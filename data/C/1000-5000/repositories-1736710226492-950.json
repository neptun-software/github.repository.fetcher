{
  "metadata": {
    "timestamp": 1736710226492,
    "page": 950,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "EnterpriseDB/repmgr",
      "stars": 1589,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.6064453125,
          "content": "# Global excludes across all subdirectories - copied from postgres\n*.o\n*.so\n*.so.[0-9]\n*.so.[0-9].[0-9]\n*.sl\n*.sl.[0-9]\n*.sl.[0-9].[0-9]\n*.dylib\n*.dll\n*.a\n*.mo\n*.pot\nobjfiles.txt\n.deps/\n*.gcno\n*.gcda\n*.gcov\n*.gcov.out\nlcov.info\ncoverage/\n*.vcproj\n*.vcxproj\nwin32ver.rc\n*.exe\nlib*dll.def\nlib*.pc\n\n# autoconf output\n/autom4te.cache/\n\n# configure output\n/Makefile\n/Makefile.global\n/config.log\n/config.status\n/config.h\n/repmgr_version.h\n\n# test output\n/results/\n/regression.diffs\n/regression.out\n\n# other\n/.lineno\n*.dSYM\n*.orig\n*.rej\n\n# generated binaries\nrepmgr\nrepmgrd\nrepmgr4\nrepmgrd4\n\n# generated files\nconfigfile-scan.c\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.2578125,
          "content": "License and Contributions\n=========================\n\n`repmgr` is licensed under the GPL v3.  All of its code and documentation is\nCopyright 2010-2021, EnterpriseDB Corporation.  See the files COPYRIGHT and LICENSE for\ndetails.\n\nThe development of repmgr has primarily been sponsored by 2ndQuadrant customers.\n\nAdditional work has been sponsored by the 4CaaST project for cloud computing,\nwhich has received funding from the European Union's Seventh Framework Programme\n(FP7/2007-2013) under grant agreement 258862.\n\nContributions to `repmgr` are welcome, and will be listed in the file `CREDITS`.\nEnterpriseDB Corporation requires that any contributions provide a copyright\nassignment and a disclaimer of any work-for-hire ownership claims from the\nemployer of the developer.  This lets us make sure that all of the repmgr\ndistribution remains free code.  Please contact info@enterprise.com for a\ncopy of the relevant Copyright Assignment Form.\n\nCode style\n----------\n\nCode in repmgr should be formatted to the same standards as the main PostgreSQL\nproject. For more details see:\n\n    https://www.postgresql.org/docs/current/source-format.html\n\nContributors should reformat their code similarly before submitting code to\nthe project, in order to minimize merge conflicts with other work.\n"
        },
        {
          "name": "COPYRIGHT",
          "type": "blob",
          "size": 0.6806640625,
          "content": "Copyright (c) 2010-2021, EnterpriseDB Corporation\nAll rights reserved.\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see https://www.gnu.org/licenses/\nto obtain one.\n"
        },
        {
          "name": "CREDITS",
          "type": "blob",
          "size": 0.5791015625,
          "content": "Code and documentation contributors to repmgr include:\n\nJaime Casanova <jaime@2ndQuadrant.com>\nSimon Riggs <simon@2ndQuadrant.com>\nGreg Smith <greg@2ndQuadrant.com>\nRobert J. Noles <rj@2ndQuadrant.com>\nGabriele Bartolini <gabriele@2ndQuadrant.com>\nBas van Oostveen <v.oostveen@gmail.com>\nHannu Krosing <hannu@2ndQuadrant.com>\nCédric Villemain <cedric@2ndquadrant.com>\nCharles Duffy <charles@dyfis.net>\nDaniel Farina <daniel@heroku.com>\nShawn Ellis <shawn.ellis17@gmail.com>\nJay Taylor <jay@jaytaylor.com>\nChristian Kruse <christian@2ndQuadrant.com>\nKrzysztof Gajdemski <songo@debian.org.pl>\n"
        },
        {
          "name": "FAQ.md",
          "type": "blob",
          "size": 0.37890625,
          "content": "FAQ - Frequently Asked Questions about repmgr\n=============================================\n\nThe repmgr 4 FAQ is located here: [repmgr FAQ (Frequently Asked Questions)](https://repmgr.org/docs/current/appendix-faq.html \"repmgr FAQ\")\n\nThe repmgr 3.x FAQ can be found here:\n\n    https://github.com/EnterpriseDB/repmgr/blob/REL3_3_STABLE/FAQ.md\n\nNote that repmgr 3.x is no longer supported.\n"
        },
        {
          "name": "HISTORY",
          "type": "blob",
          "size": 33.9599609375,
          "content": "5.5.0   2024-11-20\n        Support for PostgreSQL 17 added\n        Fix warnings detected by the -Wshadow=compatible-local\n          added in PostgreSQL 16\n\n5.4.1   2023-07-04\n        repmgrd: ensure witness node metadata is updated (Ian)\n\n5.4.0   2023-03-16\n        Support cloning replicas using pg-backup-api\n\n5.3.3   2022-10-17\n        Support for PostgreSQL added\n        repmgrd: ensure event notification script is called for event\n          \"repmgrd_upstream_disconnect\"; GitHub #760 (Ian)\n\n5.3.2   2022-05-25\n        standby clone: don't error out if unable to determine cluster size (Ian)\n        node check: fix --downstream --nagios output; GitHub #749 (Ian)\n        repmgrd: ensure witness node marked active (hslightdb)\n        repmgrd: improve walsender disable check (Ian)\n        general: ensure replication slots can be dropped by a\n          replication-only user (Ian)\n\n5.3.1   2022-02-15\n        repmgrd: fixes for potential connection leaks (hslightdb)\n        repmgr: fix upgrade path from repmgr 4.2 and 4.3 to repmgr 5.3 (Ian)\n\n5.3.0   2021-10-12\n        standby switchover: improve handling of node rejoin failure (Ian)\n        repmgrd: prefix all shared library functions with \"repmgr_\" to\n          minimize the risk of clashes with other shared libraries (Ian)\n        repmgrd: at startup, if node record is marked as \"inactive\", attempt\n          to set it to \"active\" (Ian)\n        standby clone: set \"slot_name\" in node record if required (Ian)\n        node rejoin: emit rejoin target note information as NOTICE (Ian)\n        repmgrd: ensure short option \"-s\" is accepted (Ian)\n\n5.2.1   2020-12-07\n        config: fix parsing of \"replication_type\"; GitHub #672 (Ian)\n        standby clone: handle missing \"postgresql.auto.conf\" (Ian)\n        standby clone: add option --recovery-min-apply-delay (Ian)\n        standby clone: fix data directory permissions handling for\n          PostgreSQL 11 and later (Ian)\n        repmgrd: prevent termination when local node not available and\n          standby_disconnect_on_failover; GitHub #675 (Ian)\n        repmgrd: ensure reconnect_interval\" is correctly handled;\n          GitHub #673 (Ian)\n\n5.2.0   2020-10-22\n        general: add support for PostgreSQL 13 (Ian)\n        general: remove support for PostgreSQL 9.3 (Ian)\n        config: add support for file inclusion directives (Ian)\n        repmgr: \"primary unregister --force\" will unregister an active primary\n          with no registered standby nodes (Ian)\n        repmgr: add option --verify-backup to \"standby clone\" (Ian)\n        repmgr: \"standby clone\" honours --waldir option if set in\n          \"pg_basebackup_options\" (Ian)\n        repmgr: add option --db-connection to \"node check\" (Ian)\n        repmgr: report database connection error if the --optformat option was\n          provided to \"node check\" (Ian)\n        repmgr: improve \"node rejoin\" checks (Ian)\n        repmgr: enable \"node rejoin\" to join a target with a lower timeline (Ian)\n        repmgr: support pg_rewind's automatic crash recovery in Pg13 and later (Ian)\n        repmgr: improve output formatting for cluster matrix/crosscheck (Ian)\n        repmgr: improve database connection failure error checking on the\n          demotion candidate during \"standby switchover\" (Ian)\n        repmgr: make repmgr metadata tables dumpable (Ian)\n        repmgr: fix issue with tablespace mapping when cloning from Barman;\n          GitHub #650 (Ian)\n        repmgr: improve handling of pg_control read errors (Ian)\n        repmgrd: add additional optional parameters to \"failover_validation command\"\n          (spaskalev; GitHub #651)\n        repmgrd: ensure primary connection is reset if same as upstream;\n          GitHub #633 (Ian)\n\n5.1.0   2020-04-13\n        repmgr: remove BDR 2.x support\n        repmgr: don't query upstream's data directory (Ian)\n        repmgr: rename --recovery-conf-only to --replication-conf-only (Ian)\n        repmgr: ensure postgresql.auto.conf is created with correct permissions (Ian)\n        repmgr: minimize requirement to check upstream data directory location\n          during \"standby clone\" (Ian)\n        repmgr: warn about missing pg_rewind prerequisites when executing\n          \"standby clone\" (Ian)\n        repmgr: add --upstream option to \"node check\"\n        repmgr: report error code on follow/rejoin failure due to non-available\n          replication slot (Ian)\n        repmgr: ensure \"node rejoin\" checks for available replication slots (Ian)\n        repmgr: improve \"standby switchover\" completion checks (Ian)\n        repmgr: add replication configuration file ownership check to\n          \"standby switchover\" (Ian)\n        repmgr: check the demotion candidate's registered repmgr.conf file can\n          be found (laixiong; GitHub 615)\n        repmgr: consolidate replication connection code (Ian)\n        repmgr: check permissions for \"pg_promote()\" and fall back to pg_ctl\n          if necessary (Ian)\n        repmgr: in --dry-run mode, display promote command which will be used (Ian)\n        repmgr: enable \"service_promote_command\" in PostgreSQL 12 (Ian)\n        repmgr: accept option -S/--superuser for \"node check\"; GitHub #612 (Ian)\n\n5.0     2019-10-15\n        general: add PostgreSQL 12 support (Ian)\n        general: parse configuration file using flex (Ian)\n        repmgr: rename \"repmgr daemon ...\" commands to \"repmgr service ...\" (Ian)\n        repmgr: improve data directory check (Ian)\n        repmgr: improve extension check during \"standby clone\" (Ian)\n\t\trepmgr: pass provided log level when executing repmgr remotely (Ian)\n        repmgrd: fix handling of upstream node change check (Ian)\n\n4.4     2019-06-27\n        repmgr: improve \"daemon status\" output (Ian)\n        repmgr: add \"--siblings-follow\" option to \"standby promote\" (Ian)\n        repmgr: add \"--repmgrd-force-unpause\" option to \"standby switchover\" (Ian)\n        repmgr: fix data directory permissions issue in barman mode where\n          an existing directory is being overwritten (Ian)\n        repmgr: improve \"--dry-run\" behaviour for \"standby promote\" and\n          \"standby switchover\" (Ian)\n        repmgr: when running \"standby clone\" with the \"--upstream-conninfo\" option\n          ensure that \"application_name\" is set correctly in \"primary_conninfo\" (Ian)\n        repmgr: ensure \"--dry-run\" together with --force when running \"standby clone\"\n          in barman mode does not modify an existing data directory (Ian)\n        repmgr: improve \"--dry-run\" output when running \"standby clone\" in\n          basebackup mode (Ian)\n        repmgr: improve upstream walsender checks when running \"standby clone\" (Ian)\n        repmgr: display node timeline ID in \"cluster show\" output (Ian)\n        repmgr: in \"cluster show\" and \"daemon status\", show upstream node name\n          as reported by each individual node (Ian)\n        repmgr: in \"cluster show\" and \"daemon status\", check if a node is attached\n          to its advertised upstream node\n        repmgr: use --compact rather than --terse option in \"cluster event\" (Ian)\n        repmgr: prevent a standby being cloned from a witness server (Ian)\n        repmgr: prevent a witness server being registered on the cluster primary (John)\n        repmgr: ensure BDR2-specific functionality cannot be used on\n          BDR3 and later (Ian)\n        repmgr: canonicalize the data directory path (Ian)\n        repmgr: note that \"standby follow\" requires a primary to be available (Ian)\n        repmgrd: monitor standbys attached to primary (Ian)\n        repmgrd: add \"primary visibility consensus\" functionality (Ian)\n        repmgrd: fix memory leak which occurs while the monitored PostgreSQL\n           node is not running (Ian)\n        general: documentation converted to DocBook XML format (Ian)\n\n4.3     2019-04-02\n        repmgr: add \"daemon (start|stop)\" command; GitHub #528 (Ian)\n        repmgr: add --version-number command line option (Ian)\n        repmgr: add --compact option to \"cluster show\"; GitHub #521 (Ian)\n        repmgr: cluster show - differentiate between unreachable nodes\n          and nodes which are running but rejecting connections (Ian)\n        repmgr: add --dry-run option to \"standby promote\"; GitHub #522 (Ian)\n        repmgr: add \"node check --data-directory-config\"; GitHub #523 (Ian)\n        repmgr: prevent potential race condition in \"standby switchover\"\n          when checking received WAL location; GitHub #518 (Ian)\n        repmgr: ensure \"standby switchover\" verifies repmgr can read the\n          data directory on the demotion candidate; GitHub #523 (Ian)\n        repmgr: ensure \"standby switchover\" verifies replication connection\n          exists; GitHub #519 (Ian)\n        repmgr: add sanity check for correct extension version (Ian)\n        repmgr: ensure \"witness register --dry-run\" does not attempt to read node\n          tables if repmgr extension not installed; GitHub #513 (Ian)\n        repmgr: ensure \"standby register\" fails when --upstream-node-id is the\n          same as the local node ID (Ian)\n        repmgrd: check binary and extension major versions match; GitHub #515 (Ian)\n        repmgrd: on a cascaded standby, don't fail over if \"failover=manual\";\n          GitHub #531 (Ian)\n        repmgrd: don't consider nodes where repmgrd is not running as promotion\n          candidates (Ian)\n        repmgrd: add option \"connection_check_type\" (Ian)\n        repmgrd: improve witness monitoring when primary node not available (Ian)\n\t\trepmgrd: handle situation where a primary has unexpectedly appeared\n\t\t  during failover; GitHub #420 (Ian)\n\t\tgeneral: fix Makefile (John)\n\n4.2     2018-10-24\n        repmgr: add parameter \"shutdown_check_timeout\" for use by \"standby switchover\";\n          GitHub #504 (Ian)\n        repmgr: add \"--node-id\" option to \"repmgr cluster cleanup\"; GitHub #493 (Ian)\n        repmgr: report unreachable nodes when running \"repmgr cluster (matrix|crosscheck);\n          GitHub #246 (Ian)\n        repmgr: add configuration file parameter \"repmgr_bindir\"; GitHub #246 (Ian)\n        repmgr: fix \"Missing replication slots\" label in \"node check\"; GitHub #507 (Ian)\n        repmgrd: fix parsing of -d/--daemonize option (Ian)\n        repmgrd: support \"pausing\" of repmgrd (Ian)\n\n4.1.1   2018-09-05\n        logging: explicitly log the text of failed queries as ERRORs to\n          assist logfile analysis; GitHub #498\n        repmgr: truncate version string, if necessary; GitHub #490 (Ian)\n        repmgr: improve messages emitted during \"standby promote\" (Ian)\n        repmgr: \"standby clone\" - don't copy external config files in --dry-run\n          mode; GitHub #491 (Ian)\n        repmgr: add \"cluster_cleanup\" event; GitHub #492 (Ian)\n        repmgr: (standby switchover) improve detection of free walsenders;\n          GitHub #495 (Ian)\n        repmgr: (node rejoin) improve replication slot handling; GitHub #499 (Ian)\n        repmgrd: ensure that sending SIGHUP always results in the log file\n          being reopened; GitHub #485 (Ian)\n        repmgrd: report version number *after* logger initialisation; GitHub #487 (Ian)\n        repmgrd: fix startup on witness node when local data is stale; GitHub #488/#489 (Ian)\n        repmgrd: improve cascaded standby failover handling; GitHub #480 (Ian)\n        repmgrd: improve reconnection handling (Ian)\n\n4.1.0   2018-07-31\n        repmgr: change default log_level to INFO, add documentation; GitHub #470 (Ian)\n        repmgr: add \"--missing-slots\" check to \"repmgr node check\" (Ian)\n        repmgr: improve command line error handling; GitHub #464 (Ian)\n        repmgr: fix \"standby register --wait-sync\" when no timeout provided (Ian)\n        repmgr: \"cluster show\" returns non-zero value if an issue encountered;\n          GitHub #456 (Ian)\n        repmgr: \"node check\" and \"node status\" returns non-zero value if an issue\n           encountered (Ian)\n        repmgr: add CSV output mode to \"cluster event\"; GitHub #471 (Ian)\n        repmgr: add -q/--quiet option to suppress non-error output; GitHub #468 (Ian)\n        repmgr: \"node status\" returns non-zero value if an issue encountered (Ian)\n        repmgr: enable \"recovery_min_apply_delay\" to be 0; GitHub #448 (Ian)\n        repmgr: \"cluster cleanup\" - add missing help options; GitHub #461/#462 (gclough)\n        repmgr: ensure witness node follows new primary after switchover;\n          GitHub #453 (Ian)\n        repmgr: fix witness node handling in \"node check\"/\"node status\";\n          GitHub #451 (Ian)\n        repmgr: fix \"primary_slot_name\" when using \"standby clone\" with --recovery-conf-only;\n          GitHub #474 (Ian)\n        repmgr: don't perform a switchover if an exclusive backup is running;\n          GitHub #476 (Martín)\n        repmgr: enable \"witness unregister\" to be run on any node; GitHub #472 (Ian)\n        repmgrd: create a PID file by default; GitHub #457 (Ian)\n        repmgrd: daemonize process by default; GitHub #458 (Ian)\n\n4.0.6   2018-06-14\n        repmgr: (witness register) prevent registration of a witness server with the\n          same name as an existing node (Ian)\n        repmgr: (standby follow) check node has actually connected to new primary\n          before reporting success; GitHub #444 (Ian)\n        repmgr: (standby clone) improve handling of external configuration file copying,\n          including consideration in --dry-run check; GitHub #443 (Ian)\n        repmgr: (standby clone) don't require presence of \"user\" parameter in\n          conninfo string; GitHub #437 (Ian)\n        repmgr: (standby clone) improve documentation of --recovery-conf-only\n          mode; GitHub #438 (Ian)\n        repmgr: (node rejoin) fix bug when parsing --config-files parameter;\n          GitHub #442 (Ian)\n        repmgr: when using --dry-run, force log level to INFO to ensure output\n          will always be displayed; GitHub #441 (Ian)\n        repmgr: (cluster matrix/crosscheck) return non-zero exit code if node\n           connection issues detected; GitHub #447 (Ian)\n        repmgrd: ensure local node is counted as quorum member; GitHub #439 (Ian)\n\n4.0.5   2018-05-02\n        repmgr: poll demoted primary after restart as a standby during a\n          switchover operation; GitHub #408 (Ian)\n        repmgr: add configuration parameter \"config_directory\"; GitHub #424 (Ian)\n        repmgr: add \"dbname=replication\" to all replication connection strings;\n          GitHub #421 (Ian)\n        repmgr: add sanity check if --upstream-node-id not supplied when executing\n          \"standby register\"; GitHub #395 (Ian)\n        repmgr: enable provision of \"archive_cleanup_command\" in recovery.conf;\n          GitHub #416 (Ian)\n        repmgr: actively check for node to rejoin cluster; GitHub #415 (Ian)\n        repmgr: enable pg_rewind to be used with PostgreSQL 9.3/9.4; GitHub #413 (Ian)\n        repmgr: fix minimum accepted value for \"degraded_monitoring_timeout\";\n          GitHub #411 (Ian)\n        repmgr: fix superuser password handling; GitHub #400 (Ian)\n        repmgr: fix parsing of \"archive_ready_critical\" configuration file\n          parameter; GitHub #426 (Ian)\n        repmgr: fix display of conninfo parsing error messages (Ian)\n        repmgr: fix \"repmgr cluster crosscheck\" output; GitHub #389 (Ian)\n        repmgrd: prevent standby connection handle from going stale (Ian)\n        repmgrd: fix memory leaks in witness code; GitHub #402 (AndrzejNowicki, Martín)\n        repmgrd: handle \"pg_ctl promote\" timeout; GitHub #425 (Ian)\n        repmgrd: handle failover situation with only two nodes in the primary\n          location, and at least one node in another location; GitHub #407 (Ian)\n        repmgrd: set \"connect_timeout=2\" when pinging a server (Ian)\n\n4.0.4   2018-03-09\n        repmgr: add \"standby clone --recovery-conf-only\" option; GitHub #382 (Ian)\n        repmgr: make \"standby promote\" timeout values configurable; GitHub #387 (Ian)\n        repmgr: improve replication slot warnings generated by \"node status\";\n          GitHub #385 (Ian)\n        repmgr: remove restriction on replication slots when cloning from\n          a Barman server; GitHub #379 (Ian)\n        repmgr: ensure \"node rejoin\" honours \"--dry-run\" option; GitHub #383 (Ian)\n        repmgr: fix --superuser handling when cloning a standby; GitHub #380 (Ian)\n        repmgr: update various help options; GitHub #391, #392 (hasegeli)\n        repmgrd: add event \"repmgrd_shutdown\"; GitHub #393 (Ian)\n        repmgrd: improve detection of status change from primary to standby (Ian)\n        repmgrd: improve log output in various situations (Ian)\n        repmgrd: improve reconnection to the local node after a failover (Ian)\n        repmgrd: ensure witness server connects to new primary after a failover (Ian)\n\n4.0.3   2018-02-15\n        repmgr: improve switchover handling when \"pg_ctl\" used to control the\n          server and logging output is not explicitly redirected (Ian)\n        repmgr: improve switchover log messages and exit code when old primary could\n          not be shut down cleanly (Ian)\n        repmgr: check demotion candidate can make a replication connection to the\n          promotion candidate before executing a switchover; GitHub #370 (Ian)\n        repmgr: add check for sufficient walsenders/replication slots before executing\n          a switchover; GitHub #371 (Ian)\n        repmgr: add --dry-run mode to \"repmgr standby follow\"; GitHub #368 (Ian)\n        repmgr: provide information about the primary node for \"standby_register\" and\n          \"standby_follow\" event notifications; GitHub #375 (Ian)\n        repmgr: add \"standby_register_sync\" event notification; GitHub #374 (Ian)\n        repmgr: output any connection error messages in \"cluster show\"'s list of\n          warnings; GitHub #369 (Ian)\n        repmgr: ensure an inactive data directory can be deleted; GitHub #366 (Ian)\n        repmgr: fix upstream node display in \"repmgr node status\"; GitHub #363 (fanf2)\n        repmgr: improve/clarify documentation and update --help output for\n          \"primary unregister\"; GitHub #373 (Ian)\n        repmgr: allow replication slots when Barman is configured; GitHub #379 (Ian)\n        repmgr: fix parsing of \"pg_basebackup_options\"; GitHub #376 (Ian)\n        repmgr: ensure \"pg_subtrans\" directory is created when cloning a standby in\n          Barman mode (Ian)\n        repmgr: fix primary node check in \"witness register\"; GitHub #377 (Ian)\n\n4.0.2   2018-01-18\n        repmgr: add missing -W option to getopt_long() invocation; GitHub #350 (Ian)\n        repmgr: automatically create slot name if missing; GitHub #343 (Ian)\n        repmgr: fixes to parsing output of remote repmgr invocations; GitHub #349 (Ian)\n        repmgr: BDR support - create missing connection replication set\n          if required; GitHub #347 (Ian)\n        repmgr: handle missing node record in \"repmgr node rejoin\"; GitHub #358 (Ian)\n        repmgr: enable documentation to be build as single HTML file; GitHub #353 (fanf2)\n        repmgr: recognize \"--terse\" option for \"repmgr cluster event\"; GitHub #360 (Ian)\n        repmgr: add \"--wait-start\" option for \"repmgr standby register\"; GitHub #356 (Ian)\n        repmgr: add \"%p\" event notification parameter for \"repmgr standby switchover\"\n          containing the node ID of the demoted primary (Ian)\n        docs: various fixes and updates (Ian, Daymel, Martín, ams)\n\n4.0.1   2017-12-13\n        repmgr: ensure \"repmgr node check --action=\" returns appropriate return\n          code; GitHub #340 (Ian)\n        repmgr: add missing schema qualification in get_all_node_records_with_upstream()\n          query GitHub #341 (Martín)\n        repmgr: initialise \"voting_term\" table in application, not extension SQL;\n          GitHub #344 (Ian)\n        repmgr: delete any replication slots copied by pg_rewind; GitHub #334 (Ian)\n        repmgr: fix configuration file sanity check; GitHub #342 (Ian)\n\n4.0.0   2017-11-21\n        Complete rewrite with many changes; for details see the repmgr 4.0.0 release\n        notes at: https://repmgr.org/docs/4.0/release-4.0.0.html\n\n3.3.2   2017-06-01\n        Add support for PostgreSQL 10 (Ian)\n        repmgr: ensure --replication-user option is honoured when passing database\n          connection parameters as a conninfo string (Ian)\n        repmgr: improve detection of pg_rewind on remote server (Ian)\n        repmgr: add DETAIL log output for additional clarification of error messages (Ian)\n        repmgr: suppress various spurious error messages in `standby follow` and\n          `standby switchover` (Ian)\n        repmgr: add missing `-P` option (Ian)\n        repmgrd: monitoring statistic reporting fixes (Ian)\n\n3.3.1   2017-03-13\n        repmgrd: prevent invalid apply lag value being written to the\n          monitoring table (Ian)\n        repmgrd: fix error in XLogRecPtr conversion when calculating\n          monitoring statistics (Ian)\n        repmgr: if replication slots in use, where possible delete slot on old\n          upstream node after following new upstream (Ian)\n        repmgr: improve logging of rsync actions (Ian)\n        repmgr: improve `standby clone` when synchronous replication in use (Ian)\n        repmgr: stricter checking of allowed node id values\n        repmgr: enable `master register --force` when there is a foreign key\n          dependency from a standby node (Ian)\n\n3.3     2016-12-27\n        repmgr: always log to STDERR even if log facility defined (Ian)\n        repmgr: add --log-to-file to log repmgr output to the defined\n          log facility (Ian)\n        repmgr: improve handling of command line parameter errors (Ian)\n        repmgr: add option --upstream-conninfo to explicitly set\n          'primary_conninfo' in recovery.conf (Ian)\n        repmgr: enable a standby to be registered which isn't running (Ian)\n        repmgr: enable `standby register --force` to update a node record\n          with cascaded downstream node records (Ian)\n        repmgr: add option `--no-conninfo-password` (Abhijit, Ian)\n        repmgr: add initial support for PostgreSQL 10.0 (Ian)\n        repmgr: escape values in primary_conninfo if needed (Ian)\n\n3.2.1   2016-10-24\n        repmgr: require a valid repmgr cluster name unless -F/--force\n          supplied (Ian)\n        repmgr: check master server is registered with repmgr before\n          cloning (Ian)\n        repmgr: ensure data directory defaults to that of the source node (Ian)\n        repmgr: various fixes to Barman cloning mode (Gianni, Ian)\n        repmgr: fix `repmgr cluster crosscheck` output (Ian)\n\n3.2     2016-10-05\n        repmgr: add support for cloning from a Barman backup (Gianni)\n        repmgr: add commands `standby matrix` and `standby crosscheck` (Gianni)\n        repmgr: suppress connection error display in `repmgr cluster show`\n          unless `--verbose` supplied (Ian)\n        repmgr: add commands `witness register` and `witness unregister` (Ian)\n        repmgr: enable `standby unregister` / `witness unregister` to be\n          executed for a node which is not running (Ian)\n        repmgr: remove deprecated command line options --initdb-no-pwprompt and\n           -l/--local-port (Ian)\n        repmgr: before cloning with pg_basebackup, check that sufficient free\n           walsenders are available (Ian)\n        repmgr: add option `--wait-sync` for `standby register` which causes\n           repmgr to wait for the registered node record to synchronise to\n           the standby (Ian)\n        repmgr: add option `--copy-external-config-files` for files outside\n           of the data directory (Ian)\n        repmgr: only require `wal_keep_segments` to be set in certain corner\n           cases (Ian)\n        repmgr: better support cloning from a node other than the one to\n           stream from (Ian)\n        repmgrd: add configuration options to override the default pg_ctl\n           commands (Jarkko Oranen, Ian)\n        repmgrd: don't start if node is inactive and failover=automatic (Ian)\n        packaging: improve \"repmgr-auto\" Debian package (Gianni)\n\n\n3.1.5   2016-08-15\n        repmgrd: in a failover situation, prevent endless looping when\n          attempting to establish the status of a node with\n          `failover=manual` (Ian)\n        repmgrd: improve handling of failover events on standbys with\n          `failover=manual`, and create a new event notification\n          for this, `standby_disconnect_manual` (Ian)\n        repmgr: add further event notifications (Gianni)\n        repmgr: when executing `standby switchover`, don't collect remote\n          command output unless required (Gianni, Ian)\n        repmgrd: improve standby monitoring query (Ian, based on suggestion\n          from  Álvaro)\n        repmgr: various command line handling improvements (Ian)\n\n3.1.4   2016-07-12\n        repmgr: new configuration option for setting \"restore_command\"\n          in the recovery.conf file generated by repmgr (Martín)\n        repmgr: add --csv option to \"repmgr cluster show\" (Gianni)\n        repmgr: enable provision of a conninfo string as the -d/--dbname\n          parameter, similar to other PostgreSQL utilities (Ian)\n        repmgr: during switchover operations improve detection of\n          demotion candidate shutdown (Ian)\n        various bugfixes and documentation updates (Ian, Martín)\n\n3.1.3   2016-05-17\n        repmgrd: enable monitoring when a standby is catching up by\n          replaying archived WAL (Ian)\n        repmgrd: when upstream_node_id is NULL, assume upstream node\n          to be current master (Ian)\n        repmgrd: check for reappearance of the master node if standby\n          promotion fails (Ian)\n        improve handling of rsync failure conditions (Martín)\n\n3.1.2   2016-04-12\n        Fix pg_ctl path generation in do_standby_switchover() (Ian)\n        Regularly sync witness server repl_nodes table (Ian)\n        Documentation improvements (Gianni, dhyannataraj)\n        (Experimental) ensure repmgr handles failover slots when copying\n          in rsync mode (Craig, Ian)\n        rsync mode handling fixes (Martín)\n        Enable repmgr to compile against 9.6devel (Ian)\n\n3.1.1   2016-02-24\n        Add '-P/--pwprompt' option for \"repmgr create witness\" (Ian)\n        Prevent repmgr/repmgrd running as root (Ian)\n\n3.1.0   2016-02-01\n        Add \"repmgr standby switchover\" command (Ian)\n        Revised README file (Ian)\n        Remove requirement for 'archive_mode' to be enabled (Ian)\n        Improve -?/--help output, showing default values if relevant (Ian)\n        Various bugfixes to command line/configuration parameter handling (Ian)\n\n3.0.3   2016-01-04\n        Create replication slot if required before base backup is run (Abhijit)\n        standy clone: when using rsync, clean up \"pg_replslot\" directory (Ian)\n        Improve --help output (Ian)\n        Improve config file parsing (Ian)\n        Various logging output improvements, including explicit HINTS (Ian)\n        Add --log-level to explicitly set log level on command line (Ian)\n        Repurpose --verbose to display extra log output (Ian)\n        Add --terse to hide hints and other non-critical output (Ian)\n        Reference internal functions with explicit catalog path (Ian)\n        When following a new primary, have repmgr (not repmgrd) create the new slot (Ian)\n        Add /etc/repmgr.conf as a default configuration file location (Ian)\n        Prevent repmgrd's -v/--verbose option expecting a parameter (Ian)\n        Prevent invalid replication_lag values being written to the monitoring table (Ian)\n        Improve repmgrd behaviour when monitored standby node is temporarily\n          unavailable (Martín)\n\n3.0.2   2015-10-02\n        Improve handling of --help/--version options; and improve help output (Ian)\n        Improve handling of situation where logfile can't be opened (Ian)\n        Always pass -D/--pgdata option to pg_basebackup (Ian)\n        Bugfix: standby clone --force does not empty pg_xlog (Gianni)\n        Bugfix: autofailover with reconnect_attempts > 1 (Gianni)\n        Bugfix: ignore comments after values (soxwellfb)\n        Bugfix: handle string values in 'node' parameter correctly (Gregory Duchatelet)\n        Allow repmgr to be compiled with a newer libpq (Marco)\n        Bugfix: call update_node_record_set_upstream() for STANDBY FOLLOW (Tomas)\n        Update `repmgr --help` output (per Github report from renard)\n        Update tablespace remapping in --rsync-only mode for 9.5 and later (Ian)\n        Deprecate `-l/--local-port` option - the port can be extracted\n          from the conninfo string in repmgr.conf (Ian)\n        Add STANDBY UNREGISTER (Vik Fearing)\n        Don't fail with error when registering master if schema already defined (Ian)\n        Fixes to whitespace handling when parsing config file (Ian)\n\n3.0.1   2015-04-16\n        Prevent repmgrd from looping infinitely if node was not registered (Ian)\n        When promoting a standby, have repmgr (not repmgrd) handle metadata updates (Ian)\n        Re-use replication slot if it already exists (Ian)\n        Prevent a test SSH connection being made when not needed (Ian)\n        Correct monitoring table column names (Ian)\n\n3.0     2015-03-27\n        Require PostgreSQL 9.3 or later (Ian)\n        Use `pg_basebackup` by default (instead of `rsync`) to clone standby servers (Ian)\n        Use `pg_ctl promote` to promote a standby to primary\n        Enable tablespace remapping using `pg_basebackup` (in PostgreSQL 9.3 with `rsync`) (Ian)\n        Support cascaded standbys (Ian)\n        \"pg_bindir\" no longer required as a configuration parameter (Ian)\n        Enable replication slots to be used (PostgreSQL 9.4 and later (Ian)\n        Command line option \"--check-upstream-config\" (Ian)\n        Add event logging table and option to execute an external program when an event occurs (Ian)\n        General usability and logging message improvements (Ian)\n        Code consolidation and cleanup (Ian)\n\n2.0.3   2015-04-16\n        Add -S/--superuser option for witness database creation Ian)\n        Add -c/--fast-checkpoint option for cloning (Christoph)\n        Add option \"--initdb-no-pwprompt\" (Ian)\n\n2.0.2   2015-02-17\n        Add \"--checksum\" in rsync when using \"--force\" (Jaime)\n        Use createdb/createuser instead of psql (Jaime)\n        Fixes to witness creation and monitoring (wamonite)\n        Use default master port if none supplied (Martín)\n        Documentation fixes and improvements (Ian)\n\n2.0.1   2014-07-16\n        Documentation fixes and new QUICKSTART file (Ian)\n        Explicitly specify directories to ignore when cloning (Ian)\n        Fix log level for some log messages (Ian)\n        RHEL/CentOS specfile, init script and Makefile fixes (Nathan Van Overloop)\n        Debian init script and config file documentation fixes (József Kószó)\n        Typo fixes (Riegie Godwin Jeyaranchen, PriceChild)\n\n2.0stable 2014-01-30\n        Documentation fixes (Christian)\n        General refactoring, code quality improvements and stabilization work (Christian)\n        Added proper daemonizing (-d/--daemonize) (Christian)\n        Added PID file handling (-p/--pid-file) (Christian)\n        New config option: monitor_interval_secs (Christian)\n        New config option: retry_promote_interval (Christian)\n        New config option: logfile (Christian)\n        New config option: pg_bindir (Christian)\n        New config option: pgctl_options (Christian)\n\n2.0beta2 2013-12-19\n        Improve autofailover logic and algorithms (Jaime, Andres)\n        Ignore pg_log when cloning (Jaime)\n        Add timestamps to log line in stderr (Christian)\n        Correctly check wal_keep_segments (Jay Taylor)\n        Add a ssh_options parameter (Jay Taylor)\n\n2.0beta1 2012-07-27\n        Make CLONE command try to make an exact copy including $PGDATA location (Cedric)\n        Add detection of master failure (Jaime)\n        Add the notion of a witness server (Jaime)\n        Add autofailover capabilities (Jaime)\n        Add a configuration parameter to indicate the script to execute on failover or follow (Jaime)\n        Make the monitoring optional and turned off by default, it can be turned on with --monitoring-history switch (Jaime)\n        Add tunables to specify number of retries to reconnect to master and the time between them (Jaime)\n\n1.2.0   2012-07-27\n        Test ssh connection before trying to rsync (Cédric)\n        Add CLUSTER SHOW command (Carlo)\n        Add CLUSTER CLEANUP command (Jaime)\n        Add function write_primary_conninfo (Marco)\n        Teach repmgr how to get tablespace's location in different pg version (Jaime)\n        Improve version message (Carlo)\n\n1.1.1   2012-04-18\n        Add --ignore-rsync-warning (Cédric)\n        Add strnlen for compatibility with OS X (Greg)\n        Improve performance of the repl_status view (Jaime)\n        Remove last argument from log_err (Jaime, Reported by Jeroen Dekkers)\n        Complete documentation about possible error conditions (Jaime)\n        Document how to clean history (Jaime)\n\n1.1.0   2011-03-09\n        Make options -U, -R and -p not mandatory (Jaime)\n\n1.1.0b1 2011-02-24\n        Fix missing \"--force\" option in help (Greg Smith)\n        Correct warning message for wal_keep_segments (Bas van Oostveen)\n        Add Debian build/usage docs (Bas, Hannu Krosing, Cedric Villemain)\n        Add Debian .deb packaging (Hannu)\n        Move configuration data into a structure (Bas, Gabriele Bartolini)\n        Make rsync options configurable (Bas)\n        Add syslog as alternate logging destination (Gabriele)\n        Change from using malloc to static memory allocations (Gabriele)\n        Add debugging messages after every query (Gabriele)\n        Parameterize schema name used for repmgr (Gabriele)\n        Avoid buffer overruns by using snprintf etc. (Gabriele)\n        Fix use of database query after close (Gabriele)\n        Add information about progress during \"standby clone\" (Gabriele)\n        Fix double free errors in repmgrd (Charles Duffy, Greg)\n        Make repmgr exit with an error code when encountering an error (Charles)\n        Standardize on error return codes, use in repmgrd too (Greg)\n        Add [un]install actions/SQL like most contrib modules (Daniel Farina)\n        Wrap all string construction and produce error on overflow (Daniel)\n        Correct freeing of memory from first_wal_segment (Daniel)\n        Allow creating recovery.conf file with a password (Daniel)\n        Inform when STANDBY CLONE sees an unused config file (Daniel)\n        Use 64-bit computation for WAL apply_lag (Greg)\n        Add info messages for database and general work done (Greg)\n        Map old verbose flag into a useful setting for the new logger (Greg)\n        Document repmgrd startup restrictions and log info about them (Greg)\n\n1.0.0   2010-12-05\n        First public release\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 34.32421875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n\n"
        },
        {
          "name": "Makefile.global.in",
          "type": "blob",
          "size": 0.9443359375,
          "content": "# -*-makefile-*-\n# Makefile.global.in\n# @configure_input@\n\n\n# Can only be built using pgxs\nUSE_PGXS=1\n\nrepmgr_abs_srcdir := @abs_srcdir@\nPG_CONFIG :=@PG_CONFIG@\nPGXS := $(shell $(PG_CONFIG) --pgxs)\n\nvpath_build=@vpath_build@\nifeq ($(vpath_build),yes)\n\tVPATH := $(repmgr_abs_srcdir)/$(repmgr_subdir)\n\tUSE_VPATH :=$(VPATH)\nendif\n\nSED=@SED@\n\nGIT_WORK_TREE=${repmgr_abs_srcdir}\nGIT_DIR=${repmgr_abs_srcdir}/.git\nexport GIT_DIR\nexport GIT_WORK_TREE\nPG_LDFLAGS=-lcurl -ljson-c\ninclude $(PGXS)\n\n-include ${repmgr_abs_srcdir}/Makefile.custom\n\nREPMGR_VERSION=$(shell awk '/^\\#define REPMGR_VERSION / { print $3; }' ${repmgr_abs_srcdir}/repmgr_version.h.in | cut -d '\"' -f 2)\nREPMGR_RELEASE_DATE=$(shell awk '/^\\#define REPMGR_RELEASE_DATE / { print $3; }' ${repmgr_abs_srcdir}/repmgr_version.h.in | cut -d '\"' -f 2)\n\nFLEX = flex\n\n##########################################################################\n#\n# Global targets and rules\n\n%.c: %.l\n\t$(FLEX) $(FLEXFLAGS) -o'$@' $<\n"
        },
        {
          "name": "Makefile.in",
          "type": "blob",
          "size": 3.6171875,
          "content": "# -*-makefile-*-\n# Makefile.in\n# @configure_input@\n\nrepmgr_subdir = .\nrepmgr_top_builddir = .\n\nMODULE_big = repmgr\n\nEXTENSION = repmgr\n\nDATA = \\\n  repmgr--unpackaged--4.0.sql \\\n  repmgr--unpackaged--5.1.sql \\\n  repmgr--unpackaged--5.2.sql \\\n  repmgr--unpackaged--5.3.sql \\\n  repmgr--4.0.sql \\\n  repmgr--4.0--4.1.sql \\\n  repmgr--4.1.sql \\\n  repmgr--4.1--4.2.sql \\\n  repmgr--4.2.sql \\\n  repmgr--4.2--4.3.sql \\\n  repmgr--4.3.sql \\\n  repmgr--4.3--4.4.sql \\\n  repmgr--4.4.sql \\\n  repmgr--4.4--5.0.sql \\\n  repmgr--5.0.sql \\\n  repmgr--5.0--5.1.sql \\\n  repmgr--5.1.sql \\\n  repmgr--5.1--5.2.sql \\\n  repmgr--5.2.sql \\\n  repmgr--5.2--5.3.sql \\\n  repmgr--5.3.sql \\\n  repmgr--5.3--5.4.sql \\\n  repmgr--5.4.sql \\\n  repmgr--5.4--5.5.sql \\\n  repmgr--5.5.sql\n\nREGRESS = repmgr_extension\n\n# Hacky workaround to install the binaries\nSCRIPTS_built = repmgr repmgrd\n\nall: \\\n\trepmgr \\\n\trepmgrd\n\n# When in development add -Werror\nPG_CPPFLAGS = -std=gnu89 -I$(includedir_internal) -I$(libpq_srcdir) -Wall -Wmissing-prototypes -Wmissing-declarations $(EXTRA_CFLAGS)\nSHLIB_LINK = $(libpq)\n\n\n\nOBJS = \\\n\trepmgr.o\n\ninclude Makefile.global\n\nifeq ($(vpath_build),yes)\n\tHEADERS = $(wildcard *.h)\nelse\n\tHEADERS_built = $(wildcard *.h)\nendif\n\n$(info Building against PostgreSQL $(MAJORVERSION))\n\nREPMGR_CLIENT_OBJS = repmgr-client.o \\\n\trepmgr-action-primary.o repmgr-action-standby.o repmgr-action-witness.o \\\n\trepmgr-action-cluster.o repmgr-action-node.o repmgr-action-service.o repmgr-action-daemon.o \\\n\tconfigdata.o configfile.o configfile-scan.o log.o strutil.o controldata.o dirutil.o compat.o \\\n\tdbutils.o sysutils.o pgbackupapi.o\nREPMGRD_OBJS = repmgrd.o repmgrd-physical.o configdata.o configfile.o configfile-scan.o log.o \\\n\tdbutils.o strutil.o controldata.o compat.o sysutils.o\n\nDATE=$(shell date \"+%Y-%m-%d\")\n\nrepmgr_version.h: repmgr_version.h.in\n\t$(SED) -E 's/REPMGR_VERSION_DATE.*\"\"/REPMGR_VERSION_DATE \"$(DATE)\"/' $< >$@; \\\n\t$(SED) -i -E 's/PG_ACTUAL_VERSION_NUM/PG_ACTUAL_VERSION_NUM $(VERSION_NUM)/' $@\n\nconfigfile-scan.c: configfile-scan.l\n\n$(REPMGR_CLIENT_OBJS): repmgr-client.h repmgr_version.h\n\nrepmgr: $(REPMGR_CLIENT_OBJS)\n\t$(CC) $(CFLAGS) $(REPMGR_CLIENT_OBJS) $(libpq_pgport) $(LDFLAGS) $(LDFLAGS_EX) $(LIBS) -o $@$(X)\n\nrepmgrd: $(REPMGRD_OBJS)\n\t$(CC) $(CFLAGS) $(REPMGRD_OBJS) $(libpq_pgport) $(LDFLAGS) $(LDFLAGS_EX) $(LIBS) -o $@$(X)\n\n$(REPMGR_CLIENT_OBJS): $(HEADERS)\n$(REPMGRD_OBJS): $(HEADERS)\n\n# Ensure Makefiles are up-to-date (should we move this to Makefile.global?)\nMakefile: Makefile.in config.status configure\n\t./config.status $@\n\nMakefile.global: Makefile.global.in config.status configure\n\t./config.status $@\n\ndoc: repmgr_version.h\n\t$(MAKE) -C doc html\n\ndoc-repmgr.html: repmgr_version.h\n\t$(MAKE) -C doc repmgr.html\n\ndoc-repmgr-A4.pdf: repmgr_version.h\n\t$(MAKE) -C doc repmgr-A4.pdf\n\ndoc-repmgr-US.pdf: repmgr_version.h\n\t$(MAKE) -C doc repmgr-US.pdf\n\ninstall-doc: doc\n\t$(MAKE) -C doc install\n\nclean: additional-clean\n\nmaintainer-clean: additional-maintainer-clean\n\nadditional-clean:\n\trm -f *.o\n\trm -f repmgr_version.h\n\t$(MAKE) -C doc clean\n\nadditional-maintainer-clean: clean\n\t$(MAKE) -C doc maintainer-clean\n\trm -f config.status config.log\n\trm -f config.h\n\trm -f repmgr_version.h\n\trm -f Makefile\n\trm -f Makefile.global\n\t@rm -rf autom4te.cache/\n\nifeq ($(MAJORVERSION),$(filter $(MAJORVERSION),9.3 9.4))\n# We must emulate SCRIPTS_built for Pg < 9.5 as PGXS doesn't support it\ninstall: install-scripts\ninstall-scripts:\n\t$(INSTALL_SCRIPT) $(SCRIPTS_built) '$(DESTDIR)$(bindir)/'\n.PHONY: install-scripts\ninstalldirs: installdirs-scripts\ninstalldirs-scripts:\n\t$(MKDIR_P) '$(DESTDIR)$(bindir)'\n.PHONY: installdirs-scripts\nendif\n\n.PHONY: doc doc-repmgr.html doc-repmgr-A4.pdf doc-repmgr-US.pdf install-doc\n"
        },
        {
          "name": "PACKAGES.md",
          "type": "blob",
          "size": 5.0224609375,
          "content": "Packaging\n=========\n\nNotes on RedHat Linux, Fedora, and CentOS Builds\n------------------------------------------------\n\nThe RPM packages of PostgreSQL put `pg_config` into the `postgresql-devel`\npackage, not the main server one.  And if you have a RPM install of PostgreSQL\n9.0, the entire PostgreSQL binary directory will not be in your PATH by default\neither.  Individual utilities are made available via the `alternatives`\nmechanism, but not all commands will be wrapped that way.  The files installed\nby repmgr will certainly not be in the default PATH for the postgres user\non such a system.  They will instead be in /usr/pgsql-9.0/bin/ on this\ntype of system.\n\nWhen building repmgr against a RPM packaged build, you may discover that some\ndevelopment packages are needed as well.  The following build errors can\noccur:\n\n    /usr/bin/ld: cannot find -lxslt\n    /usr/bin/ld: cannot find -lpam\n\nInstall the following packages to correct those:\n\n\n    yum install libxslt-devel\n    yum install pam-devel\n\nIf building repmgr as a regular user, then doing the install into the system\ndirectories using sudo, the syntax is hard.  `pg_config` won't be in root's\npath either.  The following recipe should work:\n\n    sudo PATH=\"/usr/pgsql-9.0/bin:$PATH\" make USE_PGXS=1 install\n\n\nIssues with 32 and 64 bit RPMs\n------------------------------\n\nIf when building, you receive a series of errors of this form:\n\n  /usr/bin/ld: skipping incompatible /usr/pgsql-9.0/lib/libpq.so when searching for -lpq\n\nThis is likely because you have both the 32 and 64 bit versions of the\n`postgresql90-devel` package installed.  You can check that like this:\n\n    rpm -qa --queryformat '%{NAME}\\t%{ARCH}\\n'  | grep postgresql90-devel\n\nAnd if two packages appear, one for i386 and one for x86_64, that's not supposed\nto be allowed.\n\nThis can happen when using the PGDG repo to install that package;\nhere is an example sessions demonstrating the problem case appearing:\n\n\n    # yum install postgresql-devel\n    ..\n    Setting up Install Process\n    Resolving Dependencies\n    --> Running transaction check\n    ---> Package postgresql90-devel.i386 0:9.0.2-2PGDG.rhel5 set to be updated\n    ---> Package postgresql90-devel.x86_64 0:9.0.2-2PGDG.rhel5 set to be updated\n    --> Finished Dependency Resolution\n\n    Dependencies Resolved\n\n    =========================================================================\n     Package               Arch      Version              Repository    Size\n    =========================================================================\n    Installing:\n     postgresql90-devel    i386      9.0.2-2PGDG.rhel5    pgdg90        1.5 M\n     postgresql90-devel    x86_64    9.0.2-2PGDG.rhel5    pgdg90        1.6 M\n\n\nNote how both the i386 and x86_64 platform architectures are selected for\ninstallation.  Your main PostgreSQL package will only be compatible with one of\nthose, and if the repmgr build finds the wrong postgresql90-devel these\n\"skipping incompatible\" messages appear.\n\nIn this case, you can temporarily remove both packages, then just install the\ncorrect one for your architecture.  Example:\n\n    rpm -e postgresql90-devel --allmatches\n    yum install postgresql90-devel-9.0.2-2PGDG.rhel5.x86_64\n\nInstead just deleting the package from the wrong platform might not leave behind\nthe correct files, due to the way in which these accidentally happen to interact.\nIf you already tried to build repmgr before doing this, you'll need to do:\n\n    make USE_PGXS=1 clean\n\nto get rid of leftover files from the wrong architecture.\n\nNotes on Ubuntu, Debian or other Debian-based Builds\n----------------------------------------------------\n\nThe Debian packages of PostgreSQL put `pg_config` into the development package\ncalled `postgresql-server-dev-$version`.\n\nWhen building repmgr against a Debian packages build, you may discover that some\ndevelopment packages are needed as well. You will need the following development\npackages installed:\n\n    sudo apt-get install libxslt-dev libxml2-dev libpam-dev libedit-dev\n\nIf you're using Debian packages for PostgreSQL and are building repmgr with the\nUSE_PGXS option you also need to install the corresponding development package:\n\n    sudo apt-get install postgresql-server-dev-9.0\n\nIf you build and install repmgr manually it will not be on the system path. The\nbinaries will be installed in /usr/lib/postgresql/$version/bin/ which is not on\nthe default path. The reason behind this is that Ubuntu/Debian systems manage\nmultiple installed versions of PostgreSQL on the same system through a wrapper\ncalled pg_wrapper and repmgr is not (yet) known to this wrapper.\n\nYou can solve this in many different ways, the most Debian like is to make an\nalternate for repmgr and repmgrd:\n\n    sudo update-alternatives --install /usr/bin/repmgr repmgr /usr/lib/postgresql/9.0/bin/repmgr 10\n    sudo update-alternatives --install /usr/bin/repmgrd repmgrd /usr/lib/postgresql/9.0/bin/repmgrd 10\n\nYou can also make a deb package of repmgr using:\n\n    make USE_PGXS=1 deb\n\nThis will build a Debian package one level up from where you build, normally the\nsame directory that you have your repmgr/ directory in.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.9794921875,
          "content": "repmgr: Replication Manager for PostgreSQL\n==========================================\n\n`repmgr` is a suite of open-source tools to manage replication and failover\nwithin a cluster of PostgreSQL servers. It enhances PostgreSQL's built-in\nreplication capabilities with utilities to set up standby servers, monitor\nreplication, and perform administrative tasks such as failover or switchover\noperations.\n\nThe most recent `repmgr` version (5.5.x) supports all PostgreSQL versions from\n13 to 17. Despite it could be used with some older ones, some features might not\nbe available, however, it's strongly recommended to use the latest version.\n\n`repmgr` is distributed under the GNU GPL 3 and maintained by EnterpriseDB.\n\nDocumentation\n-------------\n\nThe full `repmgr` documentation is available here:\n\n> [repmgr documentation](https://repmgr.org/docs/current/index.html)\n\nVersions\n--------\n\nFor an overview of `repmgr` versions and PostgreSQL compatibility, see the\n[repmgr compatibility matrix](https://repmgr.org/docs/current/install-requirements.html#INSTALL-COMPATIBILITY-MATRIX).\n\nFiles\n------\n\n - `CONTRIBUTING.md`: details on how to contribute to `repmgr`\n - `COPYRIGHT`: Copyright information\n - `HISTORY`: Summary of changes in each `repmgr` release\n - `LICENSE`: GNU GPL3 details\n\n\nDirectories\n-----------\n\n - `contrib/`: additional utilities\n - `doc/`: DocBook-based documentation files\n - `expected/`: expected regression test output\n - `sql/`: regression test input\n\n\nSupport and Assistance\n----------------------\n\nEnterpriseDB provides 24x7 production support for `repmgr`, including\nconfiguration assistance, installation verification and training for\nrunning a robust replication cluster. For further details see:\n\n* [EDB Support Services](https://www.enterprisedb.com/support/postgresql-support-overview-get-the-most-out-of-postgresql)\n\nThere is a mailing list/forum to discuss contributions or issues:\n\n* https://groups.google.com/group/repmgr\n\nPlease report bugs and other issues to:\n\n* https://github.com/EnterpriseDB/repmgr\n\nFurther information is available at https://repmgr.org/\n\nWe'd love to hear from you about how you use repmgr. Case studies and\nnews are always welcome.\n\nThanks from the repmgr core team.\n\n* Ian Barwick\n* Israel Barth\n* Mario González\n* Martín Marqués\n* Gianni Ciolli\n\nPast contributors:\n\n* Jaime Casanova\n* Abhijit Menon-Sen\n* Simon Riggs\n* Cedric Villemain\n\nFurther reading\n---------------\n\n* [repmgr documentation](https://repmgr.org/docs/current/index.html)\n* [How to Automate PostgreSQL 12 Replication and Failover with repmgr - Part 1](https://www.2ndquadrant.com/en/blog/how-to-automate-postgresql-12-replication-and-failover-with-repmgr-part-1/)\n* [How to Automate PostgreSQL 12 Replication and Failover with repmgr - Part 2](https://www.2ndquadrant.com/en/blog/how-to-automate-postgresql-12-replication-and-failover-with-repmgr-part-2/)\n* [How to implement repmgr for PostgreSQL automatic failover](https://www.enterprisedb.com/postgres-tutorials/how-implement-repmgr-postgresql-automatic-failover)\n"
        },
        {
          "name": "TODO.md",
          "type": "blob",
          "size": 0.68359375,
          "content": "TODO\n====\n\nThis file contains a list of improvements which are desirable and/or have\nbeen requested, and which we aim to address/implement when time and resources\npermit.\n\nIt is *not* a roadmap and there's no guarantee of any item being implemented\nwithin any given timeframe.\n\n\nEnable suspension of repmgrd failover\n-------------------------------------\n\nWhen performing maintenance, e.g. a switchover, it's necessary to stop all\nrepmgrd nodes to prevent unintended failover; this is obviously inconvenient.\nWe'll need to implement some way of notifying each repmgrd to suspend automatic\nfailover until further notice.\n\nRequested in GitHub #410 ( https://github.com/EnterpriseDB/repmgr/issues/410 )\n"
        },
        {
          "name": "compat.c",
          "type": "blob",
          "size": 3.3544921875,
          "content": "/*\n *\n * compat.c\n *\t  Provides a couple of useful string utility functions adapted\n *\t  from the backend code, which are not publicly exposed in all\n *    supported PostgreSQL versions. They're unlikely to change but\n *    it would be worth keeping an eye on them for any fixes/improvements.\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * Portions Copyright (c) 1996-2013, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include \"repmgr.h\"\n#include \"compat.h\"\n\n/*\n * Append the given string to the buffer, with suitable quoting for passing\n * the string as a value, in a keyword/pair value in a libpq connection\n * string\n *\n * This function is adapted from src/fe_utils/string_utils.c (before 9.6\n * located in: src/bin/pg_dump/dumputils.c)\n */\nvoid\nappendConnStrVal(PQExpBuffer buf, const char *str)\n{\n\tconst char *s;\n\tbool\t\tneedquotes;\n\n\t/*\n\t * If the string is one or more plain ASCII characters, no need to quote\n\t * it. This is quite conservative, but better safe than sorry.\n\t */\n\tneedquotes = true;\n\tfor (s = str; *s; s++)\n\t{\n\t\tif (!((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||\n\t\t\t  (*s >= '0' && *s <= '9') || *s == '_' || *s == '.'))\n\t\t{\n\t\t\tneedquotes = true;\n\t\t\tbreak;\n\t\t}\n\t\tneedquotes = false;\n\t}\n\n\tif (needquotes)\n\t{\n\t\tappendPQExpBufferChar(buf, '\\'');\n\t\twhile (*str)\n\t\t{\n\t\t\t/* ' and \\ must be escaped by to \\' and \\\\ */\n\t\t\tif (*str == '\\'' || *str == '\\\\')\n\t\t\t\tappendPQExpBufferChar(buf, '\\\\');\n\n\t\t\tappendPQExpBufferChar(buf, *str);\n\t\t\tstr++;\n\t\t}\n\t\tappendPQExpBufferChar(buf, '\\'');\n\t}\n\telse\n\t\tappendPQExpBufferStr(buf, str);\n}\n\n/*\n * Adapted from: src/fe_utils/string_utils.c\n */\nvoid\nappendShellString(PQExpBuffer buf, const char *str)\n{\n\tconst char *p;\n\n\tappendPQExpBufferChar(buf, '\\'');\n\tfor (p = str; *p; p++)\n\t{\n\t\tif (*p == '\\n' || *p == '\\r')\n\t\t{\n\t\t\tfprintf(stderr,\n\t\t\t\t\t_(\"shell command argument contains a newline or carriage return: \\\"%s\\\"\\n\"),\n\t\t\t\t\tstr);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tif (*p == '\\'')\n\t\t\tappendPQExpBufferStr(buf, \"'\\\"'\\\"'\");\n\t\telse if (*p == '&')\n\t\t\tappendPQExpBufferStr(buf, \"\\\\&\");\n\t\telse\n\t\t\tappendPQExpBufferChar(buf, *p);\n\t}\n\n\tappendPQExpBufferChar(buf, '\\'');\n}\n\n/*\n * Adapted from: src/fe_utils/string_utils.c\n */\nvoid\nappendRemoteShellString(PQExpBuffer buf, const char *str)\n{\n\tconst char *p;\n\n\tappendPQExpBufferStr(buf, \"\\\\'\");\n\n\tfor (p = str; *p; p++)\n\t{\n\t\tif (*p == '\\n' || *p == '\\r')\n\t\t{\n\t\t\tfprintf(stderr,\n\t\t\t\t\t_(\"shell command argument contains a newline or carriage return: \\\"%s\\\"\\n\"),\n\t\t\t\t\tstr);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tif (*p == '\\'')\n\t\t\tappendPQExpBufferStr(buf, \"'\\\"'\\\"'\");\n\t\telse if (*p == '&')\n\t\t\tappendPQExpBufferStr(buf, \"\\\\&\");\n\t\telse\n\t\t\tappendPQExpBufferChar(buf, *p);\n\t}\n\n\tappendPQExpBufferStr(buf, \"\\\\'\");\n}\n"
        },
        {
          "name": "compat.h",
          "type": "blob",
          "size": 1.095703125,
          "content": "/*\n * compat.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * Portions Copyright (c) 1996-2013, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#ifndef _COMPAT_H_\n#define _COMPAT_H_\n\nextern void appendConnStrVal(PQExpBuffer buf, const char *str);\n\nextern void appendShellString(PQExpBuffer buf, const char *str);\n\nextern void appendRemoteShellString(PQExpBuffer buf, const char *str);\n\n#endif\n"
        },
        {
          "name": "config.h.in",
          "type": "blob",
          "size": 0.0634765625,
          "content": "/* config.h.in.  Generated from configure.in by autoheader.  */\n\n"
        },
        {
          "name": "configdata.c",
          "type": "blob",
          "size": 21.8623046875,
          "content": "/*\n * configdata.c - contains structs with parsed configuration data\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"repmgr.h\"\n#include \"configfile.h\"\n\n/*\n * Parsed configuration settings are stored here\n */\nt_configuration_options config_file_options;\n\n\n/*\n * Configuration settings are defined here\n */\n\nstruct ConfigFileSetting config_file_settings[] =\n{\n\n\t/* ================\n\t * node information\n\t * ================\n\t */\n\t/* node_id */\n\t{\n\t\t\"node_id\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.node_id },\n\t\t{ .intdefault = UNKNOWN_NODE_ID },\n\t\t{ .intminval = MIN_NODE_ID },\n\t\t{},\n\t\t{}\n\t},\n\t/* node_name */\n\t{\n\t\t\"node_name\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.node_name },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.node_name) },\n\t\t{}\n\t},\n\t/* conninfo */\n\t{\n\t\t\"conninfo\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.conninfo },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.conninfo) },\n\t\t{}\n\t},\n\t/* replication_user */\n\t{\n\t\t\"replication_user\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.replication_user },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.replication_user) },\n\t\t{}\n\t},\n\t/* data_directory */\n\t{\n\t\t\"data_directory\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.data_directory },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.data_directory) },\n\t\t{ .postprocess_func = &repmgr_canonicalize_path }\n\t},\n\t/* config_directory */\n\t{\n\t\t\"config_directory\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.config_directory },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.config_directory) },\n\t\t{ .postprocess_func = &repmgr_canonicalize_path }\n\t},\n\t/* pg_bindir */\n\t{\n\t\t\"pg_bindir\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.pg_bindir },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.pg_bindir) },\n\t\t{ .postprocess_func = &repmgr_canonicalize_path }\n\t},\n\t/* repmgr_bindir */\n\t{\n\t\t\"repmgr_bindir\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.repmgr_bindir },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.repmgr_bindir) },\n\t\t{ .postprocess_func = &repmgr_canonicalize_path }\n\t},\n\t/* replication_type */\n\t{\n\t\t\"replication_type\",\n\t\tCONFIG_REPLICATION_TYPE,\n\t\t{ .replicationtypeptr = &config_file_options.replication_type },\n\t\t{ .replicationtypedefault = DEFAULT_REPLICATION_TYPE },\n\t\t{},\n\t\t{},\n\t\t{}\n\t},\n\n\t/* ================\n\t * logging settings\n\t * ================\n\t */\n\n\t/*\n\t * log_level\n\t * NOTE: the default for \"log_level\" is set in log.c and does not need\n\t * to be initialised here\n\t */\n\t{\n\t\t\"log_level\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.log_level },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.log_level) },\n\t\t{}\n\t},\n\t/* log_facility */\n\t{\n\t\t\"log_facility\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.log_facility },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.log_facility) },\n\t\t{}\n\t},\n\t/* log_file */\n\t{\n\t\t\"log_file\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.log_file },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.log_file) },\n\t\t{ .postprocess_func = &repmgr_canonicalize_path }\n\t},\n\t/* log_status_interval */\n\t{\n\t\t\"log_status_interval\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.log_status_interval },\n\t\t{ .intdefault = DEFAULT_LOG_STATUS_INTERVAL, },\n\t\t{ .intminval = 0 },\n\t\t{},\n\t\t{}\n\t},\n\t/* ======================\n\t * standby clone settings\n\t * ======================\n\t */\n\t/* use_replication_slots */\n\t{\n\t\t\"use_replication_slots\",\n\t\tCONFIG_BOOL,\n\t\t{ .boolptr = &config_file_options.use_replication_slots },\n\t\t{ .booldefault = DEFAULT_USE_REPLICATION_SLOTS },\n\t\t{},\n\t\t{},\n\t\t{}\n\t},\n\t/* pg_basebackup_options */\n\t{\n\t\t\"pg_basebackup_options\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.pg_basebackup_options },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.pg_basebackup_options) },\n\t\t{}\n\t},\n\t/* restore_command */\n\t{\n\t\t\"restore_command\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.restore_command },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.restore_command) },\n\t\t{}\n\t},\n\t/* tablespace_mapping */\n\t{\n\t\t\"tablespace_mapping\",\n\t\tCONFIG_TABLESPACE_MAPPING,\n\t\t{ .tablespacemappingptr = &config_file_options.tablespace_mapping },\n\t\t{},\n\t\t{},\n\t\t{},\n\t\t{}\n\t},\n\t/* recovery_min_apply_delay */\n\t{\n\t\t\"recovery_min_apply_delay\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.recovery_min_apply_delay },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.recovery_min_apply_delay) },\n        {\n\t\t\t.process_func = &parse_time_unit_parameter,\n\t\t\t.providedptr = &config_file_options.recovery_min_apply_delay_provided\n\t\t}\n\t},\n\n\t/* archive_cleanup_command */\n\t{\n\t\t\"archive_cleanup_command\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.archive_cleanup_command },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.archive_cleanup_command) },\n\t\t{}\n\t},\n\n\t/* use_primary_conninfo_password */\n\t{\n\t\t\"use_primary_conninfo_password\",\n\t\tCONFIG_BOOL,\n\t\t{ .boolptr = &config_file_options.use_primary_conninfo_password },\n\t\t{ .booldefault = DEFAULT_USE_PRIMARY_CONNINFO_PASSWORD },\n\t\t{},\n\t\t{},\n\t\t{}\n\t},\n\t/* passfile */\n\t{\n\t\t\"passfile\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.passfile },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.passfile) },\n\t\t{}\n\t},\n\n\t/* ======================\n\t * standby clone settings\n\t * ======================\n\t */\n\t/* promote_check_timeout */\n\t{\n\t\t\"promote_check_timeout\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.promote_check_timeout },\n\t\t{ .intdefault = DEFAULT_PROMOTE_CHECK_TIMEOUT },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* promote_check_interval */\n\t{\n\t\t\"promote_check_interval\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.promote_check_interval },\n\t\t{ .intdefault = DEFAULT_PROMOTE_CHECK_INTERVAL },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* pg_backupapi_backup_id*/\n\t{\n\t\t\"pg_backupapi_backup_id\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.pg_backupapi_backup_id },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.pg_backupapi_backup_id) },\n\t\t{}\n\t},\n\t/* pg_backupapi_host*/\n\t{\n\t\t\"pg_backupapi_host\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.pg_backupapi_host },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.pg_backupapi_host) },\n\t\t{}\n\t},\n\t/* pg_backupapi_node_name */\n\t{\n\t\t\"pg_backupapi_node_name\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.pg_backupapi_node_name },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.pg_backupapi_node_name) },\n\t\t{}\n\t},\n\t/* pg_backupapi_remote_ssh_command */\n\t{\n\t\t\"pg_backupapi_remote_ssh_command\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.pg_backupapi_remote_ssh_command },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.pg_backupapi_remote_ssh_command) },\n\t\t{}\n\t},\n\n\t/* =======================\n\t * standby follow settings\n\t * =======================\n\t */\n\t/* primary_follow_timeout */\n\t{\n\t\t\"primary_follow_timeout\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.primary_follow_timeout },\n\t\t{ .intdefault = DEFAULT_PRIMARY_FOLLOW_TIMEOUT, },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* standby_follow_timeout */\n\t{\n\t\t\"standby_follow_timeout\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.standby_follow_timeout },\n\t\t{ .intdefault = DEFAULT_STANDBY_FOLLOW_TIMEOUT },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* standby_follow_restart */\n\t{\n\t\t\"standby_follow_restart\",\n\t\tCONFIG_BOOL,\n\t\t{ .boolptr = &config_file_options.standby_follow_restart },\n\t\t{ .booldefault = DEFAULT_STANDBY_FOLLOW_RESTART },\n\t\t{},\n\t\t{},\n\t\t{}\n\t},\n\n\t/* ===========================\n\t * standby switchover settings\n\t * ===========================\n\t */\n\t/* shutdown_check_timeout */\n\t{\n\t\t\"shutdown_check_timeout\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.shutdown_check_timeout },\n\t\t{ .intdefault = DEFAULT_SHUTDOWN_CHECK_TIMEOUT },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* standby_reconnect_timeout */\n\t{\n\t\t\"standby_reconnect_timeout\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.standby_reconnect_timeout },\n\t\t{ .intdefault = DEFAULT_STANDBY_RECONNECT_TIMEOUT },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* wal_receive_check_timeout */\n\t{\n\t\t\"wal_receive_check_timeout\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.wal_receive_check_timeout },\n\t\t{ .intdefault = DEFAULT_WAL_RECEIVE_CHECK_TIMEOUT },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\n\t/* ====================\n\t * node rejoin settings\n\t * ====================\n\t */\n\t/* node_rejoin_timeout */\n\t{\n\t\t\"node_rejoin_timeout\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.node_rejoin_timeout },\n\t\t{ .intdefault = DEFAULT_NODE_REJOIN_TIMEOUT },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* ===================\n\t * node check settings\n\t * ===================\n\t */\n\t/* archive_ready_warning */\n\t{\n\t\t\"archive_ready_warning\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.archive_ready_warning },\n\t\t{ .intdefault = DEFAULT_ARCHIVE_READY_WARNING },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* archive_ready_critical */\n\t{\n\t\t\"archive_ready_critical\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.archive_ready_critical },\n\t\t{ .intdefault = DEFAULT_ARCHIVE_READY_CRITICAL },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* replication_lag_warning */\n\t{\n\t\t\"replication_lag_warning\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.replication_lag_warning },\n\t\t{ .intdefault = DEFAULT_REPLICATION_LAG_WARNING },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* replication_lag_critical */\n\t{\n\t\t\"replication_lag_critical\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.replication_lag_critical },\n\t\t{ .intdefault = DEFAULT_REPLICATION_LAG_CRITICAL },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\n\t/* ================\n\t * witness settings\n\t * ================\n\t */\n\t/* witness_sync_interval */\n\t{\n\t\t\"witness_sync_interval\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.witness_sync_interval },\n\t\t{ .intdefault = DEFAULT_WITNESS_SYNC_INTERVAL },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\n\t/* ================\n\t * repmgrd settings\n\t * ================\n\t */\n\t/* failover */\n\t{\n\t\t\"failover\",\n\t\tCONFIG_FAILOVER_MODE,\n\t\t{ .failovermodeptr = &config_file_options.failover },\n\t\t{ .failovermodedefault = FAILOVER_MANUAL },\n\t\t{},\n\t\t{},\n\t\t{}\n\t},\n\t/* location */\n\t{\n\t\t\"location\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.location },\n\t\t{ .strdefault = DEFAULT_LOCATION },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.location) },\n\t\t{}\n\t},\n\t/* priority */\n\t{\n\t\t\"priority\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.priority },\n\t\t{ .intdefault = DEFAULT_PRIORITY, },\n\t\t{ .intminval = 0 },\n\t\t{},\n\t\t{}\n\t},\n\t/* promote_command */\n\t{\n\t\t\"promote_command\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.promote_command },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.promote_command) },\n\t\t{}\n\t},\n\t/* follow_command */\n\t{\n\t\t\"follow_command\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.follow_command },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.follow_command) },\n\t\t{}\n\t},\n\t/* monitor_interval_secs */\n\t{\n\t\t\"monitor_interval_secs\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.monitor_interval_secs },\n\t\t{ .intdefault = DEFAULT_MONITORING_INTERVAL },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* reconnect_attempts */\n\t{\n\t\t\"reconnect_attempts\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.reconnect_attempts },\n\t\t{ .intdefault = DEFAULT_RECONNECTION_ATTEMPTS },\n\t\t{ .intminval = 0 },\n\t\t{},\n\t\t{}\n\t},\n\t/* reconnect_interval */\n\t{\n\t\t\"reconnect_interval\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.reconnect_interval },\n\t\t{ .intdefault = DEFAULT_RECONNECTION_INTERVAL },\n\t\t{ .intminval = 0 },\n\t\t{},\n\t\t{}\n\t},\n\n\t/* monitoring_history */\n\t{\n\t\t\"monitoring_history\",\n\t\tCONFIG_BOOL,\n\t\t{ .boolptr = &config_file_options.monitoring_history },\n\t\t{ .booldefault = DEFAULT_MONITORING_HISTORY },\n\t\t{},\n\t\t{},\n\t\t{}\n\t},\n\t/* degraded_monitoring_timeout */\n\t{\n\t\t\"degraded_monitoring_timeout\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.degraded_monitoring_timeout },\n\t\t{ .intdefault = DEFAULT_DEGRADED_MONITORING_TIMEOUT },\n\t\t{ .intminval = -1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* async_query_timeout */\n\t{\n\t\t\"async_query_timeout\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.async_query_timeout },\n\t\t{ .intdefault = DEFAULT_ASYNC_QUERY_TIMEOUT },\n\t\t{ .intminval = 0 },\n\t\t{},\n\t\t{}\n\t},\n\t/* primary_notification_timeout */\n\t{\n\t\t\"primary_notification_timeout\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.primary_notification_timeout },\n\t\t{ .intdefault = DEFAULT_PRIMARY_NOTIFICATION_TIMEOUT },\n\t\t{ .intminval = 0 },\n\t\t{},\n\t\t{}\n\t},\n\t/* repmgrd_standby_startup_timeout */\n\t{\n\t\t\"repmgrd_standby_startup_timeout\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.repmgrd_standby_startup_timeout },\n\t\t{ .intdefault = DEFAULT_REPMGRD_STANDBY_STARTUP_TIMEOUT },\n\t\t{ .intminval = 0 },\n\t\t{},\n\t\t{}\n\t},\n\t/* repmgrd_pid_file */\n\t{\n\t\t\"repmgrd_pid_file\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.repmgrd_pid_file },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.repmgrd_pid_file) },\n\t\t{ .postprocess_func = &repmgr_canonicalize_path }\n\t},\n\t/* repmgrd_exit_on_inactive_node */\n\t{\n\t\t\"repmgrd_exit_on_inactive_node\",\n\t\tCONFIG_BOOL,\n\t\t{ .boolptr = &config_file_options.repmgrd_exit_on_inactive_node},\n\t\t{ .booldefault = DEFAULT_REPMGRD_EXIT_ON_INACTIVE_NODE },\n\t\t{},\n\t\t{},\n\t\t{}\n\t},\n\t/* standby_disconnect_on_failover */\n\t{\n\t\t\"standby_disconnect_on_failover\",\n\t\tCONFIG_BOOL,\n\t\t{ .boolptr = &config_file_options.standby_disconnect_on_failover },\n\t\t{ .booldefault = DEFAULT_STANDBY_DISCONNECT_ON_FAILOVER },\n\t\t{},\n\t\t{},\n\t\t{}\n\t},\n\t/* sibling_nodes_disconnect_timeout */\n\t{\n\t\t\"sibling_nodes_disconnect_timeout\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.sibling_nodes_disconnect_timeout },\n\t\t{ .intdefault = DEFAULT_SIBLING_NODES_DISCONNECT_TIMEOUT },\n\t\t{ .intminval = 0 },\n\t\t{},\n\t\t{}\n\t},\n\t/* connection_check_type */\n\t{\n\t\t\"connection_check_type\",\n\t\tCONFIG_CONNECTION_CHECK_TYPE,\n\t\t{ .checktypeptr = &config_file_options.connection_check_type },\n\t\t{ .checktypedefault = DEFAULT_CONNECTION_CHECK_TYPE },\n\t\t{},\n\t\t{},\n\t\t{}\n\t},\n\t/* primary_visibility_consensus */\n\t{\n\t\t\"primary_visibility_consensus\",\n\t\tCONFIG_BOOL,\n\t\t{ .boolptr = &config_file_options.primary_visibility_consensus },\n\t\t{ .booldefault = DEFAULT_PRIMARY_VISIBILITY_CONSENSUS },\n\t\t{},\n\t\t{},\n\t\t{}\n\t},\n\t/* always_promote */\n\t{\n\t\t\"always_promote\",\n\t\tCONFIG_BOOL,\n\t\t{ .boolptr = &config_file_options.always_promote },\n\t\t{ .booldefault = DEFAULT_ALWAYS_PROMOTE },\n\t\t{},\n\t\t{},\n\t\t{}\n\t},\n\t/* failover_validation_command */\n\t{\n\t\t\"failover_validation_command\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.failover_validation_command },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.failover_validation_command) },\n\t\t{}\n\t},\n\t/* election_rerun_interval */\n\t{\n\t\t\"election_rerun_interval\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.election_rerun_interval },\n\t\t{ .intdefault = DEFAULT_ELECTION_RERUN_INTERVAL },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* child_nodes_check_interval */\n\t{\n\t\t\"child_nodes_check_interval\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.child_nodes_check_interval },\n\t\t{ .intdefault = DEFAULT_CHILD_NODES_CHECK_INTERVAL },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* child_nodes_disconnect_min_count */\n\t{\n\t\t\"child_nodes_disconnect_min_count\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.child_nodes_disconnect_min_count },\n\t\t{ .intdefault = DEFAULT_CHILD_NODES_DISCONNECT_MIN_COUNT },\n\t\t{ .intminval = -1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* child_nodes_connected_min_count */\n\t{\n\t\t\"child_nodes_connected_min_count\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.child_nodes_connected_min_count },\n\t\t{ .intdefault = DEFAULT_CHILD_NODES_CONNECTED_MIN_COUNT},\n\t\t{ .intminval = -1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* child_nodes_connected_include_witness */\n\t{\n\t\t\"child_nodes_connected_include_witness\",\n\t\tCONFIG_BOOL,\n\t\t{ .boolptr = &config_file_options.child_nodes_connected_include_witness },\n\t\t{ .booldefault = DEFAULT_CHILD_NODES_CONNECTED_INCLUDE_WITNESS },\n\t\t{},\n\t\t{},\n\t\t{}\n\t},\n\t/* child_nodes_disconnect_timeout */\n\t{\n\t\t\"child_nodes_disconnect_timeout\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.child_nodes_disconnect_timeout },\n\t\t{ .intdefault = DEFAULT_CHILD_NODES_DISCONNECT_TIMEOUT },\n\t\t{ .intminval = 0 },\n\t\t{},\n\t\t{}\n\t},\n\t/* child_nodes_disconnect_command */\n\t{\n\t\t\"child_nodes_disconnect_command\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.child_nodes_disconnect_command },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.child_nodes_disconnect_command) },\n\t\t{}\n\t},\n\t/* ================\n\t * service settings\n\t * ================\n\t */\n\t/* pg_ctl_options */\n\t{\n\t\t\"pg_ctl_options\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.pg_ctl_options },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.pg_ctl_options) },\n\t\t{}\n\t},\n\t/* service_start_command */\n\t{\n\t\t\"service_start_command\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.service_start_command },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.service_start_command) },\n\t\t{}\n\t},\n\t/* service_stop_command */\n\t{\n\t\t\"service_stop_command\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.service_stop_command },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.service_stop_command) },\n\t\t{}\n\t},\n\t/* service_restart_command */\n\t{\n\t\t\"service_restart_command\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.service_restart_command },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.service_restart_command) },\n\t\t{}\n\t},\n\t/* service_reload_command */\n\t{\n\t\t\"service_reload_command\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.service_reload_command },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.service_reload_command) },\n\t\t{}\n\t},\n\t/* service_promote_command */\n\t{\n\t\t\"service_promote_command\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.service_promote_command },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.service_promote_command) },\n\t\t{}\n\t},\n\n\t/* ========================\n\t * repmgrd service settings\n\t * ========================\n\t */\n\t/* repmgrd_service_start_command */\n\t{\n\t\t\"repmgrd_service_start_command\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.repmgrd_service_start_command },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.repmgrd_service_start_command) },\n\t\t{}\n\t},\n\t/* repmgrd_service_stop_command */\n\t{\n\t\t\"repmgrd_service_stop_command\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.repmgrd_service_stop_command },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.repmgrd_service_stop_command) },\n\t\t{}\n\t},\n\t/* ===========================\n\t * event notification settings\n\t * ===========================\n\t */\n\t/* event_notification_command */\n\t{\n\t\t\"event_notification_command\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.event_notification_command },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.event_notification_command) },\n\t\t{}\n\t},\n\t{\n\t\t\"event_notifications\",\n\t\tCONFIG_EVENT_NOTIFICATION_LIST,\n\t\t{ .notificationlistptr = &config_file_options.event_notifications },\n\t\t{},\n\t\t{},\n\t\t{},\n\t\t{}\n\t},\n\t/* ===============\n\t * barman settings\n\t * ===============\n\t */\n\t/* barman_host */\n\t{\n\t\t\"barman_host\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.barman_host },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.barman_host) },\n\t\t{}\n\t},\n\t/* barman_server */\n\t{\n\t\t\"barman_server\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.barman_server },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.barman_server) },\n\t\t{}\n\t},\n\t/* barman_config */\n\t{\n\t\t\"barman_config\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.barman_config },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.barman_config) },\n\t\t{}\n\t},\n\t/* ==================\n\t * rsync/ssh settings\n\t * ==================\n\t */\n\t/* rsync_options */\n\t{\n\t\t\"rsync_options\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.rsync_options },\n\t\t{ .strdefault = \"\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.rsync_options) },\n\t\t{}\n\t},\n\t/* ssh_options */\n\t{\n\t\t\"ssh_options\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.ssh_options },\n\t\t{ .strdefault = DEFAULT_SSH_OPTIONS },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.ssh_options) },\n\t\t{}\n\t},\n\t/* ==================================\n\t * undocumented experimental settings\n\t * ==================================\n\t */\n\t/* reconnect_loop_sync */\n\t{\n\t\t\"reconnect_loop_sync\",\n\t\tCONFIG_BOOL,\n\t\t{ .boolptr = &config_file_options.reconnect_loop_sync },\n\t\t{ .booldefault = false },\n\t\t{},\n\t\t{},\n\t\t{}\n\t},\n\t/* ==========================\n\t * undocumented test settings\n\t * ==========================\n\t */\n\t/* promote_delay */\n\t{\n\t\t\"promote_delay\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.promote_delay },\n\t\t{ .intdefault = 0 },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\t/* failover_delay */\n\t{\n\t\t\"failover_delay\",\n\t\tCONFIG_INT,\n\t\t{ .intptr = &config_file_options.failover_delay },\n\t\t{ .intdefault = 0 },\n\t\t{ .intminval = 1 },\n\t\t{},\n\t\t{}\n\t},\n\t{\n\t\t\"connection_check_query\",\n\t\tCONFIG_STRING,\n\t\t{ .strptr = config_file_options.connection_check_query },\n\t\t{ .strdefault = \"SELECT 1\" },\n\t\t{},\n\t\t{ .strmaxlen = sizeof(config_file_options.connection_check_query) },\n\t\t{}\n\t},\n\t/* End-of-list marker */\n\t{\n\t\tNULL, CONFIG_INT, {}, {}, {}, {}, {}\n\t}\n};\n\n"
        },
        {
          "name": "configfile-scan.l",
          "type": "blob",
          "size": 15.556640625,
          "content": "/*\n * Scanner for the configuration file\n */\n\n%{\n\n#include <setjmp.h>\n#include <sys/stat.h>\n#include <dirent.h>\n\n#include \"repmgr.h\"\n#include \"configfile.h\"\n\n/*\n * flex emits a yy_fatal_error() function that it calls in response to\n * critical errors like malloc failure, file I/O errors, and detection of\n * internal inconsistency.  That function prints a message and calls exit().\n * Mutate it to instead call our handler, which jumps out of the parser.\n */\n#undef fprintf\n#define fprintf(file, fmt, msg) CONF_flex_fatal(msg)\n\nenum\n{\n\tCONF_ID = 1,\n\tCONF_STRING = 2,\n\tCONF_INTEGER = 3,\n\tCONF_REAL = 4,\n\tCONF_EQUALS = 5,\n\tCONF_UNQUOTED_STRING = 6,\n\tCONF_QUALIFIED_ID = 7,\n\tCONF_EOL = 99,\n\tCONF_ERROR = 100\n};\n\nstatic unsigned int ConfigFileLineno;\nstatic const char *CONF_flex_fatal_errmsg;\nstatic sigjmp_buf *CONF_flex_fatal_jmp;\n\nstatic char *CONF_scanstr(const char *s);\nstatic int\tCONF_flex_fatal(const char *msg);\n\nstatic bool ProcessConfigFile(const char *base_dir, const char *config_file, const char *calling_file, bool strict, int depth, KeyValueList *contents, ItemList *error_list, ItemList *warning_list);\n\nstatic bool ProcessConfigFp(FILE *fp, const char *config_file, const char *calling_file, int depth, const char *base_dir, KeyValueList *contents, ItemList *error_list, ItemList *warning_list);\n\nstatic bool ProcessConfigDirectory(const char *base_dir, const char *includedir, const char *calling_file, int depth, KeyValueList *contents, ItemList *error_list, ItemList *warning_list);\n\nstatic char *AbsoluteConfigLocation(const char *base_dir, const char *location, const char *calling_file);\n\n%}\n\n%option 8bit\n%option never-interactive\n%option nodefault\n%option noinput\n%option nounput\n%option noyywrap\n%option warn\n%option prefix=\"CONF_yy\"\n\n\nSIGN\t\t\t(\"-\"|\"+\")\nDIGIT\t\t\t[0-9]\nHEXDIGIT\t\t[0-9a-fA-F]\n\nUNIT_LETTER\t\t[a-zA-Z]\n\nINTEGER\t\t\t{SIGN}?({DIGIT}+|0x{HEXDIGIT}+){UNIT_LETTER}*\n\nEXPONENT\t\t[Ee]{SIGN}?{DIGIT}+\nREAL\t\t\t{SIGN}?{DIGIT}*\".\"{DIGIT}*{EXPONENT}?\n\nLETTER\t\t\t[A-Za-z_\\200-\\377]\nLETTER_OR_DIGIT [A-Za-z_0-9\\200-\\377]\n\nID\t\t\t\t{LETTER}{LETTER_OR_DIGIT}*\nQUALIFIED_ID\t{ID}\".\"{ID}\n\nUNQUOTED_STRING {LETTER}({LETTER_OR_DIGIT}|[-._:/])*\nSTRING\t\t\t\\'([^'\\\\\\n]|\\\\.|\\'\\')*\\'\n\n%%\n\n\\n\t\t\t\tConfigFileLineno++; return CONF_EOL;\n[ \\t\\r]+\t\t/* eat whitespace */\n#.*\t\t\t\t/* eat comment (.* matches anything until newline) */\n\n{ID}\t\t\treturn CONF_ID;\n{QUALIFIED_ID}\treturn CONF_QUALIFIED_ID;\n{STRING}\t\treturn CONF_STRING;\n{UNQUOTED_STRING} return CONF_UNQUOTED_STRING;\n{INTEGER}\t\treturn CONF_INTEGER;\n{REAL}\t\t\treturn CONF_REAL;\n=\t\t\t\treturn CONF_EQUALS;\n\n.\t\t\t\treturn CONF_ERROR;\n\n%%\n\n\nextern bool\nProcessRepmgrConfigFile(const char *config_file, const char *base_dir, ItemList *error_list, ItemList *warning_list)\n{\n\treturn ProcessConfigFile(base_dir, config_file, NULL, true, 0, NULL, error_list, warning_list);\n}\n\n\nextern bool\nProcessPostgresConfigFile(const char *config_file, const char *base_dir, bool strict, KeyValueList *contents, ItemList *error_list, ItemList *warning_list)\n{\n\treturn ProcessConfigFile(base_dir, config_file, NULL, strict, 0, contents, error_list, warning_list);\n}\n\nstatic bool\nProcessConfigFile(const char *base_dir, const char *config_file, const char *calling_file, bool strict, int depth, KeyValueList *contents, ItemList *error_list, ItemList *warning_list)\n{\n\tchar\t   *abs_path;\n\tbool\t\tsuccess = true;\n\tFILE\t   *fp;\n\n\t/*\n\t * Reject file name that is all-blank (including empty), as that leads to\n\t * confusion --- we'd try to read the containing directory as a file.\n\t */\n\tif (strspn(config_file, \" \\t\\r\\n\") == strlen(config_file))\n\t{\n\t\treturn false;\n\t}\n\n\t/*\n\t * Reject too-deep include nesting depth.  This is just a safety check to\n\t * avoid dumping core due to stack overflow if an include file loops back\n\t * to itself.  The maximum nesting depth is pretty arbitrary.\n\t */\n\tif (depth > 10)\n\t{\n\t\titem_list_append_format(error_list,\n\t\t\t\t\t\t\t\t_(\"could not open configuration file \\\"%s\\\": maximum nesting depth exceeded\"),\n\t\t\t\t\t\t\t\tconfig_file);\n\t\treturn false;\n\t}\n\n\tabs_path = AbsoluteConfigLocation(base_dir, config_file, calling_file);\n\n\t/* Reject direct recursion */\n\tif (calling_file && strcmp(abs_path, calling_file) == 0)\n\t{\n\t\titem_list_append_format(error_list,\n\t\t\t\t\t\t\t\t_(\"configuration file recursion in \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\tcalling_file);\n\t\tpfree(abs_path);\n\t\treturn false;\n\t}\n\n\tfp = fopen(abs_path, \"r\");\n\tif (!fp)\n\t{\n\t\tif (strict == false)\n\t\t{\n\t\t\titem_list_append_format(error_list,\n\t\t\t\t\t\t\t\t\t\"skipping configuration file \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tabs_path);\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem_list_append_format(error_list,\n\t\t\t\t\t\t\t\t\t\"could not open configuration file \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\t\tabs_path,\n\t\t\t\t\t\t\t\t\tstrerror(errno));\n\t\t\tsuccess = false;\n\t\t}\n\t}\n\telse\n\t{\n\t\tsuccess = ProcessConfigFp(fp, abs_path, calling_file, depth + 1, base_dir, contents, error_list, warning_list);\n\t}\n\n\tfree(abs_path);\n\n\treturn success;\n}\n\nstatic bool\nProcessConfigFp(FILE *fp, const char *config_file, const char *calling_file, int depth, const char *base_dir, KeyValueList *contents, ItemList *error_list, ItemList *warning_list)\n{\n\tvolatile bool OK = true;\n\tvolatile YY_BUFFER_STATE lex_buffer = NULL;\n\tsigjmp_buf\tflex_fatal_jmp;\n\tint\t\t\terrorcount;\n\tint\t\t\ttoken;\n\n\tif (sigsetjmp(flex_fatal_jmp, 1) == 0)\n\t{\n\t\tCONF_flex_fatal_jmp = &flex_fatal_jmp;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Regain control after a fatal, internal flex error.  It may have\n\t\t * corrupted parser state.  Consequently, abandon the file, but trust\n\t\t * that the state remains sane enough for yy_delete_buffer().\n\t\t */\n\t\titem_list_append_format(error_list,\n\t\t\t\t\t\t\t\t\"%s at file \\\"%s\\\" line %u\",\n\t\t\t\t\t\t\t\tCONF_flex_fatal_errmsg, config_file, ConfigFileLineno);\n\t\tOK = false;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Parse\n\t */\n\tConfigFileLineno = 1;\n\terrorcount = 0;\n\n\tlex_buffer = yy_create_buffer(fp, YY_BUF_SIZE);\n\tyy_switch_to_buffer(lex_buffer);\n\n\t/* This loop iterates once per logical line */\n\twhile ((token = yylex()))\n\t{\n\t\tchar\t   *opt_name = NULL;\n\t\tchar\t   *opt_value = NULL;\n\n\t\tif (token == CONF_EOL)\t/* empty or comment line */\n\t\t\tcontinue;\n\n\t\t/* first token on line is option name */\n\t\tif (token != CONF_ID && token != CONF_QUALIFIED_ID)\n\t\t\tgoto parse_error;\n\t\topt_name = pstrdup(yytext);\n\n\t\t/* next we have an optional equal sign; discard if present */\n\t\ttoken = yylex();\n\t\tif (token == CONF_EQUALS)\n\t\t\ttoken = yylex();\n\n\t\t/* now we must have the option value */\n\t\tif (token != CONF_ID &&\n\t\t\ttoken != CONF_STRING &&\n\t\t\ttoken != CONF_INTEGER &&\n\t\t\ttoken != CONF_REAL &&\n\t\t\ttoken != CONF_UNQUOTED_STRING)\n\t\t\tgoto parse_error;\n\t\tif (token == CONF_STRING)\t/* strip quotes and escapes */\n\t\t\topt_value = CONF_scanstr(yytext);\n\t\telse\n\t\t\topt_value = pstrdup(yytext);\n\n\t\t/* now we'd like an end of line, or possibly EOF */\n\t\ttoken = yylex();\n\t\tif (token != CONF_EOL)\n\t\t{\n\t\t\tif (token != 0)\n\t\t\t\tgoto parse_error;\n\t\t\t/* treat EOF like \\n for line numbering purposes, cf bug 4752 */\n\t\t\tConfigFileLineno++;\n\t\t}\n\n\t\t/* Handle include files */\n\t\tif (base_dir != NULL && strcasecmp(opt_name, \"include_dir\") == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * An include_dir directive isn't a variable and should be\n\t\t\t * processed immediately.\n\t\t\t */\n\t\t\tif (!ProcessConfigDirectory(base_dir, opt_value, config_file,\n\t\t\t\t\t\t\t\t\t\tdepth + 1, contents,\n\t\t\t\t\t\t\t\t\t    error_list, warning_list))\n\t\t\t\tOK = false;\n\t\t\tyy_switch_to_buffer(lex_buffer);\n\t\t\tpfree(opt_name);\n\t\t\tpfree(opt_value);\n\t\t}\n\t\telse if (base_dir != NULL && strcasecmp(opt_name, \"include_if_exists\") == 0)\n\t\t{\n\t\t\tif (!ProcessConfigFile(base_dir, opt_value, config_file,\n\t\t\t\t\t\t\t\t   false, depth + 1, contents,\n\t\t\t\t\t\t\t\t   error_list, warning_list))\n\t\t\t\tOK = false;\n\n\t\t\tyy_switch_to_buffer(lex_buffer);\n\t\t\tpfree(opt_name);\n\t\t\tpfree(opt_value);\n\t\t}\n\t\telse if (base_dir != NULL && strcasecmp(opt_name, \"include\") == 0)\n\t\t{\n\t\t\tif (!ProcessConfigFile(base_dir, opt_value, config_file,\n\t\t\t\t\t\t\t\t   true, depth + 1, contents,\n\t\t\t\t\t\t\t\t   error_list, warning_list))\n\t\t\t\tOK = false;\n\n\t\t\tyy_switch_to_buffer(lex_buffer);\n\t\t\tpfree(opt_name);\n\t\t\tpfree(opt_value);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* OK, process the option name and value */\n\t\t\tif (contents != NULL)\n\t\t\t{\n\t\t\t\tkey_value_list_replace_or_set(contents,\n\t\t\t\t\t\t\t\t\t\t\t  opt_name,\n\t\t\t\t\t\t\t\t\t\t\t  opt_value);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparse_configuration_item(error_list,\n\t\t\t\t\t\t\t\t\t\t warning_list,\n\t\t\t\t\t\t\t\t\t\t opt_name,\n\t\t\t\t\t\t\t\t\t\t opt_value);\n\t\t\t}\n\n\t\t}\n\n\n\t\t/* break out of loop if read EOF, else loop for next line */\n\t\tif (token == 0)\n\t\t\tbreak;\n\t\tcontinue;\n\nparse_error:\n\t\t/* release storage if we allocated any on this line */\n\t\tif (opt_name)\n\t\t\tpfree(opt_name);\n\t\tif (opt_value)\n\t\t\tpfree(opt_value);\n\n\t\t/* report the error */\n\t\tif (token == CONF_EOL || token == 0)\n\t\t{\n\t\t\titem_list_append_format(error_list,\n\t\t\t\t\t\t\t\t\t_(\"syntax error in file \\\"%s\\\" line %u, near end of line\"),\n\t\t\t\t\t\t\t\t    config_file, ConfigFileLineno - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem_list_append_format(error_list,\n\t\t\t\t\t\t\t\t\t_(\"syntax error in file \\\"%s\\\" line %u, near token \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\t\tconfig_file, ConfigFileLineno, yytext);\n\t\t}\n\t\tOK = false;\n\t\terrorcount++;\n\n\t\t/*\n\t\t * To avoid producing too much noise when fed a totally bogus file,\n\t\t * give up after 100 syntax errors per file (an arbitrary number).\n\t\t * Also, if we're only logging the errors at DEBUG level anyway, might\n\t\t * as well give up immediately.  (This prevents postmaster children\n\t\t * from bloating the logs with duplicate complaints.)\n\t\t */\n\t\tif (errorcount >= 100)\n\t\t{\n\t\t\tfprintf(stderr,\n \t\t\t\t   _(\"too many syntax errors found, abandoning file \\\"%s\\\"\\n\"),\n\t\t\t\t   config_file);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* resync to next end-of-line or EOF */\n\t\twhile (token != CONF_EOL && token != 0)\n\t\t\ttoken = yylex();\n\t\t/* break out of loop on EOF */\n\t\tif (token == 0)\n\t\t\tbreak;\n\t}\n\ncleanup:\n\tyy_delete_buffer(lex_buffer);\n\n\treturn OK;\n}\n\n/*\n * Read and parse all config files in a subdirectory in alphabetical order\n *\n * includedir is the absolute or relative path to the subdirectory to scan.\n *\n * See ProcessConfigFp for further details.\n */\nstatic bool\nProcessConfigDirectory(const char *base_dir, const char *includedir, const char *calling_file, int depth, KeyValueList *contents, ItemList *error_list, ItemList *warning_list)\n{\n\tchar\t   *directory;\n\tDIR\t\t   *d;\n\tstruct dirent *de;\n\tchar\t  **filenames;\n\tint\t\t\tnum_filenames;\n\tint\t\t\tsize_filenames;\n\tbool\t\tstatus;\n\n\t/*\n\t * Reject directory name that is all-blank (including empty), as that\n\t * leads to confusion --- we'd read the containing directory, typically\n\t * resulting in recursive inclusion of the same file(s).\n\t */\n\tif (strspn(includedir, \" \\t\\r\\n\") == strlen(includedir))\n\t{\n\t\titem_list_append_format(error_list,\n\t\t\t\t\t\t\t\t_(\"empty configuration directory name: \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\tincludedir);\n\n\t\treturn false;\n\t}\n\n\tdirectory = AbsoluteConfigLocation(base_dir, includedir, calling_file);\n\td = opendir(directory);\n\tif (d == NULL)\n\t{\n\t\titem_list_append_format(error_list,\n\t\t\t\t\t\t\t\t_(\"could not open configuration directory \\\"%s\\\": %s\"),\n\t\t\t\t\t\t\t\tdirectory,\n\t\t\t\t\t\t\t\tstrerror(errno));\n\t\tstatus = false;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Read the directory and put the filenames in an array, so we can sort\n\t * them prior to processing the contents.\n\t */\n\tsize_filenames = 32;\n\tfilenames = (char **) palloc(size_filenames * sizeof(char *));\n\tnum_filenames = 0;\n\n\twhile ((de = readdir(d)) != NULL)\n\t{\n\t\tstruct stat st;\n\t\tchar\t\tfilename[MAXPGPATH];\n\n\t\t/*\n\t\t * Only parse files with names ending in \".conf\".  Explicitly reject\n\t\t * files starting with \".\".  This excludes things like \".\" and \"..\",\n\t\t * as well as typical hidden files, backup files, and editor debris.\n\t\t */\n\t\tif (strlen(de->d_name) < 6)\n\t\t\tcontinue;\n\t\tif (de->d_name[0] == '.')\n\t\t\tcontinue;\n\t\tif (strcmp(de->d_name + strlen(de->d_name) - 5, \".conf\") != 0)\n\t\t\tcontinue;\n\n\t\tjoin_path_components(filename, directory, de->d_name);\n\t\tcanonicalize_path(filename);\n\t\tif (stat(filename, &st) == 0)\n\t\t{\n\t\t\tif (!S_ISDIR(st.st_mode))\n\t\t\t{\n\t\t\t\t/* Add file to array, increasing its size in blocks of 32 */\n\t\t\t\tif (num_filenames >= size_filenames)\n\t\t\t\t{\n\t\t\t\t\tsize_filenames += 32;\n\t\t\t\t\tfilenames = (char **) repalloc(filenames,\n\t\t\t\t\t\t\t\t\t\t\tsize_filenames * sizeof(char *));\n\t\t\t\t}\n\t\t\t\tfilenames[num_filenames] = pstrdup(filename);\n\t\t\t\tnum_filenames++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * stat does not care about permissions, so the most likely reason\n\t\t\t * a file can't be accessed now is if it was removed between the\n\t\t\t * directory listing and now.\n\t\t\t */\n\t\t\titem_list_append_format(error_list,\n\t\t\t\t\t\t\t\t\t_(\"could not stat file \\\"%s\\\": %s\"),\n\t\t\t\t\t\t\t\t\tfilename, strerror(errno));\n\t\t\tstatus = false;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (num_filenames > 0)\n\t{\n\t\tint\t\t\ti;\n\n\t\tqsort(filenames, num_filenames, sizeof(char *), pg_qsort_strcmp);\n\t\tfor (i = 0; i < num_filenames; i++)\n\t\t{\n\t\t\tif (!ProcessConfigFile(base_dir, filenames[i], calling_file,\n\t\t\t\t\t\t\t\t   true, depth, contents,\n\t\t\t\t\t\t\t\t   error_list, warning_list))\n\t\t\t{\n\t\t\t\tstatus = false;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\tstatus = true;\n\n\ncleanup:\n\tif (d)\n\t\tclosedir(d);\n\tpfree(directory);\n\treturn status;\n}\n\n/*\n *\t\tscanstr\n *\n * Strip the quotes surrounding the given string, and collapse any embedded\n * '' sequences and backslash escapes.\n *\n * the string returned is palloc'd and should eventually be pfree'd by the\n * caller.\n */\nstatic char *\nCONF_scanstr(const char *s)\n{\n\tchar\t   *newStr;\n\tint\t\t\tlen,\n\t\t\t\ti,\n\t\t\t\tj;\n\n\tAssert(s != NULL && s[0] == '\\'');\n\tlen = strlen(s);\n\tAssert(s != NULL);\n\n\tAssert(len >= 2);\n\tAssert(s[len - 1] == '\\'');\n\n\t/* Skip the leading quote; we'll handle the trailing quote below */\n\ts++, len--;\n\n\t/* Since len still includes trailing quote, this is enough space */\n\tnewStr = palloc(len);\n\n\tfor (i = 0, j = 0; i < len; i++)\n\t{\n\t\tif (s[i] == '\\\\')\n\t\t{\n\t\t\ti++;\n\t\t\tswitch (s[i])\n\t\t\t{\n\t\t\t\tcase 'b':\n\t\t\t\t\tnewStr[j] = '\\b';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tnewStr[j] = '\\f';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\tnewStr[j] = '\\n';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'r':\n\t\t\t\t\tnewStr[j] = '\\r';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\tnewStr[j] = '\\t';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '0':\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tk;\n\t\t\t\t\t\tlong\t\toctVal = 0;\n\n\t\t\t\t\t\tfor (k = 0;\n\t\t\t\t\t\t\t s[i + k] >= '0' && s[i + k] <= '7' && k < 3;\n\t\t\t\t\t\t\t k++)\n\t\t\t\t\t\t\toctVal = (octVal << 3) + (s[i + k] - '0');\n\t\t\t\t\t\ti += k - 1;\n\t\t\t\t\t\tnewStr[j] = ((char) octVal);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tnewStr[j] = s[i];\n\t\t\t\t\tbreak;\n\t\t\t}\t\t\t\t\t/* switch */\n\t\t}\n\t\telse if (s[i] == '\\'' && s[i + 1] == '\\'')\n\t\t{\n\t\t\t/* doubled quote becomes just one quote */\n\t\t\tnewStr[j] = s[++i];\n\t\t}\n\t\telse\n\t\t\tnewStr[j] = s[i];\n\t\tj++;\n\t}\n\n\t/* We copied the ending quote to newStr, so replace with \\0 */\n\tAssert(j > 0 && j <= len);\n\tnewStr[--j] = '\\0';\n\n\treturn newStr;\n}\n\n/*\n * Given a configuration file or directory location that may be a relative\n * path, return an absolute one.  We consider the location to be relative to\n * the directory holding the calling file, or to DataDir if no calling file.\n */\nstatic char *\nAbsoluteConfigLocation(const char *base_dir, const char *location, const char *calling_file)\n{\n\tchar\t\tabs_path[MAXPGPATH];\n\n\tif (is_absolute_path(location))\n\t\treturn strdup(location);\n\n    if (calling_file != NULL)\n\t{\n\t\tstrlcpy(abs_path, calling_file, sizeof(abs_path));\n\t\tget_parent_directory(abs_path);\n\t\tjoin_path_components(abs_path, abs_path, location);\n\t\tcanonicalize_path(abs_path);\n\t}\n\telse if (base_dir != NULL)\n\t{\n\t\tjoin_path_components(abs_path, base_dir, location);\n\t\tcanonicalize_path(abs_path);\n\t}\n\telse\n\t{\n\t\tstrlcpy(abs_path, location, sizeof(abs_path));\n\t}\n\n\treturn strdup(abs_path);\n}\n\n\n/*\n * Flex fatal errors bring us here.  Stash the error message and jump back to\n * ParseConfigFp().  Assume all msg arguments point to string constants; this\n * holds for flex 2.5.31 (earliest we support) and flex 2.5.35 (latest as of\n * this writing).  Otherwise, we would need to copy the message.\n *\n * We return \"int\" since this takes the place of calls to fprintf().\n*/\nstatic int\nCONF_flex_fatal(const char *msg)\n{\n\tCONF_flex_fatal_errmsg = msg;\n\tsiglongjmp(*CONF_flex_fatal_jmp, 1);\n\treturn 0;\t\t\t\t\t/* keep compiler quiet */\n}\n"
        },
        {
          "name": "configfile.c",
          "type": "blob",
          "size": 60.328125,
          "content": "/*\n * configfile.c - parse repmgr.conf and other configuration-related functionality\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <sys/stat.h>\t\t\t/* for stat() */\n\n#include \"repmgr.h\"\n#include \"configfile.h\"\n#include \"log.h\"\n\n#include <utils/elog.h>\n\n#if (PG_ACTUAL_VERSION_NUM >= 100000)\n#include <storage/fd.h>\t\t\t/* for durable_rename() */\n#endif\n\nconst static char *_progname = NULL;\nchar\t\tconfig_file_path[MAXPGPATH] = \"\";\nstatic bool config_file_provided = false;\nbool\t\tconfig_file_found = false;\n\n\nstatic void parse_config(bool terse);\nstatic void _parse_config(ItemList *error_list, ItemList *warning_list);\n\nstatic void _parse_line(char *buf, char *name, char *value);\nstatic void parse_event_notifications_list(EventNotificationList *event_notifications, const char *arg);\nstatic void clear_event_notification_list(EventNotificationList *event_notifications);\n\nstatic void copy_config_file_options(t_configuration_options *original, t_configuration_options *copy);\n\nstatic void tablespace_list_append(TablespaceList *tablespace_mapping, const char *arg);\nstatic void tablespace_list_copy(t_configuration_options *original, t_configuration_options *copy);\nstatic void tablespace_list_free(t_configuration_options *options);\n\nstatic void exit_with_config_file_errors(ItemList *config_errors, ItemList *config_warnings, bool terse);\n\n\nvoid\nset_progname(const char *argv0)\n{\n\t_progname = get_progname(argv0);\n}\n\nconst char *\nprogname(void)\n{\n\treturn _progname;\n}\n\nvoid\nload_config(const char *config_file, bool verbose, bool terse, char *argv0)\n{\n\tstruct stat stat_config;\n\n\t/*\n\t * If a configuration file was provided, check it exists, otherwise emit\n\t * an error and terminate. We assume that if a user explicitly provides a\n\t * configuration file, they'll want to make sure it's used and not fall\n\t * back to any of the defaults.\n\t */\n\tif (config_file != NULL && config_file[0] != '\\0')\n\t{\n\t\tstrncpy(config_file_path, config_file, MAXPGPATH);\n\t\tcanonicalize_path(config_file_path);\n\n\t\t/* relative path supplied - convert to absolute path */\n\t\tif (config_file_path[0] != '/')\n\t\t{\n\t\t\tPQExpBufferData fullpath;\n\t\t\tchar *pwd = NULL;\n\n\t\t\tinitPQExpBuffer(&fullpath);\n\n\t\t\t/*\n\t\t\t * we'll attempt to use $PWD to derive the effective path; getcwd()\n\t\t\t * will likely resolve symlinks, which may result in a path which\n\t\t\t * isn't permanent (e.g. if filesystem mountpoints change).\n\t\t\t */\n\t\t\tpwd = getenv(\"PWD\");\n\n\t\t\tif (pwd != NULL)\n\t\t\t{\n\t\t\t\tappendPQExpBufferStr(&fullpath, pwd);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* $PWD not available - fall back to getcwd() */\n\t\t\t\tchar cwd[MAXPGPATH] = \"\";\n\n\t\t\t\tif (getcwd(cwd, MAXPGPATH) == NULL)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to execute getcwd()\"));\n\t\t\t\t\tlog_detail(\"%s\", strerror(errno));\n\n\t\t\t\t\ttermPQExpBuffer(&fullpath);\n\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t}\n\n\t\t\t\tappendPQExpBufferStr(&fullpath, cwd);\n\t\t\t}\n\n\t\t\tappendPQExpBuffer(&fullpath,\n\t\t\t\t\t\t\t  \"/%s\", config_file_path);\n\n\t\t\tlog_debug(\"relative configuration file converted to:\\n  \\\"%s\\\"\",\n\t\t\t\t\t  fullpath.data);\n\n\t\t\tstrncpy(config_file_path, fullpath.data, MAXPGPATH);\n\n\t\t\ttermPQExpBuffer(&fullpath);\n\n\t\t\tcanonicalize_path(config_file_path);\n\t\t}\n\n\n\t\tif (stat(config_file_path, &stat_config) != 0)\n\t\t{\n\t\t\tlog_error(_(\"provided configuration file \\\"%s\\\" not found\"),\n\t\t\t\t\t  config_file);\n\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\n\t\tif (verbose == true)\n\t\t{\n\t\t\tlog_notice(_(\"using provided configuration file \\\"%s\\\"\"), config_file);\n\t\t}\n\n\t\tconfig_file_provided = true;\n\t\tconfig_file_found = true;\n\t}\n\n\n\t/*-----------\n\t * If no configuration file was provided, attempt to find a default file\n\t * in this order:\n\t *  - location provided by packager\n\t *  - current directory\n\t *  - /etc/repmgr.conf\n\t *  - default sysconfdir\n\t *\n\t * here we just check for the existence of the file; parse_config() will\n\t * handle read errors etc.\n\t *\n\t *-----------\n\t */\n\tif (config_file_provided == false)\n\t{\n\t\t/* packagers: if feasible, patch configuration file path into \"package_conf_file\" */\n\t\tchar\t\tpackage_conf_file[MAXPGPATH] = \"\";\n\t\tchar\t\tmy_exec_path[MAXPGPATH] = \"\";\n\t\tchar\t\tsysconf_etc_path[MAXPGPATH] = \"\";\n\n\t\t/* 1. location provided by packager */\n\t\tif (package_conf_file[0] != '\\0')\n\t\t{\n\t\t\tif (verbose == true)\n\t\t\t\tfprintf(stdout, _(\"INFO: checking for package configuration file \\\"%s\\\"\\n\"), package_conf_file);\n\n\t\t\tif (stat(package_conf_file, &stat_config) == 0)\n\t\t\t{\n\t\t\t\tstrncpy(config_file_path, package_conf_file, MAXPGPATH);\n\t\t\t\tconfig_file_found = true;\n\t\t\t\tgoto end_search;\n\t\t\t}\n\t\t}\n\n\t\t/* 2 \"./repmgr.conf\" */\n\t\tlog_verbose(LOG_INFO, _(\"looking for configuration file in current directory\\n\"));\n\n\t\tmaxpath_snprintf(config_file_path, \"./%s\", CONFIG_FILE_NAME);\n\t\tcanonicalize_path(config_file_path);\n\n\t\tif (stat(config_file_path, &stat_config) == 0)\n\t\t{\n\t\t\tconfig_file_found = true;\n\t\t\tgoto end_search;\n\t\t}\n\n\t\t/* 3. \"/etc/repmgr.conf\" */\n\t\tif (verbose == true)\n\t\t\tfprintf(stdout, _(\"INFO: looking for configuration file in /etc\\n\"));\n\n\t\tmaxpath_snprintf(config_file_path, \"/etc/%s\", CONFIG_FILE_NAME);\n\t\tif (stat(config_file_path, &stat_config) == 0)\n\t\t{\n\t\t\tconfig_file_found = true;\n\t\t\tgoto end_search;\n\t\t}\n\n\t\t/* 4. default sysconfdir */\n\t\tif (find_my_exec(argv0, my_exec_path) < 0)\n\t\t{\n\t\t\tfprintf(stderr, _(\"ERROR: %s: could not find own program executable\\n\"), argv0);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tget_etc_path(my_exec_path, sysconf_etc_path);\n\n\t\tif (verbose == true)\n\t\t\tfprintf(stdout, _(\"INFO: looking for configuration file in \\\"%s\\\"\\n\"), sysconf_etc_path);\n\n\t\tmaxpath_snprintf(config_file_path, \"%s/%s\", sysconf_etc_path, CONFIG_FILE_NAME);\n\t\tif (stat(config_file_path, &stat_config) == 0)\n\t\t{\n\t\t\tconfig_file_found = true;\n\t\t\tgoto end_search;\n\t\t}\n\nend_search:\n\t\tif (verbose == true)\n\t\t{\n\t\t\tif (config_file_found == true)\n\t\t\t{\n\t\t\t\tfprintf(stdout, _(\"INFO: configuration file found at: \\\"%s\\\"\\n\"), config_file_path);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stdout, _(\"INFO: no configuration file provided or found\\n\"));\n\t\t\t}\n\t\t}\n\t}\n\n\tparse_config(terse);\n\n\treturn;\n}\n\n\nstatic void\nparse_config(bool terse)\n{\n\t/* Collate configuration file errors here for friendlier reporting */\n\tstatic ItemList config_errors = {NULL, NULL};\n\tstatic ItemList config_warnings = {NULL, NULL};\n\n\t_parse_config(&config_errors, &config_warnings);\n\n\t/* errors found - exit after printing details, and any warnings */\n\tif (config_errors.head != NULL)\n\t{\n\t\texit_with_config_file_errors(&config_errors, &config_warnings, terse);\n\t}\n\n\tif (terse == false && config_warnings.head != NULL)\n\t{\n\t\tlog_warning(_(\"the following problems were found in the configuration file:\"));\n\n\t\tprint_item_list(&config_warnings);\n\t}\n\n\treturn;\n}\n\n\nstatic void\n_parse_config(ItemList *error_list, ItemList *warning_list)\n{\n\tFILE\t   *fp;\n\tchar\t\tbase_directory[MAXPGPATH];\n\tbool\t\tconfig_ok;\n\tConfigFileSetting *setting;\n\tint i = 0;\n\n\t/*\n\t * Clear lists pointing to allocated memory\n\t */\n\n\tclear_event_notification_list(&config_file_options.event_notifications);\n\ttablespace_list_free(&config_file_options);\n\n\t/*\n\t * Initialise with default values\n\t */\n\tsetting = &config_file_settings[0];\n\n\tdo {\n\t\tswitch (setting->type)\n\t\t{\n\t\t\tcase CONFIG_INT:\n\t\t\t\t*setting->val.intptr = setting->defval.intdefault;\n\t\t\t\tbreak;\n\t\t\tcase CONFIG_BOOL:\n\t\t\t\t*setting->val.boolptr = setting->defval.booldefault;\n\t\t\t\tbreak;\n\t\t\tcase CONFIG_STRING:\n\t\t\t{\n\t\t\t\tmemset((char *)setting->val.strptr, 0, setting->maxval.strmaxlen);\n\t\t\t\tif (setting->defval.strdefault != NULL)\n\t\t\t\t\tstrncpy((char *)setting->val.strptr, setting->defval.strdefault, setting->maxval.strmaxlen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CONFIG_FAILOVER_MODE:\n\t\t\t\t*setting->val.failovermodeptr = setting->defval.failovermodedefault;\n\t\t\t\tbreak;\n\t\t\tcase CONFIG_CONNECTION_CHECK_TYPE:\n\t\t\t\t*setting->val.checktypeptr = setting->defval.checktypedefault;\n\t\t\t\tbreak;\n\t\t\tcase CONFIG_REPLICATION_TYPE:\n\t\t\t\t*setting->val.replicationtypeptr = setting->defval.replicationtypedefault;\n\t\t\t\tbreak;\n\t\t\tcase CONFIG_EVENT_NOTIFICATION_LIST:\n\t\t\tcase CONFIG_TABLESPACE_MAPPING:\n\t\t\t\t/* no default for these types; lists cleared above */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* this should never happen */\n\t\t\t\tlog_error(\"unhandled setting type %i\", (int)setting->type);\n\t\t}\n\n\t\ti++;\n\t\tsetting = &config_file_settings[i];\n\t} while (setting->name != NULL);\n\n\t/*\n\t * If no configuration file available (user didn't specify and none found\n\t * in the default locations), return with default values\n\t */\n\tif (config_file_found == false)\n\t{\n\t\tlog_verbose(LOG_NOTICE,\n\t\t\t\t\t_(\"no configuration file provided and no default file found - \"\n\t\t\t\t\t  \"continuing with default values\"));\n\t\treturn;\n\t}\n\n\t/*\n\t * A configuration file has been found, either provided by the user or\n\t * found in one of the default locations. Sanity check whether we\n\t * can open it, and fail with an error about the nature of the file\n\t * (provided or default) if not. We do this here rather than having\n\t * to teach the configuration file parser the difference.\n\t */\n\n\tfp = fopen(config_file_path, \"r\");\n\n\tif (fp == NULL)\n\t{\n\t\tif (config_file_provided)\n\t\t{\n\t\t\tlog_error(_(\"unable to open provided configuration file \\\"%s\\\"; terminating\"),\n\t\t\t\t\t  config_file_path);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_error(_(\"unable to open default configuration file \\\"%s\\\"; terminating\"),\n\t\t\t\t\t  config_file_path);\n\t\t}\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tfclose(fp);\n\n\tstrncpy(base_directory, config_file_path, MAXPGPATH);\n\tcanonicalize_path(base_directory);\n\tget_parent_directory(base_directory);\n\n\tconfig_ok = ProcessRepmgrConfigFile(config_file_path, base_directory, error_list, warning_list);\n\n\t/*\n\t * Perform some more complex checks which the file processing step can't do,\n\t * including checking for required parameters and sanity-checking parameters\n\t * with dependencies on other parameters.\n\t */\n\tif (config_ok == true)\n\t{\n\t\t/* check required parameters */\n\t\tif (config_file_options.node_id == UNKNOWN_NODE_ID)\n\t\t{\n\t\t\titem_list_append(error_list, _(\"\\\"node_id\\\": required parameter was not found\"));\n\t\t}\n\n\t\tif (!strlen(config_file_options.node_name))\n\t\t{\n\t\t\titem_list_append(error_list, _(\"\\\"node_name\\\": required parameter was not found\"));\n\t\t}\n\n\t\tif (!strlen(config_file_options.data_directory))\n\t\t{\n\t\t\titem_list_append(error_list, _(\"\\\"data_directory\\\": required parameter was not found\"));\n\t\t}\n\n\t\tif (!strlen(config_file_options.conninfo))\n\t\t{\n\t\t\titem_list_append(error_list, _(\"\\\"conninfo\\\": required parameter was not found\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Basic sanity check of provided conninfo string; this will catch any\n\t\t\t * invalid parameters (but not values).\n\t\t\t */\n\t\t\tchar\t   *conninfo_errmsg = NULL;\n\n\t\t\tif (validate_conninfo_string(config_file_options.conninfo, &conninfo_errmsg) == false)\n\t\t\t{\n\t\t\t\tPQExpBufferData error_message_buf;\n\t\t\t\tinitPQExpBuffer(&error_message_buf);\n\n\t\t\t\tappendPQExpBuffer(&error_message_buf,\n\t\t\t\t\t\t\t\t  _(\"\\\"conninfo\\\": %s\t(provided: \\\"%s\\\")\"),\n\t\t\t\t\t\t\t\t  conninfo_errmsg,\n\t\t\t\t\t\t\t\t  config_file_options.conninfo);\n\n\t\t\t\titem_list_append(error_list, error_message_buf.data);\n\t\t\t\ttermPQExpBuffer(&error_message_buf);\n\t\t\t}\n\t\t}\n\n\t\t/* set values for parameters which default to other parameters */\n\n\t\t/*\n\t\t * From 4.1, \"repmgrd_standby_startup_timeout\" replaces \"standby_reconnect_timeout\"\n\t\t * in repmgrd; fall back to \"standby_reconnect_timeout\" if no value explicitly provided\n\t\t */\n\t\tif (config_file_options.repmgrd_standby_startup_timeout == -1)\n\t\t{\n\t\t\tconfig_file_options.repmgrd_standby_startup_timeout = config_file_options.standby_reconnect_timeout;\n\t\t}\n\n\t\t/* add warning about changed \"barman_\" parameter meanings */\n\t\tif ((config_file_options.barman_host[0] == '\\0' && config_file_options.barman_server[0] != '\\0') ||\n\t\t\t(config_file_options.barman_host[0] != '\\0' && config_file_options.barman_server[0] == '\\0'))\n\t\t{\n\t\t\titem_list_append(error_list,\n\t\t\t\t\t\t\t _(\"use \\\"barman_host\\\" for the hostname of the Barman server\"));\n\t\t\titem_list_append(error_list,\n\t\t\t\t\t\t\t _(\"use \\\"barman_server\\\" for the name of the [server] section in the Barman configuration file\"));\n\t\t}\n\n\t\t/* other sanity checks */\n\n\t\tif (config_file_options.archive_ready_warning >= config_file_options.archive_ready_critical)\n\t\t{\n\t\t\titem_list_append(error_list,\n\t\t\t\t\t\t\t _(\"\\\"archive_ready_critical\\\" must be greater than  \\\"archive_ready_warning\\\"\"));\n\t\t}\n\n\t\tif (config_file_options.replication_lag_warning >= config_file_options.replication_lag_critical)\n\t\t{\n\t\t\titem_list_append(error_list,\n\t\t\t\t\t\t\t _(\"\\\"replication_lag_critical\\\" must be greater than  \\\"replication_lag_warning\\\"\"));\n\t\t}\n\n\t\tif (config_file_options.standby_reconnect_timeout < config_file_options.node_rejoin_timeout)\n\t\t{\n\t\t\titem_list_append(error_list,\n\t\t\t\t\t\t\t _(\"\\\"standby_reconnect_timeout\\\" must be equal to or greater than \\\"node_rejoin_timeout\\\"\"));\n\t\t}\n\t}\n}\n\n\nvoid\nparse_configuration_item(ItemList *error_list, ItemList *warning_list, const char *name, const char *value)\n{\n\tConfigFileSetting *setting = &config_file_settings[0];\n\tint i = 0;\n\tdo {\n\t\tif (strcmp(name, setting->name) == 0)\n\t\t{\n\t\t\tswitch (setting->type)\n\t\t\t{\n\t\t\t\t/* Generic types */\n\t\t\t\tcase CONFIG_BOOL:\n\t\t\t\t{\n\t\t\t\t\t*(bool *)setting->val.boolptr = parse_bool(value, name, error_list);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase CONFIG_INT:\n\t\t\t\t{\n\t\t\t\t\t*(int *)setting->val.intptr = repmgr_atoi(value, name, error_list, setting->minval.intminval);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase CONFIG_STRING:\n\t\t\t\t{\n\t\t\t\t\tif (strlen(value) > setting->maxval.strmaxlen)\n\t\t\t\t\t{\n\t\t\t\t\t\titem_list_append_format(error_list,\n\t\t\t\t\t\t\t\t\t\t\t\t_(\"value for \\\"%s\\\" must contain fewer than %i characters (current length: %i)\"),\n\t\t\t\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\t\t\t\tsetting->maxval.strmaxlen,\n\t\t\t\t\t\t\t\t\t\t\t\t(int)strlen(value));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* custom function for processing this string value */\n\t\t\t\t\t\tif (setting->process.process_func != NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t(*setting->process.process_func)(name, value, (char *)setting->val.strptr, error_list);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* otherwise copy as-is */\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstrncpy((char *)setting->val.strptr, value, setting->maxval.strmaxlen);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* post-processing, e.g. path canonicalisation */\n\t\t\t\t\t\tif (setting->process.postprocess_func != NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t(*setting->process.postprocess_func)(name, value, (char *)setting->val.strptr, error_list);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (setting->process.providedptr != NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t*(bool *)setting->process.providedptr = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t\t/* repmgr types */\n\t\t\t\tcase CONFIG_FAILOVER_MODE:\n\t\t\t\t{\n\t\t\t\t\tif (strcmp(value, \"manual\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(failover_mode_opt *)setting->val.failovermodeptr = FAILOVER_MANUAL;\n\t\t\t\t\t}\n\t\t\t\t\telse if (strcmp(value, \"automatic\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(failover_mode_opt *)setting->val.failovermodeptr = FAILOVER_AUTOMATIC;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\titem_list_append_format(error_list,\n\t\t\t\t\t\t\t\t\t\t\t\t_(\"value for \\\"%s\\\" must be \\\"automatic\\\" or \\\"manual\\\"\\n\"),\n\t\t\t\t\t\t\t\t\t\t\t\tname);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase CONFIG_CONNECTION_CHECK_TYPE:\n\t\t\t\t{\n\t\t\t\t\tif (strcasecmp(value, \"ping\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(ConnectionCheckType *)setting->val.checktypeptr = CHECK_PING;\n\t\t\t\t\t}\n\t\t\t\t\telse if (strcasecmp(value, \"connection\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(ConnectionCheckType *)setting->val.checktypeptr = CHECK_CONNECTION;\n\t\t\t\t\t}\n\t\t\t\t\telse if (strcasecmp(value, \"query\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(ConnectionCheckType *)setting->val.checktypeptr = CHECK_QUERY;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\titem_list_append_format(error_list,\n\t\t\t\t\t\t\t\t\t\t\t\t_(\"value for \\\"%s\\\" must be \\\"ping\\\", \\\"connection\\\" or \\\"query\\\"\\n\"),\n\t\t\t\t\t\t\t\t\t\t\t\tname);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase CONFIG_REPLICATION_TYPE:\n\t\t\t\t{\n\t\t\t\t\tif (strcasecmp(value, \"physical\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(ReplicationType *)setting->val.replicationtypeptr = REPLICATION_TYPE_PHYSICAL;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\titem_list_append_format(error_list,\n\t\t\t\t\t\t\t\t\t\t\t\t_(\"value for \\\"%s\\\" must be \\\"physical\\\"\\n\"),\n\t\t\t\t\t\t\t\t\t\t\t\tname);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase CONFIG_EVENT_NOTIFICATION_LIST:\n\t\t\t\t{\n\t\t\t\t\tparse_event_notifications_list((EventNotificationList *)setting->val.notificationlistptr,\n\t\t\t\t\t\t\t\t\t\t\t\t   value);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase CONFIG_TABLESPACE_MAPPING:\n\t\t\t\t{\n\t\t\t\t\ttablespace_list_append((TablespaceList *)setting->val.tablespacemappingptr, value);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\t/* this should never happen */\n\t\t\t\t\tlog_error(\"encountered unknown configuration type %i when processing \\\"%s\\\"\",\n\t\t\t\t\t\t\t  (int)setting->type,\n\t\t\t\t\t\t\t  setting->name);\n\t\t\t}\n\n\t\t\t/* Configuration item found - we can stop processing here */\n\t\t\treturn;\n\t\t}\n\t\ti++;\n\t\tsetting = &config_file_settings[i];\n\t} while (setting->name);\n\n\t/* If we reach here, the configuration item is either deprecated or unknown */\n\n\tif (strcmp(name, \"cluster\") == 0)\n\t{\n\t\titem_list_append(warning_list,\n\t\t\t\t\t\t _(\"parameter \\\"cluster\\\" is deprecated and will be ignored\"));\n\t}\n\telse if (strcmp(name, \"node\") == 0)\n\t{\n\t\titem_list_append(warning_list,\n\t\t\t\t\t\t _(\"parameter \\\"node\\\" has been renamed to \\\"node_id\\\"\"));\n\t}\n\telse if (strcmp(name, \"upstream_node\") == 0)\n\t{\n\t\titem_list_append(warning_list,\n\t\t\t\t\t\t _(\"parameter \\\"upstream_node\\\" has been removed; use \\\"--upstream-node-id\\\" when cloning a standby\"));\n\t}\n\telse if (strcmp(name, \"loglevel\") == 0)\n\t{\n\t\titem_list_append(warning_list,\n\t\t\t\t\t\t _(\"parameter \\\"loglevel\\\" has been renamed to \\\"log_level\\\"\"));\n\t}\n\telse if (strcmp(name, \"logfacility\") == 0)\n\t{\n\t\titem_list_append(warning_list,\n\t\t\t\t\t\t _(\"parameter \\\"logfacility\\\" has been renamed to \\\"log_facility\\\"\"));\n\t}\n\telse if (strcmp(name, \"logfile\") == 0)\n\t{\n\t\titem_list_append(warning_list,\n\t\t\t\t\t\t _(\"parameter \\\"logfile\\\" has been renamed to \\\"log_file\\\"\"));\n\t}\n\telse if (strcmp(name, \"master_reponse_timeout\") == 0)\n\t{\n\t\titem_list_append(warning_list,\n\t\t\t\t\t\t _(\"parameter \\\"master_reponse_timeout\\\" has been removed; use \\\"async_query_timeout\\\" instead\"));\n\t}\n\telse if (strcmp(name, \"retry_promote_interval_secs\") == 0)\n\t{\n\t\titem_list_append(warning_list,\n\t\t\t\t\t\t _(\"parameter \\\"retry_promote_interval_secs\\\" has been removed; use \\\"primary_notification_timeout\\\" instead\"));\n\t}\n\telse\n\t{\n\t\titem_list_append_format(warning_list,\n\t\t\t\t\t\t\t\t_(\"%s='%s': unknown name/value pair provided; ignoring\"), name, value);\n\t}\n}\n\n\n\nbool\nparse_recovery_conf(const char *data_dir, t_recovery_conf *conf)\n{\n\tchar\t\trecovery_conf_path[MAXPGPATH] = \"\";\n\tFILE\t   *fp;\n\tchar\t   *s = NULL,\n\t\t\t\tbuf[MAXLINELENGTH] = \"\";\n\tchar\t\tname[MAXLEN] = \"\";\n\tchar\t\tvalue[MAXLEN] = \"\";\n\n\tsnprintf(recovery_conf_path, MAXPGPATH,\n\t\t\t \"%s/%s\",\n\t\t\t data_dir,\n\t\t\t RECOVERY_COMMAND_FILE);\n\n\tfp = fopen(recovery_conf_path, \"r\");\n\n\tif (fp == NULL)\n\t{\n\t\treturn false;\n\t}\n\n\t/* Read file */\n\twhile ((s = fgets(buf, sizeof buf, fp)) != NULL)\n\t{\n\n\t\t/* Parse name/value pair from line */\n\t\t_parse_line(buf, name, value);\n\n\t\t/* Skip blank lines */\n\t\tif (!strlen(name))\n\t\t\tcontinue;\n\n\t\t/* Skip comments */\n\t\tif (name[0] == '#')\n\t\t\tcontinue;\n\n\t\t/* archive recovery settings */\n\t\tif (strcmp(name, \"restore_command\") == 0)\n\t\t\tstrncpy(conf->restore_command, value, MAXLEN);\n\t\telse if (strcmp(name, \"archive_cleanup_command\") == 0)\n\t\t\tstrncpy(conf->archive_cleanup_command, value, MAXLEN);\n\t\telse if (strcmp(name, \"recovery_end_command\") == 0)\n\t\t\tstrncpy(conf->recovery_end_command, value, MAXLEN);\n\t\t/* recovery target settings */\n\t\telse if (strcmp(name, \"recovery_target_name\") == 0)\n\t\t\tstrncpy(conf->recovery_target_name, value, MAXLEN);\n\t\telse if (strcmp(name, \"recovery_target_time\") == 0)\n\t\t\tstrncpy(conf->recovery_target_time, value, MAXLEN);\n\t\telse if (strcmp(name, \"recovery_target_xid\") == 0)\n\t\t\tstrncpy(conf->recovery_target_xid, value, MAXLEN);\n\t\telse if (strcmp(name, \"recovery_target_inclusive\") == 0)\n\t\t\tconf->recovery_target_inclusive = parse_bool(value, NULL, NULL);\n\t\telse if (strcmp(name, \"recovery_target_timeline\") == 0)\n\t\t{\n\t\t\tif (strncmp(value, \"latest\", MAXLEN) == 0)\n\t\t\t{\n\t\t\t\tconf->recovery_target_timeline = TARGET_TIMELINE_LATEST;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconf->recovery_target_timeline = atoi(value);\n\t\t\t}\n\t\t}\n\t\telse if (strcmp(name, \"recovery_target_action\") == 0)\n\t\t{\n\t\t\tif (strcmp(value, \"pause\") == 0)\n\t\t\t\tconf->recovery_target_action = RTA_PAUSE;\n\t\t\telse if (strcmp(value, \"promote\") == 0)\n\t\t\t\tconf->recovery_target_action = RTA_PROMOTE;\n\t\t\telse if (strcmp(value, \"shutdown\") == 0)\n\t\t\t\tconf->recovery_target_action = RTA_SHUTDOWN;\n\t\t}\n\n\t\t/* standby server settings */\n\n\t\telse if (strcmp(name, \"standby_mode\") == 0)\n\t\t\tconf->standby_mode = parse_bool(value, NULL, NULL);\n\t\telse if (strcmp(name, \"primary_conninfo\") == 0)\n\t\t\tstrncpy(conf->primary_conninfo, value, MAXLEN);\n\t\telse if (strcmp(name, \"primary_slot_name\") == 0)\n\t\t\tstrncpy(conf->trigger_file, value, MAXLEN);\n\t\telse if (strcmp(name, \"trigger_file\") == 0)\n\t\t\tstrncpy(conf->trigger_file, value, MAXLEN);\n\t\telse if (strcmp(name, \"recovery_min_apply_delay\") == 0)\n\t\t\tparse_time_unit_parameter(name, value, conf->recovery_min_apply_delay, NULL);\n\n\t}\n\tfclose(fp);\n\n\treturn true;\n}\n\n\nvoid\n_parse_line(char *buf, char *name, char *value)\n{\n\tint\t\t\ti = 0;\n\tint\t\t\tj = 0;\n\n\t/*\n\t * Extract parameter name, if present\n\t */\n\tfor (; i < MAXLEN; ++i)\n\t{\n\t\tif (buf[i] == '=')\n\t\t\tbreak;\n\n\t\tswitch (buf[i])\n\t\t{\n\t\t\t\t/* Ignore whitespace */\n\t\t\tcase ' ':\n\t\t\tcase '\\n':\n\t\t\tcase '\\r':\n\t\t\tcase '\\t':\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tname[j++] = buf[i];\n\t\t}\n\t}\n\tname[j] = '\\0';\n\n\t/*\n\t * Ignore any whitespace following the '=' sign\n\t */\n\tfor (; i < MAXLEN; ++i)\n\t{\n\t\tif (buf[i + 1] == ' ')\n\t\t\tcontinue;\n\t\tif (buf[i + 1] == '\\t')\n\t\t\tcontinue;\n\n\t\tbreak;\n\t}\n\n\t/*\n\t * Extract parameter value\n\t */\n\tj = 0;\n\tfor (++i; i < MAXLEN; ++i)\n\t\tif (buf[i] == '\\'')\n\t\t\tcontinue;\n\t\telse if (buf[i] == '#')\n\t\t\tbreak;\n\t\telse if (buf[i] != '\\n')\n\t\t\tvalue[j++] = buf[i];\n\t\telse\n\t\t\tbreak;\n\tvalue[j] = '\\0';\n\ttrim(value);\n}\n\n\nvoid\nparse_time_unit_parameter(const char *name, const char *value, char *dest, ItemList *errors)\n{\n\tchar\t   *ptr = NULL;\n\tint\t\t\ttarg = strtol(value, &ptr, 10);\n\n\tif (targ < 0)\n\t{\n\t\tif (errors != NULL)\n\t\t{\n\t\t\titem_list_append_format(errors,\n\t\t\t\t\t\t\t\t\t_(\"invalid value \\\"%s\\\" provided for \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t\t\tname);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ptr && *ptr)\n\t{\n\t\tif (strcmp(ptr, \"ms\") != 0 && strcmp(ptr, \"s\") != 0 &&\n\t\t\tstrcmp(ptr, \"min\") != 0 && strcmp(ptr, \"h\") != 0 &&\n\t\t\tstrcmp(ptr, \"d\") != 0)\n\t\t{\n\t\t\tif (errors != NULL)\n\t\t\t{\n\t\t\t\titem_list_append_format(\n\t\t\t\t\t\t\t\t\t\terrors,\n\t\t\t\t\t\t\t\t\t\t_(\"value for \\\"%s\\\" must be one of ms/s/min/h/d (provided: \\\"%s\\\")\"),\n\t\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\t\tvalue);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tstrncpy(dest, value, MAXLEN);\n}\n\n/*\n * reload_config()\n *\n * This is only called by repmgrd after receiving a SIGHUP or when a monitoring\n * loop is started up; it therefore only needs to reload options required\n * by repmgrd, which are as follows:\n *\n * changeable options (keep the list in \"doc/repmgrd-configuration.xml\" in sync\n * with these):\n *\n * - async_query_timeout\n * - child_nodes_check_interval\n * - child_nodes_connected_min_count\n * - child_nodes_connected_include_witness\n * - child_nodes_disconnect_command\n * - child_nodes_disconnect_min_count\n * - child_nodes_disconnect_timeout\n * - connection_check_type\n * - conninfo\n * - degraded_monitoring_timeout\n * - event_notification_command\n * - event_notifications\n * - failover\n * - failover_validation_command\n * - follow_command\n * - log_facility\n * - log_file\n * - log_level\n * - log_status_interval\n * - monitor_interval_secs\n * - monitoring_history\n * - primary_notification_timeout\n * - primary_visibility_consensus\n * - always_promote\n * - promote_command\n * - reconnect_attempts\n * - reconnect_interval\n * - repmgrd_standby_startup_timeout\n * - retry_promote_interval_secs\n * - sibling_nodes_disconnect_timeout\n * - standby_disconnect_on_failover\n *\n *\n * Not publicly documented:\n * - promote_delay\n *\n * non-changeable options (repmgrd references these from the \"repmgr.nodes\"\n * table, not the configuration file)\n *\n * - node_id\n * - node_name\n * - data_directory\n * - location\n * - priority\n * - replication_type\n *\n * extract with something like:\n *\t grep config_file_options\\\\. repmgrd*.c | perl -n -e '/config_file_options\\.([\\w_]+)/ && print qq|$1\\n|;' | sort | uniq\n *\n * Returns \"true\" if the configuration was successfully changed, otherwise \"false\".\n */\nbool\nreload_config(t_server_type server_type)\n{\n\tbool\t\tlog_config_changed = false;\n\n\tItemList config_errors = {NULL, NULL};\n\tItemList config_warnings = {NULL, NULL};\n\tItemList config_changes = {NULL, NULL};\n\n\tt_configuration_options orig_config_file_options;\n\n\tcopy_config_file_options(&config_file_options, &orig_config_file_options);\n\n\tlog_info(_(\"reloading configuration file\"));\n\tlog_detail(_(\"using file \\\"%s\\\"\"), config_file_path);\n\n\t/*\n\t * _parse_config() will sanity-check the provided values and put any\n\t * errors/warnings in the provided lists; no need to add further sanity\n\t * checks here. We do still need to check for repmgrd-specific\n\t * requirements.\n\t */\n\t_parse_config(&config_errors, &config_warnings);\n\n\tif (config_file_options.failover == FAILOVER_AUTOMATIC\n\t\t&& (server_type == PRIMARY || server_type == STANDBY))\n\t{\n\t\tif (config_file_options.promote_command[0] == '\\0')\n\t\t{\n\t\t\titem_list_append(&config_errors, _(\"\\\"promote_command\\\": required parameter was not found\"));\n\t\t}\n\n\t\tif (config_file_options.follow_command[0] == '\\0')\n\t\t{\n\t\t\titem_list_append(&config_errors, _(\"\\\"follow_command\\\": required parameter was not found\"));\n\t\t}\n\t}\n\n\n\t/* The following options cannot be changed */\n\n\tif (config_file_options.node_id != orig_config_file_options.node_id)\n\t{\n\t\titem_list_append_format(&config_errors,\n\t\t\t\t\t\t\t\t_(\"\\\"node_id\\\" cannot be changed, retaining current configuration %i %i\"),\n\t\t\t\t\t\t\t\tconfig_file_options.node_id,\n\t\t\t\t\t\t\t\torig_config_file_options.node_id);\n\t}\n\n\tif (strncmp(config_file_options.node_name, orig_config_file_options.node_name, sizeof(config_file_options.node_name)) != 0)\n\t{\n\t\titem_list_append(&config_errors,\n\t\t\t\t\t\t _(\"\\\"node_name\\\" cannot be changed, keeping current configuration\"));\n\t}\n\n\n\t/*\n\t * conninfo\n\t *\n\t * _parse_config() will already have sanity-checked the string; we do that here\n\t * again so we can avoid trying to connect with a known bad string\n\t */\n\tif (strncmp(config_file_options.conninfo, orig_config_file_options.conninfo, sizeof(config_file_options.conninfo)) != 0 && validate_conninfo_string(config_file_options.conninfo, NULL))\n\t{\n\t\tPGconn\t   *conn;\n\n\t\t/* Test conninfo string works */\n\t\tconn = establish_db_connection(config_file_options.conninfo, false);\n\n\t\tif (!conn || (PQstatus(conn) != CONNECTION_OK))\n\t\t{\n\t\t\titem_list_append_format(&config_errors,\n\t\t\t\t\t\t\t\t\t_(\"provided \\\"conninfo\\\" string \\\"%s\\\" is not valid\"),\n\t\t\t\t\t\t\t\t\tconfig_file_options.conninfo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t\t_(\"\\\"conninfo\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\t\torig_config_file_options.conninfo,\n\t\t\t\t\t\t\t\t\tconfig_file_options.conninfo);\n\t\t}\n\n\t\tPQfinish(conn);\n\t}\n\n\n\t/*\n\t * If any issues encountered, raise an error and roll back to the original\n\t * configuration\n\t */\n\tif (config_errors.head != NULL)\n\t{\n\t\tItemListCell *cell = NULL;\n\t\tPQExpBufferData errors;\n\n\t\tlog_error(_(\"one or more errors encountered while parsing the configuration file\"));\n\n\t\tinitPQExpBuffer(&errors);\n\n\t\tappendPQExpBufferStr(&errors,\n\t\t\t\t\t\t\t \"following errors were detected:\\n\");\n\n\t\tfor (cell = config_errors.head; cell; cell = cell->next)\n\t\t{\n\t\t\tappendPQExpBuffer(&errors,\n\t\t\t\t\t\t\t  \"  %s\\n\", cell->string);\n\t\t}\n\n\t\tlog_detail(\"%s\", errors.data);\n\t\ttermPQExpBuffer(&errors);\n\n\t\tlog_notice(_(\"the current configuration has been retained unchanged\"));\n\n\t\tcopy_config_file_options(&orig_config_file_options, &config_file_options);\n\n\t\treturn false;\n\t}\n\n\n\t/*\n\t * No configuration problems detected - log any changed values.\n\t *\n\t * NB: keep these in the same order as in configfile.h to make it easier\n\t * to manage them\n\t */\n\n\n\t/* async_query_timeout */\n\tif (config_file_options.async_query_timeout != orig_config_file_options.async_query_timeout)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"async_query_timeout\\\" changed from \\\"%i\\\" to \\\"%i\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.async_query_timeout,\n\t\t\t\t\t\t\t\tconfig_file_options.async_query_timeout);\n\t}\n\n\t/* child_nodes_check_interval */\n\tif (config_file_options.child_nodes_check_interval != orig_config_file_options.child_nodes_check_interval)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"child_nodes_check_interval\\\" changed from \\\"%i\\\" to \\\"%i\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.child_nodes_check_interval,\n\t\t\t\t\t\t\t\tconfig_file_options.child_nodes_check_interval);\n\t}\n\n\t/* child_nodes_disconnect_command */\n\tif (strncmp(config_file_options.child_nodes_disconnect_command, orig_config_file_options.child_nodes_disconnect_command, sizeof(config_file_options.child_nodes_disconnect_command)) != 0)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"child_nodes_disconnect_command\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.child_nodes_disconnect_command,\n\t\t\t\t\t\t\t\tconfig_file_options.child_nodes_disconnect_command);\n\t}\n\n\t/* child_nodes_disconnect_min_count */\n\tif (config_file_options.child_nodes_disconnect_min_count != orig_config_file_options.child_nodes_disconnect_min_count)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"child_nodes_disconnect_min_count\\\" changed from \\\"%i\\\" to \\\"%i\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.child_nodes_disconnect_min_count,\n\t\t\t\t\t\t\t\tconfig_file_options.child_nodes_disconnect_min_count);\n\t}\n\n\t/* child_nodes_connected_min_count */\n\tif (config_file_options.child_nodes_connected_min_count != orig_config_file_options.child_nodes_connected_min_count)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"child_nodes_connected_min_count\\\" changed from \\\"%i\\\" to \\\"%i\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.child_nodes_connected_min_count,\n\t\t\t\t\t\t\t\tconfig_file_options.child_nodes_connected_min_count);\n\t}\n\n\t/* child_nodes_connected_include_witness */\n\tif (config_file_options.child_nodes_connected_include_witness != orig_config_file_options.child_nodes_connected_include_witness)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"child_nodes_connected_include_witness\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\tformat_bool(orig_config_file_options.child_nodes_connected_include_witness),\n\t\t\t\t\t\t\t\tformat_bool(config_file_options.child_nodes_connected_include_witness));\n\t}\n\n\t/* child_nodes_disconnect_timeout */\n\tif (config_file_options.child_nodes_disconnect_timeout != orig_config_file_options.child_nodes_disconnect_timeout)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"child_nodes_disconnect_timeout\\\" changed from \\\"%i\\\" to \\\"%i\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.child_nodes_disconnect_timeout,\n\t\t\t\t\t\t\t\tconfig_file_options.child_nodes_disconnect_timeout);\n\t}\n\n\n\t/* degraded_monitoring_timeout */\n\tif (config_file_options.degraded_monitoring_timeout != orig_config_file_options.degraded_monitoring_timeout)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"degraded_monitoring_timeout\\\" changed from \\\"%i\\\" to \\\"%i\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.degraded_monitoring_timeout,\n\t\t\t\t\t\t\t\tconfig_file_options.degraded_monitoring_timeout);\n\t}\n\n\t/* event_notification_command */\n\tif (strncmp(config_file_options.event_notification_command, orig_config_file_options.event_notification_command, sizeof(config_file_options.event_notification_command)) != 0)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"event_notification_command\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.event_notification_command,\n\t\t\t\t\t\t\t\tconfig_file_options.event_notification_command);\n\t}\n\n\t/* event_notifications */\n\tif (strncmp(config_file_options.event_notifications_orig, orig_config_file_options.event_notifications_orig, sizeof(config_file_options.event_notifications_orig)) != 0)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"event_notifications\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.event_notifications_orig,\n\t\t\t\t\t\t\t\tconfig_file_options.event_notifications_orig);\n\t}\n\n\t/* failover */\n\tif (config_file_options.failover != orig_config_file_options.failover)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"failover\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\tformat_failover_mode(orig_config_file_options.failover),\n\t\t\t\t\t\t\t\tformat_failover_mode(config_file_options.failover));\n\t}\n\n\t/* follow_command */\n\tif (strncmp(config_file_options.follow_command, orig_config_file_options.follow_command, sizeof(config_file_options.follow_command)) != 0)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"follow_command\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.follow_command,\n\t\t\t\t\t\t\t\tconfig_file_options.follow_command);\n\t}\n\n\t/* monitor_interval_secs */\n\tif (config_file_options.monitor_interval_secs != orig_config_file_options.monitor_interval_secs)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"monitor_interval_secs\\\" changed from \\\"%i\\\" to \\\"%i\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.monitor_interval_secs,\n\t\t\t\t\t\t\t\tconfig_file_options.monitor_interval_secs);\n\t}\n\n\t/* monitoring_history */\n\tif (config_file_options.monitoring_history != orig_config_file_options.monitoring_history)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"monitoring_history\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\tformat_bool(orig_config_file_options.monitoring_history),\n\t\t\t\t\t\t\t\tformat_bool(config_file_options.monitoring_history));\n\t}\n\n\t/* primary_notification_timeout */\n\tif (config_file_options.primary_notification_timeout != orig_config_file_options.primary_notification_timeout)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"primary_notification_timeout\\\" changed from \\\"%i\\\" to \\\"%i\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.primary_notification_timeout,\n\t\t\t\t\t\t\t\tconfig_file_options.primary_notification_timeout);\n\t}\n\n\t/* promote_command */\n\tif (strncmp(config_file_options.promote_command, orig_config_file_options.promote_command, sizeof(config_file_options.promote_command)) != 0)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"promote_command\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.promote_command,\n\t\t\t\t\t\t\t\tconfig_file_options.promote_command);\n\t}\n\n\t/* promote_delay (for testing use only; not documented */\n\tif (config_file_options.promote_delay != orig_config_file_options.promote_delay)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"promote_delay\\\" changed from \\\"%i\\\" to \\\"%i\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.promote_delay,\n\t\t\t\t\t\t\t\tconfig_file_options.promote_delay);\n\t}\n\n\t/* reconnect_attempts */\n\tif (config_file_options.reconnect_attempts != orig_config_file_options.reconnect_attempts)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"reconnect_attempts\\\" changed from \\\"%i\\\" to \\\"%i\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.reconnect_attempts,\n\t\t\t\t\t\t\t\tconfig_file_options.reconnect_attempts);\n\t}\n\n\t/* reconnect_interval */\n\tif (config_file_options.reconnect_interval != orig_config_file_options.reconnect_interval)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"reconnect_interval\\\" changed from \\\"%i\\\" to \\\"%i\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.reconnect_interval,\n\t\t\t\t\t\t\t\tconfig_file_options.reconnect_interval);\n\t}\n\n\t/* repmgrd_standby_startup_timeout */\n\tif (config_file_options.repmgrd_standby_startup_timeout != orig_config_file_options.repmgrd_standby_startup_timeout)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"repmgrd_standby_startup_timeout\\\" changed from \\\"%i\\\" to \\\"%i\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.repmgrd_standby_startup_timeout,\n\t\t\t\t\t\t\t\tconfig_file_options.repmgrd_standby_startup_timeout);\n\t}\n\n\t/* standby_disconnect_on_failover */\n\tif (config_file_options.standby_disconnect_on_failover != orig_config_file_options.standby_disconnect_on_failover)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"standby_disconnect_on_failover\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\tformat_bool(orig_config_file_options.standby_disconnect_on_failover),\n\t\t\t\t\t\t\t\tformat_bool(config_file_options.standby_disconnect_on_failover));\n\t}\n\n\t/* sibling_nodes_disconnect_timeout */\n\tif (config_file_options.sibling_nodes_disconnect_timeout != orig_config_file_options.sibling_nodes_disconnect_timeout)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"sibling_nodes_disconnect_timeout\\\" changed from \\\"%i\\\" to \\\"%i\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.sibling_nodes_disconnect_timeout,\n\t\t\t\t\t\t\t\tconfig_file_options.sibling_nodes_disconnect_timeout);\n\t}\n\n\t/* connection_check_type */\n\tif (config_file_options.connection_check_type != orig_config_file_options.connection_check_type)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"connection_check_type\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\tprint_connection_check_type(orig_config_file_options.connection_check_type),\n\t\t\t\t\t\t\t\tprint_connection_check_type(config_file_options.connection_check_type));\n\t}\n\n\t/* primary_visibility_consensus */\n\tif (config_file_options.primary_visibility_consensus != orig_config_file_options.primary_visibility_consensus)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"primary_visibility_consensus\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\tformat_bool(orig_config_file_options.primary_visibility_consensus),\n\t\t\t\t\t\t\t\tformat_bool(config_file_options.primary_visibility_consensus));\n\t}\n\n\t/* always_promote */\n\tif (config_file_options.always_promote != orig_config_file_options.always_promote)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"always_promote\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\tformat_bool(orig_config_file_options.always_promote),\n\t\t\t\t\t\t\t\tformat_bool(config_file_options.always_promote));\n\t}\n\n\t/* failover_validation_command */\n\tif (strncmp(config_file_options.failover_validation_command, orig_config_file_options.failover_validation_command, sizeof(config_file_options.failover_validation_command)) != 0)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"failover_validation_command\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.failover_validation_command,\n\t\t\t\t\t\t\t\tconfig_file_options.failover_validation_command);\n\t}\n\n\t/*\n\t * Handle changes to logging configuration\n\t */\n\n\t/* log_facility */\n\tif (strncmp(config_file_options.log_facility, orig_config_file_options.log_facility, sizeof(config_file_options.log_facility)) != 0)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"log_facility\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.log_facility,\n\t\t\t\t\t\t\t\tconfig_file_options.log_facility);\n\t}\n\n\t/* log_file */\n\tif (strncmp(config_file_options.log_file, orig_config_file_options.log_file, sizeof(config_file_options.log_file)) != 0)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"log_file\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.log_file,\n\t\t\t\t\t\t\t\tconfig_file_options.log_file);\n\t}\n\n\n\t/* log_level */\n\tif (strncmp(config_file_options.log_level, orig_config_file_options.log_level, sizeof(config_file_options.log_level)) != 0)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"log_level\\\" changed from \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.log_level,\n\t\t\t\t\t\t\t\tconfig_file_options.log_level);\n\t}\n\n\t/* log_status_interval */\n\tif (config_file_options.log_status_interval != orig_config_file_options.log_status_interval)\n\t{\n\t\titem_list_append_format(&config_changes,\n\t\t\t\t\t\t\t\t_(\"\\\"log_status_interval\\\" changed from \\\"%i\\\" to \\\"%i\\\"\"),\n\t\t\t\t\t\t\t\torig_config_file_options.log_status_interval,\n\t\t\t\t\t\t\t\tconfig_file_options.log_status_interval);\n\t}\n\n\n\tif (log_config_changed == true)\n\t{\n\t\tlog_notice(_(\"restarting logging with changed parameters\"));\n\t\tlogger_shutdown();\n\t\tlogger_init(&config_file_options, progname());\n\t\tlog_notice(_(\"configuration file reloaded with changed parameters\"));\n\t}\n\n\tif (config_changes.head != NULL)\n\t{\n\t\tItemListCell *cell = NULL;\n\t\tPQExpBufferData detail;\n\n\t\tlog_notice(_(\"configuration was successfully changed\"));\n\n\t\tinitPQExpBuffer(&detail);\n\n\t\tappendPQExpBufferStr(&detail,\n\t\t\t\t\t\t\t _(\"following configuration items were changed:\\n\"));\n\t\tfor (cell = config_changes.head; cell; cell = cell->next)\n\t\t{\n\t\t\tappendPQExpBuffer(&detail,\n\t\t\t\t\t\t\t  \"  %s\\n\", cell->string);\n\t\t}\n\n\t\tlog_detail(\"%s\", detail.data);\n\n\t\ttermPQExpBuffer(&detail);\n\t}\n\telse\n\t{\n\t\tlog_info(_(\"configuration has not changed\"));\n\t}\n\n\t/*\n\t * parse_configuration_item() (called from _parse_config()) will add warnings\n\t * about any deprecated configuration parameters; we'll dump these here as a reminder.\n\t */\n\tif (config_warnings.head != NULL)\n\t{\n\t\tItemListCell *cell = NULL;\n\t\tPQExpBufferData detail;\n\n\t\tlog_warning(_(\"configuration file contains deprecated parameters\"));\n\n\t\tinitPQExpBuffer(&detail);\n\n\t\tappendPQExpBufferStr(&detail,\n\t\t\t\t\t\t\t _(\"following parameters are deprecated:\\n\"));\n\t\tfor (cell = config_warnings.head; cell; cell = cell->next)\n\t\t{\n\t\t\tappendPQExpBuffer(&detail,\n\t\t\t\t\t\t\t  \"  %s\\n\", cell->string);\n\t\t}\n\n\t\tlog_detail(\"%s\", detail.data);\n\n\t\ttermPQExpBuffer(&detail);\n\t}\n\n\treturn config_changes.head == NULL ? false : true;\n}\n\n\n/*\n * Dump the parsed configuration\n */\nvoid\ndump_config(void)\n{\n\tConfigFileSetting *setting;\n\tint i = 0;\n\n\tsetting = &config_file_settings[0];\n\n\tdo {\n\t\tprintf(\"%s|\", setting->name);\n\t\tswitch (setting->type)\n\t\t{\n\t\t\tcase CONFIG_INT:\n\t\t\t\tprintf(\"%i\", *setting->val.intptr);\n\t\t\t\tbreak;\n\t\t\tcase CONFIG_BOOL:\n\t\t\t\tprintf(\"%s\", format_bool(*setting->val.boolptr));\n\t\t\t\tbreak;\n\t\t\tcase CONFIG_STRING:\n\t\t\t\tprintf(\"%s\", setting->val.strptr);\n\t\t\t\tbreak;\n\t\t\tcase CONFIG_FAILOVER_MODE:\n\t\t\t\tprintf(\"%s\", format_failover_mode(*setting->val.failovermodeptr));\n\t\t\t\tbreak;\n\t\t\tcase CONFIG_CONNECTION_CHECK_TYPE:\n\t\t\t\tprintf(\"%s\", print_connection_check_type(*setting->val.checktypeptr));\n\t\t\t\tbreak;\n\t\t\tcase CONFIG_REPLICATION_TYPE:\n\t\t\t\tprintf(\"%s\", print_replication_type(*setting->val.replicationtypeptr));\n\t\t\t\tbreak;\n\t\t\tcase CONFIG_EVENT_NOTIFICATION_LIST:\n\t\t\t{\n\t\t\t\tchar *list = print_event_notification_list(setting->val.notificationlistptr);\n\t\t\t\tprintf(\"%s\", list);\n\t\t\t\tpfree(list);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CONFIG_TABLESPACE_MAPPING:\n\t\t\t{\n\t\t\t\tchar *list = print_tablespace_mapping(setting->val.tablespacemappingptr);\n\t\t\t\tprintf(\"%s\", list);\n\t\t\t\tpfree(list);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* this should never happen */\n\t\t\t\tlog_error(\"unhandled setting type %i\", (int)setting->type);\n\t\t}\n\t\tputs(\"\");\n\t\ti++;\n\t\tsetting = &config_file_settings[i];\n\t} while (setting->name != NULL);\n\n}\n\nstatic void\nexit_with_config_file_errors(ItemList *config_errors, ItemList *config_warnings, bool terse)\n{\n\tlog_error(_(\"following errors were found in the configuration file:\"));\n\n\tprint_item_list(config_errors);\n\titem_list_free(config_errors);\n\n\tif (terse == false && config_warnings->head != NULL)\n\t{\n\t\tputs(\"\");\n\t\tlog_warning(_(\"the following problems were also found in the configuration file:\"));\n\n\t\tprint_item_list(config_warnings);\n\t\titem_list_free(config_warnings);\n\t}\n\n\tif (config_file_provided == false)\n\t\tlog_detail(_(\"configuration file is: \\\"%s\\\"\"), config_file_path);\n\n\texit(ERR_BAD_CONFIG);\n}\n\n\nvoid\nexit_with_cli_errors(ItemList *error_list, const char *repmgr_command)\n{\n\tfprintf(stderr, _(\"The following command line errors were encountered:\\n\"));\n\n\tprint_item_list(error_list);\n\n\tif (repmgr_command != NULL)\n\t{\n\t\tfprintf(stderr, _(\"Try \\\"%s --help\\\" or \\\"%s %s --help\\\" for more information.\\n\"),\n\t\t\t\tprogname(),\n\t\t\t\tprogname(),\n\t\t\t\trepmgr_command);\n\t}\n\telse\n\t{\n\t\tfprintf(stderr, _(\"Try \\\"%s --help\\\" for more information.\\n\"), progname());\n\t}\n\n\texit(ERR_BAD_CONFIG);\n}\n\nvoid\nprint_item_list(ItemList *item_list)\n{\n\tItemListCell *cell = NULL;\n\n\tfor (cell = item_list->head; cell; cell = cell->next)\n\t{\n\t\tfprintf(stderr, \"  %s\\n\", cell->string);\n\t}\n}\n\n\n\n\n/*\n * Convert provided string to an integer using strtol;\n * on error, if a callback is provided, pass the error message to that,\n * otherwise exit\n */\nint\nrepmgr_atoi(const char *value, const char *config_item, ItemList *error_list, int minval)\n{\n\tchar\t   *endptr = NULL;\n\tlong\t\tlongval = 0;\n\tPQExpBufferData errors;\n\n\tinitPQExpBuffer(&errors);\n\n\t/*\n\t * It's possible that some versions of strtol() don't treat an empty\n\t * string as an error.\n\t */\n\tif (*value == '\\0')\n\t{\n\t\t/* don't log here - empty values will be caught later */\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\terrno = 0;\n\t\tlongval = strtol(value, &endptr, 10);\n\n\t\tif (value == endptr || errno)\n\t\t{\n\t\t\tappendPQExpBuffer(&errors,\n\t\t\t\t\t\t\t  _(\"\\\"%s\\\": invalid value (provided: \\\"%s\\\")\"),\n\t\t\t\t\t\t\t  config_item, value);\n\t\t}\n\t\telse if ((int32) longval < longval)\n\t\t{\n\t\t\tappendPQExpBuffer(&errors,\n\t\t\t\t\t\t\t  _(\"\\\"%s\\\": must be a positive signed 32 bit integer, i.e. 2147483647 or less (provided: \\\"%s\\\")\"),\n\t\t\t\t\t\t\t  config_item,\n\t\t\t\t\t\t\t  value);\n\t\t}\n\t\telse if ((int32) longval < minval)\n\t\t\t/* Disallow negative values for most parameters */\n\t\t{\n\t\t\tappendPQExpBuffer(&errors,\n\t\t\t\t\t\t\t  _(\"\\\"%s\\\": must be %i or greater (provided: \\\"%s\\\")\"),\n\t\t\t\t\t\t\t  config_item,\n\t\t\t\t\t\t\t  minval,\n\t\t\t\t\t\t\t  value);\n\t\t}\n\t}\n\n\t/* Error message buffer is set */\n\tif (errors.data[0] != '\\0')\n\t{\n\t\tif (error_list == NULL)\n\t\t{\n\t\t\tlog_error(\"%s\", errors.data);\n\t\t\ttermPQExpBuffer(&errors);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\titem_list_append(error_list, errors.data);\n\t}\n\n\ttermPQExpBuffer(&errors);\n\treturn (int32) longval;\n}\n\nvoid\nrepmgr_canonicalize_path(const char *name, const char *value, char *config_item, ItemList *errors)\n{\n\t/* NOTE: canonicalize_path does not produce any errors */\n\tcanonicalize_path(config_item);\n}\n\n\n/*\n * Interpret a parameter value as a boolean. Currently accepts:\n *\n * - true/false\n * - 1/0\n * - on/off\n * - yes/no\n\n * Returns 'false' if unable to determine the booleanness of the value\n * and adds an entry to the error list, which will result in the program\n * erroring out before it proceeds to do anything.\n *\n * TODO: accept \"any unambiguous prefix of one of these\" as per postgresql.conf:\n *\n *   https://www.postgresql.org/docs/current/config-setting.html\n */\nbool\nparse_bool(const char *s, const char *config_item, ItemList *error_list)\n{\n\tPQExpBufferData errors;\n\n\tif (s == NULL)\n\t\treturn true;\n\n\tif (strcasecmp(s, \"0\") == 0)\n\t\treturn false;\n\n\tif (strcasecmp(s, \"1\") == 0)\n\t\treturn true;\n\n\tif (strcasecmp(s, \"false\") == 0)\n\t\treturn false;\n\n\tif (strcasecmp(s, \"true\") == 0)\n\t\treturn true;\n\n\tif (strcasecmp(s, \"off\") == 0)\n\t\treturn false;\n\n\tif (strcasecmp(s, \"on\") == 0)\n\t\treturn true;\n\n\tif (strcasecmp(s, \"no\") == 0)\n\t\treturn false;\n\n\tif (strcasecmp(s, \"yes\") == 0)\n\t\treturn true;\n\n\tif (error_list != NULL)\n\t{\n\t\tinitPQExpBuffer(&errors);\n\n\t\tappendPQExpBuffer(&errors,\n\t\t\t\t\t\t  \"\\\"%s\\\": unable to interpret \\\"%s\\\" as a boolean value\",\n\t\t\t\t\t\t  config_item, s);\n\t\titem_list_append(error_list, errors.data);\n\t\ttermPQExpBuffer(&errors);\n\t}\n\n\treturn false;\n}\n\n\n/*\n * Copy a configuration file struct\n */\n\nvoid\ncopy_config_file_options(t_configuration_options *original, t_configuration_options *copy)\n{\n\tmemcpy(copy, original, (int)sizeof(t_configuration_options));\n\n\t/* Copy structures which point to allocated memory */\n\n\tif (original->event_notifications.head != NULL)\n\t{\n\t\t/* For the event notifications, we can just reparse the string */\n\t\tparse_event_notifications_list(&copy->event_notifications, original->event_notifications_orig);\n\t}\n\n\tif (original->tablespace_mapping.head != NULL)\n\t{\n\t\t/*\n\t\t * We allow multiple instances of \"tablespace_mapping\" in the configuration file\n\t\t * which are appended to the list as they're encountered.\n\t\t */\n\t\ttablespace_list_copy(original, copy);\n\t}\n}\n\n\n/*\n * Split argument into old_dir and new_dir and append to tablespace mapping\n * list.\n *\n * Adapted from pg_basebackup.c\n */\nstatic void\ntablespace_list_append(TablespaceList *tablespace_mapping, const char *arg)\n{\n\tTablespaceListCell *cell = NULL;\n\tchar\t   *dst = NULL;\n\tchar\t   *dst_ptr = NULL;\n\tconst char *arg_ptr = NULL;\n\n\tcell = (TablespaceListCell *) pg_malloc0(sizeof(TablespaceListCell));\n\tif (cell == NULL)\n\t{\n\t\tlog_error(_(\"unable to allocate memory; terminating\"));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tdst_ptr = dst = cell->old_dir;\n\tfor (arg_ptr = arg; *arg_ptr; arg_ptr++)\n\t{\n\t\tif (dst_ptr - dst >= MAXPGPATH)\n\t\t{\n\t\t\tlog_error(_(\"directory name too long\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tif (*arg_ptr == '\\\\' && *(arg_ptr + 1) == '=')\n\t\t\t;\t\t\t\t\t/* skip backslash escaping = */\n\t\telse if (*arg_ptr == '=' && (arg_ptr == arg || *(arg_ptr - 1) != '\\\\'))\n\t\t{\n\t\t\tif (*cell->new_dir)\n\t\t\t{\n\t\t\t\tlog_error(_(\"multiple \\\"=\\\" signs in tablespace mapping\"));\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdst = dst_ptr = cell->new_dir;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\t*dst_ptr++ = *arg_ptr;\n\t}\n\n\tif (!*cell->old_dir || !*cell->new_dir)\n\t{\n\t\tlog_error(_(\"invalid tablespace mapping format \\\"%s\\\", must be \\\"OLDDIR=NEWDIR\\\"\"),\n\t\t\t\t  arg);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tcanonicalize_path(cell->old_dir);\n\tcanonicalize_path(cell->new_dir);\n\n\tif (tablespace_mapping->tail)\n\t\ttablespace_mapping->tail->next = cell;\n\telse\n\t\ttablespace_mapping->head = cell;\n\n\ttablespace_mapping->tail = cell;\n}\n\n\nstatic void\ntablespace_list_copy(t_configuration_options *original, t_configuration_options *copy)\n{\n\tTablespaceListCell *orig_cell = original->tablespace_mapping.head;\n\n\tfor (orig_cell = config_file_options.tablespace_mapping.head; orig_cell; orig_cell = orig_cell->next)\n\t{\n\t\tTablespaceListCell *copy_cell = (TablespaceListCell *) pg_malloc0(sizeof(TablespaceListCell));\n\n\t\tstrncpy(copy_cell->old_dir, orig_cell->old_dir, sizeof(copy_cell->old_dir));\n\t\tstrncpy(copy_cell->new_dir, orig_cell->new_dir, sizeof(copy_cell->new_dir));\n\n\t\tif (copy->tablespace_mapping.tail)\n\t\t\tcopy->tablespace_mapping.tail->next = copy_cell;\n\t\telse\n\t\t\tcopy->tablespace_mapping.head = copy_cell;\n\n\t\tcopy->tablespace_mapping.tail = copy_cell;\n\t}\n}\n\n\nstatic void\ntablespace_list_free(t_configuration_options *options)\n{\n\tTablespaceListCell *cell = NULL;\n\tTablespaceListCell *next_cell = NULL;\n\n\tcell = options->tablespace_mapping.head;\n\n\twhile (cell != NULL)\n\t{\n\t\tnext_cell = cell->next;\n\t\tpfree(cell);\n\t\tcell = next_cell;\n\t}\n\n\toptions->tablespace_mapping.head = NULL;\n\toptions->tablespace_mapping.tail = NULL;\n}\n\n\nbool\nmodify_auto_conf(const char *data_dir, KeyValueList *items)\n{\n\tPQExpBufferData auto_conf;\n\tPQExpBufferData auto_conf_tmp;\n\tPQExpBufferData auto_conf_contents;\n\n\tFILE\t   *fp;\n\tmode_t\t\tum;\n\tstruct stat data_dir_st;\n\n\tKeyValueList config = {NULL, NULL};\n\tKeyValueListCell *cell = NULL;\n\n\tbool\t   success = true;\n\n\tinitPQExpBuffer(&auto_conf);\n\tappendPQExpBuffer(&auto_conf, \"%s/%s\",\n\t\t\t\t\t  data_dir, PG_AUTOCONF_FILENAME);\n\n\tsuccess = ProcessPostgresConfigFile(auto_conf.data,\n\t\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\t\tfalse, /* we don't care if the file does not exist */\n\t\t\t\t\t\t\t\t\t\t&config,\n\t\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\t\tNULL);\n\n\tif (success == false)\n\t{\n\t\tfprintf(stderr, \"unable to process \\\"%s\\\"\\n\",\n\t\t\t\tauto_conf.data);\n\t\ttermPQExpBuffer(&auto_conf);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Append requested items to any items extracted from the existing file.\n\t */\n\tfor (cell = items->head; cell; cell = cell->next)\n\t{\n\t\tkey_value_list_replace_or_set(&config,\n\t\t\t\t\t\t\t\t\t  cell->key,\n\t\t\t\t\t\t\t\t\t  cell->value);\n\t}\n\n\tinitPQExpBuffer(&auto_conf_tmp);\n\tappendPQExpBuffer(&auto_conf_tmp, \"%s.tmp\",\n\t\t\t\t\t  auto_conf.data);\n\n\tinitPQExpBuffer(&auto_conf_contents);\n\n\t/*\n\t * Keep this in sync with src/backend/utils/misc/guc.c:write_auto_conf_file()\n\t */\n\tappendPQExpBufferStr(&auto_conf_contents,\n\t\t\t\t\t\t \"# Do not edit this file manually!\\n\"\n\t\t\t\t\t\t \"# It will be overwritten by the ALTER SYSTEM command.\\n\");\n\n\tfor (cell = config.head; cell; cell = cell->next)\n\t{\n\t\tappendPQExpBuffer(&auto_conf_contents,\n\t\t\t\t\t\t  \"%s = '%s'\\n\",\n\t\t\t\t\t\t  cell->key, cell->value);\n\t}\n\n\t/* stat the data directory for the file mode */\n\tif (stat(data_dir, &data_dir_st) != 0)\n\t{\n\t\t/*\n\t\t * This is highly unlikely to happen, but if it does (e.g. freak\n\t\t * race condition with some rogue process which is messing about\n\t\t * with the data directory), there's not a lot we can do.\n\t\t */\n\t\tlog_error(_(\"error encountered when checking \\\"%s\\\"\"),\n\t\t\t\t  data_dir);\n\t\tlog_detail(\"%s\", strerror(errno));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * Set umask so the temporary file is created in the same mode as the data\n\t * directory. In PostgreSQL 11 and later this can be 0700 or 0750.\n\t */\n\tum = umask(~(data_dir_st.st_mode));\n\n\tfp = fopen(auto_conf_tmp.data, \"w\");\n\n\tumask(um);\n\n\tif (fp == NULL)\n\t{\n\t\tfprintf(stderr, \"unable to open \\\"%s\\\" for writing: %s\\n\",\n\t\t\t\tauto_conf_tmp.data,\n\t\t\t\tstrerror(errno));\n\t\tsuccess = false;\n\t}\n\telse\n\t{\n\t\tif (fwrite(auto_conf_contents.data, strlen(auto_conf_contents.data), 1, fp) != 1)\n\t\t{\n\t\t\tfprintf(stderr, \"unable to write to \\\"%s\\\": %s\\n\",\n\t\t\t\t\tauto_conf_tmp.data,\n\t\t\t\t\tstrerror(errno));\n\t\t\tfclose(fp);\n\t\t\tsuccess = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfclose(fp);\n\n\t\t\t/*\n\t\t\t * Note: durable_rename() is not exposed to frontend code before Pg 10.\n\t\t\t * We only really need to be modifying postgresql.auto.conf from Pg 12,\n\t\t\t * but provide backwards compatibility for Pg 9.6 and earlier for the\n\t\t\t * (unlikely) event that a repmgr built against one of those versions\n\t\t\t * is being used against Pg 12 and later.\n\t\t\t */\n\n#if (PG_ACTUAL_VERSION_NUM >= 100000)\n\t\t\tif (durable_rename(auto_conf_tmp.data, auto_conf.data, LOG) != 0)\n\t\t\t{\n\t\t\t\tsuccess = false;\n\t\t\t}\n#else\n\t\t\tif (rename(auto_conf_tmp.data, auto_conf.data) < 0)\n\t\t\t{\n\t\t\t\tsuccess = false;\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\ttermPQExpBuffer(&auto_conf);\n\ttermPQExpBuffer(&auto_conf_tmp);\n\ttermPQExpBuffer(&auto_conf_contents);\n\n\tkey_value_list_free(&config);\n\n\treturn success;\n}\n\n\n/*\n * parse_event_notifications_list()\n *\n *\n */\n\nstatic void\nparse_event_notifications_list(EventNotificationList *event_notifications, const char *arg)\n{\n\tconst char *arg_ptr = NULL;\n\tchar\t\tevent_type_buf[MAXLEN] = \"\";\n\tchar\t   *dst_ptr = event_type_buf;\n\n\tfor (arg_ptr = arg; arg_ptr <= (arg + strlen(arg)); arg_ptr++)\n\t{\n\t\t/* ignore whitespace */\n\t\tif (*arg_ptr == ' ' || *arg_ptr == '\\t')\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * comma (or end-of-string) should mark the end of an event type -\n\t\t * just as long as there was something preceding it\n\t\t */\n\t\tif ((*arg_ptr == ',' || *arg_ptr == '\\0') && event_type_buf[0] != '\\0')\n\t\t{\n\t\t\tEventNotificationListCell *cell;\n\n\t\t\tcell = (EventNotificationListCell *) pg_malloc0(sizeof(EventNotificationListCell));\n\n\t\t\tif (cell == NULL)\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to allocate memory; terminating\"));\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\n\t\t\tstrncpy(cell->event_type, event_type_buf, MAXLEN);\n\n\t\t\tif (event_notifications->tail)\n\t\t\t{\n\t\t\t\tevent_notifications->tail->next = cell;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tevent_notifications->head = cell;\n\t\t\t}\n\n\t\t\tevent_notifications->tail = cell;\n\n\t\t\tmemset(event_type_buf, 0, MAXLEN);\n\t\t\tdst_ptr = event_type_buf;\n\t\t}\n\t\t/* ignore duplicated commas */\n\t\telse if (*arg_ptr == ',')\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*dst_ptr++ = *arg_ptr;\n\t\t}\n\t}\n}\n\n\nstatic void\nclear_event_notification_list(EventNotificationList *event_notifications)\n{\n\tif (event_notifications->head != NULL)\n\t{\n\t\tEventNotificationListCell *cell;\n\t\tEventNotificationListCell *next_cell;\n\n\t\tcell = event_notifications->head;\n\n\t\twhile (cell != NULL)\n\t\t{\n\t\t\tnext_cell = cell->next;\n\t\t\tpfree(cell);\n\t\t\tcell = next_cell;\n\t\t}\n\t}\n\n\tevent_notifications->head = NULL;\n\tevent_notifications->tail = NULL;\n}\n\n\nint\nparse_output_to_argv(const char *string, char ***argv_array)\n{\n\tint\t\t\toptions_len = 0;\n\tchar\t   *options_string = NULL;\n\tchar\t   *options_string_ptr = NULL;\n\tint\t\t\tc = 1,\n\t   \t\t\targc_item = 1;\n\tchar\t   *argv_item = NULL;\n\tchar\t  **local_argv_array = NULL;\n\tItemListCell *cell;\n\n\t/*\n\t * Add parsed options to this list, then copy to an array to pass to\n\t * getopt\n\t */\n\tItemList option_argv = {NULL, NULL};\n\n\toptions_len = strlen(string) + 1;\n\toptions_string = pg_malloc0(options_len);\n\toptions_string_ptr = options_string;\n\n\t/* Copy the string before operating on it with strtok() */\n\tstrncpy(options_string, string, options_len);\n\n\t/* Extract arguments into a list and keep a count of the total */\n\twhile ((argv_item = strtok(options_string_ptr, \" \")) != NULL)\n\t{\n\t\titem_list_append(&option_argv, trim(argv_item));\n\n\t\targc_item++;\n\n\t\tif (options_string_ptr != NULL)\n\t\t\toptions_string_ptr = NULL;\n\t}\n\n\tpfree(options_string);\n\n\t/*\n\t * Array of argument values to pass to getopt_long - this will need to\n\t * include an empty string as the first value (normally this would be the\n\t * program name)\n\t */\n\tlocal_argv_array = pg_malloc0(sizeof(char *) * (argc_item + 2));\n\n\t/* Insert a blank dummy program name at the start of the array */\n\tlocal_argv_array[0] = pg_malloc0(1);\n\n\t/*\n\t * Copy the previously extracted arguments from our list to the array\n\t */\n\tfor (cell = option_argv.head; cell; cell = cell->next)\n\t{\n\t\tint\t\t\targv_len = strlen(cell->string) + 1;\n\n\t\tlocal_argv_array[c] = (char *)pg_malloc0(argv_len);\n\n\t\tstrncpy(local_argv_array[c], cell->string, argv_len);\n\n\t\tc++;\n\t}\n\n\tlocal_argv_array[c] = NULL;\n\n\titem_list_free(&option_argv);\n\n\t*argv_array = local_argv_array;\n\n\treturn argc_item;\n}\n\n\nvoid\nfree_parsed_argv(char ***argv_array)\n{\n\tchar\t  **local_argv_array = *argv_array;\n\tint\t\t\ti = 0;\n\n\twhile (local_argv_array[i] != NULL)\n\t{\n\t\tpfree((char *)local_argv_array[i]);\n\t\ti++;\n\t}\n\n\tpfree((char **)local_argv_array);\n\t*argv_array = NULL;\n}\n\n\nbool\nparse_pg_basebackup_options(const char *pg_basebackup_options, t_basebackup_options *backup_options, int server_version_num, ItemList *error_list)\n{\n\tbool\t\tbackup_options_ok = true;\n\tint\t\t\tc = 0,\n\t\t\t\targc_item = 0;\n\tchar\t  **argv_array = NULL;\n\tint\t\t\toptindex = 0;\n\tstruct option *long_options = NULL;\n\n\t/*\n\t * We're only interested in these options.\n\t */\n\n\tstatic struct option long_options_10[] =\n\t{\n\t\t{\"slot\", required_argument, NULL, 'S'},\n\t\t{\"wal-method\", required_argument, NULL, 'X'},\n\t\t{\"waldir\", required_argument, NULL, 1},\n\t\t{\"no-slot\", no_argument, NULL, 2},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\n\t/*\n\t * Pre-PostgreSQL 10 options\n\t */\n\tstatic struct option long_options_legacy[] =\n\t{\n\t\t{\"slot\", required_argument, NULL, 'S'},\n\t\t{\"xlog-method\", required_argument, NULL, 'X'},\n\t\t{\"xlogdir\", required_argument, NULL, 1},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\n\n\t/* Don't attempt to tokenise an empty string */\n\tif (!strlen(pg_basebackup_options))\n\t\treturn backup_options_ok;\n\n\tif (server_version_num >= 100000)\n\t\tlong_options = long_options_10;\n\telse\n\t\tlong_options = long_options_legacy;\n\n\targc_item = parse_output_to_argv(pg_basebackup_options, &argv_array);\n\n\t/* Reset getopt's optind variable */\n\toptind = 0;\n\n\t/* Prevent getopt from emitting errors */\n\topterr = 0;\n\n\twhile ((c = getopt_long(argc_item, argv_array, \"S:X:\", long_options,\n\t\t\t\t\t\t\t&optindex)) != -1)\n\t{\n\t\tswitch (c)\n\t\t{\n\t\t\tcase 'S':\n\t\t\t\tstrncpy(backup_options->slot, optarg, MAXLEN);\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tstrncpy(backup_options->wal_method, optarg, MAXLEN);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tstrncpy(backup_options->waldir, optarg, MAXPGPATH);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbackup_options->no_slot = true;\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\t\tif (server_version_num >= 100000 && optopt == 2)\n\t\t\t\t{\n\t\t\t\t\tif (error_list != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\titem_list_append(error_list, \"invalid use of --no-slot\");\n\t\t\t\t\t}\n\t\t\t\t\tbackup_options_ok = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (backup_options->no_slot == true && backup_options->slot[0] != '\\0')\n\t{\n\t\tif (error_list != NULL)\n\t\t{\n\t\t\titem_list_append(error_list, \"--no-slot cannot be used with -S/--slot\");\n\t\t}\n\t\tbackup_options_ok = false;\n\t}\n\n\t/*\n\t * If --waldir/--xlogdir provided, check it's an absolute path.\n\t */\n\tif (backup_options->waldir[0] != '\\0')\n\t{\n\t\tcanonicalize_path(backup_options->waldir);\n\t\tif (!is_absolute_path(backup_options->waldir))\n\t\t{\n\t\t\tif (error_list != NULL)\n\t\t\t{\n\t\t\t\titem_list_append_format(error_list,\n\t\t\t\t\t\t\t\t\t\t\"--%s must be provided with an absolute path\",\n\t\t\t\t\t\t\t\t\t\tserver_version_num >= 100000 ? \"waldir\" : \"xlogdir\");\n\t\t\t}\n\t\t\tbackup_options_ok = false;\n\t\t}\n\t}\n\n\tfree_parsed_argv(&argv_array);\n\n\treturn backup_options_ok;\n}\n\n\nconst char *\nprint_replication_type(ReplicationType type)\n{\n\tswitch (type)\n\t{\n\t\tcase REPLICATION_TYPE_PHYSICAL:\n\t\t\treturn \"physical\";\n\t}\n\n\t/* should never reach here */\n\treturn \"UNKNOWN\";\n}\n\n\nconst char *\nprint_connection_check_type(ConnectionCheckType type)\n{\n\tswitch (type)\n\t{\n\t\tcase CHECK_PING:\n\t\t\treturn \"ping\";\n\t\tcase CHECK_QUERY:\n\t\t\treturn \"query\";\n\t\tcase CHECK_CONNECTION:\n\t\t\treturn \"connection\";\n\t}\n\n\t/* should never reach here */\n\treturn \"UNKNOWN\";\n}\n\n\n\nchar *\nprint_event_notification_list(EventNotificationList *list)\n{\n\tPQExpBufferData buf;\n\tchar *ptr;\n\tEventNotificationListCell *cell;\n\tint ptr_len;\n\n\tinitPQExpBuffer(&buf);\n\tcell = list->head;\n\n\twhile (cell != NULL)\n\t{\n\t\tappendPQExpBufferStr(&buf, cell->event_type);\n\n\t\tif (cell->next)\n\t\t\tappendPQExpBufferChar(&buf, ',');\n\n\t\tcell = cell->next;\n\t}\n\n\tptr_len = strlen(buf.data);\n\tptr = palloc0(ptr_len + 1);\n\n\tstrncpy(ptr, buf.data, ptr_len);\n\n\ttermPQExpBuffer(&buf);\n\n\treturn ptr;\n}\n\n\nchar *\nprint_tablespace_mapping(TablespaceList *tablespace_mapping)\n{\n\tTablespaceListCell *cell;\n\tbool first = true;\n\tPQExpBufferData buf;\n\tchar *ptr;\n\n\tinitPQExpBuffer(&buf);\n\n\tfor (cell = tablespace_mapping->head; cell; cell = cell->next)\n\t{\n\t\tif (first == true)\n\t\t\tfirst = false;\n\t\telse\n\t\t\tappendPQExpBufferChar(&buf, ',');\n\n\t\tappendPQExpBuffer(&buf, \"%s=%s\",\n\t\t\t\t\t\t  cell->old_dir, cell->new_dir);\n\t}\n\n\tptr = palloc0(strlen(buf.data) + 1);\n\tstrncpy(ptr, buf.data, strlen(buf.data));\n\n\ttermPQExpBuffer(&buf);\n\n\treturn ptr;\n}\n\n\nconst char *\nformat_failover_mode(failover_mode_opt failover)\n{\n\tswitch (failover)\n\t{\n\t\tcase FAILOVER_MANUAL:\n\t\t\treturn \"manual\";\n\t\tcase FAILOVER_AUTOMATIC:\n\t\t\treturn \"automatic\";\n\t\tdefault:\n\t\t\treturn \"unknown failover mode\";\n\t}\n}\n"
        },
        {
          "name": "configfile.h",
          "type": "blob",
          "size": 10.3095703125,
          "content": "/*\n * configfile.h\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _REPMGR_CONFIGFILE_H_\n#define _REPMGR_CONFIGFILE_H_\n\n#include <getopt_long.h>\n\n#define CONFIG_FILE_NAME\t\"repmgr.conf\"\n#define MAXLINELENGTH\t\t4096\n/* magic number for use in t_recovery_conf */\n#define TARGET_TIMELINE_LATEST 0\n\n/*\n * This is defined in src/include/utils.h, however it's not practical\n * to include that from a frontend application.\n */\n#define PG_AUTOCONF_FILENAME \"postgresql.auto.conf\"\n\nextern bool config_file_found;\nextern char config_file_path[MAXPGPATH];\n\ntypedef enum\n{\n\tFAILOVER_MANUAL,\n\tFAILOVER_AUTOMATIC\n} failover_mode_opt;\n\ntypedef enum\n{\n\tCHECK_PING,\n\tCHECK_QUERY,\n\tCHECK_CONNECTION\n} ConnectionCheckType;\n\ntypedef enum\n{\n\tREPLICATION_TYPE_PHYSICAL\n} ReplicationType;\n\ntypedef struct EventNotificationListCell\n{\n\tstruct EventNotificationListCell *next;\n\tchar\t\tevent_type[MAXLEN];\n} EventNotificationListCell;\n\ntypedef struct EventNotificationList\n{\n\tEventNotificationListCell *head;\n\tEventNotificationListCell *tail;\n} EventNotificationList;\n\n\n\ntypedef struct TablespaceListCell\n{\n\tstruct TablespaceListCell *next;\n\tchar\t\told_dir[MAXPGPATH];\n\tchar\t\tnew_dir[MAXPGPATH];\n} TablespaceListCell;\n\ntypedef struct TablespaceList\n{\n\tTablespaceListCell *head;\n\tTablespaceListCell *tail;\n} TablespaceList;\n\n\ntypedef enum\n{\n\tCONFIG_BOOL,\n\tCONFIG_INT,\n\tCONFIG_STRING,\n\tCONFIG_FAILOVER_MODE,\n\tCONFIG_CONNECTION_CHECK_TYPE,\n\tCONFIG_EVENT_NOTIFICATION_LIST,\n\tCONFIG_TABLESPACE_MAPPING,\n    CONFIG_REPLICATION_TYPE\n} ConfigItemType;\n\n\ntypedef struct ConfigFileSetting\n{\n\tconst char\t   *name;\n\tConfigItemType  type;\n    union\n    {\n        int\t\t   *intptr;\n        char\t   *strptr;\n\t\tbool\t   *boolptr;\n\t\tfailover_mode_opt *failovermodeptr;\n\t\tConnectionCheckType *checktypeptr;\n\t\tEventNotificationList *notificationlistptr;\n\t\tTablespaceList *tablespacemappingptr;\n\t\tReplicationType *replicationtypeptr;\n\t} val;\n\tunion {\n\t\tint\t\t\tintdefault;\n\t\tconst char *strdefault;\n\t\tbool\t\tbooldefault;\n\t\tfailover_mode_opt failovermodedefault;\n\t\tConnectionCheckType checktypedefault;\n\t\tReplicationType replicationtypedefault;\n\t} defval;\n\tunion {\n\t\tint\t\t\t\tintminval;\n\t} minval;\n\tunion {\n\t\tint\t\t\t\tstrmaxlen;\n\t} maxval;\n\tstruct {\n\t\tvoid (*process_func)(const char *, const char *, char *, ItemList *errors);\n\t\tvoid (*postprocess_func)(const char *, const char *, char *, ItemList *errors);\n\t\tbool\t   *providedptr;\n\t} process;\n} ConfigFileSetting;\n\n/* Declare the main configfile structure for client applications */\nextern ConfigFileSetting config_file_settings[];\n\ntypedef struct\n{\n\t/* node information */\n\tint\t\t\tnode_id;\n\tchar\t\tnode_name[NAMEDATALEN];\n\tchar\t\tconninfo[MAXLEN];\n\tchar\t\treplication_user[NAMEDATALEN];\n\tchar\t\tdata_directory[MAXPGPATH];\n\tchar\t\tconfig_directory[MAXPGPATH];\n\tchar\t\tpg_bindir[MAXPGPATH];\n\tchar\t\trepmgr_bindir[MAXPGPATH];\n\tReplicationType\treplication_type;\n\n\t/* log settings */\n\tchar\t\tlog_level[MAXLEN];\n\tchar\t\tlog_facility[MAXLEN];\n\tchar\t\tlog_file[MAXPGPATH];\n\tint\t\t\tlog_status_interval;\n\n\t/* standby clone settings */\n\tbool\t\tuse_replication_slots;\n\tchar\t\tpg_basebackup_options[MAXLEN];\n\tchar\t\trestore_command[MAXLEN];\n\tTablespaceList tablespace_mapping;\n\tchar\t\trecovery_min_apply_delay[MAXLEN];\n\tbool\t\trecovery_min_apply_delay_provided;\n\tchar\t\tarchive_cleanup_command[MAXLEN];\n\tbool\t\tuse_primary_conninfo_password;\n\tchar\t\tpassfile[MAXPGPATH];\n\tchar\t\tpg_backupapi_backup_id[NAMEDATALEN];\n\tchar\t\tpg_backupapi_host[NAMEDATALEN];\n\tchar\t\tpg_backupapi_node_name[NAMEDATALEN];\n\tchar\t\tpg_backupapi_remote_ssh_command[MAXLEN];\n\n\t/* standby promote settings */\n\tint\t\t\tpromote_check_timeout;\n\tint\t\t\tpromote_check_interval;\n\n\t/* standby follow settings */\n\tint\t\t\tprimary_follow_timeout;\n\tint\t\t\tstandby_follow_timeout;\n\tbool\t\tstandby_follow_restart;\n\n\t/* standby switchover settings */\n\tint\t\t\tshutdown_check_timeout;\n\tint\t\t\tstandby_reconnect_timeout;\n\tint\t\t\twal_receive_check_timeout;\n\n\t/* node rejoin settings */\n\tint\t\t\tnode_rejoin_timeout;\n\n\t/* node check settings */\n\tint\t\t\tarchive_ready_warning;\n\tint\t\t\tarchive_ready_critical;\n\tint\t\t\treplication_lag_warning;\n\tint\t\t\treplication_lag_critical;\n\n\t/* witness settings */\n\tint\t\t\twitness_sync_interval;\n\n\t/* repmgrd settings */\n\tfailover_mode_opt failover;\n\tchar\t\tlocation[MAXLEN];\n\tint\t\t\tpriority;\n\tchar\t\tpromote_command[MAXLEN];\n\tchar\t\tfollow_command[MAXLEN];\n\tint\t\t\tmonitor_interval_secs;\n\tint\t\t\treconnect_attempts;\n\tint\t\t\treconnect_interval;\n\tbool\t\tmonitoring_history;\n\tint\t\t\tdegraded_monitoring_timeout;\n\tint\t\t\tasync_query_timeout;\n\tint\t\t\tprimary_notification_timeout;\n\tint\t\t\trepmgrd_standby_startup_timeout;\n\tchar\t\trepmgrd_pid_file[MAXPGPATH];\n\tbool\t\trepmgrd_exit_on_inactive_node;\n\tbool\t\tstandby_disconnect_on_failover;\n\tint\t\t\tsibling_nodes_disconnect_timeout;\n\tConnectionCheckType connection_check_type;\n\tbool\t\tprimary_visibility_consensus;\n\tbool\t\talways_promote;\n\tchar\t\tfailover_validation_command[MAXPGPATH];\n\tint\t\t\telection_rerun_interval;\n\tint\t\t\tchild_nodes_check_interval;\n\tint\t\t\tchild_nodes_disconnect_min_count;\n\tint\t\t\tchild_nodes_connected_min_count;\n\tbool\t\tchild_nodes_connected_include_witness;\n\tint\t\t\tchild_nodes_disconnect_timeout;\n\tchar\t\tchild_nodes_disconnect_command[MAXPGPATH];\n\n\t/* service settings */\n\tchar\t\tpg_ctl_options[MAXLEN];\n\tchar\t\tservice_start_command[MAXPGPATH];\n\tchar\t\tservice_stop_command[MAXPGPATH];\n\tchar\t\tservice_restart_command[MAXPGPATH];\n\tchar\t\tservice_reload_command[MAXPGPATH];\n\tchar\t\tservice_promote_command[MAXPGPATH];\n\n\t/* repmgrd service settings */\n\tchar\t\trepmgrd_service_start_command[MAXPGPATH];\n\tchar\t\trepmgrd_service_stop_command[MAXPGPATH];\n\n\t/* event notification settings */\n\tchar\t\tevent_notification_command[MAXPGPATH];\n\tchar\t\tevent_notifications_orig[MAXLEN];\n\tEventNotificationList event_notifications;\n\n\t/* barman settings */\n\tchar\t\tbarman_host[MAXLEN];\n\tchar\t\tbarman_server[MAXLEN];\n\tchar\t\tbarman_config[MAXLEN];\n\n\t/* rsync/ssh settings */\n\tchar\t\trsync_options[MAXLEN];\n\tchar\t\tssh_options[MAXLEN];\n\n\t/*\n\t * undocumented settings\n\t *\n\t * These settings are for testing or experimental features\n\t * and may be changed without notice.\n\t */\n\n\t/* experimental settings */\n\tbool\t\treconnect_loop_sync;\n\n\t/* test settings */\n\tint\t\t\tpromote_delay;\n\tint\t\t\tfailover_delay;\n\tchar\t\tconnection_check_query[MAXLEN];\n} t_configuration_options;\n\n\n/* Declare the main configfile structure for client applications */\nextern t_configuration_options config_file_options;\n\ntypedef struct\n{\n\tchar\t\tslot[MAXLEN];\n\tchar\t\twal_method[MAXLEN];\n\tchar\t\twaldir[MAXPGPATH];\n\tbool\t\tno_slot;\t\t/* from PostgreSQL 10 */\n} t_basebackup_options;\n\n#define T_BASEBACKUP_OPTIONS_INITIALIZER { \"\", \"\", \"\", false }\n\n\ntypedef enum\n{\n\tRTA_PAUSE,\n\tRTA_PROMOTE,\n\tRTA_SHUTDOWN\n} RecoveryTargetAction;\n\n/*\n * Struct to hold the contents of a parsed recovery.conf file.\n * We're only really interested in those related to streaming\n * replication (and also \"restore_command\") but include the\n * others for completeness.\n *\n * NOTE: \"recovery_target\" not included as it can only have\n * one value, \"immediate\".\n */\ntypedef struct\n{\n\t/* archive recovery settings */\n\tchar\t\trestore_command[MAXLEN];\n\tchar\t\tarchive_cleanup_command[MAXLEN];\n\tchar\t\trecovery_end_command[MAXLEN];\n\t/* recovery target settings */\n\tchar\t\trecovery_target_name[MAXLEN];\n\tchar\t\trecovery_target_time[MAXLEN];\n\tchar\t\trecovery_target_xid[MAXLEN];\n\tbool\t\trecovery_target_inclusive;\n\tint\t\t\trecovery_target_timeline;\n\tRecoveryTargetAction recovery_target_action;\t/* default: RTA_PAUSE */\n\t/* standby server settings */\n\tbool\t\tstandby_mode;\n\tchar\t\tprimary_conninfo[MAXLEN];\n\tchar\t\tprimary_slot_name[MAXLEN];\n\tchar\t\ttrigger_file[MAXLEN];\n\tchar\t\trecovery_min_apply_delay[MAXLEN];\n} t_recovery_conf;\n\n#define T_RECOVERY_CONF_INITIALIZER { \\\n\t/* archive recovery settings */ \\\n\t\"\", \"\", \"\", \\\n\t/* recovery target settings */ \\\n\t\"\", \"\", \"\", true, \\\n\tTARGET_TIMELINE_LATEST, \\\n\tRTA_PAUSE, \\\n\t/* standby server settings */ \\\n\ttrue, \\\n\t\"\", \"\", \"\", \"\" \\\n}\n\n#include \"dbutils.h\"\n\nvoid\t\tset_progname(const char *argv0);\nconst char *progname(void);\n\nvoid\t\tload_config(const char *config_file, bool verbose, bool terse, char *argv0);\nbool\t\treload_config(t_server_type server_type);\nvoid\t\tdump_config(void);\n\nvoid\t\tparse_configuration_item(ItemList *error_list, ItemList *warning_list, const char *name, const char *value);\n\nbool\t\tparse_recovery_conf(const char *data_dir, t_recovery_conf *conf);\n\nbool\t\tparse_bool(const char *s,\n\t\t\t\t\t   const char *config_item,\n\t\t\t\t\t   ItemList *error_list);\n\nint repmgr_atoi(const char *s,\n\t\t\tconst char *config_item,\n\t\t\tItemList *error_list,\n\t\t\tint minval);\n\nvoid parse_time_unit_parameter(const char *name, const char *value, char *dest, ItemList *errors);\nvoid repmgr_canonicalize_path(const char *name, const char *value, char *config_item, ItemList *errors);\n\nbool parse_pg_basebackup_options(const char *pg_basebackup_options,\n\t\t\t\t\t\t\tt_basebackup_options *backup_options,\n\t\t\t\t\t\t\tint server_version_num,\n\t\t\t\t\t\t\tItemList *error_list);\n\nint parse_output_to_argv(const char *string, char ***argv_array);\nvoid free_parsed_argv(char ***argv_array);\nconst char *format_failover_mode(failover_mode_opt failover);\n\n/* called by repmgr-client and repmgrd */\nvoid\t\texit_with_cli_errors(ItemList *error_list, const char *repmgr_command);\n\nvoid\t\tprint_item_list(ItemList *item_list);\nconst char *print_replication_type(ReplicationType type);\nconst char *print_connection_check_type(ConnectionCheckType type);\nchar \t   *print_event_notification_list(EventNotificationList *list);\nchar \t   *print_tablespace_mapping(TablespaceList *tablespacemappingptr);\n\nextern bool modify_auto_conf(const char *data_dir, KeyValueList *items);\n\nextern bool ProcessRepmgrConfigFile(const char *config_file, const char *base_dir, ItemList *error_list, ItemList *warning_list);\n\nextern bool ProcessPostgresConfigFile(const char *config_file, const char *base_dir, bool strict, KeyValueList *contents, ItemList *error_list, ItemList *warning_list);\n\n#endif\t\t\t\t\t\t\t/* _REPMGR_CONFIGFILE_H_ */\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 93.9677734375,
          "content": "#! /bin/sh\n# Guess values for system-dependent variables and create Makefiles.\n# Generated by GNU Autoconf 2.69 for repmgr 5.4.0.\n#\n# Report bugs to <repmgr@googlegroups.com>.\n#\n#\n# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.\n#\n#\n# This configure script is free software; the Free Software Foundation\n# gives unlimited permission to copy, distribute and modify it.\n#\n# Copyright (c) 2010-2021, EnterpriseDB Corporation\n## -------------------- ##\n## M4sh Initialization. ##\n## -------------------- ##\n\n# Be more Bourne compatible\nDUALCASE=1; export DUALCASE # for MKS sh\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in #(\n  *posix*) :\n    set -o posix ;; #(\n  *) :\n     ;;\nesac\nfi\n\n\nas_nl='\n'\nexport as_nl\n# Printing a long string crashes Solaris 7 /usr/bin/printf.\nas_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\nas_echo=$as_echo$as_echo$as_echo$as_echo$as_echo\nas_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo\n# Prefer a ksh shell builtin over an external printf program on Solaris,\n# but without wasting forks for bash or zsh.\nif test -z \"$BASH_VERSION$ZSH_VERSION\" \\\n    && (test \"X`print -r -- $as_echo`\" = \"X$as_echo\") 2>/dev/null; then\n  as_echo='print -r --'\n  as_echo_n='print -rn --'\nelif (test \"X`printf %s $as_echo`\" = \"X$as_echo\") 2>/dev/null; then\n  as_echo='printf %s\\n'\n  as_echo_n='printf %s'\nelse\n  if test \"X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`\" = \"X-n $as_echo\"; then\n    as_echo_body='eval /usr/ucb/echo -n \"$1$as_nl\"'\n    as_echo_n='/usr/ucb/echo -n'\n  else\n    as_echo_body='eval expr \"X$1\" : \"X\\\\(.*\\\\)\"'\n    as_echo_n_body='eval\n      arg=$1;\n      case $arg in #(\n      *\"$as_nl\"*)\n\texpr \"X$arg\" : \"X\\\\(.*\\\\)$as_nl\";\n\targ=`expr \"X$arg\" : \".*$as_nl\\\\(.*\\\\)\"`;;\n      esac;\n      expr \"X$arg\" : \"X\\\\(.*\\\\)\" | tr -d \"$as_nl\"\n    '\n    export as_echo_n_body\n    as_echo_n='sh -c $as_echo_n_body as_echo'\n  fi\n  export as_echo_body\n  as_echo='sh -c $as_echo_body as_echo'\nfi\n\n# The user is always right.\nif test \"${PATH_SEPARATOR+set}\" != set; then\n  PATH_SEPARATOR=:\n  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {\n    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||\n      PATH_SEPARATOR=';'\n  }\nfi\n\n\n# IFS\n# We need space, tab and new line, in precisely that order.  Quoting is\n# there to prevent editors from complaining about space-tab.\n# (If _AS_PATH_WALK were called with IFS unset, it would disable word\n# splitting by setting IFS to empty value.)\nIFS=\" \"\"\t$as_nl\"\n\n# Find who we are.  Look in the path if we contain no directory separator.\nas_myself=\ncase $0 in #((\n  *[\\\\/]* ) as_myself=$0 ;;\n  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    test -r \"$as_dir/$0\" && as_myself=$as_dir/$0 && break\n  done\nIFS=$as_save_IFS\n\n     ;;\nesac\n# We did not find ourselves, most probably we were run as `sh COMMAND'\n# in which case we are not to be found in the path.\nif test \"x$as_myself\" = x; then\n  as_myself=$0\nfi\nif test ! -f \"$as_myself\"; then\n  $as_echo \"$as_myself: error: cannot find myself; rerun with an absolute file name\" >&2\n  exit 1\nfi\n\n# Unset variables that we do not need and which cause bugs (e.g. in\n# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the \"|| exit 1\"\n# suppresses any \"Segmentation fault\" message there.  '((' could\n# trigger a bug in pdksh 5.2.14.\nfor as_var in BASH_ENV ENV MAIL MAILPATH\ndo eval test x\\${$as_var+set} = xset \\\n  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :\ndone\nPS1='$ '\nPS2='> '\nPS4='+ '\n\n# NLS nuisances.\nLC_ALL=C\nexport LC_ALL\nLANGUAGE=C\nexport LANGUAGE\n\n# CDPATH.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\n# Use a proper internal environment variable to ensure we don't fall\n  # into an infinite loop, continuously re-executing ourselves.\n  if test x\"${_as_can_reexec}\" != xno && test \"x$CONFIG_SHELL\" != x; then\n    _as_can_reexec=no; export _as_can_reexec;\n    # We cannot yet assume a decent shell, so we have to provide a\n# neutralization value for shells without unset; and this also\n# works around shells that cannot unset nonexistent variables.\n# Preserve -v and -x to the replacement shell.\nBASH_ENV=/dev/null\nENV=/dev/null\n(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV\ncase $- in # ((((\n  *v*x* | *x*v* ) as_opts=-vx ;;\n  *v* ) as_opts=-v ;;\n  *x* ) as_opts=-x ;;\n  * ) as_opts= ;;\nesac\nexec $CONFIG_SHELL $as_opts \"$as_myself\" ${1+\"$@\"}\n# Admittedly, this is quite paranoid, since all the known shells bail\n# out after a failed `exec'.\n$as_echo \"$0: could not re-execute with $CONFIG_SHELL\" >&2\nas_fn_exit 255\n  fi\n  # We don't want this to propagate to other subprocesses.\n          { _as_can_reexec=; unset _as_can_reexec;}\nif test \"x$CONFIG_SHELL\" = x; then\n  as_bourne_compatible=\"if test -n \\\"\\${ZSH_VERSION+set}\\\" && (emulate sh) >/dev/null 2>&1; then :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse\n  case \\`(set -o) 2>/dev/null\\` in #(\n  *posix*) :\n    set -o posix ;; #(\n  *) :\n     ;;\nesac\nfi\n\"\n  as_required=\"as_fn_return () { (exit \\$1); }\nas_fn_success () { as_fn_return 0; }\nas_fn_failure () { as_fn_return 1; }\nas_fn_ret_success () { return 0; }\nas_fn_ret_failure () { return 1; }\n\nexitcode=0\nas_fn_success || { exitcode=1; echo as_fn_success failed.; }\nas_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }\nas_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }\nas_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }\nif ( set x; as_fn_ret_success y && test x = \\\"\\$1\\\" ); then :\n\nelse\n  exitcode=1; echo positional parameters were not saved.\nfi\ntest x\\$exitcode = x0 || exit 1\ntest -x / || exit 1\"\n  as_suggested=\"  as_lineno_1=\";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested\" as_lineno_1a=\\$LINENO\n  as_lineno_2=\";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested\" as_lineno_2a=\\$LINENO\n  eval 'test \\\"x\\$as_lineno_1'\\$as_run'\\\" != \\\"x\\$as_lineno_2'\\$as_run'\\\" &&\n  test \\\"x\\`expr \\$as_lineno_1'\\$as_run' + 1\\`\\\" = \\\"x\\$as_lineno_2'\\$as_run'\\\"' || exit 1\ntest \\$(( 1 + 1 )) = 2 || exit 1\"\n  if (eval \"$as_required\") 2>/dev/null; then :\n  as_have_required=yes\nelse\n  as_have_required=no\nfi\n  if test x$as_have_required = xyes && (eval \"$as_suggested\") 2>/dev/null; then :\n\nelse\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nas_found=false\nfor as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n  as_found=:\n  case $as_dir in #(\n\t /*)\n\t   for as_base in sh bash ksh sh5; do\n\t     # Try only shells that exist, to save several forks.\n\t     as_shell=$as_dir/$as_base\n\t     if { test -f \"$as_shell\" || test -f \"$as_shell.exe\"; } &&\n\t\t    { $as_echo \"$as_bourne_compatible\"\"$as_required\" | as_run=a \"$as_shell\"; } 2>/dev/null; then :\n  CONFIG_SHELL=$as_shell as_have_required=yes\n\t\t   if { $as_echo \"$as_bourne_compatible\"\"$as_suggested\" | as_run=a \"$as_shell\"; } 2>/dev/null; then :\n  break 2\nfi\nfi\n\t   done;;\n       esac\n  as_found=false\ndone\n$as_found || { if { test -f \"$SHELL\" || test -f \"$SHELL.exe\"; } &&\n\t      { $as_echo \"$as_bourne_compatible\"\"$as_required\" | as_run=a \"$SHELL\"; } 2>/dev/null; then :\n  CONFIG_SHELL=$SHELL as_have_required=yes\nfi; }\nIFS=$as_save_IFS\n\n\n      if test \"x$CONFIG_SHELL\" != x; then :\n  export CONFIG_SHELL\n             # We cannot yet assume a decent shell, so we have to provide a\n# neutralization value for shells without unset; and this also\n# works around shells that cannot unset nonexistent variables.\n# Preserve -v and -x to the replacement shell.\nBASH_ENV=/dev/null\nENV=/dev/null\n(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV\ncase $- in # ((((\n  *v*x* | *x*v* ) as_opts=-vx ;;\n  *v* ) as_opts=-v ;;\n  *x* ) as_opts=-x ;;\n  * ) as_opts= ;;\nesac\nexec $CONFIG_SHELL $as_opts \"$as_myself\" ${1+\"$@\"}\n# Admittedly, this is quite paranoid, since all the known shells bail\n# out after a failed `exec'.\n$as_echo \"$0: could not re-execute with $CONFIG_SHELL\" >&2\nexit 255\nfi\n\n    if test x$as_have_required = xno; then :\n  $as_echo \"$0: This script requires a shell more modern than all\"\n  $as_echo \"$0: the shells that I found on your system.\"\n  if test x${ZSH_VERSION+set} = xset ; then\n    $as_echo \"$0: In particular, zsh $ZSH_VERSION has bugs and should\"\n    $as_echo \"$0: be upgraded to zsh 4.3.4 or later.\"\n  else\n    $as_echo \"$0: Please tell bug-autoconf@gnu.org and\n$0: repmgr@googlegroups.com about your system, including\n$0: any error possibly output before this message. Then\n$0: install a modern shell, or manually run the script\n$0: under such a shell if you do have one.\"\n  fi\n  exit 1\nfi\nfi\nfi\nSHELL=${CONFIG_SHELL-/bin/sh}\nexport SHELL\n# Unset more variables known to interfere with behavior of common tools.\nCLICOLOR_FORCE= GREP_OPTIONS=\nunset CLICOLOR_FORCE GREP_OPTIONS\n\n## --------------------- ##\n## M4sh Shell Functions. ##\n## --------------------- ##\n# as_fn_unset VAR\n# ---------------\n# Portably unset VAR.\nas_fn_unset ()\n{\n  { eval $1=; unset $1;}\n}\nas_unset=as_fn_unset\n\n# as_fn_set_status STATUS\n# -----------------------\n# Set $? to STATUS, without forking.\nas_fn_set_status ()\n{\n  return $1\n} # as_fn_set_status\n\n# as_fn_exit STATUS\n# -----------------\n# Exit the shell with STATUS, even in a \"trap 0\" or \"set -e\" context.\nas_fn_exit ()\n{\n  set +e\n  as_fn_set_status $1\n  exit $1\n} # as_fn_exit\n\n# as_fn_mkdir_p\n# -------------\n# Create \"$as_dir\" as a directory, including parents if necessary.\nas_fn_mkdir_p ()\n{\n\n  case $as_dir in #(\n  -*) as_dir=./$as_dir;;\n  esac\n  test -d \"$as_dir\" || eval $as_mkdir_p || {\n    as_dirs=\n    while :; do\n      case $as_dir in #(\n      *\\'*) as_qdir=`$as_echo \"$as_dir\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;; #'(\n      *) as_qdir=$as_dir;;\n      esac\n      as_dirs=\"'$as_qdir' $as_dirs\"\n      as_dir=`$as_dirname -- \"$as_dir\" ||\n$as_expr X\"$as_dir\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)$' \\| \\\n\t X\"$as_dir\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n$as_echo X\"$as_dir\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n      test -d \"$as_dir\" && break\n    done\n    test -z \"$as_dirs\" || eval \"mkdir $as_dirs\"\n  } || test -d \"$as_dir\" || as_fn_error $? \"cannot create directory $as_dir\"\n\n\n} # as_fn_mkdir_p\n\n# as_fn_executable_p FILE\n# -----------------------\n# Test if FILE is an executable regular file.\nas_fn_executable_p ()\n{\n  test -f \"$1\" && test -x \"$1\"\n} # as_fn_executable_p\n# as_fn_append VAR VALUE\n# ----------------------\n# Append the text in VALUE to the end of the definition contained in VAR. Take\n# advantage of any shell optimizations that allow amortized linear growth over\n# repeated appends, instead of the typical quadratic growth present in naive\n# implementations.\nif (eval \"as_var=1; as_var+=2; test x\\$as_var = x12\") 2>/dev/null; then :\n  eval 'as_fn_append ()\n  {\n    eval $1+=\\$2\n  }'\nelse\n  as_fn_append ()\n  {\n    eval $1=\\$$1\\$2\n  }\nfi # as_fn_append\n\n# as_fn_arith ARG...\n# ------------------\n# Perform arithmetic evaluation on the ARGs, and store the result in the\n# global $as_val. Take advantage of shells that can avoid forks. The arguments\n# must be portable across $(()) and expr.\nif (eval \"test \\$(( 1 + 1 )) = 2\") 2>/dev/null; then :\n  eval 'as_fn_arith ()\n  {\n    as_val=$(( $* ))\n  }'\nelse\n  as_fn_arith ()\n  {\n    as_val=`expr \"$@\" || test $? -eq 1`\n  }\nfi # as_fn_arith\n\n\n# as_fn_error STATUS ERROR [LINENO LOG_FD]\n# ----------------------------------------\n# Output \"`basename $0`: error: ERROR\" to stderr. If LINENO and LOG_FD are\n# provided, also output the error to LOG_FD, referencing LINENO. Then exit the\n# script with STATUS, using 1 if that was 0.\nas_fn_error ()\n{\n  as_status=$1; test $as_status -eq 0 && as_status=1\n  if test \"$4\"; then\n    as_lineno=${as_lineno-\"$3\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n    $as_echo \"$as_me:${as_lineno-$LINENO}: error: $2\" >&$4\n  fi\n  $as_echo \"$as_me: error: $2\" >&2\n  as_fn_exit $as_status\n} # as_fn_error\n\nif expr a : '\\(a\\)' >/dev/null 2>&1 &&\n   test \"X`expr 00001 : '.*\\(...\\)'`\" = X001; then\n  as_expr=expr\nelse\n  as_expr=false\nfi\n\nif (basename -- /) >/dev/null 2>&1 && test \"X`basename -- / 2>&1`\" = \"X/\"; then\n  as_basename=basename\nelse\n  as_basename=false\nfi\n\nif (as_dir=`dirname -- /` && test \"X$as_dir\" = X/) >/dev/null 2>&1; then\n  as_dirname=dirname\nelse\n  as_dirname=false\nfi\n\nas_me=`$as_basename -- \"$0\" ||\n$as_expr X/\"$0\" : '.*/\\([^/][^/]*\\)/*$' \\| \\\n\t X\"$0\" : 'X\\(//\\)$' \\| \\\n\t X\"$0\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n$as_echo X/\"$0\" |\n    sed '/^.*\\/\\([^/][^/]*\\)\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n\n# Avoid depending upon Character Ranges.\nas_cr_letters='abcdefghijklmnopqrstuvwxyz'\nas_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nas_cr_Letters=$as_cr_letters$as_cr_LETTERS\nas_cr_digits='0123456789'\nas_cr_alnum=$as_cr_Letters$as_cr_digits\n\n\n  as_lineno_1=$LINENO as_lineno_1a=$LINENO\n  as_lineno_2=$LINENO as_lineno_2a=$LINENO\n  eval 'test \"x$as_lineno_1'$as_run'\" != \"x$as_lineno_2'$as_run'\" &&\n  test \"x`expr $as_lineno_1'$as_run' + 1`\" = \"x$as_lineno_2'$as_run'\"' || {\n  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)\n  sed -n '\n    p\n    /[$]LINENO/=\n  ' <$as_myself |\n    sed '\n      s/[$]LINENO.*/&-/\n      t lineno\n      b\n      :lineno\n      N\n      :loop\n      s/[$]LINENO\\([^'$as_cr_alnum'_].*\\n\\)\\(.*\\)/\\2\\1\\2/\n      t loop\n      s/-\\n.*//\n    ' >$as_me.lineno &&\n  chmod +x \"$as_me.lineno\" ||\n    { $as_echo \"$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell\" >&2; as_fn_exit 1; }\n\n  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have\n  # already done that, so ensure we don't try to do so again and fall\n  # in an infinite loop.  This has already happened in practice.\n  _as_can_reexec=no; export _as_can_reexec\n  # Don't try to exec as it changes $[0], causing all sort of problems\n  # (the dirname of $[0] is not the place where we might find the\n  # original and so on.  Autoconf is especially sensitive to this).\n  . \"./$as_me.lineno\"\n  # Exit status is that of the last command.\n  exit\n}\n\nECHO_C= ECHO_N= ECHO_T=\ncase `echo -n x` in #(((((\n-n*)\n  case `echo 'xy\\c'` in\n  *c*) ECHO_T='\t';;\t# ECHO_T is single tab character.\n  xy)  ECHO_C='\\c';;\n  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null\n       ECHO_T='\t';;\n  esac;;\n*)\n  ECHO_N='-n';;\nesac\n\nrm -f conf$$ conf$$.exe conf$$.file\nif test -d conf$$.dir; then\n  rm -f conf$$.dir/conf$$.file\nelse\n  rm -f conf$$.dir\n  mkdir conf$$.dir 2>/dev/null\nfi\nif (echo >conf$$.file) 2>/dev/null; then\n  if ln -s conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s='ln -s'\n    # ... but there are two gotchas:\n    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.\n    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.\n    # In both cases, we have to default to `cp -pR'.\n    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||\n      as_ln_s='cp -pR'\n  elif ln conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s=ln\n  else\n    as_ln_s='cp -pR'\n  fi\nelse\n  as_ln_s='cp -pR'\nfi\nrm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file\nrmdir conf$$.dir 2>/dev/null\n\nif mkdir -p . 2>/dev/null; then\n  as_mkdir_p='mkdir -p \"$as_dir\"'\nelse\n  test -d ./-p && rmdir ./-p\n  as_mkdir_p=false\nfi\n\nas_test_x='test -x'\nas_executable_p=as_fn_executable_p\n\n# Sed expression to map a string onto a valid CPP name.\nas_tr_cpp=\"eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'\"\n\n# Sed expression to map a string onto a valid variable name.\nas_tr_sh=\"eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'\"\n\n\ntest -n \"$DJDIR\" || exec 7<&0 </dev/null\nexec 6>&1\n\n# Name of the host.\n# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,\n# so uname gets run too.\nac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`\n\n#\n# Initializations.\n#\nac_default_prefix=/usr/local\nac_clean_files=\nac_config_libobj_dir=.\nLIBOBJS=\ncross_compiling=no\nsubdirs=\nMFLAGS=\nMAKEFLAGS=\n\n# Identity of this package.\nPACKAGE_NAME='repmgr'\nPACKAGE_TARNAME='repmgr'\nPACKAGE_VERSION='5.4.0'\nPACKAGE_STRING='repmgr 5.4.0'\nPACKAGE_BUGREPORT='repmgr@googlegroups.com'\nPACKAGE_URL='https://repmgr.org/'\n\nac_subst_vars='LTLIBOBJS\nLIBOBJS\nHAVE_SED\nHAVE_GSED\nHAVE_GNUSED\nvpath_build\nSED\nPG_CONFIG\ntarget_alias\nhost_alias\nbuild_alias\nLIBS\nECHO_T\nECHO_N\nECHO_C\nDEFS\nmandir\nlocaledir\nlibdir\npsdir\npdfdir\ndvidir\nhtmldir\ninfodir\ndocdir\noldincludedir\nincludedir\nlocalstatedir\nsharedstatedir\nsysconfdir\ndatadir\ndatarootdir\nlibexecdir\nsbindir\nbindir\nprogram_transform_name\nprefix\nexec_prefix\nPACKAGE_URL\nPACKAGE_BUGREPORT\nPACKAGE_STRING\nPACKAGE_VERSION\nPACKAGE_TARNAME\nPACKAGE_NAME\nPATH_SEPARATOR\nSHELL'\nac_subst_files=''\nac_user_opts='\nenable_option_checking\n'\n      ac_precious_vars='build_alias\nhost_alias\ntarget_alias\nPG_CONFIG'\n\n\n# Initialize some variables set by options.\nac_init_help=\nac_init_version=false\nac_unrecognized_opts=\nac_unrecognized_sep=\n# The variables have the same names as the options, with\n# dashes changed to underlines.\ncache_file=/dev/null\nexec_prefix=NONE\nno_create=\nno_recursion=\nprefix=NONE\nprogram_prefix=NONE\nprogram_suffix=NONE\nprogram_transform_name=s,x,x,\nsilent=\nsite=\nsrcdir=\nverbose=\nx_includes=NONE\nx_libraries=NONE\n\n# Installation directory options.\n# These are left unexpanded so users can \"make install exec_prefix=/foo\"\n# and all the variables that are supposed to be based on exec_prefix\n# by default will actually change.\n# Use braces instead of parens because sh, perl, etc. also accept them.\n# (The list follows the same order as the GNU Coding Standards.)\nbindir='${exec_prefix}/bin'\nsbindir='${exec_prefix}/sbin'\nlibexecdir='${exec_prefix}/libexec'\ndatarootdir='${prefix}/share'\ndatadir='${datarootdir}'\nsysconfdir='${prefix}/etc'\nsharedstatedir='${prefix}/com'\nlocalstatedir='${prefix}/var'\nincludedir='${prefix}/include'\noldincludedir='/usr/include'\ndocdir='${datarootdir}/doc/${PACKAGE_TARNAME}'\ninfodir='${datarootdir}/info'\nhtmldir='${docdir}'\ndvidir='${docdir}'\npdfdir='${docdir}'\npsdir='${docdir}'\nlibdir='${exec_prefix}/lib'\nlocaledir='${datarootdir}/locale'\nmandir='${datarootdir}/man'\n\nac_prev=\nac_dashdash=\nfor ac_option\ndo\n  # If the previous option needs an argument, assign it.\n  if test -n \"$ac_prev\"; then\n    eval $ac_prev=\\$ac_option\n    ac_prev=\n    continue\n  fi\n\n  case $ac_option in\n  *=?*) ac_optarg=`expr \"X$ac_option\" : '[^=]*=\\(.*\\)'` ;;\n  *=)   ac_optarg= ;;\n  *)    ac_optarg=yes ;;\n  esac\n\n  # Accept the important Cygnus configure options, so we can diagnose typos.\n\n  case $ac_dashdash$ac_option in\n  --)\n    ac_dashdash=yes ;;\n\n  -bindir | --bindir | --bindi | --bind | --bin | --bi)\n    ac_prev=bindir ;;\n  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)\n    bindir=$ac_optarg ;;\n\n  -build | --build | --buil | --bui | --bu)\n    ac_prev=build_alias ;;\n  -build=* | --build=* | --buil=* | --bui=* | --bu=*)\n    build_alias=$ac_optarg ;;\n\n  -cache-file | --cache-file | --cache-fil | --cache-fi \\\n  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)\n    ac_prev=cache_file ;;\n  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \\\n  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)\n    cache_file=$ac_optarg ;;\n\n  --config-cache | -C)\n    cache_file=config.cache ;;\n\n  -datadir | --datadir | --datadi | --datad)\n    ac_prev=datadir ;;\n  -datadir=* | --datadir=* | --datadi=* | --datad=*)\n    datadir=$ac_optarg ;;\n\n  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \\\n  | --dataroo | --dataro | --datar)\n    ac_prev=datarootdir ;;\n  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \\\n  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)\n    datarootdir=$ac_optarg ;;\n\n  -disable-* | --disable-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*disable-\\(.*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid feature name: $ac_useropt\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`$as_echo \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"enable_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval enable_$ac_useropt=no ;;\n\n  -docdir | --docdir | --docdi | --doc | --do)\n    ac_prev=docdir ;;\n  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)\n    docdir=$ac_optarg ;;\n\n  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)\n    ac_prev=dvidir ;;\n  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)\n    dvidir=$ac_optarg ;;\n\n  -enable-* | --enable-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*enable-\\([^=]*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid feature name: $ac_useropt\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`$as_echo \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"enable_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval enable_$ac_useropt=\\$ac_optarg ;;\n\n  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \\\n  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \\\n  | --exec | --exe | --ex)\n    ac_prev=exec_prefix ;;\n  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \\\n  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \\\n  | --exec=* | --exe=* | --ex=*)\n    exec_prefix=$ac_optarg ;;\n\n  -gas | --gas | --ga | --g)\n    # Obsolete; use --with-gas.\n    with_gas=yes ;;\n\n  -help | --help | --hel | --he | -h)\n    ac_init_help=long ;;\n  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)\n    ac_init_help=recursive ;;\n  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)\n    ac_init_help=short ;;\n\n  -host | --host | --hos | --ho)\n    ac_prev=host_alias ;;\n  -host=* | --host=* | --hos=* | --ho=*)\n    host_alias=$ac_optarg ;;\n\n  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)\n    ac_prev=htmldir ;;\n  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \\\n  | --ht=*)\n    htmldir=$ac_optarg ;;\n\n  -includedir | --includedir | --includedi | --included | --include \\\n  | --includ | --inclu | --incl | --inc)\n    ac_prev=includedir ;;\n  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \\\n  | --includ=* | --inclu=* | --incl=* | --inc=*)\n    includedir=$ac_optarg ;;\n\n  -infodir | --infodir | --infodi | --infod | --info | --inf)\n    ac_prev=infodir ;;\n  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)\n    infodir=$ac_optarg ;;\n\n  -libdir | --libdir | --libdi | --libd)\n    ac_prev=libdir ;;\n  -libdir=* | --libdir=* | --libdi=* | --libd=*)\n    libdir=$ac_optarg ;;\n\n  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \\\n  | --libexe | --libex | --libe)\n    ac_prev=libexecdir ;;\n  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \\\n  | --libexe=* | --libex=* | --libe=*)\n    libexecdir=$ac_optarg ;;\n\n  -localedir | --localedir | --localedi | --localed | --locale)\n    ac_prev=localedir ;;\n  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)\n    localedir=$ac_optarg ;;\n\n  -localstatedir | --localstatedir | --localstatedi | --localstated \\\n  | --localstate | --localstat | --localsta | --localst | --locals)\n    ac_prev=localstatedir ;;\n  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \\\n  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)\n    localstatedir=$ac_optarg ;;\n\n  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)\n    ac_prev=mandir ;;\n  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)\n    mandir=$ac_optarg ;;\n\n  -nfp | --nfp | --nf)\n    # Obsolete; use --without-fp.\n    with_fp=no ;;\n\n  -no-create | --no-create | --no-creat | --no-crea | --no-cre \\\n  | --no-cr | --no-c | -n)\n    no_create=yes ;;\n\n  -no-recursion | --no-recursion | --no-recursio | --no-recursi \\\n  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)\n    no_recursion=yes ;;\n\n  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \\\n  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \\\n  | --oldin | --oldi | --old | --ol | --o)\n    ac_prev=oldincludedir ;;\n  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \\\n  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \\\n  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)\n    oldincludedir=$ac_optarg ;;\n\n  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)\n    ac_prev=prefix ;;\n  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)\n    prefix=$ac_optarg ;;\n\n  -program-prefix | --program-prefix | --program-prefi | --program-pref \\\n  | --program-pre | --program-pr | --program-p)\n    ac_prev=program_prefix ;;\n  -program-prefix=* | --program-prefix=* | --program-prefi=* \\\n  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)\n    program_prefix=$ac_optarg ;;\n\n  -program-suffix | --program-suffix | --program-suffi | --program-suff \\\n  | --program-suf | --program-su | --program-s)\n    ac_prev=program_suffix ;;\n  -program-suffix=* | --program-suffix=* | --program-suffi=* \\\n  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)\n    program_suffix=$ac_optarg ;;\n\n  -program-transform-name | --program-transform-name \\\n  | --program-transform-nam | --program-transform-na \\\n  | --program-transform-n | --program-transform- \\\n  | --program-transform | --program-transfor \\\n  | --program-transfo | --program-transf \\\n  | --program-trans | --program-tran \\\n  | --progr-tra | --program-tr | --program-t)\n    ac_prev=program_transform_name ;;\n  -program-transform-name=* | --program-transform-name=* \\\n  | --program-transform-nam=* | --program-transform-na=* \\\n  | --program-transform-n=* | --program-transform-=* \\\n  | --program-transform=* | --program-transfor=* \\\n  | --program-transfo=* | --program-transf=* \\\n  | --program-trans=* | --program-tran=* \\\n  | --progr-tra=* | --program-tr=* | --program-t=*)\n    program_transform_name=$ac_optarg ;;\n\n  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)\n    ac_prev=pdfdir ;;\n  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)\n    pdfdir=$ac_optarg ;;\n\n  -psdir | --psdir | --psdi | --psd | --ps)\n    ac_prev=psdir ;;\n  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)\n    psdir=$ac_optarg ;;\n\n  -q | -quiet | --quiet | --quie | --qui | --qu | --q \\\n  | -silent | --silent | --silen | --sile | --sil)\n    silent=yes ;;\n\n  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)\n    ac_prev=sbindir ;;\n  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \\\n  | --sbi=* | --sb=*)\n    sbindir=$ac_optarg ;;\n\n  -sharedstatedir | --sharedstatedir | --sharedstatedi \\\n  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \\\n  | --sharedst | --shareds | --shared | --share | --shar \\\n  | --sha | --sh)\n    ac_prev=sharedstatedir ;;\n  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \\\n  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \\\n  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \\\n  | --sha=* | --sh=*)\n    sharedstatedir=$ac_optarg ;;\n\n  -site | --site | --sit)\n    ac_prev=site ;;\n  -site=* | --site=* | --sit=*)\n    site=$ac_optarg ;;\n\n  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)\n    ac_prev=srcdir ;;\n  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)\n    srcdir=$ac_optarg ;;\n\n  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \\\n  | --syscon | --sysco | --sysc | --sys | --sy)\n    ac_prev=sysconfdir ;;\n  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \\\n  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)\n    sysconfdir=$ac_optarg ;;\n\n  -target | --target | --targe | --targ | --tar | --ta | --t)\n    ac_prev=target_alias ;;\n  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)\n    target_alias=$ac_optarg ;;\n\n  -v | -verbose | --verbose | --verbos | --verbo | --verb)\n    verbose=yes ;;\n\n  -version | --version | --versio | --versi | --vers | -V)\n    ac_init_version=: ;;\n\n  -with-* | --with-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*with-\\([^=]*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid package name: $ac_useropt\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`$as_echo \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"with_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval with_$ac_useropt=\\$ac_optarg ;;\n\n  -without-* | --without-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*without-\\(.*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid package name: $ac_useropt\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`$as_echo \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"with_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval with_$ac_useropt=no ;;\n\n  --x)\n    # Obsolete; use --with-x.\n    with_x=yes ;;\n\n  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \\\n  | --x-incl | --x-inc | --x-in | --x-i)\n    ac_prev=x_includes ;;\n  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \\\n  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)\n    x_includes=$ac_optarg ;;\n\n  -x-libraries | --x-libraries | --x-librarie | --x-librari \\\n  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)\n    ac_prev=x_libraries ;;\n  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \\\n  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)\n    x_libraries=$ac_optarg ;;\n\n  -*) as_fn_error $? \"unrecognized option: \\`$ac_option'\nTry \\`$0 --help' for more information\"\n    ;;\n\n  *=*)\n    ac_envvar=`expr \"x$ac_option\" : 'x\\([^=]*\\)='`\n    # Reject names that are not valid shell variable names.\n    case $ac_envvar in #(\n      '' | [0-9]* | *[!_$as_cr_alnum]* )\n      as_fn_error $? \"invalid variable name: \\`$ac_envvar'\" ;;\n    esac\n    eval $ac_envvar=\\$ac_optarg\n    export $ac_envvar ;;\n\n  *)\n    # FIXME: should be removed in autoconf 3.0.\n    $as_echo \"$as_me: WARNING: you should use --build, --host, --target\" >&2\n    expr \"x$ac_option\" : \".*[^-._$as_cr_alnum]\" >/dev/null &&\n      $as_echo \"$as_me: WARNING: invalid host type: $ac_option\" >&2\n    : \"${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}\"\n    ;;\n\n  esac\ndone\n\nif test -n \"$ac_prev\"; then\n  ac_option=--`echo $ac_prev | sed 's/_/-/g'`\n  as_fn_error $? \"missing argument to $ac_option\"\nfi\n\nif test -n \"$ac_unrecognized_opts\"; then\n  case $enable_option_checking in\n    no) ;;\n    fatal) as_fn_error $? \"unrecognized options: $ac_unrecognized_opts\" ;;\n    *)     $as_echo \"$as_me: WARNING: unrecognized options: $ac_unrecognized_opts\" >&2 ;;\n  esac\nfi\n\n# Check all directory arguments for consistency.\nfor ac_var in\texec_prefix prefix bindir sbindir libexecdir datarootdir \\\n\t\tdatadir sysconfdir sharedstatedir localstatedir includedir \\\n\t\toldincludedir docdir infodir htmldir dvidir pdfdir psdir \\\n\t\tlibdir localedir mandir\ndo\n  eval ac_val=\\$$ac_var\n  # Remove trailing slashes.\n  case $ac_val in\n    */ )\n      ac_val=`expr \"X$ac_val\" : 'X\\(.*[^/]\\)' \\| \"X$ac_val\" : 'X\\(.*\\)'`\n      eval $ac_var=\\$ac_val;;\n  esac\n  # Be sure to have absolute directory names.\n  case $ac_val in\n    [\\\\/$]* | ?:[\\\\/]* )  continue;;\n    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;\n  esac\n  as_fn_error $? \"expected an absolute directory name for --$ac_var: $ac_val\"\ndone\n\n# There might be people who depend on the old broken behavior: `$host'\n# used to hold the argument of --host etc.\n# FIXME: To remove some day.\nbuild=$build_alias\nhost=$host_alias\ntarget=$target_alias\n\n# FIXME: To remove some day.\nif test \"x$host_alias\" != x; then\n  if test \"x$build_alias\" = x; then\n    cross_compiling=maybe\n  elif test \"x$build_alias\" != \"x$host_alias\"; then\n    cross_compiling=yes\n  fi\nfi\n\nac_tool_prefix=\ntest -n \"$host_alias\" && ac_tool_prefix=$host_alias-\n\ntest \"$silent\" = yes && exec 6>/dev/null\n\n\nac_pwd=`pwd` && test -n \"$ac_pwd\" &&\nac_ls_di=`ls -di .` &&\nac_pwd_ls_di=`cd \"$ac_pwd\" && ls -di .` ||\n  as_fn_error $? \"working directory cannot be determined\"\ntest \"X$ac_ls_di\" = \"X$ac_pwd_ls_di\" ||\n  as_fn_error $? \"pwd does not report name of working directory\"\n\n\n# Find the source files, if location was not specified.\nif test -z \"$srcdir\"; then\n  ac_srcdir_defaulted=yes\n  # Try the directory containing this script, then the parent directory.\n  ac_confdir=`$as_dirname -- \"$as_myself\" ||\n$as_expr X\"$as_myself\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$as_myself\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$as_myself\" : 'X\\(//\\)$' \\| \\\n\t X\"$as_myself\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n$as_echo X\"$as_myself\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n  srcdir=$ac_confdir\n  if test ! -r \"$srcdir/$ac_unique_file\"; then\n    srcdir=..\n  fi\nelse\n  ac_srcdir_defaulted=no\nfi\nif test ! -r \"$srcdir/$ac_unique_file\"; then\n  test \"$ac_srcdir_defaulted\" = yes && srcdir=\"$ac_confdir or ..\"\n  as_fn_error $? \"cannot find sources ($ac_unique_file) in $srcdir\"\nfi\nac_msg=\"sources are in $srcdir, but \\`cd $srcdir' does not work\"\nac_abs_confdir=`(\n\tcd \"$srcdir\" && test -r \"./$ac_unique_file\" || as_fn_error $? \"$ac_msg\"\n\tpwd)`\n# When building in place, set srcdir=.\nif test \"$ac_abs_confdir\" = \"$ac_pwd\"; then\n  srcdir=.\nfi\n# Remove unnecessary trailing slashes from srcdir.\n# Double slashes in file names in object file debugging info\n# mess up M-x gdb in Emacs.\ncase $srcdir in\n*/) srcdir=`expr \"X$srcdir\" : 'X\\(.*[^/]\\)' \\| \"X$srcdir\" : 'X\\(.*\\)'`;;\nesac\nfor ac_var in $ac_precious_vars; do\n  eval ac_env_${ac_var}_set=\\${${ac_var}+set}\n  eval ac_env_${ac_var}_value=\\$${ac_var}\n  eval ac_cv_env_${ac_var}_set=\\${${ac_var}+set}\n  eval ac_cv_env_${ac_var}_value=\\$${ac_var}\ndone\n\n#\n# Report the --help message.\n#\nif test \"$ac_init_help\" = \"long\"; then\n  # Omit some internal or obsolete options to make the list less imposing.\n  # This message is too long to be a string in the A/UX 3.1 sh.\n  cat <<_ACEOF\n\\`configure' configures repmgr 5.4.0 to adapt to many kinds of systems.\n\nUsage: $0 [OPTION]... [VAR=VALUE]...\n\nTo assign environment variables (e.g., CC, CFLAGS...), specify them as\nVAR=VALUE.  See below for descriptions of some of the useful variables.\n\nDefaults for the options are specified in brackets.\n\nConfiguration:\n  -h, --help              display this help and exit\n      --help=short        display options specific to this package\n      --help=recursive    display the short help of all the included packages\n  -V, --version           display version information and exit\n  -q, --quiet, --silent   do not print \\`checking ...' messages\n      --cache-file=FILE   cache test results in FILE [disabled]\n  -C, --config-cache      alias for \\`--cache-file=config.cache'\n  -n, --no-create         do not create output files\n      --srcdir=DIR        find the sources in DIR [configure dir or \\`..']\n\nInstallation directories:\n  --prefix=PREFIX         install architecture-independent files in PREFIX\n                          [$ac_default_prefix]\n  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX\n                          [PREFIX]\n\nBy default, \\`make install' will install all the files in\n\\`$ac_default_prefix/bin', \\`$ac_default_prefix/lib' etc.  You can specify\nan installation prefix other than \\`$ac_default_prefix' using \\`--prefix',\nfor instance \\`--prefix=\\$HOME'.\n\nFor better control, use the options below.\n\nFine tuning of the installation directories:\n  --bindir=DIR            user executables [EPREFIX/bin]\n  --sbindir=DIR           system admin executables [EPREFIX/sbin]\n  --libexecdir=DIR        program executables [EPREFIX/libexec]\n  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]\n  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]\n  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]\n  --libdir=DIR            object code libraries [EPREFIX/lib]\n  --includedir=DIR        C header files [PREFIX/include]\n  --oldincludedir=DIR     C header files for non-gcc [/usr/include]\n  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]\n  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]\n  --infodir=DIR           info documentation [DATAROOTDIR/info]\n  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]\n  --mandir=DIR            man documentation [DATAROOTDIR/man]\n  --docdir=DIR            documentation root [DATAROOTDIR/doc/repmgr]\n  --htmldir=DIR           html documentation [DOCDIR]\n  --dvidir=DIR            dvi documentation [DOCDIR]\n  --pdfdir=DIR            pdf documentation [DOCDIR]\n  --psdir=DIR             ps documentation [DOCDIR]\n_ACEOF\n\n  cat <<\\_ACEOF\n_ACEOF\nfi\n\nif test -n \"$ac_init_help\"; then\n  case $ac_init_help in\n     short | recursive ) echo \"Configuration of repmgr 5.4.0:\";;\n   esac\n  cat <<\\_ACEOF\n\nSome influential environment variables:\n  PG_CONFIG   Location to find pg_config for target PostgreSQL (default PATH)\n\nUse these variables to override the choices made by `configure' or to help\nit to find libraries and programs with nonstandard names/locations.\n\nReport bugs to <repmgr@googlegroups.com>.\nrepmgr home page: <https://repmgr.org/>.\n_ACEOF\nac_status=$?\nfi\n\nif test \"$ac_init_help\" = \"recursive\"; then\n  # If there are subdirs, report their specific --help.\n  for ac_dir in : $ac_subdirs_all; do test \"x$ac_dir\" = x: && continue\n    test -d \"$ac_dir\" ||\n      { cd \"$srcdir\" && ac_pwd=`pwd` && srcdir=. && test -d \"$ac_dir\"; } ||\n      continue\n    ac_builddir=.\n\ncase \"$ac_dir\" in\n.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;\n*)\n  ac_dir_suffix=/`$as_echo \"$ac_dir\" | sed 's|^\\.[\\\\/]||'`\n  # A \"..\" for each directory in $ac_dir_suffix.\n  ac_top_builddir_sub=`$as_echo \"$ac_dir_suffix\" | sed 's|/[^\\\\/]*|/..|g;s|/||'`\n  case $ac_top_builddir_sub in\n  \"\") ac_top_builddir_sub=. ac_top_build_prefix= ;;\n  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;\n  esac ;;\nesac\nac_abs_top_builddir=$ac_pwd\nac_abs_builddir=$ac_pwd$ac_dir_suffix\n# for backward compatibility:\nac_top_builddir=$ac_top_build_prefix\n\ncase $srcdir in\n  .)  # We are building in place.\n    ac_srcdir=.\n    ac_top_srcdir=$ac_top_builddir_sub\n    ac_abs_top_srcdir=$ac_pwd ;;\n  [\\\\/]* | ?:[\\\\/]* )  # Absolute name.\n    ac_srcdir=$srcdir$ac_dir_suffix;\n    ac_top_srcdir=$srcdir\n    ac_abs_top_srcdir=$srcdir ;;\n  *) # Relative name.\n    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix\n    ac_top_srcdir=$ac_top_build_prefix$srcdir\n    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;\nesac\nac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix\n\n    cd \"$ac_dir\" || { ac_status=$?; continue; }\n    # Check for guested configure.\n    if test -f \"$ac_srcdir/configure.gnu\"; then\n      echo &&\n      $SHELL \"$ac_srcdir/configure.gnu\" --help=recursive\n    elif test -f \"$ac_srcdir/configure\"; then\n      echo &&\n      $SHELL \"$ac_srcdir/configure\" --help=recursive\n    else\n      $as_echo \"$as_me: WARNING: no configuration information is in $ac_dir\" >&2\n    fi || ac_status=$?\n    cd \"$ac_pwd\" || { ac_status=$?; break; }\n  done\nfi\n\ntest -n \"$ac_init_help\" && exit $ac_status\nif $ac_init_version; then\n  cat <<\\_ACEOF\nrepmgr configure 5.4.0\ngenerated by GNU Autoconf 2.69\n\nCopyright (C) 2012 Free Software Foundation, Inc.\nThis configure script is free software; the Free Software Foundation\ngives unlimited permission to copy, distribute and modify it.\n\nCopyright (c) 2010-2021, EnterpriseDB Corporation\n_ACEOF\n  exit\nfi\n\n## ------------------------ ##\n## Autoconf initialization. ##\n## ------------------------ ##\ncat >config.log <<_ACEOF\nThis file contains any messages produced by compilers while\nrunning configure, to aid debugging if configure makes a mistake.\n\nIt was created by repmgr $as_me 5.4.0, which was\ngenerated by GNU Autoconf 2.69.  Invocation command line was\n\n  $ $0 $@\n\n_ACEOF\nexec 5>>config.log\n{\ncat <<_ASUNAME\n## --------- ##\n## Platform. ##\n## --------- ##\n\nhostname = `(hostname || uname -n) 2>/dev/null | sed 1q`\nuname -m = `(uname -m) 2>/dev/null || echo unknown`\nuname -r = `(uname -r) 2>/dev/null || echo unknown`\nuname -s = `(uname -s) 2>/dev/null || echo unknown`\nuname -v = `(uname -v) 2>/dev/null || echo unknown`\n\n/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`\n/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`\n\n/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`\n/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`\n/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`\n/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`\n/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`\n/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`\n/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`\n\n_ASUNAME\n\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    $as_echo \"PATH: $as_dir\"\n  done\nIFS=$as_save_IFS\n\n} >&5\n\ncat >&5 <<_ACEOF\n\n\n## ----------- ##\n## Core tests. ##\n## ----------- ##\n\n_ACEOF\n\n\n# Keep a trace of the command line.\n# Strip out --no-create and --no-recursion so they do not pile up.\n# Strip out --silent because we don't want to record it for future runs.\n# Also quote any args containing shell meta-characters.\n# Make two passes to allow for proper duplicate-argument suppression.\nac_configure_args=\nac_configure_args0=\nac_configure_args1=\nac_must_keep_next=false\nfor ac_pass in 1 2\ndo\n  for ac_arg\n  do\n    case $ac_arg in\n    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;\n    -q | -quiet | --quiet | --quie | --qui | --qu | --q \\\n    | -silent | --silent | --silen | --sile | --sil)\n      continue ;;\n    *\\'*)\n      ac_arg=`$as_echo \"$ac_arg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    esac\n    case $ac_pass in\n    1) as_fn_append ac_configure_args0 \" '$ac_arg'\" ;;\n    2)\n      as_fn_append ac_configure_args1 \" '$ac_arg'\"\n      if test $ac_must_keep_next = true; then\n\tac_must_keep_next=false # Got value, back to normal.\n      else\n\tcase $ac_arg in\n\t  *=* | --config-cache | -C | -disable-* | --disable-* \\\n\t  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \\\n\t  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \\\n\t  | -with-* | --with-* | -without-* | --without-* | --x)\n\t    case \"$ac_configure_args0 \" in\n\t      \"$ac_configure_args1\"*\" '$ac_arg' \"* ) continue ;;\n\t    esac\n\t    ;;\n\t  -* ) ac_must_keep_next=true ;;\n\tesac\n      fi\n      as_fn_append ac_configure_args \" '$ac_arg'\"\n      ;;\n    esac\n  done\ndone\n{ ac_configure_args0=; unset ac_configure_args0;}\n{ ac_configure_args1=; unset ac_configure_args1;}\n\n# When interrupted or exit'd, cleanup temporary files, and complete\n# config.log.  We remove comments because anyway the quotes in there\n# would cause problems or look ugly.\n# WARNING: Use '\\'' to represent an apostrophe within the trap.\n# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.\ntrap 'exit_status=$?\n  # Save into config.log some information that might help in debugging.\n  {\n    echo\n\n    $as_echo \"## ---------------- ##\n## Cache variables. ##\n## ---------------- ##\"\n    echo\n    # The following way of writing the cache mishandles newlines in values,\n(\n  for ac_var in `(set) 2>&1 | sed -n '\\''s/^\\([a-zA-Z_][a-zA-Z0-9_]*\\)=.*/\\1/p'\\''`; do\n    eval ac_val=\\$$ac_var\n    case $ac_val in #(\n    *${as_nl}*)\n      case $ac_var in #(\n      *_cv_*) { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline\" >&5\n$as_echo \"$as_me: WARNING: cache variable $ac_var contains a newline\" >&2;} ;;\n      esac\n      case $ac_var in #(\n      _ | IFS | as_nl) ;; #(\n      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(\n      *) { eval $ac_var=; unset $ac_var;} ;;\n      esac ;;\n    esac\n  done\n  (set) 2>&1 |\n    case $as_nl`(ac_space='\\'' '\\''; set) 2>&1` in #(\n    *${as_nl}ac_space=\\ *)\n      sed -n \\\n\t\"s/'\\''/'\\''\\\\\\\\'\\'''\\''/g;\n\t  s/^\\\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\\\)=\\\\(.*\\\\)/\\\\1='\\''\\\\2'\\''/p\"\n      ;; #(\n    *)\n      sed -n \"/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p\"\n      ;;\n    esac |\n    sort\n)\n    echo\n\n    $as_echo \"## ----------------- ##\n## Output variables. ##\n## ----------------- ##\"\n    echo\n    for ac_var in $ac_subst_vars\n    do\n      eval ac_val=\\$$ac_var\n      case $ac_val in\n      *\\'\\''*) ac_val=`$as_echo \"$ac_val\" | sed \"s/'\\''/'\\''\\\\\\\\\\\\\\\\'\\'''\\''/g\"`;;\n      esac\n      $as_echo \"$ac_var='\\''$ac_val'\\''\"\n    done | sort\n    echo\n\n    if test -n \"$ac_subst_files\"; then\n      $as_echo \"## ------------------- ##\n## File substitutions. ##\n## ------------------- ##\"\n      echo\n      for ac_var in $ac_subst_files\n      do\n\teval ac_val=\\$$ac_var\n\tcase $ac_val in\n\t*\\'\\''*) ac_val=`$as_echo \"$ac_val\" | sed \"s/'\\''/'\\''\\\\\\\\\\\\\\\\'\\'''\\''/g\"`;;\n\tesac\n\t$as_echo \"$ac_var='\\''$ac_val'\\''\"\n      done | sort\n      echo\n    fi\n\n    if test -s confdefs.h; then\n      $as_echo \"## ----------- ##\n## confdefs.h. ##\n## ----------- ##\"\n      echo\n      cat confdefs.h\n      echo\n    fi\n    test \"$ac_signal\" != 0 &&\n      $as_echo \"$as_me: caught signal $ac_signal\"\n    $as_echo \"$as_me: exit $exit_status\"\n  } >&5\n  rm -f core *.core core.conftest.* &&\n    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&\n    exit $exit_status\n' 0\nfor ac_signal in 1 2 13 15; do\n  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal\ndone\nac_signal=0\n\n# confdefs.h avoids OS command line length limits that DEFS can exceed.\nrm -f -r conftest* confdefs.h\n\n$as_echo \"/* confdefs.h */\" > confdefs.h\n\n# Predefined preprocessor variables.\n\ncat >>confdefs.h <<_ACEOF\n#define PACKAGE_NAME \"$PACKAGE_NAME\"\n_ACEOF\n\ncat >>confdefs.h <<_ACEOF\n#define PACKAGE_TARNAME \"$PACKAGE_TARNAME\"\n_ACEOF\n\ncat >>confdefs.h <<_ACEOF\n#define PACKAGE_VERSION \"$PACKAGE_VERSION\"\n_ACEOF\n\ncat >>confdefs.h <<_ACEOF\n#define PACKAGE_STRING \"$PACKAGE_STRING\"\n_ACEOF\n\ncat >>confdefs.h <<_ACEOF\n#define PACKAGE_BUGREPORT \"$PACKAGE_BUGREPORT\"\n_ACEOF\n\ncat >>confdefs.h <<_ACEOF\n#define PACKAGE_URL \"$PACKAGE_URL\"\n_ACEOF\n\n\n# Let the site file select an alternate cache file if it wants to.\n# Prefer an explicitly selected file to automatically selected ones.\nac_site_file1=NONE\nac_site_file2=NONE\nif test -n \"$CONFIG_SITE\"; then\n  # We do not want a PATH search for config.site.\n  case $CONFIG_SITE in #((\n    -*)  ac_site_file1=./$CONFIG_SITE;;\n    */*) ac_site_file1=$CONFIG_SITE;;\n    *)   ac_site_file1=./$CONFIG_SITE;;\n  esac\nelif test \"x$prefix\" != xNONE; then\n  ac_site_file1=$prefix/share/config.site\n  ac_site_file2=$prefix/etc/config.site\nelse\n  ac_site_file1=$ac_default_prefix/share/config.site\n  ac_site_file2=$ac_default_prefix/etc/config.site\nfi\nfor ac_site_file in \"$ac_site_file1\" \"$ac_site_file2\"\ndo\n  test \"x$ac_site_file\" = xNONE && continue\n  if test /dev/null != \"$ac_site_file\" && test -r \"$ac_site_file\"; then\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file\" >&5\n$as_echo \"$as_me: loading site script $ac_site_file\" >&6;}\n    sed 's/^/| /' \"$ac_site_file\" >&5\n    . \"$ac_site_file\" \\\n      || { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"failed to load site script $ac_site_file\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\n  fi\ndone\n\nif test -r \"$cache_file\"; then\n  # Some versions of bash will fail to source /dev/null (special files\n  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.\n  if test /dev/null != \"$cache_file\" && test -f \"$cache_file\"; then\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: loading cache $cache_file\" >&5\n$as_echo \"$as_me: loading cache $cache_file\" >&6;}\n    case $cache_file in\n      [\\\\/]* | ?:[\\\\/]* ) . \"$cache_file\";;\n      *)                      . \"./$cache_file\";;\n    esac\n  fi\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: creating cache $cache_file\" >&5\n$as_echo \"$as_me: creating cache $cache_file\" >&6;}\n  >$cache_file\nfi\n\n# Check that the precious variables saved in the cache have kept the same\n# value.\nac_cache_corrupted=false\nfor ac_var in $ac_precious_vars; do\n  eval ac_old_set=\\$ac_cv_env_${ac_var}_set\n  eval ac_new_set=\\$ac_env_${ac_var}_set\n  eval ac_old_val=\\$ac_cv_env_${ac_var}_value\n  eval ac_new_val=\\$ac_env_${ac_var}_value\n  case $ac_old_set,$ac_new_set in\n    set,)\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: error: \\`$ac_var' was set to \\`$ac_old_val' in the previous run\" >&5\n$as_echo \"$as_me: error: \\`$ac_var' was set to \\`$ac_old_val' in the previous run\" >&2;}\n      ac_cache_corrupted=: ;;\n    ,set)\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: error: \\`$ac_var' was not set in the previous run\" >&5\n$as_echo \"$as_me: error: \\`$ac_var' was not set in the previous run\" >&2;}\n      ac_cache_corrupted=: ;;\n    ,);;\n    *)\n      if test \"x$ac_old_val\" != \"x$ac_new_val\"; then\n\t# differences in whitespace do not lead to failure.\n\tac_old_val_w=`echo x $ac_old_val`\n\tac_new_val_w=`echo x $ac_new_val`\n\tif test \"$ac_old_val_w\" != \"$ac_new_val_w\"; then\n\t  { $as_echo \"$as_me:${as_lineno-$LINENO}: error: \\`$ac_var' has changed since the previous run:\" >&5\n$as_echo \"$as_me: error: \\`$ac_var' has changed since the previous run:\" >&2;}\n\t  ac_cache_corrupted=:\n\telse\n\t  { $as_echo \"$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \\`$ac_var' since the previous run:\" >&5\n$as_echo \"$as_me: warning: ignoring whitespace changes in \\`$ac_var' since the previous run:\" >&2;}\n\t  eval $ac_var=\\$ac_old_val\n\tfi\n\t{ $as_echo \"$as_me:${as_lineno-$LINENO}:   former value:  \\`$ac_old_val'\" >&5\n$as_echo \"$as_me:   former value:  \\`$ac_old_val'\" >&2;}\n\t{ $as_echo \"$as_me:${as_lineno-$LINENO}:   current value: \\`$ac_new_val'\" >&5\n$as_echo \"$as_me:   current value: \\`$ac_new_val'\" >&2;}\n      fi;;\n  esac\n  # Pass precious variables to config.status.\n  if test \"$ac_new_set\" = set; then\n    case $ac_new_val in\n    *\\'*) ac_arg=$ac_var=`$as_echo \"$ac_new_val\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    *) ac_arg=$ac_var=$ac_new_val ;;\n    esac\n    case \" $ac_configure_args \" in\n      *\" '$ac_arg' \"*) ;; # Avoid dups.  Use of quotes ensures accuracy.\n      *) as_fn_append ac_configure_args \" '$ac_arg'\" ;;\n    esac\n  fi\ndone\nif $ac_cache_corrupted; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build\" >&5\n$as_echo \"$as_me: error: changes in the environment can compromise the build\" >&2;}\n  as_fn_error $? \"run \\`make distclean' and/or \\`rm $cache_file' and start over\" \"$LINENO\" 5\nfi\n## -------------------- ##\n## Main body of script. ##\n## -------------------- ##\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\n\n\n\n\nac_config_headers=\"$ac_config_headers config.h\"\n\n\n\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output\" >&5\n$as_echo_n \"checking for a sed that does not truncate output... \" >&6; }\nif ${ac_cv_path_SED+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/\n     for ac_i in 1 2 3 4 5 6 7; do\n       ac_script=\"$ac_script$as_nl$ac_script\"\n     done\n     echo \"$ac_script\" 2>/dev/null | sed 99q >conftest.sed\n     { ac_script=; unset ac_script;}\n     if test -z \"$SED\"; then\n  ac_path_SED_found=false\n  # Loop through the user's path and test for each of PROGNAME-LIST\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_prog in sed gsed; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      ac_path_SED=\"$as_dir/$ac_prog$ac_exec_ext\"\n      as_fn_executable_p \"$ac_path_SED\" || continue\n# Check for GNU ac_path_SED and select it if it is found.\n  # Check for GNU $ac_path_SED\ncase `\"$ac_path_SED\" --version 2>&1` in\n*GNU*)\n  ac_cv_path_SED=\"$ac_path_SED\" ac_path_SED_found=:;;\n*)\n  ac_count=0\n  $as_echo_n 0123456789 >\"conftest.in\"\n  while :\n  do\n    cat \"conftest.in\" \"conftest.in\" >\"conftest.tmp\"\n    mv \"conftest.tmp\" \"conftest.in\"\n    cp \"conftest.in\" \"conftest.nl\"\n    $as_echo '' >> \"conftest.nl\"\n    \"$ac_path_SED\" -f conftest.sed < \"conftest.nl\" >\"conftest.out\" 2>/dev/null || break\n    diff \"conftest.out\" \"conftest.nl\" >/dev/null 2>&1 || break\n    as_fn_arith $ac_count + 1 && ac_count=$as_val\n    if test $ac_count -gt ${ac_path_SED_max-0}; then\n      # Best one so far, save it but keep looking for a better one\n      ac_cv_path_SED=\"$ac_path_SED\"\n      ac_path_SED_max=$ac_count\n    fi\n    # 10*(2^10) chars as input seems more than enough\n    test $ac_count -gt 10 && break\n  done\n  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;\nesac\n\n      $ac_path_SED_found && break 3\n    done\n  done\n  done\nIFS=$as_save_IFS\n  if test -z \"$ac_cv_path_SED\"; then\n    as_fn_error $? \"no acceptable sed could be found in \\$PATH\" \"$LINENO\" 5\n  fi\nelse\n  ac_cv_path_SED=$SED\nfi\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED\" >&5\n$as_echo \"$ac_cv_path_SED\" >&6; }\n SED=\"$ac_cv_path_SED\"\n  rm -f conftest.sed\n\n\nif test -z \"$PG_CONFIG\"; then\n  # Extract the first word of \"pg_config\", so it can be a program name with args.\nset dummy pg_config; ac_word=$2\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n$as_echo_n \"checking for $ac_word... \" >&6; }\nif ${ac_cv_path_PG_CONFIG+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  case $PG_CONFIG in\n  [\\\\/]* | ?:[\\\\/]*)\n  ac_cv_path_PG_CONFIG=\"$PG_CONFIG\" # Let the user override the test with a path.\n  ;;\n  *)\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n    ac_cv_path_PG_CONFIG=\"$as_dir/$ac_word$ac_exec_ext\"\n    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\n  ;;\nesac\nfi\nPG_CONFIG=$ac_cv_path_PG_CONFIG\nif test -n \"$PG_CONFIG\"; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $PG_CONFIG\" >&5\n$as_echo \"$PG_CONFIG\" >&6; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\n\n\nfi\n\nif test -z \"$PG_CONFIG\"; then\n   as_fn_error $? \"could not find pg_config, set PG_CONFIG or PATH\" \"$LINENO\" 5\nfi\n\npgac_pg_config_version=$($PG_CONFIG --version 2>/dev/null)\n\nmajor_version_num=$(echo \"$pgac_pg_config_version\"|\n              $SED -e 's/^[^0-9]\\+ \\([0-9]\\{1,2\\}\\).*$/\\1/')\n\nif test \"$major_version_num\" -lt '10'; then\n    version_num=$(echo \"$pgac_pg_config_version\"|\n                $SED -e 's/^[^0-9]\\+ \\([0-9]*\\)\\.\\([0-9]*\\)\\([a-zA-Z0-9.]*\\)$/\\1.\\2/')\n\n    if test -z \"$version_num\"; then\n        as_fn_error $? \"could not detect the PostgreSQL version, wrong or broken pg_config?\" \"$LINENO\" 5\n    fi\n\n    version_num_int=$(echo \"$version_num\"|\n                    $SED -e 's/^\\([0-9]*\\)\\.\\([0-9]*\\)$/\\1\\2/')\n\n    if test \"$version_num_int\" -lt '94'; then\n        as_fn_error $? \"repmgr is not compatible with detected PostgreSQL version: $version_num\" \"$LINENO\" 5\n    fi\nelse\n    version_num=$(echo \"$pgac_pg_config_version\"|\n                $SED -e 's/^[^0-9]\\+ \\(.\\+\\)$/\\1/')\n\n    if test -z \"$version_num\"; then\n        as_fn_error $? \"could not detect the PostgreSQL version, wrong or broken pg_config?\" \"$LINENO\" 5\n    fi\nfi\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: building against PostgreSQL $version_num\" >&5\n$as_echo \"$as_me: building against PostgreSQL $version_num\" >&6;}\n\n# add includedir to prerequisites, so tests for headers can succeed\nCPPFLAGS=\"-I$($PG_CONFIG --includedir-server) $CFLAGS\"\n\n# check whether we're building inside the source tree.\nif test \"$srcdir\" -ef '.' ; then\n  vpath_build=no\nelse\n  vpath_build=yes\nfi\n\n\n# Extract the first word of \"gnused\", so it can be a program name with args.\nset dummy gnused; ac_word=$2\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n$as_echo_n \"checking for $ac_word... \" >&6; }\nif ${ac_cv_prog_HAVE_GNUSED+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  if test -n \"$HAVE_GNUSED\"; then\n  ac_cv_prog_HAVE_GNUSED=\"$HAVE_GNUSED\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_HAVE_GNUSED=\"yes\"\n    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\n  test -z \"$ac_cv_prog_HAVE_GNUSED\" && ac_cv_prog_HAVE_GNUSED=\"no\"\nfi\nfi\nHAVE_GNUSED=$ac_cv_prog_HAVE_GNUSED\nif test -n \"$HAVE_GNUSED\"; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $HAVE_GNUSED\" >&5\n$as_echo \"$HAVE_GNUSED\" >&6; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\n\n\n# Extract the first word of \"gsed\", so it can be a program name with args.\nset dummy gsed; ac_word=$2\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n$as_echo_n \"checking for $ac_word... \" >&6; }\nif ${ac_cv_prog_HAVE_GSED+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  if test -n \"$HAVE_GSED\"; then\n  ac_cv_prog_HAVE_GSED=\"$HAVE_GSED\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_HAVE_GSED=\"yes\"\n    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\n  test -z \"$ac_cv_prog_HAVE_GSED\" && ac_cv_prog_HAVE_GSED=\"no\"\nfi\nfi\nHAVE_GSED=$ac_cv_prog_HAVE_GSED\nif test -n \"$HAVE_GSED\"; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $HAVE_GSED\" >&5\n$as_echo \"$HAVE_GSED\" >&6; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\n\n\n# Extract the first word of \"sed\", so it can be a program name with args.\nset dummy sed; ac_word=$2\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n$as_echo_n \"checking for $ac_word... \" >&6; }\nif ${ac_cv_prog_HAVE_SED+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  if test -n \"$HAVE_SED\"; then\n  ac_cv_prog_HAVE_SED=\"$HAVE_SED\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_HAVE_SED=\"yes\"\n    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\n  test -z \"$ac_cv_prog_HAVE_SED\" && ac_cv_prog_HAVE_SED=\"no\"\nfi\nfi\nHAVE_SED=$ac_cv_prog_HAVE_SED\nif test -n \"$HAVE_SED\"; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $HAVE_SED\" >&5\n$as_echo \"$HAVE_SED\" >&6; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\n\n\n\nif test \"$HAVE_GNUSED\" = yes; then\n SED=gnused\nelse\n if test \"$HAVE_GSED\" = yes; then\n  SED=gsed\n else\n  SED=sed\n fi\nfi\n\n\n\nac_config_files=\"$ac_config_files Makefile\"\n\nac_config_files=\"$ac_config_files Makefile.global\"\n\ncat >confcache <<\\_ACEOF\n# This file is a shell script that caches the results of configure\n# tests run on this system so they can be shared between configure\n# scripts and configure runs, see configure's option --config-cache.\n# It is not useful on other systems.  If it contains results you don't\n# want to keep, you may remove or edit it.\n#\n# config.status only pays attention to the cache file if you give it\n# the --recheck option to rerun configure.\n#\n# `ac_cv_env_foo' variables (set or unset) will be overridden when\n# loading this file, other *unset* `ac_cv_foo' will be assigned the\n# following values.\n\n_ACEOF\n\n# The following way of writing the cache mishandles newlines in values,\n# but we know of no workaround that is simple, portable, and efficient.\n# So, we kill variables containing newlines.\n# Ultrix sh set writes to stderr and can't be redirected directly,\n# and sets the high bit in the cache file unless we assign to the vars.\n(\n  for ac_var in `(set) 2>&1 | sed -n 's/^\\([a-zA-Z_][a-zA-Z0-9_]*\\)=.*/\\1/p'`; do\n    eval ac_val=\\$$ac_var\n    case $ac_val in #(\n    *${as_nl}*)\n      case $ac_var in #(\n      *_cv_*) { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline\" >&5\n$as_echo \"$as_me: WARNING: cache variable $ac_var contains a newline\" >&2;} ;;\n      esac\n      case $ac_var in #(\n      _ | IFS | as_nl) ;; #(\n      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(\n      *) { eval $ac_var=; unset $ac_var;} ;;\n      esac ;;\n    esac\n  done\n\n  (set) 2>&1 |\n    case $as_nl`(ac_space=' '; set) 2>&1` in #(\n    *${as_nl}ac_space=\\ *)\n      # `set' does not quote correctly, so add quotes: double-quote\n      # substitution turns \\\\\\\\ into \\\\, and sed turns \\\\ into \\.\n      sed -n \\\n\t\"s/'/'\\\\\\\\''/g;\n\t  s/^\\\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\\\)=\\\\(.*\\\\)/\\\\1='\\\\2'/p\"\n      ;; #(\n    *)\n      # `set' quotes correctly as required by POSIX, so do not add quotes.\n      sed -n \"/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p\"\n      ;;\n    esac |\n    sort\n) |\n  sed '\n     /^ac_cv_env_/b end\n     t clear\n     :clear\n     s/^\\([^=]*\\)=\\(.*[{}].*\\)$/test \"${\\1+set}\" = set || &/\n     t end\n     s/^\\([^=]*\\)=\\(.*\\)$/\\1=${\\1=\\2}/\n     :end' >>confcache\nif diff \"$cache_file\" confcache >/dev/null 2>&1; then :; else\n  if test -w \"$cache_file\"; then\n    if test \"x$cache_file\" != \"x/dev/null\"; then\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: updating cache $cache_file\" >&5\n$as_echo \"$as_me: updating cache $cache_file\" >&6;}\n      if test ! -f \"$cache_file\" || test -h \"$cache_file\"; then\n\tcat confcache >\"$cache_file\"\n      else\n        case $cache_file in #(\n        */* | ?:*)\n\t  mv -f confcache \"$cache_file\"$$ &&\n\t  mv -f \"$cache_file\"$$ \"$cache_file\" ;; #(\n        *)\n\t  mv -f confcache \"$cache_file\" ;;\n\tesac\n      fi\n    fi\n  else\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file\" >&5\n$as_echo \"$as_me: not updating unwritable cache $cache_file\" >&6;}\n  fi\nfi\nrm -f confcache\n\ntest \"x$prefix\" = xNONE && prefix=$ac_default_prefix\n# Let make expand exec_prefix.\ntest \"x$exec_prefix\" = xNONE && exec_prefix='${prefix}'\n\nDEFS=-DHAVE_CONFIG_H\n\nac_libobjs=\nac_ltlibobjs=\nU=\nfor ac_i in : $LIBOBJS; do test \"x$ac_i\" = x: && continue\n  # 1. Remove the extension, and $U if already installed.\n  ac_script='s/\\$U\\././;s/\\.o$//;s/\\.obj$//'\n  ac_i=`$as_echo \"$ac_i\" | sed \"$ac_script\"`\n  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR\n  #    will be set to the directory where LIBOBJS objects are built.\n  as_fn_append ac_libobjs \" \\${LIBOBJDIR}$ac_i\\$U.$ac_objext\"\n  as_fn_append ac_ltlibobjs \" \\${LIBOBJDIR}$ac_i\"'$U.lo'\ndone\nLIBOBJS=$ac_libobjs\n\nLTLIBOBJS=$ac_ltlibobjs\n\n\n\n: \"${CONFIG_STATUS=./config.status}\"\nac_write_fail=0\nac_clean_files_save=$ac_clean_files\nac_clean_files=\"$ac_clean_files $CONFIG_STATUS\"\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS\" >&5\n$as_echo \"$as_me: creating $CONFIG_STATUS\" >&6;}\nas_write_fail=0\ncat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1\n#! $SHELL\n# Generated by $as_me.\n# Run this file to recreate the current configuration.\n# Compiler output produced by configure, useful for debugging\n# configure, is in config.log if it exists.\n\ndebug=false\nac_cs_recheck=false\nac_cs_silent=false\n\nSHELL=\\${CONFIG_SHELL-$SHELL}\nexport SHELL\n_ASEOF\ncat >>$CONFIG_STATUS <<\\_ASEOF || as_write_fail=1\n## -------------------- ##\n## M4sh Initialization. ##\n## -------------------- ##\n\n# Be more Bourne compatible\nDUALCASE=1; export DUALCASE # for MKS sh\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in #(\n  *posix*) :\n    set -o posix ;; #(\n  *) :\n     ;;\nesac\nfi\n\n\nas_nl='\n'\nexport as_nl\n# Printing a long string crashes Solaris 7 /usr/bin/printf.\nas_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\nas_echo=$as_echo$as_echo$as_echo$as_echo$as_echo\nas_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo\n# Prefer a ksh shell builtin over an external printf program on Solaris,\n# but without wasting forks for bash or zsh.\nif test -z \"$BASH_VERSION$ZSH_VERSION\" \\\n    && (test \"X`print -r -- $as_echo`\" = \"X$as_echo\") 2>/dev/null; then\n  as_echo='print -r --'\n  as_echo_n='print -rn --'\nelif (test \"X`printf %s $as_echo`\" = \"X$as_echo\") 2>/dev/null; then\n  as_echo='printf %s\\n'\n  as_echo_n='printf %s'\nelse\n  if test \"X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`\" = \"X-n $as_echo\"; then\n    as_echo_body='eval /usr/ucb/echo -n \"$1$as_nl\"'\n    as_echo_n='/usr/ucb/echo -n'\n  else\n    as_echo_body='eval expr \"X$1\" : \"X\\\\(.*\\\\)\"'\n    as_echo_n_body='eval\n      arg=$1;\n      case $arg in #(\n      *\"$as_nl\"*)\n\texpr \"X$arg\" : \"X\\\\(.*\\\\)$as_nl\";\n\targ=`expr \"X$arg\" : \".*$as_nl\\\\(.*\\\\)\"`;;\n      esac;\n      expr \"X$arg\" : \"X\\\\(.*\\\\)\" | tr -d \"$as_nl\"\n    '\n    export as_echo_n_body\n    as_echo_n='sh -c $as_echo_n_body as_echo'\n  fi\n  export as_echo_body\n  as_echo='sh -c $as_echo_body as_echo'\nfi\n\n# The user is always right.\nif test \"${PATH_SEPARATOR+set}\" != set; then\n  PATH_SEPARATOR=:\n  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {\n    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||\n      PATH_SEPARATOR=';'\n  }\nfi\n\n\n# IFS\n# We need space, tab and new line, in precisely that order.  Quoting is\n# there to prevent editors from complaining about space-tab.\n# (If _AS_PATH_WALK were called with IFS unset, it would disable word\n# splitting by setting IFS to empty value.)\nIFS=\" \"\"\t$as_nl\"\n\n# Find who we are.  Look in the path if we contain no directory separator.\nas_myself=\ncase $0 in #((\n  *[\\\\/]* ) as_myself=$0 ;;\n  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    test -r \"$as_dir/$0\" && as_myself=$as_dir/$0 && break\n  done\nIFS=$as_save_IFS\n\n     ;;\nesac\n# We did not find ourselves, most probably we were run as `sh COMMAND'\n# in which case we are not to be found in the path.\nif test \"x$as_myself\" = x; then\n  as_myself=$0\nfi\nif test ! -f \"$as_myself\"; then\n  $as_echo \"$as_myself: error: cannot find myself; rerun with an absolute file name\" >&2\n  exit 1\nfi\n\n# Unset variables that we do not need and which cause bugs (e.g. in\n# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the \"|| exit 1\"\n# suppresses any \"Segmentation fault\" message there.  '((' could\n# trigger a bug in pdksh 5.2.14.\nfor as_var in BASH_ENV ENV MAIL MAILPATH\ndo eval test x\\${$as_var+set} = xset \\\n  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :\ndone\nPS1='$ '\nPS2='> '\nPS4='+ '\n\n# NLS nuisances.\nLC_ALL=C\nexport LC_ALL\nLANGUAGE=C\nexport LANGUAGE\n\n# CDPATH.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\n\n# as_fn_error STATUS ERROR [LINENO LOG_FD]\n# ----------------------------------------\n# Output \"`basename $0`: error: ERROR\" to stderr. If LINENO and LOG_FD are\n# provided, also output the error to LOG_FD, referencing LINENO. Then exit the\n# script with STATUS, using 1 if that was 0.\nas_fn_error ()\n{\n  as_status=$1; test $as_status -eq 0 && as_status=1\n  if test \"$4\"; then\n    as_lineno=${as_lineno-\"$3\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n    $as_echo \"$as_me:${as_lineno-$LINENO}: error: $2\" >&$4\n  fi\n  $as_echo \"$as_me: error: $2\" >&2\n  as_fn_exit $as_status\n} # as_fn_error\n\n\n# as_fn_set_status STATUS\n# -----------------------\n# Set $? to STATUS, without forking.\nas_fn_set_status ()\n{\n  return $1\n} # as_fn_set_status\n\n# as_fn_exit STATUS\n# -----------------\n# Exit the shell with STATUS, even in a \"trap 0\" or \"set -e\" context.\nas_fn_exit ()\n{\n  set +e\n  as_fn_set_status $1\n  exit $1\n} # as_fn_exit\n\n# as_fn_unset VAR\n# ---------------\n# Portably unset VAR.\nas_fn_unset ()\n{\n  { eval $1=; unset $1;}\n}\nas_unset=as_fn_unset\n# as_fn_append VAR VALUE\n# ----------------------\n# Append the text in VALUE to the end of the definition contained in VAR. Take\n# advantage of any shell optimizations that allow amortized linear growth over\n# repeated appends, instead of the typical quadratic growth present in naive\n# implementations.\nif (eval \"as_var=1; as_var+=2; test x\\$as_var = x12\") 2>/dev/null; then :\n  eval 'as_fn_append ()\n  {\n    eval $1+=\\$2\n  }'\nelse\n  as_fn_append ()\n  {\n    eval $1=\\$$1\\$2\n  }\nfi # as_fn_append\n\n# as_fn_arith ARG...\n# ------------------\n# Perform arithmetic evaluation on the ARGs, and store the result in the\n# global $as_val. Take advantage of shells that can avoid forks. The arguments\n# must be portable across $(()) and expr.\nif (eval \"test \\$(( 1 + 1 )) = 2\") 2>/dev/null; then :\n  eval 'as_fn_arith ()\n  {\n    as_val=$(( $* ))\n  }'\nelse\n  as_fn_arith ()\n  {\n    as_val=`expr \"$@\" || test $? -eq 1`\n  }\nfi # as_fn_arith\n\n\nif expr a : '\\(a\\)' >/dev/null 2>&1 &&\n   test \"X`expr 00001 : '.*\\(...\\)'`\" = X001; then\n  as_expr=expr\nelse\n  as_expr=false\nfi\n\nif (basename -- /) >/dev/null 2>&1 && test \"X`basename -- / 2>&1`\" = \"X/\"; then\n  as_basename=basename\nelse\n  as_basename=false\nfi\n\nif (as_dir=`dirname -- /` && test \"X$as_dir\" = X/) >/dev/null 2>&1; then\n  as_dirname=dirname\nelse\n  as_dirname=false\nfi\n\nas_me=`$as_basename -- \"$0\" ||\n$as_expr X/\"$0\" : '.*/\\([^/][^/]*\\)/*$' \\| \\\n\t X\"$0\" : 'X\\(//\\)$' \\| \\\n\t X\"$0\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n$as_echo X/\"$0\" |\n    sed '/^.*\\/\\([^/][^/]*\\)\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n\n# Avoid depending upon Character Ranges.\nas_cr_letters='abcdefghijklmnopqrstuvwxyz'\nas_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nas_cr_Letters=$as_cr_letters$as_cr_LETTERS\nas_cr_digits='0123456789'\nas_cr_alnum=$as_cr_Letters$as_cr_digits\n\nECHO_C= ECHO_N= ECHO_T=\ncase `echo -n x` in #(((((\n-n*)\n  case `echo 'xy\\c'` in\n  *c*) ECHO_T='\t';;\t# ECHO_T is single tab character.\n  xy)  ECHO_C='\\c';;\n  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null\n       ECHO_T='\t';;\n  esac;;\n*)\n  ECHO_N='-n';;\nesac\n\nrm -f conf$$ conf$$.exe conf$$.file\nif test -d conf$$.dir; then\n  rm -f conf$$.dir/conf$$.file\nelse\n  rm -f conf$$.dir\n  mkdir conf$$.dir 2>/dev/null\nfi\nif (echo >conf$$.file) 2>/dev/null; then\n  if ln -s conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s='ln -s'\n    # ... but there are two gotchas:\n    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.\n    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.\n    # In both cases, we have to default to `cp -pR'.\n    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||\n      as_ln_s='cp -pR'\n  elif ln conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s=ln\n  else\n    as_ln_s='cp -pR'\n  fi\nelse\n  as_ln_s='cp -pR'\nfi\nrm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file\nrmdir conf$$.dir 2>/dev/null\n\n\n# as_fn_mkdir_p\n# -------------\n# Create \"$as_dir\" as a directory, including parents if necessary.\nas_fn_mkdir_p ()\n{\n\n  case $as_dir in #(\n  -*) as_dir=./$as_dir;;\n  esac\n  test -d \"$as_dir\" || eval $as_mkdir_p || {\n    as_dirs=\n    while :; do\n      case $as_dir in #(\n      *\\'*) as_qdir=`$as_echo \"$as_dir\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;; #'(\n      *) as_qdir=$as_dir;;\n      esac\n      as_dirs=\"'$as_qdir' $as_dirs\"\n      as_dir=`$as_dirname -- \"$as_dir\" ||\n$as_expr X\"$as_dir\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)$' \\| \\\n\t X\"$as_dir\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n$as_echo X\"$as_dir\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n      test -d \"$as_dir\" && break\n    done\n    test -z \"$as_dirs\" || eval \"mkdir $as_dirs\"\n  } || test -d \"$as_dir\" || as_fn_error $? \"cannot create directory $as_dir\"\n\n\n} # as_fn_mkdir_p\nif mkdir -p . 2>/dev/null; then\n  as_mkdir_p='mkdir -p \"$as_dir\"'\nelse\n  test -d ./-p && rmdir ./-p\n  as_mkdir_p=false\nfi\n\n\n# as_fn_executable_p FILE\n# -----------------------\n# Test if FILE is an executable regular file.\nas_fn_executable_p ()\n{\n  test -f \"$1\" && test -x \"$1\"\n} # as_fn_executable_p\nas_test_x='test -x'\nas_executable_p=as_fn_executable_p\n\n# Sed expression to map a string onto a valid CPP name.\nas_tr_cpp=\"eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'\"\n\n# Sed expression to map a string onto a valid variable name.\nas_tr_sh=\"eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'\"\n\n\nexec 6>&1\n## ----------------------------------- ##\n## Main body of $CONFIG_STATUS script. ##\n## ----------------------------------- ##\n_ASEOF\ntest $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n# Save the log message, to keep $0 and so on meaningful, and to\n# report actual input values of CONFIG_FILES etc. instead of their\n# values after options handling.\nac_log=\"\nThis file was extended by repmgr $as_me 5.4.0, which was\ngenerated by GNU Autoconf 2.69.  Invocation command line was\n\n  CONFIG_FILES    = $CONFIG_FILES\n  CONFIG_HEADERS  = $CONFIG_HEADERS\n  CONFIG_LINKS    = $CONFIG_LINKS\n  CONFIG_COMMANDS = $CONFIG_COMMANDS\n  $ $0 $@\n\non `(hostname || uname -n) 2>/dev/null | sed 1q`\n\"\n\n_ACEOF\n\ncase $ac_config_files in *\"\n\"*) set x $ac_config_files; shift; ac_config_files=$*;;\nesac\n\ncase $ac_config_headers in *\"\n\"*) set x $ac_config_headers; shift; ac_config_headers=$*;;\nesac\n\n\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n# Files that config.status was made for.\nconfig_files=\"$ac_config_files\"\nconfig_headers=\"$ac_config_headers\"\n\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nac_cs_usage=\"\\\n\\`$as_me' instantiates files and other configuration actions\nfrom templates according to the current configuration.  Unless the files\nand actions are specified as TAGs, all are instantiated by default.\n\nUsage: $0 [OPTION]... [TAG]...\n\n  -h, --help       print this help, then exit\n  -V, --version    print version number and configuration settings, then exit\n      --config     print configuration, then exit\n  -q, --quiet, --silent\n                   do not print progress messages\n  -d, --debug      don't remove temporary files\n      --recheck    update $as_me by reconfiguring in the same conditions\n      --file=FILE[:TEMPLATE]\n                   instantiate the configuration file FILE\n      --header=FILE[:TEMPLATE]\n                   instantiate the configuration header FILE\n\nConfiguration files:\n$config_files\n\nConfiguration headers:\n$config_headers\n\nReport bugs to <repmgr@googlegroups.com>.\nrepmgr home page: <https://repmgr.org/>.\"\n\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\nac_cs_config=\"`$as_echo \"$ac_configure_args\" | sed 's/^ //; s/[\\\\\"\"\\`\\$]/\\\\\\\\&/g'`\"\nac_cs_version=\"\\\\\nrepmgr config.status 5.4.0\nconfigured by $0, generated by GNU Autoconf 2.69,\n  with options \\\\\"\\$ac_cs_config\\\\\"\n\nCopyright (C) 2012 Free Software Foundation, Inc.\nThis config.status script is free software; the Free Software Foundation\ngives unlimited permission to copy, distribute and modify it.\"\n\nac_pwd='$ac_pwd'\nsrcdir='$srcdir'\ntest -n \"\\$AWK\" || AWK=awk\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n# The default lists apply if the user does not specify any file.\nac_need_defaults=:\nwhile test $# != 0\ndo\n  case $1 in\n  --*=?*)\n    ac_option=`expr \"X$1\" : 'X\\([^=]*\\)='`\n    ac_optarg=`expr \"X$1\" : 'X[^=]*=\\(.*\\)'`\n    ac_shift=:\n    ;;\n  --*=)\n    ac_option=`expr \"X$1\" : 'X\\([^=]*\\)='`\n    ac_optarg=\n    ac_shift=:\n    ;;\n  *)\n    ac_option=$1\n    ac_optarg=$2\n    ac_shift=shift\n    ;;\n  esac\n\n  case $ac_option in\n  # Handling of the options.\n  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)\n    ac_cs_recheck=: ;;\n  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )\n    $as_echo \"$ac_cs_version\"; exit ;;\n  --config | --confi | --conf | --con | --co | --c )\n    $as_echo \"$ac_cs_config\"; exit ;;\n  --debug | --debu | --deb | --de | --d | -d )\n    debug=: ;;\n  --file | --fil | --fi | --f )\n    $ac_shift\n    case $ac_optarg in\n    *\\'*) ac_optarg=`$as_echo \"$ac_optarg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    '') as_fn_error $? \"missing file argument\" ;;\n    esac\n    as_fn_append CONFIG_FILES \" '$ac_optarg'\"\n    ac_need_defaults=false;;\n  --header | --heade | --head | --hea )\n    $ac_shift\n    case $ac_optarg in\n    *\\'*) ac_optarg=`$as_echo \"$ac_optarg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    esac\n    as_fn_append CONFIG_HEADERS \" '$ac_optarg'\"\n    ac_need_defaults=false;;\n  --he | --h)\n    # Conflict between --help and --header\n    as_fn_error $? \"ambiguous option: \\`$1'\nTry \\`$0 --help' for more information.\";;\n  --help | --hel | -h )\n    $as_echo \"$ac_cs_usage\"; exit ;;\n  -q | -quiet | --quiet | --quie | --qui | --qu | --q \\\n  | -silent | --silent | --silen | --sile | --sil | --si | --s)\n    ac_cs_silent=: ;;\n\n  # This is an error.\n  -*) as_fn_error $? \"unrecognized option: \\`$1'\nTry \\`$0 --help' for more information.\" ;;\n\n  *) as_fn_append ac_config_targets \" $1\"\n     ac_need_defaults=false ;;\n\n  esac\n  shift\ndone\n\nac_configure_extra_args=\n\nif $ac_cs_silent; then\n  exec 6>/dev/null\n  ac_configure_extra_args=\"$ac_configure_extra_args --silent\"\nfi\n\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\nif \\$ac_cs_recheck; then\n  set X $SHELL '$0' $ac_configure_args \\$ac_configure_extra_args --no-create --no-recursion\n  shift\n  \\$as_echo \"running CONFIG_SHELL=$SHELL \\$*\" >&6\n  CONFIG_SHELL='$SHELL'\n  export CONFIG_SHELL\n  exec \"\\$@\"\nfi\n\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nexec 5>>config.log\n{\n  echo\n  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX\n## Running $as_me. ##\n_ASBOX\n  $as_echo \"$ac_log\"\n} >&5\n\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n\n# Handling of arguments.\nfor ac_config_target in $ac_config_targets\ndo\n  case $ac_config_target in\n    \"config.h\") CONFIG_HEADERS=\"$CONFIG_HEADERS config.h\" ;;\n    \"Makefile\") CONFIG_FILES=\"$CONFIG_FILES Makefile\" ;;\n    \"Makefile.global\") CONFIG_FILES=\"$CONFIG_FILES Makefile.global\" ;;\n\n  *) as_fn_error $? \"invalid argument: \\`$ac_config_target'\" \"$LINENO\" 5;;\n  esac\ndone\n\n\n# If the user did not use the arguments to specify the items to instantiate,\n# then the envvar interface is used.  Set only those that are not.\n# We use the long form for the default assignment because of an extremely\n# bizarre bug on SunOS 4.1.3.\nif $ac_need_defaults; then\n  test \"${CONFIG_FILES+set}\" = set || CONFIG_FILES=$config_files\n  test \"${CONFIG_HEADERS+set}\" = set || CONFIG_HEADERS=$config_headers\nfi\n\n# Have a temporary directory for convenience.  Make it in the build tree\n# simply because there is no reason against having it here, and in addition,\n# creating and moving files from /tmp can sometimes cause problems.\n# Hook for its removal unless debugging.\n# Note that there is a small window in which the directory will not be cleaned:\n# after its creation but before its name has been assigned to `$tmp'.\n$debug ||\n{\n  tmp= ac_tmp=\n  trap 'exit_status=$?\n  : \"${ac_tmp:=$tmp}\"\n  { test ! -d \"$ac_tmp\" || rm -fr \"$ac_tmp\"; } && exit $exit_status\n' 0\n  trap 'as_fn_exit 1' 1 2 13 15\n}\n# Create a (secure) tmp directory for tmp files.\n\n{\n  tmp=`(umask 077 && mktemp -d \"./confXXXXXX\") 2>/dev/null` &&\n  test -d \"$tmp\"\n}  ||\n{\n  tmp=./conf$$-$RANDOM\n  (umask 077 && mkdir \"$tmp\")\n} || as_fn_error $? \"cannot create a temporary directory in .\" \"$LINENO\" 5\nac_tmp=$tmp\n\n# Set up the scripts for CONFIG_FILES section.\n# No need to generate them if there are no CONFIG_FILES.\n# This happens for instance with `./config.status config.h'.\nif test -n \"$CONFIG_FILES\"; then\n\n\nac_cr=`echo X | tr X '\\015'`\n# On cygwin, bash can eat \\r inside `` if the user requested igncr.\n# But we know of no other shell where ac_cr would be empty at this\n# point, so we can use a bashism as a fallback.\nif test \"x$ac_cr\" = x; then\n  eval ac_cr=\\$\\'\\\\r\\'\nfi\nac_cs_awk_cr=`$AWK 'BEGIN { print \"a\\rb\" }' </dev/null 2>/dev/null`\nif test \"$ac_cs_awk_cr\" = \"a${ac_cr}b\"; then\n  ac_cs_awk_cr='\\\\r'\nelse\n  ac_cs_awk_cr=$ac_cr\nfi\n\necho 'BEGIN {' >\"$ac_tmp/subs1.awk\" &&\n_ACEOF\n\n\n{\n  echo \"cat >conf$$subs.awk <<_ACEOF\" &&\n  echo \"$ac_subst_vars\" | sed 's/.*/&!$&$ac_delim/' &&\n  echo \"_ACEOF\"\n} >conf$$subs.sh ||\n  as_fn_error $? \"could not make $CONFIG_STATUS\" \"$LINENO\" 5\nac_delim_num=`echo \"$ac_subst_vars\" | grep -c '^'`\nac_delim='%!_!# '\nfor ac_last_try in false false false false false :; do\n  . ./conf$$subs.sh ||\n    as_fn_error $? \"could not make $CONFIG_STATUS\" \"$LINENO\" 5\n\n  ac_delim_n=`sed -n \"s/.*$ac_delim\\$/X/p\" conf$$subs.awk | grep -c X`\n  if test $ac_delim_n = $ac_delim_num; then\n    break\n  elif $ac_last_try; then\n    as_fn_error $? \"could not make $CONFIG_STATUS\" \"$LINENO\" 5\n  else\n    ac_delim=\"$ac_delim!$ac_delim _$ac_delim!! \"\n  fi\ndone\nrm -f conf$$subs.sh\n\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\ncat >>\"\\$ac_tmp/subs1.awk\" <<\\\\_ACAWK &&\n_ACEOF\nsed -n '\nh\ns/^/S[\"/; s/!.*/\"]=/\np\ng\ns/^[^!]*!//\n:repl\nt repl\ns/'\"$ac_delim\"'$//\nt delim\n:nl\nh\ns/\\(.\\{148\\}\\)..*/\\1/\nt more1\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\\\\n\"\\\\/\np\nn\nb repl\n:more1\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"\\\\/\np\ng\ns/.\\{148\\}//\nt nl\n:delim\nh\ns/\\(.\\{148\\}\\)..*/\\1/\nt more2\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"/\np\nb\n:more2\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"\\\\/\np\ng\ns/.\\{148\\}//\nt delim\n' <conf$$subs.awk | sed '\n/^[^\"\"]/{\n  N\n  s/\\n//\n}\n' >>$CONFIG_STATUS || ac_write_fail=1\nrm -f conf$$subs.awk\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n_ACAWK\ncat >>\"\\$ac_tmp/subs1.awk\" <<_ACAWK &&\n  for (key in S) S_is_set[key] = 1\n  FS = \"\u0007\"\n\n}\n{\n  line = $ 0\n  nfields = split(line, field, \"@\")\n  substed = 0\n  len = length(field[1])\n  for (i = 2; i < nfields; i++) {\n    key = field[i]\n    keylen = length(key)\n    if (S_is_set[key]) {\n      value = S[key]\n      line = substr(line, 1, len) \"\" value \"\" substr(line, len + keylen + 3)\n      len += length(value) + length(field[++i])\n      substed = 1\n    } else\n      len += 1 + keylen\n  }\n\n  print line\n}\n\n_ACAWK\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nif sed \"s/$ac_cr//\" < /dev/null > /dev/null 2>&1; then\n  sed \"s/$ac_cr\\$//; s/$ac_cr/$ac_cs_awk_cr/g\"\nelse\n  cat\nfi < \"$ac_tmp/subs1.awk\" > \"$ac_tmp/subs.awk\" \\\n  || as_fn_error $? \"could not setup config files machinery\" \"$LINENO\" 5\n_ACEOF\n\n# VPATH may cause trouble with some makes, so we remove sole $(srcdir),\n# ${srcdir} and @srcdir@ entries from VPATH if srcdir is \".\", strip leading and\n# trailing colons and then remove the whole line if VPATH becomes empty\n# (actually we leave an empty line to preserve line numbers).\nif test \"x$srcdir\" = x.; then\n  ac_vpsub='/^[\t ]*VPATH[\t ]*=[\t ]*/{\nh\ns///\ns/^/:/\ns/[\t ]*$/:/\ns/:\\$(srcdir):/:/g\ns/:\\${srcdir}:/:/g\ns/:@srcdir@:/:/g\ns/^:*//\ns/:*$//\nx\ns/\\(=[\t ]*\\).*/\\1/\nG\ns/\\n//\ns/^[^=]*=[\t ]*$//\n}'\nfi\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nfi # test -n \"$CONFIG_FILES\"\n\n# Set up the scripts for CONFIG_HEADERS section.\n# No need to generate them if there are no CONFIG_HEADERS.\n# This happens for instance with `./config.status Makefile'.\nif test -n \"$CONFIG_HEADERS\"; then\ncat >\"$ac_tmp/defines.awk\" <<\\_ACAWK ||\nBEGIN {\n_ACEOF\n\n# Transform confdefs.h into an awk script `defines.awk', embedded as\n# here-document in config.status, that substitutes the proper values into\n# config.h.in to produce config.h.\n\n# Create a delimiter string that does not exist in confdefs.h, to ease\n# handling of long lines.\nac_delim='%!_!# '\nfor ac_last_try in false false :; do\n  ac_tt=`sed -n \"/$ac_delim/p\" confdefs.h`\n  if test -z \"$ac_tt\"; then\n    break\n  elif $ac_last_try; then\n    as_fn_error $? \"could not make $CONFIG_HEADERS\" \"$LINENO\" 5\n  else\n    ac_delim=\"$ac_delim!$ac_delim _$ac_delim!! \"\n  fi\ndone\n\n# For the awk script, D is an array of macro values keyed by name,\n# likewise P contains macro parameters if any.  Preserve backslash\n# newline sequences.\n\nac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*\nsed -n '\ns/.\\{148\\}/&'\"$ac_delim\"'/g\nt rset\n:rset\ns/^[\t ]*#[\t ]*define[\t ][\t ]*/ /\nt def\nd\n:def\ns/\\\\$//\nt bsnl\ns/[\"\\\\]/\\\\&/g\ns/^ \\('\"$ac_word_re\"'\\)\\(([^()]*)\\)[\t ]*\\(.*\\)/P[\"\\1\"]=\"\\2\"\\\nD[\"\\1\"]=\" \\3\"/p\ns/^ \\('\"$ac_word_re\"'\\)[\t ]*\\(.*\\)/D[\"\\1\"]=\" \\2\"/p\nd\n:bsnl\ns/[\"\\\\]/\\\\&/g\ns/^ \\('\"$ac_word_re\"'\\)\\(([^()]*)\\)[\t ]*\\(.*\\)/P[\"\\1\"]=\"\\2\"\\\nD[\"\\1\"]=\" \\3\\\\\\\\\\\\n\"\\\\/p\nt cont\ns/^ \\('\"$ac_word_re\"'\\)[\t ]*\\(.*\\)/D[\"\\1\"]=\" \\2\\\\\\\\\\\\n\"\\\\/p\nt cont\nd\n:cont\nn\ns/.\\{148\\}/&'\"$ac_delim\"'/g\nt clear\n:clear\ns/\\\\$//\nt bsnlc\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"/p\nd\n:bsnlc\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\\\\\\\\\\\\n\"\\\\/p\nb cont\n' <confdefs.h | sed '\ns/'\"$ac_delim\"'/\"\\\\\\\n\"/g' >>$CONFIG_STATUS || ac_write_fail=1\n\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n  for (key in D) D_is_set[key] = 1\n  FS = \"\u0007\"\n}\n/^[\\t ]*#[\\t ]*(define|undef)[\\t ]+$ac_word_re([\\t (]|\\$)/ {\n  line = \\$ 0\n  split(line, arg, \" \")\n  if (arg[1] == \"#\") {\n    defundef = arg[2]\n    mac1 = arg[3]\n  } else {\n    defundef = substr(arg[1], 2)\n    mac1 = arg[2]\n  }\n  split(mac1, mac2, \"(\") #)\n  macro = mac2[1]\n  prefix = substr(line, 1, index(line, defundef) - 1)\n  if (D_is_set[macro]) {\n    # Preserve the white space surrounding the \"#\".\n    print prefix \"define\", macro P[macro] D[macro]\n    next\n  } else {\n    # Replace #undef with comments.  This is necessary, for example,\n    # in the case of _POSIX_SOURCE, which is predefined and required\n    # on some systems where configure will not decide to define it.\n    if (defundef == \"undef\") {\n      print \"/*\", prefix defundef, macro, \"*/\"\n      next\n    }\n  }\n}\n{ print }\n_ACAWK\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n  as_fn_error $? \"could not setup config headers machinery\" \"$LINENO\" 5\nfi # test -n \"$CONFIG_HEADERS\"\n\n\neval set X \"  :F $CONFIG_FILES  :H $CONFIG_HEADERS    \"\nshift\nfor ac_tag\ndo\n  case $ac_tag in\n  :[FHLC]) ac_mode=$ac_tag; continue;;\n  esac\n  case $ac_mode$ac_tag in\n  :[FHL]*:*);;\n  :L* | :C*:*) as_fn_error $? \"invalid tag \\`$ac_tag'\" \"$LINENO\" 5;;\n  :[FH]-) ac_tag=-:-;;\n  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;\n  esac\n  ac_save_IFS=$IFS\n  IFS=:\n  set x $ac_tag\n  IFS=$ac_save_IFS\n  shift\n  ac_file=$1\n  shift\n\n  case $ac_mode in\n  :L) ac_source=$1;;\n  :[FH])\n    ac_file_inputs=\n    for ac_f\n    do\n      case $ac_f in\n      -) ac_f=\"$ac_tmp/stdin\";;\n      *) # Look for the file first in the build tree, then in the source tree\n\t # (if the path is not absolute).  The absolute path cannot be DOS-style,\n\t # because $ac_f cannot contain `:'.\n\t test -f \"$ac_f\" ||\n\t   case $ac_f in\n\t   [\\\\/$]*) false;;\n\t   *) test -f \"$srcdir/$ac_f\" && ac_f=\"$srcdir/$ac_f\";;\n\t   esac ||\n\t   as_fn_error 1 \"cannot find input file: \\`$ac_f'\" \"$LINENO\" 5;;\n      esac\n      case $ac_f in *\\'*) ac_f=`$as_echo \"$ac_f\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;; esac\n      as_fn_append ac_file_inputs \" '$ac_f'\"\n    done\n\n    # Let's still pretend it is `configure' which instantiates (i.e., don't\n    # use $as_me), people would be surprised to read:\n    #    /* config.h.  Generated by config.status.  */\n    configure_input='Generated from '`\n\t  $as_echo \"$*\" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'\n\t`' by configure.'\n    if test x\"$ac_file\" != x-; then\n      configure_input=\"$ac_file.  $configure_input\"\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: creating $ac_file\" >&5\n$as_echo \"$as_me: creating $ac_file\" >&6;}\n    fi\n    # Neutralize special characters interpreted by sed in replacement strings.\n    case $configure_input in #(\n    *\\&* | *\\|* | *\\\\* )\n       ac_sed_conf_input=`$as_echo \"$configure_input\" |\n       sed 's/[\\\\\\\\&|]/\\\\\\\\&/g'`;; #(\n    *) ac_sed_conf_input=$configure_input;;\n    esac\n\n    case $ac_tag in\n    *:-:* | *:-) cat >\"$ac_tmp/stdin\" \\\n      || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5 ;;\n    esac\n    ;;\n  esac\n\n  ac_dir=`$as_dirname -- \"$ac_file\" ||\n$as_expr X\"$ac_file\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$ac_file\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$ac_file\" : 'X\\(//\\)$' \\| \\\n\t X\"$ac_file\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n$as_echo X\"$ac_file\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n  as_dir=\"$ac_dir\"; as_fn_mkdir_p\n  ac_builddir=.\n\ncase \"$ac_dir\" in\n.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;\n*)\n  ac_dir_suffix=/`$as_echo \"$ac_dir\" | sed 's|^\\.[\\\\/]||'`\n  # A \"..\" for each directory in $ac_dir_suffix.\n  ac_top_builddir_sub=`$as_echo \"$ac_dir_suffix\" | sed 's|/[^\\\\/]*|/..|g;s|/||'`\n  case $ac_top_builddir_sub in\n  \"\") ac_top_builddir_sub=. ac_top_build_prefix= ;;\n  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;\n  esac ;;\nesac\nac_abs_top_builddir=$ac_pwd\nac_abs_builddir=$ac_pwd$ac_dir_suffix\n# for backward compatibility:\nac_top_builddir=$ac_top_build_prefix\n\ncase $srcdir in\n  .)  # We are building in place.\n    ac_srcdir=.\n    ac_top_srcdir=$ac_top_builddir_sub\n    ac_abs_top_srcdir=$ac_pwd ;;\n  [\\\\/]* | ?:[\\\\/]* )  # Absolute name.\n    ac_srcdir=$srcdir$ac_dir_suffix;\n    ac_top_srcdir=$srcdir\n    ac_abs_top_srcdir=$srcdir ;;\n  *) # Relative name.\n    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix\n    ac_top_srcdir=$ac_top_build_prefix$srcdir\n    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;\nesac\nac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix\n\n\n  case $ac_mode in\n  :F)\n  #\n  # CONFIG_FILE\n  #\n\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n# If the template does not know about datarootdir, expand it.\n# FIXME: This hack should be removed a few years after 2.60.\nac_datarootdir_hack=; ac_datarootdir_seen=\nac_sed_dataroot='\n/datarootdir/ {\n  p\n  q\n}\n/@datadir@/p\n/@docdir@/p\n/@infodir@/p\n/@localedir@/p\n/@mandir@/p'\ncase `eval \"sed -n \\\"\\$ac_sed_dataroot\\\" $ac_file_inputs\"` in\n*datarootdir*) ac_datarootdir_seen=yes;;\n*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting\" >&5\n$as_echo \"$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting\" >&2;}\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n  ac_datarootdir_hack='\n  s&@datadir@&$datadir&g\n  s&@docdir@&$docdir&g\n  s&@infodir@&$infodir&g\n  s&@localedir@&$localedir&g\n  s&@mandir@&$mandir&g\n  s&\\\\\\${datarootdir}&$datarootdir&g' ;;\nesac\n_ACEOF\n\n# Neutralize VPATH when `$srcdir' = `.'.\n# Shell code in configure.ac might set extrasub.\n# FIXME: do we really want to maintain this feature?\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\nac_sed_extra=\"$ac_vpsub\n$extrasub\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n:t\n/@[a-zA-Z_][a-zA-Z_0-9]*@/!b\ns|@configure_input@|$ac_sed_conf_input|;t t\ns&@top_builddir@&$ac_top_builddir_sub&;t t\ns&@top_build_prefix@&$ac_top_build_prefix&;t t\ns&@srcdir@&$ac_srcdir&;t t\ns&@abs_srcdir@&$ac_abs_srcdir&;t t\ns&@top_srcdir@&$ac_top_srcdir&;t t\ns&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t\ns&@builddir@&$ac_builddir&;t t\ns&@abs_builddir@&$ac_abs_builddir&;t t\ns&@abs_top_builddir@&$ac_abs_top_builddir&;t t\n$ac_datarootdir_hack\n\"\neval sed \\\"\\$ac_sed_extra\\\" \"$ac_file_inputs\" | $AWK -f \"$ac_tmp/subs.awk\" \\\n  >$ac_tmp/out || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n\ntest -z \"$ac_datarootdir_hack$ac_datarootdir_seen\" &&\n  { ac_out=`sed -n '/\\${datarootdir}/p' \"$ac_tmp/out\"`; test -n \"$ac_out\"; } &&\n  { ac_out=`sed -n '/^[\t ]*datarootdir[\t ]*:*=/p' \\\n      \"$ac_tmp/out\"`; test -z \"$ac_out\"; } &&\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \\`datarootdir'\nwhich seems to be undefined.  Please make sure it is defined\" >&5\n$as_echo \"$as_me: WARNING: $ac_file contains a reference to the variable \\`datarootdir'\nwhich seems to be undefined.  Please make sure it is defined\" >&2;}\n\n  rm -f \"$ac_tmp/stdin\"\n  case $ac_file in\n  -) cat \"$ac_tmp/out\" && rm -f \"$ac_tmp/out\";;\n  *) rm -f \"$ac_file\" && mv \"$ac_tmp/out\" \"$ac_file\";;\n  esac \\\n  || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n ;;\n  :H)\n  #\n  # CONFIG_HEADER\n  #\n  if test x\"$ac_file\" != x-; then\n    {\n      $as_echo \"/* $configure_input  */\" \\\n      && eval '$AWK -f \"$ac_tmp/defines.awk\"' \"$ac_file_inputs\"\n    } >\"$ac_tmp/config.h\" \\\n      || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n    if diff \"$ac_file\" \"$ac_tmp/config.h\" >/dev/null 2>&1; then\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: $ac_file is unchanged\" >&5\n$as_echo \"$as_me: $ac_file is unchanged\" >&6;}\n    else\n      rm -f \"$ac_file\"\n      mv \"$ac_tmp/config.h\" \"$ac_file\" \\\n\t|| as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n    fi\n  else\n    $as_echo \"/* $configure_input  */\" \\\n      && eval '$AWK -f \"$ac_tmp/defines.awk\"' \"$ac_file_inputs\" \\\n      || as_fn_error $? \"could not create -\" \"$LINENO\" 5\n  fi\n ;;\n\n\n  esac\n\ndone # for ac_tag\n\n\nas_fn_exit 0\n_ACEOF\nac_clean_files=$ac_clean_files_save\n\ntest $ac_write_fail = 0 ||\n  as_fn_error $? \"write failure creating $CONFIG_STATUS\" \"$LINENO\" 5\n\n\n# configure is writing to config.log, and then calls config.status.\n# config.status does its own redirection, appending to config.log.\n# Unfortunately, on DOS this fails, as config.log is still kept open\n# by configure, so config.status won't be able to write to it; its\n# output is simply discarded.  So we exec the FD to /dev/null,\n# effectively closing config.log, so it can be properly (re)opened and\n# appended to by config.status.  When coming back to configure, we\n# need to make the FD available again.\nif test \"$no_create\" != yes; then\n  ac_cs_success=:\n  ac_config_status_args=\n  test \"$silent\" = yes &&\n    ac_config_status_args=\"$ac_config_status_args --quiet\"\n  exec 5>/dev/null\n  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false\n  exec 5>>config.log\n  # Use ||, not &&, to avoid exiting from the if with $? = 1, which\n  # would make configure fail if this is the last instruction.\n  $ac_cs_success || as_fn_exit 1\nfi\nif test -n \"$ac_unrecognized_opts\" && test \"$enable_option_checking\" != no; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts\" >&5\n$as_echo \"$as_me: WARNING: unrecognized options: $ac_unrecognized_opts\" >&2;}\nfi\n\n\n"
        },
        {
          "name": "configure.in",
          "type": "blob",
          "size": 2.7685546875,
          "content": "AC_INIT([repmgr], [5.5.0], [repmgr@googlegroups.com], [repmgr], [https://repmgr.org/])\n\nAC_COPYRIGHT([Copyright (c) 2010-2024, EnterpriseDB Corporation])\n\nAC_CONFIG_HEADER(config.h)\n\nAC_ARG_VAR([PG_CONFIG], [Location to find pg_config for target PostgreSQL (default PATH)])\n\nAC_PROG_SED\n\nif test -z \"$PG_CONFIG\"; then\n  AC_PATH_PROG(PG_CONFIG, pg_config)\nfi\n\nif test -z \"$PG_CONFIG\"; then\n   AC_MSG_ERROR([could not find pg_config, set PG_CONFIG or PATH])\nfi\n\npgac_pg_config_version=$($PG_CONFIG --version 2>/dev/null)\n\nmajor_version_num=$(echo \"$pgac_pg_config_version\"|\n              $SED -e 's/^[[^0-9]]\\+ \\([[0-9]]\\{1,2\\}\\).*$/\\1/')\n\nif test \"$major_version_num\" -lt '10'; then\n    version_num=$(echo \"$pgac_pg_config_version\"|\n                $SED -e 's/^[[^0-9]]\\+ \\([[0-9]]*\\)\\.\\([[0-9]]*\\)\\([[a-zA-Z0-9.]]*\\)$/\\1.\\2/')\n\n    if test -z \"$version_num\"; then\n        AC_MSG_ERROR([could not detect the PostgreSQL version, wrong or broken pg_config?])\n    fi\n\n    version_num_int=$(echo \"$version_num\"|\n                    $SED -e 's/^\\([[0-9]]*\\)\\.\\([[0-9]]*\\)$/\\1\\2/')\n\n    if test \"$version_num_int\" -lt '94'; then\n        AC_MSG_ERROR([repmgr is not compatible with detected PostgreSQL version: $version_num])\n    fi\nelse\n    version_num=$(echo \"$pgac_pg_config_version\"|\n                $SED -e 's/^[[^0-9]]\\+ \\(.\\+\\)$/\\1/')\n\n    if test -z \"$version_num\"; then\n        AC_MSG_ERROR([could not detect the PostgreSQL version, wrong or broken pg_config?])\n    fi\nfi\n\nAC_MSG_NOTICE([building against PostgreSQL $version_num])\n\n# add includedir to prerequisites, so tests for headers can succeed\nCPPFLAGS=\"-I$($PG_CONFIG --includedir-server) $CFLAGS\"\n\n# check whether we're building inside the source tree.\nif test \"$srcdir\" -ef '.' ; then\n  vpath_build=no\nelse\n  vpath_build=yes\nfi\nAC_SUBST(vpath_build)\n\nAC_CHECK_PROG(HAVE_GNUSED,gnused,yes,no)\nAC_CHECK_PROG(HAVE_GSED,gsed,yes,no)\nAC_CHECK_PROG(HAVE_SED,sed,yes,no)\nAC_CHECK_PROG(HAVE_FLEX,flex,yes,no)\n\nif test \"$HAVE_GNUSED\" = yes; then\n SED=gnused\nelse\n if test \"$HAVE_GSED\" = yes; then\n  SED=gsed\n else\n  SED=sed\n fi\nfi\nAC_SUBST(SED)\n\nAS_IF([test x\"$HAVE_FLEX\" != x\"yes\"], AC_MSG_ERROR([flex should be installed first]))\n\n#Checking libraries\nGENERIC_LIB_FAILED_MSG=\"library should be installed\"\n\nAC_CHECK_LIB(selinux, is_selinux_enabled, [],\n     [AC_MSG_ERROR(['selinux' $GENERIC_LIB_FAILED_MSG])])\n\nAC_CHECK_LIB(lz4, LZ4_compress_default, [],\n     [AC_MSG_ERROR(['Z4' $GENERIC_LIB_FAILED_MSG])])\n\nAC_CHECK_LIB(xslt, xsltCleanupGlobals, [],\n     [AC_MSG_ERROR(['xslt' $GENERIC_LIB_FAILED_MSG])])\n\nAC_CHECK_LIB(pam, pam_start, [],\n     [AC_MSG_ERROR(['pam' $GENERIC_LIB_FAILED_MSG])])\n\nAC_CHECK_LIB(gssapi_krb5, gss_init_sec_context, [],\n     [AC_MSG_ERROR([gssapi_krb5 $GENERIC_LIB_FAILED_MSG])])\n\nAC_CONFIG_FILES([Makefile])\nAC_CONFIG_FILES([Makefile.global])\nAC_OUTPUT\n\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "controldata.c",
          "type": "blob",
          "size": 10.490234375,
          "content": "/*\n * controldata.c - functions for reading the pg_control file\n *\n * The functions provided here enable repmgr to read a pg_control file\n * in a version-independent way, even if the PostgreSQL instance is not\n * running. For that reason we can't use on the pg_control_*() functions\n * provided in PostgreSQL 9.6 and later.\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * Portions Copyright (c) 1996-2016, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#include \"postgres_fe.h\"\n\n#include \"repmgr.h\"\n#include \"controldata.h\"\n\nstatic ControlFileInfo *get_controlfile(const char *DataDir);\n\nint\nget_pg_version(const char *data_directory, char *version_string)\n{\n\tchar\t\tPgVersionPath[MAXPGPATH] = \"\";\n\tFILE\t   *fp = NULL;\n\tchar\t   *endptr = NULL;\n\tchar\t\tfile_version_string[MAX_VERSION_STRING] = \"\";\n\tlong\t\tfile_major, file_minor;\n\tint\t\t\tret;\n\n\tsnprintf(PgVersionPath, MAXPGPATH, \"%s/PG_VERSION\", data_directory);\n\n\tfp = fopen(PgVersionPath, \"r\");\n\n\tif (fp == NULL)\n\t{\n\t\tlog_warning(_(\"could not open file \\\"%s\\\" for reading\"),\n\t\t\t\t\tPgVersionPath);\n\t\tlog_detail(\"%s\", strerror(errno));\n\t\treturn UNKNOWN_SERVER_VERSION_NUM;\n\t}\n\n\tfile_version_string[0] = '\\0';\n\n\tret = fscanf(fp, \"%23s\", file_version_string);\n\tfclose(fp);\n\n\tif (ret != 1 || endptr == file_version_string)\n\t{\n\t\tlog_warning(_(\"unable to determine major version number from PG_VERSION\"));\n\n\t\treturn UNKNOWN_SERVER_VERSION_NUM;\n\t}\n\n\tfile_major = strtol(file_version_string, &endptr, 10);\n\tfile_minor = 0;\n\n\tif (*endptr == '.')\n\t\tfile_minor = strtol(endptr + 1, NULL, 10);\n\n\tif (version_string != NULL)\n\t\tstrncpy(version_string, file_version_string, MAX_VERSION_STRING);\n\n\treturn ((int) file_major * 10000) + ((int) file_minor * 100);\n}\n\n\nuint64\nget_system_identifier(const char *data_directory)\n{\n\tControlFileInfo *control_file_info = NULL;\n\tuint64\t\tsystem_identifier = UNKNOWN_SYSTEM_IDENTIFIER;\n\n\tcontrol_file_info = get_controlfile(data_directory);\n\n\tif (control_file_info->control_file_processed == true)\n\t\tsystem_identifier = control_file_info->system_identifier;\n\n\tpfree(control_file_info);\n\n\treturn system_identifier;\n}\n\n\nbool\nget_db_state(const char *data_directory, DBState *state)\n{\n\tControlFileInfo *control_file_info = NULL;\n\tbool control_file_processed;\n\n\tcontrol_file_info = get_controlfile(data_directory);\n\tcontrol_file_processed = control_file_info->control_file_processed;\n\n\tif (control_file_processed == true)\n\t\t*state = control_file_info->state;\n\n\tpfree(control_file_info);\n\n\treturn control_file_processed;\n}\n\n\nXLogRecPtr\nget_latest_checkpoint_location(const char *data_directory)\n{\n\tControlFileInfo *control_file_info = NULL;\n\tXLogRecPtr\tcheckPoint = InvalidXLogRecPtr;\n\n\tcontrol_file_info = get_controlfile(data_directory);\n\n\tif (control_file_info->control_file_processed == true)\n\t\tcheckPoint = control_file_info->checkPoint;\n\n\tpfree(control_file_info);\n\n\treturn checkPoint;\n}\n\n\nint\nget_data_checksum_version(const char *data_directory)\n{\n\tControlFileInfo *control_file_info = NULL;\n\tint\t\t\tdata_checksum_version = UNKNOWN_DATA_CHECKSUM_VERSION;\n\n\tcontrol_file_info = get_controlfile(data_directory);\n\n\tif (control_file_info->control_file_processed == true)\n\t\tdata_checksum_version = (int) control_file_info->data_checksum_version;\n\n\tpfree(control_file_info);\n\n\treturn data_checksum_version;\n}\n\n\nconst char *\ndescribe_db_state(DBState state)\n{\n\tswitch (state)\n\t{\n\t\tcase DB_STARTUP:\n\t\t\treturn _(\"starting up\");\n\t\tcase DB_SHUTDOWNED:\n\t\t\treturn _(\"shut down\");\n\t\tcase DB_SHUTDOWNED_IN_RECOVERY:\n\t\t\treturn _(\"shut down in recovery\");\n\t\tcase DB_SHUTDOWNING:\n\t\t\treturn _(\"shutting down\");\n\t\tcase DB_IN_CRASH_RECOVERY:\n\t\t\treturn _(\"in crash recovery\");\n\t\tcase DB_IN_ARCHIVE_RECOVERY:\n\t\t\treturn _(\"in archive recovery\");\n\t\tcase DB_IN_PRODUCTION:\n\t\t\treturn _(\"in production\");\n\t}\n\n\treturn _(\"unrecognized status code\");\n}\n\n\nTimeLineID\nget_timeline(const char *data_directory)\n{\n\tControlFileInfo *control_file_info = NULL;\n\tTimeLineID\t\t timeline = -1;\n\n\tcontrol_file_info = get_controlfile(data_directory);\n\n\ttimeline = (int) control_file_info->timeline;\n\n\tpfree(control_file_info);\n\n\treturn timeline;\n}\n\n\nTimeLineID\nget_min_recovery_end_timeline(const char *data_directory)\n{\n\tControlFileInfo *control_file_info = NULL;\n\tTimeLineID\t\t timeline = -1;\n\n\tcontrol_file_info = get_controlfile(data_directory);\n\n\ttimeline = (int) control_file_info->minRecoveryPointTLI;\n\n\tpfree(control_file_info);\n\n\treturn timeline;\n}\n\n\nXLogRecPtr\nget_min_recovery_location(const char *data_directory)\n{\n\tControlFileInfo *control_file_info = NULL;\n\tXLogRecPtr\tminRecoveryPoint  = InvalidXLogRecPtr;\n\n\tcontrol_file_info = get_controlfile(data_directory);\n\n\tminRecoveryPoint = control_file_info->minRecoveryPoint;\n\n\tpfree(control_file_info);\n\n\treturn minRecoveryPoint;\n}\n\n\n/*\n * We maintain our own version of get_controlfile() as we need cross-version\n * compatibility, and also don't care if the file isn't readable.\n */\nstatic ControlFileInfo *\nget_controlfile(const char *DataDir)\n{\n\tchar\t\tfile_version_string[MAX_VERSION_STRING] = \"\";\n\tControlFileInfo *control_file_info;\n\tint\t\t\tfd, version_num;\n\tchar\t\tControlFilePath[MAXPGPATH] = \"\";\n\tvoid\t   *ControlFileDataPtr = NULL;\n\tint\t\t\texpected_size = 0;\n\n\tcontrol_file_info = palloc0(sizeof(ControlFileInfo));\n\n\t/* set default values */\n\tcontrol_file_info->control_file_processed = false;\n\tcontrol_file_info->system_identifier = UNKNOWN_SYSTEM_IDENTIFIER;\n\tcontrol_file_info->state = DB_SHUTDOWNED;\n\tcontrol_file_info->checkPoint = InvalidXLogRecPtr;\n\tcontrol_file_info->data_checksum_version = -1;\n\tcontrol_file_info->timeline = -1;\n\tcontrol_file_info->minRecoveryPointTLI = -1;\n\tcontrol_file_info->minRecoveryPoint = InvalidXLogRecPtr;\n\n\t/*\n\t * Read PG_VERSION, as we'll need to determine which struct to read\n\t * the control file contents into\n\t */\n\n\tversion_num = get_pg_version(DataDir, file_version_string);\n\n\tif (version_num == UNKNOWN_SERVER_VERSION_NUM)\n\t{\n\t\tlog_warning(_(\"unable to determine server version number from PG_VERSION\"));\n\t\treturn control_file_info;\n\t}\n\n\tif (version_num < MIN_SUPPORTED_VERSION_NUM)\n\t{\n\t\tlog_warning(_(\"data directory appears to be initialised for %s\"),\n\t\t\t\t\tfile_version_string);\n\t\tlog_detail(_(\"minimum supported PostgreSQL version is %s\"),\n\t\t\t\t   MIN_SUPPORTED_VERSION);\n\t\treturn control_file_info;\n\t}\n\n\tsnprintf(ControlFilePath, MAXPGPATH, \"%s/global/pg_control\", DataDir);\n\n\tif ((fd = open(ControlFilePath, O_RDONLY | PG_BINARY, 0)) == -1)\n\t{\n\t\tlog_warning(_(\"could not open file \\\"%s\\\" for reading\"),\n\t\t\t\t\tControlFilePath);\n\t\tlog_detail(\"%s\", strerror(errno));\n\t\treturn control_file_info;\n\t}\n\n\tif (version_num >= 120000)\n\t{\n#if PG_ACTUAL_VERSION_NUM >= 120000\n\t\texpected_size = sizeof(ControlFileData12);\n\t\tControlFileDataPtr = palloc0(expected_size);\n#endif\n\t}\n\telse if (version_num >= 110000)\n\t{\n\t\texpected_size = sizeof(ControlFileData11);\n\t\tControlFileDataPtr = palloc0(expected_size);\n\t}\n\telse if (version_num >= 90500)\n\t{\n\t\texpected_size = sizeof(ControlFileData95);\n\t\tControlFileDataPtr = palloc0(expected_size);\n\t}\n\telse if (version_num >= 90400)\n\t{\n\t\texpected_size = sizeof(ControlFileData94);\n\t\tControlFileDataPtr = palloc0(expected_size);\n\t}\n\n\tif (read(fd, ControlFileDataPtr, expected_size) != expected_size)\n\t{\n\t\tlog_warning(_(\"could not read file \\\"%s\\\"\"),\n\t\t\t\t\tControlFilePath);\n\t\tlog_detail(\"%s\", strerror(errno));\n\n\t\tclose(fd);\n\n\t\treturn control_file_info;\n\t}\n\n\tclose(fd);\n\n\tcontrol_file_info->control_file_processed = true;\n\n\tif (version_num >= 120000)\n\t{\n#if PG_ACTUAL_VERSION_NUM >= 120000\n\t\tControlFileData12 *ptr = (struct ControlFileData12 *)ControlFileDataPtr;\n\t\tcontrol_file_info->system_identifier = ptr->system_identifier;\n\t\tcontrol_file_info->state = ptr->state;\n\t\tcontrol_file_info->checkPoint = ptr->checkPoint;\n\t\tcontrol_file_info->data_checksum_version = ptr->data_checksum_version;\n\t\tcontrol_file_info->timeline = ptr->checkPointCopy.ThisTimeLineID;\n\t\tcontrol_file_info->minRecoveryPointTLI = ptr->minRecoveryPointTLI;\n\t\tcontrol_file_info->minRecoveryPoint = ptr->minRecoveryPoint;\n#else\n\t\tfprintf(stderr, \"ERROR: please use a repmgr version built for PostgreSQL 12 or later\\n\");\n\t\texit(ERR_BAD_CONFIG);\n#endif\n\t}\n\telse if (version_num >= 110000)\n\t{\n\t\tControlFileData11 *ptr = (struct ControlFileData11 *)ControlFileDataPtr;\n\t\tcontrol_file_info->system_identifier = ptr->system_identifier;\n\t\tcontrol_file_info->state = ptr->state;\n\t\tcontrol_file_info->checkPoint = ptr->checkPoint;\n\t\tcontrol_file_info->data_checksum_version = ptr->data_checksum_version;\n\t\tcontrol_file_info->timeline = ptr->checkPointCopy.ThisTimeLineID;\n\t\tcontrol_file_info->minRecoveryPointTLI = ptr->minRecoveryPointTLI;\n\t\tcontrol_file_info->minRecoveryPoint = ptr->minRecoveryPoint;\n\t}\n\telse if (version_num >= 90500)\n\t{\n\t\tControlFileData95 *ptr = (struct ControlFileData95 *)ControlFileDataPtr;\n\t\tcontrol_file_info->system_identifier = ptr->system_identifier;\n\t\tcontrol_file_info->state = ptr->state;\n\t\tcontrol_file_info->checkPoint = ptr->checkPoint;\n\t\tcontrol_file_info->data_checksum_version = ptr->data_checksum_version;\n\t\tcontrol_file_info->timeline = ptr->checkPointCopy.ThisTimeLineID;\n\t\tcontrol_file_info->minRecoveryPointTLI = ptr->minRecoveryPointTLI;\n\t\tcontrol_file_info->minRecoveryPoint = ptr->minRecoveryPoint;\n\t}\n\telse if (version_num >= 90400)\n\t{\n\t\tControlFileData94 *ptr = (struct ControlFileData94 *)ControlFileDataPtr;\n\t\tcontrol_file_info->system_identifier = ptr->system_identifier;\n\t\tcontrol_file_info->state = ptr->state;\n\t\tcontrol_file_info->checkPoint = ptr->checkPoint;\n\t\tcontrol_file_info->data_checksum_version = ptr->data_checksum_version;\n\t\tcontrol_file_info->timeline = ptr->checkPointCopy.ThisTimeLineID;\n\t\tcontrol_file_info->minRecoveryPointTLI = ptr->minRecoveryPointTLI;\n\t\tcontrol_file_info->minRecoveryPoint = ptr->minRecoveryPoint;\n\t}\n\n\tpfree(ControlFileDataPtr);\n\n\t/*\n\t * We don't check the CRC here as we're potentially checking a pg_control\n\t * file from a different PostgreSQL version to the one repmgr was compiled\n\t * against.\n\t */\n\n\treturn control_file_info;\n}\n"
        },
        {
          "name": "controldata.h",
          "type": "blob",
          "size": 12.0693359375,
          "content": "/*\n * controldata.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * Portions Copyright (c) 1996-2016, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n */\n\n#ifndef _CONTROLDATA_H_\n#define _CONTROLDATA_H_\n\n#include \"postgres_fe.h\"\n#include \"catalog/pg_control.h\"\n\n\n#define MAX_VERSION_STRING 24\n/*\n * A simplified representation of pg_control containing only those fields\n * required by repmgr.\n */\ntypedef struct\n{\n\tbool\t\tcontrol_file_processed;\n\tuint64\t\tsystem_identifier;\n\tDBState\t\tstate;\n\tXLogRecPtr\tcheckPoint;\n\tuint32\t\tdata_checksum_version;\n\tTimeLineID\ttimeline;\n\tTimeLineID\tminRecoveryPointTLI;\n\tXLogRecPtr\tminRecoveryPoint;\n} ControlFileInfo;\n\n\ntypedef struct CheckPoint94\n{\n\tXLogRecPtr\tredo;\t\t\t/* next RecPtr available when we began to\n\t\t\t\t\t\t\t\t * create CheckPoint (i.e. REDO start point) */\n\tTimeLineID\tThisTimeLineID; /* current TLI */\n\tTimeLineID\tPrevTimeLineID; /* previous TLI, if this record begins a new\n\t\t\t\t\t\t\t\t * timeline (equals ThisTimeLineID otherwise) */\n\tbool\t\tfullPageWrites; /* current full_page_writes */\n\tuint32\t\tnextXidEpoch;\t/* higher-order bits of nextXid */\n\tTransactionId nextXid;\t\t/* next free XID */\n\tOid\t\t\tnextOid;\t\t/* next free OID */\n\tMultiXactId nextMulti;\t\t/* next free MultiXactId */\n\tMultiXactOffset nextMultiOffset;\t/* next free MultiXact offset */\n\tTransactionId oldestXid;\t/* cluster-wide minimum datfrozenxid */\n\tOid\t\t\toldestXidDB;\t/* database with minimum datfrozenxid */\n\tMultiXactId oldestMulti;\t/* cluster-wide minimum datminmxid */\n\tOid\t\t\toldestMultiDB;\t/* database with minimum datminmxid */\n\tpg_time_t\ttime;\t\t\t/* time stamp of checkpoint */\n\n\tTransactionId oldestActiveXid;\n} CheckPoint94;\n\n\n/* Same for 9.5, 9.6, 10, 11 */\ntypedef struct CheckPoint95\n{\n\tXLogRecPtr\tredo;\t\t\t/* next RecPtr available when we began to\n\t\t\t\t\t\t\t\t * create CheckPoint (i.e. REDO start point) */\n\tTimeLineID\tThisTimeLineID; /* current TLI */\n\tTimeLineID\tPrevTimeLineID; /* previous TLI, if this record begins a new\n\t\t\t\t\t\t\t\t * timeline (equals ThisTimeLineID otherwise) */\n\tbool\t\tfullPageWrites; /* current full_page_writes */\n\tuint32\t\tnextXidEpoch;\t/* higher-order bits of nextXid */\n\tTransactionId nextXid;\t\t/* next free XID */\n\tOid\t\t\tnextOid;\t\t/* next free OID */\n\tMultiXactId nextMulti;\t\t/* next free MultiXactId */\n\tMultiXactOffset nextMultiOffset;\t/* next free MultiXact offset */\n\tTransactionId oldestXid;\t/* cluster-wide minimum datfrozenxid */\n\tOid\t\t\toldestXidDB;\t/* database with minimum datfrozenxid */\n\tMultiXactId oldestMulti;\t/* cluster-wide minimum datminmxid */\n\tOid\t\t\toldestMultiDB;\t/* database with minimum datminmxid */\n\tpg_time_t\ttime;\t\t\t/* time stamp of checkpoint */\n\tTransactionId oldestCommitTsXid;\t/* oldest Xid with valid commit\n\t\t\t\t\t\t\t\t\t\t * timestamp */\n\tTransactionId newestCommitTsXid;\t/* newest Xid with valid commit\n\t\t\t\t\t\t\t\t\t\t * timestamp */\n\n\tTransactionId oldestActiveXid;\n} CheckPoint95;\n\n\n#if PG_ACTUAL_VERSION_NUM >= 120000\n/*\n * Following fields removed in PostgreSQL 12;\n *\n *   uint32 nextXidEpoch;\n *   TransactionId nextXid;\n *\n * and replaced by:\n *\n *   FullTransactionId nextFullXid;\n */\n\ntypedef struct CheckPoint12\n{\n\tXLogRecPtr\tredo;\t\t\t/* next RecPtr available when we began to\n\t\t\t\t\t\t\t\t * create CheckPoint (i.e. REDO start point) */\n\tTimeLineID\tThisTimeLineID; /* current TLI */\n\tTimeLineID\tPrevTimeLineID; /* previous TLI, if this record begins a new\n\t\t\t\t\t\t\t\t * timeline (equals ThisTimeLineID otherwise) */\n\tbool\t\tfullPageWrites; /* current full_page_writes */\n\tFullTransactionId nextFullXid;\t/* next free full transaction ID */\n\tOid\t\t\tnextOid;\t\t/* next free OID */\n\tMultiXactId nextMulti;\t\t/* next free MultiXactId */\n\tMultiXactOffset nextMultiOffset;\t/* next free MultiXact offset */\n\tTransactionId oldestXid;\t/* cluster-wide minimum datfrozenxid */\n\tOid\t\t\toldestXidDB;\t/* database with minimum datfrozenxid */\n\tMultiXactId oldestMulti;\t/* cluster-wide minimum datminmxid */\n\tOid\t\t\toldestMultiDB;\t/* database with minimum datminmxid */\n\tpg_time_t\ttime;\t\t\t/* time stamp of checkpoint */\n\tTransactionId oldestCommitTsXid;\t/* oldest Xid with valid commit\n\t\t\t\t\t\t\t\t\t\t * timestamp */\n\tTransactionId newestCommitTsXid;\t/* newest Xid with valid commit\n\t\t\t\t\t\t\t\t\t\t * timestamp */\n\n\t/*\n\t * Oldest XID still running. This is only needed to initialize hot standby\n\t * mode from an online checkpoint, so we only bother calculating this for\n\t * online checkpoints and only when wal_level is replica. Otherwise it's\n\t * set to InvalidTransactionId.\n\t */\n\tTransactionId oldestActiveXid;\n} CheckPoint12;\n#endif\n\n\ntypedef struct ControlFileData94\n{\n\tuint64\t\tsystem_identifier;\n\n\tuint32\t\tpg_control_version;\t\t/* PG_CONTROL_VERSION */\n\tuint32\t\tcatalog_version_no;\t\t/* see catversion.h */\n\n\tDBState\t\tstate;\t\t\t/* see enum above */\n\tpg_time_t\ttime;\t\t\t/* time stamp of last pg_control update */\n\tXLogRecPtr\tcheckPoint;\t\t/* last check point record ptr */\n\tXLogRecPtr\tprevCheckPoint; /* previous check point record ptr */\n\n\tCheckPoint94\tcheckPointCopy; /* copy of last check point record */\n\n\tXLogRecPtr\tunloggedLSN;\t/* current fake LSN value, for unlogged rels */\n\n\tXLogRecPtr\tminRecoveryPoint;\n\tTimeLineID\tminRecoveryPointTLI;\n\tXLogRecPtr\tbackupStartPoint;\n\tXLogRecPtr\tbackupEndPoint;\n\tbool\t\tbackupEndRequired;\n\n\tint\t\t\twal_level;\n\tbool\t\twal_log_hints;\n\tint\t\t\tMaxConnections;\n\tint\t\t\tmax_worker_processes;\n\tint\t\t\tmax_prepared_xacts;\n\tint\t\t\tmax_locks_per_xact;\n\n\tuint32\t\tmaxAlign;\t\t/* alignment requirement for tuples */\n\tdouble\t\tfloatFormat;\t/* constant 1234567.0 */\n\n\tuint32\t\tblcksz;\t\t\t/* data block size for this DB */\n\tuint32\t\trelseg_size;\t/* blocks per segment of large relation */\n\n\tuint32\t\txlog_blcksz;\t/* block size within WAL files */\n\tuint32\t\txlog_seg_size;\t/* size of each WAL segment */\n\n\tuint32\t\tnameDataLen;\t/* catalog name field width */\n\tuint32\t\tindexMaxKeys;\t/* max number of columns in an index */\n\n\tuint32\t\ttoast_max_chunk_size;\t/* chunk size in TOAST tables */\n\tuint32\t\tloblksize;\t\t/* chunk size in pg_largeobject */\n\n\tbool\t\tenableIntTimes; /* int64 storage enabled? */\n\n\tbool\t\tfloat4ByVal;\t/* float4 pass-by-value? */\n\tbool\t\tfloat8ByVal;\t/* float8, int8, etc pass-by-value? */\n\n\t/* Are data pages protected by checksums? Zero if no checksum version */\n\tuint32\t\tdata_checksum_version;\n\n} ControlFileData94;\n\n\n\n/*\n * Following field added since 9.4:\n *\n *\tbool\t\ttrack_commit_timestamp;\n *\n * Unchanged in 9.6\n *\n * In 10, following field appended *after* \"data_checksum_version\":\n *\n *\tchar\t\tmock_authentication_nonce[MOCK_AUTH_NONCE_LEN];\n *\n * (but we don't care about that)\n */\n\ntypedef struct ControlFileData95\n{\n\tuint64\t\tsystem_identifier;\n\n\tuint32\t\tpg_control_version;\t\t/* PG_CONTROL_VERSION */\n\tuint32\t\tcatalog_version_no;\t\t/* see catversion.h */\n\n\tDBState\t\tstate;\t\t\t/* see enum above */\n\tpg_time_t\ttime;\t\t\t/* time stamp of last pg_control update */\n\tXLogRecPtr\tcheckPoint;\t\t/* last check point record ptr */\n\tXLogRecPtr\tprevCheckPoint; /* previous check point record ptr */\n\n\tCheckPoint95\tcheckPointCopy; /* copy of last check point record */\n\n\tXLogRecPtr\tunloggedLSN;\t/* current fake LSN value, for unlogged rels */\n\n\tXLogRecPtr\tminRecoveryPoint;\n\tTimeLineID\tminRecoveryPointTLI;\n\tXLogRecPtr\tbackupStartPoint;\n\tXLogRecPtr\tbackupEndPoint;\n\tbool\t\tbackupEndRequired;\n\n\tint\t\t\twal_level;\n\tbool\t\twal_log_hints;\n\tint\t\t\tMaxConnections;\n\tint\t\t\tmax_worker_processes;\n\tint\t\t\tmax_prepared_xacts;\n\tint\t\t\tmax_locks_per_xact;\n\tbool\t\ttrack_commit_timestamp;\n\n\tuint32\t\tmaxAlign;\t\t/* alignment requirement for tuples */\n\tdouble\t\tfloatFormat;\t/* constant 1234567.0 */\n\n\tuint32\t\tblcksz;\t\t\t/* data block size for this DB */\n\tuint32\t\trelseg_size;\t/* blocks per segment of large relation */\n\n\tuint32\t\txlog_blcksz;\t/* block size within WAL files */\n\tuint32\t\txlog_seg_size;\t/* size of each WAL segment */\n\n\tuint32\t\tnameDataLen;\t/* catalog name field width */\n\tuint32\t\tindexMaxKeys;\t/* max number of columns in an index */\n\n\tuint32\t\ttoast_max_chunk_size;\t/* chunk size in TOAST tables */\n\tuint32\t\tloblksize;\t\t/* chunk size in pg_largeobject */\n\n\tbool\t\tenableIntTimes; /* int64 storage enabled? */\n\n\tbool\t\tfloat4ByVal;\t/* float4 pass-by-value? */\n\tbool\t\tfloat8ByVal;\t/* float8, int8, etc pass-by-value? */\n\n\tuint32\t\tdata_checksum_version;\n\n} ControlFileData95;\n\n/*\n * Following field removed in 11:\n *\n *  XLogRecPtr\tprevCheckPoint;\n *\n * In 10, following field appended *after* \"data_checksum_version\":\n *\n * \tchar\t\tmock_authentication_nonce[MOCK_AUTH_NONCE_LEN];\n *\n * (but we don't care about that)\n */\n\ntypedef struct ControlFileData11\n{\n\tuint64\t\tsystem_identifier;\n\n\tuint32\t\tpg_control_version;\t\t/* PG_CONTROL_VERSION */\n\tuint32\t\tcatalog_version_no;\t\t/* see catversion.h */\n\n\tDBState\t\tstate;\t\t\t/* see enum above */\n\tpg_time_t\ttime;\t\t\t/* time stamp of last pg_control update */\n\tXLogRecPtr\tcheckPoint;\t\t/* last check point record ptr */\n\n\tCheckPoint95\tcheckPointCopy; /* copy of last check point record */\n\n\tXLogRecPtr\tunloggedLSN;\t/* current fake LSN value, for unlogged rels */\n\n\tXLogRecPtr\tminRecoveryPoint;\n\tTimeLineID\tminRecoveryPointTLI;\n\tXLogRecPtr\tbackupStartPoint;\n\tXLogRecPtr\tbackupEndPoint;\n\tbool\t\tbackupEndRequired;\n\n\tint\t\t\twal_level;\n\tbool\t\twal_log_hints;\n\tint\t\t\tMaxConnections;\n\tint\t\t\tmax_worker_processes;\n\tint\t\t\tmax_prepared_xacts;\n\tint\t\t\tmax_locks_per_xact;\n\tbool\t\ttrack_commit_timestamp;\n\n\tuint32\t\tmaxAlign;\t\t/* alignment requirement for tuples */\n\tdouble\t\tfloatFormat;\t/* constant 1234567.0 */\n\n\tuint32\t\tblcksz;\t\t\t/* data block size for this DB */\n\tuint32\t\trelseg_size;\t/* blocks per segment of large relation */\n\n\tuint32\t\txlog_blcksz;\t/* block size within WAL files */\n\tuint32\t\txlog_seg_size;\t/* size of each WAL segment */\n\n\tuint32\t\tnameDataLen;\t/* catalog name field width */\n\tuint32\t\tindexMaxKeys;\t/* max number of columns in an index */\n\n\tuint32\t\ttoast_max_chunk_size;\t/* chunk size in TOAST tables */\n\tuint32\t\tloblksize;\t\t/* chunk size in pg_largeobject */\n\n\tbool\t\tenableIntTimes; /* int64 storage enabled? */\n\n\tbool\t\tfloat4ByVal;\t/* float4 pass-by-value? */\n\tbool\t\tfloat8ByVal;\t/* float8, int8, etc pass-by-value? */\n\n\tuint32\t\tdata_checksum_version;\n\n} ControlFileData11;\n\n\n#if PG_ACTUAL_VERSION_NUM >= 120000\n/*\n * Following field added in Pg12:\n *\n *   int max_wal_senders;\n */\n\ntypedef struct ControlFileData12\n{\n\tuint64\t\tsystem_identifier;\n\n\tuint32\t\tpg_control_version; /* PG_CONTROL_VERSION */\n\tuint32\t\tcatalog_version_no; /* see catversion.h */\n\n\tDBState\t\tstate;\t\t\t/* see enum above */\n\tpg_time_t\ttime;\t\t\t/* time stamp of last pg_control update */\n\tXLogRecPtr\tcheckPoint;\t\t/* last check point record ptr */\n\n\tCheckPoint12\tcheckPointCopy; /* copy of last check point record */\n\n\tXLogRecPtr\tunloggedLSN;\t/* current fake LSN value, for unlogged rels */\n\n\tXLogRecPtr\tminRecoveryPoint;\n\tTimeLineID\tminRecoveryPointTLI;\n\tXLogRecPtr\tbackupStartPoint;\n\tXLogRecPtr\tbackupEndPoint;\n\tbool\t\tbackupEndRequired;\n\n\tint\t\t\twal_level;\n\tbool\t\twal_log_hints;\n\tint\t\t\tMaxConnections;\n\tint\t\t\tmax_worker_processes;\n\tint\t\t\tmax_wal_senders;\n\tint\t\t\tmax_prepared_xacts;\n\tint\t\t\tmax_locks_per_xact;\n\tbool\t\ttrack_commit_timestamp;\n\n\tuint32\t\tmaxAlign;\t\t/* alignment requirement for tuples */\n\tdouble\t\tfloatFormat;\t/* constant 1234567.0 */\n\n\tuint32\t\tblcksz;\t\t\t/* data block size for this DB */\n\tuint32\t\trelseg_size;\t/* blocks per segment of large relation */\n\n\tuint32\t\txlog_blcksz;\t/* block size within WAL files */\n\tuint32\t\txlog_seg_size;\t/* size of each WAL segment */\n\n\tuint32\t\tnameDataLen;\t/* catalog name field width */\n\tuint32\t\tindexMaxKeys;\t/* max number of columns in an index */\n\n\tuint32\t\ttoast_max_chunk_size;\t/* chunk size in TOAST tables */\n\tuint32\t\tloblksize;\t\t/* chunk size in pg_largeobject */\n\n\tbool\t\tfloat4ByVal;\t/* float4 pass-by-value? */\n\tbool\t\tfloat8ByVal;\t/* float8, int8, etc pass-by-value? */\n\n\tuint32\t\tdata_checksum_version;\n} ControlFileData12;\n#endif\n\nextern int get_pg_version(const char *data_directory, char *version_string);\nextern bool get_db_state(const char *data_directory, DBState *state);\nextern const char *describe_db_state(DBState state);\nextern int\tget_data_checksum_version(const char *data_directory);\nextern uint64 get_system_identifier(const char *data_directory);\nextern XLogRecPtr get_latest_checkpoint_location(const char *data_directory);\nextern TimeLineID get_timeline(const char *data_directory);\nextern TimeLineID get_min_recovery_end_timeline(const char *data_directory);\nextern XLogRecPtr get_min_recovery_location(const char *data_directory);\n\n#endif\t\t\t\t\t\t\t/* _CONTROLDATA_H_ */\n"
        },
        {
          "name": "dbutils.c",
          "type": "blob",
          "size": 141.205078125,
          "content": "/*\n * dbutils.c - Database connection/management functions\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <dirent.h>\n#include <arpa/inet.h>\n\n#include \"repmgr.h\"\n#include \"dbutils.h\"\n#include \"controldata.h\"\n#include \"dirutil.h\"\n\n#define NODE_RECORD_PARAM_COUNT 11\n\n\nstatic void log_db_error(PGconn *conn, const char *query_text, const char *fmt,...)\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 3, 4)));\n\nstatic bool _is_server_available(const char *conninfo, bool quiet);\n\nstatic PGconn *_establish_db_connection(const char *conninfo,\n\t\t\t\t\t\t const bool exit_on_error,\n\t\t\t\t\t\t const bool log_notice,\n\t\t\t\t\t\t const bool verbose_only);\n\nstatic PGconn * _establish_replication_connection_from_params(PGconn *conn, const char *conninfo, const char *repluser);\n\nstatic PGconn *_get_primary_connection(PGconn *standby_conn, int *primary_id, char *primary_conninfo_out, bool quiet);\n\nstatic bool _set_config(PGconn *conn, const char *config_param, const char *sqlquery);\nstatic bool _get_pg_setting(PGconn *conn, const char *setting, char *str_output, bool *bool_output, int *int_output);\n\nstatic RecordStatus _get_node_record(PGconn *conn, char *sqlquery, t_node_info *node_info, bool init_defaults);\nstatic void _populate_node_record(PGresult *res, t_node_info *node_info, int row, bool init_defaults);\n\nstatic void _populate_node_records(PGresult *res, NodeInfoList *node_list);\n\nstatic bool _create_update_node_record(PGconn *conn, char *action, t_node_info *node_info);\n\nstatic ReplSlotStatus _verify_replication_slot(PGconn *conn, char *slot_name, PQExpBufferData *error_msg);\n\nstatic bool _create_event(PGconn *conn, t_configuration_options *options, int node_id, char *event, bool successful, char *details, t_event_info *event_info, bool send_notification);\n\nstatic NodeAttached _is_downstream_node_attached(PGconn *conn, char *node_name, char **node_state, bool quiet);\n\n/*\n * This provides a standardized way of logging database errors. Note\n * that the provided PGconn can be a normal or a replication connection;\n * no attempt is made to write to the database, only to report the output\n * of PQerrorMessage().\n */\nvoid\nlog_db_error(PGconn *conn, const char *query_text, const char *fmt,...)\n{\n\tva_list\t\tap;\n\tchar\t\tbuf[MAXLEN];\n\tint\t\t\tretval;\n\n\tva_start(ap, fmt);\n\tretval = vsnprintf(buf, MAXLEN, fmt, ap);\n\tva_end(ap);\n\n\tif (retval < MAXLEN)\n\t\tlog_error(\"%s\", buf);\n\n\tif (conn != NULL)\n\t{\n\t\tlog_detail(\"\\n%s\", PQerrorMessage(conn));\n\t}\n\n\tif (query_text != NULL)\n\t{\n\t\tlog_detail(\"query text is:\\n%s\", query_text);\n\t}\n}\n\n/* ================= */\n/* utility functions */\n/* ================= */\n\nXLogRecPtr\nparse_lsn(const char *str)\n{\n\tXLogRecPtr\tptr = InvalidXLogRecPtr;\n\tuint32\t\thigh,\n\t\t\t\tlow;\n\n\tif (sscanf(str, \"%x/%x\", &high, &low) == 2)\n\t\tptr = (((XLogRecPtr) high) << 32) + (XLogRecPtr) low;\n\n\treturn ptr;\n}\n\n\n/* ==================== */\n/* Connection functions */\n/* ==================== */\n\n/*\n * _establish_db_connection()\n *\n * Connect to a database using a conninfo string.\n *\n * NOTE: *do not* use this for replication connections; instead use:\n *\t establish_db_connection_by_params()\n */\n\nstatic PGconn *\n_establish_db_connection(const char *conninfo, const bool exit_on_error, const bool log_notice, const bool verbose_only)\n{\n\tPGconn\t   *conn = NULL;\n\tchar\t   *connection_string = NULL;\n\tchar\t   *errmsg = NULL;\n\n\tt_conninfo_param_list conninfo_params = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\tbool\t\tis_replication_connection = false;\n\tbool\t\tparse_success = false;\n\n\tinitialize_conninfo_params(&conninfo_params, false);\n\n\tparse_success = parse_conninfo_string(conninfo, &conninfo_params, &errmsg, false);\n\n\tif (parse_success == false)\n\t{\n\t\tlog_error(_(\"unable to parse provided conninfo string \\\"%s\\\"\"), conninfo);\n\t\tlog_detail(\"%s\", errmsg);\n\t\tfree_conninfo_params(&conninfo_params);\n\t\treturn NULL;\n\t}\n\n\t/* set some default values if not explicitly provided */\n\tparam_set_ine(&conninfo_params, \"connect_timeout\", \"2\");\n\tparam_set_ine(&conninfo_params, \"fallback_application_name\", \"repmgr\");\n\n\tif (param_get(&conninfo_params, \"replication\") != NULL)\n\t\tis_replication_connection = true;\n\n\t/* use a secure search_path */\n\tparam_set(&conninfo_params, \"options\", \"-csearch_path=\");\n\n\tconnection_string = param_list_to_string(&conninfo_params);\n\n\tlog_debug(_(\"connecting to: \\\"%s\\\"\"), connection_string);\n\n\tconn = PQconnectdb(connection_string);\n\n\t/* Check to see that the backend connection was successfully made */\n\tif ((PQstatus(conn) != CONNECTION_OK))\n\t{\n\t\tbool\t\temit_log = true;\n\n\t\tif (verbose_only == true && verbose_logging == false)\n\t\t\temit_log = false;\n\n\t\tif (emit_log)\n\t\t{\n\t\t\tif (log_notice)\n\t\t\t{\n\t\t\t\tlog_notice(_(\"connection to database failed\"));\n\t\t\t\tlog_detail(\"\\n%s\", PQerrorMessage(conn));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_error(_(\"connection to database failed\"));\n\t\t\t\tlog_detail(\"\\n%s\", PQerrorMessage(conn));\n\t\t\t}\n\t\t\tlog_detail(_(\"attempted to connect using:\\n  %s\"),\n\t\t\t\t\t   connection_string);\n\t\t}\n\n\t\tif (exit_on_error)\n\t\t{\n\t\t\tPQfinish(conn);\n\t\t\tfree_conninfo_params(&conninfo_params);\n\t\t\texit(ERR_DB_CONN);\n\t\t}\n\t}\n\n\t/*\n\t * set \"synchronous_commit\" to \"local\" in case synchronous replication is\n\t * in use\n\t *\n\t * XXX set this explicitly before any write operations\n\t */\n\n\telse if (is_replication_connection == false &&\n\t\t\t set_config(conn, \"synchronous_commit\", \"local\") == false)\n\t{\n\t\tif (exit_on_error)\n\t\t{\n\t\t\tPQfinish(conn);\n\t\t\tfree_conninfo_params(&conninfo_params);\n\t\t\texit(ERR_DB_CONN);\n\t\t}\n\t}\n\n\tpfree(connection_string);\n\tfree_conninfo_params(&conninfo_params);\n\n\treturn conn;\n}\n\n\n/*\n * Establish a database connection, optionally exit on error\n */\nPGconn *\nestablish_db_connection(const char *conninfo, const bool exit_on_error)\n{\n\treturn _establish_db_connection(conninfo, exit_on_error, false, false);\n}\n\n/*\n * Attempt to establish a database connection, never exit on error, only\n * output error messages if --verbose option used\n */\nPGconn *\nestablish_db_connection_quiet(const char *conninfo)\n{\n\treturn _establish_db_connection(conninfo, false, false, true);\n}\n\n\nPGconn *\nestablish_db_connection_with_replacement_param(const char *conninfo,\n\t\t\t\t\t\t\t\t\t\t\t   const char *param,\n\t\t\t\t\t\t\t\t\t\t\t   const char *value,\n\t\t\t\t\t\t\t\t\t\t\t   const bool exit_on_error)\n{\n\tt_conninfo_param_list node_conninfo = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\tchar\t   *errmsg = NULL;\n\tbool\t\tparse_success = false;\n\tPGconn\t   *conn = NULL;\n\n\tinitialize_conninfo_params(&node_conninfo, false);\n\n\tparse_success = parse_conninfo_string(conninfo,\n\t\t\t\t\t\t\t\t\t\t  &node_conninfo,\n\t\t\t\t\t\t\t\t\t\t  &errmsg, false);\n\n\tif (parse_success == false)\n\t{\n\t\tlog_error(_(\"unable to parse conninfo string \\\"%s\\\" for local node\"),\n\t\t\t\t  conninfo);\n\t\tlog_detail(\"%s\", errmsg);\n\n\t\tif (exit_on_error == true)\n\t\t\texit(ERR_BAD_CONFIG);\n\n\t\treturn NULL;\n\t}\n\n\tparam_set(&node_conninfo,\n\t\t\t  param,\n\t\t\t  value);\n\n\tconn = establish_db_connection_by_params(&node_conninfo, exit_on_error);\n\n\tfree_conninfo_params(&node_conninfo);\n\n\treturn conn;\n}\n\nPGconn *\nestablish_primary_db_connection(PGconn *conn,\n\t\t\t\t\t\t\t\tconst bool exit_on_error)\n{\n\tt_node_info primary_node_info = T_NODE_INFO_INITIALIZER;\n\tbool\t\tprimary_record_found = get_primary_node_record(conn, &primary_node_info);\n\n\tif (primary_record_found == false)\n\t{\n\t\treturn NULL;\n\t}\n\n\treturn establish_db_connection(primary_node_info.conninfo,\n\t\t\t\t\t\t\t\t   exit_on_error);\n}\n\n\nPGconn *\nestablish_db_connection_by_params(t_conninfo_param_list *param_list,\n\t\t\t\t\t\t\t\t  const bool exit_on_error)\n{\n\tPGconn\t   *conn = NULL;\n\n\t/* set some default values if not explicitly provided */\n\tparam_set_ine(param_list, \"connect_timeout\", \"2\");\n\tparam_set_ine(param_list, \"fallback_application_name\", \"repmgr\");\n\n\t/* use a secure search_path */\n\tparam_set(param_list, \"options\", \"-csearch_path=\");\n\n\t/* Connect to the database using the provided parameters */\n\tconn = PQconnectdbParams((const char **) param_list->keywords, (const char **) param_list->values, true);\n\n\t/* Check to see that the backend connection was successfully made */\n\tif ((PQstatus(conn) != CONNECTION_OK))\n\t{\n\t\tlog_error(_(\"connection to database failed\"));\n\t\tlog_detail(\"\\n%s\", PQerrorMessage(conn));\n\n\t\tif (exit_on_error)\n\t\t{\n\t\t\tPQfinish(conn);\n\t\t\texit(ERR_DB_CONN);\n\t\t}\n\t}\n\telse\n\t{\n\t\tbool\t\tis_replication_connection = false;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * set \"synchronous_commit\" to \"local\" in case synchronous replication\n\t\t * is in use (provided this is not a replication connection)\n\t\t */\n\n\t\tfor (i = 0; param_list->keywords[i]; i++)\n\t\t{\n\t\t\tif (strcmp(param_list->keywords[i], \"replication\") == 0)\n\t\t\t\tis_replication_connection = true;\n\t\t}\n\n\t\tif (is_replication_connection == false && set_config(conn, \"synchronous_commit\", \"local\") == false)\n\t\t{\n\t\t\tif (exit_on_error)\n\t\t\t{\n\t\t\t\tPQfinish(conn);\n\t\t\t\texit(ERR_DB_CONN);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn conn;\n}\n\n\n/*\n * Given an existing active connection and the name of a replication\n * user, extract the connection parameters from that connection and\n * attempt to return a replication connection.\n */\nPGconn *\nestablish_replication_connection_from_conn(PGconn *conn, const char *repluser)\n{\n\treturn _establish_replication_connection_from_params(conn, NULL, repluser);\n}\n\n\nPGconn *\nestablish_replication_connection_from_conninfo(const char *conninfo, const char *repluser)\n{\n\treturn _establish_replication_connection_from_params(NULL, conninfo, repluser);\n}\n\n\nstatic PGconn *\n_establish_replication_connection_from_params(PGconn *conn, const char *conninfo, const char *repluser)\n{\n\tt_conninfo_param_list repl_conninfo = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\tPGconn *repl_conn = NULL;\n\n\tinitialize_conninfo_params(&repl_conninfo, false);\n\n\tif (conn != NULL)\n\t\tconn_to_param_list(conn, &repl_conninfo);\n\telse if (conninfo != NULL)\n\t\tparse_conninfo_string(conninfo, &repl_conninfo, NULL, false);\n\n\t/* Set the provided replication user */\n\tparam_set(&repl_conninfo, \"user\", repluser);\n\tparam_set(&repl_conninfo, \"replication\", \"1\");\n\tparam_set(&repl_conninfo, \"dbname\", \"replication\");\n\n\trepl_conn = establish_db_connection_by_params(&repl_conninfo, false);\n\tfree_conninfo_params(&repl_conninfo);\n\n\treturn repl_conn;\n}\n\n\nPGconn *\nget_primary_connection(PGconn *conn,\n\t\t\t\t\t   int *primary_id, char *primary_conninfo_out)\n{\n\treturn _get_primary_connection(conn, primary_id, primary_conninfo_out, false);\n}\n\n\nPGconn *\nget_primary_connection_quiet(PGconn *conn,\n\t\t\t\t\t\t\t int *primary_id, char *primary_conninfo_out)\n{\n\treturn _get_primary_connection(conn, primary_id, primary_conninfo_out, true);\n}\n\nPGconn *\nduplicate_connection(PGconn *conn, const char *user, bool replication)\n{\n\tt_conninfo_param_list conninfo = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\tPGconn *duplicate_conn = NULL;\n\n\tinitialize_conninfo_params(&conninfo, false);\n\tconn_to_param_list(conn, &conninfo);\n\n\tif (user != NULL)\n\t\tparam_set(&conninfo, \"user\", user);\n\n\tif (replication == true)\n\t\tparam_set(&conninfo, \"replication\", \"1\");\n\n\tduplicate_conn = establish_db_connection_by_params(&conninfo, false);\n\n\tfree_conninfo_params(&conninfo);\n\n\treturn duplicate_conn;\n}\n\n\n\nvoid\nclose_connection(PGconn **conn)\n{\n\tif (*conn == NULL)\n\t\treturn;\n\n\tPQfinish(*conn);\n\n\t*conn = NULL;\n}\n\n\n/* =============================== */\n/* conninfo manipulation functions */\n/* =============================== */\n\n\n/*\n * get_conninfo_value()\n *\n * Extract the value represented by 'keyword' in 'conninfo' and copy\n * it to the 'output' buffer.\n *\n * Returns true on success, or false on failure (conninfo string could\n * not be parsed, or provided keyword not found).\n */\n\nbool\nget_conninfo_value(const char *conninfo, const char *keyword, char *output)\n{\n\tPQconninfoOption *conninfo_options = NULL;\n\tPQconninfoOption *conninfo_option = NULL;\n\n\tconninfo_options = PQconninfoParse(conninfo, NULL);\n\n\tif (conninfo_options == NULL)\n\t{\n\t\tlog_error(_(\"unable to parse provided conninfo string \\\"%s\\\"\"), conninfo);\n\t\treturn false;\n\t}\n\n\tfor (conninfo_option = conninfo_options; conninfo_option->keyword != NULL; conninfo_option++)\n\t{\n\t\tif (strcmp(conninfo_option->keyword, keyword) == 0)\n\t\t{\n\t\t\tif (conninfo_option->val != NULL && conninfo_option->val[0] != '\\0')\n\t\t\t{\n\t\t\t\tstrncpy(output, conninfo_option->val, MAXLEN);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tPQconninfoFree(conninfo_options);\n\n\treturn true;\n}\n\n\n/*\n * Get a default conninfo value for the provided parameter, and copy\n * it to the 'output' buffer.\n *\n * Returns true on success, or false on failure (provided keyword not found).\n *\n */\nbool\nget_conninfo_default_value(const char *param, char *output, int maxlen)\n{\n\tPQconninfoOption *defs = NULL;\n\tPQconninfoOption *def = NULL;\n\tbool found = false;\n\n\tdefs = PQconndefaults();\n\n\tfor (def = defs; def->keyword; def++)\n\t{\n\t\tif (strncmp(def->keyword, param, maxlen) == 0)\n\t\t{\n\t\t\tstrncpy(output, def->val, maxlen);\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tPQconninfoFree(defs);\n\n\treturn found;\n}\n\n\nvoid\ninitialize_conninfo_params(t_conninfo_param_list *param_list, bool set_defaults)\n{\n\tPQconninfoOption *defs = NULL;\n\tPQconninfoOption *def = NULL;\n\tint\t\t\tc;\n\n\tdefs = PQconndefaults();\n\tparam_list->size = 0;\n\n\t/* Count maximum number of parameters */\n\tfor (def = defs; def->keyword; def++)\n\t\tparam_list->size++;\n\n\t/* Initialize our internal parameter list */\n\tparam_list->keywords = pg_malloc0(sizeof(char *) * (param_list->size + 1));\n\tparam_list->values = pg_malloc0(sizeof(char *) * (param_list->size + 1));\n\n\tfor (c = 0; c < param_list->size; c++)\n\t{\n\t\tparam_list->keywords[c] = NULL;\n\t\tparam_list->values[c] = NULL;\n\t}\n\n\tif (set_defaults == true)\n\t{\n\t\t/* Pre-set any defaults */\n\n\t\tfor (def = defs; def->keyword; def++)\n\t\t{\n\t\t\tif (def->val != NULL && def->val[0] != '\\0')\n\t\t\t{\n\t\t\t\tparam_set(param_list, def->keyword, def->val);\n\t\t\t}\n\t\t}\n\t}\n\n\tPQconninfoFree(defs);\n}\n\n\nvoid\nfree_conninfo_params(t_conninfo_param_list *param_list)\n{\n\tint\t\t\tc;\n\n\tfor (c = 0; c < param_list->size; c++)\n\t{\n\t\tif (param_list->keywords != NULL && param_list->keywords[c] != NULL)\n\t\t\tpfree(param_list->keywords[c]);\n\n\t\tif (param_list->values != NULL && param_list->values[c] != NULL)\n\t\t\tpfree(param_list->values[c]);\n\t}\n\n\tif (param_list->keywords != NULL)\n\t\tpfree(param_list->keywords);\n\n\tif (param_list->values != NULL)\n\t\tpfree(param_list->values);\n}\n\n\n\nvoid\ncopy_conninfo_params(t_conninfo_param_list *dest_list, t_conninfo_param_list *source_list)\n{\n\tint\t\t\tc;\n\n\tfor (c = 0; c < source_list->size && source_list->keywords[c] != NULL; c++)\n\t{\n\t\tif (source_list->values[c] != NULL && source_list->values[c][0] != '\\0')\n\t\t{\n\t\t\tparam_set(dest_list, source_list->keywords[c], source_list->values[c]);\n\t\t}\n\t}\n}\n\nvoid\nparam_set(t_conninfo_param_list *param_list, const char *param, const char *value)\n{\n\tint\t\t\tc;\n\tint\t\t\tvalue_len = strlen(value) + 1;\n\tint\t\t\tparam_len;\n\n\t/*\n\t * Scan array to see if the parameter is already set - if not, replace it\n\t */\n\tfor (c = 0; c < param_list->size && param_list->keywords[c] != NULL; c++)\n\t{\n\t\tif (strcmp(param_list->keywords[c], param) == 0)\n\t\t{\n\t\t\tif (param_list->values[c] != NULL)\n\t\t\t\tpfree(param_list->values[c]);\n\n\t\t\tparam_list->values[c] = pg_malloc0(value_len);\n\t\t\tstrncpy(param_list->values[c], value, value_len);\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Sanity-check that the caller is not trying to overflow the array;\n\t * in practice this is highly unlikely, and if it ever happens, this means\n\t * something is highly wrong.\n\t */\n\tAssert(c < param_list->size);\n\n\t/*\n\t * Parameter not in array - add it and its associated value\n\t */\n\tparam_len = strlen(param) + 1;\n\n\tparam_list->keywords[c] = pg_malloc0(param_len);\n\tparam_list->values[c] = pg_malloc0(value_len);\n\n\tstrncpy(param_list->keywords[c], param, param_len);\n\tstrncpy(param_list->values[c], value, value_len);\n}\n\n\n/*\n * Like param_set(), but will only set the parameter if it doesn't exist\n */\nvoid\nparam_set_ine(t_conninfo_param_list *param_list, const char *param, const char *value)\n{\n\tint\t\t\tc;\n\tint\t\t\tvalue_len = strlen(value) + 1;\n\tint\t\t\tparam_len;\n\n\t/*\n\t * Scan array to see if the parameter is already set - if so, do nothing\n\t */\n\tfor (c = 0; c < param_list->size && param_list->keywords[c] != NULL; c++)\n\t{\n\t\tif (strcmp(param_list->keywords[c], param) == 0)\n\t\t{\n\t\t\t/* parameter exists, do nothing */\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Sanity-check that the caller is not trying to overflow the array;\n\t * in practice this is highly unlikely, and if it ever happens, this means\n\t * something is highly wrong.\n\t */\n\tAssert(c < param_list->size);\n\n\t/*\n\t * Parameter not in array - add it and its associated value\n\t */\n\tparam_len = strlen(param) + 1;\n\n\tparam_list->keywords[c] = pg_malloc0(param_len);\n\tparam_list->values[c] = pg_malloc0(value_len);\n\n\tstrncpy(param_list->keywords[c], param, param_len);\n\tstrncpy(param_list->values[c], value, value_len);\n}\n\n\nchar *\nparam_get(t_conninfo_param_list *param_list, const char *param)\n{\n\tint\t\t\tc;\n\n\tfor (c = 0; c < param_list->size && param_list->keywords[c] != NULL; c++)\n\t{\n\t\tif (strcmp(param_list->keywords[c], param) == 0)\n\t\t{\n\t\t\tif (param_list->values[c] != NULL && param_list->values[c][0] != '\\0')\n\t\t\t\treturn param_list->values[c];\n\t\t\telse\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n\n/*\n * Validate a conninfo string by attempting to parse it.\n *\n * \"errmsg\": passed to PQconninfoParse(), may be NULL\n *\n * NOTE: PQconninfoParse() verifies the string format and checks for\n * valid options but does not sanity check values.\n */\n\nbool\nvalidate_conninfo_string(const char *conninfo_str, char **errmsg)\n{\n\tPQconninfoOption *connOptions = NULL;\n\n\tconnOptions = PQconninfoParse(conninfo_str, errmsg);\n\n\tif (connOptions == NULL)\n\t\treturn false;\n\n\tPQconninfoFree(connOptions);\n\n\treturn true;\n}\n\n\n/*\n * Parse a conninfo string into a t_conninfo_param_list\n *\n * See conn_to_param_list() to do the same for a PGconn.\n *\n * \"errmsg\": passed to PQconninfoParse(), may be NULL\n *\n * \"ignore_local_params\": ignores those parameters specific\n * to a local installation, i.e. when parsing an upstream\n * node's conninfo string for inclusion into \"primary_conninfo\",\n * don't copy that node's values\n */\nbool\nparse_conninfo_string(const char *conninfo_str, t_conninfo_param_list *param_list, char **errmsg, bool ignore_local_params)\n{\n\tPQconninfoOption *connOptions = NULL;\n\tPQconninfoOption *option = NULL;\n\n\tconnOptions = PQconninfoParse(conninfo_str, errmsg);\n\n\tif (connOptions == NULL)\n\t\treturn false;\n\n\tfor (option = connOptions; option && option->keyword; option++)\n\t{\n\t\t/* Ignore non-set or blank parameter values */\n\t\tif (option->val == NULL || option->val[0] == '\\0')\n\t\t\tcontinue;\n\n\t\t/* Ignore settings specific to the upstream node */\n\t\tif (ignore_local_params == true)\n\t\t{\n\t\t\tif (strcmp(option->keyword, \"application_name\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(option->keyword, \"passfile\") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(option->keyword, \"servicefile\") == 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\tparam_set(param_list, option->keyword, option->val);\n\t}\n\n\tPQconninfoFree(connOptions);\n\n\treturn true;\n}\n\n\n/*\n * Parse a PGconn into a t_conninfo_param_list\n *\n * See parse_conninfo_string() to do the same for a conninfo string\n *\n * NOTE: the current use case for this is to take an active connection,\n * replace the existing username (typically replacing it with the superuser\n * or replication user name), and make a new connection as that user.\n * If the \"password\" field is set, it will cause any connection made with\n * these parameters to fail (unless of course the password happens to be the\n * same). Therefore we remove the password altogether, and rely on it being\n * available via .pgpass.\n */\nvoid\nconn_to_param_list(PGconn *conn, t_conninfo_param_list *param_list)\n{\n\tPQconninfoOption *connOptions = NULL;\n\tPQconninfoOption *option = NULL;\n\n\tconnOptions = PQconninfo(conn);\n\tfor (option = connOptions; option && option->keyword; option++)\n\t{\n\t\t/* Ignore non-set or blank parameter values */\n\t\tif (option->val == NULL || option->val[0] == '\\0')\n\t\t\tcontinue;\n\n\t\t/* Ignore \"password\" */\n\t\tif (strcmp(option->keyword, \"password\") == 0)\n\t\t\tcontinue;\n\n\t\tparam_set(param_list, option->keyword, option->val);\n\t}\n\n\tPQconninfoFree(connOptions);\n}\n\n\n/*\n * Converts param list to string; caller must free returned pointer\n */\nchar *\nparam_list_to_string(t_conninfo_param_list *param_list)\n{\n\tint\t\t\tc;\n\tPQExpBufferData conninfo_buf;\n\tchar\t   *conninfo_str = NULL;\n\tint\t\t\tlen = 0;\n\n\tinitPQExpBuffer(&conninfo_buf);\n\n\tfor (c = 0; c < param_list->size && param_list->keywords[c] != NULL; c++)\n\t{\n\t\tif (param_list->values[c] != NULL && param_list->values[c][0] != '\\0')\n\t\t{\n\t\t\tif (c > 0)\n\t\t\t\tappendPQExpBufferChar(&conninfo_buf, ' ');\n\n\t\t\t/* XXX escape value */\n\t\t\tappendPQExpBuffer(&conninfo_buf,\n\t\t\t\t\t\t\t  \"%s=%s\",\n\t\t\t\t\t\t\t  param_list->keywords[c],\n\t\t\t\t\t\t\t  param_list->values[c]);\n\t\t}\n\t}\n\n\tlen = strlen(conninfo_buf.data) + 1;\n\tconninfo_str = pg_malloc0(len);\n\n\tstrncpy(conninfo_str, conninfo_buf.data, len);\n\n\ttermPQExpBuffer(&conninfo_buf);\n\n\treturn conninfo_str;\n}\n\n\n/*\n * Run a conninfo string through the parser, and pass it back as a normal\n * conninfo string. This is mainly intended for converting connection URIs\n * to parameter/value conninfo strings.\n *\n * Caller must free returned pointer.\n */\n\nchar *\nnormalize_conninfo_string(const char *conninfo_str)\n{\n\tt_conninfo_param_list conninfo_params = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\tbool\t\tparse_success = false;\n\tchar\t   *normalized_string = NULL;\n\tchar\t   *errmsg = NULL;\n\n\tinitialize_conninfo_params(&conninfo_params, false);\n\n\tparse_success = parse_conninfo_string(conninfo_str, &conninfo_params, &errmsg, false);\n\n\tif (parse_success == false)\n\t{\n\t\tlog_error(_(\"unable to parse provided conninfo string \\\"%s\\\"\"), conninfo_str);\n\t\tlog_detail(\"%s\", errmsg);\n\t\tfree_conninfo_params(&conninfo_params);\n\t\treturn NULL;\n\t}\n\n\n\tnormalized_string = param_list_to_string(&conninfo_params);\n\tfree_conninfo_params(&conninfo_params);\n\n\treturn normalized_string;\n}\n\n/*\n * check whether the libpq version in use recognizes the \"passfile\" parameter\n * (should be 9.6 and later)\n */\nbool\nhas_passfile(void)\n{\n\tPQconninfoOption *defs = PQconndefaults();\n\tPQconninfoOption *def = NULL;\n    bool has_passfile = false;\n\n   \tfor (def = defs; def->keyword; def++)\n    {\n        if (strcmp(def->keyword, \"passfile\") == 0)\n        {\n            has_passfile = true;\n            break;\n        }\n    }\n\n\tPQconninfoFree(defs);\n\n\treturn has_passfile;\n}\n\n\n\n/* ===================== */\n/* transaction functions */\n/* ===================== */\n\nbool\nbegin_transaction(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\n\tlog_verbose(LOG_DEBUG, \"begin_transaction()\");\n\n\tres = PQexec(conn, \"BEGIN\");\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_error(_(\"unable to begin transaction\"));\n\t\tlog_detail(\"%s\", PQerrorMessage(conn));\n\n\t\tPQclear(res);\n\t\treturn false;\n\t}\n\n\tPQclear(res);\n\n\treturn true;\n}\n\n\nbool\ncommit_transaction(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\n\tlog_verbose(LOG_DEBUG, \"commit_transaction()\");\n\n\tres = PQexec(conn, \"COMMIT\");\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_error(_(\"unable to commit transaction\"));\n\t\tlog_detail(\"%s\", PQerrorMessage(conn));\n\t\tPQclear(res);\n\n\t\treturn false;\n\t}\n\n\tPQclear(res);\n\n\treturn true;\n}\n\n\nbool\nrollback_transaction(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\n\tlog_verbose(LOG_DEBUG, \"rollback_transaction()\");\n\n\tres = PQexec(conn, \"ROLLBACK\");\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_error(_(\"unable to rollback transaction\"));\n\t\tlog_detail(\"%s\", PQerrorMessage(conn));\n\t\tPQclear(res);\n\n\t\treturn false;\n\t}\n\n\tPQclear(res);\n\n\treturn true;\n}\n\n\n/* ========================== */\n/* GUC manipulation functions */\n/* ========================== */\n\nstatic bool\n_set_config(PGconn *conn, const char *config_param, const char *sqlquery)\n{\n\tbool\t\tsuccess = true;\n\tPGresult   *res = PQexec(conn, sqlquery);\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, sqlquery, \"_set_config(): unable to set \\\"%s\\\"\", config_param);\n\t\tsuccess = false;\n\t}\n\n\tPQclear(res);\n\n\treturn success;\n}\n\n\nbool\nset_config(PGconn *conn, const char *config_param, const char *config_value)\n{\n\tPQExpBufferData query;\n\tbool\t\tresult = false;\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SET %s TO '%s'\",\n\t\t\t\t\t  config_param,\n\t\t\t\t\t  config_value);\n\n\tlog_verbose(LOG_DEBUG, \"set_config():\\n  %s\", query.data);\n\n\tresult = _set_config(conn, config_param, query.data);\n\n\ttermPQExpBuffer(&query);\n\n\treturn result;\n}\n\nbool\nset_config_bool(PGconn *conn, const char *config_param, bool state)\n{\n\tPQExpBufferData query;\n\tbool\t\tresult = false;\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SET %s TO %s\",\n\t\t\t\t\t  config_param,\n\t\t\t\t\t  state ? \"TRUE\" : \"FALSE\");\n\n\tlog_verbose(LOG_DEBUG, \"set_config_bool():\\n  %s\", query.data);\n\n\n\tresult = _set_config(conn, config_param, query.data);\n\n\ttermPQExpBuffer(&query);\n\n\treturn result;\n}\n\n\nint\nguc_set(PGconn *conn, const char *parameter, const char *op,\n\t\tconst char *value)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tint\t\t\tretval = 1;\n\n\tchar\t   *escaped_parameter = escape_string(conn, parameter);\n\tchar\t   *escaped_value = escape_string(conn, value);\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT true FROM pg_catalog.pg_settings \"\n\t\t\t\t\t  \" WHERE name = '%s' AND setting %s '%s'\",\n\t\t\t\t\t  escaped_parameter, op, escaped_value);\n\n\tlog_verbose(LOG_DEBUG, \"guc_set():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"guc_set(): unable to execute query\"));\n\t\tretval = -1;\n\t}\n\telse if (PQntuples(res) == 0)\n\t{\n\t\tretval = 0;\n\t}\n\n\tpfree(escaped_parameter);\n\tpfree(escaped_value);\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn retval;\n}\n\n\nbool\nget_pg_setting(PGconn *conn, const char *setting, char *output)\n{\n\tbool success = _get_pg_setting(conn, setting, output, NULL, NULL);\n\n\tif (success == true)\n\t{\n\t\tlog_verbose(LOG_DEBUG, _(\"get_pg_setting(): returned value is \\\"%s\\\"\"), output);\n\t}\n\n\treturn success;\n}\n\nbool\nget_pg_setting_bool(PGconn *conn, const char *setting, bool *output)\n{\n\tbool success = _get_pg_setting(conn, setting, NULL, output, NULL);\n\n\tif (success == true)\n\t{\n\t\tlog_verbose(LOG_DEBUG, _(\"get_pg_setting(): returned value is \\\"%s\\\"\"),\n\t\t\t\t\t*output == true ? \"TRUE\" : \"FALSE\");\n\t}\n\n\treturn success;\n}\n\nbool\nget_pg_setting_int(PGconn *conn, const char *setting, int *output)\n{\n\tbool success = _get_pg_setting(conn, setting, NULL, NULL, output);\n\n\tif (success == true)\n\t{\n\t\tlog_verbose(LOG_DEBUG, _(\"get_pg_setting_int(): returned value is \\\"%i\\\"\"), *output);\n\t}\n\n\treturn success;\n}\n\n\nbool\n_get_pg_setting(PGconn *conn, const char *setting, char *str_output, bool *bool_output, int *int_output)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tint\t\t\ti;\n\tbool\t\tsuccess = false;\n\n\tchar\t   *escaped_setting = escape_string(conn, setting);\n\n\tif (escaped_setting == NULL)\n\t{\n\t\tlog_error(_(\"unable to escape setting \\\"%s\\\"\"), setting);\n\t\treturn false;\n\t}\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT name, setting \"\n\t\t\t\t\t  \"  FROM pg_catalog.pg_settings WHERE name = '%s'\",\n\t\t\t\t\t  escaped_setting);\n\n\tlog_verbose(LOG_DEBUG, \"get_pg_setting():\\n  %s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tpfree(escaped_setting);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"get_pg_setting() - unable to execute query\"));\n\n\t\ttermPQExpBuffer(&query);\n\t\tPQclear(res);\n\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < PQntuples(res); i++)\n\t{\n\t\tif (strcmp(PQgetvalue(res, i, 0), setting) == 0)\n\t\t{\n\t\t\tif (str_output != NULL)\n\t\t\t{\n\t\t\t\tsnprintf(str_output, MAXLEN, \"%s\", PQgetvalue(res, i, 1));\n\t\t\t}\n\t\t\telse if (bool_output != NULL)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Note we assume the caller is sure this is a boolean parameter\n\t\t\t\t */\n\t\t\t\tif (strncmp(PQgetvalue(res, i, 1), \"on\", MAXLEN) == 0)\n\t\t\t\t\t*bool_output = true;\n\t\t\t\telse\n\t\t\t\t\t*bool_output = false;\n\t\t\t}\n\t\t\telse if (int_output != NULL)\n\t\t\t{\n\t\t\t\t*int_output = atoi(PQgetvalue(res, i, 1));\n\t\t\t}\n\n\t\t\tsuccess = true;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* highly unlikely this would ever happen */\n\t\t\tlog_error(_(\"get_pg_setting(): unknown parameter \\\"%s\\\"\"), PQgetvalue(res, i, 0));\n\t\t}\n\t}\n\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\n\nbool\nalter_system_int(PGconn *conn, const char *name, int value)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"ALTER SYSTEM SET %s = %i\",\n\t\t\t\t\t  name, value);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"alter_system_int() - unable to execute query\"));\n\n\t\tsuccess = false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\nbool\npg_reload_conf(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tres = PQexec(conn, \"SELECT pg_catalog.pg_reload_conf()\");\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, NULL, _(\"pg_reload_conf() - unable to execute query\"));\n\n\t\tsuccess = false;\n\t}\n\n\tPQclear(res);\n\n\treturn success;\n}\n\n\n/* ============================ */\n/* Server information functions */\n/* ============================ */\n\n\nbool\nget_cluster_size(PGconn *conn, char *size)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"SELECT pg_catalog.pg_size_pretty(pg_catalog.sum(pg_catalog.pg_database_size(oid))::bigint) \"\n\t\t\t\t\t\t \"  FROM pg_catalog.pg_database \");\n\n\tlog_verbose(LOG_DEBUG, \"get_cluster_size():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t\tsuccess = false;\n\telse\n\t\tsnprintf(size, MAXLEN, \"%s\", PQgetvalue(res, 0, 0));\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\n/*\n * Return the server version number for the connection provided\n */\nint\nget_server_version(PGconn *conn, char *server_version_buf)\n{\n\tPGresult   *res = NULL;\n\tint\t\t\t_server_version_num = UNKNOWN_SERVER_VERSION_NUM;\n\n\tconst char\t   *sqlquery =\n\t\t\"SELECT pg_catalog.current_setting('server_version_num'), \"\n\t\t\"       pg_catalog.current_setting('server_version')\";\n\n\tres = PQexec(conn, sqlquery);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, sqlquery, _(\"unable to determine server version number\"));\n\t\tPQclear(res);\n\n\t\treturn UNKNOWN_SERVER_VERSION_NUM;\n\t}\n\n\t_server_version_num = atoi(PQgetvalue(res, 0, 0));\n\n\tif (server_version_buf != NULL)\n\t{\n\t\tint\t\t\ti;\n\t\tchar\t\t_server_version_buf[MAXVERSIONSTR] = \"\";\n\n\t\tmemset(_server_version_buf, 0, MAXVERSIONSTR);\n\n\t\t/*\n\t\t * Some distributions may add extra info after the actual version number,\n\t\t * e.g. \"10.4 (Debian 10.4-2.pgdg90+1)\", so copy everything up until the\n\t\t * first space.\n\t\t */\n\n\t\tsnprintf(_server_version_buf, MAXVERSIONSTR, \"%s\", PQgetvalue(res, 0, 1));\n\n\t\tfor (i = 0; i < MAXVERSIONSTR; i++)\n\t\t{\n\t\t\tif (_server_version_buf[i] == ' ')\n\t\t\t\tbreak;\n\n\t\t\t*server_version_buf++ = _server_version_buf[i];\n\t\t}\n\t}\n\n\tPQclear(res);\n\n\treturn _server_version_num;\n}\n\n\nRecoveryType\nget_recovery_type(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\tRecoveryType recovery_type = RECTYPE_UNKNOWN;\n\n\tconst char\t   *sqlquery = \"SELECT pg_catalog.pg_is_in_recovery()\";\n\n\tlog_verbose(LOG_DEBUG, \"get_recovery_type(): %s\", sqlquery);\n\n\tres = PQexec(conn, sqlquery);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn,\n\t\t\t\t\t sqlquery,\n\t\t\t\t\t _(\"unable to determine if server is in recovery\"));\n\n\t\trecovery_type = RECTYPE_UNKNOWN;\n\t}\n\telse if (PQntuples(res) == 1)\n\t{\n\t\tif (strcmp(PQgetvalue(res, 0, 0), \"f\") == 0)\n\t\t{\n\t\t\trecovery_type = RECTYPE_PRIMARY;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trecovery_type = RECTYPE_STANDBY;\n\t\t}\n\t}\n\n\tPQclear(res);\n\n\treturn recovery_type;\n}\n\n/*\n * Read the node list from the provided connection and attempt to connect to each node\n * in turn to definitely establish if it's the cluster primary.\n *\n * The node list is returned in the order which makes it likely that the\n * current primary will be returned first, reducing the number of speculative\n * connections which need to be made to other nodes.\n *\n * If primary_conninfo_out points to allocated memory of MAXCONNINFO in length,\n * the primary server's conninfo string will be copied there.\n */\n\nPGconn *\n_get_primary_connection(PGconn *conn,\n\t\t\t\t\t\tint *primary_id, char *primary_conninfo_out, bool quiet)\n{\n\tPQExpBufferData query;\n\n\tPGconn\t   *remote_conn = NULL;\n\tPGresult   *res = NULL;\n\n\tchar\t\tremote_conninfo_stack[MAXCONNINFO];\n\tchar\t   *remote_conninfo = &*remote_conninfo_stack;\n\n\tint\t\t\ti,\n\t\t\t\tnode_id;\n\n\t/*\n\t * If the caller wanted to get a copy of the connection info string, sub\n\t * out the local stack pointer for the pointer passed by the caller.\n\t */\n\tif (primary_conninfo_out != NULL)\n\t\tremote_conninfo = primary_conninfo_out;\n\n\tif (primary_id != NULL)\n\t{\n\t\t*primary_id = NODE_NOT_FOUND;\n\t}\n\n\t/* find all registered nodes  */\n\tlog_verbose(LOG_INFO, _(\"searching for primary node\"));\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"  SELECT node_id, conninfo, \"\n\t\t\t\t\t\t \"         CASE WHEN type = 'primary' THEN 1 ELSE 2 END AS type_priority\"\n\t\t\t\t\t\t \"\t   FROM repmgr.nodes \"\n\t\t\t\t\t\t \"   WHERE active IS TRUE \"\n\t\t\t\t\t\t \"     AND type != 'witness' \"\n\t\t\t\t\t\t \"ORDER BY active DESC, type_priority, priority, node_id\");\n\n\tlog_verbose(LOG_DEBUG, \"get_primary_connection():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"_get_primary_connection(): unable to retrieve node records\"));\n\n\t\ttermPQExpBuffer(&query);\n\t\tPQclear(res);\n\n\t\treturn NULL;\n\t}\n\n\ttermPQExpBuffer(&query);\n\n\tfor (i = 0; i < PQntuples(res); i++)\n\t{\n\t\tRecoveryType recovery_type;\n\n\t\t/* initialize with the values of the current node being processed */\n\t\tnode_id = atoi(PQgetvalue(res, i, 0));\n\t\tsnprintf(remote_conninfo, MAXCONNINFO, \"%s\", PQgetvalue(res, i, 1));\n\n\t\tlog_verbose(LOG_INFO,\n\t\t\t\t\t_(\"checking if node %i is primary\"),\n\t\t\t\t\tnode_id);\n\n\t\tif (quiet)\n\t\t{\n\t\t\tremote_conn = establish_db_connection_quiet(remote_conninfo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tremote_conn = establish_db_connection(remote_conninfo, false);\n\t\t}\n\n\t\tif (PQstatus(remote_conn) != CONNECTION_OK)\n\t\t{\n\t\t\tPQfinish(remote_conn);\n\t\t\tremote_conn = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\trecovery_type = get_recovery_type(remote_conn);\n\n\t\tif (recovery_type == RECTYPE_UNKNOWN)\n\t\t{\n\t\t\tlog_warning(_(\"unable to retrieve recovery state from node %i\"),\n\t\t\t\t\t\tnode_id);\n\n\t\t\tPQfinish(remote_conn);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (recovery_type == RECTYPE_PRIMARY)\n\t\t{\n\t\t\tPQclear(res);\n\t\t\tlog_verbose(LOG_INFO, _(\"current primary node is %i\"), node_id);\n\n\t\t\tif (primary_id != NULL)\n\t\t\t{\n\t\t\t\t*primary_id = node_id;\n\t\t\t}\n\n\t\t\treturn remote_conn;\n\t\t}\n\n\t\tPQfinish(remote_conn);\n\t}\n\n\tPQclear(res);\n\treturn NULL;\n}\n\n\n\n/*\n * Return the id of the active primary node, or NODE_NOT_FOUND if no\n * record available.\n *\n * This reports the value stored in the database only and\n * does not verify whether the node is actually available\n */\nint\nget_primary_node_id(PGconn *conn)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tint\t\t\tretval = NODE_NOT_FOUND;\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"SELECT node_id\t\t  \"\n\t\t\t\t\t\t \"\t FROM repmgr.nodes    \"\n\t\t\t\t\t\t \" WHERE type = 'primary' \"\n\t\t\t\t\t\t \"   AND active IS TRUE  \");\n\n\tlog_verbose(LOG_DEBUG, \"get_primary_node_id():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"get_primary_node_id(): unable to execute query\"));\n\t\tretval = UNKNOWN_NODE_ID;\n\t}\n\telse if (PQntuples(res) == 0)\n\t{\n\t\tlog_verbose(LOG_WARNING, _(\"get_primary_node_id(): no active primary found\"));\n\t\tretval = NODE_NOT_FOUND;\n\t}\n\telse\n\t{\n\t\tretval = atoi(PQgetvalue(res, 0, 0));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn retval;\n}\n\n\n\n\nint\nget_ready_archive_files(PGconn *conn, const char *data_directory)\n{\n\tchar\t\tarchive_status_dir[MAXPGPATH] = \"\";\n\tstruct stat statbuf;\n\tstruct dirent *arcdir_ent;\n\tDIR\t\t   *arcdir;\n\n\tint\t\t\tready_count = 0;\n\n\tif (PQserverVersion(conn) >= 100000)\n\t{\n\t\tsnprintf(archive_status_dir, MAXPGPATH,\n\t\t\t\t \"%s/pg_wal/archive_status\",\n\t\t\t\t data_directory);\n\t}\n\telse\n\t{\n\t\tsnprintf(archive_status_dir, MAXPGPATH,\n\t\t\t\t \"%s/pg_xlog/archive_status\",\n\t\t\t\t data_directory);\n\t}\n\n\t/* sanity-check directory path */\n\tif (stat(archive_status_dir, &statbuf) == -1)\n\t{\n\t\tlog_error(_(\"unable to access archive_status directory \\\"%s\\\"\"),\n\t\t\t\t  archive_status_dir);\n\t\tlog_detail(\"%s\", strerror(errno));\n\n\t\treturn ARCHIVE_STATUS_DIR_ERROR;\n\t}\n\n\tarcdir = opendir(archive_status_dir);\n\n\tif (arcdir == NULL)\n\t{\n\t\tlog_error(_(\"unable to open archive directory \\\"%s\\\"\"),\n\t\t\t\t  archive_status_dir);\n\t\tlog_detail(\"%s\", strerror(errno));\n\n\t\treturn ARCHIVE_STATUS_DIR_ERROR;\n\t}\n\n\twhile ((arcdir_ent = readdir(arcdir)) != NULL)\n\t{\n\t\tstruct stat local_statbuf;\n\t\tchar\t\tfile_path[MAXPGPATH + sizeof(arcdir_ent->d_name)];\n\t\tint\t\t\tbasenamelen = 0;\n\n\t\tsnprintf(file_path, sizeof(file_path),\n\t\t\t\t \"%s/%s\",\n\t\t\t\t archive_status_dir,\n\t\t\t\t arcdir_ent->d_name);\n\n\t\t/* skip non-files */\n\t\tif (stat(file_path, &local_statbuf) == 0 && !S_ISREG(local_statbuf.st_mode))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tbasenamelen = (int) strlen(arcdir_ent->d_name) - 6;\n\n\t\t/*\n\t\t * count anything ending in \".ready\"; for a more precise\n\t\t * implementation see: src/backend/postmaster/pgarch.c\n\t\t */\n\t\tif (strcmp(arcdir_ent->d_name + basenamelen, \".ready\") == 0)\n\t\t\tready_count++;\n\t}\n\n\tclosedir(arcdir);\n\n\treturn ready_count;\n}\n\n\nbool\nidentify_system(PGconn *repl_conn, t_system_identification *identification)\n{\n\tPGresult   *res = NULL;\n\n\t/* semicolon required here */\n\tres = PQexec(repl_conn, \"IDENTIFY_SYSTEM;\");\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK || !PQntuples(res))\n\t{\n\t\tlog_db_error(repl_conn, NULL, _(\"unable to execute IDENTIFY_SYSTEM\"));\n\n\t\tPQclear(res);\n\t\treturn false;\n\t}\n\n#if defined(__i386__) || defined(__i386)\n\tidentification->system_identifier = atoll(PQgetvalue(res, 0, 0));\n#else\n\tidentification->system_identifier = atol(PQgetvalue(res, 0, 0));\n#endif\n\n\tidentification->timeline = atoi(PQgetvalue(res, 0, 1));\n\tidentification->xlogpos = parse_lsn(PQgetvalue(res, 0, 2));\n\n\tPQclear(res);\n\treturn true;\n}\n\n\n/*\n * Return the system identifier by querying pg_control_system().\n *\n * Note there is a similar function in controldata.c (\"get_system_identifier()\")\n * which reads the control file.\n */\nuint64\nsystem_identifier(PGconn *conn)\n{\n\tuint64\t\tsystem_identifier = UNKNOWN_SYSTEM_IDENTIFIER;\n\tPGresult   *res = NULL;\n\n\t/*\n\t * pg_control_system() was introduced in PostgreSQL 9.6\n\t */\n\tif (PQserverVersion(conn) < 90600)\n\t{\n\t\treturn UNKNOWN_SYSTEM_IDENTIFIER;\n\t}\n\n\tres = PQexec(conn, \"SELECT system_identifier FROM pg_catalog.pg_control_system()\");\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, NULL, _(\"system_identifier(): unable to query pg_control_system()\"));\n\t}\n\telse\n\t{\n#if defined(__i386__) || defined(__i386)\n\t\tsystem_identifier = atoll(PQgetvalue(res, 0, 0));\n#else\n\t\tsystem_identifier = atol(PQgetvalue(res, 0, 0));\n#endif\n\t}\n\n\tPQclear(res);\n\n\treturn system_identifier;\n}\n\n\nTimeLineHistoryEntry *\nget_timeline_history(PGconn *repl_conn, TimeLineID tli)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\n\tPQExpBufferData result;\n\tchar\t\t*resptr;\n\n\tTimeLineHistoryEntry *history;\n\tTimeLineID\tfile_tli = UNKNOWN_TIMELINE_ID;\n\tuint32\t\tswitchpoint_hi;\n\tuint32\t\tswitchpoint_lo;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"TIMELINE_HISTORY %i\",\n\t\t\t\t\t  (int)tli);\n\n\tres = PQexec(repl_conn, query.data);\n\tlog_verbose(LOG_DEBUG, \"get_timeline_history():\\n%s\", query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(repl_conn, query.data, _(\"get_timeline_history(): unable to execute query\"));\n\t\ttermPQExpBuffer(&query);\n\t\tPQclear(res);\n\t\treturn NULL;\n\t}\n\n\ttermPQExpBuffer(&query);\n\n\tif (PQntuples(res) != 1 || PQnfields(res) != 2)\n\t{\n\t\tlog_error(_(\"unexpected response to TIMELINE_HISTORY command\"));\n\t\tlog_detail(_(\"got %i rows and %i fields, expected %i rows and %i fields\"),\n\t\t\t\t   PQntuples(res), PQnfields(res), 1, 2);\n\t\tPQclear(res);\n\t\treturn NULL;\n\t}\n\n\tinitPQExpBuffer(&result);\n\tappendPQExpBufferStr(&result, PQgetvalue(res, 0, 1));\n\tPQclear(res);\n\n\tresptr = result.data;\n\n\twhile (*resptr)\n\t{\n\t\tchar\tbuf[MAXLEN];\n\t\tchar   *bufptr = buf;\n\n\t\tif (*resptr != '\\n')\n\t\t{\n\t\t\tint\t\tlen  = 0;\n\n\t\t\tmemset(buf, 0, MAXLEN);\n\n\t\t\twhile (*resptr && *resptr != '\\n' && len < MAXLEN)\n\t\t\t{\n\t\t\t\t*bufptr++ = *resptr++;\n\t\t\t\tlen++;\n\t\t\t}\n\n\t\t\tif (buf[0])\n\t\t\t{\n\t\t\t\tint nfields = sscanf(buf,\n\t\t\t\t\t\t\t\t\t \"%u\\t%X/%X\",\n\t\t\t\t\t\t\t\t\t &file_tli, &switchpoint_hi, &switchpoint_lo);\n\t\t\t\tif (nfields == 3 && file_tli == tli - 1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (*resptr)\n\t\t\tresptr++;\n\t}\n\n\ttermPQExpBuffer(&result);\n\n\tif (file_tli == UNKNOWN_TIMELINE_ID || file_tli != tli - 1)\n\t{\n\t\tlog_error(_(\"timeline %i not found in timeline history file content\"), tli);\n\t\tlog_detail(_(\"content is: \\\"%s\\\"\"), result.data);\n\t\treturn NULL;\n\t}\n\n\thistory = (TimeLineHistoryEntry *) palloc(sizeof(TimeLineHistoryEntry));\n\thistory->tli = file_tli;\n\thistory->begin = InvalidXLogRecPtr; /* we don't care about this */\n\thistory->end = ((uint64) (switchpoint_hi)) << 32 | (uint64) switchpoint_lo;\n\n\treturn history;\n}\n\n\npid_t\nget_wal_receiver_pid(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\tpid_t\t\twal_receiver_pid = UNKNOWN_PID;\n\n\tres = PQexec(conn, \"SELECT repmgr.get_wal_receiver_pid()\");\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_error(_(\"unable to execute \\\"SELECT repmgr.get_wal_receiver_pid()\\\"\"));\n\t\tlog_detail(\"%s\", PQerrorMessage(conn));\n\t}\n\telse if (!PQgetisnull(res, 0, 0))\n\t{\n\t\twal_receiver_pid = atoi(PQgetvalue(res, 0, 0));\n\t}\n\n\tPQclear(res);\n\n\treturn wal_receiver_pid;\n}\n\n\n/* =============================== */\n/* user/role information functions */\n/* =============================== */\n\n\n/*\n * Determine if the user associated with the current connection can execute CHECKPOINT command.\n * User must be a supersuer or a member of the pg_checkpoint default role (available from PostgreSQL 15).\n */\nbool\ncan_execute_checkpoint(PGconn *conn)\n{\n\tPQExpBufferData query;\n\tPGresult   *res;\n\tbool\t\thas_pg_checkpoint_role = false;\n\n\t/* superusers can do anything, no role check needed */\n\tif (is_superuser_connection(conn, NULL) == true)\n\t\treturn true;\n\n\t/* pg_checkpoint available from PostgreSQL 15 */\n\tif (PQserverVersion(conn) < 150000)\n\t\treturn false;\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \" SELECT pg_catalog.pg_has_role('pg_checkpoint','USAGE') \");\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"can_execute_checkpoint(): unable to query user roles\"));\n\t}\n\telse\n\t{\n\t\thas_pg_checkpoint_role = atobool(PQgetvalue(res, 0, 0));\n\t}\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn has_pg_checkpoint_role;\n}\n\n\n/*\n * Determine if the user associated with the current connection\n * has sufficient permissions to use pg_promote function\n */\nbool\ncan_execute_pg_promote(PGconn *conn)\n{\n\tPQExpBufferData query;\n\tPGresult   *res;\n\tbool\t\thas_pg_promote= false;\n\n\t/* pg_promote() available from PostgreSQL 12 */\n\tif (PQserverVersion(conn) < 120000)\n\t\treturn false;\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \" SELECT pg_catalog.has_function_privilege( \"\n\t\t\t\t\t\t \"    CURRENT_USER, \"\n\t\t\t\t\t\t \"    'pg_catalog.pg_promote(bool,int)', \"\n\t\t\t\t\t\t \"    'execute' \"\n\t\t\t\t\t\t \" )\");\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"can_execute_pg_promote(): unable to query user function privilege\"));\n\t}\n\telse\n\t{\n\t\thas_pg_promote = atobool(PQgetvalue(res, 0, 0));\n\t}\n\ttermPQExpBuffer(&query);\n\n\treturn has_pg_promote;\n}\n\n\n/*\n * Determine if the user associated with the current connection\n * has sufficient permissions to disable the walsender\n */\nbool\ncan_disable_walsender(PGconn *conn)\n{\n\t/*\n\t * Requires PostgreSQL 9.5 or later, because ALTER SYSTEM\n\t */\n\tif (PQserverVersion(conn) < 90500)\n\t{\n\t\tlog_warning(_(\"\\\"standby_disconnect_on_failover\\\" specified, but not available for this PostgreSQL version\"));\n\t\t/* TODO: format server version */\n\t\tlog_detail(_(\"available from PostgreSQL 9.5; this PostgreSQL version is %i\"), PQserverVersion(conn));\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * Superusers can do anything\n\t */\n\tif (is_superuser_connection(conn, NULL) == true)\n\t\treturn true;\n\n\tPQExpBufferData query;\n\tPGresult   *res;\n\tbool\t\thas_alter_system_priv = false;\n\n\t/* GRANT ALTER SYSTEM available from PostgreSQL 15 */\n\tif (PQserverVersion(conn) >= 150000)\n\t{\n\t\tinitPQExpBuffer(&query);\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\" SELECT pg_catalog.has_parameter_privilege('wal_retrieve_retry_interval', 'ALTER SYSTEM') \");\n\n\t\tres = PQexec(conn, query.data);\n\n\t\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t\t{\n\t\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t_(\"can_disable_walsender(): unable to query user parameter privileges\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\thas_alter_system_priv = atobool(PQgetvalue(res, 0, 0));\n\t\t}\n\t\ttermPQExpBuffer(&query);\n\t\tPQclear(res);\n\t}\n\n\tif (has_alter_system_priv == false)\n\t{\n\t\tlog_warning(_(\"\\\"standby_disconnect_on_failover\\\" specified, but repmgr user is not authorized to perform ALTER SYSTEM wal_retrieve_retry_interval\"));\n\n\t\tif (PQserverVersion(conn) >= 150000)\n\t\t{\n\t\t\tlog_detail(_(\"superuser or ALTER SYSTEM wal_retrieve_retry_interval permission required to disable standbys on failover\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_detail(_(\"superuser permission required to disable standbys on failover\"));\n\t\t}\n\t}\n\n\treturn has_alter_system_priv;\n}\n\n/*\n * Determine if the user associated with the current connection is\n * a member of the \"pg_monitor\" default role, or optionally one\n * of its three constituent \"subroles\".\n */\nbool\nconnection_has_pg_monitor_role(PGconn *conn, const char *subrole)\n{\n\tPQExpBufferData query;\n\tPGresult   *res;\n\tbool\t\thas_pg_monitor_role = false;\n\n\t/* superusers can read anything, no role check needed */\n\tif (is_superuser_connection(conn, NULL) == true)\n\t\treturn true;\n\n\t/* pg_monitor and associated \"subroles\" introduced in PostgreSQL 10 */\n\tif (PQserverVersion(conn) < 100000)\n\t\treturn false;\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"  SELECT CASE \"\n\t\t\t\t\t\t \"           WHEN pg_catalog.pg_has_role('pg_monitor','USAGE') \"\n\t\t\t\t\t\t \"             THEN TRUE \");\n\n\tif (subrole != NULL)\n\t{\n\t\tappendPQExpBuffer(&query,\n\t\t\t\t\t\t  \"           WHEN pg_catalog.pg_has_role('%s','USAGE') \"\n\t\t\t\t\t\t  \"             THEN TRUE \",\n\t\t\t\t\t\t  subrole);\n\t}\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"           ELSE FALSE \"\n\t\t\t\t\t\t \"         END AS has_pg_monitor\");\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"connection_has_pg_monitor_role(): unable to query user roles\"));\n\t}\n\telse\n\t{\n\t\thas_pg_monitor_role = atobool(PQgetvalue(res, 0, 0));\n\t}\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn has_pg_monitor_role;\n}\n\n\nbool\nis_replication_role(PGconn *conn, char *rolname)\n{\n\tPQExpBufferData query;\n\tPGresult   *res;\n\tbool\t\tis_replication_role = false;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"  SELECT rolreplication \"\n\t\t\t\t\t\t \"    FROM pg_catalog.pg_roles \"\n\t\t\t\t\t\t \"   WHERE rolname = \");\n\n\tif (rolname != NULL)\n\t{\n\t\tappendPQExpBuffer(&query,\n\t\t\t\t\t\t  \"'%s'\",\n\t\t\t\t\t\t  rolname);\n\t}\n\telse\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \"CURRENT_USER\");\n\t}\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"is_replication_role(): unable to query user roles\"));\n\t}\n\telse\n\t{\n\t\tis_replication_role = atobool(PQgetvalue(res, 0, 0));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn is_replication_role;\n}\n\n\nbool\nis_superuser_connection(PGconn *conn, t_connection_user *userinfo)\n{\n\tbool\t\tis_superuser = false;\n\tconst char *current_user = PQuser(conn);\n\tconst char *superuser_status = PQparameterStatus(conn, \"is_superuser\");\n\n\tis_superuser = (strcmp(superuser_status, \"on\") == 0) ? true : false;\n\n\tif (userinfo != NULL)\n\t{\n\t\tsnprintf(userinfo->username,\n\t\t\t\t sizeof(userinfo->username),\n\t\t\t\t \"%s\", current_user);\n\t\tuserinfo->is_superuser = is_superuser;\n\t}\n\n\treturn is_superuser;\n}\n\n\n/* =============================== */\n/* repmgrd shared memory functions */\n/* =============================== */\n\nbool\nrepmgrd_set_local_node_id(PGconn *conn, int local_node_id)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT repmgr.set_local_node_id(%i)\",\n\t\t\t\t\t  local_node_id);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"repmgrd_set_local_node_id(): unable to execute query\"));\n\n\t\tsuccess = false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\nint\nrepmgrd_get_local_node_id(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\tint\t\t\tlocal_node_id = UNKNOWN_NODE_ID;\n\n\tconst char *sqlquery = \"SELECT repmgr.get_local_node_id()\";\n\n\tres = PQexec(conn, sqlquery);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, sqlquery, _(\"repmgrd_get_local_node_id(): unable to execute query\"));\n\t}\n\telse if (!PQgetisnull(res, 0, 0))\n\t{\n\t\tlocal_node_id = atoi(PQgetvalue(res, 0, 0));\n\t}\n\n\tPQclear(res);\n\n\treturn local_node_id;\n}\n\n\nbool\nrepmgrd_check_local_node_id(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\tbool\t\tnode_id_settable = true;\n\tconst char *sqlquery = \"SELECT repmgr.get_local_node_id()\";\n\n\tres = PQexec(conn, sqlquery);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, sqlquery, _(\"repmgrd_get_local_node_id(): unable to execute query\"));\n\t}\n\n\tif (PQgetisnull(res, 0, 0))\n\t{\n\t\tnode_id_settable = false;\n\t}\n\n\tPQclear(res);\n\n\treturn node_id_settable;\n}\n\n\n/*\n * Function that checks if the primary is in exclusive backup mode.\n * We'll use this when executing an action can conflict with an exclusive\n * backup.\n */\nBackupState\nserver_in_exclusive_backup_mode(PGconn *conn)\n{\n\tBackupState backup_state = BACKUP_STATE_UNKNOWN;\n\tconst char *sqlquery = \"SELECT pg_catalog.pg_is_in_backup()\";\n\tPGresult   *res = NULL;\n\n\t/* Exclusive backup removed from PostgreSQL 15 */\n\tif (PQserverVersion(conn) >= 150000)\n\t\treturn BACKUP_STATE_NO_BACKUP;\n\n\tres = PQexec(conn, sqlquery);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, sqlquery, _(\"unable to retrieve information regarding backup mode of node\"));\n\n\t\tbackup_state = BACKUP_STATE_UNKNOWN;\n\t}\n\telse if (atobool(PQgetvalue(res, 0, 0)) == true)\n\t{\n\t\tbackup_state = BACKUP_STATE_IN_BACKUP;\n\t}\n\telse\n\t{\n\t\tbackup_state = BACKUP_STATE_NO_BACKUP;\n\t}\n\n\tPQclear(res);\n\n\treturn backup_state;\n}\n\n\nvoid\nrepmgrd_set_pid(PGconn *conn, pid_t repmgrd_pid, const char *pidfile)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\n\tlog_verbose(LOG_DEBUG, \"repmgrd_set_pid(): pid is %i\", (int) repmgrd_pid);\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT repmgr.set_repmgrd_pid(%i, \",\n\t\t\t\t\t  (int) repmgrd_pid);\n\n\tif (pidfile != NULL)\n\t{\n\t\tappendPQExpBuffer(&query,\n\t\t\t\t\t\t  \" '%s')\",\n\t\t\t\t\t\t  pidfile);\n\t}\n\telse\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \" NULL)\");\n\t}\n\n\tres = PQexec(conn, query.data);\n\ttermPQExpBuffer(&query);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_error(_(\"unable to execute \\\"SELECT repmgr.set_repmgrd_pid()\\\"\"));\n\t\tlog_detail(\"%s\", PQerrorMessage(conn));\n\t}\n\n\tPQclear(res);\n\n\treturn;\n}\n\n\npid_t\nrepmgrd_get_pid(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\tpid_t\t\trepmgrd_pid = UNKNOWN_PID;\n\n\tres = PQexec(conn, \"SELECT repmgr.get_repmgrd_pid()\");\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_error(_(\"unable to execute \\\"SELECT repmgr.get_repmgrd_pid()\\\"\"));\n\t\tlog_detail(\"%s\", PQerrorMessage(conn));\n\t}\n\telse if (!PQgetisnull(res, 0, 0))\n\t{\n\t\trepmgrd_pid = atoi(PQgetvalue(res, 0, 0));\n\t}\n\n\tPQclear(res);\n\n\treturn repmgrd_pid;\n}\n\n\nbool\nrepmgrd_is_running(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\tbool\t\tis_running = false;\n\n\tres = PQexec(conn, \"SELECT repmgr.repmgrd_is_running()\");\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_error(_(\"unable to execute \\\"SELECT repmgr.repmgrd_is_running()\\\"\"));\n\t\tlog_detail(\"%s\", PQerrorMessage(conn));\n\t}\n\telse if (!PQgetisnull(res, 0, 0))\n\t{\n\t\tis_running = atobool(PQgetvalue(res, 0, 0));\n\t}\n\n\tPQclear(res);\n\n\treturn is_running;\n}\n\n\nbool\nrepmgrd_is_paused(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\tbool\t\tis_paused = false;\n\n\tres = PQexec(conn, \"SELECT repmgr.repmgrd_is_paused()\");\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_error(_(\"unable to execute \\\"SELECT repmgr.repmgrd_is_paused()\\\"\"));\n\t\tlog_detail(\"%s\", PQerrorMessage(conn));\n\t}\n\telse if (!PQgetisnull(res, 0, 0))\n\t{\n\t\tis_paused = atobool(PQgetvalue(res, 0, 0));\n\t}\n\n\tPQclear(res);\n\n\treturn is_paused;\n}\n\n\nbool\nrepmgrd_pause(PGconn *conn, bool pause)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT repmgr.repmgrd_pause(%s)\",\n\t\t\t\t\t  pause == true ? \"TRUE\" : \"FALSE\");\n\tres = PQexec(conn, query.data);\n\ttermPQExpBuffer(&query);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_error(_(\"unable to execute \\\"SELECT repmgr.repmgrd_pause()\\\"\"));\n\t\tlog_detail(\"%s\", PQerrorMessage(conn));\n\n\t\tsuccess = false;\n\t}\n\n\tPQclear(res);\n\n\treturn success;\n}\n\n\nint\nrepmgrd_get_upstream_node_id(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\tint upstream_node_id = UNKNOWN_NODE_ID;\n\n\tconst char *sqlquery = \"SELECT repmgr.get_upstream_node_id()\";\n\n\tres = PQexec(conn, sqlquery);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, sqlquery, _(\"repmgrd_get_upstream_node_id(): unable to execute query\"));\n\t}\n\telse if (!PQgetisnull(res, 0, 0))\n\t{\n\t\tupstream_node_id = atoi(PQgetvalue(res, 0, 0));\n\t}\n\n\tPQclear(res);\n\n\treturn upstream_node_id;\n}\n\n\nbool\nrepmgrd_set_upstream_node_id(PGconn *conn, int node_id)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \" SELECT repmgr.set_upstream_node_id(%i) \",\n\t\t\t\t\t  node_id);\n\n\tlog_verbose(LOG_DEBUG, \"repmgrd_set_upstream_node_id():\\n  %s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"repmgrd_set_upstream_node_id(): unable to set upstream node ID (provided value: %i)\"), node_id);\n\t\tsuccess = false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n/* ================ */\n/* result functions */\n/* ================ */\n\nbool\natobool(const char *value)\n{\n\treturn (strcmp(value, \"t\") == 0)\n\t\t? true\n\t\t: false;\n}\n\n\n/* =================== */\n/* extension functions */\n/* =================== */\n\nExtensionStatus\nget_repmgr_extension_status(PGconn *conn, t_extension_versions *extversions)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tExtensionStatus status = REPMGR_UNKNOWN;\n\n\t/* TODO: check version */\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"\t  SELECT ae.name, e.extname, \"\n\t\t\t\t\t\t \"           ae.default_version, \"\n\t\t\t\t\t\t \"           (((FLOOR(ae.default_version::NUMERIC)::INT) * 10000) + (ae.default_version::NUMERIC - FLOOR(ae.default_version::NUMERIC)::INT) * 1000)::INT AS available, \"\n\t\t\t\t\t\t \"           ae.installed_version, \"\n\t\t\t\t\t\t \"           (((FLOOR(ae.installed_version::NUMERIC)::INT) * 10000) + (ae.installed_version::NUMERIC - FLOOR(ae.installed_version::NUMERIC)::INT) * 1000)::INT AS installed \"\n\t\t\t\t\t\t \"     FROM pg_catalog.pg_available_extensions ae \"\n\t\t\t\t\t\t \"LEFT JOIN pg_catalog.pg_extension e \"\n\t\t\t\t\t\t \"       ON e.extname=ae.name \"\n\t\t\t\t\t\t \"\t   WHERE ae.name='repmgr' \");\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"get_repmgr_extension_status(): unable to execute extension query\"));\n\t\tstatus = REPMGR_UNKNOWN;\n\t}\n\n\t/* 1. Check extension is actually available */\n\telse if (PQntuples(res) == 0)\n\t{\n\t\tstatus = REPMGR_UNAVAILABLE;\n\t}\n\n\t/* 2. Check if extension installed */\n\telse if (PQgetisnull(res, 0, 1) == 0)\n\t{\n\t\tint available_version = atoi(PQgetvalue(res, 0, 3));\n\t\tint installed_version = atoi(PQgetvalue(res, 0, 5));\n\n\t\t/* caller wants to know which versions are installed/available */\n\t\tif (extversions != NULL)\n\t\t{\n\t\t\tsnprintf(extversions->default_version,\n\t\t\t\t\t sizeof(extversions->default_version),\n\t\t\t\t\t \"%s\", PQgetvalue(res, 0, 2));\n\t\t\textversions->default_version_num = available_version;\n\t\t\tsnprintf(extversions->installed_version,\n\t\t\t\t\t sizeof(extversions->installed_version),\n\t\t\t\t\t \"%s\", PQgetvalue(res, 0, 4));\n\t\t\textversions->installed_version_num = installed_version;\n\t\t}\n\n\t\tif (available_version > installed_version)\n\t\t{\n\t\t\tstatus = REPMGR_OLD_VERSION_INSTALLED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatus = REPMGR_INSTALLED;\n\t\t}\n\t}\n\telse\n\t{\n\t\tstatus = REPMGR_AVAILABLE;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn status;\n}\n\n/* ========================= */\n/* node management functions */\n/* ========================= */\n\n/*\n * Assumes the connection can execute CHECKPOINT command.\n * A check can be executed via 'can_execute_checkpoint' function.\n */\nvoid\ncheckpoint(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\n\tres = PQexec(conn, \"CHECKPOINT\");\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, NULL, _(\"unable to execute CHECKPOINT\"));\n\t}\n\n\tPQclear(res);\n\treturn;\n}\n\n\nbool\nvacuum_table(PGconn *primary_conn, const char *table)\n{\n\tPQExpBufferData query;\n\tbool\t\tsuccess = true;\n\tPGresult   *res = NULL;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query, \"VACUUM %s\", table);\n\n\tres = PQexec(primary_conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(primary_conn, NULL,\n\t\t\t\t\t _(\"unable to vacuum table \\\"%s\\\"\"), table);\n\t\tsuccess = false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n/*\n * For use in PostgreSQL 12 and later\n */\nbool\npromote_standby(PGconn *conn, bool wait, int wait_seconds)\n{\n\tPQExpBufferData query;\n\tbool\t\tsuccess = true;\n\tPGresult   *res = NULL;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT pg_catalog.pg_promote(wait := %s\",\n\t\t\t\t\t  wait ? \"TRUE\" : \"FALSE\");\n\n\tif (wait_seconds > 0)\n\t{\n\t\tappendPQExpBuffer(&query,\n\t\t\t\t\t\t  \", wait_seconds := %i\",\n\t\t\t\t\t\t  wait_seconds);\n\t}\n\n\tappendPQExpBufferStr(&query, \")\");\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"unable to execute pg_promote()\"));\n\t\tsuccess = false;\n\t}\n\telse\n\t{\n\t\t/* NOTE: if \"wait\" is false, pg_promote() will always return true */\n\t\tsuccess = atobool(PQgetvalue(res, 0, 0));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\nbool\nresume_wal_replay(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\tPQExpBufferData query;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\n\tif (PQserverVersion(conn) >= 100000)\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \"SELECT pg_catalog.pg_wal_replay_resume()\");\n\t}\n\telse\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \"SELECT pg_catalog.pg_xlog_replay_resume()\");\n\t}\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"resume_wal_replay(): unable to resume WAL replay\"));\n\t\tsuccess = false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\n/* ===================== */\n/* Node record functions */\n/* ===================== */\n\n/*\n * Note: init_defaults may only be false when the caller is refreshing a previously\n * populated record.\n */\nstatic RecordStatus\n_get_node_record(PGconn *conn, char *sqlquery, t_node_info *node_info, bool init_defaults)\n{\n\tint\t\t\tntuples = 0;\n\tPGresult   *res = PQexec(conn, sqlquery);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, sqlquery, _(\"_get_node_record(): unable to execute query\"));\n\n\t\tPQclear(res);\n\t\treturn RECORD_ERROR;\n\t}\n\n\tntuples = PQntuples(res);\n\n\tif (ntuples == 0)\n\t{\n\t\tPQclear(res);\n\t\treturn RECORD_NOT_FOUND;\n\t}\n\n\t_populate_node_record(res, node_info, 0, init_defaults);\n\n\tPQclear(res);\n\n\treturn RECORD_FOUND;\n}\n\n\n/*\n * Note: init_defaults may only be false when the caller is refreshing a previously\n * populated record.\n */\nstatic void\n_populate_node_record(PGresult *res, t_node_info *node_info, int row, bool init_defaults)\n{\n\tnode_info->node_id = atoi(PQgetvalue(res, row, 0));\n\tnode_info->type = parse_node_type(PQgetvalue(res, row, 1));\n\n\tif (PQgetisnull(res, row, 2))\n\t{\n\t\tnode_info->upstream_node_id = NO_UPSTREAM_NODE;\n\t}\n\telse\n\t{\n\t\tnode_info->upstream_node_id = atoi(PQgetvalue(res, row, 2));\n\t}\n\n\tsnprintf(node_info->node_name, sizeof(node_info->node_name), \"%s\", PQgetvalue(res, row, 3));\n\tsnprintf(node_info->conninfo, sizeof(node_info->conninfo), \"%s\", PQgetvalue(res, row, 4));\n\tsnprintf(node_info->repluser, sizeof(node_info->repluser), \"%s\", PQgetvalue(res, row, 5));\n\tsnprintf(node_info->slot_name, sizeof(node_info->slot_name), \"%s\", PQgetvalue(res, row, 6));\n\tsnprintf(node_info->location, sizeof(node_info->location), \"%s\", PQgetvalue(res, row, 7));\n\tnode_info->priority = atoi(PQgetvalue(res, row, 8));\n\tnode_info->active = atobool(PQgetvalue(res, row, 9));\n\tsnprintf(node_info->config_file, sizeof(node_info->config_file), \"%s\", PQgetvalue(res, row, 10));\n\n\t/* These are only set by certain queries */\n\tsnprintf(node_info->upstream_node_name, sizeof(node_info->upstream_node_name), \"%s\", PQgetvalue(res, row, 11));\n\n\tif (PQgetisnull(res, row, 12))\n\t{\n\t\tnode_info->attached = NODE_ATTACHED_UNKNOWN;\n\t}\n\telse\n\t{\n\t\tnode_info->attached = atobool(PQgetvalue(res, row, 12)) ? NODE_ATTACHED : NODE_DETACHED;\n\t}\n\n\t/* Set remaining struct fields with default values */\n\n\tif (init_defaults == true)\n\t{\n\t\tnode_info->node_status = NODE_STATUS_UNKNOWN;\n\t\tnode_info->recovery_type = RECTYPE_UNKNOWN;\n\t\tnode_info->last_wal_receive_lsn = InvalidXLogRecPtr;\n\t\tnode_info->monitoring_state = MS_NORMAL;\n\t\tnode_info->conn = NULL;\n\t}\n}\n\n\nt_server_type\nparse_node_type(const char *type)\n{\n\tif (strcmp(type, \"primary\") == 0)\n\t{\n\t\treturn PRIMARY;\n\t}\n\telse if (strcmp(type, \"standby\") == 0)\n\t{\n\t\treturn STANDBY;\n\t}\n\telse if (strcmp(type, \"witness\") == 0)\n\t{\n\t\treturn WITNESS;\n\t}\n\n\treturn UNKNOWN;\n}\n\n\nconst char *\nget_node_type_string(t_server_type type)\n{\n\tswitch (type)\n\t{\n\t\tcase PRIMARY:\n\t\t\treturn \"primary\";\n\t\tcase STANDBY:\n\t\t\treturn \"standby\";\n\t\tcase WITNESS:\n\t\t\treturn \"witness\";\n\t\t\t/* this should never happen */\n\t\tcase UNKNOWN:\n\t\tdefault:\n\t\t\tlog_error(_(\"unknown node type %i\"), type);\n\t\t\treturn \"unknown\";\n\t}\n}\n\n\nRecordStatus\nget_node_record(PGconn *conn, int node_id, t_node_info *node_info)\n{\n\tPQExpBufferData query;\n\tRecordStatus result;\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT \" REPMGR_NODES_COLUMNS\n\t\t\t\t\t  \"  FROM repmgr.nodes n \"\n\t\t\t\t\t  \" WHERE n.node_id = %i\",\n\t\t\t\t\t  node_id);\n\n\tlog_verbose(LOG_DEBUG, \"get_node_record():\\n  %s\", query.data);\n\n\tresult = _get_node_record(conn, query.data, node_info, true);\n\ttermPQExpBuffer(&query);\n\n\tif (result == RECORD_NOT_FOUND)\n\t{\n\t\tlog_verbose(LOG_DEBUG, \"get_node_record(): no record found for node %i\", node_id);\n\t}\n\n\treturn result;\n}\n\n\nRecordStatus\nrefresh_node_record(PGconn *conn, int node_id, t_node_info *node_info)\n{\n\tPQExpBufferData query;\n\tRecordStatus result;\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT \" REPMGR_NODES_COLUMNS\n\t\t\t\t\t  \"  FROM repmgr.nodes n \"\n\t\t\t\t\t  \" WHERE n.node_id = %i\",\n\t\t\t\t\t  node_id);\n\n\tlog_verbose(LOG_DEBUG, \"get_node_record():\\n  %s\", query.data);\n\n\tresult = _get_node_record(conn, query.data, node_info, false);\n\ttermPQExpBuffer(&query);\n\n\tif (result == RECORD_NOT_FOUND)\n\t{\n\t\tlog_verbose(LOG_DEBUG, \"refresh_node_record(): no record found for node %i\", node_id);\n\t}\n\n\treturn result;\n}\n\n\nRecordStatus\nget_node_record_with_upstream(PGconn *conn, int node_id, t_node_info *node_info)\n{\n\tPQExpBufferData query;\n\tRecordStatus result;\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"    SELECT \" REPMGR_NODES_COLUMNS_WITH_UPSTREAM\n\t\t\t\t\t  \"      FROM repmgr.nodes n \"\n\t\t\t\t\t  \" LEFT JOIN repmgr.nodes un \"\n\t\t\t\t\t  \"        ON un.node_id = n.upstream_node_id\"\n\t\t\t\t\t  \" WHERE n.node_id = %i\",\n\t\t\t\t\t  node_id);\n\n\tlog_verbose(LOG_DEBUG, \"get_node_record():\\n  %s\", query.data);\n\n\tresult = _get_node_record(conn, query.data, node_info, true);\n\ttermPQExpBuffer(&query);\n\n\tif (result == RECORD_NOT_FOUND)\n\t{\n\t\tlog_verbose(LOG_DEBUG, \"get_node_record(): no record found for node %i\", node_id);\n\t}\n\n\treturn result;\n}\n\n\nRecordStatus\nget_node_record_by_name(PGconn *conn, const char *node_name, t_node_info *node_info)\n{\n\tPQExpBufferData query;\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT \" REPMGR_NODES_COLUMNS\n\t\t\t\t\t  \"  FROM repmgr.nodes n \"\n\t\t\t\t\t  \" WHERE n.node_name = '%s' \",\n\t\t\t\t\t  node_name);\n\n\tlog_verbose(LOG_DEBUG, \"get_node_record_by_name():\\n  %s\", query.data);\n\n\trecord_status = _get_node_record(conn, query.data, node_info, true);\n\n\ttermPQExpBuffer(&query);\n\n\tif (record_status == RECORD_NOT_FOUND)\n\t{\n\t\tlog_verbose(LOG_DEBUG, \"get_node_record_by_name(): no record found for node \\\"%s\\\"\",\n\t\t\t\t\tnode_name);\n\t}\n\n\treturn record_status;\n}\n\n\nt_node_info *\nget_node_record_pointer(PGconn *conn, int node_id)\n{\n\tt_node_info *node_info = pg_malloc0(sizeof(t_node_info));\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\n\trecord_status = get_node_record(conn, node_id, node_info);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tpfree(node_info);\n\t\treturn NULL;\n\t}\n\n\treturn node_info;\n}\n\n\nbool\nget_primary_node_record(PGconn *conn, t_node_info *node_info)\n{\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\n\tint\t\t\tprimary_node_id = get_primary_node_id(conn);\n\n\tif (primary_node_id == UNKNOWN_NODE_ID)\n\t{\n\t\treturn false;\n\t}\n\n\trecord_status = get_node_record(conn, primary_node_id, node_info);\n\n\treturn record_status == RECORD_FOUND ? true : false;\n}\n\n\n/*\n * Get the local node record; if this fails, exit. Many operations\n * depend on this being available, so we'll centralize the check\n * and failure messages here.\n */\nbool\nget_local_node_record(PGconn *conn, int node_id, t_node_info *node_info)\n{\n\tRecordStatus record_status = get_node_record(conn, node_id, node_info);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve record for local node\"));\n\t\tlog_detail(_(\"local node id is  %i\"), node_id);\n\t\tlog_hint(_(\"check this node was correctly registered\"));\n\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\treturn true;\n}\n\n\nstatic\nvoid\n_populate_node_records(PGresult *res, NodeInfoList *node_list)\n{\n\tint\t\t\ti;\n\n\tclear_node_info_list(node_list);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < PQntuples(res); i++)\n\t{\n\t\tNodeInfoListCell *cell;\n\n\t\tcell = (NodeInfoListCell *) pg_malloc0(sizeof(NodeInfoListCell));\n\n\t\tcell->node_info = pg_malloc0(sizeof(t_node_info));\n\n\t\t_populate_node_record(res, cell->node_info, i, true);\n\n\t\tif (node_list->tail)\n\t\t\tnode_list->tail->next = cell;\n\t\telse\n\t\t\tnode_list->head = cell;\n\n\t\tnode_list->tail = cell;\n\t\tnode_list->node_count++;\n\t}\n\n\treturn;\n}\n\n\nbool\nget_all_node_records(PGconn *conn, NodeInfoList *node_list)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool success = true;\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"  SELECT \" REPMGR_NODES_COLUMNS\n\t\t\t\t\t\t \"    FROM repmgr.nodes n \"\n\t\t\t\t\t\t \"ORDER BY n.node_id \");\n\n\tlog_verbose(LOG_DEBUG, \"get_all_node_records():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\t/* this will return an empty list if there was an error executing the query */\n\t_populate_node_records(res, node_list);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"get_all_node_records(): unable to execute query\"));\n\t\tsuccess = false;\n\t}\n\n\tPQclear(res);\n\ttermPQExpBuffer(&query);\n\n\treturn success;\n}\n\nbool\nget_all_nodes_count(PGconn *conn, int *count)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool success = true;\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"  SELECT count(*) \"\n\t\t\t\t\t\t \"    FROM repmgr.nodes n \");\n\n\tlog_verbose(LOG_DEBUG, \"get_all_nodes_count():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"get_all_nodes_count(): unable to execute query\"));\n\t\tsuccess = false;\n\t}\n\telse\n\t{\n\t\t*count = atoi(PQgetvalue(res, 0, 0));\n\t}\n\n\tPQclear(res);\n\ttermPQExpBuffer(&query);\n\n\treturn success;\n}\n\nvoid\nget_downstream_node_records(PGconn *conn, int node_id, NodeInfoList *node_list)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"  SELECT \" REPMGR_NODES_COLUMNS\n\t\t\t\t\t  \"    FROM repmgr.nodes n \"\n\t\t\t\t\t  \"   WHERE n.upstream_node_id = %i \"\n\t\t\t\t\t  \"ORDER BY n.node_id \",\n\t\t\t\t\t  node_id);\n\n\tlog_verbose(LOG_DEBUG, \"get_downstream_node_records():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"get_downstream_node_records(): unable to execute query\"));\n\t}\n\n\ttermPQExpBuffer(&query);\n\n\t/* this will return an empty list if there was an error executing the query */\n\t_populate_node_records(res, node_list);\n\n\tPQclear(res);\n\n\treturn;\n}\n\n\nvoid\nget_active_sibling_node_records(PGconn *conn, int node_id, int upstream_node_id, NodeInfoList *node_list)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"  SELECT \" REPMGR_NODES_COLUMNS\n\t\t\t\t\t  \"    FROM repmgr.nodes n \"\n\t\t\t\t\t  \"   WHERE n.upstream_node_id = %i \"\n\t\t\t\t\t  \"     AND n.node_id != %i \"\n\t\t\t\t\t  \"     AND n.active IS TRUE \"\n\t\t\t\t\t  \"ORDER BY n.node_id \",\n\t\t\t\t\t  upstream_node_id,\n\t\t\t\t\t  node_id);\n\n\tlog_verbose(LOG_DEBUG, \"get_active_sibling_node_records():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"get_active_sibling_records(): unable to execute query\"));\n\t}\n\n\ttermPQExpBuffer(&query);\n\n\t/* this will return an empty list if there was an error executing the query */\n\t_populate_node_records(res, node_list);\n\n\tPQclear(res);\n\n\treturn;\n}\n\nbool\nget_child_nodes(PGconn *conn, int node_id, NodeInfoList *node_list)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"    SELECT n.node_id, n.type, n.upstream_node_id, n.node_name, n.conninfo, n.repluser, \"\n\t\t\t\t\t  \"           n.slot_name, n.location, n.priority, n.active, n.config_file, \"\n\t\t\t\t\t  \"           '' AS upstream_node_name, \"\n\t\t\t\t\t  \"           CASE WHEN sr.application_name IS NULL THEN FALSE ELSE TRUE END AS attached \"\n\t\t\t\t\t  \"      FROM repmgr.nodes n \"\n\t\t\t\t\t  \" LEFT JOIN pg_catalog.pg_stat_replication sr \"\n\t\t\t\t\t  \"        ON sr.application_name = n.node_name \"\n\t\t\t\t\t  \"     WHERE n.upstream_node_id = %i \",\n\t\t\t\t\t  node_id);\n\n\tlog_verbose(LOG_DEBUG, \"get_child_nodes():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"get_active_sibling_records(): unable to execute query\"));\n\t\tsuccess = false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\n\t/* this will return an empty list if there was an error executing the query */\n\t_populate_node_records(res, node_list);\n\n\tPQclear(res);\n\n\treturn success;\n}\n\n\nvoid\nget_node_records_by_priority(PGconn *conn, NodeInfoList *node_list)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"  SELECT \" REPMGR_NODES_COLUMNS\n\t\t\t\t\t\t \"    FROM repmgr.nodes n \"\n\t\t\t\t\t\t \"ORDER BY n.priority DESC, n.node_name \");\n\n\tlog_verbose(LOG_DEBUG, \"get_node_records_by_priority():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"get_node_records_by_priority(): unable to execute query\"));\n\t}\n\n\ttermPQExpBuffer(&query);\n\n\t/* this will return an empty list if there was an error executing the query */\n\t_populate_node_records(res, node_list);\n\n\tPQclear(res);\n\n\treturn;\n}\n\n/*\n * return all node records together with their upstream's node name,\n * if available.\n */\nbool\nget_all_node_records_with_upstream(PGconn *conn, NodeInfoList *node_list)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"    SELECT \" REPMGR_NODES_COLUMNS_WITH_UPSTREAM\n\t\t\t\t\t\t \"      FROM repmgr.nodes n \"\n\t\t\t\t\t\t \" LEFT JOIN repmgr.nodes un \"\n\t\t\t\t\t\t \"        ON un.node_id = n.upstream_node_id\"\n\t\t\t\t\t\t \"  ORDER BY n.node_id \");\n\n\tlog_verbose(LOG_DEBUG, \"get_all_node_records_with_upstream():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"get_all_node_records_with_upstream(): unable to retrieve node records\"));\n\t\tsuccess = false;\n\t}\n\n\n\t/* this will return an empty list if there was an error executing the query */\n\t_populate_node_records(res, node_list);\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\n\nbool\nget_downstream_nodes_with_missing_slot(PGconn *conn, int this_node_id, NodeInfoList *node_list)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"   SELECT \" REPMGR_NODES_COLUMNS\n\t\t\t\t\t  \"     FROM repmgr.nodes n \"\n\t\t\t\t\t  \"LEFT JOIN pg_catalog.pg_replication_slots rs \"\n\t\t\t\t\t  \"       ON rs.slot_name = n.slot_name \"\n\t\t\t\t\t  \"    WHERE n.slot_name IS NOT NULL\"\n\t\t\t\t\t  \"      AND rs.slot_name IS NULL \"\n\t\t\t\t\t  \"      AND n.upstream_node_id = %i \"\n\t\t\t\t\t  \"      AND n.type = 'standby'\",\n\t\t\t\t\t  this_node_id);\n\n\tlog_verbose(LOG_DEBUG, \"get_all_node_records_with_missing_slot():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"get_downstream_nodes_with_missing_slot(): unable to retrieve node records\"));\n\t\tsuccess = false;\n\t}\n\n\t/* this will return an empty list if there was an error executing the query */\n\t_populate_node_records(res, node_list);\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\nbool\ncreate_node_record(PGconn *conn, char *repmgr_action, t_node_info *node_info)\n{\n\tif (repmgr_action != NULL)\n\t\tlog_verbose(LOG_DEBUG, \"create_node_record(): action is \\\"%s\\\"\", repmgr_action);\n\n\treturn _create_update_node_record(conn, \"create\", node_info);\n}\n\n\nbool\nupdate_node_record(PGconn *conn, char *repmgr_action, t_node_info *node_info)\n{\n\tif (repmgr_action != NULL)\n\t\tlog_verbose(LOG_DEBUG, \"update_node_record(): action is \\\"%s\\\"\", repmgr_action);\n\n\treturn _create_update_node_record(conn, \"update\", node_info);\n}\n\n\nstatic bool\n_create_update_node_record(PGconn *conn, char *action, t_node_info *node_info)\n{\n\tPQExpBufferData query;\n\tchar\t\tnode_id[MAXLEN] = \"\";\n\tchar\t\tpriority[MAXLEN] = \"\";\n\n\tchar\t\tupstream_node_id[MAXLEN] = \"\";\n\tchar\t   *upstream_node_id_ptr = NULL;\n\n\tchar\t   *slot_name_ptr = NULL;\n\n\tint\t\t\tparam_count = NODE_RECORD_PARAM_COUNT;\n\tconst char *param_values[NODE_RECORD_PARAM_COUNT];\n\n\tPGresult   *res;\n\tbool\t\tsuccess = true;\n\n\tmaxlen_snprintf(node_id, \"%i\", node_info->node_id);\n\tmaxlen_snprintf(priority, \"%i\", node_info->priority);\n\n\tif (node_info->upstream_node_id == NO_UPSTREAM_NODE && node_info->type == STANDBY)\n\t{\n\t\t/*\n\t\t * No explicit upstream node id provided for standby - attempt to get\n\t\t * primary node id\n\t\t */\n\t\tint\t\t\tprimary_node_id = get_primary_node_id(conn);\n\n\t\tmaxlen_snprintf(upstream_node_id, \"%i\", primary_node_id);\n\t\tupstream_node_id_ptr = upstream_node_id;\n\t}\n\telse if (node_info->upstream_node_id != NO_UPSTREAM_NODE)\n\t{\n\t\tmaxlen_snprintf(upstream_node_id, \"%i\", node_info->upstream_node_id);\n\t\tupstream_node_id_ptr = upstream_node_id;\n\t}\n\n\tif (node_info->slot_name[0] != '\\0')\n\t{\n\t\tslot_name_ptr = node_info->slot_name;\n\t}\n\n\n\tparam_values[0] = get_node_type_string(node_info->type);\n\tparam_values[1] = upstream_node_id_ptr;\n\tparam_values[2] = node_info->node_name;\n\tparam_values[3] = node_info->conninfo;\n\tparam_values[4] = node_info->repluser;\n\tparam_values[5] = slot_name_ptr;\n\tparam_values[6] = node_info->location;\n\tparam_values[7] = priority;\n\tparam_values[8] = node_info->active == true ? \"TRUE\" : \"FALSE\";\n\tparam_values[9] = node_info->config_file;\n\tparam_values[10] = node_id;\n\n\tinitPQExpBuffer(&query);\n\n\tif (strcmp(action, \"create\") == 0)\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \"INSERT INTO repmgr.nodes \"\n\t\t\t\t\t\t\t \"       (node_id, type, upstream_node_id, \"\n\t\t\t\t\t\t\t \"        node_name, conninfo, repluser, slot_name, \"\n\t\t\t\t\t\t\t \"        location, priority, active, config_file) \"\n\t\t\t\t\t\t\t \"VALUES ($11, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) \");\n\t}\n\telse\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \"UPDATE repmgr.nodes SET \"\n\t\t\t\t\t\t\t \"       type = $1, \"\n\t\t\t\t\t\t\t \"       upstream_node_id = $2, \"\n\t\t\t\t\t\t\t \"       node_name = $3, \"\n\t\t\t\t\t\t\t \"       conninfo = $4, \"\n\t\t\t\t\t\t\t \"       repluser = $5, \"\n\t\t\t\t\t\t\t \"       slot_name = $6, \"\n\t\t\t\t\t\t\t \"       location = $7, \"\n\t\t\t\t\t\t\t \"       priority = $8, \"\n\t\t\t\t\t\t\t \"       active = $9, \"\n\t\t\t\t\t\t\t \"       config_file = $10 \"\n\t\t\t\t\t\t\t \" WHERE node_id = $11 \");\n\t}\n\n\tres = PQexecParams(conn,\n\t\t\t\t\t   query.data,\n\t\t\t\t\t   param_count,\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   param_values,\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   0);\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"_create_update_node_record(): unable to %s node record for node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t action,\n\t\t\t\t\t node_info->node_name,\n\t\t\t\t\t node_info->node_id);\n\n\t\tsuccess = false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\nbool\nupdate_node_record_set_active(PGconn *conn, int this_node_id, bool active)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"UPDATE repmgr.nodes SET active = %s \"\n\t\t\t\t\t  \" WHERE node_id = %i\",\n\t\t\t\t\t  active == true ? \"TRUE\" : \"FALSE\",\n\t\t\t\t\t  this_node_id);\n\n\tlog_verbose(LOG_DEBUG, \"update_node_record_set_active():\\n  %s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"update_node_record_set_active(): unable to update node record\"));\n\t\tsuccess = false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\nbool\nupdate_node_record_set_active_standby(PGconn *conn, int this_node_id)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"UPDATE repmgr.nodes \"\n\t\t\t\t\t  \"   SET type = 'standby', \"\n\t\t\t\t\t  \"       active = TRUE \"\n\t\t\t\t\t  \" WHERE node_id = %i\",\n\t\t\t\t\t  this_node_id);\n\n\tlog_verbose(LOG_DEBUG, \"update_node_record_set_active_standby():\\n  %s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"update_node_record_set_active_standby(): unable to update node record\"));\n\t\tsuccess = false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\nbool\nupdate_node_record_set_primary(PGconn *conn, int this_node_id)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\n\tlog_debug(_(\"setting node %i as primary and marking existing primary as failed\"),\n\t\t\t  this_node_id);\n\n\tbegin_transaction(conn);\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"  UPDATE repmgr.nodes \"\n\t\t\t\t\t  \"     SET active = FALSE \"\n\t\t\t\t\t  \"   WHERE type = 'primary' \"\n\t\t\t\t\t  \"     AND active IS TRUE \"\n\t\t\t\t\t  \"     AND node_id != %i \",\n\t\t\t\t\t  this_node_id);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"update_node_record_set_primary(): unable to set old primary node as inactive\"));\n\n\t\ttermPQExpBuffer(&query);\n\t\tPQclear(res);\n\n\t\trollback_transaction(conn);\n\n\t\treturn false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"  UPDATE repmgr.nodes\"\n\t\t\t\t\t  \"     SET type = 'primary', \"\n\t\t\t\t\t  \"         upstream_node_id = NULL, \"\n\t\t\t\t\t  \"         active = TRUE \"\n\t\t\t\t\t  \"   WHERE node_id = %i \",\n\t\t\t\t\t  this_node_id);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"unable to set current node %i as active primary\"),\n\t\t\t\t\t this_node_id);\n\n\t\ttermPQExpBuffer(&query);\n\t\tPQclear(res);\n\n\t\trollback_transaction(conn);\n\n\t\treturn false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn commit_transaction(conn);\n}\n\n\nbool\nupdate_node_record_set_upstream(PGconn *conn, int this_node_id, int new_upstream_node_id)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tlog_debug(_(\"update_node_record_set_upstream(): Updating node %i's upstream node to %i\"),\n\t\t\t  this_node_id, new_upstream_node_id);\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"  UPDATE repmgr.nodes \"\n\t\t\t\t\t  \"     SET upstream_node_id = %i \"\n\t\t\t\t\t  \"   WHERE node_id = %i \",\n\t\t\t\t\t  new_upstream_node_id,\n\t\t\t\t\t  this_node_id);\n\n\tlog_verbose(LOG_DEBUG, \"update_node_record_set_upstream():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"update_node_record_set_upstream(): unable to set new upstream node id\"));\n\n\t\tsuccess = false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\n/*\n * Update node record following change of status\n * (e.g. inactive primary converted to standby)\n */\nbool\nupdate_node_record_status(PGconn *conn, int this_node_id, char *type, int upstream_node_id, bool active)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"  UPDATE repmgr.nodes \"\n\t\t\t\t\t  \"     SET type = '%s', \"\n\t\t\t\t\t  \"         upstream_node_id = %i, \"\n\t\t\t\t\t  \"         active = %s \"\n\t\t\t\t\t  \"   WHERE node_id = %i \",\n\t\t\t\t\t  type,\n\t\t\t\t\t  upstream_node_id,\n\t\t\t\t\t  active ? \"TRUE\" : \"FALSE\",\n\t\t\t\t\t  this_node_id);\n\n\tlog_verbose(LOG_DEBUG, \"update_node_record_status():\\n  %s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"update_node_record_status(): unable to update node record status for node %i\"),\n\t\t\t\t\t this_node_id);\n\n\t\tsuccess = false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\n/*\n * Update node record's \"conninfo\" and \"priority\" fields. Called by repmgrd\n * following a configuration file reload.\n */\nbool\nupdate_node_record_conn_priority(PGconn *conn, t_configuration_options *options)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"UPDATE repmgr.nodes \"\n\t\t\t\t\t  \"   SET conninfo = '%s', \"\n\t\t\t\t\t  \"       priority = %d \"\n\t\t\t\t\t  \" WHERE node_id = %d \",\n\t\t\t\t\t  options->conninfo,\n\t\t\t\t\t  options->priority,\n\t\t\t\t\t  options->node_id);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"update_node_record_conn_priority(): unable to execute query\"));\n\t\tsuccess = false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\n\tPQclear(res);\n\n\treturn success;\n}\n\n\n/*\n * Copy node records from primary to witness servers.\n *\n * This is used when initially registering a witness server, and\n * by repmgrd to update the node records when required.\n */\n\nbool\nwitness_copy_node_records(PGconn *primary_conn, PGconn *witness_conn)\n{\n\tPGresult   *res = NULL;\n\tNodeInfoList nodes = T_NODE_INFO_LIST_INITIALIZER;\n\tNodeInfoListCell *cell = NULL;\n\n\tbegin_transaction(witness_conn);\n\n\t/* Defer constraints */\n\n\tres = PQexec(witness_conn, \"SET CONSTRAINTS ALL DEFERRED\");\n\n\tif (!res || PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(witness_conn, NULL, (\"witness_copy_node_records(): unable to defer constraints\"));\n\n\t\trollback_transaction(witness_conn);\n\t\tPQclear(res);\n\n\t\treturn false;\n\t}\n\n\tPQclear(res);\n\n\t/* truncate existing records */\n\n\tif (truncate_node_records(witness_conn) == false)\n\t{\n\t\trollback_transaction(witness_conn);\n\n\t\treturn false;\n\t}\n\n\tif (get_all_node_records(primary_conn, &nodes) == false)\n\t{\n\t\trollback_transaction(witness_conn);\n\n\t\treturn false;\n\t}\n\n\tfor (cell = nodes.head; cell; cell = cell->next)\n\t{\n\t\tif (create_node_record(witness_conn, NULL, cell->node_info) == false)\n\t\t{\n\t\t\trollback_transaction(witness_conn);\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* and done */\n\tcommit_transaction(witness_conn);\n\n\tclear_node_info_list(&nodes);\n\n\treturn true;\n}\n\n\nbool\ndelete_node_record(PGconn *conn, int node)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"DELETE FROM repmgr.nodes \"\n\t\t\t\t\t  \" WHERE node_id = %i\",\n\t\t\t\t\t  node);\n\n\tlog_verbose(LOG_DEBUG, \"delete_node_record():\\n  %s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"delete_node_record(): unable to delete node record\"));\n\n\t\tsuccess = false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\nbool\ntruncate_node_records(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tres = PQexec(conn, \"TRUNCATE TABLE repmgr.nodes\");\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, NULL, _(\"truncate_node_records(): unable to truncate table \\\"repmgr.nodes\\\"\"));\n\n\t\tsuccess = false;\n\t}\n\n\tPQclear(res);\n\n\treturn success;\n}\n\n\nbool\nupdate_node_record_slot_name(PGconn *primary_conn, int node_id, char *slot_name)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \" UPDATE repmgr.nodes \"\n\t\t\t\t\t  \"    SET slot_name = '%s' \"\n\t\t\t\t\t  \"  WHERE node_id = %i \",\n\t\t\t\t\t  slot_name,\n\t\t\t\t\t  node_id);\n\n\tres = PQexec(primary_conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(primary_conn, query.data, _(\"unable to set node record slot name\"));\n\n\t\tsuccess = false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\n\n\nvoid\nclear_node_info_list(NodeInfoList *nodes)\n{\n\tNodeInfoListCell *cell = NULL;\n\tNodeInfoListCell *next_cell = NULL;\n\n\tlog_verbose(LOG_DEBUG, \"clear_node_info_list() - closing open connections\");\n\n\t/* close any open connections */\n\tfor (cell = nodes->head; cell; cell = cell->next)\n\t{\n\n\t\tif (PQstatus(cell->node_info->conn) == CONNECTION_OK)\n\t\t{\n\t\t\tPQfinish(cell->node_info->conn);\n\t\t\tcell->node_info->conn = NULL;\n\t\t}\n\t}\n\n\tlog_verbose(LOG_DEBUG, \"clear_node_info_list() - unlinking\");\n\n\tcell = nodes->head;\n\n\twhile (cell != NULL)\n\t{\n\t\tnext_cell = cell->next;\n\n\t\tif (cell->node_info->replication_info != NULL)\n\t\t\tpfree(cell->node_info->replication_info);\n\n\t\tpfree(cell->node_info);\n\t\tpfree(cell);\n\t\tcell = next_cell;\n\t}\n\n\tnodes->head = NULL;\n\tnodes->tail = NULL;\n\tnodes->node_count = 0;\n}\n\n\n/* ================================================ */\n/* PostgreSQL configuration file location functions */\n/* ================================================ */\n\nbool\nget_datadir_configuration_files(PGconn *conn, KeyValueList *list)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tint\t\t\ti;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"WITH files AS ( \"\n\t\t\t\t\t\t \"  WITH dd AS ( \"\n\t\t\t\t\t\t \"   SELECT setting \"\n\t\t\t\t\t\t \"     FROM pg_catalog.pg_settings \"\n\t\t\t\t\t\t \"    WHERE name = 'data_directory') \"\n\t\t\t\t\t\t \"   SELECT distinct(sourcefile) AS config_file\"\n\t\t\t\t\t\t \"     FROM dd, pg_catalog.pg_settings ps \"\n\t\t\t\t\t\t \"    WHERE ps.sourcefile IS NOT NULL \"\n\t\t\t\t\t\t \"      AND ps.sourcefile ~ ('^' || dd.setting) \"\n\t\t\t\t\t\t \"       UNION \"\n\t\t\t\t\t\t \"   SELECT ps.setting  AS config_file\"\n\t\t\t\t\t\t \"     FROM dd, pg_catalog.pg_settings ps \"\n\t\t\t\t\t\t \"    WHERE ps.name IN ('config_file', 'hba_file', 'ident_file') \"\n\t\t\t\t\t\t \"      AND ps.setting ~ ('^' || dd.setting) \"\n\t\t\t\t\t\t \") \"\n\t\t\t\t\t\t \"  SELECT config_file, \"\n\t\t\t\t\t\t \"         pg_catalog.regexp_replace(config_file, '^.*\\\\/','') AS filename \"\n\t\t\t\t\t\t \"    FROM files \"\n\t\t\t\t\t\t \"ORDER BY config_file\");\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"get_datadir_configuration_files(): unable to retrieve configuration file information\"));\n\n\t\tsuccess = false;\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < PQntuples(res); i++)\n\t\t{\n\t\t\tkey_value_list_set(list,\n\t\t\t\t\t\t\t   PQgetvalue(res, i, 1),\n\t\t\t\t\t\t\t   PQgetvalue(res, i, 0));\n\t\t}\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\nbool\nget_configuration_file_locations(PGconn *conn, t_configfile_list *list)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tint\t\t\ti;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"  WITH dd AS ( \"\n\t\t\t\t\t\t \"    SELECT setting AS data_directory\"\n\t\t\t\t\t\t \"      FROM pg_catalog.pg_settings \"\n\t\t\t\t\t\t \"     WHERE name = 'data_directory' \"\n\t\t\t\t\t\t \"  ) \"\n\t\t\t\t\t\t \"    SELECT DISTINCT(sourcefile), \"\n\t\t\t\t\t\t \"           pg_catalog.regexp_replace(sourcefile, '^.*\\\\/', '') AS filename, \"\n\t\t\t\t\t\t \"           sourcefile ~ ('^' || dd.data_directory) AS in_data_dir \"\n\t\t\t\t\t\t \"      FROM dd, pg_catalog.pg_settings ps \"\n\t\t\t\t\t\t \"     WHERE sourcefile IS NOT NULL \"\n\t\t\t\t\t\t \"  ORDER BY 1 \");\n\n\tlog_verbose(LOG_DEBUG, \"get_configuration_file_locations():\\n  %s\",\n\t\t\t\tquery.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"get_configuration_file_locations(): unable to retrieve configuration file locations\"));\n\n\t\ttermPQExpBuffer(&query);\n\t\tPQclear(res);\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * allocate memory for config file array - number of rows returned from\n\t * above query + 2 for pg_hba.conf, pg_ident.conf\n\t */\n\n\tconfig_file_list_init(list, PQntuples(res) + 2);\n\n\tfor (i = 0; i < PQntuples(res); i++)\n\t{\n\t\tconfig_file_list_add(list,\n\t\t\t\t\t\t\t PQgetvalue(res, i, 0),\n\t\t\t\t\t\t\t PQgetvalue(res, i, 1),\n\t\t\t\t\t\t\t atobool(PQgetvalue(res, i, 2)));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\t/* Fetch locations of pg_hba.conf and pg_ident.conf */\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"  WITH dd AS ( \"\n\t\t\t\t\t\t \"    SELECT setting AS data_directory\"\n\t\t\t\t\t\t \"      FROM pg_catalog.pg_settings \"\n\t\t\t\t\t\t \"     WHERE name = 'data_directory' \"\n\t\t\t\t\t\t \"  ) \"\n\t\t\t\t\t\t \"    SELECT ps.setting, \"\n\t\t\t\t\t\t \"           pg_catalog.regexp_replace(setting, '^.*\\\\/', '') AS filename, \"\n\t\t\t\t\t\t \"           ps.setting ~ ('^' || dd.data_directory) AS in_data_dir \"\n\t\t\t\t\t\t \"      FROM dd, pg_catalog.pg_settings ps \"\n\t\t\t\t\t\t \"     WHERE ps.name IN ('hba_file', 'ident_file') \"\n\t\t\t\t\t\t \"  ORDER BY 1 \");\n\n\tlog_verbose(LOG_DEBUG, \"get_configuration_file_locations():\\n  %s\",\n\t\t\t\tquery.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"get_configuration_file_locations(): unable to retrieve configuration file locations\"));\n\n\t\ttermPQExpBuffer(&query);\n\t\tPQclear(res);\n\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < PQntuples(res); i++)\n\t{\n\t\tconfig_file_list_add(list,\n\t\t\t\t\t\t\t PQgetvalue(res, i, 0),\n\t\t\t\t\t\t\t PQgetvalue(res, i, 1),\n\t\t\t\t\t\t\t atobool(PQgetvalue(res, i, 2)));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn true;\n}\n\n\nvoid\nconfig_file_list_init(t_configfile_list *list, int max_size)\n{\n\tlist->size = max_size;\n\tlist->entries = 0;\n\tlist->files = pg_malloc0(sizeof(t_configfile_info *) * max_size);\n\n\tif (list->files == NULL)\n\t{\n\t\tlog_error(_(\"config_file_list_init(): unable to allocate memory; terminating\"));\n\t\texit(ERR_OUT_OF_MEMORY);\n\t}\n}\n\n\nvoid\nconfig_file_list_add(t_configfile_list *list, const char *file, const char *filename, bool in_data_dir)\n{\n\t/* Failsafe to prevent entries being added beyond the end */\n\tif (list->entries == list->size)\n\t\treturn;\n\n\tlist->files[list->entries] = pg_malloc0(sizeof(t_configfile_info));\n\n\tif (list->files[list->entries] == NULL)\n\t{\n\t\tlog_error(_(\"config_file_list_add(): unable to allocate memory; terminating\"));\n\t\texit(ERR_OUT_OF_MEMORY);\n\t}\n\n\n\tsnprintf(list->files[list->entries]->filepath,\n\t\t\t sizeof(list->files[list->entries]->filepath),\n\t\t\t \"%s\", file);\n\tcanonicalize_path(list->files[list->entries]->filepath);\n\n\tsnprintf(list->files[list->entries]->filename,\n\t\t\t sizeof(list->files[list->entries]->filename),\n\t\t\t \"%s\", filename);\n\n\tlist->files[list->entries]->in_data_directory = in_data_dir;\n\n\tlist->entries++;\n}\n\n\n/* ====================== */\n/* event record functions */\n/* ====================== */\n\n\n/*\n * create_event_record()\n *\n * Create a record in the \"events\" table, but don't execute the\n * \"event_notification_command\".\n */\n\nbool\ncreate_event_record(PGconn *conn, t_configuration_options *options, int node_id, char *event, bool successful, char *details)\n{\n\t/* create dummy t_event_info */\n\tt_event_info event_info = T_EVENT_INFO_INITIALIZER;\n\n\treturn _create_event(conn, options, node_id, event, successful, details, &event_info, false);\n}\n\n\n/*\n * create_event_notification()\n *\n * If `conn` is not NULL, insert a record into the events table.\n *\n * If configuration parameter \"event_notification_command\" is set, also\n * attempt to execute that command.\n *\n * Returns true if all operations succeeded, false if one or more failed.\n *\n * Note this function may be called with \"conn\" set to NULL in cases where\n * the primary node is not available and it's therefore not possible to write\n * an event record. In this case, if `event_notification_command` is set, a\n * user-defined notification to be generated; if not, this function will have\n * no effect.\n */\nbool\ncreate_event_notification(PGconn *conn, t_configuration_options *options, int node_id, char *event, bool successful, char *details)\n{\n\t/* create dummy t_event_info */\n\tt_event_info event_info = T_EVENT_INFO_INITIALIZER;\n\n\treturn _create_event(conn, options, node_id, event, successful, details, &event_info, true);\n}\n\n\n/*\n * create_event_notification_extended()\n *\n * The caller may need to pass additional parameters to the event notification\n * command (currently only the conninfo string of another node)\n\n */\nbool\ncreate_event_notification_extended(PGconn *conn, t_configuration_options *options, int node_id, char *event, bool successful, char *details, t_event_info *event_info)\n{\n\treturn _create_event(conn, options, node_id, event, successful, details, event_info, true);\n}\n\n\nstatic bool\n_create_event(PGconn *conn, t_configuration_options *options, int node_id, char *event, bool successful, char *details, t_event_info *event_info, bool send_notification)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tchar\t\tevent_timestamp[MAXLEN] = \"\";\n\tbool\t\tsuccess = true;\n\n\tlog_verbose(LOG_DEBUG, \"_create_event(): event is \\\"%s\\\" for node %i\", event, node_id);\n\n\t/*\n\t * Only attempt to write a record if a connection handle was provided,\n\t * and the connection handle points to a node which is not in recovery.\n\t */\n\tif (conn != NULL && PQstatus(conn) == CONNECTION_OK && get_recovery_type(conn) == RECTYPE_PRIMARY)\n\t{\n\t\tint\t\t\tn_node_id = htonl(node_id);\n\t\tchar\t   *t_successful = successful ? \"TRUE\" : \"FALSE\";\n\n\t\tconst char *values[4] = {(char *) &n_node_id,\n\t\t\tevent,\n\t\t\tt_successful,\n\t\t\tdetails\n\t\t};\n\n\t\tint\t\t\tlengths[4] = {sizeof(n_node_id),\n\t\t\t0,\n\t\t\t0,\n\t\t\t0\n\t\t};\n\n\t\tint\t\t\tbinary[4] = {1, 0, 0, 0};\n\n\t\tinitPQExpBuffer(&query);\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \" INSERT INTO repmgr.events ( \"\n\t\t\t\t\t\t\t \"             node_id, \"\n\t\t\t\t\t\t\t \"             event, \"\n\t\t\t\t\t\t\t \"             successful, \"\n\t\t\t\t\t\t\t \"             details \"\n\t\t\t\t\t\t\t \"            ) \"\n\t\t\t\t\t\t\t \"      VALUES ($1, $2, $3, $4) \"\n\t\t\t\t\t\t\t \"   RETURNING event_timestamp \");\n\n\t\tlog_verbose(LOG_DEBUG, \"_create_event():\\n  %s\", query.data);\n\n\t\tres = PQexecParams(conn,\n\t\t\t\t\t\t   query.data,\n\t\t\t\t\t\t   4,\n\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t   values,\n\t\t\t\t\t\t   lengths,\n\t\t\t\t\t\t   binary,\n\t\t\t\t\t\t   0);\n\n\n\t\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t\t{\n\t\t\t/* we don't treat this as a fatal error */\n\t\t\tlog_warning(_(\"unable to create event record\"));\n\t\t\tlog_detail(\"%s\", PQerrorMessage(conn));\n\t\t\tlog_detail(\"%s\", query.data);\n\n\t\t\tsuccess = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Store timestamp to send to the notification command */\n\t\t\tsnprintf(event_timestamp, MAXLEN, \"%s\", PQgetvalue(res, 0, 0));\n\t\t}\n\n\t\ttermPQExpBuffer(&query);\n\t\tPQclear(res);\n\t}\n\n\t/*\n\t * If no database connection provided, or the query failed, generate a\n\t * current timestamp ourselves. This isn't quite the same format as\n\t * PostgreSQL, but is close enough for diagnostic use.\n\t */\n\tif (!strlen(event_timestamp))\n\t{\n\t\ttime_t\t\tnow;\n\t\tstruct tm\tts;\n\n\t\ttime(&now);\n\t\tts = *localtime(&now);\n\t\tstrftime(event_timestamp, MAXLEN, \"%Y-%m-%d %H:%M:%S%z\", &ts);\n\t}\n\n\tlog_verbose(LOG_DEBUG, \"_create_event(): Event timestamp is \\\"%s\\\"\", event_timestamp);\n\n\t/* an event notification command was provided - parse and execute it */\n\tif (send_notification == true && strlen(options->event_notification_command))\n\t{\n\t\tchar\t\tparsed_command[MAXPGPATH] = \"\";\n\t\tconst char *src_ptr = NULL;\n\t\tchar\t   *dst_ptr = NULL;\n\t\tchar\t   *end_ptr = NULL;\n\t\tint\t\t\tr = 0;\n\n\t\tlog_verbose(LOG_DEBUG, \"_create_event(): command is '%s'\", options->event_notification_command);\n\t\t/*\n\t\t * If configuration option 'event_notifications' was provided, check\n\t\t * if this event is one of the ones listed; if not listed, don't\n\t\t * execute the notification script.\n\t\t *\n\t\t * (If 'event_notifications' was not provided, we assume the script\n\t\t * should be executed for all events).\n\t\t */\n\t\tif (options->event_notifications.head != NULL)\n\t\t{\n\t\t\tEventNotificationListCell *cell = NULL;\n\t\t\tbool\t\tnotify_ok = false;\n\n\t\t\tfor (cell = options->event_notifications.head; cell; cell = cell->next)\n\t\t\t{\n\t\t\t\tif (strcmp(event, cell->event_type) == 0)\n\t\t\t\t{\n\t\t\t\t\tnotify_ok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Event type not found in the 'event_notifications' list - return\n\t\t\t * early\n\t\t\t */\n\t\t\tif (notify_ok == false)\n\t\t\t{\n\t\t\t\tlog_debug(_(\"not executing notification script for event type \\\"%s\\\"\"), event);\n\t\t\t\treturn success;\n\t\t\t}\n\t\t}\n\n\t\tdst_ptr = parsed_command;\n\t\tend_ptr = parsed_command + MAXPGPATH - 1;\n\t\t*end_ptr = '\\0';\n\n\t\tfor (src_ptr = options->event_notification_command; *src_ptr; src_ptr++)\n\t\t{\n\t\t\tif (*src_ptr == '%')\n\t\t\t{\n\t\t\t\tswitch (src_ptr[1])\n\t\t\t\t{\n\t\t\t\t\tcase '%':\n\t\t\t\t\t\t/* %%: replace with % */\n\t\t\t\t\t\tif (dst_ptr < end_ptr)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\t\t\t*dst_ptr++ = *src_ptr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'n':\n\t\t\t\t\t\t/* %n: node id */\n\t\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\t\tsnprintf(dst_ptr, end_ptr - dst_ptr, \"%i\", node_id);\n\t\t\t\t\t\tdst_ptr += strlen(dst_ptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\t/* %a: node name */\n\t\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\t\tif (event_info->node_name != NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog_verbose(LOG_DEBUG, \"node_name: %s\", event_info->node_name);\n\t\t\t\t\t\t\tstrlcpy(dst_ptr, event_info->node_name, end_ptr - dst_ptr);\n\t\t\t\t\t\t\tdst_ptr += strlen(dst_ptr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'e':\n\t\t\t\t\t\t/* %e: event type */\n\t\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\t\tstrlcpy(dst_ptr, event, end_ptr - dst_ptr);\n\t\t\t\t\t\tdst_ptr += strlen(dst_ptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t/* %d: details */\n\t\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\t\tif (details != NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPQExpBufferData details_escaped;\n\t\t\t\t\t\t\tinitPQExpBuffer(&details_escaped);\n\n\t\t\t\t\t\t\tescape_double_quotes(details, &details_escaped);\n\n\t\t\t\t\t\t\tstrlcpy(dst_ptr, details_escaped.data, end_ptr - dst_ptr);\n\t\t\t\t\t\t\tdst_ptr += strlen(dst_ptr);\n\t\t\t\t\t\t\ttermPQExpBuffer(&details_escaped);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\t/* %s: successful */\n\t\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\t\tstrlcpy(dst_ptr, successful ? \"1\" : \"0\", end_ptr - dst_ptr);\n\t\t\t\t\t\tdst_ptr += strlen(dst_ptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\t/* %t: timestamp */\n\t\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\t\tstrlcpy(dst_ptr, event_timestamp, end_ptr - dst_ptr);\n\t\t\t\t\t\tdst_ptr += strlen(dst_ptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t/* %c: conninfo for next available node */\n\t\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\t\tif (event_info->conninfo_str != NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog_debug(\"conninfo: %s\", event_info->conninfo_str);\n\n\t\t\t\t\t\t\tstrlcpy(dst_ptr, event_info->conninfo_str, end_ptr - dst_ptr);\n\t\t\t\t\t\t\tdst_ptr += strlen(dst_ptr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\t/* %p: primary id (\"standby_switchover\"/\"repmgrd_failover_promote\": former primary id) */\n\t\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\t\tif (event_info->node_id != UNKNOWN_NODE_ID)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPQExpBufferData node_id;\n\t\t\t\t\t\t\tinitPQExpBuffer(&node_id);\n\t\t\t\t\t\t\tappendPQExpBuffer(&node_id,\n\t\t\t\t\t\t\t\t\t\t\t  \"%i\", event_info->node_id);\n\t\t\t\t\t\t\tstrlcpy(dst_ptr, node_id.data, end_ptr - dst_ptr);\n\t\t\t\t\t\t\tdst_ptr += strlen(dst_ptr);\n\t\t\t\t\t\t\ttermPQExpBuffer(&node_id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* otherwise treat the % as not special */\n\t\t\t\t\t\tif (dst_ptr < end_ptr)\n\t\t\t\t\t\t\t*dst_ptr++ = *src_ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (dst_ptr < end_ptr)\n\t\t\t\t\t*dst_ptr++ = *src_ptr;\n\t\t\t}\n\t\t}\n\n\t\t*dst_ptr = '\\0';\n\n\t\tlog_info(_(\"executing notification command for event \\\"%s\\\"\"),\n\t\t\t\t event);\n\n\t\tlog_detail(_(\"command is:\\n  %s\"), parsed_command);\n\t\tr = system(parsed_command);\n\t\tif (r != 0)\n\t\t{\n\t\t\tlog_warning(_(\"unable to execute event notification command\"));\n\t\t\tlog_detail(_(\"parsed event notification command was:\\n  %s\"), parsed_command);\n\t\t\tsuccess = false;\n\t\t}\n\t}\n\n\treturn success;\n}\n\n\nPGresult *\nget_event_records(PGconn *conn, int node_id, const char *node_name, const char *event, bool all, int limit)\n{\n\tPGresult   *res;\n\n\tPQExpBufferData query;\n\tPQExpBufferData where_clause;\n\n\n\tinitPQExpBuffer(&query);\n\tinitPQExpBuffer(&where_clause);\n\n\t/* LEFT JOIN used here as a node record may have been removed */\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"   SELECT e.node_id, n.node_name, e.event, e.successful, \"\n\t\t\t\t\t\t \"          pg_catalog.to_char(e.event_timestamp, 'YYYY-MM-DD HH24:MI:SS') AS timestamp, \"\n\t\t\t\t\t\t \"          e.details \"\n\t\t\t\t\t\t \"     FROM repmgr.events e \"\n\t\t\t\t\t\t \"LEFT JOIN repmgr.nodes n ON e.node_id = n.node_id \");\n\n\tif (node_id != UNKNOWN_NODE_ID)\n\t{\n\t\tappend_where_clause(&where_clause,\n\t\t\t\t\t\t\t\"n.node_id=%i\", node_id);\n\t}\n\telse if (node_name[0] != '\\0')\n\t{\n\t\tchar\t   *escaped = escape_string(conn, node_name);\n\n\t\tif (escaped == NULL)\n\t\t{\n\t\t\tlog_error(_(\"unable to escape value provided for node name\"));\n\t\t\tlog_detail(_(\"node name is: \\\"%s\\\"\"), node_name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappend_where_clause(&where_clause,\n\t\t\t\t\t\t\t\t\"n.node_name='%s'\",\n\t\t\t\t\t\t\t\tescaped);\n\t\t\tpfree(escaped);\n\t\t}\n\t}\n\n\tif (event[0] != '\\0')\n\t{\n\t\tchar\t   *escaped = escape_string(conn, event);\n\n\t\tif (escaped == NULL)\n\t\t{\n\t\t\tlog_error(_(\"unable to escape value provided for event\"));\n\t\t\tlog_detail(_(\"event is: \\\"%s\\\"\"), event);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappend_where_clause(&where_clause,\n\t\t\t\t\t\t\t\t\"e.event='%s'\",\n\t\t\t\t\t\t\t\tescaped);\n\t\t\tpfree(escaped);\n\t\t}\n\t}\n\n\tappendPQExpBuffer(&query, \"\\n%s\\n\",\n\t\t\t\t\t  where_clause.data);\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \" ORDER BY e.event_timestamp DESC\");\n\n\tif (all == false && limit > 0)\n\t{\n\t\tappendPQExpBuffer(&query, \" LIMIT %i\",\n\t\t\t\t\t\t  limit);\n\t}\n\n\tlog_debug(\"do_cluster_event():\\n%s\", query.data);\n\tres = PQexec(conn, query.data);\n\n\ttermPQExpBuffer(&query);\n\ttermPQExpBuffer(&where_clause);\n\n\treturn res;\n}\n\n\n/* ========================== */\n/* replication slot functions */\n/* ========================== */\n\n\nvoid\ncreate_slot_name(char *slot_name, int node_id)\n{\n\tmaxlen_snprintf(slot_name, \"repmgr_slot_%i\", node_id);\n}\n\n\nstatic ReplSlotStatus\n_verify_replication_slot(PGconn *conn, char *slot_name, PQExpBufferData *error_msg)\n{\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\tt_replication_slot slot_info = T_REPLICATION_SLOT_INITIALIZER;\n\n\t/*\n\t * Check whether slot exists already; if it exists and is active, that\n\t * means another active standby is using it, which creates an error\n\t * situation; if not we can reuse it as-is.\n\t */\n\trecord_status = get_slot_record(conn, slot_name, &slot_info);\n\n\tif (record_status == RECORD_FOUND)\n\t{\n\t\tif (strcmp(slot_info.slot_type, \"physical\") != 0)\n\t\t{\n\t\t\tif (error_msg)\n\t\t\t\tappendPQExpBuffer(error_msg,\n\t\t\t\t\t\t\t\t  _(\"slot \\\"%s\\\" exists and is not a physical slot\\n\"),\n\t\t\t\t\t\t\t\t  slot_name);\n\t\t\treturn SLOT_NOT_PHYSICAL;\n\t\t}\n\n\t\tif (slot_info.active == false)\n\t\t{\n\t\t\tlog_debug(\"replication slot \\\"%s\\\" exists but is inactive; reusing\",\n\t\t\t\t\t  slot_name);\n\n\t\t\treturn SLOT_INACTIVE;\n\t\t}\n\n\t\tif (error_msg)\n\t\t\tappendPQExpBuffer(error_msg,\n\t\t\t\t\t\t\t  _(\"slot \\\"%s\\\" already exists as an active slot\\n\"),\n\t\t\t\t\t\t\t  slot_name);\n\t\treturn SLOT_ACTIVE;\n\t}\n\n\treturn SLOT_NOT_FOUND;\n}\n\n\nbool\ncreate_replication_slot_replprot(PGconn *conn, PGconn *repl_conn, char *slot_name, PQExpBufferData *error_msg)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tReplSlotStatus slot_status = _verify_replication_slot(conn, slot_name, error_msg);\n\n\t/* Replication slot is unusable */\n\tif (slot_status == SLOT_NOT_PHYSICAL || slot_status == SLOT_ACTIVE)\n\t\treturn false;\n\n\t/* Replication slot can be reused */\n\tif (slot_status == SLOT_INACTIVE)\n\t\treturn true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"CREATE_REPLICATION_SLOT %s PHYSICAL\",\n\t\t\t\t\t  slot_name);\n\n\t/* In 9.6 and later, reserve the LSN straight away */\n\tif (PQserverVersion(conn) >= 90600)\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \" RESERVE_WAL\");\n\t}\n\n\tappendPQExpBufferChar(&query, ';');\n\n\tres = PQexec(repl_conn, query.data);\n\n\n\tif ((PQresultStatus(res) != PGRES_TUPLES_OK || !PQntuples(res)) && error_msg != NULL)\n\t{\n\t\tappendPQExpBuffer(error_msg,\n\t\t\t\t\t\t  _(\"unable to create replication slot \\\"%s\\\" on the upstream node: %s\\n\"),\n\t\t\t\t\t\t  slot_name,\n\t\t\t\t\t\t  PQerrorMessage(conn));\n\t\tsuccess = false;\n\t}\n\n\tPQclear(res);\n\treturn success;\n}\n\n\nbool\ncreate_replication_slot_sql(PGconn *conn, char *slot_name, PQExpBufferData *error_msg)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tReplSlotStatus slot_status = _verify_replication_slot(conn, slot_name, error_msg);\n\n\t/* Replication slot is unusable */\n\tif (slot_status == SLOT_NOT_PHYSICAL || slot_status == SLOT_ACTIVE)\n\t\treturn false;\n\n\t/* Replication slot can be reused */\n\tif (slot_status == SLOT_INACTIVE)\n\t\treturn true;\n\n\tinitPQExpBuffer(&query);\n\n\t/* In 9.6 and later, reserve the LSN straight away */\n\tif (PQserverVersion(conn) >= 90600)\n\t{\n\t\tappendPQExpBuffer(&query,\n\t\t\t\t\t\t  \"SELECT * FROM pg_catalog.pg_create_physical_replication_slot('%s', TRUE)\",\n\t\t\t\t\t\t  slot_name);\n\t}\n\telse\n\t{\n\t\tappendPQExpBuffer(&query,\n\t\t\t\t\t\t  \"SELECT * FROM pg_catalog.pg_create_physical_replication_slot('%s')\",\n\t\t\t\t\t\t  slot_name);\n\t}\n\n\tlog_debug(_(\"create_replication_slot_sql(): creating slot \\\"%s\\\" on upstream\"), slot_name);\n\tlog_verbose(LOG_DEBUG, \"create_replication_slot_sql():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\ttermPQExpBuffer(&query);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK && error_msg != NULL)\n\t{\n\t\tappendPQExpBuffer(error_msg,\n\t\t\t\t\t\t  _(\"unable to create replication slot \\\"%s\\\" on the upstream node: %s\\n\"),\n\t\t\t\t\t\t  slot_name,\n\t\t\t\t\t\t  PQerrorMessage(conn));\n\t\tsuccess = false;\n\t}\n\n\tPQclear(res);\n\treturn success;\n}\n\n\nbool\ndrop_replication_slot_sql(PGconn *conn, char *slot_name)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT pg_catalog.pg_drop_replication_slot('%s')\",\n\t\t\t\t\t  slot_name);\n\n\tlog_verbose(LOG_DEBUG, \"drop_replication_slot_sql():\\n  %s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"drop_replication_slot_sql(): unable to drop replication slot \\\"%s\\\"\"),\n\t\t\t\t\t slot_name);\n\n\t\tsuccess = false;\n\t}\n\telse\n\t{\n\t\tlog_verbose(LOG_DEBUG, \"replication slot \\\"%s\\\" successfully dropped\",\n\t\t\t\t\tslot_name);\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\nbool\ndrop_replication_slot_replprot(PGconn *repl_conn, char *slot_name)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"DROP_REPLICATION_SLOT %s;\",\n\t\t\t\t\t  slot_name);\n\n\tlog_verbose(LOG_DEBUG, \"drop_replication_slot_replprot():\\n  %s\", query.data);\n\n\tres = PQexec(repl_conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK || !PQntuples(res))\n\t{\n\t\tlog_db_error(repl_conn, query.data,\n\t\t\t\t\t _(\"drop_replication_slot_replprot(): unable to drop replication slot \\\"%s\\\"\"),\n\t\t\t\t\t slot_name);\n\n\t\tsuccess = false;\n\t}\n\telse\n\t{\n\t\tlog_verbose(LOG_DEBUG, \"replication slot \\\"%s\\\" successfully dropped\",\n\t\t\t\t\tslot_name);\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\nRecordStatus\nget_slot_record(PGconn *conn, char *slot_name, t_replication_slot *record)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tRecordStatus record_status = RECORD_FOUND;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT slot_name, slot_type, active \"\n\t\t\t\t\t  \"  FROM pg_catalog.pg_replication_slots \"\n\t\t\t\t\t  \" WHERE slot_name = '%s' \",\n\t\t\t\t\t  slot_name);\n\n\tlog_verbose(LOG_DEBUG, \"get_slot_record():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"get_slot_record(): unable to query pg_replication_slots\"));\n\n\t\trecord_status = RECORD_ERROR;\n\t}\n\telse if (!PQntuples(res))\n\t{\n\t\trecord_status = RECORD_NOT_FOUND;\n\t}\n\telse\n\t{\n\t\tsnprintf(record->slot_name,\n\t\t\t\t sizeof(record->slot_name),\n\t\t\t\t \"%s\", PQgetvalue(res, 0, 0));\n\t\tsnprintf(record->slot_type,\n\t\t\t\t sizeof(record->slot_type),\n\t\t\t\t \"%s\", PQgetvalue(res, 0, 1));\n\t\trecord->active = atobool(PQgetvalue(res, 0, 2));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn record_status;\n}\n\n\nint\nget_free_replication_slot_count(PGconn *conn, int *max_replication_slots)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tint\t\t\tfree_slots = 0;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \" SELECT pg_catalog.current_setting('max_replication_slots')::INT - \"\n\t\t\t\t\t\t \"          pg_catalog.count(*) \"\n\t\t\t\t\t\t \"          AS free_slots, \"\n\t\t\t\t\t\t \"        pg_catalog.current_setting('max_replication_slots')::INT \"\n\t\t\t\t\t\t \"          AS max_replication_slots \"\n\t\t\t\t\t\t \"   FROM pg_catalog.pg_replication_slots s\"\n\t\t\t\t\t\t \"  WHERE s.slot_type = 'physical'\");\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"get_free_replication_slot_count(): unable to execute replication slot query\"));\n\n\t\tfree_slots = UNKNOWN_VALUE;\n\t}\n\telse if (PQntuples(res) == 0)\n\t{\n\t\tfree_slots = UNKNOWN_VALUE;\n\t}\n\telse\n\t{\n\t\tfree_slots = atoi(PQgetvalue(res, 0, 0));\n\t\tif (max_replication_slots != NULL)\n\t\t\t*max_replication_slots = atoi(PQgetvalue(res, 0, 1));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn free_slots;\n}\n\n\nint\nget_inactive_replication_slots(PGconn *conn, KeyValueList *list)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tint\t\t\ti, inactive_slots = 0;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"   SELECT slot_name, slot_type \"\n\t\t\t\t\t\t \"     FROM pg_catalog.pg_replication_slots \"\n\t\t\t\t\t\t \"    WHERE active IS FALSE \"\n\t\t\t\t\t\t \"      AND slot_type = 'physical' \"\n\t\t\t\t\t\t \" ORDER BY slot_name \");\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"get_inactive_replication_slots(): unable to execute replication slot query\"));\n\n\t\tinactive_slots = -1;\n\t}\n\telse\n\t{\n\t\tinactive_slots = PQntuples(res);\n\n\t\tfor (i = 0; i < inactive_slots; i++)\n\t\t{\n\t\t\tkey_value_list_set(list,\n\t\t\t\t\t\t\t   PQgetvalue(res, i, 0),\n\t\t\t\t\t\t\t   PQgetvalue(res, i, 1));\n\t\t}\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn inactive_slots;\n}\n\n\n\n/* ==================== */\n/* tablespace functions */\n/* ==================== */\n\nbool\nget_tablespace_name_by_location(PGconn *conn, const char *location, char *name)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t    success = true;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT spcname \"\n\t\t\t\t\t  \"  FROM pg_catalog.pg_tablespace \"\n\t\t\t\t\t  \" WHERE pg_catalog.pg_tablespace_location(oid) = '%s'\",\n\t\t\t\t\t  location);\n\n\tlog_verbose(LOG_DEBUG, \"get_tablespace_name_by_location():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data,\n\t\t\t\t\t _(\"get_tablespace_name_by_location(): unable to execute tablespace query\"));\n\t\tsuccess = false;\n\t}\n\telse if (PQntuples(res) == 0)\n\t{\n\t\tsuccess = false;\n\t}\n\telse\n\t{\n\t\tsnprintf(name, MAXLEN,\n\t\t\t\t \"%s\", PQgetvalue(res, 0, 0));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n/* ============================ */\n/* asynchronous query functions */\n/* ============================ */\n\nbool\ncancel_query(PGconn *conn, int timeout)\n{\n\tchar\t\terrbuf[ERRBUFF_SIZE] = \"\";\n\tPGcancel   *pgcancel = NULL;\n\n\tif (wait_connection_availability(conn, timeout) != 1)\n\t\treturn false;\n\n\tpgcancel = PQgetCancel(conn);\n\n\tif (pgcancel == NULL)\n\t\treturn false;\n\n\t/*\n\t * PQcancel can only return 0 if socket()/connect()/send() fails, in any\n\t * of those cases we can assume something bad happened to the connection\n\t */\n\tif (PQcancel(pgcancel, errbuf, ERRBUFF_SIZE) == 0)\n\t{\n\t\tlog_warning(_(\"unable to cancel current query\"));\n\t\tlog_detail(\"\\n%s\", errbuf);\n\t\tPQfreeCancel(pgcancel);\n\t\treturn false;\n\t}\n\n\tPQfreeCancel(pgcancel);\n\n\treturn true;\n}\n\n\n/*\n * Wait until current query finishes, ignoring any results.\n * Usually this will be an async query or query cancellation.\n *\n * Returns 1 for success; 0 if any error occurred; -1 if timeout reached.\n */\nint\nwait_connection_availability(PGconn *conn, int timeout)\n{\n\tPGresult   *res = NULL;\n\tfd_set\t\tread_set;\n\tint\t\t\tsock = PQsocket(conn);\n\tstruct timeval tmout,\n\t\t\t\tbefore,\n\t\t\t\tafter;\n\tstruct timezone tz;\n\tlong long\ttimeout_ms;\n\n\t/* calculate timeout in microseconds */\n\ttimeout_ms = (long long) timeout * 1000000;\n\n\twhile (timeout_ms > 0)\n\t{\n\t\tif (PQconsumeInput(conn) == 0)\n\t\t{\n\t\t\tlog_warning(_(\"wait_connection_availability(): unable to receive data from connection\"));\n\t\t\tlog_detail(\"%s\", PQerrorMessage(conn));\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (PQisBusy(conn) == 0)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tres = PQgetResult(conn);\n\t\t\t\tPQclear(res);\n\t\t\t} while (res != NULL);\n\n\t\t\tbreak;\n\t\t}\n\n\t\ttmout.tv_sec = 0;\n\t\ttmout.tv_usec = 250000;\n\n\t\tFD_ZERO(&read_set);\n\t\tFD_SET(sock, &read_set);\n\n\t\tgettimeofday(&before, &tz);\n\t\tif (select(sock, &read_set, NULL, NULL, &tmout) == -1)\n\t\t{\n\t\t\tlog_warning(_(\"wait_connection_availability(): select() returned with error\"));\n\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\n\t\tgettimeofday(&after, &tz);\n\n\t\ttimeout_ms -= (after.tv_sec * 1000000 + after.tv_usec) -\n\t\t\t(before.tv_sec * 1000000 + before.tv_usec);\n\t}\n\n\n\tif (timeout_ms >= 0)\n\t{\n\t\treturn 1;\n\t}\n\n\tlog_warning(_(\"wait_connection_availability(): timeout (%i secs) reached\"), timeout);\n\treturn -1;\n}\n\n\n/* =========================== */\n/* node availability functions */\n/* =========================== */\n\nbool\nis_server_available(const char *conninfo)\n{\n\treturn _is_server_available(conninfo, false);\n}\n\n\nbool\nis_server_available_quiet(const char *conninfo)\n{\n\treturn _is_server_available(conninfo, true);\n}\n\n\nstatic bool\n_is_server_available(const char *conninfo, bool quiet)\n{\n\tPGPing\t\tstatus = PQping(conninfo);\n\n\tlog_verbose(LOG_DEBUG, \"is_server_available(): ping status for \\\"%s\\\" is %s\", conninfo, print_pqping_status(status));\n\tif (status == PQPING_OK)\n\t\treturn true;\n\n\tif (quiet == false)\n\t{\n\t\tlog_warning(_(\"unable to ping \\\"%s\\\"\"), conninfo);\n\t\tlog_detail(_(\"PQping() returned \\\"%s\\\"\"), print_pqping_status(status));\n\t}\n\n\treturn false;\n}\n\n\nbool\nis_server_available_params(t_conninfo_param_list *param_list)\n{\n\tPGPing\t\tstatus = PQpingParams((const char **) param_list->keywords,\n\t\t\t\t\t\t\t\t\t  (const char **) param_list->values,\n\t\t\t\t\t\t\t\t\t  false);\n\n\t/* deparsing the param_list adds overhead, so only do it if needed  */\n\tif (log_level == LOG_DEBUG || status != PQPING_OK)\n\t{\n\t\tchar *conninfo_str = param_list_to_string(param_list);\n\t\tlog_verbose(LOG_DEBUG, \"is_server_available_params(): ping status for \\\"%s\\\" is %s\", conninfo_str, print_pqping_status(status));\n\n\t\tif (status != PQPING_OK)\n\t\t{\n\t\t\tlog_warning(_(\"unable to ping \\\"%s\\\"\"), conninfo_str);\n\t\t\tlog_detail(_(\"PQping() returned \\\"%s\\\"\"), print_pqping_status(status));\n\t\t}\n\n\t\tpfree(conninfo_str);\n\t}\n\n\tif (status == PQPING_OK)\n\t\treturn true;\n\n\treturn false;\n}\n\n\n\n/*\n * Simple throw-away query to stop a connection handle going stale.\n */\nExecStatusType\nconnection_ping(PGconn *conn)\n{\n\tPGresult   *res = PQexec(conn, \"SELECT TRUE\");\n\tExecStatusType ping_result;\n\n\tlog_verbose(LOG_DEBUG, \"connection_ping(): result is %s\", PQresStatus(PQresultStatus(res)));\n\n\tping_result = PQresultStatus(res);\n\tPQclear(res);\n\n\treturn ping_result;\n}\n\n\nExecStatusType\nconnection_ping_reconnect(PGconn *conn)\n{\n\tExecStatusType ping_result = connection_ping(conn);\n\n\tif (PQstatus(conn) != CONNECTION_OK)\n\t{\n\t\tlog_warning(_(\"connection error, attempting to reset\"));\n\t\tlog_detail(\"\\n%s\", PQerrorMessage(conn));\n\t\tPQreset(conn);\n\t\tping_result = connection_ping(conn);\n\t}\n\n\tlog_verbose(LOG_DEBUG, \"connection_ping_reconnect(): result is %s\", PQresStatus(ping_result));\n\n\treturn ping_result;\n}\n\n\n\n/* ==================== */\n/* monitoring functions */\n/* ==================== */\n\nvoid\nadd_monitoring_record(PGconn *primary_conn,\n\t\t\t\t\t  PGconn *local_conn,\n\t\t\t\t\t  int primary_node_id,\n\t\t\t\t\t  int local_node_id,\n\t\t\t\t\t  char *monitor_standby_timestamp,\n\t\t\t\t\t  XLogRecPtr primary_last_wal_location,\n\t\t\t\t\t  XLogRecPtr last_wal_receive_lsn,\n\t\t\t\t\t  char *last_xact_replay_timestamp,\n\t\t\t\t\t  long long unsigned int replication_lag_bytes,\n\t\t\t\t\t  long long unsigned int apply_lag_bytes\n)\n{\n\tPQExpBufferData query;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"INSERT INTO repmgr.monitoring_history \"\n\t\t\t\t\t  \"           (primary_node_id, \"\n\t\t\t\t\t  \"            standby_node_id, \"\n\t\t\t\t\t  \"            last_monitor_time, \"\n\t\t\t\t\t  \"            last_apply_time, \"\n\t\t\t\t\t  \"            last_wal_primary_location, \"\n\t\t\t\t\t  \"            last_wal_standby_location, \"\n\t\t\t\t\t  \"            replication_lag, \"\n\t\t\t\t\t  \"            apply_lag ) \"\n\t\t\t\t\t  \"     VALUES(%i, \"\n\t\t\t\t\t  \"            %i, \"\n\t\t\t\t\t  \"            '%s'::TIMESTAMP WITH TIME ZONE, \"\n\t\t\t\t\t  \"            '%s'::TIMESTAMP WITH TIME ZONE, \"\n\t\t\t\t\t  \"            '%X/%X', \"\n\t\t\t\t\t  \"            '%X/%X', \"\n\t\t\t\t\t  \"            %llu, \"\n\t\t\t\t\t  \"            %llu) \",\n\t\t\t\t\t  primary_node_id,\n\t\t\t\t\t  local_node_id,\n\t\t\t\t\t  monitor_standby_timestamp,\n\t\t\t\t\t  last_xact_replay_timestamp,\n\t\t\t\t\t  format_lsn(primary_last_wal_location),\n\t\t\t\t\t  format_lsn(last_wal_receive_lsn),\n\t\t\t\t\t  replication_lag_bytes,\n\t\t\t\t\t  apply_lag_bytes);\n\n\tlog_verbose(LOG_DEBUG, \"standby_monitor:()\\n%s\", query.data);\n\n\tif (PQsendQuery(primary_conn, query.data) == 0)\n\t{\n\t\tlog_warning(_(\"query could not be sent to primary:\\n  %s\"),\n\t\t\t\t\tPQerrorMessage(primary_conn));\n\t}\n\telse\n\t{\n\t\tPGresult   *res = PQexec(local_conn, \"SELECT repmgr.standby_set_last_updated()\");\n\n\t\t/* not critical if the above query fails */\n\t\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t\t\tlog_warning(_(\"add_monitoring_record(): unable to set last_updated:\\n  %s\"),\n\t\t\t\t\t\tPQerrorMessage(local_conn));\n\n\t\tPQclear(res);\n\t}\n\n\ttermPQExpBuffer(&query);\n\n\treturn;\n}\n\n\nint\nget_number_of_monitoring_records_to_delete(PGconn *primary_conn, int keep_history, int node_id)\n{\n\tPQExpBufferData query;\n\tint\t\t\t\trecord_count = -1;\n\tPGresult\t   *res = NULL;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT pg_catalog.count(*) \"\n\t\t\t\t\t  \"  FROM repmgr.monitoring_history \"\n\t\t\t\t\t  \" WHERE pg_catalog.age(pg_catalog.now(), last_monitor_time) >= '%d days'::interval\",\n\t\t\t\t\t  keep_history);\n\n\tif (node_id != UNKNOWN_NODE_ID)\n\t{\n\t\tappendPQExpBuffer(&query,\n\t\t\t\t\t\t  \"  AND standby_node_id = %i\", node_id);\n\t}\n\n\tlog_verbose(LOG_DEBUG, \"get_number_of_monitoring_records_to_delete():\\n  %s\", query.data);\n\n\tres = PQexec(primary_conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(primary_conn, query.data,\n\t\t\t\t\t _(\"get_number_of_monitoring_records_to_delete(): unable to query number of monitoring records to clean up\"));\n\t}\n\telse\n\t{\n\t\trecord_count = atoi(PQgetvalue(res, 0, 0));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn record_count;\n}\n\n\nbool\ndelete_monitoring_records(PGconn *primary_conn, int keep_history, int node_id)\n{\n\tPQExpBufferData query;\n\tbool\t\t\tsuccess = true;\n\tPGresult\t   *res = NULL;\n\n\tinitPQExpBuffer(&query);\n\n\tif (keep_history > 0 || node_id != UNKNOWN_NODE_ID)\n\t{\n\t\tappendPQExpBuffer(&query,\n\t\t\t\t\t\t  \"DELETE FROM repmgr.monitoring_history \"\n\t\t\t\t\t\t  \" WHERE pg_catalog.age(pg_catalog.now(), last_monitor_time) >= '%d days'::INTERVAL \",\n\t\t\t\t\t\t  keep_history);\n\n\t\tif (node_id != UNKNOWN_NODE_ID)\n\t\t{\n\t\t\tappendPQExpBuffer(&query,\n\t\t\t\t\t\t\t  \"  AND standby_node_id = %i\", node_id);\n\t\t}\n\t}\n\telse\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \"TRUNCATE TABLE repmgr.monitoring_history\");\n\t}\n\n\tres = PQexec(primary_conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(primary_conn, query.data,\n\t\t\t\t\t _(\"delete_monitoring_records(): unable to delete monitoring records\"));\n\t\tsuccess = false;\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n/*\n * node voting functions\n *\n * These are intended to run under repmgrd and mainly rely on shared memory\n */\n\nint\nget_current_term(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\tint term = VOTING_TERM_NOT_SET;\n\n\tres = PQexec(conn, \"SELECT term FROM repmgr.voting_term\");\n\n\t/* it doesn't matter if for whatever reason the table has no rows */\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, NULL,\n\t\t\t\t\t _(\"get_current_term(): unable to query \\\"repmgr.voting_term\\\"\"));\n\t}\n\telse if (PQntuples(res) > 0)\n\t{\n\t\tterm = atoi(PQgetvalue(res, 0, 0));\n\t}\n\n\tPQclear(res);\n\treturn term;\n}\n\n\nvoid\ninitialize_voting_term(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\n\tint current_term = get_current_term(conn);\n\n\tif (current_term == VOTING_TERM_NOT_SET)\n\t{\n\t\tres = PQexec(conn, \"INSERT INTO repmgr.voting_term (term) VALUES (1)\");\n\t}\n\telse\n\t{\n\t\tres = PQexec(conn, \"UPDATE repmgr.voting_term SET term = 1\");\n\t}\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, NULL, _(\"unable to initialize repmgr.voting_term\"));\n\t}\n\n\tPQclear(res);\n\treturn;\n}\n\n\nvoid\nincrement_current_term(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\n\tres = PQexec(conn, \"UPDATE repmgr.voting_term SET term = term + 1\");\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, NULL, _(\"unable to increment repmgr.voting_term\"));\n\t}\n\n\tPQclear(res);\n\treturn;\n}\n\n\nbool\nannounce_candidature(PGconn *conn, t_node_info *this_node, t_node_info *other_node, int electoral_term)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\n\tbool\t\tretval = false;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT repmgr.other_node_is_candidate(%i, %i)\",\n\t\t\t\t\t  this_node->node_id,\n\t\t\t\t\t  electoral_term);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"announce_candidature(): unable to execute repmgr.other_node_is_candidate()\"));\n\t}\n\telse\n\t{\n\t\tretval = atobool(PQgetvalue(res, 0, 0));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn retval;\n}\n\n\nvoid\nnotify_follow_primary(PGconn *conn, int primary_node_id)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT repmgr.notify_follow_primary(%i)\",\n\t\t\t\t\t  primary_node_id);\n\n\tlog_verbose(LOG_DEBUG, \"notify_follow_primary():\\n  %s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"unable to execute repmgr.notify_follow_primary()\"));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn;\n}\n\n\nbool\nget_new_primary(PGconn *conn, int *primary_node_id)\n{\n\tPGresult   *res = NULL;\n\tint\t\t\tnew_primary_node_id = UNKNOWN_NODE_ID;\n\tbool\t\tsuccess = true;\n\n\tconst char *sqlquery = \"SELECT repmgr.get_new_primary()\";\n\n\tres = PQexec(conn, sqlquery);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, sqlquery, _(\"unable to execute repmgr.get_new_primary()\"));\n\t\tsuccess = false;\n\t}\n\telse if (PQgetisnull(res, 0, 0))\n\t{\n\t\tsuccess = false;\n\t}\n\telse\n\t{\n\t\tnew_primary_node_id = atoi(PQgetvalue(res, 0, 0));\n\t}\n\n\tPQclear(res);\n\n\t/*\n\t * repmgr.get_new_primary() will return UNKNOWN_NODE_ID if\n\t * \"follow_new_primary\" is false\n\t */\n\tif (new_primary_node_id == UNKNOWN_NODE_ID)\n\t\tsuccess = false;\n\n\t*primary_node_id = new_primary_node_id;\n\n\treturn success;\n}\n\n\nvoid\nreset_voting_status(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\n\tconst char *sqlquery = \"SELECT repmgr.reset_voting_status()\";\n\n\tres = PQexec(conn, sqlquery);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, sqlquery, _(\"unable to execute repmgr.reset_voting_status()\"));\n\t}\n\n\tPQclear(res);\n\treturn;\n}\n\n\n/* ============================ */\n/* replication status functions */\n/* ============================ */\n\n/*\n * Returns the current LSN on the primary.\n *\n * This just executes \"pg_current_wal_lsn()\".\n *\n * Function \"get_node_current_lsn()\" below will return the latest\n * LSN regardless of recovery state.\n */\nXLogRecPtr\nget_primary_current_lsn(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\tXLogRecPtr\tptr = InvalidXLogRecPtr;\n\n\tif (PQserverVersion(conn) >= 100000)\n\t{\n\t\tres = PQexec(conn, \"SELECT pg_catalog.pg_current_wal_lsn()\");\n\t}\n\telse\n\t{\n\t\tres = PQexec(conn, \"SELECT pg_catalog.pg_current_xlog_location()\");\n\t}\n\n\tif (PQresultStatus(res) == PGRES_TUPLES_OK)\n\t{\n\t\tptr = parse_lsn(PQgetvalue(res, 0, 0));\n\t}\n\telse\n\t{\n\t\tlog_db_error(conn, NULL, _(\"unable to execute get_primary_current_lsn()\"));\n\t}\n\n\n\tPQclear(res);\n\n\treturn ptr;\n}\n\n\nXLogRecPtr\nget_last_wal_receive_location(PGconn *conn)\n{\n\tPGresult   *res = NULL;\n\tXLogRecPtr\tptr = InvalidXLogRecPtr;\n\n\tif (PQserverVersion(conn) >= 100000)\n\t{\n\t\tres = PQexec(conn, \"SELECT pg_catalog.pg_last_wal_receive_lsn()\");\n\t}\n\telse\n\t{\n\t\tres = PQexec(conn, \"SELECT pg_catalog.pg_last_xlog_receive_location()\");\n\t}\n\n\tif (PQresultStatus(res) == PGRES_TUPLES_OK)\n\t{\n\t\tptr = parse_lsn(PQgetvalue(res, 0, 0));\n\t}\n\telse\n\t{\n\t\tlog_db_error(conn, NULL, _(\"unable to execute get_last_wal_receive_location()\"));\n\t}\n\n\tPQclear(res);\n\n\treturn ptr;\n}\n\n/*\n * Returns the latest LSN for the node regardless of recovery state.\n */\nXLogRecPtr\nget_node_current_lsn(PGconn *conn)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tXLogRecPtr\tptr = InvalidXLogRecPtr;\n\n\tinitPQExpBuffer(&query);\n\n\tif (PQserverVersion(conn) >= 100000)\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \" WITH lsn_states AS ( \"\n\t\t\t\t\t\t\t \"  SELECT \"\n\t\t\t\t\t\t\t \"    CASE WHEN pg_catalog.pg_is_in_recovery() IS FALSE \"\n\t\t\t\t\t\t\t \"      THEN pg_catalog.pg_current_wal_lsn() \"\n\t\t\t\t\t\t\t \"      ELSE NULL \"\n\t\t\t\t\t\t\t \"    END \"\n\t\t\t\t\t\t\t \"      AS current_wal_lsn, \"\n\t\t\t\t\t\t\t \"    CASE WHEN pg_catalog.pg_is_in_recovery() IS TRUE \"\n\t\t\t\t\t\t\t \"      THEN pg_catalog.pg_last_wal_receive_lsn() \"\n\t\t\t\t\t\t\t \"      ELSE NULL \"\n\t\t\t\t\t\t\t \"    END \"\n\t\t\t\t\t\t\t \"      AS last_wal_receive_lsn, \"\n\t\t\t\t\t\t\t \"    CASE WHEN pg_catalog.pg_is_in_recovery() IS TRUE \"\n\t\t\t\t\t\t\t \"      THEN pg_catalog.pg_last_wal_replay_lsn() \"\n\t\t\t\t\t\t\t \"      ELSE NULL \"\n\t\t\t\t\t\t\t \"     END \"\n\t\t\t\t\t\t\t \"       AS last_wal_replay_lsn \"\n\t\t\t\t\t\t\t \" ) \");\n\t}\n\telse\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \" WITH lsn_states AS ( \"\n\t\t\t\t\t\t\t \"  SELECT \"\n\t\t\t\t\t\t\t \"    CASE WHEN pg_catalog.pg_is_in_recovery() IS FALSE \"\n\t\t\t\t\t\t\t \"      THEN pg_catalog.pg_current_xlog_location() \"\n\t\t\t\t\t\t\t \"      ELSE NULL \"\n\t\t\t\t\t\t\t \"    END \"\n\t\t\t\t\t\t\t \"      AS current_wal_lsn, \"\n\t\t\t\t\t\t\t \"    CASE WHEN pg_catalog.pg_is_in_recovery() IS TRUE \"\n\t\t\t\t\t\t\t \"      THEN pg_catalog.pg_last_xlog_receive_location() \"\n\t\t\t\t\t\t\t \"      ELSE NULL \"\n\t\t\t\t\t\t\t \"    END \"\n\t\t\t\t\t\t\t \"      AS last_wal_receive_lsn, \"\n\t\t\t\t\t\t\t \"    CASE WHEN pg_catalog.pg_is_in_recovery() IS TRUE \"\n\t\t\t\t\t\t\t \"      THEN pg_catalog.pg_last_xlog_replay_location() \"\n\t\t\t\t\t\t\t \"      ELSE NULL \"\n\t\t\t\t\t\t\t \"     END \"\n\t\t\t\t\t\t\t \"       AS last_wal_replay_lsn \"\n\t\t\t\t\t\t\t \" ) \");\n\t}\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \" SELECT \"\n\t\t\t\t\t\t \"   CASE WHEN pg_catalog.pg_is_in_recovery() IS FALSE \"\n\t\t\t\t\t\t \"     THEN current_wal_lsn \"\n\t\t\t\t\t\t \"     ELSE \"\n\t\t\t\t\t\t \"       CASE WHEN last_wal_receive_lsn IS NULL \"\n\t\t\t\t\t\t \"       THEN last_wal_replay_lsn \"\n\t\t\t\t\t\t \"         ELSE \"\n\t\t\t\t\t\t \"           CASE WHEN last_wal_replay_lsn > last_wal_receive_lsn \"\n\t\t\t\t\t\t \"             THEN last_wal_replay_lsn \"\n\t\t\t\t\t\t \"             ELSE last_wal_receive_lsn \"\n\t\t\t\t\t\t \"           END \"\n\t\t\t\t\t\t \"       END \"\n\t\t\t\t\t\t \"   END \"\n\t\t\t\t\t\t \"     AS current_lsn \"\n\t\t\t\t\t\t \"   FROM lsn_states \");\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"unable to execute get_node_current_lsn()\"));\n\t}\n\telse if (!PQgetisnull(res, 0, 0))\n\t{\n\t\tptr = parse_lsn(PQgetvalue(res, 0, 0));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn ptr;\n}\n\n\nvoid\ninit_replication_info(ReplInfo *replication_info)\n{\n\tmemset(replication_info->current_timestamp, 0, sizeof(replication_info->current_timestamp));\n\treplication_info->in_recovery = false;\n\treplication_info->timeline_id = UNKNOWN_TIMELINE_ID;\n\treplication_info->last_wal_receive_lsn = InvalidXLogRecPtr;\n\treplication_info->last_wal_replay_lsn = InvalidXLogRecPtr;\n\tmemset(replication_info->last_xact_replay_timestamp, 0, sizeof(replication_info->last_xact_replay_timestamp));\n\treplication_info->replication_lag_time = 0;\n\treplication_info->receiving_streamed_wal = true;\n\treplication_info->wal_replay_paused = false;\n\treplication_info->upstream_last_seen = -1;\n\treplication_info->upstream_node_id = UNKNOWN_NODE_ID;\n}\n\n\nbool\nget_replication_info(PGconn *conn, t_server_type node_type, ReplInfo *replication_info)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tsuccess = true;\n\n\tinitPQExpBuffer(&query);\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \" SELECT ts, \"\n\t\t\t\t\t\t \"        in_recovery, \"\n\t\t\t\t\t\t \"        last_wal_receive_lsn, \"\n\t\t\t\t\t\t \"        last_wal_replay_lsn, \"\n\t\t\t\t\t\t \"        last_xact_replay_timestamp, \"\n\t\t\t\t\t\t \"        CASE WHEN (last_wal_receive_lsn = last_wal_replay_lsn) \"\n\t\t\t\t\t\t \"          THEN 0::INT \"\n\t\t\t\t\t\t \"        ELSE \"\n\t\t\t\t\t\t \"          CASE WHEN last_xact_replay_timestamp IS NULL \"\n\t\t\t\t\t\t \"            THEN 0::INT \"\n\t\t\t\t\t\t \"          ELSE \"\n\t\t\t\t\t\t \"            EXTRACT(epoch FROM (pg_catalog.clock_timestamp() - last_xact_replay_timestamp))::INT \"\n\t\t\t\t\t\t \"          END \"\n\t\t\t\t\t\t \"        END AS replication_lag_time, \"\n\t\t\t\t\t\t \"        last_wal_receive_lsn >= last_wal_replay_lsn AS receiving_streamed_wal, \"\n\t\t\t\t\t\t \"        wal_replay_paused, \"\n\t\t\t\t\t\t \"        upstream_last_seen, \"\n\t\t\t\t\t\t \"        upstream_node_id \"\n\t\t\t\t\t\t \"   FROM ( \"\n\t\t\t\t\t\t \" SELECT CURRENT_TIMESTAMP AS ts, \"\n\t\t\t\t\t\t \"        pg_catalog.pg_is_in_recovery() AS in_recovery, \"\n\t\t\t\t\t\t \"        pg_catalog.pg_last_xact_replay_timestamp() AS last_xact_replay_timestamp, \");\n\n\n\tif (PQserverVersion(conn) >= 100000)\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \"        COALESCE(pg_catalog.pg_last_wal_receive_lsn(), '0/0'::PG_LSN) AS last_wal_receive_lsn, \"\n\t\t\t\t\t\t\t \"        COALESCE(pg_catalog.pg_last_wal_replay_lsn(),  '0/0'::PG_LSN) AS last_wal_replay_lsn, \"\n\t\t\t\t\t\t\t \"        CASE WHEN pg_catalog.pg_is_in_recovery() IS FALSE \"\n\t\t\t\t\t\t\t \"          THEN FALSE \"\n\t\t\t\t\t\t\t \"          ELSE pg_catalog.pg_is_wal_replay_paused() \"\n\t\t\t\t\t\t\t \"        END AS wal_replay_paused, \");\n\t}\n\telse\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \"        COALESCE(pg_catalog.pg_last_xlog_receive_location(), '0/0'::PG_LSN) AS last_wal_receive_lsn, \"\n\t\t\t\t\t\t\t \"        COALESCE(pg_catalog.pg_last_xlog_replay_location(),  '0/0'::PG_LSN) AS last_wal_replay_lsn, \"\n\t\t\t\t\t\t\t \"        CASE WHEN pg_catalog.pg_is_in_recovery() IS FALSE \"\n\t\t\t\t\t\t\t \"          THEN FALSE \"\n\t\t\t\t\t\t\t \"          ELSE pg_catalog.pg_is_xlog_replay_paused() \"\n\t\t\t\t\t\t\t \"        END AS wal_replay_paused, \");\n\t}\n\n\t/* Add information about upstream node from shared memory */\n\tif (node_type == WITNESS)\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \"        repmgr.get_upstream_last_seen() AS upstream_last_seen, \"\n\t\t\t\t\t\t\t \"        repmgr.get_upstream_node_id() AS upstream_node_id \");\n\t}\n\telse\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \"        CASE WHEN pg_catalog.pg_is_in_recovery() IS FALSE \"\n\t\t\t\t\t\t\t \"          THEN -1 \"\n\t\t\t\t\t\t\t \"          ELSE repmgr.get_upstream_last_seen() \"\n\t\t\t\t\t\t\t \"        END AS upstream_last_seen, \");\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \"        CASE WHEN pg_catalog.pg_is_in_recovery() IS FALSE \"\n\t\t\t\t\t\t\t \"          THEN -1 \"\n\t\t\t\t\t\t\t \"          ELSE repmgr.get_upstream_node_id() \"\n\t\t\t\t\t\t\t \"        END AS upstream_node_id \");\n\t}\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"          ) q \");\n\n\tlog_verbose(LOG_DEBUG, \"get_replication_info():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK || !PQntuples(res))\n\t{\n\t\tlog_db_error(conn, query.data, _(\"get_replication_info(): unable to execute query\"));\n\n\t\tsuccess = false;\n\t}\n\telse\n\t{\n\t\tsnprintf(replication_info->current_timestamp,\n\t\t\t\t sizeof(replication_info->current_timestamp),\n\t\t\t\t \"%s\", PQgetvalue(res, 0, 0));\n\t\treplication_info->in_recovery = atobool(PQgetvalue(res, 0, 1));\n\t\treplication_info->last_wal_receive_lsn = parse_lsn(PQgetvalue(res, 0, 2));\n\t\treplication_info->last_wal_replay_lsn = parse_lsn(PQgetvalue(res, 0, 3));\n\t\tsnprintf(replication_info->last_xact_replay_timestamp,\n\t\t\t\t sizeof(replication_info->last_xact_replay_timestamp),\n\t\t\t\t \"%s\", PQgetvalue(res, 0, 4));\n\t\treplication_info->replication_lag_time = atoi(PQgetvalue(res, 0, 5));\n\t\treplication_info->receiving_streamed_wal = atobool(PQgetvalue(res, 0, 6));\n\t\treplication_info->wal_replay_paused = atobool(PQgetvalue(res, 0, 7));\n\t\treplication_info->upstream_last_seen = atoi(PQgetvalue(res, 0, 8));\n\t\treplication_info->upstream_node_id = atoi(PQgetvalue(res, 0, 9));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn success;\n}\n\n\nint\nget_replication_lag_seconds(PGconn *conn)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tint\t\t\tlag_seconds = 0;\n\n\tinitPQExpBuffer(&query);\n\n\tif (PQserverVersion(conn) >= 100000)\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \" SELECT CASE WHEN (pg_catalog.pg_last_wal_receive_lsn() = pg_catalog.pg_last_wal_replay_lsn()) \");\n\n\t}\n\telse\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \" SELECT CASE WHEN (pg_catalog.pg_last_xlog_receive_location() = pg_catalog.pg_last_xlog_replay_location()) \");\n\t}\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"          THEN 0 \"\n\t\t\t\t\t\t \"        ELSE EXTRACT(epoch FROM (pg_catalog.clock_timestamp() - pg_catalog.pg_last_xact_replay_timestamp()))::INT \"\n\t\t\t\t\t\t \"          END \"\n\t\t\t\t\t\t \"        AS lag_seconds\");\n\n\tres = PQexec(conn, query.data);\n\tlog_verbose(LOG_DEBUG, \"get_replication_lag_seconds():\\n%s\", query.data);\n\ttermPQExpBuffer(&query);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_warning(\"%s\", PQerrorMessage(conn));\n\t\tPQclear(res);\n\n\t\treturn UNKNOWN_REPLICATION_LAG;\n\t}\n\n\tif (!PQntuples(res))\n\t{\n\t\treturn UNKNOWN_REPLICATION_LAG;\n\t}\n\n\tlag_seconds = atoi(PQgetvalue(res, 0, 0));\n\n\tPQclear(res);\n\treturn lag_seconds;\n}\n\n\n\nTimeLineID\nget_node_timeline(PGconn *conn, char *timeline_id_str)\n{\n\tTimeLineID timeline_id  = UNKNOWN_TIMELINE_ID;\n\n\t/*\n\t * pg_control_checkpoint() was introduced in PostgreSQL 9.6\n\t */\n\tif (PQserverVersion(conn) >= 90600)\n\t{\n\t\tPGresult   *res = NULL;\n\n\t\tres = PQexec(conn, \"SELECT timeline_id FROM pg_catalog.pg_control_checkpoint()\");\n\n\t\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t\t{\n\t\t\tlog_db_error(conn, NULL, _(\"get_node_timeline(): unable to query pg_control_system()\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttimeline_id = atoi(PQgetvalue(res, 0, 0));\n\t\t}\n\n\t\tPQclear(res);\n\t}\n\n\t/* If requested, format the timeline ID as a string */\n\tif (timeline_id_str != NULL)\n\t{\n\t\tif (timeline_id == UNKNOWN_TIMELINE_ID)\n\t\t{\n\t\t\tstrncpy(timeline_id_str, \"?\", MAXLEN);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsnprintf(timeline_id_str, MAXLEN, \"%i\", timeline_id);\n\t\t}\n\t}\n\n\treturn timeline_id;\n}\n\n\nvoid\nget_node_replication_stats(PGconn *conn, t_node_info *node_info)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \" SELECT pg_catalog.current_setting('max_wal_senders')::INT AS max_wal_senders, \"\n\t\t\t\t\t\t \"        (SELECT pg_catalog.count(*) FROM pg_catalog.pg_stat_replication) AS attached_wal_receivers, \"\n\t\t\t\t\t\t \"        current_setting('max_replication_slots')::INT AS max_replication_slots, \"\n\t\t\t\t\t\t \"        (SELECT pg_catalog.count(*) FROM pg_catalog.pg_replication_slots WHERE slot_type='physical') AS total_replication_slots, \"\n\t\t\t\t\t\t \"        (SELECT pg_catalog.count(*) FROM pg_catalog.pg_replication_slots WHERE active IS TRUE AND slot_type='physical')  AS active_replication_slots, \"\n\t\t\t\t\t\t \"        (SELECT pg_catalog.count(*) FROM pg_catalog.pg_replication_slots WHERE active IS FALSE AND slot_type='physical') AS inactive_replication_slots, \"\n\t\t\t\t\t\t \"        pg_catalog.pg_is_in_recovery() AS in_recovery\");\n\n\tlog_verbose(LOG_DEBUG, \"get_node_replication_stats():\\n%s\", query.data);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_warning(_(\"unable to retrieve node replication statistics\"));\n\t\tlog_detail(\"%s\", PQerrorMessage(conn));\n\t\tlog_detail(\"%s\", query.data);\n\n\t\ttermPQExpBuffer(&query);\n\t\tPQclear(res);\n\n\t\treturn;\n\t}\n\n\tnode_info->max_wal_senders = atoi(PQgetvalue(res, 0, 0));\n\tnode_info->attached_wal_receivers = atoi(PQgetvalue(res, 0, 1));\n\tnode_info->max_replication_slots = atoi(PQgetvalue(res, 0, 2));\n\tnode_info->total_replication_slots = atoi(PQgetvalue(res, 0, 3));\n\tnode_info->active_replication_slots = atoi(PQgetvalue(res, 0, 4));\n\tnode_info->inactive_replication_slots = atoi(PQgetvalue(res, 0, 5));\n\tnode_info->recovery_type = strcmp(PQgetvalue(res, 0, 6), \"f\") == 0 ? RECTYPE_PRIMARY : RECTYPE_STANDBY;\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn;\n}\n\n\nNodeAttached\nis_downstream_node_attached(PGconn *conn, char *node_name, char **node_state)\n{\n\treturn _is_downstream_node_attached(conn, node_name, node_state, false);\n}\n\nNodeAttached\nis_downstream_node_attached_quiet(PGconn *conn, char *node_name, char **node_state)\n{\n\treturn _is_downstream_node_attached(conn, node_name, node_state, true);\n}\n\nNodeAttached\n_is_downstream_node_attached(PGconn *conn, char *node_name, char **node_state, bool quiet)\n{\n\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \" SELECT pid, state \"\n\t\t\t\t\t  \"   FROM pg_catalog.pg_stat_replication \"\n\t\t\t\t\t  \"  WHERE application_name = '%s'\",\n\t\t\t\t\t  node_name);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_verbose(LOG_WARNING, _(\"unable to query pg_stat_replication\"));\n\t\tlog_detail(\"%s\", PQerrorMessage(conn));\n\t\tlog_detail(\"%s\", query.data);\n\n\t\ttermPQExpBuffer(&query);\n\t\tPQclear(res);\n\n\t\treturn NODE_ATTACHED_UNKNOWN;\n\t}\n\n\ttermPQExpBuffer(&query);\n\n\t/*\n\t * If there's more than one entry in pg_stat_application, there's no\n\t * way we can reliably determine which one belongs to the node we're\n\t * checking, so there's nothing more we can do.\n\t */\n\tif (PQntuples(res) > 1)\n\t{\n\t\tif (quiet == false)\n\t\t{\n\t\t\tlog_error(_(\"multiple entries with \\\"application_name\\\" set to  \\\"%s\\\" found in \\\"pg_stat_replication\\\"\"),\n\t\t\t\t\t  node_name);\n\t\t\tlog_hint(_(\"verify that a unique node name is configured for each node\"));\n\t\t}\n\n\t\tPQclear(res);\n\n\t\treturn NODE_ATTACHED_UNKNOWN;\n\t}\n\n\tif (PQntuples(res) == 0)\n\t{\n\t\tif (quiet == false)\n\t\t\tlog_warning(_(\"node \\\"%s\\\" not found in \\\"pg_stat_replication\\\"\"), node_name);\n\n\t\tPQclear(res);\n\n\t\treturn NODE_DETACHED;\n\t}\n\n\t/*\n\t * If the connection is not a superuser or member of pg_read_all_stats, we\n\t * won't be able to retrieve the \"state\" column, so we'll assume\n\t * the node is attached.\n\t */\n\n\tif (connection_has_pg_monitor_role(conn, \"pg_read_all_stats\"))\n\t{\n\t\tconst char *state = PQgetvalue(res, 0, 1);\n\n\t\tif (node_state != NULL)\n\t\t{\n\t\t\tint\t\tstate_len = strlen(state);\n\t\t\t*node_state = palloc0(state_len + 1);\n\t\t\tstrncpy(*node_state, state, state_len);\n\t\t}\n\n\t\tif (strcmp(state, \"streaming\") != 0)\n\t\t{\n\t\t\tif (quiet == false)\n\t\t\t\tlog_warning(_(\"node \\\"%s\\\" attached in state \\\"%s\\\"\"),\n\t\t\t\t\t\t\tnode_name,\n\t\t\t\t\t\t\tstate);\n\n\t\t\tPQclear(res);\n\n\t\t\treturn NODE_NOT_ATTACHED;\n\t\t}\n\t}\n\telse if (node_state != NULL)\n\t{\n\t\t*node_state = palloc0(1);\n\t\t*node_state[0] = '\\0';\n\t}\n\n\tPQclear(res);\n\n\treturn NODE_ATTACHED;\n}\n\n\nvoid\nset_upstream_last_seen(PGconn *conn, int upstream_node_id)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBuffer(&query,\n\t\t\t\t\t  \"SELECT repmgr.set_upstream_last_seen(%i)\",\n\t\t\t\t\t  upstream_node_id);\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"unable to execute repmgr.set_upstream_last_seen()\"));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n}\n\n\nint\nget_upstream_last_seen(PGconn *conn, t_server_type node_type)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tint upstream_last_seen = -1;\n\n\tinitPQExpBuffer(&query);\n\n\tif (node_type == WITNESS)\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \"SELECT repmgr.get_upstream_last_seen()\");\n\t}\n\telse\n\t{\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \"SELECT CASE WHEN pg_catalog.pg_is_in_recovery() IS FALSE \"\n\t\t\t\t\t\t\t \"   THEN -1 \"\n\t\t\t\t\t\t\t \"   ELSE repmgr.get_upstream_last_seen() \"\n\t\t\t\t\t\t\t \" END AS upstream_last_seen \");\n\t}\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"unable to execute repmgr.get_upstream_last_seen()\"));\n\t}\n\telse\n\t{\n\t\tupstream_last_seen = atoi(PQgetvalue(res, 0, 0));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn upstream_last_seen;\n}\n\n\nbool\nis_wal_replay_paused(PGconn *conn, bool check_pending_wal)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tbool\t\tis_paused = false;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \"SELECT paused.wal_replay_paused \");\n\n\tif (PQserverVersion(conn) >= 100000)\n\t{\n\t\tif (check_pending_wal == true)\n\t\t{\n\t\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t\t \" AND pg_catalog.pg_last_wal_replay_lsn() < pg_catalog.pg_last_wal_receive_lsn() \");\n\t\t}\n\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \" FROM (SELECT CASE WHEN pg_catalog.pg_is_in_recovery() IS FALSE \"\n\t\t\t\t\t\t\t \"                THEN FALSE \"\n\t\t\t\t\t\t\t \"                ELSE pg_catalog.pg_is_wal_replay_paused() \"\n\t\t\t\t\t\t\t \"              END AS wal_replay_paused) paused \");\n\t}\n\telse\n\t{\n\t\tif (check_pending_wal == true)\n\t\t{\n\t\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t\t \" AND pg_catalog.pg_last_xlog_replay_location() < pg_catalog.pg_last_xlog_receive_location() \");\n\t\t}\n\n\t\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t\t \" FROM (SELECT CASE WHEN pg_catalog.pg_is_in_recovery() IS FALSE \"\n\t\t\t\t\t\t\t \"                THEN FALSE \"\n\t\t\t\t\t\t\t \"                ELSE pg_catalog.pg_is_xlog_replay_paused() \"\n\t\t\t\t\t\t\t \"              END AS wal_replay_paused) paused \");\n\n\t}\n\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"unable to execute WAL replay pause query\"));\n\t}\n\telse\n\t{\n\t\tis_paused = atobool(PQgetvalue(res, 0, 0));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\n\treturn is_paused;\n}\n\n/* repmgrd status functions */\n\nCheckStatus\nget_repmgrd_status(PGconn *conn)\n{\n\tPQExpBufferData query;\n\tPGresult   *res = NULL;\n\tCheckStatus\trepmgrd_status = CHECK_STATUS_CRITICAL;\n\n\tinitPQExpBuffer(&query);\n\n\tappendPQExpBufferStr(&query,\n\t\t\t\t\t\t \" SELECT \"\n\t\t\t\t\t\t \" CASE \"\n\t\t\t\t\t\t \"   WHEN repmgr.repmgrd_is_running() \"\n\t\t\t\t\t\t \"   THEN \"\n\t\t\t\t\t\t \"     CASE \"\n\t\t\t\t\t\t \"       WHEN repmgr.repmgrd_is_paused() THEN 1 ELSE 0 \"\n\t\t\t\t\t\t \"     END \"\n\t\t\t\t\t\t \"   ELSE 2 \"\n\t\t\t\t\t\t \" END AS repmgrd_status\");\n\tres = PQexec(conn, query.data);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_db_error(conn, query.data, _(\"unable to execute repmgrd status query\"));\n\t}\n\telse\n\t{\n\t\trepmgrd_status = atoi(PQgetvalue(res, 0, 0));\n\t}\n\n\ttermPQExpBuffer(&query);\n\tPQclear(res);\n\treturn repmgrd_status;\n}\n\n\n/* miscellaneous debugging functions */\n\nconst char *\nprint_node_status(NodeStatus node_status)\n{\n\tswitch (node_status)\n\t{\n\t\tcase NODE_STATUS_UNKNOWN:\n\t\t\treturn \"UNKNOWN\";\n\t\tcase NODE_STATUS_UP:\n\t\t\treturn \"UP\";\n\t\tcase NODE_STATUS_SHUTTING_DOWN:\n\t\t\treturn \"SHUTTING_DOWN\";\n\t\tcase NODE_STATUS_DOWN:\n\t\t\treturn \"SHUTDOWN\";\n\t\tcase NODE_STATUS_UNCLEAN_SHUTDOWN:\n\t\t\treturn \"UNCLEAN_SHUTDOWN\";\n\t\tcase NODE_STATUS_REJECTED:\n\t\t\treturn \"REJECTED\";\n\t}\n\n\treturn \"UNIDENTIFIED_STATUS\";\n}\n\n\nconst char *\nprint_pqping_status(PGPing ping_status)\n{\n\tswitch (ping_status)\n\t{\n\t\tcase PQPING_OK:\n\t\t\treturn \"PQPING_OK\";\n\t\tcase PQPING_REJECT:\n\t\t\treturn \"PQPING_REJECT\";\n\t\tcase PQPING_NO_RESPONSE:\n\t\t\treturn \"PQPING_NO_RESPONSE\";\n\t\tcase PQPING_NO_ATTEMPT:\n\t\t\treturn \"PQPING_NO_ATTEMPT\";\n\t}\n\n\treturn \"PQPING_UNKNOWN_STATUS\";\n}\n"
        },
        {
          "name": "dbutils.h",
          "type": "blob",
          "size": 18.9560546875,
          "content": "/*\n * dbutils.h\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _REPMGR_DBUTILS_H_\n#define _REPMGR_DBUTILS_H_\n\n#include \"access/timeline.h\"\n#include \"access/xlogdefs.h\"\n#include \"pqexpbuffer.h\"\n#include \"portability/instr_time.h\"\n\n#include \"configfile.h\"\n#include \"strutil.h\"\n#include \"voting.h\"\n\n#define REPMGR_NODES_COLUMNS \\\n\t\"n.node_id, \" \\\n\t\"n.type, \" \\\n\t\"n.upstream_node_id, \" \\\n\t\"n.node_name,  \" \\\n\t\"n.conninfo, \" \\\n\t\"n.repluser, \" \\\n\t\"n.slot_name, \" \\\n\t\"n.location, \" \\\n\t\"n.priority, \" \\\n\t\"n.active, \" \\\n\t\"n.config_file, \" \\\n\t\"'' AS upstream_node_name, \" \\\n\t\"NULL AS attached \"\n\n#define REPMGR_NODES_COLUMNS_WITH_UPSTREAM \\\n\t\"n.node_id, \" \\\n\t\"n.type, \" \\\n\t\"n.upstream_node_id, \" \\\n\t\"n.node_name, \" \\\n\t\"n.conninfo, \" \\\n\t\"n.repluser, \" \\\n\t\"n.slot_name, \" \\\n\t\"n.location, \" \\\n\t\"n.priority, \" \\\n\t\"n.active, \"\\\n\t\"n.config_file, \" \\\n\t\"un.node_name AS upstream_node_name, \" \\\n\t\"NULL AS attached \"\n\n\n#define ERRBUFF_SIZE 512\n\ntypedef enum\n{\n\tUNKNOWN = 0,\n\tPRIMARY,\n\tSTANDBY,\n\tWITNESS\n} t_server_type;\n\ntypedef enum\n{\n\tREPMGR_INSTALLED = 0,\n\tREPMGR_OLD_VERSION_INSTALLED,\n\tREPMGR_AVAILABLE,\n\tREPMGR_UNAVAILABLE,\n\tREPMGR_UNKNOWN\n} ExtensionStatus;\n\ntypedef enum\n{\n\tRECTYPE_UNKNOWN = -1,\n\tRECTYPE_PRIMARY,\n\tRECTYPE_STANDBY\n} RecoveryType;\n\ntypedef enum\n{\n\tRECORD_ERROR = -1,\n\tRECORD_FOUND,\n\tRECORD_NOT_FOUND\n} RecordStatus;\n\ntypedef enum\n{\n\tMS_NORMAL = 0,\n\tMS_DEGRADED = 1\n} MonitoringState;\n\ntypedef enum\n{\n\tNODE_STATUS_UNKNOWN = -1,\n\tNODE_STATUS_UP,\n\tNODE_STATUS_SHUTTING_DOWN,\n\tNODE_STATUS_DOWN,\n\tNODE_STATUS_UNCLEAN_SHUTDOWN,\n\tNODE_STATUS_REJECTED\n} NodeStatus;\n\ntypedef enum\n{\n\tCONN_UNKNOWN = -1,\n\tCONN_OK,\n\tCONN_BAD,\n\tCONN_ERROR\n} ConnectionStatus;\n\ntypedef enum\n{\n\t/* unable to query \"pg_stat_replication\" or other error */\n\tNODE_ATTACHED_UNKNOWN = -1,\n\t/* node has record in \"pg_stat_replication\" and state is not \"streaming\" */\n\tNODE_ATTACHED,\n\t/* node has record in \"pg_stat_replication\" but state is not \"streaming\" */\n\tNODE_NOT_ATTACHED,\n\t/* node has no record in \"pg_stat_replication\" */\n\tNODE_DETACHED\n} NodeAttached;\n\ntypedef enum\n{\n\tSLOT_UNKNOWN = -1,\n\tSLOT_NOT_FOUND,\n\tSLOT_NOT_PHYSICAL,\n\tSLOT_INACTIVE,\n\tSLOT_ACTIVE\n} ReplSlotStatus;\n\ntypedef enum\n{\n\tBACKUP_STATE_UNKNOWN = -1,\n\tBACKUP_STATE_IN_BACKUP,\n\tBACKUP_STATE_NO_BACKUP\n} BackupState;\n\n\n\n/*\n * Struct to store extension version information\n */\n\ntypedef struct s_extension_versions {\n\tchar\t\tdefault_version[8];\n\tint\t\t\tdefault_version_num;\n\tchar\t\tinstalled_version[8];\n\tint\t\t\tinstalled_version_num;\n} t_extension_versions;\n\n#define T_EXTENSION_VERSIONS_INITIALIZER { \\\n\t\"\", \\\n\tUNKNOWN_SERVER_VERSION_NUM, \\\n\t\"\", \\\n\tUNKNOWN_SERVER_VERSION_NUM \\\n}\n\n\ntypedef struct\n{\n\tchar\t\tcurrent_timestamp[MAXLEN];\n\tbool\t\tin_recovery;\n\tTimeLineID\ttimeline_id;\n\tchar\t\ttimeline_id_str[MAXLEN];\n\tXLogRecPtr\tlast_wal_receive_lsn;\n\tXLogRecPtr\tlast_wal_replay_lsn;\n\tchar\t\tlast_xact_replay_timestamp[MAXLEN];\n\tint\t\t\treplication_lag_time;\n\tbool\t\treceiving_streamed_wal;\n\tbool\t\twal_replay_paused;\n\tint\t\t\tupstream_last_seen;\n\tint\t\t\tupstream_node_id;\n} ReplInfo;\n\n/*\n * Struct to store node information.\n *\n * The first section represents the contents of the \"repmgr.nodes\"\n * table; subsequent section contain information collated in\n * various contexts.\n */\ntypedef struct s_node_info\n{\n\t/* contents of \"repmgr.nodes\" */\n\tint\t\t\tnode_id;\n\tint\t\t\tupstream_node_id;\n\tt_server_type type;\n\tchar\t\tnode_name[NAMEDATALEN];\n\tchar\t\tupstream_node_name[NAMEDATALEN];\n\tchar\t\tconninfo[MAXLEN];\n\tchar\t\trepluser[NAMEDATALEN];\n\tchar\t\tlocation[MAXLEN];\n\tint\t\t\tpriority;\n\tbool\t\tactive;\n\tchar\t\tslot_name[MAXLEN];\n\tchar\t\tconfig_file[MAXPGPATH];\n\t/* used during failover to track node status */\n\tXLogRecPtr\tlast_wal_receive_lsn;\n\tNodeStatus\tnode_status;\n\tRecoveryType recovery_type;\n\tMonitoringState monitoring_state;\n\tPGconn\t   *conn;\n\t/* for ad-hoc use e.g. when working with a list of nodes */\n\tchar\t\tdetails[MAXLEN];\n\tbool\t\treachable;\n\tNodeAttached attached;\n\t/* various statistics */\n\tint\t\t\tmax_wal_senders;\n\tint\t\t\tattached_wal_receivers;\n\tint\t\t\tmax_replication_slots;\n\tint\t\t\ttotal_replication_slots;\n\tint\t\t\tactive_replication_slots;\n\tint\t\t\tinactive_replication_slots;\n\t/* replication info */\n\tReplInfo   *replication_info;\n} t_node_info;\n\n\n#define T_NODE_INFO_INITIALIZER { \\\n   \t/* contents of \"repmgr.nodes\" */ \\\n\tNODE_NOT_FOUND, \\\n\tNO_UPSTREAM_NODE, \\\n\tUNKNOWN, \\\n\t\"\", \\\n\t\"\", \\\n\t\"\", \\\n\t\"\", \\\n\tDEFAULT_LOCATION, \\\n\tDEFAULT_PRIORITY, \\\n\ttrue, \\\n\t\"\", \\\n\t\"\", \\\n\t/* used during failover to track node status */ \\\n\tInvalidXLogRecPtr, \\\n\tNODE_STATUS_UNKNOWN, \\\n\tRECTYPE_UNKNOWN,  \\\n\tMS_NORMAL, \\\n\tNULL, \\\n\t/* for ad-hoc use e.g. when working with a list of nodes */ \\\n\t\"\", true, true,\t\\\n\t/* various statistics */ \\\n\t-1, -1, -1, -1, -1, -1,\t\\\n\tNULL \\\n}\n\n\n/* structs to store a list of repmgr node records */\ntypedef struct NodeInfoListCell\n{\n\tstruct NodeInfoListCell *next;\n\tt_node_info *node_info;\n} NodeInfoListCell;\n\ntypedef struct NodeInfoList\n{\n\tNodeInfoListCell *head;\n\tNodeInfoListCell *tail;\n\tint\t\t\tnode_count;\n} NodeInfoList;\n\n#define T_NODE_INFO_LIST_INITIALIZER { \\\n\tNULL, \\\n\tNULL, \\\n\t0 \\\n}\n\ntypedef struct s_event_info\n{\n\tchar\t   *node_name;\n\tchar\t   *conninfo_str;\n\tint\t\t\tnode_id;\n} t_event_info;\n\n#define T_EVENT_INFO_INITIALIZER { \\\n\tNULL, \\\n\tNULL, \\\n\tUNKNOWN_NODE_ID \\\n}\n\n\n/*\n * Struct to store list of conninfo keywords and values\n */\ntypedef struct\n{\n\tint\t\t\tsize;\n\tchar\t  **keywords;\n\tchar\t  **values;\n} t_conninfo_param_list;\n\n#define T_CONNINFO_PARAM_LIST_INITIALIZER { \\\n\t0, \\\n\tNULL, \\\n\tNULL, \\\n}\n\n/*\n * Struct to store replication slot information\n */\ntypedef struct s_replication_slot\n{\n\tchar\t\tslot_name[MAXLEN];\n\tchar\t\tslot_type[MAXLEN];\n\tbool\t\tactive;\n} t_replication_slot;\n\n#define T_REPLICATION_SLOT_INITIALIZER { \"\", \"\", false }\n\n\ntypedef struct s_connection_user\n{\n\tchar\t\tusername[MAXLEN];\n\tbool\t\tis_superuser;\n} t_connection_user;\n\n#define T_CONNECTION_USER_INITIALIZER { \"\", false }\n\n\ntypedef struct\n{\n\tchar\t\tfilepath[MAXPGPATH];\n\tchar\t\tfilename[MAXPGPATH];\n\tbool\t\tin_data_directory;\n} t_configfile_info;\n\n#define T_CONFIGFILE_INFO_INITIALIZER { \"\", \"\", false }\n\n\ntypedef struct\n{\n\tint\t\t\tsize;\n\tint\t\t\tentries;\n\tt_configfile_info **files;\n} t_configfile_list;\n\n#define T_CONFIGFILE_LIST_INITIALIZER { 0, 0, NULL }\n\n\ntypedef struct\n{\n\tuint64\t\tsystem_identifier;\n\tTimeLineID\ttimeline;\n\tXLogRecPtr\txlogpos;\n} t_system_identification;\n\n#define T_SYSTEM_IDENTIFICATION_INITIALIZER { \\\n    UNKNOWN_SYSTEM_IDENTIFIER, \\\n    UNKNOWN_TIMELINE_ID, \\\n\tInvalidXLogRecPtr \\\n}\n\n\ntypedef struct RepmgrdInfo {\n\tint node_id;\n\tint pid;\n\tchar pid_text[MAXLEN];\n\tchar pid_file[MAXLEN];\n\tbool pg_running;\n\tchar pg_running_text[MAXLEN];\n\tRecoveryType recovery_type;\n\tbool running;\n\tchar repmgrd_running[MAXLEN];\n\tbool paused;\n\tbool wal_paused_pending_wal;\n\tint  upstream_last_seen;\n\tchar upstream_last_seen_text[MAXLEN];\n} RepmgrdInfo;\n\n\n/* macros */\n\n#define is_streaming_replication(x) (x == PRIMARY || x == STANDBY)\n#define format_lsn(x) (uint32) (x >> 32), (uint32) x\n\n/* utility functions */\n\nXLogRecPtr\tparse_lsn(const char *str);\nbool\t\tatobool(const char *value);\n\n/* connection functions */\nPGconn\t   *establish_db_connection(const char *conninfo,\n\t\t\t\t\t\tconst bool exit_on_error);\nPGconn\t   *establish_db_connection_quiet(const char *conninfo);\nPGconn\t   *establish_db_connection_by_params(t_conninfo_param_list *param_list,\n\t\t\t\t\t\t\t\t  const bool exit_on_error);\nPGconn\t   *establish_db_connection_with_replacement_param(const char *conninfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   const char *param,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   const char *value,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   const bool exit_on_error);\nPGconn\t   *establish_replication_connection_from_conn(PGconn *conn, const char *repluser);\nPGconn\t   *establish_replication_connection_from_conninfo(const char *conninfo, const char *repluser);\n\nPGconn\t   *establish_primary_db_connection(PGconn *conn,\n\t\t\t\t\t\t\t\tconst bool exit_on_error);\nPGconn\t   *get_primary_connection(PGconn *standby_conn, int *primary_id, char *primary_conninfo_out);\nPGconn\t   *get_primary_connection_quiet(PGconn *standby_conn, int *primary_id, char *primary_conninfo_out);\nPGconn\t   *duplicate_connection(PGconn *conn, const char *user, bool replication);\n\nvoid\t\tclose_connection(PGconn **conn);\n\n/* conninfo manipulation functions */\nbool\t\tget_conninfo_value(const char *conninfo, const char *keyword, char *output);\nbool\t\tget_conninfo_default_value(const char *param, char *output, int maxlen);\nvoid\t\tinitialize_conninfo_params(t_conninfo_param_list *param_list, bool set_defaults);\nvoid\t\tfree_conninfo_params(t_conninfo_param_list *param_list);\nvoid\t\tcopy_conninfo_params(t_conninfo_param_list *dest_list, t_conninfo_param_list *source_list);\nvoid\t\tconn_to_param_list(PGconn *conn, t_conninfo_param_list *param_list);\nvoid\t\tparam_set(t_conninfo_param_list *param_list, const char *param, const char *value);\nvoid\t\tparam_set_ine(t_conninfo_param_list *param_list, const char *param, const char *value);\nchar\t   *param_get(t_conninfo_param_list *param_list, const char *param);\nbool\t\tvalidate_conninfo_string(const char *conninfo_str, char **errmsg);\nbool\t\tparse_conninfo_string(const char *conninfo_str, t_conninfo_param_list *param_list, char **errmsg, bool ignore_local_params);\nchar\t   *param_list_to_string(t_conninfo_param_list *param_list);\nchar\t   *normalize_conninfo_string(const char *conninfo_str);\nbool\t\thas_passfile(void);\n\n\n/* transaction functions */\nbool\t\tbegin_transaction(PGconn *conn);\nbool\t\tcommit_transaction(PGconn *conn);\nbool\t\trollback_transaction(PGconn *conn);\n\n/* GUC manipulation functions */\nbool\t\tset_config(PGconn *conn, const char *config_param, const char *config_value);\nbool\t\tset_config_bool(PGconn *conn, const char *config_param, bool state);\nint\t\t    guc_set(PGconn *conn, const char *parameter, const char *op, const char *value);\nbool\t\tget_pg_setting(PGconn *conn, const char *setting, char *output);\nbool\t\tget_pg_setting_bool(PGconn *conn, const char *setting, bool *output);\nbool\t\tget_pg_setting_int(PGconn *conn, const char *setting, int *output);\nbool\t\talter_system_int(PGconn *conn, const char *name, int value);\nbool\t\tpg_reload_conf(PGconn *conn);\n\n/* server information functions */\nbool\t\tget_cluster_size(PGconn *conn, char *size);\nint\t\t\tget_server_version(PGconn *conn, char *server_version_buf);\n\nRecoveryType get_recovery_type(PGconn *conn);\nint\t\t\tget_primary_node_id(PGconn *conn);\nint\t\t\tget_ready_archive_files(PGconn *conn, const char *data_directory);\nbool\t\tidentify_system(PGconn *repl_conn, t_system_identification *identification);\nuint64\t\tsystem_identifier(PGconn *conn);\nTimeLineHistoryEntry *get_timeline_history(PGconn *repl_conn, TimeLineID tli);\npid_t\t\tget_wal_receiver_pid(PGconn *conn);\n\n/* user/role information functions */\nbool\t\tcan_execute_checkpoint(PGconn *conn);\nbool\t\tcan_execute_pg_promote(PGconn *conn);\nbool\t\tcan_disable_walsender(PGconn *conn);\nbool\t\tconnection_has_pg_monitor_role(PGconn *conn, const char *subrole);\nbool\t\tis_replication_role(PGconn *conn, char *rolname);\nbool\t\tis_superuser_connection(PGconn *conn, t_connection_user *userinfo);\n\n/* repmgrd shared memory functions */\nbool\t\trepmgrd_set_local_node_id(PGconn *conn, int local_node_id);\nint\t\t\trepmgrd_get_local_node_id(PGconn *conn);\nbool\t\trepmgrd_check_local_node_id(PGconn *conn);\nBackupState\tserver_in_exclusive_backup_mode(PGconn *conn);\nvoid\t\trepmgrd_set_pid(PGconn *conn, pid_t repmgrd_pid, const char *pidfile);\npid_t\t\trepmgrd_get_pid(PGconn *conn);\nbool\t\trepmgrd_is_running(PGconn *conn);\nbool\t\trepmgrd_is_paused(PGconn *conn);\nbool\t\trepmgrd_pause(PGconn *conn, bool pause);\nint\t\t\trepmgrd_get_upstream_node_id(PGconn *conn);\nbool\t\trepmgrd_set_upstream_node_id(PGconn *conn, int node_id);\n\n/* extension functions */\nExtensionStatus get_repmgr_extension_status(PGconn *conn, t_extension_versions *extversions);\n\n/* node management functions */\nvoid\t\tcheckpoint(PGconn *conn);\nbool\t\tvacuum_table(PGconn *conn, const char *table);\nbool\t\tpromote_standby(PGconn *conn, bool wait, int wait_seconds);\nbool\t\tresume_wal_replay(PGconn *conn);\n\n/* node record functions */\nt_server_type parse_node_type(const char *type);\nconst char *get_node_type_string(t_server_type type);\n\nRecordStatus get_node_record(PGconn *conn, int node_id, t_node_info *node_info);\nRecordStatus refresh_node_record(PGconn *conn, int node_id, t_node_info *node_info);\n\nRecordStatus get_node_record_with_upstream(PGconn *conn, int node_id, t_node_info *node_info);\n\nRecordStatus get_node_record_by_name(PGconn *conn, const char *node_name, t_node_info *node_info);\nt_node_info *get_node_record_pointer(PGconn *conn, int node_id);\n\nbool\t\tget_local_node_record(PGconn *conn, int node_id, t_node_info *node_info);\nbool\t\tget_primary_node_record(PGconn *conn, t_node_info *node_info);\n\nbool\t\tget_all_node_records(PGconn *conn, NodeInfoList *node_list);\nbool\t\tget_all_nodes_count(PGconn *conn, int *count);\nvoid\t\tget_downstream_node_records(PGconn *conn, int node_id, NodeInfoList *nodes);\nvoid\t\tget_active_sibling_node_records(PGconn *conn, int node_id, int upstream_node_id, NodeInfoList *node_list);\nbool\t\tget_child_nodes(PGconn *conn, int node_id, NodeInfoList *node_list);\nvoid\t\tget_node_records_by_priority(PGconn *conn, NodeInfoList *node_list);\nbool\t\tget_all_node_records_with_upstream(PGconn *conn, NodeInfoList *node_list);\nbool\t\tget_downstream_nodes_with_missing_slot(PGconn *conn, int this_node_id, NodeInfoList *noede_list);\n\nbool\t\tcreate_node_record(PGconn *conn, char *repmgr_action, t_node_info *node_info);\nbool\t\tupdate_node_record(PGconn *conn, char *repmgr_action, t_node_info *node_info);\nbool\t\tdelete_node_record(PGconn *conn, int node);\nbool\t\ttruncate_node_records(PGconn *conn);\n\nbool\t\tupdate_node_record_set_active(PGconn *conn, int this_node_id, bool active);\nbool\t\tupdate_node_record_set_primary(PGconn *conn, int this_node_id);\nbool\t\tupdate_node_record_set_active_standby(PGconn *conn, int this_node_id);\nbool\t\tupdate_node_record_set_upstream(PGconn *conn, int this_node_id, int new_upstream_node_id);\nbool\t\tupdate_node_record_status(PGconn *conn, int this_node_id, char *type, int upstream_node_id, bool active);\nbool\t\tupdate_node_record_conn_priority(PGconn *conn, t_configuration_options *options);\nbool\t\tupdate_node_record_slot_name(PGconn *primary_conn, int node_id, char *slot_name);\n\nbool\t\twitness_copy_node_records(PGconn *primary_conn, PGconn *witness_conn);\n\nvoid\t\tclear_node_info_list(NodeInfoList *nodes);\n\n/* PostgreSQL configuration file location functions */\nbool\t\tget_datadir_configuration_files(PGconn *conn, KeyValueList *list);\nbool\t\tget_configuration_file_locations(PGconn *conn, t_configfile_list *list);\nvoid\t\tconfig_file_list_init(t_configfile_list *list, int max_size);\nvoid\t\tconfig_file_list_add(t_configfile_list *list, const char *file, const char *filename, bool in_data_dir);\n\n/* event functions */\nbool\t\tcreate_event_record(PGconn *conn, t_configuration_options *options, int node_id, char *event, bool successful, char *details);\nbool\t\tcreate_event_notification(PGconn *conn, t_configuration_options *options, int node_id, char *event, bool successful, char *details);\nbool\t\tcreate_event_notification_extended(PGconn *conn, t_configuration_options *options, int node_id, char *event, bool successful, char *details, t_event_info *event_info);\nPGresult   *get_event_records(PGconn *conn, int node_id, const char *node_name, const char *event, bool all, int limit);\n\n/* replication slot functions */\nvoid\t\tcreate_slot_name(char *slot_name, int node_id);\n\nbool\t\tcreate_replication_slot_sql(PGconn *conn, char *slot_name, PQExpBufferData *error_msg);\nbool\t\tcreate_replication_slot_replprot(PGconn *conn, PGconn *repl_conn, char *slot_name, PQExpBufferData *error_msg);\nbool\t\tdrop_replication_slot_sql(PGconn *conn, char *slot_name);\nbool\t\tdrop_replication_slot_replprot(PGconn *repl_conn, char *slot_name);\n\nRecordStatus get_slot_record(PGconn *conn, char *slot_name, t_replication_slot *record);\nint\t\t\tget_free_replication_slot_count(PGconn *conn, int *max_replication_slots);\nint\t\t\tget_inactive_replication_slots(PGconn *conn, KeyValueList *list);\n\n/* tablespace functions */\nbool\t\tget_tablespace_name_by_location(PGconn *conn, const char *location, char *name);\n\n/* asynchronous query functions */\nbool\t\tcancel_query(PGconn *conn, int timeout);\nint\t\t\twait_connection_availability(PGconn *conn, int timeout);\n\n/* node availability functions */\nbool\t\tis_server_available(const char *conninfo);\nbool\t\tis_server_available_quiet(const char *conninfo);\nbool\t\tis_server_available_params(t_conninfo_param_list *param_list);\nExecStatusType\tconnection_ping(PGconn *conn);\nExecStatusType\tconnection_ping_reconnect(PGconn *conn);\n\n/* monitoring functions  */\nvoid\nadd_monitoring_record(PGconn *primary_conn,\n\t\t\t\t\t  PGconn *local_conn,\n\t\t\t\t\t  int primary_node_id,\n\t\t\t\t\t  int local_node_id,\n\t\t\t\t\t  char *monitor_standby_timestamp,\n\t\t\t\t\t  XLogRecPtr primary_last_wal_location,\n\t\t\t\t\t  XLogRecPtr last_wal_receive_lsn,\n\t\t\t\t\t  char *last_xact_replay_timestamp,\n\t\t\t\t\t  long long unsigned int replication_lag_bytes,\n\t\t\t\t\t  long long unsigned int apply_lag_bytes\n);\n\nint\t\t\tget_number_of_monitoring_records_to_delete(PGconn *primary_conn, int keep_history, int node_id);\nbool\t\tdelete_monitoring_records(PGconn *primary_conn, int keep_history, int node_id);\n\n\n\n/* node voting functions */\nvoid\t\tinitialize_voting_term(PGconn *conn);\nint\t\t\tget_current_term(PGconn *conn);\nvoid\t\tincrement_current_term(PGconn *conn);\nbool\t\tannounce_candidature(PGconn *conn, t_node_info *this_node, t_node_info *other_node, int electoral_term);\nvoid\t\tnotify_follow_primary(PGconn *conn, int primary_node_id);\nbool\t\tget_new_primary(PGconn *conn, int *primary_node_id);\nvoid\t\treset_voting_status(PGconn *conn);\n\n/* replication status functions */\nXLogRecPtr\tget_primary_current_lsn(PGconn *conn);\nXLogRecPtr\tget_node_current_lsn(PGconn *conn);\nXLogRecPtr\tget_last_wal_receive_location(PGconn *conn);\nvoid\t\tinit_replication_info(ReplInfo *replication_info);\nbool\t\tget_replication_info(PGconn *conn, t_server_type node_type, ReplInfo *replication_info);\nint\t\t\tget_replication_lag_seconds(PGconn *conn);\nTimeLineID\tget_node_timeline(PGconn *conn, char *timeline_id_str);\nvoid\t\tget_node_replication_stats(PGconn *conn, t_node_info *node_info);\nNodeAttached is_downstream_node_attached(PGconn *conn, char *node_name, char **node_state);\nNodeAttached is_downstream_node_attached_quiet(PGconn *conn, char *node_name, char **node_state);\nvoid\t\tset_upstream_last_seen(PGconn *conn, int upstream_node_id);\nint\t\t\tget_upstream_last_seen(PGconn *conn, t_server_type node_type);\n\nbool\t\tis_wal_replay_paused(PGconn *conn, bool check_pending_wal);\n\n/* repmgrd status functions */\nCheckStatus\tget_repmgrd_status(PGconn *conn);\n\n/* miscellaneous debugging functions */\nconst char *print_node_status(NodeStatus node_status);\nconst char *print_pqping_status(PGPing ping_status);\n\n#endif\t\t\t\t\t\t\t/* _REPMGR_DBUTILS_H_ */\n"
        },
        {
          "name": "dirutil.c",
          "type": "blob",
          "size": 9.869140625,
          "content": "/*\n *\n * dirmod.c\n *\t  directory handling functions\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <unistd.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n#include <ftw.h>\n\n/* NB: postgres_fe must be included BEFORE check_dir */\n#include <libpq-fe.h>\n#include <postgres_fe.h>\n\n#include \"dirutil.h\"\n#include \"strutil.h\"\n#include \"log.h\"\n#include \"controldata.h\"\n\nstatic int\tunlink_dir_callback(const char *fpath, const struct stat *sb, int typeflag, struct FTW *ftwbuf);\n\n/* PID can be negative if backend is standalone */\ntypedef long pgpid_t;\n\n\n/*\n * Check if a directory exists, and if so whether it is empty.\n *\n * This function is used for checking both the data directory\n * and tablespace directories.\n */\nDataDirState\ncheck_dir(const char *path)\n{\n\tDIR\t\t   *chkdir = NULL;\n\tstruct dirent *file = NULL;\n\tint\t\t\tresult = DIR_EMPTY;\n\n\terrno = 0;\n\n\tchkdir = opendir(path);\n\n\tif (!chkdir)\n\t\treturn (errno == ENOENT) ? DIR_NOENT : DIR_ERROR;\n\n\twhile ((file = readdir(chkdir)) != NULL)\n\t{\n\t\tif (strcmp(\".\", file->d_name) == 0 ||\n\t\t\tstrcmp(\"..\", file->d_name) == 0)\n\t\t{\n\t\t\t/* skip this and parent directory */\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = DIR_NOT_EMPTY;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(chkdir);\n\n\tif (errno != 0)\n\t\treturn DIR_ERROR;\t\t\t\t/* some kind of I/O error? */\n\n\treturn result;\n}\n\n\n/*\n * Create directory with error log message when failing\n */\nbool\ncreate_dir(const char *path)\n{\n\tchar create_dir_path[MAXPGPATH];\n\n\t/* mkdir_p() may modify the supplied path */\n\tstrncpy(create_dir_path, path, MAXPGPATH);\n\n\tif (mkdir_p(create_dir_path, 0700) == 0)\n\t\treturn true;\n\n\tlog_error(_(\"unable to create directory \\\"%s\\\"\"), create_dir_path);\n\tlog_detail(\"%s\", strerror(errno));\n\n\treturn false;\n}\n\n\nbool\nset_dir_permissions(const char *path, int server_version_num)\n{\n\tstruct stat stat_buf;\n\tbool no_group_access =\n\t\t(server_version_num != UNKNOWN_SERVER_VERSION_NUM) &&\n\t\t(server_version_num < 110000);\n\t/*\n\t * At this point the path should exist, so this check is very\n\t * much just-in-case.\n\t */\n\tif (stat(path, &stat_buf) != 0)\n\t{\n\t\tif (errno == ENOENT)\n\t\t{\n\t\t\tlog_warning(_(\"directory \\\"%s\\\" does not exist\"), path);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_warning(_(\"could not read permissions of directory \\\"%s\\\"\"),\n\t\t\t\t\t\tpath);\n\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * If mode is not 0700 or 0750, attempt to change.\n\t */\n\tif ((no_group_access == true  && (stat_buf.st_mode & (S_IRWXG | S_IRWXO)))\n\t || (no_group_access == false && (stat_buf.st_mode & (S_IWGRP | S_IRWXO))))\n\t{\n\t\t/*\n\t\t * Currently we default to 0700.\n\t\t * There is no facility to override this directly,\n\t\t * but the user can manually create the directory with\n\t\t * the desired permissions.\n\t\t */\n\n\t\tif (chmod(path, 0700) != 0) {\n\t\t\tlog_error(_(\"unable to change permissions of directory \\\"%s\\\"\"), path);\n\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/* Leave as-is */\n\treturn true;\n}\n\n\n/* function from initdb.c */\n/* source adapted from FreeBSD /src/bin/mkdir/mkdir.c */\n\n/*\n * this tries to build all the elements of a path to a directory a la mkdir -p\n * we assume the path is in canonical form, i.e. uses / as the separator\n * we also assume it isn't null.\n *\n * note that on failure, the path arg has been modified to show the particular\n * directory level we had problems with.\n */\nint\nmkdir_p(char *path, mode_t omode)\n{\n\tstruct stat sb;\n\tmode_t\t\tnumask,\n\t\t\t\toumask;\n\tint\t\t\tfirst,\n\t\t\t\tlast,\n\t\t\t\tretval;\n\tchar\t   *p;\n\n\tp = path;\n\toumask = 0;\n\tretval = 0;\n\n\n\tif (p[0] == '/')\t\t\t/* Skip leading '/'. */\n\t\t++p;\n\tfor (first = 1, last = 0; !last; ++p)\n\t{\n\t\tif (p[0] == '\\0')\n\t\t\tlast = 1;\n\t\telse if (p[0] != '/')\n\t\t\tcontinue;\n\t\t*p = '\\0';\n\t\tif (!last && p[1] == '\\0')\n\t\t\tlast = 1;\n\t\tif (first)\n\t\t{\n\t\t\t/*\n\t\t\t * POSIX 1003.2: For each dir operand that does not name an\n\t\t\t * existing directory, effects equivalent to those caused by the\n\t\t\t * following command shall occur:\n\t\t\t *\n\t\t\t * mkdir -p -m $(umask -S),u+wx $(dirname dir) && mkdir [-m mode]\n\t\t\t * dir\n\t\t\t *\n\t\t\t * We change the user's umask and then restore it, instead of\n\t\t\t * doing chmod's.\n\t\t\t */\n\t\t\toumask = umask(0);\n\t\t\tnumask = oumask & ~(S_IWUSR | S_IXUSR);\n\t\t\t(void) umask(numask);\n\t\t\tfirst = 0;\n\t\t}\n\t\tif (last)\n\t\t\t(void) umask(oumask);\n\n\t\t/* check for pre-existing directory; ok if it's a parent */\n\t\tif (stat(path, &sb) == 0)\n\t\t{\n\t\t\tif (!S_ISDIR(sb.st_mode))\n\t\t\t{\n\t\t\t\tif (last)\n\t\t\t\t\terrno = EEXIST;\n\t\t\t\telse\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\tretval = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (mkdir(path, last ? omode : S_IRWXU | S_IRWXG | S_IRWXO) < 0)\n\t\t{\n\t\t\tretval = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!last)\n\t\t\t*p = '/';\n\t}\n\tif (!first && !last)\n\t\t(void) umask(oumask);\n\treturn retval;\n}\n\n\nbool\nis_pg_dir(const char *path)\n{\n\tchar\t\tdirpath[MAXPGPATH] = \"\";\n\tstruct stat sb;\n\n\t/* test pgdata */\n\tsnprintf(dirpath, MAXPGPATH, \"%s/PG_VERSION\", path);\n\tif (stat(dirpath, &sb) == 0)\n\t\treturn true;\n\n\t/* TODO: sanity check other files */\n\n\treturn false;\n}\n\n/*\n * Attempt to determine if a PostgreSQL data directory is in use\n * by reading the pidfile. This is the same mechanism used by\n * \"pg_ctl\".\n *\n * This function will abort with appropriate log messages if a file error\n * is encountered, as the user will need to address the situation before\n * any further useful progress can be made.\n */\nPgDirState\nis_pg_running(const char *path)\n{\n\tlong\t\tpid;\n\tFILE\t   *pidf;\n\n\tchar pid_file[MAXPGPATH];\n\n\t/* it's reasonable to assume the pidfile name will not change */\n\tsnprintf(pid_file, MAXPGPATH, \"%s/postmaster.pid\", path);\n\n\tpidf = fopen(pid_file, \"r\");\n\tif (pidf == NULL)\n\t{\n\t\t/*\n\t\t * No PID file - PostgreSQL shouldn't be running. From 9.3 (the\n\t\t * earliest version we care about) removal of the PID file will\n\t\t * cause the postmaster to shut down, so it's highly unlikely\n\t\t * that PostgreSQL will still be running.\n\t\t */\n\t\tif (errno == ENOENT)\n\t\t{\n\t\t\treturn PG_DIR_NOT_RUNNING;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_error(_(\"unable to open PostgreSQL PID file \\\"%s\\\"\"), pid_file);\n\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\n\t/*\n\t * In the unlikely event we're unable to extract a PID from the PID file,\n\t * log a warning but assume we're not dealing with a running instance\n\t * as PostgreSQL should have shut itself down in these cases anyway.\n\t */\n\tif (fscanf(pidf, \"%ld\", &pid) != 1)\n\t{\n\t\t/* Is the file empty? */\n\t\tif (ftell(pidf) == 0 && feof(pidf))\n\t\t{\n\t\t\tlog_warning(_(\"PostgreSQL PID file \\\"%s\\\" is empty\"), path);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_warning(_(\"invalid data in PostgreSQL PID file \\\"%s\\\"\"), path);\n\t\t}\n\n\t\tfclose(pidf);\n\n\t\treturn PG_DIR_NOT_RUNNING;\n\t}\n\n\tfclose(pidf);\n\n\tif (pid == getpid())\n\t\treturn PG_DIR_NOT_RUNNING;\n\n\tif (pid == getppid())\n\t\treturn PG_DIR_NOT_RUNNING;\n\n\tif (kill(pid, 0) == 0)\n\t\treturn PG_DIR_RUNNING;\n\n\treturn PG_DIR_NOT_RUNNING;\n}\n\n\nbool\ncreate_pg_dir(const char *path, bool force)\n{\n\t/* Check this directory can be used as a PGDATA dir */\n\tswitch (check_dir(path))\n\t{\n\t\tcase DIR_NOENT:\n\t\t\t/* Directory does not exist, attempt to create it. */\n\t\t\tlog_info(_(\"creating directory \\\"%s\\\"...\"), path);\n\n\t\t\tif (!create_dir(path))\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to create directory \\\"%s\\\"...\"),\n\t\t\t\t\t\t  path);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DIR_EMPTY:\n\t\t\t/*\n\t\t\t * Directory exists but empty, fix permissions and use it.\n\t\t\t *\n\t\t\t * Note that at this point the caller might not know the server\n\t\t\t * version number, so in this case \"set_dir_permissions()\" will\n\t\t\t * accept 0750 as a valid setting. As this is invalid in Pg10 and\n\t\t\t * earlier,  the caller should call \"set_dir_permissions()\" again\n\t\t\t * when it has the number.\n\t\t\t *\n\t\t\t * We need to do the permissions check here in any case to catch\n\t\t\t * fatal permissions early.\n\t\t\t */\n\t\t\tlog_info(_(\"checking and correcting permissions on existing directory \\\"%s\\\"\"),\n\t\t\t\t\t path);\n\n\t\t\tif (!set_dir_permissions(path, UNKNOWN_SERVER_VERSION_NUM))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DIR_NOT_EMPTY:\n\t\t\t/* exists but is not empty */\n\t\t\tlog_warning(_(\"directory \\\"%s\\\" exists but is not empty\"),\n\t\t\t\t\t\tpath);\n\n\t\t\tif (is_pg_dir(path))\n\t\t\t{\n\t\t\t\tif (force == true)\n\t\t\t\t{\n\t\t\t\t\tlog_notice(_(\"-F/--force provided - deleting existing data directory \\\"%s\\\"\"), path);\n\t\t\t\t\tnftw(path, unlink_dir_callback, 64, FTW_DEPTH | FTW_PHYS);\n\n\t\t\t\t\t/* recreate the directory ourselves to ensure permissions are correct */\n\t\t\t\t\tif (!create_dir(path))\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_error(_(\"unable to create directory \\\"%s\\\"...\"),\n\t\t\t\t\t\t\t\t  path);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (force == true)\n\t\t\t\t{\n\t\t\t\t\tlog_notice(_(\"deleting existing directory \\\"%s\\\"\"), path);\n\t\t\t\t\tnftw(path, unlink_dir_callback, 64, FTW_DEPTH | FTW_PHYS);\n\n\t\t\t\t\t/* recreate the directory ourselves to ensure permissions are correct */\n\t\t\t\t\tif (!create_dir(path))\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_error(_(\"unable to create directory \\\"%s\\\"...\"),\n\t\t\t\t\t\t\t\t  path);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DIR_ERROR:\n\t\t\tlog_error(_(\"could not access directory \\\"%s\\\"\")\n\t\t\t\t\t  , path);\n\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n\n\nint\nrmdir_recursive(const char *path)\n{\n\treturn nftw(path, unlink_dir_callback, 64, FTW_DEPTH | FTW_PHYS);\n}\n\nstatic int\nunlink_dir_callback(const char *fpath, const struct stat *sb, int typeflag, struct FTW *ftwbuf)\n{\n\tint\t\t\trv = remove(fpath);\n\n\tif (rv)\n\t\tperror(fpath);\n\n\treturn rv;\n}\n"
        },
        {
          "name": "dirutil.h",
          "type": "blob",
          "size": 1.3232421875,
          "content": "/*\n * dirutil.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _DIRUTIL_H_\n#define _DIRUTIL_H_\n\ntypedef enum\n{\n\tDIR_ERROR = -1,\n\tDIR_NOENT,\n\tDIR_EMPTY,\n\tDIR_NOT_EMPTY\n} DataDirState;\n\ntypedef enum\n{\n\tPG_DIR_ERROR = -1,\n\tPG_DIR_NOT_RUNNING,\n\tPG_DIR_RUNNING\n} PgDirState;\n\nextern int\tmkdir_p(char *path, mode_t omode);\nextern bool set_dir_permissions(const char *path, int server_version_num);\n\nextern DataDirState\tcheck_dir(const char *path);\nextern bool create_dir(const char *path);\nextern bool is_pg_dir(const char *path);\nextern PgDirState is_pg_running(const char *path);\nextern bool create_pg_dir(const char *path, bool force);\nextern int rmdir_recursive(const char *path);\n\n#endif\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "errcode.h",
          "type": "blob",
          "size": 1.587890625,
          "content": "/*\n * errcode.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _ERRCODE_H_\n#define _ERRCODE_H_\n\n/* Exit return codes */\n\n#define SUCCESS 0\n#define ERR_BAD_CONFIG 1\n#define ERR_BAD_RSYNC 2\n#define ERR_BAD_PIDFILE 3\n#define ERR_NO_RESTART 4\n#define ERR_LOCAL_COMMAND 5\n#define ERR_DB_CONN 6\n#define ERR_DB_QUERY 7\n#define ERR_PROMOTION_FAIL 8\n#define ERR_MONITORING_TIMEOUT 9\n#define ERR_STR_OVERFLOW 10\n#define ERR_FAILOVER_FAIL 11\n#define ERR_BAD_SSH 12\n#define ERR_SYS_FAILURE 13\n#define ERR_BAD_BASEBACKUP 14\n#define ERR_INTERNAL 15\n#define ERR_MONITORING_FAIL 16\n#define ERR_BAD_BACKUP_LABEL 17\n#define ERR_SWITCHOVER_FAIL 18\n#define ERR_BARMAN 19\n#define ERR_REGISTRATION_SYNC 20\n#define ERR_OUT_OF_MEMORY 21\n#define ERR_SWITCHOVER_INCOMPLETE 22\n#define ERR_FOLLOW_FAIL 23\n#define ERR_REJOIN_FAIL 24\n#define ERR_NODE_STATUS 25\n#define ERR_REPMGRD_PAUSE 26\n#define ERR_REPMGRD_SERVICE 27\n#define ERR_PGBACKUPAPI_SERVICE 28\n\n#endif\t\t\t\t\t\t\t/* _ERRCODE_H_ */\n"
        },
        {
          "name": "expected",
          "type": "tree",
          "content": null
        },
        {
          "name": "log.c",
          "type": "blob",
          "size": 8.30078125,
          "content": "/*\n * log.c - Logging methods\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"repmgr.h\"\n\n#include <stdlib.h>\n\n#ifdef HAVE_SYSLOG\n#include <syslog.h>\n#endif\n\n#include <stdarg.h>\n#include <time.h>\n\n#include \"log.h\"\n\n#define DEFAULT_IDENT \"repmgr\"\n#ifdef HAVE_SYSLOG\n#define DEFAULT_SYSLOG_FACILITY LOG_LOCAL0\n#endif\n\n/* #define REPMGR_DEBUG */\n\nstatic int\tdetect_log_facility(const char *facility);\nstatic void\n_stderr_log_with_level(const char *level_name, int level, const char *fmt, va_list ap)\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 3, 0)));\n\nint\t\t\tlog_type = REPMGR_STDERR;\nint\t\t\tlog_level = LOG_INFO;\nint\t\t\tlast_log_level = LOG_INFO;\nint\t\t\tverbose_logging = false;\nint\t\t\tterse_logging = false;\n\n/*\n * Global variable to be set by the main application to ensure any log output\n * emitted before logger_init is called, is output in the correct format\n */\nint\t\t\tlogger_output_mode = OM_DAEMON;\n\nextern void\nstderr_log_with_level(const char *level_name, int level, const char *fmt,...)\n{\n\tva_list\t\targlist;\n\n\tva_start(arglist, fmt);\n\t_stderr_log_with_level(level_name, level, fmt, arglist);\n\tva_end(arglist);\n}\n\nstatic void\n_stderr_log_with_level(const char *level_name, int level, const char *fmt, va_list ap)\n{\n\tchar\t\tbuf[100];\n\n\t/*\n\t * Store the requested level so that if there's a subsequent log_hint() or\n\t * log_detail(), we can suppress that if --terse was specified,\n\t */\n\tlast_log_level = level;\n\n\tif (log_level >= level)\n\t{\n\n\t\t/* Format log line prefix with timestamp if in daemon mode */\n\t\tif (logger_output_mode == OM_DAEMON)\n\t\t{\n\t\t\ttime_t\t\tt;\n\t\t\tstruct tm  *tm;\n\n\t\t\ttime(&t);\n\t\t\ttm = localtime(&t);\n\t\t\tstrftime(buf, sizeof(buf), \"[%Y-%m-%d %H:%M:%S]\", tm);\n\t\t\tfprintf(stderr, \"%s [%s] \", buf, level_name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfprintf(stderr, \"%s: \", level_name);\n\t\t}\n\n\t\tvfprintf(stderr, fmt, ap);\n\t\tfprintf(stderr, \"\\n\");\n\t\tfflush(stderr);\n\t}\n}\n\nvoid\nlog_hint(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n\tif (terse_logging == false)\n\t{\n\t\tva_start(ap, fmt);\n\t\t_stderr_log_with_level(\"HINT\", last_log_level, fmt, ap);\n\t\tva_end(ap);\n\t}\n}\n\n\nvoid\nlog_detail(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n\tif (terse_logging == false)\n\t{\n\t\tva_start(ap, fmt);\n\t\t_stderr_log_with_level(\"DETAIL\", last_log_level, fmt, ap);\n\t\tva_end(ap);\n\t}\n}\n\n\nvoid\nlog_verbose(int level, const char *fmt,...)\n{\n\tva_list\t\tap;\n\n\tva_start(ap, fmt);\n\n\tif (verbose_logging == true)\n\t{\n\t\tswitch (level)\n\t\t{\n\t\t\tcase LOG_EMERG:\n\t\t\t\t_stderr_log_with_level(\"EMERG\", level, fmt, ap);\n\t\t\t\tbreak;\n\t\t\tcase LOG_ALERT:\n\t\t\t\t_stderr_log_with_level(\"ALERT\", level, fmt, ap);\n\t\t\t\tbreak;\n\t\t\tcase LOG_CRIT:\n\t\t\t\t_stderr_log_with_level(\"CRIT\", level, fmt, ap);\n\t\t\t\tbreak;\n\t\t\tcase LOG_ERROR:\n\t\t\t\t_stderr_log_with_level(\"ERROR\", level, fmt, ap);\n\t\t\t\tbreak;\n\t\t\tcase LOG_WARNING:\n\t\t\t\t_stderr_log_with_level(\"WARNING\", level, fmt, ap);\n\t\t\t\tbreak;\n\t\t\tcase LOG_NOTICE:\n\t\t\t\t_stderr_log_with_level(\"NOTICE\", level, fmt, ap);\n\t\t\t\tbreak;\n\t\t\tcase LOG_INFO:\n\t\t\t\t_stderr_log_with_level(\"INFO\", level, fmt, ap);\n\t\t\t\tbreak;\n\t\t\tcase LOG_DEBUG:\n\t\t\t\t_stderr_log_with_level(\"DEBUG\", level, fmt, ap);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tva_end(ap);\n}\n\n\nbool\nlogger_init(t_configuration_options *opts, const char *ident)\n{\n\tchar\t   *level = opts->log_level;\n\tchar\t   *facility = opts->log_facility;\n\n\tint\t\t\tl;\n\tint\t\t\tf;\n\n#ifdef HAVE_SYSLOG\n\tint\t\t\tsyslog_facility = DEFAULT_SYSLOG_FACILITY;\n#endif\n\n#ifdef REPMGR_DEBUG\n\tprintf(\"logger initialisation (Level: %s, Facility: %s)\\n\", level, facility);\n#endif\n\n\tif (!ident)\n\t{\n\t\tident = DEFAULT_IDENT;\n\t}\n\n\tif (level && *level)\n\t{\n\t\tl = detect_log_level(level);\n#ifdef REPMGR_DEBUG\n\t\tprintf(\"assigned level for logger: %d\\n\", l);\n#endif\n\n\t\tif (l >= 0)\n\t\t\tlog_level = l;\n\t\telse\n\t\t\tstderr_log_warning(_(\"invalid log level \\\"%s\\\" (available values: DEBUG, INFO, NOTICE, WARNING, ERR, ALERT, CRIT or EMERG)\\n\"), level);\n\t}\n\n\t/*\n\t * STDERR only logging requested - finish here without setting up any\n\t * further logging facility.\n\t */\n\tif (logger_output_mode == OM_COMMAND_LINE)\n\t\treturn true;\n\n\tif (facility && *facility)\n\t{\n\n\t\tf = detect_log_facility(facility);\n#ifdef REPMGR_DEBUG\n\t\tprintf(\"assigned facility for logger: %d\\n\", f);\n#endif\n\n\t\tif (f == 0)\n\t\t{\n\t\t\t/* No syslog requested, just stderr */\n#ifdef REPMGR_DEBUG\n\t\t\tprintf(_(\"using stderr for logging\\n\"));\n#endif\n\t\t}\n\t\telse if (f == -1)\n\t\t{\n\t\t\tstderr_log_warning(_(\"cannot detect log facility %s (use any of LOCAL0, LOCAL1, ..., LOCAL7, USER or STDERR)\\n\"), facility);\n\t\t}\n#ifdef HAVE_SYSLOG\n\t\telse\n\t\t{\n\t\t\tsyslog_facility = f;\n\t\t\tlog_type = REPMGR_SYSLOG;\n\t\t}\n#endif\n\t}\n\n#ifdef HAVE_SYSLOG\n\n\tif (log_type == REPMGR_SYSLOG)\n\t{\n\t\tsetlogmask(LOG_UPTO(log_level));\n\t\topenlog(ident, LOG_CONS | LOG_PID | LOG_NDELAY, syslog_facility);\n\n\t\tstderr_log_notice(_(\"setup syslog (level: %s, facility: %s)\\n\"), level, facility);\n\t}\n#endif\n\n\tif (*opts->log_file)\n\t{\n\t\tFILE\t   *fd;\n\n\t\t/*\n\t\t * Check if we can write to the specified file before redirecting\n\t\t * stderr - if freopen() fails, stderr output will vanish into the\n\t\t * ether and the user won't know what's going on.\n\t\t */\n\n\t\tfd = fopen(opts->log_file, \"a\");\n\t\tif (fd == NULL)\n\t\t{\n\t\t\tstderr_log_error(_(\"unable to open specified log file \\\"%s\\\" for writing: %s\\n\"),\n\t\t\t\t\t\t\t opts->log_file, strerror(errno));\n\t\t\tstderr_log_error(_(\"Terminating\\n\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t\tfclose(fd);\n\n\t\tstderr_log_notice(_(\"redirecting logging output to \\\"%s\\\"\\n\"), opts->log_file);\n\t\tfd = freopen(opts->log_file, \"a\", stderr);\n\n\t\t/*\n\t\t * It's possible freopen() may still fail due to e.g. a race\n\t\t * condition; as it's not feasible to restore stderr after a failed\n\t\t * freopen(), we'll write to stdout as a last resort.\n\t\t */\n\t\tif (fd == NULL)\n\t\t{\n\t\t\tprintf(_(\"unable to open specified log file %s for writing: %s\\n\"), opts->log_file, strerror(errno));\n\t\t\tprintf(_(\"terminating\\n\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\nbool\nlogger_shutdown(void)\n{\n#ifdef HAVE_SYSLOG\n\tif (log_type == REPMGR_SYSLOG)\n\t\tcloselog();\n#endif\n\n\treturn true;\n}\n\n/*\n * Indicate whether extra-verbose logging is required. This will\n * generate a lot of output, particularly debug logging, and should\n * not be permanently enabled in production.\n *\n * NOTE: in previous repmgr versions, this option forced the log\n * level to INFO.\n */\nvoid\nlogger_set_verbose(void)\n{\n\tverbose_logging = true;\n}\n\n\n/*\n * Indicate whether some non-critical log messages can be omitted.\n * Currently this includes warnings about irrelevant command line\n * options and hints.\n */\n\nvoid\nlogger_set_terse(void)\n{\n\tterse_logging = true;\n}\n\n\nvoid\nlogger_set_level(int new_log_level)\n{\n\tlog_level = new_log_level;\n}\n\n\nvoid\nlogger_set_min_level(int min_log_level)\n{\n\tif (min_log_level > log_level)\n\t\tlog_level = min_log_level;\n}\n\n\nint\ndetect_log_level(const char *level)\n{\n\tif (!strcasecmp(level, \"DEBUG\"))\n\t\treturn LOG_DEBUG;\n\tif (!strcasecmp(level, \"INFO\"))\n\t\treturn LOG_INFO;\n\tif (!strcasecmp(level, \"NOTICE\"))\n\t\treturn LOG_NOTICE;\n\tif (!strcasecmp(level, \"WARNING\"))\n\t\treturn LOG_WARNING;\n\tif (!strcasecmp(level, \"ERROR\"))\n\t\treturn LOG_ERROR;\n\tif (!strcasecmp(level, \"ALERT\"))\n\t\treturn LOG_ALERT;\n\tif (!strcasecmp(level, \"CRIT\"))\n\t\treturn LOG_CRIT;\n\tif (!strcasecmp(level, \"EMERG\"))\n\t\treturn LOG_EMERG;\n\n\treturn -1;\n}\n\nstatic int\ndetect_log_facility(const char *facility)\n{\n\tint\t\t\tlocal = 0;\n\n\tif (!strncmp(facility, \"LOCAL\", 5) && strlen(facility) == 6)\n\t{\n\t\tlocal = atoi(&facility[5]);\n\n\t\tswitch (local)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\treturn LOG_LOCAL0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\treturn LOG_LOCAL1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\treturn LOG_LOCAL2;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\treturn LOG_LOCAL3;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\treturn LOG_LOCAL4;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\treturn LOG_LOCAL5;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\treturn LOG_LOCAL6;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\treturn LOG_LOCAL7;\n\t\t\t\tbreak;\n\t\t}\n\n\t}\n\telse if (!strcmp(facility, \"USER\"))\n\t{\n\t\treturn LOG_USER;\n\t}\n\telse if (!strcmp(facility, \"STDERR\"))\n\t{\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n"
        },
        {
          "name": "log.h",
          "type": "blob",
          "size": 4.4755859375,
          "content": "/*\n * log.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _REPMGR_LOG_H_\n#define _REPMGR_LOG_H_\n\n#include \"repmgr.h\"\n\n#define REPMGR_SYSLOG 1\n#define REPMGR_STDERR 2\n\n#define OM_COMMAND_LINE 1\n#define OM_DAEMON\t\t2\n\n#define DEFAULT_LOG_STATUS_INTERVAL 300\n\nextern void\nstderr_log_with_level(const char *level_name, int level, const char *fmt,...)\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 3, 4)));\n\n#define LOG_EMERG\t0\t\t\t/* system is unusable */\n#define LOG_ALERT\t1\t\t\t/* action must be taken immediately */\n#define LOG_CRIT\t2\t\t\t/* critical conditions */\n#define LOG_ERROR\t3\t\t\t/* error conditions */\n#define LOG_WARNING 4\t\t\t/* warning conditions */\n#define LOG_NOTICE\t5\t\t\t/* normal but significant condition */\n#define LOG_INFO\t6\t\t\t/* informational */\n#define LOG_DEBUG\t7\t\t\t/* debug-level messages */\n\n\n/* Standard error logging */\n#define stderr_log_debug(...) stderr_log_with_level(\"DEBUG\", LOG_DEBUG, __VA_ARGS__)\n#define stderr_log_info(...)  stderr_log_with_level(\"INFO\", LOG_INFO, __VA_ARGS__)\n#define stderr_log_notice(...) stderr_log_with_level(\"NOTICE\", LOG_NOTICE, __VA_ARGS__)\n#define stderr_log_warning(...) stderr_log_with_level(\"WARNING\", LOG_WARNING, __VA_ARGS__)\n#define stderr_log_error(...) stderr_log_with_level(\"ERROR\", LOG_ERROR, __VA_ARGS__)\n#define stderr_log_crit(...) stderr_log_with_level(\"CRITICAL\", LOG_CRIT, __VA_ARGS__)\n#define stderr_log_alert(...) stderr_log_with_level(\"ALERT\", LOG_ALERT, __VA_ARGS__)\n#define stderr_log_emerg(...) stderr_log_with_level(\"EMERGENCY\", LOG_EMERG, __VA_ARGS__)\n\n#ifdef HAVE_SYSLOG\n\n#include <syslog.h>\n\n#define log_debug(...) \\\n\tif (log_type == REPMGR_SYSLOG) \\\n\t\tsyslog(LOG_DEBUG, __VA_ARGS__); \\\n\telse \\\n\t\tstderr_log_debug(__VA_ARGS__);\n\n#define log_info(...) \\\n\t{ \\\n\t\tif (log_type == REPMGR_SYSLOG) syslog(LOG_INFO, __VA_ARGS__); \\\n\t\telse stderr_log_info(__VA_ARGS__); \\\n\t}\n\n#define log_notice(...) \\\n\t{ \\\n\t\tif (log_type == REPMGR_SYSLOG) syslog(LOG_NOTICE, __VA_ARGS__); \\\n\t\telse stderr_log_notice(__VA_ARGS__); \\\n\t}\n\n#define log_warning(...) \\\n\t{ \\\n\t\tif (log_type == REPMGR_SYSLOG) syslog(LOG_WARNING, __VA_ARGS__); \\\n\t\telse stderr_log_warning(__VA_ARGS__); \\\n\t}\n\n#define log_error(...) \\\n\t{ \\\n\t\tif (log_type == REPMGR_SYSLOG) syslog(LOG_ERROR, __VA_ARGS__); \\\n\t\telse stderr_log_error(__VA_ARGS__); \\\n\t}\n\n#define log_crit(...) \\\n\t{ \\\n\t\tif (log_type == REPMGR_SYSLOG) syslog(LOG_CRIT, __VA_ARGS__); \\\n\t\telse stderr_log_crit(__VA_ARGS__); \\\n\t}\n\n#define log_alert(...) \\\n\t{ \\\n\t\tif (log_type == REPMGR_SYSLOG) syslog(LOG_ALERT, __VA_ARGS__); \\\n\t\telse stderr_log_alert(__VA_ARGS__); \\\n\t}\n\n#define log_emerg(...) \\\n\t{ \\\n\t\tif (log_type == REPMGR_SYSLOG) syslog(LOG_ALERT, __VA_ARGS__); \\\n\t\telse stderr_log_alert(__VA_ARGS__); \\\n\t}\n#else\n\n\n#define log_debug(...) stderr_log_debug(__VA_ARGS__)\n#define log_info(...) stderr_log_info(__VA_ARGS__)\n#define log_notice(...) stderr_log_notice(__VA_ARGS__)\n#define log_warning(...) stderr_log_warning(__VA_ARGS__)\n#define log_error(...) stderr_log_error(__VA_ARGS__)\n#define log_crit(...) stderr_log_crit(__VA_ARGS__)\n#define log_alert(...) stderr_log_alert(__VA_ARGS__)\n#define log_emerg(...) stderr_log_emerg(__VA_ARGS__)\n#endif\n\n\nint\t\t\tdetect_log_level(const char *level);\n\n/* Logger initialisation and shutdown */\n\nbool\t\tlogger_init(t_configuration_options *opts, const char *ident);\n\nbool\t\tlogger_shutdown(void);\n\nvoid\t\tlogger_set_verbose(void);\nvoid\t\tlogger_set_terse(void);\nvoid\t\tlogger_set_min_level(int min_log_level);\nvoid\t\tlogger_set_level(int new_log_level);\n\nvoid\nlog_detail(const char *fmt,...)\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 1, 2)));\nvoid\nlog_hint(const char *fmt,...)\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 1, 2)));\nvoid\nlog_verbose(int level, const char *fmt,...)\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 2, 3)));\n\nextern int\tlog_type;\nextern int\tlog_level;\nextern int\tverbose_logging;\nextern int\tterse_logging;\nextern int\tlogger_output_mode;\n\n#endif\t\t\t\t\t\t\t/* _REPMGR_LOG_H_ */\n"
        },
        {
          "name": "pgbackupapi.c",
          "type": "blob",
          "size": 4.66015625,
          "content": "/*\n * pgbackupapi.c\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <string.h>\n\n#include <curl/curl.h>\n#include <json-c/json.h>\n\n#include \"repmgr.h\"\n#include \"pgbackupapi.h\"\n\n\nsize_t receive_operations_cb(void *content, size_t size, size_t nmemb, char *buffer) {\n\tshort int max_chars_to_copy = MAX_BUFFER_LENGTH -2;\n\tshort int i = 0;\n\tint operation_length = 0;\n\tjson_object *value;\n\n\tjson_object *root = json_tokener_parse(content);\n\tjson_object *operations = json_object_object_get(root, \"operations\");\n\n\toperation_length = strlen(json_object_get_string(operations));\n\tif (operation_length < max_chars_to_copy) {\n\t\tmax_chars_to_copy = operation_length;\n\t}\n\n\tstrncpy(buffer, json_object_get_string(operations), max_chars_to_copy);\n\n\tfprintf(stdout, \"Success! The following operations were found\\n\");\n\tfor (i=0; i<json_object_array_length(operations); i++) {\n\t\tvalue = json_object_array_get_idx(operations, i);\n\t\tprintf(\"%s\\n\", json_object_get_string(value));\n\t}\n\treturn size * nmemb;\n}\n\nchar * define_base_url(operation_task *task) {\n\tchar *format = \"http://%s:7480/servers/%s/operations\";\n\tchar *url = malloc(MAX_BUFFER_LENGTH);\n\n\tsnprintf(url, MAX_BUFFER_LENGTH-1, format, task->host, task->node_name);\n\n\t//`url` is freed on the function that called this\n\treturn url;\n}\n\nCURLcode get_operations_on_server(CURL *curl, operation_task *task) {\n\tchar buffer[MAX_BUFFER_LENGTH];\n\tchar *url = define_base_url(task);\n\tCURLcode ret;\n\n\tcurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, receive_operations_cb);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEDATA, &buffer);\n\tcurl_easy_setopt(curl, CURLOPT_URL, url);\n\n\tret = curl_easy_perform(curl);\n\tfree(url);\n\n\treturn ret;\n}\n\nsize_t receive_operation_id(void *content, size_t size, size_t nmemb, char *buffer) {\n\tjson_object *root = json_tokener_parse(content);\n\tjson_object *operation = json_object_object_get(root, \"operation_id\");\n\n\tif (operation != NULL) {\n\t\tstrncpy(buffer, json_object_get_string(operation), MAX_BUFFER_LENGTH-2);\n\t}\n\n\treturn size * nmemb;\n}\n\n\nCURLcode create_new_task(CURL *curl, operation_task *task) {\n\tPQExpBufferData payload;\n\tchar *url = define_base_url(task);\n\tCURLcode ret;\n\tjson_object *root = json_object_new_object();\n\tstruct curl_slist *chunk = NULL;\n\n\tjson_object_object_add(root, \"operation_type\", json_object_new_string(task->operation_type));\n\tjson_object_object_add(root, \"backup_id\", json_object_new_string(task->backup_id));\n\tjson_object_object_add(root, \"remote_ssh_command\", json_object_new_string(task->remote_ssh_command));\n\tjson_object_object_add(root, \"destination_directory\", json_object_new_string(task->destination_directory));\n\n\tinitPQExpBuffer(&payload);\n\tappendPQExpBufferStr(&payload, json_object_to_json_string(root));\n\n\tchunk = curl_slist_append(chunk, \"Content-type: application/json\");\n\tcurl_easy_setopt(curl, CURLOPT_HTTPHEADER, chunk);\n\tcurl_easy_setopt(curl, CURLOPT_URL, url);\n\tcurl_easy_setopt(curl, CURLOPT_POSTFIELDS, payload.data);\n\tcurl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L);\n\t//curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, receive_operation_id);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEDATA, task->operation_id);\n\tret = curl_easy_perform(curl);\n\tfree(url);\n\ttermPQExpBuffer(&payload);\n\n\treturn ret;\n}\n\n\nsize_t receive_operation_status(void *content, size_t size, size_t nmemb, char *buffer) {\n\tjson_object *root = json_tokener_parse(content);\n\tjson_object *status = json_object_object_get(root, \"status\");\n\tif (status != NULL) {\n\t\tstrncpy(buffer, json_object_get_string(status), MAX_BUFFER_LENGTH-2);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Incorrect reply received for that operation ID.\\n\");\n\t\tstrcpy(buffer, \"\\0\");\n\t}\n\treturn size * nmemb;\n}\n\nCURLcode get_status_of_operation(CURL *curl, operation_task *task) {\n\tCURLcode ret;\n\tchar *url = define_base_url(task);\n\n\tstrcat(url, \"/\");\n\tstrcat(url, task->operation_id);\n\tcurl_easy_setopt(curl, CURLOPT_URL, url);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, receive_operation_status);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEDATA, task->operation_status);\n\n\tret = curl_easy_perform(curl);\n\tfree(url);\n\n\treturn ret;\n}\n"
        },
        {
          "name": "pgbackupapi.h",
          "type": "blob",
          "size": 1.7919921875,
          "content": "/*\n * pgbackupapi.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n#include <curl/curl.h>\n#include <json-c/json.h>\n\ntypedef struct operation_task {\n        char *backup_id;\n        char *destination_directory;\n        char *operation_type;\n\tchar *operation_id;\n\tchar *operation_status;\n        char *remote_ssh_command;\n\tchar *host;\n\tchar *node_name;\n} operation_task;\n\n//Default simplebuffer size in most of operations\n#define MAX_BUFFER_LENGTH 72\n\n//Callbacks to send/receive data from pg-backup-api endpoints\nsize_t receive_operations_cb(void *content, size_t size, size_t nmemb, char *buffer);\nsize_t receive_operation_id(void *content, size_t size, size_t nmemb, char *buffer);\nsize_t receive_operation_status(void *content, size_t size, size_t nmemb, char *buffer);\n\n//Functions that implement the logic and know what to do and how to comunnicate wuth the API\nCURLcode get_operations_on_server(CURL *curl, operation_task *task);\nCURLcode create_new_task(CURL *curl, operation_task *task);\nCURLcode get_status_of_operation(CURL *curl, operation_task *task);\n\n//Helper to make simpler to read the handler where we set the URL\nchar * define_base_url(operation_task *task);\n"
        },
        {
          "name": "repmgr--4.0--4.1.sql",
          "type": "blob",
          "size": 0.1328125,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n"
        },
        {
          "name": "repmgr--4.0.sql",
          "type": "blob",
          "size": 5.2939453125,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nCREATE TABLE repmgr.nodes (\n  node_id          INTEGER     PRIMARY KEY,\n  upstream_node_id INTEGER     NULL REFERENCES nodes (node_id) DEFERRABLE,\n  active           BOOLEAN     NOT NULL DEFAULT TRUE,\n  node_name        TEXT        NOT NULL,\n  type             TEXT        NOT NULL CHECK (type IN('primary','standby','witness','bdr')),\n  location         TEXT        NOT NULL DEFAULT 'default',\n  priority         INT         NOT NULL DEFAULT 100,\n  conninfo         TEXT        NOT NULL,\n  repluser         VARCHAR(63) NOT NULL,\n  slot_name        TEXT        NULL,\n  config_file      TEXT        NOT NULL\n);\n\nCREATE TABLE repmgr.events (\n  node_id          INTEGER NOT NULL,\n  event            TEXT NOT NULL,\n  successful       BOOLEAN NOT NULL DEFAULT TRUE,\n  event_timestamp  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  details          TEXT NULL\n);\n\nDO $repmgr$\nDECLARE\n  DECLARE server_version_num INT;\nBEGIN\n  SELECT setting\n    FROM pg_catalog.pg_settings\n   WHERE name = 'server_version_num'\n    INTO server_version_num;\n  IF server_version_num >= 90400 THEN\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      PG_LSN NOT NULL,\n  last_wal_standby_location      PG_LSN,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n  ELSE\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      TEXT NOT NULL,\n  last_wal_standby_location      TEXT,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n  END IF;\nEND$repmgr$;\n\n\n\nCREATE INDEX idx_monitoring_history_time\n          ON repmgr.monitoring_history (last_monitor_time, standby_node_id);\n\nCREATE VIEW repmgr.show_nodes AS\n   SELECT n.node_id,\n          n.node_name,\n          n.active,\n          n.upstream_node_id,\n          un.node_name AS upstream_node_name,\n          n.type,\n          n.priority,\n          n.conninfo\n     FROM repmgr.nodes n\nLEFT JOIN repmgr.nodes un\n       ON un.node_id = n.upstream_node_id;\n\nCREATE TABLE repmgr.voting_term (\n  term INT NOT NULL\n);\n\nCREATE UNIQUE INDEX voting_term_restrict\nON repmgr.voting_term ((TRUE));\n\nCREATE RULE voting_term_delete AS\n   ON DELETE TO repmgr.voting_term\n   DO INSTEAD NOTHING;\n\n\n/* ================= */\n/* repmgrd functions */\n/* ================= */\n\n/* monitoring functions */\n\nCREATE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_get_last_updated'\n  LANGUAGE C STRICT;\n\n/* failover functions */\n\nCREATE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_new_primary()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION am_bdr_failover_handler(INT)\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'am_bdr_failover_handler'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION unset_bdr_failover_handler()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'unset_bdr_failover_handler'\n  LANGUAGE C STRICT;\n\n\nCREATE VIEW repmgr.replication_status AS\n  SELECT m.primary_node_id, m.standby_node_id, n.node_name AS standby_name,\n \t     n.type AS node_type, n.active, last_monitor_time,\n         CASE WHEN n.type='standby' THEN m.last_wal_primary_location ELSE NULL END AS last_wal_primary_location,\n         m.last_wal_standby_location,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.replication_lag) ELSE NULL END AS replication_lag,\n         CASE WHEN n.type='standby' THEN\n           CASE WHEN replication_lag > 0 THEN age(now(), m.last_apply_time) ELSE '0'::INTERVAL END\n           ELSE NULL\n         END AS replication_time_lag,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.apply_lag) ELSE NULL END AS apply_lag,\n         AGE(NOW(), CASE WHEN pg_catalog.pg_is_in_recovery() THEN repmgr.standby_get_last_updated() ELSE m.last_monitor_time END) AS communication_time_lag\n    FROM repmgr.monitoring_history m\n    JOIN repmgr.nodes n ON m.standby_node_id = n.node_id\n   WHERE (m.standby_node_id, m.last_monitor_time) IN (\n\t          SELECT m1.standby_node_id, MAX(m1.last_monitor_time)\n\t\t\t    FROM repmgr.monitoring_history m1 GROUP BY 1\n         );\n\n"
        },
        {
          "name": "repmgr--4.1--4.2.sql",
          "type": "blob",
          "size": 0.8203125,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nCREATE FUNCTION get_repmgrd_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pidfile()\n  RETURNS TEXT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pidfile'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_repmgrd_pid(INT, TEXT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_running()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_running'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_pause(BOOL)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgrd_pause'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_paused()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_paused'\n  LANGUAGE C STRICT;\n"
        },
        {
          "name": "repmgr--4.1.sql",
          "type": "blob",
          "size": 5.29296875,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nCREATE TABLE repmgr.nodes (\n  node_id          INTEGER     PRIMARY KEY,\n  upstream_node_id INTEGER     NULL REFERENCES nodes (node_id) DEFERRABLE,\n  active           BOOLEAN     NOT NULL DEFAULT TRUE,\n  node_name        TEXT        NOT NULL,\n  type             TEXT        NOT NULL CHECK (type IN('primary','standby','witness','bdr')),\n  location         TEXT        NOT NULL DEFAULT 'default',\n  priority         INT         NOT NULL DEFAULT 100,\n  conninfo         TEXT        NOT NULL,\n  repluser         VARCHAR(63) NOT NULL,\n  slot_name        TEXT        NULL,\n  config_file      TEXT        NOT NULL\n);\n\nCREATE TABLE repmgr.events (\n  node_id          INTEGER NOT NULL,\n  event            TEXT NOT NULL,\n  successful       BOOLEAN NOT NULL DEFAULT TRUE,\n  event_timestamp  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  details          TEXT NULL\n);\n\nDO $repmgr$\nDECLARE\n  DECLARE server_version_num INT;\nBEGIN\n  SELECT setting\n    FROM pg_catalog.pg_settings\n   WHERE name = 'server_version_num'\n    INTO server_version_num;\n  IF server_version_num >= 90400 THEN\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      PG_LSN NOT NULL,\n  last_wal_standby_location      PG_LSN,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n  ELSE\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      TEXT NOT NULL,\n  last_wal_standby_location      TEXT,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n  END IF;\nEND$repmgr$;\n\n\n\nCREATE INDEX idx_monitoring_history_time\n          ON repmgr.monitoring_history (last_monitor_time, standby_node_id);\n\nCREATE VIEW repmgr.show_nodes AS\n   SELECT n.node_id,\n          n.node_name,\n          n.active,\n          n.upstream_node_id,\n          un.node_name AS upstream_node_name,\n          n.type,\n          n.priority,\n          n.conninfo\n     FROM repmgr.nodes n\nLEFT JOIN repmgr.nodes un\n       ON un.node_id = n.upstream_node_id;\n\nCREATE TABLE repmgr.voting_term (\n  term INT NOT NULL\n);\n\nCREATE UNIQUE INDEX voting_term_restrict\nON repmgr.voting_term ((TRUE));\n\nCREATE RULE voting_term_delete AS\n   ON DELETE TO repmgr.voting_term\n   DO INSTEAD NOTHING;\n\n\n/* ================= */\n/* repmgrd functions */\n/* ================= */\n\n/* monitoring functions */\n\nCREATE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_get_last_updated'\n  LANGUAGE C STRICT;\n\n/* failover functions */\n\nCREATE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_new_primary()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION am_bdr_failover_handler(INT)\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'am_bdr_failover_handler'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION unset_bdr_failover_handler()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'unset_bdr_failover_handler'\n  LANGUAGE C STRICT;\n\nCREATE VIEW repmgr.replication_status AS\n  SELECT m.primary_node_id, m.standby_node_id, n.node_name AS standby_name,\n \t     n.type AS node_type, n.active, last_monitor_time,\n         CASE WHEN n.type='standby' THEN m.last_wal_primary_location ELSE NULL END AS last_wal_primary_location,\n         m.last_wal_standby_location,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.replication_lag) ELSE NULL END AS replication_lag,\n         CASE WHEN n.type='standby' THEN\n           CASE WHEN replication_lag > 0 THEN age(now(), m.last_apply_time) ELSE '0'::INTERVAL END\n           ELSE NULL\n         END AS replication_time_lag,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.apply_lag) ELSE NULL END AS apply_lag,\n         AGE(NOW(), CASE WHEN pg_catalog.pg_is_in_recovery() THEN repmgr.standby_get_last_updated() ELSE m.last_monitor_time END) AS communication_time_lag\n    FROM repmgr.monitoring_history m\n    JOIN repmgr.nodes n ON m.standby_node_id = n.node_id\n   WHERE (m.standby_node_id, m.last_monitor_time) IN (\n\t          SELECT m1.standby_node_id, MAX(m1.last_monitor_time)\n\t\t\t    FROM repmgr.monitoring_history m1 GROUP BY 1\n         );\n\n"
        },
        {
          "name": "repmgr--4.2--4.3.sql",
          "type": "blob",
          "size": 0.4892578125,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"ALTER EXTENSION repmgr UPDATE\" to load this file. \\quit\n\n-- This script is intentionally empty and exists to skip the CREATE FUNCTION\n-- commands contained in the 4.2--4.3 and 4.3--4.4 extension upgrade scripts,\n-- which reference C functions which no longer exist in 5.3 and later.\n--\n-- These functions will be explicitly created in the 5.2--5.3 extension\n-- upgrade step with the correct C function references.\n\n"
        },
        {
          "name": "repmgr--4.2.sql",
          "type": "blob",
          "size": 5.9814453125,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nCREATE TABLE repmgr.nodes (\n  node_id          INTEGER     PRIMARY KEY,\n  upstream_node_id INTEGER     NULL REFERENCES nodes (node_id) DEFERRABLE,\n  active           BOOLEAN     NOT NULL DEFAULT TRUE,\n  node_name        TEXT        NOT NULL,\n  type             TEXT        NOT NULL CHECK (type IN('primary','standby','witness','bdr')),\n  location         TEXT        NOT NULL DEFAULT 'default',\n  priority         INT         NOT NULL DEFAULT 100,\n  conninfo         TEXT        NOT NULL,\n  repluser         VARCHAR(63) NOT NULL,\n  slot_name        TEXT        NULL,\n  config_file      TEXT        NOT NULL\n);\n\nCREATE TABLE repmgr.events (\n  node_id          INTEGER NOT NULL,\n  event            TEXT NOT NULL,\n  successful       BOOLEAN NOT NULL DEFAULT TRUE,\n  event_timestamp  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  details          TEXT NULL\n);\n\nDO $repmgr$\nDECLARE\n  DECLARE server_version_num INT;\nBEGIN\n  SELECT setting\n    FROM pg_catalog.pg_settings\n   WHERE name = 'server_version_num'\n    INTO server_version_num;\n  IF server_version_num >= 90400 THEN\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      PG_LSN NOT NULL,\n  last_wal_standby_location      PG_LSN,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n  ELSE\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      TEXT NOT NULL,\n  last_wal_standby_location      TEXT,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n  END IF;\nEND$repmgr$;\n\n\n\nCREATE INDEX idx_monitoring_history_time\n          ON repmgr.monitoring_history (last_monitor_time, standby_node_id);\n\nCREATE VIEW repmgr.show_nodes AS\n   SELECT n.node_id,\n          n.node_name,\n          n.active,\n          n.upstream_node_id,\n          un.node_name AS upstream_node_name,\n          n.type,\n          n.priority,\n          n.conninfo\n     FROM repmgr.nodes n\nLEFT JOIN repmgr.nodes un\n       ON un.node_id = n.upstream_node_id;\n\nCREATE TABLE repmgr.voting_term (\n  term INT NOT NULL\n);\n\nCREATE UNIQUE INDEX voting_term_restrict\nON repmgr.voting_term ((TRUE));\n\nCREATE RULE voting_term_delete AS\n   ON DELETE TO repmgr.voting_term\n   DO INSTEAD NOTHING;\n\n\n/* ================= */\n/* repmgrd functions */\n/* ================= */\n\n/* monitoring functions */\n\nCREATE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_get_last_updated'\n  LANGUAGE C STRICT;\n\n/* failover functions */\n\nCREATE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_new_primary()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION am_bdr_failover_handler(INT)\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'am_bdr_failover_handler'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION unset_bdr_failover_handler()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'unset_bdr_failover_handler'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pidfile()\n  RETURNS TEXT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pidfile'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_repmgrd_pid(INT, TEXT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_running()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_running'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_pause(BOOL)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgrd_pause'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_paused()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_paused'\n  LANGUAGE C STRICT;\n\n\nCREATE VIEW repmgr.replication_status AS\n  SELECT m.primary_node_id, m.standby_node_id, n.node_name AS standby_name,\n \t     n.type AS node_type, n.active, last_monitor_time,\n         CASE WHEN n.type='standby' THEN m.last_wal_primary_location ELSE NULL END AS last_wal_primary_location,\n         m.last_wal_standby_location,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.replication_lag) ELSE NULL END AS replication_lag,\n         CASE WHEN n.type='standby' THEN\n           CASE WHEN replication_lag > 0 THEN age(now(), m.last_apply_time) ELSE '0'::INTERVAL END\n           ELSE NULL\n         END AS replication_time_lag,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.apply_lag) ELSE NULL END AS apply_lag,\n         AGE(NOW(), CASE WHEN pg_catalog.pg_is_in_recovery() THEN repmgr.standby_get_last_updated() ELSE m.last_monitor_time END) AS communication_time_lag\n    FROM repmgr.monitoring_history m\n    JOIN repmgr.nodes n ON m.standby_node_id = n.node_id\n   WHERE (m.standby_node_id, m.last_monitor_time) IN (\n\t          SELECT m1.standby_node_id, MAX(m1.last_monitor_time)\n\t\t\t    FROM repmgr.monitoring_history m1 GROUP BY 1\n         );\n\n"
        },
        {
          "name": "repmgr--4.3--4.4.sql",
          "type": "blob",
          "size": 0.474609375,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"ALTER EXTENSION repmgr UPDATE\" to load this file. \\quit\n\n-- This script is intentionally empty and exists to skip the CREATE FUNCTION\n-- commands contained in the 4.3--4.4 extension upgrade script, which reference\n-- C functions which no longer exist in 5.3 and later.\n--\n-- These functions will be explicitly created in the 5.2--5.3 extension\n-- upgrade step with the correct C function references.\n"
        },
        {
          "name": "repmgr--4.3.sql",
          "type": "blob",
          "size": 6.36328125,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nCREATE TABLE repmgr.nodes (\n  node_id          INTEGER     PRIMARY KEY,\n  upstream_node_id INTEGER     NULL REFERENCES nodes (node_id) DEFERRABLE,\n  active           BOOLEAN     NOT NULL DEFAULT TRUE,\n  node_name        TEXT        NOT NULL,\n  type             TEXT        NOT NULL CHECK (type IN('primary','standby','witness','bdr')),\n  location         TEXT        NOT NULL DEFAULT 'default',\n  priority         INT         NOT NULL DEFAULT 100,\n  conninfo         TEXT        NOT NULL,\n  repluser         VARCHAR(63) NOT NULL,\n  slot_name        TEXT        NULL,\n  config_file      TEXT        NOT NULL\n);\n\nCREATE TABLE repmgr.events (\n  node_id          INTEGER NOT NULL,\n  event            TEXT NOT NULL,\n  successful       BOOLEAN NOT NULL DEFAULT TRUE,\n  event_timestamp  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  details          TEXT NULL\n);\n\nDO $repmgr$\nDECLARE\n  DECLARE server_version_num INT;\nBEGIN\n  SELECT setting\n    FROM pg_catalog.pg_settings\n   WHERE name = 'server_version_num'\n    INTO server_version_num;\n  IF server_version_num >= 90400 THEN\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      PG_LSN NOT NULL,\n  last_wal_standby_location      PG_LSN,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n  ELSE\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      TEXT NOT NULL,\n  last_wal_standby_location      TEXT,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n  END IF;\nEND$repmgr$;\n\n\n\nCREATE INDEX idx_monitoring_history_time\n          ON repmgr.monitoring_history (last_monitor_time, standby_node_id);\n\nCREATE VIEW repmgr.show_nodes AS\n   SELECT n.node_id,\n          n.node_name,\n          n.active,\n          n.upstream_node_id,\n          un.node_name AS upstream_node_name,\n          n.type,\n          n.priority,\n          n.conninfo\n     FROM repmgr.nodes n\nLEFT JOIN repmgr.nodes un\n       ON un.node_id = n.upstream_node_id;\n\nCREATE TABLE repmgr.voting_term (\n  term INT NOT NULL\n);\n\nCREATE UNIQUE INDEX voting_term_restrict\nON repmgr.voting_term ((TRUE));\n\nCREATE RULE voting_term_delete AS\n   ON DELETE TO repmgr.voting_term\n   DO INSTEAD NOTHING;\n\n\n/* ================= */\n/* repmgrd functions */\n/* ================= */\n\n/* monitoring functions */\n\nCREATE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_get_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_last_seen()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_last_seen()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_upstream_last_seen'\n  LANGUAGE C STRICT;\n\n\n/* failover functions */\n\nCREATE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_new_primary()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION am_bdr_failover_handler(INT)\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'am_bdr_failover_handler'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION unset_bdr_failover_handler()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'unset_bdr_failover_handler'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pidfile()\n  RETURNS TEXT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pidfile'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_repmgrd_pid(INT, TEXT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_running()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_running'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_pause(BOOL)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgrd_pause'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_paused()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_paused'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_wal_receiver_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_wal_receiver_pid'\n  LANGUAGE C STRICT;\n\n\n\n\n/* views */\n\nCREATE VIEW repmgr.replication_status AS\n  SELECT m.primary_node_id, m.standby_node_id, n.node_name AS standby_name,\n \t     n.type AS node_type, n.active, last_monitor_time,\n         CASE WHEN n.type='standby' THEN m.last_wal_primary_location ELSE NULL END AS last_wal_primary_location,\n         m.last_wal_standby_location,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.replication_lag) ELSE NULL END AS replication_lag,\n         CASE WHEN n.type='standby' THEN\n           CASE WHEN replication_lag > 0 THEN age(now(), m.last_apply_time) ELSE '0'::INTERVAL END\n           ELSE NULL\n         END AS replication_time_lag,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.apply_lag) ELSE NULL END AS apply_lag,\n         AGE(NOW(), CASE WHEN pg_catalog.pg_is_in_recovery() THEN repmgr.standby_get_last_updated() ELSE m.last_monitor_time END) AS communication_time_lag\n    FROM repmgr.monitoring_history m\n    JOIN repmgr.nodes n ON m.standby_node_id = n.node_id\n   WHERE (m.standby_node_id, m.last_monitor_time) IN (\n\t          SELECT m1.standby_node_id, MAX(m1.last_monitor_time)\n\t\t\t    FROM repmgr.monitoring_history m1 GROUP BY 1\n         );\n\n"
        },
        {
          "name": "repmgr--4.4--5.0.sql",
          "type": "blob",
          "size": 0.203125,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nALTER FUNCTION set_repmgrd_pid(INT, TEXT) RETURNS NULL ON NULL INPUT;\n\n"
        },
        {
          "name": "repmgr--4.4.sql",
          "type": "blob",
          "size": 6.607421875,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nCREATE TABLE repmgr.nodes (\n  node_id          INTEGER     PRIMARY KEY,\n  upstream_node_id INTEGER     NULL REFERENCES nodes (node_id) DEFERRABLE,\n  active           BOOLEAN     NOT NULL DEFAULT TRUE,\n  node_name        TEXT        NOT NULL,\n  type             TEXT        NOT NULL CHECK (type IN('primary','standby','witness','bdr')),\n  location         TEXT        NOT NULL DEFAULT 'default',\n  priority         INT         NOT NULL DEFAULT 100,\n  conninfo         TEXT        NOT NULL,\n  repluser         VARCHAR(63) NOT NULL,\n  slot_name        TEXT        NULL,\n  config_file      TEXT        NOT NULL\n);\n\nCREATE TABLE repmgr.events (\n  node_id          INTEGER NOT NULL,\n  event            TEXT NOT NULL,\n  successful       BOOLEAN NOT NULL DEFAULT TRUE,\n  event_timestamp  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  details          TEXT NULL\n);\n\nDO $repmgr$\nDECLARE\n  DECLARE server_version_num INT;\nBEGIN\n  SELECT setting\n    FROM pg_catalog.pg_settings\n   WHERE name = 'server_version_num'\n    INTO server_version_num;\n  IF server_version_num >= 90400 THEN\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      PG_LSN NOT NULL,\n  last_wal_standby_location      PG_LSN,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n  ELSE\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      TEXT NOT NULL,\n  last_wal_standby_location      TEXT,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n  END IF;\nEND$repmgr$;\n\n\n\nCREATE INDEX idx_monitoring_history_time\n          ON repmgr.monitoring_history (last_monitor_time, standby_node_id);\n\nCREATE VIEW repmgr.show_nodes AS\n   SELECT n.node_id,\n          n.node_name,\n          n.active,\n          n.upstream_node_id,\n          un.node_name AS upstream_node_name,\n          n.type,\n          n.priority,\n          n.conninfo\n     FROM repmgr.nodes n\nLEFT JOIN repmgr.nodes un\n       ON un.node_id = n.upstream_node_id;\n\nCREATE TABLE repmgr.voting_term (\n  term INT NOT NULL\n);\n\nCREATE UNIQUE INDEX voting_term_restrict\nON repmgr.voting_term ((TRUE));\n\nCREATE RULE voting_term_delete AS\n   ON DELETE TO repmgr.voting_term\n   DO INSTEAD NOTHING;\n\n\n/* ================= */\n/* repmgrd functions */\n/* ================= */\n\n/* monitoring functions */\n\nCREATE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_get_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_last_seen(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_last_seen()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_upstream_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_upstream_node_id'\n  LANGUAGE C STRICT;\n\n/* failover functions */\n\nCREATE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_new_primary()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION am_bdr_failover_handler(INT)\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'am_bdr_failover_handler'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION unset_bdr_failover_handler()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'unset_bdr_failover_handler'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pidfile()\n  RETURNS TEXT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pidfile'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_repmgrd_pid(INT, TEXT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_running()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_running'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_pause(BOOL)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgrd_pause'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_paused()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_paused'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_wal_receiver_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_wal_receiver_pid'\n  LANGUAGE C STRICT;\n\n\n\n\n/* views */\n\nCREATE VIEW repmgr.replication_status AS\n  SELECT m.primary_node_id, m.standby_node_id, n.node_name AS standby_name,\n \t     n.type AS node_type, n.active, last_monitor_time,\n         CASE WHEN n.type='standby' THEN m.last_wal_primary_location ELSE NULL END AS last_wal_primary_location,\n         m.last_wal_standby_location,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.replication_lag) ELSE NULL END AS replication_lag,\n         CASE WHEN n.type='standby' THEN\n           CASE WHEN replication_lag > 0 THEN age(now(), m.last_apply_time) ELSE '0'::INTERVAL END\n           ELSE NULL\n         END AS replication_time_lag,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.apply_lag) ELSE NULL END AS apply_lag,\n         AGE(NOW(), CASE WHEN pg_catalog.pg_is_in_recovery() THEN repmgr.standby_get_last_updated() ELSE m.last_monitor_time END) AS communication_time_lag\n    FROM repmgr.monitoring_history m\n    JOIN repmgr.nodes n ON m.standby_node_id = n.node_id\n   WHERE (m.standby_node_id, m.last_monitor_time) IN (\n\t          SELECT m1.standby_node_id, MAX(m1.last_monitor_time)\n\t\t\t    FROM repmgr.monitoring_history m1 GROUP BY 1\n         );\n\n"
        },
        {
          "name": "repmgr--5.0--5.1.sql",
          "type": "blob",
          "size": 0.2197265625,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nDROP FUNCTION am_bdr_failover_handler(INT);\nDROP FUNCTION unset_bdr_failover_handler();\n"
        },
        {
          "name": "repmgr--5.0.sql",
          "type": "blob",
          "size": 6.3603515625,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nCREATE TABLE repmgr.nodes (\n  node_id          INTEGER     PRIMARY KEY,\n  upstream_node_id INTEGER     NULL REFERENCES nodes (node_id) DEFERRABLE,\n  active           BOOLEAN     NOT NULL DEFAULT TRUE,\n  node_name        TEXT        NOT NULL,\n  type             TEXT        NOT NULL CHECK (type IN('primary','standby','witness','bdr')),\n  location         TEXT        NOT NULL DEFAULT 'default',\n  priority         INT         NOT NULL DEFAULT 100,\n  conninfo         TEXT        NOT NULL,\n  repluser         VARCHAR(63) NOT NULL,\n  slot_name        TEXT        NULL,\n  config_file      TEXT        NOT NULL\n);\n\nCREATE TABLE repmgr.events (\n  node_id          INTEGER NOT NULL,\n  event            TEXT NOT NULL,\n  successful       BOOLEAN NOT NULL DEFAULT TRUE,\n  event_timestamp  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  details          TEXT NULL\n);\n\nDO $repmgr$\nDECLARE\n  DECLARE server_version_num INT;\nBEGIN\n  SELECT setting\n    FROM pg_catalog.pg_settings\n   WHERE name = 'server_version_num'\n    INTO server_version_num;\n  IF server_version_num >= 90400 THEN\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      PG_LSN NOT NULL,\n  last_wal_standby_location      PG_LSN,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n  ELSE\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      TEXT NOT NULL,\n  last_wal_standby_location      TEXT,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n  END IF;\nEND$repmgr$;\n\n\n\nCREATE INDEX idx_monitoring_history_time\n          ON repmgr.monitoring_history (last_monitor_time, standby_node_id);\n\nCREATE VIEW repmgr.show_nodes AS\n   SELECT n.node_id,\n          n.node_name,\n          n.active,\n          n.upstream_node_id,\n          un.node_name AS upstream_node_name,\n          n.type,\n          n.priority,\n          n.conninfo\n     FROM repmgr.nodes n\nLEFT JOIN repmgr.nodes un\n       ON un.node_id = n.upstream_node_id;\n\nCREATE TABLE repmgr.voting_term (\n  term INT NOT NULL\n);\n\nCREATE UNIQUE INDEX voting_term_restrict\nON repmgr.voting_term ((TRUE));\n\nCREATE RULE voting_term_delete AS\n   ON DELETE TO repmgr.voting_term\n   DO INSTEAD NOTHING;\n\n\n/* ================= */\n/* repmgrd functions */\n/* ================= */\n\n/* monitoring functions */\n\nCREATE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_get_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_last_seen(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_last_seen()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_upstream_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_upstream_node_id'\n  LANGUAGE C STRICT;\n\n/* failover functions */\n\nCREATE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_new_primary()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pidfile()\n  RETURNS TEXT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pidfile'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_repmgrd_pid(INT, TEXT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_repmgrd_pid'\n  LANGUAGE C CALLED ON NULL INPUT;\n\nCREATE FUNCTION repmgrd_is_running()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_running'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_pause(BOOL)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgrd_pause'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_paused()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_paused'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_wal_receiver_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_wal_receiver_pid'\n  LANGUAGE C STRICT;\n\n\n\n\n/* views */\n\nCREATE VIEW repmgr.replication_status AS\n  SELECT m.primary_node_id, m.standby_node_id, n.node_name AS standby_name,\n \t     n.type AS node_type, n.active, last_monitor_time,\n         CASE WHEN n.type='standby' THEN m.last_wal_primary_location ELSE NULL END AS last_wal_primary_location,\n         m.last_wal_standby_location,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.replication_lag) ELSE NULL END AS replication_lag,\n         CASE WHEN n.type='standby' THEN\n           CASE WHEN replication_lag > 0 THEN age(now(), m.last_apply_time) ELSE '0'::INTERVAL END\n           ELSE NULL\n         END AS replication_time_lag,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.apply_lag) ELSE NULL END AS apply_lag,\n         AGE(NOW(), CASE WHEN pg_catalog.pg_is_in_recovery() THEN repmgr.standby_get_last_updated() ELSE m.last_monitor_time END) AS communication_time_lag\n    FROM repmgr.monitoring_history m\n    JOIN repmgr.nodes n ON m.standby_node_id = n.node_id\n   WHERE (m.standby_node_id, m.last_monitor_time) IN (\n\t          SELECT m1.standby_node_id, MAX(m1.last_monitor_time)\n\t\t\t    FROM repmgr.monitoring_history m1 GROUP BY 1\n         );\n\n"
        },
        {
          "name": "repmgr--5.1--5.2.sql",
          "type": "blob",
          "size": 0.3359375,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nSELECT pg_catalog.pg_extension_config_dump('repmgr.nodes', '');\nSELECT pg_catalog.pg_extension_config_dump('repmgr.events', '');\nSELECT pg_catalog.pg_extension_config_dump('repmgr.monitoring_history', '');\n\n"
        },
        {
          "name": "repmgr--5.1.sql",
          "type": "blob",
          "size": 6.3603515625,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nCREATE TABLE repmgr.nodes (\n  node_id          INTEGER     PRIMARY KEY,\n  upstream_node_id INTEGER     NULL REFERENCES nodes (node_id) DEFERRABLE,\n  active           BOOLEAN     NOT NULL DEFAULT TRUE,\n  node_name        TEXT        NOT NULL,\n  type             TEXT        NOT NULL CHECK (type IN('primary','standby','witness','bdr')),\n  location         TEXT        NOT NULL DEFAULT 'default',\n  priority         INT         NOT NULL DEFAULT 100,\n  conninfo         TEXT        NOT NULL,\n  repluser         VARCHAR(63) NOT NULL,\n  slot_name        TEXT        NULL,\n  config_file      TEXT        NOT NULL\n);\n\nCREATE TABLE repmgr.events (\n  node_id          INTEGER NOT NULL,\n  event            TEXT NOT NULL,\n  successful       BOOLEAN NOT NULL DEFAULT TRUE,\n  event_timestamp  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  details          TEXT NULL\n);\n\nDO $repmgr$\nDECLARE\n  DECLARE server_version_num INT;\nBEGIN\n  SELECT setting\n    FROM pg_catalog.pg_settings\n   WHERE name = 'server_version_num'\n    INTO server_version_num;\n  IF server_version_num >= 90400 THEN\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      PG_LSN NOT NULL,\n  last_wal_standby_location      PG_LSN,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n  ELSE\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      TEXT NOT NULL,\n  last_wal_standby_location      TEXT,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n  END IF;\nEND$repmgr$;\n\n\n\nCREATE INDEX idx_monitoring_history_time\n          ON repmgr.monitoring_history (last_monitor_time, standby_node_id);\n\nCREATE VIEW repmgr.show_nodes AS\n   SELECT n.node_id,\n          n.node_name,\n          n.active,\n          n.upstream_node_id,\n          un.node_name AS upstream_node_name,\n          n.type,\n          n.priority,\n          n.conninfo\n     FROM repmgr.nodes n\nLEFT JOIN repmgr.nodes un\n       ON un.node_id = n.upstream_node_id;\n\nCREATE TABLE repmgr.voting_term (\n  term INT NOT NULL\n);\n\nCREATE UNIQUE INDEX voting_term_restrict\nON repmgr.voting_term ((TRUE));\n\nCREATE RULE voting_term_delete AS\n   ON DELETE TO repmgr.voting_term\n   DO INSTEAD NOTHING;\n\n\n/* ================= */\n/* repmgrd functions */\n/* ================= */\n\n/* monitoring functions */\n\nCREATE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_get_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_last_seen(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_last_seen()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_upstream_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_upstream_node_id'\n  LANGUAGE C STRICT;\n\n/* failover functions */\n\nCREATE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_new_primary()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pidfile()\n  RETURNS TEXT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pidfile'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_repmgrd_pid(INT, TEXT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_repmgrd_pid'\n  LANGUAGE C CALLED ON NULL INPUT;\n\nCREATE FUNCTION repmgrd_is_running()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_running'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_pause(BOOL)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgrd_pause'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_paused()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_paused'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_wal_receiver_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_wal_receiver_pid'\n  LANGUAGE C STRICT;\n\n\n\n\n/* views */\n\nCREATE VIEW repmgr.replication_status AS\n  SELECT m.primary_node_id, m.standby_node_id, n.node_name AS standby_name,\n \t     n.type AS node_type, n.active, last_monitor_time,\n         CASE WHEN n.type='standby' THEN m.last_wal_primary_location ELSE NULL END AS last_wal_primary_location,\n         m.last_wal_standby_location,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.replication_lag) ELSE NULL END AS replication_lag,\n         CASE WHEN n.type='standby' THEN\n           CASE WHEN replication_lag > 0 THEN age(now(), m.last_apply_time) ELSE '0'::INTERVAL END\n           ELSE NULL\n         END AS replication_time_lag,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.apply_lag) ELSE NULL END AS apply_lag,\n         AGE(NOW(), CASE WHEN pg_catalog.pg_is_in_recovery() THEN repmgr.standby_get_last_updated() ELSE m.last_monitor_time END) AS communication_time_lag\n    FROM repmgr.monitoring_history m\n    JOIN repmgr.nodes n ON m.standby_node_id = n.node_id\n   WHERE (m.standby_node_id, m.last_monitor_time) IN (\n\t          SELECT m1.standby_node_id, MAX(m1.last_monitor_time)\n\t\t\t    FROM repmgr.monitoring_history m1 GROUP BY 1\n         );\n\n"
        },
        {
          "name": "repmgr--5.2--5.3.sql",
          "type": "blob",
          "size": 1.865234375,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nCREATE OR REPLACE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE OR REPLACE FUNCTION repmgr.get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE OR REPLACE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'repmgr_standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE OR REPLACE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'repmgr_standby_get_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE OR REPLACE FUNCTION set_upstream_last_seen(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_set_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE OR REPLACE FUNCTION get_upstream_last_seen()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE OR REPLACE FUNCTION get_upstream_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_upstream_node_id'\n  LANGUAGE C STRICT;\n\nCREATE OR REPLACE FUNCTION set_upstream_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_set_upstream_node_id'\n  LANGUAGE C STRICT;\n\n/* failover functions */\n\nCREATE OR REPLACE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE OR REPLACE FUNCTION get_new_primary()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE OR REPLACE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE OR REPLACE FUNCTION get_wal_receiver_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_wal_receiver_pid'\n  LANGUAGE C STRICT;\n"
        },
        {
          "name": "repmgr--5.2.sql",
          "type": "blob",
          "size": 5.791015625,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nCREATE TABLE repmgr.nodes (\n  node_id          INTEGER     PRIMARY KEY,\n  upstream_node_id INTEGER     NULL REFERENCES nodes (node_id) DEFERRABLE,\n  active           BOOLEAN     NOT NULL DEFAULT TRUE,\n  node_name        TEXT        NOT NULL,\n  type             TEXT        NOT NULL CHECK (type IN('primary','standby','witness','bdr')),\n  location         TEXT        NOT NULL DEFAULT 'default',\n  priority         INT         NOT NULL DEFAULT 100,\n  conninfo         TEXT        NOT NULL,\n  repluser         VARCHAR(63) NOT NULL,\n  slot_name        TEXT        NULL,\n  config_file      TEXT        NOT NULL\n);\n\nSELECT pg_catalog.pg_extension_config_dump('repmgr.nodes', '');\n\nCREATE TABLE repmgr.events (\n  node_id          INTEGER NOT NULL,\n  event            TEXT NOT NULL,\n  successful       BOOLEAN NOT NULL DEFAULT TRUE,\n  event_timestamp  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  details          TEXT NULL\n);\n\nSELECT pg_catalog.pg_extension_config_dump('repmgr.events', '');\n\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      PG_LSN NOT NULL,\n  last_wal_standby_location      PG_LSN,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n);\n\nCREATE INDEX idx_monitoring_history_time\n          ON repmgr.monitoring_history (last_monitor_time, standby_node_id);\n\nSELECT pg_catalog.pg_extension_config_dump('repmgr.monitoring_history', '');\n\nCREATE VIEW repmgr.show_nodes AS\n   SELECT n.node_id,\n          n.node_name,\n          n.active,\n          n.upstream_node_id,\n          un.node_name AS upstream_node_name,\n          n.type,\n          n.priority,\n          n.conninfo\n     FROM repmgr.nodes n\nLEFT JOIN repmgr.nodes un\n       ON un.node_id = n.upstream_node_id;\n\nCREATE TABLE repmgr.voting_term (\n  term INT NOT NULL\n);\n\nCREATE UNIQUE INDEX voting_term_restrict\nON repmgr.voting_term ((TRUE));\n\nCREATE RULE voting_term_delete AS\n   ON DELETE TO repmgr.voting_term\n   DO INSTEAD NOTHING;\n\n\n/* ================= */\n/* repmgrd functions */\n/* ================= */\n\n/* monitoring functions */\n\nCREATE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_get_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_last_seen(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_last_seen()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_upstream_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_upstream_node_id'\n  LANGUAGE C STRICT;\n\n/* failover functions */\n\nCREATE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_new_primary()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pidfile()\n  RETURNS TEXT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pidfile'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_repmgrd_pid(INT, TEXT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_repmgrd_pid'\n  LANGUAGE C CALLED ON NULL INPUT;\n\nCREATE FUNCTION repmgrd_is_running()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_running'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_pause(BOOL)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgrd_pause'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_paused()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_paused'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_wal_receiver_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_wal_receiver_pid'\n  LANGUAGE C STRICT;\n\n\n\n\n/* views */\n\nCREATE VIEW repmgr.replication_status AS\n  SELECT m.primary_node_id, m.standby_node_id, n.node_name AS standby_name,\n \t     n.type AS node_type, n.active, last_monitor_time,\n         CASE WHEN n.type='standby' THEN m.last_wal_primary_location ELSE NULL END AS last_wal_primary_location,\n         m.last_wal_standby_location,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.replication_lag) ELSE NULL END AS replication_lag,\n         CASE WHEN n.type='standby' THEN\n           CASE WHEN replication_lag > 0 THEN age(now(), m.last_apply_time) ELSE '0'::INTERVAL END\n           ELSE NULL\n         END AS replication_time_lag,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.apply_lag) ELSE NULL END AS apply_lag,\n         AGE(NOW(), CASE WHEN pg_catalog.pg_is_in_recovery() THEN repmgr.standby_get_last_updated() ELSE m.last_monitor_time END) AS communication_time_lag\n    FROM repmgr.monitoring_history m\n    JOIN repmgr.nodes n ON m.standby_node_id = n.node_id\n   WHERE (m.standby_node_id, m.last_monitor_time) IN (\n\t          SELECT m1.standby_node_id, MAX(m1.last_monitor_time)\n\t\t\t    FROM repmgr.monitoring_history m1 GROUP BY 1\n         );\n\n"
        },
        {
          "name": "repmgr--5.3--5.4.sql",
          "type": "blob",
          "size": 0.1318359375,
          "content": "-- complain if script is sourced in psql, rather than via CREAT EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n"
        },
        {
          "name": "repmgr--5.3.sql",
          "type": "blob",
          "size": 5.873046875,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nCREATE TABLE repmgr.nodes (\n  node_id          INTEGER     PRIMARY KEY,\n  upstream_node_id INTEGER     NULL REFERENCES nodes (node_id) DEFERRABLE,\n  active           BOOLEAN     NOT NULL DEFAULT TRUE,\n  node_name        TEXT        NOT NULL,\n  type             TEXT        NOT NULL CHECK (type IN('primary','standby','witness','bdr')),\n  location         TEXT        NOT NULL DEFAULT 'default',\n  priority         INT         NOT NULL DEFAULT 100,\n  conninfo         TEXT        NOT NULL,\n  repluser         VARCHAR(63) NOT NULL,\n  slot_name        TEXT        NULL,\n  config_file      TEXT        NOT NULL\n);\n\nSELECT pg_catalog.pg_extension_config_dump('repmgr.nodes', '');\n\nCREATE TABLE repmgr.events (\n  node_id          INTEGER NOT NULL,\n  event            TEXT NOT NULL,\n  successful       BOOLEAN NOT NULL DEFAULT TRUE,\n  event_timestamp  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  details          TEXT NULL\n);\n\nSELECT pg_catalog.pg_extension_config_dump('repmgr.events', '');\n\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      PG_LSN NOT NULL,\n  last_wal_standby_location      PG_LSN,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n);\n\nCREATE INDEX idx_monitoring_history_time\n          ON repmgr.monitoring_history (last_monitor_time, standby_node_id);\n\nSELECT pg_catalog.pg_extension_config_dump('repmgr.monitoring_history', '');\n\nCREATE VIEW repmgr.show_nodes AS\n   SELECT n.node_id,\n          n.node_name,\n          n.active,\n          n.upstream_node_id,\n          un.node_name AS upstream_node_name,\n          n.type,\n          n.priority,\n          n.conninfo\n     FROM repmgr.nodes n\nLEFT JOIN repmgr.nodes un\n       ON un.node_id = n.upstream_node_id;\n\nCREATE TABLE repmgr.voting_term (\n  term INT NOT NULL\n);\n\nCREATE UNIQUE INDEX voting_term_restrict\nON repmgr.voting_term ((TRUE));\n\nCREATE RULE voting_term_delete AS\n   ON DELETE TO repmgr.voting_term\n   DO INSTEAD NOTHING;\n\n\n/* ================= */\n/* repmgrd functions */\n/* ================= */\n\n/* monitoring functions */\n\nCREATE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'repmgr_standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'repmgr_standby_get_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_last_seen(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_set_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_last_seen()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_upstream_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_set_upstream_node_id'\n  LANGUAGE C STRICT;\n\n/* failover functions */\n\nCREATE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_new_primary()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pidfile()\n  RETURNS TEXT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pidfile'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_repmgrd_pid(INT, TEXT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_repmgrd_pid'\n  LANGUAGE C CALLED ON NULL INPUT;\n\nCREATE FUNCTION repmgrd_is_running()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_running'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_pause(BOOL)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgrd_pause'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_paused()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_paused'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_wal_receiver_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_wal_receiver_pid'\n  LANGUAGE C STRICT;\n\n\n\n\n/* views */\n\nCREATE VIEW repmgr.replication_status AS\n  SELECT m.primary_node_id, m.standby_node_id, n.node_name AS standby_name,\n \t     n.type AS node_type, n.active, last_monitor_time,\n         CASE WHEN n.type='standby' THEN m.last_wal_primary_location ELSE NULL END AS last_wal_primary_location,\n         m.last_wal_standby_location,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.replication_lag) ELSE NULL END AS replication_lag,\n         CASE WHEN n.type='standby' THEN\n           CASE WHEN replication_lag > 0 THEN age(now(), m.last_apply_time) ELSE '0'::INTERVAL END\n           ELSE NULL\n         END AS replication_time_lag,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.apply_lag) ELSE NULL END AS apply_lag,\n         AGE(NOW(), CASE WHEN pg_catalog.pg_is_in_recovery() THEN repmgr.standby_get_last_updated() ELSE m.last_monitor_time END) AS communication_time_lag\n    FROM repmgr.monitoring_history m\n    JOIN repmgr.nodes n ON m.standby_node_id = n.node_id\n   WHERE (m.standby_node_id, m.last_monitor_time) IN (\n\t          SELECT m1.standby_node_id, MAX(m1.last_monitor_time)\n\t\t\t    FROM repmgr.monitoring_history m1 GROUP BY 1\n         );\n\n"
        },
        {
          "name": "repmgr--5.4--5.5.sql",
          "type": "blob",
          "size": 0.1318359375,
          "content": "-- complain if script is sourced in psql, rather than via CREAT EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n"
        },
        {
          "name": "repmgr--5.4.sql",
          "type": "blob",
          "size": 5.873046875,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nCREATE TABLE repmgr.nodes (\n  node_id          INTEGER     PRIMARY KEY,\n  upstream_node_id INTEGER     NULL REFERENCES nodes (node_id) DEFERRABLE,\n  active           BOOLEAN     NOT NULL DEFAULT TRUE,\n  node_name        TEXT        NOT NULL,\n  type             TEXT        NOT NULL CHECK (type IN('primary','standby','witness','bdr')),\n  location         TEXT        NOT NULL DEFAULT 'default',\n  priority         INT         NOT NULL DEFAULT 100,\n  conninfo         TEXT        NOT NULL,\n  repluser         VARCHAR(63) NOT NULL,\n  slot_name        TEXT        NULL,\n  config_file      TEXT        NOT NULL\n);\n\nSELECT pg_catalog.pg_extension_config_dump('repmgr.nodes', '');\n\nCREATE TABLE repmgr.events (\n  node_id          INTEGER NOT NULL,\n  event            TEXT NOT NULL,\n  successful       BOOLEAN NOT NULL DEFAULT TRUE,\n  event_timestamp  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  details          TEXT NULL\n);\n\nSELECT pg_catalog.pg_extension_config_dump('repmgr.events', '');\n\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      PG_LSN NOT NULL,\n  last_wal_standby_location      PG_LSN,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n);\n\nCREATE INDEX idx_monitoring_history_time\n          ON repmgr.monitoring_history (last_monitor_time, standby_node_id);\n\nSELECT pg_catalog.pg_extension_config_dump('repmgr.monitoring_history', '');\n\nCREATE VIEW repmgr.show_nodes AS\n   SELECT n.node_id,\n          n.node_name,\n          n.active,\n          n.upstream_node_id,\n          un.node_name AS upstream_node_name,\n          n.type,\n          n.priority,\n          n.conninfo\n     FROM repmgr.nodes n\nLEFT JOIN repmgr.nodes un\n       ON un.node_id = n.upstream_node_id;\n\nCREATE TABLE repmgr.voting_term (\n  term INT NOT NULL\n);\n\nCREATE UNIQUE INDEX voting_term_restrict\nON repmgr.voting_term ((TRUE));\n\nCREATE RULE voting_term_delete AS\n   ON DELETE TO repmgr.voting_term\n   DO INSTEAD NOTHING;\n\n\n/* ================= */\n/* repmgrd functions */\n/* ================= */\n\n/* monitoring functions */\n\nCREATE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'repmgr_standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'repmgr_standby_get_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_last_seen(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_set_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_last_seen()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_upstream_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_set_upstream_node_id'\n  LANGUAGE C STRICT;\n\n/* failover functions */\n\nCREATE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_new_primary()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pidfile()\n  RETURNS TEXT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pidfile'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_repmgrd_pid(INT, TEXT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_repmgrd_pid'\n  LANGUAGE C CALLED ON NULL INPUT;\n\nCREATE FUNCTION repmgrd_is_running()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_running'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_pause(BOOL)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgrd_pause'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_paused()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_paused'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_wal_receiver_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_wal_receiver_pid'\n  LANGUAGE C STRICT;\n\n\n\n\n/* views */\n\nCREATE VIEW repmgr.replication_status AS\n  SELECT m.primary_node_id, m.standby_node_id, n.node_name AS standby_name,\n \t     n.type AS node_type, n.active, last_monitor_time,\n         CASE WHEN n.type='standby' THEN m.last_wal_primary_location ELSE NULL END AS last_wal_primary_location,\n         m.last_wal_standby_location,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.replication_lag) ELSE NULL END AS replication_lag,\n         CASE WHEN n.type='standby' THEN\n           CASE WHEN replication_lag > 0 THEN age(now(), m.last_apply_time) ELSE '0'::INTERVAL END\n           ELSE NULL\n         END AS replication_time_lag,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.apply_lag) ELSE NULL END AS apply_lag,\n         AGE(NOW(), CASE WHEN pg_catalog.pg_is_in_recovery() THEN repmgr.standby_get_last_updated() ELSE m.last_monitor_time END) AS communication_time_lag\n    FROM repmgr.monitoring_history m\n    JOIN repmgr.nodes n ON m.standby_node_id = n.node_id\n   WHERE (m.standby_node_id, m.last_monitor_time) IN (\n\t          SELECT m1.standby_node_id, MAX(m1.last_monitor_time)\n\t\t\t    FROM repmgr.monitoring_history m1 GROUP BY 1\n         );\n\n"
        },
        {
          "name": "repmgr--5.5.sql",
          "type": "blob",
          "size": 5.8720703125,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\nCREATE TABLE repmgr.nodes (\n  node_id          INTEGER     PRIMARY KEY,\n  upstream_node_id INTEGER     NULL REFERENCES nodes (node_id) DEFERRABLE,\n  active           BOOLEAN     NOT NULL DEFAULT TRUE,\n  node_name        TEXT        NOT NULL,\n  type             TEXT        NOT NULL CHECK (type IN('primary','standby','witness','bdr')),\n  location         TEXT        NOT NULL DEFAULT 'default',\n  priority         INT         NOT NULL DEFAULT 100,\n  conninfo         TEXT        NOT NULL,\n  repluser         VARCHAR(63) NOT NULL,\n  slot_name        TEXT        NULL,\n  config_file      TEXT        NOT NULL\n);\n\nSELECT pg_catalog.pg_extension_config_dump('repmgr.nodes', '');\n\nCREATE TABLE repmgr.events (\n  node_id          INTEGER NOT NULL,\n  event            TEXT NOT NULL,\n  successful       BOOLEAN NOT NULL DEFAULT TRUE,\n  event_timestamp  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  details          TEXT NULL\n);\n\nSELECT pg_catalog.pg_extension_config_dump('repmgr.events', '');\n\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      PG_LSN NOT NULL,\n  last_wal_standby_location      PG_LSN,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n);\n\nCREATE INDEX idx_monitoring_history_time\n          ON repmgr.monitoring_history (last_monitor_time, standby_node_id);\n\nSELECT pg_catalog.pg_extension_config_dump('repmgr.monitoring_history', '');\n\nCREATE VIEW repmgr.show_nodes AS\n   SELECT n.node_id,\n          n.node_name,\n          n.active,\n          n.upstream_node_id,\n          un.node_name AS upstream_node_name,\n          n.type,\n          n.priority,\n          n.conninfo\n     FROM repmgr.nodes n\nLEFT JOIN repmgr.nodes un\n       ON un.node_id = n.upstream_node_id;\n\nCREATE TABLE repmgr.voting_term (\n  term INT NOT NULL\n);\n\nCREATE UNIQUE INDEX voting_term_restrict\nON repmgr.voting_term ((TRUE));\n\nCREATE RULE voting_term_delete AS\n   ON DELETE TO repmgr.voting_term\n   DO INSTEAD NOTHING;\n\n\n/* ================= */\n/* repmgrd functions */\n/* ================= */\n\n/* monitoring functions */\n\nCREATE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'repmgr_standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'repmgr_standby_get_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_last_seen(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_set_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_last_seen()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_upstream_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_set_upstream_node_id'\n  LANGUAGE C STRICT;\n\n/* failover functions */\n\nCREATE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_new_primary()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pidfile()\n  RETURNS TEXT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pidfile'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_repmgrd_pid(INT, TEXT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_repmgrd_pid'\n  LANGUAGE C CALLED ON NULL INPUT;\n\nCREATE FUNCTION repmgrd_is_running()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_running'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_pause(BOOL)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgrd_pause'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_paused()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_paused'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_wal_receiver_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_wal_receiver_pid'\n  LANGUAGE C STRICT;\n\n\n\n\n/* views */\n\nCREATE VIEW repmgr.replication_status AS\n  SELECT m.primary_node_id, m.standby_node_id, n.node_name AS standby_name,\n \t     n.type AS node_type, n.active, last_monitor_time,\n         CASE WHEN n.type='standby' THEN m.last_wal_primary_location ELSE NULL END AS last_wal_primary_location,\n         m.last_wal_standby_location,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.replication_lag) ELSE NULL END AS replication_lag,\n         CASE WHEN n.type='standby' THEN\n           CASE WHEN replication_lag > 0 THEN age(now(), m.last_apply_time) ELSE '0'::INTERVAL END\n           ELSE NULL\n         END AS replication_time_lag,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.apply_lag) ELSE NULL END AS apply_lag,\n         AGE(NOW(), CASE WHEN pg_catalog.pg_is_in_recovery() THEN repmgr.standby_get_last_updated() ELSE m.last_monitor_time END) AS communication_time_lag\n    FROM repmgr.monitoring_history m\n    JOIN repmgr.nodes n ON m.standby_node_id = n.node_id\n   WHERE (m.standby_node_id, m.last_monitor_time) IN (\n\t          SELECT m1.standby_node_id, MAX(m1.last_monitor_time)\n\t\t\t    FROM repmgr.monitoring_history m1 GROUP BY 1\n         );\n"
        },
        {
          "name": "repmgr--unpackaged--4.0.sql",
          "type": "blob",
          "size": 7.5048828125,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\n-- extract the current schema name\n-- NOTE: this assumes there will be only one schema matching 'repmgr_%';\n-- user is responsible for ensuring this is the case\n\nCREATE TEMPORARY TABLE repmgr_old_schema (schema_name TEXT);\nINSERT INTO repmgr_old_schema (schema_name)\nSELECT nspname AS schema_name\n  FROM pg_catalog.pg_namespace\n WHERE nspname LIKE 'repmgr_%'\n LIMIT 1;\n\n-- move old objects into new schema\nDO $repmgr$\nDECLARE\n  old_schema TEXT;\nBEGIN\n  SELECT schema_name FROM repmgr_old_schema\n    INTO old_schema;\n  EXECUTE format('ALTER TABLE %I.repl_nodes SET SCHEMA repmgr', old_schema);\n  EXECUTE format('ALTER TABLE %I.repl_events SET SCHEMA repmgr', old_schema);\n  EXECUTE format('ALTER TABLE %I.repl_monitor SET SCHEMA repmgr', old_schema);\n  EXECUTE format('DROP VIEW IF EXISTS %I.repl_show_nodes', old_schema);\n  EXECUTE format('DROP VIEW IF EXISTS %I.repl_status', old_schema);\nEND$repmgr$;\n\n-- convert \"repmgr_$cluster.repl_nodes\" to \"repmgr.nodes\"\nCREATE TABLE repmgr.nodes (\n  node_id          INTEGER     PRIMARY KEY,\n  upstream_node_id INTEGER     NULL REFERENCES repmgr.nodes (node_id) DEFERRABLE,\n  active           BOOLEAN     NOT NULL DEFAULT TRUE,\n  node_name        TEXT        NOT NULL,\n  type             TEXT        NOT NULL CHECK (type IN('primary','standby','witness','bdr')),\n  location         TEXT        NOT NULL DEFAULT 'default',\n  priority         INT         NOT NULL DEFAULT 100,\n  conninfo         TEXT        NOT NULL,\n  repluser         VARCHAR(63) NOT NULL,\n  slot_name        TEXT        NULL,\n  config_file      TEXT        NOT NULL\n);\n\nINSERT INTO repmgr.nodes\n  (node_id, upstream_node_id, active, node_name, type, location, priority, conninfo, repluser, slot_name, config_file)\nSELECT id, upstream_node_id, active, name,\n       CASE WHEN type = 'master' THEN 'primary' ELSE type END,\n       'default', priority, conninfo, 'unknown', slot_name, 'unknown'\n  FROM repmgr.repl_nodes\n ORDER BY id;\n\n\n-- convert \"repmgr_$cluster.repl_event\" to \"event\"\n\nALTER TABLE repmgr.repl_events RENAME TO events;\n\n-- create new table \"repmgr.voting_term\"\nCREATE TABLE repmgr.voting_term (\n  term INT NOT NULL\n);\n\nCREATE UNIQUE INDEX voting_term_restrict\nON repmgr.voting_term ((TRUE));\n\nCREATE RULE voting_term_delete AS\n   ON DELETE TO repmgr.voting_term\n   DO INSTEAD NOTHING;\n\nINSERT INTO repmgr.voting_term (term) VALUES (1);\n\n\n-- convert \"repmgr_$cluster.repl_monitor\" to \"monitoring_history\"\n\n\nDO $repmgr$\nDECLARE\n  DECLARE server_version_num INT;\nBEGIN\n  SELECT setting\n    FROM pg_catalog.pg_settings\n   WHERE name = 'server_version_num'\n    INTO server_version_num;\n  IF server_version_num >= 90400 THEN\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      PG_LSN NOT NULL,\n  last_wal_standby_location      PG_LSN,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n    INSERT INTO repmgr.monitoring_history\n      (primary_node_id, standby_node_id, last_monitor_time,  last_apply_time, last_wal_primary_location, last_wal_standby_location, replication_lag, apply_lag)\n    SELECT primary_node, standby_node, last_monitor_time,  last_apply_time, last_wal_primary_location::pg_lsn, last_wal_standby_location::pg_lsn, replication_lag, apply_lag\n      FROM repmgr.repl_monitor;\n  ELSE\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      TEXT NOT NULL,\n  last_wal_standby_location      TEXT,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n    INSERT INTO repmgr.monitoring_history\n      (primary_node_id, standby_node_id, last_monitor_time,  last_apply_time, last_wal_primary_location, last_wal_standby_location, replication_lag, apply_lag)\n    SELECT primary_node, standby_node, last_monitor_time,  last_apply_time, last_wal_primary_location, last_wal_standby_location, replication_lag, apply_lag\n      FROM repmgr.repl_monitor;\n\n  END IF;\nEND$repmgr$;\n\nCREATE INDEX idx_monitoring_history_time\n          ON repmgr.monitoring_history (last_monitor_time, standby_node_id);\n\nCREATE VIEW repmgr.show_nodes AS\n   SELECT n.node_id,\n          n.node_name,\n          n.active,\n          n.upstream_node_id,\n          un.node_name AS upstream_node_name,\n          n.type,\n          n.priority,\n          n.conninfo\n     FROM repmgr.nodes n\nLEFT JOIN repmgr.nodes un\n       ON un.node_id = n.upstream_node_id;\n\n\n/* ================= */\n/* repmgrd functions */\n/* ================= */\n\n/* monitoring functions */\n\nCREATE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS '$libdir/repmgr', 'standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS '$libdir/repmgr', 'standby_get_last_updated'\n  LANGUAGE C STRICT;\n\n\n/* failover functions */\n\nCREATE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS '$libdir/repmgr', 'notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_new_primary()\n  RETURNS INT\n  AS '$libdir/repmgr', 'get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS '$libdir/repmgr', 'reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION am_bdr_failover_handler(INT)\n  RETURNS BOOL\n  AS '$libdir/repmgr', 'am_bdr_failover_handler'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION unset_bdr_failover_handler()\n  RETURNS VOID\n  AS '$libdir/repmgr', 'unset_bdr_failover_handler'\n  LANGUAGE C STRICT;\n\n\n\nCREATE VIEW repmgr.replication_status AS\n  SELECT m.primary_node_id, m.standby_node_id, n.node_name AS standby_name,\n \t     n.type AS node_type, n.active, last_monitor_time,\n         CASE WHEN n.type='standby' THEN m.last_wal_primary_location ELSE NULL END AS last_wal_primary_location,\n         m.last_wal_standby_location,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.replication_lag) ELSE NULL END AS replication_lag,\n         CASE WHEN n.type='standby' THEN\n           CASE WHEN replication_lag > 0 THEN age(now(), m.last_apply_time) ELSE '0'::INTERVAL END\n           ELSE NULL\n         END AS replication_time_lag,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.apply_lag) ELSE NULL END AS apply_lag,\n         AGE(NOW(), CASE WHEN pg_catalog.pg_is_in_recovery() THEN repmgr.standby_get_last_updated() ELSE m.last_monitor_time END) AS communication_time_lag\n    FROM repmgr.monitoring_history m\n    JOIN repmgr.nodes n ON m.standby_node_id = n.node_id\n   WHERE (m.standby_node_id, m.last_monitor_time) IN (\n\t          SELECT m1.standby_node_id, MAX(m1.last_monitor_time)\n\t\t\t    FROM repmgr.monitoring_history m1 GROUP BY 1\n         );\n\n\n/* drop old tables */\nDROP TABLE repmgr.repl_nodes;\nDROP TABLE repmgr.repl_monitor;\n\n-- remove temporary table\nDROP TABLE repmgr_old_schema;\n"
        },
        {
          "name": "repmgr--unpackaged--5.1.sql",
          "type": "blob",
          "size": 8.5751953125,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\n-- extract the current schema name\n-- NOTE: this assumes there will be only one schema matching 'repmgr_%';\n-- user is responsible for ensuring this is the case\n\nCREATE TEMPORARY TABLE repmgr_old_schema (schema_name TEXT);\nINSERT INTO repmgr_old_schema (schema_name)\nSELECT nspname AS schema_name\n  FROM pg_catalog.pg_namespace\n WHERE nspname LIKE 'repmgr_%'\n LIMIT 1;\n\n-- move old objects into new schema\nDO $repmgr$\nDECLARE\n  old_schema TEXT;\nBEGIN\n  SELECT schema_name FROM repmgr_old_schema\n    INTO old_schema;\n  EXECUTE format('ALTER TABLE %I.repl_nodes SET SCHEMA repmgr', old_schema);\n  EXECUTE format('ALTER TABLE %I.repl_events SET SCHEMA repmgr', old_schema);\n  EXECUTE format('ALTER TABLE %I.repl_monitor SET SCHEMA repmgr', old_schema);\n  EXECUTE format('DROP VIEW IF EXISTS %I.repl_show_nodes', old_schema);\n  EXECUTE format('DROP VIEW IF EXISTS %I.repl_status', old_schema);\nEND$repmgr$;\n\n-- convert \"repmgr_$cluster.repl_nodes\" to \"repmgr.nodes\"\nCREATE TABLE repmgr.nodes (\n  node_id          INTEGER     PRIMARY KEY,\n  upstream_node_id INTEGER     NULL REFERENCES repmgr.nodes (node_id) DEFERRABLE,\n  active           BOOLEAN     NOT NULL DEFAULT TRUE,\n  node_name        TEXT        NOT NULL,\n  type             TEXT        NOT NULL CHECK (type IN('primary','standby','witness','bdr')),\n  location         TEXT        NOT NULL DEFAULT 'default',\n  priority         INT         NOT NULL DEFAULT 100,\n  conninfo         TEXT        NOT NULL,\n  repluser         VARCHAR(63) NOT NULL,\n  slot_name        TEXT        NULL,\n  config_file      TEXT        NOT NULL\n);\n\nINSERT INTO repmgr.nodes\n  (node_id, upstream_node_id, active, node_name, type, location, priority, conninfo, repluser, slot_name, config_file)\nSELECT id, upstream_node_id, active, name,\n       CASE WHEN type = 'master' THEN 'primary' ELSE type END,\n       'default', priority, conninfo, 'unknown', slot_name, 'unknown'\n  FROM repmgr.repl_nodes\n ORDER BY id;\n\n\n-- convert \"repmgr_$cluster.repl_event\" to \"event\"\n\nALTER TABLE repmgr.repl_events RENAME TO events;\n\n-- create new table \"repmgr.voting_term\"\nCREATE TABLE repmgr.voting_term (\n  term INT NOT NULL\n);\n\nCREATE UNIQUE INDEX voting_term_restrict\nON repmgr.voting_term ((TRUE));\n\nCREATE RULE voting_term_delete AS\n   ON DELETE TO repmgr.voting_term\n   DO INSTEAD NOTHING;\n\nINSERT INTO repmgr.voting_term (term) VALUES (1);\n\n\n-- convert \"repmgr_$cluster.repl_monitor\" to \"monitoring_history\"\n\n\nDO $repmgr$\nDECLARE\n  DECLARE server_version_num INT;\nBEGIN\n  SELECT setting\n    FROM pg_catalog.pg_settings\n   WHERE name = 'server_version_num'\n    INTO server_version_num;\n  IF server_version_num >= 90400 THEN\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      PG_LSN NOT NULL,\n  last_wal_standby_location      PG_LSN,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n    INSERT INTO repmgr.monitoring_history\n      (primary_node_id, standby_node_id, last_monitor_time,  last_apply_time, last_wal_primary_location, last_wal_standby_location, replication_lag, apply_lag)\n    SELECT primary_node, standby_node, last_monitor_time,  last_apply_time, last_wal_primary_location::pg_lsn, last_wal_standby_location::pg_lsn, replication_lag, apply_lag\n      FROM repmgr.repl_monitor;\n  ELSE\n    EXECUTE $repmgr_func$\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      TEXT NOT NULL,\n  last_wal_standby_location      TEXT,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n)\n    $repmgr_func$;\n    INSERT INTO repmgr.monitoring_history\n      (primary_node_id, standby_node_id, last_monitor_time,  last_apply_time, last_wal_primary_location, last_wal_standby_location, replication_lag, apply_lag)\n    SELECT primary_node, standby_node, last_monitor_time,  last_apply_time, last_wal_primary_location, last_wal_standby_location, replication_lag, apply_lag\n      FROM repmgr.repl_monitor;\n\n  END IF;\nEND$repmgr$;\n\nCREATE INDEX idx_monitoring_history_time\n          ON repmgr.monitoring_history (last_monitor_time, standby_node_id);\n\nCREATE VIEW repmgr.show_nodes AS\n   SELECT n.node_id,\n          n.node_name,\n          n.active,\n          n.upstream_node_id,\n          un.node_name AS upstream_node_name,\n          n.type,\n          n.priority,\n          n.conninfo\n     FROM repmgr.nodes n\nLEFT JOIN repmgr.nodes un\n       ON un.node_id = n.upstream_node_id;\n\n\n/* ================= */\n/* repmgrd functions */\n/* ================= */\n\n/* monitoring functions */\n\nCREATE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_get_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_last_seen(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_last_seen()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_upstream_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_upstream_node_id'\n  LANGUAGE C STRICT;\n\n/* failover functions */\n\nCREATE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_new_primary()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pidfile()\n  RETURNS TEXT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pidfile'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_repmgrd_pid(INT, TEXT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_repmgrd_pid'\n  LANGUAGE C CALLED ON NULL INPUT;\n\nCREATE FUNCTION repmgrd_is_running()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_running'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_pause(BOOL)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgrd_pause'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_paused()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_paused'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_wal_receiver_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_wal_receiver_pid'\n  LANGUAGE C STRICT;\n\n\n/* views */\n\nCREATE VIEW repmgr.replication_status AS\n  SELECT m.primary_node_id, m.standby_node_id, n.node_name AS standby_name,\n \t     n.type AS node_type, n.active, last_monitor_time,\n         CASE WHEN n.type='standby' THEN m.last_wal_primary_location ELSE NULL END AS last_wal_primary_location,\n         m.last_wal_standby_location,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.replication_lag) ELSE NULL END AS replication_lag,\n         CASE WHEN n.type='standby' THEN\n           CASE WHEN replication_lag > 0 THEN age(now(), m.last_apply_time) ELSE '0'::INTERVAL END\n           ELSE NULL\n         END AS replication_time_lag,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.apply_lag) ELSE NULL END AS apply_lag,\n         AGE(NOW(), CASE WHEN pg_catalog.pg_is_in_recovery() THEN repmgr.standby_get_last_updated() ELSE m.last_monitor_time END) AS communication_time_lag\n    FROM repmgr.monitoring_history m\n    JOIN repmgr.nodes n ON m.standby_node_id = n.node_id\n   WHERE (m.standby_node_id, m.last_monitor_time) IN (\n\t          SELECT m1.standby_node_id, MAX(m1.last_monitor_time)\n\t\t\t    FROM repmgr.monitoring_history m1 GROUP BY 1\n         );\n\n\n\n/* drop old tables */\nDROP TABLE repmgr.repl_nodes;\nDROP TABLE repmgr.repl_monitor;\n\n-- remove temporary table\nDROP TABLE repmgr_old_schema;\n"
        },
        {
          "name": "repmgr--unpackaged--5.2.sql",
          "type": "blob",
          "size": 7.8173828125,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\n-- extract the current schema name\n-- NOTE: this assumes there will be only one schema matching 'repmgr_%';\n-- user is responsible for ensuring this is the case\n\nCREATE TEMPORARY TABLE repmgr_old_schema (schema_name TEXT);\nINSERT INTO repmgr_old_schema (schema_name)\nSELECT nspname AS schema_name\n  FROM pg_catalog.pg_namespace\n WHERE nspname LIKE 'repmgr_%'\n LIMIT 1;\n\n-- move old objects into new schema\nDO $repmgr$\nDECLARE\n  old_schema TEXT;\nBEGIN\n  SELECT schema_name FROM repmgr_old_schema\n    INTO old_schema;\n  EXECUTE format('ALTER TABLE %I.repl_nodes SET SCHEMA repmgr', old_schema);\n  EXECUTE format('ALTER TABLE %I.repl_events SET SCHEMA repmgr', old_schema);\n  EXECUTE format('ALTER TABLE %I.repl_monitor SET SCHEMA repmgr', old_schema);\n  EXECUTE format('DROP VIEW IF EXISTS %I.repl_show_nodes', old_schema);\n  EXECUTE format('DROP VIEW IF EXISTS %I.repl_status', old_schema);\nEND$repmgr$;\n\n-- convert \"repmgr_$cluster.repl_nodes\" to \"repmgr.nodes\"\nCREATE TABLE repmgr.nodes (\n  node_id          INTEGER     PRIMARY KEY,\n  upstream_node_id INTEGER     NULL REFERENCES repmgr.nodes (node_id) DEFERRABLE,\n  active           BOOLEAN     NOT NULL DEFAULT TRUE,\n  node_name        TEXT        NOT NULL,\n  type             TEXT        NOT NULL CHECK (type IN('primary','standby','witness','bdr')),\n  location         TEXT        NOT NULL DEFAULT 'default',\n  priority         INT         NOT NULL DEFAULT 100,\n  conninfo         TEXT        NOT NULL,\n  repluser         VARCHAR(63) NOT NULL,\n  slot_name        TEXT        NULL,\n  config_file      TEXT        NOT NULL\n);\n\nINSERT INTO repmgr.nodes\n  (node_id, upstream_node_id, active, node_name, type, location, priority, conninfo, repluser, slot_name, config_file)\nSELECT id, upstream_node_id, active, name,\n       CASE WHEN type = 'master' THEN 'primary' ELSE type END,\n       'default', priority, conninfo, 'unknown', slot_name, 'unknown'\n  FROM repmgr.repl_nodes\n ORDER BY id;\n\n\n-- convert \"repmgr_$cluster.repl_event\" to \"event\"\n\nCREATE TABLE repmgr.events (\n  node_id          INTEGER NOT NULL,\n  event            TEXT NOT NULL,\n  successful       BOOLEAN NOT NULL DEFAULT TRUE,\n  event_timestamp  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  details          TEXT NULL\n);\n\nINSERT INTO repmgr.events\n  (node_id, event, successful, event_timestamp, details)\n  SELECT node_id, event, successful, event_timestamp, details\n    FROM repmgr.repl_events;\n\n-- create new table \"repmgr.voting_term\"\nCREATE TABLE repmgr.voting_term (\n  term INT NOT NULL\n);\n\nCREATE UNIQUE INDEX voting_term_restrict\nON repmgr.voting_term ((TRUE));\n\nCREATE RULE voting_term_delete AS\n   ON DELETE TO repmgr.voting_term\n   DO INSTEAD NOTHING;\n\nINSERT INTO repmgr.voting_term (term) VALUES (1);\n\n-- convert \"repmgr_$cluster.repl_monitor\" to \"monitoring_history\"\n\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      PG_LSN NOT NULL,\n  last_wal_standby_location      PG_LSN,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n);\n\nINSERT INTO repmgr.monitoring_history\n  (primary_node_id, standby_node_id, last_monitor_time,  last_apply_time, last_wal_primary_location, last_wal_standby_location, replication_lag, apply_lag)\n  SELECT primary_node, standby_node, last_monitor_time,  last_apply_time, last_wal_primary_location::pg_lsn, last_wal_standby_location::pg_lsn, replication_lag, apply_lag\n    FROM repmgr.repl_monitor;\n\nCREATE INDEX idx_monitoring_history_time\n          ON repmgr.monitoring_history (last_monitor_time, standby_node_id);\n\nCREATE VIEW repmgr.show_nodes AS\n   SELECT n.node_id,\n          n.node_name,\n          n.active,\n          n.upstream_node_id,\n          un.node_name AS upstream_node_name,\n          n.type,\n          n.priority,\n          n.conninfo\n     FROM repmgr.nodes n\nLEFT JOIN repmgr.nodes un\n       ON un.node_id = n.upstream_node_id;\n\n\n/* ================= */\n/* repmgrd functions */\n/* ================= */\n\n/* monitoring functions */\n\nCREATE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'standby_get_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_last_seen(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_last_seen()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_upstream_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_upstream_node_id'\n  LANGUAGE C STRICT;\n\n/* failover functions */\n\nCREATE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_new_primary()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pidfile()\n  RETURNS TEXT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pidfile'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_repmgrd_pid(INT, TEXT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_repmgrd_pid'\n  LANGUAGE C CALLED ON NULL INPUT;\n\nCREATE FUNCTION repmgrd_is_running()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_running'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_pause(BOOL)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgrd_pause'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_paused()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_paused'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_wal_receiver_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_wal_receiver_pid'\n  LANGUAGE C STRICT;\n\n\n/* views */\n\nCREATE VIEW repmgr.replication_status AS\n  SELECT m.primary_node_id, m.standby_node_id, n.node_name AS standby_name,\n \t     n.type AS node_type, n.active, last_monitor_time,\n         CASE WHEN n.type='standby' THEN m.last_wal_primary_location ELSE NULL END AS last_wal_primary_location,\n         m.last_wal_standby_location,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.replication_lag) ELSE NULL END AS replication_lag,\n         CASE WHEN n.type='standby' THEN\n           CASE WHEN replication_lag > 0 THEN age(now(), m.last_apply_time) ELSE '0'::INTERVAL END\n           ELSE NULL\n         END AS replication_time_lag,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.apply_lag) ELSE NULL END AS apply_lag,\n         AGE(NOW(), CASE WHEN pg_catalog.pg_is_in_recovery() THEN repmgr.standby_get_last_updated() ELSE m.last_monitor_time END) AS communication_time_lag\n    FROM repmgr.monitoring_history m\n    JOIN repmgr.nodes n ON m.standby_node_id = n.node_id\n   WHERE (m.standby_node_id, m.last_monitor_time) IN (\n\t          SELECT m1.standby_node_id, MAX(m1.last_monitor_time)\n\t\t\t    FROM repmgr.monitoring_history m1 GROUP BY 1\n         );\n\n\n\n/* drop old tables */\nDROP TABLE repmgr.repl_nodes;\nDROP TABLE repmgr.repl_monitor;\nDROP TABLE repmgr.repl_events;\n\n-- remove temporary table\nDROP TABLE repmgr_old_schema;\n"
        },
        {
          "name": "repmgr--unpackaged--5.3.sql",
          "type": "blob",
          "size": 7.8994140625,
          "content": "-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\\echo Use \"CREATE EXTENSION repmgr\" to load this file. \\quit\n\n-- extract the current schema name\n-- NOTE: this assumes there will be only one schema matching 'repmgr_%';\n-- user is responsible for ensuring this is the case\n\nCREATE TEMPORARY TABLE repmgr_old_schema (schema_name TEXT);\nINSERT INTO repmgr_old_schema (schema_name)\nSELECT nspname AS schema_name\n  FROM pg_catalog.pg_namespace\n WHERE nspname LIKE 'repmgr_%'\n LIMIT 1;\n\n-- move old objects into new schema\nDO $repmgr$\nDECLARE\n  old_schema TEXT;\nBEGIN\n  SELECT schema_name FROM repmgr_old_schema\n    INTO old_schema;\n  EXECUTE format('ALTER TABLE %I.repl_nodes SET SCHEMA repmgr', old_schema);\n  EXECUTE format('ALTER TABLE %I.repl_events SET SCHEMA repmgr', old_schema);\n  EXECUTE format('ALTER TABLE %I.repl_monitor SET SCHEMA repmgr', old_schema);\n  EXECUTE format('DROP VIEW IF EXISTS %I.repl_show_nodes', old_schema);\n  EXECUTE format('DROP VIEW IF EXISTS %I.repl_status', old_schema);\nEND$repmgr$;\n\n-- convert \"repmgr_$cluster.repl_nodes\" to \"repmgr.nodes\"\nCREATE TABLE repmgr.nodes (\n  node_id          INTEGER     PRIMARY KEY,\n  upstream_node_id INTEGER     NULL REFERENCES repmgr.nodes (node_id) DEFERRABLE,\n  active           BOOLEAN     NOT NULL DEFAULT TRUE,\n  node_name        TEXT        NOT NULL,\n  type             TEXT        NOT NULL CHECK (type IN('primary','standby','witness','bdr')),\n  location         TEXT        NOT NULL DEFAULT 'default',\n  priority         INT         NOT NULL DEFAULT 100,\n  conninfo         TEXT        NOT NULL,\n  repluser         VARCHAR(63) NOT NULL,\n  slot_name        TEXT        NULL,\n  config_file      TEXT        NOT NULL\n);\n\nINSERT INTO repmgr.nodes\n  (node_id, upstream_node_id, active, node_name, type, location, priority, conninfo, repluser, slot_name, config_file)\nSELECT id, upstream_node_id, active, name,\n       CASE WHEN type = 'master' THEN 'primary' ELSE type END,\n       'default', priority, conninfo, 'unknown', slot_name, 'unknown'\n  FROM repmgr.repl_nodes\n ORDER BY id;\n\n\n-- convert \"repmgr_$cluster.repl_event\" to \"event\"\n\nCREATE TABLE repmgr.events (\n  node_id          INTEGER NOT NULL,\n  event            TEXT NOT NULL,\n  successful       BOOLEAN NOT NULL DEFAULT TRUE,\n  event_timestamp  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  details          TEXT NULL\n);\n\nINSERT INTO repmgr.events\n  (node_id, event, successful, event_timestamp, details)\n  SELECT node_id, event, successful, event_timestamp, details\n    FROM repmgr.repl_events;\n\n-- create new table \"repmgr.voting_term\"\nCREATE TABLE repmgr.voting_term (\n  term INT NOT NULL\n);\n\nCREATE UNIQUE INDEX voting_term_restrict\nON repmgr.voting_term ((TRUE));\n\nCREATE RULE voting_term_delete AS\n   ON DELETE TO repmgr.voting_term\n   DO INSTEAD NOTHING;\n\nINSERT INTO repmgr.voting_term (term) VALUES (1);\n\n-- convert \"repmgr_$cluster.repl_monitor\" to \"monitoring_history\"\n\nCREATE TABLE repmgr.monitoring_history (\n  primary_node_id                INTEGER NOT NULL,\n  standby_node_id                INTEGER NOT NULL,\n  last_monitor_time              TIMESTAMP WITH TIME ZONE NOT NULL,\n  last_apply_time                TIMESTAMP WITH TIME ZONE,\n  last_wal_primary_location      PG_LSN NOT NULL,\n  last_wal_standby_location      PG_LSN,\n  replication_lag                BIGINT NOT NULL,\n  apply_lag                      BIGINT NOT NULL\n);\n\nINSERT INTO repmgr.monitoring_history\n  (primary_node_id, standby_node_id, last_monitor_time,  last_apply_time, last_wal_primary_location, last_wal_standby_location, replication_lag, apply_lag)\n  SELECT primary_node, standby_node, last_monitor_time,  last_apply_time, last_wal_primary_location::pg_lsn, last_wal_standby_location::pg_lsn, replication_lag, apply_lag\n    FROM repmgr.repl_monitor;\n\nCREATE INDEX idx_monitoring_history_time\n          ON repmgr.monitoring_history (last_monitor_time, standby_node_id);\n\nCREATE VIEW repmgr.show_nodes AS\n   SELECT n.node_id,\n          n.node_name,\n          n.active,\n          n.upstream_node_id,\n          un.node_name AS upstream_node_name,\n          n.type,\n          n.priority,\n          n.conninfo\n     FROM repmgr.nodes n\nLEFT JOIN repmgr.nodes un\n       ON un.node_id = n.upstream_node_id;\n\n\n/* ================= */\n/* repmgrd functions */\n/* ================= */\n\n/* monitoring functions */\n\nCREATE FUNCTION set_local_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_set_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_local_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_local_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_set_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'repmgr_standby_set_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION standby_get_last_updated()\n  RETURNS TIMESTAMP WITH TIME ZONE\n  AS 'MODULE_PATHNAME', 'repmgr_standby_get_last_updated'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_last_seen(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_set_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_last_seen()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_upstream_last_seen'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_upstream_node_id()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_upstream_node_id'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_upstream_node_id(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_set_upstream_node_id'\n  LANGUAGE C STRICT;\n\n/* failover functions */\n\nCREATE FUNCTION notify_follow_primary(INT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_notify_follow_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_new_primary()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_new_primary'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION reset_voting_status()\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgr_reset_voting_status'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pid'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_repmgrd_pidfile()\n  RETURNS TEXT\n  AS 'MODULE_PATHNAME', 'get_repmgrd_pidfile'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION set_repmgrd_pid(INT, TEXT)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'set_repmgrd_pid'\n  LANGUAGE C CALLED ON NULL INPUT;\n\nCREATE FUNCTION repmgrd_is_running()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_running'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_pause(BOOL)\n  RETURNS VOID\n  AS 'MODULE_PATHNAME', 'repmgrd_pause'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION repmgrd_is_paused()\n  RETURNS BOOL\n  AS 'MODULE_PATHNAME', 'repmgrd_is_paused'\n  LANGUAGE C STRICT;\n\nCREATE FUNCTION get_wal_receiver_pid()\n  RETURNS INT\n  AS 'MODULE_PATHNAME', 'repmgr_get_wal_receiver_pid'\n  LANGUAGE C STRICT;\n\n\n/* views */\n\nCREATE VIEW repmgr.replication_status AS\n  SELECT m.primary_node_id, m.standby_node_id, n.node_name AS standby_name,\n \t     n.type AS node_type, n.active, last_monitor_time,\n         CASE WHEN n.type='standby' THEN m.last_wal_primary_location ELSE NULL END AS last_wal_primary_location,\n         m.last_wal_standby_location,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.replication_lag) ELSE NULL END AS replication_lag,\n         CASE WHEN n.type='standby' THEN\n           CASE WHEN replication_lag > 0 THEN age(now(), m.last_apply_time) ELSE '0'::INTERVAL END\n           ELSE NULL\n         END AS replication_time_lag,\n         CASE WHEN n.type='standby' THEN pg_catalog.pg_size_pretty(m.apply_lag) ELSE NULL END AS apply_lag,\n         AGE(NOW(), CASE WHEN pg_catalog.pg_is_in_recovery() THEN repmgr.standby_get_last_updated() ELSE m.last_monitor_time END) AS communication_time_lag\n    FROM repmgr.monitoring_history m\n    JOIN repmgr.nodes n ON m.standby_node_id = n.node_id\n   WHERE (m.standby_node_id, m.last_monitor_time) IN (\n\t          SELECT m1.standby_node_id, MAX(m1.last_monitor_time)\n\t\t\t    FROM repmgr.monitoring_history m1 GROUP BY 1\n         );\n\n\n\n/* drop old tables */\nDROP TABLE repmgr.repl_nodes;\nDROP TABLE repmgr.repl_monitor;\nDROP TABLE repmgr.repl_events;\n\n-- remove temporary table\nDROP TABLE repmgr_old_schema;\n"
        },
        {
          "name": "repmgr-action-cluster.c",
          "type": "blob",
          "size": 38.0703125,
          "content": "/*\n * repmgr-action-cluster.c\n *\n * Implements cluster information actions for the repmgr command line utility\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"repmgr.h\"\n#include \"compat.h\"\n#include \"repmgr-client-global.h\"\n#include \"repmgr-action-cluster.h\"\n\n#define SHOW_HEADER_COUNT 9\n\ntypedef enum\n{\n\tSHOW_ID = 0,\n\tSHOW_NAME,\n\tSHOW_ROLE,\n\tSHOW_STATUS,\n\tSHOW_UPSTREAM_NAME,\n\tSHOW_LOCATION,\n\tSHOW_PRIORITY,\n\tSHOW_TIMELINE_ID,\n\tSHOW_CONNINFO\n}\t\t\tShowHeader;\n\n#define EVENT_HEADER_COUNT 6\n\ntypedef enum\n{\n\tEV_NODE_ID = 0,\n\tEV_NODE_NAME,\n\tEV_EVENT,\n\tEV_SUCCESS,\n\tEV_TIMESTAMP,\n\tEV_DETAILS\n}\t\t\tEventHeader;\n\n\nstruct ColHeader headers_show[SHOW_HEADER_COUNT];\nstruct ColHeader headers_event[EVENT_HEADER_COUNT];\n\nstatic int\tbuild_cluster_matrix(t_node_matrix_rec ***matrix_rec_dest, ItemList *warnings, int *error_code);\nstatic int\tbuild_cluster_crosscheck(t_node_status_cube ***cube_dest, ItemList *warnings, int *error_code);\nstatic void cube_set_node_status(t_node_status_cube **cube, int n, int node_id, int matrix_node_id, int connection_node_id, int connection_status);\n\n/*\n * CLUSTER SHOW\n *\n * Parameters:\n *   --compact\n *   --csv\n *   --terse\n *   --verbose\n */\nvoid\ndo_cluster_show(void)\n{\n\tPGconn\t   *conn = NULL;\n\tNodeInfoList nodes = T_NODE_INFO_LIST_INITIALIZER;\n\tNodeInfoListCell *cell = NULL;\n\tint\t\t\ti = 0;\n\tItemList\twarnings = {NULL, NULL};\n\tbool\t\tsuccess = false;\n\tbool\t\terror_found = false;\n\tbool\t\tconnection_error_found = false;\n\n\t/* Connect to local database to obtain cluster connection data */\n\tlog_verbose(LOG_INFO, _(\"connecting to database\"));\n\n\tif (strlen(config_file_options.conninfo))\n\t\tconn = establish_db_connection(config_file_options.conninfo, true);\n\telse\n\t\tconn = establish_db_connection_by_params(&source_conninfo, true);\n\n\tsuccess = get_all_node_records_with_upstream(conn, &nodes);\n\n\tif (success == false)\n\t{\n\t\t/* get_all_node_records_with_upstream() will print error message */\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tif (nodes.node_count == 0)\n\t{\n\t\tlog_error(_(\"no node records were found\"));\n\t\tlog_hint(_(\"ensure at least one node is registered\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* Initialize column headers  */\n\tstrncpy(headers_show[SHOW_ID].title, _(\"ID\"), MAXLEN);\n\tstrncpy(headers_show[SHOW_NAME].title, _(\"Name\"), MAXLEN);\n\tstrncpy(headers_show[SHOW_ROLE].title, _(\"Role\"), MAXLEN);\n\tstrncpy(headers_show[SHOW_STATUS].title, _(\"Status\"), MAXLEN);\n\tstrncpy(headers_show[SHOW_UPSTREAM_NAME].title, _(\"Upstream\"), MAXLEN);\n\tstrncpy(headers_show[SHOW_LOCATION].title, _(\"Location\"), MAXLEN);\n\n\tif (runtime_options.compact == true)\n\t{\n\t\tstrncpy(headers_show[SHOW_PRIORITY].title, _(\"Prio.\"), MAXLEN);\n\t\tstrncpy(headers_show[SHOW_TIMELINE_ID].title, _(\"TLI\"), MAXLEN);\n\t}\n\telse\n\t{\n\t\tstrncpy(headers_show[SHOW_PRIORITY].title, _(\"Priority\"), MAXLEN);\n\t\tstrncpy(headers_show[SHOW_TIMELINE_ID].title, _(\"Timeline\"), MAXLEN);\n\t}\n\n\tstrncpy(headers_show[SHOW_CONNINFO].title, _(\"Connection string\"), MAXLEN);\n\n\t/*\n\t * NOTE: if repmgr is ever localized into non-ASCII locales, use\n\t * pg_wcssize() or similar to establish printed column length\n\t */\n\n\tfor (i = 0; i < SHOW_HEADER_COUNT; i++)\n\t{\n\t\theaders_show[i].display = true;\n\n\t\t/* Don't display timeline on pre-9.6 clusters  */\n\t\tif (i == SHOW_TIMELINE_ID)\n\t\t{\n\t\t\tif (PQserverVersion(conn) < 90600)\n\t\t\t{\n\t\t\t\theaders_show[i].display = false;\n\t\t\t}\n\t\t}\n\n\t\t/* if --compact provided, don't display conninfo */\n\t\tif (runtime_options.compact == true)\n\t\t{\n\t\t\tif (i == SHOW_CONNINFO)\n\t\t\t{\n\t\t\t\theaders_show[i].display = false;\n\t\t\t}\n\t\t}\n\n\n\t\tif (headers_show[i].display == true)\n\t\t{\n\t\t\theaders_show[i].max_length = strlen(headers_show[i].title);\n\t\t}\n\t}\n\n\t/*\n\t * TODO: count nodes marked as \"? unreachable\" and add a hint about\n\t * the other cluster commands for better determining whether\n\t * unreachable.\n\t */\n\n\tfor (cell = nodes.head; cell; cell = cell->next)\n\t{\n\t\tPQExpBufferData node_status;\n\t\tPQExpBufferData upstream;\n\t\tPQExpBufferData buf;\n\n\t\tcell->node_info->replication_info = palloc0(sizeof(ReplInfo));\n\t\tif (cell->node_info->replication_info == NULL)\n\t\t{\n\t\t\tlog_error(_(\"unable to allocate memory\"));\n\t\t\texit(ERR_INTERNAL);\n\t\t}\n\n\t\tinit_replication_info(cell->node_info->replication_info);\n\n\t\tcell->node_info->conn = establish_db_connection_quiet(cell->node_info->conninfo);\n\n\t\tif (PQstatus(cell->node_info->conn) != CONNECTION_OK)\n\t\t{\n\t\t\tconnection_error_found = true;\n\n\t\t\tif (runtime_options.verbose)\n\t\t\t{\n\t\t\t\tchar\t\terror[MAXLEN];\n\n\t\t\t\tstrncpy(error, PQerrorMessage(cell->node_info->conn), MAXLEN);\n\t\t\t\titem_list_append_format(&warnings,\n\t\t\t\t\t\t\t\t\t\t\"when attempting to connect to node \\\"%s\\\" (ID: %i), following error encountered :\\n\\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tcell->node_info->node_name, cell->node_info->node_id, trim(error));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\titem_list_append_format(&warnings,\n\t\t\t\t\t\t\t\t\t\t\"unable to connect to node \\\"%s\\\" (ID: %i)\",\n\t\t\t\t\t\t\t\t\t\tcell->node_info->node_name, cell->node_info->node_id);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* NOP on pre-9.6 servers */\n\t\t\tcell->node_info->replication_info->timeline_id = get_node_timeline(cell->node_info->conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   cell->node_info->replication_info->timeline_id_str);\n\t\t}\n\n\t\tinitPQExpBuffer(&node_status);\n\t\tinitPQExpBuffer(&upstream);\n\n\t\tif (format_node_status(cell->node_info, &node_status, &upstream, &warnings) == true)\n\t\t\terror_found = true;\n\n\t\tsnprintf(cell->node_info->details, sizeof(cell->node_info->details),\n\t\t\t\t \"%s\", node_status.data);\n\t\tsnprintf(cell->node_info->upstream_node_name, sizeof(cell->node_info->upstream_node_name),\n\t\t\t\t \"%s\", upstream.data);\n\n\t\ttermPQExpBuffer(&node_status);\n\t\ttermPQExpBuffer(&upstream);\n\n\t\tPQfinish(cell->node_info->conn);\n\t\tcell->node_info->conn = NULL;\n\n\t\tinitPQExpBuffer(&buf);\n\t\tappendPQExpBuffer(&buf, \"%i\", cell->node_info->node_id);\n\t\theaders_show[SHOW_ID].cur_length = strlen(buf.data);\n\t\ttermPQExpBuffer(&buf);\n\n\t\theaders_show[SHOW_ROLE].cur_length = strlen(get_node_type_string(cell->node_info->type));\n\t\theaders_show[SHOW_NAME].cur_length = strlen(cell->node_info->node_name);\n\t\theaders_show[SHOW_STATUS].cur_length = strlen(cell->node_info->details);\n\n\t\theaders_show[SHOW_UPSTREAM_NAME].cur_length = strlen(cell->node_info->upstream_node_name);\n\n\t\tinitPQExpBuffer(&buf);\n\t\tappendPQExpBuffer(&buf, \"%i\", cell->node_info->priority);\n\t\theaders_show[SHOW_PRIORITY].cur_length = strlen(buf.data);\n\t\ttermPQExpBuffer(&buf);\n\n\t\theaders_show[SHOW_LOCATION].cur_length = strlen(cell->node_info->location);\n\n\t\t/* Format timeline ID */\n\t\tif (cell->node_info->type == WITNESS)\n\t\t{\n\t\t\t/* The witness node's timeline ID is irrelevant */\n\t\t\tstrncpy(cell->node_info->replication_info->timeline_id_str, _(\"n/a\"), MAXLEN);\n\t\t}\n\t\theaders_show[SHOW_TIMELINE_ID].cur_length = strlen(cell->node_info->replication_info->timeline_id_str);\n\n\t\theaders_show[SHOW_CONNINFO].cur_length = strlen(cell->node_info->conninfo);\n\n\t\tfor (i = 0; i < SHOW_HEADER_COUNT; i++)\n\t\t{\n\t\t\tif (runtime_options.compact == true)\n\t\t\t{\n\t\t\t\tif (headers_show[i].display == false)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (headers_show[i].cur_length > headers_show[i].max_length)\n\t\t\t{\n\t\t\t\theaders_show[i].max_length = headers_show[i].cur_length;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/* Print column header row (text mode only) */\n\tif (runtime_options.output_mode == OM_TEXT)\n\t{\n\t\tprint_status_header(SHOW_HEADER_COUNT, headers_show);\n\t}\n\n\tfor (cell = nodes.head; cell; cell = cell->next)\n\t{\n\t\tif (runtime_options.output_mode == OM_CSV)\n\t\t{\n\t\t\tint\t\t\tconnection_status = (cell->node_info->node_status == NODE_STATUS_UP) ? 0 : -1;\n\t\t\tint\t\t\trecovery_type = RECTYPE_UNKNOWN;\n\n\t\t\t/*\n\t\t\t * here we explicitly convert the RecoveryType to integer values\n\t\t\t * to avoid implicit dependency on the values in the enum\n\t\t\t */\n\t\t\tswitch (cell->node_info->recovery_type)\n\t\t\t{\n\t\t\t\tcase RECTYPE_UNKNOWN:\n\t\t\t\t\trecovery_type = -1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RECTYPE_PRIMARY:\n\t\t\t\t\trecovery_type = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RECTYPE_STANDBY:\n\t\t\t\t\trecovery_type = 1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprintf(\"%i,%i,%i\\n\",\n\t\t\t\t   cell->node_info->node_id,\n\t\t\t\t   connection_status,\n\t\t\t\t   recovery_type);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\" %-*i \", headers_show[SHOW_ID].max_length, cell->node_info->node_id);\n\t\t\tprintf(\"| %-*s \", headers_show[SHOW_NAME].max_length, cell->node_info->node_name);\n\t\t\tprintf(\"| %-*s \", headers_show[SHOW_ROLE].max_length, get_node_type_string(cell->node_info->type));\n\t\t\tprintf(\"| %-*s \", headers_show[SHOW_STATUS].max_length, cell->node_info->details);\n\t\t\tprintf(\"| %-*s \", headers_show[SHOW_UPSTREAM_NAME].max_length, cell->node_info->upstream_node_name);\n\t\t\tprintf(\"| %-*s \", headers_show[SHOW_LOCATION].max_length, cell->node_info->location);\n\t\t\tprintf(\"| %-*i \", headers_show[SHOW_PRIORITY].max_length, cell->node_info->priority);\n\n\t\t\tif (headers_show[SHOW_TIMELINE_ID].display == true)\n\t\t\t{\n\t\t\t\tprintf(\"| %-*s \", headers_show[SHOW_TIMELINE_ID].max_length, cell->node_info->replication_info->timeline_id_str);\n\t\t\t}\n\n\t\t\tif (headers_show[SHOW_CONNINFO].display == true)\n\t\t\t{\n\t\t\t\tprintf(\"| %-*s\", headers_show[SHOW_CONNINFO].max_length, cell->node_info->conninfo);\n\t\t\t}\n\n\t\t\tputs(\"\");\n\t\t}\n\t}\n\n\tclear_node_info_list(&nodes);\n\tPQfinish(conn);\n\n\t/* emit any warnings */\n\tif (warnings.head != NULL && runtime_options.terse == false && runtime_options.output_mode != OM_CSV)\n\t{\n\n\t\tItemListCell *cell = NULL;\n\t\tPQExpBufferData warning;\n\n\t\tinitPQExpBuffer(&warning);\n\n\t\tappendPQExpBufferStr(&warning,\n\t\t\t\t\t\t\t _(\"following issues were detected\\n\"));\n\t\tfor (cell = warnings.head; cell; cell = cell->next)\n\t\t{\n\t\t\tappendPQExpBuffer(&warning,\n\t\t\t\t\t\t\t  _(\"  - %s\\n\"), cell->string);\n\t\t}\n\n\t\tputs(\"\");\n\t\tlog_warning(\"%s\", warning.data);\n\n\t\ttermPQExpBuffer(&warning);\n\n\t\tif (runtime_options.verbose == false && connection_error_found == true)\n\t\t{\n\t\t\tlog_hint(_(\"execute with --verbose option to see connection error messages\"));\n\t\t}\n\t}\n\n\t/*\n\t * If warnings were noted, even if they're not displayed (e.g. in --csv node),\n\t * that means something's not right so we need to emit a non-zero exit code.\n\t */\n\tif (warnings.head != NULL)\n\t{\n\t\terror_found = true;\n\t}\n\n\tif (error_found == true)\n\t{\n\t\texit(ERR_NODE_STATUS);\n\t}\n}\n\n\n/*\n * CLUSTER EVENT\n *\n * Parameters:\n *   --limit[=20]\n *   --all\n *   --node-[id|name]\n *   --event\n *   --csv\n *   --compact\n */\n\nvoid\ndo_cluster_event(void)\n{\n\tPGconn\t   *conn = NULL;\n\tPGresult   *res;\n\tint\t\t\ti = 0;\n\tint\t\t\tcolumn_count = EVENT_HEADER_COUNT;\n\n\tconn = establish_db_connection(config_file_options.conninfo, true);\n\n\tres = get_event_records(conn,\n\t\t\t\t\t\t\truntime_options.node_id,\n\t\t\t\t\t\t\truntime_options.node_name,\n\t\t\t\t\t\t\truntime_options.event,\n\t\t\t\t\t\t\truntime_options.all,\n\t\t\t\t\t\t\truntime_options.limit);\n\n\tif (PQresultStatus(res) != PGRES_TUPLES_OK)\n\t{\n\t\tlog_error(_(\"unable to execute event query:\\n  %s\"),\n\t\t\t\t  PQerrorMessage(conn));\n\t\tPQclear(res);\n\t\tPQfinish(conn);\n\t\texit(ERR_DB_QUERY);\n\t}\n\n\tif (PQntuples(res) == 0)\n\t{\n\t\t/* print this message directly, rather than as a log line */\n\t\tprintf(_(\"no matching events found\\n\"));\n\t\tPQclear(res);\n\t\tPQfinish(conn);\n\t\treturn;\n\t}\n\n\tstrncpy(headers_event[EV_NODE_ID].title, _(\"Node ID\"), MAXLEN);\n\tstrncpy(headers_event[EV_NODE_NAME].title, _(\"Name\"), MAXLEN);\n\tstrncpy(headers_event[EV_EVENT].title, _(\"Event\"), MAXLEN);\n\tstrncpy(headers_event[EV_SUCCESS].title, _(\"OK\"), MAXLEN);\n\tstrncpy(headers_event[EV_TIMESTAMP].title, _(\"Timestamp\"), MAXLEN);\n\tstrncpy(headers_event[EV_DETAILS].title, _(\"Details\"), MAXLEN);\n\n\t/*\n\t * If --compact or --csv provided, simply omit the \"Details\" column.\n\t * In --csv mode we'd need to quote/escape the contents \"Details\" column,\n\t * which is doable but which will remain a TODO for now.\n\t */\n\tif (runtime_options.compact == true || runtime_options.output_mode == OM_CSV)\n\t\tcolumn_count --;\n\n\tfor (i = 0; i < column_count; i++)\n\t{\n\t\theaders_event[i].max_length = strlen(headers_event[i].title);\n\t}\n\n\tfor (i = 0; i < PQntuples(res); i++)\n\t{\n\t\tint\t\t\tj;\n\n\t\tfor (j = 0; j < column_count; j++)\n\t\t{\n\t\t\theaders_event[j].cur_length = strlen(PQgetvalue(res, i, j));\n\t\t\tif (headers_event[j].cur_length > headers_event[j].max_length)\n\t\t\t{\n\t\t\t\theaders_event[j].max_length = headers_event[j].cur_length;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (runtime_options.output_mode == OM_TEXT)\n\t{\n\t\tfor (i = 0; i < column_count; i++)\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t\tprintf(\" \");\n\t\t\telse\n\t\t\t\tprintf(\" | \");\n\n\t\t\tprintf(\"%-*s\",\n\t\t\t\t   headers_event[i].max_length,\n\t\t\t\t   headers_event[i].title);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tprintf(\"-\");\n\t\tfor (i = 0; i < column_count; i++)\n\t\t{\n\t\t\tint\t\t\tj;\n\n\t\t\tfor (j = 0; j < headers_event[i].max_length; j++)\n\t\t\t\tprintf(\"-\");\n\n\t\t\tif (i < (column_count - 1))\n\t\t\t\tprintf(\"-+-\");\n\t\t\telse\n\t\t\t\tprintf(\"-\");\n\t\t}\n\n\t\tprintf(\"\\n\");\n\t}\n\n\tfor (i = 0; i < PQntuples(res); i++)\n\t{\n\t\tint\t\t\tj;\n\n\t\tif (runtime_options.output_mode == OM_CSV)\n\t\t{\n\t\t\tfor (j = 0; j < column_count; j++)\n\t\t\t{\n\t\t\t\tprintf(\"%s\", PQgetvalue(res, i, j));\n\t\t\t\tif ((j + 1) < column_count)\n\t\t\t\t{\n\t\t\t\t\tprintf(\",\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\" \");\n\t\t\tfor (j = 0; j < column_count; j++)\n\t\t\t{\n\t\t\t\tprintf(\"%-*s\",\n\t\t\t\t\t   headers_event[j].max_length,\n\t\t\t\t\t   PQgetvalue(res, i, j));\n\n\t\t\t\tif (j < (column_count - 1))\n\t\t\t\t\tprintf(\" | \");\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"\\n\");\n\t}\n\n\tPQclear(res);\n\n\tPQfinish(conn);\n\n\tif (runtime_options.output_mode == OM_TEXT)\n\t\tputs(\"\");\n}\n\n\nvoid\ndo_cluster_crosscheck(void)\n{\n\tint\t\t\ti = 0,\n\t\t\t\tn = 0;\n\n\tt_node_status_cube **cube;\n\n\tbool\t\tconnection_error_found = false;\n\tint\t\t\terror_code = SUCCESS;\n\tItemList\twarnings = {NULL, NULL};\n\n\tn = build_cluster_crosscheck(&cube, &warnings, &error_code);\n\n\tif (runtime_options.output_mode == OM_CSV)\n\t{\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tint j;\n\t\t\tfor (j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tint\t\t\tmax_node_status = -2;\n\t\t\t\tint\t\t\tnode_ix = 0;\n\n\t\t\t\tfor (node_ix = 0; node_ix < n; node_ix++)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tnode_status = cube[node_ix]->matrix_list_rec[i]->node_status_list[j]->node_status;\n\n\t\t\t\t\tif (node_status > max_node_status)\n\t\t\t\t\t\tmax_node_status = node_status;\n\t\t\t\t}\n\t\t\t\tprintf(\"%i,%i,%i\\n\",\n\t\t\t\t\t   cube[i]->node_id,\n\t\t\t\t\t   cube[j]->node_id,\n\t\t\t\t\t   max_node_status);\n\n\t\t\t\tif (max_node_status == -1)\n\t\t\t\t{\n\t\t\t\t\tconnection_error_found = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* output header contains node name, node ID and one column for each node in the cluster */\n\t\tstruct ColHeader *headers_crosscheck = NULL;\n\n\t\tint header_count = n + 2;\n\t\tint header_id = 2;\n\n\t\theaders_crosscheck = palloc0(sizeof(ColHeader) * header_count);\n\n\t\t/* Initialize column headers  */\n\t\tstrncpy(headers_crosscheck[0].title, _(\"Name\"), MAXLEN);\n\t\tstrncpy(headers_crosscheck[1].title, _(\"ID\"), MAXLEN);\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tmaxlen_snprintf(headers_crosscheck[header_id].title, \"%i\", cube[i]->node_id);\n\t\t\theader_id++;\n\t\t}\n\n\t\t/* Initialize column max values */\n\t\tfor (i = 0; i < header_count; i++)\n\t\t{\n\t\t\theaders_crosscheck[i].display = true;\n\t\t\theaders_crosscheck[i].max_length = strlen(headers_crosscheck[i].title);\n\t\t\theaders_crosscheck[i].cur_length = headers_crosscheck[i].max_length;\n\n\t\t\t/* We can derive the maximum node ID length for the ID column from\n\t\t\t * the generated matrix node ID headers\n\t\t\t */\n\t\t\tif (i >= 2 && headers_crosscheck[i].max_length > headers_crosscheck[1].max_length)\n\t\t\t\theaders_crosscheck[1].max_length = headers_crosscheck[i].max_length;\n\t\t}\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tif (strlen(cube[i]->node_name) > headers_crosscheck[0].max_length)\n\t\t\t{\n\t\t\t\theaders_crosscheck[0].max_length = strlen(cube[i]->node_name);\n\t\t\t}\n\t\t}\n\n\t\tprint_status_header(header_count, headers_crosscheck);\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tint\t\t\tcolumn_node_ix;\n\n\t\t\tprintf(\" %-*s | %-*i \",\n\t\t\t\t   headers_crosscheck[0].max_length,\n\t\t\t\t   cube[i]->node_name,\n\t\t\t\t   headers_crosscheck[1].max_length,\n\t\t\t\t   cube[i]->node_id);\n\n\t\t\tfor (column_node_ix = 0; column_node_ix < n; column_node_ix++)\n\t\t\t{\n\t\t\t\tint\t\t\tmax_node_status = -2;\n\t\t\t\tint\t\t\tnode_ix = 0;\n\n\t\t\t\tchar\t\tc;\n\n\t\t\t\t/*\n\t\t\t\t * The value of entry (i,j) is equal to the maximum value of all\n\t\t\t\t * the (i,j,k). Indeed:\n\t\t\t\t *\n\t\t\t\t * - if one of the (i,j,k) is 0 (node up), then 0 (the node is\n\t\t\t\t * up);\n\t\t\t\t *\n\t\t\t\t * - if the (i,j,k) are either -1 (down) or -2 (unknown), then -1\n\t\t\t\t * (the node is down);\n\t\t\t\t *\n\t\t\t\t * - if all the (i,j,k) are -2 (unknown), then -2 (the node is in\n\t\t\t\t * an unknown state).\n\t\t\t\t */\n\n\t\t\t\tfor (node_ix = 0; node_ix < n; node_ix++)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tnode_status = cube[node_ix]->matrix_list_rec[i]->node_status_list[column_node_ix]->node_status;\n\n\t\t\t\t\tif (node_status > max_node_status)\n\t\t\t\t\t\tmax_node_status = node_status;\n\t\t\t\t}\n\n\t\t\t\tswitch (max_node_status)\n\t\t\t\t{\n\t\t\t\t\tcase -2:\n\t\t\t\t\t\tc = '?';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tc = 'x';\n\t\t\t\t\t\tconnection_error_found = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tc = '*';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tlog_error(\"unexpected node status value %i\", max_node_status);\n\t\t\t\t\t\texit(ERR_INTERNAL);\n\t\t\t\t}\n\n\t\t\t\tprintf(\"| %-*c \", headers_crosscheck[column_node_ix + 2].max_length, c);\n\t\t\t}\n\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\tpfree(headers_crosscheck);\n\n\t\tif (warnings.head != NULL && runtime_options.terse == false)\n\t\t{\n\t\t\tlog_warning(_(\"following problems detected:\"));\n\t\t\tprint_item_list(&warnings);\n\t\t}\n\n\t}\n\n\t/* clean up allocated cube array */\n\t{\n\t\tint\t\t\th,\n\t\t\t\t\tj;\n\n\t\tfor (h = 0; h < n; h++)\n\t\t{\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (j = 0; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tfree(cube[h]->matrix_list_rec[i]->node_status_list[j]);\n\t\t\t\t}\n\t\t\t\tfree(cube[h]->matrix_list_rec[i]->node_status_list);\n\t\t\t\tfree(cube[h]->matrix_list_rec[i]);\n\t\t\t}\n\n\t\t\tfree(cube[h]->matrix_list_rec);\n\t\t\tfree(cube[h]);\n\t\t}\n\n\t\tfree(cube);\n\t}\n\n\t/* errors detected by build_cluster_crosscheck() have priority */\n\tif (connection_error_found == true)\n\t{\n\t\terror_code = ERR_NODE_STATUS;\n\t}\n\n\texit(error_code);\n\n}\n\n\n/*\n * CLUSTER MATRIX\n *\n * Parameters:\n *   --csv\n */\nvoid\ndo_cluster_matrix()\n{\n\tint\t\t\ti = 0,\n\t\t\t\tj = 0,\n\t\t\t\tn = 0;\n\n\tt_node_matrix_rec **matrix_rec_list;\n\n\tbool\t\tconnection_error_found = false;\n\tint\t\t\terror_code = SUCCESS;\n\tItemList\twarnings = {NULL, NULL};\n\n\tn = build_cluster_matrix(&matrix_rec_list, &warnings, &error_code);\n\n\tif (runtime_options.output_mode == OM_CSV)\n\t{\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tprintf(\"%d,%d,%d\\n\",\n\t\t\t\t\t   matrix_rec_list[i]->node_id,\n\t\t\t\t\t   matrix_rec_list[i]->node_status_list[j]->node_id,\n\t\t\t\t\t   matrix_rec_list[i]->node_status_list[j]->node_status);\n\n\t\t\t\tif (matrix_rec_list[i]->node_status_list[j]->node_status == -2\n\t\t\t\t\t|| matrix_rec_list[i]->node_status_list[j]->node_status == -1)\n\t\t\t\t{\n\t\t\t\t\tconnection_error_found = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* output header contains node name, node ID and one column for each node in the cluster */\n\t\tstruct ColHeader *headers_matrix = NULL;\n\n\t\tint header_count = n + 2;\n\t\tint header_id = 2;\n\n\t\theaders_matrix = palloc0(sizeof(ColHeader) * header_count);\n\n\t\t/* Initialize column headers  */\n\t\tstrncpy(headers_matrix[0].title, _(\"Name\"), MAXLEN);\n\t\tstrncpy(headers_matrix[1].title, _(\"ID\"), MAXLEN);\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tmaxlen_snprintf(headers_matrix[header_id].title, \"%i\", matrix_rec_list[i]->node_id);\n\t\t\theader_id++;\n\t\t}\n\n\t\t/* Initialize column max values */\n\t\tfor (i = 0; i < header_count; i++)\n\t\t{\n\t\t\theaders_matrix[i].display = true;\n\t\t\theaders_matrix[i].max_length = strlen(headers_matrix[i].title);\n\t\t\theaders_matrix[i].cur_length = headers_matrix[i].max_length;\n\n\t\t\t/* We can derive the maximum node ID length for the ID column from\n\t\t\t * the generated matrix node ID headers\n\t\t\t */\n\t\t\tif (i >= 2 && headers_matrix[i].max_length > headers_matrix[1].max_length)\n\t\t\t\theaders_matrix[1].max_length = headers_matrix[i].max_length;\n\t\t}\n\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tif (strlen(matrix_rec_list[i]->node_name) > headers_matrix[0].max_length)\n\t\t\t{\n\t\t\t\theaders_matrix[0].max_length = strlen(matrix_rec_list[i]->node_name);\n\t\t\t}\n\t\t}\n\n\t\tprint_status_header(header_count, headers_matrix);\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tprintf(\" %-*s | %-*i \",\n\t\t\t\t   headers_matrix[0].max_length,\n\t\t\t\t   matrix_rec_list[i]->node_name,\n\t\t\t\t   headers_matrix[1].max_length,\n\t\t\t\t   matrix_rec_list[i]->node_id);\n\t\t\tfor (j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tchar\t\tc;\n\n\t\t\t\tswitch (matrix_rec_list[i]->node_status_list[j]->node_status)\n\t\t\t\t{\n\t\t\t\t\tcase -2:\n\t\t\t\t\t\tc = '?';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tc = 'x';\n\t\t\t\t\t\tconnection_error_found = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tc = '*';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tlog_error(\"unexpected node status value %i\", matrix_rec_list[i]->node_status_list[j]->node_status);\n\t\t\t\t\t\texit(ERR_INTERNAL);\n\t\t\t\t}\n\n\t\t\t\tprintf(\"| %-*c \", headers_matrix[j + 2].max_length, c);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\tpfree(headers_matrix);\n\n\t\tif (warnings.head != NULL && runtime_options.terse == false)\n\t\t{\n\t\t\tlog_warning(_(\"following problems detected:\"));\n\t\t\tprint_item_list(&warnings);\n\t\t}\n\n\t}\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tfree(matrix_rec_list[i]->node_status_list[j]);\n\t\t}\n\t\tfree(matrix_rec_list[i]->node_status_list);\n\t\tfree(matrix_rec_list[i]);\n\t}\n\n\tfree(matrix_rec_list);\n\n\t/* actual database connection errors have priority */\n\tif (connection_error_found == true)\n\t{\n\t\terror_code = ERR_NODE_STATUS;\n\t}\n\n\texit(error_code);\n}\n\n\nstatic void\nmatrix_set_node_status(t_node_matrix_rec **matrix_rec_list, int n, int node_id, int connection_node_id, int connection_status)\n{\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tif (matrix_rec_list[i]->node_id == node_id)\n\t\t{\n\t\t\tfor (j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif (matrix_rec_list[i]->node_status_list[j]->node_id == connection_node_id)\n\t\t\t\t{\n\t\t\t\t\tmatrix_rec_list[i]->node_status_list[j]->node_status = connection_status;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nstatic int\nbuild_cluster_matrix(t_node_matrix_rec ***matrix_rec_dest, ItemList *warnings, int *error_code)\n{\n\tPGconn\t   *conn = NULL;\n\tint\t\t\ti = 0,\n\t\t\t\tj = 0;\n\tint\t\t\tlocal_node_id = UNKNOWN_NODE_ID;\n\tint\t\t\tnode_count = 0;\n\tNodeInfoList nodes = T_NODE_INFO_LIST_INITIALIZER;\n\tNodeInfoListCell *cell = NULL;\n\n\tPQExpBufferData command;\n\tPQExpBufferData command_output;\n\n\tt_node_matrix_rec **matrix_rec_list;\n\n\t/* obtain node list from the database */\n\tlog_info(_(\"connecting to database\"));\n\n\tif (strlen(config_file_options.conninfo))\n\t{\n\t\tconn = establish_db_connection(config_file_options.conninfo, true);\n\t\tlocal_node_id = config_file_options.node_id;\n\t}\n\telse\n\t{\n\t\tconn = establish_db_connection_by_params(&source_conninfo, true);\n\t\tlocal_node_id = runtime_options.node_id;\n\t}\n\n\tif (get_all_node_records(conn, &nodes) == false)\n\t{\n\t\t/* get_all_node_records() will display the error */\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tPQfinish(conn);\n\tconn = NULL;\n\n\tif (nodes.node_count == 0)\n\t{\n\t\tlog_error(_(\"unable to retrieve any node records\"));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * Allocate an empty matrix record list\n\t *\n\t * -2 == NULL  ? -1 == Error x 0 == OK\n\t */\n\n\tmatrix_rec_list = (t_node_matrix_rec **) pg_malloc0(sizeof(t_node_matrix_rec) * nodes.node_count);\n\n\ti = 0;\n\n\t/* Initialise matrix structure for each node */\n\tfor (cell = nodes.head; cell; cell = cell->next)\n\t{\n\t\tNodeInfoListCell *cell_j;\n\n\t\tmatrix_rec_list[i] = (t_node_matrix_rec *) pg_malloc0(sizeof(t_node_matrix_rec));\n\n\t\tmatrix_rec_list[i]->node_id = cell->node_info->node_id;\n\t\tstrncpy(matrix_rec_list[i]->node_name,\n\t\t\t\tcell->node_info->node_name,\n\t\t\t\tsizeof(matrix_rec_list[i]->node_name));\n\n\t\tmatrix_rec_list[i]->node_status_list = (t_node_status_rec **) pg_malloc0(sizeof(t_node_status_rec) * nodes.node_count);\n\n\t\tj = 0;\n\n\t\tfor (cell_j = nodes.head; cell_j; cell_j = cell_j->next)\n\t\t{\n\t\t\tmatrix_rec_list[i]->node_status_list[j] = (t_node_status_rec *) pg_malloc0(sizeof(t_node_status_rec));\n\t\t\tmatrix_rec_list[i]->node_status_list[j]->node_id = cell_j->node_info->node_id;\n\t\t\tmatrix_rec_list[i]->node_status_list[j]->node_status = -2;\t/* default unknown */\n\n\t\t\tj++;\n\t\t}\n\n\t\ti++;\n\t}\n\n\t/* Fetch `repmgr cluster show --csv` output for each node */\n\ti = 0;\n\n\tfor (cell = nodes.head; cell; cell = cell->next)\n\t{\n\t\tint\t\t\tconnection_status = 0;\n\t\tt_conninfo_param_list remote_conninfo = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\t\tchar\t   *host = NULL,\n\t\t\t\t   *p = NULL;\n\t\tint\t\t\tconnection_node_id = cell->node_info->node_id;\n\t\tint\t\t\tx,\n\t\t\t\t\ty;\n\t\tPGconn\t   *node_conn = NULL;\n\n\t\tinitialize_conninfo_params(&remote_conninfo, false);\n\t\tparse_conninfo_string(cell->node_info->conninfo,\n\t\t\t\t\t\t\t  &remote_conninfo,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  false);\n\n\t\thost = param_get(&remote_conninfo, \"host\");\n\n\t\tnode_conn = establish_db_connection_quiet(cell->node_info->conninfo);\n\n\t\tconnection_status =\n\t\t\t(PQstatus(node_conn) == CONNECTION_OK) ? 0 : -1;\n\n\n\t\tmatrix_set_node_status(matrix_rec_list,\n\t\t\t\t\t\t\t   nodes.node_count,\n\t\t\t\t\t\t\t   local_node_id,\n\t\t\t\t\t\t\t   connection_node_id,\n\t\t\t\t\t\t\t   connection_status);\n\n\n\t\tif (connection_status)\n\t\t{\n\t\t\tfree_conninfo_params(&remote_conninfo);\n\t\t\tPQfinish(node_conn);\n\t\t\tnode_conn = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* We don't need to issue `cluster show --csv` for the local node */\n\t\tif (connection_node_id == local_node_id)\n\t\t{\n\t\t\tfree_conninfo_params(&remote_conninfo);\n\t\t\tPQfinish(node_conn);\n\t\t\tnode_conn = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinitPQExpBuffer(&command);\n\n\t\t/*\n\t\t * We'll pass cluster name and database connection string to the\n\t\t * remote repmgr - those are the only values it needs to work, and\n\t\t * saves us making assumptions about the location of repmgr.conf\n\t\t */\n\t\tappendPQExpBufferChar(&command, '\"');\n\n\t\tmake_remote_repmgr_path(&command, cell->node_info);\n\n\t\tappendPQExpBufferStr(&command,\n\t\t\t\t\t\t\t \" cluster show --csv --terse\");\n\n\t\t/*\n\t\t * Usually we'll want NOTICE as the log level, but if the user\n\t\t * explicitly provided one with --log-level, that will be passed\n\t\t * in the remote repmgr invocation.\n\t\t */\n\t\tif (runtime_options.log_level[0] == '\\0')\n\t\t{\n\t\t\tappendPQExpBufferStr(&command,\n\t\t\t\t\t\t\t\t \" -L NOTICE\");\n\t\t}\n\t\tappendPQExpBufferChar(&command, '\"');\n\n\t\tlog_verbose(LOG_DEBUG, \"build_cluster_matrix(): executing:\\n  %s\", command.data);\n\n\t\tinitPQExpBuffer(&command_output);\n\n\t\t(void) remote_command(host,\n\t\t\t\t\t\t\t  runtime_options.remote_user,\n\t\t\t\t\t\t\t  command.data,\n\t\t\t\t\t\t\t  config_file_options.ssh_options,\n\t\t\t\t\t\t\t  &command_output);\n\n\t\tp = command_output.data;\n\n\t\ttermPQExpBuffer(&command);\n\n\t\t/* no output returned - probably SSH error */\n\t\tif (p[0] == '\\0' || p[0] == '\\n')\n\t\t{\n\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\"node %i inaccessible via SSH\",\n\t\t\t\t\t\t\t\t\tconnection_node_id);\n\t\t\t*error_code = ERR_BAD_SSH;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (j = 0; j < nodes.node_count; j++)\n\t\t\t{\n\t\t\t\tif (sscanf(p, \"%d,%d\", &x, &y) != 2)\n\t\t\t\t{\n\t\t\t\t\tmatrix_set_node_status(matrix_rec_list,\n\t\t\t\t\t\t\t\t\t\t   nodes.node_count,\n\t\t\t\t\t\t\t\t\t\t   connection_node_id,\n\t\t\t\t\t\t\t\t\t\t   x,\n\t\t\t\t\t\t\t\t\t\t   -2);\n\n\t\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\t\"unable to parse --csv output for node %i; output returned was:\\n\\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\t\tconnection_node_id, p);\n\t\t\t\t\t*error_code = ERR_INTERNAL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmatrix_set_node_status(matrix_rec_list,\n\t\t\t\t\t\t\t\t\t\t   nodes.node_count,\n\t\t\t\t\t\t\t\t\t\t   connection_node_id,\n\t\t\t\t\t\t\t\t\t\t   x,\n\t\t\t\t\t\t\t\t\t\t   (y == -1) ? -1 : 0);\n\t\t\t\t}\n\n\t\t\t\twhile (*p && (*p != '\\n'))\n\t\t\t\t\tp++;\n\t\t\t\tif (*p == '\\n')\n\t\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\ttermPQExpBuffer(&command_output);\n\t\tPQfinish(node_conn);\n\t\tfree_conninfo_params(&remote_conninfo);\n\t}\n\n\t*matrix_rec_dest = matrix_rec_list;\n\n\tnode_count = nodes.node_count;\n\tclear_node_info_list(&nodes);\n\n\treturn node_count;\n}\n\n\nstatic int\nbuild_cluster_crosscheck(t_node_status_cube ***dest_cube, ItemList *warnings, int *error_code)\n{\n\tPGconn\t   *conn = NULL;\n\tint\t\t\th,\n\t\t\t\ti,\n\t\t\t\tj;\n\tNodeInfoList nodes = T_NODE_INFO_LIST_INITIALIZER;\n\tNodeInfoListCell *cell = NULL;\n\n\tt_node_status_cube **cube;\n\n\tint\t\t\tnode_count = 0;\n\n\t/* We need to connect to get the list of nodes */\n\tlog_info(_(\"connecting to database\"));\n\n\tif (strlen(config_file_options.conninfo))\n\t\tconn = establish_db_connection(config_file_options.conninfo, true);\n\telse\n\t\tconn = establish_db_connection_by_params(&source_conninfo, true);\n\n\tif (get_all_node_records(conn, &nodes) == false)\n\t{\n\t\t/* get_all_node_records() will display the error */\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tPQfinish(conn);\n\tconn = NULL;\n\n\tif (nodes.node_count == 0)\n\t{\n\t\tlog_error(_(\"unable to retrieve any node records\"));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * Allocate an empty cube matrix structure\n\t *\n\t * -2 == NULL -1 == Error 0 == OK\n\t */\n\n\tcube = (t_node_status_cube **) pg_malloc(sizeof(t_node_status_cube *) * nodes.node_count);\n\n\th = 0;\n\n\tfor (cell = nodes.head; cell; cell = cell->next)\n\t{\n\t\tNodeInfoListCell *cell_i = NULL;\n\n\t\tcube[h] = (t_node_status_cube *) pg_malloc(sizeof(t_node_status_cube));\n\t\tcube[h]->node_id = cell->node_info->node_id;\n\t\tstrncpy(cube[h]->node_name, cell->node_info->node_name, sizeof(cube[h]->node_name));\n\n\t\tcube[h]->matrix_list_rec = (t_node_matrix_rec **) pg_malloc(sizeof(t_node_matrix_rec) * nodes.node_count);\n\n\t\ti = 0;\n\t\tfor (cell_i = nodes.head; cell_i; cell_i = cell_i->next)\n\t\t{\n\t\t\tNodeInfoListCell *cell_j;\n\n\t\t\tcube[h]->matrix_list_rec[i] = (t_node_matrix_rec *) pg_malloc0(sizeof(t_node_matrix_rec));\n\t\t\tcube[h]->matrix_list_rec[i]->node_id = cell_i->node_info->node_id;\n\n\t\t\t/* we don't need the name here */\n\t\t\tcube[h]->matrix_list_rec[i]->node_name[0] = '\\0';\n\n\t\t\tcube[h]->matrix_list_rec[i]->node_status_list = (t_node_status_rec **) pg_malloc0(sizeof(t_node_status_rec *) * nodes.node_count);\n\n\t\t\tj = 0;\n\n\t\t\tfor (cell_j = nodes.head; cell_j; cell_j = cell_j->next)\n\t\t\t{\n\t\t\t\tcube[h]->matrix_list_rec[i]->node_status_list[j] = (t_node_status_rec *) pg_malloc0(sizeof(t_node_status_rec));\n\t\t\t\tcube[h]->matrix_list_rec[i]->node_status_list[j]->node_id = cell_j->node_info->node_id;\n\t\t\t\tcube[h]->matrix_list_rec[i]->node_status_list[j]->node_status = -2; /* default unknown */\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\th++;\n\t}\n\n\n\t/*\n\t * Build the connection cube\n\t */\n\ti = 0;\n\n\tfor (cell = nodes.head; cell; cell = cell->next)\n\t{\n\t\tint\t\t\tremote_node_id = UNKNOWN_NODE_ID;\n\t\tPQExpBufferData command;\n\t\tPQExpBufferData command_output;\n\n\t\tchar\t   *p = NULL;\n\n\t\tremote_node_id = cell->node_info->node_id;\n\n\t\tinitPQExpBuffer(&command);\n\n\t\tmake_remote_repmgr_path(&command, cell->node_info);\n\n\t\tappendPQExpBufferStr(&command,\n\t\t\t\t\t\t\t \" cluster matrix --csv --terse\");\n\n\t\t/*\n\t\t * Usually we'll want NOTICE as the log level, but if the user\n\t\t * explicitly provided one with --log-level, that will be passed\n\t\t * in the remote repmgr invocation.\n\t\t */\n\t\tif (runtime_options.log_level[0] == '\\0')\n\t\t{\n\t\t\tappendPQExpBufferStr(&command,\n\t\t\t\t\t\t\t\t \" -L NOTICE\");\n\t\t}\n\n\t\tinitPQExpBuffer(&command_output);\n\n\t\tif (cube[i]->node_id == config_file_options.node_id)\n\t\t{\n\t\t\t(void) local_command_simple(command.data,\n\t\t\t\t\t\t\t\t\t\t&command_output);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt_conninfo_param_list remote_conninfo = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\t\t\tchar\t   *host = NULL;\n\t\t\tPQExpBufferData quoted_command;\n\n\t\t\tinitPQExpBuffer(&quoted_command);\n\t\t\tappendPQExpBuffer(&quoted_command,\n\t\t\t\t\t\t\t  \"\\\"%s\\\"\",\n\t\t\t\t\t\t\t  command.data);\n\n\t\t\tinitialize_conninfo_params(&remote_conninfo, false);\n\n\t\t\tparse_conninfo_string(cell->node_info->conninfo,\n\t\t\t\t\t\t\t\t  &remote_conninfo,\n\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t  false);\n\n\t\t\thost = param_get(&remote_conninfo, \"host\");\n\n\t\t\tlog_verbose(LOG_DEBUG, \"build_cluster_crosscheck(): executing\\n  %s\", quoted_command.data);\n\n\t\t\t(void) remote_command(host,\n\t\t\t\t\t\t\t\t  runtime_options.remote_user,\n\t\t\t\t\t\t\t\t  quoted_command.data,\n\t\t\t\t\t\t\t\t  config_file_options.ssh_options,\n\t\t\t\t\t\t\t\t  &command_output);\n\n\t\t\tfree_conninfo_params(&remote_conninfo);\n\t\t\ttermPQExpBuffer(&quoted_command);\n\t\t}\n\n\t\ttermPQExpBuffer(&command);\n\n\t\tp = command_output.data;\n\n\t\tif (p[0] == '\\0' || p[0] == '\\n')\n\t\t{\n\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\"node %i inaccessible via SSH\",\n\t\t\t\t\t\t\t\t\tremote_node_id);\n\t\t\ttermPQExpBuffer(&command_output);\n\t\t\t*error_code = ERR_BAD_SSH;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < (nodes.node_count * nodes.node_count); j++)\n\t\t{\n\t\t\tint\t\t\tmatrix_rec_node_id;\n\t\t\tint\t\t\tnode_status_node_id;\n\t\t\tint\t\t\tnode_status;\n\n\t\t\tif (sscanf(p, \"%d,%d,%d\", &matrix_rec_node_id, &node_status_node_id, &node_status) != 3)\n\t\t\t{\n\t\t\t\tcube_set_node_status(cube,\n\t\t\t\t\t\t\t\t\t nodes.node_count,\n\t\t\t\t\t\t\t\t\t remote_node_id,\n\t\t\t\t\t\t\t\t\t matrix_rec_node_id,\n\t\t\t\t\t\t\t\t\t node_status_node_id,\n\t\t\t\t\t\t\t\t\t -2);\n\t\t\t\t*error_code = ERR_INTERNAL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcube_set_node_status(cube,\n\t\t\t\t\t\t\t\t\t nodes.node_count,\n\t\t\t\t\t\t\t\t\t remote_node_id,\n\t\t\t\t\t\t\t\t\t matrix_rec_node_id,\n\t\t\t\t\t\t\t\t\t node_status_node_id,\n\t\t\t\t\t\t\t\t\t node_status);\n\t\t\t}\n\n\t\t\twhile (*p && (*p != '\\n'))\n\t\t\t\tp++;\n\t\t\tif (*p == '\\n')\n\t\t\t\tp++;\n\t\t}\n\t\ttermPQExpBuffer(&command_output);\n\n\t\ti++;\n\t}\n\n\t*dest_cube = cube;\n\n\tnode_count = nodes.node_count;\n\n\tclear_node_info_list(&nodes);\n\n\treturn node_count;\n}\n\n\nstatic void\ncube_set_node_status(t_node_status_cube **cube, int n, int execute_node_id, int matrix_node_id, int connection_node_id, int connection_status)\n{\n\tint\t\t\th,\n\t\t\t\ti,\n\t\t\t\tj;\n\n\n\tfor (h = 0; h < n; h++)\n\t{\n\t\tif (cube[h]->node_id == execute_node_id)\n\t\t{\n\t\t\tfor (i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tif (cube[h]->matrix_list_rec[i]->node_id == matrix_node_id)\n\t\t\t\t{\n\t\t\t\t\tfor (j = 0; j < n; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (cube[h]->matrix_list_rec[i]->node_status_list[j]->node_id == connection_node_id)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcube[h]->matrix_list_rec[i]->node_status_list[j]->node_status = connection_status;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid\ndo_cluster_cleanup(void)\n{\n\tPGconn\t   *conn = NULL;\n\tPGconn\t   *primary_conn = NULL;\n\tint\t\t\tentries_to_delete = 0;\n\tPQExpBufferData event_details;\n\n\tconn = establish_db_connection(config_file_options.conninfo, true);\n\n\t/* check if there is a primary in this cluster */\n\tlog_info(_(\"connecting to primary server\"));\n\tprimary_conn = establish_primary_db_connection(conn, true);\n\n\tPQfinish(conn);\n\n\tlog_debug(_(\"number of days of monitoring history to retain: %i\"), runtime_options.keep_history);\n\n\tentries_to_delete = get_number_of_monitoring_records_to_delete(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   runtime_options.keep_history,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   runtime_options.node_id);\n\n\tif (entries_to_delete < 0)\n\t{\n\t\tlog_error(_(\"unable to query number of monitoring records to clean up\"));\n\t\tPQfinish(primary_conn);\n\t\texit(ERR_DB_QUERY);\n\t}\n\telse if (entries_to_delete == 0)\n\t{\n\t\tlog_info(_(\"no monitoring records to delete\"));\n\t\tPQfinish(primary_conn);\n\t\treturn;\n\t}\n\n\tlog_debug(\"at least %i monitoring records for deletion\",\n\t\t\t  entries_to_delete);\n\n\tinitPQExpBuffer(&event_details);\n\n\tif (delete_monitoring_records(primary_conn, runtime_options.keep_history, runtime_options.node_id) == false)\n\t{\n\t\tappendPQExpBufferStr(&event_details,\n\t\t\t\t\t\t  _(\"unable to delete monitoring records\"));\n\n\t\tlog_error(\"%s\", event_details.data);\n\t\tlog_detail(\"%s\", PQerrorMessage(primary_conn));\n\n\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t  \"cluster_cleanup\",\n\t\t\t\t\t\t\t\t  false,\n\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\tPQfinish(primary_conn);\n\t\texit(ERR_DB_QUERY);\n\t}\n\n\tif (vacuum_table(primary_conn, \"repmgr.monitoring_history\") == false)\n\t{\n\t\t/* annoying if this fails, but not fatal */\n\t\tlog_warning(_(\"unable to vacuum table \\\"repmgr.monitoring_history\\\"\"));\n\t\tlog_detail(\"%s\", PQerrorMessage(primary_conn));\n\t}\n\telse\n\t{\n\t\tlog_info(_(\"vacuum of table \\\"repmgr.monitoring_history\\\" completed\"));\n\t}\n\n\tif (runtime_options.keep_history == 0)\n\t{\n\t\tappendPQExpBufferStr(&event_details,\n\t\t\t\t\t\t  _(\"all monitoring records deleted\"));\n\t}\n\telse\n\t{\n\t\tappendPQExpBufferStr(&event_details,\n\t\t\t\t\t\t  _(\"monitoring records deleted\"));\n\t}\n\n\tif (runtime_options.node_id != UNKNOWN_NODE_ID)\n\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t  _(\" for node %i\"),\n\t\t\t\t\t\t  runtime_options.node_id);\n\n\tif (runtime_options.keep_history > 0)\n\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t  _(\"; records newer than %i day(s) retained\"),\n\t\t\t\t\t\t  runtime_options.keep_history);\n\n\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t  \"cluster_cleanup\",\n\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t  event_details.data);\n\n\tlog_notice(\"%s\", event_details.data);\n\n\ttermPQExpBuffer(&event_details);\n\tPQfinish(primary_conn);\n\n\n\treturn;\n}\n\n\nvoid\ndo_cluster_help(void)\n{\n\tprint_help_header();\n\n\tprintf(_(\"Usage:\\n\"));\n\tprintf(_(\"    %s [OPTIONS] cluster show\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] cluster matrix\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] cluster crosscheck\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] cluster event\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] cluster cleanup\\n\"), progname());\n\tputs(\"\");\n\n\tprintf(_(\"CLUSTER SHOW\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"cluster show\\\" displays a list showing the status of each node in the cluster.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  Configuration file or database connection required.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"    --csv                     emit output as CSV (with a subset of fields)\\n\"));\n\tprintf(_(\"    --compact                 display only a subset of fields\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"CLUSTER MATRIX\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"cluster matrix\\\" displays a matrix showing connectivity between nodes, seen from this node.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  Configuration file or database connection required.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"    --csv                     emit output as CSV\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"CLUSTER CROSSCHECK\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"cluster crosscheck\\\" displays a matrix showing connectivity between nodes, seen from all nodes.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  Configuration file or database connection required.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"    --csv                     emit output as CSV\\n\"));\n\tputs(\"\");\n\n\n\tprintf(_(\"CLUSTER EVENT\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"cluster event\\\" lists recent events logged in the \\\"repmgr.events\\\" table.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"    --limit                   maximum number of events to display (default: %i)\\n\"), CLUSTER_EVENT_LIMIT);\n\tprintf(_(\"    --all                     display all events (overrides --limit)\\n\"));\n\tprintf(_(\"    --event                   filter specific event\\n\"));\n\tprintf(_(\"    --node-id                 restrict entries to node with this ID\\n\"));\n\tprintf(_(\"    --node-name               restrict entries to node with this name\\n\"));\n\tprintf(_(\"    --compact                 omit \\\"Details\\\" column\"));\n\tprintf(_(\"    --csv                     emit output as CSV\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"CLUSTER CLEANUP\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"cluster cleanup\\\" purges records from the \\\"repmgr.monitoring_history\\\" table.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"    -k, --keep-history=VALUE  retain indicated number of days of history (default: 0)\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"%s home page: <%s>\\n\"), \"repmgr\", REPMGR_URL);\n}\n"
        },
        {
          "name": "repmgr-action-cluster.h",
          "type": "blob",
          "size": 1.333984375,
          "content": "/*\n * repmgr-action-cluster.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _REPMGR_ACTION_CLUSTER_H_\n#define _REPMGR_ACTION_CLUSTER_H_\n\n\n\ntypedef struct\n{\n\tint\t\t\tnode_id;\n\tint\t\t\tnode_status;\n} t_node_status_rec;\n\ntypedef struct\n{\n\tint\t\t\tnode_id;\n\tchar\t\tnode_name[NAMEDATALEN];\n\tt_node_status_rec **node_status_list;\n} t_node_matrix_rec;\n\ntypedef struct\n{\n\tint\t\t\tnode_id;\n\tchar\t\tnode_name[NAMEDATALEN];\n\tt_node_matrix_rec **matrix_list_rec;\n} t_node_status_cube;\n\n\n\nextern void do_cluster_show(void);\nextern void do_cluster_event(void);\nextern void do_cluster_crosscheck(void);\nextern void do_cluster_matrix(void);\nextern void do_cluster_cleanup(void);\n\nextern void do_cluster_help(void);\n\n#endif\n"
        },
        {
          "name": "repmgr-action-daemon.c",
          "type": "blob",
          "size": 8.6748046875,
          "content": "/*\n * repmgr-action-daemon.c\n *\n * Implements repmgrd actions for the repmgr command line utility\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <signal.h>\n#include <sys/stat.h>\t\t\t/* for stat() */\n\n#include \"repmgr.h\"\n\n#include \"repmgr-client-global.h\"\n#include \"repmgr-action-daemon.h\"\n\n#define REPMGR_SERVICE_STOP_START_WAIT 15\n#define REPMGR_SERVICE_STATUS_START_HINT _(\"use \\\"repmgr service status\\\" to confirm that repmgrd was successfully started\")\n#define REPMGR_SERVICE_STATUS_STOP_HINT _(\"use \\\"repmgr service status\\\" to confirm that repmgrd was successfully stopped\")\n\nvoid\ndo_daemon_start(void)\n{\n\tPGconn\t   *conn = NULL;\n\tPQExpBufferData repmgrd_command;\n\tPQExpBufferData output_buf;\n\tbool\t\tsuccess;\n\n\tif (config_file_options.repmgrd_service_start_command[0] == '\\0')\n\t{\n\t\tlog_error(_(\"\\\"repmgrd_service_start_command\\\" is not set\"));\n\t\tlog_hint(_(\"set \\\"repmgrd_service_start_command\\\" in \\\"repmgr.conf\\\"\"));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tlog_verbose(LOG_INFO, _(\"connecting to local node\"));\n\n\tconn = establish_db_connection(config_file_options.conninfo, false);\n\n\tif (PQstatus(conn) != CONNECTION_OK)\n\t{\n\t\t/* TODO: if PostgreSQL is not available, have repmgrd loop and retry connection */\n\t\tlog_error(_(\"unable to connect to local node\"));\n\t\tlog_detail(_(\"PostgreSQL must be running before \\\"repmgrd\\\" can be started\"));\n\t\texit(ERR_DB_CONN);\n\t}\n\n\t/*\n\t * if local connection available, check if repmgr.so is installed, and\n\t * whether repmgrd is running\n\t */\n\tcheck_shared_library(conn);\n\n\tif (is_repmgrd_running(conn) == true)\n\t{\n\t\tpid_t\t\tpid = UNKNOWN_PID;\n\n\t\tlog_error(_(\"repmgrd appears to be running already\"));\n\n\t\tpid = repmgrd_get_pid(conn);\n\n\t\tif (pid != UNKNOWN_PID)\n\t\t\tlog_detail(_(\"repmgrd PID is %i\"), pid);\n\t\telse\n\t\t\tlog_warning(_(\"unable to determine repmgrd PID\"));\n\n\t\tPQfinish(conn);\n\t\texit(ERR_REPMGRD_SERVICE);\n\t}\n\n\tPQfinish(conn);\n\n\n\tinitPQExpBuffer(&repmgrd_command);\n\tappendPQExpBufferStr(&repmgrd_command,\n\t\t\t\t\t\t config_file_options.repmgrd_service_start_command);\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"prerequisites for starting repmgrd met\"));\n\t\tlog_detail(\"following command would be executed:\\n  %s\", repmgrd_command.data);\n\t\texit(SUCCESS);\n\t}\n\n\tlog_notice(_(\"executing: \\\"%s\\\"\"), repmgrd_command.data);\n\n\tinitPQExpBuffer(&output_buf);\n\n\tsuccess = local_command(repmgrd_command.data, &output_buf);\n\ttermPQExpBuffer(&repmgrd_command);\n\n\tif (success == false)\n\t{\n\t\tlog_error(_(\"unable to start repmgrd\"));\n\t\tif (output_buf.data[0] != '\\0')\n\t\t\tlog_detail(\"%s\", output_buf.data);\n\t\ttermPQExpBuffer(&output_buf);\n\t\texit(ERR_REPMGRD_SERVICE);\n\t}\n\n\ttermPQExpBuffer(&output_buf);\n\n\tif (runtime_options.no_wait == true || runtime_options.wait == 0)\n\t{\n\t\tlog_hint(REPMGR_SERVICE_STATUS_START_HINT);\n\t}\n\telse\n\t{\n\t\tint i = 0;\n\t\tint timeout = REPMGR_SERVICE_STOP_START_WAIT;\n\n\t\tif (runtime_options.wait_provided)\n\t\t\ttimeout = runtime_options.wait;\n\n\t\tconn = establish_db_connection(config_file_options.conninfo, false);\n\n\t\tif (PQstatus(conn) != CONNECTION_OK)\n\t\t{\n\t\t\tlog_notice(_(\"unable to connect to local node\"));\n\t\t\tlog_hint(REPMGR_SERVICE_STATUS_START_HINT);\n\t\t\texit(ERR_DB_CONN);\n\t\t}\n\n\t\tfor (;;)\n\t\t{\n\t\t\tif (is_repmgrd_running(conn) == true)\n\t\t\t{\n\t\t\t\tlog_notice(_(\"repmgrd was successfully started\"));\n\t\t\t\tPQfinish(conn);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == timeout)\n\t\t\t{\n\t\t\t\tPQfinish(conn);\n\t\t\t\tlog_error(_(\"repmgrd does not appear to have started after %i seconds\"),\n\t\t\t\t\t\t  timeout);\n\t\t\t\tlog_hint(REPMGR_SERVICE_STATUS_START_HINT);\n\t\t\t\texit(ERR_REPMGRD_SERVICE);\n\t\t\t}\n\n\t\t\tlog_debug(\"sleeping 1 second; %i of %i attempts to determine if repmgrd is running\",\n\t\t\t\t\t  i, runtime_options.wait);\n\t\t\tsleep(1);\n\t\t\ti++;\n\t\t}\n\t}\n}\n\n\nvoid do_daemon_stop(void)\n{\n\tPGconn\t   *conn = NULL;\n\tPQExpBufferData repmgrd_command;\n\tPQExpBufferData output_buf;\n\tbool\t\tsuccess;\n\tbool\t\thave_db_connection = true;\n\tpid_t\t\tpid = UNKNOWN_PID;\n\n\tif (config_file_options.repmgrd_service_stop_command[0] == '\\0')\n\t{\n\t\tlog_error(_(\"\\\"repmgrd_service_stop_command\\\" is not set\"));\n\t\tlog_hint(_(\"set \\\"repmgrd_service_stop_command\\\" in \\\"repmgr.conf\\\"\"));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * if local connection available, check if repmgr.so is installed, and\n\t * whether repmgrd is running\n\t */\n\tlog_verbose(LOG_INFO, _(\"connecting to local node\"));\n\n\tconn = establish_db_connection(config_file_options.conninfo, false);\n\n\tif (PQstatus(conn) != CONNECTION_OK)\n\t{\n\t\t/*\n\t\t * a PostgreSQL connection is not required to stop repmgrd,\n\t\t */\n\t\tlog_warning(_(\"unable to connect to local node\"));\n\t\thave_db_connection = false;\n\t}\n\telse\n\t{\n\t\tcheck_shared_library(conn);\n\n\t\tif (is_repmgrd_running(conn) == false)\n \t\t{\n\t\t\tlog_error(_(\"repmgrd appears to be stopped already\"));\n\t\t\tPQfinish(conn);\n\t\t\texit(ERR_REPMGRD_SERVICE);\n\t\t}\n\n\t\t/* Attempt to fetch the PID, in case we need it later */\n\t\tpid = repmgrd_get_pid(conn);\n\t\tlog_debug(\"retrieved pid is %i\", pid);\n\t}\n\n\tPQfinish(conn);\n\n\tinitPQExpBuffer(&repmgrd_command);\n\n\tappendPQExpBufferStr(&repmgrd_command,\n\t\t\t\t\t\t config_file_options.repmgrd_service_stop_command);\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"prerequisites for stopping repmgrd met\"));\n\t\tlog_detail(\"following command would be executed:\\n  %s\", repmgrd_command.data);\n\t\texit(SUCCESS);\n\t}\n\n\tlog_notice(_(\"executing: \\\"%s\\\"\"), repmgrd_command.data);\n\n\tinitPQExpBuffer(&output_buf);\n\n\tsuccess = local_command(repmgrd_command.data, &output_buf);\n\ttermPQExpBuffer(&repmgrd_command);\n\n\tif (success == false)\n\t{\n\t\tlog_error(_(\"unable to stop repmgrd\"));\n\t\tif (output_buf.data[0] != '\\0')\n\t\t\tlog_detail(\"%s\", output_buf.data);\n\t\ttermPQExpBuffer(&output_buf);\n\t\texit(ERR_REPMGRD_SERVICE);\n\t}\n\n\ttermPQExpBuffer(&output_buf);\n\n\tif (runtime_options.no_wait == true || runtime_options.wait == 0)\n\t{\n\t\tif (have_db_connection == true)\n\t\t\tlog_hint(REPMGR_SERVICE_STATUS_STOP_HINT);\n\t}\n\telse\n\t{\n\t\tint i = 0;\n\t\tint timeout = REPMGR_SERVICE_STOP_START_WAIT;\n\t\t/*\n\t\t *\n\t\t */\n\t\tif (pid == UNKNOWN_PID)\n\t\t{\n\t\t\t/*\n\t\t\t * XXX attempt to get pidfile from config\n\t\t\t *   and get contents\n\t\t\t *   ( see check_and_create_pid_file() )\n\t\t\t * if PID still unknown, exit here\n\t\t\t */\n\t\t\tlog_warning(_(\"unable to determine repmgrd PID\"));\n\n\t\t\tif (have_db_connection == true)\n\t\t\t\tlog_hint(REPMGR_SERVICE_STATUS_STOP_HINT);\n\n\t\t\texit(ERR_REPMGRD_SERVICE);\n\t\t}\n\n\t\tif (runtime_options.wait_provided)\n\t\t\ttimeout = runtime_options.wait;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tif (kill(pid, 0) == -1)\n\t\t\t{\n\t\t\t\tif (errno == ESRCH)\n\t\t\t\t{\n\t\t\t\t\tlog_notice(_(\"repmgrd was successfully stopped\"));\n\t\t\t\t\texit(SUCCESS);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to determine status of process with PID %i\"), pid);\n\t\t\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\t\t\texit(ERR_REPMGRD_SERVICE);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (i == timeout)\n\t\t\t{\n\t\t\t\tlog_error(_(\"repmgrd does not appear to have stopped after %i seconds\"),\n\t\t\t\t\t\t  timeout);\n\n\t\t\t\tif (have_db_connection == true)\n\t\t\t\t\tlog_hint(REPMGR_SERVICE_STATUS_START_HINT);\n\n\t\t\t\texit(ERR_REPMGRD_SERVICE);\n\t\t\t}\n\n\t\t\tlog_debug(\"sleeping 1 second; %i of %i attempts to determine if repmgrd with PID %i is running\",\n\t\t\t\t\t  i, timeout, pid);\n\t\t\tsleep(1);\n\t\t\ti++;\n\t\t}\n\t}\n}\n\n\nvoid do_daemon_help(void)\n{\n\tprint_help_header();\n\n\tprintf(_(\"Usage:\\n\"));\n\tprintf(_(\"    %s [OPTIONS] daemon start\\n\"),   progname());\n\tprintf(_(\"    %s [OPTIONS] daemon stop\\n\"),    progname());\n\n\tputs(\"\");\n\n\tprintf(_(\"DAEMON START\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"daemon start\\\" attempts to start repmgrd on the local node\\n\"));\n\tputs(\"\");\n\tprintf(_(\"    --dry-run               check prerequisites but don't start repmgrd\\n\"));\n\tprintf(_(\"    -w/--wait               wait for repmgrd to start (default: %i seconds)\\n\"), REPMGR_SERVICE_STOP_START_WAIT);\n\tprintf(_(\"    --no-wait               don't wait for repmgrd to start\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"DAEMON STOP\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"daemon stop\\\" attempts to stop repmgrd on the local node\\n\"));\n\tputs(\"\");\n\tprintf(_(\"    --dry-run               check prerequisites but don't stop repmgrd\\n\"));\n\tprintf(_(\"    -w/--wait               wait for repmgrd to stop (default: %i seconds)\\n\"), REPMGR_SERVICE_STOP_START_WAIT);\n\tprintf(_(\"    --no-wait               don't wait for repmgrd to stop\\n\"));\n\tputs(\"\");\n\n\tputs(\"\");\n\n\tprintf(_(\"%s home page: <%s>\\n\"), \"repmgr\", REPMGR_URL);\n}\n"
        },
        {
          "name": "repmgr-action-daemon.h",
          "type": "blob",
          "size": 0.892578125,
          "content": "/*\n * repmgr-action-daemon.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _REPMGR_ACTION_DAEMON_H_\n#define _REPMGR_ACTION_DAEMON_H_\n\nextern void do_daemon_start(void);\nextern void do_daemon_stop(void);\n\nextern void do_daemon_help(void);\n#endif\n"
        },
        {
          "name": "repmgr-action-node.c",
          "type": "blob",
          "size": 90.60546875,
          "content": "/*\n * repmgr-action-node.c\n *\n * Implements actions available for any kind of node\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <sys/stat.h>\n#include <dirent.h>\n\n#include \"repmgr.h\"\n#include \"controldata.h\"\n#include \"dirutil.h\"\n#include \"dbutils.h\"\n#include \"compat.h\"\n\n#include \"repmgr-client-global.h\"\n#include \"repmgr-action-node.h\"\n#include \"repmgr-action-standby.h\"\n\nstatic bool copy_file(const char *src_file, const char *dest_file);\nstatic void format_archive_dir(PQExpBufferData *archive_dir);\nstatic t_server_action parse_server_action(const char *action);\nstatic const char *output_repmgrd_status(CheckStatus status);\n\nstatic void exit_optformat_error(const char *error, int errcode);\n\nstatic void _do_node_service_list_actions(t_server_action action);\nstatic void _do_node_status_is_shutdown_cleanly(void);\nstatic void _do_node_archive_config(void);\nstatic void _do_node_restore_config(void);\n\nstatic void do_node_check_replication_connection(void);\nstatic CheckStatus do_node_check_archive_ready(PGconn *conn, OutputMode mode, CheckStatusList *list_output);\nstatic CheckStatus do_node_check_downstream(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output);\nstatic CheckStatus do_node_check_upstream(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output);\nstatic CheckStatus do_node_check_replication_lag(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output);\nstatic CheckStatus do_node_check_role(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output);\nstatic CheckStatus do_node_check_slots(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output);\nstatic CheckStatus do_node_check_missing_slots(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output);\nstatic CheckStatus do_node_check_data_directory(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output);\nstatic CheckStatus do_node_check_repmgrd(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output);\nstatic CheckStatus do_node_check_replication_config_owner(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output);\nstatic CheckStatus do_node_check_db_connection(PGconn *conn, OutputMode mode);\n\n\n/*\n * NODE STATUS\n *\n * Can only be run on the local node, as it needs to be able to\n * read the data directory.\n *\n * Parameters:\n *   --is-shutdown-cleanly (for internal use only)\n *   --csv\n */\n\nvoid\ndo_node_status(void)\n{\n\tPGconn\t   *conn = NULL;\n\n\tt_node_info node_info = T_NODE_INFO_INITIALIZER;\n\tchar\t\tcluster_size[MAXLEN];\n\tPQExpBufferData output;\n\n\tKeyValueList node_status = {NULL, NULL};\n\tKeyValueListCell *cell = NULL;\n\tNodeInfoList missing_slots = T_NODE_INFO_LIST_INITIALIZER;\n\n\tItemList\twarnings = {NULL, NULL};\n\tRecoveryType recovery_type = RECTYPE_UNKNOWN;\n\tReplInfo\treplication_info;\n\tt_recovery_conf recovery_conf = T_RECOVERY_CONF_INITIALIZER;\n\n\tchar\t\tdata_dir[MAXPGPATH] = \"\";\n\tchar\t\tserver_version_str[MAXVERSIONSTR] = \"\";\n\n\t/*\n\t * A database connection is *not* required for this check\n\t */\n\tif (runtime_options.is_shutdown_cleanly == true)\n\t{\n\t\treturn _do_node_status_is_shutdown_cleanly();\n\t}\n\n\tinit_replication_info(&replication_info);\n\n\n\t/* config file required, so we should have \"conninfo\" and \"data_directory\" */\n\tconn = establish_db_connection(config_file_options.conninfo, true);\n\tstrncpy(data_dir, config_file_options.data_directory, MAXPGPATH);\n\n\t(void)get_server_version(conn, server_version_str);\n\n\t/* check node exists  */\n\n\tif (get_node_record_with_upstream(conn, config_file_options.node_id, &node_info) != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"no record found for node %i\"), config_file_options.node_id);\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tif (get_cluster_size(conn, cluster_size) == false)\n\t\tstrncpy(cluster_size, _(\"unknown\"), MAXLEN);\n\n\trecovery_type = get_recovery_type(conn);\n\n\tget_node_replication_stats(conn, &node_info);\n\n\tkey_value_list_set(&node_status,\n\t\t\t\t\t   \"PostgreSQL version\",\n\t\t\t\t\t   server_version_str);\n\n\tkey_value_list_set(&node_status,\n\t\t\t\t\t   \"Total data size\",\n\t\t\t\t\t   cluster_size);\n\n\tkey_value_list_set(&node_status,\n\t\t\t\t\t   \"Conninfo\",\n\t\t\t\t\t   node_info.conninfo);\n\n\tif (runtime_options.verbose == true)\n\t{\n\t\tuint64\t\tlocal_system_identifier = get_system_identifier(config_file_options.data_directory);\n\n\t\tif (local_system_identifier == UNKNOWN_SYSTEM_IDENTIFIER)\n\t\t{\n\t\t\tkey_value_list_set(&node_status,\n\t\t\t\t\t\t\t   \"System identifier\",\n\t\t\t\t\t\t\t   \"unknown\");\n\t\t\titem_list_append_format(&warnings,\n\t\t\t\t\t\t\t\t\t_(\"unable to retrieve system identifier from pg_control\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tkey_value_list_set_format(&node_status,\n\t\t\t\t\t\t\t\t\t  \"System identifier\",\n\t\t\t\t\t\t\t\t\t  \"%lu\", local_system_identifier);\n\t\t}\n\t}\n\n\tkey_value_list_set(&node_status,\n\t\t\t\t\t   \"Role\",\n\t\t\t\t\t   get_node_type_string(node_info.type));\n\n\tswitch (node_info.type)\n\t{\n\t\tcase PRIMARY:\n\t\t\tif (recovery_type == RECTYPE_STANDBY)\n\t\t\t{\n\t\t\t\titem_list_append(&warnings,\n\t\t\t\t\t\t\t\t _(\"- node is registered as primary but running as standby\"));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STANDBY:\n\t\t\tif (recovery_type == RECTYPE_PRIMARY)\n\t\t\t{\n\t\t\t\titem_list_append(&warnings,\n\t\t\t\t\t\t\t\t _(\"- node is registered as standby but running as primary\"));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tif (guc_set(conn, \"archive_mode\", \"=\", \"off\"))\n\t{\n\t\tkey_value_list_set(&node_status,\n\t\t\t\t\t\t   \"WAL archiving\",\n\t\t\t\t\t\t   \"off\");\n\n\t\tkey_value_list_set(&node_status,\n\t\t\t\t\t\t   \"Archive command\",\n\t\t\t\t\t\t   \"(none)\");\n\t}\n\telse\n\t{\n\t\t/* \"archive_mode\" is not \"off\", i.e. one of \"on\", \"always\" */\n\t\tbool\t\tenabled = true;\n\t\tPQExpBufferData archiving_status;\n\t\tchar\t\tarchive_command[MAXLEN] = \"\";\n\n\t\tinitPQExpBuffer(&archiving_status);\n\n\t\t/*\n\t\t * if the node is a standby, and \"archive_mode\" is \"on\", archiving will\n\t\t * actually be disabled.\n\t\t */\n\t\tif (recovery_type == RECTYPE_STANDBY)\n\t\t{\n\t\t\tif (guc_set(conn, \"archive_mode\", \"=\", \"on\"))\n\t\t\t\tenabled = false;\n\t\t}\n\n\t\tif (enabled == true)\n\t\t{\n\t\t\tappendPQExpBufferStr(&archiving_status, \"enabled\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappendPQExpBufferStr(&archiving_status, \"disabled\");\n\t\t}\n\n\t\tif (enabled == false && recovery_type == RECTYPE_STANDBY)\n\t\t{\n\t\t\tif (PQserverVersion(conn) >= 90500)\n\t\t\t{\n\t\t\t\tappendPQExpBufferStr(&archiving_status,\n\t\t\t\t\t\t\t\t\t \" (on standbys \\\"archive_mode\\\" must be set to \\\"always\\\" to be effective)\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tappendPQExpBufferStr(&archiving_status,\n\t\t\t\t\t\t\t\t\t \" (\\\"archive_mode\\\" has no effect on standbys)\");\n\t\t\t}\n\t\t}\n\n\t\tkey_value_list_set(&node_status,\n\t\t\t\t\t\t   \"WAL archiving\",\n\t\t\t\t\t\t   archiving_status.data);\n\n\t\ttermPQExpBuffer(&archiving_status);\n\n\t\tget_pg_setting(conn, \"archive_command\", archive_command);\n\n\t\tkey_value_list_set(&node_status,\n\t\t\t\t\t\t   \"Archive command\",\n\t\t\t\t\t\t   archive_command);\n\t}\n\n\t{\n\t\tint\t\t\tready_files;\n\n\t\tready_files = get_ready_archive_files(conn, data_dir);\n\n\t\tif (ready_files == ARCHIVE_STATUS_DIR_ERROR)\n\t\t{\n\t\t\titem_list_append_format(&warnings,\n\t\t\t\t\t\t\t\t\t\"- unable to check archive_status directory\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (runtime_options.output_mode == OM_CSV)\n\t\t\t{\n\t\t\t\tkey_value_list_set_format(&node_status,\n\t\t\t\t\t\t\t\t\t\t  \"WALs pending archiving\",\n\t\t\t\t\t\t\t\t\t\t  \"%i\",\n\t\t\t\t\t\t\t\t\t\t  ready_files);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tkey_value_list_set_format(&node_status,\n\t\t\t\t\t\t\t\t\t\t  \"WALs pending archiving\",\n\t\t\t\t\t\t\t\t\t\t  \"%i pending files\",\n\t\t\t\t\t\t\t\t\t\t  ready_files);\n\t\t\t}\n\t\t}\n\n\t\tif (guc_set(conn, \"archive_mode\", \"=\", \"off\"))\n\t\t{\n\t\t\tkey_value_list_set_output_mode(&node_status, \"WALs pending archiving\", OM_CSV);\n\t\t}\n\n\t}\n\n\n\tif (node_info.max_wal_senders >= 0)\n\t{\n\t\t/* In CSV mode, raw values supplied as well */\n\t\tkey_value_list_set_format(&node_status,\n\t\t\t\t\t\t\t\t  \"Replication connections\",\n\t\t\t\t\t\t\t\t  \"%i (of maximal %i)\",\n\t\t\t\t\t\t\t\t  node_info.attached_wal_receivers,\n\t\t\t\t\t\t\t\t  node_info.max_wal_senders);\n\t}\n\telse if (node_info.max_wal_senders == 0)\n\t{\n\t\tkey_value_list_set_format(&node_status,\n\t\t\t\t\t\t\t\t  \"Replication connections\",\n\t\t\t\t\t\t\t\t  \"disabled\");\n\t}\n\n\t/* check for attached nodes */\n\t{\n\t\tNodeInfoList downstream_nodes = T_NODE_INFO_LIST_INITIALIZER;\n\t\tNodeInfoListCell *node_cell = NULL;\n\t\tItemList\tmissing_nodes = {NULL, NULL};\n\t\tint\t\t\tmissing_nodes_count = 0;\n\t\tint\t\t\texpected_nodes_count = 0;\n\n\t\tget_downstream_node_records(conn, config_file_options.node_id, &downstream_nodes);\n\n\t\t/* if a witness node is present, we'll need to remove this from the total */\n\t\texpected_nodes_count = downstream_nodes.node_count;\n\n\t\tfor (node_cell = downstream_nodes.head; node_cell; node_cell = node_cell->next)\n\t\t{\n\t\t\t/* skip witness server */\n\t\t\tif (node_cell->node_info->type == WITNESS)\n\t\t\t{\n\t\t\t\texpected_nodes_count --;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_downstream_node_attached(conn, node_cell->node_info->node_name, NULL) != NODE_ATTACHED)\n\t\t\t{\n\t\t\t\tmissing_nodes_count++;\n\t\t\t\titem_list_append_format(&missing_nodes,\n\t\t\t\t\t\t\t\t\t\t\"%s (ID: %i)\",\n\t\t\t\t\t\t\t\t\t\tnode_cell->node_info->node_name,\n\t\t\t\t\t\t\t\t\t\tnode_cell->node_info->node_id);\n\t\t\t}\n\t\t}\n\n\t\tif (missing_nodes_count)\n\t\t{\n\t\t\tItemListCell *missing_cell = NULL;\n\n\t\t\titem_list_append_format(&warnings,\n\t\t\t\t\t\t\t\t\t_(\"- %i of %i downstream nodes not attached:\"),\n\t\t\t\t\t\t\t\t\tmissing_nodes_count,\n\t\t\t\t\t\t\t\t\texpected_nodes_count);\n\n\t\t\tfor (missing_cell = missing_nodes.head; missing_cell; missing_cell = missing_cell->next)\n\t\t\t{\n\t\t\t\titem_list_append_format(&warnings,\n\t\t\t\t\t\t\t\t\t\t\"  - %s\\n\", missing_cell->string);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (node_info.max_replication_slots == 0)\n\t{\n\t\tkey_value_list_set(&node_status,\n\t\t\t\t\t\t   \"Replication slots\",\n\t\t\t\t\t\t   \"disabled\");\n\t}\n\telse\n\t{\n\t\tPQExpBufferData slotinfo;\n\n\t\t/*\n\t\t * check for missing replication slots - we do this regardless of\n\t\t * what \"max_replication_slots\" is set to, in case the downstream\n\t\t * node was configured with \"use_replication_slots=true\" and is\n\t\t * expecting a replication slot to be available\n\t\t */\n\t\tget_downstream_nodes_with_missing_slot(conn,\n\t\t\t\t\t\t\t\t\t\t\t   config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t\t   &missing_slots);\n\n\t\tif (missing_slots.node_count > 0)\n\t\t{\n\t\t\tNodeInfoListCell *missing_slot_cell = NULL;\n\n\t\t\titem_list_append_format(&warnings,\n\t\t\t\t\t\t\t\t\t_(\"- replication slots missing for following %i node(s):\"),\n\t\t\t\t\t\t\t\t\tmissing_slots.node_count);\n\n\t\t\tfor (missing_slot_cell = missing_slots.head; missing_slot_cell; missing_slot_cell = missing_slot_cell->next)\n\t\t\t{\n\t\t\t\titem_list_append_format(&warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"  - %s (ID: %i, slot name: \\\"%s\\\")\"),\n\t\t\t\t\t\t\t\t\t\tmissing_slot_cell->node_info->node_name,\n\t\t\t\t\t\t\t\t\t\tmissing_slot_cell->node_info->node_id,\n\t\t\t\t\t\t\t\t\t\tmissing_slot_cell->node_info->slot_name);\n\t\t\t}\n\t\t}\n\n\t\tinitPQExpBuffer(&slotinfo);\n\n\t\tappendPQExpBuffer(&slotinfo,\n\t\t\t\t\t\t  \"%i physical (of maximal %i; %i missing)\",\n\t\t\t\t\t\t  node_info.active_replication_slots + node_info.inactive_replication_slots,\n\t\t\t\t\t\t  node_info.max_replication_slots,\n\t\t\t\t\t\t  missing_slots.node_count);\n\n\t\tif (node_info.inactive_replication_slots > 0)\n\t\t{\n\t\t\tKeyValueList inactive_replication_slots = {NULL, NULL};\n\n\t\t\t(void) get_inactive_replication_slots(conn, &inactive_replication_slots);\n\n\t\t\tappendPQExpBuffer(&slotinfo,\n\t\t\t\t\t\t\t  \"; %i inactive\",\n\t\t\t\t\t\t\t  node_info.inactive_replication_slots);\n\n\t\t\titem_list_append_format(&warnings,\n\t\t\t\t\t\t\t\t\t_(\"- node has %i inactive physical replication slots\"),\n\t\t\t\t\t\t\t\t\tnode_info.inactive_replication_slots);\n\n\t\t\tfor (cell = inactive_replication_slots.head; cell; cell = cell->next)\n\t\t\t{\n\t\t\t\titem_list_append_format(&warnings,\n\t\t\t\t\t\t\t\t\t\t\"  - %s\", cell->key);\n\t\t\t}\n\n\t\t\tkey_value_list_free(&inactive_replication_slots);\n\t\t}\n\n\t\tkey_value_list_set(&node_status,\n\t\t\t\t\t\t   \"Replication slots\",\n\t\t\t\t\t\t   slotinfo.data);\n\n\t\ttermPQExpBuffer(&slotinfo);\n\t}\n\n\n\tif (node_info.type == STANDBY)\n\t{\n\t\tkey_value_list_set_format(&node_status,\n\t\t\t\t\t\t\t\t  \"Upstream node\",\n\t\t\t\t\t\t\t\t  \"%s (ID: %i)\",\n\t\t\t\t\t\t\t\t  node_info.upstream_node_name,\n\t\t\t\t\t\t\t\t  node_info.upstream_node_id);\n\n\t\tget_replication_info(conn, node_info.type, &replication_info);\n\n\t\tkey_value_list_set_format(&node_status,\n\t\t\t\t\t\t\t\t  \"Replication lag\",\n\t\t\t\t\t\t\t\t  \"%i seconds\",\n\t\t\t\t\t\t\t\t  replication_info.replication_lag_time);\n\n\t\tkey_value_list_set_format(&node_status,\n\t\t\t\t\t\t\t\t  \"Last received LSN\",\n\t\t\t\t\t\t\t\t  \"%X/%X\", format_lsn(replication_info.last_wal_receive_lsn));\n\n\t\tkey_value_list_set_format(&node_status,\n\t\t\t\t\t\t\t\t  \"Last replayed LSN\",\n\t\t\t\t\t\t\t\t  \"%X/%X\", format_lsn(replication_info.last_wal_replay_lsn));\n\t}\n\telse\n\t{\n\t\tkey_value_list_set(&node_status,\n\t\t\t\t\t\t   \"Upstream node\",\n\t\t\t\t\t\t   \"(none)\");\n\t\tkey_value_list_set_output_mode(&node_status,\n\t\t\t\t\t\t\t\t\t   \"Upstream node\",\n\t\t\t\t\t\t\t\t\t   OM_CSV);\n\n\t\tkey_value_list_set(&node_status,\n\t\t\t\t\t\t   \"Replication lag\",\n\t\t\t\t\t\t   \"n/a\");\n\n\t\tkey_value_list_set(&node_status,\n\t\t\t\t\t\t   \"Last received LSN\",\n\t\t\t\t\t\t   \"(none)\");\n\n\t\tkey_value_list_set_output_mode(&node_status,\n\t\t\t\t\t\t\t\t\t   \"Last received LSN\",\n\t\t\t\t\t\t\t\t\t   OM_CSV);\n\n\t\tkey_value_list_set(&node_status,\n\t\t\t\t\t\t   \"Last replayed LSN\",\n\t\t\t\t\t\t   \"(none)\");\n\n\t\tkey_value_list_set_output_mode(&node_status,\n\t\t\t\t\t\t\t\t\t   \"Last replayed LSN\",\n\t\t\t\t\t\t\t\t\t   OM_CSV);\n\t}\n\n\n\tparse_recovery_conf(data_dir, &recovery_conf);\n\n\t/* format output */\n\tinitPQExpBuffer(&output);\n\n\tif (runtime_options.output_mode == OM_CSV)\n\t{\n\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t  \"\\\"Node name\\\",\\\"%s\\\"\\n\",\n\t\t\t\t\t\t  node_info.node_name);\n\n\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t  \"\\\"Node ID\\\",\\\"%i\\\"\\n\",\n\t\t\t\t\t\t  node_info.node_id);\n\n\t\tfor (cell = node_status.head; cell; cell = cell->next)\n\t\t{\n\t\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t\t  \"\\\"%s\\\",\\\"%s\\\"\\n\",\n\t\t\t\t\t\t\t  cell->key, cell->value);\n\t\t}\n\n\t\t/* we'll add the raw data as well */\n\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t  \"\\\"max_wal_senders\\\",%i\\n\",\n\t\t\t\t\t\t  node_info.max_wal_senders);\n\n\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t  \"\\\"occupied_wal_senders\\\",%i\\n\",\n\t\t\t\t\t\t  node_info.attached_wal_receivers);\n\n\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t  \"\\\"max_replication_slots\\\",%i\\n\",\n\t\t\t\t\t\t  node_info.max_replication_slots);\n\n\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t  \"\\\"active_replication_slots\\\",%i\\n\",\n\t\t\t\t\t\t  node_info.active_replication_slots);\n\n\t\t/* output inactive slot information */\n\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t  \"\\\"inactive_replication_slots\\\",%i\",\n\t\t\t\t\t\t  node_info.inactive_replication_slots);\n\n\t\tif (node_info.inactive_replication_slots)\n\t\t{\n\t\t\tKeyValueList inactive_replication_slots = {NULL, NULL};\n\t\t\t(void) get_inactive_replication_slots(conn, &inactive_replication_slots);\n\t\t\tfor (cell = inactive_replication_slots.head; cell; cell = cell->next)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t\t\t  \",\\\"%s\\\"\", cell->key);\n\t\t\t}\n\n\t\t\tkey_value_list_free(&inactive_replication_slots);\n\t\t}\n\n\t\t/* output missing slot information */\n\n\t\tappendPQExpBufferChar(&output, '\\n');\n\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t  \"\\\"missing_replication_slots\\\",%i\",\n\t\t\t\t\t\t  missing_slots.node_count);\n\n\t\tif (missing_slots.node_count > 0)\n\t\t{\n\t\t\tNodeInfoListCell *missing_slot_cell = NULL;\n\n\t\t\tfor (missing_slot_cell = missing_slots.head; missing_slot_cell; missing_slot_cell = missing_slot_cell->next)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t\t\t  \",\\\"%s\\\"\", missing_slot_cell->node_info->slot_name);\n\t\t\t}\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t  \"Node \\\"%s\\\":\\n\",\n\t\t\t\t\t\t  node_info.node_name);\n\n\t\tfor (cell = node_status.head; cell; cell = cell->next)\n\t\t{\n\t\t\tif (cell->output_mode == OM_NOT_SET)\n\t\t\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t\t\t  \"\\t%s: %s\\n\",\n\t\t\t\t\t\t\t\t  cell->key, cell->value);\n\t\t}\n\t}\n\n\tputs(output.data);\n\n\ttermPQExpBuffer(&output);\n\n\tif (warnings.head != NULL && runtime_options.terse == false && runtime_options.output_mode == OM_TEXT)\n\t{\n\t\tlog_warning(_(\"following issue(s) were detected:\"));\n\t\tprint_item_list(&warnings);\n\t\tlog_hint(_(\"execute \\\"repmgr node check\\\" for more details\"));\n\t}\n\n\tclear_node_info_list(&missing_slots);\n\tkey_value_list_free(&node_status);\n\titem_list_free(&warnings);\n\tPQfinish(conn);\n\n\t/*\n\t * If warnings were noted, even if they're not displayed (e.g. in --csv node),\n\t * that means something's not right so we need to emit a non-zero exit code.\n\t */\n\tif (warnings.head != NULL)\n\t{\n\t\texit(ERR_NODE_STATUS);\n\t}\n\n\treturn;\n}\n\n\n/*\n * Returns information about the running state of the node.\n * For internal use during \"standby switchover\".\n *\n * Returns \"longopt\" output:\n *\n * --status=(RUNNING|SHUTDOWN|UNCLEAN_SHUTDOWN|UNKNOWN)\n * --last-checkpoint=...\n */\n\nstatic void\n_do_node_status_is_shutdown_cleanly(void)\n{\n\tPGPing\t\tping_status;\n\tPQExpBufferData output;\n\n\tDBState\t\tdb_state;\n\tXLogRecPtr\tcheckPoint = InvalidXLogRecPtr;\n\n\tNodeStatus\tnode_status = NODE_STATUS_UNKNOWN;\n\n\tinitPQExpBuffer(&output);\n\n\tappendPQExpBufferStr(&output,\n\t\t\t\t\t  \"--state=\");\n\n\t/* sanity-check we're dealing with a PostgreSQL directory */\n\tif (is_pg_dir(config_file_options.data_directory) == false)\n\t{\n\t\tappendPQExpBufferStr(&output, \"UNKNOWN\");\n\t\tprintf(\"%s\\n\", output.data);\n\t\ttermPQExpBuffer(&output);\n\t\treturn;\n\t}\n\n\tping_status = PQping(config_file_options.conninfo);\n\n\tswitch (ping_status)\n\t{\n\t\tcase PQPING_OK:\n\t\t\tnode_status = NODE_STATUS_UP;\n\t\t\tbreak;\n\t\tcase PQPING_REJECT:\n\t\t\tnode_status = NODE_STATUS_UP;\n\t\t\tbreak;\n\t\tcase PQPING_NO_ATTEMPT:\n\t\tcase PQPING_NO_RESPONSE:\n\t\t\t/* status not yet clear */\n\t\t\tbreak;\n\t}\n\n\t/* check what pg_control says */\n\n\tif (get_db_state(config_file_options.data_directory, &db_state) == false)\n\t{\n\t\t/*\n\t\t * Unable to retrieve the database state from pg_control\n\t\t */\n\t\tnode_status = NODE_STATUS_UNKNOWN;\n\t\tlog_verbose(LOG_DEBUG, \"unable to determine db state\");\n\t\tgoto return_state;\n\t}\n\n\tlog_verbose(LOG_DEBUG, \"db state now: %s\", describe_db_state(db_state));\n\n\tif (db_state != DB_SHUTDOWNED && db_state != DB_SHUTDOWNED_IN_RECOVERY)\n\t{\n\t\tif (node_status != NODE_STATUS_UP)\n\t\t{\n\t\t\tnode_status = NODE_STATUS_UNCLEAN_SHUTDOWN;\n\t\t}\n\t\t/* server is still responding but shutting down */\n\t\telse if (db_state == DB_SHUTDOWNING)\n\t\t{\n\t\t\tnode_status = NODE_STATUS_SHUTTING_DOWN;\n\t\t}\n\t}\n\n\tcheckPoint = get_latest_checkpoint_location(config_file_options.data_directory);\n\n\tif (checkPoint == InvalidXLogRecPtr)\n\t{\n\t\t/* unable to read pg_control, don't know what's happening */\n\t\tnode_status = NODE_STATUS_UNKNOWN;\n\t}\n\telse if (node_status == NODE_STATUS_UNKNOWN)\n\t{\n\t\t/*\n\t\t * if still \"UNKNOWN\" at this point, then the node must be cleanly shut\n\t\t * down\n\t\t */\n\t\tnode_status = NODE_STATUS_DOWN;\n\t}\n\n\nreturn_state:\n\n\tlog_verbose(LOG_DEBUG, \"node status determined as: %s\",\n\t\t\t\tprint_node_status(node_status));\n\n\tappendPQExpBuffer(&output,\n\t\t\t\t\t  \"%s\", print_node_status(node_status));\n\n\tif (node_status == NODE_STATUS_DOWN)\n\t{\n\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t  \" --last-checkpoint-lsn=%X/%X\",\n\t\t\t\t\t\t  format_lsn(checkPoint));\n\t}\n\n\tprintf(\"%s\\n\", output.data);\n\ttermPQExpBuffer(&output);\n\treturn;\n}\n\nstatic void\nexit_optformat_error(const char *error, int errcode)\n{\n\tPQExpBufferData output;\n\n\tAssert(runtime_options.output_mode == OM_OPTFORMAT);\n\n\tinitPQExpBuffer(&output);\n\n\tappendPQExpBuffer(&output,\n\t\t\t\t\t  \"--error=%s\",\n\t\t\t\t\t  error);\n\n\tprintf(\"%s\\n\", output.data);\n\n\ttermPQExpBuffer(&output);\n\n\texit(errcode);\n}\n\n/*\n * Configuration file required\n */\nvoid\ndo_node_check(void)\n{\n\tPGconn\t   *conn = NULL;\n\tPQExpBufferData output;\n\n\tt_node_info node_info = T_NODE_INFO_INITIALIZER;\n\n\tCheckStatus return_code;\n\tCheckStatusList status_list = {NULL, NULL};\n\tCheckStatusListCell *cell = NULL;\n\n\tbool\t\t\tissue_detected = false;\n\tbool\t\t\texit_on_connection_error = true;\n\n\t/* for internal use */\n\tif (runtime_options.has_passfile == true)\n\t{\n\t\treturn_code = has_passfile() ? 0 : 1;\n\n\t\texit(return_code);\n\t}\n\n\t/* for use by \"standby switchover\" */\n\tif (runtime_options.replication_connection == true)\n\t{\n\t\tdo_node_check_replication_connection();\n\t\texit(SUCCESS);\n\t}\n\n\tif (runtime_options.db_connection == true)\n\t{\n\t\texit_on_connection_error = false;\n\t}\n\n\t/*\n\t * If --optformat was provided, we'll assume this is a remote invocation\n\t * and instead of exiting with an error, we'll return an error string to\n\t * so the remote invoker will know what's happened.\n\t */\n\tif (runtime_options.output_mode == OM_OPTFORMAT)\n\t{\n\t\texit_on_connection_error = false;\n\t}\n\n\n\tif (config_file_options.conninfo[0] != '\\0')\n\t{\n\t\tt_conninfo_param_list node_conninfo = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\t\tchar\t   *errmsg = NULL;\n\t\tbool\t\tparse_success = false;\n\n\t\tinitialize_conninfo_params(&node_conninfo, false);\n\n\t\tparse_success = parse_conninfo_string(config_file_options.conninfo,\n\t\t\t\t\t\t\t\t\t\t\t  &node_conninfo,\n\t\t\t\t\t\t\t\t\t\t\t  &errmsg, false);\n\n\t\tif (parse_success == false)\n\t\t{\n\t\t\tif (runtime_options.output_mode == OM_OPTFORMAT)\n\t\t\t{\n\t\t\t\texit_optformat_error(\"CONNINFO_PARSE\",\n\t\t\t\t\t\t\t\t\t ERR_BAD_CONFIG);\n\t\t\t}\n\n\t\t\tlog_error(_(\"unable to parse conninfo string \\\"%s\\\" for local node\"),\n\t\t\t\t\t  config_file_options.conninfo);\n\t\t\tlog_detail(\"%s\", errmsg);\n\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\t/*\n\t\t * If --superuser option provided, attempt to connect as the specified user\n\t\t */\n\n\t\tif (runtime_options.superuser[0] != '\\0')\n\t\t{\n\t\t\tconn = establish_db_connection_with_replacement_param(\n\t\t\t\tconfig_file_options.conninfo,\n\t\t\t\t\"user\",\n\t\t\t\truntime_options.superuser,\n\t\t\t\texit_on_connection_error);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconn = establish_db_connection_by_params(&node_conninfo, exit_on_connection_error);\n\t\t}\n\t}\n\telse\n\t{\n\t\tconn = establish_db_connection_by_params(&source_conninfo, exit_on_connection_error);\n\t}\n\n\n\t/*\n\t * --db-connection option provided\n\t */\n\tif (runtime_options.db_connection == true)\n\t{\n\t\treturn_code = do_node_check_db_connection(conn, runtime_options.output_mode);\n\t\tPQfinish(conn);\n\t\texit(return_code);\n\t}\n\n\t/*\n\t * If we've reached here, and the connection is invalid, then --optformat was provided\n\t */\n\tif (PQstatus(conn) != CONNECTION_OK)\n\t{\n\t\texit_optformat_error(\"DB_CONNECTION\",\n\t\t\t\t\t\t\t ERR_DB_CONN);\n\t}\n\n\tif (get_node_record(conn, config_file_options.node_id, &node_info) != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"no record found for node %i\"), config_file_options.node_id);\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* add replication statistics to node record */\n\tget_node_replication_stats(conn, &node_info);\n\n\t/*\n\t * handle specific checks ======================\n\t */\n\tif (runtime_options.archive_ready == true)\n\t{\n\t\treturn_code = do_node_check_archive_ready(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t  runtime_options.output_mode,\n\t\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\t\tPQfinish(conn);\n\t\texit(return_code);\n\t}\n\n\tif (runtime_options.upstream == true)\n\t{\n\t\treturn_code = do_node_check_upstream(conn,\n\t\t\t\t\t\t\t\t\t\t\t runtime_options.output_mode,\n\t\t\t\t\t\t\t\t\t\t\t &node_info,\n\t\t\t\t\t\t\t\t\t\t\t NULL);\n\t\tPQfinish(conn);\n\t\texit(return_code);\n\t}\n\n\tif (runtime_options.downstream == true)\n\t{\n\t\treturn_code = do_node_check_downstream(conn,\n\t\t\t\t\t\t\t\t\t\t\t   runtime_options.output_mode,\n\t\t\t\t\t\t\t\t\t\t\t   &node_info,\n\t\t\t\t\t\t\t\t\t\t\t   NULL);\n\t\tPQfinish(conn);\n\t\texit(return_code);\n\t}\n\n\tif (runtime_options.replication_lag == true)\n\t{\n\t\treturn_code = do_node_check_replication_lag(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\truntime_options.output_mode,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&node_info,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNULL);\n\t\tPQfinish(conn);\n\t\texit(return_code);\n\t}\n\n\tif (runtime_options.role == true)\n\t{\n\t\treturn_code = do_node_check_role(conn,\n\t\t\t\t\t\t\t\t\t\t runtime_options.output_mode,\n\t\t\t\t\t\t\t\t\t\t &node_info,\n\t\t\t\t\t\t\t\t\t\t NULL);\n\t\tPQfinish(conn);\n\t\texit(return_code);\n\t}\n\n\tif (runtime_options.slots == true)\n\t{\n\t\treturn_code = do_node_check_slots(conn,\n\t\t\t\t\t\t\t\t\t\t  runtime_options.output_mode,\n\t\t\t\t\t\t\t\t\t\t  &node_info,\n\t\t\t\t\t\t\t\t\t\t  NULL);\n\t\tPQfinish(conn);\n\t\texit(return_code);\n\t}\n\n\tif (runtime_options.missing_slots == true)\n\t{\n\t\treturn_code = do_node_check_missing_slots(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t  runtime_options.output_mode,\n\t\t\t\t\t\t\t\t\t\t\t\t  &node_info,\n\t\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\t\tPQfinish(conn);\n\t\texit(return_code);\n\t}\n\n\tif (runtime_options.data_directory_config == true)\n\t{\n\t\treturn_code = do_node_check_data_directory(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t   runtime_options.output_mode,\n\t\t\t\t\t\t\t\t\t\t\t\t   &node_info,\n\t\t\t\t\t\t\t\t\t\t\t\t   NULL);\n\t\tPQfinish(conn);\n\t\texit(return_code);\n\t}\n\n\tif (runtime_options.repmgrd == true)\n\t{\n\t\treturn_code = do_node_check_repmgrd(conn,\n\t\t\t\t\t\t\t\t\t\t\truntime_options.output_mode,\n\t\t\t\t\t\t\t\t\t\t\t&node_info,\n\t\t\t\t\t\t\t\t\t\t\tNULL);\n\t\tPQfinish(conn);\n\t\texit(return_code);\n\t}\n\n\tif (runtime_options.replication_config_owner == true)\n\t{\n\t\treturn_code = do_node_check_replication_config_owner(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   runtime_options.output_mode,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &node_info,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL);\n\t\tPQfinish(conn);\n\t\texit(return_code);\n\t}\n\n\n\tif (runtime_options.output_mode == OM_NAGIOS)\n\t{\n\t\tlog_error(_(\"--nagios can only be used with a specific check\"));\n\t\tlog_hint(_(\"execute \\\"repmgr node --help\\\" for details\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* output general overview */\n\n\tinitPQExpBuffer(&output);\n\n\t/* order functions are called is also output order */\n\tif (do_node_check_role(conn, runtime_options.output_mode, &node_info, &status_list) != CHECK_STATUS_OK)\n\t\tissue_detected = true;\n\n\tif (do_node_check_replication_lag(conn, runtime_options.output_mode, &node_info, &status_list) != CHECK_STATUS_OK)\n\t\tissue_detected = true;\n\n\tif (do_node_check_archive_ready(conn, runtime_options.output_mode, &status_list) != CHECK_STATUS_OK)\n\t\tissue_detected = true;\n\n\tif (do_node_check_upstream(conn, runtime_options.output_mode, &node_info, &status_list) != CHECK_STATUS_OK)\n\t\tissue_detected = true;\n\n\tif (do_node_check_downstream(conn, runtime_options.output_mode, &node_info, &status_list) != CHECK_STATUS_OK)\n\t\tissue_detected = true;\n\n\tif (do_node_check_slots(conn, runtime_options.output_mode, &node_info, &status_list) != CHECK_STATUS_OK)\n\t\tissue_detected = true;\n\n\tif (do_node_check_missing_slots(conn, runtime_options.output_mode, &node_info, &status_list) != CHECK_STATUS_OK)\n\t\tissue_detected = true;\n\n\tif (do_node_check_data_directory(conn, runtime_options.output_mode, &node_info, &status_list) != CHECK_STATUS_OK)\n\t\tissue_detected = true;\n\n\tif (runtime_options.output_mode == OM_CSV)\n\t{\n\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t  \"\\\"Node name\\\",\\\"%s\\\"\\n\",\n\t\t\t\t\t\t  node_info.node_name);\n\n\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t  \"\\\"Node ID\\\",\\\"%i\\\"\\n\",\n\t\t\t\t\t\t  node_info.node_id);\n\n\t\tfor (cell = status_list.head; cell; cell = cell->next)\n\t\t{\n\t\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t\t  \"\\\"%s\\\",\\\"%s\\\"\",\n\t\t\t\t\t\t\t  cell->item,\n\t\t\t\t\t\t\t  output_check_status(cell->status));\n\n\t\t\tif (strlen(cell->details))\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t\t\t  \",\\\"%s\\\"\",\n\t\t\t\t\t\t\t\t  cell->details);\n\t\t\t}\n\t\t\tappendPQExpBufferChar(&output, '\\n');\n\t\t}\n\t}\n\telse\n\t{\n\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t  \"Node \\\"%s\\\":\\n\",\n\t\t\t\t\t\t  node_info.node_name);\n\n\t\tfor (cell = status_list.head; cell; cell = cell->next)\n\t\t{\n\t\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t\t  \"\\t%s: %s\",\n\t\t\t\t\t\t\t  cell->item,\n\t\t\t\t\t\t\t  output_check_status(cell->status));\n\n\t\t\tif (strlen(cell->details))\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&output,\n\t\t\t\t\t\t\t\t  \" (%s)\",\n\t\t\t\t\t\t\t\t  cell->details);\n\t\t\t}\n\t\t\tappendPQExpBufferChar(&output, '\\n');\n\t\t}\n\t}\n\n\n\tprintf(\"%s\", output.data);\n\ttermPQExpBuffer(&output);\n\tcheck_status_list_free(&status_list);\n\n\tPQfinish(conn);\n\n\tif (issue_detected == true)\n\t{\n\t\texit(ERR_NODE_STATUS);\n\t}\n}\n\n\nstatic void\ndo_node_check_replication_connection(void)\n{\n\tPGconn *local_conn = NULL;\n\tPGconn *repl_conn = NULL;\n\tt_node_info node_record = T_NODE_INFO_INITIALIZER;\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\tPQExpBufferData output;\n\n\n\tinitPQExpBuffer(&output);\n\tappendPQExpBufferStr(&output,\n\t\t\t\t\t\t \"--connection=\");\n\n\tif (runtime_options.remote_node_id == UNKNOWN_NODE_ID)\n\t{\n\t\tappendPQExpBufferStr(&output, \"UNKNOWN\");\n\t\tprintf(\"%s\\n\", output.data);\n\t\ttermPQExpBuffer(&output);\n\t\treturn;\n\t}\n\n\t/* retrieve remote node record from local database */\n\tlocal_conn = establish_db_connection(config_file_options.conninfo, false);\n\n\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t{\n\t\tappendPQExpBufferStr(&output, \"CONNECTION_ERROR\");\n\t\tprintf(\"%s\\n\", output.data);\n\t\ttermPQExpBuffer(&output);\n\t\treturn;\n\t}\n\n\trecord_status = get_node_record(local_conn, runtime_options.remote_node_id, &node_record);\n\tPQfinish(local_conn);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tappendPQExpBufferStr(&output, \"UNKNOWN\");\n\t\tprintf(\"%s\\n\", output.data);\n\t\ttermPQExpBuffer(&output);\n\t\treturn;\n\t}\n\n\trepl_conn = establish_replication_connection_from_conninfo(node_record.conninfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   node_record.repluser);\n\n\tif (PQstatus(repl_conn) != CONNECTION_OK)\n\t{\n\t\tappendPQExpBufferStr(&output, \"BAD\");\n\t\tprintf(\"%s\\n\", output.data);\n\t\ttermPQExpBuffer(&output);\n\t\treturn;\n\t}\n\n\tPQfinish(repl_conn);\n\n\tappendPQExpBufferStr(&output, \"OK\");\n\tprintf(\"%s\\n\", output.data);\n\ttermPQExpBuffer(&output);\n\n\treturn;\n}\n\n\n\nstatic CheckStatus\ndo_node_check_archive_ready(PGconn *conn, OutputMode mode, CheckStatusList *list_output)\n{\n\tint\t\t\tready_archive_files = 0;\n\tCheckStatus status = CHECK_STATUS_UNKNOWN;\n\tPQExpBufferData details;\n\n\tif (mode == OM_CSV && list_output == NULL)\n\t{\n\t\tlog_error(_(\"--csv output not provided with --archive-ready option\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tinitPQExpBuffer(&details);\n\n\tready_archive_files = get_ready_archive_files(conn, config_file_options.data_directory);\n\n\tif (ready_archive_files > config_file_options.archive_ready_critical)\n\t{\n\t\tstatus = CHECK_STATUS_CRITICAL;\n\n\t\tswitch (mode)\n\t\t{\n\t\t\tcase OM_OPTFORMAT:\n\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t  \"--files=%i --threshold=%i\",\n\t\t\t\t\t\t\t\t  ready_archive_files, config_file_options.archive_ready_critical);\n\t\t\t\tbreak;\n\t\t\tcase OM_NAGIOS:\n\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t  \"%i pending archive ready files | files=%i;%i;%i\",\n\t\t\t\t\t\t\t\t  ready_archive_files,\n\t\t\t\t\t\t\t\t  ready_archive_files,\n\t\t\t\t\t\t\t\t  config_file_options.archive_ready_warning,\n\t\t\t\t\t\t\t\t  config_file_options.archive_ready_critical);\n\t\t\t\tbreak;\n\t\t\tcase OM_TEXT:\n\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t  \"%i pending archive ready files, critical threshold: %i\",\n\t\t\t\t\t\t\t\t  ready_archive_files, config_file_options.archive_ready_critical);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if (ready_archive_files > config_file_options.archive_ready_warning)\n\t{\n\t\tstatus = CHECK_STATUS_WARNING;\n\n\t\tswitch (mode)\n\t\t{\n\t\t\tcase OM_OPTFORMAT:\n\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t  \"--files=%i --threshold=%i\",\n\t\t\t\t\t\t\t\t  ready_archive_files, config_file_options.archive_ready_warning);\n\t\t\t\tbreak;\n\t\t\tcase OM_NAGIOS:\n\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t  \"%i pending archive ready files | files=%i;%i;%i\",\n\t\t\t\t\t\t\t\t  ready_archive_files,\n\t\t\t\t\t\t\t\t  ready_archive_files,\n\t\t\t\t\t\t\t\t  config_file_options.archive_ready_warning,\n\t\t\t\t\t\t\t\t  config_file_options.archive_ready_critical);\n\n\t\t\t\tbreak;\n\t\t\tcase OM_TEXT:\n\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t  \"%i pending archive ready files (threshold: %i)\",\n\t\t\t\t\t\t\t\t  ready_archive_files, config_file_options.archive_ready_warning);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if (ready_archive_files < 0)\n\t{\n\t\tstatus = CHECK_STATUS_UNKNOWN;\n\n\t\tswitch (mode)\n\t\t{\n\t\t\tcase OM_OPTFORMAT:\n\t\t\t\tbreak;\n\t\t\tcase OM_NAGIOS:\n\t\t\tcase OM_TEXT:\n\t\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t\t \"unable to check archive_status directory\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\tstatus = CHECK_STATUS_OK;\n\n\t\tswitch (mode)\n\t\t{\n\t\t\tcase OM_OPTFORMAT:\n\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t  \"--files=%i\", ready_archive_files);\n\t\t\t\tbreak;\n\t\t\tcase OM_NAGIOS:\n\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t  \"%i pending archive ready files | files=%i;%i;%i\",\n\t\t\t\t\t\t\t\t  ready_archive_files,\n\t\t\t\t\t\t\t\t  ready_archive_files,\n\t\t\t\t\t\t\t\t  config_file_options.archive_ready_warning,\n\t\t\t\t\t\t\t\t  config_file_options.archive_ready_critical);\n\t\t\t\tbreak;\n\t\t\tcase OM_TEXT:\n\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t  \"%i pending archive ready files\", ready_archive_files);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (mode)\n\t{\n\t\tcase OM_OPTFORMAT:\n\t\t\t{\n\t\t\t\tprintf(\"--status=%s %s\\n\",\n\t\t\t\t\t   output_check_status(status),\n\t\t\t\t\t   details.data);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OM_NAGIOS:\n\t\t\tprintf(\"REPMGR_ARCHIVE_READY %s: %s\\n\",\n\t\t\t\t   output_check_status(status),\n\t\t\t\t   details.data);\n\t\t\tbreak;\n\t\tcase OM_CSV:\n\t\tcase OM_TEXT:\n\t\t\tif (list_output != NULL)\n\t\t\t{\n\t\t\t\tcheck_status_list_set(list_output,\n\t\t\t\t\t\t\t\t\t  \"WAL archiving\",\n\t\t\t\t\t\t\t\t\t  status,\n\t\t\t\t\t\t\t\t\t  details.data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%s (%s)\\n\",\n\t\t\t\t\t   output_check_status(status),\n\t\t\t\t\t   details.data);\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\ttermPQExpBuffer(&details);\n\treturn status;\n}\n\n\nstatic CheckStatus\ndo_node_check_downstream(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output)\n{\n\tNodeInfoList downstream_nodes = T_NODE_INFO_LIST_INITIALIZER;\n\tNodeInfoListCell *cell = NULL;\n\tint\t\t\tmissing_nodes_count = 0;\n\tint\t\t\texpected_nodes_count = 0;\n\tCheckStatus status = CHECK_STATUS_OK;\n\tItemList\tmissing_nodes = {NULL, NULL};\n\tItemList\tattached_nodes = {NULL, NULL};\n\tPQExpBufferData details;\n\n\tif (mode == OM_CSV && list_output == NULL)\n\t{\n\t\tlog_error(_(\"--csv output not provided with --downstream option\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tinitPQExpBuffer(&details);\n\n\tget_downstream_node_records(conn, config_file_options.node_id, &downstream_nodes);\n\n\t/* if a witness node is present, we'll need to remove this from the total */\n\texpected_nodes_count = downstream_nodes.node_count;\n\n\tfor (cell = downstream_nodes.head; cell; cell = cell->next)\n\t{\n\t\t/* skip witness server */\n\t\tif (cell->node_info->type == WITNESS)\n\t\t{\n\t\t\texpected_nodes_count --;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_downstream_node_attached_quiet(conn, cell->node_info->node_name, NULL) != NODE_ATTACHED)\n\t\t{\n\t\t\tmissing_nodes_count++;\n\t\t\titem_list_append_format(&missing_nodes,\n\t\t\t\t\t\t\t\t\t\"%s (ID: %i)\",\n\t\t\t\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\t\t\t\tcell->node_info->node_id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem_list_append_format(&attached_nodes,\n\t\t\t\t\t\t\t\t\t\"%s (ID: %i)\",\n\t\t\t\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\t\t\t\tcell->node_info->node_id);\n\t\t}\n\t}\n\n\tif (node_info->type == WITNESS)\n\t{\n\t\t/* witness is not connecting to any upstream */\n\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t _(\"N/A - node is a witness\"));\n\t}\n\telse if (missing_nodes_count == 0)\n\t{\n\t\tif (expected_nodes_count == 0)\n\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t \"this node has no downstream nodes\");\n\t\telse\n\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t  \"%i of %i downstream nodes attached\",\n\t\t\t\t\t\t\t  expected_nodes_count - missing_nodes_count,\n\t\t\t\t\t\t\t  expected_nodes_count);\n\t}\n\telse\n\t{\n\t\tItemListCell *missing_cell = NULL;\n\t\tbool\t\tfirst = true;\n\n\t\tstatus = CHECK_STATUS_CRITICAL;\n\n\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t  \"%i of %i downstream nodes not attached\",\n\t\t\t\t\t\t  missing_nodes_count,\n\t\t\t\t\t\t  expected_nodes_count);\n\n\t\tif (mode != OM_NAGIOS)\n\t\t{\n\t\t\tappendPQExpBufferStr(&details, \"; missing: \");\n\n\t\t\tfor (missing_cell = missing_nodes.head; missing_cell; missing_cell = missing_cell->next)\n\t\t\t{\n\t\t\t\tif (first == false)\n\t\t\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t\t\t \", \");\n\t\t\t\telse\n\t\t\t\t\tfirst = false;\n\n\t\t\t\tif (first == false)\n\t\t\t\t\tappendPQExpBufferStr(&details, missing_cell->string);\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (mode)\n\t{\n\t\tcase OM_NAGIOS:\n\t\t\t{\n\t\t\t\tif (missing_nodes_count)\n\t\t\t\t{\n\t\t\t\t\tItemListCell *missing_cell = NULL;\n\t\t\t\t\tbool\t\tfirst = true;\n\n\t\t\t\t\tappendPQExpBufferStr(&details, \" (missing: \");\n\n\t\t\t\t\tfor (missing_cell = missing_nodes.head; missing_cell; missing_cell = missing_cell->next)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (first == false)\n\t\t\t\t\t\t\tappendPQExpBufferStr(&details, \", \");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfirst = false;\n\n\t\t\t\t\t\tif (first == false)\n\t\t\t\t\t\t\tappendPQExpBufferStr(&details, missing_cell->string);\n\t\t\t\t\t}\n\n\t\t\t\t\tappendPQExpBufferChar(&details, ')');\n\t\t\t\t}\n\n\t\t\t\tprintf(\"REPMGR_DOWNSTREAM_SERVERS %s: %s | attached=%i, missing=%i\\n\",\n\t\t\t\t\t   output_check_status(status),\n\t\t\t\t\t   details.data,\n\t\t\t\t\t   expected_nodes_count - missing_nodes_count,\n\t\t\t\t\t   missing_nodes_count);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OM_CSV:\n\t\tcase OM_TEXT:\n\t\t\tif (list_output != NULL)\n\t\t\t{\n\t\t\t\tcheck_status_list_set(list_output,\n\t\t\t\t\t\t\t\t\t  \"Downstream servers\",\n\t\t\t\t\t\t\t\t\t  status,\n\t\t\t\t\t\t\t\t\t  details.data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%s (%s)\\n\",\n\t\t\t\t\t   output_check_status(status),\n\t\t\t\t\t   details.data);\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\n\t}\n\ttermPQExpBuffer(&details);\n\tclear_node_info_list(&downstream_nodes);\n\treturn status;\n}\n\n\nstatic CheckStatus\ndo_node_check_upstream(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output)\n{\n\tPGconn\t   *upstream_conn = NULL;\n\tt_node_info upstream_node_info = T_NODE_INFO_INITIALIZER;\n\tPQExpBufferData details;\n\n\tCheckStatus status = CHECK_STATUS_OK;\n\n\tif (mode == OM_CSV && list_output == NULL)\n\t{\n\t\tlog_error(_(\"--csv output not provided with --upstream option\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tinitPQExpBuffer(&details);\n\n\tif (node_info->type == WITNESS)\n\t{\n\t\t/* witness is not connecting to any upstream */\n\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t _(\"N/A - node is a witness\"));\n\t}\n\telse if (get_node_record(conn, node_info->upstream_node_id, &upstream_node_info) != RECORD_FOUND)\n\t{\n\t\tif (get_recovery_type(conn) == RECTYPE_STANDBY)\n\t\t{\n\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t  _(\"node \\\"%s\\\" (ID: %i) is a standby but no upstream record found\"),\n\t\t\t\t\t\t\t  node_info->node_name,\n\t\t\t\t\t\t\t  node_info->node_id);\n\t\t\tstatus = CHECK_STATUS_CRITICAL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t _(\"N/A - node is primary\"));\n\t\t}\n\t}\n\telse\n\t{\n\t\tupstream_conn = establish_db_connection(upstream_node_info.conninfo, true);\n\n\t\t/* check our node is connected */\n\t\tif (is_downstream_node_attached(upstream_conn, config_file_options.node_name, NULL) != NODE_ATTACHED)\n\t\t{\n\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t  _(\"node \\\"%s\\\" (ID: %i) is not attached to expected upstream node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t  node_info->node_name,\n\t\t\t\t\t\t\t  node_info->node_id,\n\t\t\t\t\t\t\t  upstream_node_info.node_name,\n\t\t\t\t\t\t\t  upstream_node_info.node_id);\n\t\t\tstatus = CHECK_STATUS_CRITICAL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t  _(\"node \\\"%s\\\" (ID: %i) is attached to expected upstream node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t  node_info->node_name,\n\t\t\t\t\t\t\t  node_info->node_id,\n\t\t\t\t\t\t\t  upstream_node_info.node_name,\n\t\t\t\t\t\t\t  upstream_node_info.node_id);\n\t\t}\n\t}\n\n\tswitch (mode)\n\t{\n\t\tcase OM_NAGIOS:\n\t\t\t{\n\t\t\t\tprintf(\"REPMGR_UPSTREAM_SERVER %s: %s\\n\",\n\t\t\t\t\t   output_check_status(status),\n\t\t\t\t\t   details.data);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OM_TEXT:\n\t\t\tif (list_output != NULL)\n\t\t\t{\n\t\t\t\tcheck_status_list_set(list_output,\n\t\t\t\t\t\t\t\t\t  \"Upstream connection\",\n\t\t\t\t\t\t\t\t\t  status,\n\t\t\t\t\t\t\t\t\t  details.data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%s (%s)\\n\",\n\t\t\t\t\t   output_check_status(status),\n\t\t\t\t\t   details.data);\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\ttermPQExpBuffer(&details);\n\n\treturn status;\n}\n\n\nstatic CheckStatus\ndo_node_check_replication_lag(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output)\n{\n\tCheckStatus status = CHECK_STATUS_OK;\n\tint\t\t\tlag_seconds = 0;\n\tPQExpBufferData details;\n\n\tif (mode == OM_CSV && list_output == NULL)\n\t{\n\t\tlog_error(_(\"--csv output not provided with --replication-lag option\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tinitPQExpBuffer(&details);\n\n\tif (node_info->recovery_type == RECTYPE_PRIMARY)\n\t{\n\t\tswitch (mode)\n\t\t{\n\t\t\tcase OM_OPTFORMAT:\n\t\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t\t \"--lag=0\");\n\t\t\t\tbreak;\n\t\t\tcase OM_NAGIOS:\n\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t  \"0 seconds | lag=0;%i;%i\",\n\t\t\t\t\t\t\t\t  config_file_options.replication_lag_warning,\n\t\t\t\t\t\t\t\t  config_file_options.replication_lag_critical);\n\t\t\t\tbreak;\n\t\t\tcase OM_TEXT:\n\t\t\t\tif (node_info->type == WITNESS)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t\t\t \"N/A - node is witness\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t\t\t \"N/A - node is primary\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\tlag_seconds = get_replication_lag_seconds(conn);\n\n\t\tlog_debug(\"lag seconds: %i\", lag_seconds);\n\n\t\tif (lag_seconds >= config_file_options.replication_lag_critical)\n\t\t{\n\t\t\tstatus = CHECK_STATUS_CRITICAL;\n\n\t\t\tswitch (mode)\n\t\t\t{\n\t\t\t\tcase OM_OPTFORMAT:\n\t\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t\t  \"--lag=%i --threshold=%i\",\n\t\t\t\t\t\t\t\t\t  lag_seconds, config_file_options.replication_lag_critical);\n\t\t\t\t\tbreak;\n\t\t\t\tcase OM_NAGIOS:\n\t\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t\t  \"%i seconds | lag=%i;%i;%i\",\n\t\t\t\t\t\t\t\t\t  lag_seconds,\n\t\t\t\t\t\t\t\t\t  lag_seconds,\n\t\t\t\t\t\t\t\t\t  config_file_options.replication_lag_warning,\n\t\t\t\t\t\t\t\t\t  config_file_options.replication_lag_critical);\n\t\t\t\t\tbreak;\n\t\t\t\tcase OM_TEXT:\n\t\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t\t  \"%i seconds, critical threshold: %i)\",\n\t\t\t\t\t\t\t\t\t  lag_seconds, config_file_options.replication_lag_critical);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (lag_seconds > config_file_options.replication_lag_warning)\n\t\t{\n\t\t\tstatus = CHECK_STATUS_WARNING;\n\n\t\t\tswitch (mode)\n\t\t\t{\n\t\t\t\tcase OM_OPTFORMAT:\n\t\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t\t  \"--lag=%i --threshold=%i\",\n\t\t\t\t\t\t\t\t\t  lag_seconds, config_file_options.replication_lag_warning);\n\t\t\t\t\tbreak;\n\t\t\t\tcase OM_NAGIOS:\n\t\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t\t  \"%i seconds | lag=%i;%i;%i\",\n\t\t\t\t\t\t\t\t\t  lag_seconds,\n\t\t\t\t\t\t\t\t\t  lag_seconds,\n\t\t\t\t\t\t\t\t\t  config_file_options.replication_lag_warning,\n\t\t\t\t\t\t\t\t\t  config_file_options.replication_lag_critical);\n\t\t\t\t\tbreak;\n\t\t\t\tcase OM_TEXT:\n\t\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t\t  \"%i seconds, warning threshold: %i)\",\n\t\t\t\t\t\t\t\t\t  lag_seconds, config_file_options.replication_lag_warning);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (lag_seconds == UNKNOWN_REPLICATION_LAG)\n\t\t{\n\t\t\tstatus = CHECK_STATUS_UNKNOWN;\n\n\t\t\tswitch (mode)\n\t\t\t{\n\t\t\t\tcase OM_OPTFORMAT:\n\t\t\t\t\tbreak;\n\t\t\t\tcase OM_NAGIOS:\n\t\t\t\tcase OM_TEXT:\n\t\t\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t\t\t \"unable to query replication lag\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatus = CHECK_STATUS_OK;\n\n\t\t\tswitch (mode)\n\t\t\t{\n\t\t\t\tcase OM_OPTFORMAT:\n\t\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t\t  \"--lag=%i\",\n\t\t\t\t\t\t\t\t\t  lag_seconds);\n\t\t\t\t\tbreak;\n\t\t\t\tcase OM_NAGIOS:\n\t\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t\t  \"%i seconds | lag=%i;%i;%i\",\n\t\t\t\t\t\t\t\t\t  lag_seconds,\n\t\t\t\t\t\t\t\t\t  lag_seconds,\n\t\t\t\t\t\t\t\t\t  config_file_options.replication_lag_warning,\n\t\t\t\t\t\t\t\t\t  config_file_options.replication_lag_critical);\n\t\t\t\t\tbreak;\n\t\t\t\tcase OM_TEXT:\n\t\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t\t  \"%i seconds\",\n\t\t\t\t\t\t\t\t\t  lag_seconds);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (mode)\n\t{\n\t\tcase OM_OPTFORMAT:\n\t\t\tprintf(\"--status=%s %s\\n\",\n\t\t\t\t   output_check_status(status),\n\t\t\t\t   details.data);\n\t\t\tbreak;\n\t\tcase OM_NAGIOS:\n\t\t\tprintf(\"REPMGR_REPLICATION_LAG %s: %s\\n\",\n\t\t\t\t   output_check_status(status),\n\t\t\t\t   details.data);\n\t\t\tbreak;\n\t\tcase OM_CSV:\n\t\tcase OM_TEXT:\n\t\t\tif (list_output != NULL)\n\t\t\t{\n\t\t\t\tcheck_status_list_set(list_output,\n\t\t\t\t\t\t\t\t\t  \"Replication lag\",\n\t\t\t\t\t\t\t\t\t  status,\n\t\t\t\t\t\t\t\t\t  details.data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%s (%s)\\n\",\n\t\t\t\t\t   output_check_status(status),\n\t\t\t\t\t   details.data);\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\ttermPQExpBuffer(&details);\n\n\treturn status;\n}\n\n\nstatic CheckStatus\ndo_node_check_role(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output)\n{\n\n\tCheckStatus status = CHECK_STATUS_OK;\n\tPQExpBufferData details;\n\tRecoveryType recovery_type = get_recovery_type(conn);\n\n\tif (mode == OM_CSV && list_output == NULL)\n\t{\n\t\tlog_error(_(\"--csv output not provided with --role option\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tinitPQExpBuffer(&details);\n\n\tswitch (node_info->type)\n\t{\n\t\tcase PRIMARY:\n\t\t\tif (recovery_type == RECTYPE_STANDBY)\n\t\t\t{\n\t\t\t\tstatus = CHECK_STATUS_CRITICAL;\n\t\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t\t _(\"node is registered as primary but running as standby\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t\t _(\"node is primary\"));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STANDBY:\n\t\t\tif (recovery_type == RECTYPE_PRIMARY)\n\t\t\t{\n\t\t\t\tstatus = CHECK_STATUS_CRITICAL;\n\t\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t\t _(\"node is registered as standby but running as primary\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t\t _(\"node is standby\"));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WITNESS:\n\t\t\tif (recovery_type == RECTYPE_STANDBY)\n\t\t\t{\n\t\t\t\tstatus = CHECK_STATUS_CRITICAL;\n\t\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t\t _(\"node is registered as witness but running as standby\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t\t _(\"node is witness\"));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tswitch (mode)\n\t{\n\t\tcase OM_NAGIOS:\n\t\t\tprintf(\"REPMGR_SERVER_ROLE %s: %s\\n\",\n\t\t\t\t   output_check_status(status),\n\t\t\t\t   details.data);\n\t\t\tbreak;\n\t\tcase OM_CSV:\n\t\tcase OM_TEXT:\n\t\t\tif (list_output != NULL)\n\t\t\t{\n\t\t\t\tcheck_status_list_set(list_output,\n\t\t\t\t\t\t\t\t\t  \"Server role\",\n\t\t\t\t\t\t\t\t\t  status,\n\t\t\t\t\t\t\t\t\t  details.data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%s (%s)\\n\",\n\t\t\t\t\t   output_check_status(status),\n\t\t\t\t\t   details.data);\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\ttermPQExpBuffer(&details);\n\treturn status;\n\n}\n\n\nstatic CheckStatus\ndo_node_check_slots(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output)\n{\n\tCheckStatus status = CHECK_STATUS_OK;\n\tPQExpBufferData details;\n\n\tif (mode == OM_CSV && list_output == NULL)\n\t{\n\t\tlog_error(_(\"--csv output not provided with --slots option\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tinitPQExpBuffer(&details);\n\n\tif (node_info->total_replication_slots == 0)\n\t{\n\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t _(\"node has no physical replication slots\"));\n\t}\n\telse if (node_info->inactive_replication_slots == 0)\n\t{\n\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t  _(\"%i of %i physical replication slots are active\"),\n\t\t\t\t\t\t  node_info->total_replication_slots,\n\t\t\t\t\t\t  node_info->total_replication_slots);\n\t}\n\telse if (node_info->inactive_replication_slots > 0)\n\t{\n\t\tstatus = CHECK_STATUS_CRITICAL;\n\n\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t  _(\"%i of %i physical replication slots are inactive\"),\n\t\t\t\t\t\t  node_info->inactive_replication_slots,\n\t\t\t\t\t\t  node_info->total_replication_slots);\n\t}\n\n\tswitch (mode)\n\t{\n\t\tcase OM_NAGIOS:\n\t\t\tprintf(\"REPMGR_INACTIVE_SLOTS %s: %s | slots=%i;%i\\n\",\n\t\t\t\t   output_check_status(status),\n\t\t\t\t   details.data,\n\t\t\t\t   node_info->total_replication_slots,\n\t\t\t\t   node_info->inactive_replication_slots);\n\t\t\tbreak;\n\t\tcase OM_CSV:\n\t\tcase OM_TEXT:\n\t\t\tif (list_output != NULL)\n\t\t\t{\n\t\t\t\tcheck_status_list_set(list_output,\n\t\t\t\t\t\t\t\t\t  \"Replication slots\",\n\t\t\t\t\t\t\t\t\t  status,\n\t\t\t\t\t\t\t\t\t  details.data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%s (%s)\\n\",\n\t\t\t\t\t   output_check_status(status),\n\t\t\t\t\t   details.data);\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\ttermPQExpBuffer(&details);\n\treturn status;\n}\n\n\nstatic CheckStatus\ndo_node_check_missing_slots(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output)\n{\n\tCheckStatus status = CHECK_STATUS_OK;\n\tPQExpBufferData details;\n\tNodeInfoList missing_slots = T_NODE_INFO_LIST_INITIALIZER;\n\n\tif (mode == OM_CSV && list_output == NULL)\n\t{\n\t\tlog_error(_(\"--csv output not provided with --missing-slots option\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tinitPQExpBuffer(&details);\n\n\tget_downstream_nodes_with_missing_slot(conn,\n\t\t\t\t\t\t\t\t\t\t   config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t   &missing_slots);\n\n\tif (missing_slots.node_count == 0)\n\t{\n\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t _(\"node has no missing physical replication slots\"));\n\t}\n\telse\n\t{\n\t\tNodeInfoListCell *missing_slot_cell = NULL;\n\t\tbool first_element = true;\n\n\t\tstatus = CHECK_STATUS_CRITICAL;\n\n\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t  _(\"%i physical replication slots are missing\"),\n\t\t\t\t\t\t  missing_slots.node_count);\n\n\t\tif (missing_slots.node_count)\n\t\t{\n\t\t\tappendPQExpBufferStr(&details, \": \");\n\n\t\t\tfor (missing_slot_cell = missing_slots.head; missing_slot_cell; missing_slot_cell = missing_slot_cell->next)\n\t\t\t{\n\t\t\t\tif (first_element == true)\n\t\t\t\t{\n\t\t\t\t\tfirst_element = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(&details, \", \");\n\t\t\t\t}\n\n\t\t\t\tappendPQExpBufferStr(&details, missing_slot_cell->node_info->slot_name);\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (mode)\n\t{\n\t\tcase OM_NAGIOS:\n\t\t{\n\t\t\tprintf(\"REPMGR_MISSING_SLOTS %s: %s | missing_slots=%i\",\n\t\t\t\t   output_check_status(status),\n\t\t\t\t   details.data,\n\t\t\t\t   missing_slots.node_count);\n\n\t\t\tif (missing_slots.node_count)\n\t\t\t{\n\t\t\t\tNodeInfoListCell *missing_slot_cell = NULL;\n\t\t\t\tbool first_element = true;\n\n\t\t\t\tprintf(\";\");\n\n\t\t\t\tfor (missing_slot_cell = missing_slots.head; missing_slot_cell; missing_slot_cell = missing_slot_cell->next)\n\t\t\t\t{\n\t\t\t\t\tif (first_element == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tfirst_element = false;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\",\");\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"%s\", missing_slot_cell->node_info->slot_name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcase OM_CSV:\n\t\tcase OM_TEXT:\n\t\t\tif (list_output != NULL)\n\t\t\t{\n\t\t\t\tcheck_status_list_set(list_output,\n\t\t\t\t\t\t\t\t\t  \"Missing physical replication slots\",\n\t\t\t\t\t\t\t\t\t  status,\n\t\t\t\t\t\t\t\t\t  details.data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%s (%s)\\n\",\n\t\t\t\t\t   output_check_status(status),\n\t\t\t\t\t   details.data);\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tclear_node_info_list(&missing_slots);\n\n\ttermPQExpBuffer(&details);\n\treturn status;\n}\n\nCheckStatus\ndo_node_check_data_directory(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output)\n{\n\tCheckStatus status = CHECK_STATUS_OK;\n\tchar actual_data_directory[MAXPGPATH] = \"\";\n\tPQExpBufferData details;\n\n\tif (mode == OM_CSV && list_output == NULL)\n\t{\n\t\tlog_error(_(\"--csv output not provided with --data-directory-config option\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tinitPQExpBuffer(&details);\n\n\t/*\n\t * Check actual data directory matches that in repmgr.conf; note this requires\n\t * a superuser connection\n\t */\n\tif (connection_has_pg_monitor_role(conn, \"pg_read_all_settings\") == true)\n\t{\n\t\t/* we expect to have a database connection */\n\t\tif (get_pg_setting(conn, \"data_directory\", actual_data_directory) == false)\n\t\t{\n\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t  _(\"unable to determine current \\\"data_directory\\\"\"));\n\t\t\tstatus = CHECK_STATUS_UNKNOWN;\n\t\t}\n\n\t\tif (strncmp(actual_data_directory, config_file_options.data_directory, MAXPGPATH) != 0)\n\t\t{\n\t\t\tif (mode != OM_NAGIOS)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t  _(\"configured \\\"data_directory\\\" is \\\"%s\\\"; \"),\n\t\t\t\t\t\t\t\t  config_file_options.data_directory);\n\t\t\t}\n\n\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t  \"actual data directory is \\\"%s\\\"\",\n\t\t\t\t\t\t\t  actual_data_directory);\n\n\t\t\tstatus = CHECK_STATUS_CRITICAL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t  _(\"configured \\\"data_directory\\\" is \\\"%s\\\"\"),\n\t\t\t\t\t\t\t  config_file_options.data_directory);\n\t\t}\n\t}\n\t/*\n\t * If no superuser connection available, sanity-check that the configuration directory looks\n\t * like a PostgreSQL directory and hope it's the right one.\n\t */\n\telse\n\t{\n\t\tif (mode == OM_TEXT)\n\t\t{\n\t\t\tlog_info(_(\"connection is not a superuser connection, falling back to simple check\"));\n\n\t\t\tif (PQserverVersion(conn) >= 100000)\n\t\t\t{\n\t\t\t\tlog_hint(_(\"provide a superuser with -S/--superuser, or add the \\\"%s\\\" user to role \\\"pg_read_all_settings\\\" or \\\"pg_monitor\\\"\"),\n\t\t\t\t\t\t   PQuser(conn));\n\t\t\t}\n\t\t}\n\n\t\tif (is_pg_dir(config_file_options.data_directory) == false)\n\t\t{\n\t\t\tif (mode == OM_NAGIOS)\n\t\t\t{\n\t\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t  _(\"configured \\\"data_directory\\\" is not a PostgreSQL data directory\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t  _(\"configured \\\"data_directory\\\" \\\"%s\\\" is not a PostgreSQL data directory\"),\n\t\t\t\t\t\t\t\t  actual_data_directory);\n\t\t\t}\n\n\t\t\tstatus = CHECK_STATUS_CRITICAL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t  _(\"configured \\\"data_directory\\\" is \\\"%s\\\"\"),\n\t\t\t\t\t\t\t  config_file_options.data_directory);\n\t\t}\n\t}\n\n\tswitch (mode)\n\t{\n\t\tcase OM_OPTFORMAT:\n\t\t\tprintf(\"--configured-data-directory=%s\\n\",\n\t\t\t\t   output_check_status(status));\n\t\t\tbreak;\n\t\tcase OM_NAGIOS:\n\t\t\tprintf(\"REPMGR_DATA_DIRECTORY %s: %s\",\n\t\t\t\t   output_check_status(status),\n\t\t\t\t   config_file_options.data_directory);\n\n\t\t\tif (status == CHECK_STATUS_CRITICAL)\n\t\t\t{\n\t\t\t\tprintf(\" | %s\", details.data);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t\tbreak;\n\t\tcase OM_CSV:\n\t\tcase OM_TEXT:\n\t\t\tif (list_output != NULL)\n\t\t\t{\n\t\t\t\tcheck_status_list_set(list_output,\n\t\t\t\t\t\t\t\t\t  \"Configured data directory\",\n\t\t\t\t\t\t\t\t\t  status,\n\t\t\t\t\t\t\t\t\t  details.data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%s (%s)\\n\",\n\t\t\t\t\t   output_check_status(status),\n\t\t\t\t\t   details.data);\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\ttermPQExpBuffer(&details);\n\n\treturn status;\n}\n\nCheckStatus\ndo_node_check_repmgrd(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output)\n{\n\tCheckStatus status = CHECK_STATUS_OK;\n\n\tif (mode == OM_CSV && list_output == NULL)\n\t{\n\t\tlog_error(_(\"--csv output not provided with --repmgrd option\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tstatus = get_repmgrd_status(conn);\n\tswitch (mode)\n\t{\n\t\tcase OM_OPTFORMAT:\n\t\t\tprintf(\"--repmgrd=%s\\n\",\n\t\t\t\t   output_check_status(status));\n\t\t\tbreak;\n\t\tcase OM_NAGIOS:\n\t\t\tprintf(\"REPMGRD %s: %s\\n\",\n\t\t\t\t   output_check_status(status),\n\t\t\t\t   output_repmgrd_status(status));\n\n\t\t\tbreak;\n\t\tcase OM_CSV:\n\t\tcase OM_TEXT:\n\t\t\tif (list_output != NULL)\n\t\t\t{\n\t\t\t\tcheck_status_list_set(list_output,\n\t\t\t\t\t\t\t\t\t  \"repmgrd\",\n\t\t\t\t\t\t\t\t\t  status,\n\t\t\t\t\t\t\t\t\t  output_repmgrd_status(status));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%s (%s)\\n\",\n\t\t\t\t\t   output_check_status(status),\n\t\t\t\t\t   output_repmgrd_status(status));\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n/*\n * This is not included in the general list output\n */\nstatic\nCheckStatus do_node_check_replication_config_owner(PGconn *conn, OutputMode mode, t_node_info *node_info, CheckStatusList *list_output)\n{\n\tCheckStatus status = CHECK_STATUS_OK;\n\n\tPQExpBufferData errmsg;\n\tPQExpBufferData details;\n\n\tif (mode != OM_OPTFORMAT)\n\t{\n\t\tlog_error(_(\"--replication-config-owner option can only be used with --optformat\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tinitPQExpBuffer(&errmsg);\n\tinitPQExpBuffer(&details);\n\n\tif (check_replication_config_owner(PQserverVersion(conn),\n\t\t\t\t\t\t\t\t\t   config_file_options.data_directory,\n\t\t\t\t\t\t\t\t\t   &errmsg, &details) == false)\n\t{\n\t\tstatus = CHECK_STATUS_CRITICAL;\n\t}\n\n\tprintf(\"--replication-config-owner=%s\\n\",\n\t\t   output_check_status(status));\n\n\treturn status;\n}\n\n\n/*\n * This is not included in the general list output\n */\nstatic CheckStatus\ndo_node_check_db_connection(PGconn *conn, OutputMode mode)\n{\n\tCheckStatus status = CHECK_STATUS_OK;\n\tPQExpBufferData details;\n\n\tif (mode == OM_CSV)\n\t{\n\t\tlog_error(_(\"--csv output not provided with --db-connection option\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* This check is for configuration diagnostics only */\n\tif (mode == OM_NAGIOS)\n\t{\n\t\tlog_error(_(\"--nagios output not provided with --db-connection option\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tinitPQExpBuffer(&details);\n\n\tif (PQstatus(conn) != CONNECTION_OK)\n\t{\n\t\tt_conninfo_param_list conninfo = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\t\tint c;\n\n\t\tstatus = CHECK_STATUS_CRITICAL;\n\t\tinitialize_conninfo_params(&conninfo, false);\n\t\tconn_to_param_list(conn, &conninfo);\n\n\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t \"connection parameters used:\");\n\t\tfor (c = 0; c < conninfo.size && conninfo.keywords[c] != NULL; c++)\n\t\t{\n\t\t\tif (conninfo.values[c] != NULL && conninfo.values[c][0] != '\\0')\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t\t  \" %s=%s\",\n\t\t\t\t\t\t\t\t  conninfo.keywords[c], conninfo.values[c]);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (mode == OM_OPTFORMAT)\n\t{\n\t\tprintf(\"--db-connection=%s\\n\",\n\t\t\t   output_check_status(status));\n\t}\n\telse if (mode == OM_TEXT)\n\t{\n\t\tprintf(\"%s (%s)\\n\",\n\t\t\t   output_check_status(status),\n\t\t\t   details.data);\n\t}\n\ttermPQExpBuffer(&details);\n\n\treturn status;\n}\n\n\nvoid\ndo_node_service(void)\n{\n\tt_server_action action = ACTION_UNKNOWN;\n\tchar\t\tdata_dir[MAXPGPATH] = \"\";\n\tchar\t\tcommand[MAXLEN] = \"\";\n\tPQExpBufferData output;\n\n\taction = parse_server_action(runtime_options.action);\n\n\tif (action == ACTION_UNKNOWN)\n\t{\n\t\tlog_error(_(\"unknown value \\\"%s\\\" provided for parameter --action\"),\n\t\t\t\t  runtime_options.action);\n\t\tlog_hint(_(\"valid values are \\\"start\\\", \\\"stop\\\", \\\"restart\\\", \\\"reload\\\" and \\\"promote\\\"\"));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tif (runtime_options.list_actions == true)\n\t{\n\t\treturn _do_node_service_list_actions(action);\n\t}\n\n\n\tif (data_dir_required_for_action(action))\n\t{\n\t\tget_node_config_directory(data_dir);\n\n\t\tif (data_dir[0] == '\\0')\n\t\t{\n\t\t\tlog_error(_(\"unable to determine data directory for action\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\n\tif ((action == ACTION_STOP || action == ACTION_RESTART) && runtime_options.checkpoint == true)\n\t{\n\t\tPGconn\t   *conn = NULL;\n\n\t\tif (config_file_options.conninfo[0] != '\\0')\n\t\t{\n\t\t\t/*\n\t\t\t * If --superuser option provided, attempt to connect as the specified user\n\t\t\t */\n\t\t\tif (runtime_options.superuser[0] != '\\0')\n\t\t\t{\n\t\t\t\tconn = establish_db_connection_with_replacement_param(\n\t\t\t\t\tconfig_file_options.conninfo,\n\t\t\t\t\t\"user\",\n\t\t\t\t\truntime_options.superuser,\n\t\t\t\t\ttrue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconn = establish_db_connection(config_file_options.conninfo, true);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconn = establish_db_connection_by_params(&source_conninfo, true);\n\t\t}\n\n\t\tif (can_execute_checkpoint(conn) == false)\n\t\t{\n\t\t\tif (runtime_options.dry_run == true)\n\t\t\t{\n\t\t\t\tlog_warning(_(\"a CHECKPOINT would be issued here but no authorized connection is available\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_warning(_(\"an authorized connection is required to issue a CHECKPOINT\"));\n\t\t\t}\n\n\t\t\tif (PQserverVersion(conn) >= 150000)\n\t\t\t{\n\t\t\t\tlog_hint(_(\"provide a superuser with -S/--superuser or grant pg_checkpoint role to repmgr user\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_hint(_(\"provide a superuser with -S/--superuser\"));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (runtime_options.dry_run == true)\n\t\t\t{\n\t\t\t\tlog_info(_(\"a CHECKPOINT would be issued here\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\n\t\t\t\tlog_notice(_(\"issuing CHECKPOINT on node \\\"%s\\\" (ID: %i) \"),\n\t\t\t\t\t\t   config_file_options.node_name,\n\t\t\t\t\t\t   config_file_options.node_id);\n\n\t\t\t\tcheckpoint(conn);\n\t\t\t}\n\t\t}\n\n\t\tPQfinish(conn);\n\t}\n\n\tget_server_action(action, command, data_dir);\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"would execute server command \\\"%s\\\"\"), command);\n\t\treturn;\n\t}\n\n\t/*\n\t * log level is \"DETAIL\" here as this command is intended to be executed\n\t * by another repmgr process (e.g. during standby switchover); that repmgr\n\t * should emit a \"NOTICE\" about the intent of the command.\n\t */\n\tlog_detail(_(\"executing server command \\\"%s\\\"\"), command);\n\n\tinitPQExpBuffer(&output);\n\n\tif (local_command(command, &output) == false)\n\t{\n\t\ttermPQExpBuffer(&output);\n\t\texit(ERR_LOCAL_COMMAND);\n\t}\n\n\ttermPQExpBuffer(&output);\n}\n\n\nstatic void\n_do_node_service_list_actions(t_server_action action)\n{\n\tchar\t\tcommand[MAXLEN] = \"\";\n\n\tchar\t\tdata_dir[MAXPGPATH] = \"\";\n\n\tbool\t\tdata_dir_required = false;\n\n\t/* do we need to provide a data directory for any of the actions? */\n\tif (data_dir_required_for_action(ACTION_START))\n\t\tdata_dir_required = true;\n\n\tif (data_dir_required_for_action(ACTION_STOP))\n\t\tdata_dir_required = true;\n\n\tif (data_dir_required_for_action(ACTION_RESTART))\n\t\tdata_dir_required = true;\n\n\tif (data_dir_required_for_action(ACTION_RELOAD))\n\t\tdata_dir_required = true;\n\n\tif (data_dir_required_for_action(ACTION_PROMOTE))\n\t\tdata_dir_required = true;\n\n\tif (data_dir_required == true)\n\t{\n\t\tget_node_config_directory(data_dir);\n\t}\n\n\t/* show command for specific action only */\n\tif (action != ACTION_NONE)\n\t{\n\t\tget_server_action(action, command, data_dir);\n\t\tprintf(\"%s\\n\", command);\n\t\treturn;\n\t}\n\n\tputs(_(\"Following commands would be executed for each action:\"));\n\tputs(\"\");\n\n\tget_server_action(ACTION_START, command, data_dir);\n\tprintf(\"    start: \\\"%s\\\"\\n\", command);\n\n\tget_server_action(ACTION_STOP, command, data_dir);\n\tprintf(\"     stop: \\\"%s\\\"\\n\", command);\n\n\tget_server_action(ACTION_RESTART, command, data_dir);\n\tprintf(\"  restart: \\\"%s\\\"\\n\", command);\n\n\tget_server_action(ACTION_RELOAD, command, data_dir);\n\tprintf(\"   reload: \\\"%s\\\"\\n\", command);\n\n\tget_server_action(ACTION_PROMOTE, command, data_dir);\n\tprintf(\"  promote: \\\"%s\\\"\\n\", command);\n\n\tputs(\"\");\n\n}\n\n\nstatic t_server_action\nparse_server_action(const char *action_name)\n{\n\tif (action_name[0] == '\\0')\n\t\treturn ACTION_NONE;\n\n\tif (strcasecmp(action_name, \"start\") == 0)\n\t\treturn ACTION_START;\n\n\tif (strcasecmp(action_name, \"stop\") == 0)\n\t\treturn ACTION_STOP;\n\n\tif (strcasecmp(action_name, \"restart\") == 0)\n\t\treturn ACTION_RESTART;\n\n\tif (strcasecmp(action_name, \"reload\") == 0)\n\t\treturn ACTION_RELOAD;\n\n\tif (strcasecmp(action_name, \"promote\") == 0)\n\t\treturn ACTION_PROMOTE;\n\n\treturn ACTION_UNKNOWN;\n}\n\n\n\n/*\n * Rejoin a dormant (shut down) node to the replication cluster; this\n * is typically a former primary which needs to be demoted to a standby.\n *\n * Note that \"repmgr node rejoin\" is also executed by\n * \"repmgr standby switchover\" after promoting the new primary.\n *\n * Parameters:\n *   --dry-run\n *   --force-rewind[=VALUE]\n *   --config-files\n *   --config-archive-dir\n *   -W/--no-wait\n */\nvoid\ndo_node_rejoin(void)\n{\n\tPGconn\t   *upstream_conn = NULL;\n\tRecoveryType primary_recovery_type = RECTYPE_UNKNOWN;\n\tPGconn\t   *primary_conn = NULL;\n\n\tDBState\t\tdb_state;\n\tPGPing\t\tstatus;\n\tbool\t\tis_shutdown = true;\n\tint\t\t\tserver_version_num = UNKNOWN_SERVER_VERSION_NUM;\n\tbool\t\thide_standby_signal = false;\n\n\tKeyValueListCell *cell = NULL;\n\tPQExpBufferData command;\n\tPQExpBufferData command_output;\n\tPQExpBufferData follow_output;\n\tstruct stat statbuf;\n\tt_node_info primary_node_record = T_NODE_INFO_INITIALIZER;\n\tt_node_info local_node_record = T_NODE_INFO_INITIALIZER;\n\n\tbool\t\tsuccess = true;\n\tint\t\t\tfollow_error_code = SUCCESS;\n\n\t/* check node is not actually running */\n\tstatus = PQping(config_file_options.conninfo);\n\n\tswitch (status)\n\t{\n\t\tcase PQPING_NO_ATTEMPT:\n\t\t\tlog_error(_(\"unable to determine status of server\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\tcase PQPING_OK:\n\t\t\tis_shutdown = false;\n\t\t\tbreak;\n\t\tcase PQPING_REJECT:\n\t\t\tis_shutdown = false;\n\t\t\tbreak;\n\t\tcase PQPING_NO_RESPONSE:\n\t\t\t/* status not yet clear */\n\t\t\tbreak;\n\t}\n\n\tif (get_db_state(config_file_options.data_directory, &db_state) == false)\n\t{\n\t\tlog_error(_(\"unable to determine database state from pg_control\"));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tif (is_shutdown == false)\n\t{\n\t\tlog_error(_(\"database is still running in state \\\"%s\\\"\"),\n\t\t\t\t  describe_db_state(db_state));\n\t\tlog_hint(_(\"\\\"repmgr node rejoin\\\" cannot be executed on a running node\"));\n\t\texit(ERR_REJOIN_FAIL);\n\t}\n\n\t/*\n\t * Server version number required to determine whether pg_rewind will run\n\t * crash recovery (Pg 13 and later).\n\t */\n\tserver_version_num = get_pg_version(config_file_options.data_directory, NULL);\n\n\tif (server_version_num == UNKNOWN_SERVER_VERSION_NUM)\n\t{\n\t\t/* This is very unlikely to happen */\n\t\tlog_error(_(\"unable to determine database version\"));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tlog_verbose(LOG_DEBUG, \"server version number is: %i\", server_version_num);\n\n\t/* check if cleanly shut down */\n\tif (db_state != DB_SHUTDOWNED && db_state != DB_SHUTDOWNED_IN_RECOVERY)\n\t{\n\t\tif (db_state == DB_SHUTDOWNING)\n\t\t{\n\t\t\tlog_error(_(\"database is still shutting down\"));\n\t\t}\n\t\telse if (server_version_num >= 130000 && runtime_options.force_rewind_used == true)\n\t\t{\n\t\t\tlog_warning(_(\"database is not shut down cleanly\"));\n\t\t\tlog_detail(_(\"--force-rewind provided, pg_rewind will automatically perform recovery\"));\n\n\t\t\t/*\n\t\t\t * If pg_rewind is executed, the first change it will make\n\t\t\t * is to start the server in single user mode, which will fail\n\t\t\t * in the presence of \"standby.signal\", so we'll \"hide\" it\n\t\t\t * (actually delete and recreate).\n\t\t\t */\n\t\t\thide_standby_signal = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If the database was not shut down cleanly, it *might* rejoin correctly\n\t\t\t * after starting up and recovering, but better to ensure the database\n\t\t\t * can recover before trying anything else.\n\t\t\t */\n\t\t\tlog_error(_(\"database is not shut down cleanly\"));\n\n\t\t\tif (server_version_num >= 130000)\n\t\t\t{\n\t\t\t\tlog_hint(_(\"provide --force-rewind to run recovery\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (runtime_options.force_rewind_used == true)\n\t\t\t\t{\n\t\t\t\t\tlog_detail(_(\"pg_rewind will not be able to run\"));\n\t\t\t\t}\n\t\t\t\tlog_hint(_(\"database should be restarted then shut down cleanly after crash recovery completes\"));\n\t\t\t}\n\n\t\t\texit(ERR_REJOIN_FAIL);\n\t\t}\n\t}\n\n\t/* check provided upstream connection */\n\tupstream_conn = establish_db_connection_by_params(&source_conninfo, true);\n\n\tif (get_primary_node_record(upstream_conn, &primary_node_record) == false)\n\t{\n\t\tlog_error(_(\"unable to retrieve primary node record\"));\n\t\tlog_hint(_(\"check the provided database connection string is for a \\\"repmgr\\\" database\"));\n\t\tPQfinish(upstream_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * Emit a notice about the identity of the rejoin target\n\t */\n\tlog_notice(_(\"rejoin target is node \\\"%s\\\" (ID: %i)\"),\n\t\t\t   primary_node_record.node_name,\n\t\t\t   primary_node_record.node_id);\n\n\t/* connect to registered primary and check it's not in recovery */\n\tprimary_conn = establish_db_connection(primary_node_record.conninfo, false);\n\n\tif (PQstatus(primary_conn) != CONNECTION_OK)\n\t{\n\t\tRecoveryType upstream_recovery_type = get_recovery_type(upstream_conn);\n\n\t\tlog_error(_(\"unable to connect to current registered primary \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t  primary_node_record.node_name,\n\t\t\t\t  primary_node_record.node_id);\n\t\tlog_detail(_(\"registered primary node conninfo is: \\\"%s\\\"\"),\n\t\t\t\t   primary_node_record.conninfo);\n\t\t/*\n\t\t * Catch case where provided upstream is not in recovery, but is also\n\t\t * not registered as primary\n\t\t */\n\n\t\tif (upstream_recovery_type == RECTYPE_PRIMARY)\n\t\t{\n\t\t\tlog_warning(_(\"provided upstream connection string is for a server which is not in recovery, but not registered as primary\"));\n\t\t\tlog_hint(_(\"fix repmgr metadata configuration before continuing\"));\n\t\t}\n\n\t\tPQfinish(upstream_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tPQfinish(upstream_conn);\n\n\tprimary_recovery_type = get_recovery_type(primary_conn);\n\n\tif (primary_recovery_type != RECTYPE_PRIMARY)\n\t{\n\t\tlog_error(_(\"primary server is registered as node \\\"%s\\\" (ID: %i), but server is not a primary\"),\n\t\t\t\t  primary_node_record.node_name,\n\t\t\t\t  primary_node_record.node_id);\n\t\t/* TODO: hint about checking cluster */\n\t\tPQfinish(primary_conn);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * Fetch the local node record - we'll need this later, and it acts as an\n\t * additional sanity-check that the node is known to the primary.\n\t */\n\tif (get_node_record(primary_conn, config_file_options.node_id, &local_node_record) != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve node record for the local node\"));\n\t\tlog_hint(_(\"check the local node is registered with the current primary \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t primary_node_record.node_name,\n\t\t\t\t primary_node_record.node_id);\n\n\t\tPQfinish(primary_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * Sanity-check replication slot availability\n\t */\n\tif (config_file_options.use_replication_slots)\n\t{\n\t\tbool slots_available = check_replication_slots_available(primary_node_record.node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t primary_conn);\n\t\tif (slots_available == false)\n\t\t{\n\t\t\tPQfinish(primary_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\n\t/*\n\t * sanity-check that it will actually be possible to stream from the new upstream\n\t */\n\t{\n\t\tbool can_rejoin;\n\t\tTimeLineID tli = get_min_recovery_end_timeline(config_file_options.data_directory);\n\t\tXLogRecPtr min_recovery_location = get_min_recovery_location(config_file_options.data_directory);\n\n\t\t/*\n\t\t * It's possible this was a former primary, so the minRecoveryPoint*\n\t\t * fields may be empty.\n\t\t */\n\n\t\tif (min_recovery_location == InvalidXLogRecPtr)\n\t\t\tmin_recovery_location = get_latest_checkpoint_location(config_file_options.data_directory);\n\t\tif (tli == 0)\n\t\t\ttli = get_timeline(config_file_options.data_directory);\n\n\t\tcan_rejoin = check_node_can_attach(tli,\n\t\t\t\t\t\t\t\t\t\t   min_recovery_location,\n\t\t\t\t\t\t\t\t\t\t   primary_conn,\n\t\t\t\t\t\t\t\t\t\t   &primary_node_record,\n\t\t\t\t\t\t\t\t\t\t   true);\n\n\t\tif (can_rejoin == false)\n\t\t{\n\t\t\tPQfinish(primary_conn);\n\t\t\texit(ERR_REJOIN_FAIL);\n\t\t}\n\t}\n\n\n\t/*\n\t * --force-rewind specified - check prerequisites, and attempt to execute\n  \t * (if --dry-run provided, just output the command which would be executed)\n\t */\n\n\tif (runtime_options.force_rewind_used == true)\n\t{\n\t\tPQExpBufferData msg;\n\t\tPQExpBufferData\tfilebuf;\n\t\tint\t\t\t\tret;\n\n\t\t/*\n\t\t * Check that pg_rewind can be used\n\t\t */\n\n\t\tinitPQExpBuffer(&msg);\n\n\t\tif (can_use_pg_rewind(primary_conn, config_file_options.data_directory, &msg) == false)\n\t\t{\n\t\t\tlog_error(_(\"--force-rewind specified but pg_rewind cannot be used\"));\n\t\t\tlog_detail(\"%s\", msg.data);\n\t\t\ttermPQExpBuffer(&msg);\n\t\t\tPQfinish(primary_conn);\n\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tappendPQExpBufferStr(&msg,\n\t\t\t\t\t\t\t _(\"prerequisites for using pg_rewind are met\"));\n\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(\"%s\", msg.data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_verbose(LOG_INFO, \"%s\", msg.data);\n\t\t}\n\t\ttermPQExpBuffer(&msg);\n\n\t\t/*\n\t\t * Archive requested configuration files.\n\t\t *\n\t\t * In --dry-run mode this acts as a check that the files can be archived, though\n\t\t * errors will only be logged; any copied files will be deleted and --dry-run\n\t\t * execution will continue.\n\t\t */\n\t\t_do_node_archive_config();\n\n\t\t/* execute pg_rewind */\n\t\tinitPQExpBuffer(&command);\n\n\t\tif (runtime_options.force_rewind_path[0] != '\\0')\n\t\t{\n\t\t\tappendPQExpBuffer(&command,\n\t\t\t\t\t\t\t  \"%s -D \",\n\t\t\t\t\t\t\t  runtime_options.force_rewind_path);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmake_pg_path(&command, \"pg_rewind\");\n\t\t\tappendPQExpBufferStr(&command,\n\t\t\t\t\t\t\t\t \" -D \");\n\t\t}\n\n\t\tappendShellString(&command,\n\t\t\t\t\t\t  config_file_options.data_directory);\n\n\t\tappendPQExpBuffer(&command,\n\t\t\t\t\t\t  \" --source-server='%s'\",\n\t\t\t\t\t\t  primary_node_record.conninfo);\n\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(_(\"pg_rewind would now be executed\"));\n\t\t\tlog_detail(_(\"pg_rewind command is:\\n  %s\"),\n\t\t\t\t\t\t command.data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_notice(_(\"executing pg_rewind\"));\n\t\t\tlog_detail(_(\"pg_rewind command is \\\"%s\\\"\"),\n\t\t\t\t\t   command.data);\n\n\t\t\t/*\n\t\t\t * In Pg13 and later, pg_rewind will attempt to start up a server which\n\t\t\t * was not cleanly shut down in single user mode. This will fail if\n\t\t\t * \"standby.signal\" is present. We'll remove it and restore it after\n\t\t\t * pg_rewind runs.\n\t\t\t */\n\t\t\tif (hide_standby_signal == true)\n\t\t\t{\n\t\t\t\tchar\t    standby_signal_file_path[MAXPGPATH] = \"\";\n\n\t\t\t\tlog_notice(_(\"temporarily removing \\\"standby.signal\\\"\"));\n\t\t\t\tlog_detail(_(\"this is required so pg_rewind can fix the unclean shutdown\"));\n\n\t\t\t\tmake_standby_signal_path(config_file_options.data_directory,\n\t\t\t\t\t\t\t\t\t\t standby_signal_file_path);\n\n\t\t\t\tif (unlink(standby_signal_file_path) < 0 && errno != ENOENT)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to remove \\\"standby.signal\\\" file in data directory \\\"%s\\\"\"),\n\t\t\t\t\t\t\t  standby_signal_file_path);\n\t\t\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\t\t\texit(ERR_REJOIN_FAIL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinitPQExpBuffer(&command_output);\n\n\t\t\tret = local_command(command.data,\n\t\t\t\t\t\t\t\t&command_output);\n\n\t\t\ttermPQExpBuffer(&command);\n\n\t\t\tif (hide_standby_signal == true)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Restore standby.signal if we previously removed it, regardless\n\t\t\t\t * of whether the pg_rewind operation failed.\n\t\t\t\t */\n\t\t\t\tlog_notice(_(\"recreating \\\"standby.signal\\\"\"));\n\t\t\t\twrite_standby_signal(config_file_options.data_directory);\n\t\t\t}\n\n\t\t\tif (ret == false)\n\t\t\t{\n\t\t\t\tlog_error(_(\"pg_rewind execution failed\"));\n\t\t\t\tlog_detail(\"%s\", command_output.data);\n\n\t\t\t\ttermPQExpBuffer(&command_output);\n\n\t\t\t\texit(ERR_REJOIN_FAIL);\n\t\t\t}\n\n\t\t\ttermPQExpBuffer(&command_output);\n\n\t\t\t/* Restore any previously archived config files */\n\t\t\t_do_node_restore_config();\n\n\t\t\tinitPQExpBuffer(&filebuf);\n\n\t\t\t/* remove any recovery.done file copied in by pg_rewind */\n\t\t\tappendPQExpBuffer(&filebuf,\n\t\t\t\t\t\t\t  \"%s/recovery.done\",\n\t\t\t\t\t\t\t  config_file_options.data_directory);\n\n\t\t\tif (stat(filebuf.data, &statbuf) == 0)\n\t\t\t{\n\t\t\t\tlog_verbose(LOG_INFO, _(\"deleting \\\"recovery.done\\\"\"));\n\n\t\t\t\tif (unlink(filebuf.data) == -1)\n\t\t\t\t{\n\t\t\t\t\tlog_warning(_(\"unable to delete \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\tfilebuf.data);\n\t\t\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\t\t}\n\t\t\t}\n\t\t\ttermPQExpBuffer(&filebuf);\n\n\t\t\t/*\n\t\t\t * Delete any replication slots copied in by pg_rewind.\n\t\t\t *\n\t\t\t * TODO:\n\t\t\t *  - from PostgreSQL 11, this will be handled by pg_rewind, so\n\t\t\t *    we can skip this step from that version; see commit\n\t\t\t *    266b6acb312fc440c1c1a2036aa9da94916beac6\n\t\t\t *  - possibly delete contents of various other directories\n\t\t\t *    as per the above commit for pre-PostgreSQL 11\n\t\t\t */\n\t\t\t{\n\t\t\t\tPQExpBufferData slotdir_path;\n\t\t\t\tDIR\t\t\t  *slotdir;\n\t\t\t\tstruct dirent *slotdir_ent;\n\n\t\t\t\tinitPQExpBuffer(&slotdir_path);\n\n\t\t\t\tappendPQExpBuffer(&slotdir_path,\n\t\t\t\t\t\t\t\t  \"%s/pg_replslot\",\n\t\t\t\t\t\t\t\t  config_file_options.data_directory);\n\n\t\t\t\tslotdir = opendir(slotdir_path.data);\n\n\t\t\t\tif (slotdir == NULL)\n\t\t\t\t{\n\t\t\t\t\tlog_warning(_(\"unable to open replication slot directory \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\tslotdir_path.data);\n\t\t\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\twhile ((slotdir_ent = readdir(slotdir)) != NULL) {\n\t\t\t\t\t\tstruct stat local_statbuf;\n\t\t\t\t\t\tPQExpBufferData slotdir_ent_path;\n\n\t\t\t\t\t\tif (strcmp(slotdir_ent->d_name, \".\") == 0 || strcmp(slotdir_ent->d_name, \"..\") == 0)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tinitPQExpBuffer(&slotdir_ent_path);\n\n\t\t\t\t\t\tappendPQExpBuffer(&slotdir_ent_path,\n\t\t\t\t\t\t\t\t\t\t  \"%s/%s\",\n\t\t\t\t\t\t\t\t\t\t  slotdir_path.data,\n\t\t\t\t\t\t\t\t\t\t  slotdir_ent->d_name);\n\n\t\t\t\t\t\tif (stat(slotdir_ent_path.data, &local_statbuf) == 0 && !S_ISDIR(local_statbuf.st_mode))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttermPQExpBuffer(&slotdir_ent_path);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlog_debug(\"deleting slot directory \\\"%s\\\"\", slotdir_ent_path.data);\n\t\t\t\t\t\tif (rmdir_recursive(slotdir_ent_path.data) != 0 && errno != EEXIST)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog_warning(_(\"unable to delete replication slot directory \\\"%s\\\"\"), slotdir_ent_path.data);\n\t\t\t\t\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\t\t\t\t\tlog_hint(_(\"directory may need to be manually removed\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttermPQExpBuffer(&slotdir_ent_path);\n\t\t\t\t\t}\n\n\t\t\t\t\tclosedir(slotdir);\n\t\t\t\t}\n\t\t\t\ttermPQExpBuffer(&slotdir_path);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"prerequisites for executing NODE REJOIN are met\"));\n\t\texit(SUCCESS);\n\t}\n\n\tinitPQExpBuffer(&follow_output);\n\n\t/*\n\t * do_standby_follow_internal() can handle situations where the follow\n\t * target is not the primary, so requires database handles to both\n\t * (even if they point to the same node). For the time being,\n\t * \"node rejoin\" will only attach a standby to the primary.\n\t */\n\tsuccess = do_standby_follow_internal(primary_conn,\n\t\t\t\t\t\t\t\t\t\t primary_conn,\n\t\t\t\t\t\t\t\t\t\t &primary_node_record,\n\t\t\t\t\t\t\t\t\t\t &follow_output,\n\t\t\t\t\t\t\t\t\t\t ERR_REJOIN_FAIL,\n\t\t\t\t\t\t\t\t\t\t &follow_error_code);\n\n\tif (success == false)\n\t{\n\t\tlog_error(_(\"NODE REJOIN failed\"));\n\n\t\tif (strlen(follow_output.data))\n\t\t\tlog_detail(\"%s\", follow_output.data);\n\n\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t  \"node_rejoin\",\n\t\t\t\t\t\t\t\t  success,\n\t\t\t\t\t\t\t\t  follow_output.data);\n\n\t\tPQfinish(primary_conn);\n\n\t\ttermPQExpBuffer(&follow_output);\n\t\texit(follow_error_code);\n\t}\n\n\t/*\n\t * Actively check that node actually started and connected to primary,\n\t * if not exit with ERR_REJOIN_FAIL.\n\t *\n\t * This check can be overridden with -W/--no-wait, in which case a one-time\n\t * check will be carried out.\n\t */\n\tif (runtime_options.no_wait == false)\n\t{\n\t\tstandy_join_status join_success = check_standby_join(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t &primary_node_record,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t &local_node_record);\n\n\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t  \"node_rejoin\",\n\t\t\t\t\t\t\t\t  join_success == JOIN_SUCCESS ? true : false,\n\t\t\t\t\t\t\t\t  follow_output.data);\n\n\t\tif (join_success != JOIN_SUCCESS)\n\t\t{\n\t\t\ttermPQExpBuffer(&follow_output);\n\t\t\tlog_error(_(\"NODE REJOIN failed\"));\n\n\t\t\tif (join_success == JOIN_FAIL_NO_PING) {\n\t\t\t\tlog_detail(_(\"local node \\\"%s\\\" did not become available start after %i seconds\"),\n\t\t\t\t\t\t   config_file_options.node_name,\n\t\t\t\t\t\t   config_file_options.node_rejoin_timeout);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlog_detail(_(\"no active record for local node \\\"%s\\\" found in node \\\"%s\\\"'s \\\"pg_stat_replication\\\" table\"),\n\t\t\t\t\t\t   config_file_options.node_name,\n\t\t\t\t\t\t   primary_node_record.node_name);\n\t\t\t}\n\t\t\tlog_hint(_(\"check the PostgreSQL log on the local node\"));\n\n\t\t\texit(ERR_REJOIN_FAIL);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* -W/--no-wait provided - check once */\n\t\tNodeAttached node_attached = is_downstream_node_attached(primary_conn, config_file_options.node_name, NULL);\n\t\tif (node_attached == NODE_ATTACHED)\n\t\t\tsuccess = true;\n\t}\n\n\t/*\n\t * Handle replication slots:\n\t *  - if a slot for the new upstream exists, delete that\n\t *  - warn about any other inactive replication slots\n\t */\n\tif (runtime_options.force_rewind_used == false && config_file_options.use_replication_slots)\n\t{\n\t\tPGconn\t   *local_conn = NULL;\n\t\tlocal_conn = establish_db_connection(config_file_options.conninfo, false);\n\n\t\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t\t{\n\t\t\tlog_warning(_(\"unable to connect to local node to check replication slot status\"));\n\t\t\tlog_hint(_(\"execute \\\"repmgr node check\\\" to check inactive slots and drop manually if necessary\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tKeyValueList inactive_replication_slots = {NULL, NULL};\n\t\t\tint inactive_count = 0;\n\t\t\tPQExpBufferData slotinfo;\n\n\t\t\tdrop_replication_slot_if_exists(local_conn,\n\t\t\t\t\t\t\t\t\t\t\tconfig_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t\tprimary_node_record.slot_name);\n\n\t\t\t(void) get_inactive_replication_slots(local_conn, &inactive_replication_slots);\n\n\t\t\tinitPQExpBuffer(&slotinfo);\n\t\t\tfor (cell = inactive_replication_slots.head; cell; cell = cell->next)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&slotinfo,\n\t\t\t\t\t\t\t\t  \"  - %s (%s)\", cell->key, cell->value);\n\t\t\t\tinactive_count++;\n\t\t\t}\n\n\t\t\tif (inactive_count > 0)\n\t\t\t{\n\t\t\t\tlog_warning(_(\"%i inactive replication slots detected\"), inactive_count);\n\t\t\t\tlog_detail(_(\"inactive replication slots:\\n%s\"), slotinfo.data);\n\t\t\t\tlog_hint(_(\"these replication slots may need to be removed manually\"));\n\t\t\t}\n\n\t\t\ttermPQExpBuffer(&slotinfo);\n\n\t\t\tPQfinish(local_conn);\n\t\t}\n\t}\n\n\tif (success == true)\n\t{\n\t\tlog_notice(_(\"NODE REJOIN successful\"));\n\t\tlog_detail(\"%s\", follow_output.data);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * if we reach here, no record found in upstream node's pg_stat_replication\n\t\t */\n\t\tlog_notice(_(\"NODE REJOIN has completed but node is not yet reattached to upstream\"));\n\t\tlog_hint(_(\"you will need to manually check the node's replication status\"));\n\t}\n\ttermPQExpBuffer(&follow_output);\n\n\treturn;\n}\n\n\n/*\n * Currently for testing purposes only, not documented;\n * use at own risk!\n */\n\nvoid\ndo_node_control(void)\n{\n\tPGconn\t   *conn = NULL;\n\tpid_t\t    wal_receiver_pid = UNKNOWN_PID;\n\tconn = establish_db_connection(config_file_options.conninfo, true);\n\n\tif (runtime_options.disable_wal_receiver == true)\n\t{\n\t\twal_receiver_pid = disable_wal_receiver(conn);\n\n\t\tPQfinish(conn);\n\n\t\tif (wal_receiver_pid == UNKNOWN_PID)\n\t\t\texit(ERR_BAD_CONFIG);\n\n\t\texit(SUCCESS);\n\t}\n\n\tif (runtime_options.enable_wal_receiver == true)\n\t{\n\t\twal_receiver_pid = enable_wal_receiver(conn, true);\n\n\t\tPQfinish(conn);\n\n\t\tif (wal_receiver_pid == UNKNOWN_PID)\n\t\t\texit(ERR_BAD_CONFIG);\n\n\t\texit(SUCCESS);\n\t}\n\n\tlog_error(_(\"no option provided\"));\n\n\tPQfinish(conn);\n}\n\n\n/*\n * For \"internal\" use by `node rejoin` on the local node when\n * called by \"standby switchover\" from the remote node.\n *\n * This archives any configuration files in the data directory, which may be\n * overwritten by pg_rewind.\n *\n * Requires configuration file, optionally --config-archive-dir\n */\nstatic void\n_do_node_archive_config(void)\n{\n\tPQExpBufferData\t\tarchive_dir;\n\tstruct stat statbuf;\n\tstruct dirent *arcdir_ent;\n\tDIR\t\t   *arcdir;\n\n\tKeyValueList config_files = {NULL, NULL};\n\tKeyValueListCell *cell = NULL;\n\tint\t\t\tcopied_count = 0;\n\n\tinitPQExpBuffer(&archive_dir);\n\tformat_archive_dir(&archive_dir);\n\n\t/* sanity-check directory path */\n\tif (stat(archive_dir.data, &statbuf) == -1)\n\t{\n\t\tif (errno != ENOENT)\n\t\t{\n\t\t\tlog_error(_(\"error encountered when checking archive directory \\\"%s\\\"\"),\n\t\t\t\t\t  archive_dir.data);\n\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\ttermPQExpBuffer(&archive_dir);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\t/* attempt to create and open the directory */\n\t\tif (mkdir(archive_dir.data, S_IRWXU) != 0 && errno != EEXIST)\n\t\t{\n\t\t\tlog_error(_(\"unable to create temporary archive directory \\\"%s\\\"\"),\n\t\t\t\t\t  archive_dir.data);\n\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\ttermPQExpBuffer(&archive_dir);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_verbose(LOG_INFO, \"temporary archive directory \\\"%s\\\" created\", archive_dir.data);\n\t\t}\n\t}\n\telse if (!S_ISDIR(statbuf.st_mode))\n\t{\n\t\tlog_error(_(\"\\\"%s\\\" exists but is not a directory\"),\n\t\t\t\t  archive_dir.data);\n\t\ttermPQExpBuffer(&archive_dir);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tarcdir = opendir(archive_dir.data);\n\n\t/* always attempt to open the directory */\n\tif (arcdir == NULL)\n\t{\n\t\tlog_error(_(\"unable to open archive directory \\\"%s\\\"\"),\n\t\t\t\t  archive_dir.data);\n\t\tlog_detail(\"%s\", strerror(errno));\n\t\ttermPQExpBuffer(&archive_dir);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tif (runtime_options.dry_run == false)\n\t{\n\n\t\t/*\n\t\t * attempt to remove any existing files in the directory\n\t\t * TODO: collate problem files into list\n\t\t */\n\t\twhile ((arcdir_ent = readdir(arcdir)) != NULL)\n\t\t{\n\t\t\tPQExpBufferData arcdir_ent_path;\n\n\t\t\tinitPQExpBuffer(&arcdir_ent_path);\n\n\t\t\tappendPQExpBuffer(&arcdir_ent_path,\n\t\t\t\t\t\t\t  \"%s/%s\",\n\t\t\t\t\t\t\t  archive_dir.data,\n\t\t\t\t\t\t\t  arcdir_ent->d_name);\n\n\t\t\tif (stat(arcdir_ent_path.data, &statbuf) == 0 && !S_ISREG(statbuf.st_mode))\n\t\t\t{\n\t\t\t\ttermPQExpBuffer(&arcdir_ent_path);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (unlink(arcdir_ent_path.data) == -1)\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to delete file in temporary archive directory\"));\n\t\t\t\tlog_detail(_(\"file is:  \\\"%s\\\"\"), arcdir_ent_path.data);\n\t\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\t\tclosedir(arcdir);\n\t\t\t\ttermPQExpBuffer(&arcdir_ent_path);\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\n\t\t\ttermPQExpBuffer(&arcdir_ent_path);\n\t\t}\n\t}\n\n\tclosedir(arcdir);\n\n\n\t/*\n\t * extract list of config files from --config-files\n\t */\n\t{\n\t\tint\t\t\ti = 0;\n\t\tint\t\t\tj = 0;\n\t\tint\t\t\tconfig_file_len = strlen(runtime_options.config_files);\n\n\t\tchar\t\tfilenamebuf[MAXPGPATH] = \"\";\n\t\tPQExpBufferData\t\tpathbuf;\n\n\t\tfor (j = 0; j < config_file_len; j++)\n\t\t{\n\t\t\tif (runtime_options.config_files[j] == ',')\n\t\t\t{\n\t\t\t\tint\t\t\tfilename_len = j - i;\n\n\t\t\t\tif (filename_len >= MAXPGPATH)\n\t\t\t\t\tfilename_len = MAXPGPATH - 1;\n\n\t\t\t\tstrncpy(filenamebuf, runtime_options.config_files + i, filename_len);\n\n\t\t\t\tfilenamebuf[filename_len] = '\\0';\n\n\t\t\t\tinitPQExpBuffer(&pathbuf);\n\n\t\t\t\tappendPQExpBuffer(&pathbuf,\n\t\t\t\t\t\t\t\t  \"%s/%s\",\n\t\t\t\t\t\t\t\t  config_file_options.data_directory,\n\t\t\t\t\t\t\t\t  filenamebuf);\n\n\t\t\t\tkey_value_list_set(&config_files,\n\t\t\t\t\t\t\t\t   filenamebuf,\n\t\t\t\t\t\t\t\t   pathbuf.data);\n\t\t\t\ttermPQExpBuffer(&pathbuf);\n\t\t\t\ti = j + 1;\n\t\t\t}\n\t\t}\n\n\t\tif (i < config_file_len)\n\t\t{\n\t\t\tint\t\t\tfilename_len = config_file_len - i;\n\n\t\t\tstrncpy(filenamebuf, runtime_options.config_files + i, filename_len);\n\n\t\t\tfilenamebuf[filename_len] = '\\0';\n\n\t\t\tinitPQExpBuffer(&pathbuf);\n\t\t\tappendPQExpBuffer(&pathbuf,\n\t\t\t\t\t\t\t  \"%s/%s\",\n\t\t\t\t\t\t\t  config_file_options.data_directory,\n\t\t\t\t\t\t\t  filenamebuf);\n\n\t\t\tkey_value_list_set(&config_files,\n\t\t\t\t\t\t\t   filenamebuf,\n\t\t\t\t\t\t\t   pathbuf.data);\n\t\t\ttermPQExpBuffer(&pathbuf);\n\t\t}\n\t}\n\n\n\tfor (cell = config_files.head; cell; cell = cell->next)\n\t{\n\t\tPQExpBufferData dest_file;\n\n\t\tinitPQExpBuffer(&dest_file);\n\n\t\tappendPQExpBuffer(&dest_file,\n\t\t\t\t\t\t  \"%s/%s\",\n\t\t\t\t\t\t  archive_dir.data,\n\t\t\t\t\t\t  cell->key);\n\n\t\tif (stat(cell->value, &statbuf) == -1)\n\t\t{\n\t\t\tlog_warning(_(\"specified file \\\"%s\\\" not found, skipping\"),\n\t\t\t\t\t\tcell->value);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (runtime_options.dry_run == true)\n\t\t\t{\n\t\t\t\tlog_info(\"file \\\"%s\\\" would be copied to \\\"%s\\\"\",\n\t\t\t\t\t\t cell->key, dest_file.data);\n\t\t\t\tcopied_count++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_verbose(LOG_DEBUG, \"copying \\\"%s\\\" to \\\"%s\\\"\",\n\t\t\t\t\t\t\tcell->key, dest_file.data);\n\t\t\t\tcopy_file(cell->value, dest_file.data);\n\t\t\t\tcopied_count++;\n\t\t\t}\n\t\t}\n\n\t\ttermPQExpBuffer(&dest_file);\n\t}\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tlog_verbose(LOG_INFO, _(\"%i files would have been copied to \\\"%s\\\"\"),\n\t\t\t\t\tcopied_count, archive_dir.data);\n\t}\n\telse\n\t{\n\t\tlog_verbose(LOG_INFO, _(\"%i files copied to \\\"%s\\\"\"),\n\t\t\t\t\tcopied_count, archive_dir.data);\n\t}\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\t/*\n\t\t * Delete directory in --dry-run mode  - it should be empty unless it's been\n\t\t * interfered with for some reason, in which case manual intervention is\n\t\t * required\n\t\t */\n\t\tif (rmdir(archive_dir.data) != 0 && errno != EEXIST)\n\t\t{\n\t\t\tlog_warning(_(\"unable to delete directory \\\"%s\\\"\"), archive_dir.data);\n\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\tlog_hint(_(\"directory may need to be manually removed\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_verbose(LOG_INFO, \"temporary archive directory \\\"%s\\\" deleted\", archive_dir.data);\n\t\t}\n\t}\n\n\ttermPQExpBuffer(&archive_dir);\n}\n\n\n/*\n * Intended mainly for \"internal\" use by `standby switchover`, which\n * calls this on the target server to restore any configuration files\n * to the data directory, which may have been overwritten by an operation\n * like pg_rewind\n *\n * Not designed to be called if the instance is running, but does\n * not currently check.\n *\n * Requires -D/--pgdata, optionally --config-archive-dir\n *\n * Removes --config-archive-dir after successful copy\n */\n\nstatic void\n_do_node_restore_config(void)\n{\n\tPQExpBufferData\t\tarchive_dir;\n\n\tDIR\t\t   *arcdir;\n\tstruct dirent *arcdir_ent;\n\tint\t\t\tcopied_count = 0;\n\tbool\t\tcopy_ok = true;\n\n\tinitPQExpBuffer(&archive_dir);\n\n\tformat_archive_dir(&archive_dir);\n\n\tarcdir = opendir(archive_dir.data);\n\n\tif (arcdir == NULL)\n\t{\n\t\tlog_error(_(\"unable to open archive directory \\\"%s\\\"\"),\n\t\t\t\t  archive_dir.data);\n\t\tlog_detail(\"%s\", strerror(errno));\n\t\ttermPQExpBuffer(&archive_dir);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\twhile ((arcdir_ent = readdir(arcdir)) != NULL)\n\t{\n\t\tstruct stat statbuf;\n\t\tPQExpBufferData\t\tsrc_file_path;\n\t\tPQExpBufferData\t\tdest_file_path;\n\n\t\tinitPQExpBuffer(&src_file_path);\n\n\t\tappendPQExpBuffer(&src_file_path,\n\t\t\t\t\t\t  \"%s/%s\",\n\t\t\t\t\t\t  archive_dir.data,\n\t\t\t\t\t\t  arcdir_ent->d_name);\n\n\t\t/* skip non-files */\n\t\tif (stat(src_file_path.data, &statbuf) == 0 && !S_ISREG(statbuf.st_mode))\n\t\t{\n\t\t\ttermPQExpBuffer(&src_file_path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinitPQExpBuffer(&dest_file_path);\n\n\t\tappendPQExpBuffer(&dest_file_path,\n\t\t\t\t\t\t  \"%s/%s\",\n\t\t\t\t\t\t  config_file_options.data_directory,\n\t\t\t\t\t\t  arcdir_ent->d_name);\n\n\t\tlog_verbose(LOG_DEBUG, \"copying \\\"%s\\\" to \\\"%s\\\"\",\n\t\t\t\t\tsrc_file_path.data, dest_file_path.data);\n\n\t\tif (copy_file(src_file_path.data, dest_file_path.data) == false)\n\t\t{\n\t\t\tcopy_ok = false;\n\t\t\tlog_warning(_(\"unable to copy \\\"%s\\\" to \\\"%s\\\"\"),\n\t\t\t\t\t\tarcdir_ent->d_name, runtime_options.data_dir);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tunlink(src_file_path.data);\n\t\t\tcopied_count++;\n\t\t}\n\n\t\ttermPQExpBuffer(&dest_file_path);\n\t\ttermPQExpBuffer(&src_file_path);\n\t}\n\n\tclosedir(arcdir);\n\n\tlog_notice(_(\"%i files copied to %s\"),\n\t\t\t   copied_count,\n\t\t\t   config_file_options.data_directory);\n\n\tif (copy_ok == false)\n\t{\n\t\tlog_warning(_(\"unable to copy all files from \\\"%s\\\"\"), archive_dir.data);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Finally, delete directory - it should be empty unless it's been\n\t\t * interfered with for some reason, in which case manual intervention is\n\t\t * required\n\t\t */\n\t\tif (rmdir(archive_dir.data) != 0 && errno != EEXIST)\n\t\t{\n\t\t\tlog_warning(_(\"unable to delete directory \\\"%s\\\"\"), archive_dir.data);\n\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\tlog_hint(_(\"directory may need to be manually removed\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_verbose(LOG_INFO, \"directory \\\"%s\\\" deleted\", archive_dir.data);\n\t\t}\n\t}\n\n\ttermPQExpBuffer(&archive_dir);\n\n\treturn;\n}\n\n\nstatic void\nformat_archive_dir(PQExpBufferData *archive_dir)\n{\n\tappendPQExpBuffer(archive_dir,\n\t\t\t\t\t  \"%s/repmgr-config-archive-%s\",\n\t\t\t\t\t  runtime_options.config_archive_dir,\n\t\t\t\t\t  config_file_options.node_name);\n\n\tlog_verbose(LOG_DEBUG, \"using archive directory \\\"%s\\\"\", archive_dir->data);\n}\n\n\nstatic bool\ncopy_file(const char *src_file, const char *dest_file)\n{\n\tFILE\t   *ptr_old,\n\t\t\t   *ptr_new;\n\tint\t\t\ta = 0;\n\n\tptr_old = fopen(src_file, \"r\");\n\n\tif (ptr_old == NULL)\n\t\treturn false;\n\n\tptr_new = fopen(dest_file, \"w\");\n\n\tif (ptr_new == NULL)\n\t{\n\t\tfclose(ptr_old);\n\t\treturn false;\n\t}\n\n\tchmod(dest_file, S_IRUSR | S_IWUSR);\n\n\twhile (1)\n\t{\n\t\ta = fgetc(ptr_old);\n\n\t\tif (!feof(ptr_old))\n\t\t{\n\t\t\tfputc(a, ptr_new);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(ptr_new);\n\tfclose(ptr_old);\n\n\treturn true;\n}\n\n\nstatic const char *\noutput_repmgrd_status(CheckStatus status)\n{\n\tswitch (status)\n\t{\n\t\tcase CHECK_STATUS_OK:\n\t\t\treturn \"repmgrd running\";\n\t\tcase CHECK_STATUS_WARNING:\n\t\t\treturn \"repmgrd running but paused\";\n\t\tcase CHECK_STATUS_CRITICAL:\n\t\t\treturn \"repmgrd not running\";\n\t\tcase CHECK_STATUS_UNKNOWN:\n\t\t\treturn \"repmgrd status unknown\";\n\t}\n\n\treturn \"UNKNOWN\";\n}\n\n\nvoid\ndo_node_help(void)\n{\n\tprint_help_header();\n\n\tprintf(_(\"Usage:\\n\"));\n\tprintf(_(\"    %s [OPTIONS] node status\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] node check\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] node rejoin\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] node service\\n\"), progname());\n\tputs(\"\");\n\n\tprintf(_(\"NODE STATUS\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"node status\\\" displays an overview of a node's basic information and replication status.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  Configuration file required, runs on local node only.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"    --csv                 emit output as CSV\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"NODE CHECK\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"node check\\\" performs some health checks on a node from a replication perspective.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  Configuration file required, runs on local node only.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  Connection options:\\n\"));\n\tprintf(_(\"    -S, --superuser=USERNAME  superuser to use, if repmgr user is not superuser\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  Output options:\\n\"));\n\tprintf(_(\"    --csv                     emit output as CSV (not available for individual check output)\\n\"));\n\tprintf(_(\"    --nagios                  emit output in Nagios format (individual check output only)\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  Following options check an individual status:\\n\"));\n\tprintf(_(\"    --archive-ready           number of WAL files ready for archiving\\n\"));\n\tprintf(_(\"    --downstream              whether all downstream nodes are connected\\n\"));\n\tprintf(_(\"    --upstream                whether the node is connected to its upstream\\n\"));\n\tprintf(_(\"    --replication-lag         replication lag in seconds (standbys only)\\n\"));\n\tprintf(_(\"    --role                    check node has expected role\\n\"));\n\tprintf(_(\"    --slots                   check for inactive replication slots\\n\"));\n\tprintf(_(\"    --missing-slots           check for missing replication slots\\n\"));\n\tprintf(_(\"    --repmgrd                 check if repmgrd is running\\n\"));\n\tprintf(_(\"    --data-directory-config   check repmgr's data directory configuration\\n\"));\n\n\tputs(\"\");\n\n\tprintf(_(\"NODE REJOIN\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"node rejoin\\\" enables a dormant (stopped) node to be rejoined to the replication cluster.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  Configuration file required, runs on local node only.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"    --dry-run               check that the prerequisites are met for rejoining the node\\n\" \\\n\t\t\t \"                              (including usability of \\\"pg_rewind\\\" if requested)\\n\"));\n\tprintf(_(\"    --force-rewind[=VALUE]  execute \\\"pg_rewind\\\" if necessary\\n\"));\n\tprintf(_(\"                              (PostgreSQL 9.4 - provide full \\\"pg_rewind\\\" path)\\n\"));\n\n\tprintf(_(\"    --config-files          comma-separated list of configuration files to retain\\n\" \\\n\t\t\t \"                            after executing \\\"pg_rewind\\\"\\n\"));\n\tprintf(_(\"    --config-archive-dir    directory to temporarily store retained configuration files\\n\" \\\n\t\t\t \"                              (default: /tmp)\\n\"));\n\tprintf(_(\"    -W, --no-wait           don't wait for the node to rejoin cluster\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"NODE SERVICE\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"node service\\\" executes a system service command to stop/start/restart/reload a node\\n\" \\\n\t\t\t \"                   or optionally display which command would be executed\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  Configuration file required, runs on local node only.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"    --dry-run                 show what action would be performed, but don't execute it\\n\"));\n\tprintf(_(\"    --action                  action to perform (one of \\\"start\\\", \\\"stop\\\", \\\"restart\\\" or \\\"reload\\\")\\n\"));\n\tprintf(_(\"    --list-actions            show what command would be performed for each action\\n\"));\n\tprintf(_(\"    --checkpoint              issue a CHECKPOINT before stopping or restarting the node\\n\"));\n\tprintf(_(\"    -S, --superuser=USERNAME  superuser to use, if repmgr user is not superuser\\n\"));\n\n\tputs(\"\");\n\n\tprintf(_(\"%s home page: <%s>\\n\"), \"repmgr\", REPMGR_URL);\n}\n"
        },
        {
          "name": "repmgr-action-node.h",
          "type": "blob",
          "size": 1.0205078125,
          "content": "/*\n * repmgr-action-node.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _REPMGR_ACTION_NODE_H_\n#define _REPMGR_ACTION_NODE_H_\n\nextern void do_node_status(void);\nextern void do_node_check(void);\n\nextern void do_node_rejoin(void);\nextern void do_node_service(void);\nextern void do_node_control(void);\n\nextern void do_node_help(void);\n\n#endif\t\t\t\t\t\t\t/* _REPMGR_ACTION_NODE_H_ */\n"
        },
        {
          "name": "repmgr-action-primary.c",
          "type": "blob",
          "size": 16.982421875,
          "content": "/*\n * repmgr-action-primary.c\n *\n * Implements primary actions for the repmgr command line utility\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"repmgr.h\"\n\n#include \"repmgr-client-global.h\"\n#include \"repmgr-action-primary.h\"\n\n\n/*\n * do_primary_register()\n *\n * Event(s):\n *  - primary_register\n */\nvoid\ndo_primary_register(void)\n{\n\tPGconn\t   *conn = NULL;\n\tPGconn\t   *primary_conn = NULL;\n\tint\t\t\tcurrent_primary_id = UNKNOWN_NODE_ID;\n\tRecoveryType recovery_type = RECTYPE_UNKNOWN;\n\tt_node_info node_info = T_NODE_INFO_INITIALIZER;\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\n\tbool\t\trecord_created = false;\n\n\tPQExpBufferData event_description;\n\n\tlog_info(_(\"connecting to primary database...\"));\n\n\tconn = establish_db_connection(config_file_options.conninfo, true);\n\tlog_verbose(LOG_INFO, _(\"connected to server, checking its state\"));\n\n\t/* verify that node is running a supported server version */\n\tcheck_server_version(conn, \"primary\", true, NULL);\n\n\t/* check that node is actually a primary */\n\trecovery_type = get_recovery_type(conn);\n\n\tif (recovery_type != RECTYPE_PRIMARY)\n\t{\n\t\tif (recovery_type == RECTYPE_STANDBY)\n\t\t{\n\t\t\tlog_error(_(\"server is in standby mode and cannot be registered as a primary\"));\n\t\t\tPQfinish(conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tlog_error(_(\"unable to determine server's recovery type\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_DB_CONN);\n\t}\n\n\tlog_verbose(LOG_INFO, _(\"server is not in recovery\"));\n\n\t/*\n\t * create the repmgr extension if it doesn't already exist;\n\t * note that create_repmgr_extension() will take into account\n\t * the --dry-run option\n\t */\n\tif (!create_repmgr_extension(conn))\n\t{\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * In --dry-run mode we can't proceed any further as the following code\n\t * attempts to query the repmgr metadata, which won't exist until the\n\t * extension is installed\n\t */\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tPQfinish(conn);\n\t\treturn;\n\t}\n\n\tinitialize_voting_term(conn);\n\n\tbegin_transaction(conn);\n\n\t/*\n\t * Check for an active primary node record with a different ID. This\n\t * shouldn't happen, but could do if an existing primary was shut down\n\t * without being unregistered.\n\t */\n\tcurrent_primary_id = get_primary_node_id(conn);\n\tif (current_primary_id != NODE_NOT_FOUND && current_primary_id != config_file_options.node_id)\n\t{\n\t\tlog_debug(\"current active primary node ID is %i\", current_primary_id);\n\t\tprimary_conn = establish_primary_db_connection(conn, false);\n\n\t\tif (PQstatus(primary_conn) == CONNECTION_OK)\n\t\t{\n\t\t\tif (get_recovery_type(primary_conn) == RECTYPE_PRIMARY)\n\t\t\t{\n\t\t\t\tlog_error(_(\"there is already an active registered primary (ID: %i) in this cluster\"),\n\t\t\t\t\t\t  current_primary_id);\n\t\t\t\tlog_detail(_(\"a streaming replication cluster can have only one primary node\"));\n\n\t\t\t\tlog_hint(_(\"ensure this node is shut down before registering a new primary\"));\n\t\t\t\tPQfinish(primary_conn);\n\t\t\t\trollback_transaction(conn);\n\t\t\t\tPQfinish(conn);\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\n\t\t\tlog_warning(_(\"node %is is registered as primary but running as a standby\"),\n\t\t\t\t\t\t  current_primary_id);\n\t\t\tPQfinish(primary_conn);\n\t\t}\n\n\t\tlog_notice(_(\"setting node %i's node record to inactive\"),\n\t\t\t\t\t\t  current_primary_id);\n\t\tupdate_node_record_set_active(conn, current_primary_id, false);\n\t}\n\n\t/*\n\t * Check whether there's an existing record for this node, and update it\n\t * if --force set\n\t */\n\n\trecord_status = get_node_record(conn, config_file_options.node_id, &node_info);\n\n\tif (record_status == RECORD_FOUND)\n\t{\n\t\tif (!runtime_options.force)\n\t\t{\n\t\t\tlog_error(_(\"this node is already registered\"));\n\t\t\tlog_hint(_(\"use -F/--force to overwrite the existing node record\"));\n\t\t\trollback_transaction(conn);\n\t\t\tPQfinish(conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\tinit_node_record(&node_info);\n\n\t/* set type to \"primary\" and unset upstream_node_id */\n\tnode_info.type = PRIMARY;\n\tnode_info.upstream_node_id = NO_UPSTREAM_NODE;\n\n\tinitPQExpBuffer(&event_description);\n\n\tif (record_status == RECORD_FOUND)\n\t{\n\t\trecord_created = update_node_record(conn,\n\t\t\t\t\t\t\t\t\t\t\t\"primary register\",\n\t\t\t\t\t\t\t\t\t\t\t&node_info);\n\t\tif (record_created == true)\n\t\t{\n\t\t\tappendPQExpBufferStr(&event_description,\n\t\t\t\t\t\t\t\t \"existing primary record updated\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappendPQExpBuffer(&event_description,\n\t\t\t\t\t\t\t  \"error encountered while updating primary record:\\n%s\",\n\t\t\t\t\t\t\t  PQerrorMessage(conn));\n\t\t}\n\n\t}\n\telse\n\t{\n\t\trecord_created = create_node_record(conn,\n\t\t\t\t\t\t\t\t\t\t\t\"primary register\",\n\t\t\t\t\t\t\t\t\t\t\t&node_info);\n\t\tif (record_created == false)\n\t\t{\n\t\t\tappendPQExpBuffer(&event_description,\n\t\t\t\t\t\t\t  \"error encountered while creating primary record:\\n%s\",\n\t\t\t\t\t\t\t  PQerrorMessage(conn));\n\t\t}\n\n\t}\n\n\tif (record_created == false)\n\t{\n\t\trollback_transaction(conn);\n\t}\n\telse\n\t{\n\t\tcommit_transaction(conn);\n\t}\n\n\t/* Log the event */\n\tcreate_event_notification(\n\t\t\t\t\t\t\t  conn,\n\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t  \"primary_register\",\n\t\t\t\t\t\t\t  record_created,\n\t\t\t\t\t\t\t  event_description.data);\n\n\ttermPQExpBuffer(&event_description);\n\n\tPQfinish(conn);\n\n\tif (record_created == false)\n\t{\n\t\tlog_notice(_(\"unable to register primary node - see preceding messages\"));\n\t\texit(ERR_DB_QUERY);\n\t}\n\n\tif (record_status == RECORD_FOUND)\n\t{\n\t\tlog_notice(_(\"primary node record (ID: %i) updated\"),\n\t\t\t\t   config_file_options.node_id);\n\t}\n\telse\n\t{\n\t\tlog_notice(_(\"primary node record (ID: %i) registered\"),\n\t\t\t\t   config_file_options.node_id);\n\t}\n\n\treturn;\n}\n\nstatic inline void reset_node_info(t_node_info *info)\n{\n\tinfo->node_id \t\t\t\t\t\t= NODE_NOT_FOUND;\n\tinfo->upstream_node_id\t\t\t\t= NO_UPSTREAM_NODE;\n\tinfo->type\t\t\t\t \t\t\t= UNKNOWN;\n\tinfo->node_name[0]\t\t\t\t\t= '\\0';\n\tinfo->upstream_node_name[0]\t\t\t= '\\0';\n\tinfo->conninfo[0]\t\t\t\t\t= '\\0';\n\tinfo->repluser[0]\t\t\t\t\t= '\\0';\n\tinfo->priority \t\t\t\t\t\t= DEFAULT_PRIORITY;\n\tinfo->active\t\t\t\t\t\t= true;\n\tinfo->slot_name[0]\t\t\t\t\t= '\\0';\n\tinfo->config_file[0]\t\t\t\t= '\\0';\n\tinfo->last_wal_receive_lsn\t\t\t= InvalidXLogRecPtr;\n\tinfo->node_status\t\t\t\t\t= NODE_STATUS_UNKNOWN;\n\tinfo->recovery_type\t\t\t\t\t= RECTYPE_UNKNOWN;\n\tinfo->monitoring_state\t\t\t\t= MS_NORMAL;\n\tinfo->conn\t\t\t\t\t\t\t= NULL;\n\tinfo->details[0]\t\t\t\t\t= '\\0';\n\tinfo->reachable\t\t\t\t\t\t= true;\n\tinfo->attached\t\t\t\t\t\t= true;\n\t/* various statistics */\n\tinfo->max_wal_senders\t\t\t\t= -1;\n\tinfo->attached_wal_receivers\t\t= -1;\n\tinfo->max_replication_slots\t\t\t= -1;\n\tinfo->total_replication_slots\t\t= -1;\n\tinfo->active_replication_slots\t\t= -1;\n\tinfo->inactive_replication_slots\t= -1;\n\tinfo->replication_info\t\t\t\t= NULL;\n\n\tstrlcpy(info->location, DEFAULT_LOCATION, sizeof(info->location));\n}\n\n/*\n * do_primary_unregister()\n *\n * Event(s):\n *  - primary_unregister\n */\n\nvoid\ndo_primary_unregister(void)\n{\n\tPGconn\t   *primary_conn = NULL;\n\tPGconn\t   *local_conn = NULL;\n\tt_node_info local_node_info = T_NODE_INFO_INITIALIZER;\n\tt_node_info primary_node_info = T_NODE_INFO_INITIALIZER;\n\n\tt_node_info *target_node_info_ptr = NULL;\n\tPGconn\t   *target_node_conn = NULL;\n\n\tNodeInfoList downstream_nodes = T_NODE_INFO_LIST_INITIALIZER;\n\n\t/* We must be able to connect to the local node */\n\tlocal_conn = establish_db_connection(config_file_options.conninfo, true);\n\n\t/* Get local node record */\n\tget_local_node_record(local_conn, config_file_options.node_id, &local_node_info);\n\n\t/*\n\t * Obtain a connection to the current primary node - if this isn't\n\t * possible, abort as we won't be able to update the \"nodes\" table anyway.\n\t */\n\tprimary_conn = establish_primary_db_connection(local_conn, false);\n\n\tif (PQstatus(primary_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to connect to primary server\"));\n\n\t\tif (get_primary_node_record(local_conn, &primary_node_info) == true)\n\t\t{\n\t\t\tlog_detail(_(\"current primary registered as node \\\"%s\\\" (ID: %i, conninfo: \\\"%s\\\")\"),\n\t\t\t\t\t   primary_node_info.node_name,\n\t\t\t\t\t   primary_node_info.node_id,\n\t\t\t\t\t   primary_node_info.conninfo);\n\t\t}\n\n\t\tlog_hint(_(\"you may need to promote this standby or ask it to look for a new primary to follow\"));\n\t\tPQfinish(local_conn);\n\t\texit(ERR_DB_CONN);\n\t}\n\n\t/* Local connection no longer required */\n\tPQfinish(local_conn);\n\n\tif (get_primary_node_record(primary_conn, &primary_node_info) == false)\n\t{\n\t\tlog_error(_(\"unable to retrieve record for primary node\"));\n\t\tPQfinish(primary_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* Target node is local node? */\n\tif (target_node_info.node_id == UNKNOWN_NODE_ID)\n\t{\n\t\ttarget_node_info_ptr = &primary_node_info;\n\t}\n\telse if (target_node_info.node_id == config_file_options.node_id)\n\t{\n\t\ttarget_node_info_ptr = &local_node_info;\n\t}\n\t/* Target node is explicitly specified, and is not local node */\n\telse\n\t{\n\t\ttarget_node_info_ptr = &target_node_info;\n\t}\n\n\t/*\n\t * Sanity-check the target node is not a witness\n\t */\n\n\tif (target_node_info_ptr->type == WITNESS)\n\t{\n\t\tlog_error(_(\"node \\\"%s\\\" (ID: %i) is a witness server, unable to unregister\"),\n\t\t\t\t\t  target_node_info_ptr->node_name,\n\t\t\t\t\t  target_node_info_ptr->node_id);\n\t\tif (target_node_info_ptr->type == STANDBY)\n\t\t{\n\t\t\tlog_hint(_(\"the node can be unregistered with \\\"repmgr witness unregister\\\"\"));\n\t\t}\n\n\t\tPQfinish(primary_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * Check for downstream nodes - if any still defined, we won't be able to\n\t * delete the node record due to foreign key constraints.\n\t */\n\tget_downstream_node_records(primary_conn, target_node_info_ptr->node_id, &downstream_nodes);\n\n\tif (downstream_nodes.node_count > 0)\n\t{\n\t\tNodeInfoListCell *cell = NULL;\n\t\tPQExpBufferData detail;\n\n\t\tif (downstream_nodes.node_count == 1)\n\t\t{\n\t\t\tlog_error(_(\"%i other node still has this node as its upstream node\"),\n\t\t\t\t\t  downstream_nodes.node_count);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_error(_(\"%i other nodes still have this node as their upstream node\"),\n\t\t\t\t\t  downstream_nodes.node_count);\n\t\t}\n\n\t\tlog_hint(_(\"ensure these nodes are following the current primary with \\\"repmgr standby follow\\\"\"));\n\n\t\tinitPQExpBuffer(&detail);\n\n\t\tfor (cell = downstream_nodes.head; cell; cell = cell->next)\n\t\t{\n\t\t\tappendPQExpBuffer(&detail,\n\t\t\t\t\t\t\t  \"  %s (ID: %i)\\n\",\n\t\t\t\t\t\t\t  cell->node_info->node_name,\n\t\t\t\t\t\t\t  cell->node_info->node_id);\n\t\t}\n\n\t\tlog_detail(_(\"the affected node(s) are:\\n%s\"), detail.data);\n\n\t\ttermPQExpBuffer(&detail);\n\t\tPQfinish(primary_conn);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\ttarget_node_conn = establish_db_connection_quiet(target_node_info_ptr->conninfo);\n\n\t/* If node not reachable, check that the record is for a primary node */\n\tif (PQstatus(target_node_conn) != CONNECTION_OK)\n\t{\n\t\tif (target_node_info_ptr->type != PRIMARY)\n\t\t{\n\t\t\tlog_error(_(\"node \\\"%s\\\" (ID: %i) is not a primary, unable to unregister\"),\n\t\t\t\t\t  target_node_info_ptr->node_name,\n\t\t\t\t\t  target_node_info_ptr->node_id);\n\t\t\tif (target_node_info_ptr->type == STANDBY)\n\t\t\t{\n\t\t\t\tlog_hint(_(\"the node can be unregistered with \\\"repmgr standby unregister\\\"\"));\n\t\t\t}\n\n\t\t\tPQfinish(primary_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\t/* If we can connect to the node, perform some sanity checks on it */\n\telse\n\t{\n\t\tbool\t\tcan_unregister = true;\n\t\tRecoveryType recovery_type = get_recovery_type(target_node_conn);\n\n\t\t/* Node appears to be a standby */\n\t\tif (recovery_type == RECTYPE_STANDBY)\n\t\t{\n\t\t\t/*\n\t\t\t * We'll refuse to do anything unless the node record shows it as\n\t\t\t * a primary\n\t\t\t */\n\t\t\tif (target_node_info_ptr->type != PRIMARY)\n\t\t\t{\n\t\t\t\tlog_error(_(\"node \\\"%s\\\" (ID: %i) is a %s, unable to unregister\"),\n\t\t\t\t\t\t  target_node_info_ptr->node_name,\n\t\t\t\t\t\t  target_node_info_ptr->node_id,\n\t\t\t\t\t\t  get_node_type_string(target_node_info_ptr->type));\n\t\t\t\tcan_unregister = false;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If --F/--force not set, hint that it might be appropriate to\n\t\t\t * register the node as a standby rather than unregister as\n\t\t\t * primary\n\t\t\t */\n\t\t\telse if (!runtime_options.force)\n\t\t\t{\n\t\t\t\tlog_error(_(\"node \\\"%s\\\" (ID: %i) is running as a standby, unable to unregister\"),\n\t\t\t\t\t\t  target_node_info_ptr->node_name,\n\t\t\t\t\t\t  target_node_info_ptr->node_id);\n\t\t\t\tlog_hint(_(\"the node can be registered as a standby with \\\"repmgr standby register --force\\\"\"));\n\t\t\t\tlog_hint(_(\"use \\\"repmgr primary unregister --force\\\" to remove this node's metadata entirely\"));\n\t\t\t\tcan_unregister = false;\n\t\t\t}\n\n\n\t\t\tif (can_unregister == false)\n\t\t\t{\n\t\t\t\tPQfinish(target_node_conn);\n\t\t\t\tPQfinish(primary_conn);\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\t\t}\n\t\telse if (recovery_type == RECTYPE_PRIMARY)\n\t\t{\n\t\t\treset_node_info(&primary_node_info);\n\t\t\tbool\t\tprimary_record_found = false;\n\n\t\t\tprimary_record_found = get_primary_node_record(primary_conn, &primary_node_info);\n\n\t\t\tif (primary_record_found == false)\n\t\t\t{\n\t\t\t\tlog_error(_(\"node \\\"%s\\\" (ID: %i) is a primary node, but no primary node record found\"),\n\t\t\t\t\t\t  target_node_info_ptr->node_name,\n\t\t\t\t\t\t  target_node_info_ptr->node_id);\n\t\t\t\tlog_hint(_(\"register this node as primary with \\\"repmgr primary register --force\\\"\"));\n\t\t\t\tPQfinish(target_node_conn);\n\t\t\t\tPQfinish(primary_conn);\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * This appears to be the cluster primary - cowardly refuse to\n\t\t\t * delete the record, unless --force is supplied.\n\t\t\t */\n\t\t\tif (primary_node_info.node_id == target_node_info_ptr->node_id && !runtime_options.force)\n\t\t\t{\n\t\t\t\tlog_error(_(\"node \\\"%s\\\" (ID: %i) is the current primary node, unable to unregister\"),\n\t\t\t\t\t\t  target_node_info_ptr->node_name,\n\t\t\t\t\t\t  target_node_info_ptr->node_id);\n\n\t\t\t\tif (primary_node_info.active == false)\n\t\t\t\t{\n\t\t\t\t\tlog_hint(_(\"node is marked as inactive, activate with \\\"repmgr primary register --force\\\"\"));\n\t\t\t\t}\n\t\t\t\tPQfinish(target_node_conn);\n\t\t\t\tPQfinish(primary_conn);\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\t\t}\n\n\t\t/* We don't need the target node connection any more */\n\t\tPQfinish(target_node_conn);\n\t}\n\n\tif (target_node_info_ptr->active == true)\n\t{\n\t\tif (!runtime_options.force)\n\t\t{\n\t\t\tlog_error(_(\"node \\\"%s\\\" (ID: %i) is marked as active, unable to unregister\"),\n\t\t\t\t\t  target_node_info_ptr->node_name,\n\t\t\t\t\t  target_node_info_ptr->node_id);\n\t\t\tlog_hint(_(\"run \\\"repmgr primary unregister --force\\\" to unregister this node\"));\n\t\t\tPQfinish(primary_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tlog_notice(_(\"node \\\"%s\\\" (ID: %i) would now be unregistered\"),\n\t\t\t\t   target_node_info_ptr->node_name,\n\t\t\t\t   target_node_info_ptr->node_id);\n\t\tlog_hint(_(\"run the same command without the --dry-run option to unregister this node\"));\n\t}\n\telse\n\t{\n\t\tPQExpBufferData event_details;\n\t\tbool\t\tdelete_success = delete_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget_node_info_ptr->node_id);\n\n\t\tif (delete_success == false)\n\t\t{\n\t\t\tlog_error(_(\"unable to unregister node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t  target_node_info_ptr->node_name,\n\t\t\t\t\t  target_node_info_ptr->node_id);\n\t\t\tPQfinish(primary_conn);\n\t\t\texit(ERR_DB_QUERY);\n\t\t}\n\n\t\tinitPQExpBuffer(&event_details);\n\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t  _(\"node \\\"%s\\\" (ID: %i) unregistered\"),\n\t\t\t\t\t\t  target_node_info_ptr->node_name,\n\t\t\t\t\t\t  target_node_info_ptr->node_id);\n\n\t\tif (target_node_info_ptr->node_id != config_file_options.node_id)\n\t\t{\n\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t  _(\" from node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t  config_file_options.node_name,\n\t\t\t\t\t\t\t  config_file_options.node_id);\n\t\t}\n\n\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t  \"primary_unregister\",\n\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t  event_details.data);\n\t\ttermPQExpBuffer(&event_details);\n\n\t\tlog_info(_(\"node \\\"%s\\\" (ID: %i) was successfully unregistered\"),\n\t\t\t\t target_node_info_ptr->node_name,\n\t\t\t\t target_node_info_ptr->node_id);\n\t}\n\n\tPQfinish(primary_conn);\n\treturn;\n}\n\n\n\nvoid\ndo_primary_help(void)\n{\n\tprint_help_header();\n\n\tprintf(_(\"Usage:\\n\"));\n\tprintf(_(\"    %s [OPTIONS] primary register\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] primary unregister\\n\"), progname());\n\tputs(\"\");\n\tprintf(_(\"  Note: \\\"%s master ...\\\" can be used as an alias\\n\"), progname());\n\tputs(\"\");\n\n\tprintf(_(\"PRIMARY REGISTER\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"primary register\\\" initialises the repmgr cluster and registers the primary node.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  --dry-run                           check that the prerequisites are met for registering the primary\\n\" \\\n\t\t\t \"                                      (including availability of the repmgr extension)\\n\"));\n\tprintf(_(\"  -F, --force                         overwrite an existing node record\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"PRIMARY UNREGISTER\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"primary unregister\\\" unregisters an inactive primary node.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  --dry-run                           check what would happen, but don't actually unregister the primary\\n\"));\n\tprintf(_(\"  --node-id                           ID of the inactive primary node to unregister.\\n\"));\n\tprintf(_(\"  -F, --force                         force removal of an active record\\n\"));\n\n\tputs(\"\");\n\n\tprintf(_(\"%s home page: <%s>\\n\"), \"repmgr\", REPMGR_URL);\n}\n"
        },
        {
          "name": "repmgr-action-primary.h",
          "type": "blob",
          "size": 0.9072265625,
          "content": "/*\n * repmgr-action-primary.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _REPMGR_ACTION_PRIMARY_H_\n#define _REPMGR_ACTION_PRIMARY_H_\n\nextern void do_primary_register(void);\nextern void do_primary_unregister(void);\n\nextern void do_primary_help(void);\n#endif\n"
        },
        {
          "name": "repmgr-action-service.c",
          "type": "blob",
          "size": 15.3955078125,
          "content": "/*\n * repmgr-action-service.c\n *\n * Implements repmgrd actions for the repmgr command line utility\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <signal.h>\n#include <sys/stat.h>\t\t\t/* for stat() */\n\n#include \"repmgr.h\"\n\n#include \"repmgr-client-global.h\"\n#include \"repmgr-action-service.h\"\n\n\n/*\n * Possibly also show:\n *  - repmgrd start time?\n *  - repmgrd mode\n *  - priority\n *  - whether promotion candidate (due to zero priority/different location)\n */\n\ntypedef enum\n{\n\tSTATUS_ID = 0,\n\tSTATUS_NAME,\n\tSTATUS_ROLE,\n\tSTATUS_PG,\n\tSTATUS_UPSTREAM_NAME,\n\tSTATUS_LOCATION,\n\tSTATUS_PRIORITY,\n\tSTATUS_REPMGRD,\n\tSTATUS_PID,\n\tSTATUS_PAUSED,\n\tSTATUS_UPSTREAM_LAST_SEEN\n} StatusHeader;\n\n#define STATUS_HEADER_COUNT 11\n\nstruct ColHeader headers_status[STATUS_HEADER_COUNT];\n\nstatic void fetch_node_records(PGconn *conn, NodeInfoList *node_list);\nstatic void _do_repmgr_pause(bool pause);\n\n\nvoid\ndo_service_status(void)\n{\n\tPGconn\t   *conn = NULL;\n\tNodeInfoList nodes = T_NODE_INFO_LIST_INITIALIZER;\n\tNodeInfoListCell *cell = NULL;\n\tint i;\n\tRepmgrdInfo **repmgrd_info;\n\tItemList\twarnings = {NULL, NULL};\n\tbool\t\tconnection_error_found = false;\n\n\t/* Connect to local database to obtain cluster connection data */\n\tlog_verbose(LOG_INFO, _(\"connecting to database\"));\n\n\tif (strlen(config_file_options.conninfo))\n\t\tconn = establish_db_connection(config_file_options.conninfo, true);\n\telse\n\t\tconn = establish_db_connection_by_params(&source_conninfo, true);\n\n\tfetch_node_records(conn, &nodes);\n\n\trepmgrd_info = (RepmgrdInfo **) pg_malloc0(sizeof(RepmgrdInfo *) * nodes.node_count);\n\n\tif (repmgrd_info == NULL)\n\t{\n\t\tlog_error(_(\"unable to allocate memory\"));\n\t\texit(ERR_OUT_OF_MEMORY);\n\t}\n\n\tstrncpy(headers_status[STATUS_ID].title, _(\"ID\"), MAXLEN);\n\tstrncpy(headers_status[STATUS_NAME].title, _(\"Name\"), MAXLEN);\n\tstrncpy(headers_status[STATUS_ROLE].title, _(\"Role\"), MAXLEN);\n\tstrncpy(headers_status[STATUS_PG].title, _(\"Status\"), MAXLEN);\n\tstrncpy(headers_status[STATUS_UPSTREAM_NAME].title, _(\"Upstream\"), MAXLEN);\n\n\t/* following only displayed with the --detail option */\n\tstrncpy(headers_status[STATUS_LOCATION].title, _(\"Location\"), MAXLEN);\n\tif (runtime_options.compact == true)\n\t\tstrncpy(headers_status[STATUS_PRIORITY].title, _(\"Prio.\"), MAXLEN);\n\telse\n\t\tstrncpy(headers_status[STATUS_PRIORITY].title, _(\"Priority\"), MAXLEN);\n\n\tstrncpy(headers_status[STATUS_REPMGRD].title, _(\"repmgrd\"), MAXLEN);\n\tstrncpy(headers_status[STATUS_PID].title, _(\"PID\"), MAXLEN);\n\tstrncpy(headers_status[STATUS_PAUSED].title, _(\"Paused?\"), MAXLEN);\n\n\tif (runtime_options.compact == true)\n\t\tstrncpy(headers_status[STATUS_UPSTREAM_LAST_SEEN].title, _(\"Upstr. last\"), MAXLEN);\n\telse\n\t\tstrncpy(headers_status[STATUS_UPSTREAM_LAST_SEEN].title, _(\"Upstream last seen\"), MAXLEN);\n\n\tfor (i = 0; i < STATUS_HEADER_COUNT; i++)\n\t{\n\t\theaders_status[i].max_length = strlen(headers_status[i].title);\n\t\theaders_status[i].display = true;\n\t}\n\n\tif (runtime_options.detail == false)\n\t{\n\t\theaders_status[STATUS_LOCATION].display = false;\n\t\theaders_status[STATUS_PRIORITY].display = false;\n\t}\n\n\ti = 0;\n\n\tfor (cell = nodes.head; cell; cell = cell->next)\n\t{\n\t\tint j;\n\t\tPQExpBufferData node_status;\n\t\tPQExpBufferData upstream;\n\n\t\trepmgrd_info[i] = pg_malloc0(sizeof(RepmgrdInfo));\n\t\trepmgrd_info[i]->node_id = cell->node_info->node_id;\n\t\trepmgrd_info[i]->pid = UNKNOWN_PID;\n\t\trepmgrd_info[i]->recovery_type = RECTYPE_UNKNOWN;\n\t\trepmgrd_info[i]->paused = false;\n\t\trepmgrd_info[i]->running = false;\n\t\trepmgrd_info[i]->pg_running = true;\n\t\trepmgrd_info[i]->wal_paused_pending_wal = false;\n\t\trepmgrd_info[i]->upstream_last_seen = -1;\n\n\t\tcell->node_info->conn = establish_db_connection_quiet(cell->node_info->conninfo);\n\n\t\tif (PQstatus(cell->node_info->conn) != CONNECTION_OK)\n\t\t{\n\n\t\t\tconnection_error_found = true;\n\n\t\t\tif (runtime_options.verbose)\n\t\t\t{\n\t\t\t\tchar\t\terror[MAXLEN];\n\n\t\t\t\tstrncpy(error, PQerrorMessage(cell->node_info->conn), MAXLEN);\n\n\t\t\t\titem_list_append_format(&warnings,\n\t\t\t\t\t\t\t\t\t\t\"when attempting to connect to node \\\"%s\\\" (ID: %i), following error encountered :\\n\\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tcell->node_info->node_name, cell->node_info->node_id, trim(error));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\titem_list_append_format(&warnings,\n\t\t\t\t\t\t\t\t\t\t\"unable to  connect to node \\\"%s\\\" (ID: %i)\",\n\t\t\t\t\t\t\t\t\t\tcell->node_info->node_name, cell->node_info->node_id);\n\t\t\t}\n\n\t\t\trepmgrd_info[i]->pg_running = false;\n\t\t\tmaxlen_snprintf(repmgrd_info[i]->repmgrd_running, \"%s\", _(\"n/a\"));\n\t\t\tmaxlen_snprintf(repmgrd_info[i]->pid_text, \"%s\", _(\"n/a\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcell->node_info->node_status = NODE_STATUS_UP;\n\t\t\tcell->node_info->recovery_type = get_recovery_type(cell->node_info->conn);\n\n\t\t\trepmgrd_info[i]->pid = repmgrd_get_pid(cell->node_info->conn);\n\n\t\t\trepmgrd_info[i]->running = repmgrd_is_running(cell->node_info->conn);\n\n\t\t\tif (repmgrd_info[i]->running == true)\n\t\t\t{\n\t\t\t\tmaxlen_snprintf(repmgrd_info[i]->repmgrd_running, \"%s\", _(\"running\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmaxlen_snprintf(repmgrd_info[i]->repmgrd_running, \"%s\", _(\"not running\"));\n\t\t\t}\n\n\t\t\tif (repmgrd_info[i]->pid == UNKNOWN_PID)\n\t\t\t{\n\t\t\t\tmaxlen_snprintf(repmgrd_info[i]->pid_text, \"%s\", _(\"n/a\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmaxlen_snprintf(repmgrd_info[i]->pid_text, \"%i\", repmgrd_info[i]->pid);\n\t\t\t}\n\n\t\t\trepmgrd_info[i]->paused = repmgrd_is_paused(cell->node_info->conn);\n\n\t\t\trepmgrd_info[i]->recovery_type = get_recovery_type(cell->node_info->conn);\n\n\t\t\tif (repmgrd_info[i]->recovery_type == RECTYPE_STANDBY)\n\t\t\t{\n\t\t\t\trepmgrd_info[i]->wal_paused_pending_wal = is_wal_replay_paused(cell->node_info->conn, true);\n\n\t\t\t\tif (repmgrd_info[i]->wal_paused_pending_wal == true)\n\t\t\t\t{\n\t\t\t\t\titem_list_append_format(&warnings,\n\t\t\t\t\t\t\t\t\t\t\t_(\"WAL replay is paused on node \\\"%s\\\" (ID: %i) with WAL replay pending; this node cannot be manually promoted  until WAL replay is resumed\"),\n\t\t\t\t\t\t\t\t\t\t\tcell->node_info->node_name, cell->node_info->node_id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trepmgrd_info[i]->upstream_last_seen = get_upstream_last_seen(cell->node_info->conn, cell->node_info->type);\n\t\t\tif (repmgrd_info[i]->upstream_last_seen < 0)\n\t\t\t{\n\t\t\t\tmaxlen_snprintf(repmgrd_info[i]->upstream_last_seen_text, \"%s\", _(\"n/a\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (runtime_options.compact == true)\n\t\t\t\t{\n\t\t\t\t\tmaxlen_snprintf(repmgrd_info[i]->upstream_last_seen_text, _(\"%i sec(s) ago\"), repmgrd_info[i]->upstream_last_seen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmaxlen_snprintf(repmgrd_info[i]->upstream_last_seen_text, _(\"%i second(s) ago\"), repmgrd_info[i]->upstream_last_seen);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinitPQExpBuffer(&node_status);\n\t\tinitPQExpBuffer(&upstream);\n\n\t\t(void)format_node_status(cell->node_info, &node_status, &upstream, &warnings);\n\t\tsnprintf(repmgrd_info[i]->pg_running_text, sizeof(cell->node_info->details),\n\t\t\t\t \"%s\", node_status.data);\n\n\t\tsnprintf(cell->node_info->upstream_node_name, sizeof(cell->node_info->upstream_node_name),\n\t\t\t\t \"%s\", upstream.data);\n\n\t\ttermPQExpBuffer(&node_status);\n\t\ttermPQExpBuffer(&upstream);\n\n\t\tPQfinish(cell->node_info->conn);\n\n\t\theaders_status[STATUS_NAME].cur_length = strlen(cell->node_info->node_name);\n\t\theaders_status[STATUS_ROLE].cur_length = strlen(get_node_type_string(cell->node_info->type));\n\t\theaders_status[STATUS_PG].cur_length = strlen(repmgrd_info[i]->pg_running_text);\n\t\theaders_status[STATUS_UPSTREAM_NAME].cur_length = strlen(cell->node_info->upstream_node_name);\n\n\t\tif (runtime_options.detail == true)\n\t\t{\n\t\t\tPQExpBufferData buf;\n\n\t\t\theaders_status[STATUS_LOCATION].cur_length = strlen(cell->node_info->location);\n\n\t\t\tinitPQExpBuffer(&buf);\n\t\t\tappendPQExpBuffer(&buf, \"%i\", cell->node_info->priority);\n\t\t\theaders_status[STATUS_PRIORITY].cur_length = strlen(buf.data);\n\t\t\ttermPQExpBuffer(&buf);\n\t\t}\n\n\t\theaders_status[STATUS_PID].cur_length = strlen(repmgrd_info[i]->pid_text);\n\t\theaders_status[STATUS_REPMGRD].cur_length = strlen(repmgrd_info[i]->repmgrd_running);\n\n\t\theaders_status[STATUS_UPSTREAM_LAST_SEEN].cur_length = strlen(repmgrd_info[i]->upstream_last_seen_text);\n\n\t\tfor (j = 0; j < STATUS_HEADER_COUNT; j++)\n\t\t{\n\t\t\tif (headers_status[j].cur_length > headers_status[j].max_length)\n\t\t\t{\n\t\t\t\theaders_status[j].max_length = headers_status[j].cur_length;\n\t\t\t}\n\t\t}\n\n\t\ti++;\n\t}\n\n\t/* Print column header row (text mode only) */\n\tif (runtime_options.output_mode == OM_TEXT)\n\t{\n\t\tprint_status_header(STATUS_HEADER_COUNT, headers_status);\n\t}\n\n\ti = 0;\n\n\tfor (cell = nodes.head; cell; cell = cell->next)\n\t{\n\t\tif (runtime_options.output_mode == OM_CSV)\n\t\t{\n\t\t\tint running = repmgrd_info[i]->running ? 1 : 0;\n\t\t\tint paused = repmgrd_info[i]->paused ? 1 : 0;\n\n\t\t\t/* If PostgreSQL is not running, repmgrd status is unknown */\n\t\t\tif (repmgrd_info[i]->pg_running == false)\n\t\t\t{\n\t\t\t\trunning = -1;\n\t\t\t\tpaused = -1;\n\t\t\t}\n\n\t\t\tprintf(\"%i,%s,%s,%i,%i,%i,%i,%i,%i,%s\\n\",\n\t\t\t\t   cell->node_info->node_id,\n\t\t\t\t   cell->node_info->node_name,\n\t\t\t\t   get_node_type_string(cell->node_info->type),\n\t\t\t\t   repmgrd_info[i]->pg_running ? 1 : 0,\n\t\t\t\t   running,\n\t\t\t\t   repmgrd_info[i]->pid,\n\t\t\t\t   paused,\n\t\t\t\t   cell->node_info->priority,\n\t\t\t\t   repmgrd_info[i]->pid == UNKNOWN_PID\n\t\t\t\t     ? -1\n \t\t\t\t     : repmgrd_info[i]->upstream_last_seen,\n\t\t\t\t   cell->node_info->location);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\" %-*i \",  headers_status[STATUS_ID].max_length, cell->node_info->node_id);\n\t\t\tprintf(\"| %-*s \", headers_status[STATUS_NAME].max_length, cell->node_info->node_name);\n\t\t\tprintf(\"| %-*s \", headers_status[STATUS_ROLE].max_length, get_node_type_string(cell->node_info->type));\n\t\t\tprintf(\"| %-*s \", headers_status[STATUS_PG].max_length, repmgrd_info[i]->pg_running_text);\n\t\t\tprintf(\"| %-*s \", headers_status[STATUS_UPSTREAM_NAME].max_length, cell->node_info->upstream_node_name);\n\n\t\t\tif (runtime_options.detail == true)\n\t\t\t{\n\t\t\t\tprintf(\"| %-*s \", headers_status[STATUS_LOCATION].max_length, cell->node_info->location);\n\t\t\t\tprintf(\"| %-*i \", headers_status[STATUS_PRIORITY].max_length, cell->node_info->priority);\n\t\t\t}\n\n\t\t\tprintf(\"| %-*s \", headers_status[STATUS_REPMGRD].max_length, repmgrd_info[i]->repmgrd_running);\n\t\t\tprintf(\"| %-*s \", headers_status[STATUS_PID].max_length, repmgrd_info[i]->pid_text);\n\n\t\t\tif (repmgrd_info[i]->pid == UNKNOWN_PID)\n\t\t\t{\n\t\t\t\tprintf(\"| %-*s \", headers_status[STATUS_PAUSED].max_length, _(\"n/a\"));\n\t\t\t\tprintf(\"| %-*s \", headers_status[STATUS_UPSTREAM_LAST_SEEN].max_length, _(\"n/a\"));\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"| %-*s \", headers_status[STATUS_PAUSED].max_length, repmgrd_info[i]->paused ? _(\"yes\") : _(\"no\"));\n\n\t\t\t\tprintf(\"| %-*s \", headers_status[STATUS_UPSTREAM_LAST_SEEN].max_length, repmgrd_info[i]->upstream_last_seen_text);\n\t\t\t}\n\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t\tpfree(repmgrd_info[i]);\n\t\ti++;\n\t}\n\n\tpfree(repmgrd_info);\n\n\t/* emit any warnings */\n\n\tif (warnings.head != NULL && runtime_options.terse == false && runtime_options.output_mode != OM_CSV)\n\t{\n\t\tItemListCell *cell = NULL;\n\n\t\tPQExpBufferData warning;\n\n\t\tinitPQExpBuffer(&warning);\n\n\t\tappendPQExpBufferStr(&warning,\n\t\t\t\t\t\t\t _(\"following issues were detected\\n\"));\n\n\t\tfor (cell = warnings.head; cell; cell = cell->next)\n\t\t{\n\t\t\tappendPQExpBuffer(&warning,\n\t\t\t\t\t\t\t  _(\"  - %s\\n\"), cell->string);\n\t\t}\n\t\tputs(\"\");\n\t\tlog_warning(\"%s\", warning.data);\n\n\t\ttermPQExpBuffer(&warning);\n\n\t\tif (runtime_options.verbose == false && connection_error_found == true)\n\t\t{\n\t\t\tlog_hint(_(\"execute with --verbose option to see connection error messages\"));\n\t\t}\n\t}\n}\n\nvoid\ndo_service_pause(void)\n{\n\t_do_repmgr_pause(true);\n}\n\nvoid\ndo_service_unpause(void)\n{\n\t_do_repmgr_pause(false);\n}\n\n\nstatic void\n_do_repmgr_pause(bool pause)\n{\n\tPGconn\t   *conn = NULL;\n\tNodeInfoList nodes = T_NODE_INFO_LIST_INITIALIZER;\n\tNodeInfoListCell *cell = NULL;\n\tint i;\n\tint error_nodes = 0;\n\n\t/* Connect to local database to obtain cluster connection data */\n\tlog_verbose(LOG_INFO, _(\"connecting to database\"));\n\n\tif (strlen(config_file_options.conninfo))\n\t\tconn = establish_db_connection(config_file_options.conninfo, true);\n\telse\n\t\tconn = establish_db_connection_by_params(&source_conninfo, true);\n\n\tfetch_node_records(conn, &nodes);\n\n\ti = 0;\n\n\tfor (cell = nodes.head; cell; cell = cell->next)\n\t{\n\t\tlog_verbose(LOG_DEBUG, \"pausing node %i (%s)\",\n\t\t\t\t\tcell->node_info->node_id,\n\t\t\t\t\tcell->node_info->node_name);\n\t\tcell->node_info->conn = establish_db_connection_quiet(cell->node_info->conninfo);\n\n\t\tif (PQstatus(cell->node_info->conn) != CONNECTION_OK)\n\t\t{\n\t\t\tlog_warning(_(\"unable to connect to node %i\"),\n\t\t\t\t\t\tcell->node_info->node_id);\n\t\t\terror_nodes++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (runtime_options.dry_run == true)\n\t\t\t{\n\t\t\t\tif (pause == true)\n\t\t\t\t{\n\t\t\t\t\tlog_info(_(\"would pause node %i (%s) \"),\n\t\t\t\t\t\t\t cell->node_info->node_id,\n\t\t\t\t\t\t\t cell->node_info->node_name);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlog_info(_(\"would unpause node %i (%s) \"),\n\t\t\t\t\t\t\t cell->node_info->node_id,\n\t\t\t\t\t\t\t cell->node_info->node_name);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool success = repmgrd_pause(cell->node_info->conn, pause);\n\n\t\t\t\tif (success == false)\n\t\t\t\t\terror_nodes++;\n\n\t\t\t\tlog_notice(_(\"node %i (%s) %s\"),\n\t\t\t\t\t\t   cell->node_info->node_id,\n\t\t\t\t\t\t   cell->node_info->node_name,\n\t\t\t\t\t\t   success == true\n\t\t\t\t\t\t\t\t? pause == true ? \"paused\" : \"unpaused\"\n\t\t   \t\t\t\t\t\t: pause == true ? \"not paused\" : \"not unpaused\");\n\t\t\t}\n\t\t\tPQfinish(cell->node_info->conn);\n\t\t}\n\t\ti++;\n\t}\n\n\tif (error_nodes > 0)\n\t{\n\t\tif (pause == true)\n\t\t{\n\t\t\tlog_error(_(\"unable to pause %i node(s)\"), error_nodes);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_error(_(\"unable to unpause %i node(s)\"), error_nodes);\n\t\t}\n\n\t\tlog_hint(_(\"execute \\\"repmgr service status\\\" to view current status\"));\n\n\t\texit(ERR_REPMGRD_PAUSE);\n\t}\n\n\texit(SUCCESS);\n}\n\n\n\nvoid\nfetch_node_records(PGconn *conn, NodeInfoList *node_list)\n{\n\tbool success = get_all_node_records_with_upstream(conn, node_list);\n\n\tif (success == false)\n\t{\n\t\t/* get_all_node_records() will display any error message */\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tif (node_list->node_count == 0)\n\t{\n\t\tlog_error(_(\"no node records were found\"));\n\t\tlog_hint(_(\"ensure at least one node is registered\"));\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n}\n\n\n\nvoid do_service_help(void)\n{\n\tprint_help_header();\n\n\tprintf(_(\"Usage:\\n\"));\n\tprintf(_(\"    %s [OPTIONS] service status\\n\"),  progname());\n\tprintf(_(\"    %s [OPTIONS] service pause\\n\"),   progname());\n\tprintf(_(\"    %s [OPTIONS] service unpause\\n\"), progname());\n\n\tputs(\"\");\n\n\tprintf(_(\"SERVICE STATUS\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"service status\\\" shows the status of repmgrd on each node in the cluster\\n\"));\n\tputs(\"\");\n\tprintf(_(\"    --csv                     emit output as CSV\\n\"));\n\tprintf(_(\"    --detail                  show additional detail\\n\"));\n\tprintf(_(\"    --verbose                 show text of database connection error messages\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"SERVICE PAUSE\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"service pause\\\" instructs repmgrd on each node to pause failover detection\\n\"));\n\tputs(\"\");\n\tprintf(_(\"    --dry-run               check if nodes are reachable but don't pause repmgrd\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"SERVICE UNPAUSE\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"service unpause\\\"  instructs repmgrd on each node to resume failover detection\\n\"));\n\tputs(\"\");\n\tprintf(_(\"    --dry-run               check if nodes are reachable but don't unpause repmgrd\\n\"));\n\tputs(\"\");\n\n\tputs(\"\");\n\n\tprintf(_(\"%s home page: <%s>\\n\"), \"repmgr\", REPMGR_URL);\n}\n"
        },
        {
          "name": "repmgr-action-service.h",
          "type": "blob",
          "size": 0.9384765625,
          "content": "/*\n * repmgr-action-service.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _REPMGR_ACTION_SERVICE_H_\n#define _REPMGR_ACTION_SERVICE_H_\n\n\nextern void do_service_status(void);\nextern void do_service_pause(void);\nextern void do_service_unpause(void);\n\nextern void do_service_help(void);\n#endif\n"
        },
        {
          "name": "repmgr-action-standby.c",
          "type": "blob",
          "size": 252.8603515625,
          "content": "/*\n * repmgr-action-standby.c\n *\n * Implements standby actions for the repmgr command line utility\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"repmgr.h\"\n#include \"dirutil.h\"\n#include \"compat.h\"\n#include \"controldata.h\"\n\n#include \"repmgr-client-global.h\"\n#include \"repmgr-action-standby.h\"\n#include \"pgbackupapi.h\"\n\ntypedef struct TablespaceDataListCell\n{\n\tstruct TablespaceDataListCell *next;\n\tchar\t   *name;\n\tchar\t   *oid;\n\tchar\t   *location;\n\t/* Optional pointer to a file containing a list of tablespace files to copy from Barman */\n\tFILE\t   *fptr;\n} TablespaceDataListCell;\n\ntypedef struct TablespaceDataList\n{\n\tTablespaceDataListCell *head;\n\tTablespaceDataListCell *tail;\n} TablespaceDataList;\n\n\ntypedef struct\n{\n\tint\t\t\treachable_sibling_node_count;\n\tint\t\t\treachable_sibling_nodes_with_slot_count;\n\tint\t\t\tunreachable_sibling_node_count;\n\tint\t\t\tmin_required_wal_senders;\n\tint\t\t\tmin_required_free_slots;\n} SiblingNodeStats;\n\n#define T_SIBLING_NODES_STATS_INITIALIZER { \\\n\t0, \\\n\t0, \\\n\t0, \\\n\t0, \\\n\t0 \\\n}\n\nstatic PGconn *primary_conn = NULL;\nstatic PGconn *source_conn = NULL;\n\nstatic char local_data_directory[MAXPGPATH] = \"\";\n\nstatic bool upstream_conninfo_found = false;\nstatic int\tupstream_node_id = UNKNOWN_NODE_ID;\n\nstatic t_conninfo_param_list recovery_conninfo = T_CONNINFO_PARAM_LIST_INITIALIZER;\nstatic char recovery_conninfo_str[MAXLEN] = \"\";\nstatic char upstream_repluser[NAMEDATALEN] = \"\";\nstatic char upstream_user[NAMEDATALEN] = \"\";\n\nstatic int\tsource_server_version_num = UNKNOWN_SERVER_VERSION_NUM;\n\nstatic t_configfile_list config_files = T_CONFIGFILE_LIST_INITIALIZER;\n\nstatic standy_clone_mode mode = pg_basebackup;\n\n/* used by barman mode */\nstatic char local_repmgr_tmp_directory[MAXPGPATH] = \"\";\nstatic char datadir_list_filename[MAXLEN] = \"\";\nstatic char barman_command_buf[MAXLEN] = \"\";\n\n/*\n * To enable \"standby clone\" to run with lowest possible user\n * privileges, we'll need to determine which actions need to\n * be run and which of the available users, which will be one\n * of the repmgr user, the replication user (if available) or\n * the superuser (if available).\n *\n * This is determined in check_source_server().\n */\nstatic t_user_type SettingsUser = REPMGR_USER;\n\nstatic void _do_standby_promote_internal(PGconn *conn);\nstatic void _do_create_replication_conf(void);\n\nstatic void check_barman_config(void);\nstatic void check_source_server(void);\nstatic void check_source_server_via_barman(void);\nstatic bool check_upstream_config(PGconn *conn, int server_version_num, t_node_info *node_info, bool exit_on_error);\nstatic void check_primary_standby_version_match(PGconn *conn, PGconn *primary_conn);\nstatic void check_recovery_type(PGconn *conn);\n\nstatic void initialise_direct_clone(t_node_info *local_node_record, t_node_info *upstream_node_record);\nstatic int\trun_basebackup(t_node_info *node_record);\nstatic int\trun_file_backup(t_node_info *node_record);\nstatic int\trun_pg_backupapi(t_node_info *node_record);\n\nstatic void copy_configuration_files(bool delete_after_copy);\n\nstatic void tablespace_data_append(TablespaceDataList *list, const char *name, const char *oid, const char *location);\n\nstatic void get_barman_property(char *dst, char *name, char *local_repmgr_directory);\nstatic int\tget_tablespace_data_barman(char *, TablespaceDataList *);\nstatic char *make_barman_ssh_command(char *buf);\n\nstatic bool create_recovery_file(t_node_info *node_record, t_conninfo_param_list *primary_conninfo, int server_version_num, char *dest, bool as_file);\nstatic void write_primary_conninfo(PQExpBufferData *dest, t_conninfo_param_list *param_list);\n\nstatic bool check_sibling_nodes(NodeInfoList *sibling_nodes, SiblingNodeStats *sibling_nodes_stats);\nstatic bool check_free_wal_senders(int available_wal_senders, SiblingNodeStats *sibling_nodes_stats, bool *dry_run_success);\nstatic bool check_free_slots(t_node_info *local_node_record, SiblingNodeStats *sibling_nodes_stats, bool *dry_run_success);\n\nstatic void sibling_nodes_follow(t_node_info *local_node_record, NodeInfoList *sibling_nodes, SiblingNodeStats *sibling_nodes_stats);\n\nstatic t_remote_error_type parse_remote_error(const char *error);\nstatic CheckStatus parse_check_status(const char *status_str);\n\nstatic NodeStatus parse_node_status_is_shutdown_cleanly(const char *node_status_output, XLogRecPtr *checkPoint);\nstatic CheckStatus parse_node_check_archiver(const char *node_check_output, int *files, int *threshold, t_remote_error_type *remote_error);\nstatic ConnectionStatus parse_remote_node_replication_connection(const char *node_check_output);\nstatic bool parse_data_directory_config(const char *node_check_output, t_remote_error_type *remote_error);\nstatic bool parse_replication_config_owner(const char *node_check_output);\nstatic CheckStatus parse_db_connection(const char *db_connection);\n\n/*\n * STANDBY CLONE\n *\n * Event(s):\n *  - standby_clone\n *\n * Parameters:\n *  --upstream-conninfo\n *  --upstream-node-id\n *  --no-upstream-connection\n *  -F/--force\n *  --dry-run\n *  -c/--fast-checkpoint\n *  --copy-external-config-files\n *  -R/--remote-user\n *  --replication-user (only required if no upstream record)\n *  --without-barman\n *  --replication-conf-only (--recovery-conf-only)\n *  --verify-backup (PostgreSQL 13 and later)\n */\n\nvoid\ndo_standby_clone(void)\n{\n\tPQExpBufferData event_details;\n\tint\t\t\tr = 0;\n\n\t/* dummy node record */\n\tt_node_info local_node_record = T_NODE_INFO_INITIALIZER;\n\tt_node_info upstream_node_record = T_NODE_INFO_INITIALIZER;\n\n\tbool local_data_directory_provided = false;\n\n\tinitialize_conninfo_params(&recovery_conninfo, false);\n\n\t/*\n\t * Copy the provided data directory; if a configuration file was provided,\n\t * use the (mandatory) value from that; if -D/--pgdata was provided, use\n\t * that.\n\t *\n\t * Note that barman mode requires -D/--pgdata.\n\t */\n\n\tget_node_data_directory(local_data_directory);\n\tif (local_data_directory[0] != '\\0')\n\t{\n\t\tlocal_data_directory_provided = true;\n\t\tlog_notice(_(\"destination directory \\\"%s\\\" provided\"),\n\t\t\t\t   local_data_directory);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If a configuration file is provided, repmgr will error out after\n\t\t * parsing it if no data directory is provided; this check is for\n\t\t * niche use-cases where no configuration file is provided.\n\t\t */\n\t\tlog_error(_(\"no data directory provided\"));\n\t\tlog_hint(_(\"use -D/--pgdata to explicitly specify a data directory\"));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * --replication-conf-only provided - we'll handle that separately\n\t */\n\tif (runtime_options.replication_conf_only == true)\n\t{\n\t\treturn _do_create_replication_conf();\n\t}\n\n\t/*\n\t * conninfo params for the actual upstream node (which might be different\n\t * to the node we're cloning from) to write to recovery.conf\n\t */\n\tmode = get_standby_clone_mode();\n\n\tif (mode == barman)\n\t{\n\t\t/*\n\t\t * Not currently possible to use --verify-backup with Barman\n\t\t */\n\t\tif (runtime_options.verify_backup == true)\n\t\t{\n\t\t\tlog_error(_(\"--verify-backup option cannot be used when cloning from Barman backups\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\t/*\n\t\t * Sanity-check barman connection and installation;\n\t\t * this will exit with ERR_BARMAN if problems found.\n\t\t */\n\t\tcheck_barman_config();\n\t}\n\n\tinit_node_record(&local_node_record);\n\tlocal_node_record.type = STANDBY;\n\n\t/*\n\t * Initialise list of conninfo parameters which will later be used to\n\t * create the \"primary_conninfo\" recovery parameter.\n\t *\n\t * We'll initialise it with the host settings specified on the command\n\t * line. As it's possible the standby will be cloned from a node different\n\t * to its intended upstream, we'll later attempt to fetch the upstream\n\t * node record and overwrite the values set here with those from the\n\t * upstream node record (excluding that record's application_name)\n\t */\n\n\tcopy_conninfo_params(&recovery_conninfo, &source_conninfo);\n\n\n\t/* Set the default application name to this node's name */\n\tif (config_file_options.node_id != UNKNOWN_NODE_ID)\n\t{\n\t\tchar\t\tapplication_name[MAXLEN] = \"\";\n\n\t\tparam_set(&recovery_conninfo, \"application_name\", config_file_options.node_name);\n\n\t\tget_conninfo_value(config_file_options.conninfo, \"application_name\", application_name);\n\t\tif (strlen(application_name) && strncmp(application_name, config_file_options.node_name, sizeof(config_file_options.node_name)) != 0)\n\t\t{\n\t\t\tlog_notice(_(\"\\\"application_name\\\" is set in repmgr.conf but will be replaced by the node name\"));\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * this will only happen in corner cases where the node is being\n\t\t * cloned without a configuration file; fall back to \"repmgr\" if no\n\t\t * application_name provided\n\t\t */\n\t\tchar\t   *application_name = param_get(&source_conninfo, \"application_name\");\n\n\t\tif (application_name == NULL)\n\t\t\tparam_set(&recovery_conninfo, \"application_name\", \"repmgr\");\n\t}\n\n\n\n\t/*\n\t * Do some sanity checks on the proposed data directory; if it exists:\n\t *  - check it's openable\n\t *  - check if there's an instance running\n\t *\n\t * We do this here so the check can be part of a --dry-run.\n\t */\n\tswitch (check_dir(local_data_directory))\n\t{\n\t\tcase DIR_ERROR:\n\t\t\tlog_error(_(\"unable to access specified data directory \\\"%s\\\"\"), local_data_directory);\n\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t\tbreak;\n\t\tcase DIR_NOENT:\n\t\t\t/*\n\t\t\t * directory doesn't exist\n\t\t\t * TODO: in --dry-run mode, attempt to create and delete?\n\t\t\t */\n\t\t\tbreak;\n\t\tcase DIR_EMPTY:\n\t\t\t/* Present but empty */\n\t\t\tbreak;\n\t\tcase DIR_NOT_EMPTY:\n\t\t\t/* Present but not empty */\n\t\t\tif (is_pg_dir(local_data_directory))\n\t\t\t{\n\t\t\t\t/* even -F/--force is not enough to overwrite an active directory... */\n\t\t\t\tif (is_pg_running(local_data_directory))\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"specified data directory \\\"%s\\\" appears to contain a running PostgreSQL instance\"),\n\t\t\t\t\t\t\t  local_data_directory);\n\t\t\t\t\tlog_hint(_(\"ensure the target data directory does not contain a running PostgreSQL instance\"));\n\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * By default attempt to connect to the source node. This will fail if no\n\t * connection is possible, unless in Barman mode, in which case we can\n\t * fall back to connecting to the source node via Barman (if available).\n\t */\n\tif (runtime_options.no_upstream_connection == false)\n\t{\n\t\tRecordStatus record_status = RECORD_NOT_FOUND;\n\n\t\t/*\n\t\t * This connects to the source node and performs sanity checks, also\n\t\t * sets \"recovery_conninfo_str\", \"upstream_repluser\", \"upstream_user\" and\n\t\t * \"upstream_node_id\" and creates a connection handle in \"source_conn\".\n\t\t *\n\t\t * Will error out if source connection not possible and not in\n\t\t * \"barman\" mode.\n\t\t */\n\t\tcheck_source_server();\n\n\t\tif (runtime_options.verify_backup == true)\n\t\t{\n\t\t\t/*\n\t\t\t * --verify-backup available for PostgreSQL 13 and later\n\t\t\t */\n\t\t\tif (PQserverVersion(source_conn) < 130000)\n\t\t\t{\n\t\t\t\tlog_error(_(\"--verify-backup available for PostgreSQL 13 and later\"));\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\t\t}\n\n\t\t/* attempt to retrieve upstream node record */\n\t\trecord_status = get_node_record(source_conn,\n\t\t\t\t\t\t\t\t\t\tupstream_node_id,\n\t\t\t\t\t\t\t\t\t\t&upstream_node_record);\n\n\t\tif (record_status != RECORD_FOUND)\n\t\t{\n\t\t\tlog_error(_(\"unable to retrieve record for upstream node %i\"),\n\t\t\t\t\t  upstream_node_id);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tupstream_node_id = runtime_options.upstream_node_id;\n\t}\n\n\t/*\n\t * if --upstream-conninfo was supplied, use that (will overwrite value set\n\t * by check_source_server(), but that's OK)\n\t */\n\tif (runtime_options.upstream_conninfo[0] != '\\0')\n\t{\n\t\tstrncpy(recovery_conninfo_str, runtime_options.upstream_conninfo, MAXLEN);\n\t\tupstream_conninfo_found = true;\n\t}\n\telse if (mode == barman && PQstatus(source_conn) != CONNECTION_OK)\n\t{\n\t\t/*\n\t\t * Here we don't have a connection to the upstream node (either\n\t\t * because --no-upstream-connection was supplied, or\n\t\t * check_source_server() was unable to make a connection, and\n\t\t * --upstream-conninfo wasn't supplied.\n\t\t *\n\t\t * As we're executing in Barman mode we can try and connect via the\n\t\t * Barman server to extract the upstream node's conninfo string.\n\t\t *\n\t\t * To do this we need to extract Barman's conninfo string, replace the\n\t\t * database name with the repmgr one (they could well be different)\n\t\t * and remotely execute psql.\n\t\t *\n\t\t * This attempts to set \"recovery_conninfo_str\".\n\t\t */\n\t\tcheck_source_server_via_barman();\n\t}\n\n\tif (recovery_conninfo_str[0] == '\\0')\n\t{\n\t\tlog_error(_(\"unable to determine a connection string to use as \\\"primary_conninfo\\\"\"));\n\t\tlog_hint(_(\"use \\\"--upstream-conninfo\\\" to explicitly provide a value for \\\"primary_conninfo\\\"\"));\n\t\tif (PQstatus(source_conn) == CONNECTION_OK)\n\t\t\tPQfinish(source_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\n\tif (upstream_conninfo_found == true)\n\t{\n\t\t/*\n\t\t * parse returned upstream conninfo string to recovery\n\t\t * primary_conninfo params\n\t\t */\n\t\tchar\t   *errmsg = NULL;\n\t\tbool\t\tparse_success = false;\n\n\t\tlog_verbose(LOG_DEBUG, \"parsing upstream conninfo string \\\"%s\\\"\", recovery_conninfo_str);\n\n\t\t/*\n\t\t * parse_conninfo_string() here will remove the upstream's\n\t\t * `application_name`, if set\n\t\t */\n\n\t\tparse_success = parse_conninfo_string(recovery_conninfo_str, &recovery_conninfo, &errmsg, true);\n\n\t\tif (parse_success == false)\n\t\t{\n\t\t\tlog_error(_(\"unable to parse conninfo string \\\"%s\\\" for upstream node\"),\n\t\t\t\t\t  recovery_conninfo_str);\n\t\t\tlog_detail(\"%s\", errmsg);\n\t\t\tif (PQstatus(source_conn) == CONNECTION_OK)\n\t\t\t\tPQfinish(source_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tif (upstream_repluser[0] != '\\0')\n\t\t{\n\t\t\t/* Write the replication user from the node's upstream record */\n\t\t\tparam_set(&recovery_conninfo, \"user\", upstream_repluser);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If no upstream node record found, we'll abort with an error here,\n\t\t * unless -F/--force is used, in which case we'll use the parameters\n\t\t * provided on the command line (and assume the user knows what\n\t\t * they're doing).\n\t\t */\n\t\tif (upstream_node_id == UNKNOWN_NODE_ID)\n\t\t{\n\t\t\tlog_error(_(\"unable to determine upstream node\"));\n\t\t\tif (PQstatus(source_conn) == CONNECTION_OK)\n\t\t\t\tPQfinish(source_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tif (!runtime_options.force)\n\t\t{\n\t\t\tlog_error(_(\"no record found for upstream node (upstream_node_id: %i)\"),\n\t\t\t\t\t  upstream_node_id);\n\t\t\tlog_hint(_(\"use -F/--force to create \\\"primary_conninfo\\\" based on command-line parameters\"));\n\n\t\t\tif (PQstatus(source_conn) == CONNECTION_OK)\n\t\t\t\tPQfinish(source_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\t/*\n\t * If copying of external configuration files requested, and any are\n\t * detected, perform sanity checks\n\t */\n\tif (PQstatus(source_conn) == CONNECTION_OK && runtime_options.copy_external_config_files == true)\n\t{\n\t\tPGconn\t   *superuser_conn = NULL;\n\t\tPGconn\t   *privileged_conn = NULL;\n\t\tbool\t\texternal_config_files = false;\n\t\tint\t\t\ti = 0;\n\n\t\t/*\n\t\t * Obtain configuration file locations\n\t\t *\n\t\t * We'll check to see whether the configuration files are in the data\n\t\t * directory - if not we'll have to copy them via SSH, if copying\n\t\t * requested.\n\t\t *\n\t\t * This will require superuser permissions, so we'll attempt to\n\t\t * connect as -S/--superuser (if provided), otherwise check the\n\t\t * current connection user has superuser rights.\n\t\t *\n\t\t * XXX: if configuration files are symlinks to targets outside the\n\t\t * data directory, they won't be copied by pg_basebackup, but we can't\n\t\t * tell this from the below query; we'll probably need to add a check\n\t\t * for their presence and if missing force copy by SSH\n\t\t */\n\n\t\tif (SettingsUser == REPMGR_USER)\n\t\t{\n\t\t\tprivileged_conn = source_conn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tget_superuser_connection(&source_conn, &superuser_conn, &privileged_conn);\n\t\t}\n\n\t\tif (get_configuration_file_locations(privileged_conn, &config_files) == false)\n\t\t{\n\t\t\tlog_notice(_(\"unable to proceed without establishing configuration file locations\"));\n\t\t\tPQfinish(source_conn);\n\n\t\t\tif (superuser_conn != NULL)\n\t\t\t\tPQfinish(superuser_conn);\n\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\t/* check if any files actually outside the data directory */\n\t\tfor (i = 0; i < config_files.entries; i++)\n\t\t{\n\t\t\tt_configfile_info *file = config_files.files[i];\n\n\t\t\tif (file->in_data_directory == false)\n\t\t\t{\n\t\t\t\texternal_config_files = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (external_config_files == true)\n\t\t{\n\t\t\tr = 0;\n\t\t\tPQExpBufferData msg;\n\n\t\t\tinitPQExpBuffer(&msg);\n\n\t\t\tappendPQExpBuffer(&msg,\n\t\t\t\t\t\t\t  _(\"external configuration files detected, checking SSH connection to host \\\"%s\\\"\"),\n\t\t\t\t\t\t\t  runtime_options.host);\n\n\t\t\tif (runtime_options.dry_run == true)\n\t\t\t{\n\t\t\t\tlog_notice(\"%s\", msg.data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_verbose(LOG_INFO, \"%s\", msg.data);\n\t\t\t}\n\n\t\t\ttermPQExpBuffer(&msg);\n\n\t\t\tr = test_ssh_connection(runtime_options.host, runtime_options.remote_user);\n\n\t\t\tif (r != 0)\n\t\t\t{\n\t\t\t\tlog_error(_(\"remote host \\\"%s\\\" is not reachable via SSH - unable to copy external configuration files\"),\n\t\t\t\t\t\t  runtime_options.host);\n\t\t\t\tif (superuser_conn != NULL)\n\t\t\t\t\tPQfinish(superuser_conn);\n\t\t\t\tPQfinish(source_conn);\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\n\t\t\tinitPQExpBuffer(&msg);\n\n\t\t\tappendPQExpBuffer(&msg,\n\t\t\t\t\t\t\t  _(\"SSH connection to host \\\"%s\\\" succeeded\"),\n\t\t\t\t\t\t\t  runtime_options.host);\n\n\t\t\tif (runtime_options.dry_run == true)\n\t\t\t{\n\t\t\t\tlog_info(\"%s\", msg.data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_verbose(LOG_INFO, \"%s\", msg.data);\n\t\t\t}\n\n\t\t\ttermPQExpBuffer(&msg);\n\n\n\t\t\t/*\n\t\t\t * Here we'll attempt an initial test copy of the detected external\n\t\t\t * files, to detect any issues before we run the base backup.\n\t\t\t *\n\t\t\t * Note this will exit with an error, unless -F/--force supplied.\n\t\t\t *\n\t\t\t * We don't do this during a --dry-run as it may introduce unexpected changes\n\t\t\t * on the local node; during an actual clone operation, any problems with\n\t\t\t * copying files will be detected early and the operation aborted before\n\t\t\t * the actual database cloning commences.\n\t\t\t *\n\t\t\t * TODO: put the files in a temporary directory and move to their final\n\t\t\t * destination once the database has been cloned.\n\t\t\t */\n\n\t\t\tif (runtime_options.dry_run == false)\n\t\t\t{\n\t\t\t\tif (runtime_options.copy_external_config_files_destination == CONFIG_FILE_SAMEPATH)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Files will be placed in the same path as on the source server;\n\t\t\t\t\t * don't delete after copying.\n\t\t\t\t\t */\n\t\t\t\t\tcopy_configuration_files(false);\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Files will be placed in the data directory - delete after copying.\n\t\t\t\t\t * They'll be copied again later; see TODO above.\n\t\t\t\t\t */\n\t\t\t\t\tcopy_configuration_files(true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif (superuser_conn != NULL)\n\t\t\tPQfinish(superuser_conn);\n\t}\n\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\t/*\n\t\t * If replication slots in use, sanity-check whether we can create them\n\t\t * with the available user permissions.\n\t\t */\n\t\tif (config_file_options.use_replication_slots == true && PQstatus(source_conn) == CONNECTION_OK)\n\t\t{\n\t\t\tPQExpBufferData msg;\n\t\t\tbool success = true;\n\n\t\t\tinitPQExpBuffer(&msg);\n\n\t\t\t/*\n\t\t\t * \"create_replication_slot()\" knows about --dry-run mode and\n\t\t\t * will perform checks but not actually create the slot.\n\t\t\t */\n\t\t\tsuccess = create_replication_slot(source_conn,\n\t\t\t\t\t\t\t\t\t\t\t  local_node_record.slot_name,\n\t\t\t\t\t\t\t\t\t\t\t  &upstream_node_record,\n\t\t\t\t\t\t\t\t\t\t\t  &msg);\n\t\t\tif (success == false)\n\t\t\t{\n\t\t\t\tlog_error(_(\"prerequisites not met for creating a replication slot on upstream node %i\"),\n\t\t\t\t\t\t  upstream_node_record.node_id);\n\t\t\t\ttermPQExpBuffer(&msg);\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\t\t\ttermPQExpBuffer(&msg);\n\t\t}\n\n\t\tif (upstream_node_id != UNKNOWN_NODE_ID)\n\t\t{\n\t\t\tlog_notice(_(\"standby will attach to upstream node %i\"), upstream_node_id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_warning(_(\"unable to determine a valid upstream node id\"));\n\t\t}\n\n\t\tif (mode == pg_basebackup && runtime_options.fast_checkpoint == false)\n\t\t{\n\t\t\tlog_hint(_(\"consider using the -c/--fast-checkpoint option\"));\n\t\t}\n\n\t\tif (mode == pg_basebackup)\n\t\t{\n\t\t\t/*\n\t\t\t * In --dry-run mode, this will just output the pg_basebackup command which\n\t\t\t * would be executed.\n\t\t\t */\n\t\t\trun_basebackup(&local_node_record);\n\t\t}\n\n\t\tPQfinish(source_conn);\n\n\t\tlog_info(_(\"all prerequisites for \\\"standby clone\\\" are met\"));\n\n\t\texit(SUCCESS);\n\t}\n\n\tswitch (mode)\n\t{\n\t\tcase pg_basebackup:\n\t\t\tinitialise_direct_clone(&local_node_record, &upstream_node_record);\n\t\t\tlog_notice(_(\"starting backup (using pg_basebackup)...\"));\n\t\t\tbreak;\n\t\tcase barman:\n\t\t\tlog_notice(_(\"retrieving backup from Barman...\"));\n\t\t\tbreak;\n\t\tcase pg_backupapi:\n\t\t\tlog_notice(_(\"starting backup (using pg_backupapi)...\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* should never reach here */\n\t\t\tlog_error(_(\"unknown clone mode\"));\n\t}\n\n\tif (mode == pg_basebackup)\n\t{\n\t\tif (runtime_options.fast_checkpoint == false)\n\t\t{\n\t\t\tlog_hint(_(\"this may take some time; consider using the -c/--fast-checkpoint option\"));\n\t\t}\n\t}\n\n\tswitch (mode)\n\t{\n\t\tcase pg_basebackup:\n\t\t\tr = run_basebackup(&local_node_record);\n\t\t\tbreak;\n\t\tcase barman:\n\t\t\tr = run_file_backup(&local_node_record);\n\t\t\tbreak;\n\t\tcase pg_backupapi:\n\t\t\tr = run_pg_backupapi(&local_node_record);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* should never reach here */\n\t\t\tlog_error(_(\"unknown clone mode\"));\n\t}\n\n\t/* If the backup failed then exit */\n\tif (r != SUCCESS)\n\t{\n\t\t/* If a replication slot was previously created, drop it */\n\t\tif (config_file_options.use_replication_slots == true)\n\t\t{\n\t\t\t/*\n\t\t\t * In the case where a standby is being cloned from a node other than its\n\t\t\t * intended upstream, We can't be sure of the source node's node_id. This\n\t\t\t * is only required by \"drop_replication_slot_if_exists()\" to determine\n\t\t\t * from the node's record whether it has a different replication user, and\n\t\t\t * as in this case that would need to be supplied via \"--replication-user\"\n\t\t\t * it's not a problem.\n\t\t\t */\n\t\t\tdrop_replication_slot_if_exists(source_conn, UNKNOWN_NODE_ID, local_node_record.slot_name);\n\t\t}\n\n\t\tlog_error(_(\"unable to take a base backup of the source server\"));\n\t\tlog_hint(_(\"data directory (\\\"%s\\\") may need to be cleaned up manually\"),\n\t\t\t\t local_data_directory);\n\n\t\tPQfinish(source_conn);\n\t\texit(r);\n\t}\n\n\t/*\n\t * Run pg_verifybackup here if requested, before any alterations are made\n\t * to the data directory.\n\t */\n\tif (mode == pg_basebackup && runtime_options.verify_backup == true)\n\t{\n\t\tPQExpBufferData command;\n\t\tr = 0;\n\t\tstruct stat st;\n\n\t\tinitPQExpBuffer(&command);\n\n\t\tmake_pg_path(&command, \"pg_verifybackup\");\n\n\t\t/* check command actually exists */\n\t\tif (stat(command.data, &st) != 0)\n\t\t{\n\t\t\tlog_error(_(\"unable to find expected binary \\\"%s\\\"\"), command.data);\n\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tappendPQExpBufferChar(&command, ' ');\n\n\t\t/* Somewhat inconsistent, but pg_verifybackup doesn't accept a -D option  */\n\t\tappendShellString(&command,\n\t\t\t\t\t\t  local_data_directory);\n\n\t\tlog_debug(\"executing:\\n  %s\", command.data);\n\n\t\tr = system(command.data);\n\t\ttermPQExpBuffer(&command);\n\n\t\tif (r != 0)\n\t\t{\n\t\t\tlog_error(_(\"unable to verify backup\"));\n\t\t\texit(ERR_BAD_BASEBACKUP);\n\t\t}\n\n\t\tlog_verbose(LOG_INFO, _(\"backup successfully verified\"));\n\n\t}\n\n\n\t/*\n\t * If `--copy-external-config-files` was provided, copy any configuration\n\t * files detected to the appropriate location. Any errors encountered will\n\t * not be treated as fatal.\n\t *\n\t * This won't run in Barman mode as \"config_files\" is only populated in\n\t * \"initialise_direct_clone()\", which isn't called in Barman mode.\n\t */\n\tif (runtime_options.copy_external_config_files == true && config_files.entries > 0)\n\t{\n\t\t/*\n\t\t * If \"--copy-external-config-files=samepath\" was used, the files will already\n\t\t * have been copied.\n\t\t */\n\t\tif (runtime_options.copy_external_config_files_destination == CONFIG_FILE_PGDATA)\n\t\t\tcopy_configuration_files(false);\n\t}\n\n\t/* Write the recovery.conf file */\n\tif (create_recovery_file(&local_node_record,\n\t\t\t\t\t\t\t &recovery_conninfo,\n\t\t\t\t\t\t\t source_server_version_num,\n\t\t\t\t\t\t\t local_data_directory,\n\t\t\t\t\t\t\t true) == false)\n\t{\n\t\t/* create_recovery_file() will log an error */\n\t\tif (source_server_version_num >= 120000)\n\t\t{\n\t\t\tlog_notice(_(\"unable to write replication configuration; see preceding error messages\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_notice(_(\"unable to create recovery.conf; see preceding error messages\"));\n\t\t}\n\t\tlog_hint(_(\"data directory (\\\"%s\\\") may need to be cleaned up manually\"),\n\t\t\t\t local_data_directory);\n\n\t\tPQfinish(source_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tswitch (mode)\n\t{\n\t\tcase pg_basebackup:\n\t\t\tlog_notice(_(\"standby clone (using pg_basebackup) complete\"));\n\t\t\tbreak;\n\n\t\tcase barman:\n\t\t\tlog_notice(_(\"standby clone (from Barman) complete\"));\n\t\t\tbreak;\n\t\tcase pg_backupapi:\n\t\t\tlog_notice(_(\"standby clone (from pg_backupapi) complete\"));\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Do a final check on the data directory permissions - if the user\n\t * is cloning into an existing directory set to 0750, and the server\n\t * is Pg10 or earlier, Pg will refuse to start. We might not have\n\t * known the server version when creating the data directory\n\t * (mainly if cloning from Barman with no upstream connection), hence\n\t * the additional check here.\n\t */\n\tset_dir_permissions(local_data_directory, source_server_version_num);\n\n\t/*\n\t * TODO: It might be nice to provide an option to have repmgr start the\n\t * PostgreSQL server automatically\n\t */\n\n\tlog_notice(_(\"you can now start your PostgreSQL server\"));\n\n\tif (config_file_options.service_start_command[0] != '\\0')\n\t{\n\t\tlog_hint(_(\"for example: %s\"),\n\t\t\t\t config_file_options.service_start_command);\n\t}\n\telse if (local_data_directory_provided)\n\t{\n\t\tlog_hint(_(\"for example: pg_ctl -D %s start\"),\n\t\t\t\t local_data_directory);\n\t}\n\telse\n\t{\n\t\tlog_hint(_(\"for example: /etc/init.d/postgresql start\"));\n\t}\n\n\t/*\n\t * XXX forgetting to (re) register the standby is a frequent cause of\n\t * error; we should consider having repmgr automatically register the\n\t * standby, either by default with an option \"--no-register\", or an option\n\t * \"--register\".\n\t *\n\t * Note that \"repmgr standby register\" requires the standby to be running\n\t * - if not, and we just update the node record, we'd have an incorrect\n\t * representation of the replication cluster. Best combined with an\n\t * automatic start of the server (see note above)\n\t */\n\n\t/*\n\t * Check for an existing node record, and output the appropriate command\n\t * for registering or re-registering.\n\t */\n\t{\n\t\tt_node_info node_record = T_NODE_INFO_INITIALIZER;\n\t\tRecordStatus record_status = RECORD_NOT_FOUND;\n\n\t\trecord_status = get_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\t\tconfig_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t&node_record);\n\n\t\tif (record_status == RECORD_FOUND)\n\t\t{\n\t\t\tlog_hint(_(\"after starting the server, you need to re-register this standby with \\\"repmgr standby register --force\\\" to update the existing node record\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_hint(_(\"after starting the server, you need to register this standby with \\\"repmgr standby register\\\"\"));\n\n\t\t}\n\t}\n\n\n\t/* Log the event */\n\n\tinitPQExpBuffer(&event_details);\n\n\t/* Add details about relevant runtime options used */\n\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t  _(\"cloned from host \\\"%s\\\", port %s\"),\n\t\t\t\t\t  runtime_options.host,\n\t\t\t\t\t  runtime_options.port);\n\n\tappendPQExpBufferStr(&event_details,\n\t\t\t\t\t\t _(\"; backup method: \"));\n\n\tswitch (mode)\n\t{\n\t\tcase pg_basebackup:\n\t\t\tappendPQExpBufferStr(&event_details, \"pg_basebackup\");\n\t\t\tbreak;\n\t\tcase barman:\n\t\t\tappendPQExpBufferStr(&event_details, \"barman\");\n\t\t\tbreak;\n\t\tcase pg_backupapi:\n\t\t\tappendPQExpBufferStr(&event_details, \"pg_backupapi\");\n\t\t\tbreak;\n\t}\n\n\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t  _(\"; --force: %s\"),\n\t\t\t\t\t  runtime_options.force ? \"Y\" : \"N\");\n\n\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t  \"standby_clone\",\n\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t  event_details.data);\n\n\tif (primary_conn != source_conn && PQstatus(primary_conn) == CONNECTION_OK)\n\t\tPQfinish(primary_conn);\n\n\tif (PQstatus(source_conn) == CONNECTION_OK)\n\t\tPQfinish(source_conn);\n\n\texit(r);\n}\n\n\nvoid\ncheck_barman_config(void)\n{\n\tPQExpBufferData command;\n\tbool\t\tcommand_ok = false;\n\n\t/*\n\t * Check that there is at least one valid backup\n\t */\n\n\tlog_info(_(\"connecting to Barman server to verify backup for \\\"%s\\\"\"), config_file_options.barman_server);\n\n\tinitPQExpBuffer(&command);\n\n\tappendPQExpBuffer(&command, \"%s show-backup %s latest > /dev/null\",\n\t\t\t\t\t  make_barman_ssh_command(barman_command_buf),\n\t\t\t\t\t  config_file_options.barman_server);\n\n\tcommand_ok = local_command(command.data, NULL);\n\n\tif (command_ok == false)\n\t{\n\t\tlog_error(_(\"no valid backup for server \\\"%s\\\" was found in the Barman catalogue\"),\n\t\t\t\t  config_file_options.barman_server);\n\t\tlog_detail(_(\"command executed was:\\n  %s\"), command.data),\n\t\tlog_hint(_(\"refer to the Barman documentation for more information\"));\n\n\t\ttermPQExpBuffer(&command);\n\t\texit(ERR_BARMAN);\n\t}\n\telse if (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"valid backup for server \\\"%s\\\" found in the Barman catalogue\"),\n\t\t\t\t config_file_options.barman_server);\n\t}\n\n\ttermPQExpBuffer(&command);\n\n\t/*\n\t * Attempt to create data directory (unless --dry-run specified,\n\t * in which case do nothing; warnings will be emitted elsewhere about\n\t * any issues with the data directory)\n\t */\n\tif (runtime_options.dry_run == false)\n\t{\n\t\tif (!create_pg_dir(local_data_directory, runtime_options.force))\n\t\t{\n\t\t\tlog_error(_(\"unable to use directory %s\"),\n\t\t\t\t\t  local_data_directory);\n\t\t\tlog_hint(_(\"use -F/--force option to force this directory to be overwritten\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\t/*\n\t\t * Create the local repmgr subdirectory\n\t\t */\n\n\t\tmaxlen_snprintf(local_repmgr_tmp_directory,\n\t\t\t\t\t\t\"%s/repmgr\", local_data_directory);\n\n\t\tmaxlen_snprintf(datadir_list_filename,\n\t\t\t\t\t\t\"%s/data.txt\", local_repmgr_tmp_directory);\n\n\t\tif (!create_pg_dir(local_repmgr_tmp_directory, runtime_options.force))\n\t\t{\n\t\t\tlog_error(_(\"unable to create directory \\\"%s\\\"\"),\n\t\t\t\t\t  local_repmgr_tmp_directory);\n\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\t/*\n\t * Fetch server parameters from Barman\n\t */\n\tlog_info(_(\"connecting to Barman server to fetch server parameters\"));\n\n\tinitPQExpBuffer(&command);\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tappendPQExpBuffer(&command, \"%s show-server %s > /dev/null\",\n\t\t\t\t\t\t  make_barman_ssh_command(barman_command_buf),\n\t\t\t\t\t\t  config_file_options.barman_server);\n\t}\n\telse\n\t{\n\t\tappendPQExpBuffer(&command, \"%s show-server %s > %s/show-server.txt\",\n\t\t\t\t\t\t  make_barman_ssh_command(barman_command_buf),\n\t\t\t\t\t\t  config_file_options.barman_server,\n\t\t\t\t\t\t  local_repmgr_tmp_directory);\n\t}\n\n\tcommand_ok = local_command(command.data, NULL);\n\n\tif (command_ok == false)\n\t{\n\t\tlog_error(_(\"unable to fetch server parameters from Barman server\"));\n\t\tlog_detail(_(\"command executed was:\\n  %s\"), command.data),\n\t\ttermPQExpBuffer(&command);\n\t\texit(ERR_BARMAN);\n\t}\n\telse if (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"server parameters were successfully fetched from Barman server\"));\n\t}\n\n\ttermPQExpBuffer(&command);\n}\n\n\n/*\n * _do_create_replication_conf()\n *\n * Create replication configuration for a previously cloned instance.\n *\n * Prerequisites:\n *\n * - data directory must be provided, either explicitly or via\n *   repmgr.conf\n * - the instance should not be running\n * - an existing \"recovery.conf\" file can only be overwritten with\n *   -F/--force (Pg11 and earlier)\n * - connection parameters for an existing, running node must be provided\n * - --upstream-node-id, if provided, will be \"primary_conninfo\",\n *   otherwise primary node id; node must exist; unless -F/--force\n *   provided, must be active and connection possible\n * - if replication slots in use, create (respect --dry-run)\n *\n * not compatible with --no-upstream-connection\n *\n */\n\nstatic void\n_do_create_replication_conf(void)\n{\n\tt_node_info local_node_record = T_NODE_INFO_INITIALIZER;\n\tt_node_info upstream_node_record = T_NODE_INFO_INITIALIZER;\n\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\tchar\t\trecovery_file_path[MAXPGPATH + sizeof(RECOVERY_COMMAND_FILE)] = \"\";\n\tstruct stat st;\n\tbool\t\tnode_is_running = false;\n\tbool\t\tslot_creation_required = false;\n\tPGconn\t   *upstream_conn = NULL;\n\tPGconn\t   *upstream_repl_conn = NULL;\n\n\tget_node_data_directory(local_data_directory);\n\n\tif (local_data_directory[0] == '\\0')\n\t{\n\t\tlog_error(_(\"no data directory provided\"));\n\t\tlog_hint(_(\"provide the node's \\\"repmgr.conf\\\" file with -f/--config-file or the data directory with -D/--pgdata\"));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\n\t/* check connection */\n\tsource_conn = establish_db_connection_by_params(&source_conninfo, true);\n\n\t/* Verify that source is a supported server version */\n\t(void) check_server_version(source_conn, \"source node\", true, NULL);\n\n\t/*\n\t * Do some sanity checks on the data directory to make sure\n\t * it contains a valid but dormant instance\n\t */\n\tswitch (check_dir(local_data_directory))\n\t{\n\t\tcase DIR_ERROR:\n\t\t\tlog_error(_(\"unable to access specified data directory \\\"%s\\\"\"), local_data_directory);\n\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\tPQfinish(source_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t\tbreak;\n\t\tcase DIR_NOENT:\n\t\t\tlog_error(_(\"specified data directory \\\"%s\\\" does not exist\"), local_data_directory);\n\t\t\tPQfinish(source_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t\tbreak;\n\t\tcase DIR_EMPTY:\n\t\t\tlog_error(_(\"specified data directory \\\"%s\\\" is empty\"), local_data_directory);\n\t\t\tPQfinish(source_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t\tbreak;\n\t\tcase DIR_NOT_EMPTY:\n\t\t\t/* Present but not empty */\n\t\t\tif (!is_pg_dir(local_data_directory))\n\t\t\t{\n\t\t\t\tlog_error(_(\"specified data directory \\\"%s\\\" does not contain a PostgreSQL instance\"), local_data_directory);\n\t\t\t\tPQfinish(source_conn);\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\n\t\t\tif (is_pg_running(local_data_directory))\n\t\t\t{\n\t\t\t\tif (runtime_options.force == false)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"specified data directory \\\"%s\\\" appears to contain a running PostgreSQL instance\"),\n\t\t\t\t\t\t\t  local_data_directory);\n\n\t\t\t\t\tif (PQserverVersion(source_conn) >= 120000)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_hint(_(\"use -F/--force to create replication configuration anyway\"));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_hint(_(\"use -F/--force to create \\\"recovery.conf\\\" anyway\"));\n\t\t\t\t\t}\n\n\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t}\n\n\t\t\t\tnode_is_running = true;\n\n\t\t\t\tif (runtime_options.dry_run == true)\n\t\t\t\t{\n\t\t\t\t\tif (PQserverVersion(source_conn) >= 120000)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_warning(_(\"replication configuration would be created in an active data directory\"));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_warning(_(\"\\\"recovery.conf\\\" would be created in an active data directory\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (PQserverVersion(source_conn) >= 120000)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_warning(_(\"creating replication configuration in an active data directory\"));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_warning(_(\"creating \\\"recovery.conf\\\" in an active data directory\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\n\t/* determine node for primary_conninfo */\n\n\tif (runtime_options.upstream_node_id != UNKNOWN_NODE_ID)\n\t{\n\t\tupstream_node_id = runtime_options.upstream_node_id;\n\t}\n\telse\n\t{\n\t\t/* if --upstream-node-id not specifically supplied, get primary node id */\n\t\tupstream_node_id = get_primary_node_id(source_conn);\n\n\t\tif (upstream_node_id == NODE_NOT_FOUND)\n\t\t{\n\t\t\tlog_error(_(\"unable to determine primary node for this replication cluster\"));\n\t\t\tPQfinish(source_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tlog_debug(\"primary node determined as: %i\", upstream_node_id);\n\t}\n\n\t/* attempt to retrieve upstream node record */\n\trecord_status = get_node_record(source_conn,\n\t\t\t\t\t\t\t\t\tupstream_node_id,\n\t\t\t\t\t\t\t\t\t&upstream_node_record);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve node record for upstream node %i\"), upstream_node_id);\n\n\t\tif (record_status == RECORD_ERROR)\n\t\t{\n\t\t\tlog_detail(\"%s\", PQerrorMessage(source_conn));\n\t\t}\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* attempt to retrieve local node record */\n\trecord_status = get_node_record(source_conn,\n\t\t\t\t\t\t\t\t\tconfig_file_options.node_id,\n\t\t\t\t\t\t\t\t\t&local_node_record);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve node record for local node %i\"), config_file_options.node_id);\n\n\t\tif (record_status == RECORD_ERROR)\n\t\t{\n\t\t\tlog_detail(\"%s\", PQerrorMessage(source_conn));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_hint(_(\"standby must be registered before replication can be configured\"));\n\t\t}\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tPQfinish(source_conn);\n\n\n\t/* connect to upstream (which could be different to source) */\n\n\tupstream_conn = establish_db_connection(upstream_node_record.conninfo, false);\n\tif (PQstatus(upstream_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to connect to upstream node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t  upstream_node_record.node_name,\n \t\t\t\t  upstream_node_id);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* Set the application name to this node's name */\n\tif (config_file_options.node_name[0] != '\\0')\n\t\tparam_set(&recovery_conninfo, \"application_name\", config_file_options.node_name);\n\n\t/* Set the replication user from the primary node record */\n\tparam_set(&recovery_conninfo, \"user\", upstream_node_record.repluser);\n\n\tinitialize_conninfo_params(&recovery_conninfo, false);\n\n\t/* We ignore any application_name set in the primary's conninfo */\n\tparse_conninfo_string(upstream_node_record.conninfo, &recovery_conninfo, NULL, true);\n\n\t/* check that a replication connection can be made (--force = override) */\n\tupstream_repl_conn = establish_db_connection_by_params(&recovery_conninfo, false);\n\n\tif (PQstatus(upstream_repl_conn) != CONNECTION_OK)\n\t{\n\t\tif (runtime_options.force == false)\n\t\t{\n\t\t\tlog_error(_(\"unable to initiate replication connection to upstream node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t  upstream_node_record.node_name,\n\t\t\t\t\t  upstream_node_id);\n\t\t\tPQfinish(upstream_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\t/* if replication slots are in use, perform some checks */\n\tif (config_file_options.use_replication_slots == true)\n\t{\n\t\tPQExpBufferData msg;\n\t\tt_replication_slot slot_info = T_REPLICATION_SLOT_INITIALIZER;\n\n\t\t/*\n\t\t * Check the node record has slot_name set; if not we'll need to\n\t\t * update it.\n\t\t */\n\t\tif (local_node_record.slot_name[0] == '\\0')\n\t\t{\n\t\t\tPGconn\t   *primary_conn = NULL;\n\n\t\t\tcreate_slot_name(local_node_record.slot_name, local_node_record.node_id);\n\n\t\t\t/* Check we can connect to the primary so we can update the record */\n\n\t\t\tif (get_recovery_type(upstream_conn) == RECTYPE_PRIMARY)\n\t\t\t{\n\t\t\t\tprimary_conn = upstream_conn;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprimary_conn = establish_primary_db_connection(upstream_conn, false);\n\n\t\t\t\tif (primary_conn == NULL)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to connect to primary to update slot name for node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t  local_node_record.node_name,\n\t\t\t\t\t\t\t  local_node_record.node_id);\n\t\t\t\t\tPQfinish(upstream_conn);\n\t\t\t\t\ttermPQExpBuffer(&msg);\n\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (runtime_options.dry_run == true)\n\t\t\t{\n\t\t\t\tlog_info(_(\"would set \\\"slot_name\\\" for node \\\"%s\\\" (ID: %i) to \\\"%s\\\"\"),\n\t\t\t\t\t\t  local_node_record.node_name,\n\t\t\t\t\t\t  local_node_record.node_id,\n\t\t\t\t\t\t  local_node_record.slot_name);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool success = update_node_record_slot_name(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlocal_node_record.node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlocal_node_record.slot_name);\n\n\t\t\t\tif (primary_conn != upstream_conn)\n\t\t\t\t\tPQfinish(primary_conn);\n\n\t\t\t\tif (success == false)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to update slot name for node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t  local_node_record.node_name,\n\t\t\t\t\t\t\t  local_node_record.node_id);\n\t\t\t\t\tPQfinish(upstream_conn);\n\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trecord_status = get_slot_record(upstream_conn, local_node_record.slot_name, &slot_info);\n\n\t\t/* check if replication slot exists*/\n\t\tif (record_status == RECORD_FOUND)\n\t\t{\n\t\t\tif (slot_info.active == true)\n\t\t\t{\n\t\t\t\tinitPQExpBuffer(&msg);\n\n\t\t\t\tappendPQExpBuffer(&msg,\n\t\t\t\t\t\t\t\t  _(\"an active replication slot named \\\"%s\\\" already exists on upstream node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t\t  local_node_record.slot_name,\n\t\t\t\t\t\t\t\t  upstream_node_record.node_name,\n\t\t\t\t\t\t\t\t  upstream_node_id);\n\n\t\t\t\tif (runtime_options.force == false && runtime_options.dry_run == false)\n\t\t\t\t{\n\t\t\t\t\tlog_error(\"%s\", msg.data);\n\t\t\t\t\tlog_hint(_(\"use -F/--force to continue anyway\"));\n\t\t\t\t\ttermPQExpBuffer(&msg);\n\t\t\t\t\tPQfinish(upstream_conn);\n\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t}\n\n\t\t\t\tlog_warning(\"%s\", msg.data);\n\t\t\t\ttermPQExpBuffer(&msg);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_info(_(\"an inactive replication slot for this node exists on the upstream node\"));\n\t\t\t}\n\t\t}\n\t\t/* if not, if check one can and should be created */\n\t\telse\n\t\t{\n\t\t\tget_node_replication_stats(upstream_conn, &upstream_node_record);\n\n\t\t    if (upstream_node_record.max_replication_slots > upstream_node_record.total_replication_slots)\n\t\t\t{\n\t\t\t\tslot_creation_required = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinitPQExpBuffer(&msg);\n\n\t\t\t\tappendPQExpBuffer(&msg,\n\t\t\t\t\t\t\t\t  _(\"insufficient free replication slots on upstream node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t\t  upstream_node_record.node_name,\n\t\t\t\t\t\t\t\t  upstream_node_id);\n\n\t\t\t\tif (runtime_options.force == false && runtime_options.dry_run == false)\n\t\t\t\t{\n\t\t\t\t\tlog_error(\"%s\", msg.data);\n\t\t\t\t\tlog_hint(_(\"use -F/--force to continue anyway\"));\n\t\t\t\t\ttermPQExpBuffer(&msg);\n\t\t\t\t\tPQfinish(upstream_conn);\n\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t}\n\n\t\t\t\tlog_warning(\"%s\", msg.data);\n\t\t\t\ttermPQExpBuffer(&msg);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* check if recovery.conf exists (Pg11 and earlier only) */\n\tif (PQserverVersion(upstream_conn) < 120000)\n\t{\n\t\tsnprintf(recovery_file_path, sizeof(recovery_file_path),\n\t\t\t\t \"%s/%s\",\n\t\t\t\t local_data_directory,\n\t\t\t\t RECOVERY_COMMAND_FILE);\n\n\t\tif (stat(recovery_file_path, &st) == -1)\n\t\t{\n\t\t\tif (errno != ENOENT)\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to check for existing \\\"recovery.conf\\\" file in \\\"%s\\\"\"),\n\t\t\t\t\t\t  local_data_directory);\n\t\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (runtime_options.force == false)\n\t\t\t{\n\t\t\t\tlog_error(_(\"\\\"recovery.conf\\\" already exists in \\\"%s\\\"\"),\n\t\t\t\t\t\t  local_data_directory);\n\t\t\t\tlog_hint(_(\"use -F/--force to overwrite an existing \\\"recovery.conf\\\" file\"));\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\n\t\t\tif (runtime_options.dry_run == true)\n\t\t\t{\n\t\t\t\tlog_warning(_(\"the existing \\\"recovery.conf\\\" file would be overwritten\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_warning(_(\"the existing \\\"recovery.conf\\\" file will be overwritten\"));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tchar\t\trecovery_conf_contents[MAXLEN] = \"\";\n\t\tcreate_recovery_file(&local_node_record,\n\t\t\t\t\t\t\t &recovery_conninfo,\n\t\t\t\t\t\t\t PQserverVersion(upstream_conn),\n\t\t\t\t\t\t\t recovery_conf_contents,\n\t\t\t\t\t\t\t false);\n\n\t\tif (PQserverVersion(upstream_conn) >= 120000)\n\t\t{\n\t\t\tlog_info(_(\"following items would be added to \\\"postgresql.auto.conf\\\" in \\\"%s\\\"\"), local_data_directory);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_info(_(\"would create \\\"recovery.conf\\\" file in \\\"%s\\\"\"), local_data_directory);\n\t\t}\n\n\t\tlog_detail(_(\"\\n%s\"), recovery_conf_contents);\n\t}\n\telse\n\t{\n\t\tif (!create_recovery_file(&local_node_record,\n\t\t\t\t\t\t\t\t  &recovery_conninfo,\n\t\t\t\t\t\t\t\t  PQserverVersion(upstream_conn),\n\t\t\t\t\t\t\t\t  local_data_directory,\n\t\t\t\t\t\t\t\t  true))\n\t\t{\n\t\t\tif (PQserverVersion(upstream_conn) >= 120000)\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to write replication configuration to \\\"postgresql.auto.conf\\\"\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to create \\\"recovery.conf\\\"\"));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (PQserverVersion(upstream_conn) >= 120000)\n\t\t\t{\n\t\t\t\tlog_notice(_(\"replication configuration written to \\\"postgresql.auto.conf\\\"\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_notice(_(\"\\\"recovery.conf\\\" created as \\\"%s\\\"\"), recovery_file_path);\n\t\t\t}\n\n\t\t\tif (node_is_running == true)\n\t\t\t{\n\t\t\t\tif (PQserverVersion(upstream_conn) >= 130000)\n\t\t\t\t{\n\t\t\t\t\tlog_hint(_(\"configuration must be reloaded for the configuration changes to take effect\"));\n\t\t\t\t}\n\t\t\t\telse if (PQserverVersion(upstream_conn) >= 120000)\n\t\t\t\t{\n\t\t\t\t\tlog_hint(_(\"node must be restarted for the configuration changes to take effect\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlog_hint(_(\"node must be restarted for the new file to take effect\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Pg12 and later: add standby.signal, if not already there */\n\tif (PQserverVersion(upstream_conn) >= 120000)\n\t{\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(_(\"would write \\\"standby.signal\\\" file\"));\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (write_standby_signal(local_data_directory) == false)\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to write \\\"standby.signal\\\" file\"));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* add replication slot, if required */\n\tif (slot_creation_required == true)\n\t{\n\t\tPQExpBufferData msg;\n\t\tinitPQExpBuffer(&msg);\n\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\t/*\n\t\t\t * In --dry-run mode this will check availability\n\t\t\t * of a user who can create replication slots.\n\t\t\t */\n\t\t\t// XXX check return value\n\t\t\tcreate_replication_slot(upstream_conn,\n\t\t\t\t\t\t\t\t\tlocal_node_record.slot_name,\n\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\t&msg);\n\t\t\tlog_info(_(\"would create replication slot \\\"%s\\\" on upstream node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t local_node_record.slot_name,\n\t\t\t\t\t upstream_node_record.node_name,\n\t\t\t\t\t upstream_node_id);\n\t\t}\n\t\telse\n\t\t{\n\n\t\t\tif (create_replication_slot(upstream_conn,\n\t\t\t\t\t\t\t\t\t\tlocal_node_record.slot_name,\n\t\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\t\t&msg) == false)\n\t\t\t{\n\t\t\t\tlog_error(\"%s\", msg.data);\n\t\t\t\tPQfinish(upstream_conn);\n\t\t\t\ttermPQExpBuffer(&msg);\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\n\n\t\t\tlog_notice(_(\"replication slot \\\"%s\\\" created on upstream node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t   local_node_record.slot_name,\n\t\t\t\t\t   upstream_node_record.node_name,\n\t\t\t\t\t   upstream_node_id);\n\t\t}\n\t\ttermPQExpBuffer(&msg);\n\n\t}\n\n\n\tPQfinish(upstream_conn);\n\n\treturn;\n}\n\n\n/*\n * do_standby_register()\n *\n * Event(s):\n *  - standby_register\n *  - standby_register_sync\n */\n/*  XXX check --upstream-node-id works when re-registering */\n\nvoid\ndo_standby_register(void)\n{\n\tPGconn\t   *conn = NULL;\n\tPGconn\t   *primary_conn = NULL;\n\n\tbool\t\trecord_created = false;\n\tt_node_info node_record = T_NODE_INFO_INITIALIZER;\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\n\tPQExpBufferData details;\n\n\t/* so we can pass info about the primary to event notification scripts */\n\tt_event_info event_info = T_EVENT_INFO_INITIALIZER;\n\tt_node_info primary_node_record = T_NODE_INFO_INITIALIZER;\n\tint primary_node_id = UNKNOWN_NODE_ID;\n\n\tbool\t\tdry_run_ok = true;\n\n\tlog_info(_(\"connecting to local node \\\"%s\\\" (ID: %i)\"),\n\t\t\t config_file_options.node_name,\n\t\t\t config_file_options.node_id);\n\n\tconn = establish_db_connection_quiet(config_file_options.conninfo);\n\n\t/*\n\t * If unable to connect, and --force not provided, wait up to --wait-start\n\t * seconds (default: 0) for the node to become reachable.\n\t *\n\t * Not that if --force provided, we don't wait for the node to start, as\n\t * the normal use case will be re-registering an existing node, or\n\t * registering an inactive/not-yet-extant one; we'll do the\n\t * error handling for those cases in the next code block\n\t */\n\tif (PQstatus(conn) != CONNECTION_OK && runtime_options.force == false)\n\t{\n\t\tbool\t\tconn_ok = false;\n\t\tint\t\t\ttimer = 0;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tif (timer == runtime_options.wait_start)\n\t\t\t\tbreak;\n\n\t\t\tsleep(1);\n\n\t\t\tlog_verbose(LOG_INFO, _(\"%i of %i connection attempts\"),\n\t\t\t\t\t\ttimer + 1,\n\t\t\t\t\t\truntime_options.wait_start);\n\n\t\t\tconn = establish_db_connection_quiet(config_file_options.conninfo);\n\n\t\t\tif (PQstatus(conn) == CONNECTION_OK)\n\t\t\t{\n\t\t\t\tconn_ok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttimer++;\n\t\t}\n\n\t\tif (conn_ok == true)\n\t\t{\n\t\t\tlog_info(_(\"connected to local node \\\"%s\\\" (ID: %i) after %i seconds\"),\n\t\t\t\t\t config_file_options.node_name,\n\t\t\t\t\t config_file_options.node_id,\n\t\t\t\t\t timer);\n\t\t}\n\t}\n\n\t/*\n\t * If still unable to connect, continue only if -F/--force provided,\n\t * and primary connection parameters provided.\n\t */\n\tif (PQstatus(conn) != CONNECTION_OK)\n\t{\n\t\tif (runtime_options.force == false)\n\t\t{\n\t\t\tlog_error(_(\"unable to connect to local node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t  config_file_options.node_name,\n\t\t\t\t\t  config_file_options.node_id);\n\t\t\tlog_detail(\"\\n%s\", PQerrorMessage(conn));\n\t\t\tlog_hint(_(\"to register a standby which is not running, provide primary connection parameters and use option -F/--force\"));\n\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tif (runtime_options.connection_param_provided == false)\n\t\t{\n\t\t\tlog_error(_(\"unable to connect to local node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t  config_file_options.node_name,\n\t\t\t\t\t  config_file_options.node_id);\n\t\t\tlog_hint(_(\"to register a standby which is not running, additionally provide the primary connection parameters\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\t/* connection OK - check this is actually a standby */\n\telse\n\t{\n\t\tif (runtime_options.connection_param_provided)\n\t\t{\n\t\t\tlog_warning(_(\"database connection parameters not required when the standby to be registered is running\"));\n\t\t\tlog_detail(_(\"repmgr uses the \\\"conninfo\\\" parameter in \\\"repmgr.conf\\\" to connect to the standby\"));\n\t\t}\n\t\tcheck_recovery_type(conn);\n\t}\n\n\t/* check if there is a primary in this cluster */\n\tlog_info(_(\"connecting to primary database\"));\n\n\t/* Normal case - we can connect to the local node */\n\tif (PQstatus(conn) == CONNECTION_OK)\n\t{\n\t\tprimary_conn = get_primary_connection(conn, &primary_node_id, NULL);\n\t}\n\n\t/*\n\t * otherwise user is forcing a registration of a (potentially) inactive (or\n\t * not-yet-extant) node and must have supplied primary connection info\n\t */\n\telse\n\t{\n\t\tprimary_conn = establish_db_connection_by_params(&source_conninfo, false);\n\t}\n\n\t/*\n\t * no amount of --force will make it possible to register the standby\n\t * without a primary server to connect to\n\t */\n\tif (PQstatus(primary_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to connect to the primary database\"));\n\t\tlog_hint(_(\"a primary node must be configured before registering a standby node\"));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * Populate \"event_info\" with info about the primary for event notifications\n\t */\n\trecord_status = get_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\tprimary_node_id,\n\t\t\t\t\t\t\t\t\t&primary_node_record);\n\tevent_info.node_id = primary_node_id;\n\tevent_info.node_name = primary_node_record.node_name;\n\tevent_info.conninfo_str = primary_node_record.conninfo;\n\n\t/*\n\t * Verify that standby and primary are supported and compatible server\n\t * versions\n\t *\n\t * If the user is registering an inactive standby, we'll trust they know\n\t * what they're doing\n\t */\n\tif (PQstatus(conn) == CONNECTION_OK)\n\t{\n\t\tcheck_primary_standby_version_match(conn, primary_conn);\n\t}\n\n\n\t/*\n\t * Check that an active node with the same node_name doesn't exist already\n\t */\n\n\trecord_status = get_node_record_by_name(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\tconfig_file_options.node_name,\n\t\t\t\t\t\t\t\t\t\t\t&node_record);\n\n\tif (record_status == RECORD_FOUND)\n\t{\n\t\tif (node_record.active == true && node_record.node_id != config_file_options.node_id)\n\t\t{\n\t\t\tlog_error(_(\"node %i exists already with node_name \\\"%s\\\"\"),\n\t\t\t\t\t  node_record.node_id,\n\t\t\t\t\t  config_file_options.node_name);\n\t\t\tPQfinish(primary_conn);\n\t\t\tif (PQstatus(conn) == CONNECTION_OK)\n\t\t\t\tPQfinish(conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\t/* Check if node record exists */\n\n\trecord_status = get_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\tconfig_file_options.node_id,\n\t\t\t\t\t\t\t\t\t&node_record);\n\n\tif (record_status == RECORD_FOUND && !runtime_options.force)\n\t{\n\t\tlog_error(_(\"node %i is already registered\"),\n\t\t\t\t  config_file_options.node_id);\n\t\tlog_hint(_(\"use option -F/--force to overwrite an existing node record\"));\n\t\tPQfinish(primary_conn);\n\t\tif (PQstatus(conn) == CONNECTION_OK)\n\t\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * If an upstream node is defined, check if that node exists and is active.\n\t *\n\t * If it doesn't exist, and --force set, create a minimal inactive record,\n\t * in the assumption that the user knows what they are doing (usually some kind\n\t * of provisioning where multiple servers are created in parallel) and will\n\t * create the active record later.\n\t */\n\tif (runtime_options.upstream_node_id != NO_UPSTREAM_NODE)\n\t{\n\t\tRecordStatus upstream_record_status = RECORD_NOT_FOUND;\n\t\tt_node_info upstream_node_record = T_NODE_INFO_INITIALIZER;\n\n\t\tif (runtime_options.upstream_node_id == config_file_options.node_id)\n\t\t{\n\t\t\tlog_error(_(\"provided node ID for --upstream-node-id (%i) is the same as the configured local node ID (%i)\"),\n\t\t\t\t\t  runtime_options.upstream_node_id,\n\t\t\t\t\t  config_file_options.node_id);\n\t\t\tPQfinish(primary_conn);\n\t\t\tif (PQstatus(conn) == CONNECTION_OK)\n\t\t\t\tPQfinish(conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tupstream_record_status = get_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t runtime_options.upstream_node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t &upstream_node_record);\n\n\t\t/* create placeholder upstream record if -F/--force set */\n\t\tif (upstream_record_status != RECORD_FOUND)\n\t\t{\n\t\t\tt_node_info placeholder_upstream_node_record = T_NODE_INFO_INITIALIZER;\n\n\t\t\tif (!runtime_options.force)\n\t\t\t{\n\t\t\t\tlog_error(_(\"no record found for upstream node %i\"),\n\t\t\t\t\t\t  runtime_options.upstream_node_id);\n\t\t\t\t/* footgun alert - only do this if you know what you're doing */\n\t\t\t\tlog_hint(_(\"use option -F/--force to create a dummy upstream record\"));\n\t\t\t\tPQfinish(primary_conn);\n\t\t\t\tif (PQstatus(conn) == CONNECTION_OK)\n\t\t\t\t\tPQfinish(conn);\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\n\t\t\tlog_notice(_(\"creating placeholder record for upstream node %i\"),\n\t\t\t\t\t   runtime_options.upstream_node_id);\n\n\t\t\tplaceholder_upstream_node_record.node_id = runtime_options.upstream_node_id;\n\t\t\tplaceholder_upstream_node_record.type = STANDBY;\n\t\t\tplaceholder_upstream_node_record.upstream_node_id = NO_UPSTREAM_NODE;\n\t\t\tstrncpy(placeholder_upstream_node_record.conninfo, runtime_options.upstream_conninfo, MAXLEN);\n\t\t\tplaceholder_upstream_node_record.active = false;\n\n\t\t\trecord_created = create_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\"standby register\",\n\t\t\t\t\t\t\t\t\t\t\t\t&placeholder_upstream_node_record);\n\n\t\t\t/*\n\t\t\t * It's possible, in the kind of scenario this functionality is\n\t\t\t * intended to support, that there's a race condition where the\n\t\t\t * node's actual record gets inserted, causing the insert of the\n\t\t\t * placeholder record to fail. If this is the case, we don't worry\n\t\t\t * about this insert failing; if not we bail out.\n\t\t\t *\n\t\t\t * TODO: teach create_node_record() to use ON CONFLICT DO NOTHING\n\t\t\t * for 9.5 and later.\n\t\t\t */\n\t\t\tif (record_created == false)\n\t\t\t{\n\t\t\t\tupstream_record_status = get_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t runtime_options.upstream_node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &placeholder_upstream_node_record);\n\t\t\t\tif (upstream_record_status != RECORD_FOUND)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to create placeholder record for upstream node %i\"),\n\t\t\t\t\t\t\t  runtime_options.upstream_node_id);\n\t\t\t\t\tPQfinish(primary_conn);\n\t\t\t\t\tif (PQstatus(conn) == CONNECTION_OK)\n\t\t\t\t\t\tPQfinish(conn);\n\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t}\n\n\t\t\t\tlog_info(_(\"a record for upstream node %i was already created\"),\n\t\t\t\t\t\t runtime_options.upstream_node_id);\n\t\t\t}\n\t\t}\n\t\telse if (node_record.active == false)\n\t\t{\n\t\t\t/*\n\t\t\t * upstream node is inactive and --force not supplied - refuse to\n\t\t\t * register\n\t\t\t */\n\t\t\tif (!runtime_options.force)\n\t\t\t{\n\t\t\t\tlog_error(_(\"record for upstream node %i is marked as inactive\"),\n\t\t\t\t\t\t  runtime_options.upstream_node_id);\n\t\t\t\tlog_hint(_(\"use option -F/--force to register a standby with an inactive upstream node\"));\n\t\t\t\tPQfinish(primary_conn);\n\t\t\t\tif (PQstatus(conn) == CONNECTION_OK)\n\t\t\t\t\tPQfinish(conn);\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * user is using the --force - notify about the potential footgun\n\t\t\t */\n\t\t\tlog_notice(_(\"registering node %i with inactive upstream node %i\"),\n\t\t\t\t\t   config_file_options.node_id,\n\t\t\t\t\t   runtime_options.upstream_node_id);\n\t\t}\n\t\t/* check upstream node is accessible and this node is connected */\n\t\telse\n\t\t{\n\t\t\tPGconn\t   *upstream_conn = NULL;\n\n\t\t\tupstream_conn = establish_db_connection(upstream_node_record.conninfo, false);\n\n\t\t\tif (PQstatus(upstream_conn) != CONNECTION_OK)\n\t\t\t{\n\t\t\t\tif (!runtime_options.force)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to connect to upstream node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t  upstream_node_record.node_name,\n\t\t\t\t\t\t\t  upstream_node_record.node_id);\n\t\t\t\t\tlog_hint(_(\"use -F/--force to continue anyway\"));\n\t\t\t\t\tPQfinish(primary_conn);\n\t\t\t\t\tif (PQstatus(conn) == CONNECTION_OK)\n\t\t\t\t\t\tPQfinish(conn);\n\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t}\n\n\t\t\t\tlog_warning(_(\"unable to connect to upstream node \\\"%s\\\" (ID: %i) but continuing anyway\"),\n\t\t\t\t\t\t\tupstream_node_record.node_name,\n\t\t\t\t\t\t\tupstream_node_record.node_id);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* check our standby is connected */\n\t\t\t\tif (is_downstream_node_attached(upstream_conn, config_file_options.node_name, NULL) == NODE_ATTACHED)\n\t\t\t\t{\n\t\t\t\t\tlog_verbose(LOG_INFO, _(\"local node is attached to specified upstream node %i\"), runtime_options.upstream_node_id);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!runtime_options.force)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_error(_(\"this node does not appear to be attached to upstream node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t\t  upstream_node_record.node_name,\n\t\t\t\t\t\t\t\t  upstream_node_record.node_id);\n\n\t\t\t\t\t\tlog_detail(_(\"no record for application name \\\"%s\\\" found in \\\"pg_stat_replication\\\"\"),\n\t\t\t\t\t\t\t\t   config_file_options.node_name);\n\t\t\t\t\t\tlog_hint(_(\"use -F/--force to continue anyway\"));\n\t\t\t\t\t\tPQfinish(primary_conn);\n\t\t\t\t\t\tif (PQstatus(conn) == CONNECTION_OK)\n\t\t\t\t\t\t\tPQfinish(conn);\n\t\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t\t}\n\t\t\t\t\tlog_warning(_(\"this node does not appear to be attached to upstream node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t\tupstream_node_record.node_name,\n\t\t\t\t\t\t\t\tupstream_node_record.node_id);\n\t\t\t\t}\n\t\t\t\tPQfinish(upstream_conn);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * populate node record structure with current values set in repmgr.conf\n\t * and/or the command line (this will overwrite  any existing values, which\n\t * is what we want when updating the record)\n\t */\n\tinit_node_record(&node_record);\n\tnode_record.type = STANDBY;\n\n\t/* if --upstream-node-id not provided, set to primary node id */\n\tif (node_record.upstream_node_id == UNKNOWN_NODE_ID)\n\t{\n\t\tnode_record.upstream_node_id = primary_node_id;\n\t}\n\n\t/*\n\t * If --upstream-node-id not provided, we're defaulting to the primary as\n\t * upstream node. If local node is available, double-check that it's attached\n\t * to the primary, in case --upstream-node-id was an accidental omission.\n\t *\n\t * Currently we'll only do this for newly registered nodes.\n\t */\n\tif (runtime_options.upstream_node_id == NO_UPSTREAM_NODE && PQstatus(conn) == CONNECTION_OK)\n\t{\n\t\t/* only do this if record does not exist */\n\t\tif (record_status != RECORD_FOUND)\n\t\t{\n\t\t\tlog_warning(_(\"--upstream-node-id not supplied, assuming upstream node is primary (node ID: %i)\"),\n\t\t\t\t\t\tprimary_node_id);\n\n\t\t\t/* check our standby is connected */\n\t\t\tif (is_downstream_node_attached(primary_conn, config_file_options.node_name, NULL) == NODE_ATTACHED)\n\t\t\t{\n\t\t\t\tlog_verbose(LOG_INFO, _(\"local node is attached to primary\"));\n\t\t\t}\n\t\t\telse if (runtime_options.force == false)\n\t\t\t{\n\t\t\t\tlog_error(_(\"local node not attached to primary node %i\"), primary_node_id);\n\t\t\t\t/* TODO: 9.6 and later, display detail from pg_stat_wal_receiver */\n\t\t\t\tlog_hint(_(\"specify the actual upstream node id with --upstream-node-id, or use -F/--force to continue anyway\"));\n\n\t\t\t\tif (runtime_options.dry_run == true)\n\t\t\t\t{\n\t\t\t\t\tdry_run_ok = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tPQfinish(primary_conn);\n\t\t\t\t\tPQfinish(conn);\n\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_warning(_(\"local node not attached to primary node %i\"), primary_node_id);\n\t\t\t\tlog_notice(_(\"-F/--force supplied, continuing anyway\"));\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tPQfinish(primary_conn);\n\t\tif (PQstatus(conn) == CONNECTION_OK)\n\t\t\tPQfinish(conn);\n\n\t\tif (dry_run_ok == false)\n\t\t{\n\t\t\tlog_warning(_(\"issue(s) encountered; see preceding log messages\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tlog_info(_(\"all prerequisites for \\\"standby register\\\" are met\"));\n\n\t\texit(SUCCESS);\n\t}\n\n\t/*\n\t * node record exists - update it (at this point we have already\n\t * established that -F/--force is in use)\n\t */\n\tif (record_status == RECORD_FOUND)\n\t{\n\t\trecord_created = update_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t\"standby register\",\n\t\t\t\t\t\t\t\t\t\t\t&node_record);\n\t}\n\telse\n\t{\n\t\trecord_created = create_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t\"standby register\",\n\t\t\t\t\t\t\t\t\t\t\t&node_record);\n\t}\n\n\tinitPQExpBuffer(&details);\n\n\tif (record_created == false)\n\t{\n\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t  _(\"standby registration failed; provided upstream node ID was %i\"),\n\t\t\t\t\t\t  node_record.upstream_node_id);\n\n\t\tif (runtime_options.force == true)\n\t\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t\t _(\" (-F/--force option was used)\"));\n\n\t\tcreate_event_notification_extended(\n\t\t\tprimary_conn,\n\t\t\t&config_file_options,\n\t\t\tconfig_file_options.node_id,\n\t\t\t\"standby_register\",\n\t\t\tfalse,\n\t\t\tdetails.data,\n\t\t\t&event_info);\n\n\t\ttermPQExpBuffer(&details);\n\t\tPQfinish(primary_conn);\n\t\tprimary_conn = NULL;\n\n\t\tif (PQstatus(conn) == CONNECTION_OK)\n\t\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tappendPQExpBuffer(&details,\n\t\t\t\t\t  _(\"standby registration succeeded; upstream node ID is %i\"),\n\t\t\t\t\t  node_record.upstream_node_id);\n\n\tif (runtime_options.force == true)\n\t\tappendPQExpBufferStr(&details,\n\t\t\t\t\t\t\t _(\" (-F/--force option was used)\"));\n\n\n\t/* Log the event */\n\tcreate_event_notification_extended(\n\t\tprimary_conn,\n\t\t&config_file_options,\n\t\tconfig_file_options.node_id,\n\t\t\"standby_register\",\n\t\ttrue,\n\t\tdetails.data,\n\t\t&event_info);\n\n\ttermPQExpBuffer(&details);\n\n\t/*\n\t * If --wait-sync option set, wait for the records to synchronise\n\t * (unless 0 seconds provided, which disables it, which is the same as\n\t *  not providing the option). The default value is -1, which means\n\t * no timeout.\n\t */\n\n\tif (PQstatus(conn) == CONNECTION_OK &&\n\t\truntime_options.wait_register_sync == true &&\n\t\truntime_options.wait_register_sync_seconds != 0)\n\t{\n\t\tbool\t\tsync_ok = false;\n\t\tint\t\t\ttimer = 0;\n\t\tRecordStatus node_record_status = RECORD_NOT_FOUND;\n\t\tt_node_info node_record_on_primary = T_NODE_INFO_INITIALIZER;\n\t\tt_node_info node_record_on_standby = T_NODE_INFO_INITIALIZER;\n\n\t\tnode_record_status = get_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t\t &node_record_on_primary);\n\n\t\tif (node_record_status != RECORD_FOUND)\n\t\t{\n\t\t\tlog_error(_(\"unable to retrieve node record from primary\"));\n\t\t\tPQfinish(primary_conn);\n\t\t\tPQfinish(conn);\n\t\t\texit(ERR_REGISTRATION_SYNC);\n\t\t}\n\n\t\tfor (;;)\n\t\t{\n\t\t\tbool\t\trecords_match = true;\n\n\t\t\t/*\n\t\t\t * If timeout set to a positive value, check if we've reached it and\n\t\t\t * exit the loop\n\t\t\t */\n\t\t\tif (runtime_options.wait_register_sync_seconds > 0 && runtime_options.wait_register_sync_seconds == timer)\n\t\t\t\tbreak;\n\n\t\t\tnode_record_status = get_node_record(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t &node_record_on_standby);\n\n\t\t\tif (node_record_status == RECORD_NOT_FOUND)\n\t\t\t{\n\t\t\t\t/* no record available yet on standby */\n\t\t\t\trecords_match = false;\n\t\t\t}\n\t\t\telse if (node_record_status == RECORD_FOUND)\n\t\t\t{\n\t\t\t\t/* compare relevant fields */\n\t\t\t\tif (node_record_on_standby.upstream_node_id != node_record_on_primary.upstream_node_id)\n\t\t\t\t\trecords_match = false;\n\n\t\t\t\tif (node_record_on_standby.type != node_record_on_primary.type)\n\t\t\t\t\trecords_match = false;\n\n\t\t\t\tif (node_record_on_standby.priority != node_record_on_primary.priority)\n\t\t\t\t\trecords_match = false;\n\n\t\t\t\tif (strcmp(node_record_on_standby.location, node_record_on_primary.location) != 0)\n\t\t\t\t\trecords_match = false;\n\n\t\t\t\tif (node_record_on_standby.active != node_record_on_primary.active)\n\t\t\t\t\trecords_match = false;\n\n\t\t\t\tif (strcmp(node_record_on_standby.node_name, node_record_on_primary.node_name) != 0)\n\t\t\t\t\trecords_match = false;\n\n\t\t\t\tif (strcmp(node_record_on_standby.conninfo, node_record_on_primary.conninfo) != 0)\n\t\t\t\t\trecords_match = false;\n\n\t\t\t\tif (strcmp(node_record_on_standby.slot_name, node_record_on_primary.slot_name) != 0)\n\t\t\t\t\trecords_match = false;\n\n\t\t\t\tif (records_match == true)\n\t\t\t\t{\n\t\t\t\t\tsync_ok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsleep(1);\n\t\t\ttimer++;\n\t\t}\n\n\t\t/* Log the event */\n\t\tinitPQExpBuffer(&details);\n\n\t\tif (sync_ok == false)\n\t\t{\n\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t  _(\"node record was not synchronised after %i seconds\"),\n\t\t\t\t\t\t\t  runtime_options.wait_register_sync_seconds);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t\t  _(\"node record synchronised after %i seconds\"),\n\t\t\t\t\t\t\t  timer);\n\t\t}\n\n\t\tcreate_event_notification_extended(\n\t\t\tprimary_conn,\n\t\t\t&config_file_options,\n\t\t\tconfig_file_options.node_id,\n\t\t\t\"standby_register_sync\",\n\t\t\tsync_ok,\n\t\t\tdetails.data,\n\t\t\t&event_info);\n\n\t\tif (sync_ok == false)\n\t\t{\n\t\t\tlog_error(\"%s\", details.data);\n\t\t\ttermPQExpBuffer(&details);\n\t\t\tPQfinish(primary_conn);\n\t\t\tPQfinish(conn);\n\t\t\texit(ERR_REGISTRATION_SYNC);\n\t\t}\n\n\t\tlog_info(_(\"node record on standby synchronised from primary\"));\n\t\tlog_detail(\"%s\", details.data);\n\t\ttermPQExpBuffer(&details);\n\t}\n\n\n\tPQfinish(primary_conn);\n\n\tif (PQstatus(conn) == CONNECTION_OK)\n\t\tPQfinish(conn);\n\n\tlog_info(_(\"standby registration complete\"));\n\tlog_notice(_(\"standby node \\\"%s\\\" (ID: %i) successfully registered\"),\n\t\t\t   config_file_options.node_name, config_file_options.node_id);\n\treturn;\n}\n\n\n/*\n * do_standby_unregister()\n *\n * Event(s):\n *  - standby_unregister\n */\nvoid\ndo_standby_unregister(void)\n{\n\tPGconn\t   *conn = NULL;\n\tPGconn\t   *primary_conn = NULL;\n\n\tint\t\t\ttarget_node_id = UNKNOWN_NODE_ID;\n\tt_node_info node_info = T_NODE_INFO_INITIALIZER;\n\n\tbool\t\tnode_record_deleted = false;\n\n\tlog_info(_(\"connecting to local standby\"));\n\tconn = establish_db_connection(config_file_options.conninfo, true);\n\n\t/* check if there is a primary in this cluster */\n\tlog_info(_(\"connecting to primary database\"));\n\n\tprimary_conn = get_primary_connection(conn, NULL, NULL);\n\n\tif (PQstatus(primary_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to connect to primary server\"));\n\t\tlog_detail(\"\\n%s\", PQerrorMessage(conn));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * if --node-id was specified, unregister that node rather than the\n\t * current one - this enables inactive nodes to be unregistered.\n\t */\n\tif (runtime_options.node_id != UNKNOWN_NODE_ID)\n\t\ttarget_node_id = runtime_options.node_id;\n\telse\n\t\ttarget_node_id = config_file_options.node_id;\n\n\t/* Check node exists and is really a standby */\n\n\tif (get_node_record(primary_conn, target_node_id, &node_info) != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"no record found for node %i\"), target_node_id);\n\t\tPQfinish(primary_conn);\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tif (node_info.type != STANDBY)\n\t{\n\t\tlog_error(_(\"node %i is not a standby server\"), target_node_id);\n\t\tPQfinish(primary_conn);\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* Now unregister the standby */\n\tlog_notice(_(\"unregistering node %i\"), target_node_id);\n\tnode_record_deleted = delete_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t target_node_id);\n\n\tif (node_record_deleted == false)\n\t{\n\t\tPQfinish(primary_conn);\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* Log the event */\n\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t  target_node_id,\n\t\t\t\t\t\t\t  \"standby_unregister\",\n\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t  NULL);\n\n\tPQfinish(primary_conn);\n\tPQfinish(conn);\n\n\tlog_info(_(\"standby unregistration complete\"));\n\n\treturn;\n}\n\n\n/*\n * do_standby_promote()\n *\n * Event(s):\n *  - standby_promote\n */\nvoid\ndo_standby_promote(void)\n{\n\tPGconn\t   *local_conn = NULL;\n\tPGconn\t   *current_primary_conn = NULL;\n\n\tRecoveryType recovery_type = RECTYPE_UNKNOWN;\n\n\tint\t\t\texisting_primary_id = UNKNOWN_NODE_ID;\n\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\tt_node_info local_node_record = T_NODE_INFO_INITIALIZER;\n\n\tNodeInfoList sibling_nodes = T_NODE_INFO_LIST_INITIALIZER;\n\tSiblingNodeStats sibling_nodes_stats = T_SIBLING_NODES_STATS_INITIALIZER;\n\tint\t\t\tavailable_wal_senders = 0;\n\tbool\t\tdry_run_success = true;\n\n\tlocal_conn = establish_db_connection(config_file_options.conninfo, true);\n\n\tlog_verbose(LOG_INFO, _(\"connected to standby, checking its state\"));\n\n\t/* Verify that standby is a supported server version */\n\t(void) check_server_version(local_conn, \"standby\", true, NULL);\n\n\t/* Check we are in a standby node */\n\trecovery_type = get_recovery_type(local_conn);\n\n\tif (recovery_type != RECTYPE_STANDBY)\n\t{\n\t\tif (recovery_type == RECTYPE_PRIMARY)\n\t\t{\n\t\t\tlog_error(_(\"STANDBY PROMOTE can only be executed on a standby node\"));\n\t\t\tPQfinish(local_conn);\n\t\t\texit(ERR_PROMOTION_FAIL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_error(_(\"unable to determine node's recovery state\"));\n\t\t\tPQfinish(local_conn);\n\t\t\texit(ERR_DB_CONN);\n\t\t}\n\t}\n\telse if (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"node is a standby\"));\n\t}\n\n\trecord_status = get_node_record(local_conn, config_file_options.node_id, &local_node_record);\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve node record for node %i\"),\n\t\t\t\t  config_file_options.node_id);\n\n\t\tPQfinish(local_conn);\n\n\t\texit(ERR_DB_QUERY);\n\t}\n\n\t/*\n\t * In PostgreSQL 12 and earlier, executing \"pg_ctl ... promote\" when WAL\n\t * replay is paused and WAL is pending replay will mean the standby will\n\t * not promote until replay is resumed.\n\t *\n\t * As that could happen at any time outside repmgr's control, we\n\t * need to avoid leaving a \"ticking timebomb\" which might cause\n\t * an unexpected status change in the replication cluster.\n\t */\n\tif (PQserverVersion(local_conn) < 130000)\n\t{\n\t\tReplInfo \treplication_info;\n\t\tbool \t \treplay_paused = false;\n\n\t\tinit_replication_info(&replication_info);\n\n\t\tif (get_replication_info(local_conn, STANDBY, &replication_info) == false)\n\t\t{\n\t\t\tlog_error(_(\"unable to retrieve replication information from local node\"));\n\t\t\tPQfinish(local_conn);\n\t\t\texit(ERR_PROMOTION_FAIL);\n\t\t}\n\n\t\t/*\n\t\t * If the local node is recovering from archive, we can't tell\n\t\t * whether there's still WAL which needs to be replayed, so\n\t\t * we'll abort if WAL replay is paused.\n\t\t */\n\t\tif (replication_info.receiving_streamed_wal == false)\n\t\t{\n\t\t\t/* just a simple check for paused WAL replay */\n\t\t\treplay_paused = is_wal_replay_paused(local_conn, false);\n\t\t\tif (replay_paused == true)\n\t\t\t{\n\t\t\t\tlog_error(_(\"WAL replay is paused on this node\"));\n\t\t\t\tlog_detail(_(\"node is in archive recovery and is not safe to promote in this state\"));\n\t\t\t\tlog_detail(_(\"replay paused at %X/%X\"),\n\t\t\t\t\t\t   format_lsn(replication_info.last_wal_replay_lsn));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* check that replay is pause *and* WAL is pending replay */\n\t\t\treplay_paused = is_wal_replay_paused(local_conn, true);\n\t\t\tif (replay_paused == true)\n\t\t\t{\n\t\t\t\tlog_error(_(\"WAL replay is paused on this node but not all WAL has been replayed\"));\n\t\t\t\tlog_detail(_(\"replay paused at %X/%X; last WAL received is %X/%X\"),\n\t\t\t\t\t\t   format_lsn(replication_info.last_wal_replay_lsn),\n\t\t\t\t\t\t   format_lsn(replication_info.last_wal_receive_lsn));\n\t\t\t}\n\t\t}\n\n\t\tif (replay_paused == true)\n\t\t{\n\t\t\tif (PQserverVersion(local_conn) >= 100000)\n\t\t\t\tlog_hint(_(\"execute \\\"pg_wal_replay_resume()\\\" to unpause WAL replay\"));\n\t\t\telse\n\t\t\t\tlog_hint(_(\"execute \\\"pg_xlog_replay_resume()\\\" to npause WAL replay\"));\n\n\t\t\tPQfinish(local_conn);\n\t\t\texit(ERR_PROMOTION_FAIL);\n\t\t}\n\t}\n\n\t/* check that there's no existing primary */\n\tcurrent_primary_conn = get_primary_connection_quiet(local_conn, &existing_primary_id, NULL);\n\n\tif (PQstatus(current_primary_conn) == CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"this replication cluster already has an active primary server\"));\n\n\t\tif (existing_primary_id != UNKNOWN_NODE_ID)\n\t\t{\n\t\t\tt_node_info primary_rec;\n\n\t\t\tget_node_record(local_conn, existing_primary_id, &primary_rec);\n\n\t\t\tlog_detail(_(\"current primary is \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t   primary_rec.node_name,\n\t\t\t\t\t   existing_primary_id);\n\t\t}\n\n\t\tPQfinish(current_primary_conn);\n\t\tPQfinish(local_conn);\n\t\texit(ERR_PROMOTION_FAIL);\n\t}\n\telse if (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"no active primary server found in this replication cluster\"));\n\t}\n\n\tPQfinish(current_primary_conn);\n\n\t/*\n\t * populate local node record with current state of various replication-related\n\t * values, so we can check for sufficient walsenders and replication slots\n\t */\n\tget_node_replication_stats(local_conn, &local_node_record);\n\n\tavailable_wal_senders = local_node_record.max_wal_senders -\n\t\tlocal_node_record.attached_wal_receivers;\n\n\n\t/*\n\t * Get list of sibling nodes; if --siblings-follow specified,\n\t * check they're reachable; if not, the list will be used to warn\n\t * about nodes which will not follow the new primary\n\t */\n\tget_active_sibling_node_records(local_conn,\n\t\t\t\t\t\t\t\t\tlocal_node_record.node_id,\n\t\t\t\t\t\t\t\t\tlocal_node_record.upstream_node_id,\n\t\t\t\t\t\t\t\t\t&sibling_nodes);\n\n\tif (check_sibling_nodes(&sibling_nodes, &sibling_nodes_stats) == false)\n\t{\n\t\tPQfinish(local_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * check there are sufficient free walsenders - obviously there's potential\n\t * for a later race condition if some walsenders come into use before the\n\t * promote operation gets around to attaching the sibling nodes, but\n\t * this should catch any actual existing configuration issue (and if anyone's\n\t * performing a promote in such an unstable environment, they only have\n\t * themselves to blame).\n\t */\n\tif (check_free_wal_senders(available_wal_senders, &sibling_nodes_stats, &dry_run_success) == false)\n\t{\n\t\tif (runtime_options.dry_run == false || runtime_options.force == false)\n\t\t{\n\t\t\tPQfinish(local_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\n\t/*\n\t * if replication slots are required by siblings,\n\t * check the promotion candidate has sufficient free slots\n\t */\n\tif (check_free_slots(&local_node_record, &sibling_nodes_stats, &dry_run_success) == false)\n\t{\n\t\tif (runtime_options.dry_run == false || runtime_options.force == false)\n\t\t{\n\t\t\tPQfinish(local_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\t/*\n\t * In --dry-run mode, note which promotion method will be used.\n\t * For Pg12 and later, check whether pg_promote() can be executed.\n\t */\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tif (config_file_options.service_promote_command[0] != '\\0')\n\t\t{\n\t\t\tlog_info(_(\"node will be promoted using command defined in \\\"service_promote_command\\\"\"));\n\t\t\tlog_detail(_(\"\\\"service_promote_command\\\" is \\\"%s\\\"\"),\n\t\t\t\t\t   config_file_options.service_promote_command);\n\t\t}\n\t\telse if (PQserverVersion(local_conn) >= 120000)\n\t\t{\n\t\t\tif (can_execute_pg_promote(local_conn) == false)\n\t\t\t{\n\t\t\t\tlog_info(_(\"node will be promoted using \\\"pg_ctl promote\\\"\"));\n\t\t\t\tlog_detail(_(\"user \\\"%s\\\" does not have permission to execute \\\"pg_promote()\\\"\"),\n\t\t\t\t\t\t   PQuser(local_conn));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_info(_(\"node will be promoted using the \\\"pg_promote()\\\" function\"));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_info(_(\"node will be promoted using \\\"pg_ctl promote\\\"\"));\n\t\t}\n\t}\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tPQfinish(local_conn);\n\n\t\tif (dry_run_success == false)\n\t\t{\n\t\t\tlog_error(_(\"prerequisites for executing STANDBY PROMOTE are *not* met\"));\n\t\t\tlog_hint(_(\"see preceding error messages\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t\tlog_info(_(\"prerequisites for executing STANDBY PROMOTE are met\"));\n\t\texit(SUCCESS);\n\t}\n\n\t_do_standby_promote_internal(local_conn);\n\n\t/*\n\t * If --siblings-follow specified, attempt to make them follow the new\n\t * primary\n\t */\n\tif (runtime_options.siblings_follow == true && sibling_nodes.node_count > 0)\n\t{\n\t\tsibling_nodes_follow(&local_node_record, &sibling_nodes, &sibling_nodes_stats);\n\t}\n\n\tclear_node_info_list(&sibling_nodes);\n\n\treturn;\n}\n\n\nstatic void\n_do_standby_promote_internal(PGconn *conn)\n{\n\tint\t\t\ti;\n\tbool\t\tpromote_success = false;\n\tPQExpBufferData details;\n\n\tRecoveryType recovery_type = RECTYPE_UNKNOWN;\n\n\tt_node_info local_node_record = T_NODE_INFO_INITIALIZER;\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\tchar\t\tdata_dir[MAXPGPATH];\n\n\tget_node_config_directory(data_dir);\n\n\t/* fetch local node record so we can add detail in log messages */\n\trecord_status = get_node_record(conn,\n\t\t\t\t\t\t\t\t\tconfig_file_options.node_id,\n\t\t\t\t\t\t\t\t\t&local_node_record);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve record for node %i\"),\n\t\t\t\t  config_file_options.node_id);\n\t\tPQfinish(conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\n\t/*\n\t * Promote standby to primary.\n\t *\n\t * \"pg_ctl promote: returns immediately and (prior to 10.0) has no -w\n\t * option so we can't be sure when or if the promotion completes. For now\n\t * we'll poll the server until the default timeout (60 seconds)\n\t *\n\t * For PostgreSQL 12+, use the pg_promote() function, unless one of\n\t * \"service_promote_command\" or \"use_pg_ctl_promote\" is set.\n\t */\n\t{\n\t\tbool use_pg_promote = false;\n\n\n\t\tif (PQserverVersion(conn) >= 120000)\n\t\t{\n\t\t\tuse_pg_promote = true;\n\n\t\t\tif (config_file_options.service_promote_command[0] != '\\0')\n\t\t\t{\n\t\t\t\tuse_pg_promote = false;\n\t\t\t}\n\t\t\telse if (can_execute_pg_promote(conn) == false)\n\t\t\t{\n\t\t\t\tuse_pg_promote = false;\n\t\t\t\tlog_info(_(\"user \\\"%s\\\" does not have permission to execute \\\"pg_promote()\\\", falling back to \\\"pg_ctl promote\\\"\"),\n\t\t\t\t\t\t PQuser(conn));\n\t\t\t}\n\t\t}\n\n\t\tlog_notice(_(\"promoting standby to primary\"));\n\n\t\tif (use_pg_promote == true)\n\t\t{\n\t\t\tlog_detail(_(\"promoting server \\\"%s\\\" (ID: %i) using pg_promote()\"),\n\t\t\t\t\t   local_node_record.node_name,\n\t\t\t\t\t   local_node_record.node_id);\n\n\t\t\t/*\n\t\t\t * We'll check for promotion success ourselves, but will abort\n\t\t\t * if some unrecoverable error prevented the function from being\n\t\t\t * executed.\n\t\t\t */\n\t\t\tif (!promote_standby(conn, false, 0))\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to promote server from standby to primary\"));\n\t\t\t\texit(ERR_PROMOTION_FAIL);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar\t\tscript[MAXLEN];\n\t\t\tint\t\t\tr;\n\n\t\t\tget_server_action(ACTION_PROMOTE, script, (char *) data_dir);\n\n\t\t\tlog_detail(_(\"promoting server \\\"%s\\\" (ID: %i) using \\\"%s\\\"\"),\n\t\t\t\t\t   local_node_record.node_name,\n\t\t\t\t\t   local_node_record.node_id,\n\t\t\t\t\t   script);\n\n\t\t\tr = system(script);\n\t\t\tif (r != 0)\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to promote server from standby to primary\"));\n\t\t\t\texit(ERR_PROMOTION_FAIL);\n\t\t\t}\n\t\t}\n\t}\n\n\tlog_notice(_(\"waiting up to %i seconds (parameter \\\"promote_check_timeout\\\") for promotion to complete\"),\n\t\t\t   config_file_options.promote_check_timeout);\n\n\tfor (i = 0; i < config_file_options.promote_check_timeout; i += config_file_options.promote_check_interval)\n\t{\n\t\trecovery_type = get_recovery_type(conn);\n\n\t\tif (recovery_type == RECTYPE_PRIMARY)\n\t\t{\n\t\t\tpromote_success = true;\n\t\t\tbreak;\n\t\t}\n\t\tsleep(config_file_options.promote_check_interval);\n\t}\n\n\tif (promote_success == false)\n\t{\n\t\tif (recovery_type == RECTYPE_STANDBY)\n\t\t{\n\t\t\tlog_error(_(\"STANDBY PROMOTE failed, node is still a standby\"));\n\t\t\tlog_detail(_(\"node still in recovery after %i seconds\"), config_file_options.promote_check_timeout);\n\t\t\tlog_hint(_(\"the node may need more time to promote itself, check the PostgreSQL log for details\"));\n\t\t\tPQfinish(conn);\n\t\t\texit(ERR_PROMOTION_FAIL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_error(_(\"connection to node lost\"));\n\t\t\tPQfinish(conn);\n\t\t\texit(ERR_DB_CONN);\n\t\t}\n\t}\n\n\tlog_verbose(LOG_INFO, _(\"standby promoted to primary after %i second(s)\"), i);\n\n\t/* update node information to reflect new status */\n\tif (update_node_record_set_primary(conn, config_file_options.node_id) == false)\n\t{\n\t\tinitPQExpBuffer(&details);\n\t\tappendPQExpBuffer(&details,\n\t\t\t\t\t\t  _(\"unable to update node record for node %i\"),\n\t\t\t\t\t\t  config_file_options.node_id);\n\n\t\tlog_error(\"%s\", details.data);\n\n\t\tcreate_event_notification(NULL,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t  \"standby_promote\",\n\t\t\t\t\t\t\t\t  false,\n\t\t\t\t\t\t\t\t  details.data);\n\n\t\texit(ERR_DB_QUERY);\n\t}\n\n\n\tinitPQExpBuffer(&details);\n\tappendPQExpBuffer(&details,\n\t\t\t\t\t  _(\"server \\\"%s\\\" (ID: %i) was successfully promoted to primary\"),\n\t\t\t\t\t  local_node_record.node_name,\n\t\t\t\t\t  local_node_record.node_id);\n\n\tlog_notice(_(\"STANDBY PROMOTE successful\"));\n\tlog_detail(\"%s\", details.data);\n\n\t/* Log the event */\n\tcreate_event_notification(conn,\n\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t  \"standby_promote\",\n\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t  details.data);\n\n\ttermPQExpBuffer(&details);\n\n\treturn;\n}\n\n\n/*\n * Follow a new primary.\n *\n * Node must be running. To start an inactive node and point it at a\n * new primary, use \"repmgr node rejoin\".\n *\n * TODO: enable provision of new primary's conninfo parameters, which\n * will be necessary if the primary's information has changed, but\n * was not replicated to the current standby.\n */\n\nvoid\ndo_standby_follow(void)\n{\n\tPGconn\t   *local_conn = NULL;\n\tt_node_info local_node_record = T_NODE_INFO_INITIALIZER;\n\n\tPGconn\t   *primary_conn = NULL;\n\tint\t\t\tprimary_node_id = UNKNOWN_NODE_ID;\n\n\tPGconn\t   *follow_target_conn = NULL;\n\tint\t\t\tfollow_target_node_id = UNKNOWN_NODE_ID;\n\tt_node_info follow_target_node_record = T_NODE_INFO_INITIALIZER;\n\tbool\t\tfollow_target_is_primary = true;\n\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\t/* so we can pass info about the primary to event notification scripts */\n\tt_event_info event_info = T_EVENT_INFO_INITIALIZER;\n\n\tint\t\t\ttimer = 0;\n\n\tPQExpBufferData follow_output;\n\tbool\t\tsuccess = false;\n\tint\t\t\tfollow_error_code = SUCCESS;\n\n\tlog_verbose(LOG_DEBUG, \"do_standby_follow()\");\n\n\tlocal_conn = establish_db_connection(config_file_options.conninfo, false);\n\n\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t{\n\t\tlog_hint(_(\"use \\\"repmgr node rejoin\\\" to re-add an inactive node to the replication cluster\"));\n\t\texit(ERR_DB_CONN);\n\t}\n\n\tlog_verbose(LOG_INFO, _(\"connected to local node\"));\n\n\t/* check this is a standby */\n\tcheck_recovery_type(local_conn);\n\n\t/* attempt to retrieve local node record */\n\trecord_status = get_node_record(local_conn,\n\t\t\t\t\t\t\t\t\tconfig_file_options.node_id,\n\t\t\t\t\t\t\t\t\t&local_node_record);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve record for local node %i\"),\n\t\t\t\t  config_file_options.node_id);\n\t\tPQfinish(local_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * --upstream-node-id provided - attempt to follow that node\n\t */\n\tif (runtime_options.upstream_node_id != UNKNOWN_NODE_ID)\n\t{\n\t\t/* we can't follow ourselves */\n\t\tif (runtime_options.upstream_node_id == config_file_options.node_id)\n\t\t{\n\t\t\tlog_error(_(\"provided --upstream-node-id %i is the current node\"),\n\t\t\t\t\t  runtime_options.upstream_node_id);\n\t\t\tPQfinish(local_conn);\n\t\t\texit(ERR_FOLLOW_FAIL);\n\t\t}\n\n\t\tfollow_target_node_id = runtime_options.upstream_node_id;\n\t\trecord_status = get_node_record(local_conn,\n\t\t\t\t\t\t\t\t\t\tfollow_target_node_id,\n\t\t\t\t\t\t\t\t\t\t&follow_target_node_record);\n\n\t\t/* but we must follow a node which exists (=registered) */\n\t\tif (record_status != RECORD_FOUND)\n\t\t{\n\t\t\tlog_error(_(\"unable to find record for intended upstream node %i\"),\n\t\t\t\t\t  runtime_options.upstream_node_id);\n\t\t\tPQfinish(local_conn);\n\t\t\texit(ERR_FOLLOW_FAIL);\n\t\t}\n\t}\n\t/*\n\t * otherwise determine the current primary and attempt to follow that\n\t */\n\telse\n\t{\n\t\tlog_notice(_(\"attempting to find and follow current primary\"));\n\t}\n\n\t/*\n\t * Attempt to connect to follow target - if this was provided with --upstream-node-id,\n\t * we'll connect to that, otherwise we'll attempt to find the current primary.\n\t *\n\t * If --wait provided, loop for up `primary_follow_timeout` seconds\n\t * before giving up\n\t *\n\t * XXX add `upstream_follow_timeout` ?\n\t */\n\n\tfor (timer = 0; timer < config_file_options.primary_follow_timeout; timer++)\n\t{\n\t\t/* --upstream-node-id provided - connect to specified node*/\n\t\tif (follow_target_node_id != UNKNOWN_NODE_ID)\n\t\t{\n\t\t\tfollow_target_conn = establish_db_connection_quiet(follow_target_node_record.conninfo);\n\t\t}\n\t\t/* attempt to find current primary node */\n\t\telse\n\t\t{\n\t\t\tfollow_target_conn = get_primary_connection_quiet(local_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  &follow_target_node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\t\t}\n\n\t\tif (PQstatus(follow_target_conn) == CONNECTION_OK || runtime_options.wait_provided == false)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tsleep(1);\n\t}\n\n\t/* unable to connect to the follow target */\n\tif (PQstatus(follow_target_conn) != CONNECTION_OK)\n\t{\n\t\tif (follow_target_node_id == UNKNOWN_NODE_ID)\n\t\t{\n\t\t\tlog_error(_(\"unable to find a primary node\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_error(_(\"unable to connect to target node %i\"), follow_target_node_id);\n\t\t}\n\n\t\tif (runtime_options.wait_provided == true)\n\t\t{\n\t\t\tif (follow_target_node_id == UNKNOWN_NODE_ID)\n\t\t\t{\n\t\t\t\tlog_detail(_(\"no primary appeared after %i seconds\"),\n\t\t\t\t\t\t   config_file_options.primary_follow_timeout);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_detail(_(\"unable to connect to target node %i after %i seconds\"),\n\t\t\t\t\t\t   follow_target_node_id,\n\t\t\t\t\t\t   config_file_options.primary_follow_timeout);\n\t\t\t}\n\n\t\t\tlog_hint(_(\"alter \\\"primary_follow_timeout\\\" in \\\"repmgr.conf\\\" to change this value\"));\n\t\t}\n\n\t\tPQfinish(local_conn);\n\t\texit(ERR_FOLLOW_FAIL);\n\t}\n\n\t/* --upstream-node-id not provided - retrieve record for node determined as primary  */\n\tif (runtime_options.upstream_node_id == UNKNOWN_NODE_ID)\n\t{\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(_(\"connected to node %i, checking for current primary\"), follow_target_node_id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_verbose(LOG_INFO, _(\"connected to node %i, checking for current primary\"), follow_target_node_id);\n\t\t}\n\n\t\trecord_status = get_node_record(follow_target_conn,\n\t\t\t\t\t\t\t\t\t\tfollow_target_node_id,\n\t\t\t\t\t\t\t\t\t\t&follow_target_node_record);\n\n\t\tif (record_status != RECORD_FOUND)\n\t\t{\n\t\t\tlog_error(_(\"unable to find record for follow target node %i\"),\n\t\t\t\t\t  follow_target_node_id);\n\t\t\tPQfinish(follow_target_conn);\n\t\t\texit(ERR_FOLLOW_FAIL);\n\t\t}\n\t}\n\n\t/*\n\t * Populate \"event_info\" with info about the node to follow for event notifications\n\t *\n\t * XXX need to differentiate between primary and non-primary?\n\t */\n\tevent_info.node_id = follow_target_node_id;\n\tevent_info.node_name = follow_target_node_record.node_name;\n\tevent_info.conninfo_str = follow_target_node_record.conninfo;\n\n\t/*\n\t * Check whether follow target is in recovery, so we know later whether\n\t * we'll need to open a connection to the primary to update the metadata.\n\t * Also emit an informative message.\n\t */\n\t{\n\t\tPQExpBufferData node_info_msg;\n\t\tRecoveryType recovery_type = RECTYPE_UNKNOWN;\n\t\tinitPQExpBuffer(&node_info_msg);\n\n\t\trecovery_type = get_recovery_type(follow_target_conn);\n\n\t\t/*\n\t\t * unlikely this will happen, but it's conceivable the follow target will\n\t\t * have vanished since we last talked to it, or something\n\t\t */\n\t\tif (recovery_type == RECTYPE_UNKNOWN)\n\t\t{\n\t\t\tlog_error(_(\"unable to determine recovery type of follow target\"));\n\t\t\tPQfinish(follow_target_conn);\n\t\t\texit(ERR_FOLLOW_FAIL);\n\t\t}\n\n\t\tif (recovery_type == RECTYPE_PRIMARY)\n\t\t{\n\t\t\tfollow_target_is_primary = true;\n\t\t\tappendPQExpBuffer(&node_info_msg,\n\t\t\t\t\t\t\t  _(\"follow target is primary node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t  follow_target_node_record.node_name,\n\t\t\t\t\t\t\t  follow_target_node_id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfollow_target_is_primary = false;\n\t\t\tappendPQExpBuffer(&node_info_msg,\n\t\t\t\t\t\t\t  _(\"follow target is standby node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t  follow_target_node_record.node_name,\n\t\t\t\t\t\t\t  follow_target_node_id);\n\t\t}\n\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(\"%s\", node_info_msg.data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_verbose(LOG_INFO, \"%s\", node_info_msg.data);\n\t\t}\n\n\t\ttermPQExpBuffer(&node_info_msg);\n\t}\n\n\t/*\n\t * if replication slots in use, check at least one free slot is available\n\t * on the follow target\n\t */\n\n\tif (config_file_options.use_replication_slots)\n\t{\n\t\tbool slots_available = check_replication_slots_available(follow_target_node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t follow_target_conn);\n\t\tif (slots_available == false)\n\t\t{\n\t\t\tPQfinish(follow_target_conn);\n\t\t\tPQfinish(local_conn);\n\t\t\texit(ERR_FOLLOW_FAIL);\n\t\t}\n\t}\n\n\t/* XXX check this is not current upstream anyway */\n\n\t/* check if we can attach to the follow target */\n\t{\n\t\tPGconn\t   *local_repl_conn = NULL;\n\t\tt_system_identification local_identification = T_SYSTEM_IDENTIFICATION_INITIALIZER;\n\n\t\tbool can_follow;\n\t\tXLogRecPtr local_xlogpos = get_node_current_lsn(local_conn);\n\n\t\t/* Check local replication connection - we want to execute IDENTIFY_SYSTEM\n\t\t * to get the current timeline ID, which might not yet be written to\n\t\t * pg_control.\n\t\t *\n\t\t * TODO: from 9.6, query \"pg_stat_wal_receiver\" via the existing local connection\n\t\t */\n\n\t\tlocal_repl_conn = establish_replication_connection_from_conn(local_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t local_node_record.repluser);\n\t\tif (PQstatus(local_repl_conn) != CONNECTION_OK)\n\t\t{\n\t\t\tlog_error(_(\"unable to establish a replication connection to the local node\"));\n\n\t\t\tPQfinish(local_conn);\n\t\t\tPQfinish(follow_target_conn);\n\n\t\t\texit(ERR_FOLLOW_FAIL);\n\t\t}\n\t\telse if (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(_(\"replication connection to the local node was successful\"));\n\t\t}\n\n\t\tsuccess = identify_system(local_repl_conn, &local_identification);\n\t\tPQfinish(local_repl_conn);\n\n\t\tif (success == false)\n\t\t{\n\t\t\tlog_error(_(\"unable to query the local node's system identification\"));\n\n\t\t\tPQfinish(local_conn);\n\n\t\t\tPQfinish(follow_target_conn);\n\n\t\t\texit(ERR_FOLLOW_FAIL);\n\t\t}\n\n\t\tcan_follow = check_node_can_attach(local_identification.timeline,\n\t\t\t\t\t\t\t\t\t\t   local_xlogpos,\n\t\t\t\t\t\t\t\t\t\t   follow_target_conn,\n\t\t\t\t\t\t\t\t\t\t   &follow_target_node_record,\n\t\t\t\t\t\t\t\t\t\t   false);\n\n\t\tif (can_follow == false)\n\t\t{\n\t\t\tPQfinish(local_conn);\n\t\t\tPQfinish(follow_target_conn);\n\t\t\texit(ERR_FOLLOW_FAIL);\n\t\t}\n\t}\n\n\tPQfinish(local_conn);\n\n\t/*\n\t * Here we'll need a connection to the primary, if the upstream is not a primary.\n\t */\n\tif (follow_target_is_primary == false)\n\t{\n\t\t/*\n\t\t * We'll try and establish primary from follow target, in the assumption its node\n\t\t * record is more up-to-date.\n\t\t */\n\t\tprimary_conn = get_primary_connection_quiet(follow_target_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&primary_node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNULL);\n\n\t\t/*\n\t\t * If follow target is not primary and no other primary could be found,\n\t\t * abort because we won't be able to update the node record.\n\t\t */\n\t\tif (PQstatus(primary_conn) != CONNECTION_OK)\n\t\t{\n\t\t\tlog_error(_(\"unable to determine the cluster primary\"));\n\t\t\tlog_detail(_(\"an active primary node is required for \\\"repmgr standby follow\\\"\"));\n\t\t\tPQfinish(follow_target_conn);\n\t\t\texit(ERR_FOLLOW_FAIL);\n\t\t}\n\t}\n\telse\n\t{\n\t\tprimary_conn = follow_target_conn;\n\t}\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"prerequisites for executing STANDBY FOLLOW are met\"));\n\t\texit(SUCCESS);\n\t}\n\n\tinitPQExpBuffer(&follow_output);\n\n\tsuccess = do_standby_follow_internal(\n\t\tprimary_conn,\n\t\tfollow_target_conn,\n\t\t&follow_target_node_record,\n\t\t&follow_output,\n\t\tERR_FOLLOW_FAIL,\n\t\t&follow_error_code);\n\n\t/* unable to restart the standby */\n\tif (success == false)\n\t{\n\t\tcreate_event_notification_extended(\n\t\t\tfollow_target_conn,\n\t\t\t&config_file_options,\n\t\t\tconfig_file_options.node_id,\n\t\t\t\"standby_follow\",\n\t\t\tsuccess,\n\t\t\tfollow_output.data,\n\t\t\t&event_info);\n\n\t\tPQfinish(follow_target_conn);\n\n\t\tif (follow_target_is_primary == false)\n\t\t\tPQfinish(primary_conn);\n\n\t\tlog_notice(_(\"STANDBY FOLLOW failed\"));\n\t\tif (strlen( follow_output.data ))\n\t\t\tlog_detail(\"%s\", follow_output.data);\n\n\t\ttermPQExpBuffer(&follow_output);\n\t\texit(follow_error_code);\n\t}\n\n\ttermPQExpBuffer(&follow_output);\n\n\tinitPQExpBuffer(&follow_output);\n\n\t/*\n\t * Wait up to \"standby_follow_timeout\" seconds for standby to connect to\n\t * upstream.\n\t * For 9.6 and later, we could check pg_stat_wal_receiver on the local node.\n\t */\n\n\t/* assume success, necessary if standby_follow_timeout is zero */\n\tsuccess = true;\n\n\tfor (timer = 0; timer < config_file_options.standby_follow_timeout; timer++)\n\t{\n\t\tNodeAttached node_attached = is_downstream_node_attached(follow_target_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t config_file_options.node_name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL);\n\n\t\tif (node_attached == NODE_ATTACHED)\n\t\t{\n\t\t\tsuccess = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tlog_verbose(LOG_DEBUG, \"sleeping %i of max %i seconds waiting for standby to attach to primary\",\n\t\t\t\t\ttimer + 1,\n\t\t\t\t\tconfig_file_options.standby_follow_timeout);\n\t\tsleep(1);\n\t}\n\n\tif (success == true)\n\t{\n\t\tlog_notice(_(\"STANDBY FOLLOW successful\"));\n\t\tappendPQExpBuffer(&follow_output,\n\t\t\t\t\t\t  \"standby attached to upstream node \\\"%s\\\" (ID: %i)\",\n\t\t\t\t\t\t  follow_target_node_record.node_name,\n\t\t\t\t\t\t  follow_target_node_id);\n\t}\n\telse\n\t{\n\t\tlog_error(_(\"STANDBY FOLLOW failed\"));\n\t\tappendPQExpBuffer(&follow_output,\n\t\t\t\t\t\t  \"standby did not attach to upstream node \\\"%s\\\" (ID: %i) after %i seconds\",\n\t\t\t\t\t\t  follow_target_node_record.node_name,\n\t\t\t\t\t\t  follow_target_node_id,\n\t\t\t\t\t\t  config_file_options.standby_follow_timeout);\n\n\t}\n\n\tlog_detail(\"%s\", follow_output.data);\n\n\tcreate_event_notification_extended(\n\t\tprimary_conn,\n\t\t&config_file_options,\n\t\tconfig_file_options.node_id,\n\t\t\"standby_follow\",\n\t\tsuccess,\n\t\tfollow_output.data,\n\t\t&event_info);\n\n\ttermPQExpBuffer(&follow_output);\n\n\tPQfinish(follow_target_conn);\n\n\tif (follow_target_is_primary == false)\n\t\tPQfinish(primary_conn);\n\n\tif (success == false)\n\t\texit(ERR_FOLLOW_FAIL);\n\n\treturn;\n}\n\n\n/*\n * Perform the actual \"follow\" operation; this is executed by\n * \"node rejoin\" too.\n */\nbool\ndo_standby_follow_internal(PGconn *primary_conn, PGconn *follow_target_conn, t_node_info *follow_target_node_record, PQExpBufferData *output, int general_error_code, int *error_code)\n{\n\tt_node_info local_node_record = T_NODE_INFO_INITIALIZER;\n\tint\t\t\toriginal_upstream_node_id = UNKNOWN_NODE_ID;\n\tt_node_info original_upstream_node_record = T_NODE_INFO_INITIALIZER;\n\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\tchar\t   *errmsg = NULL;\n\n\tbool\t\tremove_old_replication_slot = false;\n\n\t/*\n\t * Fetch our node record so we can write application_name, if set, and to\n\t * get the current upstream node ID, which we'll need to know if replication\n\t * slots are in use and we want to delete this node's slot on the current\n\t * upstream.\n\t */\n\trecord_status = get_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\tconfig_file_options.node_id,\n\t\t\t\t\t\t\t\t\t&local_node_record);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve record for node %i\"),\n\t\t\t\t  config_file_options.node_id);\n\n\t\t*error_code = ERR_BAD_CONFIG;\n\t\treturn false;\n\t}\n\n\t/*\n\t * If replication slots are in use, we'll need to create a slot on the\n\t * follow target\n\t */\n\n\tif (config_file_options.use_replication_slots)\n\t{\n\t\t/*\n\t\t * Here we add a sanity check for the \"slot_name\" field - it's possible\n\t\t * the node was initially registered with \"use_replication_slots=false\"\n\t\t * but the configuration was subsequently changed, leaving the field NULL.\n\t\t *\n\t\t * To avoid annoying failures we can just update the node record and proceed.\n\t\t */\n\n\t\tif (!strlen(local_node_record.slot_name))\n\t\t{\n\t\t\tcreate_slot_name(local_node_record.slot_name, config_file_options.node_id);\n\n\t\t\tlog_notice(_(\"setting node %i's slot name to \\\"%s\\\"\"),\n\t\t\t\t\t   config_file_options.node_id,\n\t\t\t\t\t   local_node_record.slot_name);\n\n\t\t\tupdate_node_record_slot_name(primary_conn, config_file_options.node_id, local_node_record.slot_name);\n\t\t}\n\n\t\tif (create_replication_slot(follow_target_conn,\n\t\t\t\t\t\t\t\t\tlocal_node_record.slot_name,\n\t\t\t\t\t\t\t\t\tfollow_target_node_record,\n\t\t\t\t\t\t\t\t\toutput) == false)\n\t\t{\n\t\t\tlog_error(\"%s\", output->data);\n\n\t\t\t*error_code = general_error_code;\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/*\n\t * Store the original upstream node id so we can delete the\n\t * replication slot, if it exists.\n\t */\n\tif (local_node_record.upstream_node_id != UNKNOWN_NODE_ID)\n\t{\n\t\toriginal_upstream_node_id = local_node_record.upstream_node_id;\n\t}\n\telse\n\t{\n\t\toriginal_upstream_node_id = follow_target_node_record->node_id;\n\t}\n\n\tif (config_file_options.use_replication_slots && runtime_options.host_param_provided == false)\n\t{\n\t\t/*\n\t\t * Only attempt to delete the old replication slot if the old upstream\n\t\t * node is known and is different to the follow target node.\n\t\t */\n\t\tif (original_upstream_node_id != UNKNOWN_NODE_ID\n\t\t && original_upstream_node_id != follow_target_node_record->node_id)\n\t\t{\n\t\t\tremove_old_replication_slot = true;\n\t\t}\n\t}\n\n\t/* Fetch original upstream's record */\n\tif (remove_old_replication_slot == true)\n\t{\n\t\tPGconn\t    *local_conn = NULL;\n\t\tRecordStatus upstream_record_status = RECORD_NOT_FOUND;\n\n\t\t/* abort if local connection not available */\n\t\tlocal_conn = establish_db_connection(config_file_options.conninfo, true);\n\n\t\tupstream_record_status = get_node_record(local_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t original_upstream_node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t &original_upstream_node_record);\n\t\tPQfinish(local_conn);\n\n\t\tif (upstream_record_status != RECORD_FOUND)\n\t\t{\n\t\t\tlog_warning(_(\"unable to retrieve node record for old upstream node %i\"),\n\t\t\t\t\t\toriginal_upstream_node_id);\n\t\t\tlog_detail(_(\"replication slot will need to be removed manually\"));\n\t\t}\n\t}\n\n\t/* Initialise connection parameters to write as \"primary_conninfo\" */\n\tinitialize_conninfo_params(&recovery_conninfo, false);\n\n\t/* We ignore any application_name set in the primary's conninfo */\n\tparse_conninfo_string(follow_target_node_record->conninfo, &recovery_conninfo, &errmsg, true);\n\n\t/* Set the application name to this node's name */\n\tparam_set(&recovery_conninfo, \"application_name\", config_file_options.node_name);\n\n\t/* Set the replication user from the follow target node record */\n\tparam_set(&recovery_conninfo, \"user\", follow_target_node_record->repluser);\n\n\tlog_notice(_(\"setting node %i's upstream to node %i\"),\n\t\t\t   config_file_options.node_id, follow_target_node_record->node_id);\n\n\tif (!create_recovery_file(&local_node_record,\n\t\t\t\t\t\t\t  &recovery_conninfo,\n\t\t\t\t\t\t\t  PQserverVersion(primary_conn),\n\t\t\t\t\t\t\t  config_file_options.data_directory,\n\t\t\t\t\t\t\t  true))\n\t{\n\t\t*error_code = general_error_code;\n\t\treturn false;\n\t}\n\n\t/*\n\t * start/restart the service\n\t */\n\n\t{\n\t\tchar\t\tserver_command[MAXLEN] = \"\";\n\t\tbool\t\tserver_up = is_server_available(config_file_options.conninfo);\n\t\tchar\t   *action = NULL;\n\t\tbool\t\tsuccess;\n\n\t\tPQExpBufferData output_buf;\n\t\tinitPQExpBuffer(&output_buf);\n\n\t\tif (server_up == true)\n\t\t{\n\n\t\t\tif (PQserverVersion(primary_conn) >= 130000 && config_file_options.standby_follow_restart == false)\n\t\t\t{\n\t\t\t\t/* PostgreSQL 13 and later: we'll send SIGHUP via pg_ctl */\n\t\t\t\tget_server_action(ACTION_RELOAD, server_command, config_file_options.data_directory);\n\n\t\t\t\tsuccess = local_command(server_command, &output_buf);\n\n\t\t\t\tif (success == true)\n\t\t\t\t{\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\n\t\t\t\t/* In the unlikely event that fails, we'll fall back to a restart */\n\t\t\t\tlog_warning(_(\"unable to reload server configuration\"));\n\t\t\t}\n\n\t\t\tif (config_file_options.service_restart_command[0] == '\\0')\n\t\t\t{\n\t\t\t\t/* no \"service_restart_command\" defined - stop and start using pg_ctl */\n\n\t\t\t\taction = \"stopp\"; /* sic */\n\t\t\t\tget_server_action(ACTION_STOP_WAIT, server_command, config_file_options.data_directory);\n\n\t\t\t\t/* if translation needed, generate messages in the preceding if/else */\n\t\t\t\tlog_notice(_(\"%sing server using \\\"%s\\\"\"),\n\t\t\t\t\t\t   action,\n\t\t\t\t\t\t   server_command);\n\n\t\t\t\tsuccess = local_command(server_command, &output_buf);\n\n\t\t\t\tif (success == false)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to %s server\"), action);\n\n\t\t\t\t\t*error_code = ERR_NO_RESTART;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\taction = \"start\";\n\t\t\t\tget_server_action(ACTION_START, server_command, config_file_options.data_directory);\n\n\t\t\t\t/* if translation needed, generate messages in the preceding if/else */\n\t\t\t\tlog_notice(_(\"%sing server using \\\"%s\\\"\"),\n\t\t\t\t\t\t   action,\n\t\t\t\t\t\t   server_command);\n\n\t\t\t\tsuccess = local_command(server_command, &output_buf);\n\n\t\t\t\tif (success == false)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to %s server\"), action);\n\n\t\t\t\t\t*error_code = ERR_NO_RESTART;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\taction = \"restart\";\n\t\t\t\tget_server_action(ACTION_RESTART, server_command, config_file_options.data_directory);\n\n\t\t\t\t/* if translation needed, generate messages in the preceding if/else */\n\t\t\t\tlog_notice(_(\"%sing server using \\\"%s\\\"\"),\n\t\t\t\t\t\t   action,\n\t\t\t\t\t\t   server_command);\n\n\t\t\t\tsuccess = local_command(server_command, &output_buf);\n\n\t\t\t\tif (success == false)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to %s server\"), action);\n\n\t\t\t\t\t*error_code = ERR_NO_RESTART;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\taction = \"start\";\n\t\t\tget_server_action(ACTION_START, server_command, config_file_options.data_directory);\n\n\t\t\t/* if translation needed, generate messages in the preceding if/else */\n\t\t\tlog_notice(_(\"%sing server using \\\"%s\\\"\"),\n\t\t\t\t\t   action,\n\t\t\t\t\t   server_command);\n\n\t\t\tsuccess = local_command(server_command, &output_buf);\n\n\t\t\tif (success == false)\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to %s server\"), action);\n\n\t\t\t\t*error_code = ERR_NO_RESTART;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\t/*\n\t * If replication slots are in use, and an inactive one for this node\n\t * exists on the former upstream, drop it.\n\t *\n\t * Note that if this function is called by do_standby_switchover(), the\n\t * \"repmgr node rejoin\" command executed on the demotion candidate may already\n\t * have removed the slot, so there may be nothing to do.\n\t */\n\n\tif (remove_old_replication_slot == true)\n\t{\n\t\tif (original_upstream_node_record.node_id != UNKNOWN_NODE_ID)\n\t\t{\n\t\t\tPGconn\t   *old_upstream_conn = establish_db_connection_quiet(original_upstream_node_record.conninfo);\n\n\t\t\tif (PQstatus(old_upstream_conn) != CONNECTION_OK)\n\t\t\t{\n\t\t\t\tlog_warning(_(\"unable to connect to old upstream node %i to remove replication slot\"),\n\t\t\t\t\t\t\toriginal_upstream_node_id);\n\t\t\t\tlog_hint(_(\"if reusing this node, you should manually remove any inactive replication slots\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdrop_replication_slot_if_exists(old_upstream_conn,\n\t\t\t\t\t\t\t\t\t\t\t\toriginal_upstream_node_id,\n\t\t\t\t\t\t\t\t\t\t\t\tlocal_node_record.slot_name);\n\t\t\t\tPQfinish(old_upstream_conn);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * It's possible this node was an inactive primary - update the relevant\n\t * fields to ensure it's marked as an active standby\n\t */\n\tif (update_node_record_status(primary_conn,\n\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t  \"standby\",\n\t\t\t\t\t\t\t\t  follow_target_node_record->node_id,\n\t\t\t\t\t\t\t\t  true) == false)\n\t{\n\t\tappendPQExpBufferStr(output,\n\t\t\t\t\t\t\t _(\"unable to update upstream node\"));\n\t\treturn false;\n\t}\n\n\tappendPQExpBuffer(output,\n\t\t\t\t\t  _(\"node %i is now attached to node %i\"),\n\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t  follow_target_node_record->node_id);\n\n\treturn true;\n}\n\n\n/*\n * Perform a switchover by:\n *\n *  - stopping current primary node\n *  - promoting this standby node to primary\n *  - forcing the previous primary node to follow this node\n *\n * Where running and not already paused, repmgrd will be paused (and\n * subsequently unpaused), unless --repmgrd-no-pause provided.\n *\n * Note that this operation can only be considered to have failed completely\n * (\"ERR_SWITCHOVER_FAIL\") in these situations:\n *\n *  - the prerequisites for a switchover are not met\n *  - the demotion candidate could not be shut down cleanly\n *  - the promotion candidate could not be promoted\n *\n * All other failures (demotion candidate did not connect to new primary etc.)\n * are considered partial failures (\"ERR_SWITCHOVER_INCOMPLETE\")\n *\n * TODO:\n *  - make connection test timeouts/intervals configurable (see below)\n */\n\n\nvoid\ndo_standby_switchover(void)\n{\n\tPGconn\t   *local_conn = NULL;\n\tPGconn\t   *superuser_conn = NULL;\n\tPGconn\t   *remote_conn = NULL;\n\n\tt_node_info local_node_record = T_NODE_INFO_INITIALIZER;\n\n\t/* the remote server is the primary to be demoted */\n\tchar\t\tremote_conninfo[MAXCONNINFO] = \"\";\n\tchar\t\tremote_host[MAXLEN] = \"\";\n\tint\t\t\tremote_node_id = UNKNOWN_NODE_ID;\n\tt_node_info remote_node_record = T_NODE_INFO_INITIALIZER;\n\tint \t\tremote_repmgr_version = UNKNOWN_REPMGR_VERSION_NUM;\n\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\tRecoveryType recovery_type = RECTYPE_UNKNOWN;\n\tPQExpBufferData remote_command_str;\n\tPQExpBufferData command_output;\n\tPQExpBufferData node_rejoin_options;\n\tPQExpBufferData logmsg;\n\tPQExpBufferData detailmsg;\n\tPQExpBufferData event_details;\n\n\tint\t\t\tr,\n\t\t\t\ti;\n\tbool\t\tcommand_success = false;\n\tbool\t\tshutdown_success = false;\n\tbool\t\tdry_run_success = true;\n\n\t/* this flag will use to generate the final message generated */\n\tbool\t\tswitchover_success = true;\n\n\tXLogRecPtr\tremote_last_checkpoint_lsn = InvalidXLogRecPtr;\n\tReplInfo\treplication_info;\n\n\t/* store list of configuration files on the demotion candidate */\n\tKeyValueList remote_config_files = {NULL, NULL};\n\n\t/* temporary log file for \"repmgr node rejoin\" on the demotion candidate */\n\tchar\t\tnode_rejoin_log[MAXPGPATH] = \"\";\n\n\tNodeInfoList sibling_nodes = T_NODE_INFO_LIST_INITIALIZER;\n\tSiblingNodeStats sibling_nodes_stats = T_SIBLING_NODES_STATS_INITIALIZER;\n\n\t/* this will be calculated as max_wal_senders - COUNT(*) FROM pg_stat_replication */\n\tint\t\t\tavailable_wal_senders = 0;\n\n\tt_event_info event_info = T_EVENT_INFO_INITIALIZER;\n\n\t/* used for handling repmgrd pause/unpause */\n\tNodeInfoList all_nodes = T_NODE_INFO_LIST_INITIALIZER;\n\tRepmgrdInfo **repmgrd_info = NULL;\n\tint\t\t\trepmgrd_running_count = 0;\n\n\t/* number of free walsenders required on promotion candidate\n\t * (at least one will be required for the demotion candidate)\n\t */\n\tsibling_nodes_stats.min_required_wal_senders = 1;\n\n\t/*\n\t * SANITY CHECKS\n\t *\n\t * We'll be doing a bunch of operations on the remote server (primary to\n\t * be demoted) - careful checks needed before proceeding.\n\t */\n\n\tlocal_conn = establish_db_connection(config_file_options.conninfo, true);\n\n\t/* Verify that standby is a supported server version */\n\t(void) check_server_version(local_conn, \"standby\", true, NULL);\n\n\trecord_status = get_node_record(local_conn, config_file_options.node_id, &local_node_record);\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve node record for node %i\"),\n\t\t\t\t  config_file_options.node_id);\n\n\t\tPQfinish(local_conn);\n\n\t\texit(ERR_DB_QUERY);\n\t}\n\n\tif (!is_streaming_replication(local_node_record.type))\n\t{\n\t\tlog_error(_(\"switchover can only performed with streaming replication\"));\n\t\tPQfinish(local_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tlog_notice(_(\"checking switchover on node \\\"%s\\\" (ID: %i) in --dry-run mode\"),\n\t\t\t\t   local_node_record.node_name,\n\t\t\t\t   local_node_record.node_id);\n\t}\n\telse\n\t{\n\t\tlog_notice(_(\"executing switchover on node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t   local_node_record.node_name,\n\t\t\t\t   local_node_record.node_id);\n\t}\n\n\t/*\n\t * If -S/--superuser option provided, check that a superuser connection can be made\n\t * to the local database. We'll check the remote superuser connection later,\n\t */\n\n\tif (runtime_options.superuser[0] != '\\0')\n\t{\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(_(\"validating connection to local database for superuser \\\"%s\\\"\"),\n\t\t\t\t\t runtime_options.superuser);\n\t\t}\n\n\t\tsuperuser_conn = establish_db_connection_with_replacement_param(\n\t\t\tconfig_file_options.conninfo,\n\t\t\t\"user\",\n\t\t\truntime_options.superuser, false);\n\n\t\tif (PQstatus(superuser_conn) != CONNECTION_OK)\n\t\t{\n\t\t\tlog_error(_(\"unable to connect to local database \\\"%s\\\" as provided superuser \\\"%s\\\"\"),\n\t\t\t\t\t  PQdb(superuser_conn),\n\t\t\t\t\t  runtime_options.superuser);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tif (is_superuser_connection(superuser_conn, NULL) == false)\n\t\t{\n\t\t\tlog_error(_(\"connection established to local database \\\"%s\\\" for provided superuser \\\"%s\\\" is not a superuser connection\"),\n\t\t\t\t\t  PQdb(superuser_conn),\n\t\t\t\t\t  runtime_options.superuser);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(_(\"successfully established connection to local database \\\"%s\\\" for provided superuser \\\"%s\\\"\"),\n\t\t\t\t\t PQdb(superuser_conn),\n\t\t\t\t\t runtime_options.superuser);\n\t\t}\n\n\t}\n\n\t/*\n\t * Warn if no superuser connection is available.\n\t */\n\tif (superuser_conn == NULL && is_superuser_connection(local_conn, NULL) == false)\n\t{\n\t\tlog_warning(_(\"no superuser connection available\"));\n\t\tlog_detail(_(\"it is recommended to perform switchover operations with a database superuser\"));\n\t\tlog_hint(_(\"provide the name of a superuser with -S/--superuser\"));\n\t}\n\n\t/* Check that this is a standby */\n\trecovery_type = get_recovery_type(local_conn);\n\tif (recovery_type != RECTYPE_STANDBY)\n\t{\n\t\tlog_error(_(\"switchover must be executed from the standby node to be promoted\"));\n\t\tif (recovery_type == RECTYPE_PRIMARY)\n\t\t{\n\t\t\tlog_detail(_(\"this node (ID: %i) is the primary\"),\n\t\t\t\t\t   local_node_record.node_id);\n\t\t}\n\t\tPQfinish(local_conn);\n\n\t\texit(ERR_SWITCHOVER_FAIL);\n\t}\n\n\t/*\n\t * Check that the local replication configuration file is owned by the data\n\t * directory owner.\n\t *\n\t * For PostgreSQL 11 and earlier, if PostgreSQL is not able to rename \"recovery.conf\",\n\t * promotion will fail.\n\t *\n\t * For PostgreSQL 12 and later, promotion will not fail even if \"postgresql.auto.conf\"\n\t * is owned by another user, but we'll check just in case, as it is indicative of a\n\t * poorly configured setup. In any case we will need to check \"postgresql.auto.conf\" on\n\t * the demotion candidate as the rejoin will fail if we are unable to to write to that.\n\t */\n\n\tinitPQExpBuffer(&logmsg);\n\tinitPQExpBuffer(&detailmsg);\n\n\tif (check_replication_config_owner(PQserverVersion(local_conn),\n\t\t\t\t\t\t\t\t\t   config_file_options.data_directory,\n\t\t\t\t\t\t\t\t\t   &logmsg, &detailmsg) == false)\n\t{\n\t\tlog_error(\"%s\", logmsg.data);\n\t\tlog_detail(\"%s\", detailmsg.data);\n\n\t\ttermPQExpBuffer(&logmsg);\n\t\ttermPQExpBuffer(&detailmsg);\n\n\t\tPQfinish(local_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\ttermPQExpBuffer(&logmsg);\n\ttermPQExpBuffer(&detailmsg);\n\n\t/* check remote server connection and retrieve its record */\n\tremote_conn = get_primary_connection(local_conn, &remote_node_id, remote_conninfo);\n\n\tif (PQstatus(remote_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to connect to current primary node\"));\n\t\tlog_hint(_(\"check that the cluster is correctly configured and this standby is registered\"));\n\t\tPQfinish(local_conn);\n\t\texit(ERR_DB_CONN);\n\t}\n\n\trecord_status = get_node_record(remote_conn, remote_node_id, &remote_node_record);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve node record for current primary (node %i)\"),\n\t\t\t\t  remote_node_id);\n\n\t\tPQfinish(local_conn);\n\t\tPQfinish(remote_conn);\n\n\t\texit(ERR_DB_QUERY);\n\t}\n\n\tlog_verbose(LOG_DEBUG, \"remote node name is \\\"%s\\\"\", remote_node_record.node_name);\n\n\t/*\n\t * Check this standby is attached to the demotion candidate\n\t */\n\n\tif (local_node_record.upstream_node_id != remote_node_record.node_id)\n\t{\n\t\tlog_error(_(\"local node \\\"%s\\\" (ID: %i) is not a downstream of demotion candidate primary \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t  local_node_record.node_name,\n\t\t\t\t  local_node_record.node_id,\n\t\t\t\t  remote_node_record.node_name,\n\t\t\t\t  remote_node_record.node_id);\n\n\t\tif (local_node_record.upstream_node_id == UNKNOWN_NODE_ID)\n\t\t\tlog_detail(_(\"local node has no registered upstream node\"));\n\t\telse\n\t\t\tlog_detail(_(\"registered upstream node ID is %i\"),\n\t\t\t\t\t   local_node_record.upstream_node_id);\n\n\t\tlog_hint(_(\"execute \\\"repmgr standby register --force\\\" to update the local node's metadata\"));\n\n\t\tPQfinish(local_conn);\n\t\tPQfinish(remote_conn);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tif (is_downstream_node_attached(remote_conn, local_node_record.node_name, NULL) != NODE_ATTACHED)\n\t{\n\t\tlog_error(_(\"local node \\\"%s\\\" (ID: %i) is not attached to demotion candidate \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t  local_node_record.node_name,\n\t\t\t\t  local_node_record.node_id,\n\t\t\t\t  remote_node_record.node_name,\n\t\t\t\t  remote_node_record.node_id);\n\n\t\tPQfinish(local_conn);\n\t\tPQfinish(remote_conn);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * In PostgreSQL 12 and earlier, check that WAL replay on the standby\n\t * is *not* paused, as that could lead to unexpected behaviour when the\n\t * standby is promoted.\n\t *\n\t * For switchover we'll mandate that WAL replay *must not* be paused.\n\t * For a promote operation we can proceed if WAL replay is paused and\n\t * there is no more available WAL to be replayed, as we can be sure the\n\t * primary is down already, but in a switchover context there's\n\t * potentially a window for more WAL to be received before we shut down\n\t * the primary completely.\n\t */\n\n\tif (PQserverVersion(local_conn) < 130000 && is_wal_replay_paused(local_conn, false) == true)\n\t{\n\t\tinit_replication_info(&replication_info);\n\n\t\tif (get_replication_info(local_conn, STANDBY, &replication_info) == false)\n\t\t{\n\t\t\tlog_error(_(\"unable to retrieve replication information from local node\"));\n\t\t\tPQfinish(local_conn);\n\t\t\texit(ERR_SWITCHOVER_FAIL);\n\t\t}\n\n\t\tlog_error(_(\"WAL replay is paused on this node and it is not safe to proceed\"));\n\t\tlog_detail(_(\"replay paused at %X/%X; last WAL received is %X/%X\"),\n\t\t\t\t   format_lsn(replication_info.last_wal_replay_lsn),\n\t\t\t\t   format_lsn(replication_info.last_wal_receive_lsn));\n\n\t\tif (PQserverVersion(local_conn) >= 100000)\n\t\t\tlog_hint(_(\"execute \\\"pg_wal_replay_resume()\\\" to unpause WAL replay\"));\n\t\telse\n\t\t\tlog_hint(_(\"execute \\\"pg_xlog_replay_resume()\\\" to unpause WAL replay\"));\n\n\t\tPQfinish(local_conn);\n\t\texit(ERR_SWITCHOVER_FAIL);\n\t}\n\n\n\t/*\n\t * Check that there are no exclusive backups running on the primary.\n\t * We don't want to end up damaging the backup and also leaving the server in an\n\t * state where there's control data saying it's in backup mode but there's no\n\t * backup_label in PGDATA.\n\t * If the user wants to do the switchover anyway, they should first stop the\n\t * backup that's running.\n\t */\n\tif (server_in_exclusive_backup_mode(remote_conn) != BACKUP_STATE_NO_BACKUP)\n\t{\n\t\tlog_error(_(\"unable to perform a switchover while primary server is in exclusive backup mode\"));\n\t\tlog_hint(_(\"stop backup before attempting the switchover\"));\n\n\t\tPQfinish(local_conn);\n\t\tPQfinish(remote_conn);\n\n\t\texit(ERR_SWITCHOVER_FAIL);\n\t}\n\n\t/* this will fill the %p event notification parameter */\n\tevent_info.node_id = remote_node_record.node_id;\n\n\t/* keep a running total of how many nodes will require a replication slot */\n\tif (remote_node_record.slot_name[0] != '\\0')\n\t{\n\t\tsibling_nodes_stats.min_required_free_slots++;\n\t}\n\n\t/*\n\t * If --force-rewind specified, check pg_rewind can be used, and\n\t * pre-emptively fetch the list of configuration files which should be\n\t * archived\n\t */\n\n\tif (runtime_options.force_rewind_used == true)\n\t{\n\t\tPQExpBufferData reason;\n\t\tPQExpBufferData msg;\n\n\t\tinitPQExpBuffer(&reason);\n\n\t\tif (can_use_pg_rewind(remote_conn, config_file_options.data_directory, &reason) == false)\n\t\t{\n\t\t\tlog_error(_(\"--force-rewind specified but pg_rewind cannot be used\"));\n\t\t\tlog_detail(\"%s\", reason.data);\n\t\t\ttermPQExpBuffer(&reason);\n\t\t\tPQfinish(local_conn);\n\t\t\tPQfinish(remote_conn);\n\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t\ttermPQExpBuffer(&reason);\n\n\t\tinitPQExpBuffer(&msg);\n\t\tappendPQExpBufferStr(&msg,\n\t\t\t\t\t\t\t _(\"prerequisites for using pg_rewind are met\"));\n\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(\"%s\", msg.data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_verbose(LOG_INFO, \"%s\", msg.data);\n\t\t}\n\t\ttermPQExpBuffer(&msg);\n\n\t\tget_datadir_configuration_files(remote_conn, &remote_config_files);\n\t}\n\n\n\t/*\n\t * Check that we can connect by SSH to the remote (current primary) server\n\t */\n\tget_conninfo_value(remote_conninfo, \"host\", remote_host);\n\n\tr = test_ssh_connection(remote_host, runtime_options.remote_user);\n\n\tif (r != 0)\n\t{\n\t\tlog_error(_(\"unable to connect via SSH to host \\\"%s\\\", user \\\"%s\\\"\"),\n\t\t\t\t  remote_host, runtime_options.remote_user);\n\t\tPQfinish(remote_conn);\n\t\tPQfinish(local_conn);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\telse\n\t{\n\t\tPQExpBufferData msg;\n\n\t\tinitPQExpBuffer(&msg);\n\n\t\tappendPQExpBuffer(&msg,\n\t\t\t\t\t\t  _(\"SSH connection to host \\\"%s\\\" succeeded\"),\n\t\t\t\t\t\t  remote_host);\n\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(\"%s\", msg.data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_verbose(LOG_INFO, \"%s\", msg.data);\n\t\t}\n\n\t\ttermPQExpBuffer(&msg);\n\t}\n\n\t/* check remote repmgr binary can be found */\n\tinitPQExpBuffer(&remote_command_str);\n\tmake_remote_repmgr_path(&remote_command_str, &remote_node_record);\n\n\t/*\n\t * Here we're executing an arbitrary repmgr command which is guaranteed to\n\t * succeed if repmgr is executed. We'll extract the actual version number in the\n\t * next step.\n\t */\n\tappendPQExpBufferStr(&remote_command_str, \"--version >/dev/null 2>&1 && echo \\\"1\\\" || echo \\\"0\\\"\");\n\tinitPQExpBuffer(&command_output);\n\tcommand_success = remote_command(remote_host,\n\t\t\t\t\t\t\t\t\t runtime_options.remote_user,\n\t\t\t\t\t\t\t\t\t remote_command_str.data,\n\t\t\t\t\t\t\t\t\t config_file_options.ssh_options,\n\t\t\t\t\t\t\t\t\t &command_output);\n\n\ttermPQExpBuffer(&remote_command_str);\n\n\tif (command_success == false || command_output.data[0] == '0')\n\t{\n\t\tPQExpBufferData hint;\n\n\t\tlog_error(_(\"unable to execute \\\"%s\\\" on \\\"%s\\\"\"),\n\t\t\t\t  progname(), remote_host);\n\n\t\tif (strlen(command_output.data) > 2)\n\t\t\tlog_detail(\"%s\", command_output.data);\n\n\t\ttermPQExpBuffer(&command_output);\n\n\t\tinitPQExpBuffer(&hint);\n\t\tappendPQExpBufferStr(&hint,\n\t\t\t\t\t\t\t _(\"check \\\"pg_bindir\\\" is set to the correct path in \\\"repmgr.conf\\\"; current value: \"));\n\n\t\tif (strlen(config_file_options.pg_bindir))\n\t\t{\n\t\t\tappendPQExpBuffer(&hint,\n\t\t\t\t\t\t\t  \"\\\"%s\\\"\", config_file_options.pg_bindir);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappendPQExpBufferStr(&hint,\n\t\t\t\t\t\t\t\t \"(not set)\");\n\t\t}\n\n\t\tlog_hint(\"%s\", hint.data);\n\n\t\ttermPQExpBuffer(&hint);\n\n\t\tPQfinish(remote_conn);\n\t\tPQfinish(local_conn);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\ttermPQExpBuffer(&command_output);\n\n\t/*\n\t * Now we're sure the binary can be executed, fetch its version number.\n\t */\n\tinitPQExpBuffer(&remote_command_str);\n\tmake_remote_repmgr_path(&remote_command_str, &remote_node_record);\n\n\tappendPQExpBufferStr(&remote_command_str, \"--version 2>/dev/null\");\n\tinitPQExpBuffer(&command_output);\n\tcommand_success = remote_command(remote_host,\n\t\t\t\t\t\t\t\t\t runtime_options.remote_user,\n\t\t\t\t\t\t\t\t\t remote_command_str.data,\n\t\t\t\t\t\t\t\t\t config_file_options.ssh_options,\n\t\t\t\t\t\t\t\t\t &command_output);\n\n\ttermPQExpBuffer(&remote_command_str);\n\n\tif (command_success == true)\n\t{\n\t\tremote_repmgr_version = parse_repmgr_version(command_output.data);\n\t\tif (remote_repmgr_version == UNKNOWN_REPMGR_VERSION_NUM)\n\t\t{\n\t\t\tlog_error(_(\"unable to parse \\\"%s\\\"'s reported version on \\\"%s\\\"\"),\n\t\t\t\t\t  progname(), remote_host);\n\t\t\tPQfinish(remote_conn);\n\t\t\tPQfinish(local_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t\tlog_debug(_(\"\\\"%s\\\" version on \\\"%s\\\" is %i\"),\n\t\t\t\t  progname(), remote_host, remote_repmgr_version );\n\n\t}\n\telse\n\t{\n\t\tlog_error(_(\"unable to execute \\\"%s\\\" on \\\"%s\\\"\"),\n\t\t\t\t  progname(), remote_host);\n\n\t\tif (strlen(command_output.data) > 2)\n\t\t\tlog_detail(\"%s\", command_output.data);\n\n\t\ttermPQExpBuffer(&command_output);\n\n\t\tPQfinish(remote_conn);\n\t\tPQfinish(local_conn);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\ttermPQExpBuffer(&command_output);\n\n\t/*\n\t * Check if the expected remote repmgr.conf file exists\n\t */\n\tinitPQExpBuffer(&remote_command_str);\n\n\tappendPQExpBuffer(&remote_command_str,\n\t\t\t\t\t  \"test -f %s && echo 1 || echo 0\",\n\t\t\t\t\t  remote_node_record.config_file);\n\tinitPQExpBuffer(&command_output);\n\n\tcommand_success = remote_command(remote_host,\n\t\t\t\t\t\t\t\t\t runtime_options.remote_user,\n\t\t\t\t\t\t\t\t\t remote_command_str.data,\n\t\t\t\t\t\t\t\t\t config_file_options.ssh_options,\n\t\t\t\t\t\t\t\t\t &command_output);\n\n\ttermPQExpBuffer(&remote_command_str);\n\n\tif (command_success == false || command_output.data[0] == '0')\n\t{\n\t\tlog_error(_(\"expected configuration file not found on the demotion candidate \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t  remote_node_record.node_name,\n\t\t\t\t  remote_node_record.node_id);\n\t\tlog_detail(_(\"registered configuration file is \\\"%s\\\"\"),\n\t\t\t\t   remote_node_record.config_file);\n\t\tlog_hint(_(\"ensure the configuration file is in the expected location, or re-register \\\"%s\\\" to update the configuration file location\"),\n\t\t\t\t  remote_node_record.node_name);\n\n\t\tPQfinish(remote_conn);\n\t\tPQfinish(local_conn);\n\n\t\ttermPQExpBuffer(&command_output);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\n\t/*\n\t * Sanity-check remote \"data_directory\" is correctly configured in repmgr.conf.\n\t *\n\t * This is important as we'll need to be able to run \"repmgr node status\" on the data\n\t * directory after the remote (demotion candidate) has shut down.\n\t */\n\n\tinitPQExpBuffer(&remote_command_str);\n\tmake_remote_repmgr_path(&remote_command_str, &remote_node_record);\n\n\t/*\n\t * --data-directory-config is available from repmgr 4.3; it will fail\n\t * if the remote repmgr is an earlier version, but the version should match\n\t * anyway.\n\t */\n\tappendPQExpBufferStr(&remote_command_str, \"node check --data-directory-config --optformat -LINFO 2>/dev/null\");\n\n\tinitPQExpBuffer(&command_output);\n\tcommand_success = remote_command(remote_host,\n\t\t\t\t\t\t\t\t\t runtime_options.remote_user,\n\t\t\t\t\t\t\t\t\t remote_command_str.data,\n\t\t\t\t\t\t\t\t\t config_file_options.ssh_options,\n\t\t\t\t\t\t\t\t\t &command_output);\n\n\ttermPQExpBuffer(&remote_command_str);\n\n\tif (command_success == false)\n\t{\n\t\tlog_error(_(\"unable to execute \\\"%s node check --data-directory-config\\\" on \\\"%s\\\":\"),\n\t\t\t\t  progname(), remote_host);\n\t\tlog_detail(\"%s\", command_output.data);\n\n\t\tPQfinish(remote_conn);\n\t\tPQfinish(local_conn);\n\n\t\ttermPQExpBuffer(&command_output);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* check remote repmgr has the data directory correctly configured */\n\t{\n\t\tt_remote_error_type remote_error = REMOTE_ERROR_NONE;\n\n\t\tif (parse_data_directory_config(command_output.data, &remote_error) == false)\n\t\t{\n\t\t\tif (remote_error != REMOTE_ERROR_NONE)\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to run data directory check on node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\tremote_node_record.node_name,\n\t\t\t\t\t\t\tremote_node_record.node_id);\n\n\t\t\t\tif (remote_error == REMOTE_ERROR_DB_CONNECTION)\n\t\t\t\t{\n\t\t\t\t\tPQExpBufferData ssh_command;\n\n\t\t\t\t\t/* can happen if the connection configuration is not consistent across nodes */\n\t\t\t\t\tlog_detail(_(\"an error was encountered when attempting to connect to PostgreSQL on node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t   remote_node_record.node_name,\n\t\t\t\t\t\t\t   remote_node_record.node_id);\n\n\t\t\t\t\t/* output a helpful hint to help diagnose the issue */\n\t\t\t\t\tinitPQExpBuffer(&remote_command_str);\n\t\t\t\t\tmake_remote_repmgr_path(&remote_command_str, &remote_node_record);\n\n\t\t\t\t\tappendPQExpBufferStr(&remote_command_str, \"node check --db-connection\");\n\n\t\t\t\t\tinitPQExpBuffer(&ssh_command);\n\n\t\t\t\t\tmake_remote_command(remote_host,\n\t\t\t\t\t\t\t\t\t\truntime_options.remote_user,\n\t\t\t\t\t\t\t\t\t\tremote_command_str.data,\n\t\t\t\t\t\t\t\t\t\tconfig_file_options.ssh_options,\n\t\t\t\t\t\t\t\t\t\t&ssh_command);\n\n\t\t\t\t\tlog_hint(_(\"diagnose with:\\n  %s\"), ssh_command.data);\n\n\t\t\t\t\ttermPQExpBuffer(&remote_command_str);\n\t\t\t\t\ttermPQExpBuffer(&ssh_command);\n\t\t\t\t}\n\t\t\t\telse if (remote_error == REMOTE_ERROR_CONNINFO_PARSE)\n\t\t\t\t{\n\t\t\t\t\t/* highly unlikely */\n\t\t\t\t\tlog_detail(_(\"an error was encountered when parsing the \\\"conninfo\\\" parameter in \\\"repmgr.conf\\\" on node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t   remote_node_record.node_name,\n\t\t\t\t\t\t\t   remote_node_record.node_id);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlog_detail(_(\"an unknown error was encountered when attempting to connect to PostgreSQL on node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t   remote_node_record.node_name,\n\t\t\t\t\t\t\t   remote_node_record.node_id);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_error(_(\"\\\"data_directory\\\" parameter in \\\"repmgr.conf\\\" on \\\"%s\\\" (ID: %i) is incorrectly configured\"),\n\t\t\t\t\t\t  remote_node_record.node_name,\n\t\t\t\t\t\t  remote_node_record.node_id);\n\n\t\t\t\tlog_hint(_(\"execute \\\"repmgr node check --data-directory-config\\\" on \\\"%s\\\" (ID: %i) to diagnose the issue\"),\n\t\t\t\t\t\t remote_node_record.node_name,\n\t\t\t\t\t\t remote_node_record.node_id);\n\n\t\t\t}\n\n\t\t\tPQfinish(remote_conn);\n\t\t\tPQfinish(local_conn);\n\n\t\t\ttermPQExpBuffer(&command_output);\n\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\ttermPQExpBuffer(&command_output);\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"able to execute \\\"%s\\\" on remote host \\\"%s\\\"\"),\n\t\t\t\t progname(),\n\t\t\t\t remote_host);\n\t}\n\n\t/*\n\t * If -S/--superuser option provided, check that a superuser connection can be made\n\t * to the local database on the remote node.\n\t */\n\n\tif (runtime_options.superuser[0] != '\\0')\n\t{\n\t\tCheckStatus status = CHECK_STATUS_UNKNOWN;\n\n\t\tinitPQExpBuffer(&remote_command_str);\n\t\tmake_remote_repmgr_path(&remote_command_str, &remote_node_record);\n\n\t\tappendPQExpBuffer(&remote_command_str,\n\t\t\t\t\t\t  \"node check --db-connection --superuser=%s --optformat -LINFO 2>/dev/null\",\n\t\t\t\t\t\t  runtime_options.superuser);\n\n\t\tinitPQExpBuffer(&command_output);\n\t\tcommand_success = remote_command(remote_host,\n\t\t\t\t\t\t\t\t\t\t runtime_options.remote_user,\n\t\t\t\t\t\t\t\t\t\t remote_command_str.data,\n\t\t\t\t\t\t\t\t\t\t config_file_options.ssh_options,\n\t\t\t\t\t\t\t\t\t\t &command_output);\n\n\t\ttermPQExpBuffer(&remote_command_str);\n\n\t\tif (command_success == false)\n\t\t{\n\t\t\tlog_error(_(\"unable to execute \\\"%s node check --db-connection\\\" on \\\"%s\\\":\"),\n\t\t\t\t\t  progname(), remote_host);\n\t\t\tlog_detail(\"%s\", command_output.data);\n\n\t\t\tPQfinish(remote_conn);\n\t\t\tPQfinish(local_conn);\n\n\t\t\ttermPQExpBuffer(&command_output);\n\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tstatus = parse_db_connection(command_output.data);\n\n\t\tif (status != CHECK_STATUS_OK)\n\t\t{\n\t\t\tPQExpBufferData ssh_command;\n\t\t\tlog_error(_(\"unable to connect locally as superuser \\\"%s\\\" on node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t  runtime_options.superuser,\n\t\t\t\t\t  remote_node_record.node_name,\n\t\t\t\t\t  remote_node_record.node_id);\n\n\t\t\t/* output a helpful hint to help diagnose the issue */\n\t\t\tinitPQExpBuffer(&remote_command_str);\n\t\t\tmake_remote_repmgr_path(&remote_command_str, &remote_node_record);\n\n\t\t\tappendPQExpBuffer(&remote_command_str,\n\t\t\t\t\t\t\t  \"node check --db-connection --superuser=%s\",\n\t\t\t\t\t\t\t  runtime_options.superuser);\n\n\t\t\tinitPQExpBuffer(&ssh_command);\n\n\t\t\tmake_remote_command(remote_host,\n\t\t\t\t\t\t\t\truntime_options.remote_user,\n\t\t\t\t\t\t\t\tremote_command_str.data,\n\t\t\t\t\t\t\t\tconfig_file_options.ssh_options,\n\t\t\t\t\t\t\t\t&ssh_command);\n\n\t\t\tlog_hint(_(\"diagnose with:\\n  %s\"), ssh_command.data);\n\n\t\t\ttermPQExpBuffer(&remote_command_str);\n\t\t\ttermPQExpBuffer(&ssh_command);\n\t\t\texit(ERR_DB_CONN);\n\t\t}\n\n\n\n\t\ttermPQExpBuffer(&command_output);\n\t}\n\n\t/*\n\t * For PostgreSQL 12 and later, check \"postgresql.auto.conf\" is owned by the\n\t * correct user, otherwise the node will probably not be able to attach to\n\t * the promotion candidate (and is a sign of bad configuration anyway) so we\n\t * will complain vocally.\n\t *\n\t * We'll only do this if we've determined the remote repmgr binary is new\n\t * enough to have the \"node check --replication-config-owner\" option.\n\t */\n\n\tif (PQserverVersion(local_conn) >= 120000 && remote_repmgr_version >= 50100)\n\t{\n\t\tinitPQExpBuffer(&remote_command_str);\n\t\tmake_remote_repmgr_path(&remote_command_str, &remote_node_record);\n\n\t\tappendPQExpBufferStr(&remote_command_str, \"node check --replication-config-owner --optformat -LINFO 2>/dev/null\");\n\n\t\tinitPQExpBuffer(&command_output);\n\t\tcommand_success = remote_command(remote_host,\n\t\t\t\t\t\t\t\t\t\t runtime_options.remote_user,\n\t\t\t\t\t\t\t\t\t\t remote_command_str.data,\n\t\t\t\t\t\t\t\t\t\t config_file_options.ssh_options,\n\t\t\t\t\t\t\t\t\t\t &command_output);\n\n\t\ttermPQExpBuffer(&remote_command_str);\n\n\t\tif (command_success == false)\n\t\t{\n\t\t\tlog_error(_(\"unable to execute \\\"%s node check --replication-config-owner\\\" on \\\"%s\\\":\"),\n\t\t\t\t\t  progname(), remote_host);\n\t\t\tlog_detail(\"%s\", command_output.data);\n\n\t\t\tPQfinish(remote_conn);\n\t\t\tPQfinish(local_conn);\n\n\t\t\ttermPQExpBuffer(&command_output);\n\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tif (parse_replication_config_owner(command_output.data) == false)\n\t\t{\n\t\t\tlog_error(_(\"\\\"%s\\\" file on \\\"%s\\\" has incorrect ownership\"),\n\t\t\t\t\t  PG_AUTOCONF_FILENAME,\n\t\t\t\t\t  remote_node_record.node_name);\n\n\t\t\tlog_hint(_(\"check the file has the same owner/group as the data directory\"));\n\n\t\t\tPQfinish(remote_conn);\n\t\t\tPQfinish(local_conn);\n\n\t\t\ttermPQExpBuffer(&command_output);\n\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\ttermPQExpBuffer(&command_output);\n\t}\n\n\n\t/*\n\t * populate local node record with current state of various replication-related\n\t * values, so we can check for sufficient walsenders and replication slots\n\t */\n\tget_node_replication_stats(local_conn, &local_node_record);\n\n\tavailable_wal_senders = local_node_record.max_wal_senders -\n\t\tlocal_node_record.attached_wal_receivers;\n\n\t/*\n\t * Get list of sibling nodes; if --siblings-follow specified,\n\t * check they're reachable; if not, the list will be used to warn\n\t * about nodes which will remain attached to the demotion candidate\n\t */\n\tget_active_sibling_node_records(local_conn,\n\t\t\t\t\t\t\t\t\tlocal_node_record.node_id,\n\t\t\t\t\t\t\t\t\tlocal_node_record.upstream_node_id,\n\t\t\t\t\t\t\t\t\t&sibling_nodes);\n\n\tif (check_sibling_nodes(&sibling_nodes, &sibling_nodes_stats) == false)\n\t{\n\t\tPQfinish(local_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\n\t/*\n\t * check there are sufficient free walsenders - obviously there's potential\n\t * for a later race condition if some walsenders come into use before the\n\t * switchover operation gets around to attaching the sibling nodes, but\n\t * this should catch any actual existing configuration issue (and if anyone's\n\t * performing a switchover in such an unstable environment, they only have\n\t * themselves to blame).\n\t */\n\tif (check_free_wal_senders(available_wal_senders, &sibling_nodes_stats, &dry_run_success) == false)\n\t{\n\t\tif (runtime_options.dry_run == false)\n\t\t{\n\t\t\tPQfinish(local_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\n\t/* check demotion candidate can make replication connection to promotion candidate */\n\t{\n\t\tinitPQExpBuffer(&remote_command_str);\n\t\tmake_remote_repmgr_path(&remote_command_str, &remote_node_record);\n\t\tappendPQExpBuffer(&remote_command_str,\n\t\t\t\t\t\t  \"node check --remote-node-id=%i --replication-connection\",\n\t\t\t\t\t\t  local_node_record.node_id);\n\n\t\tinitPQExpBuffer(&command_output);\n\n\t\tcommand_success = remote_command(remote_host,\n\t\t\t\t\t\t\t\t\t\t runtime_options.remote_user,\n\t\t\t\t\t\t\t\t\t\t remote_command_str.data,\n\t\t\t\t\t\t\t\t\t\t config_file_options.ssh_options,\n\t\t\t\t\t\t\t\t\t\t &command_output);\n\n\t\ttermPQExpBuffer(&remote_command_str);\n\n\t\tif (command_success == true)\n\t\t{\n\t\t\tConnectionStatus conn_status = parse_remote_node_replication_connection(command_output.data);\n\n\t\t\tswitch(conn_status)\n\t\t\t{\n\t\t\t\tcase CONN_OK:\n\t\t\t\t\tif (runtime_options.dry_run == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_info(_(\"demotion candidate is able to make replication connection to promotion candidate\"));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase CONN_BAD:\n\t\t\t\t\tlog_error(_(\"demotion candidate is unable to make replication connection to promotion candidate\"));\n\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlog_error(_(\"unable to determine whether demotion candidate is able to make replication connection to promotion candidate\"));\n\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttermPQExpBuffer(&command_output);\n\t\t}\n\t}\n\n\t/* check archive/replication status */\n\t{\n\t\tint\t\t\tlag_seconds = 0;\n\t\tCheckStatus status = CHECK_STATUS_UNKNOWN;\n\n\t\t/* archive status - check when \"archive_mode\" is activated */\n\n\t\tif (guc_set(remote_conn, \"archive_mode\", \"!=\", \"off\"))\n\t\t{\n\t\t\tint\t\t\tfiles = 0;\n\t\t\tint\t\t\tthreshold = 0;\n\t\t\tt_remote_error_type remote_error = REMOTE_ERROR_NONE;\n\n\t\t\tinitPQExpBuffer(&remote_command_str);\n\t\t\tmake_remote_repmgr_path(&remote_command_str, &remote_node_record);\n\t\t\tappendPQExpBufferStr(&remote_command_str,\n\t\t\t\t\t\t\t\t \"node check --terse -LERROR --archive-ready --optformat\");\n\n\t\t\tinitPQExpBuffer(&command_output);\n\n\t\t\tcommand_success = remote_command(remote_host,\n\t\t\t\t\t\t\t\t\t\t\t runtime_options.remote_user,\n\t\t\t\t\t\t\t\t\t\t\t remote_command_str.data,\n\t\t\t\t\t\t\t\t\t\t\t config_file_options.ssh_options,\n\t\t\t\t\t\t\t\t\t\t\t &command_output);\n\n\t\t\ttermPQExpBuffer(&remote_command_str);\n\n\t\t\tif (command_success == true)\n\t\t\t{\n\t\t\t\tstatus = parse_node_check_archiver(command_output.data, &files, &threshold, &remote_error);\n\t\t\t}\n\n\t\t\ttermPQExpBuffer(&command_output);\n\n\t\t\tswitch (status)\n\t\t\t{\n\t\t\t\tcase CHECK_STATUS_UNKNOWN:\n\t\t\t\t\t{\n\t\t\t\t\t\tif (runtime_options.force == false || remote_error == REMOTE_ERROR_DB_CONNECTION)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog_error(_(\"unable to check number of pending archive files on demotion candidate \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\t\t  remote_node_record.node_name);\n\n\t\t\t\t\t\t\tif (remote_error == REMOTE_ERROR_DB_CONNECTION)\n\t\t\t\t\t\t\t\tlog_detail(_(\"an error was encountered when attempting to connect to PostgreSQL on node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t\t\t\t   remote_node_record.node_name,\n\t\t\t\t\t\t\t\t\t\t   remote_node_record.node_id);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tlog_hint(_(\"use -F/--force to continue anyway\"));\n\n\t\t\t\t\t\t\tPQfinish(remote_conn);\n\t\t\t\t\t\t\tPQfinish(local_conn);\n\n\t\t\t\t\t\t\texit(ERR_SWITCHOVER_FAIL);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlog_warning(_(\"unable to check number of pending archive files on demotion candidate \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\t\tremote_node_record.node_name);\n\t\t\t\t\t\tlog_notice(_(\"-F/--force set, continuing with switchover\"));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CHECK_STATUS_CRITICAL:\n\t\t\t\t\t{\n\t\t\t\t\t\tif (runtime_options.force == false)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog_error(_(\"number of pending archive files on demotion candidate \\\"%s\\\" is critical\"),\n\t\t\t\t\t\t\t\t\t  remote_node_record.node_name);\n\t\t\t\t\t\t\tlog_detail(_(\"%i pending archive files (critical threshold: %i)\"),\n\t\t\t\t\t\t\t\t\t   files, threshold);\n\t\t\t\t\t\t\tlog_hint(_(\"PostgreSQL will not shut down until all files are archived; use -F/--force to continue anyway\"));\n\t\t\t\t\t\t\tPQfinish(remote_conn);\n\t\t\t\t\t\t\tPQfinish(local_conn);\n\n\t\t\t\t\t\t\texit(ERR_SWITCHOVER_FAIL);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlog_warning(_(\"number of pending archive files on demotion candidate \\\"%s\\\" exceeds the critical threshold\"),\n\t\t\t\t\t\t\t\t\tremote_node_record.node_name);\n\t\t\t\t\t\tlog_detail(_(\"%i pending archive files (critical threshold: %i)\"),\n\t\t\t\t\t\t\t\t   files, threshold);\n\t\t\t\t\t\tlog_notice(_(\"-F/--force set, continuing with switchover\"));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CHECK_STATUS_WARNING:\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_warning(_(\"number of pending archive files on demotion candidate \\\"%s\\\" exceeds the warning threshold\"),\n\t\t\t\t\t\t\t\t\tremote_node_record.node_name);\n\t\t\t\t\t\tlog_detail(_(\"%i pending archive files (warning threshold: %i)\"),\n\t\t\t\t\t\t\t\t   files, threshold);\n\t\t\t\t\t\tlog_hint(_(\"PostgreSQL will not shut down until all files are archived\"));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CHECK_STATUS_OK:\n\t\t\t\t\t{\n\t\t\t\t\t\tPQExpBufferData msg;\n\n\t\t\t\t\t\tinitPQExpBuffer(&msg);\n\n\t\t\t\t\t\tappendPQExpBuffer(&msg,\n\t\t\t\t\t\t\t\t\t\t  _(\"%i pending archive files\"),\n\t\t\t\t\t\t\t\t\t\t  files);\n\n\t\t\t\t\t\tif (runtime_options.dry_run == true)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog_info(\"%s\", msg.data);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog_verbose(LOG_INFO, \"%s\", msg.data);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttermPQExpBuffer(&msg);\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar\t   *msg = _(\"archive mode is \\\"off\\\"\");\n\n\t\t\tif (runtime_options.dry_run == true)\n\t\t\t{\n\t\t\t\tlog_info(\"%s\", msg);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_verbose(LOG_INFO, \"%s\", msg);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * check replication lag on promotion candidate (TODO: check on all\n\t\t * nodes attached to demotion candidate)\n\t\t */\n\t\tlag_seconds = get_replication_lag_seconds(local_conn);\n\n\t\tlog_debug(\"lag is %i \", lag_seconds);\n\n\t\tif (lag_seconds >= config_file_options.replication_lag_critical)\n\t\t{\n\t\t\tif (runtime_options.force == false)\n\t\t\t{\n\t\t\t\tlog_error(_(\"replication lag on this node is critical\"));\n\t\t\t\tlog_detail(_(\"lag is %i seconds (critical threshold: %i)\"),\n\t\t\t\t\t\t   lag_seconds, config_file_options.replication_lag_critical);\n\t\t\t\tlog_hint(_(\"PostgreSQL on the demotion candidate will not shut down until pending WAL is flushed to the standby; use -F/--force to continue anyway\"));\n\t\t\t\tPQfinish(remote_conn);\n\t\t\t\tPQfinish(local_conn);\n\n\t\t\t\texit(ERR_SWITCHOVER_FAIL);\n\t\t\t}\n\n\t\t\tlog_warning(_(\"replication lag on this node is critical\"));\n\t\t\tlog_detail(_(\"lag is %i seconds (critical threshold: %i)\"),\n\t\t\t\t\t   lag_seconds, config_file_options.replication_lag_critical);\n\t\t\tlog_notice(_(\"-F/--force set, continuing with switchover\"));\n\t\t}\n\t\telse if (lag_seconds >= config_file_options.replication_lag_warning)\n\t\t{\n\t\t\tlog_warning(_(\"replication lag on this node is warning\"));\n\t\t\tlog_detail(_(\"lag is %i seconds (warning threshold: %i)\"),\n\t\t\t\t\t   lag_seconds, config_file_options.replication_lag_warning);\n\t\t}\n\t\telse if (lag_seconds == UNKNOWN_REPLICATION_LAG)\n\t\t{\n\t\t\tif (runtime_options.force == false)\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to check replication lag on local node\"));\n\t\t\t\tlog_hint(_(\"use -F/--force to continue anyway\"));\n\t\t\t\tPQfinish(remote_conn);\n\t\t\t\tPQfinish(local_conn);\n\n\t\t\t\texit(ERR_SWITCHOVER_FAIL);\n\t\t\t}\n\n\t\t\tlog_warning(_(\"unable to check replication lag on local node\"));\n\t\t\tlog_notice(_(\"-F/--force set, continuing with switchover\"));\n\t\t}\n\t\t/* replication lag is below warning threshold */\n\t\telse\n\t\t{\n\t\t\tPQExpBufferData msg;\n\n\t\t\tinitPQExpBuffer(&msg);\n\n\t\t\tappendPQExpBuffer(&msg,\n\t\t\t\t\t\t\t  _(\"replication lag on this standby is %i seconds\"),\n\t\t\t\t\t\t\t  lag_seconds);\n\n\t\t\tif (runtime_options.dry_run == true)\n\t\t\t{\n\t\t\t\tlog_info(\"%s\", msg.data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_verbose(LOG_INFO, \"%s\", msg.data);\n\t\t\t}\n\n\t\t\ttermPQExpBuffer(&msg);\n\t\t}\n\t}\n\n\tPQfinish(remote_conn);\n\n\t/*\n\t * if replication slots are required by demotion candidate and/or siblings,\n\t * check the promotion candidate has sufficient free slots\n\t */\n\tif (check_free_slots(&local_node_record, &sibling_nodes_stats, &dry_run_success) == false)\n\t{\n\t\tif (runtime_options.dry_run == false)\n\t\t{\n\t\t\tPQfinish(local_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\n\t/*\n\t * Attempt to pause all repmgrd instances, unless user explicitly\n\t * specifies not to.\n\t */\n\tif (runtime_options.repmgrd_no_pause == false)\n\t{\n\t\tNodeInfoListCell *cell = NULL;\n\t\tItemList repmgrd_connection_errors = {NULL, NULL};\n\t\ti = 0;\n\t\tint unreachable_node_count = 0;\n\n\t\tget_all_node_records(local_conn, &all_nodes);\n\n\t\trepmgrd_info = (RepmgrdInfo **) pg_malloc0(sizeof(RepmgrdInfo *) * all_nodes.node_count);\n\n\t\tlog_notice(_(\"attempting to pause repmgrd on %i nodes\"), all_nodes.node_count);\n\t\tfor (cell = all_nodes.head; cell; cell = cell->next)\n\t\t{\n\t\t\trepmgrd_info[i] = pg_malloc0(sizeof(RepmgrdInfo));\n\t\t\trepmgrd_info[i]->node_id = cell->node_info->node_id;\n\t\t\trepmgrd_info[i]->pid = UNKNOWN_PID;\n\t\t\trepmgrd_info[i]->paused = false;\n\t\t\trepmgrd_info[i]->running = false;\n\t\t\trepmgrd_info[i]->pg_running = true;\n\n\t\t\tcell->node_info->conn = establish_db_connection_quiet(cell->node_info->conninfo);\n\n\t\t\tif (PQstatus(cell->node_info->conn) != CONNECTION_OK)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * unable to connect; treat this as an error\n\t\t\t\t */\n\n\t\t\t\trepmgrd_info[i]->pg_running = false;\n\n\t\t\t\t/*\n\t\t\t\t * Only worry about unreachable nodes if they're marked as active\n\t\t\t\t * in the repmgr metadata.\n\t\t\t\t */\n\t\t\t\tif (cell->node_info->active == true)\n\t\t\t\t{\n\t\t\t\t\tunreachable_node_count++;\n\n\t\t\t\t\titem_list_append_format(&repmgrd_connection_errors,\n\t\t\t\t\t\t\t\t\t\t\t_(\"unable to connect to node \\\"%s\\\" (ID: %i):\\n%s\"),\n\t\t\t\t\t\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\t\t\t\t\t\tcell->node_info->node_id,\n\t\t\t\t\t\t\t\t\t\t\tPQerrorMessage(cell->node_info->conn));\n\t\t\t\t}\n\n\t\t\t\tPQfinish(cell->node_info->conn);\n\t\t\t\tcell->node_info->conn = NULL;\n\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trepmgrd_info[i]->running = repmgrd_is_running(cell->node_info->conn);\n\t\t\trepmgrd_info[i]->pid = repmgrd_get_pid(cell->node_info->conn);\n\t\t\trepmgrd_info[i]->paused = repmgrd_is_paused(cell->node_info->conn);\n\n\t\t\tif (repmgrd_info[i]->running == true)\n\t\t\t\trepmgrd_running_count++;\n\n\t\t\ti++;\n\t\t}\n\n\t\tif (unreachable_node_count > 0)\n\t\t{\n\t\t\tPQExpBufferData msg;\n\t\t\tPQExpBufferData detail;\n\t\t\tItemListCell *cell;\n\n\t\t\tinitPQExpBuffer(&msg);\n\t\t\tappendPQExpBuffer(&msg,\n\t\t\t\t\t\t\t  _(\"unable to connect to %i of %i node(s), unable to pause all repmgrd instances\"),\n\t\t\t\t\t\t\t  unreachable_node_count,\n\t\t\t\t\t\t\t  all_nodes.node_count);\n\n\t\t\tinitPQExpBuffer(&detail);\n\n\t\t\tfor (cell = repmgrd_connection_errors.head; cell; cell = cell->next)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&detail,\n\t\t\t\t\t\t\t\t  \"  %s\\n\",\n\t\t\t\t\t\t\t\t  cell->string);\n\t\t\t}\n\n\n\t\t\tif (runtime_options.force == false)\n\t\t\t{\n\t\t\t\tlog_error(\"%s\", msg.data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_warning(\"%s\", msg.data);\n\t\t\t}\n\n\t\t\tlog_detail(_(\"following node(s) unreachable:\\n%s\"), detail.data);\n\n\t\t\ttermPQExpBuffer(&msg);\n\t\t\ttermPQExpBuffer(&detail);\n\n\t\t\t/* tell user about footgun */\n\t\t\tif (runtime_options.force == false)\n\t\t\t{\n\t\t\t\tlog_hint(_(\"use -F/--force to continue anyway\"));\n\n\t\t\t\tclear_node_info_list(&sibling_nodes);\n\t\t\t\tclear_node_info_list(&all_nodes);\n\n\t\t\t\texit(ERR_SWITCHOVER_FAIL);\n\t\t\t}\n\n\t\t}\n\n\t\t/* pause repmgrd on all reachable nodes */\n\t\tif (repmgrd_running_count > 0)\n\t\t{\n\t\t\ti = 0;\n\t\t\tfor (cell = all_nodes.head; cell; cell = cell->next)\n\t\t\t{\n\n\t\t\t\t/*\n\t\t\t\t * Skip if node was unreachable\n\t\t\t\t */\n\t\t\t\tif (repmgrd_info[i]->pg_running == false)\n\t\t\t\t{\n\t\t\t\t\tlog_warning(_(\"node \\\"%s\\\" (ID: %i) unreachable, unable to pause repmgrd\"),\n\t\t\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\t\t\tcell->node_info->node_id);\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\n\t\t\t\t/*\n\t\t\t\t * Skip if repmgrd not running on node\n\t\t\t\t */\n\t\t\t\tif (repmgrd_info[i]->running == false)\n\t\t\t\t{\n\t\t\t\t\tlog_notice(_(\"repmgrd not running on node \\\"%s\\\" (ID: %i), not pausing\"),\n\t\t\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\t\t\tcell->node_info->node_id);\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Skip if node is already paused. Note we won't unpause these, to\n\t\t\t\t * leave the repmgrd instances in the cluster in the same state they\n\t\t\t\t * were before the switchover.\n\t\t\t\t */\n\t\t\t\tif (repmgrd_info[i]->paused == true)\n\t\t\t\t{\n\t\t\t\t\tPQfinish(cell->node_info->conn);\n\t\t\t\t\tcell->node_info->conn = NULL;\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (runtime_options.dry_run == true)\n\t\t\t\t{\n\t\t\t\t\tlog_info(_(\"would pause repmgrd on node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t cell->node_info->node_name,\n\t\t\t\t\t\t\t cell->node_info->node_id);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* XXX check result  */\n\t\t\t\t\tlog_debug(\"pausing repmgrd on node \\\"%s\\\" (ID: %i)\",\n\t\t\t\t\t\t\t cell->node_info->node_name,\n\t\t\t\t\t\t\t cell->node_info->node_id);\n\n\t\t\t\t\t(void) repmgrd_pause(cell->node_info->conn, true);\n\t\t\t\t}\n\n\t\t\t\tPQfinish(cell->node_info->conn);\n\t\t\t\tcell->node_info->conn = NULL;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* close all connections - we'll reestablish later */\n\t\t\tfor (cell = all_nodes.head; cell; cell = cell->next)\n\t\t\t{\n\t\t\t\tif (cell->node_info->conn != NULL)\n\t\t\t\t{\n\t\t\t\t\tPQfinish(cell->node_info->conn);\n\t\t\t\t\tcell->node_info->conn = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/*\n\t * Sanity checks completed - prepare for the switchover\n\t */\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tlog_notice(_(\"local node \\\"%s\\\" (ID: %i) would be promoted to primary; \"\n\t\t\t\t\t \"current primary \\\"%s\\\" (ID: %i) would be demoted to standby\"),\n\t\t\t\t   local_node_record.node_name,\n\t\t\t\t   local_node_record.node_id,\n\t\t\t\t   remote_node_record.node_name,\n\t\t\t\t   remote_node_record.node_id);\n\t}\n\telse\n\t{\n\t\tlog_notice(_(\"local node \\\"%s\\\" (ID: %i) will be promoted to primary; \"\n\t\t\t\t\t \"current primary \\\"%s\\\" (ID: %i) will be demoted to standby\"),\n\t\t\t\t   local_node_record.node_name,\n\t\t\t\t   local_node_record.node_id,\n\t\t\t\t   remote_node_record.node_name,\n\t\t\t\t   remote_node_record.node_id);\n\t}\n\n\n\t/*\n\t * Stop the remote primary\n\t *\n\t * We'll issue the pg_ctl command but not force it not to wait; we'll\n\t * check the connection from here - and error out if no shutdown is\n\t * detected after a certain time.\n\t */\n\n\tinitPQExpBuffer(&remote_command_str);\n\tinitPQExpBuffer(&command_output);\n\n\tmake_remote_repmgr_path(&remote_command_str, &remote_node_record);\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tappendPQExpBufferStr(&remote_command_str,\n\t\t\t\t\t\t\t \"node service --terse -LERROR --list-actions --action=stop\");\n\n\t}\n\telse\n\t{\n\t\tlog_notice(_(\"stopping current primary node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t   remote_node_record.node_name,\n\t\t\t\t   remote_node_record.node_id);\n\t\tappendPQExpBufferStr(&remote_command_str,\n\t\t\t\t\t\t\t \"node service --action=stop --checkpoint\");\n\n\t\tif (runtime_options.superuser[0] != '\\0')\n\t\t{\n\t\t\tappendPQExpBuffer(&remote_command_str,\n\t\t\t\t\t\t\t  \" --superuser=%s\",\n\t\t\t\t\t\t\t  runtime_options.superuser);\n\t\t}\n\t}\n\n\t/* XXX handle failure */\n\n\t(void) remote_command(remote_host,\n\t\t\t\t\t\t  runtime_options.remote_user,\n\t\t\t\t\t\t  remote_command_str.data,\n\t\t\t\t\t\t  config_file_options.ssh_options,\n\t\t\t\t\t\t  &command_output);\n\n\ttermPQExpBuffer(&remote_command_str);\n\n\t/*\n\t * --dry-run ends here with display of command which would be used to shut\n\t * down the remote server\n\t */\n\tif (runtime_options.dry_run == true)\n\t{\n\t\t/* we use a buffer here as it will be modified by string_remove_trailing_newlines() */\n\t\tchar\t\tshutdown_command[MAXLEN] = \"\";\n\n\t\tstrncpy(shutdown_command, command_output.data, MAXLEN);\n\n\t\ttermPQExpBuffer(&command_output);\n\n\t\tstring_remove_trailing_newlines(shutdown_command);\n\n\t\tlog_info(_(\"following shutdown command would be run on node \\\"%s\\\":\\n  \\\"%s\\\"\"),\n\t\t\t\t remote_node_record.node_name,\n\t\t\t\t shutdown_command);\n\n\t\tlog_info(_(\"parameter \\\"shutdown_check_timeout\\\" is set to %i seconds\"),\n\t\t\t\t config_file_options.shutdown_check_timeout);\n\n\t\tclear_node_info_list(&sibling_nodes);\n\n\t\tkey_value_list_free(&remote_config_files);\n\n\t\tif (dry_run_success == false)\n\t\t{\n\t\t\tlog_error(_(\"prerequisites for executing STANDBY SWITCHOVER are *not* met\"));\n\t\t\tlog_hint(_(\"see preceding error messages\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tlog_info(_(\"prerequisites for executing STANDBY SWITCHOVER are met\"));\n\n\t\texit(SUCCESS);\n\t}\n\n\ttermPQExpBuffer(&command_output);\n\tshutdown_success = false;\n\n\t/* loop for timeout waiting for current primary to stop */\n\n\tfor (i = 0; i < config_file_options.shutdown_check_timeout; i++)\n\t{\n\t\t/* Check whether primary is available */\n\t\tPGPing\t\tping_res;\n\n\t\tlog_info(_(\"checking for primary shutdown; %i of %i attempts (\\\"shutdown_check_timeout\\\")\"),\n\t\t\t\t i + 1, config_file_options.shutdown_check_timeout);\n\n\t\tping_res = PQping(remote_conninfo);\n\n\t\tlog_debug(\"ping status is: %s\", print_pqping_status(ping_res));\n\n\t\t/* database server could not be contacted */\n\t\tif (ping_res == PQPING_NO_RESPONSE || ping_res == PQPING_NO_ATTEMPT)\n\t\t{\n\t\t\t/*\n\t\t\t * remote server can't be contacted at protocol level - that\n\t\t\t * doesn't necessarily mean it's shut down, so we'll ask its\n\t\t\t * repmgr to check at data directory level, and if shut down also\n\t\t\t * return the last checkpoint LSN.\n\t\t\t */\n\n\t\t\tinitPQExpBuffer(&remote_command_str);\n\t\t\tmake_remote_repmgr_path(&remote_command_str, &remote_node_record);\n\t\t\tappendPQExpBufferStr(&remote_command_str,\n\t\t\t\t\t\t\t\t \"node status --is-shutdown-cleanly\");\n\n\t\t\tinitPQExpBuffer(&command_output);\n\n\t\t\tcommand_success = remote_command(remote_host,\n\t\t\t\t\t\t\t\t\t\t\t runtime_options.remote_user,\n\t\t\t\t\t\t\t\t\t\t\t remote_command_str.data,\n\t\t\t\t\t\t\t\t\t\t\t config_file_options.ssh_options,\n\t\t\t\t\t\t\t\t\t\t\t &command_output);\n\n\t\t\ttermPQExpBuffer(&remote_command_str);\n\n\t\t\tif (command_success == true)\n\t\t\t{\n\t\t\t\tNodeStatus\tstatus = parse_node_status_is_shutdown_cleanly(command_output.data, &remote_last_checkpoint_lsn);\n\n\t\t\t\tlog_verbose(LOG_DEBUG, \"remote node status is: %s\", print_node_status(status));\n\n\t\t\t\tif (status == NODE_STATUS_DOWN && remote_last_checkpoint_lsn != InvalidXLogRecPtr)\n\t\t\t\t{\n\t\t\t\t\tshutdown_success = true;\n\t\t\t\t\tlog_notice(_(\"current primary has been cleanly shut down at location %X/%X\"),\n\t\t\t\t\t\t\t   format_lsn(remote_last_checkpoint_lsn));\n\t\t\t\t\ttermPQExpBuffer(&command_output);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* remote node did not shut down cleanly */\n\t\t\t\telse if (status == NODE_STATUS_UNCLEAN_SHUTDOWN)\n\t\t\t\t{\n\t\t\t\t\tif (!runtime_options.force)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_error(_(\"current primary did not shut down cleanly, aborting\"));\n\t\t\t\t\t\tlog_hint(_(\"use -F/--force to promote current standby\"));\n\t\t\t\t\t\ttermPQExpBuffer(&command_output);\n\t\t\t\t\t\texit(ERR_SWITCHOVER_FAIL);\n\t\t\t\t\t}\n\t\t\t\t\tlog_error(_(\"current primary did not shut down cleanly, continuing anyway\"));\n\t\t\t\t\tshutdown_success = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (status == NODE_STATUS_SHUTTING_DOWN)\n\t\t\t\t{\n\t\t\t\t\tlog_info(_(\"remote node is still shutting down\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttermPQExpBuffer(&command_output);\n\t\t}\n\n\t\tlog_debug(\"sleeping 1 second until next check\");\n\t\tsleep(1);\n\t}\n\n\tif (shutdown_success == false)\n\t{\n\t\tlog_error(_(\"shutdown of the primary server could not be confirmed\"));\n\t\tlog_hint(_(\"check the primary server status before performing any further actions\"));\n\t\texit(ERR_SWITCHOVER_FAIL);\n\t}\n\n\t/* this is unlikely to happen, but check and handle gracefully anyway */\n\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t{\n\t\tlog_warning(_(\"connection to local node lost, reconnecting...\"));\n\t\tlog_detail(\"\\n%s\", PQerrorMessage(local_conn));\n\t\tPQfinish(local_conn);\n\n\t\tlocal_conn = establish_db_connection(config_file_options.conninfo, false);\n\n\t\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t\t{\n\t\t\tlog_error(_(\"unable to reconnect to local node \\\"%s\\\"\"),\n\t\t\t\t\t  local_node_record.node_name);\n\t\t\texit(ERR_DB_CONN);\n\t\t}\n\t\tlog_verbose(LOG_INFO, _(\"successfully reconnected to local node\"));\n\t}\n\n\tinit_replication_info(&replication_info);\n\t/*\n\t * Compare standby's last WAL receive location with the primary's last\n\t * checkpoint LSN. We'll loop for a while as it's possible the standby's\n\t * walreceiver has not yet flushed all received WAL to disk.\n\t */\n\t{\n\t\tbool notice_emitted = false;\n\n\t\tfor (i = 0; i < config_file_options.wal_receive_check_timeout; i++)\n\t\t{\n\t\t\tget_replication_info(local_conn, STANDBY, &replication_info);\n\t\t\tif (replication_info.last_wal_receive_lsn >= remote_last_checkpoint_lsn)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * We'll only output this notice if it looks like we're going to have\n\t\t\t * to wait for WAL to be flushed.\n\t\t\t */\n\t\t\tif (notice_emitted == false)\n\t\t\t{\n\t\t\t\tlog_notice(_(\"waiting up to %i seconds (parameter \\\"wal_receive_check_timeout\\\") for received WAL to flush to disk\"),\n\t\t\t\t\t\t   config_file_options.wal_receive_check_timeout);\n\n\t\t\t\tnotice_emitted = true;\n\t\t\t}\n\n\t\t\tlog_info(_(\"sleeping %i of maximum %i seconds waiting for standby to flush received WAL to disk\"),\n\t\t\t\t\t i + 1, config_file_options.wal_receive_check_timeout);\n\t\t\tsleep(1);\n\t\t}\n\t}\n\n\tif (replication_info.last_wal_receive_lsn < remote_last_checkpoint_lsn)\n\t{\n\t\tlog_warning(_(\"local node \\\"%s\\\" is behind shutdown primary \\\"%s\\\"\"),\n\t\t\t\t\tlocal_node_record.node_name,\n\t\t\t\t\tremote_node_record.node_name);\n\t\tlog_detail(_(\"local node last receive LSN is %X/%X, primary shutdown checkpoint LSN is %X/%X\"),\n\t\t\t\t   format_lsn(replication_info.last_wal_receive_lsn),\n\t\t\t\t   format_lsn(remote_last_checkpoint_lsn));\n\n\t\tif (runtime_options.always_promote == false)\n\t\t{\n\t\t\tlog_notice(_(\"aborting switchover\"));\n\t\t\tlog_hint(_(\"use --always-promote to force promotion of standby\"));\n\t\t\tPQfinish(local_conn);\n\t\t\texit(ERR_SWITCHOVER_FAIL);\n\t\t}\n\t}\n\n\tlog_debug(\"local node last receive LSN is %X/%X, primary shutdown checkpoint LSN is %X/%X\",\n\t\t\t  format_lsn(replication_info.last_wal_receive_lsn),\n\t\t\t  format_lsn(remote_last_checkpoint_lsn));\n\n\t/*\n\t * optionally add a delay before promoting the standby; this is mainly\n\t * useful for testing (e.g. for reappearance of the original primary) and\n\t * is not documented.\n\t */\n\tif (config_file_options.promote_delay > 0)\n\t{\n\t\tlog_debug(\"sleeping %i seconds before promoting standby\",\n\t\t\t\t  config_file_options.promote_delay);\n\t\tsleep(config_file_options.promote_delay);\n\t}\n\n\t/*\n\t * Promote standby (local node).\n\t *\n\t * If PostgreSQL 12 or later, and -S/--superuser provided, we will provide\n\t * a superuser connection so that pg_promote() can be used.\n\t */\n\n\tif (PQserverVersion(local_conn) >= 120000 && superuser_conn != NULL)\n\t{\n\t\t_do_standby_promote_internal(superuser_conn);\n\t}\n\telse\n\t{\n\t\t_do_standby_promote_internal(local_conn);\n\t}\n\n\n\t/*\n\t * If pg_rewind is requested, issue a checkpoint immediately after promoting\n\t * the local node, as pg_rewind compares timelines on the basis of the value\n\t * in pg_control, which is written at the first checkpoint, which might not\n\t * occur immediately.\n\t */\n\tif (runtime_options.force_rewind_used == true)\n\t{\n\t\tPGconn *checkpoint_conn = local_conn;\n\t\tif (superuser_conn != NULL)\n\t\t{\n\t\t\tcheckpoint_conn = superuser_conn;\n\t\t}\n\n\t\tif (can_execute_checkpoint(checkpoint_conn) == true)\n\t\t{\n\t\t\tlog_notice(_(\"issuing CHECKPOINT on node \\\"%s\\\" (ID: %i) \"),\n\t\t\t\t\t   config_file_options.node_name,\n\t\t\t\t\t   config_file_options.node_id);\n\t\t\tcheckpoint(superuser_conn);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_warning(_(\"no authorized connection available, unable to issue CHECKPOINT\"));\n\n\t\t\tif (PQserverVersion(local_conn) >= 150000)\n\t\t\t{\n\t\t\t\tlog_hint(_(\"provide a superuser with -S/--superuser or grant pg_checkpoint role to repmgr user\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_hint(_(\"provide a superuser with -S/--superuser\"));\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Execute \"repmgr node rejoin\" to create recovery.conf and start the\n\t * remote server. Additionally execute \"pg_rewind\", if required and\n\t * requested.\n\t */\n\tinitPQExpBuffer(&node_rejoin_options);\n\n\t/*\n\t * Don't wait for repmgr on the remote node to report the success\n\t * of the rejoin operation - we'll check it from here.\n\t */\n\tappendPQExpBufferStr(&node_rejoin_options,\n\t\t\t\t\t\t \" --no-wait\");\n\n\tif (replication_info.last_wal_receive_lsn < remote_last_checkpoint_lsn)\n\t{\n\t\tKeyValueListCell *cell = NULL;\n\t\tbool\t\tfirst_entry = true;\n\n\t\tif (runtime_options.force_rewind_used == false)\n\t\t{\n\t\t\tlog_error(_(\"new primary diverges from former primary and --force-rewind not provided\"));\n\t\t\tlog_hint(_(\"the former primary will need to be restored manually, or use \\\"repmgr node rejoin\\\"\"));\n\n\t\t\ttermPQExpBuffer(&node_rejoin_options);\n\t\t\tPQfinish(local_conn);\n\t\t\texit(ERR_SWITCHOVER_FAIL);\n\t\t}\n\n\t\tappendPQExpBufferStr(&node_rejoin_options,\n\t\t\t\t\t\t  \" --force-rewind\");\n\n\t\tif (runtime_options.force_rewind_path[0] != '\\0')\n\t\t{\n\t\t\tappendPQExpBuffer(&node_rejoin_options,\n\t\t\t\t\t\t\t  \"=%s\",\n\t\t\t\t\t\t\t  runtime_options.force_rewind_path);\n\t\t}\n\t\tappendPQExpBufferStr(&node_rejoin_options,\n\t\t\t\t\t\t\t \" --config-files=\");\n\n\t\tfor (cell = remote_config_files.head; cell; cell = cell->next)\n\t\t{\n\t\t\tif (first_entry == false)\n\t\t\t\tappendPQExpBufferChar(&node_rejoin_options, ',');\n\t\t\telse\n\t\t\t\tfirst_entry = false;\n\n\t\t\tappendPQExpBufferStr(&node_rejoin_options, cell->key);\n\t\t}\n\n\t\tappendPQExpBufferChar(&node_rejoin_options, ' ');\n\t}\n\n\tkey_value_list_free(&remote_config_files);\n\n\tinitPQExpBuffer(&remote_command_str);\n\tmake_remote_repmgr_path(&remote_command_str, &remote_node_record);\n\n\t/*\n\t * Here we'll coerce the local node's connection string into\n\t * \"param=value\" format, in case it's configured in URI format,\n\t * to simplify escaping issues when passing the string to the\n\t * remote node.\n\t */\n\t{\n\t\tchar\t   *conninfo_normalized = normalize_conninfo_string(local_node_record.conninfo);\n\n\t\tappendPQExpBuffer(&remote_command_str,\n\t\t\t\t\t\t  \"%s -d \",\n\t\t\t\t\t\t  node_rejoin_options.data);\n\n\t\tappendRemoteShellString(&remote_command_str,\n\t\t\t\t\t\t\t\tconninfo_normalized);\n\n\t\tappendPQExpBufferStr(&remote_command_str,\n\t\t\t\t\t\t\t \" node rejoin\");\n\n\t\tpfree(conninfo_normalized);\n\t}\n\n\t/* */\n\tsnprintf(node_rejoin_log, MAXPGPATH,\n#if defined(__i386__) || defined(__i386)\n\t\t\t \"/tmp/node-rejoin.%u.log\",\n\t\t\t (unsigned)time(NULL)\n#else\n\t\t\t \"/tmp/node-rejoin.%lu.log\",\n\t\t\t (unsigned long)time(NULL)\n#endif\n\t\t);\n\n\tappendPQExpBuffer(&remote_command_str,\n\t\t\t\t\t  \" > %s 2>&1 && echo \\\"1\\\" || echo \\\"0\\\"\",\n\t\t\t\t\t  node_rejoin_log);\n\n\ttermPQExpBuffer(&node_rejoin_options);\n\n\tlog_debug(\"executing:\\n  %s\", remote_command_str.data);\n\tinitPQExpBuffer(&command_output);\n\n\tcommand_success = remote_command(remote_host,\n\t\t\t\t\t\t\t\t\t runtime_options.remote_user,\n\t\t\t\t\t\t\t\t\t remote_command_str.data,\n\t\t\t\t\t\t\t\t\t config_file_options.ssh_options,\n\t\t\t\t\t\t\t\t\t &command_output);\n\n\ttermPQExpBuffer(&remote_command_str);\n\n\tinitPQExpBuffer(&logmsg);\n\tinitPQExpBuffer(&detailmsg);\n\n\t/* This is failure to execute the ssh command */\n\tif (command_success == false)\n\t{\n\t\tlog_error(_(\"rejoin failed with error code %i\"), r);\n\t\tswitchover_success = false;\n\n\t\tappendPQExpBuffer(&logmsg,\n\t\t\t\t\t\t  _(\"unable to execute \\\"repmgr node rejoin\\\" on demotion candidate \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t  remote_node_record.node_name,\n\t\t\t\t\t\t  remote_node_record.node_id);\n\t\tappendPQExpBufferStr(&detailmsg,\n\t\t\t\t\t\t\t command_output.data);\n\n\t}\n\telse\n\t{\n\t\tstandy_join_status join_success = JOIN_UNKNOWN;\n\n\t\t/* \"rempgr node rejoin\" failed on the demotion candidate */\n\t\tif (command_output.data[0] == '0')\n\t\t{\n\t\t\tappendPQExpBuffer(&logmsg,\n\t\t\t\t\t\t\t  _(\"execution of \\\"repmgr node rejoin\\\" on demotion candidate \\\"%s\\\" (ID: %i) failed\"),\n\t\t\t\t\t\t\t  remote_node_record.node_name,\n\t\t\t\t\t\t\t  remote_node_record.node_id);\n\n\t\t\t/*\n\t\t\t * Speculatively check if the demotion candidate has been restarted, e.g. by\n\t\t\t * an external watchdog process which isn't aware a switchover is happening.\n\t\t\t * This falls into the category \"thing outside of our control which shouldn't\n\t\t\t * happen, but if it does, make it easier to find out what happened\".\n\t\t\t */\n\t\t\tremote_conn = establish_db_connection(remote_node_record.conninfo, false);\n\n\t\t\tif (PQstatus(remote_conn) == CONNECTION_OK)\n\t\t\t{\n\t\t\t\tif (get_recovery_type(remote_conn) == RECTYPE_PRIMARY)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&detailmsg,\n\t\t\t\t\t\t\t\t\t  _(\"PostgreSQL instance on demotion candidate \\\"%s\\\" (ID: %i) is running as a primary\\n\"),\n\t\t\t\t\t\t\t\t\t  remote_node_record.node_name,\n\t\t\t\t\t\t\t\t\t  remote_node_record.node_id);\n\t\t\t\t\tlog_warning(\"%s\", detailmsg.data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPQfinish(remote_conn);\n\n\t\t\tappendPQExpBuffer(&detailmsg,\n\t\t\t\t\t\t\t  \"check log file \\\"%s\\\" on \\\"%s\\\" for details\",\n\t\t\t\t\t\t\t  node_rejoin_log,\n\t\t\t\t\t\t\t  remote_node_record.node_name);\n\n\t\t\tswitchover_success = false;\n\t\t\tjoin_success = JOIN_COMMAND_FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tjoin_success = check_standby_join(local_conn,\n\t\t\t\t\t\t\t\t\t\t\t  &local_node_record,\n\t\t\t\t\t\t\t\t\t\t\t  &remote_node_record);\n\n\n\n\t\t\tswitch (join_success) {\n\t\t\t\tcase JOIN_FAIL_NO_PING:\n\t\t\t\t\tappendPQExpBuffer(&logmsg,\n\t\t\t\t\t\t\t\t\t  _(\"node \\\"%s\\\" (ID: %i) promoted to primary, but demotion candidate \\\"%s\\\" (ID: %i) did not become available\"),\n\t\t\t\t\t\t\t\t\t  config_file_options.node_name,\n\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t  remote_node_record.node_name,\n\t\t\t\t\t\t\t\t\t  remote_node_record.node_id);\n\n\t\t\t\t\tswitchover_success = false;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase JOIN_FAIL_NO_REPLICATION:\n\t\t\t\t\tappendPQExpBuffer(&logmsg,\n\t\t\t\t\t\t\t\t\t  _(\"node \\\"%s\\\" (ID: %i) promoted to primary, but demotion candidate \\\"%s\\\" (ID: %i) did not connect to the new primary\"),\n\t\t\t\t\t\t\t\t\t  config_file_options.node_name,\n\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t  remote_node_record.node_name,\n\t\t\t\t\t\t\t\t\t  remote_node_record.node_id);\n\t\t\t\t\tswitchover_success = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase JOIN_SUCCESS:\n\t\t\t\t\tappendPQExpBuffer(&logmsg,\n\t\t\t\t\t\t\t\t\t  _(\"node \\\"%s\\\" (ID: %i) promoted to primary, node \\\"%s\\\" (ID: %i) demoted to standby\"),\n\t\t\t\t\t\t\t\t\t  config_file_options.node_name,\n\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t  remote_node_record.node_name,\n\t\t\t\t\t\t\t\t\t  remote_node_record.node_id);\n\t\t\t\t\tbreak;\n\t\t\t\t/* check_standby_join() does not return this */\n\t\t\t\tcase JOIN_COMMAND_FAIL:\n\t\t\t\t\tbreak;\n\t\t\t\t/* should never happen*/\n\t\t\t\tcase JOIN_UNKNOWN:\n\t\t\t\t\tappendPQExpBuffer(&logmsg,\n\t\t\t\t\t\t\t\t\t  \"unable to determine success of node rejoin action for demotion candidate \\\"%s\\\" (ID: %i)\",\n\t\t\t\t\t\t\t\t\t  remote_node_record.node_name,\n\t\t\t\t\t\t\t\t\t  remote_node_record.node_id);\n\t\t\t\t\tswitchover_success = false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (switchover_success == false)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&detailmsg,\n\t\t\t\t\t\t\t\t  \"check the PostgreSQL log file on  demotion candidate \\\"%s\\\" (ID: %i)\",\n\t\t\t\t\t\t\t\t  remote_node_record.node_name,\n\t\t\t\t\t\t\t\t  remote_node_record.node_id);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (switchover_success == true)\n\t{\n\t\t/* TODO: verify demotion candidates's node record was updated correctly */\n\n\t\tlog_notice(\"%s\", logmsg.data);\n\t}\n\telse\n\t{\n\t\tlog_error(\"%s\", logmsg.data);\n\t}\n\n\tinitPQExpBuffer(&event_details);\n\n\tappendPQExpBufferStr(&event_details, logmsg.data);\n\n\tif (detailmsg.data[0] != '\\0')\n\t{\n\t\tlog_detail(\"%s\", detailmsg.data);\n\t\tappendPQExpBuffer(&event_details, \"\\n%s\",\n\t\t\t\t\t\t  detailmsg.data);\n\t}\n\n\n\tcreate_event_notification_extended(local_conn,\n\t\t\t\t\t\t\t\t\t   &config_file_options,\n\t\t\t\t\t\t\t\t\t   config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t   \"standby_switchover\",\n\t\t\t\t\t\t\t\t\t   switchover_success,\n\t\t\t\t\t\t\t\t\t   event_details.data,\n\t\t\t\t\t\t\t\t\t   &event_info);\n\n\ttermPQExpBuffer(&event_details);\n\ttermPQExpBuffer(&logmsg);\n\ttermPQExpBuffer(&detailmsg);\n\ttermPQExpBuffer(&command_output);\n\n\n\t/*\n\t * If --siblings-follow specified, attempt to make them follow the new\n\t * primary\n\t */\n\tif (runtime_options.siblings_follow == true && sibling_nodes.node_count > 0)\n\t{\n\t\tsibling_nodes_follow(&local_node_record, &sibling_nodes, &sibling_nodes_stats);\n\t}\n\n\tclear_node_info_list(&sibling_nodes);\n\n\t/*\n\t * Clean up remote node (primary demoted to standby). It's possible that the node is\n\t * still starting up, so poll for a while until we get a connection.\n\t */\n\n\tfor (i = 0; i < config_file_options.standby_reconnect_timeout; i++)\n\t{\n\t\tremote_conn = establish_db_connection(remote_node_record.conninfo, false);\n\n\t\tif (PQstatus(remote_conn) == CONNECTION_OK)\n\t\t\tbreak;\n\n\t\tlog_info(_(\"sleeping 1 second; %i of %i attempts (\\\"standby_reconnect_timeout\\\") to reconnect to demoted primary\"),\n\t\t\t\t i + 1,\n\t\t\t\t config_file_options.standby_reconnect_timeout);\n\t\tsleep(1);\n\t}\n\n\t/* check new standby (old primary) is reachable */\n\tif (PQstatus(remote_conn) != CONNECTION_OK)\n\t{\n\t\tswitchover_success = false;\n\n\t\t/* TODO: double-check whether new standby has attached */\n\n\t\tlog_warning(_(\"switchover did not fully complete\"));\n\t\tlog_detail(_(\"node \\\"%s\\\" (ID: %i) is now primary but node \\\"%s\\\" (ID: %i) is not reachable\"),\n\t\t\t\t   local_node_record.node_name,\n\t\t\t\t   local_node_record.node_id,\n\t\t\t\t   remote_node_record.node_name,\n\t\t\t\t   remote_node_record.node_id);\n\n\t\tif (config_file_options.use_replication_slots == true)\n\t\t{\n\t\t\tlog_hint(_(\"any inactive replication slots on the old primary will need to be dropped manually\"));\n\t\t}\n\t}\n\telse\n\t{\n\t\tNodeAttached node_attached;\n\n\t\t/*\n\t\t * We were able to connect to the former primary - attempt to drop\n\t\t * this node's former replication slot, if it exists.\n\t\t */\n\t\tif (config_file_options.use_replication_slots == true)\n\t\t{\n\t\t\tdrop_replication_slot_if_exists(remote_conn,\n\t\t\t\t\t\t\t\t\t\t\tremote_node_record.node_id,\n\t\t\t\t\t\t\t\t\t\t\tlocal_node_record.slot_name);\n\t\t}\n\n\n\t\t/*\n\t\t * Do a final check that the standby has connected - it's possible\n\t\t * the standby became reachable but has not connected (or became disconnected).\n\t\t */\n\n\t\t node_attached = is_downstream_node_attached(local_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t remote_node_record.node_name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NULL);\n\t\tif (node_attached == NODE_ATTACHED)\n\t\t{\n\t\t\tswitchover_success = true;\n\t\t\tlog_notice(_(\"switchover was successful\"));\n\t\t\tlog_detail(_(\"node \\\"%s\\\" is now primary and node \\\"%s\\\" is attached as standby\"),\n\t\t\t\t\t   local_node_record.node_name,\n\t\t\t\t\t   remote_node_record.node_name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_notice(_(\"switchover is incomplete\"));\n\t\t\tlog_detail(_(\"node \\\"%s\\\" is now primary but node \\\"%s\\\" is not attached as standby\"),\n\t\t\t\t\t   local_node_record.node_name,\n\t\t\t\t\t   remote_node_record.node_name);\n\t\t\tswitchover_success = false;\n\t\t}\n\n\t}\n\n\tPQfinish(remote_conn);\n\tPQfinish(local_conn);\n\n\t/*\n\t * Attempt to unpause all paused repmgrd instances, unless user explicitly\n\t * specifies not to.\n\t */\n\tif (runtime_options.repmgrd_no_pause == false)\n\t{\n\t\tif (repmgrd_running_count > 0)\n\t\t{\n\t\t\tItemList repmgrd_unpause_errors = {NULL, NULL};\n\t\t\tNodeInfoListCell *cell = NULL;\n\t\t\ti = 0;\n\t\t\tint error_node_count = 0;\n\n\t\t\tfor (cell = all_nodes.head; cell; cell = cell->next)\n\t\t\t{\n\n\t\t\t\tif (repmgrd_info[i]->paused == true && runtime_options.repmgrd_force_unpause == false)\n\t\t\t\t{\n\t\t\t\t\tlog_debug(\"repmgrd on node \\\"%s\\\" (ID: %i) paused before switchover, --repmgrd-force-unpause not provided, not unpausing\",\n\t\t\t\t\t\t\t  cell->node_info->node_name,\n\t\t\t\t\t\t\t  cell->node_info->node_id);\n\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlog_debug(\"unpausing repmgrd on node \\\"%s\\\" (ID: %i)\",\n\t\t\t\t\t\t  cell->node_info->node_name,\n\t\t\t\t\t\t  cell->node_info->node_id);\n\n\t\t\t\tcell->node_info->conn = establish_db_connection_quiet(cell->node_info->conninfo);\n\n\t\t\t\tif (PQstatus(cell->node_info->conn) == CONNECTION_OK)\n\t\t\t\t{\n\t\t\t\t\tif (repmgrd_pause(cell->node_info->conn, false) == false)\n\t\t\t\t\t{\n\t\t\t\t\t\titem_list_append_format(&repmgrd_unpause_errors,\n\t\t\t\t\t\t\t\t\t\t\t\t_(\"unable to unpause node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\t\t\t\t\t\t\tcell->node_info->node_id);\n\t\t\t\t\t\terror_node_count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\titem_list_append_format(&repmgrd_unpause_errors,\n\t\t\t\t\t\t\t\t\t\t\t_(\"unable to connect to node \\\"%s\\\" (ID: %i):\\n%s\"),\n\t\t\t\t\t\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\t\t\t\t\t\tcell->node_info->node_id,\n\t\t\t\t\t\t\t\t\t\t\tPQerrorMessage(cell->node_info->conn));\n\t\t\t\t\terror_node_count++;\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (error_node_count > 0)\n\t\t\t{\n\t\t\t\tPQExpBufferData detail;\n\t\t\t\tItemListCell *cell;\n\n\t\t\t\tinitPQExpBuffer(&detail);\n\n\t\t\t\tfor (cell = repmgrd_unpause_errors.head; cell; cell = cell->next)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBuffer(&detail,\n\t\t\t\t\t\t\t\t\t  \"  %s\\n\",\n\t\t\t\t\t\t\t\t\t  cell->string);\n\t\t\t\t}\n\n\t\t\t\tlog_warning(_(\"unable to unpause repmgrd on %i node(s)\"),\n\t\t\t\t\t\t\terror_node_count);\n\t\t\t\tlog_detail(_(\"errors encountered for following node(s):\\n%s\"), detail.data);\n\t\t\t\tlog_hint(_(\"check node connection and status; unpause manually with \\\"repmgr service unpause\\\"\"));\n\n\t\t\t\ttermPQExpBuffer(&detail);\n\t\t\t}\n\t\t}\n\n\t\tclear_node_info_list(&all_nodes);\n\t}\n\n\tif (switchover_success == true)\n\t{\n\t\tlog_notice(_(\"STANDBY SWITCHOVER has completed successfully\"));\n\t}\n\telse\n\t{\n\t\tlog_notice(_(\"STANDBY SWITCHOVER has completed with issues\"));\n\t\tlog_hint(_(\"see preceding log message(s) for details\"));\n\t\texit(ERR_SWITCHOVER_INCOMPLETE);\n\t}\n\n\treturn;\n}\n\n\nstatic void\ncheck_source_server()\n{\n\tchar\t\tcluster_size[MAXLEN];\n\tchar\t   *connstr = NULL;\n\n\tt_node_info upstream_node_record = T_NODE_INFO_INITIALIZER;\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\tExtensionStatus extension_status = REPMGR_UNKNOWN;\n\tt_extension_versions extversions = T_EXTENSION_VERSIONS_INITIALIZER;\n\n\t/* Attempt to connect to the upstream server to verify its configuration */\n\tlog_verbose(LOG_DEBUG, \"check_source_server()\");\n\tlog_info(_(\"connecting to source node\"));\n\n\tconnstr = param_list_to_string(&source_conninfo);\n\tlog_detail(_(\"connection string is: %s\"), connstr);\n\tpfree(connstr);\n\n\tsource_conn = establish_db_connection_by_params(&source_conninfo, false);\n\n\t/*\n\t * Unless in barman mode, exit with an error;\n\t * establish_db_connection_by_params() will have already logged an error\n\t * message\n\t */\n\tif (PQstatus(source_conn) != CONNECTION_OK)\n\t{\n\t\tPQfinish(source_conn);\n\t\tsource_conn = NULL;\n\t\tif (mode == barman)\n\t\t\treturn;\n\n\t\texit(ERR_DB_CONN);\n\t}\n\n\t/*\n\t * The server version check will also serve as a sanity-check that we can\n\t * actually execute queries on this connection.\n\t */\n\tsource_server_version_num = check_server_version(source_conn, \"primary\", true, NULL);\n\n\t/*\n\t * The cluster size is nice to have, but not essential to know, so only display\n\t * something if the user has sufficient permissions to retrieve the size of\n\t * all databases.\n\t */\n\tif (get_cluster_size(source_conn, cluster_size) == true)\n\t\tlog_detail(_(\"current installation size is %s\"),\n\t\t\t   cluster_size);\n\n\t/*\n\t * If the upstream node is a standby, try to connect to the primary too so\n\t * we can write an event record\n\t */\n\tif (get_recovery_type(source_conn) == RECTYPE_STANDBY)\n\t{\n\t\tprimary_conn = get_primary_connection(source_conn, NULL, NULL);\n\n\t\tif (PQstatus(primary_conn) != CONNECTION_OK)\n\t\t{\n\t\t\tlog_error(_(\"unable to connect to primary node\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\telse\n\t{\n\t\tprimary_conn = source_conn;\n\t}\n\n\t/*\n\t * Sanity-check that the primary node has a repmgr extension - if not\n\t * present, fail with an error unless -F/--force is used (to enable repmgr\n\t * to be used as a standalone clone tool).\n\t */\n\n\textension_status = get_repmgr_extension_status(primary_conn, &extversions);\n\n\tif (extension_status != REPMGR_INSTALLED)\n\t{\n\t\tif (!runtime_options.force)\n\t\t{\n\t\t\t/* this is unlikely to happen */\n\t\t\tif (extension_status == REPMGR_UNKNOWN)\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to determine status of \\\"repmgr\\\" extension\"));\n\t\t\t\tlog_detail(\"%s\", PQerrorMessage(primary_conn));\n\t\t\t\tPQfinish(source_conn);\n\t\t\t\texit(ERR_DB_QUERY);\n\t\t\t}\n\n\t\t\tif (extension_status == REPMGR_AVAILABLE)\n\t\t\t{\n\t\t\t\tlog_error(_(\"repmgr extension is available but not installed in database \\\"%s\\\"\"),\n\t\t\t\t\t\t   param_get(&source_conninfo, \"dbname\"));\n\t\t\t\tlog_hint(_(\"check that you are cloning from the database where \\\"repmgr\\\" is installed\"));\n\t\t\t}\n\t\t\telse if (extension_status == REPMGR_UNAVAILABLE)\n\t\t\t{\n\t\t\t\tlog_error(_(\"repmgr extension is not available on the upstream node\"));\n\t\t\t}\n\t\t\telse if (extension_status == REPMGR_OLD_VERSION_INSTALLED)\n\t\t\t{\n\t\t\t\tlog_error(_(\"an older version of the extension is installed on the upstream node\"));\n\t\t\t\tlog_detail(_(\"version %s is installed but newer version %s is available\"),\n\t\t\t\t\t\t   extversions.installed_version,\n\t\t\t\t\t\t   extversions.default_version);\n\t\t\t\tlog_hint(_(\"upgrade \\\"repmgr\\\" on the source node first\"));\n\t\t\t}\n\n\t\t\tPQfinish(source_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tlog_warning(_(\"repmgr extension not found on source node\"));\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If upstream is not a standby, retrieve its node records\n\t\t * and attempt to connect to one; we'll then compare\n\t\t * that node's system identifier to that of the source\n\t\t * connection, to ensure we're cloning from a node which is\n\t\t * part of the physical replication cluster. This is mainly\n\t\t * to prevent cloning a standby from a witness server.\n\t\t *\n\t\t * Note that it doesn't matter if the node from the node record\n\t\t * list is the same as the source node; also if the source node\n\t\t * does not have any node records, there's not a lot we can do.\n\t\t *\n\t\t * This check will be only carried out on PostgreSQL 9.6 and\n\t\t * later, as this is a precautionary check and we can retrieve the system\n\t\t * identifier with a normal connection.\n\t\t */\n\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(_(\"\\\"repmgr\\\" extension is installed in database \\\"%s\\\"\"),\n\t\t\t\t\t param_get(&source_conninfo, \"dbname\"));\n\t\t}\n\n\t\tif (get_recovery_type(source_conn) == RECTYPE_PRIMARY && PQserverVersion(source_conn) >= 90600)\n\t\t{\n\t\t\tuint64\t\tsource_system_identifier = system_identifier(source_conn);\n\n\t\t\tif (source_system_identifier != UNKNOWN_SYSTEM_IDENTIFIER)\n\t\t\t{\n\t\t\t\tNodeInfoList all_nodes = T_NODE_INFO_LIST_INITIALIZER;\n\t\t\t\tNodeInfoListCell *cell = NULL;\n\t\t\t\tget_all_node_records(source_conn, &all_nodes);\n\n\t\t\t\tlog_debug(\"%i node records returned by source node\", all_nodes.node_count);\n\n\t\t\t\t/* loop through its nodes table */\n\n\t\t\t\tfor (cell = all_nodes.head; cell; cell = cell->next)\n\t\t\t\t{\n\n\t\t\t\t\t/* exclude the witness node, as its system identifier will be different, of course */\n\t\t\t\t\tif (cell->node_info->type == WITNESS)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcell->node_info->conn = establish_db_connection_quiet(cell->node_info->conninfo);\n\t\t\t\t\tif (PQstatus(cell->node_info->conn) == CONNECTION_OK)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint64\t\ttest_system_identifier = system_identifier(cell->node_info->conn);\n\t\t\t\t\t\tPQfinish(cell->node_info->conn);\n\t\t\t\t\t\tcell->node_info->conn = NULL;\n\n\t\t\t\t\t\tif (test_system_identifier != UNKNOWN_SYSTEM_IDENTIFIER)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (source_system_identifier != test_system_identifier)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog_error(_(\"source node's system identifier does not match other nodes in the replication cluster\"));\n\t\t\t\t\t\t\t\tlog_detail(_(\"source node's system identifier is %lu, replication cluster member \\\"%s\\\"'s system identifier is %lu\"),\n\t\t\t\t\t\t\t\t\t\t   source_system_identifier,\n\t\t\t\t\t\t\t\t\t\t   cell->node_info->node_name,\n\t\t\t\t\t\t\t\t\t\t   test_system_identifier);\n\t\t\t\t\t\t\t\tlog_hint(_(\"check that the source node is not a witness server\"));\n\t\t\t\t\t\t\t\tPQfinish(source_conn);\n\t\t\t\t\t\t\t\tsource_conn = NULL;\n\n\t\t\t\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* identifiers match - our work here is done */\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tPQfinish(cell->node_info->conn);\n\t\t\t\t\t\tcell->node_info->conn = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclear_node_info_list(&all_nodes);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/*\n\t * Check the local directory to see if it appears to be a PostgreSQL\n\t * data directory.\n\t *\n\t * Note: a previous call to check_dir() will have checked whether it contains\n\t * a running PostgreSQL instance.\n\t */\n\tif (is_pg_dir(local_data_directory))\n\t{\n\t\tconst char *msg = _(\"target data directory appears to be a PostgreSQL data directory\");\n\t\tconst char *hint = _(\"use -F/--force to overwrite the existing data directory\");\n\n\t\tif (runtime_options.force == false && runtime_options.dry_run == false)\n\t\t{\n\t\t\tlog_error(\"%s\", msg);\n\t\t\tlog_detail(_(\"target data directory is \\\"%s\\\"\"), local_data_directory);\n\t\t\tlog_hint(\"%s\", hint);\n\t\t\tPQfinish(source_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tif (runtime_options.force == true)\n\t\t\t{\n\t\t\t\tlog_warning(\"%s and will be overwritten\", msg);\n\t\t\t\tlog_detail(_(\"target data directory is \\\"%s\\\"\"), local_data_directory);\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_warning(\"%s\", msg);\n\t\t\t\tlog_detail(_(\"target data directory is \\\"%s\\\"\"), local_data_directory);\n\t\t\t\tlog_hint(\"%s\", hint);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Attempt to find the upstream node record\n\t */\n\tif (runtime_options.upstream_node_id == NO_UPSTREAM_NODE)\n\t\tupstream_node_id = get_primary_node_id(source_conn);\n\telse\n\t\tupstream_node_id = runtime_options.upstream_node_id;\n\n\tlog_debug(\"upstream_node_id determined as %i\", upstream_node_id);\n\n\tif (upstream_node_id != UNKNOWN_NODE_ID)\n\t{\n\t\tt_node_info other_node_record = T_NODE_INFO_INITIALIZER;\n\n\t\trecord_status = get_node_record(source_conn, upstream_node_id, &upstream_node_record);\n\t\tif (record_status == RECORD_FOUND)\n\t\t{\n\t\t\tt_conninfo_param_list upstream_conninfo = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\t\t\tchar\t   *upstream_conninfo_user;\n\n\t\t\tinitialize_conninfo_params(&upstream_conninfo, false);\n\t\t\tparse_conninfo_string(upstream_node_record.conninfo, &upstream_conninfo, NULL, false);\n\n\t\t\tstrncpy(recovery_conninfo_str, upstream_node_record.conninfo, MAXLEN);\n\t\t\tstrncpy(upstream_repluser, upstream_node_record.repluser, NAMEDATALEN);\n\n\t\t\tupstream_conninfo_user = param_get(&upstream_conninfo, \"user\");\n\t\t\tif (upstream_conninfo_user != NULL)\n\t\t\t{\n\t\t\t\tstrncpy(upstream_user, upstream_conninfo_user, NAMEDATALEN);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tget_conninfo_default_value(\"user\", upstream_user, NAMEDATALEN);\n\t\t\t}\n\n\t\t\tlog_verbose(LOG_DEBUG, \"upstream_user is \\\"%s\\\"\", upstream_user);\n\n\t\t\tupstream_conninfo_found = true;\n\t\t}\n\n\t\t/*\n\t\t * Check that there's no existing node record with the same name but\n\t\t * different ID.\n\t\t */\n\t\trecord_status = get_node_record_by_name(source_conn, config_file_options.node_name, &other_node_record);\n\n\t\tif (record_status == RECORD_FOUND && other_node_record.node_id != config_file_options.node_id)\n\t\t{\n\t\t\tlog_error(_(\"another node (ID: %i) already exists with node_name \\\"%s\\\"\"),\n\t\t\t\t\t  other_node_record.node_id,\n\t\t\t\t\t  config_file_options.node_name);\n\t\t\tPQfinish(source_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\t/* Check the source node is configured sufficiently to be able to clone from */\n\tcheck_upstream_config(source_conn, source_server_version_num, &upstream_node_record, true);\n\n\t/*\n\t * Work out which users need to perform which tasks.\n\t *\n\t * Here we'll check the qualifications of the repmgr user as we have the\n\t * connection open; replication and superuser connections will be opened\n\t * when required and any errors will be raised at that point.\n\t */\n\n\t/*\n\t * If the user wants to copy configuration files located outside the\n\t * data directory, we'll need to be able to query the upstream node's data\n\t * directory location, which is available only to superusers or members\n\t * of the appropriate role.\n\t */\n\tif (runtime_options.copy_external_config_files == true)\n\t{\n\t\t/*\n\t\t * This will check if the user is superuser or (from Pg10) is a member\n\t\t * of \"pg_read_all_settings\"/\"pg_monitor\"\n\t\t */\n\t\tif (connection_has_pg_monitor_role(source_conn, \"pg_read_all_settings\") == true)\n\t\t{\n\t\t\tSettingsUser = REPMGR_USER;\n\t\t}\n\t\telse if (runtime_options.superuser[0] != '\\0')\n\t\t{\n\t\t\tSettingsUser = SUPERUSER;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_error(_(\"--copy-external-config-files requires a user with permission to read the data directory on the source node\"));\n\n\t\t\tif (PQserverVersion(source_conn) >= 100000)\n\t\t\t{\n\t\t\t\tlog_hint(_(\"the repmgr user must be superuser or member of role \\\"pg_monitor\\\" or \\\"pg_read_all_settings\\\", or a superuser provided with -S/--superuser\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_hint(_(\"the repmgr user must be superuser, or a superuser provided with -S/--superuser\"));\n\t\t\t}\n\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\t/*\n\t * To create replication slots, we'll need a user with the REPLICATION\n\t * privilege, or a superuser.\n\t */\n\tif (config_file_options.use_replication_slots == true)\n\t{\n\t}\n}\n\n\nstatic void\ncheck_source_server_via_barman()\n{\n\tchar\t\tbuf[MAXLEN] = \"\";\n\tchar\t\tbarman_conninfo_str[MAXLEN] = \"\";\n\tt_conninfo_param_list barman_conninfo = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\tchar\t   *errmsg = NULL;\n\tbool\t\tparse_success = false,\n\t\t\t\tcommand_success = false;\n\tchar\t\twhere_condition[MAXLEN];\n\tPQExpBufferData command_output;\n\tPQExpBufferData repmgr_conninfo_buf;\n\n\tint\t\t\tc = 0;\n\n\tget_barman_property(barman_conninfo_str, \"conninfo\", local_repmgr_tmp_directory);\n\n\tinitialize_conninfo_params(&barman_conninfo, false);\n\n\t/*\n\t * parse_conninfo_string() here will remove the upstream's\n\t * `application_name`, if set\n\t */\n\tparse_success = parse_conninfo_string(barman_conninfo_str, &barman_conninfo, &errmsg, true);\n\n\tif (parse_success == false)\n\t{\n\t\tlog_error(_(\"Unable to parse barman conninfo string \\\"%s\\\":\\n%s\"),\n\t\t\t\t  barman_conninfo_str, errmsg);\n\t\texit(ERR_BARMAN);\n\t}\n\n\t/* Overwrite database name in the parsed parameter list */\n\tparam_set(&barman_conninfo, \"dbname\", runtime_options.dbname);\n\n\t/* Rebuild the Barman conninfo string */\n\tinitPQExpBuffer(&repmgr_conninfo_buf);\n\n\tfor (c = 0; c < barman_conninfo.size && barman_conninfo.keywords[c] != NULL; c++)\n\t{\n\t\tif (repmgr_conninfo_buf.len != 0)\n\t\t\tappendPQExpBufferChar(&repmgr_conninfo_buf, ' ');\n\n\t\tappendPQExpBuffer(&repmgr_conninfo_buf, \"%s=\",\n\t\t\t\t\t\t  barman_conninfo.keywords[c]);\n\t\tappendConnStrVal(&repmgr_conninfo_buf,\n\t\t\t\t\t\t barman_conninfo.values[c]);\n\t}\n\n\tlog_verbose(LOG_DEBUG,\n\t\t\t\t\"repmgr database conninfo string on barman server: %s\",\n\t\t\t\trepmgr_conninfo_buf.data);\n\n\tif (upstream_node_id == UNKNOWN_NODE_ID)\n\t{\n\t\tmaxlen_snprintf(where_condition, \"type='primary' AND active IS TRUE\");\n\t}\n\telse\n\t{\n\t\tmaxlen_snprintf(where_condition, \"node_id=%i\", upstream_node_id);\n\t}\n\n\tinitPQExpBuffer(&command_output);\n\tmaxlen_snprintf(buf,\n\t\t\t\t\t\"psql -AqtX -d \\\\\\\"%s\\\\\\\" -c \\\\\\\"\"\n\t\t\t\t\t\" SELECT conninfo\"\n\t\t\t\t\t\" FROM repmgr.nodes\"\n\t\t\t\t\t\" WHERE %s\"\n\t\t\t\t\t\" AND active IS TRUE\"\n\t\t\t\t\t\"\\\\\\\"\",\n\t\t\t\t\trepmgr_conninfo_buf.data,\n\t\t\t\t\twhere_condition);\n\n\ttermPQExpBuffer(&repmgr_conninfo_buf);\n\n\tcommand_success = remote_command(config_file_options.barman_host,\n\t\t\t\t\t\t\t\t\t runtime_options.remote_user,\n\t\t\t\t\t\t\t\t\t buf,\n\t\t\t\t\t\t\t\t\t config_file_options.ssh_options,\n\t\t\t\t\t\t\t\t\t &command_output);\n\n\tif (command_success == false)\n\t{\n\t\tlog_error(_(\"unable to execute database query via Barman server\"));\n\t\texit(ERR_BARMAN);\n\t}\n\n\tmaxlen_snprintf(recovery_conninfo_str, \"%s\", command_output.data);\n\tstring_remove_trailing_newlines(recovery_conninfo_str);\n\n\tupstream_conninfo_found = true;\n\tlog_verbose(LOG_DEBUG,\n\t\t\t\t\"upstream node conninfo string extracted via barman server: %s\",\n\t\t\t\trecovery_conninfo_str);\n\n\ttermPQExpBuffer(&command_output);\n}\n\n\n/*\n * check_upstream_config()\n *\n * Perform sanity check on upstream server configuration before starting cloning\n * process\n *\n * TODO:\n *  - check user is qualified to perform base backup\n */\n\nstatic bool\ncheck_upstream_config(PGconn *conn, int server_version_num, t_node_info *upstream_node_record, bool exit_on_error)\n{\n\tint\t\t\ti;\n\tbool\t\tconfig_ok = true;\n\tchar\t   *wal_error_message = NULL;\n\tt_basebackup_options backup_options = T_BASEBACKUP_OPTIONS_INITIALIZER;\n\tbool\t\tbackup_options_ok = true;\n\tItemList\tbackup_option_errors = {NULL, NULL};\n\tbool\t\twal_method_stream = true;\n\tstandy_clone_mode mode;\n\tbool\t\tpg_setting_ok;\n\n\t/*\n\t * Detecting the intended cloning mode\n\t */\n\tmode = get_standby_clone_mode();\n\n\t/*\n\t * Parse \"pg_basebackup_options\", if set, to detect whether --wal-method\n\t * has been set to something other than `stream` (i.e. `fetch`), as this\n\t * will influence some checks\n\t */\n\n\tbackup_options_ok = parse_pg_basebackup_options(config_file_options.pg_basebackup_options,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&backup_options, server_version_num,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&backup_option_errors);\n\n\tif (backup_options_ok == false)\n\t{\n\t\tif (exit_on_error == true)\n\t\t{\n\t\t\tlog_error(_(\"error(s) encountered parsing \\\"pg_basebackup_options\\\"\"));\n\t\t\tprint_error_list(&backup_option_errors, LOG_ERR);\n\t\t\tlog_hint(_(\"\\\"pg_basebackup_options\\\" is: \\\"%s\\\"\"),\n\t\t\t\t\t config_file_options.pg_basebackup_options);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tconfig_ok = false;\n\t}\n\n\tif (strlen(backup_options.wal_method) && strcmp(backup_options.wal_method, \"stream\") != 0)\n\t\twal_method_stream = false;\n\n\t{\n\t\tchar\t   *levels_pre96[] = {\n\t\t\t\"hot_standby\",\n\t\t\t\"logical\",\n\t\t\tNULL,\n\t\t};\n\n\t\t/*\n\t\t * Note that in 9.6+, \"hot_standby\" and \"archive\" are accepted as\n\t\t * aliases for \"replica\", but current_setting() will of course always\n\t\t * return \"replica\"\n\t\t */\n\t\tchar\t   *levels_96plus[] = {\n\t\t\t\"replica\",\n\t\t\t\"logical\",\n\t\t\tNULL,\n\t\t};\n\n\t\tchar\t  **levels;\n\t\tint\t\t\tj = 0;\n\n\t\tif (server_version_num < 90600)\n\t\t{\n\t\t\tlevels = (char **) levels_pre96;\n\t\t\twal_error_message = _(\"parameter \\\"wal_level\\\" must be set to \\\"hot_standby\\\" or \\\"logical\\\"\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlevels = (char **) levels_96plus;\n\t\t\twal_error_message = _(\"parameter \\\"wal_level\\\" must be set to \\\"replica\\\" or \\\"logical\\\"\");\n\t\t}\n\n\t\tdo\n\t\t{\n\t\t\ti = guc_set(conn, \"wal_level\", \"=\", levels[j]);\n\t\t\tif (i)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t} while (levels[j] != NULL);\n\t}\n\n\tif (i == 0 || i == -1)\n\t{\n\t\tif (i == 0)\n\t\t{\n\t\t\tlog_error(\"%s\", wal_error_message);\n\t\t}\n\n\t\tif (exit_on_error == true)\n\t\t{\n\t\t\tPQfinish(conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tconfig_ok = false;\n\t}\n\n\tif (config_file_options.use_replication_slots == true)\n\t{\n\t\tpg_setting_ok = get_pg_setting_int(conn, \"max_replication_slots\", &i);\n\n\t\tif (pg_setting_ok == false || i < 1)\n\t\t{\n\t\t\tif (pg_setting_ok == true)\n\t\t\t{\n\t\t\t\tlog_error(_(\"parameter \\\"max_replication_slots\\\" must be set to at least 1 to enable replication slots\"));\n\t\t\t\tlog_detail(_(\"current value is %i\"), i);\n\t\t\t\tlog_hint(_(\"\\\"max_replication_slots\\\" should be set to at least the number of expected standbys\"));\n\t\t\t\tif (exit_on_error == true)\n\t\t\t\t{\n\t\t\t\t\tPQfinish(conn);\n\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t}\n\n\t\t\t\tconfig_ok = false;\n\t\t\t}\n\t\t}\n\n\t\tif (pg_setting_ok == true && i > 0 && runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(_(\"parameter \\\"max_replication_slots\\\" set to %i\"), i);\n\t\t}\n\t}\n\t/*\n\t * physical replication slots not available or not requested - check if\n\t * there are any circumstances where \"wal_keep_segments\" should be set\n\t */\n\telse if (mode != barman)\n\t{\n\t\tbool\t\tcheck_wal_keep_segments = false;\n\n\t\t/*\n\t\t * A non-zero \"wal_keep_segments\" value will almost certainly be\n\t\t * required if pg_basebackup is being used with --xlog-method=fetch,\n\t\t * *and* no restore command has been specified\n\t\t */\n\t\tif (wal_method_stream == false\n\t\t\t&& strcmp(config_file_options.restore_command, \"\") == 0)\n\t\t{\n\t\t\tcheck_wal_keep_segments = true;\n\t\t}\n\n\t\tif (check_wal_keep_segments == true)\n\t\t{\n\t\t\tconst char *wal_keep_parameter_name = \"wal_keep_size\";\n\n\t\t\tif (PQserverVersion(conn) < 130000)\n\t\t\t\twal_keep_parameter_name = \"wal_keep_segments\";\n\n\t\t\tpg_setting_ok = get_pg_setting_int(conn, wal_keep_parameter_name, &i);\n\n\t\t\tif (pg_setting_ok == false || i < 1)\n\t\t\t{\n\t\t\t\tif (pg_setting_ok == true)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"parameter \\\"%s\\\" on the upstream server must be be set to a non-zero value\"),\n\t\t\t\t\t\t\t  wal_keep_parameter_name);\n\t\t\t\t\tlog_hint(_(\"Choose a value sufficiently high enough to retain enough WAL \"\n\t\t\t\t\t\t\t   \"until the standby has been cloned and started.\\n \"\n\t\t\t\t\t\t\t   \"Alternatively set up WAL archiving using e.g. PgBarman and configure \"\n\t\t\t\t\t\t\t   \"'restore_command' in repmgr.conf to fetch WALs from there.\"));\n\t\t\t\t\tlog_hint(_(\"In PostgreSQL 9.4 and later, replication slots can be used, which \"\n\t\t\t\t\t\t\t   \"do not require \\\"%s\\\" to be set \"\n\t\t\t\t\t\t\t   \"(set parameter \\\"use_replication_slots\\\" in repmgr.conf to enable)\\n\"),\n\t\t\t\t\t\t\t wal_keep_parameter_name);\n\t\t\t\t}\n\n\t\t\t\tif (exit_on_error == true)\n\t\t\t\t{\n\t\t\t\t\tPQfinish(conn);\n\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t}\n\n\t\t\t\tconfig_ok = false;\n\t\t\t}\n\n\t\t\tif (pg_setting_ok == true && i > 0 && runtime_options.dry_run == true)\n\t\t\t{\n\t\t\t\tlog_info(_(\"parameter \\\"%s\\\" set to %i\"),\n\t\t\t\t\t\t   wal_keep_parameter_name,\n\t\t\t\t\t\t   i);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (config_file_options.use_replication_slots == false)\n\t{\n\t\tlog_info(_(\"replication slot usage not requested;  no replication slot will be set up for this standby\"));\n\t}\n\n\n\t/*\n\t * If archive_mode is enabled, check that 'archive_command' is non empty\n\t * (however it's not practical to check that it actually represents a\n\t * valid command).\n\t *\n\t * From PostgreSQL 9.5, archive_mode can be one of 'off', 'on' or 'always'\n\t * so for ease of backwards compatibility, rather than explicitly check\n\t * for an enabled mode, check that it's not \"off\".\n\t */\n\n\tif (guc_set(conn, \"archive_mode\", \"!=\", \"off\"))\n\t{\n\t\ti = guc_set(conn, \"archive_command\", \"!=\", \"\");\n\n\t\tif (i == 0 || i == -1)\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t\tlog_error(_(\"parameter \\\"archive_command\\\" must be set to a valid command\"));\n\n\t\t\tif (exit_on_error == true)\n\t\t\t{\n\t\t\t\tPQfinish(conn);\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\n\t\t\tconfig_ok = false;\n\t\t}\n\t}\n\n\n\t/*\n\t * Check that 'hot_standby' is on. This isn't strictly necessary for the\n\t * primary server, however the assumption is that we'll be cloning\n\t * standbys and thus copying the primary configuration; this way the\n\t * standby will be correctly configured by default.\n\t */\n\n\ti = guc_set(conn, \"hot_standby\", \"=\", \"on\");\n\tif (i == 0 || i == -1)\n\t{\n\t\tif (i == 0)\n\t\t{\n\t\t\tlog_error(_(\"parameter \\\"hot_standby\\\" must be set to \\\"on\\\"\"));\n\t\t}\n\n\t\tif (exit_on_error == true)\n\t\t{\n\t\t\tPQfinish(conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tconfig_ok = false;\n\t}\n\n\tpg_setting_ok = get_pg_setting_int(conn, \"max_wal_senders\", &i);\n\n\tif (pg_setting_ok == false || i < 1)\n\t{\n\t\tif (pg_setting_ok == true)\n\t\t{\n\t\t\tlog_error(_(\"parameter \\\"max_wal_senders\\\" must be set to be at least %i\"), i);\n\t\t\tlog_hint(_(\"\\\"max_wal_senders\\\" should be set to at least the number of expected standbys\"));\n\t\t}\n\n\t\tif (exit_on_error == true)\n\t\t{\n\t\t\tPQfinish(conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tconfig_ok = false;\n\t}\n\telse if (pg_setting_ok == true && i > 0 && runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"parameter \\\"max_wal_senders\\\" set to %i\"), i);\n\t}\n\n\t/*\n\t * If using pg_basebackup, ensure sufficient replication connections can\n\t * be made. There's no guarantee they'll still be available by the time\n\t * pg_basebackup is executed, but there's nothing we can do about that.\n\t * This check is mainly intended to warn about missing replication permissions\n\t * and/or lack of available walsenders.\n\t */\n\tif (mode == pg_basebackup)\n\t{\n\n\t\tPGconn\t\t**connections;\n\t\tint\t\tavailable_wal_senders;\n\t\tint\t\tmin_replication_connections\t\t\t= 1;\n\t\tint\t\tpossible_replication_connections\t= 0;\n\t\ti\t\t\t\t\t\t\t\t\t\t\t= 0;\n\t\tt_conninfo_param_list repl_conninfo\t\t\t= T_CONNINFO_PARAM_LIST_INITIALIZER;\n\n\n\t\t/*\n\t\t * work out how many replication connections are required (1 or 2)\n\t\t */\n\n\t\tif (wal_method_stream == true)\n\t\t\tmin_replication_connections += 1;\n\n\t\tlog_notice(_(\"checking for available walsenders on the source node (%i required)\"),\n\t\t\t\t   min_replication_connections);\n\n\t\t/*\n\t\t * check how many free walsenders are available\n\t\t */\n\t\tget_node_replication_stats(conn, upstream_node_record);\n\n\t\tavailable_wal_senders = upstream_node_record->max_wal_senders -\n\t\t\tupstream_node_record->attached_wal_receivers;\n\n\t\tif (available_wal_senders < min_replication_connections)\n\t\t{\n\t\t\tlog_error(_(\"insufficient free walsenders on the source node\"));\n\t\t\tlog_detail(_(\"%i free walsenders required, %i free walsenders available\"),\n\t\t\t\t\t   min_replication_connections,\n\t\t\t\t\t   available_wal_senders);\n\t\t\tlog_hint(_(\"increase \\\"max_wal_senders\\\" on the source node by at least %i\"),\n\t\t\t\t\t (upstream_node_record->attached_wal_receivers + min_replication_connections) - upstream_node_record->max_wal_senders);\n\n\t\t\tif (exit_on_error == true)\n\t\t\t{\n\t\t\t\tPQfinish(conn);\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\t\t}\n\t\telse if (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(_(\"sufficient walsenders available on the source node\"));\n\t\t\tlog_detail(_(\"%i required, %i available\"),\n\t\t\t\t\t   min_replication_connections,\n\t\t\t\t\t   available_wal_senders);\n\t\t}\n\n\n\t\t/*\n\t\t * Sufficient free walsenders appear to be available, check if\n\t\t * we can connect to them. We check that the required number\n\t\t * of connections can be made e.g. to rule out a very restrictive\n\t\t * \"CONNECTION LIMIT\" setting.\n\t\t */\n\n\t\tlog_notice(_(\"checking replication connections can be made to the source server (%i required)\"),\n\t\t\t\t   min_replication_connections);\n\n\t\t/*\n\t\t * Make a copy of the connection parameter arrays, and append\n\t\t * \"replication\".\n\t\t */\n\t\tinitialize_conninfo_params(&repl_conninfo, false);\n\n\t\tconn_to_param_list(conn, &repl_conninfo);\n\n\t\tparam_set(&repl_conninfo, \"replication\", \"1\");\n\n\t\tif (runtime_options.replication_user[0] != '\\0')\n\t\t{\n\t\t\tparam_set(&repl_conninfo, \"user\", runtime_options.replication_user);\n\t\t}\n\t\telse if (upstream_repluser[0] != '\\0')\n\t\t{\n\t\t\tparam_set(&repl_conninfo, \"user\", upstream_repluser);\n\t\t}\n\t\telse if (upstream_node_record->repluser[0] != '\\0')\n\t\t{\n\t\t\tparam_set(&repl_conninfo, \"user\", upstream_node_record->repluser);\n\t\t}\n\n\t\tif (strcmp(param_get(&repl_conninfo, \"user\"), upstream_user) != 0)\n\t\t{\n\t\t\tparam_set(&repl_conninfo, \"dbname\", \"replication\");\n\t\t}\n\n\t\tconnections = pg_malloc0(sizeof(PGconn *) * min_replication_connections);\n\n\t\t/*\n\t\t * Attempt to create the minimum number of required concurrent\n\t\t * connections\n\t\t */\n\t\tfor (i = 0; i < min_replication_connections; i++)\n\t\t{\n\t\t\tPGconn\t   *replication_conn;\n\n\t\t\treplication_conn = establish_db_connection_by_params(&repl_conninfo, false);\n\n\t\t\tif (PQstatus(replication_conn) == CONNECTION_OK)\n\t\t\t{\n\t\t\t\tconnections[i] = replication_conn;\n\t\t\t\tpossible_replication_connections++;\n\t\t\t}\n\t\t}\n\n\t\t/* Close previously created connections */\n\t\tfor (i = 0; i < possible_replication_connections; i++)\n\t\t{\n\t\t\tPQfinish(connections[i]);\n\t\t}\n\n\t\tpfree(connections);\n\t\tfree_conninfo_params(&repl_conninfo);\n\n\t\tif (possible_replication_connections < min_replication_connections)\n\t\t{\n\t\t\tconfig_ok = false;\n\n\t\t\tlog_error(_(\"unable to establish necessary replication connections\"));\n\t\t\tlog_hint(_(\"check replication permissions on the source server\"));\n\n\t\t\tif (exit_on_error == true)\n\t\t\t{\n\t\t\t\tPQfinish(conn);\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\t\t}\n\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(_(\"required number of replication connections could be made to the source server\"));\n\t\t\tlog_detail(_(\"%i replication connections required\"),\n\t\t\t\t\t   min_replication_connections);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_verbose(LOG_INFO, _(\"sufficient replication connections could be made to the source server (%i required)\"),\n\t\t\t\t\t\tmin_replication_connections);\n\t\t}\n\t}\n\n\t/*\n\t * Finally, add some checks for recommended settings\n\t */\n\n\t{\n\t\tbool data_checksums = false;\n\t\tbool wal_log_hints = false;\n\n\t\t/* data_checksums available from PostgreSQL 9.3; can be read by any user */\n\t\tif (get_pg_setting_bool(conn, \"data_checksums\", &data_checksums) == false)\n\t\t{\n\t\t\t/* highly unlikely this will happen */\n\t\t\tlog_error(_(\"unable to determine value for \\\"data_checksums\\\"\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\t/* wal_log_hints available from PostgreSQL 9.4; can be read by any user */\n\t\tif (get_pg_setting_bool(conn, \"wal_log_hints\", &wal_log_hints) == false)\n\t\t{\n\t\t\t/* highly unlikely this will happen */\n\t\t\tlog_error(_(\"unable to determine value for \\\"wal_log_hints\\\"\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tif (data_checksums == false && wal_log_hints == false)\n\t\t{\n\t\t\tlog_warning(_(\"data checksums are not enabled and \\\"wal_log_hints\\\" is \\\"off\\\"\"));\n\t\t\tlog_detail(_(\"pg_rewind requires \\\"wal_log_hints\\\" to be enabled\"));\n\t\t}\n\t}\n\n\treturn config_ok;\n}\n\n\n/*\n * initialise_direct_clone()\n *\n * In pg_basebackup mode, configure the target data directory\n * if necessary, and fetch information about tablespaces and configuration\n * files.\n *\n * Event(s):\n * - standby_clone\n */\nstatic void\ninitialise_direct_clone(t_node_info *local_node_record, t_node_info *upstream_node_record)\n{\n\t/*\n\t * Check the destination data directory can be used (in Barman mode, this\n\t * directory will already have been created)\n\t */\n\n\tif (!create_pg_dir(local_data_directory, runtime_options.force))\n\t{\n\t\tlog_error(_(\"unable to use directory \\\"%s\\\"\"),\n\t\t\t\t  local_data_directory);\n\t\tlog_hint(_(\"use -F/--force to force this directory to be overwritten\"));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * Check that tablespaces named in any `tablespace_mapping` configuration\n\t * file parameters exist.\n\t *\n\t * pg_basebackup doesn't verify mappings, so any errors will not be\n\t * caught. We'll do that here as a value-added service.\n\t *\n\t */\n\n\tif (config_file_options.tablespace_mapping.head != NULL)\n\t{\n\t\tTablespaceListCell *cell;\n\t\tKeyValueList not_found = {NULL, NULL};\n\t\tint\t\t\ttotal = 0,\n\t\t\t\t\tmatched = 0;\n\t\tbool\t\tsuccess = false;\n\n\t\tfor (cell = config_file_options.tablespace_mapping.head; cell; cell = cell->next)\n\t\t{\n\t\t\tchar\t   *old_dir_escaped = escape_string(source_conn, cell->old_dir);\n\t\t\tchar\t\tname[MAXLEN] = \"\";\n\n\t\t\tsuccess = get_tablespace_name_by_location(source_conn, old_dir_escaped, name);\n\t\t\tpfree(old_dir_escaped);\n\n\t\t\tif (success == true)\n\t\t\t{\n\t\t\t\tmatched++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tkey_value_list_set(&not_found,\n\t\t\t\t\t\t\t\t   cell->old_dir,\n\t\t\t\t\t\t\t\t   \"\");\n\t\t\t}\n\n\t\t\ttotal++;\n\t\t}\n\n\t\tif (not_found.head != NULL)\n\t\t{\n\t\t\tPQExpBufferData detail;\n\t\t\tKeyValueListCell *kv_cell;\n\n\t\t\tlog_error(_(\"%i of %i mapped tablespaces not found\"),\n\t\t\t\t\t  total - matched, total);\n\n\t\t\tinitPQExpBuffer(&detail);\n\n\t\t\tfor (kv_cell = not_found.head; kv_cell; kv_cell = kv_cell->next)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(\n\t\t\t\t\t&detail,\n\t\t\t\t\t\"  %s\\n\", kv_cell->key);\n\t\t\t}\n\n\t\t\tlog_detail(_(\"following tablespaces not found:\\n%s\"),\n\t\t\t\t\t   detail.data);\n\t\t\ttermPQExpBuffer(&detail);\n\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\n\t/*\n\t * If replication slots requested, create appropriate slot on the source\n\t * node; this must be done before pg_basebackup is called.\n\t *\n\t * Note: if the source node is different to the specified upstream node,\n\t * we'll need to drop the slot and recreate it on the upstream.\n\t *\n\t * TODO: skip this for Pg10, and ensure temp slot option used\n\t *\n\t * Replication slots are not supported (and not very useful anyway) in\n\t * Barman mode.\n\t */\n\n\tif (config_file_options.use_replication_slots == true)\n\t{\n\t\tPQExpBufferData event_details;\n\n\t\tinitPQExpBuffer(&event_details);\n\n\t\tif (create_replication_slot(source_conn, local_node_record->slot_name, upstream_node_record, &event_details) == false)\n\t\t{\n\t\t\tlog_error(\"%s\", event_details.data);\n\n\t\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t  \"standby_clone\",\n\t\t\t\t\t\t\t\t\t  false,\n\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\tPQfinish(source_conn);\n\n\t\t\texit(ERR_DB_QUERY);\n\t\t}\n\n\t\ttermPQExpBuffer(&event_details);\n\n\t\tlog_verbose(LOG_INFO,\n\t\t\t\t\t_(\"replication slot \\\"%s\\\" created on source node\"),\n\t\t\t\t\tlocal_node_record->slot_name);\n\t}\n\n\treturn;\n}\n\n\nstatic int\nrun_basebackup(t_node_info *node_record)\n{\n\tPQExpBufferData params;\n\tPQExpBufferData script;\n\n\tint\t\t\tr = SUCCESS;\n\n\tTablespaceListCell *cell = NULL;\n\tt_basebackup_options backup_options = T_BASEBACKUP_OPTIONS_INITIALIZER;\n\n\t/*\n\t * Parse the pg_basebackup_options provided in repmgr.conf - we'll want to\n\t * check later whether certain options were set by the user\n\t */\n\tparse_pg_basebackup_options(config_file_options.pg_basebackup_options,\n\t\t\t\t\t\t\t\t&backup_options,\n\t\t\t\t\t\t\t\tsource_server_version_num,\n\t\t\t\t\t\t\t\tNULL);\n\n\t/* Create pg_basebackup command line options */\n\n\tinitPQExpBuffer(&params);\n\n\tappendPQExpBuffer(&params, \" -D %s\", local_data_directory);\n\n\t/*\n\t * conninfo string provided - pass it to pg_basebackup as the -d option\n\t * (pg_basebackup doesn't require or want a database name, but for\n\t * consistency with other applications accepts a conninfo string under\n\t * -d/--dbname)\n\t */\n\tif (runtime_options.conninfo_provided == true)\n\t{\n\t\tt_conninfo_param_list conninfo = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\t\tchar\t   *conninfo_str = NULL;\n\n\t\tinitialize_conninfo_params(&conninfo, false);\n\n\t\t/* string will already have been parsed */\n\t\t(void) parse_conninfo_string(runtime_options.dbname, &conninfo, NULL, false);\n\n\t\tif (runtime_options.replication_user[0] != '\\0')\n\t\t{\n\t\t\tparam_set(&conninfo, \"user\", runtime_options.replication_user);\n\t\t}\n\t\telse if (upstream_repluser[0] != '\\0')\n\t\t{\n\t\t\tparam_set(&conninfo, \"user\", upstream_repluser);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparam_set(&conninfo, \"user\", node_record->repluser);\n\t\t}\n\n\t\tconninfo_str = param_list_to_string(&conninfo);\n\n\t\tappendPQExpBuffer(&params, \" -d '%s'\", conninfo_str);\n\n\t\tpfree(conninfo_str);\n\t}\n\n\t/*\n\t * Connection parameters not passed to repmgr as conninfo string - provide\n\t * them individually to pg_basebackup (-d/--dbname not required)\n\t */\n\telse\n\t{\n\t\tif (strlen(runtime_options.host))\n\t\t{\n\t\t\tappendPQExpBuffer(&params, \" -h %s\", runtime_options.host);\n\t\t}\n\n\t\tif (strlen(runtime_options.port))\n\t\t{\n\t\t\tappendPQExpBuffer(&params, \" -p %s\", runtime_options.port);\n\t\t}\n\n\t\tif (strlen(runtime_options.replication_user))\n\t\t{\n\t\t\tappendPQExpBuffer(&params, \" -U %s\", runtime_options.replication_user);\n\t\t}\n\t\telse if (strlen(upstream_repluser))\n\t\t{\n\t\t\tappendPQExpBuffer(&params, \" -U %s\", upstream_repluser);\n\t\t}\n\t\telse if (strlen(node_record->repluser))\n\t\t{\n\t\t\tappendPQExpBuffer(&params, \" -U %s\", node_record->repluser);\n\t\t}\n\t\telse if (strlen(runtime_options.username))\n\t\t{\n\t\t\tappendPQExpBuffer(&params, \" -U %s\", runtime_options.username);\n\t\t}\n\n\t}\n\n\tif (runtime_options.fast_checkpoint)\n\t{\n\t\tappendPQExpBufferStr(&params, \" -c fast\");\n\t}\n\n\tif (config_file_options.tablespace_mapping.head != NULL)\n\t{\n\t\tfor (cell = config_file_options.tablespace_mapping.head; cell; cell = cell->next)\n\t\t{\n\t\t\tappendPQExpBuffer(&params, \" -T %s=%s\", cell->old_dir, cell->new_dir);\n\t\t}\n\t}\n\n\t/*\n\t * To ensure we have all the WALs needed during basebackup execution we\n\t * stream them as the backup is taking place.\n\t *\n\t * From 9.6, if replication slots are in use, we'll have previously\n\t * created a slot with reserved LSN, and will stream from that slot to\n\t * avoid WAL buildup on the primary using the -S/--slot, which requires\n\t * -X/--xlog-method=stream (from 10, -X/--wal-method=stream)\n\t */\n\tif (!strlen(backup_options.wal_method))\n\t{\n\t\tappendPQExpBufferStr(&params, \" -X stream\");\n\t}\n\n\t/*\n\t * From 9.6, pg_basebackup accepts -S/--slot, which forces WAL streaming\n\t * to use the specified replication slot. If replication slot usage is\n\t * specified, the slot will already have been created.\n\t *\n\t * NOTE: currently there's no way of disabling the --slot option while\n\t * using --xlog-method=stream - it's hard to imagine a use case for this,\n\t * so no provision has been made for doing it.\n\t *\n\t * NOTE: It's possible to set 'pg_basebackup_options' with an invalid\n\t * combination of values for --wal-method (--xlog-method) and --slot -\n\t * we're not checking that, just that we're not overriding any\n\t * user-supplied values\n\t */\n\tif (source_server_version_num >= 90600 && config_file_options.use_replication_slots)\n\t{\n\t\tbool\t\tslot_add = true;\n\n\t\t/*\n\t\t * Check whether 'pg_basebackup_options' in repmgr.conf has the --slot\n\t\t * option set, or if --wal-method (--xlog-method) is set to a value\n\t\t * other than \"stream\" (in which case we can't use --slot).\n\t\t */\n\t\tif (strlen(backup_options.slot) || (strlen(backup_options.wal_method) && strcmp(backup_options.wal_method, \"stream\") != 0))\n\t\t{\n\t\t\tslot_add = false;\n\t\t}\n\n\t\tif (slot_add == true)\n\t\t{\n\t\t\tappendPQExpBuffer(&params, \" -S %s\", node_record->slot_name);\n\t\t}\n\t}\n\n\tinitPQExpBuffer(&script);\n\tmake_pg_path(&script, \"pg_basebackup\");\n\n\tappendPQExpBuffer(&script,\n\t\t\t\t\t  \" -l \\\"repmgr base backup\\\" %s %s\",\n\t\t\t\t\t  params.data,\n\t\t\t\t\t  config_file_options.pg_basebackup_options);\n\n\ttermPQExpBuffer(&params);\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"would execute:\\n  %s\"), script.data);\n\t\ttermPQExpBuffer(&script);\n\t\treturn SUCCESS;\n\t}\n\n\tlog_info(_(\"executing:\\n  %s\"), script.data);\n\n\t/*\n\t * As of 9.4, pg_basebackup only ever returns 0 or 1\n\t */\n\n\tr = system(script.data);\n\n\ttermPQExpBuffer(&script);\n\n\tif (r != 0)\n\t\treturn ERR_BAD_BASEBACKUP;\n\n\t/* check connections are still available */\n\t(void)connection_ping_reconnect(primary_conn);\n\n\tif (source_conn != primary_conn)\n\t\t(void)connection_ping_reconnect(source_conn);\n\n\t/*\n\t * If replication slots in use, check the created slot is on the correct\n\t * node; the slot will initially get created on the source node, and will\n\t * need to be dropped and recreated on the actual upstream node if these\n\t * differ.\n\t */\n\tif (config_file_options.use_replication_slots && upstream_node_id != UNKNOWN_NODE_ID)\n\t{\n\t\tt_node_info upstream_node_record = T_NODE_INFO_INITIALIZER;\n\t\tt_replication_slot slot_info = T_REPLICATION_SLOT_INITIALIZER;\n\t\tRecordStatus record_status = RECORD_NOT_FOUND;\n\t\tbool slot_exists_on_upstream = false;\n\n\t\trecord_status = get_node_record(source_conn, upstream_node_id, &upstream_node_record);\n\n\t\t/*\n\t\t * If there's no upstream record, there's no point in trying to create\n\t\t * a replication slot on the designated upstream, as the assumption is\n\t\t * it won't exist at this point.\n\t\t */\n\t\tif (record_status != RECORD_FOUND)\n\t\t{\n\t\t\tlog_warning(_(\"no record exists for designated upstream node %i\"),\n\t\t\t\t\t\tupstream_node_id);\n\t\t\tlog_hint(_(\"you'll need to create the replication slot (\\\"%s\\\") manually\"),\n\t\t\t\t\t node_record->slot_name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPGconn\t   *upstream_conn = NULL;\n\n\t\t\tupstream_conn = establish_db_connection(upstream_node_record.conninfo, false);\n\n\t\t\t/*\n\t\t\t * It's possible the upstream node is not yet running, in which case we'll\n\t\t\t * have to rely on the user taking action to create the slot\n\t\t\t */\n\t\t\tif (PQstatus(upstream_conn) != CONNECTION_OK)\n\t\t\t{\n\t\t\t\tlog_warning(_(\"unable to connect to upstream node to create replication slot\"));\n\t\t\t\t/*\n\t\t\t\t * TODO: if slot creation also handled by \"standby register\", update warning\n\t\t\t\t */\n\t\t\t\tlog_hint(_(\"you may need to create the replication slot manually\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trecord_status = get_slot_record(upstream_conn, node_record->slot_name, &slot_info);\n\n\t\t\t\tif (record_status == RECORD_FOUND)\n\t\t\t\t{\n\t\t\t\t\tlog_verbose(LOG_INFO,\n\t\t\t\t\t\t\t\t_(\"replication slot \\\"%s\\\" already exists on upstream node %i\"),\n\t\t\t\t\t\t\t\tnode_record->slot_name,\n\t\t\t\t\t\t\t\tupstream_node_id);\n\t\t\t\t\tslot_exists_on_upstream = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tPQExpBufferData event_details;\n\n\t\t\t\t\tlog_notice(_(\"creating replication slot \\\"%s\\\" on upstream node %i\"),\n\t\t\t\t\t\t\t   node_record->slot_name,\n\t\t\t\t\t\t\t   upstream_node_id);\n\n\t\t\t\t\tinitPQExpBuffer(&event_details);\n\t\t\t\t\tif (create_replication_slot(upstream_conn, node_record->slot_name, &upstream_node_record, &event_details) == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_error(\"%s\", event_details.data);\n\n\t\t\t\t\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"standby_clone\",\n\t\t\t\t\t\t\t\t\t\t\t\t  false,\n\t\t\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\t\t\t\tPQfinish(source_conn);\n\n\t\t\t\t\t\texit(ERR_DB_QUERY);\n\t\t\t\t\t}\n\n\t\t\t\t\ttermPQExpBuffer(&event_details);\n\t\t\t\t}\n\n\t\t\t\tPQfinish(upstream_conn);\n\t\t\t}\n\t\t}\n\n\t\tif (slot_info.active == false)\n\t\t{\n\t\t\tif (slot_exists_on_upstream == false)\n\t\t\t{\n\n\t\t\t\t/* delete slot on source server */\n\n\t\t\t\tif (drop_replication_slot_if_exists(source_conn, UNKNOWN_NODE_ID, node_record->slot_name) == true)\n\t\t\t\t{\n\t\t\t\t\tlog_notice(_(\"replication slot \\\"%s\\\" deleted on source node\"),\n\t\t\t\t\t\t\t   node_record->slot_name);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to delete replication slot \\\"%s\\\" on source node\"),\n\t\t\t\t\t\t\t  node_record->slot_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * if replication slot is still active (shouldn't happen), emit a\n\t\t * warning\n\t\t */\n\t\telse\n\t\t{\n\t\t\tlog_warning(_(\"replication slot \\\"%s\\\" is still active on source node\"),\n\t\t\t\t\t\tnode_record->slot_name);\n\t\t}\n\t}\n\n\treturn SUCCESS;\n}\n\n\n/*\n * Perform a filesystem backup using rsync.\n *\n * From repmgr 4 this is only used for Barman backups.\n */\nstatic int\nrun_file_backup(t_node_info *local_node_record)\n{\n\tint\t\t\tr = SUCCESS,\n\t\t\t\ti;\n\n\tchar\t\tcommand[MAXLEN] = \"\";\n\tchar\t\tfilename[MAXLEN] = \"\";\n\tchar\t\tbuf[MAXLEN] = \"\";\n\tchar\t\tbasebackups_directory[MAXLEN] = \"\";\n\tchar\t\tbackup_id[MAXLEN] = \"\";\n\tTablespaceDataList tablespace_list = {NULL, NULL};\n\tTablespaceDataListCell *cell_t = NULL;\n\n\tPQExpBufferData tablespace_map;\n\tbool\t\ttablespace_map_rewrite = false;\n\n\t/* For the foreseeable future, no other modes are supported */\n\tAssert(mode == barman);\n\tif (mode == barman)\n\t{\n\t\tt_basebackup_options backup_options = T_BASEBACKUP_OPTIONS_INITIALIZER;\n\n\t\t/*\n\t\t * Locate Barman's base backups directory\n\t\t */\n\n\t\tget_barman_property(basebackups_directory, \"basebackups_directory\", local_repmgr_tmp_directory);\n\n\t\t/*\n\t\t * Read the list of backup files into a local file. In the process:\n\t\t *\n\t\t * - determine the backup ID\n\t\t * - check, and remove, the prefix\n\t\t * - detect tablespaces\n\t\t * - filter files in one list per tablespace\n\t\t */\n\t\t{\n\t\t\tFILE\t   *fi;\t\t/* input stream */\n\t\t\tFILE\t   *fd;\t\t/* output for data.txt */\n\t\t\tchar\t\tprefix[MAXLEN] = \"\";\n\t\t\tchar\t\toutput[MAXLEN] = \"\";\n\t\t\tint\t\t\tn = 0;\n\t\t\tchar\t   *p = NULL,\n\t\t\t\t\t   *q = NULL;\n\n\t\t\tmaxlen_snprintf(command, \"%s list-files --target=data %s latest\",\n\t\t\t\t\t\t\tmake_barman_ssh_command(barman_command_buf),\n\t\t\t\t\t\t\tconfig_file_options.barman_server);\n\n\t\t\tlog_verbose(LOG_DEBUG, \"executing:\\n  %s\", command);\n\n\t\t\tfi = popen(command, \"r\");\n\t\t\tif (fi == NULL)\n\t\t\t{\n\t\t\t\tlog_error(\"cannot launch command: %s\", command);\n\t\t\t\texit(ERR_BARMAN);\n\t\t\t}\n\n\t\t\tfd = fopen(datadir_list_filename, \"w\");\n\t\t\tif (fd == NULL)\n\t\t\t{\n\t\t\t\tlog_error(\"cannot open file: %s\", datadir_list_filename);\n\t\t\t\texit(ERR_BARMAN);\n\t\t\t}\n\n\t\t\tmaxlen_snprintf(prefix, \"%s/\", basebackups_directory);\n\n\t\t\twhile (fgets(output, MAXLEN, fi) != NULL)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Remove prefix\n\t\t\t\t */\n\t\t\t\tp = string_skip_prefix(prefix, output);\n\n\t\t\t\tif (p == NULL)\n\t\t\t\t{\n\t\t\t\t\tlog_error(\"unexpected output from \\\"barman list-files\\\"\");\n\t\t\t\t\tlog_detail(\"%s\", output);\n\t\t\t\t\texit(ERR_BARMAN);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Remove and note backup ID; copy backup.info\n\t\t\t\t */\n\t\t\t\tif (!strcmp(backup_id, \"\"))\n\t\t\t\t{\n\t\t\t\t\tFILE\t   *fi2;\n\n\t\t\t\t\tn = strcspn(p, \"/\");\n\n\t\t\t\t\tstrncpy(backup_id, p, n);\n\n\t\t\t\t\tstrncat(prefix, backup_id, MAXLEN - 1);\n\t\t\t\t\tstrncat(prefix, \"/\", MAXLEN - 1);\n\t\t\t\t\tp = string_skip_prefix(backup_id, p);\n\n\t\t\t\t\tif (p == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_error(\"unexpected output from \\\"barman list-files\\\"\");\n\t\t\t\t\t\tlog_detail(\"%s\", output);\n\t\t\t\t\t\texit(ERR_BARMAN);\n\t\t\t\t\t}\n\n\t\t\t\t\tp = string_skip_prefix(\"/\", p);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Copy backup.info\n\t\t\t\t\t */\n\t\t\t\t\tmaxlen_snprintf(command,\n\t\t\t\t\t\t\t\t\t\"rsync -a %s:%s/%s/backup.info %s\",\n\t\t\t\t\t\t\t\t\tconfig_file_options.barman_host,\n\t\t\t\t\t\t\t\t\tbasebackups_directory,\n\t\t\t\t\t\t\t\t\tbackup_id,\n\t\t\t\t\t\t\t\t\tlocal_repmgr_tmp_directory);\n\n\t\t\t\t\t(void) local_command(command,\n\t\t\t\t\t\t\t\t\t\t NULL);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Get tablespace data\n\t\t\t\t\t */\n\t\t\t\t\tmaxlen_snprintf(filename, \"%s/backup.info\",\n\t\t\t\t\t\t\t\t\tlocal_repmgr_tmp_directory);\n\t\t\t\t\tfi2 = fopen(filename, \"r\");\n\t\t\t\t\tif (fi2 == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_error(\"cannot open file: %s\", filename);\n\t\t\t\t\t\texit(ERR_INTERNAL);\n\t\t\t\t\t}\n\t\t\t\t\twhile (fgets(buf, MAXLEN, fi2) != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tq = string_skip_prefix(\"tablespaces=\", buf);\n\t\t\t\t\t\tif (q != NULL && strncmp(q, \"None\\n\", 5))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tget_tablespace_data_barman(q, &tablespace_list);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq = string_skip_prefix(\"version=\", buf);\n\t\t\t\t\t\tif (q != NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsource_server_version_num = strtol(q, NULL, 10);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfclose(fi2);\n\t\t\t\t\tunlink(filename);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Skip backup.info\n\t\t\t\t */\n\t\t\t\tif (string_skip_prefix(\"backup.info\", p))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/*\n\t\t\t\t * Filter data directory files\n\t\t\t\t */\n\t\t\t\tif ((q = string_skip_prefix(\"data/\", p)) != NULL)\n\t\t\t\t{\n\t\t\t\t\tfputs(q, fd);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Filter other files (i.e. tablespaces)\n\t\t\t\t */\n\t\t\t\tfor (cell_t = tablespace_list.head; cell_t; cell_t = cell_t->next)\n\t\t\t\t{\n\t\t\t\t\tif ((q = string_skip_prefix(cell_t->oid, p)) != NULL && *q == '/')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (cell_t->fptr == NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmaxlen_snprintf(filename, \"%s/%s.txt\", local_repmgr_tmp_directory, cell_t->oid);\n\t\t\t\t\t\t\tcell_t->fptr = fopen(filename, \"w\");\n\t\t\t\t\t\t\tif (cell_t->fptr == NULL)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog_error(\"cannot open file: %s\", filename);\n\t\t\t\t\t\t\t\texit(ERR_INTERNAL);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfputs(q + 1, cell_t->fptr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfclose(fd);\n\n\t\t\tpclose(fi);\n\t\t}\n\n\t\t/* For 9.5 and greater, create our own tablespace_map file */\n\t\tif (source_server_version_num >= 90500)\n\t\t{\n\t\t\tinitPQExpBuffer(&tablespace_map);\n\t\t}\n\n\t\t/*\n\t\t * As of Barman version 1.6.1, the file structure of a backup is as\n\t\t * follows:\n\t\t *\n\t\t * base/ - base backup wals/ - WAL files associated to the backup\n\t\t *\n\t\t * base/<ID> - backup files\n\t\t *\n\t\t * here ID has the standard timestamp form yyyymmddThhmmss\n\t\t *\n\t\t * base/<ID>/backup.info - backup metadata, in text format\n\t\t * base/<ID>/data        - data directory base/<ID>/<OID>       -\n\t\t * tablespace with the given oid\n\t\t */\n\n\t\t/*\n\t\t * Copy all backup files from the Barman server\n\t\t */\n\t\tmaxlen_snprintf(command,\n\t\t\t\t\t\t\"rsync --progress -a --files-from=%s %s:%s/%s/data %s\",\n\t\t\t\t\t\tdatadir_list_filename,\n\t\t\t\t\t\tconfig_file_options.barman_host,\n\t\t\t\t\t\tbasebackups_directory,\n\t\t\t\t\t\tbackup_id,\n\t\t\t\t\t\tlocal_data_directory);\n\n\t\t(void) local_command(\n\t\t\t\t\t\t\t command,\n\t\t\t\t\t\t\t NULL);\n\n\t\tunlink(datadir_list_filename);\n\n\t\t/*\n\t\t * At this point we should have the source server version number.\n\t\t * If not, try and extract it from the data directory.\n\t\t */\n\t\tif (source_server_version_num == UNKNOWN_SERVER_VERSION_NUM)\n\t\t{\n\t\t\tlog_warning(_(\"server version number is unknown\"));\n\t\t\tsource_server_version_num = get_pg_version(local_data_directory, NULL);\n\n\t\t\t/*\n\t\t\t * In the unlikely we are still unable to obtain the server\n\t\t\t * version number, there's not a lot which can be done.\n\t\t\t */\n\t\t\tif (source_server_version_num == UNKNOWN_SERVER_VERSION_NUM)\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to extract server version number from the data directory, aborting\"));\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\t\t\tlog_notice(_(\"server version number is: %i\"), source_server_version_num);\n\t\t}\n\n\t\t/*\n\t\t * Parse the pg_basebackup_options provided in repmgr.conf - we need to\n\t\t * check if --waldir/--xlogdir was provided.\n\t\t */\n\t\tparse_pg_basebackup_options(config_file_options.pg_basebackup_options,\n\t\t\t\t\t\t\t\t\t&backup_options,\n\t\t\t\t\t\t\t\t\tsource_server_version_num,\n\t\t\t\t\t\t\t\t\tNULL);\n\n\n\t\t/*\n\t\t * We must create some PGDATA subdirectories because they are not\n\t\t * included in the Barman backup.\n\t\t *\n\t\t * See class RsyncBackupExecutor in the Barman source\n\t\t * (barman/backup_executor.py) for a definitive list of excluded\n\t\t * directories.\n\t\t */\n\t\t{\n\t\t\tconst char *const dirs[] = {\n\t\t\t\t/* Only from 10 */\n\t\t\t\t\"pg_wal\",\n\t\t\t\t/* Only from 9.5 */\n\t\t\t\t\"pg_commit_ts\",\n\t\t\t\t/* Only from 9.4 */\n\t\t\t\t\"pg_dynshmem\", \"pg_logical\", \"pg_logical/snapshots\", \"pg_logical/mappings\", \"pg_replslot\",\n\t\t\t\t/* Present in all versions from  9.3 */\n\t\t\t\t\"pg_notify\", \"pg_serial\", \"pg_snapshots\", \"pg_stat\", \"pg_stat_tmp\",\n\t\t\t\t\"pg_subtrans\", \"pg_tblspc\", \"pg_twophase\",\n\t\t\t\t/* Present from at least 9.3, but removed in 10 */\n\t\t\t\t\"pg_xlog\",\n\t\t\t\t/* Array delimiter */\n\t\t\t\t0\n\t\t\t};\n\n\t\t\t/*\n\t\t\t * This array determines the major version each of the above directories\n\t\t\t * first appears in; or if the value is negative, which from major version\n\t\t\t * the directory does not appear in.\n\t\t\t */\n\t\t\tconst int\tvers[] = {\n\t\t\t\t100000,\n\t\t\t\t90500,\n\t\t\t\t90400, 90400, 90400, 90400, 90400,\n\t\t\t\t0, 0, 0, 0, 0,\n\t\t\t\t0, 0, 0,\n\t\t\t\t-100000\n\t\t\t};\n\n\t\t\tfor (i = 0; dirs[i]; i++)\n\t\t\t{\n\t\t\t\t/* directory exists in newer versions than this server - skip */\n\t\t\t\tif (vers[i] > 0 && source_server_version_num < vers[i])\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/*\n\t\t\t\t * directory existed in earlier versions than this server but\n\t\t\t\t * has been removed/renamed - skip\n\t\t\t\t */\n\t\t\t\tif (vers[i] < 0 && source_server_version_num >= abs(vers[i]))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmaxlen_snprintf(filename, \"%s/%s\", local_data_directory, dirs[i]);\n\n\t\t\t\t/*\n\t\t\t\t * If --waldir/--xlogdir specified in \"pg_basebackup_options\",\n\t\t\t\t * create a symlink rather than make a directory.\n\t\t\t\t */\n\t\t\t\tif (strcmp(dirs[i], \"pg_wal\") == 0 || strcmp(dirs[i], \"pg_xlog\") == 0)\n\t\t\t\t{\n\t\t\t\t\tif (backup_options.waldir[0] != '\\0')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (create_pg_dir(backup_options.waldir, false) == false)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* create_pg_dir() will log specifics */\n\t\t\t\t\t\t\tlog_error(_(\"unable to create an empty directory for WAL files\"));\n\t\t\t\t\t\t\tlog_hint(_(\"see preceding error messages\"));\n\t\t\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (symlink(backup_options.waldir, filename) != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog_error(_(\"could not create symbolic link \\\"%s\\\"\"), filename);\n\t\t\t\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mkdir(filename, S_IRWXU) != 0 && errno != EEXIST)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to create the %s directory\"), dirs[i]);\n\t\t\t\t\texit(ERR_INTERNAL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (cell_t = tablespace_list.head; cell_t; cell_t = cell_t->next)\n\t{\n\t\tbool\t\tmapping_found = false;\n\t\tTablespaceListCell *cell = NULL;\n\t\tchar\t   *tblspc_dir_dest = NULL;\n\n\t\t/*\n\t\t * Check if tablespace path matches one of the provided tablespace\n\t\t * mappings\n\t\t */\n\t\tif (config_file_options.tablespace_mapping.head != NULL)\n\t\t{\n\t\t\tfor (cell = config_file_options.tablespace_mapping.head; cell; cell = cell->next)\n\t\t\t{\n\t\t\t\tif (strcmp(cell_t->location, cell->old_dir) == 0)\n\t\t\t\t{\n\t\t\t\t\tmapping_found = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mapping_found == true)\n\t\t{\n\t\t\ttblspc_dir_dest = cell->new_dir;\n\t\t\tlog_debug(_(\"mapping source tablespace \\\"%s\\\" (OID %s) to \\\"%s\\\"\"),\n\t\t\t\t\t  cell_t->location, cell_t->oid, tblspc_dir_dest);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttblspc_dir_dest = cell_t->location;\n\t\t}\n\n\t\t/*\n\t\t * Tablespace file copy\n\t\t */\n\n\t\tif (mode == barman)\n\t\t{\n\t\t\tcreate_pg_dir(tblspc_dir_dest, false);\n\n\t\t\tif (cell_t->fptr != NULL)\t/* cell_t->fptr == NULL iff the tablespace is\n\t\t\t\t\t\t\t\t\t\t * empty */\n\t\t\t{\n\t\t\t\t/* close the file to ensure the contents are flushed to disk */\n\t\t\t\tfclose(cell_t->fptr);\n\n\t\t\t\tmaxlen_snprintf(command,\n\t\t\t\t\t\t\t\t\"rsync --progress -a --files-from=%s/%s.txt %s:%s/%s/%s %s\",\n\t\t\t\t\t\t\t\tlocal_repmgr_tmp_directory,\n\t\t\t\t\t\t\t\tcell_t->oid,\n\t\t\t\t\t\t\t\tconfig_file_options.barman_host,\n\t\t\t\t\t\t\t\tbasebackups_directory,\n\t\t\t\t\t\t\t\tbackup_id,\n\t\t\t\t\t\t\t\tcell_t->oid,\n\t\t\t\t\t\t\t\ttblspc_dir_dest);\n\t\t\t\t(void) local_command(command,\n\t\t\t\t\t\t\t\t\t NULL);\n\t\t\t\tmaxlen_snprintf(filename,\n\t\t\t\t\t\t\t\t\"%s/%s.txt\",\n\t\t\t\t\t\t\t\tlocal_repmgr_tmp_directory,\n\t\t\t\t\t\t\t\tcell_t->oid);\n\t\t\t\tunlink(filename);\n\t\t\t}\n\t\t}\n\n\n\t\t/*\n\t\t * If a valid mapping was provided for this tablespace, arrange for it\n\t\t * to be remapped (if no tablespace mapping was provided, the link\n\t\t * will be copied as-is by pg_basebackup and no action is required)\n\t\t */\n\t\tif (mapping_found == true || mode == barman)\n\t\t{\n\t\t\t/* 9.5 and later - append to the tablespace_map file */\n\t\t\tif (source_server_version_num >= 90500)\n\t\t\t{\n\t\t\t\ttablespace_map_rewrite = true;\n\t\t\t\tappendPQExpBuffer(&tablespace_map,\n\t\t\t\t\t\t\t\t  \"%s %s\\n\",\n\t\t\t\t\t\t\t\t  cell_t->oid,\n\t\t\t\t\t\t\t\t  tblspc_dir_dest);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Pre-9.5, we have to manipulate the symlinks in pg_tblspc/\n\t\t\t * ourselves\n\t\t\t */\n\t\t\telse\n\t\t\t{\n\t\t\t\tPQExpBufferData tblspc_symlink;\n\n\t\t\t\tinitPQExpBuffer(&tblspc_symlink);\n\t\t\t\tappendPQExpBuffer(&tblspc_symlink, \"%s/pg_tblspc/%s\",\n\t\t\t\t\t\t\t\t  local_data_directory,\n\t\t\t\t\t\t\t\t  cell_t->oid);\n\n\t\t\t\tif (unlink(tblspc_symlink.data) < 0 && errno != ENOENT)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to remove tablespace symlink %s\"), tblspc_symlink.data);\n\t\t\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\t\t\tr = ERR_BAD_BASEBACKUP;\n\t\t\t\t\tgoto stop_backup;\n\t\t\t\t}\n\n\t\t\t\tif (symlink(tblspc_dir_dest, tblspc_symlink.data) < 0)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to create tablespace symlink from %s to %s\"), tblspc_symlink.data, tblspc_dir_dest);\n\n\t\t\t\t\tr = ERR_BAD_BASEBACKUP;\n\t\t\t\t\tgoto stop_backup;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * For 9.5 and later, if tablespace remapping was requested, we'll need to\n\t * rewrite the tablespace map file ourselves. The tablespace map file is\n\t * read on startup and any links created by the backend; we could do this\n\t * ourselves like for pre-9.5 servers, but it's better to rely on\n\t * functionality the backend provides.\n\t */\n\n\tif (source_server_version_num >= 90500 && tablespace_map_rewrite == true)\n\t{\n\t\tPQExpBufferData tablespace_map_filename;\n\t\tFILE\t   *tablespace_map_file;\n\n\t\tinitPQExpBuffer(&tablespace_map_filename);\n\t\tappendPQExpBuffer(&tablespace_map_filename, \"%s/%s\",\n\t\t\t\t\t\t  local_data_directory,\n\t\t\t\t\t\t  TABLESPACE_MAP);\n\n\t\t/*\n\t\t * Unlink any existing file (it should be there, but we don't care if\n\t\t * it isn't)\n\t\t */\n\t\tif (unlink(tablespace_map_filename.data) < 0 && errno != ENOENT)\n\t\t{\n\t\t\tlog_error(_(\"unable to remove tablespace_map file \\\"%s\\\"\"),\n\t\t\t\t\t  tablespace_map_filename.data);\n\t\t\tlog_detail(\"%s\", strerror(errno));\n\n\t\t\tr = ERR_BAD_BASEBACKUP;\n\t\t\tgoto stop_backup;\n\t\t}\n\n\t\ttablespace_map_file = fopen(tablespace_map_filename.data, \"w\");\n\t\tif (tablespace_map_file == NULL)\n\t\t{\n\t\t\tlog_error(_(\"unable to create tablespace_map file \\\"%s\\\"\"), tablespace_map_filename.data);\n\n\t\t\tr = ERR_BAD_BASEBACKUP;\n\t\t\tgoto stop_backup;\n\t\t}\n\n\t\tif (fputs(tablespace_map.data, tablespace_map_file) == EOF)\n\t\t{\n\t\t\tfclose(tablespace_map_file);\n\n\t\t\tlog_error(_(\"unable to write to tablespace_map file \\\"%s\\\"\"), tablespace_map_filename.data);\n\n\t\t\tr = ERR_BAD_BASEBACKUP;\n\t\t\tgoto stop_backup;\n\t\t}\n\n\t\tfclose(tablespace_map_file);\n\n\t\ttermPQExpBuffer(&tablespace_map_filename);\n\t\ttermPQExpBuffer(&tablespace_map);\n\t}\n\nstop_backup:\n\n\tif (mode == barman)\n\t{\n\t\t/*\n\t\t * In Barman mode, remove local_repmgr_tmp_directory,\n\t\t * which contains various temporary files containing Barman metadata.\n\t\t */\n\t\trmtree(local_repmgr_tmp_directory, true);\n\t}\n\n\n\t/*\n\t * if replication slots in use, create replication slot\n\t */\n\tif (r == SUCCESS)\n\t{\n\t\tif (config_file_options.use_replication_slots == true)\n\t\t{\n\t\t\tbool slot_warning = false;\n\t\t\tif (runtime_options.no_upstream_connection == true)\n\t\t\t{\n\t\t\t\tslot_warning = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tt_node_info upstream_node_record = T_NODE_INFO_INITIALIZER;\n\t\t\t\tt_replication_slot slot_info = T_REPLICATION_SLOT_INITIALIZER;\n\t\t\t\tRecordStatus record_status = RECORD_NOT_FOUND;\n\t\t\t\tPGconn\t   *upstream_conn = NULL;\n\n\n\t\t\t\t/* check connections are still available */\n\t\t\t\t(void)connection_ping_reconnect(primary_conn);\n\n\t\t\t\tif (source_conn != primary_conn)\n\t\t\t\t\t(void)connection_ping_reconnect(source_conn);\n\n\t\t\t\t(void)connection_ping_reconnect(source_conn);\n\n\t\t\t\trecord_status = get_node_record(source_conn, upstream_node_id, &upstream_node_record);\n\n\t\t\t\tif (record_status != RECORD_FOUND)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to retrieve node record for upstream node %i\"), upstream_node_id);\n\t\t\t\t\tslot_warning = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupstream_conn = establish_db_connection(upstream_node_record.conninfo, false);\n\t\t\t\t\tif (PQstatus(upstream_conn) != CONNECTION_OK)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_error(_(\"unable to connect to upstream node %i to create a replication slot\"), upstream_node_id);\n\t\t\t\t\t\tslot_warning = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\trecord_status = get_slot_record(upstream_conn, local_node_record->slot_name, &slot_info);\n\n\t\t\t\t\t\tif (record_status == RECORD_FOUND)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog_verbose(LOG_INFO,\n\t\t\t\t\t\t\t\t\t\t_(\"replication slot \\\"%s\\\" already exists on upstream node %i\"),\n\t\t\t\t\t\t\t\t\t\tlocal_node_record->slot_name,\n\t\t\t\t\t\t\t\t\t\tupstream_node_id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tPQExpBufferData errmsg;\n\t\t\t\t\t\t\tbool success;\n\n\t\t\t\t\t\t\tinitPQExpBuffer(&errmsg);\n\t\t\t\t\t\t\tsuccess = create_replication_slot(upstream_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  local_node_record->slot_name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  &upstream_node_record,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  &errmsg);\n\t\t\t\t\t\t\tif (success == false)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog_error(_(\"unable to create replication slot \\\"%s\\\" on upstream node %i\"),\n\t\t\t\t\t\t\t\t\t\t  local_node_record->slot_name,\n\t\t\t\t\t\t\t\t\t\t  upstream_node_id);\n\t\t\t\t\t\t\t\tlog_detail(\"%s\", errmsg.data);\n\t\t\t\t\t\t\t\tslot_warning = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog_notice(_(\"replication slot \\\"%s\\\" created on upstream node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t\t\t\t   local_node_record->slot_name,\n\t\t\t\t\t\t\t\t\t\t   upstream_node_record.node_name,\n\t\t\t\t\t\t\t\t\t\t   upstream_node_id );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttermPQExpBuffer(&errmsg);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPQfinish(upstream_conn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (slot_warning == true)\n\t\t\t{\n\t\t\t\tlog_warning(_(\"\\\"use_replication_slots\\\" specified but a replication slot could not be created\"));\n\t\t\t\tlog_hint(_(\"ensure a replication slot called \\\"%s\\\" is created on the upstream node (ID: %i)\"),\n\t\t\t\t\t\t local_node_record->slot_name,\n\t\t\t\t\t\t upstream_node_id);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn r;\n}\n\n\n/*\n * Perform a call to pg_backupapi endpoint to ask barman to write the backup\n * for us. This will ensure that no matter the format on-disk of new backups,\n * barman will always find a way how to read and write them.\n * From repmgr 4 this is only used for Barman backups.\n */\nstatic int\nrun_pg_backupapi(t_node_info *local_node_record)\n{\n\tint r = ERR_PGBACKUPAPI_SERVICE;\n\tlong http_return_code = 0;\n\tshort seconds_to_sleep = 3;\n\toperation_task *task = malloc(sizeof(operation_task));\n\tCURL *curl = curl_easy_init();\n\tCURLcode ret;\n\n\tcheck_pg_backupapi_standby_clone_options();\n\n\ttask->host = malloc(strlen(config_file_options.pg_backupapi_host)+1);\n\ttask->remote_ssh_command = malloc(strlen(config_file_options.pg_backupapi_remote_ssh_command)+1);\n\ttask->node_name = malloc(strlen(config_file_options.pg_backupapi_node_name)+1);\n\ttask->operation_type = malloc(strlen(DEFAULT_STANDBY_PG_BACKUPAPI_OP_TYPE)+1);\n\ttask->backup_id = malloc(strlen(config_file_options.pg_backupapi_backup_id)+1);\n\ttask->destination_directory = malloc(strlen(local_data_directory)+1);\n\n\ttask->operation_id = malloc(MAX_BUFFER_LENGTH);\n\ttask->operation_status = malloc(MAX_BUFFER_LENGTH);\n\n\tstrcpy(task->host, config_file_options.pg_backupapi_host);\n\tstrcpy(task->remote_ssh_command, config_file_options.pg_backupapi_remote_ssh_command);\n\tstrcpy(task->node_name, config_file_options.pg_backupapi_node_name);\n\tstrcpy(task->operation_type, DEFAULT_STANDBY_PG_BACKUPAPI_OP_TYPE);\n\tstrcpy(task->backup_id, config_file_options.pg_backupapi_backup_id);\n\tstrcpy(task->destination_directory, local_data_directory);\n\tstrcpy(task->operation_id, \"\\0\");\n\n\tret = create_new_task(curl, task);\n\n\tif ((ret != CURLE_OK) || (strlen(task->operation_id) == 0)) {\n\t\tcurl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_return_code);\n\t\tif (499 > http_return_code && http_return_code >= 400) {\n\t\t\tlog_error(\"Cannot find backup '%s' for node '%s'.\", task->backup_id, task->node_name);\n\t\t} else {\n\t\t\tlog_error(\"whilst reaching out pg_backup service: %s\\n\", curl_easy_strerror(ret));\n\t\t}\n        }\n\telse\n\t{\n\t\tlog_info(\"Success creating the task: operation id '%s'\", task->operation_id);\n\n\t\t//We call init again because previous call included POST calls\n\t\tcurl_easy_cleanup(curl);\n\t\tcurl = curl_easy_init();\n\t\twhile (true)\n\t\t{\n\t\t\tret = get_status_of_operation(curl, task);\n\t\t\tif (strlen(task->operation_status) == 0) {\n\t\t\t\tlog_info(\"Retrying...\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_info(\"status %s\", task->operation_status);\n\t\t\t}\n\t\t\tif (strcmp(task->operation_status, \"FAILED\") == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strcmp(task->operation_status, \"DONE\") == 0) {\n\t\t\t\tr = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsleep(seconds_to_sleep);\n\t\t}\n\t}\n\n\tcurl_easy_cleanup(curl);\n\tfree(task);\n\treturn r;\n}\n\n/*\n * pg_backupapi mode is enabled when config_file_options.pg_backupapi_host is set hence, we\n * should also check the other required variables too.\n */\n\nvoid check_pg_backupapi_standby_clone_options() {\n\n\tbool error = false;\n\n\tif (*config_file_options.pg_backupapi_remote_ssh_command == '\\0') {\n\t\tlog_hint(\"Check config: remote ssh command is required\");\n\t\terror = true;\n\t}\n\tif (*config_file_options.pg_backupapi_node_name == '\\0') {\n\t\tlog_hint(\"Check config: node name is required\");\n\t\terror = true;\n\t}\n\tif (*config_file_options.pg_backupapi_backup_id == '\\0') {\n\t\tlog_hint(\"Check config: backup_id is required\");\n\t\terror = true;\n\t}\n\n\tif (error == true) {\n\t\tlog_error(\"Please fix the errors and try again\");\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n}\n\n\n\nstatic char *\nmake_barman_ssh_command(char *buf)\n{\n\tstatic char config_opt[MAXLEN] = \"\";\n\n\tif (strlen(config_file_options.barman_config))\n\t\tmaxlen_snprintf(config_opt,\n\t\t\t\t\t\t\" --config=%s\",\n\t\t\t\t\t\tconfig_file_options.barman_config);\n\n\tmaxlen_snprintf(buf,\n\t\t\t\t\t\"ssh %s barman%s\",\n\t\t\t\t\tconfig_file_options.barman_host,\n\t\t\t\t\tconfig_opt);\n\n\treturn buf;\n}\n\n\nstatic int\nget_tablespace_data_barman(char *tablespace_data_barman,\n\t\t\t\t\t\t   TablespaceDataList *tablespace_list)\n{\n\t/*\n\t * Example: [('main', 24674, '/var/lib/postgresql/tablespaces/9.5/main'),\n\t * ('alt', 24678, '/var/lib/postgresql/tablespaces/9.5/alt')]\n\t */\n\n\tchar\t\tname[MAXLEN] = \"\";\n\tchar\t\toid[MAXLEN] = \"\";\n\tchar\t\tlocation[MAXPGPATH] = \"\";\n\tchar\t   *p = tablespace_data_barman;\n\tint\t\t\ti = 0;\n\n\ttablespace_list->head = NULL;\n\ttablespace_list->tail = NULL;\n\n\tp = string_skip_prefix(\"[\", p);\n\tif (p == NULL)\n\t\treturn -1;\n\n\twhile (*p == '(')\n\t{\n\t\tp = string_skip_prefix(\"('\", p);\n\t\tif (p == NULL)\n\t\t\treturn -1;\n\n\t\ti = strcspn(p, \"'\");\n\t\tstrncpy(name, p, i);\n\t\tname[i] = 0;\n\n\t\tp = string_skip_prefix(\"', \", p + i);\n\t\tif (p == NULL)\n\t\t\treturn -1;\n\n\t\ti = strcspn(p, \",\");\n\t\tstrncpy(oid, p, i);\n\t\toid[i] = 0;\n\n\t\tp = string_skip_prefix(\", '\", p + i);\n\t\tif (p == NULL)\n\t\t\treturn -1;\n\n\t\ti = strcspn(p, \"'\");\n\t\tstrncpy(location, p, i);\n\t\tlocation[i] = 0;\n\n\t\tp = string_skip_prefix(\"')\", p + i);\n\t\tif (p == NULL)\n\t\t\treturn -1;\n\n\t\ttablespace_data_append(tablespace_list, name, oid, location);\n\n\t\tif (*p == ']')\n\t\t\tbreak;\n\n\t\tp = string_skip_prefix(\", \", p);\n\t\tif (p == NULL)\n\t\t\treturn -1;\n\t}\n\n\treturn SUCCESS;\n}\n\n\nvoid\nget_barman_property(char *dst, char *name, char *local_repmgr_directory)\n{\n\tPQExpBufferData command_output;\n\tchar\t\tbuf[MAXLEN] = \"\";\n\tchar\t\tcommand[MAXLEN] = \"\";\n\tchar\t   *p = NULL;\n\n\tinitPQExpBuffer(&command_output);\n\n\tmaxlen_snprintf(command,\n\t\t\t\t\t\"grep \\\"^[[:space:]]%s:\\\" %s/show-server.txt\",\n\t\t\t\t\tname, local_repmgr_tmp_directory);\n\t(void) local_command(command, &command_output);\n\n\tmaxlen_snprintf(buf, \"\\t%s: \", name);\n\tp = string_skip_prefix(buf, command_output.data);\n\tif (p == NULL)\n\t{\n\t\tlog_error(\"unexpected output from Barman: %s\",\n\t\t\t\t  command_output.data);\n\t\texit(ERR_INTERNAL);\n\t}\n\n\tstrncpy(dst, p, MAXLEN);\n\tstring_remove_trailing_newlines(dst);\n\n\ttermPQExpBuffer(&command_output);\n}\n\n\nstatic void\ncopy_configuration_files(bool delete_after_copy)\n{\n\tint\t\t\ti,\n\t\t\t\tr;\n\tt_configfile_info *file = NULL;\n\tchar\t   *host = NULL;\n\n\t/* get host from upstream record */\n\thost = param_get(&recovery_conninfo, \"host\");\n\n\tif (host == NULL)\n\t\thost = runtime_options.host;\n\n\tlog_notice(_(\"copying external configuration files from upstream node \\\"%s\\\"\"), host);\n\n\tfor (i = 0; i < config_files.entries; i++)\n\t{\n\t\tPQExpBufferData dest_path;\n\n\t\tfile = config_files.files[i];\n\n\t\t/*\n\t\t * Skip files in the data directory - these will be copied during the\n\t\t * main backup\n\t\t */\n\t\tif (file->in_data_directory == true)\n\t\t\tcontinue;\n\n\t\tinitPQExpBuffer(&dest_path);\n\n\t\tif (runtime_options.copy_external_config_files_destination == CONFIG_FILE_SAMEPATH)\n\t\t{\n\t\t\tappendPQExpBufferStr(&dest_path, file->filepath);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappendPQExpBuffer(&dest_path,\n\t\t\t\t\t\t\t  \"%s/%s\",\n\t\t\t\t\t\t\t  local_data_directory,\n\t\t\t\t\t\t\t  file->filename);\n\t\t}\n\n\t\tr = copy_remote_files(runtime_options.host, runtime_options.remote_user,\n\t\t\t\t\t\t\t  file->filepath, dest_path.data, false, source_server_version_num);\n\n\t\t/*\n\t\t * TODO: collate errors into list\n\t\t */\n\n\t\tif (WEXITSTATUS(r))\n\t\t{\n\t\t\tlog_error(_(\"standby clone: unable to copy config file \\\"%s\\\"\"),\n\t\t\t\t\t  file->filename);\n\t\t\tlog_hint(_(\"see preceding messages for details\"));\n\n\t\t\tif (runtime_options.force == false)\n\t\t\t\texit(ERR_BAD_RSYNC);\n\t\t}\n\n\t\t/*\n\t\t * This is to check we can actually copy the files before running the\n\t\t * main clone operation\n\t\t */\n\t\tif (delete_after_copy == true)\n\t\t{\n\t\t\t/* this is very unlikely to happen, but log in case it does */\n\t\t\tif (unlink(dest_path.data) < 0 && errno != ENOENT)\n\t\t\t{\n\t\t\t\tlog_warning(_(\"unable to delete %s\"), dest_path.data);\n\t\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\t}\n\t\t}\n\n\t\ttermPQExpBuffer(&dest_path);\n\t}\n\n\treturn;\n}\n\n\nstatic void\ntablespace_data_append(TablespaceDataList *list, const char *name, const char *oid, const char *location)\n{\n\tTablespaceDataListCell *cell = NULL;\n\tint oid_len = strlen(oid);\n\tint name_len = strlen(name);\n\tint location_len = strlen(location);\n\tcell = (TablespaceDataListCell *) pg_malloc0(sizeof(TablespaceDataListCell));\n\n\tif (cell == NULL)\n\t{\n\t\tlog_error(_(\"unable to allocate memory; terminating\"));\n\t\texit(ERR_OUT_OF_MEMORY);\n\t}\n\n\tcell->oid = pg_malloc0(1 + oid_len);\n\tcell->name = pg_malloc0(1 + name_len);\n\tcell->location = pg_malloc0(1 + location_len);\n\n\tstrncpy(cell->oid, oid, oid_len);\n\tstrncpy(cell->name, name, name_len);\n\tstrncpy(cell->location, location, location_len);\n\n\tif (list->tail)\n\t\tlist->tail->next = cell;\n\telse\n\t\tlist->head = cell;\n\n\tlist->tail = cell;\n}\n\n\n\n/*\n * check_primary_standby_version_match()\n *\n * Check server versions of supplied connections are compatible for\n * replication purposes.\n *\n * Exits on error.\n */\nstatic void\ncheck_primary_standby_version_match(PGconn *conn, PGconn *primary_conn)\n{\n\tchar\t\tstandby_version[MAXVERSIONSTR] = \"\";\n\tint\t\t\tstandby_version_num = UNKNOWN_SERVER_VERSION_NUM;\n\n\tchar\t\tprimary_version[MAXVERSIONSTR] = \"\";\n\tint\t\t\tprimary_version_num = UNKNOWN_SERVER_VERSION_NUM;\n\n\tstandby_version_num = check_server_version(conn, \"standby\", true, standby_version);\n\n\t/* Verify that primary is a supported server version */\n\tprimary_version_num = check_server_version(conn, \"primary\", false, primary_version);\n\tif (primary_version_num < 0)\n\t{\n\t\tPQfinish(conn);\n\t\tPQfinish(primary_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* primary and standby version should match */\n\tif ((primary_version_num / 100) != (standby_version_num / 100))\n\t{\n\t\tPQfinish(conn);\n\t\tPQfinish(primary_conn);\n\t\tlog_error(_(\"PostgreSQL versions on primary (%s) and standby (%s) must match\"),\n\t\t\t\t  primary_version, standby_version);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n}\n\n\nstatic void\ncheck_recovery_type(PGconn *conn)\n{\n\tRecoveryType recovery_type = get_recovery_type(conn);\n\n\tif (recovery_type != RECTYPE_STANDBY)\n\t{\n\t\tif (recovery_type == RECTYPE_PRIMARY)\n\t\t{\n\t\t\tlog_error(_(\"this node should be a standby (%s)\"),\n\t\t\t\t\t  config_file_options.conninfo);\n\t\t\tPQfinish(conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_error(_(\"connection to node (%s) lost\"),\n\t\t\t\t\t  config_file_options.conninfo);\n\t\t\tPQfinish(conn);\n\t\t\texit(ERR_DB_CONN);\n\t\t}\n\t}\n}\n\n\n\n/*\n * Creates recovery configuration for a standby.\n *\n * A database connection pointer is required for escaping primary_conninfo\n * parameters. When cloning from Barman and --no-upstream-connection supplied,\n * this might not be available.\n */\nstatic bool\ncreate_recovery_file(t_node_info *node_record, t_conninfo_param_list *primary_conninfo, int server_version_num, char *dest, bool as_file)\n{\n\tPQExpBufferData recovery_file_buf;\n\tPQExpBufferData primary_conninfo_buf;\n\tchar\t\trecovery_file_path[MAXPGPATH] = \"\";\n\tFILE\t   *recovery_file;\n\tmode_t\t\tum;\n\n\tKeyValueList recovery_config = {NULL, NULL};\n\tKeyValueListCell *cell = NULL;\n\n\tinitPQExpBuffer(&primary_conninfo_buf);\n\n\t/* standby_mode = 'on' (Pg 11 and earlier) */\n\tif (server_version_num < 120000)\n\t{\n\t\tkey_value_list_set(&recovery_config,\n\t\t\t\t\t\t   \"standby_mode\", \"on\");\n\t}\n\n\t/* primary_conninfo = '...' */\n\twrite_primary_conninfo(&primary_conninfo_buf, primary_conninfo);\n\tkey_value_list_set(&recovery_config,\n\t\t\t\t\t   \"primary_conninfo\", primary_conninfo_buf.data);\n\n\t/*\n\t * recovery_target_timeline = 'latest'\n\t *\n\t * PostgreSQL 11 and earlier only; 'latest' is the default from PostgreSQL 12.\n\t */\n\n\tif (server_version_num < 120000)\n\t{\n\t\tkey_value_list_set(&recovery_config,\n\t\t\t\t\t\t   \"recovery_target_timeline\", \"latest\");\n\t}\n\n\t/* recovery_min_apply_delay = ... (optional) */\n\tif (config_file_options.recovery_min_apply_delay_provided == true)\n\t{\n\t\tkey_value_list_set(&recovery_config,\n\t\t\t\t\t\t   \"recovery_min_apply_delay\", config_file_options.recovery_min_apply_delay);\n\t}\n\n\t/* primary_slot_name = '...' (optional, for 9.4 and later) */\n\tif (config_file_options.use_replication_slots)\n\t{\n\t\tkey_value_list_set(&recovery_config,\n\t\t\t\t\t\t   \"primary_slot_name\", node_record->slot_name);\n\t}\n\n\t/*\n\t * If restore_command is set, we use it as restore_command in\n\t * recovery.conf\n\t */\n\tif (config_file_options.restore_command[0] != '\\0')\n\t{\n\t\tchar\t   *escaped = escape_recovery_conf_value(config_file_options.restore_command);\n\n\t\tkey_value_list_set(&recovery_config,\n\t\t\t\t\t\t  \"restore_command\", escaped);\n\t\tfree(escaped);\n\t}\n\n\t/* archive_cleanup_command (optional) */\n\tif (config_file_options.archive_cleanup_command[0] != '\\0')\n\t{\n\t\tchar\t   *escaped = escape_recovery_conf_value(config_file_options.archive_cleanup_command);\n\n\t\tkey_value_list_set(&recovery_config,\n\t\t\t\t\t\t  \"archive_cleanup_command\", escaped);\n\t\tfree(escaped);\n\t}\n\n\t/*\n\t * Caller requests the generated file to be written into a buffer\n\t */\n\tif (as_file == false)\n\t{\n\t\t/* create file in buffer */\n\t\tinitPQExpBuffer(&recovery_file_buf);\n\n\t\tfor (cell = recovery_config.head; cell; cell = cell->next)\n\t\t{\n\t\t\tappendPQExpBuffer(&recovery_file_buf,\n\t\t\t\t\t\t\t  \"%s = '%s'\\n\",\n\t\t\t\t\t\t\t  cell->key, cell->value);\n\t\t}\n\n\t\tmaxlen_snprintf(dest, \"%s\", recovery_file_buf.data);\n\n\t\ttermPQExpBuffer(&recovery_file_buf);\n\n\t\treturn true;\n\t}\n\n\t/*\n\t * PostgreSQL 12 and later: modify postgresql.auto.conf\n\t */\n\tif (server_version_num >= 120000)\n\t{\n\t\tif (modify_auto_conf(dest, &recovery_config) == false)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (write_standby_signal(dest) == false)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/*\n\t * PostgreSQL 11 and earlier: write recovery.conf\n\t */\n\tmaxpath_snprintf(recovery_file_path, \"%s/%s\", dest, RECOVERY_COMMAND_FILE);\n\tlog_debug(\"create_recovery_file(): creating \\\"%s\\\"...\",\n\t\t\t  recovery_file_path);\n\n\t/* Set umask to 0600 */\n\tum = umask((~(S_IRUSR | S_IWUSR)) & (S_IRWXG | S_IRWXO));\n\trecovery_file = fopen(recovery_file_path, \"w\");\n\tumask(um);\n\n\tif (recovery_file == NULL)\n\t{\n\t\tlog_error(_(\"unable to create recovery.conf file at \\\"%s\\\"\"),\n\t\t\t\t  recovery_file_path);\n\t\tlog_detail(\"%s\", strerror(errno));\n\n\t\treturn false;\n\t}\n\n\tfor (cell = recovery_config.head; cell; cell = cell->next)\n\t{\n\t\tinitPQExpBuffer(&recovery_file_buf);\n\t\tappendPQExpBuffer(&recovery_file_buf,\n\t\t\t\t\t\t  \"%s = '%s'\\n\",\n\t\t\t\t\t\t  cell->key, cell->value);\n\n\t\tlog_debug(\"recovery.conf line: %s\", recovery_file_buf.data);\n\n\t\tif (fputs(recovery_file_buf.data, recovery_file) == EOF)\n\t\t{\n\t\t\tlog_error(_(\"unable to write to recovery file at \\\"%s\\\"\"), recovery_file_path);\n\t\t\tfclose(recovery_file);\n\t\t\ttermPQExpBuffer(&recovery_file_buf);\n\t\t\treturn false;\n\t\t}\n\n\t\ttermPQExpBuffer(&recovery_file_buf);\n\t}\n\n\n\tfclose(recovery_file);\n\n\treturn true;\n}\n\n\nstatic void\nwrite_primary_conninfo(PQExpBufferData *dest, t_conninfo_param_list *param_list)\n{\n\tPQExpBufferData conninfo_buf;\n\tbool\t\tapplication_name_provided = false;\n\tbool\t\tpassword_provided = false;\n\tint\t\t\tc;\n\tchar\t   *escaped = NULL;\n\tt_conninfo_param_list env_conninfo = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\n\tinitialize_conninfo_params(&env_conninfo, true);\n\n\tinitPQExpBuffer(&conninfo_buf);\n\n\tfor (c = 0; c < param_list->size && param_list->keywords[c] != NULL; c++)\n\t{\n\t\t/*\n\t\t * Skip empty settings and ones which don't make any sense in\n\t\t * recovery.conf\n\t\t */\n\t\tif (strcmp(param_list->keywords[c], \"dbname\") == 0 ||\n\t\t\tstrcmp(param_list->keywords[c], \"replication\") == 0 ||\n\t\t\t(param_list->values[c] == NULL) ||\n\t\t\t(param_list->values[c] != NULL && param_list->values[c][0] == '\\0'))\n\t\t\tcontinue;\n\n\t\t/* only include \"password\" if explicitly requested */\n\t\tif (strcmp(param_list->keywords[c], \"password\") == 0)\n\t\t{\n\t\t\tpassword_provided = true;\n\t\t}\n\n\t\tif (conninfo_buf.len != 0)\n\t\t\tappendPQExpBufferChar(&conninfo_buf, ' ');\n\n\t\tif (strcmp(param_list->keywords[c], \"application_name\") == 0)\n\t\t\tapplication_name_provided = true;\n\n\t\tappendPQExpBuffer(&conninfo_buf, \"%s=\", param_list->keywords[c]);\n\t\tappendConnStrVal(&conninfo_buf, param_list->values[c]);\n\t}\n\n\t/* \"application_name\" not provided - default to repmgr node name */\n\tif (application_name_provided == false)\n\t{\n\t\tif (strlen(config_file_options.node_name))\n\t\t{\n\t\t\tappendPQExpBufferStr(&conninfo_buf, \" application_name=\");\n\t\t\tappendConnStrVal(&conninfo_buf, config_file_options.node_name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappendPQExpBufferStr(&conninfo_buf, \" application_name=repmgr\");\n\t\t}\n\t}\n\n\t/* no password provided explicitly  */\n\tif (password_provided == false)\n\t{\n\t\tif (config_file_options.use_primary_conninfo_password == true)\n\t\t{\n\t\t\tconst char *password = param_get(&env_conninfo, \"password\");\n\n\t\t\tif (password != NULL)\n\t\t\t{\n\t\t\t\tappendPQExpBufferStr(&conninfo_buf, \" password=\");\n\t\t\t\tappendConnStrVal(&conninfo_buf, password);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* passfile provided as configuration option */\n\tif (config_file_options.passfile[0] != '\\0')\n\t{\n\t\t/* check if the libpq we're using supports \"passfile=\" */\n\t\tif (has_passfile() == true)\n\t\t{\n\t\t\tappendPQExpBufferStr(&conninfo_buf, \" passfile=\");\n\t\t\tappendConnStrVal(&conninfo_buf, config_file_options.passfile);\n\t\t}\n\t}\n\n\tescaped = escape_recovery_conf_value(conninfo_buf.data);\n\n\tappendPQExpBufferStr(dest, escaped);\n\n\tfree(escaped);\n\tfree_conninfo_params(&env_conninfo);\n\ttermPQExpBuffer(&conninfo_buf);\n}\n\n\n/*\n * For \"standby promote\" and \"standby follow\", check for sibling nodes.\n * If \"--siblings-follow\" was specified, fill the provided SiblingNodeStats\n * struct with some aggregate info about the nodes for later\n * decision making.\n */\nstatic bool\ncheck_sibling_nodes(NodeInfoList *sibling_nodes, SiblingNodeStats *sibling_nodes_stats)\n{\n\tchar\t\thost[MAXLEN] = \"\";\n\tNodeInfoListCell *cell;\n\tint\t\t\tr;\n\n\t/*\n\t * If --siblings-follow not specified, warn about any extant\n\t * siblings which will not follow the new primary\n\t */\n\n\tif (runtime_options.siblings_follow == false)\n\t{\n\t\tif (sibling_nodes->node_count > 0)\n\t\t{\n\t\t\tPQExpBufferData nodes;\n\n\t\t\tinitPQExpBuffer(&nodes);\n\n\t\t\tfor (cell = sibling_nodes->head; cell; cell = cell->next)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&nodes,\n\t\t\t\t\t\t\t\t  \"  %s (node ID: %i\",\n\t\t\t\t\t\t\t\t  cell->node_info->node_name,\n\t\t\t\t\t\t\t\t  cell->node_info->node_id);\n\n\t\t\t\tif (cell->node_info->type == WITNESS)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(&nodes,\n\t\t\t\t\t\t\t\t\t\t \", witness server\");\n\t\t\t\t}\n\t\t\t\tappendPQExpBufferChar(&nodes,\n\t\t\t\t\t\t\t\t\t  ')');\n\t\t\t\tif (cell->next)\n\t\t\t\t\tappendPQExpBufferStr(&nodes, \"\\n\");\n\t\t\t}\n\n\t\t\tlog_warning(_(\"%i sibling nodes found, but option \\\"--siblings-follow\\\" not specified\"),\n\t\t\t\t\t\tsibling_nodes->node_count);\n\t\t\tlog_detail(_(\"these nodes will remain attached to the current primary:\\n%s\"), nodes.data);\n\n\t\t\ttermPQExpBuffer(&nodes);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tlog_verbose(LOG_INFO, _(\"%i active sibling nodes found\"),\n\t\t\t\tsibling_nodes->node_count);\n\n\tif (sibling_nodes->node_count == 0)\n\t{\n\t\tlog_warning(_(\"option \\\"--sibling-nodes\\\" specified, but no sibling nodes exist\"));\n\t\treturn true;\n\t}\n\n\tfor (cell = sibling_nodes->head; cell; cell = cell->next)\n\t{\n\t\t/* get host from node record */\n\t\tget_conninfo_value(cell->node_info->conninfo, \"host\", host);\n\t\tr = test_ssh_connection(host, runtime_options.remote_user);\n\n\t\tif (r != 0)\n\t\t{\n\t\t\tcell->node_info->reachable = false;\n\t\t\tsibling_nodes_stats->unreachable_sibling_node_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcell->node_info->reachable = true;\n\t\t\tsibling_nodes_stats->reachable_sibling_node_count++;\n\t\t\tsibling_nodes_stats->min_required_wal_senders++;\n\n\t\t\tif (cell->node_info->slot_name[0] != '\\0')\n\t\t\t{\n\t\t\t\tsibling_nodes_stats->reachable_sibling_nodes_with_slot_count++;\n\t\t\t\tsibling_nodes_stats->min_required_free_slots++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sibling_nodes_stats->unreachable_sibling_node_count > 0)\n\t{\n\t\tif (runtime_options.force == false)\n\t\t{\n\t\t\tlog_error(_(\"%i of %i sibling nodes unreachable via SSH:\"),\n\t\t\t\t\t  sibling_nodes_stats->unreachable_sibling_node_count,\n\t\t\t\t\t  sibling_nodes->node_count);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_warning(_(\"%i of %i sibling nodes unreachable via SSH:\"),\n\t\t\t\t\t\tsibling_nodes_stats->unreachable_sibling_node_count,\n\t\t\t\t\t\tsibling_nodes->node_count);\n\t\t}\n\n\t\t/* display list of unreachable sibling nodes */\n\t\tfor (cell = sibling_nodes->head; cell; cell = cell->next)\n\t\t{\n\t\t\tif (cell->node_info->reachable == true)\n\t\t\t\tcontinue;\n\t\t\tlog_detail(\"  %s (ID: %i)\",\n\t\t\t\t\t   cell->node_info->node_name,\n\t\t\t\t\t   cell->node_info->node_id);\n\t\t}\n\n\t\tif (runtime_options.force == false)\n\t\t{\n\t\t\tlog_hint(_(\"use -F/--force to proceed in any case\"));\n\t\t\treturn false;\n\t\t}\n\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_detail(_(\"F/--force specified, would proceed anyway\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_detail(_(\"F/--force specified, proceeding anyway\"));\n\t\t}\n\t}\n\telse\n\t{\n\t\tchar\t   *msg = _(\"all sibling nodes are reachable via SSH\");\n\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(\"%s\", msg);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_verbose(LOG_INFO, \"%s\", msg);\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\nstatic bool\ncheck_free_wal_senders(int available_wal_senders, SiblingNodeStats *sibling_nodes_stats, bool *dry_run_success)\n{\n\tif (available_wal_senders < sibling_nodes_stats->min_required_wal_senders)\n\t{\n\t\tif (runtime_options.force == false || runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_error(_(\"insufficient free walsenders on promotion candidate\"));\n\t\t\tlog_detail(_(\"at least %i walsenders required but only %i free walsenders on promotion candidate\"),\n\t\t\t\t\t   sibling_nodes_stats->min_required_wal_senders,\n\t\t\t\t\t   available_wal_senders);\n\t\t\tlog_hint(_(\"increase parameter \\\"max_wal_senders\\\" or use -F/--force to proceed in any case\"));\n\n\t\t\tif (runtime_options.dry_run == true)\n\t\t\t{\n\t\t\t\t*dry_run_success = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_warning(_(\"insufficient free walsenders on promotion candidate\"));\n\t\t\tlog_detail(_(\"at least %i walsenders required but only %i free walsender(s) on promotion candidate\"),\n\t\t\t\t\t   sibling_nodes_stats->min_required_wal_senders,\n\t\t\t\t\t   available_wal_senders);\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_info(_(\"%i walsenders required, %i available\"),\n\t\t\t\t\t sibling_nodes_stats->min_required_wal_senders,\n\t\t\t\t\t available_wal_senders);\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\nstatic bool\ncheck_free_slots(t_node_info *local_node_record, SiblingNodeStats *sibling_nodes_stats, bool *dry_run_success)\n{\n\tif (sibling_nodes_stats->min_required_free_slots > 0 )\n\t{\n\t\tint available_slots = local_node_record->max_replication_slots -\n\t\t\tlocal_node_record->active_replication_slots;\n\n\t\tlog_debug(\"minimum of %i free slots (%i for siblings) required; %i available\",\n\t\t\t\t  sibling_nodes_stats->min_required_free_slots,\n\t\t\t\t  sibling_nodes_stats->reachable_sibling_nodes_with_slot_count,\n\t\t\t\t  available_slots);\n\n\t\tif (available_slots < sibling_nodes_stats->min_required_free_slots)\n\t\t{\n\t\t\tif (runtime_options.force == false || runtime_options.dry_run == true)\n\t\t\t{\n\t\t\t\tlog_error(_(\"insufficient free replication slots to attach all nodes\"));\n\t\t\t\tlog_detail(_(\"at least %i additional replication slots required but only %i free slots available on promotion candidate\"),\n\t\t\t\t\t\t   sibling_nodes_stats->min_required_free_slots,\n\t\t\t\t\t\t   available_slots);\n\t\t\t\tlog_hint(_(\"increase parameter \\\"max_replication_slots\\\" or use -F/--force to proceed in any case\"));\n\n\t\t\t\tif (runtime_options.dry_run == true)\n\t\t\t\t{\n\t\t\t\t\t*dry_run_success = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (runtime_options.dry_run == true)\n\t\t\t{\n\t\t\t\tlog_info(_(\"%i replication slots required, %i available\"),\n\t\t\t\t\t\t sibling_nodes_stats->min_required_free_slots,\n\t\t\t\t\t\t available_slots);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\nstatic void\nsibling_nodes_follow(t_node_info *local_node_record, NodeInfoList *sibling_nodes, SiblingNodeStats *sibling_nodes_stats)\n{\n\tint\t\t\tfailed_follow_count = 0;\n\tchar\t\thost[MAXLEN] = \"\";\n\tNodeInfoListCell *cell = NULL;\n\tPQExpBufferData remote_command_str;\n\tPQExpBufferData command_output;\n\n\tlog_notice(_(\"executing STANDBY FOLLOW on %i of %i siblings\"),\n\t\t\t   sibling_nodes->node_count - sibling_nodes_stats->unreachable_sibling_node_count,\n\t\t\t   sibling_nodes->node_count);\n\n\tfor (cell = sibling_nodes->head; cell; cell = cell->next)\n\t{\n\t\tbool\t\tsuccess = false;\n\n\t\t/* skip nodes previously determined as unreachable */\n\t\tif (cell->node_info->reachable == false)\n\t\t\tcontinue;\n\n\t\tinitPQExpBuffer(&remote_command_str);\n\t\tmake_remote_repmgr_path(&remote_command_str, cell->node_info);\n\n\t\tif (cell->node_info->type == WITNESS)\n\t\t{\n\t\t\tPGconn *witness_conn = NULL;\n\n\t\t\t/* TODO: create \"repmgr witness resync\" or similar */\n\t\t\tappendPQExpBuffer(&remote_command_str,\n\t\t\t\t\t\t\t  \"witness register -d \\\\'%s\\\\' --force 2>/dev/null && echo \\\"1\\\" || echo \\\"0\\\"\",\n\t\t\t\t\t\t\t  local_node_record->conninfo);\n\n\t\t\t/*\n\t\t\t * Notify the witness repmgrd about the new primary, as at this point it will be assuming\n\t\t\t * a failover situation is in place. It will detect the new primary at some point, this\n\t\t\t * just speeds up the process.\n\t\t\t *\n\t\t\t * In the unlikely event repmgrd is not running or not in use, this will have no effect.\n\t\t\t */\n\t\t\twitness_conn = establish_db_connection_quiet(cell->node_info->conninfo);\n\n\t\t\tif (PQstatus(witness_conn) == CONNECTION_OK)\n\t\t\t{\n\t\t\t\tnotify_follow_primary(witness_conn, local_node_record->node_id);\n\t\t\t}\n\t\t\tPQfinish(witness_conn);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappendPQExpBufferStr(&remote_command_str,\n\t\t\t\t\t\t\t\t \"standby follow 2>/dev/null && echo \\\"1\\\" || echo \\\"0\\\"\");\n\t\t}\n\t\tget_conninfo_value(cell->node_info->conninfo, \"host\", host);\n\t\tlog_debug(\"executing:\\n  %s\", remote_command_str.data);\n\n\t\tinitPQExpBuffer(&command_output);\n\n\t\tsuccess = remote_command(host,\n\t\t\t\t\t\t\t\t runtime_options.remote_user,\n\t\t\t\t\t\t\t\t remote_command_str.data,\n\t\t\t\t\t\t\t\t config_file_options.ssh_options,\n\t\t\t\t\t\t\t\t &command_output);\n\n\t\ttermPQExpBuffer(&remote_command_str);\n\n\t\tif (success == false || command_output.data[0] == '0')\n\t\t{\n\t\t\tif (cell->node_info->type == WITNESS)\n\t\t\t{\n\t\t\t\tlog_warning(_(\"WITNESS REGISTER failed on node \\\"%s\\\"\"),\n\t\t\t\t\t\t\tcell->node_info->node_name);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_warning(_(\"STANDBY FOLLOW failed on node \\\"%s\\\"\"),\n\t\t\t\t\t\t\tcell->node_info->node_name);\n\t\t\t}\n\n\t\t\tfailed_follow_count++;\n\t\t}\n\n\t\ttermPQExpBuffer(&command_output);\n\t}\n\n\tif (failed_follow_count == 0)\n\t{\n\t\tlog_info(_(\"STANDBY FOLLOW successfully executed on all reachable sibling nodes\"));\n\t}\n\telse\n\t{\n\t\tlog_warning(_(\"execution of STANDBY FOLLOW failed on %i sibling nodes\"),\n\t\t\t\t\tfailed_follow_count);\n\t}\n\n\t/*\n\t * TODO: double-check all expected nodes are in pg_stat_replication\n\t * and entries in repmgr.nodes match\n\t */\n}\n\n\n\nstatic t_remote_error_type\nparse_remote_error(const char *error)\n{\n\tif (error[0] == '\\0')\n\t\treturn REMOTE_ERROR_UNKNOWN;\n\n\tif (strcasecmp(error, \"DB_CONNECTION\") == 0)\n\t\treturn REMOTE_ERROR_DB_CONNECTION;\n\n\tif (strcasecmp(error, \"CONNINFO_PARSE\") == 0)\n\t\treturn REMOTE_ERROR_CONNINFO_PARSE;\n\n\treturn REMOTE_ERROR_UNKNOWN;\n}\n\n\nstatic CheckStatus\nparse_check_status(const char *status_str)\n{\n\tCheckStatus status = CHECK_STATUS_UNKNOWN;\n\n\tif (strncmp(status_str, \"OK\", MAXLEN) == 0)\n\t{\n\t\tstatus = CHECK_STATUS_OK;\n\t}\n\telse if (strncmp(status_str, \"WARNING\", MAXLEN) == 0)\n\t{\n\t\tstatus = CHECK_STATUS_WARNING;\n\t}\n\telse if (strncmp(status_str, \"CRITICAL\", MAXLEN) == 0)\n\t{\n\t\tstatus = CHECK_STATUS_CRITICAL;\n\t}\n\telse if (strncmp(status_str, \"UNKNOWN\", MAXLEN) == 0)\n\t{\n\t\tstatus = CHECK_STATUS_UNKNOWN;\n\t}\n\n\treturn status;\n}\n\nstatic NodeStatus\nparse_node_status_is_shutdown_cleanly(const char *node_status_output, XLogRecPtr *checkPoint)\n{\n\tNodeStatus\tnode_status = NODE_STATUS_UNKNOWN;\n\n\tint\t\t\tc = 0,\n\t\t\t\targc_item = 0;\n\tchar\t  **argv_array = NULL;\n\tint\t\t\toptindex = 0;\n\n\t/* We're only interested in these options */\n\tstruct option node_status_options[] =\n\t{\n\t\t{\"last-checkpoint-lsn\", required_argument, NULL, 'L'},\n\t\t{\"state\", required_argument, NULL, 'S'},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\n\t/* Don't attempt to tokenise an empty string */\n\tif (!strlen(node_status_output))\n\t{\n\t\t*checkPoint = InvalidXLogRecPtr;\n\t\treturn node_status;\n\t}\n\n\targc_item = parse_output_to_argv(node_status_output, &argv_array);\n\n\t/* Reset getopt's optind variable */\n\toptind = 0;\n\n\t/* Prevent getopt from emitting errors */\n\topterr = 0;\n\n\twhile ((c = getopt_long(argc_item, argv_array, \"L:S:\", node_status_options,\n\t\t\t\t\t\t\t&optindex)) != -1)\n\t{\n\t\tswitch (c)\n\t\t{\n\t\t\t\t/* --last-checkpoint-lsn */\n\t\t\tcase 'L':\n\t\t\t\t*checkPoint = parse_lsn(optarg);\n\t\t\t\tbreak;\n\t\t\t\t/* --state */\n\t\t\tcase 'S':\n\t\t\t\t{\n\t\t\t\t\tif (strncmp(optarg, \"RUNNING\", MAXLEN) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode_status = NODE_STATUS_UP;\n\t\t\t\t\t}\n\t\t\t\t\telse if (strncmp(optarg, \"SHUTDOWN\", MAXLEN) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode_status = NODE_STATUS_DOWN;\n\t\t\t\t\t}\n\t\t\t\t\telse if (strncmp(optarg, \"UNCLEAN_SHUTDOWN\", MAXLEN) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode_status = NODE_STATUS_UNCLEAN_SHUTDOWN;\n\t\t\t\t\t}\n\t\t\t\t\telse if (strncmp(optarg, \"UNKNOWN\", MAXLEN) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode_status = NODE_STATUS_UNKNOWN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree_parsed_argv(&argv_array);\n\n\treturn node_status;\n}\n\n\nstatic ConnectionStatus\nparse_remote_node_replication_connection(const char *node_check_output)\n{\n\tConnectionStatus\tconn_status = CONN_UNKNOWN;\n\n\tint\t\t\tc = 0,\n\t\t\t\targc_item = 0;\n\tchar\t  **argv_array = NULL;\n\tint\t\t\toptindex = 0;\n\n\t/* We're only interested in these options */\n\tstruct option node_check_options[] =\n\t{\n\t\t{\"connection\", required_argument, NULL, 'c'},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\n\t/* Don't attempt to tokenise an empty string */\n\tif (!strlen(node_check_output))\n\t{\n\t\treturn CONN_UNKNOWN;\n\t}\n\n\targc_item = parse_output_to_argv(node_check_output, &argv_array);\n\n\t/* Reset getopt's optind variable */\n\toptind = 0;\n\n\t/* Prevent getopt from emitting errors */\n\topterr = 0;\n\n\twhile ((c = getopt_long(argc_item, argv_array, \"L:S:\", node_check_options,\n\t\t\t\t\t\t\t&optindex)) != -1)\n\t{\n\t\tswitch (c)\n\t\t{\n\n\t\t\t/* --connection */\n\t\t\tcase 'c':\n\t\t\t\t{\n\t\t\t\t\tif (strncmp(optarg, \"OK\", MAXLEN) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn_status = CONN_OK;\n\t\t\t\t\t}\n\t\t\t\t\telse if (strncmp(optarg, \"BAD\", MAXLEN) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn_status = CONN_BAD;\n\t\t\t\t\t}\n\t\t\t\t\telse if (strncmp(optarg, \"UNKNOWN\", MAXLEN) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tconn_status = CONN_UNKNOWN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree_parsed_argv(&argv_array);\n\n\treturn conn_status;\n}\n\n\nstatic CheckStatus\nparse_node_check_archiver(const char *node_check_output, int *files, int *threshold, t_remote_error_type *remote_error)\n{\n\tCheckStatus status = CHECK_STATUS_UNKNOWN;\n\n\tint\t\t\tc = 0,\n\t\t\t\targc_item = 0;\n\tchar\t  **argv_array = NULL;\n\tint\t\t\toptindex = 0;\n\n\t/* We're only interested in these options */\n\tstruct option node_check_options[] =\n\t{\n\t\t{\"status\", required_argument, NULL, 'S'},\n\t\t{\"files\", required_argument, NULL, 'f'},\n\t\t{\"threshold\", required_argument, NULL, 't'},\n\t\t{\"error\", required_argument, NULL, 'E'},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\n\t*files = 0;\n\t*threshold = 0;\n\n\t/* Don't attempt to tokenise an empty string */\n\tif (!strlen(node_check_output))\n\t{\n\t\treturn status;\n\t}\n\n\targc_item = parse_output_to_argv(node_check_output, &argv_array);\n\n\n\t/* Reset getopt's optind variable */\n\toptind = 0;\n\n\t/* Prevent getopt from emitting errors */\n\topterr = 0;\n\n\twhile ((c = getopt_long(argc_item, argv_array, \"f:S:t:\", node_check_options,\n\t\t\t\t\t\t\t&optindex)) != -1)\n\t{\n\t\tswitch (c)\n\t\t{\n\t\t\t\t/* --files */\n\t\t\tcase 'f':\n\t\t\t\t*files = atoi(optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\t*threshold = atoi(optarg);\n\t\t\t\tbreak;\n\n\t\t\t\t/* --status */\n\t\t\tcase 'S':\n\t\t\t\tstatus = parse_check_status(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\t{\n\t\t\t\t\t*remote_error = parse_remote_error(optarg);\n\t\t\t\t\tstatus = CHECK_STATUS_UNKNOWN;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree_parsed_argv(&argv_array);\n\n\treturn status;\n}\n\n\nstatic bool\nparse_data_directory_config(const char *node_check_output, t_remote_error_type *remote_error)\n{\n\tbool\t\tconfig_ok = true;\n\n\tint\t\t\tc = 0,\n\t\t\t\targc_item = 0;\n\tchar\t  **argv_array = NULL;\n\tint\t\t\toptindex = 0;\n\n\t/* We're only interested in these options */\n\tstruct option node_check_options[] =\n\t{\n\t\t{\"configured-data-directory\", required_argument, NULL, 'C'},\n\t\t{\"error\", required_argument, NULL, 'E'},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\n\t/* Don't attempt to tokenise an empty string */\n\tif (!strlen(node_check_output))\n\t{\n\t\treturn false;\n\t}\n\n\targc_item = parse_output_to_argv(node_check_output, &argv_array);\n\n\t/* Reset getopt's optind variable */\n\toptind = 0;\n\n\t/* Prevent getopt from emitting errors */\n\topterr = 0;\n\n\twhile ((c = getopt_long(argc_item, argv_array, \"C:E:\", node_check_options,\n\t\t\t\t\t\t\t&optindex)) != -1)\n\t{\n\t\tswitch (c)\n\t\t{\n\t\t\t/* --configured-data-directory */\n\t\t\tcase 'C':\n\t\t\t\t{\n\t\t\t\t\t/* we only care whether it's \"OK\" or not */\n\t\t\t\t\tif (strncmp(optarg, \"OK\", 2) != 0)\n\t\t\t\t\t\tconfig_ok = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\t{\n\t\t\t\t\t*remote_error = parse_remote_error(optarg);\n\t\t\t\t\tconfig_ok = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tfree_parsed_argv(&argv_array);\n\n\treturn config_ok;\n}\n\n\nstatic bool\nparse_replication_config_owner(const char *node_check_output)\n{\n\tbool\t\tconfig_ok = true;\n\n\tint\t\t\tc = 0,\n\t\t\t\targc_item = 0;\n\tchar\t  **argv_array = NULL;\n\tint\t\t\toptindex = 0;\n\n\t/* We're only interested in these options */\n\tstruct option node_check_options[] =\n\t{\n\t\t{\"replication-config-owner\", required_argument, NULL, 'C'},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\n\t/* Don't attempt to tokenise an empty string */\n\tif (!strlen(node_check_output))\n\t{\n\t\treturn false;\n\t}\n\n\targc_item = parse_output_to_argv(node_check_output, &argv_array);\n\n\t/* Reset getopt's optind variable */\n\toptind = 0;\n\n\t/* Prevent getopt from emitting errors */\n\topterr = 0;\n\n\twhile ((c = getopt_long(argc_item, argv_array, \"C:\", node_check_options,\n\t\t\t\t\t\t\t&optindex)) != -1)\n\t{\n\t\tswitch (c)\n\t\t{\n\t\t\t/* --configured-data-directory */\n\t\t\tcase 'C':\n\t\t\t\t{\n\t\t\t\t\t/* we only care whether it's \"OK\" or not */\n\t\t\t\t\tif (strncmp(optarg, \"OK\", 2) != 0)\n\t\t\t\t\t\tconfig_ok = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree_parsed_argv(&argv_array);\n\n\treturn config_ok;\n}\n\n\nstatic CheckStatus\nparse_db_connection(const char *db_connection)\n{\n\tCheckStatus status = CHECK_STATUS_UNKNOWN;\n\n\tint\t\t\tc = 0,\n\t\t\t\targc_item = 0;\n\tchar\t  **argv_array = NULL;\n\tint\t\t\toptindex = 0;\n\n\t/* We're only interested in this option */\n\tstruct option node_check_options[] =\n\t{\n\t\t{\"db-connection\", required_argument, NULL, 'c'},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\n\t/* Don't attempt to tokenise an empty string */\n\tif (!strlen(db_connection))\n\t{\n\t\treturn false;\n\t}\n\n\targc_item = parse_output_to_argv(db_connection, &argv_array);\n\n\t/* Reset getopt's optind variable */\n\toptind = 0;\n\n\t/* Prevent getopt from emitting errors */\n\topterr = 0;\n\n\twhile ((c = getopt_long(argc_item, argv_array, \"c:\", node_check_options,\n\t\t\t\t\t\t\t&optindex)) != -1)\n\t{\n\t\tswitch (c)\n\t\t{\n\t\t\t/* --db-connection */\n\t\t\tcase 'c':\n\t\t\t\t{\n\t\t\t\t\tstatus = parse_check_status(optarg);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree_parsed_argv(&argv_array);\n\n\treturn status;\n}\n\n\nvoid\ndo_standby_help(void)\n{\n\tprint_help_header();\n\n\tprintf(_(\"Usage:\\n\"));\n\tprintf(_(\"    %s [OPTIONS] standby clone\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] standby register\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] standby unregister\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] standby promote\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] standby follow\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] standby switchover\\n\"), progname());\n\n\tputs(\"\");\n\n\tprintf(_(\"STANDBY CLONE\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"standby clone\\\" clones a standby from the primary or an upstream node.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  -d, --dbname=conninfo               conninfo of the upstream node to use for cloning.\\n\"));\n\tprintf(_(\"  -c, --fast-checkpoint               force fast checkpoint\\n\"));\n\tprintf(_(\"  --copy-external-config-files[={samepath|pgdata}]\\n\" \\\n\t\t\t \"                                      copy configuration files located outside the \\n\" \\\n\t\t\t \"                                        data directory to the same path on the standby (default) or to the\\n\" \\\n\t\t\t \"                                        PostgreSQL data directory\\n\"));\n\tprintf(_(\"  --dry-run                           perform checks but don't actually clone the standby\\n\"));\n\tprintf(_(\"  --no-upstream-connection            when using Barman, do not connect to upstream node\\n\"));\n\tprintf(_(\"  -R, --remote-user=USERNAME          database server username for SSH operations (default: \\\"%s\\\")\\n\"), runtime_options.username);\n\tprintf(_(\"  --replication-user                  user to make replication connections with (optional, not usually required)\\n\"));\n\tprintf(_(\"  -S, --superuser=USERNAME            superuser to use, if repmgr user is not superuser\\n\"));\n\tprintf(_(\"  --upstream-conninfo                 \\\"primary_conninfo\\\" value to write in recovery.conf\\n\" \\\n\t\t\t \"                                        when the intended upstream server does not yet exist\\n\"));\n\tprintf(_(\"  --upstream-node-id                  ID of the upstream node to replicate from (optional, defaults to primary node)\\n\"));\n#if (PG_VERSION_NUM >= 130000)\n\tprintf(_(\"  --verify-backup                     verify a cloned node using the \\\"pg_verifybackup\\\" utility\\n\"));\n#endif\n\tprintf(_(\"  --without-barman                    do not clone from Barman even if configured\\n\"));\n\tprintf(_(\"  --replication-conf-only             generate replication configuration for a previously cloned instance\\n\"));\n\tprintf(_(\"  --recovery-min-apply-delay          set PostgreSQL configuration parameter \\\"recovery_min_apply_delay\\\"\\n\" \\\n\t\t\t \"                                      (overrides any setting in repmgr.conf)\\n\"));\n\n\tputs(\"\");\n\n\tprintf(_(\"STANDBY REGISTER\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"standby register\\\" registers the standby node.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  -F, --force                         overwrite an existing node record, or if primary connection\\n\" \\\n\t\t\t \"                                        parameters supplied, create record even if standby offline\\n\"));\n\tprintf(_(\"  --upstream-node-id                  ID of the upstream node to replicate from (optional)\\n\"));\n\tprintf(_(\"  --wait-start=VALUE                  wait for the standby to start (timeout in seconds, default %i)\\n\"), DEFAULT_WAIT_START);\n\n\tprintf(_(\"  --wait-sync[=VALUE]                 wait for the node record to synchronise to the standby\\n\" \\\n\t\t\t \"                                        (optional timeout in seconds)\\n\"));\n\n\tputs(\"\");\n\n\tprintf(_(\"STANDBY UNREGISTER\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"standby unregister\\\" unregisters an inactive standby node.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  --node-id                           ID of node to unregister (optional, used when the node to\\n\" \\\n\t\t\t \"                                         unregister is offline)\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"STANDBY PROMOTE\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"standby promote\\\" promotes a standby node to primary.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  --dry-run                           perform checks etc. but don't actually promote the node\\n\"));\n\tprintf(_(\"  -F, --force                         ignore warnings and continue anyway\\n\"));\n\tprintf(_(\"  --siblings-follow                   have other standbys follow new primary\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"STANDBY FOLLOW\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"standby follow\\\" instructs a standby node to follow a new primary.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  --dry-run                           perform checks but don't actually follow the new primary\\n\"));\n\tprintf(_(\"  --upstream-node-id                  node ID of the new primary\\n\"));\n\tprintf(_(\"  -W, --wait                          wait for a primary to appear\\n\"));\n\tputs(\"\");\n\n\n\tprintf(_(\"STANDBY SWITCHOVER\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"standby switchover\\\" promotes a standby node to primary, and demotes the previous primary to a standby.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  --always-promote                    promote standby even if behind original primary\\n\"));\n\tprintf(_(\"  --dry-run                           perform checks etc. but don't actually execute switchover\\n\"));\n\tprintf(_(\"  -F, --force                         ignore warnings and continue anyway\\n\"));\n\tprintf(_(\"  --force-rewind[=VALUE]              use \\\"pg_rewind\\\" to reintegrate the old primary if necessary\\n\"));\n\tprintf(_(\"                                        (PostgreSQL 9.4 - provide \\\"pg_rewind\\\" path)\\n\"));\n\n\tprintf(_(\"  -R, --remote-user=USERNAME          database server username for SSH operations (default: \\\"%s\\\")\\n\"), runtime_options.username);\n\tprintf(_(\"  -S, --superuser=USERNAME            superuser to use, if repmgr user is not superuser\\n\"));\n\tprintf(_(\"  --repmgrd-no-pause                  don't pause repmgrd\\n\"));\n\tprintf(_(\"  --siblings-follow                   have other standbys follow new primary\\n\"));\n\n\tputs(\"\");\n\n\tprintf(_(\"%s home page: <%s>\\n\"), \"repmgr\", REPMGR_URL);\n\n}\n"
        },
        {
          "name": "repmgr-action-standby.h",
          "type": "blob",
          "size": 1.3388671875,
          "content": "/*\n * repmgr-action-standby.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _REPMGR_ACTION_STANDBY_H_\n#define _REPMGR_ACTION_STANDBY_H_\n\nextern void do_standby_clone(void);\nextern void do_standby_register(void);\nextern void do_standby_unregister(void);\nextern void do_standby_promote(void);\nextern void do_standby_follow(void);\nextern void do_standby_switchover(void);\n\nextern void do_standby_help(void);\n\nextern bool do_standby_follow_internal(PGconn *primary_conn, PGconn *follow_target_conn, t_node_info *follow_target_node_record, PQExpBufferData *output, int general_error_code, int *error_code);\n\nvoid check_pg_backupapi_standby_clone_options(void);\n\n#endif\t\t\t\t\t\t\t/* _REPMGR_ACTION_STANDBY_H_ */\n"
        },
        {
          "name": "repmgr-action-witness.c",
          "type": "blob",
          "size": 15.5390625,
          "content": "/*\n * repmgr-action-witness.c\n *\n * Implements witness actions for the repmgr command line utility\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n#include <sys/stat.h>\n\n#include \"repmgr.h\"\n#include \"dirutil.h\"\n#include \"compat.h\"\n#include \"controldata.h\"\n\n#include \"repmgr-client-global.h\"\n#include \"repmgr-action-witness.h\"\n\nstatic char\t\trepmgr_user[MAXLEN];\nstatic char\t\trepmgr_db[MAXLEN];\n\nvoid\ndo_witness_register(void)\n{\n\tPGconn\t   *witness_conn = NULL;\n\tPGconn\t   *primary_conn = NULL;\n\tint\t\t\tprimary_node_id = UNKNOWN_NODE_ID;\n\tRecoveryType recovery_type = RECTYPE_UNKNOWN;\n\tExtensionStatus extension_status = REPMGR_UNKNOWN;\n\tNodeInfoList nodes = T_NODE_INFO_LIST_INITIALIZER;\n\tt_node_info node_record = T_NODE_INFO_INITIALIZER;\n\tt_node_info primary_node_record = T_NODE_INFO_INITIALIZER;\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\tbool\t\trecord_created = false;\n\n\tlog_info(_(\"connecting to witness node \\\"%s\\\" (ID: %i)\"),\n\t\t\t config_file_options.node_name,\n\t\t\t config_file_options.node_id);\n\n\twitness_conn = establish_db_connection_quiet(config_file_options.conninfo);\n\n\tif (PQstatus(witness_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to connect to witness node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t  config_file_options.node_name,\n\t\t\t\t  config_file_options.node_id);\n\t\tlog_detail(\"\\n%s\", PQerrorMessage(witness_conn));\n\t\tlog_hint(_(\"the witness node must be running before it can be registered\"));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* check witness node's recovery type */\n\trecovery_type = get_recovery_type(witness_conn);\n\n\tif (recovery_type == RECTYPE_STANDBY)\n\t{\n\t\tlog_error(_(\"provided node is a standby\"));\n\t\tlog_hint(_(\"a witness node must run on an independent primary server\"));\n\n\t\tPQfinish(witness_conn);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* connect to primary with provided parameters */\n\tlog_info(_(\"connecting to primary node\"));\n\n\t/*\n\t * Extract the repmgr user and database names from the conninfo string\n\t * provided in repmgr.conf\n\t */\n\tget_conninfo_value(config_file_options.conninfo, \"user\", repmgr_user);\n\tget_conninfo_value(config_file_options.conninfo, \"dbname\", repmgr_db);\n\n\tparam_set_ine(&source_conninfo, \"user\", repmgr_user);\n\tparam_set_ine(&source_conninfo, \"dbname\", repmgr_db);\n\n\t/* We need to connect to check configuration and copy it */\n\tprimary_conn = establish_db_connection_by_params(&source_conninfo, false);\n\n\tif (PQstatus(primary_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to connect to the primary node\"));\n\t\tlog_hint(_(\"a primary node must be configured before registering a witness node\"));\n\n\t\tPQfinish(witness_conn);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* check primary node's recovery type */\n\trecovery_type = get_recovery_type(primary_conn);\n\n\tif (recovery_type == RECTYPE_STANDBY)\n\t{\n\t\tlog_error(_(\"provided primary node is a standby\"));\n\t\tlog_hint(_(\"provide the connection details of the cluster's primary server\"));\n\n\t\tPQfinish(witness_conn);\n\t\tPQfinish(primary_conn);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\n\t/* check we can determine the primary node */\n\tprimary_node_id = get_primary_node_id(primary_conn);\n\n\tif (primary_node_id == UNKNOWN_NODE_ID)\n\t{\n\t\tlog_error(_(\"unable to determine the cluster's primary node\"));\n\t\tlog_hint(_(\"ensure the primary node connection details are correct and that it is registered\"));\n\t\tPQfinish(witness_conn);\n\t\tPQfinish(primary_conn);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\trecord_status = get_node_record(primary_conn, primary_node_id, &primary_node_record);\n\tPQfinish(primary_conn);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve record for primary node %i\"),\n\t\t\t\t  primary_node_id);\n\n\t\tPQfinish(witness_conn);\n\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * Reconnect to the primary node's conninfo - this will\n\t * protect against the situation where the witness connection\n\t * details were provided, and we're actually connected to the\n\t * witness server.\n\t */\n\n\tprimary_conn = establish_db_connection_quiet(primary_node_record.conninfo);\n\n\tif (PQstatus(primary_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to reconnect to the primary node (node %i)\"), primary_node_id);\n\t\tlog_detail(_(\"primary node's conninfo is \\\"%s\\\"\"), primary_node_record.conninfo);\n\n\t\tPQfinish(witness_conn);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* Sanity check witness node is not part of main cluster. */\n\tif (PQserverVersion(primary_conn) >= 90600 &&\n\t\tPQserverVersion(witness_conn) >= 90600)\n\t{\n\t\tuint64\t\tprimary_system_identifier = system_identifier(primary_conn);\n\t\tuint64\t\twitness_system_identifier = system_identifier(witness_conn);\n\n\t\tif (primary_system_identifier == witness_system_identifier &&\n\t\t\tprimary_system_identifier != UNKNOWN_SYSTEM_IDENTIFIER)\n\t\t{\n\t\t\tlog_error(_(\"witness node cannot be in the same cluster as the primary node\"));\n\t\t\tlog_detail(_(\"database system identifiers on primary node and provided witness node match (%lu)\"),\n\t\t\t\t\t   primary_system_identifier);\n\t\t\tlog_hint(_(\"the witness node must be created on a separate read/write node\"));\n\t\t\tPQfinish(witness_conn);\n\t\t\tPQfinish(primary_conn);\n\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\t/* create repmgr extension, if does not exist */\n\tif (runtime_options.dry_run == false &&  !create_repmgr_extension(witness_conn))\n\t{\n\t\tPQfinish(witness_conn);\n\t\tPQfinish(primary_conn);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/*\n\t * check if node record exists on primary, overwrite if -F/--force provided,\n\t * otherwise exit with error\n\t */\n\n\trecord_status = get_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\tconfig_file_options.node_id,\n\t\t\t\t\t\t\t\t\t&node_record);\n\n\tif (record_status == RECORD_FOUND)\n\t{\n\t\t/*\n\t\t * If node is not a witness, cowardly refuse to do anything, let the\n\t\t * user work out what's the correct thing to do.\n\t\t */\n\t\tif (node_record.type != WITNESS)\n\t\t{\n\t\t\tlog_error(_(\"node \\\"%s\\\" (ID: %i) is already registered as a %s node\"),\n\t\t\t\t\t  config_file_options.node_name,\n\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t  get_node_type_string(node_record.type));\n\t\t\tlog_hint(_(\"use \\\"repmgr %s unregister\\\" to remove a non-witness node record\"),\n\t\t\t\t\t get_node_type_string(node_record.type));\n\n\t\t\tPQfinish(witness_conn);\n\t\t\tPQfinish(primary_conn);\n\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tif (!runtime_options.force)\n\t\t{\n\t\t\tlog_error(_(\"witness node is already registered\"));\n\t\t\tlog_hint(_(\"use option -F/--force to reregister the node\"));\n\n\t\t\tPQfinish(witness_conn);\n\t\t\tPQfinish(primary_conn);\n\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\t/*\n\t * Check that an active node with the same node_name doesn't exist already\n\t */\n\n\trecord_status = get_node_record_by_name(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\tconfig_file_options.node_name,\n\t\t\t\t\t\t\t\t\t\t\t&node_record);\n\n\n\tif (record_status == RECORD_FOUND)\n\t{\n\t\tif (node_record.active == true && node_record.node_id != config_file_options.node_id)\n\t\t{\n\t\t\tlog_error(_(\"node %i exists already with node_name \\\"%s\\\"\"),\n\t\t\t\t\t  node_record.node_id,\n\t\t\t\t\t  config_file_options.node_name);\n\t\t\tPQfinish(primary_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\textension_status = get_repmgr_extension_status(witness_conn, NULL);\n\n\t/*\n\t * Check if the witness database already contains node records;\n\t * only do this if the extension is actually installed.\n\t */\n\tif (extension_status == REPMGR_INSTALLED\n\t || extension_status == REPMGR_OLD_VERSION_INSTALLED)\n\t{\n\t\t/*\n\t\t * if repmgr.nodes contains entries, exit with error unless\n\t\t * -F/--force provided (which will cause the existing records\n\t\t * to be overwritten)\n\t\t */\n\n\t\tif (get_all_node_records(witness_conn, &nodes) == false)\n\t\t{\n\t\t\t/* get_all_node_records() will display the error */\n\t\t\tPQfinish(witness_conn);\n\t\t\tPQfinish(primary_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tlog_verbose(LOG_DEBUG, \"%i node records found\", nodes.node_count);\n\n\t\tif (nodes.node_count > 0)\n\t\t{\n\t\t\tif (!runtime_options.force)\n\t\t\t{\n\t\t\t\tlog_error(_(\"witness node is already initialised and contains node records\"));\n\t\t\t\tlog_hint(_(\"use option -F/--force to reinitialise the node\"));\n\t\t\t\tPQfinish(primary_conn);\n\t\t\t\tPQfinish(witness_conn);\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\t\t}\n\n\t\tclear_node_info_list(&nodes);\n\t}\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"prerequisites for registering the witness node are met\"));\n\t\tPQfinish(primary_conn);\n\t\tPQfinish(witness_conn);\n\t\texit(SUCCESS);\n\t}\n\n\t/* create record on primary */\n\n\t/*\n\t * node record exists - update it (at this point we have already\n\t * established that -F/--force is in use)\n\t */\n\n\tinit_node_record(&node_record);\n\n\t/* these values are mandatory, setting them to anything else has no point */\n\tnode_record.type = WITNESS;\n\tnode_record.priority = 0;\n\tnode_record.upstream_node_id = primary_node_id;\n\n\tif (record_status == RECORD_FOUND)\n\t{\n\t\trecord_created = update_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t\"witness register\",\n\t\t\t\t\t\t\t\t\t\t\t&node_record);\n\t}\n\telse\n\t{\n\t\trecord_created = create_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t\"witness register\",\n\t\t\t\t\t\t\t\t\t\t\t&node_record);\n\t}\n\n\tif (record_created == false)\n\t{\n\t\tlog_error(_(\"unable to create or update node record on primary\"));\n\t\tPQfinish(primary_conn);\n\t\tPQfinish(witness_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* sync records from primary */\n\tif (witness_copy_node_records(primary_conn, witness_conn) == false)\n\t{\n\t\tlog_error(_(\"unable to copy repmgr node records from primary\"));\n\t\tPQfinish(primary_conn);\n\t\tPQfinish(witness_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t{\n\t\tPQExpBufferData event_details;\n\t\tinitPQExpBuffer(&event_details);\n\n\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t  _(\"witness registration succeeded; upstream node ID is %i\"),\n\t\t\t\t\t\t  node_record.upstream_node_id);\n\n\t\t/* create event */\n\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t  \"witness_register\",\n\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\ttermPQExpBuffer(&event_details);\n\t}\n\n\tPQfinish(primary_conn);\n\tPQfinish(witness_conn);\n\n\tlog_info(_(\"witness registration complete\"));\n\tlog_notice(_(\"witness node \\\"%s\\\" (ID: %i) successfully registered\"),\n\t\t\t   config_file_options.node_name, config_file_options.node_id);\n\n\treturn;\n}\n\n\nvoid\ndo_witness_unregister(void)\n{\n\tPGconn\t   *local_conn = NULL;\n\tPGconn\t   *primary_conn = NULL;\n\tt_node_info node_record = T_NODE_INFO_INITIALIZER;\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\tbool\t\tnode_record_deleted = false;\n\tbool\t\tlocal_node_available = true;\n\tint\t\t\twitness_node_id = UNKNOWN_NODE_ID;\n\n\tif (runtime_options.node_id != UNKNOWN_NODE_ID)\n\t{\n\t\t/* user has specified the witness node id */\n\t\twitness_node_id = runtime_options.node_id;\n\t}\n\telse\n\t{\n\t\t/* assume witness node is local node */\n\t\twitness_node_id = config_file_options.node_id;\n\t}\n\n\tlog_info(_(\"connecting to node \\\"%s\\\" (ID: %i)\"),\n\t\t\t config_file_options.node_name,\n\t\t\t config_file_options.node_id);\n\n\tlocal_conn = establish_db_connection_quiet(config_file_options.conninfo);\n\n\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t{\n\t\tif (!runtime_options.force)\n\t\t{\n\t\t\tlog_error(_(\"unable to connect to node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t  config_file_options.node_name,\n\t\t\t\t\t  config_file_options.node_id);\n\t\t\tlog_detail(\"\\n%s\", PQerrorMessage(local_conn));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tlog_notice(_(\"unable to connect to witness node \\\"%s\\\" (ID: %i), removing node record on cluster primary only\"),\n\t\t\t\t   config_file_options.node_name,\n\t\t\t\t   config_file_options.node_id);\n\t\tlocal_node_available = false;\n\t}\n\n\tif (local_node_available == true)\n\t{\n\t\tprimary_conn = get_primary_connection_quiet(local_conn, NULL, NULL);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Assume user has provided connection details for the primary server\n\t\t */\n\n\t\tprimary_conn = establish_db_connection_by_params(&source_conninfo, false);\n\t}\n\n\tif (PQstatus(primary_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to connect to primary\"));\n\t\tlog_detail(\"\\n%s\", PQerrorMessage(primary_conn));\n\n\t\tif (local_node_available == true)\n\t\t{\n\t\t\tPQfinish(local_conn);\n\t\t}\n\t\telse if (runtime_options.connection_param_provided == false)\n\t\t{\n\t\t\tlog_hint(_(\"provide connection details for the primary server\"));\n\t\t}\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* Check node exists and is really a witness */\n\trecord_status = get_node_record(primary_conn, witness_node_id, &node_record);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"no record found for node %i\"), witness_node_id);\n\n\t\tif (local_node_available == true)\n\t\t\tPQfinish(local_conn);\n\t\tPQfinish(primary_conn);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tif (node_record.type != WITNESS)\n\t{\n\t\t/*\n\t\t * The node (either explicitly provided with --node-id, or the local node)\n\t\t * is not a witness.\n\t\t *\n\t\t * TODO: scan node list and print hint about identity of known witness servers.\n\t\t */\n\t\tlog_error(_(\"node %i is not a witness node\"), config_file_options.node_id);\n\t\tlog_detail(_(\"node %i is a %s node\"), config_file_options.node_id, get_node_type_string(node_record.type));\n\n\t\tif (local_node_available == true)\n\t\t\tPQfinish(local_conn);\n\t\tPQfinish(primary_conn);\n\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"prerequisites for unregistering the witness node are met\"));\n\t\tif (local_node_available == true)\n\t\t\tPQfinish(local_conn);\n\t\tPQfinish(primary_conn);\n\n\t\texit(SUCCESS);\n\t}\n\n\tlog_info(_(\"unregistering witness node %i\"), witness_node_id);\n\tnode_record_deleted = delete_node_record(primary_conn,\n\t\t\t\t\t\t\t\t\t\t     witness_node_id);\n\n\tif (node_record_deleted == false)\n\t{\n\t\tPQfinish(primary_conn);\n\n\t\tif (local_node_available == true)\n\t\t\tPQfinish(local_conn);\n\t\tPQfinish(local_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\n\t{\n\t\tPQExpBufferData event_details;\n\t\tinitPQExpBuffer(&event_details);\n\n\t\tappendPQExpBufferStr(&event_details,\n\t\t\t\t\t\t\t _(\"witness unregistration succeeded\"));\n\n\t\t/* create event */\n\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  witness_node_id,\n\t\t\t\t\t\t\t\t  \"witness_unregister\",\n\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\ttermPQExpBuffer(&event_details);\n\t}\n\n\tPQfinish(primary_conn);\n\n\tif (local_node_available == true)\n\t\tPQfinish(local_conn);\n\n\tlog_info(_(\"witness unregistration complete\"));\n\tlog_detail(_(\"witness node with ID %i successfully unregistered\"),\n\t\t\t    witness_node_id);\n\n\treturn;\n}\n\n\nvoid do_witness_help(void)\n{\n\tprint_help_header();\n\n\tprintf(_(\"Usage:\\n\"));\n\tprintf(_(\"    %s [OPTIONS] witness register\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] witness unregister\\n\"), progname());\n\tputs(\"\");\n\tprintf(_(\"WITNESS REGISTER\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"witness register\\\" registers a witness node.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  Requires provision of connection information for the primary node,\\n\"));\n\tprintf(_(\"  typically usually just the host name.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  -h/--host                host name of the primary node\\n\"));\n\tprintf(_(\"  --dry-run                check prerequisites but don't make any changes\\n\"));\n\tprintf(_(\"  -F, --force              overwrite an existing node record\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"WITNESS UNREGISTER\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  \\\"witness unregister\\\" unregisters a witness node.\\n\"));\n\tputs(\"\");\n\tprintf(_(\"  --dry-run                check prerequisites but don't make any changes\\n\"));\n\tprintf(_(\"  -F, --force              unregister when witness node not running\\n\"));\n\tprintf(_(\"  --node-id                node ID of the witness node (provide if executing on\\n\"));\n\tprintf(_(\"                             another node)\\n\"));\n\n\tputs(\"\");\n\n\tprintf(_(\"%s home page: <%s>\\n\"), \"repmgr\", REPMGR_URL);\n}\n"
        },
        {
          "name": "repmgr-action-witness.h",
          "type": "blob",
          "size": 0.9453125,
          "content": "/*\n * repmgr-action-witness.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _REPMGR_ACTION_WITNESS_H_\n#define _REPMGR_ACTION_WITNESS_H_\n\nextern void do_witness_register(void);\nextern void do_witness_unregister(void);\n\nextern void do_witness_help(void);\n\n#endif\t\t\t\t\t\t\t/* _REPMGR_ACTION_WITNESS_H_ */\n"
        },
        {
          "name": "repmgr-client-global.h",
          "type": "blob",
          "size": 8.5283203125,
          "content": "/*\n * repmgr-client-global.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _REPMGR_CLIENT_GLOBAL_H_\n#define _REPMGR_CLIENT_GLOBAL_H_\n\n#include \"configfile.h\"\n\n/* values for --copy-external-config-files */\n#define CONFIG_FILE_SAMEPATH 1\n#define CONFIG_FILE_PGDATA 2\n\n/* default value for \"cluster event --limit\"*/\n#define CLUSTER_EVENT_LIMIT 20\n\n\n\ntypedef struct\n{\n\t/* configuration metadata */\n\tbool\t\tconninfo_provided;\n\tbool\t\tconnection_param_provided;\n\tbool\t\thost_param_provided;\n\tbool\t\tlimit_provided;\n\tbool\t\twait_provided;\n\n\t/* general configuration options */\n\tchar\t\tconfig_file[MAXPGPATH];\n\tbool\t\tdry_run;\n\tbool\t\tforce;\n\tchar\t\tpg_bindir[MAXLEN];\t/* overrides setting in repmgr.conf */\n\tint\t\t\twait;\n\tbool\t\tno_wait;\n\tbool\t\tcompact;\n\tbool\t\tdetail;\n\tbool\t\tdump_config;\n\n\t/* logging options */\n\tchar\t\tlog_level[MAXLEN];\t/* overrides setting in repmgr.conf */\n\tbool\t\tlog_to_file;\n\tbool\t\tquiet;\n\tbool\t\tterse;\n\tbool\t\tverbose;\n\n\t/* output options */\n\tbool\t\tcsv;\n\tbool\t\tnagios;\n\tbool\t\toptformat;\n\n\t/* standard connection options */\n\tchar\t\tdbname[MAXLEN];\n\tchar\t\thost[MAXLEN];\n\tchar\t\tusername[MAXLEN];\n\tchar\t\tport[MAXLEN];\n\n\t/* other connection options */\n\tchar\t\tremote_user[MAXLEN];\n\tchar\t\tsuperuser[MAXLEN];\n\n\t/* general node options */\n\tint\t\t\tnode_id;\n\tchar\t\tnode_name[NAMEDATALEN];\n\tchar\t\tdata_dir[MAXPGPATH];\n\tint\t\t\tremote_node_id;\n\n\t/* \"standby clone\" options */\n\tbool\t\tcopy_external_config_files;\n\tint\t\t\tcopy_external_config_files_destination;\n\tbool\t\tfast_checkpoint;\n\tbool\t\trsync_only;\n\tbool\t\tno_upstream_connection;\n\tchar\t\trecovery_min_apply_delay[MAXLEN];\t/* overrides setting in repmgr.conf */\n\tchar\t\treplication_user[MAXLEN];\n\tchar\t\tupstream_conninfo[MAXLEN];\n\tbool\t\twithout_barman;\n\tbool\t\treplication_conf_only;\n\tbool\t\tverify_backup;\n\n\t/* \"standby clone\"/\"standby follow\" options */\n\tint\t\t\tupstream_node_id;\n\n\t/* \"standby register\" options */\n\tbool\t\twait_register_sync;\n\tint\t\t\twait_register_sync_seconds;\n\tint\t\t\twait_start;\n\n\t/* \"standby switchover\" options */\n\tbool\t\talways_promote;\n\tbool\t\tforce_rewind_used;\n\tchar\t\tforce_rewind_path[MAXPGPATH];\n\tbool\t\tsiblings_follow;\n\tbool\t\trepmgrd_no_pause;\n\tbool\t\trepmgrd_force_unpause;\n\n\t/* \"node status\" options */\n\tbool\t\tis_shutdown_cleanly;\n\n\t/* \"node check\" options */\n\tbool\t\tarchive_ready;\n\tbool\t\tdownstream;\n\tbool\t\tupstream;\n\tbool\t\treplication_lag;\n\tbool\t\trole;\n\tbool\t\tslots;\n\tbool\t\tmissing_slots;\n\tbool\t\thas_passfile;\n\tbool\t\treplication_connection;\n\tbool\t\trepmgrd;\n\tbool\t\tdata_directory_config;\n\tbool\t\treplication_config_owner;\n\tbool\t\tdb_connection;\n\n\t/* \"node rejoin\" options */\n\tchar\t\tconfig_files[MAXLEN];\n\n\t/* \"node service\" options */\n\tchar\t\taction[MAXLEN];\n\tbool\t\tcheck;\n\tbool\t\tlist_actions;\n\tbool\t\tcheckpoint;\n\n\t/* \"cluster event\" options */\n\tbool\t\tall;\n\tchar\t\tevent[MAXLEN];\n\tint\t\t\tlimit;\n\n\t/* \"cluster cleanup\" options */\n\tint\t\t\tkeep_history;\n\n\t/* following options for internal use */\n\tchar\t\tconfig_archive_dir[MAXPGPATH];\n\tOutputMode\toutput_mode; /* set through provision of --csv, --nagios or --optformat */\n\tbool\t\tdisable_wal_receiver;\n\tbool\t\tenable_wal_receiver;\n} t_runtime_options;\n\n#define T_RUNTIME_OPTIONS_INITIALIZER { \\\n\t\t/* configuration metadata */ \\\n\t\tfalse, false, false, false, false,\t\\\n\t\t/* general configuration options */\t\\\n\t\t\"\", false, false, \"\", -1, false, false, false, false, \\\n\t\t/* logging options */ \\\n\t\t\"\", false, false, false, false,\t\\\n\t\t/* output options */ \\\n\t\tfalse, false, false,  \\\n\t\t/* database connection options */ \\\n\t\t\"\", \"\", \"\",\t\"\", \\\n\t\t/* other connection options */ \\\n\t\t\"\",\t\"\", \\\n\t\t/* general node options */ \\\n\t\tUNKNOWN_NODE_ID, \"\", \"\", UNKNOWN_NODE_ID, \\\n\t\t/* \"standby clone\" options */ \\\n\t\tfalse, CONFIG_FILE_SAMEPATH, false, false, false, \"\", \"\", \"\", \\\n\t\tfalse, false, false, \\\n\t\t/* \"standby clone\"/\"standby follow\" options */ \\\n\t\tNO_UPSTREAM_NODE, \\\n\t\t/* \"standby register\" options */ \\\n\t\tfalse, -1, DEFAULT_WAIT_START,   \\\n\t\t/* \"standby switchover\" options */ \\\n\t\tfalse, false, \"\", false, false, false,\t\\\n\t\t/* \"node status\" options */ \\\n\t\tfalse, \\\n\t\t/* \"node check\" options */ \\\n\t\tfalse, false, false, false, false, false, false, false,\tfalse, false, false, false, false, \\\n\t\t/* \"node rejoin\" options */ \\\n\t\t\"\", \\\n\t\t/* \"node service\" options */ \\\n\t\t\"\", false, false, false,  \\\n\t\t/* \"cluster event\" options */ \\\n\t\tfalse, \"\", CLUSTER_EVENT_LIMIT,\t\\\n\t\t/* \"cluster cleanup\" options */ \\\n\t\t0, \\\n\t\t/* following options for internal use */ \\\n\t\t\"/tmp\", OM_TEXT, false, false \\\n}\n\n\ntypedef enum\n{\n\tbarman,\n\tpg_basebackup,\n\tpg_backupapi\n} standy_clone_mode;\n\ntypedef enum\n{\n\tACTION_UNKNOWN = -1,\n\tACTION_NONE,\n\tACTION_START,\n\tACTION_STOP,\n\tACTION_STOP_WAIT,\n\tACTION_RESTART,\n\tACTION_RELOAD,\n\tACTION_PROMOTE\n} t_server_action;\n\n\ntypedef enum\n{\n\tUSER_TYPE_UNKNOWN = -1,\n\tREPMGR_USER,\n\tREPLICATION_USER_OPT,\n\tREPLICATION_USER_NODE,\n\tSUPERUSER\n} t_user_type;\n\ntypedef enum\n{\n\tJOIN_UNKNOWN = -1,\n\tJOIN_SUCCESS,\n\tJOIN_COMMAND_FAIL,\n\tJOIN_FAIL_NO_PING,\n\tJOIN_FAIL_NO_REPLICATION\n} standy_join_status;\n\ntypedef enum\n{\n\tREMOTE_ERROR_UNKNOWN = -1,\n\tREMOTE_ERROR_NONE,\n\tREMOTE_ERROR_DB_CONNECTION,\n\tREMOTE_ERROR_CONNINFO_PARSE\n} t_remote_error_type;\n\ntypedef struct ColHeader\n{\n\tchar\t\ttitle[MAXLEN];\n\tint\t\t\tmax_length;\n\tint\t\t\tcur_length;\n\tbool\t\tdisplay;\n} ColHeader;\n\n\n\n/* globally available configuration structures */\nextern t_runtime_options runtime_options;\nextern t_conninfo_param_list source_conninfo;\nextern t_node_info target_node_info;\n\n/* global variables */\nextern bool config_file_required;\nextern char pg_bindir[MAXLEN];\n\n/* global functions */\nextern int\tcheck_server_version(PGconn *conn, char *server_type, bool exit_on_error, char *server_version_string);\nextern bool create_repmgr_extension(PGconn *conn);\nextern int\ttest_ssh_connection(char *host, char *remote_user);\n\nextern standy_clone_mode get_standby_clone_mode(void);\n\nextern int copy_remote_files(char *host, char *remote_user, char *remote_path,\n\t\t\t\t  char *local_path, bool is_directory, int server_version_num);\n\nextern void print_error_list(ItemList *error_list, int log_level);\n\nextern void make_pg_path(PQExpBufferData *buf, const char *file);\n\nextern void get_superuser_connection(PGconn **conn, PGconn **superuser_conn, PGconn **privileged_conn);\n\nextern void make_remote_repmgr_path(PQExpBufferData *outputbuf, t_node_info *remote_node_record);\nextern void make_repmgrd_path(PQExpBufferData *output_buf);\n\n/* display functions */\nextern bool format_node_status(t_node_info *node_info, PQExpBufferData *node_status, PQExpBufferData *upstream, ItemList *warnings);\nextern void print_help_header(void);\nextern void print_status_header(int cols, ColHeader *headers);\n\n/* server control functions */\nextern void get_server_action(t_server_action action, char *script, char *data_dir);\nextern bool data_dir_required_for_action(t_server_action action);\nextern void get_node_config_directory(char *config_dir_buf);\nextern void get_node_data_directory(char *data_dir_buf);\nextern void init_node_record(t_node_info *node_record);\nextern bool can_use_pg_rewind(PGconn *conn, const char *data_directory, PQExpBufferData *reason);\nextern void make_standby_signal_path(const char *data_dir, char *buf);\nextern bool write_standby_signal(const char *data_dir);\n\nextern bool create_replication_slot(PGconn *conn, char *slot_name, t_node_info *upstream_node_record, PQExpBufferData *error_msg);\nextern bool drop_replication_slot_if_exists(PGconn *conn, int node_id, char *slot_name);\n\nextern standy_join_status check_standby_join(PGconn *primary_conn, t_node_info *primary_node_record, t_node_info *standby_node_record);\nextern bool check_replication_slots_available(int node_id, PGconn* conn);\nextern bool check_node_can_attach(TimeLineID local_tli, XLogRecPtr local_xlogpos, PGconn *follow_target_conn, t_node_info *follow_target_node_record, bool is_rejoin);\nextern bool check_replication_config_owner(int pg_version, const char *data_directory, PQExpBufferData *error_msg, PQExpBufferData *detail_msg);\n\nextern void check_shared_library(PGconn *conn);\nextern bool is_repmgrd_running(PGconn *conn);\nextern int parse_repmgr_version(const char *version_string);\n\n#endif\t\t\t\t\t\t\t/* _REPMGR_CLIENT_GLOBAL_H_ */\n"
        },
        {
          "name": "repmgr-client.c",
          "type": "blob",
          "size": 116.1005859375,
          "content": "/*\n * repmgr-client.c - Command interpreter for the repmgr package\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This module is a command-line utility to easily setup a cluster of\n * hot standby servers for an HA environment\n *\n * Commands implemented are:\n *\n * [ PRIMARY | MASTER ] REGISTER\n * [ PRIMARY | MASTER ] UNREGISTER\n *\n * STANDBY CLONE\n * STANDBY REGISTER\n * STANDBY UNREGISTER\n * STANDBY PROMOTE\n * STANDBY FOLLOW\n * STANDBY SWITCHOVER\n *\n * CLUSTER SHOW\n * CLUSTER EVENT\n * CLUSTER CROSSCHECK\n * CLUSTER MATRIX\n * CLUSTER CLEANUP\n *\n * NODE STATUS\n * NODE CHECK\n * NODE REJOIN\n * NODE SERVICE\n * NODE CONTROL\n *\n * SERVICE STATUS\n * SERVICE PAUSE\n * SERVICE UNPAUSE\n *\n * DAEMON START\n * DAEMON STOP\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <signal.h>\n\n\n#include \"repmgr.h\"\n#include \"compat.h\"\n#include \"controldata.h\"\n#include \"repmgr-client.h\"\n#include \"repmgr-client-global.h\"\n#include \"repmgr-action-primary.h\"\n#include \"repmgr-action-standby.h\"\n#include \"repmgr-action-witness.h\"\n#include \"repmgr-action-node.h\"\n#include \"repmgr-action-cluster.h\"\n#include \"repmgr-action-service.h\"\n#include \"repmgr-action-daemon.h\"\n\n#if (PG_VERSION_NUM >= 170000)\n#include <common/file_utils.h> \t\t/* for PG_TEMP_FILE_PREFIX */\n#else\n#include <storage/fd.h>\t\t\t/* for PG_TEMP_FILE_PREFIX */\n#endif\n\n/* globally available variables *\n * ============================ */\n\nt_runtime_options runtime_options = T_RUNTIME_OPTIONS_INITIALIZER;\n\n\n/* conninfo params for the node we're operating on */\nt_conninfo_param_list source_conninfo = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\nbool\t\tconfig_file_required = true;\nchar\t\tpg_bindir[MAXPGPATH] = \"\";\n\n/*\n * if --node-id/--node-name provided, place that node's record here\n * for later use\n */\nt_node_info target_node_info = T_NODE_INFO_INITIALIZER;\n\n/* set by the first call to _determine_replication_slot_user() */\nstatic t_user_type ReplicationSlotUser = USER_TYPE_UNKNOWN;\n\n/* Collate command line errors and warnings here for friendlier reporting */\nstatic ItemList cli_errors = {NULL, NULL};\nstatic ItemList cli_warnings = {NULL, NULL};\n\n\nstatic void _determine_replication_slot_user(PGconn *conn,\n\t\t\t\t\t\t\t\t\t\t\t t_node_info *upstream_node_record,\n\t\t\t\t\t\t\t\t\t\t\t char **replication_user);\n\nstatic PGconn *_get_replication_slot_connection(PGconn *conn,\n\t\t\t\t\t\t\t\t\t\t\t\tchar *replication_user,\n\t\t\t\t\t\t\t\t\t\t\t\tbool *use_replication_protocol);\n\nint\nmain(int argc, char **argv)\n{\n\tt_conninfo_param_list default_conninfo = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\n\tint\t\t\toptindex = 0;\n\tint\t\t\tc;\n\n\tchar\t   *repmgr_command = NULL;\n\tchar\t   *repmgr_action = NULL;\n\tbool\t\tvalid_repmgr_command_found = true;\n\tint\t\t\taction = NO_ACTION;\n\tchar\t   *dummy_action = \"\";\n\n\tbool\t\thelp_option = false;\n\tbool\t\toption_error_found = false;\n\n\tset_progname(argv[0]);\n\n\t/*\n\t * Tell the logger we're a command-line program - this will ensure any\n\t * output logged before the logger is initialized will be formatted\n\t * correctly. Can be overridden with \"--log-to-file\".\n\t */\n\tlogger_output_mode = OM_COMMAND_LINE;\n\n\t/*\n\t * Initialize and pre-populate conninfo parameters; these will be\n\t * overwritten if matching command line parameters are provided.\n\t *\n\t * Only some actions will need these, but we need to do this before the\n\t * command line is parsed.\n\t *\n\t * Note: PQconndefaults() does not provide a default value for \"dbname\",\n\t * but if none is provided will default to \"username\" when the connection\n\t * is made. We won't set \"dbname\" here if no default available, as that\n\t * would break the libpq behaviour if non-default username is provided.\n\t */\n\tinitialize_conninfo_params(&default_conninfo, true);\n\n\tfor (c = 0; c < default_conninfo.size && default_conninfo.keywords[c]; c++)\n\t{\n\t\tif (strcmp(default_conninfo.keywords[c], \"host\") == 0 &&\n\t\t\t(default_conninfo.values[c] != NULL))\n\t\t{\n\t\t\tstrncpy(runtime_options.host, default_conninfo.values[c], MAXLEN);\n\t\t}\n\t\telse if (strcmp(default_conninfo.keywords[c], \"hostaddr\") == 0 &&\n\t\t\t\t (default_conninfo.values[c] != NULL))\n\t\t{\n\t\t\tstrncpy(runtime_options.host, default_conninfo.values[c], MAXLEN);\n\t\t}\n\t\telse if (strcmp(default_conninfo.keywords[c], \"port\") == 0 &&\n\t\t\t\t (default_conninfo.values[c] != NULL))\n\t\t{\n\t\t\tstrncpy(runtime_options.port, default_conninfo.values[c], MAXLEN);\n\t\t}\n\t\telse if (strcmp(default_conninfo.keywords[c], \"dbname\") == 0 &&\n\t\t\t\t (default_conninfo.values[c] != NULL))\n\t\t{\n\t\t\tstrncpy(runtime_options.dbname, default_conninfo.values[c], MAXLEN);\n\t\t}\n\t\telse if (strcmp(default_conninfo.keywords[c], \"user\") == 0 &&\n\t\t\t\t (default_conninfo.values[c] != NULL))\n\t\t{\n\t\t\tstrncpy(runtime_options.username, default_conninfo.values[c], MAXLEN);\n\t\t}\n\t}\n\tfree_conninfo_params(&default_conninfo);\n\n\tinitialize_conninfo_params(&source_conninfo, false);\n\n\t/* set default user for -R/--remote-user */\n\t{\n\t\tstruct passwd *pw = getpwuid(geteuid());\n\n\t\tif (pw == NULL)\n\t\t{\n\t\t\tfprintf(stderr, _(\"could not get current user name: %s\\n\"), strerror(errno));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tstrncpy(runtime_options.username, pw->pw_name, MAXLEN);\n\t}\n\n\t/* Make getopt emit errors */\n\topterr = 1;\n\n\twhile ((c = getopt_long(argc, argv, \"?Vb:f:FwWd:h:p:U:R:S:D:ck:L:qtvC:\", long_options,\n\t\t\t\t\t\t\t&optindex)) != -1)\n\t{\n\t\t/*\n\t\t * NOTE: some integer parameters (e.g. -p/--port) are stored\n\t\t * internally as strings. We use repmgr_atoi() to check these but\n\t\t * discard the returned integer; repmgr_atoi() will append the error\n\t\t * message to the provided list.\n\t\t */\n\t\tswitch (c)\n\t\t{\n\t\t\t\t/*\n\t\t\t\t * Options which cause repmgr to exit in this block; these are\n\t\t\t\t * the only ones which can be executed as root user\n\t\t\t\t */\n\t\t\tcase OPT_HELP:\t\t/* --help */\n\t\t\t\thelp_option = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/* -V/--version */\n\t\t\tcase 'V':\n\n\t\t\t\t/*\n\t\t\t\t * in contrast to repmgr3 and earlier, we only display the\n\t\t\t\t * repmgr version as it's not specific to a particular\n\t\t\t\t * PostgreSQL version\n\t\t\t\t */\n\t\t\t\tprintf(\"%s %s\\n\", progname(), REPMGR_VERSION);\n\t\t\t\texit(SUCCESS);\n\n\t\t\t\t/* --version-number */\n\t\t\tcase OPT_VERSION_NUMBER:\n\t\t\t\tprintf(\"%i\\n\", REPMGR_VERSION_NUM);\n\t\t\t\texit(SUCCESS);\n\n\t\t\t\t/*------------------------------\n\t\t\t\t * general configuration options\n\t\t\t\t *------------------------------\n\t\t\t\t */\n\n\t\t\t\t/* -b/--pg_bindir */\n\t\t\tcase 'b':\n\t\t\t\tstrncpy(runtime_options.pg_bindir, optarg, MAXLEN);\n\t\t\t\tbreak;\n\n\t\t\t\t/* -f/--config-file */\n\t\t\tcase 'f':\n\t\t\t\tstrncpy(runtime_options.config_file, optarg, MAXLEN);\n\t\t\t\tbreak;\n\n\t\t\t\t/* --dry-run */\n\t\t\tcase OPT_DRY_RUN:\n\t\t\t\truntime_options.dry_run = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/* -F/--force */\n\t\t\tcase 'F':\n\t\t\t\truntime_options.force = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/* --replication-user (primary/standby register only) */\n\t\t\tcase OPT_REPLICATION_USER:\n\t\t\t\tstrncpy(runtime_options.replication_user, optarg, MAXLEN);\n\t\t\t\tbreak;\n\n\t\t\t\t/* -w/--wait */\n\t\t\tcase 'w':\n\t\t\t\truntime_options.wait_provided = true;\n\t\t\t\tif (optarg != NULL)\n\t\t\t\t{\n\t\t\t\t\truntime_options.wait = repmgr_atoi(optarg, \"--wait\", &cli_errors, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\t/* -W/--no-wait */\n\t\t\tcase 'W':\n\t\t\t\truntime_options.no_wait = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/* --compact */\n\t\t\tcase OPT_COMPACT:\n\t\t\t\truntime_options.compact = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/* --detail */\n\t\t\tcase OPT_DETAIL:\n\t\t\t\truntime_options.detail = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/* --dump-config */\n\t\t\tcase OPT_DUMP_CONFIG:\n\t\t\t\truntime_options.dump_config = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/*----------------------------\n\t\t\t\t * database connection options\n\t\t\t\t *----------------------------\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * These are the standard database connection options; with\n\t\t\t\t * the exception of -d/--dbname (which could be a conninfo\n\t\t\t\t * string) we'll also set these values in \"source_conninfo\"\n\t\t\t\t * (overwriting preset values from environment variables).\n\t\t\t\t */\n\t\t\t\t/* -d/--dbname */\n\t\t\tcase 'd':\n\t\t\t\tstrncpy(runtime_options.dbname, optarg, MAXLEN);\n\n\t\t\t\t/*\n\t\t\t\t * dbname will be set in source_conninfo later after checking\n\t\t\t\t * if it's a conninfo string\n\t\t\t\t */\n\t\t\t\truntime_options.connection_param_provided = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/* -h/--host */\n\t\t\tcase 'h':\n\t\t\t\tstrncpy(runtime_options.host, optarg, MAXLEN);\n\t\t\t\tparam_set(&source_conninfo, \"host\", optarg);\n\t\t\t\truntime_options.connection_param_provided = true;\n\t\t\t\truntime_options.host_param_provided = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'p':\n\t\t\t\t/*\n\t\t\t\t * minimum TCP port number is 1; in practice PostgreSQL\n\t\t\t\t * won't be running on a privileged port, but we don't want\n\t\t\t\t * to be concerned with that level of checking\n\t\t\t\t */\n\t\t\t\t(void) repmgr_atoi(optarg, \"-p/--port\", &cli_errors, 1);\n\t\t\t\tparam_set(&source_conninfo, \"port\", optarg);\n\t\t\t\tstrncpy(runtime_options.port,\n\t\t\t\t\t\toptarg,\n\t\t\t\t\t\tMAXLEN);\n\t\t\t\truntime_options.connection_param_provided = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/* -U/--user */\n\t\t\tcase 'U':\n\t\t\t\tstrncpy(runtime_options.username, optarg, MAXLEN);\n\t\t\t\tparam_set(&source_conninfo, \"user\", optarg);\n\t\t\t\truntime_options.connection_param_provided = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/*-------------------------\n\t\t\t\t * other connection options\n\t\t\t\t *-------------------------\n\t\t\t\t */\n\n\t\t\t\t/* -R/--remote_user */\n\t\t\tcase 'R':\n\t\t\t\tstrncpy(runtime_options.remote_user, optarg, MAXLEN);\n\t\t\t\tbreak;\n\n\t\t\t\t/* -S/--superuser */\n\t\t\tcase 'S':\n\t\t\t\tstrncpy(runtime_options.superuser, optarg, MAXLEN);\n\t\t\t\tbreak;\n\n\t\t\t\t/*-------------\n\t\t\t\t * node options\n\t\t\t\t *-------------\n\t\t\t\t */\n\n\t\t\t\t/* -D/--pgdata/--data-dir */\n\t\t\tcase 'D':\n\t\t\t\tstrncpy(runtime_options.data_dir, optarg, MAXPGPATH);\n\t\t\t\tbreak;\n\n\t\t\t\t/* --node-id */\n\t\t\tcase OPT_NODE_ID:\n\t\t\t\truntime_options.node_id = repmgr_atoi(optarg, \"--node-id\", &cli_errors, MIN_NODE_ID);\n\t\t\t\tbreak;\n\n\t\t\t\t/* --node-name */\n\t\t\tcase OPT_NODE_NAME:\n\t\t\t{\n\t\t\t\tif (strlen(optarg) < sizeof(runtime_options.node_name))\n\t\t\t\t\tstrncpy(runtime_options.node_name, optarg, sizeof(runtime_options.node_name));\n\t\t\t\telse\n\t\t\t\t\titem_list_append_format(&cli_errors,\n\t\t\t\t\t\t\t\t\t\t\t_(\"value for \\\"--node-name\\\" must contain fewer than %lu characters\"),\n\t\t\t\t\t\t\t\t\t\t\tsizeof(runtime_options.node_name));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t/* --remote-node-id */\n\t\t\tcase OPT_REMOTE_NODE_ID:\n\t\t\t\truntime_options.remote_node_id = repmgr_atoi(optarg, \"--remote-node-id\", &cli_errors, MIN_NODE_ID);\n\t\t\t\tbreak;\n\n\t\t\t\t/*\n\t\t\t\t * standby options * ---------------\n\t\t\t\t */\n\n\t\t\t\t/* --upstream-node-id */\n\t\t\tcase OPT_UPSTREAM_NODE_ID:\n\t\t\t\truntime_options.upstream_node_id = repmgr_atoi(optarg, \"--upstream-node-id\", &cli_errors, MIN_NODE_ID);\n\t\t\t\tbreak;\n\n\t\t\t\t/*------------------------\n\t\t\t\t * \"standby clone\" options\n\t\t\t\t *------------------------\n\t\t\t\t */\n\n\t\t\t\t/* -c/--fast-checkpoint */\n\t\t\tcase 'c':\n\t\t\t\truntime_options.fast_checkpoint = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/* --copy-external-config-files(=[samepath|pgdata]) */\n\t\t\tcase OPT_COPY_EXTERNAL_CONFIG_FILES:\n\t\t\t\truntime_options.copy_external_config_files = true;\n\t\t\t\tif (optarg != NULL)\n\t\t\t\t{\n\t\t\t\t\tif (strcmp(optarg, \"samepath\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\truntime_options.copy_external_config_files_destination = CONFIG_FILE_SAMEPATH;\n\t\t\t\t\t}\n\t\t\t\t\t/* allow \"data_directory\" as synonym for \"pgdata\" */\n\t\t\t\t\telse if (strcmp(optarg, \"pgdata\") == 0 || strcmp(optarg, \"data_directory\") == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\truntime_options.copy_external_config_files_destination = CONFIG_FILE_PGDATA;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\titem_list_append(&cli_errors,\n\t\t\t\t\t\t\t\t\t\t _(\"value provided for \\\"--copy-external-config-files\\\" must be \\\"samepath\\\" or \\\"pgdata\\\"\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\t/* --no-upstream-connection */\n\t\t\tcase OPT_NO_UPSTREAM_CONNECTION:\n\t\t\t\truntime_options.no_upstream_connection = true;\n\t\t\t\tbreak;\n\n\n\t\t\tcase OPT_UPSTREAM_CONNINFO:\n\t\t\t\tstrncpy(runtime_options.upstream_conninfo, optarg, MAXLEN);\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_WITHOUT_BARMAN:\n\t\t\t\truntime_options.without_barman = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_REPLICATION_CONF_ONLY:\n\t\t\t\truntime_options.replication_conf_only = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/* --recovery-min-apply-delay */\n\t\t\tcase OPT_RECOVERY_MIN_APPLY_DELAY:\n\t\t\t\tstrncpy(runtime_options.recovery_min_apply_delay, optarg, sizeof(runtime_options.recovery_min_apply_delay));\n\t\t\t\tbreak;\n\n\t\t\t\t/* --verify-backup */\n\t\t\tcase OPT_VERIFY_BACKUP:\n\t\t\t\truntime_options.verify_backup = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/*---------------------------\n\t\t\t\t * \"standby register\" options\n\t\t\t\t *---------------------------\n\t\t\t\t */\n\n\t\t\tcase OPT_WAIT_START:\n\t\t\t\truntime_options.wait_start = repmgr_atoi(optarg, \"--wait-start\", &cli_errors, 0);\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_WAIT_SYNC:\n\t\t\t\truntime_options.wait_register_sync = true;\n\t\t\t\tif (optarg != NULL)\n\t\t\t\t{\n\t\t\t\t\truntime_options.wait_register_sync_seconds = repmgr_atoi(optarg, \"--wait-sync\", &cli_errors, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\t/*-----------------------------\n\t\t\t\t * \"standby switchover\" options\n\t\t\t\t *-----------------------------\n\t\t\t\t */\n\n\t\t\tcase OPT_ALWAYS_PROMOTE:\n\t\t\t\truntime_options.always_promote = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_FORCE_REWIND:\n\t\t\t\truntime_options.force_rewind_used = true;\n\n\t\t\t\tif (optarg != NULL)\n\t\t\t\t{\n\t\t\t\t\tstrncpy(runtime_options.force_rewind_path, optarg, MAXPGPATH);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_SIBLINGS_FOLLOW:\n\t\t\t\truntime_options.siblings_follow = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_REPMGRD_NO_PAUSE:\n\t\t\t\truntime_options.repmgrd_no_pause = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_REPMGRD_FORCE_UNPAUSE:\n\t\t\t\truntime_options.repmgrd_force_unpause = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/*----------------------\n\t\t\t\t * \"node status\" options\n\t\t\t\t *----------------------\n\t\t\t\t */\n\n\t\t\tcase OPT_IS_SHUTDOWN_CLEANLY:\n\t\t\t\truntime_options.is_shutdown_cleanly = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/*---------------------\n\t\t\t\t * \"node check\" options\n\t\t\t\t *--------------------\n\t\t\t\t */\n\t\t\tcase OPT_ARCHIVE_READY:\n\t\t\t\truntime_options.archive_ready = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_DOWNSTREAM:\n\t\t\t\truntime_options.downstream = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_UPSTREAM:\n\t\t\t\truntime_options.upstream = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_REPLICATION_LAG:\n\t\t\t\truntime_options.replication_lag = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_ROLE:\n\t\t\t\truntime_options.role = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_SLOTS:\n\t\t\t\truntime_options.slots = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_MISSING_SLOTS:\n\t\t\t\truntime_options.missing_slots = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_HAS_PASSFILE:\n\t\t\t\truntime_options.has_passfile = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_REPL_CONN:\n\t\t\t\truntime_options.replication_connection = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_DATA_DIRECTORY_CONFIG:\n\t\t\t\truntime_options.data_directory_config = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_REPMGRD:\n\t\t\t\truntime_options.repmgrd = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_REPLICATION_CONFIG_OWNER:\n\t\t\t\truntime_options.replication_config_owner = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_DB_CONNECTION:\n\t\t\t\truntime_options.db_connection = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/*--------------------\n\t\t\t\t * \"node rejoin\" options\n\t\t\t\t *--------------------\n\t\t\t\t */\n\t\t\tcase OPT_CONFIG_FILES:\n\t\t\t\tstrncpy(runtime_options.config_files, optarg, MAXLEN);\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_CONFIG_ARCHIVE_DIR:\n\t\t\t\t/* TODO: check this is an absolute path */\n\t\t\t\tstrncpy(runtime_options.config_archive_dir, optarg, MAXPGPATH);\n\t\t\t\tbreak;\n\n\t\t\t\t/*-----------------------\n\t\t\t\t * \"node service\" options\n\t\t\t\t *-----------------------\n\t\t\t\t */\n\n\t\t\t\t/* --action (repmgr node service --action) */\n\t\t\tcase OPT_ACTION:\n\t\t\t\tstrncpy(runtime_options.action, optarg, MAXLEN);\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_LIST_ACTIONS:\n\t\t\t\truntime_options.list_actions = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_CHECKPOINT:\n\t\t\t\truntime_options.checkpoint = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/*------------------------\n\t\t\t\t * \"cluster event\" options\n\t\t\t\t *------------------------\n\t\t\t\t */\n\n\t\t\tcase OPT_EVENT:\n\t\t\t\tstrncpy(runtime_options.event, optarg, MAXLEN);\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_LIMIT:\n\t\t\t\truntime_options.limit = repmgr_atoi(optarg, \"--limit\", &cli_errors, 1);\n\t\t\t\truntime_options.limit_provided = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_ALL:\n\t\t\t\truntime_options.all = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/*------------------------\n\t\t\t\t * \"cluster cleanup\" options\n\t\t\t\t *------------------------\n\t\t\t\t */\n\n\t\t\t\t/* -k/--keep-history */\n\t\t\tcase 'k':\n\t\t\t\truntime_options.keep_history = repmgr_atoi(optarg, \"-k/--keep-history\", &cli_errors, 0);\n\t\t\t\tbreak;\n\n\t\t\t\t/*----------------\n\t\t\t\t * logging options\n\t\t\t\t *----------------\n\t\t\t\t */\n\n\t\t\t\t/* -L/--log-level */\n\t\t\tcase 'L':\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tdetected_log_level = detect_log_level(optarg);\n\n\t\t\t\t\tif (detected_log_level != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrncpy(runtime_options.log_level, optarg, MAXLEN);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tPQExpBufferData invalid_log_level;\n\n\t\t\t\t\t\tinitPQExpBuffer(&invalid_log_level);\n\t\t\t\t\t\tappendPQExpBuffer(&invalid_log_level, _(\"invalid log level \\\"%s\\\" provided\"), optarg);\n\t\t\t\t\t\titem_list_append(&cli_errors, invalid_log_level.data);\n\t\t\t\t\t\ttermPQExpBuffer(&invalid_log_level);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* --log-to-file */\n\t\t\tcase OPT_LOG_TO_FILE:\n\t\t\t\truntime_options.log_to_file = true;\n\t\t\t\tlogger_output_mode = OM_DAEMON;\n\t\t\t\tbreak;\n\n\n\t\t\t\t/* --quiet */\n\t\t\tcase 'q':\n\t\t\t\truntime_options.quiet = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/* --terse */\n\t\t\tcase 't':\n\t\t\t\truntime_options.terse = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/* --verbose */\n\t\t\tcase 'v':\n\t\t\t\truntime_options.verbose = true;\n\t\t\t\tbreak;\n\n\n\t\t\t\t/*---------------\n\t\t\t\t * output options\n\t\t\t\t *---------------\n\t\t\t\t */\n\t\t\tcase OPT_CSV:\n\t\t\t\truntime_options.csv = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_NAGIOS:\n\t\t\t\truntime_options.nagios = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_OPTFORMAT:\n\t\t\t\truntime_options.optformat = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/*---------------------------------\n\t\t\t\t * undocumented options for testing\n\t\t\t\t *----------------------------------\n\t\t\t\t */\n\n\t\t\tcase OPT_DISABLE_WAL_RECEIVER:\n\t\t\t\truntime_options.disable_wal_receiver = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_ENABLE_WAL_RECEIVER:\n\t\t\t\truntime_options.enable_wal_receiver = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/*-----------------------------\n\t\t\t\t * options deprecated since 4.0\n\t\t\t\t *-----------------------------\n\t\t\t\t */\n\t\t\tcase OPT_CHECK_UPSTREAM_CONFIG:\n\t\t\t\titem_list_append(&cli_warnings,\n\t\t\t\t\t\t\t\t _(\"--check-upstream-config is deprecated; use --dry-run instead\"));\n\t\t\t\tbreak;\n\n\t\t\t\t/* -C/--remote-config-file */\n\t\t\tcase 'C':\n\t\t\t\titem_list_append(&cli_warnings,\n\t\t\t\t\t\t\t\t _(\"--remote-config-file is no longer required\"));\n\t\t\t\tbreak;\n\n\t\t\tcase ':':   /* missing option argument */\n\t\t\t\toption_error_found = true;\n\t\t\t\tbreak;\n\t\t\tcase '?':\n\t\t\t\t/* Actual help option given? */\n\t\t\t\tif (strcmp(argv[optind - 1], \"-?\") == 0)\n\t\t\t\t{\n\t\t\t\t\thelp_option = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\toption_error_found = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:    /* invalid option */\n\t\t\t\toption_error_found = true;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t/*\n\t * If -d/--dbname appears to be a conninfo string, validate by attempting\n\t * to parse it (and if successful, store the parsed parameters)\n\t */\n\tif (runtime_options.dbname[0])\n\t{\n\t\tif (strncmp(runtime_options.dbname, \"postgresql://\", 13) == 0 ||\n\t\t\tstrncmp(runtime_options.dbname, \"postgres://\", 11) == 0 ||\n\t\t\tstrchr(runtime_options.dbname, '=') != NULL)\n\t\t{\n\t\t\tchar\t   *errmsg = NULL;\n\t\t\tPQconninfoOption *opts;\n\n\t\t\truntime_options.conninfo_provided = true;\n\n\t\t\topts = PQconninfoParse(runtime_options.dbname, &errmsg);\n\n\t\t\tif (opts == NULL)\n\t\t\t{\n\t\t\t\tPQExpBufferData conninfo_error;\n\n\t\t\t\tinitPQExpBuffer(&conninfo_error);\n\t\t\t\tappendPQExpBuffer(&conninfo_error, _(\"error parsing conninfo:\\n%s\"), errmsg);\n\t\t\t\titem_list_append(&cli_errors, conninfo_error.data);\n\n\t\t\t\ttermPQExpBuffer(&conninfo_error);\n\t\t\t\tpfree(errmsg);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Store any parameters provided in the conninfo string in our\n\t\t\t\t * internal array; also overwrite any options set in\n\t\t\t\t * runtime_options.(host|port|username), as the conninfo\n\t\t\t\t * settings take priority\n\t\t\t\t */\n\t\t\t\tPQconninfoOption *opt;\n\n\t\t\t\tfor (opt = opts; opt->keyword != NULL; opt++)\n\t\t\t\t{\n\t\t\t\t\tif (opt->val != NULL && opt->val[0] != '\\0')\n\t\t\t\t\t{\n\t\t\t\t\t\tparam_set(&source_conninfo, opt->keyword, opt->val);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (strcmp(opt->keyword, \"host\") == 0 &&\n\t\t\t\t\t\t(opt->val != NULL && opt->val[0] != '\\0'))\n\t\t\t\t\t{\n\t\t\t\t\t\tstrncpy(runtime_options.host, opt->val, MAXLEN);\n\t\t\t\t\t\truntime_options.host_param_provided = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (strcmp(opt->keyword, \"hostaddr\") == 0 &&\n\t\t\t\t\t\t(opt->val != NULL && opt->val[0] != '\\0'))\n\t\t\t\t\t{\n\t\t\t\t\t\tstrncpy(runtime_options.host, opt->val, MAXLEN);\n\t\t\t\t\t\truntime_options.host_param_provided = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (strcmp(opt->keyword, \"port\") == 0 &&\n\t\t\t\t\t\t\t (opt->val != NULL && opt->val[0] != '\\0'))\n\t\t\t\t\t{\n\t\t\t\t\t\tstrncpy(runtime_options.port, opt->val, MAXLEN);\n\t\t\t\t\t}\n\t\t\t\t\telse if (strcmp(opt->keyword, \"user\") == 0 &&\n\t\t\t\t\t\t\t (opt->val != NULL && opt->val[0] != '\\0'))\n\t\t\t\t\t{\n\t\t\t\t\t\tstrncpy(runtime_options.username, opt->val, MAXLEN);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tPQconninfoFree(opts);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparam_set(&source_conninfo, \"dbname\", runtime_options.dbname);\n\t\t}\n\t}\n\n\t/*\n\t * Disallow further running as root to prevent directory ownership\n\t * problems. We check this here to give the root user a chance to execute\n\t * --help/--version options.\n\t */\n\tif (geteuid() == 0 && help_option == false)\n\t{\n\t\tfprintf(stderr,\n\t\t\t\t_(\"%s: cannot be run as root\\n\"\n\t\t\t\t  \"Please log in (using, e.g., \\\"su\\\") as the \"\n\t\t\t\t  \"(unprivileged) user that owns \"\n\t\t\t\t  \"the data directory.\\n\"\n\t\t\t\t  ),\n\t\t\t\tprogname());\n\t\tfree_conninfo_params(&source_conninfo);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* Exit here already if errors in command line options found */\n\tif (cli_errors.head != NULL)\n\t{\n\t\tfree_conninfo_params(&source_conninfo);\n\t\texit_with_cli_errors(&cli_errors, NULL);\n\t}\n\n\t/*----------\n\t * Determine the node type and action; following are valid:\n\t *\n\t *   { PRIMARY | MASTER } REGISTER |\n\t *   STANDBY { REGISTER | UNREGISTER | CLONE [node] | PROMOTE | FOLLOW [node] | SWITCHOVER } |\n\t *   WITNESS { CREATE | REGISTER | UNREGISTER }\n\t *   NODE { STATUS | CHECK | REJOIN | SERVICE } |\n\t *   CLUSTER { CROSSCHECK | MATRIX | SHOW | EVENT | CLEANUP }\n\t *   SERVICE { STATUS | PAUSE | UNPAUSE | START | STOP }\n\t *\n\t * [node] is an optional hostname, provided instead of the -h/--host\n\t * option\n\t * ---------\n\t */\n\tif (optind < argc)\n\t{\n\t\trepmgr_command = argv[optind++];\n\t}\n\n\tif (optind < argc)\n\t{\n\t\trepmgr_action = argv[optind++];\n\t}\n\telse\n\t{\n\t\trepmgr_action = dummy_action;\n\t}\n\n\tif (repmgr_command != NULL)\n\t{\n\t\tif (strcasecmp(repmgr_command, \"PRIMARY\") == 0 || strcasecmp(repmgr_command, \"MASTER\") == 0)\n\t\t{\n\t\t\tif (help_option == true)\n\t\t\t{\n\t\t\t\tdo_primary_help();\n\t\t\t\texit(SUCCESS);\n\t\t\t}\n\n\t\t\tif (strcasecmp(repmgr_action, \"REGISTER\") == 0)\n\t\t\t\taction = PRIMARY_REGISTER;\n\t\t\telse if (strcasecmp(repmgr_action, \"UNREGISTER\") == 0)\n\t\t\t\taction = PRIMARY_UNREGISTER;\n\t\t\t/* allow \"primary check\"/\"primary status\" as aliases for \"node check\"/\"node status\" */\n\t\t\telse if (strcasecmp(repmgr_action, \"CHECK\") == 0)\n\t\t\t\taction = NODE_CHECK;\n\t\t\telse if (strcasecmp(repmgr_action, \"STATUS\") == 0)\n\t\t\t\taction = NODE_STATUS;\n\t\t}\n\n\t\telse if (strcasecmp(repmgr_command, \"STANDBY\") == 0)\n\t\t{\n\t\t\tif (help_option == true)\n\t\t\t{\n\t\t\t\tdo_standby_help();\n\t\t\t\texit(SUCCESS);\n\t\t\t}\n\n\t\t\tif (strcasecmp(repmgr_action, \"CLONE\") == 0)\n\t\t\t\taction = STANDBY_CLONE;\n\t\t\telse if (strcasecmp(repmgr_action, \"REGISTER\") == 0)\n\t\t\t\taction = STANDBY_REGISTER;\n\t\t\telse if (strcasecmp(repmgr_action, \"UNREGISTER\") == 0)\n\t\t\t\taction = STANDBY_UNREGISTER;\n\t\t\telse if (strcasecmp(repmgr_action, \"PROMOTE\") == 0)\n\t\t\t\taction = STANDBY_PROMOTE;\n\t\t\telse if (strcasecmp(repmgr_action, \"FOLLOW\") == 0)\n\t\t\t\taction = STANDBY_FOLLOW;\n\t\t\telse if (strcasecmp(repmgr_action, \"SWITCHOVER\") == 0)\n\t\t\t\taction = STANDBY_SWITCHOVER;\n\t\t\t/* allow \"standby check\"/\"standby status\" as aliases for \"node check\"/\"node status\" */\n\t\t\telse if (strcasecmp(repmgr_action, \"CHECK\") == 0)\n\t\t\t\taction = NODE_CHECK;\n\t\t\telse if (strcasecmp(repmgr_action, \"STATUS\") == 0)\n\t\t\t\taction = NODE_STATUS;\n\t\t}\n\n\t\telse if (strcasecmp(repmgr_command, \"WITNESS\") == 0)\n\t\t{\n\t\t\tif (help_option == true)\n\t\t\t{\n\t\t\t\tdo_witness_help();\n\t\t\t\texit(SUCCESS);\n\t\t\t}\n\t\t\telse if (strcasecmp(repmgr_action, \"REGISTER\") == 0)\n\t\t\t\taction = WITNESS_REGISTER;\n\t\t\telse if (strcasecmp(repmgr_action, \"UNREGISTER\") == 0)\n\t\t\t\taction = WITNESS_UNREGISTER;\n\t\t}\n\n\t\telse if (strcasecmp(repmgr_command, \"NODE\") == 0)\n\t\t{\n\t\t\tif (help_option == true)\n\t\t\t{\n\t\t\t\tdo_node_help();\n\t\t\t\texit(SUCCESS);\n\t\t\t}\n\n\t\t\tif (strcasecmp(repmgr_action, \"CHECK\") == 0)\n\t\t\t\taction = NODE_CHECK;\n\t\t\telse if (strcasecmp(repmgr_action, \"STATUS\") == 0)\n\t\t\t\taction = NODE_STATUS;\n\t\t\telse if (strcasecmp(repmgr_action, \"REJOIN\") == 0)\n\t\t\t\taction = NODE_REJOIN;\n\t\t\telse if (strcasecmp(repmgr_action, \"SERVICE\") == 0)\n\t\t\t\taction = NODE_SERVICE;\n\t\t\telse if (strcasecmp(repmgr_action, \"CONTROL\") == 0)\n\t\t\t\taction = NODE_CONTROL;\n\t\t}\n\n\t\telse if (strcasecmp(repmgr_command, \"CLUSTER\") == 0)\n\t\t{\n\t\t\tif (help_option == true)\n\t\t\t{\n\t\t\t\tdo_cluster_help();\n\t\t\t\texit(SUCCESS);\n\t\t\t}\n\n\t\t\tif (strcasecmp(repmgr_action, \"SHOW\") == 0)\n\t\t\t\taction = CLUSTER_SHOW;\n\t\t\telse if (strcasecmp(repmgr_action, \"EVENT\") == 0)\n\t\t\t\taction = CLUSTER_EVENT;\n\t\t\t/* allow \"CLUSTER EVENTS\" as synonym for \"CLUSTER EVENT\" */\n\t\t\telse if (strcasecmp(repmgr_action, \"EVENTS\") == 0)\n\t\t\t\taction = CLUSTER_EVENT;\n\t\t\telse if (strcasecmp(repmgr_action, \"CROSSCHECK\") == 0)\n\t\t\t\taction = CLUSTER_CROSSCHECK;\n\t\t\telse if (strcasecmp(repmgr_action, \"MATRIX\") == 0)\n\t\t\t\taction = CLUSTER_MATRIX;\n\t\t\telse if (strcasecmp(repmgr_action, \"CLEANUP\") == 0)\n\t\t\t\taction = CLUSTER_CLEANUP;\n\t\t}\n\t\telse if (strcasecmp(repmgr_command, \"SERVICE\") == 0)\n\t\t{\n\t\t\tif (help_option == true)\n\t\t\t{\n\t\t\t\tdo_service_help();\n\t\t\t\texit(SUCCESS);\n\t\t\t}\n\n\t\t\tif (strcasecmp(repmgr_action, \"STATUS\") == 0)\n\t\t\t\taction = SERVICE_STATUS;\n\t\t\telse if (strcasecmp(repmgr_action, \"PAUSE\") == 0)\n\t\t\t\taction = SERVICE_PAUSE;\n\t\t\telse if (strcasecmp(repmgr_action, \"UNPAUSE\") == 0)\n\t\t\t\taction = SERVICE_UNPAUSE;\n\n\t\t}\n\t\telse if (strcasecmp(repmgr_command, \"DAEMON\") == 0)\n\t\t{\n\t\t\tif (help_option == true)\n\t\t\t{\n\t\t\t\tdo_daemon_help();\n\t\t\t\texit(SUCCESS);\n\t\t\t}\n\n\t\t\tif (strcasecmp(repmgr_action, \"START\") == 0)\n\t\t\t\taction = DAEMON_START;\n\t\t\telse if (strcasecmp(repmgr_action, \"STOP\") == 0)\n\t\t\t\taction = DAEMON_STOP;\n\n\t\t\t/* allow \"daemon\" as an alias for \"service\" for repmgr 4.x compatibility */\n\t\t\tif (strcasecmp(repmgr_action, \"STATUS\") == 0)\n\t\t\t\taction = SERVICE_STATUS;\n\t\t\telse if (strcasecmp(repmgr_action, \"PAUSE\") == 0)\n\t\t\t\taction = SERVICE_PAUSE;\n\t\t\telse if (strcasecmp(repmgr_action, \"UNPAUSE\") == 0)\n\t\t\t\taction = SERVICE_UNPAUSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalid_repmgr_command_found = false;\n\t\t}\n\t}\n\n\tif (help_option == true)\n\t{\n\t\tdo_help();\n\t\texit(SUCCESS);\n\t}\n\n\tif (action == NO_ACTION)\n\t{\n\t\tPQExpBufferData command_error;\n\n\t\tinitPQExpBuffer(&command_error);\n\n\t\tif (repmgr_command == NULL)\n\t\t{\n\t\t\tappendPQExpBuffer(&command_error,\n\t\t\t\t\t\t\t  _(\"no repmgr command provided\"));\n\t\t}\n\t\telse if (valid_repmgr_command_found == false && repmgr_action[0] == '\\0')\n\t\t{\n\t\t\tappendPQExpBuffer(&command_error,\n\t\t\t\t\t\t\t  _(\"unknown repmgr command '%s'\"),\n\t\t\t\t\t\t\t  repmgr_command);\n\t\t}\n\t\telse if (repmgr_action[0] == '\\0')\n\t\t{\n\t\t\tappendPQExpBuffer(&command_error,\n\t\t\t\t\t\t\t  _(\"no action provided for command '%s'\"),\n\t\t\t\t\t\t\t  repmgr_command);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappendPQExpBuffer(&command_error,\n\t\t\t\t\t\t\t  _(\"unknown repmgr action '%s %s'\"),\n\t\t\t\t\t\t\t  repmgr_command,\n\t\t\t\t\t\t\t  repmgr_action);\n\t\t}\n\n\t\titem_list_append(&cli_errors, command_error.data);\n\t}\n\n\t/*\n\t * STANDBY CLONE historically accepts the upstream hostname as an\n\t * additional argument\n\t */\n\tif (action == STANDBY_CLONE)\n\t{\n\t\tif (optind < argc)\n\t\t{\n\t\t\tif (runtime_options.host_param_provided == true)\n\t\t\t{\n\t\t\t\tPQExpBufferData additional_host_arg;\n\n\t\t\t\tinitPQExpBuffer(&additional_host_arg);\n\t\t\t\tappendPQExpBuffer(&additional_host_arg,\n\t\t\t\t\t\t\t\t  _(\"host name provided both with %s and as an extra parameter\"),\n\t\t\t\t\t\t\t\t  runtime_options.conninfo_provided == true ? \"host=\" : \"-h/--host\");\n\t\t\t\titem_list_append(&cli_errors, additional_host_arg.data);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrncpy(runtime_options.host, argv[optind++], MAXLEN);\n\t\t\t\tparam_set(&source_conninfo, \"host\", runtime_options.host);\n\t\t\t\truntime_options.host_param_provided = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (optind < argc)\n\t{\n\t\tPQExpBufferData too_many_args;\n\n\t\tinitPQExpBuffer(&too_many_args);\n\t\tappendPQExpBuffer(&too_many_args, _(\"too many command-line arguments (first extra is \\\"%s\\\")\"), argv[optind]);\n\t\titem_list_append(&cli_errors, too_many_args.data);\n\t}\n\n\n\t/*\n\t * The configuration file is not required for some actions (e.g. 'standby\n\t * clone'), however if available we'll parse it anyway for options like\n\t * 'log_level', 'use_replication_slots' etc.\n\t */\n\tload_config(runtime_options.config_file,\n\t\t\t\truntime_options.verbose,\n\t\t\t\truntime_options.terse,\n\t\t\t\targv[0]);\n\n\n\t/*\n\t * Handle options which must be executed without a repmgr command\n\t */\n\tif (runtime_options.dump_config == true)\n\t{\n\t\tif (repmgr_command != NULL)\n\t\t{\n\t\t\tfprintf(stderr,\n\t\t\t\t\t_(\"--dump-config cannot be used in combination with a repmgr command\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t\tdump_config();\n\t\texit(SUCCESS);\n\t}\n\n\tcheck_cli_parameters(action);\n\n\n\t/*\n\t * Command-line parameter --recovery-min-apply-delay overrides the equivalent\n\t * setting in the config file. Note we'll need to parse it here to handle\n\t * any formatting errors.\n\t */\n\n\tif (*runtime_options.recovery_min_apply_delay != '\\0')\n\t{\n\t\tparse_time_unit_parameter(\"--recovery-min-apply-delay\",\n\t\t\t\t\t\t\t\t  runtime_options.recovery_min_apply_delay,\n\t\t\t\t\t\t\t\t  config_file_options.recovery_min_apply_delay,\n\t\t\t\t\t\t\t\t  &cli_errors);\n\n\t\tconfig_file_options.recovery_min_apply_delay_provided = true;\n\t}\n\n\t/*\n\t * Sanity checks for command line parameters completed by now; any further\n\t * errors will be runtime ones\n\t */\n\tif (cli_errors.head != NULL)\n\t{\n\t\tfree_conninfo_params(&source_conninfo);\n\n\t\texit_with_cli_errors(&cli_errors, valid_repmgr_command_found == true ? repmgr_command : NULL);\n\t}\n\n\t/* no errors detected by repmgr, but getopt might have */\n\tif (option_error_found == true)\n\t{\n\t\tif (valid_repmgr_command_found == true)\n\t\t{\n\t\t\tprintf(_(\"Try \\\"%s --help\\\" or \\\"%s %s --help\\\" for more information.\\n\"),\n\t\t\t\t   progname(),\n\t\t\t\t   progname(),\n\t\t\t\t   repmgr_command);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(_(\"Try \\\"repmgr --help\\\" for more information.\\n\"));\n\t\t}\n\n\t\tfree_conninfo_params(&source_conninfo);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\n\t/*\n\t * Print any warnings about inappropriate command line options, unless\n\t * -t/--terse set\n\t */\n\tif (cli_warnings.head != NULL && runtime_options.terse == false)\n\t{\n\t\tlog_warning(_(\"following problems with command line parameters detected:\"));\n\t\tprint_item_list(&cli_warnings);\n\t}\n\n\t/*\n\t * post-processing following command line parameter checks\n\t * =======================================================\n\t */\n\n\tif (runtime_options.csv == true)\n\t{\n\t\truntime_options.output_mode = OM_CSV;\n\t}\n\telse if (runtime_options.nagios == true)\n\t{\n\t\truntime_options.output_mode = OM_NAGIOS;\n\t}\n\telse if (runtime_options.optformat == true)\n\t{\n\t\truntime_options.output_mode = OM_OPTFORMAT;\n\t}\n\n\t/*\n\t * Check for configuration file items which can be overridden by runtime\n\t * options\n\t * =====================================================================\n\t */\n\n\t/*\n\t * Command-line parameter -L/--log-level overrides any setting in config\n\t * file\n\t */\n\tif (*runtime_options.log_level != '\\0')\n\t{\n\t\tstrncpy(config_file_options.log_level, runtime_options.log_level, MAXLEN);\n\t}\n\n\t/*\n\t * Initialise pg_bindir - command line parameter will override any setting\n\t * in the configuration file\n\t */\n\tif (!strlen(runtime_options.pg_bindir))\n\t{\n\t\tstrncpy(runtime_options.pg_bindir, config_file_options.pg_bindir, MAXLEN);\n\t}\n\n\t/* Add trailing slash */\n\tif (strlen(runtime_options.pg_bindir))\n\t{\n\t\tint\t\t\tlen = strlen(runtime_options.pg_bindir);\n\n\t\tif (runtime_options.pg_bindir[len - 1] != '/')\n\t\t{\n\t\t\tmaxlen_snprintf(pg_bindir, \"%s/\", runtime_options.pg_bindir);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrncpy(pg_bindir, runtime_options.pg_bindir, MAXLEN);\n\t\t}\n\t}\n\n\t/*\n\t * Initialize the logger. We've previously requested STDERR logging only\n\t * to ensure the repmgr command doesn't have its output diverted to a\n\t * logging facility (which usually doesn't make sense for a command line\n\t * program).\n\t *\n\t * If required (e.g. when calling repmgr from repmgrd), this behaviour can\n\t * be overridden with \"--log-to-file\".\n\t */\n\n\tlogger_init(&config_file_options, progname());\n\n\tif (runtime_options.verbose)\n\t\tlogger_set_verbose();\n\n\tif (runtime_options.terse)\n\t\tlogger_set_terse();\n\n\t/*\n\t * If --dry-run specified, ensure log_level is at least LOG_INFO, regardless\n\t * of what's in the configuration file or -L/--log-level parameter, otherwise\n\t * some or output might not be displayed.\n\t */\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tlogger_set_min_level(LOG_INFO);\n\t}\n\n\t/*\n\t * If -q/--quiet supplied, suppress any non-ERROR log output.\n\t * This overrides everything else; we'll leave it up to the user to deal with the\n\t * consequences of e.g. running --dry-run together with -q/--quiet.\n\t */\n\tif (runtime_options.quiet == true)\n\t{\n\t\tlogger_set_level(LOG_ERROR);\n\t}\n\n\t/*\n\t * Node configuration information is not needed for all actions, with\n\t * STANDBY CLONE being the main exception.\n\t */\n\tif (config_file_required)\n\t{\n\t\t/*\n\t\t * if a configuration file was provided, the configuration file parser\n\t\t * will already have errored out if no valid node_id found\n\t\t */\n\t\tif (config_file_options.node_id == NODE_NOT_FOUND)\n\t\t{\n\t\t\tfree_conninfo_params(&source_conninfo);\n\n\t\t\tlog_error(_(\"no node information was found - please supply a configuration file\"));\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\t/*\n\t * If a node was specified (by --node-id or --node-name), check it exists\n\t * (and pre-populate a record for later use).\n\t *\n\t * At this point check_cli_parameters() will already have determined if\n\t * provision of these is valid for the action, otherwise it unsets them.\n\t *\n\t * We need to check this much later than other command line parameters as\n\t * we need to wait until the configuration file is parsed and we can\n\t * obtain the conninfo string.\n\t */\n\n\tif (runtime_options.node_id != UNKNOWN_NODE_ID || runtime_options.node_name[0] != '\\0')\n\t{\n\t\tPGconn\t   *conn = NULL;\n\t\tRecordStatus record_status = RECORD_NOT_FOUND;\n\n\t\tlog_verbose(LOG_DEBUG, \"connecting to local node to retrieve record for node specified with --node-id or --node-name\");\n\n\t\tif (strlen(config_file_options.conninfo))\n\t\t\tconn = establish_db_connection(config_file_options.conninfo, true);\n\t\telse\n\t\t\tconn = establish_db_connection_by_params(&source_conninfo, true);\n\n\t\tif (runtime_options.node_id != UNKNOWN_NODE_ID)\n\t\t{\n\t\t\trecord_status = get_node_record(conn, runtime_options.node_id, &target_node_info);\n\n\t\t\tif (record_status != RECORD_FOUND)\n\t\t\t{\n\t\t\t\tlog_error(_(\"node %i (specified with --node-id) not found\"),\n\t\t\t\t\t\t  runtime_options.node_id);\n\t\t\t\tPQfinish(conn);\n\t\t\t\tfree_conninfo_params(&source_conninfo);\n\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\t\t}\n\t\telse if (runtime_options.node_name[0] != '\\0')\n\t\t{\n\t\t\tchar\t   *escaped = escape_string(conn, runtime_options.node_name);\n\n\t\t\tif (escaped == NULL)\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to escape value provided for --node-name\"));\n\t\t\t\tPQfinish(conn);\n\t\t\t\tfree_conninfo_params(&source_conninfo);\n\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\n\t\t\trecord_status = get_node_record_by_name(conn, escaped, &target_node_info);\n\n\t\t\tpfree(escaped);\n\t\t\tif (record_status != RECORD_FOUND)\n\t\t\t{\n\t\t\t\tlog_error(_(\"node \\\"%s\\\" (specified with --node-name) not found\"),\n\t\t\t\t\t\t  runtime_options.node_name);\n\t\t\t\tPQfinish(conn);\n\t\t\t\tfree_conninfo_params(&source_conninfo);\n\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t\t}\n\t\t}\n\n\t\tPQfinish(conn);\n\t}\n\n\n\tswitch (action)\n\t{\n\t\t\t/* PRIMARY */\n\t\tcase PRIMARY_REGISTER:\n\t\t\tdo_primary_register();\n\t\t\tbreak;\n\t\tcase PRIMARY_UNREGISTER:\n\t\t\tdo_primary_unregister();\n\t\t\tbreak;\n\n\t\t\t/* STANDBY */\n\t\tcase STANDBY_CLONE:\n\t\t\tdo_standby_clone();\n\t\t\tbreak;\n\t\tcase STANDBY_REGISTER:\n\t\t\tdo_standby_register();\n\t\t\tbreak;\n\t\tcase STANDBY_UNREGISTER:\n\t\t\tdo_standby_unregister();\n\t\t\tbreak;\n\t\tcase STANDBY_PROMOTE:\n\t\t\tdo_standby_promote();\n\t\t\tbreak;\n\t\tcase STANDBY_FOLLOW:\n\t\t\tdo_standby_follow();\n\t\t\tbreak;\n\t\tcase STANDBY_SWITCHOVER:\n\t\t\tdo_standby_switchover();\n\t\t\tbreak;\n\n\t\t\t/* WITNESS */\n\t\tcase WITNESS_REGISTER:\n\t\t\tdo_witness_register();\n\t\t\tbreak;\n\t\tcase WITNESS_UNREGISTER:\n\t\t\tdo_witness_unregister();\n\t\t\tbreak;\n\n\t\t\t/* NODE */\n\t\tcase NODE_STATUS:\n\t\t\tdo_node_status();\n\t\t\tbreak;\n\t\tcase NODE_CHECK:\n\t\t\tdo_node_check();\n\t\t\tbreak;\n\t\tcase NODE_REJOIN:\n\t\t\tdo_node_rejoin();\n\t\t\tbreak;\n\t\tcase NODE_SERVICE:\n\t\t\tdo_node_service();\n\t\t\tbreak;\n\t\tcase NODE_CONTROL:\n\t\t\tdo_node_control();\n\t\t\tbreak;\n\n\t\t\t/* CLUSTER */\n\t\tcase CLUSTER_SHOW:\n\t\t\tdo_cluster_show();\n\t\t\tbreak;\n\t\tcase CLUSTER_EVENT:\n\t\t\tdo_cluster_event();\n\t\t\tbreak;\n\t\tcase CLUSTER_CROSSCHECK:\n\t\t\tdo_cluster_crosscheck();\n\t\t\tbreak;\n\t\tcase CLUSTER_MATRIX:\n\t\t\tdo_cluster_matrix();\n\t\t\tbreak;\n\t\tcase CLUSTER_CLEANUP:\n\t\t\tdo_cluster_cleanup();\n\t\t\tbreak;\n\n\t\t\t/* SERVICE */\n\t\tcase SERVICE_STATUS:\n\t\t\tdo_service_status();\n\t\t\tbreak;\n\t\tcase SERVICE_PAUSE:\n\t\t\tdo_service_pause();\n\t\t\tbreak;\n\t\tcase SERVICE_UNPAUSE:\n\t\t\tdo_service_unpause();\n\t\t\tbreak;\n\n\t\t\t/* DAEMON */\n\t\tcase DAEMON_START:\n\t\t\tdo_daemon_start();\n\t\t\tbreak;\n\t\tcase DAEMON_STOP:\n\t\t\tdo_daemon_stop();\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* An action will have been determined by this point  */\n\t\t\tbreak;\n\t}\n\n\tfree_conninfo_params(&source_conninfo);\n\n\treturn SUCCESS;\n}\n\n\n\n/*\n * Check for useless or conflicting parameters, and also whether a\n * configuration file is required.\n *\n * Messages will be added to the command line warning and error lists\n * as appropriate.\n */\n\nstatic void\ncheck_cli_parameters(const int action)\n{\n\t/*\n\t * ========================================================================\n\t * check all parameters required for an action are provided, and warn\n\t * about ineffective actions\n\t * ========================================================================\n\t */\n\tswitch (action)\n\t{\n\t\tcase PRIMARY_REGISTER:\n\t\t\t/* no required parameters */\n\t\t\tbreak;\n\t\tcase STANDBY_CLONE:\n\t\t\t{\n\t\t\t\tstandy_clone_mode mode = get_standby_clone_mode();\n\n\t\t\t\tconfig_file_required = false;\n\n\t\t\t\tif (mode == barman)\n\t\t\t\t{\n\t\t\t\t\tif (runtime_options.copy_external_config_files)\n\t\t\t\t\t{\n\t\t\t\t\t\titem_list_append(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t _(\"--copy-external-config-files ineffective in Barman mode\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (runtime_options.fast_checkpoint)\n\t\t\t\t\t{\n\t\t\t\t\t\titem_list_append(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t _(\"-c/--fast-checkpoint has no effect in Barman mode\"));\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!runtime_options.host_param_provided)\n\t\t\t\t\t{\n\t\t\t\t\t\titem_list_append_format(&cli_errors,\n\t\t\t\t\t\t\t\t\t\t\t\t_(\"host name for the source node must be provided with -h/--host when executing %s\"),\n\t\t\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!runtime_options.connection_param_provided)\n\t\t\t\t\t{\n\t\t\t\t\t\titem_list_append_format(&cli_errors,\n\t\t\t\t\t\t\t\t\t\t\t\t_(\"database connection parameters for the source node must be provided when executing %s\"),\n\t\t\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If -D/--pgdata was provided, but config_file_options.pgdata\n\t\t\t\t\t * is set, warn that -D/--pgdata will be ignored.\n\t\t\t\t\t */\n\t\t\t\t\tif (runtime_options.data_dir[0] && config_file_options.data_directory[0])\n\t\t\t\t\t{\n\t\t\t\t\t\titem_list_append(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t _(\"-D/--pgdata will be ignored if a repmgr configuration file is provided\"));\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (*runtime_options.upstream_conninfo)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (*runtime_options.replication_user)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem_list_append(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t\t _(\"--replication-user ineffective when specifying --upstream-conninfo\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (runtime_options.no_upstream_connection == true)\n\t\t\t\t\t{\n\t\t\t\t\t\titem_list_append(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t _(\"--no-upstream-connection only effective in Barman mode\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (strlen(config_file_options.config_directory))\n\t\t\t\t{\n\t\t\t\t\tif (runtime_options.copy_external_config_files == false)\n\t\t\t\t\t{\n\t\t\t\t\t\titem_list_append(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t _(\"\\\"config_directory\\\" set in repmgr.conf, but --copy-external-config-files not provided\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase STANDBY_FOLLOW:\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * if `repmgr standby follow` executed with host params,\n\t\t\t\t * ensure data directory was provided\n\t\t\t\t */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WITNESS_REGISTER:\n\t\t\t{\n\t\t\t\tif (!runtime_options.host_param_provided)\n\t\t\t\t{\n\t\t\t\t\titem_list_append_format(&cli_errors,\n\t\t\t\t\t\t\t\t\t\t\t_(\"host name for the source node must be provided with -h/--host when executing %s\"),\n\t\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NODE_CHECK:\n\t\t\tif (runtime_options.has_passfile == true)\n\t\t\t{\n\t\t\t\tconfig_file_required = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NODE_STATUS:\n\t\t\tif (runtime_options.node_id != UNKNOWN_NODE_ID)\n\t\t\t{\n\t\t\t\titem_list_append(\n\t\t\t\t\t\t\t\t &cli_warnings,\n\t\t\t\t\t\t\t\t \"--node-id will be ignored; \\\"repmgr node status\\\" can only be executed on the local node\");\n\t\t\t}\n\t\t\tif (runtime_options.node_name[0] != '\\0')\n\t\t\t{\n\t\t\t\titem_list_append(\n\t\t\t\t\t\t\t\t &cli_warnings,\n\t\t\t\t\t\t\t\t \"--node-name will be ignored; \\\"repmgr node status\\\" can only be executed on the local node\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NODE_REJOIN:\n\t\t\tif (runtime_options.connection_param_provided == false)\n\t\t\t{\n\t\t\t\titem_list_append(\n\t\t\t\t\t\t\t\t &cli_errors,\n\t\t\t\t\t\t\t\t \"database connection parameters for an available node must be provided when executing NODE REJOIN\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CLUSTER_SHOW:\n\t\tcase CLUSTER_MATRIX:\n\t\tcase CLUSTER_CROSSCHECK:\n\t\t\tif (runtime_options.connection_param_provided)\n\t\t\t\tconfig_file_required = false;\n\t\t\tbreak;\n\t\tcase CLUSTER_EVENT:\n\t\t\t/* no required parameters */\n\t\t\tbreak;\n\n\t}\n\n\t/*\n\t * ========================================================================\n\t * warn if parameters provided for an action where they're not relevant\n\t * ========================================================================\n\t */\n\n\t/* --host etc. */\n\tif (runtime_options.connection_param_provided)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase STANDBY_CLONE:\n\t\t\tcase STANDBY_FOLLOW:\n\t\t\tcase STANDBY_REGISTER:\n\t\t\tcase WITNESS_REGISTER:\n\t\t\tcase WITNESS_UNREGISTER:\n\t\t\tcase CLUSTER_SHOW:\n\t\t\tcase CLUSTER_MATRIX:\n\t\t\tcase CLUSTER_CROSSCHECK:\n\t\t\tcase NODE_REJOIN:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"database connection parameters not required when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\t/* -D/--pgdata */\n\tif (runtime_options.data_dir[0])\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase STANDBY_CLONE:\n\t\t\tcase STANDBY_FOLLOW:\n\t\t\tcase NODE_SERVICE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"-D/--pgdata not required when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\t/*\n\t * --node-id\n\t *\n\t * NOTE: overrides --node-name, if present\n\t */\n\tif (runtime_options.node_id != UNKNOWN_NODE_ID)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase PRIMARY_UNREGISTER:\n\t\t\tcase STANDBY_UNREGISTER:\n\t\t\tcase WITNESS_UNREGISTER:\n\t\t\tcase CLUSTER_CLEANUP:\n\t\t\tcase CLUSTER_EVENT:\n\t\t\tcase CLUSTER_MATRIX:\n\t\t\tcase CLUSTER_CROSSCHECK:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--node-id not required when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t\t\truntime_options.node_id = UNKNOWN_NODE_ID;\n\t\t}\n\t}\n\n\tif (runtime_options.node_name[0])\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase STANDBY_UNREGISTER:\n\t\t\tcase CLUSTER_EVENT:\n\t\t\t\tif (runtime_options.node_id != UNKNOWN_NODE_ID)\n\t\t\t\t{\n\t\t\t\t\titem_list_append(&cli_warnings,\n\t\t\t\t\t\t\t\t\t _(\"--node-id provided, ignoring --node-name\"));\n\t\t\t\t\tmemset(runtime_options.node_name, 0, sizeof(runtime_options.node_name));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--node-name not required when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t\t\tmemset(runtime_options.node_name, 0, sizeof(runtime_options.node_name));\n\t\t}\n\t}\n\n\tif (runtime_options.upstream_node_id != UNKNOWN_NODE_ID)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase STANDBY_CLONE:\n\t\t\tcase STANDBY_REGISTER:\n\t\t\tcase STANDBY_FOLLOW:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--upstream-node-id will be ignored when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\tif (runtime_options.replication_user[0])\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase PRIMARY_REGISTER:\n\t\t\tcase STANDBY_REGISTER:\n\t\t\tcase STANDBY_CLONE:\n\t\t\t\tbreak;\n\n\t\t\tcase STANDBY_FOLLOW:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--replication-user ignored when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--replication-user not required when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\tif (runtime_options.superuser[0])\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase STANDBY_CLONE:\n\t\t\tcase STANDBY_SWITCHOVER:\n\t\t\tcase NODE_CHECK:\n\t\t\tcase NODE_SERVICE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--superuser ignored when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\n\tif (runtime_options.replication_conf_only == true)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase STANDBY_CLONE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--create-recovery-conf will be ignored when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\tif (runtime_options.event[0])\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase CLUSTER_EVENT:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--event not required when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\tif (runtime_options.limit_provided)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase CLUSTER_EVENT:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--limit not required when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\tif (runtime_options.all)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase CLUSTER_EVENT:\n\t\t\t\tif (runtime_options.limit_provided == true)\n\t\t\t\t{\n\t\t\t\t\truntime_options.all = false;\n\t\t\t\t\titem_list_append(&cli_warnings,\n\t\t\t\t\t\t\t\t\t _(\"--limit provided, ignoring --all\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--all not required when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\t/* --wait/--no-wait */\n\n\tif (runtime_options.wait_provided == true && runtime_options.no_wait == true)\n\t{\n\t\titem_list_append_format(&cli_errors,\n\t\t\t\t\t\t\t\t_(\"both --wait and --no-wait options provided\"));\n\t}\n\telse\n\t{\n\t\tif (runtime_options.wait_provided)\n\t\t{\n\t\t\tswitch (action)\n\t\t\t{\n\t\t\t\tcase DAEMON_START:\n\t\t\t\tcase DAEMON_STOP:\n\t\t\t\tcase STANDBY_FOLLOW:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t\t_(\"--wait will be ignored when executing %s\"),\n\t\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t\t}\n\t\t}\n\t\telse if (runtime_options.no_wait)\n\t\t{\n\t\t\tswitch (action)\n\t\t\t{\n\t\t\t\tcase DAEMON_START:\n\t\t\t\tcase DAEMON_STOP:\n\t\t\t\tcase NODE_REJOIN:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t\t_(\"--no-wait will be ignored when executing %s\"),\n\t\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* repmgr node service --action */\n\tif (runtime_options.action[0] != '\\0')\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase NODE_SERVICE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--action will be ignored when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\t/* repmgr node status --is-shutdown-cleanly */\n\tif (runtime_options.is_shutdown_cleanly == true)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase NODE_STATUS:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--is-shutdown-cleanly will be ignored when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\tif (runtime_options.always_promote == true)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase STANDBY_SWITCHOVER:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--always-promote will be ignored when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\tif (runtime_options.force_rewind_used == true)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase STANDBY_SWITCHOVER:\n\t\t\tcase NODE_REJOIN:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--force-rewind will be ignored when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\tif (runtime_options.repmgrd_no_pause == true)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase STANDBY_SWITCHOVER:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--repmgrd-no-pause will be ignored when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\tif (runtime_options.repmgrd_force_unpause == true)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase STANDBY_SWITCHOVER:\n\t\t\t\tif (runtime_options.repmgrd_no_pause == true)\n\t\t\t\t\titem_list_append(&cli_errors,\n\t\t\t\t\t\t\t\t\t _(\"--repmgrd-force-unpause and --repmgrd-no-pause cannot be used together\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--repmgrd-force-unpause will be ignored when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\tif (runtime_options.config_files[0] != '\\0')\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase NODE_REJOIN:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--config-files will be ignored when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase PRIMARY_REGISTER:\n\t\t\tcase PRIMARY_UNREGISTER:\n\t\t\tcase STANDBY_CLONE:\n\t\t\tcase STANDBY_REGISTER:\n\t\t\tcase STANDBY_FOLLOW:\n\t\t\tcase STANDBY_SWITCHOVER:\n\t\t\tcase STANDBY_PROMOTE:\n\t\t\tcase WITNESS_REGISTER:\n\t\t\tcase WITNESS_UNREGISTER:\n\t\t\tcase NODE_REJOIN:\n\t\t\tcase NODE_SERVICE:\n\t\t\tcase SERVICE_PAUSE:\n\t\t\tcase SERVICE_UNPAUSE:\n\t\t\tcase SERVICE_STATUS:\n\t\t\tcase DAEMON_START:\n\t\t\tcase DAEMON_STOP:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--dry-run is not effective when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\t/* check only one of --csv, --nagios and --optformat  used */\n\t{\n\t\tint\t\t\tused_options = 0;\n\n\t\tif (runtime_options.csv == true)\n\t\t\tused_options++;\n\n\t\tif (runtime_options.nagios == true)\n\t\t\tused_options++;\n\n\t\tif (runtime_options.optformat == true)\n\t\t\tused_options++;\n\n\t\tif (used_options > 1)\n\t\t{\n\t\t\t/* TODO: list which options were used */\n\t\t\titem_list_append(&cli_errors,\n\t\t\t\t\t\t\t \"only one of --csv, --nagios and --optformat can be used\");\n\t\t}\n\t}\n\n\t/* --compact */\n\tif (runtime_options.compact == true)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase CLUSTER_SHOW:\n\t\t\tcase CLUSTER_EVENT:\n\t\t\tcase SERVICE_STATUS:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--compact is not effective when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\t/* --detail */\n\tif (runtime_options.detail == true)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase SERVICE_STATUS:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"--detail is not effective when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\t/* --siblings-follow */\n\tif (runtime_options.siblings_follow == true)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase STANDBY_PROMOTE:\n\t\t\tcase STANDBY_SWITCHOVER:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t_(\"----siblings-follow is not effective when executing %s\"),\n\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n\t/* --disable-wal-receiver / --enable-wal-receiver */\n\tif (runtime_options.disable_wal_receiver == true || runtime_options.enable_wal_receiver == true)\n\t{\n\t\tswitch (action)\n\t\t{\n\t\t\tcase NODE_CONTROL:\n\t\t\t{\n\t\t\t\tif (runtime_options.disable_wal_receiver == true && runtime_options.enable_wal_receiver == true)\n\t\t\t\t{\n\t\t\t\t\t\titem_list_append(&cli_errors,\n\t\t\t\t\t\t\t\t\t\t _(\"provide either --disable-wal-receiver or --enable-wal-receiver\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\titem_list_append_format(&cli_warnings,\n\t\t\t\t\t\t\t\t\t\t\t_(\"--disable-wal-receiver / --enable-wal-receiver not effective when executing %s\"),\n\t\t\t\t\t\t\t\t\t\t\taction_name(action));\n\t\t}\n\t}\n\n}\n\n\n/*\n * Generate formatted node status output for display by \"cluster show\" and\n * \"service status\".\n */\nbool\nformat_node_status(t_node_info *node_info, PQExpBufferData *node_status, PQExpBufferData *upstream, ItemList *warnings)\n{\n\tbool error_found = false;\n\tt_node_info remote_node_rec = T_NODE_INFO_INITIALIZER;\n\tRecordStatus remote_node_rec_found = RECORD_NOT_FOUND;\n\n\tif (PQstatus(node_info->conn) == CONNECTION_OK)\n\t{\n\t\tnode_info->node_status = NODE_STATUS_UP;\n\t\tnode_info->recovery_type = get_recovery_type(node_info->conn);\n\t\t/* get node's copy of its record so we can see what it thinks its status is */\n\t\tremote_node_rec_found = get_node_record_with_upstream(node_info->conn, node_info->node_id, &remote_node_rec);\n\t}\n\telse\n\t{\n\t\t/* check if node is reachable, but just not letting us in */\n\t\tif (is_server_available_quiet(node_info->conninfo))\n\t\t\tnode_info->node_status = NODE_STATUS_REJECTED;\n\t\telse\n\t\t\tnode_info->node_status = NODE_STATUS_DOWN;\n\n\t\tnode_info->recovery_type = RECTYPE_UNKNOWN;\n\t}\n\n\t/* format node status info */\n\tswitch (node_info->type)\n\t{\n\t\tcase PRIMARY:\n\t\t{\n\t\t\t/* node is reachable */\n\t\t\tif (node_info->node_status == NODE_STATUS_UP)\n\t\t\t{\n\t\t\t\tif (node_info->active == true)\n\t\t\t\t{\n\t\t\t\t\tswitch (node_info->recovery_type)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase RECTYPE_PRIMARY:\n\t\t\t\t\t\t\tappendPQExpBufferStr(node_status, \"* running\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase RECTYPE_STANDBY:\n\t\t\t\t\t\t\tappendPQExpBufferStr(node_status, \"! running as standby\");\n\t\t\t\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) is registered as primary but running as standby\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnode_info->node_name, node_info->node_id);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase RECTYPE_UNKNOWN:\n\t\t\t\t\t\t\tappendPQExpBufferStr(node_status, \"! unknown\");\n\t\t\t\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) has unknown replication status\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnode_info->node_name, node_info->node_id);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (node_info->recovery_type == RECTYPE_PRIMARY)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBufferStr(node_status, \"! running\");\n\t\t\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) is running but the repmgr node record is inactive\",\n\t\t\t\t\t\t\t\t\t\t\t\tnode_info->node_name, node_info->node_id);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBufferStr(node_status, \"! running as standby\");\n\t\t\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) is registered as an inactive primary but running as standby\",\n\t\t\t\t\t\t\t\t\t\t\t\tnode_info->node_name, node_info->node_id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* node is up but cannot connect */\n\t\t\telse if (node_info->node_status == NODE_STATUS_REJECTED)\n\t\t\t{\n\t\t\t\tif (node_info->active == true)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(node_status, \"? running\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(node_status, \"! running\");\n\t\t\t\t\terror_found = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* node is unreachable */\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* node is unreachable but marked active */\n\t\t\t\tif (node_info->active == true)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(node_status, \"? unreachable\");\n\t\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) is registered as an active primary but is unreachable\",\n\t\t\t\t\t\t\t\t\t\t\tnode_info->node_name, node_info->node_id);\n\t\t\t\t}\n\t\t\t\t/* node is unreachable and marked as inactive */\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(node_status, \"- failed\");\n\t\t\t\t\terror_found = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase STANDBY:\n\t\t{\n\t\t\t/* node is reachable */\n\t\t\tif (node_info->node_status == NODE_STATUS_UP)\n\t\t\t{\n\t\t\t\tif (node_info->active == true)\n\t\t\t\t{\n\t\t\t\t\tswitch (node_info->recovery_type)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase RECTYPE_STANDBY:\n\t\t\t\t\t\t\tappendPQExpBufferStr(node_status, \"  running\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase RECTYPE_PRIMARY:\n\t\t\t\t\t\t\tappendPQExpBufferStr(node_status, \"! running as primary\");\n\t\t\t\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) is registered as standby but running as primary\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnode_info->node_name, node_info->node_id);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase RECTYPE_UNKNOWN:\n\t\t\t\t\t\t\tappendPQExpBufferStr(node_status, \"! unknown\");\n\t\t\t\t\t\t\titem_list_append_format(\n\t\t\t\t\t\t\t\twarnings,\n\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) has unknown replication status\",\n\t\t\t\t\t\t\t\tnode_info->node_name, node_info->node_id);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (node_info->recovery_type == RECTYPE_STANDBY)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBufferStr(node_status, \"! running\");\n\t\t\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) is running but the repmgr node record is inactive\",\n\t\t\t\t\t\t\t\t\t\t\t\tnode_info->node_name, node_info->node_id);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tappendPQExpBufferStr(node_status, \"! running as primary\");\n\t\t\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) is running as primary but the repmgr node record is inactive\",\n\t\t\t\t\t\t\t\t\t\t\t\tnode_info->node_name, node_info->node_id);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* warn about issue with paused WAL replay */\n\t\t\t\tif (is_wal_replay_paused(node_info->conn, true))\n\t\t\t\t{\n\t\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\t_(\"WAL replay is paused on node \\\"%s\\\" (ID: %i) with WAL replay pending; this node cannot be manually promoted until WAL replay is resumed\"),\n\t\t\t\t\t\t\t\t\t\t\tnode_info->node_name, node_info->node_id);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* node is up but cannot connect */\n\t\t\telse if (node_info->node_status == NODE_STATUS_REJECTED)\n\t\t\t{\n\t\t\t\tif (node_info->active == true)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(node_status, \"? running\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(node_status, \"! running\");\n\t\t\t\t\terror_found = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* node is unreachable */\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* node is unreachable but marked active */\n\t\t\t\tif (node_info->active == true)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(node_status, \"? unreachable\");\n\t\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) is registered as an active standby but is unreachable\",\n\t\t\t\t\t\t\t\t\t\t\tnode_info->node_name, node_info->node_id);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(node_status, \"- failed\");\n\t\t\t\t\terror_found = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t\tcase WITNESS:\n\t\t{\n\t\t\t/* node is reachable */\n\t\t\tif (node_info->node_status == NODE_STATUS_UP)\n\t\t\t{\n\t\t\t\tif (node_info->active == true)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(node_status, \"* running\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(node_status, \"! running\");\n\t\t\t\t\terror_found = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* node is up but cannot connect */\n\t\t\telse if (node_info->node_status == NODE_STATUS_REJECTED)\n\t\t\t{\n\t\t\t\tif (node_info->active == true)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(node_status, \"? rejected\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(node_status, \"! failed\");\n\t\t\t\t\terror_found = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* node is unreachable */\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (node_info->active == true)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(node_status, \"? unreachable\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(node_status, \"- failed\");\n\t\t\t\t\terror_found = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\tcase UNKNOWN:\n\t\t{\n\t\t\t/* this should never happen */\n\t\t\tappendPQExpBufferStr(node_status, \"? unknown node type\");\n\t\t\terror_found = true;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* format node upstream info */\n\n\tif (remote_node_rec_found == RECORD_NOT_FOUND)\n\t{\n\t\t/*\n\t\t * Unable to retrieve the node's copy of its own record - copy the\n\t\t * name from our own copy of the record\n\t\t */\n\t\tappendPQExpBuffer(upstream,\n\t\t\t\t\t\t  \"? %s\",\n\t\t\t\t\t\t  node_info->upstream_node_name);\n\t}\n\telse if (remote_node_rec.type == WITNESS)\n\t{\n\t\t/* no upstream - unlikely to happen */\n\t\tif (remote_node_rec.upstream_node_id == NO_UPSTREAM_NODE)\n\t\t{\n\t\t\tappendPQExpBufferStr(upstream, \"! \");\n\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) is a witness but reports it has no upstream node\",\n\t\t\t\t\t\t\t\t\tnode_info->node_name,\n\t\t\t\t\t\t\t\t\tnode_info->node_id);\n\t\t}\n\t\t/* mismatch between reported upstream and upstream in local node's metadata */\n\t\telse if (node_info->upstream_node_id != remote_node_rec.upstream_node_id)\n\t\t{\n\t\t\tappendPQExpBufferStr(upstream, \"! \");\n\n\t\t\tif (node_info->upstream_node_id != remote_node_rec.upstream_node_id)\n\t\t\t{\n\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) reports a different upstream (reported: \\\"%s\\\", expected \\\"%s\\\")\",\n\t\t\t\t\t\t\t\t\t\tnode_info->node_name,\n\t\t\t\t\t\t\t\t\t\tnode_info->node_id,\n\t\t\t\t\t\t\t\t\t\tremote_node_rec.upstream_node_name,\n\t\t\t\t\t\t\t\t\t\tnode_info->upstream_node_name);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt_node_info upstream_node_rec = T_NODE_INFO_INITIALIZER;\n\t\t\tRecordStatus upstream_node_rec_found = get_node_record(node_info->conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   node_info->upstream_node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &upstream_node_rec);\n\n\t\t\tif (upstream_node_rec_found != RECORD_FOUND)\n\t\t\t{\n\t\t\t\tappendPQExpBufferStr(upstream, \"? \");\n\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\"unable to find record for upstream node ID %i\",\n\t\t\t\t\t\t\t\t\t\tnode_info->upstream_node_id);\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tPGconn *upstream_conn = establish_db_connection_quiet(upstream_node_rec.conninfo);\n\n\t\t\t\tif (PQstatus(upstream_conn) != CONNECTION_OK)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(upstream, \"? \");\n\t\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\t\"unable to connect to node \\\"%s\\\" (ID: %i)'s upstream node \\\"%s\\\" (ID: %i)\",\n\t\t\t\t\t\t\t\t\t\t\tnode_info->node_name,\n\t\t\t\t\t\t\t\t\t\t\tnode_info->node_id,\n\t\t\t\t\t\t\t\t\t\t\tupstream_node_rec.node_name,\n\t\t\t\t\t\t\t\t\t\t\tupstream_node_rec.node_id);\n\t\t\t\t}\n\n\t\t\t\tPQfinish(upstream_conn);\n\t\t\t}\n\t\t}\n\n\t\tappendPQExpBufferStr(upstream,\n\t\t\t\t\t\t\t remote_node_rec.upstream_node_name);\n\n\t}\n\telse if (remote_node_rec.type == STANDBY)\n\t{\n\t\tif (node_info->upstream_node_id != NO_UPSTREAM_NODE && node_info->upstream_node_id == remote_node_rec.upstream_node_id)\n\t\t{\n\t\t\t/*\n\t\t\t * expected and reported upstreams match - check if node is actually\n\t\t\t * connected to the upstream\n\t\t\t */\n\t\t\tNodeAttached attached_to_upstream = NODE_ATTACHED_UNKNOWN;\n\t\t\tchar *replication_state = NULL;\n\t\t\tt_node_info upstream_node_rec = T_NODE_INFO_INITIALIZER;\n\t\t\tRecordStatus upstream_node_rec_found = get_node_record(node_info->conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   node_info->upstream_node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &upstream_node_rec);\n\n\t\t\tif (upstream_node_rec_found != RECORD_FOUND)\n\t\t\t{\n\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\"unable to find record for upstream node ID %i\",\n\t\t\t\t\t\t\t\t\t\tnode_info->upstream_node_id);\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tPGconn *upstream_conn = establish_db_connection_quiet(upstream_node_rec.conninfo);\n\n\t\t\t\tif (PQstatus(upstream_conn) != CONNECTION_OK)\n\t\t\t\t{\n\t\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\t\"unable to connect to node \\\"%s\\\" (ID: %i)'s upstream node \\\"%s\\\" (ID: %i)\",\n\t\t\t\t\t\t\t\t\t\t\tnode_info->node_name,\n\t\t\t\t\t\t\t\t\t\t\tnode_info->node_id,\n\t\t\t\t\t\t\t\t\t\t\tupstream_node_rec.node_name,\n\t\t\t\t\t\t\t\t\t\t\tupstream_node_rec.node_id);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tattached_to_upstream = is_downstream_node_attached(upstream_conn, node_info->node_name, &replication_state);\n\t\t\t\t}\n\n\t\t\t\tPQfinish(upstream_conn);\n\t\t\t}\n\n\t\t\tif (attached_to_upstream == NODE_ATTACHED_UNKNOWN)\n\t\t\t{\n\t\t\t\tappendPQExpBufferStr(upstream, \"? \");\n\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\"unable to determine if node \\\"%s\\\" (ID: %i) is attached to its upstream node \\\"%s\\\" (ID: %i)\",\n\t\t\t\t\t\t\t\t\t\tnode_info->node_name,\n\t\t\t\t\t\t\t\t\t\tnode_info->node_id,\n\t\t\t\t\t\t\t\t\t\tupstream_node_rec.node_name,\n\t\t\t\t\t\t\t\t\t\tupstream_node_rec.node_id);\n\t\t\t}\n\t\t\tif (attached_to_upstream == NODE_NOT_ATTACHED)\n\t\t\t{\n\t\t\t\tappendPQExpBufferStr(upstream, \"? \");\n\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) attached to its upstream node \\\"%s\\\" (ID: %i) in state \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tnode_info->node_name,\n\t\t\t\t\t\t\t\t\t\tnode_info->node_id,\n\t\t\t\t\t\t\t\t\t\tupstream_node_rec.node_name,\n\t\t\t\t\t\t\t\t\t\tupstream_node_rec.node_id,\n\t\t\t\t\t\t\t\t\t\treplication_state);\n\t\t\t}\n\n\t\t\telse if (attached_to_upstream == NODE_DETACHED)\n\t\t\t{\n\t\t\t\tappendPQExpBufferStr(upstream, \"! \");\n\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) is not attached to its upstream node \\\"%s\\\" (ID: %i)\",\n\t\t\t\t\t\t\t\t\t\tnode_info->node_name,\n\t\t\t\t\t\t\t\t\t\tnode_info->node_id,\n\t\t\t\t\t\t\t\t\t\tupstream_node_rec.node_name,\n\t\t\t\t\t\t\t\t\t\tupstream_node_rec.node_id);\n\t\t\t}\n\t\t\tappendPQExpBufferStr(upstream,\n\t\t\t\t\t\t\t\t node_info->upstream_node_name);\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (node_info->upstream_node_id != NO_UPSTREAM_NODE && remote_node_rec.upstream_node_id == NO_UPSTREAM_NODE)\n\t\t\t{\n\t\t\t\tappendPQExpBufferChar(upstream, '!');\n\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) reports it has no upstream (expected: \\\"%s\\\")\",\n\t\t\t\t\t\t\t\t\t\tnode_info->node_name,\n\t\t\t\t\t\t\t\t\t\tnode_info->node_id,\n\t\t\t\t\t\t\t\t\t\tnode_info->upstream_node_name);\n\t\t\t}\n\t\t\telse if (node_info->upstream_node_id != NO_UPSTREAM_NODE && remote_node_rec.upstream_node_id != NO_UPSTREAM_NODE)\n\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(upstream,\n\t\t\t\t\t\t\t\t  \"! %s\", remote_node_rec.upstream_node_name);\n\t\t\t\titem_list_append_format(warnings,\n\t\t\t\t\t\t\t\t\t\t\"node \\\"%s\\\" (ID: %i) reports a different upstream (reported: \\\"%s\\\", expected \\\"%s\\\")\",\n\t\t\t\t\t\t\t\t\t\tnode_info->node_name,\n\t\t\t\t\t\t\t\t\t\tnode_info->node_id,\n\t\t\t\t\t\t\t\t\t\tremote_node_rec.upstream_node_name,\n\t\t\t\t\t\t\t\t\t\tnode_info->upstream_node_name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn error_found;\n}\n\n\nstatic const char *\naction_name(const int action)\n{\n\tswitch (action)\n\t{\n\t\tcase PRIMARY_REGISTER:\n\t\t\treturn \"PRIMARY REGISTER\";\n\t\tcase PRIMARY_UNREGISTER:\n\t\t\treturn \"PRIMARY UNREGISTER\";\n\n\t\tcase STANDBY_CLONE:\n\t\t\treturn \"STANDBY CLONE\";\n\t\tcase STANDBY_REGISTER:\n\t\t\treturn \"STANDBY REGISTER\";\n\t\tcase STANDBY_UNREGISTER:\n\t\t\treturn \"STANDBY UNREGISTER\";\n\t\tcase STANDBY_PROMOTE:\n\t\t\treturn \"STANDBY PROMOTE\";\n\t\tcase STANDBY_FOLLOW:\n\t\t\treturn \"STANDBY FOLLOW\";\n\t\tcase STANDBY_SWITCHOVER:\n\t\t\treturn \"STANDBY SWITCHOVER\";\n\n\t\tcase WITNESS_REGISTER:\n\t\t\treturn \"WITNESS REGISTER\";\n\t\tcase WITNESS_UNREGISTER:\n\t\t\treturn \"WITNESS UNREGISTER\";\n\n\t\tcase NODE_STATUS:\n\t\t\treturn \"NODE STATUS\";\n\t\tcase NODE_CHECK:\n\t\t\treturn \"NODE CHECK\";\n\t\tcase NODE_REJOIN:\n\t\t\treturn \"NODE REJOIN\";\n\t\tcase NODE_SERVICE:\n\t\t\treturn \"NODE SERVICE\";\n\t\tcase NODE_CONTROL:\n\t\t\treturn \"NODE CONTROL\";\n\n\t\tcase CLUSTER_SHOW:\n\t\t\treturn \"CLUSTER SHOW\";\n\t\tcase CLUSTER_CLEANUP:\n\t\t\treturn \"CLUSTER CLEANUP\";\n\t\tcase CLUSTER_EVENT:\n\t\t\treturn \"CLUSTER EVENT\";\n\t\tcase CLUSTER_MATRIX:\n\t\t\treturn \"CLUSTER MATRIX\";\n\t\tcase CLUSTER_CROSSCHECK:\n\t\t\treturn \"CLUSTER CROSSCHECK\";\n\n\t\tcase SERVICE_STATUS:\n\t\t\treturn \"SERVICE STATUS\";\n\t\tcase SERVICE_PAUSE:\n\t\t\treturn \"SERVICE PAUSE\";\n\t\tcase SERVICE_UNPAUSE:\n\t\t\treturn \"SERVICE UNPAUSE\";\n\n\t\tcase DAEMON_START:\n\t\t\treturn \"DAEMON START\";\n\t\tcase DAEMON_STOP:\n\t\t\treturn \"DAEMON STOP\";\n\t}\n\n\treturn \"UNKNOWN ACTION\";\n}\n\n\nvoid\nprint_error_list(ItemList *error_list, int log_level)\n{\n\tItemListCell *cell = NULL;\n\n\tfor (cell = error_list->head; cell; cell = cell->next)\n\t{\n\t\tswitch (log_level)\n\t\t{\n\t\t\t\t/* Currently we only need errors and warnings */\n\t\t\tcase LOG_ERROR:\n\t\t\t\tlog_error(\"%s\", cell->string);\n\t\t\t\tbreak;\n\t\t\tcase LOG_WARNING:\n\t\t\t\tlog_warning(\"%s\", cell->string);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nvoid\nprint_status_header(int cols, ColHeader *headers)\n{\n\tint i, di;\n\tint max_cols = 0;\n\n\n\t/* count how many columns we actually need to display */\n\tfor (i = 0; i < cols; i++)\n\t{\n\t\tif (headers[i].display == true)\n\t\t\tmax_cols ++;\n\t}\n\n\tfor (i = 0; i < cols; i++)\n\t{\n\t\tif (headers[i].display == false)\n\t\t\tcontinue;\n\n\t\tif (i == 0)\n\t\t\tprintf(\" \");\n\t\telse\n\t\t\tprintf(\" | \");\n\n\t\tprintf(\"%-*s\",\n\t\t\t   headers[i].max_length,\n\t\t\t   headers[i].title);\n\t}\n\n\n\tprintf(\"\\n\");\n\tprintf(\"-\");\n\n\tdi = 0;\n\tfor (i = 0; i < cols; i++)\n\t{\n\t\tint\t\t\tj;\n\n\t\tif (headers[i].display == false)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < headers[i].max_length; j++)\n\t\t\tprintf(\"-\");\n\n\t\tif (di < (max_cols - 1))\n\t\t\tprintf(\"-+-\");\n\t\telse\n\t\t\tprintf(\"-\");\n\t\tdi++;\n\t}\n\n\tprintf(\"\\n\");\n}\n\n\nvoid\nprint_help_header(void)\n{\n\tprintf(_(\"%s: replication management tool for PostgreSQL\\n\"), progname());\n\tputs(\"\");\n\n\t/* add a big friendly warning if root is executing \"repmgr --help\" */\n\tif (geteuid() == 0)\n\t{\n\t\tprintf(_(\"\t**************************************************\\n\"));\n\t\tprintf(_(\"\t*** repmgr must be executed by a non-superuser ***\\n\"));\n\t\tprintf(_(\"\t**************************************************\\n\"));\n\t\tputs(\"\");\n\t}\n}\n\nstatic void\ndo_help(void)\n{\n\tprint_help_header();\n\n\tprintf(_(\"Usage:\\n\"));\n\tprintf(_(\"    %s [OPTIONS] primary {register|unregister}\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] standby {register|unregister|clone|promote|follow|switchover}\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] node    {status|check|rejoin|service}\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] cluster {show|event|matrix|crosscheck|cleanup}\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] witness {register|unregister}\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] service {status|pause|unpause}\\n\"), progname());\n\tprintf(_(\"    %s [OPTIONS] daemon  {start|stop}\\n\"), progname());\n\n\tputs(\"\");\n\n\tprintf(_(\"  Execute \\\"%s {primary|standby|node|cluster|witness|service} --help\\\" to see command-specific options\\n\"), progname());\n\n\tputs(\"\");\n\n\tprintf(_(\"General options:\\n\"));\n\tprintf(_(\"  -?, --help                          show this help, then exit\\n\"));\n\tprintf(_(\"  -V, --version                       output version information, then exit\\n\"));\n\tprintf(_(\"  --version-number                    output version number, then exit\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"General configuration options:\\n\"));\n\tprintf(_(\"  -b, --pg_bindir=PATH                path to PostgreSQL binaries (optional)\\n\"));\n\tprintf(_(\"  -f, --config-file=PATH              path to the repmgr configuration file\\n\"));\n\tprintf(_(\"  -F, --force                         force potentially dangerous operations to happen\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"Database connection options:\\n\"));\n\tprintf(_(\"  -d, --dbname=DBNAME                 database to connect to (default: \"));\n\tif (runtime_options.dbname[0] != '\\0')\n\t\tprintf(_(\"\\\"%s\\\")\\n\"), runtime_options.dbname);\n\telse\n\t\tprintf(_(\"\\\"%s\\\")\\n\"), runtime_options.username);\n\n\tprintf(_(\"  -h, --host=HOSTNAME                 database server host\"));\n\tif (runtime_options.host[0] != '\\0')\n\t\tprintf(_(\" (default: \\\"%s\\\")\"), runtime_options.host);\n\tprintf(_(\"\\n\"));\n\n\tprintf(_(\"  -p, --port=PORT                     database server port (default: \\\"%s\\\")\\n\"), runtime_options.port);\n\tprintf(_(\"  -U, --username=USERNAME             database user name to connect as (default: \\\"%s\\\")\\n\"), runtime_options.username);\n\n\tputs(\"\");\n\n\tprintf(_(\"Node-specific options:\\n\"));\n\tprintf(_(\"  -D, --pgdata=DIR                    location of the node's data directory \\n\"));\n\tprintf(_(\"  --node-id                           specify a node by id (only available for some operations)\\n\"));\n\tprintf(_(\"  --node-name                         specify a node by name (only available for some operations)\\n\"));\n\n\tputs(\"\");\n\n\tprintf(_(\"Logging options:\\n\"));\n\tprintf(_(\"  --dry-run                           show what would happen for action, but don't execute it\\n\"));\n\tprintf(_(\"  -L, --log-level                     set log level (overrides configuration file; default: NOTICE)\\n\"));\n\tprintf(_(\"  --log-to-file                       log to file (or logging facility) defined in repmgr.conf\\n\"));\n\tprintf(_(\"  -q, --quiet                         suppress all log output apart from errors\\n\"));\n\tprintf(_(\"  -t, --terse                         don't display detail, hints and other non-critical output\\n\"));\n\tprintf(_(\"  -v, --verbose                       display additional log output (useful for debugging)\\n\"));\n\n\tputs(\"\");\n\n\tprintf(_(\"%s home page: <%s>\\n\"), \"repmgr\", REPMGR_URL);\n}\n\n\n/*\n * Create the repmgr extension, and grant access for the repmgr\n * user if not a superuser.\n *\n * Note:\n *   This is one of two places where superuser rights are required.\n *   We should also consider possible scenarios where a non-superuser\n *   has sufficient privileges to install the extension.\n */\n\nbool\ncreate_repmgr_extension(PGconn *conn)\n{\n\tPQExpBufferData query;\n\tPGresult   *res;\n\n\tExtensionStatus extension_status = REPMGR_UNKNOWN;\n\n\tt_connection_user userinfo = T_CONNECTION_USER_INITIALIZER;\n\tbool\t\tis_superuser = false;\n\tPGconn\t   *superuser_conn = NULL;\n\tPGconn\t   *schema_create_conn = NULL;\n\tt_extension_versions extversions = T_EXTENSION_VERSIONS_INITIALIZER;\n\n\textension_status = get_repmgr_extension_status(conn, &extversions);\n\n\tswitch (extension_status)\n\t{\n\t\tcase REPMGR_UNKNOWN:\n\t\t\tlog_error(_(\"unable to determine status of \\\"repmgr\\\" extension\"));\n\t\t\treturn false;\n\n\t\tcase REPMGR_UNAVAILABLE:\n\t\t\tlog_error(_(\"\\\"repmgr\\\" extension is not available\"));\n\t\t\treturn false;\n\n\t\tcase REPMGR_OLD_VERSION_INSTALLED:\n\t\t\tlog_error(_(\"an older version of the \\\"repmgr\\\" extension is installed\"));\n\t\t\tlog_detail(_(\"version %s is installed but newer version %s is available\"),\n\t\t\t\t\t   extversions.installed_version,\n\t\t\t\t\t   extversions.default_version);\n\t\t\tlog_hint(_(\"update the installed extension version by executing \\\"ALTER EXTENSION repmgr UPDATE\\\" in the repmgr database\"));\n\t\t\treturn false;\n\n\t\tcase REPMGR_INSTALLED:\n\t\t\tlog_info(_(\"\\\"repmgr\\\" extension is already installed\"));\n\t\t\treturn true;\n\n\t\tcase REPMGR_AVAILABLE:\n\t\t\tif (runtime_options.dry_run == true)\n\t\t\t{\n\t\t\t\tlog_notice(_(\"would now attempt to install extension \\\"repmgr\\\"\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_notice(_(\"attempting to install extension \\\"repmgr\\\"\"));\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\t/* 3. Attempt to get a superuser connection */\n\n\tis_superuser = is_superuser_connection(conn, &userinfo);\n\n\tget_superuser_connection(&conn, &superuser_conn, &schema_create_conn);\n\n\tif (runtime_options.dry_run == true)\n\t\treturn true;\n\n\t/* 4. Create extension */\n\n\tres = PQexec(schema_create_conn, \"CREATE EXTENSION repmgr\");\n\n\tif ((PQresultStatus(res) != PGRES_COMMAND_OK && PQresultStatus(res) != PGRES_TUPLES_OK))\n\t{\n\t\tlog_error(_(\"unable to create \\\"repmgr\\\" extension:\\n  %s\"),\n\t\t\t\t  PQerrorMessage(schema_create_conn));\n\t\tlog_hint(_(\"check that the provided user has sufficient privileges for CREATE EXTENSION\"));\n\n\t\tPQclear(res);\n\t\tif (superuser_conn != NULL)\n\t\t\tPQfinish(superuser_conn);\n\t\treturn false;\n\t}\n\n\tPQclear(res);\n\n\t/* 5. If not superuser, grant usage */\n\tif (is_superuser == false)\n\t{\n\t\tinitPQExpBuffer(&query);\n\n\t\tappendPQExpBuffer(&query,\n\t\t\t\t\t\t  \"GRANT USAGE ON SCHEMA repmgr TO %s\",\n\t\t\t\t\t\t  userinfo.username);\n\n\t\tres = PQexec(schema_create_conn, query.data);\n\t\ttermPQExpBuffer(&query);\n\n\t\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t\t{\n\t\t\tlog_error(_(\"unable to grant usage on \\\"repmgr\\\" extension to %s:\\n  %s\"),\n\t\t\t\t\t  userinfo.username,\n\t\t\t\t\t  PQerrorMessage(schema_create_conn));\n\t\t\tPQclear(res);\n\n\t\t\tif (superuser_conn != 0)\n\t\t\t\tPQfinish(superuser_conn);\n\n\t\t\treturn false;\n\t\t}\n\n\t\tinitPQExpBuffer(&query);\n\n\t\tappendPQExpBuffer(&query,\n\t\t\t\t\t\t  \"GRANT ALL ON ALL TABLES IN SCHEMA repmgr TO %s\",\n\t\t\t\t\t\t  userinfo.username);\n\n\t\tres = PQexec(schema_create_conn, query.data);\n\t\ttermPQExpBuffer(&query);\n\n\t\tif (PQresultStatus(res) != PGRES_COMMAND_OK)\n\t\t{\n\t\t\tlog_error(_(\"unable to grant permission on tables on \\\"repmgr\\\" extension to %s:\\n  %s\"),\n\t\t\t\t\t  userinfo.username,\n\t\t\t\t\t  PQerrorMessage(schema_create_conn));\n\t\t\tPQclear(res);\n\n\t\t\tif (superuser_conn != NULL)\n\t\t\t\tPQfinish(superuser_conn);\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (superuser_conn != NULL)\n\t\tPQfinish(superuser_conn);\n\n\tlog_notice(_(\"\\\"repmgr\\\" extension successfully installed\"));\n\n\tcreate_event_notification(conn,\n\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t  \"cluster_created\",\n\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t  NULL);\n\n\treturn true;\n}\n\n\n/**\n * check_server_version()\n *\n * Verify that the server is MIN_SUPPORTED_VERSION_NUM or later\n *\n * PGconn *conn:\n *\t the connection to check\n *\n * char *server_type:\n *\t either \"primary\" or \"standby\"; used to format error message\n *\n * bool exit_on_error:\n *\t exit if reported server version is too low; optional to enable some callers\n *\t to perform additional cleanup\n *\n * char *server_version_string\n *\t passed to get_server_version(), which will place the human-readable\n *\t server version string there (e.g. \"9.4.0\")\n */\nint\ncheck_server_version(PGconn *conn, char *server_type, bool exit_on_error, char *server_version_string)\n{\n\tchar\t\tversion_string[MAXVERSIONSTR] = \"\";\n\tint\t\t\tconn_server_version_num = get_server_version(conn, version_string);\n\n\t/* Copy the version string, if the caller wants it */\n\tif (server_version_string != NULL)\n\t\tstrncpy(server_version_string, version_string, MAXVERSIONSTR);\n\n\tif (conn_server_version_num < MIN_SUPPORTED_VERSION_NUM)\n\t{\n\t\tif (conn_server_version_num > 0)\n\t\t{\n\t\t\tlog_error(_(\"%s requires %s to be PostgreSQL %s or later\"),\n\t\t\t\t\t  progname(),\n\t\t\t\t\t  server_type,\n\t\t\t\t\t  MIN_SUPPORTED_VERSION);\n\t\t\tlog_detail(_(\"%s server version is %s\"),\n\t\t\t\t\t   server_type,\n\t\t\t\t\t   version_string);\n\t\t}\n\n\t\tif (exit_on_error == true)\n\t\t{\n\t\t\tPQfinish(conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\treturn UNKNOWN_SERVER_VERSION_NUM;\n\t}\n\n\t/*\n\t * If it's clear a particular repmgr feature branch won't be able to support\n\t * PostgreSQL from a particular PostgreSQL release onwards (e.g. 4.4 with PostgreSQL\n\t * 12 and later due to recovery.conf removal), set MAX_UNSUPPORTED_VERSION and\n\t * MAX_UNSUPPORTED_VERSION_NUM in \"repmgr.h\" to define the first PostgreSQL\n\t * version which can't be supported.\n\t */\n#ifdef MAX_UNSUPPORTED_VERSION_NUM\n\tif (conn_server_version_num >= MAX_UNSUPPORTED_VERSION_NUM)\n\t{\n\t\tif (conn_server_version_num > 0)\n\t\t{\n\t\t\tlog_error(_(\"%s %s does not support PostgreSQL %s or later\"),\n\t\t\t\t\t  progname(),\n\t\t\t\t\t  REPMGR_VERSION,\n\t\t\t\t\t  MAX_UNSUPPORTED_VERSION);\n\t\t\tlog_detail(_(\"%s server version is %s\"),\n\t\t\t\t\t   server_type,\n\t\t\t\t\t   version_string);\n\t\t\tlog_hint(_(\"For details of supported versions see: https://repmgr.org/docs/current/install-requirements.html#INSTALL-COMPATIBILITY-MATRIX\"));\n\t\t}\n\n\t\tif (exit_on_error == true)\n\t\t{\n\t\t\tPQfinish(conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\treturn UNKNOWN_SERVER_VERSION_NUM;\n\t}\n#endif\n\n\treturn conn_server_version_num;\n}\n\n\nint\ntest_ssh_connection(char *host, char *remote_user)\n{\n\tchar\t\tscript[MAXLEN] = \"\";\n\tint\t\t\tr = 1,\n\t\t\t\ti;\n\n\t/*\n\t * On some OS, true is located in a different place than in Linux we have\n\t * to try them all until all alternatives are gone or we found `true'\n\t * because the target OS may differ from the source OS\n\t */\n\tconst char *bin_true_paths[] = {\n\t\t\"/bin/true\",\n\t\t\"/usr/bin/true\",\n\t\tNULL\n\t};\n\n\tfor (i = 0; bin_true_paths[i] && r != 0; ++i)\n\t{\n\t\tif (!remote_user[0])\n\t\t\tmaxlen_snprintf(script, \"ssh -o Batchmode=yes %s %s %s 2>/dev/null\",\n\t\t\t\t\t\t\tconfig_file_options.ssh_options, host, bin_true_paths[i]);\n\t\telse\n\t\t\tmaxlen_snprintf(script, \"ssh -o Batchmode=yes %s %s -l %s %s 2>/dev/null\",\n\t\t\t\t\t\t\tconfig_file_options.ssh_options, host, remote_user,\n\t\t\t\t\t\t\tbin_true_paths[i]);\n\n\t\tlog_verbose(LOG_DEBUG, _(\"test_ssh_connection(): executing %s\"), script);\n\t\tr = system(script);\n\t}\n\n\tif (r != 0)\n\t\tlog_warning(_(\"unable to connect to remote host \\\"%s\\\" via SSH\"), host);\n\n\treturn r;\n}\n\n\n\n\n/*\n * get_superuser_connection()\n *\n * Check if provided connection \"conn\" is a superuser connection, if not attempt to\n * make a superuser connection \"superuser_conn\" with the provided --superuser parameter.\n *\n * \"privileged_conn\" is set to whichever connection is the superuser connection.\n */\nvoid\nget_superuser_connection(PGconn **conn, PGconn **superuser_conn, PGconn **privileged_conn)\n{\n\tt_connection_user userinfo = T_CONNECTION_USER_INITIALIZER;\n\tt_conninfo_param_list conninfo_params = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\tbool\t\tis_superuser = false;\n\n\t/* this should never happen */\n\tif (PQstatus(*conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"no database connection available\"));\n\t\tlog_detail(\"\\n%s\", PQerrorMessage(*conn));\n\t\texit(ERR_INTERNAL);\n\t}\n\n\tis_superuser = is_superuser_connection(*conn, &userinfo);\n\n\tif (is_superuser == true)\n\t{\n\t\t*privileged_conn = *conn;\n\n\t\treturn;\n\t}\n\n\tif (runtime_options.superuser[0] == '\\0')\n\t{\n\t\tlog_error(_(\"\\\"%s\\\" is not a superuser and no superuser name supplied\"), userinfo.username);\n\t\tlog_hint(_(\"supply a valid superuser name with -S/--superuser\"));\n\t\tPQfinish(*conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tinitialize_conninfo_params(&conninfo_params, false);\n\tconn_to_param_list(*conn, &conninfo_params);\n\tparam_set(&conninfo_params, \"user\", runtime_options.superuser);\n\n\t*superuser_conn = establish_db_connection_by_params(&conninfo_params, false);\n\n\tif (PQstatus(*superuser_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to establish superuser connection as \\\"%s\\\"\"),\n\t\t\t\t  runtime_options.superuser);\n\n\t\tPQfinish(*conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* check provided superuser really is superuser */\n\tif (!is_superuser_connection(*superuser_conn, NULL))\n\t{\n\t\tlog_error(_(\"\\\"%s\\\" is not a superuser\"), runtime_options.superuser);\n\t\tPQfinish(*superuser_conn);\n\t\tPQfinish(*conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tlog_debug(\"established superuser connection as \\\"%s\\\"\", runtime_options.superuser);\n\n\t*privileged_conn = *superuser_conn;\n\treturn;\n}\n\n\nstandy_clone_mode\nget_standby_clone_mode(void)\n{\n\tstandy_clone_mode mode;\n\n\tif (*config_file_options.barman_host != '\\0' && runtime_options.without_barman == false)\n\t\tmode = barman;\n\telse {\n\t\tif (*config_file_options.pg_backupapi_host != '\\0') {\n\t\t\tlog_info(\"Attempting to use `pg_backupapi` new restore mode\");\n\t\t\tmode = pg_backupapi;\n\t\t}\n\t\telse\n\t\t\tmode = pg_basebackup;\n\t}\n\treturn mode;\n}\n\n\nvoid\nmake_pg_path(PQExpBufferData *buf, const char *file)\n{\n\tappendPQExpBuffer(buf, \"%s%s\",\n\t\t\t\t\t  pg_bindir, file);\n}\n\n\nint\ncopy_remote_files(char *host, char *remote_user, char *remote_path,\n\t\t\t\t  char *local_path, bool is_directory, int server_version_num)\n{\n\tPQExpBufferData rsync_flags;\n\tchar\t\tscript[MAXLEN] = \"\";\n\tchar\t\thost_string[MAXLEN] = \"\";\n\tint\t\t\tr = 0;\n\n\tinitPQExpBuffer(&rsync_flags);\n\n\tif (*config_file_options.rsync_options == '\\0')\n\t{\n\t\tappendPQExpBufferStr(&rsync_flags,\n\t\t\t\t\t\t\t \"--archive --checksum --compress --progress --rsh=ssh\");\n\t}\n\telse\n\t{\n\t\tappendPQExpBufferStr(&rsync_flags,\n\t\t\t\t\t\t\t config_file_options.rsync_options);\n\t}\n\n\tif (runtime_options.force)\n\t{\n\t\tappendPQExpBufferStr(&rsync_flags,\n\t\t\t\t\t\t\t \" --delete --checksum\");\n\t}\n\n\tif (!remote_user[0])\n\t{\n\t\tmaxlen_snprintf(host_string, \"%s\", host);\n\t}\n\telse\n\t{\n\t\tmaxlen_snprintf(host_string, \"%s@%s\", remote_user, host);\n\t}\n\n\t/*\n\t * When copying the main PGDATA directory, certain files and contents of\n\t * certain directories need to be excluded.\n\t *\n\t * See function 'sendDir()' in 'src/backend/replication/basebackup.c' -\n\t * we're basically simulating what pg_basebackup does, but with rsync\n\t * rather than the BASEBACKUP replication protocol command.\n\t *\n\t * *However* currently we'll always copy the contents of the 'pg_replslot'\n\t * directory and delete later if appropriate.\n\t */\n\tif (is_directory)\n\t{\n\t\t/* Files which we don't want */\n\t\tappendPQExpBufferStr(&rsync_flags,\n\t\t\t\t\t\t\t \" --exclude=postmaster.pid --exclude=postmaster.opts --exclude=global/pg_control\");\n\n\t\tappendPQExpBufferStr(&rsync_flags,\n\t\t\t\t\t\t\t \" --exclude=recovery.conf --exclude=recovery.done\");\n\n\t\t/*\n\t\t * Ideally we'd use PG_AUTOCONF_FILENAME from utils/guc.h, but\n\t\t * that has too many dependencies for a mere client program.\n\t\t */\n\t\tappendPQExpBuffer(&rsync_flags, \" --exclude=%s.tmp\",\n\t\t\t\t\t\t  PG_AUTOCONF_FILENAME);\n\n\t\t/* Temporary files which we don't want, if they exist */\n\t\tappendPQExpBuffer(&rsync_flags, \" --exclude=%s*\",\n\t\t\t\t\t\t  PG_TEMP_FILE_PREFIX);\n\n\t\t/* Directories which we don't want */\n\n\t\tif (server_version_num >= 100000)\n\t\t{\n\t\t\tappendPQExpBufferStr(&rsync_flags,\n\t\t\t\t\t\t\t\t \" --exclude=pg_wal/* --exclude=log/*\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappendPQExpBufferStr(&rsync_flags,\n\t\t\t\t\t\t\t\t \" --exclude=pg_xlog/* --exclude=pg_log/*\");\n\t\t}\n\n\t\t/*\n\t\t * From PostgreSQL 15, the core server no longer uses pg_stat_tmp,\n\t\t * but some extensions (e.g. pg_stat_statements) may still do, so\n\t\t * keep excluding it.\n\t\t */\n\t\tappendPQExpBufferStr(&rsync_flags,\n\t\t\t\t\t\t\t \" --exclude=pg_stat_tmp/*\");\n\n\t\tmaxlen_snprintf(script, \"rsync %s %s:%s/* %s\",\n\t\t\t\t\t\trsync_flags.data, host_string, remote_path, local_path);\n\t}\n\telse\n\t{\n\t\tmaxlen_snprintf(script, \"rsync %s %s:%s %s\",\n\t\t\t\t\t\trsync_flags.data, host_string, remote_path, local_path);\n\t}\n\n\ttermPQExpBuffer(&rsync_flags);\n\n\tlog_info(_(\"rsync command line:\\n  %s\"), script);\n\n\tr = system(script);\n\n\tlog_debug(\"copy_remote_files(): r = %i; WIFEXITED: %i; WEXITSTATUS: %i\", r, WIFEXITED(r), WEXITSTATUS(r));\n\n\t/* exit code 24 indicates vanished files, which isn't a problem for us */\n\tif (WIFEXITED(r) && WEXITSTATUS(r) && WEXITSTATUS(r) != 24)\n\t\tlog_verbose(LOG_WARNING, \"copy_remote_files(): rsync returned unexpected exit status %i\", WEXITSTATUS(r));\n\n\treturn r;\n}\n\n\n\n\nvoid\nmake_remote_repmgr_path(PQExpBufferData *output_buf, t_node_info *remote_node_record)\n{\n\tif (config_file_options.repmgr_bindir[0] != '\\0')\n\t{\n\t\tint\t\t\tlen = strlen(config_file_options.repmgr_bindir);\n\n\t\tappendPQExpBufferStr(output_buf,\n\t\t\t\t\t\t\t config_file_options.repmgr_bindir);\n\n\t\t/* Add trailing slash */\n\t\tif (config_file_options.repmgr_bindir[len - 1] != '/')\n\t\t{\n\t\t\tappendPQExpBufferChar(output_buf, '/');\n\t\t}\n\t}\n\telse if (pg_bindir[0] != '\\0')\n\t{\n\t\tappendPQExpBufferStr(output_buf,\n\t\t\t\t\t\t\t pg_bindir);\n\t}\n\n\tappendPQExpBuffer(output_buf,\n\t\t\t\t\t  \"%s -f %s \",\n\t\t\t\t\t  progname(),\n\t\t\t\t\t  remote_node_record->config_file);\n\n\t/*\n\t * If --log-level was explicitly supplied, pass that through\n\t * to the remote repmgr client too.\n\t */\n\tif (runtime_options.log_level[0] != '\\0')\n\t{\n\t\tappendPQExpBuffer(output_buf,\n\t\t\t\t\t\t  \" -L %s \",\n\t\t\t\t\t\t  runtime_options.log_level);\n\t}\n\n}\n\n\nvoid\nmake_repmgrd_path(PQExpBufferData *output_buf)\n{\n\tif (config_file_options.repmgr_bindir[0] != '\\0')\n\t{\n\t\tint\t\t\tlen = strlen(config_file_options.repmgr_bindir);\n\n\t\tappendPQExpBufferStr(output_buf,\n\t\t\t\t\t\t\t config_file_options.repmgr_bindir);\n\n\t\t/* Add trailing slash */\n\t\tif (config_file_options.repmgr_bindir[len - 1] != '/')\n\t\t{\n\t\t\tappendPQExpBufferChar(output_buf, '/');\n\t\t}\n\t}\n\telse if (pg_bindir[0] != '\\0')\n\t{\n\t\tappendPQExpBufferStr(output_buf,\n\t\t\t\t\t\t\t pg_bindir);\n\t}\n\n\tappendPQExpBuffer(output_buf,\n\t\t\t\t\t  \"repmgrd -f %s \",\n\t\t\t\t\t  config_file_path);\n}\n\n\n/* ======================== */\n/* server control functions */\n/* ======================== */\n\nvoid\nget_server_action(t_server_action action, char *script, char *data_dir)\n{\n\tPQExpBufferData command;\n\n\tif (data_dir == NULL || data_dir[0] == '\\0')\n\t\tdata_dir = \"(none provided)\";\n\n\tswitch (action)\n\t{\n\t\tcase ACTION_NONE:\n\t\t\tscript[0] = '\\0';\n\t\t\treturn;\n\n\t\tcase ACTION_START:\n\t\t\t{\n\t\t\t\tif (config_file_options.service_start_command[0] != '\\0')\n\t\t\t\t{\n\t\t\t\t\tmaxlen_snprintf(script, \"%s\",\n\t\t\t\t\t\t\t\t\tconfig_file_options.service_start_command);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinitPQExpBuffer(&command);\n\n\t\t\t\t\tmake_pg_path(&command, \"pg_ctl\");\n\n\t\t\t\t\tappendPQExpBuffer(&command,\n\t\t\t\t\t\t\t\t\t  \" %s -w -D \",\n\t\t\t\t\t\t\t\t\t  config_file_options.pg_ctl_options);\n\n\t\t\t\t\tappendShellString(&command,\n\t\t\t\t\t\t\t\t\t  data_dir);\n\n\t\t\t\t\tappendPQExpBuffer(&command,\n\t\t\t\t\t\t\t\t\t  \" start\");\n\n\t\t\t\t\tstrncpy(script, command.data, MAXLEN);\n\n\t\t\t\t\ttermPQExpBuffer(&command);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcase ACTION_STOP:\n\t\tcase ACTION_STOP_WAIT:\n\t\t\t{\n\t\t\t\tif (config_file_options.service_stop_command[0] != '\\0')\n\t\t\t\t{\n\t\t\t\t\tmaxlen_snprintf(script, \"%s\",\n\t\t\t\t\t\t\t\t\tconfig_file_options.service_stop_command);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinitPQExpBuffer(&command);\n\t\t\t\t\tmake_pg_path(&command, \"pg_ctl\");\n\n\t\t\t\t\tappendPQExpBuffer(&command,\n\t\t\t\t\t\t\t\t\t  \" %s -D \",\n\t\t\t\t\t\t\t\t\t  config_file_options.pg_ctl_options);\n\n\t\t\t\t\tappendShellString(&command,\n\t\t\t\t\t\t\t\t\t  data_dir);\n\n\t\t\t\t\tif (action == ACTION_STOP_WAIT)\n\t\t\t\t\t\tappendPQExpBuffer(&command,\n\t\t\t\t\t\t\t\t\t\t  \" -w\");\n\t\t\t\t\telse\n\t\t\t\t\t\tappendPQExpBuffer(&command,\n\t\t\t\t\t\t\t\t\t\t  \" -W\");\n\n\t\t\t\t\tappendPQExpBuffer(&command,\n\t\t\t\t\t\t\t\t\t  \" -m fast stop\");\n\n\t\t\t\t\tstrncpy(script, command.data, MAXLEN);\n\n\t\t\t\t\ttermPQExpBuffer(&command);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcase ACTION_RESTART:\n\t\t\t{\n\t\t\t\tif (config_file_options.service_restart_command[0] != '\\0')\n\t\t\t\t{\n\t\t\t\t\tmaxlen_snprintf(script, \"%s\",\n\t\t\t\t\t\t\t\t\tconfig_file_options.service_restart_command);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinitPQExpBuffer(&command);\n\n\t\t\t\t\tmake_pg_path(&command, \"pg_ctl\");\n\n\t\t\t\t\tappendPQExpBuffer(&command,\n\t\t\t\t\t\t\t\t\t  \" %s -w -D \",\n\t\t\t\t\t\t\t\t\t  config_file_options.pg_ctl_options);\n\n\t\t\t\t\tappendShellString(&command,\n\t\t\t\t\t\t\t\t\t  data_dir);\n\n\t\t\t\t\tappendPQExpBuffer(&command,\n\t\t\t\t\t\t\t\t\t  \" restart\");\n\n\t\t\t\t\tstrncpy(script, command.data, MAXLEN);\n\n\t\t\t\t\ttermPQExpBuffer(&command);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcase ACTION_RELOAD:\n\t\t\t{\n\t\t\t\tif (config_file_options.service_reload_command[0] != '\\0')\n\t\t\t\t{\n\t\t\t\t\tmaxlen_snprintf(script, \"%s\",\n\t\t\t\t\t\t\t\t\tconfig_file_options.service_reload_command);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinitPQExpBuffer(&command);\n\n\t\t\t\t\tmake_pg_path(&command, \"pg_ctl\");\n\n\t\t\t\t\tappendPQExpBuffer(&command,\n\t\t\t\t\t\t\t\t\t  \" %s -w -D \",\n\t\t\t\t\t\t\t\t\t  config_file_options.pg_ctl_options);\n\n\t\t\t\t\tappendShellString(&command,\n\t\t\t\t\t\t\t\t\t  data_dir);\n\n\t\t\t\t\tappendPQExpBuffer(&command,\n\t\t\t\t\t\t\t\t\t  \" reload\");\n\n\t\t\t\t\tstrncpy(script, command.data, MAXLEN);\n\n\t\t\t\t\ttermPQExpBuffer(&command);\n\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tcase ACTION_PROMOTE:\n\t\t\t{\n\t\t\t\tif (config_file_options.service_promote_command[0] != '\\0')\n\t\t\t\t{\n\t\t\t\t\tmaxlen_snprintf(script, \"%s\",\n\t\t\t\t\t\t\t\t\tconfig_file_options.service_promote_command);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinitPQExpBuffer(&command);\n\n\t\t\t\t\tmake_pg_path(&command, \"pg_ctl\");\n\n\t\t\t\t\tappendPQExpBuffer(&command,\n\t\t\t\t\t\t\t\t\t  \" %s -w -D \",\n\t\t\t\t\t\t\t\t\t  config_file_options.pg_ctl_options);\n\n\t\t\t\t\tappendShellString(&command,\n\t\t\t\t\t\t\t\t\t  data_dir);\n\n\t\t\t\t\tappendPQExpBuffer(&command,\n\t\t\t\t\t\t\t\t\t  \" promote\");\n\n\t\t\t\t\tstrncpy(script, command.data, MAXLEN);\n\n\t\t\t\t\ttermPQExpBuffer(&command);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\tdefault:\n\t\t\treturn;\n\t}\n\n\treturn;\n}\n\n\nbool\ndata_dir_required_for_action(t_server_action action)\n{\n\tswitch (action)\n\t{\n\t\tcase ACTION_NONE:\n\t\t\treturn false;\n\n\t\tcase ACTION_START:\n\t\t\tif (config_file_options.service_start_command[0] != '\\0')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\n\t\tcase ACTION_STOP:\n\t\tcase ACTION_STOP_WAIT:\n\t\t\tif (config_file_options.service_stop_command[0] != '\\0')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\n\t\tcase ACTION_RESTART:\n\t\t\tif (config_file_options.service_restart_command[0] != '\\0')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\n\t\tcase ACTION_RELOAD:\n\t\t\tif (config_file_options.service_reload_command[0] != '\\0')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\n\t\tcase ACTION_PROMOTE:\n\t\t\tif (config_file_options.service_promote_command[0] != '\\0')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\n\treturn false;\n}\n\n\n/*\n * Copy the location of the configuration file directory into the\n * provided buffer; if \"config_directory\" provided, use that, otherwise\n * default to the data directory.\n *\n * This is primarily intended for use with \"pg_ctl\" (which itself shouldn't\n * be used outside of development environments).\n */\nvoid\nget_node_config_directory(char *config_dir_buf)\n{\n\tif (config_file_options.config_directory[0] != '\\0')\n\t{\n\t\tstrncpy(config_dir_buf, config_file_options.config_directory, MAXPGPATH);\n\t\treturn;\n\t}\n\n\tif (config_file_options.data_directory[0] != '\\0')\n\t{\n\t\tstrncpy(config_dir_buf, config_file_options.data_directory, MAXPGPATH);\n\t\treturn;\n\t}\n\n\treturn;\n}\n\n\nvoid\nget_node_data_directory(char *data_dir_buf)\n{\n\t/*\n\t * the configuration file setting has priority, and will always be set\n\t * when a configuration file was provided\n\t */\n\tif (config_file_options.data_directory[0] != '\\0')\n\t{\n\t\tstrncpy(data_dir_buf, config_file_options.data_directory, MAXPGPATH);\n\t\treturn;\n\t}\n\n\tif (runtime_options.data_dir[0] != '\\0')\n\t{\n\t\tstrncpy(data_dir_buf, runtime_options.data_dir, MAXPGPATH);\n\t\treturn;\n\t}\n\n\treturn;\n}\n\n\n/*\n * initialise a node record from the provided configuration\n * parameters\n */\nvoid\ninit_node_record(t_node_info *node_record)\n{\n\tnode_record->node_id = config_file_options.node_id;\n\tnode_record->upstream_node_id = runtime_options.upstream_node_id;\n\tnode_record->priority = config_file_options.priority;\n\tnode_record->active = true;\n\n\tif (config_file_options.location[0] != '\\0')\n\t\tstrncpy(node_record->location, config_file_options.location, MAXLEN);\n\telse\n\t\tstrncpy(node_record->location, \"default\", MAXLEN);\n\n\n\tstrncpy(node_record->node_name, config_file_options.node_name, sizeof(node_record->node_name));\n\tstrncpy(node_record->conninfo, config_file_options.conninfo, MAXLEN);\n\tstrncpy(node_record->config_file, config_file_path, MAXPGPATH);\n\n\tif (config_file_options.replication_user[0] != '\\0')\n\t{\n\t\t/* replication user explicitly provided in configuration file */\n\t\tstrncpy(node_record->repluser, config_file_options.replication_user, NAMEDATALEN);\n\t}\n\telse\n\t{\n\t\t/* use the \"user\" value from \"conninfo\" */\n\t\tchar\t\trepluser[MAXLEN] = \"\";\n\n\t\t(void) get_conninfo_value(config_file_options.conninfo, \"user\", repluser);\n\t\tstrncpy(node_record->repluser, repluser, NAMEDATALEN);\n\t}\n\n\tif (config_file_options.use_replication_slots == true)\n\t{\n\t\tcreate_slot_name(node_record->slot_name, config_file_options.node_id);\n\t}\n}\n\n\nbool\ncan_use_pg_rewind(PGconn *conn, const char *data_directory, PQExpBufferData *reason)\n{\n\tbool\t\tcan_use = true;\n\n\t/* \"full_page_writes\" must be on in any case */\n\tif (guc_set(conn, \"full_page_writes\", \"=\", \"off\"))\n\t{\n\t\tappendPQExpBufferStr(reason,\n\t\t\t\t\t\t\t _(\"\\\"full_page_writes\\\" must be set to \\\"on\\\"\"));\n\n\t\tcan_use = false;\n\t}\n\n\t/*\n\t * \"wal_log_hints\" off - are data checksums available? Note: we're\n\t * checking the local pg_control file here as the value will be the same\n\t * throughout the cluster and saves a round-trip to the demotion\n\t * candidate.\n\t */\n\tif (guc_set(conn, \"wal_log_hints\", \"=\", \"on\") == false)\n\t{\n\t\tint\t\t\tdata_checksum_version = get_data_checksum_version(data_directory);\n\n\t\tif (data_checksum_version == UNKNOWN_DATA_CHECKSUM_VERSION)\n\t\t{\n\t\t\tif (can_use == false)\n\t\t\t\tappendPQExpBufferStr(reason, \"; \");\n\n\t\t\tappendPQExpBufferStr(reason,\n\t\t\t\t\t\t\t\t _(\"\\\"wal_log_hints\\\" is set to \\\"off\\\" but unable to determine data checksum version\"));\n\t\t\tcan_use = false;\n\t\t}\n\t\telse if (data_checksum_version == 0)\n\t\t{\n\t\t\tif (can_use == false)\n\t\t\t\tappendPQExpBufferStr(reason, \"; \");\n\n\t\t\tappendPQExpBufferStr(reason,\n\t\t\t\t\t\t\t  _(\"\\\"wal_log_hints\\\" is set to \\\"off\\\" and data checksums are disabled\"));\n\n\t\t\tcan_use = false;\n\t\t}\n\t}\n\n\treturn can_use;\n}\n\n\nvoid\nmake_standby_signal_path(const char *data_dir, char *buf)\n{\n\tsnprintf(buf, MAXPGPATH,\n\t\t\t \"%s/%s\",\n\t\t\t data_dir,\n\t\t\t STANDBY_SIGNAL_FILE);\n}\n\n/*\n * create standby.signal (PostgreSQL 12 and later)\n */\nbool\nwrite_standby_signal(const char *data_dir)\n{\n\tchar\t    standby_signal_file_path[MAXPGPATH] = \"\";\n\tFILE\t   *file;\n\tmode_t\t\tum;\n\n\tAssert(data_dir != NULL);\n\n\tmake_standby_signal_path(data_dir, standby_signal_file_path);\n\n\t/* Set umask to 0600 */\n\tum = umask((~(S_IRUSR | S_IWUSR)) & (S_IRWXG | S_IRWXO));\n\tfile = fopen(standby_signal_file_path, \"w\");\n\tumask(um);\n\n\tif (file == NULL)\n\t{\n\t\tlog_error(_(\"unable to create %s file at \\\"%s\\\"\"),\n\t\t\t\t  STANDBY_SIGNAL_FILE,\n\t\t\t\t  standby_signal_file_path);\n\t\tlog_detail(\"%s\", strerror(errno));\n\n\t\treturn false;\n\t}\n\n\tif (fputs(\"# created by repmgr\\n\", file) == EOF)\n\t{\n\t\tlog_error(_(\"unable to write to %s file at \\\"%s\\\"\"),\n\t\t\t\t  STANDBY_SIGNAL_FILE,\n\t\t\t\t  standby_signal_file_path);\n\t\tfclose(file);\n\n\t\treturn false;\n\t}\n\n\tfclose(file);\n\n\treturn true;\n}\n\n\n/*\n * NOTE:\n *  - the provided connection should be for the normal repmgr user\n *  - if upstream_node_record is not NULL, its \"repluser\" entry, if\n *    set, will be used as the fallback replication user\n */\nbool\ncreate_replication_slot(PGconn *conn, char *slot_name, t_node_info *upstream_node_record, PQExpBufferData *error_msg)\n{\n\tPGconn *slot_conn = NULL;\n\tbool use_replication_protocol = false;\n\tbool success = true;\n\tchar *replication_user = NULL;\n\n\t_determine_replication_slot_user(conn, upstream_node_record, &replication_user);\n\n\t/*\n\t * If called in --dry-run context, if the replication slot user is not the\n\t * repmgr user, attempt to validate the connection.\n\t */\n\tif (runtime_options.dry_run == true)\n\t{\n\t\tswitch (ReplicationSlotUser)\n\t\t{\n\t\t\tcase USER_TYPE_UNKNOWN:\n\t\t\t\tlog_error(\"unable to determine user for replication slot creation\");\n\t\t\t\treturn false;\n\t\t\tcase REPMGR_USER:\n\t\t\t\tlog_info(_(\"replication slots will be created by user \\\"%s\\\"\"),\n\t\t\t\t\t\t PQuser(conn));\n\t\t\t\treturn true;\n\n\t\t\tcase REPLICATION_USER_NODE:\n\t\t\tcase REPLICATION_USER_OPT:\n\t\t\t{\n\t\t\t\tPGconn *repl_conn = duplicate_connection(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t replication_user,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t true);\n\t\t\t\tif (repl_conn == NULL || PQstatus(repl_conn) != CONNECTION_OK)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to create replication connection as user \\\"%s\\\"\"),\n\t\t\t\t\t\t\t  replication_user);\n\t\t\t\t\tlog_detail(\"%s\", PQerrorMessage(repl_conn));\n\n\t\t\t\t\tPQfinish(repl_conn);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tlog_info(_(\"replication slots will be created by replication user \\\"%s\\\"\"),\n\t\t\t\t\t\t replication_user);\n\t\t\t\tPQfinish(repl_conn);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcase SUPERUSER:\n\t\t\t{\n\t\t\t\tPGconn *superuser_conn = duplicate_connection(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  runtime_options.superuser,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  false);\n\t\t\t\tif (superuser_conn == NULL || PQstatus(superuser_conn )!= CONNECTION_OK)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to create superuser connection as user \\\"%s\\\"\"),\n\t\t\t\t\t\t\t  runtime_options.superuser);\n\t\t\t\t\tlog_detail(\"%s\", PQerrorMessage(superuser_conn));\n\n\t\t\t\t\tPQfinish(superuser_conn);\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlog_info(_(\"replication slots will be created by superuser \\\"%s\\\"\"),\n\t\t\t\t\t\t runtime_options.superuser);\n\t\t\t\tPQfinish(superuser_conn);\n\t\t\t}\n\t\t}\n\t}\n\n\tslot_conn = _get_replication_slot_connection(conn, replication_user, &use_replication_protocol);\n\n\tif (slot_conn == NULL)\n\t\treturn false;\n\n\tif (use_replication_protocol == true)\n\t{\n\t\tsuccess = create_replication_slot_replprot(conn, slot_conn, slot_name, error_msg);\n\t}\n\telse\n\t{\n\t\tsuccess = create_replication_slot_sql(slot_conn, slot_name, error_msg);\n\t}\n\n\n\tif (slot_conn != conn)\n\t\tPQfinish(slot_conn);\n\n\treturn success;\n}\n\n\nbool\ndrop_replication_slot_if_exists(PGconn *conn, int node_id, char *slot_name)\n{\n\tt_node_info node_record = T_NODE_INFO_INITIALIZER;\n\tt_replication_slot slot_info = T_REPLICATION_SLOT_INITIALIZER;\n\tRecordStatus record_status;\n\n\tchar *replication_user = NULL;\n\tbool success = true;\n\n\tif (node_id != UNKNOWN_NODE_ID)\n\t{\n\t\trecord_status = get_node_record(conn, node_id, &node_record);\n\t}\n\n\t_determine_replication_slot_user(conn, &node_record, &replication_user);\n\n\trecord_status = get_slot_record(conn, slot_name, &slot_info);\n\n\tlog_verbose(LOG_DEBUG, \"attempting to delete slot \\\"%s\\\" on node %i\",\n\t\t\t\tslot_name, node_id);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\t/* no slot, no problem */\n\t\tlog_verbose(LOG_INFO,\n\t\t\t\t\t_(\"slot \\\"%s\\\" does not exist on node %i, nothing to remove\"),\n\t\t\t\t\tslot_name, node_id);\n\t\treturn true;\n\t}\n\n\tif (slot_info.active == true)\n\t{\n\t\t/*\n\t\t * If an active replication slot exists, bail out as we have a problem\n\t\t * we can't solve here.\n\t\t */\n\t\tlog_warning(_(\"replication slot \\\"%s\\\" is still active on node %i\"), slot_name, node_id);\n\t\tsuccess = false;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Create the appropriate connection with which to drop the slot\n\t\t */\n\n\t\tbool use_replication_protocol = false;\n\t\tPGconn *slot_conn = _get_replication_slot_connection(conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t replication_user,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t &use_replication_protocol);\n\n\t\tif (use_replication_protocol == true)\n\t\t{\n\t\t\tsuccess = drop_replication_slot_replprot(slot_conn, slot_name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsuccess = drop_replication_slot_sql(slot_conn, slot_name);\n\t\t}\n\n\t\tif (success == true)\n\t\t{\n\t\t\tlog_notice(_(\"replication slot \\\"%s\\\" deleted on node %i\"), slot_name, node_id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_error(_(\"unable to delete replication slot \\\"%s\\\" on node %i\"), slot_name, node_id);\n\t\t}\n\n\t\tif (slot_conn != conn)\n\t\t\tPQfinish(slot_conn);\n\t}\n\n\treturn success;\n}\n\n\nstatic void\n_determine_replication_slot_user(PGconn *conn, t_node_info *upstream_node_record, char **replication_user)\n{\n\t/*\n\t * If not previously done, work out which user will be responsible\n\t * for creating replication slots.\n\t */\n\tif (ReplicationSlotUser == USER_TYPE_UNKNOWN)\n\t{\n\t\t/*\n\t\t * Is the repmgr user a superuser?\n\t\t */\n\t\tif (is_superuser_connection(conn, NULL))\n\t\t{\n\t\t\tReplicationSlotUser = REPMGR_USER;\n\t\t}\n\t\t/*\n\t\t * Does the repmgr user have the REPLICATION role?\n\t\t * Note we don't care here whether the repmgr user can actually\n\t\t * make a replication connection, we're just confirming that the\n\t\t * connection we have has the appropriate permissions.\n\t\t */\n\t\telse if (is_replication_role(conn, NULL))\n\t\t{\n\t\t\tReplicationSlotUser = REPMGR_USER;\n\t\t}\n\t\t/*\n\t\t * Is a superuser provided with --superuser?\n\t\t * We'll check later whether we can make a connection as that user.\n\t\t */\n\t\telse if (runtime_options.superuser[0] != '\\0')\n\t\t{\n\t\t\tReplicationSlotUser = SUPERUSER;\n\t\t}\n\t\t/*\n\t\t * Is a replication user provided with --replication-user?\n\t\t * We'll check later whether we can make a replication connection as that user.\n\t\t * Overrides any replication user defined in the upstream node record.\n\t\t */\n\t\telse if (runtime_options.replication_user[0] != '\\0')\n\t\t{\n\t\t\tReplicationSlotUser = REPLICATION_USER_OPT;\n\t\t\t*replication_user = runtime_options.replication_user;\n\t\t}\n\t\t/*\n\t\t * Is the upstream's node record provided, and does it have a different\n\t\t * replication user?\n\t\t * We'll check later whether we can make a replication connection as that user.\n\t\t */\n\t\telse if (upstream_node_record != NULL && upstream_node_record->node_id != UNKNOWN_NODE_ID\n\t\t\t && strncmp(upstream_node_record->repluser, PQuser(conn), NAMEDATALEN) != 0)\n\t\t{\n\t\t\tReplicationSlotUser = REPLICATION_USER_NODE;\n\t\t\t*replication_user = upstream_node_record->repluser;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* This should never happen */\n\t\t\tlog_error(\"unable to determine replication slot user\");\n\t\t\tif (upstream_node_record != NULL)\n\t\t\t{\n\t\t\t\tlog_debug(\"%i %s %s\", upstream_node_record->node_id, upstream_node_record->repluser, PQuser(conn));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_debug(\"upstream_node_record not provided\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic PGconn *\n_get_replication_slot_connection(PGconn *conn, char *replication_user, bool *use_replication_protocol)\n{\n\tPGconn *slot_conn = NULL;\n\t/*\n\t * If we can't create a replication slot with the connection provided to\n\t * the function, create an connection with appropriate permissions.\n\t */\n\tswitch (ReplicationSlotUser)\n\t{\n\t\tcase USER_TYPE_UNKNOWN:\n\t\t\tlog_error(\"unable to determine user for managing replication slots\");\n\t\t\treturn NULL;\n\n\t\tcase  REPMGR_USER:\n\t\t\tslot_conn = conn;\n\t\t\tlog_verbose(LOG_INFO, _(\"managing replication slot as user \\\"%s\\\"\"),\n\t\t\t\t\t\tPQuser(conn));\n\t\t\tbreak;\n\n\t\tcase REPLICATION_USER_NODE:\n\t\tcase REPLICATION_USER_OPT:\n\t\t{\n\t\t\tslot_conn = duplicate_connection(conn,\n\t\t\t\t\t\t\t\t\t\t\t replication_user,\n\t\t\t\t\t\t\t\t\t\t\t true);\n\t\t\tif (slot_conn == NULL || PQstatus(slot_conn) != CONNECTION_OK)\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to manage replication connection as replication user \\\"%s\\\"\"),\n\t\t\t\t\t\t  runtime_options.replication_user);\n\t\t\t\tlog_detail(\"%s\", PQerrorMessage(slot_conn));\n\n\t\t\t\tPQfinish(slot_conn);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t*use_replication_protocol = true;\n\t\t\tlog_verbose(LOG_INFO, _(\"managing replication slot as replication user \\\"%s\\\"\"),\n\t\t\t\t\t\treplication_user);\n\t\t}\n\t\tbreak;\n\n\t\tcase SUPERUSER:\n\t\t{\n\t\t\tslot_conn = duplicate_connection(conn,\n\t\t\t\t\t\t\t\t\t\t\t runtime_options.superuser,\n\t\t\t\t\t\t\t\t\t\t\t false);\n\t\t\tif (slot_conn == NULL || PQstatus(slot_conn )!= CONNECTION_OK)\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to create superuser connection as user \\\"%s\\\"\"),\n\t\t\t\t\t\t  runtime_options.superuser);\n\t\t\t\tlog_detail(\"%s\", PQerrorMessage(slot_conn));\n\n\t\t\t\tPQfinish(slot_conn);\n\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlog_verbose(LOG_INFO, _(\"creating replication slot as superuser \\\"%s\\\"\"),\n\t\t\t\t\t\truntime_options.superuser);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn slot_conn;\n}\n\nbool\ncheck_replication_slots_available(int node_id, PGconn* conn)\n{\n\tint max_replication_slots = UNKNOWN_VALUE;\n\tint free_slots = get_free_replication_slot_count(conn, &max_replication_slots);\n\n\tif (free_slots < 0)\n\t{\n\t\tlog_error(_(\"unable to determine number of free replication slots on node %i\"),\n\t\t\t\t  node_id);\n\t\treturn false;\n\t}\n\n\tif (free_slots == 0)\n\t{\n\t\tlog_error(_(\"no free replication slots available on node %i\"),\n\t\t\t\t  node_id);\n\t\tlog_hint(_(\"consider increasing \\\"max_replication_slots\\\" (current value: %i)\"),\n\t\t\t\t max_replication_slots);\n\t\treturn false;\n\t}\n\telse if (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"replication slots in use, %i free slots on node %i\"),\n\t\t\t\t node_id,\n\t\t\t\t free_slots);\n\t}\n\n\treturn true;\n}\n\n\n/*\n * Check whether the specified standby has joined to its upstream.\n *\n * This is used by \"standby switchover\" and \"node rejoin\" to check\n * the success of a node rejoin operation.\n *\n * IMPORTANT: the timeout settings will be taken from the node where the check\n * is performed, which might not be the standby itself.\n */\nstandy_join_status\ncheck_standby_join(PGconn *upstream_conn, t_node_info *upstream_node_record, t_node_info *standby_node_record)\n {\n\t int i;\n\t bool available = false;\n\n\t for (i = 0; i < config_file_options.standby_reconnect_timeout; i++)\n\t {\n\t\t if (is_server_available(config_file_options.conninfo))\n\t\t {\n\t\t\t log_verbose(LOG_INFO, _(\"node \\\"%s\\\" (ID: %i) is pingable\"),\n\t\t\t\t\t\t standby_node_record->node_name,\n\t\t\t\t\t\t standby_node_record->node_id);\n\t\t\t available = true;\n\t\t\t break;\n\t\t }\n\n\t\t if (i % 5 == 0)\n\t\t {\n\t\t\t log_verbose(LOG_INFO, _(\"waiting for node \\\"%s\\\" (ID: %i) to respond to pings; %i of max %i attempts (parameter \\\"node_rejoin_timeout\\\")\"),\n\t\t\t\t\t\t standby_node_record->node_name,\n\t\t\t\t\t\t standby_node_record->node_id,\n\t\t\t\t\t\t i + 1,\n\t\t\t\t\t\t config_file_options.node_rejoin_timeout);\n\t\t }\n\t\t else\n\t\t {\n\t\t\t log_debug(\"sleeping 1 second waiting for node \\\"%s\\\" (ID: %i) to respond to pings; %i of max %i attempts\",\n\t\t\t\t\t   standby_node_record->node_name,\n\t\t\t\t\t   standby_node_record->node_id,\n\t\t\t\t\t   i + 1,\n\t\t\t\t\t   config_file_options.node_rejoin_timeout);\n\t\t }\n\n\t\t sleep(1);\n\t }\n\n\t /* node did not become available */\n\t if (available == false)\n\t {\n\t\t return JOIN_FAIL_NO_PING;\n\t }\n\n\t for (; i < config_file_options.node_rejoin_timeout; i++)\n\t {\n\t\t char *node_state = NULL;\n\t\t NodeAttached node_attached = is_downstream_node_attached(upstream_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  standby_node_record->node_name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  &node_state);\n\t\t if (node_attached == NODE_ATTACHED)\n\t\t {\n\t\t\t log_verbose(LOG_INFO, _(\"node \\\"%s\\\" (ID: %i) has attached to its upstream node\"),\n\t\t\t\t\t\t standby_node_record->node_name,\n\t\t\t\t\t\t standby_node_record->node_id);\n\t\t\t return JOIN_SUCCESS;\n\t\t }\n\n\t\t if (i % 5 == 0)\n\t\t {\n\t\t\t log_info(_(\"waiting for node \\\"%s\\\" (ID: %i) to connect to new primary; %i of max %i attempts (parameter \\\"node_rejoin_timeout\\\")\"),\n\t\t\t\t\t  standby_node_record->node_name,\n\t\t\t\t\t  standby_node_record->node_id,\n\t\t\t\t\t  i + 1,\n\t\t\t\t\t  config_file_options.node_rejoin_timeout);\n\n\t\t\t if (node_attached == NODE_NOT_ATTACHED)\n\t\t\t {\n\t\t\t\t log_detail(_(\"node \\\"%s\\\" (ID: %i) is currently attached to its upstream node in state \\\"%s\\\"\"),\n\t\t\t\t\t\t\tupstream_node_record->node_name,\n\t\t\t\t\t\t\tstandby_node_record->node_id,\n\t\t\t\t\t\t\tnode_state);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\t log_detail(_(\"checking for record in node \\\"%s\\\"'s \\\"pg_stat_replication\\\" table where \\\"application_name\\\" is \\\"%s\\\"\"),\n\t\t\t\t\t\t\tupstream_node_record->node_name,\n\t\t\t\t\t\t\tstandby_node_record->node_name);\n\t\t\t }\n\t\t }\n\t\t else\n\t\t {\n\t\t\t log_debug(\"sleeping 1 second waiting for node  \\\"%s\\\" (ID: %i) to connect to new primary; %i of max %i attempts\",\n\t\t\t\t\t   standby_node_record->node_name,\n\t\t\t\t\t   standby_node_record->node_id,\n\t\t\t\t\t   i + 1,\n\t\t\t\t\t   config_file_options.node_rejoin_timeout);\n\t\t }\n\n\t\t sleep(1);\n\t }\n\n\t return JOIN_FAIL_NO_REPLICATION;\n}\n\n\n/*\n * Here we'll perform some timeline sanity checks to ensure the follow target\n * can actually be followed or rejoined.\n *\n * See also comment for check_node_can_follow() in repmgrd-physical.c .\n */\nbool\ncheck_node_can_attach(TimeLineID local_tli, XLogRecPtr local_xlogpos, PGconn *follow_target_conn, t_node_info *follow_target_node_record, bool is_rejoin)\n{\n\tuint64\t\tlocal_system_identifier = UNKNOWN_SYSTEM_IDENTIFIER;\n\tPGconn\t   *follow_target_repl_conn = NULL;\n\tt_system_identification follow_target_identification = T_SYSTEM_IDENTIFICATION_INITIALIZER;\n\tbool success = true;\n\n\tconst char *action = is_rejoin == true ? \"rejoin\" : \"follow\";\n\n\t/* check replication connection */\n\tfollow_target_repl_conn = establish_replication_connection_from_conn(follow_target_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t follow_target_node_record->repluser);\n\n\tif (PQstatus(follow_target_repl_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to establish a replication connection to the %s target node\"), action);\n\t\treturn false;\n\t}\n\telse if (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"replication connection to the %s target node was successful\"), action);\n\t}\n\n\t/* check system_identifiers match */\n\tif (identify_system(follow_target_repl_conn, &follow_target_identification) == false)\n\t{\n\t\tlog_error(_(\"unable to query the %s target node's system identification\"), action);\n\n\t\tPQfinish(follow_target_repl_conn);\n\t\treturn false;\n\t}\n\n\tlocal_system_identifier = get_system_identifier(config_file_options.data_directory);\n\n\t/*\n\t * Check for things that should never happen, but expect the unexpected anyway.\n\t */\n\n\tif (local_system_identifier == UNKNOWN_SYSTEM_IDENTIFIER)\n\t{\n\t\t/*\n\t\t * We don't return immediately here so subsequent checks can be\n\t\t * made, but indicate the node will not be able to rejoin.\n\t\t */\n\t\tsuccess = false;\n\t\tif (runtime_options.dry_run == true)\n\t\t{\n\t\t\tlog_warning(_(\"unable to retrieve system identifier from pg_control\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_error(_(\"unable to retrieve system identifier from pg_control, aborting\"));\n\t\t}\n\t}\n\telse if (follow_target_identification.system_identifier != local_system_identifier)\n\t{\n\t\t/*\n\t\t * It's never going to be possible to rejoin a node from another cluster,\n\t\t * so no need to bother with further checks.\n\t\t */\n\t\tlog_error(_(\"this node is not part of the %s target node's replication cluster\"), action);\n\t\tlog_detail(_(\"this node's system identifier is %lu, %s target node's system identifier is %lu\"),\n\t\t\t\t   local_system_identifier,\n\t\t\t\t   action,\n\t\t\t\t   follow_target_identification.system_identifier);\n\t\tPQfinish(follow_target_repl_conn);\n\t\treturn false;\n\t}\n\telse if (runtime_options.dry_run == true)\n\t{\n\t\tlog_info(_(\"local and %s target system identifiers match\"), action);\n\t\tlog_detail(_(\"system identifier is %lu\"), local_system_identifier);\n\t}\n\n\t/* check timelines */\n\n\tlog_verbose(LOG_DEBUG, \"local timeline: %i; %s target timeline: %i\",\n\t\t\t\tlocal_tli,\n\t\t\t\taction,\n\t\t\t\tfollow_target_identification.timeline);\n\n\t/*\n\t * The upstream's timeline is lower than ours - we cannot follow, and rejoin\n\t * requires PostgreSQL 9.6 and later.\n\t */\n\tif (follow_target_identification.timeline < local_tli)\n\t{\n\t\t/*\n\t\t * \"repmgr standby follow\" is impossible in this case\n\t\t */\n\t\tif (is_rejoin == false)\n\t\t{\n\t\t\tlog_error(_(\"this node's timeline is ahead of the %s target node's timeline\"), action);\n\t\t\tlog_detail(_(\"this node's timeline is %i, %s target node's timeline is %i\"),\n\t\t\t\t\t   local_tli,\n\t\t\t\t\t   action,\n\t\t\t\t\t   follow_target_identification.timeline);\n\n\t\t\tif (PQserverVersion(follow_target_conn) >= 90600)\n\t\t\t{\n\t\t\t\tlog_hint(_(\"use \\\"repmgr node rejoin --force-rewind\\\" to reattach this node\"));\n\t\t\t}\n\n\t\t\tPQfinish(follow_target_repl_conn);\n\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t * pg_rewind can only rejoin to a lower timeline from PostgreSQL 9.6\n\t\t */\n\t\tif (PQserverVersion(follow_target_conn) < 90600)\n\t\t{\n\t\t\tlog_error(_(\"this node's timeline is ahead of the %s target node's timeline\"), action);\n\t\t\tlog_detail(_(\"this node's timeline is %i, %s target node's timeline is %i\"),\n\t\t\t\t\t   local_tli,\n\t\t\t\t\t   action,\n\t\t\t\t\t   follow_target_identification.timeline);\n\n\t\t\tif (runtime_options.force_rewind_used == true)\n\t\t\t{\n\t\t\t\tlog_hint(_(\"pg_rewind can only be used to rejoin to a node with a lower timeline from PostgreSQL 9.6\"));\n\t\t\t}\n\n\t\t\tPQfinish(follow_target_repl_conn);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (runtime_options.force_rewind_used == false)\n\t\t{\n\t\t\tlog_notice(_(\"pg_rewind execution required for this node to attach to rejoin target node %i\"),\n\t\t\t\t\t   follow_target_node_record->node_id);\n\t\t\tlog_hint(_(\"provide --force-rewind\"));\n\t\t\tPQfinish(follow_target_repl_conn);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* timelines are the same - check relative positions */\n\telse if (follow_target_identification.timeline == local_tli)\n\t{\n\t\tXLogRecPtr follow_target_xlogpos = get_node_current_lsn(follow_target_conn);\n\n\t\tif (local_xlogpos == InvalidXLogRecPtr || follow_target_xlogpos == InvalidXLogRecPtr)\n\t\t{\n\t\t\tlog_error(_(\"unable to compare LSN positions\"));\n\t\t\tPQfinish(follow_target_repl_conn);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (local_xlogpos <= follow_target_xlogpos)\n\t\t{\n\t\t\tlog_info(_(\"timelines are same, this server is not ahead\"));\n\t\t\tlog_detail(_(\"local node lsn is %X/%X, %s target lsn is %X/%X\"),\n\t\t\t\t\t   format_lsn(local_xlogpos),\n\t\t\t\t\t   action,\n\t\t\t\t\t   format_lsn(follow_target_xlogpos));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Unable to follow or join to a node we're ahead of, if we're on the\n\t\t\t * same timeline. Also, pg_rewind does not detect this situation,\n\t\t\t * as there is no definitive fork point.\n\t\t\t *\n\t\t\t * Note that Pg will still happily attach to the upstream in state \"streaming\"\n\t\t\t * for a while but then detach with an endless stream of\n\t\t\t * \"record with incorrect prev-link\" errors.\n\t\t\t */\n\t\t\tlog_error(_(\"this node ahead of the %s target on the same timeline (%i)\"), action, local_tli);\n\t\t\tlog_detail(_(\"local node lsn is %X/%X, %s target lsn is %X/%X\"),\n\t\t\t\t\t   format_lsn(local_xlogpos),\n\t\t\t\t\t   action,\n\t\t\t\t\t   format_lsn(follow_target_xlogpos));\n\n\t\t\tif (is_rejoin == true)\n\t\t\t{\n\t\t\t\tlog_hint(_(\"the --force-rewind option is ineffective in this case\"));\n\t\t\t}\n\n\t\t\tsuccess = false;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * upstream has higher timeline - check where it forked off from this node's timeline\n\t\t */\n\t\tTimeLineHistoryEntry *follow_target_history = get_timeline_history(follow_target_repl_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   local_tli + 1);\n\n\t\tif (follow_target_history == NULL)\n\t\t{\n\t\t\t/* get_timeline_history() will emit relevant error messages */\n\t\t\tPQfinish(follow_target_repl_conn);\n\t\t\treturn false;\n\t\t}\n\n\t\tlog_debug(\"local tli: %i; local_xlogpos: %X/%X; follow_target_history->tli: %i; follow_target_history->end: %X/%X\",\n\t\t\t\t  local_tli,\n\t\t\t\t  format_lsn(local_xlogpos),\n\t\t\t\t  follow_target_history->tli,\n\t\t\t\t  format_lsn(follow_target_history->end));\n\n\t\t/*\n\t\t * Local node has proceeded beyond the follow target's fork, so we\n\t\t * definitely can't attach.\n\t\t *\n\t\t * This could be the case if the follow target was promoted, but does\n\t\t * not contain all changes which are being replayed to this standby.\n\t\t */\n\t\tif (local_xlogpos > follow_target_history->end)\n\t\t{\n\t\t\tif (is_rejoin == true && runtime_options.force_rewind_used == true)\n\t\t\t{\n\t\t\t\tlog_notice(_(\"pg_rewind execution required for this node to attach to rejoin target node %i\"),\n\t\t\t\t\t\t   follow_target_node_record->node_id);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_error(_(\"this node cannot attach to %s target node %i\"),\n\t\t\t\t\t\t  action,\n\t\t\t\t\t\t  follow_target_node_record->node_id);\n\t\t\t\tsuccess = false;\n\t\t\t}\n\n\t\t\tlog_detail(_(\"%s target server's timeline %i forked off current database system timeline %i before current recovery point %X/%X\"),\n\t\t\t\t\t   action,\n\t\t\t\t\t   local_tli + 1,\n\t\t\t\t\t   local_tli,\n\t\t\t\t\t   format_lsn(local_xlogpos));\n\n\t\t\tif (is_rejoin == true && runtime_options.force_rewind_used == false)\n\t\t\t{\n\t\t\t\tlog_hint(_(\"use --force-rewind to execute pg_rewind\"));\n\t\t\t}\n\t\t}\n\n\t\tif (success == true)\n\t\t{\n\t\t\tif (is_rejoin == false || (is_rejoin == true && runtime_options.force_rewind_used == false))\n\t\t\t{\n\t\t\t\tlog_info(_(\"local node %i can attach to %s target node %i\"),\n\t\t\t\t\t\t config_file_options.node_id,\n\t\t\t\t\t\t action,\n\t\t\t\t\t\t follow_target_node_record->node_id);\n\n\t\t\t\tlog_detail(_(\"local node's recovery point: %X/%X; %s target node's fork point: %X/%X\"),\n\t\t\t\t\t\t   format_lsn(local_xlogpos),\n\t\t\t\t\t\t   action,\n\t\t\t\t\t\t   format_lsn(follow_target_history->end));\n\t\t\t}\n\t\t}\n\n\t\tpfree(follow_target_history);\n\t}\n\n\tPQfinish(follow_target_repl_conn);\n\n\treturn success;\n}\n\n\n/*\n * Check that the replication configuration file is owned by the user who\n * owns the data directory.\n */\nextern bool\ncheck_replication_config_owner(int pg_version, const char *data_directory, PQExpBufferData *error_msg, PQExpBufferData *detail_msg)\n{\n\tPQExpBufferData replication_config_file;\n\tstruct stat     dirstat;\n\tstruct stat     confstat;\n\n\tif (stat(data_directory, &dirstat))\n\t{\n\t\tif (error_msg != NULL)\n\t\t{\n\t\t\tappendPQExpBuffer(error_msg,\n\t\t\t\t\t\t\t  \"unable to check ownership of data directory \\\"%s\\\"\",\n\t\t\t\t\t\t\t  data_directory);\n\t\t\tappendPQExpBufferStr(detail_msg,\n\t\t\t\t\t\t\t\t strerror(errno));\n\t\t}\n\t\treturn false;\n\t}\n\n\tinitPQExpBuffer(&replication_config_file);\n\n\tappendPQExpBuffer(&replication_config_file,\n\t\t\t\t\t  \"%s/%s\",\n\t\t\t\t\t  config_file_options.data_directory,\n\t\t\t\t\t  pg_version >= 120000 ? PG_AUTOCONF_FILENAME : RECOVERY_COMMAND_FILE);\n\n\tstat(replication_config_file.data, &confstat);\n\n\tif (confstat.st_uid == dirstat.st_uid)\n\t{\n\t\ttermPQExpBuffer(&replication_config_file);\n\t\treturn true;\n\t}\n\n\tif (error_msg != NULL)\n\t{\n\t\tchar conf_owner[MAXLEN];\n\t\tchar dir_owner[MAXLEN];\n\t\tstruct passwd *pw;\n\n\t\tpw = getpwuid(confstat.st_uid);\n\t\tif (!pw)\n\t\t{\n\t\t\tmaxlen_snprintf(conf_owner,\n\t\t\t\t\t\t\t\"(unknown user %i)\",\n\t\t\t\t\t\t\tconfstat.st_uid);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrncpy(conf_owner, pw->pw_name, MAXLEN);\n\t\t}\n\n\t\tpw = getpwuid(dirstat.st_uid);\n\n\t\tif (!pw)\n\t\t{\n\t\t\tmaxlen_snprintf(conf_owner,\n\t\t\t\t\t\t\t\"(unknown user %i)\",\n\t\t\t\t\t\t\tdirstat.st_uid);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrncpy(dir_owner, pw->pw_name, MAXLEN);\n\t\t}\n\n\t\tappendPQExpBuffer(error_msg,\n\t\t\t\t\t\t  \"ownership error for file \\\"%s\\\"\",\n\t\t\t\t\t\t  replication_config_file.data);\n\t\tappendPQExpBuffer(detail_msg,\n\t\t\t\t\t\t  \"file owner is \\\"%s\\\", data directory owner is \\\"%s\\\"\",\n\t\t\t\t\t\t  conf_owner,\n\t\t\t\t\t\t  dir_owner);\n\t}\n\n\ttermPQExpBuffer(&replication_config_file);\n\n\treturn false;\n}\n\n\n/*\n * Simple check to see if \"shared_preload_libraries\" includes \"repmgr\".\n * Parsing \"shared_preload_libraries\" is non-trivial, as it's potentially\n * a comma-separated list, and worse may not be readable by the repmgr\n * user.\n *\n * Instead, we check if a function which should return a value returns\n * NULL; this indicates the shared library is not installed.\n */\nvoid\ncheck_shared_library(PGconn *conn)\n{\n\tbool ok = repmgrd_check_local_node_id(conn);\n\n\tif (ok == true)\n\t\treturn;\n\n\tlog_error(_(\"repmgrd not configured for this node\"));\n\tlog_hint(_(\"ensure \\\"shared_preload_libraries\\\" includes \\\"repmgr\\\" and restart PostgreSQL\"));\n\tPQfinish(conn);\n\texit(ERR_BAD_CONFIG);\n}\n\n\nbool\nis_repmgrd_running(PGconn *conn)\n{\n\tpid_t\t\tpid;\n\tbool\t\tis_running = false;\n\n\tpid = repmgrd_get_pid(conn);\n\n\tif (pid != UNKNOWN_PID)\n\t{\n\t\tif (kill(pid, 0) != -1)\n\t\t{\n\t\t\tis_running = true;\n\t\t}\n\t}\n\n\treturn is_running;\n}\n\n\n/**\n * Parse the string returned by \"repmgr --version\", e.g. \"repmgr 4.1.2\",\n * and return it as a version integer (e.g. 40102).\n *\n * This is required for backwards compatibility as versions prior to\n * 4.3 do not have the --version-number option.\n */\nint\nparse_repmgr_version(const char *version_string)\n{\n\tint series, major, minor;\n\tint version_integer = UNKNOWN_REPMGR_VERSION_NUM;\n\tPQExpBufferData sscanf_string;\n\n\tinitPQExpBuffer(&sscanf_string);\n\n\tappendPQExpBuffer(&sscanf_string, \"%s \",\n\t\t\t\t\t  progname());\n\tappendPQExpBufferStr(&sscanf_string, \"%i.%i.%i\");\n\n\tif (sscanf(version_string, sscanf_string.data, &series, &major, &minor) == 3)\n\t{\n\t\tversion_integer = (series * 10000) + (major * 100) + minor;\n\t}\n\telse\n\t{\n\t\tresetPQExpBuffer(&sscanf_string);\n\t\tappendPQExpBuffer(&sscanf_string, \"%s \",\n\t\t\t\t\t\t  progname());\n\t\tappendPQExpBufferStr(&sscanf_string, \"%i.%i\");\n\n\t\tif (sscanf(version_string, \"repmgr %i.%i\", &series, &major) == 2)\n\t\t{\n\t\t\tversion_integer = (series * 10000) + (major * 100);\n\t\t}\n\t}\n\n\treturn version_integer;\n}\n"
        },
        {
          "name": "repmgr-client.h",
          "type": "blob",
          "size": 8.6103515625,
          "content": "/*\n * repmgr-client.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _REPMGR_CLIENT_H_\n#define _REPMGR_CLIENT_H_\n\n#include <getopt_long.h>\n#include \"log.h\"\n\n\n#define NO_ACTION\t\t\t   0\t/* Dummy default action */\n#define PRIMARY_REGISTER\t   1\n#define PRIMARY_UNREGISTER\t   2\n#define STANDBY_REGISTER\t   3\n#define STANDBY_UNREGISTER\t   4\n#define STANDBY_CLONE\t\t   5\n#define STANDBY_PROMOTE\t\t   6\n#define STANDBY_FOLLOW\t\t   7\n#define STANDBY_SWITCHOVER\t   8\n#define WITNESS_REGISTER       9\n#define WITNESS_UNREGISTER     10\n#define NODE_STATUS\t\t\t   11\n#define NODE_CHECK\t\t\t   12\n#define NODE_SERVICE\t\t   13\n#define NODE_REJOIN            14\n#define NODE_CONTROL           15\n#define CLUSTER_SHOW\t\t   16\n#define CLUSTER_CLEANUP\t\t   17\n#define CLUSTER_MATRIX\t\t   18\n#define CLUSTER_CROSSCHECK\t   19\n#define CLUSTER_EVENT\t\t   20\n#define SERVICE_STATUS\t\t   21\n#define SERVICE_PAUSE\t\t   22\n#define SERVICE_UNPAUSE\t\t   23\n#define DAEMON_START \t\t   24\n#define DAEMON_STOP \t\t   25\n\n/* command line options without short versions */\n#define OPT_HELP\t\t\t\t\t\t   1001\n#define OPT_COPY_EXTERNAL_CONFIG_FILES\t   1002\n#define OPT_CSV\t\t\t\t\t\t\t   1003\n#define OPT_NODE_ID\t\t\t\t\t\t   1004\n#define OPT_NODE_NAME\t\t\t\t\t   1005\n#define OPT_WITHOUT_BARMAN\t\t\t\t   1006\n#define OPT_NO_UPSTREAM_CONNECTION\t\t   1007\n#define OPT_WAIT_SYNC\t\t\t\t\t   1008\n#define OPT_LOG_TO_FILE\t\t\t\t\t   1009\n#define OPT_UPSTREAM_CONNINFO\t\t\t   1010\n#define OPT_REPLICATION_USER\t\t\t   1011\n#define OPT_EVENT\t\t\t\t\t\t   1012\n#define OPT_LIMIT\t\t\t\t\t\t   1013\n#define OPT_ALL\t\t\t\t\t\t\t   1014\n#define OPT_DRY_RUN\t\t\t\t\t\t   1015\n#define OPT_UPSTREAM_NODE_ID\t\t\t   1016\n#define OPT_ACTION\t\t\t\t\t\t   1017\n#define OPT_LIST_ACTIONS\t\t\t\t   1018\n#define OPT_CHECKPOINT\t\t\t\t\t   1019\n#define OPT_IS_SHUTDOWN_CLEANLY\t\t\t   1020\n#define OPT_ALWAYS_PROMOTE\t\t\t\t   1021\n#define OPT_FORCE_REWIND\t\t\t\t   1022\n#define OPT_NAGIOS\t\t\t\t\t\t   1023\n#define OPT_ARCHIVE_READY\t\t\t\t   1024\n#define OPT_OPTFORMAT\t\t\t\t\t   1025\n#define OPT_REPLICATION_LAG\t\t\t\t   1026\n#define OPT_CONFIG_FILES\t\t\t\t   1027\n#define OPT_SIBLINGS_FOLLOW\t\t\t\t   1028\n#define OPT_ROLE\t\t\t\t\t\t   1029\n#define OPT_DOWNSTREAM\t\t\t\t\t   1030\n#define OPT_UPSTREAM\t\t\t\t\t   1031\n#define OPT_SLOTS\t\t\t\t\t\t   1032\n#define OPT_HAS_PASSFILE\t\t\t\t   1033\n#define OPT_WAIT_START\t\t\t\t\t   1034\n#define OPT_REPL_CONN\t\t\t\t\t   1035\n#define OPT_REMOTE_NODE_ID\t\t\t\t   1036\n#define OPT_REPLICATION_CONF_ONLY\t\t   1037\n#define OPT_NO_WAIT\t\t\t\t\t\t   1038\n#define OPT_MISSING_SLOTS\t\t\t\t   1039\n#define OPT_REPMGRD_NO_PAUSE\t\t\t   1040\n#define OPT_VERSION_NUMBER\t\t\t\t   1041\n#define OPT_DATA_DIRECTORY_CONFIG\t\t   1042\n#define OPT_COMPACT\t\t\t\t\t\t   1043\n#define OPT_DETAIL\t\t\t\t\t\t   1044\n#define OPT_REPMGRD_FORCE_UNPAUSE\t\t   1045\n#define OPT_REPLICATION_CONFIG_OWNER\t   1046\n#define OPT_DB_CONNECTION\t\t\t\t   1047\n#define OPT_VERIFY_BACKUP\t\t\t\t   1048\n#define OPT_RECOVERY_MIN_APPLY_DELAY       1049\n#define OPT_REPMGRD\t\t\t\t\t\t   1050\n\n/* These options are for internal use only */\n#define OPT_CONFIG_ARCHIVE_DIR\t\t\t   2001\n#define OPT_DISABLE_WAL_RECEIVER\t\t   2002\n#define OPT_ENABLE_WAL_RECEIVER\t\t\t   2003\n#define OPT_DUMP_CONFIG\t\t\t\t\t   2004\n\n/* deprecated since 4.0 */\n#define OPT_CHECK_UPSTREAM_CONFIG\t\t    999\n\n\nstatic struct option long_options[] =\n{\n/* general options */\n\t{\"help\", no_argument, NULL, OPT_HELP},\n\t{\"version\", no_argument, NULL, 'V'},\n\t{\"version-number\", no_argument, NULL, OPT_VERSION_NUMBER},\n\n/* general configuration options */\n\t{\"config-file\", required_argument, NULL, 'f'},\n\t{\"dry-run\", no_argument, NULL, OPT_DRY_RUN},\n\t{\"force\", no_argument, NULL, 'F'},\n\t{\"pg_bindir\", required_argument, NULL, 'b'},\n\t{\"wait\", optional_argument, NULL, 'w'},\n\t{\"no-wait\", no_argument, NULL, 'W'},\n\t{\"compact\", no_argument, NULL, OPT_COMPACT},\n\t{\"detail\", no_argument, NULL, OPT_DETAIL},\n\t{\"dump-config\", no_argument, NULL, OPT_DUMP_CONFIG},\n\n/* connection options */\n\t{\"dbname\", required_argument, NULL, 'd'},\n\t{\"host\", required_argument, NULL, 'h'},\n\t{\"port\", required_argument, NULL, 'p'},\n\t{\"remote-user\", required_argument, NULL, 'R'},\n\t{\"superuser\", required_argument, NULL, 'S'},\n\t{\"username\", required_argument, NULL, 'U'},\n\n/* general node options */\n\t{\"pgdata\", required_argument, NULL, 'D'},\n\t{\"node-id\", required_argument, NULL, OPT_NODE_ID},\n\t{\"node-name\", required_argument, NULL, OPT_NODE_NAME},\n\t{\"remote-node-id\", required_argument, NULL, OPT_REMOTE_NODE_ID},\n\n/* logging options */\n\t{\"log-level\", required_argument, NULL, 'L'},\n\t{\"log-to-file\", no_argument, NULL, OPT_LOG_TO_FILE},\n\t{\"quiet\",  no_argument, NULL, 'q'},\n\t{\"terse\", no_argument, NULL, 't'},\n\t{\"verbose\", no_argument, NULL, 'v'},\n\n/* output options */\n\t{\"csv\", no_argument, NULL, OPT_CSV},\n\t{\"nagios\", no_argument, NULL, OPT_NAGIOS},\n\t{\"optformat\", no_argument, NULL, OPT_OPTFORMAT},\n\n/* \"standby clone\" options */\n\t{\"copy-external-config-files\", optional_argument, NULL, OPT_COPY_EXTERNAL_CONFIG_FILES},\n\t{\"fast-checkpoint\", no_argument, NULL, 'c'},\n\t{\"no-upstream-connection\", no_argument, NULL, OPT_NO_UPSTREAM_CONNECTION},\n\t{\"replication-user\", required_argument, NULL, OPT_REPLICATION_USER},\n\t{\"upstream-conninfo\", required_argument, NULL, OPT_UPSTREAM_CONNINFO},\n\t{\"upstream-node-id\", required_argument, NULL, OPT_UPSTREAM_NODE_ID},\n\t{\"without-barman\", no_argument, NULL, OPT_WITHOUT_BARMAN},\n\t{\"replication-conf-only\", no_argument, NULL, OPT_REPLICATION_CONF_ONLY},\n\t{\"verify-backup\", no_argument, NULL, OPT_VERIFY_BACKUP },\n\t{\"recovery-min-apply-delay\", required_argument, NULL, OPT_RECOVERY_MIN_APPLY_DELAY },\n\t/* deprecate this once Pg11 and earlier are unsupported */\n\t{\"recovery-conf-only\", no_argument, NULL, OPT_REPLICATION_CONF_ONLY},\n\n/* \"standby register\" options */\n\t{\"wait-start\", required_argument, NULL, OPT_WAIT_START},\n\t{\"wait-sync\", optional_argument, NULL, OPT_WAIT_SYNC},\n\n/* \"standby switchover\" options\n *\n * Note: --force-rewind accepted to pass to \"node rejoin\"\n */\n\t{\"always-promote\", no_argument, NULL, OPT_ALWAYS_PROMOTE},\n\t{\"siblings-follow\", no_argument, NULL, OPT_SIBLINGS_FOLLOW},\n\t{\"repmgrd-no-pause\", no_argument, NULL, OPT_REPMGRD_NO_PAUSE},\n\t{\"repmgrd-force-unpause\", no_argument, NULL, OPT_REPMGRD_FORCE_UNPAUSE},\n\n/* \"node status\" options */\n\t{\"is-shutdown-cleanly\", no_argument, NULL, OPT_IS_SHUTDOWN_CLEANLY},\n\n/* \"node check\" options */\n\t{\"archive-ready\", no_argument, NULL, OPT_ARCHIVE_READY},\n\t{\"downstream\", no_argument, NULL, OPT_DOWNSTREAM},\n\t{\"upstream\", no_argument, NULL, OPT_UPSTREAM},\n\t{\"replication-lag\", no_argument, NULL, OPT_REPLICATION_LAG},\n\t{\"role\", no_argument, NULL, OPT_ROLE},\n\t{\"slots\", no_argument, NULL, OPT_SLOTS},\n\t{\"missing-slots\", no_argument, NULL, OPT_MISSING_SLOTS},\n\t{\"repmgrd\", no_argument, NULL, OPT_REPMGRD},\n\t{\"has-passfile\", no_argument, NULL, OPT_HAS_PASSFILE},\n\t{\"replication-connection\", no_argument, NULL, OPT_REPL_CONN},\n\t{\"data-directory-config\", no_argument, NULL, OPT_DATA_DIRECTORY_CONFIG},\n\t{\"replication-config-owner\", no_argument, NULL, OPT_REPLICATION_CONFIG_OWNER},\n\t{\"db-connection\", no_argument, NULL, OPT_DB_CONNECTION},\n\n/* \"node rejoin\" options */\n\t{\"config-files\", required_argument, NULL, OPT_CONFIG_FILES},\n    {\"config-archive-dir\", required_argument, NULL, OPT_CONFIG_ARCHIVE_DIR},\n\t{\"force-rewind\", optional_argument, NULL, OPT_FORCE_REWIND},\n\n/* \"node service\" options */\n\t{\"action\", required_argument, NULL, OPT_ACTION},\n\t{\"list-actions\", no_argument, NULL, OPT_LIST_ACTIONS},\n\t{\"checkpoint\", no_argument, NULL, OPT_CHECKPOINT},\n\n/* \"cluster event\" options */\n\t{\"all\", no_argument, NULL, OPT_ALL},\n\t{\"event\", required_argument, NULL, OPT_EVENT},\n\t{\"limit\", required_argument, NULL, OPT_LIMIT},\n\n/* \"cluster cleanup\" options */\n\t{\"keep-history\", required_argument, NULL, 'k'},\n\n/* undocumented options for testing */\n\t{\"disable-wal-receiver\", no_argument, NULL, OPT_DISABLE_WAL_RECEIVER},\n\t{\"enable-wal-receiver\", no_argument, NULL, OPT_ENABLE_WAL_RECEIVER},\n\n/* deprecated */\n\t{\"check-upstream-config\", no_argument, NULL, OPT_CHECK_UPSTREAM_CONFIG},\n\t/* previously used by \"standby switchover\" */\n\t{\"remote-config-file\", required_argument, NULL, 'C'},\n\t{NULL, 0, NULL, 0}\n};\n\n\nstatic void do_help(void);\n\nstatic const char *action_name(const int action);\n\nstatic void check_cli_parameters(const int action);\n\n#endif\t\t\t\t\t\t\t/* _REPMGR_CLIENT_H_ */\n"
        },
        {
          "name": "repmgr.c",
          "type": "blob",
          "size": 15.6142578125,
          "content": "/*\n * repmgr.c - repmgr extension\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This is the actual extension code; see repmgr-client.c for the code which\n * generates the repmgr binary\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\n#include \"postgres.h\"\n#include \"fmgr.h\"\n#include \"access/xlog.h\"\n#include \"miscadmin.h\"\n#include \"replication/walreceiver.h\"\n#include \"storage/fd.h\"\n#include \"storage/ipc.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/procarray.h\"\n#include \"storage/shmem.h\"\n#include \"storage/spin.h\"\n#include \"utils/builtins.h\"\n#include \"utils/pg_lsn.h\"\n\n#include \"utils/timestamp.h\"\n\n#include \"lib/stringinfo.h\"\n#include \"access/xact.h\"\n#include \"utils/snapmgr.h\"\n#include \"pgstat.h\"\n\n#include \"voting.h\"\n\n#define UNKNOWN_NODE_ID\t\t-1\n#define ELECTION_RERUN_NOTIFICATION -2\n#define UNKNOWN_PID\t\t\t-1\n\n#define TRANCHE_NAME \"repmgrd\"\n#define REPMGRD_STATE_FILE PGSTAT_STAT_PERMANENT_DIRECTORY \"/repmgrd_state.txt\"\n#define REPMGRD_STATE_FILE_BUF_SIZE 128\n\nPG_MODULE_MAGIC;\n\ntypedef enum\n{\n\tLEADER_NODE,\n\tFOLLOWER_NODE,\n\tCANDIDATE_NODE\n} NodeState;\n\ntypedef struct repmgrdSharedState\n{\n\tLWLockId\tlock;\t\t\t/* protects search/modification */\n\tTimestampTz last_updated;\n\tint\t\t\tlocal_node_id;\n\tint\t\t\trepmgrd_pid;\n\tchar\t\trepmgrd_pidfile[MAXPGPATH];\n\tbool\t\trepmgrd_paused;\n\t/* streaming failover */\n\tint\t\t\tupstream_node_id;\n\tTimestampTz upstream_last_seen;\n\tNodeVotingStatus voting_status;\n\tint\t\t\tcurrent_electoral_term;\n\tint\t\t\tcandidate_node_id;\n\tbool\t\tfollow_new_primary;\n} repmgrdSharedState;\n\nstatic repmgrdSharedState *shared_state = NULL;\n\n#if (PG_VERSION_NUM >= 150000)\nstatic shmem_request_hook_type prev_shmem_request_hook = NULL;\n#endif\nstatic shmem_startup_hook_type prev_shmem_startup_hook = NULL;\n\nvoid\t\t_PG_init(void);\n\n#if (PG_VERSION_NUM >= 150000)\nstatic void repmgr_shmem_request(void);\n#endif\nstatic void repmgr_shmem_startup(void);\n\nPG_FUNCTION_INFO_V1(repmgr_set_local_node_id);\nPG_FUNCTION_INFO_V1(repmgr_get_local_node_id);\nPG_FUNCTION_INFO_V1(repmgr_standby_set_last_updated);\nPG_FUNCTION_INFO_V1(repmgr_standby_get_last_updated);\nPG_FUNCTION_INFO_V1(repmgr_set_upstream_last_seen);\nPG_FUNCTION_INFO_V1(repmgr_get_upstream_last_seen);\nPG_FUNCTION_INFO_V1(repmgr_get_upstream_node_id);\nPG_FUNCTION_INFO_V1(repmgr_set_upstream_node_id);\nPG_FUNCTION_INFO_V1(repmgr_notify_follow_primary);\nPG_FUNCTION_INFO_V1(repmgr_get_new_primary);\nPG_FUNCTION_INFO_V1(repmgr_reset_voting_status);\nPG_FUNCTION_INFO_V1(set_repmgrd_pid);\nPG_FUNCTION_INFO_V1(get_repmgrd_pid);\nPG_FUNCTION_INFO_V1(get_repmgrd_pidfile);\nPG_FUNCTION_INFO_V1(repmgrd_is_running);\nPG_FUNCTION_INFO_V1(repmgrd_pause);\nPG_FUNCTION_INFO_V1(repmgrd_is_paused);\nPG_FUNCTION_INFO_V1(repmgr_get_wal_receiver_pid);\n\n\n/*\n * Module load callback\n */\nvoid\n_PG_init(void)\n{\n\tif (!process_shared_preload_libraries_in_progress)\n\t\treturn;\n\n#if (PG_VERSION_NUM < 150000)\n\tRequestAddinShmemSpace(MAXALIGN(sizeof(repmgrdSharedState)));\n\n#if (PG_VERSION_NUM >= 90600)\n\tRequestNamedLWLockTranche(TRANCHE_NAME, 1);\n#else\n\tRequestAddinLWLocks(1);\n#endif\n#endif\n\n\t/*\n\t * Install hooks.\n\t */\n#if (PG_VERSION_NUM >= 150000)\n\tprev_shmem_request_hook = shmem_request_hook;\n\tshmem_request_hook = repmgr_shmem_request;\n#endif\n\n\tprev_shmem_startup_hook = shmem_startup_hook;\n\tshmem_startup_hook = repmgr_shmem_startup;\n\n}\n\n#if (PG_VERSION_NUM >= 150000)\n/*\n * shmem_requst_hook: request shared memory\n */\nstatic void\nrepmgr_shmem_request(void)\n{\n\tif (prev_shmem_request_hook)\n\t\tprev_shmem_request_hook();\n\n\tRequestAddinShmemSpace(MAXALIGN(sizeof(repmgrdSharedState)));\n\n\tRequestNamedLWLockTranche(TRANCHE_NAME, 1);\n}\n#endif\n\n/*\n * shmem_startup hook: allocate or attach to shared memory\n */\nstatic void\nrepmgr_shmem_startup(void)\n{\n\tbool\t\tfound;\n\n\tif (prev_shmem_startup_hook)\n\t\tprev_shmem_startup_hook();\n\n\t/* reset in case this is a restart within the postmaster */\n\tshared_state = NULL;\n\n\t/*\n\t * Create or attach to the shared memory state\n\t */\n\tLWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);\n\n\tshared_state = ShmemInitStruct(\"repmgrd shared state\",\n\t\t\t\t\t\t\t\t   sizeof(repmgrdSharedState),\n\t\t\t\t\t\t\t\t   &found);\n\n\tif (!found)\n\t{\n\t\t/* Initialise shared memory struct */\n#if (PG_VERSION_NUM >= 90600)\n\t\tshared_state->lock = &(GetNamedLWLockTranche(TRANCHE_NAME))->lock;\n#else\n\t\tshared_state->lock = LWLockAssign();\n#endif\n\n\t\tshared_state->local_node_id = UNKNOWN_NODE_ID;\n\t\tshared_state->repmgrd_pid = UNKNOWN_PID;\n\t\tmemset(shared_state->repmgrd_pidfile, 0, MAXPGPATH);\n\t\tshared_state->repmgrd_paused = false;\n\t\tshared_state->current_electoral_term = 0;\n\t\tshared_state->upstream_node_id = UNKNOWN_NODE_ID;\n\t\t/* arbitrary \"magic\" date to indicate this field hasn't been updated */\n\t\tshared_state->upstream_last_seen = POSTGRES_EPOCH_JDATE;\n\t\tshared_state->voting_status = VS_NO_VOTE;\n\t\tshared_state->candidate_node_id = UNKNOWN_NODE_ID;\n\t\tshared_state->follow_new_primary = false;\n\t}\n\n\tLWLockRelease(AddinShmemInitLock);\n}\n\n\n/* ==================== */\n/* monitoring functions */\n/* ==================== */\n\nDatum\nrepmgr_set_local_node_id(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tlocal_node_id = UNKNOWN_NODE_ID;\n\tint\t\t\tstored_node_id = UNKNOWN_NODE_ID;\n\tint\t\t\tpaused = -1;\n\n\tif (!shared_state)\n\t\tPG_RETURN_NULL();\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tlocal_node_id = PG_GETARG_INT32(0);\n\n\t/* read state file and if exists/valid, update \"repmgrd_paused\" */\n\t{\n\t\tFILE\t   *file = NULL;\n\n\t\tfile = AllocateFile(REPMGRD_STATE_FILE, PG_BINARY_R);\n\n\t\tif (file != NULL)\n\t\t{\n\t\t\tint\t\t\tbuffer_size = REPMGRD_STATE_FILE_BUF_SIZE;\n\t\t\tchar\t\tbuffer[REPMGRD_STATE_FILE_BUF_SIZE];\n\n\t\t\tif (fgets(buffer, buffer_size, file) != NULL)\n\t\t\t{\n\t\t\t\tif (sscanf(buffer, \"%i:%i\", &stored_node_id, &paused) != 2)\n\t\t\t\t{\n\t\t\t\t\telog(WARNING, \"unable to parse repmgrd state file\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\telog(DEBUG1, \"node_id: %i; paused: %i\", stored_node_id, paused);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tFreeFile(file);\n\t\t}\n\n\t}\n\n\tLWLockAcquire(shared_state->lock, LW_EXCLUSIVE);\n\n\t/* only set local_node_id once, as it should never change */\n\tif (shared_state->local_node_id == UNKNOWN_NODE_ID)\n\t{\n\t\tshared_state->local_node_id = local_node_id;\n\t}\n\n\t/* only update if state file valid */\n\tif (stored_node_id == shared_state->local_node_id)\n\t{\n\t\tif (paused == 0)\n\t\t{\n\t\t\tshared_state->repmgrd_paused = false;\n\t\t}\n\t\telse if (paused == 1)\n\t\t{\n\t\t\tshared_state->repmgrd_paused = true;\n\t\t}\n\t}\n\n\tLWLockRelease(shared_state->lock);\n\n\tPG_RETURN_VOID();\n}\n\n\nDatum\nrepmgr_get_local_node_id(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tlocal_node_id = UNKNOWN_NODE_ID;\n\n\tif (!shared_state)\n\t\tPG_RETURN_NULL();\n\n\tLWLockAcquire(shared_state->lock, LW_SHARED);\n\tlocal_node_id = shared_state->local_node_id;\n\tLWLockRelease(shared_state->lock);\n\n\tPG_RETURN_INT32(local_node_id);\n}\n\n\n/* update and return last updated with current timestamp */\nDatum\nrepmgr_standby_set_last_updated(PG_FUNCTION_ARGS)\n{\n\tTimestampTz last_updated = GetCurrentTimestamp();\n\n\tif (!shared_state)\n\t\tPG_RETURN_NULL();\n\n\tLWLockAcquire(shared_state->lock, LW_EXCLUSIVE);\n\tshared_state->last_updated = last_updated;\n\tLWLockRelease(shared_state->lock);\n\n\tPG_RETURN_TIMESTAMPTZ(last_updated);\n}\n\n\n/* get last updated timestamp */\nDatum\nrepmgr_standby_get_last_updated(PG_FUNCTION_ARGS)\n{\n\tTimestampTz last_updated;\n\n\t/* Safety check... */\n\tif (!shared_state)\n\t\tPG_RETURN_NULL();\n\n\tLWLockAcquire(shared_state->lock, LW_SHARED);\n\tlast_updated = shared_state->last_updated;\n\tLWLockRelease(shared_state->lock);\n\n\tPG_RETURN_TIMESTAMPTZ(last_updated);\n}\n\n\nDatum\nrepmgr_set_upstream_last_seen(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tupstream_node_id = UNKNOWN_NODE_ID;\n\n\tif (!shared_state)\n\t\tPG_RETURN_VOID();\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tupstream_node_id = PG_GETARG_INT32(0);\n\n\tLWLockAcquire(shared_state->lock, LW_EXCLUSIVE);\n\n\tshared_state->upstream_last_seen = GetCurrentTimestamp();\n\tshared_state->upstream_node_id = upstream_node_id;\n\tLWLockRelease(shared_state->lock);\n\n\tPG_RETURN_VOID();\n}\n\n\nDatum\nrepmgr_get_upstream_last_seen(PG_FUNCTION_ARGS)\n{\n\tlong\t\tsecs;\n\tint\t\t\tmicrosecs;\n\tTimestampTz last_seen;\n\n\tif (!shared_state)\n\t\tPG_RETURN_INT32(-1);\n\n\tLWLockAcquire(shared_state->lock, LW_SHARED);\n\n\tlast_seen = shared_state->upstream_last_seen;\n\n\tLWLockRelease(shared_state->lock);\n\n\t/*\n\t * \"last_seen\" is initialised with the PostgreSQL epoch as a\n\t * \"magic\" value to indicate the field hasn't ever been updated\n\t * by repmgrd. We return -1 instead, rather than imply that the\n\t * primary was last seen at the turn of the century.\n\t */\n\tif (last_seen == POSTGRES_EPOCH_JDATE)\n\t\tPG_RETURN_INT32(-1);\n\n\n\tTimestampDifference(last_seen, GetCurrentTimestamp(),\n\t\t\t\t\t\t&secs, &microsecs);\n\n\t/* let's hope repmgrd never runs for more than a century or so without seeing a primary */\n\tPG_RETURN_INT32((uint32)secs);\n}\n\n\nDatum\nrepmgr_get_upstream_node_id(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tupstream_node_id = UNKNOWN_NODE_ID;\n\n\tif (!shared_state)\n\t\tPG_RETURN_NULL();\n\n\tLWLockAcquire(shared_state->lock, LW_SHARED);\n\tupstream_node_id = shared_state->upstream_node_id;\n\tLWLockRelease(shared_state->lock);\n\n\tPG_RETURN_INT32(upstream_node_id);\n}\n\nDatum\nrepmgr_set_upstream_node_id(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tupstream_node_id = UNKNOWN_NODE_ID;\n\tint\t\t\tlocal_node_id = UNKNOWN_NODE_ID;\n\n\tif (!shared_state)\n\t\tPG_RETURN_NULL();\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tupstream_node_id = PG_GETARG_INT32(0);\n\n\tLWLockAcquire(shared_state->lock, LW_SHARED);\n\tlocal_node_id = shared_state->local_node_id;\n\tLWLockRelease(shared_state->lock);\n\n\tif (local_node_id == upstream_node_id)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t (errmsg(\"upstream node id cannot be the same as the local node id\"))));\n\n\tLWLockAcquire(shared_state->lock, LW_EXCLUSIVE);\n\tshared_state->upstream_node_id = upstream_node_id;\n\tLWLockRelease(shared_state->lock);\n\n\tPG_RETURN_VOID();\n}\n\n\n/* ===================*/\n/* failover functions */\n/* ===================*/\n\n\nDatum\nrepmgr_notify_follow_primary(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tprimary_node_id = UNKNOWN_NODE_ID;\n\n\tif (!shared_state)\n\t\tPG_RETURN_VOID();\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_VOID();\n\n\tprimary_node_id = PG_GETARG_INT32(0);\n\n\tLWLockAcquire(shared_state->lock, LW_SHARED);\n\n\t/* only do something if local_node_id is initialised */\n\tif (shared_state->local_node_id != UNKNOWN_NODE_ID)\n\t{\n\t\tif (primary_node_id == ELECTION_RERUN_NOTIFICATION)\n\t\t{\n\t\t\telog(INFO, \"node %i received notification to rerun promotion candidate election\",\n\t\t\t\t shared_state->local_node_id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(INFO, \"node %i received notification to follow node %i\",\n\t\t\t\t shared_state->local_node_id,\n\t\t\t\t primary_node_id);\n\t\t}\n\n\t\tLWLockRelease(shared_state->lock);\n\t\tLWLockAcquire(shared_state->lock, LW_EXCLUSIVE);\n\t\t/* Explicitly set the primary node id */\n\t\tshared_state->candidate_node_id = primary_node_id;\n\t\tshared_state->follow_new_primary = true;\n\t}\n\n\tLWLockRelease(shared_state->lock);\n\n\tPG_RETURN_VOID();\n}\n\n\nDatum\nrepmgr_get_new_primary(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tnew_primary_node_id = UNKNOWN_NODE_ID;\n\n\tif (!shared_state)\n\t\tPG_RETURN_INT32(UNKNOWN_NODE_ID);\n\n\tLWLockAcquire(shared_state->lock, LW_SHARED);\n\n\tif (shared_state->follow_new_primary == true)\n\t\tnew_primary_node_id = shared_state->candidate_node_id;\n\n\tLWLockRelease(shared_state->lock);\n\n\tif (new_primary_node_id == UNKNOWN_NODE_ID)\n\t\tPG_RETURN_INT32(UNKNOWN_NODE_ID);\n\n\tPG_RETURN_INT32(new_primary_node_id);\n}\n\n\nDatum\nrepmgr_reset_voting_status(PG_FUNCTION_ARGS)\n{\n\tif (!shared_state)\n\t\tPG_RETURN_NULL();\n\n\tLWLockAcquire(shared_state->lock, LW_SHARED);\n\n\t/* only do something if local_node_id is initialised */\n\tif (shared_state->local_node_id != UNKNOWN_NODE_ID)\n\t{\n\t\tLWLockRelease(shared_state->lock);\n\t\tLWLockAcquire(shared_state->lock, LW_EXCLUSIVE);\n\n\t\tshared_state->voting_status = VS_NO_VOTE;\n\t\tshared_state->candidate_node_id = UNKNOWN_NODE_ID;\n\t\tshared_state->follow_new_primary = false;\n\t}\n\n\tLWLockRelease(shared_state->lock);\n\n\tPG_RETURN_VOID();\n}\n\n\n/*\n * Returns the repmgrd pid; or NULL if none set; or -1 if set but repmgrd\n * process not running (TODO!)\n */\nDatum\nget_repmgrd_pid(PG_FUNCTION_ARGS)\n{\n\tint repmgrd_pid = UNKNOWN_PID;\n\n\tif (!shared_state)\n\t\tPG_RETURN_NULL();\n\n\tLWLockAcquire(shared_state->lock, LW_SHARED);\n\trepmgrd_pid = shared_state->repmgrd_pid;\n\tLWLockRelease(shared_state->lock);\n\n\tPG_RETURN_INT32(repmgrd_pid);\n}\n\n\n/*\n * Returns the repmgrd pidfile\n */\nDatum\nget_repmgrd_pidfile(PG_FUNCTION_ARGS)\n{\n\tchar repmgrd_pidfile[MAXPGPATH];\n\n\tif (!shared_state)\n\t\tPG_RETURN_NULL();\n\n\tmemset(repmgrd_pidfile, 0, MAXPGPATH);\n\n\tLWLockAcquire(shared_state->lock, LW_SHARED);\n\tstrncpy(repmgrd_pidfile, shared_state->repmgrd_pidfile, MAXPGPATH);\n\tLWLockRelease(shared_state->lock);\n\n\tif (repmgrd_pidfile[0] == '\\0')\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_TEXT_P(cstring_to_text(repmgrd_pidfile));\n}\n\nDatum\nset_repmgrd_pid(PG_FUNCTION_ARGS)\n{\n\tint repmgrd_pid = UNKNOWN_PID;\n\tchar *repmgrd_pidfile = NULL;\n\n\tif (!shared_state)\n\t\tPG_RETURN_VOID();\n\n\tif (PG_ARGISNULL(0))\n\t{\n\t\trepmgrd_pid = UNKNOWN_PID;\n\t}\n\telse\n\t{\n\t\trepmgrd_pid = PG_GETARG_INT32(0);\n\t}\n\n\telog(DEBUG3, \"set_repmgrd_pid(): provided pid is %i\", repmgrd_pid);\n\n\tif (repmgrd_pid != UNKNOWN_PID && !PG_ARGISNULL(1))\n\t{\n\t\trepmgrd_pidfile = text_to_cstring(PG_GETARG_TEXT_PP(1));\n\t\telog(INFO, \"set_repmgrd_pid(): provided pidfile is %s\", repmgrd_pidfile);\n\t}\n\n\tLWLockAcquire(shared_state->lock, LW_EXCLUSIVE);\n\n\tshared_state->repmgrd_pid = repmgrd_pid;\n\tmemset(shared_state->repmgrd_pidfile, 0, MAXPGPATH);\n\n\tif (repmgrd_pidfile != NULL)\n\t{\n\t\tstrncpy(shared_state->repmgrd_pidfile, repmgrd_pidfile, MAXPGPATH);\n\t}\n\n\tLWLockRelease(shared_state->lock);\n\tPG_RETURN_VOID();\n}\n\n\nDatum\nrepmgrd_is_running(PG_FUNCTION_ARGS)\n{\n\tint repmgrd_pid = UNKNOWN_PID;\n\tint kill_ret;\n\n\tif (!shared_state)\n\t\tPG_RETURN_NULL();\n\n\tLWLockAcquire(shared_state->lock, LW_SHARED);\n\trepmgrd_pid = shared_state->repmgrd_pid;\n\tLWLockRelease(shared_state->lock);\n\n\t/* No PID registered - assume not running */\n\tif (repmgrd_pid == UNKNOWN_PID)\n\t{\n\t\tPG_RETURN_BOOL(false);\n\t}\n\n\tkill_ret = kill(repmgrd_pid, 0);\n\n\tif (kill_ret == 0)\n\t{\n\t\tPG_RETURN_BOOL(true);\n\t}\n\n\tPG_RETURN_BOOL(false);\n}\n\n\nDatum\nrepmgrd_pause(PG_FUNCTION_ARGS)\n{\n\tbool\t\tpause;\n\tFILE\t   *file = NULL;\n\tStringInfoData buf;\n\n\tif (!shared_state)\n\t\tPG_RETURN_NULL();\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tpause = PG_GETARG_BOOL(0);\n\n\tLWLockAcquire(shared_state->lock, LW_EXCLUSIVE);\n\tshared_state->repmgrd_paused = pause;\n\tLWLockRelease(shared_state->lock);\n\n\t/* write state to file */\n\tfile = AllocateFile(REPMGRD_STATE_FILE, PG_BINARY_W);\n\n\tif (file == NULL)\n\t{\n\t\telog(WARNING, \"unable to allocate %s\", REPMGRD_STATE_FILE);\n\n\t\tPG_RETURN_VOID();\n\t}\n\n\telog(DEBUG1, \"allocated\");\n\n\tinitStringInfo(&buf);\n\n\tLWLockAcquire(shared_state->lock, LW_SHARED);\n\n\tappendStringInfo(&buf, \"%i:%i\",\n\t\t\t\t\t shared_state->local_node_id,\n\t\t\t\t\t pause ? 1 : 0);\n\tLWLockRelease(shared_state->lock);\n\n\tif (fwrite(buf.data, strlen(buf.data) + 1, 1, file) != 1)\n\t{\n\t\telog(WARNING, _(\"unable to write to file %s\"), REPMGRD_STATE_FILE);\n\t}\n\n\tpfree(buf.data);\n\n\tFreeFile(file);\n\n\tPG_RETURN_VOID();\n}\n\n\nDatum\nrepmgrd_is_paused(PG_FUNCTION_ARGS)\n{\n\tbool is_paused;\n\n\tif (!shared_state)\n\t\tPG_RETURN_NULL();\n\n\tLWLockAcquire(shared_state->lock, LW_SHARED);\n\tis_paused = shared_state->repmgrd_paused;\n\tLWLockRelease(shared_state->lock);\n\n\tPG_RETURN_BOOL(is_paused);\n}\n\n\nDatum\nrepmgr_get_wal_receiver_pid(PG_FUNCTION_ARGS)\n{\n\tint wal_receiver_pid;\n\n\tif (!shared_state)\n\t\tPG_RETURN_NULL();\n\n\twal_receiver_pid = WalRcv->pid;\n\n\tPG_RETURN_INT32(wal_receiver_pid);\n}\n"
        },
        {
          "name": "repmgr.conf.sample",
          "type": "blob",
          "size": 21.0634765625,
          "content": "###################################################\n# repmgr sample configuration file\n###################################################\n\n# Some configuration items will be set with a default value; this\n# is noted for each item. Where no default value is shown, the\n# parameter will be treated as empty or false.\n#\n# repmgr parses its configuration file in the same way as PostgreSQL itself\n# does. In particular, strings must be enclosed in single quotes (although\n# simple identifiers may be provided as-is).\n#\n# For details on the configuration file format see the documentation at:\n#\n#  https://repmgr.org/docs/current/configuration-file.html#CONFIGURATION-FILE-FORMAT\n#\n# =============================================================================\n# Required configuration items\n# =============================================================================\n#\n# repmgr and repmgrd require the following items to be explicitly configured.\n\n\n#node_id=\t\t\t # A unique integer greater than zero\n#node_name=''\t\t\t # An arbitrary (but unique) string; we recommend\n\t\t\t\t # using the server's hostname or another identifier\n\t\t\t\t # unambiguously associated with the server to avoid\n\t\t\t\t # confusion. Avoid choosing names which reflect the\n\t\t\t\t # node's current role, e.g. 'primary' or 'standby1',\n\t\t\t\t # as roles can change and it will be confusing if\n\t\t\t\t # the current primary is called 'standby1'.\n\t\t\t\t # The string's maximum length is 63 characters and it should\n\t\t\t\t # contain only printable ASCII characters.\n\n#conninfo=''\t\t\t # Database connection information as a conninfo string.\n\t\t\t\t # All servers in the cluster must be able to connect to\n\t\t\t\t # the local node using this string.\n\t\t\t\t #\n\t\t\t\t # For details on conninfo strings, see:\n\t\t\t\t #  https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING\n\t\t\t\t #\n\t\t\t\t # If repmgrd is in use, consider explicitly setting\n\t\t\t\t # \"connect_timeout\" in the conninfo string to determine\n\t\t\t\t # the length of time which elapses before a network\n\t\t\t\t # connection attempt is abandoned; for details see:\n\t\t\t\t #  https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNECT-CONNECT-TIMEOUT\n\n#data_directory=''\t\t # The node's data directory. This is needed by repmgr\n\t\t\t\t # when performing operations when the PostgreSQL instance\n\t\t\t\t # is not running and there's no other way of determining\n\t\t\t\t # the data directory.\n\n\n# =============================================================================\n# Optional configuration items\n# =============================================================================\n\n\n#------------------------------------------------------------------------------\n# Server settings\n#------------------------------------------------------------------------------\n\n#config_directory=''\t\t # If configuration files are located outside the data\n\t\t\t\t # directory, specify the directory where the main\n\t\t\t\t # postgresql.conf file is located.\n\n#------------------------------------------------------------------------------\n# Replication settings\n#------------------------------------------------------------------------------\n\n#replication_user='repmgr'\t # User to make replication connections with, if not set\n\t\t\t\t # defaults to the user defined in \"conninfo\".\n\n#replication_type='physical'\t # Must \"physical\" (the default).\n\n#location='default'\t\t # An arbitrary string defining the location of the node; this\n\t\t\t\t # is used during failover to check visibility of the\n\t\t\t\t # current primary node. For further details see:\n\t\t\t\t #  https://repmgr.org/docs/current/repmgrd-network-split.html\n\n#use_replication_slots=no\t # whether to use physical replication slots\n\t\t\t\t # NOTE: when using replication slots,\n\t\t\t\t # 'max_replication_slots' should be configured for\n\t\t\t\t # at least the number of standbys which will connect\n\t\t\t\t # to the primary.\n\n#------------------------------------------------------------------------------\n# Witness server settings\n#------------------------------------------------------------------------------\n\n#witness_sync_interval=15\t # interval (in seconds) to synchronise node records\n\t\t\t\t # to the witness server\n\n#------------------------------------------------------------------------------\n# Logging settings\n#------------------------------------------------------------------------------\n#\n# Note that logging facility settings will only apply to `repmgrd` by default;\n# `repmgr` will always write to STDERR unless the switch `--log-to-file` is\n# supplied, in which case it will log to the same destination as `repmgrd`.\n# This is mainly intended for those cases when `repmgr` is executed directly\n# by `repmgrd`.\n\n#log_level='INFO'\t\t # Log level: possible values are DEBUG, INFO, NOTICE,\n\t\t\t\t # WARNING, ERROR, ALERT, CRIT or EMERG\n\n#log_facility='STDERR'\t\t # Logging facility: possible values are STDERR, or for\n\t\t\t\t # syslog integration, one of LOCAL0, LOCAL1, ..., LOCAL7, USER\n\n#log_file=''\t\t\t # STDERR can be redirected to an arbitrary file\n#log_status_interval=300\t # interval (in seconds) for repmgrd to log a status message\n\n\n#------------------------------------------------------------------------------\n# Event notification settings\n#------------------------------------------------------------------------------\n\n# event notifications can be passed to an arbitrary external program\n# together with the following parameters:\n#\n#   %n - node ID\n#   %e - event type\n#   %s - success (1 or 0)\n#   %t - timestamp\n#   %d - details\n#\n# the values provided for \"%t\" and \"%d\" will probably contain spaces,\n# so should be quoted in the provided command configuration, e.g.:\n#\n#   event_notification_command='/path/to/some/script %n %e %s \"%t\" \"%d\"'\n#\n# By default, all notifications will be passed; the notification types\n# can be filtered to explicitly named ones, e.g.:\n#\n#   event_notifications=primary_register,standby_register\n\n#event_notification_command=''\t\t# An external program or script which\n\t\t\t\t\t# can be executed by the user under which\n\t\t\t\t\t# repmgr/repmgrd are run.\n\n#event_notifications=''\t\t\t# A commas-separated list of notification\n\t\t\t\t\t# types\n\n#------------------------------------------------------------------------------\n# Environment/command settings\n#------------------------------------------------------------------------------\n\n#pg_bindir=''\t\t\t\t# Path to PostgreSQL binary directory (location\n\t\t\t\t\t# of pg_ctl, pg_basebackup etc.). Only needed\n\t\t\t\t\t# if these files are not in the system $PATH.\n\t\t\t\t\t#\n\t\t\t\t\t# Debian/Ubuntu users: you will probably need to\n\t\t\t\t\t# set this to the directory where `pg_ctl` is located,\n\t\t\t\t\t# e.g. /usr/lib/postgresql/9.6/bin/\n\t\t\t\t\t#\n\t\t\t\t\t# *NOTE* \"pg_bindir\" is only used when repmgr directly\n\t\t\t\t\t# executes PostgreSQL binaries; any user-defined scripts\n\t\t\t\t\t# *must* be specified with the full path\n\n#repmgr_bindir=''\t\t\t# Path to repmgr binary directory (location of the repmgr\n\t\t\t\t\t# binary. Only needed if the repmgr executable is not in\n\t\t\t\t\t# the system $PATH or the path defined in \"pg_bindir\".\n\n#use_primary_conninfo_password=false\t# explicitly set \"password\" in \"primary_conninfo\"\n\t\t\t\t\t# using the value contained in the environment variable\n\t\t\t\t\t# PGPASSWORD\n#passfile=''\t\t\t\t# path to .pgpass file to include in \"primary_conninfo\"\n\n#------------------------------------------------------------------------------\n# external command options\n#------------------------------------------------------------------------------\n#\n# Options which can be passed to external commands invoked by repmgr/repmgrd.\n#\n# Examples:\n#\n#   pg_ctl_options='-s'\n#   pg_basebackup_options='--label=repmgr_backup'\n#   rsync_options=--archive --checksum --compress --progress --rsh=\"ssh -o \\\"StrictHostKeyChecking no\\\"\"\n#   ssh_options=-o \"StrictHostKeyChecking no\"\n\n#pg_ctl_options=''\t\t\t# Options to append to \"pg_ctl\"\n#pg_basebackup_options=''\t\t# Options to append to \"pg_basebackup\"\n\t\t\t\t\t# (Note: when cloning from Barman, repmgr will honour any\n\t\t\t\t\t# --waldir/--xlogdir setting present in \"pg_basebackup_options\"\n#rsync_options=''\t\t\t# Options to append to \"rsync\"\nssh_options='-q -o ConnectTimeout=10'\t# Options to append to \"ssh\"\n\n\n\n#------------------------------------------------------------------------------\n# \"standby clone\" settings\n#------------------------------------------------------------------------------\n#\n# These settings apply when cloning a standby (\"repmgr standby clone\").\n#\n# Examples:\n#\n#   tablespace_mapping='/path/to/original/tablespace=/path/to/new/tablespace'\n#   restore_command = 'cp /path/to/archived/wals/%f %p'\n\n#tablespace_mapping=''\t\t\t# Tablespaces can be remapped from one\n\t\t\t\t\t# file system location to another. This\n\t\t\t\t\t# parameter can be provided multiple times.\n\n#restore_command=''\t\t\t# This will be included in the recovery configuration\n\t\t\t\t\t# generated by repmgr.\n\n#archive_cleanup_command=''\t\t# This will be included in the recovery configuration\n\t\t\t\t\t# generated by repmgr. Note we recommend using Barman for\n\t\t\t\t\t# managing WAL archives (see: https://www.pgbarman.org )\n\n#recovery_min_apply_delay=\t\t# If provided, \"recovery_min_apply_delay\" will be set to\n\t\t\t\t\t# this value (PostgreSQL 9.4 and later). Value can be\n\t\t\t\t\t# an integer representing milliseconds, or a string\n\t\t\t\t\t# representing a period of time (e.g. '5 min').\n\n\n#------------------------------------------------------------------------------\n# \"standby promote\" settings\n#------------------------------------------------------------------------------\n\n# These settings apply when instructing a standby to promote itself to the\n# new primary (\"repmgr standby promote\").\n\n#promote_check_timeout=60\t\t# The length of time (in seconds) to wait\n\t\t\t\t\t# for the new primary to finish promoting\n#promote_check_interval=1\t\t# The interval (in seconds) to check whether\n\t\t\t\t\t# the new primary has finished promoting\n\n\n#------------------------------------------------------------------------------\n# \"standby follow\" settings\n#------------------------------------------------------------------------------\n\n# These settings apply when instructing a standby to follow the new primary\n# (\"repmgr standby follow\").\n\n#primary_follow_timeout=60\t\t# The max length of time (in seconds) to wait\n\t\t\t\t\t# for the new primary to become available\n#standby_follow_timeout=30\t\t# The max length of time (in seconds) to wait\n\t\t\t\t\t# for the standby to connect to the primary\n#standby_follow_restart=false\t\t# Restart the standby instead of sending a SIGHUP\n\t\t\t\t\t# (only for PostgreSQL 13 and later)\n\n#------------------------------------------------------------------------------\n# \"standby switchover\" settings\n#------------------------------------------------------------------------------\n\n# These settings apply when switching roles between a primary and a standby\n# (\"repmgr standby switchover\").\n\n#shutdown_check_timeout=60\t\t# The max length of time (in seconds) to wait for the demotion\n\t\t\t\t\t# candidate (current primary) to shut down\n#standby_reconnect_timeout=60\t\t# The max length of time (in seconds) to wait\n\t\t\t\t\t# for the demoted standby to reconnect to the promoted\n\t\t\t\t\t# primary (note: this value should be equal to or greater\n\t\t\t\t\t# than that set for \"node_rejoin_timeout\")\n#wal_receive_check_timeout=30\t\t# The max length of time (in seconds) to wait for the walreceiver\n\t\t\t\t\t# on the standby to flush WAL to disk before comparing location\n\t\t\t\t\t# with the shut-down primary\n\n#------------------------------------------------------------------------------\n# \"node rejoin\" settings\n#------------------------------------------------------------------------------\n\n# These settings apply when reintegrating a node into a replication cluster\n# with \"repmgrd_node_rejoin\"\n\n#node_rejoin_timeout=60\t\t# The maximum length of time (in seconds) to wait for\n\t\t\t\t\t# the node to reconnect to the replication cluster\n\n#------------------------------------------------------------------------------\n# Barman options\n#------------------------------------------------------------------------------\n\n#barman_server=''\t\t\t# The barman configuration section\n#barman_host=''\t\t\t\t# The host name of the barman server\n#barman_config=''\t\t\t# The Barman configuration file on the\n\t\t\t\t\t# Barman server (needed if the file is\n\t\t\t\t\t# in a non-standard location)\n\n#------------------------------------------------------------------------------\n# Failover and monitoring settings (repmgrd)\n#------------------------------------------------------------------------------\n#\n# These settings are only applied when repmgrd is running. Values shown\n# are defaults.\n\n#failover='manual'\t\t\t# one of 'automatic', 'manual'.\n\t\t\t\t\t# determines what action to take in the event of upstream failure\n\t\t\t\t\t#\n\t\t\t\t\t# 'automatic': repmgrd will automatically attempt to promote the\n\t\t\t\t\t#    node or follow the new upstream node\n\t\t\t\t\t# 'manual': repmgrd will take no action and the node will require\n\t\t\t\t\t#    manual attention to reattach it to replication\n\n#priority=100\t\t\t\t# indicates a preferred priority for promoting nodes;\n\t\t\t\t\t# a value of zero prevents the node being promoted to primary\n\t\t\t\t\t# (default: 100)\n\n#connection_check_type='ping'\t\t# How to check availability of the upstream node; valid options:\n\t\t\t\t\t#  'ping': use PQping() to check if the node is accepting connections\n\t\t\t\t\t#  'connection': attempt to make a new connection to the node\n\t\t\t\t\t#  'query': execute an SQL statement on the node via the existing connection\n#reconnect_attempts=6\t\t\t# Number of attempts which will be made to reconnect to an unreachable\n\t\t\t\t\t# primary (or other upstream node)\n#reconnect_interval=10\t\t\t# Interval between attempts to reconnect to an unreachable\n\t\t\t\t\t# primary (or other upstream node)\n#promote_command=''\t\t\t# command repmgrd executes when promoting a new primary; use something like:\n\t\t\t\t\t#\n\t\t\t\t\t#     repmgr standby promote -f /etc/repmgr.conf\n\t\t\t\t\t#\n#follow_command=''\t\t\t# command repmgrd executes when instructing a standby to follow a new primary;\n\t\t\t\t\t# use something like:\n\t\t\t\t\t#\n\t\t\t\t\t#     repmgr standby follow -f /etc/repmgr.conf --upstream-node-id=%n\n\t\t\t\t\t#\n#primary_notification_timeout=60\t# Interval (in seconds) which repmgrd on a standby\n\t\t\t\t\t# will wait for a notification from the new primary,\n\t\t\t\t\t# before falling back to degraded monitoring\n#repmgrd_standby_startup_timeout=60\t# Interval (in seconds) which repmgrd on a standby will wait\n\t\t\t\t\t# for the the local node to restart and become ready to accept connections after\n\t\t\t\t\t# executing \"follow_command\" (defaults to the value set in \"standby_reconnect_timeout\")\n\n#monitoring_history=no\t\t\t# Whether to write monitoring data to the \"monitoring_history\" table\n#monitor_interval_secs=2\t\t# Interval (in seconds) at which to write monitoring data\n#degraded_monitoring_timeout=-1\t\t# Interval (in seconds) after which repmgrd will terminate if the\n\t\t\t\t\t# server(s) being monitored are no longer available. -1 (default)\n\t\t\t\t\t# disables the timeout completely.\n#async_query_timeout=60\t\t\t# Interval (in seconds) which repmgrd will wait before\n\t\t\t\t\t# cancelling an asynchronous query.\n#repmgrd_pid_file=\t\t\t# Path of PID file to use for repmgrd; if not set, a PID file will\n\t\t\t\t\t# be generated in a temporary directory specified by the environment\n\t\t\t\t\t# variable $TMPDIR, or if not set, in \"/tmp\". This value can be overridden\n\t\t\t\t\t# by the command line option \"-p/--pid-file\"; the command line option\n\t\t\t\t\t# \"--no-pid-file\" will force PID file creation to be skipped.\n\t\t\t\t\t# Note: there is normally no need to set this, particularly if\n\t\t\t\t\t# repmgr was installed from packages.\n#repmgrd_exit_on_inactive_node=false\t# If \"true\", and the node record is marked as \"inactive\", abort repmgrd startup\n#standby_disconnect_on_failover=false\t# If \"true\", in a failover situation wait for all standbys to\n\t\t\t\t\t# disconnect their WAL receivers before electing a new primary\n\t\t\t\t\t# Can be true in PostgreSQL 9.5 and later only. Until PostgreSQL 14 repmgr user must be a superuser to use this.\n\t\t\t\t\t# From PostgreSQL 15 repmgr must be a superuser or have 'ALTER SYSTEM wal_retrieve_retry_interval' privilege.\n\t\t\t\t\t# (see: https://repmgr.org/docs/current/repmgrd-standby-disconnection-on-failover.html )\n#sibling_nodes_disconnect_timeout=30\t# If \"standby_disconnect_on_failover\" is true, the maximum length of time\n\t\t\t\t\t# (in seconds) to wait for other standbys to confirm they have disconnected their\n\t\t\t\t\t# WAL receivers\n#primary_visibility_consensus=false\t# If \"true\", only continue with failover if no standbys have seen\n\t\t\t\t\t# the primary node recently. *Must* be the same on all nodes.\n#always_promote=false\t\t\t# Always promote a node, even if repmgr metadata is outdated\n#failover_validation_command=''\t# Script to execute for an external mechanism to validate the failover\n\t\t\t\t\t# decision made by repmgrd. Each of the following parameter placeholders\n\t\t\t\t\t# should be provided, which will be replaced by repmgrd with the appropriate value:\n\t\t\t\t\t#   %n (node_id)\n\t\t\t\t\t#   %a (node_name)\n\t\t\t\t\t#   %v (number of visible nodes)\n\t\t\t\t\t#   %u (number of shared upstream nodes)\n\t\t\t\t\t#   %t (total number of nodes)\n\t\t\t\t\t# *Must* be the same on all nodes.\n#election_rerun_interval=15\t\t# if \"failover_validation_command\" is set, and the command returns\n\t\t\t\t\t# an error, pause the specified amount of seconds before rerunning the election.\n\n# The following items are relevant for repmgrd running on the primary,\n# and will be ignored on non-primary nodes.\n# (see: https://repmgr.org/docs/current/repmgrd-primary-child-disconnection.html )\n\n#child_nodes_check_interval=5\t\t# Interval (in seconds) to check for attached child nodes (standbys)\n#child_nodes_connected_min_count=-1\t# Minimum number of child nodes which must remain connected, otherwise\n\t\t\t\t\t# disconnection command will be triggered\n#child_nodes_disconnect_min_count=-1\t# Minimum number of disconnected child nodes required to execute disconnection command\n\t\t\t\t\t# (ignored if \"child_nodes_connected_min_count\" set)\n#child_nodes_disconnect_timeout=30\t# Interval between child node disconnection and disconnection command execution\n#child_nodes_disconnect_command=''\t# Command to execute if child node disconnection detected\n#child_nodes_connected_include_witness=false\t# Whether to count the witness node (if in use) as a child node when determining whether to execute child_nodes_disconnect_command.\n\n#------------------------------------------------------------------------------\n# service control commands\n#------------------------------------------------------------------------------\n#\n# repmgr provides options to override the default pg_ctl commands\n# used to stop, start, restart, reload and promote the PostgreSQL cluster\n#\n# These options are useful when PostgreSQL has been installed from a package\n# which provides OS-level service commands. In environments using an init system\n# such as systemd, which keeps track of the state of various services, it is\n# essential that the service commands are correctly configured and pg_ctl is\n# not executed directly.\n#\n# NOTE: These commands must be runnable on remote nodes as well for switchover\n# to function correctly.\n#\n# If you use sudo, the user repmgr runs as (usually 'postgres')\t must have\n# passwordless sudo access to execute the command.\n#\n# For example, to use systemd, you can set\n#\n#    service_start_command = 'sudo systemctl start postgresql-16'\n#    (...)\n#\n# and then use the following sudoers configuration:\n#\n#    # this is required when running sudo over ssh without -t:\n#    Defaults:postgres !requiretty\n#    postgres ALL = NOPASSWD: /usr/bin/systemctl stop postgresql-16, \\\n#        /usr/bin/systemctl start postgresql-16, \\\n#        /usr/bin/systemctl restart postgresql-16\n#\n# Debian/Ubuntu users: use \"sudo pg_ctlcluster\" to execute service control commands.\n#\n# For further details, see: https://repmgr.org/docs/current/configuration-file-service-commands.html\n\n#service_start_command = ''\n#service_stop_command = ''\n#service_restart_command = ''\n#service_reload_command = ''\n#service_promote_command = ''\t\t# This parameter is intended for systems which provide a\n\t\t\t\t\t# package-level promote command, such as Debian's\n\t\t\t\t\t# \"pg_ctlcluster\". *IMPORTANT*: it is *not* a substitute\n\t\t\t\t\t# for \"promote_command\"; do not use \"repmgr standby promote\"\n\t\t\t\t\t# (or a script which executes \"repmgr standby promote\") here.\n\n# Used by \"repmgr service (start|stop)\" to control repmgrd\n#\n#repmgrd_service_start_command = ''\n#repmgrd_service_stop_command = ''\n\n#------------------------------------------------------------------------------\n# Status check thresholds\n#------------------------------------------------------------------------------\n\n# Various warning/critical thresholds used by \"repmgr node check\".\n\n#archive_ready_warning=16\t\t# repmgr node check --archive-ready\n#archive_ready_critical=128\t\t#\n\t\t\t\t\t# Numbers of files pending archiving via PostgreSQL's\n\t\t\t\t\t# \"archive_command\" configuration parameter. If\n\t\t\t\t\t# files can't be archived fast enough, or the archive\n\t\t\t\t\t# command is failing, the buildup of files can\n\t\t\t\t\t# cause various issues, such as server shutdown being\n\t\t\t\t\t# delayed until all files are archived, or excessive\n\t\t\t\t\t# space being occupied by unarchived files.\n\t\t\t\t\t#\n\t\t\t\t\t# Note that these values will be checked when executing\n\t\t\t\t\t# \"repmgr standby switchover\" to warn about potential\n\t\t\t\t\t# issues with shutting down the demotion candidate.\n\n#replication_lag_warning=300\t\t# repmgr node check --replication-lag\n#replication_lag_critical=600\t\t#\n\t\t\t\t\t# Note that these values will be checked when executing\n\t\t\t\t\t# \"repmgr standby switchover\" to warn about potential\n\t\t\t\t\t# issues with shutting down the demotion candidate.\n\n"
        },
        {
          "name": "repmgr.control",
          "type": "blob",
          "size": 0.158203125,
          "content": "# repmgr extension\ncomment = 'Replication manager for PostgreSQL'\ndefault_version = '5.5'\nmodule_pathname = '$libdir/repmgr'\nrelocatable = false\nschema = repmgr\n\n"
        },
        {
          "name": "repmgr.h",
          "type": "blob",
          "size": 5.17578125,
          "content": "/*\n * repmgr.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _REPMGR_CONFIG_H\n#define _REPMGR_CONFIG_H\n#include <config.h>\n#endif\n\n#ifdef vsnprintf\n#undef vsnprintf\n#endif\n#ifdef snprintf\n#undef snprintf\n#endif\n#ifdef vsprintf\n#undef vsprintf\n#endif\n#ifdef sprintf\n#undef sprintf\n#endif\n#ifdef vfprintf\n#undef vfprintf\n#endif\n#ifdef fprintf\n#undef fprintf\n#endif\n#ifdef vprintf\n#undef vprintf\n#endif\n#ifdef printf\n#undef printf\n#endif\n#ifdef strerror\n#undef strerror\n#endif\n#ifdef strerror_r\n#undef strerror_r\n#endif\n\n#ifndef _REPMGR_H_\n#define _REPMGR_H_\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include <libpq-fe.h>\n#include <postgres_fe.h>\n#include <pqexpbuffer.h>\n\n\n#include \"repmgr_version.h\"\n#include \"errcode.h\"\n#include \"strutil.h\"\n#include \"configfile.h\"\n#include \"dbutils.h\"\n#include \"log.h\"\n#include \"sysutils.h\"\n\n#define MIN_SUPPORTED_VERSION\t\t\"9.4\"\n#define MIN_SUPPORTED_VERSION_NUM\t90400\n\n#define UNKNOWN_SERVER_VERSION_NUM -1\n#define UNKNOWN_REPMGR_VERSION_NUM -1\n\n#define UNKNOWN_TIMELINE_ID -1\n#define UNKNOWN_SYSTEM_IDENTIFIER 0\n#define UNKNOWN_DATA_CHECKSUM_VERSION -1\n#define UNKNOWN_PID\t\t\t-1\n#define UNKNOWN_REPLICATION_LAG\t-1\n#define UNKNOWN_VALUE\t\t-1\n\n#define NODE_NOT_FOUND\t\t-1\n#define NO_UPSTREAM_NODE\t-1\n#define UNKNOWN_NODE_ID\t\t-1\n#define MIN_NODE_ID          1\n#define ELECTION_RERUN_NOTIFICATION -2\n#define VOTING_TERM_NOT_SET -1\n#define ARCHIVE_STATUS_DIR_ERROR -1\n#define NO_DEGRADED_MONITORING_ELAPSED -1\n\n#define WALRECEIVER_DISABLE_TIMEOUT_VALUE    86400000 /* milliseconds */\n\n/*\n * Default command line option parameter values\n */\n#define DEFAULT_WAIT_START                   30  /* seconds */\n\n/*\n * Default configuration file parameter values - ensure repmgr.conf.sample\n * is update if any of these are changed\n */\n\n#define DEFAULT_USE_REPLICATION_SLOTS        false\n#define DEFAULT_USE_PRIMARY_CONNINFO_PASSWORD false\n#define DEFAULT_PROMOTE_CHECK_TIMEOUT        60  /* seconds */\n#define DEFAULT_PROMOTE_CHECK_INTERVAL       1   /* seconds */\n#define DEFAULT_PRIMARY_FOLLOW_TIMEOUT       60  /* seconds */\n#define DEFAULT_STANDBY_FOLLOW_TIMEOUT       30  /* seconds */\n#define DEFAULT_STANDBY_FOLLOW_RESTART       false\n#define DEFAULT_SHUTDOWN_CHECK_TIMEOUT       60  /* seconds */\n#define DEFAULT_STANDBY_PG_BACKUPAPI_OP_TYPE \"recovery\"\n#define DEFAULT_STANDBY_RECONNECT_TIMEOUT    60  /* seconds */\n#define DEFAULT_NODE_REJOIN_TIMEOUT          60  /* seconds */\n#define DEFAULT_ARCHIVE_READY_WARNING        16  /* WAL files */\n#define DEFAULT_ARCHIVE_READY_CRITICAL       128 /* WAL files */\n#define\tDEFAULT_REPLICATION_TYPE             REPLICATION_TYPE_PHYSICAL\n#define\tDEFAULT_REPLICATION_LAG_WARNING      300 /* seconds */\n#define DEFAULT_REPLICATION_LAG_CRITICAL     600 /* seconds */\n#define DEFAULT_WITNESS_SYNC_INTERVAL        15  /* seconds */\n#define DEFAULT_WAL_RECEIVE_CHECK_TIMEOUT    30  /* seconds */\n#define DEFAULT_LOCATION                     \"default\"\n#define DEFAULT_PRIORITY                     100\n#define DEFAULT_MONITORING_INTERVAL          2\t /* seconds */\n#define DEFAULT_RECONNECTION_ATTEMPTS        6\t /* seconds */\n#define DEFAULT_RECONNECTION_INTERVAL        10  /* seconds */\n#define DEFAULT_MONITORING_HISTORY           false\n#define DEFAULT_DEGRADED_MONITORING_TIMEOUT  -1  /* seconds */\n#define DEFAULT_ASYNC_QUERY_TIMEOUT          60  /* seconds */\n#define DEFAULT_PRIMARY_NOTIFICATION_TIMEOUT 60  /* seconds */\n#define DEFAULT_REPMGRD_STANDBY_STARTUP_TIMEOUT -1 /*seconds */\n#define DEFAULT_REPMGRD_EXIT_ON_INACTIVE_NODE false,\n#define DEFAULT_STANDBY_DISCONNECT_ON_FAILOVER false\n#define DEFAULT_SIBLING_NODES_DISCONNECT_TIMEOUT 30 /* seconds */\n#define DEFAULT_CONNECTION_CHECK_TYPE        CHECK_PING\n#define DEFAULT_PRIMARY_VISIBILITY_CONSENSUS false\n#define DEFAULT_ALWAYS_PROMOTE               false\n#define DEFAULT_ELECTION_RERUN_INTERVAL      15  /* seconds */\n#define DEFAULT_CHILD_NODES_CHECK_INTERVAL   5   /* seconds */\n#define DEFAULT_CHILD_NODES_DISCONNECT_MIN_COUNT -1\n#define DEFAULT_CHILD_NODES_CONNECTED_MIN_COUNT -1\n#define DEFAULT_CHILD_NODES_CONNECTED_INCLUDE_WITNESS false\n#define DEFAULT_CHILD_NODES_DISCONNECT_TIMEOUT 30 /* seconds */\n#define DEFAULT_SSH_OPTIONS                  \"-q -o ConnectTimeout=10\"\n\n\n#ifndef RECOVERY_COMMAND_FILE\n#define RECOVERY_COMMAND_FILE \"recovery.conf\"\n#endif\n\n#ifndef STANDBY_SIGNAL_FILE\n#define STANDBY_SIGNAL_FILE \"standby.signal\"\n#define RECOVERY_SIGNAL_FILE \"recovery.signal\"\n#endif\n\n#ifndef TABLESPACE_MAP\n#define TABLESPACE_MAP \"tablespace_map\"\n#endif\n\n#define REPMGR_URL \"https://repmgr.org/\"\n\n#endif\t\t\t\t\t\t\t/* _REPMGR_H_ */\n"
        },
        {
          "name": "repmgr_version.h.in",
          "type": "blob",
          "size": 0.2470703125,
          "content": "#define REPMGR_VERSION_DATE \"2024-11-20\"\n#define REPMGR_VERSION \"5.5.0\"\n#define REPMGR_VERSION_NUM 50500\n#define REPMGR_EXTENSION_VERSION \"5.5.0\"\n#define REPMGR_EXTENSION_NUM 50500\n#define REPMGR_RELEASE_DATE \"2024-XX-XX\"\n#define PG_ACTUAL_VERSION_NUM \n"
        },
        {
          "name": "repmgrd-physical.c",
          "type": "blob",
          "size": 160.271484375,
          "content": "/*\n * repmgrd-physical.c - physical (streaming) replication functionality for repmgrd\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <signal.h>\n\n#include \"repmgr.h\"\n#include \"repmgrd.h\"\n#include \"repmgrd-physical.h\"\n\ntypedef enum\n{\n\tFAILOVER_STATE_UNKNOWN = -1,\n\tFAILOVER_STATE_NONE,\n\tFAILOVER_STATE_PROMOTED,\n\tFAILOVER_STATE_PROMOTION_FAILED,\n\tFAILOVER_STATE_PRIMARY_REAPPEARED,\n\tFAILOVER_STATE_LOCAL_NODE_FAILURE,\n\tFAILOVER_STATE_WAITING_NEW_PRIMARY,\n\tFAILOVER_STATE_FOLLOW_NEW_PRIMARY,\n\tFAILOVER_STATE_REQUIRES_MANUAL_FAILOVER,\n\tFAILOVER_STATE_FOLLOWED_NEW_PRIMARY,\n\tFAILOVER_STATE_FOLLOWING_ORIGINAL_PRIMARY,\n\tFAILOVER_STATE_NO_NEW_PRIMARY,\n\tFAILOVER_STATE_FOLLOW_FAIL,\n\tFAILOVER_STATE_NODE_NOTIFICATION_ERROR,\n\tFAILOVER_STATE_ELECTION_RERUN\n} FailoverState;\n\n\ntypedef enum\n{\n\tELECTION_NOT_CANDIDATE = -1,\n\tELECTION_WON,\n\tELECTION_LOST,\n\tELECTION_CANCELLED,\n\tELECTION_RERUN\n} ElectionResult;\n\ntypedef struct election_stats\n{\n\tint visible_nodes;\n\tint shared_upstream_nodes;\n\tint all_nodes;\n} election_stats;\n\ntypedef struct t_child_node_info\n{\n\tint node_id;\n\tchar node_name[NAMEDATALEN];\n\tt_server_type type;\n\tNodeAttached attached;\n\tinstr_time detached_time;\n\tstruct t_child_node_info *next;\n} t_child_node_info;\n\ntypedef struct t_child_node_info_list\n{\n\tt_child_node_info *head;\n\tt_child_node_info *tail;\n\tint\t\t\tnode_count;\n} t_child_node_info_list;\n\n#define T_CHILD_NODE_INFO_LIST_INITIALIZER { \\\n\tNULL, \\\n\tNULL, \\\n\t0 \\\n}\n\nstatic PGconn *upstream_conn = NULL;\nstatic PGconn *primary_conn = NULL;\n\nstatic FailoverState failover_state = FAILOVER_STATE_UNKNOWN;\n\nstatic int\tprimary_node_id = UNKNOWN_NODE_ID;\nstatic t_node_info upstream_node_info = T_NODE_INFO_INITIALIZER;\n\nstatic instr_time last_monitoring_update;\n\nstatic bool child_nodes_disconnect_command_executed = false;\n\nstatic ElectionResult do_election(NodeInfoList *sibling_nodes, int *new_primary_id);\nstatic const char *_print_election_result(ElectionResult result);\n\nstatic FailoverState promote_self(void);\nstatic void notify_followers(NodeInfoList *standby_nodes, int follow_node_id);\n\nstatic void check_connection(t_node_info *node_info, PGconn **conn);\n\nstatic bool check_primary_status(int degraded_monitoring_elapsed);\nstatic void check_primary_child_nodes(t_child_node_info_list *local_child_nodes);\n\nstatic bool wait_primary_notification(int *new_primary_id);\nstatic FailoverState follow_new_primary(int new_primary_id);\nstatic FailoverState witness_follow_new_primary(int new_primary_id);\n\nstatic void reset_node_voting_status(void);\n\nstatic bool do_primary_failover(void);\nstatic bool do_upstream_standby_failover(void);\nstatic bool do_witness_failover(void);\n\nstatic bool update_monitoring_history(void);\n\nstatic void handle_sighup(PGconn **conn, t_server_type server_type);\n\nstatic const char *format_failover_state(FailoverState failover_state);\nstatic ElectionResult execute_failover_validation_command(t_node_info *node_info, election_stats *stats);\nstatic void parse_failover_validation_command(const char *template, t_node_info *node_info, election_stats *stats, PQExpBufferData *out);\nstatic bool check_node_can_follow(PGconn *local_conn, XLogRecPtr local_xlogpos, PGconn *follow_target_conn, t_node_info *follow_target_node_info);\nstatic void check_witness_attached(t_node_info *node_info, bool startup);\n\nstatic t_child_node_info *append_child_node_record(t_child_node_info_list *nodes, int node_id, const char *node_name, t_server_type type, NodeAttached attached);\nstatic void remove_child_node_record(t_child_node_info_list *nodes, int node_id);\nstatic void clear_child_node_info_list(t_child_node_info_list *nodes);\nstatic void parse_child_nodes_disconnect_command(char *parsed_command, char *template, int reporting_node_id);\nstatic void execute_child_nodes_disconnect_command(NodeInfoList *db_child_node_records, t_child_node_info_list *local_child_nodes);\n\nstatic int try_primary_reconnect(PGconn **conn, PGconn *local_conn, t_node_info *node_info);\n\nvoid\nhandle_sigint_physical(SIGNAL_ARGS)\n{\n\tPGconn *writeable_conn;\n\tPQExpBufferData event_details;\n\n\tinitPQExpBuffer(&event_details);\n\n\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t  _(\"%s signal received\"),\n\t\t\t\t\t  postgres_signal_arg == SIGTERM\n\t\t\t\t\t  ? \"TERM\" : \"INT\");\n\n\tlog_notice(\"%s\", event_details.data);\n\n\tif (local_node_info.type == PRIMARY)\n\t\twriteable_conn = local_conn;\n\telse\n\t\twriteable_conn = primary_conn;\n\n\tif (PQstatus(writeable_conn) == CONNECTION_OK)\n\t\tcreate_event_notification(writeable_conn,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t  \"repmgrd_shutdown\",\n\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t  event_details.data);\n\n\ttermPQExpBuffer(&event_details);\n\n\tterminate(SUCCESS);\n}\n\n/* perform some sanity checks on the node's configuration */\n\nvoid\ndo_physical_node_check(PGconn *conn)\n{\n\t/*\n\t * If node record is \"inactive\"; if not, attempt to set it to \"active\".\n\t *\n\t * Usually it will have become inactive due to e.g. a standby being shut down\n\t * while repmgrd was running in an unpaused state. In this case it's\n\t * perfectly reasonable to automatically mark the node as \"active\".\n\t */\n\n\tif (local_node_info.active == false)\n\t{\n\t\tchar\t   *hint = \"Check that \\\"repmgr (primary|standby) register\\\" was executed for this node\";\n\t\tRecoveryType recovery_type = get_recovery_type(conn);\n\n\t\t/*\n\t\t * If the local node's recovery status is incompatible with its registered\n\t\t * status, e.g. registered as primary but running as a standby, refuse to start.\n\t\t *\n\t\t * This typically happens when a failed primary is recloned but the node was not\n\t\t * re-registered, leaving the cluster in a potentially ambiguous state. In\n\t\t * this case it would not be possible or desirable to attempt to set the\n\t\t * node to active; the user should ensure the cluster is in the correct state.\n\t\t */\n\t\tif (recovery_type != RECTYPE_UNKNOWN && local_node_info.type != UNKNOWN)\n\t\t{\n\t\t\tbool\trequire_reregister = false;\n\t\t\tPQExpBufferData event_details;\n\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\tif (recovery_type == RECTYPE_STANDBY && local_node_info.type != STANDBY)\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t  _(\"node is registered as a %s but running as a standby\"),\n\t\t\t\t\t\t\t\t  get_node_type_string(local_node_info.type));\n\n\t\t\t\trequire_reregister = true;\n\t\t\t}\n\t\t\telse if (recovery_type == RECTYPE_PRIMARY && local_node_info.type == STANDBY)\n\t\t\t{\n\t\t\t\tlog_error(_(\"node is registered as a standby but running as a %s\"), get_node_type_string(local_node_info.type));\n\t\t\t\trequire_reregister = true;\n\t\t\t}\n\n\t\t\tif (require_reregister == true)\n\t\t\t{\n\t\t\t\tlog_error(\"%s\", event_details.data);\n\t\t\t\tlog_hint(_(\"%s\"), hint);\n\n\t\t\t\tcreate_event_notification(NULL,\n\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t  \"repmgrd_start\",\n\t\t\t\t\t\t\t\t\t\t  false,\n\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\t\ttermPQExpBuffer(&event_details);\n\t\t\t\tterminate(ERR_BAD_CONFIG);\n\t\t\t}\n\n\t\t\ttermPQExpBuffer(&event_details);\n\t\t}\n\n\t\t/*\n\t\t * Attempt to set node record active (unless explicitly configured not to)\n\t\t */\n\t\tlog_notice(_(\"setting node record for node \\\"%s\\\" (ID: %i) to \\\"active\\\"\"),\n\t\t\t\t   local_node_info.node_name,\n\t\t\t\t   local_node_info.node_id);\n\n\t\tif (config_file_options.repmgrd_exit_on_inactive_node == false)\n\t\t{\n\t\t\tPGconn *primary_conn = get_primary_connection(conn, NULL, NULL);\n\t\t\tbool\tsuccess = true;\n\n\t\t\tif (PQstatus(primary_conn) != CONNECTION_OK)\n\t\t\t{\n\t\t\t\tlog_error(_(\"unable to connect to the primary node to activate the node record\"));\n\t\t\t\tsuccess = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsuccess = update_node_record_set_active(primary_conn, local_node_info.node_id, true);\n\t\t\t\tPQfinish(primary_conn);\n\t\t\t}\n\n\t\t\tif (success == true)\n\t\t\t{\n\t\t\t\tlocal_node_info.active = true;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Corner-case where it was not possible to set the node to \"active\"\n\t\t */\n\t\tif (local_node_info.active == false)\n\t\t{\n\t\t\tswitch (config_file_options.failover)\n\t\t\t{\n\t\t\t\t/* \"failover\" is an enum, all values should be covered here */\n\n\t\t\t\tcase FAILOVER_AUTOMATIC:\n\t\t\t\t\tlog_error(_(\"this node is marked as inactive and cannot be used as a failover target\"));\n\t\t\t\t\tlog_hint(_(\"%s\"), hint);\n\n\t\t\t\t\tcreate_event_notification(NULL,\n\t\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t\t  \"repmgrd_start\",\n\t\t\t\t\t\t\t\t\t\t\t  false,\n\t\t\t\t\t\t\t\t\t\t\t  \"node is inactive and cannot be used as a failover target\");\n\n\t\t\t\t\tterminate(ERR_BAD_CONFIG);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FAILOVER_MANUAL:\n\t\t\t\t\tlog_warning(_(\"this node is marked as inactive and will be passively monitored only\"));\n\t\t\t\t\tlog_hint(_(\"%s\"), hint);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (config_file_options.failover == FAILOVER_AUTOMATIC)\n\t{\n\t\t/*\n\t\t * Check that \"promote_command\" and \"follow_command\" are defined, otherwise repmgrd\n\t\t * won't be able to perform any useful action in a failover situation.\n\t\t */\n\n\t\tbool\t\trequired_param_missing = false;\n\n\t\tif (config_file_options.promote_command[0] == '\\0')\n\t\t{\n\t\t\tlog_error(_(\"\\\"promote_command\\\" must be defined in the configuration file\"));\n\n\t\t\tif (config_file_options.service_promote_command[0] != '\\0')\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * \"service_promote_command\" is *not* a substitute for \"promote_command\";\n\t\t\t\t * it is intended for use in those systems (e.g. Debian) where there's a service\n\t\t\t\t * level promote command (e.g. pg_ctlcluster).\n\t\t\t\t *\n\t\t\t\t * \"promote_command\" should either execute \"repmgr standby promote\" directly, or\n\t\t\t\t * a script which executes \"repmgr standby promote\". This is essential, as the\n\t\t\t\t * repmgr metadata is updated by \"repmgr standby promote\".\n\t\t\t\t *\n\t\t\t\t * \"service_promote_command\", if set, will be executed by \"repmgr standby promote\",\n\t\t\t\t * but never by repmgrd.\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tlog_hint(_(\"\\\"service_promote_command\\\" is set, but can only be executed by \\\"repmgr standby promote\\\"\"));\n\t\t\t}\n\n\t\t\trequired_param_missing = true;\n\t\t}\n\n\t\tif (config_file_options.follow_command[0] == '\\0')\n\t\t{\n\t\t\tlog_error(_(\"\\\"follow_command\\\" must be defined in the configuration file\"));\n\t\t\trequired_param_missing = true;\n\t\t}\n\n\t\tif (required_param_missing == true)\n\t\t{\n\t\t\tlog_hint(_(\"add the missing configuration parameter(s) and start repmgrd again\"));\n\t\t\tterminate(ERR_BAD_CONFIG);\n\t\t}\n\t}\n}\n\n\n\n/*\n * repmgrd running on the primary server\n */\nvoid\nmonitor_streaming_primary(void)\n{\n\tinstr_time\tlog_status_interval_start;\n\tinstr_time\tchild_nodes_check_interval_start;\n\tt_child_node_info_list local_child_nodes = T_CHILD_NODE_INFO_LIST_INITIALIZER;\n\n\treset_node_voting_status();\n\trepmgrd_set_upstream_node_id(local_conn, NO_UPSTREAM_NODE);\n\n\t{\n\t\tPQExpBufferData event_details;\n\t\tinitPQExpBuffer(&event_details);\n\n\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t  _(\"monitoring cluster primary \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t  local_node_info.node_name,\n\t\t\t\t\t\t  local_node_info.node_id);\n\n\t\t/* Log startup event */\n\t\tif (startup_event_logged == false)\n\t\t{\n\t\t\tcreate_event_notification(local_conn,\n\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t  \"repmgrd_start\",\n\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\tstartup_event_logged = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcreate_event_notification(local_conn,\n\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t  \"repmgrd_reload\",\n\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t  event_details.data);\n\t\t}\n\n\t\tlog_notice(\"%s\", event_details.data);\n\n\t\ttermPQExpBuffer(&event_details);\n\t}\n\n\tINSTR_TIME_SET_CURRENT(log_status_interval_start);\n\tINSTR_TIME_SET_CURRENT(child_nodes_check_interval_start);\n\tlocal_node_info.node_status = NODE_STATUS_UP;\n\n\t/*\n\t * get list of expected and attached nodes\n\t */\n\n\t{\n\t\tNodeInfoList db_child_node_records = T_NODE_INFO_LIST_INITIALIZER;\n\t\tbool success = get_child_nodes(local_conn, config_file_options.node_id, &db_child_node_records);\n\n\t\tif (!success)\n\t\t{\n\t\t\tlog_error(_(\"unable to retrieve list of child nodes\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNodeInfoListCell *cell;\n\n\t\t\tfor (cell = db_child_node_records.head; cell; cell = cell->next)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * At startup, if a node for which a repmgr record exists, is not found\n\t\t\t\t * in pg_stat_replication, we can't know whether it has become detached, or\n\t\t\t\t * (e.g. during a provisioning operation) is a new node which has not yet\n\t\t\t\t * attached. We set the status to \"NODE_ATTACHED_UNKNOWN\" to stop repmgrd\n\t\t\t\t * emitting bogus \"node has become detached\" alerts.\n\t\t\t\t */\n\t\t\t\t(void) append_child_node_record(&local_child_nodes,\n\t\t\t\t\t\t\t\t\t\t\t\tcell->node_info->node_id,\n\t\t\t\t\t\t\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\t\t\t\t\t\t\tcell->node_info->type,\n\t\t\t\t\t\t\t\t\t\t\t\tcell->node_info->attached == NODE_ATTACHED ? NODE_ATTACHED : NODE_ATTACHED_UNKNOWN);\n\n\t\t\t\t/*\n\t\t\t\t * witness will not be \"attached\" in the normal way\n\t\t\t\t */\n\t\t\t\tif (cell->node_info->type == WITNESS)\n\t\t\t\t{\n\t\t\t\t\tcheck_witness_attached(cell->node_info, true);\n\t\t\t\t}\n\n\t\t\t\tif (cell->node_info->attached == NODE_ATTACHED)\n\t\t\t\t{\n\t\t\t\t\tlog_info(_(\"child node \\\"%s\\\" (ID: %i) is attached\"),\n\t\t\t\t\t\t\t cell->node_info->node_name,\n\t\t\t\t\t\t\t cell->node_info->node_id);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlog_info(_(\"child node \\\"%s\\\" (ID: %i) is not yet attached\"),\n\t\t\t\t\t\t\t\t cell->node_info->node_name,\n\t\t\t\t\t\t\t cell->node_info->node_id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true)\n\t{\n\t\t/*\n\t\t * TODO: cache node list here, refresh at `node_list_refresh_interval`\n\t\t * also return reason for inavailability so we can log it\n\t\t */\n\n\t\t(void) connection_ping(local_conn);\n\n\t\tcheck_connection(&local_node_info, &local_conn);\n\n\t\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t\t{\n\n\t\t\t/* local node is down, we were expecting it to be up */\n\t\t\tif (local_node_info.node_status == NODE_STATUS_UP)\n\t\t\t{\n\n\t\t\t\tinstr_time\tlocal_node_unreachable_start;\n\n\t\t\t\tINSTR_TIME_SET_CURRENT(local_node_unreachable_start);\n\n\t\t\t\t{\n\t\t\t\t\tPQExpBufferData event_details;\n\t\t\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\t\t\tappendPQExpBufferStr(&event_details,\n\t\t\t\t\t\t\t\t\t\t _(\"unable to connect to local node\"));\n\n\t\t\t\t\tlog_warning(\"%s\", event_details.data);\n\n\n\t\t\t\t\t/*\n\t\t\t\t\t * as we're monitoring the primary, no point in trying to\n\t\t\t\t\t * write the event to the database\n\t\t\t\t\t *\n\t\t\t\t\t * TODO: possibly add pre-action event here\n\t\t\t\t\t */\n\t\t\t\t\tcreate_event_notification(NULL,\n\t\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t\t  \"repmgrd_local_disconnect\",\n\t\t\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\t\t\ttermPQExpBuffer(&event_details);\n\t\t\t\t}\n\n\t\t\t\tlocal_node_info.node_status = NODE_STATUS_UNKNOWN;\n\n\t\t\t\ttry_reconnect(&local_conn, &local_node_info);\n\n\t\t\t\tif (local_node_info.node_status == NODE_STATUS_UP)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tlocal_node_unreachable_elapsed = calculate_elapsed(local_node_unreachable_start);\n\t\t\t\t\tint \t\tstored_local_node_id = UNKNOWN_NODE_ID;\n\t\t\t\t\tPQExpBufferData event_details;\n\n\t\t\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t\t  _(\"reconnected to local node after %i seconds\"),\n\t\t\t\t\t\t\t\t\t  local_node_unreachable_elapsed);\n\t\t\t\t\tlog_notice(\"%s\", event_details.data);\n\n\t\t\t\t\tcreate_event_notification(local_conn,\n\t\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t\t  \"repmgrd_local_reconnect\",\n\t\t\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\t\t\t\t\ttermPQExpBuffer(&event_details);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If the local node was restarted, we'll need to reinitialise values\n\t\t\t\t\t * stored in shared memory.\n\t\t\t\t\t */\n\n\t\t\t\t\tstored_local_node_id = repmgrd_get_local_node_id(local_conn);\n\t\t\t\t\tif (stored_local_node_id == UNKNOWN_NODE_ID)\n\t\t\t\t\t{\n\t\t\t\t\t\trepmgrd_set_local_node_id(local_conn, config_file_options.node_id);\n\t\t\t\t\t\trepmgrd_set_pid(local_conn, getpid(), pid_file);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * check that the local node is still primary, otherwise switch\n\t\t\t\t\t * to standby monitoring\n\t\t\t\t\t */\n\t\t\t\t\tif (check_primary_status(NO_DEGRADED_MONITORING_ELAPSED) == false)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tgoto loop;\n\t\t\t\t}\n\n\t\t\t\tmonitoring_state = MS_DEGRADED;\n\t\t\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\t\t\t\tlog_notice(_(\"unable to connect to local node, falling back to degraded monitoring\"));\n\t\t\t}\n\n\t\t}\n\n\n\t\tif (monitoring_state == MS_DEGRADED)\n\t\t{\n\t\t\tint\t\t\tdegraded_monitoring_elapsed = calculate_elapsed(degraded_monitoring_start);\n\n\t\t\tif (config_file_options.degraded_monitoring_timeout > 0\n\t\t\t\t&& degraded_monitoring_elapsed > config_file_options.degraded_monitoring_timeout)\n\t\t\t{\n\t\t\t\tPQExpBufferData event_details;\n\n\t\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t  _(\"degraded monitoring timeout (%i seconds) exceeded, terminating\"),\n\t\t\t\t\t\t\t\t  degraded_monitoring_elapsed);\n\n\t\t\t\tlog_notice(\"%s\", event_details.data);\n\n\t\t\t\tcreate_event_notification(NULL,\n\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t  \"repmgrd_shutdown\",\n\t\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\t\ttermPQExpBuffer(&event_details);\n\t\t\t\tterminate(ERR_MONITORING_TIMEOUT);\n\t\t\t}\n\n\t\t\tlog_debug(\"monitoring node in degraded state for %i seconds\", degraded_monitoring_elapsed);\n\n\t\t\tif (is_server_available(local_node_info.conninfo) == true)\n\t\t\t{\n\t\t\t\tclose_connection(&local_conn);\n\t\t\t\tlocal_conn = establish_db_connection(local_node_info.conninfo, false);\n\n\t\t\t\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t\t\t\t{\n\t\t\t\t\tlog_warning(_(\"node appears to be up but no connection could be made\"));\n\t\t\t\t\tclose_connection(&local_conn);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlocal_node_info.node_status = NODE_STATUS_UP;\n\n\t\t\t\t\tif (check_primary_status(degraded_monitoring_elapsed) == false)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tgoto loop;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t/*\n\t\t\t * possibly attempt to find another node from cached list check if\n\t\t\t * there's a new primary - if so add hook for fencing? loop, if\n\t\t\t * starts up check status, switch monitoring mode\n\t\t\t */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (config_file_options.child_nodes_check_interval > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tchild_nodes_check_interval_elapsed = calculate_elapsed(child_nodes_check_interval_start);\n\n\t\t\t\tif (child_nodes_check_interval_elapsed >= config_file_options.child_nodes_check_interval)\n\t\t\t\t{\n\t\t\t\t\tINSTR_TIME_SET_CURRENT(child_nodes_check_interval_start);\n\t\t\t\t\tcheck_primary_child_nodes(&local_child_nodes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nloop:\n\n\t\t/* check node is still primary, if not restart monitoring */\n\t\tif (check_primary_status(NO_DEGRADED_MONITORING_ELAPSED) == false)\n\t\t\treturn;\n\n\t\t/* emit \"still alive\" log message at regular intervals, if requested */\n\t\tif (config_file_options.log_status_interval > 0)\n\t\t{\n\t\t\tint\t\t\tlog_status_interval_elapsed = calculate_elapsed(log_status_interval_start);\n\n\t\t\tif (log_status_interval_elapsed >= config_file_options.log_status_interval)\n\t\t\t{\n\t\t\t\tlog_info(_(\"monitoring primary node \\\"%s\\\" (ID: %i) in %s state\"),\n\t\t\t\t\t\t local_node_info.node_name,\n\t\t\t\t\t\t local_node_info.node_id,\n\t\t\t\t\t\t print_monitoring_state(monitoring_state));\n\n\t\t\t\tif (monitoring_state == MS_DEGRADED)\n\t\t\t\t{\n\t\t\t\t\tlog_detail(_(\"waiting for the node to become available\"));\n\t\t\t\t}\n\n\t\t\t\tINSTR_TIME_SET_CURRENT(log_status_interval_start);\n\t\t\t}\n\t\t}\n\n\t\tif (got_SIGHUP)\n\t\t{\n\t\t\thandle_sighup(&local_conn, PRIMARY);\n\t\t}\n\n\t\tlog_verbose(LOG_DEBUG, \"sleeping %i seconds (parameter \\\"monitor_interval_secs\\\")\",\n\t\t\t\t\tconfig_file_options.monitor_interval_secs);\n\n\t\tsleep(config_file_options.monitor_interval_secs);\n\t}\n}\n\n\n/*\n * If monitoring a primary, it's possible that after an outage of the local node\n * (due to e.g. a switchover), the node has come back as a standby. We therefore\n * need to verify its status and if everything looks OK, restart monitoring in\n * standby mode.\n *\n * Returns \"true\" to indicate repmgrd should continue monitoring the node as\n * a primary; \"false\" indicates repmgrd should start monitoring the node as\n * a standby.\n */\nbool\ncheck_primary_status(int degraded_monitoring_elapsed)\n{\n\tPGconn *new_primary_conn;\n\tRecordStatus record_status;\n\tbool resume_monitoring = true;\n\tRecoveryType recovery_type = get_recovery_type(local_conn);\n\n\tif (recovery_type == RECTYPE_UNKNOWN)\n\t{\n\t\tlog_warning(_(\"unable to determine node recovery status\"));\n\t\t/* \"true\" to indicate repmgrd should continue monitoring in degraded state */\n\t\treturn true;\n\t}\n\n\t/* node is still primary - resume monitoring */\n\tif (recovery_type == RECTYPE_PRIMARY)\n\t{\n\t\tif (degraded_monitoring_elapsed != NO_DEGRADED_MONITORING_ELAPSED)\n\t\t{\n\t\t\tPQExpBufferData event_details;\n\n\t\t\tmonitoring_state = MS_NORMAL;\n\n\t\t\tinitPQExpBuffer(&event_details);\n\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t  _(\"reconnected to primary node after %i seconds, resuming monitoring\"),\n\t\t\t\t\t\t\t  degraded_monitoring_elapsed);\n\n\t\t\tcreate_event_notification(local_conn,\n\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t  \"repmgrd_local_reconnect\",\n\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\tlog_notice(\"%s\", event_details.data);\n\t\t\ttermPQExpBuffer(&event_details);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/* the node is now a standby */\n\n\t{\n\t\tPQExpBufferData event_details;\n\t\tinitPQExpBuffer(&event_details);\n\n\t\tif (degraded_monitoring_elapsed != NO_DEGRADED_MONITORING_ELAPSED)\n\t\t{\n\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t  _(\"reconnected to node after %i seconds, node is now a standby, switching to standby monitoring\"),\n\t\t\t\t\t\t\t  degraded_monitoring_elapsed);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappendPQExpBufferStr(&event_details,\n\t\t\t\t\t\t\t\t _(\"node is now a standby, switching to standby monitoring\"));\n\t\t}\n\n\t\tlog_notice(\"%s\", event_details.data);\n\t\ttermPQExpBuffer(&event_details);\n\t}\n\n\tprimary_node_id = UNKNOWN_NODE_ID;\n\n\tnew_primary_conn = get_primary_connection_quiet(local_conn, &primary_node_id, NULL);\n\n\tif (PQstatus(new_primary_conn) != CONNECTION_OK)\n\t{\n\t\tif (primary_node_id == UNKNOWN_NODE_ID)\n\t\t{\n\t\t\tlog_warning(_(\"unable to determine a new primary node\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_warning(_(\"unable to connect to new primary node %i\"), primary_node_id);\n\t\t\tlog_detail(\"\\n%s\", PQerrorMessage(new_primary_conn));\n\t\t}\n\n\t\tclose_connection(&new_primary_conn);\n\n\t\t/* \"true\" to indicate repmgrd should continue monitoring in degraded state */\n\t\treturn true;\n\t}\n\n\tlog_debug(\"primary node ID is now %i\", primary_node_id);\n\n\trecord_status = get_node_record(new_primary_conn, config_file_options.node_id, &local_node_info);\n\n\t/*\n\t * If, for whatever reason, the new primary has no record of this node,\n\t * we won't be able to perform proper monitoring. In that case\n\t * terminate and let the user sort out the situation.\n\t */\n\tif (record_status == RECORD_NOT_FOUND)\n\t{\n\t\tPQExpBufferData event_details;\n\n\t\tinitPQExpBuffer(&event_details);\n\n\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t  _(\"no metadata record found for this node on current primary %i\"),\n\t\t\t\t\t\t  primary_node_id);\n\n\t\tlog_error(\"%s\", event_details.data);\n\t\tlog_hint(_(\"check that 'repmgr (primary|standby) register' was executed for this node\"));\n\n\t\tclose_connection(&new_primary_conn);\n\n\t\tcreate_event_notification(NULL,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t  \"repmgrd_shutdown\",\n\t\t\t\t\t\t\t\t  false,\n\t\t\t\t\t\t\t\t  event_details.data);\n\t\ttermPQExpBuffer(&event_details);\n\n\t\tterminate(ERR_BAD_CONFIG);\n\t}\n\n\tlog_debug(\"node %i is registered with type = %s\",\n\t\t\t  config_file_options.node_id,\n\t\t\t  get_node_type_string(local_node_info.type));\n\n\t/*\n\t * node has recovered but metadata not updated - we can do that ourselves,\n\t */\n\tif (local_node_info.type == PRIMARY)\n\t{\n\t\tlog_notice(_(\"node \\\"%s\\\" (ID: %i) still registered as primary, setting to standby\"),\n\t\t\t\t   config_file_options.node_name,\n\t\t\t\t   config_file_options.node_id);\n\n\t\tif (update_node_record_set_active_standby(new_primary_conn, config_file_options.node_id) == false)\n\t\t{\n\t\t\tresume_monitoring = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* refresh our copy of the node record from the primary */\n\t\t\trecord_status = get_node_record(new_primary_conn, config_file_options.node_id, &local_node_info);\n\n\t\t\t/* this is unlikely to happen */\n\t\t\tif (record_status != RECORD_FOUND)\n\t\t\t{\n\t\t\t\tlog_warning(_(\"unable to retrieve local node record from primary node %i\"), primary_node_id);\n\t\t\t\tresume_monitoring = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (resume_monitoring == true)\n\t{\n\t\tPQExpBufferData event_details;\n\t\tinitPQExpBuffer(&event_details);\n\n\t\tif (degraded_monitoring_elapsed != NO_DEGRADED_MONITORING_ELAPSED)\n\t\t{\n\t\t\tmonitoring_state = MS_NORMAL;\n\n\t\t\tlog_notice(_(\"former primary has been restored as standby after %i seconds, updating node record and resuming monitoring\"),\n\t\t\t\t\t   degraded_monitoring_elapsed);\n\n\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t  _(\"node restored as standby after %i seconds, monitoring connection to upstream node %i\"),\n\t\t\t\t\t\t\t  degraded_monitoring_elapsed,\n\t\t\t\t\t\t\t  local_node_info.upstream_node_id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (local_node_info.upstream_node_id == UNKNOWN_NODE_ID)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If upstream_node_id is not set, it's possible that following a switchover\n\t\t\t\t * of some kind (possibly forced in some way), the updated node record has\n\t\t\t\t * not yet propagated to the local node. In this case however we can safely\n\t\t\t\t * assume we're monitoring the primary.\n\t\t\t\t */\n\n\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t  _(\"node has become a standby, monitoring connection to primary node %i\"),\n\t\t\t\t\t\t\t\t  primary_node_id);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t  _(\"node has become a standby, monitoring connection to upstream node %i\"),\n\t\t\t\t\t\t\t\t  local_node_info.upstream_node_id);\n\t\t\t}\n\t\t}\n\n\t\tcreate_event_notification(new_primary_conn,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t  \"repmgrd_standby_reconnect\",\n\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\ttermPQExpBuffer(&event_details);\n\n\t\tclose_connection(&new_primary_conn);\n\n\t\t/* restart monitoring as standby */\n\t\treturn false;\n\t}\n\n\t/* continue monitoring as before */\n\treturn true;\n}\n\n\nstatic void\ncheck_primary_child_nodes(t_child_node_info_list *local_child_nodes)\n{\n\tNodeInfoList db_child_node_records = T_NODE_INFO_LIST_INITIALIZER;\n\tNodeInfoListCell *cell;\n\t/* lists for newly attached and missing nodes */\n\tt_child_node_info_list disconnected_child_nodes = T_CHILD_NODE_INFO_LIST_INITIALIZER;\n\tt_child_node_info_list reconnected_child_nodes = T_CHILD_NODE_INFO_LIST_INITIALIZER;\n\tt_child_node_info_list new_child_nodes = T_CHILD_NODE_INFO_LIST_INITIALIZER;\n\n\tbool success = get_child_nodes(local_conn, config_file_options.node_id, &db_child_node_records);\n\n\tif (!success)\n\t{\n\t\t/* unlikely this will happen, but if it does, we'll try again next time round */\n\t\tlog_error(_(\"unable to retrieve list of child nodes\"));\n\t\treturn;\n\t}\n\n\tif (db_child_node_records.node_count == 0)\n\t{\n\t\t/* no registered child nodes - nothing to do */\n\t\treturn;\n\t}\n\n\t/*\n\t * compare DB records with our internal list;\n\t * this will tell us about:\n\t *  - previously known nodes and their current status\n\t *  - newly registered nodes we didn't know about\n\t *\n\t * We'll need to compare the opposite way to check for nodes\n\t * which are in the internal list, but which have now vanished\n\t */\n\tfor (cell = db_child_node_records.head; cell; cell = cell->next)\n\t{\n\t\tt_child_node_info *local_child_node_rec;\n\t\tbool local_child_node_rec_found = false;\n\n\n\t\t/*\n\t\t * witness will not be \"attached\" in the normal way\n\t\t */\n\t\tif (cell->node_info->type == WITNESS)\n\t\t{\n\t\t\tcheck_witness_attached(cell->node_info, false);\n\t\t}\n\n\t\tlog_debug(\"child node: %i; attached: %s\",\n\t\t\t\t  cell->node_info->node_id,\n\t\t\t\t  cell->node_info->attached == NODE_ATTACHED ? \"yes\" : \"no\");\n\n\t\tfor (local_child_node_rec = local_child_nodes->head; local_child_node_rec; local_child_node_rec = local_child_node_rec->next)\n\t\t{\n\t\t\tif (local_child_node_rec->node_id == cell->node_info->node_id)\n\t\t\t{\n\t\t\t\tlocal_child_node_rec_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (local_child_node_rec_found == true)\n\t\t{\n\t\t\t/* our node record shows node attached, DB record indicates detached */\n\t\t\tif (local_child_node_rec->attached == NODE_ATTACHED && cell->node_info->attached == NODE_DETACHED)\n\t\t\t{\n\t\t\t\tt_child_node_info *detached_child_node;\n\n\t\t\t\tlocal_child_node_rec->attached = NODE_DETACHED;\n\t\t\t\tINSTR_TIME_SET_CURRENT(local_child_node_rec->detached_time);\n\n\t\t\t\tdetached_child_node = append_child_node_record(&disconnected_child_nodes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   local_child_node_rec->node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   local_child_node_rec->node_name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   local_child_node_rec->type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NODE_DETACHED);\n\t\t\t\tdetached_child_node->detached_time = local_child_node_rec->detached_time;\n\t\t\t}\n\t\t\t/* our node record shows node detached, DB record indicates attached */\n\t\t\telse if (local_child_node_rec->attached == NODE_DETACHED && cell->node_info->attached == NODE_ATTACHED)\n\t\t\t{\n\t\t\t\tt_child_node_info *attached_child_node;\n\n\t\t\t\tlocal_child_node_rec->attached = NODE_ATTACHED;\n\n\t\t\t\tattached_child_node = append_child_node_record(&reconnected_child_nodes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   local_child_node_rec->node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   local_child_node_rec->node_name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   local_child_node_rec->type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NODE_ATTACHED);\n\t\t\t\tattached_child_node->detached_time = local_child_node_rec->detached_time;\n\t\t\t\tINSTR_TIME_SET_ZERO(local_child_node_rec->detached_time);\n\t\t\t}\n\t\t\telse if (local_child_node_rec->attached == NODE_ATTACHED_UNKNOWN  && cell->node_info->attached == NODE_ATTACHED)\n\t\t\t{\n\t\t\t\tlocal_child_node_rec->attached = NODE_ATTACHED;\n\n\t\t\t\tappend_child_node_record(&new_child_nodes,\n\t\t\t\t\t\t\t\t\t\t local_child_node_rec->node_id,\n\t\t\t\t\t\t\t\t\t\t local_child_node_rec->node_name,\n\t\t\t\t\t\t\t\t\t\t local_child_node_rec->type,\n\t\t\t\t\t\t\t\t\t\t NODE_ATTACHED);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* node we didn't know about before */\n\n\t\t\tNodeAttached attached = cell->node_info->attached;\n\n\t\t\t/*\n\t\t\t * node registered but not attached - set state to \"UNKNOWN\"\n\t\t\t * to prevent a bogus \"reattach\" event being generated\n\t\t\t */\n\t\t\tif (attached == NODE_DETACHED)\n\t\t\t\tattached = NODE_ATTACHED_UNKNOWN;\n\n\t\t\t(void) append_child_node_record(local_child_nodes,\n\t\t\t\t\t\t\t\t\t\t\tcell->node_info->node_id,\n\t\t\t\t\t\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\t\t\t\t\t\tcell->node_info->type,\n\t\t\t\t\t\t\t\t\t\t\tattached);\n\t\t\t(void) append_child_node_record(&new_child_nodes,\n\t\t\t\t\t\t\t\t\t\t\tcell->node_info->node_id,\n\t\t\t\t\t\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\t\t\t\t\t\tcell->node_info->type,\n\t\t\t\t\t\t\t\t\t\t\tattached);\n\t\t}\n\t}\n\n\t/*\n\t * Check if any nodes in local list are no longer in list returned\n\t * from database.\n\t */\n\t{\n\t\tt_child_node_info *local_child_node_rec;\n\t\tbool db_node_rec_found = false;\n\n\t\tfor (local_child_node_rec = local_child_nodes->head; local_child_node_rec; local_child_node_rec = local_child_node_rec->next)\n\t\t{\n\t\t\tfor (cell = db_child_node_records.head; cell; cell = cell->next)\n\t\t\t{\n\t\t\t\tif (cell->node_info->node_id == local_child_node_rec->node_id)\n\t\t\t\t{\n\t\t\t\t\tdb_node_rec_found = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (db_node_rec_found == false)\n\t\t\t{\n\t\t\t\tlog_notice(_(\"%s node \\\"%s\\\" (ID: %i) is no longer connected or registered\"),\n\t\t\t\t\t\t   get_node_type_string(local_child_node_rec->type),\n\t\t\t\t\t\t   local_child_node_rec->node_name,\n\t\t\t\t\t\t   local_child_node_rec->node_id);\n\t\t\t\tremove_child_node_record(local_child_nodes, local_child_node_rec->node_id);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* generate \"child_node_disconnect\" events */\n\tif (disconnected_child_nodes.node_count > 0)\n\t{\n\t\tt_child_node_info *child_node_rec;\n\t\tfor (child_node_rec = disconnected_child_nodes.head; child_node_rec; child_node_rec = child_node_rec->next)\n\t\t{\n\t\t\tPQExpBufferData event_details;\n\t\t\tinitPQExpBuffer(&event_details);\n\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t  _(\"%s node \\\"%s\\\" (ID: %i) has disconnected\"),\n\t\t\t\t\t\t\t  get_node_type_string(child_node_rec->type),\n\t\t\t\t\t\t\t  child_node_rec->node_name,\n\t\t\t\t\t\t\t  child_node_rec->node_id);\n\t\t\tlog_notice(\"%s\",  event_details.data);\n\n\t\t\tcreate_event_notification(local_conn,\n\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t\t  \"child_node_disconnect\",\n\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\ttermPQExpBuffer(&event_details);\n\t\t}\n\t}\n\n\t/* generate \"child_node_reconnect\" events */\n\tif (reconnected_child_nodes.node_count > 0)\n\t{\n\t\tt_child_node_info *child_node_rec;\n\t\tfor (child_node_rec = reconnected_child_nodes.head; child_node_rec; child_node_rec = child_node_rec->next)\n\t\t{\n\t\t\tPQExpBufferData event_details;\n\t\t\tinitPQExpBuffer(&event_details);\n\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t  _(\"%s node \\\"%s\\\" (ID: %i) has reconnected after %i seconds\"),\n\t\t\t\t\t\t\t  get_node_type_string(child_node_rec->type),\n\t\t\t\t\t\t\t  child_node_rec->node_name,\n\t\t\t\t\t\t\t  child_node_rec->node_id,\n\t\t\t\t\t\t\t  calculate_elapsed( child_node_rec->detached_time ));\n\t\t\tlog_notice(\"%s\",  event_details.data);\n\n\t\t\tcreate_event_notification(local_conn,\n\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t\t  \"child_node_reconnect\",\n\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\ttermPQExpBuffer(&event_details);\n\t\t}\n\t}\n\n\t/* generate \"child_node_new_connect\" events */\n\tif (new_child_nodes.node_count > 0)\n\t{\n\t\tt_child_node_info *child_node_rec;\n\t\tfor (child_node_rec = new_child_nodes.head; child_node_rec; child_node_rec = child_node_rec->next)\n\t\t{\n\t\t\tPQExpBufferData event_details;\n\t\t\tinitPQExpBuffer(&event_details);\n\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t  _(\"new %s \\\"%s\\\" (ID: %i) has connected\"),\n\t\t\t\t\t\t\t  get_node_type_string(child_node_rec->type),\n\t\t\t\t\t\t\t  child_node_rec->node_name,\n\t\t\t\t\t\t\t  child_node_rec->node_id);\n\t\t\tlog_notice(\"%s\",  event_details.data);\n\n\t\t\tcreate_event_notification(local_conn,\n\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t\t  \"child_node_new_connect\",\n\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\ttermPQExpBuffer(&event_details);\n\t\t}\n\t}\n\n\n\tif (config_file_options.child_nodes_disconnect_command[0] != '\\0')\n\t{\n\t\tbool repmgrd_paused = repmgrd_is_paused(local_conn);\n\n\t\tif (repmgrd_paused == false)\n\t\t{\n\t\t\t/* check criteria for execution, and execute if criteria met */\n\t\t\texecute_child_nodes_disconnect_command(&db_child_node_records, local_child_nodes);\n\t\t}\n\t}\n\n\tclear_child_node_info_list(&disconnected_child_nodes);\n\tclear_child_node_info_list(&reconnected_child_nodes);\n\tclear_child_node_info_list(&new_child_nodes);\n\n\tclear_node_info_list(&db_child_node_records);\n}\n\n\nvoid\nexecute_child_nodes_disconnect_command(NodeInfoList *db_child_node_records, t_child_node_info_list *local_child_nodes)\n{\n\t/*\n\t * script will only be executed if the number of attached\n\t * standbys is lower than this number\n\t */\n\tint min_required_connected_count = 1;\n\tint connected_count = 0;\n\tNodeInfoListCell *cell;\n\n\t/*\n\t * Calculate minimum number of nodes which need to be connected\n\t * (if the total falls below that, \"child_nodes_disconnect_command\"\n\t * will be executed)\n\t */\n\n\tif (config_file_options.child_nodes_connected_min_count > 0)\n\t{\n\t\tmin_required_connected_count = config_file_options.child_nodes_connected_min_count;\n\t}\n\telse if (config_file_options.child_nodes_disconnect_min_count > 0)\n\t{\n\t\tint child_node_count = db_child_node_records->node_count;\n\n\t\tif (config_file_options.child_nodes_connected_include_witness == false)\n\t\t{\n\t\t\t/* reduce total, if witness server in child node list */\n\t\t\tfor (cell = db_child_node_records->head; cell; cell = cell->next)\n\t\t\t{\n\t\t\t\tif (cell->node_info->type == WITNESS)\n\t\t\t\t{\n\t\t\t\t\tchild_node_count--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmin_required_connected_count =\n\t\t\t(child_node_count - config_file_options.child_nodes_disconnect_min_count)\n\t\t\t+ 1;\n\t}\n\n\t/* calculate number of connected child nodes */\n\tfor (cell = db_child_node_records->head; cell; cell = cell->next)\n\t{\n\t\t/* exclude witness server from total, if necessary */\n\t\tif (config_file_options.child_nodes_connected_include_witness == false &&\n\t\t\tcell->node_info->type == WITNESS)\n\t\t\tcontinue;\n\n\t\tif (cell->node_info->attached == NODE_ATTACHED)\n\t\t\tconnected_count ++;\n\t}\n\n\tlog_debug(\"connected: %i; min required: %i\",\n\t\t\t  connected_count,\n\t\t\t  min_required_connected_count);\n\n\tif (connected_count < min_required_connected_count)\n\t{\n\t\tlog_notice(_(\"%i (of %i) child nodes are connected, but at least %i child nodes required\"),\n\t\t\t\t   connected_count,\n\t\t\t\t   db_child_node_records->node_count,\n\t\t\t\t   min_required_connected_count);\n\n\t\tif (child_nodes_disconnect_command_executed == false)\n\t\t{\n\t\t\tt_child_node_info *child_node_rec;\n\n\t\t\t/* set these for informative purposes */\n\t\t\tint most_recently_disconnected_node_id = UNKNOWN_NODE_ID;\n\t\t\tint most_recently_disconnected_elapsed = -1;\n\n\t\t\tbool most_recent_disconnect_below_threshold = false;\n\t\t\tinstr_time  current_time_base;\n\n\t\t\tINSTR_TIME_SET_CURRENT(current_time_base);\n\n\t\t\tfor (child_node_rec = local_child_nodes->head; child_node_rec; child_node_rec = child_node_rec->next)\n\t\t\t{\n\t\t\t\tinstr_time  current_time = current_time_base;\n\t\t\t\tint seconds_since_detached;\n\n\t\t\t\t/* exclude witness server from calculation, if requested */\n\t\t\t\tif (config_file_options.child_nodes_connected_include_witness == false &&\n\t\t\t\t\tchild_node_rec->type == WITNESS)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (child_node_rec->attached != NODE_DETACHED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tINSTR_TIME_SUBTRACT(current_time, child_node_rec->detached_time);\n\t\t\t\tseconds_since_detached = (int) INSTR_TIME_GET_DOUBLE(current_time);\n\n\t\t\t\tif (seconds_since_detached < config_file_options.child_nodes_disconnect_timeout)\n\t\t\t\t{\n\t\t\t\t\tmost_recent_disconnect_below_threshold = true;\n\t\t\t\t}\n\n\t\t\t\tif (most_recently_disconnected_node_id == UNKNOWN_NODE_ID)\n\t\t\t\t{\n\t\t\t\t\tmost_recently_disconnected_node_id = child_node_rec->node_id;\n\t\t\t\t\tmost_recently_disconnected_elapsed = seconds_since_detached;\n\t\t\t\t}\n\t\t\t\telse if (seconds_since_detached < most_recently_disconnected_elapsed)\n\t\t\t\t{\n\t\t\t\t\tmost_recently_disconnected_node_id = child_node_rec->node_id;\n\t\t\t\t\tmost_recently_disconnected_elapsed = seconds_since_detached;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (most_recent_disconnect_below_threshold == false && most_recently_disconnected_node_id != UNKNOWN_NODE_ID)\n\t\t\t{\n\t\t\t\tchar parsed_child_nodes_disconnect_command[MAXPGPATH];\n\t\t\t\tint child_nodes_disconnect_command_result;\n\t\t\t\tPQExpBufferData event_details;\n\t\t\t\tbool success = true;\n\n\t\t\t\tparse_child_nodes_disconnect_command(parsed_child_nodes_disconnect_command,\n\t\t\t\t\t\t\t\t\t\t\t\t\t config_file_options.child_nodes_disconnect_command,\n\t\t\t\t\t\t\t\t\t\t\t\t\t local_node_info.node_id);\n\n\t\t\t\tlog_info(_(\"most recently detached child node was %i (ca. %i seconds ago), triggering \\\"child_nodes_disconnect_command\\\"\"),\n\t\t\t\t\t\t most_recently_disconnected_node_id,\n\t\t\t\t\t\t most_recently_disconnected_elapsed);\n\n\t\t\t\tlog_info(_(\"\\\"child_nodes_disconnect_command\\\" is:\\n  \\\"%s\\\"\"),\n\t\t\t\t\t\t parsed_child_nodes_disconnect_command);\n\n\t\t\t\tchild_nodes_disconnect_command_result = system(parsed_child_nodes_disconnect_command);\n\n\t\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\t\tif (child_nodes_disconnect_command_result != 0)\n\t\t\t\t{\n\t\t\t\t\tsuccess = false;\n\n\t\t\t\t\tappendPQExpBufferStr(&event_details,\n\t\t\t\t\t\t\t\t\t\t _(\"unable to execute \\\"child_nodes_disconnect_command\\\"\"));\n\n\t\t\t\t\tlog_error(\"%s\", event_details.data);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(&event_details,\n\t\t\t\t\t\t\t\t\t\t _(\"\\\"child_nodes_disconnect_command\\\" successfully executed\"));\n\n\t\t\t\t\tlog_info(\"%s\", event_details.data);\n\t\t\t\t}\n\n\t\t\t\tcreate_event_notification(local_conn,\n\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t  \"child_nodes_disconnect_command\",\n\t\t\t\t\t\t\t\t\t\t  success,\n\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\t\ttermPQExpBuffer(&event_details);\n\n\t\t\t\tchild_nodes_disconnect_command_executed = true;\n\t\t\t}\n\t\t\telse if (most_recently_disconnected_node_id != UNKNOWN_NODE_ID)\n\t\t\t{\n\t\t\t\tlog_info(_(\"most recently detached child node was %i (ca. %i seconds ago), not triggering \\\"child_nodes_disconnect_command\\\"\"),\n\t\t\t\t\t\t most_recently_disconnected_node_id,\n\t\t\t\t\t\t most_recently_disconnected_elapsed);\n\t\t\t\tlog_detail(_(\"\\\"child_nodes_disconnect_timeout\\\" set to %i seconds\"),\n\t\t\t\t\t\t   config_file_options.child_nodes_disconnect_timeout);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_info(_(\"no child nodes have detached since repmgrd startup\"));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_info(_(\"\\\"child_nodes_disconnect_command\\\" was previously executed, taking no action\"));\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * \"child_nodes_disconnect_command\" was executed, but for whatever reason\n\t\t * enough child nodes have returned to clear the threshold; in that case reset\n\t\t * the executed flag so we can execute the command again, if necessary\n\t\t */\n\t\tif (child_nodes_disconnect_command_executed == true)\n\t\t{\n\t\t\tlog_notice(_(\"%i (of %i) child nodes are now connected, meeting minimum requirement of %i child nodes\"),\n\t\t\t\t\t   connected_count,\n\t\t\t\t\t   db_child_node_records->node_count,\n\t\t\t\t\t   min_required_connected_count);\n\t\t\tchild_nodes_disconnect_command_executed = false;\n\t\t}\n\t}\n}\n\n\n/*\n * repmgrd running on a standby server\n */\nvoid\nmonitor_streaming_standby(void)\n{\n\tRecordStatus record_status;\n\tinstr_time\tlog_status_interval_start;\n\n\tMonitoringState local_monitoring_state = MS_NORMAL;\n\tinstr_time\tlocal_degraded_monitoring_start;\n\n\tbool upstream_check_result;\n\tint degraded_monitoring_elapsed;\n\tint last_known_upstream_node_id = UNKNOWN_NODE_ID;\n\n\tlog_debug(\"monitor_streaming_standby()\");\n\n\treset_node_voting_status();\n\n\tINSTR_TIME_SET_ZERO(last_monitoring_update);\n\n\t/*\n\t * If no upstream node id is specified in the metadata, we'll try and\n\t * determine the current cluster primary in the assumption we should\n\t * connect to that by default.\n\t */\n\tif (local_node_info.upstream_node_id == UNKNOWN_NODE_ID)\n\t{\n\t\tupstream_conn = get_primary_connection(local_conn, &local_node_info.upstream_node_id, NULL);\n\n\t\t/*\n\t\t * Terminate if there doesn't appear to be an active cluster primary.\n\t\t * There could be one or more nodes marked as inactive primaries, and\n\t\t * one of them could actually be a primary, but we can't sensibly\n\t\t * monitor in that state.\n\t\t */\n\t\tif (local_node_info.upstream_node_id == NODE_NOT_FOUND)\n\t\t{\n\t\t\tlog_error(_(\"unable to determine an active primary for this cluster, terminating\"));\n\t\t\tterminate(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tlog_debug(\"upstream node ID determined as %i\", local_node_info.upstream_node_id);\n\n\t\t(void) get_node_record(upstream_conn, local_node_info.upstream_node_id, &upstream_node_info);\n\t}\n\telse\n\t{\n\t\tlog_debug(\"upstream node ID in local node record is %i\", local_node_info.upstream_node_id);\n\n\t\trecord_status = get_node_record(local_conn, local_node_info.upstream_node_id, &upstream_node_info);\n\n\t\t/*\n\t\t * Terminate if we can't find the record for the node we're supposed to\n\t\t * monitor. This is a \"fix-the-config\" situation, not a lot else we can\n\t\t * do.\n\t\t */\n\t\tif (record_status == RECORD_NOT_FOUND)\n\t\t{\n\t\t\tlog_error(_(\"no record found for upstream node (ID: %i), terminating\"),\n\t\t\t\t\t  local_node_info.upstream_node_id);\n\t\t\tlog_hint(_(\"ensure the upstream node is registered correctly\"));\n\n\t\t\tterminate(ERR_DB_CONN);\n\t\t}\n\t\telse if (record_status == RECORD_ERROR)\n\t\t{\n\t\t\tlog_error(_(\"unable to retrieve record for upstream node (ID: %i), terminating\"),\n\t\t\t\t\t  local_node_info.upstream_node_id);\n\n\t\t\tterminate(ERR_DB_CONN);\n\t\t}\n\n\t\tlog_debug(\"connecting to upstream node %i: \\\"%s\\\"\", upstream_node_info.node_id, upstream_node_info.conninfo);\n\n\t\tupstream_conn = establish_db_connection(upstream_node_info.conninfo, false);\n\t}\n\n\n\t/*\n\t * Upstream node must be running at repmgrd startup.\n\t *\n\t * We could possibly have repmgrd skip to degraded monitoring mode until\n\t * it comes up, but there doesn't seem to be much point in doing that.\n\t */\n\tif (PQstatus(upstream_conn) != CONNECTION_OK)\n\t{\n\t\tclose_connection(&upstream_conn);\n\t\tlog_error(_(\"unable connect to upstream node (ID: %i), terminating\"),\n\t\t\t\t  local_node_info.upstream_node_id);\n\t\tlog_hint(_(\"upstream node must be running before repmgrd can start\"));\n\n\t\tterminate(ERR_DB_CONN);\n\t}\n\n\trecord_status = get_node_record(upstream_conn, local_node_info.node_id, &local_node_info);\n\n\tif (upstream_node_info.node_id == local_node_info.node_id)\n\t{\n\t\tclose_connection(&upstream_conn);\n\n\t\treturn;\n\t}\n\n\tlast_known_upstream_node_id = local_node_info.upstream_node_id;\n\n\t/*\n\t * refresh upstream node record from upstream node, so it's as up-to-date\n\t * as possible\n\t */\n\trecord_status = get_node_record(upstream_conn, upstream_node_info.node_id, &upstream_node_info);\n\n\tif (upstream_node_info.type == STANDBY)\n\t{\n\t\tlog_debug(\"upstream node is standby, connecting to primary\");\n\t\t/*\n\t\t * Currently cascaded standbys need to be able to connect to the\n\t\t * primary. We could possibly add a limited connection mode for cases\n\t\t * where this isn't possible, but that will complicate things further.\n\t\t */\n\t\tprimary_conn = establish_primary_db_connection(upstream_conn, false);\n\n\t\tif (PQstatus(primary_conn) != CONNECTION_OK)\n\t\t{\n\t\t\tclose_connection(&primary_conn);\n\n\t\t\tlog_error(_(\"unable to connect to primary node\"));\n\t\t\tlog_hint(_(\"ensure the primary node is reachable from this node\"));\n\n\t\t\tterminate(ERR_DB_CONN);\n\t\t}\n\n\t\tlog_verbose(LOG_DEBUG, \"connected to primary\");\n\t}\n\telse\n\t{\n\t\tlog_debug(\"upstream node is primary\");\n\t\tprimary_conn = upstream_conn;\n\t}\n\n\t/*\n\t * It's possible monitoring has been restarted after some outage which\n\t * resulted in the local node being marked as inactive; if so mark it\n\t * as active again.\n\t */\n\tif (local_node_info.active == false)\n\t{\n\t\tif (update_node_record_set_active(primary_conn, local_node_info.node_id, true) == true)\n\t\t{\n\t\t\tPQExpBufferData event_details;\n\n\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\tlocal_node_info.active = true;\n\t\t}\n\t}\n\n\tif (PQstatus(primary_conn) == CONNECTION_OK)\n\t{\n\t\tprimary_node_id = get_primary_node_id(primary_conn);\n\t\tlog_debug(\"primary_node_id is %i\", primary_node_id);\n\t}\n\telse\n\t{\n\t\tprimary_node_id = get_primary_node_id(local_conn);\n\t\tlog_debug(\"primary_node_id according to local records is %i\", primary_node_id);\n\t}\n\n\n\t/* Log startup event */\n\tif (startup_event_logged == false)\n\t{\n\t\tPQExpBufferData event_details;\n\n\t\tinitPQExpBuffer(&event_details);\n\n\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t  _(\"monitoring connection to upstream node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t  upstream_node_info.node_name,\n\t\t\t\t\t\t  upstream_node_info.node_id);\n\n\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t  \"repmgrd_start\",\n\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\tstartup_event_logged = true;\n\n\t\tlog_info(\"%s\", event_details.data);\n\n\t\ttermPQExpBuffer(&event_details);\n\t}\n\n\tmonitoring_state = MS_NORMAL;\n\tINSTR_TIME_SET_CURRENT(log_status_interval_start);\n\tupstream_node_info.node_status = NODE_STATUS_UP;\n\n\twhile (true)\n\t{\n\n\t\tlog_verbose(LOG_DEBUG, \"checking %s\", upstream_node_info.conninfo);\n\n\t\tif (upstream_node_info.type == PRIMARY)\n\t\t{\n\t\t\tupstream_check_result = check_upstream_connection(&upstream_conn, upstream_node_info.conninfo, &primary_conn);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupstream_check_result = check_upstream_connection(&upstream_conn, upstream_node_info.conninfo, NULL);\n\t\t}\n\n\t\tif (upstream_check_result == true)\n\t\t{\n\t\t\tset_upstream_last_seen(local_conn, upstream_node_info.node_id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* upstream node is down, we were expecting it to be up */\n\t\t\tif (upstream_node_info.node_status == NODE_STATUS_UP)\n\t\t\t{\n\t\t\t\tinstr_time\tupstream_node_unreachable_start;\n\n\t\t\t\tINSTR_TIME_SET_CURRENT(upstream_node_unreachable_start);\n\n\n\t\t\t\tupstream_node_info.node_status = NODE_STATUS_UNKNOWN;\n\n\t\t\t\t{\n\t\t\t\t\tPQExpBufferData event_details;\n\t\t\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t\t  _(\"unable to connect to upstream node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t\t\t  upstream_node_info.node_name, upstream_node_info.node_id);\n\n\t\t\t\t\t/* TODO: possibly add pre-action event here */\n\t\t\t\t\tif (upstream_node_info.type == STANDBY)\n\t\t\t\t\t{\n\t\t\t\t\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"repmgrd_upstream_disconnect\",\n\t\t\t\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* primary connection lost - script notification only */\n\t\t\t\t\t\tcreate_event_notification(NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"repmgrd_upstream_disconnect\",\n\t\t\t\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\t\t\t\t\t}\n\n\t\t\t\t\tlog_warning(\"%s\", event_details.data);\n\t\t\t\t\ttermPQExpBuffer(&event_details);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * if local node is unreachable, make a last-minute attempt to reconnect\n\t\t\t\t * before continuing with the failover process\n\t\t\t\t */\n\n\t\t\t\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t\t\t\t{\n\t\t\t\t\tcheck_connection(&local_node_info, &local_conn);\n\t\t\t\t}\n\n\n\t\t\t\tif (upstream_node_info.type == PRIMARY)\n\t\t\t\t{\n\t\t\t\t\tprimary_node_id = try_primary_reconnect(&upstream_conn, local_conn, &upstream_node_info);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We were notified by the the primary during our own reconnection\n\t\t\t\t\t * retry phase, in which case we can leave the failover process early\n\t\t\t\t\t * and connect to the new primary.\n\t\t\t\t\t */\n\t\t\t\t\tif (primary_node_id == ELECTION_RERUN_NOTIFICATION)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (do_primary_failover() == true)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprimary_node_id = get_primary_node_id(local_conn);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (primary_node_id != UNKNOWN_NODE_ID && primary_node_id != ELECTION_RERUN_NOTIFICATION)\n\t\t\t\t\t{\n\t\t\t\t\t\tfollow_new_primary(primary_node_id);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttry_reconnect(&upstream_conn, &upstream_node_info);\n\t\t\t\t}\n\n\t\t\t\t/* Upstream node has recovered - log and continue */\n\t\t\t\tif (upstream_node_info.node_status == NODE_STATUS_UP)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tupstream_node_unreachable_elapsed = calculate_elapsed(upstream_node_unreachable_start);\n\t\t\t\t\tPQExpBufferData event_details;\n\n\t\t\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t\t  _(\"reconnected to upstream node after %i seconds\"),\n\t\t\t\t\t\t\t\t\t  upstream_node_unreachable_elapsed);\n\t\t\t\t\tlog_notice(\"%s\", event_details.data);\n\n\t\t\t\t\tif (upstream_node_info.type == PRIMARY)\n\t\t\t\t\t{\n\t\t\t\t\t\tprimary_conn = upstream_conn;\n\n\t\t\t\t\t\tif (get_recovery_type(primary_conn) == RECTYPE_STANDBY)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tExecStatusType ping_result;\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * we're returning at the end of this block and no longer require the\n\t\t\t\t\t\t\t * event details buffer\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\ttermPQExpBuffer(&event_details);\n\n\t\t\t\t\t\t\tlog_notice(_(\"current upstream node \\\"%s\\\" (ID: %i) is not primary, restarting monitoring\"),\n\t\t\t\t\t\t\t\t\t   upstream_node_info.node_name, upstream_node_info.node_id);\n\n\t\t\t\t\t\t\tclose_connection(&upstream_conn);\n\n\t\t\t\t\t\t\tlocal_node_info.upstream_node_id = UNKNOWN_NODE_ID;\n\n\t\t\t\t\t\t\t/* check local connection */\n\t\t\t\t\t\t\tping_result = connection_ping(local_conn);\n\n\t\t\t\t\t\t\tif (ping_result != PGRES_TUPLES_OK)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint i;\n\n\t\t\t\t\t\t\t\tclose_connection(&local_conn);\n\n\t\t\t\t\t\t\t\tfor (i = 0; i < config_file_options.repmgrd_standby_startup_timeout; i++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlocal_conn = establish_db_connection(local_node_info.conninfo, false);\n\n\t\t\t\t\t\t\t\t\tif (PQstatus(local_conn) == CONNECTION_OK)\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tclose_connection(&local_conn);\n\n\t\t\t\t\t\t\t\t\tlog_debug(\"sleeping 1 second; %i of %i attempts to reconnect to local node\",\n\t\t\t\t\t\t\t\t\t\t\t  i + 1,\n\t\t\t\t\t\t\t\t\t\t\t  config_file_options.repmgrd_standby_startup_timeout);\n\t\t\t\t\t\t\t\t\tsleep(1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t\t  \"repmgrd_upstream_reconnect\",\n\t\t\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\t\t\t\t\ttermPQExpBuffer(&event_details);\n\n\t\t\t\t\tgoto loop;\n\t\t\t\t}\n\n\n\t\t\t\t/* upstream is still down after reconnect attempt(s) */\n\t\t\t\tif (upstream_node_info.node_status == NODE_STATUS_DOWN)\n\t\t\t\t{\n\t\t\t\t\tbool\t\tfailover_done = false;\n\n\t\t\t\t\tif (PQstatus(local_conn) == CONNECTION_OK && repmgrd_is_paused(local_conn))\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_notice(_(\"repmgrd on this node is paused\"));\n\t\t\t\t\t\tlog_detail(_(\"no failover will be carried out\"));\n\t\t\t\t\t\tlog_hint(_(\"execute \\\"repmgr service unpause\\\" to resume normal failover mode\"));\n\t\t\t\t\t\tmonitoring_state = MS_DEGRADED;\n\t\t\t\t\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (upstream_node_info.type == PRIMARY)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfailover_done = do_primary_failover();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (upstream_node_info.type == STANDBY)\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tfailover_done = do_upstream_standby_failover();\n\n\t\t\t\t\t\t\tif (failover_done == false)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmonitoring_state = MS_DEGRADED;\n\t\t\t\t\t\t\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * XXX it's possible it will make sense to return in all\n\t\t\t\t\t\t * cases to restart monitoring\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (failover_done == true)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprimary_node_id = get_primary_node_id(local_conn);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (monitoring_state == MS_DEGRADED)\n\t\t{\n\t\t\tdegraded_monitoring_elapsed = calculate_elapsed(degraded_monitoring_start);\n\n\t\t\tif (config_file_options.degraded_monitoring_timeout > 0\n\t\t\t\t&& degraded_monitoring_elapsed > config_file_options.degraded_monitoring_timeout)\n\t\t\t{\n\t\t\t\tPQExpBufferData event_details;\n\n\t\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t  _(\"degraded monitoring timeout (%i seconds) exceeded, terminating\"),\n\t\t\t\t\t\t\t\t  degraded_monitoring_elapsed);\n\n\t\t\t\tlog_notice(\"%s\", event_details.data);\n\n\t\t\t\tcreate_event_notification(NULL,\n\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t  \"repmgrd_shutdown\",\n\t\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\t\ttermPQExpBuffer(&event_details);\n\t\t\t\tterminate(ERR_MONITORING_TIMEOUT);\n\t\t\t}\n\n\t\t\tlog_debug(\"monitoring upstream node %i in degraded state for %i seconds\",\n\t\t\t\t\t  upstream_node_info.node_id,\n\t\t\t\t\t  degraded_monitoring_elapsed);\n\n\n\t\t\tif (upstream_node_info.type == PRIMARY)\n\t\t\t{\n\t\t\t\tupstream_check_result = check_upstream_connection(&upstream_conn, upstream_node_info.conninfo, &primary_conn);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tupstream_check_result = check_upstream_connection(&upstream_conn, upstream_node_info.conninfo, NULL);\n\t\t\t}\n\n\t\t\tif (upstream_check_result == true)\n\t\t\t{\n\t\t\t\tif (config_file_options.connection_check_type != CHECK_QUERY)\n\t\t\t\t{\n\t\t\t\t\tclose_connection(&upstream_conn);\n\t\t\t\t\tupstream_conn = establish_db_connection(upstream_node_info.conninfo, false);\n\t\t\t\t}\n\n\t\t\t\tif (PQstatus(upstream_conn) == CONNECTION_OK)\n\t\t\t\t{\n\t\t\t\t\tPQExpBufferData event_details;\n\n\t\t\t\t\tlog_debug(\"upstream node %i has recovered\",\n\t\t\t\t\t\t\t  upstream_node_info.node_id);\n\n\t\t\t\t\t/* XXX check here if upstream is still primary */\n\t\t\t\t\t/*\n\t\t\t\t\t * -> will be a problem if another node was promoted in\n\t\t\t\t\t * the meantime\n\t\t\t\t\t */\n\t\t\t\t\t/* and upstream is now former primary */\n\t\t\t\t\t/* XXX scan other nodes to see if any has become primary */\n\n\t\t\t\t\tupstream_node_info.node_status = NODE_STATUS_UP;\n\t\t\t\t\tmonitoring_state = MS_NORMAL;\n\n\t\t\t\t\tif (upstream_node_info.type == PRIMARY)\n\t\t\t\t\t{\n\t\t\t\t\t\tprimary_conn = upstream_conn;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (primary_conn != NULL && PQstatus(primary_conn) != CONNECTION_OK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tclose_connection(&primary_conn);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (primary_conn == NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprimary_conn = establish_primary_db_connection(upstream_conn, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t\t  _(\"reconnected to upstream node \\\"%s\\\" (ID: %i) after %i seconds, resuming monitoring\"),\n\t\t\t\t\t\t\t\t\t  upstream_node_info.node_name,\n\t\t\t\t\t\t\t\t\t  upstream_node_info.node_id,\n\t\t\t\t\t\t\t\t\t  degraded_monitoring_elapsed);\n\n\t\t\t\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t\t  \"repmgrd_upstream_reconnect\",\n\t\t\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\t\t\tlog_notice(\"%s\", event_details.data);\n\t\t\t\t\ttermPQExpBuffer(&event_details);\n\n\t\t\t\t\tgoto loop;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * unable to connect to former primary - check if another node\n\t\t\t\t * has been promoted\n\t\t\t\t */\n\n\t\t\t\t/* local node has been promoted */\n\t\t\t\tif (get_recovery_type(local_conn) == RECTYPE_PRIMARY)\n\t\t\t\t{\n\t\t\t\t\tlog_notice(_(\"local node is primary, checking local node state\"));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * It's possible the promote command timed out, but the promotion itself\n\t\t\t\t\t * succeeded. In this case failover state will be FAILOVER_STATE_PROMOTION_FAILED;\n\t\t\t\t\t * we can update the node record ourselves and resume primary monitoring.\n\t\t\t\t\t */\n\t\t\t\t\tif (failover_state == FAILOVER_STATE_PROMOTION_FAILED)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tformer_upstream_node_id = local_node_info.upstream_node_id;\n\t\t\t\t\t\tNodeInfoList sibling_nodes = T_NODE_INFO_LIST_INITIALIZER;\n\t\t\t\t\t\tPQExpBufferData event_details;\n\t\t\t\t\t\tt_event_info event_info = T_EVENT_INFO_INITIALIZER;\n\n\t\t\t\t\t\tupdate_node_record_set_primary(local_conn,  local_node_info.node_id);\n\t\t\t\t\t\trecord_status = get_node_record(local_conn, local_node_info.node_id, &local_node_info);\n\n\t\t\t\t\t\tdegraded_monitoring_elapsed = calculate_elapsed(degraded_monitoring_start);\n\n\t\t\t\t\t\tlog_notice(_(\"resuming monitoring as primary node after %i seconds\"),\n\t\t\t\t\t\t\t\t   degraded_monitoring_elapsed);\n\n\t\t\t\t\t\tinitPQExpBuffer(&event_details);\n\t\t\t\t\t\tappendPQExpBufferStr(&event_details,\n\t\t\t\t\t\t\t\t\t\t\t _(\"promotion command failed but promotion completed successfully\"));\n\n\t\t\t\t\t\tevent_info.node_id = former_upstream_node_id;\n\n\t\t\t\t\t\tcreate_event_notification_extended(local_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &config_file_options,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   local_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \"repmgrd_failover_promote\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   true,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   event_details.data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &event_info);\n\n\t\t\t\t\t\ttermPQExpBuffer(&event_details);\n\n\t\t\t\t\t\t/* notify former siblings that they should now follow this node */\n\t\t\t\t\t\tget_active_sibling_node_records(local_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlocal_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tformer_upstream_node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&sibling_nodes);\n\t\t\t\t\t\tnotify_followers(&sibling_nodes, local_node_info.node_id);\n\n\t\t\t\t\t\tclear_node_info_list(&sibling_nodes);\n\n\t\t\t\t\t\t/* this will restart monitoring in primary mode */\n\t\t\t\t\t\tmonitoring_state = MS_NORMAL;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * There may be a delay between the node being promoted\n\t\t\t\t\t * and the local record being updated, so if the node\n\t\t\t\t\t * record still shows it as a standby, do nothing, we'll\n\t\t\t\t\t * catch the update during the next loop. (e.g. node was\n\t\t\t\t\t * manually promoted) we'll do nothing, as the repmgr\n\t\t\t\t\t * metadata is now out-of-sync. If it does get fixed,\n\t\t\t\t\t * we'll catch it here on a future iteration.\n\t\t\t\t\t */\n\n\t\t\t\t\t/* refresh own internal node record */\n\t\t\t\t\trecord_status = refresh_node_record(local_conn, local_node_info.node_id, &local_node_info);\n\n\t\t\t\t\tif (local_node_info.type == PRIMARY)\n\t\t\t\t\t{\n\t\t\t\t\t\tdegraded_monitoring_elapsed = calculate_elapsed(degraded_monitoring_start);\n\n\t\t\t\t\t\tlog_notice(_(\"resuming monitoring as primary node after %i seconds\"),\n\t\t\t\t\t\t\t\t   degraded_monitoring_elapsed);\n\n\t\t\t\t\t\t/* this will restart monitoring in primary mode */\n\t\t\t\t\t\tmonitoring_state = MS_NORMAL;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tif (config_file_options.failover == FAILOVER_AUTOMATIC && repmgrd_is_paused(local_conn) == false)\n\t\t\t\t{\n\t\t\t\t\tNodeInfoList sibling_nodes = T_NODE_INFO_LIST_INITIALIZER;\n\n\t\t\t\t\tget_active_sibling_node_records(local_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlocal_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlocal_node_info.upstream_node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&sibling_nodes);\n\n\t\t\t\t\tif (sibling_nodes.node_count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tNodeInfoListCell *cell;\n\t\t\t\t\t\tt_node_info *follow_node_info = NULL;\n\n\t\t\t\t\t\tlog_debug(\"scanning %i node records to detect new primary...\", sibling_nodes.node_count);\n\t\t\t\t\t\tfor (cell = sibling_nodes.head; cell; cell = cell->next)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* skip local node check, we did that above */\n\t\t\t\t\t\t\tif (cell->node_info->node_id == local_node_info.node_id)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* skip witness node - we can't possibly \"follow\" that */\n\n\t\t\t\t\t\t\tif (cell->node_info->type == WITNESS)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcell->node_info->conn = establish_db_connection(cell->node_info->conninfo, false);\n\n\t\t\t\t\t\t\tif (PQstatus(cell->node_info->conn) != CONNECTION_OK)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tclose_connection(&cell->node_info->conn);\n\t\t\t\t\t\t\t\tlog_debug(\"unable to connect to %i ... \", cell->node_info->node_id);\n\t\t\t\t\t\t\t\tclose_connection(&cell->node_info->conn);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (get_recovery_type(cell->node_info->conn) == RECTYPE_PRIMARY)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfollow_node_info = cell->node_info;\n\t\t\t\t\t\t\t\tclose_connection(&cell->node_info->conn);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tclose_connection(&cell->node_info->conn);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (follow_node_info != NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog_info(_(\"node \\\"%s\\\" (node ID: %i) detected as primary\"),\n\t\t\t\t\t\t\t\t\t follow_node_info->node_name,\n\t\t\t\t\t\t\t\t\t follow_node_info->node_id);\n\t\t\t\t\t\t\tfollow_new_primary(follow_node_info->node_id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tclear_node_info_list(&sibling_nodes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nloop:\n\n\t\t/* emit \"still alive\" log message at regular intervals, if requested */\n\t\tif (config_file_options.log_status_interval > 0)\n\t\t{\n\t\t\tint\t\t\tlog_status_interval_elapsed = calculate_elapsed(log_status_interval_start);\n\n\t\t\tif (log_status_interval_elapsed >= config_file_options.log_status_interval)\n\t\t\t{\n\t\t\t\tPQExpBufferData monitoring_summary;\n\n\t\t\t\tinitPQExpBuffer(&monitoring_summary);\n\n\t\t\t\tappendPQExpBuffer(&monitoring_summary,\n\t\t\t\t\t\t\t\t  _(\"node \\\"%s\\\" (ID: %i) monitoring upstream node \\\"%s\\\" (ID: %i) in %s state\"),\n\t\t\t\t\t\t\t\t  local_node_info.node_name,\n\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t  upstream_node_info.node_name,\n\t\t\t\t\t\t\t\t  upstream_node_info.node_id,\n\t\t\t\t\t\t\t\t  print_monitoring_state(monitoring_state));\n\n\t\t\t\tif (config_file_options.failover == FAILOVER_MANUAL)\n\t\t\t\t{\n\t\t\t\t\tappendPQExpBufferStr(&monitoring_summary,\n\t\t\t\t\t\t\t\t\t\t _(\" (automatic failover disabled)\"));\n\t\t\t\t}\n\n\t\t\t\tlog_info(\"%s\", monitoring_summary.data);\n\t\t\t\ttermPQExpBuffer(&monitoring_summary);\n\n\t\t\t\tif (monitoring_state == MS_DEGRADED && config_file_options.failover == FAILOVER_AUTOMATIC)\n\t\t\t\t{\n\t\t\t\t\tif (PQstatus(local_conn) == CONNECTION_OK && repmgrd_is_paused(local_conn))\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_detail(_(\"repmgrd paused by administrator\"));\n\t\t\t\t\t\tlog_hint(_(\"execute \\\"repmgr service unpause\\\" to resume normal failover mode\"));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_detail(_(\"waiting for upstream or another primary to reappear\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Add update about monitoring updates.\n\t\t\t\t *\n\t\t\t\t * Note: with cascaded replication, it's possible we're still able to write\n\t\t\t\t * monitoring history to the primary even if the upstream is still reachable.\n\t\t\t\t */\n\n\t\t\t\tif (PQstatus(primary_conn) == CONNECTION_OK && config_file_options.monitoring_history == true)\n\t\t\t\t{\n\t\t\t\t\tif (INSTR_TIME_IS_ZERO(last_monitoring_update))\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_detail(_(\"no monitoring statistics have been written yet\"));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_detail(_(\"last monitoring statistics update was %i seconds ago\"),\n\t\t\t\t\t\t\t\t   calculate_elapsed(last_monitoring_update));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tINSTR_TIME_SET_CURRENT(log_status_interval_start);\n\t\t\t}\n\t\t}\n\n\t\tif (PQstatus(primary_conn) == CONNECTION_OK && config_file_options.monitoring_history == true)\n\t\t{\n\t\t\tbool success = update_monitoring_history();\n\n\t\t\tif (success == false && PQstatus(primary_conn) != CONNECTION_OK && upstream_node_info.type == STANDBY)\n\t\t\t{\n\t\t\t\tprimary_conn = establish_primary_db_connection(local_conn, false);\n\n\t\t\t\tif (PQstatus(primary_conn) == CONNECTION_OK)\n\t\t\t\t{\n\t\t\t\t\t(void)update_monitoring_history();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (config_file_options.monitoring_history == true)\n\t\t\t{\n\t\t\t\tlog_verbose(LOG_WARNING, _(\"monitoring_history requested but primary connection not available\"));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * if monitoring not in use, we'll need to ensure the local connection\n\t\t\t * handle isn't stale\n\t\t\t */\n\t\t\t(void) connection_ping(local_conn);\n\t\t}\n\n\t\t/*\n\t\t * handle local node failure\n\t\t *\n\t\t * currently we'll just check the connection, and try to reconnect\n\t\t *\n\t\t * TODO: add timeout, after which we run in degraded state\n\t\t */\n\n\t\tcheck_connection(&local_node_info, &local_conn);\n\n\t\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t\t{\n\t\t\tif (local_node_info.active == true)\n\t\t\t{\n\t\t\t\tbool success = true;\n\t\t\t\tPQExpBufferData event_details;\n\n\t\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\t\tlocal_node_info.active = false;\n\n\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t  _(\"unable to connect to local node \\\"%s\\\" (ID: %i), marking inactive\"),\n\t\t\t\t\t\t\t\t  local_node_info.node_name,\n\t\t\t\t\t\t\t\t  local_node_info.node_id);\n\t\t\t\tlog_notice(\"%s\", event_details.data);\n\n\t\t\t\tif (PQstatus(primary_conn) == CONNECTION_OK)\n\t\t\t\t{\n\t\t\t\t\tif (update_node_record_set_active(primary_conn, local_node_info.node_id, false) == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\tlog_warning(_(\"unable to mark node \\\"%s\\\" (ID: %i) as inactive\"),\n\t\t\t\t\t\t\t\t\t  local_node_info.node_name,\n\t\t\t\t\t\t\t\t\t  local_node_info.node_id);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t  \"standby_failure\",\n\t\t\t\t\t\t\t\t\t\t  success,\n\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\t\ttermPQExpBuffer(&event_details);\n\t\t\t}\n\n\t\t\tif (local_monitoring_state == MS_NORMAL)\n\t\t\t{\n\t\t\t\tlog_info(\"entering degraded monitoring for the local node\");\n\t\t\t\tlocal_monitoring_state = MS_DEGRADED;\n\t\t\t\tINSTR_TIME_SET_CURRENT(local_degraded_monitoring_start);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint stored_local_node_id = UNKNOWN_NODE_ID;\n\n\t\t\tif (local_monitoring_state == MS_DEGRADED)\n\t\t\t{\n\t\t\t\tlog_info(_(\"connection to local node recovered after %i seconds\"),\n\t\t\t\t\t\t calculate_elapsed(local_degraded_monitoring_start));\n\t\t\t\tlocal_monitoring_state = MS_NORMAL;\n\n\t\t\t\t/*\n\t\t\t\t * Check if anything has changed since the local node came back on line;\n\t\t\t\t * we may need to restart monitoring.\n\t\t\t\t */\n\t\t\t\trefresh_node_record(local_conn, local_node_info.node_id, &local_node_info);\n\n\t\t\t\tif (last_known_upstream_node_id != local_node_info.upstream_node_id)\n\t\t\t\t{\n\t\t\t\t\tlog_notice(_(\"upstream for local node \\\"%s\\\" (ID: %i) appears to have changed, restarting monitoring\"),\n\t\t\t\t\t\t\t   local_node_info.node_name,\n\t\t\t\t\t\t\t   local_node_info.node_id);\n\t\t\t\t\tlog_detail(_(\"currently monitoring upstream %i; new upstream is %i\"),\n\t\t\t\t\t\t\t   last_known_upstream_node_id,\n\t\t\t\t\t\t\t   local_node_info.upstream_node_id);\n\t\t\t\t\tclose_connection(&upstream_conn);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tif (local_node_info.type != STANDBY)\n\t\t\t\t{\n\t\t\t\t\tlog_notice(_(\"local node \\\"%s\\\" (ID: %i) is no longer a standby, restarting monitoring\"),\n\t\t\t\t\t\t\t   local_node_info.node_name,\n\t\t\t\t\t\t\t   local_node_info.node_id);\n\t\t\t\t\tclose_connection(&upstream_conn);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the local node was restarted, we'll need to reinitialise values\n\t\t\t * stored in shared memory.\n\t\t\t */\n\t\t\tstored_local_node_id = repmgrd_get_local_node_id(local_conn);\n\n\t\t\tif (stored_local_node_id == UNKNOWN_NODE_ID)\n\t\t\t{\n\t\t\t\trepmgrd_set_local_node_id(local_conn, config_file_options.node_id);\n\t\t\t\trepmgrd_set_pid(local_conn, getpid(), pid_file);\n\t\t\t}\n\n\t\t\tif (PQstatus(primary_conn) == CONNECTION_OK)\n\t\t\t{\n\t\t\t\tif (get_recovery_type(primary_conn) == RECTYPE_STANDBY)\n\t\t\t\t{\n\t\t\t\t\tlog_notice(_(\"current upstream node \\\"%s\\\" (ID: %i) is not primary, restarting monitoring\"),\n\t\t\t\t\t\t\t   upstream_node_info.node_name, upstream_node_info.node_id);\n\n\t\t\t\t\tclose_connection(&primary_conn);\n\n\t\t\t\t\tlocal_node_info.upstream_node_id = UNKNOWN_NODE_ID;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* we've reconnected to the local node after an outage */\n\t\t\tif (local_node_info.active == false)\n\t\t\t{\n\t\t\t\tif (PQstatus(primary_conn) == CONNECTION_OK)\n\t\t\t\t{\n\t\t\t\t\tif (update_node_record_set_active(primary_conn, local_node_info.node_id, true) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tPQExpBufferData event_details;\n\n\t\t\t\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\t\t\t\tlocal_node_info.active = true;\n\t\t\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t\t\t  _(\"reconnected to local node \\\"%s\\\" (ID: %i), marking active\"),\n\t\t\t\t\t\t\t\t\t\t  local_node_info.node_name,\n\t\t\t\t\t\t\t\t\t\t  local_node_info.node_id);\n\n\t\t\t\t\t\tlog_notice(\"%s\", event_details.data);\n\n\t\t\t\t\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"standby_recovery\",\n\t\t\t\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\t\t\t\ttermPQExpBuffer(&event_details);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (got_SIGHUP)\n\t\t{\n\t\t\thandle_sighup(&local_conn, STANDBY);\n\t\t}\n\n\t\trefresh_node_record(local_conn, local_node_info.node_id, &local_node_info);\n\n\t\tif (local_monitoring_state == MS_NORMAL && last_known_upstream_node_id != local_node_info.upstream_node_id)\n\t\t{\n\t\t\t/*\n\t\t\t * It's possible that after a change of upstream, the local node record will not\n\t\t\t * yet have been updated with the new upstream node ID. Therefore we check the\n\t\t\t * node record on the upstream, and if that matches \"last_known_upstream_node_id\",\n\t\t\t * take that as the correct value.\n\t\t\t */\n\n\t\t\tif (monitoring_state == MS_NORMAL)\n\t\t\t{\n\t\t\t\tt_node_info node_info_on_upstream = T_NODE_INFO_INITIALIZER;\n\t\t\t\trecord_status = get_node_record(primary_conn, config_file_options.node_id, &node_info_on_upstream);\n\n\t\t\t\tif (last_known_upstream_node_id == node_info_on_upstream.upstream_node_id)\n\t\t\t\t{\n\t\t\t\t\tlocal_node_info.upstream_node_id = last_known_upstream_node_id;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (last_known_upstream_node_id != local_node_info.upstream_node_id)\n\t\t\t{\n\t\t\t\tlog_notice(_(\"local node \\\"%s\\\" (ID: %i)'s upstream appears to have changed, restarting monitoring\"),\n\t\t\t\t\t\t   local_node_info.node_name,\n\t\t\t\t\t\t   local_node_info.node_id);\n\t\t\t\tlog_detail(_(\"currently monitoring upstream %i; new upstream is %i\"),\n\t\t\t\t\t\t   last_known_upstream_node_id,\n\t\t\t\t\t\t   local_node_info.upstream_node_id);\n\t\t\t\tclose_connection(&upstream_conn);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tlog_verbose(LOG_DEBUG, \"sleeping %i seconds (parameter \\\"monitor_interval_secs\\\")\",\n\t\t\t\t\tconfig_file_options.monitor_interval_secs);\n\n\n\t\tsleep(config_file_options.monitor_interval_secs);\n\t}\n}\n\n\nvoid\nmonitor_streaming_witness(void)\n{\n\tinstr_time\tlog_status_interval_start;\n\tinstr_time\twitness_sync_interval_start;\n\n\tRecordStatus record_status;\n\n\tint primary_node_id = UNKNOWN_NODE_ID;\n\n\treset_node_voting_status();\n\n\tlog_debug(\"monitor_streaming_witness()\");\n\n\t/*\n\t * At this point we can't trust the local copy of \"repmgr.nodes\", as\n\t * it may not have been updated. We'll scan the cluster to find the\n\t * current primary and refresh the copy from that before proceeding\n\t * further.\n\t */\n\tprimary_conn = get_primary_connection_quiet(local_conn, &primary_node_id, NULL);\n\n\t/*\n\t * Primary node should be running at repmgrd startup.\n\t *\n\t * Otherwise we'll skip to degraded monitoring.\n\t */\n\tif (PQstatus(primary_conn) == CONNECTION_OK)\n\t{\n\t\tPQExpBufferData event_details;\n\n\t\tchar *event_type = startup_event_logged == false\n\t\t\t? \"repmgrd_start\"\n\t\t\t: \"repmgrd_upstream_reconnect\";\n\n\t\t/* synchronise local copy of \"repmgr.nodes\", in case it was stale */\n\t\twitness_copy_node_records(primary_conn, local_conn);\n\n\t\t/*\n\t\t * refresh upstream node record from primary, so it's as up-to-date\n\t\t * as possible\n\t\t */\n\t\trecord_status = get_node_record(primary_conn, primary_node_id, &upstream_node_info);\n\n\t\t/*\n\t\t * This is unlikely to happen; if it does emit a warning for diagnostic\n\t\t * purposes and plough on regardless.\n\t\t *\n\t\t * A check for the existence of the record will have already been carried out\n\t\t * in main().\n\t\t */\n\t\tif (record_status != RECORD_FOUND)\n\t\t{\n\t\t\tlog_warning(_(\"unable to retrieve node record from primary\"));\n\t\t}\n\n\t\t/* refresh local node record from the primary */\n\t\trecord_status = get_node_record(primary_conn, config_file_options.node_id, &local_node_info);\n\n\t\tif (record_status != RECORD_FOUND)\n\t\t{\n\t\t\tlog_error(_(\"no metadata record found for this node on the current primary - terminating\"));\n\t\t\tlog_hint(_(\"check that 'repmgr witness register' was executed for this node\"));\n\t\t\tclose_connection(&primary_conn);\n\t\t\tclose_connection(&local_conn);\n\t\t\tterminate(ERR_BAD_CONFIG);\n\t\t}\n\n\t\t/*\n\t\t * It's possible that the primary changed while the witness repmgrd was not\n\t\t * running. This does not affect the functionality of the witness repmgrd, but\n\t\t * does mean outdated node metadata will be displayed, so update that.\n\t\t */\n\t\tif (local_node_info.upstream_node_id != primary_node_id)\n\t\t{\n\t\t\tupdate_node_record_set_upstream(primary_conn, local_node_info.node_id, primary_node_id);\n\t\t\tlocal_node_info.upstream_node_id = primary_node_id;\n\t\t}\n\n\t\tinitPQExpBuffer(&event_details);\n\n\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t  _(\"witness monitoring connection to primary node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t  upstream_node_info.node_name,\n\t\t\t\t\t\t  upstream_node_info.node_id);\n\n\t\tlog_info(\"%s\", event_details.data);\n\n\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t  event_type,\n\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\tif (startup_event_logged == false)\n\t\t\tstartup_event_logged = true;\n\n\t\ttermPQExpBuffer(&event_details);\n\n\t\tmonitoring_state = MS_NORMAL;\n\t\tINSTR_TIME_SET_CURRENT(log_status_interval_start);\n\t\tINSTR_TIME_SET_CURRENT(witness_sync_interval_start);\n\n\t\tupstream_node_info.node_status = NODE_STATUS_UP;\n\t}\n\telse\n\t{\n\t\tlog_warning(_(\"unable to connect to primary\"));\n\t\tlog_detail(\"\\n%s\", PQerrorMessage(primary_conn));\n\n\t\t/*\n\t\t * Here we're unable to connect to a primary despite having scanned all\n\t\t * known nodes, so we'll grab the record of the node we think is primary\n\t\t * and continue straight to degraded monitoring in the hope a primary\n\t\t * will appear.\n\t\t */\n\n\t\tprimary_node_id = get_primary_node_id(local_conn);\n\n\t\tlog_notice(_(\"setting primary_node_id to last known ID %i\"), primary_node_id);\n\n\t\trecord_status = get_node_record(local_conn, primary_node_id, &upstream_node_info);\n\n\t\t/*\n\t\t * This is unlikely to happen, but if for whatever reason there's\n\t\t * no primary record in the local table, we should just give up\n\t\t */\n\t\tif (record_status != RECORD_FOUND)\n\t\t{\n\t\t\tlog_error(_(\"unable to retrieve node record for last known primary %i\"),\n\t\t\t\t\t\tprimary_node_id);\n\t\t\tlog_hint(_(\"execute \\\"repmgr witness register --force\\\" to sync the local node records\"));\n\t\t\tPQfinish(local_conn);\n\t\t\tterminate(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tmonitoring_state = MS_DEGRADED;\n\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\t\tupstream_node_info.node_status = NODE_STATUS_DOWN;\n\t}\n\n\twhile (true)\n\t{\n\t\tif (check_upstream_connection(&primary_conn, upstream_node_info.conninfo, NULL) == true)\n\t\t{\n\t\t\tset_upstream_last_seen(local_conn, upstream_node_info.node_id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (upstream_node_info.node_status == NODE_STATUS_UP)\n\t\t\t{\n\t\t\t\tinstr_time\t\tupstream_node_unreachable_start;\n\n\t\t\t\tINSTR_TIME_SET_CURRENT(upstream_node_unreachable_start);\n\n\t\t\t\tupstream_node_info.node_status = NODE_STATUS_UNKNOWN;\n\n\t\t\t\t{\n\t\t\t\t\tPQExpBufferData event_details;\n\n\t\t\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t\t  _(\"unable to connect to primary node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t\t\t  upstream_node_info.node_name, upstream_node_info.node_id);\n\n\t\t\t\t\tcreate_event_notification(NULL,\n\t\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t\t  \"repmgrd_upstream_disconnect\",\n\t\t\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\t\t\t\t\ttermPQExpBuffer(&event_details);\n\t\t\t\t}\n\n\t\t\t\ttry_reconnect(&primary_conn, &upstream_node_info);\n\n\t\t\t\t/* Node has recovered - log and continue */\n\t\t\t\tif (upstream_node_info.node_status == NODE_STATUS_UP)\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tupstream_node_unreachable_elapsed = calculate_elapsed(upstream_node_unreachable_start);\n\t\t\t\t\tPQExpBufferData event_details;\n\n\t\t\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t\t  _(\"reconnected to upstream node after %i seconds\"),\n\t\t\t\t\t\t\t\t\t  upstream_node_unreachable_elapsed);\n\t\t\t\t\tlog_notice(\"%s\", event_details.data);\n\n\t\t\t\t\t/* check upstream is still primary */\n\t\t\t\t\tif (get_recovery_type(primary_conn) != RECTYPE_PRIMARY)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_notice(_(\"current upstream node \\\"%s\\\" (ID: %i) is not primary, restarting monitoring\"),\n\t\t\t\t\t\t\t\t   upstream_node_info.node_name, upstream_node_info.node_id);\n\n\t\t\t\t\t\tclose_connection(&primary_conn);\n\n\t\t\t\t\t\ttermPQExpBuffer(&event_details);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t\t  \"repmgrd_upstream_reconnect\",\n\t\t\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\t\t\t\t\ttermPQExpBuffer(&event_details);\n\n\t\t\t\t\tgoto loop;\n\t\t\t\t}\n\n\t\t\t\t/* still down after reconnect attempt(s) */\n\t\t\t\tif (upstream_node_info.node_status == NODE_STATUS_DOWN)\n\t\t\t\t{\n\t\t\t\t\tbool\t\tfailover_done = false;\n\n\n\t\t\t\t\tfailover_done = do_witness_failover();\n\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX it's possible it will make sense to return in all\n\t\t\t\t\t * cases to restart monitoring\n\t\t\t\t\t */\n\t\t\t\t\tif (failover_done == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tprimary_node_id = get_primary_node_id(local_conn);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif (monitoring_state == MS_DEGRADED)\n\t\t{\n\t\t\tint\t\t\tdegraded_monitoring_elapsed = calculate_elapsed(degraded_monitoring_start);\n\n\t\t\tlog_debug(\"monitoring node %i in degraded state for %i seconds\",\n\t\t\t\t\t  upstream_node_info.node_id,\n\t\t\t\t\t  degraded_monitoring_elapsed);\n\n\t\t\tif (check_upstream_connection(&primary_conn, upstream_node_info.conninfo, NULL) == true)\n\t\t\t{\n\t\t\t\tif (config_file_options.connection_check_type != CHECK_QUERY)\n\t\t\t\t{\n\t\t\t\t\tclose_connection(&primary_conn);\n\t\t\t\t\tprimary_conn = establish_db_connection(upstream_node_info.conninfo, false);\n\t\t\t\t}\n\t\t\t\tif (PQstatus(primary_conn) == CONNECTION_OK)\n\t\t\t\t{\n\t\t\t\t\tPQExpBufferData event_details;\n\n\t\t\t\t\tupstream_node_info.node_status = NODE_STATUS_UP;\n\t\t\t\t\tmonitoring_state = MS_NORMAL;\n\n\t\t\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t\t  _(\"reconnected to upstream node \\\"%s\\\" (ID: %i) after %i seconds, resuming monitoring\"),\n\t\t\t\t\t\t\t\t\t  upstream_node_info.node_name,\n\t\t\t\t\t\t\t\t\t  upstream_node_info.node_id,\n\t\t\t\t\t\t\t\t\t  degraded_monitoring_elapsed);\n\n\t\t\t\t\tlog_notice(\"%s\", event_details.data);\n\n\t\t\t\t\t/* check upstream is still primary */\n\t\t\t\t\tif (get_recovery_type(primary_conn) != RECTYPE_PRIMARY)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_notice(_(\"current upstream node \\\"%s\\\" (ID: %i) is not primary, restarting monitoring\"),\n\t\t\t\t\t\t\t\t   upstream_node_info.node_name,\n\t\t\t\t\t\t\t\t   upstream_node_info.node_id);\n\n\t\t\t\t\t\tclose_connection(&primary_conn);\n\n\t\t\t\t\t\ttermPQExpBuffer(&event_details);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t\t  config_file_options.node_id,\n\t\t\t\t\t\t\t\t\t\t\t  \"repmgrd_upstream_reconnect\",\n\t\t\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\t\t\t\t\ttermPQExpBuffer(&event_details);\n\n\t\t\t\t\tgoto loop;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * unable to connect to former primary - check if another node\n\t\t\t\t * has been promoted\n\t\t\t\t */\n\n\t\t\t\tNodeInfoList sibling_nodes = T_NODE_INFO_LIST_INITIALIZER;\n\n\t\t\t\tget_active_sibling_node_records(local_conn,\n\t\t\t\t\t\t\t\t\t\t\t\tlocal_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t\t\tlocal_node_info.upstream_node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t&sibling_nodes);\n\n\t\t\t\tif (sibling_nodes.node_count > 0)\n\t\t\t\t{\n\t\t\t\t\tNodeInfoListCell *cell;\n\t\t\t\t\tt_node_info *follow_node_info = NULL;\n\n\t\t\t\t\tlog_debug(\"scanning %i node records to detect new primary...\", sibling_nodes.node_count);\n\t\t\t\t\tfor (cell = sibling_nodes.head; cell; cell = cell->next)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* skip local node check, we did that above */\n\t\t\t\t\t\tif (cell->node_info->node_id == local_node_info.node_id)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* skip node if configured as a witness node - we can't possibly \"follow\" that */\n\t\t\t\t\t\tif (cell->node_info->type == WITNESS)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcell->node_info->conn = establish_db_connection(cell->node_info->conninfo, false);\n\n\t\t\t\t\t\tif (PQstatus(cell->node_info->conn) != CONNECTION_OK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tclose_connection(&cell->node_info->conn);\n\t\t\t\t\t\t\tlog_debug(\"unable to connect to %i ... \", cell->node_info->node_id);\n\t\t\t\t\t\t\tclose_connection(&cell->node_info->conn);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (get_recovery_type(cell->node_info->conn) == RECTYPE_PRIMARY)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfollow_node_info = cell->node_info;\n\t\t\t\t\t\t\tclose_connection(&cell->node_info->conn);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclose_connection(&cell->node_info->conn);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (follow_node_info != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_info(_(\"node \\\"%s\\\" (node ID: %i) detected as primary\"),\n\t\t\t\t\t\t\t\t follow_node_info->node_name,\n\t\t\t\t\t\t\t\t follow_node_info->node_id);\n\t\t\t\t\t\twitness_follow_new_primary(follow_node_info->node_id);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclear_node_info_list(&sibling_nodes);\n\t\t\t}\n\t\t}\nloop:\n\n\t\t/*\n\t\t * handle local node failure\n\t\t *\n\t\t * currently we'll just check the connection, and try to reconnect\n\t\t *\n\t\t * TODO: add timeout, after which we run in degraded state\n\t\t */\n\n\t\t(void) connection_ping(local_conn);\n\n\t\tcheck_connection(&local_node_info, &local_conn);\n\n\t\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t\t{\n\t\t\tif (local_node_info.active == true)\n\t\t\t{\n\t\t\t\tbool success = true;\n\t\t\t\tPQExpBufferData event_details;\n\n\t\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\t\tlocal_node_info.active = false;\n\n\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t  _(\"unable to connect to local node \\\"%s\\\" (ID: %i), marking inactive\"),\n\t\t\t\t\t\t\t\t  local_node_info.node_name,\n\t\t\t\t\t\t\t\t  local_node_info.node_id);\n\t\t\t\tlog_notice(\"%s\", event_details.data);\n\n\t\t\t\tif (PQstatus(primary_conn) == CONNECTION_OK)\n\t\t\t\t{\n\t\t\t\t\tif (update_node_record_set_active(primary_conn, local_node_info.node_id, false) == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\tlog_warning(_(\"unable to mark node \\\"%s\\\" (ID: %i) as inactive\"),\n\t\t\t\t\t\t\t\t\t  local_node_info.node_name,\n\t\t\t\t\t\t\t\t\t  local_node_info.node_id);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t  \"standby_failure\",\n\t\t\t\t\t\t\t\t\t\t  success,\n\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\t\ttermPQExpBuffer(&event_details);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* we've reconnected to the local node after an outage */\n\t\t\tif (local_node_info.active == false)\n\t\t\t{\n\t\t\t\tint stored_local_node_id = UNKNOWN_NODE_ID;\n\n\t\t\t\tif (PQstatus(primary_conn) == CONNECTION_OK)\n\t\t\t\t{\n\t\t\t\t\tif (update_node_record_set_active(primary_conn, local_node_info.node_id, true) == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tPQExpBufferData event_details;\n\n\t\t\t\t\t\tinitPQExpBuffer(&event_details);\n\n\t\t\t\t\t\tlocal_node_info.active = true;\n\n\t\t\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t\t\t  _(\"reconnected to local node \\\"%s\\\" (ID: %i), marking active\"),\n\t\t\t\t\t\t\t\t\t\t  local_node_info.node_name,\n\t\t\t\t\t\t\t\t\t\t  local_node_info.node_id);\n\n\t\t\t\t\t\tlog_notice(\"%s\", event_details.data);\n\n\t\t\t\t\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"standby_recovery\",\n\t\t\t\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\t\t\t\ttermPQExpBuffer(&event_details);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * If the local node was restarted, we'll need to reinitialise values\n\t\t\t\t * stored in shared memory.\n\t\t\t\t */\n\n\t\t\t\tstored_local_node_id = repmgrd_get_local_node_id(local_conn);\n\t\t\t\tif (stored_local_node_id == UNKNOWN_NODE_ID)\n\t\t\t\t{\n\t\t\t\t\trepmgrd_set_local_node_id(local_conn, config_file_options.node_id);\n\t\t\t\t\trepmgrd_set_pid(local_conn, getpid(), pid_file);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t/*\n\t\t * Refresh repmgr.nodes after \"witness_sync_interval\" seconds, and check if primary\n\t\t * has changed\n\t\t */\n\n\t\tif (PQstatus(primary_conn) == CONNECTION_OK)\n\t\t{\n\t\t\tint witness_sync_interval_elapsed = calculate_elapsed(witness_sync_interval_start);\n\n\t\t\tif (witness_sync_interval_elapsed >= config_file_options.witness_sync_interval)\n\t\t\t{\n\t\t\t\tif (get_recovery_type(primary_conn) != RECTYPE_PRIMARY)\n\t\t\t\t{\n\t\t\t\t\tlog_notice(_(\"current upstream node \\\"%s\\\" (ID: %i) is not primary, restarting monitoring\"),\n\t\t\t\t\t\t\t   upstream_node_info.node_name, upstream_node_info.node_id);\n\n\t\t\t\t\tclose_connection(&primary_conn);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlog_debug(\"synchronising witness node records\");\n\t\t\t\twitness_copy_node_records(primary_conn, local_conn);\n\n\t\t\t\tINSTR_TIME_SET_CURRENT(witness_sync_interval_start);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_debug(\"seconds since last node record sync: %i (sync interval: %i)\",\n\t\t\t\t\t\t  witness_sync_interval_elapsed,\n\t\t\t\t\t\t  config_file_options.witness_sync_interval)\n\t\t\t}\n\t\t}\n\n\t\t/* emit \"still alive\" log message at regular intervals, if requested */\n\t\tif (config_file_options.log_status_interval > 0)\n\t\t{\n\t\t\tint\t\t\tlog_status_interval_elapsed = calculate_elapsed(log_status_interval_start);\n\n\t\t\tif (log_status_interval_elapsed >= config_file_options.log_status_interval)\n\t\t\t{\n\t\t\t\tPQExpBufferData monitoring_summary;\n\n\t\t\t\tinitPQExpBuffer(&monitoring_summary);\n\n\t\t\t\tappendPQExpBuffer(&monitoring_summary,\n\t\t\t\t\t\t\t\t  _(\"witness node \\\"%s\\\" (ID: %i) monitoring primary node \\\"%s\\\" (ID: %i) in %s state\"),\n\t\t\t\t\t\t\t\t  local_node_info.node_name,\n\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t  upstream_node_info.node_name,\n\t\t\t\t\t\t\t\t  upstream_node_info.node_id,\n\t\t\t\t\t\t\t\t  print_monitoring_state(monitoring_state));\n\n\t\t\t\tlog_info(\"%s\", monitoring_summary.data);\n\t\t\t\ttermPQExpBuffer(&monitoring_summary);\n\t\t\t\tif (monitoring_state == MS_DEGRADED && config_file_options.failover == FAILOVER_AUTOMATIC)\n\t\t\t\t{\n\t\t\t\t\tlog_detail(_(\"waiting for current or new primary to reappear\"));\n\t\t\t\t}\n\n\t\t\t\tINSTR_TIME_SET_CURRENT(log_status_interval_start);\n\t\t\t}\n\t\t}\n\n\n\n\t\tif (got_SIGHUP)\n\t\t{\n\t\t\thandle_sighup(&local_conn, WITNESS);\n\t\t}\n\n\t\tlog_verbose(LOG_DEBUG, \"sleeping %i seconds (parameter \\\"monitor_interval_secs\\\")\",\n\t\t\t\t\tconfig_file_options.monitor_interval_secs);\n\n\t\tsleep(config_file_options.monitor_interval_secs);\n\t}\n\n\treturn;\n}\n\n\nstatic bool\ndo_primary_failover(void)\n{\n\tElectionResult election_result;\n\tbool final_result = false;\n\tNodeInfoList sibling_nodes = T_NODE_INFO_LIST_INITIALIZER;\n\tint new_primary_id = UNKNOWN_NODE_ID;\n\tbool standby_disconnect_on_failover = false;\n\n\t/*\n\t * Double-check status of the local connection\n\t */\n\tcheck_connection(&local_node_info, &local_conn);\n\n\t/*\n\t * if requested, disable WAL receiver and wait until WAL receivers on all\n\t * sibling nodes are disconnected\n\t */\n\tif (config_file_options.standby_disconnect_on_failover == true)\n\t{\n\t\t/*\n\t\t * Determine whether we can actually disable the walsender; this depends\n\t\t * on PostgreSQL version and user permissions.\n\t\t */\n\t\tstandby_disconnect_on_failover = can_disable_walsender(local_conn);\n\n\t\tif (standby_disconnect_on_failover == true)\n\t\t{\n\t\t\tNodeInfoListCell *cell = NULL;\n\t\t\tNodeInfoList check_sibling_nodes = T_NODE_INFO_LIST_INITIALIZER;\n\t\t\tint i;\n\n\t\t\tbool sibling_node_wal_receiver_connected = false;\n\n\t\t\tdisable_wal_receiver(local_conn);\n\n\t\t\t/*\n\t\t\t * Loop through all reachable sibling nodes to determine whether\n\t\t\t * they have disabled their WAL receivers.\n\t\t\t *\n\t\t\t * TODO: do_election() also calls get_active_sibling_node_records(),\n\t\t\t * consolidate calls if feasible\n\t\t\t *\n\t\t\t */\n\t\t\tget_active_sibling_node_records(local_conn,\n\t\t\t\t\t\t\t\t\t\t\tlocal_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t\tlocal_node_info.upstream_node_id,\n\t\t\t\t\t\t\t\t\t\t\t&check_sibling_nodes);\n\n\t\t\tfor (i = 0; i < config_file_options.sibling_nodes_disconnect_timeout; i++)\n\t\t\t{\n\t\t\t\tfor (cell = check_sibling_nodes.head; cell; cell = cell->next)\n\t\t\t\t{\n\t\t\t\t\tif (cell->node_info->conn == NULL)\n\t\t\t\t\t\tcell->node_info->conn = establish_db_connection(cell->node_info->conninfo, false);\n\n\t\t\t\t\tif (PQstatus(cell->node_info->conn) != CONNECTION_OK)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_warning(_(\"unable to query WAL receiver PID on node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\t\t\t\tcell->node_info->node_id);\n\t\t\t\t\t\tclose_connection(&cell->node_info->conn);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpid_t sibling_wal_receiver_pid = (pid_t)get_wal_receiver_pid(cell->node_info->conn);\n\n\t\t\t\t\t\tif (sibling_wal_receiver_pid == UNKNOWN_PID)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog_warning(_(\"unable to query WAL receiver PID on node %i\"),\n\t\t\t\t\t\t\t\t\t\tcell->node_info->node_id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (sibling_wal_receiver_pid > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog_info(_(\"WAL receiver PID on node %i is %i\"),\n\t\t\t\t\t\t\t\t\t cell->node_info->node_id,\n\t\t\t\t\t\t\t\t\t sibling_wal_receiver_pid);\n\t\t\t\t\t\t\tsibling_node_wal_receiver_connected = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (sibling_node_wal_receiver_connected == false)\n\t\t\t\t{\n\t\t\t\t\tlog_notice(_(\"WAL receiver disconnected on all sibling nodes\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlog_debug(\"sleeping %i of max %i seconds (\\\"sibling_nodes_disconnect_timeout\\\")\",\n\t\t\t\t\t\t  i + 1, config_file_options.sibling_nodes_disconnect_timeout);\n\t\t\t\tsleep(1);\n\t\t\t}\n\n\t\t\tif (sibling_node_wal_receiver_connected == true)\n\t\t\t{\n\t\t\t\t/* TODO: prevent any such nodes becoming promotion candidates */\n\t\t\t\tlog_warning(_(\"WAL receiver still connected on at least one sibling node\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_info(_(\"WAL receiver disconnected on all %i sibling nodes\"),\n\t\t\t\t\t\t check_sibling_nodes.node_count);\n\t\t\t}\n\n\t\t\tclear_node_info_list(&check_sibling_nodes);\n\t\t}\n\t}\n\n\t/* attempt to initiate voting process */\n\telection_result = do_election(&sibling_nodes, &new_primary_id);\n\n\t/* TODO add pre-event notification here */\n\tfailover_state = FAILOVER_STATE_UNKNOWN;\n\n\tlog_debug(\"election result: %s\", _print_election_result(election_result));\n\n\t/* Reenable WAL receiver, if disabled */\n\tif (standby_disconnect_on_failover == true)\n\t{\n\t\t/* adjust \"wal_retrieve_retry_interval\" but don't wait for WAL receiver to start */\n\t\tenable_wal_receiver(local_conn, false);\n\t}\n\n\t/* election was cancelled and do_election() did not determine a new primary */\n\tif (election_result == ELECTION_CANCELLED)\n\t{\n\t\tif (new_primary_id == UNKNOWN_NODE_ID)\n\t\t{\n\t\t\tlog_notice(_(\"election cancelled\"));\n\t\t\tclear_node_info_list(&sibling_nodes);\n\t\t\treturn false;\n\t\t}\n\n\t\tlog_info(_(\"follower node intending to follow new primary %i\"), new_primary_id);\n\n\t\tfailover_state = FAILOVER_STATE_FOLLOW_NEW_PRIMARY;\n\t}\n\telse if (election_result == ELECTION_RERUN)\n\t{\n\t\tlog_notice(_(\"promotion candidate election will be rerun\"));\n\t\t/* notify siblings that they should rerun the election too */\n\t\tnotify_followers(&sibling_nodes, ELECTION_RERUN_NOTIFICATION);\n\n\t\tfailover_state = FAILOVER_STATE_ELECTION_RERUN;\n\t}\n\telse if (election_result == ELECTION_WON)\n\t{\n\t\tif (sibling_nodes.node_count > 0)\n\t\t{\n\t\t\tlog_notice(\"this node is the winner, will now promote itself and inform other nodes\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_notice(\"this node is the only available candidate and will now promote itself\");\n\t\t}\n\n\t\tfailover_state = promote_self();\n\t}\n\telse if (election_result == ELECTION_LOST || election_result == ELECTION_NOT_CANDIDATE)\n\t{\n\t\t/*\n\t\t * if the node couldn't be promoted as it's not in the same location as the primary,\n\t\t * add an explanatory notice\n\t\t */\n\t\tif (election_result == ELECTION_NOT_CANDIDATE && strncmp(upstream_node_info.location, local_node_info.location, MAXLEN) != 0)\n\t\t{\n\t\t\tlog_notice(_(\"this node's location (\\\"%s\\\") is not the primary node location (\\\"%s\\\"), so node cannot be promoted\"),\n\t\t\t\t\t   local_node_info.location,\n\t\t\t\t\t   upstream_node_info.location);\n\t\t}\n\n\t\tlog_info(_(\"follower node awaiting notification from a candidate node\"));\n\n\t\tfailover_state = FAILOVER_STATE_WAITING_NEW_PRIMARY;\n\t}\n\n\t/*\n\t * node has determined a new primary is already available\n\t */\n\tif (failover_state == FAILOVER_STATE_FOLLOW_NEW_PRIMARY)\n\t{\n\t\tfailover_state = follow_new_primary(new_primary_id);\n\t}\n\n\t/*\n\t * node has decided it is a follower, so will await notification from the\n\t * candidate that it has promoted itself and can be followed\n\t */\n\telse if (failover_state == FAILOVER_STATE_WAITING_NEW_PRIMARY)\n\t{\n\t\t/* TODO: rerun election if new primary doesn't appear after timeout */\n\n\t\t/* either follow, self-promote or time out; either way resume monitoring */\n\t\tif (wait_primary_notification(&new_primary_id) == true)\n\t\t{\n\t\t\t/* if primary has reappeared, no action needed */\n\t\t\tif (new_primary_id == upstream_node_info.node_id)\n\t\t\t{\n\t\t\t\tfailover_state = FAILOVER_STATE_FOLLOWING_ORIGINAL_PRIMARY;\n\t\t\t}\n\t\t\t/* if new_primary_id is self, promote */\n\t\t\telse if (new_primary_id == local_node_info.node_id)\n\t\t\t{\n\t\t\t\tlog_notice(_(\"this node is promotion candidate, promoting\"));\n\n\t\t\t\tfailover_state = promote_self();\n\n\t\t\t\tget_active_sibling_node_records(local_conn,\n\t\t\t\t\t\t\t\t\t\t\t\tlocal_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t\t\tupstream_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t\t\t&sibling_nodes);\n\n\t\t\t}\n\t\t\t/* election rerun */\n\t\t\telse if (new_primary_id == ELECTION_RERUN_NOTIFICATION)\n\t\t\t{\n\t\t\t\tlog_notice(_(\"received notification from promotion candidate to rerun election\"));\n\t\t\t\tfailover_state = FAILOVER_STATE_ELECTION_RERUN;\n\t\t\t}\n\t\t\telse if (config_file_options.failover == FAILOVER_MANUAL)\n\t\t\t{\n\t\t\t\t/* automatic failover disabled */\n\n\t\t\t\tt_node_info new_primary = T_NODE_INFO_INITIALIZER;\n\t\t\t\tRecordStatus record_status = RECORD_NOT_FOUND;\n\n\t\t\t\trecord_status = get_node_record(local_conn, new_primary_id, &new_primary);\n\n\t\t\t\tif (record_status != RECORD_FOUND)\n\t\t\t\t{\n\t\t\t\t\tlog_error(_(\"unable to retrieve metadata record for new primary node (ID: %i)\"),\n\t\t\t\t\t\t\t  new_primary_id);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tPQExpBufferData event_details;\n\t\t\t\t\tPGconn\t   *new_primary_conn;\n\n\t\t\t\t\tinitPQExpBuffer(&event_details);\n\t\t\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t\t\t  _(\"node \\\"%s\\\" (ID: %i) is in manual failover mode and is now disconnected from streaming replication\"),\n\t\t\t\t\t\t\t\t\t  local_node_info.node_name,\n\t\t\t\t\t\t\t\t\t  local_node_info.node_id);\n\n\t\t\t\t\tnew_primary_conn = establish_db_connection(new_primary.conninfo, false);\n\n\t\t\t\t\tcreate_event_notification(new_primary_conn,\n\t\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t\t  \"standby_disconnect_manual\",\n\t\t\t\t\t\t\t\t\t\t\t  /*\n\t\t\t\t\t\t\t\t\t\t\t   * here \"true\" indicates the action has occurred as expected\n\t\t\t\t\t\t\t\t\t\t\t   */\n\t\t\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\t\t\t\t\tclose_connection(&new_primary_conn);\n\t\t\t\t\ttermPQExpBuffer(&event_details);\n\t\t\t\t}\n\t\t\t\tfailover_state = FAILOVER_STATE_REQUIRES_MANUAL_FAILOVER;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfailover_state = follow_new_primary(new_primary_id);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfailover_state = FAILOVER_STATE_NO_NEW_PRIMARY;\n\t\t}\n\t}\n\n\tlog_verbose(LOG_DEBUG, \"failover state is %s\",\n\t\t\t\tformat_failover_state(failover_state));\n\n\tswitch (failover_state)\n\t{\n\t\tcase FAILOVER_STATE_PROMOTED:\n\t\t\t/* notify former siblings that they should now follow this node */\n\t\t\tnotify_followers(&sibling_nodes, local_node_info.node_id);\n\n\t\t\t/* pass control back down to start_monitoring() */\n\t\t\tlog_info(_(\"switching to primary monitoring mode\"));\n\n\t\t\tfailover_state = FAILOVER_STATE_NONE;\n\n\t\t\tfinal_result = true;\n\n\t\t\tbreak;\n\n\t\tcase FAILOVER_STATE_ELECTION_RERUN:\n\n\t\t\t/* we no longer care about our former siblings */\n\t\t\tclear_node_info_list(&sibling_nodes);\n\n\t\t\tlog_notice(_(\"rerunning election after %i seconds (\\\"election_rerun_interval\\\")\"),\n\t\t\t\t\t   config_file_options.election_rerun_interval);\n\t\t\tsleep(config_file_options.election_rerun_interval);\n\n\t\t\tlog_info(_(\"election rerun will now commence\"));\n\t\t\t/*\n\t\t\t * mark the upstream node as \"up\" so another election is triggered\n\t\t\t * after we fall back to monitoring\n\t\t\t */\n\t\t\tupstream_node_info.node_status = NODE_STATUS_UP;\n\t\t\tfailover_state = FAILOVER_STATE_NONE;\n\n\t\t\tfinal_result = false;\n\t\t\tbreak;\n\n\t\tcase FAILOVER_STATE_PRIMARY_REAPPEARED:\n\n\t\t\t/*\n\t\t\t * notify siblings that they should resume following the original\n\t\t\t * primary\n\t\t\t */\n\t\t\tnotify_followers(&sibling_nodes, upstream_node_info.node_id);\n\n\t\t\t/* pass control back down to start_monitoring() */\n\n\t\t\tlog_info(_(\"resuming %s monitoring mode\"), get_node_type_string(local_node_info.type));\n\t\t\tlog_detail(_(\"original primary \\\"%s\\\" (ID: %i) reappeared\"),\n\t\t\t\t\t   upstream_node_info.node_name, upstream_node_info.node_id);\n\n\t\t\tfailover_state = FAILOVER_STATE_NONE;\n\n\t\t\tfinal_result = true;\n\t\t\tbreak;\n\n\t\tcase FAILOVER_STATE_FOLLOWED_NEW_PRIMARY:\n\t\t\tlog_info(_(\"resuming %s monitoring mode\"), get_node_type_string(local_node_info.type));\n\t\t\tlog_detail(_(\"following new primary \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t   upstream_node_info.node_name, upstream_node_info.node_id);\n\t\t\tfailover_state = FAILOVER_STATE_NONE;\n\n\t\t\tfinal_result = true;\n\t\t\tbreak;\n\n\t\tcase FAILOVER_STATE_FOLLOWING_ORIGINAL_PRIMARY:\n\t\t\tlog_info(_(\"resuming %s monitoring mode\"), get_node_type_string(local_node_info.type));\n\t\t\tlog_detail(_(\"following original primary \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t   upstream_node_info.node_name, upstream_node_info.node_id);\n\t\t\tfailover_state = FAILOVER_STATE_NONE;\n\n\t\t\tfinal_result = true;\n\t\t\tbreak;\n\n\t\tcase FAILOVER_STATE_PROMOTION_FAILED:\n\t\t\tmonitoring_state = MS_DEGRADED;\n\t\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\n\t\t\tfinal_result = false;\n\t\t\tbreak;\n\n\t\tcase FAILOVER_STATE_FOLLOW_FAIL:\n\n\t\t\t/*\n\t\t\t * for whatever reason we were unable to follow the new primary -\n\t\t\t * continue monitoring in degraded state\n\t\t\t */\n\t\t\tmonitoring_state = MS_DEGRADED;\n\t\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\n\t\t\tfinal_result = false;\n\t\t\tbreak;\n\n\t\tcase FAILOVER_STATE_REQUIRES_MANUAL_FAILOVER:\n\t\t\tlog_info(_(\"automatic failover disabled for this node, manual intervention required\"));\n\n\t\t\tmonitoring_state = MS_DEGRADED;\n\t\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\n\t\t\tfinal_result = false;\n\t\t\tbreak;\n\n\t\tcase FAILOVER_STATE_NO_NEW_PRIMARY:\n\t\tcase FAILOVER_STATE_WAITING_NEW_PRIMARY:\n\t\t\t/* pass control back down to start_monitoring() */\n\t\t\tfinal_result = false;\n\t\t\tbreak;\n\n\t\tcase FAILOVER_STATE_NODE_NOTIFICATION_ERROR:\n\t\tcase FAILOVER_STATE_LOCAL_NODE_FAILURE:\n\t\tcase FAILOVER_STATE_UNKNOWN:\n\t\tcase FAILOVER_STATE_NONE:\n\n\t\t\tfinal_result = false;\n\t\t\tbreak;\n\n\t\tdefault:\t/* should never reach here */\n\t\t\tlog_warning(_(\"unhandled failover state %i\"), failover_state);\n\t\t\tbreak;\n\t}\n\n\t/* we no longer care about our former siblings */\n\tclear_node_info_list(&sibling_nodes);\n\n\treturn final_result;\n}\n\n\nstatic bool\nupdate_monitoring_history(void)\n{\n\tReplInfo\treplication_info;\n\tXLogRecPtr\tprimary_last_wal_location = InvalidXLogRecPtr;\n\n\tlong long unsigned int apply_lag_bytes = 0;\n\tlong long unsigned int replication_lag_bytes = 0;\n\n\t/* both local and primary connections must be available */\n\tif (PQstatus(primary_conn) != CONNECTION_OK)\n\t{\n\t\tlog_warning(_(\"primary connection is not available, unable to update monitoring history\"));\n\t\treturn false;\n\t}\n\n\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t{\n\t\tlog_warning(_(\"local connection is not available, unable to update monitoring history\"));\n\t\treturn false;\n\t}\n\n\tinit_replication_info(&replication_info);\n\n\tif (get_replication_info(local_conn, STANDBY, &replication_info) == false)\n\t{\n\t\tlog_warning(_(\"unable to retrieve replication status information, unable to update monitoring history\"));\n\t\treturn false;\n\t}\n\n\t/*\n\t * This can be the case when a standby is starting up after following\n\t * a new primary, or when it has dropped back to archive recovery.\n\t * As long as we can connect to the primary, we can still provide lag information.\n\t */\n\tif (replication_info.receiving_streamed_wal == false)\n\t{\n\t\tlog_verbose(LOG_WARNING, _(\"standby %i not connected to streaming replication\"),\n\t\t\t\t\tlocal_node_info.node_id);\n\t}\n\n\tprimary_last_wal_location = get_primary_current_lsn(primary_conn);\n\n\tif (primary_last_wal_location == InvalidXLogRecPtr)\n\t{\n\t\tlog_warning(_(\"unable to retrieve primary's current LSN\"));\n\t\treturn false;\n\t}\n\n\t/* calculate apply lag in bytes */\n\tif (replication_info.last_wal_receive_lsn >= replication_info.last_wal_replay_lsn)\n\t{\n\t\tapply_lag_bytes = (long long unsigned int) (replication_info.last_wal_receive_lsn - replication_info.last_wal_replay_lsn);\n\t}\n\telse\n\t{\n\t\t/* if this happens, it probably indicates archive recovery */\n\t\tapply_lag_bytes = 0;\n\t}\n\n\t/* calculate replication lag in bytes */\n\n\tif (primary_last_wal_location >= replication_info.last_wal_receive_lsn)\n\t{\n\t\treplication_lag_bytes = (long long unsigned int) (primary_last_wal_location - replication_info.last_wal_receive_lsn);\n\t\tlog_debug(\"replication lag in bytes is: %llu\", replication_lag_bytes);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * This should never happen, but in case it does set replication lag\n\t\t * to zero\n\t\t */\n\t\tlog_warning(\"primary xlog location (%X/%X) is behind the standby receive location (%X/%X)\",\n\t\t\t\t\tformat_lsn(primary_last_wal_location),\n\t\t\t\t\tformat_lsn(replication_info.last_wal_receive_lsn));\n\t\treplication_lag_bytes = 0;\n\t}\n\n\tadd_monitoring_record(primary_conn,\n\t\t\t\t\t\t  local_conn,\n\t\t\t\t\t\t  primary_node_id,\n\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t  replication_info.current_timestamp,\n\t\t\t\t\t\t  primary_last_wal_location,\n\t\t\t\t\t\t  replication_info.last_wal_receive_lsn,\n\t\t\t\t\t\t  replication_info.last_xact_replay_timestamp,\n\t\t\t\t\t\t  replication_lag_bytes,\n\t\t\t\t\t\t  apply_lag_bytes);\n\n\tINSTR_TIME_SET_CURRENT(last_monitoring_update);\n\n\tlog_verbose(LOG_DEBUG, \"update_monitoring_history(): monitoring history update sent\");\n\n\treturn true;\n}\n\n\n/*\n * do_upstream_standby_failover()\n *\n * Attach cascaded standby to another node, currently the primary.\n *\n * Note that in contrast to a primary failover, where one of the downstream\n * standby nodes will become a primary, a cascaded standby failover (where the\n * upstream standby has gone away) is \"just\" a case of attaching the standby to\n * another node.\n *\n * Currently we will try to attach the node to the cluster primary.\n *\n * TODO: As of repmgr 4.3, \"repmgr standby follow\" supports attaching a standby to another\n * standby node. We need to provide a selection of reconnection strategies as different\n * behaviour might be desirable in different situations.\n */\n\nstatic bool\ndo_upstream_standby_failover(void)\n{\n\tt_node_info primary_node_info = T_NODE_INFO_INITIALIZER;\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\tRecoveryType primary_type = RECTYPE_UNKNOWN;\n\tint\t\t\ti, standby_follow_result;\n\tchar\t\tparsed_follow_command[MAXPGPATH] = \"\";\n\n\tclose_connection(&upstream_conn);\n\n\t/*\n\t *\n\t */\n\tif (config_file_options.failover == FAILOVER_MANUAL)\n\t{\n\t\tlog_notice(_(\"this node is not configured for automatic failover\"));\n\t\tlog_detail(_(\"parameter \\\"failover\\\" is set to \\\"manual\\\"\"));\n\t\treturn false;\n\t}\n\n\tif (get_primary_node_record(local_conn, &primary_node_info) == false)\n\t{\n\t\tlog_error(_(\"unable to retrieve primary node record\"));\n\t\treturn false;\n\t}\n\n\t/*\n\t * Verify that we can still talk to the cluster primary, even though the\n\t * node's upstream is not available\n\t */\n\n\tcheck_connection(&primary_node_info, &primary_conn);\n\n\tif (PQstatus(primary_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to connect to last known primary \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t  primary_node_info.node_name,\n\t\t\t\t  primary_node_info.node_id);\n\n\t\tclose_connection(&primary_conn);\n\t\tmonitoring_state = MS_DEGRADED;\n\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\t\treturn false;\n\t}\n\n\tprimary_type = get_recovery_type(primary_conn);\n\n\tif (primary_type != RECTYPE_PRIMARY)\n\t{\n\t\tif (primary_type == RECTYPE_STANDBY)\n\t\t{\n\t\t\tlog_error(_(\"last known primary \\\"%s\\\" (ID: %i) is in recovery, not following\"),\n\t\t\t\t\t  primary_node_info.node_name,\n\t\t\t\t\t  primary_node_info.node_id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_error(_(\"unable to determine status of last known primary \\\"%s\\\" (ID: %i), not following\"),\n\t\t\t\t\t  primary_node_info.node_name,\n\t\t\t\t\t  primary_node_info.node_id);\n\t\t}\n\n\t\tclose_connection(&primary_conn);\n\t\tmonitoring_state = MS_DEGRADED;\n\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\t\treturn false;\n\t}\n\n\t/* Close the connection to this server */\n\tclose_connection(&local_conn);\n\n\tlog_debug(_(\"standby follow command is:\\n  \\\"%s\\\"\"),\n\t\t\t  config_file_options.follow_command);\n\n\t/*\n\t * replace %n in \"config_file_options.follow_command\" with ID of primary\n\t * to follow.\n\t */\n\tparse_follow_command(parsed_follow_command, config_file_options.follow_command, primary_node_info.node_id);\n\n\tstandby_follow_result = system(parsed_follow_command);\n\n\tif (standby_follow_result != 0)\n\t{\n\t\tPQExpBufferData event_details;\n\n\t\tinitPQExpBuffer(&event_details);\n\n\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t  _(\"unable to execute follow command:\\n %s\"),\n\t\t\t\t\t\t  config_file_options.follow_command);\n\n\t\tlog_error(\"%s\", event_details.data);\n\n\t\t/*\n\t\t * It may not possible to write to the event notification table but we\n\t\t * should be able to generate an external notification if required.\n\t\t */\n\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t  \"repmgrd_failover_follow\",\n\t\t\t\t\t\t\t\t  false,\n\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\ttermPQExpBuffer(&event_details);\n\t}\n\n\t/*\n\t * It's possible that the standby is still starting up after the \"follow_command\"\n\t * completes, so poll for a while until we get a connection.\n\t *\n\t * NOTE: we've previously closed the local connection, so even if the follow command\n\t * failed for whatever reason and the local node remained up, we can re-open\n\t * the local connection.\n\t */\n\n\tfor (i = 0; i < config_file_options.repmgrd_standby_startup_timeout; i++)\n\t{\n\t\tlocal_conn = establish_db_connection(local_node_info.conninfo, false);\n\n\t\tif (PQstatus(local_conn) == CONNECTION_OK)\n\t\t\tbreak;\n\n\t\tclose_connection(&local_conn);\n\n\t\tlog_debug(\"sleeping 1 second; %i of %i (\\\"repmgrd_standby_startup_timeout\\\") attempts to reconnect to local node\",\n\t\t\t\t  i + 1,\n\t\t\t\t  config_file_options.repmgrd_standby_startup_timeout);\n\t\tsleep(1);\n\t}\n\n\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to reconnect to local node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t  local_node_info.node_name,\n\t\t\t\t  local_node_info.node_id);\n\t\treturn FAILOVER_STATE_FOLLOW_FAIL;\n\t}\n\n\t/* refresh shared memory settings which will have been zapped by the restart */\n\trepmgrd_set_local_node_id(local_conn, config_file_options.node_id);\n\trepmgrd_set_pid(local_conn, getpid(), pid_file);\n\n\t/*\n\t *\n\t */\n\n\tif (standby_follow_result != 0)\n\t{\n\t\tmonitoring_state = MS_DEGRADED;\n\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\n\t\treturn FAILOVER_STATE_FOLLOW_FAIL;\n\t}\n\n\t/*\n\t * update upstream_node_id to primary node (but only if follow command\n\t * was successful)\n\t */\n\n\t{\n\t\tif (update_node_record_set_upstream(primary_conn,\n\t\t\t\t\t\t\t\t\t\t\tlocal_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t\tprimary_node_info.node_id) == false)\n\t\t{\n\t\t\tPQExpBufferData event_details;\n\n\t\t\tinitPQExpBuffer(&event_details);\n\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t  _(\"unable to set node \\\"%s\\\" (ID: %i)'s new upstream ID to %i\"),\n\t\t\t\t\t\t\t  local_node_info.node_name,\n\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t  primary_node_info.node_id);\n\n\t\t\tlog_error(\"%s\", event_details.data);\n\n\t\t\tcreate_event_notification(NULL,\n\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t\t  \"repmgrd_failover_follow\",\n\t\t\t\t\t\t\t\t\t  false,\n\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\ttermPQExpBuffer(&event_details);\n\n\t\t\tterminate(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\t/* refresh own internal node record */\n\trecord_status = get_node_record(primary_conn, local_node_info.node_id, &local_node_info);\n\n\t/*\n\t * highly improbable this will happen, but in case we're unable to\n\t * retrieve our node record from the primary, update it ourselves, and\n\t * hope for the best\n\t */\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlocal_node_info.upstream_node_id = primary_node_info.node_id;\n\t}\n\n\t{\n\t\tPQExpBufferData event_details;\n\n\t\tinitPQExpBuffer(&event_details);\n\n\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t  _(\"node \\\"%s\\\" (ID: %i) is now following primary node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t  local_node_info.node_name,\n\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t  primary_node_info.node_name,\n\t\t\t\t\t\t  primary_node_info.node_id);\n\n\t\tlog_notice(\"%s\", event_details.data);\n\n\t\tcreate_event_notification(primary_conn,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t  \"repmgrd_failover_follow\",\n\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\ttermPQExpBuffer(&event_details);\n\t}\n\n\t/* keep the primary connection open */\n\n\treturn true;\n}\n\n\n/*\n * This promotes the local node using the \"promote_command\" configuration\n * parameter, which must be either \"repmgr standby promote\" or a script which\n * at some point executes \"repmgr standby promote\".\n *\n * TODO: make \"promote_command\" and execute the same code used by\n * \"repmgr standby promote\".\n */\nstatic FailoverState\npromote_self(void)\n{\n\tchar\t   *promote_command;\n\tint\t\t\tr;\n\n\t/* Store details of the failed node here */\n\tt_node_info failed_primary = T_NODE_INFO_INITIALIZER;\n\tRecordStatus record_status;\n\n\t/*\n\t * optionally add a delay before promoting the standby; this is mainly\n\t * useful for testing (e.g. for reappearance of the original primary) and\n\t * is not documented.\n\t */\n\tif (config_file_options.promote_delay > 0)\n\t{\n\t\tlog_debug(\"sleeping %i seconds before promoting standby\",\n\t\t\t\t  config_file_options.promote_delay);\n\t\tsleep(config_file_options.promote_delay);\n\t}\n\n\tif (local_node_info.upstream_node_id == UNKNOWN_NODE_ID)\n\t{\n\t\t/*\n\t\t * This is a corner-case situation where the repmgr metadata on the\n\t\t * promotion candidate is outdated and the local node's upstream_node_id\n\t\t * is not set. This is often an indication of potentially serious issues,\n\t\t * such as the local node being very far behind the primary, or not being\n\t\t * attached at all.\n\t\t *\n\t\t * In this case it may be desirable to restore the original primary.\n\t\t * This behaviour can be controlled by the \"always_promote\" configuration option.\n\t\t */\n\t\tif (config_file_options.always_promote == false)\n\t\t{\n\t\t\tlog_error(_(\"this node (ID: %i) does not have its upstream_node_id set, not promoting\"),\n\t\t\t\t\t  local_node_info.node_id);\n\t\t\tlog_detail(_(\"the local node's metadata has not been updated since it became a standby\"));\n\t\t\tlog_hint(_(\"set \\\"always_promote\\\" to \\\"true\\\" to force promotion in this situation\"));\n\t\t\treturn FAILOVER_STATE_PROMOTION_FAILED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_warning(_(\"this node (ID: %i) does not have its upstream_node_id set, promoting anyway\"),\n\t\t\t\t\t\tlocal_node_info.node_id);\n\t\t\tlog_detail(_(\"\\\"always_promote\\\" is set to \\\"true\\\" \"));\n\t\t}\n\t}\n\telse\n\t{\n\t\trecord_status = get_node_record(local_conn, local_node_info.upstream_node_id, &failed_primary);\n\n\t\tif (record_status != RECORD_FOUND)\n\t\t{\n\t\t\tlog_error(_(\"unable to retrieve metadata record for failed upstream (ID: %i)\"),\n\t\t\t\t\t  local_node_info.upstream_node_id);\n\t\t\treturn FAILOVER_STATE_PROMOTION_FAILED;\n\t\t}\n\t}\n\n\t/* the presence of this command has been established already */\n\tpromote_command = config_file_options.promote_command;\n\n\tlog_info(_(\"promote_command is:\\n  \\\"%s\\\"\"),\n\t\t\t  promote_command);\n\n\tif (log_type == REPMGR_STDERR && *config_file_options.log_file)\n\t{\n\t\tfflush(stderr);\n\t}\n\n\tr = system(promote_command);\n\n\tlog_debug(\"result of promote_command: %i\", WEXITSTATUS(r));\n\n\t/* connection should stay up, but check just in case */\n\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t{\n\t\tlog_warning(_(\"local database connection not available\"));\n\t\tlog_detail(\"\\n%s\", PQerrorMessage(local_conn));\n\n\t\tclose_connection(&local_conn);\n\n\t\tlocal_conn = establish_db_connection(local_node_info.conninfo, true);\n\n\t\t/* assume node failed */\n\t\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t\t{\n\t\t\tlog_error(_(\"unable to reconnect to local node\"));\n\t\t\tlog_detail(\"\\n%s\", PQerrorMessage(local_conn));\n\n\t\t\tclose_connection(&local_conn);\n\n\t\t\t/* XXX handle this */\n\t\t\treturn FAILOVER_STATE_LOCAL_NODE_FAILURE;\n\t\t}\n\t}\n\n\tif (WIFEXITED(r) && WEXITSTATUS(r))\n\t{\n\t\tint\t\t\tprimary_node_id = UNKNOWN_NODE_ID;\n\n\t\tlog_error(_(\"promote command failed\"));\n\t\tlog_detail(_(\"promote command exited with error code %i\"), WEXITSTATUS(r));\n\n\t\tlog_info(_(\"checking if original primary node has reappeared\"));\n\n\t\tupstream_conn = get_primary_connection(local_conn,\n\t\t\t\t\t\t\t\t\t\t\t   &primary_node_id,\n\t\t\t\t\t\t\t\t\t\t\t   NULL);\n\n\t\tif (PQstatus(upstream_conn) != CONNECTION_OK)\n\t\t{\n\t\t\tclose_connection(&upstream_conn);\n\t\t}\n\t\telse if (primary_node_id == failed_primary.node_id)\n\t\t{\n\t\t\tPQExpBufferData event_details;\n\n\t\t\tlog_notice(_(\"original primary \\\"%s\\\" (ID: %i) reappeared before this standby was promoted - no action taken\"),\n\t\t\t\t\t   failed_primary.node_name,\n\t\t\t\t\t   failed_primary.node_id);\n\n\t\t\tinitPQExpBuffer(&event_details);\n\t\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t\t  _(\"original primary \\\"%s\\\" (ID: %i) reappeared\"),\n\t\t\t\t\t\t\t  failed_primary.node_name,\n\t\t\t\t\t\t\t  failed_primary.node_id);\n\n\t\t\tcreate_event_notification(upstream_conn,\n\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t\t  \"repmgrd_failover_abort\",\n\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\ttermPQExpBuffer(&event_details);\n\n\t\t\t/* XXX handle this! */\n\t\t\t/* -> we'll need to let the other nodes know too.... */\n\t\t\t/* no failover occurred but we'll want to restart connections */\n\n\t\t\treturn FAILOVER_STATE_PRIMARY_REAPPEARED;\n\t\t}\n\n\t\tcreate_event_notification(NULL,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t  \"repmgrd_promote_error\",\n\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t  \"\");\n\n\t\treturn FAILOVER_STATE_PROMOTION_FAILED;\n\t}\n\n\t/*\n\t * Promotion has succeeded - verify local connection is still available\n\t */\n\ttry_reconnect(&local_conn, &local_node_info);\n\n\t/* bump the electoral term */\n\tincrement_current_term(local_conn);\n\n\t{\n\t\tPQExpBufferData event_details;\n\t\tt_event_info event_info = T_EVENT_INFO_INITIALIZER;\n\n\t\t/* update own internal node record */\n\t\trecord_status = get_node_record(local_conn, local_node_info.node_id, &local_node_info);\n\n\t\t/*\n\t\t * XXX here we're assuming the promote command updated metadata\n\t\t */\n\t\tinitPQExpBuffer(&event_details);\n\n\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t  _(\"node \\\"%s\\\" (ID: %i) promoted to primary; old primary \\\"%s\\\" (ID: %i) marked as failed\"),\n\t\t\t\t\t\t  local_node_info.node_name,\n\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t  failed_primary.node_name,\n\t\t\t\t\t\t  failed_primary.node_id);\n\n\t\tevent_info.node_id = failed_primary.node_id;\n\n\t\t/* local_conn is now the primary connection */\n\t\tcreate_event_notification_extended(local_conn,\n\t\t\t\t\t\t\t\t\t\t   &config_file_options,\n\t\t\t\t\t\t\t\t\t\t   local_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t   \"repmgrd_failover_promote\",\n\t\t\t\t\t\t\t\t\t\t   true,\n\t\t\t\t\t\t\t\t\t\t   event_details.data,\n\t\t\t\t\t\t\t\t\t\t   &event_info);\n\n\t\ttermPQExpBuffer(&event_details);\n\t}\n\n\treturn FAILOVER_STATE_PROMOTED;\n}\n\n\n\n\n/*\n * Notify follower nodes about which node to follow. Normally this\n * will be the current node, however if the original primary reappeared\n * before this node could be promoted, we'll inform the followers they\n * should resume monitoring the original primary.\n */\nstatic void\nnotify_followers(NodeInfoList *standby_nodes, int follow_node_id)\n{\n\tNodeInfoListCell *cell;\n\n\tlog_info(_(\"%i followers to notify\"),\n\t\t\t standby_nodes->node_count);\n\n\tfor (cell = standby_nodes->head; cell; cell = cell->next)\n\t{\n\t\tlog_verbose(LOG_DEBUG, \"intending to notify node %i...\", cell->node_info->node_id);\n\n\t\tif (PQstatus(cell->node_info->conn) != CONNECTION_OK)\n\t\t{\n\t\t\tlog_info(_(\"reconnecting to node \\\"%s\\\" (ID: %i)...\"),\n\t\t\t\t\t cell->node_info->node_name,\n\t\t\t\t\t cell->node_info->node_id);\n\n\t\t\tclose_connection(&cell->node_info->conn);\n\n\t\t\tcell->node_info->conn = establish_db_connection(cell->node_info->conninfo, false);\n\t\t}\n\n\t\tif (PQstatus(cell->node_info->conn) != CONNECTION_OK)\n\t\t{\n\t\t\tlog_warning(_(\"unable to reconnect to \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\tcell->node_info->node_id);\n\t\t\tlog_detail(\"\\n%s\", PQerrorMessage(cell->node_info->conn));\n\n\t\t\tclose_connection(&cell->node_info->conn);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (follow_node_id == ELECTION_RERUN_NOTIFICATION)\n\t\t{\n\t\t\tlog_notice(_(\"notifying node \\\"%s\\\" (ID: %i) to rerun promotion candidate selection\"),\n\t\t\t\t\t   cell->node_info->node_name,\n\t\t\t\t\t   cell->node_info->node_id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_notice(_(\"notifying node \\\"%s\\\" (ID: %i) to follow node %i\"),\n\t\t\t\t\t   cell->node_info->node_name,\n\t\t\t\t\t   cell->node_info->node_id,\n\t\t\t\t\t   follow_node_id);\n\t\t}\n\t\tnotify_follow_primary(cell->node_info->conn, follow_node_id);\n\t}\n}\n\n\nstatic bool\nwait_primary_notification(int *new_primary_id)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < config_file_options.primary_notification_timeout; i++)\n\t{\n\t\tif (get_new_primary(local_conn, new_primary_id) == true)\n\t\t{\n\t\t\tlog_debug(\"new primary is %i; elapsed: %i seconds\",\n\t\t\t\t\t  *new_primary_id, i);\n\t\t\treturn true;\n\t\t}\n\n\t\tlog_verbose(LOG_DEBUG, \"waiting for new primary notification, %i of max %i seconds (\\\"primary_notification_timeout\\\")\",\n\t\t\t\t\ti, config_file_options.primary_notification_timeout);\n\n\t\tsleep(1);\n\t}\n\n\tlog_warning(_(\"no notification received from new primary after %i seconds\"),\n\t\t\t\tconfig_file_options.primary_notification_timeout);\n\n\tmonitoring_state = MS_DEGRADED;\n\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\n\treturn false;\n}\n\n\nstatic FailoverState\nfollow_new_primary(int new_primary_id)\n{\n\tchar\t\tparsed_follow_command[MAXPGPATH] = \"\";\n\tint\t\t\ti, r;\n\n\t/* Store details of the failed node here */\n\tt_node_info failed_primary = T_NODE_INFO_INITIALIZER;\n\tt_node_info new_primary = T_NODE_INFO_INITIALIZER;\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\tbool\t\tnew_primary_ok = false;\n\n\tlog_verbose(LOG_DEBUG, \"follow_new_primary(): new primary id is %i\", new_primary_id);\n\n\trecord_status = get_node_record(local_conn, new_primary_id, &new_primary);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve metadata record for new primary node (ID: %i)\"),\n\t\t\t\t  new_primary_id);\n\t\treturn FAILOVER_STATE_FOLLOW_FAIL;\n\t}\n\n\tlog_notice(_(\"attempting to follow new primary \\\"%s\\\" (node ID: %i)\"),\n\t\t\t\t new_primary.node_name,\n\t\t\t\t new_primary_id);\n\n\trecord_status = get_node_record(local_conn, local_node_info.upstream_node_id, &failed_primary);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve metadata record for failed primary (ID: %i)\"),\n\t\t\t\t  local_node_info.upstream_node_id);\n\t\treturn FAILOVER_STATE_FOLLOW_FAIL;\n\t}\n\n\t/* XXX check if new_primary_id == failed_primary.node_id? */\n\n\tif (log_type == REPMGR_STDERR && *config_file_options.log_file)\n\t{\n\t\tfflush(stderr);\n\t}\n\n\tupstream_conn = establish_db_connection(new_primary.conninfo, false);\n\n\tif (PQstatus(upstream_conn) == CONNECTION_OK)\n\t{\n\t\tRecoveryType primary_recovery_type = get_recovery_type(upstream_conn);\n\n\t\tif (primary_recovery_type == RECTYPE_PRIMARY)\n\t\t{\n\t\t\tnew_primary_ok = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnew_primary_ok = false;\n\t\t\tlog_warning(_(\"new primary \\\"%s\\\" (node ID: %i) is in recovery\"),\n\t\t\t\t\t\tnew_primary.node_name,\n\t\t\t\t\t\tnew_primary_id);\n\t\t\tclose_connection(&upstream_conn);\n\t\t}\n\t}\n\n\tif (new_primary_ok == false)\n\t{\n\t\treturn FAILOVER_STATE_FOLLOW_FAIL;\n\t}\n\n\t/*\n\t * disconnect from local node, as follow operation will result in a server\n\t * restart\n\t */\n\n\tclose_connection(&local_conn);\n\n\t/*\n\t * replace %n in \"config_file_options.follow_command\" with ID of primary\n\t * to follow.\n\t */\n\tparse_follow_command(parsed_follow_command, config_file_options.follow_command, new_primary_id);\n\n\tlog_debug(_(\"standby follow command is:\\n  \\\"%s\\\"\"),\n\t\t\t  parsed_follow_command);\n\n\t/* execute the follow command */\n\tr = system(parsed_follow_command);\n\n\tif (r != 0)\n\t{\n\t\tPGconn\t   *old_primary_conn;\n\n\t\t/*\n\t\t * The \"standby follow\" command could still fail due to the original primary\n\t\t * reappearing before the candidate could promote itself (\"repmgr\n\t\t * standby follow\" will refuse to promote another node if the primary\n\t\t * is available). However the new primary will only instruct the other\n\t\t * nodes to follow it after it's successfully promoted itself, so this\n\t\t * case is highly unlikely. A slightly more likely scenario would\n\t\t * be the new primary becoming unavailable just after it's sent notifications\n\t\t * to its follower nodes, and the old primary becoming available again.\n\t\t */\n\t\told_primary_conn = establish_db_connection(failed_primary.conninfo, false);\n\n\t\tif (PQstatus(old_primary_conn) == CONNECTION_OK)\n\t\t{\n\t\t\tRecoveryType upstream_recovery_type = get_recovery_type(old_primary_conn);\n\n\t\t\tif (upstream_recovery_type == RECTYPE_PRIMARY)\n\t\t\t{\n\t\t\t\tPQExpBufferData event_details;\n\n\t\t\t\tinitPQExpBuffer(&event_details);\n\t\t\t\tappendPQExpBufferStr(&event_details,\n\t\t\t\t\t\t\t\t\t _(\"original primary reappeared - no action taken\"));\n\n\t\t\t\tlog_notice(\"%s\", event_details.data);\n\n\t\t\t\tcreate_event_notification(old_primary_conn,\n\t\t\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t\t\t  \"repmgrd_failover_aborted\",\n\t\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\t\t\ttermPQExpBuffer(&event_details);\n\n\t\t\t\tclose_connection(&upstream_conn);\n\t\t\t\tclose_connection(&old_primary_conn);\n\n\t\t\t\treturn FAILOVER_STATE_PRIMARY_REAPPEARED;\n\t\t\t}\n\n\t\t\tlog_notice(_(\"original primary reappeared as standby\"));\n\n\t\t\tclose_connection(&old_primary_conn);\n\t\t}\n\n\t\tclose_connection(&upstream_conn);\n\n\t\treturn FAILOVER_STATE_FOLLOW_FAIL;\n\t}\n\n\t/*\n\t * refresh local copy of local and primary node records - we get these\n\t * directly from the primary to ensure they're the current version\n\t */\n\n\trecord_status = get_node_record(upstream_conn, new_primary_id, &upstream_node_info);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve metadata record found for node %i\"),\n\t\t\t\t  new_primary_id);\n\t\treturn FAILOVER_STATE_FOLLOW_FAIL;\n\t}\n\n\trecord_status = get_node_record(upstream_conn, local_node_info.node_id, &local_node_info);\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve metadata record found for node %i\"),\n\t\t\t\t  local_node_info.node_id);\n\t\treturn FAILOVER_STATE_FOLLOW_FAIL;\n\t}\n\n\t/*\n\t * It's possible that the standby is still starting up after the \"follow_command\"\n\t * completes, so poll for a while until we get a connection.\n\t */\n\n\tfor (i = 0; i < config_file_options.repmgrd_standby_startup_timeout; i++)\n\t{\n\t\tlocal_conn = establish_db_connection(local_node_info.conninfo, false);\n\n\t\tif (PQstatus(local_conn) == CONNECTION_OK)\n\t\t\tbreak;\n\n\t\tclose_connection(&local_conn);\n\n\t\tlog_debug(\"sleeping 1 second; %i of %i attempts to reconnect to local node\",\n\t\t\t\t  i + 1,\n\t\t\t\t  config_file_options.repmgrd_standby_startup_timeout);\n\t\tsleep(1);\n\t}\n\n\tif (local_conn == NULL || PQstatus(local_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to reconnect to local node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t  local_node_info.node_name,\n\t\t\t\t  local_node_info.node_id);\n\t\treturn FAILOVER_STATE_FOLLOW_FAIL;\n\t}\n\n\t/* refresh shared memory settings which will have been zapped by the restart */\n\trepmgrd_set_local_node_id(local_conn, config_file_options.node_id);\n\trepmgrd_set_pid(local_conn, getpid(), pid_file);\n\n\t{\n\t\tPQExpBufferData event_details;\n\n\t\tinitPQExpBuffer(&event_details);\n\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t  _(\"node \\\"%s\\\" (ID: %i) now following new upstream node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t  local_node_info.node_name,\n\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t  upstream_node_info.node_name,\n\t\t\t\t\t\t  upstream_node_info.node_id);\n\n\t\tlog_notice(\"%s\", event_details.data);\n\n\t\tcreate_event_notification(upstream_conn,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t  \"repmgrd_failover_follow\",\n\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\ttermPQExpBuffer(&event_details);\n\t}\n\n\treturn FAILOVER_STATE_FOLLOWED_NEW_PRIMARY;\n}\n\n\nstatic FailoverState\nwitness_follow_new_primary(int new_primary_id)\n{\n\tt_node_info new_primary = T_NODE_INFO_INITIALIZER;\n\tRecordStatus record_status = RECORD_NOT_FOUND;\n\tbool\t\tnew_primary_ok = false;\n\n\trecord_status = get_node_record(local_conn, new_primary_id, &new_primary);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve metadata record for new primary node (ID: %i)\"),\n\t\t\t\t  new_primary_id);\n\t\treturn FAILOVER_STATE_FOLLOW_FAIL;\n\t}\n\n\t/* TODO: check if new_primary_id == failed_primary.node_id? */\n\n\tif (log_type == REPMGR_STDERR && *config_file_options.log_file)\n\t{\n\t\tfflush(stderr);\n\t}\n\n\tupstream_conn = establish_db_connection(new_primary.conninfo, false);\n\n\tif (PQstatus(upstream_conn) == CONNECTION_OK)\n\t{\n\t\tRecoveryType primary_recovery_type = get_recovery_type(upstream_conn);\n\n\t\tswitch (primary_recovery_type)\n\t\t{\n\t\t\tcase RECTYPE_PRIMARY:\n\t\t\t\tnew_primary_ok = true;\n\t\t\t\tbreak;\n\t\t\tcase RECTYPE_STANDBY:\n\t\t\t\tnew_primary_ok = false;\n\t\t\t\tlog_warning(_(\"new primary \\\"%s\\\" (node ID: %i) is in recovery\"),\n\t\t\t\t\t\t\tnew_primary.node_name,\n\t\t\t\t\t\t\tnew_primary_id);\n\t\t\t\tbreak;\n\t\t\tcase RECTYPE_UNKNOWN:\n\t\t\t\tnew_primary_ok = false;\n\t\t\t\tlog_warning(_(\"unable to determine status of new primary\"));\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (new_primary_ok == false)\n\t{\n\t\tclose_connection(&upstream_conn);\n\n\t\treturn FAILOVER_STATE_FOLLOW_FAIL;\n\t}\n\n\t/* set new upstream node ID on primary */\n\tupdate_node_record_set_upstream(upstream_conn, local_node_info.node_id, new_primary_id);\n\n\twitness_copy_node_records(upstream_conn, local_conn);\n\n\t/*\n\t * refresh local copy of local and primary node records - we get these\n\t * directly from the primary to ensure they're the current version\n\t */\n\n\trecord_status = get_node_record(upstream_conn, new_primary_id, &upstream_node_info);\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve metadata record found for node %i\"),\n\t\t\t\t  new_primary_id);\n\t\treturn FAILOVER_STATE_FOLLOW_FAIL;\n\t}\n\n\trecord_status = get_node_record(upstream_conn, local_node_info.node_id, &local_node_info);\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"unable to retrieve metadata record for node %i\"),\n\t\t\t\t  local_node_info.node_id);\n\t\treturn FAILOVER_STATE_FOLLOW_FAIL;\n\t}\n\n\t{\n\t\tPQExpBufferData event_details;\n\n\t\tinitPQExpBuffer(&event_details);\n\t\tappendPQExpBuffer(&event_details,\n\t\t\t\t\t\t  _(\"witness node \\\"%s\\\" (ID: %i) now following new primary node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t  local_node_info.node_name,\n\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t  upstream_node_info.node_name,\n\t\t\t\t\t\t  upstream_node_info.node_id);\n\n\t\tlog_notice(\"%s\", event_details.data);\n\n\t\tcreate_event_notification(upstream_conn,\n\t\t\t\t\t\t\t\t  &config_file_options,\n\t\t\t\t\t\t\t\t  local_node_info.node_id,\n\t\t\t\t\t\t\t\t  \"repmgrd_failover_follow\",\n\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t  event_details.data);\n\n\t\ttermPQExpBuffer(&event_details);\n\t}\n\n\treturn FAILOVER_STATE_FOLLOWED_NEW_PRIMARY;\n}\n\n\nstatic const char *\n_print_election_result(ElectionResult result)\n{\n\tswitch (result)\n\t{\n\t\tcase ELECTION_NOT_CANDIDATE:\n\t\t\treturn \"NOT CANDIDATE\";\n\n\t\tcase ELECTION_WON:\n\t\t\treturn \"WON\";\n\n\t\tcase ELECTION_LOST:\n\t\t\treturn \"LOST\";\n\n\t\tcase ELECTION_CANCELLED:\n\t\t\treturn \"CANCELLED\";\n\n\t\tcase ELECTION_RERUN:\n\t\t\treturn \"RERUN\";\n\t}\n\n\t/* should never reach here */\n\treturn \"UNKNOWN\";\n}\n\n\n/*\n * Failover decision for nodes attached to the current primary.\n *\n * NB: this function sets \"sibling_nodes\"; caller (do_primary_failover)\n * expects to be able to read this list\n */\nstatic ElectionResult\ndo_election(NodeInfoList *sibling_nodes, int *new_primary_id)\n{\n\tint\t\t\telectoral_term = -1;\n\n\tNodeInfoListCell *cell = NULL;\n\n\tt_node_info *candidate_node = NULL;\n\telection_stats stats;\n\n\tReplInfo\tlocal_replication_info;\n\n\t/* To collate details of nodes with primary visible for logging purposes */\n\tPQExpBufferData nodes_with_primary_visible;\n\n\t/*\n\t * Check if at least one server in the primary's location is visible; if\n\t * not we'll assume a network split between this node and the primary\n\t * location, and not promote any standby.\n\t *\n\t * NOTE: this function is only ever called by standbys attached to the\n\t * current (unreachable) primary, so \"upstream_node_info\" will always\n\t * contain the primary node record.\n\t */\n\tbool\t\tprimary_location_seen = false;\n\n\n\tint\t\t\tnodes_with_primary_still_visible = 0;\n\n\tif (config_file_options.failover_delay > 0)\n\t{\n\t\tlog_debug(\"sleeping %i seconds (\\\"failover_delay\\\") before initiating failover\",\n\t\t\t\t  config_file_options.failover_delay);\n\t\tsleep(config_file_options.failover_delay);\n\t}\n\n\t/* we're visible */\n\tstats.visible_nodes = 1;\n\tstats.shared_upstream_nodes = 0;\n\tstats.all_nodes = 0;\n\n\telectoral_term = get_current_term(local_conn);\n\n\tif (electoral_term == -1)\n\t{\n\t\tlog_error(_(\"unable to determine electoral term\"));\n\n\t\treturn ELECTION_NOT_CANDIDATE;\n\t}\n\n\tlog_debug(\"do_election(): electoral term is %i\", electoral_term);\n\n\tif (config_file_options.failover == FAILOVER_MANUAL)\n\t{\n\t\tlog_notice(_(\"this node is not configured for automatic failover so will not be considered as promotion candidate, and will not follow the new primary\"));\n\t\tlog_detail(_(\"\\\"failover\\\" is set to \\\"manual\\\" in repmgr.conf\"));\n\t\tlog_hint(_(\"manually execute \\\"repmgr standby follow\\\" to have this node follow the new primary\"));\n\n\t\treturn ELECTION_NOT_CANDIDATE;\n\t}\n\n\t/* node priority is set to zero - don't become a candidate, and lose by default */\n\tif (local_node_info.priority <= 0)\n\t{\n\t\tlog_notice(_(\"this node's priority is %i so will not be considered as an automatic promotion candidate\"),\n\t\t\t\t   local_node_info.priority);\n\n\t\treturn ELECTION_LOST;\n\t}\n\n\t/* get all active nodes attached to upstream, excluding self */\n\tget_active_sibling_node_records(local_conn,\n\t\t\t\t\t\t\t\t\tlocal_node_info.node_id,\n\t\t\t\t\t\t\t\t\tupstream_node_info.node_id,\n\t\t\t\t\t\t\t\t\tsibling_nodes);\n\n\tlog_info(_(\"%i active sibling nodes registered\"), sibling_nodes->node_count);\n\n\tstats.shared_upstream_nodes = sibling_nodes->node_count + 1;\n\n\tget_all_nodes_count(local_conn, &stats.all_nodes);\n\n\tlog_info(_(\"%i total nodes registered\"), stats.all_nodes);\n\n\tif (strncmp(upstream_node_info.location, local_node_info.location, MAXLEN) != 0)\n\t{\n\t\tlog_info(_(\"primary node \\\"%s\\\" (ID: %i) has location \\\"%s\\\", this node's location is \\\"%s\\\"\"),\n\t\t\t\t upstream_node_info.node_name,\n\t\t\t\t upstream_node_info.node_id,\n\t\t\t\t upstream_node_info.location,\n\t\t\t\t local_node_info.location);\n\t}\n\telse\n\t{\n\t\tlog_info(_(\"primary node  \\\"%s\\\" (ID: %i) and this node have the same location (\\\"%s\\\")\"),\n\t\t\t\t upstream_node_info.node_name,\n\t\t\t\t upstream_node_info.node_id,\n\t\t\t\t local_node_info.location);\n\t}\n\n\tlocal_node_info.last_wal_receive_lsn = InvalidXLogRecPtr;\n\n\t/* fast path if no other standbys (or witness) exists - normally win by default */\n\tif (sibling_nodes->node_count == 0)\n\t{\n\t\tif (strncmp(upstream_node_info.location, local_node_info.location, MAXLEN) == 0)\n\t\t{\n\t\t\tif (config_file_options.failover_validation_command[0] != '\\0')\n\t\t\t{\n\t\t\t\treturn execute_failover_validation_command(&local_node_info, &stats);\n\t\t\t}\n\n\t\t\tlog_info(_(\"no other sibling nodes - we win by default\"));\n\n\t\t\treturn ELECTION_WON;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If primary and standby have different locations set, the assumption\n\t\t\t * is that no action should be taken as we can't tell whether there's\n\t\t\t * been a network interruption or not.\n\t\t\t *\n\t\t\t * Normally a situation with primary and standby in different physical\n\t\t\t * locations would be handled by leaving the location as \"default\" and\n\t\t\t * setting up a witness server in the primary's location.\n\t\t\t */\n\t\t\tlog_debug(\"no other nodes, but primary and standby locations differ\");\n\n\t\t\tmonitoring_state = MS_DEGRADED;\n\t\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\n\t\t\treturn ELECTION_NOT_CANDIDATE;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* standby nodes found - check if we're in the primary location before checking theirs */\n\t\tif (strncmp(upstream_node_info.location, local_node_info.location, MAXLEN) == 0)\n\t\t{\n\t\t\tprimary_location_seen = true;\n\t\t}\n\t}\n\n\t/* get our lsn */\n\tif (get_replication_info(local_conn, STANDBY, &local_replication_info) == false)\n\t{\n\t\tlog_error(_(\"unable to retrieve replication information for local node\"));\n\t\treturn ELECTION_LOST;\n\t}\n\n\t/* check if WAL replay on local node is paused */\n\tif (local_replication_info.wal_replay_paused == true)\n\t{\n\t\tlog_debug(\"WAL replay is paused\");\n\t\tif (local_replication_info.last_wal_receive_lsn > local_replication_info.last_wal_replay_lsn)\n\t\t{\n\t\t\tlog_warning(_(\"WAL replay on this node is paused and WAL is pending replay\"));\n\t\t\tlog_detail(_(\"replay paused at %X/%X; last WAL received is %X/%X\"),\n\t\t\t\t\t   format_lsn(local_replication_info.last_wal_replay_lsn),\n\t\t\t\t\t   format_lsn(local_replication_info.last_wal_receive_lsn));\n\t\t}\n\n\t\t/* attempt to resume WAL replay - unlikely this will fail, but just in case */\n\t\tif (resume_wal_replay(local_conn) == false)\n\t\t{\n\t\t\tlog_error(_(\"unable to resume WAL replay\"));\n\t\t\tlog_detail(_(\"this node cannot be reliably promoted\"));\n\t\t\treturn ELECTION_LOST;\n\t\t}\n\n\t\tlog_notice(_(\"WAL replay forcibly resumed\"));\n\t}\n\n\tlocal_node_info.last_wal_receive_lsn = local_replication_info.last_wal_receive_lsn;\n\n\tlog_info(_(\"local node's last receive lsn: %X/%X\"), format_lsn(local_node_info.last_wal_receive_lsn));\n\n\t/* pointer to \"winning\" node, initially self */\n\tcandidate_node = &local_node_info;\n\n\tinitPQExpBuffer(&nodes_with_primary_visible);\n\n\tfor (cell = sibling_nodes->head; cell; cell = cell->next)\n\t{\n\t\tReplInfo\tsibling_replication_info;\n\n\t\tlog_info(_(\"checking state of sibling node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t cell->node_info->node_name,\n\t\t\t\t cell->node_info->node_id);\n\n\t\t/* assume the worst case */\n\t\tcell->node_info->node_status = NODE_STATUS_UNKNOWN;\n\n\t\tcell->node_info->conn = establish_db_connection(cell->node_info->conninfo, false);\n\n\t\tif (PQstatus(cell->node_info->conn) != CONNECTION_OK)\n\t\t{\n\t\t\tclose_connection(&cell->node_info->conn);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tcell->node_info->node_status = NODE_STATUS_UP;\n\n\t\tstats.visible_nodes++;\n\n\t\t/*\n\t\t * see if the node is in the primary's location (but skip the check if\n\t\t * we've seen a node there already)\n\t\t */\n\t\tif (primary_location_seen == false)\n\t\t{\n\t\t\tif (strncmp(cell->node_info->location, upstream_node_info.location, MAXLEN) == 0)\n\t\t\t{\n\t\t\t\tlog_debug(\"node %i in primary location \\\"%s\\\"\",\n\t\t\t\t\t\t  cell->node_info->node_id,\n\t\t\t\t\t\t  cell->node_info->location);\n\t\t\t\tprimary_location_seen = true;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * check if repmgrd running - skip if not\n\t\t *\n\t\t * TODO: include pid query in replication info query?\n\t\t *\n\t\t * NOTE: from Pg12 we could execute \"pg_promote()\" from a running repmgrd;\n\t\t * here we'll need to find a way of ensuring only one repmgrd does this\n\t\t */\n\t\tif (repmgrd_get_pid(cell->node_info->conn) == UNKNOWN_PID)\n\t\t{\n\t\t\tlog_warning(_(\"repmgrd not running on node \\\"%s\\\" (ID: %i), skipping\"),\n\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\tcell->node_info->node_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (get_replication_info(cell->node_info->conn, cell->node_info->type, &sibling_replication_info) == false)\n\t\t{\n\t\t\tlog_warning(_(\"unable to retrieve replication information for node \\\"%s\\\" (ID: %i), skipping\"),\n\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\tcell->node_info->node_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check if node is not in recovery - it may have been promoted\n\t\t * outside of the failover mechanism, in which case we may be able\n\t\t * to follow it.\n\t\t */\n\n\t\tif (sibling_replication_info.in_recovery == false && cell->node_info->type != WITNESS)\n\t\t{\n\t\t\tbool can_follow;\n\n\t\t\tlog_warning(_(\"node \\\"%s\\\" (ID: %i) is not in recovery\"),\n\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\tcell->node_info->node_id);\n\n\t\t\t/*\n\t\t\t * Node is not in recovery, but still reporting an upstream\n\t\t\t * node ID; possible it was promoted manually (e.g. with \"pg_ctl promote\"),\n\t\t\t * or (less likely) the node's repmgrd has just switched to primary\n\t\t\t * monitoring node but has not yet unset the upstream node ID in\n\t\t\t * shared memory. Either way, log this.\n\t\t\t */\n\t\t\tif (sibling_replication_info.upstream_node_id != UNKNOWN_NODE_ID)\n\t\t\t{\n\t\t\t\tlog_warning(_(\"node \\\"%s\\\" (ID: %i) still reports its upstream is node %i, last seen %i second(s) ago\"),\n\t\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\t\tcell->node_info->node_id,\n\t\t\t\t\t\t\tsibling_replication_info.upstream_node_id,\n\t\t\t\t\t\t\tsibling_replication_info.upstream_last_seen);\n\t\t\t}\n\t\t\tcan_follow = check_node_can_follow(local_conn,\n\t\t\t\t\t\t\t\t\t\t\t   local_node_info.last_wal_receive_lsn,\n\t\t\t\t\t\t\t\t\t\t\t   cell->node_info->conn,\n\t\t\t\t\t\t\t\t\t\t\t   cell->node_info);\n\n\t\t\tif (can_follow == true)\n\t\t\t{\n\t\t\t\t*new_primary_id = cell->node_info->node_id;\n\t\t\t\ttermPQExpBuffer(&nodes_with_primary_visible);\n\t\t\t\treturn ELECTION_CANCELLED;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Tricky situation here - we'll assume the node is a rogue primary\n\t\t\t */\n\t\t\tlog_warning(_(\"not possible to attach to node \\\"%s\\\" (ID: %i), ignoring\"),\n\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\tcell->node_info->node_id);\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_info(_(\"node \\\"%s\\\" (ID: %i) reports its upstream is node %i, last seen %i second(s) ago\"),\n\t\t\t\t\t cell->node_info->node_name,\n\t\t\t\t\t cell->node_info->node_id,\n\t\t\t\t\t sibling_replication_info.upstream_node_id,\n\t\t\t\t\t sibling_replication_info.upstream_last_seen);\n\t\t}\n\n\t\t/* check if WAL replay on node is paused */\n\t\tif (sibling_replication_info.wal_replay_paused == true)\n\t\t{\n\t\t\t/*\n\t\t\t * Theoretically the repmgrd on the node should have resumed WAL play\n\t\t\t * at this point.\n\t\t\t */\n\t\t\tif (sibling_replication_info.last_wal_receive_lsn > sibling_replication_info.last_wal_replay_lsn)\n\t\t\t{\n\t\t\t\tlog_warning(_(\"WAL replay on node \\\"%s\\\" (ID: %i) is paused and WAL is pending replay\"),\n\t\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\t\tcell->node_info->node_id);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Check if node has seen primary \"recently\" - if so, we may have \"partial primary visibility\".\n\t\t * For now we'll assume the primary is visible if it's been seen less than\n\t\t * monitor_interval_secs * 2 seconds ago. We may need to adjust this, and/or make the value\n\t\t * configurable.\n\t\t */\n\n\t\tif (sibling_replication_info.upstream_last_seen >= 0 && sibling_replication_info.upstream_last_seen < (config_file_options.monitor_interval_secs * 2))\n\t\t{\n\t\t\tif (sibling_replication_info.upstream_node_id != upstream_node_info.node_id)\n\t\t\t{\n\t\t\t\tlog_warning(_(\"assumed sibling node \\\"%s\\\" (ID: %i) monitoring different upstream node %i\"),\n\t\t\t\t\t\t\tcell->node_info->node_name,\n\t\t\t\t\t\t\tcell->node_info->node_id,\n\t\t\t\t\t\t\tsibling_replication_info.upstream_node_id);\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnodes_with_primary_still_visible++;\n\t\t\t\tlog_notice(_(\"%s node \\\"%s\\\" (ID: %i) last saw primary node %i second(s) ago, considering primary still visible\"),\n\t\t\t\t\t\t   get_node_type_string(cell->node_info->type),\n\t\t\t\t\t\t   cell->node_info->node_name,\n\t\t\t\t\t\t   cell->node_info->node_id,\n\t\t\t\t\t\t   sibling_replication_info.upstream_last_seen);\n\t\t\t\tappendPQExpBuffer(&nodes_with_primary_visible,\n\t\t\t\t\t\t\t\t  \" - node \\\"%s\\\" (ID: %i): %i second(s) ago\\n\",\n\t\t\t\t\t\t\t\t  cell->node_info->node_name,\n\t\t\t\t\t\t\t\t  cell->node_info->node_id,\n\t\t\t\t\t\t\t\t  sibling_replication_info.upstream_last_seen);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_info(_(\"%s node \\\"%s\\\" (ID: %i) last saw primary node %i second(s) ago\"),\n\t\t\t\t\t get_node_type_string(cell->node_info->type),\n\t\t\t\t\t cell->node_info->node_name,\n\t\t\t\t\t cell->node_info->node_id,\n\t\t\t\t\t sibling_replication_info.upstream_last_seen);\n\t\t}\n\n\n\t\t/* don't interrogate a witness server */\n\t\tif (cell->node_info->type == WITNESS)\n\t\t{\n\t\t\tlog_debug(\"node %i is witness, not querying state\", cell->node_info->node_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* don't check 0-priority nodes */\n\t\tif (cell->node_info->priority <= 0)\n\t\t{\n\t\t\tlog_info(_(\"node \\\"%s\\\" (ID: %i) has priority of %i, skipping\"),\n\t\t\t\t\t   cell->node_info->node_name,\n\t\t\t\t\t   cell->node_info->node_id,\n\t\t\t\t\t   cell->node_info->priority);\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t/* get node's last receive LSN - if \"higher\" than current winner, current node is candidate */\n\t\tcell->node_info->last_wal_receive_lsn = sibling_replication_info.last_wal_receive_lsn;\n\n\t\tlog_info(_(\"last receive LSN for sibling node \\\"%s\\\" (ID: %i) is: %X/%X\"),\n\t\t\t\t cell->node_info->node_name,\n\t\t\t\t cell->node_info->node_id,\n\t\t\t\t format_lsn(cell->node_info->last_wal_receive_lsn));\n\n\t\t/* compare LSN */\n\t\tif (cell->node_info->last_wal_receive_lsn > candidate_node->last_wal_receive_lsn)\n\t\t{\n\t\t\t/* other node is ahead */\n\t\t\tlog_info(_(\"node \\\"%s\\\" (ID: %i) is ahead of current candidate \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t cell->node_info->node_name,\n\t\t\t\t\t cell->node_info->node_id,\n\t\t\t\t\t candidate_node->node_name,\n\t\t\t\t\t candidate_node->node_id);\n\n\t\t\tcandidate_node = cell->node_info;\n\t\t}\n\t\t/* LSN is same - tiebreak on priority, then node_id */\n\t\telse if (cell->node_info->last_wal_receive_lsn == candidate_node->last_wal_receive_lsn)\n\t\t{\n\t\t\tlog_info(_(\"node \\\"%s\\\" (ID: %i) has same LSN as current candidate \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t cell->node_info->node_name,\n\t\t\t\t\t cell->node_info->node_id,\n\t\t\t\t\t candidate_node->node_name,\n\t\t\t\t\t candidate_node->node_id);\n\n\t\t\tif (cell->node_info->priority > candidate_node->priority)\n\t\t\t{\n\t\t\t\tlog_info(_(\"node \\\"%s\\\" (ID: %i) has higher priority (%i) than current candidate \\\"%s\\\" (ID: %i) (%i)\"),\n\t\t\t\t\t\t cell->node_info->node_name,\n\t\t\t\t\t\t cell->node_info->node_id,\n\t\t\t\t\t\t cell->node_info->priority,\n\t\t\t\t\t\t candidate_node->node_name,\n\t\t\t\t\t\t candidate_node->node_id,\n\t\t\t\t\t\t candidate_node->priority);\n\n\t\t\t\tcandidate_node = cell->node_info;\n\t\t\t}\n\t\t\telse if (cell->node_info->priority == candidate_node->priority)\n\t\t\t{\n\t\t\t\tif (cell->node_info->node_id < candidate_node->node_id)\n\t\t\t\t{\n\t\t\t\t\tlog_info(_(\"node \\\"%s\\\" (ID: %i) has same priority but lower node_id than current candidate \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t\t\t cell->node_info->node_name,\n\t\t\t\t\t\t\t cell->node_info->node_id,\n\t\t\t\t\t\t\t candidate_node->node_name,\n\t\t\t\t\t\t\t candidate_node->node_id);\n\n\t\t\t\t\tcandidate_node = cell->node_info;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog_info(_(\"node \\\"%s\\\" (ID: %i) has lower priority (%i) than current candidate \\\"%s\\\" (ID: %i) (%i)\"),\n\t\t\t\t\t\t cell->node_info->node_name,\n\t\t\t\t\t\t cell->node_info->node_id,\n\t\t\t\t\t\t cell->node_info->priority,\n\t\t\t\t\t\t candidate_node->node_name,\n\t\t\t\t\t\t candidate_node->node_id,\n\t\t\t\t\t\t candidate_node->priority);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (primary_location_seen == false)\n\t{\n\t\tlog_notice(_(\"no nodes from the primary location \\\"%s\\\" visible - assuming network split\"),\n\t\t\t\t   upstream_node_info.location);\n\t\tlog_detail(_(\"node will enter degraded monitoring state waiting for reconnect\"));\n\n\t\tmonitoring_state = MS_DEGRADED;\n\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\n\t\treset_node_voting_status();\n\n\t\ttermPQExpBuffer(&nodes_with_primary_visible);\n\n\t\treturn ELECTION_CANCELLED;\n\t}\n\n\tif (nodes_with_primary_still_visible > 0)\n\t{\n\t\tlog_info(_(\"%i nodes can see the primary\"),\n\t\t\t\t   nodes_with_primary_still_visible);\n\n\t\tlog_detail(_(\"following nodes can see the primary:\\n%s\"),\n\t\t\t\t   nodes_with_primary_visible.data);\n\n\t\tif (config_file_options.primary_visibility_consensus == true)\n\t\t{\n\t\t\tlog_notice(_(\"cancelling failover as some nodes can still see the primary\"));\n\t\t\tmonitoring_state = MS_DEGRADED;\n\t\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\n\t\t\treset_node_voting_status();\n\n\t\t\ttermPQExpBuffer(&nodes_with_primary_visible);\n\n\t\t\treturn ELECTION_CANCELLED;\n\t\t}\n\t}\n\n\ttermPQExpBuffer(&nodes_with_primary_visible);\n\n\tlog_info(_(\"visible nodes: %i; total nodes: %i; no nodes have seen the primary within the last %i seconds\"),\n\t\t\t stats.visible_nodes,\n\t\t\t stats.shared_upstream_nodes,\n\t\t\t (config_file_options.monitor_interval_secs * 2));\n\n\tif (stats.visible_nodes <= (stats.shared_upstream_nodes / 2.0))\n\t{\n\t\tlog_notice(_(\"unable to reach a qualified majority of nodes\"));\n\t\tlog_detail(_(\"node will enter degraded monitoring state waiting for reconnect\"));\n\n\t\tmonitoring_state = MS_DEGRADED;\n\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\n\t\treset_node_voting_status();\n\n\t\treturn ELECTION_CANCELLED;\n\t}\n\n\tlog_notice(_(\"promotion candidate is \\\"%s\\\" (ID: %i)\"),\n\t\t\t   candidate_node->node_name,\n\t\t\t   candidate_node->node_id);\n\n\tif (candidate_node->node_id == local_node_info.node_id)\n\t{\n\t\t/*\n\t\t * If \"failover_validation_command\" is set, execute that command\n\t\t * and decide the result based on the command's output\n\t\t */\n\n\t\tif (config_file_options.failover_validation_command[0] != '\\0')\n\t\t{\n\t\t\treturn execute_failover_validation_command(candidate_node, &stats);\n\t\t}\n\n\t\treturn ELECTION_WON;\n\t}\n\n\treturn ELECTION_LOST;\n}\n\n/*\n * \"failover\" for the witness node; the witness has no part in the election\n * other than being reachable, so just needs to await notification from the\n * new primary\n */\nstatic\nbool do_witness_failover(void)\n{\n\tint new_primary_id = UNKNOWN_NODE_ID;\n\n\t/* TODO add pre-event notification here */\n\tfailover_state = FAILOVER_STATE_UNKNOWN;\n\n\tif (wait_primary_notification(&new_primary_id) == true)\n\t{\n\t\t/* if primary has reappeared, no action needed */\n\t\tif (new_primary_id == upstream_node_info.node_id)\n\t\t{\n\t\t\tfailover_state = FAILOVER_STATE_FOLLOWING_ORIGINAL_PRIMARY;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfailover_state = witness_follow_new_primary(new_primary_id);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfailover_state = FAILOVER_STATE_NO_NEW_PRIMARY;\n\t}\n\n\n\tlog_verbose(LOG_DEBUG, \"failover state is %s\",\n\t\t\t\tformat_failover_state(failover_state));\n\n\tswitch (failover_state)\n\t{\n\t\tcase FAILOVER_STATE_PRIMARY_REAPPEARED:\n\t\t\t/* pass control back down to start_monitoring() */\n\t\t\tlog_info(_(\"resuming %s monitoring mode\"),get_node_type_string(local_node_info.type));\n\t\t\tlog_detail(_(\"original primary \\\"%s\\\" (ID: %i) reappeared\"),\n\t\t\t\t\t   upstream_node_info.node_name, upstream_node_info.node_id);\n\n\t\t\tfailover_state = FAILOVER_STATE_NONE;\n\t\t\treturn true;\n\n\n\t\tcase FAILOVER_STATE_FOLLOWED_NEW_PRIMARY:\n\t\t\tlog_info(_(\"resuming %s monitoring mode\"),get_node_type_string(local_node_info.type));\n\t\t\tlog_detail(_(\"following new primary \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t   upstream_node_info.node_name, upstream_node_info.node_id);\n\t\t\tfailover_state = FAILOVER_STATE_NONE;\n\n\t\t\treturn true;\n\n\t\tcase FAILOVER_STATE_FOLLOWING_ORIGINAL_PRIMARY:\n\t\t\tlog_info(_(\"resuming %s monitoring mode\"),get_node_type_string(local_node_info.type));\n\t\t\tlog_detail(_(\"following original primary \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t   upstream_node_info.node_name, upstream_node_info.node_id);\n\t\t\tfailover_state = FAILOVER_STATE_NONE;\n\n\t\t\treturn true;\n\n\t\tcase FAILOVER_STATE_FOLLOW_FAIL:\n\t\t\t/*\n\t\t\t * for whatever reason we were unable to follow the new primary -\n\t\t\t * continue monitoring in degraded state\n\t\t\t */\n\t\t\tmonitoring_state = MS_DEGRADED;\n\t\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\n\t\t\treturn false;\n\n\t\tdefault:\n\t\t\tmonitoring_state = MS_DEGRADED;\n\t\t\tINSTR_TIME_SET_CURRENT(degraded_monitoring_start);\n\n\t\t\treturn false;\n\t}\n\t/* should never reach here */\n\treturn false;\n}\n\n\nstatic void\nreset_node_voting_status(void)\n{\n\tfailover_state = FAILOVER_STATE_NONE;\n\n\tif (PQstatus(local_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"reset_node_voting_status(): local_conn not set\"));\n\t\tlog_detail(\"\\n%s\", PQerrorMessage(local_conn));\n\t\treturn;\n\t}\n\treset_voting_status(local_conn);\n}\n\n\nstatic void\ncheck_connection(t_node_info *node_info, PGconn **conn)\n{\n\tif (is_server_available(node_info->conninfo) == false)\n\t{\n\t\tlog_warning(_(\"connection to node \\\"%s\\\" (ID: %i) lost\"),\n\t\t\t\t\tnode_info->node_name,\n\t\t\t\t\tnode_info->node_id);\n\t\tlog_detail(\"\\n%s\", PQerrorMessage(*conn));\n\n\t\tclose_connection(conn);\n\t}\n\n\tif (PQstatus(*conn) != CONNECTION_OK)\n\t{\n\t\tlog_info(_(\"attempting to reconnect to node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t node_info->node_name,\n\t\t\t\t node_info->node_id);\n\n\t\tclose_connection(conn);\n\n\t\t*conn = establish_db_connection(node_info->conninfo, false);\n\n\t\tif (PQstatus(*conn) != CONNECTION_OK)\n\t\t{\n\t\t\tclose_connection(conn);\n\n\t\t\tlog_warning(_(\"reconnection to node \\\"%s\\\" (ID: %i) failed\"),\n\t\t\t\t\t\tnode_info->node_name,\n\t\t\t\t\t\tnode_info->node_id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint \t\tstored_local_node_id = UNKNOWN_NODE_ID;\n\n\t\t\tlog_info(_(\"reconnected to node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t node_info->node_name,\n\t\t\t\t\t node_info->node_id);\n\n\t\t\tstored_local_node_id = repmgrd_get_local_node_id(*conn);\n\t\t\tif (stored_local_node_id == UNKNOWN_NODE_ID)\n\t\t\t{\n\t\t\t\trepmgrd_set_local_node_id(*conn, config_file_options.node_id);\n\t\t\t\trepmgrd_set_pid(local_conn, getpid(), pid_file);\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n\nstatic const char *\nformat_failover_state(FailoverState failover_state)\n{\n\tswitch(failover_state)\n\t{\n\t\tcase FAILOVER_STATE_UNKNOWN:\n\t\t\treturn \"UNKNOWN\";\n\t\tcase FAILOVER_STATE_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase FAILOVER_STATE_PROMOTED:\n\t\t\treturn \"PROMOTED\";\n\t\tcase FAILOVER_STATE_PROMOTION_FAILED:\n\t\t\treturn \"PROMOTION_FAILED\";\n\t\tcase FAILOVER_STATE_PRIMARY_REAPPEARED:\n\t\t\treturn \"PRIMARY_REAPPEARED\";\n\t\tcase FAILOVER_STATE_LOCAL_NODE_FAILURE:\n\t\t\treturn \"LOCAL_NODE_FAILURE\";\n\t\tcase FAILOVER_STATE_WAITING_NEW_PRIMARY:\n\t\t\treturn \"WAITING_NEW_PRIMARY\";\n\t\tcase FAILOVER_STATE_FOLLOW_NEW_PRIMARY:\n\t\t\treturn \"FOLLOW_NEW_PRIMARY\";\n\t\tcase FAILOVER_STATE_REQUIRES_MANUAL_FAILOVER:\n\t\t\treturn \"REQUIRES_MANUAL_FAILOVER\";\n\t\tcase FAILOVER_STATE_FOLLOWED_NEW_PRIMARY:\n\t\t\treturn \"FOLLOWED_NEW_PRIMARY\";\n\t\tcase FAILOVER_STATE_FOLLOWING_ORIGINAL_PRIMARY:\n\t\t\treturn \"FOLLOWING_ORIGINAL_PRIMARY\";\n\t\tcase FAILOVER_STATE_NO_NEW_PRIMARY:\n\t\t\treturn \"NO_NEW_PRIMARY\";\n\t\tcase FAILOVER_STATE_FOLLOW_FAIL:\n\t\t\treturn \"FOLLOW_FAIL\";\n\t\tcase FAILOVER_STATE_NODE_NOTIFICATION_ERROR:\n\t\t\treturn \"NODE_NOTIFICATION_ERROR\";\n\t\tcase FAILOVER_STATE_ELECTION_RERUN:\n\t\t\treturn \"ELECTION_RERUN\";\n\t}\n\n\t/* should never reach here */\n\treturn \"UNKNOWN_FAILOVER_STATE\";\n}\n\n\nstatic void\nhandle_sighup(PGconn **conn, t_server_type server_type)\n{\n\tlog_notice(_(\"received SIGHUP, reloading configuration\"));\n\n\tif (reload_config(server_type))\n\t{\n\t\tclose_connection(conn);\n\n\t\t*conn = establish_db_connection(config_file_options.conninfo, true);\n\t}\n\n\tif (*config_file_options.log_file)\n\t{\n\t\tFILE\t   *fd;\n\n\t\tlog_debug(\"reopening %s\", config_file_options.log_file);\n\n\t\tfd = freopen(config_file_options.log_file, \"a\", stderr);\n\t\tif (fd == NULL)\n\t\t{\n\t\t\tfprintf(stderr, \"error reopening stderr to \\\"%s\\\": %s\",\n\t\t\t\t\tconfig_file_options.log_file, strerror(errno));\n\t\t}\n\t}\n\n\tgot_SIGHUP = false;\n}\n\nstatic ElectionResult\nexecute_failover_validation_command(t_node_info *node_info, election_stats *stats)\n{\n\tPQExpBufferData failover_validation_command;\n\tPQExpBufferData command_output;\n\tint return_value = -1;\n\n\tinitPQExpBuffer(&failover_validation_command);\n\tinitPQExpBuffer(&command_output);\n\n\tparse_failover_validation_command(config_file_options.failover_validation_command,\n\t\t\t\t\t\t\t\t\t  node_info,\n\t\t\t\t\t\t\t\t\t  stats,\n\t\t\t\t\t\t\t\t\t  &failover_validation_command);\n\n\tlog_notice(_(\"executing \\\"failover_validation_command\\\"\"));\n\tlog_detail(\"%s\", failover_validation_command.data);\n\n\t/* we determine success of the command by the value placed into return_value */\n\t(void) local_command_return_value(failover_validation_command.data,\n\t\t\t\t\t\t\t\t\t  &command_output,\n\t\t\t\t\t\t\t\t\t  &return_value);\n\n\ttermPQExpBuffer(&failover_validation_command);\n\n\tif (command_output.data[0] != '\\0')\n\t{\n\t\tlog_info(\"output returned by failover validation command:\\n%s\", command_output.data);\n\t}\n\telse\n\t{\n\t\tlog_info(_(\"no output returned from command\"));\n\t}\n\n\ttermPQExpBuffer(&command_output);\n\n\tif (return_value != 0)\n\t{\n\t\t/* create event here? */\n\t\tlog_notice(_(\"failover validation command returned a non-zero value: %i\"),\n\t\t\t\t   return_value);\n\t\treturn ELECTION_RERUN;\n\t}\n\n\tlog_notice(_(\"failover validation command returned zero\"));\n\n\treturn ELECTION_WON;\n}\n\n\nstatic void\nparse_failover_validation_command(const char *template, t_node_info *node_info, election_stats *stats, PQExpBufferData *out)\n{\n\tconst char *src_ptr;\n\n\tfor (src_ptr = template; *src_ptr; src_ptr++)\n\t{\n\t\tif (*src_ptr == '%')\n\t\t{\n\t\t\tswitch (src_ptr[1])\n\t\t\t{\n\t\t\t\tcase '%':\n\t\t\t\t\t/* %%: replace with % */\n\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\tappendPQExpBufferChar(out, *src_ptr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\t/* %n: node id */\n\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\tappendPQExpBuffer(out, \"%i\", node_info->node_id);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'a':\n\t\t\t\t\t/* %a: node name */\n\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\tappendPQExpBufferStr(out, node_info->node_name);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\t/* %v: visible nodes count */\n\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\tappendPQExpBuffer(out, \"%i\", stats->visible_nodes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\t/* %u: shared upstream nodes count */\n\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\tappendPQExpBuffer(out, \"%i\", stats->shared_upstream_nodes);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\t/* %t: total nodes count */\n\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\tappendPQExpBuffer(out, \"%i\", stats->all_nodes);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* otherwise treat the % as not special */\n\t\t\t\t\tappendPQExpBufferChar(out, *src_ptr);\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tappendPQExpBufferChar(out, *src_ptr);\n\t\t}\n\t}\n\n\treturn;\n}\n\n\n/*\n * Sanity-check whether the local node can follow the proposed upstream node.\n *\n * Note this function is very similar to check_node_can_attach() in\n * repmgr-client.c, however the later is very focussed on client-side\n * functionality (including log output related to --dry-run, pg_rewind etc.)\n * which we don't want here.\n */\nstatic bool\ncheck_node_can_follow(PGconn *local_conn, XLogRecPtr local_xlogpos, PGconn *follow_target_conn, t_node_info *follow_target_node_info)\n{\n\tPGconn\t   *local_repl_conn = NULL;\n\tt_system_identification local_identification = T_SYSTEM_IDENTIFICATION_INITIALIZER;\n\n\tPGconn\t   *follow_target_repl_conn = NULL;\n\tt_system_identification follow_target_identification = T_SYSTEM_IDENTIFICATION_INITIALIZER;\n\tTimeLineHistoryEntry *follow_target_history = NULL;\n\n\tbool can_follow = true;\n\tbool success;\n\n\tlocal_repl_conn = establish_replication_connection_from_conn(local_conn, local_node_info.repluser);\n\n\tif (PQstatus(local_repl_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to establish a replication connection to the local node\"));\n\t\tPQfinish(local_repl_conn);\n\n\t\treturn false;\n\t}\n\n\tsuccess = identify_system(local_repl_conn, &local_identification);\n\tPQfinish(local_repl_conn);\n\n\tif (success == false)\n\t{\n\t\tlog_error(_(\"unable to query the local node's system identification\"));\n\n\t\treturn false;\n\t}\n\n\t/* check replication connection */\n\tfollow_target_repl_conn = establish_replication_connection_from_conn(follow_target_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t follow_target_node_info->repluser);\n\tif (PQstatus(follow_target_repl_conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"unable to establish a replication connection to the follow target node\"));\n\n\t\tPQfinish(follow_target_repl_conn);\n\t\treturn false;\n\t}\n\n\t/* check system_identifiers match */\n\tif (identify_system(follow_target_repl_conn, &follow_target_identification) == false)\n\t{\n\t\tlog_error(_(\"unable to query the follow target node's system identification\"));\n\n\t\tPQfinish(follow_target_repl_conn);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Check for thing that should never happen, but expect the unexpected anyway.\n\t */\n\tif (follow_target_identification.system_identifier != local_identification.system_identifier)\n\t{\n\t\tlog_error(_(\"this node is not part of the follow target node's replication cluster\"));\n\t\tlog_detail(_(\"this node's system identifier is %lu, follow target node's system identifier is %lu\"),\n\t\t\t\t   local_identification.system_identifier,\n\t\t\t\t   follow_target_identification.system_identifier);\n\t\tPQfinish(follow_target_repl_conn);\n\t\treturn false;\n\t}\n\n\t/* check timelines */\n\n\tlog_verbose(LOG_DEBUG, \"local timeline: %i; follow target timeline: %i\",\n\t\t\t\tlocal_identification.timeline,\n\t\t\t\tfollow_target_identification.timeline);\n\n\t/* upstream's timeline is lower than ours - impossible case */\n\tif (follow_target_identification.timeline < local_identification.timeline)\n\t{\n\t\tlog_error(_(\"this node's timeline is ahead of the follow target node's timeline\"));\n\t\tlog_detail(_(\"this node's timeline is %i, follow target node's timeline is %i\"),\n\t\t\t\t   local_identification.timeline,\n\t\t\t\t   follow_target_identification.timeline);\n\t\tPQfinish(follow_target_repl_conn);\n\t\treturn false;\n\t}\n\n\t/* timeline is the same - check relative positions */\n\tif (follow_target_identification.timeline == local_identification.timeline)\n\t{\n\t\tXLogRecPtr follow_target_xlogpos = get_node_current_lsn(follow_target_conn);\n\n\t\tif (local_xlogpos == InvalidXLogRecPtr || follow_target_xlogpos == InvalidXLogRecPtr)\n\t\t{\n\t\t\tlog_error(_(\"unable to compare LSN positions\"));\n\t\t\tPQfinish(follow_target_repl_conn);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (local_xlogpos <= follow_target_xlogpos)\n\t\t{\n\t\t\tlog_info(_(\"timelines are same, this server is not ahead\"));\n\t\t\tlog_detail(_(\"local node lsn is %X/%X, follow target lsn is %X/%X\"),\n\t\t\t\t\t   format_lsn(local_xlogpos),\n\t\t\t\t\t   format_lsn(follow_target_xlogpos));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_error(_(\"this node is ahead of the follow target\"));\n\t\t\tlog_detail(_(\"local node lsn is %X/%X, follow target lsn is %X/%X\"),\n\t\t\t\t\t   format_lsn(local_xlogpos),\n\t\t\t\t\t   format_lsn(follow_target_xlogpos));\n\n\t\t\tcan_follow = false;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * upstream has higher timeline - check where it forked off from this node's timeline\n\t\t */\n\t\tfollow_target_history = get_timeline_history(follow_target_repl_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t local_identification.timeline + 1);\n\n\t\tif (follow_target_history == NULL)\n\t\t{\n\t\t\t/* get_timeline_history() will emit relevant error messages */\n\t\t\tPQfinish(follow_target_repl_conn);\n\t\t\treturn false;\n\t\t}\n\n\t\tlog_debug(\"local tli: %i; local_xlogpos: %X/%X; follow_target_history->tli: %i; follow_target_history->end: %X/%X\",\n\t\t\t\t  (int)local_identification.timeline,\n\t\t\t\t  format_lsn(local_xlogpos),\n\t\t\t\t  follow_target_history->tli,\n\t\t\t\t  format_lsn(follow_target_history->end));\n\n\t\t/*\n\t\t * Local node has proceeded beyond the follow target's fork, so we\n\t\t * definitely can't attach.\n\t\t *\n\t\t * This could be the case if the follow target was promoted, but does\n\t\t * not contain all changes which are being replayed to this standby.\n\t\t */\n\t\tif (local_xlogpos > follow_target_history->end)\n\t\t{\n\t\t\tlog_error(_(\"this node cannot attach to follow target node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t  follow_target_node_info->node_name,\n\t\t\t\t\t  follow_target_node_info->node_id);\n\t\t\tcan_follow = false;\n\n\t\t\tlog_detail(_(\"follow target server's timeline %lu forked off current database system timeline %lu before current recovery point %X/%X\"),\n\t\t\t\t\t   local_identification.system_identifier + 1,\n\t\t\t\t\t   local_identification.system_identifier,\n\t\t\t\t\t   format_lsn(local_xlogpos));\n\t\t}\n\n\t\tif (can_follow == true)\n\t\t{\n\t\t\tlog_info(_(\"local node \\\"%s\\\" (ID: %i) can attach to follow target node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t config_file_options.node_name,\n\t\t\t\t\t config_file_options.node_id,\n\t\t\t\t\t follow_target_node_info->node_name,\n\t\t\t\t\t follow_target_node_info->node_id);\n\n\t\t\tlog_detail(_(\"local node's recovery point: %X/%X; follow target node's fork point: %X/%X\"),\n\t\t\t\t\t   format_lsn(local_xlogpos),\n\t\t\t\t\t   format_lsn(follow_target_history->end));\n\t\t}\n\t}\n\n\tPQfinish(follow_target_repl_conn);\n\n\tif (follow_target_history)\n\t\tpfree(follow_target_history);\n\n\treturn can_follow;\n}\n\n\nstatic void\ncheck_witness_attached(t_node_info *node_info, bool startup)\n{\n\t/*\n\t * connect and check upstream node id; at this point we don't care if it's\n\t * not reachable, only whether we can mark it as attached or not.\n\t */\n\tPGconn *witness_conn = establish_db_connection_quiet(node_info->conninfo);\n\n\tif (PQstatus(witness_conn) == CONNECTION_OK)\n\t{\n\t\tint witness_upstream_node_id = repmgrd_get_upstream_node_id(witness_conn);\n\n\t\tlog_debug(\"witness node %i's upstream node ID reported as %i\",\n\t\t\t\t  node_info->node_id,\n\t\t\t\t  witness_upstream_node_id);\n\n\t\tif (witness_upstream_node_id == local_node_info.node_id)\n\t\t{\n\t\t\tnode_info->attached = NODE_ATTACHED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode_info->attached = NODE_DETACHED;\n\t\t}\n\t}\n\telse\n\t{\n\t\tnode_info->attached = startup == true ? NODE_ATTACHED_UNKNOWN : NODE_DETACHED;\n\t}\n\n\tPQfinish(witness_conn);\n}\n\n\nstatic t_child_node_info *\nappend_child_node_record(t_child_node_info_list *nodes, int node_id, const char *node_name, t_server_type type, NodeAttached attached)\n{\n\tt_child_node_info *child_node = pg_malloc0(sizeof(t_child_node_info));\n\n\tchild_node->node_id = node_id;\n\tsnprintf(child_node->node_name, sizeof(child_node->node_name), \"%s\", node_name);\n\n\tchild_node->type = type;\n\tchild_node->attached = attached;\n\n\tif (nodes->tail)\n\t\tnodes->tail->next = child_node;\n\telse\n\t\tnodes->head = child_node;\n\n\tnodes->tail = child_node;\n\tnodes->node_count++;\n\n\treturn child_node;\n}\n\n\nstatic void\nremove_child_node_record(t_child_node_info_list *nodes, int node_id)\n{\n\tt_child_node_info *node;\n\tt_child_node_info *prev_node = NULL;\n\tt_child_node_info *next_node = NULL;\n\n\tnode = nodes->head;\n\n\twhile (node != NULL)\n\t{\n\t\tnext_node = node->next;\n\n\t\tif (node->node_id == node_id)\n\t\t{\n\t\t\t/* first node */\n\t\t\tif (node == nodes->head)\n\t\t\t{\n\t\t\t\tnodes->head = next_node;\n\t\t\t}\n\t\t\t/* last node */\n\t\t\telse if (next_node == NULL)\n\t\t\t{\n\t\t\t\tprev_node->next = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprev_node->next = next_node;\n\t\t\t}\n\t\t\tpfree(node);\n\t\t\tnodes->node_count--;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprev_node = node;\n\t\t}\n\t\tnode = next_node;\n\t}\n}\n\nstatic void\nclear_child_node_info_list(t_child_node_info_list *nodes)\n{\n\tt_child_node_info *node;\n\tt_child_node_info *next_node;\n\n\tnode = nodes->head;\n\n\twhile (node != NULL)\n\t{\n\t\tnext_node = node->next;\n\t\tpfree(node);\n\t\tnode = next_node;\n\t}\n\n\tnodes->head = NULL;\n\tnodes->tail = NULL;\n\tnodes->node_count = 0;\n}\n\n\nstatic void\nparse_child_nodes_disconnect_command(char *parsed_command, char *template, int reporting_node_id)\n{\n\tconst char *src_ptr = NULL;\n\tchar\t   *dst_ptr = NULL;\n\tchar\t   *end_ptr = NULL;\n\n\tdst_ptr = parsed_command;\n\tend_ptr = (parsed_command + MAXPGPATH) - 1;\n\t*end_ptr = '\\0';\n\n\tfor (src_ptr = template; *src_ptr; src_ptr++)\n\t{\n\t\tif (*src_ptr == '%')\n\t\t{\n\t\t\tswitch (src_ptr[1])\n\t\t\t{\n\t\t\t\tcase '%':\n\t\t\t\t\t/* %%: replace with % */\n\t\t\t\t\tif (dst_ptr < end_ptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\t\t*dst_ptr++ = *src_ptr;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\t/* %p: node id of the reporting primary */\n\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\tsnprintf(dst_ptr, end_ptr - dst_ptr, \"%i\", reporting_node_id);\n\t\t\t\t\tdst_ptr += strlen(dst_ptr);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (dst_ptr < end_ptr)\n\t\t\t\t*dst_ptr++ = *src_ptr;\n\t\t}\n\t}\n\n\t*dst_ptr = '\\0';\n\n\treturn;\n}\n\n\nint\ntry_primary_reconnect(PGconn **conn, PGconn *local_conn, t_node_info *node_info)\n{\n\tt_conninfo_param_list conninfo_params = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\tint\t\t\ti;\n\tint\t\t\tmax_attempts = config_file_options.reconnect_attempts;\n\n\tinitialize_conninfo_params(&conninfo_params, false);\n\n\t/* we assume by now the conninfo string is parseable */\n\t(void) parse_conninfo_string(node_info->conninfo, &conninfo_params, NULL, false);\n\n\t/* set some default values if not explicitly provided */\n\tparam_set_ine(&conninfo_params, \"connect_timeout\", \"2\");\n\tparam_set_ine(&conninfo_params, \"fallback_application_name\", \"repmgr\");\n\n\tfor (i = 0; i < max_attempts; i++)\n\t{\n\t\ttime_t started_at = time(NULL);\n\t\tint up_to;\n\t\tbool sleep_now = false;\n\t\tint max_sleep_seconds;\n\n\t\tlog_info(_(\"checking state of node \\\"%s\\\" (ID: %i), %i of %i attempts\"),\n\t\t\t\t node_info->node_name,\n\t\t\t\t node_info->node_id,\n\t\t\t\t i + 1, max_attempts);\n\n\t\tif (is_server_available_params(&conninfo_params) == true)\n\t\t{\n\t\t\tPGconn\t   *our_conn;\n\n\t\t\tlog_notice(_(\"node \\\"%s\\\" (ID: %i) has recovered, reconnecting\"),\n\t\t\t\t\t   node_info->node_name,\n\t\t\t\t\t   node_info->node_id);\n\n\t\t\t/*\n\t\t\t * Note: we could also handle the case where node is pingable but\n\t\t\t * connection denied due to connection exhaustion, by falling back to\n\t\t\t * degraded monitoring (make configurable)\n\t\t\t */\n\t\t\tour_conn = establish_db_connection_by_params(&conninfo_params, false);\n\n\t\t\tif (PQstatus(our_conn) == CONNECTION_OK)\n\t\t\t{\n\t\t\t\tfree_conninfo_params(&conninfo_params);\n\n\t\t\t\tlog_info(_(\"connection to node \\\"%s\\\" (ID: %i) succeeded\"),\n\t\t\t\t\t\t node_info->node_name,\n\t\t\t\t\t\t node_info->node_id);\n\n\t\t\t\tif (PQstatus(*conn) == CONNECTION_BAD)\n\t\t\t\t{\n\t\t\t\t\tlog_verbose(LOG_INFO, _(\"original connection handle returned CONNECTION_BAD, using new connection\"));\n\t\t\t\t\tclose_connection(conn);\n\t\t\t\t\t*conn = our_conn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tExecStatusType ping_result;\n\n\t\t\t\t\tping_result = connection_ping(*conn);\n\n\t\t\t\t\tif (ping_result != PGRES_TUPLES_OK)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_info(_(\"original connection no longer available, using new connection\"));\n\t\t\t\t\t\tclose_connection(conn);\n\t\t\t\t\t\t*conn = our_conn;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_info(_(\"original connection is still available\"));\n\n\t\t\t\t\t\tPQfinish(our_conn);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnode_info->node_status = NODE_STATUS_UP;\n\n\t\t\t\treturn UNKNOWN_NODE_ID;\n\t\t\t}\n\n\t\t\tclose_connection(&our_conn);\n\t\t\tlog_notice(_(\"unable to reconnect to node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t   node_info->node_name,\n\t\t\t\t\t   node_info->node_id);\n\t\t}\n\n\t\t/*\n\t\t * Experimental behaviour, see GitHub #662.\n\t\t */\n\t\tif (config_file_options.reconnect_loop_sync == true)\n\t\t{\n\t\t\tup_to = (time(NULL) - started_at);\n\t\t\tmax_sleep_seconds = (up_to == 0)\n\t\t\t\t? config_file_options.reconnect_interval\n\t\t\t\t: (up_to % config_file_options.reconnect_interval);\n\t\t\tif (i + 1 <= max_attempts)\n\t\t\t\tsleep_now = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmax_sleep_seconds = config_file_options.reconnect_interval;\n\t\t\tif (i + 1 < max_attempts)\n\t\t\t\tsleep_now = true;\n\t\t}\n\n\t\tif (sleep_now == true)\n\t\t{\n\t\t\tint j;\n\t\t\tlog_info(_(\"sleeping up to %i seconds until next reconnection attempt\"),\n\t\t\t\t\t max_sleep_seconds);\n\t\t\tfor (j = 0; j < max_sleep_seconds; j++)\n\t\t\t{\n\t\t\t\tint new_primary_node_id;\n\t\t\t\tif (get_new_primary(local_conn, &new_primary_node_id) == true && new_primary_node_id != UNKNOWN_NODE_ID)\n\t\t\t\t{\n\t\t\t\t\tif (new_primary_node_id == ELECTION_RERUN_NOTIFICATION)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_notice(_(\"received rerun notification\"));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_notice(_(\"received notification that new primary is node %i\"), new_primary_node_id);\n\t\t\t\t\t}\n\n\t\t\t\t\tfree_conninfo_params(&conninfo_params);\n\t\t\t\t\treturn new_primary_node_id;\n\t\t\t\t}\n\t\t\t\tsleep(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tlog_warning(_(\"unable to reconnect to node \\\"%s\\\" (ID: %i) after %i attempts\"),\n\t\t\t\tnode_info->node_name,\n\t\t\t\tnode_info->node_id,\n\t\t\t\tmax_attempts);\n\n\tnode_info->node_status = NODE_STATUS_DOWN;\n\n\tfree_conninfo_params(&conninfo_params);\n\n\treturn UNKNOWN_NODE_ID;\n}\n"
        },
        {
          "name": "repmgrd-physical.h",
          "type": "blob",
          "size": 1.013671875,
          "content": "/*\n * repmgrd-physical.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _REPMGRD_PHYSICAL_H_\n#define _REPMGRD_PHYSICAL_H_\n\nvoid\t\tdo_physical_node_check(PGconn *conn);\n\nvoid\t\tmonitor_streaming_primary(void);\nvoid\t\tmonitor_streaming_standby(void);\nvoid\t\tmonitor_streaming_witness(void);\n\nvoid\t\thandle_sigint_physical(SIGNAL_ARGS);\n\n#endif\t\t\t\t\t\t\t/* _REPMGRD_PHYSICAL_H_ */\n"
        },
        {
          "name": "repmgrd.c",
          "type": "blob",
          "size": 25.7548828125,
          "content": "/*\n * repmgrd.c - Replication manager daemon\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdio.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n\n\n#include \"repmgr.h\"\n#include \"repmgrd.h\"\n#include \"repmgrd-physical.h\"\n#include \"configfile.h\"\n#include \"voting.h\"\n\n#define OPT_HELP\t1\n\n\nstatic char *config_file = NULL;\nstatic bool verbose = false;\nchar pid_file[MAXPGPATH];\nstatic bool daemonize = true;\nstatic bool show_pid_file = false;\nstatic bool no_pid_file = false;\n\nt_node_info local_node_info = T_NODE_INFO_INITIALIZER;\nPGconn\t   *local_conn = NULL;\n\n/* Collate command line errors here for friendlier reporting */\nstatic ItemList cli_errors = {NULL, NULL};\n\nbool\t\tstartup_event_logged = false;\n\nMonitoringState monitoring_state = MS_NORMAL;\ninstr_time\tdegraded_monitoring_start;\n\n/*\n * Record receipt of SIGHUP; will cause configuration file to be reread\n * at the appropriate point in the main loop.\n */\nvolatile sig_atomic_t got_SIGHUP = false;\n\nstatic void show_help(void);\nstatic void show_usage(void);\nstatic void daemonize_process(void);\nstatic void check_and_create_pid_file(const char *pid_file);\n\nstatic void start_monitoring(void);\n\n\n#ifndef WIN32\nstatic void setup_event_handlers(void);\nstatic void handle_sighup(SIGNAL_ARGS);\n#endif\n\nint\t\t\tcalculate_elapsed(instr_time start_time);\nvoid\t\tupdate_registration(PGconn *conn);\nvoid\t\tterminate(int retval);\n\nint\nmain(int argc, char **argv)\n{\n\tint\t\t\toptindex;\n\tint\t\t\tc;\n\tchar\t\tcli_log_level[MAXLEN] = \"\";\n\tbool\t\tcli_monitoring_history = false;\n\n\tRecordStatus record_status;\n\tExtensionStatus extension_status = REPMGR_UNKNOWN;\n\tt_extension_versions extversions = T_EXTENSION_VERSIONS_INITIALIZER;\n\n\tFILE\t   *fd;\n\n\tstatic struct option long_options[] =\n\t{\n/* general options */\n\t\t{\"help\", no_argument, NULL, OPT_HELP},\n\t\t{\"version\", no_argument, NULL, 'V'},\n\n/* configuration options */\n\t\t{\"config-file\", required_argument, NULL, 'f'},\n\n/* daemon options */\n\t\t{\"daemonize-short\", optional_argument, NULL, 'd'},\n\t\t{\"daemonize\", optional_argument, NULL, OPT_DAEMONIZE},\n\t\t{\"pid-file\", required_argument, NULL, 'p'},\n\t\t{\"show-pid-file\", no_argument, NULL, 's'},\n\t\t{\"no-pid-file\", no_argument, NULL, OPT_NO_PID_FILE},\n\n/* logging options */\n\t\t{\"log-level\", required_argument, NULL, 'L'},\n\t\t{\"verbose\", no_argument, NULL, 'v'},\n\n/* legacy options */\n\t\t{\"monitoring-history\", no_argument, NULL, 'm'},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\n\tset_progname(argv[0]);\n\n\t/* Disallow running as root */\n\tif (geteuid() == 0)\n\t{\n\t\tfprintf(stderr,\n\t\t\t\t_(\"%s: cannot be run as root\\n\"\n\t\t\t\t  \"Please log in (using, e.g., \\\"su\\\") as the \"\n\t\t\t\t  \"(unprivileged) user that owns \"\n\t\t\t\t  \"the data directory.\\n\"\n\t\t\t\t  ),\n\t\t\t\tprogname());\n\t\texit(1);\n\t}\n\n\tsrand(time(NULL));\n\n\tmemset(pid_file, 0, MAXPGPATH);\n\n\twhile ((c = getopt_long(argc, argv, \"?Vf:L:vdp:sm\", long_options, &optindex)) != -1)\n\t{\n\t\tswitch (c)\n\t\t{\n\n\t\t\t\t/* general options */\n\n\t\t\tcase '?':\n\t\t\t\t/* Actual help option given */\n\t\t\t\tif (strcmp(argv[optind - 1], \"-?\") == 0)\n\t\t\t\t{\n\t\t\t\t\tshow_help();\n\t\t\t\t\texit(SUCCESS);\n\t\t\t\t}\n\t\t\t\t/* unknown option reported by getopt */\n\t\t\t\tgoto unknown_option;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_HELP:\n\t\t\t\tshow_help();\n\t\t\t\texit(SUCCESS);\n\n\t\t\tcase 'V':\n\n\t\t\t\t/*\n\t\t\t\t * in contrast to repmgr3 and earlier, we only display the\n\t\t\t\t * repmgr version as it's not specific to a particular\n\t\t\t\t * PostgreSQL version\n\t\t\t\t */\n\t\t\t\tprintf(\"%s %s\\n\", progname(), REPMGR_VERSION);\n\t\t\t\texit(SUCCESS);\n\n\t\t\t\t/* configuration options */\n\n\t\t\tcase 'f':\n\t\t\t\tconfig_file = optarg;\n\t\t\t\tbreak;\n\n\t\t\t\t/* daemon options */\n\n\t\t\tcase 'd':\n\t\t\t\tdaemonize = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_DAEMONIZE:\n\t\t\t\tdaemonize = parse_bool(optarg, \"-d/--daemonize\", &cli_errors);\n\t\t\t\tbreak;\n\n\t\t\tcase 'p':\n\t\t\t\tstrncpy(pid_file, optarg, MAXPGPATH);\n\t\t\t\tbreak;\n\n\t\t\tcase 's':\n\t\t\t\tshow_pid_file = true;\n\t\t\t\tbreak;\n\n\t\t\tcase OPT_NO_PID_FILE:\n\t\t\t\tno_pid_file = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/* logging options */\n\n\t\t\t\t/* -L/--log-level */\n\t\t\tcase 'L':\n\t\t\t\t{\n\t\t\t\t\tint\t\t\tdetected_cli_log_level = detect_log_level(optarg);\n\n\t\t\t\t\tif (detected_cli_log_level != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrncpy(cli_log_level, optarg, MAXLEN);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tPQExpBufferData invalid_log_level;\n\n\t\t\t\t\t\tinitPQExpBuffer(&invalid_log_level);\n\t\t\t\t\t\tappendPQExpBuffer(&invalid_log_level,\n\t\t\t\t\t\t\t\t\t\t  _(\"invalid log level \\\"%s\\\" provided\"),\n\t\t\t\t\t\t\t\t\t\t  optarg);\n\t\t\t\t\t\titem_list_append(&cli_errors, invalid_log_level.data);\n\t\t\t\t\t\ttermPQExpBuffer(&invalid_log_level);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase 'v':\n\t\t\t\tverbose = true;\n\t\t\t\tbreak;\n\n\t\t\t\t/* legacy options */\n\n\t\t\tcase 'm':\n\t\t\t\tcli_monitoring_history = true;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\tunknown_option:\n\t\t\t\tshow_usage();\n\t\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\t/* Exit here already if errors in command line options found */\n\tif (cli_errors.head != NULL)\n\t{\n\t\texit_with_cli_errors(&cli_errors, NULL);\n\t}\n\n\tstartup_event_logged = false;\n\n\t/*\n\t * Tell the logger we're a daemon - this will ensure any output logged\n\t * before the logger is initialized will be formatted correctly\n\t */\n\tlogger_output_mode = OM_DAEMON;\n\n\t/*\n\t * Parse the configuration file, if provided (if no configuration file was\n\t * provided, an attempt will be made to find one in one of the default\n\t * locations). If no configuration file is available, or it can't be parsed\n\t * parse_config() will abort anyway, with an appropriate message.\n\t */\n\tload_config(config_file, verbose, false, argv[0]);\n\n\t/* Determine pid file location, unless --no-pid-file supplied */\n\n\tif (no_pid_file == false)\n\t{\n\t\tif (config_file_options.repmgrd_pid_file[0] != '\\0')\n\t\t{\n\t\t\tif (pid_file[0] != '\\0')\n\t\t\t{\n\t\t\t\tlog_warning(_(\"\\\"repmgrd_pid_file\\\" will be overridden by --pid-file\"));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrncpy(pid_file, config_file_options.repmgrd_pid_file, MAXPGPATH);\n\t\t\t}\n\t\t}\n\n\t\t/* no pid file provided - determine location */\n\t\tif (pid_file[0] == '\\0')\n\t\t{\n\t\t\t/* packagers: if feasible, patch PID file path into \"package_pid_file\" */\n\t\t\tchar\t\tpackage_pid_file[MAXPGPATH] = \"\";\n\n\t\t\tif (package_pid_file[0] != '\\0')\n\t\t\t{\n\t\t\t\tmaxpath_snprintf(pid_file, \"%s\", package_pid_file);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst char *tmpdir = getenv(\"TMPDIR\");\n\n\t\t\t\tif (!tmpdir)\n\t\t\t\t\ttmpdir = \"/tmp\";\n\n\t\t\t\tmaxpath_snprintf(pid_file, \"%s/repmgrd.pid\", tmpdir);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* --no-pid-file supplied - overwrite any value provided with --pid-file ... */\n\t\tmemset(pid_file, 0, MAXPGPATH);\n\t}\n\n\n\t/* If --show-pid-file supplied, output the location (if set) and exit */\n\n\tif (show_pid_file == true)\n\t{\n\t\tprintf(\"%s\\n\", pid_file);\n\t\texit(SUCCESS);\n\t}\n\n\n\t/* Some configuration file items can be overridden by command line options */\n\n\t/*\n\t * Command-line parameter -L/--log-level overrides any setting in config\n\t * file\n\t */\n\tif (*cli_log_level != '\\0')\n\t{\n\t\tstrncpy(config_file_options.log_level, cli_log_level, MAXLEN);\n\t}\n\n\t/*\n\t * -m/--monitoring-history, if provided, will override repmgr.conf's\n\t * monitoring_history; this is for backwards compatibility as it's\n\t * possible this may be baked into various startup scripts.\n\t */\n\n\tif (cli_monitoring_history == true)\n\t{\n\t\tconfig_file_options.monitoring_history = true;\n\t}\n\n\tfd = freopen(\"/dev/null\", \"r\", stdin);\n\tif (fd == NULL)\n\t{\n\t\tfprintf(stderr, \"error reopening stdin to \\\"/dev/null\\\":\\n  %s\\n\",\n\t\t\t\tstrerror(errno));\n\t}\n\n\tfd = freopen(\"/dev/null\", \"w\", stdout);\n\tif (fd == NULL)\n\t{\n\t\tfprintf(stderr, \"error reopening stdout to \\\"/dev/null\\\":\\n  %s\\n\",\n\t\t\t\tstrerror(errno));\n\t}\n\n\tlogger_init(&config_file_options, progname());\n\n\tlog_notice(_(\"repmgrd (%s %s) starting up\"), progname(), REPMGR_VERSION);\n\n\tif (verbose)\n\t\tlogger_set_verbose();\n\n\tif (log_type == REPMGR_SYSLOG)\n\t{\n\t\tfd = freopen(\"/dev/null\", \"w\", stderr);\n\n\t\tif (fd == NULL)\n\t\t{\n\t\t\tfprintf(stderr, \"error reopening stderr to \\\"/dev/null\\\":\\n  %s\\n\",\n\t\t\t\t\tstrerror(errno));\n\t\t}\n\t}\n\n\tlog_info(_(\"connecting to database \\\"%s\\\"\"),\n\t\t\t config_file_options.conninfo);\n\n\t/* abort if local node not available at startup */\n\tlocal_conn = establish_db_connection(config_file_options.conninfo, true);\n\n\t/*\n\t * sanity checks\n\t *\n\t * Note: previous repmgr versions checked the PostgreSQL version at this\n\t * point, but we'll skip that and assume the presence of a node record\n\t * means we're dealing with a supported installation.\n\t *\n\t * The absence of a node record will also indicate that either the node or\n\t * repmgr has not been properly configured.\n\t */\n\n\n\t/* warn about any settings which might not be relevant for the current PostgreSQL version  */\n\tif (config_file_options.standby_disconnect_on_failover == true && PQserverVersion(local_conn) < 90500)\n\t{\n\t\tlog_warning(_(\"\\\"standby_disconnect_on_failover\\\" specified, but not available for this PostgreSQL version\"));\n\t\t/* TODO: format server version */\n\t\tlog_detail(_(\"available from PostgreSQL 9.5, this PostgreSQL version is %i\"), PQserverVersion(local_conn));\n\t}\n\n\t/* Check \"repmgr\" the extension is installed */\n\textension_status = get_repmgr_extension_status(local_conn, &extversions);\n\n\tif (extension_status == REPMGR_INSTALLED)\n\t{\n\t\t/*\n\t\t * extension is the latest available according to \"pg_available_extensions\" -\n\t\t * - does our (major) version match that?\n\t\t */\n\t\tlog_verbose(LOG_DEBUG, \"expected extension version: %i; extension version: %i\",\n\t\t\t\t\tREPMGR_EXTENSION_NUM, extversions.installed_version_num);\n\t\tif ((REPMGR_EXTENSION_NUM/100) < (extversions.installed_version_num / 100))\n\t\t{\n\t\t\tlog_error(_(\"this \\\"repmgr\\\" version is older than the installed \\\"repmgr\\\" extension version\"));\n\t\t\tlog_detail(_(\"\\\"repmgr\\\" version %s providing extension version %s is installed but extension is version %s\"),\n\t\t\t\t\t   REPMGR_VERSION,\n\t\t\t\t\t   REPMGR_EXTENSION_VERSION,\n\t\t\t\t\t   extversions.installed_version);\n\t\t\tlog_hint(_(\"update the repmgr binaries to match the installed extension version\"));\n\n\t\t\tclose_connection(&local_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\n\t\tif ((REPMGR_EXTENSION_NUM/100) > (extversions.installed_version_num / 100))\n\t\t{\n\t\t\tlog_error(_(\"this \\\"repmgr\\\" version is newer than the installed \\\"repmgr\\\" extension version\"));\n\t\t\tlog_detail(_(\"\\\"repmgr\\\" version %s providing extension version %s is installed but extension is version %s\"),\n\t\t\t\t\t   REPMGR_VERSION,\n\t\t\t\t\t   REPMGR_EXTENSION_VERSION,\n\t\t\t\t\t   extversions.installed_version);\n\t\t\tlog_hint(_(\"update the installed extension version by executing \\\"ALTER EXTENSION repmgr UPDATE\\\" in the repmgr database\"));\n\n\t\t\tclose_connection(&local_conn);\n\t\t\texit(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* this is unlikely to happen */\n\t\tif (extension_status == REPMGR_UNKNOWN)\n\t\t{\n\t\t\tlog_error(_(\"unable to determine status of \\\"repmgr\\\" extension\"));\n\t\t\tlog_detail(\"\\n%s\", PQerrorMessage(local_conn));\n\t\t\tclose_connection(&local_conn);\n\t\t\texit(ERR_DB_QUERY);\n\t\t}\n\n\t\tif (extension_status == REPMGR_OLD_VERSION_INSTALLED)\n\t\t{\n\t\t\tlog_error(_(\"an older version of the \\\"repmgr\\\" extension is installed\"));\n\t\t\tlog_detail(_(\"extension version %s is installed but newer version %s is available\"),\n\t\t\t\t\t   extversions.installed_version,\n\t\t\t\t\t   extversions.default_version);\n\t\t\tlog_hint(_(\"verify the repmgr installation is updated properly before continuing\"));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlog_error(_(\"repmgr extension not found on this node\"));\n\n\t\t\tif (extension_status == REPMGR_AVAILABLE)\n\t\t\t{\n\t\t\t\tlog_detail(_(\"repmgr extension is available but not installed in database \\\"%s\\\"\"),\n\t\t\t\t\t\t   PQdb(local_conn));\n\t\t\t}\n\t\t\telse if (extension_status == REPMGR_UNAVAILABLE)\n\t\t\t{\n\t\t\t\tlog_detail(_(\"repmgr extension is not available on this node\"));\n\t\t\t}\n\n\t\t\tlog_hint(_(\"check that this node is part of a repmgr cluster\"));\n\t\t}\n\n\t\tclose_connection(&local_conn);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\t/* Retrieve record for this node from the local database */\n\trecord_status = get_node_record(local_conn, config_file_options.node_id, &local_node_info);\n\n\t/*\n\t * Terminate if we can't find the local node record. This is a\n\t * \"fix-the-config\" situation, not a lot else we can do.\n\t */\n\n\tif (record_status != RECORD_FOUND)\n\t{\n\t\tlog_error(_(\"no metadata record found for this node - terminating\"));\n\n\t\tswitch (config_file_options.replication_type)\n\t\t{\n\t\t\tcase REPLICATION_TYPE_PHYSICAL:\n\t\t\t\tlog_hint(_(\"check that 'repmgr (primary|standby|witness) register' was executed for this node\"));\n\t\t\t\tbreak;\n\t\t}\n\n\t\tclose_connection(&local_conn);\n\t\tterminate(ERR_BAD_CONFIG);\n\t}\n\n\trepmgrd_set_local_node_id(local_conn, config_file_options.node_id);\n\n\t{\n\t\t/*\n\t\t * sanity-check that the shared library is loaded and shared memory\n\t\t * can be written by attempting to retrieve the previously stored node_id\n\t\t */\n\t\tint stored_local_node_id = UNKNOWN_NODE_ID;\n\n\t\tstored_local_node_id = repmgrd_get_local_node_id(local_conn);\n\n\t\tif (stored_local_node_id == UNKNOWN_NODE_ID)\n\t\t{\n\t\t\tlog_error(_(\"unable to write to shared memory\"));\n\t\t\tlog_hint(_(\"ensure \\\"shared_preload_libraries\\\" includes \\\"repmgr\\\"\"));\n\t\t\tclose_connection(&local_conn);\n\t\t\tterminate(ERR_BAD_CONFIG);\n\t\t}\n\t}\n\n\tif (config_file_options.replication_type == REPLICATION_TYPE_PHYSICAL)\n\t{\n\t\tlog_debug(\"node id is %i, upstream node id is %i\",\n\t\t\t\t  local_node_info.node_id,\n\t\t\t\t  local_node_info.upstream_node_id);\n\t\tdo_physical_node_check(local_conn);\n\t}\n\n\tif (daemonize == true)\n\t{\n\t\tdaemonize_process();\n\t}\n\n\tif (pid_file[0] != '\\0')\n\t{\n\t\tcheck_and_create_pid_file(pid_file);\n\t}\n\n\trepmgrd_set_pid(local_conn, getpid(), pid_file);\n\n\n#ifndef WIN32\n\tsetup_event_handlers();\n#endif\n\n\tstart_monitoring();\n\n\tlogger_shutdown();\n\n\treturn SUCCESS;\n}\n\n\n\nstatic void\nstart_monitoring(void)\n{\n\tlog_notice(_(\"starting monitoring of node \\\"%s\\\" (ID: %i)\"),\n\t\t\t   local_node_info.node_name,\n\t\t\t   local_node_info.node_id);\n\n\tlog_info(_(\"\\\"connection_check_type\\\" set to \\\"%s\\\"\"), print_connection_check_type(config_file_options.connection_check_type));\n\n\twhile (true)\n\t{\n\t\tswitch (local_node_info.type)\n\t\t{\n\t\t\tcase PRIMARY:\n\t\t\t\tmonitor_streaming_primary();\n\t\t\t\tbreak;\n\t\t\tcase STANDBY:\n\t\t\t\tmonitor_streaming_standby();\n\t\t\t\tbreak;\n\t\t\tcase WITNESS:\n\t\t\t\tmonitor_streaming_witness();\n\t\t\t\tbreak;\n\t\t\tcase UNKNOWN:\n\t\t\t\t/* should never happen */\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nvoid\nupdate_registration(PGconn *conn)\n{\n\tbool\t\tsuccess = update_node_record_conn_priority(local_conn,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &config_file_options);\n\n\t/* check values have actually changed */\n\n\tif (success == false)\n\t{\n\t\tPQExpBufferData errmsg;\n\n\t\tinitPQExpBuffer(&errmsg);\n\n\t\tappendPQExpBuffer(&errmsg,\n\t\t\t\t\t\t  _(\"unable to update local node record:\\n  %s\"),\n\t\t\t\t\t\t  PQerrorMessage(conn));\n\n\t\tcreate_event_record(conn,\n\t\t\t\t\t\t\t&config_file_options,\n\t\t\t\t\t\t\tconfig_file_options.node_id,\n\t\t\t\t\t\t\t\"repmgrd_config_reload\",\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\terrmsg.data);\n\t\ttermPQExpBuffer(&errmsg);\n\t}\n\n\treturn;\n}\n\n\nstatic void\ndaemonize_process(void)\n{\n\tchar\t   *ptr,\n\t\t\t\tpath[MAXPGPATH];\n\tpid_t\t\tpid = fork();\n\tint\t\t\tret;\n\n\tswitch (pid)\n\t{\n\t\tcase -1:\n\t\t\tlog_error(_(\"error in fork()\"));\n\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\texit(ERR_SYS_FAILURE);\n\t\t\tbreak;\n\n\t\tcase 0:\n\t\t\t/* create independent session ID */\n\t\t\tpid = setsid();\n\t\t\tif (pid == (pid_t) -1)\n\t\t\t{\n\t\t\t\tlog_error(_(\"error executing setsid()\"));\n\t\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\t\texit(ERR_SYS_FAILURE);\n\t\t\t}\n\n\t\t\t/* ensure that we are no longer able to open a terminal */\n\t\t\tpid = fork();\n\n\t\t\t/* error case */\n\t\t\tif (pid == -1)\n\t\t\t{\n\t\t\t\tlog_error(_(\"error executing fork()\"));\n\t\t\t\tlog_detail(\"%s\", strerror(errno));\n\t\t\t\texit(ERR_SYS_FAILURE);\n\t\t\t}\n\n\t\t\t/* parent process */\n\t\t\tif (pid != 0)\n\t\t\t{\n\t\t\t\texit(0);\n\t\t\t}\n\n\t\t\t/* child process */\n\n\t\t\tmemset(path, 0, MAXPGPATH);\n\n\t\t\tfor (ptr = config_file_path + strlen(config_file_path); ptr > config_file_path; --ptr)\n\t\t\t{\n\t\t\t\tif (*ptr == '/')\n\t\t\t\t{\n\t\t\t\t\tstrncpy(path, config_file_path, ptr - config_file_path);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (*path == '\\0')\n\t\t\t{\n\t\t\t\t*path = '/';\n\t\t\t}\n\n\t\t\tlog_debug(\"dir now %s\", path);\n\t\t\tret = chdir(path);\n\t\t\tif (ret != 0)\n\t\t\t{\n\t\t\t\tlog_error(_(\"error changing directory to \\\"%s\\\":\\n  %s\"), path,\n\t\t\t\t\t\t  strerror(errno));\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\t\t\t\t/* parent process */\n\t\t\texit(0);\n\t}\n}\n\nstatic void\ncheck_and_create_pid_file(const char *pid_file)\n{\n\tstruct stat st;\n\tFILE\t   *fd;\n\tchar\t\tbuff[MAXLEN];\n\tpid_t\t\tpid;\n\tsize_t\t\tnread;\n\n\tif (stat(pid_file, &st) != -1)\n\t{\n\t\tmemset(buff, 0, MAXLEN);\n\n\t\tfd = fopen(pid_file, \"r\");\n\n\t\tif (fd == NULL)\n\t\t{\n\t\t\tlog_error(_(\"PID file \\\"%s\\\" exists but could not opened for reading\"), pid_file);\n\t\t\tlog_hint(_(\"if repmgrd is no longer alive, remove the file and restart repmgrd\"));\n\t\t\texit(ERR_BAD_PIDFILE);\n\t\t}\n\n\t\tnread = fread(buff, MAXLEN - 1, 1, fd);\n\n\t\tif (nread == 0 && ferror(fd))\n\t\t{\n\t\t\tlog_error(_(\"error reading PID file \\\"%s\\\", aborting\"), pid_file);\n\t\t\texit(ERR_BAD_PIDFILE);\n\t\t}\n\n\t\tfclose(fd);\n\n\t\tpid = atoi(buff);\n\n\t\tif (pid != 0)\n\t\t{\n\t\t\tif (kill(pid, 0) != -1)\n\t\t\t{\n\t\t\t\tlog_error(_(\"PID file \\\"%s\\\" exists and seems to contain a valid PID\"), pid_file);\n\t\t\t\tlog_hint(_(\"if repmgrd is no longer alive, remove the file and restart repmgrd\"));\n\t\t\t\texit(ERR_BAD_PIDFILE);\n\t\t\t}\n\t\t}\n\t}\n\n\tfd = fopen(pid_file, \"w\");\n\tif (fd == NULL)\n\t{\n\t\tlog_error(_(\"could not open PID file %s\"), pid_file);\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tfprintf(fd, \"%d\", getpid());\n\tfclose(fd);\n}\n\n\n#ifndef WIN32\n\n/* SIGHUP: set flag to re-read config file at next convenient time */\nstatic void\nhandle_sighup(SIGNAL_ARGS)\n{\n\tgot_SIGHUP = true;\n}\n\nstatic void\nsetup_event_handlers(void)\n{\n\tpqsignal(SIGHUP, handle_sighup);\n\n\t/*\n\t * we want to be able to write a \"repmgrd_shutdown\" event, so delegate\n\t * signal handling to the respective replication type handler, as it\n\t * will know best which database connection to use\n\t */\n\tswitch (config_file_options.replication_type)\n\t{\n\t\tcase REPLICATION_TYPE_PHYSICAL:\n\t\t\tpqsignal(SIGINT, handle_sigint_physical);\n\t\t\tpqsignal(SIGTERM, handle_sigint_physical);\n\t\t\tbreak;\n\t}\n}\n#endif\n\n\nvoid\nshow_usage(void)\n{\n\tfprintf(stderr, _(\"%s: replication management daemon for PostgreSQL\\n\"), progname());\n\tfprintf(stderr, _(\"Try \\\"%s --help\\\" for more information.\\n\"), progname());\n}\n\nvoid\nshow_help(void)\n{\n\tprintf(_(\"%s: replication management daemon for PostgreSQL\\n\"), progname());\n\tputs(\"\");\n\tprintf(_(\"%s monitors a cluster of servers and optionally performs failover.\\n\"), progname());\n\tputs(\"\");\n\n\tprintf(_(\"Usage:\\n\"));\n\tprintf(_(\"  %s [OPTIONS]\\n\"), progname());\n\tprintf(_(\"\\n\"));\n\tprintf(_(\"Options:\\n\"));\n\tputs(\"\");\n\n\tprintf(_(\"General options:\\n\"));\n\tprintf(_(\"  -?, --help                show this help, then exit\\n\"));\n\tprintf(_(\"  -V, --version             output version information, then exit\\n\"));\n\n\tputs(\"\");\n\n\tprintf(_(\"General configuration options:\\n\"));\n\tprintf(_(\"  -v, --verbose             output verbose activity information\\n\"));\n\tprintf(_(\"  -f, --config-file=PATH    path to the configuration file\\n\"));\n\n\tputs(\"\");\n\n\tprintf(_(\"Daemon configuration options:\\n\"));\n\tprintf(_(\"  -d\\n\"));\n\tprintf(_(\"  --daemonize[=true/false]\\n\"));\n\tprintf(_(\"                            detach process from foreground (default: true)\\n\"));\n\tprintf(_(\"  -p, --pid-file=PATH       use the specified PID file\\n\"));\n\tprintf(_(\"  -s, --show-pid-file       show PID file which would be used by the current configuration\\n\"));\n\tprintf(_(\"  --no-pid-file             don't write a PID file\\n\"));\n\tputs(\"\");\n\n}\n\n\nbool\ncheck_upstream_connection(PGconn **conn, const char *conninfo, PGconn **paired_conn)\n{\n\t/* Check the connection status twice in case it changes after reset */\n\tbool\t\ttwice = false;\n\n\tlog_debug(\"connection check type is \\\"%s\\\"\",\n\t\t\t  print_connection_check_type(config_file_options.connection_check_type));\n\t/*\n\t * For the check types which do not involve using the existing database\n\t * connection, we'll perform the actual check, then as an additional\n\t * safeguard verify that the connection is still valid (as it might have\n\t * gone away during a brief outage between checks).\n\t */\n\tif (config_file_options.connection_check_type != CHECK_QUERY)\n\t{\n\t\tbool success = true;\n\n\t\tif (config_file_options.connection_check_type == CHECK_PING)\n\t\t{\n\t\t\tsuccess = is_server_available(conninfo);\n\t\t}\n\t\telse if (config_file_options.connection_check_type == CHECK_CONNECTION)\n\t\t{\n\t\t\t/*\n\t\t\t * This connection is thrown away, and we never execute a query on it.\n\t\t\t */\n\t\t\tPGconn *test_conn = PQconnectdb(conninfo);\n\n\t\t\tlog_debug(\"check_upstream_connection(): attempting to connect to \\\"%s\\\"\", conninfo);\n\n\t\t\tif (PQstatus(test_conn) != CONNECTION_OK)\n\t\t\t{\n\t\t\t\tlog_warning(_(\"unable to connect to \\\"%s\\\"\"), conninfo);\n\t\t\t\tlog_detail(\"\\n%s\", PQerrorMessage(test_conn));\n\t\t\t\tsuccess = false;\n\t\t\t}\n\t\t\tPQfinish(test_conn);\n\t\t}\n\n\t\tif (success == false)\n\t\t\treturn false;\n\n\t\tif (PQstatus(*conn) == CONNECTION_OK)\n\t\t\treturn true;\n\n\t\t/*\n\t\t * Checks have succeeded, but the open connection to the primary has gone away,\n\t\t * possibly due to a brief outage between monitoring intervals - attempt to\n\t\t * reset it.\n\t\t */\n\t\tlog_notice(_(\"upstream is available but upstream connection has gone away, resetting\"));\n\n\t\tPQfinish(*conn);\n\t\t*conn = establish_db_connection_quiet(conninfo);\n\n\t\tif (PQstatus(*conn) == CONNECTION_OK)\n\t\t{\n\t\t\tif (paired_conn != NULL)\n\t\t\t{\n\t\t\t\tlog_debug(\"resetting paired connection\");\n\t\t\t\t*paired_conn = *conn;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfor (;;)\n\t{\n\t\tif (PQstatus(*conn) != CONNECTION_OK)\n\t\t{\n\t\t\tlog_debug(\"check_upstream_connection(): upstream connection has gone away, resetting\");\n\t\t\tif (twice)\n\t\t\t\treturn false;\n\n\t\t\t/* reconnect */\n\t\t\tPQfinish(*conn);\n\t\t\t*conn = establish_db_connection_quiet(conninfo);\n\n\t\t\tif (paired_conn != NULL)\n\t\t\t{\n\t\t\t\tlog_debug(\"resetting paired connection\");\n\t\t\t\t*paired_conn = *conn;\n\t\t\t}\n\t\t\ttwice = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!cancel_query(*conn, config_file_options.async_query_timeout))\n\t\t\t\tgoto failed;\n\n\t\t\tif (wait_connection_availability(*conn, config_file_options.async_query_timeout) != 1)\n\t\t\t\tgoto failed;\n\n\t\t\t/* execute a simple query to verify connection availability */\n\t\t\tif (PQsendQuery(*conn, config_file_options.connection_check_query) == 0)\n\t\t\t{\n\t\t\t\tlog_warning(_(\"unable to send query to upstream\"));\n\t\t\t\tlog_detail(\"%s\", PQerrorMessage(*conn));\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tif (wait_connection_availability(*conn, config_file_options.async_query_timeout) != 1)\n\t\t\t\tgoto failed;\n\n\t\t\tbreak;\n\n\tfailed:\n\t\t\t/* retry once */\n\t\t\tif (twice)\n\t\t\t\treturn false;\n\n\t\t\t/* reconnect */\n\t\t\tlog_debug(\"check_upstream_connection(): upstream connection not available, resetting\");\n\n\t\t\tPQfinish(*conn);\n\t\t\t*conn = establish_db_connection_quiet(conninfo);\n\n\t\t\tif (paired_conn != NULL)\n\t\t\t{\n\t\t\t\tlog_debug(\"resetting paired connection\");\n\t\t\t\t*paired_conn = *conn;\n\t\t\t}\n\t\t\ttwice = true;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\nvoid\ntry_reconnect(PGconn **conn, t_node_info *node_info)\n{\n\tPGconn\t   *our_conn;\n\tt_conninfo_param_list conninfo_params = T_CONNINFO_PARAM_LIST_INITIALIZER;\n\n\tint\t\t\ti;\n\n\tint\t\t\tmax_attempts = config_file_options.reconnect_attempts;\n\n\tinitialize_conninfo_params(&conninfo_params, false);\n\n\t/* we assume by now the conninfo string is parseable */\n\t(void) parse_conninfo_string(node_info->conninfo, &conninfo_params, NULL, false);\n\n\t/* set some default values if not explicitly provided */\n\tparam_set_ine(&conninfo_params, \"connect_timeout\", \"2\");\n\tparam_set_ine(&conninfo_params, \"fallback_application_name\", \"repmgr\");\n\n\tfor (i = 0; i < max_attempts; i++)\n\t{\n\t\tlog_info(_(\"checking state of node %i, %i of %i attempts\"),\n\t\t\t\t node_info->node_id, i + 1, max_attempts);\n\t\tif (is_server_available_params(&conninfo_params) == true)\n\t\t{\n\t\t\tlog_notice(_(\"node %i has recovered, reconnecting\"), node_info->node_id);\n\n\t\t\t/*\n\t\t\t * Note: we could also handle the case where node is pingable but\n\t\t\t * connection denied due to connection exhaustion, by falling back to\n\t\t\t * degraded monitoring (make configurable)\n\t\t\t */\n\t\t\tour_conn = establish_db_connection_by_params(&conninfo_params, false);\n\n\t\t\tif (PQstatus(our_conn) == CONNECTION_OK)\n\t\t\t{\n\t\t\t\tfree_conninfo_params(&conninfo_params);\n\n\t\t\t\tlog_info(_(\"connection to node %i succeeded\"), node_info->node_id);\n\n\t\t\t\tif (PQstatus(*conn) == CONNECTION_BAD)\n\t\t\t\t{\n\t\t\t\t\tlog_verbose(LOG_INFO, _(\"original connection handle returned CONNECTION_BAD, using new connection\"));\n\t\t\t\t\tclose_connection(conn);\n\t\t\t\t\t*conn = our_conn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tExecStatusType ping_result;\n\n\t\t\t\t\tping_result = connection_ping(*conn);\n\n\t\t\t\t\tif (ping_result != PGRES_TUPLES_OK)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_info(_(\"original connection no longer available, using new connection\"));\n\t\t\t\t\t\tclose_connection(conn);\n\t\t\t\t\t\t*conn = our_conn;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlog_info(_(\"original connection is still available\"));\n\n\t\t\t\t\t\tPQfinish(our_conn);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnode_info->node_status = NODE_STATUS_UP;\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclose_connection(&our_conn);\n\t\t\tlog_notice(_(\"unable to reconnect to node \\\"%s\\\" (ID: %i)\"),\n\t\t\t\t\t   node_info->node_name,\n\t\t\t\t\t   node_info->node_id);\n\t\t}\n\n\t\tif (i + 1 < max_attempts)\n\t\t{\n\t\t\tlog_info(_(\"sleeping %i seconds until next reconnection attempt\"),\n\t\t\t\t\t config_file_options.reconnect_interval);\n\t\t\tsleep(config_file_options.reconnect_interval);\n\t\t}\n\t}\n\n\tlog_warning(_(\"unable to reconnect to node %i after %i attempts\"),\n\t\t\t\tnode_info->node_id,\n\t\t\t\tmax_attempts);\n\n\tnode_info->node_status = NODE_STATUS_DOWN;\n\n\tfree_conninfo_params(&conninfo_params);\n\n\treturn;\n}\n\n\n\nint\ncalculate_elapsed(instr_time start_time)\n{\n\tinstr_time\tcurrent_time;\n\n\tINSTR_TIME_SET_CURRENT(current_time);\n\n\tINSTR_TIME_SUBTRACT(current_time, start_time);\n\n\treturn (int) INSTR_TIME_GET_DOUBLE(current_time);\n}\n\n\nconst char *\nprint_monitoring_state(MonitoringState monitoring_state)\n{\n\tswitch (monitoring_state)\n\t{\n\t\tcase MS_NORMAL:\n\t\t\treturn \"normal\";\n\n\t\tcase MS_DEGRADED:\n\t\t\treturn \"degraded\";\n\t}\n\n\t/* should never reach here */\n\treturn \"UNKNOWN\";\n}\n\n\nvoid\nterminate(int retval)\n{\n\tif (PQstatus(local_conn)  == CONNECTION_OK)\n\t\trepmgrd_set_pid(local_conn, UNKNOWN_PID, NULL);\n\n\tlogger_shutdown();\n\n\tif (pid_file[0] != '\\0')\n\t{\n\t\tunlink(pid_file);\n\t}\n\n\tlog_info(_(\"%s terminating...\"), progname());\n\n\texit(retval);\n}\n"
        },
        {
          "name": "repmgrd.h",
          "type": "blob",
          "size": 0.8759765625,
          "content": "/*\n * repmgrd.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n */\n\n\n#ifndef _REPMGRD_H_\n#define _REPMGRD_H_\n\n#include <time.h>\n#include \"portability/instr_time.h\"\n\n#define OPT_NO_PID_FILE                  1000\n#define OPT_DAEMONIZE                    1001\n\nextern volatile sig_atomic_t got_SIGHUP;\nextern MonitoringState monitoring_state;\nextern instr_time degraded_monitoring_start;\n\nextern t_node_info local_node_info;\nextern PGconn *local_conn;\nextern bool startup_event_logged;\nextern char pid_file[MAXPGPATH];\n\nbool\t\tcheck_upstream_connection(PGconn **conn, const char *conninfo, PGconn **paired_conn);\nvoid\t\ttry_reconnect(PGconn **conn, t_node_info *node_info);\n\nint\t\t\tcalculate_elapsed(instr_time start_time);\nconst char *print_monitoring_state(MonitoringState monitoring_state);\n\nvoid\t\tupdate_registration(PGconn *conn);\nvoid\t\tterminate(int retval);\n\n#endif\t\t\t\t\t\t\t/* _REPMGRD_H_ */\n"
        },
        {
          "name": "sql",
          "type": "tree",
          "content": null
        },
        {
          "name": "strutil.c",
          "type": "blob",
          "size": 9.9931640625,
          "content": "/*\n * strutil.c\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"repmgr.h\"\n#include \"log.h\"\n#include \"strutil.h\"\n\nstatic int\nxvsnprintf(char *str, size_t size, const char *format, va_list ap)\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 3, 0)));\n\nstatic void\n_key_value_list_set(KeyValueList *item_list, bool replace, const char *key, const char *value);\n\nstatic int\nxvsnprintf(char *str, size_t size, const char *format, va_list ap)\n{\n\tint\t\t\tretval;\n\n\tretval = vsnprintf(str, size, format, ap);\n\n\tif (retval >= (int) size)\n\t{\n\t\tlog_error(_(\"buffer of specified size not large enough to format entire string '%s'\"),\n\t\t\t\t  str);\n\t\texit(ERR_STR_OVERFLOW);\n\t}\n\n\treturn retval;\n}\n\n\nint\nmaxlen_snprintf(char *str, const char *format,...)\n{\n\tva_list\t\targlist;\n\tint\t\t\tretval;\n\n\tva_start(arglist, format);\n\tretval = xvsnprintf(str, MAXLEN, format, arglist);\n\tva_end(arglist);\n\n\treturn retval;\n}\n\n\nint\nmaxpath_snprintf(char *str, const char *format,...)\n{\n\tva_list\t\targlist;\n\tint\t\t\tretval;\n\n\tva_start(arglist, format);\n\tretval = xvsnprintf(str, MAXPGPATH, format, arglist);\n\tva_end(arglist);\n\n\treturn retval;\n}\n\n\nvoid\nappend_where_clause(PQExpBufferData *where_clause, const char *format,...)\n{\n\tva_list\t\targlist;\n\tchar\t\tstringbuf[MAXLEN];\n\n\tva_start(arglist, format);\n\t(void) xvsnprintf(stringbuf, MAXLEN, format, arglist);\n\tva_end(arglist);\n\n\tif (where_clause->data[0] == '\\0')\n\t{\n\t\tappendPQExpBufferStr(where_clause,\n\t\t\t\t\t\t\t \" WHERE \");\n\t}\n\telse\n\t{\n\t\tappendPQExpBufferStr(where_clause,\n\t\t\t\t\t\t\t \" AND \");\n\t}\n\n\tappendPQExpBufferStr(where_clause,\n\t\t\t\t\t\t stringbuf);\n\n}\n\n\nvoid\nitem_list_append(ItemList *item_list, const char *message)\n{\n\titem_list_append_format(item_list, \"%s\", message);\n}\n\n\nvoid\nitem_list_append_format(ItemList *item_list, const char *format,...)\n{\n\tItemListCell *cell;\n\tva_list\t\targlist;\n\n\tif (item_list == NULL)\n\t\treturn;\n\n\tcell = (ItemListCell *) pg_malloc0(sizeof(ItemListCell));\n\n\tif (cell == NULL)\n\t{\n\t\tlog_error(_(\"unable to allocate memory; terminating.\"));\n\t\texit(ERR_OUT_OF_MEMORY);\n\t}\n\n\tcell->string = pg_malloc0(MAXLEN);\n\n\tva_start(arglist, format);\n\n\t(void) xvsnprintf(cell->string, MAXLEN, format, arglist);\n\tva_end(arglist);\n\n\n\tif (item_list->tail)\n\t\titem_list->tail->next = cell;\n\telse\n\t\titem_list->head = cell;\n\n\titem_list->tail = cell;\n}\n\n\nvoid\nitem_list_free(ItemList *item_list)\n{\n\tItemListCell *cell = NULL;\n\tItemListCell *next_cell = NULL;\n\n\tcell = item_list->head;\n\n\twhile (cell != NULL)\n\t{\n\t\tnext_cell = cell->next;\n\t\tpfree(cell->string);\n\t\tpfree(cell);\n\t\tcell = next_cell;\n\t}\n}\n\n\nvoid\nkey_value_list_set(KeyValueList *item_list, const char *key, const char *value)\n{\n\t_key_value_list_set(item_list, false, key, value);\n\treturn;\n}\n\nvoid\nkey_value_list_replace_or_set(KeyValueList *item_list, const char *key, const char *value)\n{\n\t_key_value_list_set(item_list, true, key, value);\n\treturn;\n}\n\nvoid\nkey_value_list_set_format(KeyValueList *item_list, const char *key, const char *value, ...)\n{\n\tva_list\t\targlist;\n\tchar formatted_value[MAXLEN];\n\n\tva_start(arglist, value);\n\t(void) xvsnprintf(formatted_value, MAXLEN, value, arglist);\n\tva_end(arglist);\n\n\treturn _key_value_list_set(item_list, false, key, formatted_value);\n}\n\nstatic void\n_key_value_list_set(KeyValueList *item_list, bool replace, const char *key, const char *value)\n{\n\tKeyValueListCell *cell = NULL;\n\tint\t\t\tkeylen = 0;\n\tint\t\t\tvallen = 0;\n\n\tif (replace == true)\n\t{\n\t\tKeyValueListCell *prev_cell = NULL;\n\t\tKeyValueListCell *next_cell = NULL;\n\n\n\t\tfor (cell = item_list->head; cell; cell = next_cell)\n\t\t{\n\t\t\tnext_cell = cell->next;\n\n\t\t\tif (strcmp(cell->key, key) == 0)\n\t\t\t{\n\t\t\t\tif (item_list->head == cell)\n\t\t\t\t\titem_list->head = cell->next;\n\n\t\t\t\tif (prev_cell)\n\t\t\t\t{\n\t\t\t\t\tprev_cell->next = cell->next;\n\n\t\t\t\t\tif (item_list->tail == cell)\n\t\t\t\t\t\titem_list->tail = prev_cell;\n\t\t\t\t}\n\t\t\t\telse if (item_list->tail == cell)\n\t\t\t\t{\n\t\t\t\t\titem_list->tail = NULL;\n\t\t\t\t}\n\n\t\t\t\tpfree(cell->key);\n\t\t\t\tpfree(cell->value);\n\t\t\t\tpfree(cell);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprev_cell = cell;\n\t\t\t}\n\t\t}\n\t}\n\n\tcell = (KeyValueListCell *) pg_malloc0(sizeof(KeyValueListCell));\n\n\tif (cell == NULL)\n\t{\n\t\tlog_error(_(\"unable to allocate memory; terminating.\"));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\tkeylen = strlen(key);\n\tvallen = strlen(value);\n\n\tcell->key = pg_malloc0(keylen + 1);\n\tcell->value = pg_malloc0(vallen + 1);\n\tcell->output_mode = OM_NOT_SET;\n\n\tstrncpy(cell->key, key, keylen);\n\tstrncpy(cell->value, value, vallen);\n\n\tif (item_list->tail)\n\t\titem_list->tail->next = cell;\n\telse\n\t\titem_list->head = cell;\n\n\titem_list->tail = cell;\n\n\treturn;\n}\n\n\nvoid\nkey_value_list_set_output_mode(KeyValueList *item_list, const char *key, OutputMode mode)\n{\n\tKeyValueListCell *cell = NULL;\n\n\tfor (cell = item_list->head; cell; cell = cell->next)\n\t{\n\t\tif (strncmp(key, cell->key, MAXLEN) == 0)\n\t\t\tcell->output_mode = mode;\n\t}\n}\n\nconst char *\nkey_value_list_get(KeyValueList *item_list, const char *key)\n{\n\treturn NULL;\n}\n\n\nvoid\nkey_value_list_free(KeyValueList *item_list)\n{\n\tKeyValueListCell *cell;\n\tKeyValueListCell *next_cell;\n\n\tcell = item_list->head;\n\n\twhile (cell != NULL)\n\t{\n\t\tnext_cell = cell->next;\n\t\tpfree(cell->key);\n\t\tpfree(cell->value);\n\t\tpfree(cell);\n\t\tcell = next_cell;\n\t}\n}\n\n\nvoid\ncheck_status_list_set(CheckStatusList *list, const char *item, CheckStatus status, const char *details)\n{\n\tcheck_status_list_set_format(list, item, status, \"%s\", details);\n}\n\n\nvoid\ncheck_status_list_set_format(CheckStatusList *list, const char *item, CheckStatus status, const char *details,...)\n{\n\tCheckStatusListCell *cell;\n\tva_list\t\targlist;\n\tint\t\t\titemlen;\n\n\tcell = (CheckStatusListCell *) pg_malloc0(sizeof(CheckStatusListCell));\n\n\tif (cell == NULL)\n\t{\n\t\tlog_error(_(\"unable to allocate memory; terminating.\"));\n\t\texit(ERR_BAD_CONFIG);\n\t}\n\n\titemlen = strlen(item);\n\n\tcell->item = pg_malloc0(itemlen + 1);\n\tcell->details = pg_malloc0(MAXLEN);\n\tcell->status = status;\n\n\tstrncpy(cell->item, item, itemlen);\n\n\tva_start(arglist, details);\n\t(void) xvsnprintf(cell->details, MAXLEN, details, arglist);\n\tva_end(arglist);\n\n\n\tif (list->tail)\n\t\tlist->tail->next = cell;\n\telse\n\t\tlist->head = cell;\n\n\tlist->tail = cell;\n\n\treturn;\n\n}\n\n\nvoid\ncheck_status_list_free(CheckStatusList *list)\n{\n\tCheckStatusListCell *cell = NULL;\n\tCheckStatusListCell *next_cell = NULL;\n\n\tcell = list->head;\n\n\twhile (cell != NULL)\n\t{\n\t\tnext_cell = cell->next;\n\t\tpfree(cell->item);\n\t\tpfree(cell->details);\n\t\tpfree(cell);\n\t\tcell = next_cell;\n\t}\n}\n\n\nconst char *\noutput_check_status(CheckStatus status)\n{\n\tswitch (status)\n\t{\n\t\tcase CHECK_STATUS_OK:\n\t\t\treturn \"OK\";\n\t\tcase CHECK_STATUS_WARNING:\n\t\t\treturn \"WARNING\";\n\t\tcase CHECK_STATUS_CRITICAL:\n\t\t\treturn \"CRITICAL\";\n\t\tcase CHECK_STATUS_UNKNOWN:\n\t\t\treturn \"UNKNOWN\";\n\t}\n\n\treturn \"UNKNOWN\";\n}\n\n\n/*\n * Escape a string for use as a parameter in recovery.conf\n * Caller must free returned value\n */\nchar *\nescape_recovery_conf_value(const char *src)\n{\n\tchar\t   *result = escape_single_quotes_ascii(src);\n\n\tif (!result)\n\t{\n\t\tfprintf(stderr, _(\"%s: out of memory\\n\"), progname());\n\t\texit(ERR_INTERNAL);\n\t}\n\treturn result;\n}\n\n\nchar *\nescape_string(PGconn *conn, const char *string)\n{\n\tchar\t   *escaped_string;\n\tint\t\t\terror;\n\n\tescaped_string = pg_malloc0(MAXLEN);\n\n\t(void) PQescapeStringConn(conn, escaped_string, string, MAXLEN, &error);\n\n\tif (error)\n\t{\n\t\tpfree(escaped_string);\n\t\treturn NULL;\n\t}\n\n\treturn escaped_string;\n}\n\n\n/*\n * simple function to escape double quotes only\n */\nvoid\nescape_double_quotes(char *string, PQExpBufferData *out)\n{\n\tchar *ptr;\n\n\tfor (ptr = string; *ptr; ptr++)\n\t{\n\t\tif (*ptr == '\"')\n\t\t{\n\t\t\tif ( (ptr == string) || (ptr > string && *(ptr - 1) != '\\\\'))\n\t\t\t{\n\t\t\t\tappendPQExpBufferChar(out, '\\\\');\n\t\t\t}\n\t\t}\n\t\tappendPQExpBufferChar(out, *ptr);\n\t}\n\n\treturn;\n}\n\n\nchar *\nstring_skip_prefix(const char *prefix, char *string)\n{\n\tint\t\t\tn;\n\n\tn = strlen(prefix);\n\n\tif (strncmp(prefix, string, n))\n\t\treturn NULL;\n\telse\n\t\treturn string + n;\n}\n\n\nchar *\nstring_remove_trailing_newlines(char *string)\n{\n\tint\t\t\tn;\n\n\tn = strlen(string) - 1;\n\n\twhile (n >= 0 && string[n] == '\\n')\n\t\tstring[n] = 0;\n\n\treturn string;\n}\n\n\nchar *\ntrim(char *s)\n{\n\t/* Initialize start, end pointers */\n\tchar\t   *s1 = s,\n\t\t\t   *s2 = &s[strlen(s) - 1];\n\n\t/* If string is empty, no action needed */\n\tif (s2 < s1)\n\t\treturn s;\n\n\t/* Trim and delimit right side */\n\twhile ((isspace(*s2)) && (s2 >= s1))\n\t\t--s2;\n\t*(s2 + 1) = '\\0';\n\n\t/* String is all whitespace - no need for further processing */\n\tif (s2 + 1 == s1)\n\t\treturn s;\n\n\t/* Trim left side */\n\twhile ((isspace(*s1)) && (s1 < s2))\n\t\t++s1;\n\n\t/* Copy finished string */\n\tmemmove(s, s1, (s2 - s1) + 1);\n\ts[s2 - s1 + 1] = '\\0';\n\n\treturn s;\n}\n\n\nvoid\nparse_follow_command(char *parsed_command, char *template, int node_id)\n{\n\tconst char *src_ptr = NULL;\n\tchar\t   *dst_ptr = NULL;\n\tchar\t   *end_ptr = NULL;\n\n\tdst_ptr = parsed_command;\n\tend_ptr = parsed_command + MAXPGPATH - 1;\n\t*end_ptr = '\\0';\n\n\tfor (src_ptr = template; *src_ptr; src_ptr++)\n\t{\n\t\tif (*src_ptr == '%')\n\t\t{\n\t\t\tswitch (src_ptr[1])\n\t\t\t{\n\t\t\t\tcase '%':\n\t\t\t\t\t/* %%: replace with % */\n\t\t\t\t\tif (dst_ptr < end_ptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\t\t*dst_ptr++ = *src_ptr;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\t/* %n: node id */\n\t\t\t\t\tsrc_ptr++;\n\t\t\t\t\tsnprintf(dst_ptr, end_ptr - dst_ptr, \"%i\", node_id);\n\t\t\t\t\tdst_ptr += strlen(dst_ptr);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* otherwise treat the % as not special */\n\t\t\t\t\tif (dst_ptr < end_ptr)\n\t\t\t\t\t\t*dst_ptr++ = *src_ptr;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (dst_ptr < end_ptr)\n\t\t\t\t*dst_ptr++ = *src_ptr;\n\t\t}\n\t}\n\n\t*dst_ptr = '\\0';\n\n\treturn;\n}\n\n\nconst char *\nformat_bool(bool value)\n{\n\treturn value == true ? \"true\" : \"false\";\n}\n"
        },
        {
          "name": "strutil.h",
          "type": "blob",
          "size": 4.1826171875,
          "content": "/*\n * strutil.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _STRUTIL_H_\n#define _STRUTIL_H_\n\n#include <pqexpbuffer.h>\n\n#define MAXLEN\t\t\t1024\n#define MAX_QUERY_LEN\t8192\n#define MAXVERSIONSTR\t16\n\n/* same as defined in src/include/replication/walreceiver.h */\n#define MAXCONNINFO\t\t1024\n\n#define STR(x) CppAsString(x)\n\n#define MAXLEN_STR STR(MAXLEN)\n\n\n/*\n * These values must match the Nagios return codes defined here:\n *\n * https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/3/en/pluginapi.html\n */\ntypedef enum\n{\n\tCHECK_STATUS_OK       = 0,\n\tCHECK_STATUS_WARNING  = 1,\n\tCHECK_STATUS_CRITICAL = 2,\n\tCHECK_STATUS_UNKNOWN  = 3\n} CheckStatus;\n\ntypedef enum\n{\n\tOM_NOT_SET = -1,\n\tOM_TEXT,\n\tOM_CSV,\n\tOM_NAGIOS,\n\tOM_OPTFORMAT\n} OutputMode;\n\ntypedef struct ItemListCell\n{\n\tstruct ItemListCell *next;\n\tchar\t   *string;\n} ItemListCell;\n\ntypedef struct ItemList\n{\n\tItemListCell *head;\n\tItemListCell *tail;\n} ItemList;\n\ntypedef struct KeyValueListCell\n{\n\tstruct KeyValueListCell *next;\n\tchar\t   *key;\n\tchar\t   *value;\n\tOutputMode\toutput_mode;\n} KeyValueListCell;\n\ntypedef struct KeyValueList\n{\n\tKeyValueListCell *head;\n\tKeyValueListCell *tail;\n} KeyValueList;\n\n\ntypedef struct CheckStatusListCell\n{\n\tstruct CheckStatusListCell *next;\n\tchar\t   *item;\n\tCheckStatus status;\n\tchar\t   *details;\n} CheckStatusListCell;\n\ntypedef struct CheckStatusList\n{\n\tCheckStatusListCell *head;\n\tCheckStatusListCell *tail;\n} CheckStatusList;\n\n\n\nextern int\nmaxlen_snprintf(char *str, const char *format,...)\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 2, 3)));\n\nextern int\nmaxpath_snprintf(char *str, const char *format,...)\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 2, 3)));\n\nextern void\n\t\t\titem_list_append(ItemList *item_list, const char *message);\n\nextern void\nitem_list_append_format(ItemList *item_list, const char *format,...)\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 2, 3)));\n\nextern void\n\t\t\titem_list_free(ItemList *item_list);\n\nextern void\n\t\t\tkey_value_list_set(KeyValueList *item_list, const char *key, const char *value);\n\nextern void\nkey_value_list_replace_or_set(KeyValueList *item_list, const char *key, const char *value);\n\nextern void\nkey_value_list_set_format(KeyValueList *item_list, const char *key, const char *value,...)\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 3, 4)));\n\nextern void\n\t\t\tkey_value_list_set_output_mode(KeyValueList *item_list, const char *key, OutputMode mode);\n\nextern const char *key_value_list_get(KeyValueList *item_list, const char *key);\n\nextern void\n\t\t\tkey_value_list_free(KeyValueList *item_list);\n\nextern void\n\t\t\tcheck_status_list_set(CheckStatusList *list, const char *item, CheckStatus status, const char *details);\n\nextern void\ncheck_status_list_set_format(CheckStatusList *list, const char *item, CheckStatus status, const char *details,...)\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 4, 5)));\n\nextern void\n\t\t\tcheck_status_list_free(CheckStatusList *list);\n\nextern const char *output_check_status(CheckStatus status);\n\nextern char *escape_recovery_conf_value(const char *src);\n\nextern char *escape_string(PGconn *conn, const char *string);\n\nextern void escape_double_quotes(char *string, PQExpBufferData *out);\n\nextern void\nappend_where_clause(PQExpBufferData *where_clause, const char *clause,...)\n__attribute__((format(PG_PRINTF_ATTRIBUTE, 2, 3)));\n\nextern char *string_skip_prefix(const char *prefix, char *string);\n\nextern char\n\t\t   *string_remove_trailing_newlines(char *string);\n\nextern char *trim(char *s);\n\nextern void\n\t\t\tparse_follow_command(char *parsed_command, char *template, int node_id);\n\nextern const char *format_bool(bool value);\n\n#endif\t\t\t\t\t\t\t/* _STRUTIL_H_ */\n"
        },
        {
          "name": "sysutils.c",
          "type": "blob",
          "size": 10.19140625,
          "content": "/*\n * sysutils.c\n *\n * Functions which need to be executed on the local system.\n *\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <signal.h>\n\n#include \"repmgr.h\"\n\nstatic bool _local_command(const char *command, PQExpBufferData *outputbuf, bool simple, int *return_value);\n\n\n/*\n * Execute a command locally. \"outputbuf\" should either be an\n * initialised PQExpPuffer, or NULL\n */\nbool\nlocal_command(const char *command, PQExpBufferData *outputbuf)\n{\n\treturn _local_command(command, outputbuf, false, NULL);\n}\n\nbool\nlocal_command_return_value(const char *command, PQExpBufferData *outputbuf, int *return_value)\n{\n\treturn _local_command(command, outputbuf, false, return_value);\n}\n\n\nbool\nlocal_command_simple(const char *command, PQExpBufferData *outputbuf)\n{\n\treturn _local_command(command, outputbuf, true, NULL);\n}\n\n\nstatic bool\n_local_command(const char *command, PQExpBufferData *outputbuf, bool simple, int *return_value)\n{\n\tFILE\t   *fp = NULL;\n\tchar\t\toutput[MAXLEN];\n\tint\t\t\tretval = 0;\n\tbool\t\tsuccess;\n\tchar\t\ttmpfile_path[MAXPGPATH];\n\tconst char *tmpdir = getenv(\"TMPDIR\");\n\tint\t\t\tfd;\n\tPQExpBufferData command_final;\n\n\tif (!tmpdir)\n\t\ttmpdir = \"/tmp\";\n\n\tmaxpath_snprintf(tmpfile_path, \"%s/repmgr_command.XXXXXX\",\n\t\t\t\t\t tmpdir);\n\n\tfd = mkstemp(tmpfile_path);\n\n\tif (fd < 1)\n\t{\n\t\tlog_error(_(\"unable to open temporary file\"));\n\t\treturn false;\n\t}\n\n\tinitPQExpBuffer(&command_final);\n\tappendPQExpBufferStr(&command_final, command);\n\n\tappendPQExpBuffer(&command_final, \" 2>%s\", tmpfile_path);\n\n\tlog_verbose(LOG_DEBUG, \"executing:\\n  %s\", command_final.data);\n\n\tif (outputbuf == NULL)\n\t{\n\t\tretval = system(command_final.data);\n\t\ttermPQExpBuffer(&command_final);\n\n\t\tif (return_value != NULL)\n\t\t\t*return_value = WEXITSTATUS(retval);\n\n\t\tclose(fd);\n\n\t\treturn (retval == 0) ? true : false;\n\t}\n\n\tfp = popen(command_final.data, \"r\");\n\n\tif (fp == NULL)\n\t{\n\t\tlog_error(_(\"unable to execute local command:\\n%s\"), command_final.data);\n\t\ttermPQExpBuffer(&command_final);\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\ttermPQExpBuffer(&command_final);\n\n\twhile (fgets(output, MAXLEN, fp) != NULL)\n\t{\n\t\tappendPQExpBufferStr(outputbuf, output);\n\n\t\tif (!feof(fp) && simple == false)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tretval = pclose(fp);\n\n\t/* 141 = SIGPIPE */\n\tsuccess = (WEXITSTATUS(retval) == 0 || WEXITSTATUS(retval) == 141) ? true : false;\n\n\tlog_verbose(LOG_DEBUG, \"result of command was %i (%i)\", WEXITSTATUS(retval), retval);\n\n\t/*\n\t * Append any captured STDERR output\n\t */\n\n\tfp = fopen(tmpfile_path, \"r\");\n\n\t/*\n\t * Not critical if we can't open the file\n\t */\n\tif (fp != NULL)\n\t{\n\t\twhile (fgets(output, MAXLEN, fp) != NULL)\n\t\t{\n\t\t\tappendPQExpBufferStr(outputbuf, output);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n\n\tunlink(tmpfile_path);\n\n\tif (return_value != NULL)\n\t\t*return_value = WEXITSTATUS(retval);\n\n\tif (outputbuf->data != NULL && outputbuf->data[0] != '\\0')\n\t\tlog_verbose(LOG_DEBUG, \"local_command(): output returned was:\\n%s\", outputbuf->data);\n\telse\n\t\tlog_verbose(LOG_DEBUG, \"local_command(): no output returned\");\n\n\n\treturn success;\n}\n\n\n/*\n * Execute a command via ssh on the remote host.\n *\n * TODO: implement SSH calls using libssh2.\n */\nbool\nremote_command(const char *host, const char *user, const char *command, const char *ssh_options, PQExpBufferData *outputbuf)\n{\n\tFILE\t   *fp;\n\tPQExpBufferData ssh_command;\n\n\tchar\t\toutput[MAXLEN] = \"\";\n\n\n\tinitPQExpBuffer(&ssh_command);\n\n\tmake_remote_command(host, user, command, ssh_options, &ssh_command);\n\n\tlog_debug(\"remote_command():\\n  %s\", ssh_command.data);\n\n\tfp = popen(ssh_command.data, \"r\");\n\n\tif (fp == NULL)\n\t{\n\t\tlog_error(_(\"unable to execute remote command:\\n  %s\"), ssh_command.data);\n\t\ttermPQExpBuffer(&ssh_command);\n\t\treturn false;\n\t}\n\n\ttermPQExpBuffer(&ssh_command);\n\n\tif (outputbuf != NULL)\n\t{\n\t\t/* TODO: better error handling */\n\t\twhile (fgets(output, MAXLEN, fp) != NULL)\n\t\t{\n\t\t\tappendPQExpBufferStr(outputbuf, output);\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile (fgets(output, MAXLEN, fp) != NULL)\n\t\t{\n\t\t\tif (!feof(fp))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpclose(fp);\n\n\tif (outputbuf != NULL)\n\t{\n\t\tif (outputbuf->data != NULL && outputbuf->data[0] != '\\0')\n\t\t\tlog_verbose(LOG_DEBUG, \"remote_command(): output returned was:\\n%s\", outputbuf->data);\n\t\telse\n\t\t\tlog_verbose(LOG_DEBUG, \"remote_command(): no output returned\");\n\t}\n\n\treturn true;\n}\n\n\nvoid\nmake_remote_command(const char *host, const char *user, const char *command, const char *ssh_options, PQExpBufferData *ssh_command)\n{\n\tPQExpBufferData ssh_host;\n\n\tinitPQExpBuffer(&ssh_host);\n\n\tif (*user != '\\0')\n\t{\n\t\tappendPQExpBuffer(&ssh_host, \"%s@\", user);\n\t}\n\n\tappendPQExpBufferStr(&ssh_host, host);\n\n\n\tappendPQExpBuffer(ssh_command,\n\t\t\t\t\t  \"ssh -o Batchmode=yes %s %s %s\",\n\t\t\t\t\t  ssh_options,\n\t\t\t\t\t  ssh_host.data,\n\t\t\t\t\t  command);\n\n\ttermPQExpBuffer(&ssh_host);\n\n}\n\n\npid_t\ndisable_wal_receiver(PGconn *conn)\n{\n\tchar buf[MAXLEN];\n\tint wal_retrieve_retry_interval, new_wal_retrieve_retry_interval;\n\tpid_t wal_receiver_pid = UNKNOWN_PID;\n\tint kill_ret;\n\tint i, j;\n\tint max_retries = 2;\n\n\tif (is_superuser_connection(conn, NULL) == false)\n\t{\n\t\tlog_error(_(\"superuser connection required\"));\n\t\treturn UNKNOWN_PID;\n\t}\n\n\tif (get_recovery_type(conn) == RECTYPE_PRIMARY)\n\t{\n\t\tlog_error(_(\"node is not in recovery\"));\n\t\tlog_detail(_(\"wal receiver can only run on standby nodes\"));\n\t\treturn UNKNOWN_PID;\n\t}\n\n\twal_receiver_pid = (pid_t)get_wal_receiver_pid(conn);\n\n\tif (wal_receiver_pid == UNKNOWN_PID)\n\t{\n\t\tlog_warning(_(\"unable to retrieve wal receiver PID\"));\n\t\treturn UNKNOWN_PID;\n\t}\n\n\tget_pg_setting(conn, \"wal_retrieve_retry_interval\", buf);\n\n\t/* TODO: potentially handle atoi error, though unlikely at this point */\n\twal_retrieve_retry_interval = atoi(buf);\n\n\tnew_wal_retrieve_retry_interval = wal_retrieve_retry_interval + WALRECEIVER_DISABLE_TIMEOUT_VALUE;\n\n\tif (wal_retrieve_retry_interval < WALRECEIVER_DISABLE_TIMEOUT_VALUE)\n\t{\n\t\tbool success;\n\n\t\tlog_notice(_(\"setting \\\"wal_retrieve_retry_interval\\\" to %i milliseconds\"),\n\t\t\t\t   new_wal_retrieve_retry_interval);\n\t\talter_system_int(conn, \"wal_retrieve_retry_interval\", new_wal_retrieve_retry_interval);\n\n\t\tsuccess = pg_reload_conf(conn);\n\n\t\tif (success == false)\n\t\t{\n\t\t\tlog_warning(_(\"unable to reload configuration\"));\n\t\t\treturn UNKNOWN_PID;\n\t\t}\n\t}\n\n\t/*\n\t * If, at this point, the WAL receiver is not running, we don't need to (and indeed can't)\n\t * kill it.\n\t */\n\tif (wal_receiver_pid == 0)\n\t{\n\t\tlog_warning(_(\"wal receiver not running\"));\n\t\treturn UNKNOWN_PID;\n\t}\n\n\n\t/* why 5? */\n\tlog_info(_(\"sleeping 5 seconds\"));\n\tsleep(5);\n\n\t/* see comment below as to why we need a loop here */\n\tfor (i = 0; i < max_retries; i++)\n\t{\n\t\tlog_notice(_(\"killing WAL receiver with PID %i\"), (int)wal_receiver_pid);\n\n\t\tkill((int)wal_receiver_pid, SIGTERM);\n\n\t\tfor (j = 0; j < 30; j++)\n\t\t{\n\t\t\tkill_ret = kill(wal_receiver_pid, 0);\n\n\t\t\tif (kill_ret != 0)\n\t\t\t{\n\t\t\t\tlog_info(_(\"WAL receiver with pid %i killed\"), (int)wal_receiver_pid);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsleep(1);\n\t\t}\n\n\t\t/*\n\t\t * Wait briefly to check that the WAL receiver has indeed gone away -\n\t\t * for reasons as yet unclear, after a server start/restart, immediately\n\t\t * after the first time a WAL receiver is killed, a new one is started\n\t\t * straight away, so we'll need to kill that too.\n\t\t */\n\t\tsleep(1);\n\t\twal_receiver_pid = (pid_t)get_wal_receiver_pid(conn);\n\t\tif (wal_receiver_pid == UNKNOWN_PID || wal_receiver_pid == 0)\n\t\t\tbreak;\n\t}\n\n\treturn wal_receiver_pid;\n}\n\npid_t\nenable_wal_receiver(PGconn *conn, bool wait_startup)\n{\n\tchar buf[MAXLEN];\n\tint wal_retrieve_retry_interval;\n\tpid_t wal_receiver_pid = UNKNOWN_PID;\n\n\t/* make timeout configurable */\n\tint i, timeout = 30;\n\n\tif (PQstatus(conn) != CONNECTION_OK)\n\t{\n\t\tlog_error(_(\"database connection not available\"));\n\t\treturn UNKNOWN_PID;\n\t}\n\n\tif (is_superuser_connection(conn, NULL) == false)\n\t{\n\t\tlog_error(_(\"superuser connection required\"));\n\t\treturn UNKNOWN_PID;\n\t}\n\n\tif (get_recovery_type(conn) == RECTYPE_PRIMARY)\n\t{\n\t\tlog_error(_(\"node is not in recovery\"));\n\t\tlog_detail(_(\"wal receiver can only run on standby nodes\"));\n\t\treturn UNKNOWN_PID;\n\t}\n\n\tif (get_pg_setting(conn, \"wal_retrieve_retry_interval\", buf) == false)\n\t{\n\t\tlog_error(_(\"unable to retrieve \\\"wal_retrieve_retry_interval\\\"\"));\n\t\treturn UNKNOWN_PID;\n\t}\n\n\t/* TODO: potentially handle atoi error, though unlikely at this point */\n\twal_retrieve_retry_interval = atoi(buf);\n\n\tif (wal_retrieve_retry_interval > WALRECEIVER_DISABLE_TIMEOUT_VALUE)\n\t{\n\t\tint new_wal_retrieve_retry_interval = wal_retrieve_retry_interval - WALRECEIVER_DISABLE_TIMEOUT_VALUE;\n\t\tbool success;\n\n\t\tlog_notice(_(\"setting \\\"wal_retrieve_retry_interval\\\" to %i ms\"),\n\t\t\t\t   new_wal_retrieve_retry_interval);\n\n\t\tsuccess = alter_system_int(conn,\n\t\t\t\t\t\t\t\t   \"wal_retrieve_retry_interval\",\n\t\t\t\t\t\t\t\t   new_wal_retrieve_retry_interval);\n\n\t\tif (success == false)\n\t\t{\n\t\t\tlog_warning(_(\"unable to change \\\"wal_retrieve_retry_interval\\\"\"));\n\t\t\treturn UNKNOWN_PID;\n\t\t}\n\n\t\tsuccess = pg_reload_conf(conn);\n\n\t\tif (success == false)\n\t\t{\n\t\t\tlog_warning(_(\"unable to reload configuration\"));\n\t\t\treturn UNKNOWN_PID;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* TODO: add threshold sanity check */\n\t\tlog_info(_(\"\\\"wal_retrieve_retry_interval\\\" is %i, not changing\"),\n\t\t\t\t wal_retrieve_retry_interval);\n\t}\n\n\tif (wait_startup == false)\n\t\treturn UNKNOWN_PID;\n\n\tfor (i = 0; i < timeout; i++)\n\t{\n\t\twal_receiver_pid = (pid_t)get_wal_receiver_pid(conn);\n\n\t\tif (wal_receiver_pid > 0)\n\t\t\tbreak;\n\n\t\tlog_info(_(\"sleeping %i of maximum %i seconds waiting for WAL receiver to start up\"),\n\t\t\t\t i + 1, timeout)\n\t\tsleep(1);\n\t}\n\n\tif (wal_receiver_pid == UNKNOWN_PID)\n\t{\n\t\tlog_warning(_(\"unable to retrieve WAL receiver PID\"));\n\t\treturn UNKNOWN_PID;\n\t}\n\telse if (wal_receiver_pid == 0)\n\t{\n\t\tlog_error(_(\"WAL receiver did not start up after %i seconds\"), timeout);\n\t\treturn UNKNOWN_PID;\n\t}\n\n\tlog_info(_(\"WAL receiver started up with PID %i\"), (int)wal_receiver_pid);\n\n\treturn wal_receiver_pid;\n}\n\n\n"
        },
        {
          "name": "sysutils.h",
          "type": "blob",
          "size": 1.43359375,
          "content": "/*\n * sysutils.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _SYSUTILS_H_\n#define _SYSUTILS_H_\n\nextern bool local_command(const char *command, PQExpBufferData *outputbuf);\nextern bool local_command_return_value(const char *command, PQExpBufferData *outputbuf, int *return_value);\nextern bool local_command_simple(const char *command, PQExpBufferData *outputbuf);\n\nextern bool remote_command(const char *host, const char *user, const char *command, const char *ssh_options, PQExpBufferData *outputbuf);\nextern void make_remote_command(const char *host, const char *user, const char *command, const char *ssh_options, PQExpBufferData *ssh_command);\n\nextern pid_t disable_wal_receiver(PGconn *conn);\nextern pid_t enable_wal_receiver(PGconn *conn, bool wait_startup);\n\n#endif\t\t\t\t\t\t\t/* _SYSUTILS_H_ */\n"
        },
        {
          "name": "voting.h",
          "type": "blob",
          "size": 0.8818359375,
          "content": "/*\n * voting.h\n * Copyright (c) EnterpriseDB Corporation, 2010-2021\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n#ifndef _VOTING_H_\n#define _VOTING_H_\n\ntypedef enum\n{\n\tVS_UNKNOWN = -1,\n\tVS_NO_VOTE,\n\tVS_VOTE_REQUEST_RECEIVED,\n\tVS_VOTE_INITIATED\n} NodeVotingStatus;\n\n#endif\t\t\t\t\t\t\t/* _VOTING_H_ */\n"
        }
      ]
    }
  ]
}