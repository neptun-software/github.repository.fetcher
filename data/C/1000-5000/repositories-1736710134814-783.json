{
  "metadata": {
    "timestamp": 1736710134814,
    "page": 783,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "microsoft/SysmonForLinux",
      "stars": 1787,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".container",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.509765625,
          "content": "# Prerequisites\n*.d\n\n# Compiled Object files\n*.slo\n*.lo\n*.o\n*.obj\n\n# Precompiled Headers\n*.gch\n*.pch\n\n# Compiled Dynamic libraries\n*.so\n*.dylib\n*.dll\n\n# Fortran module files\n*.mod\n*.smod\n\n# Compiled Static libraries\n*.lai\n*.la\n*.a\n*.lib\n\n# Executables\n*.exe\n*.out\n*.app\n\n# Logs\n*.log\n*.db\n\n# CMake\nCMakeLists.txt.user\nCMakeCache.txt\nCMakeFiles\nCMakeScripts\nTesting\nMakefile\ncmake_install.cmake\ninstall_manifest.txt\ncompile_commands.json\nCTestTestfile.cmake\n\n# build artifacts\nbin/\nbuild/\nobj/\npkgbuild/\n\n# dev env\n.vscode/"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.0986328125,
          "content": "[submodule \"sysmonCommon\"]\n\tpath = sysmonCommon\n\turl = https://github.com/Microsoft/SysmonCommon.git\n"
        },
        {
          "name": "BUILD.md",
          "type": "blob",
          "size": 3.5224609375,
          "content": "# Build\nPlease see the history of this file for instructions for older, unsupported versions.\n\n## Prerequisites\n- SysinternalsEBPF being installed:\nlibrary `libsysinternalsEBPF.so`, header `libsysinternalsEBPF.h`, plus\nresource files in `/opt/sysinternalsEBPF`. These can be installed from\nthe\n[SysinternalsEBPF](https://github.com/Microsoft/SysinternalsEBPF)\nproject or via the `sysinternalsebpf` DEB package from the\n_packages.microsoft.com_ repository (see [INSTALL.md](INSTALL.md)).\nIf you installed SysinternalsEBPF via make install, you may need to add /usr/local/lib to the loader library path (LD_LIBRARY_PATH).\n\n- .NET 6 SDK. Please see [.NET Installation](https://learn.microsoft.com/en-us/dotnet/core/install/linux). Note: If during installation you encounter \"A fatal error occurred. The folder [/usr/share/dotnet/host/fxr] does not exist\", please see [here](https://stackoverflow.com/questions/73753672/a-fatal-error-occurred-the-folder-usr-share-dotnet-host-fxr-does-not-exist)\n\n- clang/llvm v10+\n\n### Ubuntu 20.04+\n```\nsudo apt update\ndotnet tool install --global dotnet-t4 --version 2.3.1\nsudo apt -y install build-essential gcc g++ make cmake libelf-dev llvm clang libxml2 libxml2-dev libzstd1 git libgtest-dev apt-transport-https dirmngr googletest google-mock libgmock-dev libjson-glib-dev libc6-dev-i386 libssl-dev\n```\n\n### Rocky 9\n```\nsudo dnf install dnf-plugins-core\nsudo dnf config-manager --set-enabled crb\nsudo dnf install epel-release\n\nsudo dnf update\ndotnet tool install --global dotnet-t4 --version 2.3.1\nsudo yum install gcc gcc-c++ make cmake llvm clang elfutils-libelf-devel rpm-build json-glib-devel python3 libxml2-devel gtest-devel gmock gmock-devel glibc-devel.i686 openssl-devel\n```\n\n### Rocky 8\n```\nsudo dnf install dnf-plugins-core\nsudo dnf install epel-release\nsudo dnf config-manager --set-enabled powertools\n\nsudo dnf update\ndotnet tool install --global dotnet-t4 --version 2.3.1\nsudo yum install gcc gcc-c++ make cmake llvm clang elfutils-libelf-devel rpm-build json-glib-devel python3 libxml2-devel gtest-devel gmock gmock-devel glibc-devel.i686 openssl-devel\n```\n\n### Debian 11\n```\nwget https://packages.microsoft.com/config/debian/11/packages-microsoft-prod.deb -O packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\nrm packages-microsoft-prod.deb\nsudo apt update\ndotnet tool install --global dotnet-t4 --version 2.3.1\nsudo apt -y install build-essential gcc g++ make cmake libelf-dev llvm clang libzstd1 git libjson-glib-dev libxml2 libxml2-dev googletest google-mock libgmock-dev libc6-dev-i386 libssl-dev\n```\n\n## Build\n```\ncd\ngit clone --recurse-submodules https://github.com/Microsoft/SysmonForLinux.git\ncd SysmonForLinux\nmkdir build\ncd build\ncmake ..\nmake\n```\n\n## Test\n```\n./sysmonUnitTests\n```\n\n## Run\n```\nsudo ./sysmon -?\n```\n\n## Install\n```\nsudo ./sysmon -i CONFIG_FILE\n```\nThis will install sysmon and associated files into the /opt/sysmon directory.\nThe binary is portable and self-contained - the build process packs the\nrequired files into the binary for installation with '-i'. Sysmon will restart\non reboot with the same configuration.\n\nChange the configuration with\n```\nsudo /opt/sysmon/sysmon -c CONFIG_FILE\n```\n\nUninstall sysmon with\n```\nsudo /opt/sysmon/sysmon -u\n```\n\n## Make Packages\nPackages can be generated with:\n```\nmake deb\n```\nor\n```\nmake rpm\n```\n\nThe directories build/deb and build/rpm will be populated with the required\nfiles. If dpkg-deb is available, the build/deb directory will be used to create\na deb package. Similarly if rpmbuild is available, the build/rpm directory will\nbe used to create an rpm package.\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 26.5009765625,
          "content": "#\n#\n#    SysmonForLinux\n#\n#    Copyright (c) Microsoft Corporation\n#\n#    All rights reserved.\n#\n#    MIT License\n#\n#    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n#\n#    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n#\n#    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n#\n\n#################################################################################\n#\n# CMakeLists.txt\n#\n# Build script\n#\n#################################################################################\n\n#################################################################################\n# NOTE:                                                                         #\n# Please compile in a build directory rather than the source directory.         #\n# From Sysmon/linux:                                                            #\n#                                                                               #\n#    $ mkdir build; cd build                                                    #\n#    $ cmake ..                                                                 #\n#    $ make                                                                     #\n#                                                                               #\n# If you later change this CMakeLists.txt file, remake the build directory.     #\n#                                                                               #\n#    $ cd ..                                                                    #\n#    $ rm -rf build                                                             #\n#    $ mkdir build; cd build                                                    #\n#    $ cmake ..                                                                 #\n#    $ make                                                                     #\n#                                                                               #\n#################################################################################\n\ncmake_minimum_required(VERSION 3.10)\ncmake_policy(SET CMP0048 NEW)\n\n#\n# set the project name - version is MAJOR.MINOR.PATCH.RELEASE - releases start at 1\n#\nif (DEFINED ENV{VERSION})\n  project(SysmonForLinux VERSION $ENV{VERSION})\nelse()\n  project(SysmonForLinux VERSION 0.0.0.0)\nendif()\n\nconfigure_file(linuxVersion.h.in linuxVersion.h)\nconfigure_file(package/DEBIAN.in/control.in DEBIANcontrol)\nconfigure_file(package/SPECS.in/spec.in SPECS.spec)\n\n#\n# enable Debug while pre-release; re-enable it post-release to add symbols to binary\n#\n#set(CMAKE_BUILD_TYPE Debug)\n#option(DEBUG_K \"Enter debug mode\" On)\n\n#\n# external programs used by this build\n#\nset(TEXTTRANSFORM \"$ENV{HOME}/.dotnet/tools/t4\")\nset(ICONV \"/usr/bin/iconv\")\nset(LD \"/usr/bin/ld\")\n\n#\n# package name\n#\nset(PACKAGE_NAME \"sysmonforlinux\")\n\n#\n# report warnings as errors\n# -g is required for BTF and CO:RE\n#\nadd_compile_options(-Wall -Werror -g -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2 -fstack-protector-all -O2)\n\n#\n# support for C++17\n#\nset(CMAKE_CXX_FLAGS \"-std=gnu++17\")\n\n#\n# rely on libxml2 having been installed, for XML configuration and output\n#\nfind_package(LibXml2 2.0.0 REQUIRED)\n\n#\n# source directories\n#\nif(SYSMON_ADO)\nset(SYSMON_COMMON_SOURCE_DIR \"${CMAKE_SOURCE_DIR}/../sysmonCommon/\")\nset(SYSMON_TESTS_SOURCE_DIR \"${CMAKE_SOURCE_DIR}/../test/UnitTests/\")\nelse()\nset(SYSMON_COMMON_SOURCE_DIR \"${CMAKE_SOURCE_DIR}/sysmonCommon/\")\nset(SYSMON_TESTS_SOURCE_DIR \"${CMAKE_SOURCE_DIR}/sysmonCommon/UnitTests/\")\nendif()\n\n#\n# Compress man page\n#\nset(SYSMON_COMPRESS_MAN \"sysmon.8.gz\")\n\nadd_custom_target(sysmonManPageCompress ALL\n                  DEPENDS ${PROJECT_BINARY_DIR}/${SYSMON_COMPRESS_MAN}\n                  )\n\nadd_custom_command(OUTPUT ${PROJECT_BINARY_DIR}/${SYSMON_COMPRESS_MAN}\n                   COMMAND gzip -f -c \"${CMAKE_SOURCE_DIR}/package/usr/share/man/man8/sysmon.8\" > ${PROJECT_BINARY_DIR}/${SYSMON_COMPRESS_MAN}\n                   COMMENT \"Compressing Sysmon man page\"\n                   DEPENDS \"${CMAKE_SOURCE_DIR}/package/usr/share/man/man8/sysmon.8\"\n                  )\n\ninclude(ExternalProject)\n\n\n# Get and build openSSL.\n# When you update the GIT tag please make sure to delete the build\n# directory before building again.\nExternalProject_Add(openssl\n                    GIT_REPOSITORY https://github.com/openssl/openssl.git\n                    GIT_TAG openssl-3.1.3\n                    PREFIX ./openssl\n                    CONFIGURE_COMMAND cd ../openssl && ./Configure\n                    BUILD_COMMAND cd ../openssl && make\n                    INSTALL_COMMAND \"\"\n                    UPDATE_COMMAND \"\"\n                   )\n\nset(openssl_SOURCE_DIR ${CMAKE_BINARY_DIR}/openssl/src/openssl)\n\n#\n# make sysmon\n#\nadd_executable(sysmon\n               sysmonforlinux.c\n               linuxWideChar.c\n               linuxHelpers.cpp\n               networkTracker.cpp\n               outputxml.c\n               installer.c\n               \"${SYSMON_COMMON_SOURCE_DIR}/usage.c\"\n               \"${SYSMON_COMMON_SOURCE_DIR}/parsecommandline.c\"\n               \"${SYSMON_COMMON_SOURCE_DIR}/printSchema.c\"\n               \"${SYSMON_COMMON_SOURCE_DIR}/xml.cpp\"\n               \"${SYSMON_COMMON_SOURCE_DIR}/rules.c\"\n               \"${SYSMON_COMMON_SOURCE_DIR}/eventsCommon.cpp\"\n               \"${SYSMON_COMMON_SOURCE_DIR}/networkCommon.cpp\"\n               \"${SYSMON_COMMON_SOURCE_DIR}/networkmiscCommon.cpp\"\n               \"${SYSMON_COMMON_SOURCE_DIR}/dumpConfiguration.c\"\n               sysmonevents.h           # automatically generated during build\n               sysmonmsg.h              # automatically generated during build\n               sysmonmsgop.c            # automatically generated during build\n               sysmonmsgop.h            # automatically generated during build\n               # following are all embedded in sysmon as objects\n               manifest.xml.o\n               sysmonEBPFkern4.15.o.o\n               sysmonEBPFkern4.16.o.o\n               sysmonEBPFkern4.17-5.1.o.o\n               sysmonEBPFkern5.2.o.o\n               sysmonEBPFkern5.3-5.5.o.o\n               sysmonEBPFkern5.6-.o.o\n               sysmonEBPFkern4.15_core.o.o\n               sysmonEBPFkern4.16_core.o.o\n               sysmonEBPFkern4.17-5.1_core.o.o\n               sysmonEBPFkern5.2_core.o.o\n               sysmonEBPFkern5.3-5.5_core.o.o\n               sysmonEBPFkern5.6-_core.o.o\n               sysmonLogView.o\n               sysmon.d.o\n               sysmon.service.o\n               sysmonEBPFkern4.15.rep\n               sysmonEBPFkern4.16.rep\n               sysmonEBPFkern4.17-5.1.rep\n               sysmonEBPFkern5.2.rep\n               sysmonEBPFkern5.3-5.5.rep\n               sysmonEBPFkern5.6-.rep\n               sysmonEBPFkern4.15_core.rep\n               sysmonEBPFkern4.16_core.rep\n               sysmonEBPFkern4.17-5.1_core.rep\n               sysmonEBPFkern5.2_core.rep\n               sysmonEBPFkern5.3-5.5_core.rep\n               sysmonEBPFkern5.6-_core.rep\n               )\n\ntarget_include_directories(sysmon PUBLIC\n                           \"${CMAKE_SOURCE_DIR}\"\n                           \"${SYSMON_COMMON_SOURCE_DIR}\"\n                           \"${PROJECT_BINARY_DIR}\"\n                           \"/usr/include\"\n                           \"/usr/local/include\"\n                           \"${LIBXML2_INCLUDE_DIR}\"\n                           \"/opt/sysinternalsEBPF/ebpfKern\"\n                          )\n\n\nadd_custom_target(deb\n    COMMAND \"${CMAKE_SOURCE_DIR}/makePackages.sh\" \"${CMAKE_SOURCE_DIR}\" \"${PROJECT_BINARY_DIR}\" \"${PACKAGE_NAME}\" \"${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}\" \"${PROJECT_VERSION_TWEAK}\" \"deb\"\n    DEPENDS \"${CMAKE_SOURCE_DIR}/package\" \"${PROJECT_BINARY_DIR}/sysmon\"\n)\n\nadd_custom_target(rpm\n    COMMAND \"${CMAKE_SOURCE_DIR}/makePackages.sh\" \"${CMAKE_SOURCE_DIR}\" \"${PROJECT_BINARY_DIR}\" \"${PACKAGE_NAME}\" \"${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}\" \"${PROJECT_VERSION_TWEAK}\" \"rpm\"\n    DEPENDS \"${CMAKE_SOURCE_DIR}/package\" \"${PROJECT_BINARY_DIR}/sysmon\"\n)\n\nadd_dependencies(sysmon openssl)\n\n# list of ebpf programs to make\nset(EBPF_PROGS\n               sysmonEBPFkern4.15\n               sysmonEBPFkern4.16\n               sysmonEBPFkern4.17-5.1\n               sysmonEBPFkern5.2\n               sysmonEBPFkern5.3-5.5\n               sysmonEBPFkern5.6-\n)\n\nadd_custom_command(OUTPUT sysmonEBPFkern4.15.rep\n                   COMMAND \"${CMAKE_BINARY_DIR}/checkEBPFsizes\" sysmonEBPFkern4.15.o 4096 && touch sysmonEBPFkern4.15.rep\n                   COMMENT \"Checking sysmonEBPFkern4.15.o\"\n                   DEPENDS checkEBPFsizes sysmonEBPFkern4.15.o\n                  )\n\nadd_custom_command(OUTPUT sysmonEBPFkern4.16.rep\n                   COMMAND \"${CMAKE_BINARY_DIR}/checkEBPFsizes\" sysmonEBPFkern4.16.o 4096 && touch sysmonEBPFkern4.16.rep\n                   COMMENT \"Checking sysmonEBPFkern4.16.o\"\n                   DEPENDS checkEBPFsizes sysmonEBPFkern4.16.o\n                 )\n\nadd_custom_command(OUTPUT sysmonEBPFkern4.17-5.1.rep\n                   COMMAND \"${CMAKE_BINARY_DIR}/checkEBPFsizes\" sysmonEBPFkern4.17-5.1.o 4096 && touch sysmonEBPFkern4.17-5.1.rep\n                   COMMENT \"Checking sysmonEBPFkern4.17-5.1.o\"\n                   DEPENDS checkEBPFsizes sysmonEBPFkern4.17-5.1.o\n                  )\n\nadd_custom_command(OUTPUT sysmonEBPFkern5.2.rep\n                   COMMAND \"${CMAKE_BINARY_DIR}/checkEBPFsizes\" sysmonEBPFkern5.2.o 32768 && touch sysmonEBPFkern5.2.rep\n                   COMMENT \"Checking sysmonEBPFkern5.2.o\"\n                   DEPENDS checkEBPFsizes sysmonEBPFkern5.2.o\n                  )\n\nadd_custom_command(OUTPUT sysmonEBPFkern5.3-5.5.rep\n                   COMMAND \"${CMAKE_BINARY_DIR}/checkEBPFsizes\" sysmonEBPFkern5.3-5.5.o 32768 && touch sysmonEBPFkern5.3-5.5.rep\n                   COMMENT \"Checking sysmonEBPFkern5.3-5.5.o\"\n                   DEPENDS checkEBPFsizes sysmonEBPFkern5.3-5.5.o\n                  )\n\nadd_custom_command(OUTPUT sysmonEBPFkern5.6-.rep\n                   COMMAND \"${CMAKE_BINARY_DIR}/checkEBPFsizes\" sysmonEBPFkern5.6-.o 32768 && touch sysmonEBPFkern5.6-.rep\n                   COMMENT \"Checking sysmonEBPFkern5.6-.o\"\n                   DEPENDS checkEBPFsizes sysmonEBPFkern5.6-.o\n                  )\n\nadd_custom_command(OUTPUT sysmonEBPFkern4.15_core.rep\n                   COMMAND \"${CMAKE_BINARY_DIR}/checkEBPFsizes\" sysmonEBPFkern4.15_core.o 4096 touch sysmonEBPFkern4.15_core.rep\n                   COMMENT \"Checking sysmonEBPFkern4.15_core.o\"\n                   DEPENDS checkEBPFsizes sysmonEBPFkern4.15_core.o\n                  )\n\nadd_custom_command(OUTPUT sysmonEBPFkern4.16_core.rep\n                   COMMAND \"${CMAKE_BINARY_DIR}/checkEBPFsizes\" sysmonEBPFkern4.16_core.o 4096 && touch sysmonEBPFkern4.16_core.rep\n                   COMMENT \"Checking sysmonEBPFkern4.16_core.o\"\n                   DEPENDS checkEBPFsizes sysmonEBPFkern4.16_core.o\n                  )\n\nadd_custom_command(OUTPUT sysmonEBPFkern4.17-5.1_core.rep\n                   COMMAND \"${CMAKE_BINARY_DIR}/checkEBPFsizes\" sysmonEBPFkern4.17-5.1_core.o 4096 && touch sysmonEBPFkern4.17-5.1_core.rep\n                   COMMENT \"Checking sysmonEBPFkern4.17-5.1_core.o\"\n                   DEPENDS checkEBPFsizes sysmonEBPFkern4.17-5.1_core.o\n                  )\n\nadd_custom_command(OUTPUT sysmonEBPFkern5.2_core.rep\n                   COMMAND \"${CMAKE_BINARY_DIR}/checkEBPFsizes\" sysmonEBPFkern5.2_core.o 32768 && touch sysmonEBPFkern5.2_core.rep\n                   COMMENT \"Checking sysmonEBPFkern5.2_core.o\"\n                   DEPENDS checkEBPFsizes sysmonEBPFkern5.2_core.o\n                  )\n\nadd_custom_command(OUTPUT sysmonEBPFkern5.3-5.5_core.rep\n                   COMMAND \"${CMAKE_BINARY_DIR}/checkEBPFsizes\" sysmonEBPFkern5.3-5.5_core.o 32768 && touch sysmonEBPFkern5.3-5.5_core.rep\n                   COMMENT \"Checking sysmonEBPFkern5.3-5.5_core.o\"\n                   DEPENDS checkEBPFsizes sysmonEBPFkern5.3-5.5_core.o\n                  )\n\nadd_custom_command(OUTPUT sysmonEBPFkern5.6-_core.rep\n                   COMMAND \"${CMAKE_BINARY_DIR}/checkEBPFsizes\" sysmonEBPFkern5.6-_core.o 32768 && touch sysmonEBPFkern5.6-_core.rep\n                   COMMENT \"Checking sysmonEBPFkern5.6-_core.o\"\n                   DEPENDS checkEBPFsizes sysmonEBPFkern5.6-_core.o\n                  )\n\n# list of files the EBPF programs depend upon\nset(EBPF_DEPENDS\n               sysmon_defs.h\n               linuxTypes.h\n               \"${SYSMON_COMMON_SOURCE_DIR}/ioctlcmd.h\"\n               /opt/sysinternalsEBPF/ebpfKern/sysinternalsEBPF_helpers.c\n               /opt/sysinternalsEBPF/ebpfKern/sysinternalsEBPF_common.h\n               /opt/sysinternalsEBPF/ebpfKern/sysinternalsEBPFoffsets.h\n               /opt/sysinternalsEBPF/ebpfKern/sysinternalsEBPFshared.h\n               ebpfKern/sysmonEBPF_common.h\n               ebpfKern/sysmonGenericEntry_tp.c\n               ebpfKern/sysmonGenericEntry_rawtp.c\n               ebpfKern/sysmonHelpers.c\n               ebpfKern/sysmonProcCreate.c\n               ebpfKern/sysmonProcCreate_tp.c\n               ebpfKern/sysmonProcCreate_rawtp.c\n               ebpfKern/sysmonFileCreate.c\n               ebpfKern/sysmonFileCreate_tp.c\n               ebpfKern/sysmonFileCreate_rawtp.c\n               ebpfKern/sysmonFileOpen.c\n               ebpfKern/sysmonFileOpen_tp.c\n               ebpfKern/sysmonFileOpen_rawtp.c\n               ebpfKern/sysmonFileDelete.c\n               ebpfKern/sysmonFileDelete_tp.c\n               ebpfKern/sysmonFileDelete_rawtp.c\n               ebpfKern/sysmonFileDeleteAt.c\n               ebpfKern/sysmonFileDeleteAt_tp.c\n               ebpfKern/sysmonFileDeleteAt_rawtp.c\n               ebpfKern/sysmonFileDeleteAtCwd.c\n               ebpfKern/sysmonFileDeleteAtCwd_tp.c\n               ebpfKern/sysmonFileDeleteAtCwd_rawtp.c\n               ebpfKern/sysmonProcTerminated.c\n               ebpfKern/sysmonTCPconnection_4_15.c\n               ebpfKern/sysmonTCPconnection_4_16_5_5.c\n               ebpfKern/sysmonTCPconnection_5_6_.c\n               ebpfKern/sysmonTCPaccept.c\n               ebpfKern/sysmonTCPaccept_tp.c\n               ebpfKern/sysmonTCPaccept_rawtp.c\n               ebpfKern/sysmonProcAccessed.c\n               ebpfKern/sysmonProcAccessed_tp.c\n               ebpfKern/sysmonProcAccessed_rawtp.c\n               ebpfKern/sysmonUDPsend.c\n               ebpfKern/sysmonUDPrecv.c\n               ebpfKern/sysmonUDPrecv_tp.c\n               ebpfKern/sysmonUDPrecv_rawtp.c\n               ebpfKern/sysmonCloseFD.c\n               ebpfKern/sysmonCloseFD_tp.c\n               ebpfKern/sysmonCloseFD_rawtp.c\n               sysmonevents.h   # automatically generated during build\n               sysmonmsg.h      # automatically generated during build\n               sysmonmsgop.c    # automatically generated during build\n               sysmonmsgop.h    # automatically generated during build\n)\n\n\n#\n# link sysmon\n#\ntarget_link_libraries(sysmon sysinternalsEBPF \"${LIBXML2_LIBRARIES}\" pthread ${openssl_SOURCE_DIR}/libcrypto.a ${CMAKE_DL_LIBS} )\n\n\n#\n# make sysmonLogView\n#\nadd_executable(sysmonLogView\n               sysmonLogView/sysmonLogView.cpp\n               sysmonLogView/sysmonGetEventName.c\n               sysmonmsgop.c\n               sysmonevents.h\n               sysmonmsg.h\n               sysmonmsgop.h\n)\n\ntarget_include_directories(sysmonLogView PUBLIC\n                           \"${CMAKE_SOURCE_DIR}\"\n                           \"${SYSMON_COMMON_SOURCE_DIR}\"\n                           \"${PROJECT_BINARY_DIR}\"\n                           \"/usr/include\"\n                           \"${LIBXML2_INCLUDE_DIR}\"\n                           )\n\ntarget_link_libraries(sysmonLogView \"${LIBXML2_LIBRARIES}\")\n\n\n#\n# make checkEBPFsizes\n#\nadd_executable(checkEBPFsizes\n               checkEBPFsizes/checkEBPFsizes.c\n)\n\ntarget_include_directories(checkEBPFsizes PUBLIC\n                           \"/usr/include\"\n                           )\n\ntarget_link_libraries(checkEBPFsizes sysinternalsEBPF)\n\n#\n# GTest required for unit tests\n#\nfind_package(GTest REQUIRED)\n\n#\n# make sysmon unit tests\n#\nadd_executable(sysmonUnitTests\n               \"${SYSMON_TESTS_SOURCE_DIR}/main.cpp\"\n               \"${SYSMON_TESTS_SOURCE_DIR}/rules.cpp\"\n               \"${SYSMON_TESTS_SOURCE_DIR}/utils.cpp\"\n               \"${SYSMON_TESTS_SOURCE_DIR}/RuleEntry.cpp\"\n               test/linuxRules.cpp\n               linuxWideChar.c\n               linuxHelpers.cpp\n               outputxml.c\n               hexdump.c\n               \"${SYSMON_COMMON_SOURCE_DIR}/parsecommandline.c\"\n               \"${SYSMON_COMMON_SOURCE_DIR}/xml.cpp\"\n               \"${SYSMON_COMMON_SOURCE_DIR}/rules.c\"\n               \"${SYSMON_COMMON_SOURCE_DIR}/eventsCommon.cpp\"\n               sysmonevents.h\n               sysmonmsg.h\n               sysmonmsgop.h\n               sysmonmsgop.c\n               \"${PROJECT_BINARY_DIR}/testdata\"\n               \"${PROJECT_BINARY_DIR}/yoursleep\"\n               )\n\ntarget_link_libraries(sysmonUnitTests \"${LIBXML2_LIBRARIES}\" ${GTEST_LIBRARIES} pthread ${openssl_SOURCE_DIR}/libcrypto.a ${CMAKE_DL_LIBS})\ntarget_include_directories(sysmonUnitTests PUBLIC\n                           \"${CMAKE_SOURCE_DIR}\"\n                           \"${SYSMON_COMMON_SOURCE_DIR}\"\n                           \"${SYSMON_TESTS_SOURCE_DIR}\"\n                           \"${PROJECT_BINARY_DIR}\"\n                           \"/usr/include\"\n                           \"${LIBXML2_INCLUDE_DIR}\"\n                           \"${GTEST_INCLUDE_DIRS}\"\n                           )\n\n#\n# copy test data\n#\nadd_custom_command(OUTPUT \"${PROJECT_BINARY_DIR}/testdata\"\n                   COMMAND cp -a \"${SYSMON_TESTS_SOURCE_DIR}/data\" \"${PROJECT_BINARY_DIR}/testdata\"\n                   COMMENT \"Copying data to testdata\"\n                   DEPENDS \"${SYSMON_TESTS_SOURCE_DIR}/data\"\n                   )\n\n#\n# make mysleep test binary\n#\nadd_executable(mysleep test/mysleep.c)\nadd_custom_command(OUTPUT yoursleep\n                   COMMAND ln -s mysleep yoursleep\n                   DEPENDS mysleep\n                  )\n\n\n#\n# automatically generate sources from manifest.xml and manifest.tt\n#\nadd_custom_command(OUTPUT sysmonevents.h.utf16\n                   COMMAND \"${TEXTTRANSFORM}\" \"${SYSMON_COMMON_SOURCE_DIR}/manifest.tt\" -out sysmonevents.h.utf16 -a '!!type!header'\n                   COMMENT \"Extracting sysmonevents.h.utf16\"\n                   DEPENDS \"${SYSMON_COMMON_SOURCE_DIR}/manifest.tt\"\n                   )\n\nadd_custom_command(OUTPUT sysmonevents.h\n                   COMMAND \"${ICONV}\" -f ASCII -t UTF-8 sysmonevents.h.utf16 -o sysmonevents.h\n                   COMMENT \"Converting sysmonevents.h.utf16 to UTF8\"\n                   DEPENDS sysmonevents.h.utf16\n                   )\n\nadd_custom_command(OUTPUT sysmonmsg.mc.utf16\n                   COMMAND \"${TEXTTRANSFORM}\" \"${SYSMON_COMMON_SOURCE_DIR}/manifest.tt\" -out sysmonmsg.mc.utf16 -a '!!version!internal' -a '!!type!mc'\n                   COMMENT \"Extracting sysmonmsg.mc.utf16\"\n                   DEPENDS \"${SYSMON_COMMON_SOURCE_DIR}/manifest.tt\"\n                   )\n\nadd_custom_command(OUTPUT sysmonmsg.mc\n                   COMMAND \"${ICONV}\" -f ASCII -t UTF-8 sysmonmsg.mc.utf16 -o sysmonmsg.mc\n                   COMMENT \"Converting sysmonmsg.mc.utf16 to UTF8\"\n                   DEPENDS sysmonmsg.mc.utf16\n                   )\n\nadd_custom_command(OUTPUT sysmonmsg.h\n                   COMMAND \"${CMAKE_SOURCE_DIR}/extractMsgMc.sh\" > sysmonmsg.h\n                   COMMENT \"Extracting sysmonmsg.h from sysmonmsg.mc\"\n                   DEPENDS sysmonmsg.mc\n                   )\n\nadd_custom_command(OUTPUT sysmonmsgop.man.utf16\n                   COMMAND \"${TEXTTRANSFORM}\" \"${SYSMON_COMMON_SOURCE_DIR}/manifest.tt\" -out sysmonmsgop.man.utf16 -a '!!version!internal' -a '!!type!man'\n                   COMMENT \"Extracting sysmonmsgop.man.utf16\"\n                   DEPENDS \"${SYSMON_COMMON_SOURCE_DIR}/manifest.tt\"\n                   )\n\nadd_custom_command(OUTPUT sysmonmsgop.man\n                   COMMAND \"${ICONV}\" -f ASCII -t UTF-8 sysmonmsgop.man.utf16 -o sysmonmsgop.man\n                   COMMENT \"Converting sysmonmsgop.man.utf16 to UTF8\"\n                   DEPENDS sysmonmsgop.man.utf16\n                   )\n\nadd_custom_command(OUTPUT sysmonmsgop.h\n                   COMMAND \"${CMAKE_SOURCE_DIR}/extractMsgOp.sh\" HEADER > sysmonmsgop.h\n                   COMMENT \"Extracting sysmonmsgop.h from sysmonmsgop.man\"\n                   DEPENDS sysmonmsgop.man\n                   )\n\nadd_custom_command(OUTPUT sysmonmsgop.c\n                   COMMAND \"${CMAKE_SOURCE_DIR}/extractMsgOp.sh\" > sysmonmsgop.c\n                   COMMENT \"Extracting sysmonmsgop.c from sysmonmsgop.man\"\n                   DEPENDS sysmonmsgop.man\n                   )\n\n#\n# convert embedded files to objects for linking with the sysmon binary\n#\nadd_custom_command(OUTPUT manifest.xml.o\n                   COMMAND cd \"${SYSMON_COMMON_SOURCE_DIR}\" && \"${LD}\" -r -b binary -o \"${PROJECT_BINARY_DIR}/manifest.xml.o\" manifest.xml\n                   COMMENT \"Packing manifest.xml into manifest.xml.o\"\n                   DEPENDS \"${SYSMON_COMMON_SOURCE_DIR}/manifest.xml\"\n                   )\n\nset(PACKED_BINARY_FILES\n    sysmonEBPFkern4.15.o\n    sysmonEBPFkern4.16.o\n    sysmonEBPFkern4.17-5.1.o\n    sysmonEBPFkern5.2.o\n    sysmonEBPFkern5.3-5.5.o\n    sysmonEBPFkern5.6-.o\n    sysmonEBPFkern4.15_core.o\n    sysmonEBPFkern4.16_core.o\n    sysmonEBPFkern4.17-5.1_core.o\n    sysmonEBPFkern5.2_core.o\n    sysmonEBPFkern5.3-5.5_core.o\n    sysmonEBPFkern5.6-_core.o\n    sysmonLogView\n    sysmon.service\n    sysmon.d\n)\n\nforeach(BIN_FILE IN LISTS PACKED_BINARY_FILES)\nadd_custom_command(OUTPUT \"${BIN_FILE}.o\"\n                   COMMAND \"${LD}\" -r -b binary -o \"${BIN_FILE}.o\" \"${BIN_FILE}\"\n                   COMMENT \"Packing ${BIN_FILE} into ${BIN_FILE}.o\"\n                   DEPENDS \"${PROJECT_BINARY_DIR}/${BIN_FILE}\"\n                   )\nendforeach(BIN_FILE)\n\n\n#\n# copy the service files and installer to the build directory\n#\nadd_custom_command(OUTPUT \"${PROJECT_BINARY_DIR}/sysmon.d\"\n                   COMMAND cp \"${CMAKE_SOURCE_DIR}/sysmon.d\" \"${PROJECT_BINARY_DIR}/sysmon.d\"\n                   COMMENT \"Copying sysmon.d\"\n                   DEPENDS \"${CMAKE_SOURCE_DIR}/sysmon.d\"\n                   )\n\nadd_custom_command(OUTPUT \"${PROJECT_BINARY_DIR}/sysmon.service\"\n                   COMMAND cp \"${CMAKE_SOURCE_DIR}/sysmon.service\" \"${PROJECT_BINARY_DIR}/sysmon.service\"\n                   COMMENT \"Copying sysmon.service\"\n                   DEPENDS \"${CMAKE_SOURCE_DIR}/sysmon.service\"\n                   )\n\n\n#\n# EBPF COMPILE OPTIONS\n#\n# This section specifies the options for building ebpf programs\n#\n\n# There are parts of the build process that needs to run when the CMake file changes.\n# Specifically, the eBPF program compilation. This is done by comparing the hash of\n# the CMake file to the previous hash. If they are different, then the eBPF programs\n# are rebuilt.\nfile(MD5 \"${CMAKE_CURRENT_LIST_FILE}\" CMAKE_FILE_HASH)\n\nset(PREVIOUS_CMAKE_FILE_HASH \"\")\nif(EXISTS \"${PROJECT_BINARY_DIR}/previous_cmake_file_hash.txt\")\n    file(READ \"${PROJECT_BINARY_DIR}/previous_cmake_file_hash.txt\" PREVIOUS_CMAKE_FILE_HASH)\nendif()\n\nfile(WRITE \"${PROJECT_BINARY_DIR}/previous_cmake_file_hash.txt\" \"${CMAKE_FILE_HASH}\")\n\n# set binaries and options for clang and llc\nset(CLANG \"clang\")\nset(LLC \"llc\")\nset(CLANG_OPTIONS -Wno-unused-value\n                  -Wno-pointer-sign\n                  -Wno-compare-distinct-pointer-types\n                  -Wno-gnu-variable-sized-type-not-at-end\n                  -Wno-address-of-packed-member\n                  -Wno-tautological-compare\n                  -Wno-unknown-warning-option\n                  -g\n                  )\nset(CLANG_DEFINES -D __KERNEL__\n                  -D __BPF_TRACING__\n                  -D __TARGET_ARCH_x86\n                  -D __linux__\n                  )\nif (DEBUG_K)\n    message(\"Using DEBUG_K Option...\")\n    list(APPEND CLANG_DEFINES -DDEBUG_K)\nendif()\n\nset(CLANG_INCLUDES\n                   -I \"/usr/include\"\n                   -I \"/usr/include/x86_64-linux-gnu\"\n                   -I \"${CMAKE_SOURCE_DIR}\"\n                   -I \"${SYSMON_COMMON_SOURCE_DIR}\"\n                   -I \"/opt/sysinternalsEBPF/ebpfKern\"\n                   -I \"/opt/sysinternalsEBPF/libbpf\"\n                   -I \"${CMAKE_BINARY_DIR}\"\n                   -I \"${libbpf_SOURCE_DIR}/src\"\n                   )\n\nset(EBPF_CORE_PROG_SUFFIX \"_core\")\n\n#\n# EBPF\n#\n# This section makes the EBPF programs\n#\n\n# function to make ebpf programs\nfunction(build_ebpf ebpfsrc suffix)\n    add_custom_command(OUTPUT ${ebpfsrc}${suffix}.o\n                       COMMAND \"${CLANG}\" -nostdinc -isystem `gcc -print-file-name=include` ${CLANG_INCLUDES} ${CLANG_DEFINES} -O2 ${CLANG_OPTIONS} -target bpf -fno-stack-protector -c \"${CMAKE_SOURCE_DIR}/ebpfKern/${ebpfsrc}.c\" -o \"${ebpfsrc}${suffix}.o\"\n                       COMMENT \"Building EBPF object ${ebpfsrc}${suffix}.o\"\n                       DEPENDS ebpfKern/${ebpfsrc}.c ${EBPF_DEPENDS}\n                       )\nendfunction()\n\n# Loop for all ebpf programs\nforeach(EBPF_PROG IN LISTS EBPF_PROGS)\n\n    # add custom target to build all ebpf programs with 'all'\n    add_custom_target(${EBPF_PROG} ALL\n                      DEPENDS \"${CMAKE_SOURCE_DIR}/ebpfKern/${EBPF_PROG}.c\"\n                     )\n\n    # test to only build ebpf programs when they have changed or if CMake file has changed.\n    if(${CMAKE_SOURCE_DIR}/ebpfKern/${EBPF_PROG}.c IS_NEWER_THAN ${CMAKE_BINARY_DIR}/${EBPF_PROG}.o OR NOT \"${CMAKE_FILE_HASH}\" STREQUAL \"${PREVIOUS_CMAKE_FILE_HASH}\")\n        # first build NON CORE program\n        list(REMOVE_ITEM CLANG_DEFINES -DEBPF_CO_RE)\n        build_ebpf(${EBPF_PROG} \"\")\n        set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES ${EBPF_PROG}.o)\n    endif()\n\n    if(${CMAKE_SOURCE_DIR}/ebpfKern/${EBPF_PROG}.c IS_NEWER_THAN ${CMAKE_BINARY_DIR}/${EBPF_PROG}${EBPF_CORE_PROG_SUFFIX}.o OR NOT \"${CMAKE_FILE_HASH}\" STREQUAL \"${PREVIOUS_CMAKE_FILE_HASH}\")\n        # next build CORE program\n        list(APPEND CLANG_DEFINES -DEBPF_CO_RE)\n        build_ebpf(${EBPF_PROG} ${EBPF_CORE_PROG_SUFFIX})\n        set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES ${EBPF_PROG}${EBPF_CORE_PROG_SUFFIX}.o)\n    endif()\n\nendforeach(EBPF_PROG)\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.3349609375,
          "content": "# Code of Conduct\nThis project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](opencode@microsoft.com) with any additional questions or comments."
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.52734375,
          "content": "# Contributing\n\nBefore we can accept a pull request from you, you'll need to sign a [Contributor License Agreement (CLA)](https://cla.microsoft.com). It is an automated process and you only need to do it once.\nTo enable us to quickly review and accept your pull requests, always create one pull request per issue and link the issue in the pull request. Never merge multiple requests in one unless they have the same root cause. Be sure to follow our Coding Guidelines and keep code changes as small as possible. Avoid pure formatting changes to code that has not been modified otherwise. Pull requests should contain tests whenever possible.\n\n# Branching\nThe master branch contains current development.  While CI should ensure that master always builds, it is still considered pre-release code.  Release checkpoints will be put into stable branches for maintenance.\n\nTo contribute, fork the repository and create a branch in your fork for your work.  Please keep branch names short and descriptive.  Please direct PRs into the upstream master branch.\n\n# Testing\n* There are a multitude of tests included in the `tests` directory of the repository.  \n* Add new tests corresponding to your change, if applicable. Include tests when adding new features. When fixing bugs, start with adding a test that highlights how the current behavior is broken.  \n* Make sure that the tests are all passing, including your new tests.\n\n# Pull Requests\n* Always tag a work item or issue with a pull request.\n* Limit pull requests to as few issues as possible, preferably 1 per PR\n\n\n"
        },
        {
          "name": "DEVELOP.md",
          "type": "blob",
          "size": 19.4814453125,
          "content": "# Sysmon For Linux Developer Details\n\n## Introduction\n\nSysmon For Linux is a port of the Windows Sysmon tool, with the driver\nreplaced by eBPF programs.  This document describes developer details to\nassist people who wish to modify or extend it.\n\n## Build environment\n\nThe build directory, created as part of the initial compilation, contains all\nthe Makefiles needed to recompile Sysmon For Linux.\n\nIf you are refactoring between the main program and the library, refactoring\neBPF programs, or modifying the CMakeLists.txt files, then you will probably\nbenefit from removing the build directory and recreating it, to ensure that\ncmake properly updates its cache.\n```\nrm -rf build\nmkdir build\ncd build\ncmake ..\nmake\n```\n\n## Debugging\n\nBoth the main program and the libary can be set to build with symbols by\nsetting the CMAKE\\_BUILD\\_TYPE to Debug in the CMakeLists.txt files.  You may\nneed to remove the build directory and rebuild from scratch to be sure that\neverything is rebuilt with symbols (or without).\n```\nset(CMAKE_BUILD_TYPE Debug)\n```\nThe eBPF programs can be configured to enable BPF\\_PRINTK() by setting the\nDEBUG\\_K option on in the CMakeLists.txt files.  Messages outputted with\nBPF\\_PRINTK() are sent to /sys/kernel/debug/tracing/trace\\_pipe.  Cat this\npseduo-file to monitor the output.  When DEBUG\\_K is set to Off, BPF\\_PRINTK()\nbecomes a NOP.  As before, you may need to remove the build directory and\nrebuild from scratch.\n```\noption(DEBUG_K \"Enter debug mode\" On)\n```\n\nHaving built with symbols, use gdb to debug the program.  Easiest is to attach\nto a running instance:\n```\nps -ef | grep sysmon\nsudo gdb ./sysmon -pid <Sysmon PID>\n```\n\nIf, instead, you want to debug program start-up issues, such as BPF loading,\noffsets loading, searching or discovering, or configuration setting, then you\nwill need to make gdb launch Sysmon For Linux and coach it through to the\nplace you want to break and/or step.\n```\nsudo gdb ./sysmon\n```\nSet a breakpoint on the line in main() that is \"pid = fork()\".  This line sets\nit up to be a daemon so we need to follow the child process here (as the\nparent will quit once the child has signalled that it has finished starting\nup.  For reasons unknown, gdb either fails to follow the child, or fails to\ntrigger the breakpoint, when continuing through the fork. Instead break on the\nfork itself and 'next' through it (which correctly follows the child).\n```\nb sysmonforlinux.c:1329\n    (or whatever line is \"pid = fork()\")\nset follow-fork-mode child\nr -i /opt/sysmon/config.xml -service\n    (will run sysmon with the current config file, but will not trigger\n     systemd to restart sysmon)\nn\n    (will step to next source code line)\n```\nRepeat the 'n' command until gdb reaches the startEBPF line, then set the\nfollow mode back to parent - otherwise if it goes into offsets discovery, it\nwill launch a temporary child and gdb will follow it instead of staying with\nthe main program.\n```\nset follow-fork-mode parent\n```\nNow you can set a breakpoint where you need, and 'continue' ('c') until it\nhits it.\n\n## Debugging eBPF Programs\n\nThe easiest way to debug eBPF programs is 'printf debugging', except as the\nprograms run in the kernel, we actually need 'printk debugging' instead. First\nmake sure the environment is set to enable DEBUG\\_K (see above), then simply\ninsert BPF\\_PRINTK() calls where necessary.\n```\n{BPF_PRINTK(format, args [,args ...]);}\n```\nNote that these calls are inside {} curly braces as BPF\\_PRINTK is a macro that\nconverts the format string into a local character array, supplying that and\nits size to the underlying bpf\\_trace\\_printk() helper, along with the arguments.\nAs BPF helpers are limited to 5 arguments total, you can therefore only supply\n3 optional arguments after the format string.  Note the limitations on\nconversion specifiers in the bpf\\_helpers man page; additionally note that %p\nonly prints 32 bits on older kernels, so use %lx instead.\n\nBe aware that you can grep the output of \n```\ncat /sys/kernel/debug/tracing/trace_pipe\n```\nto limit the volume of information if your program gets triggered by multiple\nprocesses.\n\nAdditionally, it is possible to debug eBPF programs with gdb by running the\nkernel inside a VM, and attaching gdb to it.\n\nSee:\nhttps://ebpf.io/summit-2020-slides/eBPF_Summit_2020-Lightning-Lorenzo_Fontana-Debugging_the_BPF_Virtual_Machine.pdf\nfor an overview.\n\n## Project Layout\n\n### Sysmon For Linux\n\nSysmon For Linux relies on the libsysinternalsEBPF.so shared library. Its main\nfunction parses the command line with Sysmon functions ported from, and shared\nwith, the Windows version.  Starting it up with the '-c' switch causes it to\nstore its command line in /opt/sysmon/arg{c,v} and trigger the running Sysmon\nFor Linux to cause it to drop its current config, load this new command line,\nand parse it to build the new config.\n\nStarting it with the '-i' switch causes it to stop any running copies, parse\nthe command line for validity and then start up depending on whether the\n'-service' switch is present or not. A user would not typically supply this\nswitch (unless they are debugging, see above), the absence of which indicates\nthat Sysmon For Linux was started from the command line.\n\nIn this situation, the program will store the command line in /opt/sysmon as\nfor configuration changes, and copy the configuration file (if supplied) to\n/opt/sysmon/config.xml. It will then exec the shell command 'systemctl start\nsysmon', essentially quitting as it does so.  This causes systemd to start it\nup as a system daemon, with the '-service' switch.\n\nThe command line arguments will be reloaded from /opt/sysmon, with the config\nfilename replaced with /opt/sysmon/config.xml, and the original returned\nseparately for reporting in a config change event.  This allows Sysmon For\nLinux to be launched from the command line with '-i' and for the whole config\nto be stored, and reloaded, when the command line version instructs systemd to\nstart it up again as a standard system daemon.\n\nThe main function then creates a sysinternalsEBPF configuration that specifies\nthe eBPF programs to be used for the different kernels, and for the different\ntypes of attachment (syscall tracepoints, syscall raw tracepoints, non-syscall\ntracepoints). It also specifies which syscalls should be active based on the\nloaded Sysmon config (with pseudo-syscalls specifying non-syscall activity),\nand which programs should be active based on those syscalls.\n\nTogether this configuration informs sysinternalsEBPF what to load for the\ndifferent kernel versions it could be running on, which programs to attach,\nand which events to make active. The configuration also specifies a callback\nfunction that will handle generated events, and a callback that signifies that\nthe start up has completed.\n\nSysinternalsEBPF calls the event callback every time an event is received from\nthe eBPF programs. Sysmon For Linux processes the event (if necessary, e.g.\nadding extra information, userland additional checks, etc) and then sends it to\nDispatchEvent() ported from the Windows version. Here it is processed and\nfiltered, and eventually reported to Syslog via FormatSyslogString() in\noutputxml.c.\n\n* installer.{c,h} - functions for installing Sysmon, and related to start up.\n* linuxHelpers.{cpp,h} - functions to replicate missing Windows functions.\n* linuxTypes.h - types/defines to repliate missing Windows types/defines.\n* linuxWideChar.{c,h} - functions to handle UTF16 strings (Windows WCHAR).\n* networkTracker.{cpp,h} - correlation engine for network events.\n* outputxml.{c,h} - output message formatter.\n\n### Sysmon For Linux ebpfKern\n\nThere are a number (currently 6) eBPF source files, made up from programs and\ninline functions in 30+ source files.  The main source files are:\n\n* sysmonEBPFkern4.15.c\n* sysmonEBPFkern4.16.c\n* sysmonEBPFkern4.17-5.1.c\n* sysmonEBPFkern5.2.c\n* sysmonEBPFkern5.3-5.5.c\n* sysmonEBPFkern5.6-.c\n\nThe numbers in the filenames specify the kernel versions that they support.\nThey set specific defines and include specific source files. Notable source\nfiles are:\n\n* sysmonEBPF\\_common.h - includes, defines, and map definitions.\n* sysmonHelpers.c - inline functions that do useful things.\n* sysmonGenericEntry\\_rawtp.c - program to attach to raw\\_syscalls/sys\\_enter\n    that stores arguments.\n* sysmonGenericEntry\\_tp.c - programs to attach to syscalls/sys\\_enter\n    tracepoints that stores arguments.\n\nTypically, userland memory can't be guaranteed to be paged in at the entry of\na syscall; as such, generic entry programs are attached to the entry points of\nsyscalls (a single entry point for raw syscalls, and each entry point for\ntraditional syscalls).  These generic entry programs simply store the arguments\nprovided to the syscalls so that they can be retrieved by programs attached to\nthe exit points, by which time the userland memory will have been paged in.\n\n(Side note: eBPF programs aren't permitted to 'sleep' on most kernels except\nthe very recent. Usually, when code attempts to access a memory location that\nis not paged in, a BRK happens and the memory pager takes control, pages it in\nand returns control to the point where the BRK happened so that the memory\naccess can be reattempted. By not being allowed to 'sleep', eBPF programs don't\nbenefit from this technology and all that happens is that the memory read\nfails.)\n\nThe programs attached to the syscall and raw syscall exit points are made up\nof three files:\n\n* sysmonEVENT.c - the inline function that processes the associated syscall,\n    and generates the Sysmon event.\n* sysmonEVENT\\_rawtp.c - the eBPF program that attaches to the raw syscalls exit\n    tracepoint, and calls the inline function.\n* sysmonEVENT\\_tp.c - the eBPF program that attaches to the specific traditional\n    tracepoint exit, and calls the inline function.\n\nThis approach reduces code duplication. These files can be created from the\nsysmonTEMPLATE.c, sysmonTEMPLATE\\_rawtp.c and sysmonTEMPLATE\\_tp.c files by\nrunning the makeEvent.sh script with the event name as parameter. Minimal edits\nshould be required for the rawtp and tp files, with the majority of the work\ngoing into the sysmonEVENT.c file. Ensure to include the rawtp and tp files in\nthe main source files mentioned above.\n\nIn addition to syscall tracepoints, Sysmon also attaches to non-syscall\ntracepoints, such as sched/sched\\_process\\_exit. These don't have an entry and\nexit, but a tracepoint that happens immediately before the relevant code in\nthe kernel (akin to entry in reality). In these cases there is just the\nrelevant program, which can be constructed by combining the sysmonEVENT.c and\nsysmonEVENT\\_rawtp.c files. Current sources for non-syscall tracepoints are:\n\n* sysmonProcTerminated.c - sched/sched\\_process\\_exit.\n* sysmonTCPconnection\\_4\\_15.c - tcp/tcp\\_set\\_state (v4.15 only).\n* sysmonTCPconnection\\_4\\_15\\_5\\_5.c - inet/inet\\_sock\\_set\\_state (<= v5.6).\n* sysmonTCPconnection\\_5\\_6\\_.c - inet/inet\\_sock\\_set\\_state (>= v5.6).\n* sysmonUDPsend.c - skb/consume\\_skb.\n\n## So You Want To Implement An Existing Event?\n\nIf you want to implement an event that already exists in the Windows version of\nSysmon, then the process is relatively straight forward. Note that it depends\nentirely on the layout specified above so maybe give that some attention if\nthings get complicated. If you want to implement an entirely new event then see\nthe next section instead.\n\nThe process is broadly:\n\n* Identify the event you wish to add from the schema - run sysmon -s to see the\n    event schema.\n* Identify the associated event struct in sysmonCommon/ioctlcmd.h.\n* Identify the syscall(s) or tracepoint(s) that will provide information needed\n    to complete the event struct. Check /sys/kernel/debug/tracing/events for\n    the event classes and the actual events within them. Cat the format file to\n    see the parameters available to the tracepoints.\n* Identify whether one or more pseudo-event types are needed or whether the\n    existing event struct is suitable. Psuedo-event structs and EventTypes\n    should be added to linuxTypes.h.\n* Make the eBPF program(s) that generate the telemetry in ebpfKern. Use the\n    format file from the event in /sys/kernel/debug/tracing/events to create a\n    suitable input parameter struct.\n* Add the eBPF program(s) to the main eBPF source files.\n* Add the eBPF program(s) to the config in sysmonforlinux.c.\n* Add a case to the switch in SetActiveSyscalls() in sysmonforlinux.c to\n    specify which syscalls and pseudo-syscalls are required. New pseudo-\n    syscalls should be added to linuxTypes.h.\n* If necessary, add a corrolation engine to combine multiple tracepoint data -\n    see networkTracker as an example.\n* If necessary, add a case to the switch in handle\\_event() in sysmonforlinux.c\n    to post-process or correlate the new event. Ultimately, this new case\n    should (usually) eventually pass the event to DispatchEvent().\n\nThis process can be best understood by analysing the following examples.\n\n### Simple Example\n\nSysmonFileDelete is a good example of an existing event that only required a\nsimple solution; it attaches to the unlink() syscall and fills in a\nSYSMON\\_FILE\\_DELETE struct. No pseudo-events or pseudo-syscalls are\nnecessary. In the eBPF config in sysmonforlinux.c the programs are added to\nthe unlink() syscall, and the File Delete event is set in SetActiveSyscalls()\nin sysmonforlinux.c to require this syscall. No correlation engine in required,\nnor any post processing. In handle\\_event() in sysmonforlinux.c, the event\nsimply hits the Default case and is dispatched directly to DispatchEvent().\n\n### Slightly More Complex Example\n\nA slightly more complex example would be ProcessAccessed. Like File Delete, it\nonly relies on real syscalls - ptrace() in this case - so the mechcanics match\nmostly to the previous case. Where it differs, however, is in needing some\npost-processing to add the image file of the target process (which couldn't be\ncaptured in the syscall).\n\nThe event struct received from eBPF (provided to handle\\_event()) should be\ntreated as read-only. In order to add information to it, a new one should be\ncreated on the stack and the data copied in. (Stack is used as it is faster\nthan malloc() and avoids potential memory leaks.)\n\n### Much More Complex Example\n\nMore complex examples are the network events. These require multiple\ntracepoints and/or information arriving split over multiple reports, and hence\na correlation engine (networkTracker). Because the information sent from eBPF\ndoesn't match a Sysmon struct, a new pseudo-event struct, pseudo-event type,\nand pseudo-syscall were created. These are connected up in the config and\nSetActiveSyscalls() in sysmonforlinux.c.\n\nThe handle\\_event() function processes the pseudo-events by adding or\nretrieving information from the networkTracker correlation engine. When\nsufficient information has been gathered, an event is generated by calling\nCreateNetworkEvent() instead of DispatchEvent() as network events are handled\ndifferently in Sysmon.\n\n## So You Want To Implement An Entirely New Event?\n\nTo implement an entirely new event that doesn't already exist in the Windows\nversion would involve modifying the schema to document the new event. This\nprocess requires a planned enhancement where the schema will contain an\nadditional switch to indicate whether an event is for Windows, Linux, or both.\n\nThe process outlined for implementing an existing event can then be followed,\nmaking the assumption that a pseudo-event struct and pseudo-event type will\ncertainly be required as suitable ones will not already exist. In addition,\nextra code will be required in DispatchEvent() in order to handle it\nappropriately. This process will be documented in an updated version of this\nfile when the planned enhancement to the schema has been implemented.\n\n## Writing Good eBPF Programs\n\nAll new eBPF programs should follow the format and approach found in the\nexisting ones - these are written in a consistent manner that meets the\nrequirements of the eBPF verifier. The following tips are offered to help write\neBPF programs.\n\n### Coding Tips\n\n* eBPF code is heavily optimised during compilation so write simpler, more\n    understandable code and let the compiler make it optimal.\n* Use the helpers in ebpfKern and in sysinternalsEBPF/ebpfKern. These have\n    been tested fairly well and are believed to work correctly.\n* If you need functions to make your code more readable, inline them all. (See\n    existing code for examples.)\n* Bound all loops with an upper bound. e.g. Use 'for' loops with simple exit\n    conditions (\"i < N\" where N is a compile-time static value). To accommodate\n    kernels <=5.2 were loops are not permitted, add the following construction\n    directly above each loop:\n```\n#ifdef NOLOOPS\n    #pragma unroll\n#endif\n```\n* Bound all array access with an upper bound. There are many ways to achieve\n    this, notably with 'if' statements preceding the access, but the simplest\n    and most reliable method is to make array sizes equal to a power of 2,\n    and then bound the index with \"& (SIZE - 1)\". e.g. \"x = a[i & (SIZE - 1)];\"\n    so that the index is always constrained between 0 and SIZE-1, even if the\n    index variable (i in this case) could take arbitrary values. Expanding an\n    array to a size that is a power of 2 wastes memory at the expense of easier\n    and more reliable compiled code (across clang verions and kernel versions).\n* For syscalls, store arguments on entry and retrieve them on exit, using a\n    hash based on PID/TID. Exit programs should be able to access userland\n    memory buffers referenced by arguments (as memory has been recently\n    accessed), but the same guarantee cannot be made for entry programs.\n* memset all structs you intend to store in maps to 0 before use to ensure that\n    every memory location in the struct (including any padding gaps) has been\n    initialised prior to attempting to store it.\n* eBPF maps can be accessed from userland - move all heavy data structure\n    management to userland, especially where it requires loops.\n\n### Debugging Tips\n\n* If programs fail to load due to a verifier error, it can be helpful to\n    compare the assembler of the eBPF object against the C source. Dump the\n    assembler using:\n```\n% llvm-objdump -source <EBPF OBJECT>\n```\n* eBPF helpers are called by number in eBPF assember - \"call #4\" would be the\n    assembler for \"bpf_probe_read()\" in C. Find bpf helper call numbers in\n    bpf_helper_defs.h. It's possible to make a reference list with:\n```\ncat bpf_helper_defs.h | grep -e '^static' | sed -e 's/^[^(]*(\\*\\([^)]*\\)).*)\\([^();]*\\);$/\\2 \\1/'\n```\n* Match eBPF assembler to C source by aligning on bpf helper calls (\"call #n\")\n    and constant values, e.g. PATH_MAX or an array size.\n* eBPF verfifier errors can be difficult to understand but most errors have\n    already been posted to online forums and the answers or help may provide\n    good clues.\n\n### Inline Assembler\n\nIf clang optimises away the array bound \"& (SIZE - 1)\" or some other code\nrequired to satisfy the veriifer, or innocently stores the bounded value on\nthe stack and then 'forgets' it was bounded after retrieval, then it may be\npossible to replace the C code with inline assembler, swapping C statements\n1-for-1 with assembler statements.\n\nFirst break the C statement into a series of very simple C statements, e.g.\n```\nx = a[i & (SIZE - 1)]\n```\ncould become:\n```\nuint32_t index = i;\nindex &= (SIZE - 1);\nx = a[index];\n```\nNext, replace the bounding statement with inline assembler so:\n```\nindex &= (SIZE - 1);\n```\nbecomes:\n```\nasm volatile(\"%[index] &= \" XSTR(SIZE - 1) \"\\n\"\n    :[index]\"+&r\"(index)\n    );\n```\nThe 'volatile' keyword prevents the compiler from optimising the assembler\ninstructions to a different location. The XSTR macro permits the use of\ndefined values and expressions in asm statements - it is defined in\nsysinternalsEBPF\\_helpers.c.\n\n"
        },
        {
          "name": "INSTALL.md",
          "type": "blob",
          "size": 2.6962890625,
          "content": "# Install Sysmon\nPlease see the history of this file for instructions for older, unsupported versions.\n\n## Ubuntu 20.04, 22.04, 23.04\n#### 1. Register Microsoft key and feed\n```sh\nwget -q https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb -O packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\n```\n\n#### 2. Install SysmonForLinux\n```sh\nsudo apt-get update\nsudo apt-get install sysmonforlinux\n```\n\n## Debian 11\n#### 1. Register Microsoft key and feed\n```sh\nwget -q https://packages.microsoft.com/config/debian/11/packages-microsoft-prod.deb -O packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\n```\n\n#### 2. Install SysmonForLinux\n```sh\nsudo apt-get update\nsudo apt-get install apt-transport-https\nsudo apt-get update\nsudo apt-get install sysmonforlinux\n```\n\n## Debian 12\n#### 1. Register Microsoft key and feed\n```sh\nwget -q https://packages.microsoft.com/config/debian/12/packages-microsoft-prod.deb -O packages-microsoft-prod.deb\nsudo dpkg -i packages-microsoft-prod.deb\n```\n\n#### 2. Install SysmonForLinux\n```sh\nsudo apt-get update\nsudo apt-get install apt-transport-https\nsudo apt-get update\nsudo apt-get install sysmonforlinux\n```\n\n## Fedora 37\n#### 1. Register Microsoft key and feed\n```sh\nsudo rpm -Uvh https://packages.microsoft.com/config/fedora/37/packages-microsoft-prod.rpm\n```\n\n#### 2. Install SysmonForLinux\n```sh\nsudo dnf install sysmonforlinux\n```\n\n## Fedora 38\n#### 1. Register Microsoft key and feed\n```sh\nsudo rpm -Uvh https://packages.microsoft.com/config/fedora/38/packages-microsoft-prod.rpm\n```\n\n#### 2. Install SysmonForLinux\n```sh\nsudo dnf install sysmonforlinux\n```\n\n## RHEL 8\n#### 1. Register Microsoft key and feed\n```sh\nsudo rpm -Uvh https://packages.microsoft.com/config/rhel/8/packages-microsoft-prod.rpm\n```\n\n#### 2. Install SysmonForLinux\n```sh\nsudo dnf install sysmonforlinux\n```\n\n## RHEL 9\n#### 1. Register Microsoft key and feed\n```sh\nsudo rpm -Uvh https://packages.microsoft.com/config/rhel/9/packages-microsoft-prod.rpm\n```\n\n#### 2. Install SysmonForLinux\n```sh\nsudo dnf install sysmonforlinux\n```\n\n## openSUSE 15\n#### 1. Register Microsoft key and feed\n```sh\nsudo zypper install libicu\nsudo rpm --import https://packages.microsoft.com/keys/microsoft.asc\nwget -q https://packages.microsoft.com/config/opensuse/15/prod.repo\nsudo mv prod.repo /etc/zypp/repos.d/microsoft-prod.repo\nsudo chown root:root /etc/zypp/repos.d/microsoft-prod.repo\n```\n\n#### 2. Install SysmonForLinux\n```sh\nsudo zypper install sysmonforlinux\n```\n\n## SLES 15\n#### 1. Register Microsoft key and feed\n```sh\nsudo rpm -Uvh https://packages.microsoft.com/config/sles/15/packages-microsoft-prod.rpm\n```\n\n#### 2. Install SysmonForLinux\n```sh\nsudo zypper install sysmonforlinux\n```\n\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0478515625,
          "content": "Copyright (c) Microsoft Corporation.\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.15625,
          "content": "[![Build Status](https://dev.azure.com/sysinternals/Tools/_apis/build/status/Sysinternals.SysmonForLinux?repoName=Sysinternals%2FSysmonForLinux&branchName=main)](https://dev.azure.com/sysinternals/Tools/_build/latest?definitionId=340&repoName=Sysinternals%2FSysmonForLinux&branchName=main)\n\n# Sysmon for Linux\nSysmon for Linux is a tool that monitors and logs system activity including process lifetime, network connections, file system writes, and more. Sysmon works across reboots and uses advanced filtering to help identify malicious activity as well as how intruders and malware operate on your network.\nSysmon for Linux is part of [Sysinternals](https://sysinternals.com).\n\n![Sysmon in use](sysmon.gif \"Sysmon in use\")\n\n## Installation\nThe packages are available in the official Microsoft Linux repositories and instructions on how to install the packages for the different Linux distributions can be found in the [Installation instructions](INSTALL.md).\n\nThis project contains the code for build and installing [Sysmon](https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon) on Linux.\n\n## Build\nPlease see build instructions [here](BUILD.md).\n\n## Autodiscovery of Offsets\nOn systems that are BTF enabled, Sysmon will use BTF for accurate kernel offsets.\nSysmon also supports specifying standalone BTF files (using /BTF switch). There are\nseveral ways to generate BTF files and [BTFHub](https://github.com/aquasecurity/btfhub)\nhas a number of standalone BTF files for different distributions/kernels.\n\nIf BTF isn't available, Sysmon attempts to automatically discover the offsets of some\nmembers of some kernel structs. If this fails, please provide details of the kernel\nversion (and config if possible) plus the error message to the GitHub issues page.\n\nYou can then generate a configuration file to override the autodiscovery by\nbuilding the getOffsets module in the /opt/sysinternals/getOffsets directory.\nSee the README.md in that directory for more information.\n\n## Manual Page\nA man page for Sysmon can be found in the package directory, and is installed\nby both deb and rpm packages.\n\nUse 'find' on the package directory to locate it manually.\n\n## Output\n```\nsudo tail -f /var/log/syslog\n```\nor more human-readable\n```\nsudo tail -f /var/log/syslog | sudo /opt/sysmon/sysmonLogView\n```\n\nSysmonLogView has options to filter the output to make it easy to identify\nspecific events or reduce outputted fields for brevity.\n\nSysmonLogView is built when Sysmon is built and is installed into /opt/sysmon\nwhen sysmon is installed.\n\n*Important*: You may wish to modify your Syslogger config to ensure it can\nhandle particularly large events (e.g. >64KB, as defaults are often between 1KB\nand 8KB), and/or use the FieldSizes configuration entry to limit the length of\noutput for some fields, such as CommandLine, Image, CurrentDirectory, etc.\n\nExample:\n\nAdd \\<FieldSizes\\>CommandLine:100,Image:20\\</FieldSizes\\> under\n\\<Sysmon\\> in your configuration file.\n\n## Developer Details\nSee DEVELOP.md\n\n## License\nSysmon For Linux is licensed under MIT, with the eBPF programs licensed under\nGPL2.  SysinternalsEBPF (on which Sysmon For Linux depends) is licensed under\nLGPL2.1, with the eBPF code library licensed under GPL2.\n\n"
        },
        {
          "name": "azure-pipelines.yml",
          "type": "blob",
          "size": 1.3994140625,
          "content": "# Azure build pipelines for Sysmon\n\nresources:\n  repositories:\n  - repository: Sysmon\n    type: github\n    endpoint: sysinternals\n    name: Microsoft/SysmonforLinux\n\n  - repository: SysinternalsEBPF\n    type: github\n    endpoint: sysinternals\n    name: Microsoft/SysinternalsEBPF\n\ntrigger:\n    branches:\n      include:\n        - release/*\n        - main\n      exclude:\n        - dev/*\n        - test/*\n\npr:\n- main\n\nstages:\n - stage: \"Build\"\n   jobs:\n    - job: \"Build_Sysmon_Ubuntu\"\n      pool:\n        vmImage: \"ubuntu-20.04\"\n      timeoutInMinutes: 240\n      steps:\n      - checkout: self\n        submodules: true\n\n      - checkout: SysinternalsEBPF\n\n      - script: |\n          chmod +x SysmonForLinux/.container/install-ubuntu-dependencies.sh\n          SysmonForLinux/.container/install-ubuntu-dependencies.sh\n        displayName: \"Install pre-reqs for Ubuntu\"\n\n      - template: templates/build.yaml@SysinternalsEBPF\n        parameters:\n          srcPath: 'SysinternalsEBPF'\n          runStaticAnalysis: false\n          builddir: 'sysinternalsEBPF_build'\n\n      - script: |\n          cd $(Build.SourcesDirectory)/SysinternalsEBPF/sysinternalsEBPF_build\n          sudo make install\n          sudo ldconfig\n        displayName: \"Install SysinternalsEBPF\"\n\n      - template: templates/build.yaml\n        parameters:\n          srcPath: 'SysmonForLinux'\n          runStaticAnalysis: true\n          builddir: 'sysinternalsEBPF_build'\n"
        },
        {
          "name": "checkEBPFsizes",
          "type": "tree",
          "content": null
        },
        {
          "name": "diag_script.sh",
          "type": "blob",
          "size": 0.4306640625,
          "content": "#!/bin/bash\nprocess_name=\"t4\"\n\n# Wait enough time for it to get into hung state\nsleep 20m\ncounter=1\nwhile [ $counter -le 20 ]\ndo\n    if pgrep -x \"$process_name\" > /dev/null; then\n        echo \"Process $process_name is running. Dumping stacks...\"\n        process_id=$(pgrep -x \"$process_name\")\n        $HOME/.dotnet/tools/dotnet-stack report -p \"$process_id\"\n        echo \"Stacks dumped\"\n    fi\n\n    sleep 1m\n    counter=$((counter + 1))\ndone"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "ebpfKern",
          "type": "tree",
          "content": null
        },
        {
          "name": "extractMsgMc.sh",
          "type": "blob",
          "size": 2.59765625,
          "content": "#!/bin/bash\n#\n#    SysmonForLinux\n#\n#    Copyright (c) Microsoft Corporation\n#\n#    All rights reserved.\n#\n#    MIT License\n#\n#    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n#\n#    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n#\n#    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n\n#################################################################################\n#\n# extractMsgMc.sh\n#\n# Extracts defines from sysmonmsg.mc\n#\n#################################################################################\n\n\nSYSMONMSG=sysmonmsg.mc\n\necho \"// Copyright (c) 2021 Microsoft Corporation\"\n\nLINE1=`grep -n SeverityNames $SYSMONMSG | cut -d: -f1`\nLINE2=`tail -n +$LINE1 $SYSMONMSG | grep -n ')' | head -n 1 | cut -d: -f1`\ntail -n +$LINE1 $SYSMONMSG | head -n $LINE2 | grep : | sed -e 's/)//' | sed -e 's/^.*=0x\\([^:]*\\):\\(.*\\)$/#define \\2 0x\\1/'\n\nLINE1=`grep -n FacilityNames $SYSMONMSG | cut -d: -f1`\nLINE2=`tail -n +$LINE1 $SYSMONMSG | grep -n ')' | head -n 1 | cut -d: -f1`\ntail -n +$LINE1 $SYSMONMSG | head -n $LINE2 | grep : | sed -e 's/)//' | sed -e 's/^.*=0x\\([^:]*\\):\\(.*\\)$/#define \\2 0x\\1/'\n\ngrep '^MessageId=0x.* Facility=Serial Severity=Error' $SYSMONMSG | sed -e 's/^MessageId=\\(0x[^ ]*\\).*SymbolicName=\\(.*\\)$/#define \\2 ((NTSTATUS)(0xC0060000L + \\1))/'\ngrep '^MessageId=0x.* Facility=Serial Severity=Warning' $SYSMONMSG | sed -e 's/^MessageId=\\(0x[^ ]*\\).*SymbolicName=\\(.*\\)$/#define \\2 ((NTSTATUS)(0x80060000L + \\1))/'\ngrep '^MessageId=0x.* Facility=Serial Severity=Informational' $SYSMONMSG | sed -e 's/^MessageId=\\(0x[^ ]*\\).*SymbolicName=\\(.*\\)$/#define \\2 ((NTSTATUS)(0x40060000L + \\1))/'\ngrep '^MessageId=0x.* Facility=Serial Severity=Success' $SYSMONMSG | sed -e 's/^MessageId=\\(0x[^ ]*\\).*SymbolicName=\\(.*\\)$/#define \\2 ((NTSTATUS)(0x00060000L + \\1))/'\n"
        },
        {
          "name": "extractMsgOp.sh",
          "type": "blob",
          "size": 3.7744140625,
          "content": "#!/bin/bash\n#\n#    SysmonForLinux\n#\n#    Copyright (c) Microsoft Corporation\n#\n#    All rights reserved.\n#\n#    MIT License\n#\n#    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n#\n#    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n#\n#    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n\n#################################################################################\n#\n# extractMsgOp.sh\n#\n# Extracts defines from sysmonmsgop.man\n#\n#################################################################################\n\nSYSMONMSGOP=sysmonmsgop.man\nif [[ \"$1\" == \"HEADER\" ]]; then\n    # H file\n    echo \"// Copyright (c) 2021 Microsoft Corporation.\"\n    echo \"\"\n    echo \"#pragma once\"\n    echo \"\"\n    echo \"extern const GUID SYSMON_PROVIDER;\"\n    echo \"#define SYSMON_CHANNEL 0x10\"\n    echo \"\"\n    grep '<task name' $SYSMONMSGOP | sed -e 's/^.*symbol=\"\\([^\"]*\\)\".*\\(..\\)}\".*$/#define \\1 0x\\2/'\n    echo \"\"\n    grep '<event symbol=' $SYSMONMSGOP | grep \"win:Error\" | sed -e 's/^.*symbol=\"\\([^\"]*\\)\".*value=\"\\([^\"]*\\).*version=\"\\([^\"]*\\)\".*$/extern const EVENT_DESCRIPTOR \\1;/'\n    grep '<event symbol=' $SYSMONMSGOP | grep \"win:Informational\" | sed -e 's/^.*symbol=\"\\([^\"]*\\)\".*value=\"\\([^\"]*\\).*version=\"\\([^\"]*\\)\".*$/extern const EVENT_DESCRIPTOR \\1;/'\n    echo \"\"\n    grep '<event symbol=' $SYSMONMSGOP | grep \"win:Error\" | sed -e 's/^.*symbol=\"\\([^\"]*\\)\".*value=\"\\([^\"]*\\).*version=\"\\([^\"]*\\)\".*$/#define \\1_value \\2/'\n    grep '<event symbol=' $SYSMONMSGOP | grep \"win:Informational\" | sed -e 's/^.*symbol=\"\\([^\"]*\\)\".*value=\"\\([^\"]*\\).*version=\"\\([^\"]*\\)\".*$/#define \\1_value \\2/'\n    X=`grep '<task name' $SYSMONMSGOP | wc -l`\n    echo \"#define EVENT_COUNT \" $X\n    # find next power of 2 for number of events\n    X=$((X - 1))\n    X=$((X | (X>>1)))\n    X=$((X | (X>>2)))\n    X=$((X | (X>>4)))\n    X=$((X | (X>>8)))\n    X=$((X | (X>>16)))\n    echo \"// EVENT_COUNT_P2 is always the power of 2 equal or greater\"\n    echo \"// than the actual number of events, for easy eBPF maths\"\n    echo \"#define EVENT_COUNT_P2 \" $((X + 1))\n\nelse\n    # C file\n    echo \"// Copyright (c) 2021 Microsoft Corporation.\"\n    echo \"\"\n    echo '#include \"stdafx.h\"'\n    echo \"\"\n    echo -n \"const GUID SYSMON_PROVIDER = \"\n    echo -n `grep 'SYSMON_PROVIDER' $SYSMONMSGOP | sed -e 's/^.*guid=\"{\\(.\\{8\\}\\)-\\(....\\)-\\(....\\)-\\(..\\)\\(..\\)-\\(..\\)\\(..\\)\\(..\\)\\(..\\).*$/{0x\\1, 0x\\2, 0x\\3, {0x\\4, 0x\\5, 0x\\6, 0x\\7, 0x\\8, 0x\\9, /'`\n    echo `grep 'SYSMON_PROVIDER' $SYSMONMSGOP | sed -e 's/^.*guid=\"{.\\{8\\}-....-....-....-.\\{8\\}\\(..\\)\\(..\\).*$/0x\\1, 0x\\2}};/'`\n    echo \"\"\n    grep '<event symbol=' $SYSMONMSGOP | grep \"win:Error\" | sed -e 's/^.*symbol=\"\\([^\"]*\\)\".*value=\"\\([^\"]*\\).*version=\"\\([^\"]*\\)\".*$/const EVENT_DESCRIPTOR \\1 = {\\2, \\3, 0x10, 0x2, 0x0, \\2, 0x8000000000000000};/'\n    grep '<event symbol=' $SYSMONMSGOP | grep \"win:Informational\" | sed -e 's/^.*symbol=\"\\([^\"]*\\)\".*value=\"\\([^\"]*\\).*version=\"\\([^\"]*\\)\".*$/const EVENT_DESCRIPTOR \\1 = {\\2, \\3, 0x10, 0x4, 0x0, \\2, 0x8000000000000000};/'\nfi\n\n"
        },
        {
          "name": "hexdump.c",
          "type": "blob",
          "size": 2.3486328125,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// hexdump.c\n//\n// Outputs binary data as hex for debugging\n//\n//====================================================================\n\n#include <sys/types.h>\n#include <stdio.h>\n#include <ctype.h>\n\n//--------------------------------------------------------------------\n//\n// hexdump\n//\n// Dump n bytes of the provided buffer as hex unsigned chars to stdout\n//\n//--------------------------------------------------------------------\nvoid hexdump(const unsigned char *x, size_t n)\n{\n    if (x == NULL) {\n        fprintf(stderr, \"hexdump invalid params\\n\");\n        return;\n    }\n\n    printf(\"\\n\");\n    for (size_t i=0; i<n; i++) {\n        if (i % 16 == 0) {\n            printf(\"%08lx  \", i);\n        }\n        printf(\"0x%02x \", x[i]);\n        if (i % 16 == 7) {\n            printf(\" \");\n        }\n        if (i % 16 == 15) {\n            for (size_t j=i-15; j<=i; j++) {\n                if (isprint(x[j])) {\n                    printf(\"%c\", x[j]);\n                } else {\n                    printf(\".\");\n                }\n                if (j % 16 == 7) {\n                    printf(\" \");\n                }\n            }\n            printf(\"\\n\");\n        }\n    }\n    printf(\"\\n\");\n}\n\n\n"
        },
        {
          "name": "hexdump.h",
          "type": "blob",
          "size": 1.3876953125,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// hexdump.h\n//\n// Outputs binary data as hex for debugging\n//\n//====================================================================\n\n#include <sys/types.h>\n\nvoid hexdump(const char *x, size_t n);\n\n"
        },
        {
          "name": "installer.c",
          "type": "blob",
          "size": 23.0498046875,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// installer.c\n//\n// Functions that install Sysmon For Linux\n//\n//====================================================================\n\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <stdbool.h>\n#include <sys/stat.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n#include <signal.h>\n#include <libsysinternalsEBPF.h>\n#include \"sysmonevents.h\"\n#include \"installer.h\"\n#include \"linuxHelpers.h\"\n#include \"sysmon_defs.h\"\n\nextern char _binary_sysmonLogView_start[];\nextern char _binary_sysmonLogView_end[];\nextern char _binary_sysmon_d_start[];\nextern char _binary_sysmon_d_end[];\nextern char _binary_sysmon_service_start[];\nextern char _binary_sysmon_service_end[];\nextern char _binary_sysmonEBPFkern4_15_o_start[];\nextern char _binary_sysmonEBPFkern4_15_o_end[];\nextern char _binary_sysmonEBPFkern4_16_o_start[];\nextern char _binary_sysmonEBPFkern4_16_o_end[];\nextern char _binary_sysmonEBPFkern4_17_5_1_o_start[];\nextern char _binary_sysmonEBPFkern4_17_5_1_o_end[];\nextern char _binary_sysmonEBPFkern5_2_o_start[];\nextern char _binary_sysmonEBPFkern5_2_o_end[];\nextern char _binary_sysmonEBPFkern5_3_5_5_o_start[];\nextern char _binary_sysmonEBPFkern5_3_5_5_o_end[];\nextern char _binary_sysmonEBPFkern5_6__o_start[];\nextern char _binary_sysmonEBPFkern5_6__o_end[];\nextern char _binary_sysmonEBPFkern4_15_core_o_start[];\nextern char _binary_sysmonEBPFkern4_15_core_o_end[];\nextern char _binary_sysmonEBPFkern4_16_core_o_start[];\nextern char _binary_sysmonEBPFkern4_16_core_o_end[];\nextern char _binary_sysmonEBPFkern4_17_5_1_core_o_start[];\nextern char _binary_sysmonEBPFkern4_17_5_1_core_o_end[];\nextern char _binary_sysmonEBPFkern5_2_core_o_start[];\nextern char _binary_sysmonEBPFkern5_2_core_o_end[];\nextern char _binary_sysmonEBPFkern5_3_5_5_core_o_start[];\nextern char _binary_sysmonEBPFkern5_3_5_5_core_o_end[];\nextern char _binary_sysmonEBPFkern5_6__core_o_start[];\nextern char _binary_sysmonEBPFkern5_6__core_o_end[];\n\nmode_t dirMode = S_IRWXU;\nmode_t fileMode = S_IRUSR | S_IWUSR;\nmode_t exeFileMode = S_IRWXU;\nmode_t systemdFileMode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;\nmode_t serviceFileMode = S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH;\n\n//--------------------------------------------------------------------\n//\n// installFiles\n//\n// Sysmon is linked with embedded versions of a number of key resource\n// files.  This function writes those files to the approprate places.\n// The purpose is to make Sysmon a standalone installer so that it can\n// be copied to another host and installed there with minimal extra\n// dependencies.\n//\n// Also installs a systemd or initd start up scripts and sets it to\n// start up by default.\n//\n// Returns true on success, otherwise false.\n//\n//--------------------------------------------------------------------\nbool installFiles(bool force)\n{\n    int fd;\n    void *addr = NULL;\n    struct stat st;\n    const char exePath[] = PROC_EXE_PATH;\n\n    umask(0022);\n\n    if (!createDir(SYSMON_INSTALL_DIR, dirMode)) {\n        fprintf(stderr, \"Cannot create sysmon directory. Make sure you are root or sudo.\\n\");\n        return false;\n    }\n\n    fd = open(exePath, O_RDONLY);\n    if (fd < 0)\n        return false;\n\n    if (fstat(fd, &st) < 0) {\n        close(fd);\n        return false;\n    }\n\n    addr = mmap(NULL, st.st_size, PROT_READ, MAP_SHARED, fd, 0);\n    if (addr == MAP_FAILED) {\n        close(fd);\n        return false;\n    }\n\n    if (!dropFile(SYSMON_INSTALL_DIR \"/\" SYSMON_BINARY,\n        addr,\n        addr + st.st_size,\n        force,\n        exeFileMode)) {\n        munmap(addr, st.st_size);\n        close(fd);\n        return false;\n    }\n\n    munmap(addr, st.st_size);\n    close(fd);\n\n    if (!dropFile(SYSMON_INSTALL_DIR \"/\" KERN_4_15_OBJ,\n        _binary_sysmonEBPFkern4_15_o_start,\n        _binary_sysmonEBPFkern4_15_o_end,\n        force,\n        fileMode))\n        return false;\n\n    if (!dropFile(SYSMON_INSTALL_DIR \"/\" KERN_4_16_OBJ,\n        _binary_sysmonEBPFkern4_16_o_start,\n        _binary_sysmonEBPFkern4_16_o_end,\n        force,\n        fileMode))\n        return false;\n\n    if (!dropFile(SYSMON_INSTALL_DIR \"/\" KERN_4_17_5_1_OBJ,\n        _binary_sysmonEBPFkern4_17_5_1_o_start,\n        _binary_sysmonEBPFkern4_17_5_1_o_end,\n        force,\n        fileMode))\n        return false;\n\n    if (!dropFile(SYSMON_INSTALL_DIR \"/\" KERN_5_2_OBJ,\n        _binary_sysmonEBPFkern5_2_o_start,\n        _binary_sysmonEBPFkern5_2_o_end,\n        force,\n        fileMode))\n        return false;\n\n    if (!dropFile(SYSMON_INSTALL_DIR \"/\" KERN_5_3_5_5_OBJ,\n        _binary_sysmonEBPFkern5_3_5_5_o_start,\n        _binary_sysmonEBPFkern5_3_5_5_o_end,\n        force,\n        fileMode))\n        return false;\n\n    if (!dropFile(SYSMON_INSTALL_DIR \"/\" KERN_5_6__OBJ,\n        _binary_sysmonEBPFkern5_6__o_start,\n        _binary_sysmonEBPFkern5_6__o_end,\n        force,\n        fileMode))\n        return false;\n\n    if (!dropFile(SYSMON_INSTALL_DIR \"/\" KERN_4_15_CORE_OBJ,\n        _binary_sysmonEBPFkern4_15_core_o_start,\n        _binary_sysmonEBPFkern4_15_core_o_end,\n        force,\n        fileMode))\n        return false;\n\n    if (!dropFile(SYSMON_INSTALL_DIR \"/\" KERN_4_16_CORE_OBJ,\n        _binary_sysmonEBPFkern4_16_core_o_start,\n        _binary_sysmonEBPFkern4_16_core_o_end,\n        force,\n        fileMode))\n        return false;\n\n    if (!dropFile(SYSMON_INSTALL_DIR \"/\" KERN_4_17_5_1_CORE_OBJ,\n        _binary_sysmonEBPFkern4_17_5_1_core_o_start,\n        _binary_sysmonEBPFkern4_17_5_1_core_o_end,\n        force,\n        fileMode))\n        return false;\n\n    if (!dropFile(SYSMON_INSTALL_DIR \"/\" KERN_5_2_CORE_OBJ,\n        _binary_sysmonEBPFkern5_2_core_o_start,\n        _binary_sysmonEBPFkern5_2_core_o_end,\n        force,\n        fileMode))\n        return false;\n\n    if (!dropFile(SYSMON_INSTALL_DIR \"/\" KERN_5_3_5_5_CORE_OBJ,\n        _binary_sysmonEBPFkern5_3_5_5_core_o_start,\n        _binary_sysmonEBPFkern5_3_5_5_core_o_end,\n        force,\n        fileMode))\n        return false;\n\n    if (!dropFile(SYSMON_INSTALL_DIR \"/\" KERN_5_6__CORE_OBJ,\n        _binary_sysmonEBPFkern5_6__core_o_start,\n        _binary_sysmonEBPFkern5_6__core_o_end,\n        force,\n        fileMode))\n        return false;\n\n    if (!dropFile(SYSMON_INSTALL_DIR \"/\" SYSMONLOGVIEW_BINARY,\n        _binary_sysmonLogView_start,\n        _binary_sysmonLogView_end,\n        force,\n        exeFileMode))\n        return false;\n\n    if (dirExists(SYSTEMD_DIR)) {\n        //\n        // systemd managed system\n        //\n        if (!dropFile(SYSTEMD_DIR \"/\" SYSTEMD_SERVICE,\n            _binary_sysmon_service_start,\n            _binary_sysmon_service_end,\n            force,\n            systemdFileMode))\n            return false;\n        if(system(SYSTEMD_RELOAD_CMD) == -1) {\n\t        return false;\n\t    }\n        if(system(SYSTEMD_ENABLE_CMD \" \" SYSTEMD_SERVICE) == -1) {\n\t        return false;\n\t    }\n    } else if (dirExists(INITD_DIR)) {\n        //\n        // init.d / rc script managed system\n        //\n        if (!dropFile(INITD_DIR \"/\" INITD_SERVICE,\n            _binary_sysmon_d_start,\n            _binary_sysmon_d_end,\n            force,\n            serviceFileMode))\n        return false;\n\n        //\n        // create symbolic links for the different run states\n        // Sysmon not running in 0 (shutdown), 1-2 (single-user)\n        // and 6 (reboot); but will run in 3-4 (multi-user) and 5 (desktop),\n        // aligned with usual Linux conventions.\n        //\n        setRunState(0, false);\n        setRunState(1, false);\n        setRunState(2, false);\n        setRunState(3, true);\n        setRunState(4, true);\n        setRunState(5, true);\n        setRunState(6, false);\n    }\n    return true;\n}\n\n//--------------------------------------------------------------------\n//\n// uninstall\n//\n// Disables the systemd or initd service.\n//\n//--------------------------------------------------------------------\nvoid uninstall()\n{\n    if (dirExists(SYSTEMD_DIR)) {\n        if (system(SYSTEMD_DISABLE_CMD \" \" SYSTEMD_SERVICE) == -1) {\n            return;\n        }\n    } else if (dirExists(INITD_DIR)) {\n        setRunState(0, false);\n        setRunState(1, false);\n        setRunState(2, false);\n        setRunState(3, false);\n        setRunState(4, false);\n        setRunState(5, false);\n        setRunState(6, false);\n    }\n}\n\n//--------------------------------------------------------------------\n//\n// copyConfigFile\n//\n// Copies the supplied config file to the Sysmon install directory.\n//\n// Returns true on success, otherwise false.\n//\n//--------------------------------------------------------------------\nbool copyConfigFile(const char *configFile)\n{\n    if (configFile == NULL) {\n        fprintf(stderr, \"copyConfigFile invalid params\\n\");\n        return false;\n    }\n\n    int fd;\n    void *addr = NULL;\n    struct stat st;\n    bool ret = true;\n    char realConfigPath[PATH_MAX];\n    char realTargetPath[PATH_MAX];\n\n    if (!fileExists(configFile))\n        return false;\n\n    if (realpath(configFile, realConfigPath) == NULL)\n        return false;\n\n    snprintf(realTargetPath, sizeof(realTargetPath), \"%s\", SYSMON_CONFIG_FILE);\n\n    if (strcmp(realConfigPath, realTargetPath) == 0)\n        return true;\n\n    fd = open(configFile, O_RDONLY);\n    if (fd < 0)\n        return false;\n\n    if (fstat(fd, &st) < 0) {\n        close(fd);\n        return false;\n    }\n\n    addr = mmap(NULL, st.st_size, PROT_READ, MAP_SHARED, fd, 0);\n    if (addr == MAP_FAILED) {\n        close(fd);\n        return false;\n    }\n\n    if (!dropFile(realTargetPath,\n        addr,\n        addr + st.st_size,\n        true,\n        fileMode)) {\n        ret = false;\n    }\n\n    munmap(addr, st.st_size);\n    close(fd);\n    return ret;\n}\n\n//--------------------------------------------------------------------\n//\n// createEmptyConfigFile\n//\n// For situations where Sysmon was configured without a configuration\n// file, this function creates an empty one to represent that fact\n// (and because the systemd and initd start up scripts expect a config\n// file).\n//\n// Returns true on success, otherwise false.\n//\n//--------------------------------------------------------------------\nbool createEmptyConfigFile()\n{\n    bool ret = false;\n    int fd = 0;\n    char empty[] = \"<Sysmon schemaversion=\\\"4.22\\\">\\n<EventFiltering>\\n</EventFiltering>\\n</Sysmon>\\n\";\n\n    fd = creat(SYSMON_CONFIG_FILE, fileMode);\n    if (fd < 0)\n        return false;\n\n    if (write(fd, empty, strlen(empty) + 1) != -1) {\n        ret = true;\n    }\n\n    close(fd);\n\n    return ret;\n}\n\n//--------------------------------------------------------------------\n//\n// writeArgv\n//\n// Writes the argc and argv of the commandline to files in the Sysmon\n// install directory for later use.\n//\n// Returns true on success, otherwise false.\n//\n//--------------------------------------------------------------------\nbool writeArgv(int argc, char *argv[])\n{\n    if (argv == NULL) {\n        fprintf(stderr, \"writeArgv invalid params\\n\");\n        return false;\n    }\n\n    int fd;\n\n    unlink(SYSMON_ARGC_FILE);\n    fd = creat(SYSMON_ARGC_FILE, fileMode);\n    if (fd < 0)\n        return false;\n\n    if (write(fd, &argc, sizeof(argc)) == -1) {\n        close(fd);\n        return false;\n    }\n\n    close(fd);\n\n    unlink(SYSMON_ARGV_FILE);\n    fd = creat(SYSMON_ARGV_FILE, fileMode);\n    if (fd < 0)\n        return false;\n\n    for (int i=0; i<argc; i++) {\n        if (write(fd, argv[i], strlen(argv[i]) + 1) == -1) {\n            close(fd);\n            return false;\n        }\n    }\n    close(fd);\n\n    return true;\n}\n\n//--------------------------------------------------------------------\n//\n// readArgv\n//\n// Reads the stored argc and argv.  Switches the config file in the\n// command line (if it exists) with the path to the one in the Sysmon\n// install directory, and returns the one in the command line as\n// configFile.\n//\n// Returns true on success, otherwise false.\n//\n//--------------------------------------------------------------------\nbool readArgv(int *argc, char ***argv, char **configFile)\n{\n    if (argc == NULL || argv == NULL || configFile == NULL) {\n        fprintf(stderr, \"readArgv invalid params\\n\");\n        return false;\n    }\n\n    int fd;\n    struct stat st;\n    char *data;\n    unsigned int ptrTableSize = 0;\n    char *specialConfigFile = NULL;\n    bool sawConfigFileSwitch = false;\n\n    *configFile = NULL;\n\n    fd = open(SYSMON_ARGC_FILE, O_RDONLY);\n    if (fd < 0)\n        return false;\n\n    if (read(fd, argc, sizeof(*argc)) == -1) {\n        close(fd);\n        return false;\n    }\n\n    close(fd);\n\n    ptrTableSize = sizeof(char *) * (*argc+1);\n\n    fd = open(SYSMON_ARGV_FILE, O_RDONLY);\n    if (fd < 0)\n        return false;\n\n    if (fstat(fd, &st) < 0) {\n        close(fd);\n        return false;\n    }\n\n    // allocate space for the string pointers followed by the strings, plus\n    // space for special config file\n    *argv = (char **)malloc(ptrTableSize + st.st_size + strlen(SYSMON_CONFIG_FILE) + 1);\n    if (*argv == NULL) {\n        close(fd);\n        return false;\n    }\n\n    data = (char *)(*argv) + ptrTableSize;\n\n    // read actual strings\n    if (read(fd, data, st.st_size) == -1) {\n        close(fd);\n        return false;\n    }\n\n    close(fd);\n\n    // write special config file to end\n    specialConfigFile = data + st.st_size;\n    strcpy(specialConfigFile, SYSMON_CONFIG_FILE);\n\n    // make pointers\n    for (int i=0; i<*argc; i++) {\n        // if previous arg was '-i' or '-c' and this arg doesn't start with '-'\n        // then point to the special config file instead and return the actual\n        // config file in configFile\n        if (sawConfigFileSwitch && data[0] != '-') {\n            (*argv)[i] = specialConfigFile;\n            *configFile = data;\n        } else {\n            (*argv)[i] = data;\n        }\n        data += strlen(data) + 1;\n\n        if (strcasecmp((*argv)[i], \"-i\") == 0 || strcasecmp((*argv)[i], \"-c\") == 0) {\n            sawConfigFileSwitch = true;\n        } else {\n            sawConfigFileSwitch = false;\n        }\n    }\n    // add the null pointer to the end\n    (*argv)[*argc] = NULL;\n\n    return true;\n}\n\n//--------------------------------------------------------------------\n//\n// GetCommandLine\n//\n// Obtains the command line from the files in the Sysmon install dir\n// and returns a pointer to a newly malloced buffer containing it.\n//\n// Returns a new pointer on success, otherwise NULL.\n//\n//--------------------------------------------------------------------\nchar *GetCommandLine()\n{\n    static char *cmdline = NULL;\n    int argc = 0;\n    char **argv = NULL;\n    char *configFile = NULL;\n    unsigned int i;\n    unsigned int totalSize = 0;\n    char *ptr = NULL;\n\n    if (!readArgv(&argc, &argv, &configFile)) {\n        return cmdline;\n    }\n\n    if (argc <= 0) {\n        free(argv);\n        return cmdline;\n    }\n\n    for (i=0; i<argc; i++) {\n        totalSize += strlen(argv[i]) + 1;\n    }\n\n    if (totalSize == 0) {\n        free(argv);\n        return cmdline;\n    }\n\n    if (cmdline != NULL) {\n        free(cmdline);\n    }\n\n    cmdline = (char *)malloc(totalSize);\n    if (cmdline == NULL) {\n        free(argv);\n        return NULL;\n    }\n\n    ptr = cmdline;\n    for (i=0; i<argc; i++) {\n        strcpy(ptr, argv[i]);\n        ptr += strlen(argv[i]);\n        *ptr = ' ';\n        ptr++;\n    }\n\n    // change last space to a null\n    ptr--;\n    *ptr = 0x00;\n\n    free(argv);\n\n    return cmdline;\n}\n\n//--------------------------------------------------------------------\n//\n// writeFieldSizes\n//\n// Writes the FieldSizes argument in the configuration file to a file\n// in the Sysmon install directory for later use.\n//\n// Returns true on success, otherwise false.\n//\n//--------------------------------------------------------------------\nbool writeFieldSizes(char *fieldSizesStr)\n{\n    bool ret = false;\n    unlink(SYSMON_FIELDSIZES_FILE);\n\n    if (fieldSizesStr == NULL) {\n        // if string is NULL, just erase the file\n        return true;\n    }\n\n    int fd;\n\n    fd = creat(SYSMON_FIELDSIZES_FILE, fileMode);\n    if (fd < 0)\n        return false;\n\n    if (write(fd, fieldSizesStr, strlen(fieldSizesStr) + 1) != -1) {\n        ret = true;\n    }\n\n    close(fd);\n\n    return ret;\n}\n\n//--------------------------------------------------------------------\n//\n// readFieldSizes\n//\n// Reads the stored FieldSizes argument.\n//\n// Returns allocated buffer containing FieldSizes on success, NULL\n// otherwise.\n//\n//--------------------------------------------------------------------\nchar *readFieldSizes()\n{\n    int fd;\n    struct stat st;\n    char *data;\n\n    fd = open(SYSMON_FIELDSIZES_FILE, O_RDONLY);\n    if (fd < 0)\n        return NULL;\n\n    if (fstat(fd, &st) < 0) {\n        close(fd);\n        return NULL;\n    }\n\n    // allocate space for the string\n    data = (char *)malloc(st.st_size);\n    if (data == NULL) {\n        close(fd);\n        return NULL;\n    }\n\n    if (read(fd, data, st.st_size) == -1) {\n        close(fd);\n        free(data);\n        return NULL;\n    }\n\n    close(fd);\n\n    return data;\n}\n\n//--------------------------------------------------------------------\n//\n// setRunState\n//\n// Sets the initd runState (0-6) to running/not-running according to\n// the running bool.\n//\n// Returns true on success, otherwise false.\n//\n//--------------------------------------------------------------------\nbool setRunState(unsigned int runState, bool running)\n{\n    char startLink[PATH_MAX];\n    char killLink[PATH_MAX];\n\n    if (runState > 6)\n        return false;\n\n    snprintf(startLink, sizeof(startLink), INITD_DIR_FMT \"/\" INITD_START_ID INITD_SERVICE, runState);\n    snprintf(killLink, sizeof(killLink), INITD_DIR_FMT \"/\" INITD_KILL_ID INITD_SERVICE, runState);\n    if (running) {\n        unlink(killLink);\n        if (symlink(INITD_DIR \"/\" INITD_SERVICE, startLink) < 0) {\n            return false;\n        }\n    } else {\n        unlink(startLink);\n        if (symlink(INITD_DIR \"/\" INITD_SERVICE, killLink) < 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//--------------------------------------------------------------------\n//\n// stopSysmonService\n//\n// Stops the systemd or initd Sysmon service.\n//\n// Returns true on success, otherwise false.\n//\n//--------------------------------------------------------------------\nbool stopSysmonService()\n{\n    if (fileExists(SYSTEMD_DIR \"/\" SYSTEMD_SERVICE)) {\n        if (system(SYSTEMD_STOP_CMD \" \" SYSTEMD_SERVICE) == -1) {\n            return false;\n        }\n\n        return true;\n    } else if (fileExists(INITD_DIR \"/\" INITD_SERVICE)) {\n        if (system(INITD_DIR \"/\" INITD_SERVICE \" stop\") == -1) {\n            return false;\n        }\n\n        return true;\n    }\n    return false;\n}\n\n//--------------------------------------------------------------------\n//\n// startSysmonService\n//\n// Starts the systemd or initd Sysmon service.  If the running Sysmon\n// was already started as a service, it does nothing and returns true.\n//\n// Returns true on success, otherwise false.\n//\n//--------------------------------------------------------------------\nbool startSysmonService()\n{\n    if (OPT_SET(Service))\n        return true;\n\n    if (fileExists(SYSTEMD_DIR \"/\" SYSTEMD_SERVICE)) {\n        execl(\"/bin/sh\", \"sh\", \"-c\", SYSTEMD_START_CMD \" \" SYSTEMD_SERVICE, NULL);\n    } else if (fileExists(INITD_DIR \"/\" INITD_SERVICE)) {\n        execl(\"/bin/sh\", \"sh\", \"-c\", INITD_DIR \"/\" INITD_SERVICE \" start\", NULL);\n    }\n    return false;\n}\n\n//--------------------------------------------------------------------\n//\n// sysmonSearch\n//\n// Searches for other Sysmon processes and optionally kills them if\n// the supplied signal is >=0.\n//\n// For signal < 0 (e.g. search), returns true if Sysmon is found\n// running.\n// For signal >= 0 (e.g. kill), returns true if at least one Sysmon\n// was found running and was sent the signal.\n//\n//--------------------------------------------------------------------\nbool sysmonSearch(int signal)\n{\n    pid_t                       pid = getpid();\n    char                        exe[PATH_MAX];\n    char                        path[2 * PATH_MAX]; // artifically long to\n                                                    // handle edge-cases\n    const char                  *name;\n    DIR                         *d;\n    struct dirent               *dir;\n    int                         path_len;\n    bool                        killed = false;\n\n    d = opendir(\"/proc\");\n    if (d) {\n        while ((dir = readdir(d)) != NULL) {\n            if (!StrIsNum(dir->d_name) || pid == atoi(dir->d_name))\n                continue;\n            snprintf(exe, PATH_MAX, PROC_EXE_PATH_FMT, atoi(dir->d_name));\n            path_len = readlink(exe, path, PATH_MAX);\n            if (path_len <= 0)\n                continue;\n            path[path_len] = 0x00;\n            name = strrchr(path, '/');\n            if (name == NULL)\n                continue;\n            if (strcmp(name+1, SYSMON_BINARY) != 0 && strcmp(name+1, SYSMON_BINARY \" (deleted)\") != 0)\n                continue;\n            if (signal >= 0) {\n                kill(atoi(dir->d_name), signal);\n                killed = true;\n            } else {\n                return true;\n            }\n        }\n        closedir(d);\n    }\n\n    if (signal >= 0 && killed)\n        return true;\n\n    return false;\n}\n\n//--------------------------------------------------------------------\n//\n// killOtherSysmon\n//\n// Sends a SIGTERM to all other Sysmon processes.  If force is true,\n// also sends SIGKILL to any remaining Sysmon processes.\n//\n//--------------------------------------------------------------------\nvoid killOtherSysmon(bool force)\n{\n    sysmonSearch(SIGTERM);\n    if (force) {\n        sysmonSearch(SIGKILL);\n    }\n}\n\n//--------------------------------------------------------------------\n//\n// sysmonIsRunning\n//\n// Checks if Sysmon is running and returns true if at least one is,\n// and false otherwise.\n//\n//--------------------------------------------------------------------\nbool sysmonIsRunning()\n{\n    return sysmonSearch(-1);\n}\n\n//--------------------------------------------------------------------\n//\n// signalConfigChange\n//\n// Sends a SIGHUP to the running Sysmon process to indicate that it\n// should read the new config stored in the install directory.\n//\n//--------------------------------------------------------------------\nvoid signalConfigChange()\n{\n    sysmonSearch(SIGHUP);\n}\n\n\n"
        },
        {
          "name": "installer.h",
          "type": "blob",
          "size": 1.8955078125,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// installer.h\n//\n// Functions that install Sysmon For Linux\n//\n//====================================================================\n\n#include <stdbool.h>\n\nbool installFiles(bool force);\nbool copyConfigFile(const char *configFile);\nbool createEmptyConfigFile();\nbool writeArgv(int argc, char *argv[]);\nbool readArgv(int *argc, char ***argv, char **configFile);\nchar *GetCommandLine();\nbool writeFieldSizes(char *fieldSizesStr);\nchar *readFieldSizes();\nbool setRunState(unsigned int runState, bool running);\nbool stopSysmonService();\nbool startSysmonService();\nbool sysmonSearch(int signal);\nvoid killOtherSysmon(bool force);\nbool sysmonIsRunning();\nvoid signalConfigChange();\nbool displayConfig();\nvoid uninstall();\n\n"
        },
        {
          "name": "linuxHelpers.cpp",
          "type": "blob",
          "size": 27.5029296875,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// linuxHelpers.cpp\n//\n// Linux support functions for eventsCommon.cpp\n//\n//====================================================================\n#include \"stdafx.h\"\n#include \"rules.h\"\n#include \"eventsCommon.h\"\n#include <math.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <pwd.h>\n#include <utmp.h>\n#include <utmpx.h>\n#include <sys/stat.h>\n#include <pthread.h>\n#include <sys/syscall.h>\n#include <openssl/evp.h>\n\n//--------------------------------------------------------------------\n//\n// InitializeCriticalSection\n//\n// Initialise a mutex to be used to mark critical sections for\n// concurrent processing.\n//\n//--------------------------------------------------------------------\nvoid\nInitializeCriticalSection(\n    CRITICAL_SECTION *p\n    )\n{\n    if (p == NULL) {\n        fprintf(stderr, \"InitializeCriticalSection invalid params\\n\");\n        return;\n    }\n\n    pthread_mutexattr_t a;\n\n    if ( pthread_mutexattr_init( &a ) != 0 ) {\n        fprintf( stderr, \"Cannot init mutex attr\\n\" );\n        return;\n    }\n\n    if ( pthread_mutexattr_settype( &a, PTHREAD_MUTEX_RECURSIVE ) != 0 ) {\n        pthread_mutexattr_destroy( &a );\n        fprintf( stderr, \"Cannot set mutex attr type\\n\" );\n        return;\n    }\n\n    if ( pthread_mutex_init( p, &a ) != 0 ) {\n        fprintf( stderr, \"Cannot init mutex\\n\" );\n    }\n\n    pthread_mutexattr_destroy( &a );\n}\n\n//--------------------------------------------------------------------\n//\n// EnterCriticalSection\n//\n// Wait for and obtain a mutex before proceeding.\n//\n//--------------------------------------------------------------------\nvoid EnterCriticalSection( CRITICAL_SECTION *p ) {\n    if (p == NULL) {\n        fprintf(stderr, \"EnterCriticalSection invalid params\\n\");\n        return;\n    }\n\n    pthread_mutex_lock( p );\n}\n\n//--------------------------------------------------------------------\n//\n// TryEnterCriticalSection\n//\n// Tries to obtain a mutex and reports success/failure, but continues\n// regardless.\n//\n//--------------------------------------------------------------------\nbool TryEnterCriticalSection( CRITICAL_SECTION *p ) {\n    if (p == NULL) {\n        fprintf(stderr, \"TryEnterCriticalSection invalid params\\n\");\n        return false;\n    }\n\n    return pthread_mutex_trylock( p ) == 0;\n}\n\n//--------------------------------------------------------------------\n//\n// LeaveCriticalSection\n//\n// Releases the mutex.\n//\n//--------------------------------------------------------------------\nvoid LeaveCriticalSection( CRITICAL_SECTION *p ) {\n    if (p == NULL) {\n        fprintf(stderr, \"LeaveCriticalSection invalid params\\n\");\n        return;\n    }\n\n    pthread_mutex_unlock( p );\n}\n\n//--------------------------------------------------------------------\n//\n// DeleteCriticalSection\n//\n// Destroys the mutex.\n//\n//--------------------------------------------------------------------\nvoid DeleteCriticalSection( CRITICAL_SECTION *p ) {\n    if (p == NULL) {\n        fprintf(stderr, \"DeleteCriticalSection invalid params\\n\");\n        return;\n    }\n\n    // The user is responsible with preventing further access to the mutex\n    pthread_mutex_destroy( p );\n}\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern double  g_bootSecSinceEpoch;\nextern DWORD   machineId;\n\nint     g_clkTck = 100;\nsize_t  g_pwEntrySize = 0;\n\n//--------------------------------------------------------------------\n//\n// GetProcess\n//\n// Get details of a process from /proc.\n//\n// Returns true on success, otherwise false.\n//\n//--------------------------------------------------------------------\nBOOLEAN GetProcess(\n    PSYSMON_EVENT_HEADER Process,\n    size_t Len,\n    ULONG ProcessId\n    )\n{\n    PSYSMON_PROCESS_CREATE pc = NULL;\n    FILE *fp = NULL;\n    char pathFile[32];\n    ssize_t numRead = 0;\n    char imagePath[PATH_MAX];\n    char cwd[PATH_MAX];\n    char cmdline[128 * 1024];\n    size_t dataSize = 0;\n    unsigned int imagePathLen = 0;\n    unsigned int cwdLen = 0;\n    unsigned int cmdlineLen = 0;\n    PCHAR ptr = NULL;\n    unsigned int uid = 0;\n    unsigned int pts = 0;\n    struct stat st;\n\n    if (Process == NULL) {\n        return false;\n    }\n\n    pc = &Process->m_EventBody.m_ProcessCreateEvent;\n\n    //\n    // Get command line, image and working directory\n    //\n    snprintf( pathFile, 32, \"/proc/%d/cmdline\", ProcessId );\n    fp = fopen( pathFile, \"rb\" );\n    if (fp == NULL) {\n        return false;\n    }\n    numRead = fread( cmdline, 1, (128 * 1024) - 1, fp );\n    fclose( fp );\n    if (numRead > 0) {\n        // terminate cmdline\n        if (cmdline[numRead - 1] != 0x00) {\n            cmdline[numRead] = 0x00;\n            numRead++;\n        }\n        // convert nulls to spaces\n        for (int i=0; i<numRead - 1; i++) {\n            if (cmdline[i] == 0x00) {\n                cmdline[i] = ' ';\n            }\n        }\n    } else {\n        cmdline[0] = 0x00;\n    }\n\n    snprintf( pathFile, 32, \"/proc/%d/exe\", ProcessId );\n    numRead = readlink( pathFile, imagePath, PATH_MAX-1 );\n    if (numRead > 0) {\n        if (imagePath[numRead - 1] != 0x00) {\n            imagePath[numRead] = 0x00;\n        }\n    } else {\n        imagePath[0] = 0x00;\n    }\n\n    snprintf( pathFile, 32, \"/proc/%d/cwd\", ProcessId );\n    numRead = readlink( pathFile, cwd, PATH_MAX-1 );\n    if (numRead > 0) {\n        if (cwd[numRead - 1] != 0x00) {\n            cwd[numRead] = 0x00;\n        }\n    } else {\n        cwd[0] = 0x00;\n    }\n\n    uid = -1;\n    snprintf( pathFile, 32, \"/proc/%d\", ProcessId );\n    if (stat( pathFile, &st ) == 0) {\n        uid = st.st_uid;\n    }\n\n    imagePathLen = strlen( imagePath ) + 1;\n    cwdLen = strlen( cwd ) + 1;\n    cmdlineLen = strlen( cmdline ) + 1;\n\n    // calculate extension sizes and total data size\n    dataSize = sizeof( *Process ) + sizeof(uint64_t);\n    if ( dataSize + imagePathLen > Len ) {\n        imagePathLen = 0;\n        cwdLen = 0;\n        cmdlineLen = 0;\n    } else {\n        dataSize += imagePathLen;\n        if (dataSize + cwdLen > Len ) {\n            cwdLen = 0;\n            cmdlineLen = 0;\n        } else {\n            dataSize += cwdLen;\n            if ( dataSize + cmdlineLen > Len ) {\n                cmdlineLen = Len - dataSize;\n            }\n            dataSize += cmdlineLen;\n        }\n    }\n\n    Process->m_EventSize = dataSize;\n    Process->m_EventType = ProcessCreate;\n    Process->m_FieldFiltered = false;\n    Process->m_PreFiltered = false;\n\n    pc->m_ProcessId = ProcessId;\n    GetProcessInfo( &pc->m_CreateTime.QuadPart, &pts, &pc->m_ParentProcessId,\n            &pc->m_SessionId, &pc->m_ProcessKey, ProcessId );\n    pc->m_AuthenticationId.LowPart = uid;\n    pc->m_AuthenticationId.HighPart = pts;\n\n    memset( pc->m_Extensions, 0, sizeof(pc->m_Extensions) );\n    pc->m_Extensions[PC_Sid] = sizeof(uint64_t);\n    pc->m_Extensions[PC_ImagePath] = imagePathLen;\n    pc->m_Extensions[PC_CommandLine] = cmdlineLen;\n    pc->m_Extensions[PC_CurrentDirectory] = cwdLen;\n\n    ptr = (PCHAR)(pc + 1);\n    *(uint64_t *)ptr = uid;\n    ptr += sizeof(uint64_t);\n\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-truncation\"\n#pragma GCC diagnostic ignored \"-Wstringop-overflow\"\n// When using snprintf, the below fields get written past the end of the sysmon event struct memory region.\n// As such, source fortification (in)correctly flags the size of 'ptr' as being 0 and it fails with a buffer\n// overflow. We work around this by using memcpy instead.\n    if (imagePathLen > 0) {\n        //snprintf( ptr, Len, \"%s\", imagePath );\n        memcpy(ptr, imagePath, sizeof(CHAR) * imagePathLen);\n        ptr += imagePathLen;\n    }\n    if (cmdlineLen > 0) {\n        //snprintf( ptr, cmdlineLen, \"%s\", cmdline );\n        memcpy(ptr, cmdline, sizeof(CHAR) * cmdlineLen);\n        ptr += cmdlineLen;\n    }\n    if (cwdLen > 0) {\n        //snprintf( ptr, cwdLen, \"%s\", cwd );\n        memcpy(ptr, cwd, sizeof(CHAR) * cwdLen);\n    }\n #pragma GCC diagnostic pop\n\n    return true;\n}\n\n//--------------------------------------------------------------------\n//\n// SetBootTime\n//\n// Sets the boot time and clock tick globals\n//\n//--------------------------------------------------------------------\nvoid SetBootTime()\n{\n    FILE *fp = NULL;\n    double uptimeF = 0.0;\n    char machineIdStr[9];\n    struct timeval tv;\n\n    fp = fopen( \"/proc/uptime\", \"r\" );\n    if (fp != NULL) {\n        if(fscanf(fp, \"%lf\", &uptimeF) == EOF) {\n            fclose(fp);\n            return;\n        }\n\n        gettimeofday(&tv, NULL);\n\n        g_bootSecSinceEpoch = (double)tv.tv_sec + ((double)tv.tv_usec / (1000 * 1000)) - uptimeF;\n        fclose(fp);\n    } else {\n        g_bootSecSinceEpoch = 0.0;\n    }\n\n    g_clkTck = sysconf( _SC_CLK_TCK );\n    // if error, set it to the default of 100\n    if (g_clkTck <= 0) {\n        g_clkTck = 100;\n    }\n\n    // get passwd entry size, or guess at 4K if not\n    g_pwEntrySize = sysconf( _SC_GETPW_R_SIZE_MAX );\n    if (g_pwEntrySize == (size_t)-1) {\n        g_pwEntrySize = 4096;\n    }\n\n    // get the machineId\n    machineId = 0;\n    fp = fopen( \"/etc/machine-id\", \"r\" );\n    if (fp != NULL) {\n        if (fread( machineIdStr, 1, 8, fp ) == 8) {\n            machineIdStr[8] = 0x00;\n            machineId = strtol( machineIdStr, NULL, 16 );\n        }\n        fclose( fp );\n    }\n}\n\n//--------------------------------------------------------------------\n//\n// GetProcessInfo\n//\n// Gets the process start time in 100-ns intervals since epoch,\n// pts number, process parent ID, session ID and process key\n// (end_data address,\n// which should a) be randomised for PIE executables and b) be\n// depenedent on the size of the text segment in the executable -\n// hopefully this makes it difficult to craft a process with a\n// pre-determined value.)\n//\n// Returns true on success, otherwise false.\n//\n//--------------------------------------------------------------------\nBOOLEAN GetProcessInfo(\n    LONGLONG* StartTime,\n    ULONG* Pts,\n    ULONG* Ppid,\n    ULONG* Sessionid,\n    ULONGLONG* ProcessKey,\n    ULONG Pid\n    )\n{\n    if (StartTime == NULL || Pts == NULL || Ppid == NULL || Sessionid == NULL\n            || ProcessKey == NULL) {\n        fprintf(stderr, \"GetProcessInfo invalid params\\n\");\n        return FALSE;\n    }\n\n    char statFile[32];\n    FILE *fp = NULL;\n    char buf[2048];\n    size_t numRead = 0;\n    char *ptr = NULL;\n    double clkTcks = 0;\n    ULONG ppid = 0;\n    ULONG pts = 0;\n    ULONGLONG endData;\n\n    if (Pid <= 0) {\n        return FALSE;\n    }\n\n    snprintf(statFile, 32, \"/proc/%d/stat\", Pid);\n    fp = fopen(statFile, \"r\");\n    if (fp == NULL) {\n        return FALSE;\n    }\n\n    numRead = fread(buf, 1, 2048, fp);\n    buf[numRead] = 0x00;\n    fclose(fp);\n\n    //\n    // extract known fields from /proc/[pid]/stat\n    //\n    ptr = strrchr(buf, ')');\n    if (ptr == NULL) {\n        return FALSE;\n    }\n    ptr++;\n    for (int i=0; i<24; i++) {\n        ptr = strchr(ptr+1, ' ');\n        if (ptr == NULL) {\n            return FALSE;\n        }\n        if (i==0) {\n            sscanf(ptr, \"%d\", &ppid);\n        } else if (i==3) {\n            sscanf(ptr, \"%d\", &pts);\n        } else if (i==18) {\n            sscanf(ptr, \"%lf\", &clkTcks);\n        }\n    }\n    sscanf(ptr, \"%ld\", &endData);\n\n    snprintf(statFile, 32, \"/proc/%d/sessionid\", Pid);\n    fp = fopen(statFile, \"r\");\n    *Sessionid = -1;\n    if (fp != NULL) {\n        if(fscanf(fp, \"%d\", Sessionid) == EOF) {\n            fclose(fp);\n            return FALSE;\n        }\n\n        fclose(fp);\n    }\n\n    *ProcessKey = endData;\n    *Pts = pts & 0xff;\n    *Ppid = ppid;\n    *StartTime = (LONGLONG)round(((clkTcks / g_clkTck) + g_bootSecSinceEpoch) * 1000 * 1000 * 10);\n    return TRUE;\n}\n\n//--------------------------------------------------------------------\n//\n// GetProcessName\n//\n// Gets the process name into the given string.\n//\n// Returns true on success, otherwise false.\n//\n//--------------------------------------------------------------------\nBOOLEAN\nGetProcessName(\n\t\t \t  char* ProcName,\n\t\t\t  unsigned int Len,\n              pid_t Pid\n\t\t\t  )\n{\n    if (ProcName == NULL) {\n        fprintf(stderr, \"GetProcessName invalid params\\n\");\n        return FALSE;\n    }\n\n\tchar processPath[PATH_MAX];\n\tchar *argvPtr = NULL;\n\tFILE *fp = NULL;\n\tsize_t numRead = 0;\n    char cmdlineFile[32] = \"/proc/self/cmdline\";\n    char exeFile[32] = \"/proc/self/exe\";\n\n    if (Len > 1) {\n        *ProcName = 0x00;\n    } else {\n        return FALSE;\n    }\n\n    if (Pid > 0) {\n        snprintf(cmdlineFile, 32, \"/proc/%d/cmdline\", Pid);\n        snprintf(exeFile, 32, \"/proc/%d/exe\", Pid);\n    }\n\n\tfp = fopen(cmdlineFile, \"rb\");\n\tif (fp != NULL) {\n        numRead = fread(processPath, 1, PATH_MAX-1, fp);\n        processPath[numRead] = 0x00;\n        fclose(fp);\n\t}\n\n\tif (numRead <= 1) {\n\t\tnumRead = readlink(exeFile, processPath, PATH_MAX-1);\n        if ((int64_t)numRead <= 0) {\n            return FALSE;\n        }\n        processPath[numRead] = 0x00;\n\t}\n\n\targvPtr = strrchr(processPath, '/');\n\tif (argvPtr != NULL) {\n\t\twhile (*argvPtr == '/') {\n\t\t\targvPtr++;\n\t\t}\n\t\tif (*argvPtr == 0x00) {\n\t\t\treturn FALSE;\n\t\t}\n\t} else {\n\t\targvPtr = processPath;\n\t}\n\tsnprintf(ProcName, Len, \"%s\", argvPtr);\n\treturn TRUE;\n}\n\n//--------------------------------------------------------------------\n//\n// StrIsNum\n//\n// Returns true if string s is a number, otherwise false.\n//\n//--------------------------------------------------------------------\nBOOLEAN StrIsNum(\n    const char *s\n    )\n{\n    if (s == NULL || *s == 0x00) {\n        return false;\n    }\n\n    while (*s != 0x00) {\n        if (!isdigit(*s)) {\n            return false;\n        }\n        s++;\n    }\n    return true;\n}\n\n//--------------------------------------------------------------------\n//\n// EnumProcesses\n//\n// Reimplementation of Windows EnumProcesses. Returns an array of\n// process IDs. cb specifies size of array in bytes. lpcbNeeded\n// returns number of bytes used.\n//\n// Returns true on success, otherwise false.\n//\n//--------------------------------------------------------------------\nBOOLEAN EnumProcesses(\n    PDWORD      lpidProcess,\n    DWORD       cb,\n    PDWORD      lpcbNeeded\n    )\n{\n    if (lpidProcess == NULL || lpcbNeeded == NULL) {\n        fprintf(stderr, \"EnumProcesses invalid params\\n\");\n        return false;\n    }\n\n    DIR *directory;\n    struct dirent *entry;\n    DWORD count = 0;\n\n    *lpcbNeeded = 0;\n\n    directory = opendir(\"/proc\");\n    if (directory == NULL) {\n        return false;\n    }\n\n    while ((entry = readdir( directory )) != NULL && *lpcbNeeded < cb) {\n        if (entry->d_type == DT_DIR && StrIsNum(entry->d_name)) {\n            lpidProcess[count++] = atoi(entry->d_name);\n            (*lpcbNeeded) += sizeof(DWORD);\n        }\n    }\n\n    closedir(directory);\n    return true;\n}\n\n//--------------------------------------------------------------------\n//\n// StringFromGUID2\n//\n// Reimplmentation of Windows StringFromGUID2. Makes a string of the\n// provided GUID.\n//\n// Returns number of characters (including null).\n//\n//--------------------------------------------------------------------\nint StringFromGUID2(\n    const GUID guid,\n    PCHAR      lpsz,\n    int        cchMax\n    )\n{\n    if (lpsz == NULL) {\n        fprintf(stderr, \"STringFromGUID2 invalid params\\n\");\n        return 0;\n    }\n\n    // target string size includes enclosing braces, hyphens, and null terminator\n    int size = (sizeof(guid.Data1) + sizeof(guid.Data2) + sizeof(guid.Data3) +\n            sizeof(guid.Data4)) * 2 + 2 + 4 + 1;\n\n    if (cchMax < size) {\n        return 0;\n    }\n\n    return 1 + snprintf(lpsz, cchMax, \"{%08x-%04hx-%04hx-%02hhx%02hhx-%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx}\",\n            guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1],\n            guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5],\n            guid.Data4[6], guid.Data4[7]);\n\n}\n\n//--------------------------------------------------------------------\n//\n// GetLogonTime\n//\n// Return the logon time, in 100ns intervals since epoch, for given\n// user and terminal. LUID->LowPart = uid; LUID->HighPart = #pts\n//\n//--------------------------------------------------------------------\nLARGE_INTEGER GetLogonTime(\n    CONST LUID* user_luid\n    )\n{\n    LARGE_INTEGER result = {{0}};\n    if (user_luid == NULL) {\n        fprintf(stderr, \"GetLogonTime invalid params\\n\");\n        return result;\n    }\n\n    struct passwd pwd;\n    struct passwd *entry = NULL;\n    char buf[g_pwEntrySize];\n    struct utmpx *r;\n    struct utmpx s;\n\n    getpwuid_r( user_luid->LowPart, &pwd, buf, g_pwEntrySize, &entry );\n    if (entry == NULL) {\n        return result;\n    }\n\n    snprintf( s.ut_line, UT_LINESIZE, \"pts/%d\", user_luid->HighPart );\n\n    setutxent();\n    while ((r = getutxline(&s)) != (struct utmpx *)NULL) {\n        if (strncmp(r->ut_user, pwd.pw_name, __UT_NAMESIZE) == 0) {\n            // time since epoch in 100ns intervals\n            result.QuadPart = ((uint64_t)r->ut_tv.tv_sec * 1000 * 1000 * 10) + ((uint64_t)r->ut_tv.tv_usec * 10);\n            break;\n        }\n    }\n\n    endutxent();\n    return result;\n}\n\n//--------------------------------------------------------------------\n//\n// TranslateSid\n//\n// Reimplementation of Windows TranslateSid. Converts given UID,\n// provided as a SID, to the associated username.\n//\n//--------------------------------------------------------------------\nvoid TranslateSid(\n    CONST PSID  pUserSid,\n    PTCHAR      Buffer,\n    SIZE_T      Size\n    )\n{\n    if (Buffer != NULL) {\n        *Buffer = 0x00;\n    }\n\n    if (pUserSid == NULL || Buffer == NULL) {\n        return;\n    }\n\n    struct passwd pwd;\n    struct passwd *entry = NULL;\n    char buf[g_pwEntrySize];\n\n    getpwuid_r( (uid_t)*pUserSid, &pwd, buf, g_pwEntrySize, &entry );\n    if (entry == NULL) {\n        return;\n    }\n\n    snprintf(Buffer, Size, \"%s\", pwd.pw_name);\n}\n\n//--------------------------------------------------------------------\n//\n// EventDataDescCreate\n//\n// Linux implementation of EventDataDescCreate\n//\n//--------------------------------------------------------------------\nVOID EventDataDescCreate(\n       _In_ PEVENT_DATA_DESCRIPTOR EventDataDescriptor,\n       _In_ const PVOID            DataPtr,\n       _In_ ULONG                  DataSize\n       )\n{\n    if (EventDataDescriptor == NULL || DataPtr == NULL) {\n        return;\n    }\n    EventDataDescriptor->Ptr = (ULONGLONG)strdup((PCHAR)DataPtr);\n    EventDataDescriptor->Size = DataSize;\n    EventDataDescriptor->Reserved = 1;\n}\n\n//--------------------------------------------------------------------\n//\n// GetSystemTimeAsLargeInteger\n//\n// Gets the time since epoch in 100ns intervals\n//\n//--------------------------------------------------------------------\nVOID GetSystemTimeAsLargeInteger(\n    PLARGE_INTEGER timestamp\n    )\n{\n    if (timestamp == NULL) {\n        fprintf(stderr, \"GetSystemTimeAsLargeInteger invalid params\\n\");\n        return;\n    }\n\n    struct timeval tv;\n\n    gettimeofday(&tv, NULL);\n    // time in 100ns intervals since epoch\n    timestamp->QuadPart = (tv.tv_sec * 1000 * 1000 * 10) + (tv.tv_usec * 10);\n}\n\n//--------------------------------------------------------------------\n//\n// LargeTimeToSeconds\n//\n// Returns time in seconds since epoch of supplied timestamp (in 100ns\n// intervals since epoch).\n//\n//--------------------------------------------------------------------\ntime_t LargeTimeToSeconds(\n    CONST PLARGE_INTEGER timestamp\n    )\n{\n    if (timestamp == NULL) {\n        fprintf(stderr, \"LargeTimeToSeconds invalid params\\n\");\n        return (time_t)0;\n    }\n\n    return (time_t)(timestamp->QuadPart / (1000 * 1000 * 10));\n}\n\n//--------------------------------------------------------------------\n//\n// LargeTimeMilliseconds\n//\n// Returns the number of millisecond component of a LARGE_INTEGER\n// time.\n//\n//--------------------------------------------------------------------\nunsigned int LargeTimeMilliseconds(\n    CONST PLARGE_INTEGER timestamp\n    )\n{\n    if (timestamp == NULL) {\n        fprintf(stderr, \"LargeTimeMilliseconds invalid params\\n\");\n        return 0;\n    }\n\n    return (unsigned int)((timestamp->QuadPart / (1000 * 10)) % 1000);\n}\n\n//--------------------------------------------------------------------\n//\n// LargeTimeNanoseconds\n//\n// Returns the number of nanosecond component of a LARGE_INTEGER time.\n//\n//--------------------------------------------------------------------\nunsigned int LargeTimeNanoseconds(\n    CONST PLARGE_INTEGER timestamp\n    )\n{\n    if (timestamp == NULL) {\n        fprintf(stderr, \"LargeTimeNanoseconds invalid params\\n\");\n        return 0;\n    }\n\n    return (unsigned int)((timestamp->QuadPart % (1000 * 1000 * 10)) * 100);\n}\n\n//--------------------------------------------------------------------\n//\n// LinuxFileTimeToLargeInteger\n//\n// Converts linux file time to LARGE_INTEGER time.\n//\n//--------------------------------------------------------------------\nVOID LinuxFileTimeToLargeInteger(\n    PLARGE_INTEGER timestamp,\n    const my_statx_timestamp *filetime\n    )\n{\n    if (timestamp != NULL) {\n        timestamp->QuadPart = 0;\n    }\n\n    if (timestamp == NULL || filetime == NULL) {\n        fprintf(stderr, \"LinuxFileTimeToLargeInteger invalid params\\n\");\n        return;\n    }\n\n    timestamp->QuadPart = (filetime->tv_sec * 1000 * 1000 * 10) + (filetime->tv_nsec / 100);\n}\n\n//--------------------------------------------------------------------\n//\n// LargeIntegerToSystemTimeString\n//\n// Converts linux file time to LARGE_INTEGER time.\n//\n//--------------------------------------------------------------------\nVOID LargeIntegerToSystemTimeString(\n    char *s,\n    size_t sLen,\n    CONST PLARGE_INTEGER timestamp\n    )\n{\n    if (s != NULL) {\n        *s = 0x00;\n    }\n\n    if (s == NULL || timestamp == NULL) {\n        fprintf(stderr, \"LargeIntegerToSystemTimeString invalid params\\n\");\n        return;\n    }\n\n    // time in 100ns intervals since epoch\n    struct tm timeFields;\n    time_t fileTime = LargeTimeToSeconds( timestamp );\n\n    if ( gmtime_r(&fileTime, &timeFields) ) {\n\n        snprintf( s, sLen, \"%04u-%02u-%02uT%02u:%02u:%02u.%09uZ\",\n                timeFields.tm_year + 1900, timeFields.tm_mon + 1, timeFields.tm_mday,\n                timeFields.tm_hour, timeFields.tm_min, timeFields.tm_sec,\n                LargeTimeNanoseconds( timestamp ));\n    } else {\n\n        snprintf( s, sLen, \"Incorrect filetime: 0x%\" PRIx64,\n                     timestamp->QuadPart );\n    }\n}\n\n//--------------------------------------------------------------------\n//\n// LinuxGetFileHash\n//\n// Calculates image hash.\n//\n//--------------------------------------------------------------------\nvoid LinuxGetFileHash(uint32_t hashType, PTCHAR imagePath, char *stringBuffer, size_t stringBufferSize)\n{\n    unsigned char       tmpReadBuffer[4096] = {};\n    unsigned char       tmpHashBuffer[ALGO_MAX][256] = {};\n    unsigned char       tmpHashPrefixBuffer[16] = {};\n    unsigned char       tmpStringBuffer[256] = {};\n    char                hashSeparator[] = \",\";\n    char                hashPrefix[3][8] = {\"SHA1=\", \"MD5=\", \"SHA256=\"};\n    unsigned int        hashSize[ALGO_MAX] = {};\n    unsigned int        hashFlag[ALGO_MAX] = {};\n    size_t              n;\n    FILE                *filePtr;\n    EVP_MD_CTX          *sha1_ctx, *md5_ctx, *sha256_ctx;\n\n    // Allocate digests context\n    sha1_ctx    = EVP_MD_CTX_new();\n    md5_ctx     = EVP_MD_CTX_new();\n    sha256_ctx  = EVP_MD_CTX_new();\n    if ( !sha1_ctx || !md5_ctx || !sha256_ctx ) return;\n\n    EVP_DigestInit(sha1_ctx  , EVP_sha1());\n    EVP_DigestInit(md5_ctx   , EVP_md5());\n    EVP_DigestInit(sha256_ctx, EVP_sha256());\n\n    hashFlag[ALGO_SHA1] = (((hashType>>(ALGO_SHA1-1))&1) && (hashType & ALGO_MULTIPLE)) || (hashType == ALGO_SHA1);\n    hashFlag[ALGO_MD5] = (((hashType>>(ALGO_MD5-1))&1) && (hashType & ALGO_MULTIPLE)) || (hashType == ALGO_MD5);\n    hashFlag[ALGO_SHA256] = (((hashType>>(ALGO_SHA256-1))&1) && (hashType & ALGO_MULTIPLE)) || (hashType == ALGO_SHA256);\n\n    filePtr = fopen(imagePath, \"rb\");\n    if( !filePtr ) return;\n\n    // Read and hash image\n    while((n = fread(tmpReadBuffer, 1, sizeof(tmpReadBuffer), filePtr))){\n\n        if( hashFlag[ALGO_SHA1] ){\n            if (!EVP_DigestUpdate(sha1_ctx, tmpReadBuffer, n)){\n                fclose(filePtr);\n                return;\n            }\n            if ( !(hashType & ALGO_MULTIPLE) ) continue;\n        }\n\n        if( hashFlag[ALGO_MD5] ){\n            if (!EVP_DigestUpdate(md5_ctx, tmpReadBuffer, n)){\n                fclose(filePtr);\n                return;\n            }\n            if ( !(hashType & ALGO_MULTIPLE) ) continue;\n        }\n\n        if( hashFlag[ALGO_SHA256] ){\n            if (!EVP_DigestUpdate(sha256_ctx, tmpReadBuffer, n)){\n                fclose(filePtr);\n                return;\n            }\n            if ( !(hashType & ALGO_MULTIPLE) ) continue;\n        }\n\n    }\n    fclose(filePtr);\n\n    // Retrieve digest and cleanup\n    EVP_DigestFinal(sha1_ctx  , tmpHashBuffer[ALGO_SHA1]  , &hashSize[ALGO_SHA1]);\n    EVP_DigestFinal(md5_ctx   , tmpHashBuffer[ALGO_MD5]   , &hashSize[ALGO_MD5]);\n    EVP_DigestFinal(sha256_ctx, tmpHashBuffer[ALGO_SHA256], &hashSize[ALGO_SHA256]);\n\n    memset(tmpStringBuffer, 0, sizeof(tmpStringBuffer));\n    memset(tmpHashPrefixBuffer, 0, sizeof(tmpHashPrefixBuffer));\n\n    for(unsigned int algo=0;algo<ALGO_MAX;algo++){\n        if( hashFlag[algo] ){\n\n            // Add seperator if multiple hashes\n            if( *tmpStringBuffer ){\n                memset(tmpStringBuffer, 0, sizeof(tmpStringBuffer));\n                memset(tmpHashPrefixBuffer, 0, sizeof(tmpHashPrefixBuffer));\n\n                strcat((char *)tmpHashPrefixBuffer, hashSeparator);\n            }\n\n            // Add hash prefix \"SHA1=\", \"MD5=\" or \"SHA256=\"\n            switch(algo){\n                case ALGO_SHA1:\n                    strcat((char *)tmpHashPrefixBuffer, hashPrefix[ALGO_SHA1-1]);\n                    break;\n                case ALGO_MD5:\n                    strcat((char *)tmpHashPrefixBuffer, hashPrefix[ALGO_MD5-1]);\n                    break;\n                case ALGO_SHA256:\n                    strcat((char *)tmpHashPrefixBuffer, hashPrefix[ALGO_SHA256-1]);\n                    break;\n            }\n\n            // Digest to hex\n            for(unsigned int i=0;i<hashSize[algo];i++){\n                snprintf((char *)tmpStringBuffer+i*2, sizeof(tmpStringBuffer), \"%02x\", tmpHashBuffer[algo][i]);\n            }\n\n            if(stringBufferSize > strnlen((char *)tmpHashPrefixBuffer, sizeof(tmpHashPrefixBuffer)) + strnlen((char *)tmpStringBuffer, sizeof(tmpStringBuffer))){\n                strcat(stringBuffer, (char *)tmpHashPrefixBuffer);\n                strcat(stringBuffer, (char *)tmpStringBuffer);\n            }\n\n            if( !(hashType & ALGO_MULTIPLE) ) return;\n        }\n    }\n}\n\n//--------------------------------------------------------------------\n//\n// GetTid\n//\n// Returns current process thread id.\n//\n//--------------------------------------------------------------------\npid_t GetTid()\n{\n\treturn syscall(SYS_gettid);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n"
        },
        {
          "name": "linuxHelpers.h",
          "type": "blob",
          "size": 2.97265625,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// linuxHelpers.h\n//\n// Functions exported by linuxHelpers.cpp\n//\n//====================================================================\n\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"linuxTypes.h\"\n#include \"ioctlcmd.h\"\n\ntypedef pthread_mutex_t CRITICAL_SECTION;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid InitializeCriticalSection( CRITICAL_SECTION *p );\nvoid EnterCriticalSection( CRITICAL_SECTION* p );\nbool TryEnterCriticalSection( CRITICAL_SECTION* p );\nvoid LeaveCriticalSection( CRITICAL_SECTION* p );\nvoid DeleteCriticalSection( CRITICAL_SECTION *p );\nBOOLEAN GetProcess( PSYSMON_EVENT_HEADER Process, size_t Len, ULONG ProcessId );\nvoid SetBootTime();\nBOOLEAN GetProcessInfo( LONGLONG* StartTime, ULONG* Pts, ULONG* Ppid, ULONG* Sessionid, ULONGLONG* ProcessKey, ULONG Pid );\nBOOLEAN GetProcessName( char* ProcName, unsigned int Len, pid_t Pid );\nBOOLEAN StrIsNum( const char* s );\nBOOLEAN EnumProcesses( DWORD *lpidProcess, DWORD cb, PDWORD lpcbNeeded );\nint StringFromGUID2( const GUID guid, PCHAR lpsz, int cchMax );\nLARGE_INTEGER GetLogonTime( CONST LUID* user_luid );\nVOID EventDataDescCreate( _In_ PEVENT_DATA_DESCRIPTOR EventDataDescriptor,\n    _In_ const PVOID DataPtr, _In_ ULONG DataSize );\nVOID GetSystemTimeAsLargeInteger( PLARGE_INTEGER timestamp );\ntime_t LargeTimeToSeconds( CONST PLARGE_INTEGER timestamp );\nunsigned int LargeTimeMilliseconds( CONST PLARGE_INTEGER timestamp );\nunsigned int LargeTimeNanoseconds( CONST PLARGE_INTEGER timestamp );\nVOID LinuxFileTimeToLargeInteger( PLARGE_INTEGER timestamp, const my_statx_timestamp *filetime );\nVOID LargeIntegerToSystemTimeString( char *s, size_t sLen, CONST PLARGE_INTEGER timestamp );\nvoid LinuxGetFileHash(uint32_t hashType, PTCHAR imagePath, char *stringBuffer, size_t stringBufferSize);\npid_t GetTid();\n\n#ifdef __cplusplus\n}\n#endif\n"
        },
        {
          "name": "linuxTypes.h",
          "type": "blob",
          "size": 16.0908203125,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// linuxTypes.h\n//\n// Defines and typedefs to map to Windows types.\n//\n//====================================================================\n\n#pragma once\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <assert.h>\n#include <linux/limits.h>\n#include <ctype.h>\n\ntypedef long unsigned int size_t;\n\n//\n// Basics\n//\n#if !defined TRUE\n#define TRUE true\n#endif\n#if !defined FALSE\n#define FALSE false\n#endif\n\n#define CONST const\n\n#define VOID void\ntypedef VOID *PVOID, *LPVOID;\n\ntypedef bool BOOL, *PBOOL;\ntypedef bool BOOLEAN;\n\ntypedef char CHAR, *PCHAR, *LPCH, *PCH, INT8;\ntypedef CONST CHAR *LPCCH, *PCCH;\ntypedef CHAR *NPSTR, *LPSTR, *PSTR;\ntypedef PSTR *PZPSTR;\ntypedef CONST PSTR *PCZPSTR;\ntypedef CONST CHAR *LPCSTR, *PCSTR;\ntypedef PCSTR *PZPCSTR;\ntypedef CHAR *PZZSTR;\ntypedef CONST CHAR *PCZZSTR;\ntypedef CHAR *PNZCH;\ntypedef CONST CHAR *PCNZCH;\n\ntypedef unsigned char UCHAR, *PUCHAR, UINT8;\ntypedef uint8_t BYTE, *PBYTE;\n\ntypedef short SHORT, *PSHORT, INT16;\ntypedef unsigned short USHORT, *PUSHORT, UINT16;\ntypedef unsigned short WORD;\n\ntypedef int INT;\ntypedef unsigned int UINT;\n\ntypedef uint32_t DWORD, *PDWORD, *UINT_PTR;\ntypedef int32_t LONG, *PLONG, INT32;\ntypedef uint32_t ULONG, *PULONG, *ULONG_PTR, UINT32;\n\ntypedef int64_t INT64, LONGLONG;\ntypedef uint64_t ULONG64, UINT64, ULONGLONG, *PULONGLONG, DWORD64;\n\ntypedef int errno_t;\ntypedef uint32_t NTSTATUS;\ntypedef size_t SIZE_T, *PSIZE_T;\ntypedef uint64_t SID, *PSID;\n\ntypedef uint64_t SERVICE_STATUS;\ntypedef uint64_t SERVICE_STATUS_HANDLE;\ntypedef uint32_t HRESULT;\ntypedef PVOID SRWLOCK, *PSRWLOCK;\ntypedef PVOID HANDLE, *PHANDLE, HMODULE, REGHANDLE;\ntypedef HANDLE HKEY;\n\n\n//\n// Windows compiler annotaions\n//\n#define ANYSIZE_ARRAY 1\n#define __stdcall\n#define WINAPI\n\n#define _In_\n#define _Inout_\n#define _Out_\n#define _Outptr_\n#define _In_opt_\n#define _Inout_opt_\n#define _Out_opt_\n#define _Outptr_opt_\n#define _In_reads_(s)\n#define _In_reads_opt_(s)\n\n#define MAX_PATH PATH_MAX\n\ntypedef HANDLE EVT_HANDLE;\ntypedef HANDLE* PEVT_HANDLE;\ntypedef HANDLE EVT_OBJECT_ARRAY_PROPERTY_HANDLE;\n\n//\n// UNICODE (Wide Character) types\n//\ntypedef unsigned short WCHAR;    // wc,   16-bit UNICODE character\n\ntypedef WCHAR *PWCHAR, *LPWCH, *PWCH;\ntypedef CONST WCHAR *LPCWCH, *PCWCH;\n\ntypedef WCHAR *NWPSTR, *LPWSTR, *PWSTR;\ntypedef PWSTR *PZPWSTR;\ntypedef CONST PWSTR *PCZPWSTR;\ntypedef WCHAR *LPUWSTR, *PUWSTR;\ntypedef CONST WCHAR *LPCWSTR, *PCWSTR;\ntypedef PCWSTR *PZPCWSTR;\ntypedef CONST WCHAR *LPCUWSTR, *PCUWSTR;\n\ntypedef WCHAR *PZZWSTR;\ntypedef CONST WCHAR *PCZZWSTR;\ntypedef WCHAR *PUZZWSTR;\ntypedef CONST WCHAR *PCUZZWSTR;\n\ntypedef WCHAR *PNZWCH;\ntypedef CONST WCHAR *PCNZWCH;\ntypedef WCHAR *PUNZWCH;\ntypedef CONST WCHAR *PCUNZWCH;\n\ntypedef CONST WCHAR *LPCWCHAR, *PCWCHAR;\ntypedef CONST WCHAR *LPCUWCHAR, *PCUWCHAR;\n\ntypedef WCHAR *LPOLESTR;\n\n//\n//  UCS (Universal Character Set) types\n//\ntypedef unsigned long UCSCHAR;\n\n#define UCSCHAR_INVALID_CHARACTER (0xffffffff)\n#define MIN_UCSCHAR (0)\n#define MAX_UCSCHAR (0x0010FFFF)\n\ntypedef UCSCHAR *PUCSCHAR;\ntypedef const UCSCHAR *PCUCSCHAR;\n\ntypedef UCSCHAR *PUCSSTR;\ntypedef UCSCHAR *PUUCSSTR;\n\ntypedef const UCSCHAR *PCUCSSTR;\ntypedef const UCSCHAR *PCUUCSSTR;\n\ntypedef UCSCHAR *PUUCSCHAR;\ntypedef const UCSCHAR *PCUUCSCHAR;\n\n//\n// Neutral ANSI/UNICODE types and macros\n// Map tchar to char\n//\ntypedef char TCHAR, *PTCHAR;\ntypedef unsigned char TBYTE, *PTBYTE;\n\ntypedef LPCH LPTCH, PTCH;\ntypedef LPCCH LPCTCH, PCTCH;\ntypedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;\ntypedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;\ntypedef PZZSTR PZZTSTR, PUZZTSTR;\ntypedef PCZZSTR PCZZTSTR, PCUZZTSTR;\ntypedef PNZCH PNZTCH, PUNZTCH;\ntypedef PCNZCH PCNZTCH, PCUNZTCH;\n\n#define __TEXT(quote) quote\n#define TEXT(quote) __TEXT(quote)\n#define _T(x) x\n\n//\n// Coord for console screen struct\n//\ntypedef struct {\n    SHORT X;\n    SHORT Y;\n} COORD, *PCOORD;\n\ntypedef struct {\n    COORD dwSize;\n} CONSOLE_SCREEN_BUFFER_INFO, *PCONSOLE_SCREEN_BUFFER_INFO;\n\n//\n// Error codes\n//\n#define S_OK 0\n#define E_ABORT         0x80004004\n#define E_ACCESSDENIED  0x80070005\n#define E_FAIL          0x80004005\n#define E_HANDLE        0x80070006\n#define E_INVALIDARG    0x80070057\n#define E_NOINTERFACE   0x80004002\n#define E_NOTIMPL       0x80004001\n#define E_OUTOFMEMORY   0x8007000E\n#define E_POINTER       0x80004003\n#define E_UNEXPECTED    0x8000FFFF\n\n#define ERROR_SUCCESS 0L\n#define ERROR_FILE_NOT_FOUND 2L\n#define ERROR_INVALID_BLOCK 9L\n#define ERROR_INVALID_DATA 13L\n#define ERROR_OUTOFMEMORY 14L\n#define ERROR_INVALID_PARAMETER 87L\n#define ERROR_BUFFER_OVERFLOW 111L\n#define ERROR_INSUFFICIENT_BUFFER 122L\n#define ERROR_NO_MATCH 1169L\n#define ERROR_ELEVATION_REQUIRED 740L\n\n#if defined DEBUG || defined _DEBUG\n#define D_ASSERT(x) assert(x)\n#else\n#define D_ASSERT(x)\n#endif\n#define _ASSERT(x) assert(x)\n#define FAILED(hr) (((HRESULT)(hr)) < 0)\n#define SUCCEEDED(hr) (((HRESULT)(hr)) >= 0)\n\n//\n// Array macros\n//\n#define _countof(_x) (sizeof(_x)/sizeof(*_x))\n#define ARRAYSIZE(_x) (sizeof(_x)/sizeof(*_x))\n\n//\n// Map tchar to char\n//\n#define _tstoi(a) atoi(a)\n#define _istalnum(a) isalnum(a)\n#define _tcscpy(a,b) strcpy(a,b)\n#define _tcsncpy(a,b,c) strncpy(a,b,c)\n#define _tcsncpy_s(a,b,c,_TRUNCATE) snprintf(a,b,\"%s\",c)\n#define _tcsdup(x) strdup(x)\n#define _tcslen(x) strlen(x)\n#define _tcsicmp(a,b) strcasecmp(a,b)\n#define _tcscmp(a,b) strcmp(a,b)\n#define _tcsnicmp(a,b,c) strncasecmp(a,b,c)\n#define _tcsncmp(a,b,c) strncmp(a,b,c)\n#define _tcschr(a,b) strchr(a,b)\n#define _tcsrchr(a,b) strrchr(a,b)\n#define _tcstoul(a,b,c) strtoul(a,b,c)\n#define _tcsstr(a,b) strstr(a,b)\n#define _tcsncat_s(a,b,c,_TRUNCATE) strncat(a,b,c)\n#define _tcstok_s(a,b,c) strtok_r(a,b,c)\n\n#define _fputts(a,b) fputs(a,b)\n#define _fputtc(a,b) fputc(a,b)\n#define _fgetts(a,b,c) fgets(a,b,c)\n\n#define _ftprintf(...) fprintf(__VA_ARGS__)\n#define _ftprintf_s(...) fprintf(__VA_ARGS__)\n#define _tprintf(...) printf(__VA_ARGS__)\n#define _tprintf_s(...) printf(__VA_ARGS__)\n#define _stprintf(...) sprintf(__VA_ARGS__)\n#define _stprintf_s(...) snprintf(__VA_ARGS__)\n#define _sntprintf(...) snprintf(__VA_ARGS__)\n#define _sntprintf_s(a,b,c,...) snprintf(a,b,__VA_ARGS__)\n\n#define _tfopen(a,b) fopen(a,b)\n\n#define _tstat(a,b) stat(a,b)\n\n#define ZeroMemory(Destination,Length) memset((Destination),0,(Length))\n\n#define Sleep(a) usleep(a * 1000)\n\n#define __fallthrough __attribute__((fallthrough))\n\n#define FIELD_OFFSET(a,b) offsetof(a,b)\n\n#define CONTAINING_RECORD(address, type, field) ((type *)( \\\n                                                  (PCHAR)(address) - \\\n                                                  (PCHAR)(ULONG_PTR)(&((type *)0)->field)))\n\n#define NT_SUCCESS(x) (((uint32_t)x) < 0x40000000 ? TRUE : FALSE)\n\ntypedef enum _EVT_LOGIN_CLASS {\n    EvtRpcLogin\n} EVT_LOGIN_CLASS;\n\ntypedef enum _EVT_PUBLISHER_METADATA_PROPERTY_ID {\n    EvtPublisherMetadataPublisherGuid,\n    EvtPublisherMetadataResourceFilePath,\n    EvtPublisherMetadataParameterFilePath,\n    EvtPublisherMetadataMessageFilePath,\n    EvtPublisherMetadataHelpLink,\n    EvtPublisherMetadataPublisherMessageID,\n    EvtPublisherMetadataChannelReferences,\n    EvtPublisherMetadataChannelReferencePath,\n    EvtPublisherMetadataChannelReferenceIndex,\n    EvtPublisherMetadataChannelReferenceID,\n    EvtPublisherMetadataChannelReferenceFlags,\n    EvtPublisherMetadataChannelReferenceMessageID,\n    EvtPublisherMetadataLevels,\n    EvtPublisherMetadataLevelName,\n    EvtPublisherMetadataLevelValue,\n    EvtPublisherMetadataLevelMessageID,\n    EvtPublisherMetadataTasks,\n    EvtPublisherMetadataTaskName,\n    EvtPublisherMetadataTaskEventGuid,\n    EvtPublisherMetadataTaskValue,\n    EvtPublisherMetadataTaskMessageID,\n    EvtPublisherMetadataOpcodes,\n    EvtPublisherMetadataOpcodeName,\n    EvtPublisherMetadataOpcodeValue,\n    EvtPublisherMetadataOpcodeMessageID,\n    EvtPublisherMetadataKeywords,\n    EvtPublisherMetadataKeywordName,\n    EvtPublisherMetadataKeywordValue,\n    EvtPublisherMetadataKeywordMessageID,\n    EvtPublisherMetadataPropertyIdEND\n} EVT_PUBLISHER_METADATA_PROPERTY_ID;\n\ntypedef struct _LIST_ENTRY {\n    struct _LIST_ENTRY *Flink;\n    struct _LIST_ENTRY *Blink;\n} LIST_ENTRY, *PLIST_ENTRY, PRLIST_ENTRY;\n\ntypedef union _LARGE_INTEGER {\n    struct {\n        DWORD LowPart;\n        LONG  HighPart;\n    };\n    LONGLONG QuadPart;\n} LARGE_INTEGER, *PLARGE_INTEGER;\n\ntypedef struct {\n    DWORD LowPart;\n    LONG  HighPart;\n} LUID, *PLUID;\n\ntypedef struct _SYSTEMTIME {\n    WORD wYear;\n    WORD wMonth;\n    WORD wDayOfWeek;\n    WORD wDay;\n    WORD wHour;\n    WORD wMinute;\n    WORD wSecond;\n    WORD wMilliseconds;\n} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;\n\ntypedef struct {\n    ULONG   Data1;\n    USHORT  Data2;\n    USHORT  Data3;\n    UCHAR   Data4[8];\n} GUID, *PGUID, IID, *PIID, *REFGUID;\ntypedef CONST GUID *LPCGUID;\n\ntypedef struct _FILETIME {\n  DWORD dwLowDateTime;\n  DWORD dwHighDateTime;\n} FILETIME, *PFILETIME, *LPFILETIME;\n\ntypedef struct _EVT_VARIANT {\n    union {\n        BOOL       BooleanVal;\n        INT8       SByteVal;\n        INT16      Int16Val;\n        INT32      Int32Val;\n        INT64      Int64Val;\n        UINT8      ByteVal;\n        UINT16     UInt16Val;\n        UINT32     UInt32Val;\n        UINT64     UInt64Val;\n        float      SingleVal;\n        double     DoubleVal;\n        ULONGLONG  FileTimeVal;\n        SYSTEMTIME *SysTimeVal;\n        GUID       *GuidVal;\n        LPCWSTR    StringVal;\n        LPCSTR     AnsiStringVal;\n        PBYTE      BinaryVal;\n        PSID       SidVal;\n        size_t     SizeTVal;\n        BOOL       *BooleanArr;\n        INT8       *SByteArr;\n        INT16      *Int16Arr;\n        INT32      *Int32Arr;\n        INT64      *Int64Arr;\n        UINT8      *ByteArr;\n        UINT16     *UInt16Arr;\n        UINT32     *UInt32Arr;\n        UINT64     *UInt64Arr;\n        float      *SingleArr;\n        double     *DoubleArr;\n        FILETIME   *FileTimeArr;\n        SYSTEMTIME *SysTimeArr;\n        GUID       *GuidArr;\n        LPWSTR     *StringArr;\n        LPSTR      *AnsiStringArr;\n        PSID       *SidArr;\n        size_t     *SizeTArr;\n        EVT_HANDLE EvtHandleVal;\n        LPCWSTR    XmlVal;\n        LPCWSTR    *XmlValArr;\n    };\n    DWORD Count;\n    DWORD Type;\n} EVT_VARIANT, *PEVT_VARIANT;\n\ntypedef struct {\n    USHORT      Id;\n    UCHAR       Version;\n    UCHAR       Channel;\n    UCHAR       Level;\n    UCHAR       Opcode;\n    USHORT      Task;\n    ULONGLONG   Keyword;\n} EVENT_DESCRIPTOR, *PEVENT_DESCRIPTOR;\ntypedef CONST EVENT_DESCRIPTOR *PCEVENT_DESCRIPTOR;\n\ntypedef struct _EVENT_DATA_DESCRIPTOR {\n    ULONGLONG Ptr;\n    ULONG     Size;\n    union {\n        ULONG Reserved;\n        struct {\n            UCHAR  Type;\n            UCHAR  Reserved1;\n            USHORT Reserved2;\n        };\n    };\n} EVENT_DATA_DESCRIPTOR, *PEVENT_DATA_DESCRIPTOR;\n\ntypedef struct _EVENT_FILTER_DESCRIPTOR {\n    ULONGLONG Ptr;\n    ULONG     Size;\n    ULONG     Type;\n} EVENT_FILTER_DESCRIPTOR, *PEVENT_FILTER_DESCRIPTOR;\n\ntypedef void (*PENABLECALLBACK)(\n    LPCGUID SourceId,\n    ULONG IsEnabled,\n    UCHAR Level,\n    ULONGLONG MatchAnyKeyword,\n    ULONGLONG MatchAllKeyword,\n    PEVENT_FILTER_DESCRIPTOR FilterData,\n    PVOID CallbackContext\n);\n\ntypedef struct _RTL_BUFFER\n{\n    PUCHAR Buffer;\n    PUCHAR StaticBuffer;\n    SIZE_T Size;\n    SIZE_T StaticSize;\n    SIZE_T ReservedForAllocatedSize;\n    PVOID ReservedForIMalloc;\n} RTL_BUFFER, *PRTL_BUFFER;\n\ntypedef struct _UNICODE_STRING {\n    USHORT Length;\n    USHORT MaximumLength;\n    PWSTR  Buffer;\n} UNICODE_STRING, *PUNICODE_STRING;\n\ntypedef struct _RTL_UNICODE_STRING_BUFFER\n{\n    UNICODE_STRING String;\n    RTL_BUFFER ByteBuffer;\n    UCHAR MinimumStaticBufferForTerminalNul[sizeof(WCHAR)];\n} RTL_UNICODE_STRING_BUFFER, *PRTL_UNICODE_STRING_BUFFER;\n\ntypedef struct _OSVERSIONINFOA {\n    DWORD dwOSVersionInfoSize;\n    DWORD dwMajorVersion;\n    DWORD dwMinorVersion;\n    DWORD dwBuildNumber;\n    DWORD dwPlatformId;\n    CHAR  szCSDVersion[128];\n} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA,\n    OSVERSIONINFO, *POSVERSIONINFO, *LPOSVERSIONINFO;\n\n#define MAX_MODULE_NAME32 255\n\ntypedef struct tagMODULEENTRY32 {\n    DWORD   dwSize;\n    DWORD   th32ModuleID;\n    DWORD   th32ProcessID;\n    DWORD   GlblcntUsage;\n    DWORD   ProccntUsage;\n    BYTE    *modBaseAddr;\n    DWORD   modBaseSize;\n    HMODULE hModule;\n    char    szModule[MAX_MODULE_NAME32 + 1];\n    char    szExePath[MAX_PATH];\n} MODULEENTRY32;\n\ntypedef struct _LSA_UNICODE_STRING {\n    USHORT Length;\n    USHORT MaximumLength;\n    PWSTR  Buffer;\n} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;\n\ntypedef struct _LSA_LAST_INTER_LOGON_INFO {\n    LARGE_INTEGER LastSuccessfulLogon;\n    LARGE_INTEGER LastFailedLogon;\n    ULONG         FailedAttemptCountSinceLastSuccessfulLogon;\n} LSA_LAST_INTER_LOGON_INFO, *PLSA_LAST_INTER_LOGON_INFO;\n\ntypedef struct _SECURITY_LOGON_SESSION_DATA {\n    ULONG                     Size;\n    LUID                      LogonId;\n    LSA_UNICODE_STRING        UserName;\n    LSA_UNICODE_STRING        LogonDomain;\n    LSA_UNICODE_STRING        AuthenticationPackage;\n    ULONG                     LogonType;\n    ULONG                     Session;\n    PSID                      Sid;\n    LARGE_INTEGER             LogonTime;\n    LSA_UNICODE_STRING        LogonServer;\n    LSA_UNICODE_STRING        DnsDomainName;\n    LSA_UNICODE_STRING        Upn;\n    ULONG                     UserFlags;\n    LSA_LAST_INTER_LOGON_INFO LastLogonInfo;\n    LSA_UNICODE_STRING        LogonScript;\n    LSA_UNICODE_STRING        ProfilePath;\n    LSA_UNICODE_STRING        HomeDirectory;\n    LSA_UNICODE_STRING        HomeDirectoryDrive;\n    LARGE_INTEGER             LogoffTime;\n    LARGE_INTEGER             KickOffTime;\n    LARGE_INTEGER             PasswordLastSet;\n    LARGE_INTEGER             PasswordCanChange;\n    LARGE_INTEGER             PasswordMustChange;\n} SECURITY_LOGON_SESSION_DATA, *PSECURITY_LOGON_SESSION_DATA;\n\n#define LinuxFileOpen           0xFF01\n#define LinuxNetworkEvent       0xFF02\n\n#define __NR_NETWORK            400\n#define __NR_PROCTERM           401\n#define __NR_RAWACCESS          402\n#define __NR_CREATE             403\n\ntypedef enum {\n    LINUX_FO_Sid,\n    LINUX_FO_ImagePath,\n    LINUX_FO_PathName,\n    LINUX_FO_Dir,\n    LINUX_FILE_OPEN_ExtMax\n} LINUX_FILE_OPEN_Extensions;\n\ntypedef struct {\n    ULONGLONG           tv_sec;\n    ULONG               tv_nsec;\n} my_statx_timestamp;\n\ntypedef struct {\n    ULONG                   m_ProcessId;\n    LARGE_INTEGER           m_EventTime;\n    ULONG                   m_Flags;\n    ULONG                   m_Mode;\n    my_statx_timestamp      m_atime;\n    my_statx_timestamp      m_mtime;\n    my_statx_timestamp      m_ctime;\n    ULONG                   m_Extensions[LINUX_FILE_OPEN_ExtMax];\n} SYSMON_LINUX_FILE_OPEN, *PSYSMON_LINUX_FILE_OPEN;\n\n\ntypedef struct {\n    ULONG                   m_ProcessId;\n    LARGE_INTEGER           m_EventTime;\n    CONST VOID*             m_SockId;\n    bool                    m_AddrIsIPv4;\n    BYTE                    m_SrcAddr[16];\n    BYTE                    m_DstAddr[16];\n    WORD                    m_SrcPort;\n    WORD                    m_DstPort;\n    bool                    m_IsTCP;\n    ULONG                   m_OldState;\n    ULONG                   m_NewState;\n} SYSMON_LINUX_NETWORK_EVENT, *PSYSMON_LINUX_NETWORK_EVENT;\n\n\n\n\n"
        },
        {
          "name": "linuxVersion.h.in",
          "type": "blob",
          "size": 1.78515625,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// linuxVersion.h\n//\n// Version information, specific to the Linux version.\n//\n//====================================================================\n\n//\n// Version information\n//\n#define STRFILEVER \t\t\"@PROJECT_VERSION_MAJOR@.@PROJECT_VERSION_MINOR@.@PROJECT_VERSION_PATCH@\"\n\n//\n// File information\n//\n#define VER_COMPANY \t\"Sysinternals - www.sysinternals.com\"\n\n#define VER_COPYRIGHT \t\"By Mark Russinovich, Thomas Garnier and Kevin Sheldrake\\nCopyright (C) 2014-2023 Microsoft Corporation\\nLicensed under MIT/GPLv2\\nUsing libxml2. libxml2 is Copyright (C) 1998-2012 Daniel Veillard. All Rights Reserved.\"\n\n"
        },
        {
          "name": "linuxWideChar.c",
          "type": "blob",
          "size": 12.990234375,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// linuxWideChar.c\n//\n// 16-bit character routines for linux\n//\n//====================================================================\n\n#include \"stdafx.h\"\n\n//--------------------------------------------------------------------\n//\n// UTF8toUTF16\n//\n// Convert null-terminated UTF8 string to null-terminated UTF16 string\n//\n// len is the size of the target buffer (WCHARs, not bytes)\n// If len==0, then nothing is written, but the value returned is equal\n// to the size of the buffer required.\n//\n// Returns the number of wchars writtern, including the null.\n// Returns 0 on error.\n//\n//--------------------------------------------------------------------\nsize_t UTF8toUTF16(\n    PWCHAR dst,\n    CONST CHAR* src,\n    size_t len\n    )\n{\n    size_t i = 0;\n    uint32_t unicode;\n    bool writeDst = true;\n\n    if (src == NULL) {\n        return 0;\n    }\n\n    if (len == 0) {\n        // only calculate the length, so set len to max value\n        len = 0xFFFFFFFF;\n        writeDst = false;\n    } else if (dst == NULL) {\n        return 0;\n    }\n\n    while (i<len - 1 && *src != 0) {\n        if (*src & 0x80) { // multibyte\n            if ((src[0] & 0xE0) == 0xC0 && (src[1] & 0xC0) == 0x80) { // 2 bytes\n                unicode = (src[1] & 0x3F) | ((uint32_t)(src[0] & 0x1F) << 6);\n                src += 2;\n            } else if ((src[0] & 0xF0) == 0xE0 && (src[1] & 0xC0) == 0x80\n                    && (src[2] & 0xC0) == 0x80) { // 3 bytes\n                unicode = (src[2] & 0x3F) | ((uint32_t)(src[1] & 0x3F) << 6) |\n                        ((uint32_t)(src[0] & 0x0F) << 12);\n                src += 3;\n            } else if ((src[0] & 0xF8) == 0xF0 && (src[1] & 0xC0) == 0x80\n                    && (src[2] & 0xC0) == 0x80 && (src[3] & 0xC0) == 0x80) { // 4 bytes\n                unicode = (src[3] & 0x3F) | ((uint32_t)(src[2] & 0x3F) << 6) |\n                        ((uint32_t)(src[1] & 0x3F) << 12) |\n                        ((uint32_t)(src[0] & 0x07) << 18);\n                src += 4;\n            } else {\n                if (writeDst) {\n                    *dst = 0;\n                }\n                return 0;\n            }\n        } else {\n            unicode = *src;\n            src++;\n        }\n\n        if (unicode > 0xFFFF) {\n            if (i == len - 2) {\n                if (writeDst) {\n                    *dst = 0;\n                }\n                return 0;\n            }\n            if (writeDst) {\n                *dst = (WCHAR)(0xD800 | (((unicode - 0x10000) & 0xFFC00) >> 10));\n                dst++;\n                *dst = (WCHAR)(0xDC00 | ((unicode - 0x10000) & 0x3FF));\n                dst++;\n            }\n            i += 2;\n        } else {\n            if (writeDst) {\n                *dst = (WCHAR)unicode;\n                dst++;\n            }\n            i++;\n        }\n    }\n    if (writeDst) {\n        *dst = 0;\n    }\n    return i+1;\n}\n\n//--------------------------------------------------------------------\n//\n// UTF16toUTF8\n//\n// Convert null-terminated UTF16 string to null-terminated UTF8 string\n//\n// len is the size of the target buffer (bytes)\n// If len==0, then nothing is written, but the value returned is equal\n// to the size of the buffer required.\n//\n// Returns the number of wchars writtern, including the null.\n// Returns 0 on error.\n//\n//--------------------------------------------------------------------\nsize_t UTF16toUTF8(\n    PCHAR dst,\n    CONST WCHAR* src,\n    size_t len\n    )\n{\n    size_t i = 0;\n    uint32_t unicode;\n    bool writeDst = true;\n\n    if (src == NULL) {\n        return 0;\n    }\n\n    if (len == 0) {\n        // only calculate the length, so set len to max value\n        len = 0xFFFFFFFF;\n        writeDst = false;\n    } else if (dst == NULL) {\n        return 0;\n    }\n\n    while (i<len - 1 && *src != 0) {\n        if ((*src & 0xFC00) == 0xD800) { // multiword\n            if ((src[1] & 0xFC00) == 0xDC00) { // check second word\n                unicode = ((src[1] & 0x3FF) | ((uint32_t)(src[0] & 0x3FF) << 10)) + 0x10000;\n                src += 2;\n            } else {\n                if (writeDst) {\n                    *dst = 0;\n                }\n                return 0;\n            }\n        } else {\n            unicode = *src;\n            src++;\n        }\n\n        if (unicode > 0xFFFF) { // 4 bytes\n            if (i < len - 4) {\n                if (writeDst) {\n                    dst[0] = (UCHAR)(0xF0 | ((unicode & 0x001C0000) >> 18));\n                    dst[1] = (UCHAR)(0x80 | ((unicode & 0x0003F000) >> 12));\n                    dst[2] = (UCHAR)(0x80 | ((unicode & 0x00000FC0) >>  6));\n                    dst[3] = (UCHAR)(0x80 |  (unicode & 0x0000003F));\n                    dst += 4;\n                }\n                i += 4;\n            } else {\n                if (writeDst) {\n                    *dst = 0;\n                }\n                return 0;\n            }\n        } else if (unicode > 0x7FF) { // 3 bytes\n            if (i < len - 3) {\n                if (writeDst) {\n                    dst[0] = (UCHAR)(0xE0 | ((unicode & 0xF000) >> 12));\n                    dst[1] = (UCHAR)(0x80 | ((unicode & 0x0FC0) >>  6));\n                    dst[2] = (UCHAR)(0x80 |  (unicode & 0x003F));\n                    dst += 3;\n                }\n                i += 3;\n            } else {\n                if (writeDst) {\n                    *dst = 0;\n                }\n                return 0;\n            }\n        } else if (unicode > 0x7F) { // 2 bytes\n            if (i < len - 2) {\n                if (writeDst) {\n                    dst[0] = (UCHAR)(0xC0 | ((unicode & 0x7C0) >> 6));\n                    dst[1] = (UCHAR)(0x80 |  (unicode & 0x03F));\n                    dst += 2;\n                }\n                i += 2;\n            } else {\n                if (writeDst) {\n                    *dst = 0;\n                }\n                return 0;\n            }\n        } else {\n            if (writeDst) {\n                *dst = (UCHAR)unicode;\n                dst++;\n            }\n            i++;\n        }\n    }\n    if (writeDst) {\n        *dst = 0;\n    }\n    return i+1;\n}\n\n//--------------------------------------------------------------------\n//\n// WideStrcmp\n//\n// Wide version of strcmp.\n//\n//--------------------------------------------------------------------\nint WideStrcmp(\n    _In_ PCWCHAR s1,\n    _In_ PCWCHAR s2\n    )\n{\n    if (s1 == NULL || s2 == NULL) {\n        fprintf(stderr, \"WideStrcmp invalid params\\n\");\n        return 1;\n    }\n\n    while (*s1 != 0 || *s2 != 0) {\n        if (*s1 < *s2) {\n            return -1;\n        } else if (*s1 > *s2) {\n            return 1;\n        }\n        s1++;\n        s2++;\n    }\n    return 0;\n}\n\n//--------------------------------------------------------------------\n//\n// WideStrncmp\n//\n// Wide version of strncmp.\n//\n//--------------------------------------------------------------------\nint WideStrncmp(\n    _In_ PCWCHAR s1,\n    _In_ PCWCHAR s2,\n    _In_ int n\n    )\n{\n    if (s1 == NULL || s2 == NULL) {\n        fprintf(stderr, \"WideStrncmp invalid params\\n\");\n        return 1;\n    }\n\n    while ((*s1 != 0 || *s2 != 0) && n>0) {\n        if (*s1 < *s2) {\n            return -1;\n        } else if (*s1 > *s2) {\n            return 1;\n        }\n        s1++;\n        s2++;\n        n--;\n    }\n    return 0;\n}\n\n//--------------------------------------------------------------------\n//\n// WideStrcasecmp\n//\n// Wide version of strcasecmp.\n//\n//--------------------------------------------------------------------\nint WideStrcasecmp(\n    _In_ PCWCHAR s1,\n    _In_ PCWCHAR s2\n    )\n{\n    if (s1 == NULL || s2 == NULL) {\n        fprintf(stderr, \"WideStrcasecmp invalid params\\n\");\n        return 1;\n    }\n\n    WCHAR c1, c2;\n    while (*s1 != 0 || *s2 != 0) {\n        c1 = WideToupper(*s1);\n        c2 = WideToupper(*s2);\n        if (c1 < c2) {\n            return -1;\n        } else if (c1 > c2) {\n            return 1;\n        }\n        s1++;\n        s2++;\n    }\n    return 0;\n}\n\n//--------------------------------------------------------------------\n//\n// WideStrncasecmp\n//\n// Wide version of strncasecmp.\n//\n//--------------------------------------------------------------------\nint WideStrncasecmp(\n    _In_ PCWCHAR s1,\n    _In_ PCWCHAR s2,\n    _In_ int n\n    )\n{\n    if (s1 == NULL || s2 == NULL) {\n        fprintf(stderr, \"WideStrncasecmp invalid params\\n\");\n        return 1;\n    }\n\n    WCHAR c1, c2;\n    while ((*s1 != 0 || *s2 != 0) && n>0) {\n        c1 = WideToupper(*s1);\n        c2 = WideToupper(*s2);\n        if (c1 < c2) {\n            return -1;\n        } else if (c1 > c2) {\n            return 1;\n        }\n        s1++;\n        s2++;\n        n--;\n    }\n    return 0;\n}\n\n//--------------------------------------------------------------------\n//\n// WideStrlen\n//\n// Wide version of strlen.\n//\n//--------------------------------------------------------------------\nsize_t WideStrlen(\n    _In_ PCWCHAR s\n    )\n{\n    if (s == NULL) {\n        fprintf(stderr, \"WideStrlen invalid params\\n\");\n        return 0;\n    }\n\n    size_t n = 0;\n\n    while (*s != 0) {\n        s++;\n        n++;\n    }\n\n    return n;\n}\n\n//--------------------------------------------------------------------\n//\n// WideStrchr\n//\n// Wide version of strchr.\n//\n//--------------------------------------------------------------------\nPCWCHAR WideStrchr(\n    _In_ PCWCHAR      s,\n    _In_ CONST WCHAR  c\n    )\n{\n    if (s == NULL) {\n        fprintf(stderr, \"WideStrchr invalid params\\n\");\n        return NULL;\n    }\n\n    while (*s != 0) {\n        if (*s == c) {\n            return s;\n        }\n        s++;\n    }\n    if (c == 0) {\n        return s;\n    }\n\n    return NULL;\n}\n\n//--------------------------------------------------------------------\n//\n// WideStrrchr\n//\n// Wide version of strrchr.\n//\n//--------------------------------------------------------------------\nPWCHAR WideStrrchr(\n    _In_ PWCHAR       s,\n    _In_ CONST WCHAR  c\n    )\n{\n    if (s == NULL) {\n        fprintf(stderr, \"WideStrrchr invalid params\\n\");\n        return NULL;\n    }\n\n    PWCHAR t = s + WideStrlen(s);\n    while (t != s) {\n        if (*t == c) {\n            return t;\n        }\n        t--;\n    }\n    if (*t == c) {\n        return t;\n    }\n\n    return NULL;\n}\n\n//--------------------------------------------------------------------\n//\n// WideStrstr\n//\n// Wide version of strstr.\n//\n//--------------------------------------------------------------------\nPWCHAR WideStrstr(\n    _In_ PWCHAR     h,\n    _In_ PCWCHAR    n\n    )\n{\n    if (h == NULL || n == NULL) {\n        fprintf(stderr, \"WideStrstr invalid params\\n\");\n        return NULL;\n    }\n\n    unsigned int hLen = WideStrlen(h);\n    unsigned int nLen = WideStrlen(n);\n\n    if (hLen == 0 || nLen == 0) {\n        return NULL;\n    }\n\n    while (hLen >= nLen && WideStrncmp(h, n, nLen) != 0) {\n        h++;\n        hLen--;\n    }\n    if (hLen < nLen) {\n        return NULL;\n    } else {\n        return h;\n    }\n}\n\n//--------------------------------------------------------------------\n//\n// WideStrspn\n//\n// Wide version of strspn.\n//\n//--------------------------------------------------------------------\nsize_t WideStrspn(\n    _In_ PCWCHAR s,\n    _In_ PCWCHAR acc\n    )\n{\n    if (s == NULL || acc == NULL) {\n        fprintf(stderr, \"WideStrspn invalid params\\n\");\n        return 0;\n    }\n\n    size_t n = 0;\n    unsigned int accLen = WideStrlen(acc);\n\n    if (accLen == 0) {\n        return 0;\n    }\n    while (*s != 0 && WideStrchr(acc, *s) != NULL) {\n        s++;\n        n++;\n    }\n\n    return n;\n}\n\n//--------------------------------------------------------------------\n//\n// WideToupper\n//\n// Wide version of toupper.\n//\n//--------------------------------------------------------------------\nWCHAR WideToupper(\n    WCHAR c\n    )\n{\n    if (c >= 'a' && c <= 'z') {\n        return c - 'a' + 'A';\n    }\n    return c;\n}\n\n//--------------------------------------------------------------------\n//\n// WideTolower\n//\n// Wide version of tolower.\n//\n//--------------------------------------------------------------------\nWCHAR WideTolower(\n    WCHAR c\n    )\n{\n    if (c >= 'A' && c <= 'Z') {\n        return c - 'A' + 'a';\n    }\n    return c;\n}\n\n\n"
        },
        {
          "name": "linuxWideChar.h",
          "type": "blob",
          "size": 2.1181640625,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// linuxWideChar.h\n//\n// Functions exported by linuxWideChar.c\n//\n//====================================================================\n\n#include \"linuxTypes.h\"\n\n//\n// In linuxWideChar.cpp\n//\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nsize_t UTF8toUTF16( PWCHAR dst, CONST CHAR* src, size_t len);\nsize_t UTF16toUTF8( PCHAR dst, CONST WCHAR* src, size_t len);\nint WideStrcmp( _In_ PCWCHAR s1, _In_ PCWCHAR s2 );\nint WideStrncmp( _In_ PCWCHAR s1, _In_ PCWCHAR s2, _In_ int n );\nint WideStrcasecmp( _In_ PCWCHAR s1, _In_ PCWCHAR s2 );\nint WideStrncasecmp( _In_ PCWCHAR s1, _In_ PCWCHAR s2, _In_ int n );\nsize_t WideStrlen( _In_ PCWCHAR s );\nPCWCHAR WideStrchr( _In_ PCWCHAR s, _In_ CONST WCHAR c );\nPWCHAR WideStrrchr( _In_ PWCHAR s, _In_ CONST WCHAR c );\nPWCHAR WideStrstr( _In_ PWCHAR h, _In_ PCWCHAR n);\nsize_t WideStrspn( _In_ PCWCHAR s, _In_ PCWCHAR acc );\nWCHAR WideToupper( WCHAR c );\nWCHAR WideTolower( WCHAR c );\n\n#ifdef __cplusplus\n}\n#endif\n\n"
        },
        {
          "name": "makePackages.sh",
          "type": "blob",
          "size": 3.7734375,
          "content": "#!/bin/sh\n#\n#    SysmonForLinux\n#\n#    Copyright (c) Microsoft Corporation\n#\n#    All rights reserved.\n#\n#    MIT License\n#\n#    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n#\n#    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n#\n#    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n\n#################################################################################\n#\n# makePackages.sh\n#\n# Builds the directory trees for DEB and RPM packages and, if suitable tools are\n# available, builds the actual packages too.\n#\n#################################################################################\n\n\nif [ \"$5\" = \"\" ]; then\n    echo \"Usage: $0 <SourceDir> <BinaryDir> <package name> <package version> <package release> <PackageType>\"\n    exit 1\nfi\n\n# copy cmake vars\nCMAKE_SOURCE_DIR=$1\nPROJECT_BINARY_DIR=$2\nPACKAGE_NAME=$3\nPACKAGE_VER=$4\nPACKAGE_REL=$5\nPACKAGE_TYPE=$6\n\nDEB_PACKAGE_NAME=\"${PACKAGE_NAME}_${PACKAGE_VER}_amd64\"\nRPM_PACKAGE_NAME=\"${PACKAGE_NAME}-${PACKAGE_VER}-${PACKAGE_REL}\"\n\nif [ \"$PACKAGE_TYPE\" = \"deb\" ]; then\n    DPKGDEB=`which dpkg-deb`\n\n    # clean up first\n    if [ -d \"${PROJECT_BINARY_DIR}/deb\" ]; then\n        rm -rf \"${PROJECT_BINARY_DIR}/deb\"\n    fi\n\n    # copy deb files\n    mkdir -p \"${PROJECT_BINARY_DIR}/deb/${DEB_PACKAGE_NAME}\"\n    cp -a \"${CMAKE_SOURCE_DIR}/package/DEBIAN\" \"${PROJECT_BINARY_DIR}/deb/${DEB_PACKAGE_NAME}/\"\n    cp \"${PROJECT_BINARY_DIR}/DEBIANcontrol\" \"${PROJECT_BINARY_DIR}/deb/${DEB_PACKAGE_NAME}/DEBIAN/control\"\n    mkdir -p \"${PROJECT_BINARY_DIR}/deb/${DEB_PACKAGE_NAME}/usr/share/man/man8\"\n    cp -a \"${PROJECT_BINARY_DIR}/sysmon.8.gz\" \"${PROJECT_BINARY_DIR}/deb/${DEB_PACKAGE_NAME}/usr/share/man/man8\"\n    mkdir -p \"${PROJECT_BINARY_DIR}/deb/${DEB_PACKAGE_NAME}/usr/bin\"\n    cp \"${PROJECT_BINARY_DIR}/sysmon\" \"${PROJECT_BINARY_DIR}/deb/${DEB_PACKAGE_NAME}/usr/bin/\"\n\n    # make the deb\n    if [ \"$DPKGDEB\" != \"\" ]; then\n        cd \"${PROJECT_BINARY_DIR}/deb\"\n        \"$DPKGDEB\" -Zxz --build --root-owner-group \"${DEB_PACKAGE_NAME}\"\n        RET=$?\n    else\n        echo \"No dpkg-deb found\"\n        RET=1\n    fi\n\n    exit 0\nfi\n\nif [ \"$PACKAGE_TYPE\" = \"rpm\" ]; then\n    RPMBUILD=`which rpmbuild`\n\n    if [ -d \"${PROJECT_BINARY_DIR}/rpm\" ]; then\n        rm -rf \"${PROJECT_BINARY_DIR}/rpm\"\n    fi\n\n    # copy rpm files\n    mkdir -p \"${PROJECT_BINARY_DIR}/rpm/${RPM_PACKAGE_NAME}/SPECS\"\n    cp -a \"${PROJECT_BINARY_DIR}/SPECS.spec\" \"${PROJECT_BINARY_DIR}/rpm/${RPM_PACKAGE_NAME}/SPECS/${RPM_PACKAGE_NAME}.spec\"\n    mkdir \"${PROJECT_BINARY_DIR}/rpm/${RPM_PACKAGE_NAME}/BUILD/\"\n    cp \"${PROJECT_BINARY_DIR}/sysmon.8.gz\" \"${PROJECT_BINARY_DIR}/sysmon\" \"${PROJECT_BINARY_DIR}/rpm/${RPM_PACKAGE_NAME}/BUILD/\"\n\n    # make the rpm\n    if [ \"$RPMBUILD\" != \"\" ]; then\n        cd \"${PROJECT_BINARY_DIR}/rpm/${RPM_PACKAGE_NAME}\"\n        \"$RPMBUILD\" --define \"_topdir `pwd`\" -v -bb \"SPECS/${RPM_PACKAGE_NAME}.spec\"\n        RET=$?\n        cp RPMS/x86_64/*.rpm ..\n    else\n        echo \"No rpmbuild found\"\n        RET=1\n    fi\nfi\n\nexit $RET\n"
        },
        {
          "name": "missingdefs.h",
          "type": "blob",
          "size": 2.552734375,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// missingdefs.h\n//\n// Defines types that are not available in vmlinux.h\n//\n// Unfortunately, today, when including vmlinux.h there is no way to \n// prevent redefinitions and hence we need to remove all headers that\n// cause redefitions. By doing so however, we also miss the defitions\n// in those headers that vmlinux.h does not define. This is a known \n// problem and the current solution is to define those types seperately. \n// This files contains all the defs that are missing. \n//\n// For more detail, please see:\n// https://lore.kernel.org/bpf/CAO658oV9AAcMMbVhjkoq5PtpvbVf41Cd_TBLCORTcf3trtwHfw@mail.gmail.com/ \n//\n//====================================================================\n\n#pragma once\n\n// If we're not compiling eBPF programs, the below will not be defined. \n#ifndef EBPF_CO_RE\nenum {\n    TCP_ESTABLISHED = 1,\n    TCP_SYN_SENT = 2,\n    TCP_SYN_RECV = 3,\n    TCP_FIN_WAIT1 = 4,\n    TCP_FIN_WAIT2 = 5,\n    TCP_TIME_WAIT = 6,\n    TCP_CLOSE = 7,\n    TCP_CLOSE_WAIT = 8,\n    TCP_LAST_ACK = 9,\n    TCP_LISTEN = 10,\n    TCP_CLOSING = 11,\n    TCP_NEW_SYN_RECV = 12\n};\n#endif\n\n#ifndef AT_FDCWD\n#define AT_FDCWD\t\t    -100\n#endif\n\n#ifndef AT_REMOVEDIR\n#define AT_REMOVEDIR\t\t0x200 \n#endif\n\n#ifndef O_CREAT\n#define O_CREAT            0100\n#endif \n\n#ifndef PTRACE_ATTACH\n#define PTRACE_ATTACH              16\n#endif\n\n#ifndef PTRACE_SEIZE\n#define PTRACE_SEIZE             0x4206\n#endif"
        },
        {
          "name": "networkTracker.cpp",
          "type": "blob",
          "size": 32.482421875,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS* PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// networkTracker.cpp\n//\n// Class for tracking the various network connection telemetry,\n// including managing eBPF maps (ageing off, handling saturation).\n//\n//====================================================================\n\n#include <string.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"networkTracker.h\"\n#include \"linuxHelpers.h\"\n\n#include \"missingdefs.h\"\n\nextern int mapFds[];\n\n//--------------------------------------------------------------------\n//\n// NetworkTracker constructor\n//\n// Initialise values.\n//\n//--------------------------------------------------------------------\nNetworkTracker::NetworkTracker(LONGLONG staleSeconds, LONGLONG checkSeconds)\n{\n    staleDuration = staleSeconds * 1000 * 1000 * 10; // in ns intervals\n    checkDuration = checkSeconds * 1000 * 1000 * 10; // in ns intervals\n    GetSystemTimeAsLargeInteger(&timeLastChecked);\n}\n\n//--------------------------------------------------------------------\n//\n// PurgeStale\n//\n// Purge old entries in the Connect and Accept trackers.  Uses a\n// time-based ordered map to walk the entries, which holds keys to the\n// other data structures.\n//\n//--------------------------------------------------------------------\nvoid NetworkTracker::PurgeStale()\n{\n    LARGE_INTEGER curTime;\n\n    // periodically remove stale entries\n    GetSystemTimeAsLargeInteger(&curTime);\n    if (curTime.QuadPart - timeLastChecked.QuadPart > checkDuration) {\n        auto it = connectTrackerTimes.cbegin();\n        while (it != connectTrackerTimes.cend()) {\n            if (curTime.QuadPart - it->first > staleDuration) {\n                connectTracker.erase(it->second);\n                it = connectTrackerTimes.erase(it);\n            } else {\n                break; // as this is an ordered map, we have exhausted all stale items\n            }\n        }\n        auto it2 = acceptTrackerTimes.cbegin();\n        while (it2 != acceptTrackerTimes.cend()) {\n            if (curTime.QuadPart - it2->first > staleDuration) {\n                acceptTracker.erase(*(it2->second));\n                it2 = acceptTrackerTimes.erase(it2);\n            } else {\n                break; // as this is an ordered map, we have exhausted all stale items\n            }\n        }\n    }\n\n    GetSystemTimeAsLargeInteger(&timeLastChecked);\n}\n\n//--------------------------------------------------------------------\n//\n// SeenConnect\n//\n// Connects are observed in three transitions: CLOSE->SYN_SENT,\n// SYN_SENT->ESTABLISHED, ESTABLISHED->CLOSE. The first transistion\n// is in the process context and the associated process ID is of the\n// process making the connection - this is stored, but the connection\n// hasn't yet been properly established (maybe the port is closed,\n// for example). The second transition establishes the connection, but\n// the process ID is of a daemon as this happens asynchronously, hence\n// retrieve the PID from the first transition. The third transition\n// is the connection closing, so remove any SYN_SENT transitions.\n//\n// Returns the PID for established connections, otherwise 0.\n//\n//--------------------------------------------------------------------\npid_t NetworkTracker::SeenConnect(PSYSMON_EVENT_HEADER eventHdr)\n{\n    if (eventHdr == NULL) {\n        fprintf(stderr, \"NetworkTracker::SeenConnect invalid params\\n\");\n        return 0;\n    }\n\n    pid_t pid = 0;\n    PSYSMON_LINUX_NETWORK_EVENT event = (PSYSMON_LINUX_NETWORK_EVENT)&eventHdr->m_EventBody;\n\n    if (event->m_NewState == TCP_CLOSE) {\n        // remove state\n        auto it = connectTracker.find(event->m_SockId);\n        if (it != connectTracker.end()) {\n            connectTrackerTimes.erase(it->second.second);\n            connectTracker.erase(it);\n        }\n        pid = 0;\n    } else {\n\n        // attempt to insert - bool indicates success/failure\n        auto ret = connectTracker.emplace(event->m_SockId, std::pair<pid_t, LONGLONG>(event->m_ProcessId, event->m_EventTime.QuadPart));\n\n        if (ret.second) {\n            // successful insertion - didn't already exist\n            connectTrackerTimes.emplace(event->m_EventTime.QuadPart, event->m_SockId);\n            pid = 0;\n        } else {\n            // already exists\n            pid = ret.first->second.first;\n            if (event->m_NewState == TCP_ESTABLISHED) {\n                // connection is established, so remove it\n                connectTracker.erase(event->m_SockId);\n                connectTrackerTimes.erase(event->m_EventTime.QuadPart);\n            }\n        }\n    }\n\n    PurgeStale();\n\n    return pid;\n}\n\n//--------------------------------------------------------------------\n//\n// SeenAccept - transition of port state\n//\n// Accept transitions all happen asynchronously, so store the\n// established transitions (which contains full source/dest\n// addr/port).\n//\n//--------------------------------------------------------------------\nvoid NetworkTracker::SeenAccept(AddrAndPort sourceAddrAndPort, AddrAndPort destAddrAndPort, LONGLONG eventTime)\n{\n    acceptTracker.erase(sourceAddrAndPort);\n    auto ret = acceptTracker.emplace(sourceAddrAndPort, std::pair<AddrAndPort, LONGLONG>(destAddrAndPort, eventTime));\n    acceptTrackerTimes.emplace(eventTime, &(ret.first->first));\n\n    PurgeStale();\n}\n\n//--------------------------------------------------------------------\n//\n// SeenAccept - successful call to accept() syscall\n//\n// Calls to accept() don't provide easy access to full source/dest\n// addr/port, but do happen in the context of the process, so the\n// process ID is valid. This function matches the successful call to\n// accept() to the previously stored port transition from SYN_RECV to\n// ESTABLISHED.\n//\n// Returns true on success, false otherwise.\n//\n//--------------------------------------------------------------------\nbool NetworkTracker::SeenAccept(AddrAndPort sourceAddrAndPort, AddrAndPort *destAddrAndPort)\n{\n    if (destAddrAndPort == NULL) {\n        fprintf(stderr, \"NetworkTracker::SeenAccept invalid params\\n\");\n        return false;\n    }\n\n    auto it = acceptTracker.find(sourceAddrAndPort);\n    if (it == acceptTracker.end()) {\n        return false;\n    }\n    acceptTrackerTimes.erase(it->second.second);\n    memcpy(destAddrAndPort, &it->second.first, sizeof(AddrAndPort));\n    acceptTracker.erase(it);\n    return true;\n}\n\n//--------------------------------------------------------------------\n//\n// CleseAccept\n//\n// Remove entries where port was closed.\n//\n//--------------------------------------------------------------------\nvoid NetworkTracker::CloseAccept(AddrAndPort sourceAddrAndPort, AddrAndPort destAddrAndPort)\n{\n    auto it = acceptTracker.find(sourceAddrAndPort);\n    if (it == acceptTracker.end()) {\n        return;\n    }\n    if (!(it->second.first == destAddrAndPort)) {\n        return;\n    }\n    acceptTrackerTimes.erase(it->second.second);\n    acceptTracker.erase(it);\n}\n\n//--------------------------------------------------------------------\n//\n// FindOrEraseUdpPidFd\n//\n// For inbound UDP connections, PID and file descriptors are stored.\n// This function locates and optionally erases them from the data\n// structures.\n//\n// Returns the last time they were reported, or 0 if not found.\n//\n//--------------------------------------------------------------------\nLONGLONG NetworkTracker::FindOrEraseUdpPidFd(pid_t pid, int fd, const PacketAddresses *p, bool erase)\n{\n    LONGLONG lastTime = 0;\n\n    auto it = udpRecvTrackerPidFds.find(pid);\n    if (it == udpRecvTrackerPidFds.end())\n        // no existing pid entry\n        return 0;\n    auto it2 = it->second.find(fd);\n    if (it2 == it->second.end())\n        // no existing fd entry\n        return 0;\n\n    if (p == NULL || it2->second.second != *p) {\n        // packet doesn't match\n        lastTime = 0;\n    } else {\n        lastTime = it2->second.first;\n    }\n\n    if (erase) {\n        // remove entries\n        it->second.erase(it2);\n        if (it->second.empty()) {\n            udpRecvTrackerPidFds.erase(it);\n        }\n    }\n    return lastTime;\n}\n\n//--------------------------------------------------------------------\n//\n// FindOrEraseUdpPidAddr\n//\n// For outbound UDP connections, PID and addresses are stored.\n// This function locates and optionally erases them from the data\n// structures.\n//\n// Returns the last time they were reported, or 0 if not found.\n//\n//--------------------------------------------------------------------\nLONGLONG NetworkTracker::FindOrEraseUdpPidAddr(pid_t pid, const PacketAddresses *p, bool erase)\n{\n    if (p == NULL) {\n        fprintf(stderr, \"NetworkTracker::FindOrEraseUdpPidAddr invalid params\\n\");\n        return 0;\n    }\n\n    LONGLONG lastTime = 0;\n\n    auto it = udpSendTrackerPidAddrs.find(pid);\n    if (it == udpSendTrackerPidAddrs.end())\n        // no existing pid entry\n        return 0;\n    auto it2 = it->second.find(*p);\n    if (it2 == it->second.end())\n        // no existing address entry\n        return 0;\n\n    lastTime = it2->second;\n\n    if (erase) {\n        // remove entries\n        it->second.erase(it2);\n        if (it->second.empty()) {\n            udpSendTrackerPidAddrs.erase(it);\n        }\n    }\n    return lastTime;\n}\n\n//--------------------------------------------------------------------\n//\n// UpdateUdpPidFd\n//\n// For inbound UDP connections, updates a PID/FD entry.\n//\n// Returns the last time they were reported, or 0 if not previous\n// entry.\n//\n//--------------------------------------------------------------------\nLONGLONG NetworkTracker::UpdateUdpPidFd(pid_t pid, int fd, LONGLONG ctime, const PacketAddresses *p)\n{\n    if (p == NULL) {\n        fprintf(stderr, \"NetworkTracker::UpdateUdpPidFd invalid params\\n\");\n        return 0;\n    }\n\n    LONGLONG lastTime = 0;\n\n    std::pair<LONGLONG, PacketAddresses> newEntry(ctime, *p);\n\n    auto it = udpRecvTrackerPidFds.find(pid);\n    if (it == udpRecvTrackerPidFds.end()) {\n        // no existing pid entry\n        udpRecvTrackerPidFds.emplace(pid, std::unordered_map<int, std::pair<LONGLONG, PacketAddresses>>({{fd, newEntry}}));\n        return 0;\n    }\n    auto it2 = it->second.find(fd);\n    if (it2 == it->second.end()) {\n        // no existing fd entry\n        it->second.emplace(fd, newEntry);\n        return 0;\n    }\n\n    // update entry and return previous time\n    if (it2->second.second == *p) {\n        lastTime = it2->second.first;\n        it2->second.first = ctime;\n        return lastTime;\n    }\n\n    // entry was for a previous socket\n    it->second.erase(it2);\n    it->second.emplace(fd, newEntry);\n    return 0;\n}\n\n//--------------------------------------------------------------------\n//\n// UpdateUdpPidAddr\n//\n// For outbound UDP connections, updates a PID/Address entry.\n//\n// Returns the last time they were reported, or 0 if not previous\n// entry.\n//\n//--------------------------------------------------------------------\nLONGLONG NetworkTracker::UpdateUdpPidAddr(pid_t pid, LONGLONG ctime, const PacketAddresses *p)\n{\n    if (p == NULL) {\n        fprintf(stderr, \"NetworkTracker::UpdateUdpPidAddr invalid params\\n\");\n        return 0;\n    }\n\n    LONGLONG lastTime = 0;\n\n    auto it = udpSendTrackerPidAddrs.find(pid);\n    if (it == udpSendTrackerPidAddrs.end()) {\n        // no existing pid entry\n        udpSendTrackerPidAddrs.emplace(pid, std::unordered_map<PacketAddresses, LONGLONG>({{*p, ctime}}));\n        return 0;\n    }\n    auto it2 = it->second.find(*p);\n    if (it2 == it->second.end()) {\n        // no existing address entry\n        it->second.emplace(*p, ctime);\n        return 0;\n    }\n\n    // update entry and return previous time\n    lastTime = it2->second;\n    it2->second = ctime;\n    return lastTime;\n}\n\n//--------------------------------------------------------------------\n//\n// PurgeUdp\n//\n// Purge old entries in the outbound and inbound UDP trackers.  Uses a\n// time-based ordered map to walk the entries, which holds keys to the\n// other data structures.\n//\n//--------------------------------------------------------------------\nvoid NetworkTracker::PurgeUdp(LONGLONG curTime)\n{\n    LONGLONG lastTime = 0;\n    pid_t pid = 0;\n    int fd;\n\n    // traverse all PID/FD entries chronologically\n    auto it = udpRecvTrackerTimes.cbegin();\n    while (it != udpRecvTrackerTimes.cend()) {\n        // if an entry is older than our reporting interval\n        if (curTime - it->first > UDP_REPORT_INTERVAL) {\n            pid = it->second >> 32;\n            fd = it->second & 0xFFFFFFFF;\n            // check if the kernel version is older than our reporting interval or not\n            if (telemetryMapLookupElem(mapFds[UDP_PIDFD_HASH], &it->second, &lastTime) < 0) {\n                FindOrEraseUdpPidFd(pid, fd, NULL, true);\n            } else {\n                if (curTime - lastTime > UDP_REPORT_INTERVAL) {\n                    // remove the element from the kernel hash\n                    telemetryMapDeleteElem(mapFds[UDP_PIDFD_HASH], &it->second);\n                    // remove from the pid and fd tracker\n                    FindOrEraseUdpPidFd(pid, fd, NULL, true);\n                } else {\n                    // update our records with latest seen time\n                    PacketAddresses p;\n                    if (GetUdp(&p, pid, fd)) {\n                        UpdateUdpPidFd(pid, fd, lastTime, &p);\n                        udpRecvTrackerTimes.emplace(lastTime, it->second);\n                    } else {\n                        FindOrEraseUdpPidFd(pid, fd, NULL, true);\n                    }\n                }\n            }\n            // remove existing time entry and iterate\n            it = udpRecvTrackerTimes.erase(it);\n        } else {\n            break; // as this is an ordered map, we have exhausted all stale items\n        }\n    }\n\n    // traverse all packetAddrs entries chronologically\n    auto it2 = udpSendTrackerTimes.cbegin();\n    while (it2 != udpSendTrackerTimes.cend()) {\n        // if an entry is older than our reporting interval\n        if (curTime - it2->first > UDP_REPORT_INTERVAL) {\n            PacketAddresses p(it2->second.IPv4, it2->second.srcAddr, it2->second.srcPort,\n                    it2->second.dstAddr, it2->second.dstPort);\n            // check if the kernel version is older than our reporting interval or not\n            if (telemetryMapLookupElem(mapFds[UDP_ADDRS_HASH], &it2->second, &lastTime) < 0) {\n                FindOrEraseUdpPidAddr(pid, &p, true);\n            } else {\n                if (curTime - lastTime > UDP_REPORT_INTERVAL) {\n                    // remove the element from the kernel hash\n                    telemetryMapDeleteElem(mapFds[UDP_ADDRS_HASH], &it2->second);\n                    // remove from the pid and addr tracker\n                    FindOrEraseUdpPidAddr(pid, &p, true);\n                } else {\n                    // update our records with latest seen time\n                    UpdateUdpPidAddr(pid, lastTime, &p);\n                    udpSendTrackerTimes.emplace(lastTime, it2->second);\n                }\n            }\n            // remove existing time entry and iterate\n            it2 = udpSendTrackerTimes.erase(it2);\n        } else {\n            break; // as this is an ordered map, we have exhausted all stale items\n        }\n    }\n}\n\n//--------------------------------------------------------------------\n//\n// PathToInode\n//\n// Returns the inode associated with a socket FD, or 0 if the FD isn't\n// an inode path.\n//\n//--------------------------------------------------------------------\nuint64_t NetworkTracker::PathToInode(const char *path)\n{\n    if (path == NULL) {\n        fprintf(stderr, \"NetworkTracker::PathToInode invalid params\\n\");\n        return 0;\n    }\n\n    if (strncmp(path, INODE_SOCK_PRE1, strlen(INODE_SOCK_PRE1)) == 0) {\n        return atoi(path + strlen(INODE_SOCK_PRE1));\n    } else if (strncmp(path, INODE_SOCK_PRE2, strlen(INODE_SOCK_PRE2)) == 0) {\n        return atoi(path + strlen(INODE_SOCK_PRE2));\n    }\n    return 0;\n}\n\n//--------------------------------------------------------------------\n//\n// InodeToAddr\n//\n// Looks up a socket inode in the UDP and UDP6 tables in /proc.\n//\n// Returns true on success, othewise false.\n//\n//--------------------------------------------------------------------\nbool NetworkTracker::InodeToAddr(PacketAddresses *p, bool IPv4, uint64_t inodeIn)\n{\n    if (p == NULL) {\n        fprintf(stderr, \"NetworkTracker::InodeToAddr invalid params\\n\");\n        return false;\n    }\n\n    FILE *fp = NULL;\n    char *line = NULL;\n    size_t len = 0;\n    int numTokens = 0;\n    char lAddrText[33];\n    char rAddrText[33];\n    uint32_t sl, st, tr, uid, timeout;\n    uint64_t txQueue, rxQueue, tmWhen, retrnsmt, inode;\n    char file[PATH_MAX];\n\n    if (IPv4) {\n        snprintf(file, PATH_MAX, \"%s\", PROC_UDP_FNAME);\n    } else {\n        snprintf(file, PATH_MAX, \"%s\", PROC_UDP6_FNAME);\n    }\n\n    memset(p->localAddr, 0, sizeof(p->localAddr));\n    memset(p->remoteAddr, 0, sizeof(p->remoteAddr));\n\n    fp = fopen(file, \"r\");\n    if (fp == NULL)\n        return false;\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n    getline(&line, &len, fp); // skip first line\n#pragma GCC diagnostic pop\n\n    while ((getline(&line, &len, fp)) >= 0) {\n        numTokens = sscanf(line, \"%u: %32[0-9A-Fa-f]:%hX %32[0-9A-Fa-f]:%hX %X %lX:%lX %X:%lX %lX %u %u %lu %*s\\n\",\n                &sl, lAddrText, &p->localPort, rAddrText, &p->remotePort, &st, &txQueue, &rxQueue, &tr, &tmWhen,\n                &retrnsmt, &uid, &timeout, &inode);\n        if (numTokens < 14 || inode != inodeIn)\n            continue;\n        if (strlen(lAddrText) == 8) {\n            // IPv4\n            p->IPv4 = true;\n            *(uint32_t *)p->localAddr = strtoul(lAddrText, NULL, 16);\n            *(uint32_t *)p->remoteAddr = strtoul(rAddrText, NULL, 16);\n            free(line);\n            fclose(fp);\n            return true;\n        }\n        if (strlen(lAddrText) == 32) {\n            // IPv6\n            p->IPv4 = false;\n            sscanf(lAddrText, \"%08X%08X%08X%08X\", (uint32_t *)p->localAddr, (uint32_t *)(p->localAddr + 4),\n                    (uint32_t *)(p->localAddr + 8), (uint32_t *)(p->localAddr + 12));\n            sscanf(rAddrText, \"%08X%08X%08X%08X\", (uint32_t *)p->remoteAddr, (uint32_t *)(p->remoteAddr + 4),\n                    (uint32_t *)(p->remoteAddr + 8), (uint32_t *)(p->remoteAddr + 12));\n            free(line);\n            fclose(fp);\n            return true;\n        }\n    }\n    free(line);\n    fclose(fp);\n    return false;\n}\n\n//--------------------------------------------------------------------\n//\n// GetUdp\n//\n// Maps a PID and FD to a UDP connection.\n//\n// Returns true on success, otherwise false.\n//\n//--------------------------------------------------------------------\nbool NetworkTracker::GetUdp(PacketAddresses *p, pid_t pid, int fd)\n{\n    if (p == NULL) {\n        fprintf(stderr, \"NetworkTracker::GetUdp invalid params\\n\");\n        return false;\n    }\n\n    char fdPath[PATH_MAX];\n    char fdSocket[PATH_MAX];\n    uint64_t inode = 0;\n\n    snprintf(fdPath, sizeof(fdPath), \"/proc/%d/fd/%d\", pid, fd);\n    if (readlink(fdPath, fdSocket, sizeof(fdSocket)) == -1)\n        return false;\n\n    inode = PathToInode(fdSocket);\n    if (inode == 0)\n        return false;\n\n    if (InodeToAddr(p, true, inode))\n        return true;\n\n    if (InodeToAddr(p, false, inode))\n        return true;\n\n    return false;\n}\n\n/*\n  These functions are called when the EBPF program sees a socket read or write.\n  The EBPF program should have logged it together with the current time; if it\n  hasn't then the EBPF hash is full and needs rapid purging, and then the\n  recent observation needs storing.\n  Otherwise (the usual case), we need to check if our existing entry is old\n  enough to qualify sending this one as an event - it is possible the last\n  observation was purged from the EBPF hash and therefore this observation has\n  occurred within the cool-off window.\n  If so, we need to update our local version with the new time. Regardless\n  we need to purge aged events from both hashes.\n\n  The EBPF recv hash maps PID|FD to time, and is used to limit the observations\n  sent to userland.\n  The udpRecvTrackerTimes hash maps time to PID|FD, and is used to purge old\n  observations (ordered map).\n  The udpRecvTrackerPidsFd hash maps PID to FD to time, and is used to remove\n  entries in the other hashes when processes terminate (map).\n  An EBPF program attahed to close() deletes entries from the EBPF recv hash\n  as sockets are closed.\n\n  The send hashes work a similar way, with the EBPF send hash mapping a\n  packetAddr (struct) to time, the udpSendTrackerTimes mapping times to\n  packetAddrs, and the udpSendTrackerPidsAddr mapping PID to PacketAddresses to\n  time.\n\n  Returns whether to send event - because we haven't seen this one recently.\n*/\n\n//--------------------------------------------------------------------\n//\n// SeenUdp - inbound read/recv/recvmsg/recvmmsg\n//\n// Checks if an inbound UDP connection should be reported.\n//\n// Returns true if it should be reported, otherwise false.\n//\n//--------------------------------------------------------------------\nbool NetworkTracker::SeenUdp(PacketAddresses *p, pid_t pid, int fd)\n{\n    if (p == NULL) {\n        fprintf(stderr, \"NetworkTracker::SeenUdp invalid params\\n\");\n        return false;\n    }\n\n    LARGE_INTEGER curTime;\n    LONGLONG lastTime;\n    uint64_t pidFd = ((uint64_t)pid << 32) | fd;\n\n    GetSystemTimeAsLargeInteger(&curTime);\n\n    if (!GetUdp(p, pid, fd)) {\n        // failed to look up in /proc\n        return false;\n    }\n\n    // get the most recent sent time from the kernel\n    if (telemetryMapLookupElem(mapFds[UDP_PIDFD_HASH], &pidFd, &lastTime) < 0) {\n        // kernel has sent this entry but it's not in the hash. This means\n        // the hash is full. So rapidly empty a significant proportion of it\n        // to make space for additional observations.\n        auto it = udpRecvTrackerTimes.cbegin();\n        for (unsigned int i=0; i<UDP_HASH_SIZE * UDP_HASH_RPP && it != udpRecvTrackerTimes.cend(); i++) {\n            telemetryMapDeleteElem(mapFds[UDP_PIDFD_HASH], &it->second);\n            it++;\n        }\n\n        // insert the one we have just received\n\n        // find the last time we sent it\n        lastTime = FindOrEraseUdpPidFd(pid, fd, p, false);\n        if (lastTime > 0) {\n            // copy to kernel table\n            telemetryMapUpdateElem(mapFds[UDP_PIDFD_HASH], &pidFd, &lastTime, MAP_UPDATE_CREATE_OR_OVERWRITE);\n        } else {\n            // insert new element\n            telemetryMapUpdateElem(mapFds[UDP_PIDFD_HASH], &pidFd, &curTime.QuadPart, MAP_UPDATE_CREATE_OR_OVERWRITE);\n            UpdateUdpPidFd(pid, fd, curTime.QuadPart, p);\n            udpRecvTrackerTimes.emplace(curTime.QuadPart, pidFd);\n        }\n        PurgeUdp(curTime.QuadPart);\n        return (curTime.QuadPart - lastTime > UDP_REPORT_INTERVAL);\n    }\n\n    LONGLONG prevTime = FindOrEraseUdpPidFd(pid, fd, p, false);\n    if (prevTime > 0) {\n        if (curTime.QuadPart - prevTime > UDP_REPORT_INTERVAL) {\n            // not sent this entry for long enough - update records and send event\n            telemetryMapUpdateElem(mapFds[UDP_PIDFD_HASH], &pidFd, &curTime.QuadPart, MAP_UPDATE_CREATE_OR_OVERWRITE);\n            lastTime = UpdateUdpPidFd(pid, fd, curTime.QuadPart, p);\n            udpRecvTrackerTimes.erase(lastTime);\n            udpRecvTrackerTimes.emplace(curTime.QuadPart, pidFd);\n            PurgeUdp(curTime.QuadPart);\n            return true;\n        } else {\n            // our local entry is older than the kernel one - update it\n            telemetryMapUpdateElem(mapFds[UDP_PIDFD_HASH], &pidFd, &prevTime, MAP_UPDATE_CREATE_OR_OVERWRITE);\n            PurgeUdp(curTime.QuadPart);\n            return false;\n        }\n    } else {\n        // we don't have an existing entry\n        UpdateUdpPidFd(pid, fd, lastTime, p);\n        udpRecvTrackerTimes.emplace(lastTime, pidFd);\n        PurgeUdp(curTime.QuadPart);\n        return true;\n    }\n}\n\n//--------------------------------------------------------------------\n//\n// SeenUdp - outbound packet capture\n//\n// Checks if an outbound UDP connection should be reported.\n//\n// Returns true if it should be reported, otherwise false.\n//\n//--------------------------------------------------------------------\nbool NetworkTracker::SeenUdp(const PacketAddresses *p, pid_t pid)\n{\n    if (p == NULL) {\n        fprintf(stderr, \"NetworkTracker::SeenUdp invalid params\\n\");\n        return false;\n    }\n\n    LARGE_INTEGER curTime;\n    LONGLONG lastTime;\n    packetAddrs pa;\n\n    pa.IPv4 = p->IPv4;\n    pa.srcPort = p->localPort;\n    pa.dstPort = p->remotePort;\n    memcpy(pa.srcAddr, p->localAddr, sizeof(pa.srcAddr));\n    memcpy(pa.dstAddr, p->remoteAddr, sizeof(pa.dstAddr));\n\n    GetSystemTimeAsLargeInteger(&curTime);\n\n    // get the most recent sent time from the kernel\n    if (telemetryMapLookupElem(mapFds[UDP_ADDRS_HASH], &pa, &lastTime) < 0) {\n        // kernel has sent this entry but it's not in the hash. This means\n        // the hash is full. So rapidly empty a significant proportion of it\n        // to make space for additional observations.\n        auto it = udpSendTrackerTimes.cbegin();\n        for (unsigned int i=0; i<UDP_HASH_SIZE * UDP_HASH_RPP && it != udpSendTrackerTimes.cend(); i++) {\n            telemetryMapDeleteElem(mapFds[UDP_PIDFD_HASH], &it->second);\n            it++;\n        }\n\n        // insert the one we have just received\n\n        // find the last time we sent it\n        lastTime = FindOrEraseUdpPidAddr(pid, p, false);\n        if (lastTime > 0) {\n            // copy to kernel table\n            telemetryMapUpdateElem(mapFds[UDP_ADDRS_HASH], &pa, &lastTime, MAP_UPDATE_CREATE_OR_OVERWRITE);\n        } else {\n            // insert new element\n            telemetryMapUpdateElem(mapFds[UDP_ADDRS_HASH], &pa, &curTime.QuadPart, MAP_UPDATE_CREATE_OR_OVERWRITE);\n            UpdateUdpPidAddr(pid, curTime.QuadPart, p);\n            udpSendTrackerTimes.emplace(curTime.QuadPart, pa);\n        }\n        PurgeUdp(curTime.QuadPart);\n        return (curTime.QuadPart - lastTime > UDP_REPORT_INTERVAL);\n    }\n\n    LONGLONG prevTime = FindOrEraseUdpPidAddr(pid, p, false);\n    if (prevTime > 0) {\n        if (curTime.QuadPart - prevTime > UDP_REPORT_INTERVAL) {\n            // not sent this entry for long enough - update records and send event\n            telemetryMapUpdateElem(mapFds[UDP_ADDRS_HASH], &pa, &curTime.QuadPart, MAP_UPDATE_CREATE_OR_OVERWRITE);\n            lastTime = UpdateUdpPidAddr(pid, curTime.QuadPart, p);\n            udpSendTrackerTimes.erase(lastTime);\n            udpSendTrackerTimes.emplace(curTime.QuadPart, pa);\n            PurgeUdp(curTime.QuadPart);\n            return true;\n        } else {\n            // our local entry is older than the kernel one - update it\n            telemetryMapUpdateElem(mapFds[UDP_ADDRS_HASH], &pa, &prevTime, MAP_UPDATE_CREATE_OR_OVERWRITE);\n            PurgeUdp(curTime.QuadPart);\n            return false;\n        }\n    } else {\n        // we don't have an existing entry\n        UpdateUdpPidAddr(pid, lastTime, p);\n        udpSendTrackerTimes.emplace(lastTime, pa);\n        PurgeUdp(curTime.QuadPart);\n        return true;\n    }\n}\n\n//--------------------------------------------------------------------\n//\n// UdpProgramTermination\n//\n// Purges UDP connection data when a process exits.\n//\n//--------------------------------------------------------------------\nvoid NetworkTracker::UdpProgramTermination(pid_t pid)\n{\n    auto it = udpRecvTrackerPidFds.find(pid);\n    if (it == udpRecvTrackerPidFds.end())\n        // no existing pid entry\n        return;\n\n    auto it2 = it->second.begin();\n    while (it2 != it->second.end()) {\n        LONGLONG lastTime = it2->second.first;\n        auto it3 = udpRecvTrackerTimes.find(lastTime);\n        if (it3 != udpRecvTrackerTimes.end()) {\n            telemetryMapDeleteElem(mapFds[UDP_PIDFD_HASH], &it3->second);\n        }\n        udpRecvTrackerTimes.erase(lastTime);\n        it2 = it->second.erase(it2);\n    }\n\n    udpRecvTrackerPidFds.erase(it);\n\n    auto it4 = udpSendTrackerPidAddrs.find(pid);\n    if (it4 == udpSendTrackerPidAddrs.end())\n        // no existing pid entry\n        return;\n\n    auto it5 = it4->second.begin();\n    while (it5 != it4->second.end()) {\n        LONGLONG lastTime = it5->second;\n        auto it6 = udpSendTrackerTimes.find(lastTime);\n        if (it6 != udpSendTrackerTimes.end()) {\n            telemetryMapDeleteElem(mapFds[UDP_ADDRS_HASH], &it6->second);\n        }\n        udpSendTrackerTimes.erase(lastTime);\n        it5 = it4->second.erase(it5);\n    }\n}\n\n//--------------------------------------------------------------------\n//\n// C wrappers for C++ methods.\n//\n//--------------------------------------------------------------------\nextern \"C\" NetworkTracker *NetworkTrackerInit(LONGLONG staleSeconds, LONGLONG checkSeconds)\n{\n    NetworkTracker *n = new NetworkTracker(staleSeconds, checkSeconds);\n    return n;\n}\n\nextern \"C\" pid_t NetworkTrackerSeenConnect(NetworkTracker *n, PSYSMON_EVENT_HEADER eventHdr)\n{\n    if (n == NULL || eventHdr == NULL) {\n        fprintf(stderr, \"NetworkTrackerSeenConnect invalid params\\n\");\n        return 0;\n    }\n\n    return n->SeenConnect(eventHdr);\n}\n\nextern \"C\" void NetworkTrackerSeenFullAccept(NetworkTracker *n, bool IPv4, const BYTE *sourceAddr,\n        unsigned short sourcePort, const BYTE *destAddr, unsigned short destPort, LONGLONG eventTime)\n{\n    if (n == NULL || sourceAddr == NULL || destAddr == NULL) {\n        fprintf(stderr, \"NetworkTrackerSeenFullAccept invalid params\\n\");\n        return;\n    }\n\n    n->SeenAccept(AddrAndPort(sourceAddr, IPv4, sourcePort), AddrAndPort(destAddr, IPv4, destPort), eventTime);\n}\n\nextern \"C\" bool NetworkTrackerSeenAccept(NetworkTracker *n, bool IPv4, const BYTE *sourceAddr,\n        unsigned short sourcePort, BYTE *destAddr, unsigned short *destPort)\n{\n    if (n == NULL || sourceAddr == NULL || destAddr == NULL) {\n        fprintf(stderr, \"NetworkTrackerSeenAccept invalid params\\n\");\n        return false;\n    }\n\n    BYTE empty[16] = {0};\n    AddrAndPort d(empty, IPv4, 0);\n\n    if (n->SeenAccept(AddrAndPort(sourceAddr, IPv4, sourcePort), &d)) {\n        memcpy(destAddr, d.addr, sizeof(d.addr));\n        *destPort = d.port;\n        return true;\n    }\n    return false;\n}\n\nextern \"C\" void NetworkTrackerCloseAccept(NetworkTracker *n, bool IPv4, const BYTE *sourceAddr,\n        unsigned short sourcePort, const BYTE *destAddr, unsigned short destPort)\n{\n    if (n == NULL || sourceAddr == NULL || destAddr == NULL) {\n        fprintf(stderr, \"NetworkTrackerCloseAccept invalid params\\n\");\n        return;\n    }\n\n    n->CloseAccept(AddrAndPort(sourceAddr, IPv4, sourcePort), AddrAndPort(destAddr, IPv4, destPort));\n}\n\nextern \"C\" bool NetworkTrackerSeenUdpRecv(NetworkTracker *n, bool *IPv4, BYTE *sourceAddr,\n        unsigned short *sourcePort, BYTE *destAddr, unsigned short *destPort, pid_t pid, int fd)\n{\n    if (n == NULL || sourceAddr == NULL || sourcePort == NULL || destAddr == NULL || destPort == NULL) {\n        fprintf(stderr, \"NetworkTrackerSeenUdpRecv invalid params\\n\");\n        return false;\n    }\n\n    PacketAddresses p;\n\n    if (!n->SeenUdp(&p, pid, fd))\n        return false;\n    *IPv4 = p.IPv4;\n    *sourcePort = p.localPort;\n    *destPort = p.remotePort;\n    memcpy(sourceAddr, p.localAddr, sizeof(p.localAddr));\n    memcpy(destAddr, p.remoteAddr, sizeof(p.remoteAddr));\n    return true;\n}\n\nextern \"C\" bool NetworkTrackerSeenUdpSend(NetworkTracker *n, bool IPv4, const BYTE *sourceAddr,\n        unsigned short sourcePort, const BYTE *destAddr, unsigned short destPort, pid_t pid)\n{\n    if (n == NULL || sourceAddr == NULL || destAddr == NULL) {\n        fprintf(stderr, \"NetworkTrackerSeenUdpSend invalid params\\n\");\n        return false;\n    }\n\n    PacketAddresses p(IPv4, sourceAddr, sourcePort, destAddr, destPort);\n\n    return n->SeenUdp(&p, pid);\n}\n\nextern \"C\" void NetworkTrackerUdpProgramTermination(NetworkTracker *n, pid_t pid)\n{\n    if (n == NULL) {\n        fprintf(stderr, \"NetworkTrackerUdpProgramTermination invalid params\\n\");\n        return;\n    }\n\n    n->UdpProgramTermination(pid);\n}\n\n"
        },
        {
          "name": "networkTracker.h",
          "type": "blob",
          "size": 9.5498046875,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// networkTracker.h\n//\n// Supporting classes for networkTracker.cpp\n//\n//====================================================================\n\n#ifndef NETWORK_TRACKER_H\n#define NETWORK_TRACKER_H\n\n#ifdef __cplusplus\n\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\nextern \"C\" {\n#include <libsysinternalsEBPF.h>\n}\n#include \"linuxTypes.h\"\n#include \"ioctlcmd.h\"\n#include \"sysmon_defs.h\"\n\n#define INODE_SOCK_PRE1 \"socket:[\"\n#define INODE_SOCK_PRE2 \"[0000]:\"\n#define PROC_TCP_FNAME \"/proc/net/tcp\"\n#define PROC_TCP6_FNAME \"/proc/net/tcp6\"\n#define PROC_UDP_FNAME \"/proc/net/udp\"\n#define PROC_UDP6_FNAME \"/proc/net/udp6\"\n#define FNV_INIT 0xcbf29ce484222325\n#define FNV_MULT 0x100000001b3\n\n//--------------------------------------------------------------------\n//\n// AddrAndPort\n//\n// Class that represents an IPv4/6 address and port.  Includes a\n// comparison operator.\n//\n//--------------------------------------------------------------------\nclass AddrAndPort\n{\npublic:\n    AddrAndPort(const BYTE *addr_in, bool IPv4, unsigned short port) :\n        IPv4(IPv4), port(port)\n    {\n        if (IPv4) memcpy(addr, addr_in, 4);\n        else memcpy(addr, addr_in, 16);\n    };\n\n    bool operator ==(const AddrAndPort& rhs) const\n    {\n        if (IPv4 != rhs.IPv4) return false;\n        if (IPv4) {\n            return (memcmp(addr, rhs.addr, 4) == 0 && port == rhs.port);\n        }\n        return (memcmp(addr, rhs.addr, 16) == 0 && port == rhs.port);\n    }\n\n    BYTE addr[16];\n    bool IPv4;\n    unsigned short port;\n};\n\n//--------------------------------------------------------------------\n//\n// PacketAddresses\n//\n// Class that represents local and remote IPv4/6 addresses and ports.\n// Includes comparison operators.\n//\n//--------------------------------------------------------------------\nclass PacketAddresses\n{\npublic:\n    PacketAddresses()\n    {\n        IPv4 = true;\n        memset(localAddr, 0, sizeof(localAddr));\n        memset(remoteAddr, 0, sizeof(remoteAddr));\n        localPort = 0;\n        remotePort = 0;\n    }\n\n    PacketAddresses(bool IPv4, const BYTE *localAddrIn, unsigned short localPort,\n            const BYTE *remoteAddrIn, unsigned short remotePort) :\n        IPv4(IPv4), localPort(localPort), remotePort(remotePort)\n    {\n        if (IPv4) {\n            memcpy(localAddr, localAddrIn, 4);\n            memcpy(remoteAddr, remoteAddrIn, 4);\n        } else {\n            memcpy(localAddr, localAddrIn, 16);\n            memcpy(remoteAddr, remoteAddrIn, 16);\n        }\n    };\n\n    bool operator ==(const PacketAddresses& rhs) const\n    {\n        if (IPv4 != rhs.IPv4) return false;\n        if (IPv4) {\n            return (memcmp(localAddr, rhs.localAddr, 4) == 0 &&\n                    localPort == rhs.localPort &&\n                    memcmp(remoteAddr, rhs.remoteAddr, 4) == 0 &&\n                    remotePort == rhs.remotePort);\n        }\n        return (memcmp(localAddr, rhs.localAddr, 16) == 0 &&\n                localPort == rhs.localPort &&\n                memcmp(remoteAddr, rhs.remoteAddr, 16) == 0 &&\n                remotePort == rhs.remotePort);\n    }\n\n    bool operator !=(const PacketAddresses& rhs) const\n    {\n        return !(*this == rhs);\n    }\n\n    bool IPv4;\n    BYTE localAddr[16];\n    BYTE remoteAddr[16];\n    unsigned short localPort, remotePort;\n};\n\nnamespace std {\n\n//--------------------------------------------------------------------\n//\n// hash<AddrAndPort>\n//\n// Hash function for AddrAndPort class allowing it to be used as a\n// map key.\n//\n//--------------------------------------------------------------------\n    template <>\n    struct hash<AddrAndPort>\n    {\n        std::size_t operator()(const AddrAndPort& k) const\n        {\n            // hash using Fowler–Noll–Vo hash function\n            uint64_t hash = FNV_INIT;\n            for (unsigned int i=0; i<16; i++) {\n                hash = hash * FNV_MULT;\n                if (!k.IPv4 || i<4)\n                    hash = hash ^ k.addr[i];\n            }\n            hash = (hash * FNV_MULT) ^ k.IPv4;\n            hash = (hash * FNV_MULT) ^ (k.port >> 8);\n            hash = (hash * FNV_MULT) ^ (k.port & 0xff);\n            return hash;\n        }\n    };\n\n//--------------------------------------------------------------------\n//\n// hash<PacketAddresses>\n//\n// Hash function for PacketAddresses class allowing it to be used as a\n// map key.\n//\n//--------------------------------------------------------------------\n    template <>\n    struct hash<PacketAddresses>\n    {\n        std::size_t operator()(const PacketAddresses& k) const\n        {\n            // hash using Fowler–Noll–Vo hash function\n            uint64_t hash = FNV_INIT;\n            hash = (hash * FNV_MULT) ^ k.IPv4;\n            for (unsigned int i=0; i<16; i++) {\n                hash = hash * FNV_MULT;\n                if (!k.IPv4 || i<4)\n                    hash = hash ^ k.localAddr[i];\n            }\n            for (unsigned int i=0; i<16; i++) {\n                hash = hash * FNV_MULT;\n                if (!k.IPv4 || i<4)\n                    hash = hash ^ k.remoteAddr[i];\n            }\n            hash = (hash * FNV_MULT) ^ (k.localPort >> 8);\n            hash = (hash * FNV_MULT) ^ (k.localPort & 0xff);\n            hash = (hash * FNV_MULT) ^ (k.remotePort >> 8);\n            hash = (hash * FNV_MULT) ^ (k.remotePort & 0xff);\n            return hash;\n        }\n    };\n}\n\n\nclass NetworkTracker\n{\n    // connect tracking\n    std::unordered_map<const void *, std::pair<pid_t, LONGLONG>> connectTracker;\n    std::map<LONGLONG, const void *> connectTrackerTimes;\n\n    // accept tracking\n    std::unordered_map<AddrAndPort, std::pair<AddrAndPort, LONGLONG>> acceptTracker;\n    std::map<LONGLONG, const AddrAndPort *> acceptTrackerTimes;\n\n    // UDP recv tracking\n    std::map<LONGLONG, uint64_t> udpRecvTrackerTimes;\n    std::unordered_map<pid_t, std::unordered_map<int, std::pair<LONGLONG, PacketAddresses>>> udpRecvTrackerPidFds;\n\n    // UDP send tracking\n    std::map<LONGLONG, packetAddrs> udpSendTrackerTimes;\n    std::unordered_map<pid_t, std::unordered_map<PacketAddresses, LONGLONG>> udpSendTrackerPidAddrs;\n\n    // parameters\n    LONGLONG staleDuration, checkDuration; // in 100ns intervals\n    LARGE_INTEGER timeLastChecked; // time we last checked in 100ns intervals from epoch\n\n    void PurgeStale();\n    LONGLONG FindOrEraseUdpPidFd(pid_t pid, int fd, const PacketAddresses *p, bool erase);\n    LONGLONG UpdateUdpPidFd(pid_t pid, int fd, LONGLONG ctime, const PacketAddresses *p);\n    void PurgeUdp(LONGLONG curTime);\n    uint64_t PathToInode(const char *path);\n    bool InodeToAddr(PacketAddresses *p, bool IPv4, uint64_t inodeIn);\n    bool GetUdp(PacketAddresses *p, pid_t pid, int fd);\n    LONGLONG FindOrEraseUdpPidAddr(pid_t pid, const PacketAddresses *p, bool erase);\n    LONGLONG UpdateUdpPidAddr(pid_t pid, LONGLONG ctime, const PacketAddresses *p);\n\npublic:\n\n    NetworkTracker(LONGLONG staleSeconds, LONGLONG checkSeconds);\n    pid_t SeenConnect(PSYSMON_EVENT_HEADER event);\n\n    void SeenAccept(AddrAndPort sourceAddrAndPort, AddrAndPort destAddrAndPort, LONGLONG eventTime);\n    bool SeenAccept(AddrAndPort sourceAddrAndPort, AddrAndPort *destAddrAndPort);\n    void CloseAccept(AddrAndPort sourceAddrAndPort, AddrAndPort destAddrAndPort);\n\n    bool SeenUdp(PacketAddresses *p, pid_t pid, int fd);\n    bool SeenUdp(const PacketAddresses *p, pid_t pid);\n    void UdpProgramTermination(pid_t pid);\n};\n\n#else\nstruct NetworkTracker;\nstruct NetworkTracker *NetworkTrackerInit();\npid_t NetworkTrackerSeenConnect(struct NetworkTracker *n, PSYSMON_EVENT_HEADER eventHdr);\n\nvoid NetworkTrackerSeenFullAccept(struct NetworkTracker *n, bool IPv4, BYTE *sourceAddr, unsigned short sourcePort,\n        BYTE *destAddr, unsigned short destPort, LONGLONG eventTime);\nbool NetworkTrackerSeenAccept(struct NetworkTracker *n, bool IPv4, BYTE *sourceAddr, unsigned short sourcePort,\n        BYTE *destAddr, unsigned short *destPort);\nvoid NetworkTrackerCloseAccept(struct NetworkTracker *n, bool IPv4, BYTE *sourceAddr, unsigned short sourcePort,\n        BYTE *destAddr, unsigned short destPort);\n\nbool NetworkTrackerSeenUdpRecv(struct NetworkTracker *n, bool *IPv4, BYTE *sourceAddr,\n        unsigned short *sourcePort, BYTE *destAddr, unsigned short *destPort, pid_t pid, int fd);\nbool NetworkTrackerSeenUdpSend(struct NetworkTracker *n, bool IPv4, const BYTE *sourceAddr,\n        unsigned short sourcePort, const BYTE *destAddr, unsigned short destPort, pid_t pid);\nvoid NetworkTrackerUdpProgramTermination(struct NetworkTracker *n, pid_t pid);\n#endif\n\n#endif\n\n"
        },
        {
          "name": "outputxml.c",
          "type": "blob",
          "size": 6.6650390625,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// outputxml.c\n//\n// Event output formatting for Syslog\n//\n//====================================================================\n\n#include <libxml/encoding.h>\n#include <libxml/xmlwriter.h>\n#include <assert.h>\n#include <syslog.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n\n#define SYSMON_EVENT_C\n#include \"linuxTypes.h\"\n#include \"sysmonevents.h\"\n#include \"linuxHelpers.h\"\n#include \"sysmon_defs.h\"\n\n#define XML_ENCODING \"ISO-8859-1\"\n\nextern uint64_t *eventIdAddr;\n\n//--------------------------------------------------------------------\n//\n// FormatSyslogString\n//\n// Format an event into an XML string.\n//\n//--------------------------------------------------------------------\nVOID FormatSyslogString(\n    PCHAR                           EventStr,\n    size_t                          EventMax,\n    CONST PSYSMON_EVENT_TYPE_FMT    EventType,\n    CONST EVENT_DATA_DESCRIPTOR*    Fields,\n    unsigned int                    FieldCount\n    )\n{\n    if (EventStr != NULL) {\n        *EventStr = 0x00;\n    }\n\n    if (EventStr == NULL || EventType == NULL || Fields == NULL) {\n        fprintf(stderr, \"FormatSyslogString invalid params\\n\");\n        return;\n    }\n\n    xmlTextWriterPtr writer;\n    xmlBufferPtr buf;\n\n    uint64_t eventId = 0;\n\n    unsigned int index = 0;\n    const char *field = NULL;\n    PCTSTR *fieldNames = NULL;\n    char providerGuid[40];\n    LARGE_INTEGER curTime;\n    char systemTime[32];\n    char hostname[HOST_NAME_MAX + 1];\n\n    if (eventIdAddr != NULL && eventIdAddr != MAP_FAILED) {\n        eventId = (*eventIdAddr)++;\n        msync(eventIdAddr, sizeof(eventId), MS_ASYNC);\n    } else {\n        eventId = 0;\n    }\n\n    assert(StringFromGUID2(SYSMON_PROVIDER, providerGuid, sizeof(providerGuid)) != 0);\n    \n    GetSystemTimeAsLargeInteger(&curTime);\n    LargeIntegerToSystemTimeString(systemTime, 32, &curTime);\n\n    if (gethostname(hostname, HOST_NAME_MAX + 1) < 0) {\n        hostname[0] = 0x00;\n    }\n\n    buf = xmlBufferCreate();\n    assert(buf);\n\n    writer = xmlNewTextWriterMemory(buf, 0);\n    assert(writer);\n\n    assert(xmlTextWriterStartElement(writer, (const xmlChar*)\"Event\") >= 0);\n\n    assert(xmlTextWriterStartElement(writer, (const xmlChar*)\"System\") >= 0);\n\n    assert(xmlTextWriterStartElement(writer, (const xmlChar*)\"Provider\") >= 0);\n    assert(xmlTextWriterWriteAttribute(writer, (const xmlChar*)\"Name\", (const xmlChar*)\"Linux-Sysmon\") >= 0);\n    assert(xmlTextWriterWriteAttribute(writer, (const xmlChar*)\"Guid\", (const xmlChar*)providerGuid) >= 0);\n    assert(xmlTextWriterEndElement(writer) >= 0);\n\n    assert(xmlTextWriterWriteFormatElement(writer, (const xmlChar*)\"EventID\", \"%d\",\n            EventType->EventDescriptor->Id) >= 0);\n    assert(xmlTextWriterWriteFormatElement(writer, (const xmlChar*)\"Version\", \"%d\",\n            EventType->EventDescriptor->Version) >= 0);\n    assert(xmlTextWriterWriteFormatElement(writer, (const xmlChar*)\"Level\", \"%d\",\n            EventType->EventDescriptor->Level) >= 0);\n    assert(xmlTextWriterWriteFormatElement(writer, (const xmlChar*)\"Task\", \"%d\",\n            EventType->EventDescriptor->Task) >= 0);\n    assert(xmlTextWriterWriteFormatElement(writer, (const xmlChar*)\"Opcode\", \"%d\",\n            EventType->EventDescriptor->Opcode) >= 0);\n    assert(xmlTextWriterWriteFormatElement(writer, (const xmlChar*)\"Keywords\", \"0x%lx\",\n            EventType->EventDescriptor->Keyword) >= 0);\n\n    assert(xmlTextWriterStartElement(writer, (const xmlChar*)\"TimeCreated\") >= 0);\n    assert(xmlTextWriterWriteAttribute(writer, (const xmlChar*)\"SystemTime\", (const xmlChar*)systemTime) >= 0);\n    assert(xmlTextWriterEndElement(writer) >= 0);\n\n    assert(xmlTextWriterWriteFormatElement(writer, (const xmlChar*)\"EventRecordID\", \"%lu\", eventId) >= 0);\n\n    assert(xmlTextWriterStartElement(writer, (const xmlChar*)\"Correlation\") >= 0);\n    assert(xmlTextWriterEndElement(writer) >= 0);\n\n    assert(xmlTextWriterStartElement(writer, (const xmlChar*)\"Execution\") >= 0);\n    assert(xmlTextWriterWriteFormatAttribute(writer, (const xmlChar*)\"ProcessID\", \"%d\", getpid()) >= 0);\n    assert(xmlTextWriterWriteFormatAttribute(writer, (const xmlChar*)\"ThreadID\", \"%d\", GetTid()) >= 0);\n    assert(xmlTextWriterEndElement(writer) >= 0);\n\n    assert(xmlTextWriterWriteElement(writer, (const xmlChar*)\"Channel\", (const xmlChar*)\"Linux-Sysmon/Operational\") >= 0);\n    assert(xmlTextWriterWriteElement(writer, (const xmlChar*)\"Computer\", (const xmlChar*)hostname) >= 0);\n\n    assert(xmlTextWriterStartElement(writer, (const xmlChar*)\"Security\") >= 0);\n    assert(xmlTextWriterWriteFormatAttribute(writer, (const xmlChar*)\"UserId\", \"%d\", geteuid()) >= 0);\n    assert(xmlTextWriterEndElement(writer) >= 0);\n\n    assert(xmlTextWriterEndElement(writer) >= 0); // end of System\n    assert(xmlTextWriterStartElement(writer, (const xmlChar*)\"EventData\") >= 0);\n\n    fieldNames = (PCTSTR *)EventType->FieldNames;\n    for( index = 0; index < FieldCount; index++ ) {\n\n        field = (const char *)Fields[index].Ptr;\n        assert(xmlTextWriterStartElement(writer, (const xmlChar*)\"Data\") >= 0);\n        assert(xmlTextWriterWriteAttribute(writer, (const xmlChar*)\"Name\", (const xmlChar*)fieldNames[index]) >= 0);\n        assert(xmlTextWriterWriteFormatString(writer, \"%s\",\n                field != NULL ? field : \"\") >= 0);\n        assert(xmlTextWriterEndElement(writer) >= 0);\n    }\n    assert(xmlTextWriterEndElement(writer) >= 0); // end of EventData\n    assert(xmlTextWriterEndElement(writer) >= 0); // end of Event\n    xmlFreeTextWriter(writer);\n    snprintf(EventStr, EventMax, \"%s\", buf->content);\n    xmlBufferFree(buf);\n}\n\n\n"
        },
        {
          "name": "outputxml.h",
          "type": "blob",
          "size": 1.6015625,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// outputxml.h\n//\n// Functions exported by outputxml.c\n//\n//====================================================================\n\n#ifndef _OUTPUTXML_H\n#define _OUTPUTXML_H\n\n#include \"linuxTypes.h\"\n#include \"sysmonevents.h\"\n\nVOID FormatSyslogString(\n    PCHAR EventStr,\n    size_t EventMax,\n    CONST PSYSMON_EVENT_TYPE_FMT EventType,\n    CONST EVENT_DATA_DESCRIPTOR* Fields,\n    unsigned int FieldCount\n    );\n\n#endif\n"
        },
        {
          "name": "package",
          "type": "tree",
          "content": null
        },
        {
          "name": "perftest",
          "type": "tree",
          "content": null
        },
        {
          "name": "sysmon.d",
          "type": "blob",
          "size": 1.8857421875,
          "content": "#!/bin/sh\n\n#    SysmonForLinux\n#\n#    Copyright (c) Microsoft Corporation\n#\n#    All rights reserved.\n#\n#    MIT License\n#\n#    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n#\n#    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n#    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n\nset -e\n. /lib/lsb/init-functions\n\nstart() {\n    printf \"Starting sysmon...\"\n    start-stop-daemon --start --chuid \"root:root\" --background --make-pidfile --pidfile /var/run/sysmon.pid --chdir \"/opt/sysmon\" --exec \"/opt/sysmon/sysmon\" -- -i /opt/sysmon/config.xml -service\n    printf \"done\\n\"\n}\n\nstop() {\n    printf \"Stopping sysmon...\"\n    kill `cat /var/run/sysmon.pid`\n    sleep 1\n    if [ -d /proc/`cat /var/run/sysmon.pid` ]; then\n        kill -9 `cat /var/run/sysmon.pid`\n    fi\n    rm /var/run/sysmon.pid\n    printf \"done\\n\"\n}\n\ncase \"$1\" in\n    start)\n        start\n        ;;\n    stop)\n        stop\n        ;;\n    restart)\n        stop\n        start\n        ;;\n    *)\n        echo \"Usage: sysmon {start|stop|restart}\"\n        exit 1\n        ;;\nesac\n\nexit 0\n\n"
        },
        {
          "name": "sysmon.gif",
          "type": "blob",
          "size": 3951.18359375,
          "content": null
        },
        {
          "name": "sysmon.service",
          "type": "blob",
          "size": 1.421875,
          "content": "#    SysmonForLinux\n#\n#    Copyright (c) Microsoft Corporation\n#\n#    All rights reserved.\n#\n#    MIT License\n#\n#    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n#\n#    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n#    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n\n[Unit]\nDescription=Sysmon event logger\nAfter=syslog.service\nStartLimitBurst=5\nStartLimitIntervalSec=90\n\n[Service]\nType=forking\nUser=root\nWorkingDirectory=/opt/sysmon\nExecStart=/opt/sysmon/sysmon -i /opt/sysmon/config.xml -service\nRestart=on-failure\nRestartSec=10\n\n[Install]\nWantedBy=multi-user.target\n"
        },
        {
          "name": "sysmonCommon",
          "type": "commit",
          "content": null
        },
        {
          "name": "sysmonLogView",
          "type": "tree",
          "content": null
        },
        {
          "name": "sysmon_defs.h",
          "type": "blob",
          "size": 4.5458984375,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// sysmon_defs.h\n//\n// Defines and types needed by Sysmon for Linux.\n//\n//====================================================================\n\n#ifndef SYSMON_DEFS_H\n#define SYSMON_DEFS_H\n\n#include <linux/limits.h>\n#include \"linuxTypes.h\"\n#include \"sysmonmsgop.h\"\n#include \"ioctlcmd.h\"\n\n#define SYSMON_UMASK            077\n\n#define SYSMON_INSTALL_DIR      \"/opt/sysmon\"\n#define SYSMON_EULA_FILE        SYSMON_INSTALL_DIR \"/eula_accepted\"\n#define EVENTID_FILE            SYSMON_INSTALL_DIR \"/eventId\"\n#define SYSMON_CONFIG_FILE      SYSMON_INSTALL_DIR \"/config.xml\"\n#define SYSMON_RULES_FILE       SYSMON_INSTALL_DIR \"/rules.bin\"\n#define SYSMON_ARGC_FILE        SYSMON_INSTALL_DIR \"/argc\"\n#define SYSMON_ARGV_FILE        SYSMON_INSTALL_DIR \"/argv\"\n#define SYSMON_FIELDSIZES_FILE  SYSMON_INSTALL_DIR \"/fieldSizes\"\n\n#define SYSMON_EBPF_DIR         \"sysinternalsEBPF\"\n#define PROC_EXE_PATH           \"/proc/self/exe\"\n#define PROC_STAT_PATH          \"/proc/self/stat\"\n#define PROC_EXE_PATH_FMT       \"/proc/%d/exe\"\n#define SYSMON_BINARY           \"sysmon\"\n#define EBPFLIB                 \"libsysinternalsEBPF.so\"\n#define MEM_DUMP_OBJ            \"sysinternalsEBPFmemDump.o\"\n#define RAW_SOCK_OBJ            \"sysinternalsEBPFrawSock.o\"\n#define KERN_4_15_OBJ           \"sysmonEBPFkern4.15.o\"\n#define KERN_4_16_OBJ           \"sysmonEBPFkern4.16.o\"\n#define KERN_4_17_5_1_OBJ       \"sysmonEBPFkern4.17-5.1.o\"\n#define KERN_5_2_OBJ            \"sysmonEBPFkern5.2.o\"\n#define KERN_5_3_5_5_OBJ        \"sysmonEBPFkern5.3-5.5.o\"\n#define KERN_5_6__OBJ           \"sysmonEBPFkern5.6-.o\"\n#define KERN_4_15_CORE_OBJ      \"sysmonEBPFkern4.15_core.o\"\n#define KERN_4_16_CORE_OBJ      \"sysmonEBPFkern4.16_core.o\"\n#define KERN_4_17_5_1_CORE_OBJ  \"sysmonEBPFkern4.17-5.1_core.o\"\n#define KERN_5_2_CORE_OBJ       \"sysmonEBPFkern5.2_core.o\"\n#define KERN_5_3_5_5_CORE_OBJ   \"sysmonEBPFkern5.3-5.5_core.o\"\n#define KERN_5_6__CORE_OBJ       \"sysmonEBPFkern5.6-_core.o\"\n\n#define KERN_NUM_PROGRAMS       6\n\n#define SYSMONLOGVIEW_BINARY    \"sysmonLogView\"\n#define SYSTEMD_DIR             \"/etc/systemd/system\"\n#define SYSTEMD_SERVICE         \"sysmon.service\"\n#define SYSTEMD_RELOAD_CMD      \"systemctl daemon-reload\"\n#define SYSTEMD_START_CMD       \"systemctl start\"\n#define SYSTEMD_STOP_CMD        \"systemctl stop\"\n#define SYSTEMD_ENABLE_CMD      \"systemctl enable\"\n#define SYSTEMD_DISABLE_CMD     \"systemctl disable\"\n#define INITD_DIR               \"/etc/init.d\"\n#define INITD_SERVICE           \"sysmon\"\n#define INITD_DIR_FMT           \"/etc/rc%d.d\"\n#define INITD_START_ID          \"S99\"\n#define INITD_KILL_ID           \"K99\"\n\n#define UDP_REPORT_INTERVAL     (30L * 60 * 1000 * 1000 * 10) // 30 minutes in 100ns intervals\n#define UDP_HASH_SIZE           (128 * 1024)\n#define UDP_HASH_RPP            0.1 // rapid purge proportion - volume of observations to remove\n#define UDP_PIDFD_HASH          0\n#define UDP_ADDRS_HASH          1\n\n#define PACKET_SIZE             128\n#define PACKET_MASK             (PACKET_SIZE - 1)\n\n#define PROTO_IPV4              0x0800\n#define PROTO_IPV6              0x86DD\n#define PROTO_UDP               0x11\n\n// return values\n#define READ_OKAY               0\n#define UPDATE_OKAY             0\n\ntypedef struct {\n    bool                        IPv4;\n    BYTE                        srcAddr[16];\n    unsigned short              srcPort;\n    BYTE                        dstAddr[16];\n    unsigned short              dstPort;\n} packetAddrs;\n\n#endif\n"
        },
        {
          "name": "sysmonforlinux.c",
          "type": "blob",
          "size": 52.9736328125,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    MIT License\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//====================================================================\n//\n// SysmonForLinux.c\n//\n// Implements the main function and event handler for Sysmon For\n// Linux.\n//\n//====================================================================\n\n#include <libxml/parser.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <linux/stat.h>\n#include <fcntl.h>\n#include <string.h>\n#include <time.h>\n#include <math.h>\n#include <syslog.h>\n#include <signal.h>\n#include <semaphore.h>\n#include <dirent.h>\n#include <sys/mman.h>\n#include <asm/unistd.h>\n#include <dlfcn.h>\n#include <libsysinternalsEBPF.h>\n#include <sysinternalsEBPFshared.h>\n#include \"stdafx.h\"\n#include \"rules.h\"\n#include \"xml.h\"\n#include \"linuxHelpers.h\"\n#include \"sysmon_defs.h\"\n#include \"linuxVersion.h\"\n#include \"networkTracker.h\"\n#include \"installer.h\"\n\n#include \"missingdefs.h\"\n\n#define EVENT_BUFFER_SIZE (49 * 1024)\n\n#define BTF_KERNEL_FILE \"/sys/kernel/btf/vmlinux\"\n\n#define STARTUP_SEM_NAME \"/sysmon-startup\"\n\nunsigned long           totalEvents = 0;\nunsigned long           badEvents = 0;\nunsigned int            numLostNotifications = 0;\nunsigned long           numLostEvents = 0;\n\nPTCHAR                  configFile = NULL;\nsem_t                   *startupSem = NULL;\n\nstruct NetworkTracker   *NetworkState;\nint                     eventIdFd = 0;\nuint64_t                *eventIdAddr = MAP_FAILED;\n\ndouble                  g_bootSecSinceEpoch = 0;\nBOOLEAN                 g_DebugMode = FALSE;\nBOOLEAN                 g_DebugModeVerbose = FALSE;\nCRITICAL_SECTION        g_DebugModePrintCriticalSection;\nchar*                   btfPath;\n\ntypedef TCHAR _bstr_t;\n\nbool CreateNetworkEvent( DWORD processId, DWORD threadId, EVENT_TYPE_NETWORK type, bool isTcp,\n                        LARGE_INTEGER timestamp, ULONGLONG duration, DWORD length,\n                        bool srcIsIpV4, const BYTE * srcAddr, WORD srcPort,\n                        bool dstIsIpV4, const BYTE * dstAddr, WORD dstPort,\n                        const void * const stackEntries[], DWORD stackCnt,\n                        const _bstr_t *details );\n\n//--------------------------------------------------------------------\n//\n// const EBPF Config\n//\n//--------------------------------------------------------------------\n\nconst char                      *defPaths[] =\n    {\"./\", \"./sysmonEBPF\", \"/opt/sysmon/\", \"/opt/sysmon/sysmonEBPF\"};\n\nconst ebpfSyscallTPprog         TPenterProgs[] =\n{   {EBPF_GENERIC_SYSCALL, \"genericEnterN\"}\n};\n\nconst ebpfSyscallTPprog         TPexitProgs[] =\n{   {__NR_execve, \"ProcCreateExit\"},\n    {__NR_execveat, \"ProcCreateExit\"},\n    {__NR_creat, \"FileCreateExit\"},\n    {__NR_open, \"FileOpenExit\"},\n    {__NR_openat, \"FileOpenExit\"},\n    {__NR_unlink, \"FileDeleteExit\"},\n    {__NR_unlinkat, \"FileDeleteAtExit\"},\n    {__NR_unlinkat, \"FileDeleteAtCwdExit\"},\n    {__NR_accept, \"TCPacceptExit\"},\n    {__NR_accept4, \"TCPacceptExit\"},\n    {__NR_ptrace, \"ProcAccessedExit\"},\n    {__NR_recvfrom, \"UDPrecvExit\"},\n    {__NR_recvmsg, \"UDPrecvExit\"},\n    {__NR_recvmmsg, \"UDPrecvExit\"},\n    {__NR_read, \"UDPrecvExit\"},\n    {__NR_close, \"CloseFDExit\"}\n};\n\nconst ebpfSyscallRTPprog        RTPenterProgs[] =\n{\n    {\"genericRawEnter\", EBPF_GENERIC_SYSCALL}\n};\n\nconst ebpfSyscallRTPprog        RTPexitProgs[] =\n{\n    {\"ProcCreateRawExit\", __NR_execve},\n    {\"ProcCreateRawExit\", __NR_execveat},\n    {\"FileCreateRawExit\", __NR_creat},\n    {\"FileOpenRawExit\", __NR_open},\n    {\"FileOpenRawExit\", __NR_openat},\n    {\"FileOpenRawExit\", __NR_RAWACCESS},\n    {\"FileOpenRawExit\", __NR_CREATE},\n    {\"FileDeleteRawExit\", __NR_unlink},\n    {\"FileDeleteAtRawExit\", __NR_unlinkat},\n    {\"FileDeleteAtCwdRawExit\", __NR_unlinkat},\n    {\"TCPacceptRawExit\", __NR_accept},\n    {\"TCPacceptRawExit\", __NR_accept4},\n    {\"TCPacceptRawExit\", __NR_NETWORK},\n    {\"ProcAccessedRawExit\", __NR_ptrace},\n    {\"UDPrecvRawExit\", __NR_recvfrom},\n    {\"UDPrecvRawExit\", __NR_recvmsg},\n    {\"UDPrecvRawExit\", __NR_recvmmsg},\n    {\"UDPrecvRawExit\", __NR_read},\n    {\"CloseFDRawExit\", __NR_close}\n};\n\nconst ebpfTracepointProg        otherTPprogs4_15[] =\n{\n    {\"sched\", \"sched_process_exit\", \"ProcTerminated\", __NR_PROCTERM},\n    {\"tcp\", \"tcp_set_state\", \"TCPconnectionOld\", __NR_NETWORK},\n    {\"skb\", \"consume_skb\", \"UDPsend\", __NR_NETWORK}\n};\n\nconst ebpfTracepointProg        otherTPprogs4_16[] =\n{\n    {\"sched\", \"sched_process_exit\", \"ProcTerminated\", __NR_PROCTERM},\n    {\"sock\", \"inet_sock_set_state\", \"TCPconnection\", __NR_NETWORK},\n    {\"skb\", \"consume_skb\", \"UDPsend\", __NR_NETWORK}\n};\n\nconst ebpfTelemetryMapObject    mapObjects[] =\n{\n    {\"UDPrecvAge\", 0, NULL, NULL},\n    {\"UDPsendAge\", 0, NULL, NULL}\n};\n\n// this holds the FDs for the above maps\nint mapFds[sizeof(mapObjects) / sizeof(*mapObjects)];\n\n//--------------------------------------------------------------------\n//\n// syslogHelper\n//\n// In production, this is a wrapper for syslog().\n// In testing, the test harness will provide an implementation such\n// that messages destined for syslog() are intercepted instead.\n//\n//--------------------------------------------------------------------\nVOID syslogHelper( int priority, const char* fmt, const char *msg )\n{\n    if (fmt == NULL || msg == NULL) {\n        fprintf(stderr, \"syslogHelper invalid params\\n\");\n        return;\n    }\n\n    syslog( priority, fmt, msg );\n}\n\n//--------------------------------------------------------------------\n//\n// telemetryReady\n//\n// Callback from loader library to indicate that it has started up.\n//\n//--------------------------------------------------------------------\nvoid telemetryReady()\n{\n    if( OPT_SET( ConfigDefault ) ) {\n        SendConfigEvent( \"Defaults\", NULL );\n    } else if( configFile ) {\n        SendConfigEvent( configFile, NULL );\n    } else {\n        SendConfigEvent( GetCommandLine(), NULL );\n    }\n\n    SendStateEvent(\"Started\", STRFILEVER);\n    sem_post(startupSem);\n}\n\n//--------------------------------------------------------------------\n//\n// isSimilarTime\n//\n// Compares a LARGE_INTEGER time (in 100ns increments from epoch)\n// against a statx_timestamp (tv_sec and tv_nsec since epoch)\n//\n//--------------------------------------------------------------------\nbool isSimilarTime(CONST PLARGE_INTEGER cur, CONST my_statx_timestamp *test)\n{\n    if (cur == NULL || test == NULL) {\n        fprintf(stderr, \"isSimilarTime invalid params\\n\");\n        return false;\n    }\n\n    LARGE_INTEGER testLargeTime;\n\n    LinuxFileTimeToLargeInteger(&testLargeTime, test);\n\n    if (llabs(cur->QuadPart - testLargeTime.QuadPart) < (10 * 1000 * 100)) // 100ms\n        return true;\n    return false;\n}\n\n//--------------------------------------------------------------------\n//\n// processFileOpen\n//\n// Handles file open events\n//\n//--------------------------------------------------------------------\nvoid processFileOpen(CONST PSYSMON_EVENT_HEADER eventHdr)\n{\n    if (eventHdr == NULL) {\n        fprintf(stderr, \"processFileOpen invalid params\\n\");\n        return;\n    }\n\n    char newData[65536];\n\n    PSYSMON_EVENT_HEADER newEventHdr = (PSYSMON_EVENT_HEADER)newData;\n    newEventHdr->m_FieldFiltered = 0;\n    newEventHdr->m_PreFiltered = 0;\n    newEventHdr->m_SequenceNumber = 0;\n    newEventHdr->m_SessionId = 0;\n    PSYSMON_LINUX_FILE_OPEN event = (PSYSMON_LINUX_FILE_OPEN)&(eventHdr->m_EventBody);\n\n    if (event->m_Flags & O_CREAT &&\n            (event->m_Mode & S_IFMT) == S_IFREG // regular file create\n    ) {\n        // file create event\n        newEventHdr->m_EventType = FileCreate;\n        PSYSMON_FILE_CREATE newEvent = &newEventHdr->m_EventBody.m_FileCreateEvent;\n        newEvent->m_ProcessId = event->m_ProcessId;\n        newEvent->m_EventTime.QuadPart = event->m_EventTime.QuadPart;\n        newEvent->m_CreateTime.QuadPart = event->m_EventTime.QuadPart;\n        newEvent->m_hashType = 0;\n        newEvent->m_filehash[0] = 0x00;\n        memset(newEvent->m_Extensions, 0, sizeof(newEvent->m_Extensions));\n        const char *ptr = (char *)(event + 1);\n        char *newPtr = (char *)(newEvent + 1);\n\n        memcpy(newPtr, ptr, event->m_Extensions[LINUX_FO_Sid]);\n        newEvent->m_Extensions[FC_Sid] = event->m_Extensions[LINUX_FO_Sid];\n        ptr += event->m_Extensions[LINUX_FO_Sid];\n        newPtr += event->m_Extensions[LINUX_FO_Sid];\n\n        strcpy(newPtr, ptr);\n        newEvent->m_Extensions[FC_ImagePath] = event->m_Extensions[LINUX_FO_ImagePath];\n        ptr += event->m_Extensions[LINUX_FO_ImagePath];\n        newPtr += event->m_Extensions[LINUX_FO_ImagePath];\n\n        strcpy(newPtr, ptr);\n        newEvent->m_Extensions[FC_FileName] = event->m_Extensions[LINUX_FO_PathName];\n        newPtr += event->m_Extensions[LINUX_FO_PathName];\n\n        newEventHdr->m_EventSize = (uint32_t)((void *)newPtr - (void *)newEventHdr);\n\n        DispatchEvent(newEventHdr);\n    } else if ((event->m_Mode & S_IFMT) == S_IFBLK) { // block device\n        newEventHdr->m_EventType = RawAccessRead;\n        PSYSMON_RAWACCESS_READ newEvent = &newEventHdr->m_EventBody.m_RawAccessRead;\n        newEvent->m_EventSystemTime.QuadPart = event->m_EventTime.QuadPart;\n        newEvent->m_ProcessId = event->m_ProcessId;\n        memset(newEvent->m_Extensions, 0, sizeof(newEvent->m_Extensions));\n        const char *ptr = (char *)(event + 1);\n        char *newPtr = (char *)(newEvent + 1);\n\n        memcpy(newPtr, ptr, event->m_Extensions[LINUX_FO_Sid]);\n        newEvent->m_Extensions[RR_Sid] = event->m_Extensions[LINUX_FO_Sid];\n        ptr += event->m_Extensions[LINUX_FO_Sid];\n        newPtr += event->m_Extensions[LINUX_FO_Sid];\n\n        ptr += event->m_Extensions[LINUX_FO_ImagePath];\n\n        strncpy(newEvent->m_Device, ptr, sizeof(newEvent->m_Device));\n        newEvent->m_Device[sizeof(newEvent->m_Device)-1] = 0;\n\n        newEventHdr->m_EventSize = (uint32_t)((void *)newPtr - (void *)newEventHdr);\n\n        DispatchEvent(newEventHdr);\n    }\n}\n\n//--------------------------------------------------------------------\n//\n// processNetworkEvent\n//\n// Handles file open events\n//\n//--------------------------------------------------------------------\nvoid processNetworkEvent(CONST PSYSMON_EVENT_HEADER eventHdr)\n{\n    if (eventHdr == NULL) {\n        fprintf(stderr, \"processNetworkEvent invalid params\\n\");\n        return;\n    }\n\n    EVENT_TYPE_NETWORK type;\n    pid_t pid = 0;\n    BYTE sourceAddr[16];\n    unsigned short sourcePort;\n    BYTE destAddr[16];\n    unsigned short destPort;\n    bool IPv4 = true;\n\n    PSYSMON_LINUX_NETWORK_EVENT event = (PSYSMON_LINUX_NETWORK_EVENT) &eventHdr->m_EventBody;\n    if (event->m_IsTCP) {\n        if (event->m_OldState == TCP_SYN_RECV && event->m_NewState == TCP_ESTABLISHED) {\n            NetworkTrackerSeenFullAccept(NetworkState, event->m_AddrIsIPv4, event->m_DstAddr, event->m_DstPort,\n                    event->m_SrcAddr, event->m_SrcPort, event->m_EventTime.QuadPart);\n        } else if (event->m_OldState == TCP_LISTEN && event->m_NewState == TCP_ESTABLISHED) {\n            if (NetworkTrackerSeenAccept(NetworkState, event->m_AddrIsIPv4, event->m_SrcAddr, event->m_SrcPort,\n                    destAddr, &destPort)) {\n                pid = event->m_ProcessId;\n            }\n        } else if (event->m_OldState == TCP_SYN_RECV && event->m_NewState == TCP_CLOSE) {\n            NetworkTrackerCloseAccept(NetworkState, event->m_AddrIsIPv4, event->m_DstAddr, event->m_DstPort,\n                    event->m_SrcAddr, event->m_SrcPort);\n        } else {\n            pid = NetworkTrackerSeenConnect(NetworkState, eventHdr);\n            memcpy(destAddr, event->m_DstAddr, 16);\n            destPort = event->m_DstPort;\n        }\n\n        if (pid != 0) {\n            switch (event->m_OldState) {\n                case TCP_SYN_SENT:\n                    type = EVENT_TYPE_NETWORK_CONNECT;\n                    break;\n                case TCP_ESTABLISHED:\n                    type = EVENT_TYPE_NETWORK_ACCEPT;\n                    break;\n                default:\n                    type = EVENT_TYPE_NETWORK_UNKNOWN;\n            }\n\n            CreateNetworkEvent( pid, 0, type, true, event->m_EventTime,\n                    0, 0,\n                    event->m_AddrIsIPv4, event->m_SrcAddr, event->m_SrcPort,\n                    event->m_AddrIsIPv4, destAddr, destPort,\n                    NULL, 0, NULL );\n        }\n    } else {\n        int fd = (int)(long)event->m_SockId;\n        if (fd == 0) {\n            // send\n            type = EVENT_TYPE_NETWORK_CONNECT;\n            if (NetworkTrackerSeenUdpSend(NetworkState, event->m_AddrIsIPv4, event->m_SrcAddr, event->m_SrcPort,\n                    event->m_DstAddr, event->m_DstPort, event->m_ProcessId)) {\n                CreateNetworkEvent( event->m_ProcessId, 0, type, false, event->m_EventTime,\n                        0, 0,\n                        event->m_AddrIsIPv4, event->m_SrcAddr, event->m_SrcPort,\n                        event->m_AddrIsIPv4, event->m_DstAddr, event->m_DstPort,\n                        NULL, 0, NULL );\n            }\n        } else {\n            // recv\n            type = EVENT_TYPE_NETWORK_ACCEPT;\n            if (NetworkTrackerSeenUdpRecv(NetworkState, &IPv4, destAddr, &destPort, sourceAddr, &sourcePort,\n                    event->m_ProcessId, fd)) {\n                CreateNetworkEvent( event->m_ProcessId, 0, type, false, event->m_EventTime,\n                        0, 0,\n                        IPv4, sourceAddr, sourcePort,\n                        IPv4, destAddr, destPort,\n                        NULL, 0, NULL );\n            }\n        }\n    }\n}\n\n//--------------------------------------------------------------------\n//\n// getPidFromTid\n//\n// Gets the process ID for a thread ID\n//\n//--------------------------------------------------------------------\npid_t getPidFromTid(pid_t tid)\n{\n    DIR                         *d, *d2;\n    struct dirent               *dir, *dir2;\n    struct stat                 stStat;\n    char                        pidfilepath[PATH_MAX];\n    char                        taskfilepath[PATH_MAX];\n    pid_t                       pid;\n\n    snprintf(pidfilepath, sizeof(pidfilepath), \"/proc/%d\", tid);\n    //\n    // if /proc/TID exists, then the PID == TID\n    //\n    if (stat(pidfilepath, &stStat) == 0) {\n        return tid;\n    }\n\n    d = opendir(\"/proc\");\n    if (d) {\n        while ((dir = readdir(d)) != NULL) {\n            if (!StrIsNum(dir->d_name))\n                continue;\n            pid = atoi(dir->d_name);\n            snprintf(taskfilepath, sizeof(taskfilepath), \"/proc/%d/task\", pid);\n            d2 = opendir(taskfilepath);\n            if (d2) {\n                while ((dir2 = readdir(d2)) != NULL) {\n                    if (!StrIsNum(dir2->d_name))\n                        continue;\n                    if (atoi(dir2->d_name) == tid) {\n                        closedir(d2);\n                        closedir(d);\n                        return pid;\n                    }\n                }\n                closedir(d2);\n            }\n        }\n        closedir(d);\n    }\n    return -1;\n}\n\n//--------------------------------------------------------------------\n//\n// processProcessAccess\n//\n// Handles process access events\n//\n//--------------------------------------------------------------------\nvoid processProcessAccess(CONST PSYSMON_EVENT_HEADER eventHdr)\n{\n    if (eventHdr == NULL) {\n        fprintf(stderr, \"processProcessAccess invalid params\\n\");\n        return;\n    }\n\n    char newData[65536];\n    pid_t pid;\n    char exePath[PATH_MAX];\n    ssize_t linkSize = 0;\n    const char *ptr = NULL;\n    char *newPtr = NULL;\n    PSYSMON_PROCESS_ACCESS event = &eventHdr->m_EventBody.m_ProcessAccessEvent;\n    PSYSMON_EVENT_HEADER newEventHdr = (PSYSMON_EVENT_HEADER)newData;\n    PSYSMON_PROCESS_ACCESS newEvent = NULL;\n    struct stat st;\n    char pathFile[32];\n\n    pid = getPidFromTid(event->m_TargetPid);\n    //\n    // if we cannot identify the PID from the target TID, just dispatch as is\n    //\n    if (pid < 0) {\n        DispatchEvent(eventHdr);\n        return;\n    }\n\n    //\n    // attempt to fill-in the target TID's image path, from the discovered PID;\n    // we cannot edit the existing event so we make a copy to modify.\n    // Extensions are variable length and follow the event body, so use the\n    // largest buffer possible temporarily.\n    //\n    memcpy(newData, eventHdr, eventHdr->m_EventSize);\n    newEvent = &newEventHdr->m_EventBody.m_ProcessAccessEvent;\n    ptr = (char *)(event + 1);\n    newPtr = (char *)(newEvent + 1);\n\n    //\n    // move pointer beyond existing client image path\n    //\n    ptr += event->m_Extensions[PA_ClientImage];\n    newPtr += newEvent->m_Extensions[PA_ClientImage];\n\n    //\n    // retrive path pointed to by process' exe link\n    //\n    snprintf(exePath, sizeof(exePath), \"/proc/%d/exe\", pid);\n    linkSize = readlink(exePath, newPtr, PATH_MAX);\n\n    //\n    // check for success\n    //\n    if (linkSize >= 0) {\n        //\n        // null-terminate path and store length in extensions array\n        //\n        newPtr[linkSize] = 0x00;\n        newEvent->m_Extensions[PA_TargetImage] = linkSize + 1;\n        newPtr += newEvent->m_Extensions[PA_TargetImage];\n    }\n\n    //\n    // copy in SidSource\n    //\n    *(uint64_t *)newPtr = *(uint64_t *)ptr & 0xFFFFFFFF;\n    newEvent->m_Extensions[PA_SidSource] = sizeof(uint64_t);\n    newPtr += newEvent->m_Extensions[PA_SidSource];\n\n    //\n    // retrieve SidTarget\n    //\n    snprintf(pathFile, 32, \"/proc/%d\", pid);\n    if (stat(pathFile, &st) == 0) {\n        *(uint64_t *)newPtr = st.st_uid;\n        newEvent->m_Extensions[PA_SidTarget] = sizeof(uint64_t);\n        newPtr += sizeof(uint64_t);\n    }\n\n    //\n    // calculate new event size and dispath\n    //\n    newEventHdr->m_EventSize = (uint32_t)((void *)newPtr - (void *)newEventHdr);\n    DispatchEvent(newEventHdr);\n}\n\n//--------------------------------------------------------------------\n//\n// processProcessCreate\n//\n// Handles process create events\n//\n//--------------------------------------------------------------------\nvoid processProcessCreate(CONST PSYSMON_EVENT_HEADER eventHdr)\n{\n    if(eventHdr == NULL) {\n        fprintf(stderr, \"processProcessCreate invalid params\\n\");\n        return;\n    }\n\n    char newData[65536];\n\n    PSYSMON_EVENT_HEADER newEventHdr = (PSYSMON_EVENT_HEADER)newData;\n    newEventHdr->m_FieldFiltered = 0;\n    newEventHdr->m_PreFiltered = 0;\n    newEventHdr->m_SequenceNumber = 0;\n    newEventHdr->m_SessionId = 0;\n\n    PSYSMON_PROCESS_CREATE event = (PSYSMON_PROCESS_CREATE)&(eventHdr->m_EventBody);\n\n    newEventHdr->m_EventType = ProcessCreate;\n    PSYSMON_PROCESS_CREATE newEvent = &newEventHdr->m_EventBody.m_ProcessCreateEvent;\n    newEvent->m_ProcessId = event->m_ProcessId;\n    newEvent->m_ProcessObject = event->m_ProcessObject;\n    newEvent->m_ParentProcessObject = event->m_ParentProcessObject;\n    newEvent->m_ParentProcessId = event->m_ParentProcessId;\n    newEvent->m_AuditUserId = event->m_AuditUserId;\n    newEvent->m_SessionId = event->m_SessionId;\n    newEvent->m_AuthenticationId.LowPart = event->m_AuthenticationId.LowPart;\n    newEvent->m_AuthenticationId.HighPart = event->m_AuthenticationId.HighPart;\n    newEvent->m_ProcessKey = event->m_ProcessKey;\n    newEvent->m_CreateTime.QuadPart = event->m_CreateTime.QuadPart;\n\n    if(OPT_SET( HashAlgorithms )){\n        unsigned int *hashTypePtr = OPT_VALUE( HashAlgorithms );\n        newEvent->m_HashType = *hashTypePtr;\n    }\n    else{\n        newEvent->m_HashType = 0;\n    }\n\n    memset(newEvent->m_Extensions, 0, sizeof(newEvent->m_Extensions));\n    const char *ptr = (char *)(event + 1);\n    char *newPtr = (char *)(newEvent + 1);\n\n    memcpy(newPtr, ptr, event->m_Extensions[PC_Sid]);\n    newEvent->m_Extensions[PC_Sid] = event->m_Extensions[PC_Sid];\n    ptr += event->m_Extensions[PC_Sid];\n    newPtr += event->m_Extensions[PC_Sid];\n\n    memcpy(newPtr, ptr, event->m_Extensions[PC_ImagePath]);\n    newEvent->m_Extensions[PC_ImagePath] = event->m_Extensions[PC_ImagePath];\n    ptr += event->m_Extensions[PC_ImagePath];\n    newPtr += event->m_Extensions[PC_ImagePath];\n\n    memcpy(newPtr, ptr, event->m_Extensions[PC_CommandLine]);\n    newEvent->m_Extensions[PC_CommandLine] = event->m_Extensions[PC_CommandLine];\n    ptr += event->m_Extensions[PC_CommandLine];\n    newPtr += event->m_Extensions[PC_CommandLine];\n\n    memcpy(newPtr, ptr, event->m_Extensions[PC_CurrentDirectory]);\n    newEvent->m_Extensions[PC_CurrentDirectory] = event->m_Extensions[PC_CurrentDirectory];\n    newPtr += event->m_Extensions[PC_CurrentDirectory];\n\n    newEventHdr->m_EventSize = (uint32_t)((void *)newPtr - (void *)newEventHdr);\n\n    DispatchEvent(newEventHdr);\n}\n\n//--------------------------------------------------------------------\n//\n// processFileDelete\n//\n// Handles file delete events\n//\n//--------------------------------------------------------------------\nvoid processFileDelete(CONST PSYSMON_EVENT_HEADER eventHdr)\n{\n    if(eventHdr == NULL) {\n        fprintf(stderr, \"processFileDelete invalid params\\n\");\n        return;\n    }\n\n    char newData[65536];\n\n    PSYSMON_EVENT_HEADER newEventHdr = (PSYSMON_EVENT_HEADER)newData;\n    newEventHdr->m_FieldFiltered = 0;\n    newEventHdr->m_PreFiltered = 0;\n    newEventHdr->m_SequenceNumber = 0;\n    newEventHdr->m_SessionId = 0;\n\n    PSYSMON_FILE_DELETE event = (PSYSMON_FILE_DELETE)&(eventHdr->m_EventBody);\n\n    newEventHdr->m_EventType = FileDelete;\n    PSYSMON_FILE_DELETE newEvent = &newEventHdr->m_EventBody.m_FileDeleteEvent;\n    newEvent->m_ProcessId = event->m_ProcessId;\n    newEvent->m_DeleteTime.QuadPart = event->m_DeleteTime.QuadPart;\n    newEvent->m_IsExecutable = event->m_IsExecutable;\n    newEvent->m_Archived[0] = event->m_Archived[0];\n    newEvent->m_TrackerId = event->m_TrackerId;\n\n    newEvent->m_HashType = 0xFF; // 0xFF will not be interpreted as any ALGO_*. Therefore, Hashes field will always be blank.\n\n    memset(newEvent->m_Extensions, 0, sizeof(newEvent->m_Extensions));\n    const char *ptr = (char *)(event + 1);\n    char *newPtr = (char *)(newEvent + 1);\n\n    memcpy(newPtr, ptr, event->m_Extensions[FD_Sid]);\n    newEvent->m_Extensions[FD_Sid] = event->m_Extensions[FD_Sid];\n    ptr += event->m_Extensions[FD_Sid];\n    newPtr += event->m_Extensions[FD_Sid];\n\n    memcpy(newPtr, ptr, event->m_Extensions[FD_FileName]);\n    newEvent->m_Extensions[FD_FileName] = event->m_Extensions[FD_FileName];\n    ptr += event->m_Extensions[FD_FileName];\n    newPtr += event->m_Extensions[FD_FileName];\n\n    memcpy(newPtr, ptr, event->m_Extensions[FD_ImagePath]);\n    newEvent->m_Extensions[FD_ImagePath] = event->m_Extensions[FD_ImagePath];\n    ptr += event->m_Extensions[FD_ImagePath];\n    newPtr += event->m_Extensions[FD_ImagePath];\n\n    memcpy(newPtr, ptr, event->m_Extensions[FD_Hash]);\n    newEvent->m_Extensions[FD_Hash] = event->m_Extensions[FD_Hash];\n    newPtr += event->m_Extensions[FD_Hash];\n\n    newEventHdr->m_EventSize = (uint32_t)((void *)newPtr - (void *)newEventHdr);\n\n    DispatchEvent(newEventHdr);\n}\n\n//--------------------------------------------------------------------\n//\n// handleEvent\n//\n// Receives the eBPF telemetry and sends it to DispatchEvent().\n//\n//--------------------------------------------------------------------\nstatic void handleEvent(void *ctx, int cpu, void *data, uint32_t size)\n{\n    if (size < 16 || data == NULL) {\n        printf(\"BAD EVENT: size=%d\\n\", size);\n        badEvents++;\n        return;\n    }\n\n    PSYSMON_EVENT_HEADER eventHdr = (PSYSMON_EVENT_HEADER)data;\n    totalEvents++;\n\n    switch ((DWORD)eventHdr->m_EventType) {\n        case LinuxFileOpen:\n            processFileOpen(eventHdr);\n            break;\n        case FileDelete:\n            processFileDelete(eventHdr);\n            break;\n        case LinuxNetworkEvent:\n            processNetworkEvent(eventHdr);\n            break;\n        case ProcessAccess:\n            processProcessAccess(eventHdr);\n            break;\n        case ProcessCreate:\n            processProcessCreate(eventHdr);\n            break;\n        case ProcessTerminate:\n        {\n            PSYSMON_PROCESS_TERMINATE event = (PSYSMON_PROCESS_TERMINATE)&eventHdr->m_EventBody.m_ProcessTerminateEvent;\n            NetworkTrackerUdpProgramTermination(NetworkState, event->m_ProcessId);\n            DispatchEvent(eventHdr);\n            break;\n        }\n        default:\n            DispatchEvent(eventHdr);\n    }\n}\n\n//--------------------------------------------------------------------\n//\n// handleLostEvents\n//\n// If the userland cannot keep up with the perf ring buffer, then\n// this callback will be called to indicate that events were lost.\n//\n//--------------------------------------------------------------------\nvoid handleLostEvents(void *ctx, int cpu, uint64_t lostCnt)\n{\n    fprintf(stdout, \"Lost %lu events on CPU #%d!\\n\", lostCnt, cpu);\n    numLostNotifications++;\n    numLostEvents += lostCnt;\n}\n\n//--------------------------------------------------------------------\n//\n// intHandler\n//\n// Called on CTRL-C. Tidies up and prints out some stats.\n//\n//--------------------------------------------------------------------\nvoid intHandler(int code)\n{\n    printf(\"\\nStopping....\\n\");\n    telemetryCloseAll();\n\n    SendStateEvent(\"Stopped\", STRFILEVER);\n\n    if (eventIdAddr != NULL && eventIdAddr != MAP_FAILED) {\n        munmap(eventIdAddr, sizeof(uint64_t));\n    }\n    if (eventIdFd > 0) {\n        close(eventIdFd);\n    }\n\n    printf(\"Total events: %ld, bad events: %ld, ratio = %f\\n\", totalEvents, badEvents, (double)badEvents / totalEvents);\n    printf(\"Lost events: %ld, in %d notifications\\n\", numLostEvents, numLostNotifications);\n\n    exit(0);\n}\n\n//--------------------------------------------------------------------\n//\n// PrintBanner\n//\n// Print program banner.\n//\n//--------------------------------------------------------------------\nvoid\nPrintBanner(\n\t\t   const int* argc,\n\t\t   const char *argv[]\n\t\t   )\n{\n\tprintf(\"\\n\");\n    printf(\"Sysmon v%s - Monitors system events\\n\", STRFILEVER);\n    printf(\"%s\\n\", VER_COMPANY);\n    printf(\"%s\\n\", VER_COPYRIGHT);\n    printf(\"\\n\");\n}\n\n//--------------------------------------------------------------------\n//\n// CheckRootPrivs\n//\n// Check if we are running as root and exit if not.\n// In the future we might vary this to check for the privileges\n// required to run eBPF instead.\n//\n//--------------------------------------------------------------------\nvoid\nCheckRootPrivs()\n{\n    if (geteuid() != 0) {\n        printf(\"You need to run Sysmon as root.\\n\\n\");\n        exit(ERROR_ELEVATION_REQUIRED);\n    }\n}\n\n//--------------------------------------------------------------------\n//\n// WriteRulesBlob\n//\n// Write the rules to a binary file in the install dir for later\n// display.\n// Note, size==0 (and therefore data possibly == NULL) is valid,\n// resulting in an empty file.\n//\n//--------------------------------------------------------------------\nbool WriteRulesBlob(PVOID data, ULONG size)\n{\n    int fd;\n    size_t written = 0;\n    ssize_t writeRet = 0;\n\n    unlink(SYSMON_RULES_FILE);\n    fd = creat(SYSMON_RULES_FILE, S_IRUSR | S_IWUSR);\n    if (fd < 0)\n        return false;\n\n    while (written < size) {\n        writeRet = write(fd, data + written, size - written);\n        if (writeRet < 0) {\n            close(fd);\n            unlink(SYSMON_RULES_FILE);\n            return false;\n        }\n        written += writeRet;\n    }\n    close(fd);\n    return true;\n}\n\n//--------------------------------------------------------------------\n//\n// SetSyscallActive\n//\n// Sets the appropriate syscall for the given event ID\n//\n//--------------------------------------------------------------------\nvoid SetSyscallActive(bool *s, ULONG eventId)\n{\n    switch(eventId) {\n        case SYSMONEVENT_CREATE_PROCESS_EVENT_value:\n            s[__NR_execve] = true;\n            s[__NR_execveat] = true;\n            break;\n        case SYSMONEVENT_NETWORK_CONNECT_EVENT_value:\n            s[__NR_accept] = true;\n            s[__NR_accept4] = true;\n            s[__NR_recvfrom] = true;\n            s[__NR_recvmsg] = true;\n            s[__NR_recvmmsg] = true;\n            s[__NR_read] = true;\n            s[__NR_NETWORK] = true;\n            break;\n        case SYSMONEVENT_PROCESS_TERMINATE_EVENT_value:\n            s[__NR_PROCTERM] = true;\n            break;\n        case SYSMONEVENT_RAWACCESS_READ_EVENT_value:\n            s[__NR_open] = true;\n            s[__NR_openat] = true;\n            s[__NR_RAWACCESS] = true;\n            break;\n        case SYSMONEVENT_FILE_CREATE_EVENT_value:\n            s[__NR_open] = true;\n            s[__NR_openat] = true;\n            s[__NR_creat] = true;\n            s[__NR_CREATE] = true;\n            break;\n        case SYSMONEVENT_FILE_DELETE_EVENT_value:\n            s[__NR_unlink] = true;\n            s[__NR_unlinkat] = true;\n            break;\n        case SYSMONEVENT_ACCESS_PROCESS_EVENT_value:\n            s[__NR_ptrace] = true;\n            break;\n        default:\n            break;\n    }\n}\n\n//--------------------------------------------------------------------\n//\n// SetActiveSyscalls\n//\n// Analyse the rules and enable appropriate syscalls\n//\n//--------------------------------------------------------------------\nvoid SetActiveSyscalls(bool *s)\n{\n    if (s == NULL) {\n        fprintf(stderr, \"SetActiveSyscalls invalid params\\n\");\n        return;\n    }\n\n    RULE_CONTEXT    ruleContext;\n    RULE_REG_EXT    ruleRegExt;\n    PRULE_EVENT     ruleEvent = NULL;\n    ULONG           index = 0;\n\n    memset( &ruleContext, 0, sizeof( ruleContext ) );\n    memset( &ruleRegExt, 0, sizeof( ruleRegExt ) );\n\n    //\n    // Set the default rules as active\n    //\n    for( index = 0; index < AllEventsCount; index++ ) {\n        if( AllEvents[index]->RuleName == NULL )\n            continue;\n        if( AllEvents[index]->Default == Rule_include ) {\n            SetSyscallActive( s, AllEvents[index]->EventId );\n        }\n    }\n\n    //\n    // Get the rules\n    //\n    if( !InitializeRuleContext( &ruleContext ) )\n    {\n        //\n        // No rules\n        //\n        return;\n    }\n\n    if( GetRuleRegExtInformation( &ruleContext, &ruleRegExt ) &&\n            ruleRegExt.header.RuleCount > 0 )\n    {\n        //\n        // Set the rules active\n        //\n        for( ruleEvent = NextRuleEvent( &ruleContext, NULL );\n             ruleEvent != NULL;\n             ruleEvent = NextRuleEvent( &ruleContext, ruleEvent ) ) {\n\n            SetSyscallActive( s, ruleEvent->EventId );\n        }\n    }\n\n    ReleaseRuleContext( &ruleContext );\n}\n\n\n//--------------------------------------------------------------------\n//\n// setConfigFromStoredArgv\n//\n// Retrieve the command line from the install directory and use it to\n// configure Sysmon\n//\n//--------------------------------------------------------------------\nbool setConfigFromStoredArgv(\n    PTCHAR          *configFile,\n    bool            *activeSyscalls\n)\n{\n    if( configFile == NULL || activeSyscalls == NULL ) {\n        fprintf( stderr, \"setConfigFromStoredArgv invalid params\\n\" );\n        return false;\n    }\n\n    int                         argc = 0;\n    static char                 **argv = NULL;\n    PVOID                       rules = NULL;\n    ULONG                       rulesSize = 0;\n    TCHAR                       configHash[256] = { 0 };\n    SIZE_T                      z;\n    PTCHAR                      parsedConfigFile = NULL;\n\n    //\n    // argv persists as its pointers are assigned to the config by\n    // ParseCommandLine; so if it is already allocated, free the previous one.\n    //\n    if( argv != NULL ) {\n        free( argv );\n    }\n\n    //\n    // Read argc and argv from sysmon install directory\n    // note: this mallocs argv\n    //\n    if( !readArgv( &argc, &argv, configFile ) ) {\n        fprintf( stderr, \"Could not read argv and argc\\n\" );\n        exit( 1 );\n    }\n\n    //\n    // Unset previous command line arguments\n    //\n    for( z = 0; z < ConfigOptionTypeCount; z++ ) {\n        ConfigOptionType[z].Option->IsSet = false;\n        ConfigOptionType[z].Option->Value = NULL;\n        ConfigOptionType[z].Option->Size = 0;\n    }\n\n    //\n    // Parse the command line using the data from manifest.xml.\n    // Note that the casing of the rules are the same as specified\n    // in the configuration.\n    //\n    if( !ParseCommandLine( argc, argv, &rules, &rulesSize,\n            &parsedConfigFile, configHash, _countof( configHash ) ) ) {\n        fprintf( stderr, \"Could not parse new rules(keep case)\\n\" );\n        free( argv );\n        //\n        // argv is static to preserve used memory\n        //\n        argv = NULL;\n        return false;\n    }\n\n    //\n    // Initialize and load any user-specified max field sizes\n    //\n    if( !LoadVariableFieldSizes( OPT_VALUE( FieldSizes ) ) ) {\n        fprintf( stderr, \"Could not load variable field sizes\\n\" );\n        free( argv );\n        //\n        // argv is static to preserve used memory\n        //\n        argv = NULL;\n        return false;\n    }\n\n    //\n    // Store any user-specified max field sizes\n    //\n    if( !writeFieldSizes( OPT_VALUE( FieldSizes ) ) ) {\n        fprintf( stderr, \"Could not write max field sizes\\n\" );\n        free( argv );\n        //\n        // argv is static to preserve used memory\n        //\n        argv = NULL;\n        return false;\n    }\n\n    //\n    // Write rules blob to file. We write the rules in the same case as\n    // in the configuration file. This is important to make sure\n    // the case is the same when using the -c switch to dump out the configuration\n    //\n    WriteRulesBlob( rules, rulesSize );\n\n\n    //\n    // Now we want to reinitialize the rules engine with the same set\n    // of rules, only this time, make sure we pass Transform=TRUE so\n    // that the rules get lower cased which is a requirement for case\n    // insensitivity to take place. We can't simply use the old 'rules'\n    // since the rules engine holds a reference (set as a result of calling\n    // ParseCommandLine above) and will end up freeing it. Instead we make a\n    // copy of the rules.\n    //\n    PVOID rulesCopy = malloc(rulesSize);\n    if(rulesCopy == NULL)\n    {\n        fprintf( stderr, \"Failed to allocate memory to rulesCopy\\n\" );\n        free( argv );\n        //\n        // argv is static to preserve used memory\n        //\n        argv = NULL;\n        return false;\n    }\n\n    memcpy(rulesCopy, rules, rulesSize);\n\n    if(!InitializeRules() || !SetRuleBlob(rulesCopy, rulesSize, TRUE))\n    {\n        fprintf( stderr, \"Could not set new rules(lower case)\\n\" );\n        free( argv );\n        //\n        // argv is static to preserve used memory\n        //\n        argv = NULL;\n        free(rulesCopy);\n        return false;\n    }\n\n    //\n    // Set active rules\n    //\n    SetActiveSyscalls( activeSyscalls );\n\n    return true;\n}\n\n//--------------------------------------------------------------------\n//\n// configChange\n//\n// Called when config has changed.\n//\n//--------------------------------------------------------------------\nvoid configChange()\n{\n    bool                        activeSyscalls[SYSCALL_ARRAY_SIZE];\n\n    memset( activeSyscalls, 0, sizeof( activeSyscalls ) );\n\n    //\n    // Load the command line from the stored argv\n    //\n    if ( !setConfigFromStoredArgv( &configFile, activeSyscalls ) )\n        return;\n\n    //\n    // Update the EBPF programs\n    //\n    telemetryUpdateSyscalls( activeSyscalls );\n\n    //\n    // Send config change event\n    //\n    SendConfigEvent( configFile, NULL );\n\n    fflush(NULL);\n}\n\n\n//--------------------------------------------------------------------\n//\n// HasCustomConfiguration\n//\n// Return TRUE if any custom configuration was set (change in settings).\n//\n//--------------------------------------------------------------------\nBOOLEAN\nHasCustomConfiguration(\n    VOID\n    )\n{\n    SIZE_T  index;\n\n    for( index = 0; index < ConfigOptionTypeCount; index++ ) {\n\n        if( !ConfigOptionType[index].CommandLineOnly &&\n            ConfigOptionType[index].Option->IsSet ) {\n            return TRUE;\n        }\n    }\n\n    return FALSE;\n}\n\n//--------------------------------------------------------------------\n//\n// main\n//\n// Entrypoint to the application for installation, configuration and\n// running the service instance.\n//\n//--------------------------------------------------------------------\nint\nmain(\n    int argc,\n    char *argv[]\n)\n{\n    PVOID                       rules = NULL;\n\tULONG                       rulesSize = 0;\n    PTCHAR                      debugModeOption;\n\tTCHAR                       configHash[256] = { 0 };\n\tCONSOLE_SCREEN_BUFFER_INFO\tcsbi;\n\tstruct \t                    winsize winSize;\n    pid_t                       pid;\n    bool                        forceUninstall = false;\n    bool                        activeSyscalls[SYSCALL_ARRAY_SIZE];\n    bool                        nothingToChange = false;\n    int                         *retPtr = NULL;\n\n    //\n    // Find boot time and clock tick interval, used for calculating process start times\n    //\n    SetBootTime();\n\n\tLIBXML_TEST_VERSION\n\n    umask(SYSMON_UMASK);\n\n\tif (ioctl(STDOUT_FILENO, TIOCGWINSZ, &winSize) == 0) {\n\t\tcsbi.dwSize.X = winSize.ws_col;\n\t} else {\n\t\tcsbi.dwSize.X = 80;\n\t}\n\n\tPrintBanner( &argc, (const char **)argv );\n\n\t//\n\t// Is it just looking for help\n\t//\n\tif( argc >= 2 &&\n\t\targv[1][0] == '-' &&\n\t\t( argv[1][1] == '?' ||\n\t\t  !strcasecmp( argv[1] + 1, \"h\" ) ||\n\t\t  !strcasecmp( argv[1] + 1, \"help\" ) ) ) {\n\n\t\tif( argc > 2 ) {\n\n\t\t\tif( !strcasecmp( argv[2], \"config\" ) || !strcasecmp( argv[2], \"configuration\" ) ) {\n\n\t\t\t\tConfigUsage( &csbi );\n\t\t\t\treturn ERROR_SUCCESS;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Expected behaviour so return success\n\t\t//\n\t\tUsage( argv[0], &csbi );\n\t\treturn ERROR_SUCCESS;\n\t}\n\n\t//\n\t// Parse the command line using the data from manifest.xml\n\t//\n\tif( !ParseCommandLine( argc, argv, &rules, &rulesSize,\n\t\t\t\t\t&configFile, configHash, _countof( configHash) ) ) {\n\n\t\treturn Usage( argv[0], &csbi );\n\t}\n\n    //\n    // Initialize and load any user-specified max field sizes\n    //\n    if( !LoadVariableFieldSizes( OPT_VALUE( FieldSizes ) ) ) {\n        fprintf( stderr, \"Could not load variable field sizes\\n\" );\n        return Usage( argv[0], &csbi );\n    }\n\n    //\n    // Print schema\n    //\n    if( OPT_SET( PrintSchema ) ) {\n\n        PrintSchema();\n        return ERROR_SUCCESS;\n    }\n\n    if( !OPT_SET(Configuration) && OPT_SET(ConfigDefault) ) {\n\n        printf( \"The '--' switch must be used with -c switch (config update) to set defaults.\\n\\n\" );\n        return ERROR_INVALID_PARAMETER;\n    }\n\n    if( OPT_SET(ClipboardInstance) ||\n        OPT_SET(DriverName) ||\n        OPT_SET(ArchiveDirectory) ||\n        OPT_SET(CaptureClipboard) ||\n        OPT_SET(CheckRevocation)\n        ) {\n        printf(\"\\nOption not implemented on Linux.\\n\\n\");\n        return ERROR_INVALID_PARAMETER;\n    }\n\n    if( OPT_SET( DebugMode ) ) {\n\n        g_DebugMode = TRUE;\n        debugModeOption = OPT_VALUE( DebugMode );\n        if( debugModeOption ) {\n\n            if( _tcsicmp( debugModeOption, _T(\"verbose\") ) ) {\n                _tprintf( _T( \"Possible options for DebugMode: verbose\\n\\n\" ) );\n                return ERROR_INVALID_PARAMETER;\n            }\n            g_DebugModeVerbose = TRUE;\n        }\n    }\n\n    CheckRootPrivs();\n\n    if ( OPT_SET(UnInstall) ) {\n        const char *uninstallModeOption = OPT_VALUE( UnInstall );\n        if ( uninstallModeOption) {\n            if( _tcsicmp( uninstallModeOption, _T(\"force\") ) != 0 ) {\n\n                _tprintf( _T(\"Invalid option for -u.\\n\\n\") );\n                return Usage( argv[0], &csbi );\n            }\n            forceUninstall = true;\n        }\n\n        stopSysmonService();\n        uninstall();\n        killOtherSysmon(forceUninstall);\n        printf(\"Sysmon stopped.\\n\");\n        return ERROR_SUCCESS;\n    }\n\n    if ( OPT_SET(Configuration) ) {\n        if( OPT_VALUE(Configuration) == NULL ) {\n\n            nothingToChange = !HasCustomConfiguration();\n        } else {\n\n            nothingToChange = FALSE;\n        }\n\n        //\n        // If we received -c -- check that there is no other options set\n        // if we received -c and others check that something will change?\n        //\n        if( OPT_SET(ConfigDefault) ) {\n\n            if( !nothingToChange ) {\n\n                _tprintf( _T(\"Cannot use specific settings with enforcing defaults.\\n\\n\") );\n                return ERROR_INVALID_PARAMETER;\n            }\n\n            _tprintf( _T(\"Updating configuration to use all defaults.\\n\") );\n\n        } else if( nothingToChange && rules == NULL && rulesSize == 0 ) {\n\n            //\n            // Display current configuration\n            //\n            if (sysmonIsRunning()) {\n                if (fileExists(SYSMON_RULES_FILE)) {\n                    DumpConfiguration();\n                } else {\n                    printf(\"No config to display\\n\");\n                }\n                return ERROR_SUCCESS;\n            } else {\n                printf(\"Sysmon is not running\\n\");\n                return ERROR_INVALID_PARAMETER;\n            }\n        }\n\n        if( !sysmonIsRunning() ) {\n\n            _tprintf( _T(\"Error: Sysmon is not installed.\\n\") );\n        }\n\n        //\n        // Update configuration\n        //\n        if( OPT_SET( ConfigDefault ) || configFile == NULL ) {\n\n            //\n            // create empty config file\n            //\n            unlink(SYSMON_CONFIG_FILE);\n            if (!createEmptyConfigFile()) {\n                fprintf(stderr, \"Cannot create empty config file\\n\");\n                return ERROR_INVALID_PARAMETER;\n            }\n        }\n        else {\n\n            if (!copyConfigFile(configFile)) {\n                fprintf(stderr, \"Cannot copy the config file\\n\");\n                return ERROR_INVALID_PARAMETER;\n            }\n        }\n\n        if (!writeArgv(argc, argv)) {\n            fprintf(stderr, \"Cannot write argv and argc\\n\");\n            return ERROR_INVALID_PARAMETER;\n        }\n\n        signalConfigChange();\n        return ERROR_SUCCESS;\n\n    }\n\n    if ( OPT_SET(Install) ) {\n\n        killOtherSysmon(true); // just to be sure\n\n        if (!installFiles(true)) {\n            fprintf(stderr, \"Cannot install Sysmon files\\n\");\n            exit(1);\n        }\n\n        if ( !OPT_SET(Service) ) {\n            stopSysmonService();\n\n            if (configFile != NULL) {\n                if (!copyConfigFile(configFile)) {\n                    fprintf(stderr, \"Cannot copy the config file\\n\");\n                    exit(1);\n                }\n            } else {\n                //\n                // create empty config file\n                //\n                unlink(SYSMON_CONFIG_FILE);\n                if (!createEmptyConfigFile()) {\n                    fprintf(stderr, \"Cannot create empty config file\\n\");\n                    exit(1);\n                }\n            }\n\n            //\n            // store the command line for when we restart as a service\n            //\n            if (!writeArgv(argc, argv)) {\n                fprintf(stderr, \"Cannot write argv and argc\\n\");\n                exit(1);\n            }\n        }\n\n        //\n        // If Sysmon is not currently running as a service (e.g. started by\n        // systemd or init.d) then start it as a service by replacing this\n        // execution with the shell invoker that starts the service.  If\n        // Sysmon is already running as a service, or it cannot start as a\n        // service (missing systemd and missing init.d) then continue.\n        //\n        startSysmonService();\n\n        //\n        // Retrieve the command line used to install Sysmon - note the systemd\n        // service will have started Sysmon with a generic command line and we\n        // want to start it up with the original command line.\n        //\n        memset( activeSyscalls, 0, sizeof( activeSyscalls ) );\n        setConfigFromStoredArgv( &configFile, activeSyscalls );\n\n        if ( OPT_SET(BTF) ) {\n            btfPath = OPT_VALUE( BTF );\n        }\n\n        bool debug = false;\n        if( OPT_SET( DebugMode ) ) {\n            debug = true;\n        }\n\n        struct stat st;\n        bool btfEnabled = stat(BTF_KERNEL_FILE, &st) < 0 ? false : true;\n\n        const ebpfTelemetryObject   kernelObjs[] =\n        {\n            {\n                KERN_4_15_OBJ, {4, 15}, {4, 16}, false,\n                sizeof(TPenterProgs) / sizeof(*TPenterProgs),\n                TPenterProgs,\n                sizeof(TPexitProgs) / sizeof(*TPexitProgs),\n                TPexitProgs,\n                0, NULL, 0, NULL, // No raw tracepoint programs\n                activeSyscalls,\n                sizeof(otherTPprogs4_15) / sizeof(*otherTPprogs4_15),\n                otherTPprogs4_15\n            },\n            {\n                KERN_4_16_OBJ, {4, 16}, {4, 17}, false,\n                sizeof(TPenterProgs) / sizeof(*TPenterProgs),\n                TPenterProgs,\n                sizeof(TPexitProgs) / sizeof(*TPexitProgs),\n                TPexitProgs,\n                0, NULL, 0, NULL, // No raw tracepoint programs\n                activeSyscalls,\n                sizeof(otherTPprogs4_16) / sizeof(*otherTPprogs4_15),\n                otherTPprogs4_16\n            },\n            {\n                KERN_4_17_5_1_OBJ, {4, 17}, {5, 2}, true,\n                0, NULL, 0, NULL, // No traditional tracepoint programs\n                sizeof(RTPenterProgs) / sizeof(*RTPenterProgs),\n                RTPenterProgs,\n                sizeof(RTPexitProgs) / sizeof(*RTPexitProgs),\n                RTPexitProgs,\n                activeSyscalls,\n                sizeof(otherTPprogs4_16) / sizeof(*otherTPprogs4_16),\n                otherTPprogs4_16\n            },\n            {\n                KERN_5_2_OBJ, {5, 2}, {5, 3}, true,\n                0, NULL, 0, NULL, // No traditional tracepoint programs\n                sizeof(RTPenterProgs) / sizeof(*RTPenterProgs),\n                RTPenterProgs,\n                sizeof(RTPexitProgs) / sizeof(*RTPexitProgs),\n                RTPexitProgs,\n                activeSyscalls,\n                sizeof(otherTPprogs4_16) / sizeof(*otherTPprogs4_16),\n                otherTPprogs4_16\n            },\n            {\n                KERN_5_3_5_5_OBJ, {5, 3}, {5, 6}, true,\n                0, NULL, 0, NULL, // No traditional tracepoint programs\n                sizeof(RTPenterProgs) / sizeof(*RTPenterProgs),\n                RTPenterProgs,\n                sizeof(RTPexitProgs) / sizeof(*RTPexitProgs),\n                RTPexitProgs,\n                activeSyscalls,\n                sizeof(otherTPprogs4_16) / sizeof(*otherTPprogs4_16),\n                otherTPprogs4_16\n            },\n            {\n                KERN_5_6__OBJ, {5, 6}, {0, 0}, true,\n                0, NULL, 0, NULL, // No traditional tracepoint programs\n                sizeof(RTPenterProgs) / sizeof(*RTPenterProgs),\n                RTPenterProgs,\n                sizeof(RTPexitProgs) / sizeof(*RTPexitProgs),\n                RTPexitProgs,\n                activeSyscalls,\n                sizeof(otherTPprogs4_16) / sizeof(*otherTPprogs4_16),\n                otherTPprogs4_16\n            }\n        };\n\n        ebpfTelemetryObject   kernelObjs_core[] =\n        {\n            {\n                KERN_4_15_CORE_OBJ, {4, 15}, {4, 16}, false,\n                sizeof(TPenterProgs) / sizeof(*TPenterProgs),\n                TPenterProgs,\n                sizeof(TPexitProgs) / sizeof(*TPexitProgs),\n                TPexitProgs,\n                0, NULL, 0, NULL, // No raw tracepoint programs\n                activeSyscalls,\n                sizeof(otherTPprogs4_15) / sizeof(*otherTPprogs4_15),\n                otherTPprogs4_15\n            },\n            {\n                KERN_4_16_CORE_OBJ, {4, 16}, {4, 17}, false,\n                sizeof(TPenterProgs) / sizeof(*TPenterProgs),\n                TPenterProgs,\n                sizeof(TPexitProgs) / sizeof(*TPexitProgs),\n                TPexitProgs,\n                0, NULL, 0, NULL, // No raw tracepoint programs\n                activeSyscalls,\n                sizeof(otherTPprogs4_16) / sizeof(*otherTPprogs4_15),\n                otherTPprogs4_16\n            },\n            {\n                KERN_4_17_5_1_CORE_OBJ, {4, 17}, {5, 2}, true,\n                0, NULL, 0, NULL, // No traditional tracepoint programs\n                sizeof(RTPenterProgs) / sizeof(*RTPenterProgs),\n                RTPenterProgs,\n                sizeof(RTPexitProgs) / sizeof(*RTPexitProgs),\n                RTPexitProgs,\n                activeSyscalls,\n                sizeof(otherTPprogs4_16) / sizeof(*otherTPprogs4_16),\n                otherTPprogs4_16\n            },\n            {\n                KERN_5_2_CORE_OBJ, {5, 2}, {5, 3}, true,\n                0, NULL, 0, NULL, // No traditional tracepoint programs\n                sizeof(RTPenterProgs) / sizeof(*RTPenterProgs),\n                RTPenterProgs,\n                sizeof(RTPexitProgs) / sizeof(*RTPexitProgs),\n                RTPexitProgs,\n                activeSyscalls,\n                sizeof(otherTPprogs4_16) / sizeof(*otherTPprogs4_16),\n                otherTPprogs4_16\n            },\n            {\n                KERN_5_3_5_5_CORE_OBJ, {5, 3}, {5, 6}, true,\n                0, NULL, 0, NULL, // No traditional tracepoint programs\n                sizeof(RTPenterProgs) / sizeof(*RTPenterProgs),\n                RTPenterProgs,\n                sizeof(RTPexitProgs) / sizeof(*RTPexitProgs),\n                RTPexitProgs,\n                activeSyscalls,\n                sizeof(otherTPprogs4_16) / sizeof(*otherTPprogs4_16),\n                otherTPprogs4_16\n            },\n            {\n                KERN_5_6__CORE_OBJ, {5, 6}, {0, 0}, true,\n                0, NULL, 0, NULL, // No traditional tracepoint programs\n                sizeof(RTPenterProgs) / sizeof(*RTPenterProgs),\n                RTPenterProgs,\n                sizeof(RTPexitProgs) / sizeof(*RTPexitProgs),\n                RTPexitProgs,\n                activeSyscalls,\n                sizeof(otherTPprogs4_16) / sizeof(*otherTPprogs4_16),\n                otherTPprogs4_16\n            }\n        };\n\n\n        const ebpfTelemetryConfig sysmonConfig = (ebpfTelemetryConfig)\n        {\n            g_bootSecSinceEpoch,\n            true, // enable raw socket capture\n            btfEnabled ? sizeof(kernelObjs_core) / sizeof(*kernelObjs_core) : sizeof(kernelObjs) / sizeof(*kernelObjs),\n            btfEnabled ? kernelObjs_core : kernelObjs,\n            sizeof(defPaths) / sizeof(*defPaths),\n            defPaths,\n            sizeof(mapObjects) / sizeof(*mapObjects),\n            mapObjects,\n            btfPath,\n            debug\n        };\n\n        //\n        // Set up network tracker\n        //\n        NetworkState = NetworkTrackerInit(15 * 60, 1 * 60); // connections are stale after 15 mins\n                                                            // check after 1 min\n\n        //\n        // Set up syslog\n        //\n        openlog( \"sysmon\", LOG_NOWAIT, LOG_USER );\n        signal( SIGINT, intHandler );\n        signal( SIGTERM, intHandler );\n\n        struct stat event_stat;\n        bool init_eventId = false;\n        if (stat(EVENTID_FILE, &event_stat) != 0) {\n            init_eventId = true;\n        }\n\n        eventIdFd = open(EVENTID_FILE, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n        if (eventIdFd > 0) {\n            if (init_eventId) {\n                posix_fallocate(eventIdFd, 0, sizeof(uint64_t));\n            }\n            eventIdAddr = (uint64_t *)mmap(NULL, sizeof(uint64_t), PROT_READ | PROT_WRITE, MAP_SHARED, eventIdFd, 0);\n            if ((eventIdAddr != NULL && eventIdAddr != MAP_FAILED) && init_eventId) {\n                *eventIdAddr = 0;\n            }\n        }\n\n        fflush(NULL);\n\n        sem_unlink(STARTUP_SEM_NAME);\n        startupSem = sem_open(STARTUP_SEM_NAME, O_CREAT | O_EXCL, S_IRUSR | S_IWUSR, 0);\n        if (startupSem == SEM_FAILED) {\n            fprintf(stderr, \"Cannot create semaphore\\n\");\n            exit(1);\n        }\n\n        //\n        // create shared memory to pass back the return code\n        //\n        retPtr = (int *)mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);\n        if (retPtr == NULL) {\n            fprintf(stderr, \"Failed to mmap shared memory\\n\");\n            return E_EBPF_CATASTROPHIC;\n        }\n\n        //\n        // fork in order to make the execution a service\n        // and also to allow the process to become a session leader, which is\n        // essential for automatic offsets discovery\n        //\n        pid = fork();\n        if (pid < 0) {\n            fprintf(stderr, \"Cannot fork\\n\");\n            exit(1);\n        } else if (pid > 0) {\n            //\n            // wait for everything to start\n            //\n            sem_wait(startupSem);\n            sem_close(startupSem);\n            sem_unlink(STARTUP_SEM_NAME);\n            if (*retPtr != E_EBPF_SUCCESS) {\n                fprintf(stderr, \"Telemetry failed to start: %s\\n\", eBPFstrerror(*retPtr));\n            }\n            exit(*retPtr);\n        }\n\n        *retPtr = telemetryStart( &sysmonConfig, handleEvent, handleLostEvents, telemetryReady, configChange,\n                NULL, (const char **)argv, mapFds );\n        sem_post(startupSem);\n\n        closelog();\n\n        return *retPtr;\n    }\n\n    Usage( argv[0], &csbi );\n    return ERROR_INVALID_PARAMETER;\n}\n\n"
        },
        {
          "name": "templates",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "vmlinux.h",
          "type": "blob",
          "size": 2663.6962890625,
          "content": "#ifndef __VMLINUX_H__\n#define __VMLINUX_H__\n\n#ifndef BPF_NO_PRESERVE_ACCESS_INDEX\n#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)\n#endif\n\ntypedef unsigned char __u8;\n\ntypedef short int __s16;\n\ntypedef short unsigned int __u16;\n\ntypedef int __s32;\n\ntypedef unsigned int __u32;\n\ntypedef long long int __s64;\n\ntypedef long long unsigned int __u64;\n\ntypedef __u8 u8;\n\ntypedef __s16 s16;\n\ntypedef __u16 u16;\n\ntypedef __s32 s32;\n\ntypedef __u32 u32;\n\ntypedef __s64 s64;\n\ntypedef __u64 u64;\n\nenum {\n\tfalse = 0,\n\ttrue = 1,\n};\n\ntypedef long int __kernel_long_t;\n\ntypedef long unsigned int __kernel_ulong_t;\n\ntypedef int __kernel_pid_t;\n\ntypedef unsigned int __kernel_uid32_t;\n\ntypedef unsigned int __kernel_gid32_t;\n\ntypedef __kernel_ulong_t __kernel_size_t;\n\ntypedef __kernel_long_t __kernel_ssize_t;\n\ntypedef long long int __kernel_loff_t;\n\ntypedef long long int __kernel_time64_t;\n\ntypedef __kernel_long_t __kernel_clock_t;\n\ntypedef int __kernel_timer_t;\n\ntypedef int __kernel_clockid_t;\n\ntypedef unsigned int __poll_t;\n\ntypedef u32 __kernel_dev_t;\n\ntypedef __kernel_dev_t dev_t;\n\ntypedef short unsigned int umode_t;\n\ntypedef __kernel_pid_t pid_t;\n\ntypedef __kernel_clockid_t clockid_t;\n\ntypedef _Bool bool;\n\ntypedef __kernel_uid32_t uid_t;\n\ntypedef __kernel_gid32_t gid_t;\n\ntypedef __kernel_loff_t loff_t;\n\ntypedef __kernel_size_t size_t;\n\ntypedef __kernel_ssize_t ssize_t;\n\ntypedef s32 int32_t;\n\ntypedef u32 uint32_t;\n\ntypedef u64 sector_t;\n\ntypedef u64 blkcnt_t;\n\ntypedef unsigned int gfp_t;\n\ntypedef unsigned int fmode_t;\n\ntypedef u64 phys_addr_t;\n\ntypedef struct {\n\tint counter;\n} atomic_t;\n\ntypedef struct {\n\ts64 counter;\n} atomic64_t;\n\nstruct list_head {\n\tstruct list_head *next;\n\tstruct list_head *prev;\n};\n\nstruct hlist_node;\n\nstruct hlist_head {\n\tstruct hlist_node *first;\n};\n\nstruct hlist_node {\n\tstruct hlist_node *next;\n\tstruct hlist_node **pprev;\n};\n\nstruct callback_head {\n\tstruct callback_head *next;\n\tvoid (*func)(struct callback_head *);\n};\n\nstruct lock_class_key {};\n\nstruct fs_context;\n\nstruct fs_parameter_spec;\n\nstruct dentry;\n\nstruct super_block;\n\nstruct module;\n\nstruct file_system_type {\n\tconst char *name;\n\tint fs_flags;\n\tint (*init_fs_context)(struct fs_context *);\n\tconst struct fs_parameter_spec *parameters;\n\tstruct dentry * (*mount)(struct file_system_type *, int, const char *, void *);\n\tvoid (*kill_sb)(struct super_block *);\n\tstruct module *owner;\n\tstruct file_system_type *next;\n\tstruct hlist_head fs_supers;\n\tstruct lock_class_key s_lock_key;\n\tstruct lock_class_key s_umount_key;\n\tstruct lock_class_key s_vfs_rename_key;\n\tstruct lock_class_key s_writers_key[3];\n\tstruct lock_class_key i_lock_key;\n\tstruct lock_class_key i_mutex_key;\n\tstruct lock_class_key invalidate_lock_key;\n\tstruct lock_class_key i_mutex_dir_key;\n};\n\nstruct qspinlock {\n\tunion {\n\t\tatomic_t val;\n\t\tstruct {\n\t\t\tu8 locked;\n\t\t\tu8 pending;\n\t\t};\n\t\tstruct {\n\t\t\tu16 locked_pending;\n\t\t\tu16 tail;\n\t\t};\n\t};\n};\n\ntypedef struct qspinlock arch_spinlock_t;\n\nstruct qrwlock {\n\tunion {\n\t\tatomic_t cnts;\n\t\tstruct {\n\t\t\tu8 wlocked;\n\t\t\tu8 __lstate[3];\n\t\t};\n\t};\n\tarch_spinlock_t wait_lock;\n};\n\ntypedef struct qrwlock arch_rwlock_t;\n\nstruct raw_spinlock {\n\tarch_spinlock_t raw_lock;\n};\n\ntypedef struct raw_spinlock raw_spinlock_t;\n\nstruct spinlock {\n\tunion {\n\t\tstruct raw_spinlock rlock;\n\t};\n};\n\ntypedef struct spinlock spinlock_t;\n\ntypedef struct {\n\tarch_rwlock_t raw_lock;\n} rwlock_t;\n\nstruct ratelimit_state {\n\traw_spinlock_t lock;\n\tint interval;\n\tint burst;\n\tint printed;\n\tint missed;\n\tlong unsigned int begin;\n\tlong unsigned int flags;\n};\n\ntypedef void *fl_owner_t;\n\nstruct file;\n\nstruct kiocb;\n\nstruct iov_iter;\n\nstruct dir_context;\n\nstruct poll_table_struct;\n\nstruct vm_area_struct;\n\nstruct inode;\n\nstruct file_lock;\n\nstruct page;\n\nstruct pipe_inode_info;\n\nstruct seq_file;\n\nstruct file_operations {\n\tstruct module *owner;\n\tloff_t (*llseek)(struct file *, loff_t, int);\n\tssize_t (*read)(struct file *, char *, size_t, loff_t *);\n\tssize_t (*write)(struct file *, const char *, size_t, loff_t *);\n\tssize_t (*read_iter)(struct kiocb *, struct iov_iter *);\n\tssize_t (*write_iter)(struct kiocb *, struct iov_iter *);\n\tint (*iopoll)(struct kiocb *, bool);\n\tint (*iterate)(struct file *, struct dir_context *);\n\tint (*iterate_shared)(struct file *, struct dir_context *);\n\t__poll_t (*poll)(struct file *, struct poll_table_struct *);\n\tlong int (*unlocked_ioctl)(struct file *, unsigned int, long unsigned int);\n\tlong int (*compat_ioctl)(struct file *, unsigned int, long unsigned int);\n\tint (*mmap)(struct file *, struct vm_area_struct *);\n\tlong unsigned int mmap_supported_flags;\n\tint (*open)(struct inode *, struct file *);\n\tint (*flush)(struct file *, fl_owner_t);\n\tint (*release)(struct inode *, struct file *);\n\tint (*fsync)(struct file *, loff_t, loff_t, int);\n\tint (*fasync)(int, struct file *, int);\n\tint (*lock)(struct file *, int, struct file_lock *);\n\tssize_t (*sendpage)(struct file *, struct page *, int, size_t, loff_t *, int);\n\tlong unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);\n\tint (*check_flags)(int);\n\tint (*setfl)(struct file *, long unsigned int);\n\tint (*flock)(struct file *, int, struct file_lock *);\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);\n\tssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\n\tint (*setlease)(struct file *, long int, struct file_lock **, void **);\n\tlong int (*fallocate)(struct file *, int, loff_t, loff_t);\n\tvoid (*show_fdinfo)(struct seq_file *, struct file *);\n\tssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);\n\tloff_t (*remap_file_range)(struct file *, loff_t, struct file *, loff_t, loff_t, unsigned int);\n\tint (*fadvise)(struct file *, loff_t, loff_t, int);\n};\n\ntypedef __s64 time64_t;\n\nstruct __kernel_timespec {\n\t__kernel_time64_t tv_sec;\n\tlong long int tv_nsec;\n};\n\nstruct timespec64 {\n\ttime64_t tv_sec;\n\tlong int tv_nsec;\n};\n\nenum timespec_type {\n\tTT_NONE = 0,\n\tTT_NATIVE = 1,\n\tTT_COMPAT = 2,\n};\n\ntypedef s32 old_time32_t;\n\nstruct old_timespec32 {\n\told_time32_t tv_sec;\n\ts32 tv_nsec;\n};\n\nstruct pollfd;\n\nstruct restart_block {\n\tlong unsigned int arch_data;\n\tlong int (*fn)(struct restart_block *);\n\tunion {\n\t\tstruct {\n\t\t\tu32 *uaddr;\n\t\t\tu32 val;\n\t\t\tu32 flags;\n\t\t\tu32 bitset;\n\t\t\tu64 time;\n\t\t\tu32 *uaddr2;\n\t\t} futex;\n\t\tstruct {\n\t\t\tclockid_t clockid;\n\t\t\tenum timespec_type type;\n\t\t\tunion {\n\t\t\t\tstruct __kernel_timespec *rmtp;\n\t\t\t\tstruct old_timespec32 *compat_rmtp;\n\t\t\t};\n\t\t\tu64 expires;\n\t\t} nanosleep;\n\t\tstruct {\n\t\t\tstruct pollfd *ufds;\n\t\t\tint nfds;\n\t\t\tint has_timeout;\n\t\t\tlong unsigned int tv_sec;\n\t\t\tlong unsigned int tv_nsec;\n\t\t} poll;\n\t};\n};\n\nstruct thread_info {\n\tlong unsigned int flags;\n\tlong unsigned int syscall_work;\n\tu32 status;\n};\n\nstruct refcount_struct {\n\tatomic_t refs;\n};\n\ntypedef struct refcount_struct refcount_t;\n\nstruct llist_node {\n\tstruct llist_node *next;\n};\n\nstruct __call_single_node {\n\tstruct llist_node llist;\n\tunion {\n\t\tunsigned int u_flags;\n\t\tatomic_t a_flags;\n\t};\n\tu16 src;\n\tu16 dst;\n};\n\nstruct load_weight {\n\tlong unsigned int weight;\n\tu32 inv_weight;\n};\n\nstruct rb_node {\n\tlong unsigned int __rb_parent_color;\n\tstruct rb_node *rb_right;\n\tstruct rb_node *rb_left;\n};\n\nstruct sched_statistics {\n\tu64 wait_start;\n\tu64 wait_max;\n\tu64 wait_count;\n\tu64 wait_sum;\n\tu64 iowait_count;\n\tu64 iowait_sum;\n\tu64 sleep_start;\n\tu64 sleep_max;\n\ts64 sum_sleep_runtime;\n\tu64 block_start;\n\tu64 block_max;\n\tu64 exec_max;\n\tu64 slice_max;\n\tu64 nr_migrations_cold;\n\tu64 nr_failed_migrations_affine;\n\tu64 nr_failed_migrations_running;\n\tu64 nr_failed_migrations_hot;\n\tu64 nr_forced_migrations;\n\tu64 nr_wakeups;\n\tu64 nr_wakeups_sync;\n\tu64 nr_wakeups_migrate;\n\tu64 nr_wakeups_local;\n\tu64 nr_wakeups_remote;\n\tu64 nr_wakeups_affine;\n\tu64 nr_wakeups_affine_attempts;\n\tu64 nr_wakeups_passive;\n\tu64 nr_wakeups_idle;\n};\n\nstruct util_est {\n\tunsigned int enqueued;\n\tunsigned int ewma;\n};\n\nstruct sched_avg {\n\tu64 last_update_time;\n\tu64 load_sum;\n\tu64 runnable_sum;\n\tu32 util_sum;\n\tu32 period_contrib;\n\tlong unsigned int load_avg;\n\tlong unsigned int runnable_avg;\n\tlong unsigned int util_avg;\n\tstruct util_est util_est;\n};\n\nstruct cfs_rq;\n\nstruct sched_entity {\n\tstruct load_weight load;\n\tstruct rb_node run_node;\n\tstruct list_head group_node;\n\tunsigned int on_rq;\n\tu64 exec_start;\n\tu64 sum_exec_runtime;\n\tu64 vruntime;\n\tu64 prev_sum_exec_runtime;\n\tu64 nr_migrations;\n\tstruct sched_statistics statistics;\n\tint depth;\n\tstruct sched_entity *parent;\n\tstruct cfs_rq *cfs_rq;\n\tstruct cfs_rq *my_q;\n\tlong unsigned int runnable_weight;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct sched_avg avg;\n};\n\nstruct sched_rt_entity {\n\tstruct list_head run_list;\n\tlong unsigned int timeout;\n\tlong unsigned int watchdog_stamp;\n\tunsigned int time_slice;\n\tshort unsigned int on_rq;\n\tshort unsigned int on_list;\n\tstruct sched_rt_entity *back;\n};\n\ntypedef s64 ktime_t;\n\nstruct timerqueue_node {\n\tstruct rb_node node;\n\tktime_t expires;\n};\n\nenum hrtimer_restart {\n\tHRTIMER_NORESTART = 0,\n\tHRTIMER_RESTART = 1,\n};\n\nstruct hrtimer_clock_base;\n\nstruct hrtimer {\n\tstruct timerqueue_node node;\n\tktime_t _softexpires;\n\tenum hrtimer_restart (*function)(struct hrtimer *);\n\tstruct hrtimer_clock_base *base;\n\tu8 state;\n\tu8 is_rel;\n\tu8 is_soft;\n\tu8 is_hard;\n};\n\nstruct sched_dl_entity {\n\tstruct rb_node rb_node;\n\tu64 dl_runtime;\n\tu64 dl_deadline;\n\tu64 dl_period;\n\tu64 dl_bw;\n\tu64 dl_density;\n\ts64 runtime;\n\tu64 deadline;\n\tunsigned int flags;\n\tunsigned int dl_throttled: 1;\n\tunsigned int dl_yielded: 1;\n\tunsigned int dl_non_contending: 1;\n\tunsigned int dl_overrun: 1;\n\tstruct hrtimer dl_timer;\n\tstruct hrtimer inactive_timer;\n\tstruct sched_dl_entity *pi_se;\n};\n\nstruct uclamp_se {\n\tunsigned int value: 11;\n\tunsigned int bucket_id: 3;\n\tunsigned int active: 1;\n\tunsigned int user_defined: 1;\n};\n\nstruct cpumask {\n\tlong unsigned int bits[128];\n};\n\ntypedef struct cpumask cpumask_t;\n\nunion rcu_special {\n\tstruct {\n\t\tu8 blocked;\n\t\tu8 need_qs;\n\t\tu8 exp_hint;\n\t\tu8 need_mb;\n\t} b;\n\tu32 s;\n};\n\nstruct sched_info {\n\tlong unsigned int pcount;\n\tlong long unsigned int run_delay;\n\tlong long unsigned int last_arrival;\n\tlong long unsigned int last_queued;\n};\n\nstruct plist_node {\n\tint prio;\n\tstruct list_head prio_list;\n\tstruct list_head node_list;\n};\n\nstruct vmacache {\n\tu64 seqnum;\n\tstruct vm_area_struct *vmas[4];\n};\n\nstruct task_rss_stat {\n\tint events;\n\tint count[4];\n};\n\nstruct prev_cputime {\n\tu64 utime;\n\tu64 stime;\n\traw_spinlock_t lock;\n};\n\nstruct rb_root {\n\tstruct rb_node *rb_node;\n};\n\nstruct rb_root_cached {\n\tstruct rb_root rb_root;\n\tstruct rb_node *rb_leftmost;\n};\n\nstruct timerqueue_head {\n\tstruct rb_root_cached rb_root;\n};\n\nstruct posix_cputimer_base {\n\tu64 nextevt;\n\tstruct timerqueue_head tqhead;\n};\n\nstruct posix_cputimers {\n\tstruct posix_cputimer_base bases[3];\n\tunsigned int timers_active;\n\tunsigned int expiry_active;\n};\n\nstruct posix_cputimers_work {\n\tstruct callback_head work;\n\tunsigned int scheduled;\n};\n\nstruct sem_undo_list;\n\nstruct sysv_sem {\n\tstruct sem_undo_list *undo_list;\n};\n\nstruct sysv_shm {\n\tstruct list_head shm_clist;\n};\n\ntypedef struct {\n\tlong unsigned int sig[1];\n} sigset_t;\n\nstruct sigpending {\n\tstruct list_head list;\n\tsigset_t signal;\n};\n\ntypedef struct {\n\tuid_t val;\n} kuid_t;\n\nstruct seccomp_filter;\n\nstruct seccomp {\n\tint mode;\n\tatomic_t filter_count;\n\tstruct seccomp_filter *filter;\n};\n\nstruct syscall_user_dispatch {\n\tchar *selector;\n\tlong unsigned int offset;\n\tlong unsigned int len;\n\tbool on_dispatch;\n};\n\nstruct wake_q_node {\n\tstruct wake_q_node *next;\n};\n\nstruct task_io_accounting {\n\tu64 rchar;\n\tu64 wchar;\n\tu64 syscr;\n\tu64 syscw;\n\tu64 read_bytes;\n\tu64 write_bytes;\n\tu64 cancelled_write_bytes;\n};\n\ntypedef struct {\n\tlong unsigned int bits[16];\n} nodemask_t;\n\nstruct seqcount {\n\tunsigned int sequence;\n};\n\ntypedef struct seqcount seqcount_t;\n\nstruct seqcount_spinlock {\n\tseqcount_t seqcount;\n};\n\ntypedef struct seqcount_spinlock seqcount_spinlock_t;\n\ntypedef atomic64_t atomic_long_t;\n\nstruct optimistic_spin_queue {\n\tatomic_t tail;\n};\n\nstruct mutex {\n\tatomic_long_t owner;\n\traw_spinlock_t wait_lock;\n\tstruct optimistic_spin_queue osq;\n\tstruct list_head wait_list;\n};\n\nstruct arch_tlbflush_unmap_batch {\n\tstruct cpumask cpumask;\n};\n\nstruct tlbflush_unmap_batch {\n\tstruct arch_tlbflush_unmap_batch arch;\n\tbool flush_required;\n\tbool writable;\n};\n\nstruct page_frag {\n\tstruct page *page;\n\t__u32 offset;\n\t__u32 size;\n};\n\nstruct kmap_ctrl {};\n\nstruct timer_list {\n\tstruct hlist_node entry;\n\tlong unsigned int expires;\n\tvoid (*function)(struct timer_list *);\n\tu32 flags;\n};\n\nstruct llist_head {\n\tstruct llist_node *first;\n};\n\nstruct desc_struct {\n\tu16 limit0;\n\tu16 base0;\n\tu16 base1: 8;\n\tu16 type: 4;\n\tu16 s: 1;\n\tu16 dpl: 2;\n\tu16 p: 1;\n\tu16 limit1: 4;\n\tu16 avl: 1;\n\tu16 l: 1;\n\tu16 d: 1;\n\tu16 g: 1;\n\tu16 base2: 8;\n};\n\nstruct fpu_state_perm {\n\tu64 __state_perm;\n\tunsigned int __state_size;\n\tunsigned int __user_state_size;\n};\n\nstruct fregs_state {\n\tu32 cwd;\n\tu32 swd;\n\tu32 twd;\n\tu32 fip;\n\tu32 fcs;\n\tu32 foo;\n\tu32 fos;\n\tu32 st_space[20];\n\tu32 status;\n};\n\nstruct fxregs_state {\n\tu16 cwd;\n\tu16 swd;\n\tu16 twd;\n\tu16 fop;\n\tunion {\n\t\tstruct {\n\t\t\tu64 rip;\n\t\t\tu64 rdp;\n\t\t};\n\t\tstruct {\n\t\t\tu32 fip;\n\t\t\tu32 fcs;\n\t\t\tu32 foo;\n\t\t\tu32 fos;\n\t\t};\n\t};\n\tu32 mxcsr;\n\tu32 mxcsr_mask;\n\tu32 st_space[32];\n\tu32 xmm_space[64];\n\tu32 padding[12];\n\tunion {\n\t\tu32 padding1[12];\n\t\tu32 sw_reserved[12];\n\t};\n};\n\nstruct math_emu_info;\n\nstruct swregs_state {\n\tu32 cwd;\n\tu32 swd;\n\tu32 twd;\n\tu32 fip;\n\tu32 fcs;\n\tu32 foo;\n\tu32 fos;\n\tu32 st_space[20];\n\tu8 ftop;\n\tu8 changed;\n\tu8 lookahead;\n\tu8 no_update;\n\tu8 rm;\n\tu8 alimit;\n\tstruct math_emu_info *info;\n\tu32 entry_eip;\n};\n\nstruct xstate_header {\n\tu64 xfeatures;\n\tu64 xcomp_bv;\n\tu64 reserved[6];\n};\n\nstruct xregs_state {\n\tstruct fxregs_state i387;\n\tstruct xstate_header header;\n\tu8 extended_state_area[0];\n};\n\nunion fpregs_state {\n\tstruct fregs_state fsave;\n\tstruct fxregs_state fxsave;\n\tstruct swregs_state soft;\n\tstruct xregs_state xsave;\n\tu8 __padding[4096];\n};\n\nstruct fpstate {\n\tunsigned int size;\n\tunsigned int user_size;\n\tu64 xfeatures;\n\tu64 user_xfeatures;\n\tu64 xfd;\n\tunsigned int is_valloc: 1;\n\tunsigned int is_guest: 1;\n\tunsigned int is_confidential: 1;\n\tunsigned int in_use: 1;\n\tlong: 60;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tunion fpregs_state regs;\n};\n\nstruct fpu {\n\tunsigned int last_cpu;\n\tlong unsigned int avx512_timestamp;\n\tstruct fpstate *fpstate;\n\tstruct fpstate *__task_fpstate;\n\tstruct fpu_state_perm perm;\n\tlong: 64;\n\tlong: 64;\n\tstruct fpstate __fpstate;\n};\n\nstruct perf_event;\n\nstruct io_bitmap;\n\nstruct thread_struct {\n\tstruct desc_struct tls_array[3];\n\tlong unsigned int sp;\n\tshort unsigned int es;\n\tshort unsigned int ds;\n\tshort unsigned int fsindex;\n\tshort unsigned int gsindex;\n\tlong unsigned int fsbase;\n\tlong unsigned int gsbase;\n\tstruct perf_event *ptrace_bps[4];\n\tlong unsigned int virtual_dr6;\n\tlong unsigned int ptrace_dr7;\n\tlong unsigned int cr2;\n\tlong unsigned int trap_nr;\n\tlong unsigned int error_code;\n\tstruct io_bitmap *io_bitmap;\n\tlong unsigned int iopl_emul;\n\tunsigned int iopl_warn: 1;\n\tunsigned int sig_on_uaccess_err: 1;\n\tu32 pkru;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct fpu fpu;\n};\n\nstruct sched_class;\n\nstruct task_group;\n\nstruct mm_struct;\n\nstruct pid;\n\nstruct completion;\n\nstruct cred;\n\nstruct key;\n\nstruct nameidata;\n\nstruct fs_struct;\n\nstruct files_struct;\n\nstruct io_uring_task;\n\nstruct nsproxy;\n\nstruct signal_struct;\n\nstruct sighand_struct;\n\nstruct audit_context;\n\nstruct rt_mutex_waiter;\n\nstruct bio_list;\n\nstruct blk_plug;\n\nstruct reclaim_state;\n\nstruct backing_dev_info;\n\nstruct io_context;\n\nstruct capture_control;\n\nstruct kernel_siginfo;\n\ntypedef struct kernel_siginfo kernel_siginfo_t;\n\nstruct css_set;\n\nstruct robust_list_head;\n\nstruct compat_robust_list_head;\n\nstruct futex_pi_state;\n\nstruct perf_event_context;\n\nstruct mempolicy;\n\nstruct numa_group;\n\nstruct rseq;\n\nstruct task_delay_info;\n\nstruct ftrace_ret_stack;\n\nstruct mem_cgroup;\n\nstruct request_queue;\n\nstruct uprobe_task;\n\nstruct vm_struct;\n\nstruct bpf_local_storage;\n\nstruct bpf_run_ctx;\n\nstruct task_struct {\n\tstruct thread_info thread_info;\n\tunsigned int __state;\n\tvoid *stack;\n\trefcount_t usage;\n\tunsigned int flags;\n\tunsigned int ptrace;\n\tint on_cpu;\n\tstruct __call_single_node wake_entry;\n\tunsigned int cpu;\n\tunsigned int wakee_flips;\n\tlong unsigned int wakee_flip_decay_ts;\n\tstruct task_struct *last_wakee;\n\tint recent_used_cpu;\n\tint wake_cpu;\n\tint on_rq;\n\tint prio;\n\tint static_prio;\n\tint normal_prio;\n\tunsigned int rt_priority;\n\tconst struct sched_class *sched_class;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct sched_entity se;\n\tstruct sched_rt_entity rt;\n\tstruct sched_dl_entity dl;\n\tstruct rb_node core_node;\n\tlong unsigned int core_cookie;\n\tunsigned int core_occupation;\n\tstruct task_group *sched_task_group;\n\tstruct uclamp_se uclamp_req[2];\n\tstruct uclamp_se uclamp[2];\n\tstruct hlist_head preempt_notifiers;\n\tunsigned int btrace_seq;\n\tunsigned int policy;\n\tint nr_cpus_allowed;\n\tconst cpumask_t *cpus_ptr;\n\tcpumask_t *user_cpus_ptr;\n\tcpumask_t cpus_mask;\n\tvoid *migration_pending;\n\tshort unsigned int migration_disabled;\n\tshort unsigned int migration_flags;\n\tint trc_reader_nesting;\n\tint trc_ipi_to_cpu;\n\tunion rcu_special trc_reader_special;\n\tbool trc_reader_checked;\n\tstruct list_head trc_holdout_list;\n\tstruct sched_info sched_info;\n\tstruct list_head tasks;\n\tstruct plist_node pushable_tasks;\n\tstruct rb_node pushable_dl_tasks;\n\tstruct mm_struct *mm;\n\tstruct mm_struct *active_mm;\n\tstruct vmacache vmacache;\n\tstruct task_rss_stat rss_stat;\n\tint exit_state;\n\tint exit_code;\n\tint exit_signal;\n\tint pdeath_signal;\n\tlong unsigned int jobctl;\n\tunsigned int personality;\n\tunsigned int sched_reset_on_fork: 1;\n\tunsigned int sched_contributes_to_load: 1;\n\tunsigned int sched_migrated: 1;\n\tunsigned int sched_psi_wake_requeue: 1;\n\tint: 28;\n\tunsigned int sched_remote_wakeup: 1;\n\tunsigned int in_execve: 1;\n\tunsigned int in_iowait: 1;\n\tunsigned int restore_sigmask: 1;\n\tunsigned int in_user_fault: 1;\n\tunsigned int no_cgroup_migration: 1;\n\tunsigned int frozen: 1;\n\tunsigned int use_memdelay: 1;\n\tunsigned int in_memstall: 1;\n\tunsigned int in_eventfd_signal: 1;\n\tlong unsigned int atomic_flags;\n\tstruct restart_block restart_block;\n\tpid_t pid;\n\tpid_t tgid;\n\tlong unsigned int stack_canary;\n\tstruct task_struct *real_parent;\n\tstruct task_struct *parent;\n\tstruct list_head children;\n\tstruct list_head sibling;\n\tstruct task_struct *group_leader;\n\tstruct list_head ptraced;\n\tstruct list_head ptrace_entry;\n\tstruct pid *thread_pid;\n\tstruct hlist_node pid_links[4];\n\tstruct list_head thread_group;\n\tstruct list_head thread_node;\n\tstruct completion *vfork_done;\n\tint *set_child_tid;\n\tint *clear_child_tid;\n\tvoid *pf_io_worker;\n\tu64 utime;\n\tu64 stime;\n\tu64 gtime;\n\tstruct prev_cputime prev_cputime;\n\tlong unsigned int nvcsw;\n\tlong unsigned int nivcsw;\n\tu64 start_time;\n\tu64 start_boottime;\n\tlong unsigned int min_flt;\n\tlong unsigned int maj_flt;\n\tstruct posix_cputimers posix_cputimers;\n\tstruct posix_cputimers_work posix_cputimers_work;\n\tconst struct cred *ptracer_cred;\n\tconst struct cred *real_cred;\n\tconst struct cred *cred;\n\tstruct key *cached_requested_key;\n\tchar comm[16];\n\tstruct nameidata *nameidata;\n\tstruct sysv_sem sysvsem;\n\tstruct sysv_shm sysvshm;\n\tlong unsigned int last_switch_count;\n\tlong unsigned int last_switch_time;\n\tstruct fs_struct *fs;\n\tstruct files_struct *files;\n\tstruct io_uring_task *io_uring;\n\tstruct nsproxy *nsproxy;\n\tstruct signal_struct *signal;\n\tstruct sighand_struct *sighand;\n\tsigset_t blocked;\n\tsigset_t real_blocked;\n\tsigset_t saved_sigmask;\n\tstruct sigpending pending;\n\tlong unsigned int sas_ss_sp;\n\tsize_t sas_ss_size;\n\tunsigned int sas_ss_flags;\n\tstruct callback_head *task_works;\n\tstruct audit_context *audit_context;\n\tkuid_t loginuid;\n\tunsigned int sessionid;\n\tstruct seccomp seccomp;\n\tstruct syscall_user_dispatch syscall_dispatch;\n\tu64 parent_exec_id;\n\tu64 self_exec_id;\n\tspinlock_t alloc_lock;\n\traw_spinlock_t pi_lock;\n\tstruct wake_q_node wake_q;\n\tstruct rb_root_cached pi_waiters;\n\tstruct task_struct *pi_top_task;\n\tstruct rt_mutex_waiter *pi_blocked_on;\n\tunsigned int in_ubsan;\n\tvoid *journal_info;\n\tstruct bio_list *bio_list;\n\tstruct blk_plug *plug;\n\tstruct reclaim_state *reclaim_state;\n\tstruct backing_dev_info *backing_dev_info;\n\tstruct io_context *io_context;\n\tstruct capture_control *capture_control;\n\tlong unsigned int ptrace_message;\n\tkernel_siginfo_t *last_siginfo;\n\tstruct task_io_accounting ioac;\n\tunsigned int psi_flags;\n\tu64 acct_rss_mem1;\n\tu64 acct_vm_mem1;\n\tu64 acct_timexpd;\n\tnodemask_t mems_allowed;\n\tseqcount_spinlock_t mems_allowed_seq;\n\tint cpuset_mem_spread_rotor;\n\tint cpuset_slab_spread_rotor;\n\tstruct css_set *cgroups;\n\tstruct list_head cg_list;\n\tu32 closid;\n\tu32 rmid;\n\tstruct robust_list_head *robust_list;\n\tstruct compat_robust_list_head *compat_robust_list;\n\tstruct list_head pi_state_list;\n\tstruct futex_pi_state *pi_state_cache;\n\tstruct mutex futex_exit_mutex;\n\tunsigned int futex_state;\n\tstruct perf_event_context *perf_event_ctxp[2];\n\tstruct mutex perf_event_mutex;\n\tstruct list_head perf_event_list;\n\tstruct mempolicy *mempolicy;\n\tshort int il_prev;\n\tshort int pref_node_fork;\n\tint numa_scan_seq;\n\tunsigned int numa_scan_period;\n\tunsigned int numa_scan_period_max;\n\tint numa_preferred_nid;\n\tlong unsigned int numa_migrate_retry;\n\tu64 node_stamp;\n\tu64 last_task_numa_placement;\n\tu64 last_sum_exec_runtime;\n\tstruct callback_head numa_work;\n\tstruct numa_group *numa_group;\n\tlong unsigned int *numa_faults;\n\tlong unsigned int total_numa_faults;\n\tlong unsigned int numa_faults_locality[3];\n\tlong unsigned int numa_pages_migrated;\n\tstruct rseq *rseq;\n\tu32 rseq_sig;\n\tlong unsigned int rseq_event_mask;\n\tstruct tlbflush_unmap_batch tlb_ubc;\n\tunion {\n\t\trefcount_t rcu_users;\n\t\tstruct callback_head rcu;\n\t};\n\tstruct pipe_inode_info *splice_pipe;\n\tstruct page_frag task_frag;\n\tstruct task_delay_info *delays;\n\tint nr_dirtied;\n\tint nr_dirtied_pause;\n\tlong unsigned int dirty_paused_when;\n\tu64 timer_slack_ns;\n\tu64 default_timer_slack_ns;\n\tint curr_ret_stack;\n\tint curr_ret_depth;\n\tstruct ftrace_ret_stack *ret_stack;\n\tlong long unsigned int ftrace_timestamp;\n\tatomic_t trace_overrun;\n\tatomic_t tracing_graph_pause;\n\tlong unsigned int trace;\n\tlong unsigned int trace_recursion;\n\tstruct mem_cgroup *memcg_in_oom;\n\tgfp_t memcg_oom_gfp_mask;\n\tint memcg_oom_order;\n\tunsigned int memcg_nr_pages_over_high;\n\tstruct mem_cgroup *active_memcg;\n\tstruct request_queue *throttle_queue;\n\tstruct uprobe_task *utask;\n\tunsigned int sequential_io;\n\tunsigned int sequential_io_avg;\n\tstruct kmap_ctrl kmap_ctrl;\n\tint pagefault_disabled;\n\tstruct task_struct *oom_reaper_list;\n\tstruct timer_list oom_reaper_timer;\n\tstruct vm_struct *stack_vm_area;\n\trefcount_t stack_refcount;\n\tint patch_state;\n\tvoid *security;\n\tstruct bpf_local_storage *bpf_storage;\n\tstruct bpf_run_ctx *bpf_ctx;\n\tvoid *mce_vaddr;\n\t__u64 mce_kflags;\n\tu64 mce_addr;\n\t__u64 mce_ripv: 1;\n\t__u64 mce_whole_page: 1;\n\t__u64 __mce_reserved: 62;\n\tstruct callback_head mce_kill_me;\n\tint mce_count;\n\tstruct llist_head kretprobe_instances;\n\tstruct callback_head l1d_flush_kill;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct thread_struct thread;\n};\n\nstruct screen_info {\n\t__u8 orig_x;\n\t__u8 orig_y;\n\t__u16 ext_mem_k;\n\t__u16 orig_video_page;\n\t__u8 orig_video_mode;\n\t__u8 orig_video_cols;\n\t__u8 flags;\n\t__u8 unused2;\n\t__u16 orig_video_ega_bx;\n\t__u16 unused3;\n\t__u8 orig_video_lines;\n\t__u8 orig_video_isVGA;\n\t__u16 orig_video_points;\n\t__u16 lfb_width;\n\t__u16 lfb_height;\n\t__u16 lfb_depth;\n\t__u32 lfb_base;\n\t__u32 lfb_size;\n\t__u16 cl_magic;\n\t__u16 cl_offset;\n\t__u16 lfb_linelength;\n\t__u8 red_size;\n\t__u8 red_pos;\n\t__u8 green_size;\n\t__u8 green_pos;\n\t__u8 blue_size;\n\t__u8 blue_pos;\n\t__u8 rsvd_size;\n\t__u8 rsvd_pos;\n\t__u16 vesapm_seg;\n\t__u16 vesapm_off;\n\t__u16 pages;\n\t__u16 vesa_attributes;\n\t__u32 capabilities;\n\t__u32 ext_lfb_base;\n\t__u8 _reserved[2];\n} __attribute__((packed));\n\nstruct apm_bios_info {\n\t__u16 version;\n\t__u16 cseg;\n\t__u32 offset;\n\t__u16 cseg_16;\n\t__u16 dseg;\n\t__u16 flags;\n\t__u16 cseg_len;\n\t__u16 cseg_16_len;\n\t__u16 dseg_len;\n};\n\nstruct edd_device_params {\n\t__u16 length;\n\t__u16 info_flags;\n\t__u32 num_default_cylinders;\n\t__u32 num_default_heads;\n\t__u32 sectors_per_track;\n\t__u64 number_of_sectors;\n\t__u16 bytes_per_sector;\n\t__u32 dpte_ptr;\n\t__u16 key;\n\t__u8 device_path_info_length;\n\t__u8 reserved2;\n\t__u16 reserved3;\n\t__u8 host_bus_type[4];\n\t__u8 interface_type[8];\n\tunion {\n\t\tstruct {\n\t\t\t__u16 base_address;\n\t\t\t__u16 reserved1;\n\t\t\t__u32 reserved2;\n\t\t} isa;\n\t\tstruct {\n\t\t\t__u8 bus;\n\t\t\t__u8 slot;\n\t\t\t__u8 function;\n\t\t\t__u8 channel;\n\t\t\t__u32 reserved;\n\t\t} pci;\n\t\tstruct {\n\t\t\t__u64 reserved;\n\t\t} ibnd;\n\t\tstruct {\n\t\t\t__u64 reserved;\n\t\t} xprs;\n\t\tstruct {\n\t\t\t__u64 reserved;\n\t\t} htpt;\n\t\tstruct {\n\t\t\t__u64 reserved;\n\t\t} unknown;\n\t} interface_path;\n\tunion {\n\t\tstruct {\n\t\t\t__u8 device;\n\t\t\t__u8 reserved1;\n\t\t\t__u16 reserved2;\n\t\t\t__u32 reserved3;\n\t\t\t__u64 reserved4;\n\t\t} ata;\n\t\tstruct {\n\t\t\t__u8 device;\n\t\t\t__u8 lun;\n\t\t\t__u8 reserved1;\n\t\t\t__u8 reserved2;\n\t\t\t__u32 reserved3;\n\t\t\t__u64 reserved4;\n\t\t} atapi;\n\t\tstruct {\n\t\t\t__u16 id;\n\t\t\t__u64 lun;\n\t\t\t__u16 reserved1;\n\t\t\t__u32 reserved2;\n\t\t} __attribute__((packed)) scsi;\n\t\tstruct {\n\t\t\t__u64 serial_number;\n\t\t\t__u64 reserved;\n\t\t} usb;\n\t\tstruct {\n\t\t\t__u64 eui;\n\t\t\t__u64 reserved;\n\t\t} i1394;\n\t\tstruct {\n\t\t\t__u64 wwid;\n\t\t\t__u64 lun;\n\t\t} fibre;\n\t\tstruct {\n\t\t\t__u64 identity_tag;\n\t\t\t__u64 reserved;\n\t\t} i2o;\n\t\tstruct {\n\t\t\t__u32 array_number;\n\t\t\t__u32 reserved1;\n\t\t\t__u64 reserved2;\n\t\t} raid;\n\t\tstruct {\n\t\t\t__u8 device;\n\t\t\t__u8 reserved1;\n\t\t\t__u16 reserved2;\n\t\t\t__u32 reserved3;\n\t\t\t__u64 reserved4;\n\t\t} sata;\n\t\tstruct {\n\t\t\t__u64 reserved1;\n\t\t\t__u64 reserved2;\n\t\t} unknown;\n\t} device_path;\n\t__u8 reserved4;\n\t__u8 checksum;\n} __attribute__((packed));\n\nstruct edd_info {\n\t__u8 device;\n\t__u8 version;\n\t__u16 interface_support;\n\t__u16 legacy_max_cylinder;\n\t__u8 legacy_max_head;\n\t__u8 legacy_sectors_per_track;\n\tstruct edd_device_params params;\n} __attribute__((packed));\n\nstruct ist_info {\n\t__u32 signature;\n\t__u32 command;\n\t__u32 event;\n\t__u32 perf_level;\n};\n\nstruct edid_info {\n\tunsigned char dummy[128];\n};\n\nstruct setup_header {\n\t__u8 setup_sects;\n\t__u16 root_flags;\n\t__u32 syssize;\n\t__u16 ram_size;\n\t__u16 vid_mode;\n\t__u16 root_dev;\n\t__u16 boot_flag;\n\t__u16 jump;\n\t__u32 header;\n\t__u16 version;\n\t__u32 realmode_swtch;\n\t__u16 start_sys_seg;\n\t__u16 kernel_version;\n\t__u8 type_of_loader;\n\t__u8 loadflags;\n\t__u16 setup_move_size;\n\t__u32 code32_start;\n\t__u32 ramdisk_image;\n\t__u32 ramdisk_size;\n\t__u32 bootsect_kludge;\n\t__u16 heap_end_ptr;\n\t__u8 ext_loader_ver;\n\t__u8 ext_loader_type;\n\t__u32 cmd_line_ptr;\n\t__u32 initrd_addr_max;\n\t__u32 kernel_alignment;\n\t__u8 relocatable_kernel;\n\t__u8 min_alignment;\n\t__u16 xloadflags;\n\t__u32 cmdline_size;\n\t__u32 hardware_subarch;\n\t__u64 hardware_subarch_data;\n\t__u32 payload_offset;\n\t__u32 payload_length;\n\t__u64 setup_data;\n\t__u64 pref_address;\n\t__u32 init_size;\n\t__u32 handover_offset;\n\t__u32 kernel_info_offset;\n} __attribute__((packed));\n\nstruct sys_desc_table {\n\t__u16 length;\n\t__u8 table[14];\n};\n\nstruct olpc_ofw_header {\n\t__u32 ofw_magic;\n\t__u32 ofw_version;\n\t__u32 cif_handler;\n\t__u32 irq_desc_table;\n};\n\nstruct efi_info {\n\t__u32 efi_loader_signature;\n\t__u32 efi_systab;\n\t__u32 efi_memdesc_size;\n\t__u32 efi_memdesc_version;\n\t__u32 efi_memmap;\n\t__u32 efi_memmap_size;\n\t__u32 efi_systab_hi;\n\t__u32 efi_memmap_hi;\n};\n\nstruct boot_e820_entry {\n\t__u64 addr;\n\t__u64 size;\n\t__u32 type;\n} __attribute__((packed));\n\nstruct boot_params {\n\tstruct screen_info screen_info;\n\tstruct apm_bios_info apm_bios_info;\n\t__u8 _pad2[4];\n\t__u64 tboot_addr;\n\tstruct ist_info ist_info;\n\t__u64 acpi_rsdp_addr;\n\t__u8 _pad3[8];\n\t__u8 hd0_info[16];\n\t__u8 hd1_info[16];\n\tstruct sys_desc_table sys_desc_table;\n\tstruct olpc_ofw_header olpc_ofw_header;\n\t__u32 ext_ramdisk_image;\n\t__u32 ext_ramdisk_size;\n\t__u32 ext_cmd_line_ptr;\n\t__u8 _pad4[116];\n\tstruct edid_info edid_info;\n\tstruct efi_info efi_info;\n\t__u32 alt_mem_k;\n\t__u32 scratch;\n\t__u8 e820_entries;\n\t__u8 eddbuf_entries;\n\t__u8 edd_mbr_sig_buf_entries;\n\t__u8 kbd_status;\n\t__u8 secure_boot;\n\t__u8 _pad5[2];\n\t__u8 sentinel;\n\t__u8 _pad6[1];\n\tstruct setup_header hdr;\n\t__u8 _pad7[36];\n\t__u32 edd_mbr_sig_buffer[16];\n\tstruct boot_e820_entry e820_table[128];\n\t__u8 _pad8[48];\n\tstruct edd_info eddbuf[6];\n\t__u8 _pad9[276];\n} __attribute__((packed));\n\nenum x86_hardware_subarch {\n\tX86_SUBARCH_PC = 0,\n\tX86_SUBARCH_LGUEST = 1,\n\tX86_SUBARCH_XEN = 2,\n\tX86_SUBARCH_INTEL_MID = 3,\n\tX86_SUBARCH_CE4100 = 4,\n\tX86_NR_SUBARCHS = 5,\n};\n\nstruct range {\n\tu64 start;\n\tu64 end;\n};\n\nstruct pt_regs {\n\tlong unsigned int r15;\n\tlong unsigned int r14;\n\tlong unsigned int r13;\n\tlong unsigned int r12;\n\tlong unsigned int bp;\n\tlong unsigned int bx;\n\tlong unsigned int r11;\n\tlong unsigned int r10;\n\tlong unsigned int r9;\n\tlong unsigned int r8;\n\tlong unsigned int ax;\n\tlong unsigned int cx;\n\tlong unsigned int dx;\n\tlong unsigned int si;\n\tlong unsigned int di;\n\tlong unsigned int orig_ax;\n\tlong unsigned int ip;\n\tlong unsigned int cs;\n\tlong unsigned int flags;\n\tlong unsigned int sp;\n\tlong unsigned int ss;\n};\n\nenum {\n\tGATE_INTERRUPT = 14,\n\tGATE_TRAP = 15,\n\tGATE_CALL = 12,\n\tGATE_TASK = 5,\n};\n\nstruct idt_bits {\n\tu16 ist: 3;\n\tu16 zero: 5;\n\tu16 type: 5;\n\tu16 dpl: 2;\n\tu16 p: 1;\n};\n\nstruct idt_data {\n\tunsigned int vector;\n\tunsigned int segment;\n\tstruct idt_bits bits;\n\tconst void *addr;\n};\n\nstruct gate_struct {\n\tu16 offset_low;\n\tu16 segment;\n\tstruct idt_bits bits;\n\tu16 offset_middle;\n\tu32 offset_high;\n\tu32 reserved;\n};\n\ntypedef struct gate_struct gate_desc;\n\nstruct desc_ptr {\n\tshort unsigned int size;\n\tlong unsigned int address;\n} __attribute__((packed));\n\ntypedef long unsigned int pteval_t;\n\ntypedef long unsigned int pmdval_t;\n\ntypedef long unsigned int pudval_t;\n\ntypedef long unsigned int p4dval_t;\n\ntypedef long unsigned int pgdval_t;\n\ntypedef long unsigned int pgprotval_t;\n\ntypedef struct {\n\tpteval_t pte;\n} pte_t;\n\nstruct pgprot {\n\tpgprotval_t pgprot;\n};\n\ntypedef struct pgprot pgprot_t;\n\ntypedef struct {\n\tpgdval_t pgd;\n} pgd_t;\n\ntypedef struct {\n\tp4dval_t p4d;\n} p4d_t;\n\ntypedef struct {\n\tpudval_t pud;\n} pud_t;\n\ntypedef struct {\n\tpmdval_t pmd;\n} pmd_t;\n\ntypedef struct page *pgtable_t;\n\nstruct address_space;\n\nstruct page_pool;\n\nstruct kmem_cache;\n\nstruct dev_pagemap;\n\nstruct page {\n\tlong unsigned int flags;\n\tunion {\n\t\tstruct {\n\t\t\tstruct list_head lru;\n\t\t\tstruct address_space *mapping;\n\t\t\tlong unsigned int index;\n\t\t\tlong unsigned int private;\n\t\t};\n\t\tstruct {\n\t\t\tlong unsigned int pp_magic;\n\t\t\tstruct page_pool *pp;\n\t\t\tlong unsigned int _pp_mapping_pad;\n\t\t\tlong unsigned int dma_addr;\n\t\t\tunion {\n\t\t\t\tlong unsigned int dma_addr_upper;\n\t\t\t\tatomic_long_t pp_frag_count;\n\t\t\t};\n\t\t};\n\t\tstruct {\n\t\t\tunion {\n\t\t\t\tstruct list_head slab_list;\n\t\t\t\tstruct {\n\t\t\t\t\tstruct page *next;\n\t\t\t\t\tint pages;\n\t\t\t\t\tint pobjects;\n\t\t\t\t};\n\t\t\t};\n\t\t\tstruct kmem_cache *slab_cache;\n\t\t\tvoid *freelist;\n\t\t\tunion {\n\t\t\t\tvoid *s_mem;\n\t\t\t\tlong unsigned int counters;\n\t\t\t\tstruct {\n\t\t\t\t\tunsigned int inuse: 16;\n\t\t\t\t\tunsigned int objects: 15;\n\t\t\t\t\tunsigned int frozen: 1;\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\tstruct {\n\t\t\tlong unsigned int compound_head;\n\t\t\tunsigned char compound_dtor;\n\t\t\tunsigned char compound_order;\n\t\t\tatomic_t compound_mapcount;\n\t\t\tunsigned int compound_nr;\n\t\t};\n\t\tstruct {\n\t\t\tlong unsigned int _compound_pad_1;\n\t\t\tatomic_t hpage_pinned_refcount;\n\t\t\tstruct list_head deferred_list;\n\t\t};\n\t\tstruct {\n\t\t\tlong unsigned int _pt_pad_1;\n\t\t\tpgtable_t pmd_huge_pte;\n\t\t\tlong unsigned int _pt_pad_2;\n\t\t\tunion {\n\t\t\t\tstruct mm_struct *pt_mm;\n\t\t\t\tatomic_t pt_frag_refcount;\n\t\t\t};\n\t\t\tspinlock_t ptl;\n\t\t};\n\t\tstruct {\n\t\t\tstruct dev_pagemap *pgmap;\n\t\t\tvoid *zone_device_data;\n\t\t};\n\t\tstruct callback_head callback_head;\n\t};\n\tunion {\n\t\tatomic_t _mapcount;\n\t\tunsigned int page_type;\n\t\tunsigned int active;\n\t\tint units;\n\t};\n\tatomic_t _refcount;\n\tlong unsigned int memcg_data;\n};\n\nstruct paravirt_callee_save {\n\tvoid *func;\n};\n\nstruct pv_lazy_ops {\n\tvoid (*enter)();\n\tvoid (*leave)();\n\tvoid (*flush)();\n};\n\nstruct pv_cpu_ops {\n\tvoid (*io_delay)();\n\tlong unsigned int (*get_debugreg)(int);\n\tvoid (*set_debugreg)(int, long unsigned int);\n\tlong unsigned int (*read_cr0)();\n\tvoid (*write_cr0)(long unsigned int);\n\tvoid (*write_cr4)(long unsigned int);\n\tvoid (*load_tr_desc)();\n\tvoid (*load_gdt)(const struct desc_ptr *);\n\tvoid (*load_idt)(const struct desc_ptr *);\n\tvoid (*set_ldt)(const void *, unsigned int);\n\tlong unsigned int (*store_tr)();\n\tvoid (*load_tls)(struct thread_struct *, unsigned int);\n\tvoid (*load_gs_index)(unsigned int);\n\tvoid (*write_ldt_entry)(struct desc_struct *, int, const void *);\n\tvoid (*write_gdt_entry)(struct desc_struct *, int, const void *, int);\n\tvoid (*write_idt_entry)(gate_desc *, int, const gate_desc *);\n\tvoid (*alloc_ldt)(struct desc_struct *, unsigned int);\n\tvoid (*free_ldt)(struct desc_struct *, unsigned int);\n\tvoid (*load_sp0)(long unsigned int);\n\tvoid (*invalidate_io_bitmap)();\n\tvoid (*update_io_bitmap)();\n\tvoid (*wbinvd)();\n\tvoid (*cpuid)(unsigned int *, unsigned int *, unsigned int *, unsigned int *);\n\tu64 (*read_msr)(unsigned int);\n\tvoid (*write_msr)(unsigned int, unsigned int, unsigned int);\n\tu64 (*read_msr_safe)(unsigned int, int *);\n\tint (*write_msr_safe)(unsigned int, unsigned int, unsigned int);\n\tu64 (*read_pmc)(int);\n\tvoid (*start_context_switch)(struct task_struct *);\n\tvoid (*end_context_switch)(struct task_struct *);\n};\n\nstruct pv_irq_ops {\n\tstruct paravirt_callee_save save_fl;\n\tstruct paravirt_callee_save irq_disable;\n\tstruct paravirt_callee_save irq_enable;\n\tvoid (*safe_halt)();\n\tvoid (*halt)();\n};\n\nstruct flush_tlb_info;\n\nstruct mmu_gather;\n\nstruct pv_mmu_ops {\n\tvoid (*flush_tlb_user)();\n\tvoid (*flush_tlb_kernel)();\n\tvoid (*flush_tlb_one_user)(long unsigned int);\n\tvoid (*flush_tlb_multi)(const struct cpumask *, const struct flush_tlb_info *);\n\tvoid (*tlb_remove_table)(struct mmu_gather *, void *);\n\tvoid (*exit_mmap)(struct mm_struct *);\n\tstruct paravirt_callee_save read_cr2;\n\tvoid (*write_cr2)(long unsigned int);\n\tlong unsigned int (*read_cr3)();\n\tvoid (*write_cr3)(long unsigned int);\n\tvoid (*activate_mm)(struct mm_struct *, struct mm_struct *);\n\tvoid (*dup_mmap)(struct mm_struct *, struct mm_struct *);\n\tint (*pgd_alloc)(struct mm_struct *);\n\tvoid (*pgd_free)(struct mm_struct *, pgd_t *);\n\tvoid (*alloc_pte)(struct mm_struct *, long unsigned int);\n\tvoid (*alloc_pmd)(struct mm_struct *, long unsigned int);\n\tvoid (*alloc_pud)(struct mm_struct *, long unsigned int);\n\tvoid (*alloc_p4d)(struct mm_struct *, long unsigned int);\n\tvoid (*release_pte)(long unsigned int);\n\tvoid (*release_pmd)(long unsigned int);\n\tvoid (*release_pud)(long unsigned int);\n\tvoid (*release_p4d)(long unsigned int);\n\tvoid (*set_pte)(pte_t *, pte_t);\n\tvoid (*set_pmd)(pmd_t *, pmd_t);\n\tpte_t (*ptep_modify_prot_start)(struct vm_area_struct *, long unsigned int, pte_t *);\n\tvoid (*ptep_modify_prot_commit)(struct vm_area_struct *, long unsigned int, pte_t *, pte_t);\n\tstruct paravirt_callee_save pte_val;\n\tstruct paravirt_callee_save make_pte;\n\tstruct paravirt_callee_save pgd_val;\n\tstruct paravirt_callee_save make_pgd;\n\tvoid (*set_pud)(pud_t *, pud_t);\n\tstruct paravirt_callee_save pmd_val;\n\tstruct paravirt_callee_save make_pmd;\n\tstruct paravirt_callee_save pud_val;\n\tstruct paravirt_callee_save make_pud;\n\tvoid (*set_p4d)(p4d_t *, p4d_t);\n\tstruct paravirt_callee_save p4d_val;\n\tstruct paravirt_callee_save make_p4d;\n\tvoid (*set_pgd)(pgd_t *, pgd_t);\n\tstruct pv_lazy_ops lazy_mode;\n\tvoid (*set_fixmap)(unsigned int, phys_addr_t, pgprot_t);\n};\n\nstruct flush_tlb_info {\n\tstruct mm_struct *mm;\n\tlong unsigned int start;\n\tlong unsigned int end;\n\tu64 new_tlb_gen;\n\tunsigned int initiating_cpu;\n\tu8 stride_shift;\n\tu8 freed_tables;\n};\n\nstruct rw_semaphore {\n\tatomic_long_t count;\n\tatomic_long_t owner;\n\tstruct optimistic_spin_queue osq;\n\traw_spinlock_t wait_lock;\n\tstruct list_head wait_list;\n};\n\nstruct mm_rss_stat {\n\tatomic_long_t count[4];\n};\n\nstruct ldt_struct;\n\nstruct vdso_image;\n\ntypedef struct {\n\tu64 ctx_id;\n\tatomic64_t tlb_gen;\n\tstruct rw_semaphore ldt_usr_sem;\n\tstruct ldt_struct *ldt;\n\tshort unsigned int flags;\n\tstruct mutex lock;\n\tvoid *vdso;\n\tconst struct vdso_image *vdso_image;\n\tatomic_t perf_rdpmc_allowed;\n\tu16 pkey_allocation_map;\n\ts16 execute_only_pkey;\n} mm_context_t;\n\nstruct xol_area;\n\nstruct uprobes_state {\n\tstruct xol_area *xol_area;\n};\n\nstruct work_struct;\n\ntypedef void (*work_func_t)(struct work_struct *);\n\nstruct work_struct {\n\tatomic_long_t data;\n\tstruct list_head entry;\n\twork_func_t func;\n};\n\nstruct linux_binfmt;\n\nstruct core_state;\n\nstruct kioctx_table;\n\nstruct user_namespace;\n\nstruct mmu_notifier_subscriptions;\n\nstruct mm_struct {\n\tstruct {\n\t\tstruct vm_area_struct *mmap;\n\t\tstruct rb_root mm_rb;\n\t\tu64 vmacache_seqnum;\n\t\tlong unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);\n\t\tlong unsigned int mmap_base;\n\t\tlong unsigned int mmap_legacy_base;\n\t\tlong unsigned int mmap_compat_base;\n\t\tlong unsigned int mmap_compat_legacy_base;\n\t\tlong unsigned int task_size;\n\t\tlong unsigned int highest_vm_end;\n\t\tpgd_t *pgd;\n\t\tatomic_t membarrier_state;\n\t\tatomic_t mm_users;\n\t\tatomic_t mm_count;\n\t\tatomic_long_t pgtables_bytes;\n\t\tint map_count;\n\t\tspinlock_t page_table_lock;\n\t\tstruct rw_semaphore mmap_lock;\n\t\tstruct list_head mmlist;\n\t\tlong unsigned int hiwater_rss;\n\t\tlong unsigned int hiwater_vm;\n\t\tlong unsigned int total_vm;\n\t\tlong unsigned int locked_vm;\n\t\tatomic64_t pinned_vm;\n\t\tlong unsigned int data_vm;\n\t\tlong unsigned int exec_vm;\n\t\tlong unsigned int stack_vm;\n\t\tlong unsigned int def_flags;\n\t\tseqcount_t write_protect_seq;\n\t\tspinlock_t arg_lock;\n\t\tlong unsigned int start_code;\n\t\tlong unsigned int end_code;\n\t\tlong unsigned int start_data;\n\t\tlong unsigned int end_data;\n\t\tlong unsigned int start_brk;\n\t\tlong unsigned int brk;\n\t\tlong unsigned int start_stack;\n\t\tlong unsigned int arg_start;\n\t\tlong unsigned int arg_end;\n\t\tlong unsigned int env_start;\n\t\tlong unsigned int env_end;\n\t\tlong unsigned int saved_auxv[48];\n\t\tstruct mm_rss_stat rss_stat;\n\t\tstruct linux_binfmt *binfmt;\n\t\tmm_context_t context;\n\t\tlong unsigned int flags;\n\t\tstruct core_state *core_state;\n\t\tspinlock_t ioctx_lock;\n\t\tstruct kioctx_table *ioctx_table;\n\t\tstruct task_struct *owner;\n\t\tstruct user_namespace *user_ns;\n\t\tstruct file *exe_file;\n\t\tstruct mmu_notifier_subscriptions *notifier_subscriptions;\n\t\tlong unsigned int numa_next_scan;\n\t\tlong unsigned int numa_scan_offset;\n\t\tint numa_scan_seq;\n\t\tatomic_t tlb_flush_pending;\n\t\tbool tlb_flush_batched;\n\t\tstruct uprobes_state uprobes_state;\n\t\tatomic_long_t hugetlb_usage;\n\t\tstruct work_struct async_put_work;\n\t\tu32 pasid;\n\t};\n\tlong unsigned int cpu_bitmap[0];\n};\n\nstruct userfaultfd_ctx;\n\nstruct vm_userfaultfd_ctx {\n\tstruct userfaultfd_ctx *ctx;\n};\n\nstruct anon_vma;\n\nstruct vm_operations_struct;\n\nstruct vm_area_struct {\n\tlong unsigned int vm_start;\n\tlong unsigned int vm_end;\n\tstruct vm_area_struct *vm_next;\n\tstruct vm_area_struct *vm_prev;\n\tstruct rb_node vm_rb;\n\tlong unsigned int rb_subtree_gap;\n\tstruct mm_struct *vm_mm;\n\tpgprot_t vm_page_prot;\n\tlong unsigned int vm_flags;\n\tstruct {\n\t\tstruct rb_node rb;\n\t\tlong unsigned int rb_subtree_last;\n\t} shared;\n\tstruct list_head anon_vma_chain;\n\tstruct anon_vma *anon_vma;\n\tconst struct vm_operations_struct *vm_ops;\n\tlong unsigned int vm_pgoff;\n\tstruct file *vm_file;\n\tstruct file *vm_prfile;\n\tvoid *vm_private_data;\n\tatomic_long_t swap_readahead_info;\n\tstruct mempolicy *vm_policy;\n\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx;\n};\n\nstruct pv_lock_ops {\n\tvoid (*queued_spin_lock_slowpath)(struct qspinlock *, u32);\n\tstruct paravirt_callee_save queued_spin_unlock;\n\tvoid (*wait)(u8 *, u8);\n\tvoid (*kick)(int);\n\tstruct paravirt_callee_save vcpu_is_preempted;\n};\n\nstruct paravirt_patch_template {\n\tstruct pv_cpu_ops cpu;\n\tstruct pv_irq_ops irq;\n\tstruct pv_mmu_ops mmu;\n\tstruct pv_lock_ops lock;\n};\n\nstruct math_emu_info {\n\tlong int ___orig_eip;\n\tstruct pt_regs *regs;\n};\n\nenum {\n\tUNAME26 = 131072,\n\tADDR_NO_RANDOMIZE = 262144,\n\tFDPIC_FUNCPTRS = 524288,\n\tMMAP_PAGE_ZERO = 1048576,\n\tADDR_COMPAT_LAYOUT = 2097152,\n\tREAD_IMPLIES_EXEC = 4194304,\n\tADDR_LIMIT_32BIT = 8388608,\n\tSHORT_INODE = 16777216,\n\tWHOLE_SECONDS = 33554432,\n\tSTICKY_TIMEOUTS = 67108864,\n\tADDR_LIMIT_3GB = 134217728,\n};\n\nenum tlb_infos {\n\tENTRIES = 0,\n\tNR_INFO = 1,\n};\n\nenum pcpu_fc {\n\tPCPU_FC_AUTO = 0,\n\tPCPU_FC_EMBED = 1,\n\tPCPU_FC_PAGE = 2,\n\tPCPU_FC_NR = 3,\n};\n\nstruct vm_struct {\n\tstruct vm_struct *next;\n\tvoid *addr;\n\tlong unsigned int size;\n\tlong unsigned int flags;\n\tstruct page **pages;\n\tunsigned int nr_pages;\n\tphys_addr_t phys_addr;\n\tconst void *caller;\n};\n\nstruct wait_queue_head {\n\tspinlock_t lock;\n\tstruct list_head head;\n};\n\ntypedef struct wait_queue_head wait_queue_head_t;\n\nstruct seqcount_raw_spinlock {\n\tseqcount_t seqcount;\n};\n\ntypedef struct seqcount_raw_spinlock seqcount_raw_spinlock_t;\n\ntypedef struct {\n\tseqcount_spinlock_t seqcount;\n\tspinlock_t lock;\n} seqlock_t;\n\nenum node_states {\n\tN_POSSIBLE = 0,\n\tN_ONLINE = 1,\n\tN_NORMAL_MEMORY = 2,\n\tN_HIGH_MEMORY = 2,\n\tN_MEMORY = 3,\n\tN_CPU = 4,\n\tN_GENERIC_INITIATOR = 5,\n\tNR_NODE_STATES = 6,\n};\n\nenum {\n\tMM_FILEPAGES = 0,\n\tMM_ANONPAGES = 1,\n\tMM_SWAPENTS = 2,\n\tMM_SHMEMPAGES = 3,\n\tNR_MM_COUNTERS = 4,\n};\n\nstruct swait_queue_head {\n\traw_spinlock_t lock;\n\tstruct list_head task_list;\n};\n\nstruct completion {\n\tunsigned int done;\n\tstruct swait_queue_head wait;\n};\n\nstruct arch_uprobe_task {\n\tlong unsigned int saved_scratch_register;\n\tunsigned int saved_trap_nr;\n\tunsigned int saved_tf;\n};\n\nenum uprobe_task_state {\n\tUTASK_RUNNING = 0,\n\tUTASK_SSTEP = 1,\n\tUTASK_SSTEP_ACK = 2,\n\tUTASK_SSTEP_TRAPPED = 3,\n};\n\nstruct uprobe;\n\nstruct return_instance;\n\nstruct uprobe_task {\n\tenum uprobe_task_state state;\n\tunion {\n\t\tstruct {\n\t\t\tstruct arch_uprobe_task autask;\n\t\t\tlong unsigned int vaddr;\n\t\t};\n\t\tstruct {\n\t\t\tstruct callback_head dup_xol_work;\n\t\t\tlong unsigned int dup_xol_addr;\n\t\t};\n\t};\n\tstruct uprobe *active_uprobe;\n\tlong unsigned int xol_vaddr;\n\tstruct return_instance *return_instances;\n\tunsigned int depth;\n};\n\nstruct return_instance {\n\tstruct uprobe *uprobe;\n\tlong unsigned int func;\n\tlong unsigned int stack;\n\tlong unsigned int orig_ret_vaddr;\n\tbool chained;\n\tstruct return_instance *next;\n};\n\nstruct vdso_image {\n\tvoid *data;\n\tlong unsigned int size;\n\tlong unsigned int alt;\n\tlong unsigned int alt_len;\n\tlong unsigned int extable_base;\n\tlong unsigned int extable_len;\n\tconst void *extable;\n\tlong int sym_vvar_start;\n\tlong int sym_vvar_page;\n\tlong int sym_pvclock_page;\n\tlong int sym_hvclock_page;\n\tlong int sym_timens_page;\n\tlong int sym_VDSO32_NOTE_MASK;\n\tlong int sym___kernel_sigreturn;\n\tlong int sym___kernel_rt_sigreturn;\n\tlong int sym___kernel_vsyscall;\n\tlong int sym_int80_landing_pad;\n\tlong int sym_vdso32_sigreturn_landing_pad;\n\tlong int sym_vdso32_rt_sigreturn_landing_pad;\n};\n\nstruct xarray {\n\tspinlock_t xa_lock;\n\tgfp_t xa_flags;\n\tvoid *xa_head;\n};\n\ntypedef u32 errseq_t;\n\nstruct address_space_operations;\n\nstruct address_space {\n\tstruct inode *host;\n\tstruct xarray i_pages;\n\tstruct rw_semaphore invalidate_lock;\n\tgfp_t gfp_mask;\n\tatomic_t i_mmap_writable;\n\tstruct rb_root_cached i_mmap;\n\tstruct rw_semaphore i_mmap_rwsem;\n\tlong unsigned int nrpages;\n\tlong unsigned int writeback_index;\n\tconst struct address_space_operations *a_ops;\n\tlong unsigned int flags;\n\terrseq_t wb_err;\n\tspinlock_t private_lock;\n\tstruct list_head private_list;\n\tvoid *private_data;\n};\n\nstruct vmem_altmap {\n\tlong unsigned int base_pfn;\n\tconst long unsigned int end_pfn;\n\tconst long unsigned int reserve;\n\tlong unsigned int free;\n\tlong unsigned int align;\n\tlong unsigned int alloc;\n};\n\nstruct percpu_ref_data;\n\nstruct percpu_ref {\n\tlong unsigned int percpu_count_ptr;\n\tstruct percpu_ref_data *data;\n};\n\nenum memory_type {\n\tMEMORY_DEVICE_PRIVATE = 1,\n\tMEMORY_DEVICE_FS_DAX = 2,\n\tMEMORY_DEVICE_GENERIC = 3,\n\tMEMORY_DEVICE_PCI_P2PDMA = 4,\n};\n\nstruct dev_pagemap_ops;\n\nstruct dev_pagemap {\n\tstruct vmem_altmap altmap;\n\tstruct percpu_ref ref;\n\tstruct completion done;\n\tenum memory_type type;\n\tunsigned int flags;\n\tconst struct dev_pagemap_ops *ops;\n\tvoid *owner;\n\tint nr_range;\n\tunion {\n\t\tstruct range range;\n\t\tstruct range ranges[0];\n\t};\n};\n\nstruct vfsmount;\n\nstruct path {\n\tstruct vfsmount *mnt;\n\tstruct dentry *dentry;\n};\n\nenum rw_hint {\n\tWRITE_LIFE_NOT_SET = 0,\n\tWRITE_LIFE_NONE = 1,\n\tWRITE_LIFE_SHORT = 2,\n\tWRITE_LIFE_MEDIUM = 3,\n\tWRITE_LIFE_LONG = 4,\n\tWRITE_LIFE_EXTREME = 5,\n};\n\nenum pid_type {\n\tPIDTYPE_PID = 0,\n\tPIDTYPE_TGID = 1,\n\tPIDTYPE_PGID = 2,\n\tPIDTYPE_SID = 3,\n\tPIDTYPE_MAX = 4,\n};\n\nstruct fown_struct {\n\trwlock_t lock;\n\tstruct pid *pid;\n\tenum pid_type pid_type;\n\tkuid_t uid;\n\tkuid_t euid;\n\tint signum;\n};\n\nstruct file_ra_state {\n\tlong unsigned int start;\n\tunsigned int size;\n\tunsigned int async_size;\n\tunsigned int ra_pages;\n\tunsigned int mmap_miss;\n\tloff_t prev_pos;\n};\n\nstruct file {\n\tunion {\n\t\tstruct llist_node fu_llist;\n\t\tstruct callback_head fu_rcuhead;\n\t} f_u;\n\tstruct path f_path;\n\tstruct inode *f_inode;\n\tconst struct file_operations *f_op;\n\tspinlock_t f_lock;\n\tenum rw_hint f_write_hint;\n\tatomic_long_t f_count;\n\tunsigned int f_flags;\n\tfmode_t f_mode;\n\tstruct mutex f_pos_lock;\n\tloff_t f_pos;\n\tstruct fown_struct f_owner;\n\tconst struct cred *f_cred;\n\tstruct file_ra_state f_ra;\n\tu64 f_version;\n\tvoid *f_security;\n\tvoid *private_data;\n\tstruct hlist_head *f_ep;\n\tstruct address_space *f_mapping;\n\terrseq_t f_wb_err;\n\terrseq_t f_sb_err;\n};\n\ntypedef unsigned int vm_fault_t;\n\nenum page_entry_size {\n\tPE_SIZE_PTE = 0,\n\tPE_SIZE_PMD = 1,\n\tPE_SIZE_PUD = 2,\n};\n\nstruct vm_fault;\n\nstruct vm_operations_struct {\n\tvoid (*open)(struct vm_area_struct *);\n\tvoid (*close)(struct vm_area_struct *);\n\tint (*may_split)(struct vm_area_struct *, long unsigned int);\n\tint (*mremap)(struct vm_area_struct *);\n\tint (*mprotect)(struct vm_area_struct *, long unsigned int, long unsigned int, long unsigned int);\n\tvm_fault_t (*fault)(struct vm_fault *);\n\tvm_fault_t (*huge_fault)(struct vm_fault *, enum page_entry_size);\n\tvm_fault_t (*map_pages)(struct vm_fault *, long unsigned int, long unsigned int);\n\tlong unsigned int (*pagesize)(struct vm_area_struct *);\n\tvm_fault_t (*page_mkwrite)(struct vm_fault *);\n\tvm_fault_t (*pfn_mkwrite)(struct vm_fault *);\n\tint (*access)(struct vm_area_struct *, long unsigned int, void *, int, int);\n\tconst char * (*name)(struct vm_area_struct *);\n\tint (*set_policy)(struct vm_area_struct *, struct mempolicy *);\n\tstruct mempolicy * (*get_policy)(struct vm_area_struct *, long unsigned int);\n\tstruct page * (*find_special_page)(struct vm_area_struct *, long unsigned int);\n};\n\nstruct core_thread {\n\tstruct task_struct *task;\n\tstruct core_thread *next;\n};\n\nstruct core_state {\n\tatomic_t nr_threads;\n\tstruct core_thread dumper;\n\tstruct completion startup;\n};\n\nenum fault_flag {\n\tFAULT_FLAG_WRITE = 1,\n\tFAULT_FLAG_MKWRITE = 2,\n\tFAULT_FLAG_ALLOW_RETRY = 4,\n\tFAULT_FLAG_RETRY_NOWAIT = 8,\n\tFAULT_FLAG_KILLABLE = 16,\n\tFAULT_FLAG_TRIED = 32,\n\tFAULT_FLAG_USER = 64,\n\tFAULT_FLAG_REMOTE = 128,\n\tFAULT_FLAG_INSTRUCTION = 256,\n\tFAULT_FLAG_INTERRUPTIBLE = 512,\n};\n\nstruct vm_fault {\n\tconst struct {\n\t\tstruct vm_area_struct *vma;\n\t\tgfp_t gfp_mask;\n\t\tlong unsigned int pgoff;\n\t\tlong unsigned int address;\n\t};\n\tenum fault_flag flags;\n\tpmd_t *pmd;\n\tpud_t *pud;\n\tunion {\n\t\tpte_t orig_pte;\n\t\tpmd_t orig_pmd;\n\t};\n\tstruct page *cow_page;\n\tstruct page *page;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\tpgtable_t prealloc_pte;\n};\n\nenum migratetype {\n\tMIGRATE_UNMOVABLE = 0,\n\tMIGRATE_MOVABLE = 1,\n\tMIGRATE_RECLAIMABLE = 2,\n\tMIGRATE_PCPTYPES = 3,\n\tMIGRATE_HIGHATOMIC = 3,\n\tMIGRATE_ISOLATE = 4,\n\tMIGRATE_TYPES = 5,\n};\n\nenum numa_stat_item {\n\tNUMA_HIT = 0,\n\tNUMA_MISS = 1,\n\tNUMA_FOREIGN = 2,\n\tNUMA_INTERLEAVE_HIT = 3,\n\tNUMA_LOCAL = 4,\n\tNUMA_OTHER = 5,\n\tNR_VM_NUMA_EVENT_ITEMS = 6,\n};\n\nenum zone_stat_item {\n\tNR_FREE_PAGES = 0,\n\tNR_ZONE_LRU_BASE = 1,\n\tNR_ZONE_INACTIVE_ANON = 1,\n\tNR_ZONE_ACTIVE_ANON = 2,\n\tNR_ZONE_INACTIVE_FILE = 3,\n\tNR_ZONE_ACTIVE_FILE = 4,\n\tNR_ZONE_UNEVICTABLE = 5,\n\tNR_ZONE_WRITE_PENDING = 6,\n\tNR_MLOCK = 7,\n\tNR_BOUNCE = 8,\n\tNR_ZSPAGES = 9,\n\tNR_FREE_CMA_PAGES = 10,\n\tNR_VM_ZONE_STAT_ITEMS = 11,\n};\n\nenum node_stat_item {\n\tNR_LRU_BASE = 0,\n\tNR_INACTIVE_ANON = 0,\n\tNR_ACTIVE_ANON = 1,\n\tNR_INACTIVE_FILE = 2,\n\tNR_ACTIVE_FILE = 3,\n\tNR_UNEVICTABLE = 4,\n\tNR_SLAB_RECLAIMABLE_B = 5,\n\tNR_SLAB_UNRECLAIMABLE_B = 6,\n\tNR_ISOLATED_ANON = 7,\n\tNR_ISOLATED_FILE = 8,\n\tWORKINGSET_NODES = 9,\n\tWORKINGSET_REFAULT_BASE = 10,\n\tWORKINGSET_REFAULT_ANON = 10,\n\tWORKINGSET_REFAULT_FILE = 11,\n\tWORKINGSET_ACTIVATE_BASE = 12,\n\tWORKINGSET_ACTIVATE_ANON = 12,\n\tWORKINGSET_ACTIVATE_FILE = 13,\n\tWORKINGSET_RESTORE_BASE = 14,\n\tWORKINGSET_RESTORE_ANON = 14,\n\tWORKINGSET_RESTORE_FILE = 15,\n\tWORKINGSET_NODERECLAIM = 16,\n\tNR_ANON_MAPPED = 17,\n\tNR_FILE_MAPPED = 18,\n\tNR_FILE_PAGES = 19,\n\tNR_FILE_DIRTY = 20,\n\tNR_WRITEBACK = 21,\n\tNR_WRITEBACK_TEMP = 22,\n\tNR_SHMEM = 23,\n\tNR_SHMEM_THPS = 24,\n\tNR_SHMEM_PMDMAPPED = 25,\n\tNR_FILE_THPS = 26,\n\tNR_FILE_PMDMAPPED = 27,\n\tNR_ANON_THPS = 28,\n\tNR_VMSCAN_WRITE = 29,\n\tNR_VMSCAN_IMMEDIATE = 30,\n\tNR_DIRTIED = 31,\n\tNR_WRITTEN = 32,\n\tNR_KERNEL_MISC_RECLAIMABLE = 33,\n\tNR_FOLL_PIN_ACQUIRED = 34,\n\tNR_FOLL_PIN_RELEASED = 35,\n\tNR_KERNEL_STACK_KB = 36,\n\tNR_PAGETABLE = 37,\n\tNR_SWAPCACHE = 38,\n\tNR_VM_NODE_STAT_ITEMS = 39,\n};\n\nenum lru_list {\n\tLRU_INACTIVE_ANON = 0,\n\tLRU_ACTIVE_ANON = 1,\n\tLRU_INACTIVE_FILE = 2,\n\tLRU_ACTIVE_FILE = 3,\n\tLRU_UNEVICTABLE = 4,\n\tNR_LRU_LISTS = 5,\n};\n\ntypedef unsigned int isolate_mode_t;\n\nenum zone_watermarks {\n\tWMARK_MIN = 0,\n\tWMARK_LOW = 1,\n\tWMARK_HIGH = 2,\n\tNR_WMARK = 3,\n};\n\nenum {\n\tZONELIST_FALLBACK = 0,\n\tZONELIST_NOFALLBACK = 1,\n\tMAX_ZONELISTS = 2,\n};\n\ntypedef void percpu_ref_func_t(struct percpu_ref *);\n\nstruct percpu_ref_data {\n\tatomic_long_t count;\n\tpercpu_ref_func_t *release;\n\tpercpu_ref_func_t *confirm_switch;\n\tbool force_atomic: 1;\n\tbool allow_reinit: 1;\n\tstruct callback_head rcu;\n\tstruct percpu_ref *ref;\n};\n\nstruct shrink_control {\n\tgfp_t gfp_mask;\n\tint nid;\n\tlong unsigned int nr_to_scan;\n\tlong unsigned int nr_scanned;\n\tstruct mem_cgroup *memcg;\n};\n\nstruct shrinker {\n\tlong unsigned int (*count_objects)(struct shrinker *, struct shrink_control *);\n\tlong unsigned int (*scan_objects)(struct shrinker *, struct shrink_control *);\n\tlong int batch;\n\tint seeks;\n\tunsigned int flags;\n\tstruct list_head list;\n\tint id;\n\tatomic_long_t *nr_deferred;\n};\n\nstruct rlimit {\n\t__kernel_ulong_t rlim_cur;\n\t__kernel_ulong_t rlim_max;\n};\n\nstruct dev_pagemap_ops {\n\tvoid (*page_free)(struct page *);\n\tvm_fault_t (*migrate_to_ram)(struct vm_fault *);\n};\n\nstruct pid_namespace;\n\nstruct upid {\n\tint nr;\n\tstruct pid_namespace *ns;\n};\n\nstruct pid {\n\trefcount_t count;\n\tunsigned int level;\n\tspinlock_t lock;\n\tstruct hlist_head tasks[4];\n\tstruct hlist_head inodes;\n\twait_queue_head_t wait_pidfd;\n\tstruct callback_head rcu;\n\tstruct upid numbers[1];\n};\n\ntypedef struct {\n\tgid_t val;\n} kgid_t;\n\nstruct hrtimer_cpu_base;\n\nstruct hrtimer_clock_base {\n\tstruct hrtimer_cpu_base *cpu_base;\n\tunsigned int index;\n\tclockid_t clockid;\n\tseqcount_raw_spinlock_t seq;\n\tstruct hrtimer *running;\n\tstruct timerqueue_head active;\n\tktime_t (*get_time)();\n\tktime_t offset;\n};\n\nstruct hrtimer_cpu_base {\n\traw_spinlock_t lock;\n\tunsigned int cpu;\n\tunsigned int active_bases;\n\tunsigned int clock_was_set_seq;\n\tunsigned int hres_active: 1;\n\tunsigned int in_hrtirq: 1;\n\tunsigned int hang_detected: 1;\n\tunsigned int softirq_activated: 1;\n\tunsigned int nr_events;\n\tshort unsigned int nr_retries;\n\tshort unsigned int nr_hangs;\n\tunsigned int max_hang_time;\n\tktime_t expires_next;\n\tstruct hrtimer *next_timer;\n\tktime_t softirq_expires_next;\n\tstruct hrtimer *softirq_next_timer;\n\tstruct hrtimer_clock_base clock_base[8];\n};\n\nenum hrtimer_base_type {\n\tHRTIMER_BASE_MONOTONIC = 0,\n\tHRTIMER_BASE_REALTIME = 1,\n\tHRTIMER_BASE_BOOTTIME = 2,\n\tHRTIMER_BASE_TAI = 3,\n\tHRTIMER_BASE_MONOTONIC_SOFT = 4,\n\tHRTIMER_BASE_REALTIME_SOFT = 5,\n\tHRTIMER_BASE_BOOTTIME_SOFT = 6,\n\tHRTIMER_BASE_TAI_SOFT = 7,\n\tHRTIMER_MAX_CLOCK_BASES = 8,\n};\n\ntypedef void __signalfn_t(int);\n\ntypedef __signalfn_t *__sighandler_t;\n\ntypedef void __restorefn_t();\n\ntypedef __restorefn_t *__sigrestore_t;\n\nunion sigval {\n\tint sival_int;\n\tvoid *sival_ptr;\n};\n\ntypedef union sigval sigval_t;\n\nunion __sifields {\n\tstruct {\n\t\t__kernel_pid_t _pid;\n\t\t__kernel_uid32_t _uid;\n\t} _kill;\n\tstruct {\n\t\t__kernel_timer_t _tid;\n\t\tint _overrun;\n\t\tsigval_t _sigval;\n\t\tint _sys_private;\n\t} _timer;\n\tstruct {\n\t\t__kernel_pid_t _pid;\n\t\t__kernel_uid32_t _uid;\n\t\tsigval_t _sigval;\n\t} _rt;\n\tstruct {\n\t\t__kernel_pid_t _pid;\n\t\t__kernel_uid32_t _uid;\n\t\tint _status;\n\t\t__kernel_clock_t _utime;\n\t\t__kernel_clock_t _stime;\n\t} _sigchld;\n\tstruct {\n\t\tvoid *_addr;\n\t\tunion {\n\t\t\tint _trapno;\n\t\t\tshort int _addr_lsb;\n\t\t\tstruct {\n\t\t\t\tchar _dummy_bnd[8];\n\t\t\t\tvoid *_lower;\n\t\t\t\tvoid *_upper;\n\t\t\t} _addr_bnd;\n\t\t\tstruct {\n\t\t\t\tchar _dummy_pkey[8];\n\t\t\t\t__u32 _pkey;\n\t\t\t} _addr_pkey;\n\t\t\tstruct {\n\t\t\t\tlong unsigned int _data;\n\t\t\t\t__u32 _type;\n\t\t\t\t__u32 _flags;\n\t\t\t} _perf;\n\t\t};\n\t} _sigfault;\n\tstruct {\n\t\tlong int _band;\n\t\tint _fd;\n\t} _sigpoll;\n\tstruct {\n\t\tvoid *_call_addr;\n\t\tint _syscall;\n\t\tunsigned int _arch;\n\t} _sigsys;\n};\n\nstruct kernel_siginfo {\n\tstruct {\n\t\tint si_signo;\n\t\tint si_errno;\n\t\tint si_code;\n\t\tunion __sifields _sifields;\n\t};\n};\n\nstruct sigaction {\n\t__sighandler_t sa_handler;\n\tlong unsigned int sa_flags;\n\t__sigrestore_t sa_restorer;\n\tsigset_t sa_mask;\n};\n\nstruct k_sigaction {\n\tstruct sigaction sa;\n};\n\nstruct cpu_itimer {\n\tu64 expires;\n\tu64 incr;\n};\n\nstruct task_cputime_atomic {\n\tatomic64_t utime;\n\tatomic64_t stime;\n\tatomic64_t sum_exec_runtime;\n};\n\nstruct thread_group_cputimer {\n\tstruct task_cputime_atomic cputime_atomic;\n};\n\nstruct pacct_struct {\n\tint ac_flag;\n\tlong int ac_exitcode;\n\tlong unsigned int ac_mem;\n\tu64 ac_utime;\n\tu64 ac_stime;\n\tlong unsigned int ac_minflt;\n\tlong unsigned int ac_majflt;\n};\n\nstruct tty_struct;\n\nstruct autogroup;\n\nstruct taskstats;\n\nstruct tty_audit_buf;\n\nstruct signal_struct {\n\trefcount_t sigcnt;\n\tatomic_t live;\n\tint nr_threads;\n\tstruct list_head thread_head;\n\twait_queue_head_t wait_chldexit;\n\tstruct task_struct *curr_target;\n\tstruct sigpending shared_pending;\n\tstruct hlist_head multiprocess;\n\tint group_exit_code;\n\tint notify_count;\n\tstruct task_struct *group_exit_task;\n\tint group_stop_count;\n\tunsigned int flags;\n\tunsigned int is_child_subreaper: 1;\n\tunsigned int has_child_subreaper: 1;\n\tint posix_timer_id;\n\tstruct list_head posix_timers;\n\tstruct hrtimer real_timer;\n\tktime_t it_real_incr;\n\tstruct cpu_itimer it[2];\n\tstruct thread_group_cputimer cputimer;\n\tstruct posix_cputimers posix_cputimers;\n\tstruct pid *pids[4];\n\tstruct pid *tty_old_pgrp;\n\tint leader;\n\tstruct tty_struct *tty;\n\tstruct autogroup *autogroup;\n\tseqlock_t stats_lock;\n\tu64 utime;\n\tu64 stime;\n\tu64 cutime;\n\tu64 cstime;\n\tu64 gtime;\n\tu64 cgtime;\n\tstruct prev_cputime prev_cputime;\n\tlong unsigned int nvcsw;\n\tlong unsigned int nivcsw;\n\tlong unsigned int cnvcsw;\n\tlong unsigned int cnivcsw;\n\tlong unsigned int min_flt;\n\tlong unsigned int maj_flt;\n\tlong unsigned int cmin_flt;\n\tlong unsigned int cmaj_flt;\n\tlong unsigned int inblock;\n\tlong unsigned int oublock;\n\tlong unsigned int cinblock;\n\tlong unsigned int coublock;\n\tlong unsigned int maxrss;\n\tlong unsigned int cmaxrss;\n\tstruct task_io_accounting ioac;\n\tlong long unsigned int sum_sched_runtime;\n\tstruct rlimit rlim[16];\n\tstruct pacct_struct pacct;\n\tstruct taskstats *stats;\n\tunsigned int audit_tty;\n\tstruct tty_audit_buf *tty_audit_buf;\n\tbool oom_flag_origin;\n\tshort int oom_score_adj;\n\tshort int oom_score_adj_min;\n\tstruct mm_struct *oom_mm;\n\tstruct mutex cred_guard_mutex;\n\tstruct rw_semaphore exec_update_lock;\n};\n\nenum rseq_cs_flags_bit {\n\tRSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT = 0,\n\tRSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT = 1,\n\tRSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT = 2,\n};\n\nstruct rseq {\n\t__u32 cpu_id_start;\n\t__u32 cpu_id;\n\t__u64 rseq_cs;\n\t__u32 flags;\n\tlong: 32;\n\tlong: 64;\n};\n\nenum uclamp_id {\n\tUCLAMP_MIN = 0,\n\tUCLAMP_MAX = 1,\n\tUCLAMP_CNT = 2,\n};\n\nenum perf_event_task_context {\n\tperf_invalid_context = 4294967295,\n\tperf_hw_context = 0,\n\tperf_sw_context = 1,\n\tperf_nr_task_contexts = 2,\n};\n\nstruct rq;\n\nstruct rq_flags;\n\nstruct sched_class {\n\tint uclamp_enabled;\n\tvoid (*enqueue_task)(struct rq *, struct task_struct *, int);\n\tvoid (*dequeue_task)(struct rq *, struct task_struct *, int);\n\tvoid (*yield_task)(struct rq *);\n\tbool (*yield_to_task)(struct rq *, struct task_struct *);\n\tvoid (*check_preempt_curr)(struct rq *, struct task_struct *, int);\n\tstruct task_struct * (*pick_next_task)(struct rq *);\n\tvoid (*put_prev_task)(struct rq *, struct task_struct *);\n\tvoid (*set_next_task)(struct rq *, struct task_struct *, bool);\n\tint (*balance)(struct rq *, struct task_struct *, struct rq_flags *);\n\tint (*select_task_rq)(struct task_struct *, int, int);\n\tstruct task_struct * (*pick_task)(struct rq *);\n\tvoid (*migrate_task_rq)(struct task_struct *, int);\n\tvoid (*task_woken)(struct rq *, struct task_struct *);\n\tvoid (*set_cpus_allowed)(struct task_struct *, const struct cpumask *, u32);\n\tvoid (*rq_online)(struct rq *);\n\tvoid (*rq_offline)(struct rq *);\n\tstruct rq * (*find_lock_rq)(struct task_struct *, struct rq *);\n\tvoid (*task_tick)(struct rq *, struct task_struct *, int);\n\tvoid (*task_fork)(struct task_struct *);\n\tvoid (*task_dead)(struct task_struct *);\n\tvoid (*switched_from)(struct rq *, struct task_struct *);\n\tvoid (*switched_to)(struct rq *, struct task_struct *);\n\tvoid (*prio_changed)(struct rq *, struct task_struct *, int);\n\tunsigned int (*get_rr_interval)(struct rq *, struct task_struct *);\n\tvoid (*update_curr)(struct rq *);\n\tvoid (*task_change_group)(struct task_struct *, int);\n};\n\nstruct kernel_cap_struct {\n\t__u32 cap[2];\n};\n\ntypedef struct kernel_cap_struct kernel_cap_t;\n\nstruct user_struct;\n\nstruct ucounts;\n\nstruct group_info;\n\nstruct cred {\n\tatomic_t usage;\n\tkuid_t uid;\n\tkgid_t gid;\n\tkuid_t suid;\n\tkgid_t sgid;\n\tkuid_t euid;\n\tkgid_t egid;\n\tkuid_t fsuid;\n\tkgid_t fsgid;\n\tunsigned int securebits;\n\tkernel_cap_t cap_inheritable;\n\tkernel_cap_t cap_permitted;\n\tkernel_cap_t cap_effective;\n\tkernel_cap_t cap_bset;\n\tkernel_cap_t cap_ambient;\n\tunsigned char jit_keyring;\n\tstruct key *session_keyring;\n\tstruct key *process_keyring;\n\tstruct key *thread_keyring;\n\tstruct key *request_key_auth;\n\tvoid *security;\n\tstruct user_struct *user;\n\tstruct user_namespace *user_ns;\n\tstruct ucounts *ucounts;\n\tstruct group_info *group_info;\n\tunion {\n\t\tint non_rcu;\n\t\tstruct callback_head rcu;\n\t};\n};\n\ntypedef int32_t key_serial_t;\n\ntypedef uint32_t key_perm_t;\n\nstruct key_type;\n\nstruct key_tag;\n\nstruct keyring_index_key {\n\tlong unsigned int hash;\n\tunion {\n\t\tstruct {\n\t\t\tu16 desc_len;\n\t\t\tchar desc[6];\n\t\t};\n\t\tlong unsigned int x;\n\t};\n\tstruct key_type *type;\n\tstruct key_tag *domain_tag;\n\tconst char *description;\n};\n\nunion key_payload {\n\tvoid *rcu_data0;\n\tvoid *data[4];\n};\n\nstruct assoc_array_ptr;\n\nstruct assoc_array {\n\tstruct assoc_array_ptr *root;\n\tlong unsigned int nr_leaves_on_tree;\n};\n\nstruct watch_list;\n\nstruct key_user;\n\nstruct key_restriction;\n\nstruct key {\n\trefcount_t usage;\n\tkey_serial_t serial;\n\tunion {\n\t\tstruct list_head graveyard_link;\n\t\tstruct rb_node serial_node;\n\t};\n\tstruct watch_list *watchers;\n\tstruct rw_semaphore sem;\n\tstruct key_user *user;\n\tvoid *security;\n\tunion {\n\t\ttime64_t expiry;\n\t\ttime64_t revoked_at;\n\t};\n\ttime64_t last_used_at;\n\tkuid_t uid;\n\tkgid_t gid;\n\tkey_perm_t perm;\n\tshort unsigned int quotalen;\n\tshort unsigned int datalen;\n\tshort int state;\n\tlong unsigned int flags;\n\tunion {\n\t\tstruct keyring_index_key index_key;\n\t\tstruct {\n\t\t\tlong unsigned int hash;\n\t\t\tlong unsigned int len_desc;\n\t\t\tstruct key_type *type;\n\t\t\tstruct key_tag *domain_tag;\n\t\t\tchar *description;\n\t\t};\n\t};\n\tunion {\n\t\tunion key_payload payload;\n\t\tstruct {\n\t\t\tstruct list_head name_link;\n\t\t\tstruct assoc_array keys;\n\t\t};\n\t};\n\tstruct key_restriction *restrict_link;\n};\n\nstruct sighand_struct {\n\tspinlock_t siglock;\n\trefcount_t count;\n\twait_queue_head_t signalfd_wqh;\n\tstruct k_sigaction action[64];\n};\n\nstruct io_cq;\n\nstruct io_context {\n\tatomic_long_t refcount;\n\tatomic_t active_ref;\n\tatomic_t nr_tasks;\n\tspinlock_t lock;\n\tshort unsigned int ioprio;\n\tstruct xarray icq_tree;\n\tstruct io_cq *icq_hint;\n\tstruct hlist_head icq_list;\n\tstruct work_struct release_work;\n};\n\nenum rseq_event_mask_bits {\n\tRSEQ_EVENT_PREEMPT_BIT = 0,\n\tRSEQ_EVENT_SIGNAL_BIT = 1,\n\tRSEQ_EVENT_MIGRATE_BIT = 2,\n};\n\nenum fixed_addresses {\n\tVSYSCALL_PAGE = 511,\n\tFIX_DBGP_BASE = 512,\n\tFIX_EARLYCON_MEM_BASE = 513,\n\tFIX_APIC_BASE = 514,\n\tFIX_IO_APIC_BASE_0 = 515,\n\tFIX_IO_APIC_BASE_END = 642,\n\tFIX_PARAVIRT_BOOTMAP = 643,\n\tFIX_APEI_GHES_IRQ = 644,\n\tFIX_APEI_GHES_NMI = 645,\n\t__end_of_permanent_fixed_addresses = 646,\n\tFIX_BTMAP_END = 1024,\n\tFIX_BTMAP_BEGIN = 1535,\n\tFIX_TBOOT_BASE = 1536,\n\t__end_of_fixed_addresses = 1537,\n};\n\nstruct hlist_bl_node;\n\nstruct hlist_bl_head {\n\tstruct hlist_bl_node *first;\n};\n\nstruct hlist_bl_node {\n\tstruct hlist_bl_node *next;\n\tstruct hlist_bl_node **pprev;\n};\n\nstruct lockref {\n\tunion {\n\t\t__u64 lock_count;\n\t\tstruct {\n\t\t\tspinlock_t lock;\n\t\t\tint count;\n\t\t};\n\t};\n};\n\nstruct qstr {\n\tunion {\n\t\tstruct {\n\t\t\tu32 hash;\n\t\t\tu32 len;\n\t\t};\n\t\tu64 hash_len;\n\t};\n\tconst unsigned char *name;\n};\n\nstruct dentry_operations;\n\nstruct dentry {\n\tunsigned int d_flags;\n\tseqcount_spinlock_t d_seq;\n\tstruct hlist_bl_node d_hash;\n\tstruct dentry *d_parent;\n\tstruct qstr d_name;\n\tstruct inode *d_inode;\n\tunsigned char d_iname[32];\n\tstruct lockref d_lockref;\n\tconst struct dentry_operations *d_op;\n\tstruct super_block *d_sb;\n\tlong unsigned int d_time;\n\tvoid *d_fsdata;\n\tunion {\n\t\tstruct list_head d_lru;\n\t\twait_queue_head_t *d_wait;\n\t};\n\tstruct list_head d_child;\n\tstruct list_head d_subdirs;\n\tunion {\n\t\tstruct hlist_node d_alias;\n\t\tstruct hlist_bl_node d_in_lookup_hash;\n\t\tstruct callback_head d_rcu;\n\t} d_u;\n};\n\nstruct posix_acl;\n\nstruct inode_operations;\n\nstruct bdi_writeback;\n\nstruct file_lock_context;\n\nstruct cdev;\n\nstruct fsnotify_mark_connector;\n\nstruct fscrypt_info;\n\nstruct fsverity_info;\n\nstruct inode {\n\tumode_t i_mode;\n\tshort unsigned int i_opflags;\n\tkuid_t i_uid;\n\tkgid_t i_gid;\n\tunsigned int i_flags;\n\tstruct posix_acl *i_acl;\n\tstruct posix_acl *i_default_acl;\n\tconst struct inode_operations *i_op;\n\tstruct super_block *i_sb;\n\tstruct address_space *i_mapping;\n\tvoid *i_security;\n\tlong unsigned int i_ino;\n\tunion {\n\t\tconst unsigned int i_nlink;\n\t\tunsigned int __i_nlink;\n\t};\n\tdev_t i_rdev;\n\tloff_t i_size;\n\tstruct timespec64 __i_atime;\n\tstruct timespec64 __i_mtime;\n\tstruct timespec64 __i_ctime;\n\tspinlock_t i_lock;\n\tshort unsigned int i_bytes;\n\tu8 i_blkbits;\n\tu8 i_write_hint;\n\tblkcnt_t i_blocks;\n\tlong unsigned int i_state;\n\tstruct rw_semaphore i_rwsem;\n\tlong unsigned int dirtied_when;\n\tlong unsigned int dirtied_time_when;\n\tstruct hlist_node i_hash;\n\tstruct list_head i_io_list;\n\tstruct bdi_writeback *i_wb;\n\tint i_wb_frn_winner;\n\tu16 i_wb_frn_avg_time;\n\tu16 i_wb_frn_history;\n\tstruct list_head i_lru;\n\tstruct list_head i_sb_list;\n\tstruct list_head i_wb_list;\n\tunion {\n\t\tstruct hlist_head i_dentry;\n\t\tstruct callback_head i_rcu;\n\t};\n\tatomic64_t i_version;\n\tatomic64_t i_sequence;\n\tatomic_t i_count;\n\tatomic_t i_dio_count;\n\tatomic_t i_writecount;\n\tatomic_t i_readcount;\n\tunion {\n\t\tconst struct file_operations *i_fop;\n\t\tvoid (*free_inode)(struct inode *);\n\t};\n\tstruct file_lock_context *i_flctx;\n\tstruct address_space i_data;\n\tstruct list_head i_devices;\n\tunion {\n\t\tstruct pipe_inode_info *i_pipe;\n\t\tstruct cdev *i_cdev;\n\t\tchar *i_link;\n\t\tunsigned int i_dir_seq;\n\t};\n\t__u32 i_generation;\n\t__u32 i_fsnotify_mask;\n\tstruct fsnotify_mark_connector *i_fsnotify_marks;\n\tstruct fscrypt_info *i_crypt_info;\n\tstruct fsverity_info *i_verity_info;\n\tvoid *i_private;\n};\n\nstruct dentry_operations {\n\tint (*d_revalidate)(struct dentry *, unsigned int);\n\tint (*d_weak_revalidate)(struct dentry *, unsigned int);\n\tint (*d_hash)(const struct dentry *, struct qstr *);\n\tint (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *);\n\tint (*d_delete)(const struct dentry *);\n\tint (*d_init)(struct dentry *);\n\tvoid (*d_release)(struct dentry *);\n\tvoid (*d_prune)(struct dentry *);\n\tvoid (*d_iput)(struct dentry *, struct inode *);\n\tchar * (*d_dname)(struct dentry *, char *, int);\n\tstruct vfsmount * (*d_automount)(struct path *);\n\tint (*d_manage)(const struct path *, bool);\n\tstruct dentry * (*d_real)(struct dentry *, const struct inode *);\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct mtd_info;\n\ntypedef long long int qsize_t;\n\nstruct quota_format_type;\n\nstruct mem_dqinfo {\n\tstruct quota_format_type *dqi_format;\n\tint dqi_fmt_id;\n\tstruct list_head dqi_dirty_list;\n\tlong unsigned int dqi_flags;\n\tunsigned int dqi_bgrace;\n\tunsigned int dqi_igrace;\n\tqsize_t dqi_max_spc_limit;\n\tqsize_t dqi_max_ino_limit;\n\tvoid *dqi_priv;\n};\n\nstruct quota_format_ops;\n\nstruct quota_info {\n\tunsigned int flags;\n\tstruct rw_semaphore dqio_sem;\n\tstruct inode *files[3];\n\tstruct mem_dqinfo info[3];\n\tconst struct quota_format_ops *ops[3];\n};\n\nstruct rcu_sync {\n\tint gp_state;\n\tint gp_count;\n\twait_queue_head_t gp_wait;\n\tstruct callback_head cb_head;\n};\n\nstruct rcuwait {\n\tstruct task_struct *task;\n};\n\nstruct percpu_rw_semaphore {\n\tstruct rcu_sync rss;\n\tunsigned int *read_count;\n\tstruct rcuwait writer;\n\twait_queue_head_t waiters;\n\tatomic_t block;\n};\n\nstruct sb_writers {\n\tint frozen;\n\twait_queue_head_t wait_unfrozen;\n\tstruct percpu_rw_semaphore rw_sem[3];\n};\n\ntypedef struct {\n\t__u8 b[16];\n} uuid_t;\n\nstruct list_lru_node;\n\nstruct list_lru {\n\tstruct list_lru_node *node;\n\tstruct list_head list;\n\tint shrinker_id;\n\tbool memcg_aware;\n};\n\nstruct super_operations;\n\nstruct dquot_operations;\n\nstruct quotactl_ops;\n\nstruct export_operations;\n\nstruct xattr_handler;\n\nstruct fscrypt_operations;\n\nstruct fsverity_operations;\n\nstruct unicode_map;\n\nstruct block_device;\n\nstruct workqueue_struct;\n\nstruct super_block {\n\tstruct list_head s_list;\n\tdev_t s_dev;\n\tunsigned char s_blocksize_bits;\n\tlong unsigned int s_blocksize;\n\tloff_t s_maxbytes;\n\tstruct file_system_type *s_type;\n\tconst struct super_operations *s_op;\n\tconst struct dquot_operations *dq_op;\n\tconst struct quotactl_ops *s_qcop;\n\tconst struct export_operations *s_export_op;\n\tlong unsigned int s_flags;\n\tlong unsigned int s_iflags;\n\tlong unsigned int s_magic;\n\tstruct dentry *s_root;\n\tstruct rw_semaphore s_umount;\n\tint s_count;\n\tatomic_t s_active;\n\tvoid *s_security;\n\tconst struct xattr_handler **s_xattr;\n\tconst struct fscrypt_operations *s_cop;\n\tstruct key *s_master_keys;\n\tconst struct fsverity_operations *s_vop;\n\tstruct unicode_map *s_encoding;\n\t__u16 s_encoding_flags;\n\tstruct hlist_bl_head s_roots;\n\tstruct list_head s_mounts;\n\tstruct block_device *s_bdev;\n\tstruct backing_dev_info *s_bdi;\n\tstruct mtd_info *s_mtd;\n\tstruct hlist_node s_instances;\n\tunsigned int s_quota_types;\n\tstruct quota_info s_dquot;\n\tstruct sb_writers s_writers;\n\tvoid *s_fs_info;\n\tu32 s_time_gran;\n\ttime64_t s_time_min;\n\ttime64_t s_time_max;\n\t__u32 s_fsnotify_mask;\n\tstruct fsnotify_mark_connector *s_fsnotify_marks;\n\tchar s_id[32];\n\tuuid_t s_uuid;\n\tunsigned int s_max_links;\n\tfmode_t s_mode;\n\tstruct mutex s_vfs_rename_mutex;\n\tconst char *s_subtype;\n\tconst struct dentry_operations *s_d_op;\n\tint cleancache_poolid;\n\tstruct shrinker s_shrink;\n\tatomic_long_t s_remove_count;\n\tatomic_long_t s_fsnotify_connectors;\n\tint s_readonly_remount;\n\terrseq_t s_wb_err;\n\tstruct workqueue_struct *s_dio_done_wq;\n\tstruct hlist_head s_pins;\n\tstruct user_namespace *s_user_ns;\n\tstruct list_lru s_dentry_lru;\n\tstruct list_lru s_inode_lru;\n\tstruct callback_head rcu;\n\tstruct work_struct destroy_work;\n\tstruct mutex s_sync_lock;\n\tint s_stack_depth;\n\tint: 32;\n\tspinlock_t s_inode_list_lock;\n\tstruct list_head s_inodes;\n\tspinlock_t s_inode_wblist_lock;\n\tstruct list_head s_inodes_wb;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct vfsmount {\n\tstruct dentry *mnt_root;\n\tstruct super_block *mnt_sb;\n\tint mnt_flags;\n\tstruct user_namespace *mnt_userns;\n};\n\nstruct kstat {\n\tu32 result_mask;\n\tumode_t mode;\n\tunsigned int nlink;\n\tuint32_t blksize;\n\tu64 attributes;\n\tu64 attributes_mask;\n\tu64 ino;\n\tdev_t dev;\n\tdev_t rdev;\n\tkuid_t uid;\n\tkgid_t gid;\n\tloff_t size;\n\tstruct timespec64 atime;\n\tstruct timespec64 mtime;\n\tstruct timespec64 ctime;\n\tstruct timespec64 btime;\n\tu64 blocks;\n\tu64 mnt_id;\n};\n\nstruct list_lru_one {\n\tstruct list_head list;\n\tlong int nr_items;\n};\n\nstruct list_lru_memcg {\n\tstruct callback_head rcu;\n\tstruct list_lru_one *lru[0];\n};\n\nstruct list_lru_node {\n\tspinlock_t lock;\n\tstruct list_lru_one lru;\n\tstruct list_lru_memcg *memcg_lrus;\n\tlong int nr_items;\n\tlong: 64;\n\tlong: 64;\n};\n\nenum migrate_mode {\n\tMIGRATE_ASYNC = 0,\n\tMIGRATE_SYNC_LIGHT = 1,\n\tMIGRATE_SYNC = 2,\n\tMIGRATE_SYNC_NO_COPY = 3,\n};\n\nstruct key_tag {\n\tstruct callback_head rcu;\n\trefcount_t usage;\n\tbool removed;\n};\n\ntypedef int (*request_key_actor_t)(struct key *, void *);\n\nstruct key_preparsed_payload;\n\nstruct key_match_data;\n\nstruct kernel_pkey_params;\n\nstruct kernel_pkey_query;\n\nstruct key_type {\n\tconst char *name;\n\tsize_t def_datalen;\n\tunsigned int flags;\n\tint (*vet_description)(const char *);\n\tint (*preparse)(struct key_preparsed_payload *);\n\tvoid (*free_preparse)(struct key_preparsed_payload *);\n\tint (*instantiate)(struct key *, struct key_preparsed_payload *);\n\tint (*update)(struct key *, struct key_preparsed_payload *);\n\tint (*match_preparse)(struct key_match_data *);\n\tvoid (*match_free)(struct key_match_data *);\n\tvoid (*revoke)(struct key *);\n\tvoid (*destroy)(struct key *);\n\tvoid (*describe)(const struct key *, struct seq_file *);\n\tlong int (*read)(const struct key *, char *, size_t);\n\trequest_key_actor_t request_key;\n\tstruct key_restriction * (*lookup_restriction)(const char *);\n\tint (*asym_query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);\n\tint (*asym_eds_op)(struct kernel_pkey_params *, const void *, void *);\n\tint (*asym_verify_signature)(struct kernel_pkey_params *, const void *, const void *);\n\tstruct list_head link;\n\tstruct lock_class_key lock_class;\n};\n\ntypedef int (*key_restrict_link_func_t)(struct key *, const struct key_type *, const union key_payload *, struct key *);\n\nstruct key_restriction {\n\tkey_restrict_link_func_t check;\n\tstruct key *key;\n\tstruct key_type *keytype;\n};\n\nstruct percpu_counter {\n\traw_spinlock_t lock;\n\ts64 count;\n\tstruct list_head list;\n\ts32 *counters;\n};\n\nstruct user_struct {\n\trefcount_t __count;\n\tstruct percpu_counter epoll_watches;\n\tlong unsigned int unix_inflight;\n\tatomic_long_t pipe_bufs;\n\tstruct hlist_node uidhash_node;\n\tkuid_t uid;\n\tatomic_long_t locked_vm;\n\tatomic_t nr_watches;\n\tstruct ratelimit_state ratelimit;\n};\n\nstruct group_info {\n\tatomic_t usage;\n\tint ngroups;\n\tkgid_t gid[0];\n};\n\nstruct delayed_call {\n\tvoid (*fn)(void *);\n\tvoid *arg;\n};\n\nstruct io_cq {\n\tstruct request_queue *q;\n\tstruct io_context *ioc;\n\tunion {\n\t\tstruct list_head q_node;\n\t\tstruct kmem_cache *__rcu_icq_cache;\n\t};\n\tunion {\n\t\tstruct hlist_node ioc_node;\n\t\tstruct callback_head __rcu_head;\n\t};\n\tunsigned int flags;\n};\n\nstruct wait_page_queue;\n\nstruct kiocb {\n\tstruct file *ki_filp;\n\tloff_t ki_pos;\n\tvoid (*ki_complete)(struct kiocb *, long int, long int);\n\tvoid *private;\n\tint ki_flags;\n\tu16 ki_hint;\n\tu16 ki_ioprio;\n\tunion {\n\t\tunsigned int ki_cookie;\n\t\tstruct wait_page_queue *ki_waitq;\n\t};\n};\n\nstruct iattr {\n\tunsigned int ia_valid;\n\tumode_t ia_mode;\n\tkuid_t ia_uid;\n\tkgid_t ia_gid;\n\tloff_t ia_size;\n\tstruct timespec64 ia_atime;\n\tstruct timespec64 ia_mtime;\n\tstruct timespec64 ia_ctime;\n\tstruct file *ia_file;\n};\n\ntypedef __kernel_uid32_t projid_t;\n\ntypedef struct {\n\tprojid_t val;\n} kprojid_t;\n\nenum quota_type {\n\tUSRQUOTA = 0,\n\tGRPQUOTA = 1,\n\tPRJQUOTA = 2,\n};\n\nstruct kqid {\n\tunion {\n\t\tkuid_t uid;\n\t\tkgid_t gid;\n\t\tkprojid_t projid;\n\t};\n\tenum quota_type type;\n};\n\nstruct mem_dqblk {\n\tqsize_t dqb_bhardlimit;\n\tqsize_t dqb_bsoftlimit;\n\tqsize_t dqb_curspace;\n\tqsize_t dqb_rsvspace;\n\tqsize_t dqb_ihardlimit;\n\tqsize_t dqb_isoftlimit;\n\tqsize_t dqb_curinodes;\n\ttime64_t dqb_btime;\n\ttime64_t dqb_itime;\n};\n\nstruct dquot {\n\tstruct hlist_node dq_hash;\n\tstruct list_head dq_inuse;\n\tstruct list_head dq_free;\n\tstruct list_head dq_dirty;\n\tstruct mutex dq_lock;\n\tspinlock_t dq_dqb_lock;\n\tatomic_t dq_count;\n\tstruct super_block *dq_sb;\n\tstruct kqid dq_id;\n\tloff_t dq_off;\n\tlong unsigned int dq_flags;\n\tstruct mem_dqblk dq_dqb;\n};\n\nenum {\n\tDQF_ROOT_SQUASH_B = 0,\n\tDQF_SYS_FILE_B = 16,\n\tDQF_PRIVATE = 17,\n};\n\nstruct quota_format_type {\n\tint qf_fmt_id;\n\tconst struct quota_format_ops *qf_ops;\n\tstruct module *qf_owner;\n\tstruct quota_format_type *qf_next;\n};\n\nenum {\n\tDQST_LOOKUPS = 0,\n\tDQST_DROPS = 1,\n\tDQST_READS = 2,\n\tDQST_WRITES = 3,\n\tDQST_CACHE_HITS = 4,\n\tDQST_ALLOC_DQUOTS = 5,\n\tDQST_FREE_DQUOTS = 6,\n\tDQST_SYNCS = 7,\n\t_DQST_DQSTAT_LAST = 8,\n};\n\nstruct quota_format_ops {\n\tint (*check_quota_file)(struct super_block *, int);\n\tint (*read_file_info)(struct super_block *, int);\n\tint (*write_file_info)(struct super_block *, int);\n\tint (*free_file_info)(struct super_block *, int);\n\tint (*read_dqblk)(struct dquot *);\n\tint (*commit_dqblk)(struct dquot *);\n\tint (*release_dqblk)(struct dquot *);\n\tint (*get_next_id)(struct super_block *, struct kqid *);\n};\n\nstruct dquot_operations {\n\tint (*write_dquot)(struct dquot *);\n\tstruct dquot * (*alloc_dquot)(struct super_block *, int);\n\tvoid (*destroy_dquot)(struct dquot *);\n\tint (*acquire_dquot)(struct dquot *);\n\tint (*release_dquot)(struct dquot *);\n\tint (*mark_dirty)(struct dquot *);\n\tint (*write_info)(struct super_block *, int);\n\tqsize_t * (*get_reserved_space)(struct inode *);\n\tint (*get_projid)(struct inode *, kprojid_t *);\n\tint (*get_inode_usage)(struct inode *, qsize_t *);\n\tint (*get_next_id)(struct super_block *, struct kqid *);\n};\n\nstruct qc_dqblk {\n\tint d_fieldmask;\n\tu64 d_spc_hardlimit;\n\tu64 d_spc_softlimit;\n\tu64 d_ino_hardlimit;\n\tu64 d_ino_softlimit;\n\tu64 d_space;\n\tu64 d_ino_count;\n\ts64 d_ino_timer;\n\ts64 d_spc_timer;\n\tint d_ino_warns;\n\tint d_spc_warns;\n\tu64 d_rt_spc_hardlimit;\n\tu64 d_rt_spc_softlimit;\n\tu64 d_rt_space;\n\ts64 d_rt_spc_timer;\n\tint d_rt_spc_warns;\n};\n\nstruct qc_type_state {\n\tunsigned int flags;\n\tunsigned int spc_timelimit;\n\tunsigned int ino_timelimit;\n\tunsigned int rt_spc_timelimit;\n\tunsigned int spc_warnlimit;\n\tunsigned int ino_warnlimit;\n\tunsigned int rt_spc_warnlimit;\n\tlong long unsigned int ino;\n\tblkcnt_t blocks;\n\tblkcnt_t nextents;\n};\n\nstruct qc_state {\n\tunsigned int s_incoredqs;\n\tstruct qc_type_state s_state[3];\n};\n\nstruct qc_info {\n\tint i_fieldmask;\n\tunsigned int i_flags;\n\tunsigned int i_spc_timelimit;\n\tunsigned int i_ino_timelimit;\n\tunsigned int i_rt_spc_timelimit;\n\tunsigned int i_spc_warnlimit;\n\tunsigned int i_ino_warnlimit;\n\tunsigned int i_rt_spc_warnlimit;\n};\n\nstruct quotactl_ops {\n\tint (*quota_on)(struct super_block *, int, int, const struct path *);\n\tint (*quota_off)(struct super_block *, int);\n\tint (*quota_enable)(struct super_block *, unsigned int);\n\tint (*quota_disable)(struct super_block *, unsigned int);\n\tint (*quota_sync)(struct super_block *, int);\n\tint (*set_info)(struct super_block *, int, struct qc_info *);\n\tint (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);\n\tint (*get_nextdqblk)(struct super_block *, struct kqid *, struct qc_dqblk *);\n\tint (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);\n\tint (*get_state)(struct super_block *, struct qc_state *);\n\tint (*rm_xquota)(struct super_block *, unsigned int);\n};\n\nstruct writeback_control;\n\nstruct readahead_control;\n\nstruct swap_info_struct;\n\nstruct address_space_operations {\n\tint (*writepage)(struct page *, struct writeback_control *);\n\tint (*readpage)(struct file *, struct page *);\n\tint (*writepages)(struct address_space *, struct writeback_control *);\n\tint (*set_page_dirty)(struct page *);\n\tint (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int);\n\tvoid (*readahead)(struct readahead_control *);\n\tint (*write_begin)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page **, void **);\n\tint (*write_end)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page *, void *);\n\tsector_t (*bmap)(struct address_space *, sector_t);\n\tvoid (*invalidatepage)(struct page *, unsigned int, unsigned int);\n\tint (*releasepage)(struct page *, gfp_t);\n\tvoid (*freepage)(struct page *);\n\tssize_t (*direct_IO)(struct kiocb *, struct iov_iter *);\n\tint (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode);\n\tbool (*isolate_page)(struct page *, isolate_mode_t);\n\tvoid (*putback_page)(struct page *);\n\tint (*launder_page)(struct page *);\n\tint (*is_partially_uptodate)(struct page *, long unsigned int, long unsigned int);\n\tvoid (*is_dirty_writeback)(struct page *, bool *, bool *);\n\tint (*error_remove_page)(struct address_space *, struct page *);\n\tint (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *);\n\tvoid (*swap_deactivate)(struct file *);\n};\n\nstruct fiemap_extent_info;\n\nstruct fileattr;\n\nstruct inode_operations {\n\tstruct dentry * (*lookup)(struct inode *, struct dentry *, unsigned int);\n\tconst char * (*get_link)(struct dentry *, struct inode *, struct delayed_call *);\n\tint (*permission)(struct user_namespace *, struct inode *, int);\n\tstruct posix_acl * (*get_acl)(struct inode *, int, bool);\n\tint (*readlink)(struct dentry *, char *, int);\n\tint (*create)(struct user_namespace *, struct inode *, struct dentry *, umode_t, bool);\n\tint (*link)(struct dentry *, struct inode *, struct dentry *);\n\tint (*unlink)(struct inode *, struct dentry *);\n\tint (*symlink)(struct user_namespace *, struct inode *, struct dentry *, const char *);\n\tint (*mkdir)(struct user_namespace *, struct inode *, struct dentry *, umode_t);\n\tint (*rmdir)(struct inode *, struct dentry *);\n\tint (*mknod)(struct user_namespace *, struct inode *, struct dentry *, umode_t, dev_t);\n\tint (*rename)(struct user_namespace *, struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int);\n\tint (*setattr)(struct user_namespace *, struct dentry *, struct iattr *);\n\tint (*getattr)(struct user_namespace *, const struct path *, struct kstat *, u32, unsigned int);\n\tssize_t (*listxattr)(struct dentry *, char *, size_t);\n\tint (*fiemap)(struct inode *, struct fiemap_extent_info *, u64, u64);\n\tint (*update_time)(struct inode *, struct timespec64 *, int);\n\tint (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int, umode_t);\n\tint (*tmpfile)(struct user_namespace *, struct inode *, struct dentry *, umode_t);\n\tint (*set_acl)(struct user_namespace *, struct inode *, struct posix_acl *, int);\n\tint (*fileattr_set)(struct user_namespace *, struct dentry *, struct fileattr *);\n\tint (*fileattr_get)(struct dentry *, struct fileattr *);\n\tlong: 64;\n};\n\nstruct file_lock_context {\n\tspinlock_t flc_lock;\n\tstruct list_head flc_flock;\n\tstruct list_head flc_posix;\n\tstruct list_head flc_lease;\n};\n\nstruct file_lock_operations {\n\tvoid (*fl_copy_lock)(struct file_lock *, struct file_lock *);\n\tvoid (*fl_release_private)(struct file_lock *);\n};\n\nstruct nlm_lockowner;\n\nstruct nfs_lock_info {\n\tu32 state;\n\tstruct nlm_lockowner *owner;\n\tstruct list_head list;\n};\n\nstruct nfs4_lock_state;\n\nstruct nfs4_lock_info {\n\tstruct nfs4_lock_state *owner;\n};\n\nstruct fasync_struct;\n\nstruct lock_manager_operations;\n\nstruct file_lock {\n\tstruct file_lock *fl_blocker;\n\tstruct list_head fl_list;\n\tstruct hlist_node fl_link;\n\tstruct list_head fl_blocked_requests;\n\tstruct list_head fl_blocked_member;\n\tfl_owner_t fl_owner;\n\tunsigned int fl_flags;\n\tunsigned char fl_type;\n\tunsigned int fl_pid;\n\tint fl_link_cpu;\n\twait_queue_head_t fl_wait;\n\tstruct file *fl_file;\n\tloff_t fl_start;\n\tloff_t fl_end;\n\tstruct fasync_struct *fl_fasync;\n\tlong unsigned int fl_break_time;\n\tlong unsigned int fl_downgrade_time;\n\tconst struct file_lock_operations *fl_ops;\n\tconst struct lock_manager_operations *fl_lmops;\n\tunion {\n\t\tstruct nfs_lock_info nfs_fl;\n\t\tstruct nfs4_lock_info nfs4_fl;\n\t\tstruct {\n\t\t\tstruct list_head link;\n\t\t\tint state;\n\t\t\tunsigned int debug_id;\n\t\t} afs;\n\t} fl_u;\n};\n\nstruct lock_manager_operations {\n\tfl_owner_t (*lm_get_owner)(fl_owner_t);\n\tvoid (*lm_put_owner)(fl_owner_t);\n\tvoid (*lm_notify)(struct file_lock *);\n\tint (*lm_grant)(struct file_lock *, int);\n\tbool (*lm_break)(struct file_lock *);\n\tint (*lm_change)(struct file_lock *, int, struct list_head *);\n\tvoid (*lm_setup)(struct file_lock *, void **);\n\tbool (*lm_breaker_owns_lease)(struct file_lock *);\n};\n\nstruct fasync_struct {\n\trwlock_t fa_lock;\n\tint magic;\n\tint fa_fd;\n\tstruct fasync_struct *fa_next;\n\tstruct file *fa_file;\n\tstruct callback_head fa_rcu;\n};\n\nenum {\n\tSB_UNFROZEN = 0,\n\tSB_FREEZE_WRITE = 1,\n\tSB_FREEZE_PAGEFAULT = 2,\n\tSB_FREEZE_FS = 3,\n\tSB_FREEZE_COMPLETE = 4,\n};\n\nstruct kstatfs;\n\nstruct super_operations {\n\tstruct inode * (*alloc_inode)(struct super_block *);\n\tvoid (*destroy_inode)(struct inode *);\n\tvoid (*free_inode)(struct inode *);\n\tvoid (*dirty_inode)(struct inode *, int);\n\tint (*write_inode)(struct inode *, struct writeback_control *);\n\tint (*drop_inode)(struct inode *);\n\tvoid (*evict_inode)(struct inode *);\n\tvoid (*put_super)(struct super_block *);\n\tint (*sync_fs)(struct super_block *, int);\n\tint (*freeze_super)(struct super_block *);\n\tint (*freeze_fs)(struct super_block *);\n\tint (*thaw_super)(struct super_block *);\n\tint (*unfreeze_fs)(struct super_block *);\n\tint (*statfs)(struct dentry *, struct kstatfs *);\n\tint (*remount_fs)(struct super_block *, int *, char *);\n\tvoid (*umount_begin)(struct super_block *);\n\tint (*show_options)(struct seq_file *, struct dentry *);\n\tint (*show_devname)(struct seq_file *, struct dentry *);\n\tint (*show_path)(struct seq_file *, struct dentry *);\n\tint (*show_stats)(struct seq_file *, struct dentry *);\n\tssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);\n\tssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);\n\tstruct dquot ** (*get_dquots)(struct inode *);\n\tlong int (*nr_cached_objects)(struct super_block *, struct shrink_control *);\n\tlong int (*free_cached_objects)(struct super_block *, struct shrink_control *);\n\tstruct file * (*real_loop)(struct file *);\n};\n\nstruct iomap;\n\nstruct fid;\n\nstruct export_operations {\n\tint (*encode_fh)(struct inode *, __u32 *, int *, struct inode *);\n\tstruct dentry * (*fh_to_dentry)(struct super_block *, struct fid *, int, int);\n\tstruct dentry * (*fh_to_parent)(struct super_block *, struct fid *, int, int);\n\tint (*get_name)(struct dentry *, char *, struct dentry *);\n\tstruct dentry * (*get_parent)(struct dentry *);\n\tint (*commit_metadata)(struct inode *);\n\tint (*get_uuid)(struct super_block *, u8 *, u32 *, u64 *);\n\tint (*map_blocks)(struct inode *, loff_t, u64, struct iomap *, bool, u32 *);\n\tint (*commit_blocks)(struct inode *, struct iomap *, int, struct iattr *);\n\tu64 (*fetch_iversion)(struct inode *);\n\tlong unsigned int flags;\n};\n\nstruct xattr_handler {\n\tconst char *name;\n\tconst char *prefix;\n\tint flags;\n\tbool (*list)(struct dentry *);\n\tint (*get)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, void *, size_t);\n\tint (*set)(const struct xattr_handler *, struct user_namespace *, struct dentry *, struct inode *, const char *, const void *, size_t, int);\n};\n\nunion fscrypt_policy;\n\nstruct fscrypt_operations {\n\tunsigned int flags;\n\tconst char *key_prefix;\n\tint (*get_context)(struct inode *, void *, size_t);\n\tint (*set_context)(struct inode *, const void *, size_t, void *);\n\tconst union fscrypt_policy * (*get_dummy_policy)(struct super_block *);\n\tbool (*empty_dir)(struct inode *);\n\tunsigned int max_namelen;\n\tbool (*has_stable_inodes)(struct super_block *);\n\tvoid (*get_ino_and_lblk_bits)(struct super_block *, int *, int *);\n\tint (*get_num_devices)(struct super_block *);\n\tvoid (*get_devices)(struct super_block *, struct request_queue **);\n};\n\nstruct fsverity_operations {\n\tint (*begin_enable_verity)(struct file *);\n\tint (*end_enable_verity)(struct file *, const void *, size_t, u64);\n\tint (*get_verity_descriptor)(struct inode *, void *, size_t);\n\tstruct page * (*read_merkle_tree_page)(struct inode *, long unsigned int, long unsigned int);\n\tint (*write_merkle_tree_block)(struct inode *, const void *, u64, int);\n};\n\ntypedef int (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64, unsigned int);\n\nstruct dir_context {\n\tfilldir_t actor;\n\tloff_t pos;\n};\n\nstruct p_log;\n\nstruct fs_parameter;\n\nstruct fs_parse_result;\n\ntypedef int fs_param_type(struct p_log *, const struct fs_parameter_spec *, struct fs_parameter *, struct fs_parse_result *);\n\nstruct fs_parameter_spec {\n\tconst char *name;\n\tfs_param_type *type;\n\tu8 opt;\n\tshort unsigned int flags;\n\tconst void *data;\n};\n\nenum compound_dtor_id {\n\tNULL_COMPOUND_DTOR = 0,\n\tCOMPOUND_PAGE_DTOR = 1,\n\tHUGETLB_PAGE_DTOR = 2,\n\tTRANSHUGE_PAGE_DTOR = 3,\n\tNR_COMPOUND_DTORS = 4,\n};\n\nenum vm_event_item {\n\tPGPGIN = 0,\n\tPGPGOUT = 1,\n\tPSWPIN = 2,\n\tPSWPOUT = 3,\n\tPGALLOC_DMA = 4,\n\tPGALLOC_DMA32 = 5,\n\tPGALLOC_NORMAL = 6,\n\tPGALLOC_MOVABLE = 7,\n\tALLOCSTALL_DMA = 8,\n\tALLOCSTALL_DMA32 = 9,\n\tALLOCSTALL_NORMAL = 10,\n\tALLOCSTALL_MOVABLE = 11,\n\tPGSCAN_SKIP_DMA = 12,\n\tPGSCAN_SKIP_DMA32 = 13,\n\tPGSCAN_SKIP_NORMAL = 14,\n\tPGSCAN_SKIP_MOVABLE = 15,\n\tPGFREE = 16,\n\tPGACTIVATE = 17,\n\tPGDEACTIVATE = 18,\n\tPGLAZYFREE = 19,\n\tPGFAULT = 20,\n\tPGMAJFAULT = 21,\n\tPGLAZYFREED = 22,\n\tPGREFILL = 23,\n\tPGREUSE = 24,\n\tPGSTEAL_KSWAPD = 25,\n\tPGSTEAL_DIRECT = 26,\n\tPGDEMOTE_KSWAPD = 27,\n\tPGDEMOTE_DIRECT = 28,\n\tPGSCAN_KSWAPD = 29,\n\tPGSCAN_DIRECT = 30,\n\tPGSCAN_DIRECT_THROTTLE = 31,\n\tPGSCAN_ANON = 32,\n\tPGSCAN_FILE = 33,\n\tPGSTEAL_ANON = 34,\n\tPGSTEAL_FILE = 35,\n\tPGSCAN_ZONE_RECLAIM_FAILED = 36,\n\tPGINODESTEAL = 37,\n\tSLABS_SCANNED = 38,\n\tKSWAPD_INODESTEAL = 39,\n\tKSWAPD_LOW_WMARK_HIT_QUICKLY = 40,\n\tKSWAPD_HIGH_WMARK_HIT_QUICKLY = 41,\n\tPAGEOUTRUN = 42,\n\tPGROTATED = 43,\n\tDROP_PAGECACHE = 44,\n\tDROP_SLAB = 45,\n\tOOM_KILL = 46,\n\tNUMA_PTE_UPDATES = 47,\n\tNUMA_HUGE_PTE_UPDATES = 48,\n\tNUMA_HINT_FAULTS = 49,\n\tNUMA_HINT_FAULTS_LOCAL = 50,\n\tNUMA_PAGE_MIGRATE = 51,\n\tPGMIGRATE_SUCCESS = 52,\n\tPGMIGRATE_FAIL = 53,\n\tTHP_MIGRATION_SUCCESS = 54,\n\tTHP_MIGRATION_FAIL = 55,\n\tTHP_MIGRATION_SPLIT = 56,\n\tCOMPACTMIGRATE_SCANNED = 57,\n\tCOMPACTFREE_SCANNED = 58,\n\tCOMPACTISOLATED = 59,\n\tCOMPACTSTALL = 60,\n\tCOMPACTFAIL = 61,\n\tCOMPACTSUCCESS = 62,\n\tKCOMPACTD_WAKE = 63,\n\tKCOMPACTD_MIGRATE_SCANNED = 64,\n\tKCOMPACTD_FREE_SCANNED = 65,\n\tHTLB_BUDDY_PGALLOC = 66,\n\tHTLB_BUDDY_PGALLOC_FAIL = 67,\n\tUNEVICTABLE_PGCULLED = 68,\n\tUNEVICTABLE_PGSCANNED = 69,\n\tUNEVICTABLE_PGRESCUED = 70,\n\tUNEVICTABLE_PGMLOCKED = 71,\n\tUNEVICTABLE_PGMUNLOCKED = 72,\n\tUNEVICTABLE_PGCLEARED = 73,\n\tUNEVICTABLE_PGSTRANDED = 74,\n\tTHP_FAULT_ALLOC = 75,\n\tTHP_FAULT_FALLBACK = 76,\n\tTHP_FAULT_FALLBACK_CHARGE = 77,\n\tTHP_COLLAPSE_ALLOC = 78,\n\tTHP_COLLAPSE_ALLOC_FAILED = 79,\n\tTHP_FILE_ALLOC = 80,\n\tTHP_FILE_FALLBACK = 81,\n\tTHP_FILE_FALLBACK_CHARGE = 82,\n\tTHP_FILE_MAPPED = 83,\n\tTHP_SPLIT_PAGE = 84,\n\tTHP_SPLIT_PAGE_FAILED = 85,\n\tTHP_DEFERRED_SPLIT_PAGE = 86,\n\tTHP_SPLIT_PMD = 87,\n\tTHP_SPLIT_PUD = 88,\n\tTHP_ZERO_PAGE_ALLOC = 89,\n\tTHP_ZERO_PAGE_ALLOC_FAILED = 90,\n\tTHP_SWPOUT = 91,\n\tTHP_SWPOUT_FALLBACK = 92,\n\tBALLOON_INFLATE = 93,\n\tBALLOON_DEFLATE = 94,\n\tBALLOON_MIGRATE = 95,\n\tSWAP_RA = 96,\n\tSWAP_RA_HIT = 97,\n\tDIRECT_MAP_LEVEL2_SPLIT = 98,\n\tDIRECT_MAP_LEVEL3_SPLIT = 99,\n\tNR_VM_EVENT_ITEMS = 100,\n};\n\nstruct tlb_context {\n\tu64 ctx_id;\n\tu64 tlb_gen;\n};\n\nstruct tlb_state {\n\tstruct mm_struct *loaded_mm;\n\tunion {\n\t\tstruct mm_struct *last_user_mm;\n\t\tlong unsigned int last_user_mm_spec;\n\t};\n\tu16 loaded_mm_asid;\n\tu16 next_asid;\n\tbool invalidate_other;\n\tshort unsigned int user_pcid_flush_mask;\n\tlong unsigned int cr4;\n\tstruct tlb_context ctxs[6];\n};\n\nstruct boot_params_to_save {\n\tunsigned int start;\n\tunsigned int len;\n};\n\nenum cpu_idle_type {\n\tCPU_IDLE = 0,\n\tCPU_NOT_IDLE = 1,\n\tCPU_NEWLY_IDLE = 2,\n\tCPU_MAX_IDLE_TYPES = 3,\n};\n\nenum {\n\t__SD_BALANCE_NEWIDLE = 0,\n\t__SD_BALANCE_EXEC = 1,\n\t__SD_BALANCE_FORK = 2,\n\t__SD_BALANCE_WAKE = 3,\n\t__SD_WAKE_AFFINE = 4,\n\t__SD_ASYM_CPUCAPACITY = 5,\n\t__SD_ASYM_CPUCAPACITY_FULL = 6,\n\t__SD_SHARE_CPUCAPACITY = 7,\n\t__SD_SHARE_PKG_RESOURCES = 8,\n\t__SD_SERIALIZE = 9,\n\t__SD_ASYM_PACKING = 10,\n\t__SD_PREFER_SIBLING = 11,\n\t__SD_OVERLAP = 12,\n\t__SD_NUMA = 13,\n\t__SD_FLAG_CNT = 14,\n};\n\nstruct x86_legacy_devices {\n\tint pnpbios;\n};\n\nenum x86_legacy_i8042_state {\n\tX86_LEGACY_I8042_PLATFORM_ABSENT = 0,\n\tX86_LEGACY_I8042_FIRMWARE_ABSENT = 1,\n\tX86_LEGACY_I8042_EXPECTED_PRESENT = 2,\n};\n\nstruct x86_legacy_features {\n\tenum x86_legacy_i8042_state i8042;\n\tint rtc;\n\tint warm_reset;\n\tint no_vga;\n\tint reserve_bios_regions;\n\tstruct x86_legacy_devices devices;\n};\n\nstruct ghcb;\n\nstruct x86_hyper_runtime {\n\tvoid (*pin_vcpu)(int);\n\tvoid (*sev_es_hcall_prepare)(struct ghcb *, struct pt_regs *);\n\tbool (*sev_es_hcall_finish)(struct ghcb *, struct pt_regs *);\n};\n\nstruct x86_platform_ops {\n\tlong unsigned int (*calibrate_cpu)();\n\tlong unsigned int (*calibrate_tsc)();\n\tvoid (*get_wallclock)(struct timespec64 *);\n\tint (*set_wallclock)(const struct timespec64 *);\n\tvoid (*iommu_shutdown)();\n\tbool (*is_untracked_pat_range)(u64, u64);\n\tvoid (*nmi_init)();\n\tunsigned char (*get_nmi_reason)();\n\tvoid (*save_sched_clock_state)();\n\tvoid (*restore_sched_clock_state)();\n\tvoid (*apic_post_init)();\n\tstruct x86_legacy_features legacy;\n\tvoid (*set_legacy_features)();\n\tstruct x86_hyper_runtime hyper;\n};\n\ntypedef signed char __s8;\n\ntypedef __s8 s8;\n\ntypedef __u16 __be16;\n\ntypedef __u32 __le32;\n\ntypedef __u32 __be32;\n\ntypedef __u32 __wsum;\n\ntypedef long unsigned int irq_hw_number_t;\n\nstruct kernel_symbol {\n\tint value_offset;\n\tint name_offset;\n\tint namespace_offset;\n};\n\ntypedef int (*initcall_t)();\n\ntypedef int initcall_entry_t;\n\nstruct obs_kernel_param {\n\tconst char *str;\n\tint (*setup_func)(char *);\n\tint early;\n};\n\nstruct lockdep_map {};\n\nstruct jump_entry {\n\ts32 code;\n\ts32 target;\n\tlong int key;\n};\n\nstruct static_key_mod;\n\nstruct static_key {\n\tatomic_t enabled;\n\tunion {\n\t\tlong unsigned int type;\n\t\tstruct jump_entry *entries;\n\t\tstruct static_key_mod *next;\n\t};\n};\n\nstruct static_key_true {\n\tstruct static_key key;\n};\n\nstruct static_key_false {\n\tstruct static_key key;\n};\n\nstruct _ddebug {\n\tconst char *modname;\n\tconst char *function;\n\tconst char *filename;\n\tconst char *format;\n\tunsigned int lineno: 18;\n\tunsigned int flags: 8;\n\tunion {\n\t\tstruct static_key_true dd_key_true;\n\t\tstruct static_key_false dd_key_false;\n\t} key;\n};\n\nstruct static_call_site {\n\ts32 addr;\n\ts32 key;\n};\n\nstruct static_call_mod {\n\tstruct static_call_mod *next;\n\tstruct module *mod;\n\tstruct static_call_site *sites;\n};\n\nstruct static_call_key {\n\tvoid *func;\n\tunion {\n\t\tlong unsigned int type;\n\t\tstruct static_call_mod *mods;\n\t\tstruct static_call_site *sites;\n\t};\n};\n\nenum system_states {\n\tSYSTEM_BOOTING = 0,\n\tSYSTEM_SCHEDULING = 1,\n\tSYSTEM_RUNNING = 2,\n\tSYSTEM_HALT = 3,\n\tSYSTEM_POWER_OFF = 4,\n\tSYSTEM_RESTART = 5,\n\tSYSTEM_SUSPEND = 6,\n};\n\nstruct bug_entry {\n\tint bug_addr_disp;\n\tint file_disp;\n\tshort unsigned int line;\n\tshort unsigned int flags;\n};\n\ntypedef struct cpumask *cpumask_var_t;\n\nstruct tracepoint_func {\n\tvoid *func;\n\tvoid *data;\n\tint prio;\n};\n\nstruct tracepoint {\n\tconst char *name;\n\tstruct static_key key;\n\tstruct static_call_key *static_call_key;\n\tvoid *static_call_tramp;\n\tvoid *iterator;\n\tint (*regfunc)();\n\tvoid (*unregfunc)();\n\tstruct tracepoint_func *funcs;\n};\n\ntypedef const int tracepoint_ptr_t;\n\nstruct bpf_raw_event_map {\n\tstruct tracepoint *tp;\n\tvoid *bpf_func;\n\tu32 num_args;\n\tu32 writable_size;\n\tlong: 64;\n};\n\nstruct seq_operations {\n\tvoid * (*start)(struct seq_file *, loff_t *);\n\tvoid (*stop)(struct seq_file *, void *);\n\tvoid * (*next)(struct seq_file *, void *, loff_t *);\n\tint (*show)(struct seq_file *, void *);\n};\n\nstruct fixed_percpu_data {\n\tchar gs_base[40];\n\tlong unsigned int stack_canary;\n};\n\nenum perf_event_state {\n\tPERF_EVENT_STATE_DEAD = 4294967292,\n\tPERF_EVENT_STATE_EXIT = 4294967293,\n\tPERF_EVENT_STATE_ERROR = 4294967294,\n\tPERF_EVENT_STATE_OFF = 4294967295,\n\tPERF_EVENT_STATE_INACTIVE = 0,\n\tPERF_EVENT_STATE_ACTIVE = 1,\n};\n\ntypedef struct {\n\tatomic_long_t a;\n} local_t;\n\ntypedef struct {\n\tlocal_t a;\n} local64_t;\n\nstruct perf_event_attr {\n\t__u32 type;\n\t__u32 size;\n\t__u64 config;\n\tunion {\n\t\t__u64 sample_period;\n\t\t__u64 sample_freq;\n\t};\n\t__u64 sample_type;\n\t__u64 read_format;\n\t__u64 disabled: 1;\n\t__u64 inherit: 1;\n\t__u64 pinned: 1;\n\t__u64 exclusive: 1;\n\t__u64 exclude_user: 1;\n\t__u64 exclude_kernel: 1;\n\t__u64 exclude_hv: 1;\n\t__u64 exclude_idle: 1;\n\t__u64 mmap: 1;\n\t__u64 comm: 1;\n\t__u64 freq: 1;\n\t__u64 inherit_stat: 1;\n\t__u64 enable_on_exec: 1;\n\t__u64 task: 1;\n\t__u64 watermark: 1;\n\t__u64 precise_ip: 2;\n\t__u64 mmap_data: 1;\n\t__u64 sample_id_all: 1;\n\t__u64 exclude_host: 1;\n\t__u64 exclude_guest: 1;\n\t__u64 exclude_callchain_kernel: 1;\n\t__u64 exclude_callchain_user: 1;\n\t__u64 mmap2: 1;\n\t__u64 comm_exec: 1;\n\t__u64 use_clockid: 1;\n\t__u64 context_switch: 1;\n\t__u64 write_backward: 1;\n\t__u64 namespaces: 1;\n\t__u64 ksymbol: 1;\n\t__u64 bpf_event: 1;\n\t__u64 aux_output: 1;\n\t__u64 cgroup: 1;\n\t__u64 text_poke: 1;\n\t__u64 build_id: 1;\n\t__u64 inherit_thread: 1;\n\t__u64 remove_on_exec: 1;\n\t__u64 sigtrap: 1;\n\t__u64 __reserved_1: 26;\n\tunion {\n\t\t__u32 wakeup_events;\n\t\t__u32 wakeup_watermark;\n\t};\n\t__u32 bp_type;\n\tunion {\n\t\t__u64 bp_addr;\n\t\t__u64 kprobe_func;\n\t\t__u64 uprobe_path;\n\t\t__u64 config1;\n\t};\n\tunion {\n\t\t__u64 bp_len;\n\t\t__u64 kprobe_addr;\n\t\t__u64 probe_offset;\n\t\t__u64 config2;\n\t};\n\t__u64 branch_sample_type;\n\t__u64 sample_regs_user;\n\t__u32 sample_stack_user;\n\t__s32 clockid;\n\t__u64 sample_regs_intr;\n\t__u32 aux_watermark;\n\t__u16 sample_max_stack;\n\t__u16 __reserved_2;\n\t__u32 aux_sample_size;\n\t__u32 __reserved_3;\n\t__u64 sig_data;\n};\n\nstruct hw_perf_event_extra {\n\tu64 config;\n\tunsigned int reg;\n\tint alloc;\n\tint idx;\n};\n\nstruct arch_hw_breakpoint {\n\tlong unsigned int address;\n\tlong unsigned int mask;\n\tu8 len;\n\tu8 type;\n};\n\nstruct hw_perf_event {\n\tunion {\n\t\tstruct {\n\t\t\tu64 config;\n\t\t\tu64 last_tag;\n\t\t\tlong unsigned int config_base;\n\t\t\tlong unsigned int event_base;\n\t\t\tint event_base_rdpmc;\n\t\t\tint idx;\n\t\t\tint last_cpu;\n\t\t\tint flags;\n\t\t\tstruct hw_perf_event_extra extra_reg;\n\t\t\tstruct hw_perf_event_extra branch_reg;\n\t\t};\n\t\tstruct {\n\t\t\tstruct hrtimer hrtimer;\n\t\t};\n\t\tstruct {\n\t\t\tstruct list_head tp_list;\n\t\t};\n\t\tstruct {\n\t\t\tu64 pwr_acc;\n\t\t\tu64 ptsc;\n\t\t};\n\t\tstruct {\n\t\t\tstruct arch_hw_breakpoint info;\n\t\t\tstruct list_head bp_list;\n\t\t};\n\t\tstruct {\n\t\t\tu8 iommu_bank;\n\t\t\tu8 iommu_cntr;\n\t\t\tu16 padding;\n\t\t\tu64 conf;\n\t\t\tu64 conf1;\n\t\t};\n\t};\n\tstruct task_struct *target;\n\tvoid *addr_filters;\n\tlong unsigned int addr_filters_gen;\n\tint state;\n\tlocal64_t prev_count;\n\tu64 sample_period;\n\tunion {\n\t\tstruct {\n\t\t\tu64 last_period;\n\t\t\tlocal64_t period_left;\n\t\t};\n\t\tstruct {\n\t\t\tu64 saved_metric;\n\t\t\tu64 saved_slots;\n\t\t};\n\t};\n\tu64 interrupts_seq;\n\tu64 interrupts;\n\tu64 freq_time_stamp;\n\tu64 freq_count_stamp;\n};\n\nstruct irq_work {\n\tstruct __call_single_node node;\n\tvoid (*func)(struct irq_work *);\n};\n\nstruct perf_addr_filters_head {\n\tstruct list_head list;\n\traw_spinlock_t lock;\n\tunsigned int nr_file_filters;\n};\n\nstruct perf_sample_data;\n\ntypedef void (*perf_overflow_handler_t)(struct perf_event *, struct perf_sample_data *, struct pt_regs *);\n\nstruct ftrace_ops;\n\nstruct ftrace_regs;\n\ntypedef void (*ftrace_func_t)(long unsigned int, long unsigned int, struct ftrace_ops *, struct ftrace_regs *);\n\nstruct ftrace_hash;\n\nstruct ftrace_ops_hash {\n\tstruct ftrace_hash *notrace_hash;\n\tstruct ftrace_hash *filter_hash;\n\tstruct mutex regex_lock;\n};\n\nstruct ftrace_ops {\n\tftrace_func_t func;\n\tstruct ftrace_ops *next;\n\tlong unsigned int flags;\n\tvoid *private;\n\tftrace_func_t saved_func;\n\tstruct ftrace_ops_hash local_hash;\n\tstruct ftrace_ops_hash *func_hash;\n\tstruct ftrace_ops_hash old_hash;\n\tlong unsigned int trampoline;\n\tlong unsigned int trampoline_size;\n\tstruct list_head list;\n};\n\nstruct pmu;\n\nstruct perf_buffer;\n\nstruct perf_addr_filter_range;\n\nstruct bpf_prog;\n\nstruct trace_event_call;\n\nstruct event_filter;\n\nstruct perf_cgroup;\n\nstruct perf_event {\n\tstruct list_head event_entry;\n\tstruct list_head sibling_list;\n\tstruct list_head active_list;\n\tstruct rb_node group_node;\n\tu64 group_index;\n\tstruct list_head migrate_entry;\n\tstruct hlist_node hlist_entry;\n\tstruct list_head active_entry;\n\tint nr_siblings;\n\tint event_caps;\n\tint group_caps;\n\tstruct perf_event *group_leader;\n\tstruct pmu *pmu;\n\tvoid *pmu_private;\n\tenum perf_event_state state;\n\tunsigned int attach_state;\n\tlocal64_t count;\n\tatomic64_t child_count;\n\tu64 total_time_enabled;\n\tu64 total_time_running;\n\tu64 tstamp;\n\tstruct perf_event_attr attr;\n\tu16 header_size;\n\tu16 id_header_size;\n\tu16 read_size;\n\tstruct hw_perf_event hw;\n\tstruct perf_event_context *ctx;\n\tatomic_long_t refcount;\n\tatomic64_t child_total_time_enabled;\n\tatomic64_t child_total_time_running;\n\tstruct mutex child_mutex;\n\tstruct list_head child_list;\n\tstruct perf_event *parent;\n\tint oncpu;\n\tint cpu;\n\tstruct list_head owner_entry;\n\tstruct task_struct *owner;\n\tstruct mutex mmap_mutex;\n\tatomic_t mmap_count;\n\tstruct perf_buffer *rb;\n\tstruct list_head rb_entry;\n\tlong unsigned int rcu_batches;\n\tint rcu_pending;\n\twait_queue_head_t waitq;\n\tstruct fasync_struct *fasync;\n\tint pending_wakeup;\n\tint pending_kill;\n\tint pending_disable;\n\tlong unsigned int pending_addr;\n\tstruct irq_work pending;\n\tatomic_t event_limit;\n\tstruct perf_addr_filters_head addr_filters;\n\tstruct perf_addr_filter_range *addr_filter_ranges;\n\tlong unsigned int addr_filters_gen;\n\tstruct perf_event *aux_event;\n\tvoid (*destroy)(struct perf_event *);\n\tstruct callback_head callback_head;\n\tstruct pid_namespace *ns;\n\tu64 id;\n\tu64 (*clock)();\n\tperf_overflow_handler_t overflow_handler;\n\tvoid *overflow_handler_context;\n\tperf_overflow_handler_t orig_overflow_handler;\n\tstruct bpf_prog *prog;\n\tu64 bpf_cookie;\n\tstruct trace_event_call *tp_event;\n\tstruct event_filter *filter;\n\tstruct ftrace_ops ftrace_ops;\n\tstruct perf_cgroup *cgrp;\n\tvoid *security;\n\tstruct list_head sb_list;\n};\n\nstruct uid_gid_extent {\n\tu32 first;\n\tu32 lower_first;\n\tu32 count;\n};\n\nstruct uid_gid_map {\n\tu32 nr_extents;\n\tunion {\n\t\tstruct uid_gid_extent extent[5];\n\t\tstruct {\n\t\t\tstruct uid_gid_extent *forward;\n\t\t\tstruct uid_gid_extent *reverse;\n\t\t};\n\t};\n};\n\nstruct proc_ns_operations;\n\nstruct ns_common {\n\tatomic_long_t stashed;\n\tconst struct proc_ns_operations *ops;\n\tunsigned int inum;\n\trefcount_t count;\n};\n\nstruct ctl_table;\n\nstruct ctl_table_root;\n\nstruct ctl_table_set;\n\nstruct ctl_dir;\n\nstruct ctl_node;\n\nstruct ctl_table_header {\n\tunion {\n\t\tstruct {\n\t\t\tstruct ctl_table *ctl_table;\n\t\t\tint used;\n\t\t\tint count;\n\t\t\tint nreg;\n\t\t};\n\t\tstruct callback_head rcu;\n\t};\n\tstruct completion *unregistering;\n\tstruct ctl_table *ctl_table_arg;\n\tstruct ctl_table_root *root;\n\tstruct ctl_table_set *set;\n\tstruct ctl_dir *parent;\n\tstruct ctl_node *node;\n\tstruct hlist_head inodes;\n};\n\nstruct ctl_dir {\n\tstruct ctl_table_header header;\n\tstruct rb_root root;\n};\n\nstruct ctl_table_set {\n\tint (*is_seen)(struct ctl_table_set *);\n\tstruct ctl_dir dir;\n};\n\nstruct user_namespace {\n\tstruct uid_gid_map uid_map;\n\tstruct uid_gid_map gid_map;\n\tstruct uid_gid_map projid_map;\n\tstruct user_namespace *parent;\n\tint level;\n\tkuid_t owner;\n\tkgid_t group;\n\tstruct ns_common ns;\n\tlong unsigned int flags;\n\tbool parent_could_setfcap;\n\tstruct list_head keyring_name_list;\n\tstruct key *user_keyring_register;\n\tstruct rw_semaphore keyring_sem;\n\tstruct key *persistent_keyring_register;\n\tstruct work_struct work;\n\tstruct ctl_table_set set;\n\tstruct ctl_table_header *sysctls;\n\tstruct ucounts *ucounts;\n\tlong int ucount_max[16];\n};\n\nstruct pollfd {\n\tint fd;\n\tshort int events;\n\tshort int revents;\n};\n\ntypedef void (*smp_call_func_t)(void *);\n\nstruct __call_single_data {\n\tstruct __call_single_node node;\n\tsmp_call_func_t func;\n\tvoid *info;\n};\n\nstruct smp_ops {\n\tvoid (*smp_prepare_boot_cpu)();\n\tvoid (*smp_prepare_cpus)(unsigned int);\n\tvoid (*smp_cpus_done)(unsigned int);\n\tvoid (*stop_other_cpus)(int);\n\tvoid (*crash_stop_other_cpus)();\n\tvoid (*smp_send_reschedule)(int);\n\tint (*cpu_up)(unsigned int, struct task_struct *);\n\tint (*cpu_disable)();\n\tvoid (*cpu_die)(unsigned int);\n\tvoid (*play_dead)();\n\tvoid (*send_call_func_ipi)(const struct cpumask *);\n\tvoid (*send_call_func_single_ipi)(int);\n};\n\nstruct wait_queue_entry;\n\ntypedef int (*wait_queue_func_t)(struct wait_queue_entry *, unsigned int, int, void *);\n\nstruct wait_queue_entry {\n\tunsigned int flags;\n\tvoid *private;\n\twait_queue_func_t func;\n\tstruct list_head entry;\n};\n\ntypedef struct wait_queue_entry wait_queue_entry_t;\n\nstruct delayed_work {\n\tstruct work_struct work;\n\tstruct timer_list timer;\n\tstruct workqueue_struct *wq;\n\tint cpu;\n};\n\nstruct rcu_work {\n\tstruct work_struct work;\n\tstruct callback_head rcu;\n\tstruct workqueue_struct *wq;\n};\n\nstruct rcu_segcblist {\n\tstruct callback_head *head;\n\tstruct callback_head **tails[4];\n\tlong unsigned int gp_seq[4];\n\tlong int len;\n\tlong int seglen[4];\n\tu8 flags;\n};\n\nstruct srcu_node;\n\nstruct srcu_struct;\n\nstruct srcu_data {\n\tlong unsigned int srcu_lock_count[2];\n\tlong unsigned int srcu_unlock_count[2];\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tspinlock_t lock;\n\tstruct rcu_segcblist srcu_cblist;\n\tlong unsigned int srcu_gp_seq_needed;\n\tlong unsigned int srcu_gp_seq_needed_exp;\n\tbool srcu_cblist_invoking;\n\tstruct timer_list delay_work;\n\tstruct work_struct work;\n\tstruct callback_head srcu_barrier_head;\n\tstruct srcu_node *mynode;\n\tlong unsigned int grpmask;\n\tint cpu;\n\tstruct srcu_struct *ssp;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct srcu_node {\n\tspinlock_t lock;\n\tlong unsigned int srcu_have_cbs[4];\n\tlong unsigned int srcu_data_have_cbs[4];\n\tlong unsigned int srcu_gp_seq_needed_exp;\n\tstruct srcu_node *srcu_parent;\n\tint grplo;\n\tint grphi;\n};\n\nstruct srcu_struct {\n\tstruct srcu_node node[521];\n\tstruct srcu_node *level[4];\n\tstruct mutex srcu_cb_mutex;\n\tspinlock_t lock;\n\tstruct mutex srcu_gp_mutex;\n\tunsigned int srcu_idx;\n\tlong unsigned int srcu_gp_seq;\n\tlong unsigned int srcu_gp_seq_needed;\n\tlong unsigned int srcu_gp_seq_needed_exp;\n\tlong unsigned int srcu_last_gp_end;\n\tstruct srcu_data *sda;\n\tlong unsigned int srcu_barrier_seq;\n\tstruct mutex srcu_barrier_mutex;\n\tstruct completion srcu_barrier_completion;\n\tatomic_t srcu_barrier_cpu_cnt;\n\tstruct delayed_work work;\n\tstruct lockdep_map dep_map;\n};\n\nstruct notifier_block;\n\ntypedef int (*notifier_fn_t)(struct notifier_block *, long unsigned int, void *);\n\nstruct notifier_block {\n\tnotifier_fn_t notifier_call;\n\tstruct notifier_block *next;\n\tint priority;\n};\n\nstruct blocking_notifier_head {\n\tstruct rw_semaphore rwsem;\n\tstruct notifier_block *head;\n};\n\nstruct raw_notifier_head {\n\tstruct notifier_block *head;\n};\n\nstruct ldt_struct {\n\tstruct desc_struct *entries;\n\tunsigned int nr_entries;\n\tint slot;\n};\n\nenum dma_data_direction {\n\tDMA_BIDIRECTIONAL = 0,\n\tDMA_TO_DEVICE = 1,\n\tDMA_FROM_DEVICE = 2,\n\tDMA_NONE = 3,\n};\n\nstruct device;\n\nstruct page_pool_params {\n\tunsigned int flags;\n\tunsigned int order;\n\tunsigned int pool_size;\n\tint nid;\n\tstruct device *dev;\n\tenum dma_data_direction dma_dir;\n\tunsigned int max_len;\n\tunsigned int offset;\n};\n\nstruct pp_alloc_cache {\n\tu32 count;\n\tstruct page *cache[128];\n};\n\nstruct ptr_ring {\n\tint producer;\n\tspinlock_t producer_lock;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tint consumer_head;\n\tint consumer_tail;\n\tspinlock_t consumer_lock;\n\tlong: 32;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tint size;\n\tint batch;\n\tvoid **queue;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct page_pool {\n\tstruct page_pool_params p;\n\tstruct delayed_work release_dw;\n\tvoid (*disconnect)(void *);\n\tlong unsigned int defer_start;\n\tlong unsigned int defer_warn;\n\tu32 pages_state_hold_cnt;\n\tunsigned int frag_offset;\n\tstruct page *frag_page;\n\tlong int frag_users;\n\tlong: 64;\n\tlong: 64;\n\tstruct pp_alloc_cache alloc;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct ptr_ring ring;\n\tatomic_t pages_state_release_cnt;\n\trefcount_t user_cnt;\n\tu64 destroy_cnt;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct anon_vma {\n\tstruct anon_vma *root;\n\tstruct rw_semaphore rwsem;\n\tatomic_t refcount;\n\tlong unsigned int num_children;\n\tlong unsigned int num_active_vmas;\n\tstruct anon_vma *parent;\n\tstruct rb_root_cached rb_root;\n};\n\nstruct mempolicy {\n\tatomic_t refcnt;\n\tshort unsigned int mode;\n\tshort unsigned int flags;\n\tnodemask_t nodes;\n\tunion {\n\t\tnodemask_t cpuset_mems_allowed;\n\t\tnodemask_t user_nodemask;\n\t} w;\n};\n\nstruct linux_binprm;\n\nstruct coredump_params;\n\nstruct linux_binfmt {\n\tstruct list_head lh;\n\tstruct module *module;\n\tint (*load_binary)(struct linux_binprm *);\n\tint (*load_shlib)(struct file *);\n\tint (*core_dump)(struct coredump_params *);\n\tlong unsigned int min_coredump;\n};\n\nstruct free_area {\n\tstruct list_head free_list[5];\n\tlong unsigned int nr_free;\n};\n\nstruct zone_padding {\n\tchar x[0];\n};\n\nstruct pglist_data;\n\nstruct lruvec {\n\tstruct list_head lists[5];\n\tspinlock_t lru_lock;\n\tlong unsigned int anon_cost;\n\tlong unsigned int file_cost;\n\tatomic_long_t nonresident_age;\n\tlong unsigned int refaults[2];\n\tlong unsigned int flags;\n\tstruct pglist_data *pgdat;\n};\n\nstruct per_cpu_pages;\n\nstruct per_cpu_zonestat;\n\nstruct zone {\n\tlong unsigned int _watermark[3];\n\tlong unsigned int watermark_boost;\n\tlong unsigned int nr_reserved_highatomic;\n\tlong int lowmem_reserve[5];\n\tint node;\n\tstruct pglist_data *zone_pgdat;\n\tstruct per_cpu_pages *per_cpu_pageset;\n\tstruct per_cpu_zonestat *per_cpu_zonestats;\n\tint pageset_high;\n\tint pageset_batch;\n\tlong unsigned int zone_start_pfn;\n\tatomic_long_t managed_pages;\n\tlong unsigned int spanned_pages;\n\tlong unsigned int present_pages;\n\tlong unsigned int present_early_pages;\n\tconst char *name;\n\tlong unsigned int nr_isolate_pageblock;\n\tseqlock_t span_seqlock;\n\tint initialized;\n\tint: 32;\n\tstruct zone_padding _pad1_;\n\tstruct free_area free_area[11];\n\tlong unsigned int flags;\n\tspinlock_t lock;\n\tlong: 32;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct zone_padding _pad2_;\n\tlong unsigned int percpu_drift_mark;\n\tlong unsigned int compact_cached_free_pfn;\n\tlong unsigned int compact_cached_migrate_pfn[2];\n\tlong unsigned int compact_init_migrate_pfn;\n\tlong unsigned int compact_init_free_pfn;\n\tunsigned int compact_considered;\n\tunsigned int compact_defer_shift;\n\tint compact_order_failed;\n\tbool compact_blockskip_flush;\n\tbool contiguous;\n\tshort: 16;\n\tstruct zone_padding _pad3_;\n\tatomic_long_t vm_stat[11];\n\tatomic_long_t vm_numa_event[6];\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct zoneref {\n\tstruct zone *zone;\n\tint zone_idx;\n};\n\nstruct zonelist {\n\tstruct zoneref _zonerefs[5121];\n};\n\nenum zone_type {\n\tZONE_DMA = 0,\n\tZONE_DMA32 = 1,\n\tZONE_NORMAL = 2,\n\tZONE_MOVABLE = 3,\n\tZONE_DEVICE = 4,\n\t__MAX_NR_ZONES = 5,\n};\n\nstruct deferred_split {\n\tspinlock_t split_queue_lock;\n\tstruct list_head split_queue;\n\tlong unsigned int split_queue_len;\n};\n\nstruct per_cpu_nodestat;\n\nstruct pglist_data {\n\tstruct zone node_zones[5];\n\tstruct zonelist node_zonelists[2];\n\tint nr_zones;\n\tspinlock_t node_size_lock;\n\tlong unsigned int node_start_pfn;\n\tlong unsigned int node_present_pages;\n\tlong unsigned int node_spanned_pages;\n\tint node_id;\n\twait_queue_head_t kswapd_wait;\n\twait_queue_head_t pfmemalloc_wait;\n\tstruct task_struct *kswapd;\n\tint kswapd_order;\n\tenum zone_type kswapd_highest_zoneidx;\n\tint kswapd_failures;\n\tint kcompactd_max_order;\n\tenum zone_type kcompactd_highest_zoneidx;\n\twait_queue_head_t kcompactd_wait;\n\tstruct task_struct *kcompactd;\n\tbool proactive_compact_trigger;\n\tlong unsigned int totalreserve_pages;\n\tlong unsigned int min_unmapped_pages;\n\tlong unsigned int min_slab_pages;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct zone_padding _pad1_;\n\tstruct deferred_split deferred_split_queue;\n\tstruct lruvec __lruvec;\n\tlong unsigned int flags;\n\tlong: 64;\n\tstruct zone_padding _pad2_;\n\tstruct per_cpu_nodestat *per_cpu_nodestats;\n\tatomic_long_t vm_stat[39];\n};\n\nstruct per_cpu_pages {\n\tint count;\n\tint high;\n\tint batch;\n\tshort int free_factor;\n\tshort int expire;\n\tstruct list_head lists[15];\n};\n\nstruct per_cpu_zonestat {\n\ts8 vm_stat_diff[11];\n\ts8 stat_threshold;\n\tlong unsigned int vm_numa_event[6];\n};\n\nstruct per_cpu_nodestat {\n\ts8 stat_threshold;\n\ts8 vm_node_stat_diff[39];\n};\n\ntypedef struct pglist_data pg_data_t;\n\nenum irq_domain_bus_token {\n\tDOMAIN_BUS_ANY = 0,\n\tDOMAIN_BUS_WIRED = 1,\n\tDOMAIN_BUS_GENERIC_MSI = 2,\n\tDOMAIN_BUS_PCI_MSI = 3,\n\tDOMAIN_BUS_PLATFORM_MSI = 4,\n\tDOMAIN_BUS_NEXUS = 5,\n\tDOMAIN_BUS_IPI = 6,\n\tDOMAIN_BUS_FSL_MC_MSI = 7,\n\tDOMAIN_BUS_TI_SCI_INTA_MSI = 8,\n\tDOMAIN_BUS_WAKEUP = 9,\n\tDOMAIN_BUS_VMD_MSI = 10,\n};\n\nstruct irq_domain_ops;\n\nstruct fwnode_handle;\n\nstruct irq_domain_chip_generic;\n\nstruct irq_data;\n\nstruct irq_domain {\n\tstruct list_head link;\n\tconst char *name;\n\tconst struct irq_domain_ops *ops;\n\tvoid *host_data;\n\tunsigned int flags;\n\tunsigned int mapcount;\n\tstruct fwnode_handle *fwnode;\n\tenum irq_domain_bus_token bus_token;\n\tstruct irq_domain_chip_generic *gc;\n\tstruct irq_domain *parent;\n\tirq_hw_number_t hwirq_max;\n\tunsigned int revmap_size;\n\tstruct xarray revmap_tree;\n\tstruct mutex revmap_mutex;\n\tstruct irq_data *revmap[0];\n};\n\ntypedef int proc_handler(struct ctl_table *, int, void *, size_t *, loff_t *);\n\nstruct ctl_table_poll;\n\nstruct ctl_table {\n\tconst char *procname;\n\tvoid *data;\n\tint maxlen;\n\tumode_t mode;\n\tstruct ctl_table *child;\n\tproc_handler *proc_handler;\n\tstruct ctl_table_poll *poll;\n\tvoid *extra1;\n\tvoid *extra2;\n};\n\nstruct ctl_table_poll {\n\tatomic_t event;\n\twait_queue_head_t wait;\n};\n\nstruct ctl_node {\n\tstruct rb_node node;\n\tstruct ctl_table_header *header;\n};\n\nstruct ctl_table_root {\n\tstruct ctl_table_set default_set;\n\tstruct ctl_table_set * (*lookup)(struct ctl_table_root *);\n\tvoid (*set_ownership)(struct ctl_table_header *, struct ctl_table *, kuid_t *, kgid_t *);\n\tint (*permissions)(struct ctl_table_header *, struct ctl_table *);\n};\n\ntypedef __u64 Elf64_Addr;\n\ntypedef __u16 Elf64_Half;\n\ntypedef __u64 Elf64_Off;\n\ntypedef __u32 Elf64_Word;\n\ntypedef __u64 Elf64_Xword;\n\nstruct elf64_sym {\n\tElf64_Word st_name;\n\tunsigned char st_info;\n\tunsigned char st_other;\n\tElf64_Half st_shndx;\n\tElf64_Addr st_value;\n\tElf64_Xword st_size;\n};\n\ntypedef struct elf64_sym Elf64_Sym;\n\nstruct elf64_hdr {\n\tunsigned char e_ident[16];\n\tElf64_Half e_type;\n\tElf64_Half e_machine;\n\tElf64_Word e_version;\n\tElf64_Addr e_entry;\n\tElf64_Off e_phoff;\n\tElf64_Off e_shoff;\n\tElf64_Word e_flags;\n\tElf64_Half e_ehsize;\n\tElf64_Half e_phentsize;\n\tElf64_Half e_phnum;\n\tElf64_Half e_shentsize;\n\tElf64_Half e_shnum;\n\tElf64_Half e_shstrndx;\n};\n\ntypedef struct elf64_hdr Elf64_Ehdr;\n\nstruct elf64_shdr {\n\tElf64_Word sh_name;\n\tElf64_Word sh_type;\n\tElf64_Xword sh_flags;\n\tElf64_Addr sh_addr;\n\tElf64_Off sh_offset;\n\tElf64_Xword sh_size;\n\tElf64_Word sh_link;\n\tElf64_Word sh_info;\n\tElf64_Xword sh_addralign;\n\tElf64_Xword sh_entsize;\n};\n\ntypedef struct elf64_shdr Elf64_Shdr;\n\nstruct idr {\n\tstruct xarray idr_rt;\n\tunsigned int idr_base;\n\tunsigned int idr_next;\n};\n\nstruct kernfs_root;\n\nstruct kernfs_elem_dir {\n\tlong unsigned int subdirs;\n\tstruct rb_root children;\n\tstruct kernfs_root *root;\n\tlong unsigned int rev;\n};\n\nstruct kernfs_node;\n\nstruct kernfs_syscall_ops;\n\nstruct kernfs_root {\n\tstruct kernfs_node *kn;\n\tunsigned int flags;\n\tstruct idr ino_idr;\n\tu32 last_id_lowbits;\n\tu32 id_highbits;\n\tstruct kernfs_syscall_ops *syscall_ops;\n\tstruct list_head supers;\n\twait_queue_head_t deactivate_waitq;\n};\n\nstruct kernfs_elem_symlink {\n\tstruct kernfs_node *target_kn;\n};\n\nstruct kernfs_ops;\n\nstruct kernfs_open_node;\n\nstruct kernfs_elem_attr {\n\tconst struct kernfs_ops *ops;\n\tstruct kernfs_open_node *open;\n\tloff_t size;\n\tstruct kernfs_node *notify_next;\n};\n\nstruct kernfs_iattrs;\n\nstruct kernfs_node {\n\tatomic_t count;\n\tatomic_t active;\n\tstruct kernfs_node *parent;\n\tconst char *name;\n\tstruct rb_node rb;\n\tconst void *ns;\n\tunsigned int hash;\n\tunion {\n\t\tstruct kernfs_elem_dir dir;\n\t\tstruct kernfs_elem_symlink symlink;\n\t\tstruct kernfs_elem_attr attr;\n\t};\n\tvoid *priv;\n\tu64 id;\n\tshort unsigned int flags;\n\tumode_t mode;\n\tstruct kernfs_iattrs *iattr;\n};\n\nstruct kernfs_open_file;\n\nstruct kernfs_ops {\n\tint (*open)(struct kernfs_open_file *);\n\tvoid (*release)(struct kernfs_open_file *);\n\tint (*seq_show)(struct seq_file *, void *);\n\tvoid * (*seq_start)(struct seq_file *, loff_t *);\n\tvoid * (*seq_next)(struct seq_file *, void *, loff_t *);\n\tvoid (*seq_stop)(struct seq_file *, void *);\n\tssize_t (*read)(struct kernfs_open_file *, char *, size_t, loff_t);\n\tsize_t atomic_write_len;\n\tbool prealloc;\n\tssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);\n\t__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);\n\tint (*mmap)(struct kernfs_open_file *, struct vm_area_struct *);\n};\n\nstruct kernfs_syscall_ops {\n\tint (*show_options)(struct seq_file *, struct kernfs_root *);\n\tint (*mkdir)(struct kernfs_node *, const char *, umode_t);\n\tint (*rmdir)(struct kernfs_node *);\n\tint (*rename)(struct kernfs_node *, struct kernfs_node *, const char *);\n\tint (*show_path)(struct seq_file *, struct kernfs_node *, struct kernfs_root *);\n};\n\nstruct seq_file {\n\tchar *buf;\n\tsize_t size;\n\tsize_t from;\n\tsize_t count;\n\tsize_t pad_until;\n\tloff_t index;\n\tloff_t read_pos;\n\tstruct mutex lock;\n\tconst struct seq_operations *op;\n\tint poll_event;\n\tconst struct file *file;\n\tvoid *private;\n};\n\nstruct kernfs_open_file {\n\tstruct kernfs_node *kn;\n\tstruct file *file;\n\tstruct seq_file *seq_file;\n\tvoid *priv;\n\tstruct mutex mutex;\n\tstruct mutex prealloc_mutex;\n\tint event;\n\tstruct list_head list;\n\tchar *prealloc_buf;\n\tsize_t atomic_write_len;\n\tbool mmapped: 1;\n\tbool released: 1;\n\tconst struct vm_operations_struct *vm_ops;\n};\n\ntypedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);\n\nstruct poll_table_struct {\n\tpoll_queue_proc _qproc;\n\t__poll_t _key;\n};\n\nenum kobj_ns_type {\n\tKOBJ_NS_TYPE_NONE = 0,\n\tKOBJ_NS_TYPE_NET = 1,\n\tKOBJ_NS_TYPES = 2,\n};\n\nstruct sock;\n\nstruct kobj_ns_type_operations {\n\tenum kobj_ns_type type;\n\tbool (*current_may_mount)();\n\tvoid * (*grab_current_ns)();\n\tconst void * (*netlink_ns)(struct sock *);\n\tconst void * (*initial_ns)();\n\tvoid (*drop_ns)(void *);\n};\n\nstruct attribute {\n\tconst char *name;\n\tumode_t mode;\n};\n\nstruct kobject;\n\nstruct bin_attribute;\n\nstruct attribute_group {\n\tconst char *name;\n\tumode_t (*is_visible)(struct kobject *, struct attribute *, int);\n\tumode_t (*is_bin_visible)(struct kobject *, struct bin_attribute *, int);\n\tstruct attribute **attrs;\n\tstruct bin_attribute **bin_attrs;\n};\n\nstruct kref {\n\trefcount_t refcount;\n};\n\nstruct kset;\n\nstruct kobj_type;\n\nstruct kobject {\n\tconst char *name;\n\tstruct list_head entry;\n\tstruct kobject *parent;\n\tstruct kset *kset;\n\tstruct kobj_type *ktype;\n\tstruct kernfs_node *sd;\n\tstruct kref kref;\n\tunsigned int state_initialized: 1;\n\tunsigned int state_in_sysfs: 1;\n\tunsigned int state_add_uevent_sent: 1;\n\tunsigned int state_remove_uevent_sent: 1;\n\tunsigned int uevent_suppress: 1;\n};\n\nstruct bin_attribute {\n\tstruct attribute attr;\n\tsize_t size;\n\tvoid *private;\n\tstruct address_space * (*f_mapping)();\n\tssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);\n\tssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);\n\tint (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *);\n};\n\nstruct sysfs_ops {\n\tssize_t (*show)(struct kobject *, struct attribute *, char *);\n\tssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);\n};\n\nenum refcount_saturation_type {\n\tREFCOUNT_ADD_NOT_ZERO_OVF = 0,\n\tREFCOUNT_ADD_OVF = 1,\n\tREFCOUNT_ADD_UAF = 2,\n\tREFCOUNT_SUB_UAF = 3,\n\tREFCOUNT_DEC_LEAK = 4,\n};\n\nstruct kset_uevent_ops;\n\nstruct kset {\n\tstruct list_head list;\n\tspinlock_t list_lock;\n\tstruct kobject kobj;\n\tconst struct kset_uevent_ops *uevent_ops;\n};\n\nstruct kobj_type {\n\tvoid (*release)(struct kobject *);\n\tconst struct sysfs_ops *sysfs_ops;\n\tstruct attribute **default_attrs;\n\tconst struct attribute_group **default_groups;\n\tconst struct kobj_ns_type_operations * (*child_ns_type)(struct kobject *);\n\tconst void * (*namespace)(struct kobject *);\n\tvoid (*get_ownership)(struct kobject *, kuid_t *, kgid_t *);\n};\n\nstruct kobj_uevent_env {\n\tchar *argv[3];\n\tchar *envp[64];\n\tint envp_idx;\n\tchar buf[2048];\n\tint buflen;\n};\n\nstruct kset_uevent_ops {\n\tint (* const filter)(struct kset *, struct kobject *);\n\tconst char * (* const name)(struct kset *, struct kobject *);\n\tint (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *);\n};\n\nstruct kernel_param;\n\nstruct kernel_param_ops {\n\tunsigned int flags;\n\tint (*set)(const char *, const struct kernel_param *);\n\tint (*get)(char *, const struct kernel_param *);\n\tvoid (*free)(void *);\n};\n\nstruct kparam_string;\n\nstruct kparam_array;\n\nstruct kernel_param {\n\tconst char *name;\n\tstruct module *mod;\n\tconst struct kernel_param_ops *ops;\n\tconst u16 perm;\n\ts8 level;\n\tu8 flags;\n\tunion {\n\t\tvoid *arg;\n\t\tconst struct kparam_string *str;\n\t\tconst struct kparam_array *arr;\n\t};\n};\n\nstruct kparam_string {\n\tunsigned int maxlen;\n\tchar *string;\n};\n\nstruct kparam_array {\n\tunsigned int max;\n\tunsigned int elemsize;\n\tunsigned int *num;\n\tconst struct kernel_param_ops *ops;\n\tvoid *elem;\n};\n\nenum module_state {\n\tMODULE_STATE_LIVE = 0,\n\tMODULE_STATE_COMING = 1,\n\tMODULE_STATE_GOING = 2,\n\tMODULE_STATE_UNFORMED = 3,\n};\n\nstruct module_param_attrs;\n\nstruct module_kobject {\n\tstruct kobject kobj;\n\tstruct module *mod;\n\tstruct kobject *drivers_dir;\n\tstruct module_param_attrs *mp;\n\tstruct completion *kobj_completion;\n};\n\nstruct latch_tree_node {\n\tstruct rb_node node[2];\n};\n\nstruct mod_tree_node {\n\tstruct module *mod;\n\tstruct latch_tree_node node;\n};\n\nstruct module_layout {\n\tvoid *base;\n\tunsigned int size;\n\tunsigned int text_size;\n\tunsigned int ro_size;\n\tunsigned int ro_after_init_size;\n\tstruct mod_tree_node mtn;\n};\n\nstruct mod_arch_specific {};\n\nstruct mod_kallsyms {\n\tElf64_Sym *symtab;\n\tunsigned int num_symtab;\n\tchar *strtab;\n\tchar *typetab;\n};\n\nstruct module_attribute;\n\nstruct exception_table_entry;\n\nstruct module_sect_attrs;\n\nstruct module_notes_attrs;\n\nstruct trace_eval_map;\n\nstruct klp_modinfo;\n\nstruct error_injection_entry;\n\nstruct module {\n\tenum module_state state;\n\tstruct list_head list;\n\tchar name[56];\n\tstruct module_kobject mkobj;\n\tstruct module_attribute *modinfo_attrs;\n\tconst char *version;\n\tconst char *srcversion;\n\tstruct kobject *holders_dir;\n\tconst struct kernel_symbol *syms;\n\tconst s32 *crcs;\n\tunsigned int num_syms;\n\tstruct mutex param_lock;\n\tstruct kernel_param *kp;\n\tunsigned int num_kp;\n\tunsigned int num_gpl_syms;\n\tconst struct kernel_symbol *gpl_syms;\n\tconst s32 *gpl_crcs;\n\tbool using_gplonly_symbols;\n\tbool sig_ok;\n\tbool async_probe_requested;\n\tunsigned int num_exentries;\n\tstruct exception_table_entry *extable;\n\tint (*init)();\n\tstruct module_layout core_layout;\n\tstruct module_layout init_layout;\n\tstruct mod_arch_specific arch;\n\tlong unsigned int taints;\n\tunsigned int num_bugs;\n\tstruct list_head bug_list;\n\tstruct bug_entry *bug_table;\n\tstruct mod_kallsyms *kallsyms;\n\tstruct mod_kallsyms core_kallsyms;\n\tstruct module_sect_attrs *sect_attrs;\n\tstruct module_notes_attrs *notes_attrs;\n\tchar *args;\n\tvoid *percpu;\n\tunsigned int percpu_size;\n\tvoid *noinstr_text_start;\n\tunsigned int noinstr_text_size;\n\tunsigned int num_tracepoints;\n\ttracepoint_ptr_t *tracepoints_ptrs;\n\tunsigned int num_srcu_structs;\n\tstruct srcu_struct **srcu_struct_ptrs;\n\tunsigned int num_bpf_raw_events;\n\tstruct bpf_raw_event_map *bpf_raw_events;\n\tunsigned int btf_data_size;\n\tvoid *btf_data;\n\tstruct jump_entry *jump_entries;\n\tunsigned int num_jump_entries;\n\tunsigned int num_trace_bprintk_fmt;\n\tconst char **trace_bprintk_fmt_start;\n\tstruct trace_event_call **trace_events;\n\tunsigned int num_trace_events;\n\tstruct trace_eval_map **trace_evals;\n\tunsigned int num_trace_evals;\n\tunsigned int num_ftrace_callsites;\n\tlong unsigned int *ftrace_callsites;\n\tvoid *kprobes_text_start;\n\tunsigned int kprobes_text_size;\n\tlong unsigned int *kprobe_blacklist;\n\tunsigned int num_kprobe_blacklist;\n\tint num_static_call_sites;\n\tstruct static_call_site *static_call_sites;\n\tbool klp;\n\tbool klp_alive;\n\tstruct klp_modinfo *klp_info;\n\tstruct list_head source_list;\n\tstruct list_head target_list;\n\tvoid (*exit)();\n\tatomic_t refcnt;\n\tstruct error_injection_entry *ei_funcs;\n\tunsigned int num_ei_funcs;\n\tlong: 32;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct error_injection_entry {\n\tlong unsigned int addr;\n\tint etype;\n};\n\nstruct module_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct module_attribute *, struct module_kobject *, char *);\n\tssize_t (*store)(struct module_attribute *, struct module_kobject *, const char *, size_t);\n\tvoid (*setup)(struct module *, const char *);\n\tint (*test)(struct module *);\n\tvoid (*free)(struct module *);\n};\n\nstruct klp_modinfo {\n\tElf64_Ehdr hdr;\n\tElf64_Shdr *sechdrs;\n\tchar *secstrings;\n\tunsigned int symndx;\n};\n\nstruct exception_table_entry {\n\tint insn;\n\tint fixup;\n\tint data;\n};\n\nstruct trace_event_functions;\n\nstruct trace_event {\n\tstruct hlist_node node;\n\tstruct list_head list;\n\tint type;\n\tstruct trace_event_functions *funcs;\n};\n\nstruct trace_event_class;\n\nstruct bpf_prog_array;\n\nstruct trace_event_call {\n\tstruct list_head list;\n\tstruct trace_event_class *class;\n\tunion {\n\t\tchar *name;\n\t\tstruct tracepoint *tp;\n\t};\n\tstruct trace_event event;\n\tchar *print_fmt;\n\tstruct event_filter *filter;\n\tunion {\n\t\tvoid *module;\n\t\tatomic_t refcnt;\n\t};\n\tvoid *data;\n\tint flags;\n\tint perf_refcount;\n\tstruct hlist_head *perf_events;\n\tstruct bpf_prog_array *prog_array;\n\tint (*perf_perm)(struct trace_event_call *, struct perf_event *);\n};\n\nstruct trace_eval_map {\n\tconst char *system;\n\tconst char *eval_string;\n\tlong unsigned int eval_value;\n};\n\nstruct cgroup;\n\nstruct cgroup_subsys;\n\nstruct cgroup_subsys_state {\n\tstruct cgroup *cgroup;\n\tstruct cgroup_subsys *ss;\n\tstruct percpu_ref refcnt;\n\tstruct list_head sibling;\n\tstruct list_head children;\n\tstruct list_head rstat_css_node;\n\tint id;\n\tunsigned int flags;\n\tu64 serial_nr;\n\tatomic_t online_cnt;\n\tstruct work_struct destroy_work;\n\tstruct rcu_work destroy_rwork;\n\tstruct cgroup_subsys_state *parent;\n};\n\nstruct mem_cgroup_id {\n\tint id;\n\trefcount_t ref;\n};\n\nstruct page_counter {\n\tatomic_long_t usage;\n\tlong unsigned int min;\n\tlong unsigned int low;\n\tlong unsigned int high;\n\tlong unsigned int max;\n\tlong unsigned int emin;\n\tatomic_long_t min_usage;\n\tatomic_long_t children_min_usage;\n\tlong unsigned int elow;\n\tatomic_long_t low_usage;\n\tatomic_long_t children_low_usage;\n\tlong unsigned int watermark;\n\tlong unsigned int failcnt;\n\tstruct page_counter *parent;\n};\n\nstruct vmpressure {\n\tlong unsigned int scanned;\n\tlong unsigned int reclaimed;\n\tlong unsigned int tree_scanned;\n\tlong unsigned int tree_reclaimed;\n\tspinlock_t sr_lock;\n\tstruct list_head events;\n\tstruct mutex events_lock;\n\tstruct work_struct work;\n};\n\nstruct cgroup_file {\n\tstruct kernfs_node *kn;\n\tlong unsigned int notified_at;\n\tstruct timer_list notify_timer;\n};\n\nstruct mem_cgroup_threshold_ary;\n\nstruct mem_cgroup_thresholds {\n\tstruct mem_cgroup_threshold_ary *primary;\n\tstruct mem_cgroup_threshold_ary *spare;\n};\n\nstruct memcg_padding {\n\tchar x[0];\n};\n\nstruct memcg_vmstats {\n\tlong int state[42];\n\tlong unsigned int events[100];\n\tlong int state_pending[42];\n\tlong unsigned int events_pending[100];\n};\n\nenum memcg_kmem_state {\n\tKMEM_NONE = 0,\n\tKMEM_ALLOCATED = 1,\n\tKMEM_ONLINE = 2,\n};\n\nstruct fprop_global {\n\tstruct percpu_counter events;\n\tunsigned int period;\n\tseqcount_t sequence;\n};\n\nstruct wb_domain {\n\tspinlock_t lock;\n\tstruct fprop_global completions;\n\tstruct timer_list period_timer;\n\tlong unsigned int period_time;\n\tlong unsigned int dirty_limit_tstamp;\n\tlong unsigned int dirty_limit;\n};\n\nstruct wb_completion {\n\tatomic_t cnt;\n\twait_queue_head_t *waitq;\n};\n\nstruct memcg_cgwb_frn {\n\tu64 bdi_id;\n\tint memcg_id;\n\tu64 at;\n\tstruct wb_completion done;\n};\n\nstruct obj_cgroup;\n\nstruct memcg_vmstats_percpu;\n\nstruct mem_cgroup_per_node;\n\nstruct mem_cgroup {\n\tstruct cgroup_subsys_state css;\n\tstruct mem_cgroup_id id;\n\tstruct page_counter memory;\n\tunion {\n\t\tstruct page_counter swap;\n\t\tstruct page_counter memsw;\n\t};\n\tstruct page_counter kmem;\n\tstruct page_counter tcpmem;\n\tstruct work_struct high_work;\n\tlong unsigned int soft_limit;\n\tstruct vmpressure vmpressure;\n\tbool oom_group;\n\tbool oom_lock;\n\tint under_oom;\n\tint swappiness;\n\tint oom_kill_disable;\n\tstruct cgroup_file events_file;\n\tstruct cgroup_file events_local_file;\n\tstruct cgroup_file swap_events_file;\n\tstruct mutex thresholds_lock;\n\tstruct mem_cgroup_thresholds thresholds;\n\tstruct mem_cgroup_thresholds memsw_thresholds;\n\tstruct list_head oom_notify;\n\tlong unsigned int move_charge_at_immigrate;\n\tspinlock_t move_lock;\n\tlong unsigned int move_lock_flags;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct memcg_padding _pad1_;\n\tstruct memcg_vmstats vmstats;\n\tatomic_long_t memory_events[8];\n\tatomic_long_t memory_events_local[8];\n\tlong unsigned int socket_pressure;\n\tbool tcpmem_active;\n\tint tcpmem_pressure;\n\tint kmemcg_id;\n\tenum memcg_kmem_state kmem_state;\n\tstruct obj_cgroup *objcg;\n\tstruct list_head objcg_list;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct memcg_padding _pad2_;\n\tatomic_t moving_account;\n\tstruct task_struct *move_lock_task;\n\tstruct memcg_vmstats_percpu *vmstats_percpu;\n\tstruct list_head cgwb_list;\n\tstruct wb_domain cgwb_domain;\n\tstruct memcg_cgwb_frn cgwb_frn[4];\n\tstruct list_head event_list;\n\tspinlock_t event_list_lock;\n\tstruct deferred_split deferred_split_queue;\n\tstruct mem_cgroup_per_node *nodeinfo[0];\n\tlong: 64;\n};\n\nstruct fs_pin;\n\nstruct pid_namespace {\n\tstruct idr idr;\n\tstruct callback_head rcu;\n\tunsigned int pid_allocated;\n\tstruct task_struct *child_reaper;\n\tstruct kmem_cache *pid_cachep;\n\tunsigned int level;\n\tstruct pid_namespace *parent;\n\tstruct fs_pin *bacct;\n\tstruct user_namespace *user_ns;\n\tstruct ucounts *ucounts;\n\tint reboot;\n\tstruct ns_common ns;\n};\n\nstruct ucounts {\n\tstruct hlist_node node;\n\tstruct user_namespace *ns;\n\tkuid_t uid;\n\tatomic_t count;\n\tatomic_long_t ucount[16];\n};\n\nstruct rhash_head {\n\tstruct rhash_head *next;\n};\n\nstruct rhashtable;\n\nstruct rhashtable_compare_arg {\n\tstruct rhashtable *ht;\n\tconst void *key;\n};\n\ntypedef u32 (*rht_hashfn_t)(const void *, u32, u32);\n\ntypedef u32 (*rht_obj_hashfn_t)(const void *, u32, u32);\n\ntypedef int (*rht_obj_cmpfn_t)(struct rhashtable_compare_arg *, const void *);\n\nstruct rhashtable_params {\n\tu16 nelem_hint;\n\tu16 key_len;\n\tu16 key_offset;\n\tu16 head_offset;\n\tunsigned int max_size;\n\tu16 min_size;\n\tbool automatic_shrinking;\n\trht_hashfn_t hashfn;\n\trht_obj_hashfn_t obj_hashfn;\n\trht_obj_cmpfn_t obj_cmpfn;\n};\n\nstruct bucket_table;\n\nstruct rhashtable {\n\tstruct bucket_table *tbl;\n\tunsigned int key_len;\n\tunsigned int max_elems;\n\tstruct rhashtable_params p;\n\tbool rhlist;\n\tstruct work_struct run_work;\n\tstruct mutex mutex;\n\tspinlock_t lock;\n\tatomic_t nelems;\n};\n\nstruct task_cputime {\n\tu64 stime;\n\tu64 utime;\n\tlong long unsigned int sum_exec_runtime;\n};\n\nstruct uts_namespace;\n\nstruct ipc_namespace;\n\nstruct mnt_namespace;\n\nstruct net;\n\nstruct time_namespace;\n\nstruct cgroup_namespace;\n\nstruct nsproxy {\n\tatomic_t count;\n\tstruct uts_namespace *uts_ns;\n\tstruct ipc_namespace *ipc_ns;\n\tstruct mnt_namespace *mnt_ns;\n\tstruct pid_namespace *pid_ns_for_children;\n\tstruct net *net_ns;\n\tstruct time_namespace *time_ns;\n\tstruct time_namespace *time_ns_for_children;\n\tstruct cgroup_namespace *cgroup_ns;\n};\n\nstruct bio;\n\nstruct bio_list {\n\tstruct bio *head;\n\tstruct bio *tail;\n};\n\nstruct blk_plug {\n\tstruct list_head mq_list;\n\tstruct list_head cb_list;\n\tshort unsigned int rq_count;\n\tbool multiple_queues;\n\tbool nowait;\n};\n\nstruct reclaim_state {\n\tlong unsigned int reclaimed_slab;\n};\n\nstruct fprop_local_percpu {\n\tstruct percpu_counter events;\n\tunsigned int period;\n\traw_spinlock_t lock;\n};\n\nenum wb_reason {\n\tWB_REASON_BACKGROUND = 0,\n\tWB_REASON_VMSCAN = 1,\n\tWB_REASON_SYNC = 2,\n\tWB_REASON_PERIODIC = 3,\n\tWB_REASON_LAPTOP_TIMER = 4,\n\tWB_REASON_FS_FREE_SPACE = 5,\n\tWB_REASON_FORKER_THREAD = 6,\n\tWB_REASON_FOREIGN_FLUSH = 7,\n\tWB_REASON_MAX = 8,\n};\n\nstruct bdi_writeback {\n\tstruct backing_dev_info *bdi;\n\tlong unsigned int state;\n\tlong unsigned int last_old_flush;\n\tstruct list_head b_dirty;\n\tstruct list_head b_io;\n\tstruct list_head b_more_io;\n\tstruct list_head b_dirty_time;\n\tspinlock_t list_lock;\n\tatomic_t writeback_inodes;\n\tstruct percpu_counter stat[4];\n\tlong unsigned int congested;\n\tlong unsigned int bw_time_stamp;\n\tlong unsigned int dirtied_stamp;\n\tlong unsigned int written_stamp;\n\tlong unsigned int write_bandwidth;\n\tlong unsigned int avg_write_bandwidth;\n\tlong unsigned int dirty_ratelimit;\n\tlong unsigned int balanced_dirty_ratelimit;\n\tstruct fprop_local_percpu completions;\n\tint dirty_exceeded;\n\tenum wb_reason start_all_reason;\n\tspinlock_t work_lock;\n\tstruct list_head work_list;\n\tstruct delayed_work dwork;\n\tstruct delayed_work bw_dwork;\n\tlong unsigned int dirty_sleep;\n\tstruct list_head bdi_node;\n\tstruct percpu_ref refcnt;\n\tstruct fprop_local_percpu memcg_completions;\n\tstruct cgroup_subsys_state *memcg_css;\n\tstruct cgroup_subsys_state *blkcg_css;\n\tstruct list_head memcg_node;\n\tstruct list_head blkcg_node;\n\tstruct list_head b_attached;\n\tstruct list_head offline_node;\n\tunion {\n\t\tstruct work_struct release_work;\n\t\tstruct callback_head rcu;\n\t};\n};\n\nstruct backing_dev_info {\n\tu64 id;\n\tstruct rb_node rb_node;\n\tstruct list_head bdi_list;\n\tlong unsigned int ra_pages;\n\tlong unsigned int io_pages;\n\tstruct kref refcnt;\n\tunsigned int capabilities;\n\tunsigned int min_ratio;\n\tunsigned int max_ratio;\n\tunsigned int max_prop_frac;\n\tatomic_long_t tot_write_bandwidth;\n\tstruct bdi_writeback wb;\n\tstruct list_head wb_list;\n\tstruct xarray cgwb_tree;\n\tstruct mutex cgwb_release_mutex;\n\tstruct rw_semaphore wb_switch_rwsem;\n\twait_queue_head_t wb_waitq;\n\tstruct device *dev;\n\tchar dev_name[64];\n\tstruct device *owner;\n\tstruct timer_list laptop_mode_wb_timer;\n\tstruct dentry *debug_dir;\n};\n\nstruct css_set {\n\tstruct cgroup_subsys_state *subsys[14];\n\trefcount_t refcount;\n\tstruct css_set *dom_cset;\n\tstruct cgroup *dfl_cgrp;\n\tint nr_tasks;\n\tstruct list_head tasks;\n\tstruct list_head mg_tasks;\n\tstruct list_head dying_tasks;\n\tstruct list_head task_iters;\n\tstruct list_head e_cset_node[14];\n\tstruct list_head threaded_csets;\n\tstruct list_head threaded_csets_node;\n\tstruct hlist_node hlist;\n\tstruct list_head cgrp_links;\n\tstruct list_head mg_src_preload_node;\n\tstruct list_head mg_dst_preload_node;\n\tstruct list_head mg_node;\n\tstruct cgroup *mg_src_cgrp;\n\tstruct cgroup *mg_dst_cgrp;\n\tstruct css_set *mg_dst_cset;\n\tbool dead;\n\tstruct callback_head callback_head;\n};\n\ntypedef u32 compat_uptr_t;\n\nstruct compat_robust_list {\n\tcompat_uptr_t next;\n};\n\ntypedef s32 compat_long_t;\n\nstruct compat_robust_list_head {\n\tstruct compat_robust_list list;\n\tcompat_long_t futex_offset;\n\tcompat_uptr_t list_op_pending;\n};\n\nstruct perf_event_groups {\n\tstruct rb_root tree;\n\tu64 index;\n};\n\nstruct perf_event_context {\n\tstruct pmu *pmu;\n\traw_spinlock_t lock;\n\tstruct mutex mutex;\n\tstruct list_head active_ctx_list;\n\tstruct perf_event_groups pinned_groups;\n\tstruct perf_event_groups flexible_groups;\n\tstruct list_head event_list;\n\tstruct list_head pinned_active;\n\tstruct list_head flexible_active;\n\tint nr_events;\n\tint nr_active;\n\tint is_active;\n\tint nr_stat;\n\tint nr_freq;\n\tint rotate_disable;\n\tint rotate_necessary;\n\trefcount_t refcount;\n\tstruct task_struct *task;\n\tu64 time;\n\tu64 timestamp;\n\tu64 timeoffset;\n\tstruct perf_event_context *parent_ctx;\n\tu64 parent_gen;\n\tu64 generation;\n\tint pin_count;\n\tint nr_cgroups;\n\tvoid *task_ctx_data;\n\tstruct callback_head callback_head;\n};\n\nstruct pipe_buffer;\n\nstruct watch_queue;\n\nstruct pipe_inode_info {\n\tstruct mutex mutex;\n\twait_queue_head_t rd_wait;\n\twait_queue_head_t wr_wait;\n\tunsigned int head;\n\tunsigned int tail;\n\tunsigned int max_usage;\n\tunsigned int ring_size;\n\tbool note_loss;\n\tunsigned int nr_accounted;\n\tunsigned int readers;\n\tunsigned int writers;\n\tunsigned int files;\n\tunsigned int r_counter;\n\tunsigned int w_counter;\n\tbool poll_usage;\n\tstruct page *tmp_page;\n\tstruct fasync_struct *fasync_readers;\n\tstruct fasync_struct *fasync_writers;\n\tstruct pipe_buffer *bufs;\n\tstruct user_struct *user;\n\tstruct watch_queue *watch_queue;\n};\n\nstruct task_delay_info {\n\traw_spinlock_t lock;\n\tunsigned int flags;\n\tu64 blkio_start;\n\tu64 blkio_delay;\n\tu64 swapin_delay;\n\tu32 blkio_count;\n\tu32 swapin_count;\n\tu64 freepages_start;\n\tu64 freepages_delay;\n\tu64 thrashing_start;\n\tu64 thrashing_delay;\n\tu32 freepages_count;\n\tu32 thrashing_count;\n};\n\nstruct ftrace_ret_stack {\n\tlong unsigned int ret;\n\tlong unsigned int func;\n\tlong long unsigned int calltime;\n\tlong long unsigned int subtime;\n\tlong unsigned int *retp;\n};\n\nstruct blk_integrity_profile;\n\nstruct blk_integrity {\n\tconst struct blk_integrity_profile *profile;\n\tunsigned char flags;\n\tunsigned char tuple_size;\n\tunsigned char interval_exp;\n\tunsigned char tag_size;\n};\n\nenum rpm_status {\n\tRPM_ACTIVE = 0,\n\tRPM_RESUMING = 1,\n\tRPM_SUSPENDED = 2,\n\tRPM_SUSPENDING = 3,\n};\n\nstruct blk_rq_stat {\n\tu64 mean;\n\tu64 min;\n\tu64 max;\n\tu32 nr_samples;\n\tu64 batch;\n};\n\nstruct sbitmap_word;\n\nstruct sbitmap {\n\tunsigned int depth;\n\tunsigned int shift;\n\tunsigned int map_nr;\n\tbool round_robin;\n\tstruct sbitmap_word *map;\n\tunsigned int *alloc_hint;\n};\n\nstruct sbq_wait_state;\n\nstruct sbitmap_queue {\n\tstruct sbitmap sb;\n\tunsigned int wake_batch;\n\tatomic_t wake_index;\n\tstruct sbq_wait_state *ws;\n\tatomic_t ws_active;\n\tunsigned int min_shallow_depth;\n};\n\nenum blk_bounce {\n\tBLK_BOUNCE_NONE = 0,\n\tBLK_BOUNCE_HIGH = 1,\n};\n\nenum blk_zoned_model {\n\tBLK_ZONED_NONE = 0,\n\tBLK_ZONED_HA = 1,\n\tBLK_ZONED_HM = 2,\n};\n\nstruct queue_limits {\n\tenum blk_bounce bounce;\n\tlong unsigned int seg_boundary_mask;\n\tlong unsigned int virt_boundary_mask;\n\tunsigned int max_hw_sectors;\n\tunsigned int max_dev_sectors;\n\tunsigned int chunk_sectors;\n\tunsigned int max_sectors;\n\tunsigned int max_segment_size;\n\tunsigned int physical_block_size;\n\tunsigned int logical_block_size;\n\tunsigned int alignment_offset;\n\tunsigned int io_min;\n\tunsigned int io_opt;\n\tunsigned int max_discard_sectors;\n\tunsigned int max_hw_discard_sectors;\n\tunsigned int max_write_same_sectors;\n\tunsigned int max_write_zeroes_sectors;\n\tunsigned int max_zone_append_sectors;\n\tunsigned int discard_granularity;\n\tunsigned int discard_alignment;\n\tunsigned int zone_write_granularity;\n\tshort unsigned int max_segments;\n\tshort unsigned int max_integrity_segments;\n\tshort unsigned int max_discard_segments;\n\tunsigned char misaligned;\n\tunsigned char discard_misaligned;\n\tunsigned char raid_partial_stripes_expensive;\n\tenum blk_zoned_model zoned;\n};\n\ntypedef void *mempool_alloc_t(gfp_t, void *);\n\ntypedef void mempool_free_t(void *, void *);\n\nstruct mempool_s {\n\tspinlock_t lock;\n\tint min_nr;\n\tint curr_nr;\n\tvoid **elements;\n\tvoid *pool_data;\n\tmempool_alloc_t *alloc;\n\tmempool_free_t *free;\n\twait_queue_head_t wait;\n};\n\ntypedef struct mempool_s mempool_t;\n\nstruct bio_alloc_cache;\n\nstruct bio_set {\n\tstruct kmem_cache *bio_slab;\n\tunsigned int front_pad;\n\tstruct bio_alloc_cache *cache;\n\tmempool_t bio_pool;\n\tmempool_t bvec_pool;\n\tmempool_t bio_integrity_pool;\n\tmempool_t bvec_integrity_pool;\n\tunsigned int back_pad;\n\tspinlock_t rescue_lock;\n\tstruct bio_list rescue_list;\n\tstruct work_struct rescue_work;\n\tstruct workqueue_struct *rescue_workqueue;\n\tstruct hlist_node cpuhp_dead;\n};\n\nstruct request;\n\nstruct elevator_queue;\n\nstruct blk_queue_stats;\n\nstruct rq_qos;\n\nstruct blk_mq_ops;\n\nstruct blk_mq_ctx;\n\nstruct blk_mq_hw_ctx;\n\nstruct gendisk;\n\nstruct blk_keyslot_manager;\n\nstruct blk_stat_callback;\n\nstruct blkcg_gq;\n\nstruct blk_trace;\n\nstruct blk_flush_queue;\n\nstruct throtl_data;\n\nstruct blk_mq_tag_set;\n\nstruct request_queue {\n\tstruct request *last_merge;\n\tstruct elevator_queue *elevator;\n\tstruct percpu_ref q_usage_counter;\n\tstruct blk_queue_stats *stats;\n\tstruct rq_qos *rq_qos;\n\tconst struct blk_mq_ops *mq_ops;\n\tstruct blk_mq_ctx *queue_ctx;\n\tunsigned int queue_depth;\n\tstruct blk_mq_hw_ctx **queue_hw_ctx;\n\tunsigned int nr_hw_queues;\n\tvoid *queuedata;\n\tlong unsigned int queue_flags;\n\tatomic_t pm_only;\n\tint id;\n\tspinlock_t queue_lock;\n\tstruct gendisk *disk;\n\tstruct kobject kobj;\n\tstruct kobject *mq_kobj;\n\tstruct blk_integrity integrity;\n\tstruct device *dev;\n\tenum rpm_status rpm_status;\n\tlong unsigned int nr_requests;\n\tunsigned int dma_pad_mask;\n\tunsigned int dma_alignment;\n\tstruct blk_keyslot_manager *ksm;\n\tunsigned int rq_timeout;\n\tint poll_nsec;\n\tstruct blk_stat_callback *poll_cb;\n\tstruct blk_rq_stat poll_stat[16];\n\tstruct timer_list timeout;\n\tstruct work_struct timeout_work;\n\tatomic_t nr_active_requests_shared_sbitmap;\n\tstruct sbitmap_queue sched_bitmap_tags;\n\tstruct sbitmap_queue sched_breserved_tags;\n\tstruct list_head icq_list;\n\tlong unsigned int blkcg_pols[1];\n\tstruct blkcg_gq *root_blkg;\n\tstruct list_head blkg_list;\n\tstruct queue_limits limits;\n\tunsigned int required_elevator_features;\n\tunsigned int nr_zones;\n\tlong unsigned int *conv_zones_bitmap;\n\tlong unsigned int *seq_zones_wlock;\n\tunsigned int max_open_zones;\n\tunsigned int max_active_zones;\n\tint node;\n\tstruct mutex debugfs_mutex;\n\tstruct blk_trace *blk_trace;\n\tstruct blk_flush_queue *fq;\n\tstruct list_head requeue_list;\n\tspinlock_t requeue_lock;\n\tstruct delayed_work requeue_work;\n\tstruct mutex sysfs_lock;\n\tstruct mutex sysfs_dir_lock;\n\tstruct list_head unused_hctx_list;\n\tspinlock_t unused_hctx_lock;\n\tint mq_freeze_depth;\n\tstruct throtl_data *td;\n\tstruct callback_head callback_head;\n\twait_queue_head_t mq_freeze_wq;\n\tstruct mutex mq_freeze_lock;\n\tstruct blk_mq_tag_set *tag_set;\n\tstruct list_head tag_set_list;\n\tstruct bio_set bio_split;\n\tstruct dentry *debugfs_dir;\n\tstruct dentry *sched_debugfs_dir;\n\tstruct dentry *rqos_debugfs_dir;\n\tbool mq_sysfs_init_done;\n\tsize_t cmd_size;\n\tu64 write_hints[5];\n};\n\nstruct bpf_run_ctx {};\n\nstruct cgroup_base_stat {\n\tstruct task_cputime cputime;\n};\n\nstruct psi_group_cpu;\n\nstruct psi_group {\n\tstruct mutex avgs_lock;\n\tstruct psi_group_cpu *pcpu;\n\tu64 avg_total[6];\n\tu64 avg_last_update;\n\tu64 avg_next_update;\n\tstruct delayed_work avgs_work;\n\tu64 total[12];\n\tlong unsigned int avg[18];\n\tstruct task_struct *poll_task;\n\tstruct timer_list poll_timer;\n\twait_queue_head_t poll_wait;\n\tatomic_t poll_wakeup;\n\tstruct mutex trigger_lock;\n\tstruct list_head triggers;\n\tu32 nr_triggers[6];\n\tu32 poll_states;\n\tu64 poll_min_period;\n\tu64 polling_total[6];\n\tu64 polling_next_update;\n\tu64 polling_until;\n};\n\nstruct cgroup_bpf {\n\tstruct bpf_prog_array *effective[23];\n\tstruct list_head progs[23];\n\tu32 flags[23];\n\tstruct list_head storages;\n\tstruct bpf_prog_array *inactive;\n\tstruct percpu_ref refcnt;\n\tstruct work_struct release_work;\n};\n\nstruct cgroup_freezer_state {\n\tbool freeze;\n\tint e_freeze;\n\tint nr_frozen_descendants;\n\tint nr_frozen_tasks;\n};\n\nstruct cgroup_root;\n\nstruct cgroup_rstat_cpu;\n\nstruct cgroup {\n\tstruct cgroup_subsys_state self;\n\tlong unsigned int flags;\n\tint level;\n\tint max_depth;\n\tint nr_descendants;\n\tint nr_dying_descendants;\n\tint max_descendants;\n\tint nr_populated_csets;\n\tint nr_populated_domain_children;\n\tint nr_populated_threaded_children;\n\tint nr_threaded_children;\n\tstruct kernfs_node *kn;\n\tstruct cgroup_file procs_file;\n\tstruct cgroup_file events_file;\n\tu16 subtree_control;\n\tu16 subtree_ss_mask;\n\tu16 old_subtree_control;\n\tu16 old_subtree_ss_mask;\n\tstruct cgroup_subsys_state *subsys[14];\n\tstruct cgroup_root *root;\n\tstruct list_head cset_links;\n\tstruct list_head e_csets[14];\n\tstruct cgroup *dom_cgrp;\n\tstruct cgroup *old_dom_cgrp;\n\tstruct cgroup_rstat_cpu *rstat_cpu;\n\tstruct list_head rstat_css_list;\n\tstruct cgroup_base_stat last_bstat;\n\tstruct cgroup_base_stat bstat;\n\tstruct prev_cputime prev_cputime;\n\tstruct list_head pidlists;\n\tstruct mutex pidlist_mutex;\n\twait_queue_head_t offline_waitq;\n\tstruct work_struct release_agent_work;\n\tstruct psi_group psi;\n\tstruct cgroup_bpf bpf;\n\tatomic_t congestion_count;\n\tstruct cgroup_freezer_state freezer;\n\tu64 ancestor_ids[0];\n};\n\nstruct taskstats {\n\t__u16 version;\n\t__u32 ac_exitcode;\n\t__u8 ac_flag;\n\t__u8 ac_nice;\n\t__u64 cpu_count;\n\t__u64 cpu_delay_total;\n\t__u64 blkio_count;\n\t__u64 blkio_delay_total;\n\t__u64 swapin_count;\n\t__u64 swapin_delay_total;\n\t__u64 cpu_run_real_total;\n\t__u64 cpu_run_virtual_total;\n\tchar ac_comm[32];\n\t__u8 ac_sched;\n\t__u8 ac_pad[3];\n\tint: 32;\n\t__u32 ac_uid;\n\t__u32 ac_gid;\n\t__u32 ac_pid;\n\t__u32 ac_ppid;\n\t__u32 ac_btime;\n\t__u64 ac_etime;\n\t__u64 ac_utime;\n\t__u64 ac_stime;\n\t__u64 ac_minflt;\n\t__u64 ac_majflt;\n\t__u64 coremem;\n\t__u64 virtmem;\n\t__u64 hiwater_rss;\n\t__u64 hiwater_vm;\n\t__u64 read_char;\n\t__u64 write_char;\n\t__u64 read_syscalls;\n\t__u64 write_syscalls;\n\t__u64 read_bytes;\n\t__u64 write_bytes;\n\t__u64 cancelled_write_bytes;\n\t__u64 nvcsw;\n\t__u64 nivcsw;\n\t__u64 ac_utimescaled;\n\t__u64 ac_stimescaled;\n\t__u64 cpu_scaled_run_real_total;\n\t__u64 freepages_count;\n\t__u64 freepages_delay_total;\n\t__u64 thrashing_count;\n\t__u64 thrashing_delay_total;\n\t__u64 ac_btime64;\n};\n\ntypedef struct {\n\t__u8 b[16];\n} guid_t;\n\nstruct wait_page_queue {\n\tstruct page *page;\n\tint bit_nr;\n\twait_queue_entry_t wait;\n};\n\nenum writeback_sync_modes {\n\tWB_SYNC_NONE = 0,\n\tWB_SYNC_ALL = 1,\n};\n\nstruct writeback_control {\n\tlong int nr_to_write;\n\tlong int pages_skipped;\n\tloff_t range_start;\n\tloff_t range_end;\n\tenum writeback_sync_modes sync_mode;\n\tunsigned int for_kupdate: 1;\n\tunsigned int for_background: 1;\n\tunsigned int tagged_writepages: 1;\n\tunsigned int for_reclaim: 1;\n\tunsigned int range_cyclic: 1;\n\tunsigned int for_sync: 1;\n\tunsigned int no_cgroup_owner: 1;\n\tunsigned int punt_to_cgroup: 1;\n\tstruct bdi_writeback *wb;\n\tstruct inode *inode;\n\tint wb_id;\n\tint wb_lcand_id;\n\tint wb_tcand_id;\n\tsize_t wb_bytes;\n\tsize_t wb_lcand_bytes;\n\tsize_t wb_tcand_bytes;\n};\n\nstruct readahead_control {\n\tstruct file *file;\n\tstruct address_space *mapping;\n\tstruct file_ra_state *ra;\n\tlong unsigned int _index;\n\tunsigned int _nr_pages;\n\tunsigned int _batch_count;\n};\n\nstruct iovec;\n\nstruct kvec;\n\nstruct bio_vec;\n\nstruct iov_iter {\n\tu8 iter_type;\n\tbool nofault;\n\tbool data_source;\n\tsize_t iov_offset;\n\tsize_t count;\n\tunion {\n\t\tconst struct iovec *iov;\n\t\tconst struct kvec *kvec;\n\t\tconst struct bio_vec *bvec;\n\t\tstruct xarray *xarray;\n\t\tstruct pipe_inode_info *pipe;\n\t};\n\tunion {\n\t\tlong unsigned int nr_segs;\n\t\tstruct {\n\t\t\tunsigned int head;\n\t\t\tunsigned int start_head;\n\t\t};\n\t\tloff_t xarray_start;\n\t};\n};\n\nstruct swap_cluster_info {\n\tspinlock_t lock;\n\tunsigned int data: 24;\n\tunsigned int flags: 8;\n};\n\nstruct swap_cluster_list {\n\tstruct swap_cluster_info head;\n\tstruct swap_cluster_info tail;\n};\n\nstruct percpu_cluster;\n\nstruct swap_info_struct {\n\tstruct percpu_ref users;\n\tlong unsigned int flags;\n\tshort int prio;\n\tstruct plist_node list;\n\tsigned char type;\n\tunsigned int max;\n\tunsigned char *swap_map;\n\tstruct swap_cluster_info *cluster_info;\n\tstruct swap_cluster_list free_clusters;\n\tunsigned int lowest_bit;\n\tunsigned int highest_bit;\n\tunsigned int pages;\n\tunsigned int inuse_pages;\n\tunsigned int cluster_next;\n\tunsigned int cluster_nr;\n\tunsigned int *cluster_next_cpu;\n\tstruct percpu_cluster *percpu_cluster;\n\tstruct rb_root swap_extent_root;\n\tstruct block_device *bdev;\n\tstruct file *swap_file;\n\tunsigned int old_block_size;\n\tstruct completion comp;\n\tlong unsigned int *frontswap_map;\n\tatomic_t frontswap_pages;\n\tspinlock_t lock;\n\tspinlock_t cont_lock;\n\tstruct work_struct discard_work;\n\tstruct swap_cluster_list discard_clusters;\n\tstruct plist_node avail_lists[0];\n};\n\nstruct cdev {\n\tstruct kobject kobj;\n\tstruct module *owner;\n\tconst struct file_operations *ops;\n\tstruct list_head list;\n\tdev_t dev;\n\tunsigned int count;\n};\n\nenum dl_dev_state {\n\tDL_DEV_NO_DRIVER = 0,\n\tDL_DEV_PROBING = 1,\n\tDL_DEV_DRIVER_BOUND = 2,\n\tDL_DEV_UNBINDING = 3,\n};\n\nstruct dev_links_info {\n\tstruct list_head suppliers;\n\tstruct list_head consumers;\n\tstruct list_head defer_sync;\n\tenum dl_dev_state status;\n};\n\nstruct pm_message {\n\tint event;\n};\n\ntypedef struct pm_message pm_message_t;\n\nenum rpm_request {\n\tRPM_REQ_NONE = 0,\n\tRPM_REQ_IDLE = 1,\n\tRPM_REQ_SUSPEND = 2,\n\tRPM_REQ_AUTOSUSPEND = 3,\n\tRPM_REQ_RESUME = 4,\n};\n\nstruct wakeup_source;\n\nstruct wake_irq;\n\nstruct pm_subsys_data;\n\nstruct dev_pm_qos;\n\nstruct dev_pm_info {\n\tpm_message_t power_state;\n\tunsigned int can_wakeup: 1;\n\tunsigned int async_suspend: 1;\n\tbool in_dpm_list: 1;\n\tbool is_prepared: 1;\n\tbool is_suspended: 1;\n\tbool is_noirq_suspended: 1;\n\tbool is_late_suspended: 1;\n\tbool no_pm: 1;\n\tbool early_init: 1;\n\tbool direct_complete: 1;\n\tu32 driver_flags;\n\tspinlock_t lock;\n\tstruct list_head entry;\n\tstruct completion completion;\n\tstruct wakeup_source *wakeup;\n\tbool wakeup_path: 1;\n\tbool syscore: 1;\n\tbool no_pm_callbacks: 1;\n\tunsigned int must_resume: 1;\n\tunsigned int may_skip_resume: 1;\n\tstruct hrtimer suspend_timer;\n\tu64 timer_expires;\n\tstruct work_struct work;\n\twait_queue_head_t wait_queue;\n\tstruct wake_irq *wakeirq;\n\tatomic_t usage_count;\n\tatomic_t child_count;\n\tunsigned int disable_depth: 3;\n\tunsigned int idle_notification: 1;\n\tunsigned int request_pending: 1;\n\tunsigned int deferred_resume: 1;\n\tunsigned int needs_force_resume: 1;\n\tunsigned int runtime_auto: 1;\n\tbool ignore_children: 1;\n\tunsigned int no_callbacks: 1;\n\tunsigned int irq_safe: 1;\n\tunsigned int use_autosuspend: 1;\n\tunsigned int timer_autosuspends: 1;\n\tunsigned int memalloc_noio: 1;\n\tunsigned int links_count;\n\tenum rpm_request request;\n\tenum rpm_status runtime_status;\n\tint runtime_error;\n\tint autosuspend_delay;\n\tu64 last_busy;\n\tu64 active_time;\n\tu64 suspended_time;\n\tu64 accounting_timestamp;\n\tstruct pm_subsys_data *subsys_data;\n\tvoid (*set_latency_tolerance)(struct device *, s32);\n\tstruct dev_pm_qos *qos;\n};\n\nstruct dev_archdata {};\n\nenum device_removable {\n\tDEVICE_REMOVABLE_NOT_SUPPORTED = 0,\n\tDEVICE_REMOVABLE_UNKNOWN = 1,\n\tDEVICE_FIXED = 2,\n\tDEVICE_REMOVABLE = 3,\n};\n\nstruct device_private;\n\nstruct device_type;\n\nstruct bus_type;\n\nstruct device_driver;\n\nstruct dev_pm_domain;\n\nstruct em_perf_domain;\n\nstruct dev_pin_info;\n\nstruct dma_map_ops;\n\nstruct bus_dma_region;\n\nstruct device_dma_parameters;\n\nstruct io_tlb_mem;\n\nstruct device_node;\n\nstruct class;\n\nstruct iommu_group;\n\nstruct dev_iommu;\n\nstruct device {\n\tstruct kobject kobj;\n\tstruct device *parent;\n\tstruct device_private *p;\n\tconst char *init_name;\n\tconst struct device_type *type;\n\tstruct bus_type *bus;\n\tstruct device_driver *driver;\n\tvoid *platform_data;\n\tvoid *driver_data;\n\tstruct mutex mutex;\n\tstruct dev_links_info links;\n\tstruct dev_pm_info power;\n\tstruct dev_pm_domain *pm_domain;\n\tstruct em_perf_domain *em_pd;\n\tstruct irq_domain *msi_domain;\n\tstruct dev_pin_info *pins;\n\traw_spinlock_t msi_lock;\n\tstruct list_head msi_list;\n\tconst struct dma_map_ops *dma_ops;\n\tu64 *dma_mask;\n\tu64 coherent_dma_mask;\n\tu64 bus_dma_limit;\n\tconst struct bus_dma_region *dma_range_map;\n\tstruct device_dma_parameters *dma_parms;\n\tstruct list_head dma_pools;\n\tstruct io_tlb_mem *dma_io_tlb_mem;\n\tstruct dev_archdata archdata;\n\tstruct device_node *of_node;\n\tstruct fwnode_handle *fwnode;\n\tint numa_node;\n\tdev_t devt;\n\tu32 id;\n\tspinlock_t devres_lock;\n\tstruct list_head devres_head;\n\tstruct class *class;\n\tconst struct attribute_group **groups;\n\tvoid (*release)(struct device *);\n\tstruct iommu_group *iommu_group;\n\tstruct dev_iommu *iommu;\n\tenum device_removable removable;\n\tbool offline_disabled: 1;\n\tbool offline: 1;\n\tbool of_node_reused: 1;\n\tbool state_synced: 1;\n\tbool can_match: 1;\n};\n\nstruct disk_stats;\n\nstruct partition_meta_info;\n\nstruct block_device {\n\tsector_t bd_start_sect;\n\tstruct disk_stats *bd_stats;\n\tlong unsigned int bd_stamp;\n\tbool bd_read_only;\n\tdev_t bd_dev;\n\tint bd_openers;\n\tstruct inode *bd_inode;\n\tstruct super_block *bd_super;\n\tvoid *bd_claiming;\n\tstruct device bd_device;\n\tvoid *bd_holder;\n\tint bd_holders;\n\tbool bd_write_holder;\n\tstruct kobject *bd_holder_dir;\n\tu8 bd_partno;\n\tspinlock_t bd_size_lock;\n\tstruct gendisk *bd_disk;\n\tint bd_fsfreeze_count;\n\tstruct mutex bd_fsfreeze_mutex;\n\tstruct super_block *bd_fsfreeze_sb;\n\tstruct partition_meta_info *bd_meta_info;\n};\n\nstruct fc_log;\n\nstruct p_log {\n\tconst char *prefix;\n\tstruct fc_log *log;\n};\n\nenum fs_context_purpose {\n\tFS_CONTEXT_FOR_MOUNT = 0,\n\tFS_CONTEXT_FOR_SUBMOUNT = 1,\n\tFS_CONTEXT_FOR_RECONFIGURE = 2,\n};\n\nenum fs_context_phase {\n\tFS_CONTEXT_CREATE_PARAMS = 0,\n\tFS_CONTEXT_CREATING = 1,\n\tFS_CONTEXT_AWAITING_MOUNT = 2,\n\tFS_CONTEXT_AWAITING_RECONF = 3,\n\tFS_CONTEXT_RECONF_PARAMS = 4,\n\tFS_CONTEXT_RECONFIGURING = 5,\n\tFS_CONTEXT_FAILED = 6,\n};\n\nstruct fs_context_operations;\n\nstruct fs_context {\n\tconst struct fs_context_operations *ops;\n\tstruct mutex uapi_mutex;\n\tstruct file_system_type *fs_type;\n\tvoid *fs_private;\n\tvoid *sget_key;\n\tstruct dentry *root;\n\tstruct user_namespace *user_ns;\n\tstruct net *net_ns;\n\tconst struct cred *cred;\n\tstruct p_log log;\n\tconst char *source;\n\tvoid *security;\n\tvoid *s_fs_info;\n\tunsigned int sb_flags;\n\tunsigned int sb_flags_mask;\n\tunsigned int s_iflags;\n\tunsigned int lsm_flags;\n\tenum fs_context_purpose purpose: 8;\n\tenum fs_context_phase phase: 8;\n\tbool need_free: 1;\n\tbool global: 1;\n\tbool oldapi: 1;\n};\n\nstruct audit_names;\n\nstruct filename {\n\tconst char *name;\n\tconst char *uptr;\n\tint refcnt;\n\tstruct audit_names *aname;\n\tconst char iname[0];\n};\n\ntypedef u8 blk_status_t;\n\nstruct bvec_iter {\n\tsector_t bi_sector;\n\tunsigned int bi_size;\n\tunsigned int bi_idx;\n\tunsigned int bi_bvec_done;\n};\n\ntypedef void bio_end_io_t(struct bio *);\n\nstruct bio_issue {\n\tu64 value;\n};\n\nstruct bio_vec {\n\tstruct page *bv_page;\n\tunsigned int bv_len;\n\tunsigned int bv_offset;\n};\n\nstruct bio_crypt_ctx;\n\nstruct bio_integrity_payload;\n\nstruct bio {\n\tstruct bio *bi_next;\n\tstruct block_device *bi_bdev;\n\tunsigned int bi_opf;\n\tshort unsigned int bi_flags;\n\tshort unsigned int bi_ioprio;\n\tshort unsigned int bi_write_hint;\n\tblk_status_t bi_status;\n\tatomic_t __bi_remaining;\n\tstruct bvec_iter bi_iter;\n\tbio_end_io_t *bi_end_io;\n\tvoid *bi_private;\n\tstruct blkcg_gq *bi_blkg;\n\tstruct bio_issue bi_issue;\n\tu64 bi_iocost_cost;\n\tstruct bio_crypt_ctx *bi_crypt_context;\n\tunion {\n\t\tstruct bio_integrity_payload *bi_integrity;\n\t};\n\tshort unsigned int bi_vcnt;\n\tshort unsigned int bi_max_vecs;\n\tatomic_t __bi_cnt;\n\tstruct bio_vec *bi_io_vec;\n\tstruct bio_set *bi_pool;\n\tstruct bio_vec bi_inline_vecs[0];\n};\n\nstruct linux_binprm {\n\tstruct vm_area_struct *vma;\n\tlong unsigned int vma_pages;\n\tstruct mm_struct *mm;\n\tlong unsigned int p;\n\tlong unsigned int argmin;\n\tunsigned int have_execfd: 1;\n\tunsigned int execfd_creds: 1;\n\tunsigned int secureexec: 1;\n\tunsigned int point_of_no_return: 1;\n\tstruct file *executable;\n\tstruct file *interpreter;\n\tstruct file *file;\n\tstruct cred *cred;\n\tint unsafe;\n\tunsigned int per_clear;\n\tint argc;\n\tint envc;\n\tconst char *filename;\n\tconst char *interp;\n\tconst char *fdpath;\n\tunsigned int interp_flags;\n\tint execfd;\n\tlong unsigned int loader;\n\tlong unsigned int exec;\n\tstruct rlimit rlim_stack;\n\tchar buf[256];\n};\n\nstruct core_vma_metadata;\n\nstruct coredump_params {\n\tconst kernel_siginfo_t *siginfo;\n\tstruct pt_regs *regs;\n\tstruct file *file;\n\tlong unsigned int limit;\n\tlong unsigned int mm_flags;\n\tloff_t written;\n\tloff_t pos;\n\tloff_t to_skip;\n\tint vma_count;\n\tsize_t vma_data_size;\n\tstruct core_vma_metadata *vma_meta;\n};\n\nstruct em_perf_state {\n\tlong unsigned int frequency;\n\tlong unsigned int power;\n\tlong unsigned int cost;\n};\n\nstruct em_perf_domain {\n\tstruct em_perf_state *table;\n\tint nr_perf_states;\n\tint milliwatts;\n\tlong unsigned int cpus[0];\n};\n\nstruct dev_pm_ops {\n\tint (*prepare)(struct device *);\n\tvoid (*complete)(struct device *);\n\tint (*suspend)(struct device *);\n\tint (*resume)(struct device *);\n\tint (*freeze)(struct device *);\n\tint (*thaw)(struct device *);\n\tint (*poweroff)(struct device *);\n\tint (*restore)(struct device *);\n\tint (*suspend_late)(struct device *);\n\tint (*resume_early)(struct device *);\n\tint (*freeze_late)(struct device *);\n\tint (*thaw_early)(struct device *);\n\tint (*poweroff_late)(struct device *);\n\tint (*restore_early)(struct device *);\n\tint (*suspend_noirq)(struct device *);\n\tint (*resume_noirq)(struct device *);\n\tint (*freeze_noirq)(struct device *);\n\tint (*thaw_noirq)(struct device *);\n\tint (*poweroff_noirq)(struct device *);\n\tint (*restore_noirq)(struct device *);\n\tint (*runtime_suspend)(struct device *);\n\tint (*runtime_resume)(struct device *);\n\tint (*runtime_idle)(struct device *);\n};\n\nstruct pm_domain_data;\n\nstruct pm_subsys_data {\n\tspinlock_t lock;\n\tunsigned int refcount;\n\tunsigned int clock_op_might_sleep;\n\tstruct mutex clock_mutex;\n\tstruct list_head clock_list;\n\tstruct pm_domain_data *domain_data;\n};\n\nstruct wakeup_source {\n\tconst char *name;\n\tint id;\n\tstruct list_head entry;\n\tspinlock_t lock;\n\tstruct wake_irq *wakeirq;\n\tstruct timer_list timer;\n\tlong unsigned int timer_expires;\n\tktime_t total_time;\n\tktime_t max_time;\n\tktime_t last_time;\n\tktime_t start_prevent_time;\n\tktime_t prevent_sleep_time;\n\tlong unsigned int event_count;\n\tlong unsigned int active_count;\n\tlong unsigned int relax_count;\n\tlong unsigned int expire_count;\n\tlong unsigned int wakeup_count;\n\tstruct device *dev;\n\tbool active: 1;\n\tbool autosleep_enabled: 1;\n};\n\nstruct dev_pm_domain {\n\tstruct dev_pm_ops ops;\n\tint (*start)(struct device *);\n\tvoid (*detach)(struct device *, bool);\n\tint (*activate)(struct device *);\n\tvoid (*sync)(struct device *);\n\tvoid (*dismiss)(struct device *);\n};\n\nstruct iommu_ops;\n\nstruct subsys_private;\n\nstruct bus_type {\n\tconst char *name;\n\tconst char *dev_name;\n\tstruct device *dev_root;\n\tconst struct attribute_group **bus_groups;\n\tconst struct attribute_group **dev_groups;\n\tconst struct attribute_group **drv_groups;\n\tint (*match)(struct device *, struct device_driver *);\n\tint (*uevent)(struct device *, struct kobj_uevent_env *);\n\tint (*probe)(struct device *);\n\tvoid (*sync_state)(struct device *);\n\tvoid (*remove)(struct device *);\n\tvoid (*shutdown)(struct device *);\n\tint (*online)(struct device *);\n\tint (*offline)(struct device *);\n\tint (*suspend)(struct device *, pm_message_t);\n\tint (*resume)(struct device *);\n\tint (*num_vf)(struct device *);\n\tint (*dma_configure)(struct device *);\n\tconst struct dev_pm_ops *pm;\n\tconst struct iommu_ops *iommu_ops;\n\tstruct subsys_private *p;\n\tstruct lock_class_key lock_key;\n\tbool need_parent_lock;\n};\n\nenum probe_type {\n\tPROBE_DEFAULT_STRATEGY = 0,\n\tPROBE_PREFER_ASYNCHRONOUS = 1,\n\tPROBE_FORCE_SYNCHRONOUS = 2,\n};\n\nstruct of_device_id;\n\nstruct acpi_device_id;\n\nstruct driver_private;\n\nstruct device_driver {\n\tconst char *name;\n\tstruct bus_type *bus;\n\tstruct module *owner;\n\tconst char *mod_name;\n\tbool suppress_bind_attrs;\n\tenum probe_type probe_type;\n\tconst struct of_device_id *of_match_table;\n\tconst struct acpi_device_id *acpi_match_table;\n\tint (*probe)(struct device *);\n\tvoid (*sync_state)(struct device *);\n\tint (*remove)(struct device *);\n\tvoid (*shutdown)(struct device *);\n\tint (*suspend)(struct device *, pm_message_t);\n\tint (*resume)(struct device *);\n\tconst struct attribute_group **groups;\n\tconst struct attribute_group **dev_groups;\n\tconst struct dev_pm_ops *pm;\n\tvoid (*coredump)(struct device *);\n\tstruct driver_private *p;\n};\n\nenum iommu_cap {\n\tIOMMU_CAP_CACHE_COHERENCY = 0,\n\tIOMMU_CAP_INTR_REMAP = 1,\n\tIOMMU_CAP_NOEXEC = 2,\n};\n\ntypedef u64 dma_addr_t;\n\nenum iommu_dev_features {\n\tIOMMU_DEV_FEAT_AUX = 0,\n\tIOMMU_DEV_FEAT_SVA = 1,\n\tIOMMU_DEV_FEAT_IOPF = 2,\n};\n\nstruct iommu_domain;\n\nstruct iommu_iotlb_gather;\n\nstruct iommu_device;\n\nstruct iommu_resv_region;\n\nstruct of_phandle_args;\n\nstruct iommu_sva;\n\nstruct iommu_fault_event;\n\nstruct iommu_page_response;\n\nstruct iommu_cache_invalidate_info;\n\nstruct iommu_gpasid_bind_data;\n\nstruct iommu_ops {\n\tbool (*capable)(enum iommu_cap);\n\tstruct iommu_domain * (*domain_alloc)(unsigned int);\n\tvoid (*domain_free)(struct iommu_domain *);\n\tint (*attach_dev)(struct iommu_domain *, struct device *);\n\tvoid (*detach_dev)(struct iommu_domain *, struct device *);\n\tint (*map)(struct iommu_domain *, long unsigned int, phys_addr_t, size_t, int, gfp_t);\n\tint (*map_pages)(struct iommu_domain *, long unsigned int, phys_addr_t, size_t, size_t, int, gfp_t, size_t *);\n\tsize_t (*unmap)(struct iommu_domain *, long unsigned int, size_t, struct iommu_iotlb_gather *);\n\tsize_t (*unmap_pages)(struct iommu_domain *, long unsigned int, size_t, size_t, struct iommu_iotlb_gather *);\n\tvoid (*flush_iotlb_all)(struct iommu_domain *);\n\tvoid (*iotlb_sync_map)(struct iommu_domain *, long unsigned int, size_t);\n\tvoid (*iotlb_sync)(struct iommu_domain *, struct iommu_iotlb_gather *);\n\tphys_addr_t (*iova_to_phys)(struct iommu_domain *, dma_addr_t);\n\tstruct iommu_device * (*probe_device)(struct device *);\n\tvoid (*release_device)(struct device *);\n\tvoid (*probe_finalize)(struct device *);\n\tstruct iommu_group * (*device_group)(struct device *);\n\tint (*enable_nesting)(struct iommu_domain *);\n\tint (*set_pgtable_quirks)(struct iommu_domain *, long unsigned int);\n\tvoid (*get_resv_regions)(struct device *, struct list_head *);\n\tvoid (*put_resv_regions)(struct device *, struct list_head *);\n\tvoid (*apply_resv_region)(struct device *, struct iommu_domain *, struct iommu_resv_region *);\n\tint (*of_xlate)(struct device *, struct of_phandle_args *);\n\tbool (*is_attach_deferred)(struct iommu_domain *, struct device *);\n\tbool (*dev_has_feat)(struct device *, enum iommu_dev_features);\n\tbool (*dev_feat_enabled)(struct device *, enum iommu_dev_features);\n\tint (*dev_enable_feat)(struct device *, enum iommu_dev_features);\n\tint (*dev_disable_feat)(struct device *, enum iommu_dev_features);\n\tint (*aux_attach_dev)(struct iommu_domain *, struct device *);\n\tvoid (*aux_detach_dev)(struct iommu_domain *, struct device *);\n\tint (*aux_get_pasid)(struct iommu_domain *, struct device *);\n\tstruct iommu_sva * (*sva_bind)(struct device *, struct mm_struct *, void *);\n\tvoid (*sva_unbind)(struct iommu_sva *);\n\tu32 (*sva_get_pasid)(struct iommu_sva *);\n\tint (*page_response)(struct device *, struct iommu_fault_event *, struct iommu_page_response *);\n\tint (*cache_invalidate)(struct iommu_domain *, struct device *, struct iommu_cache_invalidate_info *);\n\tint (*sva_bind_gpasid)(struct iommu_domain *, struct device *, struct iommu_gpasid_bind_data *);\n\tint (*sva_unbind_gpasid)(struct device *, u32);\n\tint (*def_domain_type)(struct device *);\n\tlong unsigned int pgsize_bitmap;\n\tstruct module *owner;\n};\n\nstruct device_type {\n\tconst char *name;\n\tconst struct attribute_group **groups;\n\tint (*uevent)(struct device *, struct kobj_uevent_env *);\n\tchar * (*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *);\n\tvoid (*release)(struct device *);\n\tconst struct dev_pm_ops *pm;\n};\n\nstruct class {\n\tconst char *name;\n\tstruct module *owner;\n\tconst struct attribute_group **class_groups;\n\tconst struct attribute_group **dev_groups;\n\tstruct kobject *dev_kobj;\n\tint (*dev_uevent)(struct device *, struct kobj_uevent_env *);\n\tchar * (*devnode)(struct device *, umode_t *);\n\tvoid (*class_release)(struct class *);\n\tvoid (*dev_release)(struct device *);\n\tint (*shutdown_pre)(struct device *);\n\tconst struct kobj_ns_type_operations *ns_type;\n\tconst void * (*namespace)(struct device *);\n\tvoid (*get_ownership)(struct device *, kuid_t *, kgid_t *);\n\tconst struct dev_pm_ops *pm;\n\tstruct subsys_private *p;\n};\n\nstruct of_device_id {\n\tchar name[32];\n\tchar type[32];\n\tchar compatible[128];\n\tconst void *data;\n};\n\ntypedef long unsigned int kernel_ulong_t;\n\nstruct acpi_device_id {\n\t__u8 id[9];\n\tkernel_ulong_t driver_data;\n\t__u32 cls;\n\t__u32 cls_msk;\n};\n\nstruct device_dma_parameters {\n\tunsigned int max_segment_size;\n\tunsigned int min_align_mask;\n\tlong unsigned int segment_boundary_mask;\n};\n\nstruct sg_table;\n\nstruct scatterlist;\n\nstruct dma_map_ops {\n\tvoid * (*alloc)(struct device *, size_t, dma_addr_t *, gfp_t, long unsigned int);\n\tvoid (*free)(struct device *, size_t, void *, dma_addr_t, long unsigned int);\n\tstruct page * (*alloc_pages)(struct device *, size_t, dma_addr_t *, enum dma_data_direction, gfp_t);\n\tvoid (*free_pages)(struct device *, size_t, struct page *, dma_addr_t, enum dma_data_direction);\n\tstruct sg_table * (*alloc_noncontiguous)(struct device *, size_t, enum dma_data_direction, gfp_t, long unsigned int);\n\tvoid (*free_noncontiguous)(struct device *, size_t, struct sg_table *, enum dma_data_direction);\n\tint (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t, size_t, long unsigned int);\n\tint (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t, size_t, long unsigned int);\n\tdma_addr_t (*map_page)(struct device *, struct page *, long unsigned int, size_t, enum dma_data_direction, long unsigned int);\n\tvoid (*unmap_page)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);\n\tint (*map_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);\n\tvoid (*unmap_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);\n\tdma_addr_t (*map_resource)(struct device *, phys_addr_t, size_t, enum dma_data_direction, long unsigned int);\n\tvoid (*unmap_resource)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);\n\tvoid (*sync_single_for_cpu)(struct device *, dma_addr_t, size_t, enum dma_data_direction);\n\tvoid (*sync_single_for_device)(struct device *, dma_addr_t, size_t, enum dma_data_direction);\n\tvoid (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int, enum dma_data_direction);\n\tvoid (*sync_sg_for_device)(struct device *, struct scatterlist *, int, enum dma_data_direction);\n\tvoid (*cache_sync)(struct device *, void *, size_t, enum dma_data_direction);\n\tint (*dma_supported)(struct device *, u64);\n\tu64 (*get_required_mask)(struct device *);\n\tsize_t (*max_mapping_size)(struct device *);\n\tlong unsigned int (*get_merge_boundary)(struct device *);\n};\n\nstruct bus_dma_region {\n\tphys_addr_t cpu_start;\n\tdma_addr_t dma_start;\n\tu64 size;\n\tu64 offset;\n};\n\ntypedef u32 phandle;\n\nstruct fwnode_operations;\n\nstruct fwnode_handle {\n\tstruct fwnode_handle *secondary;\n\tconst struct fwnode_operations *ops;\n\tstruct device *dev;\n\tstruct list_head suppliers;\n\tstruct list_head consumers;\n\tu8 flags;\n};\n\nstruct property;\n\nstruct device_node {\n\tconst char *name;\n\tphandle phandle;\n\tconst char *full_name;\n\tstruct fwnode_handle fwnode;\n\tstruct property *properties;\n\tstruct property *deadprops;\n\tstruct device_node *parent;\n\tstruct device_node *child;\n\tstruct device_node *sibling;\n\tlong unsigned int _flags;\n\tvoid *data;\n};\n\nenum cpuhp_state {\n\tCPUHP_INVALID = 4294967295,\n\tCPUHP_OFFLINE = 0,\n\tCPUHP_CREATE_THREADS = 1,\n\tCPUHP_PERF_PREPARE = 2,\n\tCPUHP_PERF_X86_PREPARE = 3,\n\tCPUHP_PERF_X86_AMD_UNCORE_PREP = 4,\n\tCPUHP_PERF_POWER = 5,\n\tCPUHP_PERF_SUPERH = 6,\n\tCPUHP_X86_HPET_DEAD = 7,\n\tCPUHP_X86_APB_DEAD = 8,\n\tCPUHP_X86_MCE_DEAD = 9,\n\tCPUHP_VIRT_NET_DEAD = 10,\n\tCPUHP_SLUB_DEAD = 11,\n\tCPUHP_DEBUG_OBJ_DEAD = 12,\n\tCPUHP_MM_WRITEBACK_DEAD = 13,\n\tCPUHP_MM_DEMOTION_DEAD = 14,\n\tCPUHP_MM_VMSTAT_DEAD = 15,\n\tCPUHP_SOFTIRQ_DEAD = 16,\n\tCPUHP_NET_MVNETA_DEAD = 17,\n\tCPUHP_CPUIDLE_DEAD = 18,\n\tCPUHP_ARM64_FPSIMD_DEAD = 19,\n\tCPUHP_ARM_OMAP_WAKE_DEAD = 20,\n\tCPUHP_IRQ_POLL_DEAD = 21,\n\tCPUHP_BLOCK_SOFTIRQ_DEAD = 22,\n\tCPUHP_BIO_DEAD = 23,\n\tCPUHP_ACPI_CPUDRV_DEAD = 24,\n\tCPUHP_S390_PFAULT_DEAD = 25,\n\tCPUHP_BLK_MQ_DEAD = 26,\n\tCPUHP_FS_BUFF_DEAD = 27,\n\tCPUHP_PRINTK_DEAD = 28,\n\tCPUHP_MM_MEMCQ_DEAD = 29,\n\tCPUHP_XFS_DEAD = 30,\n\tCPUHP_PERCPU_CNT_DEAD = 31,\n\tCPUHP_RADIX_DEAD = 32,\n\tCPUHP_PAGE_ALLOC = 33,\n\tCPUHP_NET_DEV_DEAD = 34,\n\tCPUHP_PCI_XGENE_DEAD = 35,\n\tCPUHP_IOMMU_IOVA_DEAD = 36,\n\tCPUHP_LUSTRE_CFS_DEAD = 37,\n\tCPUHP_AP_ARM_CACHE_B15_RAC_DEAD = 38,\n\tCPUHP_PADATA_DEAD = 39,\n\tCPUHP_RANDOM_PREPARE = 40,\n\tCPUHP_WORKQUEUE_PREP = 41,\n\tCPUHP_POWER_NUMA_PREPARE = 42,\n\tCPUHP_HRTIMERS_PREPARE = 43,\n\tCPUHP_PROFILE_PREPARE = 44,\n\tCPUHP_X2APIC_PREPARE = 45,\n\tCPUHP_SMPCFD_PREPARE = 46,\n\tCPUHP_RELAY_PREPARE = 47,\n\tCPUHP_SLAB_PREPARE = 48,\n\tCPUHP_MD_RAID5_PREPARE = 49,\n\tCPUHP_RCUTREE_PREP = 50,\n\tCPUHP_CPUIDLE_COUPLED_PREPARE = 51,\n\tCPUHP_POWERPC_PMAC_PREPARE = 52,\n\tCPUHP_POWERPC_MMU_CTX_PREPARE = 53,\n\tCPUHP_XEN_PREPARE = 54,\n\tCPUHP_XEN_EVTCHN_PREPARE = 55,\n\tCPUHP_ARM_SHMOBILE_SCU_PREPARE = 56,\n\tCPUHP_SH_SH3X_PREPARE = 57,\n\tCPUHP_NET_FLOW_PREPARE = 58,\n\tCPUHP_TOPOLOGY_PREPARE = 59,\n\tCPUHP_NET_IUCV_PREPARE = 60,\n\tCPUHP_ARM_BL_PREPARE = 61,\n\tCPUHP_TRACE_RB_PREPARE = 62,\n\tCPUHP_MM_ZS_PREPARE = 63,\n\tCPUHP_MM_ZSWP_MEM_PREPARE = 64,\n\tCPUHP_MM_ZSWP_POOL_PREPARE = 65,\n\tCPUHP_KVM_PPC_BOOK3S_PREPARE = 66,\n\tCPUHP_ZCOMP_PREPARE = 67,\n\tCPUHP_TIMERS_PREPARE = 68,\n\tCPUHP_MIPS_SOC_PREPARE = 69,\n\tCPUHP_BP_PREPARE_DYN = 70,\n\tCPUHP_BP_PREPARE_DYN_END = 90,\n\tCPUHP_BRINGUP_CPU = 91,\n\tCPUHP_AP_IDLE_DEAD = 92,\n\tCPUHP_AP_OFFLINE = 93,\n\tCPUHP_AP_SCHED_STARTING = 94,\n\tCPUHP_AP_RCUTREE_DYING = 95,\n\tCPUHP_AP_CPU_PM_STARTING = 96,\n\tCPUHP_AP_IRQ_GIC_STARTING = 97,\n\tCPUHP_AP_IRQ_HIP04_STARTING = 98,\n\tCPUHP_AP_IRQ_APPLE_AIC_STARTING = 99,\n\tCPUHP_AP_IRQ_ARMADA_XP_STARTING = 100,\n\tCPUHP_AP_IRQ_BCM2836_STARTING = 101,\n\tCPUHP_AP_IRQ_MIPS_GIC_STARTING = 102,\n\tCPUHP_AP_IRQ_RISCV_STARTING = 103,\n\tCPUHP_AP_IRQ_SIFIVE_PLIC_STARTING = 104,\n\tCPUHP_AP_ARM_MVEBU_COHERENCY = 105,\n\tCPUHP_AP_MICROCODE_LOADER = 106,\n\tCPUHP_AP_PERF_X86_AMD_UNCORE_STARTING = 107,\n\tCPUHP_AP_PERF_X86_STARTING = 108,\n\tCPUHP_AP_PERF_X86_AMD_IBS_STARTING = 109,\n\tCPUHP_AP_PERF_X86_CQM_STARTING = 110,\n\tCPUHP_AP_PERF_X86_CSTATE_STARTING = 111,\n\tCPUHP_AP_PERF_XTENSA_STARTING = 112,\n\tCPUHP_AP_MIPS_OP_LOONGSON3_STARTING = 113,\n\tCPUHP_AP_ARM_SDEI_STARTING = 114,\n\tCPUHP_AP_ARM_VFP_STARTING = 115,\n\tCPUHP_AP_ARM64_DEBUG_MONITORS_STARTING = 116,\n\tCPUHP_AP_PERF_ARM_HW_BREAKPOINT_STARTING = 117,\n\tCPUHP_AP_PERF_ARM_ACPI_STARTING = 118,\n\tCPUHP_AP_PERF_ARM_STARTING = 119,\n\tCPUHP_AP_ARM_L2X0_STARTING = 120,\n\tCPUHP_AP_EXYNOS4_MCT_TIMER_STARTING = 121,\n\tCPUHP_AP_ARM_ARCH_TIMER_STARTING = 122,\n\tCPUHP_AP_ARM_GLOBAL_TIMER_STARTING = 123,\n\tCPUHP_AP_JCORE_TIMER_STARTING = 124,\n\tCPUHP_AP_ARM_TWD_STARTING = 125,\n\tCPUHP_AP_QCOM_TIMER_STARTING = 126,\n\tCPUHP_AP_TEGRA_TIMER_STARTING = 127,\n\tCPUHP_AP_ARMADA_TIMER_STARTING = 128,\n\tCPUHP_AP_MARCO_TIMER_STARTING = 129,\n\tCPUHP_AP_MIPS_GIC_TIMER_STARTING = 130,\n\tCPUHP_AP_ARC_TIMER_STARTING = 131,\n\tCPUHP_AP_RISCV_TIMER_STARTING = 132,\n\tCPUHP_AP_CLINT_TIMER_STARTING = 133,\n\tCPUHP_AP_CSKY_TIMER_STARTING = 134,\n\tCPUHP_AP_TI_GP_TIMER_STARTING = 135,\n\tCPUHP_AP_HYPERV_TIMER_STARTING = 136,\n\tCPUHP_AP_KVM_STARTING = 137,\n\tCPUHP_AP_KVM_ARM_VGIC_INIT_STARTING = 138,\n\tCPUHP_AP_KVM_ARM_VGIC_STARTING = 139,\n\tCPUHP_AP_KVM_ARM_TIMER_STARTING = 140,\n\tCPUHP_AP_DUMMY_TIMER_STARTING = 141,\n\tCPUHP_AP_ARM_XEN_STARTING = 142,\n\tCPUHP_AP_ARM_CORESIGHT_STARTING = 143,\n\tCPUHP_AP_ARM_CORESIGHT_CTI_STARTING = 144,\n\tCPUHP_AP_ARM64_ISNDEP_STARTING = 145,\n\tCPUHP_AP_SMPCFD_DYING = 146,\n\tCPUHP_AP_X86_TBOOT_DYING = 147,\n\tCPUHP_AP_ARM_CACHE_B15_RAC_DYING = 148,\n\tCPUHP_AP_ONLINE = 149,\n\tCPUHP_TEARDOWN_CPU = 150,\n\tCPUHP_AP_ONLINE_IDLE = 151,\n\tCPUHP_AP_SCHED_WAIT_EMPTY = 152,\n\tCPUHP_AP_SMPBOOT_THREADS = 153,\n\tCPUHP_AP_X86_VDSO_VMA_ONLINE = 154,\n\tCPUHP_AP_IRQ_AFFINITY_ONLINE = 155,\n\tCPUHP_AP_BLK_MQ_ONLINE = 156,\n\tCPUHP_AP_ARM_MVEBU_SYNC_CLOCKS = 157,\n\tCPUHP_AP_X86_INTEL_EPB_ONLINE = 158,\n\tCPUHP_AP_PERF_ONLINE = 159,\n\tCPUHP_AP_PERF_X86_ONLINE = 160,\n\tCPUHP_AP_PERF_X86_UNCORE_ONLINE = 161,\n\tCPUHP_AP_PERF_X86_AMD_UNCORE_ONLINE = 162,\n\tCPUHP_AP_PERF_X86_AMD_POWER_ONLINE = 163,\n\tCPUHP_AP_PERF_X86_RAPL_ONLINE = 164,\n\tCPUHP_AP_PERF_X86_CQM_ONLINE = 165,\n\tCPUHP_AP_PERF_X86_CSTATE_ONLINE = 166,\n\tCPUHP_AP_PERF_X86_IDXD_ONLINE = 167,\n\tCPUHP_AP_PERF_S390_CF_ONLINE = 168,\n\tCPUHP_AP_PERF_S390_SF_ONLINE = 169,\n\tCPUHP_AP_PERF_ARM_CCI_ONLINE = 170,\n\tCPUHP_AP_PERF_ARM_CCN_ONLINE = 171,\n\tCPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE = 172,\n\tCPUHP_AP_PERF_ARM_HISI_HHA_ONLINE = 173,\n\tCPUHP_AP_PERF_ARM_HISI_L3_ONLINE = 174,\n\tCPUHP_AP_PERF_ARM_HISI_PA_ONLINE = 175,\n\tCPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE = 176,\n\tCPUHP_AP_PERF_ARM_L2X0_ONLINE = 177,\n\tCPUHP_AP_PERF_ARM_QCOM_L2_ONLINE = 178,\n\tCPUHP_AP_PERF_ARM_QCOM_L3_ONLINE = 179,\n\tCPUHP_AP_PERF_ARM_APM_XGENE_ONLINE = 180,\n\tCPUHP_AP_PERF_ARM_CAVIUM_TX2_UNCORE_ONLINE = 181,\n\tCPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE = 182,\n\tCPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE = 183,\n\tCPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE = 184,\n\tCPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE = 185,\n\tCPUHP_AP_PERF_POWERPC_HV_24x7_ONLINE = 186,\n\tCPUHP_AP_PERF_POWERPC_HV_GPCI_ONLINE = 187,\n\tCPUHP_AP_PERF_CSKY_ONLINE = 188,\n\tCPUHP_AP_WATCHDOG_ONLINE = 189,\n\tCPUHP_AP_WORKQUEUE_ONLINE = 190,\n\tCPUHP_AP_RANDOM_ONLINE = 191,\n\tCPUHP_AP_RCUTREE_ONLINE = 192,\n\tCPUHP_AP_BASE_CACHEINFO_ONLINE = 193,\n\tCPUHP_AP_ONLINE_DYN = 194,\n\tCPUHP_AP_ONLINE_DYN_END = 224,\n\tCPUHP_AP_MM_DEMOTION_ONLINE = 225,\n\tCPUHP_AP_X86_HPET_ONLINE = 226,\n\tCPUHP_AP_X86_KVM_CLK_ONLINE = 227,\n\tCPUHP_AP_DTPM_CPU_ONLINE = 228,\n\tCPUHP_AP_ACTIVE = 229,\n\tCPUHP_ONLINE = 230,\n};\n\nstruct ring_buffer_event {\n\tu32 type_len: 5;\n\tu32 time_delta: 27;\n\tu32 array[0];\n};\n\nstruct seq_buf {\n\tchar *buffer;\n\tsize_t size;\n\tsize_t len;\n\tloff_t readpos;\n};\n\nstruct trace_seq {\n\tchar buffer[4096];\n\tstruct seq_buf seq;\n\tint full;\n};\n\nenum perf_sw_ids {\n\tPERF_COUNT_SW_CPU_CLOCK = 0,\n\tPERF_COUNT_SW_TASK_CLOCK = 1,\n\tPERF_COUNT_SW_PAGE_FAULTS = 2,\n\tPERF_COUNT_SW_CONTEXT_SWITCHES = 3,\n\tPERF_COUNT_SW_CPU_MIGRATIONS = 4,\n\tPERF_COUNT_SW_PAGE_FAULTS_MIN = 5,\n\tPERF_COUNT_SW_PAGE_FAULTS_MAJ = 6,\n\tPERF_COUNT_SW_ALIGNMENT_FAULTS = 7,\n\tPERF_COUNT_SW_EMULATION_FAULTS = 8,\n\tPERF_COUNT_SW_DUMMY = 9,\n\tPERF_COUNT_SW_BPF_OUTPUT = 10,\n\tPERF_COUNT_SW_CGROUP_SWITCHES = 11,\n\tPERF_COUNT_SW_MAX = 12,\n};\n\nunion perf_mem_data_src {\n\t__u64 val;\n\tstruct {\n\t\t__u64 mem_op: 5;\n\t\t__u64 mem_lvl: 14;\n\t\t__u64 mem_snoop: 5;\n\t\t__u64 mem_lock: 2;\n\t\t__u64 mem_dtlb: 7;\n\t\t__u64 mem_lvl_num: 4;\n\t\t__u64 mem_remote: 1;\n\t\t__u64 mem_snoopx: 2;\n\t\t__u64 mem_blk: 3;\n\t\t__u64 mem_rsvd: 21;\n\t};\n};\n\nstruct perf_branch_entry {\n\t__u64 from;\n\t__u64 to;\n\t__u64 mispred: 1;\n\t__u64 predicted: 1;\n\t__u64 in_tx: 1;\n\t__u64 abort: 1;\n\t__u64 cycles: 16;\n\t__u64 type: 4;\n\t__u64 reserved: 40;\n};\n\nunion perf_sample_weight {\n\t__u64 full;\n\tstruct {\n\t\t__u32 var1_dw;\n\t\t__u16 var2_w;\n\t\t__u16 var3_w;\n\t};\n};\n\nstruct new_utsname {\n\tchar sysname[65];\n\tchar nodename[65];\n\tchar release[65];\n\tchar version[65];\n\tchar machine[65];\n\tchar domainname[65];\n};\n\nstruct uts_namespace {\n\tstruct new_utsname name;\n\tstruct user_namespace *user_ns;\n\tstruct ucounts *ucounts;\n\tstruct ns_common ns;\n};\n\nstruct prot_inuse;\n\nstruct netns_core {\n\tstruct ctl_table_header *sysctl_hdr;\n\tint sysctl_somaxconn;\n\tint *sock_inuse;\n\tstruct prot_inuse *prot_inuse;\n};\n\nstruct ipstats_mib;\n\nstruct tcp_mib;\n\nstruct linux_mib;\n\nstruct udp_mib;\n\nstruct linux_xfrm_mib;\n\nstruct linux_tls_mib;\n\nstruct mptcp_mib;\n\nstruct icmp_mib;\n\nstruct icmpmsg_mib;\n\nstruct icmpv6_mib;\n\nstruct icmpv6msg_mib;\n\nstruct proc_dir_entry;\n\nstruct netns_mib {\n\tstruct ipstats_mib *ip_statistics;\n\tstruct ipstats_mib *ipv6_statistics;\n\tstruct tcp_mib *tcp_statistics;\n\tstruct linux_mib *net_statistics;\n\tstruct udp_mib *udp_statistics;\n\tstruct udp_mib *udp_stats_in6;\n\tstruct linux_xfrm_mib *xfrm_statistics;\n\tstruct linux_tls_mib *tls_statistics;\n\tstruct mptcp_mib *mptcp_statistics;\n\tstruct udp_mib *udplite_statistics;\n\tstruct udp_mib *udplite_stats_in6;\n\tstruct icmp_mib *icmp_statistics;\n\tstruct icmpmsg_mib *icmpmsg_statistics;\n\tstruct icmpv6_mib *icmpv6_statistics;\n\tstruct icmpv6msg_mib *icmpv6msg_statistics;\n\tstruct proc_dir_entry *proc_net_devsnmp6;\n};\n\nstruct netns_packet {\n\tstruct mutex sklist_lock;\n\tstruct hlist_head sklist;\n};\n\nstruct netns_unix {\n\tint sysctl_max_dgram_qlen;\n\tstruct ctl_table_header *ctl;\n};\n\nstruct netns_nexthop {\n\tstruct rb_root rb_root;\n\tstruct hlist_head *devhash;\n\tunsigned int seq;\n\tu32 last_id_allocated;\n\tstruct blocking_notifier_head notifier_chain;\n};\n\nstruct inet_hashinfo;\n\nstruct inet_timewait_death_row {\n\tatomic_t tw_count;\n\tchar tw_pad[60];\n\tstruct inet_hashinfo *hashinfo;\n\tint sysctl_max_tw_buckets;\n};\n\nstruct local_ports {\n\tseqlock_t lock;\n\tint range[2];\n\tbool warned;\n};\n\nstruct ping_group_range {\n\tseqlock_t lock;\n\tkgid_t range[2];\n};\n\ntypedef struct {\n\tu64 key[2];\n} siphash_key_t;\n\nstruct ipv4_devconf;\n\nstruct ip_ra_chain;\n\nstruct fib_rules_ops;\n\nstruct fib_table;\n\nstruct inet_peer_base;\n\nstruct fqdir;\n\nstruct tcp_congestion_ops;\n\nstruct tcp_fastopen_context;\n\nstruct fib_notifier_ops;\n\nstruct netns_ipv4 {\n\tstruct inet_timewait_death_row tcp_death_row;\n\tstruct ctl_table_header *forw_hdr;\n\tstruct ctl_table_header *frags_hdr;\n\tstruct ctl_table_header *ipv4_hdr;\n\tstruct ctl_table_header *route_hdr;\n\tstruct ctl_table_header *xfrm4_hdr;\n\tstruct ipv4_devconf *devconf_all;\n\tstruct ipv4_devconf *devconf_dflt;\n\tstruct ip_ra_chain *ra_chain;\n\tstruct mutex ra_mutex;\n\tstruct fib_rules_ops *rules_ops;\n\tstruct fib_table *fib_main;\n\tstruct fib_table *fib_default;\n\tunsigned int fib_rules_require_fldissect;\n\tbool fib_has_custom_rules;\n\tbool fib_has_custom_local_routes;\n\tbool fib_offload_disabled;\n\tatomic_t fib_num_tclassid_users;\n\tstruct hlist_head *fib_table_hash;\n\tstruct sock *fibnl;\n\tstruct sock **icmp_sk;\n\tstruct sock *mc_autojoin_sk;\n\tstruct inet_peer_base *peers;\n\tstruct fqdir *fqdir;\n\tu8 sysctl_icmp_echo_ignore_all;\n\tu8 sysctl_icmp_echo_enable_probe;\n\tu8 sysctl_icmp_echo_ignore_broadcasts;\n\tu8 sysctl_icmp_ignore_bogus_error_responses;\n\tu8 sysctl_icmp_errors_use_inbound_ifaddr;\n\tint sysctl_icmp_ratelimit;\n\tint sysctl_icmp_ratemask;\n\tstruct local_ports ip_local_ports;\n\tu8 sysctl_tcp_ecn;\n\tu8 sysctl_tcp_ecn_fallback;\n\tu8 sysctl_ip_default_ttl;\n\tu8 sysctl_ip_no_pmtu_disc;\n\tu8 sysctl_ip_fwd_use_pmtu;\n\tu8 sysctl_ip_fwd_update_priority;\n\tu8 sysctl_ip_nonlocal_bind;\n\tu8 sysctl_ip_autobind_reuse;\n\tu8 sysctl_ip_dynaddr;\n\tu8 sysctl_ip_early_demux;\n\tu8 sysctl_raw_l3mdev_accept;\n\tu8 sysctl_tcp_early_demux;\n\tu8 sysctl_udp_early_demux;\n\tu8 sysctl_nexthop_compat_mode;\n\tu8 sysctl_fwmark_reflect;\n\tu8 sysctl_tcp_fwmark_accept;\n\tu8 sysctl_tcp_l3mdev_accept;\n\tu8 sysctl_tcp_mtu_probing;\n\tint sysctl_tcp_mtu_probe_floor;\n\tint sysctl_tcp_base_mss;\n\tint sysctl_tcp_min_snd_mss;\n\tint sysctl_tcp_probe_threshold;\n\tu32 sysctl_tcp_probe_interval;\n\tint sysctl_tcp_keepalive_time;\n\tint sysctl_tcp_keepalive_intvl;\n\tu8 sysctl_tcp_keepalive_probes;\n\tu8 sysctl_tcp_syn_retries;\n\tu8 sysctl_tcp_synack_retries;\n\tu8 sysctl_tcp_syncookies;\n\tu8 sysctl_tcp_migrate_req;\n\tint sysctl_tcp_reordering;\n\tu8 sysctl_tcp_retries1;\n\tu8 sysctl_tcp_retries2;\n\tu8 sysctl_tcp_orphan_retries;\n\tu8 sysctl_tcp_tw_reuse;\n\tint sysctl_tcp_fin_timeout;\n\tunsigned int sysctl_tcp_notsent_lowat;\n\tu8 sysctl_tcp_sack;\n\tu8 sysctl_tcp_window_scaling;\n\tu8 sysctl_tcp_timestamps;\n\tu8 sysctl_tcp_early_retrans;\n\tu8 sysctl_tcp_recovery;\n\tu8 sysctl_tcp_thin_linear_timeouts;\n\tu8 sysctl_tcp_slow_start_after_idle;\n\tu8 sysctl_tcp_retrans_collapse;\n\tu8 sysctl_tcp_stdurg;\n\tu8 sysctl_tcp_rfc1337;\n\tu8 sysctl_tcp_abort_on_overflow;\n\tu8 sysctl_tcp_fack;\n\tint sysctl_tcp_max_reordering;\n\tint sysctl_tcp_adv_win_scale;\n\tu8 sysctl_tcp_dsack;\n\tu8 sysctl_tcp_app_win;\n\tu8 sysctl_tcp_frto;\n\tu8 sysctl_tcp_nometrics_save;\n\tu8 sysctl_tcp_no_ssthresh_metrics_save;\n\tu8 sysctl_tcp_moderate_rcvbuf;\n\tu8 sysctl_tcp_tso_win_divisor;\n\tu8 sysctl_tcp_workaround_signed_windows;\n\tint sysctl_tcp_limit_output_bytes;\n\tint sysctl_tcp_challenge_ack_limit;\n\tint sysctl_tcp_min_rtt_wlen;\n\tu8 sysctl_tcp_min_tso_segs;\n\tu8 sysctl_tcp_autocorking;\n\tu8 sysctl_tcp_reflect_tos;\n\tu8 sysctl_tcp_comp_sack_nr;\n\tint sysctl_tcp_invalid_ratelimit;\n\tint sysctl_tcp_pacing_ss_ratio;\n\tint sysctl_tcp_pacing_ca_ratio;\n\tint sysctl_tcp_wmem[3];\n\tint sysctl_tcp_rmem[3];\n\tlong unsigned int sysctl_tcp_comp_sack_delay_ns;\n\tlong unsigned int sysctl_tcp_comp_sack_slack_ns;\n\tint sysctl_max_syn_backlog;\n\tint sysctl_tcp_fastopen;\n\tconst struct tcp_congestion_ops *tcp_congestion_control;\n\tstruct tcp_fastopen_context *tcp_fastopen_ctx;\n\tunsigned int sysctl_tcp_fastopen_blackhole_timeout;\n\tatomic_t tfo_active_disable_times;\n\tlong unsigned int tfo_active_disable_stamp;\n\tint sysctl_udp_wmem_min;\n\tint sysctl_udp_rmem_min;\n\tu8 sysctl_fib_notify_on_flag_change;\n\tu8 sysctl_udp_l3mdev_accept;\n\tu8 sysctl_igmp_llm_reports;\n\tint sysctl_igmp_max_memberships;\n\tint sysctl_igmp_max_msf;\n\tint sysctl_igmp_qrv;\n\tstruct ping_group_range ping_group_range;\n\tatomic_t dev_addr_genid;\n\tlong unsigned int *sysctl_local_reserved_ports;\n\tint sysctl_ip_prot_sock;\n\tstruct list_head mr_tables;\n\tstruct fib_rules_ops *mr_rules_ops;\n\tu32 sysctl_fib_multipath_hash_fields;\n\tu8 sysctl_fib_multipath_use_neigh;\n\tu8 sysctl_fib_multipath_hash_policy;\n\tstruct fib_notifier_ops *notifier_ops;\n\tunsigned int fib_seq;\n\tstruct fib_notifier_ops *ipmr_notifier_ops;\n\tunsigned int ipmr_seq;\n\tatomic_t rt_genid;\n\tsiphash_key_t ip_id_key;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct dst_entry;\n\nstruct net_device;\n\nstruct sk_buff;\n\nstruct neighbour;\n\nstruct dst_ops {\n\tshort unsigned int family;\n\tunsigned int gc_thresh;\n\tint (*gc)(struct dst_ops *);\n\tstruct dst_entry * (*check)(struct dst_entry *, __u32);\n\tunsigned int (*default_advmss)(const struct dst_entry *);\n\tunsigned int (*mtu)(const struct dst_entry *);\n\tu32 * (*cow_metrics)(struct dst_entry *, long unsigned int);\n\tvoid (*destroy)(struct dst_entry *);\n\tvoid (*ifdown)(struct dst_entry *, struct net_device *, int);\n\tstruct dst_entry * (*negative_advice)(struct dst_entry *);\n\tvoid (*link_failure)(struct sk_buff *);\n\tvoid (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32, bool);\n\tvoid (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *);\n\tint (*local_out)(struct net *, struct sock *, struct sk_buff *);\n\tstruct neighbour * (*neigh_lookup)(const struct dst_entry *, struct sk_buff *, const void *);\n\tvoid (*confirm_neigh)(const struct dst_entry *, const void *);\n\tstruct kmem_cache *kmem_cachep;\n\tstruct percpu_counter pcpuc_entries;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct netns_sysctl_ipv6 {\n\tstruct ctl_table_header *hdr;\n\tstruct ctl_table_header *route_hdr;\n\tstruct ctl_table_header *icmp_hdr;\n\tstruct ctl_table_header *frags_hdr;\n\tstruct ctl_table_header *xfrm6_hdr;\n\tint flush_delay;\n\tint ip6_rt_max_size;\n\tint ip6_rt_gc_min_interval;\n\tint ip6_rt_gc_timeout;\n\tint ip6_rt_gc_interval;\n\tint ip6_rt_gc_elasticity;\n\tint ip6_rt_mtu_expires;\n\tint ip6_rt_min_advmss;\n\tu32 multipath_hash_fields;\n\tu8 multipath_hash_policy;\n\tu8 bindv6only;\n\tu8 flowlabel_consistency;\n\tu8 auto_flowlabels;\n\tint icmpv6_time;\n\tu8 icmpv6_echo_ignore_all;\n\tu8 icmpv6_echo_ignore_multicast;\n\tu8 icmpv6_echo_ignore_anycast;\n\tlong unsigned int icmpv6_ratemask[4];\n\tlong unsigned int *icmpv6_ratemask_ptr;\n\tu8 anycast_src_echo_reply;\n\tu8 ip_nonlocal_bind;\n\tu8 fwmark_reflect;\n\tu8 flowlabel_state_ranges;\n\tint idgen_retries;\n\tint idgen_delay;\n\tint flowlabel_reflect;\n\tint max_dst_opts_cnt;\n\tint max_hbh_opts_cnt;\n\tint max_dst_opts_len;\n\tint max_hbh_opts_len;\n\tint seg6_flowlabel;\n\tu32 ioam6_id;\n\tu64 ioam6_id_wide;\n\tbool skip_notify_on_dev_down;\n\tu8 fib_notify_on_flag_change;\n};\n\nstruct ipv6_devconf;\n\nstruct fib6_info;\n\nstruct rt6_info;\n\nstruct rt6_statistics;\n\nstruct fib6_table;\n\nstruct seg6_pernet_data;\n\nstruct ioam6_pernet_data;\n\nstruct netns_ipv6 {\n\tstruct dst_ops ip6_dst_ops;\n\tstruct netns_sysctl_ipv6 sysctl;\n\tstruct ipv6_devconf *devconf_all;\n\tstruct ipv6_devconf *devconf_dflt;\n\tstruct inet_peer_base *peers;\n\tstruct fqdir *fqdir;\n\tstruct fib6_info *fib6_null_entry;\n\tstruct rt6_info *ip6_null_entry;\n\tstruct rt6_statistics *rt6_stats;\n\tstruct timer_list ip6_fib_timer;\n\tstruct hlist_head *fib_table_hash;\n\tstruct fib6_table *fib6_main_tbl;\n\tstruct list_head fib6_walkers;\n\trwlock_t fib6_walker_lock;\n\tspinlock_t fib6_gc_lock;\n\tatomic_t ip6_rt_gc_expire;\n\tlong unsigned int ip6_rt_last_gc;\n\tunsigned char flowlabel_has_excl;\n\tbool fib6_has_custom_rules;\n\tunsigned int fib6_rules_require_fldissect;\n\tunsigned int fib6_routes_require_src;\n\tstruct rt6_info *ip6_prohibit_entry;\n\tstruct rt6_info *ip6_blk_hole_entry;\n\tstruct fib6_table *fib6_local_tbl;\n\tstruct fib_rules_ops *fib6_rules_ops;\n\tstruct sock **icmp_sk;\n\tstruct sock *ndisc_sk;\n\tstruct sock *tcp_sk;\n\tstruct sock *igmp_sk;\n\tstruct sock *mc_autojoin_sk;\n\tstruct list_head mr6_tables;\n\tstruct fib_rules_ops *mr6_rules_ops;\n\tatomic_t dev_addr_genid;\n\tatomic_t fib6_sernum;\n\tstruct seg6_pernet_data *seg6_data;\n\tstruct fib_notifier_ops *notifier_ops;\n\tstruct fib_notifier_ops *ip6mr_notifier_ops;\n\tunsigned int ipmr_seq;\n\tstruct {\n\t\tstruct hlist_head head;\n\t\tspinlock_t lock;\n\t\tu32 seq;\n\t} ip6addrlbl_table;\n\tstruct ioam6_pernet_data *ioam6_data;\n};\n\nstruct netns_sysctl_lowpan {\n\tstruct ctl_table_header *frags_hdr;\n};\n\nstruct netns_ieee802154_lowpan {\n\tstruct netns_sysctl_lowpan sysctl;\n\tstruct fqdir *fqdir;\n};\n\nstruct sctp_mib;\n\nstruct netns_sctp {\n\tstruct sctp_mib *sctp_statistics;\n\tstruct proc_dir_entry *proc_net_sctp;\n\tstruct ctl_table_header *sysctl_header;\n\tstruct sock *ctl_sock;\n\tstruct sock *udp4_sock;\n\tstruct sock *udp6_sock;\n\tint udp_port;\n\tint encap_port;\n\tstruct list_head local_addr_list;\n\tstruct list_head addr_waitq;\n\tstruct timer_list addr_wq_timer;\n\tstruct list_head auto_asconf_splist;\n\tspinlock_t addr_wq_lock;\n\tspinlock_t local_addr_lock;\n\tunsigned int rto_initial;\n\tunsigned int rto_min;\n\tunsigned int rto_max;\n\tint rto_alpha;\n\tint rto_beta;\n\tint max_burst;\n\tint cookie_preserve_enable;\n\tchar *sctp_hmac_alg;\n\tunsigned int valid_cookie_life;\n\tunsigned int sack_timeout;\n\tunsigned int hb_interval;\n\tunsigned int probe_interval;\n\tint max_retrans_association;\n\tint max_retrans_path;\n\tint max_retrans_init;\n\tint pf_retrans;\n\tint ps_retrans;\n\tint pf_enable;\n\tint pf_expose;\n\tint sndbuf_policy;\n\tint rcvbuf_policy;\n\tint default_auto_asconf;\n\tint addip_enable;\n\tint addip_noauth;\n\tint prsctp_enable;\n\tint reconf_enable;\n\tint auth_enable;\n\tint intl_enable;\n\tint ecn_enable;\n\tint scope_policy;\n\tint rwnd_upd_shift;\n\tlong unsigned int max_autoclose;\n};\n\nstruct nf_logger;\n\nstruct nf_hook_entries;\n\nstruct netns_nf {\n\tstruct proc_dir_entry *proc_netfilter;\n\tconst struct nf_logger *nf_loggers[13];\n\tstruct ctl_table_header *nf_log_dir_header;\n\tstruct nf_hook_entries *hooks_ipv4[5];\n\tstruct nf_hook_entries *hooks_ipv6[5];\n\tstruct nf_hook_entries *hooks_arp[3];\n\tstruct nf_hook_entries *hooks_bridge[5];\n\tstruct nf_hook_entries *hooks_decnet[7];\n\tunsigned int defrag_ipv4_users;\n\tunsigned int defrag_ipv6_users;\n};\n\nstruct nf_generic_net {\n\tunsigned int timeout;\n};\n\nstruct nf_tcp_net {\n\tunsigned int timeouts[14];\n\tu8 tcp_loose;\n\tu8 tcp_be_liberal;\n\tu8 tcp_max_retrans;\n\tu8 tcp_ignore_invalid_rst;\n\tunsigned int offload_timeout;\n};\n\nstruct nf_udp_net {\n\tunsigned int timeouts[2];\n\tunsigned int offload_timeout;\n};\n\nstruct nf_icmp_net {\n\tunsigned int timeout;\n};\n\nstruct nf_dccp_net {\n\tu8 dccp_loose;\n\tunsigned int dccp_timeout[10];\n};\n\nstruct nf_sctp_net {\n\tunsigned int timeouts[10];\n};\n\nstruct nf_gre_net {\n\tstruct list_head keymap_list;\n\tunsigned int timeouts[2];\n};\n\nstruct nf_ip_net {\n\tstruct nf_generic_net generic;\n\tstruct nf_tcp_net tcp;\n\tstruct nf_udp_net udp;\n\tstruct nf_icmp_net icmp;\n\tstruct nf_icmp_net icmpv6;\n\tstruct nf_dccp_net dccp;\n\tstruct nf_sctp_net sctp;\n\tstruct nf_gre_net gre;\n};\n\nstruct ct_pcpu;\n\nstruct ip_conntrack_stat;\n\nstruct nf_ct_event_notifier;\n\nstruct netns_ct {\n\tbool ecache_dwork_pending;\n\tu8 sysctl_log_invalid;\n\tu8 sysctl_events;\n\tu8 sysctl_acct;\n\tu8 sysctl_auto_assign_helper;\n\tu8 sysctl_tstamp;\n\tu8 sysctl_checksum;\n\tstruct ct_pcpu *pcpu_lists;\n\tstruct ip_conntrack_stat *stat;\n\tstruct nf_ct_event_notifier *nf_conntrack_event_cb;\n\tstruct nf_ip_net nf_ct_proto;\n\tunsigned int labels_used;\n};\n\nstruct netns_nftables {\n\tu8 gencursor;\n};\n\nstruct sk_buff_head {\n\tstruct sk_buff *next;\n\tstruct sk_buff *prev;\n\t__u32 qlen;\n\tspinlock_t lock;\n};\n\nstruct netns_bpf {\n\tstruct bpf_prog_array *run_array[2];\n\tstruct bpf_prog *progs[2];\n\tstruct list_head links[2];\n};\n\nstruct xfrm_policy_hash {\n\tstruct hlist_head *table;\n\tunsigned int hmask;\n\tu8 dbits4;\n\tu8 sbits4;\n\tu8 dbits6;\n\tu8 sbits6;\n};\n\nstruct xfrm_policy_hthresh {\n\tstruct work_struct work;\n\tseqlock_t lock;\n\tu8 lbits4;\n\tu8 rbits4;\n\tu8 lbits6;\n\tu8 rbits6;\n};\n\nstruct netns_xfrm {\n\tstruct list_head state_all;\n\tstruct hlist_head *state_bydst;\n\tstruct hlist_head *state_bysrc;\n\tstruct hlist_head *state_byspi;\n\tstruct hlist_head *state_byseq;\n\tunsigned int state_hmask;\n\tunsigned int state_num;\n\tstruct work_struct state_hash_work;\n\tstruct list_head policy_all;\n\tstruct hlist_head *policy_byidx;\n\tunsigned int policy_idx_hmask;\n\tstruct hlist_head policy_inexact[3];\n\tstruct xfrm_policy_hash policy_bydst[3];\n\tunsigned int policy_count[6];\n\tstruct work_struct policy_hash_work;\n\tstruct xfrm_policy_hthresh policy_hthresh;\n\tstruct list_head inexact_bins;\n\tstruct sock *nlsk;\n\tstruct sock *nlsk_stash;\n\tu32 sysctl_aevent_etime;\n\tu32 sysctl_aevent_rseqth;\n\tint sysctl_larval_drop;\n\tu32 sysctl_acq_expires;\n\tu8 policy_default[3];\n\tstruct ctl_table_header *sysctl_hdr;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct dst_ops xfrm4_dst_ops;\n\tstruct dst_ops xfrm6_dst_ops;\n\tspinlock_t xfrm_state_lock;\n\tseqcount_spinlock_t xfrm_state_hash_generation;\n\tseqcount_spinlock_t xfrm_policy_hash_generation;\n\tspinlock_t xfrm_policy_lock;\n\tstruct mutex xfrm_cfg_mutex;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct netns_ipvs;\n\nstruct mpls_route;\n\nstruct netns_mpls {\n\tint ip_ttl_propagate;\n\tint default_ttl;\n\tsize_t platform_labels;\n\tstruct mpls_route **platform_label;\n\tstruct ctl_table_header *ctl;\n};\n\nstruct can_dev_rcv_lists;\n\nstruct can_pkg_stats;\n\nstruct can_rcv_lists_stats;\n\nstruct netns_can {\n\tstruct proc_dir_entry *proc_dir;\n\tstruct proc_dir_entry *pde_stats;\n\tstruct proc_dir_entry *pde_reset_stats;\n\tstruct proc_dir_entry *pde_rcvlist_all;\n\tstruct proc_dir_entry *pde_rcvlist_fil;\n\tstruct proc_dir_entry *pde_rcvlist_inv;\n\tstruct proc_dir_entry *pde_rcvlist_sff;\n\tstruct proc_dir_entry *pde_rcvlist_eff;\n\tstruct proc_dir_entry *pde_rcvlist_err;\n\tstruct proc_dir_entry *bcmproc_dir;\n\tstruct can_dev_rcv_lists *rx_alldev_list;\n\tspinlock_t rcvlists_lock;\n\tstruct timer_list stattimer;\n\tstruct can_pkg_stats *pkg_stats;\n\tstruct can_rcv_lists_stats *rcv_lists_stats;\n\tstruct hlist_head cgw_list;\n};\n\nstruct netns_xdp {\n\tstruct mutex lock;\n\tstruct hlist_head list;\n};\n\nstruct netns_mctp {\n\tstruct list_head routes;\n\tstruct mutex bind_lock;\n\tstruct hlist_head binds;\n\tspinlock_t keys_lock;\n\tstruct hlist_head keys;\n\tunsigned int default_net;\n\tstruct mutex neigh_lock;\n\tstruct list_head neighbours;\n};\n\nstruct smc_stats;\n\nstruct smc_stats_rsn;\n\nstruct netns_smc {\n\tstruct smc_stats *smc_stats;\n\tstruct mutex mutex_fback_rsn;\n\tstruct smc_stats_rsn *fback_rsn;\n};\n\nstruct uevent_sock;\n\nstruct net_generic;\n\nstruct net {\n\trefcount_t passive;\n\tspinlock_t rules_mod_lock;\n\tunsigned int dev_unreg_count;\n\tunsigned int dev_base_seq;\n\tint ifindex;\n\tspinlock_t nsid_lock;\n\tatomic_t fnhe_genid;\n\tstruct list_head list;\n\tstruct list_head exit_list;\n\tstruct llist_node cleanup_list;\n\tstruct key_tag *key_domain;\n\tstruct user_namespace *user_ns;\n\tstruct ucounts *ucounts;\n\tstruct idr netns_ids;\n\tstruct ns_common ns;\n\tstruct list_head dev_base_head;\n\tstruct proc_dir_entry *proc_net;\n\tstruct proc_dir_entry *proc_net_stat;\n\tstruct ctl_table_set sysctls;\n\tstruct sock *rtnl;\n\tstruct sock *genl_sock;\n\tstruct uevent_sock *uevent_sock;\n\tstruct hlist_head *dev_name_head;\n\tstruct hlist_head *dev_index_head;\n\tstruct raw_notifier_head netdev_chain;\n\tu32 hash_mix;\n\tstruct net_device *loopback_dev;\n\tstruct list_head rules_ops;\n\tstruct netns_core core;\n\tstruct netns_mib mib;\n\tstruct netns_packet packet;\n\tstruct netns_unix unx;\n\tstruct netns_nexthop nexthop;\n\tstruct netns_ipv4 ipv4;\n\tstruct netns_ipv6 ipv6;\n\tstruct netns_ieee802154_lowpan ieee802154_lowpan;\n\tstruct netns_sctp sctp;\n\tstruct netns_nf nf;\n\tstruct netns_ct ct;\n\tstruct netns_nftables nft;\n\tstruct sk_buff_head wext_nlevents;\n\tstruct net_generic *gen;\n\tstruct netns_bpf bpf;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct netns_xfrm xfrm;\n\tu64 net_cookie;\n\tstruct netns_ipvs *ipvs;\n\tstruct netns_mpls mpls;\n\tstruct netns_can can;\n\tstruct netns_xdp xdp;\n\tstruct netns_mctp mctp;\n\tstruct sock *crypto_nlsk;\n\tstruct sock *diag_nlsk;\n\tstruct netns_smc smc;\n\tlong: 64;\n};\n\nstruct cgroup_namespace {\n\tstruct ns_common ns;\n\tstruct user_namespace *user_ns;\n\tstruct ucounts *ucounts;\n\tstruct css_set *root_cset;\n};\n\nstruct nsset {\n\tunsigned int flags;\n\tstruct nsproxy *nsproxy;\n\tstruct fs_struct *fs;\n\tconst struct cred *cred;\n};\n\nstruct proc_ns_operations {\n\tconst char *name;\n\tconst char *real_ns_name;\n\tint type;\n\tstruct ns_common * (*get)(struct task_struct *);\n\tvoid (*put)(struct ns_common *);\n\tint (*install)(struct nsset *, struct ns_common *);\n\tstruct user_namespace * (*owner)(struct ns_common *);\n\tstruct ns_common * (*get_parent)(struct ns_common *);\n};\n\nstruct perf_cpu_context;\n\nstruct perf_output_handle;\n\nstruct pmu {\n\tstruct list_head entry;\n\tstruct module *module;\n\tstruct device *dev;\n\tconst struct attribute_group **attr_groups;\n\tconst struct attribute_group **attr_update;\n\tconst char *name;\n\tint type;\n\tint capabilities;\n\tint *pmu_disable_count;\n\tstruct perf_cpu_context *pmu_cpu_context;\n\tatomic_t exclusive_cnt;\n\tint task_ctx_nr;\n\tint hrtimer_interval_ms;\n\tunsigned int nr_addr_filters;\n\tvoid (*pmu_enable)(struct pmu *);\n\tvoid (*pmu_disable)(struct pmu *);\n\tint (*event_init)(struct perf_event *);\n\tvoid (*event_mapped)(struct perf_event *, struct mm_struct *);\n\tvoid (*event_unmapped)(struct perf_event *, struct mm_struct *);\n\tint (*add)(struct perf_event *, int);\n\tvoid (*del)(struct perf_event *, int);\n\tvoid (*start)(struct perf_event *, int);\n\tvoid (*stop)(struct perf_event *, int);\n\tvoid (*read)(struct perf_event *);\n\tvoid (*start_txn)(struct pmu *, unsigned int);\n\tint (*commit_txn)(struct pmu *);\n\tvoid (*cancel_txn)(struct pmu *);\n\tint (*event_idx)(struct perf_event *);\n\tvoid (*sched_task)(struct perf_event_context *, bool);\n\tstruct kmem_cache *task_ctx_cache;\n\tvoid (*swap_task_ctx)(struct perf_event_context *, struct perf_event_context *);\n\tvoid * (*setup_aux)(struct perf_event *, void **, int, bool);\n\tvoid (*free_aux)(void *);\n\tlong int (*snapshot_aux)(struct perf_event *, struct perf_output_handle *, long unsigned int);\n\tint (*addr_filters_validate)(struct list_head *);\n\tvoid (*addr_filters_sync)(struct perf_event *);\n\tint (*aux_output_match)(struct perf_event *);\n\tint (*filter_match)(struct perf_event *);\n\tint (*check_period)(struct perf_event *, u64);\n};\n\nstruct ftrace_regs {\n\tstruct pt_regs regs;\n};\n\nstruct iovec {\n\tvoid *iov_base;\n\t__kernel_size_t iov_len;\n};\n\nstruct kvec {\n\tvoid *iov_base;\n\tsize_t iov_len;\n};\n\nstruct perf_regs {\n\t__u64 abi;\n\tstruct pt_regs *regs;\n};\n\nstruct u64_stats_sync {};\n\nstruct bpf_cgroup_storage_key {\n\t__u64 cgroup_inode_id;\n\t__u32 attach_type;\n};\n\nenum kmalloc_cache_type {\n\tKMALLOC_NORMAL = 0,\n\tKMALLOC_CGROUP = 1,\n\tKMALLOC_RECLAIM = 2,\n\tKMALLOC_DMA = 3,\n\tNR_KMALLOC_TYPES = 4,\n};\n\nstruct bpf_storage_buffer;\n\nstruct bpf_cgroup_storage_map;\n\nstruct bpf_cgroup_storage {\n\tunion {\n\t\tstruct bpf_storage_buffer *buf;\n\t\tvoid *percpu_buf;\n\t};\n\tstruct bpf_cgroup_storage_map *map;\n\tstruct bpf_cgroup_storage_key key;\n\tstruct list_head list_map;\n\tstruct list_head list_cg;\n\tstruct rb_node node;\n\tstruct callback_head rcu;\n};\n\nstruct bpf_prog_array_item {\n\tstruct bpf_prog *prog;\n\tunion {\n\t\tstruct bpf_cgroup_storage *cgroup_storage[2];\n\t\tu64 bpf_cookie;\n\t};\n};\n\nstruct bpf_prog_array {\n\tstruct callback_head rcu;\n\tstruct bpf_prog_array_item items[0];\n};\n\ntypedef unsigned int sk_buff_data_t;\n\nstruct skb_ext;\n\nstruct sk_buff {\n\tunion {\n\t\tstruct {\n\t\t\tstruct sk_buff *next;\n\t\t\tstruct sk_buff *prev;\n\t\t\tunion {\n\t\t\t\tstruct net_device *dev;\n\t\t\t\tlong unsigned int dev_scratch;\n\t\t\t};\n\t\t};\n\t\tstruct rb_node rbnode;\n\t\tstruct list_head list;\n\t};\n\tunion {\n\t\tstruct sock *sk;\n\t\tint ip_defrag_offset;\n\t};\n\tunion {\n\t\tktime_t tstamp;\n\t\tu64 skb_mstamp_ns;\n\t};\n\tchar cb[48];\n\tunion {\n\t\tstruct {\n\t\t\tlong unsigned int _skb_refdst;\n\t\t\tvoid (*destructor)(struct sk_buff *);\n\t\t};\n\t\tstruct list_head tcp_tsorted_anchor;\n\t\tlong unsigned int _sk_redir;\n\t};\n\tlong unsigned int _nfct;\n\tunsigned int len;\n\tunsigned int data_len;\n\t__u16 mac_len;\n\t__u16 hdr_len;\n\t__u16 queue_mapping;\n\t__u8 __cloned_offset[0];\n\t__u8 cloned: 1;\n\t__u8 nohdr: 1;\n\t__u8 fclone: 2;\n\t__u8 peeked: 1;\n\t__u8 head_frag: 1;\n\t__u8 pfmemalloc: 1;\n\t__u8 pp_recycle: 1;\n\t__u8 active_extensions;\n\t__u32 headers_start[0];\n\t__u8 __pkt_type_offset[0];\n\t__u8 pkt_type: 3;\n\t__u8 ignore_df: 1;\n\t__u8 nf_trace: 1;\n\t__u8 ip_summed: 2;\n\t__u8 ooo_okay: 1;\n\t__u8 l4_hash: 1;\n\t__u8 sw_hash: 1;\n\t__u8 wifi_acked_valid: 1;\n\t__u8 wifi_acked: 1;\n\t__u8 no_fcs: 1;\n\t__u8 encapsulation: 1;\n\t__u8 encap_hdr_csum: 1;\n\t__u8 csum_valid: 1;\n\t__u8 __pkt_vlan_present_offset[0];\n\t__u8 vlan_present: 1;\n\t__u8 csum_complete_sw: 1;\n\t__u8 csum_level: 2;\n\t__u8 csum_not_inet: 1;\n\t__u8 dst_pending_confirm: 1;\n\t__u8 ndisc_nodetype: 2;\n\t__u8 ipvs_property: 1;\n\t__u8 inner_protocol_type: 1;\n\t__u8 remcsum_offload: 1;\n\t__u8 offload_fwd_mark: 1;\n\t__u8 offload_l3_fwd_mark: 1;\n\t__u8 tc_skip_classify: 1;\n\t__u8 tc_at_ingress: 1;\n\t__u8 redirected: 1;\n\t__u8 from_ingress: 1;\n\t__u8 decrypted: 1;\n\t__u8 slow_gro: 1;\n\t__u8 scm_io_uring: 1;\n\t__u16 tc_index;\n\tunion {\n\t\t__wsum csum;\n\t\tstruct {\n\t\t\t__u16 csum_start;\n\t\t\t__u16 csum_offset;\n\t\t};\n\t};\n\t__u32 priority;\n\tint skb_iif;\n\t__u32 hash;\n\t__be16 vlan_proto;\n\t__u16 vlan_tci;\n\tunion {\n\t\tunsigned int napi_id;\n\t\tunsigned int sender_cpu;\n\t};\n\t__u32 secmark;\n\tunion {\n\t\t__u32 mark;\n\t\t__u32 reserved_tailroom;\n\t};\n\tunion {\n\t\t__be16 inner_protocol;\n\t\t__u8 inner_ipproto;\n\t};\n\t__u16 inner_transport_header;\n\t__u16 inner_network_header;\n\t__u16 inner_mac_header;\n\t__be16 protocol;\n\t__u16 transport_header;\n\t__u16 network_header;\n\t__u16 mac_header;\n\t__u32 headers_end[0];\n\tsk_buff_data_t tail;\n\tsk_buff_data_t end;\n\tunsigned char *head;\n\tunsigned char *data;\n\tunsigned int truesize;\n\trefcount_t users;\n\tstruct skb_ext *extensions;\n};\n\nstruct bpf_storage_buffer {\n\tstruct callback_head rcu;\n\tchar data[0];\n};\n\nstruct psi_group_cpu {\n\tseqcount_t seq;\n\tunsigned int tasks[5];\n\tu32 state_mask;\n\tu32 times[7];\n\tu64 state_start;\n\tu32 times_prev[14];\n\tlong: 64;\n};\n\nstruct cgroup_taskset;\n\nstruct cftype;\n\nstruct cgroup_subsys {\n\tstruct cgroup_subsys_state * (*css_alloc)(struct cgroup_subsys_state *);\n\tint (*css_online)(struct cgroup_subsys_state *);\n\tvoid (*css_offline)(struct cgroup_subsys_state *);\n\tvoid (*css_released)(struct cgroup_subsys_state *);\n\tvoid (*css_free)(struct cgroup_subsys_state *);\n\tvoid (*css_reset)(struct cgroup_subsys_state *);\n\tvoid (*css_rstat_flush)(struct cgroup_subsys_state *, int);\n\tint (*css_extra_stat_show)(struct seq_file *, struct cgroup_subsys_state *);\n\tint (*can_attach)(struct cgroup_taskset *);\n\tvoid (*cancel_attach)(struct cgroup_taskset *);\n\tvoid (*attach)(struct cgroup_taskset *);\n\tvoid (*post_attach)();\n\tint (*can_fork)(struct task_struct *, struct css_set *);\n\tvoid (*cancel_fork)(struct task_struct *, struct css_set *);\n\tvoid (*fork)(struct task_struct *);\n\tvoid (*exit)(struct task_struct *);\n\tvoid (*release)(struct task_struct *);\n\tvoid (*bind)(struct cgroup_subsys_state *);\n\tbool early_init: 1;\n\tbool implicit_on_dfl: 1;\n\tbool threaded: 1;\n\tint id;\n\tconst char *name;\n\tconst char *legacy_name;\n\tstruct cgroup_root *root;\n\tstruct idr css_idr;\n\tstruct list_head cfts;\n\tstruct cftype *dfl_cftypes;\n\tstruct cftype *legacy_cftypes;\n\tunsigned int depends_on;\n};\n\nstruct cgroup_rstat_cpu {\n\tstruct u64_stats_sync bsync;\n\tstruct cgroup_base_stat bstat;\n\tstruct cgroup_base_stat last_bstat;\n\tstruct cgroup *updated_children;\n\tstruct cgroup *updated_next;\n};\n\nstruct cgroup_root {\n\tstruct kernfs_root *kf_root;\n\tunsigned int subsys_mask;\n\tint hierarchy_id;\n\tstruct cgroup cgrp;\n\tu64 cgrp_ancestor_id_storage;\n\tatomic_t nr_cgrps;\n\tstruct list_head root_list;\n\tunsigned int flags;\n\tchar release_agent_path[4096];\n\tchar name[64];\n};\n\nstruct cftype {\n\tchar name[64];\n\tlong unsigned int private;\n\tsize_t max_write_len;\n\tunsigned int flags;\n\tunsigned int file_offset;\n\tstruct cgroup_subsys *ss;\n\tstruct list_head node;\n\tstruct kernfs_ops *kf_ops;\n\tint (*open)(struct kernfs_open_file *);\n\tvoid (*release)(struct kernfs_open_file *);\n\tu64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *);\n\ts64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *);\n\tint (*seq_show)(struct seq_file *, void *);\n\tvoid * (*seq_start)(struct seq_file *, loff_t *);\n\tvoid * (*seq_next)(struct seq_file *, void *, loff_t *);\n\tvoid (*seq_stop)(struct seq_file *, void *);\n\tint (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64);\n\tint (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64);\n\tssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);\n\t__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);\n};\n\nstruct perf_callchain_entry {\n\t__u64 nr;\n\t__u64 ip[0];\n};\n\ntypedef long unsigned int (*perf_copy_f)(void *, const void *, long unsigned int, long unsigned int);\n\nstruct perf_raw_frag {\n\tunion {\n\t\tstruct perf_raw_frag *next;\n\t\tlong unsigned int pad;\n\t};\n\tperf_copy_f copy;\n\tvoid *data;\n\tu32 size;\n} __attribute__((packed));\n\nstruct perf_raw_record {\n\tstruct perf_raw_frag frag;\n\tu32 size;\n};\n\nstruct perf_branch_stack {\n\t__u64 nr;\n\t__u64 hw_idx;\n\tstruct perf_branch_entry entries[0];\n};\n\nstruct perf_cpu_context {\n\tstruct perf_event_context ctx;\n\tstruct perf_event_context *task_ctx;\n\tint active_oncpu;\n\tint exclusive;\n\traw_spinlock_t hrtimer_lock;\n\tstruct hrtimer hrtimer;\n\tktime_t hrtimer_interval;\n\tunsigned int hrtimer_active;\n\tstruct perf_cgroup *cgrp;\n\tstruct list_head cgrp_cpuctx_entry;\n\tstruct list_head sched_cb_entry;\n\tint sched_cb_usage;\n\tint online;\n\tint heap_size;\n\tstruct perf_event **heap;\n\tstruct perf_event *heap_default[2];\n};\n\nstruct perf_output_handle {\n\tstruct perf_event *event;\n\tstruct perf_buffer *rb;\n\tlong unsigned int wakeup;\n\tlong unsigned int size;\n\tu64 aux_flags;\n\tunion {\n\t\tvoid *addr;\n\t\tlong unsigned int head;\n\t};\n\tint page;\n};\n\nstruct perf_addr_filter_range {\n\tlong unsigned int start;\n\tlong unsigned int size;\n};\n\nstruct perf_sample_data {\n\tu64 addr;\n\tstruct perf_raw_record *raw;\n\tstruct perf_branch_stack *br_stack;\n\tu64 period;\n\tunion perf_sample_weight weight;\n\tu64 txn;\n\tunion perf_mem_data_src data_src;\n\tu64 type;\n\tu64 ip;\n\tstruct {\n\t\tu32 pid;\n\t\tu32 tid;\n\t} tid_entry;\n\tu64 time;\n\tu64 id;\n\tu64 stream_id;\n\tstruct {\n\t\tu32 cpu;\n\t\tu32 reserved;\n\t} cpu_entry;\n\tstruct perf_callchain_entry *callchain;\n\tu64 aux_size;\n\tstruct perf_regs regs_user;\n\tstruct perf_regs regs_intr;\n\tu64 stack_user_size;\n\tu64 phys_addr;\n\tu64 cgroup;\n\tu64 data_page_size;\n\tu64 code_page_size;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct perf_cgroup_info;\n\nstruct perf_cgroup {\n\tstruct cgroup_subsys_state css;\n\tstruct perf_cgroup_info *info;\n};\n\nstruct perf_cgroup_info {\n\tu64 time;\n\tu64 timestamp;\n\tu64 timeoffset;\n\tint active;\n};\n\nstruct trace_entry {\n\tshort unsigned int type;\n\tunsigned char flags;\n\tunsigned char preempt_count;\n\tint pid;\n};\n\nstruct trace_array;\n\nstruct tracer;\n\nstruct array_buffer;\n\nstruct ring_buffer_iter;\n\nstruct trace_iterator {\n\tstruct trace_array *tr;\n\tstruct tracer *trace;\n\tstruct array_buffer *array_buffer;\n\tvoid *private;\n\tint cpu_file;\n\tstruct mutex mutex;\n\tstruct ring_buffer_iter **buffer_iter;\n\tlong unsigned int iter_flags;\n\tvoid *temp;\n\tunsigned int temp_size;\n\tchar *fmt;\n\tunsigned int fmt_size;\n\tstruct trace_seq tmp_seq;\n\tcpumask_var_t started;\n\tbool snapshot;\n\tstruct trace_seq seq;\n\tstruct trace_entry *ent;\n\tlong unsigned int lost_events;\n\tint leftover;\n\tint ent_size;\n\tint cpu;\n\tu64 ts;\n\tloff_t pos;\n\tlong int idx;\n};\n\nenum print_line_t {\n\tTRACE_TYPE_PARTIAL_LINE = 0,\n\tTRACE_TYPE_HANDLED = 1,\n\tTRACE_TYPE_UNHANDLED = 2,\n\tTRACE_TYPE_NO_CONSUME = 3,\n};\n\ntypedef enum print_line_t (*trace_print_func)(struct trace_iterator *, int, struct trace_event *);\n\nstruct trace_event_functions {\n\ttrace_print_func trace;\n\ttrace_print_func raw;\n\ttrace_print_func hex;\n\ttrace_print_func binary;\n};\n\nenum trace_reg {\n\tTRACE_REG_REGISTER = 0,\n\tTRACE_REG_UNREGISTER = 1,\n\tTRACE_REG_PERF_REGISTER = 2,\n\tTRACE_REG_PERF_UNREGISTER = 3,\n\tTRACE_REG_PERF_OPEN = 4,\n\tTRACE_REG_PERF_CLOSE = 5,\n\tTRACE_REG_PERF_ADD = 6,\n\tTRACE_REG_PERF_DEL = 7,\n};\n\nstruct trace_event_fields {\n\tconst char *type;\n\tunion {\n\t\tstruct {\n\t\t\tconst char *name;\n\t\t\tconst int size;\n\t\t\tconst int align;\n\t\t\tconst int is_signed;\n\t\t\tconst int filter_type;\n\t\t};\n\t\tint (*define_fields)(struct trace_event_call *);\n\t};\n};\n\nstruct trace_event_class {\n\tconst char *system;\n\tvoid *probe;\n\tvoid *perf_probe;\n\tint (*reg)(struct trace_event_call *, enum trace_reg, void *);\n\tstruct trace_event_fields *fields_array;\n\tstruct list_head * (*get_fields)(struct trace_event_call *);\n\tstruct list_head fields;\n\tint (*raw_init)(struct trace_event_call *);\n};\n\nstruct trace_buffer;\n\nstruct trace_event_file;\n\nstruct trace_event_buffer {\n\tstruct trace_buffer *buffer;\n\tstruct ring_buffer_event *event;\n\tstruct trace_event_file *trace_file;\n\tvoid *entry;\n\tunsigned int trace_ctx;\n\tstruct pt_regs *regs;\n};\n\nstruct trace_subsystem_dir;\n\nstruct trace_event_file {\n\tstruct list_head list;\n\tstruct trace_event_call *event_call;\n\tstruct event_filter *filter;\n\tstruct dentry *dir;\n\tstruct trace_array *tr;\n\tstruct trace_subsystem_dir *system;\n\tstruct list_head triggers;\n\tlong unsigned int flags;\n\tatomic_t sm_ref;\n\tatomic_t tm_ref;\n};\n\nenum {\n\tTRACE_EVENT_FL_FILTERED_BIT = 0,\n\tTRACE_EVENT_FL_CAP_ANY_BIT = 1,\n\tTRACE_EVENT_FL_NO_SET_FILTER_BIT = 2,\n\tTRACE_EVENT_FL_IGNORE_ENABLE_BIT = 3,\n\tTRACE_EVENT_FL_TRACEPOINT_BIT = 4,\n\tTRACE_EVENT_FL_DYNAMIC_BIT = 5,\n\tTRACE_EVENT_FL_KPROBE_BIT = 6,\n\tTRACE_EVENT_FL_UPROBE_BIT = 7,\n\tTRACE_EVENT_FL_EPROBE_BIT = 8,\n};\n\nenum {\n\tTRACE_EVENT_FL_FILTERED = 1,\n\tTRACE_EVENT_FL_CAP_ANY = 2,\n\tTRACE_EVENT_FL_NO_SET_FILTER = 4,\n\tTRACE_EVENT_FL_IGNORE_ENABLE = 8,\n\tTRACE_EVENT_FL_TRACEPOINT = 16,\n\tTRACE_EVENT_FL_DYNAMIC = 32,\n\tTRACE_EVENT_FL_KPROBE = 64,\n\tTRACE_EVENT_FL_UPROBE = 128,\n\tTRACE_EVENT_FL_EPROBE = 256,\n};\n\nenum {\n\tEVENT_FILE_FL_ENABLED_BIT = 0,\n\tEVENT_FILE_FL_RECORDED_CMD_BIT = 1,\n\tEVENT_FILE_FL_RECORDED_TGID_BIT = 2,\n\tEVENT_FILE_FL_FILTERED_BIT = 3,\n\tEVENT_FILE_FL_NO_SET_FILTER_BIT = 4,\n\tEVENT_FILE_FL_SOFT_MODE_BIT = 5,\n\tEVENT_FILE_FL_SOFT_DISABLED_BIT = 6,\n\tEVENT_FILE_FL_TRIGGER_MODE_BIT = 7,\n\tEVENT_FILE_FL_TRIGGER_COND_BIT = 8,\n\tEVENT_FILE_FL_PID_FILTER_BIT = 9,\n\tEVENT_FILE_FL_WAS_ENABLED_BIT = 10,\n};\n\nenum {\n\tEVENT_FILE_FL_ENABLED = 1,\n\tEVENT_FILE_FL_RECORDED_CMD = 2,\n\tEVENT_FILE_FL_RECORDED_TGID = 4,\n\tEVENT_FILE_FL_FILTERED = 8,\n\tEVENT_FILE_FL_NO_SET_FILTER = 16,\n\tEVENT_FILE_FL_SOFT_MODE = 32,\n\tEVENT_FILE_FL_SOFT_DISABLED = 64,\n\tEVENT_FILE_FL_TRIGGER_MODE = 128,\n\tEVENT_FILE_FL_TRIGGER_COND = 256,\n\tEVENT_FILE_FL_PID_FILTER = 512,\n\tEVENT_FILE_FL_WAS_ENABLED = 1024,\n};\n\nenum event_trigger_type {\n\tETT_NONE = 0,\n\tETT_TRACE_ONOFF = 1,\n\tETT_SNAPSHOT = 2,\n\tETT_STACKTRACE = 4,\n\tETT_EVENT_ENABLE = 8,\n\tETT_EVENT_HIST = 16,\n\tETT_HIST_ENABLE = 32,\n\tETT_EVENT_EPROBE = 64,\n};\n\nenum {\n\tFILTER_OTHER = 0,\n\tFILTER_STATIC_STRING = 1,\n\tFILTER_DYN_STRING = 2,\n\tFILTER_PTR_STRING = 3,\n\tFILTER_TRACE_FN = 4,\n\tFILTER_COMM = 5,\n\tFILTER_CPU = 6,\n};\n\nstruct fwnode_reference_args;\n\nstruct fwnode_endpoint;\n\nstruct fwnode_operations {\n\tstruct fwnode_handle * (*get)(struct fwnode_handle *);\n\tvoid (*put)(struct fwnode_handle *);\n\tbool (*device_is_available)(const struct fwnode_handle *);\n\tconst void * (*device_get_match_data)(const struct fwnode_handle *, const struct device *);\n\tbool (*property_present)(const struct fwnode_handle *, const char *);\n\tint (*property_read_int_array)(const struct fwnode_handle *, const char *, unsigned int, void *, size_t);\n\tint (*property_read_string_array)(const struct fwnode_handle *, const char *, const char **, size_t);\n\tconst char * (*get_name)(const struct fwnode_handle *);\n\tconst char * (*get_name_prefix)(const struct fwnode_handle *);\n\tstruct fwnode_handle * (*get_parent)(const struct fwnode_handle *);\n\tstruct fwnode_handle * (*get_next_child_node)(const struct fwnode_handle *, struct fwnode_handle *);\n\tstruct fwnode_handle * (*get_named_child_node)(const struct fwnode_handle *, const char *);\n\tint (*get_reference_args)(const struct fwnode_handle *, const char *, const char *, unsigned int, unsigned int, struct fwnode_reference_args *);\n\tstruct fwnode_handle * (*graph_get_next_endpoint)(const struct fwnode_handle *, struct fwnode_handle *);\n\tstruct fwnode_handle * (*graph_get_remote_endpoint)(const struct fwnode_handle *);\n\tstruct fwnode_handle * (*graph_get_port_parent)(struct fwnode_handle *);\n\tint (*graph_parse_endpoint)(const struct fwnode_handle *, struct fwnode_endpoint *);\n\tint (*add_links)(struct fwnode_handle *);\n};\n\nstruct fwnode_endpoint {\n\tunsigned int port;\n\tunsigned int id;\n\tconst struct fwnode_handle *local_fwnode;\n};\n\nstruct fwnode_reference_args {\n\tstruct fwnode_handle *fwnode;\n\tunsigned int nargs;\n\tu64 args[8];\n};\n\nstruct property {\n\tchar *name;\n\tint length;\n\tvoid *value;\n\tstruct property *next;\n};\n\nstruct irq_fwspec {\n\tstruct fwnode_handle *fwnode;\n\tint param_count;\n\tu32 param[16];\n};\n\nstruct irq_domain_ops {\n\tint (*match)(struct irq_domain *, struct device_node *, enum irq_domain_bus_token);\n\tint (*select)(struct irq_domain *, struct irq_fwspec *, enum irq_domain_bus_token);\n\tint (*map)(struct irq_domain *, unsigned int, irq_hw_number_t);\n\tvoid (*unmap)(struct irq_domain *, unsigned int);\n\tint (*xlate)(struct irq_domain *, struct device_node *, const u32 *, unsigned int, long unsigned int *, unsigned int *);\n\tint (*alloc)(struct irq_domain *, unsigned int, unsigned int, void *);\n\tvoid (*free)(struct irq_domain *, unsigned int, unsigned int);\n\tint (*activate)(struct irq_domain *, struct irq_data *, bool);\n\tvoid (*deactivate)(struct irq_domain *, struct irq_data *);\n\tint (*translate)(struct irq_domain *, struct irq_fwspec *, long unsigned int *, unsigned int *);\n};\n\nstruct xbc_node {\n\tu16 next;\n\tu16 child;\n\tu16 parent;\n\tu16 data;\n};\n\nenum wb_stat_item {\n\tWB_RECLAIMABLE = 0,\n\tWB_WRITEBACK = 1,\n\tWB_DIRTIED = 2,\n\tWB_WRITTEN = 3,\n\tNR_WB_STAT_ITEMS = 4,\n};\n\nstruct block_device_operations;\n\nstruct timer_rand_state;\n\nstruct disk_events;\n\nstruct cdrom_device_info;\n\nstruct badblocks;\n\nstruct gendisk {\n\tint major;\n\tint first_minor;\n\tint minors;\n\tchar disk_name[32];\n\tshort unsigned int events;\n\tshort unsigned int event_flags;\n\tstruct xarray part_tbl;\n\tstruct block_device *part0;\n\tconst struct block_device_operations *fops;\n\tstruct request_queue *queue;\n\tvoid *private_data;\n\tint flags;\n\tlong unsigned int state;\n\tstruct mutex open_mutex;\n\tunsigned int open_partitions;\n\tstruct backing_dev_info *bdi;\n\tstruct kobject *slave_dir;\n\tstruct list_head slave_bdevs;\n\tstruct timer_rand_state *random;\n\tatomic_t sync_io;\n\tstruct disk_events *ev;\n\tstruct kobject integrity_kobj;\n\tstruct cdrom_device_info *cdi;\n\tint node_id;\n\tstruct badblocks *bb;\n\tstruct lockdep_map lockdep_map;\n\tu64 diskseq;\n};\n\nstruct partition_meta_info {\n\tchar uuid[37];\n\tu8 volname[64];\n};\n\nstruct bio_integrity_payload {\n\tstruct bio *bip_bio;\n\tstruct bvec_iter bip_iter;\n\tshort unsigned int bip_vcnt;\n\tshort unsigned int bip_max_vcnt;\n\tshort unsigned int bip_flags;\n\tstruct bvec_iter bio_iter;\n\tstruct work_struct bip_work;\n\tstruct bio_vec *bip_vec;\n\tstruct bio_vec bip_inline_vecs[0];\n};\n\nstruct blkg_iostat {\n\tu64 bytes[3];\n\tu64 ios[3];\n};\n\nstruct blkg_iostat_set {\n\tstruct u64_stats_sync sync;\n\tstruct blkg_iostat cur;\n\tstruct blkg_iostat last;\n};\n\nstruct blkcg;\n\nstruct blkg_policy_data;\n\nstruct blkcg_gq {\n\tstruct request_queue *q;\n\tstruct list_head q_node;\n\tstruct hlist_node blkcg_node;\n\tstruct blkcg *blkcg;\n\tstruct blkcg_gq *parent;\n\tstruct percpu_ref refcnt;\n\tbool online;\n\tstruct blkg_iostat_set *iostat_cpu;\n\tstruct blkg_iostat_set iostat;\n\tstruct blkg_policy_data *pd[6];\n\tspinlock_t async_bio_lock;\n\tstruct bio_list async_bios;\n\tstruct work_struct async_bio_work;\n\tatomic_t use_delay;\n\tatomic64_t delay_nsec;\n\tatomic64_t delay_start;\n\tu64 last_delay;\n\tint last_use;\n\tstruct callback_head callback_head;\n};\n\ntypedef __u32 blk_mq_req_flags_t;\n\ntypedef unsigned int blk_qc_t;\n\nstruct blk_integrity_iter;\n\ntypedef blk_status_t integrity_processing_fn(struct blk_integrity_iter *);\n\ntypedef void integrity_prepare_fn(struct request *);\n\ntypedef void integrity_complete_fn(struct request *, unsigned int);\n\nstruct blk_integrity_profile {\n\tintegrity_processing_fn *generate_fn;\n\tintegrity_processing_fn *verify_fn;\n\tintegrity_prepare_fn *prepare_fn;\n\tintegrity_complete_fn *complete_fn;\n\tconst char *name;\n};\n\nstruct blk_zone;\n\ntypedef int (*report_zones_cb)(struct blk_zone *, unsigned int, void *);\n\nstruct hd_geometry;\n\nstruct pr_ops;\n\nstruct block_device_operations {\n\tblk_qc_t (*submit_bio)(struct bio *);\n\tint (*open)(struct block_device *, fmode_t);\n\tvoid (*release)(struct gendisk *, fmode_t);\n\tint (*rw_page)(struct block_device *, sector_t, struct page *, unsigned int);\n\tint (*ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);\n\tint (*compat_ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);\n\tunsigned int (*check_events)(struct gendisk *, unsigned int);\n\tvoid (*unlock_native_capacity)(struct gendisk *);\n\tint (*getgeo)(struct block_device *, struct hd_geometry *);\n\tint (*set_read_only)(struct block_device *, bool);\n\tvoid (*swap_slot_free_notify)(struct block_device *, long unsigned int);\n\tint (*report_zones)(struct gendisk *, sector_t, unsigned int, report_zones_cb, void *);\n\tchar * (*devnode)(struct gendisk *, umode_t *);\n\tstruct module *owner;\n\tconst struct pr_ops *pr_ops;\n\tint (*alternative_gpt_sector)(struct gendisk *, sector_t *);\n};\n\nstruct blk_zone {\n\t__u64 start;\n\t__u64 len;\n\t__u64 wp;\n\t__u8 type;\n\t__u8 cond;\n\t__u8 non_seq;\n\t__u8 reset;\n\t__u8 resv[4];\n\t__u64 capacity;\n\t__u8 reserved[24];\n};\n\nstruct sbitmap_word {\n\tlong unsigned int depth;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong unsigned int word;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong unsigned int cleared;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct sbq_wait_state {\n\tatomic_t wait_cnt;\n\twait_queue_head_t wait;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\ntypedef void rq_end_io_fn(struct request *, blk_status_t);\n\ntypedef __u32 req_flags_t;\n\nenum mq_rq_state {\n\tMQ_RQ_IDLE = 0,\n\tMQ_RQ_IN_FLIGHT = 1,\n\tMQ_RQ_COMPLETE = 2,\n};\n\nstruct blk_ksm_keyslot;\n\nstruct request {\n\tstruct request_queue *q;\n\tstruct blk_mq_ctx *mq_ctx;\n\tstruct blk_mq_hw_ctx *mq_hctx;\n\tunsigned int cmd_flags;\n\treq_flags_t rq_flags;\n\tint tag;\n\tint internal_tag;\n\tunsigned int __data_len;\n\tsector_t __sector;\n\tstruct bio *bio;\n\tstruct bio *biotail;\n\tstruct list_head queuelist;\n\tunion {\n\t\tstruct hlist_node hash;\n\t\tstruct llist_node ipi_list;\n\t};\n\tunion {\n\t\tstruct rb_node rb_node;\n\t\tstruct bio_vec special_vec;\n\t\tvoid *completion_data;\n\t\tint error_count;\n\t};\n\tunion {\n\t\tstruct {\n\t\t\tstruct io_cq *icq;\n\t\t\tvoid *priv[2];\n\t\t} elv;\n\t\tstruct {\n\t\t\tunsigned int seq;\n\t\t\tstruct list_head list;\n\t\t\trq_end_io_fn *saved_end_io;\n\t\t} flush;\n\t};\n\tstruct gendisk *rq_disk;\n\tstruct block_device *part;\n\tu64 alloc_time_ns;\n\tu64 start_time_ns;\n\tu64 io_start_time_ns;\n\tshort unsigned int wbt_flags;\n\tshort unsigned int stats_sectors;\n\tshort unsigned int nr_phys_segments;\n\tshort unsigned int nr_integrity_segments;\n\tstruct bio_crypt_ctx *crypt_ctx;\n\tstruct blk_ksm_keyslot *crypt_keyslot;\n\tshort unsigned int write_hint;\n\tshort unsigned int ioprio;\n\tenum mq_rq_state state;\n\trefcount_t ref;\n\tunsigned int timeout;\n\tlong unsigned int deadline;\n\tunion {\n\t\tstruct __call_single_data csd;\n\t\tu64 fifo_time;\n\t};\n\trq_end_io_fn *end_io;\n\tvoid *end_io_data;\n};\n\nstruct blk_mq_tags;\n\nstruct blk_mq_hw_ctx {\n\tstruct {\n\t\tspinlock_t lock;\n\t\tstruct list_head dispatch;\n\t\tlong unsigned int state;\n\t\tlong: 64;\n\t\tlong: 64;\n\t\tlong: 64;\n\t\tlong: 64;\n\t};\n\tstruct delayed_work run_work;\n\tcpumask_var_t cpumask;\n\tint next_cpu;\n\tint next_cpu_batch;\n\tlong unsigned int flags;\n\tvoid *sched_data;\n\tstruct request_queue *queue;\n\tstruct blk_flush_queue *fq;\n\tvoid *driver_data;\n\tstruct sbitmap ctx_map;\n\tstruct blk_mq_ctx *dispatch_from;\n\tunsigned int dispatch_busy;\n\tshort unsigned int type;\n\tshort unsigned int nr_ctx;\n\tstruct blk_mq_ctx **ctxs;\n\tspinlock_t dispatch_wait_lock;\n\twait_queue_entry_t dispatch_wait;\n\tatomic_t wait_index;\n\tstruct blk_mq_tags *tags;\n\tstruct blk_mq_tags *sched_tags;\n\tlong unsigned int queued;\n\tlong unsigned int run;\n\tlong unsigned int dispatched[7];\n\tunsigned int numa_node;\n\tunsigned int queue_num;\n\tatomic_t nr_active;\n\tstruct hlist_node cpuhp_online;\n\tstruct hlist_node cpuhp_dead;\n\tstruct kobject kobj;\n\tlong unsigned int poll_considered;\n\tlong unsigned int poll_invoked;\n\tlong unsigned int poll_success;\n\tstruct dentry *debugfs_dir;\n\tstruct dentry *sched_debugfs_dir;\n\tstruct list_head hctx_list;\n\tstruct srcu_struct srcu[0];\n};\n\nenum elv_merge {\n\tELEVATOR_NO_MERGE = 0,\n\tELEVATOR_FRONT_MERGE = 1,\n\tELEVATOR_BACK_MERGE = 2,\n\tELEVATOR_DISCARD_MERGE = 3,\n};\n\nstruct elevator_type;\n\nstruct blk_mq_alloc_data;\n\nstruct elevator_mq_ops {\n\tint (*init_sched)(struct request_queue *, struct elevator_type *);\n\tvoid (*exit_sched)(struct elevator_queue *);\n\tint (*init_hctx)(struct blk_mq_hw_ctx *, unsigned int);\n\tvoid (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);\n\tvoid (*depth_updated)(struct blk_mq_hw_ctx *);\n\tbool (*allow_merge)(struct request_queue *, struct request *, struct bio *);\n\tbool (*bio_merge)(struct request_queue *, struct bio *, unsigned int);\n\tint (*request_merge)(struct request_queue *, struct request **, struct bio *);\n\tvoid (*request_merged)(struct request_queue *, struct request *, enum elv_merge);\n\tvoid (*requests_merged)(struct request_queue *, struct request *, struct request *);\n\tvoid (*limit_depth)(unsigned int, struct blk_mq_alloc_data *);\n\tvoid (*prepare_request)(struct request *);\n\tvoid (*finish_request)(struct request *);\n\tvoid (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, bool);\n\tstruct request * (*dispatch_request)(struct blk_mq_hw_ctx *);\n\tbool (*has_work)(struct blk_mq_hw_ctx *);\n\tvoid (*completed_request)(struct request *, u64);\n\tvoid (*requeue_request)(struct request *);\n\tstruct request * (*former_request)(struct request_queue *, struct request *);\n\tstruct request * (*next_request)(struct request_queue *, struct request *);\n\tvoid (*init_icq)(struct io_cq *);\n\tvoid (*exit_icq)(struct io_cq *);\n};\n\nstruct elv_fs_entry;\n\nstruct blk_mq_debugfs_attr;\n\nstruct elevator_type {\n\tstruct kmem_cache *icq_cache;\n\tstruct elevator_mq_ops ops;\n\tsize_t icq_size;\n\tsize_t icq_align;\n\tstruct elv_fs_entry *elevator_attrs;\n\tconst char *elevator_name;\n\tconst char *elevator_alias;\n\tconst unsigned int elevator_features;\n\tstruct module *elevator_owner;\n\tconst struct blk_mq_debugfs_attr *queue_debugfs_attrs;\n\tconst struct blk_mq_debugfs_attr *hctx_debugfs_attrs;\n\tchar icq_cache_name[22];\n\tstruct list_head list;\n};\n\nstruct elevator_queue {\n\tstruct elevator_type *type;\n\tvoid *elevator_data;\n\tstruct kobject kobj;\n\tstruct mutex sysfs_lock;\n\tunsigned int registered: 1;\n\tstruct hlist_head hash[64];\n};\n\nstruct elv_fs_entry {\n\tstruct attribute attr;\n\tssize_t (*show)(struct elevator_queue *, char *);\n\tssize_t (*store)(struct elevator_queue *, const char *, size_t);\n};\n\nstruct blk_mq_debugfs_attr {\n\tconst char *name;\n\tumode_t mode;\n\tint (*show)(void *, struct seq_file *);\n\tssize_t (*write)(void *, const char *, size_t, loff_t *);\n\tconst struct seq_operations *seq_ops;\n};\n\nenum blk_eh_timer_return {\n\tBLK_EH_DONE = 0,\n\tBLK_EH_RESET_TIMER = 1,\n};\n\nstruct blk_mq_queue_data;\n\nstruct blk_mq_ops {\n\tblk_status_t (*queue_rq)(struct blk_mq_hw_ctx *, const struct blk_mq_queue_data *);\n\tvoid (*commit_rqs)(struct blk_mq_hw_ctx *);\n\tint (*get_budget)(struct request_queue *);\n\tvoid (*put_budget)(struct request_queue *, int);\n\tvoid (*set_rq_budget_token)(struct request *, int);\n\tint (*get_rq_budget_token)(struct request *);\n\tenum blk_eh_timer_return (*timeout)(struct request *, bool);\n\tint (*poll)(struct blk_mq_hw_ctx *);\n\tvoid (*complete)(struct request *);\n\tint (*init_hctx)(struct blk_mq_hw_ctx *, void *, unsigned int);\n\tvoid (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);\n\tint (*init_request)(struct blk_mq_tag_set *, struct request *, unsigned int, unsigned int);\n\tvoid (*exit_request)(struct blk_mq_tag_set *, struct request *, unsigned int);\n\tvoid (*initialize_rq_fn)(struct request *);\n\tvoid (*cleanup_rq)(struct request *);\n\tbool (*busy)(struct request_queue *);\n\tint (*map_queues)(struct blk_mq_tag_set *);\n\tvoid (*show_rq)(struct seq_file *, struct request *);\n};\n\nstruct blk_mq_queue_map {\n\tunsigned int *mq_map;\n\tunsigned int nr_queues;\n\tunsigned int queue_offset;\n};\n\nstruct blk_mq_tag_set {\n\tstruct blk_mq_queue_map map[3];\n\tunsigned int nr_maps;\n\tconst struct blk_mq_ops *ops;\n\tunsigned int nr_hw_queues;\n\tunsigned int queue_depth;\n\tunsigned int reserved_tags;\n\tunsigned int cmd_size;\n\tint numa_node;\n\tunsigned int timeout;\n\tunsigned int flags;\n\tvoid *driver_data;\n\tatomic_t active_queues_shared_sbitmap;\n\tstruct sbitmap_queue __bitmap_tags;\n\tstruct sbitmap_queue __breserved_tags;\n\tstruct blk_mq_tags **tags;\n\tstruct mutex tag_list_lock;\n\tstruct list_head tag_list;\n};\n\nstruct blk_integrity_iter {\n\tvoid *prot_buf;\n\tvoid *data_buf;\n\tsector_t seed;\n\tunsigned int data_size;\n\tshort unsigned int interval;\n\tconst char *disk_name;\n};\n\nenum pr_type {\n\tPR_WRITE_EXCLUSIVE = 1,\n\tPR_EXCLUSIVE_ACCESS = 2,\n\tPR_WRITE_EXCLUSIVE_REG_ONLY = 3,\n\tPR_EXCLUSIVE_ACCESS_REG_ONLY = 4,\n\tPR_WRITE_EXCLUSIVE_ALL_REGS = 5,\n\tPR_EXCLUSIVE_ACCESS_ALL_REGS = 6,\n};\n\nstruct pr_ops {\n\tint (*pr_register)(struct block_device *, u64, u64, u32);\n\tint (*pr_reserve)(struct block_device *, u64, enum pr_type, u32);\n\tint (*pr_release)(struct block_device *, u64, enum pr_type);\n\tint (*pr_preempt)(struct block_device *, u64, u64, enum pr_type, bool);\n\tint (*pr_clear)(struct block_device *, u64);\n};\n\nenum hctx_type {\n\tHCTX_TYPE_DEFAULT = 0,\n\tHCTX_TYPE_READ = 1,\n\tHCTX_TYPE_POLL = 2,\n\tHCTX_MAX_TYPES = 3,\n};\n\nstruct blk_mq_queue_data {\n\tstruct request *rq;\n\tbool last;\n};\n\nenum blkg_iostat_type {\n\tBLKG_IOSTAT_READ = 0,\n\tBLKG_IOSTAT_WRITE = 1,\n\tBLKG_IOSTAT_DISCARD = 2,\n\tBLKG_IOSTAT_NR = 3,\n};\n\nstruct blkcg_policy_data;\n\nstruct blkcg {\n\tstruct cgroup_subsys_state css;\n\tspinlock_t lock;\n\trefcount_t online_pin;\n\tstruct xarray blkg_tree;\n\tstruct blkcg_gq *blkg_hint;\n\tstruct hlist_head blkg_list;\n\tstruct blkcg_policy_data *cpd[6];\n\tstruct list_head all_blkcgs_node;\n\tchar fc_app_id[129];\n\tstruct list_head cgwb_list;\n};\n\nstruct blkcg_policy_data {\n\tstruct blkcg *blkcg;\n\tint plid;\n};\n\nstruct blkg_policy_data {\n\tstruct blkcg_gq *blkg;\n\tint plid;\n};\n\ntypedef long unsigned int efi_status_t;\n\ntypedef u8 efi_bool_t;\n\ntypedef u16 efi_char16_t;\n\ntypedef guid_t efi_guid_t;\n\ntypedef struct {\n\tu64 signature;\n\tu32 revision;\n\tu32 headersize;\n\tu32 crc32;\n\tu32 reserved;\n} efi_table_hdr_t;\n\ntypedef struct {\n\tu32 type;\n\tu32 pad;\n\tu64 phys_addr;\n\tu64 virt_addr;\n\tu64 num_pages;\n\tu64 attribute;\n} efi_memory_desc_t;\n\ntypedef struct {\n\tefi_guid_t guid;\n\tu32 headersize;\n\tu32 flags;\n\tu32 imagesize;\n} efi_capsule_header_t;\n\ntypedef struct {\n\tu16 year;\n\tu8 month;\n\tu8 day;\n\tu8 hour;\n\tu8 minute;\n\tu8 second;\n\tu8 pad1;\n\tu32 nanosecond;\n\ts16 timezone;\n\tu8 daylight;\n\tu8 pad2;\n} efi_time_t;\n\ntypedef struct {\n\tu32 resolution;\n\tu32 accuracy;\n\tu8 sets_to_zero;\n} efi_time_cap_t;\n\ntypedef struct {\n\tefi_table_hdr_t hdr;\n\tu32 get_time;\n\tu32 set_time;\n\tu32 get_wakeup_time;\n\tu32 set_wakeup_time;\n\tu32 set_virtual_address_map;\n\tu32 convert_pointer;\n\tu32 get_variable;\n\tu32 get_next_variable;\n\tu32 set_variable;\n\tu32 get_next_high_mono_count;\n\tu32 reset_system;\n\tu32 update_capsule;\n\tu32 query_capsule_caps;\n\tu32 query_variable_info;\n} efi_runtime_services_32_t;\n\ntypedef efi_status_t efi_get_time_t(efi_time_t *, efi_time_cap_t *);\n\ntypedef efi_status_t efi_set_time_t(efi_time_t *);\n\ntypedef efi_status_t efi_get_wakeup_time_t(efi_bool_t *, efi_bool_t *, efi_time_t *);\n\ntypedef efi_status_t efi_set_wakeup_time_t(efi_bool_t, efi_time_t *);\n\ntypedef efi_status_t efi_get_variable_t(efi_char16_t *, efi_guid_t *, u32 *, long unsigned int *, void *);\n\ntypedef efi_status_t efi_get_next_variable_t(long unsigned int *, efi_char16_t *, efi_guid_t *);\n\ntypedef efi_status_t efi_set_variable_t(efi_char16_t *, efi_guid_t *, u32, long unsigned int, void *);\n\ntypedef efi_status_t efi_get_next_high_mono_count_t(u32 *);\n\ntypedef void efi_reset_system_t(int, efi_status_t, long unsigned int, efi_char16_t *);\n\ntypedef efi_status_t efi_query_variable_info_t(u32, u64 *, u64 *, u64 *);\n\ntypedef efi_status_t efi_update_capsule_t(efi_capsule_header_t **, long unsigned int, long unsigned int);\n\ntypedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **, long unsigned int, u64 *, int *);\n\ntypedef union {\n\tstruct {\n\t\tefi_table_hdr_t hdr;\n\t\tefi_status_t (*get_time)(efi_time_t *, efi_time_cap_t *);\n\t\tefi_status_t (*set_time)(efi_time_t *);\n\t\tefi_status_t (*get_wakeup_time)(efi_bool_t *, efi_bool_t *, efi_time_t *);\n\t\tefi_status_t (*set_wakeup_time)(efi_bool_t, efi_time_t *);\n\t\tefi_status_t (*set_virtual_address_map)(long unsigned int, long unsigned int, u32, efi_memory_desc_t *);\n\t\tvoid *convert_pointer;\n\t\tefi_status_t (*get_variable)(efi_char16_t *, efi_guid_t *, u32 *, long unsigned int *, void *);\n\t\tefi_status_t (*get_next_variable)(long unsigned int *, efi_char16_t *, efi_guid_t *);\n\t\tefi_status_t (*set_variable)(efi_char16_t *, efi_guid_t *, u32, long unsigned int, void *);\n\t\tefi_status_t (*get_next_high_mono_count)(u32 *);\n\t\tvoid (*reset_system)(int, efi_status_t, long unsigned int, efi_char16_t *);\n\t\tefi_status_t (*update_capsule)(efi_capsule_header_t **, long unsigned int, long unsigned int);\n\t\tefi_status_t (*query_capsule_caps)(efi_capsule_header_t **, long unsigned int, u64 *, int *);\n\t\tefi_status_t (*query_variable_info)(u32, u64 *, u64 *, u64 *);\n\t};\n\tefi_runtime_services_32_t mixed_mode;\n} efi_runtime_services_t;\n\nstruct efi_memory_map {\n\tphys_addr_t phys_map;\n\tvoid *map;\n\tvoid *map_end;\n\tint nr_map;\n\tlong unsigned int desc_version;\n\tlong unsigned int desc_size;\n\tlong unsigned int flags;\n};\n\nstruct efi {\n\tconst efi_runtime_services_t *runtime;\n\tunsigned int runtime_version;\n\tunsigned int runtime_supported_mask;\n\tlong unsigned int acpi;\n\tlong unsigned int acpi20;\n\tlong unsigned int smbios;\n\tlong unsigned int smbios3;\n\tlong unsigned int esrt;\n\tlong unsigned int tpm_log;\n\tlong unsigned int tpm_final_log;\n\tlong unsigned int mokvar_table;\n\tefi_get_time_t *get_time;\n\tefi_set_time_t *set_time;\n\tefi_get_wakeup_time_t *get_wakeup_time;\n\tefi_set_wakeup_time_t *set_wakeup_time;\n\tefi_get_variable_t *get_variable;\n\tefi_get_next_variable_t *get_next_variable;\n\tefi_set_variable_t *set_variable;\n\tefi_set_variable_t *set_variable_nonblocking;\n\tefi_query_variable_info_t *query_variable_info;\n\tefi_query_variable_info_t *query_variable_info_nonblocking;\n\tefi_update_capsule_t *update_capsule;\n\tefi_query_capsule_caps_t *query_capsule_caps;\n\tefi_get_next_high_mono_count_t *get_next_high_mono_count;\n\tefi_reset_system_t *reset_system;\n\tstruct efi_memory_map memmap;\n\tlong unsigned int flags;\n};\n\nenum memcg_stat_item {\n\tMEMCG_SWAP = 39,\n\tMEMCG_SOCK = 40,\n\tMEMCG_PERCPU_B = 41,\n\tMEMCG_NR_STAT = 42,\n};\n\nenum memcg_memory_event {\n\tMEMCG_LOW = 0,\n\tMEMCG_HIGH = 1,\n\tMEMCG_MAX = 2,\n\tMEMCG_OOM = 3,\n\tMEMCG_OOM_KILL = 4,\n\tMEMCG_SWAP_HIGH = 5,\n\tMEMCG_SWAP_MAX = 6,\n\tMEMCG_SWAP_FAIL = 7,\n\tMEMCG_NR_MEMORY_EVENTS = 8,\n};\n\nenum mem_cgroup_events_target {\n\tMEM_CGROUP_TARGET_THRESH = 0,\n\tMEM_CGROUP_TARGET_SOFTLIMIT = 1,\n\tMEM_CGROUP_NTARGETS = 2,\n};\n\nstruct memcg_vmstats_percpu {\n\tlong int state[42];\n\tlong unsigned int events[100];\n\tlong int state_prev[42];\n\tlong unsigned int events_prev[100];\n\tlong unsigned int nr_page_events;\n\tlong unsigned int targets[2];\n};\n\nstruct mem_cgroup_reclaim_iter {\n\tstruct mem_cgroup *position;\n\tunsigned int generation;\n};\n\nstruct shrinker_info {\n\tstruct callback_head rcu;\n\tatomic_long_t *nr_deferred;\n\tlong unsigned int *map;\n};\n\nstruct lruvec_stats_percpu {\n\tlong int state[39];\n\tlong int state_prev[39];\n};\n\nstruct lruvec_stats {\n\tlong int state[39];\n\tlong int state_pending[39];\n};\n\nstruct mem_cgroup_per_node {\n\tstruct lruvec lruvec;\n\tstruct lruvec_stats_percpu *lruvec_stats_percpu;\n\tstruct lruvec_stats lruvec_stats;\n\tlong unsigned int lru_zone_size[25];\n\tstruct mem_cgroup_reclaim_iter iter;\n\tstruct shrinker_info *shrinker_info;\n\tstruct rb_node tree_node;\n\tlong unsigned int usage_in_excess;\n\tbool on_tree;\n\tstruct mem_cgroup *memcg;\n};\n\nstruct eventfd_ctx;\n\nstruct mem_cgroup_threshold {\n\tstruct eventfd_ctx *eventfd;\n\tlong unsigned int threshold;\n};\n\nstruct mem_cgroup_threshold_ary {\n\tint current_threshold;\n\tunsigned int size;\n\tstruct mem_cgroup_threshold entries[0];\n};\n\nstruct obj_cgroup {\n\tstruct percpu_ref refcnt;\n\tstruct mem_cgroup *memcg;\n\tatomic_t nr_charged_bytes;\n\tunion {\n\t\tstruct list_head list;\n\t\tstruct callback_head rcu;\n\t};\n};\n\nstruct percpu_cluster {\n\tstruct swap_cluster_info index;\n\tunsigned int next;\n};\n\nenum fs_value_type {\n\tfs_value_is_undefined = 0,\n\tfs_value_is_flag = 1,\n\tfs_value_is_string = 2,\n\tfs_value_is_blob = 3,\n\tfs_value_is_filename = 4,\n\tfs_value_is_file = 5,\n};\n\nstruct fs_parameter {\n\tconst char *key;\n\tenum fs_value_type type: 8;\n\tunion {\n\t\tchar *string;\n\t\tvoid *blob;\n\t\tstruct filename *name;\n\t\tstruct file *file;\n\t};\n\tsize_t size;\n\tint dirfd;\n};\n\nstruct fc_log {\n\trefcount_t usage;\n\tu8 head;\n\tu8 tail;\n\tu8 need_free;\n\tstruct module *owner;\n\tchar *buffer[8];\n};\n\nstruct fs_context_operations {\n\tvoid (*free)(struct fs_context *);\n\tint (*dup)(struct fs_context *, struct fs_context *);\n\tint (*parse_param)(struct fs_context *, struct fs_parameter *);\n\tint (*parse_monolithic)(struct fs_context *, void *);\n\tint (*get_tree)(struct fs_context *);\n\tint (*reconfigure)(struct fs_context *);\n};\n\nstruct fs_parse_result {\n\tbool negated;\n\tunion {\n\t\tbool boolean;\n\t\tint int_32;\n\t\tunsigned int uint_32;\n\t\tu64 uint_64;\n\t};\n};\n\nstruct in6_addr {\n\tunion {\n\t\t__u8 u6_addr8[16];\n\t\t__be16 u6_addr16[8];\n\t\t__be32 u6_addr32[4];\n\t} in6_u;\n};\n\nenum flow_dissector_key_id {\n\tFLOW_DISSECTOR_KEY_CONTROL = 0,\n\tFLOW_DISSECTOR_KEY_BASIC = 1,\n\tFLOW_DISSECTOR_KEY_IPV4_ADDRS = 2,\n\tFLOW_DISSECTOR_KEY_IPV6_ADDRS = 3,\n\tFLOW_DISSECTOR_KEY_PORTS = 4,\n\tFLOW_DISSECTOR_KEY_PORTS_RANGE = 5,\n\tFLOW_DISSECTOR_KEY_ICMP = 6,\n\tFLOW_DISSECTOR_KEY_ETH_ADDRS = 7,\n\tFLOW_DISSECTOR_KEY_TIPC = 8,\n\tFLOW_DISSECTOR_KEY_ARP = 9,\n\tFLOW_DISSECTOR_KEY_VLAN = 10,\n\tFLOW_DISSECTOR_KEY_FLOW_LABEL = 11,\n\tFLOW_DISSECTOR_KEY_GRE_KEYID = 12,\n\tFLOW_DISSECTOR_KEY_MPLS_ENTROPY = 13,\n\tFLOW_DISSECTOR_KEY_ENC_KEYID = 14,\n\tFLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS = 15,\n\tFLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS = 16,\n\tFLOW_DISSECTOR_KEY_ENC_CONTROL = 17,\n\tFLOW_DISSECTOR_KEY_ENC_PORTS = 18,\n\tFLOW_DISSECTOR_KEY_MPLS = 19,\n\tFLOW_DISSECTOR_KEY_TCP = 20,\n\tFLOW_DISSECTOR_KEY_IP = 21,\n\tFLOW_DISSECTOR_KEY_CVLAN = 22,\n\tFLOW_DISSECTOR_KEY_ENC_IP = 23,\n\tFLOW_DISSECTOR_KEY_ENC_OPTS = 24,\n\tFLOW_DISSECTOR_KEY_META = 25,\n\tFLOW_DISSECTOR_KEY_CT = 26,\n\tFLOW_DISSECTOR_KEY_HASH = 27,\n\tFLOW_DISSECTOR_KEY_MAX = 28,\n};\n\nenum {\n\tIPSTATS_MIB_NUM = 0,\n\tIPSTATS_MIB_INPKTS = 1,\n\tIPSTATS_MIB_INOCTETS = 2,\n\tIPSTATS_MIB_INDELIVERS = 3,\n\tIPSTATS_MIB_OUTFORWDATAGRAMS = 4,\n\tIPSTATS_MIB_OUTPKTS = 5,\n\tIPSTATS_MIB_OUTOCTETS = 6,\n\tIPSTATS_MIB_INHDRERRORS = 7,\n\tIPSTATS_MIB_INTOOBIGERRORS = 8,\n\tIPSTATS_MIB_INNOROUTES = 9,\n\tIPSTATS_MIB_INADDRERRORS = 10,\n\tIPSTATS_MIB_INUNKNOWNPROTOS = 11,\n\tIPSTATS_MIB_INTRUNCATEDPKTS = 12,\n\tIPSTATS_MIB_INDISCARDS = 13,\n\tIPSTATS_MIB_OUTDISCARDS = 14,\n\tIPSTATS_MIB_OUTNOROUTES = 15,\n\tIPSTATS_MIB_REASMTIMEOUT = 16,\n\tIPSTATS_MIB_REASMREQDS = 17,\n\tIPSTATS_MIB_REASMOKS = 18,\n\tIPSTATS_MIB_REASMFAILS = 19,\n\tIPSTATS_MIB_FRAGOKS = 20,\n\tIPSTATS_MIB_FRAGFAILS = 21,\n\tIPSTATS_MIB_FRAGCREATES = 22,\n\tIPSTATS_MIB_INMCASTPKTS = 23,\n\tIPSTATS_MIB_OUTMCASTPKTS = 24,\n\tIPSTATS_MIB_INBCASTPKTS = 25,\n\tIPSTATS_MIB_OUTBCASTPKTS = 26,\n\tIPSTATS_MIB_INMCASTOCTETS = 27,\n\tIPSTATS_MIB_OUTMCASTOCTETS = 28,\n\tIPSTATS_MIB_INBCASTOCTETS = 29,\n\tIPSTATS_MIB_OUTBCASTOCTETS = 30,\n\tIPSTATS_MIB_CSUMERRORS = 31,\n\tIPSTATS_MIB_NOECTPKTS = 32,\n\tIPSTATS_MIB_ECT1PKTS = 33,\n\tIPSTATS_MIB_ECT0PKTS = 34,\n\tIPSTATS_MIB_CEPKTS = 35,\n\tIPSTATS_MIB_REASM_OVERLAPS = 36,\n\t__IPSTATS_MIB_MAX = 37,\n};\n\nenum {\n\tICMP_MIB_NUM = 0,\n\tICMP_MIB_INMSGS = 1,\n\tICMP_MIB_INERRORS = 2,\n\tICMP_MIB_INDESTUNREACHS = 3,\n\tICMP_MIB_INTIMEEXCDS = 4,\n\tICMP_MIB_INPARMPROBS = 5,\n\tICMP_MIB_INSRCQUENCHS = 6,\n\tICMP_MIB_INREDIRECTS = 7,\n\tICMP_MIB_INECHOS = 8,\n\tICMP_MIB_INECHOREPS = 9,\n\tICMP_MIB_INTIMESTAMPS = 10,\n\tICMP_MIB_INTIMESTAMPREPS = 11,\n\tICMP_MIB_INADDRMASKS = 12,\n\tICMP_MIB_INADDRMASKREPS = 13,\n\tICMP_MIB_OUTMSGS = 14,\n\tICMP_MIB_OUTERRORS = 15,\n\tICMP_MIB_OUTDESTUNREACHS = 16,\n\tICMP_MIB_OUTTIMEEXCDS = 17,\n\tICMP_MIB_OUTPARMPROBS = 18,\n\tICMP_MIB_OUTSRCQUENCHS = 19,\n\tICMP_MIB_OUTREDIRECTS = 20,\n\tICMP_MIB_OUTECHOS = 21,\n\tICMP_MIB_OUTECHOREPS = 22,\n\tICMP_MIB_OUTTIMESTAMPS = 23,\n\tICMP_MIB_OUTTIMESTAMPREPS = 24,\n\tICMP_MIB_OUTADDRMASKS = 25,\n\tICMP_MIB_OUTADDRMASKREPS = 26,\n\tICMP_MIB_CSUMERRORS = 27,\n\t__ICMP_MIB_MAX = 28,\n};\n\nenum {\n\tICMP6_MIB_NUM = 0,\n\tICMP6_MIB_INMSGS = 1,\n\tICMP6_MIB_INERRORS = 2,\n\tICMP6_MIB_OUTMSGS = 3,\n\tICMP6_MIB_OUTERRORS = 4,\n\tICMP6_MIB_CSUMERRORS = 5,\n\t__ICMP6_MIB_MAX = 6,\n};\n\nenum {\n\tTCP_MIB_NUM = 0,\n\tTCP_MIB_RTOALGORITHM = 1,\n\tTCP_MIB_RTOMIN = 2,\n\tTCP_MIB_RTOMAX = 3,\n\tTCP_MIB_MAXCONN = 4,\n\tTCP_MIB_ACTIVEOPENS = 5,\n\tTCP_MIB_PASSIVEOPENS = 6,\n\tTCP_MIB_ATTEMPTFAILS = 7,\n\tTCP_MIB_ESTABRESETS = 8,\n\tTCP_MIB_CURRESTAB = 9,\n\tTCP_MIB_INSEGS = 10,\n\tTCP_MIB_OUTSEGS = 11,\n\tTCP_MIB_RETRANSSEGS = 12,\n\tTCP_MIB_INERRS = 13,\n\tTCP_MIB_OUTRSTS = 14,\n\tTCP_MIB_CSUMERRORS = 15,\n\t__TCP_MIB_MAX = 16,\n};\n\nenum {\n\tUDP_MIB_NUM = 0,\n\tUDP_MIB_INDATAGRAMS = 1,\n\tUDP_MIB_NOPORTS = 2,\n\tUDP_MIB_INERRORS = 3,\n\tUDP_MIB_OUTDATAGRAMS = 4,\n\tUDP_MIB_RCVBUFERRORS = 5,\n\tUDP_MIB_SNDBUFERRORS = 6,\n\tUDP_MIB_CSUMERRORS = 7,\n\tUDP_MIB_IGNOREDMULTI = 8,\n\tUDP_MIB_MEMERRORS = 9,\n\t__UDP_MIB_MAX = 10,\n};\n\nenum {\n\tLINUX_MIB_NUM = 0,\n\tLINUX_MIB_SYNCOOKIESSENT = 1,\n\tLINUX_MIB_SYNCOOKIESRECV = 2,\n\tLINUX_MIB_SYNCOOKIESFAILED = 3,\n\tLINUX_MIB_EMBRYONICRSTS = 4,\n\tLINUX_MIB_PRUNECALLED = 5,\n\tLINUX_MIB_RCVPRUNED = 6,\n\tLINUX_MIB_OFOPRUNED = 7,\n\tLINUX_MIB_OUTOFWINDOWICMPS = 8,\n\tLINUX_MIB_LOCKDROPPEDICMPS = 9,\n\tLINUX_MIB_ARPFILTER = 10,\n\tLINUX_MIB_TIMEWAITED = 11,\n\tLINUX_MIB_TIMEWAITRECYCLED = 12,\n\tLINUX_MIB_TIMEWAITKILLED = 13,\n\tLINUX_MIB_PAWSACTIVEREJECTED = 14,\n\tLINUX_MIB_PAWSESTABREJECTED = 15,\n\tLINUX_MIB_DELAYEDACKS = 16,\n\tLINUX_MIB_DELAYEDACKLOCKED = 17,\n\tLINUX_MIB_DELAYEDACKLOST = 18,\n\tLINUX_MIB_LISTENOVERFLOWS = 19,\n\tLINUX_MIB_LISTENDROPS = 20,\n\tLINUX_MIB_TCPHPHITS = 21,\n\tLINUX_MIB_TCPPUREACKS = 22,\n\tLINUX_MIB_TCPHPACKS = 23,\n\tLINUX_MIB_TCPRENORECOVERY = 24,\n\tLINUX_MIB_TCPSACKRECOVERY = 25,\n\tLINUX_MIB_TCPSACKRENEGING = 26,\n\tLINUX_MIB_TCPSACKREORDER = 27,\n\tLINUX_MIB_TCPRENOREORDER = 28,\n\tLINUX_MIB_TCPTSREORDER = 29,\n\tLINUX_MIB_TCPFULLUNDO = 30,\n\tLINUX_MIB_TCPPARTIALUNDO = 31,\n\tLINUX_MIB_TCPDSACKUNDO = 32,\n\tLINUX_MIB_TCPLOSSUNDO = 33,\n\tLINUX_MIB_TCPLOSTRETRANSMIT = 34,\n\tLINUX_MIB_TCPRENOFAILURES = 35,\n\tLINUX_MIB_TCPSACKFAILURES = 36,\n\tLINUX_MIB_TCPLOSSFAILURES = 37,\n\tLINUX_MIB_TCPFASTRETRANS = 38,\n\tLINUX_MIB_TCPSLOWSTARTRETRANS = 39,\n\tLINUX_MIB_TCPTIMEOUTS = 40,\n\tLINUX_MIB_TCPLOSSPROBES = 41,\n\tLINUX_MIB_TCPLOSSPROBERECOVERY = 42,\n\tLINUX_MIB_TCPRENORECOVERYFAIL = 43,\n\tLINUX_MIB_TCPSACKRECOVERYFAIL = 44,\n\tLINUX_MIB_TCPRCVCOLLAPSED = 45,\n\tLINUX_MIB_TCPDSACKOLDSENT = 46,\n\tLINUX_MIB_TCPDSACKOFOSENT = 47,\n\tLINUX_MIB_TCPDSACKRECV = 48,\n\tLINUX_MIB_TCPDSACKOFORECV = 49,\n\tLINUX_MIB_TCPABORTONDATA = 50,\n\tLINUX_MIB_TCPABORTONCLOSE = 51,\n\tLINUX_MIB_TCPABORTONMEMORY = 52,\n\tLINUX_MIB_TCPABORTONTIMEOUT = 53,\n\tLINUX_MIB_TCPABORTONLINGER = 54,\n\tLINUX_MIB_TCPABORTFAILED = 55,\n\tLINUX_MIB_TCPMEMORYPRESSURES = 56,\n\tLINUX_MIB_TCPMEMORYPRESSURESCHRONO = 57,\n\tLINUX_MIB_TCPSACKDISCARD = 58,\n\tLINUX_MIB_TCPDSACKIGNOREDOLD = 59,\n\tLINUX_MIB_TCPDSACKIGNOREDNOUNDO = 60,\n\tLINUX_MIB_TCPSPURIOUSRTOS = 61,\n\tLINUX_MIB_TCPMD5NOTFOUND = 62,\n\tLINUX_MIB_TCPMD5UNEXPECTED = 63,\n\tLINUX_MIB_TCPMD5FAILURE = 64,\n\tLINUX_MIB_SACKSHIFTED = 65,\n\tLINUX_MIB_SACKMERGED = 66,\n\tLINUX_MIB_SACKSHIFTFALLBACK = 67,\n\tLINUX_MIB_TCPBACKLOGDROP = 68,\n\tLINUX_MIB_PFMEMALLOCDROP = 69,\n\tLINUX_MIB_TCPMINTTLDROP = 70,\n\tLINUX_MIB_TCPDEFERACCEPTDROP = 71,\n\tLINUX_MIB_IPRPFILTER = 72,\n\tLINUX_MIB_TCPTIMEWAITOVERFLOW = 73,\n\tLINUX_MIB_TCPREQQFULLDOCOOKIES = 74,\n\tLINUX_MIB_TCPREQQFULLDROP = 75,\n\tLINUX_MIB_TCPRETRANSFAIL = 76,\n\tLINUX_MIB_TCPRCVCOALESCE = 77,\n\tLINUX_MIB_TCPBACKLOGCOALESCE = 78,\n\tLINUX_MIB_TCPOFOQUEUE = 79,\n\tLINUX_MIB_TCPOFODROP = 80,\n\tLINUX_MIB_TCPOFOMERGE = 81,\n\tLINUX_MIB_TCPCHALLENGEACK = 82,\n\tLINUX_MIB_TCPSYNCHALLENGE = 83,\n\tLINUX_MIB_TCPFASTOPENACTIVE = 84,\n\tLINUX_MIB_TCPFASTOPENACTIVEFAIL = 85,\n\tLINUX_MIB_TCPFASTOPENPASSIVE = 86,\n\tLINUX_MIB_TCPFASTOPENPASSIVEFAIL = 87,\n\tLINUX_MIB_TCPFASTOPENLISTENOVERFLOW = 88,\n\tLINUX_MIB_TCPFASTOPENCOOKIEREQD = 89,\n\tLINUX_MIB_TCPFASTOPENBLACKHOLE = 90,\n\tLINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES = 91,\n\tLINUX_MIB_BUSYPOLLRXPACKETS = 92,\n\tLINUX_MIB_TCPAUTOCORKING = 93,\n\tLINUX_MIB_TCPFROMZEROWINDOWADV = 94,\n\tLINUX_MIB_TCPTOZEROWINDOWADV = 95,\n\tLINUX_MIB_TCPWANTZEROWINDOWADV = 96,\n\tLINUX_MIB_TCPSYNRETRANS = 97,\n\tLINUX_MIB_TCPORIGDATASENT = 98,\n\tLINUX_MIB_TCPHYSTARTTRAINDETECT = 99,\n\tLINUX_MIB_TCPHYSTARTTRAINCWND = 100,\n\tLINUX_MIB_TCPHYSTARTDELAYDETECT = 101,\n\tLINUX_MIB_TCPHYSTARTDELAYCWND = 102,\n\tLINUX_MIB_TCPACKSKIPPEDSYNRECV = 103,\n\tLINUX_MIB_TCPACKSKIPPEDPAWS = 104,\n\tLINUX_MIB_TCPACKSKIPPEDSEQ = 105,\n\tLINUX_MIB_TCPACKSKIPPEDFINWAIT2 = 106,\n\tLINUX_MIB_TCPACKSKIPPEDTIMEWAIT = 107,\n\tLINUX_MIB_TCPACKSKIPPEDCHALLENGE = 108,\n\tLINUX_MIB_TCPWINPROBE = 109,\n\tLINUX_MIB_TCPKEEPALIVE = 110,\n\tLINUX_MIB_TCPMTUPFAIL = 111,\n\tLINUX_MIB_TCPMTUPSUCCESS = 112,\n\tLINUX_MIB_TCPDELIVERED = 113,\n\tLINUX_MIB_TCPDELIVEREDCE = 114,\n\tLINUX_MIB_TCPACKCOMPRESSED = 115,\n\tLINUX_MIB_TCPZEROWINDOWDROP = 116,\n\tLINUX_MIB_TCPRCVQDROP = 117,\n\tLINUX_MIB_TCPWQUEUETOOBIG = 118,\n\tLINUX_MIB_TCPFASTOPENPASSIVEALTKEY = 119,\n\tLINUX_MIB_TCPTIMEOUTREHASH = 120,\n\tLINUX_MIB_TCPDUPLICATEDATAREHASH = 121,\n\tLINUX_MIB_TCPDSACKRECVSEGS = 122,\n\tLINUX_MIB_TCPDSACKIGNOREDDUBIOUS = 123,\n\tLINUX_MIB_TCPMIGRATEREQSUCCESS = 124,\n\tLINUX_MIB_TCPMIGRATEREQFAILURE = 125,\n\t__LINUX_MIB_MAX = 126,\n};\n\nenum {\n\tLINUX_MIB_XFRMNUM = 0,\n\tLINUX_MIB_XFRMINERROR = 1,\n\tLINUX_MIB_XFRMINBUFFERERROR = 2,\n\tLINUX_MIB_XFRMINHDRERROR = 3,\n\tLINUX_MIB_XFRMINNOSTATES = 4,\n\tLINUX_MIB_XFRMINSTATEPROTOERROR = 5,\n\tLINUX_MIB_XFRMINSTATEMODEERROR = 6,\n\tLINUX_MIB_XFRMINSTATESEQERROR = 7,\n\tLINUX_MIB_XFRMINSTATEEXPIRED = 8,\n\tLINUX_MIB_XFRMINSTATEMISMATCH = 9,\n\tLINUX_MIB_XFRMINSTATEINVALID = 10,\n\tLINUX_MIB_XFRMINTMPLMISMATCH = 11,\n\tLINUX_MIB_XFRMINNOPOLS = 12,\n\tLINUX_MIB_XFRMINPOLBLOCK = 13,\n\tLINUX_MIB_XFRMINPOLERROR = 14,\n\tLINUX_MIB_XFRMOUTERROR = 15,\n\tLINUX_MIB_XFRMOUTBUNDLEGENERROR = 16,\n\tLINUX_MIB_XFRMOUTBUNDLECHECKERROR = 17,\n\tLINUX_MIB_XFRMOUTNOSTATES = 18,\n\tLINUX_MIB_XFRMOUTSTATEPROTOERROR = 19,\n\tLINUX_MIB_XFRMOUTSTATEMODEERROR = 20,\n\tLINUX_MIB_XFRMOUTSTATESEQERROR = 21,\n\tLINUX_MIB_XFRMOUTSTATEEXPIRED = 22,\n\tLINUX_MIB_XFRMOUTPOLBLOCK = 23,\n\tLINUX_MIB_XFRMOUTPOLDEAD = 24,\n\tLINUX_MIB_XFRMOUTPOLERROR = 25,\n\tLINUX_MIB_XFRMFWDHDRERROR = 26,\n\tLINUX_MIB_XFRMOUTSTATEINVALID = 27,\n\tLINUX_MIB_XFRMACQUIREERROR = 28,\n\t__LINUX_MIB_XFRMMAX = 29,\n};\n\nenum {\n\tLINUX_MIB_TLSNUM = 0,\n\tLINUX_MIB_TLSCURRTXSW = 1,\n\tLINUX_MIB_TLSCURRRXSW = 2,\n\tLINUX_MIB_TLSCURRTXDEVICE = 3,\n\tLINUX_MIB_TLSCURRRXDEVICE = 4,\n\tLINUX_MIB_TLSTXSW = 5,\n\tLINUX_MIB_TLSRXSW = 6,\n\tLINUX_MIB_TLSTXDEVICE = 7,\n\tLINUX_MIB_TLSRXDEVICE = 8,\n\tLINUX_MIB_TLSDECRYPTERROR = 9,\n\tLINUX_MIB_TLSRXDEVICERESYNC = 10,\n\t__LINUX_MIB_TLSMAX = 11,\n};\n\nstruct ipstats_mib {\n\tu64 mibs[37];\n\tstruct u64_stats_sync syncp;\n};\n\nstruct icmp_mib {\n\tlong unsigned int mibs[28];\n};\n\nstruct icmpmsg_mib {\n\tatomic_long_t mibs[512];\n};\n\nstruct icmpv6_mib {\n\tlong unsigned int mibs[6];\n};\n\nstruct icmpv6msg_mib {\n\tatomic_long_t mibs[512];\n};\n\nstruct tcp_mib {\n\tlong unsigned int mibs[16];\n};\n\nstruct udp_mib {\n\tlong unsigned int mibs[10];\n};\n\nstruct linux_mib {\n\tlong unsigned int mibs[126];\n};\n\nstruct linux_xfrm_mib {\n\tlong unsigned int mibs[29];\n};\n\nstruct linux_tls_mib {\n\tlong unsigned int mibs[11];\n};\n\nstruct inet_frags;\n\nstruct fqdir {\n\tlong int high_thresh;\n\tlong int low_thresh;\n\tint timeout;\n\tint max_dist;\n\tstruct inet_frags *f;\n\tstruct net *net;\n\tbool dead;\n\tlong: 56;\n\tlong: 64;\n\tlong: 64;\n\tstruct rhashtable rhashtable;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tatomic_long_t mem;\n\tstruct work_struct destroy_work;\n\tstruct llist_node free_list;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct inet_frag_queue;\n\nstruct inet_frags {\n\tunsigned int qsize;\n\tvoid (*constructor)(struct inet_frag_queue *, const void *);\n\tvoid (*destructor)(struct inet_frag_queue *);\n\tvoid (*frag_expire)(struct timer_list *);\n\tstruct kmem_cache *frags_cachep;\n\tconst char *frags_cache_name;\n\tstruct rhashtable_params rhash_params;\n\trefcount_t refcnt;\n\tstruct completion completion;\n};\n\nstruct frag_v4_compare_key {\n\t__be32 saddr;\n\t__be32 daddr;\n\tu32 user;\n\tu32 vif;\n\t__be16 id;\n\tu16 protocol;\n};\n\nstruct frag_v6_compare_key {\n\tstruct in6_addr saddr;\n\tstruct in6_addr daddr;\n\tu32 user;\n\t__be32 id;\n\tu32 iif;\n};\n\nstruct inet_frag_queue {\n\tstruct rhash_head node;\n\tunion {\n\t\tstruct frag_v4_compare_key v4;\n\t\tstruct frag_v6_compare_key v6;\n\t} key;\n\tstruct timer_list timer;\n\tspinlock_t lock;\n\trefcount_t refcnt;\n\tstruct rb_root rb_fragments;\n\tstruct sk_buff *fragments_tail;\n\tstruct sk_buff *last_run_head;\n\tktime_t stamp;\n\tint len;\n\tint meat;\n\t__u8 flags;\n\tu16 max_size;\n\tstruct fqdir *fqdir;\n\tstruct callback_head rcu;\n};\n\nenum tcp_ca_event {\n\tCA_EVENT_TX_START = 0,\n\tCA_EVENT_CWND_RESTART = 1,\n\tCA_EVENT_COMPLETE_CWR = 2,\n\tCA_EVENT_LOSS = 3,\n\tCA_EVENT_ECN_NO_CE = 4,\n\tCA_EVENT_ECN_IS_CE = 5,\n};\n\nstruct ack_sample;\n\nstruct rate_sample;\n\nunion tcp_cc_info;\n\nstruct tcp_congestion_ops {\n\tu32 (*ssthresh)(struct sock *);\n\tvoid (*cong_avoid)(struct sock *, u32, u32);\n\tvoid (*set_state)(struct sock *, u8);\n\tvoid (*cwnd_event)(struct sock *, enum tcp_ca_event);\n\tvoid (*in_ack_event)(struct sock *, u32);\n\tvoid (*pkts_acked)(struct sock *, const struct ack_sample *);\n\tu32 (*min_tso_segs)(struct sock *);\n\tvoid (*cong_control)(struct sock *, const struct rate_sample *);\n\tu32 (*undo_cwnd)(struct sock *);\n\tu32 (*sndbuf_expand)(struct sock *);\n\tsize_t (*get_info)(struct sock *, u32, int *, union tcp_cc_info *);\n\tchar name[16];\n\tstruct module *owner;\n\tstruct list_head list;\n\tu32 key;\n\tu32 flags;\n\tvoid (*init)(struct sock *);\n\tvoid (*release)(struct sock *);\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct xfrm_state;\n\nstruct lwtunnel_state;\n\nstruct dst_entry {\n\tstruct net_device *dev;\n\tstruct dst_ops *ops;\n\tlong unsigned int _metrics;\n\tlong unsigned int expires;\n\tstruct xfrm_state *xfrm;\n\tint (*input)(struct sk_buff *);\n\tint (*output)(struct net *, struct sock *, struct sk_buff *);\n\tshort unsigned int flags;\n\tshort int obsolete;\n\tshort unsigned int header_len;\n\tshort unsigned int trailer_len;\n\tatomic_t __refcnt;\n\tint __use;\n\tlong unsigned int lastuse;\n\tstruct lwtunnel_state *lwtstate;\n\tstruct callback_head callback_head;\n\tshort int error;\n\tshort int __pad;\n\t__u32 tclassid;\n};\n\nenum nf_inet_hooks {\n\tNF_INET_PRE_ROUTING = 0,\n\tNF_INET_LOCAL_IN = 1,\n\tNF_INET_FORWARD = 2,\n\tNF_INET_LOCAL_OUT = 3,\n\tNF_INET_POST_ROUTING = 4,\n\tNF_INET_NUMHOOKS = 5,\n\tNF_INET_INGRESS = 5,\n};\n\nenum {\n\tNFPROTO_UNSPEC = 0,\n\tNFPROTO_INET = 1,\n\tNFPROTO_IPV4 = 2,\n\tNFPROTO_ARP = 3,\n\tNFPROTO_NETDEV = 5,\n\tNFPROTO_BRIDGE = 7,\n\tNFPROTO_IPV6 = 10,\n\tNFPROTO_DECNET = 12,\n\tNFPROTO_NUMPROTO = 13,\n};\n\nenum nf_log_type {\n\tNF_LOG_TYPE_LOG = 0,\n\tNF_LOG_TYPE_ULOG = 1,\n\tNF_LOG_TYPE_MAX = 2,\n};\n\ntypedef u8 u_int8_t;\n\nstruct nf_loginfo;\n\ntypedef void nf_logfn(struct net *, u_int8_t, unsigned int, const struct sk_buff *, const struct net_device *, const struct net_device *, const struct nf_loginfo *, const char *);\n\nstruct nf_logger {\n\tchar *name;\n\tenum nf_log_type type;\n\tnf_logfn *logfn;\n\tstruct module *me;\n};\n\nstruct hlist_nulls_node;\n\nstruct hlist_nulls_head {\n\tstruct hlist_nulls_node *first;\n};\n\nstruct hlist_nulls_node {\n\tstruct hlist_nulls_node *next;\n\tstruct hlist_nulls_node **pprev;\n};\n\nenum tcp_conntrack {\n\tTCP_CONNTRACK_NONE = 0,\n\tTCP_CONNTRACK_SYN_SENT = 1,\n\tTCP_CONNTRACK_SYN_RECV = 2,\n\tTCP_CONNTRACK_ESTABLISHED = 3,\n\tTCP_CONNTRACK_FIN_WAIT = 4,\n\tTCP_CONNTRACK_CLOSE_WAIT = 5,\n\tTCP_CONNTRACK_LAST_ACK = 6,\n\tTCP_CONNTRACK_TIME_WAIT = 7,\n\tTCP_CONNTRACK_CLOSE = 8,\n\tTCP_CONNTRACK_LISTEN = 9,\n\tTCP_CONNTRACK_MAX = 10,\n\tTCP_CONNTRACK_IGNORE = 11,\n\tTCP_CONNTRACK_RETRANS = 12,\n\tTCP_CONNTRACK_UNACK = 13,\n\tTCP_CONNTRACK_TIMEOUT_MAX = 14,\n};\n\nenum ct_dccp_states {\n\tCT_DCCP_NONE = 0,\n\tCT_DCCP_REQUEST = 1,\n\tCT_DCCP_RESPOND = 2,\n\tCT_DCCP_PARTOPEN = 3,\n\tCT_DCCP_OPEN = 4,\n\tCT_DCCP_CLOSEREQ = 5,\n\tCT_DCCP_CLOSING = 6,\n\tCT_DCCP_TIMEWAIT = 7,\n\tCT_DCCP_IGNORE = 8,\n\tCT_DCCP_INVALID = 9,\n\t__CT_DCCP_MAX = 10,\n};\n\nstruct ip_conntrack_stat {\n\tunsigned int found;\n\tunsigned int invalid;\n\tunsigned int insert;\n\tunsigned int insert_failed;\n\tunsigned int clash_resolve;\n\tunsigned int drop;\n\tunsigned int early_drop;\n\tunsigned int error;\n\tunsigned int expect_new;\n\tunsigned int expect_create;\n\tunsigned int expect_delete;\n\tunsigned int search_restart;\n\tunsigned int chaintoolong;\n};\n\nenum ip_conntrack_dir {\n\tIP_CT_DIR_ORIGINAL = 0,\n\tIP_CT_DIR_REPLY = 1,\n\tIP_CT_DIR_MAX = 2,\n};\n\nenum sctp_conntrack {\n\tSCTP_CONNTRACK_NONE = 0,\n\tSCTP_CONNTRACK_CLOSED = 1,\n\tSCTP_CONNTRACK_COOKIE_WAIT = 2,\n\tSCTP_CONNTRACK_COOKIE_ECHOED = 3,\n\tSCTP_CONNTRACK_ESTABLISHED = 4,\n\tSCTP_CONNTRACK_SHUTDOWN_SENT = 5,\n\tSCTP_CONNTRACK_SHUTDOWN_RECD = 6,\n\tSCTP_CONNTRACK_SHUTDOWN_ACK_SENT = 7,\n\tSCTP_CONNTRACK_HEARTBEAT_SENT = 8,\n\tSCTP_CONNTRACK_HEARTBEAT_ACKED = 9,\n\tSCTP_CONNTRACK_MAX = 10,\n};\n\nenum udp_conntrack {\n\tUDP_CT_UNREPLIED = 0,\n\tUDP_CT_REPLIED = 1,\n\tUDP_CT_MAX = 2,\n};\n\nenum gre_conntrack {\n\tGRE_CT_UNREPLIED = 0,\n\tGRE_CT_REPLIED = 1,\n\tGRE_CT_MAX = 2,\n};\n\nstruct ct_pcpu {\n\tspinlock_t lock;\n\tstruct hlist_nulls_head unconfirmed;\n\tstruct hlist_nulls_head dying;\n};\n\nenum {\n\tXFRM_POLICY_IN = 0,\n\tXFRM_POLICY_OUT = 1,\n\tXFRM_POLICY_FWD = 2,\n\tXFRM_POLICY_MASK = 3,\n\tXFRM_POLICY_MAX = 3,\n};\n\nenum netns_bpf_attach_type {\n\tNETNS_BPF_INVALID = 4294967295,\n\tNETNS_BPF_FLOW_DISSECTOR = 0,\n\tNETNS_BPF_SK_LOOKUP = 1,\n\tMAX_NETNS_BPF_ATTACH_TYPE = 2,\n};\n\nstruct pipe_buf_operations;\n\nstruct pipe_buffer {\n\tstruct page *page;\n\tunsigned int offset;\n\tunsigned int len;\n\tconst struct pipe_buf_operations *ops;\n\tunsigned int flags;\n\tlong unsigned int private;\n};\n\nstruct pipe_buf_operations {\n\tint (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);\n\tvoid (*release)(struct pipe_inode_info *, struct pipe_buffer *);\n\tbool (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);\n\tbool (*get)(struct pipe_inode_info *, struct pipe_buffer *);\n};\n\nstruct skb_ext {\n\trefcount_t refcnt;\n\tu8 offset[4];\n\tu8 chunks;\n\tlong: 56;\n\tchar data[0];\n};\n\nenum skb_ext_id {\n\tSKB_EXT_BRIDGE_NF = 0,\n\tSKB_EXT_SEC_PATH = 1,\n\tTC_SKB_EXT = 2,\n\tSKB_EXT_MPTCP = 3,\n\tSKB_EXT_NUM = 4,\n};\n\nstruct trace_event_raw_initcall_level {\n\tstruct trace_entry ent;\n\tu32 __data_loc_level;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_initcall_start {\n\tstruct trace_entry ent;\n\tinitcall_t func;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_initcall_finish {\n\tstruct trace_entry ent;\n\tinitcall_t func;\n\tint ret;\n\tchar __data[0];\n};\n\nstruct trace_event_data_offsets_initcall_level {\n\tu32 level;\n};\n\nstruct trace_event_data_offsets_initcall_start {};\n\nstruct trace_event_data_offsets_initcall_finish {};\n\ntypedef void (*btf_trace_initcall_level)(void *, const char *);\n\ntypedef void (*btf_trace_initcall_start)(void *, initcall_t);\n\ntypedef void (*btf_trace_initcall_finish)(void *, initcall_t, int);\n\nstruct blacklist_entry {\n\tstruct list_head next;\n\tchar *buf;\n};\n\ntypedef __u32 Elf32_Word;\n\nstruct elf32_note {\n\tElf32_Word n_namesz;\n\tElf32_Word n_descsz;\n\tElf32_Word n_type;\n};\n\nenum {\n\tPROC_ROOT_INO = 1,\n\tPROC_IPC_INIT_INO = 4026531839,\n\tPROC_UTS_INIT_INO = 4026531838,\n\tPROC_USER_INIT_INO = 4026531837,\n\tPROC_PID_INIT_INO = 4026531836,\n\tPROC_CGROUP_INIT_INO = 4026531835,\n\tPROC_TIME_INIT_INO = 4026531834,\n};\n\ntypedef __u16 __le16;\n\ntypedef __u64 __be64;\n\ntypedef unsigned int slab_flags_t;\n\ntypedef __u64 __addrpair;\n\ntypedef __u32 __portpair;\n\ntypedef struct {\n\tstruct net *net;\n} possible_net_t;\n\nstruct proto;\n\nstruct sock_common {\n\tunion {\n\t\t__addrpair skc_addrpair;\n\t\tstruct {\n\t\t\t__be32 skc_daddr;\n\t\t\t__be32 skc_rcv_saddr;\n\t\t};\n\t};\n\tunion {\n\t\tunsigned int skc_hash;\n\t\t__u16 skc_u16hashes[2];\n\t};\n\tunion {\n\t\t__portpair skc_portpair;\n\t\tstruct {\n\t\t\t__be16 skc_dport;\n\t\t\t__u16 skc_num;\n\t\t};\n\t};\n\tshort unsigned int skc_family;\n\tvolatile unsigned char skc_state;\n\tunsigned char skc_reuse: 4;\n\tunsigned char skc_reuseport: 1;\n\tunsigned char skc_ipv6only: 1;\n\tunsigned char skc_net_refcnt: 1;\n\tint skc_bound_dev_if;\n\tunion {\n\t\tstruct hlist_node skc_bind_node;\n\t\tstruct hlist_node skc_portaddr_node;\n\t};\n\tstruct proto *skc_prot;\n\tpossible_net_t skc_net;\n\tstruct in6_addr skc_v6_daddr;\n\tstruct in6_addr skc_v6_rcv_saddr;\n\tatomic64_t skc_cookie;\n\tunion {\n\t\tlong unsigned int skc_flags;\n\t\tstruct sock *skc_listener;\n\t\tstruct inet_timewait_death_row *skc_tw_dr;\n\t};\n\tint skc_dontcopy_begin[0];\n\tunion {\n\t\tstruct hlist_node skc_node;\n\t\tstruct hlist_nulls_node skc_nulls_node;\n\t};\n\tshort unsigned int skc_tx_queue_mapping;\n\tshort unsigned int skc_rx_queue_mapping;\n\tunion {\n\t\tint skc_incoming_cpu;\n\t\tu32 skc_rcv_wnd;\n\t\tu32 skc_tw_rcv_nxt;\n\t};\n\trefcount_t skc_refcnt;\n\tint skc_dontcopy_end[0];\n\tunion {\n\t\tu32 skc_rxhash;\n\t\tu32 skc_window_clamp;\n\t\tu32 skc_tw_snd_nxt;\n\t};\n};\n\ntypedef struct {\n\tspinlock_t slock;\n\tint owned;\n\twait_queue_head_t wq;\n} socket_lock_t;\n\ntypedef u64 netdev_features_t;\n\nstruct sock_cgroup_data {\n\tstruct cgroup *cgroup;\n\tu32 classid;\n\tu16 prioidx;\n};\n\nstruct sk_filter;\n\nstruct socket_wq;\n\nstruct xfrm_policy;\n\nstruct socket;\n\nstruct sock_reuseport;\n\nstruct sock {\n\tstruct sock_common __sk_common;\n\tsocket_lock_t sk_lock;\n\tatomic_t sk_drops;\n\tint sk_rcvlowat;\n\tstruct sk_buff_head sk_error_queue;\n\tstruct sk_buff *sk_rx_skb_cache;\n\tstruct sk_buff_head sk_receive_queue;\n\tstruct {\n\t\tatomic_t rmem_alloc;\n\t\tint len;\n\t\tstruct sk_buff *head;\n\t\tstruct sk_buff *tail;\n\t} sk_backlog;\n\tint sk_forward_alloc;\n\tunsigned int sk_ll_usec;\n\tunsigned int sk_napi_id;\n\tint sk_rcvbuf;\n\tstruct sk_filter *sk_filter;\n\tunion {\n\t\tstruct socket_wq *sk_wq;\n\t\tstruct socket_wq *sk_wq_raw;\n\t};\n\tstruct xfrm_policy *sk_policy[2];\n\tstruct dst_entry *sk_rx_dst;\n\tint sk_rx_dst_ifindex;\n\tu32 sk_rx_dst_cookie;\n\tstruct dst_entry *sk_dst_cache;\n\tatomic_t sk_omem_alloc;\n\tint sk_sndbuf;\n\tint sk_wmem_queued;\n\trefcount_t sk_wmem_alloc;\n\tlong unsigned int sk_tsq_flags;\n\tunion {\n\t\tstruct sk_buff *sk_send_head;\n\t\tstruct rb_root tcp_rtx_queue;\n\t};\n\tstruct sk_buff *sk_tx_skb_cache;\n\tstruct sk_buff_head sk_write_queue;\n\t__s32 sk_peek_off;\n\tint sk_write_pending;\n\t__u32 sk_dst_pending_confirm;\n\tu32 sk_pacing_status;\n\tlong int sk_sndtimeo;\n\tstruct timer_list sk_timer;\n\t__u32 sk_priority;\n\t__u32 sk_mark;\n\tlong unsigned int sk_pacing_rate;\n\tlong unsigned int sk_max_pacing_rate;\n\tstruct page_frag sk_frag;\n\tnetdev_features_t sk_route_caps;\n\tnetdev_features_t sk_route_nocaps;\n\tnetdev_features_t sk_route_forced_caps;\n\tint sk_gso_type;\n\tunsigned int sk_gso_max_size;\n\tgfp_t sk_allocation;\n\t__u32 sk_txhash;\n\tu8 sk_padding: 1;\n\tu8 sk_kern_sock: 1;\n\tu8 sk_no_check_tx: 1;\n\tu8 sk_no_check_rx: 1;\n\tu8 sk_userlocks: 4;\n\tu8 sk_pacing_shift;\n\tu16 sk_type;\n\tu16 sk_protocol;\n\tu16 sk_gso_max_segs;\n\tlong unsigned int sk_lingertime;\n\tstruct proto *sk_prot_creator;\n\trwlock_t sk_callback_lock;\n\tint sk_err;\n\tint sk_err_soft;\n\tu32 sk_ack_backlog;\n\tu32 sk_max_ack_backlog;\n\tkuid_t sk_uid;\n\tu8 sk_prefer_busy_poll;\n\tu16 sk_busy_poll_budget;\n\tspinlock_t sk_peer_lock;\n\tstruct pid *sk_peer_pid;\n\tconst struct cred *sk_peer_cred;\n\tlong int sk_rcvtimeo;\n\tktime_t sk_stamp;\n\tu16 sk_tsflags;\n\tint sk_bind_phc;\n\tu8 sk_shutdown;\n\tatomic_t sk_tskey;\n\tatomic_t sk_zckey;\n\tu8 sk_clockid;\n\tu8 sk_txtime_deadline_mode: 1;\n\tu8 sk_txtime_report_errors: 1;\n\tu8 sk_txtime_unused: 6;\n\tstruct socket *sk_socket;\n\tvoid *sk_user_data;\n\tvoid *sk_security;\n\tstruct sock_cgroup_data sk_cgrp_data;\n\tstruct mem_cgroup *sk_memcg;\n\tvoid (*sk_state_change)(struct sock *);\n\tvoid (*sk_data_ready)(struct sock *);\n\tvoid (*sk_write_space)(struct sock *);\n\tvoid (*sk_error_report)(struct sock *);\n\tint (*sk_backlog_rcv)(struct sock *, struct sk_buff *);\n\tstruct sk_buff * (*sk_validate_xmit_skb)(struct sock *, struct net_device *, struct sk_buff *);\n\tvoid (*sk_destruct)(struct sock *);\n\tstruct sock_reuseport *sk_reuseport_cb;\n\tstruct bpf_local_storage *sk_bpf_storage;\n\tstruct callback_head sk_rcu;\n};\n\nstruct fs_struct {\n\tint users;\n\tspinlock_t lock;\n\tseqcount_spinlock_t seq;\n\tint umask;\n\tint in_exec;\n\tstruct path root;\n\tstruct path pwd;\n};\n\ntypedef short unsigned int __kernel_sa_family_t;\n\ntypedef __kernel_sa_family_t sa_family_t;\n\nstruct sockaddr {\n\tsa_family_t sa_family;\n\tchar sa_data[14];\n};\n\nstruct msghdr {\n\tvoid *msg_name;\n\tint msg_namelen;\n\tstruct iov_iter msg_iter;\n\tunion {\n\t\tvoid *msg_control;\n\t\tvoid *msg_control_user;\n\t};\n\tbool msg_control_is_user: 1;\n\t__kernel_size_t msg_controllen;\n\tunsigned int msg_flags;\n\tstruct kiocb *msg_iocb;\n};\n\ntypedef struct {\n\tunsigned int clock_rate;\n\tunsigned int clock_type;\n\tshort unsigned int loopback;\n} sync_serial_settings;\n\ntypedef struct {\n\tunsigned int clock_rate;\n\tunsigned int clock_type;\n\tshort unsigned int loopback;\n\tunsigned int slot_map;\n} te1_settings;\n\ntypedef struct {\n\tshort unsigned int encoding;\n\tshort unsigned int parity;\n} raw_hdlc_proto;\n\ntypedef struct {\n\tunsigned int t391;\n\tunsigned int t392;\n\tunsigned int n391;\n\tunsigned int n392;\n\tunsigned int n393;\n\tshort unsigned int lmi;\n\tshort unsigned int dce;\n} fr_proto;\n\ntypedef struct {\n\tunsigned int dlci;\n} fr_proto_pvc;\n\ntypedef struct {\n\tunsigned int dlci;\n\tchar master[16];\n} fr_proto_pvc_info;\n\ntypedef struct {\n\tunsigned int interval;\n\tunsigned int timeout;\n} cisco_proto;\n\ntypedef struct {\n\tshort unsigned int dce;\n\tunsigned int modulo;\n\tunsigned int window;\n\tunsigned int t1;\n\tunsigned int t2;\n\tunsigned int n2;\n} x25_hdlc_proto;\n\nstruct ifmap {\n\tlong unsigned int mem_start;\n\tlong unsigned int mem_end;\n\tshort unsigned int base_addr;\n\tunsigned char irq;\n\tunsigned char dma;\n\tunsigned char port;\n};\n\nstruct if_settings {\n\tunsigned int type;\n\tunsigned int size;\n\tunion {\n\t\traw_hdlc_proto *raw_hdlc;\n\t\tcisco_proto *cisco;\n\t\tfr_proto *fr;\n\t\tfr_proto_pvc *fr_pvc;\n\t\tfr_proto_pvc_info *fr_pvc_info;\n\t\tx25_hdlc_proto *x25;\n\t\tsync_serial_settings *sync;\n\t\tte1_settings *te1;\n\t} ifs_ifsu;\n};\n\nstruct ifreq {\n\tunion {\n\t\tchar ifrn_name[16];\n\t} ifr_ifrn;\n\tunion {\n\t\tstruct sockaddr ifru_addr;\n\t\tstruct sockaddr ifru_dstaddr;\n\t\tstruct sockaddr ifru_broadaddr;\n\t\tstruct sockaddr ifru_netmask;\n\t\tstruct sockaddr ifru_hwaddr;\n\t\tshort int ifru_flags;\n\t\tint ifru_ivalue;\n\t\tint ifru_mtu;\n\t\tstruct ifmap ifru_map;\n\t\tchar ifru_slave[16];\n\t\tchar ifru_newname[16];\n\t\tvoid *ifru_data;\n\t\tstruct if_settings ifru_settings;\n\t} ifr_ifru;\n};\n\nstruct ld_semaphore {\n\tatomic_long_t count;\n\traw_spinlock_t wait_lock;\n\tunsigned int wait_readers;\n\tstruct list_head read_wait;\n\tstruct list_head write_wait;\n};\n\ntypedef unsigned int tcflag_t;\n\ntypedef unsigned char cc_t;\n\ntypedef unsigned int speed_t;\n\nstruct ktermios {\n\ttcflag_t c_iflag;\n\ttcflag_t c_oflag;\n\ttcflag_t c_cflag;\n\ttcflag_t c_lflag;\n\tcc_t c_line;\n\tcc_t c_cc[19];\n\tspeed_t c_ispeed;\n\tspeed_t c_ospeed;\n};\n\nstruct winsize {\n\tshort unsigned int ws_row;\n\tshort unsigned int ws_col;\n\tshort unsigned int ws_xpixel;\n\tshort unsigned int ws_ypixel;\n};\n\nstruct tty_driver;\n\nstruct tty_operations;\n\nstruct tty_ldisc;\n\nstruct tty_port;\n\nstruct tty_struct {\n\tint magic;\n\tstruct kref kref;\n\tstruct device *dev;\n\tstruct tty_driver *driver;\n\tconst struct tty_operations *ops;\n\tint index;\n\tstruct ld_semaphore ldisc_sem;\n\tstruct tty_ldisc *ldisc;\n\tstruct mutex atomic_write_lock;\n\tstruct mutex legacy_mutex;\n\tstruct mutex throttle_mutex;\n\tstruct rw_semaphore termios_rwsem;\n\tstruct mutex winsize_mutex;\n\tstruct ktermios termios;\n\tstruct ktermios termios_locked;\n\tchar name[64];\n\tlong unsigned int flags;\n\tint count;\n\tstruct winsize winsize;\n\tstruct {\n\t\tspinlock_t lock;\n\t\tbool stopped;\n\t\tbool tco_stopped;\n\t\tlong unsigned int unused[0];\n\t} flow;\n\tstruct {\n\t\tspinlock_t lock;\n\t\tstruct pid *pgrp;\n\t\tstruct pid *session;\n\t\tunsigned char pktstatus;\n\t\tbool packet;\n\t\tlong unsigned int unused[0];\n\t} ctrl;\n\tint hw_stopped;\n\tunsigned int receive_room;\n\tint flow_change;\n\tstruct tty_struct *link;\n\tstruct fasync_struct *fasync;\n\twait_queue_head_t write_wait;\n\twait_queue_head_t read_wait;\n\tstruct work_struct hangup_work;\n\tvoid *disc_data;\n\tvoid *driver_data;\n\tspinlock_t files_lock;\n\tstruct list_head tty_files;\n\tint closing;\n\tunsigned char *write_buf;\n\tint write_cnt;\n\tstruct work_struct SAK_work;\n\tstruct tty_port *port;\n};\n\ntypedef struct {\n\tsize_t written;\n\tsize_t count;\n\tunion {\n\t\tchar *buf;\n\t\tvoid *data;\n\t} arg;\n\tint error;\n} read_descriptor_t;\n\nstruct posix_acl_entry {\n\tshort int e_tag;\n\tshort unsigned int e_perm;\n\tunion {\n\t\tkuid_t e_uid;\n\t\tkgid_t e_gid;\n\t};\n};\n\nstruct posix_acl {\n\trefcount_t a_refcount;\n\tstruct callback_head a_rcu;\n\tunsigned int a_count;\n\tstruct posix_acl_entry a_entries[0];\n};\n\nstruct tty_buffer {\n\tunion {\n\t\tstruct tty_buffer *next;\n\t\tstruct llist_node free;\n\t};\n\tint used;\n\tint size;\n\tint commit;\n\tint read;\n\tint flags;\n\tlong unsigned int data[0];\n};\n\nstruct tty_bufhead {\n\tstruct tty_buffer *head;\n\tstruct work_struct work;\n\tstruct mutex lock;\n\tatomic_t priority;\n\tstruct tty_buffer sentinel;\n\tstruct llist_head free;\n\tatomic_t mem_used;\n\tint mem_limit;\n\tstruct tty_buffer *tail;\n};\n\nstruct serial_icounter_struct;\n\nstruct serial_struct;\n\nstruct tty_operations {\n\tstruct tty_struct * (*lookup)(struct tty_driver *, struct file *, int);\n\tint (*install)(struct tty_driver *, struct tty_struct *);\n\tvoid (*remove)(struct tty_driver *, struct tty_struct *);\n\tint (*open)(struct tty_struct *, struct file *);\n\tvoid (*close)(struct tty_struct *, struct file *);\n\tvoid (*shutdown)(struct tty_struct *);\n\tvoid (*cleanup)(struct tty_struct *);\n\tint (*write)(struct tty_struct *, const unsigned char *, int);\n\tint (*put_char)(struct tty_struct *, unsigned char);\n\tvoid (*flush_chars)(struct tty_struct *);\n\tunsigned int (*write_room)(struct tty_struct *);\n\tunsigned int (*chars_in_buffer)(struct tty_struct *);\n\tint (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);\n\tlong int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int);\n\tvoid (*set_termios)(struct tty_struct *, struct ktermios *);\n\tvoid (*throttle)(struct tty_struct *);\n\tvoid (*unthrottle)(struct tty_struct *);\n\tvoid (*stop)(struct tty_struct *);\n\tvoid (*start)(struct tty_struct *);\n\tvoid (*hangup)(struct tty_struct *);\n\tint (*break_ctl)(struct tty_struct *, int);\n\tvoid (*flush_buffer)(struct tty_struct *);\n\tvoid (*set_ldisc)(struct tty_struct *);\n\tvoid (*wait_until_sent)(struct tty_struct *, int);\n\tvoid (*send_xchar)(struct tty_struct *, char);\n\tint (*tiocmget)(struct tty_struct *);\n\tint (*tiocmset)(struct tty_struct *, unsigned int, unsigned int);\n\tint (*resize)(struct tty_struct *, struct winsize *);\n\tint (*get_icount)(struct tty_struct *, struct serial_icounter_struct *);\n\tint (*get_serial)(struct tty_struct *, struct serial_struct *);\n\tint (*set_serial)(struct tty_struct *, struct serial_struct *);\n\tvoid (*show_fdinfo)(struct tty_struct *, struct seq_file *);\n\tint (*poll_init)(struct tty_driver *, int, char *);\n\tint (*poll_get_char)(struct tty_driver *, int);\n\tvoid (*poll_put_char)(struct tty_driver *, int, char);\n\tint (*proc_show)(struct seq_file *, void *);\n};\n\nstruct tty_driver {\n\tint magic;\n\tstruct kref kref;\n\tstruct cdev **cdevs;\n\tstruct module *owner;\n\tconst char *driver_name;\n\tconst char *name;\n\tint name_base;\n\tint major;\n\tint minor_start;\n\tunsigned int num;\n\tshort int type;\n\tshort int subtype;\n\tstruct ktermios init_termios;\n\tlong unsigned int flags;\n\tstruct proc_dir_entry *proc_entry;\n\tstruct tty_driver *other;\n\tstruct tty_struct **ttys;\n\tstruct tty_port **ports;\n\tstruct ktermios **termios;\n\tvoid *driver_state;\n\tconst struct tty_operations *ops;\n\tstruct list_head tty_drivers;\n};\n\nstruct tty_port_operations;\n\nstruct tty_port_client_operations;\n\nstruct tty_port {\n\tstruct tty_bufhead buf;\n\tstruct tty_struct *tty;\n\tstruct tty_struct *itty;\n\tconst struct tty_port_operations *ops;\n\tconst struct tty_port_client_operations *client_ops;\n\tspinlock_t lock;\n\tint blocked_open;\n\tint count;\n\twait_queue_head_t open_wait;\n\twait_queue_head_t delta_msr_wait;\n\tlong unsigned int flags;\n\tlong unsigned int iflags;\n\tunsigned char console: 1;\n\tstruct mutex mutex;\n\tstruct mutex buf_mutex;\n\tunsigned char *xmit_buf;\n\tunsigned int close_delay;\n\tunsigned int closing_wait;\n\tint drain_delay;\n\tstruct kref kref;\n\tvoid *client_data;\n};\n\nstruct tty_ldisc_ops {\n\tchar *name;\n\tint num;\n\tint flags;\n\tint (*open)(struct tty_struct *);\n\tvoid (*close)(struct tty_struct *);\n\tvoid (*flush_buffer)(struct tty_struct *);\n\tssize_t (*read)(struct tty_struct *, struct file *, unsigned char *, size_t, void **, long unsigned int);\n\tssize_t (*write)(struct tty_struct *, struct file *, const unsigned char *, size_t);\n\tint (*ioctl)(struct tty_struct *, struct file *, unsigned int, long unsigned int);\n\tint (*compat_ioctl)(struct tty_struct *, struct file *, unsigned int, long unsigned int);\n\tvoid (*set_termios)(struct tty_struct *, struct ktermios *);\n\t__poll_t (*poll)(struct tty_struct *, struct file *, struct poll_table_struct *);\n\tint (*hangup)(struct tty_struct *);\n\tvoid (*receive_buf)(struct tty_struct *, const unsigned char *, const char *, int);\n\tvoid (*write_wakeup)(struct tty_struct *);\n\tvoid (*dcd_change)(struct tty_struct *, unsigned int);\n\tint (*receive_buf2)(struct tty_struct *, const unsigned char *, const char *, int);\n\tstruct module *owner;\n};\n\nstruct tty_ldisc {\n\tstruct tty_ldisc_ops *ops;\n\tstruct tty_struct *tty;\n};\n\nstruct tty_port_operations {\n\tint (*carrier_raised)(struct tty_port *);\n\tvoid (*dtr_rts)(struct tty_port *, int);\n\tvoid (*shutdown)(struct tty_port *);\n\tint (*activate)(struct tty_port *, struct tty_struct *);\n\tvoid (*destruct)(struct tty_port *);\n};\n\nstruct tty_port_client_operations {\n\tint (*receive_buf)(struct tty_port *, const unsigned char *, const unsigned char *, size_t);\n\tvoid (*write_wakeup)(struct tty_port *);\n};\n\ntypedef struct {\n\tlocal64_t v;\n} u64_stats_t;\n\nstruct bpf_insn {\n\t__u8 code;\n\t__u8 dst_reg: 4;\n\t__u8 src_reg: 4;\n\t__s16 off;\n\t__s32 imm;\n};\n\nenum bpf_map_type {\n\tBPF_MAP_TYPE_UNSPEC = 0,\n\tBPF_MAP_TYPE_HASH = 1,\n\tBPF_MAP_TYPE_ARRAY = 2,\n\tBPF_MAP_TYPE_PROG_ARRAY = 3,\n\tBPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,\n\tBPF_MAP_TYPE_PERCPU_HASH = 5,\n\tBPF_MAP_TYPE_PERCPU_ARRAY = 6,\n\tBPF_MAP_TYPE_STACK_TRACE = 7,\n\tBPF_MAP_TYPE_CGROUP_ARRAY = 8,\n\tBPF_MAP_TYPE_LRU_HASH = 9,\n\tBPF_MAP_TYPE_LRU_PERCPU_HASH = 10,\n\tBPF_MAP_TYPE_LPM_TRIE = 11,\n\tBPF_MAP_TYPE_ARRAY_OF_MAPS = 12,\n\tBPF_MAP_TYPE_HASH_OF_MAPS = 13,\n\tBPF_MAP_TYPE_DEVMAP = 14,\n\tBPF_MAP_TYPE_SOCKMAP = 15,\n\tBPF_MAP_TYPE_CPUMAP = 16,\n\tBPF_MAP_TYPE_XSKMAP = 17,\n\tBPF_MAP_TYPE_SOCKHASH = 18,\n\tBPF_MAP_TYPE_CGROUP_STORAGE = 19,\n\tBPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 20,\n\tBPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,\n\tBPF_MAP_TYPE_QUEUE = 22,\n\tBPF_MAP_TYPE_STACK = 23,\n\tBPF_MAP_TYPE_SK_STORAGE = 24,\n\tBPF_MAP_TYPE_DEVMAP_HASH = 25,\n\tBPF_MAP_TYPE_STRUCT_OPS = 26,\n\tBPF_MAP_TYPE_RINGBUF = 27,\n\tBPF_MAP_TYPE_INODE_STORAGE = 28,\n\tBPF_MAP_TYPE_TASK_STORAGE = 29,\n};\n\nenum bpf_prog_type {\n\tBPF_PROG_TYPE_UNSPEC = 0,\n\tBPF_PROG_TYPE_SOCKET_FILTER = 1,\n\tBPF_PROG_TYPE_KPROBE = 2,\n\tBPF_PROG_TYPE_SCHED_CLS = 3,\n\tBPF_PROG_TYPE_SCHED_ACT = 4,\n\tBPF_PROG_TYPE_TRACEPOINT = 5,\n\tBPF_PROG_TYPE_XDP = 6,\n\tBPF_PROG_TYPE_PERF_EVENT = 7,\n\tBPF_PROG_TYPE_CGROUP_SKB = 8,\n\tBPF_PROG_TYPE_CGROUP_SOCK = 9,\n\tBPF_PROG_TYPE_LWT_IN = 10,\n\tBPF_PROG_TYPE_LWT_OUT = 11,\n\tBPF_PROG_TYPE_LWT_XMIT = 12,\n\tBPF_PROG_TYPE_SOCK_OPS = 13,\n\tBPF_PROG_TYPE_SK_SKB = 14,\n\tBPF_PROG_TYPE_CGROUP_DEVICE = 15,\n\tBPF_PROG_TYPE_SK_MSG = 16,\n\tBPF_PROG_TYPE_RAW_TRACEPOINT = 17,\n\tBPF_PROG_TYPE_CGROUP_SOCK_ADDR = 18,\n\tBPF_PROG_TYPE_LWT_SEG6LOCAL = 19,\n\tBPF_PROG_TYPE_LIRC_MODE2 = 20,\n\tBPF_PROG_TYPE_SK_REUSEPORT = 21,\n\tBPF_PROG_TYPE_FLOW_DISSECTOR = 22,\n\tBPF_PROG_TYPE_CGROUP_SYSCTL = 23,\n\tBPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 24,\n\tBPF_PROG_TYPE_CGROUP_SOCKOPT = 25,\n\tBPF_PROG_TYPE_TRACING = 26,\n\tBPF_PROG_TYPE_STRUCT_OPS = 27,\n\tBPF_PROG_TYPE_EXT = 28,\n\tBPF_PROG_TYPE_LSM = 29,\n\tBPF_PROG_TYPE_SK_LOOKUP = 30,\n\tBPF_PROG_TYPE_SYSCALL = 31,\n};\n\nenum bpf_attach_type {\n\tBPF_CGROUP_INET_INGRESS = 0,\n\tBPF_CGROUP_INET_EGRESS = 1,\n\tBPF_CGROUP_INET_SOCK_CREATE = 2,\n\tBPF_CGROUP_SOCK_OPS = 3,\n\tBPF_SK_SKB_STREAM_PARSER = 4,\n\tBPF_SK_SKB_STREAM_VERDICT = 5,\n\tBPF_CGROUP_DEVICE = 6,\n\tBPF_SK_MSG_VERDICT = 7,\n\tBPF_CGROUP_INET4_BIND = 8,\n\tBPF_CGROUP_INET6_BIND = 9,\n\tBPF_CGROUP_INET4_CONNECT = 10,\n\tBPF_CGROUP_INET6_CONNECT = 11,\n\tBPF_CGROUP_INET4_POST_BIND = 12,\n\tBPF_CGROUP_INET6_POST_BIND = 13,\n\tBPF_CGROUP_UDP4_SENDMSG = 14,\n\tBPF_CGROUP_UDP6_SENDMSG = 15,\n\tBPF_LIRC_MODE2 = 16,\n\tBPF_FLOW_DISSECTOR = 17,\n\tBPF_CGROUP_SYSCTL = 18,\n\tBPF_CGROUP_UDP4_RECVMSG = 19,\n\tBPF_CGROUP_UDP6_RECVMSG = 20,\n\tBPF_CGROUP_GETSOCKOPT = 21,\n\tBPF_CGROUP_SETSOCKOPT = 22,\n\tBPF_TRACE_RAW_TP = 23,\n\tBPF_TRACE_FENTRY = 24,\n\tBPF_TRACE_FEXIT = 25,\n\tBPF_MODIFY_RETURN = 26,\n\tBPF_LSM_MAC = 27,\n\tBPF_TRACE_ITER = 28,\n\tBPF_CGROUP_INET4_GETPEERNAME = 29,\n\tBPF_CGROUP_INET6_GETPEERNAME = 30,\n\tBPF_CGROUP_INET4_GETSOCKNAME = 31,\n\tBPF_CGROUP_INET6_GETSOCKNAME = 32,\n\tBPF_XDP_DEVMAP = 33,\n\tBPF_CGROUP_INET_SOCK_RELEASE = 34,\n\tBPF_XDP_CPUMAP = 35,\n\tBPF_SK_LOOKUP = 36,\n\tBPF_XDP = 37,\n\tBPF_SK_SKB_VERDICT = 38,\n\tBPF_SK_REUSEPORT_SELECT = 39,\n\tBPF_SK_REUSEPORT_SELECT_OR_MIGRATE = 40,\n\tBPF_PERF_EVENT = 41,\n\t__MAX_BPF_ATTACH_TYPE = 42,\n};\n\nunion bpf_attr {\n\tstruct {\n\t\t__u32 map_type;\n\t\t__u32 key_size;\n\t\t__u32 value_size;\n\t\t__u32 max_entries;\n\t\t__u32 map_flags;\n\t\t__u32 inner_map_fd;\n\t\t__u32 numa_node;\n\t\tchar map_name[16];\n\t\t__u32 map_ifindex;\n\t\t__u32 btf_fd;\n\t\t__u32 btf_key_type_id;\n\t\t__u32 btf_value_type_id;\n\t\t__u32 btf_vmlinux_value_type_id;\n\t};\n\tstruct {\n\t\t__u32 map_fd;\n\t\t__u64 key;\n\t\tunion {\n\t\t\t__u64 value;\n\t\t\t__u64 next_key;\n\t\t};\n\t\t__u64 flags;\n\t};\n\tstruct {\n\t\t__u64 in_batch;\n\t\t__u64 out_batch;\n\t\t__u64 keys;\n\t\t__u64 values;\n\t\t__u32 count;\n\t\t__u32 map_fd;\n\t\t__u64 elem_flags;\n\t\t__u64 flags;\n\t} batch;\n\tstruct {\n\t\t__u32 prog_type;\n\t\t__u32 insn_cnt;\n\t\t__u64 insns;\n\t\t__u64 license;\n\t\t__u32 log_level;\n\t\t__u32 log_size;\n\t\t__u64 log_buf;\n\t\t__u32 kern_version;\n\t\t__u32 prog_flags;\n\t\tchar prog_name[16];\n\t\t__u32 prog_ifindex;\n\t\t__u32 expected_attach_type;\n\t\t__u32 prog_btf_fd;\n\t\t__u32 func_info_rec_size;\n\t\t__u64 func_info;\n\t\t__u32 func_info_cnt;\n\t\t__u32 line_info_rec_size;\n\t\t__u64 line_info;\n\t\t__u32 line_info_cnt;\n\t\t__u32 attach_btf_id;\n\t\tunion {\n\t\t\t__u32 attach_prog_fd;\n\t\t\t__u32 attach_btf_obj_fd;\n\t\t};\n\t\t__u64 fd_array;\n\t};\n\tstruct {\n\t\t__u64 pathname;\n\t\t__u32 bpf_fd;\n\t\t__u32 file_flags;\n\t};\n\tstruct {\n\t\t__u32 target_fd;\n\t\t__u32 attach_bpf_fd;\n\t\t__u32 attach_type;\n\t\t__u32 attach_flags;\n\t\t__u32 replace_bpf_fd;\n\t};\n\tstruct {\n\t\t__u32 prog_fd;\n\t\t__u32 retval;\n\t\t__u32 data_size_in;\n\t\t__u32 data_size_out;\n\t\t__u64 data_in;\n\t\t__u64 data_out;\n\t\t__u32 repeat;\n\t\t__u32 duration;\n\t\t__u32 ctx_size_in;\n\t\t__u32 ctx_size_out;\n\t\t__u64 ctx_in;\n\t\t__u64 ctx_out;\n\t\t__u32 flags;\n\t\t__u32 cpu;\n\t} test;\n\tstruct {\n\t\tunion {\n\t\t\t__u32 start_id;\n\t\t\t__u32 prog_id;\n\t\t\t__u32 map_id;\n\t\t\t__u32 btf_id;\n\t\t\t__u32 link_id;\n\t\t};\n\t\t__u32 next_id;\n\t\t__u32 open_flags;\n\t};\n\tstruct {\n\t\t__u32 bpf_fd;\n\t\t__u32 info_len;\n\t\t__u64 info;\n\t} info;\n\tstruct {\n\t\t__u32 target_fd;\n\t\t__u32 attach_type;\n\t\t__u32 query_flags;\n\t\t__u32 attach_flags;\n\t\t__u64 prog_ids;\n\t\t__u32 prog_cnt;\n\t} query;\n\tstruct {\n\t\t__u64 name;\n\t\t__u32 prog_fd;\n\t} raw_tracepoint;\n\tstruct {\n\t\t__u64 btf;\n\t\t__u64 btf_log_buf;\n\t\t__u32 btf_size;\n\t\t__u32 btf_log_size;\n\t\t__u32 btf_log_level;\n\t};\n\tstruct {\n\t\t__u32 pid;\n\t\t__u32 fd;\n\t\t__u32 flags;\n\t\t__u32 buf_len;\n\t\t__u64 buf;\n\t\t__u32 prog_id;\n\t\t__u32 fd_type;\n\t\t__u64 probe_offset;\n\t\t__u64 probe_addr;\n\t} task_fd_query;\n\tstruct {\n\t\t__u32 prog_fd;\n\t\tunion {\n\t\t\t__u32 target_fd;\n\t\t\t__u32 target_ifindex;\n\t\t};\n\t\t__u32 attach_type;\n\t\t__u32 flags;\n\t\tunion {\n\t\t\t__u32 target_btf_id;\n\t\t\tstruct {\n\t\t\t\t__u64 iter_info;\n\t\t\t\t__u32 iter_info_len;\n\t\t\t};\n\t\t\tstruct {\n\t\t\t\t__u64 bpf_cookie;\n\t\t\t} perf_event;\n\t\t};\n\t} link_create;\n\tstruct {\n\t\t__u32 link_fd;\n\t\t__u32 new_prog_fd;\n\t\t__u32 flags;\n\t\t__u32 old_prog_fd;\n\t} link_update;\n\tstruct {\n\t\t__u32 link_fd;\n\t} link_detach;\n\tstruct {\n\t\t__u32 type;\n\t} enable_stats;\n\tstruct {\n\t\t__u32 link_fd;\n\t\t__u32 flags;\n\t} iter_create;\n\tstruct {\n\t\t__u32 prog_fd;\n\t\t__u32 map_fd;\n\t\t__u32 flags;\n\t} prog_bind_map;\n};\n\nstruct bpf_func_info {\n\t__u32 insn_off;\n\t__u32 type_id;\n};\n\nstruct bpf_line_info {\n\t__u32 insn_off;\n\t__u32 file_name_off;\n\t__u32 line_off;\n\t__u32 line_col;\n};\n\ntypedef struct {\n\tunion {\n\t\tvoid *kernel;\n\t\tvoid *user;\n\t};\n\tbool is_kernel: 1;\n} sockptr_t;\n\nstruct bpf_iter_aux_info;\n\ntypedef int (*bpf_iter_init_seq_priv_t)(void *, struct bpf_iter_aux_info *);\n\nstruct bpf_map;\n\nstruct bpf_iter_aux_info {\n\tstruct bpf_map *map;\n};\n\ntypedef void (*bpf_iter_fini_seq_priv_t)(void *);\n\nstruct bpf_iter_seq_info {\n\tconst struct seq_operations *seq_ops;\n\tbpf_iter_init_seq_priv_t init_seq_private;\n\tbpf_iter_fini_seq_priv_t fini_seq_private;\n\tu32 seq_priv_size;\n};\n\nstruct btf;\n\nstruct btf_type;\n\nstruct bpf_prog_aux;\n\nstruct bpf_local_storage_map;\n\nstruct bpf_verifier_env;\n\nstruct bpf_func_state;\n\nstruct bpf_map_ops {\n\tint (*map_alloc_check)(union bpf_attr *);\n\tstruct bpf_map * (*map_alloc)(union bpf_attr *);\n\tvoid (*map_release)(struct bpf_map *, struct file *);\n\tvoid (*map_free)(struct bpf_map *);\n\tint (*map_get_next_key)(struct bpf_map *, void *, void *);\n\tvoid (*map_release_uref)(struct bpf_map *);\n\tvoid * (*map_lookup_elem_sys_only)(struct bpf_map *, void *);\n\tint (*map_lookup_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);\n\tint (*map_lookup_and_delete_elem)(struct bpf_map *, void *, void *, u64);\n\tint (*map_lookup_and_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);\n\tint (*map_update_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);\n\tint (*map_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);\n\tvoid * (*map_lookup_elem)(struct bpf_map *, void *);\n\tint (*map_update_elem)(struct bpf_map *, void *, void *, u64);\n\tint (*map_delete_elem)(struct bpf_map *, void *);\n\tint (*map_push_elem)(struct bpf_map *, void *, u64);\n\tint (*map_pop_elem)(struct bpf_map *, void *);\n\tint (*map_peek_elem)(struct bpf_map *, void *);\n\tvoid * (*map_fd_get_ptr)(struct bpf_map *, struct file *, int);\n\tvoid (*map_fd_put_ptr)(void *);\n\tint (*map_gen_lookup)(struct bpf_map *, struct bpf_insn *);\n\tu32 (*map_fd_sys_lookup_elem)(void *);\n\tvoid (*map_seq_show_elem)(struct bpf_map *, void *, struct seq_file *);\n\tint (*map_check_btf)(const struct bpf_map *, const struct btf *, const struct btf_type *, const struct btf_type *);\n\tint (*map_poke_track)(struct bpf_map *, struct bpf_prog_aux *);\n\tvoid (*map_poke_untrack)(struct bpf_map *, struct bpf_prog_aux *);\n\tvoid (*map_poke_run)(struct bpf_map *, u32, struct bpf_prog *, struct bpf_prog *);\n\tint (*map_direct_value_addr)(const struct bpf_map *, u64 *, u32);\n\tint (*map_direct_value_meta)(const struct bpf_map *, u64, u32 *);\n\tint (*map_mmap)(struct bpf_map *, struct vm_area_struct *);\n\t__poll_t (*map_poll)(struct bpf_map *, struct file *, struct poll_table_struct *);\n\tint (*map_local_storage_charge)(struct bpf_local_storage_map *, void *, u32);\n\tvoid (*map_local_storage_uncharge)(struct bpf_local_storage_map *, void *, u32);\n\tstruct bpf_local_storage ** (*map_owner_storage_ptr)(void *);\n\tint (*map_redirect)(struct bpf_map *, u32, u64);\n\tbool (*map_meta_equal)(const struct bpf_map *, const struct bpf_map *);\n\tint (*map_set_for_each_callback_args)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *);\n\tint (*map_for_each_callback)(struct bpf_map *, void *, void *, u64);\n\tconst char * const map_btf_name;\n\tint *map_btf_id;\n\tconst struct bpf_iter_seq_info *iter_seq_info;\n};\n\nstruct bpf_map {\n\tconst struct bpf_map_ops *ops;\n\tstruct bpf_map *inner_map_meta;\n\tvoid *security;\n\tenum bpf_map_type map_type;\n\tu32 key_size;\n\tu32 value_size;\n\tu32 max_entries;\n\tu32 map_flags;\n\tint spin_lock_off;\n\tint timer_off;\n\tu32 id;\n\tint numa_node;\n\tu32 btf_key_type_id;\n\tu32 btf_value_type_id;\n\tstruct btf *btf;\n\tstruct mem_cgroup *memcg;\n\tchar name[16];\n\tu32 btf_vmlinux_value_type_id;\n\tbool bypass_spec_v1;\n\tbool frozen;\n\tlong: 16;\n\tlong: 64;\n\tlong: 64;\n\tatomic64_t refcnt;\n\tatomic64_t usercnt;\n\tstruct work_struct work;\n\tstruct mutex freeze_mutex;\n\tatomic64_t writecnt;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct btf_header {\n\t__u16 magic;\n\t__u8 version;\n\t__u8 flags;\n\t__u32 hdr_len;\n\t__u32 type_off;\n\t__u32 type_len;\n\t__u32 str_off;\n\t__u32 str_len;\n};\n\nstruct btf {\n\tvoid *data;\n\tstruct btf_type **types;\n\tu32 *resolved_ids;\n\tu32 *resolved_sizes;\n\tconst char *strings;\n\tvoid *nohdr_data;\n\tstruct btf_header hdr;\n\tu32 nr_types;\n\tu32 types_size;\n\tu32 data_size;\n\trefcount_t refcnt;\n\tu32 id;\n\tstruct callback_head rcu;\n\tstruct btf *base_btf;\n\tu32 start_id;\n\tu32 start_str_off;\n\tchar name[56];\n\tbool kernel_btf;\n};\n\nstruct btf_type {\n\t__u32 name_off;\n\t__u32 info;\n\tunion {\n\t\t__u32 size;\n\t\t__u32 type;\n\t};\n};\n\nstruct bpf_ksym {\n\tlong unsigned int start;\n\tlong unsigned int end;\n\tchar name[128];\n\tstruct list_head lnode;\n\tstruct latch_tree_node tnode;\n\tbool prog;\n};\n\nstruct bpf_ctx_arg_aux;\n\nstruct bpf_trampoline;\n\nstruct bpf_jit_poke_descriptor;\n\nstruct bpf_kfunc_desc_tab;\n\nstruct bpf_prog_ops;\n\nstruct btf_mod_pair;\n\nstruct bpf_prog_offload;\n\nstruct bpf_func_info_aux;\n\nstruct bpf_prog_aux {\n\tatomic64_t refcnt;\n\tu32 used_map_cnt;\n\tu32 used_btf_cnt;\n\tu32 max_ctx_offset;\n\tu32 max_pkt_offset;\n\tu32 max_tp_access;\n\tu32 stack_depth;\n\tu32 id;\n\tu32 func_cnt;\n\tu32 func_idx;\n\tu32 attach_btf_id;\n\tu32 ctx_arg_info_size;\n\tu32 max_rdonly_access;\n\tu32 max_rdwr_access;\n\tstruct btf *attach_btf;\n\tconst struct bpf_ctx_arg_aux *ctx_arg_info;\n\tstruct mutex dst_mutex;\n\tstruct bpf_prog *dst_prog;\n\tstruct bpf_trampoline *dst_trampoline;\n\tenum bpf_prog_type saved_dst_prog_type;\n\tenum bpf_attach_type saved_dst_attach_type;\n\tbool verifier_zext;\n\tbool offload_requested;\n\tbool attach_btf_trace;\n\tbool func_proto_unreliable;\n\tbool sleepable;\n\tbool tail_call_reachable;\n\tstruct hlist_node tramp_hlist;\n\tconst struct btf_type *attach_func_proto;\n\tconst char *attach_func_name;\n\tstruct bpf_prog **func;\n\tvoid *jit_data;\n\tstruct bpf_jit_poke_descriptor *poke_tab;\n\tstruct bpf_kfunc_desc_tab *kfunc_tab;\n\tu32 size_poke_tab;\n\tstruct bpf_ksym ksym;\n\tconst struct bpf_prog_ops *ops;\n\tstruct bpf_map **used_maps;\n\tstruct mutex used_maps_mutex;\n\tstruct btf_mod_pair *used_btfs;\n\tstruct bpf_prog *prog;\n\tstruct user_struct *user;\n\tu64 load_time;\n\tstruct bpf_map *cgroup_storage[2];\n\tchar name[16];\n\tvoid *security;\n\tstruct bpf_prog_offload *offload;\n\tstruct btf *btf;\n\tstruct bpf_func_info *func_info;\n\tstruct bpf_func_info_aux *func_info_aux;\n\tstruct bpf_line_info *linfo;\n\tvoid **jited_linfo;\n\tu32 func_info_cnt;\n\tu32 nr_linfo;\n\tu32 linfo_idx;\n\tu32 num_exentries;\n\tstruct exception_table_entry *extable;\n\tunion {\n\t\tstruct work_struct work;\n\t\tstruct callback_head rcu;\n\t};\n};\n\nstruct sock_filter {\n\t__u16 code;\n\t__u8 jt;\n\t__u8 jf;\n\t__u32 k;\n};\n\nstruct bpf_prog_stats;\n\nstruct sock_fprog_kern;\n\nstruct bpf_prog {\n\tu16 pages;\n\tu16 jited: 1;\n\tu16 jit_requested: 1;\n\tu16 gpl_compatible: 1;\n\tu16 cb_access: 1;\n\tu16 dst_needed: 1;\n\tu16 blinded: 1;\n\tu16 is_func: 1;\n\tu16 kprobe_override: 1;\n\tu16 has_callchain_buf: 1;\n\tu16 enforce_expected_attach_type: 1;\n\tu16 call_get_stack: 1;\n\tu16 call_get_func_ip: 1;\n\tenum bpf_prog_type type;\n\tenum bpf_attach_type expected_attach_type;\n\tu32 len;\n\tu32 jited_len;\n\tu8 tag[8];\n\tstruct bpf_prog_stats *stats;\n\tint *active;\n\tunsigned int (*bpf_func)(const void *, const struct bpf_insn *);\n\tstruct bpf_prog_aux *aux;\n\tstruct sock_fprog_kern *orig_prog;\n\tstruct sock_filter insns[0];\n\tstruct bpf_insn insnsi[0];\n};\n\nstruct bpf_offloaded_map;\n\nstruct bpf_map_dev_ops {\n\tint (*map_get_next_key)(struct bpf_offloaded_map *, void *, void *);\n\tint (*map_lookup_elem)(struct bpf_offloaded_map *, void *, void *);\n\tint (*map_update_elem)(struct bpf_offloaded_map *, void *, void *, u64);\n\tint (*map_delete_elem)(struct bpf_offloaded_map *, void *);\n};\n\nstruct bpf_offloaded_map {\n\tstruct bpf_map map;\n\tstruct net_device *netdev;\n\tconst struct bpf_map_dev_ops *dev_ops;\n\tvoid *dev_priv;\n\tstruct list_head offloads;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct net_device_stats {\n\tlong unsigned int rx_packets;\n\tlong unsigned int tx_packets;\n\tlong unsigned int rx_bytes;\n\tlong unsigned int tx_bytes;\n\tlong unsigned int rx_errors;\n\tlong unsigned int tx_errors;\n\tlong unsigned int rx_dropped;\n\tlong unsigned int tx_dropped;\n\tlong unsigned int multicast;\n\tlong unsigned int collisions;\n\tlong unsigned int rx_length_errors;\n\tlong unsigned int rx_over_errors;\n\tlong unsigned int rx_crc_errors;\n\tlong unsigned int rx_frame_errors;\n\tlong unsigned int rx_fifo_errors;\n\tlong unsigned int rx_missed_errors;\n\tlong unsigned int tx_aborted_errors;\n\tlong unsigned int tx_carrier_errors;\n\tlong unsigned int tx_fifo_errors;\n\tlong unsigned int tx_heartbeat_errors;\n\tlong unsigned int tx_window_errors;\n\tlong unsigned int rx_compressed;\n\tlong unsigned int tx_compressed;\n};\n\nstruct netdev_hw_addr_list {\n\tstruct list_head list;\n\tint count;\n\tstruct rb_root tree;\n};\n\nstruct tipc_bearer;\n\nstruct dn_dev;\n\nstruct mpls_dev;\n\nstruct mctp_dev;\n\nenum rx_handler_result {\n\tRX_HANDLER_CONSUMED = 0,\n\tRX_HANDLER_ANOTHER = 1,\n\tRX_HANDLER_EXACT = 2,\n\tRX_HANDLER_PASS = 3,\n};\n\ntypedef enum rx_handler_result rx_handler_result_t;\n\ntypedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);\n\nenum netdev_ml_priv_type {\n\tML_PRIV_NONE = 0,\n\tML_PRIV_CAN = 1,\n};\n\nstruct pcpu_dstats;\n\nstruct garp_port;\n\nstruct mrp_port;\n\nstruct netdev_tc_txq {\n\tu16 count;\n\tu16 offset;\n};\n\nstruct macsec_ops;\n\nstruct udp_tunnel_nic;\n\nstruct bpf_xdp_link;\n\nstruct bpf_xdp_entity {\n\tstruct bpf_prog *prog;\n\tstruct bpf_xdp_link *link;\n};\n\nstruct netdev_name_node;\n\nstruct dev_ifalias;\n\nstruct net_device_ops;\n\nstruct iw_handler_def;\n\nstruct iw_public_data;\n\nstruct ethtool_ops;\n\nstruct l3mdev_ops;\n\nstruct ndisc_ops;\n\nstruct xfrmdev_ops;\n\nstruct tlsdev_ops;\n\nstruct header_ops;\n\nstruct vlan_info;\n\nstruct dsa_port;\n\nstruct in_device;\n\nstruct inet6_dev;\n\nstruct wireless_dev;\n\nstruct wpan_dev;\n\nstruct netdev_rx_queue;\n\nstruct mini_Qdisc;\n\nstruct netdev_queue;\n\nstruct cpu_rmap;\n\nstruct Qdisc;\n\nstruct xdp_dev_bulk_queue;\n\nstruct xps_dev_maps;\n\nstruct netpoll_info;\n\nstruct pcpu_lstats;\n\nstruct pcpu_sw_netstats;\n\nstruct rtnl_link_ops;\n\nstruct dcbnl_rtnl_ops;\n\nstruct netprio_map;\n\nstruct phy_device;\n\nstruct sfp_bus;\n\nstruct udp_tunnel_nic_info;\n\nstruct net_device {\n\tchar name[16];\n\tstruct netdev_name_node *name_node;\n\tstruct dev_ifalias *ifalias;\n\tlong unsigned int mem_end;\n\tlong unsigned int mem_start;\n\tlong unsigned int base_addr;\n\tlong unsigned int state;\n\tstruct list_head dev_list;\n\tstruct list_head napi_list;\n\tstruct list_head unreg_list;\n\tstruct list_head close_list;\n\tstruct list_head ptype_all;\n\tstruct list_head ptype_specific;\n\tstruct {\n\t\tstruct list_head upper;\n\t\tstruct list_head lower;\n\t} adj_list;\n\tunsigned int flags;\n\tunsigned int priv_flags;\n\tconst struct net_device_ops *netdev_ops;\n\tint ifindex;\n\tshort unsigned int gflags;\n\tshort unsigned int hard_header_len;\n\tunsigned int mtu;\n\tshort unsigned int needed_headroom;\n\tshort unsigned int needed_tailroom;\n\tnetdev_features_t features;\n\tnetdev_features_t hw_features;\n\tnetdev_features_t wanted_features;\n\tnetdev_features_t vlan_features;\n\tnetdev_features_t hw_enc_features;\n\tnetdev_features_t mpls_features;\n\tnetdev_features_t gso_partial_features;\n\tunsigned int min_mtu;\n\tunsigned int max_mtu;\n\tshort unsigned int type;\n\tunsigned char min_header_len;\n\tunsigned char name_assign_type;\n\tint group;\n\tstruct net_device_stats stats;\n\tatomic_long_t rx_dropped;\n\tatomic_long_t tx_dropped;\n\tatomic_long_t rx_nohandler;\n\tatomic_t carrier_up_count;\n\tatomic_t carrier_down_count;\n\tconst struct iw_handler_def *wireless_handlers;\n\tstruct iw_public_data *wireless_data;\n\tconst struct ethtool_ops *ethtool_ops;\n\tconst struct l3mdev_ops *l3mdev_ops;\n\tconst struct ndisc_ops *ndisc_ops;\n\tconst struct xfrmdev_ops *xfrmdev_ops;\n\tconst struct tlsdev_ops *tlsdev_ops;\n\tconst struct header_ops *header_ops;\n\tunsigned char operstate;\n\tunsigned char link_mode;\n\tunsigned char if_port;\n\tunsigned char dma;\n\tunsigned char perm_addr[32];\n\tunsigned char addr_assign_type;\n\tunsigned char addr_len;\n\tunsigned char upper_level;\n\tunsigned char lower_level;\n\tshort unsigned int neigh_priv_len;\n\tshort unsigned int dev_id;\n\tshort unsigned int dev_port;\n\tshort unsigned int padded;\n\tspinlock_t addr_list_lock;\n\tint irq;\n\tstruct netdev_hw_addr_list uc;\n\tstruct netdev_hw_addr_list mc;\n\tstruct netdev_hw_addr_list dev_addrs;\n\tstruct kset *queues_kset;\n\tunsigned int promiscuity;\n\tunsigned int allmulti;\n\tbool uc_promisc;\n\tstruct vlan_info *vlan_info;\n\tstruct dsa_port *dsa_ptr;\n\tstruct tipc_bearer *tipc_ptr;\n\tvoid *atalk_ptr;\n\tstruct in_device *ip_ptr;\n\tstruct dn_dev *dn_ptr;\n\tstruct inet6_dev *ip6_ptr;\n\tvoid *ax25_ptr;\n\tstruct wireless_dev *ieee80211_ptr;\n\tstruct wpan_dev *ieee802154_ptr;\n\tstruct mpls_dev *mpls_ptr;\n\tstruct mctp_dev *mctp_ptr;\n\tunsigned char *dev_addr;\n\tstruct netdev_rx_queue *_rx;\n\tunsigned int num_rx_queues;\n\tunsigned int real_num_rx_queues;\n\tstruct bpf_prog *xdp_prog;\n\tlong unsigned int gro_flush_timeout;\n\tint napi_defer_hard_irqs;\n\trx_handler_func_t *rx_handler;\n\tvoid *rx_handler_data;\n\tstruct mini_Qdisc *miniq_ingress;\n\tstruct netdev_queue *ingress_queue;\n\tstruct nf_hook_entries *nf_hooks_ingress;\n\tunsigned char broadcast[32];\n\tstruct cpu_rmap *rx_cpu_rmap;\n\tstruct hlist_node index_hlist;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct netdev_queue *_tx;\n\tunsigned int num_tx_queues;\n\tunsigned int real_num_tx_queues;\n\tstruct Qdisc *qdisc;\n\tunsigned int tx_queue_len;\n\tspinlock_t tx_global_lock;\n\tstruct xdp_dev_bulk_queue *xdp_bulkq;\n\tstruct xps_dev_maps *xps_maps[2];\n\tstruct mini_Qdisc *miniq_egress;\n\tstruct hlist_head qdisc_hash[16];\n\tstruct timer_list watchdog_timer;\n\tint watchdog_timeo;\n\tu32 proto_down_reason;\n\tstruct list_head todo_list;\n\tint *pcpu_refcnt;\n\tstruct list_head link_watch_list;\n\tenum {\n\t\tNETREG_UNINITIALIZED = 0,\n\t\tNETREG_REGISTERED = 1,\n\t\tNETREG_UNREGISTERING = 2,\n\t\tNETREG_UNREGISTERED = 3,\n\t\tNETREG_RELEASED = 4,\n\t\tNETREG_DUMMY = 5,\n\t} reg_state: 8;\n\tbool dismantle;\n\tenum {\n\t\tRTNL_LINK_INITIALIZED = 0,\n\t\tRTNL_LINK_INITIALIZING = 1,\n\t} rtnl_link_state: 16;\n\tbool needs_free_netdev;\n\tvoid (*priv_destructor)(struct net_device *);\n\tstruct netpoll_info *npinfo;\n\tpossible_net_t nd_net;\n\tvoid *ml_priv;\n\tenum netdev_ml_priv_type ml_priv_type;\n\tunion {\n\t\tstruct pcpu_lstats *lstats;\n\t\tstruct pcpu_sw_netstats *tstats;\n\t\tstruct pcpu_dstats *dstats;\n\t};\n\tstruct garp_port *garp_port;\n\tstruct mrp_port *mrp_port;\n\tstruct device dev;\n\tconst struct attribute_group *sysfs_groups[4];\n\tconst struct attribute_group *sysfs_rx_queue_group;\n\tconst struct rtnl_link_ops *rtnl_link_ops;\n\tunsigned int gso_max_size;\n\tu16 gso_max_segs;\n\tconst struct dcbnl_rtnl_ops *dcbnl_ops;\n\ts16 num_tc;\n\tstruct netdev_tc_txq tc_to_txq[16];\n\tu8 prio_tc_map[16];\n\tunsigned int fcoe_ddp_xid;\n\tstruct netprio_map *priomap;\n\tstruct phy_device *phydev;\n\tstruct sfp_bus *sfp_bus;\n\tstruct lock_class_key *qdisc_tx_busylock;\n\tstruct lock_class_key *qdisc_running_key;\n\tbool proto_down;\n\tunsigned int wol_enabled: 1;\n\tunsigned int threaded: 1;\n\tstruct list_head net_notifier_list;\n\tconst struct macsec_ops *macsec_ops;\n\tconst struct udp_tunnel_nic_info *udp_tunnel_nic_info;\n\tstruct udp_tunnel_nic *udp_tunnel_nic;\n\tstruct bpf_xdp_entity xdp_state[3];\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nenum bpf_reg_type {\n\tNOT_INIT = 0,\n\tSCALAR_VALUE = 1,\n\tPTR_TO_CTX = 2,\n\tCONST_PTR_TO_MAP = 3,\n\tPTR_TO_MAP_VALUE = 4,\n\tPTR_TO_MAP_KEY = 5,\n\tPTR_TO_STACK = 6,\n\tPTR_TO_PACKET_META = 7,\n\tPTR_TO_PACKET = 8,\n\tPTR_TO_PACKET_END = 9,\n\tPTR_TO_FLOW_KEYS = 10,\n\tPTR_TO_SOCKET = 11,\n\tPTR_TO_SOCK_COMMON = 12,\n\tPTR_TO_TCP_SOCK = 13,\n\tPTR_TO_TP_BUFFER = 14,\n\tPTR_TO_XDP_SOCK = 15,\n\tPTR_TO_BTF_ID = 16,\n\tPTR_TO_MEM = 17,\n\tPTR_TO_BUF = 18,\n\tPTR_TO_PERCPU_BTF_ID = 19,\n\tPTR_TO_FUNC = 20,\n\t__BPF_REG_TYPE_MAX = 21,\n\tPTR_TO_MAP_VALUE_OR_NULL = 260,\n\tPTR_TO_SOCKET_OR_NULL = 267,\n\tPTR_TO_SOCK_COMMON_OR_NULL = 268,\n\tPTR_TO_TCP_SOCK_OR_NULL = 269,\n\tPTR_TO_BTF_ID_OR_NULL = 272,\n\t__BPF_REG_TYPE_LIMIT = 1023,\n};\n\nstruct bpf_prog_ops {\n\tint (*test_run)(struct bpf_prog *, const union bpf_attr *, union bpf_attr *);\n};\n\nstruct bpf_offload_dev;\n\nstruct bpf_prog_offload {\n\tstruct bpf_prog *prog;\n\tstruct net_device *netdev;\n\tstruct bpf_offload_dev *offdev;\n\tvoid *dev_priv;\n\tstruct list_head offloads;\n\tbool dev_state;\n\tbool opt_failed;\n\tvoid *jited_image;\n\tu32 jited_len;\n};\n\nstruct btf_func_model {\n\tu8 ret_size;\n\tu8 nr_args;\n\tu8 arg_size[12];\n};\n\nstruct bpf_tramp_image {\n\tvoid *image;\n\tstruct bpf_ksym ksym;\n\tstruct percpu_ref pcref;\n\tvoid *ip_after_call;\n\tvoid *ip_epilogue;\n\tunion {\n\t\tstruct callback_head rcu;\n\t\tstruct work_struct work;\n\t};\n};\n\nstruct bpf_trampoline {\n\tstruct hlist_node hlist;\n\tstruct mutex mutex;\n\trefcount_t refcnt;\n\tu64 key;\n\tstruct {\n\t\tstruct btf_func_model model;\n\t\tvoid *addr;\n\t\tbool ftrace_managed;\n\t} func;\n\tstruct bpf_prog *extension_prog;\n\tstruct hlist_head progs_hlist[3];\n\tint progs_cnt[3];\n\tstruct bpf_tramp_image *cur_image;\n\tu64 selector;\n\tstruct module *mod;\n};\n\nstruct bpf_func_info_aux {\n\tu16 linkage;\n\tbool unreliable;\n};\n\nstruct bpf_jit_poke_descriptor {\n\tvoid *tailcall_target;\n\tvoid *tailcall_bypass;\n\tvoid *bypass_addr;\n\tvoid *aux;\n\tunion {\n\t\tstruct {\n\t\t\tstruct bpf_map *map;\n\t\t\tu32 key;\n\t\t} tail_call;\n\t};\n\tbool tailcall_target_stable;\n\tu8 adj_off;\n\tu16 reason;\n\tu32 insn_idx;\n};\n\nstruct bpf_ctx_arg_aux {\n\tu32 offset;\n\tenum bpf_reg_type reg_type;\n\tu32 btf_id;\n};\n\nstruct btf_mod_pair {\n\tstruct btf *btf;\n\tstruct module *module;\n};\n\nstruct scatterlist {\n\tlong unsigned int page_link;\n\tunsigned int offset;\n\tunsigned int length;\n\tdma_addr_t dma_address;\n\tunsigned int dma_length;\n};\n\nenum {\n\tRoot_NFS = 255,\n\tRoot_CIFS = 254,\n\tRoot_RAM0 = 1048576,\n\tRoot_RAM1 = 1048577,\n\tRoot_FD0 = 2097152,\n\tRoot_HDA1 = 3145729,\n\tRoot_HDA2 = 3145730,\n\tRoot_SDA1 = 8388609,\n\tRoot_SDA2 = 8388610,\n\tRoot_HDC1 = 23068673,\n\tRoot_SR0 = 11534336,\n};\n\nstruct flowi_tunnel {\n\t__be64 tun_id;\n};\n\nstruct flowi_common {\n\tint flowic_oif;\n\tint flowic_iif;\n\t__u32 flowic_mark;\n\t__u8 flowic_tos;\n\t__u8 flowic_scope;\n\t__u8 flowic_proto;\n\t__u8 flowic_flags;\n\t__u32 flowic_secid;\n\tkuid_t flowic_uid;\n\tstruct flowi_tunnel flowic_tun_key;\n\t__u32 flowic_multipath_hash;\n};\n\nunion flowi_uli {\n\tstruct {\n\t\t__be16 dport;\n\t\t__be16 sport;\n\t} ports;\n\tstruct {\n\t\t__u8 type;\n\t\t__u8 code;\n\t} icmpt;\n\tstruct {\n\t\t__le16 dport;\n\t\t__le16 sport;\n\t} dnports;\n\t__be32 gre_key;\n\tstruct {\n\t\t__u8 type;\n\t} mht;\n};\n\nstruct flowi4 {\n\tstruct flowi_common __fl_common;\n\t__be32 saddr;\n\t__be32 daddr;\n\tunion flowi_uli uli;\n};\n\nstruct flowi6 {\n\tstruct flowi_common __fl_common;\n\tstruct in6_addr daddr;\n\tstruct in6_addr saddr;\n\t__be32 flowlabel;\n\tunion flowi_uli uli;\n\t__u32 mp_hash;\n};\n\nstruct flowidn {\n\tstruct flowi_common __fl_common;\n\t__le16 daddr;\n\t__le16 saddr;\n\tunion flowi_uli uli;\n};\n\nstruct flowi {\n\tunion {\n\t\tstruct flowi_common __fl_common;\n\t\tstruct flowi4 ip4;\n\t\tstruct flowi6 ip6;\n\t\tstruct flowidn dn;\n\t} u;\n};\n\nstruct icmpv6_mib_device {\n\tatomic_long_t mibs[6];\n};\n\nstruct icmpv6msg_mib_device {\n\tatomic_long_t mibs[512];\n};\n\nstruct fib_rule;\n\nstruct fib_lookup_arg;\n\nstruct fib_rule_hdr;\n\nstruct nlattr;\n\nstruct netlink_ext_ack;\n\nstruct nla_policy;\n\nstruct fib_rules_ops {\n\tint family;\n\tstruct list_head list;\n\tint rule_size;\n\tint addr_size;\n\tint unresolved_rules;\n\tint nr_goto_rules;\n\tunsigned int fib_rules_seq;\n\tint (*action)(struct fib_rule *, struct flowi *, int, struct fib_lookup_arg *);\n\tbool (*suppress)(struct fib_rule *, int, struct fib_lookup_arg *);\n\tint (*match)(struct fib_rule *, struct flowi *, int);\n\tint (*configure)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *, struct nlattr **, struct netlink_ext_ack *);\n\tint (*delete)(struct fib_rule *);\n\tint (*compare)(struct fib_rule *, struct fib_rule_hdr *, struct nlattr **);\n\tint (*fill)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *);\n\tsize_t (*nlmsg_payload)(struct fib_rule *);\n\tvoid (*flush_cache)(struct fib_rules_ops *);\n\tint nlgroup;\n\tconst struct nla_policy *policy;\n\tstruct list_head rules_list;\n\tstruct module *owner;\n\tstruct net *fro_net;\n\tstruct callback_head rcu;\n};\n\nstruct fib_notifier_ops {\n\tint family;\n\tstruct list_head list;\n\tunsigned int (*fib_seq_read)(struct net *);\n\tint (*fib_dump)(struct net *, struct notifier_block *, struct netlink_ext_ack *);\n\tstruct module *owner;\n\tstruct callback_head rcu;\n};\n\nstruct hh_cache {\n\tunsigned int hh_len;\n\tseqlock_t hh_lock;\n\tlong unsigned int hh_data[16];\n};\n\nstruct neigh_table;\n\nstruct neigh_parms;\n\nstruct neigh_ops;\n\nstruct neighbour {\n\tstruct neighbour *next;\n\tstruct neigh_table *tbl;\n\tstruct neigh_parms *parms;\n\tlong unsigned int confirmed;\n\tlong unsigned int updated;\n\trwlock_t lock;\n\trefcount_t refcnt;\n\tunsigned int arp_queue_len_bytes;\n\tstruct sk_buff_head arp_queue;\n\tstruct timer_list timer;\n\tlong unsigned int used;\n\tatomic_t probes;\n\t__u8 flags;\n\t__u8 nud_state;\n\t__u8 type;\n\t__u8 dead;\n\tu8 protocol;\n\tseqlock_t ha_lock;\n\tint: 32;\n\tunsigned char ha[32];\n\tstruct hh_cache hh;\n\tint (*output)(struct neighbour *, struct sk_buff *);\n\tconst struct neigh_ops *ops;\n\tstruct list_head gc_list;\n\tstruct callback_head rcu;\n\tstruct net_device *dev;\n\tu8 primary_key[0];\n};\n\nstruct ipv6_stable_secret {\n\tbool initialized;\n\tstruct in6_addr secret;\n};\n\nstruct ipv6_devconf {\n\t__s32 forwarding;\n\t__s32 hop_limit;\n\t__s32 mtu6;\n\t__s32 accept_ra;\n\t__s32 accept_redirects;\n\t__s32 autoconf;\n\t__s32 dad_transmits;\n\t__s32 rtr_solicits;\n\t__s32 rtr_solicit_interval;\n\t__s32 rtr_solicit_max_interval;\n\t__s32 rtr_solicit_delay;\n\t__s32 force_mld_version;\n\t__s32 mldv1_unsolicited_report_interval;\n\t__s32 mldv2_unsolicited_report_interval;\n\t__s32 use_tempaddr;\n\t__s32 temp_valid_lft;\n\t__s32 temp_prefered_lft;\n\t__s32 regen_max_retry;\n\t__s32 max_desync_factor;\n\t__s32 max_addresses;\n\t__s32 accept_ra_defrtr;\n\t__u32 ra_defrtr_metric;\n\t__s32 accept_ra_min_hop_limit;\n\t__s32 accept_ra_pinfo;\n\t__s32 ignore_routes_with_linkdown;\n\t__s32 accept_ra_rtr_pref;\n\t__s32 rtr_probe_interval;\n\t__s32 accept_ra_rt_info_min_plen;\n\t__s32 accept_ra_rt_info_max_plen;\n\t__s32 proxy_ndp;\n\t__s32 accept_source_route;\n\t__s32 accept_ra_from_local;\n\tatomic_t mc_forwarding;\n\t__s32 disable_ipv6;\n\t__s32 drop_unicast_in_l2_multicast;\n\t__s32 accept_dad;\n\t__s32 force_tllao;\n\t__s32 ndisc_notify;\n\t__s32 suppress_frag_ndisc;\n\t__s32 accept_ra_mtu;\n\t__s32 drop_unsolicited_na;\n\tstruct ipv6_stable_secret stable_secret;\n\t__s32 use_oif_addrs_only;\n\t__s32 keep_addr_on_down;\n\t__s32 seg6_enabled;\n\t__s32 seg6_require_hmac;\n\t__u32 enhanced_dad;\n\t__u32 addr_gen_mode;\n\t__s32 disable_policy;\n\t__s32 ndisc_tclass;\n\t__s32 rpl_seg_enabled;\n\t__u32 ioam6_id;\n\t__u32 ioam6_id_wide;\n\t__u8 ioam6_enabled;\n\tstruct ctl_table_header *sysctl_header;\n};\n\ntypedef enum {\n\tSS_FREE = 0,\n\tSS_UNCONNECTED = 1,\n\tSS_CONNECTING = 2,\n\tSS_CONNECTED = 3,\n\tSS_DISCONNECTING = 4,\n} socket_state;\n\nstruct socket_wq {\n\twait_queue_head_t wait;\n\tstruct fasync_struct *fasync_list;\n\tlong unsigned int flags;\n\tstruct callback_head rcu;\n\tlong: 64;\n};\n\nstruct proto_ops;\n\nstruct socket {\n\tsocket_state state;\n\tshort int type;\n\tlong unsigned int flags;\n\tstruct file *file;\n\tstruct sock *sk;\n\tconst struct proto_ops *ops;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct socket_wq wq;\n};\n\ntypedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *, unsigned int, size_t);\n\nstruct proto_ops {\n\tint family;\n\tstruct module *owner;\n\tint (*release)(struct socket *);\n\tint (*bind)(struct socket *, struct sockaddr *, int);\n\tint (*connect)(struct socket *, struct sockaddr *, int, int);\n\tint (*socketpair)(struct socket *, struct socket *);\n\tint (*accept)(struct socket *, struct socket *, int, bool);\n\tint (*getname)(struct socket *, struct sockaddr *, int);\n\t__poll_t (*poll)(struct file *, struct socket *, struct poll_table_struct *);\n\tint (*ioctl)(struct socket *, unsigned int, long unsigned int);\n\tint (*compat_ioctl)(struct socket *, unsigned int, long unsigned int);\n\tint (*gettstamp)(struct socket *, void *, bool, bool);\n\tint (*listen)(struct socket *, int);\n\tint (*shutdown)(struct socket *, int);\n\tint (*setsockopt)(struct socket *, int, int, sockptr_t, unsigned int);\n\tint (*getsockopt)(struct socket *, int, int, char *, int *);\n\tvoid (*show_fdinfo)(struct seq_file *, struct socket *);\n\tint (*sendmsg)(struct socket *, struct msghdr *, size_t);\n\tint (*recvmsg)(struct socket *, struct msghdr *, size_t, int);\n\tint (*mmap)(struct file *, struct socket *, struct vm_area_struct *);\n\tssize_t (*sendpage)(struct socket *, struct page *, int, size_t, int);\n\tssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\n\tint (*set_peek_off)(struct sock *, int);\n\tint (*peek_len)(struct socket *);\n\tint (*read_sock)(struct sock *, read_descriptor_t *, sk_read_actor_t);\n\tint (*sendpage_locked)(struct sock *, struct page *, int, size_t, int);\n\tint (*sendmsg_locked)(struct sock *, struct msghdr *, size_t);\n\tint (*set_rcvlowat)(struct sock *, int);\n};\n\nstruct dql {\n\tunsigned int num_queued;\n\tunsigned int adj_limit;\n\tunsigned int last_obj_cnt;\n\tlong: 32;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tunsigned int limit;\n\tunsigned int num_completed;\n\tunsigned int prev_ovlimit;\n\tunsigned int prev_num_queued;\n\tunsigned int prev_last_obj_cnt;\n\tunsigned int lowest_slack;\n\tlong unsigned int slack_start_time;\n\tunsigned int max_limit;\n\tunsigned int min_limit;\n\tunsigned int slack_hold_time;\n\tlong: 32;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct ieee_ets {\n\t__u8 willing;\n\t__u8 ets_cap;\n\t__u8 cbs;\n\t__u8 tc_tx_bw[8];\n\t__u8 tc_rx_bw[8];\n\t__u8 tc_tsa[8];\n\t__u8 prio_tc[8];\n\t__u8 tc_reco_bw[8];\n\t__u8 tc_reco_tsa[8];\n\t__u8 reco_prio_tc[8];\n};\n\nstruct ieee_maxrate {\n\t__u64 tc_maxrate[8];\n};\n\nstruct ieee_qcn {\n\t__u8 rpg_enable[8];\n\t__u32 rppp_max_rps[8];\n\t__u32 rpg_time_reset[8];\n\t__u32 rpg_byte_reset[8];\n\t__u32 rpg_threshold[8];\n\t__u32 rpg_max_rate[8];\n\t__u32 rpg_ai_rate[8];\n\t__u32 rpg_hai_rate[8];\n\t__u32 rpg_gd[8];\n\t__u32 rpg_min_dec_fac[8];\n\t__u32 rpg_min_rate[8];\n\t__u32 cndd_state_machine[8];\n};\n\nstruct ieee_qcn_stats {\n\t__u64 rppp_rp_centiseconds[8];\n\t__u32 rppp_created_rps[8];\n};\n\nstruct ieee_pfc {\n\t__u8 pfc_cap;\n\t__u8 pfc_en;\n\t__u8 mbc;\n\t__u16 delay;\n\t__u64 requests[8];\n\t__u64 indications[8];\n};\n\nstruct dcbnl_buffer {\n\t__u8 prio2buffer[8];\n\t__u32 buffer_size[8];\n\t__u32 total_size;\n};\n\nstruct cee_pg {\n\t__u8 willing;\n\t__u8 error;\n\t__u8 pg_en;\n\t__u8 tcs_supported;\n\t__u8 pg_bw[8];\n\t__u8 prio_pg[8];\n};\n\nstruct cee_pfc {\n\t__u8 willing;\n\t__u8 error;\n\t__u8 pfc_en;\n\t__u8 tcs_supported;\n};\n\nstruct dcb_app {\n\t__u8 selector;\n\t__u8 priority;\n\t__u16 protocol;\n};\n\nstruct dcb_peer_app_info {\n\t__u8 willing;\n\t__u8 error;\n};\n\nstruct dcbnl_rtnl_ops {\n\tint (*ieee_getets)(struct net_device *, struct ieee_ets *);\n\tint (*ieee_setets)(struct net_device *, struct ieee_ets *);\n\tint (*ieee_getmaxrate)(struct net_device *, struct ieee_maxrate *);\n\tint (*ieee_setmaxrate)(struct net_device *, struct ieee_maxrate *);\n\tint (*ieee_getqcn)(struct net_device *, struct ieee_qcn *);\n\tint (*ieee_setqcn)(struct net_device *, struct ieee_qcn *);\n\tint (*ieee_getqcnstats)(struct net_device *, struct ieee_qcn_stats *);\n\tint (*ieee_getpfc)(struct net_device *, struct ieee_pfc *);\n\tint (*ieee_setpfc)(struct net_device *, struct ieee_pfc *);\n\tint (*ieee_getapp)(struct net_device *, struct dcb_app *);\n\tint (*ieee_setapp)(struct net_device *, struct dcb_app *);\n\tint (*ieee_delapp)(struct net_device *, struct dcb_app *);\n\tint (*ieee_peer_getets)(struct net_device *, struct ieee_ets *);\n\tint (*ieee_peer_getpfc)(struct net_device *, struct ieee_pfc *);\n\tu8 (*getstate)(struct net_device *);\n\tu8 (*setstate)(struct net_device *, u8);\n\tvoid (*getpermhwaddr)(struct net_device *, u8 *);\n\tvoid (*setpgtccfgtx)(struct net_device *, int, u8, u8, u8, u8);\n\tvoid (*setpgbwgcfgtx)(struct net_device *, int, u8);\n\tvoid (*setpgtccfgrx)(struct net_device *, int, u8, u8, u8, u8);\n\tvoid (*setpgbwgcfgrx)(struct net_device *, int, u8);\n\tvoid (*getpgtccfgtx)(struct net_device *, int, u8 *, u8 *, u8 *, u8 *);\n\tvoid (*getpgbwgcfgtx)(struct net_device *, int, u8 *);\n\tvoid (*getpgtccfgrx)(struct net_device *, int, u8 *, u8 *, u8 *, u8 *);\n\tvoid (*getpgbwgcfgrx)(struct net_device *, int, u8 *);\n\tvoid (*setpfccfg)(struct net_device *, int, u8);\n\tvoid (*getpfccfg)(struct net_device *, int, u8 *);\n\tu8 (*setall)(struct net_device *);\n\tu8 (*getcap)(struct net_device *, int, u8 *);\n\tint (*getnumtcs)(struct net_device *, int, u8 *);\n\tint (*setnumtcs)(struct net_device *, int, u8);\n\tu8 (*getpfcstate)(struct net_device *);\n\tvoid (*setpfcstate)(struct net_device *, u8);\n\tvoid (*getbcncfg)(struct net_device *, int, u32 *);\n\tvoid (*setbcncfg)(struct net_device *, int, u32);\n\tvoid (*getbcnrp)(struct net_device *, int, u8 *);\n\tvoid (*setbcnrp)(struct net_device *, int, u8);\n\tint (*setapp)(struct net_device *, u8, u16, u8);\n\tint (*getapp)(struct net_device *, u8, u16);\n\tu8 (*getfeatcfg)(struct net_device *, int, u8 *);\n\tu8 (*setfeatcfg)(struct net_device *, int, u8);\n\tu8 (*getdcbx)(struct net_device *);\n\tu8 (*setdcbx)(struct net_device *, u8);\n\tint (*peer_getappinfo)(struct net_device *, struct dcb_peer_app_info *, u16 *);\n\tint (*peer_getapptable)(struct net_device *, struct dcb_app *);\n\tint (*cee_peer_getpg)(struct net_device *, struct cee_pg *);\n\tint (*cee_peer_getpfc)(struct net_device *, struct cee_pfc *);\n\tint (*dcbnl_getbuffer)(struct net_device *, struct dcbnl_buffer *);\n\tint (*dcbnl_setbuffer)(struct net_device *, struct dcbnl_buffer *);\n};\n\nstruct netprio_map {\n\tstruct callback_head rcu;\n\tu32 priomap_len;\n\tu32 priomap[0];\n};\n\nstruct xdp_mem_info {\n\tu32 type;\n\tu32 id;\n};\n\nstruct xdp_rxq_info {\n\tstruct net_device *dev;\n\tu32 queue_index;\n\tu32 reg_state;\n\tstruct xdp_mem_info mem;\n\tunsigned int napi_id;\n\tlong: 32;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct xdp_txq_info {\n\tstruct net_device *dev;\n};\n\nstruct xdp_buff {\n\tvoid *data;\n\tvoid *data_end;\n\tvoid *data_meta;\n\tvoid *data_hard_start;\n\tstruct xdp_rxq_info *rxq;\n\tstruct xdp_txq_info *txq;\n\tu32 frame_sz;\n};\n\nstruct xdp_frame {\n\tvoid *data;\n\tu16 len;\n\tu16 headroom;\n\tu32 metasize: 8;\n\tu32 frame_sz: 24;\n\tstruct xdp_mem_info mem;\n\tstruct net_device *dev_rx;\n};\n\nstruct nlmsghdr {\n\t__u32 nlmsg_len;\n\t__u16 nlmsg_type;\n\t__u16 nlmsg_flags;\n\t__u32 nlmsg_seq;\n\t__u32 nlmsg_pid;\n};\n\nstruct nlattr {\n\t__u16 nla_len;\n\t__u16 nla_type;\n};\n\nstruct netlink_ext_ack {\n\tconst char *_msg;\n\tconst struct nlattr *bad_attr;\n\tconst struct nla_policy *policy;\n\tu8 cookie[20];\n\tu8 cookie_len;\n};\n\nstruct netlink_range_validation;\n\nstruct netlink_range_validation_signed;\n\nstruct nla_policy {\n\tu8 type;\n\tu8 validation_type;\n\tu16 len;\n\tunion {\n\t\tconst u32 bitfield32_valid;\n\t\tconst u32 mask;\n\t\tconst char *reject_message;\n\t\tconst struct nla_policy *nested_policy;\n\t\tstruct netlink_range_validation *range;\n\t\tstruct netlink_range_validation_signed *range_signed;\n\t\tstruct {\n\t\t\ts16 min;\n\t\t\ts16 max;\n\t\t};\n\t\tint (*validate)(const struct nlattr *, struct netlink_ext_ack *);\n\t\tu16 strict_start_type;\n\t};\n};\n\nstruct netlink_callback {\n\tstruct sk_buff *skb;\n\tconst struct nlmsghdr *nlh;\n\tint (*dump)(struct sk_buff *, struct netlink_callback *);\n\tint (*done)(struct netlink_callback *);\n\tvoid *data;\n\tstruct module *module;\n\tstruct netlink_ext_ack *extack;\n\tu16 family;\n\tu16 answer_flags;\n\tu32 min_dump_alloc;\n\tunsigned int prev_seq;\n\tunsigned int seq;\n\tbool strict_check;\n\tunion {\n\t\tu8 ctx[48];\n\t\tlong int args[6];\n\t};\n};\n\nstruct ndmsg {\n\t__u8 ndm_family;\n\t__u8 ndm_pad1;\n\t__u16 ndm_pad2;\n\t__s32 ndm_ifindex;\n\t__u16 ndm_state;\n\t__u8 ndm_flags;\n\t__u8 ndm_type;\n};\n\nstruct rtnl_link_stats64 {\n\t__u64 rx_packets;\n\t__u64 tx_packets;\n\t__u64 rx_bytes;\n\t__u64 tx_bytes;\n\t__u64 rx_errors;\n\t__u64 tx_errors;\n\t__u64 rx_dropped;\n\t__u64 tx_dropped;\n\t__u64 multicast;\n\t__u64 collisions;\n\t__u64 rx_length_errors;\n\t__u64 rx_over_errors;\n\t__u64 rx_crc_errors;\n\t__u64 rx_frame_errors;\n\t__u64 rx_fifo_errors;\n\t__u64 rx_missed_errors;\n\t__u64 tx_aborted_errors;\n\t__u64 tx_carrier_errors;\n\t__u64 tx_fifo_errors;\n\t__u64 tx_heartbeat_errors;\n\t__u64 tx_window_errors;\n\t__u64 rx_compressed;\n\t__u64 tx_compressed;\n\t__u64 rx_nohandler;\n};\n\nstruct ifla_vf_guid {\n\t__u32 vf;\n\t__u64 guid;\n};\n\nstruct ifla_vf_stats {\n\t__u64 rx_packets;\n\t__u64 tx_packets;\n\t__u64 rx_bytes;\n\t__u64 tx_bytes;\n\t__u64 broadcast;\n\t__u64 multicast;\n\t__u64 rx_dropped;\n\t__u64 tx_dropped;\n};\n\nstruct ifla_vf_info {\n\t__u32 vf;\n\t__u8 mac[32];\n\t__u32 vlan;\n\t__u32 qos;\n\t__u32 spoofchk;\n\t__u32 linkstate;\n\t__u32 min_tx_rate;\n\t__u32 max_tx_rate;\n\t__u32 rss_query_en;\n\t__u32 trusted;\n\t__be16 vlan_proto;\n};\n\nstruct tc_stats {\n\t__u64 bytes;\n\t__u32 packets;\n\t__u32 drops;\n\t__u32 overlimits;\n\t__u32 bps;\n\t__u32 pps;\n\t__u32 qlen;\n\t__u32 backlog;\n};\n\nstruct tc_sizespec {\n\tunsigned char cell_log;\n\tunsigned char size_log;\n\tshort int cell_align;\n\tint overhead;\n\tunsigned int linklayer;\n\tunsigned int mpu;\n\tunsigned int mtu;\n\tunsigned int tsize;\n};\n\nenum netdev_tx {\n\t__NETDEV_TX_MIN = 2147483648,\n\tNETDEV_TX_OK = 0,\n\tNETDEV_TX_BUSY = 16,\n};\n\ntypedef enum netdev_tx netdev_tx_t;\n\nstruct header_ops {\n\tint (*create)(struct sk_buff *, struct net_device *, short unsigned int, const void *, const void *, unsigned int);\n\tint (*parse)(const struct sk_buff *, unsigned char *);\n\tint (*cache)(const struct neighbour *, struct hh_cache *, __be16);\n\tvoid (*cache_update)(struct hh_cache *, const struct net_device *, const unsigned char *);\n\tbool (*validate)(const char *, unsigned int);\n\t__be16 (*parse_protocol)(const struct sk_buff *);\n};\n\nstruct xsk_buff_pool;\n\nstruct netdev_queue {\n\tstruct net_device *dev;\n\tstruct Qdisc *qdisc;\n\tstruct Qdisc *qdisc_sleeping;\n\tstruct kobject kobj;\n\tint numa_node;\n\tlong unsigned int tx_maxrate;\n\tlong unsigned int trans_timeout;\n\tstruct net_device *sb_dev;\n\tstruct xsk_buff_pool *pool;\n\tspinlock_t _xmit_lock;\n\tint xmit_lock_owner;\n\tlong unsigned int trans_start;\n\tlong unsigned int state;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct dql dql;\n};\n\nstruct qdisc_skb_head {\n\tstruct sk_buff *head;\n\tstruct sk_buff *tail;\n\t__u32 qlen;\n\tspinlock_t lock;\n};\n\nstruct gnet_stats_basic_packed {\n\t__u64 bytes;\n\t__u64 packets;\n};\n\nstruct gnet_stats_queue {\n\t__u32 qlen;\n\t__u32 backlog;\n\t__u32 drops;\n\t__u32 requeues;\n\t__u32 overlimits;\n};\n\nstruct Qdisc_ops;\n\nstruct qdisc_size_table;\n\nstruct net_rate_estimator;\n\nstruct gnet_stats_basic_cpu;\n\nstruct Qdisc {\n\tint (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);\n\tstruct sk_buff * (*dequeue)(struct Qdisc *);\n\tunsigned int flags;\n\tu32 limit;\n\tconst struct Qdisc_ops *ops;\n\tstruct qdisc_size_table *stab;\n\tstruct hlist_node hash;\n\tu32 handle;\n\tu32 parent;\n\tstruct netdev_queue *dev_queue;\n\tstruct net_rate_estimator *rate_est;\n\tstruct gnet_stats_basic_cpu *cpu_bstats;\n\tstruct gnet_stats_queue *cpu_qstats;\n\tint pad;\n\trefcount_t refcnt;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct sk_buff_head gso_skb;\n\tstruct qdisc_skb_head q;\n\tstruct gnet_stats_basic_packed bstats;\n\tseqcount_t running;\n\tstruct gnet_stats_queue qstats;\n\tlong unsigned int state;\n\tstruct Qdisc *next_sched;\n\tstruct sk_buff_head skb_bad_txq;\n\tspinlock_t busylock;\n\tspinlock_t seqlock;\n\tstruct callback_head rcu;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong int privdata[0];\n};\n\nstruct rps_map {\n\tunsigned int len;\n\tstruct callback_head rcu;\n\tu16 cpus[0];\n};\n\nstruct rps_dev_flow {\n\tu16 cpu;\n\tu16 filter;\n\tunsigned int last_qtail;\n};\n\nstruct rps_dev_flow_table {\n\tunsigned int mask;\n\tstruct callback_head rcu;\n\tstruct rps_dev_flow flows[0];\n};\n\nstruct netdev_rx_queue {\n\tstruct xdp_rxq_info xdp_rxq;\n\tstruct rps_map *rps_map;\n\tstruct rps_dev_flow_table *rps_flow_table;\n\tstruct kobject kobj;\n\tstruct net_device *dev;\n\tstruct xsk_buff_pool *pool;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct xps_map {\n\tunsigned int len;\n\tunsigned int alloc_len;\n\tstruct callback_head rcu;\n\tu16 queues[0];\n};\n\nstruct xps_dev_maps {\n\tstruct callback_head rcu;\n\tunsigned int nr_ids;\n\ts16 num_tc;\n\tstruct xps_map *attr_map[0];\n};\n\nstruct netdev_fcoe_hbainfo {\n\tchar manufacturer[64];\n\tchar serial_number[64];\n\tchar hardware_version[64];\n\tchar driver_version[64];\n\tchar optionrom_version[64];\n\tchar firmware_version[64];\n\tchar model[256];\n\tchar model_description[256];\n};\n\nstruct netdev_phys_item_id {\n\tunsigned char id[32];\n\tunsigned char id_len;\n};\n\nenum net_device_path_type {\n\tDEV_PATH_ETHERNET = 0,\n\tDEV_PATH_VLAN = 1,\n\tDEV_PATH_BRIDGE = 2,\n\tDEV_PATH_PPPOE = 3,\n\tDEV_PATH_DSA = 4,\n};\n\nstruct net_device_path {\n\tenum net_device_path_type type;\n\tconst struct net_device *dev;\n\tunion {\n\t\tstruct {\n\t\t\tu16 id;\n\t\t\t__be16 proto;\n\t\t\tu8 h_dest[6];\n\t\t} encap;\n\t\tstruct {\n\t\t\tenum {\n\t\t\t\tDEV_PATH_BR_VLAN_KEEP = 0,\n\t\t\t\tDEV_PATH_BR_VLAN_TAG = 1,\n\t\t\t\tDEV_PATH_BR_VLAN_UNTAG = 2,\n\t\t\t\tDEV_PATH_BR_VLAN_UNTAG_HW = 3,\n\t\t\t} vlan_mode;\n\t\t\tu16 vlan_id;\n\t\t\t__be16 vlan_proto;\n\t\t} bridge;\n\t\tstruct {\n\t\t\tint port;\n\t\t\tu16 proto;\n\t\t} dsa;\n\t};\n};\n\nstruct net_device_path_ctx {\n\tconst struct net_device *dev;\n\tu8 daddr[6];\n\tint num_vlans;\n\tstruct {\n\t\tu16 id;\n\t\t__be16 proto;\n\t} vlan[2];\n};\n\nenum tc_setup_type {\n\tTC_SETUP_QDISC_MQPRIO = 0,\n\tTC_SETUP_CLSU32 = 1,\n\tTC_SETUP_CLSFLOWER = 2,\n\tTC_SETUP_CLSMATCHALL = 3,\n\tTC_SETUP_CLSBPF = 4,\n\tTC_SETUP_BLOCK = 5,\n\tTC_SETUP_QDISC_CBS = 6,\n\tTC_SETUP_QDISC_RED = 7,\n\tTC_SETUP_QDISC_PRIO = 8,\n\tTC_SETUP_QDISC_MQ = 9,\n\tTC_SETUP_QDISC_ETF = 10,\n\tTC_SETUP_ROOT_QDISC = 11,\n\tTC_SETUP_QDISC_GRED = 12,\n\tTC_SETUP_QDISC_TAPRIO = 13,\n\tTC_SETUP_FT = 14,\n\tTC_SETUP_QDISC_ETS = 15,\n\tTC_SETUP_QDISC_TBF = 16,\n\tTC_SETUP_QDISC_FIFO = 17,\n\tTC_SETUP_QDISC_HTB = 18,\n};\n\nenum bpf_netdev_command {\n\tXDP_SETUP_PROG = 0,\n\tXDP_SETUP_PROG_HW = 1,\n\tBPF_OFFLOAD_MAP_ALLOC = 2,\n\tBPF_OFFLOAD_MAP_FREE = 3,\n\tXDP_SETUP_XSK_POOL = 4,\n};\n\nstruct netdev_bpf {\n\tenum bpf_netdev_command command;\n\tunion {\n\t\tstruct {\n\t\t\tu32 flags;\n\t\t\tstruct bpf_prog *prog;\n\t\t\tstruct netlink_ext_ack *extack;\n\t\t};\n\t\tstruct {\n\t\t\tstruct bpf_offloaded_map *offmap;\n\t\t};\n\t\tstruct {\n\t\t\tstruct xsk_buff_pool *pool;\n\t\t\tu16 queue_id;\n\t\t} xsk;\n\t};\n};\n\nstruct xfrmdev_ops {\n\tint (*xdo_dev_state_add)(struct xfrm_state *);\n\tvoid (*xdo_dev_state_delete)(struct xfrm_state *);\n\tvoid (*xdo_dev_state_free)(struct xfrm_state *);\n\tbool (*xdo_dev_offload_ok)(struct sk_buff *, struct xfrm_state *);\n\tvoid (*xdo_dev_state_advance_esn)(struct xfrm_state *);\n};\n\nstruct dev_ifalias {\n\tstruct callback_head rcuhead;\n\tchar ifalias[0];\n};\n\nstruct netdev_name_node {\n\tstruct hlist_node hlist;\n\tstruct list_head list;\n\tstruct net_device *dev;\n\tconst char *name;\n};\n\nstruct devlink_port;\n\nstruct ip_tunnel_parm;\n\nstruct net_device_ops {\n\tint (*ndo_init)(struct net_device *);\n\tvoid (*ndo_uninit)(struct net_device *);\n\tint (*ndo_open)(struct net_device *);\n\tint (*ndo_stop)(struct net_device *);\n\tnetdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *);\n\tnetdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t);\n\tu16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, struct net_device *);\n\tvoid (*ndo_change_rx_flags)(struct net_device *, int);\n\tvoid (*ndo_set_rx_mode)(struct net_device *);\n\tint (*ndo_set_mac_address)(struct net_device *, void *);\n\tint (*ndo_validate_addr)(struct net_device *);\n\tint (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int);\n\tint (*ndo_eth_ioctl)(struct net_device *, struct ifreq *, int);\n\tint (*ndo_siocbond)(struct net_device *, struct ifreq *, int);\n\tint (*ndo_siocwandev)(struct net_device *, struct if_settings *);\n\tint (*ndo_siocdevprivate)(struct net_device *, struct ifreq *, void *, int);\n\tint (*ndo_set_config)(struct net_device *, struct ifmap *);\n\tint (*ndo_change_mtu)(struct net_device *, int);\n\tint (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *);\n\tvoid (*ndo_tx_timeout)(struct net_device *, unsigned int);\n\tvoid (*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *);\n\tbool (*ndo_has_offload_stats)(const struct net_device *, int);\n\tint (*ndo_get_offload_stats)(int, const struct net_device *, void *);\n\tstruct net_device_stats * (*ndo_get_stats)(struct net_device *);\n\tint (*ndo_vlan_rx_add_vid)(struct net_device *, __be16, u16);\n\tint (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16, u16);\n\tvoid (*ndo_poll_controller)(struct net_device *);\n\tint (*ndo_netpoll_setup)(struct net_device *, struct netpoll_info *);\n\tvoid (*ndo_netpoll_cleanup)(struct net_device *);\n\tint (*ndo_set_vf_mac)(struct net_device *, int, u8 *);\n\tint (*ndo_set_vf_vlan)(struct net_device *, int, u16, u8, __be16);\n\tint (*ndo_set_vf_rate)(struct net_device *, int, int, int);\n\tint (*ndo_set_vf_spoofchk)(struct net_device *, int, bool);\n\tint (*ndo_set_vf_trust)(struct net_device *, int, bool);\n\tint (*ndo_get_vf_config)(struct net_device *, int, struct ifla_vf_info *);\n\tint (*ndo_set_vf_link_state)(struct net_device *, int, int);\n\tint (*ndo_get_vf_stats)(struct net_device *, int, struct ifla_vf_stats *);\n\tint (*ndo_set_vf_port)(struct net_device *, int, struct nlattr **);\n\tint (*ndo_get_vf_port)(struct net_device *, int, struct sk_buff *);\n\tint (*ndo_get_vf_guid)(struct net_device *, int, struct ifla_vf_guid *, struct ifla_vf_guid *);\n\tint (*ndo_set_vf_guid)(struct net_device *, int, u64, int);\n\tint (*ndo_set_vf_rss_query_en)(struct net_device *, int, bool);\n\tint (*ndo_setup_tc)(struct net_device *, enum tc_setup_type, void *);\n\tint (*ndo_fcoe_enable)(struct net_device *);\n\tint (*ndo_fcoe_disable)(struct net_device *);\n\tint (*ndo_fcoe_ddp_setup)(struct net_device *, u16, struct scatterlist *, unsigned int);\n\tint (*ndo_fcoe_ddp_done)(struct net_device *, u16);\n\tint (*ndo_fcoe_ddp_target)(struct net_device *, u16, struct scatterlist *, unsigned int);\n\tint (*ndo_fcoe_get_hbainfo)(struct net_device *, struct netdev_fcoe_hbainfo *);\n\tint (*ndo_fcoe_get_wwn)(struct net_device *, u64 *, int);\n\tint (*ndo_rx_flow_steer)(struct net_device *, const struct sk_buff *, u16, u32);\n\tint (*ndo_add_slave)(struct net_device *, struct net_device *, struct netlink_ext_ack *);\n\tint (*ndo_del_slave)(struct net_device *, struct net_device *);\n\tstruct net_device * (*ndo_get_xmit_slave)(struct net_device *, struct sk_buff *, bool);\n\tstruct net_device * (*ndo_sk_get_lower_dev)(struct net_device *, struct sock *);\n\tnetdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t);\n\tint (*ndo_set_features)(struct net_device *, netdev_features_t);\n\tint (*ndo_neigh_construct)(struct net_device *, struct neighbour *);\n\tvoid (*ndo_neigh_destroy)(struct net_device *, struct neighbour *);\n\tint (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, u16, struct netlink_ext_ack *);\n\tint (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16);\n\tint (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *);\n\tint (*ndo_fdb_get)(struct sk_buff *, struct nlattr **, struct net_device *, const unsigned char *, u16, u32, u32, struct netlink_ext_ack *);\n\tint (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16, struct netlink_ext_ack *);\n\tint (*ndo_bridge_getlink)(struct sk_buff *, u32, u32, struct net_device *, u32, int);\n\tint (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16);\n\tint (*ndo_change_carrier)(struct net_device *, bool);\n\tint (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *);\n\tint (*ndo_get_port_parent_id)(struct net_device *, struct netdev_phys_item_id *);\n\tint (*ndo_get_phys_port_name)(struct net_device *, char *, size_t);\n\tvoid * (*ndo_dfwd_add_station)(struct net_device *, struct net_device *);\n\tvoid (*ndo_dfwd_del_station)(struct net_device *, void *);\n\tint (*ndo_set_tx_maxrate)(struct net_device *, int, u32);\n\tint (*ndo_get_iflink)(const struct net_device *);\n\tint (*ndo_change_proto_down)(struct net_device *, bool);\n\tint (*ndo_fill_metadata_dst)(struct net_device *, struct sk_buff *);\n\tvoid (*ndo_set_rx_headroom)(struct net_device *, int);\n\tint (*ndo_bpf)(struct net_device *, struct netdev_bpf *);\n\tint (*ndo_xdp_xmit)(struct net_device *, int, struct xdp_frame **, u32);\n\tstruct net_device * (*ndo_xdp_get_xmit_slave)(struct net_device *, struct xdp_buff *);\n\tint (*ndo_xsk_wakeup)(struct net_device *, u32, u32);\n\tstruct devlink_port * (*ndo_get_devlink_port)(struct net_device *);\n\tint (*ndo_tunnel_ctl)(struct net_device *, struct ip_tunnel_parm *, int);\n\tstruct net_device * (*ndo_get_peer_dev)(struct net_device *);\n\tint (*ndo_fill_forward_path)(struct net_device_path_ctx *, struct net_device_path *);\n};\n\nstruct neigh_parms {\n\tpossible_net_t net;\n\tstruct net_device *dev;\n\tstruct list_head list;\n\tint (*neigh_setup)(struct neighbour *);\n\tstruct neigh_table *tbl;\n\tvoid *sysctl_table;\n\tint dead;\n\trefcount_t refcnt;\n\tstruct callback_head callback_head;\n\tint reachable_time;\n\tint data[13];\n\tlong unsigned int data_state[1];\n};\n\nstruct pcpu_lstats {\n\tu64_stats_t packets;\n\tu64_stats_t bytes;\n\tstruct u64_stats_sync syncp;\n};\n\nstruct pcpu_sw_netstats {\n\tu64 rx_packets;\n\tu64 rx_bytes;\n\tu64 tx_packets;\n\tu64 tx_bytes;\n\tstruct u64_stats_sync syncp;\n};\n\nstruct iw_request_info;\n\nunion iwreq_data;\n\ntypedef int (*iw_handler)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *);\n\nstruct iw_priv_args;\n\nstruct iw_statistics;\n\nstruct iw_handler_def {\n\tconst iw_handler *standard;\n\t__u16 num_standard;\n\t__u16 num_private;\n\t__u16 num_private_args;\n\tconst iw_handler *private;\n\tconst struct iw_priv_args *private_args;\n\tstruct iw_statistics * (*get_wireless_stats)(struct net_device *);\n};\n\nenum ethtool_phys_id_state {\n\tETHTOOL_ID_INACTIVE = 0,\n\tETHTOOL_ID_ACTIVE = 1,\n\tETHTOOL_ID_ON = 2,\n\tETHTOOL_ID_OFF = 3,\n};\n\nstruct ethtool_drvinfo;\n\nstruct ethtool_regs;\n\nstruct ethtool_wolinfo;\n\nstruct ethtool_link_ext_state_info;\n\nstruct ethtool_eeprom;\n\nstruct ethtool_coalesce;\n\nstruct kernel_ethtool_coalesce;\n\nstruct ethtool_ringparam;\n\nstruct ethtool_pause_stats;\n\nstruct ethtool_pauseparam;\n\nstruct ethtool_test;\n\nstruct ethtool_stats;\n\nstruct ethtool_rxnfc;\n\nstruct ethtool_flash;\n\nstruct ethtool_channels;\n\nstruct ethtool_dump;\n\nstruct ethtool_ts_info;\n\nstruct ethtool_modinfo;\n\nstruct ethtool_eee;\n\nstruct ethtool_tunable;\n\nstruct ethtool_link_ksettings;\n\nstruct ethtool_fec_stats;\n\nstruct ethtool_fecparam;\n\nstruct ethtool_module_eeprom;\n\nstruct ethtool_eth_phy_stats;\n\nstruct ethtool_eth_mac_stats;\n\nstruct ethtool_eth_ctrl_stats;\n\nstruct ethtool_rmon_stats;\n\nstruct ethtool_rmon_hist_range;\n\nstruct ethtool_ops {\n\tu32 cap_link_lanes_supported: 1;\n\tu32 supported_coalesce_params;\n\tvoid (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);\n\tint (*get_regs_len)(struct net_device *);\n\tvoid (*get_regs)(struct net_device *, struct ethtool_regs *, void *);\n\tvoid (*get_wol)(struct net_device *, struct ethtool_wolinfo *);\n\tint (*set_wol)(struct net_device *, struct ethtool_wolinfo *);\n\tu32 (*get_msglevel)(struct net_device *);\n\tvoid (*set_msglevel)(struct net_device *, u32);\n\tint (*nway_reset)(struct net_device *);\n\tu32 (*get_link)(struct net_device *);\n\tint (*get_link_ext_state)(struct net_device *, struct ethtool_link_ext_state_info *);\n\tint (*get_eeprom_len)(struct net_device *);\n\tint (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);\n\tint (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);\n\tint (*get_coalesce)(struct net_device *, struct ethtool_coalesce *, struct kernel_ethtool_coalesce *, struct netlink_ext_ack *);\n\tint (*set_coalesce)(struct net_device *, struct ethtool_coalesce *, struct kernel_ethtool_coalesce *, struct netlink_ext_ack *);\n\tvoid (*get_ringparam)(struct net_device *, struct ethtool_ringparam *);\n\tint (*set_ringparam)(struct net_device *, struct ethtool_ringparam *);\n\tvoid (*get_pause_stats)(struct net_device *, struct ethtool_pause_stats *);\n\tvoid (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *);\n\tint (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *);\n\tvoid (*self_test)(struct net_device *, struct ethtool_test *, u64 *);\n\tvoid (*get_strings)(struct net_device *, u32, u8 *);\n\tint (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state);\n\tvoid (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *);\n\tint (*begin)(struct net_device *);\n\tvoid (*complete)(struct net_device *);\n\tu32 (*get_priv_flags)(struct net_device *);\n\tint (*set_priv_flags)(struct net_device *, u32);\n\tint (*get_sset_count)(struct net_device *, int);\n\tint (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *);\n\tint (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);\n\tint (*flash_device)(struct net_device *, struct ethtool_flash *);\n\tint (*reset)(struct net_device *, u32 *);\n\tu32 (*get_rxfh_key_size)(struct net_device *);\n\tu32 (*get_rxfh_indir_size)(struct net_device *);\n\tint (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *);\n\tint (*set_rxfh)(struct net_device *, const u32 *, const u8 *, const u8);\n\tint (*get_rxfh_context)(struct net_device *, u32 *, u8 *, u8 *, u32);\n\tint (*set_rxfh_context)(struct net_device *, const u32 *, const u8 *, const u8, u32 *, bool);\n\tvoid (*get_channels)(struct net_device *, struct ethtool_channels *);\n\tint (*set_channels)(struct net_device *, struct ethtool_channels *);\n\tint (*get_dump_flag)(struct net_device *, struct ethtool_dump *);\n\tint (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *);\n\tint (*set_dump)(struct net_device *, struct ethtool_dump *);\n\tint (*get_ts_info)(struct net_device *, struct ethtool_ts_info *);\n\tint (*get_module_info)(struct net_device *, struct ethtool_modinfo *);\n\tint (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);\n\tint (*get_eee)(struct net_device *, struct ethtool_eee *);\n\tint (*set_eee)(struct net_device *, struct ethtool_eee *);\n\tint (*get_tunable)(struct net_device *, const struct ethtool_tunable *, void *);\n\tint (*set_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);\n\tint (*get_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);\n\tint (*set_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);\n\tint (*get_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *);\n\tint (*set_link_ksettings)(struct net_device *, const struct ethtool_link_ksettings *);\n\tvoid (*get_fec_stats)(struct net_device *, struct ethtool_fec_stats *);\n\tint (*get_fecparam)(struct net_device *, struct ethtool_fecparam *);\n\tint (*set_fecparam)(struct net_device *, struct ethtool_fecparam *);\n\tvoid (*get_ethtool_phy_stats)(struct net_device *, struct ethtool_stats *, u64 *);\n\tint (*get_phy_tunable)(struct net_device *, const struct ethtool_tunable *, void *);\n\tint (*set_phy_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);\n\tint (*get_module_eeprom_by_page)(struct net_device *, const struct ethtool_module_eeprom *, struct netlink_ext_ack *);\n\tvoid (*get_eth_phy_stats)(struct net_device *, struct ethtool_eth_phy_stats *);\n\tvoid (*get_eth_mac_stats)(struct net_device *, struct ethtool_eth_mac_stats *);\n\tvoid (*get_eth_ctrl_stats)(struct net_device *, struct ethtool_eth_ctrl_stats *);\n\tvoid (*get_rmon_stats)(struct net_device *, struct ethtool_rmon_stats *, const struct ethtool_rmon_hist_range **);\n};\n\nstruct l3mdev_ops {\n\tu32 (*l3mdev_fib_table)(const struct net_device *);\n\tstruct sk_buff * (*l3mdev_l3_rcv)(struct net_device *, struct sk_buff *, u16);\n\tstruct sk_buff * (*l3mdev_l3_out)(struct net_device *, struct sock *, struct sk_buff *, u16);\n\tstruct dst_entry * (*l3mdev_link_scope_lookup)(const struct net_device *, struct flowi6 *);\n};\n\nstruct nd_opt_hdr;\n\nstruct ndisc_options;\n\nstruct prefix_info;\n\nstruct ndisc_ops {\n\tint (*is_useropt)(u8);\n\tint (*parse_options)(const struct net_device *, struct nd_opt_hdr *, struct ndisc_options *);\n\tvoid (*update)(const struct net_device *, struct neighbour *, u32, u8, const struct ndisc_options *);\n\tint (*opt_addr_space)(const struct net_device *, u8, struct neighbour *, u8 *, u8 **);\n\tvoid (*fill_addr_option)(const struct net_device *, struct sk_buff *, u8, const u8 *);\n\tvoid (*prefix_rcv_add_addr)(struct net *, struct net_device *, const struct prefix_info *, struct inet6_dev *, struct in6_addr *, int, u32, bool, bool, __u32, u32, bool);\n};\n\nenum tls_offload_ctx_dir {\n\tTLS_OFFLOAD_CTX_DIR_RX = 0,\n\tTLS_OFFLOAD_CTX_DIR_TX = 1,\n};\n\nstruct tls_crypto_info;\n\nstruct tls_context;\n\nstruct tlsdev_ops {\n\tint (*tls_dev_add)(struct net_device *, struct sock *, enum tls_offload_ctx_dir, struct tls_crypto_info *, u32);\n\tvoid (*tls_dev_del)(struct net_device *, struct tls_context *, enum tls_offload_ctx_dir);\n\tint (*tls_dev_resync)(struct net_device *, struct sock *, u32, u8 *, enum tls_offload_ctx_dir);\n};\n\nstruct ipv6_devstat {\n\tstruct proc_dir_entry *proc_dir_entry;\n\tstruct ipstats_mib *ipv6;\n\tstruct icmpv6_mib_device *icmpv6dev;\n\tstruct icmpv6msg_mib_device *icmpv6msgdev;\n};\n\nstruct ifmcaddr6;\n\nstruct ifacaddr6;\n\nstruct inet6_dev {\n\tstruct net_device *dev;\n\tstruct list_head addr_list;\n\tstruct ifmcaddr6 *mc_list;\n\tstruct ifmcaddr6 *mc_tomb;\n\tunsigned char mc_qrv;\n\tunsigned char mc_gq_running;\n\tunsigned char mc_ifc_count;\n\tunsigned char mc_dad_count;\n\tlong unsigned int mc_v1_seen;\n\tlong unsigned int mc_qi;\n\tlong unsigned int mc_qri;\n\tlong unsigned int mc_maxdelay;\n\tstruct delayed_work mc_gq_work;\n\tstruct delayed_work mc_ifc_work;\n\tstruct delayed_work mc_dad_work;\n\tstruct delayed_work mc_query_work;\n\tstruct delayed_work mc_report_work;\n\tstruct sk_buff_head mc_query_queue;\n\tstruct sk_buff_head mc_report_queue;\n\tspinlock_t mc_query_lock;\n\tspinlock_t mc_report_lock;\n\tstruct mutex mc_lock;\n\tstruct ifacaddr6 *ac_list;\n\trwlock_t lock;\n\trefcount_t refcnt;\n\t__u32 if_flags;\n\tint dead;\n\tu32 desync_factor;\n\tstruct list_head tempaddr_list;\n\tstruct in6_addr token;\n\tstruct neigh_parms *nd_parms;\n\tstruct ipv6_devconf cnf;\n\tstruct ipv6_devstat stats;\n\tstruct timer_list rs_timer;\n\t__s32 rs_interval;\n\t__u8 rs_probes;\n\tlong unsigned int tstamp;\n\tstruct callback_head rcu;\n\tunsigned int ra_mtu;\n};\n\nstruct tcf_proto;\n\nstruct tcf_block;\n\nstruct mini_Qdisc {\n\tstruct tcf_proto *filter_list;\n\tstruct tcf_block *block;\n\tstruct gnet_stats_basic_cpu *cpu_bstats;\n\tstruct gnet_stats_queue *cpu_qstats;\n\tstruct callback_head rcu;\n};\n\nstruct rtnl_link_ops {\n\tstruct list_head list;\n\tconst char *kind;\n\tsize_t priv_size;\n\tstruct net_device * (*alloc)(struct nlattr **, const char *, unsigned char, unsigned int, unsigned int);\n\tvoid (*setup)(struct net_device *);\n\tbool netns_refund;\n\tunsigned int maxtype;\n\tconst struct nla_policy *policy;\n\tint (*validate)(struct nlattr **, struct nlattr **, struct netlink_ext_ack *);\n\tint (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);\n\tint (*changelink)(struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);\n\tvoid (*dellink)(struct net_device *, struct list_head *);\n\tsize_t (*get_size)(const struct net_device *);\n\tint (*fill_info)(struct sk_buff *, const struct net_device *);\n\tsize_t (*get_xstats_size)(const struct net_device *);\n\tint (*fill_xstats)(struct sk_buff *, const struct net_device *);\n\tunsigned int (*get_num_tx_queues)();\n\tunsigned int (*get_num_rx_queues)();\n\tunsigned int slave_maxtype;\n\tconst struct nla_policy *slave_policy;\n\tint (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);\n\tsize_t (*get_slave_size)(const struct net_device *, const struct net_device *);\n\tint (*fill_slave_info)(struct sk_buff *, const struct net_device *, const struct net_device *);\n\tstruct net * (*get_link_net)(const struct net_device *);\n\tsize_t (*get_linkxstats_size)(const struct net_device *, int);\n\tint (*fill_linkxstats)(struct sk_buff *, const struct net_device *, int *, int);\n};\n\nstruct udp_tunnel_nic_table_info {\n\tunsigned int n_entries;\n\tunsigned int tunnel_types;\n};\n\nstruct udp_tunnel_info;\n\nstruct udp_tunnel_nic_shared;\n\nstruct udp_tunnel_nic_info {\n\tint (*set_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);\n\tint (*unset_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);\n\tint (*sync_table)(struct net_device *, unsigned int);\n\tstruct udp_tunnel_nic_shared *shared;\n\tunsigned int flags;\n\tstruct udp_tunnel_nic_table_info tables[4];\n};\n\nenum {\n\tRTAX_UNSPEC = 0,\n\tRTAX_LOCK = 1,\n\tRTAX_MTU = 2,\n\tRTAX_WINDOW = 3,\n\tRTAX_RTT = 4,\n\tRTAX_RTTVAR = 5,\n\tRTAX_SSTHRESH = 6,\n\tRTAX_CWND = 7,\n\tRTAX_ADVMSS = 8,\n\tRTAX_REORDERING = 9,\n\tRTAX_HOPLIMIT = 10,\n\tRTAX_INITCWND = 11,\n\tRTAX_FEATURES = 12,\n\tRTAX_RTO_MIN = 13,\n\tRTAX_INITRWND = 14,\n\tRTAX_QUICKACK = 15,\n\tRTAX_CC_ALGO = 16,\n\tRTAX_FASTOPEN_NO_COOKIE = 17,\n\t__RTAX_MAX = 18,\n};\n\nstruct tcmsg {\n\tunsigned char tcm_family;\n\tunsigned char tcm__pad1;\n\tshort unsigned int tcm__pad2;\n\tint tcm_ifindex;\n\t__u32 tcm_handle;\n\t__u32 tcm_parent;\n\t__u32 tcm_info;\n};\n\nstruct gnet_stats_basic_cpu {\n\tstruct gnet_stats_basic_packed bstats;\n\tstruct u64_stats_sync syncp;\n};\n\nstruct gnet_dump {\n\tspinlock_t *lock;\n\tstruct sk_buff *skb;\n\tstruct nlattr *tail;\n\tint compat_tc_stats;\n\tint compat_xstats;\n\tint padattr;\n\tvoid *xstats;\n\tint xstats_len;\n\tstruct tc_stats tc_stats;\n};\n\nstruct netlink_range_validation {\n\tu64 min;\n\tu64 max;\n};\n\nstruct netlink_range_validation_signed {\n\ts64 min;\n\ts64 max;\n};\n\nenum flow_action_hw_stats_bit {\n\tFLOW_ACTION_HW_STATS_IMMEDIATE_BIT = 0,\n\tFLOW_ACTION_HW_STATS_DELAYED_BIT = 1,\n\tFLOW_ACTION_HW_STATS_DISABLED_BIT = 2,\n\tFLOW_ACTION_HW_STATS_NUM_BITS = 3,\n};\n\nstruct flow_block {\n\tstruct list_head cb_list;\n};\n\ntypedef int flow_setup_cb_t(enum tc_setup_type, void *, void *);\n\nstruct qdisc_size_table {\n\tstruct callback_head rcu;\n\tstruct list_head list;\n\tstruct tc_sizespec szopts;\n\tint refcnt;\n\tu16 data[0];\n};\n\nstruct Qdisc_class_ops;\n\nstruct Qdisc_ops {\n\tstruct Qdisc_ops *next;\n\tconst struct Qdisc_class_ops *cl_ops;\n\tchar id[16];\n\tint priv_size;\n\tunsigned int static_flags;\n\tint (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);\n\tstruct sk_buff * (*dequeue)(struct Qdisc *);\n\tstruct sk_buff * (*peek)(struct Qdisc *);\n\tint (*init)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);\n\tvoid (*reset)(struct Qdisc *);\n\tvoid (*destroy)(struct Qdisc *);\n\tint (*change)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);\n\tvoid (*attach)(struct Qdisc *);\n\tint (*change_tx_queue_len)(struct Qdisc *, unsigned int);\n\tvoid (*change_real_num_tx)(struct Qdisc *, unsigned int);\n\tint (*dump)(struct Qdisc *, struct sk_buff *);\n\tint (*dump_stats)(struct Qdisc *, struct gnet_dump *);\n\tvoid (*ingress_block_set)(struct Qdisc *, u32);\n\tvoid (*egress_block_set)(struct Qdisc *, u32);\n\tu32 (*ingress_block_get)(struct Qdisc *);\n\tu32 (*egress_block_get)(struct Qdisc *);\n\tstruct module *owner;\n};\n\nstruct qdisc_walker;\n\nstruct Qdisc_class_ops {\n\tunsigned int flags;\n\tstruct netdev_queue * (*select_queue)(struct Qdisc *, struct tcmsg *);\n\tint (*graft)(struct Qdisc *, long unsigned int, struct Qdisc *, struct Qdisc **, struct netlink_ext_ack *);\n\tstruct Qdisc * (*leaf)(struct Qdisc *, long unsigned int);\n\tvoid (*qlen_notify)(struct Qdisc *, long unsigned int);\n\tlong unsigned int (*find)(struct Qdisc *, u32);\n\tint (*change)(struct Qdisc *, u32, u32, struct nlattr **, long unsigned int *, struct netlink_ext_ack *);\n\tint (*delete)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);\n\tvoid (*walk)(struct Qdisc *, struct qdisc_walker *);\n\tstruct tcf_block * (*tcf_block)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);\n\tlong unsigned int (*bind_tcf)(struct Qdisc *, long unsigned int, u32);\n\tvoid (*unbind_tcf)(struct Qdisc *, long unsigned int);\n\tint (*dump)(struct Qdisc *, long unsigned int, struct sk_buff *, struct tcmsg *);\n\tint (*dump_stats)(struct Qdisc *, long unsigned int, struct gnet_dump *);\n};\n\nstruct tcf_chain;\n\nstruct tcf_block {\n\tstruct mutex lock;\n\tstruct list_head chain_list;\n\tu32 index;\n\tu32 classid;\n\trefcount_t refcnt;\n\tstruct net *net;\n\tstruct Qdisc *q;\n\tstruct rw_semaphore cb_lock;\n\tstruct flow_block flow_block;\n\tstruct list_head owner_list;\n\tbool keep_dst;\n\tatomic_t offloadcnt;\n\tunsigned int nooffloaddevcnt;\n\tunsigned int lockeddevcnt;\n\tstruct {\n\t\tstruct tcf_chain *chain;\n\t\tstruct list_head filter_chain_list;\n\t} chain0;\n\tstruct callback_head rcu;\n\tstruct hlist_head proto_destroy_ht[128];\n\tstruct mutex proto_destroy_lock;\n};\n\nstruct tcf_result;\n\nstruct tcf_proto_ops;\n\nstruct tcf_proto {\n\tstruct tcf_proto *next;\n\tvoid *root;\n\tint (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);\n\t__be16 protocol;\n\tu32 prio;\n\tvoid *data;\n\tconst struct tcf_proto_ops *ops;\n\tstruct tcf_chain *chain;\n\tspinlock_t lock;\n\tbool deleting;\n\trefcount_t refcnt;\n\tstruct callback_head rcu;\n\tstruct hlist_node destroy_ht_node;\n};\n\nstruct tcf_result {\n\tunion {\n\t\tstruct {\n\t\t\tlong unsigned int class;\n\t\t\tu32 classid;\n\t\t};\n\t\tconst struct tcf_proto *goto_tp;\n\t\tstruct {\n\t\t\tbool ingress;\n\t\t\tstruct gnet_stats_queue *qstats;\n\t\t};\n\t};\n};\n\nstruct tcf_walker;\n\nstruct tcf_proto_ops {\n\tstruct list_head head;\n\tchar kind[16];\n\tint (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);\n\tint (*init)(struct tcf_proto *);\n\tvoid (*destroy)(struct tcf_proto *, bool, struct netlink_ext_ack *);\n\tvoid * (*get)(struct tcf_proto *, u32);\n\tvoid (*put)(struct tcf_proto *, void *);\n\tint (*change)(struct net *, struct sk_buff *, struct tcf_proto *, long unsigned int, u32, struct nlattr **, void **, u32, struct netlink_ext_ack *);\n\tint (*delete)(struct tcf_proto *, void *, bool *, bool, struct netlink_ext_ack *);\n\tbool (*delete_empty)(struct tcf_proto *);\n\tvoid (*walk)(struct tcf_proto *, struct tcf_walker *, bool);\n\tint (*reoffload)(struct tcf_proto *, bool, flow_setup_cb_t *, void *, struct netlink_ext_ack *);\n\tvoid (*hw_add)(struct tcf_proto *, void *);\n\tvoid (*hw_del)(struct tcf_proto *, void *);\n\tvoid (*bind_class)(void *, u32, long unsigned int, void *, long unsigned int);\n\tvoid * (*tmplt_create)(struct net *, struct tcf_chain *, struct nlattr **, struct netlink_ext_ack *);\n\tvoid (*tmplt_destroy)(void *);\n\tint (*dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);\n\tint (*terse_dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);\n\tint (*tmplt_dump)(struct sk_buff *, struct net *, void *);\n\tstruct module *owner;\n\tint flags;\n};\n\nstruct tcf_chain {\n\tstruct mutex filter_chain_lock;\n\tstruct tcf_proto *filter_chain;\n\tstruct list_head list;\n\tstruct tcf_block *block;\n\tu32 index;\n\tunsigned int refcnt;\n\tunsigned int action_refcnt;\n\tbool explicitly_created;\n\tbool flushing;\n\tconst struct tcf_proto_ops *tmplt_ops;\n\tvoid *tmplt_priv;\n\tstruct callback_head rcu;\n};\n\nstruct sock_fprog_kern {\n\tu16 len;\n\tstruct sock_filter *filter;\n};\n\nstruct bpf_prog_stats {\n\tu64_stats_t cnt;\n\tu64_stats_t nsecs;\n\tu64_stats_t misses;\n\tstruct u64_stats_sync syncp;\n\tlong: 64;\n};\n\nstruct sk_filter {\n\trefcount_t refcnt;\n\tstruct callback_head rcu;\n\tstruct bpf_prog *prog;\n};\n\nenum {\n\tNEIGH_VAR_MCAST_PROBES = 0,\n\tNEIGH_VAR_UCAST_PROBES = 1,\n\tNEIGH_VAR_APP_PROBES = 2,\n\tNEIGH_VAR_MCAST_REPROBES = 3,\n\tNEIGH_VAR_RETRANS_TIME = 4,\n\tNEIGH_VAR_BASE_REACHABLE_TIME = 5,\n\tNEIGH_VAR_DELAY_PROBE_TIME = 6,\n\tNEIGH_VAR_GC_STALETIME = 7,\n\tNEIGH_VAR_QUEUE_LEN_BYTES = 8,\n\tNEIGH_VAR_PROXY_QLEN = 9,\n\tNEIGH_VAR_ANYCAST_DELAY = 10,\n\tNEIGH_VAR_PROXY_DELAY = 11,\n\tNEIGH_VAR_LOCKTIME = 12,\n\tNEIGH_VAR_QUEUE_LEN = 13,\n\tNEIGH_VAR_RETRANS_TIME_MS = 14,\n\tNEIGH_VAR_BASE_REACHABLE_TIME_MS = 15,\n\tNEIGH_VAR_GC_INTERVAL = 16,\n\tNEIGH_VAR_GC_THRESH1 = 17,\n\tNEIGH_VAR_GC_THRESH2 = 18,\n\tNEIGH_VAR_GC_THRESH3 = 19,\n\tNEIGH_VAR_MAX = 20,\n};\n\nstruct pneigh_entry;\n\nstruct neigh_statistics;\n\nstruct neigh_hash_table;\n\nstruct neigh_table {\n\tint family;\n\tunsigned int entry_size;\n\tunsigned int key_len;\n\t__be16 protocol;\n\t__u32 (*hash)(const void *, const struct net_device *, __u32 *);\n\tbool (*key_eq)(const struct neighbour *, const void *);\n\tint (*constructor)(struct neighbour *);\n\tint (*pconstructor)(struct pneigh_entry *);\n\tvoid (*pdestructor)(struct pneigh_entry *);\n\tvoid (*proxy_redo)(struct sk_buff *);\n\tint (*is_multicast)(const void *);\n\tbool (*allow_add)(const struct net_device *, struct netlink_ext_ack *);\n\tchar *id;\n\tstruct neigh_parms parms;\n\tstruct list_head parms_list;\n\tint gc_interval;\n\tint gc_thresh1;\n\tint gc_thresh2;\n\tint gc_thresh3;\n\tlong unsigned int last_flush;\n\tstruct delayed_work gc_work;\n\tstruct timer_list proxy_timer;\n\tstruct sk_buff_head proxy_queue;\n\tatomic_t entries;\n\tatomic_t gc_entries;\n\tstruct list_head gc_list;\n\trwlock_t lock;\n\tlong unsigned int last_rand;\n\tstruct neigh_statistics *stats;\n\tstruct neigh_hash_table *nht;\n\tstruct pneigh_entry **phash_buckets;\n};\n\nstruct neigh_statistics {\n\tlong unsigned int allocs;\n\tlong unsigned int destroys;\n\tlong unsigned int hash_grows;\n\tlong unsigned int res_failed;\n\tlong unsigned int lookups;\n\tlong unsigned int hits;\n\tlong unsigned int rcv_probes_mcast;\n\tlong unsigned int rcv_probes_ucast;\n\tlong unsigned int periodic_gc_runs;\n\tlong unsigned int forced_gc_runs;\n\tlong unsigned int unres_discards;\n\tlong unsigned int table_fulls;\n};\n\nstruct neigh_ops {\n\tint family;\n\tvoid (*solicit)(struct neighbour *, struct sk_buff *);\n\tvoid (*error_report)(struct neighbour *, struct sk_buff *);\n\tint (*output)(struct neighbour *, struct sk_buff *);\n\tint (*connected_output)(struct neighbour *, struct sk_buff *);\n};\n\nstruct pneigh_entry {\n\tstruct pneigh_entry *next;\n\tpossible_net_t net;\n\tstruct net_device *dev;\n\tu8 flags;\n\tu8 protocol;\n\tu8 key[0];\n};\n\nstruct neigh_hash_table {\n\tstruct neighbour **hash_buckets;\n\tunsigned int hash_shift;\n\t__u32 hash_rnd[4];\n\tstruct callback_head rcu;\n};\n\nenum {\n\tTCP_ESTABLISHED = 1,\n\tTCP_SYN_SENT = 2,\n\tTCP_SYN_RECV = 3,\n\tTCP_FIN_WAIT1 = 4,\n\tTCP_FIN_WAIT2 = 5,\n\tTCP_TIME_WAIT = 6,\n\tTCP_CLOSE = 7,\n\tTCP_CLOSE_WAIT = 8,\n\tTCP_LAST_ACK = 9,\n\tTCP_LISTEN = 10,\n\tTCP_CLOSING = 11,\n\tTCP_NEW_SYN_RECV = 12,\n\tTCP_MAX_STATES = 13,\n};\n\nstruct fib_rule_hdr {\n\t__u8 family;\n\t__u8 dst_len;\n\t__u8 src_len;\n\t__u8 tos;\n\t__u8 table;\n\t__u8 res1;\n\t__u8 res2;\n\t__u8 action;\n\t__u32 flags;\n};\n\nstruct fib_rule_port_range {\n\t__u16 start;\n\t__u16 end;\n};\n\nstruct fib_kuid_range {\n\tkuid_t start;\n\tkuid_t end;\n};\n\nstruct fib_rule {\n\tstruct list_head list;\n\tint iifindex;\n\tint oifindex;\n\tu32 mark;\n\tu32 mark_mask;\n\tu32 flags;\n\tu32 table;\n\tu8 action;\n\tu8 l3mdev;\n\tu8 proto;\n\tu8 ip_proto;\n\tu32 target;\n\t__be64 tun_id;\n\tstruct fib_rule *ctarget;\n\tstruct net *fr_net;\n\trefcount_t refcnt;\n\tu32 pref;\n\tint suppress_ifgroup;\n\tint suppress_prefixlen;\n\tchar iifname[16];\n\tchar oifname[16];\n\tstruct fib_kuid_range uid_range;\n\tstruct fib_rule_port_range sport_range;\n\tstruct fib_rule_port_range dport_range;\n\tstruct callback_head rcu;\n};\n\nstruct fib_lookup_arg {\n\tvoid *lookup_ptr;\n\tconst void *lookup_data;\n\tvoid *result;\n\tstruct fib_rule *rule;\n\tu32 table;\n\tint flags;\n};\n\nstruct smc_hashinfo;\n\nstruct sk_psock;\n\nstruct request_sock_ops;\n\nstruct timewait_sock_ops;\n\nstruct udp_table;\n\nstruct raw_hashinfo;\n\nstruct proto {\n\tvoid (*close)(struct sock *, long int);\n\tint (*pre_connect)(struct sock *, struct sockaddr *, int);\n\tint (*connect)(struct sock *, struct sockaddr *, int);\n\tint (*disconnect)(struct sock *, int);\n\tstruct sock * (*accept)(struct sock *, int, int *, bool);\n\tint (*ioctl)(struct sock *, int, long unsigned int);\n\tint (*init)(struct sock *);\n\tvoid (*destroy)(struct sock *);\n\tvoid (*shutdown)(struct sock *, int);\n\tint (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);\n\tint (*getsockopt)(struct sock *, int, int, char *, int *);\n\tvoid (*keepalive)(struct sock *, int);\n\tint (*compat_ioctl)(struct sock *, unsigned int, long unsigned int);\n\tint (*sendmsg)(struct sock *, struct msghdr *, size_t);\n\tint (*recvmsg)(struct sock *, struct msghdr *, size_t, int, int, int *);\n\tint (*sendpage)(struct sock *, struct page *, int, size_t, int);\n\tint (*bind)(struct sock *, struct sockaddr *, int);\n\tint (*bind_add)(struct sock *, struct sockaddr *, int);\n\tint (*backlog_rcv)(struct sock *, struct sk_buff *);\n\tbool (*bpf_bypass_getsockopt)(int, int);\n\tvoid (*release_cb)(struct sock *);\n\tint (*hash)(struct sock *);\n\tvoid (*unhash)(struct sock *);\n\tvoid (*rehash)(struct sock *);\n\tint (*get_port)(struct sock *, short unsigned int);\n\tint (*psock_update_sk_prot)(struct sock *, struct sk_psock *, bool);\n\tunsigned int inuse_idx;\n\tbool (*stream_memory_free)(const struct sock *, int);\n\tbool (*sock_is_readable)(struct sock *);\n\tvoid (*enter_memory_pressure)(struct sock *);\n\tvoid (*leave_memory_pressure)(struct sock *);\n\tatomic_long_t *memory_allocated;\n\tstruct percpu_counter *sockets_allocated;\n\tlong unsigned int *memory_pressure;\n\tlong int *sysctl_mem;\n\tint *sysctl_wmem;\n\tint *sysctl_rmem;\n\tu32 sysctl_wmem_offset;\n\tu32 sysctl_rmem_offset;\n\tint max_header;\n\tbool no_autobind;\n\tstruct kmem_cache *slab;\n\tunsigned int obj_size;\n\tslab_flags_t slab_flags;\n\tunsigned int useroffset;\n\tunsigned int usersize;\n\tunsigned int *orphan_count;\n\tstruct request_sock_ops *rsk_prot;\n\tstruct timewait_sock_ops *twsk_prot;\n\tunion {\n\t\tstruct inet_hashinfo *hashinfo;\n\t\tstruct udp_table *udp_table;\n\t\tstruct raw_hashinfo *raw_hash;\n\t\tstruct smc_hashinfo *smc_hash;\n\t} h;\n\tstruct module *owner;\n\tchar name[32];\n\tstruct list_head node;\n\tint (*diag_destroy)(struct sock *, int);\n};\n\nstruct request_sock;\n\nstruct request_sock_ops {\n\tint family;\n\tunsigned int obj_size;\n\tstruct kmem_cache *slab;\n\tchar *slab_name;\n\tint (*rtx_syn_ack)(const struct sock *, struct request_sock *);\n\tvoid (*send_ack)(const struct sock *, struct sk_buff *, struct request_sock *);\n\tvoid (*send_reset)(const struct sock *, struct sk_buff *);\n\tvoid (*destructor)(struct request_sock *);\n\tvoid (*syn_ack_timeout)(const struct request_sock *);\n};\n\nstruct timewait_sock_ops {\n\tstruct kmem_cache *twsk_slab;\n\tchar *twsk_slab_name;\n\tunsigned int twsk_obj_size;\n\tint (*twsk_unique)(struct sock *, struct sock *, void *);\n\tvoid (*twsk_destructor)(struct sock *);\n};\n\nstruct saved_syn;\n\nstruct request_sock {\n\tstruct sock_common __req_common;\n\tstruct request_sock *dl_next;\n\tu16 mss;\n\tu8 num_retrans;\n\tu8 syncookie: 1;\n\tu8 num_timeout: 7;\n\tu32 ts_recent;\n\tstruct timer_list rsk_timer;\n\tconst struct request_sock_ops *rsk_ops;\n\tstruct sock *sk;\n\tstruct saved_syn *saved_syn;\n\tu32 secid;\n\tu32 peer_secid;\n};\n\nstruct saved_syn {\n\tu32 mac_hdrlen;\n\tu32 network_hdrlen;\n\tu32 tcp_hdrlen;\n\tu8 data[0];\n};\n\nenum tsq_enum {\n\tTSQ_THROTTLED = 0,\n\tTSQ_QUEUED = 1,\n\tTCP_TSQ_DEFERRED = 2,\n\tTCP_WRITE_TIMER_DEFERRED = 3,\n\tTCP_DELACK_TIMER_DEFERRED = 4,\n\tTCP_MTU_REDUCED_DEFERRED = 5,\n};\n\nstruct ip6_sf_list {\n\tstruct ip6_sf_list *sf_next;\n\tstruct in6_addr sf_addr;\n\tlong unsigned int sf_count[2];\n\tunsigned char sf_gsresp;\n\tunsigned char sf_oldin;\n\tunsigned char sf_crcount;\n\tstruct callback_head rcu;\n};\n\nstruct ifmcaddr6 {\n\tstruct in6_addr mca_addr;\n\tstruct inet6_dev *idev;\n\tstruct ifmcaddr6 *next;\n\tstruct ip6_sf_list *mca_sources;\n\tstruct ip6_sf_list *mca_tomb;\n\tunsigned int mca_sfmode;\n\tunsigned char mca_crcount;\n\tlong unsigned int mca_sfcount[2];\n\tstruct delayed_work mca_work;\n\tunsigned int mca_flags;\n\tint mca_users;\n\trefcount_t mca_refcnt;\n\tlong unsigned int mca_cstamp;\n\tlong unsigned int mca_tstamp;\n\tstruct callback_head rcu;\n};\n\nstruct ifacaddr6 {\n\tstruct in6_addr aca_addr;\n\tstruct fib6_info *aca_rt;\n\tstruct ifacaddr6 *aca_next;\n\tstruct hlist_node aca_addr_lst;\n\tint aca_users;\n\trefcount_t aca_refcnt;\n\tlong unsigned int aca_cstamp;\n\tlong unsigned int aca_tstamp;\n\tstruct callback_head rcu;\n};\n\nenum {\n\t__ND_OPT_PREFIX_INFO_END = 0,\n\tND_OPT_SOURCE_LL_ADDR = 1,\n\tND_OPT_TARGET_LL_ADDR = 2,\n\tND_OPT_PREFIX_INFO = 3,\n\tND_OPT_REDIRECT_HDR = 4,\n\tND_OPT_MTU = 5,\n\tND_OPT_NONCE = 14,\n\t__ND_OPT_ARRAY_MAX = 15,\n\tND_OPT_ROUTE_INFO = 24,\n\tND_OPT_RDNSS = 25,\n\tND_OPT_DNSSL = 31,\n\tND_OPT_6CO = 34,\n\tND_OPT_CAPTIVE_PORTAL = 37,\n\tND_OPT_PREF64 = 38,\n\t__ND_OPT_MAX = 39,\n};\n\nstruct nd_opt_hdr {\n\t__u8 nd_opt_type;\n\t__u8 nd_opt_len;\n};\n\nstruct ndisc_options {\n\tstruct nd_opt_hdr *nd_opt_array[15];\n\tstruct nd_opt_hdr *nd_opts_ri;\n\tstruct nd_opt_hdr *nd_opts_ri_end;\n\tstruct nd_opt_hdr *nd_useropts;\n\tstruct nd_opt_hdr *nd_useropts_end;\n\tstruct nd_opt_hdr *nd_802154_opt_array[3];\n};\n\nstruct prefix_info {\n\t__u8 type;\n\t__u8 length;\n\t__u8 prefix_len;\n\t__u8 reserved: 6;\n\t__u8 autoconf: 1;\n\t__u8 onlink: 1;\n\t__be32 valid;\n\t__be32 prefered;\n\t__be32 reserved2;\n\tstruct in6_addr prefix;\n};\n\nenum nfs_opnum4 {\n\tOP_ACCESS = 3,\n\tOP_CLOSE = 4,\n\tOP_COMMIT = 5,\n\tOP_CREATE = 6,\n\tOP_DELEGPURGE = 7,\n\tOP_DELEGRETURN = 8,\n\tOP_GETATTR = 9,\n\tOP_GETFH = 10,\n\tOP_LINK = 11,\n\tOP_LOCK = 12,\n\tOP_LOCKT = 13,\n\tOP_LOCKU = 14,\n\tOP_LOOKUP = 15,\n\tOP_LOOKUPP = 16,\n\tOP_NVERIFY = 17,\n\tOP_OPEN = 18,\n\tOP_OPENATTR = 19,\n\tOP_OPEN_CONFIRM = 20,\n\tOP_OPEN_DOWNGRADE = 21,\n\tOP_PUTFH = 22,\n\tOP_PUTPUBFH = 23,\n\tOP_PUTROOTFH = 24,\n\tOP_READ = 25,\n\tOP_READDIR = 26,\n\tOP_READLINK = 27,\n\tOP_REMOVE = 28,\n\tOP_RENAME = 29,\n\tOP_RENEW = 30,\n\tOP_RESTOREFH = 31,\n\tOP_SAVEFH = 32,\n\tOP_SECINFO = 33,\n\tOP_SETATTR = 34,\n\tOP_SETCLIENTID = 35,\n\tOP_SETCLIENTID_CONFIRM = 36,\n\tOP_VERIFY = 37,\n\tOP_WRITE = 38,\n\tOP_RELEASE_LOCKOWNER = 39,\n\tOP_BACKCHANNEL_CTL = 40,\n\tOP_BIND_CONN_TO_SESSION = 41,\n\tOP_EXCHANGE_ID = 42,\n\tOP_CREATE_SESSION = 43,\n\tOP_DESTROY_SESSION = 44,\n\tOP_FREE_STATEID = 45,\n\tOP_GET_DIR_DELEGATION = 46,\n\tOP_GETDEVICEINFO = 47,\n\tOP_GETDEVICELIST = 48,\n\tOP_LAYOUTCOMMIT = 49,\n\tOP_LAYOUTGET = 50,\n\tOP_LAYOUTRETURN = 51,\n\tOP_SECINFO_NO_NAME = 52,\n\tOP_SEQUENCE = 53,\n\tOP_SET_SSV = 54,\n\tOP_TEST_STATEID = 55,\n\tOP_WANT_DELEGATION = 56,\n\tOP_DESTROY_CLIENTID = 57,\n\tOP_RECLAIM_COMPLETE = 58,\n\tOP_ALLOCATE = 59,\n\tOP_COPY = 60,\n\tOP_COPY_NOTIFY = 61,\n\tOP_DEALLOCATE = 62,\n\tOP_IO_ADVISE = 63,\n\tOP_LAYOUTERROR = 64,\n\tOP_LAYOUTSTATS = 65,\n\tOP_OFFLOAD_CANCEL = 66,\n\tOP_OFFLOAD_STATUS = 67,\n\tOP_READ_PLUS = 68,\n\tOP_SEEK = 69,\n\tOP_WRITE_SAME = 70,\n\tOP_CLONE = 71,\n\tOP_GETXATTR = 72,\n\tOP_SETXATTR = 73,\n\tOP_LISTXATTRS = 74,\n\tOP_REMOVEXATTR = 75,\n\tOP_ILLEGAL = 10044,\n};\n\nenum perf_branch_sample_type_shift {\n\tPERF_SAMPLE_BRANCH_USER_SHIFT = 0,\n\tPERF_SAMPLE_BRANCH_KERNEL_SHIFT = 1,\n\tPERF_SAMPLE_BRANCH_HV_SHIFT = 2,\n\tPERF_SAMPLE_BRANCH_ANY_SHIFT = 3,\n\tPERF_SAMPLE_BRANCH_ANY_CALL_SHIFT = 4,\n\tPERF_SAMPLE_BRANCH_ANY_RETURN_SHIFT = 5,\n\tPERF_SAMPLE_BRANCH_IND_CALL_SHIFT = 6,\n\tPERF_SAMPLE_BRANCH_ABORT_TX_SHIFT = 7,\n\tPERF_SAMPLE_BRANCH_IN_TX_SHIFT = 8,\n\tPERF_SAMPLE_BRANCH_NO_TX_SHIFT = 9,\n\tPERF_SAMPLE_BRANCH_COND_SHIFT = 10,\n\tPERF_SAMPLE_BRANCH_CALL_STACK_SHIFT = 11,\n\tPERF_SAMPLE_BRANCH_IND_JUMP_SHIFT = 12,\n\tPERF_SAMPLE_BRANCH_CALL_SHIFT = 13,\n\tPERF_SAMPLE_BRANCH_NO_FLAGS_SHIFT = 14,\n\tPERF_SAMPLE_BRANCH_NO_CYCLES_SHIFT = 15,\n\tPERF_SAMPLE_BRANCH_TYPE_SAVE_SHIFT = 16,\n\tPERF_SAMPLE_BRANCH_HW_INDEX_SHIFT = 17,\n\tPERF_SAMPLE_BRANCH_MAX_SHIFT = 18,\n};\n\nenum exception_stack_ordering {\n\tESTACK_DF = 0,\n\tESTACK_NMI = 1,\n\tESTACK_DB = 2,\n\tESTACK_MCE = 3,\n\tESTACK_VC = 4,\n\tESTACK_VC2 = 5,\n\tN_EXCEPTION_STACKS = 6,\n};\n\nenum {\n\tTSK_TRACE_FL_TRACE_BIT = 0,\n\tTSK_TRACE_FL_GRAPH_BIT = 1,\n};\n\nstruct uuidcmp {\n\tconst char *uuid;\n\tint len;\n};\n\nstruct subprocess_info {\n\tstruct work_struct work;\n\tstruct completion *complete;\n\tconst char *path;\n\tchar **argv;\n\tchar **envp;\n\tint wait;\n\tint retval;\n\tint (*init)(struct subprocess_info *, struct cred *);\n\tvoid (*cleanup)(struct subprocess_info *);\n\tvoid *data;\n};\n\ntypedef phys_addr_t resource_size_t;\n\nstruct __va_list_tag {\n\tunsigned int gp_offset;\n\tunsigned int fp_offset;\n\tvoid *overflow_arg_area;\n\tvoid *reg_save_area;\n};\n\ntypedef __builtin_va_list va_list;\n\nstruct resource {\n\tresource_size_t start;\n\tresource_size_t end;\n\tconst char *name;\n\tlong unsigned int flags;\n\tlong unsigned int desc;\n\tstruct resource *parent;\n\tstruct resource *sibling;\n\tstruct resource *child;\n};\n\ntypedef u64 async_cookie_t;\n\ntypedef void (*async_func_t)(void *, async_cookie_t);\n\nstruct async_domain {\n\tstruct list_head pending;\n\tunsigned int registered: 1;\n};\n\nenum umh_disable_depth {\n\tUMH_ENABLED = 0,\n\tUMH_FREEZING = 1,\n\tUMH_DISABLED = 2,\n};\n\nstruct hash {\n\tint ino;\n\tint minor;\n\tint major;\n\tumode_t mode;\n\tstruct hash *next;\n\tchar name[4098];\n};\n\nstruct dir_entry {\n\tstruct list_head list;\n\tchar *name;\n\ttime64_t mtime;\n};\n\nenum state {\n\tStart = 0,\n\tCollect = 1,\n\tGotHeader = 2,\n\tSkipIt = 3,\n\tGotName = 4,\n\tCopyFile = 5,\n\tGotSymlink = 6,\n\tReset = 7,\n};\n\ntypedef int (*decompress_fn)(unsigned char *, long int, long int (*)(void *, long unsigned int), long int (*)(void *, long unsigned int), unsigned char *, long int *, void (*)(char *));\n\nenum audit_ntp_type {\n\tAUDIT_NTP_OFFSET = 0,\n\tAUDIT_NTP_FREQ = 1,\n\tAUDIT_NTP_STATUS = 2,\n\tAUDIT_NTP_TAI = 3,\n\tAUDIT_NTP_TICK = 4,\n\tAUDIT_NTP_ADJUST = 5,\n\tAUDIT_NTP_NVALS = 6,\n};\n\ntypedef long int (*sys_call_ptr_t)(const struct pt_regs *);\n\nstruct io_bitmap {\n\tu64 sequence;\n\trefcount_t refcnt;\n\tunsigned int max;\n\tlong unsigned int bitmap[1024];\n};\n\nenum irqreturn {\n\tIRQ_NONE = 0,\n\tIRQ_HANDLED = 1,\n\tIRQ_WAKE_THREAD = 2,\n};\n\ntypedef enum irqreturn irqreturn_t;\n\ntypedef struct {\n\tu16 __softirq_pending;\n\tu8 kvm_cpu_l1tf_flush_l1d;\n\tunsigned int __nmi_count;\n\tunsigned int apic_timer_irqs;\n\tunsigned int irq_spurious_count;\n\tunsigned int icr_read_retry_count;\n\tunsigned int kvm_posted_intr_ipis;\n\tunsigned int kvm_posted_intr_wakeup_ipis;\n\tunsigned int kvm_posted_intr_nested_ipis;\n\tunsigned int x86_platform_ipis;\n\tunsigned int apic_perf_irqs;\n\tunsigned int apic_irq_work_irqs;\n\tunsigned int irq_resched_count;\n\tunsigned int irq_call_count;\n\tunsigned int irq_tlb_count;\n\tunsigned int irq_thermal_count;\n\tunsigned int irq_threshold_count;\n\tunsigned int irq_deferred_error_count;\n\tunsigned int irq_hv_callback_count;\n\tunsigned int irq_hv_reenlightenment_count;\n\tunsigned int hyperv_stimer0_count;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n} irq_cpustat_t;\n\ntypedef irqreturn_t (*irq_handler_t)(int, void *);\n\nstruct irqaction {\n\tirq_handler_t handler;\n\tvoid *dev_id;\n\tvoid *percpu_dev_id;\n\tstruct irqaction *next;\n\tirq_handler_t thread_fn;\n\tstruct task_struct *thread;\n\tstruct irqaction *secondary;\n\tunsigned int irq;\n\tunsigned int flags;\n\tlong unsigned int thread_flags;\n\tlong unsigned int thread_mask;\n\tconst char *name;\n\tstruct proc_dir_entry *dir;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct irq_affinity_notify {\n\tunsigned int irq;\n\tstruct kref kref;\n\tstruct work_struct work;\n\tvoid (*notify)(struct irq_affinity_notify *, const cpumask_t *);\n\tvoid (*release)(struct kref *);\n};\n\nstruct irq_affinity_desc {\n\tstruct cpumask mask;\n\tunsigned int is_managed: 1;\n};\n\nenum irqchip_irq_state {\n\tIRQCHIP_STATE_PENDING = 0,\n\tIRQCHIP_STATE_ACTIVE = 1,\n\tIRQCHIP_STATE_MASKED = 2,\n\tIRQCHIP_STATE_LINE_LEVEL = 3,\n};\n\nenum {\n\tEI_ETYPE_NONE = 0,\n\tEI_ETYPE_NULL = 1,\n\tEI_ETYPE_ERRNO = 2,\n\tEI_ETYPE_ERRNO_NULL = 3,\n\tEI_ETYPE_TRUE = 4,\n};\n\nstruct syscall_metadata {\n\tconst char *name;\n\tint syscall_nr;\n\tint nb_args;\n\tconst char **types;\n\tconst char **args;\n\tstruct list_head enter_fields;\n\tstruct trace_event_call *enter_event;\n\tstruct trace_event_call *exit_event;\n};\n\nstruct irqentry_state {\n\tunion {\n\t\tbool exit_rcu;\n\t\tbool lockdep;\n\t};\n};\n\ntypedef struct irqentry_state irqentry_state_t;\n\nstruct irq_desc;\n\ntypedef void (*irq_flow_handler_t)(struct irq_desc *);\n\nstruct msi_desc;\n\nstruct irq_common_data {\n\tunsigned int state_use_accessors;\n\tunsigned int node;\n\tvoid *handler_data;\n\tstruct msi_desc *msi_desc;\n\tcpumask_var_t affinity;\n\tcpumask_var_t effective_affinity;\n};\n\nstruct irq_chip;\n\nstruct irq_data {\n\tu32 mask;\n\tunsigned int irq;\n\tlong unsigned int hwirq;\n\tstruct irq_common_data *common;\n\tstruct irq_chip *chip;\n\tstruct irq_domain *domain;\n\tstruct irq_data *parent_data;\n\tvoid *chip_data;\n};\n\nstruct irq_desc {\n\tstruct irq_common_data irq_common_data;\n\tstruct irq_data irq_data;\n\tunsigned int *kstat_irqs;\n\tirq_flow_handler_t handle_irq;\n\tstruct irqaction *action;\n\tunsigned int status_use_accessors;\n\tunsigned int core_internal_state__do_not_mess_with_it;\n\tunsigned int depth;\n\tunsigned int wake_depth;\n\tunsigned int tot_count;\n\tunsigned int irq_count;\n\tlong unsigned int last_unhandled;\n\tunsigned int irqs_unhandled;\n\tatomic_t threads_handled;\n\tint threads_handled_last;\n\traw_spinlock_t lock;\n\tstruct cpumask *percpu_enabled;\n\tconst struct cpumask *percpu_affinity;\n\tconst struct cpumask *affinity_hint;\n\tstruct irq_affinity_notify *affinity_notify;\n\tcpumask_var_t pending_mask;\n\tlong unsigned int threads_oneshot;\n\tatomic_t threads_active;\n\twait_queue_head_t wait_for_threads;\n\tunsigned int nr_actions;\n\tunsigned int no_suspend_depth;\n\tunsigned int cond_suspend_depth;\n\tunsigned int force_resume_depth;\n\tstruct proc_dir_entry *dir;\n\tstruct callback_head rcu;\n\tstruct kobject kobj;\n\tstruct mutex request_mutex;\n\tint parent_irq;\n\tstruct module *owner;\n\tconst char *name;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct x86_msi_addr_lo {\n\tunion {\n\t\tstruct {\n\t\t\tu32 reserved_0: 2;\n\t\t\tu32 dest_mode_logical: 1;\n\t\t\tu32 redirect_hint: 1;\n\t\t\tu32 reserved_1: 1;\n\t\t\tu32 virt_destid_8_14: 7;\n\t\t\tu32 destid_0_7: 8;\n\t\t\tu32 base_address: 12;\n\t\t};\n\t\tstruct {\n\t\t\tu32 dmar_reserved_0: 2;\n\t\t\tu32 dmar_index_15: 1;\n\t\t\tu32 dmar_subhandle_valid: 1;\n\t\t\tu32 dmar_format: 1;\n\t\t\tu32 dmar_index_0_14: 15;\n\t\t\tu32 dmar_base_address: 12;\n\t\t};\n\t};\n};\n\ntypedef struct x86_msi_addr_lo arch_msi_msg_addr_lo_t;\n\nstruct x86_msi_addr_hi {\n\tu32 reserved: 8;\n\tu32 destid_8_31: 24;\n};\n\ntypedef struct x86_msi_addr_hi arch_msi_msg_addr_hi_t;\n\nstruct x86_msi_data {\n\tunion {\n\t\tstruct {\n\t\t\tu32 vector: 8;\n\t\t\tu32 delivery_mode: 3;\n\t\t\tu32 dest_mode_logical: 1;\n\t\t\tu32 reserved: 2;\n\t\t\tu32 active_low: 1;\n\t\t\tu32 is_level: 1;\n\t\t};\n\t\tu32 dmar_subhandle;\n\t};\n};\n\ntypedef struct x86_msi_data arch_msi_msg_data_t;\n\nstruct msi_msg {\n\tunion {\n\t\tu32 address_lo;\n\t\tarch_msi_msg_addr_lo_t arch_addr_lo;\n\t};\n\tunion {\n\t\tu32 address_hi;\n\t\tarch_msi_msg_addr_hi_t arch_addr_hi;\n\t};\n\tunion {\n\t\tu32 data;\n\t\tarch_msi_msg_data_t arch_data;\n\t};\n};\n\nstruct platform_msi_priv_data;\n\nstruct platform_msi_desc {\n\tstruct platform_msi_priv_data *msi_priv_data;\n\tu16 msi_index;\n};\n\nstruct fsl_mc_msi_desc {\n\tu16 msi_index;\n};\n\nstruct ti_sci_inta_msi_desc {\n\tu16 dev_index;\n};\n\nstruct msi_desc {\n\tstruct list_head list;\n\tunsigned int irq;\n\tunsigned int nvec_used;\n\tstruct device *dev;\n\tstruct msi_msg msg;\n\tstruct irq_affinity_desc *affinity;\n\tconst void *iommu_cookie;\n\tvoid (*write_msi_msg)(struct msi_desc *, void *);\n\tvoid *write_msi_msg_data;\n\tunion {\n\t\tstruct {\n\t\t\tunion {\n\t\t\t\tu32 msi_mask;\n\t\t\t\tu32 msix_ctrl;\n\t\t\t};\n\t\t\tstruct {\n\t\t\t\tu8 is_msix: 1;\n\t\t\t\tu8 multiple: 3;\n\t\t\t\tu8 multi_cap: 3;\n\t\t\t\tu8 can_mask: 1;\n\t\t\t\tu8 is_64: 1;\n\t\t\t\tu8 is_virtual: 1;\n\t\t\t\tu16 entry_nr;\n\t\t\t\tunsigned int default_irq;\n\t\t\t} msi_attrib;\n\t\t\tunion {\n\t\t\t\tu8 mask_pos;\n\t\t\t\tvoid *mask_base;\n\t\t\t};\n\t\t};\n\t\tstruct platform_msi_desc platform;\n\t\tstruct fsl_mc_msi_desc fsl_mc;\n\t\tstruct ti_sci_inta_msi_desc inta;\n\t};\n};\n\nstruct irq_chip {\n\tstruct device *parent_device;\n\tconst char *name;\n\tunsigned int (*irq_startup)(struct irq_data *);\n\tvoid (*irq_shutdown)(struct irq_data *);\n\tvoid (*irq_enable)(struct irq_data *);\n\tvoid (*irq_disable)(struct irq_data *);\n\tvoid (*irq_ack)(struct irq_data *);\n\tvoid (*irq_mask)(struct irq_data *);\n\tvoid (*irq_mask_ack)(struct irq_data *);\n\tvoid (*irq_unmask)(struct irq_data *);\n\tvoid (*irq_eoi)(struct irq_data *);\n\tint (*irq_set_affinity)(struct irq_data *, const struct cpumask *, bool);\n\tint (*irq_retrigger)(struct irq_data *);\n\tint (*irq_set_type)(struct irq_data *, unsigned int);\n\tint (*irq_set_wake)(struct irq_data *, unsigned int);\n\tvoid (*irq_bus_lock)(struct irq_data *);\n\tvoid (*irq_bus_sync_unlock)(struct irq_data *);\n\tvoid (*irq_cpu_online)(struct irq_data *);\n\tvoid (*irq_cpu_offline)(struct irq_data *);\n\tvoid (*irq_suspend)(struct irq_data *);\n\tvoid (*irq_resume)(struct irq_data *);\n\tvoid (*irq_pm_shutdown)(struct irq_data *);\n\tvoid (*irq_calc_mask)(struct irq_data *);\n\tvoid (*irq_print_chip)(struct irq_data *, struct seq_file *);\n\tint (*irq_request_resources)(struct irq_data *);\n\tvoid (*irq_release_resources)(struct irq_data *);\n\tvoid (*irq_compose_msi_msg)(struct irq_data *, struct msi_msg *);\n\tvoid (*irq_write_msi_msg)(struct irq_data *, struct msi_msg *);\n\tint (*irq_get_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool *);\n\tint (*irq_set_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool);\n\tint (*irq_set_vcpu_affinity)(struct irq_data *, void *);\n\tvoid (*ipi_send_single)(struct irq_data *, unsigned int);\n\tvoid (*ipi_send_mask)(struct irq_data *, const struct cpumask *);\n\tint (*irq_nmi_setup)(struct irq_data *);\n\tvoid (*irq_nmi_teardown)(struct irq_data *);\n\tlong unsigned int flags;\n};\n\nstruct irq_chip_regs {\n\tlong unsigned int enable;\n\tlong unsigned int disable;\n\tlong unsigned int mask;\n\tlong unsigned int ack;\n\tlong unsigned int eoi;\n\tlong unsigned int type;\n\tlong unsigned int polarity;\n};\n\nstruct irq_chip_type {\n\tstruct irq_chip chip;\n\tstruct irq_chip_regs regs;\n\tirq_flow_handler_t handler;\n\tu32 type;\n\tu32 mask_cache_priv;\n\tu32 *mask_cache;\n};\n\nstruct irq_chip_generic {\n\traw_spinlock_t lock;\n\tvoid *reg_base;\n\tu32 (*reg_readl)(void *);\n\tvoid (*reg_writel)(u32, void *);\n\tvoid (*suspend)(struct irq_chip_generic *);\n\tvoid (*resume)(struct irq_chip_generic *);\n\tunsigned int irq_base;\n\tunsigned int irq_cnt;\n\tu32 mask_cache;\n\tu32 type_cache;\n\tu32 polarity_cache;\n\tu32 wake_enabled;\n\tu32 wake_active;\n\tunsigned int num_ct;\n\tvoid *private;\n\tlong unsigned int installed;\n\tlong unsigned int unused;\n\tstruct irq_domain *domain;\n\tstruct list_head list;\n\tstruct irq_chip_type chip_types[0];\n};\n\nenum irq_gc_flags {\n\tIRQ_GC_INIT_MASK_CACHE = 1,\n\tIRQ_GC_INIT_NESTED_LOCK = 2,\n\tIRQ_GC_MASK_CACHE_PER_TYPE = 4,\n\tIRQ_GC_NO_MASK = 8,\n\tIRQ_GC_BE_IO = 16,\n};\n\nstruct irq_domain_chip_generic {\n\tunsigned int irqs_per_chip;\n\tunsigned int num_chips;\n\tunsigned int irq_flags_to_clear;\n\tunsigned int irq_flags_to_set;\n\tenum irq_gc_flags gc_flags;\n\tstruct irq_chip_generic *gc[0];\n};\n\nstruct alt_instr {\n\ts32 instr_offset;\n\ts32 repl_offset;\n\tu16 cpuid;\n\tu8 instrlen;\n\tu8 replacementlen;\n};\n\nstruct timens_offset {\n\ts64 sec;\n\tu64 nsec;\n};\n\nenum vm_fault_reason {\n\tVM_FAULT_OOM = 1,\n\tVM_FAULT_SIGBUS = 2,\n\tVM_FAULT_MAJOR = 4,\n\tVM_FAULT_WRITE = 8,\n\tVM_FAULT_HWPOISON = 16,\n\tVM_FAULT_HWPOISON_LARGE = 32,\n\tVM_FAULT_SIGSEGV = 64,\n\tVM_FAULT_NOPAGE = 256,\n\tVM_FAULT_LOCKED = 512,\n\tVM_FAULT_RETRY = 1024,\n\tVM_FAULT_FALLBACK = 2048,\n\tVM_FAULT_DONE_COW = 4096,\n\tVM_FAULT_NEEDDSYNC = 8192,\n\tVM_FAULT_HINDEX_MASK = 983040,\n};\n\nstruct vm_special_mapping {\n\tconst char *name;\n\tstruct page **pages;\n\tvm_fault_t (*fault)(const struct vm_special_mapping *, struct vm_area_struct *, struct vm_fault *);\n\tint (*mremap)(const struct vm_special_mapping *, struct vm_area_struct *);\n};\n\nstruct timens_offsets {\n\tstruct timespec64 monotonic;\n\tstruct timespec64 boottime;\n};\n\nstruct time_namespace {\n\tstruct user_namespace *user_ns;\n\tstruct ucounts *ucounts;\n\tstruct ns_common ns;\n\tstruct timens_offsets offsets;\n\tstruct page *vvar_page;\n\tbool frozen_offsets;\n};\n\nstruct pvclock_vcpu_time_info {\n\tu32 version;\n\tu32 pad0;\n\tu64 tsc_timestamp;\n\tu64 system_time;\n\tu32 tsc_to_system_mul;\n\ts8 tsc_shift;\n\tu8 flags;\n\tu8 pad[2];\n};\n\nstruct pvclock_vsyscall_time_info {\n\tstruct pvclock_vcpu_time_info pvti;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nenum vdso_clock_mode {\n\tVDSO_CLOCKMODE_NONE = 0,\n\tVDSO_CLOCKMODE_TSC = 1,\n\tVDSO_CLOCKMODE_PVCLOCK = 2,\n\tVDSO_CLOCKMODE_HVCLOCK = 3,\n\tVDSO_CLOCKMODE_MAX = 4,\n\tVDSO_CLOCKMODE_TIMENS = 2147483647,\n};\n\nstruct arch_vdso_data {};\n\nstruct vdso_timestamp {\n\tu64 sec;\n\tu64 nsec;\n};\n\nstruct vdso_data {\n\tu32 seq;\n\ts32 clock_mode;\n\tu64 cycle_last;\n\tu64 mask;\n\tu32 mult;\n\tu32 shift;\n\tunion {\n\t\tstruct vdso_timestamp basetime[12];\n\t\tstruct timens_offset offset[12];\n\t};\n\ts32 tz_minuteswest;\n\ts32 tz_dsttime;\n\tu32 hrtimer_res;\n\tu32 __unused;\n\tstruct arch_vdso_data arch_data;\n};\n\nstruct ms_hyperv_tsc_page {\n\tvolatile u32 tsc_sequence;\n\tu32 reserved1;\n\tvolatile u64 tsc_scale;\n\tvolatile s64 tsc_offset;\n};\n\nenum {\n\tTASKSTATS_CMD_UNSPEC = 0,\n\tTASKSTATS_CMD_GET = 1,\n\tTASKSTATS_CMD_NEW = 2,\n\t__TASKSTATS_CMD_MAX = 3,\n};\n\nenum ucount_type {\n\tUCOUNT_USER_NAMESPACES = 0,\n\tUCOUNT_PID_NAMESPACES = 1,\n\tUCOUNT_UTS_NAMESPACES = 2,\n\tUCOUNT_IPC_NAMESPACES = 3,\n\tUCOUNT_NET_NAMESPACES = 4,\n\tUCOUNT_MNT_NAMESPACES = 5,\n\tUCOUNT_CGROUP_NAMESPACES = 6,\n\tUCOUNT_TIME_NAMESPACES = 7,\n\tUCOUNT_INOTIFY_INSTANCES = 8,\n\tUCOUNT_INOTIFY_WATCHES = 9,\n\tUCOUNT_FANOTIFY_GROUPS = 10,\n\tUCOUNT_FANOTIFY_MARKS = 11,\n\tUCOUNT_RLIMIT_NPROC = 12,\n\tUCOUNT_RLIMIT_MSGQUEUE = 13,\n\tUCOUNT_RLIMIT_SIGPENDING = 14,\n\tUCOUNT_RLIMIT_MEMLOCK = 15,\n\tUCOUNT_COUNTS = 16,\n};\n\nenum {\n\tHI_SOFTIRQ = 0,\n\tTIMER_SOFTIRQ = 1,\n\tNET_TX_SOFTIRQ = 2,\n\tNET_RX_SOFTIRQ = 3,\n\tBLOCK_SOFTIRQ = 4,\n\tIRQ_POLL_SOFTIRQ = 5,\n\tTASKLET_SOFTIRQ = 6,\n\tSCHED_SOFTIRQ = 7,\n\tHRTIMER_SOFTIRQ = 8,\n\tRCU_SOFTIRQ = 9,\n\tNR_SOFTIRQS = 10,\n};\n\nenum cpu_usage_stat {\n\tCPUTIME_USER = 0,\n\tCPUTIME_NICE = 1,\n\tCPUTIME_SYSTEM = 2,\n\tCPUTIME_SOFTIRQ = 3,\n\tCPUTIME_IRQ = 4,\n\tCPUTIME_IDLE = 5,\n\tCPUTIME_IOWAIT = 6,\n\tCPUTIME_STEAL = 7,\n\tCPUTIME_GUEST = 8,\n\tCPUTIME_GUEST_NICE = 9,\n\tNR_STATS = 10,\n};\n\nenum bpf_type_flag {\n\tPTR_MAYBE_NULL = 256,\n\tMEM_RDONLY = 512,\n\t__BPF_TYPE_LAST_FLAG = 512,\n};\n\nenum bpf_arg_type {\n\tARG_DONTCARE = 0,\n\tARG_CONST_MAP_PTR = 1,\n\tARG_PTR_TO_MAP_KEY = 2,\n\tARG_PTR_TO_MAP_VALUE = 3,\n\tARG_PTR_TO_UNINIT_MAP_VALUE = 4,\n\tARG_PTR_TO_MEM = 5,\n\tARG_PTR_TO_UNINIT_MEM = 6,\n\tARG_CONST_SIZE = 7,\n\tARG_CONST_SIZE_OR_ZERO = 8,\n\tARG_PTR_TO_CTX = 9,\n\tARG_ANYTHING = 10,\n\tARG_PTR_TO_SPIN_LOCK = 11,\n\tARG_PTR_TO_SOCK_COMMON = 12,\n\tARG_PTR_TO_INT = 13,\n\tARG_PTR_TO_LONG = 14,\n\tARG_PTR_TO_SOCKET = 15,\n\tARG_PTR_TO_BTF_ID = 16,\n\tARG_PTR_TO_ALLOC_MEM = 17,\n\tARG_CONST_ALLOC_SIZE_OR_ZERO = 18,\n\tARG_PTR_TO_BTF_ID_SOCK_COMMON = 19,\n\tARG_PTR_TO_PERCPU_BTF_ID = 20,\n\tARG_PTR_TO_FUNC = 21,\n\tARG_PTR_TO_STACK = 22,\n\tARG_PTR_TO_CONST_STR = 23,\n\tARG_PTR_TO_TIMER = 24,\n\t__BPF_ARG_TYPE_MAX = 25,\n\tARG_PTR_TO_MAP_VALUE_OR_NULL = 259,\n\tARG_PTR_TO_MEM_OR_NULL = 261,\n\tARG_PTR_TO_CTX_OR_NULL = 265,\n\tARG_PTR_TO_SOCKET_OR_NULL = 271,\n\tARG_PTR_TO_ALLOC_MEM_OR_NULL = 273,\n\tARG_PTR_TO_STACK_OR_NULL = 278,\n\t__BPF_ARG_TYPE_LIMIT = 1023,\n};\n\nenum bpf_return_type {\n\tRET_INTEGER = 0,\n\tRET_VOID = 1,\n\tRET_PTR_TO_MAP_VALUE = 2,\n\tRET_PTR_TO_SOCKET = 3,\n\tRET_PTR_TO_TCP_SOCK = 4,\n\tRET_PTR_TO_SOCK_COMMON = 5,\n\tRET_PTR_TO_ALLOC_MEM = 6,\n\tRET_PTR_TO_MEM_OR_BTF_ID = 7,\n\tRET_PTR_TO_BTF_ID = 8,\n\t__BPF_RET_TYPE_MAX = 9,\n\tRET_PTR_TO_MAP_VALUE_OR_NULL = 258,\n\tRET_PTR_TO_SOCKET_OR_NULL = 259,\n\tRET_PTR_TO_TCP_SOCK_OR_NULL = 260,\n\tRET_PTR_TO_SOCK_COMMON_OR_NULL = 261,\n\tRET_PTR_TO_ALLOC_MEM_OR_NULL = 262,\n\tRET_PTR_TO_BTF_ID_OR_NULL = 264,\n\t__BPF_RET_TYPE_LIMIT = 1023,\n};\n\nenum bpf_cgroup_storage_type {\n\tBPF_CGROUP_STORAGE_SHARED = 0,\n\tBPF_CGROUP_STORAGE_PERCPU = 1,\n\t__BPF_CGROUP_STORAGE_MAX = 2,\n};\n\nenum bpf_tramp_prog_type {\n\tBPF_TRAMP_FENTRY = 0,\n\tBPF_TRAMP_FEXIT = 1,\n\tBPF_TRAMP_MODIFY_RETURN = 2,\n\tBPF_TRAMP_MAX = 3,\n\tBPF_TRAMP_REPLACE = 4,\n};\n\nenum cgroup_bpf_attach_type {\n\tCGROUP_BPF_ATTACH_TYPE_INVALID = 4294967295,\n\tCGROUP_INET_INGRESS = 0,\n\tCGROUP_INET_EGRESS = 1,\n\tCGROUP_INET_SOCK_CREATE = 2,\n\tCGROUP_SOCK_OPS = 3,\n\tCGROUP_DEVICE = 4,\n\tCGROUP_INET4_BIND = 5,\n\tCGROUP_INET6_BIND = 6,\n\tCGROUP_INET4_CONNECT = 7,\n\tCGROUP_INET6_CONNECT = 8,\n\tCGROUP_INET4_POST_BIND = 9,\n\tCGROUP_INET6_POST_BIND = 10,\n\tCGROUP_UDP4_SENDMSG = 11,\n\tCGROUP_UDP6_SENDMSG = 12,\n\tCGROUP_SYSCTL = 13,\n\tCGROUP_UDP4_RECVMSG = 14,\n\tCGROUP_UDP6_RECVMSG = 15,\n\tCGROUP_GETSOCKOPT = 16,\n\tCGROUP_SETSOCKOPT = 17,\n\tCGROUP_INET4_GETPEERNAME = 18,\n\tCGROUP_INET6_GETPEERNAME = 19,\n\tCGROUP_INET4_GETSOCKNAME = 20,\n\tCGROUP_INET6_GETSOCKNAME = 21,\n\tCGROUP_INET_SOCK_RELEASE = 22,\n\tMAX_CGROUP_BPF_ATTACH_TYPE = 23,\n};\n\nenum psi_task_count {\n\tNR_IOWAIT = 0,\n\tNR_MEMSTALL = 1,\n\tNR_RUNNING = 2,\n\tNR_ONCPU = 3,\n\tNR_MEMSTALL_RUNNING = 4,\n\tNR_PSI_TASK_COUNTS = 5,\n};\n\nenum psi_states {\n\tPSI_IO_SOME = 0,\n\tPSI_IO_FULL = 1,\n\tPSI_MEM_SOME = 2,\n\tPSI_MEM_FULL = 3,\n\tPSI_CPU_SOME = 4,\n\tPSI_CPU_FULL = 5,\n\tPSI_NONIDLE = 6,\n\tNR_PSI_STATES = 7,\n};\n\nenum psi_aggregators {\n\tPSI_AVGS = 0,\n\tPSI_POLL = 1,\n\tNR_PSI_AGGREGATORS = 2,\n};\n\nenum cgroup_subsys_id {\n\tcpuset_cgrp_id = 0,\n\tcpu_cgrp_id = 1,\n\tcpuacct_cgrp_id = 2,\n\tio_cgrp_id = 3,\n\tmemory_cgrp_id = 4,\n\tdevices_cgrp_id = 5,\n\tfreezer_cgrp_id = 6,\n\tnet_cls_cgrp_id = 7,\n\tperf_event_cgrp_id = 8,\n\tnet_prio_cgrp_id = 9,\n\thugetlb_cgrp_id = 10,\n\tpids_cgrp_id = 11,\n\trdma_cgrp_id = 12,\n\tmisc_cgrp_id = 13,\n\tCGROUP_SUBSYS_COUNT = 14,\n};\n\nstruct vdso_exception_table_entry {\n\tint insn;\n\tint fixup;\n};\n\nstruct cpuinfo_x86 {\n\t__u8 x86;\n\t__u8 x86_vendor;\n\t__u8 x86_model;\n\t__u8 x86_stepping;\n\tint x86_tlbsize;\n\t__u32 vmx_capability[3];\n\t__u8 x86_virt_bits;\n\t__u8 x86_phys_bits;\n\t__u8 x86_coreid_bits;\n\t__u8 cu_id;\n\t__u32 extended_cpuid_level;\n\tint cpuid_level;\n\tunion {\n\t\t__u32 x86_capability[21];\n\t\tlong unsigned int x86_capability_alignment;\n\t};\n\tchar x86_vendor_id[16];\n\tchar x86_model_id[64];\n\tunsigned int x86_cache_size;\n\tint x86_cache_alignment;\n\tint x86_cache_max_rmid;\n\tint x86_cache_occ_scale;\n\tint x86_cache_mbm_width_offset;\n\tint x86_power;\n\tlong unsigned int loops_per_jiffy;\n\tu16 x86_max_cores;\n\tu16 apicid;\n\tu16 initial_apicid;\n\tu16 x86_clflush_size;\n\tu16 booted_cores;\n\tu16 phys_proc_id;\n\tu16 logical_proc_id;\n\tu16 cpu_core_id;\n\tu16 cpu_die_id;\n\tu16 logical_die_id;\n\tu16 cpu_index;\n\tbool smt_active;\n\tu32 microcode;\n\tu8 x86_cache_bits;\n\tunsigned int initialized: 1;\n};\n\nenum syscall_work_bit {\n\tSYSCALL_WORK_BIT_SECCOMP = 0,\n\tSYSCALL_WORK_BIT_SYSCALL_TRACEPOINT = 1,\n\tSYSCALL_WORK_BIT_SYSCALL_TRACE = 2,\n\tSYSCALL_WORK_BIT_SYSCALL_EMU = 3,\n\tSYSCALL_WORK_BIT_SYSCALL_AUDIT = 4,\n\tSYSCALL_WORK_BIT_SYSCALL_USER_DISPATCH = 5,\n\tSYSCALL_WORK_BIT_SYSCALL_EXIT_TRAP = 6,\n};\n\nstruct seccomp_data {\n\tint nr;\n\t__u32 arch;\n\t__u64 instruction_pointer;\n\t__u64 args[6];\n};\n\nenum x86_pf_error_code {\n\tX86_PF_PROT = 1,\n\tX86_PF_WRITE = 2,\n\tX86_PF_USER = 4,\n\tX86_PF_RSVD = 8,\n\tX86_PF_INSTR = 16,\n\tX86_PF_PK = 32,\n\tX86_PF_SGX = 32768,\n};\n\nstruct trace_event_raw_emulate_vsyscall {\n\tstruct trace_entry ent;\n\tint nr;\n\tchar __data[0];\n};\n\nstruct trace_event_data_offsets_emulate_vsyscall {};\n\ntypedef void (*btf_trace_emulate_vsyscall)(void *, int);\n\nenum {\n\tEMULATE = 0,\n\tXONLY = 1,\n\tNONE = 2,\n};\n\nenum perf_type_id {\n\tPERF_TYPE_HARDWARE = 0,\n\tPERF_TYPE_SOFTWARE = 1,\n\tPERF_TYPE_TRACEPOINT = 2,\n\tPERF_TYPE_HW_CACHE = 3,\n\tPERF_TYPE_RAW = 4,\n\tPERF_TYPE_BREAKPOINT = 5,\n\tPERF_TYPE_MAX = 6,\n};\n\nenum perf_hw_id {\n\tPERF_COUNT_HW_CPU_CYCLES = 0,\n\tPERF_COUNT_HW_INSTRUCTIONS = 1,\n\tPERF_COUNT_HW_CACHE_REFERENCES = 2,\n\tPERF_COUNT_HW_CACHE_MISSES = 3,\n\tPERF_COUNT_HW_BRANCH_INSTRUCTIONS = 4,\n\tPERF_COUNT_HW_BRANCH_MISSES = 5,\n\tPERF_COUNT_HW_BUS_CYCLES = 6,\n\tPERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 7,\n\tPERF_COUNT_HW_STALLED_CYCLES_BACKEND = 8,\n\tPERF_COUNT_HW_REF_CPU_CYCLES = 9,\n\tPERF_COUNT_HW_MAX = 10,\n};\n\nenum perf_hw_cache_id {\n\tPERF_COUNT_HW_CACHE_L1D = 0,\n\tPERF_COUNT_HW_CACHE_L1I = 1,\n\tPERF_COUNT_HW_CACHE_LL = 2,\n\tPERF_COUNT_HW_CACHE_DTLB = 3,\n\tPERF_COUNT_HW_CACHE_ITLB = 4,\n\tPERF_COUNT_HW_CACHE_BPU = 5,\n\tPERF_COUNT_HW_CACHE_NODE = 6,\n\tPERF_COUNT_HW_CACHE_MAX = 7,\n};\n\nenum perf_hw_cache_op_id {\n\tPERF_COUNT_HW_CACHE_OP_READ = 0,\n\tPERF_COUNT_HW_CACHE_OP_WRITE = 1,\n\tPERF_COUNT_HW_CACHE_OP_PREFETCH = 2,\n\tPERF_COUNT_HW_CACHE_OP_MAX = 3,\n};\n\nenum perf_hw_cache_op_result_id {\n\tPERF_COUNT_HW_CACHE_RESULT_ACCESS = 0,\n\tPERF_COUNT_HW_CACHE_RESULT_MISS = 1,\n\tPERF_COUNT_HW_CACHE_RESULT_MAX = 2,\n};\n\nenum perf_event_sample_format {\n\tPERF_SAMPLE_IP = 1,\n\tPERF_SAMPLE_TID = 2,\n\tPERF_SAMPLE_TIME = 4,\n\tPERF_SAMPLE_ADDR = 8,\n\tPERF_SAMPLE_READ = 16,\n\tPERF_SAMPLE_CALLCHAIN = 32,\n\tPERF_SAMPLE_ID = 64,\n\tPERF_SAMPLE_CPU = 128,\n\tPERF_SAMPLE_PERIOD = 256,\n\tPERF_SAMPLE_STREAM_ID = 512,\n\tPERF_SAMPLE_RAW = 1024,\n\tPERF_SAMPLE_BRANCH_STACK = 2048,\n\tPERF_SAMPLE_REGS_USER = 4096,\n\tPERF_SAMPLE_STACK_USER = 8192,\n\tPERF_SAMPLE_WEIGHT = 16384,\n\tPERF_SAMPLE_DATA_SRC = 32768,\n\tPERF_SAMPLE_IDENTIFIER = 65536,\n\tPERF_SAMPLE_TRANSACTION = 131072,\n\tPERF_SAMPLE_REGS_INTR = 262144,\n\tPERF_SAMPLE_PHYS_ADDR = 524288,\n\tPERF_SAMPLE_AUX = 1048576,\n\tPERF_SAMPLE_CGROUP = 2097152,\n\tPERF_SAMPLE_DATA_PAGE_SIZE = 4194304,\n\tPERF_SAMPLE_CODE_PAGE_SIZE = 8388608,\n\tPERF_SAMPLE_WEIGHT_STRUCT = 16777216,\n\tPERF_SAMPLE_MAX = 33554432,\n\t__PERF_SAMPLE_CALLCHAIN_EARLY = 0,\n};\n\nenum perf_branch_sample_type {\n\tPERF_SAMPLE_BRANCH_USER = 1,\n\tPERF_SAMPLE_BRANCH_KERNEL = 2,\n\tPERF_SAMPLE_BRANCH_HV = 4,\n\tPERF_SAMPLE_BRANCH_ANY = 8,\n\tPERF_SAMPLE_BRANCH_ANY_CALL = 16,\n\tPERF_SAMPLE_BRANCH_ANY_RETURN = 32,\n\tPERF_SAMPLE_BRANCH_IND_CALL = 64,\n\tPERF_SAMPLE_BRANCH_ABORT_TX = 128,\n\tPERF_SAMPLE_BRANCH_IN_TX = 256,\n\tPERF_SAMPLE_BRANCH_NO_TX = 512,\n\tPERF_SAMPLE_BRANCH_COND = 1024,\n\tPERF_SAMPLE_BRANCH_CALL_STACK = 2048,\n\tPERF_SAMPLE_BRANCH_IND_JUMP = 4096,\n\tPERF_SAMPLE_BRANCH_CALL = 8192,\n\tPERF_SAMPLE_BRANCH_NO_FLAGS = 16384,\n\tPERF_SAMPLE_BRANCH_NO_CYCLES = 32768,\n\tPERF_SAMPLE_BRANCH_TYPE_SAVE = 65536,\n\tPERF_SAMPLE_BRANCH_HW_INDEX = 131072,\n\tPERF_SAMPLE_BRANCH_MAX = 262144,\n};\n\nstruct perf_event_mmap_page {\n\t__u32 version;\n\t__u32 compat_version;\n\t__u32 lock;\n\t__u32 index;\n\t__s64 offset;\n\t__u64 time_enabled;\n\t__u64 time_running;\n\tunion {\n\t\t__u64 capabilities;\n\t\tstruct {\n\t\t\t__u64 cap_bit0: 1;\n\t\t\t__u64 cap_bit0_is_deprecated: 1;\n\t\t\t__u64 cap_user_rdpmc: 1;\n\t\t\t__u64 cap_user_time: 1;\n\t\t\t__u64 cap_user_time_zero: 1;\n\t\t\t__u64 cap_user_time_short: 1;\n\t\t\t__u64 cap_____res: 58;\n\t\t};\n\t};\n\t__u16 pmc_width;\n\t__u16 time_shift;\n\t__u32 time_mult;\n\t__u64 time_offset;\n\t__u64 time_zero;\n\t__u32 size;\n\t__u32 __reserved_1;\n\t__u64 time_cycles;\n\t__u64 time_mask;\n\t__u8 __reserved[928];\n\t__u64 data_head;\n\t__u64 data_tail;\n\t__u64 data_offset;\n\t__u64 data_size;\n\t__u64 aux_head;\n\t__u64 aux_tail;\n\t__u64 aux_offset;\n\t__u64 aux_size;\n};\n\nstruct pv_info {\n\tu16 extra_user_64bit_cs;\n\tconst char *name;\n};\n\ntypedef bool (*smp_cond_func_t)(int, void *);\n\nenum apic_delivery_modes {\n\tAPIC_DELIVERY_MODE_FIXED = 0,\n\tAPIC_DELIVERY_MODE_LOWESTPRIO = 1,\n\tAPIC_DELIVERY_MODE_SMI = 2,\n\tAPIC_DELIVERY_MODE_NMI = 4,\n\tAPIC_DELIVERY_MODE_INIT = 5,\n\tAPIC_DELIVERY_MODE_EXTINT = 7,\n};\n\nstruct physid_mask {\n\tlong unsigned int mask[512];\n};\n\ntypedef struct physid_mask physid_mask_t;\n\nstruct x86_pmu_capability {\n\tint version;\n\tint num_counters_gp;\n\tint num_counters_fixed;\n\tint bit_width_gp;\n\tint bit_width_fixed;\n\tunsigned int events_mask;\n\tint events_mask_len;\n};\n\nstruct debug_store {\n\tu64 bts_buffer_base;\n\tu64 bts_index;\n\tu64 bts_absolute_maximum;\n\tu64 bts_interrupt_threshold;\n\tu64 pebs_buffer_base;\n\tu64 pebs_index;\n\tu64 pebs_absolute_maximum;\n\tu64 pebs_interrupt_threshold;\n\tu64 pebs_event_reset[12];\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nenum stack_type {\n\tSTACK_TYPE_UNKNOWN = 0,\n\tSTACK_TYPE_TASK = 1,\n\tSTACK_TYPE_IRQ = 2,\n\tSTACK_TYPE_SOFTIRQ = 3,\n\tSTACK_TYPE_ENTRY = 4,\n\tSTACK_TYPE_EXCEPTION = 5,\n\tSTACK_TYPE_EXCEPTION_LAST = 10,\n};\n\nstruct stack_info {\n\tenum stack_type type;\n\tlong unsigned int *begin;\n\tlong unsigned int *end;\n\tlong unsigned int *next_sp;\n};\n\nstruct stack_frame {\n\tstruct stack_frame *next_frame;\n\tlong unsigned int return_address;\n};\n\nstruct stack_frame_ia32 {\n\tu32 next_frame;\n\tu32 return_address;\n};\n\nstruct perf_guest_switch_msr {\n\tunsigned int msr;\n\tu64 host;\n\tu64 guest;\n};\n\nstruct perf_guest_info_callbacks {\n\tint (*is_in_guest)();\n\tint (*is_user_mode)();\n\tlong unsigned int (*get_guest_ip)();\n\tvoid (*handle_intel_pt_intr)();\n};\n\nstruct device_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct device *, struct device_attribute *, char *);\n\tssize_t (*store)(struct device *, struct device_attribute *, const char *, size_t);\n};\n\nenum perf_event_x86_regs {\n\tPERF_REG_X86_AX = 0,\n\tPERF_REG_X86_BX = 1,\n\tPERF_REG_X86_CX = 2,\n\tPERF_REG_X86_DX = 3,\n\tPERF_REG_X86_SI = 4,\n\tPERF_REG_X86_DI = 5,\n\tPERF_REG_X86_BP = 6,\n\tPERF_REG_X86_SP = 7,\n\tPERF_REG_X86_IP = 8,\n\tPERF_REG_X86_FLAGS = 9,\n\tPERF_REG_X86_CS = 10,\n\tPERF_REG_X86_SS = 11,\n\tPERF_REG_X86_DS = 12,\n\tPERF_REG_X86_ES = 13,\n\tPERF_REG_X86_FS = 14,\n\tPERF_REG_X86_GS = 15,\n\tPERF_REG_X86_R8 = 16,\n\tPERF_REG_X86_R9 = 17,\n\tPERF_REG_X86_R10 = 18,\n\tPERF_REG_X86_R11 = 19,\n\tPERF_REG_X86_R12 = 20,\n\tPERF_REG_X86_R13 = 21,\n\tPERF_REG_X86_R14 = 22,\n\tPERF_REG_X86_R15 = 23,\n\tPERF_REG_X86_32_MAX = 16,\n\tPERF_REG_X86_64_MAX = 24,\n\tPERF_REG_X86_XMM0 = 32,\n\tPERF_REG_X86_XMM1 = 34,\n\tPERF_REG_X86_XMM2 = 36,\n\tPERF_REG_X86_XMM3 = 38,\n\tPERF_REG_X86_XMM4 = 40,\n\tPERF_REG_X86_XMM5 = 42,\n\tPERF_REG_X86_XMM6 = 44,\n\tPERF_REG_X86_XMM7 = 46,\n\tPERF_REG_X86_XMM8 = 48,\n\tPERF_REG_X86_XMM9 = 50,\n\tPERF_REG_X86_XMM10 = 52,\n\tPERF_REG_X86_XMM11 = 54,\n\tPERF_REG_X86_XMM12 = 56,\n\tPERF_REG_X86_XMM13 = 58,\n\tPERF_REG_X86_XMM14 = 60,\n\tPERF_REG_X86_XMM15 = 62,\n\tPERF_REG_X86_XMM_MAX = 64,\n};\n\nstruct perf_callchain_entry_ctx {\n\tstruct perf_callchain_entry *entry;\n\tu32 max_stack;\n\tu32 nr;\n\tshort int contexts;\n\tbool contexts_maxed;\n};\n\nstruct perf_pmu_events_attr {\n\tstruct device_attribute attr;\n\tu64 id;\n\tconst char *event_str;\n};\n\nstruct perf_pmu_events_ht_attr {\n\tstruct device_attribute attr;\n\tu64 id;\n\tconst char *event_str_ht;\n\tconst char *event_str_noht;\n};\n\nstruct perf_pmu_events_hybrid_attr {\n\tstruct device_attribute attr;\n\tu64 id;\n\tconst char *event_str;\n\tu64 pmu_type;\n};\n\nstruct apic {\n\tvoid (*eoi_write)(u32, u32);\n\tvoid (*native_eoi_write)(u32, u32);\n\tvoid (*write)(u32, u32);\n\tu32 (*read)(u32);\n\tvoid (*wait_icr_idle)();\n\tu32 (*safe_wait_icr_idle)();\n\tvoid (*send_IPI)(int, int);\n\tvoid (*send_IPI_mask)(const struct cpumask *, int);\n\tvoid (*send_IPI_mask_allbutself)(const struct cpumask *, int);\n\tvoid (*send_IPI_allbutself)(int);\n\tvoid (*send_IPI_all)(int);\n\tvoid (*send_IPI_self)(int);\n\tu32 disable_esr;\n\tenum apic_delivery_modes delivery_mode;\n\tbool dest_mode_logical;\n\tu32 (*calc_dest_apicid)(unsigned int);\n\tu64 (*icr_read)();\n\tvoid (*icr_write)(u32, u32);\n\tint (*probe)();\n\tint (*acpi_madt_oem_check)(char *, char *);\n\tint (*apic_id_valid)(u32);\n\tint (*apic_id_registered)();\n\tbool (*check_apicid_used)(physid_mask_t *, int);\n\tvoid (*init_apic_ldr)();\n\tvoid (*ioapic_phys_id_map)(physid_mask_t *, physid_mask_t *);\n\tvoid (*setup_apic_routing)();\n\tint (*cpu_present_to_apicid)(int);\n\tvoid (*apicid_to_cpu_present)(int, physid_mask_t *);\n\tint (*check_phys_apicid_present)(int);\n\tint (*phys_pkg_id)(int, int);\n\tu32 (*get_apic_id)(long unsigned int);\n\tu32 (*set_apic_id)(unsigned int);\n\tint (*wakeup_secondary_cpu)(int, long unsigned int);\n\tvoid (*inquire_remote_apic)(int);\n\tchar *name;\n};\n\nenum {\n\tNMI_LOCAL = 0,\n\tNMI_UNKNOWN = 1,\n\tNMI_SERR = 2,\n\tNMI_IO_CHECK = 3,\n\tNMI_MAX = 4,\n};\n\ntypedef int (*nmi_handler_t)(unsigned int, struct pt_regs *);\n\nstruct nmiaction {\n\tstruct list_head list;\n\tnmi_handler_t handler;\n\tu64 max_duration;\n\tlong unsigned int flags;\n\tconst char *name;\n};\n\nstruct gdt_page {\n\tstruct desc_struct gdt[16];\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct cyc2ns_data {\n\tu32 cyc2ns_mul;\n\tu32 cyc2ns_shift;\n\tu64 cyc2ns_offset;\n};\n\nstruct unwind_state {\n\tstruct stack_info stack_info;\n\tlong unsigned int stack_mask;\n\tstruct task_struct *task;\n\tint graph_idx;\n\tbool error;\n\tbool got_irq;\n\tlong unsigned int *bp;\n\tlong unsigned int *orig_sp;\n\tlong unsigned int ip;\n\tlong unsigned int *next_bp;\n\tstruct pt_regs *regs;\n};\n\nenum extra_reg_type {\n\tEXTRA_REG_NONE = 4294967295,\n\tEXTRA_REG_RSP_0 = 0,\n\tEXTRA_REG_RSP_1 = 1,\n\tEXTRA_REG_LBR = 2,\n\tEXTRA_REG_LDLAT = 3,\n\tEXTRA_REG_FE = 4,\n\tEXTRA_REG_MAX = 5,\n};\n\nstruct event_constraint {\n\tunion {\n\t\tlong unsigned int idxmsk[1];\n\t\tu64 idxmsk64;\n\t};\n\tu64 code;\n\tu64 cmask;\n\tint weight;\n\tint overlap;\n\tint flags;\n\tunsigned int size;\n};\n\nstruct amd_nb {\n\tint nb_id;\n\tint refcnt;\n\tstruct perf_event *owners[64];\n\tstruct event_constraint event_constraints[64];\n};\n\nstruct er_account {\n\traw_spinlock_t lock;\n\tu64 config;\n\tu64 reg;\n\tatomic_t ref;\n};\n\nstruct intel_shared_regs {\n\tstruct er_account regs[5];\n\tint refcnt;\n\tunsigned int core_id;\n};\n\nenum intel_excl_state_type {\n\tINTEL_EXCL_UNUSED = 0,\n\tINTEL_EXCL_SHARED = 1,\n\tINTEL_EXCL_EXCLUSIVE = 2,\n};\n\nstruct intel_excl_states {\n\tenum intel_excl_state_type state[64];\n\tbool sched_started;\n};\n\nstruct intel_excl_cntrs {\n\traw_spinlock_t lock;\n\tstruct intel_excl_states states[2];\n\tunion {\n\t\tu16 has_exclusive[2];\n\t\tu32 exclusive_present;\n\t};\n\tint refcnt;\n\tunsigned int core_id;\n};\n\nenum {\n\tX86_PERF_KFREE_SHARED = 0,\n\tX86_PERF_KFREE_EXCL = 1,\n\tX86_PERF_KFREE_MAX = 2,\n};\n\nstruct cpu_hw_events {\n\tstruct perf_event *events[64];\n\tlong unsigned int active_mask[1];\n\tlong unsigned int dirty[1];\n\tint enabled;\n\tint n_events;\n\tint n_added;\n\tint n_txn;\n\tint n_txn_pair;\n\tint n_txn_metric;\n\tint assign[64];\n\tu64 tags[64];\n\tstruct perf_event *event_list[64];\n\tstruct event_constraint *event_constraint[64];\n\tint n_excl;\n\tunsigned int txn_flags;\n\tint is_fake;\n\tstruct debug_store *ds;\n\tvoid *ds_pebs_vaddr;\n\tvoid *ds_bts_vaddr;\n\tu64 pebs_enabled;\n\tint n_pebs;\n\tint n_large_pebs;\n\tint n_pebs_via_pt;\n\tint pebs_output;\n\tu64 pebs_data_cfg;\n\tu64 active_pebs_data_cfg;\n\tint pebs_record_size;\n\tint lbr_users;\n\tint lbr_pebs_users;\n\tstruct perf_branch_stack lbr_stack;\n\tstruct perf_branch_entry lbr_entries[32];\n\tunion {\n\t\tstruct er_account *lbr_sel;\n\t\tstruct er_account *lbr_ctl;\n\t};\n\tu64 br_sel;\n\tvoid *last_task_ctx;\n\tint last_log_id;\n\tint lbr_select;\n\tvoid *lbr_xsave;\n\tu64 intel_ctrl_guest_mask;\n\tu64 intel_ctrl_host_mask;\n\tstruct perf_guest_switch_msr guest_switch_msrs[64];\n\tu64 intel_cp_status;\n\tstruct intel_shared_regs *shared_regs;\n\tstruct event_constraint *constraint_list;\n\tstruct intel_excl_cntrs *excl_cntrs;\n\tint excl_thread_id;\n\tu64 tfa_shadow;\n\tint n_metric;\n\tstruct amd_nb *amd_nb;\n\tu64 perf_ctr_virt_mask;\n\tint n_pair;\n\tvoid *kfree_on_online[2];\n\tstruct pmu *pmu;\n};\n\nstruct extra_reg {\n\tunsigned int event;\n\tunsigned int msr;\n\tu64 config_mask;\n\tu64 valid_mask;\n\tint idx;\n\tbool extra_msr_access;\n};\n\nunion perf_capabilities {\n\tstruct {\n\t\tu64 lbr_format: 6;\n\t\tu64 pebs_trap: 1;\n\t\tu64 pebs_arch_reg: 1;\n\t\tu64 pebs_format: 4;\n\t\tu64 smm_freeze: 1;\n\t\tu64 full_width_write: 1;\n\t\tu64 pebs_baseline: 1;\n\t\tu64 perf_metrics: 1;\n\t\tu64 pebs_output_pt_available: 1;\n\t\tu64 anythread_deprecated: 1;\n\t};\n\tu64 capabilities;\n};\n\nstruct x86_pmu_quirk {\n\tstruct x86_pmu_quirk *next;\n\tvoid (*func)();\n};\n\nenum {\n\tx86_lbr_exclusive_lbr = 0,\n\tx86_lbr_exclusive_bts = 1,\n\tx86_lbr_exclusive_pt = 2,\n\tx86_lbr_exclusive_max = 3,\n};\n\nstruct x86_hybrid_pmu {\n\tstruct pmu pmu;\n\tconst char *name;\n\tu8 cpu_type;\n\tcpumask_t supported_cpus;\n\tunion perf_capabilities intel_cap;\n\tu64 intel_ctrl;\n\tint max_pebs_events;\n\tint num_counters;\n\tint num_counters_fixed;\n\tstruct event_constraint unconstrained;\n\tu64 hw_cache_event_ids[42];\n\tu64 hw_cache_extra_regs[42];\n\tstruct event_constraint *event_constraints;\n\tstruct event_constraint *pebs_constraints;\n\tstruct extra_reg *extra_regs;\n\tunsigned int late_ack: 1;\n\tunsigned int mid_ack: 1;\n\tunsigned int enabled_ack: 1;\n};\n\nenum hybrid_pmu_type {\n\thybrid_big = 64,\n\thybrid_small = 32,\n\thybrid_big_small = 96,\n};\n\nstruct x86_pmu {\n\tconst char *name;\n\tint version;\n\tint (*handle_irq)(struct pt_regs *);\n\tvoid (*disable_all)();\n\tvoid (*enable_all)(int);\n\tvoid (*enable)(struct perf_event *);\n\tvoid (*disable)(struct perf_event *);\n\tvoid (*add)(struct perf_event *);\n\tvoid (*del)(struct perf_event *);\n\tvoid (*read)(struct perf_event *);\n\tint (*hw_config)(struct perf_event *);\n\tint (*schedule_events)(struct cpu_hw_events *, int, int *);\n\tunsigned int eventsel;\n\tunsigned int perfctr;\n\tint (*addr_offset)(int, bool);\n\tint (*rdpmc_index)(int);\n\tu64 (*event_map)(int);\n\tint max_events;\n\tint num_counters;\n\tint num_counters_fixed;\n\tint cntval_bits;\n\tu64 cntval_mask;\n\tunion {\n\t\tlong unsigned int events_maskl;\n\t\tlong unsigned int events_mask[1];\n\t};\n\tint events_mask_len;\n\tint apic;\n\tu64 max_period;\n\tstruct event_constraint * (*get_event_constraints)(struct cpu_hw_events *, int, struct perf_event *);\n\tvoid (*put_event_constraints)(struct cpu_hw_events *, struct perf_event *);\n\tvoid (*start_scheduling)(struct cpu_hw_events *);\n\tvoid (*commit_scheduling)(struct cpu_hw_events *, int, int);\n\tvoid (*stop_scheduling)(struct cpu_hw_events *);\n\tstruct event_constraint *event_constraints;\n\tstruct x86_pmu_quirk *quirks;\n\tint perfctr_second_write;\n\tu64 (*limit_period)(struct perf_event *, u64);\n\tunsigned int late_ack: 1;\n\tunsigned int mid_ack: 1;\n\tunsigned int enabled_ack: 1;\n\tint attr_rdpmc_broken;\n\tint attr_rdpmc;\n\tstruct attribute **format_attrs;\n\tssize_t (*events_sysfs_show)(char *, u64);\n\tconst struct attribute_group **attr_update;\n\tlong unsigned int attr_freeze_on_smi;\n\tint (*cpu_prepare)(int);\n\tvoid (*cpu_starting)(int);\n\tvoid (*cpu_dying)(int);\n\tvoid (*cpu_dead)(int);\n\tvoid (*check_microcode)();\n\tvoid (*sched_task)(struct perf_event_context *, bool);\n\tu64 intel_ctrl;\n\tunion perf_capabilities intel_cap;\n\tunsigned int bts: 1;\n\tunsigned int bts_active: 1;\n\tunsigned int pebs: 1;\n\tunsigned int pebs_active: 1;\n\tunsigned int pebs_broken: 1;\n\tunsigned int pebs_prec_dist: 1;\n\tunsigned int pebs_no_tlb: 1;\n\tunsigned int pebs_no_isolation: 1;\n\tunsigned int pebs_block: 1;\n\tint pebs_record_size;\n\tint pebs_buffer_size;\n\tint max_pebs_events;\n\tvoid (*drain_pebs)(struct pt_regs *, struct perf_sample_data *);\n\tstruct event_constraint *pebs_constraints;\n\tvoid (*pebs_aliases)(struct perf_event *);\n\tlong unsigned int large_pebs_flags;\n\tu64 rtm_abort_event;\n\tunsigned int lbr_tos;\n\tunsigned int lbr_from;\n\tunsigned int lbr_to;\n\tunsigned int lbr_info;\n\tunsigned int lbr_nr;\n\tunion {\n\t\tu64 lbr_sel_mask;\n\t\tu64 lbr_ctl_mask;\n\t};\n\tunion {\n\t\tconst int *lbr_sel_map;\n\t\tint *lbr_ctl_map;\n\t};\n\tbool lbr_double_abort;\n\tbool lbr_pt_coexist;\n\tunsigned int lbr_depth_mask: 8;\n\tunsigned int lbr_deep_c_reset: 1;\n\tunsigned int lbr_lip: 1;\n\tunsigned int lbr_cpl: 1;\n\tunsigned int lbr_filter: 1;\n\tunsigned int lbr_call_stack: 1;\n\tunsigned int lbr_mispred: 1;\n\tunsigned int lbr_timed_lbr: 1;\n\tunsigned int lbr_br_type: 1;\n\tvoid (*lbr_reset)();\n\tvoid (*lbr_read)(struct cpu_hw_events *);\n\tvoid (*lbr_save)(void *);\n\tvoid (*lbr_restore)(void *);\n\tatomic_t lbr_exclusive[3];\n\tint num_topdown_events;\n\tu64 (*update_topdown_event)(struct perf_event *);\n\tint (*set_topdown_event_period)(struct perf_event *);\n\tvoid (*swap_task_ctx)(struct perf_event_context *, struct perf_event_context *);\n\tunsigned int amd_nb_constraints: 1;\n\tu64 perf_ctr_pair_en;\n\tstruct extra_reg *extra_regs;\n\tunsigned int flags;\n\tstruct perf_guest_switch_msr * (*guest_get_msrs)(int *);\n\tint (*check_period)(struct perf_event *, u64);\n\tint (*aux_output_match)(struct perf_event *);\n\tint (*filter_match)(struct perf_event *);\n\tint num_hybrid_pmus;\n\tstruct x86_hybrid_pmu *hybrid_pmu;\n\tu8 (*get_hybrid_cpu_type)();\n};\n\nstruct sched_state {\n\tint weight;\n\tint event;\n\tint counter;\n\tint unassigned;\n\tint nr_gp;\n\tu64 used;\n};\n\nstruct perf_sched {\n\tint max_weight;\n\tint max_events;\n\tint max_gp;\n\tint saved_states;\n\tstruct event_constraint **constraints;\n\tstruct sched_state state;\n\tstruct sched_state saved[2];\n};\n\nstruct perf_msr {\n\tu64 msr;\n\tstruct attribute_group *grp;\n\tbool (*test)(int, void *);\n\tbool no_check;\n\tu64 mask;\n};\n\ntypedef int pci_power_t;\n\ntypedef unsigned int pci_channel_state_t;\n\ntypedef short unsigned int pci_dev_flags_t;\n\nstruct pci_vpd {\n\tstruct mutex lock;\n\tunsigned int len;\n\tu8 cap;\n};\n\nstruct pci_bus;\n\nstruct pci_slot;\n\nstruct aer_stats;\n\nstruct rcec_ea;\n\nstruct pci_driver;\n\nstruct pcie_link_state;\n\nstruct pci_sriov;\n\nstruct pci_dev {\n\tstruct list_head bus_list;\n\tstruct pci_bus *bus;\n\tstruct pci_bus *subordinate;\n\tvoid *sysdata;\n\tstruct proc_dir_entry *procent;\n\tstruct pci_slot *slot;\n\tunsigned int devfn;\n\tshort unsigned int vendor;\n\tshort unsigned int device;\n\tshort unsigned int subsystem_vendor;\n\tshort unsigned int subsystem_device;\n\tunsigned int class;\n\tu8 revision;\n\tu8 hdr_type;\n\tu16 aer_cap;\n\tstruct aer_stats *aer_stats;\n\tstruct rcec_ea *rcec_ea;\n\tstruct pci_dev *rcec;\n\tu32 devcap;\n\tu8 pcie_cap;\n\tu8 msi_cap;\n\tu8 msix_cap;\n\tu8 pcie_mpss: 3;\n\tu8 rom_base_reg;\n\tu8 pin;\n\tu16 pcie_flags_reg;\n\tlong unsigned int *dma_alias_mask;\n\tstruct pci_driver *driver;\n\tu64 dma_mask;\n\tstruct device_dma_parameters dma_parms;\n\tpci_power_t current_state;\n\tunsigned int imm_ready: 1;\n\tu8 pm_cap;\n\tunsigned int pme_support: 5;\n\tunsigned int pme_poll: 1;\n\tunsigned int d1_support: 1;\n\tunsigned int d2_support: 1;\n\tunsigned int no_d1d2: 1;\n\tunsigned int no_d3cold: 1;\n\tunsigned int bridge_d3: 1;\n\tunsigned int d3cold_allowed: 1;\n\tunsigned int mmio_always_on: 1;\n\tunsigned int wakeup_prepared: 1;\n\tunsigned int runtime_d3cold: 1;\n\tunsigned int skip_bus_pm: 1;\n\tunsigned int ignore_hotplug: 1;\n\tunsigned int hotplug_user_indicators: 1;\n\tunsigned int clear_retrain_link: 1;\n\tunsigned int d3hot_delay;\n\tunsigned int d3cold_delay;\n\tstruct pcie_link_state *link_state;\n\tunsigned int ltr_path: 1;\n\tu16 l1ss;\n\tunsigned int pasid_no_tlp: 1;\n\tunsigned int eetlp_prefix_path: 1;\n\tpci_channel_state_t error_state;\n\tstruct device dev;\n\tint cfg_size;\n\tunsigned int irq;\n\tstruct resource resource[17];\n\tbool match_driver;\n\tunsigned int transparent: 1;\n\tunsigned int io_window: 1;\n\tunsigned int pref_window: 1;\n\tunsigned int pref_64_window: 1;\n\tunsigned int multifunction: 1;\n\tunsigned int is_busmaster: 1;\n\tunsigned int no_msi: 1;\n\tunsigned int no_64bit_msi: 1;\n\tunsigned int block_cfg_access: 1;\n\tunsigned int broken_parity_status: 1;\n\tunsigned int irq_reroute_variant: 2;\n\tunsigned int msi_enabled: 1;\n\tunsigned int msix_enabled: 1;\n\tunsigned int ari_enabled: 1;\n\tunsigned int ats_enabled: 1;\n\tunsigned int pasid_enabled: 1;\n\tunsigned int pri_enabled: 1;\n\tunsigned int is_managed: 1;\n\tunsigned int needs_freset: 1;\n\tunsigned int state_saved: 1;\n\tunsigned int is_physfn: 1;\n\tunsigned int is_virtfn: 1;\n\tunsigned int is_hotplug_bridge: 1;\n\tunsigned int shpc_managed: 1;\n\tunsigned int is_thunderbolt: 1;\n\tunsigned int untrusted: 1;\n\tunsigned int external_facing: 1;\n\tunsigned int broken_intx_masking: 1;\n\tunsigned int io_window_1k: 1;\n\tunsigned int irq_managed: 1;\n\tunsigned int non_compliant_bars: 1;\n\tunsigned int is_probed: 1;\n\tunsigned int link_active_reporting: 1;\n\tunsigned int no_vf_scan: 1;\n\tunsigned int no_command_memory: 1;\n\tpci_dev_flags_t dev_flags;\n\tatomic_t enable_cnt;\n\tu32 saved_config_space[16];\n\tstruct hlist_head saved_cap_space;\n\tint rom_attr_enabled;\n\tstruct bin_attribute *res_attr[17];\n\tstruct bin_attribute *res_attr_wc[17];\n\tunsigned int broken_cmd_compl: 1;\n\tu16 ptm_cap;\n\tunsigned int ptm_root: 1;\n\tunsigned int ptm_enabled: 1;\n\tu8 ptm_granularity;\n\tconst struct attribute_group **msi_irq_groups;\n\tstruct pci_vpd vpd;\n\tu16 dpc_cap;\n\tunsigned int dpc_rp_extensions: 1;\n\tu8 dpc_rp_log_size;\n\tunion {\n\t\tstruct pci_sriov *sriov;\n\t\tstruct pci_dev *physfn;\n\t};\n\tu16 ats_cap;\n\tu8 ats_stu;\n\tu16 pri_cap;\n\tu32 pri_reqs_alloc;\n\tunsigned int pasid_required: 1;\n\tu16 pasid_cap;\n\tu16 pasid_features;\n\tu16 acs_cap;\n\tphys_addr_t rom;\n\tsize_t romlen;\n\tchar *driver_override;\n\tlong unsigned int priv_flags;\n\tu8 reset_methods[7];\n};\n\nstruct pci_device_id {\n\t__u32 vendor;\n\t__u32 device;\n\t__u32 subvendor;\n\t__u32 subdevice;\n\t__u32 class;\n\t__u32 class_mask;\n\tkernel_ulong_t driver_data;\n\t__u32 override_only;\n};\n\nstruct hotplug_slot;\n\nstruct pci_slot {\n\tstruct pci_bus *bus;\n\tstruct list_head list;\n\tstruct hotplug_slot *hotplug;\n\tunsigned char number;\n\tstruct kobject kobj;\n};\n\ntypedef short unsigned int pci_bus_flags_t;\n\nstruct pci_ops;\n\nstruct pci_bus {\n\tstruct list_head node;\n\tstruct pci_bus *parent;\n\tstruct list_head children;\n\tstruct list_head devices;\n\tstruct pci_dev *self;\n\tstruct list_head slots;\n\tstruct resource *resource[4];\n\tstruct list_head resources;\n\tstruct resource busn_res;\n\tstruct pci_ops *ops;\n\tvoid *sysdata;\n\tstruct proc_dir_entry *procdir;\n\tunsigned char number;\n\tunsigned char primary;\n\tunsigned char max_bus_speed;\n\tunsigned char cur_bus_speed;\n\tchar name[48];\n\tshort unsigned int bridge_ctl;\n\tpci_bus_flags_t bus_flags;\n\tstruct device *bridge;\n\tstruct device dev;\n\tstruct bin_attribute *legacy_io;\n\tstruct bin_attribute *legacy_mem;\n\tunsigned int is_added: 1;\n\tunsigned int unsafe_warn: 1;\n};\n\nenum {\n\tPCI_STD_RESOURCES = 0,\n\tPCI_STD_RESOURCE_END = 5,\n\tPCI_ROM_RESOURCE = 6,\n\tPCI_IOV_RESOURCES = 7,\n\tPCI_IOV_RESOURCE_END = 12,\n\tPCI_BRIDGE_RESOURCES = 13,\n\tPCI_BRIDGE_RESOURCE_END = 16,\n\tPCI_NUM_RESOURCES = 17,\n\tDEVICE_COUNT_RESOURCE = 17,\n};\n\ntypedef unsigned int pcie_reset_state_t;\n\nstruct pci_dynids {\n\tspinlock_t lock;\n\tstruct list_head list;\n};\n\nstruct pci_error_handlers;\n\nstruct pci_driver {\n\tstruct list_head node;\n\tconst char *name;\n\tconst struct pci_device_id *id_table;\n\tint (*probe)(struct pci_dev *, const struct pci_device_id *);\n\tvoid (*remove)(struct pci_dev *);\n\tint (*suspend)(struct pci_dev *, pm_message_t);\n\tint (*resume)(struct pci_dev *);\n\tvoid (*shutdown)(struct pci_dev *);\n\tint (*sriov_configure)(struct pci_dev *, int);\n\tint (*sriov_set_msix_vec_count)(struct pci_dev *, int);\n\tu32 (*sriov_get_vf_total_msix)(struct pci_dev *);\n\tconst struct pci_error_handlers *err_handler;\n\tconst struct attribute_group **groups;\n\tconst struct attribute_group **dev_groups;\n\tstruct device_driver driver;\n\tstruct pci_dynids dynids;\n};\n\nstruct pci_ops {\n\tint (*add_bus)(struct pci_bus *);\n\tvoid (*remove_bus)(struct pci_bus *);\n\tvoid * (*map_bus)(struct pci_bus *, unsigned int, int);\n\tint (*read)(struct pci_bus *, unsigned int, int, int, u32 *);\n\tint (*write)(struct pci_bus *, unsigned int, int, int, u32);\n};\n\ntypedef unsigned int pci_ers_result_t;\n\nstruct pci_error_handlers {\n\tpci_ers_result_t (*error_detected)(struct pci_dev *, pci_channel_state_t);\n\tpci_ers_result_t (*mmio_enabled)(struct pci_dev *);\n\tpci_ers_result_t (*slot_reset)(struct pci_dev *);\n\tvoid (*reset_prepare)(struct pci_dev *);\n\tvoid (*reset_done)(struct pci_dev *);\n\tvoid (*resume)(struct pci_dev *);\n};\n\nstruct syscore_ops {\n\tstruct list_head node;\n\tint (*suspend)();\n\tvoid (*resume)();\n\tvoid (*shutdown)();\n};\n\nunion ibs_fetch_ctl {\n\t__u64 val;\n\tstruct {\n\t\t__u64 fetch_maxcnt: 16;\n\t\t__u64 fetch_cnt: 16;\n\t\t__u64 fetch_lat: 16;\n\t\t__u64 fetch_en: 1;\n\t\t__u64 fetch_val: 1;\n\t\t__u64 fetch_comp: 1;\n\t\t__u64 ic_miss: 1;\n\t\t__u64 phy_addr_valid: 1;\n\t\t__u64 l1tlb_pgsz: 2;\n\t\t__u64 l1tlb_miss: 1;\n\t\t__u64 l2tlb_miss: 1;\n\t\t__u64 rand_en: 1;\n\t\t__u64 fetch_l2_miss: 1;\n\t\t__u64 reserved: 5;\n\t};\n};\n\nunion ibs_op_ctl {\n\t__u64 val;\n\tstruct {\n\t\t__u64 opmaxcnt: 16;\n\t\t__u64 reserved0: 1;\n\t\t__u64 op_en: 1;\n\t\t__u64 op_val: 1;\n\t\t__u64 cnt_ctl: 1;\n\t\t__u64 opmaxcnt_ext: 7;\n\t\t__u64 reserved1: 5;\n\t\t__u64 opcurcnt: 27;\n\t\t__u64 reserved2: 5;\n\t};\n};\n\nstruct perf_ibs_data {\n\tu32 size;\n\tunion {\n\t\tu32 data[0];\n\t\tu32 caps;\n\t};\n\tu64 regs[8];\n};\n\nenum ibs_states {\n\tIBS_ENABLED = 0,\n\tIBS_STARTED = 1,\n\tIBS_STOPPING = 2,\n\tIBS_STOPPED = 3,\n\tIBS_MAX_STATES = 4,\n};\n\nstruct cpu_perf_ibs {\n\tstruct perf_event *event;\n\tlong unsigned int state[1];\n};\n\nstruct perf_ibs {\n\tstruct pmu pmu;\n\tunsigned int msr;\n\tu64 config_mask;\n\tu64 cnt_mask;\n\tu64 enable_mask;\n\tu64 valid_mask;\n\tu64 max_period;\n\tlong unsigned int offset_mask[1];\n\tint offset_max;\n\tunsigned int fetch_count_reset_broken: 1;\n\tunsigned int fetch_ignore_if_zero_rip: 1;\n\tstruct cpu_perf_ibs *pcpu;\n\tstruct attribute **format_attrs;\n\tstruct attribute_group format_group;\n\tconst struct attribute_group *attr_groups[2];\n\tu64 (*get_count)(u64);\n};\n\nstruct amd_iommu;\n\nstruct perf_amd_iommu {\n\tstruct list_head list;\n\tstruct pmu pmu;\n\tstruct amd_iommu *iommu;\n\tchar name[16];\n\tu8 max_banks;\n\tu8 max_counters;\n\tu64 cntr_assign_mask;\n\traw_spinlock_t lock;\n};\n\nstruct amd_iommu_event_desc {\n\tstruct device_attribute attr;\n\tconst char *event;\n};\n\nenum perf_msr_id {\n\tPERF_MSR_TSC = 0,\n\tPERF_MSR_APERF = 1,\n\tPERF_MSR_MPERF = 2,\n\tPERF_MSR_PPERF = 3,\n\tPERF_MSR_SMI = 4,\n\tPERF_MSR_PTSC = 5,\n\tPERF_MSR_IRPERF = 6,\n\tPERF_MSR_THERM = 7,\n\tPERF_MSR_EVENT_MAX = 8,\n};\n\nstruct x86_cpu_desc {\n\tu8 x86_family;\n\tu8 x86_vendor;\n\tu8 x86_model;\n\tu8 x86_stepping;\n\tu32 x86_microcode_rev;\n};\n\nunion cpuid10_eax {\n\tstruct {\n\t\tunsigned int version_id: 8;\n\t\tunsigned int num_counters: 8;\n\t\tunsigned int bit_width: 8;\n\t\tunsigned int mask_length: 8;\n\t} split;\n\tunsigned int full;\n};\n\nunion cpuid10_ebx {\n\tstruct {\n\t\tunsigned int no_unhalted_core_cycles: 1;\n\t\tunsigned int no_instructions_retired: 1;\n\t\tunsigned int no_unhalted_reference_cycles: 1;\n\t\tunsigned int no_llc_reference: 1;\n\t\tunsigned int no_llc_misses: 1;\n\t\tunsigned int no_branch_instruction_retired: 1;\n\t\tunsigned int no_branch_misses_retired: 1;\n\t} split;\n\tunsigned int full;\n};\n\nunion cpuid10_edx {\n\tstruct {\n\t\tunsigned int num_counters_fixed: 5;\n\t\tunsigned int bit_width_fixed: 8;\n\t\tunsigned int reserved1: 2;\n\t\tunsigned int anythread_deprecated: 1;\n\t\tunsigned int reserved2: 16;\n\t} split;\n\tunsigned int full;\n};\n\nstruct perf_pmu_format_hybrid_attr {\n\tstruct device_attribute attr;\n\tu64 pmu_type;\n};\n\nenum {\n\tLBR_FORMAT_32 = 0,\n\tLBR_FORMAT_LIP = 1,\n\tLBR_FORMAT_EIP = 2,\n\tLBR_FORMAT_EIP_FLAGS = 3,\n\tLBR_FORMAT_EIP_FLAGS2 = 4,\n\tLBR_FORMAT_INFO = 5,\n\tLBR_FORMAT_TIME = 6,\n\tLBR_FORMAT_MAX_KNOWN = 6,\n};\n\nunion x86_pmu_config {\n\tstruct {\n\t\tu64 event: 8;\n\t\tu64 umask: 8;\n\t\tu64 usr: 1;\n\t\tu64 os: 1;\n\t\tu64 edge: 1;\n\t\tu64 pc: 1;\n\t\tu64 interrupt: 1;\n\t\tu64 __reserved1: 1;\n\t\tu64 en: 1;\n\t\tu64 inv: 1;\n\t\tu64 cmask: 8;\n\t\tu64 event2: 4;\n\t\tu64 __reserved2: 4;\n\t\tu64 go: 1;\n\t\tu64 ho: 1;\n\t} bits;\n\tu64 value;\n};\n\nenum pageflags {\n\tPG_locked = 0,\n\tPG_referenced = 1,\n\tPG_uptodate = 2,\n\tPG_dirty = 3,\n\tPG_lru = 4,\n\tPG_active = 5,\n\tPG_workingset = 6,\n\tPG_waiters = 7,\n\tPG_error = 8,\n\tPG_slab = 9,\n\tPG_owner_priv_1 = 10,\n\tPG_arch_1 = 11,\n\tPG_reserved = 12,\n\tPG_private = 13,\n\tPG_private_2 = 14,\n\tPG_writeback = 15,\n\tPG_head = 16,\n\tPG_mappedtodisk = 17,\n\tPG_reclaim = 18,\n\tPG_swapbacked = 19,\n\tPG_unevictable = 20,\n\tPG_mlocked = 21,\n\tPG_uncached = 22,\n\tPG_hwpoison = 23,\n\tPG_young = 24,\n\tPG_idle = 25,\n\tPG_arch_2 = 26,\n\t__NR_PAGEFLAGS = 27,\n\tPG_checked = 10,\n\tPG_swapcache = 10,\n\tPG_fscache = 14,\n\tPG_pinned = 10,\n\tPG_savepinned = 3,\n\tPG_foreign = 10,\n\tPG_xen_remapped = 10,\n\tPG_slob_free = 13,\n\tPG_double_map = 6,\n\tPG_has_hwpoisoned = 17,\n\tPG_isolated = 18,\n\tPG_reported = 2,\n};\n\nstruct bts_ctx {\n\tstruct perf_output_handle handle;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tstruct debug_store ds_back;\n\tint state;\n\tlong: 32;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nenum {\n\tBTS_STATE_STOPPED = 0,\n\tBTS_STATE_INACTIVE = 1,\n\tBTS_STATE_ACTIVE = 2,\n};\n\nstruct bts_phys {\n\tstruct page *page;\n\tlong unsigned int size;\n\tlong unsigned int offset;\n\tlong unsigned int displacement;\n};\n\nstruct bts_buffer {\n\tsize_t real_size;\n\tunsigned int nr_pages;\n\tunsigned int nr_bufs;\n\tunsigned int cur_buf;\n\tbool snapshot;\n\tlocal_t data_size;\n\tlocal_t head;\n\tlong unsigned int end;\n\tvoid **data_pages;\n\tstruct bts_phys buf[0];\n};\n\nstruct lbr_entry {\n\tu64 from;\n\tu64 to;\n\tu64 info;\n};\n\nstruct x86_hw_tss {\n\tu32 reserved1;\n\tu64 sp0;\n\tu64 sp1;\n\tu64 sp2;\n\tu64 reserved2;\n\tu64 ist[7];\n\tu32 reserved3;\n\tu32 reserved4;\n\tu16 reserved5;\n\tu16 io_bitmap_base;\n} __attribute__((packed));\n\nstruct entry_stack {\n\tchar stack[4096];\n};\n\nstruct entry_stack_page {\n\tstruct entry_stack stack;\n};\n\nstruct x86_io_bitmap {\n\tu64 prev_sequence;\n\tunsigned int prev_max;\n\tlong unsigned int bitmap[1025];\n\tlong unsigned int mapall[1025];\n};\n\nstruct tss_struct {\n\tstruct x86_hw_tss x86_tss;\n\tstruct x86_io_bitmap io_bitmap;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct debug_store_buffers {\n\tchar bts_buffer[65536];\n\tchar pebs_buffer[65536];\n};\n\nstruct cea_exception_stacks {\n\tchar DF_stack_guard[4096];\n\tchar DF_stack[8192];\n\tchar NMI_stack_guard[4096];\n\tchar NMI_stack[8192];\n\tchar DB_stack_guard[4096];\n\tchar DB_stack[8192];\n\tchar MCE_stack_guard[4096];\n\tchar MCE_stack[8192];\n\tchar VC_stack_guard[4096];\n\tchar VC_stack[8192];\n\tchar VC2_stack_guard[4096];\n\tchar VC2_stack[8192];\n\tchar IST_top_guard[4096];\n};\n\nstruct cpu_entry_area {\n\tchar gdt[4096];\n\tstruct entry_stack_page entry_stack_page;\n\tstruct tss_struct tss;\n\tstruct cea_exception_stacks estacks;\n\tstruct debug_store cpu_debug_store;\n\tstruct debug_store_buffers cpu_debug_buffers;\n};\n\nstruct pebs_basic {\n\tu64 format_size;\n\tu64 ip;\n\tu64 applicable_counters;\n\tu64 tsc;\n};\n\nstruct pebs_meminfo {\n\tu64 address;\n\tu64 aux;\n\tu64 latency;\n\tu64 tsx_tuning;\n};\n\nstruct pebs_gprs {\n\tu64 flags;\n\tu64 ip;\n\tu64 ax;\n\tu64 cx;\n\tu64 dx;\n\tu64 bx;\n\tu64 sp;\n\tu64 bp;\n\tu64 si;\n\tu64 di;\n\tu64 r8;\n\tu64 r9;\n\tu64 r10;\n\tu64 r11;\n\tu64 r12;\n\tu64 r13;\n\tu64 r14;\n\tu64 r15;\n};\n\nstruct pebs_xmm {\n\tu64 xmm[32];\n};\n\nstruct x86_perf_regs {\n\tstruct pt_regs regs;\n\tu64 *xmm_regs;\n};\n\ntypedef unsigned int insn_attr_t;\n\ntypedef unsigned char insn_byte_t;\n\ntypedef int insn_value_t;\n\nstruct insn_field {\n\tunion {\n\t\tinsn_value_t value;\n\t\tinsn_byte_t bytes[4];\n\t};\n\tunsigned char got;\n\tunsigned char nbytes;\n};\n\nstruct insn {\n\tstruct insn_field prefixes;\n\tstruct insn_field rex_prefix;\n\tstruct insn_field vex_prefix;\n\tstruct insn_field opcode;\n\tstruct insn_field modrm;\n\tstruct insn_field sib;\n\tstruct insn_field displacement;\n\tunion {\n\t\tstruct insn_field immediate;\n\t\tstruct insn_field moffset1;\n\t\tstruct insn_field immediate1;\n\t};\n\tunion {\n\t\tstruct insn_field moffset2;\n\t\tstruct insn_field immediate2;\n\t};\n\tint emulate_prefix_size;\n\tinsn_attr_t attr;\n\tunsigned char opnd_bytes;\n\tunsigned char addr_bytes;\n\tunsigned char length;\n\tunsigned char x86_64;\n\tconst insn_byte_t *kaddr;\n\tconst insn_byte_t *end_kaddr;\n\tconst insn_byte_t *next_byte;\n};\n\nenum {\n\tPERF_TXN_ELISION = 1,\n\tPERF_TXN_TRANSACTION = 2,\n\tPERF_TXN_SYNC = 4,\n\tPERF_TXN_ASYNC = 8,\n\tPERF_TXN_RETRY = 16,\n\tPERF_TXN_CONFLICT = 32,\n\tPERF_TXN_CAPACITY_WRITE = 64,\n\tPERF_TXN_CAPACITY_READ = 128,\n\tPERF_TXN_MAX = 256,\n\tPERF_TXN_ABORT_MASK = 0,\n\tPERF_TXN_ABORT_SHIFT = 32,\n};\n\nstruct perf_event_header {\n\t__u32 type;\n\t__u16 misc;\n\t__u16 size;\n};\n\nunion intel_x86_pebs_dse {\n\tu64 val;\n\tstruct {\n\t\tunsigned int ld_dse: 4;\n\t\tunsigned int ld_stlb_miss: 1;\n\t\tunsigned int ld_locked: 1;\n\t\tunsigned int ld_data_blk: 1;\n\t\tunsigned int ld_addr_blk: 1;\n\t\tunsigned int ld_reserved: 24;\n\t};\n\tstruct {\n\t\tunsigned int st_l1d_hit: 1;\n\t\tunsigned int st_reserved1: 3;\n\t\tunsigned int st_stlb_miss: 1;\n\t\tunsigned int st_locked: 1;\n\t\tunsigned int st_reserved2: 26;\n\t};\n\tstruct {\n\t\tunsigned int st_lat_dse: 4;\n\t\tunsigned int st_lat_stlb_miss: 1;\n\t\tunsigned int st_lat_locked: 1;\n\t\tunsigned int ld_reserved3: 26;\n\t};\n};\n\nstruct pebs_record_core {\n\tu64 flags;\n\tu64 ip;\n\tu64 ax;\n\tu64 bx;\n\tu64 cx;\n\tu64 dx;\n\tu64 si;\n\tu64 di;\n\tu64 bp;\n\tu64 sp;\n\tu64 r8;\n\tu64 r9;\n\tu64 r10;\n\tu64 r11;\n\tu64 r12;\n\tu64 r13;\n\tu64 r14;\n\tu64 r15;\n};\n\nstruct pebs_record_nhm {\n\tu64 flags;\n\tu64 ip;\n\tu64 ax;\n\tu64 bx;\n\tu64 cx;\n\tu64 dx;\n\tu64 si;\n\tu64 di;\n\tu64 bp;\n\tu64 sp;\n\tu64 r8;\n\tu64 r9;\n\tu64 r10;\n\tu64 r11;\n\tu64 r12;\n\tu64 r13;\n\tu64 r14;\n\tu64 r15;\n\tu64 status;\n\tu64 dla;\n\tu64 dse;\n\tu64 lat;\n};\n\nunion hsw_tsx_tuning {\n\tstruct {\n\t\tu32 cycles_last_block: 32;\n\t\tu32 hle_abort: 1;\n\t\tu32 rtm_abort: 1;\n\t\tu32 instruction_abort: 1;\n\t\tu32 non_instruction_abort: 1;\n\t\tu32 retry: 1;\n\t\tu32 data_conflict: 1;\n\t\tu32 capacity_writes: 1;\n\t\tu32 capacity_reads: 1;\n\t};\n\tu64 value;\n};\n\nstruct pebs_record_skl {\n\tu64 flags;\n\tu64 ip;\n\tu64 ax;\n\tu64 bx;\n\tu64 cx;\n\tu64 dx;\n\tu64 si;\n\tu64 di;\n\tu64 bp;\n\tu64 sp;\n\tu64 r8;\n\tu64 r9;\n\tu64 r10;\n\tu64 r11;\n\tu64 r12;\n\tu64 r13;\n\tu64 r14;\n\tu64 r15;\n\tu64 status;\n\tu64 dla;\n\tu64 dse;\n\tu64 lat;\n\tu64 real_ip;\n\tu64 tsx_tuning;\n\tu64 tsc;\n};\n\nstruct bts_record {\n\tu64 from;\n\tu64 to;\n\tu64 flags;\n};\n\nenum {\n\tPERF_BR_UNKNOWN = 0,\n\tPERF_BR_COND = 1,\n\tPERF_BR_UNCOND = 2,\n\tPERF_BR_IND = 3,\n\tPERF_BR_CALL = 4,\n\tPERF_BR_IND_CALL = 5,\n\tPERF_BR_RET = 6,\n\tPERF_BR_SYSCALL = 7,\n\tPERF_BR_SYSRET = 8,\n\tPERF_BR_COND_CALL = 9,\n\tPERF_BR_COND_RET = 10,\n\tPERF_BR_MAX = 11,\n};\n\nenum xfeature {\n\tXFEATURE_FP = 0,\n\tXFEATURE_SSE = 1,\n\tXFEATURE_YMM = 2,\n\tXFEATURE_BNDREGS = 3,\n\tXFEATURE_BNDCSR = 4,\n\tXFEATURE_OPMASK = 5,\n\tXFEATURE_ZMM_Hi256 = 6,\n\tXFEATURE_Hi16_ZMM = 7,\n\tXFEATURE_PT_UNIMPLEMENTED_SO_FAR = 8,\n\tXFEATURE_PKRU = 9,\n\tXFEATURE_PASID = 10,\n\tXFEATURE_RSRVD_COMP_11 = 11,\n\tXFEATURE_RSRVD_COMP_12 = 12,\n\tXFEATURE_RSRVD_COMP_13 = 13,\n\tXFEATURE_RSRVD_COMP_14 = 14,\n\tXFEATURE_LBR = 15,\n\tXFEATURE_RSRVD_COMP_16 = 16,\n\tXFEATURE_XTILE_CFG = 17,\n\tXFEATURE_XTILE_DATA = 18,\n\tXFEATURE_MAX = 19,\n};\n\nstruct arch_lbr_state {\n\tu64 lbr_ctl;\n\tu64 lbr_depth;\n\tu64 ler_from;\n\tu64 ler_to;\n\tu64 ler_info;\n\tstruct lbr_entry entries[0];\n};\n\nunion cpuid28_eax {\n\tstruct {\n\t\tunsigned int lbr_depth_mask: 8;\n\t\tunsigned int reserved: 22;\n\t\tunsigned int lbr_deep_c_reset: 1;\n\t\tunsigned int lbr_lip: 1;\n\t} split;\n\tunsigned int full;\n};\n\nunion cpuid28_ebx {\n\tstruct {\n\t\tunsigned int lbr_cpl: 1;\n\t\tunsigned int lbr_filter: 1;\n\t\tunsigned int lbr_call_stack: 1;\n\t} split;\n\tunsigned int full;\n};\n\nunion cpuid28_ecx {\n\tstruct {\n\t\tunsigned int lbr_mispred: 1;\n\t\tunsigned int lbr_timed_lbr: 1;\n\t\tunsigned int lbr_br_type: 1;\n\t} split;\n\tunsigned int full;\n};\n\nstruct x86_pmu_lbr {\n\tunsigned int nr;\n\tunsigned int from;\n\tunsigned int to;\n\tunsigned int info;\n};\n\nstruct x86_perf_task_context_opt {\n\tint lbr_callstack_users;\n\tint lbr_stack_state;\n\tint log_id;\n};\n\nstruct x86_perf_task_context {\n\tu64 lbr_sel;\n\tint tos;\n\tint valid_lbrs;\n\tstruct x86_perf_task_context_opt opt;\n\tstruct lbr_entry lbr[32];\n};\n\nstruct x86_perf_task_context_arch_lbr {\n\tstruct x86_perf_task_context_opt opt;\n\tstruct lbr_entry entries[0];\n};\n\nstruct x86_perf_task_context_arch_lbr_xsave {\n\tstruct x86_perf_task_context_opt opt;\n\tlong: 32;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tunion {\n\t\tstruct xregs_state xsave;\n\t\tstruct {\n\t\t\tstruct fxregs_state i387;\n\t\t\tstruct xstate_header header;\n\t\t\tstruct arch_lbr_state lbr;\n\t\t\tlong: 64;\n\t\t\tlong: 64;\n\t\t\tlong: 64;\n\t\t};\n\t};\n};\n\nenum {\n\tX86_BR_NONE = 0,\n\tX86_BR_USER = 1,\n\tX86_BR_KERNEL = 2,\n\tX86_BR_CALL = 4,\n\tX86_BR_RET = 8,\n\tX86_BR_SYSCALL = 16,\n\tX86_BR_SYSRET = 32,\n\tX86_BR_INT = 64,\n\tX86_BR_IRET = 128,\n\tX86_BR_JCC = 256,\n\tX86_BR_JMP = 512,\n\tX86_BR_IRQ = 1024,\n\tX86_BR_IND_CALL = 2048,\n\tX86_BR_ABORT = 4096,\n\tX86_BR_IN_TX = 8192,\n\tX86_BR_NO_TX = 16384,\n\tX86_BR_ZERO_CALL = 32768,\n\tX86_BR_CALL_STACK = 65536,\n\tX86_BR_IND_JMP = 131072,\n\tX86_BR_TYPE_SAVE = 262144,\n};\n\nenum {\n\tLBR_NONE = 0,\n\tLBR_VALID = 1,\n};\n\nenum {\n\tARCH_LBR_BR_TYPE_JCC = 0,\n\tARCH_LBR_BR_TYPE_NEAR_IND_JMP = 1,\n\tARCH_LBR_BR_TYPE_NEAR_REL_JMP = 2,\n\tARCH_LBR_BR_TYPE_NEAR_IND_CALL = 3,\n\tARCH_LBR_BR_TYPE_NEAR_REL_CALL = 4,\n\tARCH_LBR_BR_TYPE_NEAR_RET = 5,\n\tARCH_LBR_BR_TYPE_KNOWN_MAX = 5,\n\tARCH_LBR_BR_TYPE_MAP_MAX = 16,\n};\n\nenum P4_EVENTS {\n\tP4_EVENT_TC_DELIVER_MODE = 0,\n\tP4_EVENT_BPU_FETCH_REQUEST = 1,\n\tP4_EVENT_ITLB_REFERENCE = 2,\n\tP4_EVENT_MEMORY_CANCEL = 3,\n\tP4_EVENT_MEMORY_COMPLETE = 4,\n\tP4_EVENT_LOAD_PORT_REPLAY = 5,\n\tP4_EVENT_STORE_PORT_REPLAY = 6,\n\tP4_EVENT_MOB_LOAD_REPLAY = 7,\n\tP4_EVENT_PAGE_WALK_TYPE = 8,\n\tP4_EVENT_BSQ_CACHE_REFERENCE = 9,\n\tP4_EVENT_IOQ_ALLOCATION = 10,\n\tP4_EVENT_IOQ_ACTIVE_ENTRIES = 11,\n\tP4_EVENT_FSB_DATA_ACTIVITY = 12,\n\tP4_EVENT_BSQ_ALLOCATION = 13,\n\tP4_EVENT_BSQ_ACTIVE_ENTRIES = 14,\n\tP4_EVENT_SSE_INPUT_ASSIST = 15,\n\tP4_EVENT_PACKED_SP_UOP = 16,\n\tP4_EVENT_PACKED_DP_UOP = 17,\n\tP4_EVENT_SCALAR_SP_UOP = 18,\n\tP4_EVENT_SCALAR_DP_UOP = 19,\n\tP4_EVENT_64BIT_MMX_UOP = 20,\n\tP4_EVENT_128BIT_MMX_UOP = 21,\n\tP4_EVENT_X87_FP_UOP = 22,\n\tP4_EVENT_TC_MISC = 23,\n\tP4_EVENT_GLOBAL_POWER_EVENTS = 24,\n\tP4_EVENT_TC_MS_XFER = 25,\n\tP4_EVENT_UOP_QUEUE_WRITES = 26,\n\tP4_EVENT_RETIRED_MISPRED_BRANCH_TYPE = 27,\n\tP4_EVENT_RETIRED_BRANCH_TYPE = 28,\n\tP4_EVENT_RESOURCE_STALL = 29,\n\tP4_EVENT_WC_BUFFER = 30,\n\tP4_EVENT_B2B_CYCLES = 31,\n\tP4_EVENT_BNR = 32,\n\tP4_EVENT_SNOOP = 33,\n\tP4_EVENT_RESPONSE = 34,\n\tP4_EVENT_FRONT_END_EVENT = 35,\n\tP4_EVENT_EXECUTION_EVENT = 36,\n\tP4_EVENT_REPLAY_EVENT = 37,\n\tP4_EVENT_INSTR_RETIRED = 38,\n\tP4_EVENT_UOPS_RETIRED = 39,\n\tP4_EVENT_UOP_TYPE = 40,\n\tP4_EVENT_BRANCH_RETIRED = 41,\n\tP4_EVENT_MISPRED_BRANCH_RETIRED = 42,\n\tP4_EVENT_X87_ASSIST = 43,\n\tP4_EVENT_MACHINE_CLEAR = 44,\n\tP4_EVENT_INSTR_COMPLETED = 45,\n};\n\nenum P4_EVENT_OPCODES {\n\tP4_EVENT_TC_DELIVER_MODE_OPCODE = 257,\n\tP4_EVENT_BPU_FETCH_REQUEST_OPCODE = 768,\n\tP4_EVENT_ITLB_REFERENCE_OPCODE = 6147,\n\tP4_EVENT_MEMORY_CANCEL_OPCODE = 517,\n\tP4_EVENT_MEMORY_COMPLETE_OPCODE = 2050,\n\tP4_EVENT_LOAD_PORT_REPLAY_OPCODE = 1026,\n\tP4_EVENT_STORE_PORT_REPLAY_OPCODE = 1282,\n\tP4_EVENT_MOB_LOAD_REPLAY_OPCODE = 770,\n\tP4_EVENT_PAGE_WALK_TYPE_OPCODE = 260,\n\tP4_EVENT_BSQ_CACHE_REFERENCE_OPCODE = 3079,\n\tP4_EVENT_IOQ_ALLOCATION_OPCODE = 774,\n\tP4_EVENT_IOQ_ACTIVE_ENTRIES_OPCODE = 6662,\n\tP4_EVENT_FSB_DATA_ACTIVITY_OPCODE = 5894,\n\tP4_EVENT_BSQ_ALLOCATION_OPCODE = 1287,\n\tP4_EVENT_BSQ_ACTIVE_ENTRIES_OPCODE = 1543,\n\tP4_EVENT_SSE_INPUT_ASSIST_OPCODE = 13313,\n\tP4_EVENT_PACKED_SP_UOP_OPCODE = 2049,\n\tP4_EVENT_PACKED_DP_UOP_OPCODE = 3073,\n\tP4_EVENT_SCALAR_SP_UOP_OPCODE = 2561,\n\tP4_EVENT_SCALAR_DP_UOP_OPCODE = 3585,\n\tP4_EVENT_64BIT_MMX_UOP_OPCODE = 513,\n\tP4_EVENT_128BIT_MMX_UOP_OPCODE = 6657,\n\tP4_EVENT_X87_FP_UOP_OPCODE = 1025,\n\tP4_EVENT_TC_MISC_OPCODE = 1537,\n\tP4_EVENT_GLOBAL_POWER_EVENTS_OPCODE = 4870,\n\tP4_EVENT_TC_MS_XFER_OPCODE = 1280,\n\tP4_EVENT_UOP_QUEUE_WRITES_OPCODE = 2304,\n\tP4_EVENT_RETIRED_MISPRED_BRANCH_TYPE_OPCODE = 1282,\n\tP4_EVENT_RETIRED_BRANCH_TYPE_OPCODE = 1026,\n\tP4_EVENT_RESOURCE_STALL_OPCODE = 257,\n\tP4_EVENT_WC_BUFFER_OPCODE = 1285,\n\tP4_EVENT_B2B_CYCLES_OPCODE = 5635,\n\tP4_EVENT_BNR_OPCODE = 2051,\n\tP4_EVENT_SNOOP_OPCODE = 1539,\n\tP4_EVENT_RESPONSE_OPCODE = 1027,\n\tP4_EVENT_FRONT_END_EVENT_OPCODE = 2053,\n\tP4_EVENT_EXECUTION_EVENT_OPCODE = 3077,\n\tP4_EVENT_REPLAY_EVENT_OPCODE = 2309,\n\tP4_EVENT_INSTR_RETIRED_OPCODE = 516,\n\tP4_EVENT_UOPS_RETIRED_OPCODE = 260,\n\tP4_EVENT_UOP_TYPE_OPCODE = 514,\n\tP4_EVENT_BRANCH_RETIRED_OPCODE = 1541,\n\tP4_EVENT_MISPRED_BRANCH_RETIRED_OPCODE = 772,\n\tP4_EVENT_X87_ASSIST_OPCODE = 773,\n\tP4_EVENT_MACHINE_CLEAR_OPCODE = 517,\n\tP4_EVENT_INSTR_COMPLETED_OPCODE = 1796,\n};\n\nenum P4_ESCR_EMASKS {\n\tP4_EVENT_TC_DELIVER_MODE__DD = 512,\n\tP4_EVENT_TC_DELIVER_MODE__DB = 1024,\n\tP4_EVENT_TC_DELIVER_MODE__DI = 2048,\n\tP4_EVENT_TC_DELIVER_MODE__BD = 4096,\n\tP4_EVENT_TC_DELIVER_MODE__BB = 8192,\n\tP4_EVENT_TC_DELIVER_MODE__BI = 16384,\n\tP4_EVENT_TC_DELIVER_MODE__ID = 32768,\n\tP4_EVENT_BPU_FETCH_REQUEST__TCMISS = 512,\n\tP4_EVENT_ITLB_REFERENCE__HIT = 512,\n\tP4_EVENT_ITLB_REFERENCE__MISS = 1024,\n\tP4_EVENT_ITLB_REFERENCE__HIT_UK = 2048,\n\tP4_EVENT_MEMORY_CANCEL__ST_RB_FULL = 2048,\n\tP4_EVENT_MEMORY_CANCEL__64K_CONF = 4096,\n\tP4_EVENT_MEMORY_COMPLETE__LSC = 512,\n\tP4_EVENT_MEMORY_COMPLETE__SSC = 1024,\n\tP4_EVENT_LOAD_PORT_REPLAY__SPLIT_LD = 1024,\n\tP4_EVENT_STORE_PORT_REPLAY__SPLIT_ST = 1024,\n\tP4_EVENT_MOB_LOAD_REPLAY__NO_STA = 1024,\n\tP4_EVENT_MOB_LOAD_REPLAY__NO_STD = 4096,\n\tP4_EVENT_MOB_LOAD_REPLAY__PARTIAL_DATA = 8192,\n\tP4_EVENT_MOB_LOAD_REPLAY__UNALGN_ADDR = 16384,\n\tP4_EVENT_PAGE_WALK_TYPE__DTMISS = 512,\n\tP4_EVENT_PAGE_WALK_TYPE__ITMISS = 1024,\n\tP4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_HITS = 512,\n\tP4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_HITE = 1024,\n\tP4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_HITM = 2048,\n\tP4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_HITS = 4096,\n\tP4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_HITE = 8192,\n\tP4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_HITM = 16384,\n\tP4_EVENT_BSQ_CACHE_REFERENCE__RD_2ndL_MISS = 131072,\n\tP4_EVENT_BSQ_CACHE_REFERENCE__RD_3rdL_MISS = 262144,\n\tP4_EVENT_BSQ_CACHE_REFERENCE__WR_2ndL_MISS = 524288,\n\tP4_EVENT_IOQ_ALLOCATION__DEFAULT = 512,\n\tP4_EVENT_IOQ_ALLOCATION__ALL_READ = 16384,\n\tP4_EVENT_IOQ_ALLOCATION__ALL_WRITE = 32768,\n\tP4_EVENT_IOQ_ALLOCATION__MEM_UC = 65536,\n\tP4_EVENT_IOQ_ALLOCATION__MEM_WC = 131072,\n\tP4_EVENT_IOQ_ALLOCATION__MEM_WT = 262144,\n\tP4_EVENT_IOQ_ALLOCATION__MEM_WP = 524288,\n\tP4_EVENT_IOQ_ALLOCATION__MEM_WB = 1048576,\n\tP4_EVENT_IOQ_ALLOCATION__OWN = 4194304,\n\tP4_EVENT_IOQ_ALLOCATION__OTHER = 8388608,\n\tP4_EVENT_IOQ_ALLOCATION__PREFETCH = 16777216,\n\tP4_EVENT_IOQ_ACTIVE_ENTRIES__DEFAULT = 512,\n\tP4_EVENT_IOQ_ACTIVE_ENTRIES__ALL_READ = 16384,\n\tP4_EVENT_IOQ_ACTIVE_ENTRIES__ALL_WRITE = 32768,\n\tP4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_UC = 65536,\n\tP4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WC = 131072,\n\tP4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WT = 262144,\n\tP4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WP = 524288,\n\tP4_EVENT_IOQ_ACTIVE_ENTRIES__MEM_WB = 1048576,\n\tP4_EVENT_IOQ_ACTIVE_ENTRIES__OWN = 4194304,\n\tP4_EVENT_IOQ_ACTIVE_ENTRIES__OTHER = 8388608,\n\tP4_EVENT_IOQ_ACTIVE_ENTRIES__PREFETCH = 16777216,\n\tP4_EVENT_FSB_DATA_ACTIVITY__DRDY_DRV = 512,\n\tP4_EVENT_FSB_DATA_ACTIVITY__DRDY_OWN = 1024,\n\tP4_EVENT_FSB_DATA_ACTIVITY__DRDY_OTHER = 2048,\n\tP4_EVENT_FSB_DATA_ACTIVITY__DBSY_DRV = 4096,\n\tP4_EVENT_FSB_DATA_ACTIVITY__DBSY_OWN = 8192,\n\tP4_EVENT_FSB_DATA_ACTIVITY__DBSY_OTHER = 16384,\n\tP4_EVENT_BSQ_ALLOCATION__REQ_TYPE0 = 512,\n\tP4_EVENT_BSQ_ALLOCATION__REQ_TYPE1 = 1024,\n\tP4_EVENT_BSQ_ALLOCATION__REQ_LEN0 = 2048,\n\tP4_EVENT_BSQ_ALLOCATION__REQ_LEN1 = 4096,\n\tP4_EVENT_BSQ_ALLOCATION__REQ_IO_TYPE = 16384,\n\tP4_EVENT_BSQ_ALLOCATION__REQ_LOCK_TYPE = 32768,\n\tP4_EVENT_BSQ_ALLOCATION__REQ_CACHE_TYPE = 65536,\n\tP4_EVENT_BSQ_ALLOCATION__REQ_SPLIT_TYPE = 131072,\n\tP4_EVENT_BSQ_ALLOCATION__REQ_DEM_TYPE = 262144,\n\tP4_EVENT_BSQ_ALLOCATION__REQ_ORD_TYPE = 524288,\n\tP4_EVENT_BSQ_ALLOCATION__MEM_TYPE0 = 1048576,\n\tP4_EVENT_BSQ_ALLOCATION__MEM_TYPE1 = 2097152,\n\tP4_EVENT_BSQ_ALLOCATION__MEM_TYPE2 = 4194304,\n\tP4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_TYPE0 = 512,\n\tP4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_TYPE1 = 1024,\n\tP4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_LEN0 = 2048,\n\tP4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_LEN1 = 4096,\n\tP4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_IO_TYPE = 16384,\n\tP4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_LOCK_TYPE = 32768,\n\tP4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_CACHE_TYPE = 65536,\n\tP4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_SPLIT_TYPE = 131072,\n\tP4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_DEM_TYPE = 262144,\n\tP4_EVENT_BSQ_ACTIVE_ENTRIES__REQ_ORD_TYPE = 524288,\n\tP4_EVENT_BSQ_ACTIVE_ENTRIES__MEM_TYPE0 = 1048576,\n\tP4_EVENT_BSQ_ACTIVE_ENTRIES__MEM_TYPE1 = 2097152,\n\tP4_EVENT_BSQ_ACTIVE_ENTRIES__MEM_TYPE2 = 4194304,\n\tP4_EVENT_SSE_INPUT_ASSIST__ALL = 16777216,\n\tP4_EVENT_PACKED_SP_UOP__ALL = 16777216,\n\tP4_EVENT_PACKED_DP_UOP__ALL = 16777216,\n\tP4_EVENT_SCALAR_SP_UOP__ALL = 16777216,\n\tP4_EVENT_SCALAR_DP_UOP__ALL = 16777216,\n\tP4_EVENT_64BIT_MMX_UOP__ALL = 16777216,\n\tP4_EVENT_128BIT_MMX_UOP__ALL = 16777216,\n\tP4_EVENT_X87_FP_UOP__ALL = 16777216,\n\tP4_EVENT_TC_MISC__FLUSH = 8192,\n\tP4_EVENT_GLOBAL_POWER_EVENTS__RUNNING = 512,\n\tP4_EVENT_TC_MS_XFER__CISC = 512,\n\tP4_EVENT_UOP_QUEUE_WRITES__FROM_TC_BUILD = 512,\n\tP4_EVENT_UOP_QUEUE_WRITES__FROM_TC_DELIVER = 1024,\n\tP4_EVENT_UOP_QUEUE_WRITES__FROM_ROM = 2048,\n\tP4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__CONDITIONAL = 1024,\n\tP4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__CALL = 2048,\n\tP4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__RETURN = 4096,\n\tP4_EVENT_RETIRED_MISPRED_BRANCH_TYPE__INDIRECT = 8192,\n\tP4_EVENT_RETIRED_BRANCH_TYPE__CONDITIONAL = 1024,\n\tP4_EVENT_RETIRED_BRANCH_TYPE__CALL = 2048,\n\tP4_EVENT_RETIRED_BRANCH_TYPE__RETURN = 4096,\n\tP4_EVENT_RETIRED_BRANCH_TYPE__INDIRECT = 8192,\n\tP4_EVENT_RESOURCE_STALL__SBFULL = 16384,\n\tP4_EVENT_WC_BUFFER__WCB_EVICTS = 512,\n\tP4_EVENT_WC_BUFFER__WCB_FULL_EVICTS = 1024,\n\tP4_EVENT_FRONT_END_EVENT__NBOGUS = 512,\n\tP4_EVENT_FRONT_END_EVENT__BOGUS = 1024,\n\tP4_EVENT_EXECUTION_EVENT__NBOGUS0 = 512,\n\tP4_EVENT_EXECUTION_EVENT__NBOGUS1 = 1024,\n\tP4_EVENT_EXECUTION_EVENT__NBOGUS2 = 2048,\n\tP4_EVENT_EXECUTION_EVENT__NBOGUS3 = 4096,\n\tP4_EVENT_EXECUTION_EVENT__BOGUS0 = 8192,\n\tP4_EVENT_EXECUTION_EVENT__BOGUS1 = 16384,\n\tP4_EVENT_EXECUTION_EVENT__BOGUS2 = 32768,\n\tP4_EVENT_EXECUTION_EVENT__BOGUS3 = 65536,\n\tP4_EVENT_REPLAY_EVENT__NBOGUS = 512,\n\tP4_EVENT_REPLAY_EVENT__BOGUS = 1024,\n\tP4_EVENT_INSTR_RETIRED__NBOGUSNTAG = 512,\n\tP4_EVENT_INSTR_RETIRED__NBOGUSTAG = 1024,\n\tP4_EVENT_INSTR_RETIRED__BOGUSNTAG = 2048,\n\tP4_EVENT_INSTR_RETIRED__BOGUSTAG = 4096,\n\tP4_EVENT_UOPS_RETIRED__NBOGUS = 512,\n\tP4_EVENT_UOPS_RETIRED__BOGUS = 1024,\n\tP4_EVENT_UOP_TYPE__TAGLOADS = 1024,\n\tP4_EVENT_UOP_TYPE__TAGSTORES = 2048,\n\tP4_EVENT_BRANCH_RETIRED__MMNP = 512,\n\tP4_EVENT_BRANCH_RETIRED__MMNM = 1024,\n\tP4_EVENT_BRANCH_RETIRED__MMTP = 2048,\n\tP4_EVENT_BRANCH_RETIRED__MMTM = 4096,\n\tP4_EVENT_MISPRED_BRANCH_RETIRED__NBOGUS = 512,\n\tP4_EVENT_X87_ASSIST__FPSU = 512,\n\tP4_EVENT_X87_ASSIST__FPSO = 1024,\n\tP4_EVENT_X87_ASSIST__POAO = 2048,\n\tP4_EVENT_X87_ASSIST__POAU = 4096,\n\tP4_EVENT_X87_ASSIST__PREA = 8192,\n\tP4_EVENT_MACHINE_CLEAR__CLEAR = 512,\n\tP4_EVENT_MACHINE_CLEAR__MOCLEAR = 1024,\n\tP4_EVENT_MACHINE_CLEAR__SMCLEAR = 2048,\n\tP4_EVENT_INSTR_COMPLETED__NBOGUS = 512,\n\tP4_EVENT_INSTR_COMPLETED__BOGUS = 1024,\n};\n\nenum P4_PEBS_METRIC {\n\tP4_PEBS_METRIC__none = 0,\n\tP4_PEBS_METRIC__1stl_cache_load_miss_retired = 1,\n\tP4_PEBS_METRIC__2ndl_cache_load_miss_retired = 2,\n\tP4_PEBS_METRIC__dtlb_load_miss_retired = 3,\n\tP4_PEBS_METRIC__dtlb_store_miss_retired = 4,\n\tP4_PEBS_METRIC__dtlb_all_miss_retired = 5,\n\tP4_PEBS_METRIC__tagged_mispred_branch = 6,\n\tP4_PEBS_METRIC__mob_load_replay_retired = 7,\n\tP4_PEBS_METRIC__split_load_retired = 8,\n\tP4_PEBS_METRIC__split_store_retired = 9,\n\tP4_PEBS_METRIC__max = 10,\n};\n\nstruct p4_event_bind {\n\tunsigned int opcode;\n\tunsigned int escr_msr[2];\n\tunsigned int escr_emask;\n\tunsigned int shared;\n\tchar cntr[6];\n};\n\nstruct p4_pebs_bind {\n\tunsigned int metric_pebs;\n\tunsigned int metric_vert;\n};\n\nstruct p4_event_alias {\n\tu64 original;\n\tu64 alternative;\n};\n\nenum cpuid_regs_idx {\n\tCPUID_EAX = 0,\n\tCPUID_EBX = 1,\n\tCPUID_ECX = 2,\n\tCPUID_EDX = 3,\n};\n\nstruct dev_ext_attribute {\n\tstruct device_attribute attr;\n\tvoid *var;\n};\n\nenum pt_capabilities {\n\tPT_CAP_max_subleaf = 0,\n\tPT_CAP_cr3_filtering = 1,\n\tPT_CAP_psb_cyc = 2,\n\tPT_CAP_ip_filtering = 3,\n\tPT_CAP_mtc = 4,\n\tPT_CAP_ptwrite = 5,\n\tPT_CAP_power_event_trace = 6,\n\tPT_CAP_topa_output = 7,\n\tPT_CAP_topa_multiple_entries = 8,\n\tPT_CAP_single_range_output = 9,\n\tPT_CAP_output_subsys = 10,\n\tPT_CAP_payloads_lip = 11,\n\tPT_CAP_num_address_ranges = 12,\n\tPT_CAP_mtc_periods = 13,\n\tPT_CAP_cycle_thresholds = 14,\n\tPT_CAP_psb_periods = 15,\n};\n\nenum perf_addr_filter_action_t {\n\tPERF_ADDR_FILTER_ACTION_STOP = 0,\n\tPERF_ADDR_FILTER_ACTION_START = 1,\n\tPERF_ADDR_FILTER_ACTION_FILTER = 2,\n};\n\nstruct perf_addr_filter {\n\tstruct list_head entry;\n\tstruct path path;\n\tlong unsigned int offset;\n\tlong unsigned int size;\n\tenum perf_addr_filter_action_t action;\n};\n\nstruct topa_entry {\n\tu64 end: 1;\n\tu64 rsvd0: 1;\n\tu64 intr: 1;\n\tu64 rsvd1: 1;\n\tu64 stop: 1;\n\tu64 rsvd2: 1;\n\tu64 size: 4;\n\tu64 rsvd3: 2;\n\tu64 base: 36;\n\tu64 rsvd4: 16;\n};\n\nstruct pt_pmu {\n\tstruct pmu pmu;\n\tu32 caps[8];\n\tbool vmx;\n\tbool branch_en_always_on;\n\tlong unsigned int max_nonturbo_ratio;\n\tunsigned int tsc_art_num;\n\tunsigned int tsc_art_den;\n};\n\nstruct topa;\n\nstruct pt_buffer {\n\tstruct list_head tables;\n\tstruct topa *first;\n\tstruct topa *last;\n\tstruct topa *cur;\n\tunsigned int cur_idx;\n\tsize_t output_off;\n\tlong unsigned int nr_pages;\n\tlocal_t data_size;\n\tlocal64_t head;\n\tbool snapshot;\n\tbool single;\n\tlong int stop_pos;\n\tlong int intr_pos;\n\tstruct topa_entry *stop_te;\n\tstruct topa_entry *intr_te;\n\tvoid **data_pages;\n};\n\nstruct topa {\n\tstruct list_head list;\n\tu64 offset;\n\tsize_t size;\n\tint last;\n\tunsigned int z_count;\n};\n\nstruct pt_filter {\n\tlong unsigned int msr_a;\n\tlong unsigned int msr_b;\n\tlong unsigned int config;\n};\n\nstruct pt_filters {\n\tstruct pt_filter filter[4];\n\tunsigned int nr_filters;\n};\n\nstruct pt {\n\tstruct perf_output_handle handle;\n\tstruct pt_filters filters;\n\tint handle_nmi;\n\tint vmx_on;\n\tu64 output_base;\n\tu64 output_mask;\n};\n\nstruct pt_cap_desc {\n\tconst char *name;\n\tu32 leaf;\n\tu8 reg;\n\tu32 mask;\n};\n\nstruct pt_address_range {\n\tlong unsigned int msr_a;\n\tlong unsigned int msr_b;\n\tunsigned int reg_off;\n};\n\nstruct topa_page {\n\tstruct topa_entry table[507];\n\tstruct topa topa;\n};\n\ntypedef void (*exitcall_t)();\n\nstruct x86_cpu_id {\n\t__u16 vendor;\n\t__u16 family;\n\t__u16 model;\n\t__u16 steppings;\n\t__u16 feature;\n\tkernel_ulong_t driver_data;\n};\n\nenum hrtimer_mode {\n\tHRTIMER_MODE_ABS = 0,\n\tHRTIMER_MODE_REL = 1,\n\tHRTIMER_MODE_PINNED = 2,\n\tHRTIMER_MODE_SOFT = 4,\n\tHRTIMER_MODE_HARD = 8,\n\tHRTIMER_MODE_ABS_PINNED = 2,\n\tHRTIMER_MODE_REL_PINNED = 3,\n\tHRTIMER_MODE_ABS_SOFT = 4,\n\tHRTIMER_MODE_REL_SOFT = 5,\n\tHRTIMER_MODE_ABS_PINNED_SOFT = 6,\n\tHRTIMER_MODE_REL_PINNED_SOFT = 7,\n\tHRTIMER_MODE_ABS_HARD = 8,\n\tHRTIMER_MODE_REL_HARD = 9,\n\tHRTIMER_MODE_ABS_PINNED_HARD = 10,\n\tHRTIMER_MODE_REL_PINNED_HARD = 11,\n};\n\nstruct acpi_device;\n\nstruct pci_sysdata {\n\tint domain;\n\tint node;\n\tstruct acpi_device *companion;\n\tvoid *iommu;\n\tvoid *fwnode;\n\tstruct pci_dev *vmd_dev;\n};\n\nstruct pci_extra_dev {\n\tstruct pci_dev *dev[4];\n};\n\nstruct intel_uncore_pmu;\n\nstruct intel_uncore_ops;\n\nstruct uncore_event_desc;\n\nstruct freerunning_counters;\n\nstruct intel_uncore_topology;\n\nstruct intel_uncore_type {\n\tconst char *name;\n\tint num_counters;\n\tint num_boxes;\n\tint perf_ctr_bits;\n\tint fixed_ctr_bits;\n\tint num_freerunning_types;\n\tint type_id;\n\tunsigned int perf_ctr;\n\tunsigned int event_ctl;\n\tunsigned int event_mask;\n\tunsigned int event_mask_ext;\n\tunsigned int fixed_ctr;\n\tunsigned int fixed_ctl;\n\tunsigned int box_ctl;\n\tu64 *box_ctls;\n\tunion {\n\t\tunsigned int msr_offset;\n\t\tunsigned int mmio_offset;\n\t};\n\tunsigned int mmio_map_size;\n\tunsigned int num_shared_regs: 8;\n\tunsigned int single_fixed: 1;\n\tunsigned int pair_ctr_ctl: 1;\n\tunion {\n\t\tunsigned int *msr_offsets;\n\t\tunsigned int *pci_offsets;\n\t\tunsigned int *mmio_offsets;\n\t};\n\tunsigned int *box_ids;\n\tstruct event_constraint unconstrainted;\n\tstruct event_constraint *constraints;\n\tstruct intel_uncore_pmu *pmus;\n\tstruct intel_uncore_ops *ops;\n\tstruct uncore_event_desc *event_descs;\n\tstruct freerunning_counters *freerunning;\n\tconst struct attribute_group *attr_groups[4];\n\tconst struct attribute_group **attr_update;\n\tstruct pmu *pmu;\n\tstruct intel_uncore_topology *topology;\n\tint (*get_topology)(struct intel_uncore_type *);\n\tint (*set_mapping)(struct intel_uncore_type *);\n\tvoid (*cleanup_mapping)(struct intel_uncore_type *);\n};\n\nstruct intel_uncore_box;\n\nstruct intel_uncore_pmu {\n\tstruct pmu pmu;\n\tchar name[32];\n\tint pmu_idx;\n\tint func_id;\n\tbool registered;\n\tatomic_t activeboxes;\n\tstruct intel_uncore_type *type;\n\tstruct intel_uncore_box **boxes;\n};\n\nstruct intel_uncore_ops {\n\tvoid (*init_box)(struct intel_uncore_box *);\n\tvoid (*exit_box)(struct intel_uncore_box *);\n\tvoid (*disable_box)(struct intel_uncore_box *);\n\tvoid (*enable_box)(struct intel_uncore_box *);\n\tvoid (*disable_event)(struct intel_uncore_box *, struct perf_event *);\n\tvoid (*enable_event)(struct intel_uncore_box *, struct perf_event *);\n\tu64 (*read_counter)(struct intel_uncore_box *, struct perf_event *);\n\tint (*hw_config)(struct intel_uncore_box *, struct perf_event *);\n\tstruct event_constraint * (*get_constraint)(struct intel_uncore_box *, struct perf_event *);\n\tvoid (*put_constraint)(struct intel_uncore_box *, struct perf_event *);\n};\n\nstruct uncore_event_desc {\n\tstruct device_attribute attr;\n\tconst char *config;\n};\n\nstruct freerunning_counters {\n\tunsigned int counter_base;\n\tunsigned int counter_offset;\n\tunsigned int box_offset;\n\tunsigned int num_counters;\n\tunsigned int bits;\n\tunsigned int *box_offsets;\n};\n\nstruct intel_uncore_topology {\n\tu64 configuration;\n\tint segment;\n};\n\nstruct intel_uncore_extra_reg {\n\traw_spinlock_t lock;\n\tu64 config;\n\tu64 config1;\n\tu64 config2;\n\tatomic_t ref;\n};\n\nstruct intel_uncore_box {\n\tint dieid;\n\tint n_active;\n\tint n_events;\n\tint cpu;\n\tlong unsigned int flags;\n\tatomic_t refcnt;\n\tstruct perf_event *events[10];\n\tstruct perf_event *event_list[10];\n\tstruct event_constraint *event_constraint[10];\n\tlong unsigned int active_mask[1];\n\tu64 tags[10];\n\tstruct pci_dev *pci_dev;\n\tstruct intel_uncore_pmu *pmu;\n\tu64 hrtimer_duration;\n\tstruct hrtimer hrtimer;\n\tstruct list_head list;\n\tstruct list_head active_list;\n\tvoid *io_addr;\n\tstruct intel_uncore_extra_reg shared_regs[0];\n};\n\nstruct pci2phy_map {\n\tstruct list_head list;\n\tint segment;\n\tint pbus_to_dieid[256];\n};\n\nstruct intel_uncore_init_fun {\n\tvoid (*cpu_init)();\n\tint (*pci_init)();\n\tvoid (*mmio_init)();\n\tbool use_discovery;\n};\n\nenum {\n\tEXTRA_REG_NHMEX_M_FILTER = 0,\n\tEXTRA_REG_NHMEX_M_DSP = 1,\n\tEXTRA_REG_NHMEX_M_ISS = 2,\n\tEXTRA_REG_NHMEX_M_MAP = 3,\n\tEXTRA_REG_NHMEX_M_MSC_THR = 4,\n\tEXTRA_REG_NHMEX_M_PGT = 5,\n\tEXTRA_REG_NHMEX_M_PLD = 6,\n\tEXTRA_REG_NHMEX_M_ZDP_CTL_FVC = 7,\n};\n\nenum {\n\tSNB_PCI_UNCORE_IMC = 0,\n};\n\nenum perf_snb_uncore_imc_freerunning_types {\n\tSNB_PCI_UNCORE_IMC_DATA_READS = 0,\n\tSNB_PCI_UNCORE_IMC_DATA_WRITES = 1,\n\tSNB_PCI_UNCORE_IMC_GT_REQUESTS = 2,\n\tSNB_PCI_UNCORE_IMC_IA_REQUESTS = 3,\n\tSNB_PCI_UNCORE_IMC_IO_REQUESTS = 4,\n\tSNB_PCI_UNCORE_IMC_FREERUNNING_TYPE_MAX = 5,\n};\n\nstruct imc_uncore_pci_dev {\n\t__u32 pci_id;\n\tstruct pci_driver *driver;\n};\n\nenum perf_tgl_uncore_imc_freerunning_types {\n\tTGL_MMIO_UNCORE_IMC_DATA_TOTAL = 0,\n\tTGL_MMIO_UNCORE_IMC_DATA_READ = 1,\n\tTGL_MMIO_UNCORE_IMC_DATA_WRITE = 2,\n\tTGL_MMIO_UNCORE_IMC_FREERUNNING_TYPE_MAX = 3,\n};\n\nenum uncore_access_type {\n\tUNCORE_ACCESS_MSR = 0,\n\tUNCORE_ACCESS_MMIO = 1,\n\tUNCORE_ACCESS_PCI = 2,\n\tUNCORE_ACCESS_MAX = 3,\n};\n\nenum {\n\tSNBEP_PCI_QPI_PORT0_FILTER = 0,\n\tSNBEP_PCI_QPI_PORT1_FILTER = 1,\n\tBDX_PCI_QPI_PORT2_FILTER = 2,\n};\n\nenum {\n\tSNBEP_PCI_UNCORE_HA = 0,\n\tSNBEP_PCI_UNCORE_IMC = 1,\n\tSNBEP_PCI_UNCORE_QPI = 2,\n\tSNBEP_PCI_UNCORE_R2PCIE = 3,\n\tSNBEP_PCI_UNCORE_R3QPI = 4,\n};\n\nenum {\n\tIVBEP_PCI_UNCORE_HA = 0,\n\tIVBEP_PCI_UNCORE_IMC = 1,\n\tIVBEP_PCI_UNCORE_IRP = 2,\n\tIVBEP_PCI_UNCORE_QPI = 3,\n\tIVBEP_PCI_UNCORE_R2PCIE = 4,\n\tIVBEP_PCI_UNCORE_R3QPI = 5,\n};\n\nenum {\n\tKNL_PCI_UNCORE_MC_UCLK = 0,\n\tKNL_PCI_UNCORE_MC_DCLK = 1,\n\tKNL_PCI_UNCORE_EDC_UCLK = 2,\n\tKNL_PCI_UNCORE_EDC_ECLK = 3,\n\tKNL_PCI_UNCORE_M2PCIE = 4,\n\tKNL_PCI_UNCORE_IRP = 5,\n};\n\nenum {\n\tHSWEP_PCI_UNCORE_HA = 0,\n\tHSWEP_PCI_UNCORE_IMC = 1,\n\tHSWEP_PCI_UNCORE_IRP = 2,\n\tHSWEP_PCI_UNCORE_QPI = 3,\n\tHSWEP_PCI_UNCORE_R2PCIE = 4,\n\tHSWEP_PCI_UNCORE_R3QPI = 5,\n};\n\nenum {\n\tBDX_PCI_UNCORE_HA = 0,\n\tBDX_PCI_UNCORE_IMC = 1,\n\tBDX_PCI_UNCORE_IRP = 2,\n\tBDX_PCI_UNCORE_QPI = 3,\n\tBDX_PCI_UNCORE_R2PCIE = 4,\n\tBDX_PCI_UNCORE_R3QPI = 5,\n};\n\nenum perf_uncore_iio_freerunning_type_id {\n\tSKX_IIO_MSR_IOCLK = 0,\n\tSKX_IIO_MSR_BW = 1,\n\tSKX_IIO_MSR_UTIL = 2,\n\tSKX_IIO_FREERUNNING_TYPE_MAX = 3,\n};\n\nenum {\n\tSKX_PCI_UNCORE_IMC = 0,\n\tSKX_PCI_UNCORE_M2M = 1,\n\tSKX_PCI_UNCORE_UPI = 2,\n\tSKX_PCI_UNCORE_M2PCIE = 3,\n\tSKX_PCI_UNCORE_M3UPI = 4,\n};\n\nenum {\n\tSNR_QAT_PMON_ID = 0,\n\tSNR_CBDMA_DMI_PMON_ID = 1,\n\tSNR_NIS_PMON_ID = 2,\n\tSNR_DLB_PMON_ID = 3,\n\tSNR_PCIE_GEN3_PMON_ID = 4,\n};\n\nenum perf_uncore_snr_iio_freerunning_type_id {\n\tSNR_IIO_MSR_IOCLK = 0,\n\tSNR_IIO_MSR_BW_IN = 1,\n\tSNR_IIO_FREERUNNING_TYPE_MAX = 2,\n};\n\nenum {\n\tSNR_PCI_UNCORE_M2M = 0,\n\tSNR_PCI_UNCORE_PCIE3 = 1,\n};\n\nenum perf_uncore_snr_imc_freerunning_type_id {\n\tSNR_IMC_DCLK = 0,\n\tSNR_IMC_DDR = 1,\n\tSNR_IMC_FREERUNNING_TYPE_MAX = 2,\n};\n\nenum {\n\tICX_PCIE1_PMON_ID = 0,\n\tICX_PCIE2_PMON_ID = 1,\n\tICX_PCIE3_PMON_ID = 2,\n\tICX_PCIE4_PMON_ID = 3,\n\tICX_PCIE5_PMON_ID = 4,\n\tICX_CBDMA_DMI_PMON_ID = 5,\n};\n\nenum perf_uncore_icx_iio_freerunning_type_id {\n\tICX_IIO_MSR_IOCLK = 0,\n\tICX_IIO_MSR_BW_IN = 1,\n\tICX_IIO_FREERUNNING_TYPE_MAX = 2,\n};\n\nenum {\n\tICX_PCI_UNCORE_M2M = 0,\n\tICX_PCI_UNCORE_UPI = 1,\n\tICX_PCI_UNCORE_M3UPI = 2,\n};\n\nenum perf_uncore_icx_imc_freerunning_type_id {\n\tICX_IMC_DCLK = 0,\n\tICX_IMC_DDR = 1,\n\tICX_IMC_DDRT = 2,\n\tICX_IMC_FREERUNNING_TYPE_MAX = 3,\n};\n\nenum perf_uncore_spr_iio_freerunning_type_id {\n\tSPR_IIO_MSR_IOCLK = 0,\n\tSPR_IIO_MSR_BW_IN = 1,\n\tSPR_IIO_MSR_BW_OUT = 2,\n\tSPR_IIO_FREERUNNING_TYPE_MAX = 3,\n};\n\nenum perf_uncore_spr_imc_freerunning_type_id {\n\tSPR_IMC_DCLK = 0,\n\tSPR_IMC_PQ_CYCLES = 1,\n\tSPR_IMC_FREERUNNING_TYPE_MAX = 2,\n};\n\nstruct uncore_global_discovery {\n\tunion {\n\t\tu64 table1;\n\t\tstruct {\n\t\t\tu64 type: 8;\n\t\t\tu64 stride: 8;\n\t\t\tu64 max_units: 10;\n\t\t\tu64 __reserved_1: 36;\n\t\t\tu64 access_type: 2;\n\t\t};\n\t};\n\tu64 ctl;\n\tunion {\n\t\tu64 table3;\n\t\tstruct {\n\t\t\tu64 status_offset: 8;\n\t\t\tu64 num_status: 16;\n\t\t\tu64 __reserved_2: 40;\n\t\t};\n\t};\n};\n\nstruct uncore_unit_discovery {\n\tunion {\n\t\tu64 table1;\n\t\tstruct {\n\t\t\tu64 num_regs: 8;\n\t\t\tu64 ctl_offset: 8;\n\t\t\tu64 bit_width: 8;\n\t\t\tu64 ctr_offset: 8;\n\t\t\tu64 status_offset: 8;\n\t\t\tu64 __reserved_1: 22;\n\t\t\tu64 access_type: 2;\n\t\t};\n\t};\n\tu64 ctl;\n\tunion {\n\t\tu64 table3;\n\t\tstruct {\n\t\t\tu64 box_type: 16;\n\t\t\tu64 box_id: 16;\n\t\t\tu64 __reserved_2: 32;\n\t\t};\n\t};\n};\n\nstruct intel_uncore_discovery_type {\n\tstruct rb_node node;\n\tenum uncore_access_type access_type;\n\tu64 box_ctrl;\n\tu64 *box_ctrl_die;\n\tu16 type;\n\tu8 num_counters;\n\tu8 counter_width;\n\tu8 ctl_offset;\n\tu8 ctr_offset;\n\tu16 num_boxes;\n\tunsigned int *ids;\n\tunsigned int *box_offset;\n};\n\ntypedef s8 int8_t;\n\ntypedef u8 uint8_t;\n\ntypedef u64 uint64_t;\n\nstruct atomic_notifier_head {\n\tspinlock_t lock;\n\tstruct notifier_block *head;\n};\n\nenum xen_domain_type {\n\tXEN_NATIVE = 0,\n\tXEN_PV_DOMAIN = 1,\n\tXEN_HVM_DOMAIN = 2,\n};\n\ntypedef long unsigned int xen_pfn_t;\n\ntypedef long unsigned int xen_ulong_t;\n\nstruct arch_shared_info {\n\tlong unsigned int max_pfn;\n\txen_pfn_t pfn_to_mfn_frame_list_list;\n\tlong unsigned int nmi_reason;\n\tlong unsigned int p2m_cr3;\n\tlong unsigned int p2m_vaddr;\n\tlong unsigned int p2m_generation;\n};\n\nstruct arch_vcpu_info {\n\tlong unsigned int cr2;\n\tlong unsigned int pad;\n};\n\nstruct pvclock_wall_clock {\n\tu32 version;\n\tu32 sec;\n\tu32 nsec;\n};\n\nstruct vcpu_info {\n\tuint8_t evtchn_upcall_pending;\n\tuint8_t evtchn_upcall_mask;\n\txen_ulong_t evtchn_pending_sel;\n\tstruct arch_vcpu_info arch;\n\tstruct pvclock_vcpu_time_info time;\n};\n\nstruct shared_info {\n\tstruct vcpu_info vcpu_info[32];\n\txen_ulong_t evtchn_pending[64];\n\txen_ulong_t evtchn_mask[64];\n\tstruct pvclock_wall_clock wc;\n\tuint32_t wc_sec_hi;\n\tstruct arch_shared_info arch;\n};\n\nstruct start_info {\n\tchar magic[32];\n\tlong unsigned int nr_pages;\n\tlong unsigned int shared_info;\n\tuint32_t flags;\n\txen_pfn_t store_mfn;\n\tuint32_t store_evtchn;\n\tunion {\n\t\tstruct {\n\t\t\txen_pfn_t mfn;\n\t\t\tuint32_t evtchn;\n\t\t} domU;\n\t\tstruct {\n\t\t\tuint32_t info_off;\n\t\t\tuint32_t info_size;\n\t\t} dom0;\n\t} console;\n\tlong unsigned int pt_base;\n\tlong unsigned int nr_pt_frames;\n\tlong unsigned int mfn_list;\n\tlong unsigned int mod_start;\n\tlong unsigned int mod_len;\n\tint8_t cmd_line[1024];\n\tlong unsigned int first_p2m_pfn;\n\tlong unsigned int nr_p2m_frames;\n};\n\nstruct sched_shutdown {\n\tunsigned int reason;\n};\n\nstruct sched_pin_override {\n\tint32_t pcpu;\n};\n\nstruct xen_extraversion {\n\tchar extraversion[16];\n};\n\nstruct vcpu_register_vcpu_info {\n\tuint64_t mfn;\n\tuint32_t offset;\n\tuint32_t rsvd;\n};\n\nstruct xmaddr {\n\tphys_addr_t maddr;\n};\n\ntypedef struct xmaddr xmaddr_t;\n\nstruct xpaddr {\n\tphys_addr_t paddr;\n};\n\ntypedef struct xpaddr xpaddr_t;\n\ntypedef s16 int16_t;\n\ntypedef u16 uint16_t;\n\nenum clocksource_ids {\n\tCSID_GENERIC = 0,\n\tCSID_ARM_ARCH_COUNTER = 1,\n\tCSID_MAX = 2,\n};\n\nstruct clocksource {\n\tu64 (*read)(struct clocksource *);\n\tu64 mask;\n\tu32 mult;\n\tu32 shift;\n\tu64 max_idle_ns;\n\tu32 maxadj;\n\tu32 uncertainty_margin;\n\tu64 max_cycles;\n\tconst char *name;\n\tstruct list_head list;\n\tint rating;\n\tenum clocksource_ids id;\n\tenum vdso_clock_mode vdso_clock_mode;\n\tlong unsigned int flags;\n\tint (*enable)(struct clocksource *);\n\tvoid (*disable)(struct clocksource *);\n\tvoid (*suspend)(struct clocksource *);\n\tvoid (*resume)(struct clocksource *);\n\tvoid (*mark_unstable)(struct clocksource *);\n\tvoid (*tick_stable)(struct clocksource *);\n\tstruct list_head wd_list;\n\tu64 cs_last;\n\tu64 wd_last;\n\tstruct module *owner;\n};\n\nstruct x86_init_mpparse {\n\tvoid (*setup_ioapic_ids)();\n\tvoid (*find_smp_config)();\n\tvoid (*get_smp_config)(unsigned int);\n};\n\nstruct x86_init_resources {\n\tvoid (*probe_roms)();\n\tvoid (*reserve_resources)();\n\tchar * (*memory_setup)();\n};\n\nstruct x86_init_irqs {\n\tvoid (*pre_vector_init)();\n\tvoid (*intr_init)();\n\tvoid (*intr_mode_select)();\n\tvoid (*intr_mode_init)();\n\tstruct irq_domain * (*create_pci_msi_domain)();\n};\n\nstruct x86_init_oem {\n\tvoid (*arch_setup)();\n\tvoid (*banner)();\n};\n\nstruct x86_init_paging {\n\tvoid (*pagetable_init)();\n};\n\nstruct x86_init_timers {\n\tvoid (*setup_percpu_clockev)();\n\tvoid (*timer_init)();\n\tvoid (*wallclock_init)();\n};\n\nstruct x86_init_iommu {\n\tint (*iommu_init)();\n};\n\nstruct x86_init_pci {\n\tint (*arch_init)();\n\tint (*init)();\n\tvoid (*init_irq)();\n\tvoid (*fixup_irqs)();\n};\n\nstruct x86_hyper_init {\n\tvoid (*init_platform)();\n\tvoid (*guest_late_init)();\n\tbool (*x2apic_available)();\n\tbool (*msi_ext_dest_id)();\n\tvoid (*init_mem_mapping)();\n\tvoid (*init_after_bootmem)();\n};\n\nstruct x86_init_acpi {\n\tvoid (*set_root_pointer)(u64);\n\tu64 (*get_root_pointer)();\n\tvoid (*reduced_hw_early_init)();\n};\n\nstruct x86_init_ops {\n\tstruct x86_init_resources resources;\n\tstruct x86_init_mpparse mpparse;\n\tstruct x86_init_irqs irqs;\n\tstruct x86_init_oem oem;\n\tstruct x86_init_paging paging;\n\tstruct x86_init_timers timers;\n\tstruct x86_init_iommu iommu;\n\tstruct x86_init_pci pci;\n\tstruct x86_hyper_init hyper;\n\tstruct x86_init_acpi acpi;\n};\n\nstruct x86_cpuinit_ops {\n\tvoid (*setup_percpu_clockev)();\n\tvoid (*early_percpu_clock_init)();\n\tvoid (*fixup_cpu_id)(struct cpuinfo_x86 *, int);\n};\n\nenum clock_event_state {\n\tCLOCK_EVT_STATE_DETACHED = 0,\n\tCLOCK_EVT_STATE_SHUTDOWN = 1,\n\tCLOCK_EVT_STATE_PERIODIC = 2,\n\tCLOCK_EVT_STATE_ONESHOT = 3,\n\tCLOCK_EVT_STATE_ONESHOT_STOPPED = 4,\n};\n\nstruct clock_event_device {\n\tvoid (*event_handler)(struct clock_event_device *);\n\tint (*set_next_event)(long unsigned int, struct clock_event_device *);\n\tint (*set_next_ktime)(ktime_t, struct clock_event_device *);\n\tktime_t next_event;\n\tu64 max_delta_ns;\n\tu64 min_delta_ns;\n\tu32 mult;\n\tu32 shift;\n\tenum clock_event_state state_use_accessors;\n\tunsigned int features;\n\tlong unsigned int retries;\n\tint (*set_state_periodic)(struct clock_event_device *);\n\tint (*set_state_oneshot)(struct clock_event_device *);\n\tint (*set_state_oneshot_stopped)(struct clock_event_device *);\n\tint (*set_state_shutdown)(struct clock_event_device *);\n\tint (*tick_resume)(struct clock_event_device *);\n\tvoid (*broadcast)(const struct cpumask *);\n\tvoid (*suspend)(struct clock_event_device *);\n\tvoid (*resume)(struct clock_event_device *);\n\tlong unsigned int min_delta_ticks;\n\tlong unsigned int max_delta_ticks;\n\tconst char *name;\n\tint rating;\n\tint irq;\n\tint bound_on;\n\tconst struct cpumask *cpumask;\n\tstruct list_head list;\n\tstruct module *owner;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct tk_read_base {\n\tstruct clocksource *clock;\n\tu64 mask;\n\tu64 cycle_last;\n\tu32 mult;\n\tu32 shift;\n\tu64 xtime_nsec;\n\tktime_t base;\n\tu64 base_real;\n};\n\nstruct timekeeper {\n\tstruct tk_read_base tkr_mono;\n\tstruct tk_read_base tkr_raw;\n\tu64 xtime_sec;\n\tlong unsigned int ktime_sec;\n\tstruct timespec64 wall_to_monotonic;\n\tktime_t offs_real;\n\tktime_t offs_boot;\n\tktime_t offs_tai;\n\ts32 tai_offset;\n\tunsigned int clock_was_set_seq;\n\tu8 cs_was_changed_seq;\n\tktime_t next_leap_ktime;\n\tu64 raw_sec;\n\tstruct timespec64 monotonic_to_boot;\n\tu64 cycle_interval;\n\tu64 xtime_interval;\n\ts64 xtime_remainder;\n\tu64 raw_interval;\n\tu64 ntp_tick;\n\ts64 ntp_error;\n\tu32 ntp_error_shift;\n\tu32 ntp_err_mult;\n\tu32 skip_second_overflow;\n};\n\ntypedef unsigned char *__guest_handle_uchar;\n\ntypedef char *__guest_handle_char;\n\ntypedef void *__guest_handle_void;\n\ntypedef uint64_t *__guest_handle_uint64_t;\n\ntypedef uint32_t *__guest_handle_uint32_t;\n\nstruct vcpu_time_info {\n\tuint32_t version;\n\tuint32_t pad0;\n\tuint64_t tsc_timestamp;\n\tuint64_t system_time;\n\tuint32_t tsc_to_system_mul;\n\tint8_t tsc_shift;\n\tint8_t pad1[3];\n};\n\nstruct xenpf_settime32 {\n\tuint32_t secs;\n\tuint32_t nsecs;\n\tuint64_t system_time;\n};\n\nstruct xenpf_settime64 {\n\tuint64_t secs;\n\tuint32_t nsecs;\n\tuint32_t mbz;\n\tuint64_t system_time;\n};\n\nstruct xenpf_add_memtype {\n\txen_pfn_t mfn;\n\tuint64_t nr_mfns;\n\tuint32_t type;\n\tuint32_t handle;\n\tuint32_t reg;\n};\n\nstruct xenpf_del_memtype {\n\tuint32_t handle;\n\tuint32_t reg;\n};\n\nstruct xenpf_read_memtype {\n\tuint32_t reg;\n\txen_pfn_t mfn;\n\tuint64_t nr_mfns;\n\tuint32_t type;\n};\n\nstruct xenpf_microcode_update {\n\t__guest_handle_void data;\n\tuint32_t length;\n};\n\nstruct xenpf_platform_quirk {\n\tuint32_t quirk_id;\n};\n\nstruct xenpf_efi_time {\n\tuint16_t year;\n\tuint8_t month;\n\tuint8_t day;\n\tuint8_t hour;\n\tuint8_t min;\n\tuint8_t sec;\n\tuint32_t ns;\n\tint16_t tz;\n\tuint8_t daylight;\n};\n\nstruct xenpf_efi_guid {\n\tuint32_t data1;\n\tuint16_t data2;\n\tuint16_t data3;\n\tuint8_t data4[8];\n};\n\nstruct xenpf_efi_runtime_call {\n\tuint32_t function;\n\tuint32_t misc;\n\txen_ulong_t status;\n\tunion {\n\t\tstruct {\n\t\t\tstruct xenpf_efi_time time;\n\t\t\tuint32_t resolution;\n\t\t\tuint32_t accuracy;\n\t\t} get_time;\n\t\tstruct xenpf_efi_time set_time;\n\t\tstruct xenpf_efi_time get_wakeup_time;\n\t\tstruct xenpf_efi_time set_wakeup_time;\n\t\tstruct {\n\t\t\t__guest_handle_void name;\n\t\t\txen_ulong_t size;\n\t\t\t__guest_handle_void data;\n\t\t\tstruct xenpf_efi_guid vendor_guid;\n\t\t} get_variable;\n\t\tstruct {\n\t\t\t__guest_handle_void name;\n\t\t\txen_ulong_t size;\n\t\t\t__guest_handle_void data;\n\t\t\tstruct xenpf_efi_guid vendor_guid;\n\t\t} set_variable;\n\t\tstruct {\n\t\t\txen_ulong_t size;\n\t\t\t__guest_handle_void name;\n\t\t\tstruct xenpf_efi_guid vendor_guid;\n\t\t} get_next_variable_name;\n\t\tstruct {\n\t\t\tuint32_t attr;\n\t\t\tuint64_t max_store_size;\n\t\t\tuint64_t remain_store_size;\n\t\t\tuint64_t max_size;\n\t\t} query_variable_info;\n\t\tstruct {\n\t\t\t__guest_handle_void capsule_header_array;\n\t\t\txen_ulong_t capsule_count;\n\t\t\tuint64_t max_capsule_size;\n\t\t\tuint32_t reset_type;\n\t\t} query_capsule_capabilities;\n\t\tstruct {\n\t\t\t__guest_handle_void capsule_header_array;\n\t\t\txen_ulong_t capsule_count;\n\t\t\tuint64_t sg_list;\n\t\t} update_capsule;\n\t} u;\n};\n\nunion xenpf_efi_info {\n\tuint32_t version;\n\tstruct {\n\t\tuint64_t addr;\n\t\tuint32_t nent;\n\t} cfg;\n\tstruct {\n\t\tuint32_t revision;\n\t\tuint32_t bufsz;\n\t\t__guest_handle_void name;\n\t} vendor;\n\tstruct {\n\t\tuint64_t addr;\n\t\tuint64_t size;\n\t\tuint64_t attr;\n\t\tuint32_t type;\n\t} mem;\n};\n\nstruct xenpf_firmware_info {\n\tuint32_t type;\n\tuint32_t index;\n\tunion {\n\t\tstruct {\n\t\t\tuint8_t device;\n\t\t\tuint8_t version;\n\t\t\tuint16_t interface_support;\n\t\t\tuint16_t legacy_max_cylinder;\n\t\t\tuint8_t legacy_max_head;\n\t\t\tuint8_t legacy_sectors_per_track;\n\t\t\t__guest_handle_void edd_params;\n\t\t} disk_info;\n\t\tstruct {\n\t\t\tuint8_t device;\n\t\t\tuint32_t mbr_signature;\n\t\t} disk_mbr_signature;\n\t\tstruct {\n\t\t\tuint8_t capabilities;\n\t\t\tuint8_t edid_transfer_time;\n\t\t\t__guest_handle_uchar edid;\n\t\t} vbeddc_info;\n\t\tunion xenpf_efi_info efi_info;\n\t\tuint8_t kbd_shift_flags;\n\t} u;\n};\n\nstruct xenpf_enter_acpi_sleep {\n\tuint16_t val_a;\n\tuint16_t val_b;\n\tuint32_t sleep_state;\n\tuint32_t flags;\n};\n\nstruct xenpf_change_freq {\n\tuint32_t flags;\n\tuint32_t cpu;\n\tuint64_t freq;\n};\n\nstruct xenpf_getidletime {\n\t__guest_handle_uchar cpumap_bitmap;\n\tuint32_t cpumap_nr_cpus;\n\t__guest_handle_uint64_t idletime;\n\tuint64_t now;\n};\n\nstruct xen_power_register {\n\tuint32_t space_id;\n\tuint32_t bit_width;\n\tuint32_t bit_offset;\n\tuint32_t access_size;\n\tuint64_t address;\n};\n\nstruct xen_processor_csd {\n\tuint32_t domain;\n\tuint32_t coord_type;\n\tuint32_t num;\n};\n\ntypedef struct xen_processor_csd *__guest_handle_xen_processor_csd;\n\nstruct xen_processor_cx {\n\tstruct xen_power_register reg;\n\tuint8_t type;\n\tuint32_t latency;\n\tuint32_t power;\n\tuint32_t dpcnt;\n\t__guest_handle_xen_processor_csd dp;\n};\n\ntypedef struct xen_processor_cx *__guest_handle_xen_processor_cx;\n\nstruct xen_processor_flags {\n\tuint32_t bm_control: 1;\n\tuint32_t bm_check: 1;\n\tuint32_t has_cst: 1;\n\tuint32_t power_setup_done: 1;\n\tuint32_t bm_rld_set: 1;\n};\n\nstruct xen_processor_power {\n\tuint32_t count;\n\tstruct xen_processor_flags flags;\n\t__guest_handle_xen_processor_cx states;\n};\n\nstruct xen_pct_register {\n\tuint8_t descriptor;\n\tuint16_t length;\n\tuint8_t space_id;\n\tuint8_t bit_width;\n\tuint8_t bit_offset;\n\tuint8_t reserved;\n\tuint64_t address;\n};\n\nstruct xen_processor_px {\n\tuint64_t core_frequency;\n\tuint64_t power;\n\tuint64_t transition_latency;\n\tuint64_t bus_master_latency;\n\tuint64_t control;\n\tuint64_t status;\n};\n\ntypedef struct xen_processor_px *__guest_handle_xen_processor_px;\n\nstruct xen_psd_package {\n\tuint64_t num_entries;\n\tuint64_t revision;\n\tuint64_t domain;\n\tuint64_t coord_type;\n\tuint64_t num_processors;\n};\n\nstruct xen_processor_performance {\n\tuint32_t flags;\n\tuint32_t platform_limit;\n\tstruct xen_pct_register control_register;\n\tstruct xen_pct_register status_register;\n\tuint32_t state_count;\n\t__guest_handle_xen_processor_px states;\n\tstruct xen_psd_package domain_info;\n\tuint32_t shared_type;\n};\n\nstruct xenpf_set_processor_pminfo {\n\tuint32_t id;\n\tuint32_t type;\n\tunion {\n\t\tstruct xen_processor_power power;\n\t\tstruct xen_processor_performance perf;\n\t\t__guest_handle_uint32_t pdc;\n\t};\n};\n\nstruct xenpf_pcpuinfo {\n\tuint32_t xen_cpuid;\n\tuint32_t max_present;\n\tuint32_t flags;\n\tuint32_t apic_id;\n\tuint32_t acpi_id;\n};\n\nstruct xenpf_cpu_ol {\n\tuint32_t cpuid;\n};\n\nstruct xenpf_cpu_hotadd {\n\tuint32_t apic_id;\n\tuint32_t acpi_id;\n\tuint32_t pxm;\n};\n\nstruct xenpf_mem_hotadd {\n\tuint64_t spfn;\n\tuint64_t epfn;\n\tuint32_t pxm;\n\tuint32_t flags;\n};\n\nstruct xenpf_core_parking {\n\tuint32_t type;\n\tuint32_t idle_nums;\n};\n\nstruct xenpf_symdata {\n\tuint32_t namelen;\n\tuint32_t symnum;\n\t__guest_handle_char name;\n\tuint64_t address;\n\tchar type;\n};\n\nstruct xen_platform_op {\n\tuint32_t cmd;\n\tuint32_t interface_version;\n\tunion {\n\t\tstruct xenpf_settime32 settime32;\n\t\tstruct xenpf_settime64 settime64;\n\t\tstruct xenpf_add_memtype add_memtype;\n\t\tstruct xenpf_del_memtype del_memtype;\n\t\tstruct xenpf_read_memtype read_memtype;\n\t\tstruct xenpf_microcode_update microcode;\n\t\tstruct xenpf_platform_quirk platform_quirk;\n\t\tstruct xenpf_efi_runtime_call efi_runtime_call;\n\t\tstruct xenpf_firmware_info firmware_info;\n\t\tstruct xenpf_enter_acpi_sleep enter_acpi_sleep;\n\t\tstruct xenpf_change_freq change_freq;\n\t\tstruct xenpf_getidletime getidletime;\n\t\tstruct xenpf_set_processor_pminfo set_pminfo;\n\t\tstruct xenpf_pcpuinfo pcpu_info;\n\t\tstruct xenpf_cpu_ol cpu_ol;\n\t\tstruct xenpf_cpu_hotadd cpu_add;\n\t\tstruct xenpf_mem_hotadd mem_add;\n\t\tstruct xenpf_core_parking core_parking;\n\t\tstruct xenpf_symdata symdata;\n\t\tuint8_t pad[128];\n\t} u;\n};\n\nstruct vcpu_set_singleshot_timer {\n\tuint64_t timeout_abs_ns;\n\tuint32_t flags;\n};\n\ntypedef struct vcpu_time_info *__guest_handle_vcpu_time_info;\n\nstruct vcpu_register_time_memory_area {\n\tunion {\n\t\t__guest_handle_vcpu_time_info h;\n\t\tstruct pvclock_vcpu_time_info *v;\n\t\tuint64_t p;\n\t} addr;\n};\n\nstruct xen_clock_event_device {\n\tstruct clock_event_device evt;\n\tchar name[16];\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\ntypedef int (*pte_fn_t)(pte_t *, long unsigned int, void *);\n\ntypedef uint16_t grant_status_t;\n\nstruct grant_frames {\n\txen_pfn_t *pfn;\n\tunsigned int count;\n\tvoid *vaddr;\n};\n\nstruct gnttab_vm_area {\n\tstruct vm_struct *area;\n\tpte_t **ptes;\n\tint idx;\n};\n\nenum acpi_irq_model_id {\n\tACPI_IRQ_MODEL_PIC = 0,\n\tACPI_IRQ_MODEL_IOAPIC = 1,\n\tACPI_IRQ_MODEL_IOSAPIC = 2,\n\tACPI_IRQ_MODEL_PLATFORM = 3,\n\tACPI_IRQ_MODEL_GIC = 4,\n\tACPI_IRQ_MODEL_COUNT = 5,\n};\n\ntypedef uint16_t domid_t;\n\nstruct xen_add_to_physmap {\n\tdomid_t domid;\n\tuint16_t size;\n\tunsigned int space;\n\txen_ulong_t idx;\n\txen_pfn_t gpfn;\n};\n\nstruct machine_ops {\n\tvoid (*restart)(char *);\n\tvoid (*halt)();\n\tvoid (*power_off)();\n\tvoid (*shutdown)();\n\tvoid (*crash_shutdown)(struct pt_regs *);\n\tvoid (*emergency_restart)();\n};\n\nenum x86_hypervisor_type {\n\tX86_HYPER_NATIVE = 0,\n\tX86_HYPER_VMWARE = 1,\n\tX86_HYPER_MS_HYPERV = 2,\n\tX86_HYPER_XEN_PV = 3,\n\tX86_HYPER_XEN_HVM = 4,\n\tX86_HYPER_KVM = 5,\n\tX86_HYPER_JAILHOUSE = 6,\n\tX86_HYPER_ACRN = 7,\n};\n\nstruct hypervisor_x86 {\n\tconst char *name;\n\tuint32_t (*detect)();\n\tenum x86_hypervisor_type type;\n\tstruct x86_hyper_init init;\n\tstruct x86_hyper_runtime runtime;\n\tbool ignore_nopv;\n};\n\nenum e820_type {\n\tE820_TYPE_RAM = 1,\n\tE820_TYPE_RESERVED = 2,\n\tE820_TYPE_ACPI = 3,\n\tE820_TYPE_NVS = 4,\n\tE820_TYPE_UNUSABLE = 5,\n\tE820_TYPE_PMEM = 7,\n\tE820_TYPE_PRAM = 12,\n\tE820_TYPE_SOFT_RESERVED = 4026531839,\n\tE820_TYPE_RESERVED_KERN = 128,\n};\n\nstruct xen_hvm_pagetable_dying {\n\tdomid_t domid;\n\t__u64 gpa;\n};\n\nenum hvmmem_type_t {\n\tHVMMEM_ram_rw = 0,\n\tHVMMEM_ram_ro = 1,\n\tHVMMEM_mmio_dm = 2,\n};\n\nstruct xen_hvm_get_mem_type {\n\tdomid_t domid;\n\tuint16_t mem_type;\n\tuint16_t pad[2];\n\tuint64_t pfn;\n};\n\nstruct e820_entry {\n\tu64 addr;\n\tu64 size;\n\tenum e820_type type;\n} __attribute__((packed));\n\nstruct e820_table {\n\t__u32 nr_entries;\n\tstruct e820_entry entries[3200];\n} __attribute__((packed));\n\ntypedef xen_pfn_t *__guest_handle_xen_pfn_t;\n\ntypedef long unsigned int xen_callback_t;\n\nstruct mmu_update {\n\tuint64_t ptr;\n\tuint64_t val;\n};\n\nstruct xen_memory_region {\n\tlong unsigned int start_pfn;\n\tlong unsigned int n_pfns;\n};\n\nstruct callback_register {\n\tuint16_t type;\n\tuint16_t flags;\n\txen_callback_t address;\n};\n\nstruct xen_memory_reservation {\n\t__guest_handle_xen_pfn_t extent_start;\n\txen_ulong_t nr_extents;\n\tunsigned int extent_order;\n\tunsigned int address_bits;\n\tdomid_t domid;\n};\n\nstruct xen_memory_map {\n\tunsigned int nr_entries;\n\t__guest_handle_void buffer;\n};\n\nstruct x86_apic_ops {\n\tunsigned int (*io_apic_read)(unsigned int, unsigned int);\n\tvoid (*restore)();\n};\n\nstruct physdev_apic {\n\tlong unsigned int apic_physbase;\n\tuint32_t reg;\n\tuint32_t value;\n};\n\n//typedef long unsigned int uintptr_t;\n\nstruct xen_pmu_amd_ctxt {\n\tuint32_t counters;\n\tuint32_t ctrls;\n\tuint64_t regs[0];\n};\n\nstruct xen_pmu_cntr_pair {\n\tuint64_t counter;\n\tuint64_t control;\n};\n\nstruct xen_pmu_intel_ctxt {\n\tuint32_t fixed_counters;\n\tuint32_t arch_counters;\n\tuint64_t global_ctrl;\n\tuint64_t global_ovf_ctrl;\n\tuint64_t global_status;\n\tuint64_t fixed_ctrl;\n\tuint64_t ds_area;\n\tuint64_t pebs_enable;\n\tuint64_t debugctl;\n\tuint64_t regs[0];\n};\n\nstruct xen_pmu_regs {\n\tuint64_t ip;\n\tuint64_t sp;\n\tuint64_t flags;\n\tuint16_t cs;\n\tuint16_t ss;\n\tuint8_t cpl;\n\tuint8_t pad[3];\n};\n\nstruct xen_pmu_arch {\n\tunion {\n\t\tstruct xen_pmu_regs regs;\n\t\tuint8_t pad[64];\n\t} r;\n\tuint64_t pmu_flags;\n\tunion {\n\t\tuint32_t lapic_lvtpc;\n\t\tuint64_t pad;\n\t} l;\n\tunion {\n\t\tstruct xen_pmu_amd_ctxt amd;\n\t\tstruct xen_pmu_intel_ctxt intel;\n\t\tuint8_t pad[128];\n\t} c;\n};\n\nstruct xen_pmu_params {\n\tstruct {\n\t\tuint32_t maj;\n\t\tuint32_t min;\n\t} version;\n\tuint64_t val;\n\tuint32_t vcpu;\n\tuint32_t pad;\n};\n\nstruct xen_pmu_data {\n\tuint32_t vcpu_id;\n\tuint32_t pcpu_id;\n\tdomid_t domain_id;\n\tuint8_t pad[6];\n\tstruct xen_pmu_arch pmu;\n};\n\nstruct xenpmu {\n\tstruct xen_pmu_data *xenpmu_data;\n\tuint8_t flags;\n};\n\nenum pg_level {\n\tPG_LEVEL_NONE = 0,\n\tPG_LEVEL_4K = 1,\n\tPG_LEVEL_2M = 2,\n\tPG_LEVEL_1G = 3,\n\tPG_LEVEL_512G = 4,\n\tPG_LEVEL_NUM = 5,\n};\n\ntypedef uint32_t grant_ref_t;\n\ntypedef uint32_t grant_handle_t;\n\nstruct gnttab_map_grant_ref {\n\tuint64_t host_addr;\n\tuint32_t flags;\n\tgrant_ref_t ref;\n\tdomid_t dom;\n\tint16_t status;\n\tgrant_handle_t handle;\n\tuint64_t dev_bus_addr;\n};\n\nstruct gnttab_unmap_grant_ref {\n\tuint64_t host_addr;\n\tuint64_t dev_bus_addr;\n\tgrant_handle_t handle;\n\tint16_t status;\n};\n\nenum {\n\tDESC_TSS = 9,\n\tDESC_LDT = 2,\n\tDESCTYPE_S = 16,\n};\n\nenum paravirt_lazy_mode {\n\tPARAVIRT_LAZY_NONE = 0,\n\tPARAVIRT_LAZY_MMU = 1,\n\tPARAVIRT_LAZY_CPU = 2,\n};\n\nstruct plist_head {\n\tstruct list_head node_list;\n};\n\nenum pm_qos_type {\n\tPM_QOS_UNITIALIZED = 0,\n\tPM_QOS_MAX = 1,\n\tPM_QOS_MIN = 2,\n};\n\nstruct pm_qos_constraints {\n\tstruct plist_head list;\n\ts32 target_value;\n\ts32 default_value;\n\ts32 no_constraint_value;\n\tenum pm_qos_type type;\n\tstruct blocking_notifier_head *notifiers;\n};\n\nstruct freq_constraints {\n\tstruct pm_qos_constraints min_freq;\n\tstruct blocking_notifier_head min_freq_notifiers;\n\tstruct pm_qos_constraints max_freq;\n\tstruct blocking_notifier_head max_freq_notifiers;\n};\n\nstruct pm_qos_flags {\n\tstruct list_head list;\n\ts32 effective_flags;\n};\n\nstruct dev_pm_qos_request;\n\nstruct dev_pm_qos {\n\tstruct pm_qos_constraints resume_latency;\n\tstruct pm_qos_constraints latency_tolerance;\n\tstruct freq_constraints freq;\n\tstruct pm_qos_flags flags;\n\tstruct dev_pm_qos_request *resume_latency_req;\n\tstruct dev_pm_qos_request *latency_tolerance_req;\n\tstruct dev_pm_qos_request *flags_req;\n};\n\ntypedef long int xen_long_t;\n\nstruct trap_info {\n\tuint8_t vector;\n\tuint8_t flags;\n\tuint16_t cs;\n\tlong unsigned int address;\n};\n\nstruct mmuext_op {\n\tunsigned int cmd;\n\tunion {\n\t\txen_pfn_t mfn;\n\t\tlong unsigned int linear_addr;\n\t} arg1;\n\tunion {\n\t\tunsigned int nr_ents;\n\t\tvoid *vcpumask;\n\t\txen_pfn_t src_mfn;\n\t} arg2;\n};\n\nstruct multicall_entry {\n\txen_ulong_t op;\n\txen_long_t result;\n\txen_ulong_t args[6];\n};\n\nstruct dom0_vga_console_info {\n\tuint8_t video_type;\n\tunion {\n\t\tstruct {\n\t\t\tuint16_t font_height;\n\t\t\tuint16_t cursor_x;\n\t\t\tuint16_t cursor_y;\n\t\t\tuint16_t rows;\n\t\t\tuint16_t columns;\n\t\t} text_mode_3;\n\t\tstruct {\n\t\t\tuint16_t width;\n\t\t\tuint16_t height;\n\t\t\tuint16_t bytes_per_line;\n\t\t\tuint16_t bits_per_pixel;\n\t\t\tuint32_t lfb_base;\n\t\t\tuint32_t lfb_size;\n\t\t\tuint8_t red_pos;\n\t\t\tuint8_t red_size;\n\t\t\tuint8_t green_pos;\n\t\t\tuint8_t green_size;\n\t\t\tuint8_t blue_pos;\n\t\t\tuint8_t blue_size;\n\t\t\tuint8_t rsvd_pos;\n\t\t\tuint8_t rsvd_size;\n\t\t\tuint32_t gbl_caps;\n\t\t\tuint16_t mode_attrs;\n\t\t} vesa_lfb;\n\t} u;\n};\n\nstruct physdev_set_iopl {\n\tuint32_t iopl;\n};\n\nstruct physdev_set_iobitmap {\n\tuint8_t *bitmap;\n\tuint32_t nr_ports;\n};\n\ntypedef u32 acpi_status;\n\nstruct pm_qos_flags_request {\n\tstruct list_head node;\n\ts32 flags;\n};\n\nenum freq_qos_req_type {\n\tFREQ_QOS_MIN = 1,\n\tFREQ_QOS_MAX = 2,\n};\n\nstruct freq_qos_request {\n\tenum freq_qos_req_type type;\n\tstruct plist_node pnode;\n\tstruct freq_constraints *qos;\n};\n\nenum dev_pm_qos_req_type {\n\tDEV_PM_QOS_RESUME_LATENCY = 1,\n\tDEV_PM_QOS_LATENCY_TOLERANCE = 2,\n\tDEV_PM_QOS_MIN_FREQUENCY = 3,\n\tDEV_PM_QOS_MAX_FREQUENCY = 4,\n\tDEV_PM_QOS_FLAGS = 5,\n};\n\nstruct dev_pm_qos_request {\n\tenum dev_pm_qos_req_type type;\n\tunion {\n\t\tstruct plist_node pnode;\n\t\tstruct pm_qos_flags_request flr;\n\t\tstruct freq_qos_request freq;\n\t} data;\n\tstruct device *dev;\n};\n\nstruct multicall_space {\n\tstruct multicall_entry *mc;\n\tvoid *args;\n};\n\nstruct tls_descs {\n\tstruct desc_struct desc[3];\n};\n\nstruct trap_array_entry {\n\tvoid (*orig)();\n\tvoid (*xen)();\n\tbool ist_okay;\n};\n\nstruct mmu_gather_batch {\n\tstruct mmu_gather_batch *next;\n\tunsigned int nr;\n\tunsigned int max;\n\tstruct page *pages[0];\n};\n\nstruct mmu_table_batch;\n\nstruct mmu_gather {\n\tstruct mm_struct *mm;\n\tstruct mmu_table_batch *batch;\n\tlong unsigned int start;\n\tlong unsigned int end;\n\tunsigned int fullmm: 1;\n\tunsigned int need_flush_all: 1;\n\tunsigned int freed_tables: 1;\n\tunsigned int cleared_ptes: 1;\n\tunsigned int cleared_pmds: 1;\n\tunsigned int cleared_puds: 1;\n\tunsigned int cleared_p4ds: 1;\n\tunsigned int vma_exec: 1;\n\tunsigned int vma_huge: 1;\n\tunsigned int batch_count;\n\tstruct mmu_gather_batch *active;\n\tstruct mmu_gather_batch local;\n\tstruct page *__pages[8];\n};\n\nstruct mmu_table_batch {\n\tstruct callback_head rcu;\n\tunsigned int nr;\n\tvoid *tables[0];\n};\n\nstruct xen_memory_exchange {\n\tstruct xen_memory_reservation in;\n\tstruct xen_memory_reservation out;\n\txen_ulong_t nr_exchanged;\n};\n\nstruct xen_machphys_mapping {\n\txen_ulong_t v_start;\n\txen_ulong_t v_end;\n\txen_ulong_t max_mfn;\n};\n\nenum pt_level {\n\tPT_PGD = 0,\n\tPT_P4D = 1,\n\tPT_PUD = 2,\n\tPT_PMD = 3,\n\tPT_PTE = 4,\n};\n\nstruct remap_data {\n\txen_pfn_t *pfn;\n\tbool contiguous;\n\tbool no_translate;\n\tpgprot_t prot;\n\tstruct mmu_update *mmu_update;\n};\n\nenum xen_mc_flush_reason {\n\tXEN_MC_FL_NONE = 0,\n\tXEN_MC_FL_BATCH = 1,\n\tXEN_MC_FL_ARGS = 2,\n\tXEN_MC_FL_CALLBACK = 3,\n};\n\nenum xen_mc_extend_args {\n\tXEN_MC_XE_OK = 0,\n\tXEN_MC_XE_BAD_OP = 1,\n\tXEN_MC_XE_NO_SPACE = 2,\n};\n\ntypedef void (*xen_mc_callback_fn_t)(void *);\n\nstruct callback {\n\tvoid (*fn)(void *);\n\tvoid *data;\n};\n\nstruct mc_buffer {\n\tunsigned int mcidx;\n\tunsigned int argidx;\n\tunsigned int cbidx;\n\tstruct multicall_entry entries[32];\n\tunsigned char args[512];\n\tstruct callback callbacks[32];\n};\n\nstruct hvm_start_info {\n\tuint32_t magic;\n\tuint32_t version;\n\tuint32_t flags;\n\tuint32_t nr_modules;\n\tuint64_t modlist_paddr;\n\tuint64_t cmdline_paddr;\n\tuint64_t rsdp_paddr;\n\tuint64_t memmap_paddr;\n\tuint32_t memmap_entries;\n\tuint32_t reserved;\n};\n\nstruct trace_event_raw_xen_mc__batch {\n\tstruct trace_entry ent;\n\tenum paravirt_lazy_mode mode;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mc_entry {\n\tstruct trace_entry ent;\n\tunsigned int op;\n\tunsigned int nargs;\n\tlong unsigned int args[6];\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mc_entry_alloc {\n\tstruct trace_entry ent;\n\tsize_t args;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mc_callback {\n\tstruct trace_entry ent;\n\txen_mc_callback_fn_t fn;\n\tvoid *data;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mc_flush_reason {\n\tstruct trace_entry ent;\n\tenum xen_mc_flush_reason reason;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mc_flush {\n\tstruct trace_entry ent;\n\tunsigned int mcidx;\n\tunsigned int argidx;\n\tunsigned int cbidx;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mc_extend_args {\n\tstruct trace_entry ent;\n\tunsigned int op;\n\tsize_t args;\n\tenum xen_mc_extend_args res;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mmu__set_pte {\n\tstruct trace_entry ent;\n\tpte_t *ptep;\n\tpteval_t pteval;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mmu_set_pmd {\n\tstruct trace_entry ent;\n\tpmd_t *pmdp;\n\tpmdval_t pmdval;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mmu_set_pud {\n\tstruct trace_entry ent;\n\tpud_t *pudp;\n\tpudval_t pudval;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mmu_set_p4d {\n\tstruct trace_entry ent;\n\tp4d_t *p4dp;\n\tp4d_t *user_p4dp;\n\tp4dval_t p4dval;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mmu_ptep_modify_prot {\n\tstruct trace_entry ent;\n\tstruct mm_struct *mm;\n\tlong unsigned int addr;\n\tpte_t *ptep;\n\tpteval_t pteval;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mmu_alloc_ptpage {\n\tstruct trace_entry ent;\n\tstruct mm_struct *mm;\n\tlong unsigned int pfn;\n\tunsigned int level;\n\tbool pinned;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mmu_release_ptpage {\n\tstruct trace_entry ent;\n\tlong unsigned int pfn;\n\tunsigned int level;\n\tbool pinned;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mmu_pgd {\n\tstruct trace_entry ent;\n\tstruct mm_struct *mm;\n\tpgd_t *pgd;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mmu_flush_tlb_one_user {\n\tstruct trace_entry ent;\n\tlong unsigned int addr;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mmu_flush_tlb_multi {\n\tstruct trace_entry ent;\n\tunsigned int ncpus;\n\tstruct mm_struct *mm;\n\tlong unsigned int addr;\n\tlong unsigned int end;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_mmu_write_cr3 {\n\tstruct trace_entry ent;\n\tbool kernel;\n\tlong unsigned int cr3;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_cpu_write_ldt_entry {\n\tstruct trace_entry ent;\n\tstruct desc_struct *dt;\n\tint entrynum;\n\tu64 desc;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_cpu_write_idt_entry {\n\tstruct trace_entry ent;\n\tgate_desc *dt;\n\tint entrynum;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_cpu_load_idt {\n\tstruct trace_entry ent;\n\tlong unsigned int addr;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_cpu_write_gdt_entry {\n\tstruct trace_entry ent;\n\tu64 desc;\n\tstruct desc_struct *dt;\n\tint entrynum;\n\tint type;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_xen_cpu_set_ldt {\n\tstruct trace_entry ent;\n\tconst void *addr;\n\tunsigned int entries;\n\tchar __data[0];\n};\n\nstruct trace_event_data_offsets_xen_mc__batch {};\n\nstruct trace_event_data_offsets_xen_mc_entry {};\n\nstruct trace_event_data_offsets_xen_mc_entry_alloc {};\n\nstruct trace_event_data_offsets_xen_mc_callback {};\n\nstruct trace_event_data_offsets_xen_mc_flush_reason {};\n\nstruct trace_event_data_offsets_xen_mc_flush {};\n\nstruct trace_event_data_offsets_xen_mc_extend_args {};\n\nstruct trace_event_data_offsets_xen_mmu__set_pte {};\n\nstruct trace_event_data_offsets_xen_mmu_set_pmd {};\n\nstruct trace_event_data_offsets_xen_mmu_set_pud {};\n\nstruct trace_event_data_offsets_xen_mmu_set_p4d {};\n\nstruct trace_event_data_offsets_xen_mmu_ptep_modify_prot {};\n\nstruct trace_event_data_offsets_xen_mmu_alloc_ptpage {};\n\nstruct trace_event_data_offsets_xen_mmu_release_ptpage {};\n\nstruct trace_event_data_offsets_xen_mmu_pgd {};\n\nstruct trace_event_data_offsets_xen_mmu_flush_tlb_one_user {};\n\nstruct trace_event_data_offsets_xen_mmu_flush_tlb_multi {};\n\nstruct trace_event_data_offsets_xen_mmu_write_cr3 {};\n\nstruct trace_event_data_offsets_xen_cpu_write_ldt_entry {};\n\nstruct trace_event_data_offsets_xen_cpu_write_idt_entry {};\n\nstruct trace_event_data_offsets_xen_cpu_load_idt {};\n\nstruct trace_event_data_offsets_xen_cpu_write_gdt_entry {};\n\nstruct trace_event_data_offsets_xen_cpu_set_ldt {};\n\ntypedef void (*btf_trace_xen_mc_batch)(void *, enum paravirt_lazy_mode);\n\ntypedef void (*btf_trace_xen_mc_issue)(void *, enum paravirt_lazy_mode);\n\ntypedef void (*btf_trace_xen_mc_entry)(void *, struct multicall_entry *, unsigned int);\n\ntypedef void (*btf_trace_xen_mc_entry_alloc)(void *, size_t);\n\ntypedef void (*btf_trace_xen_mc_callback)(void *, xen_mc_callback_fn_t, void *);\n\ntypedef void (*btf_trace_xen_mc_flush_reason)(void *, enum xen_mc_flush_reason);\n\ntypedef void (*btf_trace_xen_mc_flush)(void *, unsigned int, unsigned int, unsigned int);\n\ntypedef void (*btf_trace_xen_mc_extend_args)(void *, long unsigned int, size_t, enum xen_mc_extend_args);\n\ntypedef void (*btf_trace_xen_mmu_set_pte)(void *, pte_t *, pte_t);\n\ntypedef void (*btf_trace_xen_mmu_set_pmd)(void *, pmd_t *, pmd_t);\n\ntypedef void (*btf_trace_xen_mmu_set_pud)(void *, pud_t *, pud_t);\n\ntypedef void (*btf_trace_xen_mmu_set_p4d)(void *, p4d_t *, p4d_t *, p4d_t);\n\ntypedef void (*btf_trace_xen_mmu_ptep_modify_prot_start)(void *, struct mm_struct *, long unsigned int, pte_t *, pte_t);\n\ntypedef void (*btf_trace_xen_mmu_ptep_modify_prot_commit)(void *, struct mm_struct *, long unsigned int, pte_t *, pte_t);\n\ntypedef void (*btf_trace_xen_mmu_alloc_ptpage)(void *, struct mm_struct *, long unsigned int, unsigned int, bool);\n\ntypedef void (*btf_trace_xen_mmu_release_ptpage)(void *, long unsigned int, unsigned int, bool);\n\ntypedef void (*btf_trace_xen_mmu_pgd_pin)(void *, struct mm_struct *, pgd_t *);\n\ntypedef void (*btf_trace_xen_mmu_pgd_unpin)(void *, struct mm_struct *, pgd_t *);\n\ntypedef void (*btf_trace_xen_mmu_flush_tlb_one_user)(void *, long unsigned int);\n\ntypedef void (*btf_trace_xen_mmu_flush_tlb_multi)(void *, const struct cpumask *, struct mm_struct *, long unsigned int, long unsigned int);\n\ntypedef void (*btf_trace_xen_mmu_write_cr3)(void *, bool, long unsigned int);\n\ntypedef void (*btf_trace_xen_cpu_write_ldt_entry)(void *, struct desc_struct *, int, u64);\n\ntypedef void (*btf_trace_xen_cpu_write_idt_entry)(void *, gate_desc *, int, const gate_desc *);\n\ntypedef void (*btf_trace_xen_cpu_load_idt)(void *, const struct desc_ptr *);\n\ntypedef void (*btf_trace_xen_cpu_write_gdt_entry)(void *, struct desc_struct *, int, const void *, int);\n\ntypedef void (*btf_trace_xen_cpu_set_ldt)(void *, const void *, unsigned int);\n\nenum ipi_vector {\n\tXEN_RESCHEDULE_VECTOR = 0,\n\tXEN_CALL_FUNCTION_VECTOR = 1,\n\tXEN_CALL_FUNCTION_SINGLE_VECTOR = 2,\n\tXEN_SPIN_UNLOCK_VECTOR = 3,\n\tXEN_IRQ_WORK_VECTOR = 4,\n\tXEN_NMI_VECTOR = 5,\n\tXEN_NR_IPIS = 6,\n};\n\nstruct xen_common_irq {\n\tint irq;\n\tchar *name;\n};\n\nstruct cpu_user_regs {\n\tuint64_t r15;\n\tuint64_t r14;\n\tuint64_t r13;\n\tuint64_t r12;\n\tunion {\n\t\tuint64_t rbp;\n\t\tuint64_t ebp;\n\t\tuint32_t _ebp;\n\t};\n\tunion {\n\t\tuint64_t rbx;\n\t\tuint64_t ebx;\n\t\tuint32_t _ebx;\n\t};\n\tuint64_t r11;\n\tuint64_t r10;\n\tuint64_t r9;\n\tuint64_t r8;\n\tunion {\n\t\tuint64_t rax;\n\t\tuint64_t eax;\n\t\tuint32_t _eax;\n\t};\n\tunion {\n\t\tuint64_t rcx;\n\t\tuint64_t ecx;\n\t\tuint32_t _ecx;\n\t};\n\tunion {\n\t\tuint64_t rdx;\n\t\tuint64_t edx;\n\t\tuint32_t _edx;\n\t};\n\tunion {\n\t\tuint64_t rsi;\n\t\tuint64_t esi;\n\t\tuint32_t _esi;\n\t};\n\tunion {\n\t\tuint64_t rdi;\n\t\tuint64_t edi;\n\t\tuint32_t _edi;\n\t};\n\tuint32_t error_code;\n\tuint32_t entry_vector;\n\tunion {\n\t\tuint64_t rip;\n\t\tuint64_t eip;\n\t\tuint32_t _eip;\n\t};\n\tuint16_t cs;\n\tuint16_t _pad0[1];\n\tuint8_t saved_upcall_mask;\n\tuint8_t _pad1[3];\n\tunion {\n\t\tuint64_t rflags;\n\t\tuint64_t eflags;\n\t\tuint32_t _eflags;\n\t};\n\tunion {\n\t\tuint64_t rsp;\n\t\tuint64_t esp;\n\t\tuint32_t _esp;\n\t};\n\tuint16_t ss;\n\tuint16_t _pad2[3];\n\tuint16_t es;\n\tuint16_t _pad3[3];\n\tuint16_t ds;\n\tuint16_t _pad4[3];\n\tuint16_t fs;\n\tuint16_t _pad5[3];\n\tuint16_t gs;\n\tuint16_t _pad6[3];\n};\n\nstruct vcpu_guest_context {\n\tstruct {\n\t\tchar x[512];\n\t} fpu_ctxt;\n\tlong unsigned int flags;\n\tstruct cpu_user_regs user_regs;\n\tstruct trap_info trap_ctxt[256];\n\tlong unsigned int ldt_base;\n\tlong unsigned int ldt_ents;\n\tlong unsigned int gdt_frames[16];\n\tlong unsigned int gdt_ents;\n\tlong unsigned int kernel_ss;\n\tlong unsigned int kernel_sp;\n\tlong unsigned int ctrlreg[8];\n\tlong unsigned int debugreg[8];\n\tlong unsigned int event_callback_eip;\n\tlong unsigned int failsafe_callback_eip;\n\tlong unsigned int syscall_callback_eip;\n\tlong unsigned int vm_assist;\n\tuint64_t fs_base;\n\tuint64_t gs_base_kernel;\n\tuint64_t gs_base_user;\n};\n\nstruct io_tlb_slot;\n\nstruct io_tlb_mem {\n\tphys_addr_t start;\n\tphys_addr_t end;\n\tlong unsigned int nslabs;\n\tlong unsigned int used;\n\tunsigned int index;\n\tspinlock_t lock;\n\tstruct dentry *debugfs;\n\tbool late_alloc;\n\tbool force_bounce;\n\tbool for_alloc;\n\tstruct io_tlb_slot *slots;\n};\n\nstruct sg_table {\n\tstruct scatterlist *sgl;\n\tunsigned int nents;\n\tunsigned int orig_nents;\n};\n\nenum swiotlb_force {\n\tSWIOTLB_NORMAL = 0,\n\tSWIOTLB_FORCE = 1,\n\tSWIOTLB_NO_FORCE = 2,\n};\n\nstruct io_tlb_slot {\n\tphys_addr_t orig_addr;\n\tsize_t alloc_size;\n\tunsigned int list;\n};\n\nstruct iommu_table_entry {\n\tinitcall_t detect;\n\tinitcall_t depend;\n\tvoid (*early_init)();\n\tvoid (*late_init)();\n\tint flags;\n};\n\nunion efi_boot_services;\n\ntypedef union efi_boot_services efi_boot_services_t;\n\ntypedef struct {\n\tefi_table_hdr_t hdr;\n\tu32 fw_vendor;\n\tu32 fw_revision;\n\tu32 con_in_handle;\n\tu32 con_in;\n\tu32 con_out_handle;\n\tu32 con_out;\n\tu32 stderr_handle;\n\tu32 stderr;\n\tu32 runtime;\n\tu32 boottime;\n\tu32 nr_tables;\n\tu32 tables;\n} efi_system_table_32_t;\n\nunion efi_simple_text_input_protocol;\n\ntypedef union efi_simple_text_input_protocol efi_simple_text_input_protocol_t;\n\nunion efi_simple_text_output_protocol;\n\ntypedef union efi_simple_text_output_protocol efi_simple_text_output_protocol_t;\n\ntypedef union {\n\tstruct {\n\t\tefi_table_hdr_t hdr;\n\t\tlong unsigned int fw_vendor;\n\t\tu32 fw_revision;\n\t\tlong unsigned int con_in_handle;\n\t\tefi_simple_text_input_protocol_t *con_in;\n\t\tlong unsigned int con_out_handle;\n\t\tefi_simple_text_output_protocol_t *con_out;\n\t\tlong unsigned int stderr_handle;\n\t\tlong unsigned int stderr;\n\t\tefi_runtime_services_t *runtime;\n\t\tefi_boot_services_t *boottime;\n\t\tlong unsigned int nr_tables;\n\t\tlong unsigned int tables;\n\t};\n\tefi_system_table_32_t mixed_mode;\n} efi_system_table_t;\n\nenum efi_secureboot_mode {\n\tefi_secureboot_mode_unset = 0,\n\tefi_secureboot_mode_unknown = 1,\n\tefi_secureboot_mode_disabled = 2,\n\tefi_secureboot_mode_enabled = 3,\n};\n\nstruct hvm_modlist_entry {\n\tuint64_t paddr;\n\tuint64_t size;\n\tuint64_t cmdline_paddr;\n\tuint64_t reserved;\n};\n\nstruct hvm_memmap_table_entry {\n\tuint64_t addr;\n\tuint64_t size;\n\tuint32_t type;\n\tuint32_t reserved;\n};\n\nenum {\n\tWORK_STRUCT_PENDING_BIT = 0,\n\tWORK_STRUCT_INACTIVE_BIT = 1,\n\tWORK_STRUCT_PWQ_BIT = 2,\n\tWORK_STRUCT_LINKED_BIT = 3,\n\tWORK_STRUCT_COLOR_SHIFT = 4,\n\tWORK_STRUCT_COLOR_BITS = 4,\n\tWORK_STRUCT_PENDING = 1,\n\tWORK_STRUCT_INACTIVE = 2,\n\tWORK_STRUCT_PWQ = 4,\n\tWORK_STRUCT_LINKED = 8,\n\tWORK_STRUCT_STATIC = 0,\n\tWORK_NR_COLORS = 16,\n\tWORK_CPU_UNBOUND = 8192,\n\tWORK_STRUCT_FLAG_BITS = 8,\n\tWORK_OFFQ_FLAG_BASE = 4,\n\t__WORK_OFFQ_CANCELING = 4,\n\tWORK_OFFQ_CANCELING = 16,\n\tWORK_OFFQ_FLAG_BITS = 1,\n\tWORK_OFFQ_POOL_SHIFT = 5,\n\tWORK_OFFQ_LEFT = 59,\n\tWORK_OFFQ_POOL_BITS = 31,\n\tWORK_OFFQ_POOL_NONE = 2147483647,\n\tWORK_STRUCT_FLAG_MASK = 255,\n\tWORK_STRUCT_WQ_DATA_MASK = 4294967040,\n\tWORK_STRUCT_NO_POOL = 4294967264,\n\tWORK_BUSY_PENDING = 1,\n\tWORK_BUSY_RUNNING = 2,\n\tWORKER_DESC_LEN = 24,\n};\n\nenum {\n\tMEMREMAP_WB = 1,\n\tMEMREMAP_WT = 2,\n\tMEMREMAP_WC = 4,\n\tMEMREMAP_ENC = 8,\n\tMEMREMAP_DEC = 16,\n};\n\nenum hv_isolation_type {\n\tHV_ISOLATION_TYPE_NONE = 0,\n\tHV_ISOLATION_TYPE_VBS = 1,\n\tHV_ISOLATION_TYPE_SNP = 2,\n};\n\nunion hv_x64_msr_hypercall_contents {\n\tu64 as_uint64;\n\tstruct {\n\t\tu64 enable: 1;\n\t\tu64 reserved: 11;\n\t\tu64 guest_physical_address: 52;\n\t};\n};\n\nunion hv_vp_assist_msr_contents {\n\tu64 as_uint64;\n\tstruct {\n\t\tu64 enable: 1;\n\t\tu64 reserved: 11;\n\t\tu64 pfn: 52;\n\t};\n};\n\nstruct hv_reenlightenment_control {\n\t__u64 vector: 8;\n\t__u64 reserved1: 8;\n\t__u64 enabled: 1;\n\t__u64 reserved2: 15;\n\t__u64 target_vp: 32;\n};\n\nstruct hv_tsc_emulation_control {\n\t__u64 enabled: 1;\n\t__u64 reserved: 63;\n};\n\nstruct hv_tsc_emulation_status {\n\t__u64 inprogress: 1;\n\t__u64 reserved: 63;\n};\n\nstruct hv_nested_enlightenments_control {\n\tstruct {\n\t\t__u32 directhypercall: 1;\n\t\t__u32 reserved: 31;\n\t} features;\n\tstruct {\n\t\t__u32 reserved;\n\t} hypercallControls;\n};\n\nstruct hv_vp_assist_page {\n\t__u32 apic_assist;\n\t__u32 reserved1;\n\t__u64 vtl_control[3];\n\tstruct hv_nested_enlightenments_control nested_control;\n\t__u8 enlighten_vmentry;\n\t__u8 reserved2[7];\n\t__u64 current_nested_vmcs;\n};\n\nstruct hv_get_partition_id {\n\tu64 partition_id;\n};\n\nstruct ms_hyperv_info {\n\tu32 features;\n\tu32 priv_high;\n\tu32 misc_features;\n\tu32 hints;\n\tu32 nested_features;\n\tu32 max_vp_index;\n\tu32 max_lp_index;\n\tu32 isolation_config_a;\n\tu32 isolation_config_b;\n};\n\nenum HV_GENERIC_SET_FORMAT {\n\tHV_GENERIC_SET_SPARSE_4K = 0,\n\tHV_GENERIC_SET_ALL = 1,\n};\n\nstruct hv_vpset {\n\tu64 format;\n\tu64 valid_bank_mask;\n\tu64 bank_contents[0];\n};\n\nstruct hv_tlb_flush {\n\tu64 address_space;\n\tu64 flags;\n\tu64 processor_mask;\n\tu64 gva_list[0];\n};\n\nstruct hv_tlb_flush_ex {\n\tu64 address_space;\n\tu64 flags;\n\tstruct hv_vpset hv_vp_set;\n\tu64 gva_list[0];\n};\n\nstruct trace_event_raw_hyperv_mmu_flush_tlb_multi {\n\tstruct trace_entry ent;\n\tunsigned int ncpus;\n\tstruct mm_struct *mm;\n\tlong unsigned int addr;\n\tlong unsigned int end;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_hyperv_nested_flush_guest_mapping {\n\tstruct trace_entry ent;\n\tu64 as;\n\tint ret;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_hyperv_nested_flush_guest_mapping_range {\n\tstruct trace_entry ent;\n\tu64 as;\n\tint ret;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_hyperv_send_ipi_mask {\n\tstruct trace_entry ent;\n\tunsigned int ncpus;\n\tint vector;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_hyperv_send_ipi_one {\n\tstruct trace_entry ent;\n\tint cpu;\n\tint vector;\n\tchar __data[0];\n};\n\nstruct trace_event_data_offsets_hyperv_mmu_flush_tlb_multi {};\n\nstruct trace_event_data_offsets_hyperv_nested_flush_guest_mapping {};\n\nstruct trace_event_data_offsets_hyperv_nested_flush_guest_mapping_range {};\n\nstruct trace_event_data_offsets_hyperv_send_ipi_mask {};\n\nstruct trace_event_data_offsets_hyperv_send_ipi_one {};\n\ntypedef void (*btf_trace_hyperv_mmu_flush_tlb_multi)(void *, const struct cpumask *, const struct flush_tlb_info *);\n\ntypedef void (*btf_trace_hyperv_nested_flush_guest_mapping)(void *, u64, int);\n\ntypedef void (*btf_trace_hyperv_nested_flush_guest_mapping_range)(void *, u64, int);\n\ntypedef void (*btf_trace_hyperv_send_ipi_mask)(void *, const struct cpumask *, int);\n\ntypedef void (*btf_trace_hyperv_send_ipi_one)(void *, int, int);\n\nstruct hv_guest_mapping_flush {\n\tu64 address_space;\n\tu64 flags;\n};\n\nunion hv_gpa_page_range {\n\tu64 address_space;\n\tstruct {\n\t\tu64 additional_pages: 11;\n\t\tu64 largepage: 1;\n\t\tu64 basepfn: 52;\n\t} page;\n\tstruct {\n\t\tu64 reserved: 12;\n\t\tu64 page_size: 1;\n\t\tu64 reserved1: 8;\n\t\tu64 base_large_pfn: 43;\n\t};\n};\n\nstruct hv_guest_mapping_flush_list {\n\tu64 address_space;\n\tu64 flags;\n\tunion hv_gpa_page_range gpa_list[510];\n};\n\ntypedef int (*hyperv_fill_flush_list_func)(struct hv_guest_mapping_flush_list *, void *);\n\nenum {\n\tIRQCHIP_SET_TYPE_MASKED = 1,\n\tIRQCHIP_EOI_IF_HANDLED = 2,\n\tIRQCHIP_MASK_ON_SUSPEND = 4,\n\tIRQCHIP_ONOFFLINE_ENABLED = 8,\n\tIRQCHIP_SKIP_SET_WAKE = 16,\n\tIRQCHIP_ONESHOT_SAFE = 32,\n\tIRQCHIP_EOI_THREADED = 64,\n\tIRQCHIP_SUPPORTS_LEVEL_MSI = 128,\n\tIRQCHIP_SUPPORTS_NMI = 256,\n\tIRQCHIP_ENABLE_WAKEUP_ON_SUSPEND = 512,\n\tIRQCHIP_AFFINITY_PRE_STARTUP = 1024,\n};\n\nenum irq_alloc_type {\n\tX86_IRQ_ALLOC_TYPE_IOAPIC = 1,\n\tX86_IRQ_ALLOC_TYPE_HPET = 2,\n\tX86_IRQ_ALLOC_TYPE_PCI_MSI = 3,\n\tX86_IRQ_ALLOC_TYPE_PCI_MSIX = 4,\n\tX86_IRQ_ALLOC_TYPE_DMAR = 5,\n\tX86_IRQ_ALLOC_TYPE_AMDVI = 6,\n\tX86_IRQ_ALLOC_TYPE_UV = 7,\n};\n\nstruct ioapic_alloc_info {\n\tint pin;\n\tint node;\n\tu32 is_level: 1;\n\tu32 active_low: 1;\n\tu32 valid: 1;\n};\n\nstruct uv_alloc_info {\n\tint limit;\n\tint blade;\n\tlong unsigned int offset;\n\tchar *name;\n};\n\nstruct irq_alloc_info {\n\tenum irq_alloc_type type;\n\tu32 flags;\n\tu32 devid;\n\tirq_hw_number_t hwirq;\n\tconst struct cpumask *mask;\n\tstruct msi_desc *desc;\n\tvoid *data;\n\tunion {\n\t\tstruct ioapic_alloc_info ioapic;\n\t\tstruct uv_alloc_info uv;\n\t};\n};\n\nstruct irq_cfg {\n\tunsigned int dest_apicid;\n\tunsigned int vector;\n};\n\nenum {\n\tIRQCHIP_FWNODE_REAL = 0,\n\tIRQCHIP_FWNODE_NAMED = 1,\n\tIRQCHIP_FWNODE_NAMED_ID = 2,\n};\n\ntypedef struct irq_alloc_info msi_alloc_info_t;\n\nstruct msi_domain_info;\n\nstruct msi_domain_ops {\n\tirq_hw_number_t (*get_hwirq)(struct msi_domain_info *, msi_alloc_info_t *);\n\tint (*msi_init)(struct irq_domain *, struct msi_domain_info *, unsigned int, irq_hw_number_t, msi_alloc_info_t *);\n\tvoid (*msi_free)(struct irq_domain *, struct msi_domain_info *, unsigned int);\n\tint (*msi_check)(struct irq_domain *, struct msi_domain_info *, struct device *);\n\tint (*msi_prepare)(struct irq_domain *, struct device *, int, msi_alloc_info_t *);\n\tvoid (*msi_finish)(msi_alloc_info_t *, int);\n\tvoid (*set_desc)(msi_alloc_info_t *, struct msi_desc *);\n\tint (*handle_error)(struct irq_domain *, struct msi_desc *, int);\n\tint (*domain_alloc_irqs)(struct irq_domain *, struct device *, int);\n\tvoid (*domain_free_irqs)(struct irq_domain *, struct device *);\n};\n\nstruct msi_domain_info {\n\tu32 flags;\n\tstruct msi_domain_ops *ops;\n\tstruct irq_chip *chip;\n\tvoid *chip_data;\n\tirq_flow_handler_t handler;\n\tvoid *handler_data;\n\tconst char *handler_name;\n\tvoid *data;\n};\n\nenum {\n\tMSI_FLAG_USE_DEF_DOM_OPS = 1,\n\tMSI_FLAG_USE_DEF_CHIP_OPS = 2,\n\tMSI_FLAG_MULTI_PCI_MSI = 4,\n\tMSI_FLAG_PCI_MSIX = 8,\n\tMSI_FLAG_ACTIVATE_EARLY = 16,\n\tMSI_FLAG_MUST_REACTIVATE = 32,\n\tMSI_FLAG_LEVEL_CAPABLE = 64,\n};\n\nenum hv_interrupt_type {\n\tHV_X64_INTERRUPT_TYPE_FIXED = 0,\n\tHV_X64_INTERRUPT_TYPE_LOWESTPRIORITY = 1,\n\tHV_X64_INTERRUPT_TYPE_SMI = 2,\n\tHV_X64_INTERRUPT_TYPE_REMOTEREAD = 3,\n\tHV_X64_INTERRUPT_TYPE_NMI = 4,\n\tHV_X64_INTERRUPT_TYPE_INIT = 5,\n\tHV_X64_INTERRUPT_TYPE_SIPI = 6,\n\tHV_X64_INTERRUPT_TYPE_EXTINT = 7,\n\tHV_X64_INTERRUPT_TYPE_LOCALINT0 = 8,\n\tHV_X64_INTERRUPT_TYPE_LOCALINT1 = 9,\n\tHV_X64_INTERRUPT_TYPE_MAXIMUM = 10,\n};\n\nunion hv_msi_address_register {\n\tu32 as_uint32;\n\tstruct {\n\t\tu32 reserved1: 2;\n\t\tu32 destination_mode: 1;\n\t\tu32 redirection_hint: 1;\n\t\tu32 reserved2: 8;\n\t\tu32 destination_id: 8;\n\t\tu32 msi_base: 12;\n\t};\n};\n\nunion hv_msi_data_register {\n\tu32 as_uint32;\n\tstruct {\n\t\tu32 vector: 8;\n\t\tu32 delivery_mode: 3;\n\t\tu32 reserved1: 3;\n\t\tu32 level_assert: 1;\n\t\tu32 trigger_mode: 1;\n\t\tu32 reserved2: 16;\n\t};\n};\n\nunion hv_msi_entry {\n\tu64 as_uint64;\n\tstruct {\n\t\tunion hv_msi_address_register address;\n\t\tunion hv_msi_data_register data;\n\t};\n};\n\nunion hv_ioapic_rte {\n\tu64 as_uint64;\n\tstruct {\n\t\tu32 vector: 8;\n\t\tu32 delivery_mode: 3;\n\t\tu32 destination_mode: 1;\n\t\tu32 delivery_status: 1;\n\t\tu32 interrupt_polarity: 1;\n\t\tu32 remote_irr: 1;\n\t\tu32 trigger_mode: 1;\n\t\tu32 interrupt_mask: 1;\n\t\tu32 reserved1: 15;\n\t\tu32 reserved2: 24;\n\t\tu32 destination_id: 8;\n\t};\n\tstruct {\n\t\tu32 low_uint32;\n\t\tu32 high_uint32;\n\t};\n};\n\nstruct hv_interrupt_entry {\n\tu32 source;\n\tu32 reserved1;\n\tunion {\n\t\tunion hv_msi_entry msi_entry;\n\t\tunion hv_ioapic_rte ioapic_rte;\n\t};\n};\n\nstruct hv_device_interrupt_target {\n\tu32 vector;\n\tu32 flags;\n\tunion {\n\t\tu64 vp_mask;\n\t\tstruct hv_vpset vp_set;\n\t};\n};\n\nenum hv_device_type {\n\tHV_DEVICE_TYPE_LOGICAL = 0,\n\tHV_DEVICE_TYPE_PCI = 1,\n\tHV_DEVICE_TYPE_IOAPIC = 2,\n\tHV_DEVICE_TYPE_ACPI = 3,\n};\n\ntypedef u16 hv_pci_rid;\n\ntypedef u16 hv_pci_segment;\n\nunion hv_pci_bdf {\n\tu16 as_uint16;\n\tstruct {\n\t\tu8 function: 3;\n\t\tu8 device: 5;\n\t\tu8 bus;\n\t};\n};\n\nunion hv_pci_bus_range {\n\tu16 as_uint16;\n\tstruct {\n\t\tu8 subordinate_bus;\n\t\tu8 secondary_bus;\n\t};\n};\n\nunion hv_device_id {\n\tu64 as_uint64;\n\tstruct {\n\t\tu64 reserved0: 62;\n\t\tu64 device_type: 2;\n\t};\n\tstruct {\n\t\tu64 id: 62;\n\t\tu64 device_type: 2;\n\t} logical;\n\tstruct {\n\t\tunion {\n\t\t\thv_pci_rid rid;\n\t\t\tunion hv_pci_bdf bdf;\n\t\t};\n\t\thv_pci_segment segment;\n\t\tunion hv_pci_bus_range shadow_bus_range;\n\t\tu16 phantom_function_bits: 2;\n\t\tu16 source_shadow: 1;\n\t\tu16 rsvdz0: 11;\n\t\tu16 device_type: 2;\n\t} pci;\n\tstruct {\n\t\tu8 ioapic_id;\n\t\tu8 rsvdz0;\n\t\tu16 rsvdz1;\n\t\tu16 rsvdz2;\n\t\tu16 rsvdz3: 14;\n\t\tu16 device_type: 2;\n\t} ioapic;\n\tstruct {\n\t\tu32 input_mapping_base;\n\t\tu32 input_mapping_count: 30;\n\t\tu32 device_type: 2;\n\t} acpi;\n};\n\nenum hv_interrupt_trigger_mode {\n\tHV_INTERRUPT_TRIGGER_MODE_EDGE = 0,\n\tHV_INTERRUPT_TRIGGER_MODE_LEVEL = 1,\n};\n\nstruct hv_device_interrupt_descriptor {\n\tu32 interrupt_type;\n\tu32 trigger_mode;\n\tu32 vector_count;\n\tu32 reserved;\n\tstruct hv_device_interrupt_target target;\n};\n\nstruct hv_input_map_device_interrupt {\n\tu64 partition_id;\n\tu64 device_id;\n\tu64 flags;\n\tstruct hv_interrupt_entry logical_interrupt_entry;\n\tstruct hv_device_interrupt_descriptor interrupt_descriptor;\n};\n\nstruct hv_output_map_device_interrupt {\n\tstruct hv_interrupt_entry interrupt_entry;\n};\n\nstruct hv_input_unmap_device_interrupt {\n\tu64 partition_id;\n\tu64 device_id;\n\tstruct hv_interrupt_entry interrupt_entry;\n};\n\nstruct rid_data {\n\tstruct pci_dev *bridge;\n\tu32 rid;\n};\n\nstruct hv_send_ipi {\n\tu32 vector;\n\tu32 reserved;\n\tu64 cpu_mask;\n};\n\nstruct hv_send_ipi_ex {\n\tu32 vector;\n\tu32 reserved;\n\tstruct hv_vpset vp_set;\n};\n\nstruct hv_deposit_memory {\n\tu64 partition_id;\n\tu64 gpa_page_list[0];\n};\n\nstruct hv_proximity_domain_flags {\n\tu32 proximity_preferred: 1;\n\tu32 reserved: 30;\n\tu32 proximity_info_valid: 1;\n};\n\nunion hv_proximity_domain_info {\n\tstruct {\n\t\tu32 domain_id;\n\t\tstruct hv_proximity_domain_flags flags;\n\t};\n\tu64 as_uint64;\n};\n\nstruct hv_lp_startup_status {\n\tu64 hv_status;\n\tu64 substatus1;\n\tu64 substatus2;\n\tu64 substatus3;\n\tu64 substatus4;\n\tu64 substatus5;\n\tu64 substatus6;\n};\n\nstruct hv_add_logical_processor_in {\n\tu32 lp_index;\n\tu32 apic_id;\n\tunion hv_proximity_domain_info proximity_domain_info;\n\tu64 flags;\n};\n\nstruct hv_add_logical_processor_out {\n\tstruct hv_lp_startup_status startup_status;\n};\n\nenum HV_SUBNODE_TYPE {\n\tHvSubnodeAny = 0,\n\tHvSubnodeSocket = 1,\n\tHvSubnodeAmdNode = 2,\n\tHvSubnodeL3 = 3,\n\tHvSubnodeCount = 4,\n\tHvSubnodeInvalid = 4294967295,\n};\n\nstruct hv_create_vp {\n\tu64 partition_id;\n\tu32 vp_index;\n\tu8 padding[3];\n\tu8 subnode_type;\n\tu64 subnode_id;\n\tunion hv_proximity_domain_info proximity_domain_info;\n\tu64 flags;\n};\n\nstruct real_mode_header {\n\tu32 text_start;\n\tu32 ro_end;\n\tu32 trampoline_start;\n\tu32 trampoline_header;\n\tu32 sev_es_trampoline_start;\n\tu32 trampoline_pgd;\n\tu32 wakeup_start;\n\tu32 wakeup_header;\n\tu32 machine_real_restart_asm;\n\tu32 machine_real_restart_seg;\n};\n\nstruct trampoline_header {\n\tu64 start;\n\tu64 efer;\n\tu32 cr4;\n\tu32 flags;\n};\n\nenum show_regs_mode {\n\tSHOW_REGS_SHORT = 0,\n\tSHOW_REGS_USER = 1,\n\tSHOW_REGS_ALL = 2,\n};\n\nstruct resctrl_pqr_state {\n\tu32 cur_rmid;\n\tu32 cur_closid;\n\tu32 default_rmid;\n\tu32 default_closid;\n};\n\nenum which_selector {\n\tFS = 0,\n\tGS = 1,\n};\n\nstruct sigcontext_64 {\n\t__u64 r8;\n\t__u64 r9;\n\t__u64 r10;\n\t__u64 r11;\n\t__u64 r12;\n\t__u64 r13;\n\t__u64 r14;\n\t__u64 r15;\n\t__u64 di;\n\t__u64 si;\n\t__u64 bp;\n\t__u64 bx;\n\t__u64 dx;\n\t__u64 ax;\n\t__u64 cx;\n\t__u64 sp;\n\t__u64 ip;\n\t__u64 flags;\n\t__u16 cs;\n\t__u16 gs;\n\t__u16 fs;\n\t__u16 ss;\n\t__u64 err;\n\t__u64 trapno;\n\t__u64 oldmask;\n\t__u64 cr2;\n\t__u64 fpstate;\n\t__u64 reserved1[8];\n};\n\nstruct sigaltstack {\n\tvoid *ss_sp;\n\tint ss_flags;\n\tsize_t ss_size;\n};\n\ntypedef struct sigaltstack stack_t;\n\nstruct siginfo {\n\tunion {\n\t\tstruct {\n\t\t\tint si_signo;\n\t\t\tint si_errno;\n\t\t\tint si_code;\n\t\t\tunion __sifields _sifields;\n\t\t};\n\t\tint _si_pad[32];\n\t};\n};\n\ntypedef struct siginfo siginfo_t;\n\nstruct ksignal {\n\tstruct k_sigaction ka;\n\tkernel_siginfo_t info;\n\tint sig;\n};\n\nstruct __large_struct {\n\tlong unsigned int buf[100];\n};\n\ntypedef u32 compat_size_t;\n\ntypedef s32 compat_clock_t;\n\ntypedef s32 compat_pid_t;\n\ntypedef s32 compat_timer_t;\n\ntypedef s32 compat_int_t;\n\ntypedef u32 compat_ulong_t;\n\ntypedef u32 __compat_uid32_t;\n\ntypedef s64 compat_s64;\n\ntypedef u32 compat_sigset_word;\n\nstruct compat_sigaltstack {\n\tcompat_uptr_t ss_sp;\n\tint ss_flags;\n\tcompat_size_t ss_size;\n};\n\ntypedef struct compat_sigaltstack compat_stack_t;\n\ntypedef struct {\n\tcompat_sigset_word sig[2];\n} compat_sigset_t;\n\nunion compat_sigval {\n\tcompat_int_t sival_int;\n\tcompat_uptr_t sival_ptr;\n};\n\ntypedef union compat_sigval compat_sigval_t;\n\nstruct compat_siginfo {\n\tint si_signo;\n\tint si_errno;\n\tint si_code;\n\tunion {\n\t\tint _pad[29];\n\t\tstruct {\n\t\t\tcompat_pid_t _pid;\n\t\t\t__compat_uid32_t _uid;\n\t\t} _kill;\n\t\tstruct {\n\t\t\tcompat_timer_t _tid;\n\t\t\tint _overrun;\n\t\t\tcompat_sigval_t _sigval;\n\t\t} _timer;\n\t\tstruct {\n\t\t\tcompat_pid_t _pid;\n\t\t\t__compat_uid32_t _uid;\n\t\t\tcompat_sigval_t _sigval;\n\t\t} _rt;\n\t\tstruct {\n\t\t\tcompat_pid_t _pid;\n\t\t\t__compat_uid32_t _uid;\n\t\t\tint _status;\n\t\t\tcompat_clock_t _utime;\n\t\t\tcompat_clock_t _stime;\n\t\t} _sigchld;\n\t\tstruct {\n\t\t\tcompat_pid_t _pid;\n\t\t\t__compat_uid32_t _uid;\n\t\t\tint _status;\n\t\t\tcompat_s64 _utime;\n\t\t\tcompat_s64 _stime;\n\t\t} __attribute__((packed)) _sigchld_x32;\n\t\tstruct {\n\t\t\tcompat_uptr_t _addr;\n\t\t\tunion {\n\t\t\t\tint _trapno;\n\t\t\t\tshort int _addr_lsb;\n\t\t\t\tstruct {\n\t\t\t\t\tchar _dummy_bnd[4];\n\t\t\t\t\tcompat_uptr_t _lower;\n\t\t\t\t\tcompat_uptr_t _upper;\n\t\t\t\t} _addr_bnd;\n\t\t\t\tstruct {\n\t\t\t\t\tchar _dummy_pkey[4];\n\t\t\t\t\tu32 _pkey;\n\t\t\t\t} _addr_pkey;\n\t\t\t\tstruct {\n\t\t\t\t\tcompat_ulong_t _data;\n\t\t\t\t\tu32 _type;\n\t\t\t\t\tu32 _flags;\n\t\t\t\t} _perf;\n\t\t\t};\n\t\t} _sigfault;\n\t\tstruct {\n\t\t\tcompat_long_t _band;\n\t\t\tint _fd;\n\t\t} _sigpoll;\n\t\tstruct {\n\t\t\tcompat_uptr_t _call_addr;\n\t\t\tint _syscall;\n\t\t\tunsigned int _arch;\n\t\t} _sigsys;\n\t} _sifields;\n} __attribute__((packed));\n\ntypedef struct compat_siginfo compat_siginfo_t;\n\nstruct ucontext {\n\tlong unsigned int uc_flags;\n\tstruct ucontext *uc_link;\n\tstack_t uc_stack;\n\tstruct sigcontext_64 uc_mcontext;\n\tsigset_t uc_sigmask;\n};\n\nstruct kernel_vm86_regs {\n\tstruct pt_regs pt;\n\tshort unsigned int es;\n\tshort unsigned int __esh;\n\tshort unsigned int ds;\n\tshort unsigned int __dsh;\n\tshort unsigned int fs;\n\tshort unsigned int __fsh;\n\tshort unsigned int gs;\n\tshort unsigned int __gsh;\n};\n\nstruct rt_sigframe {\n\tchar *pretcode;\n\tstruct ucontext uc;\n\tstruct siginfo info;\n};\n\nstruct ucontext_x32 {\n\tunsigned int uc_flags;\n\tunsigned int uc_link;\n\tcompat_stack_t uc_stack;\n\tunsigned int uc__pad0;\n\tstruct sigcontext_64 uc_mcontext;\n\tcompat_sigset_t uc_sigmask;\n};\n\nstruct rt_sigframe_x32 {\n\tu64 pretcode;\n\tstruct ucontext_x32 uc;\n\tcompat_siginfo_t info;\n};\n\nenum bug_trap_type {\n\tBUG_TRAP_TYPE_NONE = 0,\n\tBUG_TRAP_TYPE_WARN = 1,\n\tBUG_TRAP_TYPE_BUG = 2,\n};\n\nenum insn_mode {\n\tINSN_MODE_32 = 0,\n\tINSN_MODE_64 = 1,\n\tINSN_MODE_KERN = 2,\n\tINSN_NUM_MODES = 3,\n};\n\ntypedef u8 kprobe_opcode_t;\n\nstruct kprobe;\n\nstruct arch_specific_insn {\n\tkprobe_opcode_t *insn;\n\tunsigned int boostable: 1;\n\tunsigned char size;\n\tunion {\n\t\tunsigned char opcode;\n\t\tstruct {\n\t\t\tunsigned char type;\n\t\t} jcc;\n\t\tstruct {\n\t\t\tunsigned char type;\n\t\t\tunsigned char asize;\n\t\t} loop;\n\t\tstruct {\n\t\t\tunsigned char reg;\n\t\t} indirect;\n\t};\n\ts32 rel32;\n\tvoid (*emulate_op)(struct kprobe *, struct pt_regs *);\n\tint tp_len;\n};\n\ntypedef int (*kprobe_pre_handler_t)(struct kprobe *, struct pt_regs *);\n\ntypedef void (*kprobe_post_handler_t)(struct kprobe *, struct pt_regs *, long unsigned int);\n\nstruct kprobe {\n\tstruct hlist_node hlist;\n\tstruct list_head list;\n\tlong unsigned int nmissed;\n\tkprobe_opcode_t *addr;\n\tconst char *symbol_name;\n\tunsigned int offset;\n\tkprobe_pre_handler_t pre_handler;\n\tkprobe_post_handler_t post_handler;\n\tkprobe_opcode_t opcode;\n\tstruct arch_specific_insn ainsn;\n\tu32 flags;\n};\n\nenum die_val {\n\tDIE_OOPS = 1,\n\tDIE_INT3 = 2,\n\tDIE_DEBUG = 3,\n\tDIE_PANIC = 4,\n\tDIE_NMI = 5,\n\tDIE_DIE = 6,\n\tDIE_KERNELDEBUG = 7,\n\tDIE_TRAP = 8,\n\tDIE_GPF = 9,\n\tDIE_CALL = 10,\n\tDIE_PAGE_FAULT = 11,\n\tDIE_NMIUNKNOWN = 12,\n};\n\nenum kernel_gp_hint {\n\tGP_NO_HINT = 0,\n\tGP_NON_CANONICAL = 1,\n\tGP_CANONICAL = 2,\n};\n\ntypedef struct irq_desc *vector_irq_t[256];\n\nstruct trace_event_raw_x86_irq_vector {\n\tstruct trace_entry ent;\n\tint vector;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_vector_config {\n\tstruct trace_entry ent;\n\tunsigned int irq;\n\tunsigned int vector;\n\tunsigned int cpu;\n\tunsigned int apicdest;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_vector_mod {\n\tstruct trace_entry ent;\n\tunsigned int irq;\n\tunsigned int vector;\n\tunsigned int cpu;\n\tunsigned int prev_vector;\n\tunsigned int prev_cpu;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_vector_reserve {\n\tstruct trace_entry ent;\n\tunsigned int irq;\n\tint ret;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_vector_alloc {\n\tstruct trace_entry ent;\n\tunsigned int irq;\n\tunsigned int vector;\n\tbool reserved;\n\tint ret;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_vector_alloc_managed {\n\tstruct trace_entry ent;\n\tunsigned int irq;\n\tunsigned int vector;\n\tint ret;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_vector_activate {\n\tstruct trace_entry ent;\n\tunsigned int irq;\n\tbool is_managed;\n\tbool can_reserve;\n\tbool reserve;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_vector_teardown {\n\tstruct trace_entry ent;\n\tunsigned int irq;\n\tbool is_managed;\n\tbool has_reserved;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_vector_setup {\n\tstruct trace_entry ent;\n\tunsigned int irq;\n\tbool is_legacy;\n\tint ret;\n\tchar __data[0];\n};\n\nstruct trace_event_raw_vector_free_moved {\n\tstruct trace_entry ent;\n\tunsigned int irq;\n\tunsigned int cpu;\n\tunsigned int vector;\n\tbool is_managed;\n\tchar __data[0];\n};\n\nstruct trace_event_data_offsets_x86_irq_vector {};\n\nstruct trace_event_data_offsets_vector_config {};\n\nstruct trace_event_data_offsets_vector_mod {};\n\nstruct trace_event_data_offsets_vector_reserve {};\n\nstruct trace_event_data_offsets_vector_alloc {};\n\nstruct trace_event_data_offsets_vector_alloc_managed {};\n\nstruct trace_event_data_offsets_vector_activate {};\n\nstruct trace_event_data_offsets_vector_teardown {};\n\nstruct trace_event_data_offsets_vector_setup {};\n\nstruct trace_event_data_offsets_vector_free_moved {};\n\ntypedef void (*btf_trace_local_timer_entry)(void *, int);\n\ntypedef void (*btf_trace_local_timer_exit)(void *, int);\n\ntypedef void (*btf_trace_spurious_apic_entry)(void *, int);\n\ntypedef void (*btf_trace_spurious_apic_exit)(void *, int);\n\ntypedef void (*btf_trace_error_apic_entry)(void *, int);\n\ntypedef void (*btf_trace_error_apic_exit)(void *, int);\n\ntypedef void (*btf_trace_x86_platform_ipi_entry)(void *, int);\n\ntypedef void (*btf_trace_x86_platform_ipi_exit)(void *, int);\n\ntypedef void (*btf_trace_irq_work_entry)(void *, int);\n\ntypedef void (*btf_trace_irq_work_exit)(void *, int);\n\ntypedef void (*btf_trace_reschedule_entry)(void *, int);\n\ntypedef void (*btf_trace_reschedule_exit)(void *, int);\n\ntypedef void (*btf_trace_call_function_entry)(void *, int);\n\ntypedef void (*btf_trace_call_function_exit)(void *, int);\n\ntypedef void (*btf_trace_call_function_single_entry)(void *, int);\n\ntypedef void (*btf_trace_call_function_single_exit)(void *, int);\n\ntypedef void (*btf_trace_threshold_apic_entry)(void *, int);\n\ntypedef void (*btf_trace_threshold_apic_exit)(void *, int);\n\ntypedef void (*btf_trace_deferred_error_apic_entry)(void *, int);\n\ntypedef void (*btf_trace_deferred_error_apic_exit)(void *, int);\n\ntypedef void (*btf_trace_thermal_apic_entry)(void *, int);\n\ntypedef void (*btf_trace_thermal_apic_exit)(void *, int);\n\ntypedef void (*btf_trace_vector_config)(void *, unsigned int, unsigned int, unsigned int, unsigned int);\n\ntypedef void (*btf_trace_vector_update)(void *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);\n\ntypedef void (*btf_trace_vector_clear)(void *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);\n\ntypedef void (*btf_trace_vector_reserve_managed)(void *, unsigned int, int);\n\ntypedef void (*btf_trace_vector_reserve)(void *, unsigned int, int);\n\ntypedef void (*btf_trace_vector_alloc)(void *, unsigned int, unsigned int, bool, int);\n\ntypedef void (*btf_trace_vector_alloc_managed)(void *, unsigned int, unsigned int, int);\n\ntypedef void (*btf_trace_vector_activate)(void *, unsigned int, bool, bool, bool);\n\ntypedef void (*btf_trace_vector_deactivate)(void *, unsigned int, bool, bool, bool);\n\ntypedef void (*btf_trace_vector_teardown)(void *, unsigned int, bool, bool);\n\ntypedef void (*btf_trace_vector_setup)(void *, unsigned int, bool, int);\n\ntypedef void (*btf_trace_vector_free_moved)(void *, unsigned int, unsigned int, unsigned int, bool);\n\nstruct irq_stack {\n\tchar stack[16384];\n};\n\nstruct estack_pages {\n\tu32 offs;\n\tu16 size;\n\tu16 type;\n};\n\nenum lockdown_reason {\n\tLOCKDOWN_NONE = 0,\n\tLOCKDOWN_MODULE_SIGNATURE = 1,\n\tLOCKDOWN_DEV_MEM = 2,\n\tLOCKDOWN_EFI_TEST = 3,\n\tLOCKDOWN_KEXEC = 4,\n\tLOCKDOWN_HIBERNATION = 5,\n\tLOCKDOWN_PCI_ACCESS = 6,\n\tLOCKDOWN_IOPORT = 7,\n\tLOCKDOWN_MSR = 8,\n\tLOCKDOWN_ACPI_TABLES = 9,\n\tLOCKDOWN_PCMCIA_CIS = 10,\n\tLOCKDOWN_TIOCSSERIAL = 11,\n\tLOCKDOWN_MODULE_PARAMETERS = 12,\n\tLOCKDOWN_MMIOTRACE = 13,\n\tLOCKDOWN_DEBUGFS = 14,\n\tLOCKDOWN_XMON_WR = 15,\n\tLOCKDOWN_BPF_WRITE_USER = 16,\n\tLOCKDOWN_KGDB = 17,\n\tLOCKDOWN_INTEGRITY_MAX = 18,\n\tLOCKDOWN_KCORE = 19,\n\tLOCKDOWN_KPROBES = 20,\n\tLOCKDOWN_BPF_READ_KERNEL = 21,\n\tLOCKDOWN_PERF = 22,\n\tLOCKDOWN_TRACEFS = 23,\n\tLOCKDOWN_XMON_RW = 24,\n\tLOCKDOWN_XFRM_SECRET = 25,\n\tLOCKDOWN_CONFIDENTIALITY_MAX = 26,\n};\n\nenum lockdep_ok {\n\tLOCKDEP_STILL_OK = 0,\n\tLOCKDEP_NOW_UNRELIABLE = 1,\n};\n\nstruct trace_event_raw_nmi_handler {\n\tstruct trace_entry ent;\n\tvoid *handler;\n\ts64 delta_ns;\n\tint handled;\n\tchar __data[0];\n};\n\nstruct trace_event_data_offsets_nmi_handler {};\n\ntypedef void (*btf_trace_nmi_handler)(void *, void *, s64, int);\n\nstruct nmi_desc {\n\traw_spinlock_t lock;\n\tstruct list_head head;\n};\n\nstruct nmi_stats {\n\tunsigned int normal;\n\tunsigned int unknown;\n\tunsigned int external;\n\tunsigned int swallow;\n};\n\nenum nmi_states {\n\tNMI_NOT_RUNNING = 0,\n\tNMI_EXECUTING = 1,\n\tNMI_LATCHED = 2,\n};\n\nstruct user_desc {\n\tunsigned int entry_number;\n\tunsigned int base_addr;\n\tunsigned int limit;\n\tunsigned int seg_32bit: 1;\n\tunsigned int contents: 2;\n\tunsigned int read_exec_only: 1;\n\tunsigned int limit_in_pages: 1;\n\tunsigned int seg_not_present: 1;\n\tunsigned int useable: 1;\n\tunsigned int lm: 1;\n};\n\nstruct edd {\n\tunsigned int mbr_signature[16];\n\tstruct edd_info edd_info[6];\n\tunsigned char mbr_signature_nr;\n\tunsigned char edd_info_nr;\n};\n\nstruct setup_data {\n\t__u64 next;\n\t__u32 type;\n\t__u32 len;\n\t__u8 data[0];\n};\n\nstruct setup_indirect {\n\t__u32 type;\n\t__u32 reserved;\n\t__u64 len;\n\t__u64 addr;\n};\n\nenum con_scroll {\n\tSM_UP = 0,\n\tSM_DOWN = 1,\n};\n\nenum vc_intensity {\n\tVCI_HALF_BRIGHT = 0,\n\tVCI_NORMAL = 1,\n\tVCI_BOLD = 2,\n\tVCI_MASK = 3,\n};\n\nstruct vc_data;\n\nstruct console_font;\n\nstruct consw {\n\tstruct module *owner;\n\tconst char * (*con_startup)();\n\tvoid (*con_init)(struct vc_data *, int);\n\tvoid (*con_deinit)(struct vc_data *);\n\tvoid (*con_clear)(struct vc_data *, int, int, int, int);\n\tvoid (*con_putc)(struct vc_data *, int, int, int);\n\tvoid (*con_putcs)(struct vc_data *, const short unsigned int *, int, int, int);\n\tvoid (*con_cursor)(struct vc_data *, int);\n\tbool (*con_scroll)(struct vc_data *, unsigned int, unsigned int, enum con_scroll, unsigned int);\n\tint (*con_switch)(struct vc_data *);\n\tint (*con_blank)(struct vc_data *, int, int);\n\tint (*con_font_set)(struct vc_data *, struct console_font *, unsigned int);\n\tint (*con_font_get)(struct vc_data *, struct console_font *);\n\tint (*con_font_default)(struct vc_data *, struct console_font *, char *);\n\tint (*con_resize)(struct vc_data *, unsigned int, unsigned int, unsigned int);\n\tvoid (*con_set_palette)(struct vc_data *, const unsigned char *);\n\tvoid (*con_scrolldelta)(struct vc_data *, int);\n\tint (*con_set_origin)(struct vc_data *);\n\tvoid (*con_save_screen)(struct vc_data *);\n\tu8 (*con_build_attr)(struct vc_data *, u8, enum vc_intensity, bool, bool, bool, bool);\n\tvoid (*con_invert_region)(struct vc_data *, u16 *, int);\n\tu16 * (*con_screen_pos)(const struct vc_data *, int);\n\tlong unsigned int (*con_getxy)(struct vc_data *, long unsigned int, int *, int *);\n\tvoid (*con_flush_scrollback)(struct vc_data *);\n\tint (*con_debug_enter)(struct vc_data *);\n\tint (*con_debug_leave)(struct vc_data *);\n};\n\nstruct vc_state {\n\tunsigned int x;\n\tunsigned int y;\n\tunsigned char color;\n\tunsigned char Gx_charset[2];\n\tunsigned int charset: 1;\n\tenum vc_intensity intensity;\n\tbool italic;\n\tbool underline;\n\tbool blink;\n\tbool reverse;\n};\n\nstruct console_font {\n\tunsigned int width;\n\tunsigned int height;\n\tunsigned int charcount;\n\tunsigned char *data;\n};\n\nstruct vt_mode {\n\tchar mode;\n\tchar waitv;\n\tshort int relsig;\n\tshort int acqsig;\n\tshort int frsig;\n};\n\nstruct uni_pagedir;\n\nstruct uni_screen;\n\nstruct vc_data {\n\tstruct tty_port port;\n\tstruct vc_state state;\n\tstruct vc_state saved_state;\n\tshort unsigned int vc_num;\n\tunsigned int vc_cols;\n\tunsigned int vc_rows;\n\tunsigned int vc_size_row;\n\tunsigned int vc_scan_lines;\n\tunsigned int vc_cell_height;\n\tlong unsigned int vc_origin;\n\tlong unsigned int vc_scr_end;\n\tlong unsigned int vc_visible_origin;\n\tunsigned int vc_top;\n\tunsigned int vc_bottom;\n\tconst struct consw *vc_sw;\n\tshort unsigned int *vc_screenbuf;\n\tunsigned int vc_screenbuf_size;\n\tunsigned char vc_mode;\n\tunsigned char vc_attr;\n\tunsigned char vc_def_color;\n\tunsigned char vc_ulcolor;\n\tunsigned char vc_itcolor;\n\tunsigned char vc_halfcolor;\n\tunsigned int vc_cursor_type;\n\tshort unsigned int vc_complement_mask;\n\tshort unsigned int vc_s_complement_mask;\n\tlong unsigned int vc_pos;\n\tshort unsigned int vc_hi_font_mask;\n\tstruct console_font vc_font;\n\tshort unsigned int vc_video_erase_char;\n\tunsigned int vc_state;\n\tunsigned int vc_npar;\n\tunsigned int vc_par[16];\n\tstruct vt_mode vt_mode;\n\tstruct pid *vt_pid;\n\tint vt_newvt;\n\twait_queue_head_t paste_wait;\n\tunsigned int vc_disp_ctrl: 1;\n\tunsigned int vc_toggle_meta: 1;\n\tunsigned int vc_decscnm: 1;\n\tunsigned int vc_decom: 1;\n\tunsigned int vc_decawm: 1;\n\tunsigned int vc_deccm: 1;\n\tunsigned int vc_decim: 1;\n\tunsigned int vc_priv: 3;\n\tunsigned int vc_need_wrap: 1;\n\tunsigned int vc_can_do_color: 1;\n\tunsigned int vc_report_mouse: 2;\n\tunsigned char vc_utf: 1;\n\tunsigned char vc_utf_count;\n\tint vc_utf_char;\n\tlong unsigned int vc_tab_stop[4];\n\tunsigned char vc_palette[48];\n\tshort unsigned int *vc_translate;\n\tunsigned int vc_resize_user;\n\tunsigned int vc_bell_pitch;\n\tunsigned int vc_bell_duration;\n\tshort unsigned int vc_cur_blink_ms;\n\tstruct vc_data **vc_display_fg;\n\tstruct uni_pagedir *vc_uni_pagedir;\n\tstruct uni_pagedir **vc_uni_pagedir_loc;\n\tstruct uni_screen *vc_uni_screen;\n};\n\nenum memblock_flags {\n\tMEMBLOCK_NONE = 0,\n\tMEMBLOCK_HOTPLUG = 1,\n\tMEMBLOCK_MIRROR = 2,\n\tMEMBLOCK_NOMAP = 4,\n};\n\nstruct memblock_region {\n\tphys_addr_t base;\n\tphys_addr_t size;\n\tenum memblock_flags flags;\n\tint nid;\n};\n\nstruct memblock_type {\n\tlong unsigned int cnt;\n\tlong unsigned int max;\n\tphys_addr_t total_size;\n\tstruct memblock_region *regions;\n\tchar *name;\n};\n\nstruct memblock {\n\tbool bottom_up;\n\tphys_addr_t current_limit;\n\tstruct memblock_type memory;\n\tstruct memblock_type reserved;\n};\n\nstruct x86_msi_ops {\n\tvoid (*restore_msi_irqs)(struct pci_dev *);\n};\n\nstruct legacy_pic {\n\tint nr_legacy_irqs;\n\tstruct irq_chip *chip;\n\tvoid (*mask)(unsigned int);\n\tvoid (*unmask)(unsigned int);\n\tvoid (*mask_all)();\n\tvoid (*restore_mask)();\n\tvoid (*init)(int);\n\tint (*probe)();\n\tint (*irq_pending)(unsigned int);\n\tvoid (*make_irq)(unsigned int);\n};\n\nenum jump_label_type {\n\tJUMP_LABEL_NOP = 0,\n\tJUMP_LABEL_JMP = 1,\n};\n\nunion text_poke_insn {\n\tu8 text[5];\n\tstruct {\n\t\tu8 opcode;\n\t\ts32 disp;\n\t} __attribute__((packed));\n};\n\nstruct jump_label_patch {\n\tconst void *code;\n\tint size;\n};\n\nenum {\n\tJL_STATE_START = 0,\n\tJL_STATE_NO_UPDATE = 1,\n\tJL_STATE_UPDATE = 2,\n};\n\ntypedef short unsigned int __kernel_old_uid_t;\n\ntypedef short unsigned int __kernel_old_gid_t;\n\ntypedef struct {\n\tint val[2];\n} __kernel_fsid_t;\n\ntypedef __kernel_old_uid_t old_uid_t;\n\ntypedef __kernel_old_gid_t old_gid_t;\n\nstruct kernel_clone_args {\n\tu64 flags;\n\tint *pidfd;\n\tint *child_tid;\n\tint *parent_tid;\n\tint exit_signal;\n\tlong unsigned int stack;\n\tlong unsigned int stack_size;\n\tlong unsigned int tls;\n\tpid_t *set_tid;\n\tsize_t set_tid_size;\n\tint cgroup;\n\tint io_thread;\n\tstruct cgroup *cgrp;\n\tstruct css_set *cset;\n};\n\nstruct kstatfs {\n\tlong int f_type;\n\tlong int f_bsize;\n\tu64 f_blocks;\n\tu64 f_bfree;\n\tu64 f_bavail;\n\tu64 f_files;\n\tu64 f_ffree;\n\t__kernel_fsid_t f_fsid;\n\tlong int f_namelen;\n\tlong int f_frsize;\n\tlong int f_flags;\n\tlong int f_spare[4];\n};\n\nstruct stat64 {\n\tlong long unsigned int st_dev;\n\tunsigned char __pad0[4];\n\tunsigned int __st_ino;\n\tunsigned int st_mode;\n\tunsigned int st_nlink;\n\tunsigned int st_uid;\n\tunsigned int st_gid;\n\tlong long unsigned int st_rdev;\n\tunsigned char __pad3[4];\n\tlong long int st_size;\n\tunsigned int st_blksize;\n\tlong long int st_blocks;\n\tunsigned int st_atime;\n\tunsigned int st_atime_nsec;\n\tunsigned int st_mtime;\n\tunsigned int st_mtime_nsec;\n\tunsigned int st_ctime;\n\tunsigned int st_ctime_nsec;\n\tlong long unsigned int st_ino;\n} __attribute__((packed));\n\nstruct mmap_arg_struct32 {\n\tunsigned int addr;\n\tunsigned int len;\n\tunsigned int prot;\n\tunsigned int flags;\n\tunsigned int fd;\n\tunsigned int offset;\n};\n\nstruct vm_unmapped_area_info {\n\tlong unsigned int flags;\n\tlong unsigned int length;\n\tlong unsigned int low_limit;\n\tlong unsigned int high_limit;\n\tlong unsigned int align_mask;\n\tlong unsigned int align_offset;\n};\n\nenum align_flags {\n\tALIGN_VA_32 = 1,\n\tALIGN_VA_64 = 2,\n};\n\nstruct va_alignment {\n\tint flags;\n\tlong unsigned int mask;\n\tlong unsigned int bits;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n\tlong: 64;\n};\n\nstruct kobj_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct kobject *, struct kobj_attribute *, char *);\n\tssize_t (*store)(struct kobject *, struct kobj_attribute *, const char *, size_t);\n};\n\ntypedef void (*swap_func_t)(void *, void *, int);\n\ntypedef int (*cmp_func_t)(const void *, const void *);\n\nenum {\n\tIORES_DESC_NONE = 0,\n\tIORES_DESC_CRASH_KERNEL = 1,\n\tIORES_DESC_ACPI_TABLES = 2,\n\tIORES_DESC_ACPI_NV_STORAGE = 3,\n\tIORES_DESC_PERSISTENT_MEMORY = 4,\n\tIORES_DESC_PERSISTENT_MEMORY_LEGACY = 5,\n\tIORES_DESC_DEVICE_PRIVATE_MEMORY = 6,\n\tIORES_DESC_RESERVED = 7,\n\tIORES_DESC_SOFT_RESERVED = 8,\n};\n\nstruct change_member {\n\tstruct e820_entry *entry;\n\tlong long unsigned int addr;\n};\n\nstruct iommu_fault_param;\n\nstruct iopf_device_param;\n\nstruct iommu_fwspec;\n\nstruct dev_iommu {\n\tstruct mutex lock;\n\tstruct iommu_fault_param *fault_param;\n\tstruct iopf_device_param *iopf_param;\n\tstruct iommu_fwspec *fwspec;\n\tstruct iommu_device *iommu_dev;\n\tvoid *priv;\n};\n\nstruct of_phandle_args {\n\tstruct device_node *np;\n\tint args_count;\n\tuint32_t args[16];\n};\n\nstruct iommu_fault_unrecoverable {\n\t__u32 reason;\n\t__u32 flags;\n\t__u32 pasid;\n\t__u32 perm;\n\t__u64 addr;\n\t__u64 fetch_addr;\n};\n\nstruct iommu_fault_page_request {\n\t__u32 flags;\n\t__u32 pasid;\n\t__u32 grpid;\n\t__u32 perm;\n\t__u64 addr;\n\t__u64 private_data[2];\n};\n\nstruct iommu_fault {\n\t__u32 type;\n\t__u32 padding;\n\tunion {\n\t\tstruct iommu_fault_unrecoverable event;\n\t\tstruct iommu_fault_page_request prm;\n\t\t__u8 padding2[56];\n\t};\n};\n\nstruct iommu_page_response {\n\t__u32 argsz;\n\t__u32 version;\n\t__u32 flags;\n\t__u32 pasid;\n\t__u32 grpid;\n\t__u32 code;\n};\n\nstruct iommu_inv_addr_info {\n\t__u32 flags;\n\t__u32 archid;\n\t__u64 pasid;\n\t__u64 addr;\n\t__u64 granule_size;\n\t__u64 nb_granules;\n};\n\nstruct iommu_inv_pasid_info {\n\t__u32 flags;\n\t__u32 archid;\n\t__u64 pasid;\n};\n\nstruct iommu_cache_invalidate_info {\n\t__u32 argsz;\n\t__u32 version;\n\t__u8 cache;\n\t__u8 granularity;\n\t__u8 padding[6];\n\tunion {\n\t\tstruct iommu_inv_pasid_info pasid_info;\n\t\tstruct iommu_inv_addr_info addr_info;\n\t} granu;\n};\n\nstruct iommu_gpasid_bind_data_vtd {\n\t__u64 flags;\n\t__u32 pat;\n\t__u32 emt;\n};\n\nstruct iommu_gpasid_bind_data {\n\t__u32 argsz;\n\t__u32 version;\n\t__u32 format;\n\t__u32 addr_width;\n\t__u64 flags;\n\t__u64 gpgd;\n\t__u64 hpasid;\n\t__u64 gpasid;\n\t__u8 padding[8];\n\tunion {\n\t\tstruct iommu_gpasid_bind_data_vtd vtd;\n\t} vendor;\n};\n\ntypedef int (*iommu_fault_handler_t)(struct iommu_domain *, struct device *, long unsigned int, int, void *);\n\nstruct iommu_domain_geometry {\n\tdma_addr_t aperture_start;\n\tdma_addr_t aperture_end;\n\tbool force_aperture;\n};\n\nstruct iommu_dma_cookie;\n\nstruct iommu_domain {\n\tunsigned int type;\n\tconst struct iommu_ops *ops;\n\tlong unsigned int pgsize_bitmap;\n\tiommu_fault_handler_t handler;\n\tvoid *handler_token;\n\tstruct iommu_domain_geometry geometry;\n\tstruct iommu_dma_cookie *iova_cookie;\n};\n\ntypedef int (*iommu_dev_fault_handler_t)(struct iommu_fault *, void *);\n\nenum iommu_resv_type {\n\tIOMMU_RESV_DIRECT = 0,\n\tIOMMU_RESV_DIRECT_RELAXABLE = 1,\n\tIOMMU_RESV_RESERVED = 2,\n\tIOMMU_RESV_MSI = 3,\n\tIOMMU_RESV_SW_MSI = 4,\n};\n\nstruct iommu_resv_region {\n\tstruct list_head list;\n\tphys_addr_t start;\n\tsize_t length;\n\tint prot;\n\tenum iommu_resv_type type;\n};\n\nstruct iommu_iotlb_gather {\n\tlong unsigned int start;\n\tlong unsigned int end;\n\tsize_t pgsize;\n\tstruct page *freelist;\n\tbool queued;\n};\n\nstruct iommu_device {\n\tstruct list_head list;\n\tconst struct iommu_ops *ops;\n\tstruct fwnode_handle *fwnode;\n\tstruct device *dev;\n};\n\nstruct iommu_sva {\n\tstruct device *dev;\n};\n\nstruct iommu_fault_event {\n\tstruct iommu_fault fault;\n\tstruct list_head list;\n};\n\nstruct iommu_fault_param {\n\tiommu_dev_fault_handler_t handler;\n\tvoid *data;\n\tstruct list_head faults;\n\tstruct mutex lock;\n};\n\nstruct iommu_fwspec {\n\tconst struct iommu_ops *ops;\n\tstruct fwnode_handle *iommu_fwnode;\n\tu32 flags;\n\tunsigned int num_ids;\n\tu32 ids[0];\n};\n\nenum dmi_field {\n\tDMI_NONE = 0,\n\tDMI_BIOS_VENDOR = 1,\n\tDMI_BIOS_VERSION = 2,\n\tDMI_BIOS_DATE = 3,\n\tDMI_BIOS_RELEASE = 4,\n\tDMI_EC_FIRMWARE_RELEASE = 5,\n\tDMI_SYS_VENDOR = 6,\n\tDMI_PRODUCT_NAME = 7,\n\tDMI_PRODUCT_VERSION = 8,\n\tDMI_PRODUCT_SERIAL = 9,\n\tDMI_PRODUCT_UUID = 10,\n\tDMI_PRODUCT_SKU = 11,\n\tDMI_PRODUCT_FAMILY = 12,\n\tDMI_BOARD_VENDOR = 13,\n\tDMI_BOARD_NAME = 14,\n\tDMI_BOARD_VERSION = 15,\n\tDMI_BOARD_SERIAL = 16,\n\tDMI_BOARD_ASSET_TAG = 17,\n\tDMI_CHASSIS_VENDOR = 18,\n\tDMI_CHASSIS_TYPE = 19,\n\tDMI_CHASSIS_VERSION = 20,\n\tDMI_CHASSIS_SERIAL = 21,\n\tDMI_CHASSIS_ASSET_TAG = 22,\n\tDMI_STRING_MAX = 23,\n\tDMI_OEM_STRING = 24,\n};\n\nenum {\n\tNONE_FORCE_HPET_RESUME = 0,\n\tOLD_ICH_FORCE_HPET_RESUME = 1,\n\tICH_FORCE_HPET_RESUME = 2,\n\tVT8237_FORCE_HPET_RESUME = 3,\n\tNVIDIA_FORCE_HPET_RESUME = 4,\n\tATI_FORCE_HPET_RESUME = 5,\n};\n\nenum meminit_context {\n\tMEMINIT_EARLY = 0,\n\tMEMINIT_HOTPLUG = 1,\n};\n\nstruct cpu {\n\tint node_id;\n\tint hotpluggable;\n\tstruct device dev;\n};\n\nstruct x86_cpu {\n\tstruct cpu cpu;\n};\n\ntypedef u8 retpoline_thunk_t[32];\n\nstruct paravirt_patch_site {\n\tu8 *instr;\n\tu8 type;\n\tu8 len;\n};\n\nstruct die_args {\n\tstruct pt_regs *regs;\n\tconst char *str;\n\tlong int err;\n\tint trapnr;\n\tint signr;\n};\n\nstruct tlb_state_shared {\n\tbool is_lazy;\n};\n\nstruct smp_alt_module {\n\tstruct module *mod;\n\tchar *name;\n\tconst s32 *locks;\n\tconst s32 *locks_end;\n\tu8 *text;\n\tu8 *text_end;\n\tstruct list_head next;\n};\n\ntypedef struct {\n\tstruct mm_struct *mm;\n} temp_mm_state_t;\n\nstruct text_poke_loc {\n\ts32 rel_addr;\n\ts32 disp;\n\tu8 len;\n\tu8 opcode;\n\tconst u8 text[5];\n\tu8 old;\n};\n\nstruct bp_patching_desc {\n\tstruct text_poke_loc *vec;\n\tint nr_entries;\n\tatomic_t refs;\n};\n\nenum {\n\tHW_BREAKPOINT_LEN_1 = 1,\n\tHW_BREAKPOINT_LEN_2 = 2,\n\tHW_BREAKPOINT_LEN_3 = 3,\n\tHW_BREAKPOINT_LEN_4 = 4,\n\tHW_BREAKPOINT_LEN_5 = 5,\n\tHW_BREAKPOINT_LEN_6 = 6,\n\tHW_BREAKPOINT_LEN_7 = 7,\n\tHW_BREAKPOINT_LEN_8 = 8,\n};\n\nenum {\n\tHW_BREAKPOINT_EMPTY = 0,\n\tHW_BREAKPOINT_R = 1,\n\tHW_BREAKPOINT_W = 2,\n\tHW_BREAKPOINT_RW = 3,\n\tHW_BREAKPOINT_X = 4,\n\tHW_BREAKPOINT_INVALID = 7,\n};\n\ntypedef unsigned int u_int;\n\ntypedef long long unsigned int cycles_t;\n\nstruct system_counterval_t {\n\tu64 cycles;\n\tstruct clocksource *cs;\n};\n\ntypedef struct {\n\tseqcount_t seqcount;\n} seqcount_latch_t;\n\nenum cpufreq_table_sorting {\n\tCPUFREQ_TABLE_UNSORTED = 0,\n\tCPUFREQ_TABLE_SORTED_ASCENDING = 1,\n\tCPUFREQ_TABLE_SORTED_DESCENDING = 2,\n};\n\nstruct cpufreq_cpuinfo {\n\tunsigned int max_freq;\n\tunsigned int min_freq;\n\tunsigned int transition_latency;\n};\n\nstruct clk;\n\nstruct cpufreq_governor;\n\nstruct cpufreq_frequency_table;\n\nstruct cpufreq_stats;\n\nstruct thermal_cooling_device;\n\nstruct cpufreq_policy {\n\tcpumask_var_t cpus;\n\tcpumask_var_t related_cpus;\n\tcpumask_var_t real_cpus;\n\tunsigned int shared_type;\n\tunsigned int cpu;\n\tstruct clk *clk;\n\tstruct cpufreq_cpuinfo cpuinfo;\n\tunsigned int min;\n\tunsigned int max;\n\tunsigned int cur;\n\tunsigned int suspend_freq;\n\tunsigned int policy;\n\tunsigned int last_policy;\n\tstruct cpufreq_governor *governor;\n\tvoid *governor_data;\n\tchar last_governor[16];\n\tstruct work_struct update;\n\tstruct freq_constraints constraints;\n\tstruct freq_qos_request *min_freq_req;\n\tstruct freq_qos_request *max_freq_req;\n\tstruct cpufreq_frequency_table *freq_table;\n\tenum cpufreq_table_sorting freq_table_sorted;\n\tstruct list_head policy_list;\n\tstruct kobject kobj;\n\tstruct completion kobj_unregister;\n\tstruct rw_semaphore rwsem;\n\tbool fast_switch_possible;\n\tbool fast_switch_enabled;\n\tbool strict_target;\n\tunsigned int transition_delay_us;\n\tbool dvfs_possible_from_any_cpu;\n\tunsigned int cached_target_freq;\n\tunsigned int cached_resolved_idx;\n\tbool transition_ongoing;\n\tspinlock_t trans"
        },
        {
          "name": "vmlinux_kern_diffs.h",
          "type": "blob",
          "size": 1.685546875,
          "content": "/*\n    SysmonForLinux\n\n    Copyright (c) Microsoft Corporation\n\n    All rights reserved.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n//====================================================================\n//\n// vmlinux_kern_diffs.h\n//\n// Contains type definitions that are kernel version dependent.\n// The type definitions are usually duplicates (although with only\n// the fields that are relevant). CO-RE has a special naming convention\n// to properly handle this. See \"Handling incompatible field and type changes\"\n// in:\n//\n// https://nakryiko.com/posts/bpf-core-reference-guide/#defining-own-co-re-relocatable-type-definitions\n//\n//====================================================================\n\n#ifndef __VMLINUX_KERN_DIFFS_H__\n#define __VMLINUX_KERN_DIFFS_H__\n\n#include <vmlinux.h>\n\n//\n// In kernel v6.6 inode i_ctime, i_atime and i_mtime field changed to __i_Xtime.\n//\nstruct inode___pre_v66\n{\n    struct timespec64 i_atime;\n    struct timespec64 i_mtime;\n    struct timespec64 i_ctime;\n};\n\n#endif /* __VMLINUX_KERN_DIFFS_H__ */\n"
        }
      ]
    }
  ]
}