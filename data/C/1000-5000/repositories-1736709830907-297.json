{
  "metadata": {
    "timestamp": 1736709830907,
    "page": 297,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rfjakob/earlyoom",
      "stars": 3017,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.0205078125,
          "content": "BasedOnStyle: WebKit\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1533203125,
          "content": "*~\n/earlyoom\n/earlyoom.profile\n/.*\n\n# generated from MANPAGE.md\n/earlyoom.1\n/earlyoom.1.gz\n\n# generated service files\n/earlyoom.service\n/earlyoom.initscript\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.271484375,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at jakobunt@gmail.com. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see\nhttps://www.contributor-covenant.org/faq\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.1533203125,
          "content": "FROM gcc as build\n\nWORKDIR /usr/src\nCOPY . .\n\nENV CFLAGS -static\nRUN make\n\n###\n\nFROM scratch\nCOPY --from=build /usr/src/earlyoom /\n\nENTRYPOINT [\"/earlyoom\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0615234375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Jakob Unterwurzacher\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "MANPAGE-render.sh",
          "type": "blob",
          "size": 0.044921875,
          "content": "#!/bin/bash\n\nmake earlyoom.1\nman ./earlyoom.1\n"
        },
        {
          "name": "MANPAGE.md",
          "type": "blob",
          "size": 9.2041015625,
          "content": "% earlyoom(1) | General Commands Manual\n\n# NAME\n\nearlyoom - Early OOM Daemon\n\n# SYNOPSIS\n\n**earlyoom** [**OPTION**]...\n\n# DESCRIPTION\n\nThe oom-killer generally has a bad reputation among Linux users. One may have\nto sit in front of an unresponsive system, listening to the grinding disk for\nminutes, and press the reset button to quickly get back to what one was doing\nafter running out of patience.\n\n**earlyoom** checks the amount of available memory and free swap up to 10 times a\nsecond (less often if there is a lot of free memory).\nIf **both** memory **and** swap (if any) are below 10%, it will kill the\nlargest process (highest `oom_score`).\n\nThe percentage values are configurable via command line arguments.\n\nIf there is a failure when trying to kill a process, **earlyoom** sleeps for\n1 second to limit log spam due to recurring errors.\n\n# OPTIONS\n\n#### -m PERCENT[,KILL_PERCENT]\nset available memory minimum to PERCENT of `user mem total` (default 10 %).\n\n`user mem total`, introduced in earlyoom v1.8, is the memory accessible by userspace\n(`MemAvailable`+`AnonPages` as reported in `/proc/meminfo`).\nWhen a tmpfs ramdisk fills up, `user mem total` shrinks accordingly.\n\nBy using a percentage of `user mem total` as opposed to total memory,\nthe set memory minimum can always be achieved by killing processes, even\nwhen tmpfs fills a large portion of memory.\n\nearlyoom sends SIGTERM once **both** available memory **and** free swap are\nbelow their respective PERCENT settings.\n\nIt sends SIGKILL once **both** are below their respective\nKILL_PERCENT setting (default PERCENT/2).\n\nUse the same value for PERCENT and KILL_PERCENT if you always want to use SIGKILL.\n\nExamples:\n\n    earlyoom              # sets PERCENT=10, KILL_PERCENT=5\n    earlyoom -m 30        # sets PERCENT=30, KILL_PERCENT=15\n    earlyoom -m 20,18     # sets PERCENT=20, KILL_PERCENT=18\n\n#### -s PERCENT[,KILL_PERCENT]\nset free swap minimum to PERCENT of total (default 10 %).\nSend SIGKILL if at or below KILL_PERCENT (default PERCENT/2), otherwise SIGTERM.\n\nYou can use `-s 100` to have earlyoom effectively ignore swap usage:\nProcesses are killed once available memory drops below the configured\nminimum, no matter how much swap is free.\n\nUse the same value for PERCENT and KILL_PERCENT if you always want to use SIGKILL.\n\n#### -M SIZE[,KILL_SIZE]\nAs an alternative to specifying a percentage of total memory, `-M` sets\nthe available memory minimum to SIZE KiB. The value is internally converted\nto the percentage of `mem total` as reported on startup. `user mem total` is\nNOT used for the startup calculation because that would make the outcome dependent\non how filled tmpfs is at that moment.\n\nIf you pass both `-M` and `-m`, the lower value is used.\nExample: Reserve 10% of RAM but at most 1 GiB:\n\n    earlyoom -m 10 -M 1048576\n\nearlyoom sends SIGKILL if at or below KILL_SIZE (default SIZE/2), otherwise SIGTERM.\n\n#### -S SIZE[,KILL_SIZE]\nAs an alternative to specifying a percentage of total swap, `-S` sets\nthe free swap minimum to SIZE KiB. The value is internally converted\nto a percentage. If you pass both `-S` and `-s`, the lower value is used.\n\nSend SIGKILL if at or below KILL_SIZE (default SIZE/2), otherwise SIGTERM.\n\n#### -k\nremoved in earlyoom v1.2, ignored for compatibility\n\n#### -i\nremoved in earlyoom v1.7, ignored for compatibility\n\n#### -d, --debug\nenable debugging messages\n\n#### -v\nprint version information and exit\n\n#### -r INTERVAL\nTime between printing periodic memory reports, in seconds (default 1.0).\nA memory report looks like this:\n\n    mem avail: 21790 of 23909 MiB (91.14%), swap free:    0 of    0 MiB ( 0.00%)\n\nSet to 3600 to print a report every hour, to 86400 to print once a day\netc. Set to 0 to disable printing periodic memory reports.\nFree memory monitoring and low-memory killing runs independently of\nthis option at an adaptive poll rate that only depends on free memory.\nDue to the adaptive poll rate, when there is a lot of free memory,\nthe actual interval may be up to 1 second longer than the setting.\n\n#### -p\nIncrease earlyoom's priority: set niceness of earlyoom to -20 and oom_score_adj to -100.\n\nWhen earlyoom is run through its default systemd service, the `-p` switch doesn't work. To achieve the same effect, enter the following three lines into `sudo systemctl edit earlyoom`:\n\n    [Service]\n    OOMScoreAdjust=-100\n    Nice=-20\n\n#### -n\nEnable notifications via d-bus.\n\nTo actually see the notifications in your GUI session, you need to have\n[systembus-notify](https://github.com/rfjakob/systembus-notify)\nrunning as your user.\n\n#### -N /PATH/TO/SCRIPT\nRun the given script for each process killed. Must be an absolute path.\n\nWithin the script, information about the killed process can be obtained via the\nfollowing environment variables:\n\n    EARLYOOM_PID     Process PID\n    EARLYOOM_NAME    Process name truncated to 16 bytes (as reported in /proc/PID/comm)\n    EARLYOOM_CMDLINE Process cmdline truncated to 256 bytes (as reported in /proc/PID/cmdline)\n    EARLYOOM_UID     UID of the user running the process\n\nWARNING: `EARLYOOM_NAME` can contain spaces, newlines, special characters\nand is controlled by the user, or it can be empty! Make sure that your\nnotification script can handle that!\n\n#### -g\nKill all processes that have same process group id (PGID) as the process\nwith excessive memory usage.\n\nFor example, with this flag turned on, the whole application will be killed when\none of its subprocess consumes too much memory (as long as they all have the\nsame PGID, of course).\n\nEnable this flag when completely cleaning up the \"entire application\" is more desirable,\nand you are sure that the application puts all its processes in the same PGID.\n\nNote that some desktop environments (GNOME, for example) put all desktop\napplication in the same process group as `gnome-shell`. earlyoom might kill\nall such processes including `gnome-shell` when this flag is turned on.\n\nBe sure to check how your environment behaves beforehand. Use\n\n\tpstree -gT\n\nto show all processes with the PGID in brackets.\n\n#### \\-\\-prefer REGEX\nPrefer killing processes whose `comm` name matches REGEX (adds 300 to oom_score).\n\nThe `comm` name is the string in `/proc/pid/comm`. It is the first 15 bytes of the\nprocess name. Longer names are truncated to 15 bytes.\n\nThe `comm` name is also what `top`, `pstree`, `ps -e` show. Use any of these tools\nto find the proper `comm` name.\n\nExample: You want to match `gnome-control-center`, which is longer than 15 bytes:\n\n    earlyoom --prefer '^gnome-control-c$'\n\n#### \\-\\-avoid REGEX\navoid killing processes whose `comm` name matches REGEX (subtracts 300 from oom_score).\n\n#### \\-\\-ignore REGEX\nignore processes whose `comm` name matches REGEX.\n\nUnlike the \\-\\-avoid option, this option disables any potential killing of the matched processes\nthat might have occurred due to the processes attaining a high oom_score.\n\nUse this option with caution as other processes might be sacrificed in place of the ignored\nprocesses when earlyoom determines to kill processes.\n\n### \\-\\-sort-by-rss\nfind process with the largest rss (default oom_score)\n\n#### \\-\\-dryrun\ndry run (do not kill any processes)\n\n#### \\-\\-syslog\nuse syslog instead of std streams.\n\nUsually this is not needed as systemd handles logging\nof all output.\n\nThe \\-\\-syslog option may be useful for minimal embedded\nsystems that don't run systemd.\nSee https://github.com/rfjakob/earlyoom/pull/292 for some\nbackground info.\n\n#### -h, \\-\\-help\nthis help text\n\n# EXIT STATUS\n\n0: Successful program execution.\n\n1: Other error - inspect message for details\n\n2: Switch conflict.\n\n4: Could not cd to /proc\n\n5: Could not open proc\n\n7: Could not open /proc/sysrq-trigger\n\n13: Unknown options.\n\n14: Wrong parameters for other options.\n\n15: Wrong parameters for memory threshold.\n\n16: Wrong parameters for swap threshold.\n\n102: Could not open /proc/meminfo\n\n103: Could not read /proc/meminfo\n\n104: Could not find a specific entry in /proc/meminfo\n\n105: Could not convert number when parse the contents of /proc/meminfo\n\n# Why not trigger the kernel oom killer?\n\nEarlyoom does not use `echo f > /proc/sysrq-trigger` because the Chrome people\nmade their browser always be the first (innocent!)  victim by setting\n`oom_score_adj` very high. Instead, earlyoom finds out itself by reading through\n`/proc/*/status` (actually `/proc/*/statm`, which contains the same information\nbut is easier to parse programmatically).\n\nAdditionally, in recent kernels (tested on 4.0.5), triggering the kernel oom\nkiller manually may not work at all. That is, it may only free some graphics\nmemory (that will be allocated immediately again) and not actually kill any\nprocess.\n\n# MEMORY USAGE\n\nAbout 2 MiB VmRSS. All memory is locked using mlockall() to make sure earlyoom\ndoes not slow down in low memory situations.\n\n# BUGS\n\nIf there is zero total swap on earlyoom startup, any `-S` (uppercase \"S\") values\nare ignored, a warning is printed, and default swap percentages are used.\n\nFor processes matched by `--prefer`, negative `oom_score_adj` values are not\ntaken into account, and the process gets an effective `oom_score` of at least\n300. See https://github.com/rfjakob/earlyoom/issues/159 for details.\n\n# AUTHOR\n\nThe author of earlyoom is Jakob Unterwurzacher ⟨jakobunt@gmail.com⟩.\n\nThis manual page was written by Yangfl ⟨mmyangfl@gmail.com⟩, for the Debian\nproject (and may be used by others).\n\n# SEE ALSO\n\nnohang(8)\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.830078125,
          "content": "# Setting GIT_DIR keeps git from ascending to parent directories\n# and gives a nicer error message\nVERSION ?= $(shell GIT_DIR=$(shell pwd)/.git git describe --tags --dirty)\nifeq ($(VERSION),)\nVERSION := \"(unknown version)\"\n$(warning Could not get version from git, setting to $(VERSION))\nendif\nCFLAGS += -Wall -Wextra -Wformat-security -Wconversion -DVERSION=\\\"$(VERSION)\\\" -g -fstack-protector-all -std=gnu99\n\nDESTDIR ?=\nPREFIX ?= /usr/local\nBINDIR ?= $(PREFIX)/bin\nMANDIR ?= $(PREFIX)/share/man\nMAN1DIR ?= $(MANDIR)/man1\n# Systemd hardcodes its unit path list\nSYSCONFDIR ?= /etc\nSYSTEMDUNITDIR ?= /etc/systemd/system\nPANDOC := $(shell command -v pandoc 2> /dev/null)\n\n.PHONY: all clean install uninstall format test\n\nall: earlyoom earlyoom.1 earlyoom.service\n\nearlyoom: $(wildcard *.c *.h) Makefile\n\t$(CC) $(LDFLAGS) $(CPPFLAGS) $(CFLAGS) -o $@ $(wildcard *.c)\n\n.PHONY: earlyoom.profile\nearlyoom.profile:\n\t$(CC) $(LDFLAGS) $(CPPFLAGS) $(CFLAGS) -DPROFILE_FIND_LARGEST_PROCESS -o earlyoom.profile $(wildcard *.c)\n\nearlyoom.1: MANPAGE.md\nifdef PANDOC\n\tpandoc MANPAGE.md -s -t man > earlyoom.1\nelse\n\t@echo \"pandoc is not installed, skipping earlyoom.1 manpage generation\"\nendif\n\nclean:\n\trm -f earlyoom earlyoom.profile earlyoom.service earlyoom.initscript earlyoom.1 earlyoom.1.gz gmon.out*\n\ninstall: earlyoom.service install-bin install-default install-man\n\tinstall -d $(DESTDIR)$(SYSTEMDUNITDIR)\n\tinstall -m 644 $< $(DESTDIR)$(SYSTEMDUNITDIR)\n\t-chcon -t systemd_unit_file_t $(DESTDIR)$(SYSTEMDUNITDIR)/$<\n\t-systemctl enable earlyoom\n\ninstall-initscript: earlyoom.initscript install-bin install-default\n\tinstall -d $(DESTDIR)$(SYSCONFDIR)/init.d/\n\tinstall -m 755 $< $(DESTDIR)$(SYSCONFDIR)/init.d/earlyoom\n\t-update-rc.d earlyoom start 18 2 3 4 5 . stop 20 0 1 6 .\n\nearlyoom.%: earlyoom.%.in\n\tsed \"s|:TARGET:|$(BINDIR)|g;s|:SYSCONFDIR:|$(SYSCONFDIR)|g\" $< > $@\n\ninstall-default: earlyoom.default install-man\n\tinstall -d $(DESTDIR)$(SYSCONFDIR)/default/\n\tinstall -m 644 $< $(DESTDIR)$(SYSCONFDIR)/default/earlyoom\n\ninstall-bin: earlyoom\n\tinstall -d $(DESTDIR)$(BINDIR)/\n\tinstall -m 755 $< $(DESTDIR)$(BINDIR)/\n\ninstall-man: earlyoom.1.gz\nifdef PANDOC\n\tinstall -d $(DESTDIR)$(MAN1DIR)/\n\tinstall -m 644 $< $(DESTDIR)$(MAN1DIR)/\nendif\n\nearlyoom.1.gz: earlyoom.1\nifdef PANDOC\n\tgzip -f -k -n $<\nendif\n\nuninstall: uninstall-bin uninstall-man\n\tsystemctl disable earlyoom\n\trm -f $(DESTDIR)$(SYSTEMDUNITDIR)/earlyoom.service\n\nuninstall-man:\n\trm -f $(DESTDIR)$(MAN1DIR)/earlyoom.1.gz\n\nuninstall-initscript: uninstall-bin\n\trm -f $(DESTDIR)$(SYSCONFDIR)/init.d/earlyoom\n\tupdate-rc.d earlyoom remove\n\nuninstall-bin:\n\trm -f $(DESTDIR)$(BINDIR)/earlyoom\n\n# Depends on earlyoom compilation to make sure the syntax is ok.\nformat: earlyoom\n\tclang-format --style=file -i *.h *.c\n\tgo fmt .\n\ntest: earlyoom\n\tcppcheck -q . || echo \"skipping optional cppcheck\"\n\tgo test -v\n\n.PHONY: bench\nbench:\n\tgo test -run=NONE -bench=.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.0986328125,
          "content": "earlyoom - The Early OOM Daemon\n===============================\n\n[![CI](https://github.com/rfjakob/earlyoom/actions/workflows/ci.yml/badge.svg)](https://github.com/rfjakob/earlyoom/actions/workflows/ci.yml)\n[![MIT License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)\n[![Latest release](https://img.shields.io/github/release/rfjakob/earlyoom.svg)](https://github.com/rfjakob/earlyoom/releases)\n\nThe oom-killer generally has a bad reputation among Linux users. This may be\npart of the reason Linux invokes it only when it has absolutely no other choice.\nIt will swap out the desktop environment, drop the whole page cache and empty\nevery buffer before it will ultimately kill a process. At least that's what I\nthink that it will do. I have yet to be patient enough to wait for it, sitting\nin front of an unresponsive system.\n\nThis made me and other people wonder if the oom-killer could be configured to\nstep in earlier: [reddit r/linux][5], [superuser.com][2], [unix.stackexchange.com][3].\n\nAs it turns out, no, it can't. At least using the in-kernel oom-killer.\nIn the user space, however, we can do whatever we want.\n\nearlyoom wants to be simple and solid. It is written in pure C with no dependencies.\nAn extensive test suite (unit- and integration tests) is written in Go.\n\nWhat does it do\n---------------\nearlyoom checks the amount of available memory and free swap up to 10\ntimes a second (less often if there is a lot of free memory).\nBy default if both are below 10%, it will kill the largest process (highest `oom_score`).\nThe percentage value is configurable via command line\narguments.\n\nIn the `free -m` output below, the available memory is 2170 MiB and\nthe free swap is 231 MiB.\n\n                  total        used        free      shared  buff/cache   available\n    Mem:           7842        4523         137         841        3182        2170\n    Swap:          1023         792         231\n\nWhy is \"available\" memory checked as opposed to \"free\" memory?\nOn a healthy Linux system, \"free\" memory is supposed to be close to zero,\nbecause Linux uses all available physical memory to cache disk access.\nThese caches can be dropped any time the memory is needed for something\nelse.\n\nThe \"available\" memory accounts for that. It sums up all memory that\nis unused or can be freed immediately.\n\nNote that you need a recent version of\n`free` and Linux kernel 3.14+ to see the \"available\" column. If you have\na recent kernel, but an old version of `free`, you can get the value\nfrom `grep MemAvailable /proc/meminfo`.\n\nWhen both your available memory and free swap drop below 10% of the total memory available\nto userspace processes (=total-shared),\nit will send the `SIGTERM` signal to the process that uses the most memory in the opinion of\nthe kernel (`/proc/*/oom_score`).\n\n#### See also\n* [nohang](https://github.com/hakavlad/nohang), a similar project like earlyoom,\n  written in Python and with additional features and configuration options.\n* facebooks's pressure stall information (psi) [kernel patches](http://git.cmpxchg.org/cgit.cgi/linux-psi.git/)\n  and the accompanying [oomd](https://github.com/facebookincubator/oomd) userspace helper.\n  The patches are merged in Linux 4.20.\n\nWhy not trigger the kernel oom killer?\n--------------------------------------\nearlyoom does not use `echo f > /proc/sysrq-trigger` because:\n\nIn some kernel versions (tested on v4.0.5), triggering the kernel\noom killer manually does not work at all.\nThat is, it may only free some graphics\nmemory (that will be allocated immediately again) and not actually kill\nany process. [Here](https://gist.github.com/rfjakob/346b7dc611fc3cdf4011) you\ncan see how this looks like on my machine (Intel integrated graphics).\n\nThis problem has been fixed\nin Linux v5.17\n([commit f530243a](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f530243a172d2ff03f88d0056f838928d6445c6d))\n.\n\nLike the Linux kernel would, earlyoom finds its victim by reading through `/proc/*/oom_score`.\n\nHow much memory does earlyoom use?\n----------------------------------\nAbout `2 MiB` (`VmRSS`), though only `220 kiB` is private memory (`RssAnon`).\nThe rest is the libc library (`RssFile`) that is shared with other processes.\nAll memory is locked using `mlockall()` to make sure earlyoom does not slow down in low memory situations.\n\nDownload and compile\n--------------------\nCompiling yourself is easy:\n\n```bash\ngit clone https://github.com/rfjakob/earlyoom.git\ncd earlyoom\nmake\n```\n\nOptional: Run the integrated self-tests:\n```bash\nmake test\n```\n\nStart earlyoom automatically by registering it as a service:\n```bash\nsudo make install              # systemd\nsudo make install-initscript   # non-systemd\n```\n_Note that for systems with SELinux disabled (Ubuntu 19.04, Debian 9 ...) chcon warnings reporting failure to set the context can be safely ignored._\n\nFor Debian 10+ and Ubuntu 18.04+, there's a [Debian package](https://packages.debian.org/search?keywords=earlyoom):\n```bash\nsudo apt install earlyoom\n```\n\nFor Fedora and RHEL 8 with EPEL, there's a [Fedora package](https://src.fedoraproject.org/rpms/earlyoom/):\n```bash\nsudo dnf install earlyoom\nsudo systemctl enable --now earlyoom\n```\n\nFor Arch Linux, there's an [Arch Linux package](https://www.archlinux.org/packages/community/x86_64/earlyoom/):\n```bash\nsudo pacman -S earlyoom\nsudo systemctl enable --now earlyoom\n```\n\nAvailability in other distributions: see [repology page](https://repology.org/project/earlyoom/versions).\n\nUse\n---\nJust start the executable you have just compiled:\n\n```bash\n./earlyoom\n```\n\nIt will inform you how much memory and swap you have, what the minimum\nis, how much memory is available and how much swap is free.\n\n```\n./earlyoom\neearlyoom v1.8\nmem total: 23890 MiB, user mem total: 21701 MiB, swap total: 8191 MiB\nsending SIGTERM when mem avail <= 10.00% and swap free <= 10.00%,\n        SIGKILL when mem avail <=  5.00% and swap free <=  5.00%\nmem avail: 20012 of 21701 MiB (92.22%), swap free: 5251 of 8191 MiB (64.11%)\nmem avail: 20031 of 21721 MiB (92.22%), swap free: 5251 of 8191 MiB (64.11%)\nmem avail: 20033 of 21723 MiB (92.22%), swap free: 5251 of 8191 MiB (64.11%)\n[...]\n```\n\nIf the values drop below the minimum, processes are killed until it\nis above the minimum again. Every action is logged to stderr. If you are\nrunning earlyoom as a systemd service, you can view the last 10 lines\nusing\n\n```bash\nsystemctl status earlyoom\n```\n\n### Testing\n\nIn order to see `earlyoom` in action, create/simulate a memory leak and let `earlyoom` do what it does: \n\n```\ntail /dev/zero\n```\n\n### Checking Logs \n\nIf you need any further actions after a process is killed by `earlyoom` (such as sending emails), you can parse the logs by:\n\n```\nsudo journalctl -u earlyoom | grep sending\n```\nExample output for above test command (`tail /dev/zero`) will look like: \n\n```\nFeb 20 10:59:34 debian earlyoom[10231]: sending SIGTERM to process 7378 uid 1000 \"tail\": oom_score 156, VmRSS 4962 MiB\n```\n\n> For older versions of `earlyoom`, use: \n> \n>     sudo journalctl -u earlyoom | grep -iE \"(sending|killing)\"\n> \n\n### Notifications\n\nSince version 1.6, earlyoom can send notifications about killed processes\nvia the system d-bus. Pass `-n` to enable them.\n\nTo actually see the notifications in your GUI session, you need to have\n[systembus-notify](https://github.com/rfjakob/systembus-notify)\nrunning as your user.\n\nAdditionally, earlyoom can execute a script for each process killed, providing\ninformation about the process via the `EARLYOOM_PID`, `EARLYOOM_UID` and\n`EARLYOOM_NAME` environment variables. Pass `-N /path/to/script` to enable.\n\nWarning: In case of dryrun mode, the script will be executed in rapid\nsuccession, ensure you have some sort of rate-limit implemented.\n\n### Preferred Processes\n\nThe command-line flag `--prefer` specifies processes to prefer killing;\nlikewise, `--avoid` specifies\nprocesses to avoid killing. See https://github.com/rfjakob/earlyoom/blob/master/MANPAGE.md#--prefer-regex for details.\n\nConfiguration file\n------------------\n\nIf you are running earlyoom as a system service (through systemd or init.d), you can adjust its configuration via the file provided in `/etc/default/earlyoom`. The file already contains some examples in the comments, which you can use to build your own set of configuration based on the supported command line options, for example:\n\n```\nEARLYOOM_ARGS=\"-m 5 -r 60 --avoid '(^|/)(init|Xorg|ssh)$' --prefer '(^|/)(java|chromium)$'\"\n```\nAfter adjusting the file, simply restart the service to apply the changes. For example, for systemd:\n\n```bash\nsystemctl restart earlyoom\n```\n\nPlease note that this configuration file has no effect on earlyoom instances outside of systemd/init.d.\n\nCommand line options\n--------------------\n```\nearlyoom v1.8\nUsage: ./earlyoom [OPTION]...\n\n  -m PERCENT[,KILL_PERCENT] set available memory minimum to PERCENT of total\n                            (default 10 %).\n                            earlyoom sends SIGTERM once below PERCENT, then\n                            SIGKILL once below KILL_PERCENT (default PERCENT/2).\n  -s PERCENT[,KILL_PERCENT] set free swap minimum to PERCENT of total (default\n                            10 %).\n                            Note: both memory and swap must be below minimum for\n                            earlyoom to act.\n  -M SIZE[,KILL_SIZE]       set available memory minimum to SIZE KiB\n  -S SIZE[,KILL_SIZE]       set free swap minimum to SIZE KiB\n  -n                        enable d-bus notifications\n  -N /PATH/TO/SCRIPT        call script after oom kill\n  -g                        kill all processes within a process group\n  -d, --debug               enable debugging messages\n  -v                        print version information and exit\n  -r INTERVAL               memory report interval in seconds (default 1), set\n                            to 0 to disable completely\n  -p                        set niceness of earlyoom to -20 and oom_score_adj to\n                            -100\n  --ignore-root-user        do not kill processes owned by root\n  --sort-by-rss             find process with the largest rss (default oom_score)\n  --prefer REGEX            prefer to kill processes matching REGEX\n  --avoid REGEX             avoid killing processes matching REGEX\n  --ignore REGEX            ignore processes matching REGEX\n  --dryrun                  dry run (do not kill any processes)\n  --syslog                  use syslog instead of std streams\n  -h, --help                this help text\n\n```\n\nSee the [man page](MANPAGE.md) for details.\n\nContribute\n----------\nBug reports and pull requests are welcome via github. In particular, I am glad to\naccept\n\n* Use case reports and feedback\n\nImplementation Notes\n--------------------\n\n* We don't use [procps/libproc2](https://man7.org/linux/man-pages/man3/procps_pids.3.html) because\n  procps_pids_select(), for some reason, always parses /proc/$pid/status.\n  This is relatively expensive, and we don't need it.\n\nChangelog\n---------\n\n* v1.8.2, 2024-05-07\n  * Fixes in `earlyoom.service` systemd unit file\n    * Add `process_mrelease` to allowed syscalls ([commit](https://github.com/rfjakob/earlyoom/commit/c171b72ba217e923551bdde7e7f00ec5a0488b54))\n    * Fix `IPAddressDeny` syntax ([commit](e6c7978813413f3ee4181b8c8b11ae088d6e92a4))\n    * Allow `-p` ([commit](b41ebb2275e59781a8d55a764863417e1e0da5f1))\n\n* v1.8.1, 2024-04-17\n  * Fix trivial test failures caused by message rewording\n    ([commit](https://github.com/rfjakob/earlyoom/commit/bfde82c001c6e5ec11dfd6e5d13dcee9a9f01229))\n\n* v1.8, 2024-04-15\n  * Introduce `user mem total` / `meminfo_t.UserMemTotal` and calculate MemAvailablePercent based on it\n    ([commit](https://github.com/rfjakob/earlyoom/commit/459d76296d3d0a0b59ee1e2e48ad2271429de916),\n    [more info in man page](https://github.com/rfjakob/earlyoom/blob/master/MANPAGE.md#-m-percentkill_percent))\n  * Use `process_mrelease` ([#266](https://github.com/rfjakob/earlyoom/issues/266))\n  * Support `NO_COLOR` (https://no-color.org/)\n  * Don't get confused by processes with a zombie main thread ([commit](https://github.com/rfjakob/earlyoom/commit/e54650f0baf7cef7fb1fed3b02cb8e689c6544ea))\n  * Add `--sort-by-rss`, thanks @RanHuang! This will select a process to kill acc. to the largest RSS\n    instead of largest oom_score.\n  * The Gitlab CI testsuite now also runs on Amazon Linux 2 and Oracle Linux 7.\n\n* v1.7, 2022-03-05\n  * Add `-N` flag to run a script every time a process is killed ([commit](https://github.com/rfjakob/earlyoom/commit/afe03606f077a1a17e6fbc238400b3ce7a9ef2be),\n    [man page section](https://github.com/rfjakob/earlyoom/blob/master/MANPAGE.md#-n-pathtoscript))\n  * Add `-g` flag to kill whole process group ([#247](https://github.com/rfjakob/earlyoom/pull/247))\n  * Remove `-i` flag (ignored for compatibility), it does\n    not work properly on Linux kernels 5.9+ ([#234](https://github.com/rfjakob/earlyoom/issues/234))\n  * Hardening: Drop ambient capabilities on startup ([#234](https://github.com/rfjakob/earlyoom/pull/228))\n\n* v1.6.2, 2020-10-14\n  * Double-check memory situation before killing victim ([commit](https://github.com/rfjakob/earlyoom/commit/e34e0fcec5d9f60eb19a48a3ec2bab175818fdd8))\n  * Never terminate ourselves ([#205](https://github.com/rfjakob/earlyoom/issues/205))\n  * Dump buffer on /proc/meminfo conversion error ([#214](https://github.com/rfjakob/earlyoom/issues/214))\n\n* 1.6.1, 2020-07-07\n  * Clean up dbus-send zombie processes ([#200](https://github.com/rfjakob/earlyoom/issues/200))\n  * Skip processes with oom_score_adj=-1000 ([210](https://github.com/rfjakob/earlyoom/issues/210))\n\n* 1.6, 2020-04-11\n  * Replace old `notify-send` GUI notification logic with\n    `dbus-send` / [systembus-notify](https://github.com/rfjakob/systembus-notify)\n    ([#183](https://github.com/rfjakob/earlyoom/issues/183))\n    * `-n`/`-N` now enables the new logic\n    * You need to have [systembus-notify](https://github.com/rfjakob/systembus-notify) running\n      in your GUI session for notifications for work\n  * Handle `/proc` mounted with\n    [hidepid](https://github.com/rfjakob/earlyoom/wiki/proc-hidepid)\n    gracefully ([issue #184](https://github.com/rfjakob/earlyoom/issues/184))\n\n* v1.5, 2020-03-22\n  * `-p`: set oom_score_adj to `-100` instead of `-1000`\n    ([#170](https://github.com/rfjakob/earlyoom/issues/170))\n  * Allow using **both** `-M` and `-m`, and `-S` and `-s`. The\n    lower value (converted to percentages) will be used.\n  * Set memory report interval in `earlyoom.default` to 1 hour\n    instead of 1 minute ([#177](https://github.com/rfjakob/earlyoom/issues/177))\n\n* v1.4, 2020-03-01\n  * Make victim selection logic 50% faster by lazy-loading process attributes\n  * Log the user id `uid` of killed processes in addition to pid and name\n  * Color debug log in light grey\n  * Code clean-up\n    * Use block-local variables where possible\n    * Introduce PATH_LEN to replace several hardcoded buffer lengths\n  * Expand testsuite (`make test`)\n  * Run `cppcheck` when available\n  * Add unit-test benchmarks (`make bench`)\n  * Drop root privileges in systemd unit file `earlyoom.service`\n\n* v1.3.1, 2020-02-27\n  * Fix spurious testsuite failure on systems with a lot of RAM\n    ([issue #156](https://github.com/rfjakob/earlyoom/issues/156))\n\n* v1.3, 2019-05-26\n  * Wait for processes to actually exit when sending a signal\n    * This fixes the problem that earlyoom sometimes kills more than\n      one process when one would be enough\n      ([issue #121](https://github.com/rfjakob/earlyoom/issues/121))\n  * Be more liberal in what limits to accepts for SIGTERM and SIGKILL\n    ([issue #97](https://github.com/rfjakob/earlyoom/issues/97))\n    * Don't exit with a fatal error if SIGTERM limit < SIGKILL limit\n    * Allow zero SIGKILL limit\n  * Reformat startup output to make it clear that BOTH swap and mem must\n    be <= limit\n  * Add [notify_all_users.py](contrib/notify_all_users.py)\n    helper script\n  * Add [CODE_OF_CONDUCT.md](CODE_OF_CONDUCT.md) (Contributor Covenant 1.4)\n    ([#102](https://github.com/rfjakob/earlyoom/issues/102))\n  * Fix possibly truncated UTF8 app names in log output\n    ([#110](https://github.com/rfjakob/earlyoom/issues/110))\n\n* v1.2, 2018-10-28\n  * Implement adaptive sleep time (= adaptive poll rate) to lower CPU\n    usage further ([issue #61](https://github.com/rfjakob/earlyoom/issues/61))\n  * Remove option to use kernel oom-killer (`-k`, now ignored for compatibility)\n    ([issue #80](https://github.com/rfjakob/earlyoom/issues/80))\n  * Gracefully handle the case of swap being added or removed after earlyoom was started\n    ([issue 62](https://github.com/rfjakob/earlyoom/issues/62),\n    [commit](https://github.com/rfjakob/earlyoom/commit/88e58903fec70b105aebba39cd584add5e1d1532))\n  * Implement staged kill: first SIGTERM, then SIGKILL, with configurable limits\n    ([issue #67](https://github.com/rfjakob/earlyoom/issues/67))\n* v1.1, 2018-07-07\n  * Fix possible shell code injection through GUI notifications\n    ([commit](https://github.com/rfjakob/earlyoom/commit/ab79aa3895077676f50120f15e2bb22915446db9))\n  * On failure to kill any process, only sleep 1 second instead of 10\n    ([issue #74](https://github.com/rfjakob/earlyoom/issues/74))\n  * Send the GUI notification *after* killing, not before\n    ([issue #73](https://github.com/rfjakob/earlyoom/issues/73))\n  * Accept `--help` in addition to `-h`\n  * Fix wrong process name in log and in kill notification\n    ([commit 1](https://github.com/rfjakob/earlyoom/commit/7634c5b66dd7e9b88c6ebf0496c8777f3c4b3cc1),\n    [commit 2](https://github.com/rfjakob/earlyoom/commit/15679a3b768ea2df9b13a7d9b0c1e30bd1a450e6),\n    [issue #52](https://github.com/rfjakob/earlyoom/issues/52),\n    [issue #65](https://github.com/rfjakob/earlyoom/issues/65),\n    [issue #194](https://github.com/rfjakob/earlyoom/issues/194))\n  * Fix possible division by zero with `-S`\n    ([commit](https://github.com/rfjakob/earlyoom/commit/a0c4b26dfef8b38ef81c7b0b907442f344a3e115))\n* v1.0, 2018-01-28\n  * Add `--prefer` and `--avoid` options (@TomJohnZ)\n  * Add support for GUI notifications, add options `-n` and `-N`\n* v0.12: Add `-M` and `-S` options (@nailgun); add man page, parameterize Makefile (@yangfl)\n* v0.11: Fix undefined behavior in get_entry_fatal (missing return, [commit](https://github.com/rfjakob/earlyoom/commit/9251d25618946723eb8a829404ebf1a65d99dbb0))\n* v0.10: Allow to override Makefile's VERSION variable to make packaging easier,\n  add `-v` command-line option\n* v0.9: If oom_score of all processes is 0, use VmRss to find a victim\n* v0.8: Use a guesstimate if the kernel does not provide MemAvailable\n* v0.7: Select victim by oom_score instead of VmRSS, add options `-i` and `-d`\n* v0.6: Add command-line options `-m`, `-s`, `-k`\n* v0.5: Add swap support\n* v0.4: Add SysV init script (thanks [@joeytwiddle](https://github.com/joeytwiddle)), use the new `MemAvailable` from `/proc/meminfo`\n  (needs Linux 3.14+, [commit][4])\n* v0.2: Add systemd unit file\n* v0.1: Initial release\n\n[1]: http://www.freelists.org/post/procps/library-properly-handle-memory-used-by-tmpfs\n[2]: http://superuser.com/questions/406101/is-it-possible-to-make-the-oom-killer-intervent-earlier\n[3]: http://unix.stackexchange.com/questions/38507/is-it-possible-to-trigger-oom-killer-on-forced-swapping\n[4]: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773\n[5]: https://www.reddit.com/r/linux/comments/56r4xj/why_are_low_memory_conditions_handled_so_badly/\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "earlyoom.default",
          "type": "blob",
          "size": 0.5498046875,
          "content": "# Default settings for earlyoom. This file is sourced by /bin/sh from\n# /etc/init.d/earlyoom or by systemd from earlyoom.service.\n\n# Options to pass to earlyoom\nEARLYOOM_ARGS=\"-r 3600\"\n\n# Examples:\n\n# Print memory report every minute instead of every hour\n# EARLYOOM_ARGS=\"-r 60\"\n\n# Available minimum memory 5%\n# EARLYOOM_ARGS=\"-m 5\"\n\n# Available minimum memory 15% and free minimum swap 5%\n# EARLYOOM_ARGS=\"-m 15 -s 5\"\n\n# Avoid killing processes whose name matches this regexp\n# EARLYOOM_ARGS=\"--avoid '(^|/)(init|X|sshd|firefox)$'\"\n\n# See more at `earlyoom -h'\n"
        },
        {
          "name": "earlyoom.initscript.in",
          "type": "blob",
          "size": 4.42578125,
          "content": "#! /bin/sh\n### BEGIN INIT INFO\n# Provides:          earlyoom\n# Required-Start:    $remote_fs $syslog\n# Required-Stop:     $remote_fs $syslog\n# Default-Start:     2 3 4 5\n# Default-Stop:      0 1 6\n# Short-Description: Early OOM Killer\n# Description:       A userspace service that will kill the largest process\n#                    (by VmRSS residential size) when free RAM drops below 10%.\n### END INIT INFO\n\n# Author: https://github.com/rfjakob\n\n# Do NOT \"set -e\"\n\n# PATH should only include /usr/* if it runs after the mountnfs.sh script\nPATH=/sbin:/usr/sbin:/bin:/usr/bin\nDESC=\"Early OOM Daemon\"\nNAME=earlyoom\nDAEMON=:TARGET:/$NAME\n#DAEMON_ARGS=\"--options args\"\nLOGFILE=/var/log/$NAME.log\nPIDFILE=/var/run/$NAME.pid\nSCRIPTNAME=:SYSCONFDIR:/init.d/$NAME\n\n# Exit if the package is not installed\n[ -x \"$DAEMON\" ] || exit 0\n\n# Read configuration variable file if it is present\n[ -r :SYSCONFDIR:/default/$NAME ] && . :SYSCONFDIR:/default/$NAME\n\n# Load the VERBOSE setting and other rcS variables\n. /lib/init/vars.sh\n\n# Define LSB log_* functions.\n# Depend on lsb-base (>= 3.2-14) to ensure that this file is present\n# and status_of_proc is working.\n. /lib/lsb/init-functions\n\n#\n# Function that starts the daemon/service\n#\ndo_start()\n{\n\t# Return\n\t#   0 if daemon has been started\n\t#   1 if daemon was already running\n\t#   2 if daemon could not be started\n\tstart-stop-daemon --start --quiet --background --pidfile $PIDFILE --exec /bin/bash --test > /dev/null \\\n\t\t|| return 1\n\tstart-stop-daemon --start --quiet --background --pidfile $PIDFILE --exec /bin/bash -- -c \"exec $DAEMON $EARLYOOM_ARGS 2> \\\"$LOGFILE\\\"\" \\\n\t\t|| return 2\n\t# Add code here, if necessary, that waits for the process to be ready\n\t# to handle requests from services started subsequently which depend\n\t# on this one.  As a last resort, sleep for some time.\n}\n\n#\n# Function that stops the daemon/service\n#\ndo_stop()\n{\n\t# Return\n\t#   0 if daemon has been stopped\n\t#   1 if daemon was already stopped\n\t#   2 if daemon could not be stopped\n\t#   other if a failure occurred\n\tstart-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile $PIDFILE --name $NAME\n\tRETVAL=\"$?\"\n\t[ \"$RETVAL\" = 2 ] && return 2\n\n\t# Wait for children to finish too if this is a daemon that forks\n\t# and if the daemon is only ever run from this initscript.\n\t# If the above conditions are not satisfied then add some other code\n\t# that waits for the process to drop all resources that could be\n\t# needed by services started subsequently.  A last resort is to\n\t# sleep for some time.\n\t#\n\t# We may be able to skip this, if we are not concerned about being attached\n\t# to any resources.\n\t# This was blocking until the timeout, so I replaced 0/ with TERM/ and now\n\t# it completes immediately.\n\tstart-stop-daemon --stop --quiet --oknodo --retry=TERM/30/KILL/5 --exec $DAEMON\n\n\t[ \"$?\" = 2 ] && return 2\n\t# Many daemons don't delete their pidfiles when they exit.\n\trm -f $PIDFILE\n\treturn \"$RETVAL\"\n}\n\n#\n# Function that sends a SIGHUP to the daemon/service\n#\n#do_reload() {\n\t#\n\t# If the daemon can reload its configuration without\n\t# restarting (for example, when it is sent a SIGHUP),\n\t# then implement that here.\n\t#\n\t#start-stop-daemon --stop --signal 1 --quiet --pidfile $PIDFILE --name $NAME\n\t#return 0\n#}\n\ncase \"$1\" in\n  start)\n\t[ \"$VERBOSE\" != no ] && log_daemon_msg \"Starting $DESC\" \"$NAME\"\n\tdo_start\n\tcase \"$?\" in\n\t\t0|1) [ \"$VERBOSE\" != no ] && log_end_msg 0 ;;\n\t\t2) [ \"$VERBOSE\" != no ] && log_end_msg 1 ;;\n\tesac\n\t;;\n  stop)\n\t[ \"$VERBOSE\" != no ] && log_daemon_msg \"Stopping $DESC\" \"$NAME\"\n\tdo_stop\n\tcase \"$?\" in\n\t\t0|1) [ \"$VERBOSE\" != no ] && log_end_msg 0 ;;\n\t\t2) [ \"$VERBOSE\" != no ] && log_end_msg 1 ;;\n\tesac\n\t;;\n  status)\n       status_of_proc \"$DAEMON\" \"$NAME\" && exit 0 || exit $?\n       ;;\n  #reload|force-reload)\n\t#\n\t# If do_reload() is not implemented then leave this commented out\n\t# and leave 'force-reload' as an alias for 'restart'.\n\t#\n\t#log_daemon_msg \"Reloading $DESC\" \"$NAME\"\n\t#do_reload\n\t#log_end_msg $?\n\t#;;\n  restart|force-reload)\n\t#\n\t# If the \"reload\" option is implemented then remove the\n\t# 'force-reload' alias\n\t#\n\tlog_daemon_msg \"Restarting $DESC\" \"$NAME\"\n\tdo_stop\n\tcase \"$?\" in\n\t  0|1)\n\t\tdo_start\n\t\tcase \"$?\" in\n\t\t\t0) log_end_msg 0 ;;\n\t\t\t1) log_end_msg 1 ;; # Old process is still running\n\t\t\t*) log_end_msg 1 ;; # Failed to start\n\t\tesac\n\t\t;;\n\t  *)\n\t  \t# Failed to stop\n\t\tlog_end_msg 1\n\t\t;;\n\tesac\n\t;;\n  *)\n\t#echo \"Usage: $SCRIPTNAME {start|stop|restart|reload|force-reload}\" >&2\n\techo \"Usage: $SCRIPTNAME {start|stop|status|restart|force-reload}\" >&2\n\texit 3\n\t;;\nesac\n\n:\n"
        },
        {
          "name": "earlyoom.service.in",
          "type": "blob",
          "size": 1.30859375,
          "content": "[Unit]\nDescription=Early OOM Daemon\nDocumentation=man:earlyoom(1) https://github.com/rfjakob/earlyoom\n\n[Service]\nEnvironmentFile=-:SYSCONFDIR:/default/earlyoom\nExecStart=:TARGET:/earlyoom $EARLYOOM_ARGS\n# Allow killing processes and calling mlockall()\nAmbientCapabilities=CAP_KILL CAP_IPC_LOCK\nCapabilityBoundingSet=CAP_KILL CAP_IPC_LOCK\n# Give priority to our process\nNice=-20\n# Avoid getting killed by OOM\nOOMScoreAdjust=-100\n# earlyoom never exits on it's own, so have systemd\n# restart it should it get killed for some reason.\nRestart=always\n# set memory limits and max tasks number\nTasksMax=10\nMemoryMax=50M\n\n# Hardening. Deny everything we don't use.\n\n# Run as an unprivileged user with random user id.\nDynamicUser=true\n# We don't need write access anywhere.\nProtectSystem=strict\n# We don't need /home at all, make it inaccessible.\nProtectHome=true\nPrivateDevices=true\nProtectClock=true\nProtectHostname=true\nProtectKernelLogs=true\nProtectKernelModules=true\nProtectKernelTunables=true\nProtectControlGroups=true\nRestrictNamespaces=true\nRestrictRealtime=true\nLockPersonality=true\nPrivateNetwork=true\nIPAddressDeny=any\n\n# Unix socket is used by dbus-send.\nRestrictAddressFamilies=AF_UNIX\n\nSystemCallArchitectures=native\nSystemCallFilter=@system-service process_mrelease\nSystemCallFilter=~@privileged\n\n[Install]\nWantedBy=multi-user.target\n"
        },
        {
          "name": "globals.c",
          "type": "blob",
          "size": 0.1240234375,
          "content": "int enable_debug = 0;\n\n// This variable exists so the tests can point\n// it to a mockup proc dir\nchar* procdir_path = \"/proc\";\n"
        },
        {
          "name": "globals.h",
          "type": "blob",
          "size": 0.1298828125,
          "content": "/* SPDX-License-Identifier: MIT */\n#ifndef GLOBALS_H\n#define GLOBALS_H\n\nextern int enable_debug;\n\nextern char* procdir_path;\n\n#endif\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.15234375,
          "content": "module github.com/rfjakob/earlyoom\n\ngo 1.16\n\nrequire (\n\tgithub.com/c9s/goprocinfo v0.0.0-20210130143923-c95fcf8c64a8 // indirect\n\tgolang.org/x/sys v0.6.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.3671875,
          "content": "github.com/c9s/goprocinfo v0.0.0-20210130143923-c95fcf8c64a8 h1:SjZ2GvvOononHOpK84APFuMvxqsk3tEIaKH/z4Rpu3g=\ngithub.com/c9s/goprocinfo v0.0.0-20210130143923-c95fcf8c64a8/go.mod h1:uEyr4WpAH4hio6LFriaPkL938XnrvLpNPmQHBdrmbIE=\ngolang.org/x/sys v0.6.0 h1:MVltZSvRTcU2ljQOhs94SXPftV6DCNnZViHeQps87pQ=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n"
        },
        {
          "name": "kill.c",
          "type": "blob",
          "size": 17.62890625,
          "content": "// SPDX-License-Identifier: MIT\n\n/* Kill the most memory-hungy process */\n\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/syscall.h> /* Definition of SYS_* constants */\n#include <time.h>\n#include <unistd.h>\n\n#include \"globals.h\"\n#include \"kill.h\"\n#include \"meminfo.h\"\n#include \"msg.h\"\n\n// Processes matching \"--prefer REGEX\" get OOM_SCORE_PREFER added to their oom_score\n#define OOM_SCORE_PREFER 300\n// Processes matching \"--avoid REGEX\" get OOM_SCORE_AVOID added to their oom_score\n#define OOM_SCORE_AVOID -300\n\n// Processes matching \"--prefer REGEX\" get VMRSS_PREFER added to their VmRSSkiB\n#define VMRSS_PREFER 3145728\n// Processes matching \"--avoid REGEX\" get VMRSS_AVOID added to their VmRSSkiB\n#define VMRSS_AVOID -3145728\n\n// Buffer size for UID/GID/PID string conversion\n#define UID_BUFSIZ 128\n// At most 1 notification per second when --dryrun is active\n#define NOTIFY_RATELIMIT 1\n\nstatic bool isnumeric(char* str)\n{\n    int i = 0;\n\n    // Empty string is not numeric\n    if (str[0] == 0)\n        return false;\n\n    while (1) {\n        if (str[i] == 0) // End of string\n            return true;\n\n        if (isdigit(str[i]) == 0)\n            return false;\n\n        i++;\n    }\n}\n\nstatic void notify_dbus(const char* summary, const char* body)\n{\n    int pid = fork();\n    if (pid > 0) {\n        // parent\n        return;\n    }\n    char summary2[1024] = { 0 };\n    snprintf(summary2, sizeof(summary2), \"string:%s\", summary);\n    char body2[1024] = \"string:\";\n    if (body != NULL) {\n        snprintf(body2, sizeof(body2), \"string:%s\", body);\n    }\n    // Complete command line looks like this:\n    // dbus-send --system / net.nuetzlich.SystemNotifications.Notify 'string:summary text' 'string:and body text'\n    execl(\"/usr/bin/dbus-send\", \"dbus-send\", \"--system\", \"/\", \"net.nuetzlich.SystemNotifications.Notify\",\n        summary2, body2, NULL);\n    warn(\"%s: exec failed: %s\\n\", __func__, strerror(errno));\n    exit(1);\n}\n\nstatic void notify_ext(const char* script, const procinfo_t* victim)\n{\n    pid_t pid1 = fork();\n\n    if (pid1 == -1) {\n        warn(\"notify_ext: fork() returned -1: %s\\n\", strerror(errno));\n        return;\n    } else if (pid1 != 0) {\n        return;\n    }\n\n    char pid_str[UID_BUFSIZ] = { 0 };\n    char uid_str[UID_BUFSIZ] = { 0 };\n\n    snprintf(pid_str, UID_BUFSIZ, \"%d\", victim->pid);\n    snprintf(uid_str, UID_BUFSIZ, \"%d\", victim->uid);\n\n    setenv(\"EARLYOOM_PID\", pid_str, 1);\n    setenv(\"EARLYOOM_UID\", uid_str, 1);\n    setenv(\"EARLYOOM_NAME\", victim->name, 1);\n    setenv(\"EARLYOOM_CMDLINE\", victim->cmdline, 1);\n\n    execl(script, script, NULL);\n    warn(\"%s: exec %s failed: %s\\n\", __func__, script, strerror(errno));\n    exit(1);\n}\n\nstatic void notify_process_killed(const poll_loop_args_t* args, const procinfo_t* victim)\n{\n    // Dry run can cause the notify function to be called on each poll as\n    // nothing is immediately done to change the situation we don't know how\n    // heavy the notify script is so avoid spamming it\n    if (args->dryrun) {\n        static struct timespec prev_notify = { 0 };\n        struct timespec cur_time = { 0 };\n\n        int ret = clock_gettime(CLOCK_MONOTONIC, &cur_time);\n        if (ret == -1) {\n            warn(\"%s: clock_gettime failed: %s\\n\", __func__, strerror(errno));\n            return;\n        }\n        // Ignores nanoseconds, but good enough here\n        if (cur_time.tv_sec - prev_notify.tv_sec < NOTIFY_RATELIMIT) {\n            // Too soon\n            debug(\"%s: rate limit hit, skipping notifications this time\\n\", __func__);\n            return;\n        }\n        prev_notify = cur_time;\n    }\n\n    if (args->notify) {\n        char notif_args[PATH_MAX + 1000];\n        snprintf(notif_args, sizeof(notif_args),\n            \"Low memory! Killing process %d %s\", victim->pid, victim->name);\n        notify_dbus(\"earlyoom\", notif_args);\n    }\n    if (args->notify_ext) {\n        notify_ext(args->notify_ext, victim);\n    }\n}\n\n#if defined(__NR_pidfd_open) && defined(__NR_process_mrelease)\n#define HAVE_MRELEASE\n#else\n#warning process_mrelease is not supported. earlyoom will still work but with degraded performance.\n#endif\n\n// kill_release kills a process and calls process_mrelease to\n// release the memory as quickly as possible.\n//\n// See https://lwn.net/Articles/864184/ for details on process_mrelease.\nint kill_release(const pid_t pid, const int pidfd, const int sig)\n{\n    int res = kill(pid, sig);\n    if (res != 0) {\n        return res;\n    }\n    // Can't do process_mrelease without a pidfd.\n    if (pidfd < 0) {\n        return 0;\n    }\n#if defined(HAVE_MRELEASE)\n    res = (int)syscall(__NR_process_mrelease, pidfd, 0);\n    if (res != 0) {\n        warn(\"%s: pid=%d: process_mrelease pidfd=%d failed: %s\\n\", __func__, pid, pidfd, strerror(errno));\n    } else {\n        info(\"%s: pid=%d: process_mrelease pidfd=%d success\\n\", __func__, pid, pidfd);\n    }\n#endif\n    // Return 0 regardless of process_mrelease outcome\n    return 0;\n}\n\n/*\n * Send the selected signal to \"pid\" and wait for the process to exit\n * (max 10 seconds)\n */\nint kill_wait(const poll_loop_args_t* args, pid_t pid, int sig)\n{\n    const unsigned poll_ms = 100;\n    int pidfd = -1;\n\n    if (args->dryrun && sig != 0) {\n        warn(\"dryrun, not actually sending any signal\\n\");\n        return 0;\n    }\n\n    if (args->kill_process_group) {\n        int res = getpgid(pid);\n        if (res < 0) {\n            return res;\n        }\n        pid = -res;\n        warn(\"killing whole process group %d (-g flag is active)\\n\", res);\n    }\n\n#if defined(HAVE_MRELEASE)\n    // Open the pidfd *before* calling kill().\n    if (!args->kill_process_group && sig != 0) {\n        pidfd = (int)syscall(__NR_pidfd_open, pid, 0);\n        if (pidfd < 0) {\n            warn(\"%s pid %d: error opening pidfd: %s\\n\", __func__, pid, strerror(errno));\n        }\n    }\n#else\n    warn(\"%s pid %d: system does not support process_mrelease, skipping\\n\", __func__, pid);\n#endif\n\n    int res = kill_release(pid, pidfd, sig);\n    if (res != 0) {\n        goto out_close;\n    }\n\n    /* signal 0 does not kill the process. Don't wait for it to exit */\n    if (sig == 0) {\n        goto out_close;\n    }\n\n    struct timespec t0 = { 0 };\n    clock_gettime(CLOCK_MONOTONIC, &t0);\n\n    for (unsigned i = 0; i < 100; i++) {\n        struct timespec t1 = { 0 };\n        clock_gettime(CLOCK_MONOTONIC, &t1);\n        float secs = (float)(t1.tv_sec - t0.tv_sec) + (float)(t1.tv_nsec - t0.tv_nsec) / (float)1e9;\n\n        // We have sent SIGTERM but now have dropped below SIGKILL limits.\n        // Escalate to SIGKILL.\n        if (sig != SIGKILL) {\n            meminfo_t m = parse_meminfo();\n            print_mem_stats(debug, m);\n            if (m.MemAvailablePercent <= args->mem_kill_percent && m.SwapFreePercent <= args->swap_kill_percent) {\n                sig = SIGKILL;\n                warn(\"escalating to SIGKILL after %.3f seconds\\n\", secs);\n                res = kill_release(pid, pidfd, sig);\n                if (res != 0) {\n                    goto out_close;\n                }\n            }\n        } else if (enable_debug) {\n            meminfo_t m = parse_meminfo();\n            print_mem_stats(info, m);\n        }\n        if (!is_alive(pid)) {\n            warn(\"process %d exited after %.3f seconds\\n\", pid, secs);\n            goto out_close;\n        }\n        struct timespec req = { .tv_sec = (time_t)(poll_ms / 1000), .tv_nsec = (poll_ms % 1000) * 1000000 };\n        nanosleep(&req, NULL);\n    }\n\n    res = -1;\n    errno = ETIME;\n    warn(\"process %d did not exit\\n\", pid);\n\nout_close:\n    if (pidfd >= 0) {\n        int saved_errno = errno;\n        if (close(pidfd)) {\n            warn(\"%s pid %d: error closing pidfd %d: %s\\n\", __func__, pid, pidfd, strerror(errno));\n        }\n        errno = saved_errno;\n    }\n    return res;\n}\n\n// is_larger finds out if the process with pid `cur->pid` uses more memory\n// than our current `victim`.\n// In the process, it fills the `cur` structure. It does so lazily, meaning\n// it only fills the fields it needs to make a decision.\nbool is_larger(const poll_loop_args_t* args, const procinfo_t* victim, procinfo_t* cur)\n{\n    if (cur->pid <= 2) {\n        // Let's not kill init or kthreadd.\n        return false;\n    }\n\n    // Ignore processes owned by root user?\n    if (args->ignore_root_user) {\n        int res = get_uid(cur->pid);\n        if (res < 0) {\n            debug(\"%s: pid %d: error reading uid: %s\\n\", __func__, cur->pid, strerror(-res));\n            return false;\n        }\n        cur->uid = res;\n\n        if (cur->uid == 0) {\n            return false;\n        }\n    }\n\n    {\n        bool res = parse_proc_pid_stat(&cur->stat, cur->pid);\n        if (!res) {\n            debug(\"%s: pid %d: error reading stat\\n\", __func__, cur->pid);\n            return false;\n        }\n        const long page_size = sysconf(_SC_PAGESIZE);\n        cur->VmRSSkiB = cur->stat.rss * page_size / 1024;\n    }\n\n    // A pid is a kernel thread if it's pid or ppid is 2.\n    // At least that's what procs does:\n    // https://github.com/warmchang/procps/blob/d173f5d6db746e3f252a6182aa1906a292fc200f/library/readproc.c#L1325\n    //\n    // The check for pid == 2 has already been done at the top.\n    if (cur->stat.ppid == 2) {\n        return false;\n    }\n\n    {\n        int res = get_oom_score(cur->pid);\n        if (res < 0) {\n            debug(\"%s: pid %d: error reading oom_score: %s\\n\", __func__, cur->pid, strerror(-res));\n            return false;\n        }\n        cur->oom_score = res;\n    }\n\n    if ((args->prefer_regex || args->avoid_regex || args->ignore_regex)) {\n        int res = get_comm(cur->pid, cur->name, sizeof(cur->name));\n        if (res < 0) {\n            debug(\"%s: pid %d: error reading process name: %s\\n\", __func__, cur->pid, strerror(-res));\n            return false;\n        }\n        if (args->prefer_regex && regexec(args->prefer_regex, cur->name, (size_t)0, NULL, 0) == 0) {\n            if (args->sort_by_rss) {\n                cur->VmRSSkiB += VMRSS_PREFER;\n            } else {\n                cur->oom_score += OOM_SCORE_PREFER;\n            }\n        }\n        if (args->avoid_regex && regexec(args->avoid_regex, cur->name, (size_t)0, NULL, 0) == 0) {\n            if (args->sort_by_rss) {\n                cur->VmRSSkiB += VMRSS_AVOID;\n            } else {\n                cur->oom_score += OOM_SCORE_AVOID;\n            }\n        }\n        if (args->ignore_regex && regexec(args->ignore_regex, cur->name, (size_t)0, NULL, 0) == 0) {\n            return false;\n        }\n    }\n\n    // find process with the largest rss\n    if (args->sort_by_rss) {\n        // Case 1: neither victim nor cur have rss=0 (zombie main thread).\n        // This is the usual case.\n        if (cur->VmRSSkiB > 0 && victim->VmRSSkiB > 0) {\n            if (cur->VmRSSkiB < victim->VmRSSkiB) {\n                return false;\n            }\n            if (cur->VmRSSkiB == victim->VmRSSkiB && cur->oom_score <= victim->oom_score) {\n                return false;\n            }\n        }\n        // Case 2: one (or both) have rss=0 (zombie main thread)\n        else {\n            if (cur->VmRSSkiB == 0) {\n                // only print the warning when the zombie is first seen, i.e. as \"cur\"\n                get_comm(cur->pid, cur->name, sizeof(cur->name));\n                warn(\"%s: pid %d \\\"%s\\\": rss=0 but oom_score=%d. Zombie main thread? Using oom_score for this process.\\n\",\n                    __func__, cur->pid, cur->name, cur->oom_score);\n            }\n            if (cur->oom_score < victim->oom_score) {\n                return false;\n            }\n            if (cur->oom_score == victim->oom_score && cur->VmRSSkiB <= victim->VmRSSkiB) {\n                return false;\n            }\n        }\n    } else {\n        /* find process with the largest oom_score */\n        if (cur->oom_score < victim->oom_score) {\n            return false;\n        }\n\n        if (cur->oom_score == victim->oom_score && cur->VmRSSkiB <= victim->VmRSSkiB) {\n            return false;\n        }\n    }\n\n    // Skip processes with oom_score_adj = -1000, like the\n    // kernel oom killer would.\n    {\n        int res = get_oom_score_adj(cur->pid, &cur->oom_score_adj);\n        if (res < 0) {\n            debug(\"%s: pid %d: error reading oom_score_adj: %s\\n\", __func__, cur->pid, strerror(-res));\n            return false;\n        }\n        if (cur->oom_score_adj == -1000) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Fill the fields in `cur` that are not required for the kill decision.\n// Used to log details about the selected process.\nvoid fill_informative_fields(procinfo_t* cur)\n{\n    if (strlen(cur->name) == 0) {\n        int res = get_comm(cur->pid, cur->name, sizeof(cur->name));\n        if (res < 0) {\n            debug(\"%s: pid %d: error reading process name: %s\\n\", __func__, cur->pid, strerror(-res));\n        }\n    }\n    if (strlen(cur->cmdline) == 0) {\n        int res = get_cmdline(cur->pid, cur->cmdline, sizeof(cur->cmdline));\n        if (res < 0) {\n            debug(\"%s: pid %d: error reading process cmdline: %s\\n\", __func__, cur->pid, strerror(-res));\n        }\n    }\n    if (cur->uid == PROCINFO_FIELD_NOT_SET) {\n        int res = get_uid(cur->pid);\n        if (res < 0) {\n            debug(\"%s: pid %d: error reading uid: %s\\n\", __func__, cur->pid, strerror(-res));\n        } else {\n            cur->uid = res;\n        }\n    }\n}\n\n// debug_print_procinfo pretty-prints the process information in `cur`.\nvoid debug_print_procinfo(procinfo_t* cur)\n{\n    if (!enable_debug) {\n        return;\n    }\n    fill_informative_fields(cur);\n    debug(\"%5d %9d %7lld %5d %13d \\\"%s\\\"\",\n        cur->pid, cur->oom_score, cur->VmRSSkiB, cur->uid, cur->oom_score_adj, cur->name);\n}\n\nvoid debug_print_procinfo_header()\n{\n    debug(\"  PID OOM_SCORE  RSSkiB   UID OOM_SCORE_ADJ  COMM\\n\");\n}\n\n/*\n * Find the process with the largest oom_score or rss(when flag --sort-by-rss is set).\n */\nprocinfo_t find_largest_process(const poll_loop_args_t* args)\n{\n    DIR* procdir = opendir(procdir_path);\n    if (procdir == NULL) {\n        fatal(5, \"%s: could not open /proc: %s\", __func__, strerror(errno));\n    }\n\n    struct timespec t0 = { 0 }, t1 = { 0 };\n    if (enable_debug) {\n        clock_gettime(CLOCK_MONOTONIC, &t0);\n    }\n\n    debug_print_procinfo_header();\n\n    const procinfo_t empty_procinfo = {\n        .pid = PROCINFO_FIELD_NOT_SET,\n        .uid = PROCINFO_FIELD_NOT_SET,\n        .oom_score = PROCINFO_FIELD_NOT_SET,\n        .oom_score_adj = PROCINFO_FIELD_NOT_SET,\n        .VmRSSkiB = PROCINFO_FIELD_NOT_SET,\n        /* omitted fields are set to zero */\n    };\n\n    procinfo_t victim = empty_procinfo;\n    while (1) {\n        errno = 0;\n        struct dirent* d = readdir(procdir);\n        if (d == NULL) {\n            if (errno != 0)\n                warn(\"%s: readdir error: %s\", __func__, strerror(errno));\n            break;\n        }\n\n        // proc contains lots of directories not related to processes,\n        // skip them\n        if (!isnumeric(d->d_name))\n            continue;\n\n        procinfo_t cur = empty_procinfo;\n        cur.pid = (int)strtol(d->d_name, NULL, 10);\n\n        bool larger = is_larger(args, &victim, &cur);\n\n        debug_print_procinfo(&cur);\n\n        if (larger) {\n            debug(\" <--- new victim\\n\");\n            victim = cur;\n        } else {\n            debug(\"\\n\");\n        }\n    }\n    closedir(procdir);\n\n    if (enable_debug) {\n        clock_gettime(CLOCK_MONOTONIC, &t1);\n        long delta = (t1.tv_sec - t0.tv_sec) * 1000000 + (t1.tv_nsec - t0.tv_nsec) / 1000;\n        debug(\"selecting victim took %ld.%03ld ms\\n\", delta / 1000, delta % 1000);\n    }\n\n    if (victim.pid == getpid()) {\n        warn(\"%s: selected myself (pid %d). Do you use hidpid? See https://github.com/rfjakob/earlyoom/wiki/proc-hidepid\\n\",\n            __func__, victim.pid);\n        // zero victim struct\n        victim = (const procinfo_t) { 0 };\n    }\n\n    if (victim.pid >= 0) {\n        // We will pretty-print the victim later, so get all the info.\n        fill_informative_fields(&victim);\n    }\n\n    return victim;\n}\n\n/*\n * Kill the victim process, wait for it to exit, send a gui notification\n * (if enabled).\n */\nvoid kill_process(const poll_loop_args_t* args, int sig, const procinfo_t* victim)\n{\n    if (victim->pid <= 0) {\n        warn(\"Could not find a process to kill. Sleeping 1 second.\\n\");\n        if (args->notify) {\n            notify_dbus(\"earlyoom\", \"Error: Could not find a process to kill. Sleeping 1 second.\");\n        }\n        sleep(1);\n        return;\n    }\n\n    char* sig_name = \"?\";\n    if (sig == SIGTERM) {\n        sig_name = \"SIGTERM\";\n    } else if (sig == SIGKILL) {\n        sig_name = \"SIGKILL\";\n    } else if (sig == 0) {\n        sig_name = \"0 (no-op signal)\";\n    }\n    // sig == 0 is used as a self-test during startup. Don't notify the user.\n    if (sig != 0 || enable_debug) {\n        warn(\"sending %s to process %d uid %d \\\"%s\\\": oom_score %d, VmRSS %lld MiB, cmdline \\\"%s\\\"\\n\",\n            sig_name, victim->pid, victim->uid, victim->name, victim->oom_score, victim->VmRSSkiB / 1024,\n            victim->cmdline);\n    }\n\n    int res = kill_wait(args, victim->pid, sig);\n    int saved_errno = errno;\n\n    // Send the GUI notification AFTER killing a process. This makes it more likely\n    // that there is enough memory to spawn the notification helper.\n    if (sig != 0) {\n        notify_process_killed(args, victim);\n    }\n\n    if (sig == 0) {\n        return;\n    }\n\n    if (res != 0) {\n        warn(\"kill failed: %s\\n\", strerror(saved_errno));\n        if (args->notify) {\n            notify_dbus(\"earlyoom\", \"Error: Failed to kill process\");\n        }\n        // Killing the process may have failed because we are not running as root.\n        // In that case, trying again in 100ms will just yield the same error.\n        // Throttle ourselves to not spam the log.\n        if (saved_errno == EPERM) {\n            warn(\"sleeping 1 second\\n\");\n            sleep(1);\n        }\n    }\n}\n"
        },
        {
          "name": "kill.h",
          "type": "blob",
          "size": 1.291015625,
          "content": "/* SPDX-License-Identifier: MIT */\n#ifndef KILL_H\n#define KILL_H\n\n#include <regex.h>\n#include <stdbool.h>\n\n#include \"meminfo.h\"\n\ntypedef struct {\n    /* if the available memory AND swap goes below these percentages,\n     * we start killing processes */\n    double mem_term_percent;\n    double mem_kill_percent;\n    double swap_term_percent;\n    double swap_kill_percent;\n    /* send d-bus notifications? */\n    bool notify;\n    /* Path to script for programmatic notifications (or NULL) */\n    char* notify_ext;\n    /* kill all processes within a process group */\n    bool kill_process_group;\n    /* do not kill processes owned by root */\n    bool ignore_root_user;\n    /* find process with the largest rss */\n    bool sort_by_rss;\n    /* prefer/avoid killing these processes. NULL = no-op. */\n    regex_t* prefer_regex;\n    regex_t* avoid_regex;\n    /* will ignore these processes. NULL = no-op. */\n    regex_t* ignore_regex;\n    /* memory report interval, in milliseconds */\n    int report_interval_ms;\n    /* Flag --dryrun was passed */\n    bool dryrun;\n} poll_loop_args_t;\n\nvoid kill_process(const poll_loop_args_t* args, int sig, const procinfo_t* victim);\nprocinfo_t find_largest_process(const poll_loop_args_t* args);\nbool is_larger(const poll_loop_args_t* args, const procinfo_t* victim, procinfo_t* cur);\n\n#endif\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 19.4404296875,
          "content": "// SPDX-License-Identifier: MIT\n\n/* Check available memory and swap in a loop and start killing\n * processes if they get too low */\n\n#include <errno.h>\n#include <getopt.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/prctl.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"globals.h\"\n#include \"kill.h\"\n#include \"meminfo.h\"\n#include \"msg.h\"\n\n/* Don't fail compilation if the user has an old glibc that\n * does not define MCL_ONFAULT. The kernel may still be recent\n * enough to support the flag.\n */\n#ifndef MCL_ONFAULT\n#define MCL_ONFAULT 4\n#endif\n\n#ifndef VERSION\n#define VERSION \"*** unknown version ***\"\n#endif\n\n/* Arbitrary identifiers for long options that do not have a short\n * version */\nenum {\n    LONG_OPT_PREFER = 513,\n    LONG_OPT_AVOID,\n    LONG_OPT_DRYRUN,\n    LONG_OPT_IGNORE,\n    LONG_OPT_IGNORE_ROOT,\n    LONG_OPT_USE_SYSLOG,\n    LONG_OPT_SORT_BY_RSS,\n};\n\nstatic int set_oom_score_adj(int);\nstatic void poll_loop(const poll_loop_args_t* args);\n\n// Prevent Golang / Cgo name collision when the test suite runs -\n// Cgo generates it's own main function.\n#ifdef CGO\n#define main main2\n#endif\n\ndouble min(double x, double y)\n{\n    if (x < y)\n        return x;\n    return y;\n}\n\n// Dry-run oom kill to make sure that\n// (1) it works (meaning /proc is accessible)\n// (2) the stack grows to maximum size before calling mlockall()\nstatic void startup_selftests(poll_loop_args_t* args)\n{\n    {\n        debug(\"%s: dry-running oom kill...\\n\", __func__);\n        procinfo_t victim = find_largest_process(args);\n        kill_process(args, 0, &victim);\n    }\n    if (args->notify_ext) {\n        if (args->notify_ext[0] != '/') {\n            warn(\"%s: -N: notify script '%s' is not an absolute path, disabling -N\\n\", __func__, args->notify_ext);\n            args->notify_ext = NULL;\n        } else if (access(args->notify_ext, X_OK)) {\n            warn(\"%s: -N: notify script '%s' is not executable: %s\\n\", __func__, args->notify_ext, strerror(errno));\n        }\n    }\n\n#ifdef PROFILE_FIND_LARGEST_PROCESS\n    struct timespec t0 = { 0 }, t1 = { 0 };\n    clock_gettime(CLOCK_MONOTONIC, &t0);\n\n    warn(\"PROFILE_FIND_LARGEST_PROCESS: looping forever on find_largest_process(). Use sysprof of perf to capture profile.\\n\");\n    long i = 0;\n    while (1) {\n        find_largest_process(args);\n        i++;\n\n        const int avg_n = 1000;\n        if (i % avg_n == 0) {\n            clock_gettime(CLOCK_MONOTONIC, &t1);\n            long delta_usecs = (t1.tv_sec - t0.tv_sec) * 1000000 + (t1.tv_nsec - t0.tv_nsec) / 1000;\n            double avg_wall_time_ms = (double)(delta_usecs / avg_n) / 1000.0;\n            info(\"average find_largest_process() wall time: %.3lf ms\\n\", avg_wall_time_ms);\n            clock_gettime(CLOCK_MONOTONIC, &t0);\n        }\n    };\n#endif\n}\n\nint main(int argc, char* argv[])\n{\n    poll_loop_args_t args = {\n        .mem_term_percent = 10,\n        .swap_term_percent = 10,\n        .mem_kill_percent = 5,\n        .swap_kill_percent = 5,\n        .report_interval_ms = 1000,\n        .ignore_root_user = false,\n        .sort_by_rss = false,\n        /* omitted fields are set to zero */\n    };\n    int set_my_priority = 0;\n    char* prefer_cmds = NULL;\n    char* avoid_cmds = NULL;\n    char* ignore_cmds = NULL;\n    regex_t _prefer_regex;\n    regex_t _avoid_regex;\n    regex_t _ignore_regex;\n\n    /* request line buffering for stdout - otherwise the output\n     * may lag behind stderr */\n    setlinebuf(stdout);\n\n    /* clean up dbus-send zombies */\n    signal(SIGCHLD, SIG_IGN);\n\n    fprintf(stderr, \"earlyoom \" VERSION \"\\n\");\n\n    if (chdir(procdir_path) != 0) {\n        fatal(4, \"Could not cd to /proc: %s\", strerror(errno));\n    }\n\n    // PR_CAP_AMBIENT is not available on kernel < 4.3\n#ifdef PR_CAP_AMBIENT\n    // When systemd starts a daemon with capabilities, it uses ambient\n    // capabilities to do so. If not dropped, the capabilities can spread\n    // to any child process. This is usually not necessary and its a good\n    // idea to drop them if not needed.\n    prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_CLEAR_ALL, 0, 0, 0);\n#endif\n\n    meminfo_t m = parse_meminfo();\n\n    int c;\n    const char* short_opt = \"m:s:M:S:kingN:dvr:ph\";\n    struct option long_opt[] = {\n        { \"prefer\", required_argument, NULL, LONG_OPT_PREFER },\n        { \"avoid\", required_argument, NULL, LONG_OPT_AVOID },\n        { \"ignore\", required_argument, NULL, LONG_OPT_IGNORE },\n        { \"dryrun\", no_argument, NULL, LONG_OPT_DRYRUN },\n        { \"ignore-root-user\", no_argument, NULL, LONG_OPT_IGNORE_ROOT },\n        { \"sort-by-rss\", no_argument, NULL, LONG_OPT_SORT_BY_RSS },\n        { \"syslog\", no_argument, NULL, LONG_OPT_USE_SYSLOG },\n        { \"help\", no_argument, NULL, 'h' },\n        { \"debug\", no_argument, NULL, 'd' },\n        { 0, 0, NULL, 0 } /* end-of-array marker */\n    };\n    bool have_m = 0, have_M = 0, have_s = 0, have_S = 0;\n    double mem_term_kib = 0, mem_kill_kib = 0, swap_term_kib = 0, swap_kill_kib = 0;\n\n    while ((c = getopt_long(argc, argv, short_opt, long_opt, NULL)) != -1) {\n        float report_interval_f = 0;\n        term_kill_tuple_t tuple;\n\n        switch (c) {\n        case -1: /* no more arguments */\n        case 0: /* long option toggles */\n            break;\n        case 'm':\n            // Use 99 as upper limit. Passing \"-m 100\" makes no sense.\n            tuple = parse_term_kill_tuple(optarg, 99);\n            if (strlen(tuple.err)) {\n                fatal(15, \"-m: %s\", tuple.err);\n            }\n            args.mem_term_percent = tuple.term;\n            args.mem_kill_percent = tuple.kill;\n            have_m = 1;\n            break;\n        case 's':\n            // Using \"-s 100\" is a valid way to ignore swap usage\n            tuple = parse_term_kill_tuple(optarg, 100);\n            if (strlen(tuple.err)) {\n                fatal(16, \"-s: %s\", tuple.err);\n            }\n            args.swap_term_percent = tuple.term;\n            args.swap_kill_percent = tuple.kill;\n            have_s = 1;\n            break;\n        case 'M':\n            tuple = parse_term_kill_tuple(optarg, m.MemTotalKiB * 100 / 99);\n            if (strlen(tuple.err)) {\n                fatal(15, \"-M: %s\", tuple.err);\n            }\n            mem_term_kib = tuple.term;\n            mem_kill_kib = tuple.kill;\n            have_M = 1;\n            break;\n        case 'S':\n            tuple = parse_term_kill_tuple(optarg, m.SwapTotalKiB * 100 / 99);\n            if (strlen(tuple.err)) {\n                fatal(16, \"-S: %s\", tuple.err);\n            }\n            if (m.SwapTotalKiB == 0) {\n                warn(\"warning: -S: total swap is zero, using default percentages\\n\");\n                break;\n            }\n            swap_term_kib = tuple.term;\n            swap_kill_kib = tuple.kill;\n            have_S = 1;\n            break;\n        case 'k':\n            fprintf(stderr, \"Option -k is ignored since earlyoom v1.2\\n\");\n            break;\n        case 'i':\n            fprintf(stderr, \"Option -i is ignored since earlyoom v1.7\\n\");\n            break;\n        case 'n':\n            args.notify = true;\n            fprintf(stderr, \"Notifying through D-Bus\\n\");\n            break;\n        case 'g':\n            args.kill_process_group = true;\n            break;\n        case 'N':\n            args.notify_ext = optarg;\n            break;\n        case 'd':\n            enable_debug = 1;\n            break;\n        case 'v':\n            // The version has already been printed above\n            exit(0);\n        case 'r':\n            report_interval_f = strtof(optarg, NULL);\n            if (report_interval_f < 0) {\n                fatal(14, \"-r: invalid interval '%s'\\n\", optarg);\n            }\n            args.report_interval_ms = (int)(report_interval_f * 1000);\n            break;\n        case 'p':\n            set_my_priority = 1;\n            break;\n        case LONG_OPT_IGNORE_ROOT:\n            args.ignore_root_user = true;\n            fprintf(stderr, \"Processes owned by root will not be killed\\n\");\n            break;\n        case LONG_OPT_SORT_BY_RSS:\n            args.sort_by_rss = true;\n            fprintf(stderr, \"Find process with the largest rss\\n\");\n            break;\n        case LONG_OPT_PREFER:\n            prefer_cmds = optarg;\n            break;\n        case LONG_OPT_AVOID:\n            avoid_cmds = optarg;\n            break;\n        case LONG_OPT_DRYRUN:\n            warn(\"dryrun mode enabled, will not kill anything\\n\");\n            args.dryrun = 1;\n            break;\n        case LONG_OPT_USE_SYSLOG:\n            earlyoom_syslog_init();\n            break;\n        case LONG_OPT_IGNORE:\n            ignore_cmds = optarg;\n            break;\n        case 'h':\n            fprintf(stderr,\n                \"Usage: %s [OPTION]...\\n\"\n                \"\\n\"\n                \"  -m PERCENT[,KILL_PERCENT] set available memory minimum to PERCENT of total\\n\"\n                \"                            (default 10 %%).\\n\"\n                \"                            earlyoom sends SIGTERM once below PERCENT, then\\n\"\n                \"                            SIGKILL once below KILL_PERCENT (default PERCENT/2).\\n\"\n                \"  -s PERCENT[,KILL_PERCENT] set free swap minimum to PERCENT of total (default\\n\"\n                \"                            10 %%).\\n\"\n                \"                            Note: both memory and swap must be below minimum for\\n\"\n                \"                            earlyoom to act.\\n\"\n                \"  -M SIZE[,KILL_SIZE]       set available memory minimum to SIZE KiB\\n\"\n                \"  -S SIZE[,KILL_SIZE]       set free swap minimum to SIZE KiB\\n\"\n                \"  -n                        enable d-bus notifications\\n\"\n                \"  -N /PATH/TO/SCRIPT        call script after oom kill\\n\"\n                \"  -g                        kill all processes within a process group\\n\"\n                \"  -d, --debug               enable debugging messages\\n\"\n                \"  -v                        print version information and exit\\n\"\n                \"  -r INTERVAL               memory report interval in seconds (default 1), set\\n\"\n                \"                            to 0 to disable completely\\n\"\n                \"  -p                        set niceness of earlyoom to -20 and oom_score_adj to\\n\"\n                \"                            -100\\n\"\n                \"  --ignore-root-user        do not kill processes owned by root\\n\"\n                \"  --sort-by-rss             find process with the largest rss (default oom_score)\\n\"\n                \"  --prefer REGEX            prefer to kill processes matching REGEX\\n\"\n                \"  --avoid REGEX             avoid killing processes matching REGEX\\n\"\n                \"  --ignore REGEX            ignore processes matching REGEX\\n\"\n                \"  --dryrun                  dry run (do not kill any processes)\\n\"\n                \"  --syslog                  use syslog instead of std streams\\n\"\n                \"  -h, --help                this help text\\n\",\n                argv[0]);\n            exit(0);\n        case '?':\n            fprintf(stderr, \"Try 'earlyoom --help' for more information.\\n\");\n            exit(13);\n        }\n    } /* while getopt */\n\n    if (optind < argc) {\n        fatal(13, \"extra argument not understood: '%s'\\n\", argv[optind]);\n    }\n    // Merge \"-M\" with \"-m\" values\n    if (have_M) {\n        double M_term_percent = 100 * mem_term_kib / (double)m.MemTotalKiB;\n        double M_kill_percent = 100 * mem_kill_kib / (double)m.MemTotalKiB;\n        if (have_m) {\n            // Both -m and -M were passed. Use the lower of both values.\n            args.mem_term_percent = min(args.mem_term_percent, M_term_percent);\n            args.mem_kill_percent = min(args.mem_kill_percent, M_kill_percent);\n        } else {\n            // Only -M was passed.\n            args.mem_term_percent = M_term_percent;\n            args.mem_kill_percent = M_kill_percent;\n        }\n    }\n    // Merge \"-S\" with \"-s\" values\n    if (have_S) {\n        double S_term_percent = 100 * swap_term_kib / (double)m.SwapTotalKiB;\n        double S_kill_percent = 100 * swap_kill_kib / (double)m.SwapTotalKiB;\n        if (have_s) {\n            // Both -s and -S were passed. Use the lower of both values.\n            args.swap_term_percent = min(args.swap_term_percent, S_term_percent);\n            args.swap_kill_percent = min(args.swap_kill_percent, S_kill_percent);\n        } else {\n            // Only -S was passed.\n            args.swap_term_percent = S_term_percent;\n            args.swap_kill_percent = S_kill_percent;\n        }\n    }\n    if (prefer_cmds) {\n        args.prefer_regex = &_prefer_regex;\n        if (regcomp(args.prefer_regex, prefer_cmds, REG_EXTENDED | REG_NOSUB) != 0) {\n            fatal(6, \"could not compile regexp '%s'\\n\", prefer_cmds);\n        }\n        fprintf(stderr, \"Preferring to kill process names that match regex '%s'\\n\", prefer_cmds);\n    }\n    if (avoid_cmds) {\n        args.avoid_regex = &_avoid_regex;\n        if (regcomp(args.avoid_regex, avoid_cmds, REG_EXTENDED | REG_NOSUB) != 0) {\n            fatal(6, \"could not compile regexp '%s'\\n\", avoid_cmds);\n        }\n        fprintf(stderr, \"Will avoid killing process names that match regex '%s'\\n\", avoid_cmds);\n    }\n    if (ignore_cmds) {\n        args.ignore_regex = &_ignore_regex;\n        if (regcomp(args.ignore_regex, ignore_cmds, REG_EXTENDED | REG_NOSUB) != 0) {\n            fatal(6, \"could not compile regexp '%s'\\n\", ignore_cmds);\n        }\n        fprintf(stderr, \"Will ignore process names that match regex '%s'\\n\", ignore_cmds);\n    }\n    if (set_my_priority) {\n        bool fail = 0;\n        if (setpriority(PRIO_PROCESS, 0, -20) != 0) {\n            warn(\"Could not set priority: %s. Continuing anyway\\n\", strerror(errno));\n            fail = 1;\n        }\n        int ret = set_oom_score_adj(-100);\n        if (ret != 0) {\n            warn(\"Could not set oom_score_adj: %s. Continuing anyway\\n\", strerror(ret));\n            fail = 1;\n        }\n        if (!fail) {\n            fprintf(stderr, \"Priority was raised successfully\\n\");\n        }\n    }\n\n    // Print memory limits\n    fprintf(stderr, \"mem total: %4lld MiB, user mem total: %4lld MiB, swap total: %4lld MiB\\n\",\n        m.MemTotalKiB / 1024, m.UserMemTotalKiB / 1024, m.SwapTotalKiB / 1024);\n    fprintf(stderr, \"sending SIGTERM when mem avail <= \" PRIPCT \" and swap free <= \" PRIPCT \",\\n\",\n        args.mem_term_percent, args.swap_term_percent);\n    fprintf(stderr, \"        SIGKILL when mem avail <= \" PRIPCT \" and swap free <= \" PRIPCT \"\\n\",\n        args.mem_kill_percent, args.swap_kill_percent);\n\n    startup_selftests(&args);\n\n    int err = mlockall(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT);\n    // kernels older than 4.4 don't support MCL_ONFAULT. Retry without it.\n    if (err != 0) {\n        err = mlockall(MCL_CURRENT | MCL_FUTURE);\n    }\n    if (err != 0) {\n        perror(\"Could not lock memory - continuing anyway\");\n    }\n\n    // Jump into main poll loop\n    poll_loop(&args);\n    return 0;\n}\n\n// Returns errno (success = 0)\nstatic int set_oom_score_adj(int oom_score_adj)\n{\n    char buf[PATH_LEN] = { 0 };\n    pid_t pid = getpid();\n\n    snprintf(buf, sizeof(buf), \"%s/%d/oom_score_adj\", procdir_path, pid);\n    FILE* f = fopen(buf, \"w\");\n    if (f == NULL) {\n        return -1;\n    }\n\n    // fprintf returns a negative error code on failure\n    int ret1 = fprintf(f, \"%d\", oom_score_adj);\n    // fclose returns a non-zero value on failure and errno contains the error code\n    int ret2 = fclose(f);\n\n    if (ret1 < 0) {\n        return -ret1;\n    }\n    if (ret2) {\n        return errno;\n    }\n    return 0;\n}\n\n/* Calculate the time we should sleep based upon how far away from the memory and swap\n * limits we are (headroom). Returns a millisecond value between 100 and 1000 (inclusive).\n * The idea is simple: if memory and swap can only fill up so fast, we know how long we can sleep\n * without risking to miss a low memory event.\n */\nstatic unsigned sleep_time_ms(const poll_loop_args_t* args, const meminfo_t* m)\n{\n    // Maximum expected memory/swap fill rate. In kiB per millisecond ==~ MiB per second.\n    const long long mem_fill_rate = 6000; // 6000MiB/s seen with \"stress -m 4 --vm-bytes 4G\"\n    const long long swap_fill_rate = 800; //  800MiB/s seen with membomb on ZRAM\n    // Clamp calculated value to this range (milliseconds)\n    const unsigned min_sleep = 100;\n    const unsigned max_sleep = 1000;\n\n    long long mem_headroom_kib = (long long)((m->MemAvailablePercent - args->mem_term_percent) * (double)m->UserMemTotalKiB / 100);\n    if (mem_headroom_kib < 0) {\n        mem_headroom_kib = 0;\n    }\n    long long swap_headroom_kib = (long long)((m->SwapFreePercent - args->swap_term_percent) * (double)m->SwapTotalKiB / 100);\n    if (swap_headroom_kib < 0) {\n        swap_headroom_kib = 0;\n    }\n    long long ms = mem_headroom_kib / mem_fill_rate + swap_headroom_kib / swap_fill_rate;\n    if (ms < min_sleep) {\n        return min_sleep;\n    }\n    if (ms > max_sleep) {\n        return max_sleep;\n    }\n    return (unsigned)ms;\n}\n\n/* lowmem_sig compares the limits with the current memory situation\n * and returns which signal (SIGKILL, SIGTERM, 0) should be sent in\n * response. 0 means that there is enough memory and we should\n * not kill anything.\n */\nstatic int lowmem_sig(const poll_loop_args_t* args, const meminfo_t* m)\n{\n    if (m->MemAvailablePercent <= args->mem_kill_percent && m->SwapFreePercent <= args->swap_kill_percent)\n        return SIGKILL;\n    else if (m->MemAvailablePercent <= args->mem_term_percent && m->SwapFreePercent <= args->swap_term_percent)\n        return SIGTERM;\n    return 0;\n}\n\n// poll_loop is the main event loop. Never returns.\nstatic void poll_loop(const poll_loop_args_t* args)\n{\n    // Print a a memory report when this reaches zero. We start at zero so\n    // we print the first report immediately.\n    int report_countdown_ms = 0;\n\n    while (1) {\n        meminfo_t m = parse_meminfo();\n        int sig = lowmem_sig(args, &m);\n        if (sig == SIGKILL) {\n            print_mem_stats(warn, m);\n            warn(\"low memory! at or below SIGKILL limits: mem \" PRIPCT \", swap \" PRIPCT \"\\n\",\n                args->mem_kill_percent, args->swap_kill_percent);\n        } else if (sig == SIGTERM) {\n            print_mem_stats(warn, m);\n            warn(\"low memory! at or below SIGTERM limits: mem \" PRIPCT \", swap \" PRIPCT \"\\n\",\n                args->mem_term_percent, args->swap_term_percent);\n        }\n        if (sig) {\n            procinfo_t victim = find_largest_process(args);\n            /* The run time of find_largest_process is proportional to the number\n             * of processes, and takes 2.5ms on my box with a running Gnome desktop (try \"make bench\").\n             * This is long enough that the situation may have changed in the meantime,\n             * so we double-check if we still need to kill anything.\n             * The run time of parse_meminfo is only 6us on my box and independent of the number\n             * of processes (try \"make bench\").\n             */\n            m = parse_meminfo();\n            if (lowmem_sig(args, &m) == 0) {\n                warn(\"memory situation has recovered while selecting victim\\n\");\n            } else {\n                kill_process(args, sig, &victim);\n            }\n        } else if (args->report_interval_ms && report_countdown_ms <= 0) {\n            print_mem_stats(info, m);\n            report_countdown_ms = args->report_interval_ms;\n        }\n        unsigned sleep_ms = sleep_time_ms(args, &m);\n        debug(\"adaptive sleep time: %d ms\\n\", sleep_ms);\n        struct timespec req = { .tv_sec = (time_t)(sleep_ms / 1000), .tv_nsec = (sleep_ms % 1000) * 1000000 };\n        while (nanosleep(&req, &req) == -1 && errno == EINTR)\n            ;\n        report_countdown_ms -= (int)sleep_ms;\n    }\n}\n"
        },
        {
          "name": "meminfo.c",
          "type": "blob",
          "size": 8.1484375,
          "content": "// SPDX-License-Identifier: MIT\n\n/* Parse /proc/meminfo\n * Returned values are in kiB */\n\n#include <errno.h>\n#include <signal.h>\n#include <stddef.h> // for size_t\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include \"globals.h\"\n#include \"meminfo.h\"\n#include \"msg.h\"\n#include \"proc_pid.h\"\n\n/* Parse the contents of /proc/meminfo (in buf), return value of \"name\"\n * (example: \"MemTotal:\")\n * Returns -errno if the entry cannot be found. */\nstatic long long get_entry(const char* name, const char* buf)\n{\n    char* hit = strstr(buf, name);\n    if (hit == NULL) {\n        return -ENODATA;\n    }\n\n    errno = 0;\n    long long val = strtoll(hit + strlen(name), NULL, 10);\n    if (errno != 0) {\n        int strtoll_errno = errno;\n        warn(\"%s: strtol() failed: %s\", __func__, strerror(errno));\n        return -strtoll_errno;\n    }\n    return val;\n}\n\n/* Like get_entry(), but exit if the value cannot be found */\nstatic long long get_entry_fatal(const char* name, const char* buf)\n{\n    long long val = get_entry(name, buf);\n    if (val < 0) {\n        warn(\"%s: fatal error, dumping buffer for later diagnosis:\\n%s\", __func__, buf);\n        fatal(104, \"could not find entry '%s' in /proc/meminfo: %s\\n\", name, strerror((int)-val));\n    }\n    return val;\n}\n\n/* If the kernel does not provide MemAvailable (introduced in Linux 3.14),\n * approximate it using other data we can get */\nstatic long long available_guesstimate(const char* buf)\n{\n    long long Cached = get_entry_fatal(\"Cached:\", buf);\n    long long MemFree = get_entry_fatal(\"MemFree:\", buf);\n    long long Buffers = get_entry_fatal(\"Buffers:\", buf);\n    long long Shmem = get_entry_fatal(\"Shmem:\", buf);\n\n    return MemFree + Cached + Buffers - Shmem;\n}\n\n/* Parse /proc/meminfo.\n * This function either returns valid data or kills the process\n * with a fatal error.\n */\nmeminfo_t parse_meminfo()\n{\n    // Note that we do not need to close static FDs that we ensure to\n    // `fopen()` maximally once.\n    static FILE* fd;\n    static int guesstimate_warned = 0;\n    // On Linux 5.3, \"wc -c /proc/meminfo\" counts 1391 bytes.\n    // 8192 should be enough for the foreseeable future.\n    char buf[8192] = { 0 };\n    meminfo_t m = { 0 };\n\n    if (fd == NULL) {\n        char buf[PATH_LEN] = { 0 };\n        snprintf(buf, sizeof(buf), \"%s/%s\", procdir_path, \"meminfo\");\n        fd = fopen(buf, \"r\");\n    }\n    if (fd == NULL) {\n        fatal(102, \"could not open /proc/meminfo: %s\\n\", strerror(errno));\n    }\n    rewind(fd);\n\n    size_t len = fread(buf, 1, sizeof(buf) - 1, fd);\n    if (ferror(fd)) {\n        fatal(103, \"could not read /proc/meminfo: %s\\n\", strerror(errno));\n    }\n    if (len == 0) {\n        fatal(103, \"could not read /proc/meminfo: 0 bytes returned\\n\");\n    }\n\n    m.MemTotalKiB = get_entry_fatal(\"MemTotal:\", buf);\n    m.SwapTotalKiB = get_entry_fatal(\"SwapTotal:\", buf);\n    m.AnonPagesKiB = get_entry_fatal(\"AnonPages:\", buf);\n    m.SwapFreeKiB = get_entry_fatal(\"SwapFree:\", buf);\n\n    m.MemAvailableKiB = get_entry(\"MemAvailable:\", buf);\n    if (m.MemAvailableKiB < 0) {\n        m.MemAvailableKiB = available_guesstimate(buf);\n        if (guesstimate_warned == 0) {\n            fprintf(stderr, \"Warning: Your kernel does not provide MemAvailable data (needs 3.14+)\\n\"\n                            \"         Falling back to guesstimate\\n\");\n            guesstimate_warned = 1;\n        }\n    }\n\n    // Calculated values\n    m.UserMemTotalKiB = m.MemAvailableKiB + m.AnonPagesKiB;\n\n    // Calculate percentages\n    m.MemAvailablePercent = (double)m.MemAvailableKiB * 100 / (double)m.UserMemTotalKiB;\n    if (m.SwapTotalKiB > 0) {\n        m.SwapFreePercent = (double)m.SwapFreeKiB * 100 / (double)m.SwapTotalKiB;\n    } else {\n        m.SwapFreePercent = 0;\n    }\n\n    return m;\n}\n\nbool is_alive(int pid)\n{\n    // whole process group (-g flag)?\n    if (pid < 0) {\n        // signal 0 does nothing, but we do get an error when the process\n        // group does not exist.\n        int res = kill(pid, 0);\n        if (res == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    pid_stat_t stat;\n    if (!parse_proc_pid_stat(&stat, pid)) {\n        return false;\n    }\n\n    debug(\"%s: state=%c num_threads=%ld\\n\", __func__, stat.state, stat.num_threads);\n    if (stat.state == 'Z' && stat.num_threads == 1) {\n        // A zombie process without subthreads does not use any memory. Consider it dead.\n        return false;\n    }\n    return true;\n}\n\n/* Read /proc/[pid]/[name] and convert to integer.\n * As the value may legitimately be < 0 (think oom_score_adj),\n * it is stored in the `out` pointer, and the return value is either\n * 0 (success) or -errno (failure).\n */\nstatic int read_proc_file_integer(const int pid, const char* name, int* out)\n{\n    char path[PATH_LEN] = { 0 };\n    snprintf(path, sizeof(path), \"%s/%d/%s\", procdir_path, pid, name);\n    FILE* f = fopen(path, \"r\");\n    if (f == NULL) {\n        return -errno;\n    }\n    int matches = fscanf(f, \"%d\", out);\n    fclose(f);\n    if (matches != 1) {\n        return -ENODATA;\n    }\n    return 0;\n}\n\n/* Read /proc/[pid]/oom_score.\n * Returns the value (>= 0) or -errno on error.\n */\nint get_oom_score(const int pid)\n{\n    int out = 0;\n    int res = read_proc_file_integer(pid, \"oom_score\", &out);\n    if (res < 0) {\n        return res;\n    }\n    return out;\n}\n\n/* Read /proc/[pid]/oom_score_adj.\n * As the value may legitimately be negative, the return value is\n * only used for error indication, and the value is stored in\n * the `out` pointer.\n * Returns 0 on success and -errno on error.\n */\nint get_oom_score_adj(const int pid, int* out)\n{\n    return read_proc_file_integer(pid, \"oom_score_adj\", out);\n}\n\n/* Read /proc/[pid]/comm (process name truncated to 16 bytes).\n * Returns 0 on success and -errno on error.\n */\nint get_comm(int pid, char* out, size_t outlen)\n{\n    char path[PATH_LEN] = { 0 };\n    snprintf(path, sizeof(path), \"%s/%d/comm\", procdir_path, pid);\n    FILE* f = fopen(path, \"r\");\n    if (f == NULL) {\n        return -errno;\n    }\n    size_t n = fread(out, 1, outlen - 1, f);\n    if (ferror(f)) {\n        int fread_errno = errno;\n        perror(\"get_comm: fread() failed\");\n        fclose(f);\n        return -fread_errno;\n    }\n    fclose(f);\n    // Process name may be empty, but we should get at least a newline\n    // Example for empty process name: perl -MPOSIX -e '$0=\"\"; pause'\n    if (n < 1) {\n        return -ENODATA;\n    }\n    // Strip trailing space\n    out[n - 1] = 0;\n    fix_truncated_utf8(out);\n    return 0;\n}\n\n/* Read /proc/[pid]/cmdline (process command line truncated to 256 bytes).\n * The null bytes are replaced by space.\n * Returns 0 on success and -errno on error.\n */\nint get_cmdline(int pid, char* out, size_t outlen)\n{\n    char path[PATH_LEN] = { 0 };\n    snprintf(path, sizeof(path), \"%s/%d/cmdline\", procdir_path, pid);\n    FILE* f = fopen(path, \"r\");\n    if (f == NULL) {\n        return -errno;\n    }\n    size_t n = fread(out, 1, outlen - 1, f);\n    if (ferror(f)) {\n        int fread_errno = errno;\n        perror(\"get_cmdline: fread() failed\");\n        fclose(f);\n        return -fread_errno;\n    }\n    fclose(f);\n    /* replace null character with space */\n    for (size_t i = 0; i < n; i++) {\n        if (out[i] == '\\0') {\n            out[i] = ' ';\n        }\n    }\n    // Strip trailing space\n    out[n - 1] = 0;\n    fix_truncated_utf8(out);\n    return 0;\n}\n\n// Get the effective uid (EUID) of `pid`.\n// Returns the uid (>= 0) or -errno on error.\nint get_uid(int pid)\n{\n    char path[PATH_LEN] = { 0 };\n    snprintf(path, sizeof(path), \"%s/%d\", procdir_path, pid);\n    struct stat st = { 0 };\n    int res = stat(path, &st);\n    if (res < 0) {\n        return -errno;\n    }\n    return (int)st.st_uid;\n}\n\n/* Print a status line like\n *   mem avail: 5259 MiB (67 %), swap free: 0 MiB (0 %)\"\n * as an informational message to stdout (default), or\n * as a warning to stderr.\n */\nvoid print_mem_stats(int __attribute__((format(printf, 1, 2))) (*out_func)(const char* fmt, ...), const meminfo_t m)\n{\n    out_func(\"mem avail: %5lld of %5lld MiB (\" PRIPCT \"), swap free: %4lld of %4lld MiB (\" PRIPCT \")\\n\",\n        m.MemAvailableKiB / 1024,\n        m.UserMemTotalKiB / 1024,\n        m.MemAvailablePercent,\n        m.SwapFreeKiB / 1024,\n        m.SwapTotalKiB / 1024,\n        m.SwapFreePercent);\n}\n"
        },
        {
          "name": "meminfo.h",
          "type": "blob",
          "size": 1.3095703125,
          "content": "/* SPDX-License-Identifier: MIT */\n#ifndef MEMINFO_H\n#define MEMINFO_H\n\n#define PATH_LEN 256\n\n#include \"proc_pid.h\"\n#include <stdbool.h>\n\ntypedef struct {\n    // Values from /proc/meminfo, in KiB\n    long long MemTotalKiB;\n    long long MemAvailableKiB;\n    long long SwapTotalKiB;\n    long long SwapFreeKiB;\n    long long AnonPagesKiB;\n    // Calculated values\n    // UserMemTotalKiB = MemAvailableKiB + AnonPagesKiB.\n    // Represents the total amount of memory that may be used by user processes.\n    long long UserMemTotalKiB;\n    // Calculated percentages\n    double MemAvailablePercent; // percent of total memory that is available\n    double SwapFreePercent; // percent of total swap that is free\n} meminfo_t;\n\ntypedef struct procinfo {\n    int pid;\n    int uid;\n    int oom_score;\n    int oom_score_adj;\n    long long VmRSSkiB;\n    pid_stat_t stat;\n    char name[PATH_LEN];\n    char cmdline[PATH_LEN];\n} procinfo_t;\n\n// placeholder value for numeric fields\n#define PROCINFO_FIELD_NOT_SET -9999\n\nmeminfo_t parse_meminfo();\nbool is_alive(int pid);\nvoid print_mem_stats(int (*out_func)(const char* fmt, ...), const meminfo_t m);\nint get_oom_score(int pid);\nint get_oom_score_adj(const int pid, int* out);\nint get_comm(int pid, char* out, size_t outlen);\nint get_uid(int pid);\nint get_cmdline(int pid, char* out, size_t outlen);\n\n#endif\n"
        },
        {
          "name": "msg.c",
          "type": "blob",
          "size": 6.703125,
          "content": "// SPDX-License-Identifier: MIT\n\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h> // need strlen()\n#include <syslog.h>\n#include <unistd.h>\n\n#include \"globals.h\"\n#include \"msg.h\"\n\nstatic int use_syslog = 0;\n\n// color_log writes to `f`, prefixing the `color` code if `f` is a tty.\nstatic void color_log(FILE* f, const char* color, const char* fmt, va_list vl)\n{\n    // Find out (and cache) if we should use color\n    static int stdout_is_tty = -1;\n    static int stderr_is_tty = -1;\n    static int no_color = -1;\n    bool is_tty = false;\n\n    if (no_color == -1) {\n        // https://no-color.org/\n        if (getenv(\"NO_COLOR\") != NULL) {\n            no_color = 1;\n        } else {\n            no_color = 0;\n        }\n    }\n    if (no_color == 0) {\n        if (fileno(f) == fileno(stdout)) {\n            if (stdout_is_tty == -1) {\n                stdout_is_tty = isatty(fileno(stdout));\n            }\n            is_tty = stdout_is_tty;\n        } else if (fileno(f) == fileno(stderr)) {\n            if (stderr_is_tty == -1) {\n                stderr_is_tty = isatty(fileno(stderr));\n            }\n            is_tty = stderr_is_tty;\n        }\n    }\n\n    // fds other than stdout and stderr never get color\n    const char* reset = \"\\033[0m\";\n    if (!is_tty) {\n        color = \"\";\n        reset = \"\";\n    }\n\n    fputs(color, f);\n    vfprintf(f, fmt, vl);\n    fputs(reset, f);\n    // The `reset` control was not flushed out by the\n    // newline as it was sent after. Manually flush\n    // it now to prevent artifacts when stderr and stdout\n    // mix.\n    if (fmt[strlen(fmt) - 1] == '\\n') {\n        fflush(f);\n    }\n}\n\nstatic void logger(int priority, FILE* f, const char* color, const char* fmt, va_list vl)\n{\n    if (use_syslog) {\n        vsyslog(priority, fmt, vl);\n    } else {\n        color_log(f, color, fmt, vl);\n    }\n}\n\nvoid earlyoom_syslog_init(void)\n{\n    if (!use_syslog) {\n        use_syslog = 1;\n        openlog(\"earlyoom\", LOG_PID | LOG_NDELAY, LOG_DAEMON);\n        atexit(closelog);\n    }\n}\n\n// Print message, prefixed with \"fatal: \", to stderr and exit with \"code\".\n// Example: fatal(6, \"could not compile regexp '%s'\\n\", regex_str);\nint fatal(int code, char* fmt, ...)\n{\n    const char* red = \"\\033[31m\";\n    char fmt2[MSG_LEN] = { 0 };\n    snprintf(fmt2, sizeof(fmt2), \"fatal: %s\", fmt);\n    va_list vl;\n    va_start(vl, fmt);\n    logger(LOG_ERR, stderr, red, fmt2, vl);\n    va_end(vl);\n    exit(code);\n}\n\n// Print a yellow warning message to stderr. No \"warning\" prefix is added.\nint warn(const char* fmt, ...)\n{\n    const char* yellow = \"\\033[33m\";\n    va_list vl;\n    va_start(vl, fmt);\n    logger(LOG_WARNING, stderr, yellow, fmt, vl);\n    va_end(vl);\n    return 0;\n}\n\n// Print a gray debug message to stdout. No prefix is added.\nint debug(const char* fmt, ...)\n{\n    if (!enable_debug) {\n        return 0;\n    }\n    const char* gray = \"\\033[2m\";\n    va_list vl;\n    va_start(vl, fmt);\n    logger(LOG_DEBUG, stdout, gray, fmt, vl);\n    va_end(vl);\n    return 0;\n}\n\n// Print info message to stdout. No prefix is added.\nint info(const char* fmt, ...)\n{\n    va_list vl;\n    va_start(vl, fmt);\n    logger(LOG_INFO, stdout, \"\", fmt, vl);\n    va_end(vl);\n    return 0;\n}\n\n// Parse a floating point value, check conversion errors and allowed range.\n// Guaranteed value range: 0 <= val <= upper_limit.\n// An error is indicated by storing an error message in tuple->err and returning 0.\nstatic double parse_part(term_kill_tuple_t* tuple, const char* part, long long upper_limit)\n{\n    errno = 0;\n    char* endptr = 0;\n    double val = strtod(part, &endptr);\n    if (*endptr != '\\0') {\n        snprintf(tuple->err, sizeof(tuple->err),\n            \"trailing garbage '%s'\", endptr);\n        return 0;\n    }\n    if (errno) {\n        snprintf(tuple->err, sizeof(tuple->err),\n            \"conversion error: %s\", strerror(errno));\n        return 0;\n    }\n    if (val > (double)upper_limit) {\n        snprintf(tuple->err, sizeof(tuple->err),\n            \"value %lf exceeds limit %lld\", val, upper_limit);\n        return 0;\n    }\n    if (val < 0) {\n        snprintf(tuple->err, sizeof(tuple->err),\n            \"value %lf below zero\", val);\n        return 0;\n    }\n    return val;\n}\n\n// Parse the \"term[,kill]\" tuple in optarg, examples: \"123\", \"123,456\".\n// Guaranteed value range: 0 <= term <= kill <= upper_limit.\nterm_kill_tuple_t parse_term_kill_tuple(const char* optarg, long long upper_limit)\n{\n    term_kill_tuple_t tuple = { 0 };\n    // writable copy of optarg\n    char buf[MSG_LEN] = { 0 };\n\n    if (strlen(optarg) > (sizeof(buf) - 1)) {\n        snprintf(tuple.err, sizeof(tuple.err),\n            \"argument too long (%zu bytes)\", strlen(optarg));\n        return tuple;\n    }\n    strncpy(buf, optarg, sizeof(buf) - 1);\n    // Split string on \",\" into two parts\n    char* part1 = buf;\n    char* part2 = NULL;\n    char* comma = strchr(buf, ',');\n    if (comma) {\n        // Zero-out the comma, truncates part1\n        *comma = '\\0';\n        // part2 gets zero or more bytes after the comma\n        part2 = comma + 1;\n    }\n    // Parse part1\n    tuple.term = parse_part(&tuple, part1, upper_limit);\n    if (strlen(tuple.err)) {\n        return tuple;\n    }\n    if (part2) {\n        // Parse part2\n        tuple.kill = parse_part(&tuple, part2, upper_limit);\n        if (strlen(tuple.err)) {\n            return tuple;\n        }\n    } else {\n        // User passed only the SIGTERM value: the SIGKILL value is calculated as\n        // SIGTERM/2.\n        tuple.kill = tuple.term / 2;\n    }\n    // Setting term < kill makes no sense\n    if (tuple.term < tuple.kill) {\n        warn(\"warning: SIGTERM value %.2lf is below SIGKILL value %.2lf, setting SIGTERM = SIGKILL = %.2lf\\n\",\n            tuple.term, tuple.kill, tuple.kill);\n        tuple.term = tuple.kill;\n    }\n    // Sanity checks\n    if (tuple.kill == 0 && tuple.term == 0) {\n        snprintf(tuple.err, sizeof(tuple.err),\n            \"both SIGTERM and SIGKILL values are zero\");\n        return tuple;\n    }\n    return tuple;\n}\n\n// Credit to https://gist.github.com/w-vi/67fe49106c62421992a2\n// Only works for string of length 3 and up. This is good enough\n// for our use case, which is fixing the 16-byte value we get\n// from /proc/[pid]/comm.\n//\n// Tested in unit_test.go: Test_fix_truncated_utf8()\nvoid fix_truncated_utf8(char* str)\n{\n    size_t len = strlen(str);\n    if (len < 3) {\n        return;\n    }\n    // We only need to look at the last three bytes\n    char* b = str + len - 3;\n    // Last byte is ascii\n    if ((b[2] & 0x80) == 0) {\n        return;\n    }\n    // Last byte is multi-byte sequence start\n    if (b[2] & 0x40) {\n        b[2] = 0;\n    }\n    // Truncated 3-byte sequence\n    else if ((b[1] & 0xe0) == 0xe0) {\n        b[1] = 0;\n        // Truncated 4-byte sequence\n    } else if ((b[0] & 0xf0) == 0xf0) {\n        b[0] = 0;\n    }\n}\n"
        },
        {
          "name": "msg.h",
          "type": "blob",
          "size": 1.0029296875,
          "content": "/* SPDX-License-Identifier: MIT */\n#ifndef MSG_H\n#define MSG_H\n\n#include <stdbool.h>\n\n#define MSG_LEN 256\n\n// printf format for percentages\n#define PRIPCT \"%5.2lf%%\"\n\n/* From https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Common-Function-Attributes.html :\n * The format attribute specifies that a function takes printf\n * style arguments that should be type-checked against a format string.\n */\nint fatal(int code, char* fmt, ...) __attribute__((noreturn, format(printf, 2, 3)));\nint warn(const char* fmt, ...) __attribute__((format(printf, 1, 2)));\nint debug(const char* fmt, ...) __attribute__((format(printf, 1, 2)));\nint info(const char* fmt, ...) __attribute__((format(printf, 1, 2)));\n\ntypedef struct {\n    // If the conversion failed, err contains the error message.\n    char err[255];\n    // Parsed values.\n    double term;\n    double kill;\n} term_kill_tuple_t;\n\nterm_kill_tuple_t parse_term_kill_tuple(const char* optarg, long long upper_limit);\nvoid fix_truncated_utf8(char* str);\n\nvoid earlyoom_syslog_init();\n\n#endif\n"
        },
        {
          "name": "proc_pid.c",
          "type": "blob",
          "size": 2.619140625,
          "content": "#include <errno.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"globals.h\"\n#include \"msg.h\"\n#include \"proc_pid.h\"\n\n// Parse a buffer that contains the text from /proc/$pid/stat. Example:\n// $ cat /proc/self/stat\n// 551716 (cat) R 551087 551716 551087 34816 551716 4194304 94 0 0 0 0 0 0 0 20 0 1 0 5017160 227065856 448 18446744073709551615 94898152189952 94898152206609 140721104501216 0 0 0 0 0 0 0 0 0 17 0 0 0 0 0 0 94898152221328 94898152222824 94898185641984 140721104505828 140721104505848 140721104505848 140721104510955 0\nbool parse_proc_pid_stat_buf(pid_stat_t* out, char* buf)\n{\n    char* closing_bracket = strrchr(buf, ')');\n    if (!closing_bracket) {\n        return false;\n    }\n    // If the string ends (i.e. has a null byte) after the closing bracket: bail out.\n    if (!closing_bracket[1]) {\n        return false;\n    }\n    // Because of the check above, there must be at least one more byte at\n    // closing_bracket[2] (possibly a null byte, but sscanf will handle that).\n    char* state_field = &closing_bracket[2];\n    int ret = sscanf(state_field,\n        \"%c \" // state\n        \"%d %*d %*d %*d %*d \" // ppid, pgrp, sid, tty_nr, tty_pgrp\n        \"%*u %*u %*u %*u %*u \" // flags, min_flt, cmin_flt, maj_flt, cmaj_flt\n        \"%*u %*u %*u %*u \" // utime, stime, cutime, cstime\n        \"%*d %*d \" // priority, nice\n        \"%ld \" // num_threads\n        \"%*d %*d %*d\" // itrealvalue, starttime, vsize\n        \"%ld \", // rss\n        &out->state,\n        &out->ppid,\n        &out->num_threads,\n        &out->rss);\n    if (ret != 4) {\n        return false;\n    };\n    return true;\n};\n\n// Read and parse /proc/$pid/stat. Returns true on success, false on error.\nbool parse_proc_pid_stat(pid_stat_t* out, int pid)\n{\n    // Largest /proc/*/stat file here is 363 bytes acc. to:\n    //   wc -c /proc/*/stat | sort\n    // 512 seems safe given that we only need the first 20 fields.\n    char buf[512] = { 0 };\n\n    // Read /proc/$pid/stat\n    snprintf(buf, sizeof(buf), \"%s/%d/stat\", procdir_path, pid);\n    FILE* f = fopen(buf, \"r\");\n    if (f == NULL) {\n        // Process is gone - good.\n        return false;\n    }\n    memset(buf, 0, sizeof(buf));\n\n    // File content looks like this:\n    // 10751 (cat) R 2663 10751 2663[...]\n    // File may be bigger than 256 bytes, but we only need the first 20 or so.\n    int len = (int)fread(buf, 1, sizeof(buf) - 1, f);\n    bool read_error = ferror(f) || len == 0;\n    fclose(f);\n    if (read_error) {\n        warn(\"%s: fread failed: %s\\n\", __func__, strerror(errno));\n        return false;\n    }\n    // Terminate string at end of data\n    buf[len] = 0;\n    return parse_proc_pid_stat_buf(out, buf);\n}\n"
        },
        {
          "name": "proc_pid.h",
          "type": "blob",
          "size": 0.3046875,
          "content": "/* SPDX-License-Identifier: MIT */\n#ifndef PROC_PID_H\n#define PROC_PID_H\n\n#include <stdbool.h>\n\ntypedef struct {\n    char state;\n    int ppid;\n    long num_threads;\n    long rss;\n} pid_stat_t;\n\nbool parse_proc_pid_stat_buf(pid_stat_t* out, char* buf);\nbool parse_proc_pid_stat(pid_stat_t* out, int pid);\n\n#endif\n"
        },
        {
          "name": "testsuite_c_wrappers.go",
          "type": "blob",
          "size": 2.6845703125,
          "content": "package earlyoom_testsuite\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// #cgo CFLAGS: -std=gnu99 -DCGO\n// #include \"meminfo.h\"\n// #include \"kill.h\"\n// #include \"msg.h\"\n// #include \"globals.h\"\n// #include \"proc_pid.h\"\nimport \"C\"\n\nfunc init() {\n\tC.enable_debug = 1\n}\n\nfunc enable_debug(state bool) (oldState bool) {\n\tif C.enable_debug == 1 {\n\t\toldState = true\n\t}\n\tif state {\n\t\tC.enable_debug = 1\n\t} else {\n\t\tC.enable_debug = 0\n\t}\n\treturn\n}\n\nfunc parse_term_kill_tuple(optarg string, upper_limit int) (error, float64, float64) {\n\tcs := C.CString(optarg)\n\ttuple := C.parse_term_kill_tuple(cs, C.longlong(upper_limit))\n\terrmsg := C.GoString(&(tuple.err[0]))\n\tif len(errmsg) > 0 {\n\t\treturn fmt.Errorf(errmsg), 0, 0\n\t}\n\treturn nil, float64(tuple.term), float64(tuple.kill)\n}\n\nfunc is_alive(pid int) bool {\n\tres := C.is_alive(C.int(pid))\n\treturn bool(res)\n}\n\nfunc fix_truncated_utf8(str string) string {\n\tcstr := C.CString(str)\n\tC.fix_truncated_utf8(cstr)\n\treturn C.GoString(cstr)\n}\n\nfunc parse_meminfo() C.meminfo_t {\n\treturn C.parse_meminfo()\n}\n\n// Wrapper so _test.go code can create a poll_loop_args_t\n// struct. _test.go code cannot use C.\nfunc poll_loop_args_t(sort_by_rss bool) (args C.poll_loop_args_t) {\n\targs.sort_by_rss = C.bool(sort_by_rss)\n\treturn\n}\n\nfunc procinfo_t() C.procinfo_t {\n\treturn C.procinfo_t{}\n}\n\nfunc is_larger(args *C.poll_loop_args_t, victim mockProcProcess, cur mockProcProcess) bool {\n\tcVictim := victim.toProcinfo_t()\n\tcCur := cur.toProcinfo_t()\n\treturn bool(C.is_larger(args, &cVictim, &cCur))\n}\n\nfunc find_largest_process() {\n\tvar args C.poll_loop_args_t\n\tC.find_largest_process(&args)\n}\n\nfunc kill_process() {\n\tvar args C.poll_loop_args_t\n\tvar victim C.procinfo_t\n\tvictim.pid = 1\n\tC.kill_process(&args, 0, &victim)\n}\n\nfunc get_oom_score(pid int) int {\n\treturn int(C.get_oom_score(C.int(pid)))\n}\n\nfunc get_oom_score_adj(pid int, out *int) int {\n\tvar out2 C.int\n\tres := C.get_oom_score_adj(C.int(pid), &out2)\n\t*out = int(out2)\n\treturn int(res)\n}\n\nfunc get_comm(pid int) (int, string) {\n\tcstr := C.CString(strings.Repeat(\"\\000\", 256))\n\tres := C.get_comm(C.int(pid), cstr, 256)\n\treturn int(res), C.GoString(cstr)\n}\n\nfunc get_cmdline(pid int) (int, string) {\n\tcstr := C.CString(strings.Repeat(\"\\000\", 256))\n\tres := C.get_cmdline(C.int(pid), cstr, 256)\n\treturn int(res), C.GoString(cstr)\n}\n\nfunc procdir_path(str string) string {\n\tif str != \"\" {\n\t\tcstr := C.CString(str)\n\t\tC.procdir_path = cstr\n\t}\n\treturn C.GoString(C.procdir_path)\n}\n\nfunc parse_proc_pid_stat_buf(buf string) (res bool, out C.pid_stat_t) {\n\tcbuf := C.CString(buf)\n\tres = bool(C.parse_proc_pid_stat_buf(&out, cbuf))\n\treturn res, out\n}\n\nfunc parse_proc_pid_stat(pid int) (res bool, out C.pid_stat_t) {\n\tres = bool(C.parse_proc_pid_stat(&out, C.int(pid)))\n\treturn res, out\n}\n"
        },
        {
          "name": "testsuite_cli_test.go",
          "type": "blob",
          "size": 9.0986328125,
          "content": "package earlyoom_testsuite\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype cliTestCase struct {\n\t// arguments to pass to earlyoom\n\targs []string\n\t// expected exit code\n\tcode int\n\t// stdout must contain\n\tstdoutContains string\n\t// stdout must be empty?\n\tstdoutEmpty bool\n\t// stderr must contain\n\tstderrContains string\n\t// stderr must be empty?\n\tstderrEmpty bool\n}\n\nfunc parseMeminfoLine(l string) int64 {\n\tfields := strings.Split(l, \" \")\n\tasciiVal := fields[len(fields)-2]\n\tval, err := strconv.ParseInt(asciiVal, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn val\n}\n\nfunc parseMeminfo() (memTotal int64, swapTotal int64) {\n\t/*\n\t\t/proc/meminfo looks like this:\n\n\t\tMemTotal:        8024108 kB\n\t\t[...]\n\t\tSwapTotal:        102396 kB\n\t\t[...]\n\t*/\n\tcontent, err := ioutil.ReadFile(\"/proc/meminfo\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tlines := strings.Split(string(content), \"\\n\")\n\tfor _, l := range lines {\n\t\tif strings.HasPrefix(l, \"MemTotal:\") {\n\t\t\tmemTotal = parseMeminfoLine(l)\n\t\t}\n\t\tif strings.HasPrefix(l, \"SwapTotal:\") {\n\t\t\tswapTotal = parseMeminfoLine(l)\n\t\t}\n\t}\n\treturn\n}\n\n// earlyoom RSS should never be above 1 MiB,\n// but on some systems, it is (due to glibc?).\n// https://github.com/rfjakob/earlyoom/issues/221\n// https://github.com/rfjakob/earlyoom/issues/296\nconst rssMaxKiB = 4096\n\nfunc TestCli(t *testing.T) {\n\tmemTotal, swapTotal := parseMeminfo()\n\tmem1percent := fmt.Sprintf(\"%d\", memTotal*1/100)\n\tswap2percent := fmt.Sprintf(\"%d\", swapTotal*2/100)\n\ttooBigInt32 := fmt.Sprintf(\"%d\", uint64(math.MaxInt32+1))\n\ttooBigUint32 := fmt.Sprintf(\"%d\", uint64(math.MaxUint32+1))\n\t// earlyoom startup looks like this:\n\t//   earlyoom v1.1-5-g74a364b-dirty\n\t//   mem total: 7836 MiB, min: 783 MiB (10 %)\n\t//   swap total: 0 MiB, min: 0 MiB (10 %)\n\t// startupMsg matches the last line of the startup output.\n\tconst startupMsg = \"swap total: \"\n\ttestcases := []cliTestCase{\n\t\t// Both -h and --help should show the help text\n\t\t{args: []string{\"-h\"}, code: 0, stderrContains: \"this help text\", stdoutEmpty: true},\n\t\t{args: []string{\"--help\"}, code: 0, stderrContains: \"this help text\", stdoutEmpty: true},\n\t\t{args: nil, code: -1, stderrContains: startupMsg, stdoutContains: memReport},\n\t\t{args: []string{\"-p\"}, code: -1, stdoutContains: memReport},\n\t\t{args: []string{\"-v\"}, code: 0, stderrContains: \"earlyoom v\", stdoutEmpty: true},\n\t\t{args: []string{\"-d\"}, code: -1, stdoutContains: \"new victim\"},\n\t\t{args: []string{\"-m\", \"1\"}, code: -1, stderrContains: \" 1.00%\", stdoutContains: memReport},\n\t\t{args: []string{\"-m\", \"0\"}, code: 15, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-m\", \"-10\"}, code: 15, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t// Using \"-m 100\" makes no sense\n\t\t{args: []string{\"-m\", \"100\"}, code: 15, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-s\", \"2\"}, code: -1, stderrContains: \" 2.00%\", stdoutContains: memReport},\n\t\t// Using \"-s 100\" is a valid way to ignore swap usage\n\t\t{args: []string{\"-s\", \"100\"}, code: -1, stderrContains: \" 100.00%\", stdoutContains: memReport},\n\t\t{args: []string{\"-s\", \"101\"}, code: 16, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-s\", \"0\"}, code: 16, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-s\", \"-10\"}, code: 16, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-M\", mem1percent}, code: -1, stderrContains: \" 1.00%\", stdoutContains: memReport},\n\t\t{args: []string{\"-M\", \"9999999999999999\"}, code: 15, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t// We use {\"-r=0\"} instead of {\"-r\", \"0\"} so runEarlyoom() can detect that there will be no output\n\t\t{args: []string{\"-r=0\"}, code: -1, stderrContains: startupMsg, stdoutEmpty: true},\n\t\t{args: []string{\"-r\", \"0.1\"}, code: -1, stderrContains: startupMsg, stdoutContains: memReport},\n\t\t// Test --avoid, --prefer, --ignore-root-user and --sort-by-rss\n\t\t{args: []string{\"--avoid\", \"MyProcess1\"}, code: -1, stderrContains: \"Will avoid killing\", stdoutContains: memReport},\n\t\t{args: []string{\"--prefer\", \"MyProcess2\"}, code: -1, stderrContains: \"Preferring to kill\", stdoutContains: memReport},\n\t\t{args: []string{\"--ignore-root-user\"}, code: -1, stderrContains: \"Processes owned by root will not be killed\", stdoutContains: memReport},\n\t\t{args: []string{\"--sort-by-rss\"}, code: -1, stderrContains: \"Find process with the largest rss\", stdoutContains: memReport},\n\t\t{args: []string{\"-i\"}, code: -1, stderrContains: \"Option -i is ignored\"},\n\t\t// Extra arguments should error out\n\t\t{args: []string{\"xyz\"}, code: 13, stderrContains: \"extra argument not understood\", stdoutEmpty: true},\n\t\t{args: []string{\"-i\", \"1\"}, code: 13, stderrContains: \"extra argument not understood\", stdoutEmpty: true},\n\t\t// Tuples\n\t\t{args: []string{\"-m\", \"2,1\"}, code: -1, stderrContains: \"sending SIGTERM when mem avail <=  2.00% and swap free <= 10.00%\", stdoutContains: memReport},\n\t\t{args: []string{\"-m\", \"1,2\"}, code: -1, stdoutContains: memReport},\n\t\t{args: []string{\"-m\", \"1,-1\"}, code: 15, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-m\", \"1000,-1000\"}, code: 15, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-s\", \"2,1\"}, code: -1, stderrContains: \"sending SIGTERM when mem avail <= 10.00% and swap free <=  2.00%\", stdoutContains: memReport},\n\t\t{args: []string{\"-s\", \"1,2\"}, code: -1, stdoutContains: memReport},\n\t\t// https://github.com/rfjakob/earlyoom/issues/97\n\t\t{args: []string{\"-m\", \"5,0\"}, code: -1, stdoutContains: memReport},\n\t\t{args: []string{\"-m\", \"5,9\"}, code: -1, stdoutContains: memReport},\n\t\t// check for integer overflows\n\t\t{args: []string{\"-M\", \"-1\"}, code: 15, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-M\", tooBigInt32}, code: 15, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-M\", tooBigUint32}, code: 15, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-m\", \"-1\"}, code: 15, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-m\", tooBigInt32}, code: 15, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-m\", tooBigUint32}, code: 15, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-S\", \"-1\"}, code: 16, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-S\", tooBigInt32}, code: 16, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-S\", tooBigUint32}, code: 16, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-s\", \"-1\"}, code: 16, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-s\", tooBigInt32}, code: 16, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t{args: []string{\"-s\", tooBigUint32}, code: 16, stderrContains: \"fatal\", stdoutEmpty: true},\n\t\t// Floating point values\n\t\t{args: []string{\"-m\", \"3.14\"}, code: -1, stderrContains: \"SIGTERM when mem avail <=  3.14%\", stdoutContains: memReport},\n\t\t{args: []string{\"-m\", \"7,3.14\"}, code: -1, stderrContains: \"SIGKILL when mem avail <=  3.14%\", stdoutContains: memReport},\n\t\t{args: []string{\"-s\", \"12.34\"}, code: -1, stderrContains: \"swap free <= 12.34%\", stdoutContains: memReport},\n\t\t// Use both -m/-M\n\t\t{args: []string{\"-m\", \"10\", \"-M\", mem1percent}, code: -1, stderrContains: \"SIGTERM when mem avail <=  1.00%\", stdoutContains: memReport},\n\t}\n\tif swapTotal > 0 {\n\t\t// Tests that cannot work when there is no swap enabled\n\t\ttc := []cliTestCase{\n\t\t\t{args: []string{\"-S\", swap2percent}, code: -1, stderrContains: \" 2.00%\", stdoutContains: memReport},\n\t\t\t// Use both -s/-S\n\t\t\t{args: []string{\"-s\", \"10\", \"-S\", swap2percent}, code: -1, stderrContains: \"swap free <=  1.00%\", stdoutContains: memReport},\n\t\t}\n\t\ttestcases = append(testcases, tc...)\n\t}\n\n\tfor _, tc := range testcases {\n\t\tname := fmt.Sprintf(\"%s\", strings.Join(tc.args, \" \"))\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tpass := true\n\t\t\tres := runEarlyoom(t, tc.args...)\n\t\t\tif res.code != tc.code {\n\t\t\t\tt.Errorf(\"wrong exit code: have=%d want=%d\", res.code, tc.code)\n\t\t\t\tpass = false\n\t\t\t}\n\t\t\tif tc.stdoutEmpty && res.stdout != \"\" {\n\t\t\t\tt.Errorf(\"stdout should be empty but is not\")\n\t\t\t\tpass = false\n\t\t\t}\n\t\t\tif !strings.Contains(res.stdout, tc.stdoutContains) {\n\t\t\t\tt.Errorf(\"stdout should contain %q, but does not\", tc.stdoutContains)\n\t\t\t\tpass = false\n\t\t\t}\n\t\t\tif tc.stderrEmpty && res.stderr != \"\" {\n\t\t\t\tt.Errorf(\"stderr should be empty, but is not\")\n\t\t\t\tpass = false\n\t\t\t}\n\t\t\tif !strings.Contains(res.stderr, tc.stderrContains) {\n\t\t\t\tt.Errorf(\"stderr should contain %q, but does not\", tc.stderrContains)\n\t\t\t\tpass = false\n\t\t\t}\n\t\t\tif res.rss > rssMaxKiB {\n\t\t\t\tt.Errorf(\"Memory usage too high! actual rss: %d, rssMax: %d\", res.rss, rssMaxKiB)\n\t\t\t\tpass = false\n\t\t\t}\n\t\t\tif res.fds > openFdsMax {\n\t\t\t\tif os.Getenv(\"GITHUB_ACTIONS\") == \"true\" {\n\t\t\t\t\tt.Log(\"Ignoring fd leak. Github Actions bug? See https://github.com/actions/runner/issues/1188\")\n\t\t\t\t} else {\n\t\t\t\t\tt.Fatalf(\"High number of open file descriptors: %d\", res.fds)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !pass {\n\t\t\t\tconst empty = \"(empty)\"\n\t\t\t\tif res.stderr == \"\" {\n\t\t\t\t\tres.stderr = empty\n\t\t\t\t}\n\t\t\t\tif res.stdout == \"\" {\n\t\t\t\t\tres.stdout = empty\n\t\t\t\t}\n\t\t\t\tt.Logf(\"stderr:\\n%s\", res.stderr)\n\t\t\t\tt.Logf(\"stdout:\\n%s\", res.stdout)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRss(t *testing.T) {\n\tres := runEarlyoom(t)\n\tif res.rss == 0 {\n\t\tt.Error(\"rss is zero!?\")\n\t}\n\tif res.rss > rssMaxKiB {\n\t\tt.Errorf(\"rss above %d kiB\", rssMaxKiB)\n\t}\n\tt.Logf(\"earlyoom RSS: %d kiB\", res.rss)\n}\n"
        },
        {
          "name": "testsuite_helpers.go",
          "type": "blob",
          "size": 5.6767578125,
          "content": "package earlyoom_testsuite\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n\n\tlinuxproc \"github.com/c9s/goprocinfo/linux\"\n)\n\n// #include \"meminfo.h\"\nimport \"C\"\n\ntype exitVals struct {\n\tstdout string\n\tstderr string\n\t// Exit code\n\tcode int\n\t// RSS in kiB\n\trss int\n\t// Number of file descriptors\n\tfds int\n}\n\nconst earlyoomBinary = \"./earlyoom\"\n\n// The periodic memory report looks like this:\n//\n//\tmem avail: 4998 MiB (63 %), swap free: 0 MiB (0 %)\nconst memReport = \"mem avail: \"\n\n// runEarlyoom runs earlyoom, waits for the first \"mem avail:\" status line,\n// and kills it.\nfunc runEarlyoom(t *testing.T, args ...string) exitVals {\n\tvar stdoutBuf, stderrBuf bytes.Buffer\n\tcmd := exec.Command(earlyoomBinary, args...)\n\tcmd.Stderr = &stderrBuf\n\tp, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tstdoutScanner := bufio.NewScanner(p)\n\n\t// If \"-r=0\" is passed, earlyoom will not print a memory report,\n\t// so we set a shorter timeout and not report an error on timeout\n\t// kill.\n\texpectMemReport := true\n\tfor _, a := range args {\n\t\tif a == \"-r=0\" {\n\t\t\texpectMemReport = false\n\t\t}\n\t}\n\tvar timer *time.Timer\n\tif expectMemReport {\n\t\ttimer = time.AfterFunc(10*time.Second, func() {\n\t\t\tt.Error(\"timeout\")\n\t\t\tcmd.Process.Kill()\n\t\t})\n\t} else {\n\t\ttimer = time.AfterFunc(100*time.Millisecond, func() {\n\t\t\tcmd.Process.Kill()\n\t\t})\n\t}\n\n\terr = cmd.Start()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Read until the first status line, looks like this:\n\t// mem avail: 19377 of 23915 MiB (81 %), swap free:    0 of    0 MiB ( 0 %)\n\tfor stdoutScanner.Scan() {\n\t\tline := stdoutScanner.Bytes()\n\t\tstdoutBuf.Write(line)\n\t\t// Scanner strips the newline, add it back\n\t\tstdoutBuf.Write([]byte{'\\n'})\n\t\tif bytes.HasPrefix(line, []byte(memReport)) {\n\t\t\tbreak\n\t\t}\n\t}\n\ttimer.Stop()\n\n\tstat, err := linuxproc.ReadProcessStat(fmt.Sprintf(\"/proc/%d/stat\", cmd.Process.Pid))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\trss := int(stat.Rss)\n\tfds := countFds(cmd.Process.Pid)\n\tcmd.Process.Kill()\n\terr = cmd.Wait()\n\n\treturn exitVals{\n\t\tcode:   extractCmdExitCode(err),\n\t\tstdout: string(stdoutBuf.Bytes()),\n\t\tstderr: string(stderrBuf.Bytes()),\n\t\trss:    rss,\n\t\tfds:    fds,\n\t}\n}\n\n/*\n$ ls -l /proc/$(pgrep earlyoom)/fd\ntotal 0\nlrwx------. 1 jakob jakob 64 Feb 22 14:36 0 -> /dev/pts/2\nlrwx------. 1 jakob jakob 64 Feb 22 14:36 1 -> /dev/pts/2\nlrwx------. 1 jakob jakob 64 Feb 22 14:36 2 -> /dev/pts/2\nlr-x------. 1 jakob jakob 64 Feb 22 14:36 3 -> /proc/meminfo\n\nPlus one for /proc/[pid]/stat which may possibly be open as well\n*/\nconst openFdsMax = 5\n\nfunc countFds(pid int) int {\n\tdir := fmt.Sprintf(\"/proc/%d/fd\", pid)\n\tf, err := os.Open(dir)\n\tif err != nil {\n\t\treturn -1\n\t}\n\tdefer f.Close()\n\t// Note: Readdirnames filters \".\" and \"..\"\n\tnames, err := f.Readdirnames(0)\n\tif err != nil {\n\t\treturn -1\n\t}\n\tif len(names) > openFdsMax {\n\t\tfmt.Printf(\"countFds: earlyoom has too many open fds:\\n\")\n\t\tfor _, n := range names {\n\t\t\tlinkName := fmt.Sprintf(\"%s/%s\", dir, n)\n\t\t\tlinkTarget, err := os.Readlink(linkName)\n\t\t\tfmt.Printf(\"%s -> %s, err=%v\\n\", linkName, linkTarget, err)\n\t\t}\n\t}\n\treturn len(names)\n}\n\n// extractCmdExitCode extracts the exit code from an error value that was\n// returned from exec / cmd.Run()\nfunc extractCmdExitCode(err error) int {\n\tif err == nil {\n\t\treturn 0\n\t}\n\t// OMG this is convoluted\n\tif err2, ok := err.(*exec.ExitError); ok {\n\t\treturn err2.Sys().(syscall.WaitStatus).ExitStatus()\n\t}\n\tif err2, ok := err.(*os.PathError); ok {\n\t\treturn int(err2.Err.(syscall.Errno))\n\t}\n\tlog.Panicf(\"could not decode error %#v\", err)\n\treturn 0\n}\n\ntype mockProcProcess struct {\n\tpid         int\n\tstate       string // set to \"R\" when empty\n\toom_score   int\n\tVmRSSkiB    int\n\tcomm        string\n\tnum_threads int // set to 1 when zero\n}\n\nfunc (m *mockProcProcess) toProcinfo_t() (p C.procinfo_t) {\n\tp.pid = C.int(m.pid)\n\tp.oom_score = C.int(m.oom_score)\n\tp.VmRSSkiB = C.longlong(m.VmRSSkiB)\n\tfor i, v := range []byte(m.comm) {\n\t\tp.name[i] = C.char(v)\n\t}\n\treturn p\n}\n\nfunc mockProc(t *testing.T, procs []mockProcProcess) {\n\tmockProcdir, err := ioutil.TempDir(\"\", t.Name())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tprocdir_path(mockProcdir)\n\n\tfor _, p := range procs {\n\t\tif p.state == \"\" {\n\t\t\tp.state = \"R\"\n\t\t}\n\t\tif p.num_threads == 0 {\n\t\t\tp.num_threads = 1\n\t\t}\n\n\t\tpidDir := fmt.Sprintf(\"%s/%d\", mockProcdir, int(p.pid))\n\t\tif err := os.Mkdir(pidDir, 0755); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t// statm\n\t\t//\n\t\t// rss = 2nd field, in pages. The other fields are not used by earlyoom.\n\t\trss := p.VmRSSkiB * 1024 / os.Getpagesize()\n\t\tcontent := []byte(fmt.Sprintf(\"1 %d 3 4 5 6 7\\n\", rss))\n\t\tif err := ioutil.WriteFile(pidDir+\"/statm\", content, 0444); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t// stat\n\t\t//\n\t\t// Real /proc/pid/stat string for gnome-shell\n\t\ttemplate := \"549077 (%s) S 547891 549077 549077 0 -1 4194560 245592 104 342 5 108521 28953 0 1 20 0 %d 0 4816953 5260238848 %d 18446744073709551615 94179647238144 94179647245825 140730757359824 0 0 0 0 16781312 17656 0 0 0 17 1 0 0 0 0 0 94179647252976 94179647254904 94179672109056 140730757367876 140730757367897 140730757367897 140730757369827 0\\n\"\n\t\tcontent = []byte(fmt.Sprintf(template, p.comm, p.num_threads, rss))\n\t\tif err := ioutil.WriteFile(pidDir+\"/stat\", content, 0444); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t// oom_score\n\t\tcontent = []byte(fmt.Sprintf(\"%d\\n\", p.oom_score))\n\t\tif err := ioutil.WriteFile(pidDir+\"/oom_score\", content, 0444); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t// oom_score_adj\n\t\tif err := ioutil.WriteFile(pidDir+\"/oom_score_adj\", []byte(\"0\\n\"), 0444); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t// comm\n\t\tif err := ioutil.WriteFile(pidDir+\"/comm\", []byte(p.comm+\"\\n\"), 0444); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t// cmdline\n\t\tif err := ioutil.WriteFile(pidDir+\"/cmdline\", []byte(\"foo\\000-bar\\000-baz\"), 0444); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "testsuite_unit_test.go",
          "type": "blob",
          "size": 10.39453125,
          "content": "package earlyoom_testsuite\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n\t\"syscall\"\n\t\"testing\"\n\t\"unicode/utf8\"\n\n\tlinuxproc \"github.com/c9s/goprocinfo/linux\"\n)\n\n// On Fedora 31 (Linux 5.4), /proc/sys/kernel/pid_max = 4194304.\n// It's very unlikely that INT32_MAX will be a valid pid anytime soon.\nconst INT32_MAX = 2147483647\nconst ENOENT = 2\n\nfunc TestParseTuple(t *testing.T) {\n\ttcs := []struct {\n\t\targ        string\n\t\tlimit      int\n\t\tshouldFail bool\n\t\tterm       float64\n\t\tkill       float64\n\t}{\n\t\t{arg: \"2,1\", limit: 100, term: 2, kill: 1},\n\t\t{arg: \"20,10\", limit: 100, term: 20, kill: 10},\n\t\t{arg: \"30\", limit: 100, term: 30, kill: 15},\n\t\t{arg: \"30\", limit: 20, shouldFail: true},\n\t\t// https://github.com/rfjakob/earlyoom/issues/97\n\t\t{arg: \"22[,20]\", limit: 100, shouldFail: true},\n\t\t{arg: \"220[,160]\", limit: 300, shouldFail: true},\n\t\t{arg: \"180[,170]\", limit: 300, shouldFail: true},\n\t\t{arg: \"5,0\", limit: 100, term: 5, kill: 0},\n\t\t{arg: \"5,9\", limit: 100, term: 9, kill: 9},\n\t\t{arg: \"0,5\", limit: 100, term: 5, kill: 5},\n\t\t// TERM value is set to KILL value when it is below TERM\n\t\t{arg: \"4,5\", limit: 100, term: 5, kill: 5},\n\t\t{arg: \"0\", limit: 100, shouldFail: true},\n\t\t{arg: \"0,0\", limit: 100, shouldFail: true},\n\t\t// Floating point values\n\t\t{arg: \"4.0,2.0\", limit: 100, term: 4, kill: 2},\n\t\t{arg: \"4,0,2,0\", limit: 100, shouldFail: true},\n\t\t{arg: \"3.1415,2.7182\", limit: 100, term: 3.1415, kill: 2.7182},\n\t\t{arg: \"3.1415\", limit: 100, term: 3.1415, kill: 3.1415 / 2},\n\t\t{arg: \"1.\" + strings.Repeat(\"123\", 100), limit: 100, shouldFail: true},\n\t\t// Leading garbage\n\t\t{arg: \"x1,x2\", limit: 100, shouldFail: true},\n\t\t{arg: \"1,x2\", limit: 100, shouldFail: true},\n\t\t// Trailing garbage\n\t\t{arg: \"1x,2x\", limit: 100, shouldFail: true},\n\t\t{arg: \"1.1.\", limit: 100, shouldFail: true},\n\t\t{arg: \"1,2..\", limit: 100, shouldFail: true},\n\t}\n\tfor _, tc := range tcs {\n\t\terr, term, kill := parse_term_kill_tuple(tc.arg, tc.limit)\n\t\thasFailed := (err != nil)\n\t\tif tc.shouldFail != hasFailed {\n\t\t\tt.Errorf(\"case %v: hasFailed=%v\", tc, hasFailed)\n\t\t\tcontinue\n\t\t}\n\t\tif term != tc.term {\n\t\t\tt.Errorf(\"case %v: term=%v\", tc, term)\n\t\t}\n\t\tif kill != tc.kill {\n\t\t\tt.Errorf(\"case %v: kill=%v\", tc, kill)\n\t\t}\n\t}\n}\n\nfunc TestIsAlive(t *testing.T) {\n\ttcs := []struct {\n\t\tpid int\n\t\tres bool\n\t}{\n\t\t{os.Getpid(), true},\n\t\t{1, true},\n\t\t{999999, false},\n\t\t{0, false},\n\t}\n\tfor _, tc := range tcs {\n\t\tif res := is_alive(tc.pid); res != tc.res {\n\t\t\tt.Errorf(\"pid %d: expected %v, got %v\", tc.pid, tc.res, res)\n\t\t}\n\t}\n}\n\nfunc TestIsAliveMock(t *testing.T) {\n\tmockProcdir, err := ioutil.TempDir(\"\", t.Name())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tprocdir_path(mockProcdir)\n\tdefer procdir_path(\"/proc\")\n\n\tif err := os.Mkdir(mockProcdir+\"/100\", 0700); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tstatString := func(comm string, state string) string {\n\t\ttemplate := \"144815 (%s) %s 17620 144815 144815 34817 247882 4194304 20170 1855121 1 3321 28 46 3646 3366 20 0 1 0 10798280 237576192 1065 18446744073709551615 94174652813312 94174653706789 140724247111872 0 0 0 65536 3686404 1266761467 0 0 0 17 0 0 0 9 0 0 94174653946928 94174653994640 94174663303168 140724247119367 140724247119377 140724247119377 140724247121902 0\"\n\t\treturn fmt.Sprintf(template, comm, state)\n\t}\n\ttestCases := []struct {\n\t\tcontent string\n\t\tres     bool\n\t}{\n\t\t{statString(\"bash\", \"R\"), true}, // full string from actual system\n\t\t{statString(\"bash\", \"Z\"), false},\n\t\t// hostile process names that try to fake \"I am dead\"\n\t\t{statString(\"foo) Z \", \"R\"), true},\n\t\t{statString(\"foo) Z\", \"R\"), true},\n\t\t{statString(\"foo)Z \", \"R\"), true},\n\t\t{statString(\"foo)\\nZ\\n\", \"R\"), true},\n\t\t{statString(\"foo)\\tZ\\t\", \"R\"), true},\n\t\t{statString(\"foo)  Z  \", \"R\"), true},\n\t\t// Actual stat string from https://github.com/rfjakob/zombiemem\n\t\t{\"777295 (zombiemem) Z 773303 777295 773303 34817 777295 4227084 262246 0 1 0 18 49 0 0 20 0 2 0 8669053 0 0 18446744073709551615 0 0 0 0 0 0 0 0 0 0 0 0 17 3 0 0 0 0 0 0 0 0 0 0 0 0 0\", true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tstatFile := mockProcdir + \"/100/stat\"\n\t\tif err := ioutil.WriteFile(statFile, []byte(tc.content), 0600); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif is_alive(100) != tc.res {\n\t\t\tt.Errorf(\"have=%v, want=%v for /proc/100/stat=%q\", is_alive(100), tc.res, tc.content)\n\t\t}\n\t}\n}\n\nfunc Test_fix_truncated_utf8(t *testing.T) {\n\t// From https://gist.github.com/w-vi/67fe49106c62421992a2\n\tstr := \"___😀∮ E⋅da = Q,  n → ∞, 𐍈∑ f(i) = ∏ g(i)\"\n\t// a range loop will split at runes - we *want* broken utf8 so use raw\n\t// counter.\n\tfor i := 3; i < len(str); i++ {\n\t\ttruncated := str[:i]\n\t\tfixed := fix_truncated_utf8(truncated)\n\t\tif len(fixed) < 3 {\n\t\t\tt.Fatalf(\"truncated: %q\", fixed)\n\t\t}\n\t\tif !utf8.Valid([]byte(fixed)) {\n\t\t\tt.Errorf(\"Invalid utf8: %q\", fixed)\n\t\t}\n\t}\n}\n\nfunc Test_get_oom_score(t *testing.T) {\n\tres := get_oom_score(os.Getpid())\n\t// On systems with a lot of RAM, our process may actually have a score of\n\t// zero. At least check that get_oom_score did not return an error.\n\tif res < 0 {\n\t\tt.Error(res)\n\t}\n\tres = get_oom_score(INT32_MAX)\n\tif res != -ENOENT {\n\t\tt.Errorf(\"want %d, but have %d\", syscall.ENOENT, res)\n\t}\n}\n\nfunc Test_get_comm(t *testing.T) {\n\tpid := os.Getpid()\n\tres, comm := get_comm(pid)\n\tif res != 0 {\n\t\tt.Fatalf(\"error %d\", res)\n\t}\n\tif len(comm) == 0 {\n\t\tt.Fatalf(\"empty process name %q\", comm)\n\t}\n\tt.Logf(\"process name %q\", comm)\n\t// Error case\n\tres, comm = get_comm(INT32_MAX)\n\tif res != -ENOENT {\n\t\tt.Fail()\n\t}\n\tif comm != \"\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc Test_get_cmdline(t *testing.T) {\n\tpid := os.Getpid()\n\tres, comm := get_cmdline(pid)\n\tif res != 0 {\n\t\tt.Fatalf(\"error %d\", res)\n\t}\n\tif len(comm) == 0 {\n\t\tt.Fatalf(\"empty process cmdline %q\", comm)\n\t}\n\tt.Logf(\"process cmdline %q\", comm)\n\t// Error case\n\tres, comm = get_cmdline(INT32_MAX)\n\tif res != -ENOENT {\n\t\tt.Fail()\n\t}\n\tif comm != \"\" {\n\t\tt.Fail()\n\t}\n}\n\nfunc Test_parse_proc_pid_stat_buf(t *testing.T) {\n\tshould_error_out := []string{\n\t\t\"\",\n\t\t\"x\",\n\t\t\"\\000\\000\\000\",\n\t\t\")\",\n\t}\n\tfor _, v := range should_error_out {\n\t\tres, _ := parse_proc_pid_stat_buf(v)\n\t\tif res {\n\t\t\tt.Errorf(\"Should have errored out at %q\", v)\n\t\t}\n\t}\n}\n\nfunc Test_parse_proc_pid_stat_1(t *testing.T) {\n\tstat, err := linuxproc.ReadProcessStat(\"/proc/1/stat\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tres, have := parse_proc_pid_stat(1)\n\tif !res {\n\t\tt.Fatal(res)\n\t}\n\n\twant := have\n\twant.state = _Ctype_char(stat.State[0])\n\twant.ppid = _Ctype_int(stat.Ppid)\n\twant.num_threads = _Ctype_long(stat.NumThreads)\n\twant.rss = _Ctype_long(stat.Rss)\n\n\tif have != want {\n\t\tt.Errorf(\"\\nhave=%#v\\nwant=%#v\", have, want)\n\t}\n}\n\nfunc Test_parse_proc_pid_stat_Mock(t *testing.T) {\n\tmockProcdir, err := ioutil.TempDir(\"\", t.Name())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tprocdir_path(mockProcdir)\n\tdefer procdir_path(\"/proc\")\n\n\tif err := os.Mkdir(mockProcdir+\"/100\", 0700); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Real /proc/pid/stat string for gnome-shell\n\ttemplate := \"549077 (%s) S 547891 549077 549077 0 -1 4194560 245592 104 342 5 108521 28953 0 1 20 0 23 0 4816953 5260238848 65528 18446744073709551615 94179647238144 94179647245825 140730757359824 0 0 0 0 16781312 17656 0 0 0 17 1 0 0 0 0 0 94179647252976 94179647254904 94179672109056 140730757367876 140730757367897 140730757367897 140730757369827 0\"\n\tcontent := []string{\n\t\tfmt.Sprintf(template, \"gnome-shell\"),\n\t\tfmt.Sprintf(template, \"\"),\n\t\tfmt.Sprintf(template, \": - )\"),\n\t\tfmt.Sprintf(template, \"()()()())))(((()))()()\"),\n\t\tfmt.Sprintf(template, \"   \\n\\n    \"),\n\t}\n\n\t// Stupid hack to get a C.pid_stat_t\n\t_, want := parse_proc_pid_stat(1)\n\twant.state = 'S'\n\twant.ppid = 547891\n\twant.num_threads = 23\n\twant.rss = 65528\n\n\tfor _, c := range content {\n\t\tstatFile := mockProcdir + \"/100/stat\"\n\t\tif err := ioutil.WriteFile(statFile, []byte(c), 0600); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tres, have := parse_proc_pid_stat(100)\n\t\tif !res {\n\t\t\tt.Errorf(\"parse_proc_pid_stat returned %v\", res)\n\t\t}\n\t\tif have != want {\n\t\t\tt.Errorf(\"/proc/100/stat=%q:\\nhave=%#v\\nwant=%#v\", c, have, want)\n\t\t}\n\t}\n}\n\nfunc permute_is_larger(t *testing.T, sort_by_rss bool, procs []mockProcProcess) {\n\targs := poll_loop_args_t(sort_by_rss)\n\tfor i := range procs {\n\t\tfor j := range procs {\n\t\t\t// If the entry is later in the list, is_larger should return true.\n\t\t\twant := j > i\n\t\t\thave := is_larger(&args, procs[i], procs[j])\n\t\t\tif want != have {\n\t\t\t\tt.Errorf(\"j%d/pid%d larger than i%d/pid%d? want=%v have=%v\", j, procs[j].pid, i, procs[i].pid, want, have)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc Test_is_larger(t *testing.T) {\n\tprocs := []mockProcProcess{\n\t\t// smallest\n\t\t{pid: 100, oom_score: 100, VmRSSkiB: 1234},\n\t\t{pid: 101, oom_score: 100, VmRSSkiB: 1238},\n\t\t{pid: 102, oom_score: 101, VmRSSkiB: 4},\n\t\t{pid: 103, oom_score: 102, VmRSSkiB: 4},\n\t\t{pid: 104, oom_score: 103, VmRSSkiB: 0, num_threads: 2}, // zombie main thread\n\t\t// largest\n\t}\n\n\tmockProc(t, procs)\n\tdefer procdir_path(\"/proc\")\n\tt.Logf(\"procdir_path=%q\", procdir_path(\"\"))\n\n\tpermute_is_larger(t, false, procs)\n}\n\nfunc Test_is_larger_by_rss(t *testing.T) {\n\tprocs := []mockProcProcess{\n\t\t// smallest\n\t\t{pid: 100, oom_score: 100, VmRSSkiB: 4},\n\t\t{pid: 101, oom_score: 100, VmRSSkiB: 8},\n\t\t{pid: 102, oom_score: 101, VmRSSkiB: 8},\n\t\t{pid: 103, oom_score: 99, VmRSSkiB: 12},\n\t\t{pid: 104, oom_score: 102, VmRSSkiB: 0, num_threads: 2}, // zombie main thread\n\t\t{pid: 105, oom_score: 102, VmRSSkiB: 12},\n\t\t// largest\n\t}\n\n\tmockProc(t, procs)\n\tdefer procdir_path(\"/proc\")\n\tt.Logf(\"procdir_path=%q\", procdir_path(\"\"))\n\n\tpermute_is_larger(t, true, procs)\n}\n\nfunc Benchmark_parse_meminfo(b *testing.B) {\n\tenable_debug(false)\n\n\tfor n := 0; n < b.N; n++ {\n\t\tparse_meminfo()\n\t}\n}\n\nfunc Benchmark_kill_process(b *testing.B) {\n\tenable_debug(false)\n\n\tfor n := 0; n < b.N; n++ {\n\t\tkill_process()\n\t}\n}\n\nfunc Benchmark_find_largest_process(b *testing.B) {\n\tenable_debug(false)\n\n\tfor n := 0; n < b.N; n++ {\n\t\tfind_largest_process()\n\t}\n}\n\nfunc Benchmark_get_oom_score(b *testing.B) {\n\tenable_debug(false)\n\n\tpid := os.Getpid()\n\tfor n := 0; n < b.N; n++ {\n\t\tget_oom_score(pid)\n\t}\n}\n\nfunc Benchmark_get_oom_score_adj(b *testing.B) {\n\tenable_debug(false)\n\n\tpid := os.Getpid()\n\tfor n := 0; n < b.N; n++ {\n\t\tvar out int\n\t\tget_oom_score_adj(pid, &out)\n\t}\n}\n\nfunc Benchmark_get_cmdline(b *testing.B) {\n\tenable_debug(false)\n\n\tpid := os.Getpid()\n\tfor n := 0; n < b.N; n++ {\n\t\tres, comm := get_cmdline(pid)\n\t\tif len(comm) == 0 {\n\t\t\tb.Fatalf(\"empty process cmdline %q\", comm)\n\t\t}\n\t\tif res != 0 {\n\t\t\tb.Fatalf(\"error %d\", res)\n\t\t}\n\t}\n}\n\nfunc Benchmark_parse_proc_pid_stat(b *testing.B) {\n\tenable_debug(false)\n\n\tpid := os.Getpid()\n\tfor n := 0; n < b.N; n++ {\n\t\tres, out := parse_proc_pid_stat(pid)\n\t\tif out.num_threads == 0 {\n\t\t\tb.Fatalf(\"no threads???\")\n\t\t}\n\t\tif !res {\n\t\t\tb.Fatal(\"failed\")\n\t\t}\n\t}\n}\n"
        }
      ]
    }
  ]
}