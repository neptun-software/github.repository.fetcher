{
  "metadata": {
    "timestamp": 1736710434135,
    "page": 75,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cesanta/mongoose",
      "stars": 11302,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.162109375,
          "content": "BasedOnStyle: Google\nAllowShortFunctionsOnASingleLine: false\nSpaceAfterCStyleCast: true\nPointerBindsToType: false\nDerivePointerBinding: false\nIncludeBlocks: Preserve\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.7138671875,
          "content": "Copyright (c) 2004-2013 Sergey Lyubka\nCopyright (c) 2013-2024 Cesanta Software Limited\nAll rights reserved\n\nThis software is dual-licensed: you can redistribute it and/or modify\nit under the terms of the GNU General Public License version 2 as\npublished by the Free Software Foundation. For the terms of this\nlicense, see <http://www.gnu.org/licenses/>.\n\nYou are free to use this software under the terms of the GNU General\nPublic License, but WITHOUT ANY WARRANTY; without even the implied\nwarranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\nSee the GNU General Public License for more details.\n\nAlternatively, you can license this software under a commercial\nlicense, as set out in <https://mongoose.ws/licensing/>.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.541015625,
          "content": "# Mongoose - Embedded Web Server / Embedded Network Library\n\n[![License: GPLv2/Commercial](https://img.shields.io/badge/License-GPLv2%20or%20Commercial-green.svg)](https://opensource.org/licenses/gpl-2.0.php)\n[![Build Status]( https://github.com/cesanta/mongoose/workflows/build/badge.svg)](https://github.com/cesanta/mongoose/actions)\n[![Code Coverage](https://codecov.io/gh/cesanta/mongoose/branch/master/graph/badge.svg)](https://codecov.io/gh/cesanta/mongoose)\n[![Fuzzing Status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/mongoose.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&can=1&q=proj:mongoose)\n[![Gurubase](https://img.shields.io/badge/Gurubase-Ask%20Mongoose%20Guru-006BFF)](https://gurubase.io/g/mongoose)\n\nMongoose is a network library for C/C++.  It provides event-driven non-blocking\nAPIs for TCP, UDP, HTTP, WebSocket, MQTT, and other protocols.  It is designed\nfor connecting devices and bringing them online. On the market since 2004, used\nby vast number of open source and commercial products - it even runs on the\nInternational Space Station!  Mongoose makes embedded network programming fast,\nrobust, and easy. Features include:\n\n- Cross-platform:\n  - works on Linux/UNIX, MacOS, Windows, Android\n  - works on ST, NXP, ESP32, Nordic, TI, Microchip, Infineon, Renesas and other chips\n  - write code once - and it'll work everywhere\n  - ideal for the unification of the network infrastructure code across company\n- Built-in protocols: plain TCP/UDP, SNTP, HTTP, MQTT, Websocket, and other\n- Asynchronous DNS resolver\n- Tiny static and run-time footprint\n- Source code is both ISO C and ISO C++ compliant\n- Easy to integrate: just copy [mongoose.c](https://raw.githubusercontent.com/cesanta/mongoose/master/mongoose.c)\n  and [mongoose.h](https://raw.githubusercontent.com/cesanta/mongoose/master/mongoose.h) files to your source tree\n- Built-in TCP/IP stack with drivers for bare metal or RTOS systems\n   - Available drivers: STM32F, STM32H; NXP RT1xxx; TI TM4C; Microchip SAME54; Wiznet W5500\n   - A complete Web device dashboard on bare metal ST Nucleo boards is only 6 files\n   - For comparison, a CubeIDE generated HTTP example is 400+ files\n- Can run on top of an existing TCP/IP stack with BSD API, e.g. lwIP, Zephyr, Azure, etc\n- Built-in TLS 1.3 ECC stack. Also can use external TLS libraries - mbedTLS, OpenSSL, or other\n- Does not depend on any other software to implement networking\n- Built-in firmware updates for STM32 H5, STM32 H7\n\nSee https://mongoose.ws/ for complete documentation, videos, case studies, etc.\n\n## Usage Examples\n\nBelow are quick snippets that should give an idea how simple the API is and\nhow easy it is to create applications with it.\n\nCreate a simple web server that serves a directory. The behavior of the\nHTTP server is specified by its event handler function:\n\n```c\n#include \"mongoose.h\"   // To build, run: cc main.c mongoose.c\n\n// HTTP server event handler function\nvoid ev_handler(struct mg_connection *c, int ev, void *ev_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_http_serve_opts opts = { .root_dir = \"./web_root/\" };\n    mg_http_serve_dir(c, hm, &opts);\n  }\n}\n\nint main(void) {\n  struct mg_mgr mgr;  // Declare event manager\n  mg_mgr_init(&mgr);  // Initialise event manager\n  mg_http_listen(&mgr, \"http://0.0.0.0:8000\", ev_handler, NULL);  // Setup listener\n  for (;;) {          // Run an infinite event loop\n    mg_mgr_poll(&mgr, 1000);\n  }\n  return 0;\n}\n```\n\nHTTP server implements a REST API that returns current time. JSON formatting:\n```c\nstatic void ev_handler(struct mg_connection *c, int ev, void *ev_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    if (mg_match(hm->uri, mg_str(\"/api/time/get\"), NULL)) {\n      mg_http_reply(c, 200, \"\", \"{%m:%lu}\\n\", MG_ESC(\"time\"), time(NULL));\n    } else {\n      mg_http_reply(c, 500, \"\", \"{%m:%m}\\n\", MG_ESC(\"error\"), MG_ESC(\"Unsupported URI\")); \n    }\n  }\n}\n```\n\nMQTT client that subscribes to a topic `device1/rx` and\nechoes incoming messages to `device1/tx`:\n\n```c\n#include \"mongoose.h\"\n\nstatic const char *s_mqtt_url = \"mqtt://broker.hivemq.com:1883\";\nstatic struct mg_connection *s_mqtt_conn = NULL;\n\n// MQTT connection event handler function\nstatic void ev_handler(struct mg_connection *c, int ev, void *ev_data) {\n  if (ev == MG_EV_OPEN) {\n    MG_INFO((\"%lu created, connecting to %s ...\", c->id, s_mqtt_url));\n  } else if (ev == MG_EV_MQTT_OPEN) {\n    struct mg_mqtt_opts opts = {.qos = 1, .topic = mg_str(\"device1/rx\")};\n    mg_mqtt_sub(c, &opts);\n    MG_INFO((\"%lu connected, subscribing to %s\", c->id, opts.topic.buf));\n  } else if (ev == MG_EV_MQTT_MSG) {\n    char response[100];\n    struct mg_mqtt_message *mm = (struct mg_mqtt_message *) ev_data;\n    struct mg_mqtt_opts opts = {.qos = 1, .topic = mg_str(\"device1/tx\")};\n    mg_snprintf(response, sizeof(response), \"Received [%.*s] / [%.*s]\",\n                mm->topic.len, mm->topic.buf, mm->data.len, mm->data.buf);\n    opts.message = mg_str(response);\n    mg_mqtt_pub(c, &opts);\n  } else if (ev == MG_EV_CLOSE) {\n    MG_INFO((\"%u closing\", c->id));\n    s_mqtt_conn = NULL;\n  }\n}\n\n// Reconnection timer function. If we get disconnected, reconnect again\nstatic void timer_fn(void *arg) {\n  struct mg_mgr *mgr = (struct mg_mgr *) arg;\n  if (s_mqtt_conn == NULL) {\n    struct mg_mqtt_opts opts = {.clean = true};\n    s_mqtt_conn = mg_mqtt_connect(mgr, s_mqtt_url, &opts, ev_handler, NULL);\n  }\n}\n\nint main() {\n  struct mg_mgr mgr;  // Mongoose event manager. Holds all connections\n  mg_mgr_init(&mgr);  // Initialise event manager\n  mg_timer_add(&mgr, 3000, MG_TIMER_REPEAT | MG_TIMER_RUN_NOW, timer_fn, &mgr);\n  for (;;) {\n    mg_mgr_poll(&mgr, 1000);  // Infinite event loop\n  }\n  return 0;\n}\n```\n\n## Commercial use\n- Mongoose is used by hundreds of businesses, from Fortune500 giants like\n  Siemens, Schneider Electric, Broadcom, Bosch, Google, Samsung, Qualcomm, Caterpillar to the small businesses\n- Used to solve a wide range of business needs, like implementing Web UI\n  interface on devices, RESTful API services, telemetry data exchange, remote\n  control for a product, remote software updates, remote monitoring, and others\n- Deployed to hundreds of millions devices in production environment worldwide\n- See [Case Studies](https://mongoose.ws/case-studies/) from our respected\n  customers like [Schneider Electric](https://mongoose.ws/case-studies/schneider-electric/) (industrial automation), [Broadcom](https://mongoose.ws/case-studies/broadcom/) (semiconductors), [Pilz](https://mongoose.ws/case-studies/pilz/) (industrial automation), and others\n- See [Testimonials](https://mongoose.ws/testimonials/) from engineers that integrated Mongoose in their commercial products\n- We provide [Evaluation and Commercial licensing](https://mongoose.ws/licensing/), [support](https://mongoose.ws/support/), consultancy and [integration\n  services](https://mongoose.ws/integration/) - don't hesitate to [contact us](https://mongoose.ws/contact/)\n\n\n## Security\n\nWe take security seriously:\n1. Mongoose repository runs a\n  [continuous integration test powered by GitHub](https://github.com/cesanta/mongoose/actions),\n  which runs through hundreds of unit tests on every commit to the repository.\n  Our [unit tests](https://github.com/cesanta/mongoose/tree/master/test)\n  are built with modern address sanitizer technologies, which help to find\n  security vulnerabilities early\n2. Mongoose repository is integrated into Google's\n  [oss-fuzz continuous fuzzer](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&can=1&q=proj:mongoose)\n  which scans for potential vulnerabilities continuously\n3.  We receive periodic vulnerability reports from the independent security\n  groups like\n  [Cisco Talos](https://www.cisco.com/c/en/us/products/security/talos.html),\n  [Microsoft Security Response Center](https://www.microsoft.com/en-us/msrc),\n  [MITRE Corporation](https://www.mitre.org/),\n  [Compass Security](https://www.compass-security.com/en/) and others.\n  In case of the vulnerability found, we act according to the industry best\n  practice: hold on to the publication, fix the software and notify all our\n  customers that have an appropriate subscription\n4. Some of our customers (for example NASA)\n  have specific security requirements and run independent security audits,\n  of which we get notified and in case of any issue, act similar to (3).\n\n\n## Contributions\n\nContributions are welcome! Please follow the guidelines below:\n\n- Sign [Cesanta CLA](https://cesanta.com/cla.html) and send GitHub pull request\n- Make sure that PRs have only one commit, and deal with one issue only\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "mongoose.c",
          "type": "blob",
          "size": 687.58203125,
          "content": "// Copyright (c) 2004-2013 Sergey Lyubka\n// Copyright (c) 2013-2024 Cesanta Software Limited\n// All rights reserved\n//\n// This software is dual-licensed: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License version 2 as\n// published by the Free Software Foundation. For the terms of this\n// license, see http://www.gnu.org/licenses/\n//\n// You are free to use this software under the terms of the GNU General\n// Public License, but WITHOUT ANY WARRANTY; without even the implied\n// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU General Public License for more details.\n//\n// Alternatively, you can license this software under a commercial\n// license, as set out in https://www.mongoose.ws/licensing/\n//\n// SPDX-License-Identifier: GPL-2.0-only or commercial\n\n#include \"mongoose.h\"\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/base64.c\"\n#endif\n\n\nstatic int mg_base64_encode_single(int c) {\n  if (c < 26) {\n    return c + 'A';\n  } else if (c < 52) {\n    return c - 26 + 'a';\n  } else if (c < 62) {\n    return c - 52 + '0';\n  } else {\n    return c == 62 ? '+' : '/';\n  }\n}\n\nstatic int mg_base64_decode_single(int c) {\n  if (c >= 'A' && c <= 'Z') {\n    return c - 'A';\n  } else if (c >= 'a' && c <= 'z') {\n    return c + 26 - 'a';\n  } else if (c >= '0' && c <= '9') {\n    return c + 52 - '0';\n  } else if (c == '+') {\n    return 62;\n  } else if (c == '/') {\n    return 63;\n  } else if (c == '=') {\n    return 64;\n  } else {\n    return -1;\n  }\n}\n\nsize_t mg_base64_update(unsigned char ch, char *to, size_t n) {\n  unsigned long rem = (n & 3) % 3;\n  if (rem == 0) {\n    to[n] = (char) mg_base64_encode_single(ch >> 2);\n    to[++n] = (char) ((ch & 3) << 4);\n  } else if (rem == 1) {\n    to[n] = (char) mg_base64_encode_single(to[n] | (ch >> 4));\n    to[++n] = (char) ((ch & 15) << 2);\n  } else {\n    to[n] = (char) mg_base64_encode_single(to[n] | (ch >> 6));\n    to[++n] = (char) mg_base64_encode_single(ch & 63);\n    n++;\n  }\n  return n;\n}\n\nsize_t mg_base64_final(char *to, size_t n) {\n  size_t saved = n;\n  // printf(\"---[%.*s]\\n\", n, to);\n  if (n & 3) n = mg_base64_update(0, to, n);\n  if ((saved & 3) == 2) n--;\n  // printf(\"    %d[%.*s]\\n\", n, n, to);\n  while (n & 3) to[n++] = '=';\n  to[n] = '\\0';\n  return n;\n}\n\nsize_t mg_base64_encode(const unsigned char *p, size_t n, char *to, size_t dl) {\n  size_t i, len = 0;\n  if (dl > 0) to[0] = '\\0';\n  if (dl < ((n / 3) + (n % 3 ? 1 : 0)) * 4 + 1) return 0;\n  for (i = 0; i < n; i++) len = mg_base64_update(p[i], to, len);\n  len = mg_base64_final(to, len);\n  return len;\n}\n\nsize_t mg_base64_decode(const char *src, size_t n, char *dst, size_t dl) {\n  const char *end = src == NULL ? NULL : src + n;  // Cannot add to NULL\n  size_t len = 0;\n  if (dl < n / 4 * 3 + 1) goto fail;\n  while (src != NULL && src + 3 < end) {\n    int a = mg_base64_decode_single(src[0]),\n        b = mg_base64_decode_single(src[1]),\n        c = mg_base64_decode_single(src[2]),\n        d = mg_base64_decode_single(src[3]);\n    if (a == 64 || a < 0 || b == 64 || b < 0 || c < 0 || d < 0) {\n      goto fail;\n    }\n    dst[len++] = (char) ((a << 2) | (b >> 4));\n    if (src[2] != '=') {\n      dst[len++] = (char) ((b << 4) | (c >> 2));\n      if (src[3] != '=') dst[len++] = (char) ((c << 6) | d);\n    }\n    src += 4;\n  }\n  dst[len] = '\\0';\n  return len;\nfail:\n  if (dl > 0) dst[0] = '\\0';\n  return 0;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/dns.c\"\n#endif\n\n\n\n\n\n\n\n\nstruct dns_data {\n  struct dns_data *next;\n  struct mg_connection *c;\n  uint64_t expire;\n  uint16_t txnid;\n};\n\nstatic void mg_sendnsreq(struct mg_connection *, struct mg_str *, int,\n                         struct mg_dns *, bool);\n\nstatic void mg_dns_free(struct dns_data **head, struct dns_data *d) {\n  LIST_DELETE(struct dns_data, head, d);\n  free(d);\n}\n\nvoid mg_resolve_cancel(struct mg_connection *c) {\n  struct dns_data *tmp, *d;\n  struct dns_data **head = (struct dns_data **) &c->mgr->active_dns_requests;\n  for (d = *head; d != NULL; d = tmp) {\n    tmp = d->next;\n    if (d->c == c) mg_dns_free(head, d);\n  }\n}\n\nstatic size_t mg_dns_parse_name_depth(const uint8_t *s, size_t len, size_t ofs,\n                                      char *to, size_t tolen, size_t j,\n                                      int depth) {\n  size_t i = 0;\n  if (tolen > 0 && depth == 0) to[0] = '\\0';\n  if (depth > 5) return 0;\n  // MG_INFO((\"ofs %lx %x %x\", (unsigned long) ofs, s[ofs], s[ofs + 1]));\n  while (ofs + i + 1 < len) {\n    size_t n = s[ofs + i];\n    if (n == 0) {\n      i++;\n      break;\n    }\n    if (n & 0xc0) {\n      size_t ptr = (((n & 0x3f) << 8) | s[ofs + i + 1]);  // 12 is hdr len\n      // MG_INFO((\"PTR %lx\", (unsigned long) ptr));\n      if (ptr + 1 < len && (s[ptr] & 0xc0) == 0 &&\n          mg_dns_parse_name_depth(s, len, ptr, to, tolen, j, depth + 1) == 0)\n        return 0;\n      i += 2;\n      break;\n    }\n    if (ofs + i + n + 1 >= len) return 0;\n    if (j > 0) {\n      if (j < tolen) to[j] = '.';\n      j++;\n    }\n    if (j + n < tolen) memcpy(&to[j], &s[ofs + i + 1], n);\n    j += n;\n    i += n + 1;\n    if (j < tolen) to[j] = '\\0';  // Zero-terminate this chunk\n    // MG_INFO((\"--> [%s]\", to));\n  }\n  if (tolen > 0) to[tolen - 1] = '\\0';  // Make sure make sure it is nul-term\n  return i;\n}\n\nstatic size_t mg_dns_parse_name(const uint8_t *s, size_t n, size_t ofs,\n                                char *dst, size_t dstlen) {\n  return mg_dns_parse_name_depth(s, n, ofs, dst, dstlen, 0, 0);\n}\n\nsize_t mg_dns_parse_rr(const uint8_t *buf, size_t len, size_t ofs,\n                       bool is_question, struct mg_dns_rr *rr) {\n  const uint8_t *s = buf + ofs, *e = &buf[len];\n\n  memset(rr, 0, sizeof(*rr));\n  if (len < sizeof(struct mg_dns_header)) return 0;  // Too small\n  if (len > 512) return 0;  //  Too large, we don't expect that\n  if (s >= e) return 0;     //  Overflow\n\n  if ((rr->nlen = (uint16_t) mg_dns_parse_name(buf, len, ofs, NULL, 0)) == 0)\n    return 0;\n  s += rr->nlen + 4;\n  if (s > e) return 0;\n  rr->atype = (uint16_t) (((uint16_t) s[-4] << 8) | s[-3]);\n  rr->aclass = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);\n  if (is_question) return (size_t) (rr->nlen + 4);\n\n  s += 6;\n  if (s > e) return 0;\n  rr->alen = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);\n  if (s + rr->alen > e) return 0;\n  return (size_t) (rr->nlen + rr->alen + 10);\n}\n\nbool mg_dns_parse(const uint8_t *buf, size_t len, struct mg_dns_message *dm) {\n  const struct mg_dns_header *h = (struct mg_dns_header *) buf;\n  struct mg_dns_rr rr;\n  size_t i, n, num_answers, ofs = sizeof(*h);\n  memset(dm, 0, sizeof(*dm));\n\n  if (len < sizeof(*h)) return 0;                // Too small, headers dont fit\n  if (mg_ntohs(h->num_questions) > 1) return 0;  // Sanity\n  num_answers = mg_ntohs(h->num_answers);\n  if (num_answers > 10) {\n    MG_DEBUG((\"Got %u answers, ignoring beyond 10th one\", num_answers));\n    num_answers = 10;  // Sanity cap\n  }\n  dm->txnid = mg_ntohs(h->txnid);\n\n  for (i = 0; i < mg_ntohs(h->num_questions); i++) {\n    if ((n = mg_dns_parse_rr(buf, len, ofs, true, &rr)) == 0) return false;\n    // MG_INFO((\"Q %lu %lu %hu/%hu\", ofs, n, rr.atype, rr.aclass));\n    ofs += n;\n  }\n  for (i = 0; i < num_answers; i++) {\n    if ((n = mg_dns_parse_rr(buf, len, ofs, false, &rr)) == 0) return false;\n    // MG_INFO((\"A -- %lu %lu %hu/%hu %s\", ofs, n, rr.atype, rr.aclass,\n    // dm->name));\n    mg_dns_parse_name(buf, len, ofs, dm->name, sizeof(dm->name));\n    ofs += n;\n\n    if (rr.alen == 4 && rr.atype == 1 && rr.aclass == 1) {\n      dm->addr.is_ip6 = false;\n      memcpy(&dm->addr.ip, &buf[ofs - 4], 4);\n      dm->resolved = true;\n      break;  // Return success\n    } else if (rr.alen == 16 && rr.atype == 28 && rr.aclass == 1) {\n      dm->addr.is_ip6 = true;\n      memcpy(&dm->addr.ip, &buf[ofs - 16], 16);\n      dm->resolved = true;\n      break;  // Return success\n    }\n  }\n  return true;\n}\n\nstatic void dns_cb(struct mg_connection *c, int ev, void *ev_data) {\n  struct dns_data *d, *tmp;\n  struct dns_data **head = (struct dns_data **) &c->mgr->active_dns_requests;\n  if (ev == MG_EV_POLL) {\n    uint64_t now = *(uint64_t *) ev_data;\n    for (d = *head; d != NULL; d = tmp) {\n      tmp = d->next;\n      // MG_DEBUG (\"%lu %lu dns poll\", d->expire, now));\n      if (now > d->expire) mg_error(d->c, \"DNS timeout\");\n    }\n  } else if (ev == MG_EV_READ) {\n    struct mg_dns_message dm;\n    int resolved = 0;\n    if (mg_dns_parse(c->recv.buf, c->recv.len, &dm) == false) {\n      MG_ERROR((\"Unexpected DNS response:\"));\n      mg_hexdump(c->recv.buf, c->recv.len);\n    } else {\n      // MG_VERBOSE((\"%s %d\", dm.name, dm.resolved));\n      for (d = *head; d != NULL; d = tmp) {\n        tmp = d->next;\n        // MG_INFO((\"d %p %hu %hu\", d, d->txnid, dm.txnid));\n        if (dm.txnid != d->txnid) continue;\n        if (d->c->is_resolving) {\n          if (dm.resolved) {\n            dm.addr.port = d->c->rem.port;  // Save port\n            d->c->rem = dm.addr;            // Copy resolved address\n            MG_DEBUG(\n                (\"%lu %s is %M\", d->c->id, dm.name, mg_print_ip, &d->c->rem));\n            mg_connect_resolved(d->c);\n#if MG_ENABLE_IPV6\n          } else if (dm.addr.is_ip6 == false && dm.name[0] != '\\0' &&\n                     c->mgr->use_dns6 == false) {\n            struct mg_str x = mg_str(dm.name);\n            mg_sendnsreq(d->c, &x, c->mgr->dnstimeout, &c->mgr->dns6, true);\n#endif\n          } else {\n            mg_error(d->c, \"%s DNS lookup failed\", dm.name);\n          }\n        } else {\n          MG_ERROR((\"%lu already resolved\", d->c->id));\n        }\n        mg_dns_free(head, d);\n        resolved = 1;\n      }\n    }\n    if (!resolved) MG_ERROR((\"stray DNS reply\"));\n    c->recv.len = 0;\n  } else if (ev == MG_EV_CLOSE) {\n    for (d = *head; d != NULL; d = tmp) {\n      tmp = d->next;\n      mg_error(d->c, \"DNS error\");\n      mg_dns_free(head, d);\n    }\n  }\n}\n\nstatic bool mg_dns_send(struct mg_connection *c, const struct mg_str *name,\n                        uint16_t txnid, bool ipv6) {\n  struct {\n    struct mg_dns_header header;\n    uint8_t data[256];\n  } pkt;\n  size_t i, n;\n  memset(&pkt, 0, sizeof(pkt));\n  pkt.header.txnid = mg_htons(txnid);\n  pkt.header.flags = mg_htons(0x100);\n  pkt.header.num_questions = mg_htons(1);\n  for (i = n = 0; i < sizeof(pkt.data) - 5; i++) {\n    if (name->buf[i] == '.' || i >= name->len) {\n      pkt.data[n] = (uint8_t) (i - n);\n      memcpy(&pkt.data[n + 1], name->buf + n, i - n);\n      n = i + 1;\n    }\n    if (i >= name->len) break;\n  }\n  memcpy(&pkt.data[n], \"\\x00\\x00\\x01\\x00\\x01\", 5);  // A query\n  n += 5;\n  if (ipv6) pkt.data[n - 3] = 0x1c;  // AAAA query\n  // memcpy(&pkt.data[n], \"\\xc0\\x0c\\x00\\x1c\\x00\\x01\", 6);  // AAAA query\n  // n += 6;\n  return mg_send(c, &pkt, sizeof(pkt.header) + n);\n}\n\nstatic void mg_sendnsreq(struct mg_connection *c, struct mg_str *name, int ms,\n                         struct mg_dns *dnsc, bool ipv6) {\n  struct dns_data *d = NULL;\n  if (dnsc->url == NULL) {\n    mg_error(c, \"DNS server URL is NULL. Call mg_mgr_init()\");\n  } else if (dnsc->c == NULL) {\n    dnsc->c = mg_connect(c->mgr, dnsc->url, NULL, NULL);\n    if (dnsc->c != NULL) {\n      dnsc->c->pfn = dns_cb;\n      // dnsc->c->is_hexdumping = 1;\n    }\n  }\n  if (dnsc->c == NULL) {\n    mg_error(c, \"resolver\");\n  } else if ((d = (struct dns_data *) calloc(1, sizeof(*d))) == NULL) {\n    mg_error(c, \"resolve OOM\");\n  } else {\n    struct dns_data *reqs = (struct dns_data *) c->mgr->active_dns_requests;\n    d->txnid = reqs ? (uint16_t) (reqs->txnid + 1) : 1;\n    d->next = (struct dns_data *) c->mgr->active_dns_requests;\n    c->mgr->active_dns_requests = d;\n    d->expire = mg_millis() + (uint64_t) ms;\n    d->c = c;\n    c->is_resolving = 1;\n    MG_VERBOSE((\"%lu resolving %.*s @ %s, txnid %hu\", c->id, (int) name->len,\n                name->buf, dnsc->url, d->txnid));\n    if (!mg_dns_send(dnsc->c, name, d->txnid, ipv6)) {\n      mg_error(dnsc->c, \"DNS send\");\n    }\n  }\n}\n\nvoid mg_resolve(struct mg_connection *c, const char *url) {\n  struct mg_str host = mg_url_host(url);\n  c->rem.port = mg_htons(mg_url_port(url));\n  if (mg_aton(host, &c->rem)) {\n    // host is an IP address, do not fire name resolution\n    mg_connect_resolved(c);\n  } else {\n    // host is not an IP, send DNS resolution request\n    struct mg_dns *dns = c->mgr->use_dns6 ? &c->mgr->dns6 : &c->mgr->dns4;\n    mg_sendnsreq(c, &host, c->mgr->dnstimeout, dns, c->mgr->use_dns6);\n  }\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/event.c\"\n#endif\n\n\n\n\n\n\nvoid mg_call(struct mg_connection *c, int ev, void *ev_data) {\n#if MG_ENABLE_PROFILE\n  const char *names[] = {\n      \"EV_ERROR\",    \"EV_OPEN\",      \"EV_POLL\",      \"EV_RESOLVE\",\n      \"EV_CONNECT\",  \"EV_ACCEPT\",    \"EV_TLS_HS\",    \"EV_READ\",\n      \"EV_WRITE\",    \"EV_CLOSE\",     \"EV_HTTP_MSG\",  \"EV_HTTP_CHUNK\",\n      \"EV_WS_OPEN\",  \"EV_WS_MSG\",    \"EV_WS_CTL\",    \"EV_MQTT_CMD\",\n      \"EV_MQTT_MSG\", \"EV_MQTT_OPEN\", \"EV_SNTP_TIME\", \"EV_USER\"};\n  if (ev != MG_EV_POLL && ev < (int) (sizeof(names) / sizeof(names[0]))) {\n    MG_PROF_ADD(c, names[ev]);\n  }\n#endif\n  // Fire protocol handler first, user handler second. See #2559\n  if (c->pfn != NULL) c->pfn(c, ev, ev_data);\n  if (c->fn != NULL) c->fn(c, ev, ev_data);\n}\n\nvoid mg_error(struct mg_connection *c, const char *fmt, ...) {\n  char buf[64];\n  va_list ap;\n  va_start(ap, fmt);\n  mg_vsnprintf(buf, sizeof(buf), fmt, &ap);\n  va_end(ap);\n  MG_ERROR((\"%lu %ld %s\", c->id, c->fd, buf));\n  c->is_closing = 1;             // Set is_closing before sending MG_EV_CALL\n  mg_call(c, MG_EV_ERROR, buf);  // Let user handler override it\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/flash.c\"\n#endif\n\n\n\n\n\n#if MG_OTA != MG_OTA_NONE && MG_OTA != MG_OTA_CUSTOM\n\nstatic char *s_addr;      // Current address to write to\nstatic size_t s_size;     // Firmware size to flash. In-progress indicator\nstatic uint32_t s_crc32;  // Firmware checksum\n\nbool mg_ota_flash_begin(size_t new_firmware_size, struct mg_flash *flash) {\n  bool ok = false;\n  if (s_size) {\n    MG_ERROR((\"OTA already in progress. Call mg_ota_end()\"));\n  } else {\n    size_t half = flash->size / 2;\n    s_crc32 = 0;\n    s_addr = (char *) flash->start + half;\n    MG_DEBUG((\"FW %lu bytes, max %lu\", new_firmware_size, half));\n    if (new_firmware_size < half) {\n      ok = true;\n      s_size = new_firmware_size;\n      MG_INFO((\"Starting OTA, firmware size %lu\", s_size));\n    } else {\n      MG_ERROR((\"Firmware %lu is too big to fit %lu\", new_firmware_size, half));\n    }\n  }\n  return ok;\n}\n\nbool mg_ota_flash_write(const void *buf, size_t len, struct mg_flash *flash) {\n  bool ok = false;\n  if (s_size == 0) {\n    MG_ERROR((\"OTA is not started, call mg_ota_begin()\"));\n  } else {\n    size_t len_aligned_down = MG_ROUND_DOWN(len, flash->align);\n    if (len_aligned_down) ok = flash->write_fn(s_addr, buf, len_aligned_down);\n    if (len_aligned_down < len) {\n      size_t left = len - len_aligned_down;\n      char tmp[flash->align];\n      memset(tmp, 0xff, sizeof(tmp));\n      memcpy(tmp, (char *) buf + len_aligned_down, left);\n      ok = flash->write_fn(s_addr + len_aligned_down, tmp, sizeof(tmp));\n    }\n    s_crc32 = mg_crc32(s_crc32, (char *) buf, len);  // Update CRC\n    MG_DEBUG((\"%#x %p %lu -> %d\", s_addr - len, buf, len, ok));\n    s_addr += len;\n  }\n  return ok;\n}\n\nbool mg_ota_flash_end(struct mg_flash *flash) {\n  char *base = (char *) flash->start + flash->size / 2;\n  bool ok = false;\n  if (s_size) {\n    size_t size = (size_t) (s_addr - base);\n    uint32_t crc32 = mg_crc32(0, base, s_size);\n    if (size == s_size && crc32 == s_crc32) ok = true;\n    MG_DEBUG((\"CRC: %x/%x, size: %lu/%lu, status: %s\", s_crc32, crc32, s_size,\n              size, ok ? \"ok\" : \"fail\"));\n    s_size = 0;\n    if (ok) ok = flash->swap_fn();\n  }\n  MG_INFO((\"Finishing OTA: %s\", ok ? \"ok\" : \"fail\"));\n  return ok;\n}\n\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fmt.c\"\n#endif\n\n\n\n\nstatic bool is_digit(int c) {\n  return c >= '0' && c <= '9';\n}\n\nstatic int addexp(char *buf, int e, int sign) {\n  int n = 0;\n  buf[n++] = 'e';\n  buf[n++] = (char) sign;\n  if (e > 400) return 0;\n  if (e < 10) buf[n++] = '0';\n  if (e >= 100) buf[n++] = (char) (e / 100 + '0'), e -= 100 * (e / 100);\n  if (e >= 10) buf[n++] = (char) (e / 10 + '0'), e -= 10 * (e / 10);\n  buf[n++] = (char) (e + '0');\n  return n;\n}\n\nstatic int xisinf(double x) {\n  union {\n    double f;\n    uint64_t u;\n  } ieee754 = {x};\n  return ((unsigned) (ieee754.u >> 32) & 0x7fffffff) == 0x7ff00000 &&\n         ((unsigned) ieee754.u == 0);\n}\n\nstatic int xisnan(double x) {\n  union {\n    double f;\n    uint64_t u;\n  } ieee754 = {x};\n  return ((unsigned) (ieee754.u >> 32) & 0x7fffffff) +\n             ((unsigned) ieee754.u != 0) >\n         0x7ff00000;\n}\n\nstatic size_t mg_dtoa(char *dst, size_t dstlen, double d, int width, bool tz) {\n  char buf[40];\n  int i, s = 0, n = 0, e = 0;\n  double t, mul, saved;\n  if (d == 0.0) return mg_snprintf(dst, dstlen, \"%s\", \"0\");\n  if (xisinf(d)) return mg_snprintf(dst, dstlen, \"%s\", d > 0 ? \"inf\" : \"-inf\");\n  if (xisnan(d)) return mg_snprintf(dst, dstlen, \"%s\", \"nan\");\n  if (d < 0.0) d = -d, buf[s++] = '-';\n\n  // Round\n  saved = d;\n  if (tz) {\n    mul = 1.0;\n    while (d >= 10.0 && d / mul >= 10.0) mul *= 10.0;\n  } else {\n    mul = 0.1;\n  }\n\n  while (d <= 1.0 && d / mul <= 1.0) mul /= 10.0;\n  for (i = 0, t = mul * 5; i < width; i++) t /= 10.0;\n\n  d += t;\n\n  // Calculate exponent, and 'mul' for scientific representation\n  mul = 1.0;\n  while (d >= 10.0 && d / mul >= 10.0) mul *= 10.0, e++;\n  while (d < 1.0 && d / mul < 1.0) mul /= 10.0, e--;\n  // printf(\" --> %g %d %g %g\\n\", saved, e, t, mul);\n\n  if (tz && e >= width && width > 1) {\n    n = (int) mg_dtoa(buf, sizeof(buf), saved / mul, width, tz);\n    // printf(\" --> %.*g %d [%.*s]\\n\", 10, d / t, e, n, buf);\n    n += addexp(buf + s + n, e, '+');\n    return mg_snprintf(dst, dstlen, \"%.*s\", n, buf);\n  } else if (tz && e <= -width && width > 1) {\n    n = (int) mg_dtoa(buf, sizeof(buf), saved / mul, width, tz);\n    // printf(\" --> %.*g %d [%.*s]\\n\", 10, d / mul, e, n, buf);\n    n += addexp(buf + s + n, -e, '-');\n    return mg_snprintf(dst, dstlen, \"%.*s\", n, buf);\n  } else {\n    int targ_width = width;\n    for (i = 0, t = mul; t >= 1.0 && s + n < (int) sizeof(buf); i++) {\n      int ch = (int) (d / t);\n      if (n > 0 || ch > 0) buf[s + n++] = (char) (ch + '0');\n      d -= ch * t;\n      t /= 10.0;\n    }\n    // printf(\" --> [%g] -> %g %g (%d) [%.*s]\\n\", saved, d, t, n, s + n, buf);\n    if (n == 0) buf[s++] = '0';\n    while (t >= 1.0 && n + s < (int) sizeof(buf)) buf[n++] = '0', t /= 10.0;\n    if (s + n < (int) sizeof(buf)) buf[n + s++] = '.';\n    // printf(\" 1--> [%g] -> [%.*s]\\n\", saved, s + n, buf);\n    if (!tz && n > 0) targ_width = width + n;\n    for (i = 0, t = 0.1; s + n < (int) sizeof(buf) && n < targ_width; i++) {\n      int ch = (int) (d / t);\n      buf[s + n++] = (char) (ch + '0');\n      d -= ch * t;\n      t /= 10.0;\n    }\n  }\n\n  while (tz && n > 0 && buf[s + n - 1] == '0') n--;  // Trim trailing zeroes\n  if (tz && n > 0 && buf[s + n - 1] == '.') n--;           // Trim trailing dot\n  n += s;\n  if (n >= (int) sizeof(buf)) n = (int) sizeof(buf) - 1;\n  buf[n] = '\\0';\n  return mg_snprintf(dst, dstlen, \"%s\", buf);\n}\n\nstatic size_t mg_lld(char *buf, int64_t val, bool is_signed, bool is_hex) {\n  const char *letters = \"0123456789abcdef\";\n  uint64_t v = (uint64_t) val;\n  size_t s = 0, n, i;\n  if (is_signed && val < 0) buf[s++] = '-', v = (uint64_t) (-val);\n  // This loop prints a number in reverse order. I guess this is because we\n  // write numbers from right to left: least significant digit comes last.\n  // Maybe because we use Arabic numbers, and Arabs write RTL?\n  if (is_hex) {\n    for (n = 0; v; v >>= 4) buf[s + n++] = letters[v & 15];\n  } else {\n    for (n = 0; v; v /= 10) buf[s + n++] = letters[v % 10];\n  }\n  // Reverse a string\n  for (i = 0; i < n / 2; i++) {\n    char t = buf[s + i];\n    buf[s + i] = buf[s + n - i - 1], buf[s + n - i - 1] = t;\n  }\n  if (val == 0) buf[n++] = '0';  // Handle special case\n  return n + s;\n}\n\nstatic size_t scpy(void (*out)(char, void *), void *ptr, char *buf,\n                          size_t len) {\n  size_t i = 0;\n  while (i < len && buf[i] != '\\0') out(buf[i++], ptr);\n  return i;\n}\n\nsize_t mg_xprintf(void (*out)(char, void *), void *ptr, const char *fmt, ...) {\n  size_t len = 0;\n  va_list ap;\n  va_start(ap, fmt);\n  len = mg_vxprintf(out, ptr, fmt, &ap);\n  va_end(ap);\n  return len;\n}\n\nsize_t mg_vxprintf(void (*out)(char, void *), void *param, const char *fmt,\n                   va_list *ap) {\n  size_t i = 0, n = 0;\n  while (fmt[i] != '\\0') {\n    if (fmt[i] == '%') {\n      size_t j, k, x = 0, is_long = 0, w = 0 /* width */, pr = ~0U /* prec */;\n      char pad = ' ', minus = 0, c = fmt[++i];\n      if (c == '#') x++, c = fmt[++i];\n      if (c == '-') minus++, c = fmt[++i];\n      if (c == '0') pad = '0', c = fmt[++i];\n      while (is_digit(c)) w *= 10, w += (size_t) (c - '0'), c = fmt[++i];\n      if (c == '.') {\n        c = fmt[++i];\n        if (c == '*') {\n          pr = (size_t) va_arg(*ap, int);\n          c = fmt[++i];\n        } else {\n          pr = 0;\n          while (is_digit(c)) pr *= 10, pr += (size_t) (c - '0'), c = fmt[++i];\n        }\n      }\n      while (c == 'h') c = fmt[++i];  // Treat h and hh as int\n      if (c == 'l') {\n        is_long++, c = fmt[++i];\n        if (c == 'l') is_long++, c = fmt[++i];\n      }\n      if (c == 'p') x = 1, is_long = 1;\n      if (c == 'd' || c == 'u' || c == 'x' || c == 'X' || c == 'p' ||\n          c == 'g' || c == 'f') {\n        bool s = (c == 'd'), h = (c == 'x' || c == 'X' || c == 'p');\n        char tmp[40];\n        size_t xl = x ? 2 : 0;\n        if (c == 'g' || c == 'f') {\n          double v = va_arg(*ap, double);\n          if (pr == ~0U) pr = 6;\n          k = mg_dtoa(tmp, sizeof(tmp), v, (int) pr, c == 'g');\n        } else if (is_long == 2) {\n          int64_t v = va_arg(*ap, int64_t);\n          k = mg_lld(tmp, v, s, h);\n        } else if (is_long == 1) {\n          long v = va_arg(*ap, long);\n          k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned long) v, s, h);\n        } else {\n          int v = va_arg(*ap, int);\n          k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned) v, s, h);\n        }\n        for (j = 0; j < xl && w > 0; j++) w--;\n        for (j = 0; pad == ' ' && !minus && k < w && j + k < w; j++)\n          n += scpy(out, param, &pad, 1);\n        n += scpy(out, param, (char *) \"0x\", xl);\n        for (j = 0; pad == '0' && k < w && j + k < w; j++)\n          n += scpy(out, param, &pad, 1);\n        n += scpy(out, param, tmp, k);\n        for (j = 0; pad == ' ' && minus && k < w && j + k < w; j++)\n          n += scpy(out, param, &pad, 1);\n      } else if (c == 'm' || c == 'M') {\n        mg_pm_t f = va_arg(*ap, mg_pm_t);\n        if (c == 'm') out('\"', param);\n        n += f(out, param, ap);\n        if (c == 'm') n += 2, out('\"', param);\n      } else if (c == 'c') {\n        int ch = va_arg(*ap, int);\n        out((char) ch, param);\n        n++;\n      } else if (c == 's') {\n        char *p = va_arg(*ap, char *);\n        if (pr == ~0U) pr = p == NULL ? 0 : strlen(p);\n        for (j = 0; !minus && pr < w && j + pr < w; j++)\n          n += scpy(out, param, &pad, 1);\n        n += scpy(out, param, p, pr);\n        for (j = 0; minus && pr < w && j + pr < w; j++)\n          n += scpy(out, param, &pad, 1);\n      } else if (c == '%') {\n        out('%', param);\n        n++;\n      } else {\n        out('%', param);\n        out(c, param);\n        n += 2;\n      }\n      i++;\n    } else {\n      out(fmt[i], param), n++, i++;\n    }\n  }\n  return n;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs.c\"\n#endif\n\n\n\n\nstruct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags) {\n  struct mg_fd *fd = (struct mg_fd *) calloc(1, sizeof(*fd));\n  if (fd != NULL) {\n    fd->fd = fs->op(path, flags);\n    fd->fs = fs;\n    if (fd->fd == NULL) {\n      free(fd);\n      fd = NULL;\n    }\n  }\n  return fd;\n}\n\nvoid mg_fs_close(struct mg_fd *fd) {\n  if (fd != NULL) {\n    fd->fs->cl(fd->fd);\n    free(fd);\n  }\n}\n\nstruct mg_str mg_file_read(struct mg_fs *fs, const char *path) {\n  struct mg_str result = {NULL, 0};\n  void *fp;\n  fs->st(path, &result.len, NULL);\n  if ((fp = fs->op(path, MG_FS_READ)) != NULL) {\n    result.buf = (char *) calloc(1, result.len + 1);\n    if (result.buf != NULL &&\n        fs->rd(fp, (void *) result.buf, result.len) != result.len) {\n      free((void *) result.buf);\n      result.buf = NULL;\n    }\n    fs->cl(fp);\n  }\n  if (result.buf == NULL) result.len = 0;\n  return result;\n}\n\nbool mg_file_write(struct mg_fs *fs, const char *path, const void *buf,\n                   size_t len) {\n  bool result = false;\n  struct mg_fd *fd;\n  char tmp[MG_PATH_MAX];\n  mg_snprintf(tmp, sizeof(tmp), \"%s..%d\", path, rand());\n  if ((fd = mg_fs_open(fs, tmp, MG_FS_WRITE)) != NULL) {\n    result = fs->wr(fd->fd, buf, len) == len;\n    mg_fs_close(fd);\n    if (result) {\n      fs->rm(path);\n      fs->mv(tmp, path);\n    } else {\n      fs->rm(tmp);\n    }\n  }\n  return result;\n}\n\nbool mg_file_printf(struct mg_fs *fs, const char *path, const char *fmt, ...) {\n  va_list ap;\n  char *data;\n  bool result = false;\n  va_start(ap, fmt);\n  data = mg_vmprintf(fmt, &ap);\n  va_end(ap);\n  result = mg_file_write(fs, path, data, strlen(data));\n  free(data);\n  return result;\n}\n\n// This helper function allows to scan a filesystem in a sequential way,\n// without using callback function:\n//      char buf[100] = \"\";\n//      while (mg_fs_ls(&mg_fs_posix, \"./\", buf, sizeof(buf))) {\n//        ...\nstatic void mg_fs_ls_fn(const char *filename, void *param) {\n  struct mg_str *s = (struct mg_str *) param;\n  if (s->buf[0] == '\\0') {\n    mg_snprintf((char *) s->buf, s->len, \"%s\", filename);\n  } else if (strcmp(s->buf, filename) == 0) {\n    ((char *) s->buf)[0] = '\\0';  // Fetch next file\n  }\n}\n\nbool mg_fs_ls(struct mg_fs *fs, const char *path, char *buf, size_t len) {\n  struct mg_str s = {buf, len};\n  fs->ls(path, mg_fs_ls_fn, &s);\n  return buf[0] != '\\0';\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs_fat.c\"\n#endif\n\n\n\n#if MG_ENABLE_FATFS\n#include <ff.h>\n\nstatic int mg_days_from_epoch(int y, int m, int d) {\n  y -= m <= 2;\n  int era = y / 400;\n  int yoe = y - era * 400;\n  int doy = (153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1;\n  int doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;\n  return era * 146097 + doe - 719468;\n}\n\nstatic time_t mg_timegm(const struct tm *t) {\n  int year = t->tm_year + 1900;\n  int month = t->tm_mon;  // 0-11\n  if (month > 11) {\n    year += month / 12;\n    month %= 12;\n  } else if (month < 0) {\n    int years_diff = (11 - month) / 12;\n    year -= years_diff;\n    month += 12 * years_diff;\n  }\n  int x = mg_days_from_epoch(year, month + 1, t->tm_mday);\n  return 60 * (60 * (24L * x + t->tm_hour) + t->tm_min) + t->tm_sec;\n}\n\nstatic time_t ff_time_to_epoch(uint16_t fdate, uint16_t ftime) {\n  struct tm tm;\n  memset(&tm, 0, sizeof(struct tm));\n  tm.tm_sec = (ftime << 1) & 0x3e;\n  tm.tm_min = ((ftime >> 5) & 0x3f);\n  tm.tm_hour = ((ftime >> 11) & 0x1f);\n  tm.tm_mday = (fdate & 0x1f);\n  tm.tm_mon = ((fdate >> 5) & 0x0f) - 1;\n  tm.tm_year = ((fdate >> 9) & 0x7f) + 80;\n  return mg_timegm(&tm);\n}\n\nstatic int ff_stat(const char *path, size_t *size, time_t *mtime) {\n  FILINFO fi;\n  if (path[0] == '\\0') {\n    if (size) *size = 0;\n    if (mtime) *mtime = 0;\n    return MG_FS_DIR;\n  } else if (f_stat(path, &fi) == 0) {\n    if (size) *size = (size_t) fi.fsize;\n    if (mtime) *mtime = ff_time_to_epoch(fi.fdate, fi.ftime);\n    return MG_FS_READ | MG_FS_WRITE | ((fi.fattrib & AM_DIR) ? MG_FS_DIR : 0);\n  } else {\n    return 0;\n  }\n}\n\nstatic void ff_list(const char *dir, void (*fn)(const char *, void *),\n                    void *userdata) {\n  DIR d;\n  FILINFO fi;\n  if (f_opendir(&d, dir) == FR_OK) {\n    while (f_readdir(&d, &fi) == FR_OK && fi.fname[0] != '\\0') {\n      if (!strcmp(fi.fname, \".\") || !strcmp(fi.fname, \"..\")) continue;\n      fn(fi.fname, userdata);\n    }\n    f_closedir(&d);\n  }\n}\n\nstatic void *ff_open(const char *path, int flags) {\n  FIL f;\n  unsigned char mode = FA_READ;\n  if (flags & MG_FS_WRITE) mode |= FA_WRITE | FA_OPEN_ALWAYS | FA_OPEN_APPEND;\n  if (f_open(&f, path, mode) == 0) {\n    FIL *fp;\n    if ((fp = calloc(1, sizeof(*fp))) != NULL) {\n      memcpy(fp, &f, sizeof(*fp));\n      return fp;\n    }\n  }\n  return NULL;\n}\n\nstatic void ff_close(void *fp) {\n  if (fp != NULL) {\n    f_close((FIL *) fp);\n    free(fp);\n  }\n}\n\nstatic size_t ff_read(void *fp, void *buf, size_t len) {\n  UINT n = 0, misalign = ((size_t) buf) & 3;\n  if (misalign) {\n    char aligned[4];\n    f_read((FIL *) fp, aligned, len > misalign ? misalign : len, &n);\n    memcpy(buf, aligned, n);\n  } else {\n    f_read((FIL *) fp, buf, len, &n);\n  }\n  return n;\n}\n\nstatic size_t ff_write(void *fp, const void *buf, size_t len) {\n  UINT n = 0;\n  return f_write((FIL *) fp, (char *) buf, len, &n) == FR_OK ? n : 0;\n}\n\nstatic size_t ff_seek(void *fp, size_t offset) {\n  f_lseek((FIL *) fp, offset);\n  return offset;\n}\n\nstatic bool ff_rename(const char *from, const char *to) {\n  return f_rename(from, to) == FR_OK;\n}\n\nstatic bool ff_remove(const char *path) {\n  return f_unlink(path) == FR_OK;\n}\n\nstatic bool ff_mkdir(const char *path) {\n  return f_mkdir(path) == FR_OK;\n}\n\nstruct mg_fs mg_fs_fat = {ff_stat,  ff_list, ff_open,   ff_close,  ff_read,\n                          ff_write, ff_seek, ff_rename, ff_remove, ff_mkdir};\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs_packed.c\"\n#endif\n\n\n\n\nstruct packed_file {\n  const char *data;\n  size_t size;\n  size_t pos;\n};\n\n#if MG_ENABLE_PACKED_FS\n#else\nconst char *mg_unpack(const char *path, size_t *size, time_t *mtime) {\n  if (size != NULL) *size = 0;\n  if (mtime != NULL) *mtime = 0;\n  (void) path;\n  return NULL;\n}\nconst char *mg_unlist(size_t no) {\n  (void) no;\n  return NULL;\n}\n#endif\n\nstruct mg_str mg_unpacked(const char *path) {\n  size_t len = 0;\n  const char *buf = mg_unpack(path, &len, NULL);\n  return mg_str_n(buf, len);\n}\n\nstatic int is_dir_prefix(const char *prefix, size_t n, const char *path) {\n  // MG_INFO((\"[%.*s] [%s] %c\", (int) n, prefix, path, path[n]));\n  return n < strlen(path) && strncmp(prefix, path, n) == 0 &&\n         (n == 0 || path[n] == '/' || path[n - 1] == '/');\n}\n\nstatic int packed_stat(const char *path, size_t *size, time_t *mtime) {\n  const char *p;\n  size_t i, n = strlen(path);\n  if (mg_unpack(path, size, mtime)) return MG_FS_READ;  // Regular file\n  // Scan all files. If `path` is a dir prefix for any of them, it's a dir\n  for (i = 0; (p = mg_unlist(i)) != NULL; i++) {\n    if (is_dir_prefix(path, n, p)) return MG_FS_DIR;\n  }\n  return 0;\n}\n\nstatic void packed_list(const char *dir, void (*fn)(const char *, void *),\n                        void *userdata) {\n  char buf[MG_PATH_MAX], tmp[sizeof(buf)];\n  const char *path, *begin, *end;\n  size_t i, n = strlen(dir);\n  tmp[0] = '\\0';  // Previously listed entry\n  for (i = 0; (path = mg_unlist(i)) != NULL; i++) {\n    if (!is_dir_prefix(dir, n, path)) continue;\n    begin = &path[n + 1];\n    end = strchr(begin, '/');\n    if (end == NULL) end = begin + strlen(begin);\n    mg_snprintf(buf, sizeof(buf), \"%.*s\", (int) (end - begin), begin);\n    buf[sizeof(buf) - 1] = '\\0';\n    // If this entry has been already listed, skip\n    // NOTE: we're assuming that file list is sorted alphabetically\n    if (strcmp(buf, tmp) == 0) continue;\n    fn(buf, userdata);  // Not yet listed, call user function\n    strcpy(tmp, buf);   // And save this entry as listed\n  }\n}\n\nstatic void *packed_open(const char *path, int flags) {\n  size_t size = 0;\n  const char *data = mg_unpack(path, &size, NULL);\n  struct packed_file *fp = NULL;\n  if (data == NULL) return NULL;\n  if (flags & MG_FS_WRITE) return NULL;\n  if ((fp = (struct packed_file *) calloc(1, sizeof(*fp))) != NULL) {\n    fp->size = size;\n    fp->data = data;\n  }\n  return (void *) fp;\n}\n\nstatic void packed_close(void *fp) {\n  if (fp != NULL) free(fp);\n}\n\nstatic size_t packed_read(void *fd, void *buf, size_t len) {\n  struct packed_file *fp = (struct packed_file *) fd;\n  if (fp->pos + len > fp->size) len = fp->size - fp->pos;\n  memcpy(buf, &fp->data[fp->pos], len);\n  fp->pos += len;\n  return len;\n}\n\nstatic size_t packed_write(void *fd, const void *buf, size_t len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\n\nstatic size_t packed_seek(void *fd, size_t offset) {\n  struct packed_file *fp = (struct packed_file *) fd;\n  fp->pos = offset;\n  if (fp->pos > fp->size) fp->pos = fp->size;\n  return fp->pos;\n}\n\nstatic bool packed_rename(const char *from, const char *to) {\n  (void) from, (void) to;\n  return false;\n}\n\nstatic bool packed_remove(const char *path) {\n  (void) path;\n  return false;\n}\n\nstatic bool packed_mkdir(const char *path) {\n  (void) path;\n  return false;\n}\n\nstruct mg_fs mg_fs_packed = {\n    packed_stat,  packed_list, packed_open,   packed_close,  packed_read,\n    packed_write, packed_seek, packed_rename, packed_remove, packed_mkdir};\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs_posix.c\"\n#endif\n\n\n#if MG_ENABLE_POSIX_FS\n\n#ifndef MG_STAT_STRUCT\n#define MG_STAT_STRUCT stat\n#endif\n\n#ifndef MG_STAT_FUNC\n#define MG_STAT_FUNC stat\n#endif\n\nstatic int p_stat(const char *path, size_t *size, time_t *mtime) {\n#if !defined(S_ISDIR)\n  MG_ERROR((\"stat() API is not supported. %p %p %p\", path, size, mtime));\n  return 0;\n#else\n#if MG_ARCH == MG_ARCH_WIN32\n  struct _stati64 st;\n  wchar_t tmp[MG_PATH_MAX];\n  MultiByteToWideChar(CP_UTF8, 0, path, -1, tmp, sizeof(tmp) / sizeof(tmp[0]));\n  if (_wstati64(tmp, &st) != 0) return 0;\n  // If path is a symlink, windows reports 0 in st.st_size.\n  // Get a real file size by opening it and jumping to the end\n  if (st.st_size == 0 && (st.st_mode & _S_IFREG)) {\n    FILE *fp = _wfopen(tmp, L\"rb\");\n    if (fp != NULL) {\n      fseek(fp, 0, SEEK_END);\n      if (ftell(fp) > 0) st.st_size = ftell(fp);  // Use _ftelli64 on win10+\n      fclose(fp);\n    }\n  }\n#else\n  struct MG_STAT_STRUCT st;\n  if (MG_STAT_FUNC(path, &st) != 0) return 0;\n#endif\n  if (size) *size = (size_t) st.st_size;\n  if (mtime) *mtime = st.st_mtime;\n  return MG_FS_READ | MG_FS_WRITE | (S_ISDIR(st.st_mode) ? MG_FS_DIR : 0);\n#endif\n}\n\n#if MG_ARCH == MG_ARCH_WIN32\nstruct dirent {\n  char d_name[MAX_PATH];\n};\n\ntypedef struct win32_dir {\n  HANDLE handle;\n  WIN32_FIND_DATAW info;\n  struct dirent result;\n} DIR;\n\n#if 0\nint gettimeofday(struct timeval *tv, void *tz) {\n  FILETIME ft;\n  unsigned __int64 tmpres = 0;\n\n  if (tv != NULL) {\n    GetSystemTimeAsFileTime(&ft);\n    tmpres |= ft.dwHighDateTime;\n    tmpres <<= 32;\n    tmpres |= ft.dwLowDateTime;\n    tmpres /= 10;  // convert into microseconds\n    tmpres -= (int64_t) 11644473600000000;\n    tv->tv_sec = (long) (tmpres / 1000000UL);\n    tv->tv_usec = (long) (tmpres % 1000000UL);\n  }\n  (void) tz;\n  return 0;\n}\n#endif\n\nstatic int to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {\n  int ret;\n  char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;\n  strncpy(buf, path, sizeof(buf));\n  buf[sizeof(buf) - 1] = '\\0';\n  // Trim trailing slashes. Leave backslash for paths like \"X:\\\"\n  p = buf + strlen(buf) - 1;\n  while (p > buf && p[-1] != ':' && (p[0] == '\\\\' || p[0] == '/')) *p-- = '\\0';\n  memset(wbuf, 0, wbuf_len * sizeof(wchar_t));\n  ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);\n  // Convert back to Unicode. If doubly-converted string does not match the\n  // original, something is fishy, reject.\n  WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),\n                      NULL, NULL);\n  if (strcmp(buf, buf2) != 0) {\n    wbuf[0] = L'\\0';\n    ret = 0;\n  }\n  return ret;\n}\n\nDIR *opendir(const char *name) {\n  DIR *d = NULL;\n  wchar_t wpath[MAX_PATH];\n  DWORD attrs;\n\n  if (name == NULL) {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  } else if ((d = (DIR *) calloc(1, sizeof(*d))) == NULL) {\n    SetLastError(ERROR_NOT_ENOUGH_MEMORY);\n  } else {\n    to_wchar(name, wpath, sizeof(wpath) / sizeof(wpath[0]));\n    attrs = GetFileAttributesW(wpath);\n    if (attrs != 0Xffffffff && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {\n      (void) wcscat(wpath, L\"\\\\*\");\n      d->handle = FindFirstFileW(wpath, &d->info);\n      d->result.d_name[0] = '\\0';\n    } else {\n      free(d);\n      d = NULL;\n    }\n  }\n  return d;\n}\n\nint closedir(DIR *d) {\n  int result = 0;\n  if (d != NULL) {\n    if (d->handle != INVALID_HANDLE_VALUE)\n      result = FindClose(d->handle) ? 0 : -1;\n    free(d);\n  } else {\n    result = -1;\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n  return result;\n}\n\nstruct dirent *readdir(DIR *d) {\n  struct dirent *result = NULL;\n  if (d != NULL) {\n    memset(&d->result, 0, sizeof(d->result));\n    if (d->handle != INVALID_HANDLE_VALUE) {\n      result = &d->result;\n      WideCharToMultiByte(CP_UTF8, 0, d->info.cFileName, -1, result->d_name,\n                          sizeof(result->d_name), NULL, NULL);\n      if (!FindNextFileW(d->handle, &d->info)) {\n        FindClose(d->handle);\n        d->handle = INVALID_HANDLE_VALUE;\n      }\n    } else {\n      SetLastError(ERROR_FILE_NOT_FOUND);\n    }\n  } else {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n  return result;\n}\n#endif\n\nstatic void p_list(const char *dir, void (*fn)(const char *, void *),\n                   void *userdata) {\n#if MG_ENABLE_DIRLIST\n  struct dirent *dp;\n  DIR *dirp;\n  if ((dirp = (opendir(dir))) == NULL) return;\n  while ((dp = readdir(dirp)) != NULL) {\n    if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) continue;\n    fn(dp->d_name, userdata);\n  }\n  closedir(dirp);\n#else\n  (void) dir, (void) fn, (void) userdata;\n#endif\n}\n\nstatic void *p_open(const char *path, int flags) {\n#if MG_ARCH == MG_ARCH_WIN32\n  const char *mode = flags == MG_FS_READ ? \"rb\" : \"a+b\";\n  wchar_t b1[MG_PATH_MAX], b2[10];\n  MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));\n  MultiByteToWideChar(CP_UTF8, 0, mode, -1, b2, sizeof(b2) / sizeof(b2[0]));\n  return (void *) _wfopen(b1, b2);\n#else\n  const char *mode = flags == MG_FS_READ ? \"rbe\" : \"a+be\";  // e for CLOEXEC\n  return (void *) fopen(path, mode);\n#endif\n}\n\nstatic void p_close(void *fp) {\n  fclose((FILE *) fp);\n}\n\nstatic size_t p_read(void *fp, void *buf, size_t len) {\n  return fread(buf, 1, len, (FILE *) fp);\n}\n\nstatic size_t p_write(void *fp, const void *buf, size_t len) {\n  return fwrite(buf, 1, len, (FILE *) fp);\n}\n\nstatic size_t p_seek(void *fp, size_t offset) {\n#if (defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64) ||  \\\n    (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200112L) || \\\n    (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 600)\n  if (fseeko((FILE *) fp, (off_t) offset, SEEK_SET) != 0) (void) 0;\n#else\n  if (fseek((FILE *) fp, (long) offset, SEEK_SET) != 0) (void) 0;\n#endif\n  return (size_t) ftell((FILE *) fp);\n}\n\nstatic bool p_rename(const char *from, const char *to) {\n  return rename(from, to) == 0;\n}\n\nstatic bool p_remove(const char *path) {\n  return remove(path) == 0;\n}\n\nstatic bool p_mkdir(const char *path) {\n  return mkdir(path, 0775) == 0;\n}\n\n#else\n\nstatic int p_stat(const char *path, size_t *size, time_t *mtime) {\n  (void) path, (void) size, (void) mtime;\n  return 0;\n}\nstatic void p_list(const char *path, void (*fn)(const char *, void *),\n                   void *userdata) {\n  (void) path, (void) fn, (void) userdata;\n}\nstatic void *p_open(const char *path, int flags) {\n  (void) path, (void) flags;\n  return NULL;\n}\nstatic void p_close(void *fp) {\n  (void) fp;\n}\nstatic size_t p_read(void *fd, void *buf, size_t len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\nstatic size_t p_write(void *fd, const void *buf, size_t len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\nstatic size_t p_seek(void *fd, size_t offset) {\n  (void) fd, (void) offset;\n  return (size_t) ~0;\n}\nstatic bool p_rename(const char *from, const char *to) {\n  (void) from, (void) to;\n  return false;\n}\nstatic bool p_remove(const char *path) {\n  (void) path;\n  return false;\n}\nstatic bool p_mkdir(const char *path) {\n  (void) path;\n  return false;\n}\n#endif\n\nstruct mg_fs mg_fs_posix = {p_stat,  p_list, p_open,   p_close,  p_read,\n                            p_write, p_seek, p_rename, p_remove, p_mkdir};\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/http.c\"\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatic int mg_ncasecmp(const char *s1, const char *s2, size_t len) {\n  int diff = 0;\n  if (len > 0) do {\n      int c = *s1++, d = *s2++;\n      if (c >= 'A' && c <= 'Z') c += 'a' - 'A';\n      if (d >= 'A' && d <= 'Z') d += 'a' - 'A';\n      diff = c - d;\n    } while (diff == 0 && s1[-1] != '\\0' && --len > 0);\n  return diff;\n}\n\nbool mg_to_size_t(struct mg_str str, size_t *val);\nbool mg_to_size_t(struct mg_str str, size_t *val) {\n  size_t i = 0, max = (size_t) -1, max2 = max / 10, result = 0, ndigits = 0;\n  while (i < str.len && (str.buf[i] == ' ' || str.buf[i] == '\\t')) i++;\n  if (i < str.len && str.buf[i] == '-') return false;\n  while (i < str.len && str.buf[i] >= '0' && str.buf[i] <= '9') {\n    size_t digit = (size_t) (str.buf[i] - '0');\n    if (result > max2) return false;  // Overflow\n    result *= 10;\n    if (result > max - digit) return false;  // Overflow\n    result += digit;\n    i++, ndigits++;\n  }\n  while (i < str.len && (str.buf[i] == ' ' || str.buf[i] == '\\t')) i++;\n  if (ndigits == 0) return false;  // #2322: Content-Length = 1 * DIGIT\n  if (i != str.len) return false;  // Ditto\n  *val = (size_t) result;\n  return true;\n}\n\n// Chunk deletion marker is the MSB in the \"processed\" counter\n#define MG_DMARK ((size_t) 1 << (sizeof(size_t) * 8 - 1))\n\n// Multipart POST example:\n// --xyz\n// Content-Disposition: form-data; name=\"val\"\n//\n// abcdef\n// --xyz\n// Content-Disposition: form-data; name=\"foo\"; filename=\"a.txt\"\n// Content-Type: text/plain\n//\n// hello world\n//\n// --xyz--\nsize_t mg_http_next_multipart(struct mg_str body, size_t ofs,\n                              struct mg_http_part *part) {\n  struct mg_str cd = mg_str_n(\"Content-Disposition\", 19);\n  const char *s = body.buf;\n  size_t b = ofs, h1, h2, b1, b2, max = body.len;\n\n  // Init part params\n  if (part != NULL) part->name = part->filename = part->body = mg_str_n(0, 0);\n\n  // Skip boundary\n  while (b + 2 < max && s[b] != '\\r' && s[b + 1] != '\\n') b++;\n  if (b <= ofs || b + 2 >= max) return 0;\n  // MG_INFO((\"B: %zu %zu [%.*s]\", ofs, b - ofs, (int) (b - ofs), s));\n\n  // Skip headers\n  h1 = h2 = b + 2;\n  for (;;) {\n    while (h2 + 2 < max && s[h2] != '\\r' && s[h2 + 1] != '\\n') h2++;\n    if (h2 == h1) break;\n    if (h2 + 2 >= max) return 0;\n    // MG_INFO((\"Header: [%.*s]\", (int) (h2 - h1), &s[h1]));\n    if (part != NULL && h1 + cd.len + 2 < h2 && s[h1 + cd.len] == ':' &&\n        mg_ncasecmp(&s[h1], cd.buf, cd.len) == 0) {\n      struct mg_str v = mg_str_n(&s[h1 + cd.len + 2], h2 - (h1 + cd.len + 2));\n      part->name = mg_http_get_header_var(v, mg_str_n(\"name\", 4));\n      part->filename = mg_http_get_header_var(v, mg_str_n(\"filename\", 8));\n    }\n    h1 = h2 = h2 + 2;\n  }\n  b1 = b2 = h2 + 2;\n  while (b2 + 2 + (b - ofs) + 2 < max && !(s[b2] == '\\r' && s[b2 + 1] == '\\n' &&\n                                           memcmp(&s[b2 + 2], s, b - ofs) == 0))\n    b2++;\n\n  if (b2 + 2 >= max) return 0;\n  if (part != NULL) part->body = mg_str_n(&s[b1], b2 - b1);\n  // MG_INFO((\"Body: [%.*s]\", (int) (b2 - b1), &s[b1]));\n  return b2 + 2;\n}\n\nvoid mg_http_bauth(struct mg_connection *c, const char *user,\n                   const char *pass) {\n  struct mg_str u = mg_str(user), p = mg_str(pass);\n  size_t need = c->send.len + 36 + (u.len + p.len) * 2;\n  if (c->send.size < need) mg_iobuf_resize(&c->send, need);\n  if (c->send.size >= need) {\n    size_t i, n = 0;\n    char *buf = (char *) &c->send.buf[c->send.len];\n    memcpy(buf, \"Authorization: Basic \", 21);  // DON'T use mg_send!\n    for (i = 0; i < u.len; i++) {\n      n = mg_base64_update(((unsigned char *) u.buf)[i], buf + 21, n);\n    }\n    if (p.len > 0) {\n      n = mg_base64_update(':', buf + 21, n);\n      for (i = 0; i < p.len; i++) {\n        n = mg_base64_update(((unsigned char *) p.buf)[i], buf + 21, n);\n      }\n    }\n    n = mg_base64_final(buf + 21, n);\n    c->send.len += 21 + (size_t) n + 2;\n    memcpy(&c->send.buf[c->send.len - 2], \"\\r\\n\", 2);\n  } else {\n    MG_ERROR((\"%lu oom %d->%d \", c->id, (int) c->send.size, (int) need));\n  }\n}\n\nstruct mg_str mg_http_var(struct mg_str buf, struct mg_str name) {\n  struct mg_str entry, k, v, result = mg_str_n(NULL, 0);\n  while (mg_span(buf, &entry, &buf, '&')) {\n    if (mg_span(entry, &k, &v, '=') && name.len == k.len &&\n        mg_ncasecmp(name.buf, k.buf, k.len) == 0) {\n      result = v;\n      break;\n    }\n  }\n  return result;\n}\n\nint mg_http_get_var(const struct mg_str *buf, const char *name, char *dst,\n                    size_t dst_len) {\n  int len;\n  if (dst != NULL && dst_len > 0) {\n    dst[0] = '\\0';  // If destination buffer is valid, always nul-terminate it\n  }\n  if (dst == NULL || dst_len == 0) {\n    len = -2;  // Bad destination\n  } else if (buf->buf == NULL || name == NULL || buf->len == 0) {\n    len = -1;  // Bad source\n  } else {\n    struct mg_str v = mg_http_var(*buf, mg_str(name));\n    if (v.buf == NULL) {\n      len = -4;  // Name does not exist\n    } else {\n      len = mg_url_decode(v.buf, v.len, dst, dst_len, 1);\n      if (len < 0) len = -3;  // Failed to decode\n    }\n  }\n  return len;\n}\n\nstatic bool isx(int c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||\n         (c >= 'A' && c <= 'F');\n}\n\nint mg_url_decode(const char *src, size_t src_len, char *dst, size_t dst_len,\n                  int is_form_url_encoded) {\n  size_t i, j;\n  for (i = j = 0; i < src_len && j + 1 < dst_len; i++, j++) {\n    if (src[i] == '%') {\n      // Use `i + 2 < src_len`, not `i < src_len - 2`, note small src_len\n      if (i + 2 < src_len && isx(src[i + 1]) && isx(src[i + 2])) {\n        mg_str_to_num(mg_str_n(src + i + 1, 2), 16, &dst[j], sizeof(uint8_t));\n        i += 2;\n      } else {\n        return -1;\n      }\n    } else if (is_form_url_encoded && src[i] == '+') {\n      dst[j] = ' ';\n    } else {\n      dst[j] = src[i];\n    }\n  }\n  if (j < dst_len) dst[j] = '\\0';  // Null-terminate the destination\n  return i >= src_len && j < dst_len ? (int) j : -1;\n}\n\nstatic bool isok(uint8_t c) {\n  return c == '\\n' || c == '\\r' || c == '\\t' || c >= ' ';\n}\n\nint mg_http_get_request_len(const unsigned char *buf, size_t buf_len) {\n  size_t i;\n  for (i = 0; i < buf_len; i++) {\n    if (!isok(buf[i])) return -1;\n    if ((i > 0 && buf[i] == '\\n' && buf[i - 1] == '\\n') ||\n        (i > 3 && buf[i] == '\\n' && buf[i - 1] == '\\r' && buf[i - 2] == '\\n'))\n      return (int) i + 1;\n  }\n  return 0;\n}\nstruct mg_str *mg_http_get_header(struct mg_http_message *h, const char *name) {\n  size_t i, n = strlen(name), max = sizeof(h->headers) / sizeof(h->headers[0]);\n  for (i = 0; i < max && h->headers[i].name.len > 0; i++) {\n    struct mg_str *k = &h->headers[i].name, *v = &h->headers[i].value;\n    if (n == k->len && mg_ncasecmp(k->buf, name, n) == 0) return v;\n  }\n  return NULL;\n}\n\n// Is it a valid utf-8 continuation byte\nstatic bool vcb(uint8_t c) {\n  return (c & 0xc0) == 0x80;\n}\n\n// Get character length (valid utf-8). Used to parse method, URI, headers\nstatic size_t clen(const char *s, const char *end) {\n  const unsigned char *u = (unsigned char *) s, c = *u;\n  long n = (long) (end - s);\n  if (c > ' ' && c < '~') return 1;  // Usual ascii printed char\n  if ((c & 0xe0) == 0xc0 && n > 1 && vcb(u[1])) return 2;  // 2-byte UTF8\n  if ((c & 0xf0) == 0xe0 && n > 2 && vcb(u[1]) && vcb(u[2])) return 3;\n  if ((c & 0xf8) == 0xf0 && n > 3 && vcb(u[1]) && vcb(u[2]) && vcb(u[3]))\n    return 4;\n  return 0;\n}\n\n// Skip until the newline. Return advanced `s`, or NULL on error\nstatic const char *skiptorn(const char *s, const char *end, struct mg_str *v) {\n  v->buf = (char *) s;\n  while (s < end && s[0] != '\\n' && s[0] != '\\r') s++, v->len++;  // To newline\n  if (s >= end || (s[0] == '\\r' && s[1] != '\\n')) return NULL;    // Stray \\r\n  if (s < end && s[0] == '\\r') s++;                               // Skip \\r\n  if (s >= end || *s++ != '\\n') return NULL;                      // Skip \\n\n  return s;\n}\n\nstatic bool mg_http_parse_headers(const char *s, const char *end,\n                                  struct mg_http_header *h, size_t max_hdrs) {\n  size_t i, n;\n  for (i = 0; i < max_hdrs; i++) {\n    struct mg_str k = {NULL, 0}, v = {NULL, 0};\n    if (s >= end) return false;\n    if (s[0] == '\\n' || (s[0] == '\\r' && s[1] == '\\n')) break;\n    k.buf = (char *) s;\n    while (s < end && s[0] != ':' && (n = clen(s, end)) > 0) s += n, k.len += n;\n    if (k.len == 0) return false;                     // Empty name\n    if (s >= end || clen(s, end) == 0) return false;  // Invalid UTF-8\n    if (*s++ != ':') return false;  // Invalid, not followed by :\n    // if (clen(s, end) == 0) return false;        // Invalid UTF-8\n    while (s < end && (s[0] == ' ' || s[0] == '\\t')) s++;  // Skip spaces\n    if ((s = skiptorn(s, end, &v)) == NULL) return false;\n    while (v.len > 0 && (v.buf[v.len - 1] == ' ' || v.buf[v.len - 1] == '\\t')) {\n      v.len--;  // Trim spaces\n    }\n    // MG_INFO((\"--HH [%.*s] [%.*s]\", (int) k.len, k.buf, (int) v.len, v.buf));\n    h[i].name = k, h[i].value = v;  // Success. Assign values\n  }\n  return true;\n}\n\nint mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s == NULL ? NULL : s + req_len, *qs;  // Cannot add to NULL\n  const struct mg_str *cl;\n  size_t n;\n  bool version_prefix_valid;\n\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n\n  hm->message.buf = hm->head.buf = (char *) s;\n  hm->body.buf = (char *) end;\n  hm->head.len = (size_t) req_len;\n  hm->message.len = hm->body.len = (size_t) -1;  // Set body length to infinite\n\n  // Parse request line\n  hm->method.buf = (char *) s;\n  while (s < end && (n = clen(s, end)) > 0) s += n, hm->method.len += n;\n  while (s < end && s[0] == ' ') s++;  // Skip spaces\n  hm->uri.buf = (char *) s;\n  while (s < end && (n = clen(s, end)) > 0) s += n, hm->uri.len += n;\n  while (s < end && s[0] == ' ') s++;  // Skip spaces\n  is_response = hm->method.len > 5 &&\n                (mg_ncasecmp(hm->method.buf, \"HTTP/\", 5) == 0);\n  if ((s = skiptorn(s, end, &hm->proto)) == NULL) return false;\n  // If we're given a version, check that it is HTTP/x.x\n  version_prefix_valid = hm->proto.len > 5 &&\n                         (mg_ncasecmp(hm->proto.buf, \"HTTP/\", 5) == 0);\n  if (!is_response && hm->proto.len > 0 &&\n    (!version_prefix_valid || hm->proto.len != 8 ||\n    (hm->proto.buf[5] < '0' || hm->proto.buf[5] > '9') ||\n    (hm->proto.buf[6] != '.') ||\n    (hm->proto.buf[7] < '0' || hm->proto.buf[7] > '9'))) {\n    return -1;\n  }\n\n  // If URI contains '?' character, setup query string\n  if ((qs = (const char *) memchr(hm->uri.buf, '?', hm->uri.len)) != NULL) {\n    hm->query.buf = (char *) qs + 1;\n    hm->query.len = (size_t) (&hm->uri.buf[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.buf);\n  }\n\n  // Sanity check. Allow protocol/reason to be empty\n  // Do this check after hm->method.len and hm->uri.len are finalised\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n\n  if (!mg_http_parse_headers(s, end, hm->headers,\n                             sizeof(hm->headers) / sizeof(hm->headers[0])))\n    return -1;  // error when parsing\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    if (mg_to_size_t(*cl, &hm->body.len) == false) return -1;\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n\n  // mg_http_parse() is used to parse both HTTP requests and HTTP\n  // responses. If HTTP response does not have Content-Length set, then\n  // body is read until socket is closed, i.e. body.len is infinite (~0).\n  //\n  // For HTTP requests though, according to\n  // http://tools.ietf.org/html/rfc7231#section-8.1.3,\n  // only POST and PUT methods have defined body semantics.\n  // Therefore, if Content-Length is not specified and methods are\n  // not one of PUT or POST, set body length to 0.\n  //\n  // So, if it is HTTP request, and Content-Length is not set,\n  // and method is not (PUT or POST) then reset body length to zero.\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_strcasecmp(hm->method, mg_str(\"PUT\")) != 0 &&\n      mg_strcasecmp(hm->method, mg_str(\"POST\")) != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  // The 204 (No content) responses also have 0 body length\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_strcasecmp(hm->uri, mg_str(\"204\")) == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n  if (hm->message.len < (size_t) req_len) return -1;  // Overflow protection\n\n  return req_len;\n}\n\nstatic void mg_http_vprintf_chunk(struct mg_connection *c, const char *fmt,\n                                  va_list *ap) {\n  size_t len = c->send.len;\n  mg_send(c, \"        \\r\\n\", 10);\n  mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);\n  if (c->send.len >= len + 10) {\n    mg_snprintf((char *) c->send.buf + len, 9, \"%08lx\", c->send.len - len - 10);\n    c->send.buf[len + 8] = '\\r';\n    if (c->send.len == len + 10) c->is_resp = 0;  // Last chunk, reset marker\n  }\n  mg_send(c, \"\\r\\n\", 2);\n}\n\nvoid mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_http_vprintf_chunk(c, fmt, &ap);\n  va_end(ap);\n}\n\nvoid mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len) {\n  mg_printf(c, \"%lx\\r\\n\", (unsigned long) len);\n  mg_send(c, buf, len);\n  mg_send(c, \"\\r\\n\", 2);\n  if (len == 0) c->is_resp = 0;\n}\n\n// clang-format off\nstatic const char *mg_http_status_code_str(int status_code) {\n  switch (status_code) {\n    case 100: return \"Continue\";\n    case 101: return \"Switching Protocols\";\n    case 102: return \"Processing\";\n    case 200: return \"OK\";\n    case 201: return \"Created\";\n    case 202: return \"Accepted\";\n    case 203: return \"Non-authoritative Information\";\n    case 204: return \"No Content\";\n    case 205: return \"Reset Content\";\n    case 206: return \"Partial Content\";\n    case 207: return \"Multi-Status\";\n    case 208: return \"Already Reported\";\n    case 226: return \"IM Used\";\n    case 300: return \"Multiple Choices\";\n    case 301: return \"Moved Permanently\";\n    case 302: return \"Found\";\n    case 303: return \"See Other\";\n    case 304: return \"Not Modified\";\n    case 305: return \"Use Proxy\";\n    case 307: return \"Temporary Redirect\";\n    case 308: return \"Permanent Redirect\";\n    case 400: return \"Bad Request\";\n    case 401: return \"Unauthorized\";\n    case 402: return \"Payment Required\";\n    case 403: return \"Forbidden\";\n    case 404: return \"Not Found\";\n    case 405: return \"Method Not Allowed\";\n    case 406: return \"Not Acceptable\";\n    case 407: return \"Proxy Authentication Required\";\n    case 408: return \"Request Timeout\";\n    case 409: return \"Conflict\";\n    case 410: return \"Gone\";\n    case 411: return \"Length Required\";\n    case 412: return \"Precondition Failed\";\n    case 413: return \"Payload Too Large\";\n    case 414: return \"Request-URI Too Long\";\n    case 415: return \"Unsupported Media Type\";\n    case 416: return \"Requested Range Not Satisfiable\";\n    case 417: return \"Expectation Failed\";\n    case 418: return \"I'm a teapot\";\n    case 421: return \"Misdirected Request\";\n    case 422: return \"Unprocessable Entity\";\n    case 423: return \"Locked\";\n    case 424: return \"Failed Dependency\";\n    case 426: return \"Upgrade Required\";\n    case 428: return \"Precondition Required\";\n    case 429: return \"Too Many Requests\";\n    case 431: return \"Request Header Fields Too Large\";\n    case 444: return \"Connection Closed Without Response\";\n    case 451: return \"Unavailable For Legal Reasons\";\n    case 499: return \"Client Closed Request\";\n    case 500: return \"Internal Server Error\";\n    case 501: return \"Not Implemented\";\n    case 502: return \"Bad Gateway\";\n    case 503: return \"Service Unavailable\";\n    case 504: return \"Gateway Timeout\";\n    case 505: return \"HTTP Version Not Supported\";\n    case 506: return \"Variant Also Negotiates\";\n    case 507: return \"Insufficient Storage\";\n    case 508: return \"Loop Detected\";\n    case 510: return \"Not Extended\";\n    case 511: return \"Network Authentication Required\";\n    case 599: return \"Network Connect Timeout Error\";\n    default: return \"\";\n  }\n}\n// clang-format on\n\nvoid mg_http_reply(struct mg_connection *c, int code, const char *headers,\n                   const char *fmt, ...) {\n  va_list ap;\n  size_t len;\n  mg_printf(c, \"HTTP/1.1 %d %s\\r\\n%sContent-Length:            \\r\\n\\r\\n\", code,\n            mg_http_status_code_str(code), headers == NULL ? \"\" : headers);\n  len = c->send.len;\n  va_start(ap, fmt);\n  mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, &ap);\n  va_end(ap);\n  if (c->send.len > 16) {\n    size_t n = mg_snprintf((char *) &c->send.buf[len - 15], 11, \"%-10lu\",\n                           (unsigned long) (c->send.len - len));\n    c->send.buf[len - 15 + n] = ' ';  // Change ending 0 to space\n  }\n  c->is_resp = 0;\n}\n\nstatic void http_cb(struct mg_connection *, int, void *);\nstatic void restore_http_cb(struct mg_connection *c) {\n  mg_fs_close((struct mg_fd *) c->pfn_data);\n  c->pfn_data = NULL;\n  c->pfn = http_cb;\n  c->is_resp = 0;\n}\n\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime);\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {\n  mg_snprintf(buf, len, \"\\\"%lld.%lld\\\"\", (int64_t) mtime, (int64_t) size);\n  return buf;\n}\n\nstatic void static_cb(struct mg_connection *c, int ev, void *ev_data) {\n  if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {\n    struct mg_fd *fd = (struct mg_fd *) c->pfn_data;\n    // Read to send IO buffer directly, avoid extra on-stack buffer\n    size_t n, max = MG_IO_SIZE, space;\n    size_t *cl = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /\n                                     sizeof(size_t) * sizeof(size_t)];\n    if (c->send.size < max) mg_iobuf_resize(&c->send, max);\n    if (c->send.len >= c->send.size) return;  // Rate limit\n    if ((space = c->send.size - c->send.len) > *cl) space = *cl;\n    n = fd->fs->rd(fd->fd, c->send.buf + c->send.len, space);\n    c->send.len += n;\n    *cl -= n;\n    if (n == 0) restore_http_cb(c);\n  } else if (ev == MG_EV_CLOSE) {\n    restore_http_cb(c);\n  }\n  (void) ev_data;\n}\n\n// Known mime types. Keep it outside guess_content_type() function, since\n// some environments don't like it defined there.\n// clang-format off\n#define MG_C_STR(a) { (char *) (a), sizeof(a) - 1 }\nstatic struct mg_str s_known_types[] = {\n    MG_C_STR(\"html\"), MG_C_STR(\"text/html; charset=utf-8\"),\n    MG_C_STR(\"htm\"), MG_C_STR(\"text/html; charset=utf-8\"),\n    MG_C_STR(\"css\"), MG_C_STR(\"text/css; charset=utf-8\"),\n    MG_C_STR(\"js\"), MG_C_STR(\"text/javascript; charset=utf-8\"),\n    MG_C_STR(\"gif\"), MG_C_STR(\"image/gif\"),\n    MG_C_STR(\"png\"), MG_C_STR(\"image/png\"),\n    MG_C_STR(\"jpg\"), MG_C_STR(\"image/jpeg\"),\n    MG_C_STR(\"jpeg\"), MG_C_STR(\"image/jpeg\"),\n    MG_C_STR(\"woff\"), MG_C_STR(\"font/woff\"),\n    MG_C_STR(\"ttf\"), MG_C_STR(\"font/ttf\"),\n    MG_C_STR(\"svg\"), MG_C_STR(\"image/svg+xml\"),\n    MG_C_STR(\"txt\"), MG_C_STR(\"text/plain; charset=utf-8\"),\n    MG_C_STR(\"avi\"), MG_C_STR(\"video/x-msvideo\"),\n    MG_C_STR(\"csv\"), MG_C_STR(\"text/csv\"),\n    MG_C_STR(\"doc\"), MG_C_STR(\"application/msword\"),\n    MG_C_STR(\"exe\"), MG_C_STR(\"application/octet-stream\"),\n    MG_C_STR(\"gz\"), MG_C_STR(\"application/gzip\"),\n    MG_C_STR(\"ico\"), MG_C_STR(\"image/x-icon\"),\n    MG_C_STR(\"json\"), MG_C_STR(\"application/json\"),\n    MG_C_STR(\"mov\"), MG_C_STR(\"video/quicktime\"),\n    MG_C_STR(\"mp3\"), MG_C_STR(\"audio/mpeg\"),\n    MG_C_STR(\"mp4\"), MG_C_STR(\"video/mp4\"),\n    MG_C_STR(\"mpeg\"), MG_C_STR(\"video/mpeg\"),\n    MG_C_STR(\"pdf\"), MG_C_STR(\"application/pdf\"),\n    MG_C_STR(\"shtml\"), MG_C_STR(\"text/html; charset=utf-8\"),\n    MG_C_STR(\"tgz\"), MG_C_STR(\"application/tar-gz\"),\n    MG_C_STR(\"wav\"), MG_C_STR(\"audio/wav\"),\n    MG_C_STR(\"webp\"), MG_C_STR(\"image/webp\"),\n    MG_C_STR(\"zip\"), MG_C_STR(\"application/zip\"),\n    MG_C_STR(\"3gp\"), MG_C_STR(\"video/3gpp\"),\n    {0, 0},\n};\n// clang-format on\n\nstatic struct mg_str guess_content_type(struct mg_str path, const char *extra) {\n  struct mg_str entry, k, v, s = mg_str(extra), asterisk = mg_str_n(\"*\", 1);\n  size_t i = 0;\n\n  // Shrink path to its extension only\n  while (i < path.len && path.buf[path.len - i - 1] != '.') i++;\n  path.buf += path.len - i;\n  path.len = i;\n\n  // Process user-provided mime type overrides, if any\n  while (mg_span(s, &entry, &s, ',')) {\n    if (mg_span(entry, &k, &v, '=') &&\n        (mg_strcmp(asterisk, k) == 0 || mg_strcmp(path, k) == 0))\n      return v;\n  }\n\n  // Process built-in mime types\n  for (i = 0; s_known_types[i].buf != NULL; i += 2) {\n    if (mg_strcmp(path, s_known_types[i]) == 0) return s_known_types[i + 1];\n  }\n\n  return mg_str(\"text/plain; charset=utf-8\");\n}\n\nstatic int getrange(struct mg_str *s, size_t *a, size_t *b) {\n  size_t i, numparsed = 0;\n  for (i = 0; i + 6 < s->len; i++) {\n    struct mg_str k, v = mg_str_n(s->buf + i + 6, s->len - i - 6);\n    if (memcmp(&s->buf[i], \"bytes=\", 6) != 0) continue;\n    if (mg_span(v, &k, &v, '-')) {\n      if (mg_to_size_t(k, a)) numparsed++;\n      if (v.len > 0 && mg_to_size_t(v, b)) numparsed++;\n    } else {\n      if (mg_to_size_t(v, a)) numparsed++;\n    }\n    break;\n  }\n  return (int) numparsed;\n}\n\nvoid mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,\n                        const char *path,\n                        const struct mg_http_serve_opts *opts) {\n  char etag[64], tmp[MG_PATH_MAX];\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_fd *fd = NULL;\n  size_t size = 0;\n  time_t mtime = 0;\n  struct mg_str *inm = NULL;\n  struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);\n  bool gzip = false;\n\n  if (path != NULL) {\n    // If a browser sends us \"Accept-Encoding: gzip\", try to open .gz first\n    struct mg_str *ae = mg_http_get_header(hm, \"Accept-Encoding\");\n    if (ae != NULL) {\n      char *ae_ = mg_mprintf(\"%.*s\", ae->len, ae->buf);\n      if (ae_ != NULL && strstr(ae_, \"gzip\") != NULL) {\n        mg_snprintf(tmp, sizeof(tmp), \"%s.gz\", path);\n        fd = mg_fs_open(fs, tmp, MG_FS_READ);\n        if (fd != NULL) gzip = true, path = tmp;\n      }\n      free(ae_);\n    }\n    // No luck opening .gz? Open what we've told to open\n    if (fd == NULL) fd = mg_fs_open(fs, path, MG_FS_READ);\n  }\n\n  // Failed to open, and page404 is configured? Open it, then\n  if (fd == NULL && opts->page404 != NULL) {\n    fd = mg_fs_open(fs, opts->page404, MG_FS_READ);\n    path = opts->page404;\n    mime = guess_content_type(mg_str(path), opts->mime_types);\n  }\n\n  if (fd == NULL || fs->st(path, &size, &mtime) == 0) {\n    mg_http_reply(c, 404, opts->extra_headers, \"Not found\\n\");\n    mg_fs_close(fd);\n    // NOTE: mg_http_etag() call should go first!\n  } else if (mg_http_etag(etag, sizeof(etag), size, mtime) != NULL &&\n             (inm = mg_http_get_header(hm, \"If-None-Match\")) != NULL &&\n             mg_strcasecmp(*inm, mg_str(etag)) == 0) {\n    mg_fs_close(fd);\n    mg_http_reply(c, 304, opts->extra_headers, \"\");\n  } else {\n    int n, status = 200;\n    char range[100];\n    size_t r1 = 0, r2 = 0, cl = size;\n\n    // Handle Range header\n    struct mg_str *rh = mg_http_get_header(hm, \"Range\");\n    range[0] = '\\0';\n    if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0) {\n      // If range is specified like \"400-\", set second limit to content len\n      if (n == 1) r2 = cl - 1;\n      if (r1 > r2 || r2 >= cl) {\n        status = 416;\n        cl = 0;\n        mg_snprintf(range, sizeof(range), \"Content-Range: bytes */%lld\\r\\n\",\n                    (int64_t) size);\n      } else {\n        status = 206;\n        cl = r2 - r1 + 1;\n        mg_snprintf(range, sizeof(range),\n                    \"Content-Range: bytes %llu-%llu/%llu\\r\\n\", (uint64_t) r1,\n                    (uint64_t) (r1 + cl - 1), (uint64_t) size);\n        fs->sk(fd->fd, r1);\n      }\n    }\n    mg_printf(c,\n              \"HTTP/1.1 %d %s\\r\\n\"\n              \"Content-Type: %.*s\\r\\n\"\n              \"Etag: %s\\r\\n\"\n              \"Content-Length: %llu\\r\\n\"\n              \"%s%s%s\\r\\n\",\n              status, mg_http_status_code_str(status), (int) mime.len, mime.buf,\n              etag, (uint64_t) cl, gzip ? \"Content-Encoding: gzip\\r\\n\" : \"\",\n              range, opts->extra_headers ? opts->extra_headers : \"\");\n    if (mg_strcasecmp(hm->method, mg_str(\"HEAD\")) == 0) {\n      c->is_resp = 0;\n      mg_fs_close(fd);\n    } else {\n      // Track to-be-sent content length at the end of c->data, aligned\n      size_t *clp = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /\n                                        sizeof(size_t) * sizeof(size_t)];\n      c->pfn = static_cb;\n      c->pfn_data = fd;\n      *clp = cl;\n    }\n  }\n}\n\nstruct printdirentrydata {\n  struct mg_connection *c;\n  struct mg_http_message *hm;\n  const struct mg_http_serve_opts *opts;\n  const char *dir;\n};\n\n#if MG_ENABLE_DIRLIST\nstatic void printdirentry(const char *name, void *userdata) {\n  struct printdirentrydata *d = (struct printdirentrydata *) userdata;\n  struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;\n  size_t size = 0;\n  time_t t = 0;\n  char path[MG_PATH_MAX], sz[40], mod[40];\n  int flags, n = 0;\n\n  // MG_DEBUG((\"[%s] [%s]\", d->dir, name));\n  if (mg_snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) >\n      sizeof(path)) {\n    MG_ERROR((\"%s truncated\", name));\n  } else if ((flags = fs->st(path, &size, &t)) == 0) {\n    MG_ERROR((\"%lu stat(%s): %d\", d->c->id, path, errno));\n  } else {\n    const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";\n    if (flags & MG_FS_DIR) {\n      mg_snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");\n    } else {\n      mg_snprintf(sz, sizeof(sz), \"%lld\", (uint64_t) size);\n    }\n#if defined(MG_HTTP_DIRLIST_TIME_FMT)\n    {\n      char time_str[40];\n      struct tm *time_info = localtime(&t);\n      strftime(time_str, sizeof time_str, \"%Y/%m/%d %H:%M:%S\", time_info);\n      mg_snprintf(mod, sizeof(mod), \"%s\", time_str);\n    }\n#else\n    mg_snprintf(mod, sizeof(mod), \"%lu\", (unsigned long) t);\n#endif\n    n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));\n    mg_printf(d->c,\n              \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"\n              \"<td name=%lu>%s</td><td name=%lld>%s</td></tr>\\n\",\n              n, path, slash, name, slash, (unsigned long) t, mod,\n              flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);\n  }\n}\n\nstatic void listdir(struct mg_connection *c, struct mg_http_message *hm,\n                    const struct mg_http_serve_opts *opts, char *dir) {\n  const char *sort_js_code =\n      \"<script>function srt(tb, sc, so, d) {\"\n      \"var tr = Array.prototype.slice.call(tb.rows, 0),\"\n      \"tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],\"\n      \"n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), \"\n      \"t1 = a.cells[2].getAttribute('name'), \"\n      \"t2 = b.cells[2].getAttribute('name'); \"\n      \"return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : \"\n      \"n1 ? parseInt(n2) - parseInt(n1) : \"\n      \"c1.textContent.trim().localeCompare(c2.textContent.trim())); });\";\n  const char *sort_js_code2 =\n      \"for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); \"\n      \"if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); \"\n      \"};\"\n      \"window.onload = function() {\"\n      \"var tb = document.getElementById('tb');\"\n      \"var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];\"\n      \"var sc = m[1], so = m[2]; document.onclick = function(ev) { \"\n      \"var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); \"\n      \"sc = c; ev.preventDefault();}};\"\n      \"srt(tb, sc, so, true);\"\n      \"}\"\n      \"</script>\";\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct printdirentrydata d = {c, hm, opts, dir};\n  char tmp[10], buf[MG_PATH_MAX];\n  size_t off, n;\n  int len = mg_url_decode(hm->uri.buf, hm->uri.len, buf, sizeof(buf), 0);\n  struct mg_str uri = len > 0 ? mg_str_n(buf, (size_t) len) : hm->uri;\n\n  mg_printf(c,\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Content-Type: text/html; charset=utf-8\\r\\n\"\n            \"%s\"\n            \"Content-Length:         \\r\\n\\r\\n\",\n            opts->extra_headers == NULL ? \"\" : opts->extra_headers);\n  off = c->send.len;  // Start of body\n  mg_printf(c,\n            \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"\n            \"<style>th,td {text-align: left; padding-right: 1em; \"\n            \"font-family: monospace; }</style></head>\"\n            \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"\n            \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"\n            \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"\n            \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"\n            \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"\n            \"</thead>\"\n            \"<tbody id=\\\"tb\\\">\\n\",\n            (int) uri.len, uri.buf, sort_js_code, sort_js_code2, (int) uri.len,\n            uri.buf);\n  mg_printf(c, \"%s\",\n            \"  <tr><td><a href=\\\"..\\\">..</a></td>\"\n            \"<td name=-1></td><td name=-1>[DIR]</td></tr>\\n\");\n\n  fs->ls(dir, printdirentry, &d);\n  mg_printf(c,\n            \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"\n            \"</table><address>Mongoose v.%s</address></body></html>\\n\",\n            MG_VERSION);\n  n = mg_snprintf(tmp, sizeof(tmp), \"%lu\", (unsigned long) (c->send.len - off));\n  if (n > sizeof(tmp)) n = 0;\n  memcpy(c->send.buf + off - 12, tmp, n);  // Set content length\n  c->is_resp = 0;                          // Mark response end\n}\n#endif\n\n// Resolve requested file into `path` and return its fs->st() result\nstatic int uri_to_path2(struct mg_connection *c, struct mg_http_message *hm,\n                        struct mg_fs *fs, struct mg_str url, struct mg_str dir,\n                        char *path, size_t path_size) {\n  int flags, tmp;\n  // Append URI to the root_dir, and sanitize it\n  size_t n = mg_snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.buf);\n  if (n + 2 >= path_size) {\n    mg_http_reply(c, 400, \"\", \"Exceeded path size\");\n    return -1;\n  }\n  path[path_size - 1] = '\\0';\n  // Terminate root dir with slash\n  if (n > 0 && path[n - 1] != '/') path[n++] = '/', path[n] = '\\0';\n  if (url.len < hm->uri.len) {\n    mg_url_decode(hm->uri.buf + url.len, hm->uri.len - url.len, path + n,\n                  path_size - n, 0);\n  }\n  path[path_size - 1] = '\\0';  // Double-check\n  if (!mg_path_is_sane(mg_str_n(path, path_size))) {\n    mg_http_reply(c, 400, \"\", \"Invalid path\");\n    return -1;\n  }\n  n = strlen(path);\n  while (n > 1 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes\n  flags = mg_strcmp(hm->uri, mg_str(\"/\")) == 0 ? MG_FS_DIR\n                                               : fs->st(path, NULL, NULL);\n  MG_VERBOSE((\"%lu %.*s -> %s %d\", c->id, (int) hm->uri.len, hm->uri.buf, path,\n              flags));\n  if (flags == 0) {\n    // Do nothing - let's caller decide\n  } else if ((flags & MG_FS_DIR) && hm->uri.len > 0 &&\n             hm->uri.buf[hm->uri.len - 1] != '/') {\n    mg_printf(c,\n              \"HTTP/1.1 301 Moved\\r\\n\"\n              \"Location: %.*s/\\r\\n\"\n              \"Content-Length: 0\\r\\n\"\n              \"\\r\\n\",\n              (int) hm->uri.len, hm->uri.buf);\n    c->is_resp = 0;\n    flags = -1;\n  } else if (flags & MG_FS_DIR) {\n    if (((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&\n          (tmp = fs->st(path, NULL, NULL)) != 0) ||\n         (mg_snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&\n          (tmp = fs->st(path, NULL, NULL)) != 0))) {\n      flags = tmp;\n    } else if ((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX \".gz\") >\n                    0 &&\n                (tmp = fs->st(path, NULL, NULL)) !=\n                    0)) {  // check for gzipped index\n      flags = tmp;\n      path[n + 1 + strlen(MG_HTTP_INDEX)] =\n          '\\0';  // Remove appended .gz in index file name\n    } else {\n      path[n] = '\\0';  // Remove appended index file name\n    }\n  }\n  return flags;\n}\n\nstatic int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,\n                       const struct mg_http_serve_opts *opts, char *path,\n                       size_t path_size) {\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_str k, v, part, s = mg_str(opts->root_dir), u = {NULL, 0}, p = u;\n  while (mg_span(s, &part, &s, ',')) {\n    if (!mg_span(part, &k, &v, '=')) k = part, v = mg_str_n(NULL, 0);\n    if (v.len == 0) v = k, k = mg_str(\"/\"), u = k, p = v;\n    if (hm->uri.len < k.len) continue;\n    if (mg_strcmp(k, mg_str_n(hm->uri.buf, k.len)) != 0) continue;\n    u = k, p = v;\n  }\n  return uri_to_path2(c, hm, fs, u, p, path, path_size);\n}\n\nvoid mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,\n                       const struct mg_http_serve_opts *opts) {\n  char path[MG_PATH_MAX];\n  const char *sp = opts->ssi_pattern;\n  int flags = uri_to_path(c, hm, opts, path, sizeof(path));\n  if (flags < 0) {\n    // Do nothing: the response has already been sent by uri_to_path()\n  } else if (flags & MG_FS_DIR) {\n#if MG_ENABLE_DIRLIST\n    listdir(c, hm, opts, path);\n#else\n    mg_http_reply(c, 403, \"\", \"Forbidden\\n\");\n#endif\n  } else if (flags && sp != NULL && mg_match(mg_str(path), mg_str(sp), NULL)) {\n    mg_http_serve_ssi(c, opts->root_dir, path);\n  } else {\n    mg_http_serve_file(c, hm, path, opts);\n  }\n}\n\nstatic bool mg_is_url_safe(int c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||\n         (c >= 'A' && c <= 'Z') || c == '.' || c == '_' || c == '-' || c == '~';\n}\n\nsize_t mg_url_encode(const char *s, size_t sl, char *buf, size_t len) {\n  size_t i, n = 0;\n  for (i = 0; i < sl; i++) {\n    int c = *(unsigned char *) &s[i];\n    if (n + 4 >= len) return 0;\n    if (mg_is_url_safe(c)) {\n      buf[n++] = s[i];\n    } else {\n      mg_snprintf(&buf[n], 4, \"%%%M\", mg_print_hex, 1, &s[i]);\n      n += 3;\n    }\n  }\n  if (len > 0 && n < len - 1) buf[n] = '\\0';  // Null-terminate the destination\n  if (len > 0) buf[len - 1] = '\\0';           // Always.\n  return n;\n}\n\nvoid mg_http_creds(struct mg_http_message *hm, char *user, size_t userlen,\n                   char *pass, size_t passlen) {\n  struct mg_str *v = mg_http_get_header(hm, \"Authorization\");\n  user[0] = pass[0] = '\\0';\n  if (v != NULL && v->len > 6 && memcmp(v->buf, \"Basic \", 6) == 0) {\n    char buf[256];\n    size_t n = mg_base64_decode(v->buf + 6, v->len - 6, buf, sizeof(buf));\n    const char *p = (const char *) memchr(buf, ':', n > 0 ? n : 0);\n    if (p != NULL) {\n      mg_snprintf(user, userlen, \"%.*s\", p - buf, buf);\n      mg_snprintf(pass, passlen, \"%.*s\", n - (size_t) (p - buf) - 1, p + 1);\n    }\n  } else if (v != NULL && v->len > 7 && memcmp(v->buf, \"Bearer \", 7) == 0) {\n    mg_snprintf(pass, passlen, \"%.*s\", (int) v->len - 7, v->buf + 7);\n  } else if ((v = mg_http_get_header(hm, \"Cookie\")) != NULL) {\n    struct mg_str t = mg_http_get_header_var(*v, mg_str_n(\"access_token\", 12));\n    if (t.len > 0) mg_snprintf(pass, passlen, \"%.*s\", (int) t.len, t.buf);\n  } else {\n    mg_http_get_var(&hm->query, \"access_token\", pass, passlen);\n  }\n}\n\nstatic struct mg_str stripquotes(struct mg_str s) {\n  return s.len > 1 && s.buf[0] == '\"' && s.buf[s.len - 1] == '\"'\n             ? mg_str_n(s.buf + 1, s.len - 2)\n             : s;\n}\n\nstruct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.buf[i + v.len] == '=' && memcmp(&s.buf[i], v.buf, v.len) == 0) {\n      const char *p = &s.buf[i + v.len + 1], *b = p, *x = &s.buf[s.len];\n      int q = p < x && *p == '\"' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\"' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // MG_INFO((\"[%.*s] [%.*s] [%.*s]\", (int) s.len, s.buf, (int) v.len,\n      // v.buf, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}\n\nlong mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                    struct mg_fs *fs, const char *dir, size_t max_size) {\n  char buf[20] = \"0\", file[MG_PATH_MAX], path[MG_PATH_MAX];\n  long res = 0, offset;\n  mg_http_get_var(&hm->query, \"offset\", buf, sizeof(buf));\n  mg_http_get_var(&hm->query, \"file\", file, sizeof(file));\n  offset = strtol(buf, NULL, 0);\n  mg_snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, file);\n  if (hm->body.len == 0) {\n    mg_http_reply(c, 200, \"\", \"%ld\", res);  // Nothing to write\n  } else if (file[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"file required\");\n    res = -1;\n  } else if (mg_path_is_sane(mg_str(file)) == false) {\n    mg_http_reply(c, 400, \"\", \"%s: invalid file\", file);\n    res = -2;\n  } else if (offset < 0) {\n    mg_http_reply(c, 400, \"\", \"offset required\");\n    res = -3;\n  } else if ((size_t) offset + hm->body.len > max_size) {\n    mg_http_reply(c, 400, \"\", \"%s: over max size of %lu\", path,\n                  (unsigned long) max_size);\n    res = -4;\n  } else {\n    struct mg_fd *fd;\n    size_t current_size = 0;\n    MG_DEBUG((\"%s -> %lu bytes @ %ld\", path, hm->body.len, offset));\n    if (offset == 0) fs->rm(path);  // If offset if 0, truncate file\n    fs->st(path, &current_size, NULL);\n    if (offset > 0 && current_size != (size_t) offset) {\n      mg_http_reply(c, 400, \"\", \"%s: offset mismatch\", path);\n      res = -5;\n    } else if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {\n      mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);\n      res = -6;\n    } else {\n      res = offset + (long) fs->wr(fd->fd, hm->body.buf, hm->body.len);\n      mg_fs_close(fd);\n      mg_http_reply(c, 200, \"\", \"%ld\", res);\n    }\n  }\n  return res;\n}\n\nint mg_http_status(const struct mg_http_message *hm) {\n  return atoi(hm->uri.buf);\n}\n\nstatic bool is_hex_digit(int c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||\n         (c >= 'A' && c <= 'F');\n}\n\nstatic int skip_chunk(const char *buf, int len, int *pl, int *dl) {\n  int i = 0, n = 0;\n  if (len < 3) return 0;\n  while (i < len && is_hex_digit(buf[i])) i++;\n  if (i == 0) return -1;                     // Error, no length specified\n  if (i > (int) sizeof(int) * 2) return -1;  // Chunk length is too big\n  if (len < i + 1 || buf[i] != '\\r' || buf[i + 1] != '\\n') return -1;  // Error\n  if (mg_str_to_num(mg_str_n(buf, (size_t) i), 16, &n, sizeof(int)) == false)\n    return -1;                    // Decode chunk length, overflow\n  if (n < 0) return -1;           // Error. TODO(): some checks now redundant\n  if (n > len - i - 4) return 0;  // Chunk not yet fully buffered\n  if (buf[i + n + 2] != '\\r' || buf[i + n + 3] != '\\n') return -1;  // Error\n  *pl = i + 2, *dl = n;\n  return i + 2 + n + 2;\n}\n\nstatic void http_cb(struct mg_connection *c, int ev, void *ev_data) {\n  if (ev == MG_EV_READ || ev == MG_EV_CLOSE ||\n      (ev == MG_EV_POLL && c->is_accepted && !c->is_draining &&\n       c->recv.len > 0)) {  // see #2796\n    struct mg_http_message hm;\n    size_t ofs = 0;  // Parsing offset\n    while (c->is_resp == 0 && ofs < c->recv.len) {\n      const char *buf = (char *) c->recv.buf + ofs;\n      int n = mg_http_parse(buf, c->recv.len - ofs, &hm);\n      struct mg_str *te;  // Transfer - encoding header\n      bool is_chunked = false;\n      size_t old_len = c->recv.len;\n      if (n < 0) {\n        // We don't use mg_error() here, to avoid closing pipelined requests\n        // prematurely, see #2592\n        MG_ERROR((\"HTTP parse, %lu bytes\", c->recv.len));\n        c->is_draining = 1;\n        mg_hexdump(buf, c->recv.len - ofs > 16 ? 16 : c->recv.len - ofs);\n        c->recv.len = 0;\n        return;\n      }\n      if (n == 0) break;                 // Request is not buffered yet\n      mg_call(c, MG_EV_HTTP_HDRS, &hm);  // Got all HTTP headers\n      if (c->recv.len != old_len) {\n        // User manipulated received data. Wash our hands\n        MG_DEBUG((\"%lu detaching HTTP handler\", c->id));\n        c->pfn = NULL;\n        return;\n      }\n      if (ev == MG_EV_CLOSE) {           // If client did not set Content-Length\n        hm.message.len = c->recv.len - ofs;  // and closes now, deliver MSG\n        hm.body.len = hm.message.len - (size_t) (hm.body.buf - hm.message.buf);\n      }\n      if ((te = mg_http_get_header(&hm, \"Transfer-Encoding\")) != NULL) {\n        if (mg_strcasecmp(*te, mg_str(\"chunked\")) == 0) {\n          is_chunked = true;\n        } else {\n          mg_error(c, \"Invalid Transfer-Encoding\");  // See #2460\n          return;\n        }\n      } else if (mg_http_get_header(&hm, \"Content-length\") == NULL) {\n        // #2593: HTTP packets must contain either Transfer-Encoding or\n        // Content-length\n        bool is_response = mg_ncasecmp(hm.method.buf, \"HTTP/\", 5) == 0;\n        bool require_content_len = false;\n        if (!is_response && (mg_strcasecmp(hm.method, mg_str(\"POST\")) == 0 ||\n                             mg_strcasecmp(hm.method, mg_str(\"PUT\")) == 0)) {\n          // POST and PUT should include an entity body. Therefore, they should\n          // contain a Content-length header. Other requests can also contain a\n          // body, but their content has no defined semantics (RFC 7231)\n          require_content_len = true;\n          ofs += (size_t) n;  // this request has been processed\n        } else if (is_response) {\n          // HTTP spec 7.2 Entity body: All other responses must include a body\n          // or Content-Length header field defined with a value of 0.\n          int status = mg_http_status(&hm);\n          require_content_len = status >= 200 && status != 204 && status != 304;\n        }\n        if (require_content_len) {\n          if (!c->is_client) mg_http_reply(c, 411, \"\", \"\");\n          MG_ERROR((\"Content length missing from %s\", is_response ? \"response\" : \"request\"));\n        }\n      }\n\n      if (is_chunked) {\n        // For chunked data, strip off prefixes and suffixes from chunks\n        // and relocate them right after the headers, then report a message\n        char *s = (char *) c->recv.buf + ofs + n;\n        int o = 0, pl, dl, cl, len = (int) (c->recv.len - ofs - (size_t) n);\n\n        // Find zero-length chunk (the end of the body)\n        while ((cl = skip_chunk(s + o, len - o, &pl, &dl)) > 0 && dl) o += cl;\n        if (cl == 0) break;  // No zero-len chunk, buffer more data\n        if (cl < 0) {\n          mg_error(c, \"Invalid chunk\");\n          break;\n        }\n\n        // Zero chunk found. Second pass: strip + relocate\n        o = 0, hm.body.len = 0, hm.message.len = (size_t) n;\n        while ((cl = skip_chunk(s + o, len - o, &pl, &dl)) > 0) {\n          memmove(s + hm.body.len, s + o + pl, (size_t) dl);\n          o += cl, hm.body.len += (size_t) dl, hm.message.len += (size_t) dl;\n          if (dl == 0) break;\n        }\n        ofs += (size_t) (n + o);\n      } else {  // Normal, non-chunked data\n        size_t len = c->recv.len - ofs - (size_t) n;\n        if (hm.body.len > len) break;  // Buffer more data\n        ofs += (size_t) n + hm.body.len;\n      }\n\n      if (c->is_accepted) c->is_resp = 1;  // Start generating response\n      mg_call(c, MG_EV_HTTP_MSG, &hm);     // User handler can clear is_resp\n      if (c->is_accepted && !c->is_resp) {\n        struct mg_str *cc = mg_http_get_header(&hm, \"Connection\");\n        if (cc != NULL && mg_strcasecmp(*cc, mg_str(\"close\")) == 0) {\n          c->is_draining = 1;  // honor \"Connection: close\"\n          break;\n        }\n      }\n    }\n    if (ofs > 0) mg_iobuf_del(&c->recv, 0, ofs);  // Delete processed data\n  }\n  (void) ev_data;\n}\n\nstatic void mg_hfn(struct mg_connection *c, int ev, void *ev_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    if (mg_match(hm->uri, mg_str(\"/quit\"), NULL)) {\n      mg_http_reply(c, 200, \"\", \"ok\\n\");\n      c->is_draining = 1;\n      c->data[0] = 'X';\n    } else if (mg_match(hm->uri, mg_str(\"/debug\"), NULL)) {\n      int level = (int) mg_json_get_long(hm->body, \"$.level\", MG_LL_DEBUG);\n      mg_log_set(level);\n      mg_http_reply(c, 200, \"\", \"Debug level set to %d\\n\", level);\n    } else {\n      mg_http_reply(c, 200, \"\", \"hi\\n\");\n    }\n  } else if (ev == MG_EV_CLOSE) {\n    if (c->data[0] == 'X') *(bool *) c->fn_data = true;\n  }\n}\n\nvoid mg_hello(const char *url) {\n  struct mg_mgr mgr;\n  bool done = false;\n  mg_mgr_init(&mgr);\n  if (mg_http_listen(&mgr, url, mg_hfn, &done) == NULL) done = true;\n  while (done == false) mg_mgr_poll(&mgr, 100);\n  mg_mgr_free(&mgr);\n}\n\nstruct mg_connection *mg_http_connect(struct mg_mgr *mgr, const char *url,\n                                      mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n\nstruct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url,\n                                     mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/iobuf.c\"\n#endif\n\n\n\n\n\nstatic size_t roundup(size_t size, size_t align) {\n  return align == 0 ? size : (size + align - 1) / align * align;\n}\n\nint mg_iobuf_resize(struct mg_iobuf *io, size_t new_size) {\n  int ok = 1;\n  new_size = roundup(new_size, io->align);\n  if (new_size == 0) {\n    mg_bzero(io->buf, io->size);\n    free(io->buf);\n    io->buf = NULL;\n    io->len = io->size = 0;\n  } else if (new_size != io->size) {\n    // NOTE(lsm): do not use realloc here. Use calloc/free only, to ease the\n    // porting to some obscure platforms like FreeRTOS\n    void *p = calloc(1, new_size);\n    if (p != NULL) {\n      size_t len = new_size < io->len ? new_size : io->len;\n      if (len > 0 && io->buf != NULL) memmove(p, io->buf, len);\n      mg_bzero(io->buf, io->size);\n      free(io->buf);\n      io->buf = (unsigned char *) p;\n      io->size = new_size;\n    } else {\n      ok = 0;\n      MG_ERROR((\"%lld->%lld\", (uint64_t) io->size, (uint64_t) new_size));\n    }\n  }\n  return ok;\n}\n\nint mg_iobuf_init(struct mg_iobuf *io, size_t size, size_t align) {\n  io->buf = NULL;\n  io->align = align;\n  io->size = io->len = 0;\n  return mg_iobuf_resize(io, size);\n}\n\nsize_t mg_iobuf_add(struct mg_iobuf *io, size_t ofs, const void *buf,\n                    size_t len) {\n  size_t new_size = roundup(io->len + len, io->align);\n  mg_iobuf_resize(io, new_size);      // Attempt to resize\n  if (new_size != io->size) len = 0;  // Resize failure, append nothing\n  if (ofs < io->len) memmove(io->buf + ofs + len, io->buf + ofs, io->len - ofs);\n  if (buf != NULL) memmove(io->buf + ofs, buf, len);\n  if (ofs > io->len) io->len += ofs - io->len;\n  io->len += len;\n  return len;\n}\n\nsize_t mg_iobuf_del(struct mg_iobuf *io, size_t ofs, size_t len) {\n  if (ofs > io->len) ofs = io->len;\n  if (ofs + len > io->len) len = io->len - ofs;\n  if (io->buf) memmove(io->buf + ofs, io->buf + ofs + len, io->len - ofs - len);\n  if (io->buf) mg_bzero(io->buf + io->len - len, len);\n  io->len -= len;\n  return len;\n}\n\nvoid mg_iobuf_free(struct mg_iobuf *io) {\n  mg_iobuf_resize(io, 0);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/json.c\"\n#endif\n\n\n\n\nstatic const char *escapeseq(int esc) {\n  return esc ? \"\\b\\f\\n\\r\\t\\\\\\\"\" : \"bfnrt\\\\\\\"\";\n}\n\nstatic char json_esc(int c, int esc) {\n  const char *p, *esc1 = escapeseq(esc), *esc2 = escapeseq(!esc);\n  for (p = esc1; *p != '\\0'; p++) {\n    if (*p == c) return esc2[p - esc1];\n  }\n  return 0;\n}\n\nstatic int mg_pass_string(const char *s, int len) {\n  int i;\n  for (i = 0; i < len; i++) {\n    if (s[i] == '\\\\' && i + 1 < len && json_esc(s[i + 1], 1)) {\n      i++;\n    } else if (s[i] == '\\0') {\n      return MG_JSON_INVALID;\n    } else if (s[i] == '\"') {\n      return i;\n    }\n  }\n  return MG_JSON_INVALID;\n}\n\nstatic double mg_atod(const char *p, int len, int *numlen) {\n  double d = 0.0;\n  int i = 0, sign = 1;\n\n  // Sign\n  if (i < len && *p == '-') {\n    sign = -1, i++;\n  } else if (i < len && *p == '+') {\n    i++;\n  }\n\n  // Decimal\n  for (; i < len && p[i] >= '0' && p[i] <= '9'; i++) {\n    d *= 10.0;\n    d += p[i] - '0';\n  }\n  d *= sign;\n\n  // Fractional\n  if (i < len && p[i] == '.') {\n    double frac = 0.0, base = 0.1;\n    i++;\n    for (; i < len && p[i] >= '0' && p[i] <= '9'; i++) {\n      frac += base * (p[i] - '0');\n      base /= 10.0;\n    }\n    d += frac * sign;\n  }\n\n  // Exponential\n  if (i < len && (p[i] == 'e' || p[i] == 'E')) {\n    int j, exp = 0, minus = 0;\n    i++;\n    if (i < len && p[i] == '-') minus = 1, i++;\n    if (i < len && p[i] == '+') i++;\n    while (i < len && p[i] >= '0' && p[i] <= '9' && exp < 308)\n      exp = exp * 10 + (p[i++] - '0');\n    if (minus) exp = -exp;\n    for (j = 0; j < exp; j++) d *= 10.0;\n    for (j = 0; j < -exp; j++) d /= 10.0;\n  }\n\n  if (numlen != NULL) *numlen = i;\n  return d;\n}\n\n// Iterate over object or array elements\nsize_t mg_json_next(struct mg_str obj, size_t ofs, struct mg_str *key,\n                    struct mg_str *val) {\n  if (ofs >= obj.len) {\n    ofs = 0;  // Out of boundaries, stop scanning\n  } else if (obj.len < 2 || (*obj.buf != '{' && *obj.buf != '[')) {\n    ofs = 0;  // Not an array or object, stop\n  } else {\n    struct mg_str sub = mg_str_n(obj.buf + ofs, obj.len - ofs);\n    if (ofs == 0) ofs++, sub.buf++, sub.len--;\n    if (*obj.buf == '[') {  // Iterate over an array\n      int n = 0, o = mg_json_get(sub, \"$\", &n);\n      if (n < 0 || o < 0 || (size_t) (o + n) > sub.len) {\n        ofs = 0;  // Error parsing key, stop scanning\n      } else {\n        if (key) *key = mg_str_n(NULL, 0);\n        if (val) *val = mg_str_n(sub.buf + o, (size_t) n);\n        ofs = (size_t) (&sub.buf[o + n] - obj.buf);\n      }\n    } else {  // Iterate over an object\n      int n = 0, o = mg_json_get(sub, \"$\", &n);\n      if (n < 0 || o < 0 || (size_t) (o + n) > sub.len) {\n        ofs = 0;  // Error parsing key, stop scanning\n      } else {\n        if (key) *key = mg_str_n(sub.buf + o, (size_t) n);\n        sub.buf += o + n, sub.len -= (size_t) (o + n);\n        while (sub.len > 0 && *sub.buf != ':') sub.len--, sub.buf++;\n        if (sub.len > 0 && *sub.buf == ':') sub.len--, sub.buf++;\n        n = 0, o = mg_json_get(sub, \"$\", &n);\n        if (n < 0 || o < 0 || (size_t) (o + n) > sub.len) {\n          ofs = 0;  // Error parsing value, stop scanning\n        } else {\n          if (val) *val = mg_str_n(sub.buf + o, (size_t) n);\n          ofs = (size_t) (&sub.buf[o + n] - obj.buf);\n        }\n      }\n    }\n    // MG_INFO((\"SUB ofs %u %.*s\", ofs, sub.len, sub.buf));\n    while (ofs && ofs < obj.len &&\n           (obj.buf[ofs] == ' ' || obj.buf[ofs] == '\\t' ||\n            obj.buf[ofs] == '\\n' || obj.buf[ofs] == '\\r')) {\n      ofs++;\n    }\n    if (ofs && ofs < obj.len && obj.buf[ofs] == ',') ofs++;\n    if (ofs > obj.len) ofs = 0;\n  }\n  return ofs;\n}\n\nint mg_json_get(struct mg_str json, const char *path, int *toklen) {\n  const char *s = json.buf;\n  int len = (int) json.len;\n  enum { S_VALUE, S_KEY, S_COLON, S_COMMA_OR_EOO } expecting = S_VALUE;\n  unsigned char nesting[MG_JSON_MAX_DEPTH];\n  int i = 0;             // Current offset in `s`\n  int j = 0;             // Offset in `s` we're looking for (return value)\n  int depth = 0;         // Current depth (nesting level)\n  int ed = 0;            // Expected depth\n  int pos = 1;           // Current position in `path`\n  int ci = -1, ei = -1;  // Current and expected index in array\n\n  if (toklen) *toklen = 0;\n  if (path[0] != '$') return MG_JSON_INVALID;\n\n#define MG_CHECKRET(x)                                  \\\n  do {                                                  \\\n    if (depth == ed && path[pos] == '\\0' && ci == ei) { \\\n      if (toklen) *toklen = i - j + 1;                  \\\n      return j;                                         \\\n    }                                                   \\\n  } while (0)\n\n// In the ascii table, the distance between `[` and `]` is 2.\n// Ditto for `{` and `}`. Hence +2 in the code below.\n#define MG_EOO(x)                                            \\\n  do {                                                       \\\n    if (depth == ed && ci != ei) return MG_JSON_NOT_FOUND;   \\\n    if (c != nesting[depth - 1] + 2) return MG_JSON_INVALID; \\\n    depth--;                                                 \\\n    MG_CHECKRET(x);                                          \\\n  } while (0)\n\n  for (i = 0; i < len; i++) {\n    unsigned char c = ((unsigned char *) s)[i];\n    if (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') continue;\n    switch (expecting) {\n      case S_VALUE:\n        // p(\"V %s [%.*s] %d %d %d %d\\n\", path, pos, path, depth, ed, ci, ei);\n        if (depth == ed) j = i;\n        if (c == '{') {\n          if (depth >= (int) sizeof(nesting)) return MG_JSON_TOO_DEEP;\n          if (depth == ed && path[pos] == '.' && ci == ei) {\n            // If we start the object, reset array indices\n            ed++, pos++, ci = ei = -1;\n          }\n          nesting[depth++] = c;\n          expecting = S_KEY;\n          break;\n        } else if (c == '[') {\n          if (depth >= (int) sizeof(nesting)) return MG_JSON_TOO_DEEP;\n          if (depth == ed && path[pos] == '[' && ei == ci) {\n            ed++, pos++, ci = 0;\n            for (ei = 0; path[pos] != ']' && path[pos] != '\\0'; pos++) {\n              ei *= 10;\n              ei += path[pos] - '0';\n            }\n            if (path[pos] != 0) pos++;\n          }\n          nesting[depth++] = c;\n          break;\n        } else if (c == ']' && depth > 0) {  // Empty array\n          MG_EOO(']');\n        } else if (c == 't' && i + 3 < len && memcmp(&s[i], \"true\", 4) == 0) {\n          i += 3;\n        } else if (c == 'n' && i + 3 < len && memcmp(&s[i], \"null\", 4) == 0) {\n          i += 3;\n        } else if (c == 'f' && i + 4 < len && memcmp(&s[i], \"false\", 5) == 0) {\n          i += 4;\n        } else if (c == '-' || ((c >= '0' && c <= '9'))) {\n          int numlen = 0;\n          mg_atod(&s[i], len - i, &numlen);\n          i += numlen - 1;\n        } else if (c == '\"') {\n          int n = mg_pass_string(&s[i + 1], len - i - 1);\n          if (n < 0) return n;\n          i += n + 1;\n        } else {\n          return MG_JSON_INVALID;\n        }\n        MG_CHECKRET('V');\n        if (depth == ed && ei >= 0) ci++;\n        expecting = S_COMMA_OR_EOO;\n        break;\n\n      case S_KEY:\n        if (c == '\"') {\n          int n = mg_pass_string(&s[i + 1], len - i - 1);\n          if (n < 0) return n;\n          if (i + 1 + n >= len) return MG_JSON_NOT_FOUND;\n          if (depth < ed) return MG_JSON_NOT_FOUND;\n          if (depth == ed && path[pos - 1] != '.') return MG_JSON_NOT_FOUND;\n          // printf(\"K %s [%.*s] [%.*s] %d %d %d %d %d\\n\", path, pos, path, n,\n          //        &s[i + 1], n, depth, ed, ci, ei);\n          //  NOTE(cpq): in the check sequence below is important.\n          //  strncmp() must go first: it fails fast if the remaining length\n          //  of the path is smaller than `n`.\n          if (depth == ed && path[pos - 1] == '.' &&\n              strncmp(&s[i + 1], &path[pos], (size_t) n) == 0 &&\n              (path[pos + n] == '\\0' || path[pos + n] == '.' ||\n               path[pos + n] == '[')) {\n            pos += n;\n          }\n          i += n + 1;\n          expecting = S_COLON;\n        } else if (c == '}') {  // Empty object\n          MG_EOO('}');\n          expecting = S_COMMA_OR_EOO;\n          if (depth == ed && ei >= 0) ci++;\n        } else {\n          return MG_JSON_INVALID;\n        }\n        break;\n\n      case S_COLON:\n        if (c == ':') {\n          expecting = S_VALUE;\n        } else {\n          return MG_JSON_INVALID;\n        }\n        break;\n\n      case S_COMMA_OR_EOO:\n        if (depth <= 0) {\n          return MG_JSON_INVALID;\n        } else if (c == ',') {\n          expecting = (nesting[depth - 1] == '{') ? S_KEY : S_VALUE;\n        } else if (c == ']' || c == '}') {\n          if (depth == ed && c == '}' && path[pos - 1] == '.')\n            return MG_JSON_NOT_FOUND;\n          if (depth == ed && c == ']' && path[pos - 1] == ',')\n            return MG_JSON_NOT_FOUND;\n          MG_EOO('O');\n          if (depth == ed && ei >= 0) ci++;\n        } else {\n          return MG_JSON_INVALID;\n        }\n        break;\n    }\n  }\n  return MG_JSON_NOT_FOUND;\n}\n\nstruct mg_str mg_json_get_tok(struct mg_str json, const char *path) {\n  int len = 0, ofs = mg_json_get(json, path, &len);\n  return mg_str_n(ofs < 0 ? NULL : json.buf + ofs,\n                  (size_t) (len < 0 ? 0 : len));\n}\n\nbool mg_json_get_num(struct mg_str json, const char *path, double *v) {\n  int n, toklen, found = 0;\n  if ((n = mg_json_get(json, path, &toklen)) >= 0 &&\n      (json.buf[n] == '-' || (json.buf[n] >= '0' && json.buf[n] <= '9'))) {\n    if (v != NULL) *v = mg_atod(json.buf + n, toklen, NULL);\n    found = 1;\n  }\n  return found;\n}\n\nbool mg_json_get_bool(struct mg_str json, const char *path, bool *v) {\n  int found = 0, off = mg_json_get(json, path, NULL);\n  if (off >= 0 && (json.buf[off] == 't' || json.buf[off] == 'f')) {\n    if (v != NULL) *v = json.buf[off] == 't';\n    found = 1;\n  }\n  return found;\n}\n\nbool mg_json_unescape(struct mg_str s, char *to, size_t n) {\n  size_t i, j;\n  for (i = 0, j = 0; i < s.len && j < n; i++, j++) {\n    if (s.buf[i] == '\\\\' && i + 5 < s.len && s.buf[i + 1] == 'u') {\n      //  \\uXXXX escape. We process simple one-byte chars \\u00xx within ASCII\n      //  range. More complex chars would require dragging in a UTF8 library,\n      //  which is too much for us\n      if (mg_str_to_num(mg_str_n(s.buf + i + 2, 4), 16, &to[j],\n                        sizeof(uint8_t)) == false)\n        return false;\n      i += 5;\n    } else if (s.buf[i] == '\\\\' && i + 1 < s.len) {\n      char c = json_esc(s.buf[i + 1], 0);\n      if (c == 0) return false;\n      to[j] = c;\n      i++;\n    } else {\n      to[j] = s.buf[i];\n    }\n  }\n  if (j >= n) return false;\n  if (n > 0) to[j] = '\\0';\n  return true;\n}\n\nchar *mg_json_get_str(struct mg_str json, const char *path) {\n  char *result = NULL;\n  int len = 0, off = mg_json_get(json, path, &len);\n  if (off >= 0 && len > 1 && json.buf[off] == '\"') {\n    if ((result = (char *) calloc(1, (size_t) len)) != NULL &&\n        !mg_json_unescape(mg_str_n(json.buf + off + 1, (size_t) (len - 2)),\n                          result, (size_t) len)) {\n      free(result);\n      result = NULL;\n    }\n  }\n  return result;\n}\n\nchar *mg_json_get_b64(struct mg_str json, const char *path, int *slen) {\n  char *result = NULL;\n  int len = 0, off = mg_json_get(json, path, &len);\n  if (off >= 0 && json.buf[off] == '\"' && len > 1 &&\n      (result = (char *) calloc(1, (size_t) len)) != NULL) {\n    size_t k = mg_base64_decode(json.buf + off + 1, (size_t) (len - 2), result,\n                                (size_t) len);\n    if (slen != NULL) *slen = (int) k;\n  }\n  return result;\n}\n\nchar *mg_json_get_hex(struct mg_str json, const char *path, int *slen) {\n  char *result = NULL;\n  int len = 0, off = mg_json_get(json, path, &len);\n  if (off >= 0 && json.buf[off] == '\"' && len > 1 &&\n      (result = (char *) calloc(1, (size_t) len / 2)) != NULL) {\n    int i;\n    for (i = 0; i < len - 2; i += 2) {\n      mg_str_to_num(mg_str_n(json.buf + off + 1 + i, 2), 16, &result[i >> 1],\n                    sizeof(uint8_t));\n    }\n    result[len / 2 - 1] = '\\0';\n    if (slen != NULL) *slen = len / 2 - 1;\n  }\n  return result;\n}\n\nlong mg_json_get_long(struct mg_str json, const char *path, long dflt) {\n  double dv;\n  long result = dflt;\n  if (mg_json_get_num(json, path, &dv)) result = (long) dv;\n  return result;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/log.c\"\n#endif\n\n\n\n\n\nint mg_log_level = MG_LL_INFO;\nstatic mg_pfn_t s_log_func = mg_pfn_stdout;\nstatic void *s_log_func_param = NULL;\n\nvoid mg_log_set_fn(mg_pfn_t fn, void *param) {\n  s_log_func = fn;\n  s_log_func_param = param;\n}\n\nstatic void logc(unsigned char c) {\n  s_log_func((char) c, s_log_func_param);\n}\n\nstatic void logs(const char *buf, size_t len) {\n  size_t i;\n  for (i = 0; i < len; i++) logc(((unsigned char *) buf)[i]);\n}\n\n#if MG_ENABLE_CUSTOM_LOG\n// Let user define their own mg_log_prefix() and mg_log()\n#else\nvoid mg_log_prefix(int level, const char *file, int line, const char *fname) {\n  const char *p = strrchr(file, '/');\n  char buf[41];\n  size_t n;\n  if (p == NULL) p = strrchr(file, '\\\\');\n  n = mg_snprintf(buf, sizeof(buf), \"%-6llx %d %s:%d:%s\", mg_millis(), level,\n                  p == NULL ? file : p + 1, line, fname);\n  if (n > sizeof(buf) - 2) n = sizeof(buf) - 2;\n  while (n < sizeof(buf)) buf[n++] = ' ';\n  logs(buf, n - 1);\n}\n\nvoid mg_log(const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_vxprintf(s_log_func, s_log_func_param, fmt, &ap);\n  va_end(ap);\n  logs(\"\\r\\n\", 2);\n}\n#endif\n\nstatic unsigned char nibble(unsigned c) {\n  return (unsigned char) (c < 10 ? c + '0' : c + 'W');\n}\n\n#define ISPRINT(x) ((x) >= ' ' && (x) <= '~')\nvoid mg_hexdump(const void *buf, size_t len) {\n  const unsigned char *p = (const unsigned char *) buf;\n  unsigned char ascii[16], alen = 0;\n  size_t i;\n  for (i = 0; i < len; i++) {\n    if ((i % 16) == 0) {\n      // Print buffered ascii chars\n      if (i > 0) logs(\"  \", 2), logs((char *) ascii, 16), logc('\\n'), alen = 0;\n      // Print hex address, then \\t\n      logc(nibble((i >> 12) & 15)), logc(nibble((i >> 8) & 15)),\n          logc(nibble((i >> 4) & 15)), logc('0'), logs(\"   \", 3);\n    }\n    logc(nibble(p[i] >> 4)), logc(nibble(p[i] & 15));  // Two nibbles, e.g. c5\n    logc(' ');                                         // Space after hex number\n    ascii[alen++] = ISPRINT(p[i]) ? p[i] : '.';        // Add to the ascii buf\n  }\n  while (alen < 16) logs(\"   \", 3), ascii[alen++] = ' ';\n  logs(\"  \", 2), logs((char *) ascii, 16), logc('\\n');\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/md5.c\"\n#endif\n\n\n\n//  This code implements the MD5 message-digest algorithm.\n//  The algorithm is due to Ron Rivest.  This code was\n//  written by Colin Plumb in 1993, no copyright is claimed.\n//  This code is in the public domain; do with it what you wish.\n//\n//  Equivalent code is available from RSA Data Security, Inc.\n//  This code has been tested against that, and is equivalent,\n//  except that you don't need to include two pages of legalese\n//  with every copy.\n//\n//  To compute the message digest of a chunk of bytes, declare an\n//  MD5Context structure, pass it to MD5Init, call MD5Update as\n//  needed on buffers full of bytes, and then call MD5Final, which\n//  will fill a supplied 16-byte array with the digest.\n\n#if defined(MG_ENABLE_MD5) && MG_ENABLE_MD5\n\nstatic void mg_byte_reverse(unsigned char *buf, unsigned longs) {\n  if (MG_BIG_ENDIAN) {\n    do {\n      uint32_t t = (uint32_t) ((unsigned) buf[3] << 8 | buf[2]) << 16 |\n                   ((unsigned) buf[1] << 8 | buf[0]);\n      *(uint32_t *) buf = t;\n      buf += 4;\n    } while (--longs);\n  } else {\n    (void) buf, (void) longs;  // Little endian. Do nothing\n  }\n}\n\n#define F1(x, y, z) (z ^ (x & (y ^ z)))\n#define F2(x, y, z) F1(z, x, y)\n#define F3(x, y, z) (x ^ y ^ z)\n#define F4(x, y, z) (y ^ (x | ~z))\n\n#define MD5STEP(f, w, x, y, z, data, s) \\\n  (w += f(x, y, z) + data, w = w << s | w >> (32 - s), w += x)\n\n/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */\nvoid mg_md5_init(mg_md5_ctx *ctx) {\n  ctx->buf[0] = 0x67452301;\n  ctx->buf[1] = 0xefcdab89;\n  ctx->buf[2] = 0x98badcfe;\n  ctx->buf[3] = 0x10325476;\n\n  ctx->bits[0] = 0;\n  ctx->bits[1] = 0;\n}\n\nstatic void mg_md5_transform(uint32_t buf[4], uint32_t const in[16]) {\n  uint32_t a, b, c, d;\n\n  a = buf[0];\n  b = buf[1];\n  c = buf[2];\n  d = buf[3];\n\n  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\n  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\n  buf[0] += a;\n  buf[1] += b;\n  buf[2] += c;\n  buf[3] += d;\n}\n\nvoid mg_md5_update(mg_md5_ctx *ctx, const unsigned char *buf, size_t len) {\n  uint32_t t;\n\n  t = ctx->bits[0];\n  if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t) ctx->bits[1]++;\n  ctx->bits[1] += (uint32_t) len >> 29;\n\n  t = (t >> 3) & 0x3f;\n\n  if (t) {\n    unsigned char *p = (unsigned char *) ctx->in + t;\n\n    t = 64 - t;\n    if (len < t) {\n      memcpy(p, buf, len);\n      return;\n    }\n    memcpy(p, buf, t);\n    mg_byte_reverse(ctx->in, 16);\n    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += t;\n    len -= t;\n  }\n\n  while (len >= 64) {\n    memcpy(ctx->in, buf, 64);\n    mg_byte_reverse(ctx->in, 16);\n    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += 64;\n    len -= 64;\n  }\n\n  memcpy(ctx->in, buf, len);\n}\n\nvoid mg_md5_final(mg_md5_ctx *ctx, unsigned char digest[16]) {\n  unsigned count;\n  unsigned char *p;\n  uint32_t *a;\n\n  count = (ctx->bits[0] >> 3) & 0x3F;\n\n  p = ctx->in + count;\n  *p++ = 0x80;\n  count = 64 - 1 - count;\n  if (count < 8) {\n    memset(p, 0, count);\n    mg_byte_reverse(ctx->in, 16);\n    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n    memset(ctx->in, 0, 56);\n  } else {\n    memset(p, 0, count - 8);\n  }\n  mg_byte_reverse(ctx->in, 14);\n\n  a = (uint32_t *) ctx->in;\n  a[14] = ctx->bits[0];\n  a[15] = ctx->bits[1];\n\n  mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n  mg_byte_reverse((unsigned char *) ctx->buf, 4);\n  memcpy(digest, ctx->buf, 16);\n  memset((char *) ctx, 0, sizeof(*ctx));\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/mqtt.c\"\n#endif\n\n\n\n\n\n\n\n\n#define MQTT_CLEAN_SESSION 0x02\n#define MQTT_HAS_WILL 0x04\n#define MQTT_WILL_RETAIN 0x20\n#define MQTT_HAS_PASSWORD 0x40\n#define MQTT_HAS_USER_NAME 0x80\n\nstruct mg_mqtt_pmap {\n  uint8_t id;\n  uint8_t type;\n};\n\nstatic const struct mg_mqtt_pmap s_prop_map[] = {\n    {MQTT_PROP_PAYLOAD_FORMAT_INDICATOR, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_MESSAGE_EXPIRY_INTERVAL, MQTT_PROP_TYPE_INT},\n    {MQTT_PROP_CONTENT_TYPE, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_RESPONSE_TOPIC, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_CORRELATION_DATA, MQTT_PROP_TYPE_BINARY_DATA},\n    {MQTT_PROP_SUBSCRIPTION_IDENTIFIER, MQTT_PROP_TYPE_VARIABLE_INT},\n    {MQTT_PROP_SESSION_EXPIRY_INTERVAL, MQTT_PROP_TYPE_INT},\n    {MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_SERVER_KEEP_ALIVE, MQTT_PROP_TYPE_SHORT},\n    {MQTT_PROP_AUTHENTICATION_METHOD, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_AUTHENTICATION_DATA, MQTT_PROP_TYPE_BINARY_DATA},\n    {MQTT_PROP_REQUEST_PROBLEM_INFORMATION, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_WILL_DELAY_INTERVAL, MQTT_PROP_TYPE_INT},\n    {MQTT_PROP_REQUEST_RESPONSE_INFORMATION, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_RESPONSE_INFORMATION, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_SERVER_REFERENCE, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_REASON_STRING, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_RECEIVE_MAXIMUM, MQTT_PROP_TYPE_SHORT},\n    {MQTT_PROP_TOPIC_ALIAS_MAXIMUM, MQTT_PROP_TYPE_SHORT},\n    {MQTT_PROP_TOPIC_ALIAS, MQTT_PROP_TYPE_SHORT},\n    {MQTT_PROP_MAXIMUM_QOS, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_RETAIN_AVAILABLE, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_USER_PROPERTY, MQTT_PROP_TYPE_STRING_PAIR},\n    {MQTT_PROP_MAXIMUM_PACKET_SIZE, MQTT_PROP_TYPE_INT},\n    {MQTT_PROP_WILDCARD_SUBSCRIPTION_AVAILABLE, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_SUBSCRIPTION_IDENTIFIER_AVAILABLE, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_SHARED_SUBSCRIPTION_AVAILABLE, MQTT_PROP_TYPE_BYTE}};\n\nvoid mg_mqtt_send_header(struct mg_connection *c, uint8_t cmd, uint8_t flags,\n                         uint32_t len) {\n  uint8_t buf[1 + sizeof(len)], *vlen = &buf[1];\n  buf[0] = (uint8_t) ((cmd << 4) | flags);\n  do {\n    *vlen = len % 0x80;\n    len /= 0x80;\n    if (len > 0) *vlen |= 0x80;\n    vlen++;\n  } while (len > 0 && vlen < &buf[sizeof(buf)]);\n  mg_send(c, buf, (size_t) (vlen - buf));\n}\n\nstatic void mg_send_u16(struct mg_connection *c, uint16_t value) {\n  mg_send(c, &value, sizeof(value));\n}\n\nstatic void mg_send_u32(struct mg_connection *c, uint32_t value) {\n  mg_send(c, &value, sizeof(value));\n}\n\nstatic uint8_t varint_size(size_t length) {\n  uint8_t bytes_needed = 0;\n  do {\n    bytes_needed++;\n    length /= 0x80;\n  } while (length > 0);\n  return bytes_needed;\n}\n\nstatic size_t encode_varint(uint8_t *buf, size_t value) {\n  size_t len = 0;\n\n  do {\n    uint8_t b = (uint8_t) (value % 128);\n    value /= 128;\n    if (value > 0) b |= 0x80;\n    buf[len++] = b;\n  } while (value > 0);\n\n  return len;\n}\n\nstatic size_t decode_varint(const uint8_t *buf, size_t len, size_t *value) {\n  size_t multiplier = 1, offset;\n  *value = 0;\n\n  for (offset = 0; offset < 4 && offset < len; offset++) {\n    uint8_t encoded_byte = buf[offset];\n    *value += (encoded_byte & 0x7f) * multiplier;\n    multiplier *= 128;\n\n    if ((encoded_byte & 0x80) == 0) return offset + 1;\n  }\n\n  return 0;\n}\n\nstatic int mqtt_prop_type_by_id(uint8_t prop_id) {\n  size_t i, num_properties = sizeof(s_prop_map) / sizeof(s_prop_map[0]);\n  for (i = 0; i < num_properties; ++i) {\n    if (s_prop_map[i].id == prop_id) return s_prop_map[i].type;\n  }\n  return -1;  // Property ID not found\n}\n\n// Returns the size of the properties section, without the\n// size of the content's length\nstatic size_t get_properties_length(struct mg_mqtt_prop *props, size_t count) {\n  size_t i, size = 0;\n  for (i = 0; i < count; i++) {\n    size++;  // identifier\n    switch (mqtt_prop_type_by_id(props[i].id)) {\n      case MQTT_PROP_TYPE_STRING_PAIR:\n        size += (uint32_t) (props[i].val.len + props[i].key.len +\n                            2 * sizeof(uint16_t));\n        break;\n      case MQTT_PROP_TYPE_STRING:\n        size += (uint32_t) (props[i].val.len + sizeof(uint16_t));\n        break;\n      case MQTT_PROP_TYPE_BINARY_DATA:\n        size += (uint32_t) (props[i].val.len + sizeof(uint16_t));\n        break;\n      case MQTT_PROP_TYPE_VARIABLE_INT:\n        size += varint_size((uint32_t) props[i].iv);\n        break;\n      case MQTT_PROP_TYPE_INT:\n        size += (uint32_t) sizeof(uint32_t);\n        break;\n      case MQTT_PROP_TYPE_SHORT:\n        size += (uint32_t) sizeof(uint16_t);\n        break;\n      case MQTT_PROP_TYPE_BYTE:\n        size += (uint32_t) sizeof(uint8_t);\n        break;\n      default:\n        return size;  // cannot parse further down\n    }\n  }\n\n  return size;\n}\n\n// returns the entire size of the properties section, including the\n// size of the variable length of the content\nstatic size_t get_props_size(struct mg_mqtt_prop *props, size_t count) {\n  size_t size = get_properties_length(props, count);\n  size += varint_size(size);\n  return size;\n}\n\nstatic void mg_send_mqtt_properties(struct mg_connection *c,\n                                    struct mg_mqtt_prop *props, size_t nprops) {\n  size_t total_size = get_properties_length(props, nprops);\n  uint8_t buf_v[4] = {0, 0, 0, 0};\n  uint8_t buf[4] = {0, 0, 0, 0};\n  size_t i, len = encode_varint(buf, total_size);\n\n  mg_send(c, buf, (size_t) len);\n  for (i = 0; i < nprops; i++) {\n    mg_send(c, &props[i].id, sizeof(props[i].id));\n    switch (mqtt_prop_type_by_id(props[i].id)) {\n      case MQTT_PROP_TYPE_STRING_PAIR:\n        mg_send_u16(c, mg_htons((uint16_t) props[i].key.len));\n        mg_send(c, props[i].key.buf, props[i].key.len);\n        mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));\n        mg_send(c, props[i].val.buf, props[i].val.len);\n        break;\n      case MQTT_PROP_TYPE_BYTE:\n        mg_send(c, &props[i].iv, sizeof(uint8_t));\n        break;\n      case MQTT_PROP_TYPE_SHORT:\n        mg_send_u16(c, mg_htons((uint16_t) props[i].iv));\n        break;\n      case MQTT_PROP_TYPE_INT:\n        mg_send_u32(c, mg_htonl((uint32_t) props[i].iv));\n        break;\n      case MQTT_PROP_TYPE_STRING:\n        mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));\n        mg_send(c, props[i].val.buf, props[i].val.len);\n        break;\n      case MQTT_PROP_TYPE_BINARY_DATA:\n        mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));\n        mg_send(c, props[i].val.buf, props[i].val.len);\n        break;\n      case MQTT_PROP_TYPE_VARIABLE_INT:\n        len = encode_varint(buf_v, props[i].iv);\n        mg_send(c, buf_v, (size_t) len);\n        break;\n    }\n  }\n}\n\nsize_t mg_mqtt_next_prop(struct mg_mqtt_message *msg, struct mg_mqtt_prop *prop,\n                         size_t ofs) {\n  uint8_t *i = (uint8_t *) msg->dgram.buf + msg->props_start + ofs;\n  uint8_t *end = (uint8_t *) msg->dgram.buf + msg->dgram.len;\n  size_t new_pos = ofs, len;\n  prop->id = i[0];\n\n  if (ofs >= msg->dgram.len || ofs >= msg->props_start + msg->props_size)\n    return 0;\n  i++, new_pos++;\n\n  switch (mqtt_prop_type_by_id(prop->id)) {\n    case MQTT_PROP_TYPE_STRING_PAIR:\n      prop->key.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);\n      prop->key.buf = (char *) i + 2;\n      i += 2 + prop->key.len;\n      prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);\n      prop->val.buf = (char *) i + 2;\n      new_pos += 2 * sizeof(uint16_t) + prop->val.len + prop->key.len;\n      break;\n    case MQTT_PROP_TYPE_BYTE:\n      prop->iv = (uint8_t) i[0];\n      new_pos++;\n      break;\n    case MQTT_PROP_TYPE_SHORT:\n      prop->iv = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);\n      new_pos += sizeof(uint16_t);\n      break;\n    case MQTT_PROP_TYPE_INT:\n      prop->iv = ((uint32_t) i[0] << 24) | ((uint32_t) i[1] << 16) |\n                 ((uint32_t) i[2] << 8) | i[3];\n      new_pos += sizeof(uint32_t);\n      break;\n    case MQTT_PROP_TYPE_STRING:\n      prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);\n      prop->val.buf = (char *) i + 2;\n      new_pos += 2 + prop->val.len;\n      break;\n    case MQTT_PROP_TYPE_BINARY_DATA:\n      prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);\n      prop->val.buf = (char *) i + 2;\n      new_pos += 2 + prop->val.len;\n      break;\n    case MQTT_PROP_TYPE_VARIABLE_INT:\n      len = decode_varint(i, (size_t) (end - i), (size_t *) &prop->iv);\n      new_pos = (!len) ? 0 : new_pos + len;\n      break;\n    default:\n      new_pos = 0;\n  }\n\n  return new_pos;\n}\n\nvoid mg_mqtt_login(struct mg_connection *c, const struct mg_mqtt_opts *opts) {\n  char client_id[21];\n  struct mg_str cid = opts->client_id;\n  size_t total_len = 7 + 1 + 2 + 2;\n  uint8_t hdr[8] = {0, 4, 'M', 'Q', 'T', 'T', opts->version, 0};\n\n  if (cid.len == 0) {\n    mg_random_str(client_id, sizeof(client_id) - 1);\n    client_id[sizeof(client_id) - 1] = '\\0';\n    cid = mg_str(client_id);\n  }\n\n  if (hdr[6] == 0) hdr[6] = 4;  // If version is not set, use 4 (3.1.1)\n  c->is_mqtt5 = hdr[6] == 5;    // Set version 5 flag\n  hdr[7] = (uint8_t) ((opts->qos & 3) << 3);  // Connection flags\n  if (opts->user.len > 0) {\n    total_len += 2 + (uint32_t) opts->user.len;\n    hdr[7] |= MQTT_HAS_USER_NAME;\n  }\n  if (opts->pass.len > 0) {\n    total_len += 2 + (uint32_t) opts->pass.len;\n    hdr[7] |= MQTT_HAS_PASSWORD;\n  }\n  if (opts->topic.len > 0) {  // allow zero-length msgs, message.len is size_t\n    total_len += 4 + (uint32_t) opts->topic.len + (uint32_t) opts->message.len;\n    hdr[7] |= MQTT_HAS_WILL;\n  }\n  if (opts->clean || cid.len == 0) hdr[7] |= MQTT_CLEAN_SESSION;\n  if (opts->retain) hdr[7] |= MQTT_WILL_RETAIN;\n  total_len += (uint32_t) cid.len;\n  if (c->is_mqtt5) {\n    total_len += get_props_size(opts->props, opts->num_props);\n    if (hdr[7] & MQTT_HAS_WILL)\n      total_len += get_props_size(opts->will_props, opts->num_will_props);\n  }\n\n  mg_mqtt_send_header(c, MQTT_CMD_CONNECT, 0, (uint32_t) total_len);\n  mg_send(c, hdr, sizeof(hdr));\n  // keepalive == 0 means \"do not disconnect us!\"\n  mg_send_u16(c, mg_htons((uint16_t) opts->keepalive));\n\n  if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);\n\n  mg_send_u16(c, mg_htons((uint16_t) cid.len));\n  mg_send(c, cid.buf, cid.len);\n\n  if (hdr[7] & MQTT_HAS_WILL) {\n    if (c->is_mqtt5)\n      mg_send_mqtt_properties(c, opts->will_props, opts->num_will_props);\n\n    mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));\n    mg_send(c, opts->topic.buf, opts->topic.len);\n    mg_send_u16(c, mg_htons((uint16_t) opts->message.len));\n    mg_send(c, opts->message.buf, opts->message.len);\n  }\n  if (opts->user.len > 0) {\n    mg_send_u16(c, mg_htons((uint16_t) opts->user.len));\n    mg_send(c, opts->user.buf, opts->user.len);\n  }\n  if (opts->pass.len > 0) {\n    mg_send_u16(c, mg_htons((uint16_t) opts->pass.len));\n    mg_send(c, opts->pass.buf, opts->pass.len);\n  }\n}\n\nuint16_t mg_mqtt_pub(struct mg_connection *c, const struct mg_mqtt_opts *opts) {\n  uint16_t id = opts->retransmit_id;\n  uint8_t flags = (uint8_t) (((opts->qos & 3) << 1) | (opts->retain ? 1 : 0));\n  size_t len = 2 + opts->topic.len + opts->message.len;\n  MG_DEBUG((\"%lu [%.*s] <- [%.*s%c\", c->id, (int) opts->topic.len,\n            (char *) opts->topic.buf,\n            (int) (opts->message.len <= 10 ? opts->message.len : 10),\n            (char *) opts->message.buf, opts->message.len <= 10 ? ']' : ' '));\n  if (opts->qos > 0) len += 2;\n  if (c->is_mqtt5) len += get_props_size(opts->props, opts->num_props);\n\n  if (opts->qos > 0 && id != 0) flags |= 1 << 3;\n  mg_mqtt_send_header(c, MQTT_CMD_PUBLISH, flags, (uint32_t) len);\n  mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));\n  mg_send(c, opts->topic.buf, opts->topic.len);\n  if (opts->qos > 0) {  // need to send 'id' field\n    if (id == 0) {      // generate new one if not resending\n      if (++c->mgr->mqtt_id == 0) ++c->mgr->mqtt_id;\n      id = c->mgr->mqtt_id;\n    }\n    mg_send_u16(c, mg_htons(id));\n  }\n\n  if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);\n\n  if (opts->message.len > 0) mg_send(c, opts->message.buf, opts->message.len);\n  return id;\n}\n\nvoid mg_mqtt_sub(struct mg_connection *c, const struct mg_mqtt_opts *opts) {\n  uint8_t qos_ = opts->qos & 3;\n  size_t plen = c->is_mqtt5 ? get_props_size(opts->props, opts->num_props) : 0;\n  size_t len = 2 + opts->topic.len + 2 + 1 + plen;\n\n  mg_mqtt_send_header(c, MQTT_CMD_SUBSCRIBE, 2, (uint32_t) len);\n  if (++c->mgr->mqtt_id == 0) ++c->mgr->mqtt_id;\n  mg_send_u16(c, mg_htons(c->mgr->mqtt_id));\n  if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);\n\n  mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));\n  mg_send(c, opts->topic.buf, opts->topic.len);\n  mg_send(c, &qos_, sizeof(qos_));\n}\n\nint mg_mqtt_parse(const uint8_t *buf, size_t len, uint8_t version,\n                  struct mg_mqtt_message *m) {\n  uint8_t lc = 0, *p, *end;\n  uint32_t n = 0, len_len = 0;\n\n  memset(m, 0, sizeof(*m));\n  m->dgram.buf = (char *) buf;\n  if (len < 2) return MQTT_INCOMPLETE;\n  m->cmd = (uint8_t) (buf[0] >> 4);\n  m->qos = (buf[0] >> 1) & 3;\n\n  n = len_len = 0;\n  p = (uint8_t *) buf + 1;\n  while ((size_t) (p - buf) < len) {\n    lc = *((uint8_t *) p++);\n    n += (uint32_t) ((lc & 0x7f) << 7 * len_len);\n    len_len++;\n    if (!(lc & 0x80)) break;\n    if (len_len >= 4) return MQTT_MALFORMED;\n  }\n  end = p + n;\n  if ((lc & 0x80) || (end > buf + len)) return MQTT_INCOMPLETE;\n  m->dgram.len = (size_t) (end - buf);\n\n  switch (m->cmd) {\n    case MQTT_CMD_CONNACK:\n      if (end - p < 2) return MQTT_MALFORMED;\n      m->ack = p[1];\n      break;\n    case MQTT_CMD_PUBACK:\n    case MQTT_CMD_PUBREC:\n    case MQTT_CMD_PUBREL:\n    case MQTT_CMD_PUBCOMP:\n    case MQTT_CMD_SUBSCRIBE:\n    case MQTT_CMD_SUBACK:\n    case MQTT_CMD_UNSUBSCRIBE:\n    case MQTT_CMD_UNSUBACK:\n      if (p + 2 > end) return MQTT_MALFORMED;\n      m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n      p += 2;\n      break;\n    case MQTT_CMD_PUBLISH: {\n      if (p + 2 > end) return MQTT_MALFORMED;\n      m->topic.len = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n      m->topic.buf = (char *) p + 2;\n      p += 2 + m->topic.len;\n      if (p > end) return MQTT_MALFORMED;\n      if (m->qos > 0) {\n        if (p + 2 > end) return MQTT_MALFORMED;\n        m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n        p += 2;\n      }\n      if (p > end) return MQTT_MALFORMED;\n      if (version == 5 && p + 2 < end) {\n        len_len =\n            (uint32_t) decode_varint(p, (size_t) (end - p), &m->props_size);\n        if (!len_len) return MQTT_MALFORMED;\n        m->props_start = (size_t) (p + len_len - buf);\n        p += len_len + m->props_size;\n      }\n      if (p > end) return MQTT_MALFORMED;\n      m->data.buf = (char *) p;\n      m->data.len = (size_t) (end - p);\n      break;\n    }\n    default:\n      break;\n  }\n  return MQTT_OK;\n}\n\nstatic void mqtt_cb(struct mg_connection *c, int ev, void *ev_data) {\n  if (ev == MG_EV_READ) {\n    for (;;) {\n      uint8_t version = c->is_mqtt5 ? 5 : 4;\n      struct mg_mqtt_message mm;\n      int rc = mg_mqtt_parse(c->recv.buf, c->recv.len, version, &mm);\n      if (rc == MQTT_MALFORMED) {\n        MG_ERROR((\"%lu MQTT malformed message\", c->id));\n        c->is_closing = 1;\n        break;\n      } else if (rc == MQTT_OK) {\n        MG_VERBOSE((\"%lu MQTT CMD %d len %d [%.*s]\", c->id, mm.cmd,\n                    (int) mm.dgram.len, (int) mm.data.len, mm.data.buf));\n        switch (mm.cmd) {\n          case MQTT_CMD_CONNACK:\n            mg_call(c, MG_EV_MQTT_OPEN, &mm.ack);\n            if (mm.ack == 0) {\n              MG_DEBUG((\"%lu Connected\", c->id));\n            } else {\n              MG_ERROR((\"%lu MQTT auth failed, code %d\", c->id, mm.ack));\n              c->is_closing = 1;\n            }\n            break;\n          case MQTT_CMD_PUBLISH: {\n            MG_DEBUG((\"%lu [%.*s] -> [%.*s%c\", c->id, (int) mm.topic.len,\n                      mm.topic.buf,\n                      (int) (mm.data.len <= 10 ? mm.data.len : 10), mm.data.buf,\n                      mm.data.len <= 10 ? ']' : ' '));\n            if (mm.qos > 0) {\n              uint16_t id = mg_ntohs(mm.id);\n              uint32_t remaining_len = sizeof(id);\n              if (c->is_mqtt5) remaining_len += 2;  // 3.4.2\n\n              mg_mqtt_send_header(\n                  c,\n                  (uint8_t) (mm.qos == 2 ? MQTT_CMD_PUBREC : MQTT_CMD_PUBACK),\n                  0, remaining_len);\n              mg_send(c, &id, sizeof(id));\n\n              if (c->is_mqtt5) {\n                uint16_t zero = 0;\n                mg_send(c, &zero, sizeof(zero));\n              }\n            }\n            mg_call(c, MG_EV_MQTT_MSG, &mm);  // let the app handle qos stuff\n            break;\n          }\n          case MQTT_CMD_PUBREC: {  // MQTT5: 3.5.2-1 TODO(): variable header rc\n            uint16_t id = mg_ntohs(mm.id);\n            uint32_t remaining_len = sizeof(id);  // MQTT5 3.6.2-1\n            mg_mqtt_send_header(c, MQTT_CMD_PUBREL, 2, remaining_len);\n            mg_send(c, &id, sizeof(id));  // MQTT5 3.6.1-1, flags = 2\n            break;\n          }\n          case MQTT_CMD_PUBREL: {  // MQTT5: 3.6.2-1 TODO(): variable header rc\n            uint16_t id = mg_ntohs(mm.id);\n            uint32_t remaining_len = sizeof(id);  // MQTT5 3.7.2-1\n            mg_mqtt_send_header(c, MQTT_CMD_PUBCOMP, 0, remaining_len);\n            mg_send(c, &id, sizeof(id));\n            break;\n          }\n        }\n        mg_call(c, MG_EV_MQTT_CMD, &mm);\n        mg_iobuf_del(&c->recv, 0, mm.dgram.len);\n      } else {\n        break;\n      }\n    }\n  }\n  (void) ev_data;\n}\n\nvoid mg_mqtt_ping(struct mg_connection *nc) {\n  mg_mqtt_send_header(nc, MQTT_CMD_PINGREQ, 0, 0);\n}\n\nvoid mg_mqtt_pong(struct mg_connection *nc) {\n  mg_mqtt_send_header(nc, MQTT_CMD_PINGRESP, 0, 0);\n}\n\nvoid mg_mqtt_disconnect(struct mg_connection *c,\n                        const struct mg_mqtt_opts *opts) {\n  size_t len = 0;\n  if (c->is_mqtt5) len = 1 + get_props_size(opts->props, opts->num_props);\n  mg_mqtt_send_header(c, MQTT_CMD_DISCONNECT, 0, (uint32_t) len);\n\n  if (c->is_mqtt5) {\n    uint8_t zero = 0;\n    mg_send(c, &zero, sizeof(zero));  // reason code\n    mg_send_mqtt_properties(c, opts->props, opts->num_props);\n  }\n}\n\nstruct mg_connection *mg_mqtt_connect(struct mg_mgr *mgr, const char *url,\n                                      const struct mg_mqtt_opts *opts,\n                                      mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) {\n    struct mg_mqtt_opts empty;\n    memset(&empty, 0, sizeof(empty));\n    mg_mqtt_login(c, opts == NULL ? &empty : opts);\n    c->pfn = mqtt_cb;\n  }\n  return c;\n}\n\nstruct mg_connection *mg_mqtt_listen(struct mg_mgr *mgr, const char *url,\n                                     mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = mqtt_cb, c->pfn_data = mgr;\n  return c;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/net.c\"\n#endif\n\n\n\n\n\n\n\n\n\nsize_t mg_vprintf(struct mg_connection *c, const char *fmt, va_list *ap) {\n  size_t old = c->send.len;\n  mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);\n  return c->send.len - old;\n}\n\nsize_t mg_printf(struct mg_connection *c, const char *fmt, ...) {\n  size_t len = 0;\n  va_list ap;\n  va_start(ap, fmt);\n  len = mg_vprintf(c, fmt, &ap);\n  va_end(ap);\n  return len;\n}\n\nstatic bool mg_atonl(struct mg_str str, struct mg_addr *addr) {\n  uint32_t localhost = mg_htonl(0x7f000001);\n  if (mg_strcasecmp(str, mg_str(\"localhost\")) != 0) return false;\n  memcpy(addr->ip, &localhost, sizeof(uint32_t));\n  addr->is_ip6 = false;\n  return true;\n}\n\nstatic bool mg_atone(struct mg_str str, struct mg_addr *addr) {\n  if (str.len > 0) return false;\n  memset(addr->ip, 0, sizeof(addr->ip));\n  addr->is_ip6 = false;\n  return true;\n}\n\nstatic bool mg_aton4(struct mg_str str, struct mg_addr *addr) {\n  uint8_t data[4] = {0, 0, 0, 0};\n  size_t i, num_dots = 0;\n  for (i = 0; i < str.len; i++) {\n    if (str.buf[i] >= '0' && str.buf[i] <= '9') {\n      int octet = data[num_dots] * 10 + (str.buf[i] - '0');\n      if (octet > 255) return false;\n      data[num_dots] = (uint8_t) octet;\n    } else if (str.buf[i] == '.') {\n      if (num_dots >= 3 || i == 0 || str.buf[i - 1] == '.') return false;\n      num_dots++;\n    } else {\n      return false;\n    }\n  }\n  if (num_dots != 3 || str.buf[i - 1] == '.') return false;\n  memcpy(&addr->ip, data, sizeof(data));\n  addr->is_ip6 = false;\n  return true;\n}\n\nstatic bool mg_v4mapped(struct mg_str str, struct mg_addr *addr) {\n  int i;\n  uint32_t ipv4;\n  if (str.len < 14) return false;\n  if (str.buf[0] != ':' || str.buf[1] != ':' || str.buf[6] != ':') return false;\n  for (i = 2; i < 6; i++) {\n    if (str.buf[i] != 'f' && str.buf[i] != 'F') return false;\n  }\n  // struct mg_str s = mg_str_n(&str.buf[7], str.len - 7);\n  if (!mg_aton4(mg_str_n(&str.buf[7], str.len - 7), addr)) return false;\n  memcpy(&ipv4, addr->ip, sizeof(ipv4));\n  memset(addr->ip, 0, sizeof(addr->ip));\n  addr->ip[10] = addr->ip[11] = 255;\n  memcpy(&addr->ip[12], &ipv4, 4);\n  addr->is_ip6 = true;\n  return true;\n}\n\nstatic bool mg_aton6(struct mg_str str, struct mg_addr *addr) {\n  size_t i, j = 0, n = 0, dc = 42;\n  addr->scope_id = 0;\n  if (str.len > 2 && str.buf[0] == '[') str.buf++, str.len -= 2;\n  if (mg_v4mapped(str, addr)) return true;\n  for (i = 0; i < str.len; i++) {\n    if ((str.buf[i] >= '0' && str.buf[i] <= '9') ||\n        (str.buf[i] >= 'a' && str.buf[i] <= 'f') ||\n        (str.buf[i] >= 'A' && str.buf[i] <= 'F')) {\n      unsigned long val = 0;  // TODO(): This loops on chars, refactor\n      if (i > j + 3) return false;\n      // MG_DEBUG((\"%lu %lu [%.*s]\", i, j, (int) (i - j + 1), &str.buf[j]));\n      mg_str_to_num(mg_str_n(&str.buf[j], i - j + 1), 16, &val, sizeof(val));\n      addr->ip[n] = (uint8_t) ((val >> 8) & 255);\n      addr->ip[n + 1] = (uint8_t) (val & 255);\n    } else if (str.buf[i] == ':') {\n      j = i + 1;\n      if (i > 0 && str.buf[i - 1] == ':') {\n        dc = n;  // Double colon\n        if (i > 1 && str.buf[i - 2] == ':') return false;\n      } else if (i > 0) {\n        n += 2;\n      }\n      if (n > 14) return false;\n      addr->ip[n] = addr->ip[n + 1] = 0;  // For trailing ::\n    } else if (str.buf[i] == '%') {       // Scope ID, last in string\n      return mg_str_to_num(mg_str_n(&str.buf[i + 1], str.len - i - 1), 10,\n                           &addr->scope_id, sizeof(uint8_t));\n    } else {\n      return false;\n    }\n  }\n  if (n < 14 && dc == 42) return false;\n  if (n < 14) {\n    memmove(&addr->ip[dc + (14 - n)], &addr->ip[dc], n - dc + 2);\n    memset(&addr->ip[dc], 0, 14 - n);\n  }\n\n  addr->is_ip6 = true;\n  return true;\n}\n\nbool mg_aton(struct mg_str str, struct mg_addr *addr) {\n  // MG_INFO((\"[%.*s]\", (int) str.len, str.buf));\n  return mg_atone(str, addr) || mg_atonl(str, addr) || mg_aton4(str, addr) ||\n         mg_aton6(str, addr);\n}\n\nstruct mg_connection *mg_alloc_conn(struct mg_mgr *mgr) {\n  struct mg_connection *c =\n      (struct mg_connection *) calloc(1, sizeof(*c) + mgr->extraconnsize);\n  if (c != NULL) {\n    c->mgr = mgr;\n    c->send.align = c->recv.align = c->rtls.align = MG_IO_SIZE;\n    c->id = ++mgr->nextid;\n    MG_PROF_INIT(c);\n  }\n  return c;\n}\n\nvoid mg_close_conn(struct mg_connection *c) {\n  mg_resolve_cancel(c);  // Close any pending DNS query\n  LIST_DELETE(struct mg_connection, &c->mgr->conns, c);\n  if (c == c->mgr->dns4.c) c->mgr->dns4.c = NULL;\n  if (c == c->mgr->dns6.c) c->mgr->dns6.c = NULL;\n  // Order of operations is important. `MG_EV_CLOSE` event must be fired\n  // before we deallocate received data, see #1331\n  mg_call(c, MG_EV_CLOSE, NULL);\n  MG_DEBUG((\"%lu %ld closed\", c->id, c->fd));\n  MG_PROF_DUMP(c);\n  MG_PROF_FREE(c);\n\n  mg_tls_free(c);\n  mg_iobuf_free(&c->recv);\n  mg_iobuf_free(&c->send);\n  mg_iobuf_free(&c->rtls);\n  mg_bzero((unsigned char *) c, sizeof(*c));\n  free(c);\n}\n\nstruct mg_connection *mg_connect(struct mg_mgr *mgr, const char *url,\n                                 mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = NULL;\n  if (url == NULL || url[0] == '\\0') {\n    MG_ERROR((\"null url\"));\n  } else if ((c = mg_alloc_conn(mgr)) == NULL) {\n    MG_ERROR((\"OOM\"));\n  } else {\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n    c->is_udp = (strncmp(url, \"udp:\", 4) == 0);\n    c->fd = (void *) (size_t) MG_INVALID_SOCKET;\n    c->fn = fn;\n    c->is_client = true;\n    c->fn_data = fn_data;\n    MG_DEBUG((\"%lu %ld %s\", c->id, c->fd, url));\n    mg_call(c, MG_EV_OPEN, (void *) url);\n    mg_resolve(c, url);\n  }\n  return c;\n}\n\nstruct mg_connection *mg_listen(struct mg_mgr *mgr, const char *url,\n                                mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = NULL;\n  if ((c = mg_alloc_conn(mgr)) == NULL) {\n    MG_ERROR((\"OOM %s\", url));\n  } else if (!mg_open_listener(c, url)) {\n    MG_ERROR((\"Failed: %s, errno %d\", url, errno));\n    MG_PROF_FREE(c);\n    free(c);\n    c = NULL;\n  } else {\n    c->is_listening = 1;\n    c->is_udp = strncmp(url, \"udp:\", 4) == 0;\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n    c->fn = fn;\n    c->fn_data = fn_data;\n    mg_call(c, MG_EV_OPEN, NULL);\n    if (mg_url_is_ssl(url)) c->is_tls = 1;  // Accepted connection must\n    MG_DEBUG((\"%lu %ld %s\", c->id, c->fd, url));\n  }\n  return c;\n}\n\nstruct mg_connection *mg_wrapfd(struct mg_mgr *mgr, int fd,\n                                mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_alloc_conn(mgr);\n  if (c != NULL) {\n    c->fd = (void *) (size_t) fd;\n    c->fn = fn;\n    c->fn_data = fn_data;\n    MG_EPOLL_ADD(c);\n    mg_call(c, MG_EV_OPEN, NULL);\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n  }\n  return c;\n}\n\nstruct mg_timer *mg_timer_add(struct mg_mgr *mgr, uint64_t milliseconds,\n                              unsigned flags, void (*fn)(void *), void *arg) {\n  struct mg_timer *t = (struct mg_timer *) calloc(1, sizeof(*t));\n  if (t != NULL) {\n    mg_timer_init(&mgr->timers, t, milliseconds, flags, fn, arg);\n    t->id = mgr->timerid++;\n  }\n  return t;\n}\n\nlong mg_io_recv(struct mg_connection *c, void *buf, size_t len) {\n  if (c->rtls.len == 0) return MG_IO_WAIT;\n  if (len > c->rtls.len) len = c->rtls.len;\n  memcpy(buf, c->rtls.buf, len);\n  mg_iobuf_del(&c->rtls, 0, len);\n  return (long) len;\n}\n\nvoid mg_mgr_free(struct mg_mgr *mgr) {\n  struct mg_connection *c;\n  struct mg_timer *tmp, *t = mgr->timers;\n  while (t != NULL) tmp = t->next, free(t), t = tmp;\n  mgr->timers = NULL;  // Important. Next call to poll won't touch timers\n  for (c = mgr->conns; c != NULL; c = c->next) c->is_closing = 1;\n  mg_mgr_poll(mgr, 0);\n#if MG_ENABLE_FREERTOS_TCP\n  FreeRTOS_DeleteSocketSet(mgr->ss);\n#endif\n  MG_DEBUG((\"All connections closed\"));\n#if MG_ENABLE_EPOLL\n  if (mgr->epoll_fd >= 0) close(mgr->epoll_fd), mgr->epoll_fd = -1;\n#endif\n  mg_tls_ctx_free(mgr);\n}\n\nvoid mg_mgr_init(struct mg_mgr *mgr) {\n  memset(mgr, 0, sizeof(*mgr));\n#if MG_ENABLE_EPOLL\n  if ((mgr->epoll_fd = epoll_create1(EPOLL_CLOEXEC)) < 0)\n    MG_ERROR((\"epoll_create1 errno %d\", errno));\n#else\n  mgr->epoll_fd = -1;\n#endif\n#if MG_ARCH == MG_ARCH_WIN32 && MG_ENABLE_WINSOCK\n  // clang-format off\n  { WSADATA data; WSAStartup(MAKEWORD(2, 2), &data); }\n  // clang-format on\n#elif MG_ENABLE_FREERTOS_TCP\n  mgr->ss = FreeRTOS_CreateSocketSet();\n#elif defined(__unix) || defined(__unix__) || defined(__APPLE__)\n  // Ignore SIGPIPE signal, so if client cancels the request, it\n  // won't kill the whole process.\n  signal(SIGPIPE, SIG_IGN);\n#elif MG_ENABLE_TCPIP_DRIVER_INIT && defined(MG_TCPIP_DRIVER_INIT)\n  MG_TCPIP_DRIVER_INIT(mgr);\n#endif\n  mgr->pipe = MG_INVALID_SOCKET;\n  mgr->dnstimeout = 3000;\n  mgr->dns4.url = \"udp://8.8.8.8:53\";\n  mgr->dns6.url = \"udp://[2001:4860:4860::8888]:53\";\n  mg_tls_ctx_init(mgr);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/net_builtin.c\"\n#endif\n\n\n#if defined(MG_ENABLE_TCPIP) && MG_ENABLE_TCPIP\n#define MG_EPHEMERAL_PORT_BASE 32768\n#define PDIFF(a, b) ((size_t) (((char *) (b)) - ((char *) (a))))\n\n#ifndef MIP_TCP_KEEPALIVE_MS\n#define MIP_TCP_KEEPALIVE_MS 45000  // TCP keep-alive period, ms\n#endif\n\n#define MIP_TCP_ACK_MS 150    // Timeout for ACKing\n#define MIP_ARP_RESP_MS 100   // Timeout for ARP response\n#define MIP_TCP_SYN_MS 15000  // Timeout for connection establishment\n#define MIP_TCP_FIN_MS 1000   // Timeout for closing connection\n#define MIP_TCP_WIN 6000      // TCP window size\n\nstruct connstate {\n  uint32_t seq, ack;           // TCP seq/ack counters\n  uint64_t timer;              // TCP keep-alive / ACK timer\n  uint32_t acked;              // Last ACK-ed number\n  size_t unacked;              // Not acked bytes\n  uint8_t mac[6];              // Peer MAC address\n  uint8_t ttype;               // Timer type. 0: ack, 1: keep-alive\n#define MIP_TTYPE_KEEPALIVE 0  // Connection is idle for long, send keepalive\n#define MIP_TTYPE_ACK 1        // Peer sent us data, we have to ack it soon\n#define MIP_TTYPE_ARP 2        // ARP resolve sent, waiting for response\n#define MIP_TTYPE_SYN 3        // SYN sent, waiting for response\n#define MIP_TTYPE_FIN 4  // FIN sent, waiting until terminating the connection\n  uint8_t tmiss;         // Number of keep-alive misses\n  struct mg_iobuf raw;   // For TLS only. Incoming raw data\n};\n\n#pragma pack(push, 1)\n\nstruct lcp {\n  uint8_t addr, ctrl, proto[2], code, id, len[2];\n};\n\nstruct eth {\n  uint8_t dst[6];  // Destination MAC address\n  uint8_t src[6];  // Source MAC address\n  uint16_t type;   // Ethernet type\n};\n\nstruct ip {\n  uint8_t ver;    // Version\n  uint8_t tos;    // Unused\n  uint16_t len;   // Length\n  uint16_t id;    // Unused\n  uint16_t frag;  // Fragmentation\n#define IP_FRAG_OFFSET_MSK 0x1fff\n#define IP_MORE_FRAGS_MSK 0x2000\n  uint8_t ttl;    // Time to live\n  uint8_t proto;  // Upper level protocol\n  uint16_t csum;  // Checksum\n  uint32_t src;   // Source IP\n  uint32_t dst;   // Destination IP\n};\n\nstruct ip6 {\n  uint8_t ver;      // Version\n  uint8_t opts[3];  // Options\n  uint16_t len;     // Length\n  uint8_t proto;    // Upper level protocol\n  uint8_t ttl;      // Time to live\n  uint8_t src[16];  // Source IP\n  uint8_t dst[16];  // Destination IP\n};\n\nstruct icmp {\n  uint8_t type;\n  uint8_t code;\n  uint16_t csum;\n};\n\nstruct arp {\n  uint16_t fmt;    // Format of hardware address\n  uint16_t pro;    // Format of protocol address\n  uint8_t hlen;    // Length of hardware address\n  uint8_t plen;    // Length of protocol address\n  uint16_t op;     // Operation\n  uint8_t sha[6];  // Sender hardware address\n  uint32_t spa;    // Sender protocol address\n  uint8_t tha[6];  // Target hardware address\n  uint32_t tpa;    // Target protocol address\n};\n\nstruct tcp {\n  uint16_t sport;  // Source port\n  uint16_t dport;  // Destination port\n  uint32_t seq;    // Sequence number\n  uint32_t ack;    // Acknowledgement number\n  uint8_t off;     // Data offset\n  uint8_t flags;   // TCP flags\n#define TH_FIN 0x01\n#define TH_SYN 0x02\n#define TH_RST 0x04\n#define TH_PUSH 0x08\n#define TH_ACK 0x10\n#define TH_URG 0x20\n#define TH_ECE 0x40\n#define TH_CWR 0x80\n  uint16_t win;   // Window\n  uint16_t csum;  // Checksum\n  uint16_t urp;   // Urgent pointer\n};\n\nstruct udp {\n  uint16_t sport;  // Source port\n  uint16_t dport;  // Destination port\n  uint16_t len;    // UDP length\n  uint16_t csum;   // UDP checksum\n};\n\nstruct dhcp {\n  uint8_t op, htype, hlen, hops;\n  uint32_t xid;\n  uint16_t secs, flags;\n  uint32_t ciaddr, yiaddr, siaddr, giaddr;\n  uint8_t hwaddr[208];\n  uint32_t magic;\n  uint8_t options[32];\n};\n\n#pragma pack(pop)\n\nstruct pkt {\n  struct mg_str raw;  // Raw packet data\n  struct mg_str pay;  // Payload data\n  struct eth *eth;\n  struct llc *llc;\n  struct arp *arp;\n  struct ip *ip;\n  struct ip6 *ip6;\n  struct icmp *icmp;\n  struct tcp *tcp;\n  struct udp *udp;\n  struct dhcp *dhcp;\n};\n\nstatic void mg_tcpip_call(struct mg_tcpip_if *ifp, int ev, void *ev_data) {\n  if (ifp->fn != NULL) ifp->fn(ifp, ev, ev_data);\n}\n\nstatic void send_syn(struct mg_connection *c);\n\nstatic void mkpay(struct pkt *pkt, void *p) {\n  pkt->pay =\n      mg_str_n((char *) p, (size_t) (&pkt->raw.buf[pkt->raw.len] - (char *) p));\n}\n\nstatic uint32_t csumup(uint32_t sum, const void *buf, size_t len) {\n  size_t i;\n  const uint8_t *p = (const uint8_t *) buf;\n  for (i = 0; i < len; i++) sum += i & 1 ? p[i] : ((uint32_t) p[i]) << 8;\n  return sum;\n}\n\nstatic uint16_t csumfin(uint32_t sum) {\n  while (sum >> 16) sum = (sum & 0xffff) + (sum >> 16);\n  return mg_htons(~sum & 0xffff);\n}\n\nstatic uint16_t ipcsum(const void *buf, size_t len) {\n  uint32_t sum = csumup(0, buf, len);\n  return csumfin(sum);\n}\n\nstatic void settmout(struct mg_connection *c, uint8_t type) {\n  struct mg_tcpip_if *ifp = c->mgr->ifp;\n  struct connstate *s = (struct connstate *) (c + 1);\n  unsigned n = type == MIP_TTYPE_ACK   ? MIP_TCP_ACK_MS\n               : type == MIP_TTYPE_ARP ? MIP_ARP_RESP_MS\n               : type == MIP_TTYPE_SYN ? MIP_TCP_SYN_MS\n               : type == MIP_TTYPE_FIN ? MIP_TCP_FIN_MS\n                                       : MIP_TCP_KEEPALIVE_MS;\n  s->timer = ifp->now + n;\n  s->ttype = type;\n  MG_VERBOSE((\"%lu %d -> %llx\", c->id, type, s->timer));\n}\n\nstatic size_t ether_output(struct mg_tcpip_if *ifp, size_t len) {\n  size_t n = ifp->driver->tx(ifp->tx.buf, len, ifp);\n  if (n == len) ifp->nsent++;\n  return n;\n}\n\nvoid mg_tcpip_arp_request(struct mg_tcpip_if *ifp, uint32_t ip, uint8_t *mac) {\n  struct eth *eth = (struct eth *) ifp->tx.buf;\n  struct arp *arp = (struct arp *) (eth + 1);\n  memset(eth->dst, 255, sizeof(eth->dst));\n  memcpy(eth->src, ifp->mac, sizeof(eth->src));\n  eth->type = mg_htons(0x806);\n  memset(arp, 0, sizeof(*arp));\n  arp->fmt = mg_htons(1), arp->pro = mg_htons(0x800), arp->hlen = 6,\n  arp->plen = 4;\n  arp->op = mg_htons(1), arp->tpa = ip, arp->spa = ifp->ip;\n  memcpy(arp->sha, ifp->mac, sizeof(arp->sha));\n  if (mac != NULL) memcpy(arp->tha, mac, sizeof(arp->tha));\n  ether_output(ifp, PDIFF(eth, arp + 1));\n}\n\nstatic void onstatechange(struct mg_tcpip_if *ifp) {\n  if (ifp->state == MG_TCPIP_STATE_READY) {\n    MG_INFO((\"READY, IP: %M\", mg_print_ip4, &ifp->ip));\n    MG_INFO((\"       GW: %M\", mg_print_ip4, &ifp->gw));\n    MG_INFO((\"      MAC: %M\", mg_print_mac, &ifp->mac));\n  } else if (ifp->state == MG_TCPIP_STATE_IP) {\n    MG_ERROR((\"Got IP\"));\n    mg_tcpip_arp_request(ifp, ifp->gw, NULL);  // unsolicited GW ARP request\n  } else if (ifp->state == MG_TCPIP_STATE_UP) {\n    MG_ERROR((\"Link up\"));\n    srand((unsigned int) mg_millis());\n  } else if (ifp->state == MG_TCPIP_STATE_DOWN) {\n    MG_ERROR((\"Link down\"));\n  }\n  mg_tcpip_call(ifp, MG_TCPIP_EV_ST_CHG, &ifp->state);\n}\n\nstatic struct ip *tx_ip(struct mg_tcpip_if *ifp, uint8_t *mac_dst,\n                        uint8_t proto, uint32_t ip_src, uint32_t ip_dst,\n                        size_t plen) {\n  struct eth *eth = (struct eth *) ifp->tx.buf;\n  struct ip *ip = (struct ip *) (eth + 1);\n  memcpy(eth->dst, mac_dst, sizeof(eth->dst));\n  memcpy(eth->src, ifp->mac, sizeof(eth->src));  // Use our MAC\n  eth->type = mg_htons(0x800);\n  memset(ip, 0, sizeof(*ip));\n  ip->ver = 0x45;               // Version 4, header length 5 words\n  ip->frag = mg_htons(0x4000);  // Don't fragment\n  ip->len = mg_htons((uint16_t) (sizeof(*ip) + plen));\n  ip->ttl = 64;\n  ip->proto = proto;\n  ip->src = ip_src;\n  ip->dst = ip_dst;\n  ip->csum = ipcsum(ip, sizeof(*ip));\n  return ip;\n}\n\nstatic void tx_udp(struct mg_tcpip_if *ifp, uint8_t *mac_dst, uint32_t ip_src,\n                   uint16_t sport, uint32_t ip_dst, uint16_t dport,\n                   const void *buf, size_t len) {\n  struct ip *ip =\n      tx_ip(ifp, mac_dst, 17, ip_src, ip_dst, len + sizeof(struct udp));\n  struct udp *udp = (struct udp *) (ip + 1);\n  // MG_DEBUG((\"UDP XX LEN %d %d\", (int) len, (int) ifp->tx.len));\n  udp->sport = sport;\n  udp->dport = dport;\n  udp->len = mg_htons((uint16_t) (sizeof(*udp) + len));\n  udp->csum = 0;\n  uint32_t cs = csumup(0, udp, sizeof(*udp));\n  cs = csumup(cs, buf, len);\n  cs = csumup(cs, &ip->src, sizeof(ip->src));\n  cs = csumup(cs, &ip->dst, sizeof(ip->dst));\n  cs += (uint32_t) (ip->proto + sizeof(*udp) + len);\n  udp->csum = csumfin(cs);\n  memmove(udp + 1, buf, len);\n  // MG_DEBUG((\"UDP LEN %d %d\", (int) len, (int) ifp->frame_len));\n  ether_output(ifp, sizeof(struct eth) + sizeof(*ip) + sizeof(*udp) + len);\n}\n\nstatic void tx_dhcp(struct mg_tcpip_if *ifp, uint8_t *mac_dst, uint32_t ip_src,\n                    uint32_t ip_dst, uint8_t *opts, size_t optslen,\n                    bool ciaddr) {\n  // https://datatracker.ietf.org/doc/html/rfc2132#section-9.6\n  struct dhcp dhcp = {1, 1, 6, 0, 0, 0, 0, 0, 0, 0, 0, {0}, 0, {0}};\n  dhcp.magic = mg_htonl(0x63825363);\n  memcpy(&dhcp.hwaddr, ifp->mac, sizeof(ifp->mac));\n  memcpy(&dhcp.xid, ifp->mac + 2, sizeof(dhcp.xid));\n  memcpy(&dhcp.options, opts, optslen);\n  if (ciaddr) dhcp.ciaddr = ip_src;\n  tx_udp(ifp, mac_dst, ip_src, mg_htons(68), ip_dst, mg_htons(67), &dhcp,\n         sizeof(dhcp));\n}\n\nstatic const uint8_t broadcast[] = {255, 255, 255, 255, 255, 255};\n\n// RFC-2131 #4.3.6, #4.4.1; RFC-2132 #9.8\nstatic void tx_dhcp_request_sel(struct mg_tcpip_if *ifp, uint32_t ip_req,\n                                uint32_t ip_srv) {\n  uint8_t opts[] = {\n      53, 1, 3,                   // Type: DHCP request\n      12, 3, 'm', 'i', 'p',       // Host name: \"mip\"\n      54, 4, 0,   0,   0,   0,    // DHCP server ID\n      50, 4, 0,   0,   0,   0,    // Requested IP\n      55, 2, 1,   3,   255, 255,  // GW, mask [DNS] [SNTP]\n      255                         // End of options\n  };\n  uint8_t addopts = 0;\n  memcpy(opts + 10, &ip_srv, sizeof(ip_srv));\n  memcpy(opts + 16, &ip_req, sizeof(ip_req));\n  if (ifp->enable_req_dns) opts[24 + addopts++] = 6;    // DNS\n  if (ifp->enable_req_sntp) opts[24 + addopts++] = 42;  // SNTP\n  opts[21] += addopts;\n  tx_dhcp(ifp, (uint8_t *) broadcast, 0, 0xffffffff, opts,\n          sizeof(opts) + addopts - 2, false);\n  MG_DEBUG((\"DHCP req sent\"));\n}\n\n// RFC-2131 #4.3.6, #4.4.5 (renewing: unicast, rebinding: bcast)\nstatic void tx_dhcp_request_re(struct mg_tcpip_if *ifp, uint8_t *mac_dst,\n                               uint32_t ip_src, uint32_t ip_dst) {\n  uint8_t opts[] = {\n      53, 1, 3,  // Type: DHCP request\n      255        // End of options\n  };\n  tx_dhcp(ifp, mac_dst, ip_src, ip_dst, opts, sizeof(opts), true);\n  MG_DEBUG((\"DHCP req sent\"));\n}\n\nstatic void tx_dhcp_discover(struct mg_tcpip_if *ifp) {\n  uint8_t opts[] = {\n      53, 1, 1,     // Type: DHCP discover\n      55, 2, 1, 3,  // Parameters: ip, mask\n      255           // End of options\n  };\n  tx_dhcp(ifp, (uint8_t *) broadcast, 0, 0xffffffff, opts, sizeof(opts), false);\n  MG_DEBUG((\"DHCP discover sent. Our MAC: %M\", mg_print_mac, ifp->mac));\n}\n\nstatic struct mg_connection *getpeer(struct mg_mgr *mgr, struct pkt *pkt,\n                                     bool lsn) {\n  struct mg_connection *c = NULL;\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    if (c->is_arplooking && pkt->arp &&\n        memcmp(&pkt->arp->spa, c->rem.ip, sizeof(pkt->arp->spa)) == 0)\n      break;\n    if (c->is_udp && pkt->udp && c->loc.port == pkt->udp->dport) break;\n    if (!c->is_udp && pkt->tcp && c->loc.port == pkt->tcp->dport &&\n        lsn == c->is_listening && (lsn || c->rem.port == pkt->tcp->sport))\n      break;\n  }\n  return c;\n}\n\nstatic void mac_resolved(struct mg_connection *c);\n\nstatic void rx_arp(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  if (pkt->arp->op == mg_htons(1) && pkt->arp->tpa == ifp->ip) {\n    // ARP request. Make a response, then send\n    // MG_DEBUG((\"ARP op %d %M: %M\", mg_ntohs(pkt->arp->op), mg_print_ip4,\n    //          &pkt->arp->spa, mg_print_ip4, &pkt->arp->tpa));\n    struct eth *eth = (struct eth *) ifp->tx.buf;\n    struct arp *arp = (struct arp *) (eth + 1);\n    memcpy(eth->dst, pkt->eth->src, sizeof(eth->dst));\n    memcpy(eth->src, ifp->mac, sizeof(eth->src));\n    eth->type = mg_htons(0x806);\n    *arp = *pkt->arp;\n    arp->op = mg_htons(2);\n    memcpy(arp->tha, pkt->arp->sha, sizeof(pkt->arp->tha));\n    memcpy(arp->sha, ifp->mac, sizeof(pkt->arp->sha));\n    arp->tpa = pkt->arp->spa;\n    arp->spa = ifp->ip;\n    MG_DEBUG((\"ARP: tell %M we're %M\", mg_print_ip4, &arp->tpa, mg_print_mac,\n              &ifp->mac));\n    ether_output(ifp, PDIFF(eth, arp + 1));\n  } else if (pkt->arp->op == mg_htons(2)) {\n    if (memcmp(pkt->arp->tha, ifp->mac, sizeof(pkt->arp->tha)) != 0) return;\n    if (pkt->arp->spa == ifp->gw) {\n      // Got response for the GW ARP request. Set ifp->gwmac and IP -> READY\n      memcpy(ifp->gwmac, pkt->arp->sha, sizeof(ifp->gwmac));\n      if (ifp->state == MG_TCPIP_STATE_IP) {\n        ifp->state = MG_TCPIP_STATE_READY;\n        onstatechange(ifp);\n      }\n    } else {\n      struct mg_connection *c = getpeer(ifp->mgr, pkt, false);\n      if (c != NULL && c->is_arplooking) {\n        struct connstate *s = (struct connstate *) (c + 1);\n        memcpy(s->mac, pkt->arp->sha, sizeof(s->mac));\n        MG_DEBUG((\"%lu ARP resolved %M -> %M\", c->id, mg_print_ip4, c->rem.ip,\n                  mg_print_mac, s->mac));\n        c->is_arplooking = 0;\n        mac_resolved(c);\n      }\n    }\n  }\n}\n\nstatic void rx_icmp(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  // MG_DEBUG((\"ICMP %d\", (int) len));\n  if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip) {\n    size_t hlen = sizeof(struct eth) + sizeof(struct ip) + sizeof(struct icmp);\n    size_t space = ifp->tx.len - hlen, plen = pkt->pay.len;\n    if (plen > space) plen = space;\n    struct ip *ip = tx_ip(ifp, pkt->eth->src, 1, ifp->ip, pkt->ip->src,\n                          sizeof(struct icmp) + plen);\n    struct icmp *icmp = (struct icmp *) (ip + 1);\n    memset(icmp, 0, sizeof(*icmp));        // Set csum to 0\n    memcpy(icmp + 1, pkt->pay.buf, plen);  // Copy RX payload to TX\n    icmp->csum = ipcsum(icmp, sizeof(*icmp) + plen);\n    ether_output(ifp, hlen + plen);\n  }\n}\n\nstatic void rx_dhcp_client(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  uint32_t ip = 0, gw = 0, mask = 0, lease = 0, dns = 0, sntp = 0;\n  uint8_t msgtype = 0, state = ifp->state;\n  // perform size check first, then access fields\n  uint8_t *p = pkt->dhcp->options,\n          *end = (uint8_t *) &pkt->raw.buf[pkt->raw.len];\n  if (end < (uint8_t *) (pkt->dhcp + 1)) return;\n  if (memcmp(&pkt->dhcp->xid, ifp->mac + 2, sizeof(pkt->dhcp->xid))) return;\n  while (p + 1 < end && p[0] != 255) {  // Parse options RFC-1533 #9\n    if (p[0] == 1 && p[1] == sizeof(ifp->mask) && p + 6 < end) {  // Mask\n      memcpy(&mask, p + 2, sizeof(mask));\n    } else if (p[0] == 3 && p[1] == sizeof(ifp->gw) && p + 6 < end) {  // GW\n      memcpy(&gw, p + 2, sizeof(gw));\n      ip = pkt->dhcp->yiaddr;\n    } else if (ifp->enable_req_dns && p[0] == 6 && p[1] == sizeof(dns) &&\n               p + 6 < end) {  // DNS\n      memcpy(&dns, p + 2, sizeof(dns));\n    } else if (ifp->enable_req_sntp && p[0] == 42 && p[1] == sizeof(sntp) &&\n               p + 6 < end) {  // SNTP\n      memcpy(&sntp, p + 2, sizeof(sntp));\n    } else if (p[0] == 51 && p[1] == 4 && p + 6 < end) {  // Lease\n      memcpy(&lease, p + 2, sizeof(lease));\n      lease = mg_ntohl(lease);\n    } else if (p[0] == 53 && p[1] == 1 && p + 6 < end) {  // Msg Type\n      msgtype = p[2];\n    }\n    p += p[1] + 2;\n  }\n  // Process message type, RFC-1533 (9.4); RFC-2131 (3.1, 4)\n  if (msgtype == 6 && ifp->ip == ip) {  // DHCPNACK, release IP\n    ifp->state = MG_TCPIP_STATE_UP, ifp->ip = 0;\n  } else if (msgtype == 2 && ifp->state == MG_TCPIP_STATE_UP && ip && gw &&\n             lease) {  // DHCPOFFER\n    // select IP, (4.4.1) (fallback to IP source addr on foul play)\n    tx_dhcp_request_sel(ifp, ip,\n                        pkt->dhcp->siaddr ? pkt->dhcp->siaddr : pkt->ip->src);\n    ifp->state = MG_TCPIP_STATE_REQ;  // REQUESTING state\n  } else if (msgtype == 5) {          // DHCPACK\n    if (ifp->state == MG_TCPIP_STATE_REQ && ip && gw && lease) {  // got an IP\n      ifp->lease_expire = ifp->now + lease * 1000;\n      MG_INFO((\"Lease: %u sec (%lld)\", lease, ifp->lease_expire / 1000));\n      // assume DHCP server = router until ARP resolves\n      memcpy(ifp->gwmac, pkt->eth->src, sizeof(ifp->gwmac));\n      ifp->ip = ip, ifp->gw = gw, ifp->mask = mask;\n      ifp->state = MG_TCPIP_STATE_IP;  // BOUND state\n      uint64_t rand;\n      mg_random(&rand, sizeof(rand));\n      srand((unsigned int) (rand + mg_millis()));\n      if (ifp->enable_req_dns && dns != 0)\n        mg_tcpip_call(ifp, MG_TCPIP_EV_DHCP_DNS, &dns);\n      if (ifp->enable_req_sntp && sntp != 0)\n        mg_tcpip_call(ifp, MG_TCPIP_EV_DHCP_SNTP, &sntp);\n    } else if (ifp->state == MG_TCPIP_STATE_READY && ifp->ip == ip) {  // renew\n      ifp->lease_expire = ifp->now + lease * 1000;\n      MG_INFO((\"Lease: %u sec (%lld)\", lease, ifp->lease_expire / 1000));\n    }  // TODO(): accept provided T1/T2 and store server IP for renewal (4.4)\n  }\n  if (ifp->state != state) onstatechange(ifp);\n}\n\n// Simple DHCP server that assigns a next IP address: ifp->ip + 1\nstatic void rx_dhcp_server(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  uint8_t op = 0, *p = pkt->dhcp->options,\n          *end = (uint8_t *) &pkt->raw.buf[pkt->raw.len];\n  if (end < (uint8_t *) (pkt->dhcp + 1)) return;\n  // struct dhcp *req = pkt->dhcp;\n  struct dhcp res = {2, 1, 6, 0, 0, 0, 0, 0, 0, 0, 0, {0}, 0, {0}};\n  res.yiaddr = ifp->ip;\n  ((uint8_t *) (&res.yiaddr))[3]++;                // Offer our IP + 1\n  while (p + 1 < end && p[0] != 255) {             // Parse options\n    if (p[0] == 53 && p[1] == 1 && p + 2 < end) {  // Message type\n      op = p[2];\n    }\n    p += p[1] + 2;\n  }\n  if (op == 1 || op == 3) {         // DHCP Discover or DHCP Request\n    uint8_t msg = op == 1 ? 2 : 5;  // Message type: DHCP OFFER or DHCP ACK\n    uint8_t opts[] = {\n        53, 1, msg,                 // Message type\n        1,  4, 0,   0,   0,   0,    // Subnet mask\n        54, 4, 0,   0,   0,   0,    // Server ID\n        12, 3, 'm', 'i', 'p',       // Host name: \"mip\"\n        51, 4, 255, 255, 255, 255,  // Lease time\n        255                         // End of options\n    };\n    memcpy(&res.hwaddr, pkt->dhcp->hwaddr, 6);\n    memcpy(opts + 5, &ifp->mask, sizeof(ifp->mask));\n    memcpy(opts + 11, &ifp->ip, sizeof(ifp->ip));\n    memcpy(&res.options, opts, sizeof(opts));\n    res.magic = pkt->dhcp->magic;\n    res.xid = pkt->dhcp->xid;\n    if (ifp->enable_get_gateway) {\n      ifp->gw = res.yiaddr;  // set gw IP, best-effort gwmac as DHCP server's\n      memcpy(ifp->gwmac, pkt->eth->src, sizeof(ifp->gwmac));\n    }\n    tx_udp(ifp, pkt->eth->src, ifp->ip, mg_htons(67),\n           op == 1 ? ~0U : res.yiaddr, mg_htons(68), &res, sizeof(res));\n  }\n}\n\nstatic void rx_udp(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  struct mg_connection *c = getpeer(ifp->mgr, pkt, true);\n  if (c == NULL) {\n    // No UDP listener on this port. Should send ICMP, but keep silent.\n  } else {\n    c->rem.port = pkt->udp->sport;\n    memcpy(c->rem.ip, &pkt->ip->src, sizeof(uint32_t));\n    struct connstate *s = (struct connstate *) (c + 1);\n    memcpy(s->mac, pkt->eth->src, sizeof(s->mac));\n    if (c->recv.len >= MG_MAX_RECV_SIZE) {\n      mg_error(c, \"max_recv_buf_size reached\");\n    } else if (c->recv.size - c->recv.len < pkt->pay.len &&\n               !mg_iobuf_resize(&c->recv, c->recv.len + pkt->pay.len)) {\n      mg_error(c, \"oom\");\n    } else {\n      memcpy(&c->recv.buf[c->recv.len], pkt->pay.buf, pkt->pay.len);\n      c->recv.len += pkt->pay.len;\n      mg_call(c, MG_EV_READ, &pkt->pay.len);\n    }\n  }\n}\n\nstatic size_t tx_tcp(struct mg_tcpip_if *ifp, uint8_t *dst_mac, uint32_t dst_ip,\n                     uint8_t flags, uint16_t sport, uint16_t dport,\n                     uint32_t seq, uint32_t ack, const void *buf, size_t len) {\n#if 0\n  uint8_t opts[] = {2, 4, 5, 0xb4, 4, 2, 0, 0};  // MSS = 1460, SACK permitted\n  if (flags & TH_SYN) {\n    // Handshake? Set MSS\n    buf = opts;\n    len = sizeof(opts);\n  }\n#endif\n  struct ip *ip =\n      tx_ip(ifp, dst_mac, 6, ifp->ip, dst_ip, sizeof(struct tcp) + len);\n  struct tcp *tcp = (struct tcp *) (ip + 1);\n  memset(tcp, 0, sizeof(*tcp));\n  if (buf != NULL && len) memmove(tcp + 1, buf, len);\n  tcp->sport = sport;\n  tcp->dport = dport;\n  tcp->seq = seq;\n  tcp->ack = ack;\n  tcp->flags = flags;\n  tcp->win = mg_htons(MIP_TCP_WIN);\n  tcp->off = (uint8_t) (sizeof(*tcp) / 4 << 4);\n  // if (flags & TH_SYN) tcp->off = 0x70;  // Handshake? header size 28 bytes\n\n  uint32_t cs = 0;\n  uint16_t n = (uint16_t) (sizeof(*tcp) + len);\n  uint8_t pseudo[] = {0, ip->proto, (uint8_t) (n >> 8), (uint8_t) (n & 255)};\n  cs = csumup(cs, tcp, n);\n  cs = csumup(cs, &ip->src, sizeof(ip->src));\n  cs = csumup(cs, &ip->dst, sizeof(ip->dst));\n  cs = csumup(cs, pseudo, sizeof(pseudo));\n  tcp->csum = csumfin(cs);\n  MG_VERBOSE((\"TCP %M:%hu -> %M:%hu fl %x len %u\", mg_print_ip4, &ip->src,\n              mg_ntohs(tcp->sport), mg_print_ip4, &ip->dst,\n              mg_ntohs(tcp->dport), tcp->flags, len));\n  // mg_hexdump(ifp->tx.buf, PDIFF(ifp->tx.buf, tcp + 1) + len);\n  return ether_output(ifp, PDIFF(ifp->tx.buf, tcp + 1) + len);\n}\n\nstatic size_t tx_tcp_pkt(struct mg_tcpip_if *ifp, struct pkt *pkt,\n                         uint8_t flags, uint32_t seq, const void *buf,\n                         size_t len) {\n  uint32_t delta = (pkt->tcp->flags & (TH_SYN | TH_FIN)) ? 1 : 0;\n  return tx_tcp(ifp, pkt->eth->src, pkt->ip->src, flags, pkt->tcp->dport,\n                pkt->tcp->sport, seq, mg_htonl(mg_ntohl(pkt->tcp->seq) + delta),\n                buf, len);\n}\n\nstatic struct mg_connection *accept_conn(struct mg_connection *lsn,\n                                         struct pkt *pkt) {\n  struct mg_connection *c = mg_alloc_conn(lsn->mgr);\n  if (c == NULL) {\n    MG_ERROR((\"OOM\"));\n    return NULL;\n  }\n  struct connstate *s = (struct connstate *) (c + 1);\n  s->seq = mg_ntohl(pkt->tcp->ack), s->ack = mg_ntohl(pkt->tcp->seq);\n  memcpy(s->mac, pkt->eth->src, sizeof(s->mac));\n  settmout(c, MIP_TTYPE_KEEPALIVE);\n  memcpy(c->rem.ip, &pkt->ip->src, sizeof(uint32_t));\n  c->rem.port = pkt->tcp->sport;\n  MG_DEBUG((\"%lu accepted %M\", c->id, mg_print_ip_port, &c->rem));\n  LIST_ADD_HEAD(struct mg_connection, &lsn->mgr->conns, c);\n  c->is_accepted = 1;\n  c->is_hexdumping = lsn->is_hexdumping;\n  c->pfn = lsn->pfn;\n  c->loc = lsn->loc;\n  c->pfn_data = lsn->pfn_data;\n  c->fn = lsn->fn;\n  c->fn_data = lsn->fn_data;\n  mg_call(c, MG_EV_OPEN, NULL);\n  mg_call(c, MG_EV_ACCEPT, NULL);\n  return c;\n}\n\nstatic size_t trim_len(struct mg_connection *c, size_t len) {\n  struct mg_tcpip_if *ifp = c->mgr->ifp;\n  size_t eth_h_len = 14, ip_max_h_len = 24, tcp_max_h_len = 60, udp_h_len = 8;\n  size_t max_headers_len =\n      eth_h_len + ip_max_h_len + (c->is_udp ? udp_h_len : tcp_max_h_len);\n  size_t min_mtu = c->is_udp ? 68 /* RFC-791 */ : max_headers_len - eth_h_len;\n\n  // If the frame exceeds the available buffer, trim the length\n  if (len + max_headers_len > ifp->tx.len) {\n    len = ifp->tx.len - max_headers_len;\n  }\n  // Ensure the MTU isn't lower than the minimum allowed value\n  if (ifp->mtu < min_mtu) {\n    MG_ERROR((\"MTU is lower than minimum, capping to %lu\", min_mtu));\n    ifp->mtu = (uint16_t) min_mtu;\n  }\n  // If the total packet size exceeds the MTU, trim the length\n  if (len + max_headers_len - eth_h_len > ifp->mtu) {\n    len = ifp->mtu - max_headers_len + eth_h_len;\n    if (c->is_udp) {\n      MG_ERROR((\"UDP datagram exceeds MTU. Truncating it.\"));\n    }\n  }\n\n  return len;\n}\n\nlong mg_io_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tcpip_if *ifp = c->mgr->ifp;\n  struct connstate *s = (struct connstate *) (c + 1);\n  uint32_t dst_ip = *(uint32_t *) c->rem.ip;\n  len = trim_len(c, len);\n  if (c->is_udp) {\n    tx_udp(ifp, s->mac, ifp->ip, c->loc.port, dst_ip, c->rem.port, buf, len);\n  } else {\n    size_t sent =\n        tx_tcp(ifp, s->mac, dst_ip, TH_PUSH | TH_ACK, c->loc.port, c->rem.port,\n               mg_htonl(s->seq), mg_htonl(s->ack), buf, len);\n    if (sent == 0) {\n      return MG_IO_WAIT;\n    } else if (sent == (size_t) -1) {\n      return MG_IO_ERR;\n    } else {\n      s->seq += (uint32_t) len;\n      if (s->ttype == MIP_TTYPE_ACK) settmout(c, MIP_TTYPE_KEEPALIVE);\n    }\n  }\n  return (long) len;\n}\n\nstatic void handle_tls_recv(struct mg_connection *c) {\n  size_t avail = mg_tls_pending(c); \n  size_t min = avail > MG_MAX_RECV_SIZE ? MG_MAX_RECV_SIZE : avail;\n  struct mg_iobuf *io = &c->recv;\n  if (io->size - io->len < min && !mg_iobuf_resize(io, io->len + min)) {\n    mg_error(c, \"oom\");\n  } else {\n    // Decrypt data directly into c->recv\n    long n = mg_tls_recv(c, &io->buf[io->len], io->size - io->len);\n    if (n == MG_IO_ERR) {\n      mg_error(c, \"TLS recv error\");\n    } else if (n > 0) {\n      // Decrypted successfully - trigger MG_EV_READ\n      io->len += (size_t) n;\n      mg_call(c, MG_EV_READ, &n);\n    } // else n < 0: outstanding data to be moved to c->recv\n  }\n}\n\nstatic void read_conn(struct mg_connection *c, struct pkt *pkt) {\n  struct connstate *s = (struct connstate *) (c + 1);\n  struct mg_iobuf *io = c->is_tls ? &c->rtls : &c->recv;\n  uint32_t seq = mg_ntohl(pkt->tcp->seq);\n  uint32_t rem_ip;\n  memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));\n  if (pkt->tcp->flags & TH_FIN) {\n    // If we initiated the closure, we reply with ACK upon receiving FIN\n    // If we didn't initiate it, we reply with FIN as part of the normal TCP\n    // closure process\n    uint8_t flags = TH_ACK;\n    s->ack = (uint32_t) (mg_htonl(pkt->tcp->seq) + pkt->pay.len + 1);\n    if (c->is_draining && s->ttype == MIP_TTYPE_FIN) {\n      if (s->seq == mg_htonl(pkt->tcp->ack)) {  // Simultaneous closure ?\n        s->seq++;                               // Yes. Increment our SEQ\n      } else {                                  // Otherwise,\n        s->seq = mg_htonl(pkt->tcp->ack);       // Set to peer's ACK\n      }\n    } else {\n      flags |= TH_FIN;\n      c->is_draining = 1;\n      settmout(c, MIP_TTYPE_FIN);\n    }\n    tx_tcp(c->mgr->ifp, s->mac, rem_ip, flags, c->loc.port, c->rem.port,\n           mg_htonl(s->seq), mg_htonl(s->ack), \"\", 0);\n  } else if (pkt->pay.len == 0) {\n    // TODO(cpq): handle this peer's ACK\n  } else if (seq != s->ack) {\n    uint32_t ack = (uint32_t) (mg_htonl(pkt->tcp->seq) + pkt->pay.len);\n    if (s->ack == ack) {\n      MG_VERBOSE((\"ignoring duplicate pkt\"));\n    } else {\n      MG_VERBOSE((\"SEQ != ACK: %x %x %x\", seq, s->ack, ack));\n      tx_tcp(c->mgr->ifp, s->mac, rem_ip, TH_ACK, c->loc.port, c->rem.port,\n             mg_htonl(s->seq), mg_htonl(s->ack), \"\", 0);\n    }\n  } else if (io->size - io->len < pkt->pay.len &&\n             !mg_iobuf_resize(io, io->len + pkt->pay.len)) {\n    mg_error(c, \"oom\");\n  } else {\n    // Copy TCP payload into the IO buffer. If the connection is plain text,\n    // we copy to c->recv. If the connection is TLS, this data is encrypted,\n    // therefore we copy that encrypted data to the c->rtls iobuffer instead,\n    // and then call mg_tls_recv() to decrypt it. NOTE: mg_tls_recv() will\n    // call back mg_io_recv() which grabs raw data from c->rtls\n    memcpy(&io->buf[io->len], pkt->pay.buf, pkt->pay.len);\n    io->len += pkt->pay.len;\n\n    MG_VERBOSE((\"%lu SEQ %x -> %x\", c->id, mg_htonl(pkt->tcp->seq), s->ack));\n    // Advance ACK counter\n    s->ack = (uint32_t) (mg_htonl(pkt->tcp->seq) + pkt->pay.len);\n    s->unacked += pkt->pay.len;\n    // size_t diff = s->acked <= s->ack ? s->ack - s->acked : s->ack;\n    if (s->unacked > MIP_TCP_WIN / 2 && s->acked != s->ack) {\n      // Send ACK immediately\n      MG_VERBOSE((\"%lu imm ACK %lu\", c->id, s->acked));\n      tx_tcp(c->mgr->ifp, s->mac, rem_ip, TH_ACK, c->loc.port, c->rem.port,\n             mg_htonl(s->seq), mg_htonl(s->ack), NULL, 0);\n      s->unacked = 0;\n      s->acked = s->ack;\n      if (s->ttype != MIP_TTYPE_KEEPALIVE) settmout(c, MIP_TTYPE_KEEPALIVE);\n    } else {\n      // if not already running, setup a timer to send an ACK later\n      if (s->ttype != MIP_TTYPE_ACK) settmout(c, MIP_TTYPE_ACK);\n    }\n\n    if (c->is_tls && c->is_tls_hs) {\n      mg_tls_handshake(c);\n    } else if (c->is_tls) {\n      handle_tls_recv(c);\n    } else {\n      // Plain text connection, data is already in c->recv, trigger MG_EV_READ\n      mg_call(c, MG_EV_READ, &pkt->pay.len);\n    }\n  }\n}\n\nstatic void rx_tcp(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  struct mg_connection *c = getpeer(ifp->mgr, pkt, false);\n  struct connstate *s = c == NULL ? NULL : (struct connstate *) (c + 1);\n#if 0\n  MG_INFO((\"%lu %hhu %d\", c ? c->id : 0, pkt->tcp->flags, (int) pkt->pay.len));\n#endif\n  if (c != NULL && c->is_connecting && pkt->tcp->flags == (TH_SYN | TH_ACK)) {\n    s->seq = mg_ntohl(pkt->tcp->ack), s->ack = mg_ntohl(pkt->tcp->seq) + 1;\n    tx_tcp_pkt(ifp, pkt, TH_ACK, pkt->tcp->ack, NULL, 0);\n    c->is_connecting = 0;  // Client connected\n    settmout(c, MIP_TTYPE_KEEPALIVE);\n    mg_call(c, MG_EV_CONNECT, NULL);  // Let user know\n    if (c->is_tls_hs) mg_tls_handshake(c);\n  } else if (c != NULL && c->is_connecting && pkt->tcp->flags != TH_ACK) {\n    // mg_hexdump(pkt->raw.buf, pkt->raw.len);\n    tx_tcp_pkt(ifp, pkt, TH_RST | TH_ACK, pkt->tcp->ack, NULL, 0);\n  } else if (c != NULL && pkt->tcp->flags & TH_RST) {\n    mg_error(c, \"peer RST\");  // RFC-1122 4.2.2.13\n  } else if (c != NULL) {\n#if 0\n    MG_DEBUG((\"%lu %d %M:%hu -> %M:%hu\", c->id, (int) pkt->raw.len,\n              mg_print_ip4, &pkt->ip->src, mg_ntohs(pkt->tcp->sport),\n              mg_print_ip4, &pkt->ip->dst, mg_ntohs(pkt->tcp->dport)));\n    mg_hexdump(pkt->pay.buf, pkt->pay.len);\n#endif\n    s->tmiss = 0;                         // Reset missed keep-alive counter\n    if (s->ttype == MIP_TTYPE_KEEPALIVE)  // Advance keep-alive timer\n      settmout(c,\n               MIP_TTYPE_KEEPALIVE);  // unless a former ACK timeout is pending\n    read_conn(c, pkt);  // Override timer with ACK timeout if needed\n  } else if ((c = getpeer(ifp->mgr, pkt, true)) == NULL) {\n    tx_tcp_pkt(ifp, pkt, TH_RST | TH_ACK, pkt->tcp->ack, NULL, 0);\n  } else if (pkt->tcp->flags & TH_RST) {\n    if (c->is_accepted) mg_error(c, \"peer RST\");  // RFC-1122 4.2.2.13\n    // ignore RST if not connected\n  } else if (pkt->tcp->flags & TH_SYN) {\n    // Use peer's source port as ISN, in order to recognise the handshake\n    uint32_t isn = mg_htonl((uint32_t) mg_ntohs(pkt->tcp->sport));\n    tx_tcp_pkt(ifp, pkt, TH_SYN | TH_ACK, isn, NULL, 0);\n  } else if (pkt->tcp->flags & TH_FIN) {\n    tx_tcp_pkt(ifp, pkt, TH_FIN | TH_ACK, pkt->tcp->ack, NULL, 0);\n  } else if (mg_htonl(pkt->tcp->ack) == mg_htons(pkt->tcp->sport) + 1U) {\n    accept_conn(c, pkt);\n  } else if (!c->is_accepted) {  // no peer\n    tx_tcp_pkt(ifp, pkt, TH_RST | TH_ACK, pkt->tcp->ack, NULL, 0);\n  } else {\n    // MG_VERBOSE((\"dropped silently..\"));\n  }\n}\n\nstatic void rx_ip(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  uint16_t frag = mg_ntohs(pkt->ip->frag);\n  if (frag & IP_MORE_FRAGS_MSK || frag & IP_FRAG_OFFSET_MSK) {\n    if (pkt->ip->proto == 17) pkt->udp = (struct udp *) (pkt->ip + 1);\n    if (pkt->ip->proto == 6) pkt->tcp = (struct tcp *) (pkt->ip + 1);\n    struct mg_connection *c = getpeer(ifp->mgr, pkt, false);\n    if (c) mg_error(c, \"Received fragmented packet\");\n  } else if (pkt->ip->proto == 1) {\n    pkt->icmp = (struct icmp *) (pkt->ip + 1);\n    if (pkt->pay.len < sizeof(*pkt->icmp)) return;\n    mkpay(pkt, pkt->icmp + 1);\n    rx_icmp(ifp, pkt);\n  } else if (pkt->ip->proto == 17) {\n    pkt->udp = (struct udp *) (pkt->ip + 1);\n    if (pkt->pay.len < sizeof(*pkt->udp)) return;\n    mkpay(pkt, pkt->udp + 1);\n    MG_VERBOSE((\"UDP %M:%hu -> %M:%hu len %u\", mg_print_ip4, &pkt->ip->src,\n                mg_ntohs(pkt->udp->sport), mg_print_ip4, &pkt->ip->dst,\n                mg_ntohs(pkt->udp->dport), (int) pkt->pay.len));\n    if (ifp->enable_dhcp_client && pkt->udp->dport == mg_htons(68)) {\n      pkt->dhcp = (struct dhcp *) (pkt->udp + 1);\n      mkpay(pkt, pkt->dhcp + 1);\n      rx_dhcp_client(ifp, pkt);\n    } else if (ifp->enable_dhcp_server && pkt->udp->dport == mg_htons(67)) {\n      pkt->dhcp = (struct dhcp *) (pkt->udp + 1);\n      mkpay(pkt, pkt->dhcp + 1);\n      rx_dhcp_server(ifp, pkt);\n    } else {\n      rx_udp(ifp, pkt);\n    }\n  } else if (pkt->ip->proto == 6) {\n    pkt->tcp = (struct tcp *) (pkt->ip + 1);\n    if (pkt->pay.len < sizeof(*pkt->tcp)) return;\n    mkpay(pkt, pkt->tcp + 1);\n    uint16_t iplen = mg_ntohs(pkt->ip->len);\n    uint16_t off = (uint16_t) (sizeof(*pkt->ip) + ((pkt->tcp->off >> 4) * 4U));\n    if (iplen >= off) pkt->pay.len = (size_t) (iplen - off);\n    MG_VERBOSE((\"TCP %M:%hu -> %M:%hu len %u\", mg_print_ip4, &pkt->ip->src,\n                mg_ntohs(pkt->tcp->sport), mg_print_ip4, &pkt->ip->dst,\n                mg_ntohs(pkt->tcp->dport), (int) pkt->pay.len));\n    rx_tcp(ifp, pkt);\n  }\n}\n\nstatic void rx_ip6(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  // MG_DEBUG((\"IP %d\", (int) len));\n  if (pkt->ip6->proto == 1 || pkt->ip6->proto == 58) {\n    pkt->icmp = (struct icmp *) (pkt->ip6 + 1);\n    if (pkt->pay.len < sizeof(*pkt->icmp)) return;\n    mkpay(pkt, pkt->icmp + 1);\n    rx_icmp(ifp, pkt);\n  } else if (pkt->ip6->proto == 17) {\n    pkt->udp = (struct udp *) (pkt->ip6 + 1);\n    if (pkt->pay.len < sizeof(*pkt->udp)) return;\n    // MG_DEBUG((\"  UDP %u %u -> %u\", len, mg_htons(udp->sport),\n    // mg_htons(udp->dport)));\n    mkpay(pkt, pkt->udp + 1);\n  }\n}\n\nstatic void mg_tcpip_rx(struct mg_tcpip_if *ifp, void *buf, size_t len) {\n  struct pkt pkt;\n  memset(&pkt, 0, sizeof(pkt));\n  pkt.raw.buf = (char *) buf;\n  pkt.raw.len = len;\n  pkt.eth = (struct eth *) buf;\n  // mg_hexdump(buf, len > 16 ? 16: len);\n  if (pkt.raw.len < sizeof(*pkt.eth)) return;  // Truncated - runt?\n  if (ifp->enable_mac_check &&\n      memcmp(pkt.eth->dst, ifp->mac, sizeof(pkt.eth->dst)) != 0 &&\n      memcmp(pkt.eth->dst, broadcast, sizeof(pkt.eth->dst)) != 0)\n    return;\n  if (ifp->enable_crc32_check && len > 4) {\n    len -= 4;  // TODO(scaprile): check on bigendian\n    uint32_t crc = mg_crc32(0, (const char *) buf, len);\n    if (memcmp((void *) ((size_t) buf + len), &crc, sizeof(crc))) return;\n  }\n  if (pkt.eth->type == mg_htons(0x806)) {\n    pkt.arp = (struct arp *) (pkt.eth + 1);\n    if (sizeof(*pkt.eth) + sizeof(*pkt.arp) > pkt.raw.len) return;  // Truncated\n    mg_tcpip_call(ifp, MG_TCPIP_EV_ARP, &pkt.raw);\n    rx_arp(ifp, &pkt);\n  } else if (pkt.eth->type == mg_htons(0x86dd)) {\n    pkt.ip6 = (struct ip6 *) (pkt.eth + 1);\n    if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip6)) return;  // Truncated\n    if ((pkt.ip6->ver >> 4) != 0x6) return;                         // Not IP\n    mkpay(&pkt, pkt.ip6 + 1);\n    rx_ip6(ifp, &pkt);\n  } else if (pkt.eth->type == mg_htons(0x800)) {\n    pkt.ip = (struct ip *) (pkt.eth + 1);\n    if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip)) return;  // Truncated\n    // Truncate frame to what IP header tells us\n    if ((size_t) mg_ntohs(pkt.ip->len) + sizeof(struct eth) < pkt.raw.len) {\n      pkt.raw.len = (size_t) mg_ntohs(pkt.ip->len) + sizeof(struct eth);\n    }\n    if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip)) return;  // Truncated\n    if ((pkt.ip->ver >> 4) != 4) return;                           // Not IP\n    mkpay(&pkt, pkt.ip + 1);\n    rx_ip(ifp, &pkt);\n  } else {\n    MG_DEBUG((\"Unknown eth type %x\", mg_htons(pkt.eth->type)));\n    if (mg_log_level >= MG_LL_VERBOSE) mg_hexdump(buf, len >= 32 ? 32 : len);\n  }\n}\n\nstatic void mg_tcpip_poll(struct mg_tcpip_if *ifp, uint64_t now) {\n  struct mg_connection *c;\n  bool expired_1000ms = mg_timer_expired(&ifp->timer_1000ms, 1000, now);\n  ifp->now = now;\n\n  if (expired_1000ms) {\n#if MG_ENABLE_TCPIP_PRINT_DEBUG_STATS\n    const char *names[] = {\"down\", \"up\", \"req\", \"ip\", \"ready\"};\n    MG_INFO((\"Status: %s, IP: %M, rx:%u, tx:%u, dr:%u, er:%u\",\n             names[ifp->state], mg_print_ip4, &ifp->ip, ifp->nrecv, ifp->nsent,\n             ifp->ndrop, ifp->nerr));\n#endif\n  }\n  // Handle gw ARP request timeout, order is important\n  if (expired_1000ms && ifp->state == MG_TCPIP_STATE_IP) {\n    ifp->state = MG_TCPIP_STATE_READY;  // keep best-effort MAC\n    onstatechange(ifp);\n  }\n  // Handle physical interface up/down status\n  if (expired_1000ms && ifp->driver->up) {\n    bool up = ifp->driver->up(ifp);\n    bool current = ifp->state != MG_TCPIP_STATE_DOWN;\n    if (!up && ifp->enable_dhcp_client) ifp->ip = 0;\n    if (up != current) {  // link state has changed\n      ifp->state = up == false ? MG_TCPIP_STATE_DOWN\n                   : ifp->enable_dhcp_client || ifp->ip == 0\n                       ? MG_TCPIP_STATE_UP\n                       : MG_TCPIP_STATE_IP;\n      onstatechange(ifp);\n    } else if (!ifp->enable_dhcp_client && ifp->state == MG_TCPIP_STATE_UP &&\n               ifp->ip) {\n      ifp->state = MG_TCPIP_STATE_IP;  // ifp->fn has set an IP\n      onstatechange(ifp);\n    }\n    if (ifp->state == MG_TCPIP_STATE_DOWN) MG_ERROR((\"Network is down\"));\n    mg_tcpip_call(ifp, MG_TCPIP_EV_TIMER_1S, NULL);\n  }\n  if (ifp->state == MG_TCPIP_STATE_DOWN) return;\n\n  // DHCP RFC-2131 (4.4)\n  if (ifp->enable_dhcp_client && expired_1000ms) {\n    if (ifp->state == MG_TCPIP_STATE_UP) {\n      tx_dhcp_discover(ifp);  // INIT (4.4.1)\n    } else if (ifp->state == MG_TCPIP_STATE_READY &&\n               ifp->lease_expire > 0) {  // BOUND / RENEWING / REBINDING\n      if (ifp->now >= ifp->lease_expire) {\n        ifp->state = MG_TCPIP_STATE_UP, ifp->ip = 0;  // expired, release IP\n        onstatechange(ifp);\n      } else if (ifp->now + 30UL * 60UL * 1000UL > ifp->lease_expire &&\n                 ((ifp->now / 1000) % 60) == 0) {\n        // hack: 30 min before deadline, try to rebind (4.3.6) every min\n        tx_dhcp_request_re(ifp, (uint8_t *) broadcast, ifp->ip, 0xffffffff);\n      }  // TODO(): Handle T1 (RENEWING) and T2 (REBINDING) (4.4.5)\n    }\n  }\n\n  // Read data from the network\n  if (ifp->driver->rx != NULL) {  // Polling driver. We must call it\n    size_t len =\n        ifp->driver->rx(ifp->recv_queue.buf, ifp->recv_queue.size, ifp);\n    if (len > 0) {\n      ifp->nrecv++;\n      mg_tcpip_rx(ifp, ifp->recv_queue.buf, len);\n    }\n  } else {  // Interrupt-based driver. Fills recv queue itself\n    char *buf;\n    size_t len = mg_queue_next(&ifp->recv_queue, &buf);\n    if (len > 0) {\n      mg_tcpip_rx(ifp, buf, len);\n      mg_queue_del(&ifp->recv_queue, len);\n    }\n  }\n\n  // Process timeouts\n  for (c = ifp->mgr->conns; c != NULL; c = c->next) {\n    if ((c->is_udp && !c->is_arplooking) || c->is_listening || c->is_resolving)\n      continue;\n    struct connstate *s = (struct connstate *) (c + 1);\n    uint32_t rem_ip;\n    memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));\n    if (now > s->timer) {\n      if (s->ttype == MIP_TTYPE_ARP) {\n        mg_error(c, \"ARP timeout\");\n      } else if (c->is_udp) {\n        continue;\n      } else if (s->ttype == MIP_TTYPE_ACK && s->acked != s->ack) {\n        MG_VERBOSE((\"%lu ack %x %x\", c->id, s->seq, s->ack));\n        tx_tcp(ifp, s->mac, rem_ip, TH_ACK, c->loc.port, c->rem.port,\n               mg_htonl(s->seq), mg_htonl(s->ack), NULL, 0);\n        s->acked = s->ack;\n      } else if (s->ttype == MIP_TTYPE_SYN) {\n        mg_error(c, \"Connection timeout\");\n      } else if (s->ttype == MIP_TTYPE_FIN) {\n        c->is_closing = 1;\n        continue;\n      } else {\n        if (s->tmiss++ > 2) {\n          mg_error(c, \"keepalive\");\n        } else {\n          MG_VERBOSE((\"%lu keepalive\", c->id));\n          tx_tcp(ifp, s->mac, rem_ip, TH_ACK, c->loc.port, c->rem.port,\n                 mg_htonl(s->seq - 1), mg_htonl(s->ack), NULL, 0);\n        }\n      }\n\n      settmout(c, MIP_TTYPE_KEEPALIVE);\n    }\n  }\n}\n\n// This function executes in interrupt context, thus it should copy data\n// somewhere fast. Note that newlib's malloc is not thread safe, thus use\n// our lock-free queue with preallocated buffer to copy data and return asap\nvoid mg_tcpip_qwrite(void *buf, size_t len, struct mg_tcpip_if *ifp) {\n  char *p;\n  if (mg_queue_book(&ifp->recv_queue, &p, len) >= len) {\n    memcpy(p, buf, len);\n    mg_queue_add(&ifp->recv_queue, len);\n    ifp->nrecv++;\n  } else {\n    ifp->ndrop++;\n  }\n}\n\nvoid mg_tcpip_init(struct mg_mgr *mgr, struct mg_tcpip_if *ifp) {\n  // If MAC address is not set, make a random one\n  if (ifp->mac[0] == 0 && ifp->mac[1] == 0 && ifp->mac[2] == 0 &&\n      ifp->mac[3] == 0 && ifp->mac[4] == 0 && ifp->mac[5] == 0) {\n    ifp->mac[0] = 0x02;  // Locally administered, unicast\n    mg_random(&ifp->mac[1], sizeof(ifp->mac) - 1);\n    MG_INFO((\"MAC not set. Generated random: %M\", mg_print_mac, ifp->mac));\n  }\n\n  if (ifp->driver->init && !ifp->driver->init(ifp)) {\n    MG_ERROR((\"driver init failed\"));\n  } else {\n    size_t framesize = 1540;\n    ifp->tx.buf = (char *) calloc(1, framesize), ifp->tx.len = framesize;\n    if (ifp->recv_queue.size == 0)\n      ifp->recv_queue.size = ifp->driver->rx ? framesize : 8192;\n    ifp->recv_queue.buf = (char *) calloc(1, ifp->recv_queue.size);\n    ifp->timer_1000ms = mg_millis();\n    mgr->ifp = ifp;\n    ifp->mgr = mgr;\n    ifp->mtu = MG_TCPIP_MTU_DEFAULT;\n    mgr->extraconnsize = sizeof(struct connstate);\n    if (ifp->ip == 0) ifp->enable_dhcp_client = true;\n    memset(ifp->gwmac, 255, sizeof(ifp->gwmac));  // Set best-effort to bcast\n    mg_random(&ifp->eport, sizeof(ifp->eport));   // Random from 0 to 65535\n    ifp->eport |= MG_EPHEMERAL_PORT_BASE;         // Random from\n                                           // MG_EPHEMERAL_PORT_BASE to 65535\n    if (ifp->tx.buf == NULL || ifp->recv_queue.buf == NULL) MG_ERROR((\"OOM\"));\n  }\n}\n\nvoid mg_tcpip_free(struct mg_tcpip_if *ifp) {\n  free(ifp->recv_queue.buf);\n  free(ifp->tx.buf);\n}\n\nstatic void send_syn(struct mg_connection *c) {\n  struct connstate *s = (struct connstate *) (c + 1);\n  uint32_t isn = mg_htonl((uint32_t) mg_ntohs(c->loc.port));\n  uint32_t rem_ip;\n  memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));\n  tx_tcp(c->mgr->ifp, s->mac, rem_ip, TH_SYN, c->loc.port, c->rem.port, isn, 0,\n         NULL, 0);\n}\n\nstatic void mac_resolved(struct mg_connection *c) {\n  if (c->is_udp) {\n    c->is_connecting = 0;\n    mg_call(c, MG_EV_CONNECT, NULL);\n  } else {\n    send_syn(c);\n    settmout(c, MIP_TTYPE_SYN);\n  }\n}\n\nvoid mg_connect_resolved(struct mg_connection *c) {\n  struct mg_tcpip_if *ifp = c->mgr->ifp;\n  uint32_t rem_ip;\n  memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));\n  c->is_resolving = 0;\n  if (ifp->eport < MG_EPHEMERAL_PORT_BASE) ifp->eport = MG_EPHEMERAL_PORT_BASE;\n  memcpy(c->loc.ip, &ifp->ip, sizeof(uint32_t));\n  c->loc.port = mg_htons(ifp->eport++);\n  MG_DEBUG((\"%lu %M -> %M\", c->id, mg_print_ip_port, &c->loc, mg_print_ip_port,\n            &c->rem));\n  mg_call(c, MG_EV_RESOLVE, NULL);\n  c->is_connecting = 1;\n  if (c->is_udp && (rem_ip == 0xffffffff || rem_ip == (ifp->ip | ~ifp->mask))) {\n    struct connstate *s = (struct connstate *) (c + 1);\n    memset(s->mac, 0xFF, sizeof(s->mac));  // global or local broadcast\n    mac_resolved(c);\n  } else if (ifp->ip && ((rem_ip & ifp->mask) == (ifp->ip & ifp->mask)) &&\n             rem_ip != ifp->gw) {  // skip if gw (onstatechange -> READY -> ARP)\n    // If we're in the same LAN, fire an ARP lookup.\n    MG_DEBUG((\"%lu ARP lookup...\", c->id));\n    mg_tcpip_arp_request(ifp, rem_ip, NULL);\n    settmout(c, MIP_TTYPE_ARP);\n    c->is_arplooking = 1;\n  } else if ((*((uint8_t *) &rem_ip) & 0xE0) == 0xE0) {\n    struct connstate *s = (struct connstate *) (c + 1);  // 224 to 239, E0 to EF\n    uint8_t mcastp[3] = {0x01, 0x00, 0x5E};              // multicast group\n    memcpy(s->mac, mcastp, 3);\n    memcpy(s->mac + 3, ((uint8_t *) &rem_ip) + 1, 3);  // 23 LSb\n    s->mac[3] &= 0x7F;\n    mac_resolved(c);\n  } else {\n    struct connstate *s = (struct connstate *) (c + 1);\n    memcpy(s->mac, ifp->gwmac, sizeof(ifp->gwmac));\n    mac_resolved(c);\n  }\n}\n\nbool mg_open_listener(struct mg_connection *c, const char *url) {\n  c->loc.port = mg_htons(mg_url_port(url));\n  return true;\n}\n\nstatic void write_conn(struct mg_connection *c) {\n  long len = c->is_tls ? mg_tls_send(c, c->send.buf, c->send.len)\n                       : mg_io_send(c, c->send.buf, c->send.len);\n  if (len == MG_IO_ERR) {\n    mg_error(c, \"tx err\");\n  } else if (len > 0) {\n    mg_iobuf_del(&c->send, 0, (size_t) len);\n    mg_call(c, MG_EV_WRITE, &len);\n  }\n}\n\nstatic void init_closure(struct mg_connection *c) {\n  struct connstate *s = (struct connstate *) (c + 1);\n  if (c->is_udp == false && c->is_listening == false &&\n      c->is_connecting == false) {  // For TCP conns,\n    uint32_t rem_ip;\n    memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));\n    tx_tcp(c->mgr->ifp, s->mac, rem_ip, TH_FIN | TH_ACK, c->loc.port,\n           c->rem.port, mg_htonl(s->seq), mg_htonl(s->ack), NULL, 0);\n    settmout(c, MIP_TTYPE_FIN);\n  }\n}\n\nstatic void close_conn(struct mg_connection *c) {\n  struct connstate *s = (struct connstate *) (c + 1);\n  mg_iobuf_free(&s->raw);  // For TLS connections, release raw data\n  mg_close_conn(c);\n}\n\nstatic bool can_write(struct mg_connection *c) {\n  return c->is_connecting == 0 && c->is_resolving == 0 && c->send.len > 0 &&\n         c->is_tls_hs == 0 && c->is_arplooking == 0;\n}\n\nvoid mg_mgr_poll(struct mg_mgr *mgr, int ms) {\n  struct mg_connection *c, *tmp;\n  uint64_t now = mg_millis();\n  mg_timer_poll(&mgr->timers, now);\n  if (mgr->ifp == NULL || mgr->ifp->driver == NULL) return;\n  mg_tcpip_poll(mgr->ifp, now);\n  for (c = mgr->conns; c != NULL; c = tmp) {\n    tmp = c->next;\n    struct connstate *s = (struct connstate *) (c + 1);\n    mg_call(c, MG_EV_POLL, &now);\n    MG_VERBOSE((\"%lu .. %c%c%c%c%c\", c->id, c->is_tls ? 'T' : 't',\n                c->is_connecting ? 'C' : 'c', c->is_tls_hs ? 'H' : 'h',\n                c->is_resolving ? 'R' : 'r', c->is_closing ? 'C' : 'c'));\n    if (c->is_tls && mg_tls_pending(c) > 0) handle_tls_recv(c);\n    if (can_write(c)) write_conn(c);\n    if (c->is_draining && c->send.len == 0 && s->ttype != MIP_TTYPE_FIN)\n      init_closure(c);\n    if (c->is_closing) close_conn(c);\n  }\n  (void) ms;\n}\n\nbool mg_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tcpip_if *ifp = c->mgr->ifp;\n  bool res = false;\n  uint32_t rem_ip;\n  memcpy(&rem_ip, c->rem.ip, sizeof(uint32_t));\n  if (ifp->ip == 0 || ifp->state != MG_TCPIP_STATE_READY) {\n    mg_error(c, \"net down\");\n  } else if (c->is_udp && (c->is_arplooking || c->is_resolving)) {\n    // Fail to send, no target MAC or IP\n    MG_VERBOSE((\"still resolving...\"));\n  } else if (c->is_udp) {\n    struct connstate *s = (struct connstate *) (c + 1);\n    len = trim_len(c, len);  // Trimming length if necessary\n    tx_udp(ifp, s->mac, ifp->ip, c->loc.port, rem_ip, c->rem.port, buf, len);\n    res = true;\n  } else {\n    res = mg_iobuf_add(&c->send, c->send.len, buf, len);\n  }\n  return res;\n}\n#endif  // MG_ENABLE_TCPIP\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ota_ch32v307.c\"\n#endif\n\n\n\n\n#if MG_OTA == MG_OTA_CH32V307\n// RM: https://www.wch-ic.com/downloads/CH32FV2x_V3xRM_PDF.html\n\nstatic bool mg_ch32v307_write(void *, const void *, size_t);\nstatic bool mg_ch32v307_swap(void);\n\nstatic struct mg_flash s_mg_flash_ch32v307 = {\n    (void *) 0x08000000,  // Start\n    480 * 1024,           // Size, first 320k is 0-wait\n    4 * 1024,             // Sector size, 4k\n    4,                    // Align, 32 bit\n    mg_ch32v307_write,\n    mg_ch32v307_swap,\n};\n\n#define FLASH_BASE 0x40022000\n#define FLASH_ACTLR (FLASH_BASE + 0)\n#define FLASH_KEYR (FLASH_BASE + 4)\n#define FLASH_OBKEYR (FLASH_BASE + 8)\n#define FLASH_STATR (FLASH_BASE + 12)\n#define FLASH_CTLR (FLASH_BASE + 16)\n#define FLASH_ADDR (FLASH_BASE + 20)\n#define FLASH_OBR (FLASH_BASE + 28)\n#define FLASH_WPR (FLASH_BASE + 32)\n\nMG_IRAM static void flash_unlock(void) {\n  static bool unlocked;\n  if (unlocked == false) {\n    MG_REG(FLASH_KEYR) = 0x45670123;\n    MG_REG(FLASH_KEYR) = 0xcdef89ab;\n    unlocked = true;\n  }\n}\n\nMG_IRAM static void flash_wait(void) {\n  while (MG_REG(FLASH_STATR) & MG_BIT(0)) (void) 0;\n}\n\nMG_IRAM static void mg_ch32v307_erase(void *addr) {\n  // MG_INFO((\"%p\", addr));\n  flash_unlock();\n  flash_wait();\n  MG_REG(FLASH_ADDR) = (uint32_t) addr;\n  MG_REG(FLASH_CTLR) |= MG_BIT(1) | MG_BIT(6);  // PER | STRT;\n  flash_wait();\n}\n\nMG_IRAM static bool is_page_boundary(const void *addr) {\n  uint32_t val = (uint32_t) addr;\n  return (val & (s_mg_flash_ch32v307.secsz - 1)) == 0;\n}\n\nMG_IRAM static bool mg_ch32v307_write(void *addr, const void *buf, size_t len) {\n  // MG_INFO((\"%p %p %lu\", addr, buf, len));\n  // mg_hexdump(buf, len);\n  flash_unlock();\n  const uint16_t *src = (uint16_t *) buf, *end = &src[len / 2];\n  uint16_t *dst = (uint16_t *) addr;\n  MG_REG(FLASH_CTLR) |= MG_BIT(0);  // Set PG\n  // MG_INFO((\"CTLR: %#lx\", MG_REG(FLASH_CTLR)));\n  while (src < end) {\n    if (is_page_boundary(dst)) mg_ch32v307_erase(dst);\n    *dst++ = *src++;\n    flash_wait();\n  }\n  MG_REG(FLASH_CTLR) &= ~MG_BIT(0);  // Clear PG\n  return true;\n}\n\nMG_IRAM bool mg_ch32v307_swap(void) {\n  return true;\n}\n\n// just overwrite instead of swap\nMG_IRAM static void single_bank_swap(char *p1, char *p2, size_t s, size_t ss) {\n  // no stdlib calls here\n  for (size_t ofs = 0; ofs < s; ofs += ss) {\n    mg_ch32v307_write(p1 + ofs, p2 + ofs, ss);\n  }\n  *((volatile uint32_t *) 0xbeef0000) |= 1U << 7;  // NVIC_SystemReset()\n}\n\nbool mg_ota_begin(size_t new_firmware_size) {\n  return mg_ota_flash_begin(new_firmware_size, &s_mg_flash_ch32v307);\n}\n\nbool mg_ota_write(const void *buf, size_t len) {\n  return mg_ota_flash_write(buf, len, &s_mg_flash_ch32v307);\n}\n\nbool mg_ota_end(void) {\n  if (mg_ota_flash_end(&s_mg_flash_ch32v307)) {\n    // Swap partitions. Pray power does not go away\n    MG_INFO((\"Swapping partitions, size %u (%u sectors)\",\n             s_mg_flash_ch32v307.size,\n             s_mg_flash_ch32v307.size / s_mg_flash_ch32v307.secsz));\n    MG_INFO((\"Do NOT power off...\"));\n    mg_log_level = MG_LL_NONE;\n    // TODO() disable IRQ, s_flash_irq_disabled = true;\n    // Runs in RAM, will reset when finished\n    single_bank_swap(\n        (char *) s_mg_flash_ch32v307.start,\n        (char *) s_mg_flash_ch32v307.start + s_mg_flash_ch32v307.size / 2,\n        s_mg_flash_ch32v307.size / 2, s_mg_flash_ch32v307.secsz);\n  }\n  return false;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ota_dummy.c\"\n#endif\n\n\n\n#if MG_OTA == MG_OTA_NONE\nbool mg_ota_begin(size_t new_firmware_size) {\n  (void) new_firmware_size;\n  return true;\n}\nbool mg_ota_write(const void *buf, size_t len) {\n  (void) buf, (void) len;\n  return true;\n}\nbool mg_ota_end(void) {\n  return true;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ota_esp32.c\"\n#endif\n\n\n#if MG_ARCH == MG_ARCH_ESP32 && MG_OTA == MG_OTA_ESP32\n\nstatic const esp_partition_t *s_ota_update_partition;\nstatic esp_ota_handle_t s_ota_update_handle;\nstatic bool s_ota_success;\n\n// Those empty macros do nothing, but mark places in the code which could\n// potentially trigger a watchdog reboot due to the log flash erase operation\n#define disable_wdt()\n#define enable_wdt()\n\nbool mg_ota_begin(size_t new_firmware_size) {\n  if (s_ota_update_partition != NULL) {\n    MG_ERROR((\"Update in progress. Call mg_ota_end() ?\"));\n    return false;\n  } else {\n    s_ota_success = false;\n    disable_wdt();\n    s_ota_update_partition = esp_ota_get_next_update_partition(NULL);\n    esp_err_t err = esp_ota_begin(s_ota_update_partition, new_firmware_size,\n                                  &s_ota_update_handle);\n    enable_wdt();\n    MG_DEBUG((\"esp_ota_begin(): %d\", err));\n    s_ota_success = (err == ESP_OK);\n  }\n  return s_ota_success;\n}\n\nbool mg_ota_write(const void *buf, size_t len) {\n  disable_wdt();\n  esp_err_t err = esp_ota_write(s_ota_update_handle, buf, len);\n  enable_wdt();\n  MG_INFO((\"esp_ota_write(): %d\", err));\n  s_ota_success = err == ESP_OK;\n  return s_ota_success;\n}\n\nbool mg_ota_end(void) {\n  esp_err_t err = esp_ota_end(s_ota_update_handle);\n  MG_DEBUG((\"esp_ota_end(%p): %d\", s_ota_update_handle, err));\n  if (s_ota_success && err == ESP_OK) {\n    err = esp_ota_set_boot_partition(s_ota_update_partition);\n    s_ota_success = (err == ESP_OK);\n  }\n  MG_DEBUG((\"Finished ESP32 OTA, success: %d\", s_ota_success));\n  s_ota_update_partition = NULL;\n  return s_ota_success;\n}\n\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ota_imxrt.c\"\n#endif\n\n\n\n\n#if MG_OTA >= MG_OTA_RT1020 && MG_OTA <= MG_OTA_RT1170\n\nstatic bool mg_imxrt_write(void *, const void *, size_t);\nstatic bool mg_imxrt_swap(void);\n\n#if MG_OTA <= MG_OTA_RT1060\n#define MG_IMXRT_FLASH_START 0x60000000\n#define FLEXSPI_NOR_INSTANCE 0\n#elif MG_OTA == MG_OTA_RT1064\n#define MG_IMXRT_FLASH_START 0x70000000\n#define FLEXSPI_NOR_INSTANCE 1\n#else // RT1170\n#define MG_IMXRT_FLASH_START 0x30000000\n#define FLEXSPI_NOR_INSTANCE 1\n#endif\n\n// TODO(): fill at init, support more devices in a dynamic way\n// TODO(): then, check alignment is <= 256, see Wizard's #251\nstatic struct mg_flash s_mg_flash_imxrt = {\n    (void *) MG_IMXRT_FLASH_START,  // Start,\n    4 * 1024 * 1024,                // Size, 4mb\n    4 * 1024,                       // Sector size, 4k\n    256,                            // Align,\n    mg_imxrt_write,\n    mg_imxrt_swap,\n};\n\nstruct mg_flexspi_lut_seq {\n  uint8_t seqNum;\n  uint8_t seqId;\n  uint16_t reserved;\n};\n\nstruct mg_flexspi_mem_config {\n  uint32_t tag;\n  uint32_t version;\n  uint32_t reserved0;\n  uint8_t readSampleClkSrc;\n  uint8_t csHoldTime;\n  uint8_t csSetupTime;\n  uint8_t columnAddressWidth;\n  uint8_t deviceModeCfgEnable;\n  uint8_t deviceModeType;\n  uint16_t waitTimeCfgCommands;\n  struct mg_flexspi_lut_seq deviceModeSeq;\n  uint32_t deviceModeArg;\n  uint8_t configCmdEnable;\n  uint8_t configModeType[3];\n  struct mg_flexspi_lut_seq configCmdSeqs[3];\n  uint32_t reserved1;\n  uint32_t configCmdArgs[3];\n  uint32_t reserved2;\n  uint32_t controllerMiscOption;\n  uint8_t deviceType;\n  uint8_t sflashPadType;\n  uint8_t serialClkFreq;\n  uint8_t lutCustomSeqEnable;\n  uint32_t reserved3[2];\n  uint32_t sflashA1Size;\n  uint32_t sflashA2Size;\n  uint32_t sflashB1Size;\n  uint32_t sflashB2Size;\n  uint32_t csPadSettingOverride;\n  uint32_t sclkPadSettingOverride;\n  uint32_t dataPadSettingOverride;\n  uint32_t dqsPadSettingOverride;\n  uint32_t timeoutInMs;\n  uint32_t commandInterval;\n  uint16_t dataValidTime[2];\n  uint16_t busyOffset;\n  uint16_t busyBitPolarity;\n  uint32_t lookupTable[64];\n  struct mg_flexspi_lut_seq lutCustomSeq[12];\n  uint32_t reserved4[4];\n};\n\nstruct mg_flexspi_nor_config {\n  struct mg_flexspi_mem_config memConfig;\n  uint32_t pageSize;\n  uint32_t sectorSize;\n  uint8_t ipcmdSerialClkFreq;\n  uint8_t isUniformBlockSize;\n  uint8_t reserved0[2];\n  uint8_t serialNorType;\n  uint8_t needExitNoCmdMode;\n  uint8_t halfClkForNonReadCmd;\n  uint8_t needRestoreNoCmdMode;\n  uint32_t blockSize;\n  uint32_t reserve2[11];\n};\n\n/* FLEXSPI memory config block related defintions */\n#define MG_FLEXSPI_CFG_BLK_TAG (0x42464346UL)      // ascii \"FCFB\" Big Endian\n#define MG_FLEXSPI_CFG_BLK_VERSION (0x56010400UL)  // V1.4.0\n\n#define MG_FLEXSPI_LUT_SEQ(cmd0, pad0, op0, cmd1, pad1, op1)       \\\n  (MG_FLEXSPI_LUT_OPERAND0(op0) | MG_FLEXSPI_LUT_NUM_PADS0(pad0) | \\\n   MG_FLEXSPI_LUT_OPCODE0(cmd0) | MG_FLEXSPI_LUT_OPERAND1(op1) |   \\\n   MG_FLEXSPI_LUT_NUM_PADS1(pad1) | MG_FLEXSPI_LUT_OPCODE1(cmd1))\n\n#define MG_CMD_SDR 0x01\n#define MG_CMD_DDR 0x21\n#define MG_DUMMY_SDR 0x0C\n#define MG_DUMMY_DDR 0x2C\n#define MG_RADDR_SDR 0x02\n#define MG_RADDR_DDR 0x22\n#define MG_READ_SDR 0x09\n#define MG_READ_DDR 0x29\n#define MG_WRITE_SDR 0x08\n#define MG_WRITE_DDR 0x28\n#define MG_STOP 0\n\n#define MG_FLEXSPI_1PAD 0\n#define MG_FLEXSPI_2PAD 1\n#define MG_FLEXSPI_4PAD 2\n#define MG_FLEXSPI_8PAD 3\n\n#define MG_FLEXSPI_QSPI_LUT                                                    \\\n  {                                                                            \\\n    [0] = MG_FLEXSPI_LUT_SEQ(MG_CMD_SDR, MG_FLEXSPI_1PAD, 0xEB, MG_RADDR_SDR,  \\\n                             MG_FLEXSPI_4PAD, 0x18),                           \\\n    [1] = MG_FLEXSPI_LUT_SEQ(MG_DUMMY_SDR, MG_FLEXSPI_4PAD, 0x06, MG_READ_SDR, \\\n                             MG_FLEXSPI_4PAD, 0x04),                           \\\n    [4 * 1 + 0] = MG_FLEXSPI_LUT_SEQ(MG_CMD_SDR, MG_FLEXSPI_1PAD, 0x05,        \\\n                                     MG_READ_SDR, MG_FLEXSPI_1PAD, 0x04),      \\\n    [4 * 3 + 0] = MG_FLEXSPI_LUT_SEQ(MG_CMD_SDR, MG_FLEXSPI_1PAD, 0x06,        \\\n                                     MG_STOP, MG_FLEXSPI_1PAD, 0x0),           \\\n    [4 * 5 + 0] = MG_FLEXSPI_LUT_SEQ(MG_CMD_SDR, MG_FLEXSPI_1PAD, 0x20,        \\\n                                     MG_RADDR_SDR, MG_FLEXSPI_1PAD, 0x18),     \\\n    [4 * 8 + 0] = MG_FLEXSPI_LUT_SEQ(MG_CMD_SDR, MG_FLEXSPI_1PAD, 0xD8,        \\\n                                     MG_RADDR_SDR, MG_FLEXSPI_1PAD, 0x18),     \\\n    [4 * 9 + 0] = MG_FLEXSPI_LUT_SEQ(MG_CMD_SDR, MG_FLEXSPI_1PAD, 0x02,        \\\n                                     MG_RADDR_SDR, MG_FLEXSPI_1PAD, 0x18),     \\\n    [4 * 9 + 1] = MG_FLEXSPI_LUT_SEQ(MG_WRITE_SDR, MG_FLEXSPI_1PAD, 0x04,      \\\n                                     MG_STOP, MG_FLEXSPI_1PAD, 0x0),           \\\n    [4 * 11 + 0] = MG_FLEXSPI_LUT_SEQ(MG_CMD_SDR, MG_FLEXSPI_1PAD, 0x60,       \\\n                                      MG_STOP, MG_FLEXSPI_1PAD, 0x0),          \\\n  }\n\n#define MG_FLEXSPI_LUT_OPERAND0(x) (((uint32_t) (((uint32_t) (x)))) & 0xFFU)\n#define MG_FLEXSPI_LUT_NUM_PADS0(x) \\\n  (((uint32_t) (((uint32_t) (x)) << 8U)) & 0x300U)\n#define MG_FLEXSPI_LUT_OPCODE0(x) \\\n  (((uint32_t) (((uint32_t) (x)) << 10U)) & 0xFC00U)\n#define MG_FLEXSPI_LUT_OPERAND1(x) \\\n  (((uint32_t) (((uint32_t) (x)) << 16U)) & 0xFF0000U)\n#define MG_FLEXSPI_LUT_NUM_PADS1(x) \\\n  (((uint32_t) (((uint32_t) (x)) << 24U)) & 0x3000000U)\n#define MG_FLEXSPI_LUT_OPCODE1(x) \\\n  (((uint32_t) (((uint32_t) (x)) << 26U)) & 0xFC000000U)\n\n#if MG_OTA == MG_OTA_RT1020\n// RT102X boards support ROM API version 1.4\nstruct mg_flexspi_nor_driver_interface {\n  uint32_t version;\n  int (*init)(uint32_t instance, struct mg_flexspi_nor_config *config);\n  int (*program)(uint32_t instance, struct mg_flexspi_nor_config *config,\n                 uint32_t dst_addr, const uint32_t *src);\n  uint32_t reserved;\n  int (*erase)(uint32_t instance, struct mg_flexspi_nor_config *config,\n               uint32_t start, uint32_t lengthInBytes);\n  uint32_t reserved2;\n  int (*update_lut)(uint32_t instance, uint32_t seqIndex,\n                    const uint32_t *lutBase, uint32_t seqNumber);\n  int (*xfer)(uint32_t instance, char *xfer);\n  void (*clear_cache)(uint32_t instance);\n};\n#elif MG_OTA <= MG_OTA_RT1064\n// RT104x and RT106x support ROM API version 1.5\nstruct mg_flexspi_nor_driver_interface {\n  uint32_t version;\n  int (*init)(uint32_t instance, struct mg_flexspi_nor_config *config);\n  int (*program)(uint32_t instance, struct mg_flexspi_nor_config *config,\n                 uint32_t dst_addr, const uint32_t *src);\n  int (*erase_all)(uint32_t instance, struct mg_flexspi_nor_config *config);\n  int (*erase)(uint32_t instance, struct mg_flexspi_nor_config *config,\n               uint32_t start, uint32_t lengthInBytes);\n  int (*read)(uint32_t instance, struct mg_flexspi_nor_config *config,\n              uint32_t *dst, uint32_t addr, uint32_t lengthInBytes);\n  void (*clear_cache)(uint32_t instance);\n  int (*xfer)(uint32_t instance, char *xfer);\n  int (*update_lut)(uint32_t instance, uint32_t seqIndex,\n                    const uint32_t *lutBase, uint32_t seqNumber);\n  int (*get_config)(uint32_t instance, struct mg_flexspi_nor_config *config,\n                    uint32_t *option);\n};\n#else\n// RT117x support ROM API version 1.7\nstruct mg_flexspi_nor_driver_interface {\n  uint32_t version;\n  int (*init)(uint32_t instance, struct mg_flexspi_nor_config *config);\n  int (*program)(uint32_t instance, struct mg_flexspi_nor_config *config,\n                 uint32_t dst_addr, const uint32_t *src);\n  int (*erase_all)(uint32_t instance, struct mg_flexspi_nor_config *config);\n  int (*erase)(uint32_t instance, struct mg_flexspi_nor_config *config,\n               uint32_t start, uint32_t lengthInBytes);\n  int (*read)(uint32_t instance, struct mg_flexspi_nor_config *config,\n              uint32_t *dst, uint32_t addr, uint32_t lengthInBytes);\n  uint32_t reserved;\n  int (*xfer)(uint32_t instance, char *xfer);\n  int (*update_lut)(uint32_t instance, uint32_t seqIndex,\n                    const uint32_t *lutBase, uint32_t seqNumber);\n  int (*get_config)(uint32_t instance, struct mg_flexspi_nor_config *config,\n                    uint32_t *option);\n  int (*erase_sector)(uint32_t instance, struct mg_flexspi_nor_config *config,\n                      uint32_t address);\n  int (*erase_block)(uint32_t instance, struct mg_flexspi_nor_config *config,\n                     uint32_t address);\n  void (*hw_reset)(uint32_t instance, uint32_t resetLogic);\n  int (*wait_busy)(uint32_t instance, struct mg_flexspi_nor_config *config,\n                  bool isParallelMode, uint32_t address);\n  int (*set_clock_source)(uint32_t instance, uint32_t clockSrc);\n  void (*config_clock)(uint32_t instance, uint32_t freqOption,\n                  uint32_t sampleClkMode);\n};\n#endif\n\n#if MG_OTA <= MG_OTA_RT1064\n#define MG_FLEXSPI_BASE 0x402A8000\n#define flexspi_nor                                                          \\\n  (*((struct mg_flexspi_nor_driver_interface **) (*(uint32_t *) 0x0020001c + \\\n                                                  16)))\n#else\n#define MG_FLEXSPI_BASE 0x400CC000\n#define flexspi_nor                                                          \\\n  (*((struct mg_flexspi_nor_driver_interface **) (*(uint32_t *) 0x0021001c + \\\n                                                  12)))\n#endif\n\nstatic bool s_flash_irq_disabled;\n\nMG_IRAM static bool flash_page_start(volatile uint32_t *dst) {\n  char *base = (char *) s_mg_flash_imxrt.start, *end = base + s_mg_flash_imxrt.size;\n  volatile char *p = (char *) dst;\n  return p >= base && p < end && ((p - base) % s_mg_flash_imxrt.secsz) == 0;\n}\n\n// Note: the get_config function below works both for RT1020 and 1060\n// must reside in RAM, as flash will be erased\nstatic struct mg_flexspi_nor_config default_config = {\n  .memConfig = {.tag = MG_FLEXSPI_CFG_BLK_TAG,\n                .version = MG_FLEXSPI_CFG_BLK_VERSION,\n                .readSampleClkSrc = 1,  // ReadSampleClk_LoopbackFromDqsPad\n                .csHoldTime = 3,\n                .csSetupTime = 3,\n                .controllerMiscOption = MG_BIT(4),\n                .deviceType = 1,  // serial NOR\n                .sflashPadType = 4,\n                .serialClkFreq = 7,  // 133MHz\n                .sflashA1Size = 8 * 1024 * 1024,\n                .lookupTable = MG_FLEXSPI_QSPI_LUT},\n  .pageSize = 256,\n  .sectorSize = 4 * 1024,\n  .ipcmdSerialClkFreq = 1,\n  .blockSize = 64 * 1024,\n  .isUniformBlockSize = false\n};\nMG_IRAM static int flexspi_nor_get_config(\n  struct mg_flexspi_nor_config **config) {\n  *config = &default_config;\n  return 0;\n}\n\n#if 0\n// ROM API get_config call (ROM version >= 1.5)\nMG_IRAM static int flexspi_nor_get_config(\n    struct mg_flexspi_nor_config **config) {\n  uint32_t options[] = {0xc0000000, 0x00};\n\n  MG_ARM_DISABLE_IRQ();\n  uint32_t status =\n      flexspi_nor->get_config(FLEXSPI_NOR_INSTANCE, *config, options);\n  if (!s_flash_irq_disabled) {\n    MG_ARM_ENABLE_IRQ();\n  }\n  if (status) {\n    MG_ERROR((\"Failed to extract flash configuration: status %u\", status));\n  }\n  return status;\n}\n#endif\n\nMG_IRAM static void mg_spin(volatile uint32_t count) {\n  while (count--) (void) 0;\n}\n\nMG_IRAM static void flash_wait(void) {\n  while ((*((volatile uint32_t *) (MG_FLEXSPI_BASE + 0xE0)) & MG_BIT(1)) == 0)\n    mg_spin(1);\n}\n\nMG_IRAM static bool flash_erase(struct mg_flexspi_nor_config *config,\n                                void *addr) {\n  if (flash_page_start(addr) == false) {\n    MG_ERROR((\"%p is not on a sector boundary\", addr));\n    return false;\n  }\n\n  void *dst = (void *) ((char *) addr - (char *) s_mg_flash_imxrt.start);\n\n  bool ok = (flexspi_nor->erase(FLEXSPI_NOR_INSTANCE, config, (uint32_t) dst,\n                                s_mg_flash_imxrt.secsz) == 0);\n  MG_DEBUG((\"Sector starting at %p erasure: %s\", addr, ok ? \"ok\" : \"fail\"));\n  return ok;\n}\n\n#if 0\n// standalone erase call\nMG_IRAM static bool mg_imxrt_erase(void *addr) {\n  struct mg_flexspi_nor_config config, *config_ptr = &config;\n  bool ret;\n  // Interrupts must be disabled before calls to ROM API in RT1020 and 1060\n  MG_ARM_DISABLE_IRQ();\n  ret = (flexspi_nor_get_config(&config_ptr) == 0);\n  if (ret) ret = flash_erase(config_ptr, addr);\n  MG_ARM_ENABLE_IRQ();\n  return ret;\n}\n#endif\n\nMG_IRAM bool mg_imxrt_swap(void) {\n  return true;\n}\n\nMG_IRAM static bool mg_imxrt_write(void *addr, const void *buf, size_t len) {\n  struct mg_flexspi_nor_config config, *config_ptr = &config;\n  bool ok = false;\n  // Interrupts must be disabled before calls to ROM API in RT1020 and 1060\n  MG_ARM_DISABLE_IRQ();\n  if (flexspi_nor_get_config(&config_ptr) != 0) goto fwxit;\n  if ((len % s_mg_flash_imxrt.align) != 0) {\n    MG_ERROR((\"%lu is not aligned to %lu\", len, s_mg_flash_imxrt.align));\n    goto fwxit;\n  }\n  if ((char *) addr < (char *) s_mg_flash_imxrt.start) {\n    MG_ERROR((\"Invalid flash write address: %p\", addr));\n    goto fwxit;\n  }\n\n  uint32_t *dst = (uint32_t *) addr;\n  uint32_t *src = (uint32_t *) buf;\n  uint32_t *end = (uint32_t *) ((char *) buf + len);\n  ok = true;\n\n  while (ok && src < end) {\n    if (flash_page_start(dst) && flash_erase(config_ptr, dst) == false) {\n      ok = false;\n      break;\n    }\n    uint32_t status;\n    uint32_t dst_ofs = (uint32_t) dst - (uint32_t) s_mg_flash_imxrt.start;\n    if ((char *) buf >= (char *) s_mg_flash_imxrt.start) {\n      // If we copy from FLASH to FLASH, then we first need to copy the source\n      // to RAM\n      size_t tmp_buf_size = s_mg_flash_imxrt.align / sizeof(uint32_t);\n      uint32_t tmp[tmp_buf_size];\n\n      for (size_t i = 0; i < tmp_buf_size; i++) {\n        flash_wait();\n        tmp[i] = src[i];\n      }\n      status = flexspi_nor->program(FLEXSPI_NOR_INSTANCE, config_ptr,\n                                    (uint32_t) dst_ofs, tmp);\n    } else {\n      status = flexspi_nor->program(FLEXSPI_NOR_INSTANCE, config_ptr,\n                                    (uint32_t) dst_ofs, src);\n    }\n    src = (uint32_t *) ((char *) src + s_mg_flash_imxrt.align);\n    dst = (uint32_t *) ((char *) dst + s_mg_flash_imxrt.align);\n    if (status != 0) {\n      ok = false;\n    }\n  }\n  MG_DEBUG((\"Flash write %lu bytes @ %p: %s.\", len, dst, ok ? \"ok\" : \"fail\"));\nfwxit:\n  if (!s_flash_irq_disabled) MG_ARM_ENABLE_IRQ();\n  return ok;\n}\n\n// just overwrite instead of swap\nMG_IRAM static void single_bank_swap(char *p1, char *p2, size_t s, size_t ss) {\n  // no stdlib calls here\n  for (size_t ofs = 0; ofs < s; ofs += ss) {\n    mg_imxrt_write(p1 + ofs, p2 + ofs, ss);\n  }\n  *(volatile unsigned long *) 0xe000ed0c = 0x5fa0004;\n}\n\nbool mg_ota_begin(size_t new_firmware_size) {\n  return mg_ota_flash_begin(new_firmware_size, &s_mg_flash_imxrt);\n}\n\nbool mg_ota_write(const void *buf, size_t len) {\n  return mg_ota_flash_write(buf, len, &s_mg_flash_imxrt);\n}\n\nbool mg_ota_end(void) {\n  if (mg_ota_flash_end(&s_mg_flash_imxrt)) {\n    if (0) {  // is_dualbank()\n      // TODO(): no devices so far\n      *(volatile unsigned long *) 0xe000ed0c = 0x5fa0004;\n    } else {\n      // Swap partitions. Pray power does not go away\n      MG_INFO((\"Swapping partitions, size %u (%u sectors)\",\n               s_mg_flash_imxrt.size,\n               s_mg_flash_imxrt.size / s_mg_flash_imxrt.secsz));\n      MG_INFO((\"Do NOT power off...\"));\n      mg_log_level = MG_LL_NONE;\n      s_flash_irq_disabled = true;\n      // Runs in RAM, will reset when finished\n      single_bank_swap(\n          (char *) s_mg_flash_imxrt.start,\n          (char *) s_mg_flash_imxrt.start + s_mg_flash_imxrt.size / 2,\n          s_mg_flash_imxrt.size / 2, s_mg_flash_imxrt.secsz);\n    }\n  }\n  return false;\n}\n\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ota_mcxn.c\"\n#endif\n\n\n\n\n#if MG_OTA == MG_OTA_MCXN\n\n// - Flash phrase: 16 bytes; smallest portion programmed in one operation.\n// - Flash page: 128 bytes; largest portion programmed in one operation.\n// - Flash sector: 8 KB; smallest portion that can be erased in one operation.\n// - Flash API mg_flash_driver->program: \"start\" and \"len\" must be page-size\n// aligned; to use 'phrase', FMU register access is needed. Using ROM\n\nstatic bool mg_mcxn_write(void *, const void *, size_t);\nstatic bool mg_mcxn_swap(void);\n\nstatic struct mg_flash s_mg_flash_mcxn = {\n    (void *) 0,  // Start, filled at init\n    0,           // Size, filled at init\n    0,           // Sector size, filled at init\n    0,           // Align, filled at init\n    mg_mcxn_write,\n    mg_mcxn_swap,\n};\n\nstruct mg_flash_config {\n  uint32_t addr;\n  uint32_t size;\n  uint32_t blocks;\n  uint32_t page_size;\n  uint32_t sector_size;\n  uint32_t ffr[6];\n  uint32_t reserved0[5];\n  uint32_t *bootctx;\n  bool useahb;\n};\n\nstruct mg_flash_driver_interface {\n  uint32_t version;\n  uint32_t (*init)(struct mg_flash_config *);\n  uint32_t (*erase)(struct mg_flash_config *, uint32_t start, uint32_t len,\n                    uint32_t key);\n  uint32_t (*program)(struct mg_flash_config *, uint32_t start, uint8_t *src,\n                      uint32_t len);\n  uint32_t (*verify_erase)(struct mg_flash_config *, uint32_t start,\n                           uint32_t len);\n  uint32_t (*verify_program)(struct mg_flash_config *, uint32_t start,\n                             uint32_t len, const uint8_t *expected,\n                             uint32_t *addr, uint32_t *failed);\n  uint32_t reserved1[12];\n  uint32_t (*read)(struct mg_flash_config *, uint32_t start, uint8_t *dest,\n                   uint32_t len);\n  uint32_t reserved2[4];\n  uint32_t (*deinit)(struct mg_flash_config *);\n};\n#define mg_flash_driver \\\n  ((struct mg_flash_driver_interface *) (*((uint32_t *) 0x1303fc00 + 4)))\n#define MG_MCXN_FLASK_KEY (('k' << 24) | ('e' << 16) | ('f' << 8) | 'l')\n\nMG_IRAM static bool flash_sector_start(volatile uint32_t *dst) {\n  char *base = (char *) s_mg_flash_mcxn.start,\n       *end = base + s_mg_flash_mcxn.size;\n  volatile char *p = (char *) dst;\n  return p >= base && p < end && ((p - base) % s_mg_flash_mcxn.secsz) == 0;\n}\n\nMG_IRAM static bool flash_erase(struct mg_flash_config *config, void *addr) {\n  if (flash_sector_start(addr) == false) {\n    MG_ERROR((\"%p is not on a sector boundary\", addr));\n    return false;\n  }\n  uint32_t dst =\n      (uint32_t) addr - (uint32_t) s_mg_flash_mcxn.start;  // future-proof\n  uint32_t status = mg_flash_driver->erase(config, dst, s_mg_flash_mcxn.secsz,\n                                           MG_MCXN_FLASK_KEY);\n  bool ok = (status == 0);\n  if (!ok) MG_ERROR((\"Flash write error: %lu\", status));\n  MG_DEBUG((\"Sector starting at %p erasure: %s\", addr, ok ? \"ok\" : \"fail\"));\n  return ok;\n}\n\n#if 0\n// read-while-write, no need to disable IRQs for standalone usage\nMG_IRAM static bool mg_mcxn_erase(void *addr) {\n  uint32_t status;\n  struct mg_flash_config config;\n  if ((status = mg_flash_driver->init(&config)) != 0) {\n    MG_ERROR((\"Flash driver init error: %lu\", status));\n    return false;\n  }\n  bool ok = flash_erase(&config, addr);\n  mg_flash_driver->deinit(&config);\n  return ok;\n}\n#endif\n\nMG_IRAM static bool mg_mcxn_swap(void) {\n  // TODO(): no devices so far\n  return true;\n}\n\nstatic bool s_flash_irq_disabled;\n\nMG_IRAM static bool mg_mcxn_write(void *addr, const void *buf, size_t len) {\n  bool ok = false;\n  uint32_t status;\n  struct mg_flash_config config;\n  if ((status = mg_flash_driver->init(&config)) != 0) {\n    MG_ERROR((\"Flash driver init error: %lu\", status));\n    return false;\n  }\n  if ((len % s_mg_flash_mcxn.align) != 0) {\n    MG_ERROR((\"%lu is not aligned to %lu\", len, s_mg_flash_mcxn.align));\n    goto fwxit;\n  }\n  if ((((size_t) addr - (size_t) s_mg_flash_mcxn.start) %\n       s_mg_flash_mcxn.align) != 0) {\n    MG_ERROR((\"%p is not on a page boundary\", addr));\n    goto fwxit;\n  }\n\n  uint32_t *dst = (uint32_t *) addr;\n  uint32_t *src = (uint32_t *) buf;\n  uint32_t *end = (uint32_t *) ((char *) buf + len);\n  ok = true;\n\n  MG_ARM_DISABLE_IRQ();\n  while (ok && src < end) {\n    if (flash_sector_start(dst) && flash_erase(&config, dst) == false) {\n      ok = false;\n      break;\n    }\n    uint32_t dst_ofs = (uint32_t) dst - (uint32_t) s_mg_flash_mcxn.start;\n    // assume source is in RAM or in a different bank or read-while-write\n    status = mg_flash_driver->program(&config, dst_ofs, (uint8_t *) src,\n                                      s_mg_flash_mcxn.align);\n    src = (uint32_t *) ((char *) src + s_mg_flash_mcxn.align);\n    dst = (uint32_t *) ((char *) dst + s_mg_flash_mcxn.align);\n    if (status != 0) {\n      MG_ERROR((\"Flash write error: %lu\", status));\n      ok = false;\n    }\n  }\n  if (!s_flash_irq_disabled) MG_ARM_ENABLE_IRQ();\n  MG_DEBUG((\"Flash write %lu bytes @ %p: %s.\", len, dst, ok ? \"ok\" : \"fail\"));\n\nfwxit:\n  mg_flash_driver->deinit(&config);\n  return ok;\n}\n\n// try to swap (honor dual image), otherwise just overwrite\nMG_IRAM static void single_bank_swap(char *p1, char *p2, size_t s, size_t ss) {\n  char *tmp = malloc(ss);\n  // no stdlib calls here\n  for (size_t ofs = 0; ofs < s; ofs += ss) {\n    if (tmp != NULL)\n      for (size_t i = 0; i < ss; i++) tmp[i] = p1[ofs + i];\n    mg_mcxn_write(p1 + ofs, p2 + ofs, ss);\n    if (tmp != NULL) mg_mcxn_write(p2 + ofs, tmp, ss);\n  }\n  *(volatile unsigned long *) 0xe000ed0c = 0x5fa0004;\n}\n\nbool mg_ota_begin(size_t new_firmware_size) {\n  uint32_t status;\n  struct mg_flash_config config;\n  if ((status = mg_flash_driver->init(&config)) != 0) {\n    MG_ERROR((\"Flash driver init error: %lu\", status));\n    return false;\n  }\n  s_mg_flash_mcxn.start = (void *) config.addr;\n  s_mg_flash_mcxn.size = config.size;\n  s_mg_flash_mcxn.secsz = config.sector_size;\n  s_mg_flash_mcxn.align = config.page_size;\n  mg_flash_driver->deinit(&config);\n  MG_DEBUG(\n      (\"%lu-byte flash @%p, using %lu-byte sectors with %lu-byte-aligned pages\",\n       s_mg_flash_mcxn.size, s_mg_flash_mcxn.start, s_mg_flash_mcxn.secsz,\n       s_mg_flash_mcxn.align));\n  return mg_ota_flash_begin(new_firmware_size, &s_mg_flash_mcxn);\n}\n\nbool mg_ota_write(const void *buf, size_t len) {\n  return mg_ota_flash_write(buf, len, &s_mg_flash_mcxn);\n}\n\nbool mg_ota_end(void) {\n  if (mg_ota_flash_end(&s_mg_flash_mcxn)) {\n    if (0) {  // is_dualbank()\n      // TODO(): no devices so far\n      *(volatile unsigned long *) 0xe000ed0c = 0x5fa0004;\n    } else {\n      // Swap partitions. Pray power does not go away\n      MG_INFO((\"Swapping partitions, size %u (%u sectors)\",\n               s_mg_flash_mcxn.size,\n               s_mg_flash_mcxn.size / s_mg_flash_mcxn.secsz));\n      MG_INFO((\"Do NOT power off...\"));\n      mg_log_level = MG_LL_NONE;\n      s_flash_irq_disabled = true;\n      // Runs in RAM, will reset when finished\n      single_bank_swap(\n          (char *) s_mg_flash_mcxn.start,\n          (char *) s_mg_flash_mcxn.start + s_mg_flash_mcxn.size / 2,\n          s_mg_flash_mcxn.size / 2, s_mg_flash_mcxn.secsz);\n    }\n  }\n  return false;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ota_picosdk.c\"\n#endif\n\n\n\n\n#if MG_OTA == MG_OTA_PICOSDK\n\n// Both RP2040 and RP2350 have no flash, low-level flash access support in\n// bootrom, and high-level support in Pico-SDK (2.0+ for the RP2350)\n// - The RP2350 in RISC-V mode is not yet (fully) supported (nor tested)\n\nstatic bool mg_picosdk_write(void *, const void *, size_t);\nstatic bool mg_picosdk_swap(void);\n\nstatic struct mg_flash s_mg_flash_picosdk = {\n    (void *) 0x10000000,  // Start, not used here; functions handle offset\n#ifdef PICO_FLASH_SIZE_BYTES\n    PICO_FLASH_SIZE_BYTES,  // Size, from board definitions\n#else\n    0x200000,  // Size, guess... is 2M enough ?\n#endif\n    FLASH_SECTOR_SIZE,  // Sector size, from hardware_flash\n    FLASH_PAGE_SIZE,    // Align, from hardware_flash\n    mg_picosdk_write,      mg_picosdk_swap,\n};\n\n#define MG_MODULO2(x, m) ((x) & ((m) -1))\n\nstatic bool __no_inline_not_in_flash_func(flash_sector_start)(\n    volatile uint32_t *dst) {\n  char *base = (char *) s_mg_flash_picosdk.start,\n       *end = base + s_mg_flash_picosdk.size;\n  volatile char *p = (char *) dst;\n  return p >= base && p < end &&\n         MG_MODULO2(p - base, s_mg_flash_picosdk.secsz) == 0;\n}\n\nstatic bool __no_inline_not_in_flash_func(flash_erase)(void *addr) {\n  if (flash_sector_start(addr) == false) {\n    MG_ERROR((\"%p is not on a sector boundary\", addr));\n    return false;\n  }\n  void *dst = (void *) ((char *) addr - (char *) s_mg_flash_picosdk.start);\n  flash_range_erase((uint32_t) dst, s_mg_flash_picosdk.secsz);\n  MG_DEBUG((\"Sector starting at %p erasure\", addr));\n  return true;\n}\n\nstatic bool __no_inline_not_in_flash_func(mg_picosdk_swap)(void) {\n  // TODO(): RP2350 might have some A/B functionality (DS 5.1)\n  return true;\n}\n\nstatic bool s_flash_irq_disabled;\n\nstatic bool __no_inline_not_in_flash_func(mg_picosdk_write)(void *addr,\n                                                            const void *buf,\n                                                            size_t len) {\n  if ((len % s_mg_flash_picosdk.align) != 0) {\n    MG_ERROR((\"%lu is not aligned to %lu\", len, s_mg_flash_picosdk.align));\n    return false;\n  }\n  if ((((size_t) addr - (size_t) s_mg_flash_picosdk.start) %\n       s_mg_flash_picosdk.align) != 0) {\n    MG_ERROR((\"%p is not on a page boundary\", addr));\n    return false;\n  }\n\n  uint32_t *dst = (uint32_t *) addr;\n  uint32_t *src = (uint32_t *) buf;\n  uint32_t *end = (uint32_t *) ((char *) buf + len);\n\n#ifndef __riscv\n  MG_ARM_DISABLE_IRQ();\n#else\n  asm volatile(\"csrrc zero, mstatus, %0\" : : \"i\"(1 << 3) : \"memory\");\n#endif\n  while (src < end) {\n    uint32_t dst_ofs = (uint32_t) dst - (uint32_t) s_mg_flash_picosdk.start;\n    if (flash_sector_start(dst) && flash_erase(dst) == false) break;\n    // flash_range_program() runs in RAM and handles writing up to\n    // FLASH_PAGE_SIZE bytes. Source must not be in flash\n    flash_range_program((uint32_t) dst_ofs, (uint8_t *) src,\n                        s_mg_flash_picosdk.align);\n    src = (uint32_t *) ((char *) src + s_mg_flash_picosdk.align);\n    dst = (uint32_t *) ((char *) dst + s_mg_flash_picosdk.align);\n  }\n  if (!s_flash_irq_disabled) {\n#ifndef __riscv\n    MG_ARM_ENABLE_IRQ();\n#else\n    asm volatile(\"csrrs mstatus, %0\" : : \"i\"(1 << 3) : \"memory\");\n#endif\n  }\n  MG_DEBUG((\"Flash write %lu bytes @ %p.\", len, dst));\n  return true;\n}\n\n// just overwrite instead of swap\nstatic void __no_inline_not_in_flash_func(single_bank_swap)(char *p1, char *p2,\n                                                            size_t s,\n                                                            size_t ss) {\n  char *tmp = malloc(ss);\n  if (tmp == NULL) return;\n#if PICO_RP2040\n  uint32_t xip[256 / sizeof(uint32_t)];\n  void *dst = (void *) ((char *) p1 - (char *) s_mg_flash_picosdk.start);\n  size_t count = MG_ROUND_UP(s, ss);\n  // use SDK function calls to get BootROM function pointers\n  rom_connect_internal_flash_fn connect = (rom_connect_internal_flash_fn) rom_func_lookup_inline(ROM_FUNC_CONNECT_INTERNAL_FLASH);\n  rom_flash_exit_xip_fn xit = (rom_flash_exit_xip_fn) rom_func_lookup_inline(ROM_FUNC_FLASH_EXIT_XIP);\n  rom_flash_range_program_fn program = (rom_flash_range_program_fn) rom_func_lookup_inline(ROM_FUNC_FLASH_RANGE_PROGRAM);\n  rom_flash_flush_cache_fn flush = (rom_flash_flush_cache_fn) rom_func_lookup_inline(ROM_FUNC_FLASH_FLUSH_CACHE);\n  // no stdlib calls here.\n  MG_ARM_DISABLE_IRQ();\n  // 2nd bootloader (XIP) is in flash, SDK functions copy it to RAM on entry\n  for (size_t i = 0; i < 256 / sizeof(uint32_t); i++)\n    xip[i] = ((uint32_t *) (s_mg_flash_picosdk.start))[i];\n  flash_range_erase((uint32_t) dst, count);\n  // flash has been erased, no XIP to copy. Only BootROM calls possible\n  for (uint32_t ofs = 0; ofs < s; ofs += ss) {\n    for (size_t i = 0; i < ss; i++) tmp[i] = p2[ofs + i];\n    __compiler_memory_barrier();\n    connect();\n    xit();\n    program((uint32_t) dst + ofs, tmp, ss);\n    flush();\n    ((void (*)(void))((intptr_t) xip + 1))(); // enter XIP again\n  }\n  *(volatile unsigned long *) 0xe000ed0c = 0x5fa0004;  // AIRCR = SYSRESETREQ\n#else\n  // RP2350 has bootram and copies second bootloader there, SDK uses that copy,\n  // It might also be able to take advantage of partition swapping\n  for (size_t ofs = 0; ofs < s; ofs += ss) {\n    for (size_t i = 0; i < ss; i++) tmp[i] = p2[ofs + i];\n    mg_picosdk_write(p1 + ofs, tmp, ss);\n  }\n#ifndef __riscv\n  *(volatile unsigned long *) 0xe000ed0c = 0x5fa0004;  // AIRCR = SYSRESETREQ\n#else\n  // TODO(): find a way to do a system reset, like block resets and watchdog\n#endif\n#endif\n}\n\nbool mg_ota_begin(size_t new_firmware_size) {\n  return mg_ota_flash_begin(new_firmware_size, &s_mg_flash_picosdk);\n}\n\nbool mg_ota_write(const void *buf, size_t len) {\n  return mg_ota_flash_write(buf, len, &s_mg_flash_picosdk);\n}\n\nbool mg_ota_end(void) {\n  if (mg_ota_flash_end(&s_mg_flash_picosdk)) {\n    // Swap partitions. Pray power does not go away\n    MG_INFO((\"Swapping partitions, size %u (%u sectors)\",\n             s_mg_flash_picosdk.size,\n             s_mg_flash_picosdk.size / s_mg_flash_picosdk.secsz));\n    MG_INFO((\"Do NOT power off...\"));\n    mg_log_level = MG_LL_NONE;\n    s_flash_irq_disabled = true;\n    // Runs in RAM, will reset when finished or return on failure\n    single_bank_swap(\n        (char *) s_mg_flash_picosdk.start,\n        (char *) s_mg_flash_picosdk.start + s_mg_flash_picosdk.size / 2,\n        s_mg_flash_picosdk.size / 2, s_mg_flash_picosdk.secsz);\n  }\n  return false;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ota_stm32f.c\"\n#endif\n\n\n\n\n#if MG_OTA == MG_OTA_STM32F\n\nstatic bool mg_stm32f_write(void *, const void *, size_t);\nstatic bool mg_stm32f_swap(void);\n\nstatic struct mg_flash s_mg_flash_stm32f = {\n    (void *) 0x08000000,  // Start\n    0,                    // Size, FLASH_SIZE_REG\n    0,                    // Irregular sector size\n    32,                   // Align, 256 bit\n    mg_stm32f_write,\n    mg_stm32f_swap,\n};\n\n#define MG_FLASH_BASE 0x40023c00\n#define MG_FLASH_KEYR 0x04\n#define MG_FLASH_SR 0x0c\n#define MG_FLASH_CR 0x10\n#define MG_FLASH_OPTCR 0x14\n#define MG_FLASH_SIZE_REG_F7 0x1FF0F442\n#define MG_FLASH_SIZE_REG_F4 0x1FFF7A22\n\n#define STM_DBGMCU_IDCODE 0xE0042000\n#define STM_DEV_ID (MG_REG(STM_DBGMCU_IDCODE) & (MG_BIT(12) - 1))\n#define SYSCFG_MEMRMP 0x40013800\n\n#define MG_FLASH_SIZE_REG_LOCATION \\\n  ((STM_DEV_ID >= 0x449) ? MG_FLASH_SIZE_REG_F7 : MG_FLASH_SIZE_REG_F4)\n\nstatic size_t flash_size(void) {\n  return (MG_REG(MG_FLASH_SIZE_REG_LOCATION) & 0xFFFF) * 1024;\n}\n\nMG_IRAM static int is_dualbank(void) {\n  // only F42x/F43x series (0x419) support dual bank\n  return STM_DEV_ID == 0x419;\n}\n\nMG_IRAM static void flash_unlock(void) {\n  static bool unlocked = false;\n  if (unlocked == false) {\n    MG_REG(MG_FLASH_BASE + MG_FLASH_KEYR) = 0x45670123;\n    MG_REG(MG_FLASH_BASE + MG_FLASH_KEYR) = 0xcdef89ab;\n    unlocked = true;\n  }\n}\n\n#define MG_FLASH_CONFIG_16_64_128 1   // used by STM32F7\n#define MG_FLASH_CONFIG_32_128_256 2  // used by STM32F4 and F2\n\nMG_IRAM static bool flash_page_start(volatile uint32_t *dst) {\n  char *base = (char *) s_mg_flash_stm32f.start;\n  char *end = base + s_mg_flash_stm32f.size;\n\n  if (is_dualbank() && dst >= (uint32_t *) (base + (end - base) / 2)) {\n    dst = (uint32_t *) ((uint32_t) dst - (end - base) / 2);\n  }\n\n  uint32_t flash_config = MG_FLASH_CONFIG_16_64_128;\n  if (STM_DEV_ID >= 0x449) {\n    flash_config = MG_FLASH_CONFIG_32_128_256;\n  }\n\n  volatile char *p = (char *) dst;\n  if (p >= base && p < end) {\n    if (p < base + 16 * 1024 * 4 * flash_config) {\n      if ((p - base) % (16 * 1024 * flash_config) == 0) return true;\n    } else if (p == base + 16 * 1024 * 4 * flash_config) {\n      return true;\n    } else if ((p - base) % (128 * 1024 * flash_config) == 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\nMG_IRAM static int flash_sector(volatile uint32_t *addr) {\n  char *base = (char *) s_mg_flash_stm32f.start;\n  char *end = base + s_mg_flash_stm32f.size;\n  bool addr_in_bank_2 = false;\n  if (is_dualbank() && addr >= (uint32_t *) (base + (end - base) / 2)) {\n    addr = (uint32_t *) ((uint32_t) addr - (end - base) / 2);\n    addr_in_bank_2 = true;\n  }\n  volatile char *p = (char *) addr;\n  uint32_t flash_config = MG_FLASH_CONFIG_16_64_128;\n  if (STM_DEV_ID >= 0x449) {\n    flash_config = MG_FLASH_CONFIG_32_128_256;\n  }\n  int sector = -1;\n  if (p >= base && p < end) {\n    if (p < base + 16 * 1024 * 4 * flash_config) {\n      sector = (p - base) / (16 * 1024 * flash_config);\n    } else if (p >= base + 64 * 1024 * flash_config &&\n               p < base + 128 * 1024 * flash_config) {\n      sector = 4;\n    } else {\n      sector = (p - base) / (128 * 1024 * flash_config) + 4;\n    }\n  }\n  if (sector == -1) return -1;\n  if (addr_in_bank_2) sector += 12;  // a bank has 12 sectors\n  return sector;\n}\n\nMG_IRAM static bool flash_is_err(void) {\n  return MG_REG(MG_FLASH_BASE + MG_FLASH_SR) & ((MG_BIT(7) - 1) << 1);\n}\n\nMG_IRAM static void flash_wait(void) {\n  while (MG_REG(MG_FLASH_BASE + MG_FLASH_SR) & (MG_BIT(16))) (void) 0;\n}\n\nMG_IRAM static void flash_clear_err(void) {\n  flash_wait();                                // Wait until ready\n  MG_REG(MG_FLASH_BASE + MG_FLASH_SR) = 0xf2;  // Clear all errors\n}\n\nMG_IRAM static bool mg_stm32f_erase(void *addr) {\n  bool ok = false;\n  if (flash_page_start(addr) == false) {\n    MG_ERROR((\"%p is not on a sector boundary\", addr));\n  } else {\n    int sector = flash_sector(addr);\n    if (sector < 0) return false;\n    uint32_t sector_reg = sector;\n    if (is_dualbank() && sector >= 12) {\n      // 3.9.8 Flash control register (FLASH_CR) for F42xxx and F43xxx\n      // BITS[7:3]\n      sector_reg -= 12;\n      sector_reg |= MG_BIT(4);\n    }\n    flash_unlock();\n    flash_wait();\n    uint32_t cr = MG_BIT(1);       // SER\n    cr |= MG_BIT(16);              // STRT\n    cr |= (sector_reg & 31) << 3;  // sector\n    MG_REG(MG_FLASH_BASE + MG_FLASH_CR) = cr;\n    ok = !flash_is_err();\n    MG_DEBUG((\"Erase sector %lu @ %p %s. CR %#lx SR %#lx\", sector, addr,\n              ok ? \"ok\" : \"fail\", MG_REG(MG_FLASH_BASE + MG_FLASH_CR),\n              MG_REG(MG_FLASH_BASE + MG_FLASH_SR)));\n    // After we have erased the sector, set CR flags for programming\n    // 2 << 8 is word write parallelism, bit(0) is PG. RM0385, section 3.7.5\n    MG_REG(MG_FLASH_BASE + MG_FLASH_CR) = MG_BIT(0) | (2 << 8);\n    flash_clear_err();\n  }\n  return ok;\n}\n\nMG_IRAM static bool mg_stm32f_swap(void) {\n  // STM32 F42x/F43x support dual bank, however, the memory mapping\n  // change will not be carried through a hard reset. Therefore, we will use\n  // the single bank approach for this family as well.\n  return true;\n}\n\nstatic bool s_flash_irq_disabled;\n\nMG_IRAM static bool mg_stm32f_write(void *addr, const void *buf, size_t len) {\n  if ((len % s_mg_flash_stm32f.align) != 0) {\n    MG_ERROR((\"%lu is not aligned to %lu\", len, s_mg_flash_stm32f.align));\n    return false;\n  }\n  uint32_t *dst = (uint32_t *) addr;\n  uint32_t *src = (uint32_t *) buf;\n  uint32_t *end = (uint32_t *) ((char *) buf + len);\n  bool ok = true;\n  MG_ARM_DISABLE_IRQ();\n  flash_unlock();\n  flash_clear_err();\n  MG_REG(MG_FLASH_BASE + MG_FLASH_CR) = MG_BIT(0) | MG_BIT(9);  // PG, 32-bit\n  flash_wait();\n  MG_DEBUG((\"Writing flash @ %p, %lu bytes\", addr, len));\n  while (ok && src < end) {\n    if (flash_page_start(dst) && mg_stm32f_erase(dst) == false) break;\n    *(volatile uint32_t *) dst++ = *src++;\n    MG_DSB();  // ensure flash is written with no errors\n    flash_wait();\n    if (flash_is_err()) ok = false;\n  }\n  if (!s_flash_irq_disabled) MG_ARM_ENABLE_IRQ();\n  MG_DEBUG((\"Flash write %lu bytes @ %p: %s. CR %#lx SR %#lx\", len, dst,\n            ok ? \"ok\" : \"fail\", MG_REG(MG_FLASH_BASE + MG_FLASH_CR),\n            MG_REG(MG_FLASH_BASE + MG_FLASH_SR)));\n  MG_REG(MG_FLASH_BASE + MG_FLASH_CR) &= ~MG_BIT(0);  // Clear programming flag\n  return ok;\n}\n\n// just overwrite instead of swap\nMG_IRAM void single_bank_swap(char *p1, char *p2, size_t size) {\n  // no stdlib calls here\n  mg_stm32f_write(p1, p2, size);\n  *(volatile unsigned long *) 0xe000ed0c = 0x5fa0004;\n}\n\nbool mg_ota_begin(size_t new_firmware_size) {\n  s_mg_flash_stm32f.size = flash_size();\n  return mg_ota_flash_begin(new_firmware_size, &s_mg_flash_stm32f);\n}\n\nbool mg_ota_write(const void *buf, size_t len) {\n  return mg_ota_flash_write(buf, len, &s_mg_flash_stm32f);\n}\n\nbool mg_ota_end(void) {\n  if (mg_ota_flash_end(&s_mg_flash_stm32f)) {\n    // Swap partitions. Pray power does not go away\n    MG_INFO((\"Swapping partitions, size %u (%u sectors)\",\n             s_mg_flash_stm32f.size, STM_DEV_ID == 0x449 ? 8 : 12));\n    MG_INFO((\"Do NOT power off...\"));\n    mg_log_level = MG_LL_NONE;\n    s_flash_irq_disabled = true;\n    char *p1 = (char *) s_mg_flash_stm32f.start;\n    char *p2 = p1 + s_mg_flash_stm32f.size / 2;\n    size_t size = s_mg_flash_stm32f.size / 2;\n    // Runs in RAM, will reset when finished\n    single_bank_swap(p1, p2, size);\n  }\n  return false;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ota_stm32h5.c\"\n#endif\n\n\n\n\n#if MG_OTA == MG_OTA_STM32H5\n\nstatic bool mg_stm32h5_write(void *, const void *, size_t);\nstatic bool mg_stm32h5_swap(void);\n\nstatic struct mg_flash s_mg_flash_stm32h5 = {\n    (void *) 0x08000000,  // Start\n    2 * 1024 * 1024,      // Size, 2Mb\n    8 * 1024,             // Sector size, 8k\n    16,                   // Align, 128 bit\n    mg_stm32h5_write,\n    mg_stm32h5_swap,\n};\n\n#define MG_FLASH_BASE 0x40022000          // Base address of the flash controller\n#define FLASH_KEYR (MG_FLASH_BASE + 0x4)  // See RM0481 7.11\n#define FLASH_OPTKEYR (MG_FLASH_BASE + 0xc)\n#define FLASH_OPTCR (MG_FLASH_BASE + 0x1c)\n#define FLASH_NSSR (MG_FLASH_BASE + 0x20)\n#define FLASH_NSCR (MG_FLASH_BASE + 0x28)\n#define FLASH_NSCCR (MG_FLASH_BASE + 0x30)\n#define FLASH_OPTSR_CUR (MG_FLASH_BASE + 0x50)\n#define FLASH_OPTSR_PRG (MG_FLASH_BASE + 0x54)\n\nstatic void flash_unlock(void) {\n  static bool unlocked = false;\n  if (unlocked == false) {\n    MG_REG(FLASH_KEYR) = 0x45670123;\n    MG_REG(FLASH_KEYR) = 0Xcdef89ab;\n    MG_REG(FLASH_OPTKEYR) = 0x08192a3b;\n    MG_REG(FLASH_OPTKEYR) = 0x4c5d6e7f;\n    unlocked = true;\n  }\n}\n\nstatic int flash_page_start(volatile uint32_t *dst) {\n  char *base = (char *) s_mg_flash_stm32h5.start,\n       *end = base + s_mg_flash_stm32h5.size;\n  volatile char *p = (char *) dst;\n  return p >= base && p < end && ((p - base) % s_mg_flash_stm32h5.secsz) == 0;\n}\n\nstatic bool flash_is_err(void) {\n  return MG_REG(FLASH_NSSR) & ((MG_BIT(8) - 1) << 17);  // RM0481 7.11.9\n}\n\nstatic void flash_wait(void) {\n  while ((MG_REG(FLASH_NSSR) & MG_BIT(0)) &&\n         (MG_REG(FLASH_NSSR) & MG_BIT(16)) == 0) {\n    (void) 0;\n  }\n}\n\nstatic void flash_clear_err(void) {\n  flash_wait();                                    // Wait until ready\n  MG_REG(FLASH_NSCCR) = ((MG_BIT(9) - 1) << 16U);  // Clear all errors\n}\n\nstatic bool flash_bank_is_swapped(void) {\n  return MG_REG(FLASH_OPTCR) & MG_BIT(31);  // RM0481 7.11.8\n}\n\nstatic bool mg_stm32h5_erase(void *location) {\n  bool ok = false;\n  if (flash_page_start(location) == false) {\n    MG_ERROR((\"%p is not on a sector boundary\"));\n  } else {\n    uintptr_t diff = (char *) location - (char *) s_mg_flash_stm32h5.start;\n    uint32_t sector = diff / s_mg_flash_stm32h5.secsz;\n    uint32_t saved_cr = MG_REG(FLASH_NSCR);  // Save CR value\n    flash_unlock();\n    flash_clear_err();\n    MG_REG(FLASH_NSCR) = 0;\n    if ((sector < 128 && flash_bank_is_swapped()) ||\n        (sector > 127 && !flash_bank_is_swapped())) {\n      MG_REG(FLASH_NSCR) |= MG_BIT(31);  // Set FLASH_CR_BKSEL\n    }\n    if (sector > 127) sector -= 128;\n    MG_REG(FLASH_NSCR) |= MG_BIT(2) | (sector << 6);  // Erase | sector_num\n    MG_REG(FLASH_NSCR) |= MG_BIT(5);                  // Start erasing\n    flash_wait();\n    ok = !flash_is_err();\n    MG_DEBUG((\"Erase sector %lu @ %p: %s. CR %#lx SR %#lx\", sector, location,\n              ok ? \"ok\" : \"fail\", MG_REG(FLASH_NSCR), MG_REG(FLASH_NSSR)));\n    // mg_hexdump(location, 32);\n    MG_REG(FLASH_NSCR) = saved_cr;  // Restore saved CR\n  }\n  return ok;\n}\n\nstatic bool mg_stm32h5_swap(void) {\n  uint32_t desired = flash_bank_is_swapped() ? 0 : MG_BIT(31);\n  flash_unlock();\n  flash_clear_err();\n  // printf(\"OPTSR_PRG 1 %#lx\\n\", FLASH->OPTSR_PRG);\n  MG_SET_BITS(MG_REG(FLASH_OPTSR_PRG), MG_BIT(31), desired);\n  // printf(\"OPTSR_PRG 2 %#lx\\n\", FLASH->OPTSR_PRG);\n  MG_REG(FLASH_OPTCR) |= MG_BIT(1);  // OPTSTART\n  while ((MG_REG(FLASH_OPTSR_CUR) & MG_BIT(31)) != desired) (void) 0;\n  return true;\n}\n\nstatic bool mg_stm32h5_write(void *addr, const void *buf, size_t len) {\n  if ((len % s_mg_flash_stm32h5.align) != 0) {\n    MG_ERROR((\"%lu is not aligned to %lu\", len, s_mg_flash_stm32h5.align));\n    return false;\n  }\n  uint32_t *dst = (uint32_t *) addr;\n  uint32_t *src = (uint32_t *) buf;\n  uint32_t *end = (uint32_t *) ((char *) buf + len);\n  bool ok = true;\n  MG_ARM_DISABLE_IRQ();\n  flash_unlock();\n  flash_clear_err();\n  MG_REG(FLASH_NSCR) = MG_BIT(1);  // Set programming flag\n  while (ok && src < end) {\n    if (flash_page_start(dst) && mg_stm32h5_erase(dst) == false) {\n      ok = false;\n      break;\n    }\n    *(volatile uint32_t *) dst++ = *src++;\n    flash_wait();\n    if (flash_is_err()) ok = false;\n  }\n  MG_ARM_ENABLE_IRQ();\n  MG_DEBUG((\"Flash write %lu bytes @ %p: %s. CR %#lx SR %#lx\", len, dst,\n            flash_is_err() ? \"fail\" : \"ok\", MG_REG(FLASH_NSCR),\n            MG_REG(FLASH_NSSR)));\n  MG_REG(FLASH_NSCR) = 0;  // Clear flags\n  return ok;\n}\n\nbool mg_ota_begin(size_t new_firmware_size) {\n  return mg_ota_flash_begin(new_firmware_size, &s_mg_flash_stm32h5);\n}\n\nbool mg_ota_write(const void *buf, size_t len) {\n  return mg_ota_flash_write(buf, len, &s_mg_flash_stm32h5);\n}\n\n// Actual bank swap is deferred until reset, it is safe to execute in flash\nbool mg_ota_end(void) {\n  if(!mg_ota_flash_end(&s_mg_flash_stm32h5)) return false;\n  *(volatile unsigned long *) 0xe000ed0c = 0x5fa0004;\n  return true;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ota_stm32h7.c\"\n#endif\n\n\n\n\n#if MG_OTA == MG_OTA_STM32H7 || MG_OTA == MG_OTA_STM32H7_DUAL_CORE\n\n// - H723/735 RM 4.3.3: Note: The application can simultaneously request a read\n// and a write operation through the AXI interface.\n//   - We only need IRAM for partition swapping in the H723, however, all\n//   related functions must reside in IRAM for this to be possible.\n// - Linker files for other devices won't define a .iram section so there's no\n// associated penalty\n\nstatic bool mg_stm32h7_write(void *, const void *, size_t);\nstatic bool mg_stm32h7_swap(void);\n\nstatic struct mg_flash s_mg_flash_stm32h7 = {\n    (void *) 0x08000000,  // Start\n    0,                    // Size, FLASH_SIZE_REG\n    128 * 1024,           // Sector size, 128k\n    32,                   // Align, 256 bit\n    mg_stm32h7_write,\n    mg_stm32h7_swap,\n};\n\n#define FLASH_BASE1 0x52002000  // Base address for bank1\n#define FLASH_BASE2 0x52002100  // Base address for bank2\n#define FLASH_KEYR 0x04         // See RM0433 4.9.2\n#define FLASH_OPTKEYR 0x08\n#define FLASH_OPTCR 0x18\n#define FLASH_SR 0x10\n#define FLASH_CR 0x0c\n#define FLASH_CCR 0x14\n#define FLASH_OPTSR_CUR 0x1c\n#define FLASH_OPTSR_PRG 0x20\n#define FLASH_SIZE_REG 0x1ff1e880\n\n#define IS_DUALCORE() (MG_OTA == MG_OTA_STM32H7_DUAL_CORE)\n\nMG_IRAM static bool is_dualbank(void) {\n  if (IS_DUALCORE()) {\n    // H745/H755 and H747/H757 are running on dual core.\n    // Using only the 1st bank (mapped to CM7), in order not to interfere\n    // with the 2nd bank (CM4), possibly causing CM4 to boot unexpectedly.\n    return false;\n  }\n  return (s_mg_flash_stm32h7.size < 2 * 1024 * 1024) ? false : true;\n}\n\nMG_IRAM static void flash_unlock(void) {\n  static bool unlocked = false;\n  if (unlocked == false) {\n    MG_REG(FLASH_BASE1 + FLASH_KEYR) = 0x45670123;\n    MG_REG(FLASH_BASE1 + FLASH_KEYR) = 0xcdef89ab;\n    if (is_dualbank()) {\n      MG_REG(FLASH_BASE2 + FLASH_KEYR) = 0x45670123;\n      MG_REG(FLASH_BASE2 + FLASH_KEYR) = 0xcdef89ab;\n    }\n    MG_REG(FLASH_BASE1 + FLASH_OPTKEYR) = 0x08192a3b;  // opt reg is \"shared\"\n    MG_REG(FLASH_BASE1 + FLASH_OPTKEYR) = 0x4c5d6e7f;  // thus unlock once\n    unlocked = true;\n  }\n}\n\nMG_IRAM static bool flash_page_start(volatile uint32_t *dst) {\n  char *base = (char *) s_mg_flash_stm32h7.start,\n       *end = base + s_mg_flash_stm32h7.size;\n  volatile char *p = (char *) dst;\n  return p >= base && p < end && ((p - base) % s_mg_flash_stm32h7.secsz) == 0;\n}\n\nMG_IRAM static bool flash_is_err(uint32_t bank) {\n  return MG_REG(bank + FLASH_SR) & ((MG_BIT(11) - 1) << 17);  // RM0433 4.9.5\n}\n\nMG_IRAM static void flash_wait(uint32_t bank) {\n  while (MG_REG(bank + FLASH_SR) & (MG_BIT(0) | MG_BIT(2))) (void) 0;\n}\n\nMG_IRAM static void flash_clear_err(uint32_t bank) {\n  flash_wait(bank);                                      // Wait until ready\n  MG_REG(bank + FLASH_CCR) = ((MG_BIT(11) - 1) << 16U);  // Clear all errors\n}\n\nMG_IRAM static bool flash_bank_is_swapped(uint32_t bank) {\n  return MG_REG(bank + FLASH_OPTCR) & MG_BIT(31);  // RM0433 4.9.7\n}\n\n// Figure out flash bank based on the address\nMG_IRAM static uint32_t flash_bank(void *addr) {\n  size_t ofs = (char *) addr - (char *) s_mg_flash_stm32h7.start;\n  if (!is_dualbank()) return FLASH_BASE1;\n  return ofs < s_mg_flash_stm32h7.size / 2 ? FLASH_BASE1 : FLASH_BASE2;\n}\n\n// read-while-write, no need to disable IRQs for standalone usage\nMG_IRAM static bool mg_stm32h7_erase(void *addr) {\n  bool ok = false;\n  if (flash_page_start(addr) == false) {\n    MG_ERROR((\"%p is not on a sector boundary\", addr));\n  } else {\n    uintptr_t diff = (char *) addr - (char *) s_mg_flash_stm32h7.start;\n    uint32_t sector = diff / s_mg_flash_stm32h7.secsz;\n    uint32_t bank = flash_bank(addr);\n    uint32_t saved_cr = MG_REG(bank + FLASH_CR);  // Save CR value\n\n    flash_unlock();\n    if (sector > 7) sector -= 8;\n\n    flash_clear_err(bank);\n    MG_REG(bank + FLASH_CR) = MG_BIT(5);             // 32-bit write parallelism\n    MG_REG(bank + FLASH_CR) |= (sector & 7U) << 8U;  // Sector to erase\n    MG_REG(bank + FLASH_CR) |= MG_BIT(2);            // Sector erase bit\n    MG_REG(bank + FLASH_CR) |= MG_BIT(7);            // Start erasing\n    ok = !flash_is_err(bank);\n    MG_DEBUG((\"Erase sector %lu @ %p %s. CR %#lx SR %#lx\", sector, addr,\n              ok ? \"ok\" : \"fail\", MG_REG(bank + FLASH_CR),\n              MG_REG(bank + FLASH_SR)));\n    MG_REG(bank + FLASH_CR) = saved_cr;  // Restore CR\n  }\n  return ok;\n}\n\nMG_IRAM static bool mg_stm32h7_swap(void) {\n  if (!is_dualbank()) return true;\n  uint32_t bank = FLASH_BASE1;\n  uint32_t desired = flash_bank_is_swapped(bank) ? 0 : MG_BIT(31);\n  flash_unlock();\n  flash_clear_err(bank);\n  // printf(\"OPTSR_PRG 1 %#lx\\n\", FLASH->OPTSR_PRG);\n  MG_SET_BITS(MG_REG(bank + FLASH_OPTSR_PRG), MG_BIT(31), desired);\n  // printf(\"OPTSR_PRG 2 %#lx\\n\", FLASH->OPTSR_PRG);\n  MG_REG(bank + FLASH_OPTCR) |= MG_BIT(1);  // OPTSTART\n  while ((MG_REG(bank + FLASH_OPTSR_CUR) & MG_BIT(31)) != desired) (void) 0;\n  return true;\n}\n\nstatic bool s_flash_irq_disabled;\n\nMG_IRAM static bool mg_stm32h7_write(void *addr, const void *buf, size_t len) {\n  if ((len % s_mg_flash_stm32h7.align) != 0) {\n    MG_ERROR((\"%lu is not aligned to %lu\", len, s_mg_flash_stm32h7.align));\n    return false;\n  }\n  uint32_t bank = flash_bank(addr);\n  uint32_t *dst = (uint32_t *) addr;\n  uint32_t *src = (uint32_t *) buf;\n  uint32_t *end = (uint32_t *) ((char *) buf + len);\n  bool ok = true;\n  MG_ARM_DISABLE_IRQ();\n  flash_unlock();\n  flash_clear_err(bank);\n  MG_REG(bank + FLASH_CR) = MG_BIT(1);   // Set programming flag\n  MG_REG(bank + FLASH_CR) |= MG_BIT(5);  // 32-bit write parallelism\n  while (ok && src < end) {\n    if (flash_page_start(dst) && mg_stm32h7_erase(dst) == false) {\n      ok = false;\n      break;\n    }\n    *(volatile uint32_t *) dst++ = *src++;\n    flash_wait(bank);\n    if (flash_is_err(bank)) ok = false;\n  }\n  if (!s_flash_irq_disabled) MG_ARM_ENABLE_IRQ();\n  MG_DEBUG((\"Flash write %lu bytes @ %p: %s. CR %#lx SR %#lx\", len, dst,\n            ok ? \"ok\" : \"fail\", MG_REG(bank + FLASH_CR),\n            MG_REG(bank + FLASH_SR)));\n  MG_REG(bank + FLASH_CR) &= ~MG_BIT(1);  // Clear programming flag\n  return ok;\n}\n\n// just overwrite instead of swap\nMG_IRAM static void single_bank_swap(char *p1, char *p2, size_t s, size_t ss) {\n  // no stdlib calls here\n  for (size_t ofs = 0; ofs < s; ofs += ss) {\n    mg_stm32h7_write(p1 + ofs, p2 + ofs, ss);\n  }\n  *(volatile unsigned long *) 0xe000ed0c = 0x5fa0004;\n}\n\nbool mg_ota_begin(size_t new_firmware_size) {\n  s_mg_flash_stm32h7.size = MG_REG(FLASH_SIZE_REG) * 1024;\n  if (IS_DUALCORE()) {\n    // Using only the 1st bank (mapped to CM7)\n    s_mg_flash_stm32h7.size /= 2;\n  }\n  return mg_ota_flash_begin(new_firmware_size, &s_mg_flash_stm32h7);\n}\n\nbool mg_ota_write(const void *buf, size_t len) {\n  return mg_ota_flash_write(buf, len, &s_mg_flash_stm32h7);\n}\n\nbool mg_ota_end(void) {\n  if (mg_ota_flash_end(&s_mg_flash_stm32h7)) {\n    if (is_dualbank()) {\n      // Bank swap is deferred until reset, been executing in flash, reset\n      *(volatile unsigned long *) 0xe000ed0c = 0x5fa0004;\n    } else {\n      // Swap partitions. Pray power does not go away\n      MG_INFO((\"Swapping partitions, size %u (%u sectors)\",\n               s_mg_flash_stm32h7.size,\n               s_mg_flash_stm32h7.size / s_mg_flash_stm32h7.secsz));\n      MG_INFO((\"Do NOT power off...\"));\n      mg_log_level = MG_LL_NONE;\n      s_flash_irq_disabled = true;\n      // Runs in RAM, will reset when finished\n      single_bank_swap(\n          (char *) s_mg_flash_stm32h7.start,\n          (char *) s_mg_flash_stm32h7.start + s_mg_flash_stm32h7.size / 2,\n          s_mg_flash_stm32h7.size / 2, s_mg_flash_stm32h7.secsz);\n    }\n  }\n  return false;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/printf.c\"\n#endif\n\n\n\n\nsize_t mg_queue_vprintf(struct mg_queue *q, const char *fmt, va_list *ap) {\n  size_t len = mg_snprintf(NULL, 0, fmt, ap);\n  char *buf;\n  if (len == 0 || mg_queue_book(q, &buf, len + 1) < len + 1) {\n    len = 0;  // Nah. Not enough space\n  } else {\n    len = mg_vsnprintf((char *) buf, len + 1, fmt, ap);\n    mg_queue_add(q, len);\n  }\n  return len;\n}\n\nsize_t mg_queue_printf(struct mg_queue *q, const char *fmt, ...) {\n  va_list ap;\n  size_t len;\n  va_start(ap, fmt);\n  len = mg_queue_vprintf(q, fmt, &ap);\n  va_end(ap);\n  return len;\n}\n\nstatic void mg_pfn_iobuf_private(char ch, void *param, bool expand) {\n  struct mg_iobuf *io = (struct mg_iobuf *) param;\n  if (expand && io->len + 2 > io->size) mg_iobuf_resize(io, io->len + 2);\n  if (io->len + 2 <= io->size) {\n    io->buf[io->len++] = (uint8_t) ch;\n    io->buf[io->len] = 0;\n  } else if (io->len < io->size) {\n    io->buf[io->len++] = 0;  // Guarantee to 0-terminate\n  }\n}\n\nstatic void mg_putchar_iobuf_static(char ch, void *param) {\n  mg_pfn_iobuf_private(ch, param, false);\n}\n\nvoid mg_pfn_iobuf(char ch, void *param) {\n  mg_pfn_iobuf_private(ch, param, true);\n}\n\nsize_t mg_vsnprintf(char *buf, size_t len, const char *fmt, va_list *ap) {\n  struct mg_iobuf io = {(uint8_t *) buf, len, 0, 0};\n  size_t n = mg_vxprintf(mg_putchar_iobuf_static, &io, fmt, ap);\n  if (n < len) buf[n] = '\\0';\n  return n;\n}\n\nsize_t mg_snprintf(char *buf, size_t len, const char *fmt, ...) {\n  va_list ap;\n  size_t n;\n  va_start(ap, fmt);\n  n = mg_vsnprintf(buf, len, fmt, &ap);\n  va_end(ap);\n  return n;\n}\n\nchar *mg_vmprintf(const char *fmt, va_list *ap) {\n  struct mg_iobuf io = {0, 0, 0, 256};\n  mg_vxprintf(mg_pfn_iobuf, &io, fmt, ap);\n  return (char *) io.buf;\n}\n\nchar *mg_mprintf(const char *fmt, ...) {\n  char *s;\n  va_list ap;\n  va_start(ap, fmt);\n  s = mg_vmprintf(fmt, &ap);\n  va_end(ap);\n  return s;\n}\n\nvoid mg_pfn_stdout(char c, void *param) {\n  putchar(c);\n  (void) param;\n}\n\nstatic size_t print_ip4(void (*out)(char, void *), void *arg, uint8_t *p) {\n  return mg_xprintf(out, arg, \"%d.%d.%d.%d\", p[0], p[1], p[2], p[3]);\n}\n\nstatic size_t print_ip6(void (*out)(char, void *), void *arg, uint16_t *p) {\n  return mg_xprintf(out, arg, \"[%x:%x:%x:%x:%x:%x:%x:%x]\", mg_ntohs(p[0]),\n                    mg_ntohs(p[1]), mg_ntohs(p[2]), mg_ntohs(p[3]),\n                    mg_ntohs(p[4]), mg_ntohs(p[5]), mg_ntohs(p[6]),\n                    mg_ntohs(p[7]));\n}\n\nsize_t mg_print_ip4(void (*out)(char, void *), void *arg, va_list *ap) {\n  uint8_t *p = va_arg(*ap, uint8_t *);\n  return print_ip4(out, arg, p);\n}\n\nsize_t mg_print_ip6(void (*out)(char, void *), void *arg, va_list *ap) {\n  uint16_t *p = va_arg(*ap, uint16_t *);\n  return print_ip6(out, arg, p);\n}\n\nsize_t mg_print_ip(void (*out)(char, void *), void *arg, va_list *ap) {\n  struct mg_addr *addr = va_arg(*ap, struct mg_addr *);\n  if (addr->is_ip6) return print_ip6(out, arg, (uint16_t *) addr->ip);\n  return print_ip4(out, arg, (uint8_t *) &addr->ip);\n}\n\nsize_t mg_print_ip_port(void (*out)(char, void *), void *arg, va_list *ap) {\n  struct mg_addr *a = va_arg(*ap, struct mg_addr *);\n  return mg_xprintf(out, arg, \"%M:%hu\", mg_print_ip, a, mg_ntohs(a->port));\n}\n\nsize_t mg_print_mac(void (*out)(char, void *), void *arg, va_list *ap) {\n  uint8_t *p = va_arg(*ap, uint8_t *);\n  return mg_xprintf(out, arg, \"%02x:%02x:%02x:%02x:%02x:%02x\", p[0], p[1], p[2],\n                    p[3], p[4], p[5]);\n}\n\nstatic char mg_esc(int c, bool esc) {\n  const char *p, *esc1 = \"\\b\\f\\n\\r\\t\\\\\\\"\", *esc2 = \"bfnrt\\\\\\\"\";\n  for (p = esc ? esc1 : esc2; *p != '\\0'; p++) {\n    if (*p == c) return esc ? esc2[p - esc1] : esc1[p - esc2];\n  }\n  return 0;\n}\n\nstatic char mg_escape(int c) {\n  return mg_esc(c, true);\n}\n\nstatic size_t qcpy(void (*out)(char, void *), void *ptr, char *buf,\n                   size_t len) {\n  size_t i = 0, extra = 0;\n  for (i = 0; i < len && buf[i] != '\\0'; i++) {\n    char c = mg_escape(buf[i]);\n    if (c) {\n      out('\\\\', ptr), out(c, ptr), extra++;\n    } else {\n      out(buf[i], ptr);\n    }\n  }\n  return i + extra;\n}\n\nstatic size_t bcpy(void (*out)(char, void *), void *arg, uint8_t *buf,\n                   size_t len) {\n  size_t i, j, n = 0;\n  const char *t =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  for (i = 0; i < len; i += 3) {\n    uint8_t c1 = buf[i], c2 = i + 1 < len ? buf[i + 1] : 0,\n            c3 = i + 2 < len ? buf[i + 2] : 0;\n    char tmp[4] = {t[c1 >> 2], t[(c1 & 3) << 4 | (c2 >> 4)], '=', '='};\n    if (i + 1 < len) tmp[2] = t[(c2 & 15) << 2 | (c3 >> 6)];\n    if (i + 2 < len) tmp[3] = t[c3 & 63];\n    for (j = 0; j < sizeof(tmp) && tmp[j] != '\\0'; j++) out(tmp[j], arg);\n    n += j;\n  }\n  return n;\n}\n\nsize_t mg_print_hex(void (*out)(char, void *), void *arg, va_list *ap) {\n  size_t bl = (size_t) va_arg(*ap, int);\n  uint8_t *p = va_arg(*ap, uint8_t *);\n  const char *hex = \"0123456789abcdef\";\n  size_t j;\n  for (j = 0; j < bl; j++) {\n    out(hex[(p[j] >> 4) & 0x0F], arg);\n    out(hex[p[j] & 0x0F], arg);\n  }\n  return 2 * bl;\n}\nsize_t mg_print_base64(void (*out)(char, void *), void *arg, va_list *ap) {\n  size_t len = (size_t) va_arg(*ap, int);\n  uint8_t *buf = va_arg(*ap, uint8_t *);\n  return bcpy(out, arg, buf, len);\n}\n\nsize_t mg_print_esc(void (*out)(char, void *), void *arg, va_list *ap) {\n  size_t len = (size_t) va_arg(*ap, int);\n  char *p = va_arg(*ap, char *);\n  if (len == 0) len = p == NULL ? 0 : strlen(p);\n  return qcpy(out, arg, p, len);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/queue.c\"\n#endif\n\n\n\n#if (defined(__GNUC__) && (__GNUC__ > 4) ||                                \\\n     (defined(__GNUC_MINOR__) && __GNUC__ == 4 && __GNUC_MINOR__ >= 1)) || \\\n    defined(__clang__)\n#define MG_MEMORY_BARRIER() __sync_synchronize()\n#elif defined(_MSC_VER) && _MSC_VER >= 1700\n#define MG_MEMORY_BARRIER() MemoryBarrier()\n#elif !defined(MG_MEMORY_BARRIER)\n#define MG_MEMORY_BARRIER()\n#endif\n\n// Every message in a queue is prepended by a 32-bit message length (ML).\n// If ML is 0, then it is the end, and reader must wrap to the beginning.\n//\n//  Queue when q->tail <= q->head:\n//  |----- free -----| ML | message1 | ML | message2 |  ----- free ------|\n//  ^                ^                               ^                   ^\n// buf              tail                            head                len\n//\n//  Queue when q->tail > q->head:\n//  | ML | message2 |----- free ------| ML | message1 | 0 |---- free ----|\n//  ^               ^                 ^                                  ^\n// buf             head              tail                               len\n\nvoid mg_queue_init(struct mg_queue *q, char *buf, size_t size) {\n  q->size = size;\n  q->buf = buf;\n  q->head = q->tail = 0;\n}\n\nstatic size_t mg_queue_read_len(struct mg_queue *q) {\n  uint32_t n = 0;\n  MG_MEMORY_BARRIER();\n  memcpy(&n, q->buf + q->tail, sizeof(n));\n  assert(q->tail + n + sizeof(n) <= q->size);\n  return n;\n}\n\nstatic void mg_queue_write_len(struct mg_queue *q, size_t len) {\n  uint32_t n = (uint32_t) len;\n  memcpy(q->buf + q->head, &n, sizeof(n));\n  MG_MEMORY_BARRIER();\n}\n\nsize_t mg_queue_book(struct mg_queue *q, char **buf, size_t len) {\n  size_t space = 0, hs = sizeof(uint32_t) * 2;  // *2 is for the 0 marker\n  if (q->head >= q->tail && q->head + len + hs <= q->size) {\n    space = q->size - q->head - hs;  // There is enough space\n  } else if (q->head >= q->tail && q->tail > hs) {\n    mg_queue_write_len(q, 0);  // Not enough space ahead\n    q->head = 0;               // Wrap head to the beginning\n  }\n  if (q->head + hs + len < q->tail) space = q->tail - q->head - hs;\n  if (buf != NULL) *buf = q->buf + q->head + sizeof(uint32_t);\n  return space;\n}\n\nsize_t mg_queue_next(struct mg_queue *q, char **buf) {\n  size_t len = 0;\n  if (q->tail != q->head) {\n    len = mg_queue_read_len(q);\n    if (len == 0) {  // Zero (head wrapped) ?\n      q->tail = 0;   // Reset tail to the start\n      if (q->head > q->tail) len = mg_queue_read_len(q);  // Read again\n    }\n  }\n  if (buf != NULL) *buf = q->buf + q->tail + sizeof(uint32_t);\n  assert(q->tail + len <= q->size);\n  return len;\n}\n\nvoid mg_queue_add(struct mg_queue *q, size_t len) {\n  assert(len > 0);\n  mg_queue_write_len(q, len);\n  assert(q->head + sizeof(uint32_t) * 2 + len <= q->size);\n  q->head += len + sizeof(uint32_t);\n}\n\nvoid mg_queue_del(struct mg_queue *q, size_t len) {\n  q->tail += len + sizeof(uint32_t);\n  assert(q->tail + sizeof(uint32_t) <= q->size);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/rpc.c\"\n#endif\n\n\n\nvoid mg_rpc_add(struct mg_rpc **head, struct mg_str method,\n                void (*fn)(struct mg_rpc_req *), void *fn_data) {\n  struct mg_rpc *rpc = (struct mg_rpc *) calloc(1, sizeof(*rpc));\n  if (rpc != NULL) {\n    rpc->method = mg_strdup(method);\n    rpc->fn = fn;\n    rpc->fn_data = fn_data;\n    rpc->next = *head, *head = rpc;\n  }\n}\n\nvoid mg_rpc_del(struct mg_rpc **head, void (*fn)(struct mg_rpc_req *)) {\n  struct mg_rpc *r;\n  while ((r = *head) != NULL) {\n    if (r->fn == fn || fn == NULL) {\n      *head = r->next;\n      free((void *) r->method.buf);\n      free(r);\n    } else {\n      head = &(*head)->next;\n    }\n  }\n}\n\nstatic void mg_rpc_call(struct mg_rpc_req *r, struct mg_str method) {\n  struct mg_rpc *h = r->head == NULL ? NULL : *r->head;\n  while (h != NULL && !mg_match(method, h->method, NULL)) h = h->next;\n  if (h != NULL) {\n    r->rpc = h;\n    h->fn(r);\n  } else {\n    mg_rpc_err(r, -32601, \"\\\"%.*s not found\\\"\", (int) method.len, method.buf);\n  }\n}\n\nvoid mg_rpc_process(struct mg_rpc_req *r) {\n  int len, off = mg_json_get(r->frame, \"$.method\", &len);\n  if (off > 0 && r->frame.buf[off] == '\"') {\n    struct mg_str method = mg_str_n(&r->frame.buf[off + 1], (size_t) len - 2);\n    mg_rpc_call(r, method);\n  } else if ((off = mg_json_get(r->frame, \"$.result\", &len)) > 0 ||\n             (off = mg_json_get(r->frame, \"$.error\", &len)) > 0) {\n    mg_rpc_call(r, mg_str(\"\"));  // JSON response! call \"\" method handler\n  } else {\n    mg_rpc_err(r, -32700, \"%m\", mg_print_esc, (int) r->frame.len,\n               r->frame.buf);  // Invalid\n  }\n}\n\nvoid mg_rpc_vok(struct mg_rpc_req *r, const char *fmt, va_list *ap) {\n  int len, off = mg_json_get(r->frame, \"$.id\", &len);\n  if (off > 0) {\n    mg_xprintf(r->pfn, r->pfn_data, \"{%m:%.*s,%m:\", mg_print_esc, 0, \"id\", len,\n               &r->frame.buf[off], mg_print_esc, 0, \"result\");\n    mg_vxprintf(r->pfn, r->pfn_data, fmt == NULL ? \"null\" : fmt, ap);\n    mg_xprintf(r->pfn, r->pfn_data, \"}\");\n  }\n}\n\nvoid mg_rpc_ok(struct mg_rpc_req *r, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_rpc_vok(r, fmt, &ap);\n  va_end(ap);\n}\n\nvoid mg_rpc_verr(struct mg_rpc_req *r, int code, const char *fmt, va_list *ap) {\n  int len, off = mg_json_get(r->frame, \"$.id\", &len);\n  mg_xprintf(r->pfn, r->pfn_data, \"{\");\n  if (off > 0) {\n    mg_xprintf(r->pfn, r->pfn_data, \"%m:%.*s,\", mg_print_esc, 0, \"id\", len,\n               &r->frame.buf[off]);\n  }\n  mg_xprintf(r->pfn, r->pfn_data, \"%m:{%m:%d,%m:\", mg_print_esc, 0, \"error\",\n             mg_print_esc, 0, \"code\", code, mg_print_esc, 0, \"message\");\n  mg_vxprintf(r->pfn, r->pfn_data, fmt == NULL ? \"null\" : fmt, ap);\n  mg_xprintf(r->pfn, r->pfn_data, \"}}\");\n}\n\nvoid mg_rpc_err(struct mg_rpc_req *r, int code, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_rpc_verr(r, code, fmt, &ap);\n  va_end(ap);\n}\n\nstatic size_t print_methods(mg_pfn_t pfn, void *pfn_data, va_list *ap) {\n  struct mg_rpc *h, **head = (struct mg_rpc **) va_arg(*ap, void **);\n  size_t len = 0;\n  for (h = *head; h != NULL; h = h->next) {\n    if (h->method.len == 0) continue;  // Ignore response handler\n    len += mg_xprintf(pfn, pfn_data, \"%s%m\", h == *head ? \"\" : \",\",\n                      mg_print_esc, (int) h->method.len, h->method.buf);\n  }\n  return len;\n}\n\nvoid mg_rpc_list(struct mg_rpc_req *r) {\n  mg_rpc_ok(r, \"[%M]\", print_methods, r->head);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sha1.c\"\n#endif\n/* Copyright(c) By Steve Reid <steve@edmweb.com> */\n/* 100% Public Domain */\n\n\n\nunion char64long16 {\n  unsigned char c[64];\n  uint32_t l[16];\n};\n\n#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n\nstatic uint32_t blk0(union char64long16 *block, int i) {\n  if (MG_BIG_ENDIAN) {\n  } else {\n    block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |\n                  (rol(block->l[i], 8) & 0x00FF00FF);\n  }\n  return block->l[i];\n}\n\n/* Avoid redefine warning (ARM /usr/include/sys/ucontext.h define R0~R4) */\n#undef blk\n#undef R0\n#undef R1\n#undef R2\n#undef R3\n#undef R4\n\n#define blk(i)                                                               \\\n  (block->l[i & 15] = rol(block->l[(i + 13) & 15] ^ block->l[(i + 8) & 15] ^ \\\n                              block->l[(i + 2) & 15] ^ block->l[i & 15],     \\\n                          1))\n#define R0(v, w, x, y, z, i)                                          \\\n  z += ((w & (x ^ y)) ^ y) + blk0(block, i) + 0x5A827999 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R1(v, w, x, y, z, i)                                  \\\n  z += ((w & (x ^ y)) ^ y) + blk(i) + 0x5A827999 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R2(v, w, x, y, z, i)                          \\\n  z += (w ^ x ^ y) + blk(i) + 0x6ED9EBA1 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R3(v, w, x, y, z, i)                                        \\\n  z += (((w | x) & y) | (w & x)) + blk(i) + 0x8F1BBCDC + rol(v, 5); \\\n  w = rol(w, 30);\n#define R4(v, w, x, y, z, i)                          \\\n  z += (w ^ x ^ y) + blk(i) + 0xCA62C1D6 + rol(v, 5); \\\n  w = rol(w, 30);\n\nstatic void mg_sha1_transform(uint32_t state[5],\n                              const unsigned char *buffer) {\n  uint32_t a, b, c, d, e;\n  union char64long16 block[1];\n\n  memcpy(block, buffer, 64);\n  a = state[0];\n  b = state[1];\n  c = state[2];\n  d = state[3];\n  e = state[4];\n  R0(a, b, c, d, e, 0);\n  R0(e, a, b, c, d, 1);\n  R0(d, e, a, b, c, 2);\n  R0(c, d, e, a, b, 3);\n  R0(b, c, d, e, a, 4);\n  R0(a, b, c, d, e, 5);\n  R0(e, a, b, c, d, 6);\n  R0(d, e, a, b, c, 7);\n  R0(c, d, e, a, b, 8);\n  R0(b, c, d, e, a, 9);\n  R0(a, b, c, d, e, 10);\n  R0(e, a, b, c, d, 11);\n  R0(d, e, a, b, c, 12);\n  R0(c, d, e, a, b, 13);\n  R0(b, c, d, e, a, 14);\n  R0(a, b, c, d, e, 15);\n  R1(e, a, b, c, d, 16);\n  R1(d, e, a, b, c, 17);\n  R1(c, d, e, a, b, 18);\n  R1(b, c, d, e, a, 19);\n  R2(a, b, c, d, e, 20);\n  R2(e, a, b, c, d, 21);\n  R2(d, e, a, b, c, 22);\n  R2(c, d, e, a, b, 23);\n  R2(b, c, d, e, a, 24);\n  R2(a, b, c, d, e, 25);\n  R2(e, a, b, c, d, 26);\n  R2(d, e, a, b, c, 27);\n  R2(c, d, e, a, b, 28);\n  R2(b, c, d, e, a, 29);\n  R2(a, b, c, d, e, 30);\n  R2(e, a, b, c, d, 31);\n  R2(d, e, a, b, c, 32);\n  R2(c, d, e, a, b, 33);\n  R2(b, c, d, e, a, 34);\n  R2(a, b, c, d, e, 35);\n  R2(e, a, b, c, d, 36);\n  R2(d, e, a, b, c, 37);\n  R2(c, d, e, a, b, 38);\n  R2(b, c, d, e, a, 39);\n  R3(a, b, c, d, e, 40);\n  R3(e, a, b, c, d, 41);\n  R3(d, e, a, b, c, 42);\n  R3(c, d, e, a, b, 43);\n  R3(b, c, d, e, a, 44);\n  R3(a, b, c, d, e, 45);\n  R3(e, a, b, c, d, 46);\n  R3(d, e, a, b, c, 47);\n  R3(c, d, e, a, b, 48);\n  R3(b, c, d, e, a, 49);\n  R3(a, b, c, d, e, 50);\n  R3(e, a, b, c, d, 51);\n  R3(d, e, a, b, c, 52);\n  R3(c, d, e, a, b, 53);\n  R3(b, c, d, e, a, 54);\n  R3(a, b, c, d, e, 55);\n  R3(e, a, b, c, d, 56);\n  R3(d, e, a, b, c, 57);\n  R3(c, d, e, a, b, 58);\n  R3(b, c, d, e, a, 59);\n  R4(a, b, c, d, e, 60);\n  R4(e, a, b, c, d, 61);\n  R4(d, e, a, b, c, 62);\n  R4(c, d, e, a, b, 63);\n  R4(b, c, d, e, a, 64);\n  R4(a, b, c, d, e, 65);\n  R4(e, a, b, c, d, 66);\n  R4(d, e, a, b, c, 67);\n  R4(c, d, e, a, b, 68);\n  R4(b, c, d, e, a, 69);\n  R4(a, b, c, d, e, 70);\n  R4(e, a, b, c, d, 71);\n  R4(d, e, a, b, c, 72);\n  R4(c, d, e, a, b, 73);\n  R4(b, c, d, e, a, 74);\n  R4(a, b, c, d, e, 75);\n  R4(e, a, b, c, d, 76);\n  R4(d, e, a, b, c, 77);\n  R4(c, d, e, a, b, 78);\n  R4(b, c, d, e, a, 79);\n  state[0] += a;\n  state[1] += b;\n  state[2] += c;\n  state[3] += d;\n  state[4] += e;\n  /* Erase working structures. The order of operations is important,\n   * used to ensure that compiler doesn't optimize those out. */\n  memset(block, 0, sizeof(block));\n  a = b = c = d = e = 0;\n  (void) a;\n  (void) b;\n  (void) c;\n  (void) d;\n  (void) e;\n}\n\nvoid mg_sha1_init(mg_sha1_ctx *context) {\n  context->state[0] = 0x67452301;\n  context->state[1] = 0xEFCDAB89;\n  context->state[2] = 0x98BADCFE;\n  context->state[3] = 0x10325476;\n  context->state[4] = 0xC3D2E1F0;\n  context->count[0] = context->count[1] = 0;\n}\n\nvoid mg_sha1_update(mg_sha1_ctx *context, const unsigned char *data,\n                    size_t len) {\n  size_t i, j;\n\n  j = context->count[0];\n  if ((context->count[0] += (uint32_t) len << 3) < j) context->count[1]++;\n  context->count[1] += (uint32_t) (len >> 29);\n  j = (j >> 3) & 63;\n  if ((j + len) > 63) {\n    memcpy(&context->buffer[j], data, (i = 64 - j));\n    mg_sha1_transform(context->state, context->buffer);\n    for (; i + 63 < len; i += 64) {\n      mg_sha1_transform(context->state, &data[i]);\n    }\n    j = 0;\n  } else\n    i = 0;\n  memcpy(&context->buffer[j], &data[i], len - i);\n}\n\nvoid mg_sha1_final(unsigned char digest[20], mg_sha1_ctx *context) {\n  unsigned i;\n  unsigned char finalcount[8], c;\n\n  for (i = 0; i < 8; i++) {\n    finalcount[i] = (unsigned char) ((context->count[(i >= 4 ? 0 : 1)] >>\n                                      ((3 - (i & 3)) * 8)) &\n                                     255);\n  }\n  c = 0200;\n  mg_sha1_update(context, &c, 1);\n  while ((context->count[0] & 504) != 448) {\n    c = 0000;\n    mg_sha1_update(context, &c, 1);\n  }\n  mg_sha1_update(context, finalcount, 8);\n  for (i = 0; i < 20; i++) {\n    digest[i] =\n        (unsigned char) ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);\n  }\n  memset(context, '\\0', sizeof(*context));\n  memset(&finalcount, '\\0', sizeof(finalcount));\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sha256.c\"\n#endif\n// https://github.com/B-Con/crypto-algorithms\n// Author:     Brad Conte (brad AT bradconte.com)\n// Disclaimer: This code is presented \"as is\" without any guarantees.\n// Details:    Defines the API for the corresponding SHA1 implementation.\n// Copyright:  public domain\n\n\n\n#define ror(x, n) (((x) >> (n)) | ((x) << (32 - (n))))\n#define ch(x, y, z) (((x) & (y)) ^ (~(x) & (z)))\n#define maj(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))\n#define ep0(x) (ror(x, 2) ^ ror(x, 13) ^ ror(x, 22))\n#define ep1(x) (ror(x, 6) ^ ror(x, 11) ^ ror(x, 25))\n#define sig0(x) (ror(x, 7) ^ ror(x, 18) ^ ((x) >> 3))\n#define sig1(x) (ror(x, 17) ^ ror(x, 19) ^ ((x) >> 10))\n\nstatic const uint32_t mg_sha256_k[64] = {\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n    0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n    0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n    0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n    0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};\n\nvoid mg_sha256_init(mg_sha256_ctx *ctx) {\n  ctx->len = 0;\n  ctx->bits = 0;\n  ctx->state[0] = 0x6a09e667;\n  ctx->state[1] = 0xbb67ae85;\n  ctx->state[2] = 0x3c6ef372;\n  ctx->state[3] = 0xa54ff53a;\n  ctx->state[4] = 0x510e527f;\n  ctx->state[5] = 0x9b05688c;\n  ctx->state[6] = 0x1f83d9ab;\n  ctx->state[7] = 0x5be0cd19;\n}\n\nstatic void mg_sha256_chunk(mg_sha256_ctx *ctx) {\n  int i, j;\n  uint32_t a, b, c, d, e, f, g, h;\n  uint32_t m[64];\n  for (i = 0, j = 0; i < 16; ++i, j += 4)\n    m[i] = (uint32_t) (((uint32_t) ctx->buffer[j] << 24) |\n                       ((uint32_t) ctx->buffer[j + 1] << 16) |\n                       ((uint32_t) ctx->buffer[j + 2] << 8) |\n                       ((uint32_t) ctx->buffer[j + 3]));\n  for (; i < 64; ++i)\n    m[i] = sig1(m[i - 2]) + m[i - 7] + sig0(m[i - 15]) + m[i - 16];\n\n  a = ctx->state[0];\n  b = ctx->state[1];\n  c = ctx->state[2];\n  d = ctx->state[3];\n  e = ctx->state[4];\n  f = ctx->state[5];\n  g = ctx->state[6];\n  h = ctx->state[7];\n\n  for (i = 0; i < 64; ++i) {\n    uint32_t t1 = h + ep1(e) + ch(e, f, g) + mg_sha256_k[i] + m[i];\n    uint32_t t2 = ep0(a) + maj(a, b, c);\n    h = g;\n    g = f;\n    f = e;\n    e = d + t1;\n    d = c;\n    c = b;\n    b = a;\n    a = t1 + t2;\n  }\n\n  ctx->state[0] += a;\n  ctx->state[1] += b;\n  ctx->state[2] += c;\n  ctx->state[3] += d;\n  ctx->state[4] += e;\n  ctx->state[5] += f;\n  ctx->state[6] += g;\n  ctx->state[7] += h;\n}\n\nvoid mg_sha256_update(mg_sha256_ctx *ctx, const unsigned char *data,\n                      size_t len) {\n  size_t i;\n  for (i = 0; i < len; i++) {\n    ctx->buffer[ctx->len] = data[i];\n    if ((++ctx->len) == 64) {\n      mg_sha256_chunk(ctx);\n      ctx->bits += 512;\n      ctx->len = 0;\n    }\n  }\n}\n\n// TODO: make final reusable (remove side effects)\nvoid mg_sha256_final(unsigned char digest[32], mg_sha256_ctx *ctx) {\n  uint32_t i = ctx->len;\n  if (i < 56) {\n    ctx->buffer[i++] = 0x80;\n    while (i < 56) {\n      ctx->buffer[i++] = 0x00;\n    }\n  } else {\n    ctx->buffer[i++] = 0x80;\n    while (i < 64) {\n      ctx->buffer[i++] = 0x00;\n    }\n    mg_sha256_chunk(ctx);\n    memset(ctx->buffer, 0, 56);\n  }\n\n  ctx->bits += ctx->len * 8;\n  ctx->buffer[63] = (uint8_t) ((ctx->bits) & 0xff);\n  ctx->buffer[62] = (uint8_t) ((ctx->bits >> 8) & 0xff);\n  ctx->buffer[61] = (uint8_t) ((ctx->bits >> 16) & 0xff);\n  ctx->buffer[60] = (uint8_t) ((ctx->bits >> 24) & 0xff);\n  ctx->buffer[59] = (uint8_t) ((ctx->bits >> 32) & 0xff);\n  ctx->buffer[58] = (uint8_t) ((ctx->bits >> 40) & 0xff);\n  ctx->buffer[57] = (uint8_t) ((ctx->bits >> 48) & 0xff);\n  ctx->buffer[56] = (uint8_t) ((ctx->bits >> 56) & 0xff);\n  mg_sha256_chunk(ctx);\n\n  for (i = 0; i < 4; ++i) {\n    digest[i] = (uint8_t) ((ctx->state[0] >> (24 - i * 8)) & 0xff);\n    digest[i + 4] = (uint8_t) ((ctx->state[1] >> (24 - i * 8)) & 0xff);\n    digest[i + 8] = (uint8_t) ((ctx->state[2] >> (24 - i * 8)) & 0xff);\n    digest[i + 12] = (uint8_t) ((ctx->state[3] >> (24 - i * 8)) & 0xff);\n    digest[i + 16] = (uint8_t) ((ctx->state[4] >> (24 - i * 8)) & 0xff);\n    digest[i + 20] = (uint8_t) ((ctx->state[5] >> (24 - i * 8)) & 0xff);\n    digest[i + 24] = (uint8_t) ((ctx->state[6] >> (24 - i * 8)) & 0xff);\n    digest[i + 28] = (uint8_t) ((ctx->state[7] >> (24 - i * 8)) & 0xff);\n  }\n}\n\nvoid mg_hmac_sha256(uint8_t dst[32], uint8_t *key, size_t keysz, uint8_t *data,\n                    size_t datasz) {\n  mg_sha256_ctx ctx;\n  uint8_t k[64] = {0};\n  uint8_t o_pad[64], i_pad[64];\n  unsigned int i;\n  memset(i_pad, 0x36, sizeof(i_pad));\n  memset(o_pad, 0x5c, sizeof(o_pad));\n  if (keysz < 64) {\n    if (keysz > 0) memmove(k, key, keysz);\n  } else {\n    mg_sha256_init(&ctx);\n    mg_sha256_update(&ctx, key, keysz);\n    mg_sha256_final(k, &ctx);\n  }\n  for (i = 0; i < sizeof(k); i++) {\n    i_pad[i] ^= k[i];\n    o_pad[i] ^= k[i];\n  }\n  mg_sha256_init(&ctx);\n  mg_sha256_update(&ctx, i_pad, sizeof(i_pad));\n  mg_sha256_update(&ctx, data, datasz);\n  mg_sha256_final(dst, &ctx);\n  mg_sha256_init(&ctx);\n  mg_sha256_update(&ctx, o_pad, sizeof(o_pad));\n  mg_sha256_update(&ctx, dst, 32);\n  mg_sha256_final(dst, &ctx);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sntp.c\"\n#endif\n\n\n\n\n\n\n#define SNTP_TIME_OFFSET 2208988800U  // (1970 - 1900) in seconds\n#define SNTP_MAX_FRAC 4294967295.0    // 2 ** 32 - 1\n\nstatic uint64_t s_boot_timestamp = 0;  // Updated by SNTP\n\nuint64_t mg_now(void) {\n  return mg_millis() + s_boot_timestamp;\n}\n\nstatic int64_t gettimestamp(const uint32_t *data) {\n  uint32_t sec = mg_ntohl(data[0]), frac = mg_ntohl(data[1]);\n  if (sec) sec -= SNTP_TIME_OFFSET;\n  return ((int64_t) sec) * 1000 + (int64_t) (frac / SNTP_MAX_FRAC * 1000.0);\n}\n\nint64_t mg_sntp_parse(const unsigned char *buf, size_t len) {\n  int64_t epoch_milliseconds = -1;\n  int mode = len > 0 ? buf[0] & 7 : 0;\n  int version = len > 0 ? (buf[0] >> 3) & 7 : 0;\n  if (len < 48) {\n    MG_ERROR((\"%s\", \"corrupt packet\"));\n  } else if (mode != 4 && mode != 5) {\n    MG_ERROR((\"%s\", \"not a server reply\"));\n  } else if (buf[1] == 0) {\n    MG_ERROR((\"%s\", \"server sent a kiss of death\"));\n  } else if (version == 4 || version == 3) {\n    // int64_t ref = gettimestamp((uint32_t *) &buf[16]);\n    int64_t origin_time = gettimestamp((uint32_t *) &buf[24]);\n    int64_t receive_time = gettimestamp((uint32_t *) &buf[32]);\n    int64_t transmit_time = gettimestamp((uint32_t *) &buf[40]);\n    int64_t now = (int64_t) mg_millis();\n    int64_t latency = (now - origin_time) - (transmit_time - receive_time);\n    epoch_milliseconds = transmit_time + latency / 2;\n    s_boot_timestamp = (uint64_t) (epoch_milliseconds - now);\n  } else {\n    MG_ERROR((\"unexpected version: %d\", version));\n  }\n  return epoch_milliseconds;\n}\n\nstatic void sntp_cb(struct mg_connection *c, int ev, void *ev_data) {\n  uint64_t *expiration_time = (uint64_t *) c->data;\n  if (ev == MG_EV_OPEN) {\n    *expiration_time = mg_millis() + 3000;  // Store expiration time in 3s\n  } else if (ev == MG_EV_CONNECT) {\n    mg_sntp_request(c);\n  } else if (ev == MG_EV_READ) {\n    int64_t milliseconds = mg_sntp_parse(c->recv.buf, c->recv.len);\n    if (milliseconds > 0) {\n      s_boot_timestamp = (uint64_t) milliseconds - mg_millis();\n      mg_call(c, MG_EV_SNTP_TIME, (uint64_t *) &milliseconds);\n      MG_DEBUG((\"%lu got time: %lld ms from epoch\", c->id, milliseconds));\n    }\n    // mg_iobuf_del(&c->recv, 0, c->recv.len);  // Free receive buffer\n    c->is_closing = 1;\n  } else if (ev == MG_EV_POLL) {\n    if (mg_millis() > *expiration_time) c->is_closing = 1;\n  } else if (ev == MG_EV_CLOSE) {\n  }\n  (void) ev_data;\n}\n\nvoid mg_sntp_request(struct mg_connection *c) {\n  if (c->is_resolving) {\n    MG_ERROR((\"%lu wait until resolved\", c->id));\n  } else {\n    int64_t now = (int64_t) mg_millis();  // Use int64_t, for vc98\n    uint8_t buf[48] = {0};\n    uint32_t *t = (uint32_t *) &buf[40];\n    double frac = ((double) (now % 1000)) / 1000.0 * SNTP_MAX_FRAC;\n    buf[0] = (0 << 6) | (4 << 3) | 3;\n    t[0] = mg_htonl((uint32_t) (now / 1000) + SNTP_TIME_OFFSET);\n    t[1] = mg_htonl((uint32_t) frac);\n    mg_send(c, buf, sizeof(buf));\n  }\n}\n\nstruct mg_connection *mg_sntp_connect(struct mg_mgr *mgr, const char *url,\n                                      mg_event_handler_t fn, void *fnd) {\n  struct mg_connection *c = NULL;\n  if (url == NULL) url = \"udp://time.google.com:123\";\n  if ((c = mg_connect(mgr, url, fn, fnd)) != NULL) {\n    c->pfn = sntp_cb;\n    sntp_cb(c, MG_EV_OPEN, (void *) url);\n  }\n  return c;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sock.c\"\n#endif\n\n\n\n\n\n\n\n\n\n\n\n#if MG_ENABLE_SOCKET\n\n#ifndef closesocket\n#define closesocket(x) close(x)\n#endif\n\n#define FD(c_) ((MG_SOCKET_TYPE) (size_t) (c_)->fd)\n#define S2PTR(s_) ((void *) (size_t) (s_))\n\n#ifndef MSG_NONBLOCKING\n#define MSG_NONBLOCKING 0\n#endif\n\n#ifndef AF_INET6\n#define AF_INET6 10\n#endif\n\n#ifndef MG_SOCK_ERR\n#define MG_SOCK_ERR(errcode) ((errcode) < 0 ? errno : 0)\n#endif\n\n#ifndef MG_SOCK_INTR\n#define MG_SOCK_INTR(fd) (fd == MG_INVALID_SOCKET && MG_SOCK_ERR(-1) == EINTR)\n#endif\n\n#ifndef MG_SOCK_PENDING\n#define MG_SOCK_PENDING(errcode) \\\n  (((errcode) < 0) && (errno == EINPROGRESS || errno == EWOULDBLOCK))\n#endif\n\n#ifndef MG_SOCK_RESET\n#define MG_SOCK_RESET(errcode) \\\n  (((errcode) < 0) && (errno == EPIPE || errno == ECONNRESET))\n#endif\n\nunion usa {\n  struct sockaddr sa;\n  struct sockaddr_in sin;\n#if MG_ENABLE_IPV6\n  struct sockaddr_in6 sin6;\n#endif\n};\n\nstatic socklen_t tousa(struct mg_addr *a, union usa *usa) {\n  socklen_t len = sizeof(usa->sin);\n  memset(usa, 0, sizeof(*usa));\n  usa->sin.sin_family = AF_INET;\n  usa->sin.sin_port = a->port;\n  memcpy(&usa->sin.sin_addr, a->ip, sizeof(uint32_t));\n#if MG_ENABLE_IPV6\n  if (a->is_ip6) {\n    usa->sin.sin_family = AF_INET6;\n    usa->sin6.sin6_port = a->port;\n    usa->sin6.sin6_scope_id = a->scope_id;\n    memcpy(&usa->sin6.sin6_addr, a->ip, sizeof(a->ip));\n    len = sizeof(usa->sin6);\n  }\n#endif\n  return len;\n}\n\nstatic void tomgaddr(union usa *usa, struct mg_addr *a, bool is_ip6) {\n  a->is_ip6 = is_ip6;\n  a->port = usa->sin.sin_port;\n  memcpy(&a->ip, &usa->sin.sin_addr, sizeof(uint32_t));\n#if MG_ENABLE_IPV6\n  if (is_ip6) {\n    memcpy(a->ip, &usa->sin6.sin6_addr, sizeof(a->ip));\n    a->port = usa->sin6.sin6_port;\n    a->scope_id = (uint8_t) usa->sin6.sin6_scope_id;\n  }\n#endif\n}\n\nstatic void setlocaddr(MG_SOCKET_TYPE fd, struct mg_addr *addr) {\n  union usa usa;\n  socklen_t n = sizeof(usa);\n  if (getsockname(fd, &usa.sa, &n) == 0) {\n    tomgaddr(&usa, addr, n != sizeof(usa.sin));\n  }\n}\n\nstatic void iolog(struct mg_connection *c, char *buf, long n, bool r) {\n  if (n == MG_IO_WAIT) {\n    // Do nothing\n  } else if (n <= 0) {\n    c->is_closing = 1;  // Termination. Don't call mg_error(): #1529\n  } else if (n > 0) {\n    if (c->is_hexdumping) {\n      MG_INFO((\"\\n-- %lu %M %s %M %ld\", c->id, mg_print_ip_port, &c->loc,\n               r ? \"<-\" : \"->\", mg_print_ip_port, &c->rem, n));\n      mg_hexdump(buf, (size_t) n);\n    }\n    if (r) {\n      c->recv.len += (size_t) n;\n      mg_call(c, MG_EV_READ, &n);\n    } else {\n      mg_iobuf_del(&c->send, 0, (size_t) n);\n      // if (c->send.len == 0) mg_iobuf_resize(&c->send, 0);\n      if (c->send.len == 0) {\n        MG_EPOLL_MOD(c, 0);\n      }\n      mg_call(c, MG_EV_WRITE, &n);\n    }\n  }\n}\n\nlong mg_io_send(struct mg_connection *c, const void *buf, size_t len) {\n  long n;\n  if (c->is_udp) {\n    union usa usa;\n    socklen_t slen = tousa(&c->rem, &usa);\n    n = sendto(FD(c), (char *) buf, len, 0, &usa.sa, slen);\n    if (n > 0) setlocaddr(FD(c), &c->loc);\n  } else {\n    n = send(FD(c), (char *) buf, len, MSG_NONBLOCKING);\n  }\n  MG_VERBOSE((\"%lu %ld %d\", c->id, n, MG_SOCK_ERR(n)));\n  if (MG_SOCK_PENDING(n)) return MG_IO_WAIT;\n  if (MG_SOCK_RESET(n)) return MG_IO_RESET;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n\nbool mg_send(struct mg_connection *c, const void *buf, size_t len) {\n  if (c->is_udp) {\n    long n = mg_io_send(c, buf, len);\n    MG_DEBUG((\"%lu %ld %lu:%lu:%lu %ld err %d\", c->id, c->fd, c->send.len,\n              c->recv.len, c->rtls.len, n, MG_SOCK_ERR(n)));\n    iolog(c, (char *) buf, n, false);\n    return n > 0;\n  } else {\n    return mg_iobuf_add(&c->send, c->send.len, buf, len);\n  }\n}\n\nstatic void mg_set_non_blocking_mode(MG_SOCKET_TYPE fd) {\n#if defined(MG_CUSTOM_NONBLOCK)\n  MG_CUSTOM_NONBLOCK(fd);\n#elif MG_ARCH == MG_ARCH_WIN32 && MG_ENABLE_WINSOCK\n  unsigned long on = 1;\n  ioctlsocket(fd, FIONBIO, &on);\n#elif MG_ENABLE_RL\n  unsigned long on = 1;\n  ioctlsocket(fd, FIONBIO, &on);\n#elif MG_ENABLE_FREERTOS_TCP\n  const BaseType_t off = 0;\n  if (setsockopt(fd, 0, FREERTOS_SO_RCVTIMEO, &off, sizeof(off)) != 0) (void) 0;\n  if (setsockopt(fd, 0, FREERTOS_SO_SNDTIMEO, &off, sizeof(off)) != 0) (void) 0;\n#elif MG_ENABLE_LWIP\n  lwip_fcntl(fd, F_SETFL, O_NONBLOCK);\n#elif MG_ARCH == MG_ARCH_AZURERTOS\n  fcntl(fd, F_SETFL, O_NONBLOCK);\n#elif MG_ARCH == MG_ARCH_TIRTOS\n  int val = 0;\n  setsockopt(fd, SOL_SOCKET, SO_BLOCKING, &val, sizeof(val));\n  // SPRU524J section 3.3.3 page 63, SO_SNDLOWAT\n  int sz = sizeof(val);\n  getsockopt(fd, SOL_SOCKET, SO_SNDBUF, &val, &sz);\n  val /= 2;  // set send low-water mark at half send buffer size\n  setsockopt(fd, SOL_SOCKET, SO_SNDLOWAT, &val, sizeof(val));\n#else\n  fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);  // Non-blocking mode\n  fcntl(fd, F_SETFD, FD_CLOEXEC);                          // Set close-on-exec\n#endif\n}\n\nbool mg_open_listener(struct mg_connection *c, const char *url) {\n  MG_SOCKET_TYPE fd = MG_INVALID_SOCKET;\n  bool success = false;\n  c->loc.port = mg_htons(mg_url_port(url));\n  if (!mg_aton(mg_url_host(url), &c->loc)) {\n    MG_ERROR((\"invalid listening URL: %s\", url));\n  } else {\n    union usa usa;\n    socklen_t slen = tousa(&c->loc, &usa);\n    int rc, on = 1, af = c->loc.is_ip6 ? AF_INET6 : AF_INET;\n    int type = strncmp(url, \"udp:\", 4) == 0 ? SOCK_DGRAM : SOCK_STREAM;\n    int proto = type == SOCK_DGRAM ? IPPROTO_UDP : IPPROTO_TCP;\n    (void) on;\n\n    if ((fd = socket(af, type, proto)) == MG_INVALID_SOCKET) {\n      MG_ERROR((\"socket: %d\", MG_SOCK_ERR(-1)));\n#if defined(SO_EXCLUSIVEADDRUSE)\n    } else if ((rc = setsockopt(fd, SOL_SOCKET, SO_EXCLUSIVEADDRUSE,\n                                (char *) &on, sizeof(on))) != 0) {\n      // \"Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE\"\n      MG_ERROR((\"setsockopt(SO_EXCLUSIVEADDRUSE): %d %d\", on, MG_SOCK_ERR(rc)));\n#elif defined(SO_REUSEADDR) && (!defined(LWIP_SOCKET) || SO_REUSE)\n    } else if ((rc = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on,\n                                sizeof(on))) != 0) {\n      // 1. SO_REUSEADDR semantics on UNIX and Windows is different.  On\n      // Windows, SO_REUSEADDR allows to bind a socket to a port without error\n      // even if the port is already open by another program. This is not the\n      // behavior SO_REUSEADDR was designed for, and leads to hard-to-track\n      // failure scenarios.\n      //\n      // 2. For LWIP, SO_REUSEADDR should be explicitly enabled by defining\n      // SO_REUSE = 1 in lwipopts.h, otherwise the code below will compile but\n      // won't work! (setsockopt will return EINVAL)\n      MG_ERROR((\"setsockopt(SO_REUSEADDR): %d\", MG_SOCK_ERR(rc)));\n#endif\n#if MG_IPV6_V6ONLY\n      // Bind only to the V6 address, not V4 address on this port\n    } else if (c->loc.is_ip6 &&\n               (rc = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &on,\n                                sizeof(on))) != 0) {\n      // See #2089. Allow to bind v4 and v6 sockets on the same port\n      MG_ERROR((\"setsockopt(IPV6_V6ONLY): %d\", MG_SOCK_ERR(rc)));\n#endif\n    } else if ((rc = bind(fd, &usa.sa, slen)) != 0) {\n      MG_ERROR((\"bind: %d\", MG_SOCK_ERR(rc)));\n    } else if ((type == SOCK_STREAM &&\n                (rc = listen(fd, MG_SOCK_LISTEN_BACKLOG_SIZE)) != 0)) {\n      // NOTE(lsm): FreeRTOS uses backlog value as a connection limit\n      // In case port was set to 0, get the real port number\n      MG_ERROR((\"listen: %d\", MG_SOCK_ERR(rc)));\n    } else {\n      setlocaddr(fd, &c->loc);\n      mg_set_non_blocking_mode(fd);\n      c->fd = S2PTR(fd);\n      MG_EPOLL_ADD(c);\n      success = true;\n    }\n  }\n  if (success == false && fd != MG_INVALID_SOCKET) closesocket(fd);\n  return success;\n}\n\nstatic long recv_raw(struct mg_connection *c, void *buf, size_t len) {\n  long n = 0;\n  if (c->is_udp) {\n    union usa usa;\n    socklen_t slen = tousa(&c->rem, &usa);\n    n = recvfrom(FD(c), (char *) buf, len, 0, &usa.sa, &slen);\n    if (n > 0) tomgaddr(&usa, &c->rem, slen != sizeof(usa.sin));\n  } else {\n    n = recv(FD(c), (char *) buf, len, MSG_NONBLOCKING);\n  }\n  MG_VERBOSE((\"%lu %ld %d\", c->id, n, MG_SOCK_ERR(n)));\n  if (MG_SOCK_PENDING(n)) return MG_IO_WAIT;\n  if (MG_SOCK_RESET(n)) return MG_IO_RESET;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n\nstatic bool ioalloc(struct mg_connection *c, struct mg_iobuf *io) {\n  bool res = false;\n  if (io->len >= MG_MAX_RECV_SIZE) {\n    mg_error(c, \"MG_MAX_RECV_SIZE\");\n  } else if (io->size <= io->len &&\n             !mg_iobuf_resize(io, io->size + MG_IO_SIZE)) {\n    mg_error(c, \"OOM\");\n  } else {\n    res = true;\n  }\n  return res;\n}\n\n// NOTE(lsm): do only one iteration of reads, cause some systems\n// (e.g. FreeRTOS stack) return 0 instead of -1/EWOULDBLOCK when no data\nstatic void read_conn(struct mg_connection *c) {\n  if (ioalloc(c, &c->recv)) {\n    char *buf = (char *) &c->recv.buf[c->recv.len];\n    size_t len = c->recv.size - c->recv.len;\n    long n = -1;\n    if (c->is_tls) {\n      // Do not read to the raw TLS buffer if it already has enough.\n      // This is to prevent overflowing c->rtls if our reads are slow\n      long m;\n      if (c->rtls.len < 16 * 1024 + 40) {  // TLS record, header, MAC, padding\n        if (!ioalloc(c, &c->rtls)) return;\n        n = recv_raw(c, (char *) &c->rtls.buf[c->rtls.len],\n                     c->rtls.size - c->rtls.len);\n        if (n > 0) c->rtls.len += (size_t) n;\n      }\n      // there can still be > 16K from last iteration, always mg_tls_recv()\n      m = c->is_tls_hs ? (long) MG_IO_WAIT : mg_tls_recv(c, buf, len);\n      if (n == MG_IO_ERR) {\n        if (c->rtls.len == 0 || m < 0) {\n          // Close only when we have fully drained both rtls and TLS buffers\n          c->is_closing = 1;  // or there's nothing we can do about it.\n          m = MG_IO_ERR;\n        } else { // see #2885\n          // TLS buffer is capped to max record size, even though, there can\n          // be more than one record, give TLS a chance to process them.\n        }\n      } else if (c->is_tls_hs) {\n        mg_tls_handshake(c);\n      }\n      n = m;\n    } else {\n      n = recv_raw(c, buf, len);\n    }\n    MG_DEBUG((\"%lu %ld %lu:%lu:%lu %ld err %d\", c->id, c->fd, c->send.len,\n              c->recv.len, c->rtls.len, n, MG_SOCK_ERR(n)));\n    iolog(c, buf, n, true);\n  }\n}\n\nstatic void write_conn(struct mg_connection *c) {\n  char *buf = (char *) c->send.buf;\n  size_t len = c->send.len;\n  long n = c->is_tls ? mg_tls_send(c, buf, len) : mg_io_send(c, buf, len);\n  MG_DEBUG((\"%lu %ld snd %ld/%ld rcv %ld/%ld n=%ld err=%d\", c->id, c->fd,\n            (long) c->send.len, (long) c->send.size, (long) c->recv.len,\n            (long) c->recv.size, n, MG_SOCK_ERR(n)));\n  iolog(c, buf, n, false);\n}\n\nstatic void close_conn(struct mg_connection *c) {\n  if (FD(c) != MG_INVALID_SOCKET) {\n#if MG_ENABLE_EPOLL\n    epoll_ctl(c->mgr->epoll_fd, EPOLL_CTL_DEL, FD(c), NULL);\n#endif\n    closesocket(FD(c));\n#if MG_ENABLE_FREERTOS_TCP\n    FreeRTOS_FD_CLR(c->fd, c->mgr->ss, eSELECT_ALL);\n#endif\n  }\n  mg_close_conn(c);\n}\n\nstatic void connect_conn(struct mg_connection *c) {\n  union usa usa;\n  socklen_t n = sizeof(usa);\n  // Use getpeername() to test whether we have connected\n  if (getpeername(FD(c), &usa.sa, &n) == 0) {\n    c->is_connecting = 0;\n    setlocaddr(FD(c), &c->loc);\n    mg_call(c, MG_EV_CONNECT, NULL);\n    MG_EPOLL_MOD(c, 0);\n    if (c->is_tls_hs) mg_tls_handshake(c);\n  } else {\n    mg_error(c, \"socket error\");\n  }\n}\n\nstatic void setsockopts(struct mg_connection *c) {\n#if MG_ENABLE_FREERTOS_TCP || MG_ARCH == MG_ARCH_AZURERTOS || \\\n    MG_ARCH == MG_ARCH_TIRTOS\n  (void) c;\n#else\n  int on = 1;\n#if !defined(SOL_TCP)\n#define SOL_TCP IPPROTO_TCP\n#endif\n  if (setsockopt(FD(c), SOL_TCP, TCP_NODELAY, (char *) &on, sizeof(on)) != 0)\n    (void) 0;\n  if (setsockopt(FD(c), SOL_SOCKET, SO_KEEPALIVE, (char *) &on, sizeof(on)) !=\n      0)\n    (void) 0;\n#endif\n}\n\nvoid mg_connect_resolved(struct mg_connection *c) {\n  int type = c->is_udp ? SOCK_DGRAM : SOCK_STREAM;\n  int proto = type == SOCK_DGRAM ? IPPROTO_UDP : IPPROTO_TCP;\n  int rc, af = c->rem.is_ip6 ? AF_INET6 : AF_INET;  // c->rem has resolved IP\n  c->fd = S2PTR(socket(af, type, proto));           // Create outbound socket\n  c->is_resolving = 0;                              // Clear resolving flag\n  if (FD(c) == MG_INVALID_SOCKET) {\n    mg_error(c, \"socket(): %d\", MG_SOCK_ERR(-1));\n  } else if (c->is_udp) {\n    MG_EPOLL_ADD(c);\n#if MG_ARCH == MG_ARCH_TIRTOS\n    union usa usa;  // TI-RTOS NDK requires binding to receive on UDP sockets\n    socklen_t slen = tousa(&c->loc, &usa);\n    if ((rc = bind(c->fd, &usa.sa, slen)) != 0)\n      MG_ERROR((\"bind: %d\", MG_SOCK_ERR(rc)));\n#endif\n    setlocaddr(FD(c), &c->loc);\n    mg_call(c, MG_EV_RESOLVE, NULL);\n    mg_call(c, MG_EV_CONNECT, NULL);\n  } else {\n    union usa usa;\n    socklen_t slen = tousa(&c->rem, &usa);\n    mg_set_non_blocking_mode(FD(c));\n    setsockopts(c);\n    MG_EPOLL_ADD(c);\n    mg_call(c, MG_EV_RESOLVE, NULL);\n    rc = connect(FD(c), &usa.sa, slen);  // Attempt to connect\n    if (rc == 0) {                       // Success\n      setlocaddr(FD(c), &c->loc);\n      mg_call(c, MG_EV_CONNECT, NULL);  // Send MG_EV_CONNECT to the user\n    } else if (MG_SOCK_PENDING(rc)) {   // Need to wait for TCP handshake\n      MG_DEBUG((\"%lu %ld -> %M pend\", c->id, c->fd, mg_print_ip_port, &c->rem));\n      c->is_connecting = 1;\n    } else {\n      mg_error(c, \"connect: %d\", MG_SOCK_ERR(rc));\n    }\n  }\n}\n\nstatic MG_SOCKET_TYPE raccept(MG_SOCKET_TYPE sock, union usa *usa,\n                              socklen_t *len) {\n  MG_SOCKET_TYPE fd = MG_INVALID_SOCKET;\n  do {\n    memset(usa, 0, sizeof(*usa));\n    fd = accept(sock, &usa->sa, len);\n  } while (MG_SOCK_INTR(fd));\n  return fd;\n}\n\nstatic void accept_conn(struct mg_mgr *mgr, struct mg_connection *lsn) {\n  struct mg_connection *c = NULL;\n  union usa usa;\n  socklen_t sa_len = sizeof(usa);\n  MG_SOCKET_TYPE fd = raccept(FD(lsn), &usa, &sa_len);\n  if (fd == MG_INVALID_SOCKET) {\n#if MG_ARCH == MG_ARCH_AZURERTOS || defined(__ECOS)\n    // AzureRTOS, in non-block socket mode can mark listening socket readable\n    // even it is not. See comment for 'select' func implementation in\n    // nx_bsd.c That's not an error, just should try later\n    if (errno != EAGAIN)\n#endif\n      MG_ERROR((\"%lu accept failed, errno %d\", lsn->id, MG_SOCK_ERR(-1)));\n#if (MG_ARCH != MG_ARCH_WIN32) && !MG_ENABLE_FREERTOS_TCP && \\\n    (MG_ARCH != MG_ARCH_TIRTOS) && !MG_ENABLE_POLL && !MG_ENABLE_EPOLL\n  } else if ((long) fd >= FD_SETSIZE) {\n    MG_ERROR((\"%ld > %ld\", (long) fd, (long) FD_SETSIZE));\n    closesocket(fd);\n#endif\n  } else if ((c = mg_alloc_conn(mgr)) == NULL) {\n    MG_ERROR((\"%lu OOM\", lsn->id));\n    closesocket(fd);\n  } else {\n    tomgaddr(&usa, &c->rem, sa_len != sizeof(usa.sin));\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n    c->fd = S2PTR(fd);\n    MG_EPOLL_ADD(c);\n    mg_set_non_blocking_mode(FD(c));\n    setsockopts(c);\n    c->is_accepted = 1;\n    c->is_hexdumping = lsn->is_hexdumping;\n    c->loc = lsn->loc;\n    c->pfn = lsn->pfn;\n    c->pfn_data = lsn->pfn_data;\n    c->fn = lsn->fn;\n    c->fn_data = lsn->fn_data;\n    MG_DEBUG((\"%lu %ld accepted %M -> %M\", c->id, c->fd, mg_print_ip_port,\n              &c->rem, mg_print_ip_port, &c->loc));\n    mg_call(c, MG_EV_OPEN, NULL);\n    mg_call(c, MG_EV_ACCEPT, NULL);\n  }\n}\n\nstatic bool can_read(const struct mg_connection *c) {\n  return c->is_full == false;\n}\n\nstatic bool can_write(const struct mg_connection *c) {\n  return c->is_connecting || (c->send.len > 0 && c->is_tls_hs == 0);\n}\n\nstatic bool skip_iotest(const struct mg_connection *c) {\n  return (c->is_closing || c->is_resolving || FD(c) == MG_INVALID_SOCKET) ||\n         (can_read(c) == false && can_write(c) == false);\n}\n\nstatic void mg_iotest(struct mg_mgr *mgr, int ms) {\n#if MG_ENABLE_FREERTOS_TCP\n  struct mg_connection *c;\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    c->is_readable = c->is_writable = 0;\n    if (skip_iotest(c)) continue;\n    if (can_read(c))\n      FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_READ | eSELECT_EXCEPT);\n    if (can_write(c)) FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_WRITE);\n    if (c->is_closing) ms = 1;\n  }\n  FreeRTOS_select(mgr->ss, pdMS_TO_TICKS(ms));\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    EventBits_t bits = FreeRTOS_FD_ISSET(c->fd, mgr->ss);\n    c->is_readable = bits & (eSELECT_READ | eSELECT_EXCEPT) ? 1U : 0;\n    c->is_writable = bits & eSELECT_WRITE ? 1U : 0;\n    if (c->fd != MG_INVALID_SOCKET)\n      FreeRTOS_FD_CLR(c->fd, mgr->ss,\n                      eSELECT_READ | eSELECT_EXCEPT | eSELECT_WRITE);\n  }\n#elif MG_ENABLE_EPOLL\n  size_t max = 1;\n  for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {\n    c->is_readable = c->is_writable = 0;\n    if (c->rtls.len > 0 || mg_tls_pending(c) > 0) ms = 1, c->is_readable = 1;\n    if (can_write(c)) MG_EPOLL_MOD(c, 1);\n    if (c->is_closing) ms = 1;\n    max++;\n  }\n  struct epoll_event *evs = (struct epoll_event *) alloca(max * sizeof(evs[0]));\n  int n = epoll_wait(mgr->epoll_fd, evs, (int) max, ms);\n  for (int i = 0; i < n; i++) {\n    struct mg_connection *c = (struct mg_connection *) evs[i].data.ptr;\n    if (evs[i].events & EPOLLERR) {\n      mg_error(c, \"socket error\");\n    } else if (c->is_readable == 0) {\n      bool rd = evs[i].events & (EPOLLIN | EPOLLHUP);\n      bool wr = evs[i].events & EPOLLOUT;\n      c->is_readable = can_read(c) && rd ? 1U : 0;\n      c->is_writable = can_write(c) && wr ? 1U : 0;\n      if (c->rtls.len > 0 || mg_tls_pending(c) > 0) c->is_readable = 1;\n    }\n  }\n  (void) skip_iotest;\n#elif MG_ENABLE_POLL\n  nfds_t n = 0;\n  for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) n++;\n  struct pollfd *fds = (struct pollfd *) alloca(n * sizeof(fds[0]));\n  memset(fds, 0, n * sizeof(fds[0]));\n  n = 0;\n  for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {\n    c->is_readable = c->is_writable = 0;\n    if (c->is_closing) ms = 1;\n    if (skip_iotest(c)) {\n      // Socket not valid, ignore\n    } else {\n      // Don't wait if TLS is ready\n      if (c->rtls.len > 0 || mg_tls_pending(c) > 0) ms = 1;\n      fds[n].fd = FD(c);\n      if (can_read(c)) fds[n].events |= POLLIN;\n      if (can_write(c)) fds[n].events |= POLLOUT;\n      n++;\n    }\n  }\n\n  // MG_INFO((\"poll n=%d ms=%d\", (int) n, ms));\n  if (poll(fds, n, ms) < 0) {\n#if MG_ARCH == MG_ARCH_WIN32\n    if (n == 0) Sleep(ms);  // On Windows, poll fails if no sockets\n#endif\n    memset(fds, 0, n * sizeof(fds[0]));\n  }\n  n = 0;\n  for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {\n    if (skip_iotest(c)) {\n      // Socket not valid, ignore\n    } else {\n      if (fds[n].revents & POLLERR) {\n        mg_error(c, \"socket error\");\n      } else {\n        c->is_readable =\n            (unsigned) (fds[n].revents & (POLLIN | POLLHUP) ? 1 : 0);\n        c->is_writable = (unsigned) (fds[n].revents & POLLOUT ? 1 : 0);\n        if (c->rtls.len > 0 || mg_tls_pending(c) > 0) c->is_readable = 1;\n      }\n      n++;\n    }\n  }\n#else\n  struct timeval tv = {ms / 1000, (ms % 1000) * 1000}, tv_zero = {0, 0}, *tvp;\n  struct mg_connection *c;\n  fd_set rset, wset, eset;\n  MG_SOCKET_TYPE maxfd = 0;\n  int rc;\n\n  FD_ZERO(&rset);\n  FD_ZERO(&wset);\n  FD_ZERO(&eset);\n  tvp = ms < 0 ? NULL : &tv;\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    c->is_readable = c->is_writable = 0;\n    if (skip_iotest(c)) continue;\n    FD_SET(FD(c), &eset);\n    if (can_read(c)) FD_SET(FD(c), &rset);\n    if (can_write(c)) FD_SET(FD(c), &wset);\n    if (c->rtls.len > 0 || mg_tls_pending(c) > 0) tvp = &tv_zero;\n    if (FD(c) > maxfd) maxfd = FD(c);\n    if (c->is_closing) tvp = &tv_zero;\n  }\n\n  if ((rc = select((int) maxfd + 1, &rset, &wset, &eset, tvp)) < 0) {\n#if MG_ARCH == MG_ARCH_WIN32\n    if (maxfd == 0) Sleep(ms);  // On Windows, select fails if no sockets\n#else\n    MG_ERROR((\"select: %d %d\", rc, MG_SOCK_ERR(rc)));\n#endif\n    FD_ZERO(&rset);\n    FD_ZERO(&wset);\n    FD_ZERO(&eset);\n  }\n\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    if (FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &eset)) {\n      mg_error(c, \"socket error\");\n    } else {\n      c->is_readable = FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &rset);\n      c->is_writable = FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &wset);\n      if (c->rtls.len > 0 || mg_tls_pending(c) > 0) c->is_readable = 1;\n    }\n  }\n#endif\n}\n\nstatic bool mg_socketpair(MG_SOCKET_TYPE sp[2], union usa usa[2]) {\n  socklen_t n = sizeof(usa[0].sin);\n  bool success = false;\n\n  sp[0] = sp[1] = MG_INVALID_SOCKET;\n  (void) memset(&usa[0], 0, sizeof(usa[0]));\n  usa[0].sin.sin_family = AF_INET;\n  *(uint32_t *) &usa->sin.sin_addr = mg_htonl(0x7f000001U);  // 127.0.0.1\n  usa[1] = usa[0];\n\n  if ((sp[0] = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) != MG_INVALID_SOCKET &&\n      (sp[1] = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) != MG_INVALID_SOCKET &&\n      bind(sp[0], &usa[0].sa, n) == 0 &&          //\n      bind(sp[1], &usa[1].sa, n) == 0 &&          //\n      getsockname(sp[0], &usa[0].sa, &n) == 0 &&  //\n      getsockname(sp[1], &usa[1].sa, &n) == 0 &&  //\n      connect(sp[0], &usa[1].sa, n) == 0 &&       //\n      connect(sp[1], &usa[0].sa, n) == 0) {       //\n    success = true;\n  }\n  if (!success) {\n    if (sp[0] != MG_INVALID_SOCKET) closesocket(sp[0]);\n    if (sp[1] != MG_INVALID_SOCKET) closesocket(sp[1]);\n    sp[0] = sp[1] = MG_INVALID_SOCKET;\n  }\n  return success;\n}\n\n// mg_wakeup() event handler\nstatic void wufn(struct mg_connection *c, int ev, void *ev_data) {\n  if (ev == MG_EV_READ) {\n    unsigned long *id = (unsigned long *) c->recv.buf;\n    // MG_INFO((\"Got data\"));\n    // mg_hexdump(c->recv.buf, c->recv.len);\n    if (c->recv.len >= sizeof(*id)) {\n      struct mg_connection *t;\n      for (t = c->mgr->conns; t != NULL; t = t->next) {\n        if (t->id == *id) {\n          struct mg_str data = mg_str_n((char *) c->recv.buf + sizeof(*id),\n                                        c->recv.len - sizeof(*id));\n          mg_call(t, MG_EV_WAKEUP, &data);\n        }\n      }\n    }\n    c->recv.len = 0;  // Consume received data\n  } else if (ev == MG_EV_CLOSE) {\n    closesocket(c->mgr->pipe);         // When we're closing, close the other\n    c->mgr->pipe = MG_INVALID_SOCKET;  // side of the socketpair, too\n  }\n  (void) ev_data;\n}\n\nbool mg_wakeup_init(struct mg_mgr *mgr) {\n  bool ok = false;\n  if (mgr->pipe == MG_INVALID_SOCKET) {\n    union usa usa[2];\n    MG_SOCKET_TYPE sp[2] = {MG_INVALID_SOCKET, MG_INVALID_SOCKET};\n    struct mg_connection *c = NULL;\n    if (!mg_socketpair(sp, usa)) {\n      MG_ERROR((\"Cannot create socket pair\"));\n    } else if ((c = mg_wrapfd(mgr, (int) sp[1], wufn, NULL)) == NULL) {\n      closesocket(sp[0]);\n      closesocket(sp[1]);\n      sp[0] = sp[1] = MG_INVALID_SOCKET;\n    } else {\n      tomgaddr(&usa[0], &c->rem, false);\n      MG_DEBUG((\"%lu %p pipe %lu\", c->id, c->fd, (unsigned long) sp[0]));\n      mgr->pipe = sp[0];\n      ok = true;\n    }\n  }\n  return ok;\n}\n\nbool mg_wakeup(struct mg_mgr *mgr, unsigned long conn_id, const void *buf,\n               size_t len) {\n  if (mgr->pipe != MG_INVALID_SOCKET && conn_id > 0) {\n    char *extended_buf = (char *) alloca(len + sizeof(conn_id));\n    memcpy(extended_buf, &conn_id, sizeof(conn_id));\n    memcpy(extended_buf + sizeof(conn_id), buf, len);\n    send(mgr->pipe, extended_buf, len + sizeof(conn_id), MSG_NONBLOCKING);\n    return true;\n  }\n  return false;\n}\n\nvoid mg_mgr_poll(struct mg_mgr *mgr, int ms) {\n  struct mg_connection *c, *tmp;\n  uint64_t now;\n\n  mg_iotest(mgr, ms);\n  now = mg_millis();\n  mg_timer_poll(&mgr->timers, now);\n\n  for (c = mgr->conns; c != NULL; c = tmp) {\n    bool is_resp = c->is_resp;\n    tmp = c->next;\n    mg_call(c, MG_EV_POLL, &now);\n    if (is_resp && !c->is_resp) {\n      long n = 0;\n      mg_call(c, MG_EV_READ, &n);\n    }\n    MG_VERBOSE((\"%lu %c%c %c%c%c%c%c %lu %lu\", c->id,\n                c->is_readable ? 'r' : '-', c->is_writable ? 'w' : '-',\n                c->is_tls ? 'T' : 't', c->is_connecting ? 'C' : 'c',\n                c->is_tls_hs ? 'H' : 'h', c->is_resolving ? 'R' : 'r',\n                c->is_closing ? 'C' : 'c', mg_tls_pending(c), c->rtls.len));\n    if (c->is_resolving || c->is_closing) {\n      // Do nothing\n    } else if (c->is_listening && c->is_udp == 0) {\n      if (c->is_readable) accept_conn(mgr, c);\n    } else if (c->is_connecting) {\n      if (c->is_readable || c->is_writable) connect_conn(c);\n      //} else if (c->is_tls_hs) {\n      //  if ((c->is_readable || c->is_writable)) mg_tls_handshake(c);\n    } else {\n      if (c->is_readable) read_conn(c);\n      if (c->is_writable) write_conn(c);\n    }\n\n    if (c->is_draining && c->send.len == 0) c->is_closing = 1;\n    if (c->is_closing) close_conn(c);\n  }\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ssi.c\"\n#endif\n\n\n\n\n#ifndef MG_MAX_SSI_DEPTH\n#define MG_MAX_SSI_DEPTH 5\n#endif\n\n#ifndef MG_SSI_BUFSIZ\n#define MG_SSI_BUFSIZ 1024\n#endif\n\n#if MG_ENABLE_SSI\nstatic char *mg_ssi(const char *path, const char *root, int depth) {\n  struct mg_iobuf b = {NULL, 0, 0, MG_IO_SIZE};\n  FILE *fp = fopen(path, \"rb\");\n  if (fp != NULL) {\n    char buf[MG_SSI_BUFSIZ], arg[sizeof(buf)];\n    int ch, intag = 0;\n    size_t len = 0;\n    buf[0] = arg[0] = '\\0';\n    while ((ch = fgetc(fp)) != EOF) {\n      if (intag && ch == '>' && buf[len - 1] == '-' && buf[len - 2] == '-') {\n        buf[len++] = (char) (ch & 0xff);\n        buf[len] = '\\0';\n        if (sscanf(buf, \"<!--#include file=\\\"%[^\\\"]\", arg) > 0) {\n          char tmp[MG_PATH_MAX + MG_SSI_BUFSIZ + 10],\n              *p = (char *) path + strlen(path), *data;\n          while (p > path && p[-1] != MG_DIRSEP && p[-1] != '/') p--;\n          mg_snprintf(tmp, sizeof(tmp), \"%.*s%s\", (int) (p - path), path, arg);\n          if (depth < MG_MAX_SSI_DEPTH &&\n              (data = mg_ssi(tmp, root, depth + 1)) != NULL) {\n            mg_iobuf_add(&b, b.len, data, strlen(data));\n            free(data);\n          } else {\n            MG_ERROR((\"%s: file=%s error or too deep\", path, arg));\n          }\n        } else if (sscanf(buf, \"<!--#include virtual=\\\"%[^\\\"]\", arg) > 0) {\n          char tmp[MG_PATH_MAX + MG_SSI_BUFSIZ + 10], *data;\n          mg_snprintf(tmp, sizeof(tmp), \"%s%s\", root, arg);\n          if (depth < MG_MAX_SSI_DEPTH &&\n              (data = mg_ssi(tmp, root, depth + 1)) != NULL) {\n            mg_iobuf_add(&b, b.len, data, strlen(data));\n            free(data);\n          } else {\n            MG_ERROR((\"%s: virtual=%s error or too deep\", path, arg));\n          }\n        } else {\n          // Unknown SSI tag\n          MG_ERROR((\"Unknown SSI tag: %.*s\", (int) len, buf));\n          mg_iobuf_add(&b, b.len, buf, len);\n        }\n        intag = 0;\n        len = 0;\n      } else if (ch == '<') {\n        intag = 1;\n        if (len > 0) mg_iobuf_add(&b, b.len, buf, len);\n        len = 0;\n        buf[len++] = (char) (ch & 0xff);\n      } else if (intag) {\n        if (len == 5 && strncmp(buf, \"<!--#\", 5) != 0) {\n          intag = 0;\n        } else if (len >= sizeof(buf) - 2) {\n          MG_ERROR((\"%s: SSI tag is too large\", path));\n          len = 0;\n        }\n        buf[len++] = (char) (ch & 0xff);\n      } else {\n        buf[len++] = (char) (ch & 0xff);\n        if (len >= sizeof(buf)) {\n          mg_iobuf_add(&b, b.len, buf, len);\n          len = 0;\n        }\n      }\n    }\n    if (len > 0) mg_iobuf_add(&b, b.len, buf, len);\n    if (b.len > 0) mg_iobuf_add(&b, b.len, \"\", 1);  // nul-terminate\n    fclose(fp);\n  }\n  (void) depth;\n  (void) root;\n  return (char *) b.buf;\n}\n\nvoid mg_http_serve_ssi(struct mg_connection *c, const char *root,\n                       const char *fullpath) {\n  const char *headers = \"Content-Type: text/html; charset=utf-8\\r\\n\";\n  char *data = mg_ssi(fullpath, root, 0);\n  mg_http_reply(c, 200, headers, \"%s\", data == NULL ? \"\" : data);\n  free(data);\n}\n#else\nvoid mg_http_serve_ssi(struct mg_connection *c, const char *root,\n                       const char *fullpath) {\n  mg_http_reply(c, 501, NULL, \"SSI not enabled\");\n  (void) root, (void) fullpath;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/str.c\"\n#endif\n\n\nstruct mg_str mg_str_s(const char *s) {\n  struct mg_str str = {(char *) s, s == NULL ? 0 : strlen(s)};\n  return str;\n}\n\nstruct mg_str mg_str_n(const char *s, size_t n) {\n  struct mg_str str = {(char *) s, n};\n  return str;\n}\n\nstatic int mg_tolc(char c) {\n  return (c >= 'A' && c <= 'Z') ? c + 'a' - 'A' : c;\n}\n\nint mg_casecmp(const char *s1, const char *s2) {\n  int diff = 0;\n  do {\n    int c = mg_tolc(*s1++), d = mg_tolc(*s2++);\n    diff = c - d;\n  } while (diff == 0 && s1[-1] != '\\0');\n  return diff;\n}\n\nstruct mg_str mg_strdup(const struct mg_str s) {\n  struct mg_str r = {NULL, 0};\n  if (s.len > 0 && s.buf != NULL) {\n    char *sc = (char *) calloc(1, s.len + 1);\n    if (sc != NULL) {\n      memcpy(sc, s.buf, s.len);\n      sc[s.len] = '\\0';\n      r.buf = sc;\n      r.len = s.len;\n    }\n  }\n  return r;\n}\n\nint mg_strcmp(const struct mg_str str1, const struct mg_str str2) {\n  size_t i = 0;\n  while (i < str1.len && i < str2.len) {\n    int c1 = str1.buf[i];\n    int c2 = str2.buf[i];\n    if (c1 < c2) return -1;\n    if (c1 > c2) return 1;\n    i++;\n  }\n  if (i < str1.len) return 1;\n  if (i < str2.len) return -1;\n  return 0;\n}\n\nint mg_strcasecmp(const struct mg_str str1, const struct mg_str str2) {\n  size_t i = 0;\n  while (i < str1.len && i < str2.len) {\n    int c1 = mg_tolc(str1.buf[i]);\n    int c2 = mg_tolc(str2.buf[i]);\n    if (c1 < c2) return -1;\n    if (c1 > c2) return 1;\n    i++;\n  }\n  if (i < str1.len) return 1;\n  if (i < str2.len) return -1;\n  return 0;\n}\n\nbool mg_match(struct mg_str s, struct mg_str p, struct mg_str *caps) {\n  size_t i = 0, j = 0, ni = 0, nj = 0;\n  if (caps) caps->buf = NULL, caps->len = 0;\n  while (i < p.len || j < s.len) {\n    if (i < p.len && j < s.len &&\n        (p.buf[i] == '?' ||\n         (p.buf[i] != '*' && p.buf[i] != '#' && s.buf[j] == p.buf[i]))) {\n      if (caps == NULL) {\n      } else if (p.buf[i] == '?') {\n        caps->buf = &s.buf[j], caps->len = 1;     // Finalize `?` cap\n        caps++, caps->buf = NULL, caps->len = 0;  // Init next cap\n      } else if (caps->buf != NULL && caps->len == 0) {\n        caps->len = (size_t) (&s.buf[j] - caps->buf);  // Finalize current cap\n        caps++, caps->len = 0, caps->buf = NULL;       // Init next cap\n      }\n      i++, j++;\n    } else if (i < p.len && (p.buf[i] == '*' || p.buf[i] == '#')) {\n      if (caps && !caps->buf) caps->len = 0, caps->buf = &s.buf[j];  // Init cap\n      ni = i++, nj = j + 1;\n    } else if (nj > 0 && nj <= s.len && (p.buf[ni] == '#' || s.buf[j] != '/')) {\n      i = ni, j = nj;\n      if (caps && caps->buf == NULL && caps->len == 0) {\n        caps--, caps->len = 0;  // Restart previous cap\n      }\n    } else {\n      return false;\n    }\n  }\n  if (caps && caps->buf && caps->len == 0) {\n    caps->len = (size_t) (&s.buf[j] - caps->buf);\n  }\n  return true;\n}\n\nbool mg_span(struct mg_str s, struct mg_str *a, struct mg_str *b, char sep) {\n  if (s.len == 0 || s.buf == NULL) {\n    return false;  // Empty string, nothing to span - fail\n  } else {\n    size_t len = 0;\n    while (len < s.len && s.buf[len] != sep) len++;  // Find separator\n    if (a) *a = mg_str_n(s.buf, len);                // Init a\n    if (b) *b = mg_str_n(s.buf + len, s.len - len);  // Init b\n    if (b && len < s.len) b->buf++, b->len--;        // Skip separator\n    return true;\n  }\n}\n\nbool mg_str_to_num(struct mg_str str, int base, void *val, size_t val_len) {\n  size_t i = 0, ndigits = 0;\n  uint64_t max = val_len == sizeof(uint8_t)    ? 0xFF\n                 : val_len == sizeof(uint16_t) ? 0xFFFF\n                 : val_len == sizeof(uint32_t) ? 0xFFFFFFFF\n                                               : (uint64_t) ~0;\n  uint64_t result = 0;\n  if (max == (uint64_t) ~0 && val_len != sizeof(uint64_t)) return false;\n  if (base == 0 && str.len >= 2) {\n    if (str.buf[i] == '0') {\n      i++;\n      base = str.buf[i] == 'b' ? 2 : str.buf[i] == 'x' ? 16 : 10;\n      if (base != 10) ++i;\n    } else {\n      base = 10;\n    }\n  }\n  switch (base) {\n    case 2:\n      while (i < str.len && (str.buf[i] == '0' || str.buf[i] == '1')) {\n        uint64_t digit = (uint64_t) (str.buf[i] - '0');\n        if (result > max / 2) return false;  // Overflow\n        result *= 2;\n        if (result > max - digit) return false;  // Overflow\n        result += digit;\n        i++, ndigits++;\n      }\n      break;\n    case 10:\n      while (i < str.len && str.buf[i] >= '0' && str.buf[i] <= '9') {\n        uint64_t digit = (uint64_t) (str.buf[i] - '0');\n        if (result > max / 10) return false;  // Overflow\n        result *= 10;\n        if (result > max - digit) return false;  // Overflow\n        result += digit;\n        i++, ndigits++;\n      }\n      break;\n    case 16:\n      while (i < str.len) {\n        char c = str.buf[i];\n        uint64_t digit = (c >= '0' && c <= '9')   ? (uint64_t) (c - '0')\n                         : (c >= 'A' && c <= 'F') ? (uint64_t) (c - '7')\n                         : (c >= 'a' && c <= 'f') ? (uint64_t) (c - 'W')\n                                                  : (uint64_t) ~0;\n        if (digit == (uint64_t) ~0) break;\n        if (result > max / 16) return false;  // Overflow\n        result *= 16;\n        if (result > max - digit) return false;  // Overflow\n        result += digit;\n        i++, ndigits++;\n      }\n      break;\n    default:\n      return false;\n  }\n  if (ndigits == 0) return false;\n  if (i != str.len) return false;\n  if (val_len == 1) {\n    *((uint8_t *) val) = (uint8_t) result;\n  } else if (val_len == 2) {\n    *((uint16_t *) val) = (uint16_t) result;\n  } else if (val_len == 4) {\n    *((uint32_t *) val) = (uint32_t) result;\n  } else {\n    *((uint64_t *) val) = (uint64_t) result;\n  }\n  return true;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/timer.c\"\n#endif\n\n\n\n#define MG_TIMER_CALLED 4\n\nvoid mg_timer_init(struct mg_timer **head, struct mg_timer *t, uint64_t ms,\n                   unsigned flags, void (*fn)(void *), void *arg) {\n  t->id = 0, t->period_ms = ms, t->expire = 0;\n  t->flags = flags, t->fn = fn, t->arg = arg, t->next = *head;\n  *head = t;\n}\n\nvoid mg_timer_free(struct mg_timer **head, struct mg_timer *t) {\n  while (*head && *head != t) head = &(*head)->next;\n  if (*head) *head = t->next;\n}\n\n// t: expiration time, prd: period, now: current time. Return true if expired\nbool mg_timer_expired(uint64_t *t, uint64_t prd, uint64_t now) {\n  if (now + prd < *t) *t = 0;                    // Time wrapped? Reset timer\n  if (*t == 0) *t = now + prd;                   // Firt poll? Set expiration\n  if (*t > now) return false;                    // Not expired yet, return\n  *t = (now - *t) > prd ? now + prd : *t + prd;  // Next expiration time\n  return true;                                   // Expired, return true\n}\n\nvoid mg_timer_poll(struct mg_timer **head, uint64_t now_ms) {\n  struct mg_timer *t, *tmp;\n  for (t = *head; t != NULL; t = tmp) {\n    bool once = t->expire == 0 && (t->flags & MG_TIMER_RUN_NOW) &&\n                !(t->flags & MG_TIMER_CALLED);  // Handle MG_TIMER_NOW only once\n    bool expired = mg_timer_expired(&t->expire, t->period_ms, now_ms);\n    tmp = t->next;\n    if (!once && !expired) continue;\n    if ((t->flags & MG_TIMER_REPEAT) || !(t->flags & MG_TIMER_CALLED)) {\n      t->fn(t->arg);\n    }\n    t->flags |= MG_TIMER_CALLED;\n  }\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_aes128.c\"\n#endif\n/******************************************************************************\n *\n * THIS SOURCE CODE IS HEREBY PLACED INTO THE PUBLIC DOMAIN FOR THE GOOD OF ALL\n *\n * This is a simple and straightforward implementation of the AES Rijndael\n * 128-bit block cipher designed by Vincent Rijmen and Joan Daemen. The focus\n * of this work was correctness & accuracy.  It is written in 'C' without any\n * particular focus upon optimization or speed. It should be endian (memory\n * byte order) neutral since the few places that care are handled explicitly.\n *\n * This implementation of Rijndael was created by Steven M. Gibson of GRC.com.\n *\n * It is intended for general purpose use, but was written in support of GRC's\n * reference implementation of the SQRL (Secure Quick Reliable Login) client.\n *\n * See:    http://csrc.nist.gov/archive/aes/rijndael/wsdindex.html\n *\n * NO COPYRIGHT IS CLAIMED IN THIS WORK, HOWEVER, NEITHER IS ANY WARRANTY MADE\n * REGARDING ITS FITNESS FOR ANY PARTICULAR PURPOSE. USE IT AT YOUR OWN RISK.\n *\n *******************************************************************************/\n\n/******************************************************************************/\n#define AES_DECRYPTION 1  // whether AES decryption is supported\n/******************************************************************************/\n\n#define MG_ENCRYPT 1  // specify whether we're encrypting\n#define MG_DECRYPT 0  // or decrypting\n\n\n\n\n\n#if MG_TLS == MG_TLS_BUILTIN\n/******************************************************************************\n *  AES_INIT_KEYGEN_TABLES : MUST be called once before any AES use\n ******************************************************************************/\nstatic void aes_init_keygen_tables(void);\n\n/******************************************************************************\n *  AES_SETKEY : called to expand the key for encryption or decryption\n ******************************************************************************/\nstatic int aes_setkey(aes_context *ctx,  // pointer to context\n                      int mode,          // 1 or 0 for Encrypt/Decrypt\n                      const unsigned char *key,  // AES input key\n                      unsigned int keysize);  // size in bytes (must be 16, 24, 32 for\n                                      // 128, 192 or 256-bit keys respectively)\n                                      // returns 0 for success\n\n/******************************************************************************\n *  AES_CIPHER : called to encrypt or decrypt ONE 128-bit block of data\n ******************************************************************************/\nstatic int aes_cipher(aes_context *ctx,       // pointer to context\n                      const unsigned char input[16],  // 128-bit block to en/decipher\n                      unsigned char output[16]);      // 128-bit output result block\n                                              // returns 0 for success\n\n/******************************************************************************\n *  GCM_CONTEXT : GCM context / holds keytables, instance data, and AES ctx\n ******************************************************************************/\ntypedef struct {\n  int mode;             // cipher direction: encrypt/decrypt\n  uint64_t len;         // cipher data length processed so far\n  uint64_t add_len;     // total add data length\n  uint64_t HL[16];      // precalculated lo-half HTable\n  uint64_t HH[16];      // precalculated hi-half HTable\n  unsigned char base_ectr[16];  // first counter-mode cipher output for tag\n  unsigned char y[16];          // the current cipher-input IV|Counter value\n  unsigned char buf[16];        // buf working value\n  aes_context aes_ctx;  // cipher context used\n} gcm_context;\n\n/******************************************************************************\n *  GCM_SETKEY : sets the GCM (and AES) keying material for use\n ******************************************************************************/\nstatic int gcm_setkey(\n    gcm_context *ctx,   // caller-provided context ptr\n    const unsigned char *key,   // pointer to cipher key\n    const unsigned int keysize  // size in bytes (must be 16, 24, 32 for\n                        // 128, 192 or 256-bit keys respectively)\n);                      // returns 0 for success\n\n/******************************************************************************\n *\n *  GCM_CRYPT_AND_TAG\n *\n *  This either encrypts or decrypts the user-provided data and, either\n *  way, generates an authentication tag of the requested length. It must be\n *  called with a GCM context whose key has already been set with GCM_SETKEY.\n *\n *  The user would typically call this explicitly to ENCRYPT a buffer of data\n *  and optional associated data, and produce its an authentication tag.\n *\n *  To reverse the process the user would typically call the companion\n *  GCM_AUTH_DECRYPT function to decrypt data and verify a user-provided\n *  authentication tag.  The GCM_AUTH_DECRYPT function calls this function\n *  to perform its decryption and tag generation, which it then compares.\n *\n ******************************************************************************/\nstatic int gcm_crypt_and_tag(\n    gcm_context *ctx,    // gcm context with key already setup\n    int mode,            // cipher direction: MG_ENCRYPT (1) or MG_DECRYPT (0)\n    const unsigned char *iv,     // pointer to the 12-byte initialization vector\n    size_t iv_len,       // byte length if the IV. should always be 12\n    const unsigned char *add,    // pointer to the non-ciphered additional data\n    size_t add_len,      // byte length of the additional AEAD data\n    const unsigned char *input,  // pointer to the cipher data source\n    unsigned char *output,       // pointer to the cipher data destination\n    size_t length,       // byte length of the cipher data\n    unsigned char *tag,          // pointer to the tag to be generated\n    size_t tag_len);     // byte length of the tag to be generated\n\n/******************************************************************************\n *\n *  GCM_START\n *\n *  Given a user-provided GCM context, this initializes it, sets the encryption\n *  mode, and preprocesses the initialization vector and additional AEAD data.\n *\n ******************************************************************************/\nstatic int gcm_start(\n    gcm_context *ctx,  // pointer to user-provided GCM context\n    int mode,          // MG_ENCRYPT (1) or MG_DECRYPT (0)\n    const unsigned char *iv,   // pointer to initialization vector\n    size_t iv_len,     // IV length in bytes (should == 12)\n    const unsigned char *add,  // pointer to additional AEAD data (NULL if none)\n    size_t add_len);   // length of additional AEAD data (bytes)\n\n/******************************************************************************\n *\n *  GCM_UPDATE\n *\n *  This is called once or more to process bulk plaintext or ciphertext data.\n *  We give this some number of bytes of input and it returns the same number\n *  of output bytes. If called multiple times (which is fine) all but the final\n *  invocation MUST be called with length mod 16 == 0. (Only the final call can\n *  have a partial block length of < 128 bits.)\n *\n ******************************************************************************/\nstatic int gcm_update(gcm_context *ctx,  // pointer to user-provided GCM context\n                      size_t length,     // length, in bytes, of data to process\n                      const unsigned char *input,  // pointer to source data\n                      unsigned char *output);      // pointer to destination data\n\n/******************************************************************************\n *\n *  GCM_FINISH\n *\n *  This is called once after all calls to GCM_UPDATE to finalize the GCM.\n *  It performs the final GHASH to produce the resulting authentication TAG.\n *\n ******************************************************************************/\nstatic int gcm_finish(\n    gcm_context *ctx,  // pointer to user-provided GCM context\n    unsigned char *tag,        // ptr to tag buffer - NULL if tag_len = 0\n    size_t tag_len);   // length, in bytes, of the tag-receiving buf\n\n/******************************************************************************\n *\n *  GCM_ZERO_CTX\n *\n *  The GCM context contains both the GCM context and the AES context.\n *  This includes keying and key-related material which is security-\n *  sensitive, so it MUST be zeroed after use. This function does that.\n *\n ******************************************************************************/\nstatic void gcm_zero_ctx(gcm_context *ctx);\n\n/******************************************************************************\n *\n * THIS SOURCE CODE IS HEREBY PLACED INTO THE PUBLIC DOMAIN FOR THE GOOD OF ALL\n *\n * This is a simple and straightforward implementation of the AES Rijndael\n * 128-bit block cipher designed by Vincent Rijmen and Joan Daemen. The focus\n * of this work was correctness & accuracy.  It is written in 'C' without any\n * particular focus upon optimization or speed. It should be endian (memory\n * byte order) neutral since the few places that care are handled explicitly.\n *\n * This implementation of Rijndael was created by Steven M. Gibson of GRC.com.\n *\n * It is intended for general purpose use, but was written in support of GRC's\n * reference implementation of the SQRL (Secure Quick Reliable Login) client.\n *\n * See:    http://csrc.nist.gov/archive/aes/rijndael/wsdindex.html\n *\n * NO COPYRIGHT IS CLAIMED IN THIS WORK, HOWEVER, NEITHER IS ANY WARRANTY MADE\n * REGARDING ITS FITNESS FOR ANY PARTICULAR PURPOSE. USE IT AT YOUR OWN RISK.\n *\n *******************************************************************************/\n\n\n\n\nstatic int aes_tables_inited = 0;  // run-once flag for performing key\n                                   // expasion table generation (see below)\n/*\n *  The following static local tables must be filled-in before the first use of\n *  the GCM or AES ciphers. They are used for the AES key expansion/scheduling\n *  and once built are read-only and thread safe. The \"gcm_initialize\" function\n *  must be called once during system initialization to populate these arrays\n *  for subsequent use by the AES key scheduler. If they have not been built\n *  before attempted use, an error will be returned to the caller.\n *\n *  NOTE: GCM Encryption/Decryption does NOT REQUIRE AES decryption. Since\n *  GCM uses AES in counter-mode, where the AES cipher output is XORed with\n *  the GCM input, we ONLY NEED AES encryption.  Thus, to save space AES\n *  decryption is typically disabled by setting AES_DECRYPTION to 0 in aes.h.\n */\n// We always need our forward tables\nstatic unsigned char FSb[256];     // Forward substitution box (FSb)\nstatic uint32_t FT0[256];  // Forward key schedule assembly tables\nstatic uint32_t FT1[256];\nstatic uint32_t FT2[256];\nstatic uint32_t FT3[256];\n\n#if AES_DECRYPTION         // We ONLY need reverse for decryption\nstatic unsigned char RSb[256];     // Reverse substitution box (RSb)\nstatic uint32_t RT0[256];  // Reverse key schedule assembly tables\nstatic uint32_t RT1[256];\nstatic uint32_t RT2[256];\nstatic uint32_t RT3[256];\n#endif /* AES_DECRYPTION */\n\nstatic uint32_t RCON[10];  // AES round constants\n\n/*\n * Platform Endianness Neutralizing Load and Store Macro definitions\n * AES wants platform-neutral Little Endian (LE) byte ordering\n */\n#define GET_UINT32_LE(n, b, i)                                               \\\n  {                                                                          \\\n    (n) = ((uint32_t) (b)[(i)]) | ((uint32_t) (b)[(i) + 1] << 8) |           \\\n          ((uint32_t) (b)[(i) + 2] << 16) | ((uint32_t) (b)[(i) + 3] << 24); \\\n  }\n\n#define PUT_UINT32_LE(n, b, i)          \\\n  {                                     \\\n    (b)[(i)] = (unsigned char) ((n));           \\\n    (b)[(i) + 1] = (unsigned char) ((n) >> 8);  \\\n    (b)[(i) + 2] = (unsigned char) ((n) >> 16); \\\n    (b)[(i) + 3] = (unsigned char) ((n) >> 24); \\\n  }\n\n/*\n *  AES forward and reverse encryption round processing macros\n */\n#define AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3)          \\\n  {                                                         \\\n    X0 = *RK++ ^ FT0[(Y0) & 0xFF] ^ FT1[(Y1 >> 8) & 0xFF] ^ \\\n         FT2[(Y2 >> 16) & 0xFF] ^ FT3[(Y3 >> 24) & 0xFF];   \\\n                                                            \\\n    X1 = *RK++ ^ FT0[(Y1) & 0xFF] ^ FT1[(Y2 >> 8) & 0xFF] ^ \\\n         FT2[(Y3 >> 16) & 0xFF] ^ FT3[(Y0 >> 24) & 0xFF];   \\\n                                                            \\\n    X2 = *RK++ ^ FT0[(Y2) & 0xFF] ^ FT1[(Y3 >> 8) & 0xFF] ^ \\\n         FT2[(Y0 >> 16) & 0xFF] ^ FT3[(Y1 >> 24) & 0xFF];   \\\n                                                            \\\n    X3 = *RK++ ^ FT0[(Y3) & 0xFF] ^ FT1[(Y0 >> 8) & 0xFF] ^ \\\n         FT2[(Y1 >> 16) & 0xFF] ^ FT3[(Y2 >> 24) & 0xFF];   \\\n  }\n\n#define AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3)          \\\n  {                                                         \\\n    X0 = *RK++ ^ RT0[(Y0) & 0xFF] ^ RT1[(Y3 >> 8) & 0xFF] ^ \\\n         RT2[(Y2 >> 16) & 0xFF] ^ RT3[(Y1 >> 24) & 0xFF];   \\\n                                                            \\\n    X1 = *RK++ ^ RT0[(Y1) & 0xFF] ^ RT1[(Y0 >> 8) & 0xFF] ^ \\\n         RT2[(Y3 >> 16) & 0xFF] ^ RT3[(Y2 >> 24) & 0xFF];   \\\n                                                            \\\n    X2 = *RK++ ^ RT0[(Y2) & 0xFF] ^ RT1[(Y1 >> 8) & 0xFF] ^ \\\n         RT2[(Y0 >> 16) & 0xFF] ^ RT3[(Y3 >> 24) & 0xFF];   \\\n                                                            \\\n    X3 = *RK++ ^ RT0[(Y3) & 0xFF] ^ RT1[(Y2 >> 8) & 0xFF] ^ \\\n         RT2[(Y1 >> 16) & 0xFF] ^ RT3[(Y0 >> 24) & 0xFF];   \\\n  }\n\n/*\n *  These macros improve the readability of the key\n *  generation initialization code by collapsing\n *  repetitive common operations into logical pieces.\n */\n#define ROTL8(x) ((x << 8) & 0xFFFFFFFF) | (x >> 24)\n#define XTIME(x) ((x << 1) ^ ((x & 0x80) ? 0x1B : 0x00))\n#define MUL(x, y) ((x && y) ? pow[(log[x] + log[y]) % 255] : 0)\n#define MIX(x, y)                     \\\n  {                                   \\\n    y = ((y << 1) | (y >> 7)) & 0xFF; \\\n    x ^= y;                           \\\n  }\n#define CPY128     \\\n  {                \\\n    *RK++ = *SK++; \\\n    *RK++ = *SK++; \\\n    *RK++ = *SK++; \\\n    *RK++ = *SK++; \\\n  }\n\n/******************************************************************************\n *\n *  AES_INIT_KEYGEN_TABLES\n *\n *  Fills the AES key expansion tables allocated above with their static\n *  data. This is not \"per key\" data, but static system-wide read-only\n *  table data. THIS FUNCTION IS NOT THREAD SAFE. It must be called once\n *  at system initialization to setup the tables for all subsequent use.\n *\n ******************************************************************************/\nvoid aes_init_keygen_tables(void) {\n  int i, x, y, z;  // general purpose iteration and computation locals\n  int pow[256];\n  int log[256];\n\n  if (aes_tables_inited) return;\n\n  // fill the 'pow' and 'log' tables over GF(2^8)\n  for (i = 0, x = 1; i < 256; i++) {\n    pow[i] = x;\n    log[x] = i;\n    x = (x ^ XTIME(x)) & 0xFF;\n  }\n  // compute the round constants\n  for (i = 0, x = 1; i < 10; i++) {\n    RCON[i] = (uint32_t) x;\n    x = XTIME(x) & 0xFF;\n  }\n  // fill the forward and reverse substitution boxes\n  FSb[0x00] = 0x63;\n#if AES_DECRYPTION  // whether AES decryption is supported\n  RSb[0x63] = 0x00;\n#endif /* AES_DECRYPTION */\n\n  for (i = 1; i < 256; i++) {\n    x = y = pow[255 - log[i]];\n    MIX(x, y);\n    MIX(x, y);\n    MIX(x, y);\n    MIX(x, y);\n    FSb[i] = (unsigned char) (x ^= 0x63);\n#if AES_DECRYPTION  // whether AES decryption is supported\n    RSb[x] = (unsigned char) i;\n#endif /* AES_DECRYPTION */\n  }\n  // generate the forward and reverse key expansion tables\n  for (i = 0; i < 256; i++) {\n    x = FSb[i];\n    y = XTIME(x) & 0xFF;\n    z = (y ^ x) & 0xFF;\n\n    FT0[i] = ((uint32_t) y) ^ ((uint32_t) x << 8) ^ ((uint32_t) x << 16) ^\n             ((uint32_t) z << 24);\n\n    FT1[i] = ROTL8(FT0[i]);\n    FT2[i] = ROTL8(FT1[i]);\n    FT3[i] = ROTL8(FT2[i]);\n\n#if AES_DECRYPTION  // whether AES decryption is supported\n    x = RSb[i];\n\n    RT0[i] = ((uint32_t) MUL(0x0E, x)) ^ ((uint32_t) MUL(0x09, x) << 8) ^\n             ((uint32_t) MUL(0x0D, x) << 16) ^ ((uint32_t) MUL(0x0B, x) << 24);\n\n    RT1[i] = ROTL8(RT0[i]);\n    RT2[i] = ROTL8(RT1[i]);\n    RT3[i] = ROTL8(RT2[i]);\n#endif /* AES_DECRYPTION */\n  }\n  aes_tables_inited = 1;  // flag that the tables have been generated\n}  // to permit subsequent use of the AES cipher\n\n/******************************************************************************\n *\n *  AES_SET_ENCRYPTION_KEY\n *\n *  This is called by 'aes_setkey' when we're establishing a key for\n *  subsequent encryption.  We give it a pointer to the encryption\n *  context, a pointer to the key, and the key's length in bytes.\n *  Valid lengths are: 16, 24 or 32 bytes (128, 192, 256 bits).\n *\n ******************************************************************************/\nstatic int aes_set_encryption_key(aes_context *ctx, const unsigned char *key,\n                                  unsigned int keysize) {\n  unsigned int i;                  // general purpose iteration local\n  uint32_t *RK = ctx->rk;  // initialize our RoundKey buffer pointer\n\n  for (i = 0; i < (keysize >> 2); i++) {\n    GET_UINT32_LE(RK[i], key, i << 2);\n  }\n\n  switch (ctx->rounds) {\n    case 10:\n      for (i = 0; i < 10; i++, RK += 4) {\n        RK[4] = RK[0] ^ RCON[i] ^ ((uint32_t) FSb[(RK[3] >> 8) & 0xFF]) ^\n                ((uint32_t) FSb[(RK[3] >> 16) & 0xFF] << 8) ^\n                ((uint32_t) FSb[(RK[3] >> 24) & 0xFF] << 16) ^\n                ((uint32_t) FSb[(RK[3]) & 0xFF] << 24);\n\n        RK[5] = RK[1] ^ RK[4];\n        RK[6] = RK[2] ^ RK[5];\n        RK[7] = RK[3] ^ RK[6];\n      }\n      break;\n\n    case 12:\n      for (i = 0; i < 8; i++, RK += 6) {\n        RK[6] = RK[0] ^ RCON[i] ^ ((uint32_t) FSb[(RK[5] >> 8) & 0xFF]) ^\n                ((uint32_t) FSb[(RK[5] >> 16) & 0xFF] << 8) ^\n                ((uint32_t) FSb[(RK[5] >> 24) & 0xFF] << 16) ^\n                ((uint32_t) FSb[(RK[5]) & 0xFF] << 24);\n\n        RK[7] = RK[1] ^ RK[6];\n        RK[8] = RK[2] ^ RK[7];\n        RK[9] = RK[3] ^ RK[8];\n        RK[10] = RK[4] ^ RK[9];\n        RK[11] = RK[5] ^ RK[10];\n      }\n      break;\n\n    case 14:\n      for (i = 0; i < 7; i++, RK += 8) {\n        RK[8] = RK[0] ^ RCON[i] ^ ((uint32_t) FSb[(RK[7] >> 8) & 0xFF]) ^\n                ((uint32_t) FSb[(RK[7] >> 16) & 0xFF] << 8) ^\n                ((uint32_t) FSb[(RK[7] >> 24) & 0xFF] << 16) ^\n                ((uint32_t) FSb[(RK[7]) & 0xFF] << 24);\n\n        RK[9] = RK[1] ^ RK[8];\n        RK[10] = RK[2] ^ RK[9];\n        RK[11] = RK[3] ^ RK[10];\n\n        RK[12] = RK[4] ^ ((uint32_t) FSb[(RK[11]) & 0xFF]) ^\n                 ((uint32_t) FSb[(RK[11] >> 8) & 0xFF] << 8) ^\n                 ((uint32_t) FSb[(RK[11] >> 16) & 0xFF] << 16) ^\n                 ((uint32_t) FSb[(RK[11] >> 24) & 0xFF] << 24);\n\n        RK[13] = RK[5] ^ RK[12];\n        RK[14] = RK[6] ^ RK[13];\n        RK[15] = RK[7] ^ RK[14];\n      }\n      break;\n\n    default:\n      return -1;\n  }\n  return (0);\n}\n\n#if AES_DECRYPTION  // whether AES decryption is supported\n\n/******************************************************************************\n *\n *  AES_SET_DECRYPTION_KEY\n *\n *  This is called by 'aes_setkey' when we're establishing a\n *  key for subsequent decryption.  We give it a pointer to\n *  the encryption context, a pointer to the key, and the key's\n *  length in bits. Valid lengths are: 128, 192, or 256 bits.\n *\n ******************************************************************************/\nstatic int aes_set_decryption_key(aes_context *ctx, const unsigned char *key,\n                                  unsigned int keysize) {\n  int i, j;\n  aes_context cty;         // a calling aes context for set_encryption_key\n  uint32_t *RK = ctx->rk;  // initialize our RoundKey buffer pointer\n  uint32_t *SK;\n  int ret;\n\n  cty.rounds = ctx->rounds;  // initialize our local aes context\n  cty.rk = cty.buf;          // round count and key buf pointer\n\n  if ((ret = aes_set_encryption_key(&cty, key, keysize)) != 0) return (ret);\n\n  SK = cty.rk + cty.rounds * 4;\n\n  CPY128  // copy a 128-bit block from *SK to *RK\n\n      for (i = ctx->rounds - 1, SK -= 8; i > 0; i--, SK -= 8) {\n    for (j = 0; j < 4; j++, SK++) {\n      *RK++ = RT0[FSb[(*SK) & 0xFF]] ^ RT1[FSb[(*SK >> 8) & 0xFF]] ^\n              RT2[FSb[(*SK >> 16) & 0xFF]] ^ RT3[FSb[(*SK >> 24) & 0xFF]];\n    }\n  }\n  CPY128  // copy a 128-bit block from *SK to *RK\n      memset(&cty, 0, sizeof(aes_context));  // clear local aes context\n  return (0);\n}\n\n#endif /* AES_DECRYPTION */\n\n/******************************************************************************\n *\n *  AES_SETKEY\n *\n *  Invoked to establish the key schedule for subsequent encryption/decryption\n *\n ******************************************************************************/\nstatic int aes_setkey(aes_context *ctx,  // AES context provided by our caller\n                      int mode,          // ENCRYPT or DECRYPT flag\n                      const unsigned char *key,  // pointer to the key\n                      unsigned int keysize)      // key length in bytes\n{\n  // since table initialization is not thread safe, we could either add\n  // system-specific mutexes and init the AES key generation tables on\n  // demand, or ask the developer to simply call \"gcm_initialize\" once during\n  // application startup before threading begins. That's what we choose.\n  if (!aes_tables_inited) return (-1);  // fail the call when not inited.\n\n  ctx->mode = mode;    // capture the key type we're creating\n  ctx->rk = ctx->buf;  // initialize our round key pointer\n\n  switch (keysize)  // set the rounds count based upon the keysize\n  {\n    case 16:\n      ctx->rounds = 10;\n      break;  // 16-byte, 128-bit key\n    case 24:\n      ctx->rounds = 12;\n      break;  // 24-byte, 192-bit key\n    case 32:\n      ctx->rounds = 14;\n      break;  // 32-byte, 256-bit key\n    default:\n      return (-1);\n  }\n\n#if AES_DECRYPTION\n  if (mode == MG_DECRYPT)  // expand our key for encryption or decryption\n    return (aes_set_decryption_key(ctx, key, keysize));\n  else /* MG_ENCRYPT */\n#endif /* AES_DECRYPTION */\n    return (aes_set_encryption_key(ctx, key, keysize));\n}\n\n/******************************************************************************\n *\n *  AES_CIPHER\n *\n *  Perform AES encryption and decryption.\n *  The AES context will have been setup with the encryption mode\n *  and all keying information appropriate for the task.\n *\n ******************************************************************************/\nstatic int aes_cipher(aes_context *ctx, const unsigned char input[16],\n                      unsigned char output[16]) {\n  int i;\n  uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;  // general purpose locals\n\n  RK = ctx->rk;\n\n  GET_UINT32_LE(X0, input, 0);\n  X0 ^= *RK++;  // load our 128-bit\n  GET_UINT32_LE(X1, input, 4);\n  X1 ^= *RK++;  // input buffer in a storage\n  GET_UINT32_LE(X2, input, 8);\n  X2 ^= *RK++;  // memory endian-neutral way\n  GET_UINT32_LE(X3, input, 12);\n  X3 ^= *RK++;\n\n#if AES_DECRYPTION  // whether AES decryption is supported\n\n  if (ctx->mode == MG_DECRYPT) {\n    for (i = (ctx->rounds >> 1) - 1; i > 0; i--) {\n      AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);\n      AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);\n    }\n\n    AES_RROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);\n\n    X0 = *RK++ ^ ((uint32_t) RSb[(Y0) & 0xFF]) ^\n         ((uint32_t) RSb[(Y3 >> 8) & 0xFF] << 8) ^\n         ((uint32_t) RSb[(Y2 >> 16) & 0xFF] << 16) ^\n         ((uint32_t) RSb[(Y1 >> 24) & 0xFF] << 24);\n\n    X1 = *RK++ ^ ((uint32_t) RSb[(Y1) & 0xFF]) ^\n         ((uint32_t) RSb[(Y0 >> 8) & 0xFF] << 8) ^\n         ((uint32_t) RSb[(Y3 >> 16) & 0xFF] << 16) ^\n         ((uint32_t) RSb[(Y2 >> 24) & 0xFF] << 24);\n\n    X2 = *RK++ ^ ((uint32_t) RSb[(Y2) & 0xFF]) ^\n         ((uint32_t) RSb[(Y1 >> 8) & 0xFF] << 8) ^\n         ((uint32_t) RSb[(Y0 >> 16) & 0xFF] << 16) ^\n         ((uint32_t) RSb[(Y3 >> 24) & 0xFF] << 24);\n\n    X3 = *RK++ ^ ((uint32_t) RSb[(Y3) & 0xFF]) ^\n         ((uint32_t) RSb[(Y2 >> 8) & 0xFF] << 8) ^\n         ((uint32_t) RSb[(Y1 >> 16) & 0xFF] << 16) ^\n         ((uint32_t) RSb[(Y0 >> 24) & 0xFF] << 24);\n  } else /* MG_ENCRYPT */\n  {\n#endif /* AES_DECRYPTION */\n\n    for (i = (ctx->rounds >> 1) - 1; i > 0; i--) {\n      AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);\n      AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3);\n    }\n\n    AES_FROUND(Y0, Y1, Y2, Y3, X0, X1, X2, X3);\n\n    X0 = *RK++ ^ ((uint32_t) FSb[(Y0) & 0xFF]) ^\n         ((uint32_t) FSb[(Y1 >> 8) & 0xFF] << 8) ^\n         ((uint32_t) FSb[(Y2 >> 16) & 0xFF] << 16) ^\n         ((uint32_t) FSb[(Y3 >> 24) & 0xFF] << 24);\n\n    X1 = *RK++ ^ ((uint32_t) FSb[(Y1) & 0xFF]) ^\n         ((uint32_t) FSb[(Y2 >> 8) & 0xFF] << 8) ^\n         ((uint32_t) FSb[(Y3 >> 16) & 0xFF] << 16) ^\n         ((uint32_t) FSb[(Y0 >> 24) & 0xFF] << 24);\n\n    X2 = *RK++ ^ ((uint32_t) FSb[(Y2) & 0xFF]) ^\n         ((uint32_t) FSb[(Y3 >> 8) & 0xFF] << 8) ^\n         ((uint32_t) FSb[(Y0 >> 16) & 0xFF] << 16) ^\n         ((uint32_t) FSb[(Y1 >> 24) & 0xFF] << 24);\n\n    X3 = *RK++ ^ ((uint32_t) FSb[(Y3) & 0xFF]) ^\n         ((uint32_t) FSb[(Y0 >> 8) & 0xFF] << 8) ^\n         ((uint32_t) FSb[(Y1 >> 16) & 0xFF] << 16) ^\n         ((uint32_t) FSb[(Y2 >> 24) & 0xFF] << 24);\n\n#if AES_DECRYPTION  // whether AES decryption is supported\n  }\n#endif /* AES_DECRYPTION */\n\n  PUT_UINT32_LE(X0, output, 0);\n  PUT_UINT32_LE(X1, output, 4);\n  PUT_UINT32_LE(X2, output, 8);\n  PUT_UINT32_LE(X3, output, 12);\n\n  return (0);\n}\n/* end of aes.c */\n/******************************************************************************\n *\n * THIS SOURCE CODE IS HEREBY PLACED INTO THE PUBLIC DOMAIN FOR THE GOOD OF ALL\n *\n * This is a simple and straightforward implementation of AES-GCM authenticated\n * encryption. The focus of this work was correctness & accuracy. It is written\n * in straight 'C' without any particular focus upon optimization or speed. It\n * should be endian (memory byte order) neutral since the few places that care\n * are handled explicitly.\n *\n * This implementation of AES-GCM was created by Steven M. Gibson of GRC.com.\n *\n * It is intended for general purpose use, but was written in support of GRC's\n * reference implementation of the SQRL (Secure Quick Reliable Login) client.\n *\n * See:    http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf\n *         http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/\n *         gcm/gcm-revised-spec.pdf\n *\n * NO COPYRIGHT IS CLAIMED IN THIS WORK, HOWEVER, NEITHER IS ANY WARRANTY MADE\n * REGARDING ITS FITNESS FOR ANY PARTICULAR PURPOSE. USE IT AT YOUR OWN RISK.\n *\n *******************************************************************************/\n\n/******************************************************************************\n *                      ==== IMPLEMENTATION WARNING ====\n *\n *  This code was developed for use within SQRL's fixed environmnent. Thus, it\n *  is somewhat less \"general purpose\" than it would be if it were designed as\n *  a general purpose AES-GCM library. Specifically, it bothers with almost NO\n *  error checking on parameter limits, buffer bounds, etc. It assumes that it\n *  is being invoked by its author or by someone who understands the values it\n *  expects to receive. Its behavior will be undefined otherwise.\n *\n *  All functions that might fail are defined to return 'ints' to indicate a\n *  problem. Most do not do so now. But this allows for error propagation out\n *  of internal functions if robust error checking should ever be desired.\n *\n ******************************************************************************/\n\n/* Calculating the \"GHASH\"\n *\n * There are many ways of calculating the so-called GHASH in software, each with\n * a traditional size vs performance tradeoff.  The GHASH (Galois field hash) is\n * an intriguing construction which takes two 128-bit strings (also the cipher's\n * block size and the fundamental operation size for the system) and hashes them\n * into a third 128-bit result.\n *\n * Many implementation solutions have been worked out that use large precomputed\n * table lookups in place of more time consuming bit fiddling, and this approach\n * can be scaled easily upward or downward as needed to change the time/space\n * tradeoff. It's been studied extensively and there's a solid body of theory\n * and practice.  For example, without using any lookup tables an implementation\n * might obtain 119 cycles per byte throughput, whereas using a simple, though\n * large, key-specific 64 kbyte 8-bit lookup table the performance jumps to 13\n * cycles per byte.\n *\n * And Intel's processors have, since 2010, included an instruction which does\n * the entire 128x128->128 bit job in just several 64x64->128 bit pieces.\n *\n * Since SQRL is interactive, and only processing a few 128-bit blocks, I've\n * settled upon a relatively slower but appealing small-table compromise which\n * folds a bunch of not only time consuming but also bit twiddling into a simple\n * 16-entry table which is attributed to Victor Shoup's 1996 work while at\n * Bellcore: \"On Fast and Provably Secure MessageAuthentication Based on\n * Universal Hashing.\"  See: http://www.shoup.net/papers/macs.pdf\n * See, also section 4.1 of the \"gcm-revised-spec\" cited above.\n */\n\n/*\n *  This 16-entry table of pre-computed constants is used by the\n *  GHASH multiplier to improve over a strictly table-free but\n *  significantly slower 128x128 bit multiple within GF(2^128).\n */\nstatic const uint64_t last4[16] = {\n    0x0000, 0x1c20, 0x3840, 0x2460, 0x7080, 0x6ca0, 0x48c0, 0x54e0,\n    0xe100, 0xfd20, 0xd940, 0xc560, 0x9180, 0x8da0, 0xa9c0, 0xb5e0};\n\n/*\n * Platform Endianness Neutralizing Load and Store Macro definitions\n * GCM wants platform-neutral Big Endian (BE) byte ordering\n */\n#define GET_UINT32_BE(n, b, i)                                            \\\n  {                                                                       \\\n    (n) = ((uint32_t) (b)[(i)] << 24) | ((uint32_t) (b)[(i) + 1] << 16) | \\\n          ((uint32_t) (b)[(i) + 2] << 8) | ((uint32_t) (b)[(i) + 3]);     \\\n  }\n\n#define PUT_UINT32_BE(n, b, i)          \\\n  {                                     \\\n    (b)[(i)] = (unsigned char) ((n) >> 24);     \\\n    (b)[(i) + 1] = (unsigned char) ((n) >> 16); \\\n    (b)[(i) + 2] = (unsigned char) ((n) >> 8);  \\\n    (b)[(i) + 3] = (unsigned char) ((n));       \\\n  }\n\n/******************************************************************************\n *\n *  GCM_INITIALIZE\n *\n *  Must be called once to initialize the GCM library.\n *\n *  At present, this only calls the AES keygen table generator, which expands\n *  the AES keying tables for use. This is NOT A THREAD-SAFE function, so it\n *  MUST be called during system initialization before a multi-threading\n *  environment is running.\n *\n ******************************************************************************/\nint mg_gcm_initialize(void) {\n  aes_init_keygen_tables();\n  return (0);\n}\n\n/******************************************************************************\n *\n *  GCM_MULT\n *\n *  Performs a GHASH operation on the 128-bit input vector 'x', setting\n *  the 128-bit output vector to 'x' times H using our precomputed tables.\n *  'x' and 'output' are seen as elements of GCM's GF(2^128) Galois field.\n *\n ******************************************************************************/\nstatic void gcm_mult(gcm_context *ctx,   // pointer to established context\n                     const unsigned char x[16],  // pointer to 128-bit input vector\n                     unsigned char output[16])   // pointer to 128-bit output vector\n{\n  int i;\n  unsigned char lo, hi, rem;\n  uint64_t zh, zl;\n\n  lo = (unsigned char) (x[15] & 0x0f);\n  hi = (unsigned char) (x[15] >> 4);\n  zh = ctx->HH[lo];\n  zl = ctx->HL[lo];\n\n  for (i = 15; i >= 0; i--) {\n    lo = (unsigned char) (x[i] & 0x0f);\n    hi = (unsigned char) (x[i] >> 4);\n\n    if (i != 15) {\n      rem = (unsigned char) (zl & 0x0f);\n      zl = (zh << 60) | (zl >> 4);\n      zh = (zh >> 4);\n      zh ^= (uint64_t) last4[rem] << 48;\n      zh ^= ctx->HH[lo];\n      zl ^= ctx->HL[lo];\n    }\n    rem = (unsigned char) (zl & 0x0f);\n    zl = (zh << 60) | (zl >> 4);\n    zh = (zh >> 4);\n    zh ^= (uint64_t) last4[rem] << 48;\n    zh ^= ctx->HH[hi];\n    zl ^= ctx->HL[hi];\n  }\n  PUT_UINT32_BE(zh >> 32, output, 0);\n  PUT_UINT32_BE(zh, output, 4);\n  PUT_UINT32_BE(zl >> 32, output, 8);\n  PUT_UINT32_BE(zl, output, 12);\n}\n\n/******************************************************************************\n *\n *  GCM_SETKEY\n *\n *  This is called to set the AES-GCM key. It initializes the AES key\n *  and populates the gcm context's pre-calculated HTables.\n *\n ******************************************************************************/\nstatic int gcm_setkey(\n    gcm_context *ctx,    // pointer to caller-provided gcm context\n    const unsigned char *key,    // pointer to the AES encryption key\n    const unsigned int keysize)  // size in bytes (must be 16, 24, 32 for\n                         // 128, 192 or 256-bit keys respectively)\n{\n  int ret, i, j;\n  uint64_t hi, lo;\n  uint64_t vl, vh;\n  unsigned char h[16];\n\n  memset(ctx, 0, sizeof(gcm_context));  // zero caller-provided GCM context\n  memset(h, 0, 16);                     // initialize the block to encrypt\n\n  // encrypt the null 128-bit block to generate a key-based value\n  // which is then used to initialize our GHASH lookup tables\n  if ((ret = aes_setkey(&ctx->aes_ctx, MG_ENCRYPT, key, keysize)) != 0)\n    return (ret);\n  if ((ret = aes_cipher(&ctx->aes_ctx, h, h)) != 0) return (ret);\n\n  GET_UINT32_BE(hi, h, 0);  // pack h as two 64-bit ints, big-endian\n  GET_UINT32_BE(lo, h, 4);\n  vh = (uint64_t) hi << 32 | lo;\n\n  GET_UINT32_BE(hi, h, 8);\n  GET_UINT32_BE(lo, h, 12);\n  vl = (uint64_t) hi << 32 | lo;\n\n  ctx->HL[8] = vl;  // 8 = 1000 corresponds to 1 in GF(2^128)\n  ctx->HH[8] = vh;\n  ctx->HH[0] = 0;  // 0 corresponds to 0 in GF(2^128)\n  ctx->HL[0] = 0;\n\n  for (i = 4; i > 0; i >>= 1) {\n    uint32_t T = (uint32_t) (vl & 1) * 0xe1000000U;\n    vl = (vh << 63) | (vl >> 1);\n    vh = (vh >> 1) ^ ((uint64_t) T << 32);\n    ctx->HL[i] = vl;\n    ctx->HH[i] = vh;\n  }\n  for (i = 2; i < 16; i <<= 1) {\n    uint64_t *HiL = ctx->HL + i, *HiH = ctx->HH + i;\n    vh = *HiH;\n    vl = *HiL;\n    for (j = 1; j < i; j++) {\n      HiH[j] = vh ^ ctx->HH[j];\n      HiL[j] = vl ^ ctx->HL[j];\n    }\n  }\n  return (0);\n}\n\n/******************************************************************************\n *\n *    GCM processing occurs four phases: SETKEY, START, UPDATE and FINISH.\n *\n *  SETKEY:\n *\n *   START: Sets the Encryption/Decryption mode.\n *          Accepts the initialization vector and additional data.\n *\n *  UPDATE: Encrypts or decrypts the plaintext or ciphertext.\n *\n *  FINISH: Performs a final GHASH to generate the authentication tag.\n *\n ******************************************************************************\n *\n *  GCM_START\n *\n *  Given a user-provided GCM context, this initializes it, sets the encryption\n *  mode, and preprocesses the initialization vector and additional AEAD data.\n *\n ******************************************************************************/\nint gcm_start(gcm_context *ctx,  // pointer to user-provided GCM context\n              int mode,          // GCM_ENCRYPT or GCM_DECRYPT\n              const unsigned char *iv,   // pointer to initialization vector\n              size_t iv_len,     // IV length in bytes (should == 12)\n              const unsigned char *add,  // ptr to additional AEAD data (NULL if none)\n              size_t add_len)    // length of additional AEAD data (bytes)\n{\n  int ret;             // our error return if the AES encrypt fails\n  unsigned char work_buf[16];  // XOR source built from provided IV if len != 16\n  const unsigned char *p;      // general purpose array pointer\n  size_t use_len;      // byte count to process, up to 16 bytes\n  size_t i;            // local loop iterator\n\n  // since the context might be reused under the same key\n  // we zero the working buffers for this next new process\n  memset(ctx->y, 0x00, sizeof(ctx->y));\n  memset(ctx->buf, 0x00, sizeof(ctx->buf));\n  ctx->len = 0;\n  ctx->add_len = 0;\n\n  ctx->mode = mode;                // set the GCM encryption/decryption mode\n  ctx->aes_ctx.mode = MG_ENCRYPT;  // GCM *always* runs AES in ENCRYPTION mode\n\n  if (iv_len == 12) {            // GCM natively uses a 12-byte, 96-bit IV\n    memcpy(ctx->y, iv, iv_len);  // copy the IV to the top of the 'y' buff\n    ctx->y[15] = 1;              // start \"counting\" from 1 (not 0)\n  } else  // if we don't have a 12-byte IV, we GHASH whatever we've been given\n  {\n    memset(work_buf, 0x00, 16);               // clear the working buffer\n    PUT_UINT32_BE(iv_len * 8, work_buf, 12);  // place the IV into buffer\n\n    p = iv;\n    while (iv_len > 0) {\n      use_len = (iv_len < 16) ? iv_len : 16;\n      for (i = 0; i < use_len; i++) ctx->y[i] ^= p[i];\n      gcm_mult(ctx, ctx->y, ctx->y);\n      iv_len -= use_len;\n      p += use_len;\n    }\n    for (i = 0; i < 16; i++) ctx->y[i] ^= work_buf[i];\n    gcm_mult(ctx, ctx->y, ctx->y);\n  }\n  if ((ret = aes_cipher(&ctx->aes_ctx, ctx->y, ctx->base_ectr)) != 0)\n    return (ret);\n\n  ctx->add_len = add_len;\n  p = add;\n  while (add_len > 0) {\n    use_len = (add_len < 16) ? add_len : 16;\n    for (i = 0; i < use_len; i++) ctx->buf[i] ^= p[i];\n    gcm_mult(ctx, ctx->buf, ctx->buf);\n    add_len -= use_len;\n    p += use_len;\n  }\n  return (0);\n}\n\n/******************************************************************************\n *\n *  GCM_UPDATE\n *\n *  This is called once or more to process bulk plaintext or ciphertext data.\n *  We give this some number of bytes of input and it returns the same number\n *  of output bytes. If called multiple times (which is fine) all but the final\n *  invocation MUST be called with length mod 16 == 0. (Only the final call can\n *  have a partial block length of < 128 bits.)\n *\n ******************************************************************************/\nint gcm_update(gcm_context *ctx,    // pointer to user-provided GCM context\n               size_t length,       // length, in bytes, of data to process\n               const unsigned char *input,  // pointer to source data\n               unsigned char *output)       // pointer to destination data\n{\n  int ret;         // our error return if the AES encrypt fails\n  unsigned char ectr[16];  // counter-mode cipher output for XORing\n  size_t use_len;  // byte count to process, up to 16 bytes\n  size_t i;        // local loop iterator\n\n  ctx->len += length;  // bump the GCM context's running length count\n\n  while (length > 0) {\n    // clamp the length to process at 16 bytes\n    use_len = (length < 16) ? length : 16;\n\n    // increment the context's 128-bit IV||Counter 'y' vector\n    for (i = 16; i > 12; i--)\n      if (++ctx->y[i - 1] != 0) break;\n\n    // encrypt the context's 'y' vector under the established key\n    if ((ret = aes_cipher(&ctx->aes_ctx, ctx->y, ectr)) != 0) return (ret);\n\n    // encrypt or decrypt the input to the output\n    if (ctx->mode == MG_ENCRYPT) {\n      for (i = 0; i < use_len; i++) {\n        // XOR the cipher's ouptut vector (ectr) with our input\n        output[i] = (unsigned char) (ectr[i] ^ input[i]);\n        // now we mix in our data into the authentication hash.\n        // if we're ENcrypting we XOR in the post-XOR (output)\n        // results, but if we're DEcrypting we XOR in the input\n        // data\n        ctx->buf[i] ^= output[i];\n      }\n    } else {\n      for (i = 0; i < use_len; i++) {\n        // but if we're DEcrypting we XOR in the input data first,\n        // i.e. before saving to ouput data, otherwise if the input\n        // and output buffer are the same (inplace decryption) we\n        // would not get the correct auth tag\n\n        ctx->buf[i] ^= input[i];\n\n        // XOR the cipher's ouptut vector (ectr) with our input\n        output[i] = (unsigned char) (ectr[i] ^ input[i]);\n      }\n    }\n    gcm_mult(ctx, ctx->buf, ctx->buf);  // perform a GHASH operation\n\n    length -= use_len;  // drop the remaining byte count to process\n    input += use_len;   // bump our input pointer forward\n    output += use_len;  // bump our output pointer forward\n  }\n  return (0);\n}\n\n/******************************************************************************\n *\n *  GCM_FINISH\n *\n *  This is called once after all calls to GCM_UPDATE to finalize the GCM.\n *  It performs the final GHASH to produce the resulting authentication TAG.\n *\n ******************************************************************************/\nint gcm_finish(gcm_context *ctx,  // pointer to user-provided GCM context\n               unsigned char *tag,        // pointer to buffer which receives the tag\n               size_t tag_len)    // length, in bytes, of the tag-receiving buf\n{\n  unsigned char work_buf[16];\n  uint64_t orig_len = ctx->len * 8;\n  uint64_t orig_add_len = ctx->add_len * 8;\n  size_t i;\n\n  if (tag_len != 0) memcpy(tag, ctx->base_ectr, tag_len);\n\n  if (orig_len || orig_add_len) {\n    memset(work_buf, 0x00, 16);\n\n    PUT_UINT32_BE((orig_add_len >> 32), work_buf, 0);\n    PUT_UINT32_BE((orig_add_len), work_buf, 4);\n    PUT_UINT32_BE((orig_len >> 32), work_buf, 8);\n    PUT_UINT32_BE((orig_len), work_buf, 12);\n\n    for (i = 0; i < 16; i++) ctx->buf[i] ^= work_buf[i];\n    gcm_mult(ctx, ctx->buf, ctx->buf);\n    for (i = 0; i < tag_len; i++) tag[i] ^= ctx->buf[i];\n  }\n  return (0);\n}\n\n/******************************************************************************\n *\n *  GCM_CRYPT_AND_TAG\n *\n *  This either encrypts or decrypts the user-provided data and, either\n *  way, generates an authentication tag of the requested length. It must be\n *  called with a GCM context whose key has already been set with GCM_SETKEY.\n *\n *  The user would typically call this explicitly to ENCRYPT a buffer of data\n *  and optional associated data, and produce its an authentication tag.\n *\n *  To reverse the process the user would typically call the companion\n *  GCM_AUTH_DECRYPT function to decrypt data and verify a user-provided\n *  authentication tag.  The GCM_AUTH_DECRYPT function calls this function\n *  to perform its decryption and tag generation, which it then compares.\n *\n ******************************************************************************/\nint gcm_crypt_and_tag(\n    gcm_context *ctx,    // gcm context with key already setup\n    int mode,            // cipher direction: GCM_ENCRYPT or GCM_DECRYPT\n    const unsigned char *iv,     // pointer to the 12-byte initialization vector\n    size_t iv_len,       // byte length if the IV. should always be 12\n    const unsigned char *add,    // pointer to the non-ciphered additional data\n    size_t add_len,      // byte length of the additional AEAD data\n    const unsigned char *input,  // pointer to the cipher data source\n    unsigned char *output,       // pointer to the cipher data destination\n    size_t length,       // byte length of the cipher data\n    unsigned char *tag,          // pointer to the tag to be generated\n    size_t tag_len)      // byte length of the tag to be generated\n{                        /*\n                            assuming that the caller has already invoked gcm_setkey to\n                            prepare the gcm context with the keying material, we simply\n                            invoke each of the three GCM sub-functions in turn...\n                         */\n  gcm_start(ctx, mode, iv, iv_len, add, add_len);\n  gcm_update(ctx, length, input, output);\n  gcm_finish(ctx, tag, tag_len);\n  return (0);\n}\n\n/******************************************************************************\n *\n *  GCM_ZERO_CTX\n *\n *  The GCM context contains both the GCM context and the AES context.\n *  This includes keying and key-related material which is security-\n *  sensitive, so it MUST be zeroed after use. This function does that.\n *\n ******************************************************************************/\nvoid gcm_zero_ctx(gcm_context *ctx) {\n  // zero the context originally provided to us\n  memset(ctx, 0, sizeof(gcm_context));\n}\n//\n//  aes-gcm.c\n//  Pods\n//\n//  Created by Markus Kosmal on 20/11/14.\n//\n//\n\nint mg_aes_gcm_encrypt(unsigned char *output,  //\n                       const unsigned char *input, size_t input_length,\n                       const unsigned char *key, const size_t key_len,\n                       const unsigned char *iv, const size_t iv_len,\n                       unsigned char *aead, size_t aead_len, unsigned char *tag,\n                       const size_t tag_len) {\n  int ret = 0;      // our return value\n  gcm_context ctx;  // includes the AES context structure\n\n  gcm_setkey(&ctx, key, (unsigned int) key_len);\n\n  ret = gcm_crypt_and_tag(&ctx, MG_ENCRYPT, iv, iv_len, aead, aead_len, input,\n                          output, input_length, tag, tag_len);\n\n  gcm_zero_ctx(&ctx);\n\n  return (ret);\n}\n\nint mg_aes_gcm_decrypt(unsigned char *output, const unsigned char *input,\n                       size_t input_length, const unsigned char *key,\n                       const size_t key_len, const unsigned char *iv,\n                       const size_t iv_len) {\n  int ret = 0;      // our return value\n  gcm_context ctx;  // includes the AES context structure\n\n  size_t tag_len = 0;\n  unsigned char *tag_buf = NULL;\n\n  gcm_setkey(&ctx, key, (unsigned int) key_len);\n\n  ret = gcm_crypt_and_tag(&ctx, MG_DECRYPT, iv, iv_len, NULL, 0, input, output,\n                          input_length, tag_buf, tag_len);\n\n  gcm_zero_ctx(&ctx);\n\n  return (ret);\n}\n#endif\n// End of aes128 PD\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_builtin.c\"\n#endif\n\n\n\n\n\n\n\n\n\n\n\n#if MG_TLS == MG_TLS_BUILTIN\n\n#define CHACHA20 1\n\n/* TLS 1.3 Record Content Type (RFC8446 B.1) */\n#define MG_TLS_CHANGE_CIPHER 20\n#define MG_TLS_ALERT 21\n#define MG_TLS_HANDSHAKE 22\n#define MG_TLS_APP_DATA 23\n#define MG_TLS_HEARTBEAT 24\n\n/* TLS 1.3 Handshake Message Type (RFC8446 B.3) */\n#define MG_TLS_CLIENT_HELLO 1\n#define MG_TLS_SERVER_HELLO 2\n#define MG_TLS_ENCRYPTED_EXTENSIONS 8\n#define MG_TLS_CERTIFICATE 11\n#define MG_TLS_CERTIFICATE_REQUEST 13\n#define MG_TLS_CERTIFICATE_VERIFY 15\n#define MG_TLS_FINISHED 20\n\n// handshake is re-entrant, so we need to keep track of its state state names\n// refer to RFC8446#A.1\nenum mg_tls_hs_state {\n  // Client state machine:\n  MG_TLS_STATE_CLIENT_START,          // Send ClientHello\n  MG_TLS_STATE_CLIENT_WAIT_SH,        // Wait for ServerHello\n  MG_TLS_STATE_CLIENT_WAIT_EE,        // Wait for EncryptedExtensions\n  MG_TLS_STATE_CLIENT_WAIT_CERT,      // Wait for Certificate\n  MG_TLS_STATE_CLIENT_WAIT_CV,        // Wait for CertificateVerify\n  MG_TLS_STATE_CLIENT_WAIT_FINISHED,  // Wait for Finished\n  MG_TLS_STATE_CLIENT_CONNECTED,      // Done\n\n  // Server state machine:\n  MG_TLS_STATE_SERVER_START,       // Wait for ClientHello\n  MG_TLS_STATE_SERVER_NEGOTIATED,  // Wait for Finished\n  MG_TLS_STATE_SERVER_CONNECTED    // Done\n};\n\n// encryption keys for a TLS connection\nstruct tls_enc {\n  uint32_t sseq;  // server sequence number, used in encryption\n  uint32_t cseq;  // client sequence number, used in decryption\n  // keys for AES encryption or ChaCha20\n  uint8_t handshake_secret[32];\n  uint8_t server_write_key[32];\n  uint8_t server_write_iv[12];\n  uint8_t server_finished_key[32];\n  uint8_t client_write_key[32];\n  uint8_t client_write_iv[12];\n  uint8_t client_finished_key[32];\n};\n\n// per-connection TLS data\nstruct tls_data {\n  enum mg_tls_hs_state state;  // keep track of connection handshake progress\n\n  struct mg_iobuf send;  // For the receive path, we're reusing c->rtls\n  size_t recv_offset;    // While c->rtls contains full records, reuse that\n  size_t recv_len;       // buffer but point at individual decrypted messages\n\n  uint8_t content_type;  // Last received record content type\n\n  mg_sha256_ctx sha256;  // incremental SHA-256 hash for TLS handshake\n\n  uint8_t random[32];      // client random from ClientHello\n  uint8_t session_id[32];  // client session ID between the handshake states\n  uint8_t x25519_cli[32];  // client X25519 key between the handshake states\n  uint8_t x25519_sec[32];  // x25519 secret between the handshake states\n\n  int skip_verification;   // perform checks on server certificate?\n  int cert_requested;      // client received a CertificateRequest?\n  struct mg_str cert_der;  // certificate in DER format\n  uint8_t ec_key[32];      // EC private key\n  char hostname[254];      // server hostname (client extension)\n\n  uint8_t certhash[32];  // certificate message hash\n  uint8_t pubkey[64];    // server EC public key to verify cert\n  uint8_t sighash[32];   // server EC public key to verify cert\n\n  struct tls_enc enc;\n};\n\n#define TLS_RECHDR_SIZE 5  // 1 byte type, 2 bytes version, 2 bytes length\n#define TLS_MSGHDR_SIZE 4  // 1 byte type, 3 bytes length\n\n#ifdef MG_TLS_SSLKEYLOGFILE\n#include <stdio.h>\nstatic void mg_ssl_key_log(const char *label, uint8_t client_random[32],\n                           uint8_t *secret, size_t secretsz) {\n  char *keylogfile = getenv(\"SSLKEYLOGFILE\");\n  size_t i;\n  if (keylogfile != NULL) {\n    MG_DEBUG((\"Dumping key log into %s\", keylogfile));\n    FILE *f = fopen(keylogfile, \"a\");\n    if (f != NULL) {\n      fprintf(f, \"%s \", label);\n      for (i = 0; i < 32; i++) {\n        fprintf(f, \"%02x\", client_random[i]);\n      }\n      fprintf(f, \" \");\n      for (i = 0; i < secretsz; i++) {\n        fprintf(f, \"%02x\", secret[i]);\n      }\n      fprintf(f, \"\\n\");\n      fclose(f);\n    } else {\n      MG_ERROR((\"Cannot open %s\", keylogfile));\n    }\n  }\n}\n#endif\n\n// for derived tls keys we need SHA256([0]*32)\nstatic uint8_t zeros[32] = {0};\nstatic uint8_t zeros_sha256_digest[32] = {\n    0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14, 0x9a, 0xfb, 0xf4,\n    0xc8, 0x99, 0x6f, 0xb9, 0x24, 0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b,\n    0x93, 0x4c, 0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55};\n\n// helper to hexdump buffers inline\nstatic void mg_tls_hexdump(const char *msg, uint8_t *buf, size_t bufsz) {\n  MG_VERBOSE((\"%s: %M\", msg, mg_print_hex, bufsz, buf));\n}\n\n// helper utilities to parse ASN.1 DER\nstruct mg_der_tlv {\n  uint8_t type;\n  uint32_t len;\n  uint8_t *value;\n};\n\n// parse DER into a TLV record\nstatic int mg_der_to_tlv(uint8_t *der, size_t dersz, struct mg_der_tlv *tlv) {\n  if (dersz < 2) {\n    return -1;\n  }\n  tlv->type = der[0];\n  tlv->len = der[1];\n  tlv->value = der + 2;\n  if (tlv->len > 0x7f) {\n    uint32_t i, n = tlv->len - 0x80;\n    tlv->len = 0;\n    for (i = 0; i < n; i++) {\n      tlv->len = (tlv->len << 8) | (der[2 + i]);\n    }\n    tlv->value = der + 2 + n;\n  }\n  if (der + dersz < tlv->value + tlv->len) {\n    return -1;\n  }\n  return 0;\n}\n\nstatic int mg_der_find(uint8_t *der, size_t dersz, uint8_t *oid, size_t oidsz,\n                       struct mg_der_tlv *tlv) {\n  uint8_t *p, *end;\n  struct mg_der_tlv child = {0, 0, NULL};\n  if (mg_der_to_tlv(der, dersz, tlv) < 0) {\n    return -1;                  // invalid DER\n  } else if (tlv->type == 6) {  // found OID, check value\n    return (tlv->len == oidsz && memcmp(tlv->value, oid, oidsz) == 0);\n  } else if ((tlv->type & 0x20) == 0) {\n    return 0;  // Primitive, but not OID: not found\n  }\n  // Constructed object: scan children\n  p = tlv->value;\n  end = tlv->value + tlv->len;\n  while (end > p) {\n    int r;\n    mg_der_to_tlv(p, (size_t) (end - p), &child);\n    r = mg_der_find(p, (size_t) (end - p), oid, oidsz, tlv);\n    if (r < 0) return -1;  // error\n    if (r > 0) return 1;   // found OID!\n    p = child.value + child.len;\n  }\n  return 0;  // not found\n}\n\n// Did we receive a full TLS record in the c->rtls buffer?\nstatic bool mg_tls_got_record(struct mg_connection *c) {\n  return c->rtls.len >= (size_t) TLS_RECHDR_SIZE &&\n         c->rtls.len >=\n             (size_t) (TLS_RECHDR_SIZE + MG_LOAD_BE16(c->rtls.buf + 3));\n}\n\n// Remove a single TLS record from the recv buffer\nstatic void mg_tls_drop_record(struct mg_connection *c) {\n  struct mg_iobuf *rio = &c->rtls;\n  uint16_t n = MG_LOAD_BE16(rio->buf + 3) + TLS_RECHDR_SIZE;\n  mg_iobuf_del(rio, 0, n);\n}\n\n// Remove a single TLS message from decrypted buffer, remove the wrapping\n// record if it was the last message within a record\nstatic void mg_tls_drop_message(struct mg_connection *c) {\n  uint32_t len;\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  unsigned char *recv_buf = &c->rtls.buf[tls->recv_offset];\n  if (tls->recv_len == 0) return;\n  len = MG_LOAD_BE24(recv_buf + 1) + TLS_MSGHDR_SIZE;\n  if (tls->recv_len < len) {\n    mg_error(c, \"wrong size\");\n    return;\n  }\n  mg_sha256_update(&tls->sha256, recv_buf, len);\n  tls->recv_offset += len;\n  tls->recv_len -= len;\n  if (tls->recv_len == 0) {\n    mg_tls_drop_record(c);\n  }\n}\n\n// TLS1.3 secret derivation based on the key label\nstatic void mg_tls_derive_secret(const char *label, uint8_t *key, size_t keysz,\n                                 uint8_t *data, size_t datasz, uint8_t *hash,\n                                 size_t hashsz) {\n  size_t labelsz = strlen(label);\n  uint8_t secret[32];\n  uint8_t packed[256] = {0, (uint8_t) hashsz, (uint8_t) labelsz};\n  // TODO: assert lengths of label, key, data and hash\n  if (labelsz > 0) memmove(packed + 3, label, labelsz);\n  packed[3 + labelsz] = (uint8_t) datasz;\n  if (datasz > 0) memmove(packed + labelsz + 4, data, datasz);\n  packed[4 + labelsz + datasz] = 1;\n\n  mg_hmac_sha256(secret, key, keysz, packed, 5 + labelsz + datasz);\n  memmove(hash, secret, hashsz);\n}\n\n// at this point we have x25519 shared secret, we can generate a set of derived\n// handshake encryption keys\nstatic void mg_tls_generate_handshake_keys(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n\n  mg_sha256_ctx sha256;\n  uint8_t early_secret[32];\n  uint8_t pre_extract_secret[32];\n  uint8_t hello_hash[32];\n  uint8_t server_hs_secret[32];\n  uint8_t client_hs_secret[32];\n#if CHACHA20\n  const size_t keysz = 32;\n#else\n  const size_t keysz = 16;\n#endif\n\n  mg_hmac_sha256(early_secret, NULL, 0, zeros, sizeof(zeros));\n  mg_tls_derive_secret(\"tls13 derived\", early_secret, 32, zeros_sha256_digest,\n                       32, pre_extract_secret, 32);\n  mg_hmac_sha256(tls->enc.handshake_secret, pre_extract_secret,\n                 sizeof(pre_extract_secret), tls->x25519_sec,\n                 sizeof(tls->x25519_sec));\n  mg_tls_hexdump(\"hs secret\", tls->enc.handshake_secret, 32);\n\n  // mg_sha256_final is not idempotent, need to copy sha256 context to calculate\n  // the digest\n  memmove(&sha256, &tls->sha256, sizeof(mg_sha256_ctx));\n  mg_sha256_final(hello_hash, &sha256);\n\n  mg_tls_hexdump(\"hello hash\", hello_hash, 32);\n  // derive keys needed for the rest of the handshake\n  mg_tls_derive_secret(\"tls13 s hs traffic\", tls->enc.handshake_secret, 32,\n                       hello_hash, 32, server_hs_secret, 32);\n  mg_tls_derive_secret(\"tls13 c hs traffic\", tls->enc.handshake_secret, 32,\n                       hello_hash, 32, client_hs_secret, 32);\n\n  mg_tls_derive_secret(\"tls13 key\", server_hs_secret, 32, NULL, 0,\n                       tls->enc.server_write_key, keysz);\n  mg_tls_derive_secret(\"tls13 iv\", server_hs_secret, 32, NULL, 0,\n                       tls->enc.server_write_iv, 12);\n  mg_tls_derive_secret(\"tls13 finished\", server_hs_secret, 32, NULL, 0,\n                       tls->enc.server_finished_key, 32);\n\n  mg_tls_derive_secret(\"tls13 key\", client_hs_secret, 32, NULL, 0,\n                       tls->enc.client_write_key, keysz);\n  mg_tls_derive_secret(\"tls13 iv\", client_hs_secret, 32, NULL, 0,\n                       tls->enc.client_write_iv, 12);\n  mg_tls_derive_secret(\"tls13 finished\", client_hs_secret, 32, NULL, 0,\n                       tls->enc.client_finished_key, 32);\n\n  mg_tls_hexdump(\"s hs traffic\", server_hs_secret, 32);\n  mg_tls_hexdump(\"s key\", tls->enc.server_write_key, keysz);\n  mg_tls_hexdump(\"s iv\", tls->enc.server_write_iv, 12);\n  mg_tls_hexdump(\"s finished\", tls->enc.server_finished_key, 32);\n  mg_tls_hexdump(\"c hs traffic\", client_hs_secret, 32);\n  mg_tls_hexdump(\"c key\", tls->enc.client_write_key, keysz);\n  mg_tls_hexdump(\"c iv\", tls->enc.client_write_iv, 12);\n  mg_tls_hexdump(\"c finished\", tls->enc.client_finished_key, 32);\n\n#ifdef MG_TLS_SSLKEYLOGFILE\n  mg_ssl_key_log(\"SERVER_HANDSHAKE_TRAFFIC_SECRET\", tls->random,\n                 server_hs_secret, 32);\n  mg_ssl_key_log(\"CLIENT_HANDSHAKE_TRAFFIC_SECRET\", tls->random,\n                 client_hs_secret, 32);\n#endif\n}\n\nstatic void mg_tls_generate_application_keys(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  uint8_t hash[32];\n  uint8_t premaster_secret[32];\n  uint8_t master_secret[32];\n  uint8_t server_secret[32];\n  uint8_t client_secret[32];\n#if CHACHA20\n  const size_t keysz = 32;\n#else\n  const size_t keysz = 16;\n#endif\n\n  mg_sha256_ctx sha256;\n  memmove(&sha256, &tls->sha256, sizeof(mg_sha256_ctx));\n  mg_sha256_final(hash, &sha256);\n\n  mg_tls_derive_secret(\"tls13 derived\", tls->enc.handshake_secret, 32,\n                       zeros_sha256_digest, 32, premaster_secret, 32);\n  mg_hmac_sha256(master_secret, premaster_secret, 32, zeros, 32);\n\n  mg_tls_derive_secret(\"tls13 s ap traffic\", master_secret, 32, hash, 32,\n                       server_secret, 32);\n  mg_tls_derive_secret(\"tls13 key\", server_secret, 32, NULL, 0,\n                       tls->enc.server_write_key, keysz);\n  mg_tls_derive_secret(\"tls13 iv\", server_secret, 32, NULL, 0,\n                       tls->enc.server_write_iv, 12);\n  mg_tls_derive_secret(\"tls13 c ap traffic\", master_secret, 32, hash, 32,\n                       client_secret, 32);\n  mg_tls_derive_secret(\"tls13 key\", client_secret, 32, NULL, 0,\n                       tls->enc.client_write_key, keysz);\n  mg_tls_derive_secret(\"tls13 iv\", client_secret, 32, NULL, 0,\n                       tls->enc.client_write_iv, 12);\n\n  mg_tls_hexdump(\"s ap traffic\", server_secret, 32);\n  mg_tls_hexdump(\"s key\", tls->enc.server_write_key, keysz);\n  mg_tls_hexdump(\"s iv\", tls->enc.server_write_iv, 12);\n  mg_tls_hexdump(\"s finished\", tls->enc.server_finished_key, 32);\n  mg_tls_hexdump(\"c ap traffic\", client_secret, 32);\n  mg_tls_hexdump(\"c key\", tls->enc.client_write_key, keysz);\n  mg_tls_hexdump(\"c iv\", tls->enc.client_write_iv, 12);\n  mg_tls_hexdump(\"c finished\", tls->enc.client_finished_key, 32);\n  tls->enc.sseq = tls->enc.cseq = 0;\n\n#ifdef MG_TLS_SSLKEYLOGFILE\n  mg_ssl_key_log(\"SERVER_TRAFFIC_SECRET_0\", tls->random, server_secret, 32);\n  mg_ssl_key_log(\"CLIENT_TRAFFIC_SECRET_0\", tls->random, client_secret, 32);\n#endif\n}\n\n// AES GCM encryption of the message + put encoded data into the write buffer\nstatic void mg_tls_encrypt(struct mg_connection *c, const uint8_t *msg,\n                           size_t msgsz, uint8_t msgtype) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  struct mg_iobuf *wio = &tls->send;\n  uint8_t *outmsg;\n  uint8_t *tag;\n  size_t encsz = msgsz + 16 + 1;\n  uint8_t hdr[5] = {MG_TLS_APP_DATA, 0x03, 0x03,\n                    (uint8_t) ((encsz >> 8) & 0xff), (uint8_t) (encsz & 0xff)};\n  uint8_t associated_data[5] = {MG_TLS_APP_DATA, 0x03, 0x03,\n                                (uint8_t) ((encsz >> 8) & 0xff),\n                                (uint8_t) (encsz & 0xff)};\n  uint8_t nonce[12];\n\n  uint32_t seq = c->is_client ? tls->enc.cseq : tls->enc.sseq;\n  uint8_t *key =\n      c->is_client ? tls->enc.client_write_key : tls->enc.server_write_key;\n  uint8_t *iv =\n      c->is_client ? tls->enc.client_write_iv : tls->enc.server_write_iv;\n\n#if !CHACHA20\n  mg_gcm_initialize();\n#endif\n\n  memmove(nonce, iv, sizeof(nonce));\n  nonce[8] ^= (uint8_t) ((seq >> 24) & 255U);\n  nonce[9] ^= (uint8_t) ((seq >> 16) & 255U);\n  nonce[10] ^= (uint8_t) ((seq >> 8) & 255U);\n  nonce[11] ^= (uint8_t) ((seq) &255U);\n\n  mg_iobuf_add(wio, wio->len, hdr, sizeof(hdr));\n  mg_iobuf_resize(wio, wio->len + encsz);\n  outmsg = wio->buf + wio->len;\n  tag = wio->buf + wio->len + msgsz + 1;\n  memmove(outmsg, msg, msgsz);\n  outmsg[msgsz] = msgtype;\n#if CHACHA20\n  (void) tag;  // tag is only used in aes gcm\n  {\n    size_t maxlen = MG_IO_SIZE > 16384 ? 16384 : MG_IO_SIZE;\n    uint8_t *enc = (uint8_t *) calloc(1, maxlen + 256 + 1);\n    if (enc == NULL) {\n      mg_error(c, \"TLS OOM\");\n      return;\n    } else {\n      size_t n = mg_chacha20_poly1305_encrypt(enc, key, nonce, associated_data,\n                                              sizeof(associated_data), outmsg,\n                                              msgsz + 1);\n      memmove(outmsg, enc, n);\n      free(enc);\n    }\n  }\n#else\n  mg_aes_gcm_encrypt(outmsg, outmsg, msgsz + 1, key, 16, nonce, sizeof(nonce),\n                     associated_data, sizeof(associated_data), tag, 16);\n#endif\n  c->is_client ? tls->enc.cseq++ : tls->enc.sseq++;\n  wio->len += encsz;\n}\n\n// read an encrypted record, decrypt it in place\nstatic int mg_tls_recv_record(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  struct mg_iobuf *rio = &c->rtls;\n  uint16_t msgsz;\n  uint8_t *msg;\n  uint8_t nonce[12];\n  int r;\n\n  uint32_t seq = c->is_client ? tls->enc.sseq : tls->enc.cseq;\n  uint8_t *key =\n      c->is_client ? tls->enc.server_write_key : tls->enc.client_write_key;\n  uint8_t *iv =\n      c->is_client ? tls->enc.server_write_iv : tls->enc.client_write_iv;\n\n  if (tls->recv_len > 0) {\n    return 0; /* some data from previous record is still present */\n  }\n  for (;;) {\n    if (!mg_tls_got_record(c)) {\n      return MG_IO_WAIT;\n    }\n    if (rio->buf[0] == MG_TLS_APP_DATA) {\n      break;\n    } else if (rio->buf[0] ==\n               MG_TLS_CHANGE_CIPHER) {  // Skip ChangeCipher messages\n      mg_tls_drop_record(c);\n    } else if (rio->buf[0] == MG_TLS_ALERT) {  // Skip Alerts\n      MG_INFO((\"TLS ALERT packet received\"));\n      mg_tls_drop_record(c);\n    } else {\n      mg_error(c, \"unexpected packet\");\n      return -1;\n    }\n  }\n\n  msgsz = MG_LOAD_BE16(rio->buf + 3);\n  msg = rio->buf + 5;\n  if (msgsz < 16) {\n    mg_error(c, \"wrong size\");\n    return -1;\n  }\n\n  memmove(nonce, iv, sizeof(nonce));\n  nonce[8] ^= (uint8_t) ((seq >> 24) & 255U);\n  nonce[9] ^= (uint8_t) ((seq >> 16) & 255U);\n  nonce[10] ^= (uint8_t) ((seq >> 8) & 255U);\n  nonce[11] ^= (uint8_t) ((seq) &255U);\n\n#if CHACHA20\n  {\n    uint8_t *dec = (uint8_t *) calloc(1, msgsz);\n    size_t n;\n    if (dec == NULL) {\n      mg_error(c, \"TLS OOM\");\n      return -1;\n    }\n    n = mg_chacha20_poly1305_decrypt(dec, key, nonce, msg, msgsz);\n    memmove(msg, dec, n);\n    free(dec);\n  }\n#else\n  mg_gcm_initialize();\n  mg_aes_gcm_decrypt(msg, msg, msgsz - 16, key, 16, nonce, sizeof(nonce));\n#endif\n\n  r = msgsz - 16 - 1;\n  tls->content_type = msg[msgsz - 16 - 1];\n  tls->recv_offset = (size_t) msg - (size_t) rio->buf;\n  tls->recv_len = msgsz - 16 - 1;\n  c->is_client ? tls->enc.sseq++ : tls->enc.cseq++;\n  return r;\n}\n\nstatic void mg_tls_calc_cert_verify_hash(struct mg_connection *c,\n                                         uint8_t hash[32], int is_client) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  uint8_t server_context[34] = \"TLS 1.3, server CertificateVerify\";\n  uint8_t client_context[34] = \"TLS 1.3, client CertificateVerify\";\n  uint8_t sig_content[130];\n  mg_sha256_ctx sha256;\n\n  memset(sig_content, 0x20, 64);\n  if (is_client) {\n    memmove(sig_content + 64, client_context, sizeof(client_context));\n  } else {\n    memmove(sig_content + 64, server_context, sizeof(server_context));\n  }\n\n  memmove(&sha256, &tls->sha256, sizeof(mg_sha256_ctx));\n  mg_sha256_final(sig_content + 98, &sha256);\n\n  mg_sha256_init(&sha256);\n  mg_sha256_update(&sha256, sig_content, sizeof(sig_content));\n  mg_sha256_final(hash, &sha256);\n}\n\n// read and parse ClientHello record\nstatic int mg_tls_server_recv_hello(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  struct mg_iobuf *rio = &c->rtls;\n  uint8_t session_id_len;\n  uint16_t j;\n  uint16_t cipher_suites_len;\n  uint16_t ext_len;\n  uint8_t *ext;\n  uint16_t msgsz;\n\n  if (!mg_tls_got_record(c)) {\n    return MG_IO_WAIT;\n  }\n  if (rio->buf[0] != MG_TLS_HANDSHAKE || rio->buf[5] != MG_TLS_CLIENT_HELLO) {\n    mg_error(c, \"not a client hello packet\");\n    return -1;\n  }\n  msgsz = MG_LOAD_BE16(rio->buf + 3);\n  mg_sha256_update(&tls->sha256, rio->buf + 5, msgsz);\n  // store client random\n  memmove(tls->random, rio->buf + 11, sizeof(tls->random));\n  // store session_id\n  session_id_len = rio->buf[43];\n  if (session_id_len == sizeof(tls->session_id)) {\n    memmove(tls->session_id, rio->buf + 44, session_id_len);\n  } else if (session_id_len != 0) {\n    MG_INFO((\"bad session id len\"));\n  }\n  cipher_suites_len = MG_LOAD_BE16(rio->buf + 44 + session_id_len);\n  if (cipher_suites_len > (rio->len - 46 - session_id_len)) goto fail;\n  ext_len = MG_LOAD_BE16(rio->buf + 48 + session_id_len + cipher_suites_len);\n  ext = rio->buf + 50 + session_id_len + cipher_suites_len;\n  if (ext_len > (rio->len - 50 - session_id_len - cipher_suites_len)) goto fail;\n  for (j = 0; j < ext_len;) {\n    uint16_t k;\n    uint16_t key_exchange_len;\n    uint8_t *key_exchange;\n    uint16_t n = MG_LOAD_BE16(ext + j + 2);\n    if (ext[j] != 0x00 ||\n        ext[j + 1] != 0x33) {  // not a key share extension, ignore\n      j += (uint16_t) (n + 4);\n      continue;\n    }\n    key_exchange_len = MG_LOAD_BE16(ext + j + 4);\n    key_exchange = ext + j + 6;\n    if (key_exchange_len >\n        rio->len - (uint16_t) ((size_t) key_exchange - (size_t) rio->buf) - 2)\n      goto fail;\n    for (k = 0; k < key_exchange_len;) {\n      uint16_t m = MG_LOAD_BE16(key_exchange + k + 2);\n      if (m > (key_exchange_len - k - 4)) goto fail;\n      if (m == 32 && key_exchange[k] == 0x00 && key_exchange[k + 1] == 0x1d) {\n        memmove(tls->x25519_cli, key_exchange + k + 4, m);\n        mg_tls_drop_record(c);\n        return 0;\n      }\n      k += (uint16_t) (m + 4);\n    }\n    j += (uint16_t) (n + 4);\n  }\nfail:\n  mg_error(c, \"bad client hello\");\n  return -1;\n}\n\n#define PLACEHOLDER_8B 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X'\n#define PLACEHOLDER_16B PLACEHOLDER_8B, PLACEHOLDER_8B\n#define PLACEHOLDER_32B PLACEHOLDER_16B, PLACEHOLDER_16B\n\n// put ServerHello record into wio buffer\nstatic void mg_tls_server_send_hello(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  struct mg_iobuf *wio = &tls->send;\n\n  // clang-format off\n  uint8_t msg_server_hello[122] = {\n      // server hello, tls 1.2\n      0x02, 0x00, 0x00, 0x76, 0x03, 0x03,\n      // random (32 bytes)\n      PLACEHOLDER_32B,\n      // session ID length + session ID (32 bytes)\n      0x20, PLACEHOLDER_32B,\n#if defined(CHACHA20) && CHACHA20\n      // TLS_CHACHA20_POLY1305_SHA256 + no compression\n      0x13, 0x03, 0x00,\n#else\n      // TLS_AES_128_GCM_SHA256 + no compression\n      0x13, 0x01, 0x00,\n#endif\n      // extensions + keyshare\n      0x00, 0x2e, 0x00, 0x33, 0x00, 0x24, 0x00, 0x1d, 0x00, 0x20,\n      // x25519 keyshare\n      PLACEHOLDER_32B,\n      // supported versions (tls1.3 == 0x304)\n      0x00, 0x2b, 0x00, 0x02, 0x03, 0x04};\n  // clang-format on\n\n  // calculate keyshare\n  uint8_t x25519_pub[X25519_BYTES];\n  uint8_t x25519_prv[X25519_BYTES];\n  if (!mg_random(x25519_prv, sizeof(x25519_prv))) mg_error(c, \"RNG\"); \n  mg_tls_x25519(x25519_pub, x25519_prv, X25519_BASE_POINT, 1);\n  mg_tls_x25519(tls->x25519_sec, x25519_prv, tls->x25519_cli, 1);\n  mg_tls_hexdump(\"s x25519 sec\", tls->x25519_sec, sizeof(tls->x25519_sec));\n\n  // fill in the gaps: random + session ID + keyshare\n  memmove(msg_server_hello + 6, tls->random, sizeof(tls->random));\n  memmove(msg_server_hello + 39, tls->session_id, sizeof(tls->session_id));\n  memmove(msg_server_hello + 84, x25519_pub, sizeof(x25519_pub));\n\n  // server hello message\n  mg_iobuf_add(wio, wio->len, \"\\x16\\x03\\x03\\x00\\x7a\", 5);\n  mg_iobuf_add(wio, wio->len, msg_server_hello, sizeof(msg_server_hello));\n  mg_sha256_update(&tls->sha256, msg_server_hello, sizeof(msg_server_hello));\n\n  // change cipher message\n  mg_iobuf_add(wio, wio->len, \"\\x14\\x03\\x03\\x00\\x01\\x01\", 6);\n}\n\nstatic void mg_tls_server_send_ext(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  // server extensions\n  uint8_t ext[6] = {0x08, 0, 0, 2, 0, 0};\n  mg_sha256_update(&tls->sha256, ext, sizeof(ext));\n  mg_tls_encrypt(c, ext, sizeof(ext), MG_TLS_HANDSHAKE);\n}\n\nstatic void mg_tls_server_send_cert(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  // server DER certificate (empty)\n  size_t n = tls->cert_der.len;\n  uint8_t *cert = (uint8_t *) calloc(1, 13 + n);\n  if (cert == NULL) {\n    mg_error(c, \"tls cert oom\");\n    return;\n  }\n  cert[0] = 0x0b;                                // handshake header\n  cert[1] = (uint8_t) (((n + 9) >> 16) & 255U);  // 3 bytes: payload length\n  cert[2] = (uint8_t) (((n + 9) >> 8) & 255U);\n  cert[3] = (uint8_t) ((n + 9) & 255U);\n  cert[4] = 0;                                   // request context\n  cert[5] = (uint8_t) (((n + 5) >> 16) & 255U);  // 3 bytes: cert (s) length\n  cert[6] = (uint8_t) (((n + 5) >> 8) & 255U);\n  cert[7] = (uint8_t) ((n + 5) & 255U);\n  cert[8] =\n      (uint8_t) (((n) >> 16) & 255U);  // 3 bytes: first (and only) cert len\n  cert[9] = (uint8_t) (((n) >> 8) & 255U);\n  cert[10] = (uint8_t) (n & 255U);\n  // bytes 11+ are certificate in DER format\n  memmove(cert + 11, tls->cert_der.buf, n);\n  cert[11 + n] = cert[12 + n] = 0;  // certificate extensions (none)\n  mg_sha256_update(&tls->sha256, cert, 13 + n);\n  mg_tls_encrypt(c, cert, 13 + n, MG_TLS_HANDSHAKE);\n  free(cert);\n}\n\n// type adapter between uECC hash context and our sha256 implementation\ntypedef struct SHA256_HashContext {\n  MG_UECC_HashContext uECC;\n  mg_sha256_ctx ctx;\n} SHA256_HashContext;\n\nstatic void init_SHA256(const MG_UECC_HashContext *base) {\n  SHA256_HashContext *c = (SHA256_HashContext *) base;\n  mg_sha256_init(&c->ctx);\n}\n\nstatic void update_SHA256(const MG_UECC_HashContext *base,\n                          const uint8_t *message, unsigned message_size) {\n  SHA256_HashContext *c = (SHA256_HashContext *) base;\n  mg_sha256_update(&c->ctx, message, message_size);\n}\nstatic void finish_SHA256(const MG_UECC_HashContext *base,\n                          uint8_t *hash_result) {\n  SHA256_HashContext *c = (SHA256_HashContext *) base;\n  mg_sha256_final(hash_result, &c->ctx);\n}\n\nstatic void mg_tls_send_cert_verify(struct mg_connection *c, int is_client) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  // server certificate verify packet\n  uint8_t verify[82] = {0x0f, 0x00, 0x00, 0x00, 0x04, 0x03, 0x00, 0x00};\n  size_t sigsz, verifysz = 0;\n  uint8_t hash[32] = {0}, tmp[2 * 32 + 64] = {0};\n  struct SHA256_HashContext ctx = {\n      {&init_SHA256, &update_SHA256, &finish_SHA256, 64, 32, tmp},\n      {{0}, 0, 0, {0}}};\n  int neg1, neg2;\n  uint8_t sig[64] = {0};\n\n  mg_tls_calc_cert_verify_hash(c, (uint8_t *) hash, is_client);\n\n  mg_uecc_sign_deterministic(tls->ec_key, hash, sizeof(hash), &ctx.uECC, sig,\n                             mg_uecc_secp256r1());\n\n  neg1 = !!(sig[0] & 0x80);\n  neg2 = !!(sig[32] & 0x80);\n  verify[8] = 0x30;  // ASN.1 SEQUENCE\n  verify[9] = (uint8_t) (68 + neg1 + neg2);\n  verify[10] = 0x02;  // ASN.1 INTEGER\n  verify[11] = (uint8_t) (32 + neg1);\n  memmove(verify + 12 + neg1, sig, 32);\n  verify[12 + 32 + neg1] = 0x02;  // ASN.1 INTEGER\n  verify[13 + 32 + neg1] = (uint8_t) (32 + neg2);\n  memmove(verify + 14 + 32 + neg1 + neg2, sig + 32, 32);\n\n  sigsz = (size_t) (70 + neg1 + neg2);\n  verifysz = 8U + sigsz;\n  verify[3] = (uint8_t) (sigsz + 4);\n  verify[7] = (uint8_t) sigsz;\n\n  mg_sha256_update(&tls->sha256, verify, verifysz);\n  mg_tls_encrypt(c, verify, verifysz, MG_TLS_HANDSHAKE);\n}\n\nstatic void mg_tls_server_send_finish(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  struct mg_iobuf *wio = &tls->send;\n  mg_sha256_ctx sha256;\n  uint8_t hash[32];\n  uint8_t finish[36] = {0x14, 0, 0, 32};\n  memmove(&sha256, &tls->sha256, sizeof(mg_sha256_ctx));\n  mg_sha256_final(hash, &sha256);\n  mg_hmac_sha256(finish + 4, tls->enc.server_finished_key, 32, hash, 32);\n  mg_tls_encrypt(c, finish, sizeof(finish), MG_TLS_HANDSHAKE);\n  mg_io_send(c, wio->buf, wio->len);\n  wio->len = 0;\n\n  mg_sha256_update(&tls->sha256, finish, sizeof(finish));\n}\n\nstatic int mg_tls_server_recv_finish(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  unsigned char *recv_buf;\n  // we have to backup sha256 value to restore it later, since Finished record\n  // is exceptional and is not supposed to be added to the rolling hash\n  // calculation.\n  mg_sha256_ctx sha256 = tls->sha256;\n  if (mg_tls_recv_record(c) < 0) {\n    return -1;\n  }\n  recv_buf = &c->rtls.buf[tls->recv_offset];\n  if (recv_buf[0] != MG_TLS_FINISHED) {\n    mg_error(c, \"expected Finish but got msg 0x%02x\", recv_buf[0]);\n    return -1;\n  }\n  mg_tls_drop_message(c);\n\n  // restore hash\n  tls->sha256 = sha256;\n  return 0;\n}\n\nstatic void mg_tls_client_send_hello(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  struct mg_iobuf *wio = &tls->send;\n\n  uint8_t x25519_pub[X25519_BYTES];\n\n  // the only signature algorithm we actually support\n  uint8_t secp256r1_sig_algs[8] = {\n      0x00, 0x0d, 0x00, 0x04, 0x00, 0x02, 0x04, 0x03,\n  };\n  // all popular signature algorithms (if we don't care about verification)\n  uint8_t all_sig_algs[34] = {\n      0x00, 0x0d, 0x00, 0x1e, 0x00, 0x1c, 0x04, 0x03, 0x05, 0x03, 0x06, 0x03,\n      0x08, 0x07, 0x08, 0x08, 0x08, 0x09, 0x08, 0x0a, 0x08, 0x0b, 0x08, 0x04,\n      0x08, 0x05, 0x08, 0x06, 0x04, 0x01, 0x05, 0x01, 0x06, 0x01};\n  uint8_t server_name_ext[9] = {0x00, 0x00, 0x00, 0xfe, 0x00,\n                                0xfe, 0x00, 0x00, 0xfe};\n\n  // clang-format off\n  uint8_t msg_client_hello[145] = {\n      // TLS Client Hello header reported as TLS1.2 (5)\n      0x16, 0x03, 0x03, 0x00, 0xfe,\n      // client hello, tls 1.2 (6)\n      0x01, 0x00, 0x00, 0x8c, 0x03, 0x03,\n      // random (32 bytes)\n      PLACEHOLDER_32B,\n      // session ID length + session ID (32 bytes)\n      0x20, PLACEHOLDER_32B, 0x00,\n      0x02,  // size = 2 bytes\n#if defined(CHACHA20) && CHACHA20\n      // TLS_CHACHA20_POLY1305_SHA256\n      0x13, 0x03,\n#else\n      // TLS_AES_128_GCM_SHA256\n      0x13, 0x01,\n#endif\n      // no compression\n      0x01, 0x00,\n      // extensions + keyshare\n      0x00, 0xfe,\n      // x25519 keyshare\n      0x00, 0x33, 0x00, 0x26, 0x00, 0x24, 0x00, 0x1d, 0x00, 0x20,\n      PLACEHOLDER_32B,\n      // supported groups (x25519)\n      0x00, 0x0a, 0x00, 0x04, 0x00, 0x02, 0x00, 0x1d,\n      // supported versions (tls1.3 == 0x304)\n      0x00, 0x2b, 0x00, 0x03, 0x02, 0x03, 0x04,\n      // session ticket (none)\n      0x00, 0x23, 0x00, 0x00, // 144 bytes till here\n\t};\n  // clang-format on\n  const char *hostname = tls->hostname;\n  size_t hostnamesz = strlen(tls->hostname);\n  size_t hostname_extsz = hostnamesz ? hostnamesz + 9 : 0;\n  uint8_t *sig_alg = tls->skip_verification ? all_sig_algs : secp256r1_sig_algs;\n  size_t sig_alg_sz = tls->skip_verification ? sizeof(all_sig_algs)\n                                             : sizeof(secp256r1_sig_algs);\n\n  // patch ClientHello with correct hostname ext length (if any)\n  MG_STORE_BE16(msg_client_hello + 3,\n                hostname_extsz + 183 - 9 - 34 + sig_alg_sz);\n  MG_STORE_BE16(msg_client_hello + 7,\n                hostname_extsz + 179 - 9 - 34 + sig_alg_sz);\n  MG_STORE_BE16(msg_client_hello + 82,\n                hostname_extsz + 104 - 9 - 34 + sig_alg_sz);\n\n  if (hostnamesz > 0) {\n    MG_STORE_BE16(server_name_ext + 2, hostnamesz + 5);\n    MG_STORE_BE16(server_name_ext + 4, hostnamesz + 3);\n    MG_STORE_BE16(server_name_ext + 7, hostnamesz);\n  }\n\n  // calculate keyshare\n  if (!mg_random(tls->x25519_cli, sizeof(tls->x25519_cli))) mg_error(c, \"RNG\");\n  mg_tls_x25519(x25519_pub, tls->x25519_cli, X25519_BASE_POINT, 1);\n\n  // fill in the gaps: random + session ID + keyshare\n  if (!mg_random(tls->session_id, sizeof(tls->session_id))) mg_error(c, \"RNG\");\n  if (!mg_random(tls->random, sizeof(tls->random))) mg_error(c, \"RNG\");\n  memmove(msg_client_hello + 11, tls->random, sizeof(tls->random));\n  memmove(msg_client_hello + 44, tls->session_id, sizeof(tls->session_id));\n  memmove(msg_client_hello + 94, x25519_pub, sizeof(x25519_pub));\n\n  // client hello message\n  mg_iobuf_add(wio, wio->len, msg_client_hello, sizeof(msg_client_hello));\n  mg_sha256_update(&tls->sha256, msg_client_hello + 5,\n                   sizeof(msg_client_hello) - 5);\n  mg_iobuf_add(wio, wio->len, sig_alg, sig_alg_sz);\n  mg_sha256_update(&tls->sha256, sig_alg, sig_alg_sz);\n  if (hostnamesz > 0) {\n    mg_iobuf_add(wio, wio->len, server_name_ext, sizeof(server_name_ext));\n    mg_iobuf_add(wio, wio->len, hostname, hostnamesz);\n    mg_sha256_update(&tls->sha256, server_name_ext, sizeof(server_name_ext));\n    mg_sha256_update(&tls->sha256, (uint8_t *) hostname, hostnamesz);\n  }\n\n  // change cipher message\n  mg_iobuf_add(wio, wio->len, (const char *) \"\\x14\\x03\\x03\\x00\\x01\\x01\", 6);\n  mg_io_send(c, wio->buf, wio->len);\n  wio->len = 0;\n}\n\nstatic int mg_tls_client_recv_hello(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  struct mg_iobuf *rio = &c->rtls;\n  uint16_t msgsz;\n  uint8_t *ext;\n  uint16_t ext_len;\n  int j;\n\n  if (!mg_tls_got_record(c)) {\n    return MG_IO_WAIT;\n  }\n  if (rio->buf[0] != MG_TLS_HANDSHAKE || rio->buf[5] != MG_TLS_SERVER_HELLO) {\n    if (rio->buf[0] == MG_TLS_ALERT && rio->len >= 7) {\n      mg_error(c, \"tls alert %d\", rio->buf[6]);\n      return -1;\n    }\n    MG_INFO((\"got packet type 0x%02x/0x%02x\", rio->buf[0], rio->buf[5]));\n    mg_error(c, \"not a server hello packet\");\n    return -1;\n  }\n\n  msgsz = MG_LOAD_BE16(rio->buf + 3);\n  mg_sha256_update(&tls->sha256, rio->buf + 5, msgsz);\n\n  ext_len = MG_LOAD_BE16(rio->buf + 5 + 39 + 32 + 3);\n  ext = rio->buf + 5 + 39 + 32 + 3 + 2;\n  if (ext_len > (rio->len - (5 + 39 + 32 + 3 + 2))) goto fail;\n\n  for (j = 0; j < ext_len;) {\n    uint16_t ext_type = MG_LOAD_BE16(ext + j);\n    uint16_t ext_len2 = MG_LOAD_BE16(ext + j + 2);\n    uint16_t group;\n    uint8_t *key_exchange;\n    uint16_t key_exchange_len;\n    if (ext_len2 > (ext_len - j - 4)) goto fail;\n    if (ext_type != 0x0033) {  // not a key share extension, ignore\n      j += (uint16_t) (ext_len2 + 4);\n      continue;\n    }\n    group = MG_LOAD_BE16(ext + j + 4);\n    if (group != 0x001d) {\n      mg_error(c, \"bad key exchange group\");\n      return -1;\n    }\n    key_exchange_len = MG_LOAD_BE16(ext + j + 6);\n    key_exchange = ext + j + 8;\n    if (key_exchange_len != 32) {\n      mg_error(c, \"bad key exchange length\");\n      return -1;\n    }\n    mg_tls_x25519(tls->x25519_sec, tls->x25519_cli, key_exchange, 1);\n    mg_tls_hexdump(\"c x25519 sec\", tls->x25519_sec, 32);\n    mg_tls_drop_record(c);\n    /* generate handshake keys */\n    mg_tls_generate_handshake_keys(c);\n    return 0;\n  }\nfail:\n  mg_error(c, \"bad client hello\");\n  return -1;\n}\n\nstatic int mg_tls_client_recv_ext(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  unsigned char *recv_buf;\n  if (mg_tls_recv_record(c) < 0) {\n    return -1;\n  }\n  recv_buf = &c->rtls.buf[tls->recv_offset];\n  if (recv_buf[0] != MG_TLS_ENCRYPTED_EXTENSIONS) {\n    mg_error(c, \"expected server extensions but got msg 0x%02x\", recv_buf[0]);\n    return -1;\n  }\n  mg_tls_drop_message(c);\n  return 0;\n}\n\nstatic int mg_tls_client_recv_cert(struct mg_connection *c) {\n  uint8_t *cert;\n  uint32_t certsz;\n  struct mg_der_tlv oid, pubkey, seq, subj;\n  int subj_match = 0;\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  unsigned char *recv_buf;\n  if (mg_tls_recv_record(c) < 0) {\n    return -1;\n  }\n  recv_buf = &c->rtls.buf[tls->recv_offset];\n  if (recv_buf[0] == MG_TLS_CERTIFICATE_REQUEST) {\n    MG_VERBOSE((\"got certificate request\"));\n    mg_tls_drop_message(c);\n    tls->cert_requested = 1;\n    return -1;\n  }\n  if (recv_buf[0] != MG_TLS_CERTIFICATE) {\n    mg_error(c, \"expected server certificate but got msg 0x%02x\", recv_buf[0]);\n    return -1;\n  }\n  if (tls->skip_verification) {\n    mg_tls_drop_message(c);\n    return 0;\n  }\n\n  if (tls->recv_len < 11) {\n    mg_error(c, \"certificate list too short\");\n    return -1;\n  }\n\n  cert = recv_buf + 11;\n  certsz = MG_LOAD_BE24(recv_buf + 8);\n  if (certsz > tls->recv_len - 11) {\n    mg_error(c, \"certificate too long: %d vs %d\", certsz, tls->recv_len - 11);\n    return -1;\n  }\n\n  do {\n    // secp256r1 public key\n    if (mg_der_find(cert, certsz,\n                    (uint8_t *) \"\\x2A\\x86\\x48\\xCE\\x3D\\x03\\x01\\x07\", 8,\n                    &oid) < 0) {\n      mg_error(c, \"certificate secp256r1 public key OID not found\");\n      return -1;\n    }\n    if (mg_der_to_tlv(oid.value + oid.len,\n                      (size_t) (cert + certsz - (oid.value + oid.len)),\n                      &pubkey) < 0) {\n      mg_error(c, \"certificate secp256r1 public key not found\");\n      return -1;\n    }\n\n    // expect BIT STRING, unpadded, uncompressed: [0]+[4]+32+32 content bytes\n    if (pubkey.type != 3 || pubkey.len != 66 || pubkey.value[0] != 0 ||\n        pubkey.value[1] != 4) {\n      mg_error(c, \"unsupported public key bitstring encoding\");\n      return -1;\n    }\n    memmove(tls->pubkey, pubkey.value + 2, pubkey.len - 2);\n  } while (0);\n\n  // Subject Alternative Names\n  do {\n    if (mg_der_find(cert, certsz, (uint8_t *) \"\\x55\\x1d\\x11\", 3, &oid) < 0) {\n      mg_error(c, \"certificate does not contain subject alternative names\");\n      return -1;\n    }\n    if (mg_der_to_tlv(oid.value + oid.len,\n                      (size_t) (cert + certsz - (oid.value + oid.len)),\n                      &seq) < 0) {\n      mg_error(c, \"certificate subject alternative names not found\");\n      return -1;\n    }\n    if (mg_der_to_tlv(seq.value, seq.len, &seq) < 0) {\n      mg_error(\n          c,\n          \"certificate subject alternative names is not a constructed object\");\n      return -1;\n    }\n    MG_VERBOSE((\"verify hostname %s\", tls->hostname));\n    while (seq.len > 0) {\n      if (mg_der_to_tlv(seq.value, seq.len, &subj) < 0) {\n        mg_error(c, \"bad subject alternative name\");\n        return -1;\n      }\n      MG_VERBOSE((\"subj=%.*s\", subj.len, subj.value));\n      if (mg_match(mg_str((const char *) tls->hostname),\n                   mg_str_n((const char *) subj.value, subj.len), NULL)) {\n        subj_match = 1;\n        break;\n      }\n      seq.len = (uint32_t) (seq.value + seq.len - (subj.value + subj.len));\n      seq.value = subj.value + subj.len;\n    }\n    if (!subj_match) {\n      mg_error(c, \"certificate did not match the hostname\");\n      return -1;\n    }\n  } while (0);\n\n  mg_tls_drop_message(c);\n  mg_tls_calc_cert_verify_hash(c, tls->sighash, 0);\n  return 0;\n}\n\nstatic int mg_tls_client_recv_cert_verify(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  unsigned char *recv_buf;\n  if (mg_tls_recv_record(c) < 0) {\n    return -1;\n  }\n  recv_buf = &c->rtls.buf[tls->recv_offset];\n  if (recv_buf[0] != MG_TLS_CERTIFICATE_VERIFY) {\n    mg_error(c, \"expected server certificate verify but got msg 0x%02x\", recv_buf[0]);\n    return -1;\n  }\n  // Ignore CertificateVerify is strict checks are not required\n  if (tls->skip_verification) {\n    mg_tls_drop_message(c);\n    return 0;\n  }\n\n  // Extract certificate signature and verify it using pubkey and sighash\n  do {\n    uint8_t sig[64];\n    struct mg_der_tlv seq, a, b;\n    if (mg_der_to_tlv(recv_buf + 8, tls->recv_len - 8, &seq) < 0) {\n      mg_error(c, \"verification message is not an ASN.1 DER sequence\");\n      return -1;\n    }\n    if (mg_der_to_tlv(seq.value, seq.len, &a) < 0) {\n      mg_error(c, \"missing first part of the signature\");\n      return -1;\n    }\n    if (mg_der_to_tlv(a.value + a.len, seq.len - a.len, &b) < 0) {\n      mg_error(c, \"missing second part of the signature\");\n      return -1;\n    }\n    // Integers may be padded with zeroes\n    if (a.len > 32) {\n      a.value = a.value + (a.len - 32);\n      a.len = 32;\n    }\n    if (b.len > 32) {\n      b.value = b.value + (b.len - 32);\n      b.len = 32;\n    }\n\n    memmove(sig, a.value, a.len);\n    memmove(sig + 32, b.value, b.len);\n\n    if (mg_uecc_verify(tls->pubkey, tls->sighash, sizeof(tls->sighash), sig,\n                       mg_uecc_secp256r1()) != 1) {\n      mg_error(c, \"failed to verify certificate\");\n      return -1;\n    }\n  } while (0);\n\n  mg_tls_drop_message(c);\n  return 0;\n}\n\nstatic int mg_tls_client_recv_finish(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  unsigned char *recv_buf;\n  if (mg_tls_recv_record(c) < 0) {\n    return -1;\n  }\n  recv_buf = &c->rtls.buf[tls->recv_offset];\n  if (recv_buf[0] != MG_TLS_FINISHED) {\n    mg_error(c, \"expected server finished but got msg 0x%02x\", recv_buf[0]);\n    return -1;\n  }\n  mg_tls_drop_message(c);\n  return 0;\n}\n\nstatic void mg_tls_client_send_finish(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  struct mg_iobuf *wio = &tls->send;\n  mg_sha256_ctx sha256;\n  uint8_t hash[32];\n  uint8_t finish[36] = {0x14, 0, 0, 32};\n  memmove(&sha256, &tls->sha256, sizeof(mg_sha256_ctx));\n  mg_sha256_final(hash, &sha256);\n  mg_hmac_sha256(finish + 4, tls->enc.client_finished_key, 32, hash, 32);\n  mg_tls_encrypt(c, finish, sizeof(finish), MG_TLS_HANDSHAKE);\n  mg_io_send(c, wio->buf, wio->len);\n  wio->len = 0;\n}\n\nstatic void mg_tls_client_handshake(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  switch (tls->state) {\n    case MG_TLS_STATE_CLIENT_START:\n      mg_tls_client_send_hello(c);\n      tls->state = MG_TLS_STATE_CLIENT_WAIT_SH;\n      // Fallthrough\n    case MG_TLS_STATE_CLIENT_WAIT_SH:\n      if (mg_tls_client_recv_hello(c) < 0) {\n        break;\n      }\n      tls->state = MG_TLS_STATE_CLIENT_WAIT_EE;\n      // Fallthrough\n    case MG_TLS_STATE_CLIENT_WAIT_EE:\n      if (mg_tls_client_recv_ext(c) < 0) {\n        break;\n      }\n      tls->state = MG_TLS_STATE_CLIENT_WAIT_CERT;\n      // Fallthrough\n    case MG_TLS_STATE_CLIENT_WAIT_CERT:\n      if (mg_tls_client_recv_cert(c) < 0) {\n        break;\n      }\n      tls->state = MG_TLS_STATE_CLIENT_WAIT_CV;\n      // Fallthrough\n    case MG_TLS_STATE_CLIENT_WAIT_CV:\n      if (mg_tls_client_recv_cert_verify(c) < 0) {\n        break;\n      }\n      tls->state = MG_TLS_STATE_CLIENT_WAIT_FINISHED;\n      // Fallthrough\n    case MG_TLS_STATE_CLIENT_WAIT_FINISHED:\n      if (mg_tls_client_recv_finish(c) < 0) {\n        break;\n      }\n      if (tls->cert_requested) {\n        /* for mTLS we should generate application keys at this point\n         * but then restore handshake keys and continue with\n         * the rest of the handshake */\n        struct tls_enc app_keys;\n        struct tls_enc hs_keys = tls->enc;\n        mg_tls_generate_application_keys(c);\n        app_keys = tls->enc;\n        tls->enc = hs_keys;\n        mg_tls_server_send_cert(c);\n        mg_tls_send_cert_verify(c, 1);\n        mg_tls_client_send_finish(c);\n        tls->enc = app_keys;\n      } else {\n        mg_tls_client_send_finish(c);\n        mg_tls_generate_application_keys(c);\n      }\n      tls->state = MG_TLS_STATE_CLIENT_CONNECTED;\n      c->is_tls_hs = 0;\n      break;\n    default:\n      mg_error(c, \"unexpected client state: %d\", tls->state);\n      break;\n  }\n}\n\nstatic void mg_tls_server_handshake(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  switch (tls->state) {\n    case MG_TLS_STATE_SERVER_START:\n      if (mg_tls_server_recv_hello(c) < 0) {\n        return;\n      }\n      mg_tls_server_send_hello(c);\n      mg_tls_generate_handshake_keys(c);\n      mg_tls_server_send_ext(c);\n      mg_tls_server_send_cert(c);\n      mg_tls_send_cert_verify(c, 0);\n      mg_tls_server_send_finish(c);\n      tls->state = MG_TLS_STATE_SERVER_NEGOTIATED;\n      // fallthrough\n    case MG_TLS_STATE_SERVER_NEGOTIATED:\n      if (mg_tls_server_recv_finish(c) < 0) {\n        return;\n      }\n      mg_tls_generate_application_keys(c);\n      tls->state = MG_TLS_STATE_SERVER_CONNECTED;\n      c->is_tls_hs = 0;\n      return;\n    default:\n      mg_error(c, \"unexpected server state: %d\", tls->state);\n      break;\n  }\n}\n\nvoid mg_tls_handshake(struct mg_connection *c) {\n  if (c->is_client) {\n    mg_tls_client_handshake(c);\n  } else {\n    mg_tls_server_handshake(c);\n  }\n}\n\nstatic int mg_parse_pem(const struct mg_str pem, const struct mg_str label,\n                        struct mg_str *der) {\n  size_t n = 0, m = 0;\n  char *s;\n  const char *c;\n  struct mg_str caps[6];  // number of wildcards + 1\n  if (!mg_match(pem, mg_str(\"#-----BEGIN #-----#-----END #-----#\"), caps)) {\n    *der = mg_strdup(pem);\n    return 0;\n  }\n  if (mg_strcmp(caps[1], label) != 0 || mg_strcmp(caps[3], label) != 0) {\n    return -1;  // bad label\n  }\n  if ((s = (char *) calloc(1, caps[2].len)) == NULL) {\n    return -1;\n  }\n\n  for (c = caps[2].buf; c < caps[2].buf + caps[2].len; c++) {\n    if (*c == ' ' || *c == '\\n' || *c == '\\r' || *c == '\\t') {\n      continue;\n    }\n    s[n++] = *c;\n  }\n  m = mg_base64_decode(s, n, s, n);\n  if (m == 0) {\n    free(s);\n    return -1;\n  }\n  der->buf = s;\n  der->len = m;\n  return 0;\n}\n\nvoid mg_tls_init(struct mg_connection *c, const struct mg_tls_opts *opts) {\n  struct mg_str key;\n  struct tls_data *tls = (struct tls_data *) calloc(1, sizeof(struct tls_data));\n  if (tls == NULL) {\n    mg_error(c, \"tls oom\");\n    return;\n  }\n\n  tls->state =\n      c->is_client ? MG_TLS_STATE_CLIENT_START : MG_TLS_STATE_SERVER_START;\n\n  tls->skip_verification = opts->skip_verification;\n  //tls->send.align = MG_IO_SIZE;\n\n  c->tls = tls;\n  c->is_tls = c->is_tls_hs = 1;\n  mg_sha256_init(&tls->sha256);\n\n  // save hostname (client extension)\n  if (opts->name.len > 0) {\n    if (opts->name.len >= sizeof(tls->hostname) - 1) {\n      mg_error(c, \"hostname too long\");\n      return;\n    }\n    strncpy((char *) tls->hostname, opts->name.buf, sizeof(tls->hostname) - 1);\n    tls->hostname[opts->name.len] = 0;\n  }\n\n  if (opts->cert.buf == NULL) {\n    MG_VERBOSE((\"no certificate provided\"));\n    return;\n  }\n\n  // parse PEM or DER certificate\n  if (mg_parse_pem(opts->cert, mg_str_s(\"CERTIFICATE\"), &tls->cert_der) < 0) {\n    MG_ERROR((\"Failed to load certificate\"));\n    return;\n  }\n\n  // parse PEM or DER EC key\n  if (opts->key.buf == NULL) {\n    mg_error(c, \"certificate provided without a private key\");\n    return;\n  }\n\n  if (mg_parse_pem(opts->key, mg_str_s(\"EC PRIVATE KEY\"), &key) == 0) {\n    if (key.len < 39) {\n      MG_ERROR((\"EC private key too short\"));\n      return;\n    }\n    // expect ASN.1 SEQUENCE=[INTEGER=1, BITSTRING of 32 bytes, ...]\n    // 30 nn 02 01 01 04 20 [key] ...\n    if (key.buf[0] != 0x30 || (key.buf[1] & 0x80) != 0) {\n      MG_ERROR((\"EC private key: ASN.1 bad sequence\"));\n      return;\n    }\n    if (memcmp(key.buf + 2, \"\\x02\\x01\\x01\\x04\\x20\", 5) != 0) {\n      MG_ERROR((\"EC private key: ASN.1 bad data\"));\n    }\n    memmove(tls->ec_key, key.buf + 7, 32);\n    free((void *) key.buf);\n  } else if (mg_parse_pem(opts->key, mg_str_s(\"PRIVATE KEY\"), &key) == 0) {\n    mg_error(c, \"PKCS8 private key format is not supported\");\n  } else {\n    mg_error(c, \"expected EC PRIVATE KEY or PRIVATE KEY\");\n  }\n}\n\nvoid mg_tls_free(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  if (tls != NULL) {\n    mg_iobuf_free(&tls->send);\n    free((void *) tls->cert_der.buf);\n  }\n  free(c->tls);\n  c->tls = NULL;\n}\n\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  long n = MG_IO_WAIT;\n  if (len > MG_IO_SIZE) len = MG_IO_SIZE;\n  if (len > 16384) len = 16384;\n  mg_tls_encrypt(c, (const uint8_t *) buf, len, MG_TLS_APP_DATA);\n  while (tls->send.len > 0 &&\n         (n = mg_io_send(c, tls->send.buf, tls->send.len)) > 0) {\n    mg_iobuf_del(&tls->send, 0, (size_t) n);\n  }\n  if (n == MG_IO_ERR || n == MG_IO_WAIT) return n;\n  return (long) len;\n}\n\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  int r = 0;\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  unsigned char *recv_buf;\n  size_t minlen;\n\n  r = mg_tls_recv_record(c);\n  if (r < 0) {\n    return r;\n  }\n  recv_buf = &c->rtls.buf[tls->recv_offset];\n\n  if (tls->content_type != MG_TLS_APP_DATA) {\n    tls->recv_len = 0;\n    mg_tls_drop_record(c);\n    return MG_IO_WAIT;\n  }\n  minlen = len < tls->recv_len ? len : tls->recv_len;\n  memmove(buf, recv_buf, minlen);\n  tls->recv_offset += minlen;\n  tls->recv_len -= minlen;\n  if (tls->recv_len == 0) {\n    mg_tls_drop_record(c);\n  }\n  return (long) minlen;\n}\n\nsize_t mg_tls_pending(struct mg_connection *c) {\n  struct tls_data *tls = (struct tls_data *) c->tls;\n  return tls != NULL ? tls->recv_len : 0;\n}\n\nvoid mg_tls_ctx_init(struct mg_mgr *mgr) {\n  (void) mgr;\n}\n\nvoid mg_tls_ctx_free(struct mg_mgr *mgr) {\n  (void) mgr;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_chacha20.c\"\n#endif\n// portable8439 v1.0.1\n// Source: https://github.com/DavyLandman/portable8439\n// Licensed under CC0-1.0\n// Contains poly1305-donna e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781 (Public\n// Domain)\n\n\n\n\n#if MG_TLS == MG_TLS_BUILTIN\n// ******* BEGIN: chacha-portable/chacha-portable.h ********\n\n#if !defined(__cplusplus) && !defined(_MSC_VER) && \\\n    (!defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L)\n#error \"C99 or newer required\"\n#endif\n\n#define CHACHA20_KEY_SIZE (32)\n#define CHACHA20_NONCE_SIZE (12)\n\n#if defined(_MSC_VER) || defined(__cplusplus)\n// add restrict support\n#if (defined(_MSC_VER) && _MSC_VER >= 1900) || defined(__clang__) || \\\n    defined(__GNUC__)\n#define restrict __restrict\n#else\n#define restrict\n#endif\n#endif\n\n// xor data with a ChaCha20 keystream as per RFC8439\nstatic PORTABLE_8439_DECL void chacha20_xor_stream(\n    uint8_t *restrict dest, const uint8_t *restrict source, size_t length,\n    const uint8_t key[CHACHA20_KEY_SIZE],\n    const uint8_t nonce[CHACHA20_NONCE_SIZE], uint32_t counter);\n\nstatic PORTABLE_8439_DECL void rfc8439_keygen(\n    uint8_t poly_key[32], const uint8_t key[CHACHA20_KEY_SIZE],\n    const uint8_t nonce[CHACHA20_NONCE_SIZE]);\n\n// ******* END:   chacha-portable/chacha-portable.h ********\n// ******* BEGIN: poly1305-donna/poly1305-donna.h ********\n\n#include <stddef.h>\n\ntypedef struct poly1305_context {\n  size_t aligner;\n  unsigned char opaque[136];\n} poly1305_context;\n\nstatic PORTABLE_8439_DECL void poly1305_init(poly1305_context *ctx,\n                                             const unsigned char key[32]);\nstatic PORTABLE_8439_DECL void poly1305_update(poly1305_context *ctx,\n                                               const unsigned char *m,\n                                               size_t bytes);\nstatic PORTABLE_8439_DECL void poly1305_finish(poly1305_context *ctx,\n                                               unsigned char mac[16]);\n\n// ******* END:   poly1305-donna/poly1305-donna.h ********\n// ******* BEGIN: chacha-portable.c ********\n\n#include <assert.h>\n#include <string.h>\n\n// this is a fresh implementation of chacha20, based on the description in\n// rfc8349 it's such a nice compact algorithm that it is easy to do. In\n// relationship to other c implementation this implementation:\n//  - pure c99\n//  - big & little endian support\n//  - safe for architectures that don't support unaligned reads\n//\n// Next to this, we try to be fast as possible without resorting inline\n// assembly.\n\n// based on https://sourceforge.net/p/predef/wiki/Endianness/\n#if defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && \\\n    __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n#define __HAVE_LITTLE_ENDIAN 1\n#elif defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) ||                 \\\n    defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || \\\n    defined(__MIPSEL) || defined(__MIPSEL__) || defined(__XTENSA_EL__) || \\\n    defined(__AVR__) || defined(LITTLE_ENDIAN)\n#define __HAVE_LITTLE_ENDIAN 1\n#endif\n\n#ifndef TEST_SLOW_PATH\n#if defined(__HAVE_LITTLE_ENDIAN)\n#define FAST_PATH\n#endif\n#endif\n\n#define CHACHA20_STATE_WORDS (16)\n#define CHACHA20_BLOCK_SIZE (CHACHA20_STATE_WORDS * sizeof(uint32_t))\n\n#ifdef FAST_PATH\n#define store_32_le(target, source) memcpy(&(target), source, sizeof(uint32_t))\n#else\n#define store_32_le(target, source)                                 \\\n  target = (uint32_t) (source)[0] | ((uint32_t) (source)[1]) << 8 | \\\n           ((uint32_t) (source)[2]) << 16 | ((uint32_t) (source)[3]) << 24\n#endif\n\nstatic void initialize_state(uint32_t state[CHACHA20_STATE_WORDS],\n                             const uint8_t key[CHACHA20_KEY_SIZE],\n                             const uint8_t nonce[CHACHA20_NONCE_SIZE],\n                             uint32_t counter) {\n#ifdef static_assert\n  static_assert(sizeof(uint32_t) == 4,\n                \"We don't support systems that do not conform to standard of \"\n                \"uint32_t being exact 32bit wide\");\n#endif\n  state[0] = 0x61707865;\n  state[1] = 0x3320646e;\n  state[2] = 0x79622d32;\n  state[3] = 0x6b206574;\n  store_32_le(state[4], key);\n  store_32_le(state[5], key + 4);\n  store_32_le(state[6], key + 8);\n  store_32_le(state[7], key + 12);\n  store_32_le(state[8], key + 16);\n  store_32_le(state[9], key + 20);\n  store_32_le(state[10], key + 24);\n  store_32_le(state[11], key + 28);\n  state[12] = counter;\n  store_32_le(state[13], nonce);\n  store_32_le(state[14], nonce + 4);\n  store_32_le(state[15], nonce + 8);\n}\n\n#define increment_counter(state) (state)[12]++\n\n// source: http://blog.regehr.org/archives/1063\n#define rotl32a(x, n) ((x) << (n)) | ((x) >> (32 - (n)))\n\n#define Qround(a, b, c, d) \\\n  a += b;                  \\\n  d ^= a;                  \\\n  d = rotl32a(d, 16);      \\\n  c += d;                  \\\n  b ^= c;                  \\\n  b = rotl32a(b, 12);      \\\n  a += b;                  \\\n  d ^= a;                  \\\n  d = rotl32a(d, 8);       \\\n  c += d;                  \\\n  b ^= c;                  \\\n  b = rotl32a(b, 7);\n\n#define TIMES16(x)                                                          \\\n  x(0) x(1) x(2) x(3) x(4) x(5) x(6) x(7) x(8) x(9) x(10) x(11) x(12) x(13) \\\n      x(14) x(15)\n\nstatic void core_block(const uint32_t *restrict start,\n                       uint32_t *restrict output) {\n  int i;\n// instead of working on the output array,\n// we let the compiler allocate 16 local variables on the stack\n#define __LV(i) uint32_t __t##i = start[i];\n  TIMES16(__LV)\n\n#define __Q(a, b, c, d) Qround(__t##a, __t##b, __t##c, __t##d)\n\n  for (i = 0; i < 10; i++) {\n    __Q(0, 4, 8, 12);\n    __Q(1, 5, 9, 13);\n    __Q(2, 6, 10, 14);\n    __Q(3, 7, 11, 15);\n    __Q(0, 5, 10, 15);\n    __Q(1, 6, 11, 12);\n    __Q(2, 7, 8, 13);\n    __Q(3, 4, 9, 14);\n  }\n\n#define __FIN(i) output[i] = start[i] + __t##i;\n  TIMES16(__FIN)\n}\n\n#define U8(x) ((uint8_t) ((x) &0xFF))\n\n#ifdef FAST_PATH\n#define xor32_le(dst, src, pad)            \\\n  uint32_t __value;                        \\\n  memcpy(&__value, src, sizeof(uint32_t)); \\\n  __value ^= *(pad);                       \\\n  memcpy(dst, &__value, sizeof(uint32_t));\n#else\n#define xor32_le(dst, src, pad)           \\\n  (dst)[0] = (src)[0] ^ U8(*(pad));       \\\n  (dst)[1] = (src)[1] ^ U8(*(pad) >> 8);  \\\n  (dst)[2] = (src)[2] ^ U8(*(pad) >> 16); \\\n  (dst)[3] = (src)[3] ^ U8(*(pad) >> 24);\n#endif\n\n#define index8_32(a, ix) ((a) + ((ix) * sizeof(uint32_t)))\n\n#define xor32_blocks(dest, source, pad, words)                    \\\n  for (i = 0; i < words; i++) {                                   \\\n    xor32_le(index8_32(dest, i), index8_32(source, i), (pad) + i) \\\n  }\n\nstatic void xor_block(uint8_t *restrict dest, const uint8_t *restrict source,\n                      const uint32_t *restrict pad, unsigned int chunk_size) {\n  unsigned int i, full_blocks = chunk_size / (unsigned int) sizeof(uint32_t);\n  // have to be carefull, we are going back from uint32 to uint8, so endianness\n  // matters again\n  xor32_blocks(dest, source, pad, full_blocks)\n\n      dest += full_blocks * sizeof(uint32_t);\n  source += full_blocks * sizeof(uint32_t);\n  pad += full_blocks;\n\n  switch (chunk_size % sizeof(uint32_t)) {\n    case 1:\n      dest[0] = source[0] ^ U8(*pad);\n      break;\n    case 2:\n      dest[0] = source[0] ^ U8(*pad);\n      dest[1] = source[1] ^ U8(*pad >> 8);\n      break;\n    case 3:\n      dest[0] = source[0] ^ U8(*pad);\n      dest[1] = source[1] ^ U8(*pad >> 8);\n      dest[2] = source[2] ^ U8(*pad >> 16);\n      break;\n  }\n}\n\nstatic void chacha20_xor_stream(uint8_t *restrict dest,\n                                const uint8_t *restrict source, size_t length,\n                                const uint8_t key[CHACHA20_KEY_SIZE],\n                                const uint8_t nonce[CHACHA20_NONCE_SIZE],\n                                uint32_t counter) {\n  uint32_t state[CHACHA20_STATE_WORDS];\n  uint32_t pad[CHACHA20_STATE_WORDS];\n  size_t i, b, last_block, full_blocks = length / CHACHA20_BLOCK_SIZE;\n  initialize_state(state, key, nonce, counter);\n  for (b = 0; b < full_blocks; b++) {\n    core_block(state, pad);\n    increment_counter(state);\n    xor32_blocks(dest, source, pad, CHACHA20_STATE_WORDS) dest +=\n        CHACHA20_BLOCK_SIZE;\n    source += CHACHA20_BLOCK_SIZE;\n  }\n  last_block = length % CHACHA20_BLOCK_SIZE;\n  if (last_block > 0) {\n    core_block(state, pad);\n    xor_block(dest, source, pad, (unsigned int) last_block);\n  }\n}\n\n#ifdef FAST_PATH\n#define serialize(poly_key, result) memcpy(poly_key, result, 32)\n#else\n#define store32_le(target, source)   \\\n  (target)[0] = U8(*(source));       \\\n  (target)[1] = U8(*(source) >> 8);  \\\n  (target)[2] = U8(*(source) >> 16); \\\n  (target)[3] = U8(*(source) >> 24);\n\n#define serialize(poly_key, result)                 \\\n  for (i = 0; i < 32 / sizeof(uint32_t); i++) {     \\\n    store32_le(index8_32(poly_key, i), result + i); \\\n  }\n#endif\n\nstatic void rfc8439_keygen(uint8_t poly_key[32],\n                           const uint8_t key[CHACHA20_KEY_SIZE],\n                           const uint8_t nonce[CHACHA20_NONCE_SIZE]) {\n  uint32_t state[CHACHA20_STATE_WORDS];\n  uint32_t result[CHACHA20_STATE_WORDS];\n  size_t i;\n  initialize_state(state, key, nonce, 0);\n  core_block(state, result);\n  serialize(poly_key, result);\n  (void) i;\n}\n// ******* END: chacha-portable.c ********\n// ******* BEGIN: poly1305-donna.c ********\n\n/* auto detect between 32bit / 64bit */\n#if /* uint128 available on 64bit system*/                              \\\n    (defined(__SIZEOF_INT128__) &&                                      \\\n     defined(__LP64__))                       /* MSVC 64bit compiler */ \\\n    || (defined(_MSC_VER) && defined(_M_X64)) /* gcc >= 4.4 64bit */    \\\n    || (defined(__GNUC__) && defined(__LP64__) &&                       \\\n        ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 4))))\n#define __GUESS64\n#else\n#define __GUESS32\n#endif\n\n#if defined(POLY1305_8BIT)\n/*\n        poly1305 implementation using 8 bit * 8 bit = 16 bit multiplication and\n32 bit addition\n\n        based on the public domain reference version in supercop by djb\nstatic */\n\n#if defined(_MSC_VER) && _MSC_VER < 1700\n#define POLY1305_NOINLINE\n#elif defined(_MSC_VER)\n#define POLY1305_NOINLINE __declspec(noinline)\n#elif defined(__GNUC__)\n#define POLY1305_NOINLINE __attribute__((noinline))\n#else\n#define POLY1305_NOINLINE\n#endif\n\n#define poly1305_block_size 16\n\n/* 17 + sizeof(size_t) + 51*sizeof(unsigned char) */\ntypedef struct poly1305_state_internal_t {\n  unsigned char buffer[poly1305_block_size];\n  size_t leftover;\n  unsigned char h[17];\n  unsigned char r[17];\n  unsigned char pad[17];\n  unsigned char final;\n} poly1305_state_internal_t;\n\nstatic void poly1305_init(poly1305_context *ctx, const unsigned char key[32]) {\n  poly1305_state_internal_t *st = (poly1305_state_internal_t *) ctx;\n  size_t i;\n\n  st->leftover = 0;\n\n  /* h = 0 */\n  for (i = 0; i < 17; i++) st->h[i] = 0;\n\n  /* r &= 0xffffffc0ffffffc0ffffffc0fffffff */\n  st->r[0] = key[0] & 0xff;\n  st->r[1] = key[1] & 0xff;\n  st->r[2] = key[2] & 0xff;\n  st->r[3] = key[3] & 0x0f;\n  st->r[4] = key[4] & 0xfc;\n  st->r[5] = key[5] & 0xff;\n  st->r[6] = key[6] & 0xff;\n  st->r[7] = key[7] & 0x0f;\n  st->r[8] = key[8] & 0xfc;\n  st->r[9] = key[9] & 0xff;\n  st->r[10] = key[10] & 0xff;\n  st->r[11] = key[11] & 0x0f;\n  st->r[12] = key[12] & 0xfc;\n  st->r[13] = key[13] & 0xff;\n  st->r[14] = key[14] & 0xff;\n  st->r[15] = key[15] & 0x0f;\n  st->r[16] = 0;\n\n  /* save pad for later */\n  for (i = 0; i < 16; i++) st->pad[i] = key[i + 16];\n  st->pad[16] = 0;\n\n  st->final = 0;\n}\n\nstatic void poly1305_add(unsigned char h[17], const unsigned char c[17]) {\n  unsigned short u;\n  unsigned int i;\n  for (u = 0, i = 0; i < 17; i++) {\n    u += (unsigned short) h[i] + (unsigned short) c[i];\n    h[i] = (unsigned char) u & 0xff;\n    u >>= 8;\n  }\n}\n\nstatic void poly1305_squeeze(unsigned char h[17], unsigned long hr[17]) {\n  unsigned long u;\n  unsigned int i;\n  u = 0;\n  for (i = 0; i < 16; i++) {\n    u += hr[i];\n    h[i] = (unsigned char) u & 0xff;\n    u >>= 8;\n  }\n  u += hr[16];\n  h[16] = (unsigned char) u & 0x03;\n  u >>= 2;\n  u += (u << 2); /* u *= 5; */\n  for (i = 0; i < 16; i++) {\n    u += h[i];\n    h[i] = (unsigned char) u & 0xff;\n    u >>= 8;\n  }\n  h[16] += (unsigned char) u;\n}\n\nstatic void poly1305_freeze(unsigned char h[17]) {\n  const unsigned char minusp[17] = {0x05, 0x00, 0x00, 0x00, 0x00, 0x00,\n                                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                                    0x00, 0x00, 0x00, 0x00, 0xfc};\n  unsigned char horig[17], negative;\n  unsigned int i;\n\n  /* compute h + -p */\n  for (i = 0; i < 17; i++) horig[i] = h[i];\n  poly1305_add(h, minusp);\n\n  /* select h if h < p, or h + -p if h >= p */\n  negative = -(h[16] >> 7);\n  for (i = 0; i < 17; i++) h[i] ^= negative & (horig[i] ^ h[i]);\n}\n\nstatic void poly1305_blocks(poly1305_state_internal_t *st,\n                            const unsigned char *m, size_t bytes) {\n  const unsigned char hibit = st->final ^ 1; /* 1 << 128 */\n\n  while (bytes >= poly1305_block_size) {\n    unsigned long hr[17], u;\n    unsigned char c[17];\n    unsigned int i, j;\n\n    /* h += m */\n    for (i = 0; i < 16; i++) c[i] = m[i];\n    c[16] = hibit;\n    poly1305_add(st->h, c);\n\n    /* h *= r */\n    for (i = 0; i < 17; i++) {\n      u = 0;\n      for (j = 0; j <= i; j++) {\n        u += (unsigned short) st->h[j] * st->r[i - j];\n      }\n      for (j = i + 1; j < 17; j++) {\n        unsigned long v = (unsigned short) st->h[j] * st->r[i + 17 - j];\n        v = ((v << 8) + (v << 6)); /* v *= (5 << 6); */\n        u += v;\n      }\n      hr[i] = u;\n    }\n\n    /* (partial) h %= p */\n    poly1305_squeeze(st->h, hr);\n\n    m += poly1305_block_size;\n    bytes -= poly1305_block_size;\n  }\n}\n\nstatic POLY1305_NOINLINE void poly1305_finish(poly1305_context *ctx,\n                                              unsigned char mac[16]) {\n  poly1305_state_internal_t *st = (poly1305_state_internal_t *) ctx;\n  size_t i;\n\n  /* process the remaining block */\n  if (st->leftover) {\n    size_t i = st->leftover;\n    st->buffer[i++] = 1;\n    for (; i < poly1305_block_size; i++) st->buffer[i] = 0;\n    st->final = 1;\n    poly1305_blocks(st, st->buffer, poly1305_block_size);\n  }\n\n  /* fully reduce h */\n  poly1305_freeze(st->h);\n\n  /* h = (h + pad) % (1 << 128) */\n  poly1305_add(st->h, st->pad);\n  for (i = 0; i < 16; i++) mac[i] = st->h[i];\n\n  /* zero out the state */\n  for (i = 0; i < 17; i++) st->h[i] = 0;\n  for (i = 0; i < 17; i++) st->r[i] = 0;\n  for (i = 0; i < 17; i++) st->pad[i] = 0;\n}\n#elif defined(POLY1305_16BIT)\n/*\n        poly1305 implementation using 16 bit * 16 bit = 32 bit multiplication\nand 32 bit addition static */\n\n#if defined(_MSC_VER) && _MSC_VER < 1700\n#define POLY1305_NOINLINE\n#elif defined(_MSC_VER)\n#define POLY1305_NOINLINE __declspec(noinline)\n#elif defined(__GNUC__)\n#define POLY1305_NOINLINE __attribute__((noinline))\n#else\n#define POLY1305_NOINLINE\n#endif\n\n#define poly1305_block_size 16\n\n/* 17 + sizeof(size_t) + 18*sizeof(unsigned short) */\ntypedef struct poly1305_state_internal_t {\n  unsigned char buffer[poly1305_block_size];\n  size_t leftover;\n  unsigned short r[10];\n  unsigned short h[10];\n  unsigned short pad[8];\n  unsigned char final;\n} poly1305_state_internal_t;\n\n/* interpret two 8 bit unsigned integers as a 16 bit unsigned integer in little\n * endian */\nstatic unsigned short U8TO16(const unsigned char *p) {\n  return (((unsigned short) (p[0] & 0xff)) |\n          ((unsigned short) (p[1] & 0xff) << 8));\n}\n\n/* store a 16 bit unsigned integer as two 8 bit unsigned integers in little\n * endian */\nstatic void U16TO8(unsigned char *p, unsigned short v) {\n  p[0] = (v) &0xff;\n  p[1] = (v >> 8) & 0xff;\n}\n\nstatic void poly1305_init(poly1305_context *ctx, const unsigned char key[32]) {\n  poly1305_state_internal_t *st = (poly1305_state_internal_t *) ctx;\n  unsigned short t0, t1, t2, t3, t4, t5, t6, t7;\n  size_t i;\n\n  /* r &= 0xffffffc0ffffffc0ffffffc0fffffff */\n  t0 = U8TO16(&key[0]);\n  st->r[0] = (t0) &0x1fff;\n  t1 = U8TO16(&key[2]);\n  st->r[1] = ((t0 >> 13) | (t1 << 3)) & 0x1fff;\n  t2 = U8TO16(&key[4]);\n  st->r[2] = ((t1 >> 10) | (t2 << 6)) & 0x1f03;\n  t3 = U8TO16(&key[6]);\n  st->r[3] = ((t2 >> 7) | (t3 << 9)) & 0x1fff;\n  t4 = U8TO16(&key[8]);\n  st->r[4] = ((t3 >> 4) | (t4 << 12)) & 0x00ff;\n  st->r[5] = ((t4 >> 1)) & 0x1ffe;\n  t5 = U8TO16(&key[10]);\n  st->r[6] = ((t4 >> 14) | (t5 << 2)) & 0x1fff;\n  t6 = U8TO16(&key[12]);\n  st->r[7] = ((t5 >> 11) | (t6 << 5)) & 0x1f81;\n  t7 = U8TO16(&key[14]);\n  st->r[8] = ((t6 >> 8) | (t7 << 8)) & 0x1fff;\n  st->r[9] = ((t7 >> 5)) & 0x007f;\n\n  /* h = 0 */\n  for (i = 0; i < 10; i++) st->h[i] = 0;\n\n  /* save pad for later */\n  for (i = 0; i < 8; i++) st->pad[i] = U8TO16(&key[16 + (2 * i)]);\n\n  st->leftover = 0;\n  st->final = 0;\n}\n\nstatic void poly1305_blocks(poly1305_state_internal_t *st,\n                            const unsigned char *m, size_t bytes) {\n  const unsigned short hibit = (st->final) ? 0 : (1 << 11); /* 1 << 128 */\n  unsigned short t0, t1, t2, t3, t4, t5, t6, t7;\n  unsigned long d[10];\n  unsigned long c;\n\n  while (bytes >= poly1305_block_size) {\n    size_t i, j;\n\n    /* h += m[i] */\n    t0 = U8TO16(&m[0]);\n    st->h[0] += (t0) &0x1fff;\n    t1 = U8TO16(&m[2]);\n    st->h[1] += ((t0 >> 13) | (t1 << 3)) & 0x1fff;\n    t2 = U8TO16(&m[4]);\n    st->h[2] += ((t1 >> 10) | (t2 << 6)) & 0x1fff;\n    t3 = U8TO16(&m[6]);\n    st->h[3] += ((t2 >> 7) | (t3 << 9)) & 0x1fff;\n    t4 = U8TO16(&m[8]);\n    st->h[4] += ((t3 >> 4) | (t4 << 12)) & 0x1fff;\n    st->h[5] += ((t4 >> 1)) & 0x1fff;\n    t5 = U8TO16(&m[10]);\n    st->h[6] += ((t4 >> 14) | (t5 << 2)) & 0x1fff;\n    t6 = U8TO16(&m[12]);\n    st->h[7] += ((t5 >> 11) | (t6 << 5)) & 0x1fff;\n    t7 = U8TO16(&m[14]);\n    st->h[8] += ((t6 >> 8) | (t7 << 8)) & 0x1fff;\n    st->h[9] += ((t7 >> 5)) | hibit;\n\n    /* h *= r, (partial) h %= p */\n    for (i = 0, c = 0; i < 10; i++) {\n      d[i] = c;\n      for (j = 0; j < 10; j++) {\n        d[i] += (unsigned long) st->h[j] *\n                ((j <= i) ? st->r[i - j] : (5 * st->r[i + 10 - j]));\n        /* Sum(h[i] * r[i] * 5) will overflow slightly above 6 products with an\n         * unclamped r, so carry at 5 */\n        if (j == 4) {\n          c = (d[i] >> 13);\n          d[i] &= 0x1fff;\n        }\n      }\n      c += (d[i] >> 13);\n      d[i] &= 0x1fff;\n    }\n    c = ((c << 2) + c); /* c *= 5 */\n    c += d[0];\n    d[0] = ((unsigned short) c & 0x1fff);\n    c = (c >> 13);\n    d[1] += c;\n\n    for (i = 0; i < 10; i++) st->h[i] = (unsigned short) d[i];\n\n    m += poly1305_block_size;\n    bytes -= poly1305_block_size;\n  }\n}\n\nstatic POLY1305_NOINLINE void poly1305_finish(poly1305_context *ctx,\n                                              unsigned char mac[16]) {\n  poly1305_state_internal_t *st = (poly1305_state_internal_t *) ctx;\n  unsigned short c;\n  unsigned short g[10];\n  unsigned short mask;\n  unsigned long f;\n  size_t i;\n\n  /* process the remaining block */\n  if (st->leftover) {\n    size_t i = st->leftover;\n    st->buffer[i++] = 1;\n    for (; i < poly1305_block_size; i++) st->buffer[i] = 0;\n    st->final = 1;\n    poly1305_blocks(st, st->buffer, poly1305_block_size);\n  }\n\n  /* fully carry h */\n  c = st->h[1] >> 13;\n  st->h[1] &= 0x1fff;\n  for (i = 2; i < 10; i++) {\n    st->h[i] += c;\n    c = st->h[i] >> 13;\n    st->h[i] &= 0x1fff;\n  }\n  st->h[0] += (c * 5);\n  c = st->h[0] >> 13;\n  st->h[0] &= 0x1fff;\n  st->h[1] += c;\n  c = st->h[1] >> 13;\n  st->h[1] &= 0x1fff;\n  st->h[2] += c;\n\n  /* compute h + -p */\n  g[0] = st->h[0] + 5;\n  c = g[0] >> 13;\n  g[0] &= 0x1fff;\n  for (i = 1; i < 10; i++) {\n    g[i] = st->h[i] + c;\n    c = g[i] >> 13;\n    g[i] &= 0x1fff;\n  }\n\n  /* select h if h < p, or h + -p if h >= p */\n  mask = (c ^ 1) - 1;\n  for (i = 0; i < 10; i++) g[i] &= mask;\n  mask = ~mask;\n  for (i = 0; i < 10; i++) st->h[i] = (st->h[i] & mask) | g[i];\n\n  /* h = h % (2^128) */\n  st->h[0] = ((st->h[0]) | (st->h[1] << 13)) & 0xffff;\n  st->h[1] = ((st->h[1] >> 3) | (st->h[2] << 10)) & 0xffff;\n  st->h[2] = ((st->h[2] >> 6) | (st->h[3] << 7)) & 0xffff;\n  st->h[3] = ((st->h[3] >> 9) | (st->h[4] << 4)) & 0xffff;\n  st->h[4] = ((st->h[4] >> 12) | (st->h[5] << 1) | (st->h[6] << 14)) & 0xffff;\n  st->h[5] = ((st->h[6] >> 2) | (st->h[7] << 11)) & 0xffff;\n  st->h[6] = ((st->h[7] >> 5) | (st->h[8] << 8)) & 0xffff;\n  st->h[7] = ((st->h[8] >> 8) | (st->h[9] << 5)) & 0xffff;\n\n  /* mac = (h + pad) % (2^128) */\n  f = (unsigned long) st->h[0] + st->pad[0];\n  st->h[0] = (unsigned short) f;\n  for (i = 1; i < 8; i++) {\n    f = (unsigned long) st->h[i] + st->pad[i] + (f >> 16);\n    st->h[i] = (unsigned short) f;\n  }\n\n  for (i = 0; i < 8; i++) U16TO8(mac + (i * 2), st->h[i]);\n\n  /* zero out the state */\n  for (i = 0; i < 10; i++) st->h[i] = 0;\n  for (i = 0; i < 10; i++) st->r[i] = 0;\n  for (i = 0; i < 8; i++) st->pad[i] = 0;\n}\n#elif defined(POLY1305_32BIT) || \\\n    (!defined(POLY1305_64BIT) && defined(__GUESS32))\n/*\n        poly1305 implementation using 32 bit * 32 bit = 64 bit multiplication\nand 64 bit addition static */\n\n#if defined(_MSC_VER) && _MSC_VER < 1700\n#define POLY1305_NOINLINE\n#elif defined(_MSC_VER)\n#define POLY1305_NOINLINE __declspec(noinline)\n#elif defined(__GNUC__)\n#define POLY1305_NOINLINE __attribute__((noinline))\n#else\n#define POLY1305_NOINLINE\n#endif\n\n#define poly1305_block_size 16\n\n/* 17 + sizeof(size_t) + 14*sizeof(unsigned long) */\ntypedef struct poly1305_state_internal_t {\n  unsigned long r[5];\n  unsigned long h[5];\n  unsigned long pad[4];\n  size_t leftover;\n  unsigned char buffer[poly1305_block_size];\n  unsigned char final;\n} poly1305_state_internal_t;\n\n/* interpret four 8 bit unsigned integers as a 32 bit unsigned integer in little\n * endian */\nstatic unsigned long U8TO32(const unsigned char *p) {\n  return (((unsigned long) (p[0] & 0xff)) |\n          ((unsigned long) (p[1] & 0xff) << 8) |\n          ((unsigned long) (p[2] & 0xff) << 16) |\n          ((unsigned long) (p[3] & 0xff) << 24));\n}\n\n/* store a 32 bit unsigned integer as four 8 bit unsigned integers in little\n * endian */\nstatic void U32TO8(unsigned char *p, unsigned long v) {\n  p[0] = (unsigned char) ((v) &0xff);\n  p[1] = (unsigned char) ((v >> 8) & 0xff);\n  p[2] = (unsigned char) ((v >> 16) & 0xff);\n  p[3] = (unsigned char) ((v >> 24) & 0xff);\n}\n\nstatic void poly1305_init(poly1305_context *ctx, const unsigned char key[32]) {\n  poly1305_state_internal_t *st = (poly1305_state_internal_t *) ctx;\n\n  /* r &= 0xffffffc0ffffffc0ffffffc0fffffff */\n  st->r[0] = (U8TO32(&key[0])) & 0x3ffffff;\n  st->r[1] = (U8TO32(&key[3]) >> 2) & 0x3ffff03;\n  st->r[2] = (U8TO32(&key[6]) >> 4) & 0x3ffc0ff;\n  st->r[3] = (U8TO32(&key[9]) >> 6) & 0x3f03fff;\n  st->r[4] = (U8TO32(&key[12]) >> 8) & 0x00fffff;\n\n  /* h = 0 */\n  st->h[0] = 0;\n  st->h[1] = 0;\n  st->h[2] = 0;\n  st->h[3] = 0;\n  st->h[4] = 0;\n\n  /* save pad for later */\n  st->pad[0] = U8TO32(&key[16]);\n  st->pad[1] = U8TO32(&key[20]);\n  st->pad[2] = U8TO32(&key[24]);\n  st->pad[3] = U8TO32(&key[28]);\n\n  st->leftover = 0;\n  st->final = 0;\n}\n\nstatic void poly1305_blocks(poly1305_state_internal_t *st,\n                            const unsigned char *m, size_t bytes) {\n  const unsigned long hibit = (st->final) ? 0 : (1UL << 24); /* 1 << 128 */\n  unsigned long r0, r1, r2, r3, r4;\n  unsigned long s1, s2, s3, s4;\n  unsigned long h0, h1, h2, h3, h4;\n  uint64_t d0, d1, d2, d3, d4;\n  unsigned long c;\n\n  r0 = st->r[0];\n  r1 = st->r[1];\n  r2 = st->r[2];\n  r3 = st->r[3];\n  r4 = st->r[4];\n\n  s1 = r1 * 5;\n  s2 = r2 * 5;\n  s3 = r3 * 5;\n  s4 = r4 * 5;\n\n  h0 = st->h[0];\n  h1 = st->h[1];\n  h2 = st->h[2];\n  h3 = st->h[3];\n  h4 = st->h[4];\n\n  while (bytes >= poly1305_block_size) {\n    /* h += m[i] */\n    h0 += (U8TO32(m + 0)) & 0x3ffffff;\n    h1 += (U8TO32(m + 3) >> 2) & 0x3ffffff;\n    h2 += (U8TO32(m + 6) >> 4) & 0x3ffffff;\n    h3 += (U8TO32(m + 9) >> 6) & 0x3ffffff;\n    h4 += (U8TO32(m + 12) >> 8) | hibit;\n\n    /* h *= r */\n    d0 = ((uint64_t) h0 * r0) + ((uint64_t) h1 * s4) + ((uint64_t) h2 * s3) +\n         ((uint64_t) h3 * s2) + ((uint64_t) h4 * s1);\n    d1 = ((uint64_t) h0 * r1) + ((uint64_t) h1 * r0) + ((uint64_t) h2 * s4) +\n         ((uint64_t) h3 * s3) + ((uint64_t) h4 * s2);\n    d2 = ((uint64_t) h0 * r2) + ((uint64_t) h1 * r1) + ((uint64_t) h2 * r0) +\n         ((uint64_t) h3 * s4) + ((uint64_t) h4 * s3);\n    d3 = ((uint64_t) h0 * r3) + ((uint64_t) h1 * r2) + ((uint64_t) h2 * r1) +\n         ((uint64_t) h3 * r0) + ((uint64_t) h4 * s4);\n    d4 = ((uint64_t) h0 * r4) + ((uint64_t) h1 * r3) + ((uint64_t) h2 * r2) +\n         ((uint64_t) h3 * r1) + ((uint64_t) h4 * r0);\n\n    /* (partial) h %= p */\n    c = (unsigned long) (d0 >> 26);\n    h0 = (unsigned long) d0 & 0x3ffffff;\n    d1 += c;\n    c = (unsigned long) (d1 >> 26);\n    h1 = (unsigned long) d1 & 0x3ffffff;\n    d2 += c;\n    c = (unsigned long) (d2 >> 26);\n    h2 = (unsigned long) d2 & 0x3ffffff;\n    d3 += c;\n    c = (unsigned long) (d3 >> 26);\n    h3 = (unsigned long) d3 & 0x3ffffff;\n    d4 += c;\n    c = (unsigned long) (d4 >> 26);\n    h4 = (unsigned long) d4 & 0x3ffffff;\n    h0 += c * 5;\n    c = (h0 >> 26);\n    h0 = h0 & 0x3ffffff;\n    h1 += c;\n\n    m += poly1305_block_size;\n    bytes -= poly1305_block_size;\n  }\n\n  st->h[0] = h0;\n  st->h[1] = h1;\n  st->h[2] = h2;\n  st->h[3] = h3;\n  st->h[4] = h4;\n}\n\nstatic POLY1305_NOINLINE void poly1305_finish(poly1305_context *ctx,\n                                              unsigned char mac[16]) {\n  poly1305_state_internal_t *st = (poly1305_state_internal_t *) ctx;\n  unsigned long h0, h1, h2, h3, h4, c;\n  unsigned long g0, g1, g2, g3, g4;\n  uint64_t f;\n  unsigned long mask;\n\n  /* process the remaining block */\n  if (st->leftover) {\n    size_t i = st->leftover;\n    st->buffer[i++] = 1;\n    for (; i < poly1305_block_size; i++) st->buffer[i] = 0;\n    st->final = 1;\n    poly1305_blocks(st, st->buffer, poly1305_block_size);\n  }\n\n  /* fully carry h */\n  h0 = st->h[0];\n  h1 = st->h[1];\n  h2 = st->h[2];\n  h3 = st->h[3];\n  h4 = st->h[4];\n\n  c = h1 >> 26;\n  h1 = h1 & 0x3ffffff;\n  h2 += c;\n  c = h2 >> 26;\n  h2 = h2 & 0x3ffffff;\n  h3 += c;\n  c = h3 >> 26;\n  h3 = h3 & 0x3ffffff;\n  h4 += c;\n  c = h4 >> 26;\n  h4 = h4 & 0x3ffffff;\n  h0 += c * 5;\n  c = h0 >> 26;\n  h0 = h0 & 0x3ffffff;\n  h1 += c;\n\n  /* compute h + -p */\n  g0 = h0 + 5;\n  c = g0 >> 26;\n  g0 &= 0x3ffffff;\n  g1 = h1 + c;\n  c = g1 >> 26;\n  g1 &= 0x3ffffff;\n  g2 = h2 + c;\n  c = g2 >> 26;\n  g2 &= 0x3ffffff;\n  g3 = h3 + c;\n  c = g3 >> 26;\n  g3 &= 0x3ffffff;\n  g4 = h4 + c - (1UL << 26);\n\n  /* select h if h < p, or h + -p if h >= p */\n  mask = (g4 >> ((sizeof(unsigned long) * 8) - 1)) - 1;\n  g0 &= mask;\n  g1 &= mask;\n  g2 &= mask;\n  g3 &= mask;\n  g4 &= mask;\n  mask = ~mask;\n  h0 = (h0 & mask) | g0;\n  h1 = (h1 & mask) | g1;\n  h2 = (h2 & mask) | g2;\n  h3 = (h3 & mask) | g3;\n  h4 = (h4 & mask) | g4;\n\n  /* h = h % (2^128) */\n  h0 = ((h0) | (h1 << 26)) & 0xffffffff;\n  h1 = ((h1 >> 6) | (h2 << 20)) & 0xffffffff;\n  h2 = ((h2 >> 12) | (h3 << 14)) & 0xffffffff;\n  h3 = ((h3 >> 18) | (h4 << 8)) & 0xffffffff;\n\n  /* mac = (h + pad) % (2^128) */\n  f = (uint64_t) h0 + st->pad[0];\n  h0 = (unsigned long) f;\n  f = (uint64_t) h1 + st->pad[1] + (f >> 32);\n  h1 = (unsigned long) f;\n  f = (uint64_t) h2 + st->pad[2] + (f >> 32);\n  h2 = (unsigned long) f;\n  f = (uint64_t) h3 + st->pad[3] + (f >> 32);\n  h3 = (unsigned long) f;\n\n  U32TO8(mac + 0, h0);\n  U32TO8(mac + 4, h1);\n  U32TO8(mac + 8, h2);\n  U32TO8(mac + 12, h3);\n\n  /* zero out the state */\n  st->h[0] = 0;\n  st->h[1] = 0;\n  st->h[2] = 0;\n  st->h[3] = 0;\n  st->h[4] = 0;\n  st->r[0] = 0;\n  st->r[1] = 0;\n  st->r[2] = 0;\n  st->r[3] = 0;\n  st->r[4] = 0;\n  st->pad[0] = 0;\n  st->pad[1] = 0;\n  st->pad[2] = 0;\n  st->pad[3] = 0;\n}\n\n#else\n/*\n        poly1305 implementation using 64 bit * 64 bit = 128 bit multiplication\nand 128 bit addition static */\n\n#if defined(_MSC_VER)\n\ntypedef struct uint128_t {\n  uint64_t lo;\n  uint64_t hi;\n} uint128_t;\n\n#define MUL128(out, x, y) out.lo = _umul128((x), (y), &out.hi)\n#define ADD(out, in)                \\\n  {                                 \\\n    uint64_t t = out.lo;            \\\n    out.lo += in.lo;                \\\n    out.hi += (out.lo < t) + in.hi; \\\n  }\n#define ADDLO(out, in)      \\\n  {                         \\\n    uint64_t t = out.lo;    \\\n    out.lo += in;           \\\n    out.hi += (out.lo < t); \\\n  }\n#define SHR(in, shift) (__shiftright128(in.lo, in.hi, (shift)))\n#define LO(in) (in.lo)\n\n#if defined(_MSC_VER) && _MSC_VER < 1700\n#define POLY1305_NOINLINE\n#else\n#define POLY1305_NOINLINE __declspec(noinline)\n#endif\n#elif defined(__GNUC__)\n#if defined(__SIZEOF_INT128__)\n// Get rid of GCC warning \"ISO C does not support '__int128' types\"\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpedantic\"\ntypedef unsigned __int128 uint128_t;\n#pragma GCC diagnostic pop\n#else\ntypedef unsigned uint128_t __attribute__((mode(TI)));\n#endif\n\n#define MUL128(out, x, y) out = ((uint128_t) x * y)\n#define ADD(out, in) out += in\n#define ADDLO(out, in) out += in\n#define SHR(in, shift) (uint64_t)(in >> (shift))\n#define LO(in) (uint64_t)(in)\n\n#define POLY1305_NOINLINE __attribute__((noinline))\n#endif\n\n#define poly1305_block_size 16\n\n/* 17 + sizeof(size_t) + 8*sizeof(uint64_t) */\ntypedef struct poly1305_state_internal_t {\n  uint64_t r[3];\n  uint64_t h[3];\n  uint64_t pad[2];\n  size_t leftover;\n  unsigned char buffer[poly1305_block_size];\n  unsigned char final;\n} poly1305_state_internal_t;\n\n/* interpret eight 8 bit unsigned integers as a 64 bit unsigned integer in\n * little endian */\nstatic uint64_t U8TO64(const unsigned char *p) {\n  return (((uint64_t) (p[0] & 0xff)) | ((uint64_t) (p[1] & 0xff) << 8) |\n          ((uint64_t) (p[2] & 0xff) << 16) | ((uint64_t) (p[3] & 0xff) << 24) |\n          ((uint64_t) (p[4] & 0xff) << 32) | ((uint64_t) (p[5] & 0xff) << 40) |\n          ((uint64_t) (p[6] & 0xff) << 48) | ((uint64_t) (p[7] & 0xff) << 56));\n}\n\n/* store a 64 bit unsigned integer as eight 8 bit unsigned integers in little\n * endian */\nstatic void U64TO8(unsigned char *p, uint64_t v) {\n  p[0] = (unsigned char) ((v) &0xff);\n  p[1] = (unsigned char) ((v >> 8) & 0xff);\n  p[2] = (unsigned char) ((v >> 16) & 0xff);\n  p[3] = (unsigned char) ((v >> 24) & 0xff);\n  p[4] = (unsigned char) ((v >> 32) & 0xff);\n  p[5] = (unsigned char) ((v >> 40) & 0xff);\n  p[6] = (unsigned char) ((v >> 48) & 0xff);\n  p[7] = (unsigned char) ((v >> 56) & 0xff);\n}\n\nstatic void poly1305_init(poly1305_context *ctx, const unsigned char key[32]) {\n  poly1305_state_internal_t *st = (poly1305_state_internal_t *) ctx;\n  uint64_t t0, t1;\n\n  /* r &= 0xffffffc0ffffffc0ffffffc0fffffff */\n  t0 = U8TO64(&key[0]);\n  t1 = U8TO64(&key[8]);\n\n  st->r[0] = (t0) &0xffc0fffffff;\n  st->r[1] = ((t0 >> 44) | (t1 << 20)) & 0xfffffc0ffff;\n  st->r[2] = ((t1 >> 24)) & 0x00ffffffc0f;\n\n  /* h = 0 */\n  st->h[0] = 0;\n  st->h[1] = 0;\n  st->h[2] = 0;\n\n  /* save pad for later */\n  st->pad[0] = U8TO64(&key[16]);\n  st->pad[1] = U8TO64(&key[24]);\n\n  st->leftover = 0;\n  st->final = 0;\n}\n\nstatic void poly1305_blocks(poly1305_state_internal_t *st,\n                            const unsigned char *m, size_t bytes) {\n  const uint64_t hibit = (st->final) ? 0 : ((uint64_t) 1 << 40); /* 1 << 128 */\n  uint64_t r0, r1, r2;\n  uint64_t s1, s2;\n  uint64_t h0, h1, h2;\n  uint64_t c;\n  uint128_t d0, d1, d2, d;\n\n  r0 = st->r[0];\n  r1 = st->r[1];\n  r2 = st->r[2];\n\n  h0 = st->h[0];\n  h1 = st->h[1];\n  h2 = st->h[2];\n\n  s1 = r1 * (5 << 2);\n  s2 = r2 * (5 << 2);\n\n  while (bytes >= poly1305_block_size) {\n    uint64_t t0, t1;\n\n    /* h += m[i] */\n    t0 = U8TO64(&m[0]);\n    t1 = U8TO64(&m[8]);\n\n    h0 += ((t0) &0xfffffffffff);\n    h1 += (((t0 >> 44) | (t1 << 20)) & 0xfffffffffff);\n    h2 += (((t1 >> 24)) & 0x3ffffffffff) | hibit;\n\n    /* h *= r */\n    MUL128(d0, h0, r0);\n    MUL128(d, h1, s2);\n    ADD(d0, d);\n    MUL128(d, h2, s1);\n    ADD(d0, d);\n    MUL128(d1, h0, r1);\n    MUL128(d, h1, r0);\n    ADD(d1, d);\n    MUL128(d, h2, s2);\n    ADD(d1, d);\n    MUL128(d2, h0, r2);\n    MUL128(d, h1, r1);\n    ADD(d2, d);\n    MUL128(d, h2, r0);\n    ADD(d2, d);\n\n    /* (partial) h %= p */\n    c = SHR(d0, 44);\n    h0 = LO(d0) & 0xfffffffffff;\n    ADDLO(d1, c);\n    c = SHR(d1, 44);\n    h1 = LO(d1) & 0xfffffffffff;\n    ADDLO(d2, c);\n    c = SHR(d2, 42);\n    h2 = LO(d2) & 0x3ffffffffff;\n    h0 += c * 5;\n    c = (h0 >> 44);\n    h0 = h0 & 0xfffffffffff;\n    h1 += c;\n\n    m += poly1305_block_size;\n    bytes -= poly1305_block_size;\n  }\n\n  st->h[0] = h0;\n  st->h[1] = h1;\n  st->h[2] = h2;\n}\n\nstatic POLY1305_NOINLINE void poly1305_finish(poly1305_context *ctx,\n                                              unsigned char mac[16]) {\n  poly1305_state_internal_t *st = (poly1305_state_internal_t *) ctx;\n  uint64_t h0, h1, h2, c;\n  uint64_t g0, g1, g2;\n  uint64_t t0, t1;\n\n  /* process the remaining block */\n  if (st->leftover) {\n    size_t i = st->leftover;\n    st->buffer[i] = 1;\n    for (i = i + 1; i < poly1305_block_size; i++) st->buffer[i] = 0;\n    st->final = 1;\n    poly1305_blocks(st, st->buffer, poly1305_block_size);\n  }\n\n  /* fully carry h */\n  h0 = st->h[0];\n  h1 = st->h[1];\n  h2 = st->h[2];\n\n  c = (h1 >> 44);\n  h1 &= 0xfffffffffff;\n  h2 += c;\n  c = (h2 >> 42);\n  h2 &= 0x3ffffffffff;\n  h0 += c * 5;\n  c = (h0 >> 44);\n  h0 &= 0xfffffffffff;\n  h1 += c;\n  c = (h1 >> 44);\n  h1 &= 0xfffffffffff;\n  h2 += c;\n  c = (h2 >> 42);\n  h2 &= 0x3ffffffffff;\n  h0 += c * 5;\n  c = (h0 >> 44);\n  h0 &= 0xfffffffffff;\n  h1 += c;\n\n  /* compute h + -p */\n  g0 = h0 + 5;\n  c = (g0 >> 44);\n  g0 &= 0xfffffffffff;\n  g1 = h1 + c;\n  c = (g1 >> 44);\n  g1 &= 0xfffffffffff;\n  g2 = h2 + c - ((uint64_t) 1 << 42);\n\n  /* select h if h < p, or h + -p if h >= p */\n  c = (g2 >> ((sizeof(uint64_t) * 8) - 1)) - 1;\n  g0 &= c;\n  g1 &= c;\n  g2 &= c;\n  c = ~c;\n  h0 = (h0 & c) | g0;\n  h1 = (h1 & c) | g1;\n  h2 = (h2 & c) | g2;\n\n  /* h = (h + pad) */\n  t0 = st->pad[0];\n  t1 = st->pad[1];\n\n  h0 += ((t0) &0xfffffffffff);\n  c = (h0 >> 44);\n  h0 &= 0xfffffffffff;\n  h1 += (((t0 >> 44) | (t1 << 20)) & 0xfffffffffff) + c;\n  c = (h1 >> 44);\n  h1 &= 0xfffffffffff;\n  h2 += (((t1 >> 24)) & 0x3ffffffffff) + c;\n  h2 &= 0x3ffffffffff;\n\n  /* mac = h % (2^128) */\n  h0 = ((h0) | (h1 << 44));\n  h1 = ((h1 >> 20) | (h2 << 24));\n\n  U64TO8(&mac[0], h0);\n  U64TO8(&mac[8], h1);\n\n  /* zero out the state */\n  st->h[0] = 0;\n  st->h[1] = 0;\n  st->h[2] = 0;\n  st->r[0] = 0;\n  st->r[1] = 0;\n  st->r[2] = 0;\n  st->pad[0] = 0;\n  st->pad[1] = 0;\n}\n\n#endif\n\nstatic void poly1305_update(poly1305_context *ctx, const unsigned char *m,\n                            size_t bytes) {\n  poly1305_state_internal_t *st = (poly1305_state_internal_t *) ctx;\n  size_t i;\n\n  /* handle leftover */\n  if (st->leftover) {\n    size_t want = (poly1305_block_size - st->leftover);\n    if (want > bytes) want = bytes;\n    for (i = 0; i < want; i++) st->buffer[st->leftover + i] = m[i];\n    bytes -= want;\n    m += want;\n    st->leftover += want;\n    if (st->leftover < poly1305_block_size) return;\n    poly1305_blocks(st, st->buffer, poly1305_block_size);\n    st->leftover = 0;\n  }\n\n  /* process full blocks */\n  if (bytes >= poly1305_block_size) {\n    size_t want = (bytes & (size_t) ~(poly1305_block_size - 1));\n    poly1305_blocks(st, m, want);\n    m += want;\n    bytes -= want;\n  }\n\n  /* store leftover */\n  if (bytes) {\n    for (i = 0; i < bytes; i++) st->buffer[st->leftover + i] = m[i];\n    st->leftover += bytes;\n  }\n}\n\n// ******* END: poly1305-donna.c ********\n// ******* BEGIN: portable8439.c ********\n\n#define __CHACHA20_BLOCK_SIZE (64)\n#define __POLY1305_KEY_SIZE (32)\n\nstatic PORTABLE_8439_DECL uint8_t __ZEROES[16] = {0};\nstatic PORTABLE_8439_DECL void pad_if_needed(poly1305_context *ctx,\n                                             size_t size) {\n  size_t padding = size % 16;\n  if (padding != 0) {\n    poly1305_update(ctx, __ZEROES, 16 - padding);\n  }\n}\n\n#define __u8(v) ((uint8_t) ((v) &0xFF))\n\n// TODO: make this depending on the unaligned/native read size possible\nstatic PORTABLE_8439_DECL void write_64bit_int(poly1305_context *ctx,\n                                               uint64_t value) {\n  uint8_t result[8];\n  result[0] = __u8(value);\n  result[1] = __u8(value >> 8);\n  result[2] = __u8(value >> 16);\n  result[3] = __u8(value >> 24);\n  result[4] = __u8(value >> 32);\n  result[5] = __u8(value >> 40);\n  result[6] = __u8(value >> 48);\n  result[7] = __u8(value >> 56);\n  poly1305_update(ctx, result, 8);\n}\n\nstatic PORTABLE_8439_DECL void poly1305_calculate_mac(\n    uint8_t *mac, const uint8_t *cipher_text, size_t cipher_text_size,\n    const uint8_t key[RFC_8439_KEY_SIZE],\n    const uint8_t nonce[RFC_8439_NONCE_SIZE], const uint8_t *ad,\n    size_t ad_size) {\n  // init poly key (section 2.6)\n  uint8_t poly_key[__POLY1305_KEY_SIZE] = {0};\n  poly1305_context poly_ctx;\n  rfc8439_keygen(poly_key, key, nonce);\n  // start poly1305 mac\n  poly1305_init(&poly_ctx, poly_key);\n\n  if (ad != NULL && ad_size > 0) {\n    // write AD if present\n    poly1305_update(&poly_ctx, ad, ad_size);\n    pad_if_needed(&poly_ctx, ad_size);\n  }\n\n  // now write the cipher text\n  poly1305_update(&poly_ctx, cipher_text, cipher_text_size);\n  pad_if_needed(&poly_ctx, cipher_text_size);\n\n  // write sizes\n  write_64bit_int(&poly_ctx, ad_size);\n  write_64bit_int(&poly_ctx, cipher_text_size);\n\n  // calculate MAC\n  poly1305_finish(&poly_ctx, mac);\n}\n\n#define MG_PM(p) ((size_t) (p))\n\n// pointers overlap if the smaller either ahead of the end,\n// or its end is before the start of the other\n//\n// s_size should be smaller or equal to b_size\n#define MG_OVERLAPPING(s, s_size, b, b_size) \\\n  (MG_PM(s) < MG_PM((b) + (b_size))) && (MG_PM(b) < MG_PM((s) + (s_size)))\n\nPORTABLE_8439_DECL size_t mg_chacha20_poly1305_encrypt(\n    uint8_t *restrict cipher_text, const uint8_t key[RFC_8439_KEY_SIZE],\n    const uint8_t nonce[RFC_8439_NONCE_SIZE], const uint8_t *restrict ad,\n    size_t ad_size, const uint8_t *restrict plain_text,\n    size_t plain_text_size) {\n  size_t new_size = plain_text_size + RFC_8439_TAG_SIZE;\n  if (MG_OVERLAPPING(plain_text, plain_text_size, cipher_text, new_size)) {\n    return (size_t) -1;\n  }\n  chacha20_xor_stream(cipher_text, plain_text, plain_text_size, key, nonce, 1);\n  poly1305_calculate_mac(cipher_text + plain_text_size, cipher_text,\n                         plain_text_size, key, nonce, ad, ad_size);\n  return new_size;\n}\n\nPORTABLE_8439_DECL size_t mg_chacha20_poly1305_decrypt(\n    uint8_t *restrict plain_text, const uint8_t key[RFC_8439_KEY_SIZE],\n    const uint8_t nonce[RFC_8439_NONCE_SIZE],\n    const uint8_t *restrict cipher_text, size_t cipher_text_size) {\n  // first we calculate the mac and see if it lines up, only then do we decrypt\n  size_t actual_size = cipher_text_size - RFC_8439_TAG_SIZE;\n  if (MG_OVERLAPPING(plain_text, actual_size, cipher_text, cipher_text_size)) {\n    return (size_t) -1;\n  }\n\n  chacha20_xor_stream(plain_text, cipher_text, actual_size, key, nonce, 1);\n  return actual_size;\n}\n// ******* END:   portable8439.c ********\n#endif  // MG_TLS == MG_TLS_BUILTIN\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_dummy.c\"\n#endif\n\n\n#if MG_TLS == MG_TLS_NONE\nvoid mg_tls_init(struct mg_connection *c, const struct mg_tls_opts *opts) {\n  (void) opts;\n  mg_error(c, \"TLS is not enabled\");\n}\nvoid mg_tls_handshake(struct mg_connection *c) {\n  (void) c;\n}\nvoid mg_tls_free(struct mg_connection *c) {\n  (void) c;\n}\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  return c == NULL || buf == NULL || len == 0 ? 0 : -1;\n}\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  return c == NULL || buf == NULL || len == 0 ? 0 : -1;\n}\nsize_t mg_tls_pending(struct mg_connection *c) {\n  (void) c;\n  return 0;\n}\nvoid mg_tls_ctx_init(struct mg_mgr *mgr) {\n  (void) mgr;\n}\nvoid mg_tls_ctx_free(struct mg_mgr *mgr) {\n  (void) mgr;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_mbed.c\"\n#endif\n\n\n\n#if MG_TLS == MG_TLS_MBED\n\n#if defined(MBEDTLS_VERSION_NUMBER) && MBEDTLS_VERSION_NUMBER >= 0x03000000\n#define MG_MBEDTLS_RNG_GET , mg_mbed_rng, NULL\n#else\n#define MG_MBEDTLS_RNG_GET\n#endif\n\nstatic int mg_mbed_rng(void *ctx, unsigned char *buf, size_t len) {\n  mg_random(buf, len);\n  (void) ctx;\n  return 0;\n}\n\nstatic bool mg_load_cert(struct mg_str str, mbedtls_x509_crt *p) {\n  int rc;\n  if (str.buf == NULL || str.buf[0] == '\\0' || str.buf[0] == '*') return true;\n  if (str.buf[0] == '-') str.len++;  // PEM, include trailing NUL\n  if ((rc = mbedtls_x509_crt_parse(p, (uint8_t *) str.buf, str.len)) != 0) {\n    MG_ERROR((\"cert err %#x\", -rc));\n    return false;\n  }\n  return true;\n}\n\nstatic bool mg_load_key(struct mg_str str, mbedtls_pk_context *p) {\n  int rc;\n  if (str.buf == NULL || str.buf[0] == '\\0' || str.buf[0] == '*') return true;\n  if (str.buf[0] == '-') str.len++;  // PEM, include trailing NUL\n  if ((rc = mbedtls_pk_parse_key(p, (uint8_t *) str.buf, str.len, NULL,\n                                 0 MG_MBEDTLS_RNG_GET)) != 0) {\n    MG_ERROR((\"key err %#x\", -rc));\n    return false;\n  }\n  return true;\n}\n\nvoid mg_tls_free(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  if (tls != NULL) {\n    mbedtls_ssl_free(&tls->ssl);\n    mbedtls_pk_free(&tls->pk);\n    mbedtls_x509_crt_free(&tls->ca);\n    mbedtls_x509_crt_free(&tls->cert);\n    mbedtls_ssl_config_free(&tls->conf);\n#ifdef MBEDTLS_SSL_SESSION_TICKETS\n    mbedtls_ssl_ticket_free(&tls->ticket);\n#endif\n    free(tls);\n    c->tls = NULL;\n  }\n}\n\nstatic int mg_net_send(void *ctx, const unsigned char *buf, size_t len) {\n  long n = mg_io_send((struct mg_connection *) ctx, buf, len);\n  MG_VERBOSE((\"%lu n=%ld e=%d\", ((struct mg_connection *) ctx)->id, n, errno));\n  if (n == MG_IO_WAIT) return MBEDTLS_ERR_SSL_WANT_WRITE;\n  if (n == MG_IO_RESET) return MBEDTLS_ERR_NET_CONN_RESET;\n  if (n == MG_IO_ERR) return MBEDTLS_ERR_NET_SEND_FAILED;\n  return (int) n;\n}\n\nstatic int mg_net_recv(void *ctx, unsigned char *buf, size_t len) {\n  long n = mg_io_recv((struct mg_connection *) ctx, buf, len);\n  MG_VERBOSE((\"%lu n=%ld\", ((struct mg_connection *) ctx)->id, n));\n  if (n == MG_IO_WAIT) return MBEDTLS_ERR_SSL_WANT_WRITE;\n  if (n == MG_IO_RESET) return MBEDTLS_ERR_NET_CONN_RESET;\n  if (n == MG_IO_ERR) return MBEDTLS_ERR_NET_RECV_FAILED;\n  return (int) n;\n}\n\nvoid mg_tls_handshake(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int rc = mbedtls_ssl_handshake(&tls->ssl);\n  if (rc == 0) {  // Success\n    MG_DEBUG((\"%lu success\", c->id));\n    c->is_tls_hs = 0;\n    mg_call(c, MG_EV_TLS_HS, NULL);\n  } else if (rc == MBEDTLS_ERR_SSL_WANT_READ ||\n             rc == MBEDTLS_ERR_SSL_WANT_WRITE) {  // Still pending\n    MG_VERBOSE((\"%lu pending, %d%d %d (-%#x)\", c->id, c->is_connecting,\n                c->is_tls_hs, rc, -rc));\n  } else {\n    mg_error(c, \"TLS handshake: -%#x\", -rc);  // Error\n  }\n}\n\nstatic void debug_cb(void *c, int lev, const char *s, int n, const char *s2) {\n  n = (int) strlen(s2) - 1;\n  MG_INFO((\"%lu %d %.*s\", ((struct mg_connection *) c)->id, lev, n, s2));\n  (void) s;\n}\n\nvoid mg_tls_init(struct mg_connection *c, const struct mg_tls_opts *opts) {\n  struct mg_tls *tls = (struct mg_tls *) calloc(1, sizeof(*tls));\n  int rc = 0;\n  c->tls = tls;\n  if (c->tls == NULL) {\n    mg_error(c, \"TLS OOM\");\n    goto fail;\n  }\n  if (c->is_listening) goto fail;\n  MG_DEBUG((\"%lu Setting TLS\", c->id));\n  MG_PROF_ADD(c, \"mbedtls_init_start\");\n#if defined(MBEDTLS_VERSION_NUMBER) && MBEDTLS_VERSION_NUMBER >= 0x03000000 && \\\n    defined(MBEDTLS_PSA_CRYPTO_C)\n  psa_crypto_init();  // https://github.com/Mbed-TLS/mbedtls/issues/9072#issuecomment-2084845711\n#endif\n  mbedtls_ssl_init(&tls->ssl);\n  mbedtls_ssl_config_init(&tls->conf);\n  mbedtls_x509_crt_init(&tls->ca);\n  mbedtls_x509_crt_init(&tls->cert);\n  mbedtls_pk_init(&tls->pk);\n  mbedtls_ssl_conf_dbg(&tls->conf, debug_cb, c);\n#if defined(MG_MBEDTLS_DEBUG_LEVEL)\n  mbedtls_debug_set_threshold(MG_MBEDTLS_DEBUG_LEVEL);\n#endif\n  if ((rc = mbedtls_ssl_config_defaults(\n           &tls->conf,\n           c->is_client ? MBEDTLS_SSL_IS_CLIENT : MBEDTLS_SSL_IS_SERVER,\n           MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT)) != 0) {\n    mg_error(c, \"tls defaults %#x\", -rc);\n    goto fail;\n  }\n  mbedtls_ssl_conf_rng(&tls->conf, mg_mbed_rng, c);\n\n  if (opts->ca.len == 0 || mg_strcmp(opts->ca, mg_str(\"*\")) == 0) {\n    // NOTE: MBEDTLS_SSL_VERIFY_NONE is not supported for TLS1.3 on client side\n    // See https://github.com/Mbed-TLS/mbedtls/issues/7075\n    mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_NONE);\n  } else {\n    if (mg_load_cert(opts->ca, &tls->ca) == false) goto fail;\n    mbedtls_ssl_conf_ca_chain(&tls->conf, &tls->ca, NULL);\n    if (c->is_client && opts->name.buf != NULL && opts->name.buf[0] != '\\0') {\n      char *host = mg_mprintf(\"%.*s\", opts->name.len, opts->name.buf);\n      mbedtls_ssl_set_hostname(&tls->ssl, host);\n      MG_DEBUG((\"%lu hostname verification: %s\", c->id, host));\n      free(host);\n    }\n    mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_REQUIRED);\n  }\n  if (!mg_load_cert(opts->cert, &tls->cert)) goto fail;\n  if (!mg_load_key(opts->key, &tls->pk)) goto fail;\n  if (tls->cert.version &&\n      (rc = mbedtls_ssl_conf_own_cert(&tls->conf, &tls->cert, &tls->pk)) != 0) {\n    mg_error(c, \"own cert %#x\", -rc);\n    goto fail;\n  }\n\n#ifdef MBEDTLS_SSL_SESSION_TICKETS\n  mbedtls_ssl_conf_session_tickets_cb(\n      &tls->conf, mbedtls_ssl_ticket_write, mbedtls_ssl_ticket_parse,\n      &((struct mg_tls_ctx *) c->mgr->tls_ctx)->tickets);\n#endif\n\n  if ((rc = mbedtls_ssl_setup(&tls->ssl, &tls->conf)) != 0) {\n    mg_error(c, \"setup err %#x\", -rc);\n    goto fail;\n  }\n  c->is_tls = 1;\n  c->is_tls_hs = 1;\n  mbedtls_ssl_set_bio(&tls->ssl, c, mg_net_send, mg_net_recv, 0);\n  MG_PROF_ADD(c, \"mbedtls_init_end\");\n  if (c->is_client && c->is_resolving == 0 && c->is_connecting == 0) {\n    mg_tls_handshake(c);\n  }\n  return;\nfail:\n  mg_tls_free(c);\n}\n\nsize_t mg_tls_pending(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  return tls == NULL ? 0 : mbedtls_ssl_get_bytes_avail(&tls->ssl);\n}\n\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  long n = mbedtls_ssl_read(&tls->ssl, (unsigned char *) buf, len);\n  if (n == MBEDTLS_ERR_SSL_WANT_READ || n == MBEDTLS_ERR_SSL_WANT_WRITE)\n    return MG_IO_WAIT;\n#if defined(MBEDTLS_ERR_SSL_RECEIVED_NEW_SESSION_TICKET)\n  if (n == MBEDTLS_ERR_SSL_RECEIVED_NEW_SESSION_TICKET) {\n    return MG_IO_WAIT;\n  }\n#endif\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  long n = mbedtls_ssl_write(&tls->ssl, (unsigned char *) buf, len);\n  if (n == MBEDTLS_ERR_SSL_WANT_READ || n == MBEDTLS_ERR_SSL_WANT_WRITE)\n    return MG_IO_WAIT;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n\nvoid mg_tls_ctx_init(struct mg_mgr *mgr) {\n  struct mg_tls_ctx *ctx = (struct mg_tls_ctx *) calloc(1, sizeof(*ctx));\n  if (ctx == NULL) {\n    MG_ERROR((\"TLS context init OOM\"));\n  } else {\n#ifdef MBEDTLS_SSL_SESSION_TICKETS\n    int rc;\n    mbedtls_ssl_ticket_init(&ctx->tickets);\n    if ((rc = mbedtls_ssl_ticket_setup(&ctx->tickets, mg_mbed_rng, NULL,\n                                       MBEDTLS_CIPHER_AES_128_GCM, 86400)) !=\n        0) {\n      MG_ERROR((\" mbedtls_ssl_ticket_setup %#x\", -rc));\n    }\n#endif\n    mgr->tls_ctx = ctx;\n  }\n}\n\nvoid mg_tls_ctx_free(struct mg_mgr *mgr) {\n  struct mg_tls_ctx *ctx = (struct mg_tls_ctx *) mgr->tls_ctx;\n  if (ctx != NULL) {\n#ifdef MBEDTLS_SSL_SESSION_TICKETS\n    mbedtls_ssl_ticket_free(&ctx->tickets);\n#endif\n    free(ctx);\n    mgr->tls_ctx = NULL;\n  }\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_openssl.c\"\n#endif\n\n\n\n#if MG_TLS == MG_TLS_OPENSSL || MG_TLS == MG_TLS_WOLFSSL\n\nstatic int tls_err_cb(const char *s, size_t len, void *c) {\n  int n = (int) len - 1;\n  MG_ERROR((\"%lu %.*s\", ((struct mg_connection *) c)->id, n, s));\n  return 0;  // undocumented\n}\n\nstatic int mg_tls_err(struct mg_connection *c, struct mg_tls *tls, int res) {\n  int err = SSL_get_error(tls->ssl, res);\n  // We've just fetched the last error from the queue.\n  // Now we need to clear the error queue. If we do not, then the following\n  // can happen (actually reported):\n  //  - A new connection is accept()-ed with cert error (e.g. self-signed cert)\n  //  - Since all accept()-ed connections share listener's context,\n  //  - *ALL* SSL accepted connection report read error on the next poll cycle.\n  //    Thus a single errored connection can close all the rest, unrelated ones.\n  // Clearing the error keeps the shared SSL_CTX in an OK state.\n\n  if (err != 0) ERR_print_errors_cb(tls_err_cb, c);\n  ERR_clear_error();\n  if (err == SSL_ERROR_WANT_READ) return 0;\n  if (err == SSL_ERROR_WANT_WRITE) return 0;\n  return err;\n}\n\nstatic STACK_OF(X509_INFO) * load_ca_certs(struct mg_str ca) {\n  BIO *bio = BIO_new_mem_buf(ca.buf, (int) ca.len);\n  STACK_OF(X509_INFO) *certs =\n      bio ? PEM_X509_INFO_read_bio(bio, NULL, NULL, NULL) : NULL;\n  if (bio) BIO_free(bio);\n  return certs;\n}\n\nstatic bool add_ca_certs(SSL_CTX *ctx, STACK_OF(X509_INFO) * certs) {\n  int i;\n  X509_STORE *cert_store = SSL_CTX_get_cert_store(ctx);\n  for (i = 0; i < sk_X509_INFO_num(certs); i++) {\n    X509_INFO *cert_info = sk_X509_INFO_value(certs, i);\n    if (cert_info->x509 && !X509_STORE_add_cert(cert_store, cert_info->x509))\n      return false;\n  }\n  return true;\n}\n\nstatic EVP_PKEY *load_key(struct mg_str s) {\n  BIO *bio = BIO_new_mem_buf(s.buf, (int) (long) s.len);\n  EVP_PKEY *key = bio ? PEM_read_bio_PrivateKey(bio, NULL, 0, NULL) : NULL;\n  if (bio) BIO_free(bio);\n  return key;\n}\n\nstatic X509 *load_cert(struct mg_str s) {\n  BIO *bio = BIO_new_mem_buf(s.buf, (int) (long) s.len);\n  X509 *cert = bio == NULL ? NULL\n               : s.buf[0] == '-'\n                   ? PEM_read_bio_X509(bio, NULL, NULL, NULL)  // PEM\n                   : d2i_X509_bio(bio, NULL);                  // DER\n  if (bio) BIO_free(bio);\n  return cert;\n}\n\nstatic long mg_bio_ctrl(BIO *b, int cmd, long larg, void *pargs) {\n  long ret = 0;\n  if (cmd == BIO_CTRL_PUSH) ret = 1;\n  if (cmd == BIO_CTRL_POP) ret = 1;\n  if (cmd == BIO_CTRL_FLUSH) ret = 1;\n#if MG_TLS == MG_TLS_OPENSSL\n  if (cmd == BIO_C_SET_NBIO) ret = 1;\n#endif\n  // MG_DEBUG((\"%d -> %ld\", cmd, ret));\n  (void) b, (void) cmd, (void) larg, (void) pargs;\n  return ret;\n}\n\nstatic int mg_bio_read(BIO *bio, char *buf, int len) {\n  struct mg_connection *c = (struct mg_connection *) BIO_get_data(bio);\n  long res = mg_io_recv(c, buf, (size_t) len);\n  // MG_DEBUG((\"%p %d %ld\", buf, len, res));\n  len = res > 0 ? (int) res : -1;\n  if (res == MG_IO_WAIT) BIO_set_retry_read(bio);\n  return len;\n}\n\nstatic int mg_bio_write(BIO *bio, const char *buf, int len) {\n  struct mg_connection *c = (struct mg_connection *) BIO_get_data(bio);\n  long res = mg_io_send(c, buf, (size_t) len);\n  // MG_DEBUG((\"%p %d %ld\", buf, len, res));\n  len = res > 0 ? (int) res : -1;\n  if (res == MG_IO_WAIT) BIO_set_retry_write(bio);\n  return len;\n}\n\n#ifdef MG_TLS_SSLKEYLOGFILE\nstatic void ssl_keylog_cb(const SSL *ssl, const char *line) {\n  char *keylogfile = getenv(\"SSLKEYLOGFILE\");\n  if (keylogfile == NULL) {\n    return;\n  }\n  FILE *f = fopen(keylogfile, \"a\");\n  fprintf(f, \"%s\\n\", line);\n  fflush(f);\n  fclose(f);\n}\n#endif\n\nvoid mg_tls_free(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  if (tls == NULL) return;\n  SSL_free(tls->ssl);\n  SSL_CTX_free(tls->ctx);\n  BIO_meth_free(tls->bm);\n  free(tls);\n  c->tls = NULL;\n}\n\nvoid mg_tls_init(struct mg_connection *c, const struct mg_tls_opts *opts) {\n  struct mg_tls *tls = (struct mg_tls *) calloc(1, sizeof(*tls));\n  const char *id = \"mongoose\";\n  static unsigned char s_initialised = 0;\n  BIO *bio = NULL;\n  int rc;\n  c->tls = tls;\n  if (tls == NULL) {\n    mg_error(c, \"TLS OOM\");\n    goto fail;\n  }\n\n  if (!s_initialised) {\n    SSL_library_init();\n    s_initialised++;\n  }\n  MG_DEBUG((\"%lu Setting TLS\", c->id));\n  tls->ctx = c->is_client ? SSL_CTX_new(TLS_client_method())\n                          : SSL_CTX_new(TLS_server_method());\n  if (tls->ctx == NULL) {\n    mg_error(c, \"SSL_CTX_new\");\n    goto fail;\n  }\n#ifdef MG_TLS_SSLKEYLOGFILE\n  SSL_CTX_set_keylog_callback(tls->ctx, ssl_keylog_cb);\n#endif\n  if ((tls->ssl = SSL_new(tls->ctx)) == NULL) {\n    mg_error(c, \"SSL_new\");\n    goto fail;\n  }\n  SSL_set_session_id_context(tls->ssl, (const uint8_t *) id,\n                             (unsigned) strlen(id));\n  // Disable deprecated protocols\n  SSL_set_options(tls->ssl, SSL_OP_NO_SSLv2);\n  SSL_set_options(tls->ssl, SSL_OP_NO_SSLv3);\n  SSL_set_options(tls->ssl, SSL_OP_NO_TLSv1);\n  SSL_set_options(tls->ssl, SSL_OP_NO_TLSv1_1);\n#ifdef MG_ENABLE_OPENSSL_NO_COMPRESSION\n  SSL_set_options(tls->ssl, SSL_OP_NO_COMPRESSION);\n#endif\n#ifdef MG_ENABLE_OPENSSL_CIPHER_SERVER_PREFERENCE\n  SSL_set_options(tls->ssl, SSL_OP_CIPHER_SERVER_PREFERENCE);\n#endif\n\n#if MG_TLS == MG_TLS_WOLFSSL && !defined(OPENSSL_COMPATIBLE_DEFAULTS)\n  if (opts->ca.len == 0 || mg_strcmp(opts->ca, mg_str(\"*\")) == 0) {\n    // Older versions require that either the CA is loaded or SSL_VERIFY_NONE\n    // explicitly set\n    SSL_set_verify(tls->ssl, SSL_VERIFY_NONE, NULL);\n  }\n#endif\n  if (opts->ca.buf != NULL && opts->ca.buf[0] != '\\0') {\n    SSL_set_verify(tls->ssl, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n                   NULL);\n    STACK_OF(X509_INFO) *certs = load_ca_certs(opts->ca);\n    rc = add_ca_certs(tls->ctx, certs);\n    sk_X509_INFO_pop_free(certs, X509_INFO_free);\n    if (!rc) {\n      mg_error(c, \"CA err\");\n      goto fail;\n    }\n  }\n  if (opts->cert.buf != NULL && opts->cert.buf[0] != '\\0') {\n    X509 *cert = load_cert(opts->cert);\n    rc = cert == NULL ? 0 : SSL_use_certificate(tls->ssl, cert);\n    X509_free(cert);\n    if (cert == NULL || rc != 1) {\n      mg_error(c, \"CERT err %d\", mg_tls_err(c, tls, rc));\n      goto fail;\n    }\n  }\n  if (opts->key.buf != NULL && opts->key.buf[0] != '\\0') {\n    EVP_PKEY *key = load_key(opts->key);\n    rc = key == NULL ? 0 : SSL_use_PrivateKey(tls->ssl, key);\n    EVP_PKEY_free(key);\n    if (key == NULL || rc != 1) {\n      mg_error(c, \"KEY err %d\", mg_tls_err(c, tls, rc));\n      goto fail;\n    }\n  }\n\n  SSL_set_mode(tls->ssl, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);\n#if MG_TLS == MG_TLS_OPENSSL && OPENSSL_VERSION_NUMBER > 0x10002000L\n  (void) SSL_set_ecdh_auto(tls->ssl, 1);\n#endif\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n  if (opts->name.len > 0) {\n    char *s = mg_mprintf(\"%.*s\", (int) opts->name.len, opts->name.buf);\n#if MG_TLS != MG_TLS_WOLFSSL || LIBWOLFSSL_VERSION_HEX >= 0x05005002\n    SSL_set1_host(tls->ssl, s);\n#else\n    X509_VERIFY_PARAM_set1_host(SSL_get0_param(tls->ssl), s, 0);\n#endif\n    SSL_set_tlsext_host_name(tls->ssl, s);\n    free(s);\n  }\n#endif\n#if MG_TLS == MG_TLS_WOLFSSL\n  tls->bm = BIO_meth_new(0, \"bio_mg\");\n#else\n  tls->bm = BIO_meth_new(BIO_get_new_index() | BIO_TYPE_SOURCE_SINK, \"bio_mg\");\n#endif\n  BIO_meth_set_write(tls->bm, mg_bio_write);\n  BIO_meth_set_read(tls->bm, mg_bio_read);\n  BIO_meth_set_ctrl(tls->bm, mg_bio_ctrl);\n\n  bio = BIO_new(tls->bm);\n  BIO_set_data(bio, c);\n  SSL_set_bio(tls->ssl, bio, bio);\n\n  c->is_tls = 1;\n  c->is_tls_hs = 1;\n  if (c->is_client && c->is_resolving == 0 && c->is_connecting == 0) {\n    mg_tls_handshake(c);\n  }\n  MG_DEBUG((\"%lu SSL %s OK\", c->id, c->is_accepted ? \"accept\" : \"client\"));\n  return;\nfail:\n  mg_tls_free(c);\n}\n\nvoid mg_tls_handshake(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int rc = c->is_client ? SSL_connect(tls->ssl) : SSL_accept(tls->ssl);\n  if (rc == 1) {\n    MG_DEBUG((\"%lu success\", c->id));\n    c->is_tls_hs = 0;\n    mg_call(c, MG_EV_TLS_HS, NULL);\n  } else {\n    int code = mg_tls_err(c, tls, rc);\n    if (code != 0) mg_error(c, \"tls hs: rc %d, err %d\", rc, code);\n  }\n}\n\nsize_t mg_tls_pending(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  return tls == NULL ? 0 : (size_t) SSL_pending(tls->ssl);\n}\n\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int n = SSL_read(tls->ssl, buf, (int) len);\n  if (n < 0 && mg_tls_err(c, tls, n) == 0) return MG_IO_WAIT;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int n = SSL_write(tls->ssl, buf, (int) len);\n  if (n < 0 && mg_tls_err(c, tls, n) == 0) return MG_IO_WAIT;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n\nvoid mg_tls_ctx_init(struct mg_mgr *mgr) {\n  (void) mgr;\n}\n\nvoid mg_tls_ctx_free(struct mg_mgr *mgr) {\n  (void) mgr;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_uecc.c\"\n#endif\n/* Copyright 2014, Kenneth MacKay. Licensed under the BSD 2-clause license. */\n\n\n\n\n#if MG_TLS == MG_TLS_BUILTIN\n\n#ifndef MG_UECC_RNG_MAX_TRIES\n#define MG_UECC_RNG_MAX_TRIES 64\n#endif\n\n#if MG_UECC_ENABLE_VLI_API\n#define MG_UECC_VLI_API\n#else\n#define MG_UECC_VLI_API static\n#endif\n\n#if (MG_UECC_PLATFORM == mg_uecc_avr) || (MG_UECC_PLATFORM == mg_uecc_arm) || \\\n    (MG_UECC_PLATFORM == mg_uecc_arm_thumb) ||                                \\\n    (MG_UECC_PLATFORM == mg_uecc_arm_thumb2)\n#define MG_UECC_CONCATX(a, ...) a##__VA_ARGS__\n#define MG_UECC_CONCAT(a, ...) MG_UECC_CONCATX(a, __VA_ARGS__)\n\n#define STRX(a) #a\n#define STR(a) STRX(a)\n\n#define EVAL(...) EVAL1(EVAL1(EVAL1(EVAL1(__VA_ARGS__))))\n#define EVAL1(...) EVAL2(EVAL2(EVAL2(EVAL2(__VA_ARGS__))))\n#define EVAL2(...) EVAL3(EVAL3(EVAL3(EVAL3(__VA_ARGS__))))\n#define EVAL3(...) EVAL4(EVAL4(EVAL4(EVAL4(__VA_ARGS__))))\n#define EVAL4(...) __VA_ARGS__\n\n#define DEC_1 0\n#define DEC_2 1\n#define DEC_3 2\n#define DEC_4 3\n#define DEC_5 4\n#define DEC_6 5\n#define DEC_7 6\n#define DEC_8 7\n#define DEC_9 8\n#define DEC_10 9\n#define DEC_11 10\n#define DEC_12 11\n#define DEC_13 12\n#define DEC_14 13\n#define DEC_15 14\n#define DEC_16 15\n#define DEC_17 16\n#define DEC_18 17\n#define DEC_19 18\n#define DEC_20 19\n#define DEC_21 20\n#define DEC_22 21\n#define DEC_23 22\n#define DEC_24 23\n#define DEC_25 24\n#define DEC_26 25\n#define DEC_27 26\n#define DEC_28 27\n#define DEC_29 28\n#define DEC_30 29\n#define DEC_31 30\n#define DEC_32 31\n\n#define DEC(N) MG_UECC_CONCAT(DEC_, N)\n\n#define SECOND_ARG(_, val, ...) val\n#define SOME_CHECK_0 ~, 0\n#define GET_SECOND_ARG(...) SECOND_ARG(__VA_ARGS__, SOME, )\n#define SOME_OR_0(N) GET_SECOND_ARG(MG_UECC_CONCAT(SOME_CHECK_, N))\n\n#define MG_UECC_EMPTY(...)\n#define DEFER(...) __VA_ARGS__ MG_UECC_EMPTY()\n\n#define REPEAT_NAME_0() REPEAT_0\n#define REPEAT_NAME_SOME() REPEAT_SOME\n#define REPEAT_0(...)\n#define REPEAT_SOME(N, stuff) \\\n  DEFER(MG_UECC_CONCAT(REPEAT_NAME_, SOME_OR_0(DEC(N))))()(DEC(N), stuff) stuff\n#define REPEAT(N, stuff) EVAL(REPEAT_SOME(N, stuff))\n\n#define REPEATM_NAME_0() REPEATM_0\n#define REPEATM_NAME_SOME() REPEATM_SOME\n#define REPEATM_0(...)\n#define REPEATM_SOME(N, macro) \\\n  macro(N) DEFER(MG_UECC_CONCAT(REPEATM_NAME_, SOME_OR_0(DEC(N))))()(DEC(N), macro)\n#define REPEATM(N, macro) EVAL(REPEATM_SOME(N, macro))\n#endif\n\n// \n\n#if (MG_UECC_WORD_SIZE == 1)\n#if MG_UECC_SUPPORTS_secp160r1\n#define MG_UECC_MAX_WORDS 21 /* Due to the size of curve_n. */\n#endif\n#if MG_UECC_SUPPORTS_secp192r1\n#undef MG_UECC_MAX_WORDS\n#define MG_UECC_MAX_WORDS 24\n#endif\n#if MG_UECC_SUPPORTS_secp224r1\n#undef MG_UECC_MAX_WORDS\n#define MG_UECC_MAX_WORDS 28\n#endif\n#if (MG_UECC_SUPPORTS_secp256r1 || MG_UECC_SUPPORTS_secp256k1)\n#undef MG_UECC_MAX_WORDS\n#define MG_UECC_MAX_WORDS 32\n#endif\n#elif (MG_UECC_WORD_SIZE == 4)\n#if MG_UECC_SUPPORTS_secp160r1\n#define MG_UECC_MAX_WORDS 6 /* Due to the size of curve_n. */\n#endif\n#if MG_UECC_SUPPORTS_secp192r1\n#undef MG_UECC_MAX_WORDS\n#define MG_UECC_MAX_WORDS 6\n#endif\n#if MG_UECC_SUPPORTS_secp224r1\n#undef MG_UECC_MAX_WORDS\n#define MG_UECC_MAX_WORDS 7\n#endif\n#if (MG_UECC_SUPPORTS_secp256r1 || MG_UECC_SUPPORTS_secp256k1)\n#undef MG_UECC_MAX_WORDS\n#define MG_UECC_MAX_WORDS 8\n#endif\n#elif (MG_UECC_WORD_SIZE == 8)\n#if MG_UECC_SUPPORTS_secp160r1\n#define MG_UECC_MAX_WORDS 3\n#endif\n#if MG_UECC_SUPPORTS_secp192r1\n#undef MG_UECC_MAX_WORDS\n#define MG_UECC_MAX_WORDS 3\n#endif\n#if MG_UECC_SUPPORTS_secp224r1\n#undef MG_UECC_MAX_WORDS\n#define MG_UECC_MAX_WORDS 4\n#endif\n#if (MG_UECC_SUPPORTS_secp256r1 || MG_UECC_SUPPORTS_secp256k1)\n#undef MG_UECC_MAX_WORDS\n#define MG_UECC_MAX_WORDS 4\n#endif\n#endif /* MG_UECC_WORD_SIZE */\n\n#define BITS_TO_WORDS(num_bits)                                \\\n  ((wordcount_t) ((num_bits + ((MG_UECC_WORD_SIZE * 8) - 1)) / \\\n                  (MG_UECC_WORD_SIZE * 8)))\n#define BITS_TO_BYTES(num_bits) ((num_bits + 7) / 8)\n\nstruct MG_UECC_Curve_t {\n  wordcount_t num_words;\n  wordcount_t num_bytes;\n  bitcount_t num_n_bits;\n  mg_uecc_word_t p[MG_UECC_MAX_WORDS];\n  mg_uecc_word_t n[MG_UECC_MAX_WORDS];\n  mg_uecc_word_t G[MG_UECC_MAX_WORDS * 2];\n  mg_uecc_word_t b[MG_UECC_MAX_WORDS];\n  void (*double_jacobian)(mg_uecc_word_t *X1, mg_uecc_word_t *Y1,\n                          mg_uecc_word_t *Z1, MG_UECC_Curve curve);\n#if MG_UECC_SUPPORT_COMPRESSED_POINT\n  void (*mod_sqrt)(mg_uecc_word_t *a, MG_UECC_Curve curve);\n#endif\n  void (*x_side)(mg_uecc_word_t *result, const mg_uecc_word_t *x,\n                 MG_UECC_Curve curve);\n#if (MG_UECC_OPTIMIZATION_LEVEL > 0)\n  void (*mmod_fast)(mg_uecc_word_t *result, mg_uecc_word_t *product);\n#endif\n};\n\n#if MG_UECC_VLI_NATIVE_LITTLE_ENDIAN\nstatic void bcopy(uint8_t *dst, const uint8_t *src, unsigned num_bytes) {\n  while (0 != num_bytes) {\n    num_bytes--;\n    dst[num_bytes] = src[num_bytes];\n  }\n}\n#endif\n\nstatic cmpresult_t mg_uecc_vli_cmp_unsafe(const mg_uecc_word_t *left,\n                                          const mg_uecc_word_t *right,\n                                          wordcount_t num_words);\n\n#if (MG_UECC_PLATFORM == mg_uecc_arm ||       \\\n     MG_UECC_PLATFORM == mg_uecc_arm_thumb || \\\n     MG_UECC_PLATFORM == mg_uecc_arm_thumb2)\n\n#endif\n\n#if (MG_UECC_PLATFORM == mg_uecc_avr)\n\n#endif\n\n#ifndef asm_clear\n#define asm_clear 0\n#endif\n#ifndef asm_set\n#define asm_set 0\n#endif\n#ifndef asm_add\n#define asm_add 0\n#endif\n#ifndef asm_sub\n#define asm_sub 0\n#endif\n#ifndef asm_mult\n#define asm_mult 0\n#endif\n#ifndef asm_rshift1\n#define asm_rshift1 0\n#endif\n#ifndef asm_mmod_fast_secp256r1\n#define asm_mmod_fast_secp256r1 0\n#endif\n\n#if defined(default_RNG_defined) && default_RNG_defined\nstatic MG_UECC_RNG_Function g_rng_function = &default_RNG;\n#else\nstatic MG_UECC_RNG_Function g_rng_function = 0;\n#endif\n\nvoid mg_uecc_set_rng(MG_UECC_RNG_Function rng_function) {\n  g_rng_function = rng_function;\n}\n\nMG_UECC_RNG_Function mg_uecc_get_rng(void) {\n  return g_rng_function;\n}\n\nint mg_uecc_curve_private_key_size(MG_UECC_Curve curve) {\n  return BITS_TO_BYTES(curve->num_n_bits);\n}\n\nint mg_uecc_curve_public_key_size(MG_UECC_Curve curve) {\n  return 2 * curve->num_bytes;\n}\n\n#if !asm_clear\nMG_UECC_VLI_API void mg_uecc_vli_clear(mg_uecc_word_t *vli,\n                                       wordcount_t num_words) {\n  wordcount_t i;\n  for (i = 0; i < num_words; ++i) {\n    vli[i] = 0;\n  }\n}\n#endif /* !asm_clear */\n\n/* Constant-time comparison to zero - secure way to compare long integers */\n/* Returns 1 if vli == 0, 0 otherwise. */\nMG_UECC_VLI_API mg_uecc_word_t mg_uecc_vli_isZero(const mg_uecc_word_t *vli,\n                                                  wordcount_t num_words) {\n  mg_uecc_word_t bits = 0;\n  wordcount_t i;\n  for (i = 0; i < num_words; ++i) {\n    bits |= vli[i];\n  }\n  return (bits == 0);\n}\n\n/* Returns nonzero if bit 'bit' of vli is set. */\nMG_UECC_VLI_API mg_uecc_word_t mg_uecc_vli_testBit(const mg_uecc_word_t *vli,\n                                                   bitcount_t bit) {\n  return (vli[bit >> MG_UECC_WORD_BITS_SHIFT] &\n          ((mg_uecc_word_t) 1 << (bit & MG_UECC_WORD_BITS_MASK)));\n}\n\n/* Counts the number of words in vli. */\nstatic wordcount_t vli_numDigits(const mg_uecc_word_t *vli,\n                                 const wordcount_t max_words) {\n  wordcount_t i;\n  /* Search from the end until we find a non-zero digit.\n     We do it in reverse because we expect that most digits will be nonzero. */\n  for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {\n  }\n\n  return (i + 1);\n}\n\n/* Counts the number of bits required to represent vli. */\nMG_UECC_VLI_API bitcount_t mg_uecc_vli_numBits(const mg_uecc_word_t *vli,\n                                               const wordcount_t max_words) {\n  mg_uecc_word_t i;\n  mg_uecc_word_t digit;\n\n  wordcount_t num_digits = vli_numDigits(vli, max_words);\n  if (num_digits == 0) {\n    return 0;\n  }\n\n  digit = vli[num_digits - 1];\n  for (i = 0; digit; ++i) {\n    digit >>= 1;\n  }\n\n  return (((bitcount_t) ((num_digits - 1) << MG_UECC_WORD_BITS_SHIFT)) +\n          (bitcount_t) i);\n}\n\n/* Sets dest = src. */\n#if !asm_set\nMG_UECC_VLI_API void mg_uecc_vli_set(mg_uecc_word_t *dest,\n                                     const mg_uecc_word_t *src,\n                                     wordcount_t num_words) {\n  wordcount_t i;\n  for (i = 0; i < num_words; ++i) {\n    dest[i] = src[i];\n  }\n}\n#endif /* !asm_set */\n\n/* Returns sign of left - right. */\nstatic cmpresult_t mg_uecc_vli_cmp_unsafe(const mg_uecc_word_t *left,\n                                          const mg_uecc_word_t *right,\n                                          wordcount_t num_words) {\n  wordcount_t i;\n  for (i = num_words - 1; i >= 0; --i) {\n    if (left[i] > right[i]) {\n      return 1;\n    } else if (left[i] < right[i]) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\n/* Constant-time comparison function - secure way to compare long integers */\n/* Returns one if left == right, zero otherwise. */\nMG_UECC_VLI_API mg_uecc_word_t mg_uecc_vli_equal(const mg_uecc_word_t *left,\n                                                 const mg_uecc_word_t *right,\n                                                 wordcount_t num_words) {\n  mg_uecc_word_t diff = 0;\n  wordcount_t i;\n  for (i = num_words - 1; i >= 0; --i) {\n    diff |= (left[i] ^ right[i]);\n  }\n  return (diff == 0);\n}\n\nMG_UECC_VLI_API mg_uecc_word_t mg_uecc_vli_sub(mg_uecc_word_t *result,\n                                               const mg_uecc_word_t *left,\n                                               const mg_uecc_word_t *right,\n                                               wordcount_t num_words);\n\n/* Returns sign of left - right, in constant time. */\nMG_UECC_VLI_API cmpresult_t mg_uecc_vli_cmp(const mg_uecc_word_t *left,\n                                            const mg_uecc_word_t *right,\n                                            wordcount_t num_words) {\n  mg_uecc_word_t tmp[MG_UECC_MAX_WORDS];\n  mg_uecc_word_t neg = !!mg_uecc_vli_sub(tmp, left, right, num_words);\n  mg_uecc_word_t equal = mg_uecc_vli_isZero(tmp, num_words);\n  return (cmpresult_t) (!equal - 2 * neg);\n}\n\n/* Computes vli = vli >> 1. */\n#if !asm_rshift1\nMG_UECC_VLI_API void mg_uecc_vli_rshift1(mg_uecc_word_t *vli,\n                                         wordcount_t num_words) {\n  mg_uecc_word_t *end = vli;\n  mg_uecc_word_t carry = 0;\n\n  vli += num_words;\n  while (vli-- > end) {\n    mg_uecc_word_t temp = *vli;\n    *vli = (temp >> 1) | carry;\n    carry = temp << (MG_UECC_WORD_BITS - 1);\n  }\n}\n#endif /* !asm_rshift1 */\n\n/* Computes result = left + right, returning carry. Can modify in place. */\n#if !asm_add\nMG_UECC_VLI_API mg_uecc_word_t mg_uecc_vli_add(mg_uecc_word_t *result,\n                                               const mg_uecc_word_t *left,\n                                               const mg_uecc_word_t *right,\n                                               wordcount_t num_words) {\n  mg_uecc_word_t carry = 0;\n  wordcount_t i;\n  for (i = 0; i < num_words; ++i) {\n    mg_uecc_word_t sum = left[i] + right[i] + carry;\n    if (sum != left[i]) {\n      carry = (sum < left[i]);\n    }\n    result[i] = sum;\n  }\n  return carry;\n}\n#endif /* !asm_add */\n\n/* Computes result = left - right, returning borrow. Can modify in place. */\n#if !asm_sub\nMG_UECC_VLI_API mg_uecc_word_t mg_uecc_vli_sub(mg_uecc_word_t *result,\n                                               const mg_uecc_word_t *left,\n                                               const mg_uecc_word_t *right,\n                                               wordcount_t num_words) {\n  mg_uecc_word_t borrow = 0;\n  wordcount_t i;\n  for (i = 0; i < num_words; ++i) {\n    mg_uecc_word_t diff = left[i] - right[i] - borrow;\n    if (diff != left[i]) {\n      borrow = (diff > left[i]);\n    }\n    result[i] = diff;\n  }\n  return borrow;\n}\n#endif /* !asm_sub */\n\n#if !asm_mult || (MG_UECC_SQUARE_FUNC && !asm_square) ||               \\\n    (MG_UECC_SUPPORTS_secp256k1 && (MG_UECC_OPTIMIZATION_LEVEL > 0) && \\\n     ((MG_UECC_WORD_SIZE == 1) || (MG_UECC_WORD_SIZE == 8)))\nstatic void muladd(mg_uecc_word_t a, mg_uecc_word_t b, mg_uecc_word_t *r0,\n                   mg_uecc_word_t *r1, mg_uecc_word_t *r2) {\n#if MG_UECC_WORD_SIZE == 8\n  uint64_t a0 = a & 0xffffffff;\n  uint64_t a1 = a >> 32;\n  uint64_t b0 = b & 0xffffffff;\n  uint64_t b1 = b >> 32;\n\n  uint64_t i0 = a0 * b0;\n  uint64_t i1 = a0 * b1;\n  uint64_t i2 = a1 * b0;\n  uint64_t i3 = a1 * b1;\n\n  uint64_t p0, p1;\n\n  i2 += (i0 >> 32);\n  i2 += i1;\n  if (i2 < i1) { /* overflow */\n    i3 += 0x100000000;\n  }\n\n  p0 = (i0 & 0xffffffff) | (i2 << 32);\n  p1 = i3 + (i2 >> 32);\n\n  *r0 += p0;\n  *r1 += (p1 + (*r0 < p0));\n  *r2 += ((*r1 < p1) || (*r1 == p1 && *r0 < p0));\n#else\n  mg_uecc_dword_t p = (mg_uecc_dword_t) a * b;\n  mg_uecc_dword_t r01 = ((mg_uecc_dword_t) (*r1) << MG_UECC_WORD_BITS) | *r0;\n  r01 += p;\n  *r2 += (r01 < p);\n  *r1 = (mg_uecc_word_t) (r01 >> MG_UECC_WORD_BITS);\n  *r0 = (mg_uecc_word_t) r01;\n#endif\n}\n#endif /* muladd needed */\n\n#if !asm_mult\nMG_UECC_VLI_API void mg_uecc_vli_mult(mg_uecc_word_t *result,\n                                      const mg_uecc_word_t *left,\n                                      const mg_uecc_word_t *right,\n                                      wordcount_t num_words) {\n  mg_uecc_word_t r0 = 0;\n  mg_uecc_word_t r1 = 0;\n  mg_uecc_word_t r2 = 0;\n  wordcount_t i, k;\n\n  /* Compute each digit of result in sequence, maintaining the carries. */\n  for (k = 0; k < num_words; ++k) {\n    for (i = 0; i <= k; ++i) {\n      muladd(left[i], right[k - i], &r0, &r1, &r2);\n    }\n    result[k] = r0;\n    r0 = r1;\n    r1 = r2;\n    r2 = 0;\n  }\n  for (k = num_words; k < num_words * 2 - 1; ++k) {\n    for (i = (wordcount_t) ((k + 1) - num_words); i < num_words; ++i) {\n      muladd(left[i], right[k - i], &r0, &r1, &r2);\n    }\n    result[k] = r0;\n    r0 = r1;\n    r1 = r2;\n    r2 = 0;\n  }\n  result[num_words * 2 - 1] = r0;\n}\n#endif /* !asm_mult */\n\n#if MG_UECC_SQUARE_FUNC\n\n#if !asm_square\nstatic void mul2add(mg_uecc_word_t a, mg_uecc_word_t b, mg_uecc_word_t *r0,\n                    mg_uecc_word_t *r1, mg_uecc_word_t *r2) {\n#if MG_UECC_WORD_SIZE == 8\n  uint64_t a0 = a & 0xffffffffull;\n  uint64_t a1 = a >> 32;\n  uint64_t b0 = b & 0xffffffffull;\n  uint64_t b1 = b >> 32;\n\n  uint64_t i0 = a0 * b0;\n  uint64_t i1 = a0 * b1;\n  uint64_t i2 = a1 * b0;\n  uint64_t i3 = a1 * b1;\n\n  uint64_t p0, p1;\n\n  i2 += (i0 >> 32);\n  i2 += i1;\n  if (i2 < i1) { /* overflow */\n    i3 += 0x100000000ull;\n  }\n\n  p0 = (i0 & 0xffffffffull) | (i2 << 32);\n  p1 = i3 + (i2 >> 32);\n\n  *r2 += (p1 >> 63);\n  p1 = (p1 << 1) | (p0 >> 63);\n  p0 <<= 1;\n\n  *r0 += p0;\n  *r1 += (p1 + (*r0 < p0));\n  *r2 += ((*r1 < p1) || (*r1 == p1 && *r0 < p0));\n#else\n  mg_uecc_dword_t p = (mg_uecc_dword_t) a * b;\n  mg_uecc_dword_t r01 = ((mg_uecc_dword_t) (*r1) << MG_UECC_WORD_BITS) | *r0;\n  *r2 += (p >> (MG_UECC_WORD_BITS * 2 - 1));\n  p *= 2;\n  r01 += p;\n  *r2 += (r01 < p);\n  *r1 = r01 >> MG_UECC_WORD_BITS;\n  *r0 = (mg_uecc_word_t) r01;\n#endif\n}\n\nMG_UECC_VLI_API void mg_uecc_vli_square(mg_uecc_word_t *result,\n                                        const mg_uecc_word_t *left,\n                                        wordcount_t num_words) {\n  mg_uecc_word_t r0 = 0;\n  mg_uecc_word_t r1 = 0;\n  mg_uecc_word_t r2 = 0;\n\n  wordcount_t i, k;\n\n  for (k = 0; k < num_words * 2 - 1; ++k) {\n    mg_uecc_word_t min = (k < num_words ? 0 : (k + 1) - num_words);\n    for (i = min; i <= k && i <= k - i; ++i) {\n      if (i < k - i) {\n        mul2add(left[i], left[k - i], &r0, &r1, &r2);\n      } else {\n        muladd(left[i], left[k - i], &r0, &r1, &r2);\n      }\n    }\n    result[k] = r0;\n    r0 = r1;\n    r1 = r2;\n    r2 = 0;\n  }\n\n  result[num_words * 2 - 1] = r0;\n}\n#endif /* !asm_square */\n\n#else /* MG_UECC_SQUARE_FUNC */\n\n#if MG_UECC_ENABLE_VLI_API\nMG_UECC_VLI_API void mg_uecc_vli_square(mg_uecc_word_t *result,\n                                        const mg_uecc_word_t *left,\n                                        wordcount_t num_words) {\n  mg_uecc_vli_mult(result, left, left, num_words);\n}\n#endif /* MG_UECC_ENABLE_VLI_API */\n\n#endif /* MG_UECC_SQUARE_FUNC */\n\n/* Computes result = (left + right) % mod.\n   Assumes that left < mod and right < mod, and that result does not overlap\n   mod. */\nMG_UECC_VLI_API void mg_uecc_vli_modAdd(mg_uecc_word_t *result,\n                                        const mg_uecc_word_t *left,\n                                        const mg_uecc_word_t *right,\n                                        const mg_uecc_word_t *mod,\n                                        wordcount_t num_words) {\n  mg_uecc_word_t carry = mg_uecc_vli_add(result, left, right, num_words);\n  if (carry || mg_uecc_vli_cmp_unsafe(mod, result, num_words) != 1) {\n    /* result > mod (result = mod + remainder), so subtract mod to get\n     * remainder. */\n    mg_uecc_vli_sub(result, result, mod, num_words);\n  }\n}\n\n/* Computes result = (left - right) % mod.\n   Assumes that left < mod and right < mod, and that result does not overlap\n   mod. */\nMG_UECC_VLI_API void mg_uecc_vli_modSub(mg_uecc_word_t *result,\n                                        const mg_uecc_word_t *left,\n                                        const mg_uecc_word_t *right,\n                                        const mg_uecc_word_t *mod,\n                                        wordcount_t num_words) {\n  mg_uecc_word_t l_borrow = mg_uecc_vli_sub(result, left, right, num_words);\n  if (l_borrow) {\n    /* In this case, result == -diff == (max int) - diff. Since -x % d == d - x,\n       we can get the correct result from result + mod (with overflow). */\n    mg_uecc_vli_add(result, result, mod, num_words);\n  }\n}\n\n/* Computes result = product % mod, where product is 2N words long. */\n/* Currently only designed to work for curve_p or curve_n. */\nMG_UECC_VLI_API void mg_uecc_vli_mmod(mg_uecc_word_t *result,\n                                      mg_uecc_word_t *product,\n                                      const mg_uecc_word_t *mod,\n                                      wordcount_t num_words) {\n  mg_uecc_word_t mod_multiple[2 * MG_UECC_MAX_WORDS];\n  mg_uecc_word_t tmp[2 * MG_UECC_MAX_WORDS];\n  mg_uecc_word_t *v[2] = {tmp, product};\n  mg_uecc_word_t index;\n\n  /* Shift mod so its highest set bit is at the maximum position. */\n  bitcount_t shift = (bitcount_t) ((num_words * 2 * MG_UECC_WORD_BITS) -\n                                   mg_uecc_vli_numBits(mod, num_words));\n  wordcount_t word_shift = (wordcount_t) (shift / MG_UECC_WORD_BITS);\n  wordcount_t bit_shift = (wordcount_t) (shift % MG_UECC_WORD_BITS);\n  mg_uecc_word_t carry = 0;\n  mg_uecc_vli_clear(mod_multiple, word_shift);\n  if (bit_shift > 0) {\n    for (index = 0; index < (mg_uecc_word_t) num_words; ++index) {\n      mod_multiple[(mg_uecc_word_t) word_shift + index] =\n          (mg_uecc_word_t) (mod[index] << bit_shift) | carry;\n      carry = mod[index] >> (MG_UECC_WORD_BITS - bit_shift);\n    }\n  } else {\n    mg_uecc_vli_set(mod_multiple + word_shift, mod, num_words);\n  }\n\n  for (index = 1; shift >= 0; --shift) {\n    mg_uecc_word_t borrow = 0;\n    wordcount_t i;\n    for (i = 0; i < num_words * 2; ++i) {\n      mg_uecc_word_t diff = v[index][i] - mod_multiple[i] - borrow;\n      if (diff != v[index][i]) {\n        borrow = (diff > v[index][i]);\n      }\n      v[1 - index][i] = diff;\n    }\n    index = !(index ^ borrow); /* Swap the index if there was no borrow */\n    mg_uecc_vli_rshift1(mod_multiple, num_words);\n    mod_multiple[num_words - 1] |= mod_multiple[num_words]\n                                   << (MG_UECC_WORD_BITS - 1);\n    mg_uecc_vli_rshift1(mod_multiple + num_words, num_words);\n  }\n  mg_uecc_vli_set(result, v[index], num_words);\n}\n\n/* Computes result = (left * right) % mod. */\nMG_UECC_VLI_API void mg_uecc_vli_modMult(mg_uecc_word_t *result,\n                                         const mg_uecc_word_t *left,\n                                         const mg_uecc_word_t *right,\n                                         const mg_uecc_word_t *mod,\n                                         wordcount_t num_words) {\n  mg_uecc_word_t product[2 * MG_UECC_MAX_WORDS];\n  mg_uecc_vli_mult(product, left, right, num_words);\n  mg_uecc_vli_mmod(result, product, mod, num_words);\n}\n\nMG_UECC_VLI_API void mg_uecc_vli_modMult_fast(mg_uecc_word_t *result,\n                                              const mg_uecc_word_t *left,\n                                              const mg_uecc_word_t *right,\n                                              MG_UECC_Curve curve) {\n  mg_uecc_word_t product[2 * MG_UECC_MAX_WORDS];\n  mg_uecc_vli_mult(product, left, right, curve->num_words);\n#if (MG_UECC_OPTIMIZATION_LEVEL > 0)\n  curve->mmod_fast(result, product);\n#else\n  mg_uecc_vli_mmod(result, product, curve->p, curve->num_words);\n#endif\n}\n\n#if MG_UECC_SQUARE_FUNC\n\n#if MG_UECC_ENABLE_VLI_API\n/* Computes result = left^2 % mod. */\nMG_UECC_VLI_API void mg_uecc_vli_modSquare(mg_uecc_word_t *result,\n                                           const mg_uecc_word_t *left,\n                                           const mg_uecc_word_t *mod,\n                                           wordcount_t num_words) {\n  mg_uecc_word_t product[2 * MG_UECC_MAX_WORDS];\n  mg_uecc_vli_square(product, left, num_words);\n  mg_uecc_vli_mmod(result, product, mod, num_words);\n}\n#endif /* MG_UECC_ENABLE_VLI_API */\n\nMG_UECC_VLI_API void mg_uecc_vli_modSquare_fast(mg_uecc_word_t *result,\n                                                const mg_uecc_word_t *left,\n                                                MG_UECC_Curve curve) {\n  mg_uecc_word_t product[2 * MG_UECC_MAX_WORDS];\n  mg_uecc_vli_square(product, left, curve->num_words);\n#if (MG_UECC_OPTIMIZATION_LEVEL > 0)\n  curve->mmod_fast(result, product);\n#else\n  mg_uecc_vli_mmod(result, product, curve->p, curve->num_words);\n#endif\n}\n\n#else /* MG_UECC_SQUARE_FUNC */\n\n#if MG_UECC_ENABLE_VLI_API\nMG_UECC_VLI_API void mg_uecc_vli_modSquare(mg_uecc_word_t *result,\n                                           const mg_uecc_word_t *left,\n                                           const mg_uecc_word_t *mod,\n                                           wordcount_t num_words) {\n  mg_uecc_vli_modMult(result, left, left, mod, num_words);\n}\n#endif /* MG_UECC_ENABLE_VLI_API */\n\nMG_UECC_VLI_API void mg_uecc_vli_modSquare_fast(mg_uecc_word_t *result,\n                                                const mg_uecc_word_t *left,\n                                                MG_UECC_Curve curve) {\n  mg_uecc_vli_modMult_fast(result, left, left, curve);\n}\n\n#endif /* MG_UECC_SQUARE_FUNC */\n\n#define EVEN(vli) (!(vli[0] & 1))\nstatic void vli_modInv_update(mg_uecc_word_t *uv, const mg_uecc_word_t *mod,\n                              wordcount_t num_words) {\n  mg_uecc_word_t carry = 0;\n  if (!EVEN(uv)) {\n    carry = mg_uecc_vli_add(uv, uv, mod, num_words);\n  }\n  mg_uecc_vli_rshift1(uv, num_words);\n  if (carry) {\n    uv[num_words - 1] |= HIGH_BIT_SET;\n  }\n}\n\n/* Computes result = (1 / input) % mod. All VLIs are the same size.\n   See \"From Euclid's GCD to Montgomery Multiplication to the Great Divide\" */\nMG_UECC_VLI_API void mg_uecc_vli_modInv(mg_uecc_word_t *result,\n                                        const mg_uecc_word_t *input,\n                                        const mg_uecc_word_t *mod,\n                                        wordcount_t num_words) {\n  mg_uecc_word_t a[MG_UECC_MAX_WORDS], b[MG_UECC_MAX_WORDS],\n      u[MG_UECC_MAX_WORDS], v[MG_UECC_MAX_WORDS];\n  cmpresult_t cmpResult;\n\n  if (mg_uecc_vli_isZero(input, num_words)) {\n    mg_uecc_vli_clear(result, num_words);\n    return;\n  }\n\n  mg_uecc_vli_set(a, input, num_words);\n  mg_uecc_vli_set(b, mod, num_words);\n  mg_uecc_vli_clear(u, num_words);\n  u[0] = 1;\n  mg_uecc_vli_clear(v, num_words);\n  while ((cmpResult = mg_uecc_vli_cmp_unsafe(a, b, num_words)) != 0) {\n    if (EVEN(a)) {\n      mg_uecc_vli_rshift1(a, num_words);\n      vli_modInv_update(u, mod, num_words);\n    } else if (EVEN(b)) {\n      mg_uecc_vli_rshift1(b, num_words);\n      vli_modInv_update(v, mod, num_words);\n    } else if (cmpResult > 0) {\n      mg_uecc_vli_sub(a, a, b, num_words);\n      mg_uecc_vli_rshift1(a, num_words);\n      if (mg_uecc_vli_cmp_unsafe(u, v, num_words) < 0) {\n        mg_uecc_vli_add(u, u, mod, num_words);\n      }\n      mg_uecc_vli_sub(u, u, v, num_words);\n      vli_modInv_update(u, mod, num_words);\n    } else {\n      mg_uecc_vli_sub(b, b, a, num_words);\n      mg_uecc_vli_rshift1(b, num_words);\n      if (mg_uecc_vli_cmp_unsafe(v, u, num_words) < 0) {\n        mg_uecc_vli_add(v, v, mod, num_words);\n      }\n      mg_uecc_vli_sub(v, v, u, num_words);\n      vli_modInv_update(v, mod, num_words);\n    }\n  }\n  mg_uecc_vli_set(result, u, num_words);\n}\n\n/* ------ Point operations ------ */\n\n/* Copyright 2015, Kenneth MacKay. Licensed under the BSD 2-clause license. */\n\n#ifndef _UECC_CURVE_SPECIFIC_H_\n#define _UECC_CURVE_SPECIFIC_H_\n\n#define num_bytes_secp160r1 20\n#define num_bytes_secp192r1 24\n#define num_bytes_secp224r1 28\n#define num_bytes_secp256r1 32\n#define num_bytes_secp256k1 32\n\n#if (MG_UECC_WORD_SIZE == 1)\n\n#define num_words_secp160r1 20\n#define num_words_secp192r1 24\n#define num_words_secp224r1 28\n#define num_words_secp256r1 32\n#define num_words_secp256k1 32\n\n#define BYTES_TO_WORDS_8(a, b, c, d, e, f, g, h) \\\n  0x##a, 0x##b, 0x##c, 0x##d, 0x##e, 0x##f, 0x##g, 0x##h\n#define BYTES_TO_WORDS_4(a, b, c, d) 0x##a, 0x##b, 0x##c, 0x##d\n\n#elif (MG_UECC_WORD_SIZE == 4)\n\n#define num_words_secp160r1 5\n#define num_words_secp192r1 6\n#define num_words_secp224r1 7\n#define num_words_secp256r1 8\n#define num_words_secp256k1 8\n\n#define BYTES_TO_WORDS_8(a, b, c, d, e, f, g, h) 0x##d##c##b##a, 0x##h##g##f##e\n#define BYTES_TO_WORDS_4(a, b, c, d) 0x##d##c##b##a\n\n#elif (MG_UECC_WORD_SIZE == 8)\n\n#define num_words_secp160r1 3\n#define num_words_secp192r1 3\n#define num_words_secp224r1 4\n#define num_words_secp256r1 4\n#define num_words_secp256k1 4\n\n#define BYTES_TO_WORDS_8(a, b, c, d, e, f, g, h) 0x##h##g##f##e##d##c##b##a##U\n#define BYTES_TO_WORDS_4(a, b, c, d) 0x##d##c##b##a##U\n\n#endif /* MG_UECC_WORD_SIZE */\n\n#if MG_UECC_SUPPORTS_secp160r1 || MG_UECC_SUPPORTS_secp192r1 || \\\n    MG_UECC_SUPPORTS_secp224r1 || MG_UECC_SUPPORTS_secp256r1\nstatic void double_jacobian_default(mg_uecc_word_t *X1, mg_uecc_word_t *Y1,\n                                    mg_uecc_word_t *Z1, MG_UECC_Curve curve) {\n  /* t1 = X, t2 = Y, t3 = Z */\n  mg_uecc_word_t t4[MG_UECC_MAX_WORDS];\n  mg_uecc_word_t t5[MG_UECC_MAX_WORDS];\n  wordcount_t num_words = curve->num_words;\n\n  if (mg_uecc_vli_isZero(Z1, num_words)) {\n    return;\n  }\n\n  mg_uecc_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */\n  mg_uecc_vli_modMult_fast(t5, X1, t4, curve); /* t5 = x1*y1^2 = A */\n  mg_uecc_vli_modSquare_fast(t4, t4, curve);   /* t4 = y1^4 */\n  mg_uecc_vli_modMult_fast(Y1, Y1, Z1, curve); /* t2 = y1*z1 = z3 */\n  mg_uecc_vli_modSquare_fast(Z1, Z1, curve);   /* t3 = z1^2 */\n\n  mg_uecc_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */\n  mg_uecc_vli_modAdd(Z1, Z1, Z1, curve->p, num_words); /* t3 = 2*z1^2 */\n  mg_uecc_vli_modSub(Z1, X1, Z1, curve->p, num_words); /* t3 = x1 - z1^2 */\n  mg_uecc_vli_modMult_fast(X1, X1, Z1, curve);         /* t1 = x1^2 - z1^4 */\n\n  mg_uecc_vli_modAdd(Z1, X1, X1, curve->p,\n                     num_words); /* t3 = 2*(x1^2 - z1^4) */\n  mg_uecc_vli_modAdd(X1, X1, Z1, curve->p,\n                     num_words); /* t1 = 3*(x1^2 - z1^4) */\n  if (mg_uecc_vli_testBit(X1, 0)) {\n    mg_uecc_word_t l_carry = mg_uecc_vli_add(X1, X1, curve->p, num_words);\n    mg_uecc_vli_rshift1(X1, num_words);\n    X1[num_words - 1] |= l_carry << (MG_UECC_WORD_BITS - 1);\n  } else {\n    mg_uecc_vli_rshift1(X1, num_words);\n  }\n  /* t1 = 3/2*(x1^2 - z1^4) = B */\n\n  mg_uecc_vli_modSquare_fast(Z1, X1, curve);           /* t3 = B^2 */\n  mg_uecc_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - A */\n  mg_uecc_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - 2A = x3 */\n  mg_uecc_vli_modSub(t5, t5, Z1, curve->p, num_words); /* t5 = A - x3 */\n  mg_uecc_vli_modMult_fast(X1, X1, t5, curve);         /* t1 = B * (A - x3) */\n  mg_uecc_vli_modSub(t4, X1, t4, curve->p,\n                     num_words); /* t4 = B * (A - x3) - y1^4 = y3 */\n\n  mg_uecc_vli_set(X1, Z1, num_words);\n  mg_uecc_vli_set(Z1, Y1, num_words);\n  mg_uecc_vli_set(Y1, t4, num_words);\n}\n\n/* Computes result = x^3 + ax + b. result must not overlap x. */\nstatic void x_side_default(mg_uecc_word_t *result, const mg_uecc_word_t *x,\n                           MG_UECC_Curve curve) {\n  mg_uecc_word_t _3[MG_UECC_MAX_WORDS] = {3}; /* -a = 3 */\n  wordcount_t num_words = curve->num_words;\n\n  mg_uecc_vli_modSquare_fast(result, x, curve);                /* r = x^2 */\n  mg_uecc_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */\n  mg_uecc_vli_modMult_fast(result, result, x, curve); /* r = x^3 - 3x */\n  mg_uecc_vli_modAdd(result, result, curve->b, curve->p,\n                     num_words); /* r = x^3 - 3x + b */\n}\n#endif /* MG_UECC_SUPPORTS_secp... */\n\n#if MG_UECC_SUPPORT_COMPRESSED_POINT\n#if MG_UECC_SUPPORTS_secp160r1 || MG_UECC_SUPPORTS_secp192r1 || \\\n    MG_UECC_SUPPORTS_secp256r1 || MG_UECC_SUPPORTS_secp256k1\n/* Compute a = sqrt(a) (mod curve_p). */\nstatic void mod_sqrt_default(mg_uecc_word_t *a, MG_UECC_Curve curve) {\n  bitcount_t i;\n  mg_uecc_word_t p1[MG_UECC_MAX_WORDS] = {1};\n  mg_uecc_word_t l_result[MG_UECC_MAX_WORDS] = {1};\n  wordcount_t num_words = curve->num_words;\n\n  /* When curve->p == 3 (mod 4), we can compute\n     sqrt(a) = a^((curve->p + 1) / 4) (mod curve->p). */\n  mg_uecc_vli_add(p1, curve->p, p1, num_words); /* p1 = curve_p + 1 */\n  for (i = mg_uecc_vli_numBits(p1, num_words) - 1; i > 1; --i) {\n    mg_uecc_vli_modSquare_fast(l_result, l_result, curve);\n    if (mg_uecc_vli_testBit(p1, i)) {\n      mg_uecc_vli_modMult_fast(l_result, l_result, a, curve);\n    }\n  }\n  mg_uecc_vli_set(a, l_result, num_words);\n}\n#endif /* MG_UECC_SUPPORTS_secp... */\n#endif /* MG_UECC_SUPPORT_COMPRESSED_POINT */\n\n#if MG_UECC_SUPPORTS_secp160r1\n\n#if (MG_UECC_OPTIMIZATION_LEVEL > 0)\nstatic void vli_mmod_fast_secp160r1(mg_uecc_word_t *result,\n                                    mg_uecc_word_t *product);\n#endif\n\nstatic const struct MG_UECC_Curve_t curve_secp160r1 = {\n    num_words_secp160r1,\n    num_bytes_secp160r1,\n    161, /* num_n_bits */\n    {BYTES_TO_WORDS_8(FF, FF, FF, 7F, FF, FF, FF, FF),\n     BYTES_TO_WORDS_8(FF, FF, FF, FF, FF, FF, FF, FF),\n     BYTES_TO_WORDS_4(FF, FF, FF, FF)},\n    {BYTES_TO_WORDS_8(57, 22, 75, CA, D3, AE, 27, F9),\n     BYTES_TO_WORDS_8(C8, F4, 01, 00, 00, 00, 00, 00),\n     BYTES_TO_WORDS_8(00, 00, 00, 00, 01, 00, 00, 00)},\n    {BYTES_TO_WORDS_8(82, FC, CB, 13, B9, 8B, C3, 68),\n     BYTES_TO_WORDS_8(89, 69, 64, 46, 28, 73, F5, 8E),\n     BYTES_TO_WORDS_4(68, B5, 96, 4A),\n\n     BYTES_TO_WORDS_8(32, FB, C5, 7A, 37, 51, 23, 04),\n     BYTES_TO_WORDS_8(12, C9, DC, 59, 7D, 94, 68, 31),\n     BYTES_TO_WORDS_4(55, 28, A6, 23)},\n    {BYTES_TO_WORDS_8(45, FA, 65, C5, AD, D4, D4, 81),\n     BYTES_TO_WORDS_8(9F, F8, AC, 65, 8B, 7A, BD, 54),\n     BYTES_TO_WORDS_4(FC, BE, 97, 1C)},\n    &double_jacobian_default,\n#if MG_UECC_SUPPORT_COMPRESSED_POINT\n    &mod_sqrt_default,\n#endif\n    &x_side_default,\n#if (MG_UECC_OPTIMIZATION_LEVEL > 0)\n    &vli_mmod_fast_secp160r1\n#endif\n};\n\nMG_UECC_Curve mg_uecc_secp160r1(void) {\n  return &curve_secp160r1;\n}\n\n#if (MG_UECC_OPTIMIZATION_LEVEL > 0 && !asm_mmod_fast_secp160r1)\n/* Computes result = product % curve_p\n    see http://www.isys.uni-klu.ac.at/PDF/2001-0126-MT.pdf page 354\n\n    Note that this only works if log2(omega) < log2(p) / 2 */\nstatic void omega_mult_secp160r1(mg_uecc_word_t *result,\n                                 const mg_uecc_word_t *right);\n#if MG_UECC_WORD_SIZE == 8\nstatic void vli_mmod_fast_secp160r1(mg_uecc_word_t *result,\n                                    mg_uecc_word_t *product) {\n  mg_uecc_word_t tmp[2 * num_words_secp160r1];\n  mg_uecc_word_t copy;\n\n  mg_uecc_vli_clear(tmp, num_words_secp160r1);\n  mg_uecc_vli_clear(tmp + num_words_secp160r1, num_words_secp160r1);\n\n  omega_mult_secp160r1(tmp,\n                       product + num_words_secp160r1 - 1); /* (Rq, q) = q * c */\n\n  product[num_words_secp160r1 - 1] &= 0xffffffff;\n  copy = tmp[num_words_secp160r1 - 1];\n  tmp[num_words_secp160r1 - 1] &= 0xffffffff;\n  mg_uecc_vli_add(result, product, tmp,\n                  num_words_secp160r1); /* (C, r) = r + q */\n  mg_uecc_vli_clear(product, num_words_secp160r1);\n  tmp[num_words_secp160r1 - 1] = copy;\n  omega_mult_secp160r1(product, tmp + num_words_secp160r1 - 1); /* Rq*c */\n  mg_uecc_vli_add(result, result, product,\n                  num_words_secp160r1); /* (C1, r) = r + Rq*c */\n\n  while (mg_uecc_vli_cmp_unsafe(result, curve_secp160r1.p,\n                                num_words_secp160r1) > 0) {\n    mg_uecc_vli_sub(result, result, curve_secp160r1.p, num_words_secp160r1);\n  }\n}\n\nstatic void omega_mult_secp160r1(uint64_t *result, const uint64_t *right) {\n  uint32_t carry;\n  unsigned i;\n\n  /* Multiply by (2^31 + 1). */\n  carry = 0;\n  for (i = 0; i < num_words_secp160r1; ++i) {\n    uint64_t tmp = (right[i] >> 32) | (right[i + 1] << 32);\n    result[i] = (tmp << 31) + tmp + carry;\n    carry = (tmp >> 33) + (result[i] < tmp || (carry && result[i] == tmp));\n  }\n  result[i] = carry;\n}\n#else\nstatic void vli_mmod_fast_secp160r1(mg_uecc_word_t *result,\n                                    mg_uecc_word_t *product) {\n  mg_uecc_word_t tmp[2 * num_words_secp160r1];\n  mg_uecc_word_t carry;\n\n  mg_uecc_vli_clear(tmp, num_words_secp160r1);\n  mg_uecc_vli_clear(tmp + num_words_secp160r1, num_words_secp160r1);\n\n  omega_mult_secp160r1(tmp,\n                       product + num_words_secp160r1); /* (Rq, q) = q * c */\n\n  carry = mg_uecc_vli_add(result, product, tmp,\n                          num_words_secp160r1); /* (C, r) = r + q */\n  mg_uecc_vli_clear(product, num_words_secp160r1);\n  omega_mult_secp160r1(product, tmp + num_words_secp160r1); /* Rq*c */\n  carry += mg_uecc_vli_add(result, result, product,\n                           num_words_secp160r1); /* (C1, r) = r + Rq*c */\n\n  while (carry > 0) {\n    --carry;\n    mg_uecc_vli_sub(result, result, curve_secp160r1.p, num_words_secp160r1);\n  }\n  if (mg_uecc_vli_cmp_unsafe(result, curve_secp160r1.p, num_words_secp160r1) >\n      0) {\n    mg_uecc_vli_sub(result, result, curve_secp160r1.p, num_words_secp160r1);\n  }\n}\n#endif\n\n#if MG_UECC_WORD_SIZE == 1\nstatic void omega_mult_secp160r1(uint8_t *result, const uint8_t *right) {\n  uint8_t carry;\n  uint8_t i;\n\n  /* Multiply by (2^31 + 1). */\n  mg_uecc_vli_set(result + 4, right, num_words_secp160r1); /* 2^32 */\n  mg_uecc_vli_rshift1(result + 4, num_words_secp160r1);    /* 2^31 */\n  result[3] = right[0] << 7; /* get last bit from shift */\n\n  carry = mg_uecc_vli_add(result, result, right,\n                          num_words_secp160r1); /* 2^31 + 1 */\n  for (i = num_words_secp160r1; carry; ++i) {\n    uint16_t sum = (uint16_t) result[i] + carry;\n    result[i] = (uint8_t) sum;\n    carry = sum >> 8;\n  }\n}\n#elif MG_UECC_WORD_SIZE == 4\nstatic void omega_mult_secp160r1(uint32_t *result, const uint32_t *right) {\n  uint32_t carry;\n  unsigned i;\n\n  /* Multiply by (2^31 + 1). */\n  mg_uecc_vli_set(result + 1, right, num_words_secp160r1); /* 2^32 */\n  mg_uecc_vli_rshift1(result + 1, num_words_secp160r1);    /* 2^31 */\n  result[0] = right[0] << 31; /* get last bit from shift */\n\n  carry = mg_uecc_vli_add(result, result, right,\n                          num_words_secp160r1); /* 2^31 + 1 */\n  for (i = num_words_secp160r1; carry; ++i) {\n    uint64_t sum = (uint64_t) result[i] + carry;\n    result[i] = (uint32_t) sum;\n    carry = sum >> 32;\n  }\n}\n#endif /* MG_UECC_WORD_SIZE */\n#endif /* (MG_UECC_OPTIMIZATION_LEVEL > 0 && !asm_mmod_fast_secp160r1) */\n\n#endif /* MG_UECC_SUPPORTS_secp160r1 */\n\n#if MG_UECC_SUPPORTS_secp192r1\n\n#if (MG_UECC_OPTIMIZATION_LEVEL > 0)\nstatic void vli_mmod_fast_secp192r1(mg_uecc_word_t *result,\n                                    mg_uecc_word_t *product);\n#endif\n\nstatic const struct MG_UECC_Curve_t curve_secp192r1 = {\n    num_words_secp192r1,\n    num_bytes_secp192r1,\n    192, /* num_n_bits */\n    {BYTES_TO_WORDS_8(FF, FF, FF, FF, FF, FF, FF, FF),\n     BYTES_TO_WORDS_8(FE, FF, FF, FF, FF, FF, FF, FF),\n     BYTES_TO_WORDS_8(FF, FF, FF, FF, FF, FF, FF, FF)},\n    {BYTES_TO_WORDS_8(31, 28, D2, B4, B1, C9, 6B, 14),\n     BYTES_TO_WORDS_8(36, F8, DE, 99, FF, FF, FF, FF),\n     BYTES_TO_WORDS_8(FF, FF, FF, FF, FF, FF, FF, FF)},\n    {BYTES_TO_WORDS_8(12, 10, FF, 82, FD, 0A, FF, F4),\n     BYTES_TO_WORDS_8(00, 88, A1, 43, EB, 20, BF, 7C),\n     BYTES_TO_WORDS_8(F6, 90, 30, B0, 0E, A8, 8D, 18),\n\n     BYTES_TO_WORDS_8(11, 48, 79, 1E, A1, 77, F9, 73),\n     BYTES_TO_WORDS_8(D5, CD, 24, 6B, ED, 11, 10, 63),\n     BYTES_TO_WORDS_8(78, DA, C8, FF, 95, 2B, 19, 07)},\n    {BYTES_TO_WORDS_8(B1, B9, 46, C1, EC, DE, B8, FE),\n     BYTES_TO_WORDS_8(49, 30, 24, 72, AB, E9, A7, 0F),\n     BYTES_TO_WORDS_8(E7, 80, 9C, E5, 19, 05, 21, 64)},\n    &double_jacobian_default,\n#if MG_UECC_SUPPORT_COMPRESSED_POINT\n    &mod_sqrt_default,\n#endif\n    &x_side_default,\n#if (MG_UECC_OPTIMIZATION_LEVEL > 0)\n    &vli_mmod_fast_secp192r1\n#endif\n};\n\nMG_UECC_Curve mg_uecc_secp192r1(void) {\n  return &curve_secp192r1;\n}\n\n#if (MG_UECC_OPTIMIZATION_LEVEL > 0)\n/* Computes result = product % curve_p.\n   See algorithm 5 and 6 from http://www.isys.uni-klu.ac.at/PDF/2001-0126-MT.pdf\n */\n#if MG_UECC_WORD_SIZE == 1\nstatic void vli_mmod_fast_secp192r1(uint8_t *result, uint8_t *product) {\n  uint8_t tmp[num_words_secp192r1];\n  uint8_t carry;\n\n  mg_uecc_vli_set(result, product, num_words_secp192r1);\n\n  mg_uecc_vli_set(tmp, &product[24], num_words_secp192r1);\n  carry = mg_uecc_vli_add(result, result, tmp, num_words_secp192r1);\n\n  tmp[0] = tmp[1] = tmp[2] = tmp[3] = tmp[4] = tmp[5] = tmp[6] = tmp[7] = 0;\n  tmp[8] = product[24];\n  tmp[9] = product[25];\n  tmp[10] = product[26];\n  tmp[11] = product[27];\n  tmp[12] = product[28];\n  tmp[13] = product[29];\n  tmp[14] = product[30];\n  tmp[15] = product[31];\n  tmp[16] = product[32];\n  tmp[17] = product[33];\n  tmp[18] = product[34];\n  tmp[19] = product[35];\n  tmp[20] = product[36];\n  tmp[21] = product[37];\n  tmp[22] = product[38];\n  tmp[23] = product[39];\n  carry += mg_uecc_vli_add(result, result, tmp, num_words_secp192r1);\n\n  tmp[0] = tmp[8] = product[40];\n  tmp[1] = tmp[9] = product[41];\n  tmp[2] = tmp[10] = product[42];\n  tmp[3] = tmp[11] = product[43];\n  tmp[4] = tmp[12] = product[44];\n  tmp[5] = tmp[13] = product[45];\n  tmp[6] = tmp[14] = product[46];\n  tmp[7] = tmp[15] = product[47];\n  tmp[16] = tmp[17] = tmp[18] = tmp[19] = tmp[20] = tmp[21] = tmp[22] =\n      tmp[23] = 0;\n  carry += mg_uecc_vli_add(result, result, tmp, num_words_secp192r1);\n\n  while (carry || mg_uecc_vli_cmp_unsafe(curve_secp192r1.p, result,\n                                         num_words_secp192r1) != 1) {\n    carry -=\n        mg_uecc_vli_sub(result, result, curve_secp192r1.p, num_words_secp192r1);\n  }\n}\n#elif MG_UECC_WORD_SIZE == 4\nstatic void vli_mmod_fast_secp192r1(uint32_t *result, uint32_t *product) {\n  uint32_t tmp[num_words_secp192r1];\n  int carry;\n\n  mg_uecc_vli_set(result, product, num_words_secp192r1);\n\n  mg_uecc_vli_set(tmp, &product[6], num_words_secp192r1);\n  carry = mg_uecc_vli_add(result, result, tmp, num_words_secp192r1);\n\n  tmp[0] = tmp[1] = 0;\n  tmp[2] = product[6];\n  tmp[3] = product[7];\n  tmp[4] = product[8];\n  tmp[5] = product[9];\n  carry += mg_uecc_vli_add(result, result, tmp, num_words_secp192r1);\n\n  tmp[0] = tmp[2] = product[10];\n  tmp[1] = tmp[3] = product[11];\n  tmp[4] = tmp[5] = 0;\n  carry += mg_uecc_vli_add(result, result, tmp, num_words_secp192r1);\n\n  while (carry || mg_uecc_vli_cmp_unsafe(curve_secp192r1.p, result,\n                                         num_words_secp192r1) != 1) {\n    carry -=\n        mg_uecc_vli_sub(result, result, curve_secp192r1.p, num_words_secp192r1);\n  }\n}\n#else\nstatic void vli_mmod_fast_secp192r1(uint64_t *result, uint64_t *product) {\n  uint64_t tmp[num_words_secp192r1];\n  int carry;\n\n  mg_uecc_vli_set(result, product, num_words_secp192r1);\n\n  mg_uecc_vli_set(tmp, &product[3], num_words_secp192r1);\n  carry = (int) mg_uecc_vli_add(result, result, tmp, num_words_secp192r1);\n\n  tmp[0] = 0;\n  tmp[1] = product[3];\n  tmp[2] = product[4];\n  carry += mg_uecc_vli_add(result, result, tmp, num_words_secp192r1);\n\n  tmp[0] = tmp[1] = product[5];\n  tmp[2] = 0;\n  carry += mg_uecc_vli_add(result, result, tmp, num_words_secp192r1);\n\n  while (carry || mg_uecc_vli_cmp_unsafe(curve_secp192r1.p, result,\n                                         num_words_secp192r1) != 1) {\n    carry -=\n        mg_uecc_vli_sub(result, result, curve_secp192r1.p, num_words_secp192r1);\n  }\n}\n#endif /* MG_UECC_WORD_SIZE */\n#endif /* (MG_UECC_OPTIMIZATION_LEVEL > 0) */\n\n#endif /* MG_UECC_SUPPORTS_secp192r1 */\n\n#if MG_UECC_SUPPORTS_secp224r1\n\n#if MG_UECC_SUPPORT_COMPRESSED_POINT\nstatic void mod_sqrt_secp224r1(mg_uecc_word_t *a, MG_UECC_Curve curve);\n#endif\n#if (MG_UECC_OPTIMIZATION_LEVEL > 0)\nstatic void vli_mmod_fast_secp224r1(mg_uecc_word_t *result,\n                                    mg_uecc_word_t *product);\n#endif\n\nstatic const struct MG_UECC_Curve_t curve_secp224r1 = {\n    num_words_secp224r1,\n    num_bytes_secp224r1,\n    224, /* num_n_bits */\n    {BYTES_TO_WORDS_8(01, 00, 00, 00, 00, 00, 00, 00),\n     BYTES_TO_WORDS_8(00, 00, 00, 00, FF, FF, FF, FF),\n     BYTES_TO_WORDS_8(FF, FF, FF, FF, FF, FF, FF, FF),\n     BYTES_TO_WORDS_4(FF, FF, FF, FF)},\n    {BYTES_TO_WORDS_8(3D, 2A, 5C, 5C, 45, 29, DD, 13),\n     BYTES_TO_WORDS_8(3E, F0, B8, E0, A2, 16, FF, FF),\n     BYTES_TO_WORDS_8(FF, FF, FF, FF, FF, FF, FF, FF),\n     BYTES_TO_WORDS_4(FF, FF, FF, FF)},\n    {BYTES_TO_WORDS_8(21, 1D, 5C, 11, D6, 80, 32, 34),\n     BYTES_TO_WORDS_8(22, 11, C2, 56, D3, C1, 03, 4A),\n     BYTES_TO_WORDS_8(B9, 90, 13, 32, 7F, BF, B4, 6B),\n     BYTES_TO_WORDS_4(BD, 0C, 0E, B7),\n\n     BYTES_TO_WORDS_8(34, 7E, 00, 85, 99, 81, D5, 44),\n     BYTES_TO_WORDS_8(64, 47, 07, 5A, A0, 75, 43, CD),\n     BYTES_TO_WORDS_8(E6, DF, 22, 4C, FB, 23, F7, B5),\n     BYTES_TO_WORDS_4(88, 63, 37, BD)},\n    {BYTES_TO_WORDS_8(B4, FF, 55, 23, 43, 39, 0B, 27),\n     BYTES_TO_WORDS_8(BA, D8, BF, D7, B7, B0, 44, 50),\n     BYTES_TO_WORDS_8(56, 32, 41, F5, AB, B3, 04, 0C),\n     BYTES_TO_WORDS_4(85, 0A, 05, B4)},\n    &double_jacobian_default,\n#if MG_UECC_SUPPORT_COMPRESSED_POINT\n    &mod_sqrt_secp224r1,\n#endif\n    &x_side_default,\n#if (MG_UECC_OPTIMIZATION_LEVEL > 0)\n    &vli_mmod_fast_secp224r1\n#endif\n};\n\nMG_UECC_Curve mg_uecc_secp224r1(void) {\n  return &curve_secp224r1;\n}\n\n#if MG_UECC_SUPPORT_COMPRESSED_POINT\n/* Routine 3.2.4 RS;  from http://www.nsa.gov/ia/_files/nist-routines.pdf */\nstatic void mod_sqrt_secp224r1_rs(mg_uecc_word_t *d1, mg_uecc_word_t *e1,\n                                  mg_uecc_word_t *f1, const mg_uecc_word_t *d0,\n                                  const mg_uecc_word_t *e0,\n                                  const mg_uecc_word_t *f0) {\n  mg_uecc_word_t t[num_words_secp224r1];\n\n  mg_uecc_vli_modSquare_fast(t, d0, &curve_secp224r1);    /* t <-- d0 ^ 2 */\n  mg_uecc_vli_modMult_fast(e1, d0, e0, &curve_secp224r1); /* e1 <-- d0 * e0 */\n  mg_uecc_vli_modAdd(d1, t, f0, curve_secp224r1.p,\n                     num_words_secp224r1); /* d1 <-- t  + f0 */\n  mg_uecc_vli_modAdd(e1, e1, e1, curve_secp224r1.p,\n                     num_words_secp224r1);               /* e1 <-- e1 + e1 */\n  mg_uecc_vli_modMult_fast(f1, t, f0, &curve_secp224r1); /* f1 <-- t  * f0 */\n  mg_uecc_vli_modAdd(f1, f1, f1, curve_secp224r1.p,\n                     num_words_secp224r1); /* f1 <-- f1 + f1 */\n  mg_uecc_vli_modAdd(f1, f1, f1, curve_secp224r1.p,\n                     num_words_secp224r1); /* f1 <-- f1 + f1 */\n}\n\n/* Routine 3.2.5 RSS;  from http://www.nsa.gov/ia/_files/nist-routines.pdf */\nstatic void mod_sqrt_secp224r1_rss(mg_uecc_word_t *d1, mg_uecc_word_t *e1,\n                                   mg_uecc_word_t *f1, const mg_uecc_word_t *d0,\n                                   const mg_uecc_word_t *e0,\n                                   const mg_uecc_word_t *f0,\n                                   const bitcount_t j) {\n  bitcount_t i;\n\n  mg_uecc_vli_set(d1, d0, num_words_secp224r1); /* d1 <-- d0 */\n  mg_uecc_vli_set(e1, e0, num_words_secp224r1); /* e1 <-- e0 */\n  mg_uecc_vli_set(f1, f0, num_words_secp224r1); /* f1 <-- f0 */\n  for (i = 1; i <= j; i++) {\n    mod_sqrt_secp224r1_rs(d1, e1, f1, d1, e1, f1); /* RS (d1,e1,f1,d1,e1,f1) */\n  }\n}\n\n/* Routine 3.2.6 RM;  from http://www.nsa.gov/ia/_files/nist-routines.pdf */\nstatic void mod_sqrt_secp224r1_rm(mg_uecc_word_t *d2, mg_uecc_word_t *e2,\n                                  mg_uecc_word_t *f2, const mg_uecc_word_t *c,\n                                  const mg_uecc_word_t *d0,\n                                  const mg_uecc_word_t *e0,\n                                  const mg_uecc_word_t *d1,\n                                  const mg_uecc_word_t *e1) {\n  mg_uecc_word_t t1[num_words_secp224r1];\n  mg_uecc_word_t t2[num_words_secp224r1];\n\n  mg_uecc_vli_modMult_fast(t1, e0, e1, &curve_secp224r1); /* t1 <-- e0 * e1 */\n  mg_uecc_vli_modMult_fast(t1, t1, c, &curve_secp224r1);  /* t1 <-- t1 * c */\n  /* t1 <-- p  - t1 */\n  mg_uecc_vli_modSub(t1, curve_secp224r1.p, t1, curve_secp224r1.p,\n                     num_words_secp224r1);\n  mg_uecc_vli_modMult_fast(t2, d0, d1, &curve_secp224r1); /* t2 <-- d0 * d1 */\n  mg_uecc_vli_modAdd(t2, t2, t1, curve_secp224r1.p,\n                     num_words_secp224r1);                /* t2 <-- t2 + t1 */\n  mg_uecc_vli_modMult_fast(t1, d0, e1, &curve_secp224r1); /* t1 <-- d0 * e1 */\n  mg_uecc_vli_modMult_fast(e2, d1, e0, &curve_secp224r1); /* e2 <-- d1 * e0 */\n  mg_uecc_vli_modAdd(e2, e2, t1, curve_secp224r1.p,\n                     num_words_secp224r1);               /* e2 <-- e2 + t1 */\n  mg_uecc_vli_modSquare_fast(f2, e2, &curve_secp224r1);  /* f2 <-- e2^2 */\n  mg_uecc_vli_modMult_fast(f2, f2, c, &curve_secp224r1); /* f2 <-- f2 * c */\n  /* f2 <-- p  - f2 */\n  mg_uecc_vli_modSub(f2, curve_secp224r1.p, f2, curve_secp224r1.p,\n                     num_words_secp224r1);\n  mg_uecc_vli_set(d2, t2, num_words_secp224r1); /* d2 <-- t2 */\n}\n\n/* Routine 3.2.7 RP;  from http://www.nsa.gov/ia/_files/nist-routines.pdf */\nstatic void mod_sqrt_secp224r1_rp(mg_uecc_word_t *d1, mg_uecc_word_t *e1,\n                                  mg_uecc_word_t *f1, const mg_uecc_word_t *c,\n                                  const mg_uecc_word_t *r) {\n  wordcount_t i;\n  wordcount_t pow2i = 1;\n  mg_uecc_word_t d0[num_words_secp224r1];\n  mg_uecc_word_t e0[num_words_secp224r1] = {1}; /* e0 <-- 1 */\n  mg_uecc_word_t f0[num_words_secp224r1];\n\n  mg_uecc_vli_set(d0, r, num_words_secp224r1); /* d0 <-- r */\n  /* f0 <-- p  - c */\n  mg_uecc_vli_modSub(f0, curve_secp224r1.p, c, curve_secp224r1.p,\n                     num_words_secp224r1);\n  for (i = 0; i <= 6; i++) {\n    mod_sqrt_secp224r1_rss(d1, e1, f1, d0, e0, f0,\n                           pow2i); /* RSS (d1,e1,f1,d0,e0,f0,2^i) */\n    mod_sqrt_secp224r1_rm(d1, e1, f1, c, d1, e1, d0,\n                          e0); /* RM (d1,e1,f1,c,d1,e1,d0,e0) */\n    mg_uecc_vli_set(d0, d1, num_words_secp224r1); /* d0 <-- d1 */\n    mg_uecc_vli_set(e0, e1, num_words_secp224r1); /* e0 <-- e1 */\n    mg_uecc_vli_set(f0, f1, num_words_secp224r1); /* f0 <-- f1 */\n    pow2i *= 2;\n  }\n}\n\n/* Compute a = sqrt(a) (mod curve_p). */\n/* Routine 3.2.8 mp_mod_sqrt_224; from\n * http://www.nsa.gov/ia/_files/nist-routines.pdf */\nstatic void mod_sqrt_secp224r1(mg_uecc_word_t *a, MG_UECC_Curve curve) {\n  (void) curve;\n  bitcount_t i;\n  mg_uecc_word_t e1[num_words_secp224r1];\n  mg_uecc_word_t f1[num_words_secp224r1];\n  mg_uecc_word_t d0[num_words_secp224r1];\n  mg_uecc_word_t e0[num_words_secp224r1];\n  mg_uecc_word_t f0[num_words_secp224r1];\n  mg_uecc_word_t d1[num_words_secp224r1];\n\n  /* s = a; using constant instead of random value */\n  mod_sqrt_secp224r1_rp(d0, e0, f0, a, a); /* RP (d0, e0, f0, c, s) */\n  mod_sqrt_secp224r1_rs(d1, e1, f1, d0, e0,\n                        f0); /* RS (d1, e1, f1, d0, e0, f0) */\n  for (i = 1; i <= 95; i++) {\n    mg_uecc_vli_set(d0, d1, num_words_secp224r1); /* d0 <-- d1 */\n    mg_uecc_vli_set(e0, e1, num_words_secp224r1); /* e0 <-- e1 */\n    mg_uecc_vli_set(f0, f1, num_words_secp224r1); /* f0 <-- f1 */\n    mod_sqrt_secp224r1_rs(d1, e1, f1, d0, e0,\n                          f0); /* RS (d1, e1, f1, d0, e0, f0) */\n    if (mg_uecc_vli_isZero(d1, num_words_secp224r1)) { /* if d1 == 0 */\n      break;\n    }\n  }\n  mg_uecc_vli_modInv(f1, e0, curve_secp224r1.p,\n                     num_words_secp224r1);               /* f1 <-- 1 / e0 */\n  mg_uecc_vli_modMult_fast(a, d0, f1, &curve_secp224r1); /* a  <-- d0 / e0 */\n}\n#endif /* MG_UECC_SUPPORT_COMPRESSED_POINT */\n\n#if (MG_UECC_OPTIMIZATION_LEVEL > 0)\n/* Computes result = product % curve_p\n   from http://www.nsa.gov/ia/_files/nist-routines.pdf */\n#if MG_UECC_WORD_SIZE == 1\nstatic void vli_mmod_fast_secp224r1(uint8_t *result, uint8_t *product) {\n  uint8_t tmp[num_words_secp224r1];\n  int8_t carry;\n\n  /* t */\n  mg_uecc_vli_set(result, product, num_words_secp224r1);\n\n  /* s1 */\n  tmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;\n  tmp[4] = tmp[5] = tmp[6] = tmp[7] = 0;\n  tmp[8] = tmp[9] = tmp[10] = tmp[11] = 0;\n  tmp[12] = product[28];\n  tmp[13] = product[29];\n  tmp[14] = product[30];\n  tmp[15] = product[31];\n  tmp[16] = product[32];\n  tmp[17] = product[33];\n  tmp[18] = product[34];\n  tmp[19] = product[35];\n  tmp[20] = product[36];\n  tmp[21] = product[37];\n  tmp[22] = product[38];\n  tmp[23] = product[39];\n  tmp[24] = product[40];\n  tmp[25] = product[41];\n  tmp[26] = product[42];\n  tmp[27] = product[43];\n  carry = mg_uecc_vli_add(result, result, tmp, num_words_secp224r1);\n\n  /* s2 */\n  tmp[12] = product[44];\n  tmp[13] = product[45];\n  tmp[14] = product[46];\n  tmp[15] = product[47];\n  tmp[16] = product[48];\n  tmp[17] = product[49];\n  tmp[18] = product[50];\n  tmp[19] = product[51];\n  tmp[20] = product[52];\n  tmp[21] = product[53];\n  tmp[22] = product[54];\n  tmp[23] = product[55];\n  tmp[24] = tmp[25] = tmp[26] = tmp[27] = 0;\n  carry += mg_uecc_vli_add(result, result, tmp, num_words_secp224r1);\n\n  /* d1 */\n  tmp[0] = product[28];\n  tmp[1] = product[29];\n  tmp[2] = product[30];\n  tmp[3] = product[31];\n  tmp[4] = product[32];\n  tmp[5] = product[33];\n  tmp[6] = product[34];\n  tmp[7] = product[35];\n  tmp[8] = product[36];\n  tmp[9] = product[37];\n  tmp[10] = product[38];\n  tmp[11] = product[39];\n  tmp[12] = product[40];\n  tmp[13] = product[41];\n  tmp[14] = product[42];\n  tmp[15] = product[43];\n  tmp[16] = product[44];\n  tmp[17] = product[45];\n  tmp[18] = product[46];\n  tmp[19] = product[47];\n  tmp[20] = product[48];\n  tmp[21] = product[49];\n  tmp[22] = product[50];\n  tmp[23] = product[51];\n  tmp[24] = product[52];\n  tmp[25] = product[53];\n  tmp[26] = product[54];\n  tmp[27] = product[55];\n  carry -= mg_uecc_vli_sub(result, result, tmp, num_words_secp224r1);\n\n  /* d2 */\n  tmp[0] = product[44];\n  tmp[1] = product[45];\n  tmp[2] = product[46];\n  tmp[3] = product[47];\n  tmp[4] = product[48];\n  tmp[5] = product[49];\n  tmp[6] = product[50];\n  tmp[7] = product[51];\n  tmp[8] = product[52];\n  tmp[9] = product[53];\n  tmp[10] = product[54];\n  tmp[11] = product[55];\n  tmp[12] = tmp[13] = tmp[14] = tmp[15] = 0;\n  tmp[16] = tmp[17] = tmp[18] = tmp[19] = 0;\n  tmp[20] = tmp[21] = tmp[22] = tmp[23] = 0;\n  tmp[24] = tmp[25] = tmp[26] = tmp[27] = 0;\n  carry -= mg_uecc_vli_sub(result, result, tmp, num_words_secp224r1);\n\n  if (carry < 0) {\n    do {\n      carry += mg_uecc_vli_add(result, result, curve_secp224r1.p,\n                               num_words_secp224r1);\n    } while (carry < 0);\n  } else {\n    while (carry || mg_uecc_vli_cmp_unsafe(curve_secp224r1.p, result,\n                                           num_words_secp224r1) != 1) {\n      carry -= mg_uecc_vli_sub(result, result, curve_secp224r1.p,\n                               num_words_secp224r1);\n    }\n  }\n}\n#elif MG_UECC_WORD_SIZE == 4\nstatic void vli_mmod_fast_secp224r1(uint32_t *result, uint32_t *product) {\n  uint32_t tmp[num_words_secp224r1];\n  int carry;\n\n  /* t */\n  mg_uecc_vli_set(result, product, num_words_secp224r1);\n\n  /* s1 */\n  tmp[0] = tmp[1] = tmp[2] = 0;\n  tmp[3] = product[7];\n  tmp[4] = product[8];\n  tmp[5] = product[9];\n  tmp[6] = product[10];\n  carry = mg_uecc_vli_add(result, result, tmp, num_words_secp224r1);\n\n  /* s2 */\n  tmp[3] = product[11];\n  tmp[4] = product[12];\n  tmp[5] = product[13];\n  tmp[6] = 0;\n  carry += mg_uecc_vli_add(result, result, tmp, num_words_secp224r1);\n\n  /* d1 */\n  tmp[0] = product[7];\n  tmp[1] = product[8];\n  tmp[2] = product[9];\n  tmp[3] = product[10];\n  tmp[4] = product[11];\n  tmp[5] = product[12];\n  tmp[6] = product[13];\n  carry -= mg_uecc_vli_sub(result, result, tmp, num_words_secp224r1);\n\n  /* d2 */\n  tmp[0] = product[11];\n  tmp[1] = product[12];\n  tmp[2] = product[13];\n  tmp[3] = tmp[4] = tmp[5] = tmp[6] = 0;\n  carry -= mg_uecc_vli_sub(result, result, tmp, num_words_secp224r1);\n\n  if (carry < 0) {\n    do {\n      carry += mg_uecc_vli_add(result, result, curve_secp224r1.p,\n                               num_words_secp224r1);\n    } while (carry < 0);\n  } else {\n    while (carry || mg_uecc_vli_cmp_unsafe(curve_secp224r1.p, result,\n                                           num_words_secp224r1) != 1) {\n      carry -= mg_uecc_vli_sub(result, result, curve_secp224r1.p,\n                               num_words_secp224r1);\n    }\n  }\n}\n#else\nstatic void vli_mmod_fast_secp224r1(uint64_t *result, uint64_t *product) {\n  uint64_t tmp[num_words_secp224r1];\n  int carry = 0;\n\n  /* t */\n  mg_uecc_vli_set(result, product, num_words_secp224r1);\n  result[num_words_secp224r1 - 1] &= 0xffffffff;\n\n  /* s1 */\n  tmp[0] = 0;\n  tmp[1] = product[3] & 0xffffffff00000000ull;\n  tmp[2] = product[4];\n  tmp[3] = product[5] & 0xffffffff;\n  mg_uecc_vli_add(result, result, tmp, num_words_secp224r1);\n\n  /* s2 */\n  tmp[1] = product[5] & 0xffffffff00000000ull;\n  tmp[2] = product[6];\n  tmp[3] = 0;\n  mg_uecc_vli_add(result, result, tmp, num_words_secp224r1);\n\n  /* d1 */\n  tmp[0] = (product[3] >> 32) | (product[4] << 32);\n  tmp[1] = (product[4] >> 32) | (product[5] << 32);\n  tmp[2] = (product[5] >> 32) | (product[6] << 32);\n  tmp[3] = product[6] >> 32;\n  carry -= mg_uecc_vli_sub(result, result, tmp, num_words_secp224r1);\n\n  /* d2 */\n  tmp[0] = (product[5] >> 32) | (product[6] << 32);\n  tmp[1] = product[6] >> 32;\n  tmp[2] = tmp[3] = 0;\n  carry -= mg_uecc_vli_sub(result, result, tmp, num_words_secp224r1);\n\n  if (carry < 0) {\n    do {\n      carry += mg_uecc_vli_add(result, result, curve_secp224r1.p,\n                               num_words_secp224r1);\n    } while (carry < 0);\n  } else {\n    while (mg_uecc_vli_cmp_unsafe(curve_secp224r1.p, result,\n                                  num_words_secp224r1) != 1) {\n      mg_uecc_vli_sub(result, result, curve_secp224r1.p, num_words_secp224r1);\n    }\n  }\n}\n#endif /* MG_UECC_WORD_SIZE */\n#endif /* (MG_UECC_OPTIMIZATION_LEVEL > 0) */\n\n#endif /* MG_UECC_SUPPORTS_secp224r1 */\n\n#if MG_UECC_SUPPORTS_secp256r1\n\n#if (MG_UECC_OPTIMIZATION_LEVEL > 0)\nstatic void vli_mmod_fast_secp256r1(mg_uecc_word_t *result,\n                                    mg_uecc_word_t *product);\n#endif\n\nstatic const struct MG_UECC_Curve_t curve_secp256r1 = {\n    num_words_secp256r1,\n    num_bytes_secp256r1,\n    256, /* num_n_bits */\n    {BYTES_TO_WORDS_8(FF, FF, FF, FF, FF, FF, FF, FF),\n     BYTES_TO_WORDS_8(FF, FF, FF, FF, 00, 00, 00, 00),\n     BYTES_TO_WORDS_8(00, 00, 00, 00, 00, 00, 00, 00),\n     BYTES_TO_WORDS_8(01, 00, 00, 00, FF, FF, FF, FF)},\n    {BYTES_TO_WORDS_8(51, 25, 63, FC, C2, CA, B9, F3),\n     BYTES_TO_WORDS_8(84, 9E, 17, A7, AD, FA, E6, BC),\n     BYTES_TO_WORDS_8(FF, FF, FF, FF, FF, FF, FF, FF),\n     BYTES_TO_WORDS_8(00, 00, 00, 00, FF, FF, FF, FF)},\n    {BYTES_TO_WORDS_8(96, C2, 98, D8, 45, 39, A1, F4),\n     BYTES_TO_WORDS_8(A0, 33, EB, 2D, 81, 7D, 03, 77),\n     BYTES_TO_WORDS_8(F2, 40, A4, 63, E5, E6, BC, F8),\n     BYTES_TO_WORDS_8(47, 42, 2C, E1, F2, D1, 17, 6B),\n\n     BYTES_TO_WORDS_8(F5, 51, BF, 37, 68, 40, B6, CB),\n     BYTES_TO_WORDS_8(CE, 5E, 31, 6B, 57, 33, CE, 2B),\n     BYTES_TO_WORDS_8(16, 9E, 0F, 7C, 4A, EB, E7, 8E),\n     BYTES_TO_WORDS_8(9B, 7F, 1A, FE, E2, 42, E3, 4F)},\n    {BYTES_TO_WORDS_8(4B, 60, D2, 27, 3E, 3C, CE, 3B),\n     BYTES_TO_WORDS_8(F6, B0, 53, CC, B0, 06, 1D, 65),\n     BYTES_TO_WORDS_8(BC, 86, 98, 76, 55, BD, EB, B3),\n     BYTES_TO_WORDS_8(E7, 93, 3A, AA, D8, 35, C6, 5A)},\n    &double_jacobian_default,\n#if MG_UECC_SUPPORT_COMPRESSED_POINT\n    &mod_sqrt_default,\n#endif\n    &x_side_default,\n#if (MG_UECC_OPTIMIZATION_LEVEL > 0)\n    &vli_mmod_fast_secp256r1\n#endif\n};\n\nMG_UECC_Curve mg_uecc_secp256r1(void) {\n  return &curve_secp256r1;\n}\n\n#if (MG_UECC_OPTIMIZATION_LEVEL > 0 && !asm_mmod_fast_secp256r1)\n/* Computes result = product % curve_p\n   from http://www.nsa.gov/ia/_files/nist-routines.pdf */\n#if MG_UECC_WORD_SIZE == 1\nstatic void vli_mmod_fast_secp256r1(uint8_t *result, uint8_t *product) {\n  uint8_t tmp[num_words_secp256r1];\n  int8_t carry;\n\n  /* t */\n  mg_uecc_vli_set(result, product, num_words_secp256r1);\n\n  /* s1 */\n  tmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;\n  tmp[4] = tmp[5] = tmp[6] = tmp[7] = 0;\n  tmp[8] = tmp[9] = tmp[10] = tmp[11] = 0;\n  tmp[12] = product[44];\n  tmp[13] = product[45];\n  tmp[14] = product[46];\n  tmp[15] = product[47];\n  tmp[16] = product[48];\n  tmp[17] = product[49];\n  tmp[18] = product[50];\n  tmp[19] = product[51];\n  tmp[20] = product[52];\n  tmp[21] = product[53];\n  tmp[22] = product[54];\n  tmp[23] = product[55];\n  tmp[24] = product[56];\n  tmp[25] = product[57];\n  tmp[26] = product[58];\n  tmp[27] = product[59];\n  tmp[28] = product[60];\n  tmp[29] = product[61];\n  tmp[30] = product[62];\n  tmp[31] = product[63];\n  carry = mg_uecc_vli_add(tmp, tmp, tmp, num_words_secp256r1);\n  carry += mg_uecc_vli_add(result, result, tmp, num_words_secp256r1);\n\n  /* s2 */\n  tmp[12] = product[48];\n  tmp[13] = product[49];\n  tmp[14] = product[50];\n  tmp[15] = product[51];\n  tmp[16] = product[52];\n  tmp[17] = product[53];\n  tmp[18] = product[54];\n  tmp[19] = product[55];\n  tmp[20] = product[56];\n  tmp[21] = product[57];\n  tmp[22] = product[58];\n  tmp[23] = product[59];\n  tmp[24] = product[60];\n  tmp[25] = product[61];\n  tmp[26] = product[62];\n  tmp[27] = product[63];\n  tmp[28] = tmp[29] = tmp[30] = tmp[31] = 0;\n  carry += mg_uecc_vli_add(tmp, tmp, tmp, num_words_secp256r1);\n  carry += mg_uecc_vli_add(result, result, tmp, num_words_secp256r1);\n\n  /* s3 */\n  tmp[0] = product[32];\n  tmp[1] = product[33];\n  tmp[2] = product[34];\n  tmp[3] = product[35];\n  tmp[4] = product[36];\n  tmp[5] = product[37];\n  tmp[6] = product[38];\n  tmp[7] = product[39];\n  tmp[8] = product[40];\n  tmp[9] = product[41];\n  tmp[10] = product[42];\n  tmp[11] = product[43];\n  tmp[12] = tmp[13] = tmp[14] = tmp[15] = 0;\n  tmp[16] = tmp[17] = tmp[18] = tmp[19] = 0;\n  tmp[20] = tmp[21] = tmp[22] = tmp[23] = 0;\n  tmp[24] = product[56];\n  tmp[25] = product[57];\n  tmp[26] = product[58];\n  tmp[27] = product[59];\n  tmp[28] = product[60];\n  tmp[29] = product[61];\n  tmp[30] = product[62];\n  tmp[31] = product[63];\n  carry += mg_uecc_vli_add(result, result, tmp, num_words_secp256r1);\n\n  /* s4 */\n  tmp[0] = product[36];\n  tmp[1] = product[37];\n  tmp[2] = product[38];\n  tmp[3] = product[39];\n  tmp[4] = product[40];\n  tmp[5] = product[41];\n  tmp[6] = product[42];\n  tmp[7] = product[43];\n  tmp[8] = product[44];\n  tmp[9] = product[45];\n  tmp[10] = product[46];\n  tmp[11] = product[47];\n  tmp[12] = product[52];\n  tmp[13] = product[53];\n  tmp[14] = product[54];\n  tmp[15] = product[55];\n  tmp[16] = product[56];\n  tmp[17] = product[57];\n  tmp[18] = product[58];\n  tmp[19] = product[59];\n  tmp[20] = product[60];\n  tmp[21] = product[61];\n  tmp[22] = product[62];\n  tmp[23] = product[63];\n  tmp[24] = product[52];\n  tmp[25] = product[53];\n  tmp[26] = product[54];\n  tmp[27] = product[55];\n  tmp[28] = product[32];\n  tmp[29] = product[33];\n  tmp[30] = product[34];\n  tmp[31] = product[35];\n  carry += mg_uecc_vli_add(result, result, tmp, num_words_secp256r1);\n\n  /* d1 */\n  tmp[0] = product[44];\n  tmp[1] = product[45];\n  tmp[2] = product[46];\n  tmp[3] = product[47];\n  tmp[4] = product[48];\n  tmp[5] = product[49];\n  tmp[6] = product[50];\n  tmp[7] = product[51];\n  tmp[8] = product[52];\n  tmp[9] = product[53];\n  tmp[10] = product[54];\n  tmp[11] = product[55];\n  tmp[12] = tmp[13] = tmp[14] = tmp[15] = 0;\n  tmp[16] = tmp[17] = tmp[18] = tmp[19] = 0;\n  tmp[20] = tmp[21] = tmp[22] = tmp[23] = 0;\n  tmp[24] = product[32];\n  tmp[25] = product[33];\n  tmp[26] = product[34];\n  tmp[27] = product[35];\n  tmp[28] = product[40];\n  tmp[29] = product[41];\n  tmp[30] = product[42];\n  tmp[31] = product[43];\n  carry -= mg_uecc_vli_sub(result, result, tmp, num_words_secp256r1);\n\n  /* d2 */\n  tmp[0] = product[48];\n  tmp[1] = product[49];\n  tmp[2] = product[50];\n  tmp[3] = product[51];\n  tmp[4] = product[52];\n  tmp[5] = product[53];\n  tmp[6] = product[54];\n  tmp[7] = product[55];\n  tmp[8] = product[56];\n  tmp[9] = product[57];\n  tmp[10] = product[58];\n  tmp[11] = product[59];\n  tmp[12] = product[60];\n  tmp[13] = product[61];\n  tmp[14] = product[62];\n  tmp[15] = product[63];\n  tmp[16] = tmp[17] = tmp[18] = tmp[19] = 0;\n  tmp[20] = tmp[21] = tmp[22] = tmp[23] = 0;\n  tmp[24] = product[36];\n  tmp[25] = product[37];\n  tmp[26] = product[38];\n  tmp[27] = product[39];\n  tmp[28] = product[44];\n  tmp[29] = product[45];\n  tmp[30] = product[46];\n  tmp[31] = product[47];\n  carry -= mg_uecc_vli_sub(result, result, tmp, num_words_secp256r1);\n\n  /* d3 */\n  tmp[0] = product[52];\n  tmp[1] = product[53];\n  tmp[2] = product[54];\n  tmp[3] = product[55];\n  tmp[4] = product[56];\n  tmp[5] = product[57];\n  tmp[6] = product[58];\n  tmp[7] = product[59];\n  tmp[8] = product[60];\n  tmp[9] = product[61];\n  tmp[10] = product[62];\n  tmp[11] = product[63];\n  tmp[12] = product[32];\n  tmp[13] = product[33];\n  tmp[14] = product[34];\n  tmp[15] = product[35];\n  tmp[16] = product[36];\n  tmp[17] = product[37];\n  tmp[18] = product[38];\n  tmp[19] = product[39];\n  tmp[20] = product[40];\n  tmp[21] = product[41];\n  tmp[22] = product[42];\n  tmp[23] = product[43];\n  tmp[24] = tmp[25] = tmp[26] = tmp[27] = 0;\n  tmp[28] = product[48];\n  tmp[29] = product[49];\n  tmp[30] = product[50];\n  tmp[31] = product[51];\n  carry -= mg_uecc_vli_sub(result, result, tmp, num_words_secp256r1);\n\n  /* d4 */\n  tmp[0] = product[56];\n  tmp[1] = product[57];\n  tmp[2] = product[58];\n  tmp[3] = product[59];\n  tmp[4] = product[60];\n  tmp[5] = product[61];\n  tmp[6] = product[62];\n  tmp[7] = product[63];\n  tmp[8] = tmp[9] = tmp[10] = tmp[11] = 0;\n  tmp[12] = product[36];\n  tmp[13] = product[37];\n  tmp[14] = product[38];\n  tmp[15] = product[39];\n  tmp[16] = product[40];\n  tmp[17] = product[41];\n  tmp[18] = product[42];\n  tmp[19] = product[43];\n  tmp[20] = product[44];\n  tmp[21] = product[45];\n  tmp[22] = product[46];\n  tmp[23] = product[47];\n  tmp[24] = tmp[25] = tmp[26] = tmp[27] = 0;\n  tmp[28] = product[52];\n  tmp[29] = product[53];\n  tmp[30] = product[54];\n  tmp[31] = product[55];\n  carry -= mg_uecc_vli_sub(result, result, tmp, num_words_secp256r1);\n\n  if (carry < 0) {\n    do {\n      carry += mg_uecc_vli_add(result, result, curve_secp256r1.p,\n                               num_words_secp256r1);\n    } while (carry < 0);\n  } else {\n    while (carry || mg_uecc_vli_cmp_unsafe(curve_secp256r1.p, result,\n                                           num_words_secp256r1) != 1) {\n      carry -= mg_uecc_vli_sub(result, result, curve_secp256r1.p,\n                               num_words_secp256r1);\n    }\n  }\n}\n#elif MG_UECC_WORD_SIZE == 4\nstatic void vli_mmod_fast_secp256r1(uint32_t *result, uint32_t *product) {\n  uint32_t tmp[num_words_secp256r1];\n  int carry;\n\n  /* t */\n  mg_uecc_vli_set(result, product, num_words_secp256r1);\n\n  /* s1 */\n  tmp[0] = tmp[1] = tmp[2] = 0;\n  tmp[3] = product[11];\n  tmp[4] = product[12];\n  tmp[5] = product[13];\n  tmp[6] = product[14];\n  tmp[7] = product[15];\n  carry = (int) mg_uecc_vli_add(tmp, tmp, tmp, num_words_secp256r1);\n  carry += (int) mg_uecc_vli_ad"
        },
        {
          "name": "mongoose.h",
          "type": "blob",
          "size": 107.6904296875,
          "content": "// Copyright (c) 2004-2013 Sergey Lyubka\n// Copyright (c) 2013-2024 Cesanta Software Limited\n// All rights reserved\n//\n// This software is dual-licensed: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License version 2 as\n// published by the Free Software Foundation. For the terms of this\n// license, see http://www.gnu.org/licenses/\n//\n// You are free to use this software under the terms of the GNU General\n// Public License, but WITHOUT ANY WARRANTY; without even the implied\n// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU General Public License for more details.\n//\n// Alternatively, you can license this software under a commercial\n// license, as set out in https://www.mongoose.ws/licensing/\n//\n// SPDX-License-Identifier: GPL-2.0-only or commercial\n\n#ifndef MONGOOSE_H\n#define MONGOOSE_H\n\n#define MG_VERSION \"7.16\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n#define MG_ARCH_CUSTOM 0        // User creates its own mongoose_config.h\n#define MG_ARCH_UNIX 1          // Linux, BSD, Mac, ...\n#define MG_ARCH_WIN32 2         // Windows\n#define MG_ARCH_ESP32 3         // ESP32\n#define MG_ARCH_ESP8266 4       // ESP8266\n#define MG_ARCH_FREERTOS 5      // FreeRTOS\n#define MG_ARCH_AZURERTOS 6     // MS Azure RTOS\n#define MG_ARCH_ZEPHYR 7        // Zephyr RTOS\n#define MG_ARCH_NEWLIB 8        // Bare metal ARM\n#define MG_ARCH_CMSIS_RTOS1 9   // CMSIS-RTOS API v1 (Keil RTX)\n#define MG_ARCH_TIRTOS 10       // Texas Semi TI-RTOS\n#define MG_ARCH_PICOSDK 11      // Raspberry Pi Pico-SDK (RP2040, RP2350)\n#define MG_ARCH_ARMCC 12        // Keil MDK-Core with Configuration Wizard\n#define MG_ARCH_CMSIS_RTOS2 13  // CMSIS-RTOS API v2 (Keil RTX5, FreeRTOS)\n#define MG_ARCH_RTTHREAD 14     // RT-Thread RTOS\n#define MG_ARCH_ARMCGT 15       // Texas Semi ARM-CGT\n\n#if !defined(MG_ARCH)\n#if defined(__unix__) || defined(__APPLE__)\n#define MG_ARCH MG_ARCH_UNIX\n#elif defined(_WIN32)\n#define MG_ARCH MG_ARCH_WIN32\n#endif\n#endif  // !defined(MG_ARCH)\n\n#if !defined(MG_ARCH) || (MG_ARCH == MG_ARCH_CUSTOM)\n#include \"mongoose_config.h\"  // keep this include\n#endif\n\n#if !defined(MG_ARCH)\n#error \"MG_ARCH is not specified and we couldn't guess it. Define MG_ARCH=... in your compiler\"\n#endif\n\n// http://esr.ibiblio.org/?p=5095\n#define MG_BIG_ENDIAN (*(uint16_t *) \"\\0\\xff\" < 0x100)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#if MG_ARCH == MG_ARCH_ARMCGT\n\n#include <ctype.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <time.h>\n\n#define MG_PATH_MAX 100\n#define MG_ENABLE_SOCKET 0\n#define MG_ENABLE_DIRLIST 0\n\n#endif\n\n\n#if MG_ARCH == MG_ARCH_AZURERTOS\n\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <time.h>\n\n#include <fx_api.h>\n#include <tx_api.h>\n\n#include <nx_api.h>\n#include <nx_bsd.h>\n#include <nx_port.h>\n#include <tx_port.h>\n\n#define PATH_MAX FX_MAXIMUM_PATH\n#define MG_DIRSEP '\\\\'\n\n#define socklen_t int\n#define closesocket(x) soc_close(x)\n\n#undef FOPEN_MAX\n\n#endif\n\n\n#if MG_ARCH == MG_ARCH_ESP32\n\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <netdb.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n\n#include <esp_ota_ops.h>  // Use angle brackets to avoid\n#include <esp_timer.h>    // amalgamation ditching them\n\n#define MG_PATH_MAX 128\n\n#endif\n\n\n#if MG_ARCH == MG_ARCH_ESP8266\n\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <netdb.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <time.h>\n\n#include <esp_system.h>\n\n#define MG_PATH_MAX 128\n\n#endif\n\n\n#if MG_ARCH == MG_ARCH_FREERTOS\n\n#include <ctype.h>\n#if !defined(MG_ENABLE_LWIP) || !MG_ENABLE_LWIP\n#include <errno.h>\n#endif\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>  // rand(), strtol(), atoi()\n#include <string.h>\n#if defined(__ARMCC_VERSION)\n#define mode_t size_t\n#include <alloca.h>\n#include <time.h>\n#elif defined(__CCRH__)\n#else\n#include <sys/stat.h>\n#endif\n\n#include <FreeRTOS.h>\n#include <task.h>\n\n#define calloc(a, b) mg_calloc(a, b)\n#define free(a) vPortFree(a)\n#define malloc(a) pvPortMalloc(a)\n#define strdup(s) ((char *) mg_strdup(mg_str(s)).buf)\n\n// Re-route calloc/free to the FreeRTOS's functions, don't use stdlib\nstatic inline void *mg_calloc(size_t cnt, size_t size) {\n  void *p = pvPortMalloc(cnt * size);\n  if (p != NULL) memset(p, 0, size * cnt);\n  return p;\n}\n\n#define mkdir(a, b) mg_mkdir(a, b)\nstatic inline int mg_mkdir(const char *path, mode_t mode) {\n  (void) path, (void) mode;\n  return -1;\n}\n\n#endif  // MG_ARCH == MG_ARCH_FREERTOS\n\n\n#if MG_ARCH == MG_ARCH_NEWLIB\n#define _POSIX_TIMERS\n\n#include <ctype.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#define MG_PATH_MAX 100\n#define MG_ENABLE_SOCKET 0\n#define MG_ENABLE_DIRLIST 0\n\n#endif\n\n\n#if MG_ARCH == MG_ARCH_PICOSDK\n#if !defined(MG_ENABLE_LWIP) || !MG_ENABLE_LWIP\n#include <errno.h>\n#endif\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include <pico/stdlib.h>\n#include <pico/rand.h>\nint mkdir(const char *, mode_t);\n\n#if MG_OTA == MG_OTA_PICOSDK\n#include <hardware/flash.h>\n#if PICO_RP2040\n#include <pico/bootrom.h>\n#endif\n#endif\n\n#endif\n\n\n#if MG_ARCH == MG_ARCH_RTTHREAD\n\n#include <rtthread.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/select.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <time.h>\n\n#ifndef MG_IO_SIZE\n#define MG_IO_SIZE 1460\n#endif\n\n#endif // MG_ARCH == MG_ARCH_RTTHREAD\n\n\n#if MG_ARCH == MG_ARCH_ARMCC || MG_ARCH == MG_ARCH_CMSIS_RTOS1 || \\\n    MG_ARCH == MG_ARCH_CMSIS_RTOS2\n\n#include <ctype.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <alloca.h>\n#include <string.h>\n#include <time.h>\n#if MG_ARCH == MG_ARCH_CMSIS_RTOS1\n#include \"cmsis_os.h\"  // keep this include\n// https://developer.arm.com/documentation/ka003821/latest\nextern uint32_t rt_time_get(void);\n#elif MG_ARCH == MG_ARCH_CMSIS_RTOS2\n#include \"cmsis_os2.h\"  // keep this include\n#endif\n\n#define strdup(s) ((char *) mg_strdup(mg_str(s)).buf)\n\n#if defined(__ARMCC_VERSION)\n#define mode_t size_t\n#define mkdir(a, b) mg_mkdir(a, b)\nstatic inline int mg_mkdir(const char *path, mode_t mode) {\n  (void) path, (void) mode;\n  return -1;\n}\n#endif\n\n#if (MG_ARCH == MG_ARCH_CMSIS_RTOS1 || MG_ARCH == MG_ARCH_CMSIS_RTOS2) &&     \\\n    !defined MG_ENABLE_RL && (!defined(MG_ENABLE_LWIP) || !MG_ENABLE_LWIP) && \\\n    (!defined(MG_ENABLE_TCPIP) || !MG_ENABLE_TCPIP)\n#define MG_ENABLE_RL 1\n#ifndef MG_SOCK_LISTEN_BACKLOG_SIZE\n#define MG_SOCK_LISTEN_BACKLOG_SIZE 3\n#endif\n#endif\n\n#endif\n\n\n#if MG_ARCH == MG_ARCH_TIRTOS\n\n#include <stdlib.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n\n#include <serrno.h>\n#include <sys/socket.h>\n\n#include <ti/sysbios/knl/Clock.h>\n\n#endif\n\n\n#if MG_ARCH == MG_ARCH_UNIX\n\n#define _DARWIN_UNLIMITED_SELECT 1  // No limit on file descriptors\n\n#if defined(__APPLE__)\n#include <mach/mach_time.h>\n#endif\n\n#if !defined(MG_ENABLE_EPOLL) && defined(__linux__)\n#define MG_ENABLE_EPOLL 1\n#elif !defined(MG_ENABLE_POLL)\n#define MG_ENABLE_POLL 1\n#endif\n\n#include <arpa/inet.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if defined(MG_ENABLE_EPOLL) && MG_ENABLE_EPOLL\n#include <sys/epoll.h>\n#elif defined(MG_ENABLE_POLL) && MG_ENABLE_POLL\n#include <poll.h>\n#else\n#include <sys/select.h>\n#endif\n\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <time.h>\n#include <unistd.h>\n\n#ifndef MG_ENABLE_DIRLIST\n#define MG_ENABLE_DIRLIST 1\n#endif\n\n#ifndef MG_PATH_MAX\n#define MG_PATH_MAX FILENAME_MAX\n#endif\n\n#ifndef MG_ENABLE_POSIX_FS\n#define MG_ENABLE_POSIX_FS 1\n#endif\n\n#ifndef MG_IO_SIZE\n#define MG_IO_SIZE 16384\n#endif\n\n#endif\n\n\n#if MG_ARCH == MG_ARCH_WIN32\n\n#ifndef _CRT_RAND_S\n#define _CRT_RAND_S\n#endif\n\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n\n#ifndef _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef _WINSOCK_DEPRECATED_NO_WARNINGS\n#define _WINSOCK_DEPRECATED_NO_WARNINGS\n#endif\n\n#include <ctype.h>\n#include <direct.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <time.h>\n\n#if defined(_MSC_VER) && _MSC_VER < 1700\n#define __func__ \"\"\ntypedef __int64 int64_t;\ntypedef unsigned __int64 uint64_t;\ntypedef unsigned char uint8_t;\ntypedef char int8_t;\ntypedef unsigned short uint16_t;\ntypedef short int16_t;\ntypedef unsigned int uint32_t;\ntypedef int int32_t;\ntypedef enum { false = 0, true = 1 } bool;\n#else\n#include <stdbool.h>\n#include <stdint.h>\n#include <ws2tcpip.h>\n#endif\n\n#include <process.h>\n#include <winerror.h>\n#include <winsock2.h>\n\n// For mg_random()\n#if defined(_MSC_VER) && _MSC_VER < 1700\n#ifndef _WIN32_WINNT\n#define _WIN32_WINNT 0x400  // Let vc98 pick up wincrypt.h\n#endif\n#include <wincrypt.h>\n#pragma comment(lib, \"advapi32.lib\")\n#endif\n\n// Protect from calls like std::snprintf in app code\n// See https://github.com/cesanta/mongoose/issues/1047\n#ifndef __cplusplus\n#define snprintf _snprintf\n#define vsnprintf _vsnprintf\n#ifndef strdup  // For MSVC with _DEBUG, see #1359\n#define strdup(x) _strdup(x)\n#endif\n#endif\n\n#define MG_INVALID_SOCKET INVALID_SOCKET\n#define MG_SOCKET_TYPE SOCKET\ntypedef unsigned long nfds_t;\n#if defined(_MSC_VER)\n#pragma comment(lib, \"ws2_32.lib\")\n#ifndef alloca\n#define alloca(a) _alloca(a)\n#endif\n#endif\n#define poll(a, b, c) WSAPoll((a), (b), (c))\n#define closesocket(x) closesocket(x)\n\ntypedef int socklen_t;\n#define MG_DIRSEP '\\\\'\n\n#ifndef MG_PATH_MAX\n#define MG_PATH_MAX FILENAME_MAX\n#endif\n\n#ifndef SO_EXCLUSIVEADDRUSE\n#define SO_EXCLUSIVEADDRUSE ((int) (~SO_REUSEADDR))\n#endif\n\n#define MG_SOCK_ERR(errcode) ((errcode) < 0 ? WSAGetLastError() : 0)\n\n#define MG_SOCK_PENDING(errcode)                                            \\\n  (((errcode) < 0) &&                                                       \\\n   (WSAGetLastError() == WSAEINTR || WSAGetLastError() == WSAEINPROGRESS || \\\n    WSAGetLastError() == WSAEWOULDBLOCK))\n\n#define MG_SOCK_RESET(errcode) \\\n  (((errcode) < 0) && (WSAGetLastError() == WSAECONNRESET))\n\n#define realpath(a, b) _fullpath((b), (a), MG_PATH_MAX)\n#define sleep(x) Sleep((x) * 1000)\n#define mkdir(a, b) _mkdir(a)\n#define timegm(x) _mkgmtime(x)\n\n#ifndef S_ISDIR\n#define S_ISDIR(x) (((x) & _S_IFMT) == _S_IFDIR)\n#endif\n\n#ifndef MG_ENABLE_DIRLIST\n#define MG_ENABLE_DIRLIST 1\n#endif\n\n#ifndef SIGPIPE\n#define SIGPIPE 0\n#endif\n\n#ifndef MG_ENABLE_POSIX_FS\n#define MG_ENABLE_POSIX_FS 1\n#endif\n\n#ifndef MG_IO_SIZE\n#define MG_IO_SIZE 16384\n#endif\n\n#endif\n\n\n#if MG_ARCH == MG_ARCH_ZEPHYR\n\n#include <zephyr/kernel.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <zephyr/net/socket.h>\n#include <zephyr/posix/fcntl.h>\n#include <zephyr/posix/sys/select.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <time.h>\n\n#define MG_PUTCHAR(x) printk(\"%c\", x)\n#ifndef strdup\n#define strdup(s) ((char *) mg_strdup(mg_str(s)).buf)\n#endif\n#define strerror(x) zsock_gai_strerror(x)\n\n#ifndef FD_CLOEXEC\n#define FD_CLOEXEC 0\n#endif\n\n#ifndef F_SETFD\n#define F_SETFD 0\n#endif\n\n#define MG_ENABLE_SSI 0\n\nint rand(void);\nint sscanf(const char *, const char *, ...);\n\n#endif\n\n\n#if defined(MG_ENABLE_FREERTOS_TCP) && MG_ENABLE_FREERTOS_TCP\n\n#include <limits.h>\n#include <list.h>\n\n#include <FreeRTOS_IP.h>\n#include <FreeRTOS_Sockets.h>\n\n#define MG_SOCKET_TYPE Socket_t\n#define MG_INVALID_SOCKET FREERTOS_INVALID_SOCKET\n\n// Why FreeRTOS-TCP did not implement a clean BSD API, but its own thing\n// with FreeRTOS_ prefix, is beyond me\n#define IPPROTO_TCP FREERTOS_IPPROTO_TCP\n#define IPPROTO_UDP FREERTOS_IPPROTO_UDP\n#define AF_INET FREERTOS_AF_INET\n#define SOCK_STREAM FREERTOS_SOCK_STREAM\n#define SOCK_DGRAM FREERTOS_SOCK_DGRAM\n#define SO_BROADCAST 0\n#define SO_ERROR 0\n#define SOL_SOCKET 0\n#define SO_REUSEADDR 0\n\n#define MG_SOCK_ERR(errcode) ((errcode) < 0 ? (errcode) : 0)\n\n#define MG_SOCK_PENDING(errcode)                 \\\n  ((errcode) == -pdFREERTOS_ERRNO_EWOULDBLOCK || \\\n   (errcode) == -pdFREERTOS_ERRNO_EISCONN ||     \\\n   (errcode) == -pdFREERTOS_ERRNO_EINPROGRESS || \\\n   (errcode) == -pdFREERTOS_ERRNO_EAGAIN)\n\n#define MG_SOCK_RESET(errcode) ((errcode) == -pdFREERTOS_ERRNO_ENOTCONN)\n\n// actually only if optional timeout is enabled\n#define MG_SOCK_INTR(fd) (fd == NULL)\n\n#define sockaddr_in freertos_sockaddr\n#define sockaddr freertos_sockaddr\n#if ipFR_TCP_VERSION_MAJOR >= 4\n#define sin_addr sin_address.ulIP_IPv4\n#endif\n#define accept(a, b, c) FreeRTOS_accept((a), (b), (c))\n#define connect(a, b, c) FreeRTOS_connect((a), (b), (c))\n#define bind(a, b, c) FreeRTOS_bind((a), (b), (c))\n#define listen(a, b) FreeRTOS_listen((a), (b))\n#define socket(a, b, c) FreeRTOS_socket((a), (b), (c))\n#define send(a, b, c, d) FreeRTOS_send((a), (b), (c), (d))\n#define recv(a, b, c, d) FreeRTOS_recv((a), (b), (c), (d))\n#define setsockopt(a, b, c, d, e) FreeRTOS_setsockopt((a), (b), (c), (d), (e))\n#define sendto(a, b, c, d, e, f) FreeRTOS_sendto((a), (b), (c), (d), (e), (f))\n#define recvfrom(a, b, c, d, e, f) \\\n  FreeRTOS_recvfrom((a), (b), (c), (d), (e), (f))\n#define closesocket(x) FreeRTOS_closesocket(x)\n#define gethostbyname(x) FreeRTOS_gethostbyname(x)\n#define getsockname(a, b, c) mg_getsockname((a), (b), (c))\n#define getpeername(a, b, c) mg_getpeername((a), (b), (c))\n\nstatic inline int mg_getsockname(MG_SOCKET_TYPE fd, void *buf, socklen_t *len) {\n  (void) fd, (void) buf, (void) len;\n  return -1;\n}\n\nstatic inline int mg_getpeername(MG_SOCKET_TYPE fd, void *buf, socklen_t *len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\n#endif\n\n\n#if defined(MG_ENABLE_LWIP) && MG_ENABLE_LWIP\n\n#if defined(__GNUC__) && !defined(__ARMCC_VERSION)\n#include <sys/stat.h>\n#endif\n\nstruct timeval;\n\n#include <lwip/sockets.h>\n\n#if !LWIP_TIMEVAL_PRIVATE\n#if defined(__GNUC__) && !defined(__ARMCC_VERSION) // armclang sets both\n#include <sys/time.h>\n#else\nstruct timeval {\n  time_t tv_sec;\n  long tv_usec;\n};\n#endif\n#endif\n\n#if LWIP_SOCKET != 1\n// Sockets support disabled in LWIP by default\n#error Set LWIP_SOCKET variable to 1 (in lwipopts.h)\n#endif\n#endif\n\n\n#if defined(MG_ENABLE_RL) && MG_ENABLE_RL\n#include <rl_net.h>\n\n#define closesocket(x) closesocket(x)\n\n#define TCP_NODELAY SO_KEEPALIVE\n\n#define MG_SOCK_ERR(errcode) ((errcode) < 0 ? (errcode) : 0)\n\n#define MG_SOCK_PENDING(errcode)                                \\\n  ((errcode) == BSD_EWOULDBLOCK || (errcode) == BSD_EALREADY || \\\n   (errcode) == BSD_EINPROGRESS)\n\n#define MG_SOCK_RESET(errcode) \\\n  ((errcode) == BSD_ECONNABORTED || (errcode) == BSD_ECONNRESET)\n\n// In blocking mode, which is enabled by default, accept() waits for a\n// connection request. In non blocking mode, you must call accept()\n// again if the error code BSD_EWOULDBLOCK is returned.\n#define MG_SOCK_INTR(fd) (fd == BSD_EWOULDBLOCK)\n\n#define socklen_t int\n#endif\n\n\n#ifndef MG_ENABLE_LOG\n#define MG_ENABLE_LOG 1\n#endif\n\n#ifndef MG_ENABLE_CUSTOM_LOG\n#define MG_ENABLE_CUSTOM_LOG 0  // Let user define their own MG_LOG\n#endif\n\n#ifndef MG_ENABLE_TCPIP\n#define MG_ENABLE_TCPIP 0  // Mongoose built-in network stack\n#endif\n\n#ifndef MG_ENABLE_LWIP\n#define MG_ENABLE_LWIP 0  // lWIP network stack\n#endif\n\n#ifndef MG_ENABLE_FREERTOS_TCP\n#define MG_ENABLE_FREERTOS_TCP 0  // Amazon FreeRTOS-TCP network stack\n#endif\n\n#ifndef MG_ENABLE_RL\n#define MG_ENABLE_RL 0  // ARM MDK network stack\n#endif\n\n#ifndef MG_ENABLE_SOCKET\n#define MG_ENABLE_SOCKET !MG_ENABLE_TCPIP\n#endif\n\n#ifndef MG_ENABLE_POLL\n#define MG_ENABLE_POLL 0\n#endif\n\n#ifndef MG_ENABLE_EPOLL\n#define MG_ENABLE_EPOLL 0\n#endif\n\n#ifndef MG_ENABLE_FATFS\n#define MG_ENABLE_FATFS 0\n#endif\n\n#ifndef MG_ENABLE_SSI\n#define MG_ENABLE_SSI 0\n#endif\n\n#ifndef MG_ENABLE_IPV6\n#define MG_ENABLE_IPV6 0\n#endif\n\n#ifndef MG_IPV6_V6ONLY\n#define MG_IPV6_V6ONLY 0  // IPv6 socket binds only to V6, not V4 address\n#endif\n\n#ifndef MG_ENABLE_MD5\n#define MG_ENABLE_MD5 1\n#endif\n\n// Set MG_ENABLE_WINSOCK=0 for Win32 builds with external IP stack (like LWIP)\n#ifndef MG_ENABLE_WINSOCK\n#define MG_ENABLE_WINSOCK 1\n#endif\n\n#ifndef MG_ENABLE_DIRLIST\n#define MG_ENABLE_DIRLIST 0\n#endif\n\n#ifndef MG_ENABLE_CUSTOM_RANDOM\n#define MG_ENABLE_CUSTOM_RANDOM 0\n#endif\n\n#ifndef MG_ENABLE_CUSTOM_MILLIS\n#define MG_ENABLE_CUSTOM_MILLIS 0\n#endif\n\n#ifndef MG_ENABLE_PACKED_FS\n#define MG_ENABLE_PACKED_FS 0\n#endif\n\n#ifndef MG_ENABLE_ASSERT\n#define MG_ENABLE_ASSERT 0\n#endif\n\n#ifndef MG_IO_SIZE\n#define MG_IO_SIZE 256  // Granularity of the send/recv IO buffer growth\n#endif\n\n#ifndef MG_MAX_RECV_SIZE\n#define MG_MAX_RECV_SIZE (3UL * 1024UL * 1024UL)  // Maximum recv IO buffer size\n#endif\n\n#ifndef MG_DATA_SIZE\n#define MG_DATA_SIZE 32  // struct mg_connection :: data size\n#endif\n\n#ifndef MG_MAX_HTTP_HEADERS\n#define MG_MAX_HTTP_HEADERS 30\n#endif\n\n#ifndef MG_HTTP_INDEX\n#define MG_HTTP_INDEX \"index.html\"\n#endif\n\n#ifndef MG_PATH_MAX\n#ifdef PATH_MAX\n#define MG_PATH_MAX PATH_MAX\n#else\n#define MG_PATH_MAX 128\n#endif\n#endif\n\n#ifndef MG_SOCK_LISTEN_BACKLOG_SIZE\n#define MG_SOCK_LISTEN_BACKLOG_SIZE 128\n#endif\n\n#ifndef MG_DIRSEP\n#define MG_DIRSEP '/'\n#endif\n\n#ifndef MG_ENABLE_POSIX_FS\n#define MG_ENABLE_POSIX_FS 0\n#endif\n\n#ifndef MG_INVALID_SOCKET\n#define MG_INVALID_SOCKET (-1)\n#endif\n\n#ifndef MG_SOCKET_TYPE\n#define MG_SOCKET_TYPE int\n#endif\n\n#ifndef MG_SOCKET_ERRNO\n#define MG_SOCKET_ERRNO errno\n#endif\n\n#if MG_ENABLE_EPOLL\n#define MG_EPOLL_ADD(c)                                                    \\\n  do {                                                                     \\\n    struct epoll_event ev = {EPOLLIN | EPOLLERR | EPOLLHUP, {c}};          \\\n    epoll_ctl(c->mgr->epoll_fd, EPOLL_CTL_ADD, (int) (size_t) c->fd, &ev); \\\n  } while (0)\n#define MG_EPOLL_MOD(c, wr)                                                \\\n  do {                                                                     \\\n    struct epoll_event ev = {EPOLLIN | EPOLLERR | EPOLLHUP, {c}};          \\\n    if (wr) ev.events |= EPOLLOUT;                                         \\\n    epoll_ctl(c->mgr->epoll_fd, EPOLL_CTL_MOD, (int) (size_t) c->fd, &ev); \\\n  } while (0)\n#else\n#define MG_EPOLL_ADD(c)\n#define MG_EPOLL_MOD(c, wr)\n#endif\n\n#ifndef MG_ENABLE_PROFILE\n#define MG_ENABLE_PROFILE 0\n#endif\n\n#ifndef MG_ENABLE_TCPIP_DRIVER_INIT    // mg_mgr_init() will also initialize\n#define MG_ENABLE_TCPIP_DRIVER_INIT 1  // enabled built-in driver for\n#endif                                 // Mongoose built-in network stack\n\n#ifndef MG_TCPIP_IP                      // e.g. MG_IPV4(192, 168, 0, 223)\n#define MG_TCPIP_IP MG_IPV4(0, 0, 0, 0)  // Default is 0.0.0.0 (DHCP)\n#endif\n\n#ifndef MG_TCPIP_MASK\n#define MG_TCPIP_MASK MG_IPV4(0, 0, 0, 0)  // Default is 0.0.0.0 (DHCP)\n#endif\n\n#ifndef MG_TCPIP_GW\n#define MG_TCPIP_GW MG_IPV4(0, 0, 0, 0)  // Default is 0.0.0.0 (DHCP)\n#endif\n\n#ifndef MG_SET_MAC_ADDRESS\n#define MG_SET_MAC_ADDRESS(mac)\n#endif\n\n#ifndef MG_SET_WIFI_CREDS\n#define MG_SET_WIFI_CREDS(ssid, pass)\n#endif\n\n#ifndef MG_ENABLE_TCPIP_PRINT_DEBUG_STATS\n#define MG_ENABLE_TCPIP_PRINT_DEBUG_STATS 0\n#endif\n\n\n\n\n// Describes an arbitrary chunk of memory\nstruct mg_str {\n  char *buf;   // String data\n  size_t len;  // String length\n};\n\n// Using macro to avoid shadowing C++ struct constructor, see #1298\n#define mg_str(s) mg_str_s(s)\n\nstruct mg_str mg_str(const char *s);\nstruct mg_str mg_str_n(const char *s, size_t n);\nint mg_casecmp(const char *s1, const char *s2);\nint mg_strcmp(const struct mg_str str1, const struct mg_str str2);\nint mg_strcasecmp(const struct mg_str str1, const struct mg_str str2);\nstruct mg_str mg_strdup(const struct mg_str s);\nbool mg_match(struct mg_str str, struct mg_str pattern, struct mg_str *caps);\nbool mg_span(struct mg_str s, struct mg_str *a, struct mg_str *b, char delim);\n\nbool mg_str_to_num(struct mg_str, int base, void *val, size_t val_len);\n\n\n\n\n// Single producer, single consumer non-blocking queue\n\nstruct mg_queue {\n  char *buf;\n  size_t size;\n  volatile size_t tail;\n  volatile size_t head;\n};\n\nvoid mg_queue_init(struct mg_queue *, char *, size_t);        // Init queue\nsize_t mg_queue_book(struct mg_queue *, char **buf, size_t);  // Reserve space\nvoid mg_queue_add(struct mg_queue *, size_t);                 // Add new message\nsize_t mg_queue_next(struct mg_queue *, char **);  // Get oldest message\nvoid mg_queue_del(struct mg_queue *, size_t);      // Delete oldest message\n\n\n\n\ntypedef void (*mg_pfn_t)(char, void *);                  // Output function\ntypedef size_t (*mg_pm_t)(mg_pfn_t, void *, va_list *);  // %M printer\n\nsize_t mg_vxprintf(void (*)(char, void *), void *, const char *fmt, va_list *);\nsize_t mg_xprintf(void (*fn)(char, void *), void *, const char *fmt, ...);\n\n\n\n\n\n\n// Convenience wrappers around mg_xprintf\nsize_t mg_vsnprintf(char *buf, size_t len, const char *fmt, va_list *ap);\nsize_t mg_snprintf(char *, size_t, const char *fmt, ...);\nchar *mg_vmprintf(const char *fmt, va_list *ap);\nchar *mg_mprintf(const char *fmt, ...);\nsize_t mg_queue_vprintf(struct mg_queue *, const char *fmt, va_list *);\nsize_t mg_queue_printf(struct mg_queue *, const char *fmt, ...);\n\n// %M print helper functions\nsize_t mg_print_base64(void (*out)(char, void *), void *arg, va_list *ap);\nsize_t mg_print_esc(void (*out)(char, void *), void *arg, va_list *ap);\nsize_t mg_print_hex(void (*out)(char, void *), void *arg, va_list *ap);\nsize_t mg_print_ip(void (*out)(char, void *), void *arg, va_list *ap);\nsize_t mg_print_ip_port(void (*out)(char, void *), void *arg, va_list *ap);\nsize_t mg_print_ip4(void (*out)(char, void *), void *arg, va_list *ap);\nsize_t mg_print_ip6(void (*out)(char, void *), void *arg, va_list *ap);\nsize_t mg_print_mac(void (*out)(char, void *), void *arg, va_list *ap);\n\n// Various output functions\nvoid mg_pfn_iobuf(char ch, void *param);  // param: struct mg_iobuf *\nvoid mg_pfn_stdout(char c, void *param);  // param: ignored\n\n// A helper macro for printing JSON: mg_snprintf(buf, len, \"%m\", MG_ESC(\"hi\"))\n#define MG_ESC(str) mg_print_esc, 0, (str)\n\n\n\n\n\n\nenum { MG_LL_NONE, MG_LL_ERROR, MG_LL_INFO, MG_LL_DEBUG, MG_LL_VERBOSE };\nextern int mg_log_level;  // Current log level, one of MG_LL_*\n\nvoid mg_log(const char *fmt, ...);\nvoid mg_log_prefix(int ll, const char *file, int line, const char *fname);\n// bool mg_log2(int ll, const char *file, int line, const char *fmt, ...);\nvoid mg_hexdump(const void *buf, size_t len);\nvoid mg_log_set_fn(mg_pfn_t fn, void *param);\n\n#define mg_log_set(level_) mg_log_level = (level_)\n\n#if MG_ENABLE_LOG\n#define MG_LOG(level, args)                                 \\\n  do {                                                      \\\n    if ((level) <= mg_log_level) {                          \\\n      mg_log_prefix((level), __FILE__, __LINE__, __func__); \\\n      mg_log args;                                          \\\n    }                                                       \\\n  } while (0)\n#else\n#define MG_LOG(level, args) \\\n  do {                      \\\n    if (0) mg_log args;     \\\n  } while (0)\n#endif\n\n#define MG_ERROR(args) MG_LOG(MG_LL_ERROR, args)\n#define MG_INFO(args) MG_LOG(MG_LL_INFO, args)\n#define MG_DEBUG(args) MG_LOG(MG_LL_DEBUG, args)\n#define MG_VERBOSE(args) MG_LOG(MG_LL_VERBOSE, args)\n\n\n\n\nstruct mg_timer {\n  unsigned long id;         // Timer ID\n  uint64_t period_ms;       // Timer period in milliseconds\n  uint64_t expire;          // Expiration timestamp in milliseconds\n  unsigned flags;           // Possible flags values below\n#define MG_TIMER_ONCE 0     // Call function once\n#define MG_TIMER_REPEAT 1   // Call function periodically\n#define MG_TIMER_RUN_NOW 2  // Call immediately when timer is set\n  void (*fn)(void *);       // Function to call\n  void *arg;                // Function argument\n  struct mg_timer *next;    // Linkage\n};\n\nvoid mg_timer_init(struct mg_timer **head, struct mg_timer *timer,\n                   uint64_t milliseconds, unsigned flags, void (*fn)(void *),\n                   void *arg);\nvoid mg_timer_free(struct mg_timer **head, struct mg_timer *);\nvoid mg_timer_poll(struct mg_timer **head, uint64_t new_ms);\nbool mg_timer_expired(uint64_t *expiration, uint64_t period, uint64_t now);\n\n\n\n\n\nenum { MG_FS_READ = 1, MG_FS_WRITE = 2, MG_FS_DIR = 4 };\n\n// Filesystem API functions\n// st() returns MG_FS_* flags and populates file size and modification time\n// ls() calls fn() for every directory entry, allowing to list a directory\n//\n// NOTE: UNIX-style shorthand names for the API functions are deliberately\n// chosen to avoid conflicts with some libraries that make macros for e.g.\n// stat(), write(), read() calls.\nstruct mg_fs {\n  int (*st)(const char *path, size_t *size, time_t *mtime);  // stat file\n  void (*ls)(const char *path, void (*fn)(const char *, void *),\n             void *);  // List directory entries: call fn(file_name, fn_data)\n                       // for each directory entry\n  void *(*op)(const char *path, int flags);             // Open file\n  void (*cl)(void *fd);                                 // Close file\n  size_t (*rd)(void *fd, void *buf, size_t len);        // Read file\n  size_t (*wr)(void *fd, const void *buf, size_t len);  // Write file\n  size_t (*sk)(void *fd, size_t offset);                // Set file position\n  bool (*mv)(const char *from, const char *to);         // Rename file\n  bool (*rm)(const char *path);                         // Delete file\n  bool (*mkd)(const char *path);                        // Create directory\n};\n\nextern struct mg_fs mg_fs_posix;   // POSIX open/close/read/write/seek\nextern struct mg_fs mg_fs_packed;  // Packed FS, see examples/device-dashboard\nextern struct mg_fs mg_fs_fat;     // FAT FS\n\n// File descriptor\nstruct mg_fd {\n  void *fd;\n  struct mg_fs *fs;\n};\n\nstruct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags);\nvoid mg_fs_close(struct mg_fd *fd);\nbool mg_fs_ls(struct mg_fs *fs, const char *path, char *buf, size_t len);\nstruct mg_str mg_file_read(struct mg_fs *fs, const char *path);\nbool mg_file_write(struct mg_fs *fs, const char *path, const void *, size_t);\nbool mg_file_printf(struct mg_fs *fs, const char *path, const char *fmt, ...);\n\n// Packed API\nconst char *mg_unpack(const char *path, size_t *size, time_t *mtime);\nconst char *mg_unlist(size_t no);             // Get no'th packed filename\nstruct mg_str mg_unpacked(const char *path);  // Packed file as mg_str\n\n\n\n\n\n\n\n#if MG_ENABLE_ASSERT\n#include <assert.h>\n#elif !defined(assert)\n#define assert(x)\n#endif\n\nvoid mg_bzero(volatile unsigned char *buf, size_t len);\nbool mg_random(void *buf, size_t len);\nchar *mg_random_str(char *buf, size_t len);\nuint16_t mg_ntohs(uint16_t net);\nuint32_t mg_ntohl(uint32_t net);\nuint32_t mg_crc32(uint32_t crc, const char *buf, size_t len);\nuint64_t mg_millis(void);  // Return milliseconds since boot\nbool mg_path_is_sane(const struct mg_str path);\n\n#define mg_htons(x) mg_ntohs(x)\n#define mg_htonl(x) mg_ntohl(x)\n\n#define MG_U32(a, b, c, d)                                           \\\n  (((uint32_t) ((a) & 255) << 24) | ((uint32_t) ((b) & 255) << 16) | \\\n   ((uint32_t) ((c) & 255) << 8) | (uint32_t) ((d) & 255))\n\n#define MG_IPV4(a, b, c, d) mg_htonl(MG_U32(a, b, c, d))\n\n// For printing IPv4 addresses: printf(\"%d.%d.%d.%d\\n\", MG_IPADDR_PARTS(&ip))\n#define MG_U8P(ADDR) ((uint8_t *) (ADDR))\n#define MG_IPADDR_PARTS(ADDR) \\\n  MG_U8P(ADDR)[0], MG_U8P(ADDR)[1], MG_U8P(ADDR)[2], MG_U8P(ADDR)[3]\n\n#define MG_LOAD_BE16(p) ((uint16_t) ((MG_U8P(p)[0] << 8U) | MG_U8P(p)[1]))\n#define MG_LOAD_BE24(p) \\\n  ((uint32_t) ((MG_U8P(p)[0] << 16U) | (MG_U8P(p)[1] << 8U) | MG_U8P(p)[2]))\n#define MG_STORE_BE16(p, n)           \\\n  do {                                \\\n    MG_U8P(p)[0] = ((n) >> 8U) & 255; \\\n    MG_U8P(p)[1] = (n) &255;          \\\n  } while (0)\n\n#define MG_REG(x) ((volatile uint32_t *) (x))[0]\n#define MG_BIT(x) (((uint32_t) 1U) << (x))\n#define MG_SET_BITS(R, CLRMASK, SETMASK) (R) = ((R) & ~(CLRMASK)) | (SETMASK)\n\n#define MG_ROUND_UP(x, a) ((a) == 0 ? (x) : ((((x) + (a) -1) / (a)) * (a)))\n#define MG_ROUND_DOWN(x, a) ((a) == 0 ? (x) : (((x) / (a)) * (a)))\n\n#if defined(__GNUC__)\n#define MG_ARM_DISABLE_IRQ() asm volatile(\"cpsid i\" : : : \"memory\")\n#define MG_ARM_ENABLE_IRQ() asm volatile(\"cpsie i\" : : : \"memory\")\n#elif defined(__CCRH__)\n#define MG_RH850_DISABLE_IRQ() __DI()\n#define MG_RH850_ENABLE_IRQ() __EI()\n#else\n#define MG_ARM_DISABLE_IRQ()\n#define MG_ARM_ENABLE_IRQ()\n#endif\n\n#if defined(__CC_ARM)\n#define MG_DSB() __dsb(0xf)\n#elif defined(__ARMCC_VERSION)\n#define MG_DSB() __builtin_arm_dsb(0xf)\n#elif defined(__GNUC__) && defined(__arm__) && defined(__thumb__)\n#define MG_DSB() asm(\"DSB 0xf\")\n#elif defined(__ICCARM__)\n#define MG_DSB() __iar_builtin_DSB()\n#else\n#define MG_DSB()\n#endif\n\nstruct mg_addr;\nint mg_check_ip_acl(struct mg_str acl, struct mg_addr *remote_ip);\n\n// Linked list management macros\n#define LIST_ADD_HEAD(type_, head_, elem_) \\\n  do {                                     \\\n    (elem_)->next = (*head_);              \\\n    *(head_) = (elem_);                    \\\n  } while (0)\n\n#define LIST_ADD_TAIL(type_, head_, elem_) \\\n  do {                                     \\\n    type_ **h = head_;                     \\\n    while (*h != NULL) h = &(*h)->next;    \\\n    *h = (elem_);                          \\\n  } while (0)\n\n#define LIST_DELETE(type_, head_, elem_)   \\\n  do {                                     \\\n    type_ **h = head_;                     \\\n    while (*h != (elem_)) h = &(*h)->next; \\\n    *h = (elem_)->next;                    \\\n  } while (0)\n\n\n\nunsigned short mg_url_port(const char *url);\nint mg_url_is_ssl(const char *url);\nstruct mg_str mg_url_host(const char *url);\nstruct mg_str mg_url_user(const char *url);\nstruct mg_str mg_url_pass(const char *url);\nconst char *mg_url_uri(const char *url);\n\n\n\n\nstruct mg_iobuf {\n  unsigned char *buf;  // Pointer to stored data\n  size_t size;         // Total size available\n  size_t len;          // Current number of bytes\n  size_t align;        // Alignment during allocation\n};\n\nint mg_iobuf_init(struct mg_iobuf *, size_t, size_t);\nint mg_iobuf_resize(struct mg_iobuf *, size_t);\nvoid mg_iobuf_free(struct mg_iobuf *);\nsize_t mg_iobuf_add(struct mg_iobuf *, size_t, const void *, size_t);\nsize_t mg_iobuf_del(struct mg_iobuf *, size_t ofs, size_t len);\n\n\nsize_t mg_base64_update(unsigned char input_byte, char *buf, size_t len);\nsize_t mg_base64_final(char *buf, size_t len);\nsize_t mg_base64_encode(const unsigned char *p, size_t n, char *buf, size_t);\nsize_t mg_base64_decode(const char *src, size_t n, char *dst, size_t);\n\n\n\n\ntypedef struct {\n  uint32_t buf[4];\n  uint32_t bits[2];\n  unsigned char in[64];\n} mg_md5_ctx;\n\nvoid mg_md5_init(mg_md5_ctx *c);\nvoid mg_md5_update(mg_md5_ctx *c, const unsigned char *data, size_t len);\nvoid mg_md5_final(mg_md5_ctx *c, unsigned char[16]);\n\n\n\n\ntypedef struct {\n  uint32_t state[5];\n  uint32_t count[2];\n  unsigned char buffer[64];\n} mg_sha1_ctx;\n\nvoid mg_sha1_init(mg_sha1_ctx *);\nvoid mg_sha1_update(mg_sha1_ctx *, const unsigned char *data, size_t len);\nvoid mg_sha1_final(unsigned char digest[20], mg_sha1_ctx *);\n// https://github.com/B-Con/crypto-algorithms\n// Author:     Brad Conte (brad AT bradconte.com)\n// Disclaimer: This code is presented \"as is\" without any guarantees.\n// Details:    Defines the API for the corresponding SHA1 implementation.\n// Copyright:  public domain\n\n\n\n\n\ntypedef struct {\n  uint32_t state[8];\n  uint64_t bits;\n  uint32_t len;\n  unsigned char buffer[64];\n} mg_sha256_ctx;\n\nvoid mg_sha256_init(mg_sha256_ctx *);\nvoid mg_sha256_update(mg_sha256_ctx *, const unsigned char *data, size_t len);\nvoid mg_sha256_final(unsigned char digest[32], mg_sha256_ctx *);\nvoid mg_hmac_sha256(uint8_t dst[32], uint8_t *key, size_t keysz, uint8_t *data,\n                    size_t datasz);\n#ifndef TLS_X15519_H\n#define TLS_X15519_H\n\n\n\n#define X25519_BYTES 32\nextern const uint8_t X25519_BASE_POINT[X25519_BYTES];\n\nint mg_tls_x25519(uint8_t out[X25519_BYTES], const uint8_t scalar[X25519_BYTES],\n                  const uint8_t x1[X25519_BYTES], int clamp);\n\n\n#endif /* TLS_X15519_H */\n/******************************************************************************\n *\n * THIS SOURCE CODE IS HEREBY PLACED INTO THE PUBLIC DOMAIN FOR THE GOOD OF ALL\n *\n * This is a simple and straightforward implementation of AES-GCM authenticated\n * encryption. The focus of this work was correctness & accuracy. It is written\n * in straight 'C' without any particular focus upon optimization or speed. It\n * should be endian (memory byte order) neutral since the few places that care\n * are handled explicitly.\n *\n * This implementation of AES-GCM was created by Steven M. Gibson of GRC.com.\n *\n * It is intended for general purpose use, but was written in support of GRC's\n * reference implementation of the SQRL (Secure Quick Reliable Login) client.\n *\n * See:    http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf\n *         http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/ \\\n *         gcm/gcm-revised-spec.pdf\n *\n * NO COPYRIGHT IS CLAIMED IN THIS WORK, HOWEVER, NEITHER IS ANY WARRANTY MADE\n * REGARDING ITS FITNESS FOR ANY PARTICULAR PURPOSE. USE IT AT YOUR OWN RISK.\n *\n *******************************************************************************/\n#ifndef TLS_AES128_H\n#define TLS_AES128_H\n\n/******************************************************************************\n *  AES_CONTEXT : cipher context / holds inter-call data\n ******************************************************************************/\ntypedef struct {\n  int mode;          // 1 for Encryption, 0 for Decryption\n  int rounds;        // keysize-based rounds count\n  uint32_t *rk;      // pointer to current round key\n  uint32_t buf[68];  // key expansion buffer\n} aes_context;\n\n\n#define GCM_AUTH_FAILURE 0x55555555  // authentication failure\n\n/******************************************************************************\n *  GCM_CONTEXT : MUST be called once before ANY use of this library\n ******************************************************************************/\nint mg_gcm_initialize(void);\n\n//\n//  aes-gcm.h\n//  MKo\n//\n//  Created by Markus Kosmal on 20/11/14.\n//\n//\nint mg_aes_gcm_encrypt(unsigned char *output, const unsigned char *input,\n                       size_t input_length, const unsigned char *key,\n                       const size_t key_len, const unsigned char *iv,\n                       const size_t iv_len, unsigned char *aead,\n                       size_t aead_len, unsigned char *tag,\n                       const size_t tag_len);\n\nint mg_aes_gcm_decrypt(unsigned char *output, const unsigned char *input,\n                       size_t input_length, const unsigned char *key,\n                       const size_t key_len, const unsigned char *iv,\n                       const size_t iv_len);\n\n#endif /* TLS_AES128_H */\n\n// End of aes128 PD\n\n\n\n#define MG_UECC_SUPPORTS_secp256r1 1\n/* Copyright 2014, Kenneth MacKay. Licensed under the BSD 2-clause license. */\n\n#ifndef _UECC_H_\n#define _UECC_H_\n\n/* Platform selection options.\nIf MG_UECC_PLATFORM is not defined, the code will try to guess it based on\ncompiler macros. Possible values for MG_UECC_PLATFORM are defined below: */\n#define mg_uecc_arch_other 0\n#define mg_uecc_x86 1\n#define mg_uecc_x86_64 2\n#define mg_uecc_arm 3\n#define mg_uecc_arm_thumb 4\n#define mg_uecc_arm_thumb2 5\n#define mg_uecc_arm64 6\n#define mg_uecc_avr 7\n\n/* If desired, you can define MG_UECC_WORD_SIZE as appropriate for your platform\n(1, 4, or 8 bytes). If MG_UECC_WORD_SIZE is not explicitly defined then it will\nbe automatically set based on your platform. */\n\n/* Optimization level; trade speed for code size.\n   Larger values produce code that is faster but larger.\n   Currently supported values are 0 - 4; 0 is unusably slow for most\n   applications. Optimization level 4 currently only has an effect ARM platforms\n   where more than one curve is enabled. */\n#ifndef MG_UECC_OPTIMIZATION_LEVEL\n#define MG_UECC_OPTIMIZATION_LEVEL 2\n#endif\n\n/* MG_UECC_SQUARE_FUNC - If enabled (defined as nonzero), this will cause a\nspecific function to be used for (scalar) squaring instead of the generic\nmultiplication function. This can make things faster somewhat faster, but\nincreases the code size. */\n#ifndef MG_UECC_SQUARE_FUNC\n#define MG_UECC_SQUARE_FUNC 0\n#endif\n\n/* MG_UECC_VLI_NATIVE_LITTLE_ENDIAN - If enabled (defined as nonzero), this will\nswitch to native little-endian format for *all* arrays passed in and out of the\npublic API. This includes public and private keys, shared secrets, signatures\nand message hashes. Using this switch reduces the amount of call stack memory\nused by uECC, since less intermediate translations are required. Note that this\nwill *only* work on native little-endian processors and it will treat the\nuint8_t arrays passed into the public API as word arrays, therefore requiring\nthe provided byte arrays to be word aligned on architectures that do not support\nunaligned accesses. IMPORTANT: Keys and signatures generated with\nMG_UECC_VLI_NATIVE_LITTLE_ENDIAN=1 are incompatible with keys and signatures\ngenerated with MG_UECC_VLI_NATIVE_LITTLE_ENDIAN=0; all parties must use the same\nendianness. */\n#ifndef MG_UECC_VLI_NATIVE_LITTLE_ENDIAN\n#define MG_UECC_VLI_NATIVE_LITTLE_ENDIAN 0\n#endif\n\n/* Curve support selection. Set to 0 to remove that curve. */\n#ifndef MG_UECC_SUPPORTS_secp160r1\n#define MG_UECC_SUPPORTS_secp160r1 0\n#endif\n#ifndef MG_UECC_SUPPORTS_secp192r1\n#define MG_UECC_SUPPORTS_secp192r1 0\n#endif\n#ifndef MG_UECC_SUPPORTS_secp224r1\n#define MG_UECC_SUPPORTS_secp224r1 0\n#endif\n#ifndef MG_UECC_SUPPORTS_secp256r1\n#define MG_UECC_SUPPORTS_secp256r1 1\n#endif\n#ifndef MG_UECC_SUPPORTS_secp256k1\n#define MG_UECC_SUPPORTS_secp256k1 0\n#endif\n\n/* Specifies whether compressed point format is supported.\n   Set to 0 to disable point compression/decompression functions. */\n#ifndef MG_UECC_SUPPORT_COMPRESSED_POINT\n#define MG_UECC_SUPPORT_COMPRESSED_POINT 1\n#endif\n\nstruct MG_UECC_Curve_t;\ntypedef const struct MG_UECC_Curve_t *MG_UECC_Curve;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if MG_UECC_SUPPORTS_secp160r1\nMG_UECC_Curve mg_uecc_secp160r1(void);\n#endif\n#if MG_UECC_SUPPORTS_secp192r1\nMG_UECC_Curve mg_uecc_secp192r1(void);\n#endif\n#if MG_UECC_SUPPORTS_secp224r1\nMG_UECC_Curve mg_uecc_secp224r1(void);\n#endif\n#if MG_UECC_SUPPORTS_secp256r1\nMG_UECC_Curve mg_uecc_secp256r1(void);\n#endif\n#if MG_UECC_SUPPORTS_secp256k1\nMG_UECC_Curve mg_uecc_secp256k1(void);\n#endif\n\n/* MG_UECC_RNG_Function type\nThe RNG function should fill 'size' random bytes into 'dest'. It should return 1\nif 'dest' was filled with random data, or 0 if the random data could not be\ngenerated. The filled-in values should be either truly random, or from a\ncryptographically-secure PRNG.\n\nA correctly functioning RNG function must be set (using mg_uecc_set_rng())\nbefore calling mg_uecc_make_key() or mg_uecc_sign().\n\nSetting a correctly functioning RNG function improves the resistance to\nside-channel attacks for mg_uecc_shared_secret() and\nmg_uecc_sign_deterministic().\n\nA correct RNG function is set by default when building for Windows, Linux, or OS\nX. If you are building on another POSIX-compliant system that supports\n/dev/random or /dev/urandom, you can define MG_UECC_POSIX to use the predefined\nRNG. For embedded platforms there is no predefined RNG function; you must\nprovide your own.\n*/\ntypedef int (*MG_UECC_RNG_Function)(uint8_t *dest, unsigned size);\n\n/* mg_uecc_set_rng() function.\nSet the function that will be used to generate random bytes. The RNG function\nshould return 1 if the random data was generated, or 0 if the random data could\nnot be generated.\n\nOn platforms where there is no predefined RNG function (eg embedded platforms),\nthis must be called before mg_uecc_make_key() or mg_uecc_sign() are used.\n\nInputs:\n    rng_function - The function that will be used to generate random bytes.\n*/\nvoid mg_uecc_set_rng(MG_UECC_RNG_Function rng_function);\n\n/* mg_uecc_get_rng() function.\n\nReturns the function that will be used to generate random bytes.\n*/\nMG_UECC_RNG_Function mg_uecc_get_rng(void);\n\n/* mg_uecc_curve_private_key_size() function.\n\nReturns the size of a private key for the curve in bytes.\n*/\nint mg_uecc_curve_private_key_size(MG_UECC_Curve curve);\n\n/* mg_uecc_curve_public_key_size() function.\n\nReturns the size of a public key for the curve in bytes.\n*/\nint mg_uecc_curve_public_key_size(MG_UECC_Curve curve);\n\n/* mg_uecc_make_key() function.\nCreate a public/private key pair.\n\nOutputs:\n    public_key  - Will be filled in with the public key. Must be at least 2 *\nthe curve size (in bytes) long. For example, if the curve is secp256r1,\npublic_key must be 64 bytes long. private_key - Will be filled in with the\nprivate key. Must be as long as the curve order; this is typically the same as\nthe curve size, except for secp160r1. For example, if the curve is secp256r1,\nprivate_key must be 32 bytes long.\n\n                  For secp160r1, private_key must be 21 bytes long! Note that\nthe first byte will almost always be 0 (there is about a 1 in 2^80 chance of it\nbeing non-zero).\n\nReturns 1 if the key pair was generated successfully, 0 if an error occurred.\n*/\nint mg_uecc_make_key(uint8_t *public_key, uint8_t *private_key,\n                     MG_UECC_Curve curve);\n\n/* mg_uecc_shared_secret() function.\nCompute a shared secret given your secret key and someone else's public key. If\nthe public key is not from a trusted source and has not been previously\nverified, you should verify it first using mg_uecc_valid_public_key(). Note: It\nis recommended that you hash the result of mg_uecc_shared_secret() before using\nit for symmetric encryption or HMAC.\n\nInputs:\n    public_key  - The public key of the remote party.\n    private_key - Your private key.\n\nOutputs:\n    secret - Will be filled in with the shared secret value. Must be the same\nsize as the curve size; for example, if the curve is secp256r1, secret must be\n32 bytes long.\n\nReturns 1 if the shared secret was generated successfully, 0 if an error\noccurred.\n*/\nint mg_uecc_shared_secret(const uint8_t *public_key, const uint8_t *private_key,\n                          uint8_t *secret, MG_UECC_Curve curve);\n\n#if MG_UECC_SUPPORT_COMPRESSED_POINT\n/* mg_uecc_compress() function.\nCompress a public key.\n\nInputs:\n    public_key - The public key to compress.\n\nOutputs:\n    compressed - Will be filled in with the compressed public key. Must be at\nleast (curve size + 1) bytes long; for example, if the curve is secp256r1,\n                 compressed must be 33 bytes long.\n*/\nvoid mg_uecc_compress(const uint8_t *public_key, uint8_t *compressed,\n                      MG_UECC_Curve curve);\n\n/* mg_uecc_decompress() function.\nDecompress a compressed public key.\n\nInputs:\n    compressed - The compressed public key.\n\nOutputs:\n    public_key - Will be filled in with the decompressed public key.\n*/\nvoid mg_uecc_decompress(const uint8_t *compressed, uint8_t *public_key,\n                        MG_UECC_Curve curve);\n#endif /* MG_UECC_SUPPORT_COMPRESSED_POINT */\n\n/* mg_uecc_valid_public_key() function.\nCheck to see if a public key is valid.\n\nNote that you are not required to check for a valid public key before using any\nother uECC functions. However, you may wish to avoid spending CPU time computing\na shared secret or verifying a signature using an invalid public key.\n\nInputs:\n    public_key - The public key to check.\n\nReturns 1 if the public key is valid, 0 if it is invalid.\n*/\nint mg_uecc_valid_public_key(const uint8_t *public_key, MG_UECC_Curve curve);\n\n/* mg_uecc_compute_public_key() function.\nCompute the corresponding public key for a private key.\n\nInputs:\n    private_key - The private key to compute the public key for\n\nOutputs:\n    public_key - Will be filled in with the corresponding public key\n\nReturns 1 if the key was computed successfully, 0 if an error occurred.\n*/\nint mg_uecc_compute_public_key(const uint8_t *private_key, uint8_t *public_key,\n                               MG_UECC_Curve curve);\n\n/* mg_uecc_sign() function.\nGenerate an ECDSA signature for a given hash value.\n\nUsage: Compute a hash of the data you wish to sign (SHA-2 is recommended) and\npass it in to this function along with your private key.\n\nInputs:\n    private_key  - Your private key.\n    message_hash - The hash of the message to sign.\n    hash_size    - The size of message_hash in bytes.\n\nOutputs:\n    signature - Will be filled in with the signature value. Must be at least 2 *\ncurve size long. For example, if the curve is secp256r1, signature must be 64\nbytes long.\n\nReturns 1 if the signature generated successfully, 0 if an error occurred.\n*/\nint mg_uecc_sign(const uint8_t *private_key, const uint8_t *message_hash,\n                 unsigned hash_size, uint8_t *signature, MG_UECC_Curve curve);\n\n/* MG_UECC_HashContext structure.\nThis is used to pass in an arbitrary hash function to\nmg_uecc_sign_deterministic(). The structure will be used for multiple hash\ncomputations; each time a new hash is computed, init_hash() will be called,\nfollowed by one or more calls to update_hash(), and finally a call to\nfinish_hash() to produce the resulting hash.\n\nThe intention is that you will create a structure that includes\nMG_UECC_HashContext followed by any hash-specific data. For example:\n\ntypedef struct SHA256_HashContext {\n    MG_UECC_HashContext uECC;\n    SHA256_CTX ctx;\n} SHA256_HashContext;\n\nvoid init_SHA256(MG_UECC_HashContext *base) {\n    SHA256_HashContext *context = (SHA256_HashContext *)base;\n    SHA256_Init(&context->ctx);\n}\n\nvoid update_SHA256(MG_UECC_HashContext *base,\n                   const uint8_t *message,\n                   unsigned message_size) {\n    SHA256_HashContext *context = (SHA256_HashContext *)base;\n    SHA256_Update(&context->ctx, message, message_size);\n}\n\nvoid finish_SHA256(MG_UECC_HashContext *base, uint8_t *hash_result) {\n    SHA256_HashContext *context = (SHA256_HashContext *)base;\n    SHA256_Final(hash_result, &context->ctx);\n}\n\n... when signing ...\n{\n    uint8_t tmp[32 + 32 + 64];\n    SHA256_HashContext ctx = {{&init_SHA256, &update_SHA256, &finish_SHA256, 64,\n32, tmp}}; mg_uecc_sign_deterministic(key, message_hash, &ctx.uECC, signature);\n}\n*/\ntypedef struct MG_UECC_HashContext {\n  void (*init_hash)(const struct MG_UECC_HashContext *context);\n  void (*update_hash)(const struct MG_UECC_HashContext *context,\n                      const uint8_t *message, unsigned message_size);\n  void (*finish_hash)(const struct MG_UECC_HashContext *context,\n                      uint8_t *hash_result);\n  unsigned\n      block_size; /* Hash function block size in bytes, eg 64 for SHA-256. */\n  unsigned\n      result_size; /* Hash function result size in bytes, eg 32 for SHA-256. */\n  uint8_t *tmp;    /* Must point to a buffer of at least (2 * result_size +\n                      block_size) bytes. */\n} MG_UECC_HashContext;\n\n/* mg_uecc_sign_deterministic() function.\nGenerate an ECDSA signature for a given hash value, using a deterministic\nalgorithm (see RFC 6979). You do not need to set the RNG using mg_uecc_set_rng()\nbefore calling this function; however, if the RNG is defined it will improve\nresistance to side-channel attacks.\n\nUsage: Compute a hash of the data you wish to sign (SHA-2 is recommended) and\npass it to this function along with your private key and a hash context. Note\nthat the message_hash does not need to be computed with the same hash function\nused by hash_context.\n\nInputs:\n    private_key  - Your private key.\n    message_hash - The hash of the message to sign.\n    hash_size    - The size of message_hash in bytes.\n    hash_context - A hash context to use.\n\nOutputs:\n    signature - Will be filled in with the signature value.\n\nReturns 1 if the signature generated successfully, 0 if an error occurred.\n*/\nint mg_uecc_sign_deterministic(const uint8_t *private_key,\n                               const uint8_t *message_hash, unsigned hash_size,\n                               const MG_UECC_HashContext *hash_context,\n                               uint8_t *signature, MG_UECC_Curve curve);\n\n/* mg_uecc_verify() function.\nVerify an ECDSA signature.\n\nUsage: Compute the hash of the signed data using the same hash as the signer and\npass it to this function along with the signer's public key and the signature\nvalues (r and s).\n\nInputs:\n    public_key   - The signer's public key.\n    message_hash - The hash of the signed data.\n    hash_size    - The size of message_hash in bytes.\n    signature    - The signature value.\n\nReturns 1 if the signature is valid, 0 if it is invalid.\n*/\nint mg_uecc_verify(const uint8_t *public_key, const uint8_t *message_hash,\n                   unsigned hash_size, const uint8_t *signature,\n                   MG_UECC_Curve curve);\n\n#ifdef __cplusplus\n} /* end of extern \"C\" */\n#endif\n\n#endif /* _UECC_H_ */\n\n/* Copyright 2015, Kenneth MacKay. Licensed under the BSD 2-clause license. */\n\n#ifndef _UECC_TYPES_H_\n#define _UECC_TYPES_H_\n\n#ifndef MG_UECC_PLATFORM\n#if defined(__AVR__) && __AVR__\n#define MG_UECC_PLATFORM mg_uecc_avr\n#elif defined(__thumb2__) || \\\n    defined(_M_ARMT) /* I think MSVC only supports Thumb-2 targets */\n#define MG_UECC_PLATFORM mg_uecc_arm_thumb2\n#elif defined(__thumb__)\n#define MG_UECC_PLATFORM mg_uecc_arm_thumb\n#elif defined(__arm__) || defined(_M_ARM)\n#define MG_UECC_PLATFORM mg_uecc_arm\n#elif defined(__aarch64__)\n#define MG_UECC_PLATFORM mg_uecc_arm64\n#elif defined(__i386__) || defined(_M_IX86) || defined(_X86_) || \\\n    defined(__I86__)\n#define MG_UECC_PLATFORM mg_uecc_x86\n#elif defined(__amd64__) || defined(_M_X64)\n#define MG_UECC_PLATFORM mg_uecc_x86_64\n#else\n#define MG_UECC_PLATFORM mg_uecc_arch_other\n#endif\n#endif\n\n#ifndef MG_UECC_ARM_USE_UMAAL\n#if (MG_UECC_PLATFORM == mg_uecc_arm) && (__ARM_ARCH >= 6)\n#define MG_UECC_ARM_USE_UMAAL 1\n#elif (MG_UECC_PLATFORM == mg_uecc_arm_thumb2) && (__ARM_ARCH >= 6) && \\\n    (!defined(__ARM_ARCH_7M__) || !__ARM_ARCH_7M__)\n#define MG_UECC_ARM_USE_UMAAL 1\n#else\n#define MG_UECC_ARM_USE_UMAAL 0\n#endif\n#endif\n\n#ifndef MG_UECC_WORD_SIZE\n#if MG_UECC_PLATFORM == mg_uecc_avr\n#define MG_UECC_WORD_SIZE 1\n#elif (MG_UECC_PLATFORM == mg_uecc_x86_64 || MG_UECC_PLATFORM == mg_uecc_arm64)\n#define MG_UECC_WORD_SIZE 8\n#else\n#define MG_UECC_WORD_SIZE 4\n#endif\n#endif\n\n#if (MG_UECC_WORD_SIZE != 1) && (MG_UECC_WORD_SIZE != 4) && \\\n    (MG_UECC_WORD_SIZE != 8)\n#error \"Unsupported value for MG_UECC_WORD_SIZE\"\n#endif\n\n#if ((MG_UECC_PLATFORM == mg_uecc_avr) && (MG_UECC_WORD_SIZE != 1))\n#pragma message(\"MG_UECC_WORD_SIZE must be 1 for AVR\")\n#undef MG_UECC_WORD_SIZE\n#define MG_UECC_WORD_SIZE 1\n#endif\n\n#if ((MG_UECC_PLATFORM == mg_uecc_arm ||         \\\n      MG_UECC_PLATFORM == mg_uecc_arm_thumb ||   \\\n      MG_UECC_PLATFORM == mg_uecc_arm_thumb2) && \\\n     (MG_UECC_WORD_SIZE != 4))\n#pragma message(\"MG_UECC_WORD_SIZE must be 4 for ARM\")\n#undef MG_UECC_WORD_SIZE\n#define MG_UECC_WORD_SIZE 4\n#endif\n\ntypedef int8_t wordcount_t;\ntypedef int16_t bitcount_t;\ntypedef int8_t cmpresult_t;\n\n#if (MG_UECC_WORD_SIZE == 1)\n\ntypedef uint8_t mg_uecc_word_t;\ntypedef uint16_t mg_uecc_dword_t;\n\n#define HIGH_BIT_SET 0x80\n#define MG_UECC_WORD_BITS 8\n#define MG_UECC_WORD_BITS_SHIFT 3\n#define MG_UECC_WORD_BITS_MASK 0x07\n\n#elif (MG_UECC_WORD_SIZE == 4)\n\ntypedef uint32_t mg_uecc_word_t;\ntypedef uint64_t mg_uecc_dword_t;\n\n#define HIGH_BIT_SET 0x80000000\n#define MG_UECC_WORD_BITS 32\n#define MG_UECC_WORD_BITS_SHIFT 5\n#define MG_UECC_WORD_BITS_MASK 0x01F\n\n#elif (MG_UECC_WORD_SIZE == 8)\n\ntypedef uint64_t mg_uecc_word_t;\n\n#define HIGH_BIT_SET 0x8000000000000000U\n#define MG_UECC_WORD_BITS 64\n#define MG_UECC_WORD_BITS_SHIFT 6\n#define MG_UECC_WORD_BITS_MASK 0x03F\n\n#endif /* MG_UECC_WORD_SIZE */\n\n#endif /* _UECC_TYPES_H_ */\n\n/* Copyright 2015, Kenneth MacKay. Licensed under the BSD 2-clause license. */\n\n#ifndef _UECC_VLI_H_\n#define _UECC_VLI_H_\n\n// \n// \n\n/* Functions for raw large-integer manipulation. These are only available\n   if uECC.c is compiled with MG_UECC_ENABLE_VLI_API defined to 1. */\n#ifndef MG_UECC_ENABLE_VLI_API\n#define MG_UECC_ENABLE_VLI_API 0\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if MG_UECC_ENABLE_VLI_API\n\nvoid mg_uecc_vli_clear(mg_uecc_word_t *vli, wordcount_t num_words);\n\n/* Constant-time comparison to zero - secure way to compare long integers */\n/* Returns 1 if vli == 0, 0 otherwise. */\nmg_uecc_word_t mg_uecc_vli_isZero(const mg_uecc_word_t *vli,\n                                  wordcount_t num_words);\n\n/* Returns nonzero if bit 'bit' of vli is set. */\nmg_uecc_word_t mg_uecc_vli_testBit(const mg_uecc_word_t *vli, bitcount_t bit);\n\n/* Counts the number of bits required to represent vli. */\nbitcount_t mg_uecc_vli_numBits(const mg_uecc_word_t *vli,\n                               const wordcount_t max_words);\n\n/* Sets dest = src. */\nvoid mg_uecc_vli_set(mg_uecc_word_t *dest, const mg_uecc_word_t *src,\n                     wordcount_t num_words);\n\n/* Constant-time comparison function - secure way to compare long integers */\n/* Returns one if left == right, zero otherwise */\nmg_uecc_word_t mg_uecc_vli_equal(const mg_uecc_word_t *left,\n                                 const mg_uecc_word_t *right,\n                                 wordcount_t num_words);\n\n/* Constant-time comparison function - secure way to compare long integers */\n/* Returns sign of left - right, in constant time. */\ncmpresult_t mg_uecc_vli_cmp(const mg_uecc_word_t *left,\n                            const mg_uecc_word_t *right, wordcount_t num_words);\n\n/* Computes vli = vli >> 1. */\nvoid mg_uecc_vli_rshift1(mg_uecc_word_t *vli, wordcount_t num_words);\n\n/* Computes result = left + right, returning carry. Can modify in place. */\nmg_uecc_word_t mg_uecc_vli_add(mg_uecc_word_t *result,\n                               const mg_uecc_word_t *left,\n                               const mg_uecc_word_t *right,\n                               wordcount_t num_words);\n\n/* Computes result = left - right, returning borrow. Can modify in place. */\nmg_uecc_word_t mg_uecc_vli_sub(mg_uecc_word_t *result,\n                               const mg_uecc_word_t *left,\n                               const mg_uecc_word_t *right,\n                               wordcount_t num_words);\n\n/* Computes result = left * right. Result must be 2 * num_words long. */\nvoid mg_uecc_vli_mult(mg_uecc_word_t *result, const mg_uecc_word_t *left,\n                      const mg_uecc_word_t *right, wordcount_t num_words);\n\n/* Computes result = left^2. Result must be 2 * num_words long. */\nvoid mg_uecc_vli_square(mg_uecc_word_t *result, const mg_uecc_word_t *left,\n                        wordcount_t num_words);\n\n/* Computes result = (left + right) % mod.\n   Assumes that left < mod and right < mod, and that result does not overlap\n   mod. */\nvoid mg_uecc_vli_modAdd(mg_uecc_word_t *result, const mg_uecc_word_t *left,\n                        const mg_uecc_word_t *right, const mg_uecc_word_t *mod,\n                        wordcount_t num_words);\n\n/* Computes result = (left - right) % mod.\n   Assumes that left < mod and right < mod, and that result does not overlap\n   mod. */\nvoid mg_uecc_vli_modSub(mg_uecc_word_t *result, const mg_uecc_word_t *left,\n                        const mg_uecc_word_t *right, const mg_uecc_word_t *mod,\n                        wordcount_t num_words);\n\n/* Computes result = product % mod, where product is 2N words long.\n   Currently only designed to work for mod == curve->p or curve_n. */\nvoid mg_uecc_vli_mmod(mg_uecc_word_t *result, mg_uecc_word_t *product,\n                      const mg_uecc_word_t *mod, wordcount_t num_words);\n\n/* Calculates result = product (mod curve->p), where product is up to\n   2 * curve->num_words long. */\nvoid mg_uecc_vli_mmod_fast(mg_uecc_word_t *result, mg_uecc_word_t *product,\n                           MG_UECC_Curve curve);\n\n/* Computes result = (left * right) % mod.\n   Currently only designed to work for mod == curve->p or curve_n. */\nvoid mg_uecc_vli_modMult(mg_uecc_word_t *result, const mg_uecc_word_t *left,\n                         const mg_uecc_word_t *right, const mg_uecc_word_t *mod,\n                         wordcount_t num_words);\n\n/* Computes result = (left * right) % curve->p. */\nvoid mg_uecc_vli_modMult_fast(mg_uecc_word_t *result,\n                              const mg_uecc_word_t *left,\n                              const mg_uecc_word_t *right, MG_UECC_Curve curve);\n\n/* Computes result = left^2 % mod.\n   Currently only designed to work for mod == curve->p or curve_n. */\nvoid mg_uecc_vli_modSquare(mg_uecc_word_t *result, const mg_uecc_word_t *left,\n                           const mg_uecc_word_t *mod, wordcount_t num_words);\n\n/* Computes result = left^2 % curve->p. */\nvoid mg_uecc_vli_modSquare_fast(mg_uecc_word_t *result,\n                                const mg_uecc_word_t *left,\n                                MG_UECC_Curve curve);\n\n/* Computes result = (1 / input) % mod.*/\nvoid mg_uecc_vli_modInv(mg_uecc_word_t *result, const mg_uecc_word_t *input,\n                        const mg_uecc_word_t *mod, wordcount_t num_words);\n\n#if MG_UECC_SUPPORT_COMPRESSED_POINT\n/* Calculates a = sqrt(a) (mod curve->p) */\nvoid mg_uecc_vli_mod_sqrt(mg_uecc_word_t *a, MG_UECC_Curve curve);\n#endif\n\n/* Converts an integer in uECC native format to big-endian bytes. */\nvoid mg_uecc_vli_nativeToBytes(uint8_t *bytes, int num_bytes,\n                               const mg_uecc_word_t *native);\n/* Converts big-endian bytes to an integer in uECC native format. */\nvoid mg_uecc_vli_bytesToNative(mg_uecc_word_t *native, const uint8_t *bytes,\n                               int num_bytes);\n\nunsigned mg_uecc_curve_num_words(MG_UECC_Curve curve);\nunsigned mg_uecc_curve_num_bytes(MG_UECC_Curve curve);\nunsigned mg_uecc_curve_num_bits(MG_UECC_Curve curve);\nunsigned mg_uecc_curve_num_n_words(MG_UECC_Curve curve);\nunsigned mg_uecc_curve_num_n_bytes(MG_UECC_Curve curve);\nunsigned mg_uecc_curve_num_n_bits(MG_UECC_Curve curve);\n\nconst mg_uecc_word_t *mg_uecc_curve_p(MG_UECC_Curve curve);\nconst mg_uecc_word_t *mg_uecc_curve_n(MG_UECC_Curve curve);\nconst mg_uecc_word_t *mg_uecc_curve_G(MG_UECC_Curve curve);\nconst mg_uecc_word_t *mg_uecc_curve_b(MG_UECC_Curve curve);\n\nint mg_uecc_valid_point(const mg_uecc_word_t *point, MG_UECC_Curve curve);\n\n/* Multiplies a point by a scalar. Points are represented by the X coordinate\n   followed by the Y coordinate in the same array, both coordinates are\n   curve->num_words long. Note that scalar must be curve->num_n_words long (NOT\n   curve->num_words). */\nvoid mg_uecc_point_mult(mg_uecc_word_t *result, const mg_uecc_word_t *point,\n                        const mg_uecc_word_t *scalar, MG_UECC_Curve curve);\n\n/* Generates a random integer in the range 0 < random < top.\n   Both random and top have num_words words. */\nint mg_uecc_generate_random_int(mg_uecc_word_t *random,\n                                const mg_uecc_word_t *top,\n                                wordcount_t num_words);\n\n#endif /* MG_UECC_ENABLE_VLI_API */\n\n#ifdef __cplusplus\n} /* end of extern \"C\" */\n#endif\n\n#endif /* _UECC_VLI_H_ */\n\n// End of uecc BSD-2\n// portable8439 v1.0.1\n// Source: https://github.com/DavyLandman/portable8439\n// Licensed under CC0-1.0\n// Contains poly1305-donna e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781 (Public\n// Domain)\n\n\n\n\n#ifndef __PORTABLE_8439_H\n#define __PORTABLE_8439_H\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n// provide your own decl specificier like -DPORTABLE_8439_DECL=ICACHE_RAM_ATTR\n#ifndef PORTABLE_8439_DECL\n#define PORTABLE_8439_DECL\n#endif\n\n/*\n This library implements RFC 8439 a.k.a. ChaCha20-Poly1305 AEAD\n\n You can use this library to avoid attackers mutating or reusing your\n encrypted messages. This does assume you never reuse a nonce+key pair and,\n if possible, carefully pick your associated data.\n*/\n\n/* Make sure we are either nested in C++ or running in a C99+ compiler\n#if !defined(__cplusplus) && !defined(_MSC_VER) && \\\n    (!defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L)\n#error \"C99 or newer required\"\n#endif */\n\n// #if CHAR_BIT > 8\n// #    error \"Systems without native octals not suppoted\"\n// #endif\n\n#if defined(_MSC_VER) || defined(__cplusplus)\n// add restrict support is possible\n#if (defined(_MSC_VER) && _MSC_VER >= 1900) || defined(__clang__) || \\\n    defined(__GNUC__)\n#define restrict __restrict\n#else\n#define restrict\n#endif\n#endif\n\n#define RFC_8439_TAG_SIZE (16)\n#define RFC_8439_KEY_SIZE (32)\n#define RFC_8439_NONCE_SIZE (12)\n\n/*\n    Encrypt/Seal plain text bytes into a cipher text that can only be\n    decrypted by knowing the key, nonce and associated data.\n\n    input:\n        - key: RFC_8439_KEY_SIZE bytes that all parties have agreed\n            upon beforehand\n        - nonce: RFC_8439_NONCE_SIZE bytes that should never be repeated\n            for the same key. A counter or a pseudo-random value are fine.\n        - ad: associated data to include with calculating the tag of the\n            cipher text. Can be null for empty.\n        - plain_text: data to be encrypted, pointer + size should not overlap\n            with cipher_text pointer\n\n    output:\n        - cipher_text: encrypted plain_text with a tag appended. Make sure to\n            allocate at least plain_text_size + RFC_8439_TAG_SIZE\n\n    returns:\n        - size of bytes written to cipher_text, can be -1 if overlapping\n            pointers are passed for plain_text and cipher_text\n*/\nPORTABLE_8439_DECL size_t mg_chacha20_poly1305_encrypt(\n    uint8_t *restrict cipher_text, const uint8_t key[RFC_8439_KEY_SIZE],\n    const uint8_t nonce[RFC_8439_NONCE_SIZE], const uint8_t *restrict ad,\n    size_t ad_size, const uint8_t *restrict plain_text, size_t plain_text_size);\n\n/*\n    Decrypt/unseal cipher text given the right key, nonce, and additional data.\n\n    input:\n        - key: RFC_8439_KEY_SIZE bytes that all parties have agreed\n            upon beforehand\n        - nonce: RFC_8439_NONCE_SIZE bytes that should never be repeated for\n            the same key. A counter or a pseudo-random value are fine.\n        - ad: associated data to include with calculating the tag of the\n            cipher text. Can be null for empty.\n        - cipher_text: encrypted message.\n\n    output:\n        - plain_text: data to be encrypted, pointer + size should not overlap\n            with cipher_text pointer, leave at least enough room for\n            cipher_text_size - RFC_8439_TAG_SIZE\n\n    returns:\n        - size of bytes written to plain_text, -1 signals either:\n            - incorrect key/nonce/ad\n            - corrupted cipher_text\n            - overlapping pointers are passed for plain_text and cipher_text\n*/\nPORTABLE_8439_DECL size_t mg_chacha20_poly1305_decrypt(\n    uint8_t *restrict plain_text, const uint8_t key[RFC_8439_KEY_SIZE],\n    const uint8_t nonce[RFC_8439_NONCE_SIZE],\n    const uint8_t *restrict cipher_text, size_t cipher_text_size);\n#if defined(__cplusplus)\n}\n#endif\n#endif\n\n\nstruct mg_connection;\ntypedef void (*mg_event_handler_t)(struct mg_connection *, int ev,\n                                   void *ev_data);\nvoid mg_call(struct mg_connection *c, int ev, void *ev_data);\nvoid mg_error(struct mg_connection *c, const char *fmt, ...);\n\nenum {\n  MG_EV_ERROR,      // Error                        char *error_message\n  MG_EV_OPEN,       // Connection created           NULL\n  MG_EV_POLL,       // mg_mgr_poll iteration        uint64_t *uptime_millis\n  MG_EV_RESOLVE,    // Host name is resolved        NULL\n  MG_EV_CONNECT,    // Connection established       NULL\n  MG_EV_ACCEPT,     // Connection accepted          NULL\n  MG_EV_TLS_HS,     // TLS handshake succeeded      NULL\n  MG_EV_READ,       // Data received from socket    long *bytes_read\n  MG_EV_WRITE,      // Data written to socket       long *bytes_written\n  MG_EV_CLOSE,      // Connection closed            NULL\n  MG_EV_HTTP_HDRS,  // HTTP headers                 struct mg_http_message *\n  MG_EV_HTTP_MSG,   // Full HTTP request/response   struct mg_http_message *\n  MG_EV_WS_OPEN,    // Websocket handshake done     struct mg_http_message *\n  MG_EV_WS_MSG,     // Websocket msg, text or bin   struct mg_ws_message *\n  MG_EV_WS_CTL,     // Websocket control msg        struct mg_ws_message *\n  MG_EV_MQTT_CMD,   // MQTT low-level command       struct mg_mqtt_message *\n  MG_EV_MQTT_MSG,   // MQTT PUBLISH received        struct mg_mqtt_message *\n  MG_EV_MQTT_OPEN,  // MQTT CONNACK received        int *connack_status_code\n  MG_EV_SNTP_TIME,  // SNTP time received           uint64_t *epoch_millis\n  MG_EV_WAKEUP,     // mg_wakeup() data received    struct mg_str *data\n  MG_EV_USER        // Starting ID for user events\n};\n\n\n\n\n\n\n\n\n\n\nstruct mg_dns {\n  const char *url;          // DNS server URL\n  struct mg_connection *c;  // DNS server connection\n};\n\nstruct mg_addr {\n  uint8_t ip[16];    // Holds IPv4 or IPv6 address, in network byte order\n  uint16_t port;     // TCP or UDP port in network byte order\n  uint8_t scope_id;  // IPv6 scope ID\n  bool is_ip6;       // True when address is IPv6 address\n};\n\nstruct mg_mgr {\n  struct mg_connection *conns;  // List of active connections\n  struct mg_dns dns4;           // DNS for IPv4\n  struct mg_dns dns6;           // DNS for IPv6\n  int dnstimeout;               // DNS resolve timeout in milliseconds\n  bool use_dns6;                // Use DNS6 server by default, see #1532\n  unsigned long nextid;         // Next connection ID\n  unsigned long timerid;        // Next timer ID\n  void *userdata;               // Arbitrary user data pointer\n  void *tls_ctx;                // TLS context shared by all TLS sessions\n  uint16_t mqtt_id;             // MQTT IDs for pub/sub\n  void *active_dns_requests;    // DNS requests in progress\n  struct mg_timer *timers;      // Active timers\n  int epoll_fd;                 // Used when MG_EPOLL_ENABLE=1\n  struct mg_tcpip_if *ifp;      // Builtin TCP/IP stack only. Interface pointer\n  size_t extraconnsize;         // Builtin TCP/IP stack only. Extra space\n  MG_SOCKET_TYPE pipe;          // Socketpair end for mg_wakeup()\n#if MG_ENABLE_FREERTOS_TCP\n  SocketSet_t ss;  // NOTE(lsm): referenced from socket struct\n#endif\n};\n\nstruct mg_connection {\n  struct mg_connection *next;  // Linkage in struct mg_mgr :: connections\n  struct mg_mgr *mgr;          // Our container\n  struct mg_addr loc;          // Local address\n  struct mg_addr rem;          // Remote address\n  void *fd;                    // Connected socket, or LWIP data\n  unsigned long id;            // Auto-incrementing unique connection ID\n  struct mg_iobuf recv;        // Incoming data\n  struct mg_iobuf send;        // Outgoing data\n  struct mg_iobuf prof;        // Profile data enabled by MG_ENABLE_PROFILE\n  struct mg_iobuf rtls;        // TLS only. Incoming encrypted data\n  mg_event_handler_t fn;       // User-specified event handler function\n  void *fn_data;               // User-specified function parameter\n  mg_event_handler_t pfn;      // Protocol-specific handler function\n  void *pfn_data;              // Protocol-specific function parameter\n  char data[MG_DATA_SIZE];     // Arbitrary connection data\n  void *tls;                   // TLS specific data\n  unsigned is_listening : 1;   // Listening connection\n  unsigned is_client : 1;      // Outbound (client) connection\n  unsigned is_accepted : 1;    // Accepted (server) connection\n  unsigned is_resolving : 1;   // Non-blocking DNS resolution is in progress\n  unsigned is_arplooking : 1;  // Non-blocking ARP resolution is in progress\n  unsigned is_connecting : 1;  // Non-blocking connect is in progress\n  unsigned is_tls : 1;         // TLS-enabled connection\n  unsigned is_tls_hs : 1;      // TLS handshake is in progress\n  unsigned is_udp : 1;         // UDP connection\n  unsigned is_websocket : 1;   // WebSocket connection\n  unsigned is_mqtt5 : 1;       // For MQTT connection, v5 indicator\n  unsigned is_hexdumping : 1;  // Hexdump in/out traffic\n  unsigned is_draining : 1;    // Send remaining data, then close and free\n  unsigned is_closing : 1;     // Close and free the connection immediately\n  unsigned is_full : 1;        // Stop reads, until cleared\n  unsigned is_resp : 1;        // Response is still being generated\n  unsigned is_readable : 1;    // Connection is ready to read\n  unsigned is_writable : 1;    // Connection is ready to write\n};\n\nvoid mg_mgr_poll(struct mg_mgr *, int ms);\nvoid mg_mgr_init(struct mg_mgr *);\nvoid mg_mgr_free(struct mg_mgr *);\n\nstruct mg_connection *mg_listen(struct mg_mgr *, const char *url,\n                                mg_event_handler_t fn, void *fn_data);\nstruct mg_connection *mg_connect(struct mg_mgr *, const char *url,\n                                 mg_event_handler_t fn, void *fn_data);\nstruct mg_connection *mg_wrapfd(struct mg_mgr *mgr, int fd,\n                                mg_event_handler_t fn, void *fn_data);\nvoid mg_connect_resolved(struct mg_connection *);\nbool mg_send(struct mg_connection *, const void *, size_t);\nsize_t mg_printf(struct mg_connection *, const char *fmt, ...);\nsize_t mg_vprintf(struct mg_connection *, const char *fmt, va_list *ap);\nbool mg_aton(struct mg_str str, struct mg_addr *addr);\n\n// These functions are used to integrate with custom network stacks\nstruct mg_connection *mg_alloc_conn(struct mg_mgr *);\nvoid mg_close_conn(struct mg_connection *c);\nbool mg_open_listener(struct mg_connection *c, const char *url);\n\n// Utility functions\nbool mg_wakeup(struct mg_mgr *, unsigned long id, const void *buf, size_t len);\nbool mg_wakeup_init(struct mg_mgr *);\nstruct mg_timer *mg_timer_add(struct mg_mgr *mgr, uint64_t milliseconds,\n                              unsigned flags, void (*fn)(void *), void *arg);\n\n\n\n\n\n\n\n\nstruct mg_http_header {\n  struct mg_str name;   // Header name\n  struct mg_str value;  // Header value\n};\n\nstruct mg_http_message {\n  struct mg_str method, uri, query, proto;             // Request/response line\n  struct mg_http_header headers[MG_MAX_HTTP_HEADERS];  // Headers\n  struct mg_str body;                                  // Body\n  struct mg_str head;                                  // Request + headers\n  struct mg_str message;  // Request + headers + body\n};\n\n// Parameter for mg_http_serve_dir()\nstruct mg_http_serve_opts {\n  const char *root_dir;       // Web root directory, must be non-NULL\n  const char *ssi_pattern;    // SSI file name pattern, e.g. #.shtml\n  const char *extra_headers;  // Extra HTTP headers to add in responses\n  const char *mime_types;     // Extra mime types, ext1=type1,ext2=type2,..\n  const char *page404;        // Path to the 404 page, or NULL by default\n  struct mg_fs *fs;           // Filesystem implementation. Use NULL for POSIX\n};\n\n// Parameter for mg_http_next_multipart\nstruct mg_http_part {\n  struct mg_str name;      // Form field name\n  struct mg_str filename;  // Filename for file uploads\n  struct mg_str body;      // Part contents\n};\n\nint mg_http_parse(const char *s, size_t len, struct mg_http_message *);\nint mg_http_get_request_len(const unsigned char *buf, size_t buf_len);\nvoid mg_http_printf_chunk(struct mg_connection *cnn, const char *fmt, ...);\nvoid mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len);\nvoid mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm);\nstruct mg_connection *mg_http_listen(struct mg_mgr *, const char *url,\n                                     mg_event_handler_t fn, void *fn_data);\nstruct mg_connection *mg_http_connect(struct mg_mgr *, const char *url,\n                                      mg_event_handler_t fn, void *fn_data);\nvoid mg_http_serve_dir(struct mg_connection *, struct mg_http_message *hm,\n                       const struct mg_http_serve_opts *);\nvoid mg_http_serve_file(struct mg_connection *, struct mg_http_message *hm,\n                        const char *path, const struct mg_http_serve_opts *);\nvoid mg_http_reply(struct mg_connection *, int status_code, const char *headers,\n                   const char *body_fmt, ...);\nstruct mg_str *mg_http_get_header(struct mg_http_message *, const char *name);\nstruct mg_str mg_http_var(struct mg_str buf, struct mg_str name);\nint mg_http_get_var(const struct mg_str *, const char *name, char *, size_t);\nint mg_url_decode(const char *s, size_t n, char *to, size_t to_len, int form);\nsize_t mg_url_encode(const char *s, size_t n, char *buf, size_t len);\nvoid mg_http_creds(struct mg_http_message *, char *, size_t, char *, size_t);\nlong mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                    struct mg_fs *fs, const char *dir, size_t max_size);\nvoid mg_http_bauth(struct mg_connection *, const char *user, const char *pass);\nstruct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v);\nsize_t mg_http_next_multipart(struct mg_str, size_t, struct mg_http_part *);\nint mg_http_status(const struct mg_http_message *hm);\nvoid mg_hello(const char *url);\n\n\nvoid mg_http_serve_ssi(struct mg_connection *c, const char *root,\n                       const char *fullpath);\n\n\n#define MG_TLS_NONE 0     // No TLS support\n#define MG_TLS_MBED 1     // mbedTLS\n#define MG_TLS_OPENSSL 2  // OpenSSL\n#define MG_TLS_WOLFSSL 5  // WolfSSL (based on OpenSSL)\n#define MG_TLS_BUILTIN 3  // Built-in\n#define MG_TLS_CUSTOM 4   // Custom implementation\n\n#ifndef MG_TLS\n#define MG_TLS MG_TLS_NONE\n#endif\n\n\n\n\n\nstruct mg_tls_opts {\n  struct mg_str ca;       // PEM or DER\n  struct mg_str cert;     // PEM or DER\n  struct mg_str key;      // PEM or DER\n  struct mg_str name;     // If not empty, enable host name verification\n  int skip_verification;  // Skip certificate and host name verification\n};\n\nvoid mg_tls_init(struct mg_connection *, const struct mg_tls_opts *opts);\nvoid mg_tls_free(struct mg_connection *);\nlong mg_tls_send(struct mg_connection *, const void *buf, size_t len);\nlong mg_tls_recv(struct mg_connection *, void *buf, size_t len);\nsize_t mg_tls_pending(struct mg_connection *);\nvoid mg_tls_handshake(struct mg_connection *);\n\n// Private\nvoid mg_tls_ctx_init(struct mg_mgr *);\nvoid mg_tls_ctx_free(struct mg_mgr *);\n\n// Low-level IO primives used by TLS layer\nenum { MG_IO_ERR = -1, MG_IO_WAIT = -2, MG_IO_RESET = -3 };\nlong mg_io_send(struct mg_connection *c, const void *buf, size_t len);\nlong mg_io_recv(struct mg_connection *c, void *buf, size_t len);\n\n\n\n\n\n\n\n#if MG_TLS == MG_TLS_MBED\n#include <mbedtls/debug.h>\n#include <mbedtls/net_sockets.h>\n#include <mbedtls/ssl.h>\n#include <mbedtls/ssl_ticket.h>\n\nstruct mg_tls_ctx {\n  int dummy;\n#ifdef MBEDTLS_SSL_SESSION_TICKETS\n  mbedtls_ssl_ticket_context tickets;\n#endif\n};\n\nstruct mg_tls {\n  mbedtls_x509_crt ca;      // Parsed CA certificate\n  mbedtls_x509_crt cert;    // Parsed certificate\n  mbedtls_pk_context pk;    // Private key context\n  mbedtls_ssl_context ssl;  // SSL/TLS context\n  mbedtls_ssl_config conf;  // SSL-TLS config\n#ifdef MBEDTLS_SSL_SESSION_TICKETS\n  mbedtls_ssl_ticket_context ticket;  // Session tickets context\n#endif\n};\n#endif\n\n\n#if MG_TLS == MG_TLS_OPENSSL || MG_TLS == MG_TLS_WOLFSSL\n\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n\nstruct mg_tls {\n  BIO_METHOD *bm;\n  SSL_CTX *ctx;\n  SSL *ssl;\n};\n#endif\n\n\n#define WEBSOCKET_OP_CONTINUE 0\n#define WEBSOCKET_OP_TEXT 1\n#define WEBSOCKET_OP_BINARY 2\n#define WEBSOCKET_OP_CLOSE 8\n#define WEBSOCKET_OP_PING 9\n#define WEBSOCKET_OP_PONG 10\n\n\n\nstruct mg_ws_message {\n  struct mg_str data;  // Websocket message data\n  uint8_t flags;       // Websocket message flags\n};\n\nstruct mg_connection *mg_ws_connect(struct mg_mgr *, const char *url,\n                                    mg_event_handler_t fn, void *fn_data,\n                                    const char *fmt, ...);\nvoid mg_ws_upgrade(struct mg_connection *, struct mg_http_message *,\n                   const char *fmt, ...);\nsize_t mg_ws_send(struct mg_connection *, const void *buf, size_t len, int op);\nsize_t mg_ws_wrap(struct mg_connection *, size_t len, int op);\nsize_t mg_ws_printf(struct mg_connection *c, int op, const char *fmt, ...);\nsize_t mg_ws_vprintf(struct mg_connection *c, int op, const char *fmt,\n                     va_list *);\n\n\n\n\nstruct mg_connection *mg_sntp_connect(struct mg_mgr *mgr, const char *url,\n                                      mg_event_handler_t fn, void *fn_data);\nvoid mg_sntp_request(struct mg_connection *c);\nint64_t mg_sntp_parse(const unsigned char *buf, size_t len);\n\nuint64_t mg_now(void);     // Return milliseconds since Epoch\n\n\n\n\n\n#define MQTT_CMD_CONNECT 1\n#define MQTT_CMD_CONNACK 2\n#define MQTT_CMD_PUBLISH 3\n#define MQTT_CMD_PUBACK 4\n#define MQTT_CMD_PUBREC 5\n#define MQTT_CMD_PUBREL 6\n#define MQTT_CMD_PUBCOMP 7\n#define MQTT_CMD_SUBSCRIBE 8\n#define MQTT_CMD_SUBACK 9\n#define MQTT_CMD_UNSUBSCRIBE 10\n#define MQTT_CMD_UNSUBACK 11\n#define MQTT_CMD_PINGREQ 12\n#define MQTT_CMD_PINGRESP 13\n#define MQTT_CMD_DISCONNECT 14\n#define MQTT_CMD_AUTH 15\n\n#define MQTT_PROP_PAYLOAD_FORMAT_INDICATOR 0x01\n#define MQTT_PROP_MESSAGE_EXPIRY_INTERVAL 0x02\n#define MQTT_PROP_CONTENT_TYPE 0x03\n#define MQTT_PROP_RESPONSE_TOPIC 0x08\n#define MQTT_PROP_CORRELATION_DATA 0x09\n#define MQTT_PROP_SUBSCRIPTION_IDENTIFIER 0x0B\n#define MQTT_PROP_SESSION_EXPIRY_INTERVAL 0x11\n#define MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER 0x12\n#define MQTT_PROP_SERVER_KEEP_ALIVE 0x13\n#define MQTT_PROP_AUTHENTICATION_METHOD 0x15\n#define MQTT_PROP_AUTHENTICATION_DATA 0x16\n#define MQTT_PROP_REQUEST_PROBLEM_INFORMATION 0x17\n#define MQTT_PROP_WILL_DELAY_INTERVAL 0x18\n#define MQTT_PROP_REQUEST_RESPONSE_INFORMATION 0x19\n#define MQTT_PROP_RESPONSE_INFORMATION 0x1A\n#define MQTT_PROP_SERVER_REFERENCE 0x1C\n#define MQTT_PROP_REASON_STRING 0x1F\n#define MQTT_PROP_RECEIVE_MAXIMUM 0x21\n#define MQTT_PROP_TOPIC_ALIAS_MAXIMUM 0x22\n#define MQTT_PROP_TOPIC_ALIAS 0x23\n#define MQTT_PROP_MAXIMUM_QOS 0x24\n#define MQTT_PROP_RETAIN_AVAILABLE 0x25\n#define MQTT_PROP_USER_PROPERTY 0x26\n#define MQTT_PROP_MAXIMUM_PACKET_SIZE 0x27\n#define MQTT_PROP_WILDCARD_SUBSCRIPTION_AVAILABLE 0x28\n#define MQTT_PROP_SUBSCRIPTION_IDENTIFIER_AVAILABLE 0x29\n#define MQTT_PROP_SHARED_SUBSCRIPTION_AVAILABLE 0x2A\n\nenum {\n  MQTT_PROP_TYPE_BYTE,\n  MQTT_PROP_TYPE_STRING,\n  MQTT_PROP_TYPE_STRING_PAIR,\n  MQTT_PROP_TYPE_BINARY_DATA,\n  MQTT_PROP_TYPE_VARIABLE_INT,\n  MQTT_PROP_TYPE_INT,\n  MQTT_PROP_TYPE_SHORT\n};\n\nenum { MQTT_OK, MQTT_INCOMPLETE, MQTT_MALFORMED };\n\nstruct mg_mqtt_prop {\n  uint8_t id;         // Enumerated at MQTT5 Reference\n  uint32_t iv;        // Integer value for 8-, 16-, 32-bit integers types\n  struct mg_str key;  // Non-NULL only for user property type\n  struct mg_str val;  // Non-NULL only for UTF-8 types and user properties\n};\n\nstruct mg_mqtt_opts {\n  struct mg_str user;               // Username, can be empty\n  struct mg_str pass;               // Password, can be empty\n  struct mg_str client_id;          // Client ID\n  struct mg_str topic;              // message/subscription topic\n  struct mg_str message;            // message content\n  uint8_t qos;                      // message quality of service\n  uint8_t version;                  // Can be 4 (3.1.1), or 5. If 0, assume 4\n  uint16_t keepalive;               // Keep-alive timer in seconds\n  uint16_t retransmit_id;           // For PUBLISH, init to 0\n  bool retain;                      // Retain flag\n  bool clean;                       // Clean session flag\n  struct mg_mqtt_prop *props;       // MQTT5 props array\n  size_t num_props;                 // number of props\n  struct mg_mqtt_prop *will_props;  // Valid only for CONNECT packet (MQTT5)\n  size_t num_will_props;            // Number of will props\n};\n\nstruct mg_mqtt_message {\n  struct mg_str topic;  // Parsed topic for PUBLISH\n  struct mg_str data;   // Parsed message for PUBLISH\n  struct mg_str dgram;  // Whole MQTT packet, including headers\n  uint16_t id;          // For PUBACK, PUBREC, PUBREL, PUBCOMP, SUBACK, PUBLISH\n  uint8_t cmd;          // MQTT command, one of MQTT_CMD_*\n  uint8_t qos;          // Quality of service\n  uint8_t ack;          // CONNACK return code, 0 = success\n  size_t props_start;   // Offset to the start of the properties (MQTT5)\n  size_t props_size;    // Length of the properties\n};\n\nstruct mg_connection *mg_mqtt_connect(struct mg_mgr *, const char *url,\n                                      const struct mg_mqtt_opts *opts,\n                                      mg_event_handler_t fn, void *fn_data);\nstruct mg_connection *mg_mqtt_listen(struct mg_mgr *mgr, const char *url,\n                                     mg_event_handler_t fn, void *fn_data);\nvoid mg_mqtt_login(struct mg_connection *c, const struct mg_mqtt_opts *opts);\nuint16_t mg_mqtt_pub(struct mg_connection *c, const struct mg_mqtt_opts *opts);\nvoid mg_mqtt_sub(struct mg_connection *, const struct mg_mqtt_opts *opts);\nint mg_mqtt_parse(const uint8_t *, size_t, uint8_t, struct mg_mqtt_message *);\nvoid mg_mqtt_send_header(struct mg_connection *, uint8_t cmd, uint8_t flags,\n                         uint32_t len);\nvoid mg_mqtt_ping(struct mg_connection *);\nvoid mg_mqtt_pong(struct mg_connection *);\nvoid mg_mqtt_disconnect(struct mg_connection *, const struct mg_mqtt_opts *);\nsize_t mg_mqtt_next_prop(struct mg_mqtt_message *, struct mg_mqtt_prop *,\n                         size_t ofs);\n\n\n\n\n\n// Mongoose sends DNS queries that contain only one question:\n// either A (IPv4) or AAAA (IPv6) address lookup.\n// Therefore, we expect zero or one answer.\n// If `resolved` is true, then `addr` contains resolved IPv4 or IPV6 address.\nstruct mg_dns_message {\n  uint16_t txnid;       // Transaction ID\n  bool resolved;        // Resolve successful, addr is set\n  struct mg_addr addr;  // Resolved address\n  char name[256];       // Host name\n};\n\nstruct mg_dns_header {\n  uint16_t txnid;  // Transaction ID\n  uint16_t flags;\n  uint16_t num_questions;\n  uint16_t num_answers;\n  uint16_t num_authority_prs;\n  uint16_t num_other_prs;\n};\n\n// DNS resource record\nstruct mg_dns_rr {\n  uint16_t nlen;    // Name or pointer length\n  uint16_t atype;   // Address type\n  uint16_t aclass;  // Address class\n  uint16_t alen;    // Address length\n};\n\nvoid mg_resolve(struct mg_connection *, const char *url);\nvoid mg_resolve_cancel(struct mg_connection *);\nbool mg_dns_parse(const uint8_t *buf, size_t len, struct mg_dns_message *);\nsize_t mg_dns_parse_rr(const uint8_t *buf, size_t len, size_t ofs,\n                       bool is_question, struct mg_dns_rr *);\n\n\n\n\n\n#ifndef MG_JSON_MAX_DEPTH\n#define MG_JSON_MAX_DEPTH 30\n#endif\n\n// Error return values - negative. Successful returns are >= 0\nenum { MG_JSON_TOO_DEEP = -1, MG_JSON_INVALID = -2, MG_JSON_NOT_FOUND = -3 };\nint mg_json_get(struct mg_str json, const char *path, int *toklen);\n\nstruct mg_str mg_json_get_tok(struct mg_str json, const char *path);\nbool mg_json_get_num(struct mg_str json, const char *path, double *v);\nbool mg_json_get_bool(struct mg_str json, const char *path, bool *v);\nlong mg_json_get_long(struct mg_str json, const char *path, long dflt);\nchar *mg_json_get_str(struct mg_str json, const char *path);\nchar *mg_json_get_hex(struct mg_str json, const char *path, int *len);\nchar *mg_json_get_b64(struct mg_str json, const char *path, int *len);\n\nbool mg_json_unescape(struct mg_str str, char *buf, size_t len);\nsize_t mg_json_next(struct mg_str obj, size_t ofs, struct mg_str *key,\n                    struct mg_str *val);\n\n\n\n\n// JSON-RPC request descriptor\nstruct mg_rpc_req {\n  struct mg_rpc **head;  // RPC handlers list head\n  struct mg_rpc *rpc;    // RPC handler being called\n  mg_pfn_t pfn;          // Response printing function\n  void *pfn_data;        // Response printing function data\n  void *req_data;        // Arbitrary request data\n  struct mg_str frame;   // Request, e.g. {\"id\":1,\"method\":\"add\",\"params\":[1,2]}\n};\n\n// JSON-RPC method handler\nstruct mg_rpc {\n  struct mg_rpc *next;              // Next in list\n  struct mg_str method;             // Method pattern\n  void (*fn)(struct mg_rpc_req *);  // Handler function\n  void *fn_data;                    // Handler function argument\n};\n\nvoid mg_rpc_add(struct mg_rpc **head, struct mg_str method_pattern,\n                void (*handler)(struct mg_rpc_req *), void *handler_data);\nvoid mg_rpc_del(struct mg_rpc **head, void (*handler)(struct mg_rpc_req *));\nvoid mg_rpc_process(struct mg_rpc_req *);\n\n// Helper functions to print result or error frame\nvoid mg_rpc_ok(struct mg_rpc_req *, const char *fmt, ...);\nvoid mg_rpc_vok(struct mg_rpc_req *, const char *fmt, va_list *ap);\nvoid mg_rpc_err(struct mg_rpc_req *, int code, const char *fmt, ...);\nvoid mg_rpc_verr(struct mg_rpc_req *, int code, const char *fmt, va_list *);\nvoid mg_rpc_list(struct mg_rpc_req *r);\n// Copyright (c) 2023 Cesanta Software Limited\n// All rights reserved\n\n\n\n\n\n#define MG_OTA_NONE 0       // No OTA support\n#define MG_OTA_STM32H5 1    // STM32 H5\n#define MG_OTA_STM32H7 2    // STM32 H7\n#define MG_OTA_STM32H7_DUAL_CORE 3 // STM32 H7 dual core\n#define MG_OTA_STM32F  4    // STM32 F7/F4/F2\n#define MG_OTA_CH32V307 100 // WCH CH32V307\n#define MG_OTA_U2A 200      // Renesas U2A16, U2A8, U2A6\n#define MG_OTA_RT1020 300   // IMXRT1020\n#define MG_OTA_RT1060 301   // IMXRT1060\n#define MG_OTA_RT1064 302   // IMXRT1064\n#define MG_OTA_RT1170 303   // IMXRT1170\n#define MG_OTA_MCXN 310 \t  // MCXN947\n#define MG_OTA_FLASH 900    // OTA via an internal flash\n#define MG_OTA_ESP32 910    // ESP32 OTA implementation\n#define MG_OTA_PICOSDK 920  // RP2040/2350 using Pico-SDK hardware_flash\n#define MG_OTA_CUSTOM 1000  // Custom implementation\n\n#ifndef MG_OTA\n#define MG_OTA MG_OTA_NONE\n#else\n#ifndef MG_IRAM\n#if defined(__GNUC__)\n#define MG_IRAM __attribute__((noinline, section(\".iram\")))\n#else\n#define MG_IRAM\n#endif // compiler\n#endif // IRAM\n#endif // OTA\n\n// Firmware update API\nbool mg_ota_begin(size_t new_firmware_size);     // Start writing\nbool mg_ota_write(const void *buf, size_t len);  // Write chunk, aligned to 1k\nbool mg_ota_end(void);                           // Stop writing\n\n\n\n#if MG_OTA != MG_OTA_NONE && MG_OTA != MG_OTA_CUSTOM\n\nstruct mg_flash {\n  void *start;    // Address at which flash starts\n  size_t size;    // Flash size\n  size_t secsz;   // Sector size\n  size_t align;   // Write alignment\n  bool (*write_fn)(void *, const void *, size_t);  // Write function\n  bool (*swap_fn)(void);                           // Swap partitions\n};\n\nbool mg_ota_flash_begin(size_t new_firmware_size, struct mg_flash *flash);\nbool mg_ota_flash_write(const void *buf, size_t len, struct mg_flash *flash);\nbool mg_ota_flash_end(struct mg_flash *flash);\n\n#endif\n\n\n\n\n\n\n\nstruct mg_tcpip_if;  // Mongoose TCP/IP network interface\n\nstruct mg_tcpip_driver {\n  bool (*init)(struct mg_tcpip_if *);                         // Init driver\n  size_t (*tx)(const void *, size_t, struct mg_tcpip_if *);   // Transmit frame\n  size_t (*rx)(void *buf, size_t len, struct mg_tcpip_if *);  // Receive frame\n  bool (*up)(struct mg_tcpip_if *);                           // Up/down status\n};\n\ntypedef void (*mg_tcpip_event_handler_t)(struct mg_tcpip_if *ifp, int ev,\n                                         void *ev_data);\n\nenum {\n  MG_TCPIP_EV_ST_CHG,     // state change             uint8_t * (&ifp->state)\n  MG_TCPIP_EV_DHCP_DNS,   // DHCP DNS assignment      uint32_t *ipaddr\n  MG_TCPIP_EV_DHCP_SNTP,  // DHCP SNTP assignment     uint32_t *ipaddr\n  MG_TCPIP_EV_ARP,        // Got ARP packet           struct mg_str *\n  MG_TCPIP_EV_TIMER_1S,   // 1 second timer           NULL\n  MG_TCPIP_EV_USER        // Starting ID for user events\n};\n\n// Network interface\nstruct mg_tcpip_if {\n  uint8_t mac[6];                  // MAC address. Must be set to a valid MAC\n  uint32_t ip, mask, gw;           // IP address, mask, default gateway\n  struct mg_str tx;                // Output (TX) buffer\n  bool enable_dhcp_client;         // Enable DCHP client\n  bool enable_dhcp_server;         // Enable DCHP server\n  bool enable_get_gateway;         // DCHP server sets client as gateway\n  bool enable_req_dns;             // DCHP client requests DNS server\n  bool enable_req_sntp;            // DCHP client requests SNTP server\n  bool enable_crc32_check;         // Do a CRC check on RX frames and strip it\n  bool enable_mac_check;           // Do a MAC check on RX frames\n  struct mg_tcpip_driver *driver;  // Low level driver\n  void *driver_data;               // Driver-specific data\n  mg_tcpip_event_handler_t fn;     // User-specified event handler function\n  struct mg_mgr *mgr;              // Mongoose event manager\n  struct mg_queue recv_queue;      // Receive queue\n  uint16_t mtu;                    // Interface MTU\n#define MG_TCPIP_MTU_DEFAULT 1500\n\n  // Internal state, user can use it but should not change it\n  uint8_t gwmac[6];             // Router's MAC\n  uint64_t now;                 // Current time\n  uint64_t timer_1000ms;        // 1000 ms timer: for DHCP and link state\n  uint64_t lease_expire;        // Lease expiration time, in ms\n  uint16_t eport;               // Next ephemeral port\n  volatile uint32_t ndrop;      // Number of received, but dropped frames\n  volatile uint32_t nrecv;      // Number of received frames\n  volatile uint32_t nsent;      // Number of transmitted frames\n  volatile uint32_t nerr;       // Number of driver errors\n  uint8_t state;                // Current state\n#define MG_TCPIP_STATE_DOWN 0   // Interface is down\n#define MG_TCPIP_STATE_UP 1     // Interface is up\n#define MG_TCPIP_STATE_REQ 2    // Interface is up, DHCP REQUESTING state\n#define MG_TCPIP_STATE_IP 3     // Interface is up and has an IP assigned\n#define MG_TCPIP_STATE_READY 4  // Interface has fully come up, ready to work\n};\n\nvoid mg_tcpip_init(struct mg_mgr *, struct mg_tcpip_if *);\nvoid mg_tcpip_free(struct mg_tcpip_if *);\nvoid mg_tcpip_qwrite(void *buf, size_t len, struct mg_tcpip_if *ifp);\nvoid mg_tcpip_arp_request(struct mg_tcpip_if *ifp, uint32_t ip, uint8_t *mac);\n\nextern struct mg_tcpip_driver mg_tcpip_driver_stm32f;\nextern struct mg_tcpip_driver mg_tcpip_driver_w5500;\nextern struct mg_tcpip_driver mg_tcpip_driver_tm4c;\nextern struct mg_tcpip_driver mg_tcpip_driver_tms570;\nextern struct mg_tcpip_driver mg_tcpip_driver_stm32h;\nextern struct mg_tcpip_driver mg_tcpip_driver_imxrt;\nextern struct mg_tcpip_driver mg_tcpip_driver_same54;\nextern struct mg_tcpip_driver mg_tcpip_driver_cmsis;\nextern struct mg_tcpip_driver mg_tcpip_driver_ra;\nextern struct mg_tcpip_driver mg_tcpip_driver_xmc;\nextern struct mg_tcpip_driver mg_tcpip_driver_xmc7;\nextern struct mg_tcpip_driver mg_tcpip_driver_ppp;\nextern struct mg_tcpip_driver mg_tcpip_driver_pico_w;\n\n// Drivers that require SPI, can use this SPI abstraction\nstruct mg_tcpip_spi {\n  void *spi;                        // Opaque SPI bus descriptor\n  void (*begin)(void *);            // SPI begin: slave select low\n  void (*end)(void *);              // SPI end: slave select high\n  uint8_t (*txn)(void *, uint8_t);  // SPI transaction: write 1 byte, read reply\n};\n\n\n\n// Macros to record timestamped events that happens with a connection.\n// They are saved into a c->prof IO buffer, each event is a name and a 32-bit\n// timestamp in milliseconds since connection init time.\n//\n// Test (run in two separate terminals):\n//   make -C examples/http-server/ CFLAGS_EXTRA=-DMG_ENABLE_PROFILE=1\n//   curl localhost:8000\n// Output:\n//   1ea1f1e7 2 net.c:150:mg_close_conn      3 profile:                                                            \n//   1ea1f1e8 2 net.c:150:mg_close_conn      1ea1f1e6 init                                                         \n//   1ea1f1e8 2 net.c:150:mg_close_conn          0 EV_OPEN\n//   1ea1f1e8 2 net.c:150:mg_close_conn          0 EV_ACCEPT \n//   1ea1f1e8 2 net.c:150:mg_close_conn          0 EV_READ\n//   1ea1f1e8 2 net.c:150:mg_close_conn          0 EV_HTTP_MSG\n//   1ea1f1e8 2 net.c:150:mg_close_conn          0 EV_WRITE\n//   1ea1f1e8 2 net.c:150:mg_close_conn          1 EV_CLOSE\n//\n// Usage:\n//   Enable profiling by setting MG_ENABLE_PROFILE=1\n//   Invoke MG_PROF_ADD(c, \"MY_EVENT_1\") in the places you'd like to measure\n\n#if MG_ENABLE_PROFILE\nstruct mg_profitem {\n  const char *name;    // Event name\n  uint32_t timestamp;  // Milliseconds since connection creation (MG_EV_OPEN)\n};\n\n#define MG_PROFILE_ALLOC_GRANULARITY 256  // Can save 32 items wih to realloc\n\n// Adding a profile item to the c->prof. Must be as fast as possible.\n// Reallocation of the c->prof iobuf is not desirable here, that's why we\n// pre-allocate c->prof with MG_PROFILE_ALLOC_GRANULARITY.\n// This macro just inits and copies 8 bytes, and calls mg_millis(),\n// which should be fast enough.\n#define MG_PROF_ADD(c, name_)                                             \\\n  do {                                                                    \\\n    struct mg_iobuf *io = &c->prof;                                       \\\n    uint32_t inittime = ((struct mg_profitem *) io->buf)->timestamp;      \\\n    struct mg_profitem item = {name_, (uint32_t) mg_millis() - inittime}; \\\n    mg_iobuf_add(io, io->len, &item, sizeof(item));                       \\\n  } while (0)\n\n// Initialising profile for a new connection. Not time sensitive\n#define MG_PROF_INIT(c)                                          \\\n  do {                                                           \\\n    struct mg_profitem first = {\"init\", (uint32_t) mg_millis()}; \\\n    mg_iobuf_init(&(c)->prof, 0, MG_PROFILE_ALLOC_GRANULARITY);  \\\n    mg_iobuf_add(&c->prof, c->prof.len, &first, sizeof(first));  \\\n  } while (0)\n\n#define MG_PROF_FREE(c) mg_iobuf_free(&(c)->prof)\n\n// Dumping the profile. Not time sensitive\n#define MG_PROF_DUMP(c)                                            \\\n  do {                                                             \\\n    struct mg_iobuf *io = &c->prof;                                \\\n    struct mg_profitem *p = (struct mg_profitem *) io->buf;        \\\n    struct mg_profitem *e = &p[io->len / sizeof(*p)];              \\\n    MG_INFO((\"%lu profile:\", c->id));                              \\\n    while (p < e) {                                                \\\n      MG_INFO((\"%5lx %s\", (unsigned long) p->timestamp, p->name)); \\\n      p++;                                                         \\\n    }                                                              \\\n  } while (0)\n\n#else\n#define MG_PROF_INIT(c)\n#define MG_PROF_FREE(c)\n#define MG_PROF_ADD(c, name)\n#define MG_PROF_DUMP(c)\n#endif\n\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_CMSIS) && MG_ENABLE_DRIVER_CMSIS\n\n#include \"Driver_ETH_MAC.h\"  // keep this include\n#include \"Driver_ETH_PHY.h\"  // keep this include\n\n#endif\n\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_IMXRT) && MG_ENABLE_DRIVER_IMXRT\n\nstruct mg_tcpip_driver_imxrt_data {\n  // MDC clock divider. MDC clock is derived from IPS Bus clock (ipg_clk),\n  // must not exceed 2.5MHz. Configuration for clock range 2.36~2.50 MHz\n  // 37.5.1.8.2, Table 37-46 : f = ipg_clk / (2(mdc_cr + 1))\n  //    ipg_clk       mdc_cr VALUE\n  //    --------------------------\n  //                  -1  <-- TODO() tell driver to guess the value\n  //    25 MHz         4\n  //    33 MHz         6\n  //    40 MHz         7\n  //    50 MHz         9\n  //    66 MHz        13\n  int mdc_cr;  // Valid values: -1 to 63\n\n  uint8_t phy_addr;  // PHY address\n};\n\n#ifndef MG_TCPIP_PHY_ADDR\n#define MG_TCPIP_PHY_ADDR 2\n#endif\n\n#ifndef MG_DRIVER_MDC_CR\n#define MG_DRIVER_MDC_CR 24\n#endif\n\n#define MG_TCPIP_DRIVER_INIT(mgr)                                \\\n  do {                                                           \\\n    static struct mg_tcpip_driver_imxrt_data driver_data_;       \\\n    static struct mg_tcpip_if mif_;                              \\\n    driver_data_.mdc_cr = MG_DRIVER_MDC_CR;                      \\\n    driver_data_.phy_addr = MG_TCPIP_PHY_ADDR;                   \\\n    mif_.ip = MG_TCPIP_IP;                                       \\\n    mif_.mask = MG_TCPIP_MASK;                                   \\\n    mif_.gw = MG_TCPIP_GW;                                       \\\n    mif_.driver = &mg_tcpip_driver_imxrt;                        \\\n    mif_.driver_data = &driver_data_;                            \\\n    MG_SET_MAC_ADDRESS(mif_.mac);                                \\\n    mg_tcpip_init(mgr, &mif_);                                   \\\n    MG_INFO((\"Driver: imxrt, MAC: %M\", mg_print_mac, mif_.mac)); \\\n  } while (0)\n\n#endif\n\n\n\n\nstruct mg_phy {\n  uint16_t (*read_reg)(uint8_t addr, uint8_t reg);\n  void (*write_reg)(uint8_t addr, uint8_t reg, uint16_t value);\n};\n\n// PHY configuration settings, bitmask\nenum {\n  // Set if PHY LEDs are connected to ground\n  MG_PHY_LEDS_ACTIVE_HIGH = (1 << 0),\n  // Set when PHY clocks MAC. Otherwise, MAC clocks PHY\n  MG_PHY_CLOCKS_MAC = (1 << 1),\n};\n\nenum { MG_PHY_SPEED_10M, MG_PHY_SPEED_100M, MG_PHY_SPEED_1000M };\n\nvoid mg_phy_init(struct mg_phy *, uint8_t addr, uint8_t config);\nbool mg_phy_up(struct mg_phy *, uint8_t addr, bool *full_duplex,\n               uint8_t *speed);\n\n\n#if MG_ENABLE_TCPIP && MG_ARCH == MG_ARCH_PICOSDK && \\\n    defined(MG_ENABLE_DRIVER_PICO_W) && MG_ENABLE_DRIVER_PICO_W\n\n#include \"cyw43.h\"              // keep this include\n#include \"pico/cyw43_arch.h\"    // keep this include\n#include \"pico/unique_id.h\"     // keep this include\n\nstruct mg_tcpip_driver_pico_w_data {\n  char *ssid;\n  char *pass;\n};\n\n#define MG_TCPIP_DRIVER_INIT(mgr)                                 \\\n  do {                                                            \\\n    static struct mg_tcpip_driver_pico_w_data driver_data_;       \\\n    static struct mg_tcpip_if mif_;                               \\\n    MG_SET_WIFI_CREDS(&driver_data_.ssid, &driver_data_.pass);    \\\n    mif_.ip = MG_TCPIP_IP;                                        \\\n    mif_.mask = MG_TCPIP_MASK;                                    \\\n    mif_.gw = MG_TCPIP_GW;                                        \\\n    mif_.driver = &mg_tcpip_driver_pico_w;                        \\\n    mif_.driver_data = &driver_data_;                             \\\n    mif_.recv_queue.size = 8192;                                  \\\n    mif_.mac[0] = 2; /* MAC read from OTP at driver init */       \\\n    mg_tcpip_init(mgr, &mif_);                                    \\\n    MG_INFO((\"Driver: pico-w, MAC: %M\", mg_print_mac, mif_.mac)); \\\n  } while (0)\n\n#endif\n\n\nstruct mg_tcpip_driver_ppp_data {\n  void *uart;                   // Opaque UART bus descriptor\n  void (*reset)(void *);        // Modem hardware reset\n  void (*tx)(void *, uint8_t);  // UART transmit single byte\n  int (*rx)(void *);            // UART receive single byte\n  const char **script;          // List of AT commands and expected replies\n  int script_index;             // Index of the current AT command in the list\n  uint64_t deadline;            // AT command deadline in ms\n};\n\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_RA) && MG_ENABLE_DRIVER_RA\n\nstruct mg_tcpip_driver_ra_data {\n  // MDC clock \"divider\". MDC clock is software generated,\n  uint32_t clock;    // core clock frequency in Hz\n  uint16_t irqno;    // IRQn, R_ICU->IELSR[irqno]\n  uint8_t phy_addr;  // PHY address\n};\n\n#endif\n\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_SAME54) && MG_ENABLE_DRIVER_SAME54\n\nstruct mg_tcpip_driver_same54_data {\n    int mdc_cr;\n};\n\n#ifndef MG_DRIVER_MDC_CR\n#define MG_DRIVER_MDC_CR 5\n#endif\n\n#endif\n\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_STM32F) && \\\n    MG_ENABLE_DRIVER_STM32F\n\nstruct mg_tcpip_driver_stm32f_data {\n  // MDC clock divider. MDC clock is derived from HCLK, must not exceed 2.5MHz\n  //    HCLK range    DIVIDER    mdc_cr VALUE\n  //    -------------------------------------\n  //                                -1  <-- tell driver to guess the value\n  //    60-100 MHz    HCLK/42        0\n  //    100-150 MHz   HCLK/62        1\n  //    20-35 MHz     HCLK/16        2\n  //    35-60 MHz     HCLK/26        3\n  //    150-216 MHz   HCLK/102       4  <-- value for Nucleo-F* on max speed\n  //    216-310 MHz   HCLK/124       5\n  //    110, 111 Reserved\n  int mdc_cr;  // Valid values: -1, 0, 1, 2, 3, 4, 5\n\n  uint8_t phy_addr;  // PHY address\n};\n\n#ifndef MG_TCPIP_PHY_ADDR\n#define MG_TCPIP_PHY_ADDR 0\n#endif\n\n#ifndef MG_DRIVER_MDC_CR\n#define MG_DRIVER_MDC_CR 4\n#endif\n\n#define MG_TCPIP_DRIVER_INIT(mgr)                                 \\\n  do {                                                            \\\n    static struct mg_tcpip_driver_stm32f_data driver_data_;       \\\n    static struct mg_tcpip_if mif_;                               \\\n    driver_data_.mdc_cr = MG_DRIVER_MDC_CR;                       \\\n    driver_data_.phy_addr = MG_TCPIP_PHY_ADDR;                    \\\n    mif_.ip = MG_TCPIP_IP;                                        \\\n    mif_.mask = MG_TCPIP_MASK;                                    \\\n    mif_.gw = MG_TCPIP_GW;                                        \\\n    mif_.driver = &mg_tcpip_driver_stm32f;                        \\\n    mif_.driver_data = &driver_data_;                             \\\n    MG_SET_MAC_ADDRESS(mif_.mac);                                 \\\n    mg_tcpip_init(mgr, &mif_);                                    \\\n    MG_INFO((\"Driver: stm32f, MAC: %M\", mg_print_mac, mif_.mac)); \\\n  } while (0)\n\n#endif\n\n\n#if MG_ENABLE_TCPIP\n#if !defined(MG_ENABLE_DRIVER_STM32H)\n#define MG_ENABLE_DRIVER_STM32H 0\n#endif\n#if !defined(MG_ENABLE_DRIVER_MCXN)\n#define MG_ENABLE_DRIVER_MCXN 0\n#endif\n#if MG_ENABLE_DRIVER_STM32H || MG_ENABLE_DRIVER_MCXN\n\nstruct mg_tcpip_driver_stm32h_data {\n  // MDC clock divider. MDC clock is derived from HCLK, must not exceed 2.5MHz\n  //    HCLK range    DIVIDER    mdc_cr VALUE\n  //    -------------------------------------\n  //                                -1  <-- tell driver to guess the value\n  //    60-100 MHz    HCLK/42        0\n  //    100-150 MHz   HCLK/62        1\n  //    20-35 MHz     HCLK/16        2\n  //    35-60 MHz     HCLK/26        3\n  //    150-250 MHz   HCLK/102       4  <-- value for max speed HSI\n  //    250-300 MHz   HCLK/124       5  <-- value for Nucleo-H* on CSI\n  //    300-500 MHz   HCLK/204       6\n  //    500-800 MHz   HCLK/324       7\n  int mdc_cr;  // Valid values: -1, 0, 1, 2, 3, 4, 5\n\n  uint8_t phy_addr;  // PHY address\n  uint8_t phy_conf;  // PHY config\n};\n\n#ifndef MG_TCPIP_PHY_CONF\n#define MG_TCPIP_PHY_CONF MG_PHY_CLOCKS_MAC\n#endif\n\n#ifndef MG_TCPIP_PHY_ADDR\n#define MG_TCPIP_PHY_ADDR 0\n#endif\n\n#ifndef MG_DRIVER_MDC_CR\n#define MG_DRIVER_MDC_CR 4\n#endif\n\n#define MG_TCPIP_DRIVER_INIT(mgr)                                 \\\n  do {                                                            \\\n    static struct mg_tcpip_driver_stm32h_data driver_data_;       \\\n    static struct mg_tcpip_if mif_;                               \\\n    driver_data_.mdc_cr = MG_DRIVER_MDC_CR;                       \\\n    driver_data_.phy_addr = MG_TCPIP_PHY_ADDR;                    \\\n    driver_data_.phy_conf = MG_TCPIP_PHY_CONF;                    \\\n    mif_.ip = MG_TCPIP_IP;                                        \\\n    mif_.mask = MG_TCPIP_MASK;                                    \\\n    mif_.gw = MG_TCPIP_GW;                                        \\\n    mif_.driver = &mg_tcpip_driver_stm32h;                        \\\n    mif_.driver_data = &driver_data_;                             \\\n    MG_SET_MAC_ADDRESS(mif_.mac);                                 \\\n    mg_tcpip_init(mgr, &mif_);                                    \\\n    MG_INFO((\"Driver: stm32h, MAC: %M\", mg_print_mac, mif_.mac)); \\\n  } while (0)\n\n#endif\n#endif\n\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_TM4C) && MG_ENABLE_DRIVER_TM4C\n\nstruct mg_tcpip_driver_tm4c_data {\n  // MDC clock divider. MDC clock is derived from SYSCLK, must not exceed 2.5MHz\n  //    SYSCLK range   DIVIDER   mdc_cr VALUE\n  //    -------------------------------------\n  //                                -1  <-- tell driver to guess the value\n  //    60-100 MHz    SYSCLK/42      0\n  //    100-150 MHz   SYSCLK/62      1  <-- value for EK-TM4C129* on max speed\n  //    20-35 MHz     SYSCLK/16      2\n  //    35-60 MHz     SYSCLK/26      3\n  //    0x4-0xF Reserved\n  int mdc_cr;  // Valid values: -1, 0, 1, 2, 3\n};\n\n#ifndef MG_DRIVER_MDC_CR\n#define MG_DRIVER_MDC_CR 1\n#endif\n\n#define MG_TCPIP_DRIVER_INIT(mgr)                               \\\n  do {                                                          \\\n    static struct mg_tcpip_driver_tm4c_data driver_data_;       \\\n    static struct mg_tcpip_if mif_;                             \\\n    driver_data_.mdc_cr = MG_DRIVER_MDC_CR;                     \\\n    mif_.ip = MG_TCPIP_IP;                                      \\\n    mif_.mask = MG_TCPIP_MASK;                                  \\\n    mif_.gw = MG_TCPIP_GW;                                      \\\n    mif_.driver = &mg_tcpip_driver_tm4c;                        \\\n    mif_.driver_data = &driver_data_;                           \\\n    MG_SET_MAC_ADDRESS(mif_.mac);                               \\\n    mg_tcpip_init(mgr, &mif_);                                  \\\n    MG_INFO((\"Driver: tm4c, MAC: %M\", mg_print_mac, mif_.mac)); \\\n  } while (0)\n\n#endif\n\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_TMS570) && MG_ENABLE_DRIVER_TMS570\nstruct mg_tcpip_driver_tms570_data {\n  int mdc_cr;\n  int phy_addr;\n};\n\n#ifndef MG_TCPIP_PHY_ADDR\n#define MG_TCPIP_PHY_ADDR 0\n#endif\n\n#ifndef MG_DRIVER_MDC_CR\n#define MG_DRIVER_MDC_CR 1\n#endif\n\n#define MG_TCPIP_DRIVER_INIT(mgr)                               \\\n  do {                                                          \\\n    static struct mg_tcpip_driver_tms570_data driver_data_;     \\\n    static struct mg_tcpip_if mif_;                             \\\n    driver_data_.mdc_cr = MG_DRIVER_MDC_CR;                     \\\n    driver_data_.phy_addr = MG_TCPIP_PHY_ADDR;                  \\\n    mif_.ip = MG_TCPIP_IP;                                      \\\n    mif_.mask = MG_TCPIP_MASK;                                  \\\n    mif_.gw = MG_TCPIP_GW;                                      \\\n    mif_.driver = &mg_tcpip_driver_tms570;                      \\\n    mif_.driver_data = &driver_data_;                           \\\n    MG_SET_MAC_ADDRESS(mif_.mac);                               \\\n    mg_tcpip_init(mgr, &mif_);                                  \\\n    MG_INFO((\"Driver: tms570, MAC: %M\", mg_print_mac, mif_.mac));\\\n  } while (0)\n#endif\n\n\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_W5500) && MG_ENABLE_DRIVER_W5500\n\n#endif\n\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_XMC7) && MG_ENABLE_DRIVER_XMC7\n\nstruct mg_tcpip_driver_xmc7_data {\n  int mdc_cr;  // Valid values: -1, 0, 1, 2, 3, 4, 5\n  uint8_t phy_addr;\n};\n\n#ifndef MG_TCPIP_PHY_ADDR\n#define MG_TCPIP_PHY_ADDR 0\n#endif\n\n#ifndef MG_DRIVER_MDC_CR\n#define MG_DRIVER_MDC_CR 3\n#endif\n\n#define MG_TCPIP_DRIVER_INIT(mgr)                                 \\\n  do {                                                            \\\n    static struct mg_tcpip_driver_xmc7_data driver_data_;       \\\n    static struct mg_tcpip_if mif_;                               \\\n    driver_data_.mdc_cr = MG_DRIVER_MDC_CR;                       \\\n    driver_data_.phy_addr = MG_TCPIP_PHY_ADDR;                    \\\n    mif_.ip = MG_TCPIP_IP;                                        \\\n    mif_.mask = MG_TCPIP_MASK;                                    \\\n    mif_.gw = MG_TCPIP_GW;                                        \\\n    mif_.driver = &mg_tcpip_driver_xmc7;                        \\\n    mif_.driver_data = &driver_data_;                             \\\n    MG_SET_MAC_ADDRESS(mif_.mac);                                 \\\n    mg_tcpip_init(mgr, &mif_);                                    \\\n    MG_INFO((\"Driver: xmc7, MAC: %M\", mg_print_mac, mif_.mac)); \\\n  } while (0)\n\n#endif\n\n\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_XMC) && MG_ENABLE_DRIVER_XMC\n\nstruct mg_tcpip_driver_xmc_data {\n  // 13.2.8.1 Station Management Functions\n  // MDC clock divider (). MDC clock is derived from ETH MAC clock\n  // It must not exceed 2.5MHz\n  // ETH Clock range  DIVIDER       mdc_cr VALUE\n  // --------------------------------------------\n  //                                     -1  <-- tell driver to guess the value\n  // 60-100 MHz       ETH Clock/42        0\n  // 100-150 MHz      ETH Clock/62        1\n  // 20-35 MHz        ETH Clock/16        2\n  // 35-60 MHz        ETH Clock/26        3\n  // 150-250 MHz      ETH Clock/102       4\n  // 250-300 MHz      ETH Clock/124       5\n  // 110, 111 Reserved\n  int mdc_cr;  // Valid values: -1, 0, 1, 2, 3, 4, 5\n  uint8_t phy_addr;\n};\n\n#ifndef MG_TCPIP_PHY_ADDR\n#define MG_TCPIP_PHY_ADDR 0\n#endif\n\n#ifndef MG_DRIVER_MDC_CR\n#define MG_DRIVER_MDC_CR 4\n#endif\n\n#define MG_TCPIP_DRIVER_INIT(mgr)                                 \\\n  do {                                                            \\\n    static struct mg_tcpip_driver_xmc_data driver_data_;       \\\n    static struct mg_tcpip_if mif_;                               \\\n    driver_data_.mdc_cr = MG_DRIVER_MDC_CR;                       \\\n    driver_data_.phy_addr = MG_TCPIP_PHY_ADDR;                    \\\n    mif_.ip = MG_TCPIP_IP;                                        \\\n    mif_.mask = MG_TCPIP_MASK;                                    \\\n    mif_.gw = MG_TCPIP_GW;                                        \\\n    mif_.driver = &mg_tcpip_driver_xmc;                        \\\n    mif_.driver_data = &driver_data_;                             \\\n    MG_SET_MAC_ADDRESS(mif_.mac);                                 \\\n    mg_tcpip_init(mgr, &mif_);                                    \\\n    MG_INFO((\"Driver: xmc, MAC: %M\", mg_print_mac, mif_.mac)); \\\n  } while (0)\n\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n#endif  // MONGOOSE_H\n"
        },
        {
          "name": "reference-projects",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tutorials",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}