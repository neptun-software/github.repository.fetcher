{
  "metadata": {
    "timestamp": 1736710421176,
    "page": 53,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pgvector/pgvector",
      "stars": 13395,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0791015625,
          "content": "/.git/\n/dist/\n/results/\n/tmp_check/\n/sql/vector--?.?.?.sql\nregression.*\n*.o\n*.so\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.08203125,
          "content": "root = true\n\n[*.{c,h,pl,pm,sql}]\nindent_style = tab\nindent_size = tab\ntab_width = 4\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1142578125,
          "content": "/dist/\n/log/\n/results/\n/tmp_check/\n/sql/vector--?.?.?.sql\nregression.*\n*.o\n*.so\n*.bc\n*.dll\n*.dylib\n*.obj\n*.lib\n*.exp\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 5.998046875,
          "content": "## 0.8.0 (2024-10-30)\n\n- Added support for iterative index scans\n- Added casts for arrays to `sparsevec`\n- Improved cost estimation for better index selection when filtering\n- Improved performance of HNSW index scans\n- Improved performance of HNSW inserts and on-disk index builds\n- Dropped support for Postgres 12\n\n## 0.7.4 (2024-08-05)\n\n- Fixed locking for parallel HNSW index builds\n- Fixed compilation error with GCC 14 on i386 when SSE2 is not enabled\n\n## 0.7.3 (2024-07-22)\n\n- Fixed `failed to add index item` error with `sparsevec`\n- Fixed compilation error with FreeBSD ARM\n- Fixed compilation warning with MSVC and Postgres 16\n\n## 0.7.2 (2024-06-11)\n\n- Fixed initialization fork for indexes on unlogged tables\n\n## 0.7.1 (2024-06-03)\n\n- Improved performance of on-disk HNSW index builds\n- Fixed `undefined symbol` error with GCC 8\n- Fixed compilation error with universal binaries on Mac\n- Fixed compilation warning with Clang < 14\n\n## 0.7.0 (2024-04-29)\n\n- Added `halfvec` type\n- Added `sparsevec` type\n- Added support for indexing `bit` type\n- Added support for indexing L1 distance with HNSW\n- Added `binary_quantize` function\n- Added `hamming_distance` function\n- Added `jaccard_distance` function\n- Added `l2_normalize` function\n- Added `subvector` function\n- Added concatenate operator for vectors\n- Added CPU dispatching for distance functions on Linux x86-64\n- Updated comparison operators to support vectors with different dimensions\n\n## 0.6.2 (2024-03-18)\n\n- Reduced lock contention with parallel HNSW index builds\n\n## 0.6.1 (2024-03-04)\n\n- Fixed error with `ANALYZE` and vectors with different dimensions\n- Fixed segmentation fault with `shared_preload_libraries`\n- Fixed vector subtraction being marked as commutative\n\n## 0.6.0 (2024-01-29)\n\nIf upgrading with Postgres 12 or Docker, see [these notes](https://github.com/pgvector/pgvector#060).\n\n- Added support for parallel index builds for HNSW\n- Added validation for GUC parameters\n- Changed storage for vector from `extended` to `external`\n- Improved performance of HNSW\n- Reduced memory usage for HNSW index builds\n- Reduced WAL generation for HNSW index builds\n- Fixed error with logical replication\n- Fixed `invalid memory alloc request size` error with HNSW index builds\n- Moved Docker image to `pgvector` org\n- Added Docker tags for each supported version of Postgres\n- Dropped support for Postgres 11\n\n## 0.5.1 (2023-10-10)\n\n- Improved performance of HNSW index builds\n- Added check for MVCC-compliant snapshot for index scans\n\n## 0.5.0 (2023-08-28)\n\n- Added HNSW index type\n- Added support for parallel index builds for IVFFlat\n- Added `l1_distance` function\n- Added element-wise multiplication for vectors\n- Added `sum` aggregate\n- Improved performance of distance functions\n- Fixed out of range results for cosine distance\n- Fixed results for NULL and NaN distances for IVFFlat\n\n## 0.4.4 (2023-06-12)\n\n- Improved error message for malformed vector literal\n- Fixed segmentation fault with text input\n- Fixed consecutive delimiters with text input\n\n## 0.4.3 (2023-06-10)\n\n- Improved cost estimation\n- Improved support for spaces with text input\n- Fixed infinite and NaN values with binary input\n- Fixed infinite values with vector addition and subtraction\n- Fixed infinite values with list centers\n- Fixed compilation error when `float8` is pass by reference\n- Fixed compilation error on PowerPC\n- Fixed segmentation fault with index creation on i386\n\n## 0.4.2 (2023-05-13)\n\n- Added notice when index created with little data\n- Fixed dimensions check for some direct function calls\n- Fixed installation error with Postgres 12.0-12.2\n\n## 0.4.1 (2023-03-21)\n\n- Improved performance of cosine distance\n- Fixed index scan count\n\n## 0.4.0 (2023-01-11)\n\nIf upgrading with Postgres < 13, see [this note](https://github.com/pgvector/pgvector/blob/v0.4.0/README.md#040).\n\n- Changed text representation for vector elements to match `real`\n- Changed storage for vector from `plain` to `extended`\n- Increased max dimensions for vector from 1024 to 16000\n- Increased max dimensions for index from 1024 to 2000\n- Improved accuracy of text parsing for certain inputs\n- Added `avg` aggregate for vector\n- Added experimental support for Windows\n- Dropped support for Postgres 10\n\n## 0.3.2 (2022-11-22)\n\n- Fixed `invalid memory alloc request size` error\n\n## 0.3.1 (2022-11-02)\n\nIf upgrading from 0.2.7 or 0.3.0, [recreate](https://github.com/pgvector/pgvector/blob/v0.3.1/README.md#031) all `ivfflat` indexes after upgrading to ensure all data is indexed.\n\n- Fixed issue with inserts silently corrupting `ivfflat` indexes (introduced in 0.2.7)\n- Fixed segmentation fault with index creation when lists > 6500\n\n## 0.3.0 (2022-10-15)\n\n- Added support for Postgres 15\n- Dropped support for Postgres 9.6\n\n## 0.2.7 (2022-07-31)\n\n- Fixed `unexpected data beyond EOF` error\n\n## 0.2.6 (2022-05-22)\n\n- Improved performance of index creation for Postgres < 12\n\n## 0.2.5 (2022-02-11)\n\n- Reduced memory usage during index creation\n- Fixed index creation exceeding `maintenance_work_mem`\n- Fixed error with index creation when lists > 1600\n\n## 0.2.4 (2022-02-06)\n\n- Added support for parallel vacuum\n- Fixed issue with index not reusing space\n\n## 0.2.3 (2022-01-30)\n\n- Added indexing progress for Postgres 12+\n- Improved interrupt handling during index creation\n\n## 0.2.2 (2022-01-15)\n\n- Fixed compilation error on Mac ARM\n\n## 0.2.1 (2022-01-02)\n\n- Fixed `operator is not unique` error\n\n## 0.2.0 (2021-10-03)\n\n- Added support for Postgres 14\n\n## 0.1.8 (2021-09-07)\n\n- Added cast for `vector` to `real[]`\n\n## 0.1.7 (2021-06-13)\n\n- Added cast for `numeric[]` to `vector`\n\n## 0.1.6 (2021-06-09)\n\n- Fixed segmentation fault with `COUNT`\n\n## 0.1.5 (2021-05-25)\n\n- Reduced memory usage during index creation\n\n## 0.1.4 (2021-05-09)\n\n- Fixed kmeans for inner product\n- Fixed multiple definition error with GCC 10\n\n## 0.1.3 (2021-05-06)\n\n- Added Dockerfile\n- Fixed version\n\n## 0.1.2 (2021-04-26)\n\n- Vectorized distance calculations\n- Improved cost estimation\n\n## 0.1.1 (2021-04-25)\n\n- Added binary representation for `COPY`\n- Marked functions as `PARALLEL SAFE`\n\n## 0.1.0 (2021-04-20)\n\n- First release\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.578125,
          "content": "ARG PG_MAJOR=17\nFROM postgres:$PG_MAJOR\nARG PG_MAJOR\n\nCOPY . /tmp/pgvector\n\nRUN apt-get update && \\\n\t\tapt-mark hold locales && \\\n\t\tapt-get install -y --no-install-recommends build-essential postgresql-server-dev-$PG_MAJOR && \\\n\t\tcd /tmp/pgvector && \\\n\t\tmake clean && \\\n\t\tmake OPTFLAGS=\"\" && \\\n\t\tmake install && \\\n\t\tmkdir /usr/share/doc/pgvector && \\\n\t\tcp LICENSE README.md /usr/share/doc/pgvector && \\\n\t\trm -r /tmp/pgvector && \\\n\t\tapt-get remove -y build-essential postgresql-server-dev-$PG_MAJOR && \\\n\t\tapt-get autoremove -y && \\\n\t\tapt-mark unhold locales && \\\n\t\trm -rf /var/lib/apt/lists/*\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.078125,
          "content": "Portions Copyright (c) 1996-2025, PostgreSQL Global Development Group\n\nPortions Copyright (c) 1994, The Regents of the University of California\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose, without fee, and without a written agreement\nis hereby granted, provided that the above copyright notice and this\nparagraph and the following two paragraphs appear in all copies.\n\nIN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR\nDIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING\nLOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS\nDOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\nTHE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\nON AN \"AS IS\" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO\nPROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n"
        },
        {
          "name": "META.json",
          "type": "blob",
          "size": 1.0791015625,
          "content": "{\n\t\"name\": \"vector\",\n\t\"abstract\": \"Open-source vector similarity search for Postgres\",\n\t\"description\": \"Supports L2 distance, inner product, and cosine distance\",\n\t\"version\": \"0.8.0\",\n\t\"maintainer\": [\n\t\t\"Andrew Kane <andrew@ankane.org>\"\n\t],\n\t\"license\": {\n\t\t\"PostgreSQL\": \"http://www.postgresql.org/about/licence\"\n\t},\n\t\"prereqs\": {\n\t\t\"runtime\": {\n\t\t\t\"requires\": {\n\t\t\t\t\"PostgreSQL\": \"13.0.0\"\n\t\t\t}\n\t\t}\n\t},\n\t\"provides\": {\n\t\t\"vector\": {\n\t\t\t\"file\": \"sql/vector.sql\",\n\t\t\t\"docfile\": \"README.md\",\n\t\t\t\"version\": \"0.8.0\",\n\t\t\t\"abstract\": \"Open-source vector similarity search for Postgres\"\n\t\t}\n\t},\n\t\"resources\": {\n\t\t\"homepage\": \"https://github.com/pgvector/pgvector\",\n\t\t\"bugtracker\": {\n\t\t\t\"web\": \"https://github.com/pgvector/pgvector/issues\"\n\t\t},\n\t\t\"repository\": {\n\t\t\t\"url\":  \"https://github.com/pgvector/pgvector.git\",\n\t\t\t\"web\":  \"https://github.com/pgvector/pgvector\",\n\t\t\t\"type\": \"git\"\n\t\t}\n\t},\n\t\"generated_by\": \"Andrew Kane\",\n\t\"meta-spec\": {\n\t\t\"version\": \"1.0.0\",\n\t\t\"url\": \"http://pgxn.org/meta/spec.txt\"\n\t},\n\t\"tags\": [\n\t\t\"vectors\",\n\t\t\"datatype\",\n\t\t\"nearest neighbor search\",\n\t\t\"approximate nearest neighbors\"\n\t]\n}\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.564453125,
          "content": "EXTENSION = vector\nEXTVERSION = 0.8.0\n\nMODULE_big = vector\nDATA = $(wildcard sql/*--*--*.sql)\nDATA_built = sql/$(EXTENSION)--$(EXTVERSION).sql\nOBJS = src/bitutils.o src/bitvec.o src/halfutils.o src/halfvec.o src/hnsw.o src/hnswbuild.o src/hnswinsert.o src/hnswscan.o src/hnswutils.o src/hnswvacuum.o src/ivfbuild.o src/ivfflat.o src/ivfinsert.o src/ivfkmeans.o src/ivfscan.o src/ivfutils.o src/ivfvacuum.o src/sparsevec.o src/vector.o\nHEADERS = src/halfvec.h src/sparsevec.h src/vector.h\n\nTESTS = $(wildcard test/sql/*.sql)\nREGRESS = $(patsubst test/sql/%.sql,%,$(TESTS))\nREGRESS_OPTS = --inputdir=test --load-extension=$(EXTENSION)\n\n# To compile for portability, run: make OPTFLAGS=\"\"\nOPTFLAGS = -march=native\n\n# Mac ARM doesn't always support -march=native\nifeq ($(shell uname -s), Darwin)\n\tifeq ($(shell uname -p), arm)\n\t\t# no difference with -march=armv8.5-a\n\t\tOPTFLAGS =\n\tendif\nendif\n\n# PowerPC doesn't support -march=native\nifneq ($(filter ppc64%, $(shell uname -m)), )\n\tOPTFLAGS =\nendif\n\n# For auto-vectorization:\n# - GCC (needs -ftree-vectorize OR -O3) - https://gcc.gnu.org/projects/tree-ssa/vectorization.html\n# - Clang (could use pragma instead) - https://llvm.org/docs/Vectorizers.html\nPG_CFLAGS += $(OPTFLAGS) -ftree-vectorize -fassociative-math -fno-signed-zeros -fno-trapping-math\n\n# Debug GCC auto-vectorization\n# PG_CFLAGS += -fopt-info-vec\n\n# Debug Clang auto-vectorization\n# PG_CFLAGS += -Rpass=loop-vectorize -Rpass-analysis=loop-vectorize\n\nall: sql/$(EXTENSION)--$(EXTVERSION).sql\n\nsql/$(EXTENSION)--$(EXTVERSION).sql: sql/$(EXTENSION).sql\n\tcp $< $@\n\nPG_CONFIG ?= pg_config\nPGXS := $(shell $(PG_CONFIG) --pgxs)\ninclude $(PGXS)\n\n# for Mac\nifeq ($(PROVE),)\n\tPROVE = prove\nendif\n\n# for Postgres < 15\nPROVE_FLAGS += -I ./test/perl\n\nprove_installcheck:\n\trm -rf $(CURDIR)/tmp_check\n\tcd $(srcdir) && TESTDIR='$(CURDIR)' PATH=\"$(bindir):$$PATH\" PGPORT='6$(DEF_PGPORT)' PG_REGRESS='$(top_builddir)/src/test/regress/pg_regress' $(PROVE) $(PG_PROVE_FLAGS) $(PROVE_FLAGS) $(if $(PROVE_TESTS),$(PROVE_TESTS),test/t/*.pl)\n\n.PHONY: dist\n\ndist:\n\tmkdir -p dist\n\tgit archive --format zip --prefix=$(EXTENSION)-$(EXTVERSION)/ --output dist/$(EXTENSION)-$(EXTVERSION).zip master\n\n# for Docker\nPG_MAJOR ?= 17\n\n.PHONY: docker\n\ndocker:\n\tdocker build --pull --no-cache --build-arg PG_MAJOR=$(PG_MAJOR) -t pgvector/pgvector:pg$(PG_MAJOR) -t pgvector/pgvector:$(EXTVERSION)-pg$(PG_MAJOR) .\n\n.PHONY: docker-release\n\ndocker-release:\n\tdocker buildx build --push --pull --no-cache --platform linux/amd64,linux/arm64 --build-arg PG_MAJOR=$(PG_MAJOR) -t pgvector/pgvector:pg$(PG_MAJOR) -t pgvector/pgvector:$(EXTVERSION)-pg$(PG_MAJOR) .\n"
        },
        {
          "name": "Makefile.win",
          "type": "blob",
          "size": 2.66015625,
          "content": "EXTENSION = vector\nEXTVERSION = 0.8.0\n\nDATA_built = sql\\$(EXTENSION)--$(EXTVERSION).sql\nOBJS = src\\bitutils.obj src\\bitvec.obj src\\halfutils.obj src\\halfvec.obj src\\hnsw.obj src\\hnswbuild.obj src\\hnswinsert.obj src\\hnswscan.obj src\\hnswutils.obj src\\hnswvacuum.obj src\\ivfbuild.obj src\\ivfflat.obj src\\ivfinsert.obj src\\ivfkmeans.obj src\\ivfscan.obj src\\ivfutils.obj src\\ivfvacuum.obj src\\sparsevec.obj src\\vector.obj\nHEADERS = src\\halfvec.h src\\sparsevec.h src\\vector.h\n\nREGRESS = bit btree cast copy halfvec hnsw_bit hnsw_halfvec hnsw_sparsevec hnsw_vector ivfflat_bit ivfflat_halfvec ivfflat_vector sparsevec vector_type\nREGRESS_OPTS = --inputdir=test --load-extension=$(EXTENSION)\n\n# For /arch flags\n# https://learn.microsoft.com/en-us/cpp/build/reference/arch-minimum-cpu-architecture\nOPTFLAGS =\n\n# For auto-vectorization:\n# - MSVC (needs /O2 /fp:fast) - https://learn.microsoft.com/en-us/cpp/parallel/auto-parallelization-and-auto-vectorization?#auto-vectorizer\nPG_CFLAGS = $(PG_CFLAGS) $(OPTFLAGS) /O2 /fp:fast\n\n# Debug MSVC auto-vectorization\n# https://learn.microsoft.com/en-us/cpp/error-messages/tool-errors/vectorizer-and-parallelizer-messages\n# PG_CFLAGS = $(PG_CFLAGS) /Qvec-report:2\n\n# TODO use pg_config\n!ifndef PGROOT\n!error PGROOT is not set\n!endif\nBINDIR = $(PGROOT)\\bin\nINCLUDEDIR = $(PGROOT)\\include\nINCLUDEDIR_SERVER = $(PGROOT)\\include\\server\nLIBDIR = $(PGROOT)\\lib\nPKGLIBDIR = $(PGROOT)\\lib\nSHAREDIR = $(PGROOT)\\share\n\nCFLAGS = /nologo /I\"$(INCLUDEDIR_SERVER)\\port\\win32_msvc\" /I\"$(INCLUDEDIR_SERVER)\\port\\win32\" /I\"$(INCLUDEDIR_SERVER)\" /I\"$(INCLUDEDIR)\"\n\nCFLAGS = $(CFLAGS) $(PG_CFLAGS)\n\nSHLIB = $(EXTENSION).dll\n\nLIBS = \"$(LIBDIR)\\postgres.lib\"\n\nall: $(SHLIB) $(DATA_built)\n\n.c.obj:\n\t$(CC) $(CFLAGS) /c $< /Fo$@\n\n$(SHLIB): $(OBJS)\n\t$(CC) $(CFLAGS) $(OBJS) $(LIBS) /link /DLL /OUT:$(SHLIB)\n\nsql\\$(EXTENSION)--$(EXTVERSION).sql: sql\\$(EXTENSION).sql\n\tcopy sql\\$(EXTENSION).sql $@\n\ninstall: all\n\tcopy $(SHLIB) \"$(PKGLIBDIR)\"\n\tcopy $(EXTENSION).control \"$(SHAREDIR)\\extension\"\n\tcopy sql\\$(EXTENSION)--*.sql \"$(SHAREDIR)\\extension\"\n\tmkdir \"$(INCLUDEDIR_SERVER)\\extension\\$(EXTENSION)\"\n\tfor %f in ($(HEADERS)) do copy %f \"$(INCLUDEDIR_SERVER)\\extension\\$(EXTENSION)\"\n\ninstallcheck:\n\t\"$(BINDIR)\\pg_regress\" --bindir=\"$(BINDIR)\" $(REGRESS_OPTS) $(REGRESS)\n\nuninstall:\n\tdel /f \"$(PKGLIBDIR)\\$(SHLIB)\"\n\tdel /f \"$(SHAREDIR)\\extension\\$(EXTENSION).control\"\n\tdel /f \"$(SHAREDIR)\\extension\\$(EXTENSION)--*.sql\"\n\tdel /f \"$(INCLUDEDIR_SERVER)\\extension\\$(EXTENSION)\\*.h\"\n\trmdir \"$(INCLUDEDIR_SERVER)\\extension\\$(EXTENSION)\"\n\nclean:\n\tdel /f $(SHLIB) $(EXTENSION).lib $(EXTENSION).exp\n\tdel /f $(DATA_built)\n\tdel /f $(OBJS)\n\tdel /f /s /q results regression.diffs regression.out tmp_check tmp_check_iso log output_iso\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 40.0078125,
          "content": "# pgvector\n\nOpen-source vector similarity search for Postgres\n\nStore your vectors with the rest of your data. Supports:\n\n- exact and approximate nearest neighbor search\n- single-precision, half-precision, binary, and sparse vectors\n- L2 distance, inner product, cosine distance, L1 distance, Hamming distance, and Jaccard distance\n- any [language](#languages) with a Postgres client\n\nPlus [ACID](https://en.wikipedia.org/wiki/ACID) compliance, point-in-time recovery, JOINs, and all of the other [great features](https://www.postgresql.org/about/) of Postgres\n\n[![Build Status](https://github.com/pgvector/pgvector/actions/workflows/build.yml/badge.svg)](https://github.com/pgvector/pgvector/actions)\n\n## Installation\n\n### Linux and Mac\n\nCompile and install the extension (supports Postgres 13+)\n\n```sh\ncd /tmp\ngit clone --branch v0.8.0 https://github.com/pgvector/pgvector.git\ncd pgvector\nmake\nmake install # may need sudo\n```\n\nSee the [installation notes](#installation-notes---linux-and-mac) if you run into issues\n\nYou can also install it with [Docker](#docker), [Homebrew](#homebrew), [PGXN](#pgxn), [APT](#apt), [Yum](#yum), [pkg](#pkg), or [conda-forge](#conda-forge), and it comes preinstalled with [Postgres.app](#postgresapp) and many [hosted providers](#hosted-postgres). There are also instructions for [GitHub Actions](https://github.com/pgvector/setup-pgvector).\n\n### Windows\n\nEnsure [C++ support in Visual Studio](https://learn.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#download-and-install-the-tools) is installed, and run:\n\n```cmd\ncall \"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n```\n\nNote: The exact path will vary depending on your Visual Studio version and edition\n\nThen use `nmake` to build:\n\n```cmd\nset \"PGROOT=C:\\Program Files\\PostgreSQL\\16\"\ncd %TEMP%\ngit clone --branch v0.8.0 https://github.com/pgvector/pgvector.git\ncd pgvector\nnmake /F Makefile.win\nnmake /F Makefile.win install\n```\n\nNote: Postgres 17 is not supported with MSVC yet due to an [upstream issue](https://www.postgresql.org/message-id/flat/CAOdR5yF0krWrxycA04rgUKCgKugRvGWzzGLAhDZ9bzNv8g0Lag%40mail.gmail.com)\n\nSee the [installation notes](#installation-notes---windows) if you run into issues\n\nYou can also install it with [Docker](#docker) or [conda-forge](#conda-forge).\n\n## Getting Started\n\nEnable the extension (do this once in each database where you want to use it)\n\n```tsql\nCREATE EXTENSION vector;\n```\n\nCreate a vector column with 3 dimensions\n\n```sql\nCREATE TABLE items (id bigserial PRIMARY KEY, embedding vector(3));\n```\n\nInsert vectors\n\n```sql\nINSERT INTO items (embedding) VALUES ('[1,2,3]'), ('[4,5,6]');\n```\n\nGet the nearest neighbors by L2 distance\n\n```sql\nSELECT * FROM items ORDER BY embedding <-> '[3,1,2]' LIMIT 5;\n```\n\nAlso supports inner product (`<#>`), cosine distance (`<=>`), and L1 distance (`<+>`, added in 0.7.0)\n\nNote: `<#>` returns the negative inner product since Postgres only supports `ASC` order index scans on operators\n\n## Storing\n\nCreate a new table with a vector column\n\n```sql\nCREATE TABLE items (id bigserial PRIMARY KEY, embedding vector(3));\n```\n\nOr add a vector column to an existing table\n\n```sql\nALTER TABLE items ADD COLUMN embedding vector(3);\n```\n\nAlso supports [half-precision](#half-precision-vectors), [binary](#binary-vectors), and [sparse](#sparse-vectors) vectors\n\nInsert vectors\n\n```sql\nINSERT INTO items (embedding) VALUES ('[1,2,3]'), ('[4,5,6]');\n```\n\nOr load vectors in bulk using `COPY` ([example](https://github.com/pgvector/pgvector-python/blob/master/examples/loading/example.py))\n\n```sql\nCOPY items (embedding) FROM STDIN WITH (FORMAT BINARY);\n```\n\nUpsert vectors\n\n```sql\nINSERT INTO items (id, embedding) VALUES (1, '[1,2,3]'), (2, '[4,5,6]')\n    ON CONFLICT (id) DO UPDATE SET embedding = EXCLUDED.embedding;\n```\n\nUpdate vectors\n\n```sql\nUPDATE items SET embedding = '[1,2,3]' WHERE id = 1;\n```\n\nDelete vectors\n\n```sql\nDELETE FROM items WHERE id = 1;\n```\n\n## Querying\n\nGet the nearest neighbors to a vector\n\n```sql\nSELECT * FROM items ORDER BY embedding <-> '[3,1,2]' LIMIT 5;\n```\n\nSupported distance functions are:\n\n- `<->` - L2 distance\n- `<#>` - (negative) inner product\n- `<=>` - cosine distance\n- `<+>` - L1 distance (added in 0.7.0)\n- `<~>` - Hamming distance (binary vectors, added in 0.7.0)\n- `<%>` - Jaccard distance (binary vectors, added in 0.7.0)\n\nGet the nearest neighbors to a row\n\n```sql\nSELECT * FROM items WHERE id != 1 ORDER BY embedding <-> (SELECT embedding FROM items WHERE id = 1) LIMIT 5;\n```\n\nGet rows within a certain distance\n\n```sql\nSELECT * FROM items WHERE embedding <-> '[3,1,2]' < 5;\n```\n\nNote: Combine with `ORDER BY` and `LIMIT` to use an index\n\n#### Distances\n\nGet the distance\n\n```sql\nSELECT embedding <-> '[3,1,2]' AS distance FROM items;\n```\n\nFor inner product, multiply by -1 (since `<#>` returns the negative inner product)\n\n```tsql\nSELECT (embedding <#> '[3,1,2]') * -1 AS inner_product FROM items;\n```\n\nFor cosine similarity, use 1 - cosine distance\n\n```sql\nSELECT 1 - (embedding <=> '[3,1,2]') AS cosine_similarity FROM items;\n```\n\n#### Aggregates\n\nAverage vectors\n\n```sql\nSELECT AVG(embedding) FROM items;\n```\n\nAverage groups of vectors\n\n```sql\nSELECT category_id, AVG(embedding) FROM items GROUP BY category_id;\n```\n\n## Indexing\n\nBy default, pgvector performs exact nearest neighbor search, which provides perfect recall.\n\nYou can add an index to use approximate nearest neighbor search, which trades some recall for speed. Unlike typical indexes, you will see different results for queries after adding an approximate index.\n\nSupported index types are:\n\n- [HNSW](#hnsw)\n- [IVFFlat](#ivfflat)\n\n## HNSW\n\nAn HNSW index creates a multilayer graph. It has better query performance than IVFFlat (in terms of speed-recall tradeoff), but has slower build times and uses more memory. Also, an index can be created without any data in the table since there isn’t a training step like IVFFlat.\n\nAdd an index for each distance function you want to use.\n\nL2 distance\n\n```sql\nCREATE INDEX ON items USING hnsw (embedding vector_l2_ops);\n```\n\nNote: Use `halfvec_l2_ops` for `halfvec` and `sparsevec_l2_ops` for `sparsevec` (and similar with the other distance functions)\n\nInner product\n\n```sql\nCREATE INDEX ON items USING hnsw (embedding vector_ip_ops);\n```\n\nCosine distance\n\n```sql\nCREATE INDEX ON items USING hnsw (embedding vector_cosine_ops);\n```\n\nL1 distance - added in 0.7.0\n\n```sql\nCREATE INDEX ON items USING hnsw (embedding vector_l1_ops);\n```\n\nHamming distance - added in 0.7.0\n\n```sql\nCREATE INDEX ON items USING hnsw (embedding bit_hamming_ops);\n```\n\nJaccard distance - added in 0.7.0\n\n```sql\nCREATE INDEX ON items USING hnsw (embedding bit_jaccard_ops);\n```\n\nSupported types are:\n\n- `vector` - up to 2,000 dimensions\n- `halfvec` - up to 4,000 dimensions (added in 0.7.0)\n- `bit` - up to 64,000 dimensions (added in 0.7.0)\n- `sparsevec` - up to 1,000 non-zero elements (added in 0.7.0)\n\n### Index Options\n\nSpecify HNSW parameters\n\n- `m` - the max number of connections per layer (16 by default)\n- `ef_construction` - the size of the dynamic candidate list for constructing the graph (64 by default)\n\n```sql\nCREATE INDEX ON items USING hnsw (embedding vector_l2_ops) WITH (m = 16, ef_construction = 64);\n```\n\nA higher value of `ef_construction` provides better recall at the cost of index build time / insert speed.\n\n### Query Options\n\nSpecify the size of the dynamic candidate list for search (40 by default)\n\n```sql\nSET hnsw.ef_search = 100;\n```\n\nA higher value provides better recall at the cost of speed.\n\nUse `SET LOCAL` inside a transaction to set it for a single query\n\n```sql\nBEGIN;\nSET LOCAL hnsw.ef_search = 100;\nSELECT ...\nCOMMIT;\n```\n\n### Index Build Time\n\nIndexes build significantly faster when the graph fits into `maintenance_work_mem`\n\n```sql\nSET maintenance_work_mem = '8GB';\n```\n\nA notice is shown when the graph no longer fits\n\n```text\nNOTICE:  hnsw graph no longer fits into maintenance_work_mem after 100000 tuples\nDETAIL:  Building will take significantly more time.\nHINT:  Increase maintenance_work_mem to speed up builds.\n```\n\nNote: Do not set `maintenance_work_mem` so high that it exhausts the memory on the server\n\nLike other index types, it’s faster to create an index after loading your initial data\n\nStarting with 0.6.0, you can also speed up index creation by increasing the number of parallel workers (2 by default)\n\n```sql\nSET max_parallel_maintenance_workers = 7; -- plus leader\n```\n\nFor a large number of workers, you may also need to increase `max_parallel_workers` (8 by default)\n\n### Indexing Progress\n\nCheck [indexing progress](https://www.postgresql.org/docs/current/progress-reporting.html#CREATE-INDEX-PROGRESS-REPORTING)\n\n```sql\nSELECT phase, round(100.0 * blocks_done / nullif(blocks_total, 0), 1) AS \"%\" FROM pg_stat_progress_create_index;\n```\n\nThe phases for HNSW are:\n\n1. `initializing`\n2. `loading tuples`\n\n## IVFFlat\n\nAn IVFFlat index divides vectors into lists, and then searches a subset of those lists that are closest to the query vector. It has faster build times and uses less memory than HNSW, but has lower query performance (in terms of speed-recall tradeoff).\n\nThree keys to achieving good recall are:\n\n1. Create the index *after* the table has some data\n2. Choose an appropriate number of lists - a good place to start is `rows / 1000` for up to 1M rows and `sqrt(rows)` for over 1M rows\n3. When querying, specify an appropriate number of [probes](#query-options) (higher is better for recall, lower is better for speed) - a good place to start is `sqrt(lists)`\n\nAdd an index for each distance function you want to use.\n\nL2 distance\n\n```sql\nCREATE INDEX ON items USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);\n```\n\nNote: Use `halfvec_l2_ops` for `halfvec` (and similar with the other distance functions)\n\nInner product\n\n```sql\nCREATE INDEX ON items USING ivfflat (embedding vector_ip_ops) WITH (lists = 100);\n```\n\nCosine distance\n\n```sql\nCREATE INDEX ON items USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);\n```\n\nHamming distance - added in 0.7.0\n\n```sql\nCREATE INDEX ON items USING ivfflat (embedding bit_hamming_ops) WITH (lists = 100);\n```\n\nSupported types are:\n\n- `vector` - up to 2,000 dimensions\n- `halfvec` - up to 4,000 dimensions (added in 0.7.0)\n- `bit` - up to 64,000 dimensions (added in 0.7.0)\n\n### Query Options\n\nSpecify the number of probes (1 by default)\n\n```sql\nSET ivfflat.probes = 10;\n```\n\nA higher value provides better recall at the cost of speed, and it can be set to the number of lists for exact nearest neighbor search (at which point the planner won’t use the index)\n\nUse `SET LOCAL` inside a transaction to set it for a single query\n\n```sql\nBEGIN;\nSET LOCAL ivfflat.probes = 10;\nSELECT ...\nCOMMIT;\n```\n\n### Index Build Time\n\nSpeed up index creation on large tables by increasing the number of parallel workers (2 by default)\n\n```sql\nSET max_parallel_maintenance_workers = 7; -- plus leader\n```\n\nFor a large number of workers, you may also need to increase `max_parallel_workers` (8 by default)\n\n### Indexing Progress\n\nCheck [indexing progress](https://www.postgresql.org/docs/current/progress-reporting.html#CREATE-INDEX-PROGRESS-REPORTING)\n\n```sql\nSELECT phase, round(100.0 * tuples_done / nullif(tuples_total, 0), 1) AS \"%\" FROM pg_stat_progress_create_index;\n```\n\nThe phases for IVFFlat are:\n\n1. `initializing`\n2. `performing k-means`\n3. `assigning tuples`\n4. `loading tuples`\n\nNote: `%` is only populated during the `loading tuples` phase\n\n## Filtering\n\nThere are a few ways to index nearest neighbor queries with a `WHERE` clause.\n\n```sql\nSELECT * FROM items WHERE category_id = 123 ORDER BY embedding <-> '[3,1,2]' LIMIT 5;\n```\n\nA good place to start is creating an index on the filter column. This can provide fast, exact nearest neighbor search in many cases. Postgres has a number of [index types](https://www.postgresql.org/docs/current/indexes-types.html) for this: B-tree (default), hash, GiST, SP-GiST, GIN, and BRIN.\n\n```sql\nCREATE INDEX ON items (category_id);\n```\n\nFor multiple columns, consider a [multicolumn index](https://www.postgresql.org/docs/current/indexes-multicolumn.html).\n\n```sql\nCREATE INDEX ON items (location_id, category_id);\n```\n\nExact indexes work well for conditions that match a low percentage of rows. Otherwise, [approximate indexes](#indexing) can work better.\n\n```sql\nCREATE INDEX ON items USING hnsw (embedding vector_l2_ops);\n```\n\nWith approximate indexes, filtering is applied *after* the index is scanned. If a condition matches 10% of rows, with HNSW and the default `hnsw.ef_search` of 40, only 4 rows will match on average. For more rows, increase `hnsw.ef_search`.\n\n```sql\nSET hnsw.ef_search = 200;\n```\n\nStarting with 0.8.0, you can enable [iterative index scans](#iterative-index-scans), which will automatically scan more of the index when needed.\n\n```sql\nSET hnsw.iterative_scan = strict_order;\n```\n\nIf filtering by only a few distinct values, consider [partial indexing](https://www.postgresql.org/docs/current/indexes-partial.html).\n\n```sql\nCREATE INDEX ON items USING hnsw (embedding vector_l2_ops) WHERE (category_id = 123);\n```\n\nIf filtering by many different values, consider [partitioning](https://www.postgresql.org/docs/current/ddl-partitioning.html).\n\n```sql\nCREATE TABLE items (embedding vector(3), category_id int) PARTITION BY LIST(category_id);\n```\n\n## Iterative Index Scans\n\n*Added in 0.8.0*\n\nWith approximate indexes, queries with filtering can return less results since filtering is applied *after* the index is scanned. Starting with 0.8.0, you can enable iterative index scans, which will automatically scan more of the index until enough results are found (or it reaches `hnsw.max_scan_tuples` or `ivfflat.max_probes`).\n\nIterative scans can use strict or relaxed ordering.\n\nStrict ensures results are in the exact order by distance\n\n```sql\nSET hnsw.iterative_scan = strict_order;\n```\n\nRelaxed allows results to be slightly out of order by distance, but provides better recall\n\n```sql\nSET hnsw.iterative_scan = relaxed_order;\n# or\nSET ivfflat.iterative_scan = relaxed_order;\n```\n\nWith relaxed ordering, you can use a [materialized CTE](https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-CTE-MATERIALIZATION) to get strict ordering\n\n```sql\nWITH relaxed_results AS MATERIALIZED (\n    SELECT id, embedding <-> '[1,2,3]' AS distance FROM items WHERE category_id = 123 ORDER BY distance LIMIT 5\n) SELECT * FROM relaxed_results ORDER BY distance;\n```\n\nFor queries that filter by distance, use a materialized CTE and place the distance filter outside of it for best performance (due to the [current behavior](https://www.postgresql.org/message-id/flat/CAOdR5yGUoMQ6j7M5hNUXrySzaqZVGf_Ne%2B8fwZMRKTFxU1nbJg%40mail.gmail.com) of the Postgres executor)\n\n```sql\nWITH nearest_results AS MATERIALIZED (\n    SELECT id, embedding <-> '[1,2,3]' AS distance FROM items ORDER BY distance LIMIT 5\n) SELECT * FROM nearest_results WHERE distance < 5 ORDER BY distance;\n```\n\nNote: Place any other filters inside the CTE\n\n### Iterative Scan Options\n\nSince scanning a large portion of an approximate index is expensive, there are options to control when a scan ends.\n\n#### HNSW\n\nSpecify the max number of tuples to visit (20,000 by default)\n\n```sql\nSET hnsw.max_scan_tuples = 20000;\n```\n\nNote: This is approximate and does not affect the initial scan\n\nSpecify the max amount of memory to use, as a multiple of `work_mem` (1 by default)\n\n```sql\nSET hnsw.scan_mem_multiplier = 2;\n```\n\nNote: Try increasing this if increasing `hnsw.max_scan_tuples` does not improve recall\n\n#### IVFFlat\n\nSpecify the max number of probes\n\n```sql\nSET ivfflat.max_probes = 100;\n```\n\nNote: If this is lower than `ivfflat.probes`, `ivfflat.probes` will be used\n\n## Half-Precision Vectors\n\n*Added in 0.7.0*\n\nUse the `halfvec` type to store half-precision vectors\n\n```sql\nCREATE TABLE items (id bigserial PRIMARY KEY, embedding halfvec(3));\n```\n\n## Half-Precision Indexing\n\n*Added in 0.7.0*\n\nIndex vectors at half precision for smaller indexes\n\n```sql\nCREATE INDEX ON items USING hnsw ((embedding::halfvec(3)) halfvec_l2_ops);\n```\n\nGet the nearest neighbors\n\n```sql\nSELECT * FROM items ORDER BY embedding::halfvec(3) <-> '[1,2,3]' LIMIT 5;\n```\n\n## Binary Vectors\n\nUse the `bit` type to store binary vectors ([example](https://github.com/pgvector/pgvector-python/blob/master/examples/imagehash/example.py))\n\n```sql\nCREATE TABLE items (id bigserial PRIMARY KEY, embedding bit(3));\nINSERT INTO items (embedding) VALUES ('000'), ('111');\n```\n\nGet the nearest neighbors by Hamming distance (added in 0.7.0)\n\n```sql\nSELECT * FROM items ORDER BY embedding <~> '101' LIMIT 5;\n```\n\nOr (before 0.7.0)\n\n```sql\nSELECT * FROM items ORDER BY bit_count(embedding # '101') LIMIT 5;\n```\n\nAlso supports Jaccard distance (`<%>`)\n\n## Binary Quantization\n\n*Added in 0.7.0*\n\nUse expression indexing for binary quantization\n\n```sql\nCREATE INDEX ON items USING hnsw ((binary_quantize(embedding)::bit(3)) bit_hamming_ops);\n```\n\nGet the nearest neighbors by Hamming distance\n\n```sql\nSELECT * FROM items ORDER BY binary_quantize(embedding)::bit(3) <~> binary_quantize('[1,-2,3]') LIMIT 5;\n```\n\nRe-rank by the original vectors for better recall\n\n```sql\nSELECT * FROM (\n    SELECT * FROM items ORDER BY binary_quantize(embedding)::bit(3) <~> binary_quantize('[1,-2,3]') LIMIT 20\n) ORDER BY embedding <=> '[1,-2,3]' LIMIT 5;\n```\n\n## Sparse Vectors\n\n*Added in 0.7.0*\n\nUse the `sparsevec` type to store sparse vectors\n\n```sql\nCREATE TABLE items (id bigserial PRIMARY KEY, embedding sparsevec(5));\n```\n\nInsert vectors\n\n```sql\nINSERT INTO items (embedding) VALUES ('{1:1,3:2,5:3}/5'), ('{1:4,3:5,5:6}/5');\n```\n\nThe format is `{index1:value1,index2:value2}/dimensions` and indices start at 1 like SQL arrays\n\nGet the nearest neighbors by L2 distance\n\n```sql\nSELECT * FROM items ORDER BY embedding <-> '{1:3,3:1,5:2}/5' LIMIT 5;\n```\n\n## Hybrid Search\n\nUse together with Postgres [full-text search](https://www.postgresql.org/docs/current/textsearch-intro.html) for hybrid search.\n\n```sql\nSELECT id, content FROM items, plainto_tsquery('hello search') query\n    WHERE textsearch @@ query ORDER BY ts_rank_cd(textsearch, query) DESC LIMIT 5;\n```\n\nYou can use [Reciprocal Rank Fusion](https://github.com/pgvector/pgvector-python/blob/master/examples/hybrid_search/rrf.py) or a [cross-encoder](https://github.com/pgvector/pgvector-python/blob/master/examples/hybrid_search/cross_encoder.py) to combine results.\n\n## Indexing Subvectors\n\n*Added in 0.7.0*\n\nUse expression indexing to index subvectors\n\n```sql\nCREATE INDEX ON items USING hnsw ((subvector(embedding, 1, 3)::vector(3)) vector_cosine_ops);\n```\n\nGet the nearest neighbors by cosine distance\n\n```sql\nSELECT * FROM items ORDER BY subvector(embedding, 1, 3)::vector(3) <=> subvector('[1,2,3,4,5]'::vector, 1, 3) LIMIT 5;\n```\n\nRe-rank by the full vectors for better recall\n\n```sql\nSELECT * FROM (\n    SELECT * FROM items ORDER BY subvector(embedding, 1, 3)::vector(3) <=> subvector('[1,2,3,4,5]'::vector, 1, 3) LIMIT 20\n) ORDER BY embedding <=> '[1,2,3,4,5]' LIMIT 5;\n```\n\n## Performance\n\n### Tuning\n\nUse a tool like [PgTune](https://pgtune.leopard.in.ua/) to set initial values for Postgres server parameters. For instance, `shared_buffers` should typically be 25% of the server’s memory. You can find the config file with:\n\n```sql\nSHOW config_file;\n```\n\nAnd check individual settings with:\n\n```sql\nSHOW shared_buffers;\n```\n\nBe sure to restart Postgres for changes to take effect.\n\n### Loading\n\nUse `COPY` for bulk loading data ([example](https://github.com/pgvector/pgvector-python/blob/master/examples/loading/example.py)).\n\n```sql\nCOPY items (embedding) FROM STDIN WITH (FORMAT BINARY);\n```\n\nAdd any indexes *after* loading the initial data for best performance.\n\n### Indexing\n\nSee index build time for [HNSW](#index-build-time) and [IVFFlat](#index-build-time-1).\n\nIn production environments, create indexes concurrently to avoid blocking writes.\n\n```sql\nCREATE INDEX CONCURRENTLY ...\n```\n\n### Querying\n\nUse `EXPLAIN ANALYZE` to debug performance.\n\n```sql\nEXPLAIN ANALYZE SELECT * FROM items ORDER BY embedding <-> '[3,1,2]' LIMIT 5;\n```\n\n#### Exact Search\n\nTo speed up queries without an index, increase `max_parallel_workers_per_gather`.\n\n```sql\nSET max_parallel_workers_per_gather = 4;\n```\n\nIf vectors are normalized to length 1 (like [OpenAI embeddings](https://platform.openai.com/docs/guides/embeddings/which-distance-function-should-i-use)), use inner product for best performance.\n\n```tsql\nSELECT * FROM items ORDER BY embedding <#> '[3,1,2]' LIMIT 5;\n```\n\n#### Approximate Search\n\nTo speed up queries with an IVFFlat index, increase the number of inverted lists (at the expense of recall).\n\n```sql\nCREATE INDEX ON items USING ivfflat (embedding vector_l2_ops) WITH (lists = 1000);\n```\n\n### Vacuuming\n\nVacuuming can take a while for HNSW indexes. Speed it up by reindexing first.\n\n```sql\nREINDEX INDEX CONCURRENTLY index_name;\nVACUUM table_name;\n```\n\n## Monitoring\n\nMonitor performance with [pg_stat_statements](https://www.postgresql.org/docs/current/pgstatstatements.html) (be sure to add it to `shared_preload_libraries`).\n\n```sql\nCREATE EXTENSION pg_stat_statements;\n```\n\nGet the most time-consuming queries with:\n\n```sql\nSELECT query, calls, ROUND((total_plan_time + total_exec_time) / calls) AS avg_time_ms,\n    ROUND((total_plan_time + total_exec_time) / 60000) AS total_time_min\n    FROM pg_stat_statements ORDER BY total_plan_time + total_exec_time DESC LIMIT 20;\n```\n\nNote: Replace `total_plan_time + total_exec_time` with `total_time` for Postgres < 13\n\nMonitor recall by comparing results from approximate search with exact search.\n\n```sql\nBEGIN;\nSET LOCAL enable_indexscan = off; -- use exact search\nSELECT ...\nCOMMIT;\n```\n\n## Scaling\n\nScale pgvector the same way you scale Postgres.\n\nScale vertically by increasing memory, CPU, and storage on a single instance. Use existing tools to [tune parameters](#tuning) and [monitor performance](#monitoring).\n\nScale horizontally with [replicas](https://www.postgresql.org/docs/current/hot-standby.html), or use [Citus](https://github.com/citusdata/citus) or another approach for sharding ([example](https://github.com/pgvector/pgvector-python/blob/master/examples/citus/example.py)).\n\n## Languages\n\nUse pgvector from any language with a Postgres client. You can even generate and store vectors in one language and query them in another.\n\nLanguage | Libraries / Examples\n--- | ---\nC | [pgvector-c](https://github.com/pgvector/pgvector-c)\nC++ | [pgvector-cpp](https://github.com/pgvector/pgvector-cpp)\nC#, F#, Visual Basic | [pgvector-dotnet](https://github.com/pgvector/pgvector-dotnet)\nCrystal | [pgvector-crystal](https://github.com/pgvector/pgvector-crystal)\nD | [pgvector-d](https://github.com/pgvector/pgvector-d)\nDart | [pgvector-dart](https://github.com/pgvector/pgvector-dart)\nElixir | [pgvector-elixir](https://github.com/pgvector/pgvector-elixir)\nErlang | [pgvector-erlang](https://github.com/pgvector/pgvector-erlang)\nFortran | [pgvector-fortran](https://github.com/pgvector/pgvector-fortran)\nGleam | [pgvector-gleam](https://github.com/pgvector/pgvector-gleam)\nGo | [pgvector-go](https://github.com/pgvector/pgvector-go)\nHaskell | [pgvector-haskell](https://github.com/pgvector/pgvector-haskell)\nJava, Kotlin, Groovy, Scala | [pgvector-java](https://github.com/pgvector/pgvector-java)\nJavaScript, TypeScript | [pgvector-node](https://github.com/pgvector/pgvector-node)\nJulia | [pgvector-julia](https://github.com/pgvector/pgvector-julia)\nLisp | [pgvector-lisp](https://github.com/pgvector/pgvector-lisp)\nLua | [pgvector-lua](https://github.com/pgvector/pgvector-lua)\nNim | [pgvector-nim](https://github.com/pgvector/pgvector-nim)\nOCaml | [pgvector-ocaml](https://github.com/pgvector/pgvector-ocaml)\nPerl | [pgvector-perl](https://github.com/pgvector/pgvector-perl)\nPHP | [pgvector-php](https://github.com/pgvector/pgvector-php)\nPython | [pgvector-python](https://github.com/pgvector/pgvector-python)\nR | [pgvector-r](https://github.com/pgvector/pgvector-r)\nRaku | [pgvector-raku](https://github.com/pgvector/pgvector-raku)\nRuby | [pgvector-ruby](https://github.com/pgvector/pgvector-ruby), [Neighbor](https://github.com/ankane/neighbor)\nRust | [pgvector-rust](https://github.com/pgvector/pgvector-rust)\nSwift | [pgvector-swift](https://github.com/pgvector/pgvector-swift)\nZig | [pgvector-zig](https://github.com/pgvector/pgvector-zig)\n\n## Frequently Asked Questions\n\n#### How many vectors can be stored in a single table?\n\nA non-partitioned table has a limit of 32 TB by default in Postgres. A partitioned table can have thousands of partitions of that size.\n\n#### Is replication supported?\n\nYes, pgvector uses the write-ahead log (WAL), which allows for replication and point-in-time recovery.\n\n#### What if I want to index vectors with more than 2,000 dimensions?\n\nYou can use [half-precision indexing](#half-precision-indexing) to index up to 4,000 dimensions or [binary quantization](#binary-quantization) to index up to 64,000 dimensions. Another option is [dimensionality reduction](https://en.wikipedia.org/wiki/Dimensionality_reduction).\n\n#### Can I store vectors with different dimensions in the same column?\n\nYou can use `vector` as the type (instead of `vector(3)`).\n\n```sql\nCREATE TABLE embeddings (model_id bigint, item_id bigint, embedding vector, PRIMARY KEY (model_id, item_id));\n```\n\nHowever, you can only create indexes on rows with the same number of dimensions (using [expression](https://www.postgresql.org/docs/current/indexes-expressional.html) and [partial](https://www.postgresql.org/docs/current/indexes-partial.html) indexing):\n\n```sql\nCREATE INDEX ON embeddings USING hnsw ((embedding::vector(3)) vector_l2_ops) WHERE (model_id = 123);\n```\n\nand query with:\n\n```sql\nSELECT * FROM embeddings WHERE model_id = 123 ORDER BY embedding::vector(3) <-> '[3,1,2]' LIMIT 5;\n```\n\n#### Can I store vectors with more precision?\n\nYou can use the `double precision[]` or `numeric[]` type to store vectors with more precision.\n\n```sql\nCREATE TABLE items (id bigserial PRIMARY KEY, embedding double precision[]);\n\n-- use {} instead of [] for Postgres arrays\nINSERT INTO items (embedding) VALUES ('{1,2,3}'), ('{4,5,6}');\n```\n\nOptionally, add a [check constraint](https://www.postgresql.org/docs/current/ddl-constraints.html) to ensure data can be converted to the `vector` type and has the expected dimensions.\n\n```sql\nALTER TABLE items ADD CHECK (vector_dims(embedding::vector) = 3);\n```\n\nUse [expression indexing](https://www.postgresql.org/docs/current/indexes-expressional.html) to index (at a lower precision):\n\n```sql\nCREATE INDEX ON items USING hnsw ((embedding::vector(3)) vector_l2_ops);\n```\n\nand query with:\n\n```sql\nSELECT * FROM items ORDER BY embedding::vector(3) <-> '[3,1,2]' LIMIT 5;\n```\n\n#### Do indexes need to fit into memory?\n\nNo, but like other index types, you’ll likely see better performance if they do. You can get the size of an index with:\n\n```sql\nSELECT pg_size_pretty(pg_relation_size('index_name'));\n```\n\n## Troubleshooting\n\n#### Why isn’t a query using an index?\n\nThe query needs to have an `ORDER BY` and `LIMIT`, and the `ORDER BY` must be the result of a distance operator (not an expression) in ascending order.\n\n```sql\n-- index\nORDER BY embedding <=> '[3,1,2]' LIMIT 5;\n\n-- no index\nORDER BY 1 - (embedding <=> '[3,1,2]') DESC LIMIT 5;\n```\n\nYou can encourage the planner to use an index for a query with:\n\n```sql\nBEGIN;\nSET LOCAL enable_seqscan = off;\nSELECT ...\nCOMMIT;\n```\n\nAlso, if the table is small, a table scan may be faster.\n\n#### Why isn’t a query using a parallel table scan?\n\nThe planner doesn’t consider [out-of-line storage](https://www.postgresql.org/docs/current/storage-toast.html) in cost estimates, which can make a serial scan look cheaper. You can reduce the cost of a parallel scan for a query with:\n\n```sql\nBEGIN;\nSET LOCAL min_parallel_table_scan_size = 1;\nSET LOCAL parallel_setup_cost = 1;\nSELECT ...\nCOMMIT;\n```\n\nor choose to store vectors inline:\n\n```sql\nALTER TABLE items ALTER COLUMN embedding SET STORAGE PLAIN;\n```\n\n#### Why are there less results for a query after adding an HNSW index?\n\nResults are limited by the size of the dynamic candidate list (`hnsw.ef_search`), which is 40 by default. There may be even less results due to dead tuples or filtering conditions in the query. Enabling [iterative index scans](#iterative-index-scans) can help address this.\n\nAlso, note that `NULL` vectors are not indexed (as well as zero vectors for cosine distance).\n\n#### Why are there less results for a query after adding an IVFFlat index?\n\nThe index was likely created with too little data for the number of lists. Drop the index until the table has more data.\n\n```sql\nDROP INDEX index_name;\n```\n\nResults can also be limited by the number of probes (`ivfflat.probes`). Enabling [iterative index scans](#iterative-index-scans) can address this.\n\nAlso, note that `NULL` vectors are not indexed (as well as zero vectors for cosine distance).\n\n## Reference\n\n- [Vector](#vector-type)\n- [Halfvec](#halfvec-type)\n- [Bit](#bit-type)\n- [Sparsevec](#sparsevec-type)\n\n### Vector Type\n\nEach vector takes `4 * dimensions + 8` bytes of storage. Each element is a single-precision floating-point number (like the `real` type in Postgres), and all elements must be finite (no `NaN`, `Infinity` or `-Infinity`). Vectors can have up to 16,000 dimensions.\n\n### Vector Operators\n\nOperator | Description | Added\n--- | --- | ---\n\\+ | element-wise addition |\n\\- | element-wise subtraction |\n\\* | element-wise multiplication | 0.5.0\n\\|\\| | concatenate | 0.7.0\n<-> | Euclidean distance |\n<#> | negative inner product |\n<=> | cosine distance |\n<+> | taxicab distance | 0.7.0\n\n### Vector Functions\n\nFunction | Description | Added\n--- | --- | ---\nbinary_quantize(vector) → bit | binary quantize | 0.7.0\ncosine_distance(vector, vector) → double precision | cosine distance |\ninner_product(vector, vector) → double precision | inner product |\nl1_distance(vector, vector) → double precision | taxicab distance | 0.5.0\nl2_distance(vector, vector) → double precision | Euclidean distance |\nl2_normalize(vector) → vector | Normalize with Euclidean norm | 0.7.0\nsubvector(vector, integer, integer) → vector | subvector | 0.7.0\nvector_dims(vector) → integer | number of dimensions |\nvector_norm(vector) → double precision | Euclidean norm |\n\n### Vector Aggregate Functions\n\nFunction | Description | Added\n--- | --- | ---\navg(vector) → vector | average |\nsum(vector) → vector | sum | 0.5.0\n\n### Halfvec Type\n\nEach half vector takes `2 * dimensions + 8` bytes of storage. Each element is a half-precision floating-point number, and all elements must be finite (no `NaN`, `Infinity` or `-Infinity`). Half vectors can have up to 16,000 dimensions.\n\n### Halfvec Operators\n\nOperator | Description | Added\n--- | --- | ---\n\\+ | element-wise addition | 0.7.0\n\\- | element-wise subtraction | 0.7.0\n\\* | element-wise multiplication | 0.7.0\n\\|\\| | concatenate | 0.7.0\n<-> | Euclidean distance | 0.7.0\n<#> | negative inner product | 0.7.0\n<=> | cosine distance | 0.7.0\n<+> | taxicab distance | 0.7.0\n\n### Halfvec Functions\n\nFunction | Description | Added\n--- | --- | ---\nbinary_quantize(halfvec) → bit | binary quantize | 0.7.0\ncosine_distance(halfvec, halfvec) → double precision | cosine distance | 0.7.0\ninner_product(halfvec, halfvec) → double precision | inner product | 0.7.0\nl1_distance(halfvec, halfvec) → double precision | taxicab distance | 0.7.0\nl2_distance(halfvec, halfvec) → double precision | Euclidean distance | 0.7.0\nl2_norm(halfvec) → double precision | Euclidean norm | 0.7.0\nl2_normalize(halfvec) → halfvec | Normalize with Euclidean norm | 0.7.0\nsubvector(halfvec, integer, integer) → halfvec | subvector | 0.7.0\nvector_dims(halfvec) → integer | number of dimensions | 0.7.0\n\n### Halfvec Aggregate Functions\n\nFunction | Description | Added\n--- | --- | ---\navg(halfvec) → halfvec | average | 0.7.0\nsum(halfvec) → halfvec | sum | 0.7.0\n\n### Bit Type\n\nEach bit vector takes `dimensions / 8 + 8` bytes of storage. See the [Postgres docs](https://www.postgresql.org/docs/current/datatype-bit.html) for more info.\n\n### Bit Operators\n\nOperator | Description | Added\n--- | --- | ---\n<~> | Hamming distance | 0.7.0\n<%> | Jaccard distance | 0.7.0\n\n### Bit Functions\n\nFunction | Description | Added\n--- | --- | ---\nhamming_distance(bit, bit) → double precision | Hamming distance | 0.7.0\njaccard_distance(bit, bit) → double precision | Jaccard distance | 0.7.0\n\n### Sparsevec Type\n\nEach sparse vector takes `8 * non-zero elements + 16` bytes of storage. Each element is a single-precision floating-point number, and all elements must be finite (no `NaN`, `Infinity` or `-Infinity`). Sparse vectors can have up to 16,000 non-zero elements.\n\n### Sparsevec Operators\n\nOperator | Description | Added\n--- | --- | ---\n<-> | Euclidean distance | 0.7.0\n<#> | negative inner product | 0.7.0\n<=> | cosine distance | 0.7.0\n<+> | taxicab distance | 0.7.0\n\n### Sparsevec Functions\n\nFunction | Description | Added\n--- | --- | ---\ncosine_distance(sparsevec, sparsevec) → double precision | cosine distance | 0.7.0\ninner_product(sparsevec, sparsevec) → double precision | inner product | 0.7.0\nl1_distance(sparsevec, sparsevec) → double precision | taxicab distance | 0.7.0\nl2_distance(sparsevec, sparsevec) → double precision | Euclidean distance | 0.7.0\nl2_norm(sparsevec) → double precision | Euclidean norm | 0.7.0\nl2_normalize(sparsevec) → sparsevec | Normalize with Euclidean norm | 0.7.0\n\n## Installation Notes - Linux and Mac\n\n### Postgres Location\n\nIf your machine has multiple Postgres installations, specify the path to [pg_config](https://www.postgresql.org/docs/current/app-pgconfig.html) with:\n\n```sh\nexport PG_CONFIG=/Library/PostgreSQL/17/bin/pg_config\n```\n\nThen re-run the installation instructions (run `make clean` before `make` if needed). If `sudo` is needed for `make install`, use:\n\n```sh\nsudo --preserve-env=PG_CONFIG make install\n```\n\nA few common paths on Mac are:\n\n- EDB installer - `/Library/PostgreSQL/17/bin/pg_config`\n- Homebrew (arm64) - `/opt/homebrew/opt/postgresql@17/bin/pg_config`\n- Homebrew (x86-64) - `/usr/local/opt/postgresql@17/bin/pg_config`\n\nNote: Replace `17` with your Postgres server version\n\n### Missing Header\n\nIf compilation fails with `fatal error: postgres.h: No such file or directory`, make sure Postgres development files are installed on the server.\n\nFor Ubuntu and Debian, use:\n\n```sh\nsudo apt install postgresql-server-dev-17\n```\n\nNote: Replace `17` with your Postgres server version\n\n### Missing SDK\n\nIf compilation fails and the output includes `warning: no such sysroot directory` on Mac, reinstall Xcode Command Line Tools.\n\n### Portability\n\nBy default, pgvector compiles with `-march=native` on some platforms for best performance. However, this can lead to `Illegal instruction` errors if trying to run the compiled extension on a different machine.\n\nTo compile for portability, use:\n\n```sh\nmake OPTFLAGS=\"\"\n```\n\n## Installation Notes - Windows\n\n### Missing Header\n\nIf compilation fails with `Cannot open include file: 'postgres.h': No such file or directory`, make sure `PGROOT` is correct.\n\n### Permissions\n\nIf installation fails with `Access is denied`, re-run the installation instructions as an administrator.\n\n## Additional Installation Methods\n\n### Docker\n\nGet the [Docker image](https://hub.docker.com/r/pgvector/pgvector) with:\n\n```sh\ndocker pull pgvector/pgvector:pg17\n```\n\nThis adds pgvector to the [Postgres image](https://hub.docker.com/_/postgres) (replace `17` with your Postgres server version, and run it the same way).\n\nYou can also build the image manually:\n\n```sh\ngit clone --branch v0.8.0 https://github.com/pgvector/pgvector.git\ncd pgvector\ndocker build --pull --build-arg PG_MAJOR=17 -t myuser/pgvector .\n```\n\n### Homebrew\n\nWith Homebrew Postgres, you can use:\n\n```sh\nbrew install pgvector\n```\n\nNote: This only adds it to the `postgresql@17` and `postgresql@14` formulas\n\n### PGXN\n\nInstall from the [PostgreSQL Extension Network](https://pgxn.org/dist/vector) with:\n\n```sh\npgxn install vector\n```\n\n### APT\n\nDebian and Ubuntu packages are available from the [PostgreSQL APT Repository](https://wiki.postgresql.org/wiki/Apt). Follow the [setup instructions](https://wiki.postgresql.org/wiki/Apt#Quickstart) and run:\n\n```sh\nsudo apt install postgresql-17-pgvector\n```\n\nNote: Replace `17` with your Postgres server version\n\n### Yum\n\nRPM packages are available from the [PostgreSQL Yum Repository](https://yum.postgresql.org/). Follow the [setup instructions](https://www.postgresql.org/download/linux/redhat/) for your distribution and run:\n\n```sh\nsudo yum install pgvector_17\n# or\nsudo dnf install pgvector_17\n```\n\nNote: Replace `17` with your Postgres server version\n\n### pkg\n\nInstall the FreeBSD package with:\n\n```sh\npkg install postgresql16-pgvector\n```\n\nor the port with:\n\n```sh\ncd /usr/ports/databases/pgvector\nmake install\n```\n\n### conda-forge\n\nWith Conda Postgres, install from [conda-forge](https://anaconda.org/conda-forge/pgvector) with:\n\n```sh\nconda install -c conda-forge pgvector\n```\n\nThis method is [community-maintained](https://github.com/conda-forge/pgvector-feedstock) by [@mmcauliffe](https://github.com/mmcauliffe)\n\n### Postgres.app\n\nDownload the [latest release](https://postgresapp.com/downloads.html) with Postgres 15+.\n\n## Hosted Postgres\n\npgvector is available on [these providers](https://github.com/pgvector/pgvector/issues/54).\n\n## Upgrading\n\n[Install](#installation) the latest version (use the same method as the original installation). Then in each database you want to upgrade, run:\n\n```sql\nALTER EXTENSION vector UPDATE;\n```\n\nYou can check the version in the current database with:\n\n```sql\nSELECT extversion FROM pg_extension WHERE extname = 'vector';\n```\n\n## Upgrade Notes\n\n### 0.6.0\n\n#### Postgres 12\n\nIf upgrading with Postgres 12, remove this line from `sql/vector--0.5.1--0.6.0.sql`:\n\n```sql\nALTER TYPE vector SET (STORAGE = external);\n```\n\nThen run `make install` and `ALTER EXTENSION vector UPDATE;`.\n\n#### Docker\n\nThe Docker image is now published in the `pgvector` org, and there are tags for each supported version of Postgres (rather than a `latest` tag).\n\n```sh\ndocker pull pgvector/pgvector:pg16\n# or\ndocker pull pgvector/pgvector:0.6.0-pg16\n```\n\nAlso, if you’ve increased `maintenance_work_mem`, make sure `--shm-size` is at least that size to avoid an error with parallel HNSW index builds.\n\n```sh\ndocker run --shm-size=1g ...\n```\n\n## Thanks\n\nThanks to:\n\n- [PASE: PostgreSQL Ultra-High-Dimensional Approximate Nearest Neighbor Search Extension](https://dl.acm.org/doi/pdf/10.1145/3318464.3386131)\n- [Faiss: A Library for Efficient Similarity Search and Clustering of Dense Vectors](https://github.com/facebookresearch/faiss)\n- [Using the Triangle Inequality to Accelerate k-means](https://cdn.aaai.org/ICML/2003/ICML03-022.pdf)\n- [k-means++: The Advantage of Careful Seeding](https://theory.stanford.edu/~sergei/papers/kMeansPP-soda.pdf)\n- [Concept Decompositions for Large Sparse Text Data using Clustering](https://www.cs.utexas.edu/users/inderjit/public_papers/concept_mlj.pdf)\n- [Efficient and Robust Approximate Nearest Neighbor Search using Hierarchical Navigable Small World Graphs](https://arxiv.org/ftp/arxiv/papers/1603/1603.09320.pdf)\n\n## History\n\nView the [changelog](https://github.com/pgvector/pgvector/blob/master/CHANGELOG.md)\n\n## Contributing\n\nEveryone is encouraged to help improve this project. Here are a few ways you can help:\n\n- [Report bugs](https://github.com/pgvector/pgvector/issues)\n- Fix bugs and [submit pull requests](https://github.com/pgvector/pgvector/pulls)\n- Write, clarify, or fix documentation\n- Suggest or add new features\n\nTo get started with development:\n\n```sh\ngit clone https://github.com/pgvector/pgvector.git\ncd pgvector\nmake\nmake install\n```\n\nTo run all tests:\n\n```sh\nmake installcheck        # regression tests\nmake prove_installcheck  # TAP tests\n```\n\nTo run single tests:\n\n```sh\nmake installcheck REGRESS=functions                            # regression test\nmake prove_installcheck PROVE_TESTS=test/t/001_ivfflat_wal.pl  # TAP test\n```\n\nTo enable assertions:\n\n```sh\nmake clean && PG_CFLAGS=\"-DUSE_ASSERT_CHECKING\" make && make install\n```\n\nTo enable benchmarking:\n\n```sh\nmake clean && PG_CFLAGS=\"-DIVFFLAT_BENCH\" make && make install\n```\n\nTo show memory usage:\n\n```sh\nmake clean && PG_CFLAGS=\"-DHNSW_MEMORY -DIVFFLAT_MEMORY\" make && make install\n```\n\nTo get k-means metrics:\n\n```sh\nmake clean && PG_CFLAGS=\"-DIVFFLAT_KMEANS_DEBUG\" make && make install\n```\n\nResources for contributors\n\n- [Extension Building Infrastructure](https://www.postgresql.org/docs/current/extend-pgxs.html)\n- [Index Access Method Interface Definition](https://www.postgresql.org/docs/current/indexam.html)\n- [Generic WAL Records](https://www.postgresql.org/docs/current/generic-wal.html)\n"
        },
        {
          "name": "sql",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "vector.control",
          "type": "blob",
          "size": 0.1416015625,
          "content": "comment = 'vector data type and ivfflat and hnsw access methods'\ndefault_version = '0.8.0'\nmodule_pathname = '$libdir/vector'\nrelocatable = true\n"
        }
      ]
    }
  ]
}