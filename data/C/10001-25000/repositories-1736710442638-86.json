{
  "metadata": {
    "timestamp": 1736710442638,
    "page": 86,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "microsoft/mimalloc",
      "stars": 10809,
      "defaultBranch": "dev",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.2041015625,
          "content": "# default behavior is to always use unix style line endings\n* text eol=lf\n*.png binary\n*.pdn binary\n*.jpg binary\n*.sln binary\n*.suo binary\n*.vcproj binary\n*.patch binary\n*.dll binary\n*.lib binary\n*.exe binary\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1357421875,
          "content": "build\nide/vs20??/*.db\nide/vs20??/*.opendb\nide/vs20??/*.user\nide/vs20??/.vs\nide/vs20??/VTune*\nout/\ndocs/\n*.zip\n*.tar\n*.gz\n.vscode\n.DS_STore\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 28.1435546875,
          "content": "cmake_minimum_required(VERSION 3.18)\nproject(libmimalloc C CXX)\n\nset(CMAKE_C_STANDARD 11)\nset(CMAKE_CXX_STANDARD 17)\n\noption(MI_SECURE            \"Use full security mitigations (like guard pages, allocation randomization, double-free mitigation, and free-list corruption detection)\" OFF)\noption(MI_DEBUG_FULL        \"Use full internal heap invariant checking in DEBUG mode (expensive)\" OFF)\noption(MI_PADDING           \"Enable padding to detect heap block overflow (always on in DEBUG or SECURE mode, or with Valgrind/ASAN)\" OFF)\noption(MI_OVERRIDE          \"Override the standard malloc interface (i.e. define entry points for 'malloc', 'free', etc)\" ON)\noption(MI_XMALLOC           \"Enable abort() call on memory allocation failure by default\" OFF)\noption(MI_SHOW_ERRORS       \"Show error and warning messages by default (only enabled by default in DEBUG mode)\" OFF)\noption(MI_TRACK_VALGRIND    \"Compile with Valgrind support (adds a small overhead)\" OFF)\noption(MI_TRACK_ASAN        \"Compile with address sanitizer support (adds a small overhead)\" OFF)\noption(MI_TRACK_ETW         \"Compile with Windows event tracing (ETW) support (adds a small overhead)\" OFF)\noption(MI_USE_CXX           \"Use the C++ compiler to compile the library (instead of the C compiler)\" OFF)\noption(MI_OPT_ARCH          \"Only for optimized builds: turn on architecture specific optimizations (for arm64: '-march=armv8.1-a' (2016))\" ON)\noption(MI_SEE_ASM           \"Generate assembly files\" OFF)\noption(MI_OSX_INTERPOSE     \"Use interpose to override standard malloc on macOS\" ON)\noption(MI_OSX_ZONE          \"Use malloc zone to override standard malloc on macOS\" ON)\noption(MI_WIN_REDIRECT      \"Use redirection module ('mimalloc-redirect') on Windows if compiling mimalloc as a DLL\" ON)\noption(MI_WIN_USE_FIXED_TLS \"Use a fixed TLS slot on Windows to avoid extra tests in the malloc fast path\" OFF)\noption(MI_LOCAL_DYNAMIC_TLS \"Use local-dynamic-tls, a slightly slower but dlopen-compatible thread local storage mechanism (Unix)\" OFF)\noption(MI_LIBC_MUSL         \"Set this when linking with musl libc\" OFF)\noption(MI_BUILD_SHARED      \"Build shared library\" ON)\noption(MI_BUILD_STATIC      \"Build static library\" ON)\noption(MI_BUILD_OBJECT      \"Build object library\" ON)\noption(MI_BUILD_TESTS       \"Build test executables\" ON)\noption(MI_DEBUG_TSAN        \"Build with thread sanitizer (needs clang)\" OFF)\noption(MI_DEBUG_UBSAN       \"Build with undefined-behavior sanitizer (needs clang++)\" OFF)\noption(MI_GUARDED           \"Build with guard pages behind certain object allocations (implies MI_NO_PADDING=ON)\" OFF)\noption(MI_SKIP_COLLECT_ON_EXIT \"Skip collecting memory on program exit\" OFF)\noption(MI_NO_PADDING        \"Force no use of padding even in DEBUG mode etc.\" OFF)\noption(MI_INSTALL_TOPLEVEL  \"Install directly into $CMAKE_INSTALL_PREFIX instead of PREFIX/lib/mimalloc-version\" OFF)\noption(MI_NO_THP            \"Disable transparent huge pages support on Linux/Android for the mimalloc process only\" OFF)\noption(MI_EXTRA_CPPDEFS     \"Extra pre-processor definitions (use as `-DMI_EXTRA_CPPDEFS=\\\"opt1=val1;opt2=val2\\\"`)\" \"\")\n\n# negated options for vcpkg features\noption(MI_NO_USE_CXX        \"Use plain C compilation (has priority over MI_USE_CXX)\" OFF)\noption(MI_NO_OPT_ARCH       \"Do not use architecture specific optimizations (like '-march=armv8.1-a' for example) (has priority over MI_OPT_ARCH)\" OFF)\n\n# deprecated options\noption(MI_WIN_USE_FLS       \"Use Fiber local storage on Windows to detect thread termination (deprecated)\" OFF)\noption(MI_CHECK_FULL        \"Use full internal invariant checking in DEBUG mode (deprecated, use MI_DEBUG_FULL instead)\" OFF)\noption(MI_USE_LIBATOMIC     \"Explicitly link with -latomic (on older systems) (deprecated and detected automatically)\" OFF)\n\ninclude(CheckLinkerFlag)    # requires cmake 3.18\ninclude(CheckIncludeFiles)\ninclude(GNUInstallDirs)\ninclude(\"cmake/mimalloc-config-version.cmake\")\n\nset(mi_sources\n    src/alloc.c\n    src/alloc-aligned.c\n    src/alloc-posix.c\n    src/arena.c\n    src/bitmap.c\n    src/heap.c\n    src/init.c\n    src/libc.c\n    src/options.c\n    src/os.c\n    src/page.c\n    src/random.c\n    src/segment.c\n    src/segment-map.c\n    src/stats.c\n    src/prim/prim.c)\n\nset(mi_cflags \"\")\nset(mi_cflags_static \"\")            # extra flags for a static library build\nset(mi_cflags_dynamic \"\")           # extra flags for a shared-object library build\nset(mi_libraries \"\")\n\nif(MI_EXTRA_CPPDEFS)\n set(mi_defines ${MI_EXTRA_CPPDEFS})\nelse()\n set(mi_defines \"\")\nendif()\n\n# -----------------------------------------------------------------------------\n# Convenience: set default build type and compiler depending on the build directory\n# -----------------------------------------------------------------------------\n\nmessage(STATUS \"\")\nif (NOT CMAKE_BUILD_TYPE)\n  if (\"${CMAKE_BINARY_DIR}\" MATCHES \".*((D|d)ebug|asan|tsan|ubsan|valgrind)$\" OR MI_DEBUG_FULL)\n    message(STATUS \"No build type selected, default to 'Debug'\")\n    set(CMAKE_BUILD_TYPE \"Debug\")\n  else()\n    message(STATUS \"No build type selected, default to 'Release'\")\n    set(CMAKE_BUILD_TYPE \"Release\")\n  endif()\nendif()\n\nif (CMAKE_GENERATOR MATCHES \"^Visual Studio.*$\")\n  message(STATUS \"Note: when building with Visual Studio the build type is specified when building.\")\n  message(STATUS \"For example: 'cmake --build . --config=Release\")\nendif()\n\nif(\"${CMAKE_BINARY_DIR}\" MATCHES \".*(S|s)ecure$\")\n  message(STATUS \"Default to secure build\")\n  set(MI_SECURE \"ON\")\nendif()\n\n# -----------------------------------------------------------------------------\n# Process options\n# -----------------------------------------------------------------------------\nif(CMAKE_C_COMPILER_ID STREQUAL \"Clang\" AND CMAKE_CXX_COMPILER_FRONTEND_VARIANT STREQUAL \"MSVC\")\n  set(MI_CLANG_CL \"ON\")\nendif()\n\n# put -Wall early so other warnings can be disabled selectively\nif(CMAKE_C_COMPILER_ID MATCHES \"AppleClang|Clang\")\n  if (MI_CLANG_CL)\n    list(APPEND mi_cflags -W)\n  else()\n    list(APPEND mi_cflags -Wall -Wextra -Wpedantic)\n  endif()\nendif()\nif(CMAKE_C_COMPILER_ID MATCHES \"GNU\")\n    list(APPEND mi_cflags -Wall -Wextra)\nendif()\nif(CMAKE_C_COMPILER_ID MATCHES \"Intel\")\n    list(APPEND mi_cflags -Wall)\nendif()\n\n# negative overrides (mainly to support vcpkg features)\nif(MI_NO_USE_CXX) \n  set(MI_USE_CXX \"OFF\")\nendif()\nif(MI_NO_OPT_ARCH)\n  set(MI_OPT_ARCH \"OFF\")\nendif()\n\n\nif(CMAKE_C_COMPILER_ID MATCHES \"MSVC|Intel\")\n  set(MI_USE_CXX \"ON\")\nendif()\n\nif(CMAKE_BUILD_TYPE MATCHES \"Release|RelWithDebInfo\")\n  if (NOT MI_OPT_ARCH)\n    message(STATUS \"Architecture specific optimizations are disabled (MI_OPT_ARCH=OFF)\")\n  endif()\nelse()\n  set(MI_OPT_ARCH OFF)\nendif()\n\nif(MI_OVERRIDE)\n  message(STATUS \"Override standard malloc (MI_OVERRIDE=ON)\")\n  if(APPLE)\n    if(MI_OSX_ZONE)\n      # use zone's on macOS\n      message(STATUS \"  Use malloc zone to override malloc (MI_OSX_ZONE=ON)\")\n      list(APPEND mi_sources src/prim/osx/alloc-override-zone.c)\n      list(APPEND mi_defines MI_OSX_ZONE=1)\n      if (NOT MI_OSX_INTERPOSE)\n        message(STATUS \"  WARNING: zone overriding usually also needs interpose (use -DMI_OSX_INTERPOSE=ON)\")\n      endif()\n    endif()\n    if(MI_OSX_INTERPOSE)\n      # use interpose on macOS\n      message(STATUS \"  Use interpose to override malloc (MI_OSX_INTERPOSE=ON)\")\n      list(APPEND mi_defines MI_OSX_INTERPOSE=1)\n      if (NOT MI_OSX_ZONE)\n        message(STATUS \"  WARNING: interpose usually also needs zone overriding (use -DMI_OSX_INTERPOSE=ON)\")\n      endif()\n    endif()\n    if(MI_USE_CXX AND MI_OSX_INTERPOSE)\n      message(STATUS \"  WARNING: if dynamically overriding malloc/free, it is more reliable to build mimalloc as C code (use -DMI_USE_CXX=OFF)\")\n    endif()\n  endif()\nendif()\n\nif(WIN32)\n  if (NOT MI_WIN_REDIRECT)\n    # use a negative define for backward compatibility\n    list(APPEND mi_defines MI_WIN_NOREDIRECT=1)\n  endif()\nendif()\n\nif(MI_SECURE)\n  message(STATUS \"Set full secure build (MI_SECURE=ON)\")\n  list(APPEND mi_defines MI_SECURE=4)\nendif()\n\nif(MI_TRACK_VALGRIND)\n  CHECK_INCLUDE_FILES(\"valgrind/valgrind.h;valgrind/memcheck.h\" MI_HAS_VALGRINDH)\n  if (NOT MI_HAS_VALGRINDH)\n    set(MI_TRACK_VALGRIND OFF)\n    message(WARNING \"Cannot find the 'valgrind/valgrind.h' and 'valgrind/memcheck.h' -- install valgrind first?\")\n    message(STATUS  \"Disabling Valgrind support (MI_TRACK_VALGRIND=OFF)\")\n  else()\n    message(STATUS \"Compile with Valgrind support (MI_TRACK_VALGRIND=ON)\")\n    list(APPEND mi_defines MI_TRACK_VALGRIND=1)\n  endif()\nendif()\n\nif(MI_TRACK_ASAN)\n  if (APPLE AND MI_OVERRIDE)\n    set(MI_TRACK_ASAN OFF)\n    message(WARNING \"Cannot enable address sanitizer support on macOS if MI_OVERRIDE is ON (MI_TRACK_ASAN=OFF)\")\n  endif()\n  if (MI_TRACK_VALGRIND)\n    set(MI_TRACK_ASAN OFF)\n    message(WARNING \"Cannot enable address sanitizer support with also Valgrind support enabled (MI_TRACK_ASAN=OFF)\")\n  endif()\n  if(MI_TRACK_ASAN)\n    CHECK_INCLUDE_FILES(\"sanitizer/asan_interface.h\" MI_HAS_ASANH)\n    if (NOT MI_HAS_ASANH)\n      set(MI_TRACK_ASAN OFF)\n      message(WARNING \"Cannot find the 'sanitizer/asan_interface.h' -- install address sanitizer support first\")\n      message(STATUS  \"Compile **without** address sanitizer support (MI_TRACK_ASAN=OFF)\")\n    else()\n      message(STATUS \"Compile with address sanitizer support (MI_TRACK_ASAN=ON)\")\n      list(APPEND mi_defines MI_TRACK_ASAN=1)\n      list(APPEND mi_cflags -fsanitize=address)\n      list(APPEND mi_libraries -fsanitize=address)\n    endif()\n  endif()\nendif()\n\nif(MI_TRACK_ETW)\n  if(NOT WIN32)\n    set(MI_TRACK_ETW OFF)\n    message(WARNING \"Can only enable ETW support on Windows (MI_TRACK_ETW=OFF)\")\n  endif()\n  if (MI_TRACK_VALGRIND OR MI_TRACK_ASAN)\n    set(MI_TRACK_ETW OFF)\n    message(WARNING \"Cannot enable ETW support with also Valgrind or ASAN support enabled (MI_TRACK_ETW=OFF)\")\n  endif()\n  if(MI_TRACK_ETW)\n    message(STATUS \"Compile with Windows event tracing support (MI_TRACK_ETW=ON)\")\n    list(APPEND mi_defines MI_TRACK_ETW=1)\n  endif()\nendif()\n\nif(MI_GUARDED)\n  message(STATUS \"Compile guard pages behind certain object allocations (MI_GUARDED=ON)\")\n  list(APPEND mi_defines MI_GUARDED=1)\n  if(NOT MI_NO_PADDING)\n    message(STATUS \"  Disabling padding due to guard pages (MI_NO_PADDING=ON)\")\n    set(MI_NO_PADDING ON)\n  endif()\nendif()\n\nif(MI_SEE_ASM)\n  message(STATUS \"Generate assembly listings (MI_SEE_ASM=ON)\")\n  list(APPEND mi_cflags -save-temps)\n  if(CMAKE_C_COMPILER_ID MATCHES \"AppleClang|Clang\")\n    message(STATUS \"No GNU Line marker\")\n    list(APPEND mi_cflags -Wno-gnu-line-marker)\n  endif()\nendif()\n\nif(MI_CHECK_FULL)\n  message(STATUS \"The MI_CHECK_FULL option is deprecated, use MI_DEBUG_FULL instead\")\n  set(MI_DEBUG_FULL \"ON\")\nendif()\n\nif (MI_SKIP_COLLECT_ON_EXIT)\n  message(STATUS \"Skip collecting memory on program exit (MI_SKIP_COLLECT_ON_EXIT=ON)\")\n  list(APPEND mi_defines MI_SKIP_COLLECT_ON_EXIT=1)\nendif()\n\nif(MI_DEBUG_FULL)\n  message(STATUS \"Set debug level to full internal invariant checking (MI_DEBUG_FULL=ON)\")\n  list(APPEND mi_defines MI_DEBUG=3)   # full invariant checking\nendif()\n\nif(MI_NO_PADDING)\n  message(STATUS \"Suppress any padding of heap blocks (MI_NO_PADDING=ON)\")\n  list(APPEND mi_defines MI_PADDING=0)\nelse()\n  if(MI_PADDING)\n    message(STATUS \"Enable explicit padding of heap blocks (MI_PADDING=ON)\")\n    list(APPEND mi_defines MI_PADDING=1)\n  endif()\nendif()\n\nif(MI_XMALLOC)\n  message(STATUS \"Enable abort() calls on memory allocation failure (MI_XMALLOC=ON)\")\n  list(APPEND mi_defines MI_XMALLOC=1)\nendif()\n\nif(MI_SHOW_ERRORS)\n  message(STATUS \"Enable printing of error and warning messages by default (MI_SHOW_ERRORS=ON)\")\n  list(APPEND mi_defines MI_SHOW_ERRORS=1)\nendif()\n\nif(MI_DEBUG_TSAN)\n  if(CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n    message(STATUS \"Build with thread sanitizer (MI_DEBUG_TSAN=ON)\")\n    list(APPEND mi_defines MI_TSAN=1)\n    list(APPEND mi_cflags -fsanitize=thread -g -O1)\n    list(APPEND mi_libraries -fsanitize=thread)\n  else()\n    message(WARNING \"Can only use thread sanitizer with clang (MI_DEBUG_TSAN=ON but ignored)\")\n  endif()\nendif()\n\nif(MI_DEBUG_UBSAN)\n  if(CMAKE_BUILD_TYPE MATCHES \"Debug\")\n    if(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n      message(STATUS \"Build with undefined-behavior sanitizer (MI_DEBUG_UBSAN=ON)\")\n      list(APPEND mi_defines MI_UBSAN=1)\n      list(APPEND mi_cflags -fsanitize=undefined -g -fno-sanitize-recover=undefined)\n      list(APPEND mi_libraries -fsanitize=undefined)\n      if (NOT MI_USE_CXX)\n        message(STATUS \"(switch to use C++ due to MI_DEBUG_UBSAN)\")\n        set(MI_USE_CXX \"ON\")\n      endif()\n    else()\n      message(WARNING \"Can only use undefined-behavior sanitizer with clang++ (MI_DEBUG_UBSAN=ON but ignored)\")\n    endif()\n  else()\n    message(WARNING \"Can only use undefined-behavior sanitizer with a debug build (CMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE})\")\n  endif()\nendif()\n\nif(MI_USE_CXX)\n  message(STATUS \"Use the C++ compiler to compile (MI_USE_CXX=ON)\")\n  set_source_files_properties(${mi_sources} PROPERTIES LANGUAGE CXX )\n  set_source_files_properties(src/static.c test/test-api.c test/test-api-fill test/test-stress PROPERTIES LANGUAGE CXX )\n  if(CMAKE_CXX_COMPILER_ID MATCHES \"AppleClang|Clang\")\n    list(APPEND mi_cflags -Wno-deprecated)\n  endif()\n  if(CMAKE_CXX_COMPILER_ID MATCHES \"Intel\" AND NOT CMAKE_CXX_COMPILER_ID MATCHES \"IntelLLVM\")\n    list(APPEND mi_cflags -Kc++)\n  endif()\nendif()\n\nif(CMAKE_SYSTEM_NAME MATCHES \"Linux|Android\")\n  if(MI_NO_THP)\n    message(STATUS \"Disable transparent huge pages support (MI_NO_THP=ON)\")\n    list(APPEND mi_defines MI_NO_THP=1)\n  endif()\nendif()\n\nif(MI_LIBC_MUSL)\n  message(STATUS \"Assume using musl libc (MI_LIBC_MUSL=ON)\")\n  list(APPEND mi_defines MI_LIBC_MUSL=1)\nendif()\n\nif(MI_WIN_USE_FLS)\n  message(STATUS \"Use the Fiber API to detect thread termination (deprecated) (MI_WIN_USE_FLS=ON)\")\n  list(APPEND mi_defines MI_WIN_USE_FLS=1)\nendif()\n\nif(MI_WIN_USE_FIXED_TLS)\n  message(STATUS \"Use fixed TLS slot on Windows to avoid extra tests in the malloc fast path (MI_WIN_USE_FIXED_TLS=ON)\")\n  list(APPEND mi_defines MI_WIN_USE_FIXED_TLS=1)\nendif()\n\n# Determine architecture\nset(MI_OPT_ARCH_FLAGS \"\")\nset(MI_ARCH \"unknown\")\nif(CMAKE_SYSTEM_PROCESSOR MATCHES \"^(x86|i[3456]86)$\" OR CMAKE_GENERATOR_PLATFORM MATCHES \"^(x86|Win32)$\")\n  set(MI_ARCH \"x86\")\nelseif(CMAKE_SYSTEM_PROCESSOR MATCHES \"^(x86_64|x64|amd64|AMD64)$\" OR CMAKE_GENERATOR_PLATFORM STREQUAL \"x64\") # must be before arm64\n  set(MI_ARCH \"x64\")\nelseif(CMAKE_SYSTEM_PROCESSOR MATCHES \"^(aarch64|arm64|armv8.?|ARM64)$\" OR CMAKE_GENERATOR_PLATFORM STREQUAL \"ARM64\")\n  set(MI_ARCH \"arm64\")\nelseif(CMAKE_SYSTEM_PROCESSOR MATCHES \"^(arm|armv[34567]|ARM)$\")\n  set(MI_ARCH \"arm32\")\nelseif(CMAKE_SYSTEM_PROCESSOR MATCHES \"^(riscv|riscv32|riscv64)$\")\n  if(CMAKE_SIZEOF_VOID_P==4)\n    set(MI_ARCH \"riscv32\")\n  else()\n    set(MI_ARCH \"riscv64\")\n  endif()\nelse()\n  set(MI_ARCH ${CMAKE_SYSTEM_PROCESSOR})\nendif()\nmessage(STATUS \"Architecture: ${MI_ARCH}\") # (${CMAKE_SYSTEM_PROCESSOR}, ${CMAKE_GENERATOR_PLATFORM}, ${CMAKE_GENERATOR})\")\n\n# Check /proc/cpuinfo for an SV39 MMU and limit the virtual address bits.\n# (this will skip the aligned hinting in that case. Issue #939, #949)\nif (EXISTS /proc/cpuinfo)\n  file(STRINGS /proc/cpuinfo mi_sv39_mmu REGEX \"^mmu[ \\t]+:[ \\t]+sv39$\")\n  if (mi_sv39_mmu)\n    MESSAGE( STATUS \"Set virtual address bits to 39 (SV39 MMU detected)\" )\n    list(APPEND mi_defines MI_DEFAULT_VIRTUAL_ADDRESS_BITS=39)\n  endif()\nendif()\n\n# On Haiku use `-DCMAKE_INSTALL_PREFIX` instead, issue #788\n# if(CMAKE_SYSTEM_NAME MATCHES \"Haiku\")\n#   SET(CMAKE_INSTALL_LIBDIR ~/config/non-packaged/lib)\n#   SET(CMAKE_INSTALL_INCLUDEDIR ~/config/non-packaged/headers)\n# endif()\n\n# Compiler flags\nif(CMAKE_C_COMPILER_ID MATCHES \"AppleClang|Clang|GNU\" AND NOT MI_CLANG_CL)\n  list(APPEND mi_cflags -Wno-unknown-pragmas -fvisibility=hidden)\n  if(NOT MI_USE_CXX)\n    list(APPEND mi_cflags -Wstrict-prototypes)\n  endif()\n  if(CMAKE_C_COMPILER_ID MATCHES \"AppleClang|Clang\")\n    list(APPEND mi_cflags -Wno-static-in-inline)\n  endif()\nendif()\n\nif(CMAKE_C_COMPILER_ID MATCHES \"Intel\")\n  list(APPEND mi_cflags -fvisibility=hidden)\nendif()\n\nif(CMAKE_C_COMPILER_ID MATCHES \"AppleClang|Clang|GNU|Intel\" AND NOT CMAKE_SYSTEM_NAME MATCHES \"Haiku\" AND NOT MI_CLANG_CL)\n  if(MI_LOCAL_DYNAMIC_TLS)\n    list(APPEND mi_cflags -ftls-model=local-dynamic)\n  else()\n    if(MI_LIBC_MUSL)\n      # with musl we use local-dynamic for the static build, see issue #644\n      list(APPEND mi_cflags_static  -ftls-model=local-dynamic)\n      list(APPEND mi_cflags_dynamic -ftls-model=initial-exec)\n      message(STATUS \"Use local dynamic TLS for the static build (since MI_LIBC_MUSL=ON)\")\n    else()\n      list(APPEND mi_cflags -ftls-model=initial-exec)\n    endif()\n  endif()\n  if(MI_OVERRIDE)\n    list(APPEND mi_cflags -fno-builtin-malloc)\n  endif()\nendif()\n\nif(CMAKE_C_COMPILER_ID MATCHES \"AppleClang|Clang|GNU|Intel\" AND NOT CMAKE_SYSTEM_NAME MATCHES \"Haiku\")\n  if(MI_OPT_ARCH)\n    if(MI_ARCH STREQUAL \"arm64\")\n      set(MI_OPT_ARCH_FLAGS \"-march=armv8.1-a\")         # fast atomics\n    endif()\n  endif()\nendif()\n\nif (MSVC AND MSVC_VERSION GREATER_EQUAL 1914)\n  list(APPEND mi_cflags /Zc:__cplusplus)\n  if(MI_OPT_ARCH AND NOT MI_CLANG_CL)\n    if(MI_ARCH STREQUAL \"arm64\")\n      set(MI_OPT_ARCH_FLAGS \"/arch:armv8.1\")           # fast atomics\n    endif()\n  endif()\nendif()\n\nif(MINGW)\n  add_definitions(-D_WIN32_WINNT=0x601)                # issue #976\nendif()\n\nif(MI_OPT_ARCH_FLAGS)\n  list(APPEND mi_cflags ${MI_OPT_ARCH_FLAGS})\n  message(STATUS \"Architecture specific optimization is enabled (with ${MI_OPT_ARCH_FLAGS}) (MI_OPT_ARCH=ON)\")\nendif()\n\n# extra needed libraries\n\n# we prefer -l<lib> test over `find_library` as sometimes core libraries\n# like `libatomic` are not on the system path (see issue #898)\nfunction(find_link_library libname outlibname)\n  check_linker_flag(C \"-l${libname}\" mi_has_lib${libname})\n  if (mi_has_lib${libname})\n    message(VERBOSE \"link library: -l${libname}\")\n    set(${outlibname} ${libname} PARENT_SCOPE)\n  else()\n    find_library(MI_LIBPATH libname)\n    if (MI_LIBPATH)\n      message(VERBOSE \"link library ${libname} at ${MI_LIBPATH}\")\n      set(${outlibname} ${MI_LIBPATH} PARENT_SCOPE)\n    else()\n      message(VERBOSE \"link library not found: ${libname}\")\n      set(${outlibname} \"\" PARENT_SCOPE)\n    endif()\n  endif()\nendfunction()\n\nif(WIN32)\n  list(APPEND mi_libraries psapi shell32 user32 advapi32 bcrypt)\nelse()\n  find_link_library(\"pthread\" MI_LIB_PTHREAD)\n  if(MI_LIB_PTHREAD)\n    list(APPEND mi_libraries \"${MI_LIB_PTHREAD}\")\n  endif()\n  find_link_library(\"rt\" MI_LIB_RT)\n  if(MI_LIB_RT)\n    list(APPEND mi_libraries \"${MI_LIB_RT}\")\n  endif()\n  find_link_library(\"atomic\" MI_LIB_ATOMIC)\n  if(MI_LIB_ATOMIC)\n    list(APPEND mi_libraries \"${MI_LIB_ATOMIC}\")\n  endif()\nendif()\n\n# -----------------------------------------------------------------------------\n# Install and output names\n# -----------------------------------------------------------------------------\n\n# dynamic/shared library and symlinks always go to /usr/local/lib equivalent\n# we use ${CMAKE_INSTALL_BINDIR} and ${CMAKE_INSTALL_LIBDIR}.\n\n# static libraries and object files, includes, and cmake config files\n# are either installed at top level, or use versioned directories for side-by-side installation (default)\nif (MI_INSTALL_TOPLEVEL)\n  set(mi_install_objdir     \"${CMAKE_INSTALL_LIBDIR}\")\n  set(mi_install_incdir     \"${CMAKE_INSTALL_INCLUDEDIR}\")\n  set(mi_install_cmakedir   \"${CMAKE_INSTALL_LIBDIR}/cmake/mimalloc\")\nelse()\n  set(mi_install_objdir     \"${CMAKE_INSTALL_LIBDIR}/mimalloc-${mi_version}\")       # for static library and object files\n  set(mi_install_incdir     \"${CMAKE_INSTALL_INCLUDEDIR}/mimalloc-${mi_version}\")   # for includes\n  set(mi_install_cmakedir   \"${CMAKE_INSTALL_LIBDIR}/cmake/mimalloc-${mi_version}\") # for cmake package info\nendif()\n\nset(mi_libname \"mimalloc\")\nif(MI_SECURE)\n  set(mi_libname \"${mi_libname}-secure\")\nendif()\nif(MI_TRACK_VALGRIND)\n  set(mi_libname \"${mi_libname}-valgrind\")\nendif()\nif(MI_TRACK_ASAN)\n  set(mi_libname \"${mi_libname}-asan\")\nendif()\nstring(TOLOWER \"${CMAKE_BUILD_TYPE}\" CMAKE_BUILD_TYPE_LC)\nif(NOT(CMAKE_BUILD_TYPE_LC MATCHES \"^(release|relwithdebinfo|minsizerel|none)$\"))\n  set(mi_libname \"${mi_libname}-${CMAKE_BUILD_TYPE_LC}\") #append build type (e.g. -debug) if not a release version\nendif()\n\nif(MI_BUILD_SHARED)\n  list(APPEND mi_build_targets \"shared\")\nendif()\nif(MI_BUILD_STATIC)\n  list(APPEND mi_build_targets \"static\")\nendif()\nif(MI_BUILD_OBJECT)\n  list(APPEND mi_build_targets \"object\")\nendif()\nif(MI_BUILD_TESTS)\n  list(APPEND mi_build_targets \"tests\")\nendif()\n\nmessage(STATUS \"\")\nmessage(STATUS \"Library name     : ${mi_libname}\")\nmessage(STATUS \"Version          : ${mi_version}.${mi_version_patch}\")\nmessage(STATUS \"Build type       : ${CMAKE_BUILD_TYPE_LC}\")\nif(MI_USE_CXX)\n  message(STATUS \"C++ Compiler     : ${CMAKE_CXX_COMPILER}\")\nelse()\n  message(STATUS \"C Compiler       : ${CMAKE_C_COMPILER}\")\nendif()\nmessage(STATUS \"Compiler flags   : ${mi_cflags}\")\nmessage(STATUS \"Compiler defines : ${mi_defines}\")\nmessage(STATUS \"Link libraries   : ${mi_libraries}\")\nmessage(STATUS \"Build targets    : ${mi_build_targets}\")\nmessage(STATUS \"\")\n\n# -----------------------------------------------------------------------------\n# Main targets\n# -----------------------------------------------------------------------------\n\n# shared library\nif(MI_BUILD_SHARED)\n  add_library(mimalloc SHARED ${mi_sources})\n  set_target_properties(mimalloc PROPERTIES VERSION ${mi_version} SOVERSION ${mi_version_major} OUTPUT_NAME ${mi_libname} )\n  target_compile_definitions(mimalloc PRIVATE ${mi_defines} MI_SHARED_LIB MI_SHARED_LIB_EXPORT)\n  target_compile_options(mimalloc PRIVATE ${mi_cflags} ${mi_cflags_dynamic})\n  target_link_libraries(mimalloc PRIVATE ${mi_libraries})\n  target_include_directories(mimalloc PUBLIC\n      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n      $<INSTALL_INTERFACE:${mi_install_incdir}>\n  )\n  install(TARGETS mimalloc EXPORT mimalloc ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR})\n  install(EXPORT mimalloc DESTINATION ${mi_install_cmakedir})\n\n  if(WIN32)\n    # On windows, the import library name for the dll would clash with the static mimalloc.lib\n    # so we postfix the dll import library with `.dll.lib`.\n    set_property(TARGET mimalloc PROPERTY ARCHIVE_OUTPUT_NAME \"${mi_libname}.dll\" )\n    install(FILES \"$<TARGET_FILE_DIR:mimalloc>/${mi_libname}.dll.lib\" DESTINATION ${CMAKE_INSTALL_LIBDIR})\n  endif()\n  if(WIN32 AND MI_WIN_REDIRECT)\n    # On windows, link and copy the mimalloc redirection dll too.\n    if(CMAKE_GENERATOR_PLATFORM STREQUAL \"arm64ec\")\n      set(MIMALLOC_REDIRECT_SUFFIX \"-arm64ec\")\n    elseif(MI_ARCH STREQUAL \"x64\")\n      set(MIMALLOC_REDIRECT_SUFFIX \"\")\n      if(CMAKE_SYSTEM_PROCESSOR STREQUAL \"ARM64\")\n        message(STATUS \"Note: x64 code emulated on Windows for arm64 should use an arm64ec build of 'mimalloc.dll'\")\n        message(STATUS \"      together with 'mimalloc-redirect-arm64ec.dll'. See the 'bin\\\\readme.md' for more information.\")\n      endif()\n    elseif(MI_ARCH STREQUAL \"x86\")\n      set(MIMALLOC_REDIRECT_SUFFIX \"32\")\n    else()\n      set(MIMALLOC_REDIRECT_SUFFIX \"-${MI_ARCH}\")  # -arm64 etc.\n    endif()\n\n    target_link_libraries(mimalloc PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/bin/mimalloc-redirect${MIMALLOC_REDIRECT_SUFFIX}.lib)  # the DLL import library\n    add_custom_command(TARGET mimalloc POST_BUILD\n      COMMAND \"${CMAKE_COMMAND}\" -E copy \"${CMAKE_CURRENT_SOURCE_DIR}/bin/mimalloc-redirect${MIMALLOC_REDIRECT_SUFFIX}.dll\" $<TARGET_FILE_DIR:mimalloc>\n      COMMENT \"Copy mimalloc-redirect${MIMALLOC_REDIRECT_SUFFIX}.dll to output directory\")\n    install(FILES \"$<TARGET_FILE_DIR:mimalloc>/mimalloc-redirect${MIMALLOC_REDIRECT_SUFFIX}.dll\" DESTINATION ${CMAKE_INSTALL_BINDIR})\n  endif()\nendif()\n\n\n# static library\nif (MI_BUILD_STATIC)\n  add_library(mimalloc-static STATIC ${mi_sources})\n  set_property(TARGET mimalloc-static PROPERTY OUTPUT_NAME ${mi_libname})\n  set_property(TARGET mimalloc-static PROPERTY POSITION_INDEPENDENT_CODE ON)\n  target_compile_definitions(mimalloc-static PRIVATE ${mi_defines} MI_STATIC_LIB)\n  target_compile_options(mimalloc-static PRIVATE ${mi_cflags} ${mi_cflags_static})\n  target_link_libraries(mimalloc-static PRIVATE ${mi_libraries})\n  target_include_directories(mimalloc-static PUBLIC\n      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n      $<INSTALL_INTERFACE:${mi_install_incdir}>\n  )\n  install(TARGETS mimalloc-static EXPORT mimalloc DESTINATION ${mi_install_objdir} LIBRARY)\n  install(EXPORT mimalloc DESTINATION ${mi_install_cmakedir})\nendif()\n\n# install include files\ninstall(FILES include/mimalloc.h DESTINATION ${mi_install_incdir})\ninstall(FILES include/mimalloc-override.h DESTINATION ${mi_install_incdir})\ninstall(FILES include/mimalloc-new-delete.h DESTINATION ${mi_install_incdir})\ninstall(FILES cmake/mimalloc-config.cmake DESTINATION ${mi_install_cmakedir})\ninstall(FILES cmake/mimalloc-config-version.cmake DESTINATION ${mi_install_cmakedir})\n\n\n# single object file for more predictable static overriding\nif (MI_BUILD_OBJECT)\n  add_library(mimalloc-obj OBJECT src/static.c)\n  set_property(TARGET mimalloc-obj PROPERTY POSITION_INDEPENDENT_CODE ON)\n  target_compile_definitions(mimalloc-obj PRIVATE ${mi_defines})\n  target_compile_options(mimalloc-obj PRIVATE ${mi_cflags} ${mi_cflags_static})\n  target_include_directories(mimalloc-obj PUBLIC\n      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n      $<INSTALL_INTERFACE:${mi_install_incdir}>\n  )\n\n  # Copy the generated object file (`static.o`) to the output directory (as `mimalloc.o`)\n  if(CMAKE_GENERATOR MATCHES \"^Visual Studio.*$\")\n    set(mimalloc-obj-static \"${CMAKE_CURRENT_BINARY_DIR}/mimalloc-obj.dir/$<CONFIG>/static${CMAKE_C_OUTPUT_EXTENSION}\")\n  else()\n    set(mimalloc-obj-static \"${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/mimalloc-obj.dir/src/static.c${CMAKE_C_OUTPUT_EXTENSION}\")\n  endif()\n  set(mimalloc-obj-out \"${CMAKE_CURRENT_BINARY_DIR}/${mi_libname}${CMAKE_C_OUTPUT_EXTENSION}\")\n  add_custom_command(OUTPUT ${mimalloc-obj-out} DEPENDS mimalloc-obj COMMAND \"${CMAKE_COMMAND}\" -E copy \"${mimalloc-obj-static}\" \"${mimalloc-obj-out}\")\n  add_custom_target(mimalloc-obj-target ALL DEPENDS ${mimalloc-obj-out})\n\n\n  # the following seems to lead to cmake warnings/errors on some systems, disable for now :-(\n  # install(TARGETS mimalloc-obj EXPORT mimalloc DESTINATION ${mi_install_objdir})\n\n  # the FILES expression can also be: $<TARGET_OBJECTS:mimalloc-obj>\n  # but that fails cmake versions less than 3.10 so we leave it as is for now\n  install(FILES ${mimalloc-obj-static}\n          DESTINATION ${mi_install_objdir}\n          RENAME ${mi_libname}${CMAKE_C_OUTPUT_EXTENSION} )\nendif()\n\n\n# pkg-config file support\nset(mi_pc_libraries \"\")\nforeach(item IN LISTS mi_libraries)\n  if(item MATCHES \" *[-].*\")\n    set(mi_pc_libraries \"${mi_pc_libraries} ${item}\")\n  else()\n    set(mi_pc_libraries \"${mi_pc_libraries} -l${item}\")\n  endif()\nendforeach()\n\ninclude(\"cmake/JoinPaths.cmake\")\njoin_paths(mi_pc_includedir \"\\${prefix}\" \"${CMAKE_INSTALL_INCLUDEDIR}\")\njoin_paths(mi_pc_libdir \"\\${prefix}\" \"${CMAKE_INSTALL_LIBDIR}\")\n\nconfigure_file(mimalloc.pc.in mimalloc.pc @ONLY)\ninstall(FILES \"${CMAKE_CURRENT_BINARY_DIR}/mimalloc.pc\"\n        DESTINATION \"${CMAKE_INSTALL_LIBDIR}/pkgconfig/\")\n\n\n\n# -----------------------------------------------------------------------------\n# API surface testing\n# -----------------------------------------------------------------------------\n\nif (MI_BUILD_TESTS)\n  enable_testing()\n\n  foreach(TEST_NAME api api-fill stress)\n    add_executable(mimalloc-test-${TEST_NAME} test/test-${TEST_NAME}.c)\n    target_compile_definitions(mimalloc-test-${TEST_NAME} PRIVATE ${mi_defines})\n    target_compile_options(mimalloc-test-${TEST_NAME} PRIVATE ${mi_cflags})\n    target_include_directories(mimalloc-test-${TEST_NAME} PRIVATE include)\n    target_link_libraries(mimalloc-test-${TEST_NAME} PRIVATE mimalloc ${mi_libraries})\n\n    add_test(NAME test-${TEST_NAME} COMMAND mimalloc-test-${TEST_NAME})\n  endforeach()\nendif()\n\n# -----------------------------------------------------------------------------\n# Set override properties\n# -----------------------------------------------------------------------------\nif (MI_OVERRIDE)\n  if (MI_BUILD_SHARED)\n    target_compile_definitions(mimalloc PRIVATE MI_MALLOC_OVERRIDE)\n  endif()\n  if(NOT WIN32)\n    # It is only possible to override malloc on Windows when building as a DLL.\n    if (MI_BUILD_STATIC)\n      target_compile_definitions(mimalloc-static PRIVATE MI_MALLOC_OVERRIDE)\n    endif()\n    if (MI_BUILD_OBJECT)\n      target_compile_definitions(mimalloc-obj PRIVATE MI_MALLOC_OVERRIDE)\n    endif()\n  endif()\nendif()\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0703125,
          "content": "MIT License\n\nCopyright (c) 2018-2025 Microsoft Corporation, Daan Leijen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 2.59375,
          "content": "<!-- BEGIN MICROSOFT SECURITY.MD V0.0.9 BLOCK -->\n\n## Security\n\nMicrosoft takes the security of our software products and services seriously, which includes all source code repositories managed through our GitHub organizations, which include [Microsoft](https://github.com/Microsoft), [Azure](https://github.com/Azure), [DotNet](https://github.com/dotnet), [AspNet](https://github.com/aspnet) and [Xamarin](https://github.com/xamarin).\n\nIf you believe you have found a security vulnerability in any Microsoft-owned repository that meets [Microsoft's definition of a security vulnerability](https://aka.ms/security.md/definition), please report it to us as described below.\n\n## Reporting Security Issues\n\n**Please do not report security vulnerabilities through public GitHub issues.**\n\nInstead, please report them to the Microsoft Security Response Center (MSRC) at [https://msrc.microsoft.com/create-report](https://aka.ms/security.md/msrc/create-report).\n\nIf you prefer to submit without logging in, send email to [secure@microsoft.com](mailto:secure@microsoft.com).  If possible, encrypt your message with our PGP key; please download it from the [Microsoft Security Response Center PGP Key page](https://aka.ms/security.md/msrc/pgp).\n\nYou should receive a response within 24 hours. If for some reason you do not, please follow up via email to ensure we received your original message. Additional information can be found at [microsoft.com/msrc](https://www.microsoft.com/msrc). \n\nPlease include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:\n\n  * Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)\n  * Full paths of source file(s) related to the manifestation of the issue\n  * The location of the affected source code (tag/branch/commit or direct URL)\n  * Any special configuration required to reproduce the issue\n  * Step-by-step instructions to reproduce the issue\n  * Proof-of-concept or exploit code (if possible)\n  * Impact of the issue, including how an attacker might exploit the issue\n\nThis information will help us triage your report more quickly.\n\nIf you are reporting for a bug bounty, more complete reports can contribute to a higher bounty award. Please visit our [Microsoft Bug Bounty Program](https://aka.ms/security.md/msrc/bounty) page for more details about our active programs.\n\n## Preferred Languages\n\nWe prefer all communications to be in English.\n\n## Policy\n\nMicrosoft follows the principle of [Coordinated Vulnerability Disclosure](https://aka.ms/security.md/cvd).\n\n<!-- END MICROSOFT SECURITY.MD BLOCK -->\n"
        },
        {
          "name": "azure-pipelines.yml",
          "type": "blob",
          "size": 8.3203125,
          "content": "# Starter pipeline\n# Start with a minimal pipeline that you can customize to build and deploy your code.\n# Add steps that build, run tests, deploy, and more:\n# https://aka.ms/yaml\n\ntrigger:\n  branches:\n    include:\n    - master\n    - dev\n    - dev2\n    - dev3\n  tags:\n    include:\n    - v*\n\njobs:\n- job:\n  displayName: Windows 2022\n  pool:\n    vmImage:\n      windows-2022\n  strategy:\n    matrix:\n      Debug:\n        BuildType: debug\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON\n        MSBuildConfiguration: Debug\n      Release:\n        BuildType: release\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Release\n        MSBuildConfiguration: Release\n      Secure:\n        BuildType: secure\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Release -DMI_SECURE=ON\n        MSBuildConfiguration: Release\n  steps:\n  - task: CMake@1\n    inputs:\n      workingDirectory: $(BuildType)\n      cmakeArgs: .. $(cmakeExtraArgs)\n  - task: MSBuild@1\n    inputs:\n      solution: $(BuildType)/libmimalloc.sln\n      configuration: '$(MSBuildConfiguration)'\n      msbuildArguments: -m\n  - script: ctest --verbose --timeout 240 -C $(MSBuildConfiguration)\n    workingDirectory: $(BuildType)\n    displayName: CTest\n  #- script: $(BuildType)\\$(BuildType)\\mimalloc-test-stress\n  #  displayName: TestStress\n  #- upload: $(Build.SourcesDirectory)/$(BuildType)\n  #  artifact: mimalloc-windows-$(BuildType)\n\n- job:\n  displayName: Ubuntu 22.04\n  pool:\n    vmImage:\n     ubuntu-22.04\n  strategy:\n    matrix:\n      Debug:\n        CC: gcc\n        CXX: g++\n        BuildType: debug\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON\n      Release:\n        CC: gcc\n        CXX: g++\n        BuildType: release\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Release\n      Secure:\n        CC: gcc\n        CXX: g++\n        BuildType: secure\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Release -DMI_SECURE=ON\n      Debug++:\n        CC: gcc\n        CXX: g++\n        BuildType: debug-cxx\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON -DMI_USE_CXX=ON\n      Debug Clang:\n        CC: clang\n        CXX: clang++\n        BuildType: debug-clang\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON\n      Release Clang:\n        CC: clang\n        CXX: clang++\n        BuildType: release-clang\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Release\n      Secure Clang:\n        CC: clang\n        CXX: clang++\n        BuildType: secure-clang\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Release -DMI_SECURE=ON\n      Debug++ Clang:\n        CC: clang\n        CXX: clang++\n        BuildType: debug-clang-cxx\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON -DMI_USE_CXX=ON\n      Debug ASAN Clang:\n        CC: clang\n        CXX: clang++\n        BuildType: debug-asan-clang\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON -DMI_TRACK_ASAN=ON\n      Debug UBSAN Clang:\n        CC: clang\n        CXX: clang++\n        BuildType: debug-ubsan-clang\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON -DMI_DEBUG_UBSAN=ON\n      Debug TSAN Clang++:\n        CC: clang\n        CXX: clang++\n        BuildType: debug-tsan-clang-cxx\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=RelWithDebInfo -DMI_USE_CXX=ON -DMI_DEBUG_TSAN=ON\n      Debug Guarded Clang:\n        CC: clang\n        CXX: clang\n        BuildType: debug-guarded-clang\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=RelWithDebInfo -DMI_DEBUG_FULL=ON -DMI_GUARDED=ON\n\n  steps:\n  - task: CMake@1\n    inputs:\n      workingDirectory: $(BuildType)\n      cmakeArgs: .. $(cmakeExtraArgs)\n  - script: make -j$(nproc) -C $(BuildType)\n    displayName: Make\n  - script: ctest --verbose --timeout 240\n    workingDirectory: $(BuildType)\n    displayName: CTest\n    env:\n      MIMALLOC_GUARDED_SAMPLE_RATE: 1000\n#  - upload: $(Build.SourcesDirectory)/$(BuildType)\n#    artifact: mimalloc-ubuntu-$(BuildType)\n\n- job:\n  displayName: macOS 14 (Sonoma)\n  pool:\n    vmImage:\n      macOS-14\n  strategy:\n    matrix:\n      Debug:\n        BuildType: debug\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON\n      Release:\n        BuildType: release\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Release\n      Secure:\n        BuildType: secure\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Release -DMI_SECURE=ON\n  steps:\n  - task: CMake@1\n    inputs:\n      workingDirectory: $(BuildType)\n      cmakeArgs: .. $(cmakeExtraArgs)\n  - script: make -j$(sysctl -n hw.ncpu) -C $(BuildType)\n    displayName: Make\n  - script: ctest --verbose --timeout 240\n    workingDirectory: $(BuildType)\n    displayName: CTest\n#  - upload: $(Build.SourcesDirectory)/$(BuildType)\n#    artifact: mimalloc-macos-$(BuildType)\n\n# ----------------------------------------------------------\n# Other OS versions (just debug mode)\n# ----------------------------------------------------------\n\n- job:\n  displayName: Windows 2019\n  pool:\n    vmImage:\n      windows-2019\n  strategy:\n    matrix:\n      Debug:\n        BuildType: debug\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON\n        MSBuildConfiguration: Debug\n      Release:\n        BuildType: release\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Release\n        MSBuildConfiguration: Release\n  steps:\n  - task: CMake@1\n    inputs:\n      workingDirectory: $(BuildType)\n      cmakeArgs: .. $(cmakeExtraArgs)\n  - task: MSBuild@1\n    inputs:\n      solution: $(BuildType)/libmimalloc.sln\n      configuration: '$(MSBuildConfiguration)'\n      msbuildArguments: -m\n  - script: ctest --verbose --timeout 240 -C $(MSBuildConfiguration)\n    workingDirectory: $(BuildType)\n    displayName: CTest\n\n- job:\n  displayName: Ubuntu 24.04\n  pool:\n    vmImage:\n      ubuntu-24.04\n  strategy:\n    matrix:\n      Debug:\n        CC: gcc\n        CXX: g++\n        BuildType: debug\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON\n      Debug++:\n        CC: gcc\n        CXX: g++\n        BuildType: debug-cxx\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON -DMI_USE_CXX=ON\n      Debug Clang:\n        CC: clang\n        CXX: clang++\n        BuildType: debug-clang\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON\n      Debug++ Clang:\n        CC: clang\n        CXX: clang++\n        BuildType: debug-clang-cxx\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON -DMI_USE_CXX=ON\n      Release Clang:\n        CC: clang\n        CXX: clang++\n        BuildType: release-clang\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Release\n  steps:\n  - task: CMake@1\n    inputs:\n      workingDirectory: $(BuildType)\n      cmakeArgs: .. $(cmakeExtraArgs)\n  - script: make -j$(nproc) -C $(BuildType)\n    displayName: Make\n  - script: ctest --verbose --timeout 240\n    workingDirectory: $(BuildType)\n    displayName: CTest\n\n- job:\n  displayName: Ubuntu 20.04\n  pool:\n    vmImage:\n      ubuntu-20.04\n  strategy:\n    matrix:\n      Debug:\n        CC: gcc\n        CXX: g++\n        BuildType: debug\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON\n      Debug++:\n        CC: gcc\n        CXX: g++\n        BuildType: debug-cxx\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON -DMI_USE_CXX=ON\n      Debug Clang:\n        CC: clang\n        CXX: clang++\n        BuildType: debug-clang\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON\n      Debug++ Clang:\n        CC: clang\n        CXX: clang++\n        BuildType: debug-clang-cxx\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON -DMI_USE_CXX=ON\n      Release Clang:\n        CC: clang\n        CXX: clang++\n        BuildType: release-clang\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Release\n  steps:\n  - task: CMake@1\n    inputs:\n      workingDirectory: $(BuildType)\n      cmakeArgs: .. $(cmakeExtraArgs)\n  - script: make -j$(nproc) -C $(BuildType)\n    displayName: Make\n  - script: ctest --verbose --timeout 240\n    workingDirectory: $(BuildType)\n    displayName: CTest\n\n- job:\n  displayName: macOS 15 (Sequoia)\n  pool:\n    vmImage:\n      macOS-15\n  strategy:\n    matrix:\n      Debug:\n        BuildType: debug\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Debug -DMI_DEBUG_FULL=ON\n      Release:\n        BuildType: release\n        cmakeExtraArgs: -DCMAKE_BUILD_TYPE=Release\n  steps:\n  - task: CMake@1\n    inputs:\n      workingDirectory: $(BuildType)\n      cmakeArgs: .. $(cmakeExtraArgs)\n  - script: make -j$(sysctl -n hw.ncpu) -C $(BuildType)\n    displayName: Make\n  - script: ctest --verbose --timeout 240\n    workingDirectory: $(BuildType)\n    displayName: CTest\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "ide",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "mimalloc.pc.in",
          "type": "blob",
          "size": 0.33203125,
          "content": "prefix=@CMAKE_INSTALL_PREFIX@\nlibdir=@mi_pc_libdir@\nincludedir=@mi_pc_includedir@\n\nName: @PROJECT_NAME@\nDescription: A compact general purpose allocator with excellent performance\nVersion: @PACKAGE_VERSION@\nURL: https://github.com/microsoft/mimalloc/\nLibs: -L${libdir} -l@mi_libname@\nLibs.private: @mi_pc_libraries@\nCflags: -I${includedir}\n"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 50.7099609375,
          "content": "\n<img align=\"left\" width=\"100\" height=\"100\" src=\"doc/mimalloc-logo.png\"/>\n\n[<img align=\"right\" src=\"https://dev.azure.com/Daan0324/mimalloc/_apis/build/status/microsoft.mimalloc?branchName=dev\"/>](https://dev.azure.com/Daan0324/mimalloc/_build?definitionId=1&_a=summary)\n\n# mimalloc\n\n&nbsp;\n\nmimalloc (pronounced \"me-malloc\")\nis a general purpose allocator with excellent [performance](#performance) characteristics.\nInitially developed by Daan Leijen for the runtime systems of the\n[Koka](https://koka-lang.github.io) and [Lean](https://github.com/leanprover/lean) languages.\n\nLatest release tag: `v2.1.9` (2025-01-03).  \nLatest v1 tag: `v1.8.9` (2024-01-03).\n\nmimalloc is a drop-in replacement for `malloc` and can be used in other programs\nwithout code changes, for example, on dynamically linked ELF-based systems (Linux, BSD, etc.) you can use it as:\n```\n> LD_PRELOAD=/usr/lib/libmimalloc.so  myprogram\n```\nIt also includes a robust way to override the default allocator in [Windows](#override_on_windows). Notable aspects of the design include:\n\n- __small and consistent__: the library is about 10k LOC using simple and\n  consistent data structures. This makes it very suitable\n  to integrate and adapt in other projects. For runtime systems it\n  provides hooks for a monotonic _heartbeat_ and deferred freeing (for\n  bounded worst-case times with reference counting).\n  Partly due to its simplicity, mimalloc has been ported to many systems (Windows, macOS,\n  Linux, WASM, various BSD's, Haiku, MUSL, etc) and has excellent support for dynamic overriding.\n  At the same time, it is an industrial strength allocator that runs (very) large scale\n  distributed services on thousands of machines with excellent worst case latencies.\n- __free list sharding__: instead of one big free list (per size class) we have\n  many smaller lists per \"mimalloc page\" which reduces fragmentation and\n  increases locality --\n  things that are allocated close in time get allocated close in memory.\n  (A mimalloc page contains blocks of one size class and is usually 64KiB on a 64-bit system).\n- __free list multi-sharding__: the big idea! Not only do we shard the free list\n  per mimalloc page, but for each page we have multiple free lists. In particular, there\n  is one list for thread-local `free` operations, and another one for concurrent `free`\n  operations. Free-ing from another thread can now be a single CAS without needing\n  sophisticated coordination between threads. Since there will be\n  thousands of separate free lists, contention is naturally distributed over the heap,\n  and the chance of contending on a single location will be low -- this is quite\n  similar to randomized algorithms like skip lists where adding\n  a random oracle removes the need for a more complex algorithm.\n- __eager page purging__: when a \"page\" becomes empty (with increased chance\n  due to free list sharding) the memory is marked to the OS as unused (reset or decommitted)\n  reducing (real) memory pressure and fragmentation, especially in long running\n  programs.\n- __secure__: _mimalloc_ can be built in secure mode, adding guard pages,\n  randomized allocation, encrypted free lists, etc. to protect against various\n  heap vulnerabilities. The performance penalty is usually around 10% on average\n  over our benchmarks.\n- __first-class heaps__: efficiently create and use multiple heaps to allocate across different regions.\n  A heap can be destroyed at once instead of deallocating each object separately.\n- __bounded__: it does not suffer from _blowup_ \\[1\\], has bounded worst-case allocation\n  times (_wcat_) (upto OS primitives), bounded space overhead (~0.2% meta-data, with low\n  internal fragmentation), and has no internal points of contention using only atomic operations.\n- __fast__: In our benchmarks (see [below](#performance)),\n  _mimalloc_ outperforms other leading allocators (_jemalloc_, _tcmalloc_, _Hoard_, etc),\n  and often uses less memory. A nice property is that it does consistently well over a wide range\n  of benchmarks. There is also good huge OS page support for larger server programs.\n\nThe [documentation](https://microsoft.github.io/mimalloc) gives a full overview of the API.\nYou can read more on the design of _mimalloc_ in the [technical report](https://www.microsoft.com/en-us/research/publication/mimalloc-free-list-sharding-in-action) which also has detailed benchmark results.\n\nEnjoy!\n\n### Branches\n\n* `master`: latest stable release (based on `dev2`).\n* `dev`: development branch for mimalloc v1. Use this branch for submitting PR's.\n* `dev2`: development branch for mimalloc v2. This branch is downstream of `dev` \n         (and is essentially equal to `dev` except for `src/segment.c`). Uses larger sliced segments to manage\n         mimalloc pages what can reduce fragmentation.\n* `dev3`: development branch for mimalloc v3-alpha. This branch is downstream of `dev`. This is still experimental,\n          but simplifies previous versions by having no segments any more. This improves sharing of memory \n          between threads, and on certain large workloads uses less memory with less fragmentation.\n\n### Releases\n\n* 2025-01-03, `v1.8.9`, `v2.1.9`, `v3.0.1-alpha`: Interim release. Support Windows arm64. New [guarded](#guarded) build that can place OS \n  guard pages behind objects to catch buffer overflows as they occur. \n  Many small fixes: build on Windows arm64, cygwin, riscV, and dragonfly; fix Windows static library initialization to account for\n  thread local destructors (in Rust/C++); macOS tag change; macOS TLS slot fix; improve stats; \n  consistent mimalloc.dll on Windows (instead of mimalloc-override.dll); fix mimalloc-redirect on Win11 H2; \n  add 0-byte to canary; upstream CPython fixes; reduce .bss size; allow fixed TLS slot on Windows for improved performance.\n* 2024-05-21, `v1.8.7`, `v2.1.7`: Fix build issues on less common platforms. Started upstreaming patches\n  from the CPython [integration](https://github.com/python/cpython/issues/113141#issuecomment-2119255217). Upstream `vcpkg` patches.\n* 2024-05-13, `v1.8.6`, `v2.1.6`: Fix build errors on various (older) platforms. Refactored aligned allocation.\n* 2024-04-22, `v1.8.4`, `v2.1.4`: Fixes various bugs and build issues. Add `MI_LIBC_MUSL` cmake flag for musl builds.\n  Free-ing code is refactored into a separate module (`free.c`). Mimalloc page info is simplified with the block size\n  directly available (and new `block_size_shift` to improve aligned block free-ing).\n  New approach to collection of abandoned segments: When\n  a thread terminates the segments it owns are abandoned (containing still live objects) and these can be\n  reclaimed by other threads. We no longer use a list of abandoned segments but this is now done using bitmaps in arena's\n  which is more concurrent (and more aggressive). Abandoned memory can now also be reclaimed if a thread frees an object in\n  an abandoned page (which can be disabled using `mi_option_abandoned_reclaim_on_free`). The option `mi_option_max_segment_reclaim`\n  gives a maximum percentage of abandoned segments that can be reclaimed per try (=10%).\n\n* 2023-04-24, `v1.8.2`, `v2.1.2`: Fixes build issues on freeBSD, musl, and C17 (UE 5.1.1). Reduce code size/complexity\n  by removing regions and segment-cache's and only use arenas with improved memory purging -- this may improve memory\n  usage as well for larger services. Renamed options for consistency. Improved Valgrind and ASAN checking.\n\n* 2023-04-03, `v1.8.1`, `v2.1.1`: Fixes build issues on some platforms.\n\n* 2023-03-29, `v1.8.0`, `v2.1.0`: Improved support dynamic overriding on Windows 11. Improved tracing precision\n  with [asan](#asan) and [Valgrind](#valgrind), and added Windows event tracing [ETW](#ETW) (contributed by Xinglong He). Created an OS\n  abstraction layer to make it easier to port and separate platform dependent code (in `src/prim`). Fixed C++ STL compilation on older Microsoft C++ compilers, and various small bug fixes.\n\n* 2022-12-23, `v1.7.9`, `v2.0.9`: Supports building with [asan](#asan) and improved [Valgrind](#valgrind) support.\n  Support arbitrary large alignments (in particular for `std::pmr` pools).\n  Added C++ STL allocators attached to a specific heap (thanks @vmarkovtsev).\n  Heap walks now visit all object (including huge objects). Support Windows nano server containers (by Johannes Schindelin,@dscho).\n  Various small bug fixes.\n\n* 2022-11-03, `v1.7.7`, `v2.0.7`: Initial support for [Valgrind](#valgrind) for leak testing and heap block overflow\n  detection. Initial\n  support for attaching heaps to a specific memory area (only in v2). Fix `realloc` behavior for zero size blocks, remove restriction to integral multiple of the alignment in `alloc_align`, improved aligned allocation performance, reduced contention with many threads on few processors (thank you @dposluns!), vs2022 support, support `pkg-config`, .\n\n* 2022-04-14, `v1.7.6`, `v2.0.6`: fix fallback path for aligned OS allocation on Windows, improve Windows aligned allocation\n  even when compiling with older SDK's, fix dynamic overriding on macOS Monterey, fix MSVC C++ dynamic overriding, fix\n  warnings under Clang 14, improve performance if many OS threads are created and destroyed, fix statistics for large object\n  allocations, using MIMALLOC_VERBOSE=1 has no maximum on the number of error messages, various small fixes.\n\n* 2022-02-14, `v1.7.5`, `v2.0.5` (alpha): fix malloc override on\n  Windows 11, fix compilation with musl, potentially reduced\n  committed memory, add `bin/minject` for Windows,\n  improved wasm support, faster aligned allocation,\n  various small fixes.\n\n* [Older release notes](#older-release-notes)\n\nSpecial thanks to:\n\n* [David Carlier](https://devnexen.blogspot.com/) (@devnexen) for his many contributions, and making\n  mimalloc work better on many less common operating systems, like Haiku, Dragonfly, etc.\n* Mary Feofanova (@mary3000), Evgeniy Moiseenko, and Manuel Pter (@mpoeter) for making mimalloc TSAN checkable, and finding\n  memory model bugs using the [genMC] model checker.\n* Weipeng Liu (@pongba), Zhuowei Li, Junhua Wang, and Jakub Szymanski, for their early support of mimalloc and deployment\n  at large scale services, leading to many improvements in the mimalloc algorithms for large workloads.\n* Jason Gibson (@jasongibson) for exhaustive testing on large scale workloads and server environments, and finding complex bugs\n  in (early versions of) `mimalloc`.\n* Manuel Pter (@mpoeter) and Sam Gross(@colesbury) for finding an ABA concurrency issue in abandoned segment reclamation. Sam also created the [no GIL](https://github.com/colesbury/nogil) Python fork which\n  uses mimalloc internally.\n\n\n[genMC]: https://plv.mpi-sws.org/genmc/\n\n### Usage\n\nmimalloc is used in various large scale low-latency services and programs, for example:\n\n<a href=\"https://www.bing.com\"><img height=\"50\" align=\"left\" src=\"https://upload.wikimedia.org/wikipedia/commons/e/e9/Bing_logo.svg\"></a>\n<a href=\"https://azure.microsoft.com/\"><img height=\"50\" align=\"left\" src=\"https://upload.wikimedia.org/wikipedia/commons/a/a8/Microsoft_Azure_Logo.svg\"></a>\n<a href=\"https://deathstrandingpc.505games.com\"><img height=\"100\" src=\"doc/ds-logo.png\"></a>\n<a href=\"https://docs.unrealengine.com/4.26/en-US/WhatsNew/Builds/ReleaseNotes/4_25/\"><img height=\"100\" src=\"doc/unreal-logo.svg\"></a>\n<a href=\"https://cab.spbu.ru/software/spades/\"><img height=\"100\" src=\"doc/spades-logo.png\"></a>\n\n\n# Building\n\n## Windows\n\nOpen `ide/vs2022/mimalloc.sln` in Visual Studio 2022 and build.\nThe `mimalloc` project builds a static library (in `out/msvc-x64`), while the\n`mimalloc-override` project builds a DLL for overriding malloc\nin the entire program.\n\n## Linux, macOS, BSD, etc.\n\nWe use [`cmake`](https://cmake.org) as the build system:\n\n```\n> mkdir -p out/release\n> cd out/release\n> cmake ../..\n> make\n```\nThis builds the library as a shared (dynamic)\nlibrary (`.so` or `.dylib`), a static library (`.a`), and\nas a single object file (`.o`).\n\n`> sudo make install` (install the library and header files in `/usr/local/lib`  and `/usr/local/include`)\n\nYou can build the debug version which does many internal checks and\nmaintains detailed statistics as:\n\n```\n> mkdir -p out/debug\n> cd out/debug\n> cmake -DCMAKE_BUILD_TYPE=Debug ../..\n> make\n```\n\nThis will name the shared library as `libmimalloc-debug.so`.\n\nFinally, you can build a _secure_ version that uses guard pages, encrypted free lists, etc., as:\n\n```\n> mkdir -p out/secure\n> cd out/secure\n> cmake -DMI_SECURE=ON ../..\n> make\n```\n\nThis will name the shared library as `libmimalloc-secure.so`.\nUse `cmake ../.. -LH` to see all the available build options.\n\nThe examples use the default compiler. If you like to use another, use:\n\n```\n> CC=clang CXX=clang++ cmake ../..\n```\n\n## Cmake with Visual Studio\n\nYou can also use cmake on Windows. Open a Visual Studio 2022 development prompt \nand invoke `cmake` with the right [generator](https://cmake.org/cmake/help/latest/generator/Visual%20Studio%2017%202022.html) \nand architecture, like:\n\n```\n> cmake ..\\.. -G \"Visual Studio 17 2022\" -A x64 -DMI_OVERRIDE=ON\n```\n\nThe cmake build type is specified when actually building, for example:\n\n```\n> cmake --build . --config=Release\n```\n\nYou can also install the [LLVM toolset](https://learn.microsoft.com/en-us/cpp/build/clang-support-msbuild?view=msvc-170#install-1) \non Windows to build with the `clang-cl` compiler directly:\n\n```\n> cmake ../.. -G \"Visual Studio 17 2022\" -T ClangCl\n```\n\n\n## Single source\n\nYou can also directly build the single `src/static.c` file as part of your project without\nneeding `cmake` at all. Make sure to also add the mimalloc `include` directory to the include path.\n\n\n# Using the library\n\nThe preferred usage is including `<mimalloc.h>`, linking with\nthe shared- or static library, and using the `mi_malloc` API exclusively for allocation. For example,\n```\n> gcc -o myprogram -lmimalloc myfile.c\n```\n\nmimalloc uses only safe OS calls (`mmap` and `VirtualAlloc`) and can co-exist\nwith other allocators linked to the same program.\nIf you use `cmake`, you can simply use:\n```\nfind_package(mimalloc 1.8 REQUIRED)\n```\nin your `CMakeLists.txt` to find a locally installed mimalloc. Then use either:\n```\ntarget_link_libraries(myapp PUBLIC mimalloc)\n```\nto link with the shared (dynamic) library, or:\n```\ntarget_link_libraries(myapp PUBLIC mimalloc-static)\n```\nto link with the static library. See `test\\CMakeLists.txt` for an example.\n\nFor best performance in C++ programs, it is also recommended to override the\nglobal `new` and `delete` operators. For convenience, mimalloc provides\n[`mimalloc-new-delete.h`](include/mimalloc-new-delete.h) which does this for you -- just include it in a single(!) source file in your project.\nIn C++, mimalloc also provides the `mi_stl_allocator` struct which implements the `std::allocator`\ninterface.\n\nYou can pass environment variables to print verbose messages (`MIMALLOC_VERBOSE=1`)\nand statistics (`MIMALLOC_SHOW_STATS=1`) (in the debug version):\n```\n> env MIMALLOC_SHOW_STATS=1 ./cfrac 175451865205073170563711388363\n\n175451865205073170563711388363 = 374456281610909315237213 * 468551\n\nheap stats:     peak      total      freed       unit\nnormal   2:    16.4 kb    17.5 mb    17.5 mb      16 b   ok\nnormal   3:    16.3 kb    15.2 mb    15.2 mb      24 b   ok\nnormal   4:      64 b      4.6 kb     4.6 kb      32 b   ok\nnormal   5:      80 b    118.4 kb   118.4 kb      40 b   ok\nnormal   6:      48 b       48 b       48 b       48 b   ok\nnormal  17:     960 b      960 b      960 b      320 b   ok\n\nheap stats:     peak      total      freed       unit\n    normal:    33.9 kb    32.8 mb    32.8 mb       1 b   ok\n      huge:       0 b        0 b        0 b        1 b   ok\n     total:    33.9 kb    32.8 mb    32.8 mb       1 b   ok\nmalloc requested:         32.8 mb\n\n committed:    58.2 kb    58.2 kb    58.2 kb       1 b   ok\n  reserved:     2.0 mb     2.0 mb     2.0 mb       1 b   ok\n     reset:       0 b        0 b        0 b        1 b   ok\n  segments:       1          1          1\n-abandoned:       0\n     pages:       6          6          6\n-abandoned:       0\n     mmaps:       3\n mmap fast:       0\n mmap slow:       1\n   threads:       0\n   elapsed:     2.022s\n   process: user: 1.781s, system: 0.016s, faults: 756, reclaims: 0, rss: 2.7 mb\n```\n\nThe above model of using the `mi_` prefixed API is not always possible\nthough in existing programs that already use the standard malloc interface,\nand another option is to override the standard malloc interface\ncompletely and redirect all calls to the _mimalloc_ library instead .\n\n## Environment Options\n\nYou can set further options either programmatically (using [`mi_option_set`](https://microsoft.github.io/mimalloc/group__options.html)), or via environment variables:\n\n- `MIMALLOC_SHOW_STATS=1`: show statistics when the program terminates.\n- `MIMALLOC_VERBOSE=1`: show verbose messages.\n- `MIMALLOC_SHOW_ERRORS=1`: show error and warning messages.\n\nAdvanced options:\n\n- `MIMALLOC_ARENA_EAGER_COMMIT=2`: turns on eager commit for the large arenas (usually 1GiB) from which mimalloc\n   allocates segments and pages. Set this to 2 (default) to\n   only enable this on overcommit systems (e.g. Linux). Set this to 1 to enable explicitly on other systems\n   as well (like Windows or macOS) which may improve performance (as the whole arena is committed at once).\n   Note that eager commit only increases the commit but not the actual the peak resident set\n   (rss) so it is generally ok to enable this.\n- `MIMALLOC_PURGE_DELAY=N`: the delay in `N` milli-seconds (by default `10`) after which mimalloc will purge\n   OS pages that are not in use. This signals to the OS that the underlying physical memory can be reused which\n   can reduce memory fragmentation especially in long running (server) programs. Setting `N` to `0` purges immediately when\n   a page becomes unused which can improve memory usage but also decreases performance. Setting `N` to a higher\n   value like `100` can improve performance (sometimes by a lot) at the cost of potentially using more memory at times.\n   Setting it to `-1` disables purging completely.\n- `MIMALLOC_PURGE_DECOMMITS=1`: By default \"purging\" memory means unused memory is decommitted (`MEM_DECOMMIT` on Windows,\n   `MADV_DONTNEED` (which decresease rss immediately) on `mmap` systems). Set this to 0 to instead \"reset\" unused\n   memory on a purge (`MEM_RESET` on Windows, generally `MADV_FREE` (which does not decrease rss immediately) on `mmap` systems).\n   Mimalloc generally does not \"free\" OS memory but only \"purges\" OS memory, in other words, it tries to keep virtual\n   address ranges and decommits within those ranges (to make the underlying physical memory available to other processes).\n\nFurther options for large workloads and services:\n\n- `MIMALLOC_USE_NUMA_NODES=N`: pretend there are at most `N` NUMA nodes. If not set, the actual NUMA nodes are detected\n   at runtime. Setting `N` to 1 may avoid problems in some virtual environments. Also, setting it to a lower number than\n   the actual NUMA nodes is fine and will only cause threads to potentially allocate more memory across actual NUMA\n   nodes (but this can happen in any case as NUMA local allocation is always a best effort but not guaranteed).\n- `MIMALLOC_ALLOW_LARGE_OS_PAGES=0`: Set to 1 to use large OS pages (2 or 4MiB) when available; for some workloads this can significantly\n   improve performance. When this option is disabled (default), it also disables transparent huge pages (THP) for the process\n   (on Linux and Android). On Linux the default setting is 2 -- this enables the use of large pages through THP only.\n   Use `MIMALLOC_VERBOSE` to check if the large OS pages are enabled -- usually one needs\n   to explicitly give permissions for large OS pages (as on [Windows][windows-huge] and [Linux][linux-huge]). However, sometimes\n   the OS is very slow to reserve contiguous physical memory for large OS pages so use with care on systems that\n   can have fragmented memory (for that reason, we generally recommend to use `MIMALLOC_RESERVE_HUGE_OS_PAGES` instead whenever possible).\n- `MIMALLOC_RESERVE_HUGE_OS_PAGES=N`: where `N` is the number of 1GiB _huge_ OS pages. This reserves the huge pages at\n   startup and sometimes this can give a large (latency) performance improvement on big workloads.\n   Usually it is better to not use `MIMALLOC_ALLOW_LARGE_OS_PAGES=1` in combination with this setting. Just like large\n   OS pages, use with care as reserving\n   contiguous physical memory can take a long time when memory is fragmented (but reserving the huge pages is done at\n   startup only once).\n   Note that we usually need to explicitly give permission for huge OS pages (as on [Windows][windows-huge] and [Linux][linux-huge])).\n   With huge OS pages, it may be beneficial to set the setting\n   `MIMALLOC_EAGER_COMMIT_DELAY=N` (`N` is 1 by default) to delay the initial `N` segments (of 4MiB)\n   of a thread to not allocate in the huge OS pages; this prevents threads that are short lived\n   and allocate just a little to take up space in the huge OS page area (which cannot be purged as huge OS pages are pinned\n   to physical memory).\n   The huge pages are usually allocated evenly among NUMA nodes.\n   We can use `MIMALLOC_RESERVE_HUGE_OS_PAGES_AT=N` where `N` is the numa node (starting at 0) to allocate all\n   the huge pages at a specific numa node instead.\n\nUse caution when using `fork` in combination with either large or huge OS pages: on a fork, the OS uses copy-on-write\nfor all pages in the original process including the huge OS pages. When any memory is now written in that area, the\nOS will copy the entire 1GiB huge page (or 2MiB large page) which can cause the memory usage to grow in large increments.\n\n[linux-huge]: https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/tuning_and_optimizing_red_hat_enterprise_linux_for_oracle_9i_and_10g_databases/sect-oracle_9i_and_10g_tuning_guide-large_memory_optimization_big_pages_and_huge_pages-configuring_huge_pages_in_red_hat_enterprise_linux_4_or_5\n[windows-huge]: https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/enable-the-lock-pages-in-memory-option-windows?view=sql-server-2017\n\n## Secure Mode\n\n_mimalloc_ can be build in secure mode by using the `-DMI_SECURE=ON` flags in `cmake`. This build enables various mitigations\nto make mimalloc more robust against exploits. In particular:\n\n- All internal mimalloc pages are surrounded by guard pages and the heap metadata is behind a guard page as well (so a buffer overflow\n  exploit cannot reach into the metadata).\n- All free list pointers are\n  [encoded](https://github.com/microsoft/mimalloc/blob/783e3377f79ee82af43a0793910a9f2d01ac7863/include/mimalloc-internal.h#L396)\n  with per-page keys which is used both to prevent overwrites with a known pointer, as well as to detect heap corruption.\n- Double free's are detected (and ignored).\n- The free lists are initialized in a random order and allocation randomly chooses between extension and reuse within a page to\n  mitigate against attacks that rely on a predicable allocation order. Similarly, the larger heap blocks allocated by mimalloc\n  from the OS are also address randomized.\n\nAs always, evaluate with care as part of an overall security strategy as all of the above are mitigations but not guarantees.\n\n## Debug Mode\n\nWhen _mimalloc_ is built using debug mode, (`-DCMAKE_BUILD_TYPE=Debug`), \nvarious checks are done at runtime to catch development errors.\n\n- Statistics are maintained in detail for each object size. They can be shown using `MIMALLOC_SHOW_STATS=1` at runtime.\n- All objects have padding at the end to detect (byte precise) heap block overflows.\n- Double free's, and freeing invalid heap pointers are detected.\n- Corrupted free-lists and some forms of use-after-free are detected.\n\n## Guarded Mode\n\n<span id=\"guarded\">_mimalloc_ can be build in guarded mode using the `-DMI_GUARDED=ON` flags in `cmake`.</span>\nThis enables placing OS guard pages behind certain object allocations to catch buffer overflows as they occur.\nThis can be invaluable to catch buffer-overflow bugs in large programs. However, it also means that any object\nallocated with a guard page takes at least 8 KiB memory for the guard page and its alignment. As such, allocating\na guard page for every allocation may be too expensive both in terms of memory, and in terms of performance with\nmany system calls. Therefore, there are various environment variables (and options) to tune this:\n\n- `MIMALLOC_GUARDED_SAMPLE_RATE=N`: Set the sample rate to `N` (by default 4000). This mode places a guard page\n  behind every `N` suitable object allocations (per thread). Since the performance in guarded mode without placing\n  guard pages is close to release mode, this can be used to enable guard pages even in production to catch latent \n  buffer overflow bugs. Set the sample rate to `1` to guard every object, and to `0` to place no guard pages at all.\n\n- `MIMALLOC_GUARDED_SAMPLE_SEED=N`: Start sampling at `N` (by default random). Can be used to reproduce a buffer\n  overflow if needed.\n\n- `MIMALLOC_GUARDED_MIN=N`, `MIMALLOC_GUARDED_MAX=N`: Minimal and maximal _rounded_ object sizes for which a guard \n  page is considered (`0` and `1GiB` respectively). If you suspect a buffer overflow occurs with an object of size\n  141, set the minimum and maximum to `148` and the sample rate to `1` to have all of those guarded.\n\n- `MIMALLOC_GUARDED_PRECISE=1`: If we have an object of size 13, we would usually place it an aligned 16 bytes in\n  front of the guard page. Using `MIMALLOC_GUARDED_PRECISE` places it exactly 13 bytes before a page so that even\n  a 1 byte overflow is detected. This violates the C/C++ minimal alignment guarantees though so use with care.\n\n\n# Overriding Standard Malloc\n\nOverriding the standard `malloc` (and `new`) can be done either _dynamically_ or _statically_.\n\n## Dynamic override\n\nThis is the recommended way to override the standard malloc interface.\n\n### Dynamic Override on Linux, BSD\n\nOn these ELF-based systems we preload the mimalloc shared\nlibrary so all calls to the standard `malloc` interface are\nresolved to the _mimalloc_ library.\n```\n> env LD_PRELOAD=/usr/lib/libmimalloc.so myprogram\n```\n\nYou can set extra environment variables to check that mimalloc is running,\nlike:\n```\n> env MIMALLOC_VERBOSE=1 LD_PRELOAD=/usr/lib/libmimalloc.so myprogram\n```\nor run with the debug version to get detailed statistics:\n```\n> env MIMALLOC_SHOW_STATS=1 LD_PRELOAD=/usr/lib/libmimalloc-debug.so myprogram\n```\n\n### Dynamic Override on MacOS\n\nOn macOS we can also preload the mimalloc shared\nlibrary so all calls to the standard `malloc` interface are\nresolved to the _mimalloc_ library.\n```\n> env DYLD_INSERT_LIBRARIES=/usr/lib/libmimalloc.dylib myprogram\n```\n\nNote that certain security restrictions may apply when doing this from\nthe [shell](https://stackoverflow.com/questions/43941322/dyld-insert-libraries-ignored-when-calling-application-through-bash).\n\n\n# Windows Override\n\n<span id=\"override_on_windows\">Dynamically overriding on mimalloc on Windows</span> \nis robust and has the particular advantage to be able to redirect all malloc/free calls \nthat go through the (dynamic) C runtime allocator, including those from other DLL's or \nlibraries. As it intercepts all allocation calls on a low level, it can be used reliably \non large programs that include other 3rd party components.\nThere are four requirements to make the overriding work well:\n\n1. Use the C-runtime library as a DLL (using the `/MD` or `/MDd` switch).\n\n2. Link your program explicitly with the `mimalloc.lib` export library for the `mimalloc.dll`.\n   (which must be compiled with `-DMI_OVERRIDE=ON`, which is the default though).\n   To ensure the `mimalloc.dll` is actually loaded at run-time it is easiest \n   to insert some call to the mimalloc API in the `main` function, like `mi_version()`\n   (or use the `/include:mi_version` switch on the linker command, or\n   similarly, `#pragma comment(linker, \"/include:mi_version\")` in some source file). \n   See the `mimalloc-test-override` project for an example on how to use this. \n\n3. The `mimalloc-redirect.dll` must be put in the same directory as the main \n   `mimalloc.dll` at runtime (as it is a dependency of that DLL).\n   The redirection DLL ensures that all calls to the C runtime malloc API get \n   redirected to mimalloc functions (which reside in `mimalloc.dll`).\n\n4. Ensure the `mimalloc.dll` comes as early as possible in the import\n   list of the final executable (so it can intercept all potential allocations).\n   You can use `minject -l <exe>` to check this if needed.\n\nFor best performance on Windows with C++, it\nis also recommended to also override the `new`/`delete` operations (by including\n[`mimalloc-new-delete.h`](include/mimalloc-new-delete.h)\na single(!) source file in your project).\n\nThe environment variable `MIMALLOC_DISABLE_REDIRECT=1` can be used to disable dynamic\noverriding at run-time. Use `MIMALLOC_VERBOSE=1` to check if mimalloc was successfully \nredirected.\n\nFor different platforms than x64, you may need a specific [redirection dll](bin).\nFurthermore, we cannot always re-link an executable or ensure `mimalloc.dll` comes\nfirst in the import table. In such cases the [`minject`](bin) tool can be used\nto patch the executable's import tables.\n\n\n## Static override\n\nOn Unix-like systems, you can also statically link with _mimalloc_ to override the standard\nmalloc interface. The recommended way is to link the final program with the\n_mimalloc_ single object file (`mimalloc.o`). We use\nan object file instead of a library file as linkers give preference to\nthat over archives to resolve symbols. To ensure that the standard\nmalloc interface resolves to the _mimalloc_ library, link it as the first\nobject file. For example:\n\n```\n> gcc -o myprogram mimalloc.o  myfile1.c ...\n```\n\nAnother way to override statically that works on all platforms, is to\nlink statically to mimalloc (as shown in the introduction) and include a\nheader file in each source file that re-defines `malloc` etc. to `mi_malloc`.\nThis is provided by [`mimalloc-override.h`](include/mimalloc-override.h). This only works \nreliably though if all sources are\nunder your control or otherwise mixing of pointers from different heaps may occur!\n\n\n# Tools\n\nGenerally, we recommend using the standard allocator with memory tracking tools, but mimalloc\ncan also be build to support the [address sanitizer][asan] or the excellent [Valgrind] tool.\nMoreover, it can be build to support Windows event tracing ([ETW]).\nThis has a small performance overhead but does allow detecting memory leaks and byte-precise\nbuffer overflows directly on final executables. See also the `test/test-wrong.c` file to test with various tools.\n\n## Valgrind\n\nTo build with [valgrind] support, use the `MI_TRACK_VALGRIND=ON` cmake option:\n\n```\n> cmake ../.. -DMI_TRACK_VALGRIND=ON\n```\n\nThis can also be combined with secure mode or debug mode.\nYou can then run your programs directly under valgrind:\n\n```\n> valgrind <myprogram>\n```\n\nIf you rely on overriding `malloc`/`free` by mimalloc (instead of using the `mi_malloc`/`mi_free` API directly),\nyou also need to tell `valgrind` to not intercept those calls itself, and use:\n\n```\n> MIMALLOC_SHOW_STATS=1 valgrind  --soname-synonyms=somalloc=*mimalloc* -- <myprogram>\n```\n\nBy setting the `MIMALLOC_SHOW_STATS` environment variable you can check that mimalloc is indeed\nused and not the standard allocator. Even though the [Valgrind option][valgrind-soname]\nis called `--soname-synonyms`, this also works when overriding with a static library or object file.\nTo dynamically override mimalloc using `LD_PRELOAD` together with `valgrind`, use:\n\n```\n> valgrind --trace-children=yes --soname-synonyms=somalloc=*mimalloc* /usr/bin/env LD_PRELOAD=/usr/lib/libmimalloc.so -- <myprogram>\n```\n\nSee also the `test/test-wrong.c` file to test with `valgrind`.\n\nValgrind support is in its initial development -- please report any issues.\n\n[Valgrind]: https://valgrind.org/\n[valgrind-soname]: https://valgrind.org/docs/manual/manual-core.html#opt.soname-synonyms\n\n## ASAN\n\nTo build with the address sanitizer, use the `-DMI_TRACK_ASAN=ON` cmake option:\n\n```\n> cmake ../.. -DMI_TRACK_ASAN=ON\n```\n\nThis can also be combined with secure mode or debug mode.\nYou can then run your programs as:'\n\n```\n> ASAN_OPTIONS=verbosity=1 <myprogram>\n```\n\nWhen you link a program with an address sanitizer build of mimalloc, you should\ngenerally compile that program too with the address sanitizer enabled.\nFor example, assuming you build mimalloc in `out/debug`:\n\n```\nclang -g -o test-wrong -Iinclude test/test-wrong.c out/debug/libmimalloc-asan-debug.a -lpthread -fsanitize=address -fsanitize-recover=address\n```\n\nSince the address sanitizer redirects the standard allocation functions, on some platforms (macOSX for example)\nit is required to compile mimalloc with `-DMI_OVERRIDE=OFF`.\nAddress sanitizer support is in its initial development -- please report any issues.\n\n[asan]: https://github.com/google/sanitizers/wiki/AddressSanitizer\n\n## ETW\n\nEvent tracing for Windows ([ETW]) provides a high performance way to capture all allocations though\nmimalloc and analyze them later. To build with ETW support, use the `-DMI_TRACK_ETW=ON` cmake option.\n\nYou can then capture an allocation trace using the Windows performance recorder (WPR), using the\n`src/prim/windows/etw-mimalloc.wprp` profile. In an admin prompt, you can use:\n```\n> wpr -start src\\prim\\windows\\etw-mimalloc.wprp -filemode\n> <my_mimalloc_program>\n> wpr -stop <my_mimalloc_program>.etl\n```\nand then open `<my_mimalloc_program>.etl` in the Windows Performance Analyzer (WPA), or\nuse a tool like [TraceControl] that is specialized for analyzing mimalloc traces.\n\n[ETW]: https://learn.microsoft.com/en-us/windows-hardware/test/wpt/event-tracing-for-windows\n[TraceControl]: https://github.com/xinglonghe/TraceControl\n\n\n# Performance\n\nLast update: 2021-01-30\n\nWe tested _mimalloc_ against many other top allocators over a wide\nrange of benchmarks, ranging from various real world programs to\nsynthetic benchmarks that see how the allocator behaves under more\nextreme circumstances. In our benchmark suite, _mimalloc_ outperforms other leading\nallocators (_jemalloc_, _tcmalloc_, _Hoard_, etc), and has a similar memory footprint. A nice property is that it\ndoes consistently well over the wide range of benchmarks.\n\nGeneral memory allocators are interesting as there exists no algorithm that is\noptimal -- for a given allocator one can usually construct a workload\nwhere it does not do so well. The goal is thus to find an allocation\nstrategy that performs well over a wide range of benchmarks without\nsuffering from (too much) underperformance in less common situations.\n\nAs always, interpret these results with care since some benchmarks test synthetic\nor uncommon situations that may never apply to your workloads. For example, most\nallocators do not do well on `xmalloc-testN` but that includes even the best\nindustrial allocators like _jemalloc_ and _tcmalloc_ that are used in some of\nthe world's largest systems (like Chrome or FreeBSD).\n\nAlso, the benchmarks here do not measure the behaviour on very large and long-running server workloads,\nor worst-case latencies of allocation. Much work has gone into `mimalloc` to work well on such\nworkloads (for example, to reduce virtual memory fragmentation on long-running services)\nbut such optimizations are not always reflected in the current benchmark suite.\n\nWe show here only an overview -- for\nmore specific details and further benchmarks we refer to the\n[technical report](https://www.microsoft.com/en-us/research/publication/mimalloc-free-list-sharding-in-action).\nThe benchmark suite is automated and available separately\nas [mimalloc-bench](https://github.com/daanx/mimalloc-bench).\n\n\n## Benchmark Results on a 16-core AMD 5950x (Zen3)\n\nTesting on the 16-core AMD 5950x processor at 3.4Ghz (4.9Ghz boost), with\nwith 32GiB memory at 3600Mhz, running\tUbuntu 20.04 with glibc 2.31 and GCC 9.3.0.\n\nWe measure three versions of _mimalloc_: the main version `mi` (tag:v1.7.0),\nthe new v2.0 beta version as `xmi` (tag:v2.0.0), and the main version in secure mode as `smi` (tag:v1.7.0).\n\nThe other allocators are\nGoogle's [_tcmalloc_](https://github.com/gperftools/gperftools) (`tc`, tag:gperftools-2.8.1) used in Chrome,\nFacebook's [_jemalloc_](https://github.com/jemalloc/jemalloc) (`je`, tag:5.2.1) by Jason Evans used in Firefox and FreeBSD,\nthe Intel thread building blocks [allocator](https://github.com/intel/tbb) (`tbb`, tag:v2020.3),\n[rpmalloc](https://github.com/mjansson/rpmalloc) (`rp`,tag:1.4.1) by Mattias Jansson,\nthe original scalable [_Hoard_](https://github.com/emeryberger/Hoard) (git:d880f72) allocator by Emery Berger \\[1],\nthe memory compacting [_Mesh_](https://github.com/plasma-umass/Mesh) (git:67ff31a) allocator by\nBobby Powers _et al_ \\[8],\nand finally the default system allocator (`glibc`, 2.31) (based on _PtMalloc2_).\n\n<img width=\"90%\" src=\"doc/bench-2021/bench-amd5950x-2021-01-30-a.svg\"/>\n<img width=\"90%\" src=\"doc/bench-2021/bench-amd5950x-2021-01-30-b.svg\"/>\n\nAny benchmarks ending in `N` run on all 32 logical cores in parallel.\nResults are averaged over 10 runs and reported relative\nto mimalloc (where 1.2 means it took 1.2&times; longer to run).\nThe legend also contains the _overall relative score_ between the\nallocators where 100 points is the maximum if an allocator is fastest on\nall benchmarks.\n\nThe single threaded _cfrac_ benchmark by Dave Barrett is an implementation of\ncontinued fraction factorization which uses many small short-lived allocations.\nAll allocators do well on such common usage, where _mimalloc_ is just a tad\nfaster than _tcmalloc_ and\n_jemalloc_.\n\nThe _leanN_ program is interesting as a large realistic and\nconcurrent workload of the [Lean](https://github.com/leanprover/lean)\ntheorem prover compiling its own standard library, and there is a 13%\nspeedup over _tcmalloc_. This is\nquite significant: if Lean spends 20% of its time in the\nallocator that means that _mimalloc_ is 1.6&times; faster than _tcmalloc_\nhere. (This is surprising as that is not measured in a pure\nallocation benchmark like _alloc-test_. We conjecture that we see this\noutsized improvement here because _mimalloc_ has better locality in\nthe allocation which improves performance for the *other* computations\nin a program as well).\n\nThe single threaded _redis_ benchmark again show that most allocators do well on such workloads.\n\nThe _larsonN_ server benchmark by Larson and Krishnan \\[2] allocates and frees between threads. They observed this\nbehavior (which they call _bleeding_) in actual server applications, and the benchmark simulates this.\nHere, _mimalloc_ is quite a bit faster than _tcmalloc_ and _jemalloc_ probably due to the object migration between different threads.\n\nThe _mstressN_ workload performs many allocations and re-allocations,\nand migrates objects between threads (as in _larsonN_). However, it also\ncreates  and destroys the _N_ worker threads a few times keeping some objects\nalive beyond the life time of the allocating thread. We observed this\nbehavior in many larger server applications.\n\nThe [_rptestN_](https://github.com/mjansson/rpmalloc-benchmark) benchmark\nby Mattias Jansson is a allocator test originally designed\nfor _rpmalloc_, and tries to simulate realistic allocation patterns over\nmultiple threads. Here the differences between allocators become more apparent.\n\nThe second benchmark set tests specific aspects of the allocators and\nshows even more extreme differences between them.\n\nThe _alloc-test_, by\n[OLogN Technologies AG](http://ithare.com/testing-memory-allocators-ptmalloc2-tcmalloc-hoard-jemalloc-while-trying-to-simulate-real-world-loads/), is a very allocation intensive benchmark doing millions of\nallocations in various size classes. The test is scaled such that when an\nallocator performs almost identically on _alloc-test1_ as _alloc-testN_ it\nmeans that it scales linearly.\n\nThe _sh6bench_ and _sh8bench_ benchmarks are\ndeveloped by [MicroQuill](http://www.microquill.com/) as part of SmartHeap.\nIn _sh6bench_ _mimalloc_ does much\nbetter than the others (more than 2.5&times; faster than _jemalloc_).\nWe cannot explain this well but believe it is\ncaused in part by the \"reverse\" free-ing pattern in _sh6bench_.\nThe _sh8bench_ is a variation with object migration\nbetween threads; whereas _tcmalloc_ did well on _sh6bench_, the addition of object migration causes it to be 10&times; slower than before.\n\nThe _xmalloc-testN_ benchmark by Lever and Boreham \\[5] and Christian Eder, simulates an asymmetric workload where\nsome threads only allocate, and others only free -- they observed this pattern in\nlarger server applications. Here we see that\nthe _mimalloc_ technique of having non-contended sharded thread free\nlists pays off as it outperforms others by a very large margin. Only _rpmalloc_, _tbb_, and _glibc_ also scale well on this benchmark.\n\nThe _cache-scratch_ benchmark by Emery Berger \\[1], and introduced with\nthe Hoard allocator to test for _passive-false_ sharing of cache lines.\nWith a single thread they all\nperform the same, but when running with multiple threads the potential allocator\ninduced false sharing of the cache lines can cause large run-time differences.\nCrundal \\[6] describes in detail why the false cache line sharing occurs in the _tcmalloc_ design, and also discusses how this\ncan be avoided with some small implementation changes.\nOnly the _tbb_, _rpmalloc_ and _mesh_ allocators also avoid the\ncache line sharing completely, while _Hoard_ and _glibc_ seem to mitigate\nthe effects. Kukanov and Voss \\[7] describe in detail\nhow the design of _tbb_ avoids the false cache line sharing.\n\n\n## On a 36-core Intel Xeon\n\nFor completeness, here are the results on a big Amazon\n[c5.18xlarge](https://aws.amazon.com/ec2/instance-types/#Compute_Optimized) instance\nconsisting of a 2&times;18-core Intel Xeon (Cascade Lake) at 3.4GHz (boost 3.5GHz)\nwith 144GiB ECC memory, running\tUbuntu 20.04 with glibc 2.31, GCC 9.3.0, and\nClang 10.0.0. This time, the mimalloc allocators (mi, xmi, and smi) were\ncompiled with the Clang compiler instead of GCC.\nThe results are similar to the AMD results but it is interesting to\nsee the differences in the _larsonN_, _mstressN_, and _xmalloc-testN_ benchmarks.\n\n<img width=\"90%\" src=\"doc/bench-2021/bench-c5-18xlarge-2021-01-30-a.svg\"/>\n<img width=\"90%\" src=\"doc/bench-2021/bench-c5-18xlarge-2021-01-30-b.svg\"/>\n\n\n## Peak Working Set\n\nThe following figure shows the peak working set (rss) of the allocators\non the benchmarks (on the c5.18xlarge instance).\n\n<img width=\"90%\" src=\"doc/bench-2021/bench-c5-18xlarge-2021-01-30-rss-a.svg\"/>\n<img width=\"90%\" src=\"doc/bench-2021/bench-c5-18xlarge-2021-01-30-rss-b.svg\"/>\n\nNote that the _xmalloc-testN_ memory usage should be disregarded as it\nallocates more the faster the program runs. Similarly, memory usage of\n_larsonN_, _mstressN_, _rptestN_ and _sh8bench_ can vary depending on scheduling and\nspeed. Nevertheless, we hope to improve the memory usage on _mstressN_\nand _rptestN_ (just as _cfrac_, _larsonN_ and _sh8bench_ have a small working set which skews the results).\n\n<!--\n# Previous Benchmarks\n\nTodo: should we create a separate page for this?\n\n## Benchmark Results on 36-core Intel: 2020-01-20\n\nTesting on a big Amazon EC2 compute instance\n([c5.18xlarge](https://aws.amazon.com/ec2/instance-types/#Compute_Optimized))\nconsisting of a 72 processor Intel Xeon at 3GHz\nwith 144GiB ECC memory, running\tUbuntu 18.04.1 with glibc 2.27 and GCC 7.4.0.\nThe measured allocators are _mimalloc_ (xmi, tag:v1.4.0, page reset enabled)\nand its secure build as _smi_,\nGoogle's [_tcmalloc_](https://github.com/gperftools/gperftools) (tc, tag:gperftools-2.7) used in Chrome,\nFacebook's [_jemalloc_](https://github.com/jemalloc/jemalloc) (je, tag:5.2.1) by Jason Evans used in Firefox and FreeBSD,\nthe Intel thread building blocks [allocator](https://github.com/intel/tbb) (tbb, tag:2020),\n[rpmalloc](https://github.com/mjansson/rpmalloc) (rp,tag:1.4.0) by Mattias Jansson,\nthe original scalable [_Hoard_](https://github.com/emeryberger/Hoard) (tag:3.13) allocator by Emery Berger \\[1],\nthe memory compacting [_Mesh_](https://github.com/plasma-umass/Mesh) (git:51222e7) allocator by\nBobby Powers _et al_ \\[8],\nand finally the default system allocator (glibc, 2.27) (based on _PtMalloc2_).\n\n<img width=\"90%\" src=\"doc/bench-2020/bench-c5-18xlarge-2020-01-20-a.svg\"/>\n<img width=\"90%\" src=\"doc/bench-2020/bench-c5-18xlarge-2020-01-20-b.svg\"/>\n\nThe following figure shows the peak working set (rss) of the allocators\non the benchmarks (on the c5.18xlarge instance).\n\n<img width=\"90%\" src=\"doc/bench-2020/bench-c5-18xlarge-2020-01-20-rss-a.svg\"/>\n<img width=\"90%\" src=\"doc/bench-2020/bench-c5-18xlarge-2020-01-20-rss-b.svg\"/>\n\n\n## On 24-core AMD Epyc, 2020-01-16\n\nFor completeness, here are the results on a\n[r5a.12xlarge](https://aws.amazon.com/ec2/instance-types/#Memory_Optimized) instance\nhaving a 48 processor AMD Epyc 7000 at 2.5GHz with 384GiB of memory.\nThe results are similar to the Intel results but it is interesting to\nsee the differences in the _larsonN_, _mstressN_, and _xmalloc-testN_ benchmarks.\n\n<img width=\"90%\" src=\"doc/bench-2020/bench-r5a-12xlarge-2020-01-16-a.svg\"/>\n<img width=\"90%\" src=\"doc/bench-2020/bench-r5a-12xlarge-2020-01-16-b.svg\"/>\n\n-->\n\n\n# References\n\n- \\[1] Emery D. Berger, Kathryn S. McKinley, Robert D. Blumofe, and Paul R. Wilson.\n   _Hoard: A Scalable Memory Allocator for Multithreaded Applications_\n   the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-IX). Cambridge, MA, November 2000.\n   [pdf](http://www.cs.utexas.edu/users/mckinley/papers/asplos-2000.pdf)\n\n- \\[2] P. Larson and M. Krishnan. _Memory allocation for long-running server applications_.\n  In ISMM, Vancouver, B.C., Canada, 1998. [pdf](http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.45.1947&rep=rep1&type=pdf)\n\n- \\[3] D. Grunwald, B. Zorn, and R. Henderson.\n  _Improving the cache locality of memory allocation_. In R. Cartwright, editor,\n  Proceedings of the Conference on Programming Language Design and Implementation, pages 177186, New York, NY, USA, June 1993. [pdf](http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.43.6621&rep=rep1&type=pdf)\n\n- \\[4] J. Barnes and P. Hut. _A hierarchical O(n*log(n)) force-calculation algorithm_. Nature, 324:446-449, 1986.\n\n- \\[5] C. Lever, and D. Boreham. _Malloc() Performance in a Multithreaded Linux Environment._\n  In USENIX Annual Technical Conference, Freenix Session. San Diego, CA. Jun. 2000.\n  Available at <https://github.com/kuszmaul/SuperMalloc/tree/master/tests>\n\n- \\[6] Timothy Crundal. _Reducing Active-False Sharing in TCMalloc_. 2016. CS16S1 project at the Australian National University. [pdf](http://courses.cecs.anu.edu.au/courses/CSPROJECTS/16S1/Reports/Timothy_Crundal_Report.pdf)\n\n- \\[7] Alexey Kukanov, and Michael J Voss.\n   _The Foundations for Scalable Multi-Core Software in Intel Threading Building Blocks._\n   Intel Technology Journal 11 (4). 2007\n\n- \\[8] Bobby Powers, David Tench, Emery D. Berger, and Andrew McGregor.\n _Mesh: Compacting Memory Management for C/C++_\n In Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI'19), June 2019, pages 333-346.\n\n<!--\n- \\[9] Paul Litar, Theodore Butler, Sylvan Clebsch, Sophia Drossopoulou, Juliana Franco, Matthew J Parkinson,\n  Alex Shamis, Christoph M Wintersteiger, and David Chisnall.\n  _Snmalloc: A Message Passing Allocator._\n  In Proceedings of the 2019 ACM SIGPLAN International Symposium on Memory Management, 122135. ACM. 2019.\n-->\n\n# Contributing\n\nThis project welcomes contributions and suggestions.  Most contributions require you to agree to a\nContributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us\nthe rights to use your contribution. For details, visit https://cla.microsoft.com.\n\nWhen you submit a pull request, a CLA-bot will automatically determine whether you need to provide\na CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions\nprovided by the bot. You will only need to do this once across all repos using our CLA.\n\n\n# Older Release Notes\n\n* 2021-11-14, `v1.7.3`, `v2.0.3` (beta): improved WASM support, improved macOS support and performance (including\n  M1), improved performance for v2 for large objects, Python integration improvements, more standard\n  installation directories, various small fixes.\n* 2021-06-17, `v1.7.2`, `v2.0.2` (beta): support M1, better installation layout on Linux, fix\n  thread_id on Android, prefer 2-6TiB area for aligned allocation to work better on pre-windows 8, various small fixes.\n* 2021-04-06, `v1.7.1`, `v2.0.1` (beta): fix bug in arena allocation for huge pages, improved aslr on large allocations, initial M1 support (still experimental).\n* 2021-01-31, `v2.0.0`: beta release 2.0: new slice algorithm for managing internal mimalloc pages.\n* 2021-01-31, `v1.7.0`: stable release 1.7: support explicit user provided memory regions, more precise statistics,\n  improve macOS overriding, initial support for Apple M1, improved DragonFly support, faster memcpy on Windows, various small fixes.\n\n* 2020-09-24, `v1.6.7`: stable release 1.6: using standard C atomics, passing tsan testing, improved\n  handling of failing to commit on Windows, add [`mi_process_info`](https://github.com/microsoft/mimalloc/blob/master/include/mimalloc.h#L156) api call.\n* 2020-08-06, `v1.6.4`: stable release 1.6: improved error recovery in low-memory situations,\n  support for IllumOS and Haiku, NUMA support for Vista/XP, improved NUMA detection for AMD Ryzen, ubsan support.\n* 2020-05-05, `v1.6.3`: stable release 1.6: improved behavior in out-of-memory situations, improved malloc zones on macOS,\n  build PIC static libraries by default, add option to abort on out-of-memory, line buffered statistics.\n* 2020-04-20, `v1.6.2`: stable release 1.6: fix compilation on Android, MingW, Raspberry, and Conda,\n  stability fix for Windows 7, fix multiple mimalloc instances in one executable, fix `strnlen` overload,\n  fix aligned debug padding.\n* 2020-02-17, `v1.6.1`: stable release 1.6: minor updates (build with clang-cl, fix alignment issue for small objects).\n* 2020-02-09, `v1.6.0`: stable release 1.6: fixed potential memory leak, improved overriding\n  and thread local support on FreeBSD, NetBSD, DragonFly, and macOSX. New byte-precise\n  heap block overflow detection in debug mode (besides the double-free detection and free-list\n  corruption detection). Add `nodiscard` attribute to most allocation functions.\n  Enable `MIMALLOC_PAGE_RESET` by default. New reclamation strategy for abandoned heap pages\n  for better memory footprint.\n* 2020-02-09, `v1.5.0`: stable release 1.5: improved free performance, small bug fixes.\n* 2020-01-22, `v1.4.0`: stable release 1.4: improved performance for delayed OS page reset,\nmore eager concurrent free, addition of STL allocator, fixed potential memory leak.\n* 2020-01-15, `v1.3.0`: stable release 1.3: bug fixes, improved randomness and [stronger\nfree list encoding](https://github.com/microsoft/mimalloc/blob/783e3377f79ee82af43a0793910a9f2d01ac7863/include/mimalloc-internal.h#L396) in secure mode.\n\n* 2019-12-22, `v1.2.2`: stable release 1.2: minor updates.\n* 2019-11-22, `v1.2.0`: stable release 1.2: bug fixes, improved secure mode (free list corruption checks, double free mitigation). Improved dynamic overriding on Windows.\n* 2019-10-07, `v1.1.0`: stable release 1.1.\n* 2019-09-01, `v1.0.8`: pre-release 8: more robust windows dynamic overriding, initial huge page support.\n* 2019-08-10, `v1.0.6`: pre-release 6: various performance improvements.\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}