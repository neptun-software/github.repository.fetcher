{
  "metadata": {
    "timestamp": 1736710406410,
    "page": 32,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "skywind3000/kcp",
      "stars": 15645,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1005859375,
          "content": "*.o\r\n*.obj\r\n*.exe\r\n*.dll\r\n*.so\r\n*.dylib\r\n*.ncb\r\n\r\n/.vscode/*\r\n/.idea/*\r\n/.DS_Store\r\n/.env\r\n/build/*\r\n\r\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.103515625,
          "content": "language: cpp\r\ncompiler:\r\n    - gcc\r\n    - clang\r\nscript:\r\n    - $CC -O3 test.cpp -o test -lstdc++\r\n\r\n\r\n\r\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 1.3271484375,
          "content": "CMAKE_MINIMUM_REQUIRED(VERSION 2.8.12)\n\nproject(kcp LANGUAGES C)\n\ninclude(CTest)\ninclude(GNUInstallDirs)\n\ncmake_policy(SET CMP0054 NEW)\n\nif(BUILD_SHARED_LIBS AND WIN32)\n    set(exports_def_file \"${CMAKE_CURRENT_BINARY_DIR}/exports.def\")\n    set(exports_def_contents\n\"EXPORTS \n    ikcp_create\n    ikcp_release\n    ikcp_setoutput\n    ikcp_recv\n    ikcp_send\n    ikcp_update\n    ikcp_check\n    ikcp_input\n    ikcp_flush\n    ikcp_peeksize\n    ikcp_setmtu\n    ikcp_wndsize\n    ikcp_waitsnd\n    ikcp_nodelay\n    ikcp_log\n    ikcp_allocator\n    ikcp_getconv\n\")\n\n    file(WRITE \"${exports_def_file}\" \"${exports_def_contents}\")\n    add_library(kcp ikcp.c \"${exports_def_file}\")\nelse()\n    add_library(kcp ikcp.c)\nendif()\n\ninstall(FILES ikcp.h DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}\")\n\ninstall(TARGETS kcp\n    EXPORT kcp-targets\n    ARCHIVE DESTINATION \"${CMAKE_INSTALL_LIBDIR}\"\n    LIBRARY DESTINATION \"${CMAKE_INSTALL_LIBDIR}\"\n    RUNTIME DESTINATION \"${CMAKE_INSTALL_BINDIR}\"\n    INCLUDES DESTINATION \"${CMAKE_INSTALL_INCLUDEDIR}\"\n)\n\ninstall(EXPORT kcp-targets\n    FILE kcp-config.cmake\n    NAMESPACE kcp::\n    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/kcp\n)\n\nif(BUILD_TESTING)\n    enable_language(CXX)\n\n    add_executable(kcp_test test.cpp)\n    if(MSVC AND NOT (MSVC_VERSION LESS 1900))\n        target_compile_options(kcp_test PRIVATE /utf-8)\n    endif()\nendif()\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.064453125,
          "content": "MIT License\n\nCopyright (c) 2017 Lin Wei (skywind3000 at gmail.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.en.md",
          "type": "blob",
          "size": 16.40234375,
          "content": "KCP - A Fast and Reliable ARQ Protocol\r\n======================================\r\n\r\n[![Powered][3]][1] \r\n[![GitHub license][6]][7]\r\n[![Backers on Open Collective](https://opencollective.com/kcp/backers/badge.svg)](#backers)\r\n [![Sponsors on Open Collective](https://opencollective.com/kcp/sponsors/badge.svg)](#sponsors) \r\n\r\n[1]: https://github.com/skywind3000/kcp\r\n[2]: https://github.com/skywind3000/kcp/raw/master/kcp.svg\r\n[3]: https://github.com/skywind3000/kcp/raw/master/kcp.svg\r\n[4]: https://api.travis-ci.org/skywind3000/kcp.svg?branch=master\r\n[5]: https://travis-ci.org/skywind3000/kcp\r\n[6]: https://img.shields.io/badge/license-MIT-blue.svg\r\n[7]: https://github.com/skywind3000/kcp/blob/master/LICENSE\r\n\r\n# Introduction\r\n\r\nKCP is a fast and reliable protocol that can achieve the transmission effect of a reduction of the average latency by 30% to 40% and reduction of the maximum delay by a factor of three, at the cost of 10% to 20% more bandwidth wasted than TCP. It is implemented by using the pure algorithm, and is not responsible for the sending and receiving of the underlying protocol (such as UDP), requiring the users to define their own transmission mode for the underlying data packet, and provide it to KCP in the way of callback. Even the clock needs to be passed in from the outside, without any internal system calls.\r\n\r\nThe entire protocol has only two source files of ikcp.h, ikcp.c, which can be easily integrated into the user's own protocol stack. You may have implement a P2P, or a UDP-based protocol, but are lack of a set of perfect ARQ reliable protocol implementation, then by simply copying the two files to the existing project, and writing a couple of lines of code, you can use it.\r\n\r\n\r\n\r\n# Technical Specifications\r\n\r\nTCP is designed for traffic (the amount of kilobits per second of data that can be transmitted), which focuses on the full use of bandwidth. While KCP is designed for the flow rate (the amount of time it takes to send a single packet from one end to the other), with 10% -20% bandwidth waste in exchange for transmission speed 30%-40% faster than TCP. TCP channel is a grand canal with very slow flow rate, but very large flow per second, while KCP is a small torrent with the rapid flow. KCP has both normal and fast modes, achieving the result of flow rate increase by the following strategies:\r\n\r\n#### RTO Doubled vs Not Doubled:\r\n\r\nTCP timeout calculation is RTOx2, so three consecutive packet losses will make it RTOx8, which is very terrible, while after KCP fast mode is enabled, it is not x2, but x1.5 (Experimental results show that the value of 1.5 is relatively good), which has improved the transmission speed.\r\n\r\n#### Selective Retransmission vs Full Retransmission:\r\n\r\nWhen packet loss occurs in TCP, all the data after the lost packet will be retransmitted, while KCP is selective retransmission, and only re-transmits the data packets that are really lost.\r\n\r\n#### Fast Retransmission:\r\n\r\nThe transmitting terminal sends 1, 2, 3, 4 and 5 packets, and then receives the remote ACK: 1, 3, 4 and 5, when receiving ACK3, KCP knows that 2 is skipped 1 time, and when receiving ACK4, it knows that 2 is skipped 2 times, at this point, it can consider that 2 is lost, without waiting until timeout, it will directly retransmit packet 2, which can greatly improve the transmission speed when packet loss occurs.\r\n\r\n#### Delayed ACK vs Non-delayed ACK:\r\n\r\nIn order to make full use of the bandwidth, TCP delays sending an ACK (Even NODELAY does not work), so that the timeout calculation will come out with a relatively high RTT, which has extended the judgment process when packet loss occurs. While for KCP, it is adjustable whether to delay sending an ACK.\r\n\r\n#### UNA vs ACK+UNA：\r\n\r\nThere are two kinds of ARQ model responses: UNA (All packets before this number received, such as TCP) and ACK (The packet with this number received). Using UNA alone will result in full retransmissions, and using ACK alone has too much cost for packet loss, hence in the previous protocols, one of the two has been selected; while in KCP protocol, all packets have UNA information except for a single ACK packet.\r\n\r\n#### Non-concessional Flow Control:\r\n\r\nKCP normal mode uses the same fair concession rules as TCP, i.e., the send window size is determined by: four factors including the size of the send cache, the size of the receive buffer at the receiving end, packet loss concession and slow start. However, when sending small data with high timeliness requirement, it is allowed to select skipping the latter two steps through configuration, and use only the first two items to control the transmission frequency, sacrificing some of the fairness and bandwidth utilization, in exchange for the effect of smooth transmission even when BT is opened.\r\n\r\n\r\n# Quick Install\r\n\r\nYou can download and install kcp using the [vcpkg](https://github.com/Microsoft/vcpkg) dependency manager:\r\n\r\n    git clone https://github.com/Microsoft/vcpkg.git\r\n    cd vcpkg\r\n    ./bootstrap-vcpkg.sh\r\n    ./vcpkg integrate install\r\n    ./vcpkg install kcp\r\n\r\nThe kcp port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\r\n\r\n# Basic Usage\r\n\r\n1. Create KCP object:\r\n\r\n   ```cpp\r\n   // Initialize the kcp object, conv is an integer that represents the session number, \r\n   // same as the conv of tcp, both communication sides shall ensure the same conv, \r\n   // so that mutual data packets can be recognized, user is a pointer which will be \r\n   // passed to the callback function.\r\n   ikcpcb *kcp = ikcp_create(conv, user);\r\n   ```\r\n\r\n2. Set the callback function:\r\n\r\n   ```cpp\r\n   // KCP lower layer protocol output function, which will be called by KCP when it \r\n   // needs to send data, buf/len represents the buffer and data length. \r\n   // user refers to the incoming value at the time the kcp object is created to \r\n   // distinguish between multiple KCP objects\r\n   int udp_output(const char *buf, int len, ikcpcb *kcp, void *user)\r\n   {\r\n     ....\r\n   }\r\n   // Set the callback function\r\n   kcp->output = udp_output;\r\n   ```\r\n\r\n3. Call update in an interval:\r\n\r\n   ```cpp\r\n   // Call ikcp_update at a certain frequency to update the kcp state, and pass in \r\n   // the current clock (in milliseconds). If the call is executed every 10ms, or \r\n   // ikcp_check is used to determine time of the next call for update, no need to \r\n   // call every time;\r\n   ikcp_update(kcp, millisec);\r\n   ```\r\n\r\n4. Input a lower layer data packet:\r\n\r\n   ```cpp\r\n   // Need to call when a lower layer data packet (such as UDP packet)is received:\r\n   ikcp_input(kcp, received_udp_packet, received_udp_size);\r\n   ```\r\n\r\n   After processing the output / input of the lower layer protocols, KCP protocol can work normally, and ikcp_send is used to send data to the remote end. While the other end uses ikcp_recv (kcp, ptr, size) to receive the data.\r\n\r\n\r\n# Protocol Configuration\r\n\r\nThe protocol default mode is a standard ARQ, and various acceleration switches can be enabled by configuration:\r\n\r\n1. Working Mode:\r\n   ```cpp\r\n   int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc)\r\n   ```\r\n\r\n   - `nodelay` : Whether nodelay mode is enabled, 0 is not enabled; 1 enabled.\r\n   - `interval` ：Protocol internal work interval, in milliseconds, such as 10 ms or 20 ms.\r\n   - `resend` ：Fast retransmission mode, 0 represents off by default, 2 can be set (2 ACK spans will result in direct retransmission)\r\n   - `nc` ：Whether to turn off flow control, 0 represents “Do not turn off” by default, 1 represents “Turn off”.\r\n   - Normal Mode: ikcp_nodelay(kcp, 0, 40, 0, 0);\r\n   - Turbo Mode： ikcp_nodelay(kcp, 1, 10, 2, 1);\r\n\r\n2. Window Size:\r\n   ```cpp\r\n   int ikcp_wndsize(ikcpcb *kcp, int sndwnd, int rcvwnd);\r\n   ```\r\n   The call will set the maximum send window and maximum receive window size of the procotol, which is 32 by default. This can be understood as SND_BUF and RCV_BUF of TCP, but the unit is not the same, SND / RCV_BUF unit is byte, while this unit is the packet.\r\n\r\n3. Maximum Transmission Unit:\r\n\r\n   Pure algorithm protocol is not responsible for MTU detection, the default mtu is 1400 bytes, which can be set using ikcp_setmtu. The value will affect the maximum transmission unit upon data packet merging and fragmentation.\r\n\r\n4. Minimum RTO:\r\n\r\n   No matter TCP or KCP, they have the limitation for the minimum RTO when calculating the RTO, even if the calculated RTO is 40ms, as the default RTO is 100ms, the protocol can only detect packet loss after 100ms, which is 30ms in the fast mode, and the value can be manually changed: \r\n   ```cpp\r\n   kcp->rx_minrto = 10;\r\n   ```\r\n\r\n\r\n\r\n# Document Indexing\r\n\r\nBoth the use and configuration of the protocol is very simple, in most cases, after you read the above contents, basically you will be able to use it. If you need further fine control, such as changing the KCP memory allocator, or if you need more efficient large-scale scheduling of KCP links (such as more than 3,500 links), or to better combine with TCP, you can continue the extensive reading:\r\n\r\n- [KCP Best Practice](https://github.com/skywind3000/kcp/wiki/KCP-Best-Practice-EN)\r\n- [Integration with the Existing TCP Server](https://github.com/skywind3000/kcp/wiki/KCP-Best-Practice-EN)\r\n- [Benchmarks](https://github.com/skywind3000/kcp/wiki/KCP-Benchmark)\r\n\r\n\r\n# Related Applications\r\n\r\n- [kcptun](https://github.com/xtaci/kcptun): High-speed remote port forwarding based (tunnel) on kcp-go, with ssh-D, it allows smoother online video viewing than finalspeed.\r\n- [dog-tunnel](https://github.com/vzex/dog-tunnel): Network tunnel developed by GO, using KCP to greatly improve the transmission speed, and migrated a GO version of the KCP.\r\n- [v2ray](https://www.v2ray.com)：Well-known proxy software, Shadowsocks replacement, integrated with kcp protocol after 1.17, using UDP transmission, no data packet features.\r\n- [HP-Socket](https://github.com/ldcsaa/HP-Socket): High Performance TCP/UDP/HTTP Communication Component.\r\n- [frp](https://github.com/fatedier/frp): A fast reverse proxy to help you expose a local server behind a NAT or firewall to the internet. \r\n- [asio-kcp](https://github.com/libinzhangyuan/asio_kcp): Use the complete UDP network library of KCP, complete implementation of UDP-based link state management, session control and KCP protocol scheduling, etc.\r\n- [kcp-cpp](https://github.com/Unit-X/kcp-cpp): Multi-platform (Windows, MacOS, Linux) C++ implementation of KCP as a simple library in your application. Contains socket handling and helper functions for all platforms.\r\n- [kcp-perl](https://github.com/Homqyy/kcp-perl): Perl extensions for kcp. It's OOP and Perl-Like.\r\n- [kcp-java](https://github.com/hkspirt/kcp-java)：Implementation of Java version of KCP protocol.\r\n- [kcp-netty](https://github.com/szhnet/kcp-netty)：Java implementation of KCP based on Netty.\r\n- [java-kcp](https://github.com/l42111996/java-Kcp): JAVA version KCP, based on netty implementation (including fec function)\r\n- [csharp-kcp](https://github.com/l42111996/csharp-kcp): csharp version KCP, based on dotNetty implementation (including fec function)\r\n- [kcp-go](https://github.com/xtaci/kcp-go): High-security GO language implementation of kcp, including simple implementation of UDP session management, as a base library for subsequent development.\r\n- [kcp-csharp](https://github.com/limpo1989/kcp-csharp): The csharp migration of kcp, containing the session management, which can access the above kcp-go server.\r\n- [KcpTransport](https://github.com/Cysharp/KcpTransport): KcpTransport is built on top of KCP ported to Pure C#, with implementations of Syn Cookie handshake, connection management, Unreliable communication, and KeepAlive. In the future, encryption will also be supported.\r\n- [Kcp-CSharp](https://github.com/Molth/Kcp-CSharp): a pure C# KCP instance callback(delegate) wrapper for (Unity/Godot/.NET)\r\n- [kcp2k](https://github.com/vis2k/kcp2k/): Line-by-line translation to C#, with optional Server/Client on top.\r\n- [kcp-rs](https://github.com/en/kcp-rs): The rust migration of KCP\r\n- [kcp-rust-native](https://github.com/b23r0/kcp-rust-native)：KCP bindings for Rust\r\n- [lua-kcp](https://github.com/linxiaolong/lua-kcp): Lua extension of KCP, applicable for Lua server\r\n- [node-kcp](https://github.com/leenjewel/node-kcp): KCP interface for node-js \r\n- [nysocks](https://github.com/oyyd/nysocks): Nysocks provides proxy services base on libuv and kcp for nodejs users. Both SOCKS5 and ss protocols are supported in the client.\r\n- [shadowsocks-android](https://github.com/shadowsocks/shadowsocks-android): Shadowsocks for android has integrated kcptun using kcp protocol to accelerate shadowsocks, with good results\r\n- [kcpuv](https://github.com/elisaday/kcpuv): The kcpuv library developed with libuv, currently still in the early alpha phase.\r\n- [xkcptun](https://github.com/liudf0716/xkcptun): C language implementation of kcptun, embedded-friendly for [LEDE](https://github.com/lede-project/source) and [OpenWrt](https://github.com/openwrt/openwrt) projects.\r\n- [yasio](https://github.com/yasio/yasio): A cross-platform asynchronous socket library focus on any client application with kcp support, easy to use, API same with UDP and TCP, see [benchmark-pump](https://github.com/yasio/yasio/blob/master/benchmark.md).\r\n- [gouxp](https://github.com/shaoyuan1943/gouxp): Implementing a callback-based KCP development package with Go, with decryption and FEC support, is easy to use.\r\n- [kcp.py](https://github.com/RealistikDash/kcp.py): Python bindings and networking with an emphasis on dev friendliness.\r\n- [pykcp](https://github.com/enkiller/pykcp): KCP implementation for Python version.\r\n- [php-ext-kcp](https://github.com/wpjscc/php-ext-kcp): php extension for KCP.\r\n- [asio-kcp(new)](https://github.com/sniper00/asio-kcp): KCP implementation for C++/Asio, with Modern C++/Asio async features, such as coroutine.\r\n\r\n# Protocol Comparison\r\n\r\nIf the network is never congested, KCP/TCP performance is similar; but the network itself is not reliable, and packet loss and jitter may be inevitable (otherwise why there are various reliable protocols). Compared in the intranet environment which is almost ideal, they have similar performance, but on the public Internet, under 3G / 4G network situation, or using the intranet packet loss simulation, the gap is obvious. The public network has an average of nearly 10% packet loss during peak times, which is even worse in wifi / 3g / 4g network, all of which will cause transmission congestion.\r\n\r\nThanks to [zhangyuan](https://github.com/libinzhangyuan) the author of [asio-kcp](https://github.com/libinzhangyuan/asio_kcp) for the horizontal evaluation on KCP, enet and udt, and the conclusions are as follows:\r\n\r\n- ASIO-KCP **has good performace in wifi and phone network(3G, 4G)**.\r\n- The kcp is the **first choice for realtime pvp game**.\r\n- The lag is less than 1 second when network lag happen. **3 times better than enet** when lag happen.\r\n- The enet is a good choice if your game allow 2 second lag.\r\n- **UDT is a bad idea**. It always sink into badly situation of more than serval seconds lag. And the recovery is not expected.\r\n- enet has the problem of lack of doc. And it has lots of functions that you may intrest.\r\n- kcp's doc is in both chinese and english. Good thing is the function detail which is writen in code is english. And you can use asio_kcp which is a good wrap.\r\n- The kcp is a simple thing. You will write more code if you want more feature.\r\n- UDT has a perfect doc. UDT may has more bug than others as I feeling.\r\n\r\nFor specifics please refer to: [Reliable Udp Benchmark](https://github.com/libinzhangyuan/reliable_udp_bench_mark) and [KCP-Benchmark](https://github.com/skywind3000/kcp/wiki/KCP-Benchmark), for more guidance to the hesitant users.\r\n\r\nMMO Engine [SpatialOS](https://improbable.io/spatialOS) has a benchmark report on KCP/TCP/RakNet:\r\n\r\n![](images/spatialos-50.png)\r\n\r\nfor more details, please see the report itself:\r\n\r\n- [Kcp a new low latency secure network stack](https://improbable.io/blog/kcp-a-new-low-latency-secure-network-stack)\r\n\r\n# KCP is used by\r\n\r\nSee [Success Stories](https://github.com/skywind3000/kcp/wiki/Success-Stories).\r\n\r\n# Donation\r\n\r\n![欢迎使用支付宝对该项目进行捐赠](https://raw.githubusercontent.com/skywind3000/kcp/master/images/donation.png)\r\n\r\nDonation is welcome by using alipay, the money will be used to improve the protocol and documentation.\r\n\r\n\r\ntwitter: https://twitter.com/skywind3000\r\nblog: http://www.skywind.me\r\n\r\nzhihu: https://www.zhihu.com/people/skywind3000\r\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.7724609375,
          "content": "KCP - A Fast and Reliable ARQ Protocol\r\n======================================\r\n\r\n[![Powered][3]][1] \r\n[![GitHub license][6]][7]\r\n[![Backers on Open Collective](https://opencollective.com/kcp/backers/badge.svg)](#backers)\r\n[![Sponsors on Open Collective](https://opencollective.com/kcp/sponsors/badge.svg)](#sponsors) \r\n\r\n[1]: https://github.com/skywind3000/kcp\r\n[2]: https://github.com/skywind3000/kcp/raw/master/kcp.svg\r\n[3]: https://github.com/skywind3000/kcp/raw/master/kcp.svg\r\n[4]: https://api.travis-ci.org/skywind3000/kcp.svg?branch=master\r\n[5]: https://travis-ci.org/skywind3000/kcp\r\n[6]: https://img.shields.io/badge/license-MIT-blue.svg\r\n[7]: https://github.com/skywind3000/kcp/blob/master/LICENSE\r\n\r\n[README in English](https://github.com/skywind3000/kcp/blob/master/README.en.md) \r\n\r\n# 简介\r\n\r\nKCP是一个快速可靠协议，能以比 TCP 浪费 10%-20% 的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据包的发送方式，以 callback的方式提供给 KCP。 连时钟都需要外部传递进来，内部不会有任何一次系统调用。\r\n\r\n整个协议只有 ikcp.h, ikcp.c两个源文件，可以方便的集成到用户自己的协议栈中。也许你实现了一个P2P，或者某个基于 UDP的协议，而缺乏一套完善的ARQ可靠协议实现，那么简单的拷贝这两个文件到现有项目中，稍微编写两行代码，即可使用。\r\n\r\n\r\n# 技术特性\r\n\r\nTCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。TCP信道是一条流速很慢，但每秒流量很大的大运河，而KCP是水流湍急的小激流。KCP有正常模式和快速模式两种，通过以下策略达到提高流速的结果：\r\n\r\n#### RTO翻倍vs不翻倍：\r\n\r\n   TCP超时计算是RTOx2，这样连续丢三次包就变成RTOx8了，十分恐怖，而KCP启动快速模式后不x2，只是x1.5（实验证明1.5这个值相对比较好），提高了传输速度。\r\n\r\n#### 选择性重传 vs 全部重传：\r\n\r\n   TCP丢包时会全部重传从丢的那个包开始以后的数据，KCP是选择性重传，只重传真正丢失的数据包。\r\n\r\n#### 快速重传：\r\n\r\n   发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4, 5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。\r\n\r\n#### 延迟ACK vs 非延迟ACK：\r\n\r\n   TCP为了充分利用带宽，延迟发送ACK（NODELAY都没用），这样超时计算会算出较大 RTT时间，延长了丢包时的判断过程。KCP的ACK是否延迟发送可以调节。\r\n\r\n#### UNA vs ACK+UNA：\r\n\r\n   ARQ模型响应有两种，UNA（此编号前所有包已收到，如TCP）和ACK（该编号包已收到），光用UNA将导致全部重传，光用ACK则丢失成本太高，以往协议都是二选其一，而 KCP协议中，除去单独的 ACK包外，所有包都有UNA信息。\r\n\r\n#### 非退让流控：\r\n\r\n   KCP正常模式同TCP一样使用公平退让法则，即发送窗口大小由：发送缓存大小、接收端剩余接收缓存大小、丢包退让及慢启动这四要素决定。但传送及时性要求很高的小数据时，可选择通过配置跳过后两步，仅用前两项来控制发送频率。以牺牲部分公平性及带宽利用率之代价，换取了开着BT都能流畅传输的效果。\r\n\r\n\r\n# 快速安装\r\n\r\n您可以使用[vcpkg](https://github.com/Microsoft/vcpkg)库管理器下载并安装kcp:\r\n\r\n    git clone https://github.com/Microsoft/vcpkg.git\r\n    cd vcpkg\r\n    ./bootstrap-vcpkg.sh\r\n    ./vcpkg integrate install\r\n    ./vcpkg install kcp\r\n\r\nvcpkg中的kcp库由Microsoft团队成员和社区贡献者保持最新状态。如果版本过时，请在vcpkg存储库上[创建issue或提出PR](https://github.com/Microsoft/vcpkg)。\r\n\r\n# 基本使用\r\n\r\n1. 创建 KCP对象：\r\n\r\n   ```cpp\r\n   // 初始化 kcp对象，conv为一个表示会话编号的整数，和tcp的 conv一样，通信双\r\n   // 方需保证 conv相同，相互的数据包才能够被认可，user是一个给回调函数的指针\r\n   ikcpcb *kcp = ikcp_create(conv, user);\r\n   ```\r\n\r\n2. 设置回调函数：\r\n\r\n   ```cpp\r\n   // KCP的下层协议输出函数，KCP需要发送数据时会调用它\r\n   // buf/len 表示缓存和长度\r\n   // user指针为 kcp对象创建时传入的值，用于区别多个 KCP对象\r\n   int udp_output(const char *buf, int len, ikcpcb *kcp, void *user)\r\n   {\r\n     ....\r\n   }\r\n   // 设置回调函数\r\n   kcp->output = udp_output;\r\n   ```\r\n\r\n3. 循环调用 update：\r\n\r\n   ```cpp\r\n   // 以一定频率调用 ikcp_update来更新 kcp状态，并且传入当前时钟（毫秒单位）\r\n   // 如 10ms调用一次，或用 ikcp_check确定下次调用 update的时间不必每次调用\r\n   ikcp_update(kcp, millisec);\r\n   ```\r\n\r\n4. 输入一个下层数据包：\r\n\r\n   ```cpp\r\n   // 收到一个下层数据包（比如UDP包）时需要调用：\r\n   ikcp_input(kcp, received_udp_packet, received_udp_size);\r\n   ```\r\n   处理了下层协议的输出/输入后 KCP协议就可以正常工作了，使用 ikcp_send 来向\r\n   远端发送数据。而另一端使用 ikcp_recv(kcp, ptr, size)来接收数据。\r\n\r\n\r\n# 协议配置\r\n\r\n协议默认模式是一个标准的 ARQ，需要通过配置打开各项加速开关：\r\n\r\n1. 工作模式：\r\n   ```cpp\r\n   int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc)\r\n   ```\r\n\r\n   - nodelay ：是否启用 nodelay模式，0不启用；1启用。\r\n   - interval ：协议内部工作的 interval，单位毫秒，比如 10ms或者 20ms\r\n   - resend ：快速重传模式，默认0关闭，可以设置2（2次ACK跨越将会直接重传）\r\n   - nc ：是否关闭流控，默认是0代表不关闭，1代表关闭。\r\n   - 普通模式： ikcp_nodelay(kcp, 0, 40, 0, 0);\r\n   - 极速模式： ikcp_nodelay(kcp, 1, 10, 2, 1);\r\n\r\n2. 最大窗口：\r\n   ```cpp\r\n   int ikcp_wndsize(ikcpcb *kcp, int sndwnd, int rcvwnd);\r\n   ```\r\n   该调用将会设置协议的最大发送窗口和最大接收窗口大小，默认为32. 这个可以理解为 TCP的 SND_BUF 和 RCV_BUF，只不过单位不一样 SND/RCV_BUF 单位是字节，这个单位是包。\r\n\r\n3. 最大传输单元：\r\n\r\n   纯算法协议并不负责探测 MTU，默认 mtu是1400字节，可以使用ikcp_setmtu来设置该值。该值将会影响数据包归并及分片时候的最大传输单元。\r\n\r\n4. 最小RTO：\r\n\r\n   不管是 TCP还是 KCP计算 RTO时都有最小 RTO的限制，即便计算出来RTO为40ms，由于默认的 RTO是100ms，协议只有在100ms后才能检测到丢包，快速模式下为30ms，可以手动更改该值：\r\n   ```cpp\r\n   kcp->rx_minrto = 10;\r\n   ```\r\n\r\n\r\n# 文档索引\r\n\r\n协议的使用和配置都是很简单的，大部分情况看完上面的内容基本可以使用了。如果你需要进一步进行精细的控制，比如改变 KCP的内存分配器，或者你需要更有效的大规模调度 KCP链接（比如 3500个以上），或者如何更好的同 TCP结合，那么可以继续延伸阅读：\r\n\r\n- [Wiki Home](https://github.com/skywind3000/kcp/wiki)\r\n- [KCP 最佳实践](https://github.com/skywind3000/kcp/wiki/KCP-Best-Practice)\r\n- [同现有TCP服务器集成](https://github.com/skywind3000/kcp/wiki/Cooperate-With-Tcp-Server)\r\n- [传输数据加密](https://github.com/skywind3000/kcp/wiki/Network-Encryption)\r\n- [应用层流量控制](https://github.com/skywind3000/kcp/wiki/Flow-Control-for-Users)\r\n- [性能评测](https://github.com/skywind3000/kcp/wiki/KCP-Benchmark)\r\n\r\n\r\n# 开源案例\r\n\r\n- [kcptun](https://github.com/xtaci/kcptun): 基于 kcp-go做的高速远程端口转发(隧道) ，配合ssh -D，可以比 shadowsocks 更流畅的看在线视频。\r\n- [dog-tunnel](https://github.com/vzex/dog-tunnel): GO开发的网络隧道，使用 KCP极大的改进了传输速度，并移植了一份 GO版本 KCP\r\n- [v2ray](https://www.v2ray.com): 著名代理软件，Shadowsocks 代替者，1.17后集成了 kcp协议，使用UDP传输，无数据包特征。\r\n- [HP-Socket](https://github.com/ldcsaa/HP-Socket): 高性能网络通信框架 HP-Socket。\r\n- [frp](https://github.com/fatedier/frp): 高性能内网穿透的反向代理软件，可将将内网服务暴露映射到外网服务器。\r\n- [asio-kcp](https://github.com/libinzhangyuan/asio_kcp): 使用 KCP的完整 UDP网络库，完整实现了基于 UDP的链接状态管理，会话控制，KCP协议调度等\r\n- [kcp-java](https://github.com/hkspirt/kcp-java): Java版本 KCP协议实现。\r\n- [kcp-netty](https://github.com/szhnet/kcp-netty): kcp的Java语言实现，基于netty。\r\n- [java-kcp](https://github.com/l42111996/java-Kcp): JAVA版本KCP,基于netty实现(包含fec功能)\r\n- [csharp-kcp](https://github.com/l42111996/csharp-kcp): csharp版本KCP,基于dotNetty实现(包含fec功能)\r\n- [kcp-cpp](https://github.com/Unit-X/kcp-cpp): KCP 的多平台（Windows、MacOS、Linux）C++ 实现作为应用程序中的简单库。包含适用于所有平台的套接字处理和辅助函数。\r\n- [kcp-perl](https://github.com/Homqyy/kcp-perl): kcp的Perl实现，其是面向对象的，Perl-Like的。\r\n- [kcp-go](https://github.com/xtaci/kcp-go): 高安全性的kcp的 GO语言实现，包含 UDP会话管理的简单实现，可以作为后续开发的基础库。 \r\n- [kcp-csharp](https://github.com/limpo1989/kcp-csharp): kcp的 csharp移植，同时包含一份回话管理，可以连接上面kcp-go的服务端。\r\n- [kcp-csharp](https://github.com/KumoKyaku/KCP): 新版本 Kcp的 csharp移植。线程安全，运行时无alloc，对gc无压力。\r\n- [KcpTransport](https://github.com/Cysharp/KcpTransport): kcp的csharp移植，实现了 Syn Cookie 握手、连接管理、不可靠通信、KeepAlive，未来还将支持加密。\r\n- [Kcp-CSharp](https://github.com/Molth/Kcp-CSharp): kcp的csharp移植，非托管包装器。\r\n- [kcp2k](https://github.com/vis2k/kcp2k/): Line-by-line translation to C#, with optional Server/Client on top.\r\n- [kcp-rs](https://github.com/en/kcp-rs): KCP的 rust移植\r\n- [kcp-rust](https://github.com/Matrix-Zhang/kcp)：新版本 KCP的 rust 移植\r\n- [tokio-kcp](https://github.com/Matrix-Zhang/tokio_kcp)：rust tokio 的 kcp 集成\r\n- [kcp-rust-native](https://github.com/b23r0/kcp-rust-native)：rust 的 kcp bindings\r\n- [lua-kcp](https://github.com/linxiaolong/lua-kcp): KCP的 Lua扩展，用于 Lua服务器\r\n- [node-kcp](https://github.com/leenjewel/node-kcp): node-js 的 KCP 接口  \r\n- [nysocks](https://github.com/oyyd/nysocks): 基于libuv实现的[node-addon](https://nodejs.org/api/addons.html)，提供nodejs版本的代理服务，客户端接入支持SOCKS5和ss两种协议\r\n- [shadowsocks-android](https://github.com/shadowsocks/shadowsocks-android): Shadowsocks for android 集成了 kcptun 使用 kcp协议加速 shadowsocks，效果不错\r\n- [kcpuv](https://github.com/elisaday/kcpuv): 使用 libuv开发的kcpuv库，目前还在 Demo阶段\r\n- [Lantern](https://getlantern.org/)：更好的 VPN，Github 50000 星，使用 kcpgo 加速\r\n- [rpcx](https://github.com/smallnest/rpcx) ：RPC 框架，1000+ 星，使用 kcpgo 加速 RPC\r\n- [xkcptun](https://github.com/liudf0716/xkcptun): c语言实现的kcptun，主要用于[OpenWrt](https://github.com/openwrt/openwrt), [LEDE](https://github.com/lede-project/source)开发的路由器项目上\r\n- [et-frame](https://github.com/egametang/ET): C#前后端框架(前端unity3d)，统一用C#开发游戏，实现了前后端kcp协议\r\n- [yasio](https://github.com/yasio/yasio): 一个跨平台专注于任意客户端程序的异步socket库, 易于使用，相同的API操作KCP/TCP/UDP, 性能测试结果: [benchmark-pump](https://github.com/yasio/yasio/blob/master/benchmark.md).\r\n- [gouxp](https://github.com/shaoyuan1943/gouxp): 用Go实现基于回调方式的KCP开发包，包含加解密和FEC支持，简单易用。  \r\n- [skcp](https://github.com/xboss/skcp): 基于libev实现的库，具备传输加密及基本的连接管理能力。\r\n- [pykcp](https://github.com/enkiller/pykcp): Python 版本的 KCP 实现\r\n- [php-ext-kcp](https://github.com/wpjscc/php-ext-kcp): php 的 KCP 扩展\r\n- [asio-kcp(new)](https://github.com/sniper00/asio-kcp): c++的asio/kcp支持，支持asio协程等现代c++异步模型\r\n\r\n# 商业案例\r\n\r\n- [原神](https://ys.mihoyo.com/)：米哈游的《原神》使用 KCP 降低游戏消息的传输耗时，提升操作的体验。\r\n- [SpatialOS](https://improbable.io/spatialOS): 大型多人分布式游戏服务端引擎，BigWorld 的后继者，使用 KCP 加速数据传输。\r\n- [西山居](https://www.xishanju.com/)：使用 KCP 进行游戏数据加速。\r\n- [CC](http://cc.163.com/)：网易 CC 使用 kcp 加速视频推流，有效提高流畅性\r\n- [BOBO](http://bobo.163.com/)：网易 BOBO 使用 kcp 加速主播推流\r\n- [UU](https://uu.163.com)：网易 UU 加速器使用 KCP/KCPTUN 经行远程传输加速。\r\n- [阿里云](https://cn.aliyun.com/)：阿里云的视频传输加速服务 GRTN 使用 KCP 进行音视频数据传输优化，动态加速产品也使用 KCP。\r\n- [云帆加速](http://www.yfcloud.com/)：使用 KCP 加速文件传输和视频推流，优化了台湾主播推流的流畅度。\r\n- [明日帝国](https://www.taptap.com/app/50664)：Game K17 的 《明日帝国》 （Google Play），使用 KCP 加速游戏消息，让全球玩家流畅联网\r\n- [仙灵大作战](https://www.taptap.com/app/27242)：4399 的 MOBA游戏，使用 KCP 优化游戏同步\r\n\r\n相关阅读：[《原神》也在使用 KCP 加速游戏消息](https://skywind.me/blog/archives/2706)\r\n\r\nKCP 成功的运行在多个用户规模上亿的项目上，为他们提供了更加灵敏和丝滑网络体验。\r\n\r\n欢迎告知更多案例\r\n\r\n# 协议比较\r\n\r\n如果网络永远不卡，那 KCP/TCP 表现类似，但是网络本身就是不可靠的，丢包和抖动无法避免（否则还要各种可靠协议干嘛）。在内网这种几乎理想的环境里直接比较，大家都差不多，但是放到公网上，放到3G/4G网络情况下，或者使用内网丢包模拟，差距就很明显了。公网在高峰期有平均接近10%的丢包，wifi/3g/4g下更糟糕，这些都会让传输变卡。\r\n\r\n感谢 [asio-kcp](https://github.com/libinzhangyuan/asio_kcp) 的作者 [zhangyuan](https://github.com/libinzhangyuan) 对 KCP 与 enet, udt做过的一次横向评测，结论如下：\r\n\r\n- ASIO-KCP **has good performace in wifi and phone network(3G, 4G)**.\r\n- The kcp is the **first choice for realtime pvp game**.\r\n- The lag is less than 1 second when network lag happen. **3 times better than enet** when lag happen.\r\n- The enet is a good choice if your game allow 2 second lag.\r\n- **UDT is a bad idea**. It always sink into badly situation of more than serval seconds lag. And the recovery is not expected.\r\n- enet has the problem of lack of doc. And it has lots of functions that you may intrest.\r\n- kcp's doc is chinese. Good thing is the function detail which is writen in code is english. And you can use asio_kcp which is a good wrap.\r\n- The kcp is a simple thing. You will write more code if you want more feature.\r\n- UDT has a perfect doc. UDT may has more bug than others as I feeling.\r\n\r\n具体见：[横向比较](https://github.com/libinzhangyuan/reliable_udp_bench_mark) 和 [评测数据](https://github.com/skywind3000/kcp/wiki/KCP-Benchmark)，为犹豫选择的人提供了更多指引。\r\n\r\n大型多人游戏服务端引擎 [SpatialOS](https://improbable.io/spatialOS) 在集成 KCP 协议后做了同 TCP/RakNet 的评测：\r\n\r\n![](https://github.com/skywind3000/kcp/raw/master/images/spatialos-50.png)\r\n\r\n对比了在服务端刷新率为 60 Hz 同时维护 50 个角色时的响应时间，详细对比报告见：\r\n\r\n- [Kcp a new low latency secure network stack](https://improbable.io/blog/kcp-a-new-low-latency-secure-network-stack)\r\n\r\n\r\n# 关于协议\r\n\r\n近年来，网络游戏和各类社交网络都在成几何倍数的增长，不管网络游戏还是各类互动社交网络，交互性和复杂度都在迅速提高，都需要在极短的时间内将数据同时投递给大量用户，因此传输技术自然变为未来制约发展的一个重要因素，而开源界里各种著名的传输协议，如 raknet/enet 之类，一发布都是整套协议栈一起发布，这种形式是不利于多样化的，我的项目只能选择用或者不用你，很难选择 “部分用你”，然而你一套协议栈设计的再好，是非常难以满足不同角度的各种需求的。\r\n\r\n因此 KCP 的方式是把协议栈 “拆开”，让大家可以根据项目需求进行灵活的调整和组装，你可以下面加一层 reed solomon 的纠删码做 FEC，上面加一层类 RC4/Salsa20 做流加密，握手处再设计一套非对称密钥交换，底层 UDP 传输层再做一套动态路由系统，同时探测多条路径，选最好路径进行传输。这些不同的 “协议单元” 可以像搭建积木一般根据需要自由组合，保证 “简单性” 和 “可拆分性”，这样才能灵活适配多变的业务需求，哪个模块不好，换了就是。\r\n\r\n未来传输方面的解决方案必然是根据使用场景深度定制的，因此给大家一个可以自由组合的 “协议单元” ，方便大家集成在自己的协议栈中。\r\n\r\nFor more information, please see the [Success Stories](https://github.com/skywind3000/kcp/wiki/Success-Stories).\r\n\r\n\r\n# 关于作者\r\n\r\n作者：林伟 (skywind3000)\r\n\r\n欢迎关注我的：[个人博客](https://skywind.me/blog) 和 [推特](https://x.com/skywind3000)。\r\n\r\n我在多年的开发经历中，一直都喜欢研究解决程序中的一些瓶颈问题，早年喜欢游戏开发，照着《VGA编程》来做游戏图形，读 Michael Abrash 的《图形程序开发人员指南》做软渲染器，爱好摆弄一些能够榨干 CPU 能够运行更快的代码，参加工作后，兴趣转移到服务端和网络相关的技术。\r\n\r\n2007 年时做了几个传统游戏后开始研究快速动作游戏的同步问题，期间写过不少文章，算是国内比较早研究同步问题的人，然而发现不管怎么解决同步都需要在网络传输方面有所突破，后来离开游戏转行互联网后也发现不少领域有这方面的需求，于是开始花时间在网络传输这个领域上，尝试基于 UDP 实现一些保守的可靠协议，仿照 BSD Lite 4.4 的代码实现一些类 TCP 协议，觉得比较有意思，又接着实现一些 P2P 和动态路由网相关的玩具。KCP 协议诞生于 2011 年，基本算是自己传输方面做的几个玩具中的一个。\r\n\r\nKcptun 的作者 xtaci 是我的大学同学，我俩都是学通信的，经常在一起研究如何进行传输优化。\r\n\r\n# 欢迎捐赠\r\n\r\n![欢迎使用支付宝对该项目进行捐赠](images/donation.png)\r\n\r\n欢迎使用支付宝手扫描上面的二维码，对该项目进行捐赠。捐赠款项将用于持续优化 KCP协议以及完善文档。\r\n\r\n感谢：明明、星仔、进、帆、颁钊、斌铨、晓丹、余争、虎、晟敢、徐玮、王川、赵刚强、胡知锋、万新朝、何新超、刘旸、侯宪辉、吴佩仪、华斌、如涛、胡坚。。。（早先的名单实在不好意思没记录下来）等同学的捐助与支持。\r\n\r\n\r\n欢迎关注\r\n\r\nKCP交流群：364933586（QQ群号），KCP集成，调优，网络传输以及相关技术讨论\r\n\r\nGitter 群：https://gitter.im/skywind3000/KCP\r\n\r\nblog: http://www.skywind.me\r\n\r\n\r\n\r\n## Contributors\r\n\r\nThis project exists thanks to all the people who contribute. \r\n<a href=\"https://github.com/skywind3000/kcp/graphs/contributors\"><img src=\"https://opencollective.com/kcp/contributors.svg?width=890&button=false\" /></a>\r\n\r\n"
        },
        {
          "name": "benchmark.png",
          "type": "blob",
          "size": 164.6220703125,
          "content": null
        },
        {
          "name": "ikcp.c",
          "type": "blob",
          "size": 32.3720703125,
          "content": "//=====================================================================\r\n//\r\n// KCP - A Better ARQ Protocol Implementation\r\n// skywind3000 (at) gmail.com, 2010-2011\r\n//  \r\n// Features:\r\n// + Average RTT reduce 30% - 40% vs traditional ARQ like tcp.\r\n// + Maximum RTT reduce three times vs tcp.\r\n// + Lightweight, distributed as a single source file.\r\n//\r\n//=====================================================================\r\n#include \"ikcp.h\"\r\n\r\n#include <stddef.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdarg.h>\r\n#include <stdio.h>\r\n\r\n#define IKCP_FASTACK_CONSERVE\r\n\r\n//=====================================================================\r\n// KCP BASIC\r\n//=====================================================================\r\nconst IUINT32 IKCP_RTO_NDL = 30;\t\t// no delay min rto\r\nconst IUINT32 IKCP_RTO_MIN = 100;\t\t// normal min rto\r\nconst IUINT32 IKCP_RTO_DEF = 200;\r\nconst IUINT32 IKCP_RTO_MAX = 60000;\r\nconst IUINT32 IKCP_CMD_PUSH = 81;\t\t// cmd: push data\r\nconst IUINT32 IKCP_CMD_ACK  = 82;\t\t// cmd: ack\r\nconst IUINT32 IKCP_CMD_WASK = 83;\t\t// cmd: window probe (ask)\r\nconst IUINT32 IKCP_CMD_WINS = 84;\t\t// cmd: window size (tell)\r\nconst IUINT32 IKCP_ASK_SEND = 1;\t\t// need to send IKCP_CMD_WASK\r\nconst IUINT32 IKCP_ASK_TELL = 2;\t\t// need to send IKCP_CMD_WINS\r\nconst IUINT32 IKCP_WND_SND = 32;\r\nconst IUINT32 IKCP_WND_RCV = 128;       // must >= max fragment size\r\nconst IUINT32 IKCP_MTU_DEF = 1400;\r\nconst IUINT32 IKCP_ACK_FAST\t= 3;\r\nconst IUINT32 IKCP_INTERVAL\t= 100;\r\nconst IUINT32 IKCP_OVERHEAD = 24;\r\nconst IUINT32 IKCP_DEADLINK = 20;\r\nconst IUINT32 IKCP_THRESH_INIT = 2;\r\nconst IUINT32 IKCP_THRESH_MIN = 2;\r\nconst IUINT32 IKCP_PROBE_INIT = 7000;\t\t// 7 secs to probe window size\r\nconst IUINT32 IKCP_PROBE_LIMIT = 120000;\t// up to 120 secs to probe window\r\nconst IUINT32 IKCP_FASTACK_LIMIT = 5;\t\t// max times to trigger fastack\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// encode / decode\r\n//---------------------------------------------------------------------\r\n\r\n/* encode 8 bits unsigned int */\r\nstatic inline char *ikcp_encode8u(char *p, unsigned char c)\r\n{\r\n\t*(unsigned char*)p++ = c;\r\n\treturn p;\r\n}\r\n\r\n/* decode 8 bits unsigned int */\r\nstatic inline const char *ikcp_decode8u(const char *p, unsigned char *c)\r\n{\r\n\t*c = *(unsigned char*)p++;\r\n\treturn p;\r\n}\r\n\r\n/* encode 16 bits unsigned int (lsb) */\r\nstatic inline char *ikcp_encode16u(char *p, unsigned short w)\r\n{\r\n#if IWORDS_BIG_ENDIAN || IWORDS_MUST_ALIGN\r\n\t*(unsigned char*)(p + 0) = (w & 255);\r\n\t*(unsigned char*)(p + 1) = (w >> 8);\r\n#else\r\n\tmemcpy(p, &w, 2);\r\n#endif\r\n\tp += 2;\r\n\treturn p;\r\n}\r\n\r\n/* decode 16 bits unsigned int (lsb) */\r\nstatic inline const char *ikcp_decode16u(const char *p, unsigned short *w)\r\n{\r\n#if IWORDS_BIG_ENDIAN || IWORDS_MUST_ALIGN\r\n\t*w = *(const unsigned char*)(p + 1);\r\n\t*w = *(const unsigned char*)(p + 0) + (*w << 8);\r\n#else\r\n\tmemcpy(w, p, 2);\r\n#endif\r\n\tp += 2;\r\n\treturn p;\r\n}\r\n\r\n/* encode 32 bits unsigned int (lsb) */\r\nstatic inline char *ikcp_encode32u(char *p, IUINT32 l)\r\n{\r\n#if IWORDS_BIG_ENDIAN || IWORDS_MUST_ALIGN\r\n\t*(unsigned char*)(p + 0) = (unsigned char)((l >>  0) & 0xff);\r\n\t*(unsigned char*)(p + 1) = (unsigned char)((l >>  8) & 0xff);\r\n\t*(unsigned char*)(p + 2) = (unsigned char)((l >> 16) & 0xff);\r\n\t*(unsigned char*)(p + 3) = (unsigned char)((l >> 24) & 0xff);\r\n#else\r\n\tmemcpy(p, &l, 4);\r\n#endif\r\n\tp += 4;\r\n\treturn p;\r\n}\r\n\r\n/* decode 32 bits unsigned int (lsb) */\r\nstatic inline const char *ikcp_decode32u(const char *p, IUINT32 *l)\r\n{\r\n#if IWORDS_BIG_ENDIAN || IWORDS_MUST_ALIGN\r\n\t*l = *(const unsigned char*)(p + 3);\r\n\t*l = *(const unsigned char*)(p + 2) + (*l << 8);\r\n\t*l = *(const unsigned char*)(p + 1) + (*l << 8);\r\n\t*l = *(const unsigned char*)(p + 0) + (*l << 8);\r\n#else \r\n\tmemcpy(l, p, 4);\r\n#endif\r\n\tp += 4;\r\n\treturn p;\r\n}\r\n\r\nstatic inline IUINT32 _imin_(IUINT32 a, IUINT32 b) {\r\n\treturn a <= b ? a : b;\r\n}\r\n\r\nstatic inline IUINT32 _imax_(IUINT32 a, IUINT32 b) {\r\n\treturn a >= b ? a : b;\r\n}\r\n\r\nstatic inline IUINT32 _ibound_(IUINT32 lower, IUINT32 middle, IUINT32 upper) \r\n{\r\n\treturn _imin_(_imax_(lower, middle), upper);\r\n}\r\n\r\nstatic inline long _itimediff(IUINT32 later, IUINT32 earlier) \r\n{\r\n\treturn ((IINT32)(later - earlier));\r\n}\r\n\r\n//---------------------------------------------------------------------\r\n// manage segment\r\n//---------------------------------------------------------------------\r\ntypedef struct IKCPSEG IKCPSEG;\r\n\r\nstatic void* (*ikcp_malloc_hook)(size_t) = NULL;\r\nstatic void (*ikcp_free_hook)(void *) = NULL;\r\n\r\n// internal malloc\r\nstatic void* ikcp_malloc(size_t size) {\r\n\tif (ikcp_malloc_hook) \r\n\t\treturn ikcp_malloc_hook(size);\r\n\treturn malloc(size);\r\n}\r\n\r\n// internal free\r\nstatic void ikcp_free(void *ptr) {\r\n\tif (ikcp_free_hook) {\r\n\t\tikcp_free_hook(ptr);\r\n\t}\telse {\r\n\t\tfree(ptr);\r\n\t}\r\n}\r\n\r\n// redefine allocator\r\nvoid ikcp_allocator(void* (*new_malloc)(size_t), void (*new_free)(void*))\r\n{\r\n\tikcp_malloc_hook = new_malloc;\r\n\tikcp_free_hook = new_free;\r\n}\r\n\r\n// allocate a new kcp segment\r\nstatic IKCPSEG* ikcp_segment_new(ikcpcb *kcp, int size)\r\n{\r\n\treturn (IKCPSEG*)ikcp_malloc(sizeof(IKCPSEG) + size);\r\n}\r\n\r\n// delete a segment\r\nstatic void ikcp_segment_delete(ikcpcb *kcp, IKCPSEG *seg)\r\n{\r\n\tikcp_free(seg);\r\n}\r\n\r\n// write log\r\nvoid ikcp_log(ikcpcb *kcp, int mask, const char *fmt, ...)\r\n{\r\n\tchar buffer[1024];\r\n\tva_list argptr;\r\n\tif ((mask & kcp->logmask) == 0 || kcp->writelog == 0) return;\r\n\tva_start(argptr, fmt);\r\n\tvsprintf(buffer, fmt, argptr);\r\n\tva_end(argptr);\r\n\tkcp->writelog(buffer, kcp, kcp->user);\r\n}\r\n\r\n// check log mask\r\nstatic int ikcp_canlog(const ikcpcb *kcp, int mask)\r\n{\r\n\tif ((mask & kcp->logmask) == 0 || kcp->writelog == NULL) return 0;\r\n\treturn 1;\r\n}\r\n\r\n// output segment\r\nstatic int ikcp_output(ikcpcb *kcp, const void *data, int size)\r\n{\r\n\tassert(kcp);\r\n\tassert(kcp->output);\r\n\tif (ikcp_canlog(kcp, IKCP_LOG_OUTPUT)) {\r\n\t\tikcp_log(kcp, IKCP_LOG_OUTPUT, \"[RO] %ld bytes\", (long)size);\r\n\t}\r\n\tif (size == 0) return 0;\r\n\treturn kcp->output((const char*)data, size, kcp, kcp->user);\r\n}\r\n\r\n// output queue\r\nvoid ikcp_qprint(const char *name, const struct IQUEUEHEAD *head)\r\n{\r\n#if 0\r\n\tconst struct IQUEUEHEAD *p;\r\n\tprintf(\"<%s>: [\", name);\r\n\tfor (p = head->next; p != head; p = p->next) {\r\n\t\tconst IKCPSEG *seg = iqueue_entry(p, const IKCPSEG, node);\r\n\t\tprintf(\"(%lu %d)\", (unsigned long)seg->sn, (int)(seg->ts % 10000));\r\n\t\tif (p->next != head) printf(\",\");\r\n\t}\r\n\tprintf(\"]\\n\");\r\n#endif\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// create a new kcpcb\r\n//---------------------------------------------------------------------\r\nikcpcb* ikcp_create(IUINT32 conv, void *user)\r\n{\r\n\tikcpcb *kcp = (ikcpcb*)ikcp_malloc(sizeof(struct IKCPCB));\r\n\tif (kcp == NULL) return NULL;\r\n\tkcp->conv = conv;\r\n\tkcp->user = user;\r\n\tkcp->snd_una = 0;\r\n\tkcp->snd_nxt = 0;\r\n\tkcp->rcv_nxt = 0;\r\n\tkcp->ts_recent = 0;\r\n\tkcp->ts_lastack = 0;\r\n\tkcp->ts_probe = 0;\r\n\tkcp->probe_wait = 0;\r\n\tkcp->snd_wnd = IKCP_WND_SND;\r\n\tkcp->rcv_wnd = IKCP_WND_RCV;\r\n\tkcp->rmt_wnd = IKCP_WND_RCV;\r\n\tkcp->cwnd = 0;\r\n\tkcp->incr = 0;\r\n\tkcp->probe = 0;\r\n\tkcp->mtu = IKCP_MTU_DEF;\r\n\tkcp->mss = kcp->mtu - IKCP_OVERHEAD;\r\n\tkcp->stream = 0;\r\n\r\n\tkcp->buffer = (char*)ikcp_malloc((kcp->mtu + IKCP_OVERHEAD) * 3);\r\n\tif (kcp->buffer == NULL) {\r\n\t\tikcp_free(kcp);\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tiqueue_init(&kcp->snd_queue);\r\n\tiqueue_init(&kcp->rcv_queue);\r\n\tiqueue_init(&kcp->snd_buf);\r\n\tiqueue_init(&kcp->rcv_buf);\r\n\tkcp->nrcv_buf = 0;\r\n\tkcp->nsnd_buf = 0;\r\n\tkcp->nrcv_que = 0;\r\n\tkcp->nsnd_que = 0;\r\n\tkcp->state = 0;\r\n\tkcp->acklist = NULL;\r\n\tkcp->ackblock = 0;\r\n\tkcp->ackcount = 0;\r\n\tkcp->rx_srtt = 0;\r\n\tkcp->rx_rttval = 0;\r\n\tkcp->rx_rto = IKCP_RTO_DEF;\r\n\tkcp->rx_minrto = IKCP_RTO_MIN;\r\n\tkcp->current = 0;\r\n\tkcp->interval = IKCP_INTERVAL;\r\n\tkcp->ts_flush = IKCP_INTERVAL;\r\n\tkcp->nodelay = 0;\r\n\tkcp->updated = 0;\r\n\tkcp->logmask = 0;\r\n\tkcp->ssthresh = IKCP_THRESH_INIT;\r\n\tkcp->fastresend = 0;\r\n\tkcp->fastlimit = IKCP_FASTACK_LIMIT;\r\n\tkcp->nocwnd = 0;\r\n\tkcp->xmit = 0;\r\n\tkcp->dead_link = IKCP_DEADLINK;\r\n\tkcp->output = NULL;\r\n\tkcp->writelog = NULL;\r\n\r\n\treturn kcp;\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// release a new kcpcb\r\n//---------------------------------------------------------------------\r\nvoid ikcp_release(ikcpcb *kcp)\r\n{\r\n\tassert(kcp);\r\n\tif (kcp) {\r\n\t\tIKCPSEG *seg;\r\n\t\twhile (!iqueue_is_empty(&kcp->snd_buf)) {\r\n\t\t\tseg = iqueue_entry(kcp->snd_buf.next, IKCPSEG, node);\r\n\t\t\tiqueue_del(&seg->node);\r\n\t\t\tikcp_segment_delete(kcp, seg);\r\n\t\t}\r\n\t\twhile (!iqueue_is_empty(&kcp->rcv_buf)) {\r\n\t\t\tseg = iqueue_entry(kcp->rcv_buf.next, IKCPSEG, node);\r\n\t\t\tiqueue_del(&seg->node);\r\n\t\t\tikcp_segment_delete(kcp, seg);\r\n\t\t}\r\n\t\twhile (!iqueue_is_empty(&kcp->snd_queue)) {\r\n\t\t\tseg = iqueue_entry(kcp->snd_queue.next, IKCPSEG, node);\r\n\t\t\tiqueue_del(&seg->node);\r\n\t\t\tikcp_segment_delete(kcp, seg);\r\n\t\t}\r\n\t\twhile (!iqueue_is_empty(&kcp->rcv_queue)) {\r\n\t\t\tseg = iqueue_entry(kcp->rcv_queue.next, IKCPSEG, node);\r\n\t\t\tiqueue_del(&seg->node);\r\n\t\t\tikcp_segment_delete(kcp, seg);\r\n\t\t}\r\n\t\tif (kcp->buffer) {\r\n\t\t\tikcp_free(kcp->buffer);\r\n\t\t}\r\n\t\tif (kcp->acklist) {\r\n\t\t\tikcp_free(kcp->acklist);\r\n\t\t}\r\n\r\n\t\tkcp->nrcv_buf = 0;\r\n\t\tkcp->nsnd_buf = 0;\r\n\t\tkcp->nrcv_que = 0;\r\n\t\tkcp->nsnd_que = 0;\r\n\t\tkcp->ackcount = 0;\r\n\t\tkcp->buffer = NULL;\r\n\t\tkcp->acklist = NULL;\r\n\t\tikcp_free(kcp);\r\n\t}\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// set output callback, which will be invoked by kcp\r\n//---------------------------------------------------------------------\r\nvoid ikcp_setoutput(ikcpcb *kcp, int (*output)(const char *buf, int len,\r\n\tikcpcb *kcp, void *user))\r\n{\r\n\tkcp->output = output;\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// user/upper level recv: returns size, returns below zero for EAGAIN\r\n//---------------------------------------------------------------------\r\nint ikcp_recv(ikcpcb *kcp, char *buffer, int len)\r\n{\r\n\tstruct IQUEUEHEAD *p;\r\n\tint ispeek = (len < 0)? 1 : 0;\r\n\tint peeksize;\r\n\tint recover = 0;\r\n\tIKCPSEG *seg;\r\n\tassert(kcp);\r\n\r\n\tif (iqueue_is_empty(&kcp->rcv_queue))\r\n\t\treturn -1;\r\n\r\n\tif (len < 0) len = -len;\r\n\r\n\tpeeksize = ikcp_peeksize(kcp);\r\n\r\n\tif (peeksize < 0) \r\n\t\treturn -2;\r\n\r\n\tif (peeksize > len) \r\n\t\treturn -3;\r\n\r\n\tif (kcp->nrcv_que >= kcp->rcv_wnd)\r\n\t\trecover = 1;\r\n\r\n\t// merge fragment\r\n\tfor (len = 0, p = kcp->rcv_queue.next; p != &kcp->rcv_queue; ) {\r\n\t\tint fragment;\r\n\t\tseg = iqueue_entry(p, IKCPSEG, node);\r\n\t\tp = p->next;\r\n\r\n\t\tif (buffer) {\r\n\t\t\tmemcpy(buffer, seg->data, seg->len);\r\n\t\t\tbuffer += seg->len;\r\n\t\t}\r\n\r\n\t\tlen += seg->len;\r\n\t\tfragment = seg->frg;\r\n\r\n\t\tif (ikcp_canlog(kcp, IKCP_LOG_RECV)) {\r\n\t\t\tikcp_log(kcp, IKCP_LOG_RECV, \"recv sn=%lu\", (unsigned long)seg->sn);\r\n\t\t}\r\n\r\n\t\tif (ispeek == 0) {\r\n\t\t\tiqueue_del(&seg->node);\r\n\t\t\tikcp_segment_delete(kcp, seg);\r\n\t\t\tkcp->nrcv_que--;\r\n\t\t}\r\n\r\n\t\tif (fragment == 0) \r\n\t\t\tbreak;\r\n\t}\r\n\r\n\tassert(len == peeksize);\r\n\r\n\t// move available data from rcv_buf -> rcv_queue\r\n\twhile (! iqueue_is_empty(&kcp->rcv_buf)) {\r\n\t\tseg = iqueue_entry(kcp->rcv_buf.next, IKCPSEG, node);\r\n\t\tif (seg->sn == kcp->rcv_nxt && kcp->nrcv_que < kcp->rcv_wnd) {\r\n\t\t\tiqueue_del(&seg->node);\r\n\t\t\tkcp->nrcv_buf--;\r\n\t\t\tiqueue_add_tail(&seg->node, &kcp->rcv_queue);\r\n\t\t\tkcp->nrcv_que++;\r\n\t\t\tkcp->rcv_nxt++;\r\n\t\t}\telse {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t// fast recover\r\n\tif (kcp->nrcv_que < kcp->rcv_wnd && recover) {\r\n\t\t// ready to send back IKCP_CMD_WINS in ikcp_flush\r\n\t\t// tell remote my window size\r\n\t\tkcp->probe |= IKCP_ASK_TELL;\r\n\t}\r\n\r\n\treturn len;\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// peek data size\r\n//---------------------------------------------------------------------\r\nint ikcp_peeksize(const ikcpcb *kcp)\r\n{\r\n\tstruct IQUEUEHEAD *p;\r\n\tIKCPSEG *seg;\r\n\tint length = 0;\r\n\r\n\tassert(kcp);\r\n\r\n\tif (iqueue_is_empty(&kcp->rcv_queue)) return -1;\r\n\r\n\tseg = iqueue_entry(kcp->rcv_queue.next, IKCPSEG, node);\r\n\tif (seg->frg == 0) return seg->len;\r\n\r\n\tif (kcp->nrcv_que < seg->frg + 1) return -1;\r\n\r\n\tfor (p = kcp->rcv_queue.next; p != &kcp->rcv_queue; p = p->next) {\r\n\t\tseg = iqueue_entry(p, IKCPSEG, node);\r\n\t\tlength += seg->len;\r\n\t\tif (seg->frg == 0) break;\r\n\t}\r\n\r\n\treturn length;\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// user/upper level send, returns below zero for error\r\n//---------------------------------------------------------------------\r\nint ikcp_send(ikcpcb *kcp, const char *buffer, int len)\r\n{\r\n\tIKCPSEG *seg;\r\n\tint count, i;\r\n\tint sent = 0;\r\n\r\n\tassert(kcp->mss > 0);\r\n\tif (len < 0) return -1;\r\n\r\n\t// append to previous segment in streaming mode (if possible)\r\n\tif (kcp->stream != 0) {\r\n\t\tif (!iqueue_is_empty(&kcp->snd_queue)) {\r\n\t\t\tIKCPSEG *old = iqueue_entry(kcp->snd_queue.prev, IKCPSEG, node);\r\n\t\t\tif (old->len < kcp->mss) {\r\n\t\t\t\tint capacity = kcp->mss - old->len;\r\n\t\t\t\tint extend = (len < capacity)? len : capacity;\r\n\t\t\t\tseg = ikcp_segment_new(kcp, old->len + extend);\r\n\t\t\t\tassert(seg);\r\n\t\t\t\tif (seg == NULL) {\r\n\t\t\t\t\treturn -2;\r\n\t\t\t\t}\r\n\t\t\t\tiqueue_add_tail(&seg->node, &kcp->snd_queue);\r\n\t\t\t\tmemcpy(seg->data, old->data, old->len);\r\n\t\t\t\tif (buffer) {\r\n\t\t\t\t\tmemcpy(seg->data + old->len, buffer, extend);\r\n\t\t\t\t\tbuffer += extend;\r\n\t\t\t\t}\r\n\t\t\t\tseg->len = old->len + extend;\r\n\t\t\t\tseg->frg = 0;\r\n\t\t\t\tlen -= extend;\r\n\t\t\t\tiqueue_del_init(&old->node);\r\n\t\t\t\tikcp_segment_delete(kcp, old);\r\n\t\t\t\tsent = extend;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (len <= 0) {\r\n\t\t\treturn sent;\r\n\t\t}\r\n\t}\r\n\r\n\tif (len <= (int)kcp->mss) count = 1;\r\n\telse count = (len + kcp->mss - 1) / kcp->mss;\r\n\r\n\tif (count >= (int)IKCP_WND_RCV) {\r\n\t\tif (kcp->stream != 0 && sent > 0) \r\n\t\t\treturn sent;\r\n\t\treturn -2;\r\n\t}\r\n\r\n\tif (count == 0) count = 1;\r\n\r\n\t// fragment\r\n\tfor (i = 0; i < count; i++) {\r\n\t\tint size = len > (int)kcp->mss ? (int)kcp->mss : len;\r\n\t\tseg = ikcp_segment_new(kcp, size);\r\n\t\tassert(seg);\r\n\t\tif (seg == NULL) {\r\n\t\t\treturn -2;\r\n\t\t}\r\n\t\tif (buffer && len > 0) {\r\n\t\t\tmemcpy(seg->data, buffer, size);\r\n\t\t}\r\n\t\tseg->len = size;\r\n\t\tseg->frg = (kcp->stream == 0)? (count - i - 1) : 0;\r\n\t\tiqueue_init(&seg->node);\r\n\t\tiqueue_add_tail(&seg->node, &kcp->snd_queue);\r\n\t\tkcp->nsnd_que++;\r\n\t\tif (buffer) {\r\n\t\t\tbuffer += size;\r\n\t\t}\r\n\t\tlen -= size;\r\n\t\tsent += size;\r\n\t}\r\n\r\n\treturn sent;\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// parse ack\r\n//---------------------------------------------------------------------\r\nstatic void ikcp_update_ack(ikcpcb *kcp, IINT32 rtt)\r\n{\r\n\tIINT32 rto = 0;\r\n\tif (kcp->rx_srtt == 0) {\r\n\t\tkcp->rx_srtt = rtt;\r\n\t\tkcp->rx_rttval = rtt / 2;\r\n\t}\telse {\r\n\t\tlong delta = rtt - kcp->rx_srtt;\r\n\t\tif (delta < 0) delta = -delta;\r\n\t\tkcp->rx_rttval = (3 * kcp->rx_rttval + delta) / 4;\r\n\t\tkcp->rx_srtt = (7 * kcp->rx_srtt + rtt) / 8;\r\n\t\tif (kcp->rx_srtt < 1) kcp->rx_srtt = 1;\r\n\t}\r\n\trto = kcp->rx_srtt + _imax_(kcp->interval, 4 * kcp->rx_rttval);\r\n\tkcp->rx_rto = _ibound_(kcp->rx_minrto, rto, IKCP_RTO_MAX);\r\n}\r\n\r\nstatic void ikcp_shrink_buf(ikcpcb *kcp)\r\n{\r\n\tstruct IQUEUEHEAD *p = kcp->snd_buf.next;\r\n\tif (p != &kcp->snd_buf) {\r\n\t\tIKCPSEG *seg = iqueue_entry(p, IKCPSEG, node);\r\n\t\tkcp->snd_una = seg->sn;\r\n\t}\telse {\r\n\t\tkcp->snd_una = kcp->snd_nxt;\r\n\t}\r\n}\r\n\r\nstatic void ikcp_parse_ack(ikcpcb *kcp, IUINT32 sn)\r\n{\r\n\tstruct IQUEUEHEAD *p, *next;\r\n\r\n\tif (_itimediff(sn, kcp->snd_una) < 0 || _itimediff(sn, kcp->snd_nxt) >= 0)\r\n\t\treturn;\r\n\r\n\tfor (p = kcp->snd_buf.next; p != &kcp->snd_buf; p = next) {\r\n\t\tIKCPSEG *seg = iqueue_entry(p, IKCPSEG, node);\r\n\t\tnext = p->next;\r\n\t\tif (sn == seg->sn) {\r\n\t\t\tiqueue_del(p);\r\n\t\t\tikcp_segment_delete(kcp, seg);\r\n\t\t\tkcp->nsnd_buf--;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif (_itimediff(sn, seg->sn) < 0) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void ikcp_parse_una(ikcpcb *kcp, IUINT32 una)\r\n{\r\n\tstruct IQUEUEHEAD *p, *next;\r\n\tfor (p = kcp->snd_buf.next; p != &kcp->snd_buf; p = next) {\r\n\t\tIKCPSEG *seg = iqueue_entry(p, IKCPSEG, node);\r\n\t\tnext = p->next;\r\n\t\tif (_itimediff(una, seg->sn) > 0) {\r\n\t\t\tiqueue_del(p);\r\n\t\t\tikcp_segment_delete(kcp, seg);\r\n\t\t\tkcp->nsnd_buf--;\r\n\t\t}\telse {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstatic void ikcp_parse_fastack(ikcpcb *kcp, IUINT32 sn, IUINT32 ts)\r\n{\r\n\tstruct IQUEUEHEAD *p, *next;\r\n\r\n\tif (_itimediff(sn, kcp->snd_una) < 0 || _itimediff(sn, kcp->snd_nxt) >= 0)\r\n\t\treturn;\r\n\r\n\tfor (p = kcp->snd_buf.next; p != &kcp->snd_buf; p = next) {\r\n\t\tIKCPSEG *seg = iqueue_entry(p, IKCPSEG, node);\r\n\t\tnext = p->next;\r\n\t\tif (_itimediff(sn, seg->sn) < 0) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse if (sn != seg->sn) {\r\n\t\t#ifndef IKCP_FASTACK_CONSERVE\r\n\t\t\tseg->fastack++;\r\n\t\t#else\r\n\t\t\tif (_itimediff(ts, seg->ts) >= 0)\r\n\t\t\t\tseg->fastack++;\r\n\t\t#endif\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// ack append\r\n//---------------------------------------------------------------------\r\nstatic void ikcp_ack_push(ikcpcb *kcp, IUINT32 sn, IUINT32 ts)\r\n{\r\n\tIUINT32 newsize = kcp->ackcount + 1;\r\n\tIUINT32 *ptr;\r\n\r\n\tif (newsize > kcp->ackblock) {\r\n\t\tIUINT32 *acklist;\r\n\t\tIUINT32 newblock;\r\n\r\n\t\tfor (newblock = 8; newblock < newsize; newblock <<= 1);\r\n\t\tacklist = (IUINT32*)ikcp_malloc(newblock * sizeof(IUINT32) * 2);\r\n\r\n\t\tif (acklist == NULL) {\r\n\t\t\tassert(acklist != NULL);\r\n\t\t\tabort();\r\n\t\t}\r\n\r\n\t\tif (kcp->acklist != NULL) {\r\n\t\t\tIUINT32 x;\r\n\t\t\tfor (x = 0; x < kcp->ackcount; x++) {\r\n\t\t\t\tacklist[x * 2 + 0] = kcp->acklist[x * 2 + 0];\r\n\t\t\t\tacklist[x * 2 + 1] = kcp->acklist[x * 2 + 1];\r\n\t\t\t}\r\n\t\t\tikcp_free(kcp->acklist);\r\n\t\t}\r\n\r\n\t\tkcp->acklist = acklist;\r\n\t\tkcp->ackblock = newblock;\r\n\t}\r\n\r\n\tptr = &kcp->acklist[kcp->ackcount * 2];\r\n\tptr[0] = sn;\r\n\tptr[1] = ts;\r\n\tkcp->ackcount++;\r\n}\r\n\r\nstatic void ikcp_ack_get(const ikcpcb *kcp, int p, IUINT32 *sn, IUINT32 *ts)\r\n{\r\n\tif (sn) sn[0] = kcp->acklist[p * 2 + 0];\r\n\tif (ts) ts[0] = kcp->acklist[p * 2 + 1];\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// parse data\r\n//---------------------------------------------------------------------\r\nvoid ikcp_parse_data(ikcpcb *kcp, IKCPSEG *newseg)\r\n{\r\n\tstruct IQUEUEHEAD *p, *prev;\r\n\tIUINT32 sn = newseg->sn;\r\n\tint repeat = 0;\r\n\t\r\n\tif (_itimediff(sn, kcp->rcv_nxt + kcp->rcv_wnd) >= 0 ||\r\n\t\t_itimediff(sn, kcp->rcv_nxt) < 0) {\r\n\t\tikcp_segment_delete(kcp, newseg);\r\n\t\treturn;\r\n\t}\r\n\r\n\tfor (p = kcp->rcv_buf.prev; p != &kcp->rcv_buf; p = prev) {\r\n\t\tIKCPSEG *seg = iqueue_entry(p, IKCPSEG, node);\r\n\t\tprev = p->prev;\r\n\t\tif (seg->sn == sn) {\r\n\t\t\trepeat = 1;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif (_itimediff(sn, seg->sn) > 0) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (repeat == 0) {\r\n\t\tiqueue_init(&newseg->node);\r\n\t\tiqueue_add(&newseg->node, p);\r\n\t\tkcp->nrcv_buf++;\r\n\t}\telse {\r\n\t\tikcp_segment_delete(kcp, newseg);\r\n\t}\r\n\r\n#if 0\r\n\tikcp_qprint(\"rcvbuf\", &kcp->rcv_buf);\r\n\tprintf(\"rcv_nxt=%lu\\n\", kcp->rcv_nxt);\r\n#endif\r\n\r\n\t// move available data from rcv_buf -> rcv_queue\r\n\twhile (! iqueue_is_empty(&kcp->rcv_buf)) {\r\n\t\tIKCPSEG *seg = iqueue_entry(kcp->rcv_buf.next, IKCPSEG, node);\r\n\t\tif (seg->sn == kcp->rcv_nxt && kcp->nrcv_que < kcp->rcv_wnd) {\r\n\t\t\tiqueue_del(&seg->node);\r\n\t\t\tkcp->nrcv_buf--;\r\n\t\t\tiqueue_add_tail(&seg->node, &kcp->rcv_queue);\r\n\t\t\tkcp->nrcv_que++;\r\n\t\t\tkcp->rcv_nxt++;\r\n\t\t}\telse {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n#if 0\r\n\tikcp_qprint(\"queue\", &kcp->rcv_queue);\r\n\tprintf(\"rcv_nxt=%lu\\n\", kcp->rcv_nxt);\r\n#endif\r\n\r\n#if 1\r\n//\tprintf(\"snd(buf=%d, queue=%d)\\n\", kcp->nsnd_buf, kcp->nsnd_que);\r\n//\tprintf(\"rcv(buf=%d, queue=%d)\\n\", kcp->nrcv_buf, kcp->nrcv_que);\r\n#endif\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// input data\r\n//---------------------------------------------------------------------\r\nint ikcp_input(ikcpcb *kcp, const char *data, long size)\r\n{\r\n\tIUINT32 prev_una = kcp->snd_una;\r\n\tIUINT32 maxack = 0, latest_ts = 0;\r\n\tint flag = 0;\r\n\r\n\tif (ikcp_canlog(kcp, IKCP_LOG_INPUT)) {\r\n\t\tikcp_log(kcp, IKCP_LOG_INPUT, \"[RI] %d bytes\", (int)size);\r\n\t}\r\n\r\n\tif (data == NULL || (int)size < (int)IKCP_OVERHEAD) return -1;\r\n\r\n\twhile (1) {\r\n\t\tIUINT32 ts, sn, len, una, conv;\r\n\t\tIUINT16 wnd;\r\n\t\tIUINT8 cmd, frg;\r\n\t\tIKCPSEG *seg;\r\n\r\n\t\tif (size < (int)IKCP_OVERHEAD) break;\r\n\r\n\t\tdata = ikcp_decode32u(data, &conv);\r\n\t\tif (conv != kcp->conv) return -1;\r\n\r\n\t\tdata = ikcp_decode8u(data, &cmd);\r\n\t\tdata = ikcp_decode8u(data, &frg);\r\n\t\tdata = ikcp_decode16u(data, &wnd);\r\n\t\tdata = ikcp_decode32u(data, &ts);\r\n\t\tdata = ikcp_decode32u(data, &sn);\r\n\t\tdata = ikcp_decode32u(data, &una);\r\n\t\tdata = ikcp_decode32u(data, &len);\r\n\r\n\t\tsize -= IKCP_OVERHEAD;\r\n\r\n\t\tif ((long)size < (long)len || (int)len < 0) return -2;\r\n\r\n\t\tif (cmd != IKCP_CMD_PUSH && cmd != IKCP_CMD_ACK &&\r\n\t\t\tcmd != IKCP_CMD_WASK && cmd != IKCP_CMD_WINS) \r\n\t\t\treturn -3;\r\n\r\n\t\tkcp->rmt_wnd = wnd;\r\n\t\tikcp_parse_una(kcp, una);\r\n\t\tikcp_shrink_buf(kcp);\r\n\r\n\t\tif (cmd == IKCP_CMD_ACK) {\r\n\t\t\tif (_itimediff(kcp->current, ts) >= 0) {\r\n\t\t\t\tikcp_update_ack(kcp, _itimediff(kcp->current, ts));\r\n\t\t\t}\r\n\t\t\tikcp_parse_ack(kcp, sn);\r\n\t\t\tikcp_shrink_buf(kcp);\r\n\t\t\tif (flag == 0) {\r\n\t\t\t\tflag = 1;\r\n\t\t\t\tmaxack = sn;\r\n\t\t\t\tlatest_ts = ts;\r\n\t\t\t}\telse {\r\n\t\t\t\tif (_itimediff(sn, maxack) > 0) {\r\n\t\t\t\t#ifndef IKCP_FASTACK_CONSERVE\r\n\t\t\t\t\tmaxack = sn;\r\n\t\t\t\t\tlatest_ts = ts;\r\n\t\t\t\t#else\r\n\t\t\t\t\tif (_itimediff(ts, latest_ts) > 0) {\r\n\t\t\t\t\t\tmaxack = sn;\r\n\t\t\t\t\t\tlatest_ts = ts;\r\n\t\t\t\t\t}\r\n\t\t\t\t#endif\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (ikcp_canlog(kcp, IKCP_LOG_IN_ACK)) {\r\n\t\t\t\tikcp_log(kcp, IKCP_LOG_IN_ACK, \r\n\t\t\t\t\t\"input ack: sn=%lu rtt=%ld rto=%ld\", (unsigned long)sn, \r\n\t\t\t\t\t(long)_itimediff(kcp->current, ts),\r\n\t\t\t\t\t(long)kcp->rx_rto);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (cmd == IKCP_CMD_PUSH) {\r\n\t\t\tif (ikcp_canlog(kcp, IKCP_LOG_IN_DATA)) {\r\n\t\t\t\tikcp_log(kcp, IKCP_LOG_IN_DATA, \r\n\t\t\t\t\t\"input psh: sn=%lu ts=%lu\", (unsigned long)sn, (unsigned long)ts);\r\n\t\t\t}\r\n\t\t\tif (_itimediff(sn, kcp->rcv_nxt + kcp->rcv_wnd) < 0) {\r\n\t\t\t\tikcp_ack_push(kcp, sn, ts);\r\n\t\t\t\tif (_itimediff(sn, kcp->rcv_nxt) >= 0) {\r\n\t\t\t\t\tseg = ikcp_segment_new(kcp, len);\r\n\t\t\t\t\tseg->conv = conv;\r\n\t\t\t\t\tseg->cmd = cmd;\r\n\t\t\t\t\tseg->frg = frg;\r\n\t\t\t\t\tseg->wnd = wnd;\r\n\t\t\t\t\tseg->ts = ts;\r\n\t\t\t\t\tseg->sn = sn;\r\n\t\t\t\t\tseg->una = una;\r\n\t\t\t\t\tseg->len = len;\r\n\r\n\t\t\t\t\tif (len > 0) {\r\n\t\t\t\t\t\tmemcpy(seg->data, data, len);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tikcp_parse_data(kcp, seg);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (cmd == IKCP_CMD_WASK) {\r\n\t\t\t// ready to send back IKCP_CMD_WINS in ikcp_flush\r\n\t\t\t// tell remote my window size\r\n\t\t\tkcp->probe |= IKCP_ASK_TELL;\r\n\t\t\tif (ikcp_canlog(kcp, IKCP_LOG_IN_PROBE)) {\r\n\t\t\t\tikcp_log(kcp, IKCP_LOG_IN_PROBE, \"input probe\");\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (cmd == IKCP_CMD_WINS) {\r\n\t\t\t// do nothing\r\n\t\t\tif (ikcp_canlog(kcp, IKCP_LOG_IN_WINS)) {\r\n\t\t\t\tikcp_log(kcp, IKCP_LOG_IN_WINS,\r\n\t\t\t\t\t\"input wins: %lu\", (unsigned long)(wnd));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn -3;\r\n\t\t}\r\n\r\n\t\tdata += len;\r\n\t\tsize -= len;\r\n\t}\r\n\r\n\tif (flag != 0) {\r\n\t\tikcp_parse_fastack(kcp, maxack, latest_ts);\r\n\t}\r\n\r\n\tif (_itimediff(kcp->snd_una, prev_una) > 0) {\r\n\t\tif (kcp->cwnd < kcp->rmt_wnd) {\r\n\t\t\tIUINT32 mss = kcp->mss;\r\n\t\t\tif (kcp->cwnd < kcp->ssthresh) {\r\n\t\t\t\tkcp->cwnd++;\r\n\t\t\t\tkcp->incr += mss;\r\n\t\t\t}\telse {\r\n\t\t\t\tif (kcp->incr < mss) kcp->incr = mss;\r\n\t\t\t\tkcp->incr += (mss * mss) / kcp->incr + (mss / 16);\r\n\t\t\t\tif ((kcp->cwnd + 1) * mss <= kcp->incr) {\r\n\t\t\t\t#if 1\r\n\t\t\t\t\tkcp->cwnd = (kcp->incr + mss - 1) / ((mss > 0)? mss : 1);\r\n\t\t\t\t#else\r\n\t\t\t\t\tkcp->cwnd++;\r\n\t\t\t\t#endif\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (kcp->cwnd > kcp->rmt_wnd) {\r\n\t\t\t\tkcp->cwnd = kcp->rmt_wnd;\r\n\t\t\t\tkcp->incr = kcp->rmt_wnd * mss;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// ikcp_encode_seg\r\n//---------------------------------------------------------------------\r\nstatic char *ikcp_encode_seg(char *ptr, const IKCPSEG *seg)\r\n{\r\n\tptr = ikcp_encode32u(ptr, seg->conv);\r\n\tptr = ikcp_encode8u(ptr, (IUINT8)seg->cmd);\r\n\tptr = ikcp_encode8u(ptr, (IUINT8)seg->frg);\r\n\tptr = ikcp_encode16u(ptr, (IUINT16)seg->wnd);\r\n\tptr = ikcp_encode32u(ptr, seg->ts);\r\n\tptr = ikcp_encode32u(ptr, seg->sn);\r\n\tptr = ikcp_encode32u(ptr, seg->una);\r\n\tptr = ikcp_encode32u(ptr, seg->len);\r\n\treturn ptr;\r\n}\r\n\r\nstatic int ikcp_wnd_unused(const ikcpcb *kcp)\r\n{\r\n\tif (kcp->nrcv_que < kcp->rcv_wnd) {\r\n\t\treturn kcp->rcv_wnd - kcp->nrcv_que;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// ikcp_flush\r\n//---------------------------------------------------------------------\r\nvoid ikcp_flush(ikcpcb *kcp)\r\n{\r\n\tIUINT32 current = kcp->current;\r\n\tchar *buffer = kcp->buffer;\r\n\tchar *ptr = buffer;\r\n\tint count, size, i;\r\n\tIUINT32 resent, cwnd;\r\n\tIUINT32 rtomin;\r\n\tstruct IQUEUEHEAD *p;\r\n\tint change = 0;\r\n\tint lost = 0;\r\n\tIKCPSEG seg;\r\n\r\n\t// 'ikcp_update' haven't been called. \r\n\tif (kcp->updated == 0) return;\r\n\r\n\tseg.conv = kcp->conv;\r\n\tseg.cmd = IKCP_CMD_ACK;\r\n\tseg.frg = 0;\r\n\tseg.wnd = ikcp_wnd_unused(kcp);\r\n\tseg.una = kcp->rcv_nxt;\r\n\tseg.len = 0;\r\n\tseg.sn = 0;\r\n\tseg.ts = 0;\r\n\r\n\t// flush acknowledges\r\n\tcount = kcp->ackcount;\r\n\tfor (i = 0; i < count; i++) {\r\n\t\tsize = (int)(ptr - buffer);\r\n\t\tif (size + (int)IKCP_OVERHEAD > (int)kcp->mtu) {\r\n\t\t\tikcp_output(kcp, buffer, size);\r\n\t\t\tptr = buffer;\r\n\t\t}\r\n\t\tikcp_ack_get(kcp, i, &seg.sn, &seg.ts);\r\n\t\tptr = ikcp_encode_seg(ptr, &seg);\r\n\t}\r\n\r\n\tkcp->ackcount = 0;\r\n\r\n\t// probe window size (if remote window size equals zero)\r\n\tif (kcp->rmt_wnd == 0) {\r\n\t\tif (kcp->probe_wait == 0) {\r\n\t\t\tkcp->probe_wait = IKCP_PROBE_INIT;\r\n\t\t\tkcp->ts_probe = kcp->current + kcp->probe_wait;\r\n\t\t}\t\r\n\t\telse {\r\n\t\t\tif (_itimediff(kcp->current, kcp->ts_probe) >= 0) {\r\n\t\t\t\tif (kcp->probe_wait < IKCP_PROBE_INIT) \r\n\t\t\t\t\tkcp->probe_wait = IKCP_PROBE_INIT;\r\n\t\t\t\tkcp->probe_wait += kcp->probe_wait / 2;\r\n\t\t\t\tif (kcp->probe_wait > IKCP_PROBE_LIMIT)\r\n\t\t\t\t\tkcp->probe_wait = IKCP_PROBE_LIMIT;\r\n\t\t\t\tkcp->ts_probe = kcp->current + kcp->probe_wait;\r\n\t\t\t\tkcp->probe |= IKCP_ASK_SEND;\r\n\t\t\t}\r\n\t\t}\r\n\t}\telse {\r\n\t\tkcp->ts_probe = 0;\r\n\t\tkcp->probe_wait = 0;\r\n\t}\r\n\r\n\t// flush window probing commands\r\n\tif (kcp->probe & IKCP_ASK_SEND) {\r\n\t\tseg.cmd = IKCP_CMD_WASK;\r\n\t\tsize = (int)(ptr - buffer);\r\n\t\tif (size + (int)IKCP_OVERHEAD > (int)kcp->mtu) {\r\n\t\t\tikcp_output(kcp, buffer, size);\r\n\t\t\tptr = buffer;\r\n\t\t}\r\n\t\tptr = ikcp_encode_seg(ptr, &seg);\r\n\t}\r\n\r\n\t// flush window probing commands\r\n\tif (kcp->probe & IKCP_ASK_TELL) {\r\n\t\tseg.cmd = IKCP_CMD_WINS;\r\n\t\tsize = (int)(ptr - buffer);\r\n\t\tif (size + (int)IKCP_OVERHEAD > (int)kcp->mtu) {\r\n\t\t\tikcp_output(kcp, buffer, size);\r\n\t\t\tptr = buffer;\r\n\t\t}\r\n\t\tptr = ikcp_encode_seg(ptr, &seg);\r\n\t}\r\n\r\n\tkcp->probe = 0;\r\n\r\n\t// calculate window size\r\n\tcwnd = _imin_(kcp->snd_wnd, kcp->rmt_wnd);\r\n\tif (kcp->nocwnd == 0) cwnd = _imin_(kcp->cwnd, cwnd);\r\n\r\n\t// move data from snd_queue to snd_buf\r\n\twhile (_itimediff(kcp->snd_nxt, kcp->snd_una + cwnd) < 0) {\r\n\t\tIKCPSEG *newseg;\r\n\t\tif (iqueue_is_empty(&kcp->snd_queue)) break;\r\n\r\n\t\tnewseg = iqueue_entry(kcp->snd_queue.next, IKCPSEG, node);\r\n\r\n\t\tiqueue_del(&newseg->node);\r\n\t\tiqueue_add_tail(&newseg->node, &kcp->snd_buf);\r\n\t\tkcp->nsnd_que--;\r\n\t\tkcp->nsnd_buf++;\r\n\r\n\t\tnewseg->conv = kcp->conv;\r\n\t\tnewseg->cmd = IKCP_CMD_PUSH;\r\n\t\tnewseg->wnd = seg.wnd;\r\n\t\tnewseg->ts = current;\r\n\t\tnewseg->sn = kcp->snd_nxt++;\r\n\t\tnewseg->una = kcp->rcv_nxt;\r\n\t\tnewseg->resendts = current;\r\n\t\tnewseg->rto = kcp->rx_rto;\r\n\t\tnewseg->fastack = 0;\r\n\t\tnewseg->xmit = 0;\r\n\t}\r\n\r\n\t// calculate resent\r\n\tresent = (kcp->fastresend > 0)? (IUINT32)kcp->fastresend : 0xffffffff;\r\n\trtomin = (kcp->nodelay == 0)? (kcp->rx_rto >> 3) : 0;\r\n\r\n\t// flush data segments\r\n\tfor (p = kcp->snd_buf.next; p != &kcp->snd_buf; p = p->next) {\r\n\t\tIKCPSEG *segment = iqueue_entry(p, IKCPSEG, node);\r\n\t\tint needsend = 0;\r\n\t\tif (segment->xmit == 0) {\r\n\t\t\tneedsend = 1;\r\n\t\t\tsegment->xmit++;\r\n\t\t\tsegment->rto = kcp->rx_rto;\r\n\t\t\tsegment->resendts = current + segment->rto + rtomin;\r\n\t\t}\r\n\t\telse if (_itimediff(current, segment->resendts) >= 0) {\r\n\t\t\tneedsend = 1;\r\n\t\t\tsegment->xmit++;\r\n\t\t\tkcp->xmit++;\r\n\t\t\tif (kcp->nodelay == 0) {\r\n\t\t\t\tsegment->rto += _imax_(segment->rto, (IUINT32)kcp->rx_rto);\r\n\t\t\t}\telse {\r\n\t\t\t\tIINT32 step = (kcp->nodelay < 2)? \r\n\t\t\t\t\t((IINT32)(segment->rto)) : kcp->rx_rto;\r\n\t\t\t\tsegment->rto += step / 2;\r\n\t\t\t}\r\n\t\t\tsegment->resendts = current + segment->rto;\r\n\t\t\tlost = 1;\r\n\t\t}\r\n\t\telse if (segment->fastack >= resent) {\r\n\t\t\tif ((int)segment->xmit <= kcp->fastlimit || \r\n\t\t\t\tkcp->fastlimit <= 0) {\r\n\t\t\t\tneedsend = 1;\r\n\t\t\t\tsegment->xmit++;\r\n\t\t\t\tsegment->fastack = 0;\r\n\t\t\t\tsegment->resendts = current + segment->rto;\r\n\t\t\t\tchange++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (needsend) {\r\n\t\t\tint need;\r\n\t\t\tsegment->ts = current;\r\n\t\t\tsegment->wnd = seg.wnd;\r\n\t\t\tsegment->una = kcp->rcv_nxt;\r\n\r\n\t\t\tsize = (int)(ptr - buffer);\r\n\t\t\tneed = IKCP_OVERHEAD + segment->len;\r\n\r\n\t\t\tif (size + need > (int)kcp->mtu) {\r\n\t\t\t\tikcp_output(kcp, buffer, size);\r\n\t\t\t\tptr = buffer;\r\n\t\t\t}\r\n\r\n\t\t\tptr = ikcp_encode_seg(ptr, segment);\r\n\r\n\t\t\tif (segment->len > 0) {\r\n\t\t\t\tmemcpy(ptr, segment->data, segment->len);\r\n\t\t\t\tptr += segment->len;\r\n\t\t\t}\r\n\r\n\t\t\tif (segment->xmit >= kcp->dead_link) {\r\n\t\t\t\tkcp->state = (IUINT32)-1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// flash remain segments\r\n\tsize = (int)(ptr - buffer);\r\n\tif (size > 0) {\r\n\t\tikcp_output(kcp, buffer, size);\r\n\t}\r\n\r\n\t// update ssthresh\r\n\tif (change) {\r\n\t\tIUINT32 inflight = kcp->snd_nxt - kcp->snd_una;\r\n\t\tkcp->ssthresh = inflight / 2;\r\n\t\tif (kcp->ssthresh < IKCP_THRESH_MIN)\r\n\t\t\tkcp->ssthresh = IKCP_THRESH_MIN;\r\n\t\tkcp->cwnd = kcp->ssthresh + resent;\r\n\t\tkcp->incr = kcp->cwnd * kcp->mss;\r\n\t}\r\n\r\n\tif (lost) {\r\n\t\tkcp->ssthresh = cwnd / 2;\r\n\t\tif (kcp->ssthresh < IKCP_THRESH_MIN)\r\n\t\t\tkcp->ssthresh = IKCP_THRESH_MIN;\r\n\t\tkcp->cwnd = 1;\r\n\t\tkcp->incr = kcp->mss;\r\n\t}\r\n\r\n\tif (kcp->cwnd < 1) {\r\n\t\tkcp->cwnd = 1;\r\n\t\tkcp->incr = kcp->mss;\r\n\t}\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// update state (call it repeatedly, every 10ms-100ms), or you can ask \r\n// ikcp_check when to call it again (without ikcp_input/_send calling).\r\n// 'current' - current timestamp in millisec. \r\n//---------------------------------------------------------------------\r\nvoid ikcp_update(ikcpcb *kcp, IUINT32 current)\r\n{\r\n\tIINT32 slap;\r\n\r\n\tkcp->current = current;\r\n\r\n\tif (kcp->updated == 0) {\r\n\t\tkcp->updated = 1;\r\n\t\tkcp->ts_flush = kcp->current;\r\n\t}\r\n\r\n\tslap = _itimediff(kcp->current, kcp->ts_flush);\r\n\r\n\tif (slap >= 10000 || slap < -10000) {\r\n\t\tkcp->ts_flush = kcp->current;\r\n\t\tslap = 0;\r\n\t}\r\n\r\n\tif (slap >= 0) {\r\n\t\tkcp->ts_flush += kcp->interval;\r\n\t\tif (_itimediff(kcp->current, kcp->ts_flush) >= 0) {\r\n\t\t\tkcp->ts_flush = kcp->current + kcp->interval;\r\n\t\t}\r\n\t\tikcp_flush(kcp);\r\n\t}\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// Determine when should you invoke ikcp_update:\r\n// returns when you should invoke ikcp_update in millisec, if there \r\n// is no ikcp_input/_send calling. you can call ikcp_update in that\r\n// time, instead of call update repeatly.\r\n// Important to reduce unnacessary ikcp_update invoking. use it to \r\n// schedule ikcp_update (eg. implementing an epoll-like mechanism, \r\n// or optimize ikcp_update when handling massive kcp connections)\r\n//---------------------------------------------------------------------\r\nIUINT32 ikcp_check(const ikcpcb *kcp, IUINT32 current)\r\n{\r\n\tIUINT32 ts_flush = kcp->ts_flush;\r\n\tIINT32 tm_flush = 0x7fffffff;\r\n\tIINT32 tm_packet = 0x7fffffff;\r\n\tIUINT32 minimal = 0;\r\n\tstruct IQUEUEHEAD *p;\r\n\r\n\tif (kcp->updated == 0) {\r\n\t\treturn current;\r\n\t}\r\n\r\n\tif (_itimediff(current, ts_flush) >= 10000 ||\r\n\t\t_itimediff(current, ts_flush) < -10000) {\r\n\t\tts_flush = current;\r\n\t}\r\n\r\n\tif (_itimediff(current, ts_flush) >= 0) {\r\n\t\treturn current;\r\n\t}\r\n\r\n\ttm_flush = _itimediff(ts_flush, current);\r\n\r\n\tfor (p = kcp->snd_buf.next; p != &kcp->snd_buf; p = p->next) {\r\n\t\tconst IKCPSEG *seg = iqueue_entry(p, const IKCPSEG, node);\r\n\t\tIINT32 diff = _itimediff(seg->resendts, current);\r\n\t\tif (diff <= 0) {\r\n\t\t\treturn current;\r\n\t\t}\r\n\t\tif (diff < tm_packet) tm_packet = diff;\r\n\t}\r\n\r\n\tminimal = (IUINT32)(tm_packet < tm_flush ? tm_packet : tm_flush);\r\n\tif (minimal >= kcp->interval) minimal = kcp->interval;\r\n\r\n\treturn current + minimal;\r\n}\r\n\r\n\r\n\r\nint ikcp_setmtu(ikcpcb *kcp, int mtu)\r\n{\r\n\tchar *buffer;\r\n\tif (mtu < 50 || mtu < (int)IKCP_OVERHEAD) \r\n\t\treturn -1;\r\n\tbuffer = (char*)ikcp_malloc((mtu + IKCP_OVERHEAD) * 3);\r\n\tif (buffer == NULL) \r\n\t\treturn -2;\r\n\tkcp->mtu = mtu;\r\n\tkcp->mss = kcp->mtu - IKCP_OVERHEAD;\r\n\tikcp_free(kcp->buffer);\r\n\tkcp->buffer = buffer;\r\n\treturn 0;\r\n}\r\n\r\nint ikcp_interval(ikcpcb *kcp, int interval)\r\n{\r\n\tif (interval > 5000) interval = 5000;\r\n\telse if (interval < 10) interval = 10;\r\n\tkcp->interval = interval;\r\n\treturn 0;\r\n}\r\n\r\nint ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc)\r\n{\r\n\tif (nodelay >= 0) {\r\n\t\tkcp->nodelay = nodelay;\r\n\t\tif (nodelay) {\r\n\t\t\tkcp->rx_minrto = IKCP_RTO_NDL;\t\r\n\t\t}\t\r\n\t\telse {\r\n\t\t\tkcp->rx_minrto = IKCP_RTO_MIN;\r\n\t\t}\r\n\t}\r\n\tif (interval >= 0) {\r\n\t\tif (interval > 5000) interval = 5000;\r\n\t\telse if (interval < 10) interval = 10;\r\n\t\tkcp->interval = interval;\r\n\t}\r\n\tif (resend >= 0) {\r\n\t\tkcp->fastresend = resend;\r\n\t}\r\n\tif (nc >= 0) {\r\n\t\tkcp->nocwnd = nc;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n\r\nint ikcp_wndsize(ikcpcb *kcp, int sndwnd, int rcvwnd)\r\n{\r\n\tif (kcp) {\r\n\t\tif (sndwnd > 0) {\r\n\t\t\tkcp->snd_wnd = sndwnd;\r\n\t\t}\r\n\t\tif (rcvwnd > 0) {   // must >= max fragment size\r\n\t\t\tkcp->rcv_wnd = _imax_(rcvwnd, IKCP_WND_RCV);\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nint ikcp_waitsnd(const ikcpcb *kcp)\r\n{\r\n\treturn kcp->nsnd_buf + kcp->nsnd_que;\r\n}\r\n\r\n\r\n// read conv\r\nIUINT32 ikcp_getconv(const void *ptr)\r\n{\r\n\tIUINT32 conv;\r\n\tikcp_decode32u((const char*)ptr, &conv);\r\n\treturn conv;\r\n}\r\n\r\n\r\n"
        },
        {
          "name": "ikcp.h",
          "type": "blob",
          "size": 12.287109375,
          "content": "//=====================================================================\r\n//\r\n// KCP - A Better ARQ Protocol Implementation\r\n// skywind3000 (at) gmail.com, 2010-2011\r\n//  \r\n// Features:\r\n// + Average RTT reduce 30% - 40% vs traditional ARQ like tcp.\r\n// + Maximum RTT reduce three times vs tcp.\r\n// + Lightweight, distributed as a single source file.\r\n//\r\n//=====================================================================\r\n#ifndef __IKCP_H__\r\n#define __IKCP_H__\r\n\r\n#include <stddef.h>\r\n#include <stdlib.h>\r\n#include <assert.h>\r\n\r\n\r\n//=====================================================================\r\n// 32BIT INTEGER DEFINITION \r\n//=====================================================================\r\n#ifndef __INTEGER_32_BITS__\r\n#define __INTEGER_32_BITS__\r\n#if defined(_WIN64) || defined(WIN64) || defined(__amd64__) || \\\r\n\tdefined(__x86_64) || defined(__x86_64__) || defined(_M_IA64) || \\\r\n\tdefined(_M_AMD64)\r\n\ttypedef unsigned int ISTDUINT32;\r\n\ttypedef int ISTDINT32;\r\n#elif defined(_WIN32) || defined(WIN32) || defined(__i386__) || \\\r\n\tdefined(__i386) || defined(_M_X86)\r\n\ttypedef unsigned long ISTDUINT32;\r\n\ttypedef long ISTDINT32;\r\n#elif defined(__MACOS__)\r\n\ttypedef UInt32 ISTDUINT32;\r\n\ttypedef SInt32 ISTDINT32;\r\n#elif defined(__APPLE__) && defined(__MACH__)\r\n\t#include <sys/types.h>\r\n\ttypedef u_int32_t ISTDUINT32;\r\n\ttypedef int32_t ISTDINT32;\r\n#elif defined(__BEOS__)\r\n\t#include <sys/inttypes.h>\r\n\ttypedef u_int32_t ISTDUINT32;\r\n\ttypedef int32_t ISTDINT32;\r\n#elif (defined(_MSC_VER) || defined(__BORLANDC__)) && (!defined(__MSDOS__))\r\n\ttypedef unsigned __int32 ISTDUINT32;\r\n\ttypedef __int32 ISTDINT32;\r\n#elif defined(__GNUC__)\r\n\t#include <stdint.h>\r\n\ttypedef uint32_t ISTDUINT32;\r\n\ttypedef int32_t ISTDINT32;\r\n#else \r\n\ttypedef unsigned long ISTDUINT32; \r\n\ttypedef long ISTDINT32;\r\n#endif\r\n#endif\r\n\r\n\r\n//=====================================================================\r\n// Integer Definition\r\n//=====================================================================\r\n#ifndef __IINT8_DEFINED\r\n#define __IINT8_DEFINED\r\ntypedef char IINT8;\r\n#endif\r\n\r\n#ifndef __IUINT8_DEFINED\r\n#define __IUINT8_DEFINED\r\ntypedef unsigned char IUINT8;\r\n#endif\r\n\r\n#ifndef __IUINT16_DEFINED\r\n#define __IUINT16_DEFINED\r\ntypedef unsigned short IUINT16;\r\n#endif\r\n\r\n#ifndef __IINT16_DEFINED\r\n#define __IINT16_DEFINED\r\ntypedef short IINT16;\r\n#endif\r\n\r\n#ifndef __IINT32_DEFINED\r\n#define __IINT32_DEFINED\r\ntypedef ISTDINT32 IINT32;\r\n#endif\r\n\r\n#ifndef __IUINT32_DEFINED\r\n#define __IUINT32_DEFINED\r\ntypedef ISTDUINT32 IUINT32;\r\n#endif\r\n\r\n#ifndef __IINT64_DEFINED\r\n#define __IINT64_DEFINED\r\n#if defined(_MSC_VER) || defined(__BORLANDC__)\r\ntypedef __int64 IINT64;\r\n#else\r\ntypedef long long IINT64;\r\n#endif\r\n#endif\r\n\r\n#ifndef __IUINT64_DEFINED\r\n#define __IUINT64_DEFINED\r\n#if defined(_MSC_VER) || defined(__BORLANDC__)\r\ntypedef unsigned __int64 IUINT64;\r\n#else\r\ntypedef unsigned long long IUINT64;\r\n#endif\r\n#endif\r\n\r\n#ifndef INLINE\r\n#if defined(__GNUC__)\r\n\r\n#if (__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 1))\r\n#define INLINE         __inline__ __attribute__((always_inline))\r\n#else\r\n#define INLINE         __inline__\r\n#endif\r\n\r\n#elif (defined(_MSC_VER) || defined(__BORLANDC__) || defined(__WATCOMC__))\r\n#define INLINE __inline\r\n#else\r\n#define INLINE \r\n#endif\r\n#endif\r\n\r\n#if (!defined(__cplusplus)) && (!defined(inline))\r\n#define inline INLINE\r\n#endif\r\n\r\n\r\n//=====================================================================\r\n// QUEUE DEFINITION                                                  \r\n//=====================================================================\r\n#ifndef __IQUEUE_DEF__\r\n#define __IQUEUE_DEF__\r\n\r\nstruct IQUEUEHEAD {\r\n\tstruct IQUEUEHEAD *next, *prev;\r\n};\r\n\r\ntypedef struct IQUEUEHEAD iqueue_head;\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// queue init                                                         \r\n//---------------------------------------------------------------------\r\n#define IQUEUE_HEAD_INIT(name) { &(name), &(name) }\r\n#define IQUEUE_HEAD(name) \\\r\n\tstruct IQUEUEHEAD name = IQUEUE_HEAD_INIT(name)\r\n\r\n#define IQUEUE_INIT(ptr) ( \\\r\n\t(ptr)->next = (ptr), (ptr)->prev = (ptr))\r\n\r\n#define IOFFSETOF(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\r\n\r\n#define ICONTAINEROF(ptr, type, member) ( \\\r\n\t\t(type*)( ((char*)((type*)ptr)) - IOFFSETOF(type, member)) )\r\n\r\n#define IQUEUE_ENTRY(ptr, type, member) ICONTAINEROF(ptr, type, member)\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// queue operation                     \r\n//---------------------------------------------------------------------\r\n#define IQUEUE_ADD(node, head) ( \\\r\n\t(node)->prev = (head), (node)->next = (head)->next, \\\r\n\t(head)->next->prev = (node), (head)->next = (node))\r\n\r\n#define IQUEUE_ADD_TAIL(node, head) ( \\\r\n\t(node)->prev = (head)->prev, (node)->next = (head), \\\r\n\t(head)->prev->next = (node), (head)->prev = (node))\r\n\r\n#define IQUEUE_DEL_BETWEEN(p, n) ((n)->prev = (p), (p)->next = (n))\r\n\r\n#define IQUEUE_DEL(entry) (\\\r\n\t(entry)->next->prev = (entry)->prev, \\\r\n\t(entry)->prev->next = (entry)->next, \\\r\n\t(entry)->next = 0, (entry)->prev = 0)\r\n\r\n#define IQUEUE_DEL_INIT(entry) do { \\\r\n\tIQUEUE_DEL(entry); IQUEUE_INIT(entry); } while (0)\r\n\r\n#define IQUEUE_IS_EMPTY(entry) ((entry) == (entry)->next)\r\n\r\n#define iqueue_init\t\tIQUEUE_INIT\r\n#define iqueue_entry\tIQUEUE_ENTRY\r\n#define iqueue_add\t\tIQUEUE_ADD\r\n#define iqueue_add_tail\tIQUEUE_ADD_TAIL\r\n#define iqueue_del\t\tIQUEUE_DEL\r\n#define iqueue_del_init\tIQUEUE_DEL_INIT\r\n#define iqueue_is_empty IQUEUE_IS_EMPTY\r\n\r\n#define IQUEUE_FOREACH(iterator, head, TYPE, MEMBER) \\\r\n\tfor ((iterator) = iqueue_entry((head)->next, TYPE, MEMBER); \\\r\n\t\t&((iterator)->MEMBER) != (head); \\\r\n\t\t(iterator) = iqueue_entry((iterator)->MEMBER.next, TYPE, MEMBER))\r\n\r\n#define iqueue_foreach(iterator, head, TYPE, MEMBER) \\\r\n\tIQUEUE_FOREACH(iterator, head, TYPE, MEMBER)\r\n\r\n#define iqueue_foreach_entry(pos, head) \\\r\n\tfor( (pos) = (head)->next; (pos) != (head) ; (pos) = (pos)->next )\r\n\t\r\n\r\n#define __iqueue_splice(list, head) do {\t\\\r\n\t\tiqueue_head *first = (list)->next, *last = (list)->prev; \\\r\n\t\tiqueue_head *at = (head)->next; \\\r\n\t\t(first)->prev = (head), (head)->next = (first);\t\t\\\r\n\t\t(last)->next = (at), (at)->prev = (last); }\twhile (0)\r\n\r\n#define iqueue_splice(list, head) do { \\\r\n\tif (!iqueue_is_empty(list)) __iqueue_splice(list, head); } while (0)\r\n\r\n#define iqueue_splice_init(list, head) do {\t\\\r\n\tiqueue_splice(list, head);\tiqueue_init(list); } while (0)\r\n\r\n\r\n#ifdef _MSC_VER\r\n#pragma warning(disable:4311)\r\n#pragma warning(disable:4312)\r\n#pragma warning(disable:4996)\r\n#endif\r\n\r\n#endif\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// BYTE ORDER & ALIGNMENT\r\n//---------------------------------------------------------------------\r\n#ifndef IWORDS_BIG_ENDIAN\r\n    #ifdef _BIG_ENDIAN_\r\n        #if _BIG_ENDIAN_\r\n            #define IWORDS_BIG_ENDIAN 1\r\n        #endif\r\n    #endif\r\n    #ifndef IWORDS_BIG_ENDIAN\r\n        #if defined(__hppa__) || \\\r\n            defined(__m68k__) || defined(mc68000) || defined(_M_M68K) || \\\r\n            (defined(__MIPS__) && defined(__MIPSEB__)) || \\\r\n            defined(__ppc__) || defined(__POWERPC__) || defined(_M_PPC) || \\\r\n            defined(__sparc__) || defined(__powerpc__) || \\\r\n            defined(__mc68000__) || defined(__s390x__) || defined(__s390__)\r\n            #define IWORDS_BIG_ENDIAN 1\r\n        #endif\r\n    #endif\r\n    #ifndef IWORDS_BIG_ENDIAN\r\n        #define IWORDS_BIG_ENDIAN  0\r\n    #endif\r\n#endif\r\n\r\n#ifndef IWORDS_MUST_ALIGN\r\n\t#if defined(__i386__) || defined(__i386) || defined(_i386_)\r\n\t\t#define IWORDS_MUST_ALIGN 0\r\n\t#elif defined(_M_IX86) || defined(_X86_) || defined(__x86_64__)\r\n\t\t#define IWORDS_MUST_ALIGN 0\r\n\t#elif defined(__amd64) || defined(__amd64__)\r\n\t\t#define IWORDS_MUST_ALIGN 0\r\n\t#else\r\n\t\t#define IWORDS_MUST_ALIGN 1\r\n\t#endif\r\n#endif\r\n\r\n\r\n//=====================================================================\r\n// SEGMENT\r\n//=====================================================================\r\nstruct IKCPSEG\r\n{\r\n\tstruct IQUEUEHEAD node;\r\n\tIUINT32 conv;\r\n\tIUINT32 cmd;\r\n\tIUINT32 frg;\r\n\tIUINT32 wnd;\r\n\tIUINT32 ts;\r\n\tIUINT32 sn;\r\n\tIUINT32 una;\r\n\tIUINT32 len;\r\n\tIUINT32 resendts;\r\n\tIUINT32 rto;\r\n\tIUINT32 fastack;\r\n\tIUINT32 xmit;\r\n\tchar data[1];\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\n// IKCPCB\r\n//---------------------------------------------------------------------\r\nstruct IKCPCB\r\n{\r\n\tIUINT32 conv, mtu, mss, state;\r\n\tIUINT32 snd_una, snd_nxt, rcv_nxt;\r\n\tIUINT32 ts_recent, ts_lastack, ssthresh;\r\n\tIINT32 rx_rttval, rx_srtt, rx_rto, rx_minrto;\r\n\tIUINT32 snd_wnd, rcv_wnd, rmt_wnd, cwnd, probe;\r\n\tIUINT32 current, interval, ts_flush, xmit;\r\n\tIUINT32 nrcv_buf, nsnd_buf;\r\n\tIUINT32 nrcv_que, nsnd_que;\r\n\tIUINT32 nodelay, updated;\r\n\tIUINT32 ts_probe, probe_wait;\r\n\tIUINT32 dead_link, incr;\r\n\tstruct IQUEUEHEAD snd_queue;\r\n\tstruct IQUEUEHEAD rcv_queue;\r\n\tstruct IQUEUEHEAD snd_buf;\r\n\tstruct IQUEUEHEAD rcv_buf;\r\n\tIUINT32 *acklist;\r\n\tIUINT32 ackcount;\r\n\tIUINT32 ackblock;\r\n\tvoid *user;\r\n\tchar *buffer;\r\n\tint fastresend;\r\n\tint fastlimit;\r\n\tint nocwnd, stream;\r\n\tint logmask;\r\n\tint (*output)(const char *buf, int len, struct IKCPCB *kcp, void *user);\r\n\tvoid (*writelog)(const char *log, struct IKCPCB *kcp, void *user);\r\n};\r\n\r\n\r\ntypedef struct IKCPCB ikcpcb;\r\n\r\n#define IKCP_LOG_OUTPUT\t\t\t1\r\n#define IKCP_LOG_INPUT\t\t\t2\r\n#define IKCP_LOG_SEND\t\t\t4\r\n#define IKCP_LOG_RECV\t\t\t8\r\n#define IKCP_LOG_IN_DATA\t\t16\r\n#define IKCP_LOG_IN_ACK\t\t\t32\r\n#define IKCP_LOG_IN_PROBE\t\t64\r\n#define IKCP_LOG_IN_WINS\t\t128\r\n#define IKCP_LOG_OUT_DATA\t\t256\r\n#define IKCP_LOG_OUT_ACK\t\t512\r\n#define IKCP_LOG_OUT_PROBE\t\t1024\r\n#define IKCP_LOG_OUT_WINS\t\t2048\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n//---------------------------------------------------------------------\r\n// interface\r\n//---------------------------------------------------------------------\r\n\r\n// create a new kcp control object, 'conv' must equal in two endpoint\r\n// from the same connection. 'user' will be passed to the output callback\r\n// output callback can be setup like this: 'kcp->output = my_udp_output'\r\nikcpcb* ikcp_create(IUINT32 conv, void *user);\r\n\r\n// release kcp control object\r\nvoid ikcp_release(ikcpcb *kcp);\r\n\r\n// set output callback, which will be invoked by kcp\r\nvoid ikcp_setoutput(ikcpcb *kcp, int (*output)(const char *buf, int len, \r\n\tikcpcb *kcp, void *user));\r\n\r\n// user/upper level recv: returns size, returns below zero for EAGAIN\r\nint ikcp_recv(ikcpcb *kcp, char *buffer, int len);\r\n\r\n// user/upper level send, returns below zero for error\r\nint ikcp_send(ikcpcb *kcp, const char *buffer, int len);\r\n\r\n// update state (call it repeatedly, every 10ms-100ms), or you can ask \r\n// ikcp_check when to call it again (without ikcp_input/_send calling).\r\n// 'current' - current timestamp in millisec. \r\nvoid ikcp_update(ikcpcb *kcp, IUINT32 current);\r\n\r\n// Determine when should you invoke ikcp_update:\r\n// returns when you should invoke ikcp_update in millisec, if there \r\n// is no ikcp_input/_send calling. you can call ikcp_update in that\r\n// time, instead of call update repeatly.\r\n// Important to reduce unnacessary ikcp_update invoking. use it to \r\n// schedule ikcp_update (eg. implementing an epoll-like mechanism, \r\n// or optimize ikcp_update when handling massive kcp connections)\r\nIUINT32 ikcp_check(const ikcpcb *kcp, IUINT32 current);\r\n\r\n// when you received a low level packet (eg. UDP packet), call it\r\nint ikcp_input(ikcpcb *kcp, const char *data, long size);\r\n\r\n// flush pending data\r\nvoid ikcp_flush(ikcpcb *kcp);\r\n\r\n// check the size of next message in the recv queue\r\nint ikcp_peeksize(const ikcpcb *kcp);\r\n\r\n// change MTU size, default is 1400\r\nint ikcp_setmtu(ikcpcb *kcp, int mtu);\r\n\r\n// set maximum window size: sndwnd=32, rcvwnd=32 by default\r\nint ikcp_wndsize(ikcpcb *kcp, int sndwnd, int rcvwnd);\r\n\r\n// get how many packet is waiting to be sent\r\nint ikcp_waitsnd(const ikcpcb *kcp);\r\n\r\n// fastest: ikcp_nodelay(kcp, 1, 20, 2, 1)\r\n// nodelay: 0:disable(default), 1:enable\r\n// interval: internal update timer interval in millisec, default is 100ms \r\n// resend: 0:disable fast resend(default), 1:enable fast resend\r\n// nc: 0:normal congestion control(default), 1:disable congestion control\r\nint ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc);\r\n\r\n\r\nvoid ikcp_log(ikcpcb *kcp, int mask, const char *fmt, ...);\r\n\r\n// setup allocator\r\nvoid ikcp_allocator(void* (*new_malloc)(size_t), void (*new_free)(void*));\r\n\r\n// read conv\r\nIUINT32 ikcp_getconv(const void *ptr);\r\n\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif\r\n\r\n\r\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "kcp.svg",
          "type": "blob",
          "size": 0.7177734375,
          "content": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"88\" height=\"20\"><linearGradient id=\"b\" x2=\"0\" y2=\"100%\"><stop offset=\"0\" stop-color=\"#bbb\" stop-opacity=\".1\"/><stop offset=\"1\" stop-opacity=\".1\"/></linearGradient><mask id=\"a\"><rect width=\"88\" height=\"20\" rx=\"3\" fill=\"#fff\"/></mask><g mask=\"url(#a)\"><path fill=\"#555\" d=\"M0 0h31v20H0z\"/><path fill=\"#007ec6\" d=\"M31 0h57v20H31z\"/><path fill=\"url(#b)\" d=\"M0 0h88v20H0z\"/></g><g fill=\"#fff\" text-anchor=\"middle\" font-family=\"DejaVu Sans,Verdana,Geneva,sans-serif\" font-size=\"11\"><text x=\"15.5\" y=\"15\" fill=\"#010101\" fill-opacity=\".3\">KCP</text><text x=\"15.5\" y=\"14\">KCP</text><text x=\"58.5\" y=\"15\" fill=\"#010101\" fill-opacity=\".3\">Powered</text><text x=\"58.5\" y=\"14\">Powered</text></g></svg>"
        },
        {
          "name": "protocol.txt",
          "type": "blob",
          "size": 2.064453125,
          "content": "KCP PROTOCOL SPECIFICATION\r\n\r\n\r\n1. Packet (aka. segment) Structure\r\n\r\nKCP has only one kind of segment: both the data and control messages are \r\nencoded into the same structure and share the same header.\r\n\r\nThe KCP packet (aka. segment) structure is as following:\r\n\r\n0               4   5   6       8 (BYTE)\r\n+---------------+---+---+-------+\r\n|     conv      |cmd|frg|  wnd  |\r\n+---------------+---+---+-------+   8\r\n|     ts        |     sn        |\r\n+---------------+---------------+  16\r\n|     una       |     len       |\r\n+---------------+---------------+  24\r\n|                               |\r\n|        DATA (optional)        |\r\n|                               |\r\n+-------------------------------+\r\n\r\n\r\n- conv: conversation id (32 bits integer)\r\n\r\nThe conversation id is used to identify each connection, which will not change\r\nduring the connection life-time.\r\n\r\nIt is represented by a 32 bits integer which is given at the moment the KCP\r\ncontrol block (aka. struct ikcpcb, or kcp object) has been created. Each\r\npacket sent out will carry the conversation id in the first 4 bytes and a\r\npacket from remote endpoint will not be accepted if it has a different\r\nconversation id.\r\n\r\nThe value can be any random number, but in practice, both side between a\r\nconnection will have many KCP objects (or control block) storing in the\r\ncontainers like a map or an array. A index is used as the key to look up one\r\nKCP object from the container. \r\n\r\nSo, the higher 16 bits of conversation id can be used as caller's index while\r\nthe lower 16 bits can be used as callee's index. KCP will not handle\r\nhandshake, and the index in both side can be decided and exchanged after \r\nconnection establish.\r\n\r\nWhen you receive and accept a remote packet, the local index can be extracted\r\nfrom the conversation id and the kcp object which is in charge of this\r\nconnection can be find out from your map or array.\r\n\r\n\r\n- cmd: command\r\n\r\n- frg: fragment count\r\n\r\n- wnd: window size\r\n\r\n- ts: timestamp\r\n\r\n- sn: serial number\r\n\r\n- una: un-acknowledged serial number\r\n\r\n\r\n# vim: set ts=4 sw=4 tw=0 noet cc=78 wrap textwidth=78 :\r\n\r\n"
        },
        {
          "name": "test.cpp",
          "type": "blob",
          "size": 4.5947265625,
          "content": "//=====================================================================\r\n//\r\n// test.cpp - kcp 测试用例\r\n//\r\n// 说明：\r\n// gcc test.cpp -o test -lstdc++\r\n//\r\n//=====================================================================\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#include \"test.h\"\r\n#include \"ikcp.c\"\r\n\r\n\r\n// 模拟网络\r\nLatencySimulator *vnet;\r\n\r\n// 模拟网络：模拟发送一个 udp包\r\nint udp_output(const char *buf, int len, ikcpcb *kcp, void *user)\r\n{\r\n\tunion { int id; void *ptr; } parameter;\r\n\tparameter.ptr = user;\r\n\tvnet->send(parameter.id, buf, len);\r\n\treturn 0;\r\n}\r\n\r\n// 测试用例\r\nvoid test(int mode)\r\n{\r\n\t// 创建模拟网络：丢包率10%，Rtt 60ms~125ms\r\n\tvnet = new LatencySimulator(10, 60, 125);\r\n\r\n\t// 创建两个端点的 kcp对象，第一个参数 conv是会话编号，同一个会话需要相同\r\n\t// 最后一个是 user参数，用来传递标识\r\n\tikcpcb *kcp1 = ikcp_create(0x11223344, (void*)0);\r\n\tikcpcb *kcp2 = ikcp_create(0x11223344, (void*)1);\r\n\r\n\t// 设置kcp的下层输出，这里为 udp_output，模拟udp网络输出函数\r\n\tkcp1->output = udp_output;\r\n\tkcp2->output = udp_output;\r\n\r\n\tIUINT32 current = iclock();\r\n\tIUINT32 slap = current + 20;\r\n\tIUINT32 index = 0;\r\n\tIUINT32 next = 0;\r\n\tIINT64 sumrtt = 0;\r\n\tint count = 0;\r\n\tint maxrtt = 0;\r\n\r\n\t// 配置窗口大小：平均延迟200ms，每20ms发送一个包，\r\n\t// 而考虑到丢包重发，设置最大收发窗口为128\r\n\tikcp_wndsize(kcp1, 128, 128);\r\n\tikcp_wndsize(kcp2, 128, 128);\r\n\r\n\t// 判断测试用例的模式\r\n\tif (mode == 0) {\r\n\t\t// 默认模式\r\n\t\tikcp_nodelay(kcp1, 0, 10, 0, 0);\r\n\t\tikcp_nodelay(kcp2, 0, 10, 0, 0);\r\n\t}\r\n\telse if (mode == 1) {\r\n\t\t// 普通模式，关闭流控等\r\n\t\tikcp_nodelay(kcp1, 0, 10, 0, 1);\r\n\t\tikcp_nodelay(kcp2, 0, 10, 0, 1);\r\n\t}\telse {\r\n\t\t// 启动快速模式\r\n\t\t// 第二个参数 nodelay-启用以后若干常规加速将启动\r\n\t\t// 第三个参数 interval为内部处理时钟，默认设置为 10ms\r\n\t\t// 第四个参数 resend为快速重传指标，设置为2\r\n\t\t// 第五个参数 为是否禁用常规流控，这里禁止\r\n\t\tikcp_nodelay(kcp1, 2, 10, 2, 1);\r\n\t\tikcp_nodelay(kcp2, 2, 10, 2, 1);\r\n\t\tkcp1->rx_minrto = 10;\r\n\t\tkcp1->fastresend = 1;\r\n\t}\r\n\r\n\r\n\tchar buffer[2000];\r\n\tint hr;\r\n\r\n\tIUINT32 ts1 = iclock();\r\n\r\n\twhile (1) {\r\n\t\tisleep(1);\r\n\t\tcurrent = iclock();\r\n\t\tikcp_update(kcp1, iclock());\r\n\t\tikcp_update(kcp2, iclock());\r\n\r\n\t\t// 每隔 20ms，kcp1发送数据\r\n\t\tfor (; current >= slap; slap += 20) {\r\n\t\t\t((IUINT32*)buffer)[0] = index++;\r\n\t\t\t((IUINT32*)buffer)[1] = current;\r\n\r\n\t\t\t// 发送上层协议包\r\n\t\t\tikcp_send(kcp1, buffer, 8);\r\n\t\t}\r\n\r\n\t\t// 处理虚拟网络：检测是否有udp包从p1->p2\r\n\t\twhile (1) {\r\n\t\t\thr = vnet->recv(1, buffer, 2000);\r\n\t\t\tif (hr < 0) break;\r\n\t\t\t// 如果 p2收到udp，则作为下层协议输入到kcp2\r\n\t\t\tikcp_input(kcp2, buffer, hr);\r\n\t\t}\r\n\r\n\t\t// 处理虚拟网络：检测是否有udp包从p2->p1\r\n\t\twhile (1) {\r\n\t\t\thr = vnet->recv(0, buffer, 2000);\r\n\t\t\tif (hr < 0) break;\r\n\t\t\t// 如果 p1收到udp，则作为下层协议输入到kcp1\r\n\t\t\tikcp_input(kcp1, buffer, hr);\r\n\t\t}\r\n\r\n\t\t// kcp2接收到任何包都返回回去\r\n\t\twhile (1) {\r\n\t\t\thr = ikcp_recv(kcp2, buffer, 10);\r\n\t\t\t// 没有收到包就退出\r\n\t\t\tif (hr < 0) break;\r\n\t\t\t// 如果收到包就回射\r\n\t\t\tikcp_send(kcp2, buffer, hr);\r\n\t\t}\r\n\r\n\t\t// kcp1收到kcp2的回射数据\r\n\t\twhile (1) {\r\n\t\t\thr = ikcp_recv(kcp1, buffer, 10);\r\n\t\t\t// 没有收到包就退出\r\n\t\t\tif (hr < 0) break;\r\n\t\t\tIUINT32 sn = *(IUINT32*)(buffer + 0);\r\n\t\t\tIUINT32 ts = *(IUINT32*)(buffer + 4);\r\n\t\t\tIUINT32 rtt = current - ts;\r\n\t\t\t\r\n\t\t\tif (sn != next) {\r\n\t\t\t\t// 如果收到的包不连续\r\n\t\t\t\tprintf(\"ERROR sn %d<->%d\\n\", (int)count, (int)next);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tnext++;\r\n\t\t\tsumrtt += rtt;\r\n\t\t\tcount++;\r\n\t\t\tif (rtt > (IUINT32)maxrtt) maxrtt = rtt;\r\n\r\n\t\t\tprintf(\"[RECV] mode=%d sn=%d rtt=%d\\n\", mode, (int)sn, (int)rtt);\r\n\t\t}\r\n\t\tif (next > 1000) break;\r\n\t}\r\n\r\n\tts1 = iclock() - ts1;\r\n\r\n\tikcp_release(kcp1);\r\n\tikcp_release(kcp2);\r\n\r\n\tconst char *names[3] = { \"default\", \"normal\", \"fast\" };\r\n\tprintf(\"%s mode result (%dms):\\n\", names[mode], (int)ts1);\r\n\tprintf(\"avgrtt=%d maxrtt=%d tx=%d\\n\", (int)(sumrtt / count), (int)maxrtt, (int)vnet->tx1);\r\n\tprintf(\"press enter to next ...\\n\");\r\n\tchar ch; scanf(\"%c\", &ch);\r\n}\r\n\r\nint main()\r\n{\r\n\ttest(0);\t// 默认模式，类似 TCP：正常模式，无快速重传，常规流控\r\n\ttest(1);\t// 普通模式，关闭流控等\r\n\ttest(2);\t// 快速模式，所有开关都打开，且关闭流控\r\n\treturn 0;\r\n}\r\n\r\n/*\r\ndefault mode result (20917ms):\r\navgrtt=740 maxrtt=1507\r\n\r\nnormal mode result (20131ms):\r\navgrtt=156 maxrtt=571\r\n\r\nfast mode result (20207ms):\r\navgrtt=138 maxrtt=392\r\n*/\r\n\r\n\r\n"
        },
        {
          "name": "test.h",
          "type": "blob",
          "size": 5.17578125,
          "content": "#ifndef __TEST_H__\r\n#define __TEST_H__\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n#include <ctype.h>\r\n#include <string.h>\r\n\r\n#include \"ikcp.h\"\r\n\r\n#if defined(WIN32) || defined(_WIN32) || defined(WIN64) || defined(_WIN64)\r\n#include <windows.h>\r\n#elif !defined(__unix)\r\n#define __unix\r\n#endif\r\n\r\n#ifdef __unix\r\n#include <unistd.h>\r\n#include <sys/time.h>\r\n#include <sys/wait.h>\r\n#include <sys/types.h>\r\n#endif\r\n\r\n/* get system time */\r\nstatic inline void itimeofday(long *sec, long *usec)\r\n{\r\n\t#if defined(__unix)\r\n\tstruct timeval time;\r\n\tgettimeofday(&time, NULL);\r\n\tif (sec) *sec = time.tv_sec;\r\n\tif (usec) *usec = time.tv_usec;\r\n\t#else\r\n\tstatic long mode = 0, addsec = 0;\r\n\tBOOL retval;\r\n\tstatic IINT64 freq = 1;\r\n\tIINT64 qpc;\r\n\tif (mode == 0) {\r\n\t\tretval = QueryPerformanceFrequency((LARGE_INTEGER*)&freq);\r\n\t\tfreq = (freq == 0)? 1 : freq;\r\n\t\tretval = QueryPerformanceCounter((LARGE_INTEGER*)&qpc);\r\n\t\taddsec = (long)time(NULL);\r\n\t\taddsec = addsec - (long)((qpc / freq) & 0x7fffffff);\r\n\t\tmode = 1;\r\n\t}\r\n\tretval = QueryPerformanceCounter((LARGE_INTEGER*)&qpc);\r\n\tretval = retval * 2;\r\n\tif (sec) *sec = (long)(qpc / freq) + addsec;\r\n\tif (usec) *usec = (long)((qpc % freq) * 1000000 / freq);\r\n\t#endif\r\n}\r\n\r\n/* get clock in millisecond 64 */\r\nstatic inline IINT64 iclock64(void)\r\n{\r\n\tlong s, u;\r\n\tIINT64 value;\r\n\titimeofday(&s, &u);\r\n\tvalue = ((IINT64)s) * 1000 + (u / 1000);\r\n\treturn value;\r\n}\r\n\r\nstatic inline IUINT32 iclock()\r\n{\r\n\treturn (IUINT32)(iclock64() & 0xfffffffful);\r\n}\r\n\r\n/* sleep in millisecond */\r\nstatic inline void isleep(unsigned long millisecond)\r\n{\r\n\t#ifdef __unix \t/* usleep( time * 1000 ); */\r\n\tstruct timespec ts;\r\n\tts.tv_sec = (time_t)(millisecond / 1000);\r\n\tts.tv_nsec = (long)((millisecond % 1000) * 1000000);\r\n\t/*nanosleep(&ts, NULL);*/\r\n\tusleep((millisecond << 10) - (millisecond << 4) - (millisecond << 3));\r\n\t#elif defined(_WIN32)\r\n\tSleep(millisecond);\r\n\t#endif\r\n}\r\n\r\n#ifdef __cplusplus\r\n#include <list>\r\n#include <vector>\r\n\r\n// 带延迟的数据包\r\nclass DelayPacket\r\n{\r\npublic:\r\n\tvirtual ~DelayPacket() {\r\n\t\tif (_ptr) delete[] _ptr;\r\n\t\t_ptr = NULL;\r\n\t}\r\n\r\n\tDelayPacket(int size, const void *src = NULL) {\r\n\t\t_ptr = new unsigned char[size];\r\n\t\t_size = size;\r\n\t\tif (src) {\r\n\t\t\tmemcpy(_ptr, src, size);\r\n\t\t}\r\n\t}\r\n\r\n\tunsigned char* ptr() { return _ptr; }\r\n\tconst unsigned char* ptr() const { return _ptr; }\r\n\r\n\tint size() const { return _size; }\r\n\tIUINT32 ts() const { return _ts; }\r\n\tvoid setts(IUINT32 ts) { _ts = ts; }\r\n\r\nprotected:\r\n\tunsigned char *_ptr;\r\n\tint _size;\r\n\tIUINT32 _ts;\r\n};\r\n\r\n// 均匀分布的随机数\r\nclass Random\r\n{\r\npublic:\r\n\tRandom(int size) {\r\n\t\tthis->size = 0;\r\n\t\tseeds.resize(size);\r\n\t}\r\n\r\n\tint random() {\r\n\t\tint x, i;\r\n\t\tif (seeds.size() == 0) return 0;\r\n\t\tif (size == 0) { \r\n\t\t\tfor (i = 0; i < (int)seeds.size(); i++) {\r\n\t\t\t\tseeds[i] = i;\r\n\t\t\t}\r\n\t\t\tsize = (int)seeds.size();\r\n\t\t}\r\n\t\ti = rand() % size;\r\n\t\tx = seeds[i];\r\n\t\tseeds[i] = seeds[--size];\r\n\t\treturn x;\r\n\t}\r\n\r\nprotected:\r\n\tint size;\r\n\tstd::vector<int> seeds;\r\n};\r\n\r\n// 网络延迟模拟器\r\nclass LatencySimulator\r\n{\r\npublic:\r\n\r\n\tvirtual ~LatencySimulator() {\r\n\t\tclear();\r\n\t}\r\n\r\n\t// lostrate: 往返一周丢包率的百分比，默认 10%\r\n\t// rttmin：rtt最小值，默认 60\r\n\t// rttmax：rtt最大值，默认 125\r\n\tLatencySimulator(int lostrate = 10, int rttmin = 60, int rttmax = 125, int nmax = 1000): \r\n\t\tr12(100), r21(100) {\r\n\t\tcurrent = iclock();\t\t\r\n\t\tthis->lostrate = lostrate / 2;\t// 上面数据是往返丢包率，单程除以2\r\n\t\tthis->rttmin = rttmin / 2;\r\n\t\tthis->rttmax = rttmax / 2;\r\n\t\tthis->nmax = nmax;\r\n\t\ttx1 = tx2 = 0;\r\n\t}\r\n\r\n\t// 清除数据\r\n\tvoid clear() {\r\n\t\tDelayTunnel::iterator it;\r\n\t\tfor (it = p12.begin(); it != p12.end(); it++) {\r\n\t\t\tdelete *it;\r\n\t\t}\r\n\t\tfor (it = p21.begin(); it != p21.end(); it++) {\r\n\t\t\tdelete *it;\r\n\t\t}\r\n\t\tp12.clear();\r\n\t\tp21.clear();\r\n\t}\r\n\r\n\t// 发送数据\r\n\t// peer - 端点0/1，从0发送，从1接收；从1发送从0接收\r\n\tvoid send(int peer, const void *data, int size) {\r\n\t\tif (peer == 0) {\r\n\t\t\ttx1++;\r\n\t\t\tif (r12.random() < lostrate) return;\r\n\t\t\tif ((int)p12.size() >= nmax) return;\r\n\t\t}\telse {\r\n\t\t\ttx2++;\r\n\t\t\tif (r21.random() < lostrate) return;\r\n\t\t\tif ((int)p21.size() >= nmax) return;\r\n\t\t}\r\n\t\tDelayPacket *pkt = new DelayPacket(size, data);\r\n\t\tcurrent = iclock();\r\n\t\tIUINT32 delay = rttmin;\r\n\t\tif (rttmax > rttmin) delay += rand() % (rttmax - rttmin);\r\n\t\tpkt->setts(current + delay);\r\n\t\tif (peer == 0) {\r\n\t\t\tp12.push_back(pkt);\r\n\t\t}\telse {\r\n\t\t\tp21.push_back(pkt);\r\n\t\t}\r\n\t}\r\n\r\n\t// 接收数据\r\n\tint recv(int peer, void *data, int maxsize) {\r\n\t\tDelayTunnel::iterator it;\r\n\t\tif (peer == 0) {\r\n\t\t\tit = p21.begin();\r\n\t\t\tif (p21.size() == 0) return -1;\r\n\t\t}\telse {\r\n\t\t\tit = p12.begin();\r\n\t\t\tif (p12.size() == 0) return -1;\r\n\t\t}\r\n\t\tDelayPacket *pkt = *it;\r\n\t\tcurrent = iclock();\r\n\t\tif (current < pkt->ts()) return -2;\r\n\t\tif (maxsize < pkt->size()) return -3;\r\n\t\tif (peer == 0) {\r\n\t\t\tp21.erase(it);\r\n\t\t}\telse {\r\n\t\t\tp12.erase(it);\r\n\t\t}\r\n\t\tmaxsize = pkt->size();\r\n\t\tmemcpy(data, pkt->ptr(), maxsize);\r\n\t\tdelete pkt;\r\n\t\treturn maxsize;\r\n\t}\r\n\r\npublic:\r\n\tint tx1;\r\n\tint tx2;\r\n\r\nprotected:\r\n\tIUINT32 current;\r\n\tint lostrate;\r\n\tint rttmin;\r\n\tint rttmax;\r\n\tint nmax;\r\n\ttypedef std::list<DelayPacket*> DelayTunnel;\r\n\tDelayTunnel p12;\r\n\tDelayTunnel p21;\r\n\tRandom r12;\r\n\tRandom r21;\r\n};\r\n\r\n#endif\r\n\r\n#endif\r\n\r\n\r\n"
        }
      ]
    }
  ]
}