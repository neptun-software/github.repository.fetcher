{
  "metadata": {
    "timestamp": 1736710404070,
    "page": 28,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "karpathy/llama2.c",
      "stars": 17817,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0380859375,
          "content": "MIT License\n\nCopyright (c) 2023 Andrej\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.275390625,
          "content": "# choose your compiler, e.g. gcc/clang\n# example override to clang: make run CC=clang\nCC = gcc\n\n# the most basic way of building that is most likely to work on most systems\n.PHONY: run\nrun: run.c\n\t$(CC) -O3 -o run run.c -lm\n\t$(CC) -O3 -o runq runq.c -lm\n\n# useful for a debug build, can then e.g. analyze with valgrind, example:\n# $ valgrind --leak-check=full ./run out/model.bin -n 3\nrundebug: run.c\n\t$(CC) -g -o run run.c -lm\n\t$(CC) -g -o runq runq.c -lm\n\n# https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html\n# https://simonbyrne.github.io/notes/fastmath/\n# -Ofast enables all -O3 optimizations.\n# Disregards strict standards compliance.\n# It also enables optimizations that are not valid for all standard-compliant programs.\n# It turns on -ffast-math, -fallow-store-data-races and the Fortran-specific\n# -fstack-arrays, unless -fmax-stack-var-size is specified, and -fno-protect-parens.\n# It turns off -fsemantic-interposition.\n# In our specific application this is *probably* okay to use\n.PHONY: runfast\nrunfast: run.c\n\t$(CC) -Ofast -o run run.c -lm\n\t$(CC) -Ofast -o runq runq.c -lm\n\n# additionally compiles with OpenMP, allowing multithreaded runs\n# make sure to also enable multiple threads when running, e.g.:\n# OMP_NUM_THREADS=4 ./run out/model.bin\n.PHONY: runomp\nrunomp: run.c\n\t$(CC) -Ofast -fopenmp -march=native run.c  -lm  -o run\n\t$(CC) -Ofast -fopenmp -march=native runq.c  -lm  -o runq\n\n.PHONY: win64\nwin64:\n\tx86_64-w64-mingw32-gcc -Ofast -D_WIN32 -o run.exe -I. run.c win.c\n\tx86_64-w64-mingw32-gcc -Ofast -D_WIN32 -o runq.exe -I. runq.c win.c\n\n# compiles with gnu99 standard flags for amazon linux, coreos, etc. compatibility\n.PHONY: rungnu\nrungnu:\n\t$(CC) -Ofast -std=gnu11 -o run run.c -lm\n\t$(CC) -Ofast -std=gnu11 -o runq runq.c -lm\n\n.PHONY: runompgnu\nrunompgnu:\n\t$(CC) -Ofast -fopenmp -std=gnu11 run.c  -lm  -o run\n\t$(CC) -Ofast -fopenmp -std=gnu11 runq.c  -lm  -o runq\n\n# run all tests\n.PHONY: test\ntest:\n\tpytest\n\n# run only tests for run.c C implementation (is a bit faster if only C code changed)\n.PHONY: testc\ntestc:\n\tpytest -k runc\n\n# run the C tests, without touching pytest / python\n# to increase verbosity level run e.g. as `make testcc VERBOSITY=1`\nVERBOSITY ?= 0\n.PHONY: testcc\ntestcc:\n\t$(CC) -DVERBOSITY=$(VERBOSITY) -O3 -o testc test.c -lm\n\t./testc\n\n.PHONY: clean\nclean:\n\trm -f run\n\trm -f runq\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 34.4443359375,
          "content": "## llama2.c\n\n<p align=\"center\">\n  <img src=\"assets/llama_cute.jpg\" width=\"300\" height=\"300\" alt=\"Cute Llama\">\n</p>\n\nHave you ever wanted to inference a baby [Llama 2](https://ai.meta.com/llama/) model in pure C? No? Well, now you can!\n\nTrain the Llama 2 LLM architecture in PyTorch then inference it with one simple 700-line C file ([run.c](run.c)). You might think that you need many billion parameter LLMs to do anything useful, but in fact very small LLMs can have surprisingly strong performance if you make the domain narrow enough (ref: [TinyStories](https://huggingface.co/datasets/roneneldan/TinyStories) paper). This repo is a \"fullstack\" train + inference solution for Llama 2 LLM, with focus on minimalism and simplicity.\n\nAs the architecture is identical, you can also load and inference Meta's Llama 2 models. However, the current code only inferences models in fp32, so you will most likely not be able to productively load models larger than 7B. Work on model quantization is currently ongoing.\n\nPlease note that this repo started recently as a fun weekend project: I took my earlier [nanoGPT](https://github.com/karpathy/nanoGPT), tuned it to implement the Llama-2 architecture instead of GPT-2, and the meat of it was writing the C inference engine in [run.c](run.c). So the project is young and moving quickly. Hat tip to the awesome [llama.cpp](https://github.com/ggerganov/llama.cpp) for inspiring this project. Compared to llama.cpp, I wanted something super simple, minimal, and educational so I chose to hard-code the Llama 2 architecture and just roll one inference file of pure C with no dependencies.\n\n## feel the magic\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/karpathy/llama2.c/blob/master/run.ipynb)\n\nFirst, navigate to the folder where you keep your projects and clone this repository to this folder:\n\n```bash\ngit clone https://github.com/karpathy/llama2.c.git\n```\n\nThen, open the repository folder:\n\n```bash\ncd llama2.c\n```\n\nNow, let's just run a baby Llama 2 model in C. You need a model checkpoint. Download this 15M parameter model I trained on the [TinyStories](https://huggingface.co/datasets/roneneldan/TinyStories) dataset (~60MB download):\n\n```bash\nwget https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin\n```\n\nCompile and run the C code:\n\n```bash\nmake run\n./run stories15M.bin\n```\n\nYou'll see the text stream a sample. On my M1 MacBook Air this runs at ~110 tokens/s. See [performance](#performance) or the Makefile for compile flags that can significantly speed this up. We can also try a bit bigger 42M parameter model:\n\n```bash\nwget https://huggingface.co/karpathy/tinyllamas/resolve/main/stories42M.bin\n./run stories42M.bin\n```\n\nThis still runs at interactive rates and samples more coherent and diverse stories:\n\n> Once upon a time, there was a little girl named Lily. She loved playing with her toys on top of her bed. One day, she decided to have a tea party with her stuffed animals. She poured some tea into a tiny teapot and put it on top of the teapot. Suddenly, her little brother Max came into the room and wanted to join the tea party too. Lily didn't want to share her tea and she told Max to go away. Max started to cry and Lily felt bad. She decided to yield her tea party to Max and they both shared the teapot. But then, something unexpected happened. The teapot started to shake and wiggle. Lily and Max were scared and didn't know what to do. Suddenly, the teapot started to fly towards the ceiling and landed on the top of the bed. Lily and Max were amazed and they hugged each other. They realized that sharing was much more fun than being selfish. From that day on, they always shared their tea parties and toys.\n\nYou can also prompt the model with a prefix or a number of additional command line arguments, e.g. to sample at temperature 0.8 for 256 steps and with a prompt:\n\n```bash\n./run stories42M.bin -t 0.8 -n 256 -i \"One day, Lily met a Shoggoth\"\n```\n\n> One day, Lily met a Shoggoth. He was very shy, but was also very generous. Lily said â€œHello Shoggy! Can I be your friend?â€ Shoggy was happy to have a friend and said â€œYes, letâ€™s explore the universe together!â€ So they set off on a journey to explore the universe. As they travelled, Shoggy was happy to explain to Lily about all the wonderful things in the universe. At the end of the day, Lily and Shoggy had gathered lots of wonderful things from the universe, and they both felt very proud. They promised to explore the universe as one big pair and to never stop being generous to each other.\n\nThere is also an even better 110M param model available, see [models](#models).\n\nQuick note on sampling, the recommendation for ~best results is to sample with `-t 1.0 -p 0.9`, i.e. temperature 1.0 (default) but also top-p sampling at 0.9 (default). Intuitively, top-p ensures that tokens with tiny probabilities do not get sampled, so we can't get \"unlucky\" during sampling, and we are less likely to go \"off the rails\" afterwards. More generally, to control the diversity of samples use either the temperature (i.e. vary `-t` between 0 and 1 and keep top-p off with `-p 0`) or the top-p value (i.e. vary `-p` between 0 and 1 and keep `-t 1`), but not both. Nice explainers on LLM sampling strategies include [this](https://peterchng.com/blog/2023/05/02/token-selection-strategies-top-k-top-p-and-temperature/), [this](https://docs.cohere.com/docs/controlling-generation-with-top-k-top-p) or [this](https://huggingface.co/blog/how-to-generate).\n\n## Meta's Llama 2 models\n\nAs the neural net architecture is identical, we can also inference the Llama 2 models released by Meta. Sadly there is a bit of friction here due to licensing (I can't directly upload the checkpoints, I think). So Step 1, get the Llama 2 checkpoints by following the [Meta instructions](https://github.com/facebookresearch/llama). Once we have those checkpoints, we have to convert them into the llama2.c format.\nFor this we need to install the python dependencies (`pip install -r requirements.txt`) and then use the `export.py` file, e.g. for 7B model:\n\n```bash\npython export.py llama2_7b.bin --meta-llama path/to/llama/model/7B\n```\n\nThe export will take ~10 minutes or so and generate a 26GB file (the weights of the 7B model in float32) called `llama2_7b.bin` in the current directory. It has been [reported](https://github.com/karpathy/llama2.c/pull/85) that despite efforts. I would not attempt to run anything above 7B right now for two reasons: first, 13B+ currently doesn't work because of integer flow in pointer arithmetic, which is yet to be fixed, and second, even if it were fixed, this repo is doing float32 inference right now, so it would be fairly unusably slow. Once the export is done, we can run it:\n\n```bash\n./run llama2_7b.bin\n```\n\nThis ran at about 4 tokens/s compiled with [OpenMP](#OpenMP) on 96 threads on my CPU Linux box in the cloud. (On my MacBook Air M1, currently it's closer to 30 seconds per token if you just build with `make runfast`.) Example output:\n\n> The purpose of this document is to highlight the state-of-the-art of CoO generation technologies, both recent developments and those in commercial use. The focus is on the technologies with the highest merit to become the dominating processes of the future and therefore to be technologies of interest to S&amp;T ... R&amp;D. As such, CoO generation technologies developed in Russia, Japan and Europe are described in some depth. The document starts with an introduction to cobalt oxides as complex products and a short view on cobalt as an essential material. The document continues with the discussion of the available CoO generation processes with respect to energy and capital consumption as well as to environmental damage.\n\nbase models... Â¯\\\\_(ãƒ„)_/Â¯. Since we can inference the base model, it should be possible to also inference the chat model quite easily, and have a conversation with it. And if we can find a way to run 7B more efficiently, we can start adding LoRA to our training script, and going wild with finetunes all within the repo!\n\nYou can also chat with the Llama Chat models. Export the chat model exactly as above:\n\n```bash\npython export.py llama2_7b_chat.bin --meta-llama /path/to/7B-chat\n```\n\nThen chat with it by specifying the chat mode using the `-m` flag, e.g.:\n\n```bash\n./run llama2_7b_chat.bin -m chat\n```\n\nYou can also try Meta's Code Llama models even if support for them is incomplete. In particular, some hyperparameters changed (e.g. the constant in RoPE layer), so the inference is not exactly correct and a bit buggy right now. Looking into fixes. Make sure to build the tokenizer for the plain and instruct variants and pass it when doing inference.\n\n```bash\npython export.py codellama2_7b.bin --meta-llama /path/to/CodeLlama-7b\npython tokenizer.py --tokenizer-model=/path/to/CodeLlama-7b/tokenizer.model\n./run codellama2_7b.bin -z /path/to/CodeLlama-7b/tokenizer.bin\n```\n\nChat with Code Llama Instruct:\n\n```bash\npython export.py codellama2_7b_instruct.bin --meta-llama /path/to/CodeLlama-7b-Instruct\npython tokenizer.py --tokenizer-model=/path/to/CodeLlama-7b-Instruct/tokenizer.model\n./run codellama2_7b_instruct.bin -m chat -z /path/to/CodeLlama-7b-Instruct/tokenizer.bin\n```\n\n## int8 quantization\n\nThe (default) script [run.c](run.c), above, uses a float32 forward pass, where the entire calculation of the forward pass is kept in fp32. This is very easy to understand as far as reference code goes, but it has the following downsides: the model checkpoint files are very large (it takes 4 bytes per every individual weight), and the forward pass is relatively slow. The (very) common inference optimization employed in practice is to quantize the model parameters to lower precision, giving up a little bit of correctness in return for smaller checkpoint sizes and faster forward passes (as most of the inference uses integer arithmetic). Empirically, LLMs can tolerate precisions as low as 4-bit (or even lower), but we use int8 here because it is a \"safe\" setting that gets us the benefits but doesn't sacrifice too much of the model accuracy. Only the weights that participate in matmuls are quantized. All the other parameters (e.g. especially the scale and bias in RMSNorm) are kept in float32, because these layers are very sensitive. Now, if all you're after is reduction in checkpoint sizes, you could quantize the weights, save the checkpoint, and then dequantize them in run.c, and do float32 inference as normal and call it a day. This is totally fine. But here, we go one step further (as is standard practice) and additionally quantize the activations in the forward pass. This requires us to dynamically quantize and dequantize between float32 and int8 at runtime, which adds overhead. But the benefit is that now the majority of the calculations (the matmuls especially!) are using pure integer arithmetic, where both weights and activations enter as int8. This is where the speedups can fundamentally come from. The version we use is the \"Q8_0\" quantization (llama.cpp terminology), where the 0 means that the weight quantization is symmetric around 0, quantizing to the range [-127, 127].\n\nThe quantized forward pass is implemented in [runq.c](runq.c). To use it, we have to export the model in the quantized format. For example, the float32 version of Llama 2 7B was exported as:\n\n```\npython export.py llama2_7b.bin --meta-llama path/to/llama/model/7B\n```\n\nThis creates a 26GB file, because each one of 7B parameters is 4 bytes (fp32). To export it quantized, we instead use version 2 export:\n\n```\npython export.py llama2_7b_q80.bin --version 2 --meta-llama path/to/llama/model/7B\n```\n\nThis runs for a few minutes, but now creates only a 6.7GB file. For exporting non-meta checkpoints you would use the --checkpoint arg instead of --meta-llama arg (more docs on this later, below). Now let's inference them. I like to use OMP here because these are big models, so e.g. on my Linux box:\n\n```\nmake runomp\nOMP_NUM_THREADS=64 ./run llama2_7b.bin -n 40\nOMP_NUM_THREADS=64 ./runq llama2_7b_q80.bin -n 40\n```\n\nThis runs 40 steps just to get a timing. The float32 version for me runs at 4.6 tok/s, and the int8 version at 14 tok/s. So we achieved a 3X speedup while reducing the checkpoint size by 4X. However, the forward pass is quantized to int8, and therefore silently very slightly lower quality.\n\n## huggingface models\n\nWe can load any huggingface models that use the Llama 2 architecture. See the script [export.py](export.py) and the `--hf` flag to export the model .bin file.\n\n## models\n\nFor the sake of examples of smaller, from-scratch models, I trained a small model series on TinyStories. All of these trained in a few hours on my training setup (4X A100 40GB GPUs). The 110M took around 24 hours. I am hosting them on huggingface hub [tinyllamas](https://huggingface.co/karpathy/tinyllamas), both in the original PyTorch .pt, and also in the llama2.c format .bin:\n\n| model | dim | n_layers | n_heads | n_kv_heads | max context length | parameters | val loss | download\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 260K | 64 | 5 | 8 | 4 | 512 | 260K | 1.297 | [stories260K](https://huggingface.co/karpathy/tinyllamas/tree/main/stories260K)\n| OG | 288 | 6 | 6 | 6 | 256 | 15M | 1.072 | [stories15M.bin](https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin) |\n| 42M| 512 | 8 | 8 | 8 | 1024 | 42M | 0.847 | [stories42M.bin](https://huggingface.co/karpathy/tinyllamas/resolve/main/stories42M.bin) |\n| 110M| 768 | 12 | 12 | 12 | 1024 | 110M | 0.760 | [stories110M.bin](https://huggingface.co/karpathy/tinyllamas/resolve/main/stories110M.bin) |\n\nYou'll notice that the 110M model is equivalent to GPT-1 in size. Alternatively, this is also the smallest model in the GPT-2 series (`GPT-2 small`), except the max context length is only 1024 instead of 2048. The only notable changes from GPT-1/2 architecture is that Llama uses RoPE relatively positional embeddings instead of absolute/learned positional embeddings, a bit more fancy SwiGLU non-linearity in the MLP, RMSNorm instead of LayerNorm, bias=False on all Linear layers, and is optionally multiquery.\n\n## training\n\nLet's see how we can train a baby Llama 2 from scratch using the code in this repo. First let's download and pretokenize some source dataset, e.g. I like [TinyStories](https://huggingface.co/datasets/roneneldan/TinyStories) so this is the only example currently available in this repo. But it should be very easy to add datasets, see the code.\n\n```bash\npython tinystories.py download\npython tinystories.py pretokenize\n```\n\nThen train our model:\n\n```bash\npython train.py\n```\n\n**brief training guide**. See the train.py script for more exotic launches and hyperparameter overrides. Here is a brief guide to how to set the parameters. Look at the table at the very end of the [Chinchilla paper](https://arxiv.org/abs/2203.15556) to get a sense of how the Transformer parameters (dim, n_layers, n_heads) grow or shrink together. Extrapolate/interpolate this pattern to get bigger or smaller transformers. Set the max context length however you wish, depending on the problem: this should be the max number of tokens that matter to predict the next token. E.g. Llama 2 uses 2048. Next, you want the _total_ batch size per update (printed by the script as \"tokens per iteration will be:\") to be somewhere around 100K tokens for medium-sized applications. For tiny applications it could be lower, for large training (e.g. GPTs/LLamas) it is usually ~0.5M, or even more. You get there by first maxing out the batch_size to whatever your system allows (e.g. mine was 16 in a recent run because after that my GPU runs out of memory), and then you want to increase gradient_accumulation_steps to be as high as necessary to reach the total batch size of ~100K. Finally, you want to tune your learning_rate (LR). You want this to be as high as your training allows. Very small networks can get away with a large LR (e.g. 1e-3 or even higher). Large networks need lower LRs. 3e-4 is a safe choice in most medium-sized applications, but can be too low for small networks, so try to increase it! Finally, max_iters is the length of training. Play with different settings. I mostly only ever tune these parameters and leave most of the others unchanged. Here is an example of how I trained the 110M model, which I don't think is anywhere near optimal, but looked sensible to me: dim 768, n_layers 12, n_heads 12 (so size of each head is 768 / 12 = 64 channels), seq len of 1024, batch size 16 (this is the most that fit my A100 40GB GPU), gradient_accumulation_steps = 8 was needed to get total tokens batch size to be 16 batch size * 1024 tokens in sequence * 8 grad_accum = 131,072 tokens per update. Good. Learning rate 4e-4 (probably a little too low). max_iters 200K (probably a bit too high). Dropout 0.1, as that usually helps a bit at medium size. That was it. I ran using Distributed Data Parallel (DDP) on 4 GPUs on my cloud machine, training took ~day or so.\n\nTotally understand if you want to skip model training, for simple demo just download one of the pretrained models (see [models](#models) section), e.g.:\n\n```bash\nwget https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin\n```\n\nOnce we have the model.bin file, we can inference in C. Compile the C code first:\n\n```bash\nmake run\n```\n\nYou can now run it simply as\n\n```bash\n./run stories15M.bin\n```\n\nWatch the tokens stream by, fun! We can also run the PyTorch inference script for a comparison. Download one of the models again from huggingface hub and point the `sample.py` script at it:\n\n```bash\nwget https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.pt -P out15M\npython sample.py --checkpoint=out15M/stories15M.pt\n```\n\nWhich gives the same results.\n\n## custom tokenizers\n\nIn everything above, we've assumed the custom Lllama 2 tokenizer with 32,000 tokens. However, in many boutique LLMs, using vocabulary this big might be an overkill. If you have a small application you have in mind, you might be much better off training your own tokenizers. This can make everything nicer - with smaller vocabs your model has fewer parameters (because the token embedding table is a lot smaller), the inference is faster (because there are fewer tokens to predict), and your average sequence length per example could also get smaller (because the compression is a lot more efficient on your data). So let's see how we train a custom tokenizer.\n\nBy default, to pretokenize the tinystories dataset we had to run, in order:\n\n```\npython tinystories.py download\npython tinystories.py pretokenize\n```\n\nThe `pretokenize` stage here loads the Llama 2 tokenizer (vocab size 32,000) and uses it to convert the downloaded text into integers, and saves that to file. We now change this as follows, to train an example 4096-token tokenizer:\n\n```\npython tinystories.py download\npython tinystories.py train_vocab --vocab_size=4096\npython tinystories.py pretokenize --vocab_size=4096\n```\n\nThe `train_vocab` stage will call the `sentencepiece` library to train the tokenizer, storing it in a new file `data/tok4096.model`. I tried to reproduce as well as I could the settings that (I think) Meta used to train their vocabulary. This uses the Byte Pair Encoding algorithm that starts out with raw utf8 byte sequences of the text data and then iteratively merges the most common consecutive pairs of tokens to form the vocabulary. Inspect the `tinystories.py` file - the custom tokenizers are stored in a special directory structure indexed by the vocab size.\n\nA quick note of interest is that vocab size of 4096 trained specifically on tinystories creates integer sequences with about the same sequence length per example as the default Llama 2 tokenizer of 32000 tokens! This means that our custom, tailored tokenizer is a lot better adapted to our specific text, and can compress it very effectively. So our trained models are smaller and faster.\n\nNow that we have pretokenized the dataset with our custom tokenizer, we can train the model. The training script `train.py` doesn't care about the exact tokens, it only cares about the vocabulary size so it can correctly initialize the model. So when training your model, make sure to pass in\n\n```\npython train.py --vocab_source=custom --vocab_size=4096\n```\n\n(The defaults are `llama2` and `32000` respectively, which indicates the default Llama 2 tokenizer). This trains the model. Finally we are ready to run inference with our `run.c` script. For that we need two things. Number one, we have to export our tokenizer in the `.bin` format, do that with:\n\n```\npython tokenizer.py --tokenizer-model=data/tok4096.model\n```\n\nThis writes the tokenizer to `data/tok4096.bin`. Now we can run inference, pointing it to this tokenizer using the `-z` flag:\n\n```\n./run out/model.bin -z data/tok4096.bin\n```\n\nThis should print the samples. If you leave out the `-z` flag, it will use the default Llama 2 tokenizer, which would generate a good sequence of integers, but they would get translated using a different vocabulary to text, so it would look like gibberish.\n\n## performance\n\nThere are many ways to potentially speed up this code depending on your system. Have a look at the [Makefile](Makefile), which contains a lot of notes. The `make run` command currently uses the `-O3` optimization by default, i.e.:\n\n```bash\ngcc -O3 -o run run.c -lm\n```\n\n-O3 includes optimizations that are expensive in terms of compile time and memory usage. Including vectorization, loop unrolling, and predicting branches.\n\nTo get a much better performance, try to compile with `make runfast`. This turns on the `-Ofast` flag, which includes additional optimizations that may break compliance with the C/IEEE specifications, in addition to `-O3`. See [the GCC docs](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html) for more information.\n\nTry `-march=native` to compile the program to use the architecture of the machine you're compiling on rather than a more generic CPU. This may enable additional optimizations and hardware-specific tuning such as improved vector instructions/width.\n\nThe fastest throughput I saw so far on my MacBook Air (M1) so far is with `make runfast`.\n\nYou can also experiment with replacing `gcc` with `clang`.\n\nIf compiling with gcc, try experimenting with `-funroll-all-loops`, see PR [#183](https://github.com/karpathy/llama2.c/pull/183)\n\n**OpenMP**. Big improvements can also be achieved by compiling with OpenMP, which \"activates\" the `#pragma omp parallel for` inside the matmul and attention, allowing the work in the loops to be split up over multiple processors.\nYou'll need to install the OpenMP library and the clang compiler first (e.g. `apt install clang libomp-dev` on ubuntu). Then you can compile with `make runomp`, which does:\n\n```bash\nclang -Ofast -fopenmp -march=native run.c  -lm  -o run\n```\n\nWhen you run inference make sure to use OpenMP flags to set the number of threads, e.g.:\n\n```bash\nOMP_NUM_THREADS=4 ./run out/model.bin\n```\n\nDepending on your system resources you may want to tweak these hyperparameters and use more threads. But more is not always better, usually this is a bit U shaped. In particular, if your CPU has SMT (multithreading), try setting the number of threads to the number of physical cores rather than logical cores. The performance difference can be large due to cache thrashing and communication overhead. The PyTorch documentation [CPU specific optimizations\n](https://pytorch.org/tutorials/recipes/recipes/tuning_guide.html#cpu-specific-optimizations) has some good information that applies here too.\n\n## platforms\n\nOn **Windows**, use `build_msvc.bat` in a Visual Studio Command Prompt to build with msvc, or you can use `make win64` to use mingw compiler toolchain from linux or windows to build the windows target. MSVC build will automatically use openmp and max threads appropriate for your CPU unless you set `OMP_NUM_THREADS` env.\n\nOn **Centos 7**, **Amazon Linux 2018** use `rungnu` Makefile target: `make rungnu` or `make runompgnu` to use openmp.\n\nOn **Mac**, use clang from brew for openmp build. Install clang as `brew install llvm` and use the installed clang binary to compile with openmp: `make runomp CC=/opt/homebrew/opt/llvm/bin/clang`\n\n## tests\n\nYou can run tests simply with pytest:\n\n```bash\n$ pip install pytest\n$ pytest\n```\n\nThis will currently invoke two tests inside `test_all.py`, which forward the model in both C and Python for 200 steps and check the output against a known good expected output. The tests currently run in only a few seconds, but will have to download and cache the stories260K models in a temporary `test` directory (only ~2MB download).\n\nThere are also some tests in C, in the file [test.c](test.c). You can run these with `make testcc`, or to see more stuff printed:\n\n```\nmake testcc VERBOSITY=1\n```\n\nCall for help: help add more tests.\n\n## ack\n\nI trained the llama2.c storyteller models on a 4X A100 40GB box graciously provided by the excellent [Lambda labs](https://lambdalabs.com/service/gpu-cloud), thank you.\n\n## discord\n\nFigured it's possible to reuse my existing discord channel (that I use for my [zero to hero youtube series](https://karpathy.ai/zero-to-hero.html)), see #llama2c channel on [discord](https://discord.gg/3zy8kqD9Cp), for any quick questions, related discussions, etc.\n\n## contributing\n\nA few words on this repo and the kinds of PRs that are likely to be accepted. What is the goal of this repo? Basically I think there will be a lot of interest in training or finetuning custom micro-LLMs (think ~100M - ~1B params, but let's say up to ~10B params) across a large diversity of applications, and deploying them in edge-adjacent environments (think MCUs, phones, web browsers, laptops, etc.). I'd like this repo to be the simplest, smallest, most hackable repo to support this workflow, both training and inference. In particular, this repo is not a complex framework with a 1000 knobs controlling inscrutible code across a nested directory structure of hundreds of files. Instead, I expect most applications will wish to create a fork of this repo and hack it to their specific needs and deployment platforms.\n\nPeople who care about deployment efficiency above all else should look at [llama.cpp](https://github.com/ggerganov/llama.cpp). This repo still cares about efficiency, but not at the cost of simplicity, readability or portability. Basically, I expect that a lot of people come to this repo because the training code is 2 readable .py files and the inference code is 500 lines of C. So I'd like this to continue to be a kind of simplest \"reference implementation\" that can be easily hacked in a separate fork into whatever downstream application people are excited about. It shouldn't be full-featured. It shouldn't take 100 different options or settings. It shouldn't be the most efficient. A few examples:\n\n- someone re-ordered two loops to improve data locality for a small efficieny win => instant merge.\n- someone added the one line \"pragma omp parallel for\", which allows you to compile with OpenMP and dramatically speed up the code, or acts as just a comment if you don't compile it that way => instant merge.\n- bug fixes and touchups etc. => happy to merge\n\nA few examples of PRs are that are not an excellent fit:\n\n- adding more than several #ifdefs all over the place in code. If they are localized / few, might be okay.\n- adding a lot of code that is very specific to some specific platform (e.g. MCUs, or some special version of linux or processor). These may be a better fit for forks of the project, and I am very happy to maintain a list of these forks in section below.\n- adding hundreds of lines of code to run.c that are only active in specific scenarios or platforms.\n\nIf your candidate PRs have elements of these it doesn't mean they won't get merged, it just means they will make it into the gray territory. TLDR: I am eager to merge any mostly small, mostly localized, broadly applicable, clean changes that improve the efficiency and portability of the repo, while keep its hackability and readability. I appreciate all PRs seeking to help me improve the project, thank you! <3.\n\n## notable forks\n\n- Rust\n  - [llama2.rs](https://github.com/gaxler/llama2.rs) by @[gaxler](https://github.com/gaxler): a Rust port of this project\n  - [llama2.rs](https://github.com/leo-du/llama2.rs) by @[leo-du](https://github.com/leo-du): A Rust port of this project\n  - [llama2-rs](https://github.com/danielgrittner/llama2-rs) by @[danielgrittner](https://github.com/danielgrittner): a Rust port of this project\n  - [llama2.rs](https://github.com/lintian06/llama2.rs) by @[lintian06](https://github.com/lintian06): A Rust port of this project\n  - [pecca.rs](https://github.com/rahoua/pecca-rs) by @[rahoua](https://github.com/rahoua): A Rust port leveraging [ndarray](https://github.com/rust-ndarray/ndarray), supports BLAS.\n  - [llama2.rs](https://github.com/flaneur2020/llama2.rs) by @[flaneur2020](https://github.com/flaneur2020): A Rust port of this project.\n  - [llama2-burn](https://github.com/code-cp/llama2-burn): A Rust port of this project leveraging [Burn](https://github.com/tracel-ai/burn)\n- Go\n  - [go-llama2](https://github.com/tmc/go-llama2) by @[tmc](https://github.com/tmc): a Go port of this project\n  - [llama2.go](https://github.com/nikolaydubina/llama2.go) by @[nikolaydubina](https://github.com/nikolaydubina): a Go port of this project\n  - [llama2.go](https://github.com/haormj/llama2.go) by @[haormj](https://github.com/haormj): a Go port of this project\n  - [llama2.go](https://github.com/saracen/llama2.go) by @[saracen](https://github.com/saracen): a Go port of this project\n- Android\n  - [llama2.c-android](https://github.com/Manuel030/llama2.c-android): by @[Manuel030](https://github.com/Manuel030): adds Android binaries of this project\n  - [llama2.c-android-wrapper](https://github.com/celikin/llama2.c-android-wrapper): by @[celikin](https://github.com/celikin): added JNI wrapper, PoC\n- C\n  - [llama3.c](https://github.com/jameswdelancey/llama3.c): by @[jameswdelancey](https://github.com/jameswdelancey): a LLaMA 3 8B Base and Instruct port of this project\n- C++\n  - [llama2.cpp](https://github.com/leloykun/llama2.cpp) by @[leloykun](https://github.com/leloykun): a C++ port of this project\n  - [llama2.cpp](https://github.com/coldlarry/llama2.cpp) by @[coldlarry](https://github.com/coldlarry): a C++ port of this project\n- JavaScript\n  - [llama2.js](https://github.com/epicure/llama2.js) by @[epicure](https://github.com/epicure): a JavaScript port of this project\n  - [llamajs](https://github.com/agershun/llamajs) by @[agershun](https://github.com/agershun): a JavaScript port of this project\n  - [llama2.ts](https://github.com/wizzard0/llama2.ts) by @[oleksandr_now](https://twitter.com/oleksandr_now): a TypeScript port of this project. Full Llama2-7B capable.\n  - [llama2.c-emscripten](https://github.com/gohai/llama2.c-emscripten) by @[gohai](https://github.com/gohai): Emscripten (JavaScript) port, based on @ggerganov's initial prototype\n- Zig\n  - [llama2.zig](https://github.com/cgbur/llama2.zig) by @[cgbur](https://github.com/cgbur): A Zig port of this project\n  - [llama2.zig](https://github.com/vodkaslime/llama2.zig) by @[vodkaslime](https://github.com/vodkaslime): a Zig port of this project\n  - [llama2.zig](https://github.com/clebert/llama2.zig) by @[clebert](https://github.com/clebert): a Zig port of this project\n- Julia\n  - [llama2.jl](https://github.com/juvi21/llama2.jl) by @[juvi21](https://github.com/juvi21): a Julia port of this project\n- Scala\n  - [llama2.scala](https://github.com/jrudolph/llama2.scala) by @[jrudolph](https://github.com/jrudolph): a Scala port of this project\n- Java\n  - [llama2.java](https://github.com/mukel/llama2.java) by @[mukel](https://github.com/mukel): a Java port of this project\n  - [llama2.java](https://github.com/neoremind/llama2.java) by @[neoremind](https://github.com/neoremind): a Java port of this project\n  - [llama2.tornadovm.java](https://github.com/mikepapadim/llama2.tornadovm.java) by @[mikepapadim](https://github.com/mikepapadim): an extension of the llama2.java with GPU-support through [TornadoVM](https://github.com/beehive-lab/TornadoVM).\n- Kotlin\n  - [llama2.kt](https://github.com/madroidmaq/llama2.kt) by @[madroidmaq](https://github.com/madroidmaq): a Kotlin port of this project\n  - [llama2-kmp](https://github.com/stepango/llama2-kmp) by @[stepango](https://github.com/stepango): a Kotlin multiplatform(KMP) port of this project \n- Python\n  - [llama2.py](https://github.com/tairov/llama2.py) by @[tairov](https://github.com/tairov): a simple one file pure Python port of this project with zero dependencies\n- C#\n  - [llama2.cs](https://github.com/trrahul/llama2.cs) by @[trrahul](https://github.com/trrahul): a C# port of this project\n- F#\n  - [llama2.fs](https://github.com/micsh/llama2.fs) by @[micsh](https://github.com/micsh): a F# port of this project\n- Dart\n  - [llama2.dart](https://github.com/yiminghan/llama2.dart) by @[yiminghan](https://github.com/yiminghan/llama2.dart): one-file dart port of this project, works with Flutter!\n- Web\n  - [llama2c-web](https://github.com/dmarcos/llama2.c-web) by @[dmarcos](https://github.com/dmarcos): Super simple way to build unmodified llama2.c to WASM and run it in the browser. [Demo](https://diegomarcos.com/llama2.c-web/)\n  - [llama2.rs.wasm](https://github.com/mtb0x1/llama2.rs.wasm) by @[mtb0x1](https://github.com/mtb0x1/) : a [Demo](https://mtb0x1.github.io/llama2.rs.wasm/) of all listed rust ports to WASM, all in one web page.\n- WebAssembly\n  - [icpp-llm](https://github.com/icppWorld/icpp-llm): LLMs for the Internet Computer\n- Fortran\n  - [llama2.f90](https://github.com/rbitr/llama2.f90): a Fortran port of this project\n- Mojo\n  - [llama2.ðŸ”¥](https://github.com/tairov/llama2.mojo) by @[tairov](https://github.com/tairov): pure Mojo port of this project\n- OCaml\n  - [llama2.ml](https://github.com/jackpeck/llama2.ml) by @[jackpeck](https://github.com/jackpeck): an OCaml port of this project\n- Hare\n  - [llama2.ha](https://sr.ht/~dvshkn/llama2.ha) by @[dvshkn](https://git.sr.ht/~dvshkn): a Hare port of this project\n- [llama2.c - Llama 2 Everywhere](https://github.com/trholding/llama2.c) by @[trholding](https://github.com/trholding): Standalone, Bootable & Portable Binary Llama 2\n- [llama2.c-zh - Bilingual Chinese and English](https://github.com/chenyangMl/llama2.c-zh) by @[chenyangMl](https://github.com/chenyangMl): Expand tokenizer to support training and inference in both Chinese and English\n- Haskell\n  - [llama2.hs](https://github.com/chris-ch/llama2.hs) by @[chris-ch](https://github.com/chris-ch): an Haskell port of this project\n\n## unsorted todos\n\n- add support in run.c of reading version 1+ files from export, later deprecate \"version 0\"\n- run.cu (CUDA) investigate and merge\n- add more tests inside [test.c](test.c)\n- add Engine class for use in sample.py that does efficient inference in PyTorch, e.g. KV cache keeping\n- make it easier to add a new dataset with not too much pain\n- (LoRA) finetuning and export of Llama 2 models\n\n## License\n\nMIT\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "build_msvc.bat",
          "type": "blob",
          "size": 0.0439453125,
          "content": "cl.exe /fp:fast /Ox /openmp /I. run.c win.c \n"
        },
        {
          "name": "configurator.py",
          "type": "blob",
          "size": 1.716796875,
          "content": "\"\"\"\nPoor Man's Configurator. Probably a terrible idea. Example usage:\n$ python train.py config/override_file.py --batch_size=32\nthis will first run config/override_file.py, then override batch_size to 32\n\nThe code in this file will be run as follows from e.g. train.py:\n>>> exec(open('configurator.py').read())\n\nSo it's not a Python module, it's just shuttling this code away from train.py\nThe code in this script then overrides the globals()\n\nI know people are not going to love this, I just really dislike configuration\ncomplexity and having to prepend config. to every single variable. If someone\ncomes up with a better simple Python solution I am all ears.\n\"\"\"\n\nimport sys\nfrom ast import literal_eval\n\nfor arg in sys.argv[1:]:\n    if '=' not in arg:\n        # assume it's the name of a config file\n        assert not arg.startswith('--')\n        config_file = arg\n        print(f\"Overriding config with {config_file}:\")\n        with open(config_file) as f:\n            print(f.read())\n        exec(open(config_file).read())\n    else:\n        # assume it's a --key=value argument\n        assert arg.startswith('--')\n        key, val = arg.split('=')\n        key = key[2:]\n        if key in globals():\n            try:\n                # attempt to eval it it (e.g. if bool, number, or etc)\n                attempt = literal_eval(val)\n            except (SyntaxError, ValueError):\n                # if that goes wrong, just use the string\n                attempt = val\n            # ensure the types match ok\n            assert type(attempt) == type(globals()[key])\n            # cross fingers\n            print(f\"Overriding: {key} = {attempt}\")\n            globals()[key] = attempt\n        else:\n            raise ValueError(f\"Unknown config key: {key}\")\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "export.py",
          "type": "blob",
          "size": 23.9384765625,
          "content": "\"\"\"\nThis script has functions and utilties for model export.\nBasically, we have a bunch of versions of the model, and we\nwant to export them to .bin files to be read from and inferenced in C.\n\nAmong the \"input\" versions of PyTorch files/models:\n- Official Llama 2 weights released by Meta\n- Huggingface weights available on the hub\n- llama2.c (this repo) trained models\n\nAmong the \"output\" versions of .bin files:\n- v0: Legacy files of the original llama2.c repo (will eventually be DEPRECATED)\n- v1-vN: Improved .bin files with a proper header, cache alignment, etc.\n\nThis script aspires to provide all of these conversions.\n\"\"\"\nimport os\nimport gzip\nimport shutil\nimport struct\nimport argparse\nimport json\nfrom pathlib import Path\n\nimport numpy as np\nimport torch\nfrom torch import nn\n\nfrom model import ModelArgs, Transformer\n\n# -----------------------------------------------------------------------------\n# common utilities\n\ndef serialize_fp32(file, tensor):\n    \"\"\" writes one fp32 tensor to file that is open in wb mode \"\"\"\n    d = tensor.detach().cpu().view(-1).to(torch.float32).numpy()\n    b = struct.pack(f'{len(d)}f', *d)\n    file.write(b)\n\ndef serialize_int8(file, tensor):\n    \"\"\" writes one int8 tensor to file that is open in wb mode \"\"\"\n    d = tensor.detach().cpu().view(-1).numpy().astype(np.int8)\n    b = struct.pack(f'{len(d)}b', *d)\n    file.write(b)\n\ndef quantize_q80(w, group_size):\n    \"\"\"\n    takes a tensor and returns the Q8_0 quantized version\n    i.e. symmetric quantization into int8, range [-127,127]\n    \"\"\"\n    assert w.numel() % group_size == 0\n    ori_shape = w.shape\n    w = w.float() # convert to float32\n    w = w.reshape(-1, group_size)\n    # find the max in each group\n    wmax = torch.abs(w).max(dim=1).values\n    # calculate the scaling factor such that float = quant * scale\n    scale = wmax / 127.0\n    # scale into range [-127, 127]\n    quant = w / scale[:,None]\n    # round to nearest integer\n    int8val = torch.round(quant).to(torch.int8)\n    # dequantize by rescaling\n    fp32val = (int8val.float() * scale[:,None]).view(-1)\n    fp32valr = fp32val.reshape(-1, group_size)\n    # calculate the max error in each group\n    err = torch.abs(fp32valr - w).max(dim=1).values\n    # find the max error across all groups\n    maxerr = err.max().item()\n    return int8val, scale, maxerr\n\n# -----------------------------------------------------------------------------\n# legacy\n\ndef legacy_export(model, filepath):\n    \"\"\" Original export of llama2.c bin files, i.e. version v0 \"\"\"\n    out_file = open(filepath, 'wb')\n\n    # first write out the header\n    hidden_dim = model.layers[0].feed_forward.w1.weight.shape[0]\n    p = model.params\n    shared_classifier = torch.equal(model.tok_embeddings.weight, model.output.weight)\n    # legacy format uses negative/positive vocab size as a shared classifier flag\n    if not shared_classifier:\n        p.vocab_size = -p.vocab_size\n    n_kv_heads = p.n_heads if p.n_kv_heads is None else p.n_kv_heads\n    header = struct.pack('iiiiiii', p.dim, hidden_dim, p.n_layers, p.n_heads,\n                                    n_kv_heads, p.vocab_size, p.max_seq_len)\n    out_file.write(header)\n\n    # next write out the embedding weights\n    serialize_fp32(out_file, model.tok_embeddings.weight)\n\n    # now all the layers\n    # attention weights\n    for layer in model.layers:\n        serialize_fp32(out_file, layer.attention_norm.weight)\n    for layer in model.layers:\n        serialize_fp32(out_file, layer.attention.wq.weight)\n    for layer in model.layers:\n        serialize_fp32(out_file, layer.attention.wk.weight)\n    for layer in model.layers:\n        serialize_fp32(out_file, layer.attention.wv.weight)\n    for layer in model.layers:\n        serialize_fp32(out_file, layer.attention.wo.weight)\n    # ffn weights\n    for layer in model.layers:\n        serialize_fp32(out_file, layer.ffn_norm.weight)\n    for layer in model.layers:\n        serialize_fp32(out_file, layer.feed_forward.w1.weight)\n    for layer in model.layers:\n        serialize_fp32(out_file, layer.feed_forward.w2.weight)\n    for layer in model.layers:\n        serialize_fp32(out_file, layer.feed_forward.w3.weight)\n    # final rmsnorm\n    serialize_fp32(out_file, model.norm.weight)\n    # freqs_cis\n    serialize_fp32(out_file, model.freqs_cos[:p.max_seq_len])\n    serialize_fp32(out_file, model.freqs_sin[:p.max_seq_len])\n\n    # final classifier weights\n    if not shared_classifier:\n        serialize_fp32(out_file, model.output.weight)\n\n    # write to binary file\n    out_file.close()\n    print(f\"wrote {filepath}\")\n\n# -----------------------------------------------------------------------------\n# new version\n\ndef version1_export(model, filepath):\n    \"\"\"\n    Export the model weights in full float32 .bin file to be read from C.\n    This is same as legacy_export, but with a proper header.\n    \"\"\"\n    version = 1\n\n    out_file = open(filepath, 'wb')\n    # first write out the header. the header will be 256 bytes\n    # 1) write magic, which will be uint32 of \"ak42\" in ASCII\n    out_file.write(struct.pack('I', 0x616b3432))\n    # 2) write version, which will be int\n    out_file.write(struct.pack('i', version))\n    # 3) write the params, which will be 7 ints\n    p = model.params\n    hidden_dim = model.layers[0].feed_forward.w1.weight.shape[0]\n    n_kv_heads = p.n_heads if p.n_kv_heads is None else p.n_kv_heads\n    header = struct.pack('iiiiiii', p.dim, hidden_dim, p.n_layers, p.n_heads,\n                                    n_kv_heads, p.vocab_size, p.max_seq_len)\n    out_file.write(header)\n    # 4) write some other flags\n    shared_classifier = torch.equal(model.tok_embeddings.weight, model.output.weight)\n    out_file.write(struct.pack('B', int(shared_classifier)))\n    pad = 256 - out_file.tell() # pad rest with zeros; tell returns current pos\n    assert pad >= 0\n    out_file.write(b'\\0' * pad)\n\n    # now let's write out all the params\n    weights = [\n        *[layer.attention_norm.weight for layer in model.layers],\n        *[layer.ffn_norm.weight for layer in model.layers],\n        model.norm.weight,\n        model.tok_embeddings.weight,\n        *[layer.attention.wq.weight for layer in model.layers],\n        *[layer.attention.wk.weight for layer in model.layers],\n        *[layer.attention.wv.weight for layer in model.layers],\n        *[layer.attention.wo.weight for layer in model.layers],\n        *[layer.feed_forward.w1.weight for layer in model.layers],\n        *[layer.feed_forward.w2.weight for layer in model.layers],\n        *[layer.feed_forward.w3.weight for layer in model.layers],\n    ]\n    if not shared_classifier:\n        weights.append(model.output.weight)\n    for w in weights:\n        serialize_fp32(out_file, w)\n\n    # write to binary file\n    out_file.close()\n    print(f\"wrote {filepath}\")\n\ndef version2_export(model, filepath, group_size=64):\n    \"\"\"\n    Export the model weights in Q8_0 into .bin file to be read from C.\n    That is:\n    - quantize all weights to symmetric int8, in range [-127, 127]\n    - all other tensors (the rmsnorm params) are kept and exported in fp32\n    - quantization is done in groups of group_size to reduce the effects of any outliers\n    \"\"\"\n    version = 2\n\n    # let's first do some validation for this export type\n    while model.params.dim % group_size != 0:\n        group_size //= 2\n        print(f\"BACKOFF: reducing group size to {group_size} to fit hidden_dim\")\n    weights = [\n        model.tok_embeddings.weight,\n        *[layer.attention.wq.weight for layer in model.layers],\n        *[layer.attention.wk.weight for layer in model.layers],\n        *[layer.attention.wv.weight for layer in model.layers],\n        *[layer.attention.wo.weight for layer in model.layers],\n        *[layer.feed_forward.w1.weight for layer in model.layers],\n        *[layer.feed_forward.w2.weight for layer in model.layers],\n        *[layer.feed_forward.w3.weight for layer in model.layers],\n    ]\n    shared_classifier = torch.equal(model.tok_embeddings.weight, model.output.weight)\n    if not shared_classifier:\n        weights.append(model.output.weight)\n    for w in weights:\n        assert w.numel() % group_size == 0, f\"weight {i} has numel {w.numel()}, not a multiple of group_size {group_size}\"\n\n    # write\n    out_file = open(filepath, 'wb')\n    # first write out the header. the header will be 256 bytes\n    # 1) write magic, which will be uint32 of \"ak42\" in ASCII\n    out_file.write(struct.pack('I', 0x616b3432))\n    # 2) write version, which will be int\n    out_file.write(struct.pack('i', version))\n    # 3) write the params, which will be 7 ints\n    p = model.params\n    hidden_dim = model.layers[0].feed_forward.w1.weight.shape[0]\n    n_kv_heads = p.n_heads if p.n_kv_heads is None else p.n_kv_heads\n    header = struct.pack('iiiiiii', p.dim, hidden_dim, p.n_layers, p.n_heads,\n                                    n_kv_heads, p.vocab_size, p.max_seq_len)\n    out_file.write(header)\n    # 4) write some other flags\n    out_file.write(struct.pack('B', int(shared_classifier)))\n    out_file.write(struct.pack('i', group_size)) # group size used for quantization\n    pad = 256 - out_file.tell() # pad rest with zeros; tell returns current pos\n    assert pad >= 0\n    out_file.write(b'\\0' * pad)\n    # now that the header is done, let's write out the model\n\n    # first let's write out all the params that we are keeping in fp32: the norms\n    for layer in model.layers: # attention norms\n        serialize_fp32(out_file, layer.attention_norm.weight)\n    for layer in model.layers: # MLP norms\n        serialize_fp32(out_file, layer.ffn_norm.weight)\n    serialize_fp32(out_file, model.norm.weight) # final pre-classifier norm\n\n    # now let's write out all the params that we are quantizing to Q8_0\n    # note we skip classifier weights, which are shared with the embedding\n    ew = []\n    for i, w in enumerate(weights):\n        # quantize this weight\n        q, s, err = quantize_q80(w, group_size)\n        # save the int8 weights to file\n        serialize_int8(out_file, q) # save the tensor in int8\n        serialize_fp32(out_file, s) # save scale factors\n        # logging\n        ew.append((err, w.shape))\n        print(f\"{i+1}/{len(weights)} quantized {tuple(w.shape)} to Q8_0 with max error {err}\")\n\n    # print the highest error across all weights, should be very small, e.g. O(~0.001)\n    ew.sort(reverse=True)\n    print(f\"max quantization group error across all weights: {ew[0][0]}\")\n\n    # write to binary file\n    out_file.close()\n    print(f\"wrote {filepath}\")\n\ndef hf_export(llama_model, filepath, group_size=64, dtype=torch.float32):\n    \"\"\" Generate the pytorch_model.bin state_dict and config.json for HuggingFace \"\"\"\n\n    try:\n        from transformers.models.llama.configuration_llama import LlamaConfig\n    except ImportError:\n        print(\"Error: transformers package is required to load huggingface models\")\n        print(\"Please run `pip install transformers` to install it\")\n        return None\n\n    #Â Generate LlamaModel state_dict\n    hf_state_dict = {}\n\n    # Sometimes we have repeated key values for the heads\n    dim = llama_model.params.dim\n    num_key_value_heads = llama_model.params.n_kv_heads\n    n_rep = llama_model.params.n_heads // num_key_value_heads\n    key_value_dim = dim // n_rep\n\n    # HuggingFace needs the weights permuted.\n    # See: https://github.com/huggingface/transformers/blob/b132c1703eb1c8bd9dfa4ad6a9be2bfd6ef819e9/src/transformers/models/llama/convert_llama_weights_to_hf.py#L122\n    def permute_original(w, n_heads=llama_model.params.n_heads, dim1=dim, dim2=dim):\n        return w.view(dim1, dim2).reshape(n_heads, dim1 // n_heads // 2, 2, dim2).transpose(1, 2).reshape(dim1, dim2)\n\n    # Transfer weights from llama model to the HF state dictionary format\n    hf_state_dict['model.embed_tokens.weight'] = llama_model.tok_embeddings.weight.clone().to(dtype)\n    hf_state_dict['model.norm.weight'] = llama_model.norm.weight.clone().to(dtype)\n\n    # Add each layer's weights to the HF state dictionary\n    for i, layer in enumerate(llama_model.layers):\n        layer_id = layer.layer_id\n        hf_state_dict[f'model.layers.{i}.input_layernorm.weight'] = llama_model.layers[layer_id].attention_norm.weight.clone().to(dtype)\n        hf_state_dict[f'model.layers.{i}.self_attn.q_proj.weight'] = permute_original(llama_model.layers[layer_id].attention.wq.weight.clone()).to(dtype)\n        hf_state_dict[f'model.layers.{i}.self_attn.k_proj.weight'] = permute_original(llama_model.layers[layer_id].attention.wk.weight.clone(), num_key_value_heads, key_value_dim, dim).to(dtype)\n        hf_state_dict[f'model.layers.{i}.self_attn.v_proj.weight'] = llama_model.layers[layer_id].attention.wv.weight.clone().to(dtype)\n        hf_state_dict[f'model.layers.{i}.self_attn.o_proj.weight'] = llama_model.layers[layer_id].attention.wo.weight.clone().to(dtype)\n        hf_state_dict[f'model.layers.{i}.post_attention_layernorm.weight'] = llama_model.layers[layer_id].ffn_norm.weight.clone().to(dtype)\n        hf_state_dict[f'model.layers.{i}.mlp.gate_proj.weight'] = llama_model.layers[layer_id].feed_forward.w1.weight.clone().to(dtype)\n        hf_state_dict[f'model.layers.{i}.mlp.down_proj.weight'] = llama_model.layers[layer_id].feed_forward.w2.weight.clone().to(dtype)\n        hf_state_dict[f'model.layers.{i}.mlp.up_proj.weight'] = llama_model.layers[layer_id].feed_forward.w3.weight.clone().to(dtype)\n\n    # llama2.c usually uses tied weights -> reference the embed_tokens.weights instead\n    hf_state_dict['lm_head.weight'] = hf_state_dict['model.embed_tokens.weight']\n\n    # We check that the embeddings are tied, else use manual output weights\n    _embeddings_are_tied: bool = torch.equal(llama_model.tok_embeddings.weight, llama_model.output.weight)\n    if not _embeddings_are_tied:\n        hf_state_dict['lm_head.weight'] = llama_model.output.weight.clone().to(dtype)\n\n\n    # Generate LlamaConfig (seen in transformers.models.llama.configuration_llama)\n\n    # Extract necessary attributes from llama.c model\n    vocab_size = llama_model.params.vocab_size\n    hidden_size = llama_model.params.dim\n    intermediate_size = llama_model.layers[0].feed_forward.w1.weight.shape[0]\n    num_hidden_layers = llama_model.params.n_layers\n    num_attention_heads = llama_model.params.n_heads\n    num_key_value_heads = llama_model.params.n_kv_heads\n    max_position_embeddings = llama_model.params.max_seq_len\n    rms_norm_eps = llama_model.params.norm_eps\n\n    # TODO check values for:\n    # pretraining_tp, initializer_range, use_cache,\n    # rope_theta, and rope_scaling.\n\n    config = LlamaConfig(\n        vocab_size=vocab_size,\n        hidden_size=hidden_size,\n        intermediate_size=intermediate_size,\n        num_hidden_layers=num_hidden_layers,\n        num_attention_heads=num_attention_heads,\n        num_key_value_heads=num_key_value_heads,\n        max_position_embeddings=max_position_embeddings,\n        rms_norm_eps=rms_norm_eps,\n        tie_word_embeddings=_embeddings_are_tied,\n        # Manual\n        architectures=[\"LlamaForCausalLM\"],\n        hidden_act=\"silu\",\n    )\n\n\n    # Save files in directory filepath\n    #Â First make the directory if it doesn't exist\n    os.makedirs(filepath, exist_ok=True)\n\n    # Save the state dictionary in .bin format, and config as .json\n    torch.save(hf_state_dict, os.path.join(filepath, \"pytorch_model.bin\"))\n    config.save_pretrained(filepath)\n\n\n# -----------------------------------------------------------------------------\n# Load / import functions\n\ndef load_checkpoint(checkpoint):\n\n    # load the provided model checkpoint\n    checkpoint_dict = torch.load(checkpoint, map_location='cpu')\n    gptconf = ModelArgs(**checkpoint_dict['model_args'])\n    model = Transformer(gptconf)\n    state_dict = checkpoint_dict['model']\n    unwanted_prefix = '_orig_mod.'\n    for k,v in list(state_dict.items()):\n        if k.startswith(unwanted_prefix):\n            state_dict[k[len(unwanted_prefix):]] = state_dict.pop(k)\n    model.load_state_dict(state_dict, strict=False)\n    model.eval()\n    return model\n\ndef load_meta_model(model_path):\n    params_path = os.path.join(model_path, 'params.json')\n    with open(params_path) as f:\n        params = json.load(f)\n        print(params)\n\n    model_paths = sorted(list(Path(model_path).glob('consolidated.*.pth')))\n    models = [torch.load(p, map_location='cpu') for p in model_paths]\n\n    def concat_weights(models):\n        state_dict = {}\n        for name in list(models[0]):\n            tensors = [model[name] for model in models]\n            if len(tensors) == 1 or len(tensors[0].shape) == 1:\n                state_dict[name] = tensors[0]\n                continue\n            is_axis_1 = (\n                name.startswith('tok_embeddings.')\n                or name.endswith('.attention.wo.weight')\n                or name.endswith('.feed_forward.w2.weight')\n            )\n            axis = 1 if is_axis_1 else 0\n            state_dict[name] = torch.cat(tensors, dim=axis)\n            for model in models:\n                del model[name]\n        return state_dict\n\n    state_dict = concat_weights(models)\n    del models\n\n    # set ModelArgs\n    config = ModelArgs()\n    config.dim = params[\"dim\"]\n    config.n_layers = params[\"n_layers\"]\n    config.n_heads = params[\"n_heads\"]\n    config.n_kv_heads = params.get('n_kv_heads') or params['n_heads']\n    config.multiple_of = params[\"multiple_of\"]\n    config.norm_eps = params[\"norm_eps\"]\n\n    config.vocab_size = state_dict['tok_embeddings.weight'].shape[0]\n    config.max_seq_len = 2048\n\n\n    # create a new Transformer object and set weights\n    model = Transformer(config)\n\n    model.tok_embeddings.weight = nn.Parameter(state_dict['tok_embeddings.weight'])\n    model.norm.weight = nn.Parameter(state_dict['norm.weight'])\n\n    for layer in model.layers:\n        i = layer.layer_id\n        layer.attention_norm.weight = nn.Parameter(state_dict[f'layers.{i}.attention_norm.weight'])\n        layer.attention.wq.weight = nn.Parameter(state_dict[f'layers.{i}.attention.wq.weight'])\n        layer.attention.wk.weight = nn.Parameter(state_dict[f'layers.{i}.attention.wk.weight'])\n        layer.attention.wv.weight = nn.Parameter(state_dict[f'layers.{i}.attention.wv.weight'])\n        layer.attention.wo.weight = nn.Parameter(state_dict[f'layers.{i}.attention.wo.weight'])\n        layer.ffn_norm.weight = nn.Parameter(state_dict[f'layers.{i}.ffn_norm.weight'])\n        layer.feed_forward.w1.weight = nn.Parameter(state_dict[f'layers.{i}.feed_forward.w1.weight'])\n        layer.feed_forward.w2.weight = nn.Parameter(state_dict[f'layers.{i}.feed_forward.w2.weight'])\n        layer.feed_forward.w3.weight = nn.Parameter(state_dict[f'layers.{i}.feed_forward.w3.weight'])\n\n    # final classifier\n    model.output.weight = nn.Parameter(state_dict['output.weight'])\n    model.eval()\n    return model\n\ndef load_hf_model(model_path):\n\n    try:\n        from transformers import AutoModelForCausalLM\n    except ImportError:\n        print(\"Error: transformers package is required to load huggingface models\")\n        print(\"Please run `pip install transformers` to install it\")\n        return None\n\n    # load HF model\n    hf_model = AutoModelForCausalLM.from_pretrained(model_path)\n    hf_dict = hf_model.state_dict()\n\n    # convert LlamaConfig to ModelArgs\n    config = ModelArgs()\n    config.dim = hf_model.config.hidden_size\n    config.n_layers = hf_model.config.num_hidden_layers\n    config.n_heads = hf_model.config.num_attention_heads\n    config.n_kv_heads = hf_model.config.num_attention_heads\n    config.vocab_size = hf_model.config.vocab_size\n    config.hidden_dim = hf_model.config.intermediate_size\n    config.norm_eps = hf_model.config.rms_norm_eps\n    config.max_seq_len = hf_model.config.max_position_embeddings\n\n    # create a new Transformer object and set weights\n    model = Transformer(config)\n\n    model.tok_embeddings.weight = nn.Parameter(hf_dict['model.embed_tokens.weight'])\n    model.norm.weight = nn.Parameter(hf_dict['model.norm.weight'])\n\n    # huggingface permutes WQ and WK, this function reverses it\n    def permute_reverse(w, n_heads=config.n_heads, dim1=config.dim, dim2=config.dim):\n        return w.view(n_heads, 2, dim1 // n_heads // 2, dim2).transpose(1, 2).reshape(dim1, dim2)\n\n    for layer in model.layers:\n        i = layer.layer_id\n        layer.attention_norm.weight = nn.Parameter(hf_dict[f'model.layers.{i}.input_layernorm.weight'])\n        layer.attention.wq.weight = nn.Parameter(permute_reverse(hf_dict[f'model.layers.{i}.self_attn.q_proj.weight']))\n        layer.attention.wk.weight = nn.Parameter(permute_reverse(hf_dict[f'model.layers.{i}.self_attn.k_proj.weight']))\n        layer.attention.wv.weight = nn.Parameter(hf_dict[f'model.layers.{i}.self_attn.v_proj.weight'])\n        layer.attention.wo.weight = nn.Parameter(hf_dict[f'model.layers.{i}.self_attn.o_proj.weight'])\n        layer.ffn_norm.weight = nn.Parameter(hf_dict[f'model.layers.{i}.post_attention_layernorm.weight'])\n        layer.feed_forward.w1.weight = nn.Parameter(hf_dict[f'model.layers.{i}.mlp.gate_proj.weight'])\n        layer.feed_forward.w2.weight = nn.Parameter(hf_dict[f'model.layers.{i}.mlp.down_proj.weight'])\n        layer.feed_forward.w3.weight = nn.Parameter(hf_dict[f'model.layers.{i}.mlp.up_proj.weight'])\n\n    # final classifier\n    model.output.weight = nn.Parameter(hf_dict['lm_head.weight'])\n    model.eval()\n    return model\n\n\n# -----------------------------------------------------------------------------\n# API entrypoint\n\ndef model_export(model, filepath, version, dtype=torch.float32):\n    \"\"\"\n    Versions docs:\n    v-1:huggingface export, i.e. intended for use outside of this repo, in HF\n    v0: legacy llama2.c float format, DEPRECATED\n    v1: float32 export\n    v2: int8 quantized Q8_0 export, similar to llama.cpp, in groups\n    # TODO: add dtype export support for other versions (?)\n    \"\"\"\n    if version == 0:\n        legacy_export(model, filepath)\n    elif version == 1:\n        version1_export(model, filepath)\n    elif version == 2:\n        version2_export(model, filepath)\n    elif version == -1:\n        hf_export(model, filepath, dtype)\n    else:\n        raise ValueError(f\"unknown version {version}\")\n\ndef torchscript_export(model, filepath, zero_params=False, gzip_output=False):\n    \"\"\"\n    (This was submitted via a PR earlier. Leaving it here, but \"orphaned\" for now)\n    Saves the model as a TorchScript.\n    The resulting file can be loaded in C++ code and then used for training or\n    inference with:\n        #include <torch/script.h>\n        torch::jit::Module module = torch::jit::load(\"model.pt\")\n    Note that the serialized model includes the initial parameters and with the default\n    ModelArgs the file is 59M and gzips down to 55M. If you want to serialize/distribute\n    the model parameters separately you can zero out the parameters before saving it and\n    it will gzip down to 780K.\n    \"\"\"\n\n    # If requested zero params before saving the model. This is useful in\n    # conjunction with gzip_output.\n    if zero_params:\n        for p in model.parameters():\n            p.detach().zero_()\n\n    torch.jit.save(torch.jit.script(model), filepath)\n\n    if gzip_output:\n        with open(filepath, \"rb\") as f_in:\n            with gzip.open(f\"{filepath}.gz\", \"wb\") as f_out:\n                shutil.copyfileobj(f_in, f_out)\n        os.unlink(filepath)\n\n# -----------------------------------------------------------------------------\n# CLI entrypoint\n\nif __name__ == \"__main__\":\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"filepath\", type=str, help=\"the output filepath\")\n    parser.add_argument(\"--version\", default=0, type=int, help=\"the version to export with\")\n    parser.add_argument(\"--dtype\", type=str, help=\"dtype of the model (fp16, fp32)\", default=\"fp32\")\n    group = parser.add_mutually_exclusive_group(required=True)\n    group.add_argument(\"--checkpoint\", type=str, help=\"model checkpoint, .pt file\")\n    group.add_argument(\"--meta-llama\", type=str, help=\"meta llama model path\")\n    group.add_argument(\"--hf\", type=str, help=\"huggingface model path\")\n    args = parser.parse_args()\n    dtype = {\"fp16\": torch.float16, \"fp32\": torch.float32}[args.dtype]\n\n    if args.checkpoint:\n        model = load_checkpoint(args.checkpoint)\n    elif args.meta_llama:\n        model = load_meta_model(args.meta_llama)\n    elif args.hf:\n        model = load_hf_model(args.hf)\n\n    if model is None:\n        parser.error(\"Can't load input model!\")\n\n    # export\n    model_export(model, args.filepath, args.version, args.dtype)\n"
        },
        {
          "name": "model.py",
          "type": "blob",
          "size": 14.9306640625,
          "content": "import math\nimport struct\nimport inspect\nfrom dataclasses import dataclass\nfrom typing import Any, Optional, Tuple\n\nimport numpy as np\nimport torch\nimport torch.nn.functional as F\nfrom torch import nn\n\n@dataclass\nclass ModelArgs:\n    # default hyperparameters for the Llama 7B model\n    dim: int = 4096\n    n_layers: int = 32\n    n_heads: int = 32\n    n_kv_heads: Optional[int] = None\n    vocab_size: int = 32000\n    hidden_dim: Optional[int] = None\n    multiple_of: int = 256  # MLP hidden layer size will be multiple of\n    norm_eps: float = 1e-5\n    max_seq_len: int = 2048\n    dropout: float = 0.0\n\n\nclass RMSNorm(torch.nn.Module):\n    def __init__(self, dim: int, eps: float):\n        super().__init__()\n        self.eps = eps\n        self.weight = nn.Parameter(torch.ones(dim))\n\n    def _norm(self, x):\n        return x * torch.rsqrt(x.pow(2).mean(-1, keepdim=True) + self.eps)\n\n    def forward(self, x):\n        output = self._norm(x.float()).type_as(x)\n        return output * self.weight\n\n\ndef precompute_freqs_cis(dim: int, end: int, theta: float = 10000.0):\n    freqs = 1.0 / (theta ** (torch.arange(0, dim, 2)[: (dim // 2)].float() / dim))\n    t = torch.arange(end, device=freqs.device)  # type: ignore\n    freqs = torch.outer(t, freqs).float()  # type: ignore\n    freqs_cos = torch.cos(freqs)  # real part\n    freqs_sin = torch.sin(freqs)  # imaginary part\n    return freqs_cos, freqs_sin\n\ndef reshape_for_broadcast(freqs_cis: torch.Tensor, x: torch.Tensor):\n    ndim = x.ndim\n    assert 0 <= 1 < ndim\n    assert freqs_cis.shape == (x.shape[1], x.shape[-1])\n    shape = [d if i == 1 or i == ndim - 1 else 1 for i, d in enumerate(x.shape)]\n    return freqs_cis.view(shape)\n\ndef apply_rotary_emb(\n    xq: torch.Tensor,\n    xk: torch.Tensor,\n    freqs_cos: torch.Tensor,\n    freqs_sin: torch.Tensor\n) -> Tuple[torch.Tensor, torch.Tensor]:\n\n    # reshape xq and xk to match the complex representation\n    xq_r, xq_i = xq.float().reshape(xq.shape[:-1] + (-1, 2)).unbind(-1)\n    xk_r, xk_i = xk.float().reshape(xk.shape[:-1] + (-1, 2)).unbind(-1)\n\n    # reshape freqs_cos and freqs_sin for broadcasting\n    freqs_cos = reshape_for_broadcast(freqs_cos, xq_r)\n    freqs_sin = reshape_for_broadcast(freqs_sin, xq_r)\n\n    # apply rotation using real numbers\n    xq_out_r = xq_r * freqs_cos - xq_i * freqs_sin\n    xq_out_i = xq_r * freqs_sin + xq_i * freqs_cos\n    xk_out_r = xk_r * freqs_cos - xk_i * freqs_sin\n    xk_out_i = xk_r * freqs_sin + xk_i * freqs_cos\n\n    # flatten last two dimensions\n    xq_out = torch.stack([xq_out_r, xq_out_i], dim=-1).flatten(3)\n    xk_out = torch.stack([xk_out_r, xk_out_i], dim=-1).flatten(3)\n\n    return xq_out.type_as(xq), xk_out.type_as(xk)\n\ndef repeat_kv(x: torch.Tensor, n_rep: int) -> torch.Tensor:\n    \"\"\"torch.repeat_interleave(x, dim=2, repeats=n_rep)\"\"\"\n    bs, slen, n_kv_heads, head_dim = x.shape\n    if n_rep == 1:\n        return x\n    return (\n        x[:, :, :, None, :]\n        .expand(bs, slen, n_kv_heads, n_rep, head_dim)\n        .reshape(bs, slen, n_kv_heads * n_rep, head_dim)\n    )\n\nclass Attention(nn.Module):\n    def __init__(self, args: ModelArgs):\n        super().__init__()\n        self.n_kv_heads = args.n_heads if args.n_kv_heads is None else args.n_kv_heads\n        assert args.n_heads % self.n_kv_heads == 0\n        model_parallel_size = 1\n        self.n_local_heads = args.n_heads // model_parallel_size\n        self.n_local_kv_heads = self.n_kv_heads // model_parallel_size\n        self.n_rep = self.n_local_heads // self.n_local_kv_heads\n        self.head_dim = args.dim // args.n_heads\n        self.wq = nn.Linear(args.dim, args.n_heads * self.head_dim, bias=False)\n        self.wk = nn.Linear(args.dim, self.n_kv_heads * self.head_dim, bias=False)\n        self.wv = nn.Linear(args.dim, self.n_kv_heads * self.head_dim, bias=False)\n        self.wo = nn.Linear(args.n_heads * self.head_dim, args.dim, bias=False)\n        self.attn_dropout = nn.Dropout(args.dropout)\n        self.resid_dropout = nn.Dropout(args.dropout)\n        self.dropout = args.dropout\n\n        # use flash attention or a manual implementation?\n        self.flash = hasattr(torch.nn.functional, 'scaled_dot_product_attention')\n        if not self.flash:\n            print(\"WARNING: using slow attention. Flash Attention requires PyTorch >= 2.0\")\n            mask = torch.full((1, 1, args.max_seq_len, args.max_seq_len), float(\"-inf\"))\n            mask = torch.triu(mask, diagonal=1)\n            self.register_buffer(\"mask\", mask)\n\n    def forward(\n        self,\n        x: torch.Tensor,\n        freqs_cos: torch.Tensor,\n        freqs_sin: torch.Tensor,\n    ):\n        bsz, seqlen, _ = x.shape\n\n        # QKV\n        xq, xk, xv = self.wq(x), self.wk(x), self.wv(x)\n        xq = xq.view(bsz, seqlen, self.n_local_heads, self.head_dim)\n        xk = xk.view(bsz, seqlen, self.n_local_kv_heads, self.head_dim)\n        xv = xv.view(bsz, seqlen, self.n_local_kv_heads, self.head_dim)\n\n        # RoPE relative positional embeddings\n        xq, xk = apply_rotary_emb(xq, xk, freqs_cos, freqs_sin)\n\n        # grouped multiquery attention: expand out keys and values\n        xk = repeat_kv(xk, self.n_rep)  # (bs, seqlen, n_local_heads, head_dim)\n        xv = repeat_kv(xv, self.n_rep)  # (bs, seqlen, n_local_heads, head_dim)\n\n        # make heads into a batch dimension\n        xq = xq.transpose(1, 2)  # (bs, n_local_heads, seqlen, head_dim)\n        xk = xk.transpose(1, 2)\n        xv = xv.transpose(1, 2)\n\n        # flash implementation\n        if self.flash:\n            output = torch.nn.functional.scaled_dot_product_attention(xq, xk, xv, attn_mask=None, dropout_p=self.dropout if self.training else 0.0, is_causal=True)\n        else:\n            # manual implementation\n            scores = torch.matmul(xq, xk.transpose(2, 3)) / math.sqrt(self.head_dim)\n            assert hasattr(self, 'mask')\n            scores = scores + self.mask[:, :, :seqlen, :seqlen]   # (bs, n_local_heads, seqlen, cache_len + seqlen)\n            scores = F.softmax(scores.float(), dim=-1).type_as(xq)\n            scores = self.attn_dropout(scores)\n            output = torch.matmul(scores, xv)  # (bs, n_local_heads, seqlen, head_dim)\n\n        # restore time as batch dimension and concat heads\n        output = output.transpose(1, 2).contiguous().view(bsz, seqlen, -1)\n\n        # final projection into the residual stream\n        output = self.wo(output)\n        output = self.resid_dropout(output)\n        return output\n\n\nclass FeedForward(nn.Module):\n    def __init__(self, dim: int, hidden_dim: int, multiple_of: int, dropout: float):\n        super().__init__()\n        if hidden_dim is None:\n            hidden_dim = 4 * dim\n            hidden_dim = int(2 * hidden_dim / 3)\n            hidden_dim = multiple_of * ((hidden_dim + multiple_of - 1) // multiple_of)\n        self.w1 = nn.Linear(dim, hidden_dim, bias=False)\n        self.w2 = nn.Linear(hidden_dim, dim, bias=False)\n        self.w3 = nn.Linear(dim, hidden_dim, bias=False)\n        self.dropout = nn.Dropout(dropout)\n\n    def forward(self, x):\n        return self.dropout(self.w2(F.silu(self.w1(x)) * self.w3(x)))\n\n\nclass TransformerBlock(nn.Module):\n    def __init__(self, layer_id: int, args: ModelArgs):\n        super().__init__()\n        self.n_heads = args.n_heads\n        self.dim = args.dim\n        self.head_dim = args.dim // args.n_heads\n        self.attention = Attention(args)\n        self.feed_forward = FeedForward(\n            dim=args.dim,\n            hidden_dim=args.hidden_dim,\n            multiple_of=args.multiple_of,\n            dropout=args.dropout,\n        )\n        self.layer_id = layer_id\n        self.attention_norm = RMSNorm(args.dim, eps=args.norm_eps)\n        self.ffn_norm = RMSNorm(args.dim, eps=args.norm_eps)\n\n    def forward(self, x, freqs_cos, freqs_sin):\n        h = x + self.attention.forward(self.attention_norm(x), freqs_cos, freqs_sin)\n        out = h + self.feed_forward.forward(self.ffn_norm(h))\n        return out\n\n\nclass Transformer(nn.Module):\n    last_loss: Optional[torch.Tensor]\n\n    def __init__(self, params: ModelArgs):\n        super().__init__()\n        self.params = params\n        self.vocab_size = params.vocab_size\n        self.n_layers = params.n_layers\n\n        self.tok_embeddings = nn.Embedding(params.vocab_size, params.dim)\n        self.dropout = nn.Dropout(params.dropout)\n        self.layers = torch.nn.ModuleList()\n        for layer_id in range(params.n_layers):\n            self.layers.append(TransformerBlock(layer_id, params))\n        self.norm = RMSNorm(params.dim, eps=params.norm_eps)\n        self.output = nn.Linear(params.dim, params.vocab_size, bias=False)\n\n        # share the unembedding parameters with the embedding parameters\n        self.tok_embeddings.weight = self.output.weight # https://paperswithcode.com/method/weight-tying\n\n        # some useful precompute for the RoPE relative positional embeddings\n        freqs_cos, freqs_sin = precompute_freqs_cis(self.params.dim // self.params.n_heads, self.params.max_seq_len)\n        self.register_buffer(\"freqs_cos\", freqs_cos, persistent=False)\n        self.register_buffer(\"freqs_sin\", freqs_sin, persistent=False)\n\n        # init all weights\n        self.apply(self._init_weights)\n        # apply special scaled init to the residual projections, per GPT-2 paper\n        for pn, p in self.named_parameters():\n            if pn.endswith('w3.weight') or pn.endswith('wo.weight'):\n                torch.nn.init.normal_(p, mean=0.0, std=0.02/math.sqrt(2 * params.n_layers))\n\n        # Initialize attribute for the loss of the last forward call. This will be set if the forward is called with a targets tensor.\n        self.last_loss = None\n\n    def _init_weights(self, module):\n        if isinstance(module, nn.Linear):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n            if module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.Embedding):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n\n    def forward(self, tokens: torch.Tensor, targets: Optional[torch.Tensor] = None) -> torch.Tensor:\n        _bsz, seqlen = tokens.shape\n        h = self.tok_embeddings(tokens)\n        h = self.dropout(h)\n        freqs_cos = self.freqs_cos[:seqlen]\n        freqs_sin = self.freqs_sin[:seqlen]\n\n        for layer in self.layers:\n            h = layer(h, freqs_cos, freqs_sin)\n        h = self.norm(h)\n\n        if targets is not None:\n            # if we are given some desired targets also calculate the loss\n            logits = self.output(h)\n            self.last_loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n        else:\n            # inference-time mini-optimization: only forward the output on the very last position\n            logits = self.output(h[:, [-1], :]) # note: using list [-1] to preserve the time dim\n            self.last_loss = None\n\n        return logits\n\n    def configure_optimizers(self, weight_decay, learning_rate, betas, device_type):\n        # start with all of the candidate parameters\n        param_dict = {pn: p for pn, p in self.named_parameters()}\n        # filter out those that do not require grad\n        param_dict = {pn: p for pn, p in param_dict.items() if p.requires_grad}\n        # create optim groups. Any parameters that is 2D will be weight decayed, otherwise no.\n        # i.e. all weight tensors in matmuls + embeddings decay, all biases and layernorms don't.\n        decay_params = [p for n, p in param_dict.items() if p.dim() >= 2]\n        nodecay_params = [p for n, p in param_dict.items() if p.dim() < 2]\n        optim_groups = [\n            {'params': decay_params, 'weight_decay': weight_decay},\n            {'params': nodecay_params, 'weight_decay': 0.0}\n        ]\n        num_decay_params = sum(p.numel() for p in decay_params)\n        num_nodecay_params = sum(p.numel() for p in nodecay_params)\n        print(f\"num decayed parameter tensors: {len(decay_params)}, with {num_decay_params:,} parameters\")\n        print(f\"num non-decayed parameter tensors: {len(nodecay_params)}, with {num_nodecay_params:,} parameters\")\n        # Create AdamW optimizer and use the fused version if it is available\n        fused_available = 'fused' in inspect.signature(torch.optim.AdamW).parameters\n        use_fused = fused_available and device_type == 'cuda'\n        extra_args = dict(fused=True) if use_fused else dict()\n        optimizer = torch.optim.AdamW(optim_groups, lr=learning_rate, betas=betas, **extra_args)\n        print(f\"using fused AdamW: {use_fused}\")\n\n        return optimizer\n\n    def estimate_mfu(self, fwdbwd_per_iter, dt):\n        \"\"\" estimate model flops utilization (MFU) in units of A100 bfloat16 peak FLOPS \"\"\"\n        # first estimate the number of flops we do per iteration.\n        # see PaLM paper Appendix B as ref: https://arxiv.org/abs/2204.02311\n        N = sum(p.numel() for p in self.parameters())\n        cfg = self.params\n        L, H, Q, T = cfg.n_layers, cfg.n_heads, cfg.dim//cfg.n_heads, cfg.max_seq_len\n        flops_per_token = 6*N + 12*L*H*Q*T\n        flops_per_fwdbwd = flops_per_token * T\n        flops_per_iter = flops_per_fwdbwd * fwdbwd_per_iter\n        # express our flops throughput as ratio of A100 bfloat16 peak flops\n        flops_achieved = flops_per_iter * (1.0/dt) # per second\n        flops_promised = 312e12 # A100 GPU bfloat16 peak flops is 312 TFLOPS\n        mfu = flops_achieved / flops_promised\n        return mfu\n\n    @torch.inference_mode()\n    def generate(self, idx, max_new_tokens, temperature=1.0, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        Also note this is a super inefficient version of sampling with no key/value cache.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.params.max_seq_len else idx[:, -self.params.max_seq_len:]\n            # forward the model to get the logits for the index in the sequence\n            logits = self(idx_cond)\n            logits = logits[:, -1, :] # crop to just the final time step\n            if temperature == 0.0:\n                # \"sample\" the single most likely index\n                _, idx_next = torch.topk(logits, k=1, dim=-1)\n            else:\n                # pluck the logits at the final step and scale by desired temperature\n                logits = logits / temperature\n                # optionally crop the logits to only the top k options\n                if top_k is not None:\n                    v, _ = torch.topk(logits, min(top_k, logits.size(-1)))\n                    logits[logits < v[:, [-1]]] = -float('Inf')\n                # apply softmax to convert logits to (normalized) probabilities\n                probs = F.softmax(logits, dim=-1)\n                idx_next = torch.multinomial(probs, num_samples=1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.1044921875,
          "content": "numpy==1.23.5\npytest==7.4.0\nRequests==2.31.0\nsentencepiece==0.1.99\ntorch==2.0.1\ntqdm==4.64.1\nwandb==0.15.5\n"
        },
        {
          "name": "run.c",
          "type": "blob",
          "size": 37.6416015625,
          "content": "/* Inference for Llama-2 Transformer model in pure C */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <time.h>\n#include <math.h>\n#include <string.h>\n#include <fcntl.h>\n#if defined _WIN32\n    #include \"win.h\"\n#else\n    #include <unistd.h>\n    #include <sys/mman.h>\n#endif\n// ----------------------------------------------------------------------------\n// Transformer model\n\ntypedef struct {\n    int dim; // transformer dimension\n    int hidden_dim; // for ffn layers\n    int n_layers; // number of layers\n    int n_heads; // number of query heads\n    int n_kv_heads; // number of key/value heads (can be < query heads because of multiquery)\n    int vocab_size; // vocabulary size, usually 256 (byte-level)\n    int seq_len; // max sequence length\n} Config;\n\ntypedef struct {\n    // token embedding table\n    float* token_embedding_table;    // (vocab_size, dim)\n    // weights for rmsnorms\n    float* rms_att_weight; // (layer, dim) rmsnorm weights\n    float* rms_ffn_weight; // (layer, dim)\n    // weights for matmuls. note dim == n_heads * head_size\n    float* wq; // (layer, dim, n_heads * head_size)\n    float* wk; // (layer, dim, n_kv_heads * head_size)\n    float* wv; // (layer, dim, n_kv_heads * head_size)\n    float* wo; // (layer, n_heads * head_size, dim)\n    // weights for ffn\n    float* w1; // (layer, hidden_dim, dim)\n    float* w2; // (layer, dim, hidden_dim)\n    float* w3; // (layer, hidden_dim, dim)\n    // final rmsnorm\n    float* rms_final_weight; // (dim,)\n    // (optional) classifier weights for the logits, on the last layer\n    float* wcls;\n} TransformerWeights;\n\ntypedef struct {\n    // current wave of activations\n    float *x; // activation at current time stamp (dim,)\n    float *xb; // same, but inside a residual branch (dim,)\n    float *xb2; // an additional buffer just for convenience (dim,)\n    float *hb; // buffer for hidden dimension in the ffn (hidden_dim,)\n    float *hb2; // buffer for hidden dimension in the ffn (hidden_dim,)\n    float *q; // query (dim,)\n    float *k; // key (dim,)\n    float *v; // value (dim,)\n    float *att; // buffer for scores/attention values (n_heads, seq_len)\n    float *logits; // output logits\n    // kv cache\n    float* key_cache;   // (layer, seq_len, dim)\n    float* value_cache; // (layer, seq_len, dim)\n} RunState;\n\ntypedef struct {\n    Config config; // the hyperparameters of the architecture (the blueprint)\n    TransformerWeights weights; // the weights of the model\n    RunState state; // buffers for the \"wave\" of activations in the forward pass\n    // some more state needed to properly clean up the memory mapping (sigh)\n    int fd; // file descriptor for memory mapping\n    float* data; // memory mapped data pointer\n    ssize_t file_size; // size of the checkpoint file in bytes\n} Transformer;\n\nvoid malloc_run_state(RunState* s, Config* p) {\n    // we calloc instead of malloc to keep valgrind happy\n    int kv_dim = (p->dim * p->n_kv_heads) / p->n_heads;\n    s->x = calloc(p->dim, sizeof(float));\n    s->xb = calloc(p->dim, sizeof(float));\n    s->xb2 = calloc(p->dim, sizeof(float));\n    s->hb = calloc(p->hidden_dim, sizeof(float));\n    s->hb2 = calloc(p->hidden_dim, sizeof(float));\n    s->q = calloc(p->dim, sizeof(float));\n    s->key_cache = calloc(p->n_layers * p->seq_len * kv_dim, sizeof(float));\n    s->value_cache = calloc(p->n_layers * p->seq_len * kv_dim, sizeof(float));\n    s->att = calloc(p->n_heads * p->seq_len, sizeof(float));\n    s->logits = calloc(p->vocab_size, sizeof(float));\n    // ensure all mallocs went fine\n    if (!s->x || !s->xb || !s->xb2 || !s->hb || !s->hb2 || !s->q\n     || !s->key_cache || !s->value_cache || !s->att || !s->logits) {\n        fprintf(stderr, \"malloc failed!\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nvoid free_run_state(RunState* s) {\n    free(s->x);\n    free(s->xb);\n    free(s->xb2);\n    free(s->hb);\n    free(s->hb2);\n    free(s->q);\n    free(s->att);\n    free(s->logits);\n    free(s->key_cache);\n    free(s->value_cache);\n}\n\nvoid memory_map_weights(TransformerWeights *w, Config* p, float* ptr, int shared_weights) {\n    int head_size = p->dim / p->n_heads;\n    // make sure the multiplications below are done in 64bit to fit the parameter counts of 13B+ models\n    unsigned long long n_layers = p->n_layers;\n    w->token_embedding_table = ptr;\n    ptr += p->vocab_size * p->dim;\n    w->rms_att_weight = ptr;\n    ptr += n_layers * p->dim;\n    w->wq = ptr;\n    ptr += n_layers * p->dim * (p->n_heads * head_size);\n    w->wk = ptr;\n    ptr += n_layers * p->dim * (p->n_kv_heads * head_size);\n    w->wv = ptr;\n    ptr += n_layers * p->dim * (p->n_kv_heads * head_size);\n    w->wo = ptr;\n    ptr += n_layers * (p->n_heads * head_size) * p->dim;\n    w->rms_ffn_weight = ptr;\n    ptr += n_layers * p->dim;\n    w->w1 = ptr;\n    ptr += n_layers * p->dim * p->hidden_dim;\n    w->w2 = ptr;\n    ptr += n_layers * p->hidden_dim * p->dim;\n    w->w3 = ptr;\n    ptr += n_layers * p->dim * p->hidden_dim;\n    w->rms_final_weight = ptr;\n    ptr += p->dim;\n    ptr += p->seq_len * head_size / 2; // skip what used to be freq_cis_real (for RoPE)\n    ptr += p->seq_len * head_size / 2; // skip what used to be freq_cis_imag (for RoPE)\n    w->wcls = shared_weights ? w->token_embedding_table : ptr;\n}\n\nvoid read_checkpoint(char* checkpoint, Config* config, TransformerWeights* weights,\n                     int* fd, float** data, ssize_t* file_size) {\n    FILE *file = fopen(checkpoint, \"rb\");\n    if (!file) { fprintf(stderr, \"Couldn't open file %s\\n\", checkpoint); exit(EXIT_FAILURE); }\n    // read in the config header\n    if (fread(config, sizeof(Config), 1, file) != 1) { exit(EXIT_FAILURE); }\n    // negative vocab size is hacky way of signaling unshared weights. bit yikes.\n    int shared_weights = config->vocab_size > 0 ? 1 : 0;\n    config->vocab_size = abs(config->vocab_size);\n    // figure out the file size\n    fseek(file, 0, SEEK_END); // move file pointer to end of file\n    *file_size = ftell(file); // get the file size, in bytes\n    fclose(file);\n    // memory map the Transformer weights into the data pointer\n    *fd = open(checkpoint, O_RDONLY); // open in read only mode\n    if (*fd == -1) { fprintf(stderr, \"open failed!\\n\"); exit(EXIT_FAILURE); }\n    *data = mmap(NULL, *file_size, PROT_READ, MAP_PRIVATE, *fd, 0);\n    if (*data == MAP_FAILED) { fprintf(stderr, \"mmap failed!\\n\"); exit(EXIT_FAILURE); }\n    float* weights_ptr = *data + sizeof(Config)/sizeof(float);\n    memory_map_weights(weights, config, weights_ptr, shared_weights);\n}\n\nvoid build_transformer(Transformer *t, char* checkpoint_path) {\n    // read in the Config and the Weights from the checkpoint\n    read_checkpoint(checkpoint_path, &t->config, &t->weights, &t->fd, &t->data, &t->file_size);\n    // allocate the RunState buffers\n    malloc_run_state(&t->state, &t->config);\n}\n\nvoid free_transformer(Transformer* t) {\n    // close the memory mapping\n    if (t->data != MAP_FAILED) { munmap(t->data, t->file_size); }\n    if (t->fd != -1) { close(t->fd); }\n    // free the RunState buffers\n    free_run_state(&t->state);\n}\n\n// ----------------------------------------------------------------------------\n// neural net blocks; the dynamics of the Transformer\n\nvoid rmsnorm(float* o, float* x, float* weight, int size) {\n    // calculate sum of squares\n    float ss = 0.0f;\n    for (int j = 0; j < size; j++) {\n        ss += x[j] * x[j];\n    }\n    ss /= size;\n    ss += 1e-5f;\n    ss = 1.0f / sqrtf(ss);\n    // normalize and scale\n    for (int j = 0; j < size; j++) {\n        o[j] = weight[j] * (ss * x[j]);\n    }\n}\n\nvoid softmax(float* x, int size) {\n    // find max value (for numerical stability)\n    float max_val = x[0];\n    for (int i = 1; i < size; i++) {\n        if (x[i] > max_val) {\n            max_val = x[i];\n        }\n    }\n    // exp and sum\n    float sum = 0.0f;\n    for (int i = 0; i < size; i++) {\n        x[i] = expf(x[i] - max_val);\n        sum += x[i];\n    }\n    // normalize\n    for (int i = 0; i < size; i++) {\n        x[i] /= sum;\n    }\n}\n\nvoid matmul(float* xout, float* x, float* w, int n, int d) {\n    // W (d,n) @ x (n,) -> xout (d,)\n    // by far the most amount of time is spent inside this little function\n    int i;\n    #pragma omp parallel for private(i)\n    for (i = 0; i < d; i++) {\n        float val = 0.0f;\n        for (int j = 0; j < n; j++) {\n            val += w[i * n + j] * x[j];\n        }\n        xout[i] = val;\n    }\n}\n\nfloat* forward(Transformer* transformer, int token, int pos) {\n\n    // a few convenience variables\n    Config* p = &transformer->config;\n    TransformerWeights* w = &transformer->weights;\n    RunState* s = &transformer->state;\n    float *x = s->x;\n    int dim = p->dim;\n    int kv_dim = (p->dim * p->n_kv_heads) / p->n_heads;\n    int kv_mul = p->n_heads / p->n_kv_heads; // integer multiplier of the kv sharing in multiquery\n    int hidden_dim =  p->hidden_dim;\n    int head_size = dim / p->n_heads;\n\n    // copy the token embedding into x\n    float* content_row = w->token_embedding_table + token * dim;\n    memcpy(x, content_row, dim*sizeof(*x));\n\n    // forward all the layers\n    for(unsigned long long l = 0; l < p->n_layers; l++) {\n\n        // attention rmsnorm\n        rmsnorm(s->xb, x, w->rms_att_weight + l*dim, dim);\n\n        // key and value point to the kv cache\n        int loff = l * p->seq_len * kv_dim; // kv cache layer offset for convenience\n        s->k = s->key_cache + loff + pos * kv_dim;\n        s->v = s->value_cache + loff + pos * kv_dim;\n\n        // qkv matmuls for this position\n        matmul(s->q, s->xb, w->wq + l*dim*dim, dim, dim);\n        matmul(s->k, s->xb, w->wk + l*dim*kv_dim, dim, kv_dim);\n        matmul(s->v, s->xb, w->wv + l*dim*kv_dim, dim, kv_dim);\n\n        // RoPE relative positional encoding: complex-valued rotate q and k in each head\n        for (int i = 0; i < dim; i+=2) {\n            int head_dim = i % head_size;\n            float freq = 1.0f / powf(10000.0f, head_dim / (float)head_size);\n            float val = pos * freq;\n            float fcr = cosf(val);\n            float fci = sinf(val);\n            int rotn = i < kv_dim ? 2 : 1; // how many vectors? 2 = q & k, 1 = q only\n            for (int v = 0; v < rotn; v++) {\n                float* vec = v == 0 ? s->q : s->k; // the vector to rotate (query or key)\n                float v0 = vec[i];\n                float v1 = vec[i+1];\n                vec[i]   = v0 * fcr - v1 * fci;\n                vec[i+1] = v0 * fci + v1 * fcr;\n            }\n        }\n\n        // multihead attention. iterate over all heads\n        int h;\n        #pragma omp parallel for private(h)\n        for (h = 0; h < p->n_heads; h++) {\n            // get the query vector for this head\n            float* q = s->q + h * head_size;\n            // attention scores for this head\n            float* att = s->att + h * p->seq_len;\n            // iterate over all timesteps, including the current one\n            for (int t = 0; t <= pos; t++) {\n                // get the key vector for this head and at this timestep\n                float* k = s->key_cache + loff + t * kv_dim + (h / kv_mul) * head_size;\n                // calculate the attention score as the dot product of q and k\n                float score = 0.0f;\n                for (int i = 0; i < head_size; i++) {\n                    score += q[i] * k[i];\n                }\n                score /= sqrtf(head_size);\n                // save the score to the attention buffer\n                att[t] = score;\n            }\n\n            // softmax the scores to get attention weights, from 0..pos inclusively\n            softmax(att, pos + 1);\n\n            // weighted sum of the values, store back into xb\n            float* xb = s->xb + h * head_size;\n            memset(xb, 0, head_size * sizeof(float));\n            for (int t = 0; t <= pos; t++) {\n                // get the value vector for this head and at this timestep\n                float* v = s->value_cache + loff + t * kv_dim + (h / kv_mul) * head_size;\n                // get the attention weight for this timestep\n                float a = att[t];\n                // accumulate the weighted value into xb\n                for (int i = 0; i < head_size; i++) {\n                    xb[i] += a * v[i];\n                }\n            }\n        }\n\n        // final matmul to get the output of the attention\n        matmul(s->xb2, s->xb, w->wo + l*dim*dim, dim, dim);\n\n        // residual connection back into x\n        for (int i = 0; i < dim; i++) {\n            x[i] += s->xb2[i];\n        }\n\n        // ffn rmsnorm\n        rmsnorm(s->xb, x, w->rms_ffn_weight + l*dim, dim);\n\n        // Now for FFN in PyTorch we have: self.w2(F.silu(self.w1(x)) * self.w3(x))\n        // first calculate self.w1(x) and self.w3(x)\n        matmul(s->hb, s->xb, w->w1 + l*dim*hidden_dim, dim, hidden_dim);\n        matmul(s->hb2, s->xb, w->w3 + l*dim*hidden_dim, dim, hidden_dim);\n\n        // SwiGLU non-linearity\n        for (int i = 0; i < hidden_dim; i++) {\n            float val = s->hb[i];\n            // silu(x)=x*Ïƒ(x), where Ïƒ(x) is the logistic sigmoid\n            val *= (1.0f / (1.0f + expf(-val)));\n            // elementwise multiply with w3(x)\n            val *= s->hb2[i];\n            s->hb[i] = val;\n        }\n\n        // final matmul to get the output of the ffn\n        matmul(s->xb, s->hb, w->w2 + l*dim*hidden_dim, hidden_dim, dim);\n\n        // residual connection\n        for (int i = 0; i < dim; i++) {\n            x[i] += s->xb[i];\n        }\n    }\n\n    // final rmsnorm\n    rmsnorm(x, x, w->rms_final_weight, dim);\n\n    // classifier into logits\n    matmul(s->logits, x, w->wcls, p->dim, p->vocab_size);\n    return s->logits;\n}\n\n// ----------------------------------------------------------------------------\n// The Byte Pair Encoding (BPE) Tokenizer that translates strings <-> tokens\n\ntypedef struct {\n    char *str;\n    int id;\n} TokenIndex;\n\ntypedef struct {\n    char** vocab;\n    float* vocab_scores;\n    TokenIndex *sorted_vocab;\n    int vocab_size;\n    unsigned int max_token_length;\n    unsigned char byte_pieces[512]; // stores all single-byte strings\n} Tokenizer;\n\nint compare_tokens(const void *a, const void *b) {\n    return strcmp(((TokenIndex*)a)->str, ((TokenIndex*)b)->str);\n}\n\nvoid build_tokenizer(Tokenizer* t, char* tokenizer_path, int vocab_size) {\n    // i should have written the vocab_size into the tokenizer file... sigh\n    t->vocab_size = vocab_size;\n    // malloc space to hold the scores and the strings\n    t->vocab = (char**)malloc(vocab_size * sizeof(char*));\n    t->vocab_scores = (float*)malloc(vocab_size * sizeof(float));\n    t->sorted_vocab = NULL; // initialized lazily\n    for (int i = 0; i < 256; i++) {\n        t->byte_pieces[i * 2] = (unsigned char)i;\n        t->byte_pieces[i * 2 + 1] = '\\0';\n    }\n    // read in the file\n    FILE *file = fopen(tokenizer_path, \"rb\");\n    if (!file) { fprintf(stderr, \"couldn't load %s\\n\", tokenizer_path); exit(EXIT_FAILURE); }\n    if (fread(&t->max_token_length, sizeof(int), 1, file) != 1) { fprintf(stderr, \"failed read\\n\"); exit(EXIT_FAILURE); }\n    int len;\n    for (int i = 0; i < vocab_size; i++) {\n        if (fread(t->vocab_scores + i, sizeof(float), 1, file) != 1) { fprintf(stderr, \"failed read\\n\"); exit(EXIT_FAILURE);}\n        if (fread(&len, sizeof(int), 1, file) != 1) { fprintf(stderr, \"failed read\\n\"); exit(EXIT_FAILURE); }\n        t->vocab[i] = (char *)malloc(len + 1);\n        if (fread(t->vocab[i], len, 1, file) != 1) { fprintf(stderr, \"failed read\\n\"); exit(EXIT_FAILURE); }\n        t->vocab[i][len] = '\\0'; // add the string terminating token\n    }\n    fclose(file);\n}\n\nvoid free_tokenizer(Tokenizer* t) {\n    for (int i = 0; i < t->vocab_size; i++) { free(t->vocab[i]); }\n    free(t->vocab);\n    free(t->vocab_scores);\n    free(t->sorted_vocab);\n}\n\nchar* decode(Tokenizer* t, int prev_token, int token) {\n    char *piece = t->vocab[token];\n    // following BOS (1) token, sentencepiece decoder strips any leading whitespace (see PR #89)\n    if (prev_token == 1 && piece[0] == ' ') { piece++; }\n    // careful, some tokens designate raw bytes, and look like e.g. '<0x01>'\n    // parse this and convert and return the actual byte\n    unsigned char byte_val;\n    if (sscanf(piece, \"<0x%02hhX>\", &byte_val) == 1) {\n        piece = (char*)t->byte_pieces + byte_val * 2;\n    }\n    return piece;\n}\n\nvoid safe_printf(char *piece) {\n    // piece might be a raw byte token, and we only want to print printable chars or whitespace\n    // because some of the other bytes can be various control codes, backspace, etc.\n    if (piece == NULL) { return; }\n    if (piece[0] == '\\0') { return; }\n    if (piece[1] == '\\0') {\n        unsigned char byte_val = piece[0];\n        if (!(isprint(byte_val) || isspace(byte_val))) {\n            return; // bad byte, don't print it\n        }\n    }\n    printf(\"%s\", piece);\n}\n\nint str_lookup(char *str, TokenIndex *sorted_vocab, int vocab_size) {\n    // efficiently find the perfect match for str in vocab, return its index or -1 if not found\n    TokenIndex tok = { .str = str }; // acts as the key to search for\n    TokenIndex *res = bsearch(&tok, sorted_vocab, vocab_size, sizeof(TokenIndex), compare_tokens);\n    return res != NULL ? res->id : -1;\n}\n\nvoid encode(Tokenizer* t, char *text, int8_t bos, int8_t eos, int *tokens, int *n_tokens) {\n    // encode the string text (input) into an upper-bound preallocated tokens[] array\n    // bos != 0 means prepend the BOS token (=1), eos != 0 means append the EOS token (=2)\n    if (text == NULL) { fprintf(stderr, \"cannot encode NULL text\\n\"); exit(EXIT_FAILURE); }\n\n    if (t->sorted_vocab == NULL) {\n        // lazily malloc and sort the vocabulary\n        t->sorted_vocab = malloc(t->vocab_size * sizeof(TokenIndex));\n        for (int i = 0; i < t->vocab_size; i++) {\n            t->sorted_vocab[i].str = t->vocab[i];\n            t->sorted_vocab[i].id = i;\n        }\n        qsort(t->sorted_vocab, t->vocab_size, sizeof(TokenIndex), compare_tokens);\n    }\n\n    // create a temporary buffer that will store merge candidates of always two consecutive tokens\n    // *2 for concat, +1 for null terminator +2 for UTF8 (in case max_token_length is 1)\n    char* str_buffer = malloc((t->max_token_length*2 +1 +2) * sizeof(char));\n    size_t str_len = 0;\n\n    // start at 0 tokens\n    *n_tokens = 0;\n\n    // add optional BOS (=1) token, if desired\n    if (bos) tokens[(*n_tokens)++] = 1;\n\n    // add_dummy_prefix is true by default\n    // so prepend a dummy prefix token to the input string, but only if text != \"\"\n    // TODO: pretty sure this isn't correct in the general case but I don't have the\n    // energy to read more of the sentencepiece code to figure out what it's doing\n    if (text[0] != '\\0') {\n        int dummy_prefix = str_lookup(\" \", t->sorted_vocab, t->vocab_size);\n        tokens[(*n_tokens)++] = dummy_prefix;\n    }\n\n    // Okay UTF-8 time. This will get messy. Here is the reference from Wikipedia:\n    // Code point â†” UTF-8 conversion\n    // First code point\tLast code point\tByte 1\tByte 2\tByte 3\tByte 4\n    // U+0000\tU+007F\t    0xxxxxxx\n    // U+0080\tU+07FF\t    110xxxxx\t10xxxxxx\n    // U+0800\tU+FFFF\t    1110xxxx\t10xxxxxx\t10xxxxxx\n    // U+10000\tU+10FFFF    11110xxx\t10xxxxxx\t10xxxxxx\t10xxxxxx\n\n    // process the raw (UTF-8) byte sequence of the input string\n    for (char *c = text; *c != '\\0'; c++) {\n\n        // reset buffer if the current byte is ASCII or a leading byte\n        // 0xC0 is 11000000, so (*c & 0xC0) keeps the first 2 bits and zeros the rest\n        // 0x80 is 10000000\n        // in UTF-8, all continuation bytes start with \"10\" in first two bits\n        // so in English this is: \"if this byte is not a continuation byte\"\n        if ((*c & 0xC0) != 0x80) {\n            // this byte must be either a leading byte (11...) or an ASCII char (0x...)\n            // => reset our location, as we're starting a new UTF-8 codepoint\n            str_len = 0;\n        }\n\n        // append the current byte to the buffer\n        str_buffer[str_len++] = *c; // ++ is post-increment, incremented after this line\n        str_buffer[str_len] = '\\0';\n\n        // while the next character is a continuation byte, continue appending\n        // but if there are too many of them, just stop to avoid overruning str_buffer size.\n        if ((*(c+1) & 0xC0) == 0x80 && str_len < 4) {\n            continue;\n        }\n\n        // ok c+1 is not a continuation byte, so we've read in a full codepoint\n        int id = str_lookup(str_buffer, t->sorted_vocab, t->vocab_size);\n\n        if (id != -1) {\n            // we found this codepoint in vocab, add it as a token\n            tokens[(*n_tokens)++] = id;\n        } else {\n            // byte_fallback encoding: just encode each byte as a token\n            // +3 is here because the first 3 vocab elements are <unk>, <s>, </s>\n            // so the individual bytes only start at index 3\n            for (int i=0; i < str_len; i++) {\n                tokens[(*n_tokens)++] = (unsigned char)str_buffer[i] + 3;\n            }\n        }\n        str_len = 0; // protect against a sequence of stray UTF8 continuation bytes\n    }\n\n    // merge the best consecutive pair each iteration, according the scores in vocab_scores\n    while (1) {\n        float best_score = -1e10;\n        int best_id = -1;\n        int best_idx = -1;\n\n        for (int i=0; i < (*n_tokens-1); i++) {\n            // check if we can merge the pair (tokens[i], tokens[i+1])\n            sprintf(str_buffer, \"%s%s\", t->vocab[tokens[i]], t->vocab[tokens[i+1]]);\n            int id = str_lookup(str_buffer, t->sorted_vocab, t->vocab_size);\n            if (id != -1 && t->vocab_scores[id] > best_score) {\n                // this merge pair exists in vocab! record its score and position\n                best_score = t->vocab_scores[id];\n                best_id = id;\n                best_idx = i;\n            }\n        }\n\n        if (best_idx == -1) {\n            break; // we couldn't find any more pairs to merge, so we're done\n        }\n\n        // merge the consecutive pair (best_idx, best_idx+1) into new token best_id\n        tokens[best_idx] = best_id;\n        // delete token at position best_idx+1, shift the entire sequence back 1\n        for (int i = best_idx+1; i < (*n_tokens-1); i++) {\n            tokens[i] = tokens[i+1];\n        }\n        (*n_tokens)--; // token length decreased\n    }\n\n    // add optional EOS (=2) token, if desired\n    if (eos) tokens[(*n_tokens)++] = 2;\n\n    free(str_buffer);\n}\n\n// ----------------------------------------------------------------------------\n// The Sampler, which takes logits and returns a sampled token\n// sampling can be done in a few ways: greedy argmax, sampling, top-p sampling\n\ntypedef struct {\n    float prob;\n    int index;\n} ProbIndex; // struct used when sorting probabilities during top-p sampling\n\ntypedef struct {\n    int vocab_size;\n    ProbIndex* probindex; // buffer used in top-p sampling\n    float temperature;\n    float topp;\n    unsigned long long rng_state;\n} Sampler;\n\nint sample_argmax(float* probabilities, int n) {\n    // return the index that has the highest probability\n    int max_i = 0;\n    float max_p = probabilities[0];\n    for (int i = 1; i < n; i++) {\n        if (probabilities[i] > max_p) {\n            max_i = i;\n            max_p = probabilities[i];\n        }\n    }\n    return max_i;\n}\n\nint sample_mult(float* probabilities, int n, float coin) {\n    // sample index from probabilities (they must sum to 1!)\n    // coin is a random number in [0, 1), usually from random_f32()\n    float cdf = 0.0f;\n    for (int i = 0; i < n; i++) {\n        cdf += probabilities[i];\n        if (coin < cdf) {\n            return i;\n        }\n    }\n    return n - 1; // in case of rounding errors\n}\n\nint compare(const void* a, const void* b) {\n    ProbIndex* a_ = (ProbIndex*) a;\n    ProbIndex* b_ = (ProbIndex*) b;\n    if (a_->prob > b_->prob) return -1;\n    if (a_->prob < b_->prob) return 1;\n    return 0;\n}\n\nint sample_topp(float* probabilities, int n, float topp, ProbIndex* probindex, float coin) {\n    // top-p sampling (or \"nucleus sampling\") samples from the smallest set of\n    // tokens that exceed probability topp. This way we never sample tokens that\n    // have very low probabilities and are less likely to go \"off the rails\".\n    // coin is a random number in [0, 1), usually from random_f32()\n\n    int n0 = 0;\n    // quicksort indices in descending order of probabilities\n    // values smaller than (1 - topp) / (n - 1) cannot be part of the result\n    // so for efficiency we crop these out as candidates before sorting\n    const float cutoff = (1.0f - topp) / (n - 1);\n    for (int i = 0; i < n; i++) {\n        if (probabilities[i] >= cutoff) {\n            probindex[n0].index = i;\n            probindex[n0].prob = probabilities[i];\n            n0++;\n        }\n    }\n    qsort(probindex, n0, sizeof(ProbIndex), compare);\n\n    // truncate the list where cumulative probability exceeds topp\n    float cumulative_prob = 0.0f;\n    int last_idx = n0 - 1; // in case of rounding errors consider all elements\n    for (int i = 0; i < n0; i++) {\n        cumulative_prob += probindex[i].prob;\n        if (cumulative_prob > topp) {\n            last_idx = i;\n            break; // we've exceeded topp by including last_idx\n        }\n    }\n\n    // sample from the truncated list\n    float r = coin * cumulative_prob;\n    float cdf = 0.0f;\n    for (int i = 0; i <= last_idx; i++) {\n        cdf += probindex[i].prob;\n        if (r < cdf) {\n            return probindex[i].index;\n        }\n    }\n    return probindex[last_idx].index; // in case of rounding errors\n}\n\nvoid build_sampler(Sampler* sampler, int vocab_size, float temperature, float topp, unsigned long long rng_seed) {\n    sampler->vocab_size = vocab_size;\n    sampler->temperature = temperature;\n    sampler->topp = topp;\n    sampler->rng_state = rng_seed;\n    // buffer only used with nucleus sampling; may not need but it's ~small\n    sampler->probindex = malloc(sampler->vocab_size * sizeof(ProbIndex));\n}\n\nvoid free_sampler(Sampler* sampler) {\n    free(sampler->probindex);\n}\n\nunsigned int random_u32(unsigned long long *state) {\n    // xorshift rng: https://en.wikipedia.org/wiki/Xorshift#xorshift.2A\n    *state ^= *state >> 12;\n    *state ^= *state << 25;\n    *state ^= *state >> 27;\n    return (*state * 0x2545F4914F6CDD1Dull) >> 32;\n}\nfloat random_f32(unsigned long long *state) { // random float32 in [0,1)\n    return (random_u32(state) >> 8) / 16777216.0f;\n}\n\nint sample(Sampler* sampler, float* logits) {\n    // sample the token given the logits and some hyperparameters\n    int next;\n    if (sampler->temperature == 0.0f) {\n        // greedy argmax sampling: take the token with the highest probability\n        next = sample_argmax(logits, sampler->vocab_size);\n    } else {\n        // apply the temperature to the logits\n        for (int q=0; q<sampler->vocab_size; q++) { logits[q] /= sampler->temperature; }\n        // apply softmax to the logits to get the probabilities for next token\n        softmax(logits, sampler->vocab_size);\n        // flip a (float) coin (this is our source of entropy for sampling)\n        float coin = random_f32(&sampler->rng_state);\n        // we sample from this distribution to get the next token\n        if (sampler->topp <= 0 || sampler->topp >= 1) {\n            // simply sample from the predicted probability distribution\n            next = sample_mult(logits, sampler->vocab_size, coin);\n        } else {\n            // top-p (nucleus) sampling, clamping the least likely tokens to zero\n            next = sample_topp(logits, sampler->vocab_size, sampler->topp, sampler->probindex, coin);\n        }\n    }\n    return next;\n}\n\n// ----------------------------------------------------------------------------\n// utilities: time\n\nlong time_in_ms() {\n    // return time in milliseconds, for benchmarking the model speed\n    struct timespec time;\n    clock_gettime(CLOCK_REALTIME, &time);\n    return time.tv_sec * 1000 + time.tv_nsec / 1000000;\n}\n\n// ----------------------------------------------------------------------------\n// generation loop\n\nvoid generate(Transformer *transformer, Tokenizer *tokenizer, Sampler *sampler, char *prompt, int steps) {\n    char *empty_prompt = \"\";\n    if (prompt == NULL) { prompt = empty_prompt; }\n\n    // encode the (string) prompt into tokens sequence\n    int num_prompt_tokens = 0;\n    int* prompt_tokens = (int*)malloc((strlen(prompt)+3) * sizeof(int)); // +3 for '\\0', ?BOS, ?EOS\n    encode(tokenizer, prompt, 1, 0, prompt_tokens, &num_prompt_tokens);\n    if (num_prompt_tokens < 1) {\n        fprintf(stderr, \"something is wrong, expected at least 1 prompt token\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    // start the main loop\n    long start = 0;  // used to time our code, only initialized after first iteration\n    int next;        // will store the next token in the sequence\n    int token = prompt_tokens[0]; // kick off with the first token in the prompt\n    int pos = 0;     // position in the sequence\n    while (pos < steps) {\n\n        // forward the transformer to get logits for the next token\n        float* logits = forward(transformer, token, pos);\n\n        // advance the state machine\n        if (pos < num_prompt_tokens - 1) {\n            // if we are still processing the input prompt, force the next prompt token\n            next = prompt_tokens[pos + 1];\n        } else {\n            // otherwise sample the next token from the logits\n            next = sample(sampler, logits);\n        }\n        pos++;\n\n        // data-dependent terminating condition: the BOS (=1) token delimits sequences\n        if (next == 1) { break; }\n\n        // print the token as string, decode it with the Tokenizer object\n        char* piece = decode(tokenizer, token, next);\n        safe_printf(piece); // same as printf(\"%s\", piece), but skips \"unsafe\" bytes\n        fflush(stdout);\n        token = next;\n\n        // init the timer here because the first iteration can be slower\n        if (start == 0) { start = time_in_ms(); }\n    }\n    printf(\"\\n\");\n\n    // report achieved tok/s (pos-1 because the timer starts after first iteration)\n    if (pos > 1) {\n        long end = time_in_ms();\n        fprintf(stderr, \"achieved tok/s: %f\\n\", (pos-1) / (double)(end-start)*1000);\n    }\n\n    free(prompt_tokens);\n}\n\nvoid read_stdin(const char* guide, char* buffer, size_t bufsize) {\n    // read a line from stdin, up to but not including \\n\n    printf(\"%s\", guide);\n    if (fgets(buffer, bufsize, stdin) != NULL) {\n        size_t len = strlen(buffer);\n        if (len > 0 && buffer[len - 1] == '\\n') {\n            buffer[len - 1] = '\\0'; // strip newline\n        }\n    }\n}\n\n// ----------------------------------------------------------------------------\n// chat loop\n// I manually inspected the tokens for a few chat conversations compared to\n// python reference and that seemed ok, but this was not thoroughly tested and\n// is not safely implemented, it's more a proof of concept atm.\n\nvoid chat(Transformer *transformer, Tokenizer *tokenizer, Sampler *sampler,\n          char *cli_user_prompt, char *cli_system_prompt, int steps) {\n\n    // buffers for reading the system prompt and user prompt from stdin\n    // you'll notice they are soomewhat haphazardly and unsafely set atm\n    char system_prompt[512];\n    char user_prompt[512];\n    char rendered_prompt[1152];\n    int num_prompt_tokens = 0;\n    int* prompt_tokens = (int*)malloc(1152 * sizeof(int));\n    int user_idx;\n\n    // start the main loop\n    int8_t user_turn = 1; // user starts\n    int next;        // will store the next token in the sequence\n    int token;       // stores the current token to feed into the transformer\n    int prev_token;\n    int pos = 0;     // position in the sequence\n    while (pos < steps) {\n\n        // when it is the user's turn to contribute tokens to the dialog...\n        if (user_turn) {\n            // get the (optional) system prompt at position 0\n            if (pos == 0) {\n                // at position 0, the user can also contribute a system prompt\n                if (cli_system_prompt == NULL) {\n                    // system prompt was not passed in, attempt to get it from stdin\n                    read_stdin(\"Enter system prompt (optional): \", system_prompt, sizeof(system_prompt));\n                } else {\n                    // system prompt was passed in, use it\n                    strcpy(system_prompt, cli_system_prompt);\n                }\n            }\n            // get the user prompt\n            if (pos == 0 && cli_user_prompt != NULL) {\n                // user prompt for position 0 was passed in, use it\n                strcpy(user_prompt, cli_user_prompt);\n            } else {\n                // otherwise get user prompt from stdin\n                read_stdin(\"User: \", user_prompt, sizeof(user_prompt));\n            }\n            // render user/system prompts into the Llama 2 Chat schema\n            if (pos == 0 && system_prompt[0] != '\\0') {\n                char system_template[] = \"[INST] <<SYS>>\\n%s\\n<</SYS>>\\n\\n%s [/INST]\";\n                sprintf(rendered_prompt, system_template, system_prompt, user_prompt);\n            } else {\n                char user_template[] = \"[INST] %s [/INST]\";\n                sprintf(rendered_prompt, user_template, user_prompt);\n            }\n            // encode the rendered prompt into tokens\n            encode(tokenizer, rendered_prompt, 1, 0, prompt_tokens, &num_prompt_tokens);\n            user_idx = 0; // reset the user index\n            user_turn = 0;\n            printf(\"Assistant: \");\n        }\n\n        // determine the token to pass into the transformer next\n        if (user_idx < num_prompt_tokens) {\n            // if we are still processing the input prompt, force the next prompt token\n            token = prompt_tokens[user_idx++];\n        } else {\n            // otherwise use the next token sampled from previous turn\n            token = next;\n        }\n        // EOS (=2) token ends the Assistant turn\n        if (token == 2) { user_turn = 1; }\n\n        // forward the transformer to get logits for the next token\n        float* logits = forward(transformer, token, pos);\n        next = sample(sampler, logits);\n        pos++;\n\n        if (user_idx >= num_prompt_tokens && next != 2) {\n            // the Assistant is responding, so print its output\n            char* piece = decode(tokenizer, token, next);\n            safe_printf(piece); // same as printf(\"%s\", piece), but skips \"unsafe\" bytes\n            fflush(stdout);\n        }\n        if (next == 2) { printf(\"\\n\"); }\n    }\n    printf(\"\\n\");\n    free(prompt_tokens);\n}\n\n\n// ----------------------------------------------------------------------------\n// CLI, include only if not testing\n#ifndef TESTING\n\nvoid error_usage() {\n    fprintf(stderr, \"Usage:   run <checkpoint> [options]\\n\");\n    fprintf(stderr, \"Example: run model.bin -n 256 -i \\\"Once upon a time\\\"\\n\");\n    fprintf(stderr, \"Options:\\n\");\n    fprintf(stderr, \"  -t <float>  temperature in [0,inf], default 1.0\\n\");\n    fprintf(stderr, \"  -p <float>  p value in top-p (nucleus) sampling in [0,1] default 0.9\\n\");\n    fprintf(stderr, \"  -s <int>    random seed, default time(NULL)\\n\");\n    fprintf(stderr, \"  -n <int>    number of steps to run for, default 256. 0 = max_seq_len\\n\");\n    fprintf(stderr, \"  -i <string> input prompt\\n\");\n    fprintf(stderr, \"  -z <string> optional path to custom tokenizer\\n\");\n    fprintf(stderr, \"  -m <string> mode: generate|chat, default: generate\\n\");\n    fprintf(stderr, \"  -y <string> (optional) system prompt in chat mode\\n\");\n    exit(EXIT_FAILURE);\n}\n\nint main(int argc, char *argv[]) {\n\n    // default parameters\n    char *checkpoint_path = NULL;  // e.g. out/model.bin\n    char *tokenizer_path = \"tokenizer.bin\";\n    float temperature = 1.0f;   // 0.0 = greedy deterministic. 1.0 = original. don't set higher\n    float topp = 0.9f;          // top-p in nucleus sampling. 1.0 = off. 0.9 works well, but slower\n    int steps = 256;            // number of steps to run for\n    char *prompt = NULL;        // prompt string\n    unsigned long long rng_seed = 0; // seed rng with time by default\n    char *mode = \"generate\";    // generate|chat\n    char *system_prompt = NULL; // the (optional) system prompt to use in chat mode\n\n    // poor man's C argparse so we can override the defaults above from the command line\n    if (argc >= 2) { checkpoint_path = argv[1]; } else { error_usage(); }\n    for (int i = 2; i < argc; i+=2) {\n        // do some basic validation\n        if (i + 1 >= argc) { error_usage(); } // must have arg after flag\n        if (argv[i][0] != '-') { error_usage(); } // must start with dash\n        if (strlen(argv[i]) != 2) { error_usage(); } // must be -x (one dash, one letter)\n        // read in the args\n        if (argv[i][1] == 't') { temperature = atof(argv[i + 1]); }\n        else if (argv[i][1] == 'p') { topp = atof(argv[i + 1]); }\n        else if (argv[i][1] == 's') { rng_seed = atoi(argv[i + 1]); }\n        else if (argv[i][1] == 'n') { steps = atoi(argv[i + 1]); }\n        else if (argv[i][1] == 'i') { prompt = argv[i + 1]; }\n        else if (argv[i][1] == 'z') { tokenizer_path = argv[i + 1]; }\n        else if (argv[i][1] == 'm') { mode = argv[i + 1]; }\n        else if (argv[i][1] == 'y') { system_prompt = argv[i + 1]; }\n        else { error_usage(); }\n    }\n\n    // parameter validation/overrides\n    if (rng_seed <= 0) rng_seed = (unsigned int)time(NULL);\n    if (temperature < 0.0) temperature = 0.0;\n    if (topp < 0.0 || 1.0 < topp) topp = 0.9;\n    if (steps < 0) steps = 0;\n\n    // build the Transformer via the model .bin file\n    Transformer transformer;\n    build_transformer(&transformer, checkpoint_path);\n    if (steps == 0 || steps > transformer.config.seq_len) steps = transformer.config.seq_len; // override to ~max length\n\n    // build the Tokenizer via the tokenizer .bin file\n    Tokenizer tokenizer;\n    build_tokenizer(&tokenizer, tokenizer_path, transformer.config.vocab_size);\n\n    // build the Sampler\n    Sampler sampler;\n    build_sampler(&sampler, transformer.config.vocab_size, temperature, topp, rng_seed);\n\n    // run!\n    if (strcmp(mode, \"generate\") == 0) {\n        generate(&transformer, &tokenizer, &sampler, prompt, steps);\n    } else if (strcmp(mode, \"chat\") == 0) {\n        chat(&transformer, &tokenizer, &sampler, prompt, system_prompt, steps);\n    } else {\n        fprintf(stderr, \"unknown mode: %s\\n\", mode);\n        error_usage();\n    }\n\n    // memory and file handles cleanup\n    free_sampler(&sampler);\n    free_tokenizer(&tokenizer);\n    free_transformer(&transformer);\n    return 0;\n}\n#endif\n"
        },
        {
          "name": "run.ipynb",
          "type": "blob",
          "size": 3.8876953125,
          "content": "{\n  \"cells\": [\n    {\n      \"cell_type\": \"markdown\",\n      \"metadata\": {\n        \"id\": \"HLdoj4cz-xal\"\n      },\n      \"source\": [\n        \"# Run.c\\n\",\n        \"\\n\",\n        \"[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/karpathy/llama2.c/blob/master/run.ipynb)\\n\",\n        \"\\n\",\n        \"More details can be found in the [README.md](README.md) .\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {\n        \"id\": \"Une3Ozlnu1B7\"\n      },\n      \"outputs\": [],\n      \"source\": [\n        \"#@title Clone Project\\n\",\n        \"\\n\",\n        \"!git clone https://github.com/karpathy/llama2.c.git\\n\",\n        \"%cd llama2.c\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {},\n      \"outputs\": [],\n      \"source\": [\n        \"#@title Build\\n\",\n        \"\\n\",\n        \"!make runfast\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {\n        \"id\": \"thm0ZBrtSgoC\"\n      },\n      \"outputs\": [],\n      \"source\": [\n        \"#@title Pick Your Model\\n\",\n        \"\\n\",\n        \"#@markdown Choose model\\n\",\n        \"model = \\\"stories15M\\\" #@param [\\\"stories15M\\\", \\\"stories42M\\\", \\\"stories110M\\\"]\\n\",\n        \"\\n\",\n        \"download_url = \\\"\\\"\\n\",\n        \"\\n\",\n        \"if(model == \\\"stories15M\\\"):\\n\",\n        \"  download_url = \\\"https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin\\\"\\n\",\n        \"if(model == \\\"stories42M\\\"):\\n\",\n        \"  download_url = \\\"https://huggingface.co/karpathy/tinyllamas/resolve/main/stories42M.bin\\\"\\n\",\n        \"if(model == \\\"stories110M\\\"):\\n\",\n        \"  download_url = \\\"https://huggingface.co/karpathy/tinyllamas/resolve/main/stories110M.bin\\\"\\n\",\n        \"\\n\",\n        \"print(f\\\"download_url: {download_url}\\\")\\n\",\n        \"\\n\",\n        \"!wget $download_url\\n\",\n        \"\\n\",\n        \"model_file = model + \\\".bin\\\"\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {\n        \"id\": \"OgAc3KjuT-NM\"\n      },\n      \"outputs\": [],\n      \"source\": [\n        \"#@title Generate Stories\\n\",\n        \"\\n\",\n        \"# Generate args\\n\",\n        \"max_token = 256 #@param {type:\\\"slider\\\", min:32, max:1024, step:32}\\n\",\n        \"temperature = 0.8 #@param {type:\\\"slider\\\", min:0.0, max:1, step:0.05}\\n\",\n        \"top_p = 0.9 #@param {type:\\\"slider\\\", min:0.0, max:1.0, step:0.05}\\n\",\n        \"prompt = \\\"One day, Lily met a Shoggoth\\\" #@param {type:\\\"string\\\"}\\n\",\n        \"\\n\",\n        \"print(f\\\"model: {model_file}, max_token: {max_token}, temperature: {temperature}, top_p: {top_p}, prompt: {prompt}\\\")\\n\",\n        \"print(f\\\"----------------------------\\\\n\\\")\\n\",\n        \"\\n\",\n        \"cmd = f'./run {model_file} -t {temperature} -p {top_p} -n {max_token} -i \\\"{prompt}\\\"'\\n\",\n        \"!{cmd}\"\n      ]\n    },\n    {\n      \"cell_type\": \"code\",\n      \"execution_count\": null,\n      \"metadata\": {},\n      \"outputs\": [],\n      \"source\": [\n        \"#@title Run Meta's Llama 2 models\\n\",\n        \"\\n\",\n        \"#@markdown input your huggingface [access token](https://huggingface.co/settings/tokens) to download Meta's Llama 2 models.\\n\",\n        \"\\n\",\n        \"from huggingface_hub import snapshot_download\\n\",\n        \"\\n\",\n        \"token = \\\"replace your huggingface access token\\\" #@param {type:\\\"string\\\"}\\n\",\n        \"path = snapshot_download(repo_id=\\\"meta-llama/Llama-2-7b\\\",cache_dir=\\\"Llama-2-7b\\\", use_auth_token=token)\\n\",\n        \"\\n\",\n        \"!python export.py llama2_7b.bin --meta-llama $path\\n\",\n        \"\\n\",\n        \"print(\\\"./run llama2_7b.bin\\\\n\\\")\\n\",\n        \"!./run llama2_7b.bin\"\n      ]\n    }\n  ],\n  \"metadata\": {\n    \"colab\": {\n      \"private_outputs\": true,\n      \"provenance\": []\n    },\n    \"kernelspec\": {\n      \"display_name\": \"Python 3\",\n      \"name\": \"python3\"\n    },\n    \"language_info\": {\n      \"name\": \"python\"\n    }\n  },\n  \"nbformat\": 4,\n  \"nbformat_minor\": 0\n}\n"
        },
        {
          "name": "runq.c",
          "type": "blob",
          "size": 42.3408203125,
          "content": "/* Inference for Llama-2 Transformer model in pure C, int8 quantized forward pass. */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <stdint.h>\n#include <time.h>\n#include <math.h>\n#include <string.h>\n#include <fcntl.h>\n#if defined _WIN32\n    #include \"win.h\"\n#else\n    #include <unistd.h>\n    #include <sys/mman.h>\n#endif\n// ----------------------------------------------------------------------------\n// Globals\nint GS = 0; // group size global for quantization of the weights\n\n// ----------------------------------------------------------------------------\n// Transformer model\n\ntypedef struct {\n    int dim; // transformer dimension\n    int hidden_dim; // for ffn layers\n    int n_layers; // number of layers\n    int n_heads; // number of query heads\n    int n_kv_heads; // number of key/value heads (can be < query heads because of multiquery)\n    int vocab_size; // vocabulary size, usually 256 (byte-level)\n    int seq_len; // max sequence length\n} Config;\n\ntypedef struct {\n    int8_t* q;    // quantized values\n    float* s; // scaling factors\n} QuantizedTensor;\n\ntypedef struct {\n    // token embedding table\n    QuantizedTensor *q_tokens; // (vocab_size, dim)\n    float* token_embedding_table; // same, but dequantized\n\n    // weights for rmsnorms\n    float* rms_att_weight; // (layer, dim) rmsnorm weights\n    float* rms_ffn_weight; // (layer, dim)\n    // weights for matmuls. note dim == n_heads * head_size\n    QuantizedTensor *wq; // (layer, dim, n_heads * head_size)\n    QuantizedTensor *wk; // (layer, dim, n_kv_heads * head_size)\n    QuantizedTensor *wv; // (layer, dim, n_kv_heads * head_size)\n    QuantizedTensor *wo; // (layer, n_heads * head_size, dim)\n    // weights for ffn\n    QuantizedTensor *w1; // (layer, hidden_dim, dim)\n    QuantizedTensor *w2; // (layer, dim, hidden_dim)\n    QuantizedTensor *w3; // (layer, hidden_dim, dim)\n    // final rmsnorm\n    float* rms_final_weight; // (dim,)\n    // (optional) classifier weights for the logits, on the last layer\n    QuantizedTensor *wcls;\n} TransformerWeights;\n\ntypedef struct {\n    // current wave of activations\n    float *x; // activation at current time stamp (dim,)\n    float *xb; // same, but inside a residual branch (dim,)\n    float *xb2; // an additional buffer just for convenience (dim,)\n    float *hb; // buffer for hidden dimension in the ffn (hidden_dim,)\n    float *hb2; // buffer for hidden dimension in the ffn (hidden_dim,)\n    QuantizedTensor xq; // quantized x (dim,)\n    QuantizedTensor hq; // quantized hb (hidden_dim,)\n    float *q; // query (dim,)\n    float *k; // key (dim,)\n    float *v; // value (dim,)\n    float *att; // buffer for scores/attention values (n_heads, seq_len)\n    float *logits; // output logits\n    // kv cache\n    float* key_cache;   // (layer, seq_len, dim)\n    float* value_cache; // (layer, seq_len, dim)\n} RunState;\n\ntypedef struct {\n    Config config; // the hyperparameters of the architecture (the blueprint)\n    TransformerWeights weights; // the weights of the model\n    RunState state; // buffers for the \"wave\" of activations in the forward pass\n    // some more state needed to properly clean up the memory mapping (sigh)\n    int fd; // file descriptor for memory mapping\n    float* data; // memory mapped data pointer\n    ssize_t file_size; // size of the checkpoint file in bytes\n} Transformer;\n\nvoid malloc_run_state(RunState* s, Config* p) {\n    // we calloc instead of malloc to keep valgrind happy\n    int kv_dim = (p->dim * p->n_kv_heads) / p->n_heads;\n    s->x = calloc(p->dim, sizeof(float));\n    s->xb = calloc(p->dim, sizeof(float));\n    s->xb2 = calloc(p->dim, sizeof(float));\n    s->hb = calloc(p->hidden_dim, sizeof(float));\n    s->hb2 = calloc(p->hidden_dim, sizeof(float));\n    s->xq = (QuantizedTensor) { .q = calloc(p->dim, sizeof(int8_t)), .s = calloc(p->dim, sizeof(float)) };\n    s->hq = (QuantizedTensor) { .q = calloc(p->hidden_dim, sizeof(int8_t)), .s = calloc(p->hidden_dim, sizeof(float)) };\n    s->q = calloc(p->dim, sizeof(float));\n    s->k = calloc(kv_dim, sizeof(float));\n    s->v = calloc(kv_dim, sizeof(float));\n    s->att = calloc(p->n_heads * p->seq_len, sizeof(float));\n    s->logits = calloc(p->vocab_size, sizeof(float));\n    s->key_cache = calloc(p->n_layers * p->seq_len * kv_dim, sizeof(float));\n    s->value_cache = calloc(p->n_layers * p->seq_len * kv_dim, sizeof(float));\n    // ensure all mallocs went fine\n    if (!s->x || !s->xb || !s->xb2 || !s->hb || !s->hb2 || !s->q\n     || !s->k || !s->v || !s->att || !s->logits || !s->key_cache\n     || !s->value_cache) {\n        fprintf(stderr, \"malloc failed!\\n\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nvoid free_run_state(RunState* s) {\n    free(s->x);\n    free(s->xb);\n    free(s->xb2);\n    free(s->hb);\n    free(s->hb2);\n    free(s->xq.q);\n    free(s->xq.s);\n    free(s->hq.q);\n    free(s->hq.s);\n    free(s->q);\n    free(s->k);\n    free(s->v);\n    free(s->att);\n    free(s->logits);\n    free(s->key_cache);\n    free(s->value_cache);\n}\n\n// ----------------------------------------------------------------------------\n// Quantization functions\n\nvoid dequantize(QuantizedTensor *qx, float* x, int n) {\n    for (int i = 0; i < n; i++) {\n        x[i] = qx->q[i] * qx->s[i / GS];\n    }\n}\n\nvoid quantize(QuantizedTensor *qx, float* x, int n) {\n    int num_groups = n / GS;\n    float Q_MAX = 127.0f;\n\n    for (int group = 0; group < num_groups; group++) {\n\n        // find the max absolute value in the current group\n        float wmax = 0.0;\n        for (int i = 0; i < GS; i++) {\n            float val = fabs(x[group * GS + i]);\n            if (val > wmax) {\n                wmax = val;\n            }\n        }\n\n        // calculate and write the scaling factor\n        float scale = wmax / Q_MAX;\n        qx->s[group] = scale;\n\n        // calculate and write the quantized values\n        for (int i = 0; i < GS; i++) {\n            float quant_value = x[group * GS + i] / scale; // scale\n            int8_t quantized = (int8_t) round(quant_value); // round and clamp\n            qx->q[group * GS + i] = quantized;\n        }\n    }\n}\n\n/* initialize `n` x quantized tensor (with `size_each` elements), starting from memory pointed at *ptr */\nQuantizedTensor *init_quantized_tensors(void **ptr, int n, int size_each) {\n    void *p = *ptr;\n    QuantizedTensor *res = malloc(n * sizeof(QuantizedTensor));\n    for(int i=0; i<n; i++) {\n        /* map quantized int8 values*/\n        res[i].q = (int8_t*)p;\n        p = (int8_t*)p + size_each;\n        /* map scale factors */\n        res[i].s = (float*)p;\n        p = (float*)p + size_each / GS;\n    }\n    *ptr = p; // advance ptr to current position\n    return res;\n}\n\nvoid memory_map_weights(TransformerWeights *w, Config* p, void* ptr, uint8_t shared_classifier) {\n    int head_size = p->dim / p->n_heads;\n    // first are the parameters that are kept in fp32 (the rmsnorm (1D) weights)\n    float* fptr = (float*) ptr; // cast our pointer to float*\n    w->rms_att_weight = fptr;\n    fptr += p->n_layers * p->dim;\n    w->rms_ffn_weight = fptr;\n    fptr += p->n_layers * p->dim;\n    w->rms_final_weight = fptr;\n    fptr += p->dim;\n\n    // now read all the quantized weights\n    ptr = (void*)fptr; // now cast the pointer back to void*\n    w->q_tokens = init_quantized_tensors(&ptr, 1, p->vocab_size * p->dim);\n    // dequantize token embedding table\n    w->token_embedding_table = malloc(p->vocab_size * p->dim * sizeof(float));\n    dequantize(w->q_tokens, w->token_embedding_table, p->vocab_size * p->dim);\n\n    w->wq = init_quantized_tensors(&ptr, p->n_layers, p->dim * (p->n_heads * head_size));\n    w->wk = init_quantized_tensors(&ptr, p->n_layers, p->dim * (p->n_kv_heads * head_size));\n    w->wv = init_quantized_tensors(&ptr, p->n_layers, p->dim * (p->n_kv_heads * head_size));\n    w->wo = init_quantized_tensors(&ptr, p->n_layers, (p->n_heads * head_size) * p->dim);\n\n    w->w1 = init_quantized_tensors(&ptr, p->n_layers, p->dim * p->hidden_dim);\n    w->w2 = init_quantized_tensors(&ptr, p->n_layers, p->hidden_dim * p->dim);\n    w->w3 = init_quantized_tensors(&ptr, p->n_layers, p->dim * p->hidden_dim);\n\n    w->wcls = shared_classifier ? w->q_tokens : init_quantized_tensors(&ptr, 1, p->dim * p->vocab_size);\n}\n\nvoid read_checkpoint(char* checkpoint, Config* config, TransformerWeights* weights,\n                     int* fd, float** data, ssize_t* file_size) {\n    FILE *file = fopen(checkpoint, \"rb\");\n    if (!file) { fprintf(stderr, \"Couldn't open file %s\\n\", checkpoint); exit(EXIT_FAILURE); }\n    // read in magic number (uint32), has to be 0x616b3432, i.e. \"ak42\" in ASCII\n    uint32_t magic_number;\n    if (fread(&magic_number, sizeof(uint32_t), 1, file) != 1) { exit(EXIT_FAILURE); }\n    if (magic_number != 0x616b3432) { fprintf(stderr, \"Bad magic number\\n\"); exit(EXIT_FAILURE); }\n    // read in the version number (uint32), has to be 2\n    int version;\n    if (fread(&version, sizeof(int), 1, file) != 1) { exit(EXIT_FAILURE); }\n    if (version != 2) { fprintf(stderr, \"Bad version %d, need version 2\\n\", version); exit(EXIT_FAILURE); }\n    int header_size = 256; // the header size for version 2 in bytes\n    // read in the Config\n    if (fread(config, sizeof(Config), 1, file) != 1) { exit(EXIT_FAILURE); }\n    // read in flags\n    uint8_t shared_classifier; // a byte to indicate if the classifier is shared\n    if (fread(&shared_classifier, sizeof(uint8_t), 1, file) != 1) { exit(EXIT_FAILURE); }\n    int group_size; // the group size used in quantization\n    if (fread(&group_size, sizeof(int), 1, file) != 1) { exit(EXIT_FAILURE); }\n    GS = group_size; // set as global, as it will be used in many places\n    // figure out the file size\n    fseek(file, 0, SEEK_END); // move file pointer to end of file\n    *file_size = ftell(file); // get the file size, in bytes\n    fclose(file);\n    // memory map the Transformer weights into the data pointer\n    *fd = open(checkpoint, O_RDONLY); // open in read only mode\n    if (*fd == -1) { fprintf(stderr, \"open failed!\\n\"); exit(EXIT_FAILURE); }\n    *data = mmap(NULL, *file_size, PROT_READ, MAP_PRIVATE, *fd, 0);\n    if (*data == MAP_FAILED) { fprintf(stderr, \"mmap failed!\\n\"); exit(EXIT_FAILURE); }\n    void* weights_ptr = ((char*)*data) + header_size; // skip header bytes. char is 1 byte\n    memory_map_weights(weights, config, weights_ptr, shared_classifier);\n}\n\nvoid build_transformer(Transformer *t, char* checkpoint_path) {\n    // read in the Config and the Weights from the checkpoint\n    read_checkpoint(checkpoint_path, &t->config, &t->weights, &t->fd, &t->data, &t->file_size);\n    // allocate the RunState buffers\n    malloc_run_state(&t->state, &t->config);\n}\n\nvoid free_transformer(Transformer* t) {\n    // free QuantizedTensors\n    free(t->weights.q_tokens);\n    free(t->weights.token_embedding_table);\n    free(t->weights.wq);\n    free(t->weights.wk);\n    free(t->weights.wv);\n    free(t->weights.wo);\n    free(t->weights.w1);\n    free(t->weights.w2);\n    free(t->weights.w3);\n    if(t->weights.wcls != t->weights.q_tokens) { free(t->weights.wcls); }\n    // close the memory mapping\n    if (t->data != MAP_FAILED) { munmap(t->data, t->file_size); }\n    if (t->fd != -1) { close(t->fd); }\n    // free the RunState buffers\n    free_run_state(&t->state);\n}\n\n// ----------------------------------------------------------------------------\n// neural net blocks; the dynamics of the Transformer\n\nvoid rmsnorm(float* o, float* x, float* weight, int size) {\n    // calculate sum of squares\n    float ss = 0.0f;\n    for (int j = 0; j < size; j++) {\n        ss += x[j] * x[j];\n    }\n    ss /= size;\n    ss += 1e-5f;\n    ss = 1.0f / sqrtf(ss);\n    // normalize and scale\n    for (int j = 0; j < size; j++) {\n        o[j] = weight[j] * (ss * x[j]);\n    }\n}\n\nvoid softmax(float* x, int size) {\n    // find max value (for numerical stability)\n    float max_val = x[0];\n    for (int i = 1; i < size; i++) {\n        if (x[i] > max_val) {\n            max_val = x[i];\n        }\n    }\n    // exp and sum\n    float sum = 0.0f;\n    for (int i = 0; i < size; i++) {\n        x[i] = expf(x[i] - max_val);\n        sum += x[i];\n    }\n    // normalize\n    for (int i = 0; i < size; i++) {\n        x[i] /= sum;\n    }\n}\n\nvoid matmul(float* xout, QuantizedTensor *x, QuantizedTensor *w, int n, int d) {\n    // W (d,n) @ x (n,) -> xout (d,)\n    // by far the most amount of time is spent inside this little function\n    // inputs to this function are both quantized\n\n    int i;\n    #pragma omp parallel for private(i)\n    for (i = 0; i < d; i++) {\n\n        float val = 0.0f;\n        int32_t ival = 0;\n        int in = i * n;\n\n        // do the matmul in groups of GS\n        int j;\n        for (j = 0; j <= n - GS; j += GS) {\n            for (int k = 0; k < GS; k++) {\n                ival += ((int32_t) x->q[j + k]) * ((int32_t) w->q[in + j + k]);\n            }\n            val += ((float) ival) * w->s[(in + j) / GS] * x->s[j / GS];\n            ival = 0;\n        }\n\n        xout[i] = val;\n    }\n}\n\nfloat* forward(Transformer* transformer, int token, int pos) {\n\n    // a few convenience variables\n    Config* p = &transformer->config;\n    TransformerWeights* w = &transformer->weights;\n    RunState* s = &transformer->state;\n    float *x = s->x;\n    int dim = p->dim;\n    int kv_dim = (p->dim * p->n_kv_heads) / p->n_heads;\n    int kv_mul = p->n_heads / p->n_kv_heads; // integer multiplier of the kv sharing in multiquery\n    int hidden_dim =  p->hidden_dim;\n    int head_size = dim / p->n_heads;\n\n    // copy the token embedding into x\n    memcpy(x, w->token_embedding_table + token*dim, dim * sizeof(float));\n\n    // forward all the layers\n    for(int l = 0; l < p->n_layers; l++) {\n\n        // attention rmsnorm\n        rmsnorm(s->xb, x, w->rms_att_weight + l*dim, dim);\n\n        // qkv matmuls for this position\n        quantize(&s->xq, s->xb, dim);\n        matmul(s->q, &s->xq, w->wq + l, dim, dim);\n        matmul(s->k, &s->xq, w->wk + l, dim, kv_dim);\n        matmul(s->v, &s->xq, w->wv + l, dim, kv_dim);\n\n        // RoPE relative positional encoding: complex-valued rotate q and k in each head\n        for (int i = 0; i < dim; i+=2) {\n            int head_dim = i % head_size;\n            float freq = 1.0f / powf(10000.0f, head_dim / (float)head_size);\n            float val = pos * freq;\n            float fcr = cosf(val);\n            float fci = sinf(val);\n            int rotn = i < kv_dim ? 2 : 1; // how many vectors? 2 = q & k, 1 = q only\n            for (int v = 0; v < rotn; v++) {\n                float* vec = v == 0 ? s->q : s->k; // the vector to rotate (query or key)\n                float v0 = vec[i];\n                float v1 = vec[i+1];\n                vec[i]   = v0 * fcr - v1 * fci;\n                vec[i+1] = v0 * fci + v1 * fcr;\n            }\n        }\n\n        // save key,value at this time step (pos) to our kv cache\n        int loff = l * p->seq_len * kv_dim; // kv cache layer offset for convenience\n        float* key_cache_row = s->key_cache + loff + pos * kv_dim;\n        float* value_cache_row = s->value_cache + loff + pos * kv_dim;\n        memcpy(key_cache_row, s->k, kv_dim * sizeof(*key_cache_row));\n        memcpy(value_cache_row, s->v, kv_dim * sizeof(*value_cache_row));\n\n        // multihead attention. iterate over all heads\n        int h;\n        #pragma omp parallel for private(h)\n        for (h = 0; h < p->n_heads; h++) {\n            // get the query vector for this head\n            float* q = s->q + h * head_size;\n            // attention scores for this head\n            float* att = s->att + h * p->seq_len;\n            // iterate over all timesteps, including the current one\n            for (int t = 0; t <= pos; t++) {\n                // get the key vector for this head and at this timestep\n                float* k = s->key_cache + loff + t * kv_dim + (h / kv_mul) * head_size;\n                // calculate the attention score as the dot product of q and k\n                float score = 0.0f;\n                for (int i = 0; i < head_size; i++) {\n                    score += q[i] * k[i];\n                }\n                score /= sqrtf(head_size);\n                // save the score to the attention buffer\n                att[t] = score;\n            }\n\n            // softmax the scores to get attention weights, from 0..pos inclusively\n            softmax(att, pos + 1);\n\n            // weighted sum of the values, store back into xb\n            float* xb = s->xb + h * head_size;\n            memset(xb, 0, head_size * sizeof(float));\n            for (int t = 0; t <= pos; t++) {\n                // get the value vector for this head and at this timestep\n                float* v = s->value_cache + loff + t * kv_dim + (h / kv_mul) * head_size;\n                // get the attention weight for this timestep\n                float a = att[t];\n                // accumulate the weighted value into xb\n                for (int i = 0; i < head_size; i++) {\n                    xb[i] += a * v[i];\n                }\n            }\n        }\n\n        // final matmul to get the output of the attention\n        quantize(&s->xq, s->xb, dim);\n        matmul(s->xb2, &s->xq, w->wo + l, dim, dim);\n\n        // residual connection back into x\n        for (int i = 0; i < dim; i++) {\n            x[i] += s->xb2[i];\n        }\n\n        // ffn rmsnorm\n        rmsnorm(s->xb, x, w->rms_ffn_weight + l*dim, dim);\n\n        // Now for FFN in PyTorch we have: self.w2(F.silu(self.w1(x)) * self.w3(x))\n        // first calculate self.w1(x) and self.w3(x)\n        quantize(&s->xq, s->xb, dim);\n        matmul(s->hb, &s->xq, w->w1 + l, dim, hidden_dim);\n        matmul(s->hb2, &s->xq, w->w3 + l, dim, hidden_dim);\n\n        // SwiGLU non-linearity\n        for (int i = 0; i < hidden_dim; i++) {\n            float val = s->hb[i];\n            // silu(x)=x*Ïƒ(x), where Ïƒ(x) is the logistic sigmoid\n            val *= (1.0f / (1.0f + expf(-val)));\n            // elementwise multiply with w3(x)\n            val *= s->hb2[i];\n            s->hb[i] = val;\n        }\n\n        // final matmul to get the output of the ffn\n        quantize(&s->hq, s->hb, hidden_dim);\n        matmul(s->xb, &s->hq, w->w2 + l, hidden_dim, dim);\n\n        // residual connection\n        for (int i = 0; i < dim; i++) {\n            x[i] += s->xb[i];\n        }\n    }\n\n    // final rmsnorm\n    rmsnorm(x, x, w->rms_final_weight, dim);\n\n    // classifier into logits\n    quantize(&s->xq, x, dim);\n    matmul(s->logits, &s->xq, w->wcls, dim, p->vocab_size);\n    return s->logits;\n}\n\n// ----------------------------------------------------------------------------\n// The Byte Pair Encoding (BPE) Tokenizer that translates strings <-> tokens\n\ntypedef struct {\n    char *str;\n    int id;\n} TokenIndex;\n\ntypedef struct {\n    char** vocab;\n    float* vocab_scores;\n    TokenIndex *sorted_vocab;\n    int vocab_size;\n    unsigned int max_token_length;\n    unsigned char byte_pieces[512]; // stores all single-byte strings\n} Tokenizer;\n\nint compare_tokens(const void *a, const void *b) {\n    return strcmp(((TokenIndex*)a)->str, ((TokenIndex*)b)->str);\n}\n\nvoid build_tokenizer(Tokenizer* t, char* tokenizer_path, int vocab_size) {\n    // i should have written the vocab_size into the tokenizer file... sigh\n    t->vocab_size = vocab_size;\n    // malloc space to hold the scores and the strings\n    t->vocab = (char**)malloc(vocab_size * sizeof(char*));\n    t->vocab_scores = (float*)malloc(vocab_size * sizeof(float));\n    t->sorted_vocab = NULL; // initialized lazily\n    for (int i = 0; i < 256; i++) {\n        t->byte_pieces[i * 2] = (unsigned char)i;\n        t->byte_pieces[i * 2 + 1] = '\\0';\n    }\n    // read in the file\n    FILE *file = fopen(tokenizer_path, \"rb\");\n    if (!file) { fprintf(stderr, \"couldn't load %s\\n\", tokenizer_path); exit(EXIT_FAILURE); }\n    if (fread(&t->max_token_length, sizeof(int), 1, file) != 1) { fprintf(stderr, \"failed read\\n\"); exit(EXIT_FAILURE); }\n    int len;\n    for (int i = 0; i < vocab_size; i++) {\n        if (fread(t->vocab_scores + i, sizeof(float), 1, file) != 1) { fprintf(stderr, \"failed read\\n\"); exit(EXIT_FAILURE);}\n        if (fread(&len, sizeof(int), 1, file) != 1) { fprintf(stderr, \"failed read\\n\"); exit(EXIT_FAILURE); }\n        t->vocab[i] = (char *)malloc(len + 1);\n        if (fread(t->vocab[i], len, 1, file) != 1) { fprintf(stderr, \"failed read\\n\"); exit(EXIT_FAILURE); }\n        t->vocab[i][len] = '\\0'; // add the string terminating token\n    }\n    fclose(file);\n}\n\nvoid free_tokenizer(Tokenizer* t) {\n    for (int i = 0; i < t->vocab_size; i++) { free(t->vocab[i]); }\n    free(t->vocab);\n    free(t->vocab_scores);\n    free(t->sorted_vocab);\n}\n\nchar* decode(Tokenizer* t, int prev_token, int token) {\n    char *piece = t->vocab[token];\n    // following BOS (1) token, sentencepiece decoder strips any leading whitespace (see PR #89)\n    if (prev_token == 1 && piece[0] == ' ') { piece++; }\n    // careful, some tokens designate raw bytes, and look like e.g. '<0x01>'\n    // parse this and convert and return the actual byte\n    unsigned char byte_val;\n    if (sscanf(piece, \"<0x%02hhX>\", &byte_val) == 1) {\n        piece = (char*)t->byte_pieces + byte_val * 2;\n    }\n    return piece;\n}\n\nvoid safe_printf(char *piece) {\n    // piece might be a raw byte token, and we only want to print printable chars or whitespace\n    // because some of the other bytes can be various control codes, backspace, etc.\n    if (piece == NULL) { return; }\n    if (piece[0] == '\\0') { return; }\n    if (piece[1] == '\\0') {\n        unsigned char byte_val = piece[0];\n        if (!(isprint(byte_val) || isspace(byte_val))) {\n            return; // bad byte, don't print it\n        }\n    }\n    printf(\"%s\", piece);\n}\n\nint str_lookup(char *str, TokenIndex *sorted_vocab, int vocab_size) {\n    // efficiently find the perfect match for str in vocab, return its index or -1 if not found\n    TokenIndex tok = { .str = str }; // acts as the key to search for\n    TokenIndex *res = bsearch(&tok, sorted_vocab, vocab_size, sizeof(TokenIndex), compare_tokens);\n    return res != NULL ? res->id : -1;\n}\n\nvoid encode(Tokenizer* t, char *text, int8_t bos, int8_t eos, int *tokens, int *n_tokens) {\n    // encode the string text (input) into an upper-bound preallocated tokens[] array\n    // bos != 0 means prepend the BOS token (=1), eos != 0 means append the EOS token (=2)\n    if (text == NULL) { fprintf(stderr, \"cannot encode NULL text\\n\"); exit(EXIT_FAILURE); }\n\n    if (t->sorted_vocab == NULL) {\n        // lazily malloc and sort the vocabulary\n        t->sorted_vocab = malloc(t->vocab_size * sizeof(TokenIndex));\n        for (int i = 0; i < t->vocab_size; i++) {\n            t->sorted_vocab[i].str = t->vocab[i];\n            t->sorted_vocab[i].id = i;\n        }\n        qsort(t->sorted_vocab, t->vocab_size, sizeof(TokenIndex), compare_tokens);\n    }\n\n    // create a temporary buffer that will store merge candidates of always two consecutive tokens\n    // *2 for concat, +1 for null terminator +2 for UTF8 (in case max_token_length is 1)\n    char* str_buffer = malloc((t->max_token_length*2 +1 +2) * sizeof(char));\n    size_t str_len = 0;\n\n    // start at 0 tokens\n    *n_tokens = 0;\n\n    // add optional BOS (=1) token, if desired\n    if (bos) tokens[(*n_tokens)++] = 1;\n\n    // add_dummy_prefix is true by default\n    // so prepend a dummy prefix token to the input string, but only if text != \"\"\n    // TODO: pretty sure this isn't correct in the general case but I don't have the\n    // energy to read more of the sentencepiece code to figure out what it's doing\n    if (text[0] != '\\0') {\n        int dummy_prefix = str_lookup(\" \", t->sorted_vocab, t->vocab_size);\n        tokens[(*n_tokens)++] = dummy_prefix;\n    }\n\n    // Okay UTF-8 time. This will get messy. Here is the reference from Wikipedia:\n    // Code point â†” UTF-8 conversion\n    // First code point\tLast code point\tByte 1\tByte 2\tByte 3\tByte 4\n    // U+0000\tU+007F\t    0xxxxxxx\n    // U+0080\tU+07FF\t    110xxxxx\t10xxxxxx\n    // U+0800\tU+FFFF\t    1110xxxx\t10xxxxxx\t10xxxxxx\n    // U+10000\tU+10FFFF    11110xxx\t10xxxxxx\t10xxxxxx\t10xxxxxx\n\n    // process the raw (UTF-8) byte sequence of the input string\n    for (char *c = text; *c != '\\0'; c++) {\n\n        // reset buffer if the current byte is ASCII or a leading byte\n        // 0xC0 is 11000000, so (*c & 0xC0) keeps the first 2 bits and zeros the rest\n        // 0x80 is 10000000\n        // in UTF-8, all continuation bytes start with \"10\" in first two bits\n        // so in English this is: \"if this byte is not a continuation byte\"\n        if ((*c & 0xC0) != 0x80) {\n            // this byte must be either a leading byte (11...) or an ASCII char (0x...)\n            // => reset our location, as we're starting a new UTF-8 codepoint\n            str_len = 0;\n        }\n\n        // append the current byte to the buffer\n        str_buffer[str_len++] = *c; // ++ is post-increment, incremented after this line\n        str_buffer[str_len] = '\\0';\n\n        // while the next character is a continuation byte, continue appending\n        // but if there are too many of them, just stop to avoid overruning str_buffer size.\n        if ((*(c+1) & 0xC0) == 0x80 && str_len < 4) {\n            continue;\n        }\n\n        // ok c+1 is not a continuation byte, so we've read in a full codepoint\n        int id = str_lookup(str_buffer, t->sorted_vocab, t->vocab_size);\n\n        if (id != -1) {\n            // we found this codepoint in vocab, add it as a token\n            tokens[(*n_tokens)++] = id;\n        } else {\n            // byte_fallback encoding: just encode each byte as a token\n            // +3 is here because the first 3 vocab elements are <unk>, <s>, </s>\n            // so the individual bytes only start at index 3\n            for (int i=0; i < str_len; i++) {\n                tokens[(*n_tokens)++] = (unsigned char)str_buffer[i] + 3;\n            }\n        }\n        str_len = 0; // protect against a sequence of stray UTF8 continuation bytes\n    }\n\n    // merge the best consecutive pair each iteration, according the scores in vocab_scores\n    while (1) {\n        float best_score = -1e10;\n        int best_id = -1;\n        int best_idx = -1;\n\n        for (int i=0; i < (*n_tokens-1); i++) {\n            // check if we can merge the pair (tokens[i], tokens[i+1])\n            sprintf(str_buffer, \"%s%s\", t->vocab[tokens[i]], t->vocab[tokens[i+1]]);\n            int id = str_lookup(str_buffer, t->sorted_vocab, t->vocab_size);\n            if (id != -1 && t->vocab_scores[id] > best_score) {\n                // this merge pair exists in vocab! record its score and position\n                best_score = t->vocab_scores[id];\n                best_id = id;\n                best_idx = i;\n            }\n        }\n\n        if (best_idx == -1) {\n            break; // we couldn't find any more pairs to merge, so we're done\n        }\n\n        // merge the consecutive pair (best_idx, best_idx+1) into new token best_id\n        tokens[best_idx] = best_id;\n        // delete token at position best_idx+1, shift the entire sequence back 1\n        for (int i = best_idx+1; i < (*n_tokens-1); i++) {\n            tokens[i] = tokens[i+1];\n        }\n        (*n_tokens)--; // token length decreased\n    }\n\n    // add optional EOS (=2) token, if desired\n    if (eos) tokens[(*n_tokens)++] = 2;\n\n    free(str_buffer);\n}\n\n// ----------------------------------------------------------------------------\n// The Sampler, which takes logits and returns a sampled token\n// sampling can be done in a few ways: greedy argmax, sampling, top-p sampling\n\ntypedef struct {\n    float prob;\n    int index;\n} ProbIndex; // struct used when sorting probabilities during top-p sampling\n\ntypedef struct {\n    int vocab_size;\n    ProbIndex* probindex; // buffer used in top-p sampling\n    float temperature;\n    float topp;\n    unsigned long long rng_state;\n} Sampler;\n\nint sample_argmax(float* probabilities, int n) {\n    // return the index that has the highest probability\n    int max_i = 0;\n    float max_p = probabilities[0];\n    for (int i = 1; i < n; i++) {\n        if (probabilities[i] > max_p) {\n            max_i = i;\n            max_p = probabilities[i];\n        }\n    }\n    return max_i;\n}\n\nint sample_mult(float* probabilities, int n, float coin) {\n    // sample index from probabilities (they must sum to 1!)\n    // coin is a random number in [0, 1), usually from random_f32()\n    float cdf = 0.0f;\n    for (int i = 0; i < n; i++) {\n        cdf += probabilities[i];\n        if (coin < cdf) {\n            return i;\n        }\n    }\n    return n - 1; // in case of rounding errors\n}\n\nint compare(const void* a, const void* b) {\n    ProbIndex* a_ = (ProbIndex*) a;\n    ProbIndex* b_ = (ProbIndex*) b;\n    if (a_->prob > b_->prob) return -1;\n    if (a_->prob < b_->prob) return 1;\n    return 0;\n}\n\nint sample_topp(float* probabilities, int n, float topp, ProbIndex* probindex, float coin) {\n    // top-p sampling (or \"nucleus sampling\") samples from the smallest set of\n    // tokens that exceed probability topp. This way we never sample tokens that\n    // have very low probabilities and are less likely to go \"off the rails\".\n    // coin is a random number in [0, 1), usually from random_f32()\n\n    int n0 = 0;\n    // quicksort indices in descending order of probabilities\n    // values smaller than (1 - topp) / (n - 1) cannot be part of the result\n    // so for efficiency we crop these out as candidates before sorting\n    const float cutoff = (1.0f - topp) / (n - 1);\n    for (int i = 0; i < n; i++) {\n        if (probabilities[i] >= cutoff) {\n            probindex[n0].index = i;\n            probindex[n0].prob = probabilities[i];\n            n0++;\n        }\n    }\n    qsort(probindex, n0, sizeof(ProbIndex), compare);\n\n    // truncate the list where cumulative probability exceeds topp\n    float cumulative_prob = 0.0f;\n    int last_idx = n0 - 1; // in case of rounding errors consider all elements\n    for (int i = 0; i < n0; i++) {\n        cumulative_prob += probindex[i].prob;\n        if (cumulative_prob > topp) {\n            last_idx = i;\n            break; // we've exceeded topp by including last_idx\n        }\n    }\n\n    // sample from the truncated list\n    float r = coin * cumulative_prob;\n    float cdf = 0.0f;\n    for (int i = 0; i <= last_idx; i++) {\n        cdf += probindex[i].prob;\n        if (r < cdf) {\n            return probindex[i].index;\n        }\n    }\n    return probindex[last_idx].index; // in case of rounding errors\n}\n\nvoid build_sampler(Sampler* sampler, int vocab_size, float temperature, float topp, unsigned long long rng_seed) {\n    sampler->vocab_size = vocab_size;\n    sampler->temperature = temperature;\n    sampler->topp = topp;\n    sampler->rng_state = rng_seed;\n    // buffer only used with nucleus sampling; may not need but it's ~small\n    sampler->probindex = malloc(sampler->vocab_size * sizeof(ProbIndex));\n}\n\nvoid free_sampler(Sampler* sampler) {\n    free(sampler->probindex);\n}\n\nunsigned int random_u32(unsigned long long *state) {\n    // xorshift rng: https://en.wikipedia.org/wiki/Xorshift#xorshift.2A\n    *state ^= *state >> 12;\n    *state ^= *state << 25;\n    *state ^= *state >> 27;\n    return (*state * 0x2545F4914F6CDD1Dull) >> 32;\n}\nfloat random_f32(unsigned long long *state) { // random float32 in [0,1)\n    return (random_u32(state) >> 8) / 16777216.0f;\n}\n\nint sample(Sampler* sampler, float* logits) {\n    // sample the token given the logits and some hyperparameters\n    int next;\n    if (sampler->temperature == 0.0f) {\n        // greedy argmax sampling: take the token with the highest probability\n        next = sample_argmax(logits, sampler->vocab_size);\n    } else {\n        // apply the temperature to the logits\n        for (int q=0; q<sampler->vocab_size; q++) { logits[q] /= sampler->temperature; }\n        // apply softmax to the logits to get the probabilities for next token\n        softmax(logits, sampler->vocab_size);\n        // flip a (float) coin (this is our source of entropy for sampling)\n        float coin = random_f32(&sampler->rng_state);\n        // we sample from this distribution to get the next token\n        if (sampler->topp <= 0 || sampler->topp >= 1) {\n            // simply sample from the predicted probability distribution\n            next = sample_mult(logits, sampler->vocab_size, coin);\n        } else {\n            // top-p (nucleus) sampling, clamping the least likely tokens to zero\n            next = sample_topp(logits, sampler->vocab_size, sampler->topp, sampler->probindex, coin);\n        }\n    }\n    return next;\n}\n\n// ----------------------------------------------------------------------------\n// utilities: time\n\nlong time_in_ms() {\n    // return time in milliseconds, for benchmarking the model speed\n    struct timespec time;\n    clock_gettime(CLOCK_REALTIME, &time);\n    return time.tv_sec * 1000 + time.tv_nsec / 1000000;\n}\n\n// ----------------------------------------------------------------------------\n// generation loop\n\nvoid generate(Transformer *transformer, Tokenizer *tokenizer, Sampler *sampler, char *prompt, int steps) {\n    char *empty_prompt = \"\";\n    if (prompt == NULL) { prompt = empty_prompt; }\n\n    // encode the (string) prompt into tokens sequence\n    int num_prompt_tokens = 0;\n    int* prompt_tokens = (int*)malloc((strlen(prompt)+3) * sizeof(int)); // +3 for '\\0', ?BOS, ?EOS\n    encode(tokenizer, prompt, 1, 0, prompt_tokens, &num_prompt_tokens);\n    if (num_prompt_tokens < 1) {\n        fprintf(stderr, \"something is wrong, expected at least 1 prompt token\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    // start the main loop\n    long start = 0;  // used to time our code, only initialized after first iteration\n    int next;        // will store the next token in the sequence\n    int token = prompt_tokens[0]; // kick off with the first token in the prompt\n    int pos = 0;     // position in the sequence\n    while (pos < steps) {\n\n        // forward the transformer to get logits for the next token\n        float* logits = forward(transformer, token, pos);\n\n        // advance the state state machine\n        if (pos < num_prompt_tokens - 1) {\n            // if we are still processing the input prompt, force the next prompt token\n            next = prompt_tokens[pos + 1];\n        } else {\n            // otherwise sample the next token from the logits\n            next = sample(sampler, logits);\n        }\n        pos++;\n\n        // data-dependent terminating condition: the BOS (=1) token delimits sequences\n        if (next == 1) { break; }\n\n        // print the token as string, decode it with the Tokenizer object\n        char* piece = decode(tokenizer, token, next);\n        safe_printf(piece); // same as printf(\"%s\", piece), but skips \"unsafe\" bytes\n        fflush(stdout);\n        token = next;\n\n        // init the timer here because the first iteration can be slower\n        if (start == 0) { start = time_in_ms(); }\n    }\n    printf(\"\\n\");\n\n    // report achieved tok/s (pos-1 because the timer starts after first iteration)\n    if (pos > 1) {\n        long end = time_in_ms();\n        fprintf(stderr, \"achieved tok/s: %f\\n\", (pos-1) / (double)(end-start)*1000);\n    }\n\n    free(prompt_tokens);\n}\n\nvoid read_stdin(const char* guide, char* buffer, size_t bufsize) {\n    // read a line from stdin, up to but not including \\n\n    printf(\"%s\", guide);\n    if (fgets(buffer, bufsize, stdin) != NULL) {\n        size_t len = strlen(buffer);\n        if (len > 0 && buffer[len - 1] == '\\n') {\n            buffer[len - 1] = '\\0'; // strip newline\n        }\n    }\n}\n\n// ----------------------------------------------------------------------------\n// chat loop\n// I manually inspected the tokens for a few chat conversations compared to\n// python reference and that seemed ok, but this was not thoroughly tested and\n// is not safely implemented, it's more a proof of concept atm.\n\nvoid chat(Transformer *transformer, Tokenizer *tokenizer, Sampler *sampler,\n          char *cli_user_prompt, char *cli_system_prompt, int steps) {\n\n    // buffers for reading the system prompt and user prompt from stdin\n    // you'll notice they are soomewhat haphazardly and unsafely set atm\n    char system_prompt[512];\n    char user_prompt[512];\n    char rendered_prompt[1152];\n    int num_prompt_tokens = 0;\n    int* prompt_tokens = (int*)malloc(1152 * sizeof(int));\n    int user_idx;\n\n    // start the main loop\n    int8_t user_turn = 1; // user starts\n    int next;        // will store the next token in the sequence\n    int token;       // stores the current token to feed into the transformer\n    int prev_token;\n    int pos = 0;     // position in the sequence\n    while (pos < steps) {\n\n        // when it is the user's turn to contribute tokens to the dialog...\n        if (user_turn) {\n            // get the (optional) system prompt at position 0\n            if (pos == 0) {\n                // at position 0, the user can also contribute a system prompt\n                if (cli_system_prompt == NULL) {\n                    // system prompt was not passed in, attempt to get it from stdin\n                    read_stdin(\"Enter system prompt (optional): \", system_prompt, sizeof(system_prompt));\n                } else {\n                    // system prompt was passed in, use it\n                    strcpy(system_prompt, cli_system_prompt);\n                }\n            }\n            // get the user prompt\n            if (pos == 0 && cli_user_prompt != NULL) {\n                // user prompt for position 0 was passed in, use it\n                strcpy(user_prompt, cli_user_prompt);\n            } else {\n                // otherwise get user prompt from stdin\n                read_stdin(\"User: \", user_prompt, sizeof(user_prompt));\n            }\n            // render user/system prompts into the Llama 2 Chat schema\n            if (pos == 0 && system_prompt[0] != '\\0') {\n                char system_template[] = \"[INST] <<SYS>>\\n%s\\n<</SYS>>\\n\\n%s [/INST]\";\n                sprintf(rendered_prompt, system_template, system_prompt, user_prompt);\n            } else {\n                char user_template[] = \"[INST] %s [/INST]\";\n                sprintf(rendered_prompt, user_template, user_prompt);\n            }\n            // encode the rendered prompt into tokens\n            encode(tokenizer, rendered_prompt, 1, 0, prompt_tokens, &num_prompt_tokens);\n            user_idx = 0; // reset the user index\n            user_turn = 0;\n            printf(\"Assistant: \");\n        }\n\n        // determine the token to pass into the transformer next\n        if (user_idx < num_prompt_tokens) {\n            // if we are still processing the input prompt, force the next prompt token\n            token = prompt_tokens[user_idx++];\n        } else {\n            // otherwise use the next token sampled from previous turn\n            token = next;\n        }\n        // EOS (=2) token ends the Assistant turn\n        if (token == 2) { user_turn = 1; }\n\n        // forward the transformer to get logits for the next token\n        float* logits = forward(transformer, token, pos);\n        next = sample(sampler, logits);\n        pos++;\n\n        if (user_idx >= num_prompt_tokens && next != 2) {\n            // the Assistant is responding, so print its output\n            char* piece = decode(tokenizer, token, next);\n            safe_printf(piece); // same as printf(\"%s\", piece), but skips \"unsafe\" bytes\n            fflush(stdout);\n        }\n        if (next == 2) { printf(\"\\n\"); }\n    }\n    printf(\"\\n\");\n    free(prompt_tokens);\n}\n\n\n// ----------------------------------------------------------------------------\n// CLI, include only if not testing\n#ifndef TESTING\n\nvoid error_usage() {\n    fprintf(stderr, \"Usage:   run <checkpoint> [options]\\n\");\n    fprintf(stderr, \"Example: run model.bin -n 256 -i \\\"Once upon a time\\\"\\n\");\n    fprintf(stderr, \"Options:\\n\");\n    fprintf(stderr, \"  -t <float>  temperature in [0,inf], default 1.0\\n\");\n    fprintf(stderr, \"  -p <float>  p value in top-p (nucleus) sampling in [0,1] default 0.9\\n\");\n    fprintf(stderr, \"  -s <int>    random seed, default time(NULL)\\n\");\n    fprintf(stderr, \"  -n <int>    number of steps to run for, default 256. 0 = max_seq_len\\n\");\n    fprintf(stderr, \"  -i <string> input prompt\\n\");\n    fprintf(stderr, \"  -z <string> optional path to custom tokenizer\\n\");\n    fprintf(stderr, \"  -m <string> mode: generate|chat, default: generate\\n\");\n    fprintf(stderr, \"  -y <string> (optional) system prompt in chat mode\\n\");\n    exit(EXIT_FAILURE);\n}\n\nint main(int argc, char *argv[]) {\n\n    // default parameters\n    char *checkpoint_path = NULL;  // e.g. out/model.bin\n    char *tokenizer_path = \"tokenizer.bin\";\n    float temperature = 1.0f;   // 0.0 = greedy deterministic. 1.0 = original. don't set higher\n    float topp = 0.9f;          // top-p in nucleus sampling. 1.0 = off. 0.9 works well, but slower\n    int steps = 256;            // number of steps to run for\n    char *prompt = NULL;        // prompt string\n    unsigned long long rng_seed = 0; // seed rng with time by default\n    char *mode = \"generate\";    // generate|chat\n    char *system_prompt = NULL; // the (optional) system prompt to use in chat mode\n\n    // poor man's C argparse so we can override the defaults above from the command line\n    if (argc >= 2) { checkpoint_path = argv[1]; } else { error_usage(); }\n    for (int i = 2; i < argc; i+=2) {\n        // do some basic validation\n        if (i + 1 >= argc) { error_usage(); } // must have arg after flag\n        if (argv[i][0] != '-') { error_usage(); } // must start with dash\n        if (strlen(argv[i]) != 2) { error_usage(); } // must be -x (one dash, one letter)\n        // read in the args\n        if (argv[i][1] == 't') { temperature = atof(argv[i + 1]); }\n        else if (argv[i][1] == 'p') { topp = atof(argv[i + 1]); }\n        else if (argv[i][1] == 's') { rng_seed = atoi(argv[i + 1]); }\n        else if (argv[i][1] == 'n') { steps = atoi(argv[i + 1]); }\n        else if (argv[i][1] == 'i') { prompt = argv[i + 1]; }\n        else if (argv[i][1] == 'z') { tokenizer_path = argv[i + 1]; }\n        else if (argv[i][1] == 'm') { mode = argv[i + 1]; }\n        else if (argv[i][1] == 'y') { system_prompt = argv[i + 1]; }\n        else { error_usage(); }\n    }\n\n    // parameter validation/overrides\n    if (rng_seed <= 0) rng_seed = (unsigned int)time(NULL);\n    if (temperature < 0.0) temperature = 0.0;\n    if (topp < 0.0 || 1.0 < topp) topp = 0.9;\n    if (steps < 0) steps = 0;\n\n    // build the Transformer via the model .bin file\n    Transformer transformer;\n    build_transformer(&transformer, checkpoint_path);\n    if (steps == 0 || steps > transformer.config.seq_len) steps = transformer.config.seq_len; // override to ~max length\n\n    // build the Tokenizer via the tokenizer .bin file\n    Tokenizer tokenizer;\n    build_tokenizer(&tokenizer, tokenizer_path, transformer.config.vocab_size);\n\n    // build the Sampler\n    Sampler sampler;\n    build_sampler(&sampler, transformer.config.vocab_size, temperature, topp, rng_seed);\n\n    // run!\n    if (strcmp(mode, \"generate\") == 0) {\n        generate(&transformer, &tokenizer, &sampler, prompt, steps);\n    } else if (strcmp(mode, \"chat\") == 0) {\n        chat(&transformer, &tokenizer, &sampler, prompt, system_prompt, steps);\n    } else {\n        fprintf(stderr, \"unknown mode: %s\\n\", mode);\n        error_usage();\n    }\n\n    // memory and file handles cleanup\n    free_sampler(&sampler);\n    free_tokenizer(&tokenizer);\n    free_transformer(&transformer);\n    return 0;\n}\n#endif\n"
        },
        {
          "name": "sample.py",
          "type": "blob",
          "size": 3.3173828125,
          "content": "\"\"\"\nSample from the trained model with PyTorch\n\"\"\"\nimport os\nimport pickle\nfrom contextlib import nullcontext\nimport torch\nfrom model import ModelArgs, Transformer\nfrom tokenizer import Tokenizer\n\nfrom tinystories import get_tokenizer_model_path\n\n# -----------------------------------------------------------------------------\ncheckpoint = 'out/ckpt.pt'\nstart = \"\" # or \"<|endoftext|>\" or etc. Can also specify a file, use as: \"FILE:prompt.txt\"\nnum_samples = 1 # number of samples to draw\nmax_new_tokens = 100 # number of tokens generated in each sample\ntemperature = 1.0 # 1.0 = no change, < 1.0 = less random, > 1.0 = more random, in predictions\ntop_k = 300 # retain only the top_k most likely tokens, clamp others to have 0 probability\ntokenizer = \"\" # override the tokenizer model path\nseed = 1337\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu' # examples: 'cpu', 'cuda', 'cuda:0', 'cuda:1', etc.\n#dtype = 'bfloat16' if torch.cuda.is_available() and torch.cuda.is_bf16_supported() else 'float16' # 'float32' or 'bfloat16' or 'float16'\ndtype = \"float32\"\ncompile = False # use PyTorch 2.0 to compile the model to be faster\nexec(open('configurator.py').read()) # overrides from command line or config file\n# -----------------------------------------------------------------------------\n\ntorch.manual_seed(seed)\ntorch.cuda.manual_seed(seed)\ntorch.backends.cuda.matmul.allow_tf32 = True # allow tf32 on matmul\ntorch.backends.cudnn.allow_tf32 = True # allow tf32 on cudnn\ndevice_type = 'cuda' if 'cuda' in device else 'cpu' # for later use in torch.autocast\nptdtype = {'float32': torch.float32, 'bfloat16': torch.bfloat16, 'float16': torch.float16}[dtype]\nctx = nullcontext() if device_type == 'cpu' else torch.amp.autocast(device_type=device_type, dtype=ptdtype)\n\n# init from a model saved in a specific directory\ncheckpoint_dict = torch.load(checkpoint, map_location=device)\ngptconf = ModelArgs(**checkpoint_dict['model_args'])\nmodel = Transformer(gptconf)\nstate_dict = checkpoint_dict['model']\nunwanted_prefix = '_orig_mod.'\nfor k,v in list(state_dict.items()):\n    if k.startswith(unwanted_prefix):\n        state_dict[k[len(unwanted_prefix):]] = state_dict.pop(k)\nmodel.load_state_dict(state_dict, strict=False)\n\nmodel.eval()\nmodel.to(device)\nif compile:\n    print(\"Compiling the model...\")\n    model = torch.compile(model) # requires PyTorch 2.0 (optional)\n\n# load the tokenizer\nvocab_source = checkpoint_dict[\"config\"].get(\"vocab_source\", \"llama2\")\nvocab_size = gptconf.vocab_size\nif tokenizer:\n    # a specific tokenizer is provided, use it\n    tokenizer_model = tokenizer\nelse:\n    # let's try to find the tokenizer model automatically. bit gross here...\n    query_vocab_size = 0 if vocab_source == \"llama2\" else vocab_size\n    tokenizer_model = get_tokenizer_model_path(vocab_size=query_vocab_size)\nenc = Tokenizer(tokenizer_model=tokenizer_model)\n\n# encode the beginning of the prompt\nif start.startswith('FILE:'):\n    with open(start[5:], 'r', encoding='utf-8') as f:\n        start = f.read()\nstart_ids = enc.encode(start, bos=True, eos=False)\nx = (torch.tensor(start_ids, dtype=torch.long, device=device)[None, ...])\n\n# run generation\nwith torch.no_grad():\n    with ctx:\n        for k in range(num_samples):\n            y = model.generate(x, max_new_tokens, temperature=temperature, top_k=top_k)\n            print(enc.decode(y[0].tolist()))\n            print('---------------')\n"
        },
        {
          "name": "test.c",
          "type": "blob",
          "size": 3.490234375,
          "content": "#define TESTING\n#include \"run.c\"\n\nvoid assert_eq(int a, int b) {\n    if (a != b) {\n        printf(\"Assertion failed: %d != %d\\n\", a, b);\n        exit(EXIT_FAILURE);\n    }\n}\n\nvoid test_prompt_encoding(Tokenizer* tokenizer, char* prompt, int* expected_tokens, int num_expected_tokens) {\n    // encode\n    int* prompt_tokens = (int*)malloc((strlen(prompt)+3) * sizeof(int));\n    int num_prompt_tokens = 0; // the total number of prompt tokens\n    encode(tokenizer, prompt, 1, 0, prompt_tokens, &num_prompt_tokens);\n\n    #if VERBOSITY == 1\n    // print maybe\n    printf(\"expected tokens:\\n\");\n    for (int i = 0; i < num_expected_tokens; i++) printf(\"%d \", expected_tokens[i]);\n    printf(\"\\n\");\n    printf(\"actual tokens:\\n\");\n    for (int i = 0; i < num_prompt_tokens; i++) printf(\"%d \", prompt_tokens[i]);\n    printf(\"\\n\");\n    #endif\n\n    // verify\n    assert_eq(num_prompt_tokens, num_expected_tokens);\n    for (int i = 0; i < num_prompt_tokens; i++) {\n        assert_eq(prompt_tokens[i], expected_tokens[i]);\n    }\n\n    #if VERBOSITY == 1\n    printf(\"OK\\n\");\n    printf(\"---\\n\");\n    #endif\n    free(prompt_tokens);\n}\n\nvoid test_prompt_encodings() {\n    // let's verify that the Tokenizer works as expected\n\n    char *tokenizer_path = \"tokenizer.bin\";\n    int vocab_size = 32000;\n    Tokenizer tokenizer;\n    build_tokenizer(&tokenizer, tokenizer_path, vocab_size);\n\n    // test 0 (test the empty string) (I added this as a simple case)\n    char *prompt0 = \"\";\n    int expected_tokens0[] = {1};\n    test_prompt_encoding(&tokenizer, prompt0, expected_tokens0, sizeof(expected_tokens0) / sizeof(int));\n\n    // the tests below are taken from the Meta Llama 2 repo example code\n    // https://github.com/facebookresearch/llama/blob/main/example_text_completion.py\n    // and the expected tokens come from me breaking in the debugger in Python\n\n    // test 1\n    char *prompt = \"I believe the meaning of life is\";\n    int expected_tokens[] = {1, 306, 4658, 278, 6593, 310, 2834, 338};\n    test_prompt_encoding(&tokenizer, prompt, expected_tokens, sizeof(expected_tokens) / sizeof(int));\n\n    // test 2\n    char* prompt2 = \"Simply put, the theory of relativity states that \";\n    int expected_tokens2[] = {1, 3439, 17632, 1925, 29892, 278, 6368, 310, 14215, 537, 5922, 393, 29871};\n    test_prompt_encoding(&tokenizer, prompt2, expected_tokens2, sizeof(expected_tokens2) / sizeof(int));\n\n    // test 3\n    char* prompt3 = \"A brief message congratulating the team on the launch:\\n\\n        Hi everyone,\\n\\n        I just \";\n    int expected_tokens3[] = {1, 319, 11473, 2643, 378, 629, 271, 18099, 278, 3815, 373, 278, 6826, 29901, 13, 13, 4706, 6324, 14332, 29892, 13, 13, 4706, 306, 925, 29871};\n    test_prompt_encoding(&tokenizer, prompt3, expected_tokens3, sizeof(expected_tokens3) / sizeof(int));\n\n    // test 4\n    char* prompt4 = \"Translate English to French:\\n\\n        sea otter => loutre de mer\\n        peppermint => menthe poivrÃ©e\\n        plush girafe => girafe peluche\\n        cheese =>\";\n    int expected_tokens4[] = {1, 4103, 9632, 4223, 304, 5176, 29901, 13, 13, 4706, 7205, 4932, 357, 1149, 301, 449, 276, 316, 2778, 13, 4706, 1236, 407, 837, 524, 1149, 6042, 354, 772, 440, 29878, 1318, 13, 4706, 715, 1878, 330, 3055, 1725, 1149, 330, 3055, 1725, 4639, 28754, 13, 4706, 923, 968, 1149};\n    test_prompt_encoding(&tokenizer, prompt4, expected_tokens4, sizeof(expected_tokens4) / sizeof(int));\n\n    // memory and file handles cleanup\n    free_tokenizer(&tokenizer);\n}\n\nint main(int argc, char *argv[]) {\n    test_prompt_encodings();\n    printf(\"ALL OK\\n\");\n}\n"
        },
        {
          "name": "test_all.py",
          "type": "blob",
          "size": 3.66015625,
          "content": "\"\"\"\nRun simply with\n$ pytest\n\"\"\"\nimport os\nimport pytest # pip install pytest\nimport requests\nimport subprocess\n\n\nimport torch\nfrom model import ModelArgs, Transformer\nfrom tokenizer import Tokenizer\n\n# -----------------------------------------------------------------------------\n# test utilities\n\ntest_ckpt_dir = \"test\"\n\ndef download_file(url, filename):\n    print(f\"Downloading {url} to {filename}\")\n    response = requests.get(url, stream=True)\n    response.raise_for_status() # Raise an HTTPError on bad status code\n    with open(filename, 'wb') as file:\n        for chunk in response.iter_content(chunk_size=8192):\n            file.write(chunk)\n\ndef attempt_download_files():\n    os.makedirs(test_ckpt_dir, exist_ok=True)\n    root_url = \"https://huggingface.co/karpathy/tinyllamas/resolve/main/stories260K\"\n    need = [\"stories260K.bin\", \"stories260K.pt\", \"tok512.bin\", \"tok512.model\"]\n    for file in need:\n        url = root_url + '/' + file   #os.path.join inserts \\\\ on windows\n        filename = os.path.join(test_ckpt_dir, file)\n        if not os.path.exists(filename):\n            download_file(url, filename)\n\nexpected_stdout = b'Once upon a time, there was a little girl named Lily. She loved to play outside in the park. One day, she saw a big, red ball. She wanted to play with it, but it was too high.\\nLily\\'s mom said, \"Lily, let\\'s go to the park.\" Lily was sad and didn\\'t know what to do. She said, \"I want to play with your ball, but I can\\'t find it.\"\\nLily was sad and didn\\'t know what to do. She said, \"I\\'m sorry, Lily. I didn\\'t know what to do.\"\\nLily didn\\'t want to help her mom, so she'\n\n# -----------------------------------------------------------------------------\n# actual tests\n\ndef test_runc():\n    \"\"\" Forwards a model against a known-good desired outcome in run.c for 200 steps\"\"\"\n    attempt_download_files()\n\n    model_path = os.path.join(test_ckpt_dir, \"stories260K.bin\")\n    tokenizer_path = os.path.join(test_ckpt_dir, \"tok512.bin\")\n    command = [\"./run\", model_path, \"-z\", tokenizer_path, \"-t\", \"0.0\", \"-n\", \"200\"]\n    with open('err.txt', mode='wb') as fe:\n        with open('stdout.txt', mode='wb') as fo:\n            proc = subprocess.Popen(command, stdout=fo, stderr=fe)  #pipe in windows terminal does funny things like replacing \\n with \\r\\n\n            proc.wait()\n\n    with open('stdout.txt', mode='r') as f:\n        stdout = f.read()\n    # strip the very last \\n that is added by run.c for aesthetic reasons\n    stdout = stdout[:-1].encode('ascii')\n\n    assert stdout == expected_stdout\n\ndef test_python():\n    \"\"\" Forwards a model against a known-good desired outcome in sample.py for 200 steps\"\"\"\n    attempt_download_files()\n\n    device = \"cpu\" # stories260K is small enough to just breeze through it on CPU\n    checkpoint = os.path.join(test_ckpt_dir, \"stories260K.pt\")\n    checkpoint_dict = torch.load(checkpoint, map_location=device)\n    gptconf = ModelArgs(**checkpoint_dict['model_args'])\n    model = Transformer(gptconf)\n    state_dict = checkpoint_dict['model']\n    unwanted_prefix = '_orig_mod.'\n    for k,v in list(state_dict.items()):\n        if k.startswith(unwanted_prefix):\n            state_dict[k[len(unwanted_prefix):]] = state_dict.pop(k)\n    model.load_state_dict(state_dict, strict=False)\n    model.eval()\n    model.to(device)\n    x = torch.tensor([[1]], dtype=torch.long, device=device) # 1 is BOS\n    with torch.inference_mode():\n        y = model.generate(x, max_new_tokens=200, temperature=0.0)\n    pt_tokens = y[0].tolist()\n\n    tokenizer_model = os.path.join(test_ckpt_dir, \"tok512.model\")\n    enc = Tokenizer(tokenizer_model=tokenizer_model)\n    text = enc.decode(pt_tokens)\n    text = text.encode('ascii') # turn into bytes\n\n    assert text == expected_stdout\n"
        },
        {
          "name": "tinystories.py",
          "type": "blob",
          "size": 11.271484375,
          "content": "\"\"\"\nDownload, preprocess and serve the TinyStories dataset as a DataLoader.\n\"\"\"\n\nimport argparse\nimport glob\nimport json\nimport os\nimport random\nfrom typing import List\nfrom concurrent.futures import ProcessPoolExecutor\nfrom functools import partial\n\nimport numpy as np\nimport requests\nimport sentencepiece as spm\nimport torch\nimport torch.distributed as dist\nfrom tqdm import tqdm\n\nfrom tokenizer import Tokenizer\n\nDATA_CACHE_DIR = \"data\"\n\ndef download_file(url: str, fname: str, chunk_size=1024):\n    \"\"\"Helper function to download a file from a given url\"\"\"\n    resp = requests.get(url, stream=True)\n    total = int(resp.headers.get(\"content-length\", 0))\n    with open(fname, \"wb\") as file, tqdm(\n        desc=fname,\n        total=total,\n        unit=\"iB\",\n        unit_scale=True,\n        unit_divisor=1024,\n    ) as bar:\n        for data in resp.iter_content(chunk_size=chunk_size):\n            size = file.write(data)\n            bar.update(size)\n\n\ndef download():\n    \"\"\"Downloads the TinyStories dataset to DATA_CACHE_DIR\"\"\"\n    os.makedirs(DATA_CACHE_DIR, exist_ok=True)\n\n    # download the TinyStories dataset, unless it's already downloaded\n    data_url = \"https://huggingface.co/datasets/roneneldan/TinyStories/resolve/main/TinyStories_all_data.tar.gz\"\n    data_filename = os.path.join(DATA_CACHE_DIR, \"TinyStories_all_data.tar.gz\")\n    if not os.path.exists(data_filename):\n        print(f\"Downloading {data_url} to {data_filename}...\")\n        download_file(data_url, data_filename)\n    else:\n        print(f\"{data_filename} already exists, skipping download...\")\n\n    # unpack the tar.gz file into all the data shards (json files)\n    data_dir = os.path.join(DATA_CACHE_DIR, \"TinyStories_all_data\")\n    if not os.path.exists(data_dir):\n        os.makedirs(data_dir, exist_ok=True)\n        print(f\"Unpacking {data_filename}...\")\n        os.system(f\"tar -xzf {data_filename} -C {data_dir}\")\n    else:\n        print(f\"{data_dir} already exists, skipping unpacking...\")\n\n    # print a single example just for debugging and such\n    shard_filenames = sorted(glob.glob(os.path.join(data_dir, \"*.json\")))\n    with open(shard_filenames[0], \"r\") as f:\n        data = json.load(f)\n    print(\"Download done.\")\n    print(f\"Number of shards: {len(shard_filenames)}\")\n    print(f\"Example story:\\n{data[0]}\")\n\ndef train_vocab(vocab_size):\n    \"\"\"\n    Trains a custom sentencepiece tokenizer on the TinyStories dataset.\n    The custom tokenizer files will be saved in DATA_CACHE_DIR/tok{N} directories,\n    where N is the vocab size. This is also where the pretok .bin files will go.\n    \"\"\"\n    assert vocab_size > 0, \"Vocab size must be positive\"\n\n    # output file prefix path for sentencepiece\n    prefix = os.path.join(DATA_CACHE_DIR, f\"tok{vocab_size}\")\n\n    # how many shards we'll use for vocab training, kept low for efficiency\n    num_shards = 10\n\n    # 1) export a large chunk of text as a single text file tiny.txt\n    tiny_file = os.path.join(DATA_CACHE_DIR, \"tiny.txt\")\n    data_dir = os.path.join(DATA_CACHE_DIR, \"TinyStories_all_data\")\n    shard_filenames = sorted(glob.glob(os.path.join(data_dir, \"*.json\")))\n\n    print(f\"Writing temporary file {tiny_file} with {num_shards} shards...\")\n    with open(tiny_file, \"w\", encoding=\"utf-8\") as of:\n        for shard in tqdm(shard_filenames[:num_shards]):\n            with open(shard, \"r\") as f:\n                data = json.load(f)\n            for example in data:\n                text = example[\"story\"]\n                text = text.strip()\n                of.write(text + \"\\n\")\n    print(f\"Size is: {os.path.getsize(tiny_file) / 1024 / 1024:.2f} MB\")\n\n    # 2) train the sentencepiece model\n    print(\"Will now train the vocab...\")\n    spm.SentencePieceTrainer.train(input=tiny_file,\n                                   model_prefix=prefix,\n                                   model_type=\"bpe\",\n                                   vocab_size=vocab_size,\n                                   self_test_sample_size=0,\n                                   input_format=\"text\",\n                                   character_coverage=1.0,\n                                   num_threads=os.cpu_count(),\n                                   split_digits=True,\n                                   allow_whitespace_only_pieces=True,\n                                   byte_fallback=True,\n                                   unk_surface=r\" \\342\\201\\207 \",\n                                   normalization_rule_name=\"identity\")\n\n    # 3) optional cleanup, ask the user if they'd like to delete tiny.txt\n    dec = input(f\"Delete the temporary file {tiny_file}? [y/N] \")\n    if dec.lower() == \"y\":\n        os.remove(tiny_file)\n        print(f\"Deleted {tiny_file}\")\n\n    print(f\"Trained tokenizer is in {prefix}.model\")\n    print(\"Done.\")\n\n\ndef process_shard(args, vocab_size):\n    shard_id, shard = args\n    tokenizer_model = get_tokenizer_model_path(vocab_size)\n    enc = Tokenizer(tokenizer_model)\n    with open(shard, \"r\") as f:\n        data = json.load(f)\n    all_tokens = []\n    for example in tqdm(data, position=shard_id):\n        text = example[\"story\"]\n        text = text.strip()  # get rid of leading/trailing whitespace\n        tokens = enc.encode(text, bos=True, eos=False)  # encode the text, use BOS\n        all_tokens.extend(tokens)\n    # convert to uint16 nparray\n    all_tokens = np.array(all_tokens, dtype=np.uint16)\n    # calculate the output filename\n    if vocab_size == 0:\n        # if we're using Llama 2, just save the tokenized file in the same dir\n        tokenized_filename = shard.replace(\".json\", \".bin\")\n    else:\n        # save .bin files into a new tok{N} directory\n        bin_dir = os.path.join(DATA_CACHE_DIR, f\"tok{vocab_size}\")\n        shard_basename = os.path.basename(shard)\n        bin_basename = shard_basename.replace(\".json\", \".bin\")\n        tokenized_filename = os.path.join(bin_dir, bin_basename)\n    # write the bytes\n    with open(tokenized_filename, \"wb\") as f:\n        f.write(all_tokens.tobytes())\n    # calculate the average sequence length (they are separated by BOS=1)\n    avg_seq_len = all_tokens.size / ((all_tokens == 1).sum())\n    print(f\"Saved {tokenized_filename}, average seqlen: {avg_seq_len:.2f}\")\n\n\ndef pretokenize(vocab_size):\n    # iterate the shards and tokenize all of them one by one\n    data_dir = os.path.join(DATA_CACHE_DIR, \"TinyStories_all_data\")\n    shard_filenames = sorted(glob.glob(os.path.join(data_dir, \"*.json\")))\n    if vocab_size > 0:\n        # .bin files will be saved into tok{N} directory, create it once here\n        bin_dir = os.path.join(DATA_CACHE_DIR, f\"tok{vocab_size}\")\n        os.makedirs(bin_dir, exist_ok=True)\n\n    # process all the shards in a process pool\n    fun = partial(process_shard, vocab_size=vocab_size)\n    with ProcessPoolExecutor() as executor:\n        executor.map(fun, enumerate(shard_filenames))\n    print(\"Done.\")\n\n\nclass PretokDataset(torch.utils.data.IterableDataset):\n    \"\"\"Loads pretokenized examples from disk and yields them as PyTorch tensors.\"\"\"\n\n    def __init__(self, split, max_seq_len, vocab_size, vocab_source):\n        super().__init__()\n        self.split = split\n        self.max_seq_len = max_seq_len\n        self.vocab_size = vocab_size\n        self.vocab_source = vocab_source\n\n    def __iter__(self):\n        # get worker info within a DataLoader\n        worker_info = torch.utils.data.get_worker_info()\n        worker_id = worker_info.id if worker_info else 0\n        # get DDP rank info\n        rank = dist.get_rank() if dist.is_initialized() else 0\n        # combine the worker_id and worker_rank to create a unique seed for rng\n        seed = 42 + worker_id + 1337 * rank\n        rng = random.Random(seed)\n        print(f\"Created a PretokDataset with rng seed {seed}\")\n        if self.vocab_source == \"llama2\":\n            # the .bin files are right along the .json files\n            bin_dir = os.path.join(DATA_CACHE_DIR, \"TinyStories_all_data\")\n            shard_filenames = sorted(glob.glob(os.path.join(bin_dir, \"*.bin\")))\n        elif self.vocab_source == \"custom\":\n            # the .bin files are in tok{N} directory\n            bin_dir = os.path.join(DATA_CACHE_DIR, f\"tok{self.vocab_size}\")\n            shard_filenames = sorted(glob.glob(os.path.join(bin_dir, \"*.bin\")))\n        # train/test split. let's use only shard 0 for test split, rest train\n        shard_filenames = shard_filenames[1:] if self.split == \"train\" else shard_filenames[:1]\n        assert len(shard_filenames)>0, f\"No bin files found in {bin_dir}\"\n        while True:\n            rng.shuffle(shard_filenames)\n            for shard in shard_filenames:\n                # open the dataset for reading but keep it on disk with memmap\n                m = np.memmap(shard, dtype=np.uint16, mode=\"r\")\n                num_batches = len(m) // self.max_seq_len\n                num_batches -= 1  # drop the last partial batch\n                assert num_batches > 0, \"this shard is way too small? investigate.\"\n                ixs = list(range(num_batches))\n                rng.shuffle(ixs)\n                for ix in ixs:\n                    start = ix * self.max_seq_len\n                    end = start + self.max_seq_len + 1\n                    # calling .astype will copy the data into a new numpy array, now in RAM\n                    chunk = torch.from_numpy((m[start:end]).astype(np.int64))\n                    x = chunk[:-1]\n                    y = chunk[1:]\n                    yield x, y\n\n# -----------------------------------------------------------------------------\n# public interface functions\n\ndef get_tokenizer_model_path(vocab_size):\n    \"\"\"\n    Returns path to the sentencepiece tokenizer model for a given vocab size\n    vocab_size = 0 designates the default Llama 2 tokenizer, in that case\n    None is returned.\n    \"\"\"\n    if vocab_size == 0:\n        return None\n    else:\n        return os.path.join(DATA_CACHE_DIR, f\"tok{vocab_size}.model\")\n\nclass Task:\n\n    @staticmethod\n    def iter_batches(batch_size, device, num_workers=0, **dataset_kwargs):\n        ds = PretokDataset(**dataset_kwargs)\n        dl = torch.utils.data.DataLoader(\n            ds, batch_size=batch_size, pin_memory=True, num_workers=num_workers\n        )\n        for x, y in dl:\n            x = x.to(device, non_blocking=True)\n            y = y.to(device, non_blocking=True)\n            yield x, y\n\n# -----------------------------------------------------------------------------\n# CLI for constructing the dataset\n\nif __name__ == \"__main__\":\n    \"\"\"\n    These stages are designed to be run in order.\n\n    To tokenize data with the Llama 2 tokenizer:\n    python tinystories.py download\n    python tinystories.py pretokenize\n\n    To tokenize data with a custom tokenizer we train ourselves with sentencepiece, e.g.:\n    python tinystories.py download\n    python tinystories.py train_vocab --vocab_size=2048\n    python tinystories.py pretokenize --vocab_size=2048\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"stage\", type=str, choices=[\"download\", \"pretokenize\", \"train_vocab\"])\n    parser.add_argument(\"--vocab_size\", type=int, default=0, help=\"pretokenization vocab size. 0 = use Llama 2 tokenizer.\")\n    args = parser.parse_args()\n\n    # depending on the stage call the appropriate function\n    if args.stage == \"download\":\n        download()\n    elif args.stage == \"train_vocab\":\n        train_vocab(vocab_size=args.vocab_size)\n    elif args.stage == \"pretokenize\":\n        pretokenize(vocab_size=args.vocab_size)\n    else:\n        raise ValueError(f\"Unknown stage {args.stage}\")\n"
        },
        {
          "name": "tokenizer.bin",
          "type": "blob",
          "size": 423.7001953125,
          "content": null
        },
        {
          "name": "tokenizer.model",
          "type": "blob",
          "size": 488.0107421875,
          "content": null
        },
        {
          "name": "tokenizer.py",
          "type": "blob",
          "size": 2.798828125,
          "content": "# Taken from llama code and lightly modified\n# Copyright (c) Meta Platforms, Inc. and affiliates.\n# This software may be used and distributed according to the terms of the Llama 2 Community License Agreement.\n\nimport os\nimport struct\nimport argparse\nfrom typing import List\n\nfrom sentencepiece import SentencePieceProcessor\n\nTOKENIZER_MODEL = \"tokenizer.model\" # the llama sentencepiece tokenizer model\n\nclass Tokenizer:\n    def __init__(self, tokenizer_model=None):\n        model_path = tokenizer_model if tokenizer_model else TOKENIZER_MODEL\n        assert os.path.isfile(model_path), model_path\n        self.sp_model = SentencePieceProcessor(model_file=model_path)\n        self.model_path = model_path\n\n        # BOS / EOS token IDs\n        self.n_words: int = self.sp_model.vocab_size()\n        self.bos_id: int = self.sp_model.bos_id()\n        self.eos_id: int = self.sp_model.eos_id()\n        self.pad_id: int = self.sp_model.pad_id()\n        #print(f\"#words: {self.n_words} - BOS ID: {self.bos_id} - EOS ID: {self.eos_id}\")\n        assert self.sp_model.vocab_size() == self.sp_model.get_piece_size()\n\n    def encode(self, s: str, bos: bool, eos: bool) -> List[int]:\n        assert type(s) is str\n        t = self.sp_model.encode(s)\n        if bos:\n            t = [self.bos_id] + t\n        if eos:\n            t = t + [self.eos_id]\n        return t\n\n    def decode(self, t: List[int]) -> str:\n        return self.sp_model.decode(t)\n\n    def export(self):\n\n        # get all the tokens (postprocessed) and their scores as floats\n        tokens, scores = [], []\n        for i in range(self.n_words):\n\n            # decode the token and light postprocessing\n            t = self.sp_model.id_to_piece(i)\n            s = self.sp_model.get_score(i)\n            if i == self.bos_id:\n                t = '\\n<s>\\n'\n            elif i == self.eos_id:\n                t = '\\n</s>\\n'\n            t = t.replace('â–', ' ') # sentencepiece uses this character as whitespace\n            b = t.encode('utf-8') # bytes of this token, utf-8 encoded\n\n            tokens.append(b)\n            scores.append(s)\n\n        # record the max token length\n        max_token_length = max(len(t) for t in tokens)\n\n        # write to a binary file\n        # the tokenizer.bin file is the same as .model file, but .bin\n        tokenizer_bin = self.model_path.replace('.model', '.bin')\n        with open(tokenizer_bin, 'wb') as f:\n            f.write(struct.pack(\"I\", max_token_length))\n            for bytes, score in zip(tokens, scores):\n                f.write(struct.pack(\"fI\", score, len(bytes)))\n                f.write(bytes)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-t\", \"--tokenizer-model\", type=str, help=\"optional path to custom tokenizer \")\n    args = parser.parse_args()\n\n    t = Tokenizer(args.tokenizer_model)\n    t.export()\n"
        },
        {
          "name": "train.py",
          "type": "blob",
          "size": 13.5888671875,
          "content": "\"\"\"\nThis training script can be run both on a single gpu in debug mode,\nand also in a larger training run with distributed data parallel (ddp).\n\nTo run on a single GPU small debug run, example:\n$ python -m train.py --compile=False --eval_iters=10 --batch_size=8\n\nTo run with DDP on 4 gpus on 1 node, example:\n$ torchrun --standalone --nproc_per_node=4 train.py\n\nTo run with DDP on 4 gpus across 2 nodes, example:\n- Run on the first (master) node with example IP 123.456.123.456:\n$ torchrun --nproc_per_node=8 --nnodes=2 --node_rank=0 --master_addr=123.456.123.456 --master_port=1234 train.py\n- Run on the worker node:\n$ torchrun --nproc_per_node=8 --nnodes=2 --node_rank=1 --master_addr=123.456.123.456 --master_port=1234 train.py\n(If your cluster does not have Infiniband interconnect prepend NCCL_IB_DISABLE=1)\n\"\"\"\n\nimport math\nimport os\nimport time\nfrom contextlib import nullcontext\nfrom datetime import datetime\nfrom functools import partial\n\nimport torch\nfrom model import Transformer, ModelArgs\nfrom torch.distributed import destroy_process_group, init_process_group\nfrom torch.nn.parallel import DistributedDataParallel as DDP\n\nfrom tinystories import Task\nfrom export import model_export\n\n# -----------------------------------------------------------------------------\n# I/O\nout_dir = \"out\"\neval_interval = 2000\nlog_interval = 1\neval_iters = 100\neval_only = False  # if True, script exits right after the first eval\nalways_save_checkpoint = False  # if True, always save a checkpoint after each eval\ninit_from = \"scratch\"  # 'scratch' or 'resume'\n# wandb logging\nwandb_log = False  # disabled by default\nwandb_project = \"llamac\"\nwandb_run_name = \"run\" + datetime.now().strftime(\"%Y_%m_%d_%H_%M_%S\")\n# data\nbatch_size = 128  # if gradient_accumulation_steps > 1, this is the micro-batch size\nmax_seq_len = 256\nvocab_source = \"llama2\" # llama2|custom; use Lllama 2 vocab from Meta, or custom trained\nvocab_size = 32000 # the Llama 2 tokenizer has 32K tokens\n# model\ndim = 288\nn_layers = 6\nn_heads = 6\nn_kv_heads = 6\nmultiple_of = 32\ndropout = 0.0\n# adamw optimizer\ngradient_accumulation_steps = 4  # used to simulate larger batch sizes\nlearning_rate = 5e-4  # max learning rate\nmax_iters = 100000  # total number of training iterations\nweight_decay = 1e-1\nbeta1 = 0.9\nbeta2 = 0.95\ngrad_clip = 1.0  # clip gradients at this value, or disable if == 0.0\n# learning rate decay settings\ndecay_lr = True  # whether to decay the learning rate\nwarmup_iters = 1000  # how many steps to warm up for\n# system\ndevice = \"cuda\"  # examples: 'cpu', 'cuda', 'cuda:0', 'cuda:1' etc., or try 'mps' on macbooks\ndtype = \"bfloat16\"  # float32|bfloat16|float16\ncompile = True  # use PyTorch 2.0 to compile the model to be faster\n# -----------------------------------------------------------------------------\nconfig_keys = [\n    k\n    for k, v in globals().items()\n    if not k.startswith(\"_\") and isinstance(v, (int, float, bool, str))\n]\nexec(open(\"configurator.py\").read())  # overrides from command line or config file\nconfig = {k: globals()[k] for k in config_keys}  # will be useful for logging\n# -----------------------------------------------------------------------------\n\n# fixing some hyperparams to sensible defaults\nlr_decay_iters = max_iters  # should be ~= max_iters per Chinchilla\nmin_lr = 0.0  # minimum learning rate, should be ~= learning_rate/10 per Chinchilla\n\n# validating checks\nassert vocab_source in [\"llama2\", \"custom\"]\nassert vocab_source == \"custom\" or vocab_size == 32000, \"The vocab from Meta has 32K tokens\"\n\n# various inits, derived attributes, I/O setup\nddp = int(os.environ.get(\"RANK\", -1)) != -1  # is this a ddp run?\nif ddp:\n    init_process_group(backend=\"nccl\")\n    ddp_rank = int(os.environ[\"RANK\"])\n    ddp_local_rank = int(os.environ[\"LOCAL_RANK\"])\n    ddp_world_size = int(os.environ[\"WORLD_SIZE\"])\n    device = f\"cuda:{ddp_local_rank}\"\n    torch.cuda.set_device(device)\n    master_process = ddp_rank == 0  # this process will do logging, checkpointing etc.\n    seed_offset = ddp_rank  # each process gets a different seed\n    # world_size number of processes will be training simultaneously, so we can scale\n    # down the desired gradient accumulation iterations per process proportionally\n    assert gradient_accumulation_steps % ddp_world_size == 0\n    gradient_accumulation_steps //= ddp_world_size\nelse:\n    # if not ddp, we are running on a single gpu, and one process\n    master_process = True\n    seed_offset = 0\n    ddp_world_size = 1\ntokens_per_iter = gradient_accumulation_steps * ddp_world_size * batch_size * max_seq_len\nif master_process:\n    print(f\"tokens per iteration will be: {tokens_per_iter:,}\")\n    print(f\"breaks down as: {gradient_accumulation_steps} grad accum steps * {ddp_world_size} processes * {batch_size} batch size * {max_seq_len} max seq len\")\n\nif master_process:\n    os.makedirs(out_dir, exist_ok=True)\ntorch.manual_seed(1337 + seed_offset)\ntorch.backends.cuda.matmul.allow_tf32 = True  # allow tf32 on matmul\ntorch.backends.cudnn.allow_tf32 = True  # allow tf32 on cudnn\ndevice_type = \"cuda\" if \"cuda\" in device else \"cpu\"  # for later use in torch.autocast\n# note: float16 data type will automatically use a GradScaler\nptdtype = {\"float32\": torch.float32, \"bfloat16\": torch.bfloat16, \"float16\": torch.float16}[dtype]\nctx = (\n    nullcontext()\n    if device_type == \"cpu\"\n    else torch.amp.autocast(device_type=device_type, dtype=ptdtype)\n)\n\n# task-specific setup\niter_batches = partial(\n    Task.iter_batches,\n    batch_size=batch_size,\n    max_seq_len=max_seq_len,\n    vocab_size=vocab_size,\n    vocab_source=vocab_source,\n    device=device,\n    num_workers=0,\n)\n\n# init these up here, can override if init_from='resume' (i.e. from a checkpoint)\niter_num = 0\nbest_val_loss = 1e9\n\n# model init\nmodel_args = dict(\n    dim=dim,\n    n_layers=n_layers,\n    n_heads=n_heads,\n    n_kv_heads=n_kv_heads,\n    vocab_size=vocab_size,\n    multiple_of=multiple_of,\n    max_seq_len=max_seq_len,\n    dropout=dropout,\n)  # start with model_args from command line\nif init_from == \"scratch\":\n    # init a new model from scratch\n    print(\"Initializing a new model from scratch\")\n    gptconf = ModelArgs(**model_args)\n    model = Transformer(gptconf)\nelif init_from == \"resume\":\n    print(f\"Resuming training from {out_dir}\")\n    # resume training from a checkpoint.\n    ckpt_path = os.path.join(out_dir, \"ckpt.pt\")\n    checkpoint = torch.load(ckpt_path, map_location=device)\n    checkpoint_model_args = checkpoint[\"model_args\"]\n    # force these config attributes to be equal otherwise we can't even resume training\n    # the rest of the attributes (e.g. dropout) can stay as desired from command line\n    for k in [\"dim\", \"n_layers\", \"n_heads\", \"n_kv_heads\", \"vocab_size\", \"multiple_of\", \"max_seq_len\"]:\n        model_args[k] = checkpoint_model_args[k]\n    # create the model\n    gptconf = ModelArgs(**model_args)\n    model = Transformer(gptconf)\n    state_dict = checkpoint[\"model\"]\n    # fix the keys of the state dictionary :(\n    # honestly no idea how checkpoints sometimes get this prefix, have to debug more\n    unwanted_prefix = \"_orig_mod.\"\n    for k, v in list(state_dict.items()):\n        if k.startswith(unwanted_prefix):\n            state_dict[k[len(unwanted_prefix) :]] = state_dict.pop(k)\n    model.load_state_dict(state_dict)\n    iter_num = checkpoint[\"iter_num\"]\n    best_val_loss = checkpoint[\"best_val_loss\"]\nmodel.to(device)\n\n# initialize a GradScaler. If enabled=False scaler is a no-op\nscaler = torch.cuda.amp.GradScaler(enabled=(dtype == \"float16\"))\n\n# optimizer\noptimizer = model.configure_optimizers(weight_decay, learning_rate, (beta1, beta2), device_type)\nif init_from == \"resume\" and \"optimizer\" in checkpoint:\n    optimizer.load_state_dict(checkpoint[\"optimizer\"])\ncheckpoint = None  # free up memory\n\n# compile the model\nif compile:\n    print(\"compiling the model... (takes a ~minute)\")\n    unoptimized_model = model\n    model = torch.compile(model)  # requires PyTorch 2.0\n\n# wrap model into DDP container\nif ddp:\n    # Ignore the `freqs_cis` buffer so that DDP does not broadcast it at\n    # construction time since NCCL does not support `ComplexFloat`\n    prefix = \"_orig_mod.\" if compile else \"\"\n    model._ddp_params_and_buffers_to_ignore = {prefix + \"freqs_cis\"}\n    model = DDP(model, device_ids=[ddp_local_rank])\n\n# helps estimate an arbitrarily accurate loss over either split using many batches\n@torch.no_grad()\ndef estimate_loss():\n    out = {}\n    model.eval()\n    for split in [\"train\", \"val\"]:\n        batch_iter = iter_batches(split=split)\n        losses = torch.zeros(eval_iters)  # keep on CPU\n        for k in range(eval_iters):\n            X, Y = next(batch_iter)\n            with ctx:\n                logits = model(X, Y)\n                loss = raw_model.last_loss\n            losses[k] = loss.item()\n        out[split] = losses.mean()\n    model.train()\n    return out\n\n# learning rate decay scheduler (cosine with warmup)\ndef get_lr(it):\n    # 1) linear warmup for warmup_iters steps\n    if it < warmup_iters:\n        return learning_rate * it / warmup_iters\n    # 2) if it > lr_decay_iters, return min learning rate\n    if it > lr_decay_iters:\n        return min_lr\n    # 3) in between, use cosine decay down to min learning rate\n    decay_ratio = (it - warmup_iters) / (lr_decay_iters - warmup_iters)\n    assert 0 <= decay_ratio <= 1\n    coeff = 0.5 * (1.0 + math.cos(math.pi * decay_ratio))  # coeff ranges 0..1\n    return min_lr + coeff * (learning_rate - min_lr)\n\n# logging\nif wandb_log and master_process:\n    import wandb\n    wandb.init(project=wandb_project, name=wandb_run_name, config=config)\n\n# training loop\ntrain_batch_iter = iter_batches(split=\"train\")\nX, Y = next(train_batch_iter)  # fetch the very first batch\nt0 = time.time()\nlocal_iter_num = 0  # number of iterations in the lifetime of this process\nraw_model = model.module if ddp else model  # unwrap DDP container if needed\nrunning_mfu = -1.0\nwhile True:\n    # determine and set the learning rate for this iteration\n    lr = get_lr(iter_num) if decay_lr else learning_rate\n    for param_group in optimizer.param_groups:\n        param_group[\"lr\"] = lr\n\n    # evaluate the loss on train/val sets and write checkpoints\n    if iter_num % eval_interval == 0 and master_process:\n        losses = estimate_loss()\n        print(f\"step {iter_num}: train loss {losses['train']:.4f}, val loss {losses['val']:.4f}\")\n        if wandb_log:\n            try:\n                wandb.log(\n                    {\n                        \"iter\": iter_num,\n                        \"tokens\": iter_num * tokens_per_iter,\n                        \"loss/train\": losses[\"train\"],\n                        \"loss/val\": losses[\"val\"],\n                        \"lr\": lr,\n                        \"mfu\": running_mfu * 100,  # convert to percentage\n                    }, step = iter_num\n                )\n            except Exception as e:\n                print(f\"logging to wandb failed: {e}\")\n        if losses[\"val\"] < best_val_loss or always_save_checkpoint:\n            best_val_loss = losses[\"val\"]\n            if iter_num > 0:\n                checkpoint = {\n                    \"model\": raw_model.state_dict(),\n                    \"optimizer\": optimizer.state_dict(),\n                    \"model_args\": model_args,\n                    \"iter_num\": iter_num,\n                    \"best_val_loss\": best_val_loss,\n                    \"config\": config,\n                }\n                print(f\"saving checkpoint to {out_dir}\")\n                torch.save(checkpoint, os.path.join(out_dir, \"ckpt.pt\"))\n                model_export(raw_model, os.path.join(out_dir, \"model.bin\"), version=0)\n    if iter_num == 0 and eval_only:\n        break\n\n    # forward backward update, with optional gradient accumulation to simulate larger batch size\n    # and using the GradScaler if data type is float16\n    for micro_step in range(gradient_accumulation_steps):\n        if ddp:\n            # in DDP training we only need to sync gradients at the last micro step.\n            # the official way to do this is with model.no_sync() context manager, but\n            # I really dislike that this bloats the code and forces us to repeat code\n            # looking at the source of that context manager, it just toggles this variable\n            model.require_backward_grad_sync = micro_step == gradient_accumulation_steps - 1\n        with ctx:\n            logits = model(X, Y)\n            loss = raw_model.last_loss\n            loss = loss / gradient_accumulation_steps\n        # immediately async prefetch next batch while model is doing the forward pass on the GPU\n        X, Y = next(train_batch_iter)\n        # backward pass, with gradient scaling if training in fp16\n        scaler.scale(loss).backward()\n    # clip the gradient\n    if grad_clip != 0.0:\n        scaler.unscale_(optimizer)\n        torch.nn.utils.clip_grad_norm_(model.parameters(), grad_clip)\n    # step the optimizer and scaler if training in fp16\n    scaler.step(optimizer)\n    scaler.update()\n    # flush the gradients as soon as we can, no need for this memory anymore\n    optimizer.zero_grad(set_to_none=True)\n\n    # timing and logging\n    t1 = time.time()\n    dt = t1 - t0\n    t0 = t1\n    if iter_num % log_interval == 0 and master_process:\n        # get loss as float, scale up due to the divide above. note: this is a CPU-GPU sync point\n        lossf = loss.item() * gradient_accumulation_steps\n        if local_iter_num >= 5:  # let the training loop settle a bit\n            mfu = raw_model.estimate_mfu(batch_size * gradient_accumulation_steps, dt)\n            running_mfu = mfu if running_mfu == -1.0 else 0.9 * running_mfu + 0.1 * mfu\n        print(\n            f\"{iter_num} | loss {lossf:.4f} | lr {lr:e} | {dt*1000:.2f}ms | mfu {running_mfu*100:.2f}%\"\n        )\n    iter_num += 1\n    local_iter_num += 1\n\n    # termination conditions\n    if iter_num > max_iters:\n        break\n\nif ddp:\n    destroy_process_group()\n"
        },
        {
          "name": "win.c",
          "type": "blob",
          "size": 4.1689453125,
          "content": "#include \"win.h\"\r\n#include <errno.h>\r\n#include <io.h>\r\n\r\n#ifndef FILE_MAP_EXECUTE\r\n#define FILE_MAP_EXECUTE    0x0020\r\n#endif /* FILE_MAP_EXECUTE */\r\n\r\nstatic int __map_mman_error(const uint32_t err, const int deferr)\r\n{\r\n    if (err == 0)\r\n        return 0;\r\n    //TODO: implement\r\n    return err;\r\n}\r\n\r\nstatic uint32_t __map_mmap_prot_page(const int prot)\r\n{\r\n    uint32_t protect = 0;\r\n    \r\n    if (prot == PROT_NONE)\r\n        return protect;\r\n        \r\n    if ((prot & PROT_EXEC) != 0)\r\n    {\r\n        protect = ((prot & PROT_WRITE) != 0) ? \r\n                    PAGE_EXECUTE_READWRITE : PAGE_EXECUTE_READ;\r\n    }\r\n    else\r\n    {\r\n        protect = ((prot & PROT_WRITE) != 0) ?\r\n                    PAGE_READWRITE : PAGE_READONLY;\r\n    }\r\n    \r\n    return protect;\r\n}\r\n\r\nstatic uint32_t __map_mmap_prot_file(const int prot)\r\n{\r\n    uint32_t desiredAccess = 0;\r\n    \r\n    if (prot == PROT_NONE)\r\n        return desiredAccess;\r\n        \r\n    if ((prot & PROT_READ) != 0)\r\n        desiredAccess |= FILE_MAP_READ;\r\n    if ((prot & PROT_WRITE) != 0)\r\n        desiredAccess |= FILE_MAP_WRITE;\r\n    if ((prot & PROT_EXEC) != 0)\r\n        desiredAccess |= FILE_MAP_EXECUTE;\r\n    \r\n    return desiredAccess;\r\n}\r\n\r\nvoid* mmap(void *addr, size_t len, int prot, int flags, int fildes, ssize_t off)\r\n{\r\n    HANDLE fm, h;\r\n    void * map = MAP_FAILED;\r\n    \r\n#ifdef _MSC_VER\r\n#pragma warning(push)\r\n#pragma warning(disable: 4293)\r\n#endif\r\n\r\n    const uint32_t dwFileOffsetLow = (uint32_t)(off & 0xFFFFFFFFL);\r\n    const uint32_t dwFileOffsetHigh = (uint32_t)((off >> 32) & 0xFFFFFFFFL);\r\n    const uint32_t protect = __map_mmap_prot_page(prot);\r\n    const uint32_t desiredAccess = __map_mmap_prot_file(prot);\r\n\r\n    const ssize_t maxSize = off + (ssize_t)len;\r\n\r\n    const uint32_t dwMaxSizeLow = (uint32_t)(maxSize & 0xFFFFFFFFL);\r\n    const uint32_t dwMaxSizeHigh = (uint32_t)((maxSize >> 32) & 0xFFFFFFFFL);\r\n\r\n#ifdef _MSC_VER\r\n#pragma warning(pop)\r\n#endif\r\n\r\n    errno = 0;\r\n    \r\n    if (len == 0 \r\n        /* Unsupported flag combinations */\r\n        || (flags & MAP_FIXED) != 0\r\n        /* Unsupported protection combinations */\r\n        || prot == PROT_EXEC)\r\n    {\r\n        errno = EINVAL;\r\n        return MAP_FAILED;\r\n    }\r\n    \r\n    h = ((flags & MAP_ANONYMOUS) == 0) ? \r\n                    (HANDLE)_get_osfhandle(fildes) : INVALID_HANDLE_VALUE;\r\n\r\n    if ((flags & MAP_ANONYMOUS) == 0 && h == INVALID_HANDLE_VALUE)\r\n    {\r\n        errno = EBADF;\r\n        return MAP_FAILED;\r\n    }\r\n\r\n    fm = CreateFileMapping(h, NULL, protect, dwMaxSizeHigh, dwMaxSizeLow, NULL);\r\n\r\n    if (fm == NULL)\r\n    {\r\n        errno = __map_mman_error(GetLastError(), EPERM);\r\n        return MAP_FAILED;\r\n    }\r\n\r\n    map = MapViewOfFile(fm, desiredAccess, dwFileOffsetHigh, dwFileOffsetLow, len);\r\n\r\n    CloseHandle(fm);\r\n\r\n    if (map == NULL)\r\n    {\r\n        errno = __map_mman_error(GetLastError(), EPERM);\r\n        return MAP_FAILED;\r\n    }\r\n\r\n    return map;\r\n}\r\n\r\nint munmap(void *addr, size_t len)\r\n{\r\n    if (UnmapViewOfFile(addr))\r\n        return 0;\r\n        \r\n    errno =  __map_mman_error(GetLastError(), EPERM);\r\n    \r\n    return -1;\r\n}\r\n\r\nint mprotect(void *addr, size_t len, int prot)\r\n{\r\n    uint32_t newProtect = __map_mmap_prot_page(prot);\r\n    uint32_t oldProtect = 0;\r\n    \r\n    if (VirtualProtect(addr, len, newProtect, &oldProtect))\r\n        return 0;\r\n    \r\n    errno =  __map_mman_error(GetLastError(), EPERM);\r\n    \r\n    return -1;\r\n}\r\n\r\nint msync(void *addr, size_t len, int flags)\r\n{\r\n    if (FlushViewOfFile(addr, len))\r\n        return 0;\r\n    \r\n    errno =  __map_mman_error(GetLastError(), EPERM);\r\n    \r\n    return -1;\r\n}\r\n\r\nint mlock(const void *addr, size_t len)\r\n{\r\n    if (VirtualLock((LPVOID)addr, len))\r\n        return 0;\r\n        \r\n    errno =  __map_mman_error(GetLastError(), EPERM);\r\n    \r\n    return -1;\r\n}\r\n\r\nint munlock(const void *addr, size_t len)\r\n{\r\n    if (VirtualUnlock((LPVOID)addr, len))\r\n        return 0;\r\n        \r\n    errno =  __map_mman_error(GetLastError(), EPERM);\r\n    \r\n    return -1;\r\n}\r\n\r\n// Portable clock_gettime function for Windows\r\nint clock_gettime(int clk_id, struct timespec *tp) {\r\n    uint32_t ticks = GetTickCount();\r\n    tp->tv_sec = ticks / 1000;\r\n    tp->tv_nsec = (ticks % 1000) * 1000000;\r\n    return 0;\r\n}\r\n"
        },
        {
          "name": "win.h",
          "type": "blob",
          "size": 1.57421875,
          "content": "#ifndef _WIN_H_\n#define _WIN_H_\n\n#define WIN32_LEAN_AND_MEAN      // Exclude rarely-used stuff from Windows headers\n#include <windows.h>\n#include <time.h>\n#include <stdint.h>\n\n#define ssize_t int64_t\n#define ftell _ftelli64\n\n// Below code is originally from mman-win32\n//\n/*\n * sys/mman.h\n * mman-win32\n */\n\n#ifndef _WIN32_WINNT            // Allow use of features specific to Windows XP or later.\n#define _WIN32_WINNT    0x0501  // Change this to the appropriate value to target other versions of Windows.\n#endif\n\n/* All the headers include this file. */\n#ifndef _MSC_VER\n#include <_mingw.h>\n#endif\n\n#include <sys/types.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define PROT_NONE       0\n#define PROT_READ       1\n#define PROT_WRITE      2\n#define PROT_EXEC       4\n\n#define MAP_FILE        0\n#define MAP_SHARED      1\n#define MAP_PRIVATE     2\n#define MAP_TYPE        0xf\n#define MAP_FIXED       0x10\n#define MAP_ANONYMOUS   0x20\n#define MAP_ANON        MAP_ANONYMOUS\n\n#define MAP_FAILED      ((void *)-1)\n\n/* Flags for msync. */\n#define MS_ASYNC        1\n#define MS_SYNC         2\n#define MS_INVALIDATE   4\n\n/* Flags for portable clock_gettime call. */\n#define CLOCK_REALTIME  0\n\nvoid*   mmap(void *addr, size_t len, int prot, int flags, int fildes, ssize_t off);\nint     munmap(void *addr, size_t len);\nint     mprotect(void *addr, size_t len, int prot);\nint     msync(void *addr, size_t len, int flags);\nint     mlock(const void *addr, size_t len);\nint     munlock(const void *addr, size_t len);\nint     clock_gettime(int clk_id, struct timespec *tp);\n\n#ifdef __cplusplus\n};\n#endif\n\n#endif /*  _WIN_H_ */\n"
        }
      ]
    }
  ]
}