{
  "metadata": {
    "timestamp": 1736710467972,
    "page": 101,
    "hasNextPage": false,
    "endCursor": "Y3Vyc29yOjEwMw==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "phpredis/phpredis",
      "stars": 10029,
      "defaultBranch": "develop",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.119140625,
          "content": "/.github export-ignore\n/docs export-ignore\n.gitattributes export-ignore\n.gitignore export-ignore\n.gitmodules export-ignore"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.22265625,
          "content": "/.github\n/.idea\n/.vscode\n/docs/.cache\n.cquery\n*.deps\n*.libs\n*.o\n*.lo\nMakefile*\nconfigure*\nac*.m4\nconfig.*\ninstall-sh\nlibtool\n./*.sh\nbuild*\nmissing\nautom4te.cache\nmkinstalldirs\ntags\ncompile_commands.json\ndoctum.phar\nrun-tests.php"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.1025390625,
          "content": "[submodule \"liblzf\"]\n    path = liblzf\n    url = https://github.com/nemequ/liblzf.git\n    ignore = dirty\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 128.845703125,
          "content": "# Changelog\n\nAll changes to phpredis will be documented in this file.\n\nWe're basing this format on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand PhpRedis adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [6.1.0] - 2024-10-04 ([Github](https://github.com/phpredis/phpredis/releases/6.1.0), [PECL](https://pecl.php.net/package/redis/6.1.0))\n\n**NOTE**: There were no changes to C code between 6.1.0RC2 and 6.1.0.\n\n### Documentation\n\n- Update package.xml to make it clearer that we support many key-value stores\n  [52e69ede](https://github.com/phpredis/phpredis/commit/52e69ede)\n  ([Remi Collet](https://github.com/remicollet))\n- Fix redis.io urls\n  [0bae4bb0](https://github.com/phpredis/phpredis/commit/0bae4bb0)\n  ([Vincent Langlet](https://github.com/VincentLanglet))\n\n### Tests/CI\n\n- Fix 2 tests with redis 6.2\n  [cc1be322](https://github.com/phpredis/phpredis/commit/cc1be322)\n  ([Remi Collet](https://github.com/remicollet))\n\n### Sponsors :sparkling_heart:\n\n- [A-VISION](https://github.com/A-VISION-BV)\n- [Open LMS](https://openlms.net/)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n- [Ty Karok](https://github.com/karock)\n- [Object Cache Pro for WordPress](https://objectcache.pro/)\n\n### Contributors to this release :sparkling_heart:\n\n  [@michael-grunder](https://github.com/michael-grunder),\n  [@yatsukhnenko](https://github.com/yatsukhnenko),\n  [@bitactive](https://github.com/bitactive),\n  [@OrangeJuiced](https://github.com/OrangeJuiced),\n  [@crocodele](https://github.com/crocodele),\n  [@kalifg](https://github.com/kalifg),\n  [@divinity76](https://github.com/divinity76),\n  [@PlavorSeol](https://github.com/PlavorSeol),\n  [@kjoe](https://github.com/kjoe),\n  [@tstarling](https://github.com/tstarling),\n  [@acorncom](https://github.com/acorncom),\n  [@tuxmartin](https://github.com/tuxmartin),\n  [@BenMorel](https://github.com/BenMorel),\n  [@szepeviktor](https://github.com/szepeviktor),\n  [@SplotyCode](https://github.com/SplotyCode),\n  [@taka-oyama](https://github.com/taka-oyama),\n  [@PROFeNoM](https://github.com/PROFeNoM),\n  [@woodongwong](https://github.com/woodongwong),\n  [@RobiNN1](https://github.com/RobiNN1),\n  [@vtsykun](https://github.com/vtsykun),\n  [@solracsf](https://github.com/solracsf),\n  [@tillkruss](https://github.com/tillkruss),\n  [@deiga](https://github.com/deiga),\n  [@tutuna](https://github.com/tutuna)\n  [@VincentLanglet](https://github.com/VincentLanglet)\n\n\n## [6.1.0RC2] - 2024-09-23 ([Github](https://github.com/phpredis/phpredis/releases/6.1.0RC2), [PECL](https://pecl.php.net/package/redis/6.1.0RC2))\n\n### Fixed\n\n- Fixed a `SIGABRT` error in PHP 8.4\n  [a75a7e5a](https://github.com/phpredis/phpredis/commit/a75a7e5a)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Clean up code for unsupported versions of PHP\n  [37cebdd7](https://github.com/phpredis/phpredis/commit/37cebdd7)\n  ([Remi Collet](https://github.com/remicollet))\n- Add `SessionHelpers.php` to `package.xml`\n  [e9474b80](https://github.com/phpredis/phpredis/commit/e9474b80)\n  ([Remi Collet](https://github.com/remicollet))\n- 8.4 implicit null fix, bump version\n  [bff3a22e](https://github.com/phpredis/phpredis/commit/bff3a22e)\n  [30c8f90c](https://github.com/phpredis/phpredis/commit/30c8f90c)\n  ([Remi Collet](https://github.com/remicollet))\n\n### Changed\n\n- Raised minimum supported PHP version to 7.4\n  [8b519423](https://github.com/phpredis/phpredis/commit/8b519423)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n### Removed\n\n- Removed erroneously duplicated changelog entries\n  [40c89736](https://github.com/phpredis/phpredis/commit/40c89736)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n### Tests/CI\n\n- Move to upload artifacts v4\n  [9d3805009](https://github.com/phpredis/phpredis/commit/9d3805009)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n### Added\n\n- Added `composer.json` to support [PIE](https://github.com/php/pie) (PHP Installer for Extensions)\n  [b59e35a6](https://github.com/phpredis/phpredis/commit/b59e35a6)\n  ([James Titcumb](https://github.com/asgrim))\n\n## [6.1.0RC1] - 2024-08-04 ([GitHub](https://github.com/phpredis/phpredis/releases/6.1.0RC1), [PECL](https://pecl.php.net/package/redis/6.1.0RC1))\n\n### Fixed\n\n- Fix random connection timeouts with Redis Cluster.\n  [eb7f31e7](https://github.com/phpredis/phpredis/commit/eb7f31e7)\n  ([Jozsef Koszo](https://github.com/kjoe))\n  [#1142](https://github.com/phpredis/phpredis/pull/1142)\n  [#1385](https://github.com/phpredis/phpredis/pull/1385)\n  [#1633](https://github.com/phpredis/phpredis/pull/1633)\n  [#1707](https://github.com/phpredis/phpredis/pull/1707)\n  [#1811](https://github.com/phpredis/phpredis/pull/1811)\n  [#2407](https://github.com/phpredis/phpredis/pull/2407)\n- Fix argument count issue in HSET with associative array\n  [6ea5b3e0](https://github.com/phpredis/phpredis/commit/6ea5b3e0)\n  ([Viktor Djupsj√∂backa](https://github.com/crocodele))\n- SRANDMEMBER can return any type because of serialization.\n  [6673b5b2](https://github.com/phpredis/phpredis/commit/6673b5b2)\n  ([michael-grunder](https://github.com/michael-grunder))\n- Fix HRANDFIELD command when WITHVALUES is used.\n  [99f9fd83](https://github.com/phpredis/phpredis/commit/99f9fd83)\n  ([Michael Grunder](https://github.com/michael-grunder))\n  [#2524](https://github.com/phpredis/phpredis/pull/2524)\n- Allow context array to be nullable\n  [50529f56](https://github.com/phpredis/phpredis/commit/50529f56)\n  ([michael-grunder](https://github.com/michael-grunder))\n  [#2521](https://github.com/phpredis/phpredis/pull/2521)\n- Fix a macOS (M1) compiler warning.\n  [7de29d57](https://github.com/phpredis/phpredis/commit/7de29d57)\n  ([michael-grunder](https://github.com/michael-grunder))\n- `GETEX` documentation/updates and implentation in `RedisCluster`\n  [981c6931](https://github.com/phpredis/phpredis/commit/981c6931)\n  ([michael-grunder](https://github.com/michael-grunder))\n  [#2512](https://github.com/phpredis/phpredis/pull/2512)\n- Refactor redis_script_cmd and fix to `flush` subcommand.\n  [7c551424](https://github.com/phpredis/phpredis/commit/7c551424)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Update liveness check and fix PHP 8.4 compilation error.\n  [c139de3a](https://github.com/phpredis/phpredis/commit/c139de3a)\n  ([michael-grunder](https://github.com/michael-grunder))\n- Rework how we declare ZSTD min/max constants.\n  [34b5bd81](https://github.com/phpredis/phpredis/commit/34b5bd81)\n  ([michael-grunder](https://github.com/michael-grunder))\n  [#2487](https://github.com/phpredis/phpredis/pull/2487)\n- Fix memory leak if we fail in ps_open_redis.\n  [0e926165](https://github.com/phpredis/phpredis/commit/0e926165)\n  ([michael-grunder](https://github.com/michael-grunder))\n- Fix segfault and remove redundant macros\n  [a9e53fd1](https://github.com/phpredis/phpredis/commit/a9e53fd1)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix PHP 8.4 includes\n  [a51215ce](https://github.com/phpredis/phpredis/commit/a51215ce)\n  [#2463](https://github.com/phpredis/phpredis/pull/2463)\n  ([michael-grunder](https://github.com/michael-grunder))\n- Handle arbitrarily large `SCAN` cursors properly.\n  [2612d444](https://github.com/phpredis/phpredis/commit/2612d444)\n  [e52f0afa](https://github.com/phpredis/phpredis/commit/e52f0afa)\n  [#2454](https://github.com/phpredis/phpredis/pull/2454)\n  [#2458](https://github.com/phpredis/phpredis/pull/2458)\n  ([michael-grunder](https://github.com/michael-grunder))\n- Improve warning when we encounter an invalid EXPIRY in SET\n  [732e466a](https://github.com/phpredis/phpredis/commit/732e466a)\n  [#2448](https://github.com/phpredis/phpredis/pull/2448)\n  ([michael-grunder](https://github.com/michael-grunder))\n- Fix Arginfo / zpp mismatch for DUMP command\n  [50e5405c](https://github.com/phpredis/phpredis/commit/50e5405c)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- RedisCluster::publish returns a cluster_long_resp\n  [14f93339](https://github.com/phpredis/phpredis/commit/14f93339)\n  ([Alexandre Choura](https://github.com/PROFeNoM))\n- Fix segfault when passing just false to auth.\n  [6dc0a0be](https://github.com/phpredis/phpredis/commit/6dc0a0be)\n  [#2430](https://github.com/phpredis/phpredis/pull/2430)\n  ([michael-grunder](https://github.com/michael-grunder))\n- the VALUE argument type for hSetNx must be the same as for hSet\n  [df074dbe](https://github.com/phpredis/phpredis/commit/df074dbe)\n  ([U≈Çadzimir Tsykun](https://github.com/vtsykun))\n- Other fixes\n  [e18f6c6d](https://github.com/phpredis/phpredis/commit/e18f6c6d)\n  [3d7be358](https://github.com/phpredis/phpredis/commit/3d7be358)\n  [2b555c89](https://github.com/phpredis/phpredis/commit/2b555c89)\n  [fa1a283a](https://github.com/phpredis/phpredis/commit/fa1a283a)\n  ([michael-grunder](https://github.com/michael-grunder))\n  [37c5f8d4](https://github.com/phpredis/phpredis/commit/37c5f8d4)\n  ([Viktor Sz√©pe](https://github.com/szepeviktor))\n\n### Added\n\n- Compression support for PHP sessions.\n  [da4ab0a7](https://github.com/phpredis/phpredis/commit/da4ab0a7)\n  [#2473](https://github.com/phpredis/phpredis/pull/2473)\n  ([bitactive](https://github.com/bitactive))\n- Support for early_refresh in Redis sessions to match cluster behavior\n  [b6989018](https://github.com/phpredis/phpredis/commit/b6989018)\n  ([Bitactive](https://github.com/bitactive))\n- Implement WAITAOF command.\n  [ed7c9f6f](https://github.com/phpredis/phpredis/commit/ed7c9f6f)\n  ([michael-grunder](https://github.com/michael-grunder))\n\n### Removed\n\n- PHP 7.1, 7.2, and 7.3 CI jobs\n  [d68c30f8](https://github.com/phpredis/phpredis/commit/d68c30f8)\n  [dc39bd55](https://github.com/phpredis/phpredis/commit/dc39bd55)\n  [#2478](https://github.com/phpredis/phpredis/pull/2478)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n### Changed\n\n- Fix the time unit of retry_interval\n  [3fdd52b4](https://github.com/phpredis/phpredis/commit/3fdd52b4)\n  ([woodong](https://github.com/woodongwong))\n\n### Documentation\n\n- Many documentation fixes.\n  [eeb51099](https://github.com/phpredis/phpredis/commit/eeb51099)\n  ([Michael Dwyer](https://github.com/kalifg))\n  [#2523](https://github.com/phpredis/phpredis/pull/2523)\n- fix missing \\<code\\> tags\n  [f865d5b9](https://github.com/phpredis/phpredis/commit/f865d5b9)\n  ([divinity76](https://github.com/divinity76))\n- Mention Valkey support\n  [5f1eecfb](https://github.com/phpredis/phpredis/commit/5f1eecfb)\n  ([PlavorSeol](https://github.com/PlavorSeol))\n- Mention KeyDB support in README.md\n  [37fa3592](https://github.com/phpredis/phpredis/commit/37fa3592)\n  ([Tim Starling](https://github.com/tstarling))\n- Remove mention of pickle\n  [c7a73abb](https://github.com/phpredis/phpredis/commit/c7a73abb)\n  ([David Baker](https://github.com/acorncom))\n- Add session.save_path examples\n  [8a39caeb](https://github.com/phpredis/phpredis/commit/8a39caeb)\n  ([Martin Vancl](https://github.com/tuxmartin))\n- Tighter return types for Redis::(keys|hKeys|hVals|hGetAll)()\n  [77ab62bc](https://github.com/phpredis/phpredis/commit/77ab62bc)\n  ([Benjamin Morel](https://github.com/BenMorel))\n- Update stubs\n  [4d233977](https://github.com/phpredis/phpredis/commit/4d233977)\n  [ff305349](https://github.com/phpredis/phpredis/commit/ff305349)\n  [12966a74](https://github.com/phpredis/phpredis/commit/12966a74)\n  [a4a283ab](https://github.com/phpredis/phpredis/commit/a4a283ab)\n  ([michael-grunder](https://github.com/michael-grunder))\n  [8f8ff72a](https://github.com/phpredis/phpredis/commit/8f8ff72a)\n  ([Takayasu Oyama](https://github.com/taka-oyama))\n  [5d293245](https://github.com/phpredis/phpredis/commit/5d293245)\n- Fix config.m4 when using custom dep paths\n  [ece3f7be](https://github.com/phpredis/phpredis/commit/ece3f7be)\n  ([Michael Grunder](https://github.com/michael-grunder))\n  [#2453](https://github.com/phpredis/phpredis/pull/2453)\n  [#2452](https://github.com/phpredis/phpredis/pull/2452)\n- Fix retry_internal documentation\n  [142c1f4a](https://github.com/phpredis/phpredis/commit/142c1f4a)\n  ([SplotyCode](https://github.com/SplotyCode))\n- Fix anchor link\n  [9b5cad31](https://github.com/phpredis/phpredis/commit/9b5cad31)\n  ([Git'Fellow](https://github.com/solracsf))\n- Fix typo in link\n  [bfd379f0](https://github.com/phpredis/phpredis/commit/bfd379f0)\n  [#2349](https://github.com/phpredis/phpredis/pull/2349)\n  ([deiga](https://github.com/deiga))\n- Fix Fedora package url\n  [60b1ba14](https://github.com/phpredis/phpredis/commit/60b1ba14)\n  [717713e1](https://github.com/phpredis/phpredis/commit/717713e1)\n  ([Dmitrii Kotov](https://github.com/tutunak))\n- Update Redis Sentinel documentation to reflect changes to constructor in 6.0 release\n  [dc05d65c](https://github.com/phpredis/phpredis/commit/dc05d65c)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n  [#2381](https://github.com/phpredis/phpredis/pull/2381)\n\n### Tests/CI\n\n- Avoid fatal error in test execution.\n  [57304970](https://github.com/phpredis/phpredis/commit/57304970)\n  ([Michael Grunder](https://github.com/michael-grunder))\n  [#2510](https://github.com/phpredis/phpredis/pull/2510)\n- Refactor unit test framework.\n  [b1771def](https://github.com/phpredis/phpredis/commit/b1771def)\n  ([Michael Grunder](https://github.com/michael-grunder))\n  [#2509](https://github.com/phpredis/phpredis/pull/2509)\n- Get unit tests working in `php-cgi`.\n  [b808cc60](https://github.com/phpredis/phpredis/commit/b808cc60)\n  ([michael-grunder](https://github.com/michael-grunder))\n  [#2507](https://github.com/phpredis/phpredis/pull/2507)\n- Switch to `ZEND_STRL` in more places.\n  [7050c989](https://github.com/phpredis/phpredis/commit/7050c989)\n  [f8c762e7](https://github.com/phpredis/phpredis/commit/f8c762e7)\n  ([Michael Grunder](https://github.com/michael-grunder))\n  [#2505](https://github.com/phpredis/phpredis/pull/2505)\n- Workaround weird PHP compiler crash.\n  [d3b2d87b](https://github.com/phpredis/phpredis/commit/d3b2d87b)\n  ([michael-grunder](https://github.com/michael-grunder))\n- Refactor tests (formatting, modernization, etc).\n  [dab6a62d](https://github.com/phpredis/phpredis/commit/dab6a62d)\n  [c6cd665b](https://github.com/phpredis/phpredis/commit/c6cd665b)\n  [78b70ca8](https://github.com/phpredis/phpredis/commit/78b70ca8)\n  [3c125b09](https://github.com/phpredis/phpredis/commit/3c125b09)\n  [18b0da72](https://github.com/phpredis/phpredis/commit/18b0da72)\n  [b88e72b1](https://github.com/phpredis/phpredis/commit/b88e72b1)\n  [#2492](https://github.com/phpredis/phpredis/pull/2492)\n  [0f94d9c1](https://github.com/phpredis/phpredis/commit/0f94d9c1)\n  [59965971](https://github.com/phpredis/phpredis/commit/59965971)\n  [3dbc2bd8](https://github.com/phpredis/phpredis/commit/3dbc2bd8)\n  [9b90c03b](https://github.com/phpredis/phpredis/commit/9b90c03b)\n  [c0d6f042](https://github.com/phpredis/phpredis/commit/c0d6f042)\n  ([michael-grunder](https://github.com/michael-grunder))\n- Spelling fixes\n  [0d89e928](https://github.com/phpredis/phpredis/commit/0d89e928)\n  ([michael-grunder](https://github.com/michael-grunder))\n- Added Valkey support.\n  [f350dc34](https://github.com/phpredis/phpredis/commit/f350dc34)\n  ([michael-grunder](https://github.com/michael-grunder))\n- Add a test for session compression.\n  [9f3ca98c](https://github.com/phpredis/phpredis/commit/9f3ca98c)\n  ([michael-grunder](https://github.com/michael-grunder))\n  [#2473](https://github.com/phpredis/phpredis/pull/2473)\n  [#2480](https://github.com/phpredis/phpredis/pull/2480)\n- Test against valkey\n  [a819a44b](https://github.com/phpredis/phpredis/commit/a819a44b)\n  ([michael-grunder](https://github.com/michael-grunder))\n- sessionSaveHandler injection.\n  [9f8f80ca](https://github.com/phpredis/phpredis/commit/9f8f80ca)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- KeyDB addiions\n  [54d62c72](https://github.com/phpredis/phpredis/commit/54d62c72)\n  [d9c48b78](https://github.com/phpredis/phpredis/commit/d9c48b78)\n  [#2466](https://github.com/phpredis/phpredis/pull/2466)\n  ([michael-grunder](https://github.com/michael-grunder))\n- Add PHP 8.3 to CI\n  [78d15140](https://github.com/phpredis/phpredis/commit/78d15140)\n  ([R√≥bert Kelƒç√°k](https://github.com/RobiNN1))\n  [e051a5db](https://github.com/phpredis/phpredis/commit/e051a5db)\n  [#2427](https://github.com/phpredis/phpredis/pull/2427)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Use newInstance in RedisClusterTest\n  [954fbab8](https://github.com/phpredis/phpredis/commit/954fbab8)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Use actions/checkout@v4\n  [f4c2ac26](https://github.com/phpredis/phpredis/commit/f4c2ac26)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Cluster nodes from ENV\n  [eda39958](https://github.com/phpredis/phpredis/commit/eda39958)\n  [0672703b](https://github.com/phpredis/phpredis/commit/0672703b)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Ensure we're talking to redis-server in our high ports test.\n  [7825efbc](https://github.com/phpredis/phpredis/commit/7825efbc)\n  ([michael-grunder](https://github.com/michael-grunder))\n- Add missing option to installation example\n  [2bddd84f](https://github.com/phpredis/phpredis/commit/2bddd84f)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n  [#2378](https://github.com/phpredis/phpredis/pull/2378)\n- Fix typo in link\n  [8f6bc98f](https://github.com/phpredis/phpredis/commit/8f6bc98f)\n  ([Timo Sand](https://github.com/deiga))\n- Update tests to allow users to use a custom class.\n  [5f6ce414](https://github.com/phpredis/phpredis/commit/5f6ce414)\n  ([michael-grunder](https://github.com/michael-grunder))\n\n\n## [6.0.2] - 2023-10-22 ([GitHub](https://github.com/phpredis/phpredis/releases/6.0.2), [PECL](https://pecl.php.net/package/redis/6.0.2))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [Open LMS](https://openlms.net/)\n- [BlueHost](https://bluehost.com)\n- [Object Cache Pro for WordPress](https://objectcache.pro/)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n- [Zaher Ghaibeh](https://github.com/zaherg)\n- [BatchLabs](https://batch.com)\n- [Stackhero](https://github.com/stackhero-io)\n- [Florian Levis](https://github.com/Gounlaf)\n- [Luis Z√°rate](https://github.com/jlzaratec)\n\n### Fixed\n- Fix deprecation error when passing null to match_type parameter.\n  [b835aaa3](https://github.com/phpredis/phpredis/commit/b835aaa3)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix flaky test and OBJECT in a pipeline.\n  [a7f51f70](https://github.com/phpredis/phpredis/commit/a7f51f70)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Find our callback by pattern with PSUBSCRIBE\n  [2f276dcd](https://github.com/phpredis/phpredis/commit/2f276dcd)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n## [6.0.1] - 2023-09-23 ([GitHub](https://github.com/phpredis/phpredis/releases/6.0.1), [PECL](https://pecl.php.net/package/redis/6.0.1))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [Open LMS](https://openlms.net/)\n- [BlueHost](https://bluehost.com)\n- [Object Cache Pro for WordPress](https://objectcache.pro/)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n- [Zaher Ghaibeh](https://github.com/zaherg)\n- [BatchLabs](https://batch.com)\n- [Stackhero](https://github.com/stackhero-io)\n- [Florian Levis](https://github.com/Gounlaf)\n- [Luis Z√°rate](https://github.com/jlzaratec)\n\n### Fixed\n- Fix memory leak and segfault in Redis::exec\n  [362e1141](https://github.com/phpredis/phpredis/commit/362e1141)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko)),\n  ([Markus Podar](https://github.com/mfn))\n- Fix unknown expiration modifier\n  [264c0c7e](https://github.com/phpredis/phpredis/commit/264c0c7e),\n  [95bd184b](https://github.com/phpredis/phpredis/commit/95bd184b)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Added\n- Add missing option to exampleA\n  [3674d663](https://github.com/phpredis/phpredis/commit/3674d663)\n  ([Till Kr√ºss](https://github.com/tillkruss))\n- Update sentinel documentation\n  [849bedb6](https://github.com/phpredis/phpredis/commit/849bedb6),\n  [1ad95b63](https://github.com/phpredis/phpredis/commit/1ad95b63)\n  ([Joost OrangeJuiced](https://github.com/OrangeJuiced))\n\n## [6.0.0] - 2023-09-09 ([GitHub](https://github.com/phpredis/phpredis/releases/6.0.0), [PECL](https://pecl.php.net/package/redis/6.0.0))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [Open LMS](https://openlms.net/)\n- [BlueHost](https://bluehost.com)\n- [Object Cache Pro for WordPress](https://objectcache.pro/)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n- [Zaher Ghaibeh](https://github.com/zaherg)\n- [BatchLabs](https://batch.com)\n- [Stackhero](https://github.com/stackhero-io)\n- [Florian Levis](https://github.com/Gounlaf)\n- [Luis Z√°rate](https://github.com/jlzaratec)\n\n*There were no changes between 6.0.0 and 6.0.0RC2*\n\n## [6.0.0RC2] - 2023-08-20 ([GitHub](https://github.com/phpredis/phpredis/releases/6.0.0RC2), [PECL](https://pecl.php.net/package/redis/6.0.0RC2))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [Open LMS](https://openlms.net/)\n- [BlueHost](https://bluehost.com)\n- [Object Cache Pro for WordPress](https://objectcache.pro/)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n- [Zaher Ghaibeh](https://github.com/zaherg)\n- [BatchLabs](https://batch.com)\n- [Stackhero](https://github.com/stackhero-io)\n- [Florian Levis](https://github.com/Gounlaf)\n- [Luis Z√°rate](https://github.com/jlzaratec)\n\n### Fixed\n\n- Fix arginfo for arguments that default to null\n  [8d99b7d1](https://github.com/phpredis/phpredis/commit/8d99b7d1)\n  ([Nicolas Grekas](https://github.com/nicolas-grekas))\n- Fix C99 usages\n  [54d9ca45](https://github.com/phpredis/phpredis/commit/54d9ca45)\n  ([Remi Collet](https://github.com/remicollet))\n- Raise minimal supported version to 7.2\n  [e10b9a85](https://github.com/phpredis/phpredis/commit/e10b9a85)\n  ([Remi Collet](https://github.com/remicollet))\n\n## [6.0.0RC1] - 2023-08-01 ([GitHub](https://github.com/phpredis/phpredis/releases/6.0.0RC1), [PECL](https://pecl.php.net/package/redis/6.0.0RC1))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [Open LMS](https://openlms.net/)\n- [BlueHost](https://bluehost.com)\n- [Object Cache Pro for WordPress](https://objectcache.pro/)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n- [Zaher Ghaibeh](https://github.com/zaherg)\n- [BatchLabs](https://batch.com)\n- [Stackhero](https://github.com/stackhero-io)\n- [Florian Levis](https://github.com/Gounlaf)\n- [Luis Z√°rate](https://github.com/jlzaratec)\n\n### Fixed\n\n- Fix restoring keys when using compression\n  [82e08723](https://github.com/phpredis/phpredis/commit/82e08723)\n  ([Till Kr√ºss](https://github.com/tillkruss))\n- Fix missing auth in RedisSentinel stub\n  [5db85561](https://github.com/phpredis/phpredis/commit/5db85561)\n  ([Lu Fei](https://github.com/sy-records))\n- Fix RedisSentinel pconnect check\n  [42cbd88a](https://github.com/phpredis/phpredis/commit/42cbd88a)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix NULL-pointer dereferences and handle possible UB\n  [36457555](https://github.com/phpredis/phpredis/commit/36457555)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix security alerts\n  [ee210f86](https://github.com/phpredis/phpredis/commit/ee210f86),\n  [fb6a297c](https://github.com/phpredis/phpredis/commit/fb6a297c)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko)),\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Fix segfault\n  [55bf0202](https://github.com/phpredis/phpredis/commit/55bf0202)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix default host length\n  [c40f9d6c](https://github.com/phpredis/phpredis/commit/c40f9d6c)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix redis session standalone stream ssl context\n  [ed10f365](https://github.com/phpredis/phpredis/commit/ed10f365),\n  [d1bc6727](https://github.com/phpredis/phpredis/commit/d1bc6727),\n  [2ff11df5](https://github.com/phpredis/phpredis/commit/2ff11df5)\n  ([patricio.dorantes](https://github.com/patricio.dorantes))\n- Fix segfault with session+tls\n  [a471c87a](https://github.com/phpredis/phpredis/commit/a471c87a)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix non standards conforming prototypes.\n  [b3ce0486](https://github.com/phpredis/phpredis/commit/b3ce0486)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Avoid registering the same replicas multiple times\n  [f2bfd723](https://github.com/phpredis/phpredis/commit/f2bfd723)\n  ([Marius Adam](https://github.com/mariusadam))\n- Better unix:// or file:// detection.\n  [d05d301b](https://github.com/phpredis/phpredis/commit/d05d301b)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Future proof our igbinary header check\n  [69355faa](https://github.com/phpredis/phpredis/commit/69355faa)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Fix BITOP cross-slot bug\n  [af13f951](https://github.com/phpredis/phpredis/commit/af13f951)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- SENTINEL RESET returns a long.\n  [0243dd9d](https://github.com/phpredis/phpredis/commit/0243dd9d)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Fix redis_sock_read_multibulk_multi_reply_loop logic\n  [d9cb5946](https://github.com/phpredis/phpredis/commit/d9cb5946),\n  [5a643b62](https://github.com/phpredis/phpredis/commit/5a643b62)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix RPOP to unserialize/decompress data.\n  [02c91d59](https://github.com/phpredis/phpredis/commit/02c91d59)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Fix testObject for redis 7.2\n  [fea19b52](https://github.com/phpredis/phpredis/commit/fea19b52),\n  [dcb95a3f](https://github.com/phpredis/phpredis/commit/dcb95a3f)\n  ([Remi Collet](https://github.com/remicollet))\n- Fix bug: the pipeline mode socket return an unexpected result after reconnecting\n  [a3327d9d](https://github.com/phpredis/phpredis/commit/a3327d9d)\n  ([thomaston](https://github.com/omigafu))\n- Fix stub files\n  [9aa5f387](https://github.com/phpredis/phpredis/commit/9aa5f387),\n  [74cf49f5](https://github.com/phpredis/phpredis/commit/74cf49f5),\n  [8b1eafe8](https://github.com/phpredis/phpredis/commit/8b1eafe8),\n  [e392dd88](https://github.com/phpredis/phpredis/commit/e392dd88),\n  [b5ea5fd7](https://github.com/phpredis/phpredis/commit/b5ea5fd7),\n  [71758b09](https://github.com/phpredis/phpredis/commit/71758b09),\n  [2a6dee5d](https://github.com/phpredis/phpredis/commit/2a6dee5d)\n  ([Nicolas Grekas](https://github.com/nicolas-grekas)),\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Update documentation\n  [b64d93e1](https://github.com/phpredis/phpredis/commit/b64d93e1),\n  [703d71b5](https://github.com/phpredis/phpredis/commit/703d71b5),\n  [eba1c6d2](https://github.com/phpredis/phpredis/commit/eba1c6d2),\n  [0f502c9e](https://github.com/phpredis/phpredis/commit/0f502c9e),\n  [130b5d0b](https://github.com/phpredis/phpredis/commit/130b5d0b),\n  [21c3ef94](https://github.com/phpredis/phpredis/commit/21c3ef94),\n  [b7bf22d4](https://github.com/phpredis/phpredis/commit/b7bf22d4),\n  [50151e7a](https://github.com/phpredis/phpredis/commit/50151e7a),\n  [b9950727](https://github.com/phpredis/phpredis/commit/b9950727),\n  [ab4ce4ab](https://github.com/phpredis/phpredis/commit/ab4ce4ab),\n  [8d80ca5b](https://github.com/phpredis/phpredis/commit/8d80ca5b),\n  [c4de8667](https://github.com/phpredis/phpredis/commit/c4de8667),\n  [6982941b](https://github.com/phpredis/phpredis/commit/6982941b),\n  [375d093d](https://github.com/phpredis/phpredis/commit/375d093d),\n  [43da8dd9](https://github.com/phpredis/phpredis/commit/43da8dd9),\n  [71344612](https://github.com/phpredis/phpredis/commit/71344612),\n  [b9de0b97](https://github.com/phpredis/phpredis/commit/b9de0b97),\n  [2d8a8a44](https://github.com/phpredis/phpredis/commit/2d8a8a44),\n  [a2b0c86f](https://github.com/phpredis/phpredis/commit/a2b0c86f),\n  [e0b24be1](https://github.com/phpredis/phpredis/commit/e0b24be1),\n  [e609fbe8](https://github.com/phpredis/phpredis/commit/e609fbe8),\n  [c4aef956](https://github.com/phpredis/phpredis/commit/c4aef956),\n  [df50b2ad](https://github.com/phpredis/phpredis/commit/df50b2ad),\n  [cc2383f0](https://github.com/phpredis/phpredis/commit/cc2383f0),\n  [0dd2836f](https://github.com/phpredis/phpredis/commit/0dd2836f),\n  [7d5db510](https://github.com/phpredis/phpredis/commit/7d5db510),\n  [99340889](https://github.com/phpredis/phpredis/commit/99340889),\n  [70a55f3e](https://github.com/phpredis/phpredis/commit/70a55f3e),\n  [b04684d4](https://github.com/phpredis/phpredis/commit/b04684d4),\n  [980ea6b1](https://github.com/phpredis/phpredis/commit/980ea6b1),\n  [bb06ffa3](https://github.com/phpredis/phpredis/commit/bb06ffa3),\n  [b8679d7a](https://github.com/phpredis/phpredis/commit/b8679d7a),\n  [854f3aa4](https://github.com/phpredis/phpredis/commit/854f3aa4),\n  [a5c47901](https://github.com/phpredis/phpredis/commit/a5c47901),\n  [cf63e96e](https://github.com/phpredis/phpredis/commit/cf63e96e),\n  [f05ba819](https://github.com/phpredis/phpredis/commit/f05ba819),\n  [17db2328](https://github.com/phpredis/phpredis/commit/17db2328),\n  [450904f7](https://github.com/phpredis/phpredis/commit/450904f7),\n  [114f4d60](https://github.com/phpredis/phpredis/commit/114f4d60),\n  [142bddf0](https://github.com/phpredis/phpredis/commit/142bddf0),\n  [87fa36d6](https://github.com/phpredis/phpredis/commit/87fa36d6),\n  [531177d4](https://github.com/phpredis/phpredis/commit/531177d4),\n  [ecf65144](https://github.com/phpredis/phpredis/commit/ecf65144),\n  [53d142d9](https://github.com/phpredis/phpredis/commit/53d142d9),\n  [c14a9e3a](https://github.com/phpredis/phpredis/commit/c14a9e3a),\n  [72f8eb25](https://github.com/phpredis/phpredis/commit/72f8eb25),\n  [872b6931](https://github.com/phpredis/phpredis/commit/872b6931)\n  ([Karina Kwiatek](https://github.com/raccube)),\n  ([Nicolas Grekas](https://github.com/nicolas-grekas)),\n  ([Muhammad Dyas Yaskur](https://github.com/dyaskur)),\n  ([sergkash7](https://github.com/sergkash7)),\n  ([Dawid Polak](https://github.com/DeyV)),\n  ([Michael Grunder](https://github.com/michael-grunder)),\n  ([Yurun](https://github.com/Yurunsoft)),\n  ([twosee](https://github.com/twose)),\n  ([Juha](https://github.com/ejuhjav)),\n  ([Till Kr√ºss](https://github.com/tillkruss))\n\n### Changed\n\n- Allow to pass null as iterator\n  [14d121bb](https://github.com/phpredis/phpredis/commit/14d121bb)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add NOMKSTREAM option to XADD command.\n  [f9436e25](https://github.com/phpredis/phpredis/commit/f9436e25)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Don't allow reconnect on read response\n  [5a269ab6](https://github.com/phpredis/phpredis/commit/5a269ab6)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Reset multi/pipline transaction on pconnect close\n  [0879770a](https://github.com/phpredis/phpredis/commit/0879770a)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Use read_mbulk_header helper where possible\n  [ca8b4c93](https://github.com/phpredis/phpredis/commit/ca8b4c93)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Allow to pass null as auth argument\n  [41517753](https://github.com/phpredis/phpredis/commit/41517753)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Refactor redis_parse_client_list_response\n  [68136a29](https://github.com/phpredis/phpredis/commit/68136a29),\n  [aaa4c91a](https://github.com/phpredis/phpredis/commit/aaa4c91a),\n  [1fb2935b](https://github.com/phpredis/phpredis/commit/1fb2935b),\n  [cf2c052c](https://github.com/phpredis/phpredis/commit/cf2c052c)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Refactor subscribe/unsubscribe\n  [3c9e159c](https://github.com/phpredis/phpredis/commit/3c9e159c)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Change PHPREDIS_CTX_PTR type\n  [de3635da](https://github.com/phpredis/phpredis/commit/de3635da)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Refactor redis_parse_info_response\n  [982bd13b](https://github.com/phpredis/phpredis/commit/982bd13b)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Allow IPv6 address within square brackets\n  [c28ad7bb](https://github.com/phpredis/phpredis/commit/c28ad7bb)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Allow multiple field-value pairs for hmset command.\n  [e858e8e3](https://github.com/phpredis/phpredis/commit/e858e8e3)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Refactor MINIT and use @generate-class-entries in stub files\n  [3675f442](https://github.com/phpredis/phpredis/commit/3675f442)\n  ([Remi Collet](https://github.com/remicollet))\n- Use spl_ce_RuntimeException\n  [3cd5ac1e](https://github.com/phpredis/phpredis/commit/3cd5ac1e),\n  [a7e5ea64](https://github.com/phpredis/phpredis/commit/a7e5ea64)\n  ([Remi Collet](https://github.com/remicollet))\n- Regenerate arginfo using 8.2.0\n  [a38e08da](https://github.com/phpredis/phpredis/commit/a38e08da)\n  ([Remi Collet](https://github.com/remicollet))\n- Refactor client command\n  [a8d10291](https://github.com/phpredis/phpredis/commit/a8d10291)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Pull COUNT/ANY parsing into a helper function\n  [d67b2020](https://github.com/phpredis/phpredis/commit/d67b2020)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Return false or NULL on empty lpos response\n  [39a01ac7](https://github.com/phpredis/phpredis/commit/39a01ac7)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- BLPOP with a float timeout\n  [a98605f2](https://github.com/phpredis/phpredis/commit/a98605f2),\n  [dc9af529](https://github.com/phpredis/phpredis/commit/dc9af529)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Make sure we set an error for key based scans\n  [98fda1b8](https://github.com/phpredis/phpredis/commit/98fda1b8)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Add back a default switch case for setoption handler\n  [87464932](https://github.com/phpredis/phpredis/commit/87464932)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Update stubs so the tests pass in strict mode\n  [bebd398c](https://github.com/phpredis/phpredis/commit/bebd398c)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Move where we generate our salt\n  [d2044c9f](https://github.com/phpredis/phpredis/commit/d2044c9f)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor XINFO handler\n  [3b0d8b77](https://github.com/phpredis/phpredis/commit/3b0d8b77)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor and fix XPENDING handler\n  [457953f4](https://github.com/phpredis/phpredis/commit/457953f4)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor FLUSHDB and update docs.\n  [54a084e5](https://github.com/phpredis/phpredis/commit/54a084e5)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Add missing directed node command to docs and refactor stubs.\n  [5ac92d25](https://github.com/phpredis/phpredis/commit/5ac92d25)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor BITPOS and implement BIT/BYTE option.\n  [4d8afd38](https://github.com/phpredis/phpredis/commit/4d8afd38)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- INFO with multiple sections\n  [44d03ca0](https://github.com/phpredis/phpredis/commit/44d03ca0)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor SLOWLOG command\n  [d87f1428](https://github.com/phpredis/phpredis/commit/d87f1428)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor SORT and add SORT_RO command\n  [8c7c5a3a](https://github.com/phpredis/phpredis/commit/8c7c5a3a)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Use ZEND_STRL in redis_commands.c\n  [78de25a3](https://github.com/phpredis/phpredis/commit/78de25a3)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Refactor PubSub command\n  [2a0d1c1e](https://github.com/phpredis/phpredis/commit/2a0d1c1e)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Refactor SLAVEOF handler\n  [f2cef8be](https://github.com/phpredis/phpredis/commit/f2cef8be)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor ACL command\n  [504810a5](https://github.com/phpredis/phpredis/commit/504810a5)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Use fast_zpp API\n  [376d4d27](https://github.com/phpredis/phpredis/commit/376d4d27)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix XAUTOCLAIM response handler\n  [0b7bd83f](https://github.com/phpredis/phpredis/commit/0b7bd83f)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor `command` command\n  [ff863f3f](https://github.com/phpredis/phpredis/commit/ff863f3f)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Refactor rawCommand and WAIT\n  [79c9d224](https://github.com/phpredis/phpredis/commit/79c9d224)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor SELECT command\n  [86f15cca](https://github.com/phpredis/phpredis/commit/86f15cca)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor SRANDMEMBER command.\n  [f62363c2](https://github.com/phpredis/phpredis/commit/f62363c2)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor OBJECT command.\n  [acb5db76](https://github.com/phpredis/phpredis/commit/acb5db76)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor gen_varkey_cmd\n  [3efa59cb](https://github.com/phpredis/phpredis/commit/3efa59cb)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor MGET command.\n  [8cb6dd17](https://github.com/phpredis/phpredis/commit/8cb6dd17)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor INFO and SCRIPT commands.\n  [3574ef08](https://github.com/phpredis/phpredis/commit/3574ef08)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor MSET and MSETNX commands.\n  [6d104481](https://github.com/phpredis/phpredis/commit/6d104481)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor HMSET command.\n  [90eb0470](https://github.com/phpredis/phpredis/commit/90eb0470)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor PFCOUNT command.\n  [19fd7e0c](https://github.com/phpredis/phpredis/commit/19fd7e0c)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor SMOVE command.\n  [204a02c5](https://github.com/phpredis/phpredis/commit/204a02c5)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Rework ZRANGE argument handling.\n  [aa0938a4](https://github.com/phpredis/phpredis/commit/aa0938a4)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor a couple more command methods.\n  [5b560ccf](https://github.com/phpredis/phpredis/commit/5b560ccf),\n  [c8224b93](https://github.com/phpredis/phpredis/commit/c8224b93),\n  [40e1b1bf](https://github.com/phpredis/phpredis/commit/40e1b1bf),\n  [ccd419a4](https://github.com/phpredis/phpredis/commit/ccd419a4)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor HMGET command\n  [bb66a547](https://github.com/phpredis/phpredis/commit/bb66a547)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor CLIENT command\n  [77c4f7a3](https://github.com/phpredis/phpredis/commit/77c4f7a3)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Refactor redis_long_response\n  [f14a80db](https://github.com/phpredis/phpredis/commit/f14a80db)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Synchronize Redis and RedisSentinel constructors\n  [ebb2386e](https://github.com/phpredis/phpredis/commit/ebb2386e)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Use redis_sock_connect on connect\n  [f6c8b9c6](https://github.com/phpredis/phpredis/commit/f6c8b9c6)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Auto-select db in redis_sock_server_open\n  [6930a81c](https://github.com/phpredis/phpredis/commit/6930a81c)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Use on-stack allocated valiables\n  [7a055cad](https://github.com/phpredis/phpredis/commit/7a055cad)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Added\n\n- Add XAUTOCLAIM command\n  [01f3342c](https://github.com/phpredis/phpredis/commit/01f3342c)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add SYNC arg to FLUSHALL and FLUSHDB, and ASYNC/SYNC arg to SCRIPT FLUSH\n  [750b6cf3](https://github.com/phpredis/phpredis/commit/750b6cf3)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add reset command\n  [947a2d38](https://github.com/phpredis/phpredis/commit/947a2d38)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add hRandField command\n  [fe397371](https://github.com/phpredis/phpredis/commit/fe397371)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add PXAT/EXAT arguments to SET command.\n  [0a160685](https://github.com/phpredis/phpredis/commit/0a160685)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add GETEX, GETDEL commands.\n  [11861d95](https://github.com/phpredis/phpredis/commit/11861d95)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add FAILOVER command.\n  [4b767be7](https://github.com/phpredis/phpredis/commit/4b767be7)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Backoff settings in constructor\n  [e6b3fe54](https://github.com/phpredis/phpredis/commit/e6b3fe54)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add the COUNT argument to LPOP and RPOP\n  [df97cc35](https://github.com/phpredis/phpredis/commit/df97cc35)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Unsubscribe from all channels\n  [0f1ca0cc](https://github.com/phpredis/phpredis/commit/0f1ca0cc)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add lPos command.\n  [687a5c78](https://github.com/phpredis/phpredis/commit/687a5c78)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add the ANY argument to GEOSEARCH and GEORADIUS\n  [bf6f31e3](https://github.com/phpredis/phpredis/commit/bf6f31e3)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add 'BIT'/'BYTE' modifier to BITCOUNT + tests\n  [a3d2f131](https://github.com/phpredis/phpredis/commit/a3d2f131)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Add missing configureoption entries in package.xml\n  [59053f10](https://github.com/phpredis/phpredis/commit/59053f10)\n  ([Michele Locati](https://github.com/mlocati))\n- Implement CONFIG RESETSTAT\n  [239678a0](https://github.com/phpredis/phpredis/commit/239678a0)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- SINTERCARD and ZINTERCARD commands\n  [64300508](https://github.com/phpredis/phpredis/commit/64300508)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- LCS command\n  [c0e839f6](https://github.com/phpredis/phpredis/commit/c0e839f6)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- EXPIRETIME and PEXPIRETIME\n  [f5b2a09b](https://github.com/phpredis/phpredis/commit/f5b2a09b)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- [B]LMPOP and [B]ZMPOP commands\n  [6ea978eb](https://github.com/phpredis/phpredis/commit/6ea978eb)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Implement new RESTORE options\n  [9a3fe401](https://github.com/phpredis/phpredis/commit/9a3fe401)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Add new Redis 6.2.0 XTRIM options\n  [6b34d17f](https://github.com/phpredis/phpredis/commit/6b34d17f)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Implement AUTH/AUTH2 arguments for MIGRATE\n  [114d79d1](https://github.com/phpredis/phpredis/commit/114d79d1)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Implement CONFIG REWRITE\n  [525958ea](https://github.com/phpredis/phpredis/commit/525958ea)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Implement Redis 7.0.0 [P]EXPIRE[AT] options\n  [872ae107](https://github.com/phpredis/phpredis/commit/872ae107)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Variadic CONFIG GET/SET\n  [36ef4bd8](https://github.com/phpredis/phpredis/commit/36ef4bd8),\n  [a176f586](https://github.com/phpredis/phpredis/commit/a176f586)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- EVAL_RO and EVALSHA_RO\n  [f3a40830](https://github.com/phpredis/phpredis/commit/f3a40830)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Implement ZRANGESTORE and add ZRANGE options\n  [71bcbcb9](https://github.com/phpredis/phpredis/commit/71bcbcb9)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- XGROUP DELCONSUMER and ENTRIESREAD\n  [1343f500](https://github.com/phpredis/phpredis/commit/1343f500)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Expose the transferred number of bytes\n  [e0a88b7b](https://github.com/phpredis/phpredis/commit/e0a88b7b),\n  [90828019](https://github.com/phpredis/phpredis/commit/90828019),\n  [7a4cee2d](https://github.com/phpredis/phpredis/commit/7a4cee2d)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko)),\n  ([Michael Grunder](https://github.com/michael-grunder))\n- TOUCH command\n  [dc1f2398](https://github.com/phpredis/phpredis/commit/dc1f2398)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Redis Sentinel TLS support\n  [f2bb2cdb](https://github.com/phpredis/phpredis/commit/f2bb2cdb)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add the CH, NX, XX arguments to GEOADD\n  [2bb64038](https://github.com/phpredis/phpredis/commit/2bb64038),\n  [e8f5b517](https://github.com/phpredis/phpredis/commit/e8f5b517)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Implement SMISMEMBER for RedisCluster\n  [abfac47b](https://github.com/phpredis/phpredis/commit/abfac47b)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Implement ssubscribe/sunsubscribe\n  [7644736e](https://github.com/phpredis/phpredis/commit/7644736e)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Implement BLMOVE and add LMOVE/BLMOVE to cluster.\n  [121e9d9c](https://github.com/phpredis/phpredis/commit/121e9d9c)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Implement LPOS for RedisCluster\n  [7121aaae](https://github.com/phpredis/phpredis/commit/7121aaae)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Implement GEOSEARCH and GEOSEARCHSTORE for RedisCluster.\n  [fa5d1af9](https://github.com/phpredis/phpredis/commit/fa5d1af9)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Implement HRANDFIELD for RedisCluster\n  [e222b85e](https://github.com/phpredis/phpredis/commit/e222b85e)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Implement COPY for RedisCluster\n  [40a2c254](https://github.com/phpredis/phpredis/commit/40a2c254)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Implement new ZSET commands for cluster\n  [27900f39](https://github.com/phpredis/phpredis/commit/27900f39)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Add cluster support for strict sessions and lazy write\n  [b6cf6361](https://github.com/phpredis/phpredis/commit/b6cf6361)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Add function command\n  [90a0e9cc](https://github.com/phpredis/phpredis/commit/90a0e9cc)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add FCALL/FCALL_RO commands\n  [7c46ad2c](https://github.com/phpredis/phpredis/commit/7c46ad2c)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Removed\n\n- Remove unused macros\n  [831d6118](https://github.com/phpredis/phpredis/commit/831d6118)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n## [5.3.7] - 2021-02-15 ([GitHub](https://github.com/phpredis/phpredis/releases/5.3.7), [PECL](https://pecl.php.net/package/redis/5.3.7))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [Open LMS](https://openlms.net/)\n- [BlueHost](https://bluehost.com)\n- [Object Cache Pro for WordPress](https://objectcache.pro/)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n- [Zaher Ghaibeh](https://github.com/zaherg)\n- [BatchLabs](https://batch.com)\n- [Stackhero](https://github.com/stackhero-io)\n- [Florian Levis](https://github.com/Gounlaf)\n- [Luis Z√°rate](https://github.com/jlzaratec)\n\n*There were no changes between 5.3.7 and 5.3.7RC2*\n\n## [5.3.7RC2] - 2021-02-12 ([GitHub](https://github.com/phpredis/phpredis/releases/5.3.7RC2), [PECL](https://pecl.php.net/package/redis/5.3.7RC2))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [Open LMS](https://openlms.net/)\n- [BlueHost](https://bluehost.com)\n- [Object Cache Pro for WordPress](https://objectcache.pro/)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n- [Zaher Ghaibeh](https://github.com/zaherg)\n- [BatchLabs](https://batch.com)\n- [Stackhero](https://github.com/stackhero-io)\n- [Florian Levis](https://github.com/Gounlaf)\n- [Luis Z√°rate](https://github.com/jlzaratec)\n\n*There were no changes between 5.3.7RC2 and 5.3.7RC1*\n\n## [5.3.7RC1] - 2021-02-02 ([GitHub](https://github.com/phpredis/phpredis/releases/5.3.7RC1), [PECL](https://pecl.php.net/package/redis/5.3.7RC1))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [Open LMS](https://openlms.net/)\n- [BlueHost](https://bluehost.com)\n- [Object Cache Pro for WordPress](https://objectcache.pro/)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n- [Zaher Ghaibeh](https://github.com/zaherg)\n- [BatchLabs](https://batch.com)\n- [Stackhero](https://github.com/stackhero-io)\n- [Florian Levis](https://github.com/Gounlaf)\n- [Luis Z√°rate](https://github.com/jlzaratec)\n\n### Fixed\n\n- Fix RedisArray::[hsz]scan and tests\n  [08a9d5db](https://github.com/phpredis/phpredis/commit/08a9d5db),\n  [0264de18](https://github.com/phpredis/phpredis/commit/0264de18),\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko)),\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Fix RedisArray::scan\n  [8689ab1c](https://github.com/phpredis/phpredis/commit/8689ab1c)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix LZF decompression logic\n  [0719c1ec](https://github.com/phpredis/phpredis/commit/0719c1ec)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n## [5.3.6] - 2021-01-17 ([GitHub](https://github.com/phpredis/phpredis/releases/5.3.6), [PECL](https://pecl.php.net/package/redis/5.3.6))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [Open LMS](https://openlms.net/)\n- [BlueHost](https://bluehost.com)\n- [Object Cache Pro for WordPress](https://objectcache.pro/)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n- [Zaher Ghaibeh](https://github.com/zaherg)\n- [BatchLabs](https://batch.com)\n- [Stackhero](https://github.com/stackhero-io)\n- [Florian Levis](https://github.com/Gounlaf)\n- [Luis Z√°rate](https://github.com/jlzaratec)\n\n### Fixed\n\n- Fix a segfault in RedisArray::del\n  [d2f2a7d9](https://github.com/phpredis/phpredis/commit/d2f2a7d9)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n## [5.3.5] - 2021-12-18 ([GitHub](https://github.com/phpredis/phpredis/releases/5.3.5), [PECL](https://pecl.php.net/package/redis/5.3.5))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [Open LMS](https://openlms.net/)\n- [BlueHost](https://bluehost.com)\n- [Object Cache Pro for WordPress](https://objectcache.pro/)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n- [Zaher Ghaibeh](https://github.com/zaherg)\n- [BatchLabs](https://batch.com)\n- [Stackhero](https://github.com/stackhero-io)\n- [Florian Levis](https://github.com/Gounlaf)\n- [Luis Z√°rate](https://github.com/jlzaratec)\n\n### Fixed\n\n- Fixed typo in cluster_scan_resp\n  [44affad2](https://github.com/phpredis/phpredis/commit/44affad2)\n\n## [5.3.5RC1] - 2021-11-16 ([GitHub](https://github.com/phpredis/phpredis/releases/5.3.5RC1), [PECL](https://pecl.php.net/package/redis/5.3.5RC1))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [Open LMS](https://openlms.net/)\n- [BlueHost](https://bluehost.com)\n- [Object Cache Pro for WordPress](https://objectcache.pro/)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n- [Zaher Ghaibeh](https://github.com/zaherg)\n- [BatchLabs](https://batch.com)\n- [Stackhero](https://github.com/stackhero-io)\n- [Florian Levis](https://github.com/Gounlaf)\n- [Luis Z√°rate](https://github.com/jlzaratec)\n\n### Fixed\n\n- Fixed segfault in redis_setoption_handler\n  [#2030](https://github.com/phpredis/phpredis/issues/2030)\n  [692e4e84](https://github.com/phpredis/phpredis/commit/692e4e84)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix masters array in the event of a cluster failover\n  [bce692962](https://github.com/phpredis/phpredis/commit/bce692962)\n  [#2025](https://github.com/phpredis/phpredis/pull/2025)\n  ([Bar Shaul](https://github.com/barshaul))\n- Fix 32bit type error\n  [672dec87f](https://github.com/phpredis/phpredis/commit/672dec87f)\n  ([#1956](https://github.com/phpredis/phpredis/issues/1956))\n  ([Remi Collet](https://github.com/remicollet))\n- Fix radix character in certain locales\n  [#1893](https://github.com/phpredis/phpredis/issues/1893)\n  [89a871e24](https://github.com/phpredis/phpredis/commit/89a871e24)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- ZSTD Validation fix\n  [6a77ef5cd](https://github.com/phpredis/phpredis/commit/6a77ef5cd)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Remove superfluous typecast\n  [b2871471f](https://github.com/phpredis/phpredis/commit/b2871471f)\n  ([Remi Collet](https://github.com/remicollet))\n- Updated documentation\n  [f84168657](https://github.com/phpredis/phpredis/commit/f84168657),\n  [d017788e7](https://github.com/phpredis/phpredis/commit/d017788e7),\n  [20ac84710](https://github.com/phpredis/phpredis/commit/20ac84710),\n  [0adf05260](https://github.com/phpredis/phpredis/commit/0adf05260),\n  [aee29bf73](https://github.com/phpredis/phpredis/commit/aee29bf73),\n  [09a095e72](https://github.com/phpredis/phpredis/commit/09a095e72),\n  [12ffbf33a](https://github.com/phpredis/phpredis/commit/12ffbf33a),\n  [ff331af98](https://github.com/phpredis/phpredis/commit/ff331af98),\n  [a6bdb8731](https://github.com/phpredis/phpredis/commit/a6bdb8731),\n  [305c15840](https://github.com/phpredis/phpredis/commit/305c15840),\n  [1aa10e93a](https://github.com/phpredis/phpredis/commit/1aa10e93a),\n  [d78b0c79d](https://github.com/phpredis/phpredis/commit/d78b0c79d),\n  [c6d37c27c](https://github.com/phpredis/phpredis/commit/c6d37c27c),\n  [a6303f5b9](https://github.com/phpredis/phpredis/commit/a6303f5b9),\n  [d144bd2c7](https://github.com/phpredis/phpredis/commit/d144bd2c7),\n  [a6fb815ef](https://github.com/phpredis/phpredis/commit/a6fb815ef),\n  [9ef862bc6](https://github.com/phpredis/phpredis/commit/9ef862bc6)\n  ([neodisco](https://github.com/neodisco), [Billy Wilson](https://github.com/wilsonwr),\n  [Cl√©ment Tessier](https://github.com/ctessier), [wangqr](https://github.com/wangqr),\n  [T. Todua](https://github.com/ttodua), [Naphat Deepar](https://github.com/feverxai),\n  [dengliming](https://github.com/dengliming), [Poplary](https://github.com/poplary),\n  [Maxime Cornet](https://github.com/xElysioN), [Michael Grunder](https://github.com/michael-grunder),\n  [Emanuele Filannino](https://github.com/tatekan), [MiRacLe](https://github.com/MiRacLe-RPZ),\n  [Michael Grunder](https://github.com/michael-grunder))\n- Travis CI Fixes\n  [a43f4586e](https://github.com/phpredis/phpredis/commit/a43f4586e),\n  [4fde8178f](https://github.com/phpredis/phpredis/commit/4fde8178f),\n  [7bd5415ac](https://github.com/phpredis/phpredis/commit/7bd5415ac),\n  [fdb8c4bb7](https://github.com/phpredis/phpredis/commit/fdb8c4bb7),\n  [d4f407470](https://github.com/phpredis/phpredis/commit/d4f407470)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Minor fixes/cleanup\n  [2e190adc1](https://github.com/phpredis/phpredis/commit/2e190adc1),\n  [99975b592](https://github.com/phpredis/phpredis/commit/99975b592),\n  [9d0879fa5](https://github.com/phpredis/phpredis/commit/9d0879fa5),\n  [22b06457b](https://github.com/phpredis/phpredis/commit/22b06457b),\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix RedisArray constructor bug\n  [85dc883ba](https://github.com/phpredis/phpredis/commit/85dc883ba)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Changed\n\n- Moved to GitHub Actions\n  [4d2afa786](https://github.com/phpredis/phpredis/commit/4d2afa786),\n  [502d09fd5](https://github.com/phpredis/phpredis/commit/502d09fd5)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Use more appropriate array iteration macro\n  [6008900c2](https://github.com/phpredis/phpredis/commit/6008900c2)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Clean up session tests\n  [ab25ae7f3](https://github.com/phpredis/phpredis/commit/ab25ae7f3)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- RedisArray refactors\n  [1250f0001](https://github.com/phpredis/phpredis/commit/1250f0001),\n  [017b2ea7f](https://github.com/phpredis/phpredis/commit/017b2ea7f),\n  [37ed3f079](https://github.com/phpredis/phpredis/commit/37ed3f079)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Use zend_parse_parameters_none helper\n  [a26b14dbe](https://github.com/phpredis/phpredis/commit/a26b14dbe)\n  ([Remi Collet](https://github.com/remicollet))\n\n### Added\n\n- Support for various exponential backoff strategies\n  [#1986](https://github.com/phpredis/phpredis/commit/#1986),\n  [#1993](https://github.com/phpredis/phpredis/commit/#1993),\n  [732eb8dcb](https://github.com/phpredis/phpredis/commit/732eb8dcb)\n  [05129c3a3](https://github.com/phpredis/phpredis/commit/05129c3a3)\n  [5bba6a7fc](https://github.com/phpredis/phpredis/commit/5bba6a7fc)\n  ([Nathaniel Braun](https://github.com/nbraun-amazon))\n- Added experimental support for detecting a dirty connection by\n  trying to determine if the underlying stream is readable.\n  [d68579562](https://github.com/phpredis/phpredis/commit/d68579562)\n  [#2013](https://github.com/phpredis/phpredis/issues/2013)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Created distinct compression utility methods (pack/unpack)\n  [#1939](https://github.com/phpredis/phpredis/issues/1939)\n  [da2790aec](https://github.com/phpredis/phpredis/commit/da2790aec)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- SMISMEMBER Command\n  [#1894](https://github.com/phpredis/phpredis/commit/#1894)\n  [ae2382472](https://github.com/phpredis/phpredis/commit/ae2382472),\n  [ed283e1ab](https://github.com/phpredis/phpredis/commit/ed283e1ab),\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n## [5.3.4] - 2021-03-24 ([GitHub](https://github.com/phpredis/phpredis/releases/5.3.4), [PECL](https://pecl.php.net/package/redis/5.3.4))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [Open LMS](https://openlms.net/)\n- [BlueHost](https://bluehost.com)\n- [Object Cache Pro for WordPress](https://objectcache.pro/)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n- [Zaher Ghaibeh](https://github.com/zaherg)\n- [BatchLabs](https://batch.com)\n\n### Fixed\n\n- Fix multi/pipeline segfault on Apple silicon [#1917](https://github.com/phpredis/phpredis/issues/1917)\n  [e0796d48](https://github.com/phpredis/phpredis/commit/e0796d48af18adac2b93982474e7df8de79ec854)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Pass compression flag on HMGET in RedisCluster [#1945](https://github.com/phpredis/phpredis/issues/1945)\n  [edc724e6](https://github.com/phpredis/phpredis/commit/edc724e6022620414abf4f90256522d03c3160fd)\n  ([Adam Olley](https://github.com/aolley))\n- Abide by ZSTD error return constants [#1936](https://github.com/phpredis/phpredis/issues/1936)\n  [8400ed1c](https://github.com/phpredis/phpredis/pull/1937/commits/8400ed1cb23a22f70727cb60e88ca5397ee10d23)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Fix timing related CI session tests\n  [9b986bf8](https://github.com/phpredis/phpredis/commit/9b986bf81859f5a5983cd148cb15ee6ce292d288)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n## [5.3.3] - 2021-02-01 ([GitHub](https://github.com/phpredis/phpredis/releases/5.3.3), [PECL](https://pecl.php.net/package/redis/5.3.3))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [BlueHost](https://bluehost.com)\n- [Redis Cache Pro for WordPress](https://wprediscache.com)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n- [Oleg Babushkin](https://github.com/olbabushkin)\n- [Zaher Ghaibeh](https://github.com/zaherg)\n- [BatchLabs](https://batch.com)\n\n### Fixed\n\n- Fixed Windows includes for PHP 8\n  [270b4db8](https://www.github.com/phpredis//phpredis/commit/270b4db821fcbe9fb881eef83e046f87587c4110)\n  ([Jan-E](https://github.com/Jan-E))\n- Fix hash_ops for PHP 8.0.1\n  [87297cbb](https://www.github.com/phpredis/phpredis/commit/87297cbb4000c88b07e729b9379de321ead74aa2)\n  ([defender-11](https://github.com/defender-11))\n- Disable clone for Redis and RedisCluster objects.  Presently they segfault.\n  [cd05a344](https://www.github.com/phpredis/phpredis/commit/87297cbb4000c88b07e729b9379de321ead74aa2)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n## [5.3.2] - 2020-10-22 ([GitHub](https://github.com/phpredis/phpredis/releases/5.3.2), [PECL](https://pecl.php.net/package/redis/5.3.2))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [BlueHost](https://bluehost.com)\n- [Redis Cache Pro for WordPress](https://wprediscache.com)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n- [Oleg Babushkin](https://github.com/olbabushkin)\n\n### Fixed\n\n- Verify SET options are strings before testing them as strings\n  [514bc371](https://github.com/phpredis/phpredis/commit/514bc37102c08c1ba7222212b125390f34c35803)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Fix cluster segfault when dealing with NULL multi bulk replies in RedisCluster\n  [950e8de8](https://github.com/phpredis/phpredis/commit/950e8de807ba17ecfff62504a6ee7a959a5df714)\n  ([Michael Grunder](https://github.com/michael-grunder),\n   [Alex Offshore](https://github.com/offshore))\n- Fix xReadGroup() must return message id\n  [500916a4](https://github.com/phpredis/phpredis/commit/500916a4d052aa180aa8d27a9e147e64f3ee6303)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix memory leak in rediscluster session handler\n  [b2cffffc](https://github.com/phpredis/phpredis/commit/b2cffffc107541643bab7eb81751b497bc264639)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix XInfo() returns false if the stream is empty\n  [5719c9f7](https://github.com/phpredis/phpredis/commit/5719c9f7ff8ba4595c0f2d82e9549a604d925ed7),\n  [566fdeeb](https://github.com/phpredis/phpredis/commit/566fdeeb19c8112ac83cf4e47be6928626aa7b37)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko),\n   [Michael Grunder](https://github.com/michael-grunder))\n\n### Changed\n\n- Use \"%.17g\" sprintf format for doubles as done in Redis server.\n  [32be3006](https://github.com/phpredis/phpredis/commit/32be3006e6d5a9d58636efd53fe02aa22f18c496)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Relax requirements on set's expire argument\n  [36458071](https://github.com/phpredis/phpredis/commit/364580718891de94aac13dc352aa994d531d4272)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Refactor redis_sock_check_liveness\n  [c5950644](https://github.com/phpredis/phpredis/commit/c5950644e92e61e0c3f38a8ab8a380f707102eb0)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- PHP8 compatibility\n  [a7662da7](https://github.com/phpredis/phpredis/commit/a7662da7924dcbaa74f5f2c6e1dce06b19e64bfc),\n  [f4a30cb2](https://github.com/phpredis/phpredis/commit/f4a30cb2bda7414b159bf8b1be69dad52ed6f008),\n  [17848791](https://github.com/phpredis/phpredis/commit/178487919148a0f8f1ad4cae62847bc4ae82ee8c)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko),\n   [Remi Collet](https://github.com/remicollet))\n- Update documentation\n  [c9ed151d](https://github.com/phpredis/phpredis/commit/c9ed151dbae1532a98c0c9322c9401c47d1da149),\n  [398c99d9](https://github.com/phpredis/phpredis/commit/398c99d9851b267d9aaaa42c097c5fe54d507a6e)\n  ([Ali Alwash](https://github.com/aalwash),\n   [Gregoire Pineau](https://github.com/lyrixx))\n\n### Added\n\n- Add `Redis::OPT_NULL_MULTIBULK_AS_NULL` setting to treat NULL multi bulk replies as `NULL` instead of `[]`.\n  [950e8de8](https://github.com/phpredis/phpredis/commit/950e8de807ba17ecfff62504a6ee7a959a5df714)\n  ([Michael Grunder](https://github.com/michael-grunder),\n   [Alex Offshore](https://github.com/offshore))\n- Allow to specify stream context for rediscluster session handler\n  [a8daaff8](https://github.com/phpredis/phpredis/commit/a8daaff87a055bb6b4fb8702151915f56e144649),\n  [4fbe7df7](https://github.com/phpredis/phpredis/commit/4fbe7df79b9b0e03f92e8323aed0bda9513bc20a)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add new parameter to RedisCluster to specify stream ssl/tls context.\n  [f771ea16](https://github.com/phpredis/phpredis/commit/f771ea16b77f39fcca555bec2d952412265197aa),\n  [72024afe](https://github.com/phpredis/phpredis/commit/72024afed3640230bbd1a017b2a374d12ab88e59)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add new parameter to RedisSentinel to specify auth information\n  [81c502ae](https://github.com/phpredis/phpredis/commit/81c502ae7c0de65d63cd514ee59849c9d1b0b952)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n## [5.3.1] - 2020-07-06 ([GitHub](https://github.com/phpredis/phpredis/releases/5.3.1), [PECL](https://pecl.php.net/package/redis/5.3.1))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [BlueHost](https://bluehost.com)\n- [Redis Cache Pro for WordPress](https://wprediscache.com)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n\n### Fixed\n\n- Properly clean up on session start failure\n  [066cff6a](https://github.com/phpredis/phpredis/commit/066cff6adee03ce05ec5d57083eb7995dfa4344d)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Treat NULL as a failure for redis_extract_auth_info\n  [49428a2f](https://github.com/phpredis/phpredis/commit/49428a2f7072dc30a52db4155aed3d382800b1a6),\n  [14ac969d](https://github.com/phpredis/phpredis/commit/14ac969da29dbf7203f8db31988ca26b9b45f583)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Don't dereference a NULL zend_string or try to efree it\n  [ff2e160f](https://github.com/phpredis/phpredis/commit/ff2e160f408efdc97676cffaa02093e65c2ad634),\n  [7fed06f2](https://github.com/phpredis/phpredis/commit/7fed60f248e2249e6cac5c5c3090509aa47647fb)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Fix config.m4 messages and test for and include php_hash.h\n  [83a1b7c5](https://github.com/phpredis/phpredis/commit/83a1b7c5e225abd94cd3459c52bf7d502dfb0979),\n  [3c56289c](https://github.com/phpredis/phpredis/commit/3c56289c71516a7c0ac81713ef2786c2b9e52274),\n  [08f202e7](https://github.com/phpredis/phpredis/commit/08f202e775037ccf849d7b933dddb467c9c2ee5f),\n  ([Remi Collet](https://github.com/remicollet))\n\n### Added\n\n- Add openSUSE installation instructions\n  [13a168f4](https://github.com/phpredis/phpredis/commit/13a168f42d6639a051d6f829d573dd81bcb97f3a)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Removed\n\n- Remove EOL Fedora installation instructions\n  [b4779e6a](https://github.com/phpredis/phpredis/commit/b4779e6a919103bd65fa0e6a0c88e658e05a3e7c)\n  ([Remi Collet](https://github.com/remicollet))\n\n## [5.3.0] - 2020-06-30 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/5.3.0), [PECL](https://pecl.php.net/package/redis/5.3.0))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [BlueHost](https://bluehost.com)\n- [Redis Cache Pro for WordPress](https://wprediscache.com)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n\n*There were no changes between 5.3.0RC2 and 5.3.0*\n\n## [5.3.0RC2] - 2020-06-26 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/5.3.0RC2), [PECL](https://pecl.php.net/package/redis/5.3.0RC2))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack](https://audiomack.com)\n- [BlueHost](https://bluehost.com)\n- [Redis Cache Pro for WordPress](https://wprediscache.com/)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n\n### Fixed\n\n- Fix LZ4 configuration and use pkg-config if we have it\n  [df398cb0](https://github.com/phpredis/phpredis/commit/df398cb07cd10d870c6805d5834703dc39590b0f)\n  ([Remi Collet](https://github.com/remicollet))\n\n- Make sure persistent pool ID is NULL terminated\n  [0838b5bd](https://github.com/phpredis/phpredis/commit/0838b5bde7ef25d419868c7e705bf6c70d68ea20),\n  [57bb95bf](https://github.com/phpredis/phpredis/commit/57bb95bf5a01a2adb74e2bf73bb285488e0d1586)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n### Changed\n\n- Run LZ4 tests in Travis\n  [3ba3f06d](https://github.com/phpredis/phpredis/commit/3ba3f06d51ff126eb51dd697381c0e56b38bbcf3)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n## [5.3.0RC1]\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack.com](https://audiomack.com)\n- [BlueHost](https://bluehost.com)\n- [Redis Cache Pro for WordPress](https://wprediscache.com/)\n- [Avtandil Kikabidze](https://github.com/akalongman)\n\n### Added\n\n- Support for Redis 6 ACLs\n  [a311cc4e](https://github.com/phpredis/phpredis/commit/a311cc4ec3cecdbaf83ba66985efa82137e37cc0)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n- LZ4 Compression\n  [04def9fb](https://github.com/phpredis/phpredis/commit/04def9fbe2194b3b711362de57260a6cd5216e69)\n  ([Ilia Alshanetsky](https://github.com/iliaal),\n   [Michael Grunder](https://github.com/michael-grunder))\n\n- Support for new Redis 6 arguments (XINFO FULL, SET KEEPTTL)\n  [a0c53e0b](https://github.com/phpredis/phpredis/commit/a0c53e0b30e0c6af15cc137415e7d65f6d1867f7),\n  [f9c7bb57](https://github.com/phpredis/phpredis/commit/f9c7bb5788c39614c23e3bb9ec42ec8d6d5bbaa1)\n  ([Victor Kislov](https://github.com/vityank),\n   [Michael Grunder](https://github.com/michael-grunder))\n\n- Support for TLS connections\n  [890ee0e6](https://github.com/phpredis/phpredis/commit/890ee0e656e545b18179cf247db94a33179ce1ab),\n  [b0671296](https://github.com/phpredis/phpredis/commit/b067129678264fc1c5c0f611ce1b192e05c14669)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n- New option Redis::SCAN_PREFIX, Redis::SCAN_NOPREFIX\n  [e80600e2](https://github.com/phpredis/phpredis/commit/e80600e244b8442cb7c86e99b067966cd59bf2ee)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n- Configurable unit test authentication arguments\n  [e37f38a3](https://github.com/phpredis/phpredis/commit/e37f38a39eb4bece8f49ebd0652112dc992084a0),\n  [201a9759](https://github.com/phpredis/phpredis/commit/201a97599953a9621bb8eb02dc8d5f08d16499a3)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko),\n   [Michael Grunder](https://github.com/michael-grunder))\n\n### Fixed\n\n- Improved cluster slot caching mechanism to fix a couple of bugs and make it more efficient.\n  [5ca4141c](https://github.com/phpredis/phpredis/commit/5ca4141c72e23816f146b49877a6a4b8098b34c6)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n- Stop calling Redis constructor when creating a RedisArray\n  [e41e19a8](https://github.com/phpredis/phpredis/commit/e41e19a8342212ee9cfe35f622804c9870d05ec2)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n- Use ZEND_LONG_FMT instead of system `long`\n  [5bf88124](https://github.com/phpredis/phpredis/commit/5bf881244dd30b5310fcfcaf5bcd8f9e2675bb01)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n- Use long for SCAN iteration to fix potential overflow\n  [f13f9b7c](https://github.com/phpredis/phpredis/commit/f13f9b7c7f5e3a7d286b412541199a408a0a98bd)\n  ([Victor Kislov](https://github.com/vityank))\n\n- Fix config.m4 to test for the variable $PHP_REDIS_JSON and not the literal PHP_REDIS_JSON\n  [20a3dc72](https://github.com/phpredis/phpredis/commit/20a3dc7251cb0bf450ef2a1cfeeeaeaa10355cd2)\n  ([Mizuki Nakano](https://github.com/mi-nakano))\n\n- Fix compiler warnings\n  [b9b383f4](https://github.com/phpredis/phpredis/commit/b9b383f49939484dcddf1a5edefdb9d753baa7f8),\n  [215828e](https://github.com/phpredis/phpredis/commit/215828e3474dfd9ea72fdc6da67aa6bee2d95ddf)\n  ([Remi Collet](https://github.com/remicollet), [Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n- Avoid use-after-free of RediSock\n  [8c45816d](https://github.com/phpredis/phpredis/commit/8c45816dbf4746f6557f83332be874bd78b5ce34)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n- Fixed ZADD arginfo\n  [a8e2b021](https://github.com/phpredis/phpredis/commit/a8e2b021f9eb51ad3ed0cc89064e2f004c56f8ba)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Changed\n\n- Store AUTH information in flags RedisSock rather than duplicating information.\n  [58dab564](https://github.com/phpredis/phpredis/commit/58dab5649fcc2cc63f5a29df83f783e154d7fa22)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n- Refactor redis_sock_get_connection_pool logic.\n  [73212e1](https://github.com/phpredis/phpredis/commit/73212e141403ec47441142fe1c7fd5fad24f6720)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n- Updated documentation to show LPUSH and RPUSH are variadic and fixed DEL documentation.\n  [92f8dde1](https://github.com/phpredis/phpredis/commit/92f8dde1c996d4e1c3d79226b888119307612c40)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n- Authenticate in redis_server_sock_open\n  [4ef465b5](https://github.com/phpredis/phpredis/commit/4ef465b57325d2d93234fd66af06a7091ce7d1ea)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n- Dynamically include json.so in unit tests based on configuration\n  [0ce7ca2f](https://github.com/phpredis/phpredis/commit/0ce7ca2fb1eb2f3c445487957a49b70ad8d4ecb6)\n  (([Michael Grunder](https://github.com/michael-grunder))\n\n- Update save_path logic in Redis Cluster session unit tests\n  [dd66fce](https://github.com/phpredis/phpredis/commit/dd66fceeb232f9e1fb0a26373949e810180dc5fc)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n- Refactoring various bits of logic\n  [bbcf32a3](https://github.com/phpredis/phpredis/commit/bbcf32a37fa856ba0b50b489ba05bd3d43800fcc),\n  [a42cf189](https://github.com/phpredis/phpredis/commit/a42cf189a776fc43acf47ca519f1d7385cc27f2f),\n  [460c8f29](https://github.com/phpredis/phpredis/commit/460c8f29239c263e15a093c9bcdb6fb24587ec7d),\n  [b7f9df75](https://github.com/phpredis/phpredis/commit/b7f9df758b30187864012d5cd831dbbc5fa053d0),\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n- Use the portable `ZEND_LONG_FORMAT` family instead of C format specifiers\n  [b9b383f4](https://github.com/phpredis/phpredis/commit/b9b383f4)\n  ([Remi Collet](https://github.com/remicollet))\n\n- PHP 8 compatibility\n  [9ee94ca4](https://github.com/phpredis/phpredis/commit/9ee94ca4),\n  [7e4c7b3e](https://github.com/phpredis/phpredis/commit/7e4c7b3e)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n- Refactor PHPREDIS_GET_OBJECT macro\n  [d5dadaf6](https://github.com/phpredis/phpredis/commit/d5dadaf6),\n  [190c0d34](https://github.com/phpredis/phpredis/commit/190c0d34)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n- Fix documentation to show lPush and rPush are variadic\n  [6808cd6a](https://github.com/phpredis/phpredis/commit/6808cd6a)\n  ([Michel Grunder](https://github.com/michael-grunder))\n\n---\n\n## [5.2.2] - 2020-05-05 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/5.2.2), [PECL](https://pecl.php.net/package/redis/5.2.2))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack.com](https://audiomack.com)\n- [Till Kr√ºss](https://github.com/tillkruss)\n\n### Changed\n\n- Inexpensive liveness check, and making ECHO optional\n  [56898f81](https://github.com/phpredis/phpredis/commit/56898f81)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n- Move `AUTH` to `redis_sock_server_open`\n  [80f2529b](https://github.com/phpredis/phpredis/commit/80f2529b)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n---\n\n## [5.2.1] - 2020-03-19 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/5.2.1), [PECL](https://pecl.php.net/package/redis/5.2.1))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack.com](https://audiomack.com)\n- [Till Kr√ºss](https://github.com/tillkruss)\n\n### Fixed\n\n- Fix arginfo for Redis::zadd\n  [a8e2b021](https://github.com/phpredis/phpredis/commit/a8e2b021)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n- Fix segfault on closing persistent stream\n  [b7f9df75](https://github.com/phpredis/phpredis/commit/b7f9df75)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n---\n\n## [5.2.0] - 2020-03-02 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/5.2.0), [PECL](https://pecl.php.net/package/redis/5.2.0))\n\n*There were no changes between 5.2.0RC2 and 5.2.0*\n\n## [5.2.0RC2] - 2020-02-21 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/5.2.0RC2), [PECL](https://pecl.php.net/package/redis/5.2.0RC2))\n\n### Sponsors :sparkling_heart:\n\n- [Audiomack.com](https://audiomack.com)\n- [Till Kr√ºss](https://github.com/tillkruss)\n\n### Fixed\n\n- Include RedisSentinelTest.php in package.xml!\n  [eddbfc8f](https://github.com/phpredis/phpredis/commit/eddbfc8f)\n  ([Michel Grunder](https://github.com/michael-grunder))\n\n- Fix -Wmaybe-uninitialized warning\n  [740b8c87](https://github.com/phpredis/phpredis/commit/740b8c87)\n  ([Remi Collet](https://github.com/remicollet))\n\n- Fix improper destructor when zipping values and scores\n  [371ae7ae](https://github.com/phpredis/phpredis/commit/371ae7ae)\n\n- Use php_rand instead of php_mt_rand for liveness challenge string\n  [9ef2ed89](https://github.com/phpredis/phpredis/commit/9ef2ed89)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n## [5.2.0RC1] - 2020-02-15 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/5.2.0RC1), [PECL](https://pecl.php.net/package/redis/5.2.0RC1))\n\n### Sponsors :sparkling_heart:\n\n- [Till Kr√ºss](https://github.com/tillkruss)\n\n### Added\n\n- Added challenge/response mechanism to ensure persistent connections are not in a bad state\n  [a5f95925](https://github.com/phpredis/phpredis/commit/a5f95925),\n  [25cdaee6](https://github.com/phpredis/phpredis/commit/25cdaee6),\n  [7b6072e0](https://github.com/phpredis/phpredis/commit/7b6072e0),\n  [99ebd0cc](https://github.com/phpredis/phpredis/commit/99ebd0cc),\n  [3243f426](https://github.com/phpredis/phpredis/commit/3243f426)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko), [Michael Grunder](https://github.com/michael-grunder))\n\n- Experimental support for RedisSentinel\n  [90cb69f3](https://github.com/phpredis/phpredis/commit/90cb69f3),\n  [c94e28f1](https://github.com/phpredis/phpredis/commit/c94e28f1),\n  [46da22b0](https://github.com/phpredis/phpredis/commit/46da22b0),\n  [5a609fa4](https://github.com/phpredis/phpredis/commit/5a609fa4),\n  [383779ed](https://github.com/phpredis/phpredis/commit/383779ed)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Fixed\n\n- Fixed ASK redirection logic\n  [ba73fbee](https://github.com/phpredis/phpredis/commit/ba73fbee)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n- Create specific 'test skipped' exception\n  [c3d83d44](https://github.com/phpredis/phpredis/commit/c3d83d44)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n- Fixed memory leaks in RedisCluster\n  [a107c9fc](https://github.com/phpredis/phpredis/commit/a107c9fc)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n- Fixes for session lifetime values that underflow or overflow\n  [7a79ad9c](https://github.com/phpredis/phpredis/commit/7a79ad9c),\n  [3c48a332](https://github.com/phpredis/phpredis/commit/3c48a332)\n  ([Michael Grunder](https://github.com/michael-grunder))\n\n- Enables slot caching for Redis Cluster\n  [23b1a9d8](https://github.com/phpredis/phpredis/commit/23b1a9d8)\n  ([Michael Booth](https://github.com/Michael03))\n\n- Housekeeping (spelling, doc changes, etc)\n  [23f9de30](https://github.com/phpredis/phpredis/commit/23f9de30),\n  [d07a8df6](https://github.com/phpredis/phpredis/commit/d07a8df6),\n  [2d39b48d](https://github.com/phpredis/phpredis/commit/2d39b48d),\n  [0ef488fc](https://github.com/phpredis/phpredis/commit/0ef488fc),\n  [2c35e435](https://github.com/phpredis/phpredis/commit/2c35e435),\n  [f52bd8a8](https://github.com/phpredis/phpredis/commit/f52bd8a8),\n  [2ddc5f21](https://github.com/phpredis/phpredis/commit/2ddc5f21),\n  [1ff7dfb7](https://github.com/phpredis/phpredis/commit/1ff7dfb7),\n  [db446138](https://github.com/phpredis/phpredis/commit/db446138)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko),\n   [Tyson Andre](https://github.com/TysonAndre), [Michael Grunder](https://github.com/michael-grunder),\n   [Paul DelRe](https://github.com/pdelre), [Tyson Andre](https://github.com/TysonAndre))\n\n### Changed\n\n- Support TYPE argument for SCAN\n  [8eb39a26](https://github.com/phpredis/phpredis/commit/8eb39a26)\n  [b1724b84](https://github.com/phpredis/phpredis/commit/b1724b84)\n  [53fb36c9](https://github.com/phpredis/phpredis/commit/53fb36c9)\n  [544e641b](https://github.com/phpredis/phpredis/commit/544e641b)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n---\n\n## [5.1.1] - 2019-11-11 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/5.1.1), [PECL](https://pecl.php.net/package/redis/5.1.1))\n\n### Fixed\n\n- Fix fail to connect to redis through unix socket\n  [2bae8010](https://github.com/phpredis/phpredis/commit/2bae8010),\n  [9f4ededa](https://github.com/phpredis/phpredis/commit/9f4ededa)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko), [Michael Grunder](https://github.com/michael-grunder))\n\n---\n\n## [5.1.0] - 2019-10-31 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/5.1.0), [PECL](https://pecl.php.net/package/redis/5.1.0))\n\n### Added\n\n- Add optional support for Zstd compression, using `--enable-redis-zstd`.\n  This requires libzstd version >= 1.3.0\n  [2abc61da](https://github.com/phpredis/phpredis/commit/2abc61da)\n  ([Remi Collet](https://github.com/remicollet))\n- Add documentation for zpopmin and zpopmax\n  [99ec24b3](https://github.com/phpredis/phpredis/commit/99ec24b3),\n  [4ab1f940](https://github.com/phpredis/phpredis/commit/4ab1f940)\n  ([alexander-schranz](https://github.com/alexander-schranz))\n- Allow to specify scheme for session handler.\n  [53a8bcc7](https://github.com/phpredis/phpredis/commit/53a8bcc7)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Changed\n\n- Refactor redis_session\n  [91a8e734](https://github.com/phpredis/phpredis/commit/91a8e734),\n  [978c3074](https://github.com/phpredis/phpredis/commit/978c3074)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix overallocation in RedisCluster directed node commands\n  [cf93649](https://github.com/phpredis/phpredis/commit/cf93649)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Also attach slaves when caching cluster slots\n  [0d6d3fdd](https://github.com/phpredis/phpredis/commit/0d6d3fdd),\n  [b114fc26](https://github.com/phpredis/phpredis/commit/b114fc26)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Use zend_register_persistent_resource_ex for connection pooling\n  [fdada7ae](https://github.com/phpredis/phpredis/commit/fdada7ae),\n  [7c6c43a6](https://github.com/phpredis/phpredis/commit/7c6c43a6)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Fixed\n\n- Fix regression for multihost_distribute_call added in [112c77e3](https://github.com/phpredis/phpredis/commit/112c77e3)\n  [fbe0f804](https://github.com/phpredis/phpredis/commit/fbe0f804)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Revert \"fix regression for conntecting to ports > 32767\" added in [1f41da64](https://github.com/phpredis/phpredis/commit/1f41da64) and add another fix\n  [17b139d8](https://github.com/phpredis/phpredis/commit/17b139d8),\n  [7ef17ce1](https://github.com/phpredis/phpredis/commit/7ef17ce1)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix regression for conntecting to unix sockets with relative path added in [1f41da64](https://github.com/phpredis/phpredis/commit/1f41da64)\n  [17b139d8](https://github.com/phpredis/phpredis/commit/17b139d8),\n  [7ef17ce1](https://github.com/phpredis/phpredis/commit/7ef17ce1)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix unix-socket detection logic broken in [418428fa](https://github.com/phpredis/phpredis/commit/418428fa)\n  [a080b73f](https://github.com/phpredis/phpredis/commit/a080b73f)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix memory leak and bug with getLastError for redis_mbulk_reply_assoc and redis_mbulk_reply_zipped.\n  [7f42d628](https://github.com/phpredis/phpredis/commit/7f42d628),\n  [3a622a07](https://github.com/phpredis/phpredis/commit/3a622a07)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko)),\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Fix bug with password contain \"#\" for redis_session\n  [2bb08680](https://github.com/phpredis/phpredis/commit/2bb08680)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Missing null byte in PHP_MINFO_FUNCTION\n  [8bc2240c](https://github.com/phpredis/phpredis/commit/8bc2240c)\n  ([Remi Collet](https://github.com/remicollet))\n\n### Removed\n\n- Dead code generic_unsubscribe_cmd\n  [8ee4abbc](https://github.com/phpredis/phpredis/commit/8ee4abbc)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n---\n\n## [5.0.2] - 2019-07-29 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/5.0.2), [PECL](https://pecl.php.net/package/redis/5.0.2))\n\n### Fixed\n\n- Fix regression for conntecting to ports > 32767\n  [1f41da64](https://github.com/phpredis/phpredis/commit/1f41da64),\n  ([Owen Smith](https://github.com/orls))\n- RedisCluster segfaults after second connection with cache_slots enabled\n  [f52cd237](https://github.com/phpredis/phpredis/commit/f52cd237),\n  [cb5d6b94](https://github.com/phpredis/phpredis/commit/cb5d6b94)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko), [Michael Grunder](https://github.com/michael-grunder))\n\n### Changed\n\n- Cleanup TSRMLS_* usage\n  [94380227](https://github.com/phpredis/phpredis/commit/94380227)\n  ([Remi Collet](https://github.com/remicollet))\n- Replace ulong with zend_ulong\n  [b4eb158a](https://github.com/phpredis/phpredis/commit/b4eb158a)\n  ([Remi Collet](https://github.com/remicollet))\n- Replace uint with uint32_t\n  [d6fc5c73](https://github.com/phpredis/phpredis/commit/d6fc5c73)\n  ([Remi Collet](https://github.com/remicollet))\n\n---\n\n## [5.0.1] - 2019-07-12 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/5.0.1), [PECL](https://pecl.php.net/package/redis/5.0.1))\n\n### Fixed\n\n- RedisCluster segfaults after second connection with cache_slots enabled\n  [327cf0bd](https://github.com/phpredis/phpredis/commit/327cf0bd)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n---\n\n## [5.0.0] - 2019-07-02 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/5.0.0), [PECL](https://pecl.php.net/package/redis/5.0.0))\n\nThis release contains important improvements and breaking changes.  The most\ninteresting are: drop PHP5 support, RedisCluster slots caching, JSON and msgpack\nserializers, soft deprecation of non-Redis commands.\n\n### Breaking Changes\n\n- [Nullable xReadGroup COUNT and BLOCK arguments](#brk500-xreadgroup)\n- [RedisArray exception now includes host information](#brk500-exception-host)\n- [zRange now conforms to zRangeByScore to get scores](#brk500-zrange-withscores)\n\n### Added\n- Adds OPT_REPLY_LITERAL for rawCommand and EVAL [5cb30fb2](https://www.github.com/phpredis/phpredis/commit/5cb30fb2)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- JSON serializer [98bd2886](https://www.github.com/phpredis/phpredis/commit/98bd2886),\n  [96c57139](https://www.github.com/phpredis/phpredis/commit/96c57139),\n  [235a27](https://www.github.com/phpredis/phpredis/commit/235a27)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko), [Michael Grunder](https://github.com/michael-grunder))\n- msgpack serializer [d5b8f833](https://www.github.com/phpredis/phpredis/commit/d5b8f833),\n  [545250f3](https://www.github.com/phpredis/phpredis/commit/545250f3),\n  [52bae8ab](https://www.github.com/phpredis/phpredis/commit/52bae8ab)\n  ([@bgort](https://github.com/bgort), [Pavlo Yatsukhnenko](https://github.com/yatsukhnenko),\n   [Michael Grunder](https://github.com/michael-grunder))\n- Add support for STREAM to the type command [d7450b2f](https://www.github.com/phpredis/phpredis/commit/d7450b2f),\n  [068ce978](https://www.github.com/phpredis/phpredis/commit/068ce978), [8a45d18c](https://www.github.com/phpredis/phpredis/commit/8a45d18c)\n  ([Michael Grunder](https://github.com/michael-grunder), [Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add Cluster slots caching [9f0d7bc0](https://www.github.com/phpredis/phpredis/commit/9f0d7bc0),\n  [ea081e05](https://www.github.com/phpredis/phpredis/commit/ea081e05) ([Michael Grunder](https://github.com/michael-grunder))\n\n### Changed\n\n- <a id=\"brk500-exception-host\">Add server address to exception message.  This changes the exception message from `read error on connection` to\n  `read error on connection to <host>:<port>` or `read error on connection to </path/to/socket>` so code matching the exception string might break.\n  [e8fb49be](https://www.github.com/phpredis/phpredis/commit/e8fb49be),\n  [34d6403d](https://www.github.com/phpredis/phpredis/commit/34d6403d)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Allow to specify server address as `schema://host` [418428fa](https://www.github.com/phpredis/phpredis/commit/418428fa)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko)).\n- Update Fedora installation instructions [90aa067c](https://www.github.com/phpredis/phpredis/commit/90aa067c)\n  ([@remicollet](https://github.com/remicollet))\n- Enable connection pooling by default [8206b147](https://www.github.com/phpredis/phpredis/commit/8206b147)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- <a id=\"brk500-ping-argument\">Allow PING to take an optional argument. PING now returns `true` instead of \"+PONG\" [6e494170](https://www.github.com/phpredis/phpredis/commit/6e494170)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- <a id=\"brk500-zrange-withscores\">Allow ZRANGE to be called either with `true` or `['withscores' => true]`\n  [19f3efcf](https://www.github.com/phpredis/phpredis/commit/19f3efcf) ([Michael Grunder](https://github.com/michael-grunder))\n- Documentation improvements ([@alexander-schranz](https://github.com/alexander-schranz), [@cookieguru](https://github.com/cookieguru),\n  [Pavlo Yatsukhnenko](https://github.com/yatsukhnenko), [Michael Grunder](https://github.com/michael-grunder))\n\n### Deprecated\n\n- Soft deprecate methods that aren't actually Redis commands [a81b4f2d](https://www.github.com/phpredis/phpredis/commit/a81b4f2d),\n  [95c8aab9](https://www.github.com/phpredis/phpredis/commit/95c8aab9), [235a27](https://www.github.com/phpredis/phpredis/commit/235a27) ([@michael-grunder](https://github.com/michael-grunder), [@yatsukhnenko](https://github.com/weltling))\n- Remove HAVE_SPL define [[55c5586c](https://www.github.com/phpredis/phpredis/commit/55c5586c)] ([@petk](https://github.com/petk))\n\n### Removed\n\n- Drop PHP5 support [[f9928642](https://www.github.com/phpredis/phpredis/commit/f9928642), [46a50c12](https://www.github.com/phpredis/phpredis/commit/46a50c12), [4601887d](https://www.github.com/phpredis/phpredis/commit/4601887d), [6ebb36ce](https://www.github.com/phpredis/phpredis/commit/6ebb36ce), [fdbe9d29](https://www.github.com/phpredis/phpredis/commit/fdbe9d29)] (Michael\n  Grunder)\n\n### Fixed\n\n- Reworked PHP msgpack >= 2.0.3 version requirement. [6973478](https://www.github.com/phpredis/phpredis/commit/6973478)..[a537df8](https://www.github.com/phpredis/phpredis/commit/a537df8)\n  ([@michael-grunder](https://github.com/michael-grunder)).\n- Enable pooling for cluster slave nodes [17600dd1](https://www.github.com/phpredis/phpredis/commit/17600dd1) ([Michael Grunder](https://github.com/michael-grunder))\n- xInfo response format [4852a510](https://www.github.com/phpredis/phpredis/commit/4852a510), [ac9dca0a](https://www.github.com/phpredis/phpredis/commit/ac9dca0a) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- <a id=\"brk500-xreadgroup\">Make the XREADGROUP optional COUNT and BLOCK arguments nullable\n  [0c17bd27](https://www.github.com/phpredis/phpredis/commit/0c17bd27)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Allow persistent_id to be passed as NULL with strict_types enabled [60223762](https://www.github.com/phpredis/phpredis/commit/60223762)\n  ([Michael Grunder](https://github.com/michael-grunder))\n- Fix TypeError when using built-in constants in `setOption` [4c7643ee](https://www.github.com/phpredis/phpredis/commit/4c7643ee)\n  ([@JoyceBabu](https://github.com/JoyceBabu))\n- Handle references in MGET [60d8b679](https://www.github.com/phpredis/phpredis/commit/60d8b679) ([Michael Grunder](https://github.com/michael-grunder))\n\n---\n\n## [4.3.0] - 2019-03-13 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/4.3.0), [PECL](https://pecl.php.net/package/redis/4.3.0))\n\nThis is probably the last release with PHP 5 support!!!\n\n### Added\n\n- RedisArray auth [b5549cff](https://www.github.com/phpredis/phpredis/commit/b5549cff), [339cfa2b](https://www.github.com/phpredis/phpredis/commit/339cfa2b),\n  [6b411aa8](https://www.github.com/phpredis/phpredis/commit/6b411aa8) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add ZPOPMAX and ZPOPMIN support [46f03561](https://www.github.com/phpredis/phpredis/commit/46f03561),\n  [f89e941a](https://www.github.com/phpredis/phpredis/commit/f89e941a),\n  [2ec7d91a](https://www.github.com/phpredis/phpredis/commit/2ec7d91a) (@mbezhanov, [Michael Grunder](https://github.com/michael-grunder))\n- Implement GEORADIUS_RO and GEORADIUSBYMEMBER_RO [22d81a94](https://www.github.com/phpredis/phpredis/commit/22d81a94) ([Michael Grunder](https://github.com/michael-grunder))\n- RedisCluster auth [c5994f2a](https://www.github.com/phpredis/phpredis/commit/c5994f2a) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Different key hashing algorithms from hash extension [850027ff](https://www.github.com/phpredis/phpredis/commit/850027ff)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Changed\n\n- Proper persistent connections pooling implementation [a3703820](https://www.github.com/phpredis/phpredis/commit/a3703820),\n  [c76e00fb](https://www.github.com/phpredis/phpredis/commit/c76e00fb), [0433dc03](https://www.github.com/phpredis/phpredis/commit/0433dc03),\n  [c75b3b93](https://www.github.com/phpredis/phpredis/commit/c75b3b93) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Use zend_string for storing key hashing algorithm [8cd165df](https://www.github.com/phpredis/phpredis/commit/8cd165df),\n  [64e6a57f](https://www.github.com/phpredis/phpredis/commit/64e6a57f), [Pavlo Yatsukhnenko](https://github.com/yatsukhnenko)\n\n- Add callback parameter to subscribe/psubscribe arginfo [0653ff31](https://www.github.com/phpredis/phpredis/commit/0653ff31),\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Xgroup updates [15995c06](https://www.github.com/phpredis/phpredis/commit/15995c06) ([Michael Grunder](https://github.com/michael-grunder))\n- Use zend_string for pipeline_cmd [e98f5116](https://www.github.com/phpredis/phpredis/commit/e98f5116) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Implement consistent hashing algorithm for RedisArray [bb32e6f3](https://www.github.com/phpredis/phpredis/commit/bb32e6f3), [71922bf1](https://www.github.com/phpredis/phpredis/commit/71922bf1)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Use zend_string for storing RedisArray hosts [602740d3](https://www.github.com/phpredis/phpredis/commit/602740d3),\n  [3e7e1c83](https://www.github.com/phpredis/phpredis/commit/3e7e1c83) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Refactor redis_sock_read_bulk_reply [bc4dbc4b](https://www.github.com/phpredis/phpredis/commit/bc4dbc4b) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Fixed\n\n- Don't check the number affected keys in PS_UPDATE_TIMESTAMP_FUNC [b00060ce](https://www.github.com/phpredis/phpredis/commit/b00060ce)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Cancel pipeline mode without executing commands [789256d7](https://www.github.com/phpredis/phpredis/commit/789256d7)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Breaking the lock acquire loop in case of network problems [61889cd7](https://www.github.com/phpredis/phpredis/commit/61889cd7)\n  ([@SkydiveMarius](https://github.com/SkydiveMarius))\n- Update lzf_compress to be compatible with PECL lzf extension [b27fd430](https://www.github.com/phpredis/phpredis/commit/b27fd430)\n  ([@jrchamp](https://github.com/jrchamp))\n- Fix RedisCluster keys memory leak [3b56b7db](https://www.github.com/phpredis/phpredis/commit/3b56b7db) ([Michael Grunder](https://github.com/michael-grunder))\n- Directly use return_value in RedisCluster::keys method [ad10a49e](https://www.github.com/phpredis/phpredis/commit/ad10a49e)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix segfault in Redis Cluster with inconsistent configuration [72749916](https://www.github.com/phpredis/phpredis/commit/72749916),\n  [6e455e2e](https://www.github.com/phpredis/phpredis/commit/6e455e2e) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Masters info leakfix [91bd7426](https://www.github.com/phpredis/phpredis/commit/91bd7426) ([Michael Grunder](https://github.com/michael-grunder))\n- Remove unused parameter lazy_connect from redis_sock_create [c0793e8b](https://www.github.com/phpredis/phpredis/commit/c0793e8b)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Remove useless `ZEND_ACC_[C|D]TOR`. [bc9b5597](https://www.github.com/phpredis/phpredis/commit/bc9b5597) (@[twosee](https://github.com/twose))\n- Documentation improvements ([yulonghu](https://github.com/yulonghu), [@alexander-schranz](https://github.com/alexander-schranz), [@hmc](https://github.com/hmczju),\n  [Pavlo Yatsukhnenko](https://github.com/yatsukhnenko), [Michael Grunder](https://github.com/michael-grunder))\n\n---\n\n## [4.2.0] - 2018-11-08 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/4.2.0), [PECL](https://pecl.php.net/package/redis/4.2.0))\n\nThe main feature of this release is new Streams API implemented by\n[Michael Grunder](https://github.com/michael-grunder).\n\n### Added\n\n- Streams API [2c9e0572](https://www.github.com/phpredis/phpredis/commit/2c9e0572), [0b97ec37](https://www.github.com/phpredis/phpredis/commit/0b97ec37) ([Michael Grunder](https://github.com/michael-grunder))\n- Display ini entries in output of phpinfo [908ac4b3](https://www.github.com/phpredis/phpredis/commit/908ac4b3) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Persistent connections can be closed via close method + change reconnection\n  logic [1d997873](https://www.github.com/phpredis/phpredis/commit/1d997873) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Changed\n\n- Optimize close method [2a1ef961](https://www.github.com/phpredis/phpredis/commit/2a1ef961) ([yulonghu](https://github.com/yulonghu))\n- Use a ZSET instead of SET for EVAL tests [2e412373](https://www.github.com/phpredis/phpredis/commit/2e412373) ([Michael Grunder](https://github.com/michael-grunder))\n- Modify session testing logic [bfd27471](https://www.github.com/phpredis/phpredis/commit/bfd27471) ([Michael Grunder](https://github.com/michael-grunder))\n- Documentation improvements ([@michael-grunder](https://github.com/michael-grunder), [@elcheco](https://github.com/elcheco), [@lucascourot](https://github.com/lucascourot), [@nolimitdev](https://github.com/nolimitdev),\n  [Michael Grunder](https://github.com/michael-grunder))\n\n### Fixed\n\n- Prevent potential infinite loop for sessions [4e2de158](https://www.github.com/phpredis/phpredis/commit/4e2de158) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix coverty warnings [6f7ddd27](https://www.github.com/phpredis/phpredis/commit/6f7ddd27) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix session memory leaks [071a1d54](https://www.github.com/phpredis/phpredis/commit/071a1d54), [92f14b14](https://www.github.com/phpredis/phpredis/commit/92f14b14) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko),\n  [Michael Grunder](https://github.com/michael-grunder))\n- Fix XCLAIM on 32-bit installs [18dc2aac](https://www.github.com/phpredis/phpredis/commit/18dc2aac) ([Michael Grunder](https://github.com/michael-grunder))\n- Build warning fixes [b5093910](https://www.github.com/phpredis/phpredis/commit/b5093910), [51027044](https://www.github.com/phpredis/phpredis/commit/51027044), [8b0f28cd](https://www.github.com/phpredis/phpredis/commit/8b0f28cd) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko),\n  [Remi Collet](https://github.com/remicollet), [twosee](https://github.com/twose))\n- Fix incorrect arginfo for `Redis::sRem` and `Redis::multi` [25b043ce](https://www.github.com/phpredis/phpredis/commit/25b043ce)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Treat a -1 response from cluster_check_response as a timeout. [27df9220](https://www.github.com/phpredis/phpredis/commit/27df9220),\n  [07ef7f4e](https://www.github.com/phpredis/phpredis/commit/07ef7f4e), [d1172426](https://www.github.com/phpredis/phpredis/commit/d1172426) ([Michael Grunder](https://github.com/michael-grunder)).\n- Missing space between command and args [0af2a7fe](https://www.github.com/phpredis/phpredis/commit/0af2a7fe) ([@remicollet](https://github.com/remicollet))\n- Reset the socket after a timeout to make sure no wrong data is received\n  [cd6ebc6d](https://www.github.com/phpredis/phpredis/commit/cd6ebc6d) ([@marcdejonge](https://github.com/marcdejonge))\n- Allow '-' and '+' arguments and add tests for zLexCount and zRemRangeByLex\n  [d4a08697](https://www.github.com/phpredis/phpredis/commit/d4a08697) ([Michael Grunder](https://github.com/michael-grunder))\n- Fix printf format warnings [dcde9331](https://www.github.com/phpredis/phpredis/commit/dcde9331) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Session module is required [58bd8cc8](https://www.github.com/phpredis/phpredis/commit/58bd8cc8) ([@remicollet](https://github.com/remicollet))\n- Set default values for ini entries [e206ce9c](https://www.github.com/phpredis/phpredis/commit/e206ce9c) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n---\n\n## [4.0.0] - 2018-03-07 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/4.0.0), [PECL](https://pecl.php.net/package/redis/4.0.0))\n\n*WARNING:* THIS RELEASE CONTAINS BREAKING API CHANGES!\n\n### Added\n\n- Add proper ARGINFO for all methods. ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko), [Michael Grunder](https://github.com/michael-grunder))\n- Let EXISTS take multiple keys [cccc39](https://www.github.com/phpredis/phpredis/commit/cccc39) ([Michael Grunder](https://github.com/michael-grunder))\n- Implement SWAPDB and UNLINK commands [84f1f28b](https://www.github.com/phpredis/phpredis/commit/84f1f28b), [9e65c429](https://www.github.com/phpredis/phpredis/commit/9e65c429) ([Michael Grunder](https://github.com/michael-grunder))\n- Add LZF compression (experimental) [e2c51251](https://www.github.com/phpredis/phpredis/commit/e2c51251), [8cb2d5bd](https://www.github.com/phpredis/phpredis/commit/8cb2d5bd), [8657557](https://www.github.com/phpredis/phpredis/commit/8657557) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Allow mixing MULTI and PIPELINE modes (experimental) [5874b0](https://www.github.com/phpredis/phpredis/commit/5874b0) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Changed\n\n- Use zend_string as returning value for ra_extract_key and ra_call_extractor\n  [9cd05911](https://www.github.com/phpredis/phpredis/commit/9cd05911) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Return real connection error as exception [5b9c0c60](https://www.github.com/phpredis/phpredis/commit/5b9c0c60) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko),\n  [Michael Grunder](https://github.com/michael-grunder))\n- Use zend_string for storing auth and prefix members [4b8336f7](https://www.github.com/phpredis/phpredis/commit/4b8336f7)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add tcp_keepalive option to redis sock [68c58513](https://www.github.com/phpredis/phpredis/commit/68c58513), [5101172a](https://www.github.com/phpredis/phpredis/commit/5101172a), [010336d5](https://www.github.com/phpredis/phpredis/commit/010336d5),\n  [51e48729](https://www.github.com/phpredis/phpredis/commit/51e48729) ([@git-hulk](https://github.com/git-hulk), [Michael Grunder](https://github.com/michael-grunder))\n- More robust GEORADIUS COUNT validation [f7edee5d](https://www.github.com/phpredis/phpredis/commit/f7edee5d) ([Michael Grunder](https://github.com/michael-grunder))\n- Allow to use empty string as persistent_id [ec4fd1bd](https://www.github.com/phpredis/phpredis/commit/ec4fd1bd) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Documentation improvements ([Michael Grunder](https://github.com/michael-grunder), [@TomA-R](https://github.com/TomA-R))\n\n### Fixed\n\n- Disallow using empty string as session name. [485db46f](https://www.github.com/phpredis/phpredis/commit/485db46f) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- The element of z_seeds may be a reference on php7 [367bc6aa](https://www.github.com/phpredis/phpredis/commit/367bc6aa), [1e63717a](https://www.github.com/phpredis/phpredis/commit/1e63717a)\n  ([@janic716](https://github.com/janic716))\n- Avoid connection in helper methods [91e9cfe1](https://www.github.com/phpredis/phpredis/commit/91e9cfe1) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Don't use convert_to_string in redis_hmget_cmd [99335d6](https://www.github.com/phpredis/phpredis/commit/99335d6) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- PHP >=7.3.0 uses zend_string to store `php_url` elements [b566fb44](https://www.github.com/phpredis/phpredis/commit/b566fb44) ([@fmk](https://github.com/fmk))\n\n---\n\n## [3.1.5] - 2017-09-27 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/3.1.5), [PECL](https://pecl.php.net/package/redis/3.1.5))\n\nThis is interim release which contains only bug fixes.\n\n### Fixed\n\n- Fix segfault when extending Redis class in PHP 5 [d23eff](https://www.github.com/phpredis/phpredis/commit/d23eff) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix RedisCluster constructor with PHP 7 strict scalar type [5c21d7](https://www.github.com/phpredis/phpredis/commit/5c21d7)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Allow to use empty string as persistent_id [344de5](https://www.github.com/phpredis/phpredis/commit/344de5) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix cluster_init_seeds. [db1347](https://www.github.com/phpredis/phpredis/commit/db1347) ([@adlagares](https://github.com/adlagares))\n- Fix z_seeds may be a reference [42581a](https://www.github.com/phpredis/phpredis/commit/42581a) ([@janic716](https://github.com/janic716))\n- PHP >=7.3 uses zend_string for php_url elements [b566fb](https://www.github.com/phpredis/phpredis/commit/b566fb) ([@fmk](https://github.com/fmk))\n\n---\n\n## [3.1.4] - 2017-09-27 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/3.1.4), [PECL](https://pecl.php.net/package/redis/3.1.4))\n\nThe primary new feature phpredis 3.1.4 is the ability to send MULTI .. EXEC\nblocks in pipeline mode.  There are also many bugfixes and minor improvements\nto the api, listed below.\n\n### Added\n\n- Allow mixing MULTI and PIPELINE modes (experimental)!  [5874b0](https://www.github.com/phpredis/phpredis/commit/5874b0)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Added integration for coverty static analysis and fixed several warnings\n  [faac8b0](https://www.github.com/phpredis/phpredis/commit/faac8b0), [eff7398](https://www.github.com/phpredis/phpredis/commit/eff7398), [4766c25](https://www.github.com/phpredis/phpredis/commit/4766c25), [0438ab4](https://www.github.com/phpredis/phpredis/commit/0438ab4), [1e0b065](https://www.github.com/phpredis/phpredis/commit/1e0b065), [733732a](https://www.github.com/phpredis/phpredis/commit/733732a), [26eeda5](https://www.github.com/phpredis/phpredis/commit/26eeda5), [735025](https://www.github.com/phpredis/phpredis/commit/735025),\n   [42f1c9](https://www.github.com/phpredis/phpredis/commit/42f1c9), [af71d4](https://www.github.com/phpredis/phpredis/commit/af71d4) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko)).\n- Added arginfo introspection structures [81a0303](https://www.github.com/phpredis/phpredis/commit/81a0303), [d5609fc](https://www.github.com/phpredis/phpredis/commit/d5609fc), [e5660be](https://www.github.com/phpredis/phpredis/commit/e5660be), [3c60e1f](https://www.github.com/phpredis/phpredis/commit/3c60e1f),\n  [50dcb15](https://www.github.com/phpredis/phpredis/commit/50dcb15), [6c2c6fa](https://www.github.com/phpredis/phpredis/commit/6c2c6fa), [212e323](https://www.github.com/phpredis/phpredis/commit/212e323), [e23be2c](https://www.github.com/phpredis/phpredis/commit/e23be2c), [682593d](https://www.github.com/phpredis/phpredis/commit/682593d), [f8de702](https://www.github.com/phpredis/phpredis/commit/f8de702), [4ef3acd](https://www.github.com/phpredis/phpredis/commit/4ef3acd), [f116be9](https://www.github.com/phpredis/phpredis/commit/f116be9),\n  [5c111dd](https://www.github.com/phpredis/phpredis/commit/5c111dd), [9caa029](https://www.github.com/phpredis/phpredis/commit/9caa029), [0d69650](https://www.github.com/phpredis/phpredis/commit/0d69650), [6859828](https://www.github.com/phpredis/phpredis/commit/6859828), [024e593](https://www.github.com/phpredis/phpredis/commit/024e593), [3643ab6](https://www.github.com/phpredis/phpredis/commit/3643ab6), [f576fab](https://www.github.com/phpredis/phpredis/commit/f576fab), [122d41f](https://www.github.com/phpredis/phpredis/commit/122d41f),\n  [a09d0e6](https://www.github.com/phpredis/phpredis/commit/a09d0e6) ([Tyson Andre](https://github.com/TysonAndre), [Pavlo Yatsukhnenko](https://github.com/yatsukhnenko)).\n- Added a github issue template [61aba9](https://www.github.com/phpredis/phpredis/commit/61aba9) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Changed\n\n- Refactor redis_send_discard [ea15ce](https://www.github.com/phpredis/phpredis/commit/ea15ce) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Improve redis array rehash [577a91](https://www.github.com/phpredis/phpredis/commit/577a91) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Change redis array pure_cmds from zval to hashtable [a56ed7](https://www.github.com/phpredis/phpredis/commit/a56ed7) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Use zend_string rather than char for various context fields (err, prefix, etc)\n  [2bf7b2](https://www.github.com/phpredis/phpredis/commit/2bf7b2) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Updated runtime exception handling [8dcaa4](https://www.github.com/phpredis/phpredis/commit/8dcaa4), [7c1407](https://www.github.com/phpredis/phpredis/commit/7c1407) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Fixed\n\n- Fixed link to redis cluster documentation [3b0b06](https://www.github.com/phpredis/phpredis/commit/3b0b06) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Removed duplicate HGET in redis array hash table, formatting [d0b9c5](https://www.github.com/phpredis/phpredis/commit/d0b9c5)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko)).\n- Treat NULL bulk as success for session read [659450](https://www.github.com/phpredis/phpredis/commit/659450) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix valgrind warnings [471ce07](https://www.github.com/phpredis/phpredis/commit/471ce07), [1ab89e1](https://www.github.com/phpredis/phpredis/commit/1ab89e1), [b624a8b](https://www.github.com/phpredis/phpredis/commit/b624a8b) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix php5/php7 compatibility layer [1ab89e](https://www.github.com/phpredis/phpredis/commit/1ab89e), [4e3225](https://www.github.com/phpredis/phpredis/commit/4e3225) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix typo in README.markdown [e47e44](https://www.github.com/phpredis/phpredis/commit/e47e44) ([Toby Schrapel](https://github.com/schrapel))\n- Initialize gc member of zend_string [37f569](https://www.github.com/phpredis/phpredis/commit/37f569) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko)).\n- Don't try to set TCP_NODELAY on a unix socket and don't warn on multiple\n  calls to pipeline [d11798](https://www.github.com/phpredis/phpredis/commit/d11798), [77aeba](https://www.github.com/phpredis/phpredis/commit/77aeba) ([Michael Grunder](https://github.com/michael-grunder))\n- Various other library fixes [142b51](https://www.github.com/phpredis/phpredis/commit/142b51), [4452f6](https://www.github.com/phpredis/phpredis/commit/4452f6), [e672f4](https://www.github.com/phpredis/phpredis/commit/e672f4), [658ee3](https://www.github.com/phpredis/phpredis/commit/658ee3), [c9df77](https://www.github.com/phpredis/phpredis/commit/c9df77), [4a0a46](https://www.github.com/phpredis/phpredis/commit/4a0a46)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Removed\n\n- Remove unused PHP_RINIT and PHP_RSHUTDOWN functions [c760bf](https://www.github.com/phpredis/phpredis/commit/c760bf) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n---\n\n## [3.1.3] - 2017-07-15 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/3.1.3), [PECL](https://pecl.php.net/package/redis/3.1.3))\n\nThis release contains two big improvements:\n\n1. Adding a new printf like command construction function with additionally\n   format specifiers specific to phpredis.\n2. Implementation of custom objects for Redis and RedisArray which eliminates\n   double hash lookup.\n\nAlso many small improvements and bug fixes were made.\n\n### Added\n\n- Add hStrLen command [c52077](https://www.github.com/phpredis/phpredis/commit/c52077), [fb88e1](https://www.github.com/phpredis/phpredis/commit/fb88e1) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- A printf like method to construct a Redis RESP command [a4a0ed](https://www.github.com/phpredis/phpredis/commit/a4a0ed), [d75081](https://www.github.com/phpredis/phpredis/commit/d75081),\n  [bdd287](https://www.github.com/phpredis/phpredis/commit/bdd287), [0eaeae](https://www.github.com/phpredis/phpredis/commit/0eaeae), [b3d00d](https://www.github.com/phpredis/phpredis/commit/b3d00d) ([Michael Grunder](https://github.com/michael-grunder))\n- Use custom objects instead of zend_list for storing Redis/RedisArray [a765f8](https://www.github.com/phpredis/phpredis/commit/a765f8),\n  [8fa85a](https://www.github.com/phpredis/phpredis/commit/8fa85a) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Add configureoption tag to package.xml [750963](https://www.github.com/phpredis/phpredis/commit/750963) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Changed\n\n- Add optional COUNT argument to sPop [d2e203](https://www.github.com/phpredis/phpredis/commit/d2e203) ([Michael Grunder](https://github.com/michael-grunder))\n- Allow sInterStore to take one arg [26aec4](https://www.github.com/phpredis/phpredis/commit/26aec4), [4cd06b](https://www.github.com/phpredis/phpredis/commit/4cd06b) ([Michael Grunder](https://github.com/michael-grunder))\n- Allow MIGRATE to accept multiple keys [9aa3db](https://www.github.com/phpredis/phpredis/commit/9aa3db) ([Michael Grunder](https://github.com/michael-grunder))\n- Use crc32 table from PHP distro [f81694](https://www.github.com/phpredis/phpredis/commit/f81694) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Throw exception for all non recoverable errors [e37239](https://www.github.com/phpredis/phpredis/commit/e37239) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Increase read buffers size [520e06](https://www.github.com/phpredis/phpredis/commit/520e06) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Better documentation [f0c25a](https://www.github.com/phpredis/phpredis/commit/f0c25a), [c5991f](https://www.github.com/phpredis/phpredis/commit/c5991f), [9ec9ae](https://www.github.com/phpredis/phpredis/commit/9ec9ae) ([Michael Grunder](https://github.com/michael-grunder))\n- Better TravisCI integration [e37c08](https://www.github.com/phpredis/phpredis/commit/e37c08) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Fixed\n\n- Make sure redisCluster members are all initialized on (re)creation [162d88](https://www.github.com/phpredis/phpredis/commit/162d88)\n- ([Michael Grunder](https://github.com/michael-grunder)).\n- Fix Null Bulk String response parsing in cluster library [058753](https://www.github.com/phpredis/phpredis/commit/058753)\n- ([Alberto Fern√°ndez](https://github.com/albertofem))\n- Allow using numeric string in zInter command [ba0070](https://www.github.com/phpredis/phpredis/commit/ba0070) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Use ZVAL_DEREF macros for dereference input variables [ad4596](https://www.github.com/phpredis/phpredis/commit/ad4596)\n- ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix read_timeout [18149e](https://www.github.com/phpredis/phpredis/commit/18149e), [b56dc4](https://www.github.com/phpredis/phpredis/commit/b56dc4) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix zval_get_string impl for PHP5 [4e56ba](https://www.github.com/phpredis/phpredis/commit/4e56ba) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix Redis/RedisArray segfaults [be5c1f](https://www.github.com/phpredis/phpredis/commit/be5c1f), [635c3a](https://www.github.com/phpredis/phpredis/commit/635c3a), [1f8dde](https://www.github.com/phpredis/phpredis/commit/1f8dde), [43e1e0](https://www.github.com/phpredis/phpredis/commit/43e1e0)\n- ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Fix memory leak and potential segfault [aa6ff77a](https://www.github.com/phpredis/phpredis/commit/aa6ff77a), [88efaa](https://www.github.com/phpredis/phpredis/commit/88efaa) ([Michael Grunder](https://github.com/michael-grunder))\n- Assume \"NULL bulk\" reply as success (empty session data) [4a81e1](https://www.github.com/phpredis/phpredis/commit/4a81e1)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Refactoring ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko), [Michael Grunder](https://github.com/michael-grunder))\n\n---\n\n## [3.1.2] - 2017-03-16 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/3.1.2), [PECL](https://pecl.php.net/package/redis/3.1.2))\n\n### Changes\n\n- Re allow single array for sInterStore [6ef0c2](https://www.github.com/phpredis/phpredis/commit/6ef0c2), [d01966](https://www.github.com/phpredis/phpredis/commit/d01966) ([Michael Grunder](https://github.com/michael-grunder))\n- Better TravisCI integration [4fd2f6](https://www.github.com/phpredis/phpredis/commit/4fd2f6) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Fixed\n\n- RedisArray segfault fix [564ce3](https://www.github.com/phpredis/phpredis/commit/564ce3) ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n- Small memory leak fix [645888b](https://www.github.com/phpredis/phpredis/commit/645888b) (Mike Grunder)\n- Segfault fix when recreating RedisCluster objects [abf7d4](https://www.github.com/phpredis/phpredis/commit/abf7d4) ([Michael Grunder](https://github.com/michael-grunder))\n- Fix for RedisCluster bulk response parsing [4121c4](https://www.github.com/phpredis/phpredis/commit/4121c4) ([Alberto Fern√°ndez](https://github.com/albertofem))\n\n---\n\n## [3.1.1] - 2017-02-01 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/3.1.1), [PECL](https://pecl.php.net/package/redis/3.1.1))\n\nThis release contains mostly fixes for issues introduced when merging\nthe php 5 and 7 codebase into a single branch.\n\n- Additional test updates for 32 bit systems ([@remicollet](https://github.com/remicollet))\n- ARM rounding issue in tests ([@remicollet](https://github.com/remicollet))\n- Use new zend_list_close instead of zend_list_delete when reconnecting.\n- Refactoring of redis_boolean_response_impl and redis_sock_write ([@yatsukhnenko](https://github.com/weltling))\n- Fixed a segfault in igbinary serialization ([@yatsukhnenko](https://github.com/weltling))\n- Restore 2.2.8/3.0.0 functionality to distinguish between an error\n  and simply empty session data. ([@remicollet](https://github.com/remicollet))\n- Fix double to string conversion function ([@yatsukhnenko](https://github.com/weltling))\n- Use PHP_FE_END definition when available ([@remicollet](https://github.com/remicollet))\n- Fixed various 'static function declared but not used' warnings\n- Fixes to various calls which were typecasting pointers to the\n- wrong size. ([@remicollet](https://github.com/remicollet))\n-\n- Added php session unit test ([@yatsukhnenko](https://github.com/weltling))\n- Added explicit module dependency for igbinary ([@remicollet](https://github.com/remicollet))\n- Added phpinfo serialization information ([@remicollet](https://github.com/remicollet))\n\n---\n\n## [3.1.0] - 2016-12-14 ([GitHub](https://github.com/phpredis/phpredis/releases/3.1.0), [PECL](https://pecl.php.net/package/redis/3.1.0))\n\nIn this version of phpredis codebase was unified to work with all versions of php \\o/\nAlso many bug fixes and some improvements has been made.\n\n### Added\n\n- Support the client to Redis Cluster just having one master ([andyli](https://github.com/andyli029)) [892e5646](https://www.github.com/phpredis/phpredis/commit/892e5646)\n- Allow both long and strings that are longs for zrangebyscore offset/limit\n  ([Michael Grunder](https://github.com/michael-grunder)) [bdcdd2aa](https://www.github.com/phpredis/phpredis/commit/bdcdd2aa)\n- Process NX|XX, CH and INCR options in zAdd command [71c9f7c8](https://www.github.com/phpredis/phpredis/commit/71c9f7c8)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n### Fixed\n\n- Fix incrby/decrby for large integers ([Michael Grunder](https://github.com/michael-grunder)) [3a12758a](https://www.github.com/phpredis/phpredis/commit/3a12758a)\n- Use static declarations for spl_ce_RuntimeException decl [a9857d69](https://www.github.com/phpredis/phpredis/commit/a9857d69)\n  ([Jeremy Mikola](https://github.com/jmikola))\n- Fixed method call problem causes session handler to display two times\n  [24f86c49](https://www.github.com/phpredis/phpredis/commit/24f86c49) ([ZiHang Gao](https://github.com/cdoco)).\n- PSETEX method returns '+OK' on success, not true [afcd8445](https://www.github.com/phpredis/phpredis/commit/afcd8445) ([sitri@ndxbn](https://github.com/ndxbn))\n- Fix integer overflow for long (>32bit) increments in hIncrBy [58e1d799](https://www.github.com/phpredis/phpredis/commit/58e1d799)\n  ([@iyesin](https://github.com/iyesin))\n- Move zend_object handler to the end ([Michael Grunder](https://github.com/michael-grunder)) [34107966](https://www.github.com/phpredis/phpredis/commit/34107966)\n- Using setOption on redis array causes immediate connection [f1a85b38](https://www.github.com/phpredis/phpredis/commit/f1a85b38)\n  ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n---\n\n## [3.0.0] - 2016-06-10 ([GitHub](https://github.com/phpredis/phpredis/releases/3.0.0), [PECL](https://pecl.php.net/package/redis/3.0.0))\n\nThis version of phpredis supports cluster and is intended for php versions\n7.0.0 and higher. To compile cluster-enabled phpredis for older versions\nof php, please use the 2.2.8 pecl package.\n\nA huge thanks goes out to Sean DuBois for doing all the work required to get\nphpredis working in php 7.0!\n\n### Added\n\n- PHP 7 Support [3159bd2](https://www.github.com/phpredis//phpredis/commit/3159bd2),\n  [567dc2f](https://www.github.com/phpredis//phpredis/commit/567dc2f), [daa4d9f](https://www.github.com/phpredis//phpredis/commit/daa4d9f),\n  [f2711e3](https://www.github.com/phpredis//phpredis/commit/f2711e3), [9cb9d07](https://www.github.com/phpredis//phpredis/commit/9cb9d07),\n  [d51c89](https://www.github.com/phpredis//phpredis/commit/d51c89), [9ff8f49](https://www.github.com/phpredis//phpredis/commit/9ff8f49),\n  [33bb629](https://www.github.com/phpredis//phpredis/commit/33bb629), [cbdf65a](https://www.github.com/phpredis//phpredis/commit/cbdf65a),\n  [f30b7fd](https://www.github.com/phpredis//phpredis/commit/f30b7fd), [c687a51](https://www.github.com/phpredis//phpredis/commit/c687a51),\n  [6b3e773](https://www.github.com/phpredis//phpredis/commit/6b3e773), [2bf8241](https://www.github.com/phpredis//phpredis/commit/2bf8241),\n  [71bd3d](https://www.github.com/phpredis//phpredis/commit/71bd3d), [9221ca4](https://www.github.com/phpredis//phpredis/commit/9221ca4),\n  [4e00df6](https://www.github.com/phpredis//phpredis/commit/4e00df6), [e2407ca](https://www.github.com/phpredis//phpredis/commit/e2407ca),\n  [97fcfe6](https://www.github.com/phpredis//phpredis/commit/97fcfe6), [77e6200](https://www.github.com/phpredis//phpredis/commit/77e6200)\n  [Sean DuBois](https://github.com/Sean-Der)\n- Redis Cluster support\n- IPv6 support\n\n### Changed\n\n- Allow SINTERSTORE to take a single array argument again\n- Exception handling improvement [Jan-E](https://github.com/Jan-E) [314a2c3c](https://www.github.com/phpredis//phpredis/commit/314a2c3c)\n- Allow '-' and '+' in ZRANGEBYLEX [Patrick Pokatilo](https://github.com/SHyx0rmZ) [8bfa2188](https://www.github.com/phpredis//phpredis/commit/8bfa2188)\n\n### Fixed\n\n- config.w32 fix [Jan-E](https://github.com/Jan-E) [495d308](https://www.github.com/phpredis//phpredis/commit/495d308), [c9e0b682](https://www.github.com/phpredis//phpredis/commit/c9e0b682)\n- Unit test fix for max int value [Jan-E](https://github.com/Jan-E) [659ea2aa](https://www.github.com/phpredis//phpredis/commit/659ea2aa)\n- unsigned long -> zend_ulong fix [Jan-E](https://github.com/Jan-E) [4d66e3d4](https://www.github.com/phpredis//phpredis/commit/4d66e3d4)\n- Visual Stuio 14 fixes [Jan-E](https://github.com/Jan-E) [ea98401c](https://www.github.com/phpredis//phpredis/commit/ea98401c)\n- Segfault fix when looking up our socket [ephemeralsnow](https://github.com/ephemeralsnow) [0126481a](https://www.github.com/phpredis//phpredis/commit/0126481a)\n- Documentation fixes [Ares](https://github.com/ares333) [54b9a0ec](https://www.github.com/phpredis//phpredis/commit/54b9a0ec)\n- php7 related memory leak fix [Stuart Carnie](https://github.com/stuartcarnie) [b75bf3b4](https://www.github.com/phpredis//phpredis/commit/b75bf3b4)\n- Potential segfault fix in cluster session [Sergei Lomakov](https://github.com/sapfeer0k) [661fb5b1](https://www.github.com/phpredis//phpredis/commit/661fb5b1)\n- php7 related serialization leak fix (Adam Harvey) [c40fc1d8](https://www.github.com/phpredis//phpredis/commit/c40fc1d8)\n\n---\n\n## [2.2.8] - 2016-06-02 ([GitHub](https://github.com/phpredis/phpredis/releases/2.2.8), [PECL](https://pecl.php.net/package/redis/2.2.8))\n\nThe main improvement in this version of phpredis is support for Redis\nCluster.  This version of phpredis is intended for versions of php older\nthan 7.\n\n### Added\n\n- Added randomization to our seed nodes to balance which instance is used\n  to map the keyspace [32eb1c5f](https://www.github.com/phpredis/phpredis/commit/32eb1c5f) (Vitaliy Stepanyuk)\n- Added support for IPv6 addresses\n\n### Fixed\n\n- PHP liveness checking workaround (Shafreeck Sea) [c18d58b9](https://www.github.com/phpredis/phpredis/commit/c18d58b9)\n- Various documentation and code formatting and style fixes ([ares333](https://github.com/ares333),\n  [sanpili](https://github.com/sanpili), [Bryan Nelson](https://github.com/bplus), [linfangrong](https://github.com/linfangrong), [Romero Malaquias](https://github.com/RomeroMalaquias), [Viktor Sz√©pe](https://github.com/szepeviktor))\n- Fix scan reply processing to use long instead of int to avoid overflow\n  [mixiaojiong](https://github.com/mixiaojiong)).\n- Fix potential segfault in Redis Cluster session storage [cc15aae](https://www.github.com/phpredis/phpredis/commit/cc15aae)\n  ([Sergei Lomakov](https://github.com/sapfeer0k)).\n- Fixed memory leak in discard function [17b1f427](https://www.github.com/phpredis/phpredis/commit/17b1f427)\n- Sanity check for igbinary unserialization\n  [3266b222](https://www.github.com/phpredis/phpredis/commit/3266b222), [528297a](https://www.github.com/phpredis/phpredis/commit/528297a) ([Maurus Cuelenaere](https://github.com/mcuelenaere)).\n- Fix segfault occurring from unclosed socket connection for Redis Cluster\n  [04196aee](https://www.github.com/phpredis/phpredis/commit/04196aee) ([CatKang](https://github.com/CatKang))\n- Case insensitive zRangeByScore options\n- Fixed dreaded size_t vs long long compiler warning\n\n---\n\n## [2.2.7] - 2015-03-03 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/2.2.7), [PECL](https://pecl.php.net/package/redis/2.2.7))\n\n### Added\n\n- Implemented PFADD, PFMERGE, and PFCOUNT command handling\n- Implemented ZRANGEBYLEX command (holding off on ZREVRANGEBYLEX\n  as that won't be out until 3.0)\n- Implemented getMode() so clients can detect whether we're in\n  ATOMIC/MULTI/PIPELINE mode.\n- Implemented rawCommand() so clients can send arbitrary things to\n  the redis server\n- Implemented DEBUG OBJECT ([@michael-grunder](https://github.com/michael-grunder), [@isage](https://github.com/isage))\n- Added/abide by connect timeout for RedisArray\n\n### Fixed\n\n- Select to the last selected DB when phpredis reconnects\n- Fix a possible invalid free in \\_serialize()\n- Added SAVE and BGSAVE to \"distributable\" commands for RedisArray\n- Fixed invalid \"argc\" calculation in HLL commands ([@welting](https://github.com/weltling))\n- Allow clients to break out of the subscribe loop and return context.\n- Fixes a memory leak in SCAN when OPT_SCAN_RETRY id.\n- Fix possible segfault when igbinary is enabled ([@remicollet](https://github.com/remicollet)).\n- Add a couple of cases where we throw on an error (LOADING/NOAUTH/MASTERDOWN)\n- Fix several issues with serialization NARY\n- Fix missing TSRMLS_CC and a TSRMLS_DC/TSRMLS_CC typo ([@itcom](https://github.com/itcom))\n\n---\n\n## [2.2.5] - 2014-03-15 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/2.2.5), [PECL](https://pecl.php.net/package/redis/2.2.5))\n\n### Added\n\n- Support for the BITPOS command\n- Connection timeout option for RedisArray ([@MiketoString](https://github.com/MiketoString))\n- A \\_serialize method, to complement our existing \\_unserialize method\n- Support for the PUBSUB command\n- Support for SCAN, SSCAN, HSCAN, and ZSCAN\n- Support for the WAIT command\n\n### Fixed\n\n- Handle the COPY and REPLACE arguments for the MIGRATE command\n- Fix syntax error in documentation for the SET command ([@mithunsatheesh](https://github.com/mithunsatheesh))\n- Fix Homebrew documentation instructions ([@mathias](https://github.com/mathiasverraes))\n\n---\n\n## [2.2.4] - 2013-09-01 ([GitHub](https://github.com/phpredis/phpredis/releases/tag/2.2.4), [PECL](https://pecl.php.net/package/redis/2.2.4))\n\n### Added\n\n- Randomized reconnect delay for RedisArray @mobli\n- Lazy connections to RedisArray servers @mobli\n- Allow LONG and STRING keys in MGET/MSET\n- Extended SET options for Redis &gt;= 2.6.12\n- Persistent connections and UNIX SOCKET support for RedisArray\n- Allow aggregates for ZUNION/ZINTER without weights @mheijkoop\n- Support for SLOWLOG command\n\n### Changed\n- Reworked MGET algorithm to run in linear time regardless of key count.\n- Reworked ZINTERSTORE/ZUNIONSTORE algorithm to run in linear time\n\n### Fixed\n\n- C99 Compliance (or rather lack thereof) fix @mobli\n- Added ZEND_ACC_CTOR and ZEND_ACC_DTOR [@euskadi31](https://github.com/euskadi31)\n- Stop throwing and clearing an exception on connect failure @matmoi\n- Fix a false positive unit test failure having to do with TTL returns\n"
        },
        {
          "name": "CREDITS",
          "type": "blob",
          "size": 0.19921875,
          "content": "Redis client extension for PHP\nAlfonso Jimenez (yo@alfonsojimenez.com)\nNasreddine Bouafif (n.bouafif@owlient.eu)\nNicolas Favre-Felix (n.favre-felix@owlient.eu)\nMichael Grunder (michael.grunder@gmail.com)\n"
        },
        {
          "name": "INSTALL.md",
          "type": "blob",
          "size": 3.763671875,
          "content": "# Installation from pecl\n\nTo pull latest stable released version, from [pecl](https://pecl.php.net/package/redis)\n\n~~~\npecl install redis\n~~~\n\n# Installation from sources\n\nTo build this extension for the sources tree:\n\n~~~\ngit clone https://github.com/phpredis/phpredis.git\ncd phpredis\nphpize\n./configure [--enable-redis-igbinary] [--enable-redis-msgpack] [--enable-redis-lzf [--with-liblzf[=DIR]]] [--enable-redis-zstd] [--enable-redis-lz4]\nmake && make install\n~~~\n\nIf you would like phpredis to serialize your data using the igbinary library, run configure with `--enable-redis-igbinary`.\nIf you would like to use the msgpack serializer, run configure with `--enable-redis-msgpack` (note:  Requires php-msgpack >= 2.0.3)\nThe extension also may compress data before sending it to Redis server, if you run configure with `--enable-redis-lzf`. If you want to use lzf library pre-installed into your system use `--with-liblzf` configuration option to specify the path where to search files.\n`make install` copies `redis.so` to an appropriate location, but you still need to enable the module in the PHP config file. To do so, either edit your php.ini or add a redis.ini file in `/etc/php5/conf.d` with the following contents: `extension=redis.so`.\n\nYou can generate a debian package for PHP5, accessible from Apache 2 by running `./mkdeb-apache2.sh` or with `dpkg-buildpackage` or `svn-buildpackage`.\n\nThis extension exports a single class, [Redis](./README.md#class-redis) (and [RedisException](./README.md#class-redisexception) used in case of errors). Check out https://github.com/ukko/phpredis-phpdoc for a PHP stub that you can use in your IDE for code completion.\n\n\n# Binary packages\n\nMost distributions provides pre-build binary packages of this extension.\n\n## Windows:\n\nFollow the DLL link on the [https://pecl.php.net/package/redis](https://pecl.php.net/package/redis) page or use [https://windows.php.net/downloads/pecl/releases/redis/](https://windows.php.net/downloads/pecl/releases/redis/)\n\n## Fedora\n\nFedora users can install the package from the official repository.\n\n### Fedora ‚â• 29, Version 5\n\nInstallation of the [php-pecl-redis5](https://packages.fedoraproject.org/pkgs/php-pecl-redis5/php-pecl-redis5/) package:\n\n~~~\ndnf install php-pecl-redis5\n~~~\n\n## RHEL / CentOS\n\nInstallation of the [php-pecl-redis](https://apps.fedoraproject.org/packages/php-pecl-redis) package, from the [EPEL repository](https://fedoraproject.org/wiki/EPEL):\n\n~~~\nyum install php-pecl-redis\n~~~\n\n### openSUSE ‚â• 15.1\n\nInstallation of the [php7-redis](https://software.opensuse.org/package/php7-redis?search_term=php7-redis) package:\n\n~~~\nzypper in php7-redis\n~~~\n\n\n# Installation on OSX\n\nIf the install fails on OSX, type the following commands in your shell before trying again:\n~~~\nMACOSX_DEPLOYMENT_TARGET=10.6\nCFLAGS=\"-arch i386 -arch x86_64 -g -Os -pipe -no-cpp-precomp\"\nCCFLAGS=\"-arch i386 -arch x86_64 -g -Os -pipe\"\nCXXFLAGS=\"-arch i386 -arch x86_64 -g -Os -pipe\"\nLDFLAGS=\"-arch i386 -arch x86_64 -bind_at_load\"\nexport CFLAGS CXXFLAGS LDFLAGS CCFLAGS MACOSX_DEPLOYMENT_TARGET\n~~~\n\nIf that still fails and you are running Zend Server CE, try this right before \"make\": `./configure CFLAGS=\"-arch i386\"`.\n\nTaken from [Compiling phpredis on Zend Server CE/OSX ](http://www.tumblr.com/tagged/phpredis).\n\nSee also: [Install Redis & PHP Extension PHPRedis with Macports](http://www.lecloud.net/post/3378834922/install-redis-php-extension-phpredis-with-macports).\n\nYou can install it using MacPorts:\n\n- [Get macports-php](https://www.macports.org/)\n- `sudo port install php56-redis` (or php53-redis, php54-redis, php55-redis, php70-redis, php71-redis, php72-redis, php73-redis, php74-redis)\n\n# Building on Windows\n\nSee [instructions from @char101](https://github.com/phpredis/phpredis/issues/213#issuecomment-11361242) on how to build phpredis on Windows.\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 3.142578125,
          "content": "-------------------------------------------------------------------- \n                  The PHP License, version 3.01\nCopyright (c) 1999 - 2010 The PHP Group. All rights reserved.\n-------------------------------------------------------------------- \n\nRedistribution and use in source and binary forms, with or without\nmodification, is permitted provided that the following conditions\nare met:\n\n  1. Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n \n  2. Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n     distribution.\n \n  3. The name \"PHP\" must not be used to endorse or promote products\n     derived from this software without prior written permission. For\n     written permission, please contact group@php.net.\n  \n  4. Products derived from this software may not be called \"PHP\", nor\n     may \"PHP\" appear in their name, without prior written permission\n     from group@php.net.  You may indicate that your software works in\n     conjunction with PHP by saying \"Foo for PHP\" instead of calling\n     it \"PHP Foo\" or \"phpfoo\"\n \n  5. The PHP Group may publish revised and/or new versions of the\n     license from time to time. Each version will be given a\n     distinguishing version number.\n     Once covered code has been published under a particular version\n     of the license, you may always continue to use it under the terms\n     of that version. You may also choose to use such covered code\n     under the terms of any subsequent version of the license\n     published by the PHP Group. No one other than the PHP Group has\n     the right to modify the terms applicable to covered code created\n     under this License.\n\n  6. Redistributions of any form whatsoever must retain the following\n     acknowledgment:\n     \"This product includes PHP software, freely available from\n     <http://www.php.net/software/>\".\n\nTHIS SOFTWARE IS PROVIDED BY THE PHP DEVELOPMENT TEAM ``AS IS'' AND \nANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A \nPARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE PHP\nDEVELOPMENT TEAM OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, \nINDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES \n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR \nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\nSTRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\nOF THE POSSIBILITY OF SUCH DAMAGE.\n\n-------------------------------------------------------------------- \n\nThis software consists of voluntary contributions made by many\nindividuals on behalf of the PHP Group.\n\nThe PHP Group can be contacted via Email at group@php.net.\n\nFor more information on the PHP Group and the PHP project, \nplease see <http://www.php.net>.\n\nPHP includes the Zend Engine, freely available at\n<http://www.zend.com>.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 131.046875,
          "content": "# PhpRedis\n\n[![Build Status](https://github.com/phpredis/phpredis/actions/workflows/ci.yml/badge.svg)](https://github.com/phpredis/phpredis/actions/workflows/ci.yml)\n[![Coverity Scan Build Status](https://scan.coverity.com/projects/13205/badge.svg)](https://scan.coverity.com/projects/phpredis-phpredis)\n[![PHP version](https://img.shields.io/badge/php-%3E%3D%207.0-8892BF.svg)](https://github.com/phpredis/phpredis)\n\nThe phpredis extension provides an API for communicating with the [Redis](http://redis.io/) key-value store. It also supports [KeyDB](https://docs.keydb.dev/) and [Valkey](https://valkey.io/), which are open source alternatives to Redis.\n\nIt is released under the [PHP License, version 3.01](http://www.php.net/license/3_01.txt).\n\nYou can send comments, patches, questions [here on github](https://github.com/phpredis/phpredis/issues), to michael.grunder@gmail.com ([Twitter](https://twitter.com/grumi78), <a rel=\"me\" href=\"https://phpc.social/@mgrunder\">Mastodon</a>), p.yatsukhnenko@gmail.com ([@yatsukhnenko](https://twitter.com/yatsukhnenko)), or n.favrefelix@gmail.com ([@yowgi](https://twitter.com/yowgi)).\n\n\n## [API Documentation](https://phpredis.github.io/phpredis)\nThese are a work in progress, but will eventually replace our **ONE README TO RULE THEM ALL** docs.  \n\n## Supporting the project\nPhpRedis will always be free and open source software, but if you or your company has found it useful please consider supporting the project.  Developing a large, complex, and performant library like PhpRedis takes a great deal of time and effort, and support would be appreciated! :heart:\n\nThe best way to support the project is through [GitHub sponsors](https://github.com/sponsors/michael-grunder).  Many of the reward tiers grant access to our [slack channel](https://phpredis.slack.com) where [myself](https://github.com/michael-grunder) and [Pavlo](https://github.com/yatsukhnenko) are regularly available to answer questions.  Additionally this will allow you to provide feedback on which fixes and new features to prioritize.\n\nYou can also make a one-time contribution with [![PayPal](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://www.paypal.me/michaelgrunder/5)\n\n## Sponsors\n<a href=\"https://audiomack.com\"><img src=\"https://styleguide.audiomack.com/assets/dl/inline-orange-large.png\" align=\"center\" alt=\"Audiomack.com\" width=\"150\"></a>\n<a href=\"https://bluehost.com\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/2/22/Bluehost-logo.png\" align=\"center\" alt=\"Bluehost.com\" width=\"150\"></a>\n<a href=\"https://objectcache.pro\"><img src=\"https://objectcache.pro/assets/wordmark-padded.png\" align=\"center\" alt=\"Object Cache Pro\" width=\"150\"></a>\n<a href=\"https://openlms.net\"><img src=\"https://help.openlms.net/wp-content/uploads/2020/05/cropped-open-lms.png\" align=\"center\" alt=\"OpenLMS.net\" width=\"150\"></a>\n\n# Table of contents\n-----\n1. [Installing/Configuring](#installingconfiguring)\n   * [Installation](#installation)\n   * [PHP Session handler](#php-session-handler)\n   * [Distributed Redis Array](./arrays.md#readme)\n   * [Redis Cluster support](./cluster.md#readme)\n   * [Redis Sentinel support](./sentinel.md#readme)\n   * [Running the unit tests](#running-the-unit-tests)\n1. [Classes and methods](#classes-and-methods)\n   * [Usage](#usage)\n   * [Connection](#connection)\n   * [Retry and backoff](#retry-and-backoff)\n   * [Server](#server)\n   * [Keys and strings](#keys-and-strings)\n   * [Hashes](#hashes)\n   * [Lists](#lists)\n   * [Sets](#sets)\n   * [Sorted sets](#sorted-sets)\n   * [HyperLogLogs](#hyperloglogs)\n   * [Geocoding](#geocoding)\n   * [Streams](#streams)\n   * [Pub/sub](#pubsub)\n   * [Transactions](#transactions)\n   * [Scripting](#scripting)\n   * [Introspection](#introspection)\n\n-----\n\n# Installing/Configuring\n-----\n\n## Installation\n\nFor everything you should need to install PhpRedis on your system,\nsee the [INSTALL.md](./INSTALL.md) page.\n\n## PHP Session handler\n\nphpredis can be used to store PHP sessions. To do this, configure `session.save_handler` and `session.save_path` in your php.ini to tell phpredis where to store the sessions.\n\n`session.save_path` can have a simple `host:port` format too, but you need to provide the `tcp://` scheme if you want to use the parameters. The following parameters are available:\n\n* weight (integer): the weight of a host is used in comparison with the others in order to customize the session distribution on several hosts. If host A has twice the weight of host B, it will get twice the amount of sessions. In the example, *host1* stores 20% of all the sessions (1/(1+2+2)) while *host2* and *host3* each store 40% (2/(1+2+2)). The target host is determined once and for all at the start of the session, and doesn't change. The default weight is 1.\n* timeout (float): the connection timeout to a redis host, expressed in seconds. If the host is unreachable in that amount of time, the session storage will be unavailable for the client. The default timeout is very high (86400 seconds).\n* persistent (integer, should be 1 or 0): defines if a persistent connection should be used.\n* prefix (string, defaults to \"PHPREDIS_SESSION:\"): used as a prefix to the Redis key in which the session is stored. The key is composed of the prefix followed by the session ID.\n* auth (string, or an array with one or two elements): used to authenticate with the server prior to sending commands.\n* database (integer): selects a different database.\n\nSessions have a lifetime expressed in seconds and stored in the INI variable \"session.gc_maxlifetime\". You can change it with [`ini_set()`](http://php.net/ini_set).\nThe session handler requires a version of Redis supporting `EX` and `NX` options of `SET` command (at least 2.6.12).\nphpredis can also connect to a unix domain socket: `session.save_path = \"unix:///var/run/redis/redis.sock?persistent=1&weight=1&database=0\"`.\n\n### Examples\n\nMultiple Redis servers:\n~~~\nsession.save_handler = redis\nsession.save_path = \"tcp://host1:6379?weight=1, tcp://host2:6379?weight=2&timeout=2.5, tcp://host3:6379?weight=2&read_timeout=2.5\"\n~~~\n\nLogin to Redis using username and password:\n~~~\nsession.save_handler = redis\nsession.save_path = \"tcp://127.0.0.1:6379?auth[]=user&auth[]=password\"\n~~~\n\nLogin to Redis using username, password, and set prefix:\n~~~\nsession.save_handler = redis\nsession.save_path = \"tcp://127.0.0.1:6379?auth[]=user&auth[]=password&prefix=user_PHPREDIS_SESSION:\"\n~~~\n\n### Session locking\n\n**Support**: Locking feature is currently only supported for Redis setup with single master instance (e.g. classic master/slave Sentinel environment).\nSo locking may not work properly in RedisArray or RedisCluster environments.\n\nFollowing INI variables can be used to configure session locking:\n~~~\n; Should the locking be enabled? Defaults to: 0.\nredis.session.locking_enabled = 1\n; How long should the lock live (in seconds)? Defaults to: value of max_execution_time.\nredis.session.lock_expire = 60\n; How long to wait between attempts to acquire lock, in microseconds (¬µs)?. Defaults to: 20000\nredis.session.lock_wait_time = 50000\n; Maximum number of times to retry (-1 means infinite). Defaults to: 100\nredis.session.lock_retries = 2000\n~~~\n\n### Session compression\n\nFollowing INI variables can be used to configure session compression:\n~~~\n; Should session compression be enabled? Possible values are zstd, lzf, lz4, none. Defaults to: none\nredis.session.compression = zstd\n; What compression level should be used? Compression level depends on used library. For most deployments range 1-9 should be fine. Defaults to: 3\nredis.session.compression_level = 3\n~~~\n\n## Running the unit tests\n\nphpredis uses a small custom unit test suite for testing functionality of the various classes.  To run tests, simply do the following:\n\n~~~\n# Run tests for Redis class (note this is the default)\nphp tests/TestRedis.php --class Redis\n\n# Run tests for RedisArray class\ntests/mkring.sh start\nphp tests/TestRedis.php --class RedisArray\ntests/mkring.sh stop\n\n# Run tests for the RedisCluster class\ntests/make-cluster.sh start\nphp tests/TestRedis.php --class RedisCluster\ntests/make-cluster.sh stop\n\n# Run tests for RedisSentinel class\nphp tests/TestRedis.php --class RedisSentinel\n~~~\n\nNote that it is possible to run only tests which match a substring of the test itself by passing the additional argument '--test <str>' when invoking.\n\n~~~\n# Just run the 'echo' test\nphp tests/TestRedis.php --class Redis --test echo\n~~~\n\n# Classes and methods\n-----\n\n## Usage\n\n1. [Class Redis](#class-redis)\n1. [Class RedisException](#class-redisexception)\n1. [Predefined constants](#predefined-constants)\n\n### Class Redis\n-----\n_**Description**_: Creates a Redis client\n\n##### *Example*\n\n~~~php\n$redis = new Redis();\n~~~\n\nStarting from version 6.0.0 it's possible to specify configuration options.\nThis allows to connect lazily to the server without explicitly invoking `connect` command.\n\n##### *Example*\n\n~~~php\n$redis = new Redis([\n    'host' => '127.0.0.1',\n    'port' => 6379,\n    'connectTimeout' => 2.5,\n    'auth' => ['phpredis', 'phpredis'],\n    'ssl' => ['verify_peer' => false],\n    'backoff' => [\n        'algorithm' => Redis::BACKOFF_ALGORITHM_DECORRELATED_JITTER,\n        'base' => 500,\n        'cap' => 750,\n    ],\n]);\n~~~\n\n##### *Parameters*\n\n*host*: string. can be a host, or the path to a unix domain socket.  \n*port*: int (default is 6379, should be -1 for unix domain socket)  \n*connectTimeout*: float, value in seconds (default is 0 meaning unlimited)  \n*retryInterval*: int, value in milliseconds (optional)  \n*readTimeout*: float, value in seconds (default is 0 meaning unlimited)  \n*persistent*: mixed, if value is string then it used as persistend id, else value casts to boolean  \n*auth*: mixed, authentication information  \n*ssl*: array, SSL context options  \n\n### Class RedisException\n-----\nphpredis throws a [RedisException](#class-redisexception) object if it can't reach the Redis server. That can happen in case of connectivity issues,\nif the Redis service is down, or if the redis host is overloaded. In any other problematic case that does not involve an\nunreachable server (such as a key not existing, an invalid command, etc), phpredis will return `FALSE`.\n\n### Predefined constants\n-----\n_**Description**_: Available Redis Constants\n\nRedis data types, as returned by [type](#type)\n~~~\nRedis::REDIS_STRING - String\nRedis::REDIS_SET - Set\nRedis::REDIS_LIST - List\nRedis::REDIS_ZSET - Sorted set\nRedis::REDIS_HASH - Hash\nRedis::REDIS_NOT_FOUND - Not found / other\n~~~\n\n@TODO: OPT_SERIALIZER, AFTER, BEFORE,...\n\n## Connection\n\n1. [connect, open](#connect-open) - Connect to a server\n1. [pconnect, popen](#pconnect-popen) - Connect to a server (persistent)\n1. [auth](#auth) - Authenticate to the server\n1. [select](#select) - Change the selected database for the current connection\n1. [swapdb](#swapdb) - Swaps two Redis databases\n1. [close](#close) - Close the connection\n1. [setOption](#setoption) - Set client option\n1. [getOption](#getoption) - Get client option\n1. [ping](#ping) - Ping the server\n1. [echo](#echo) - Echo the given string\n\n### connect, open\n-----\n_**Description**_: Connects to a Redis instance.\n\n##### *Parameters*\n\n*host*: string. can be a host, or the path to a unix domain socket. Starting from version 5.0.0 it is possible to specify schema  \n*port*: int, optional  \n*timeout*: float, value in seconds (optional, default is 0 meaning it will use default_socket_timeout)  \n*reserved*: should be '' if retry_interval is specified  \n*retry_interval*: int, value in milliseconds (optional)  \n*read_timeout*: float, value in seconds (optional, default is 0 meaning it will use default_socket_timeout)  \n*others*: array, with PhpRedis >= 5.3.0, it allows setting _auth_ and [_stream_](https://www.php.net/manual/en/context.ssl.php) configuration.  \n\n##### *Return value*\n\n*BOOL*: `TRUE` on success, `FALSE` on error.\n\n##### *Example*\n\n~~~php\n$redis->connect('127.0.0.1', 6379);\n$redis->connect('127.0.0.1'); // port 6379 by default\n$redis->connect('tls://127.0.0.1', 6379); // enable transport level security.\n$redis->connect('tls://127.0.0.1'); // enable transport level security, port 6379 by default.\n$redis->connect('127.0.0.1', 6379, 2.5); // 2.5 sec timeout.\n$redis->connect('/tmp/redis.sock'); // unix domain socket.\n$redis->connect('127.0.0.1', 6379, 1, '', 100); // 1 sec timeout, 100ms delay between reconnection attempts.\n$redis->connect('/tmp/redis.sock', 0, 1.5, NULL, 0, 1.5); // Unix socket with 1.5s timeouts (connect and read)\n\n/* With PhpRedis >= 5.3.0 you can specify authentication and stream information on connect */\n$redis->connect('127.0.0.1', 6379, 1, '', 0, 0, ['auth' => ['phpredis', 'phpredis']]);\n~~~\n\n**Note:** `open` is an alias for `connect` and will be removed in future versions of phpredis.\n\n### pconnect, popen\n-----\n_**Description**_: Connects to a Redis instance or reuse a connection already established with `pconnect`/`popen`.\n\nThe connection will not be closed on end of request until the php process ends.\nSo be prepared for too many open FD's errors (specially on redis server side) when using persistent\nconnections on many servers connecting to one redis server.\n\nAlso more than one persistent connection can be made identified by either host + port + timeout\nor host + persistent_id or unix socket + timeout.\n\nStarting from version 4.2.1, it became possible to use connection pooling by setting INI variable `redis.pconnect.pooling_enabled` to 1.\n\nThis feature is not available in threaded versions. `pconnect` and `popen` then working like their non\npersistent equivalents.\n\n##### *Parameters*\n\n*host*: string. can be a host, or the path to a unix domain socket. Starting from version 5.0.0 it is possible to specify schema  \n*port*: int, optional  \n*timeout*: float, value in seconds (optional, default is 0 meaning it will use default_socket_timeout)  \n*persistent_id*: string. identity for the requested persistent connection  \n*retry_interval*: int, value in milliseconds (optional)  \n*read_timeout*: float, value in seconds (optional, default is 0 meaning it will use default_socket_timeout)  \n\n##### *Return value*\n\n*BOOL*: `TRUE` on success, `FALSE` on error.\n\n##### *Example*\n\n~~~php\n$redis->pconnect('127.0.0.1', 6379);\n$redis->pconnect('127.0.0.1'); // port 6379 by default - same connection like before.\n$redis->pconnect('tls://127.0.0.1', 6379); // enable transport level security.\n$redis->pconnect('tls://127.0.0.1'); // enable transport level security, port 6379 by default.\n$redis->pconnect('127.0.0.1', 6379, 2.5); // 2.5 sec timeout and would be another connection than the two before.\n$redis->pconnect('127.0.0.1', 6379, 2.5, 'x'); // x is sent as persistent_id and would be another connection than the three before.\n$redis->pconnect('/tmp/redis.sock'); // unix domain socket - would be another connection than the four before.\n~~~\n\n**Note:** `popen` is an alias for `pconnect` and will be removed in future versions of phpredis.\n\n### auth\n-----\n_**Description**_: Authenticate the connection using a password or a username and password.\n*Warning*: The password is sent in plain-text over the network.\n\n##### *Parameters*\n*MIXED*: password\n\n##### *Return value*\n*BOOL*: `TRUE` if the connection is authenticated, `FALSE` otherwise.\n\n*Note*: In order to authenticate with a username and password you need Redis >= 6.0.\n\n##### *Example*\n~~~php\n/* Authenticate with the password 'foobared' */\n$redis->auth('foobared');\n\n/* Authenticate with the username 'phpredis', and password 'haxx00r' */\n$redis->auth(['phpredis', 'haxx00r']);\n\n/* Authenticate with the password 'foobared' */\n$redis->auth(['foobared']);\n\n/* You can also use an associative array specifying user and pass */\n$redis->auth(['user' => 'phpredis', 'pass' => 'phpredis']);\n$redis->auth(['pass' => 'phpredis']);\n~~~\n\n### select\n-----\n_**Description**_: Change the selected database for the current connection.\n\n##### *Parameters*\n*INTEGER*: dbindex, the database number to switch to.\n\n##### *Return value*\n`TRUE` in case of success, `FALSE` in case of failure.\n##### *Example*\nSee method for example: [move](#move)\n\n### swapdb\n-----\n_**Description**_:  Swap one Redis database with another atomically  \n\n##### *Parameters*  \n*INTEGER*: db1  \n*INTEGER*: db2  \n\n##### *Return value*  \n`TRUE` on success and `FALSE` on failure.\n\n*Note*: Requires Redis >= 4.0.0\n\n##### *Example*  \n~~~php\n$redis->swapdb(0, 1); /* Swaps DB 0 with DB 1 atomically */\n~~~\n\n### close\n-----\n_**Description**_: Disconnects from the Redis instance.\n\n*Note*: Closing a persistent connection requires PhpRedis >= 4.2.0.\n\n##### *Parameters*\nNone.\n\n##### *Return value*\n*BOOL*: `TRUE` on success, `FALSE` on failure.\n\n### setOption\n-----\n_**Description**_: Set client option.\n\n##### *Parameters*\n*parameter name*  \n*parameter value*\n\n##### *Return value*\n*BOOL*: `TRUE` on success, `FALSE` on error.\n\n##### *Example*\n~~~php\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_NONE);\t  // Don't serialize data\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP);\t  // Use built-in serialize/unserialize\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_IGBINARY); // Use igBinary serialize/unserialize\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_MSGPACK);  // Use msgpack serialize/unserialize\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_JSON);  // Use JSON to serialize/unserialize\n\n$redis->setOption(Redis::OPT_PREFIX, 'myAppName:');\t// use custom prefix on all keys\n\n/* Options for the SCAN family of commands, indicating whether to abstract\n   empty results from the user.  If set to SCAN_NORETRY (the default), phpredis\n   will just issue one SCAN command at a time, sometimes returning an empty\n   array of results.  If set to SCAN_RETRY, phpredis will retry the scan command\n   until keys come back OR Redis returns an iterator of zero\n*/\n$redis->setOption(Redis::OPT_SCAN, Redis::SCAN_NORETRY);\n$redis->setOption(Redis::OPT_SCAN, Redis::SCAN_RETRY);\n\n/* Scan can also be configured to automatically prepend the currently set PhpRedis\n   prefix to any MATCH pattern. */\n$redis->setOption(Redis::OPT_SCAN, Redis::SCAN_PREFIX);\n$redis->setOption(Redis::OPT_SCAN, Redis::SCAN_NOPREFIX);\n~~~\n\n\n### getOption\n-----\n_**Description**_: Get client option.\n\n##### *Parameters*\n*parameter name*\n\n##### *Return value*\nParameter value.\n\n##### *Example*\n~~~php\n// return Redis::SERIALIZER_NONE, Redis::SERIALIZER_PHP, \n//        Redis::SERIALIZER_IGBINARY, Redis::SERIALIZER_MSGPACK or Redis::SERIALIZER_JSON\n$redis->getOption(Redis::OPT_SERIALIZER);\n~~~\n\n### ping\n-----\n_**Description**_: Check the current connection status.\n\n##### *Prototype*\n~~~php\n$redis->ping([string $message]);\n~~~\n\n##### *Return value*\n*Mixed*:  This method returns `TRUE` on success, or the passed string if called with an argument.\n\n##### *Example*\n~~~php\n/* When called without an argument, PING returns `TRUE` */\n$redis->ping();\n\n/* If passed an argument, that argument is returned.  Here 'hello' will be returned */\n$redis->ping('hello');\n~~~\n\n*Note*:  Prior to PhpRedis 5.0.0 this command simply returned the string `+PONG`.\n\n### echo\n-----\n_**Description**_: Sends a string to Redis, which replies with the same string\n\n##### *Parameters*\n\n*STRING*: The message to send.\n\n##### *Return value*\n\n*STRING*: the same message.\n\n## Retry and backoff\n\n1. [Maximum retries](#maximum-retries)\n1. [Backoff algorithms](#backoff-algorithms)\n\n### Maximum retries\nYou can set and get the maximum retries upon connection issues using the `OPT_MAX_RETRIES` option. Note that this is the number of _retries_, meaning if you set this option to _n_, there will be a maximum _n+1_ attempts overall. Defaults to 10.\n\n##### *Example*\n\n~~~php\n$redis->setOption(Redis::OPT_MAX_RETRIES, 5);\n$redis->getOption(Redis::OPT_MAX_RETRIES);\n~~~\n\n### Backoff algorithms\nYou can set the backoff algorithm using the `Redis::OPT_BACKOFF_ALGORITHM` option and choose among the following algorithms described in this blog post by Marc Brooker from AWS: [Exponential Backoff And Jitter](https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter):\n\n* Default: `Redis::BACKOFF_ALGORITHM_DEFAULT`\n* Decorrelated jitter: `Redis::BACKOFF_ALGORITHM_DECORRELATED_JITTER`\n* Full jitter: `Redis::BACKOFF_ALGORITHM_FULL_JITTER`\n* Equal jitter: `Redis::BACKOFF_ALGORITHM_EQUAL_JITTER`\n* Exponential: `Redis::BACKOFF_ALGORITHM_EXPONENTIAL`\n* Uniform: `Redis::BACKOFF_ALGORITHM_UNIFORM`\n* Constant: `Redis::BACKOFF_ALGORITHM_CONSTANT`\n\nThese algorithms depend on the _base_ and _cap_ parameters, both in milliseconds, which you can set using the `Redis::OPT_BACKOFF_BASE` and `Redis::OPT_BACKOFF_CAP` options, respectively.\n\n##### *Example*\n\n~~~php\n$redis->setOption(Redis::OPT_BACKOFF_ALGORITHM, Redis::BACKOFF_ALGORITHM_DECORRELATED_JITTER);\n$redis->setOption(Redis::OPT_BACKOFF_BASE, 500); // base for backoff computation: 500ms\n$redis->setOption(Redis::OPT_BACKOFF_CAP, 750); // backoff time capped at 750ms\n~~~\n\n## Server\n\n1. [acl](#acl) - Manage Redis ACLs\n1. [bgRewriteAOF](#bgrewriteaof) - Asynchronously rewrite the append-only file\n1. [bgSave](#bgsave) - Asynchronously save the dataset to disk (in background)\n1. [config](#config) - Get or Set the Redis server configuration parameters\n1. [dbSize](#dbsize) - Return the number of keys in selected database\n1. [flushAll](#flushall) - Remove all keys from all databases\n1. [flushDb](#flushdb) - Remove all keys from the current database\n1. [info](#info) - Get information and statistics about the server\n1. [lastSave](#lastsave) - Get the timestamp of the last disk save\n1. [save](#save) - Synchronously save the dataset to disk (wait to complete)\n1. [slaveOf](#slaveof) - Make the server a slave of another instance, or promote it to master\n1. [time](#time) - Return the current server time\n1. [slowLog](#slowlog) - Access the Redis slowLog entries\n\n### acl\n-----\n_**Description**_: Execute the Redis ACL command.\n\n##### *Parameters*\n_variable_:  Minimum of one argument for `Redis` and two for `RedisCluster`.\n\n##### *Example*\n~~~php\n$redis->acl('USERS'); /* Get a list of users */\n$redis->acl('LOG');   /* See log of Redis' ACL subsystem */\n~~~\n\n*Note*:  In order to user the `ACL` command you must be communicating with Redis >= 6.0 and be logged into an account that has access to administration commands such as ACL.  Please reference [this tutorial](https://redis.io/topics/acl) for an overview of Redis 6 ACLs and [the redis command reference](https://redis.io/commands) for every ACL subcommand.\n\n*Note*: If you are connecting to Redis server >= 4.0.0 you can remove a key with the `unlink` method in the exact same way you would use `del`.  The Redis [unlink](https://redis.io/commands/unlink) command is non-blocking and will perform the actual deletion asynchronously.\n\n### bgRewriteAOF\n-----\n_**Description**_: Start the background rewrite of AOF (Append-Only File)\n\n##### *Parameters*\nNone.\n\n##### *Return value*\n*BOOL*: `TRUE` in case of success, `FALSE` in case of failure.\n\n##### *Example*\n~~~php\n$redis->bgRewriteAOF();\n~~~\n\n### bgSave\n-----\n_**Description**_: Asynchronously save the dataset to disk (in background)\n\n##### *Parameters*\nNone.\n\n##### *Return value*\n*BOOL*: `TRUE` in case of success, `FALSE` in case of failure. If a save is already running, this command will fail and return `FALSE`.\n\n##### *Example*\n~~~php\n$redis->bgSave();\n~~~\n\n### config\n-----\n_**Description**_: Get or Set the Redis server configuration parameters.\n\n##### *Prototype*\n~~~php\n$redis->config(string $operation, string|array|null $key = NULL, ?string $value = NULL): mixed;\n~~~\n\n##### *Return value*\n*Associative array* for `GET`, key(s) -> value(s)  \n*bool* for `SET`, `RESETSTAT`, and `REWRITE`\n\n##### *Examples*\n~~~php\n$redis->config(\"GET\", \"*max-*-entries*\");\n$redis->config(\"SET\", ['timeout', 'loglevel']);\n$redis->config(\"SET\", \"dir\", \"/var/run/redis/dumps/\");\n$redis->config(\"SET\", ['timeout' => 128, 'loglevel' => 'warning']);\n$redis->config('RESETSTAT');\n~~~\n\n### dbSize\n-----\n_**Description**_: Return the number of keys in selected database.\n\n##### *Parameters*\nNone.\n\n##### *Return value*\n*INTEGER*: DB size, in number of keys.\n\n##### *Example*\n~~~php\n$count = $redis->dbSize();\necho \"Redis has $count keys\\n\";\n~~~\n\n### flushAll\n-----\n_**Description**_: Remove all keys from all databases.\n\n##### *Parameters*\n*async* (bool) requires server version 4.0.0 or greater\n\n##### *Return value*\n*BOOL*: Always `TRUE`.\n\n##### *Example*\n~~~php\n$redis->flushAll();\n~~~\n\n### flushDb\n-----\n_**Description**_: Remove all keys from the current database.\n\n##### *Prototype*\n~~~php\n$redis->flushdb(?bool $sync = NULL): Redis|bool;\n~~~\n\n##### *Return value*\n*BOOL*:  This command returns true on success and false on failure.\n\n##### *Example*\n~~~php\n$redis->flushDb();\n~~~\n\n### info\n-----\n_**Description**_: Get information and statistics about the server\n\nReturns an associative array that provides information about the server. Passing no arguments to\nINFO will call the standard REDIS INFO command, which returns information such as the following:\n\n* redis_version\n* arch_bits\n* uptime_in_seconds\n* uptime_in_days\n* connected_clients\n* connected_slaves\n* used_memory\n* changes_since_last_save\n* bgsave_in_progress\n* last_save_time\n* total_connections_received\n* total_commands_processed\n* role\n\nYou can pass a variety of options to INFO ([per the Redis documentation](http://redis.io/commands/info)),\nwhich will modify what is returned.\n\n##### *Parameters*\n*option*: The option to provide redis (e.g. \"COMMANDSTATS\", \"CPU\")\n\n##### *Example*\n~~~php\n$redis->info(); /* standard redis INFO command */\n$redis->info(\"COMMANDSTATS\"); /* Information on the commands that have been run (>=2.6 only)\n$redis->info(\"CPU\"); /* just CPU information from Redis INFO */\n~~~\n\n### lastSave\n-----\n_**Description**_: Returns the timestamp of the last disk save.\n\n##### *Parameters*\nNone.\n\n##### *Return value*\n*INT*: timestamp.\n\n##### *Example*\n~~~php\n$redis->lastSave();\n~~~\n\n### save\n-----\n_**Description**_: Synchronously save the dataset to disk (wait to complete)\n\n##### *Parameters*\nNone.\n\n##### *Return value*\n*BOOL*: `TRUE` in case of success, `FALSE` in case of failure. If a save is already running, this command will fail and return `FALSE`.\n\n##### *Example*\n~~~php\n$redis->save();\n~~~\n\n### slaveOf\n-----\n_**Description**_: Changes the slave status\n\n##### *Parameters*\nEither host (string) and port (int), or no parameter to stop being a slave.\n\n##### *Return value*\n*BOOL*: `TRUE` in case of success, `FALSE` in case of failure.\n\n##### *Example*\n~~~php\n$redis->slaveOf('10.0.1.7', 6379);\n/* ... */\n$redis->slaveOf();\n~~~\n\n### time\n-----\n_**Description**_: Return the current server time.\n\n##### *Parameters*\n(none)\n\n##### *Return value*\nIf successful, the time will come back as an associative array with element zero being\nthe unix timestamp, and element one being microseconds.\n\n##### *Examples*\n~~~php\n$redis->time();\n~~~\n\n### slowLog\n-----\n_**Description**_: Access the Redis slowLog\n\n##### *Parameters*\n*Operation* (string): This can be either `GET`, `LEN`, or `RESET`  \n*Length* (integer), optional: If executing a `SLOWLOG GET` command, you can pass an optional length.\n#####\n\n##### *Return value*\nThe return value of SLOWLOG will depend on which operation was performed.\nSLOWLOG GET: Array of slowLog entries, as provided by Redis\nSLOGLOG LEN: Integer, the length of the slowLog\nSLOWLOG RESET: Boolean, depending on success\n#####\n\n##### *Examples*\n~~~php\n// Get ten slowLog entries\n$redis->slowLog('get', 10);\n// Get the default number of slowLog entries\n\n$redis->slowLog('get');\n// Reset our slowLog\n$redis->slowLog('reset');\n\n// Retrieve slowLog length\n$redis->slowLog('len');\n~~~\n\n## Keys and Strings\n\n### Strings\n-----\n\n* [append](#append) - Append a value to a key\n* [bitCount](#bitcount) - Count set bits in a string\n* [bitOp](#bitop) - Perform bitwise operations between strings\n* [decr, decrBy](#decr-decrby) - Decrement the value of a key\n* [get](#get) - Get the value of a key\n* [getEx](#getex) - Get the value of a key and set its expiration\n* [getBit](#getbit) - Returns the bit value at offset in the string value stored at key\n* [getRange](#getrange) - Get a substring of the string stored at a key\n* [getSet](#getset) - Set the string value of a key and return its old value\n* [incr, incrBy](#incr-incrby) - Increment the value of a key\n* [incrByFloat](#incrbyfloat) - Increment the float value of a key by the given amount\n* [mGet](#mget) - Get the values of all the given keys\n* [mSet, mSetNX](#mset-msetnx) - Set multiple keys to multiple values\n* [set](#set) - Set the string value of a key\n* [setBit](#setbit) - Sets or clears the bit at offset in the string value stored at key\n* [setEx, pSetEx](#setex-psetex) - Set the value and expiration of a key\n* [setNx](#setnx) - Set the value of a key, only if the key does not exist\n* [setRange](#setrange) - Overwrite part of a string at key starting at the specified offset\n* [strLen](#strlen) - Get the length of the value stored in a key\n\n### Keys\n-----\n\n* [del, delete, unlink](#del-delete-unlink) - Delete a key\n* [dump](#dump) - Return a serialized version of the value stored at the specified key.\n* [exists](#exists) - Determine if a key exists\n* [expire, pexpire](#expire-pexpire) - Set a key's time to live in seconds\n* [expireAt, pexpireAt](#expireat-pexpireat) - Set the expiration for a key as a UNIX timestamp\n* [keys](#keys) - Find all keys matching the given pattern\n* [scan](#scan) - Scan for keys in the keyspace (Redis >= 2.8.0)\n* [migrate](#migrate) - Atomically transfer a key from a Redis instance to another one\n* [move](#move) - Move a key to another database\n* [object](#object) - Inspect the internals of Redis objects\n* [persist](#persist) - Remove the expiration from a key\n* [randomKey](#randomkey) - Return a random key from the keyspace\n* [rename](#rename) - Rename a key\n* [renameNx](#renamenx) - Rename a key, only if the new key does not exist\n* [type](#type) - Determine the type stored at key\n* [sort](#sort) - Sort the elements in a list, set or sorted set\n* [ttl, pttl](#ttl-pttl) - Get the time to live for a key\n* [restore](#restore) - Create a key using the provided serialized value, previously obtained with [dump](#dump).\n\n-----\n\n### get\n-----\n_**Description**_: Get the value related to the specified key\n\n##### *Parameters*\n*key*\n\n##### *Return value*\n*String* or *Bool*: If key didn't exist, `FALSE` is returned. Otherwise, the value related to this key is returned.\n\n##### *Examples*\n\n~~~php\n$redis->get('key');\n~~~\n\n### getEx\n-----\n_**Description**_: Get the value related to the specified key and set its expiration\n\n##### *Parameters*\n*key* \n*options array* (optional) with the following keys:\n  * `EX` - expire time in seconds\n  * `PX` - expire time in milliseconds\n  * `EXAT` - expire time in seconds since UNIX epoch\n  * `PXAT` - expire time in milliseconds since UNIX epoch\n  * `PERSIST` - remove the expiration from the key\n\n##### *Return value*\n*String* or *Bool*: If key didn't exist, `FALSE` is returned. Otherwise, the value related to this key is returned.\n\n##### *Examples*\n\n~~~php\n$redis->getEx('key', ['EX' => 10]); // get key and set its expiration to 10 seconds\n~~~\n\n### set\n-----\n_**Description**_: Set the string value in argument as value of the key.  If you're using Redis >= 2.6.12, you can pass extended options as explained below\n\n##### *Parameters*\n*Key*  \n*Value*  \n*Timeout or Options Array* (optional). If you pass an integer, phpredis will redirect to SETEX, and will try to use Redis >= 2.6.12 extended options if you pass an array with valid values\n\n##### *Return value*\n*Bool* `TRUE` if the command is successful.\n\n##### *Examples*\n~~~php\n// Simple key -> value set\n$redis->set('key', 'value');\n\n// Will redirect, and actually make an SETEX call\n$redis->set('key','value', 10);\n\n// Will set the key, if it doesn't exist, with a ttl of 10 seconds\n$redis->set('key', 'value', ['nx', 'ex'=>10]);\n\n// Will set a key, if it does exist, with a ttl of 1000 milliseconds\n$redis->set('key', 'value', ['xx', 'px'=>1000]);\n\n~~~\n\n### setEx, pSetEx\n-----\n_**Description**_: Set the string value in argument as value of the key, with a time to live. PSETEX uses a TTL in milliseconds.\n\n##### *Parameters*\n*Key*\n*TTL*\n*Value*\n\n##### *Return value*\n*Bool* `TRUE` if the command is successful.\n\n##### *Examples*\n\n~~~php\n$redis->setEx('key', 3600, 'value'); // sets key ‚Üí value, with 1h TTL.\n$redis->pSetEx('key', 100, 'value'); // sets key ‚Üí value, with 0.1 sec TTL.\n~~~\n\n### setNx\n-----\n_**Description**_: Set the string value in argument as value of the key if the key doesn't already exist in the database.\n\n##### *Parameters*\n*key*\n*value*\n\n##### *Return value*\n*Bool* `TRUE` in case of success, `FALSE` in case of failure.\n\n##### *Examples*\n~~~php\n$redis->setNx('key', 'value'); /* return TRUE */\n$redis->setNx('key', 'value'); /* return FALSE */\n~~~\n\n### del, delete, unlink\n-----\n_**Description**_: Remove specified keys.\n\n##### *Parameters*\nAn array of keys, or an undefined number of parameters, each a key: *key1* *key2* *key3* ... *keyN*\n\n*Note*: If you are connecting to Redis server >= 4.0.0 you can remove a key with the `unlink` method in the exact same way you would use `del`.  The Redis [unlink](https://redis.io/commands/unlink) command is non-blocking and will perform the actual deletion asynchronously.\n\n##### *Return value*\n*Long* Number of keys deleted.\n\n##### *Examples*\n~~~php\n$redis->set('key1', 'val1');\n$redis->set('key2', 'val2');\n$redis->set('key3', 'val3');\n$redis->set('key4', 'val4');\n\n$redis->del('key1', 'key2'); /* return 2 */\n$redis->del(['key3', 'key4']); /* return 2 */\n\n/* If using Redis >= 4.0.0 you can call unlink */\n$redis->unlink('key1', 'key2');\n$redis->unlink(['key1', 'key2']);\n~~~\n\n**Note:** `delete` is an alias for `del` and will be removed in future versions of phpredis.\n\n### exists\n-----\n_**Description**_: Verify if the specified key exists.\n\n##### *Parameters*\n*key*\n\n##### *Return value*\n*long*: The number of keys tested that do exist.\n\n##### *Examples*\n~~~php\n$redis->set('key', 'value');\n$redis->exists('key'); /* 1 */\n$redis->exists('NonExistingKey'); /* 0 */\n\n$redis->mset(['foo' => 'foo', 'bar' => 'bar', 'baz' => 'baz']);\n$redis->exists(['foo', 'bar', 'baz']); /* 3 */\n$redis->exists('foo', 'bar', 'baz'); /* 3 */\n~~~\n\n**Note**: This function took a single argument and returned TRUE or FALSE in phpredis versions < 4.0.0.\n\n### incr, incrBy\n-----\n_**Description**_: Increment the number stored at key by one. If the second argument is filled, it will be used as the integer value of the increment.\n\n##### *Parameters*\n*key*  \n*value*: value that will be added to key (only for incrBy)\n\n##### *Return value*\n*INT* the new value\n\n##### *Examples*\n~~~php\n$redis->incr('key1'); /* key1 didn't exists, set to 0 before the increment */\n\t\t\t\t\t  /* and now has the value 1  */\n\n$redis->incr('key1'); /* 2 */\n$redis->incr('key1'); /* 3 */\n$redis->incr('key1'); /* 4 */\n\n// Will redirect, and actually make an INCRBY call\n$redis->incr('key1', 10);   /* 14 */\n\n$redis->incrBy('key1', 10); /* 24 */\n~~~\n\n### incrByFloat\n-----\n_**Description**_: Increment the key with floating point precision.\n\n##### *Parameters*\n*key*  \n*value*: (float) value that will be added to the key\n\n##### *Return value*\n*FLOAT* the new value\n\n##### *Examples*\n~~~php\n$redis->incrByFloat('key1', 1.5); /* key1 didn't exist, so it will now be 1.5 */\n\n\n$redis->incrByFloat('key1', 1.5); /* 3 */\n$redis->incrByFloat('key1', -1.5); /* 1.5 */\n$redis->incrByFloat('key1', 2.5); /* 4 */\n~~~\n\n### decr, decrBy\n-----\n_**Description**_: Decrement the number stored at key by one. If the second argument is filled, it will be used as the integer value of the decrement.\n\n##### *Parameters*\n*key*  \n*value*: value that will be subtracted to key (only for decrBy)\n\n##### *Return value*\n*INT* the new value\n\n##### *Examples*\n~~~php\n$redis->decr('key1'); /* key1 didn't exists, set to 0 before the increment */\n\t\t\t\t\t  /* and now has the value -1  */\n\n$redis->decr('key1'); /* -2 */\n$redis->decr('key1'); /* -3 */\n\n// Will redirect, and actually make an DECRBY call\n$redis->decr('key1', 10);   /* -13 */\n\n$redis->decrBy('key1', 10); /* -23 */\n~~~\n\n### mGet\n-----\n_**Description**_: Get the values of all the specified keys. If one or more keys don't exist, the array will contain `FALSE` at the position of the key.\n\n##### *Parameters*\n*Array*: Array containing the list of the keys\n\n##### *Return value*\n*Array*: Array containing the values related to keys in argument\n\n##### *Examples*\n~~~php\n$redis->set('key1', 'value1');\n$redis->set('key2', 'value2');\n$redis->set('key3', 'value3');\n$redis->mGet(['key1', 'key2', 'key3']); /* ['value1', 'value2', 'value3'];\n$redis->mGet(['key0', 'key1', 'key5']); /* [`FALSE`, 'value1', `FALSE`];\n~~~\n\n### getSet\n-----\n_**Description**_: Sets a value and returns the previous entry at that key.\n##### *Parameters*\n*Key*: key\n\n*STRING*: value\n\n##### *Return value*\nA string, the previous value located at this key.\n##### *Example*\n~~~php\n$redis->set('x', '42');\n$exValue = $redis->getSet('x', 'lol');\t// return '42', replaces x by 'lol'\n$newValue = $redis->get('x')'\t\t// return 'lol'\n~~~\n\n### randomKey\n-----\n_**Description**_: Returns a random key.\n\n##### *Parameters*\nNone.\n##### *Return value*\n*STRING*: an existing key in redis.\n\n##### *Example*\n~~~php\n$key = $redis->randomKey();\n$surprise = $redis->get($key);\t// who knows what's in there.\n~~~\n\n### move\n-----\n_**Description**_: Moves a key to a different database.\n\n##### *Parameters*\n*Key*: key, the key to move.\n\n*INTEGER*: dbindex, the database number to move the key to.\n\n##### *Return value*\n*BOOL*: `TRUE` in case of success, `FALSE` in case of failure.\n##### *Example*\n\n~~~php\n$redis->select(0);\t// switch to DB 0\n$redis->set('x', '42');\t// write 42 to x\n$redis->move('x', 1);\t// move to DB 1\n$redis->select(1);\t// switch to DB 1\n$redis->get('x');\t// will return 42\n~~~\n\n### rename\n-----\n_**Description**_: Renames a key.\n##### *Parameters*\n*STRING*: srckey, the key to rename.\n\n*STRING*: dstkey, the new name for the key.\n\n##### *Return value*\n*BOOL*: `TRUE` in case of success, `FALSE` in case of failure.\n##### *Example*\n~~~php\n$redis->set('x', '42');\n$redis->rename('x', 'y');\n$redis->get('y'); \t// ‚Üí 42\n$redis->get('x'); \t// ‚Üí `FALSE`\n~~~\n\n### renameNx\n-----\n_**Description**_: Same as rename, but will not replace a key if the destination already exists. This is the same behaviour as setNx.\n\n### expire, pexpire\n-----\n_**Description**_: Sets an expiration on a key in either seconds or milliseconds.\n\n##### *Prototype*\n~~~php\npublic function expire(string $key, int $seconds, ?string $mode = NULL): Redis|bool;\npublic function pexpire(string $key, int $milliseconds, ?string $mode = NULL): Redis|bool;\n~~~\n\n##### *Return value*\n*BOOL*: `TRUE` if an expiration was set, and `FALSE` on failure or if one was not set.  You can distinguish between an error and an expiration not being set by checking `getLastError()`.\n##### *Example*\n~~~php\n$redis->set('x', '42');\n$redis->expire('x', 3);\t// x will disappear in 3 seconds.\nsleep(5);\t\t\t\t// wait 5 seconds\n$redis->get('x'); \t\t// will return `FALSE`, as 'x' has expired.\n~~~\n\n### expireAt, pexpireAt\n-----\n_**Description**_: Seta specific timestamp for a key to expire in seconds or milliseconds.\n\n##### *Prototype*\n~~~php\npublic function expireat(string $key, int $unix_timestamp, ?string $mode = NULL): Redis|bool;\npublic function pexpireat(string $key, int $unix_timestamp_millis, ?string $mode = NULL): Redis|bool;\n~~~\n\n##### *Return value*\n*BOOL*: `TRUE` if an expiration was set and `FALSE` if one was not set or in the event on an error.  You can detect an actual error by checking `getLastError()`.\n\n##### *Example*\n~~~php\n$redis->set('x', '42');\n$redis->expireAt('x', time(NULL) + 3); // x will disappear in 3 seconds.\nsleep(5);\t\t\t\t// wait 5 seconds\n$redis->get('x'); \t// will return `FALSE`, as 'x' has expired.\n~~~\n\n### keys\n-----\n_**Description**_: Returns the keys that match a certain pattern.\n\n##### *Parameters*\n*STRING*: pattern, using '*' as a wildcard.\n\n##### *Return value*\n*Array of STRING*: The keys that match a certain pattern.\n\n##### *Example*\n~~~php\n$allKeys = $redis->keys('*');\t// all keys will match this.\n$keyWithUserPrefix = $redis->keys('user*');\n~~~\n\n### scan\n-----\n_**Description**_:  Scan the keyspace for keys\n\n##### *Parameters*\n*LONG (reference)*:  Iterator, initialized to NULL\n*STRING, Optional*:  Pattern to match\n*LONG, Optional*: Count of keys per iteration (only a suggestion to Redis)\n\n##### *Return value*\n*Array, boolean*:  This function will return an array of keys or FALSE if Redis returned zero keys\n\n*Note*: SCAN is a \"directed node\" command in [RedisCluster](cluster.md#directed-node-commands)\n\n##### *Example*\n~~~php\n\n/* Without enabling Redis::SCAN_RETRY (default condition) */\n$it = NULL;\ndo {\n    // Scan for some keys\n    $arr_keys = $redis->scan($it);\n\n    // Redis may return empty results, so protect against that\n    if ($arr_keys !== FALSE) {\n        foreach($arr_keys as $str_key) {\n            echo \"Here is a key: $str_key\\n\";\n        }\n    }\n} while ($it > 0);\necho \"No more keys to scan!\\n\";\n\n/* With Redis::SCAN_RETRY enabled */\n$redis->setOption(Redis::OPT_SCAN, Redis::SCAN_RETRY);\n$it = NULL;\n\n/* phpredis will retry the SCAN command if empty results are returned from the\n   server, so no empty results check is required. */\nwhile ($arr_keys = $redis->scan($it)) {\n    foreach ($arr_keys as $str_key) {\n        echo \"Here is a key: $str_key\\n\";\n    }\n}\necho \"No more keys to scan!\\n\";\n~~~\n\n### object\n-----\n_**Description**_: Describes the object pointed to by a key.\n\n##### *Parameters*\nThe information to retrieve (string) and the key (string). Info can be one of the following:\n\n* \"encoding\"\n* \"refcount\"\n* \"idletime\"\n\n##### *Return value*\n*STRING* for \"encoding\", *LONG* for \"refcount\" and \"idletime\", `FALSE` if the key doesn't exist.\n\n##### *Example*\n~~~php\n$redis->object(\"encoding\", \"l\"); // ‚Üí ziplist\n$redis->object(\"refcount\", \"l\"); // ‚Üí 1\n$redis->object(\"idletime\", \"l\"); // ‚Üí 400 (in seconds, with a precision of 10 seconds).\n~~~\n\n### type\n-----\n_**Description**_: Returns the type of data pointed by a given key.\n\n##### *Parameters*\n*Key*: key\n\n##### *Return value*\n\nDepending on the type of the data pointed by the key, this method will return the following value:  \nstring: Redis::REDIS_STRING  \nset: Redis::REDIS_SET  \nlist: Redis::REDIS_LIST  \nzset: Redis::REDIS_ZSET  \nhash: Redis::REDIS_HASH  \nother: Redis::REDIS_NOT_FOUND\n\n##### *Example*\n~~~php\n$redis->type('key');\n~~~\n\n### append\n-----\n_**Description**_: Append specified string to the string stored in specified key.\n\n##### *Parameters*\n*Key*\n*Value*\n\n##### *Return value*\n*INTEGER*: Size of the value after the append\n\n##### *Example*\n~~~php\n$redis->set('key', 'value1');\n$redis->append('key', 'value2'); /* 12 */\n$redis->get('key'); /* 'value1value2' */\n~~~\n\n### getRange\n-----\n_**Description**_: Return a substring of a larger string\n\n##### *Parameters*\n*key*  \n*start*  \n*end*\n\n##### *Return value*\n*STRING*: the substring\n\n##### *Example*\n~~~php\n$redis->set('key', 'string value');\n$redis->getRange('key', 0, 5); /* 'string' */\n$redis->getRange('key', -5, -1); /* 'value' */\n~~~\n\n### setRange\n-----\n_**Description**_: Changes a substring of a larger string.\n\n##### *Parameters*\n*key*\n*offset*\n*value*\n\n##### *Return value*\n*STRING*: the length of the string after it was modified.\n\n##### *Example*\n~~~php\n$redis->set('key', 'Hello world');\n$redis->setRange('key', 6, \"redis\"); /* returns 11 */\n$redis->get('key'); /* \"Hello redis\" */\n~~~\n\n### strLen\n-----\n_**Description**_: Get the length of a string value.\n\n##### *Parameters*\n*key*\n\n##### *Return value*\n*INTEGER*\n\n##### *Example*\n~~~php\n$redis->set('key', 'value');\n$redis->strlen('key'); /* 5 */\n~~~\n\n### getBit\n-----\n_**Description**_: Return a single bit out of a larger string\n\n##### *Parameters*\n*key*  \n*offset*\n\n##### *Return value*\n*LONG*: the bit value (0 or 1)\n\n##### *Example*\n~~~php\n$redis->set('key', \"\\x7f\"); // this is 0111 1111\n$redis->getBit('key', 0); /* 0 */\n$redis->getBit('key', 1); /* 1 */\n~~~\n\n### setBit\n-----\n_**Description**_: Changes a single bit of a string.\n\n##### *Parameters*\n*key*  \n*offset*  \n*value*: bool or int (1 or 0)\n\n##### *Return value*\n*LONG*: 0 or 1, the value of the bit before it was set.\n\n##### *Example*\n~~~php\n$redis->set('key', \"*\");\t// ord(\"*\") = 42 = 0x2f = \"0010 1010\"\n$redis->setBit('key', 5, 1); /* returns 0 */\n$redis->setBit('key', 7, 1); /* returns 0 */\n$redis->get('key'); /* chr(0x2f) = \"/\" = b(\"0010 1111\") */\n~~~\n\n### bitOp\n-----\n_**Description**_: Bitwise operation on multiple keys.\n\n##### *Parameters*\n*operation*: either \"AND\", \"OR\", \"NOT\", \"XOR\"  \n*ret_key*: return key  \n*key1*  \n*key2...*\n\n##### *Return value*\n*LONG*: The size of the string stored in the destination key.\n\n### bitCount\n-----\n_**Description**_: Count bits in a string.\n\n##### *Parameters*\n*key*\n\n##### *Return value*\n*LONG*: The number of bits set to 1 in the value behind the input key.\n\n### sort\n-----\n_**Description**_: Sort the elements in a list, set or sorted set.\n\n##### *Parameters*\n*Key*: key\n*Options*: [key => value, ...] - optional, with the following keys and values:\n~~~\n    'by' => 'some_pattern_*',\n    'limit' => [0, 1],\n    'get' => 'some_other_pattern_*' or an array of patterns,\n    'sort' => 'asc' or 'desc',\n    'alpha' => TRUE,\n    'store' => 'external-key'\n~~~\n##### *Return value*\nAn array of values, or a number corresponding to the number of elements stored if that was used.\n\n##### *Example*\n~~~php\n$redis->del('s');\n$redis->sAdd('s', 5);\n$redis->sAdd('s', 4);\n$redis->sAdd('s', 2);\n$redis->sAdd('s', 1);\n$redis->sAdd('s', 3);\n\nvar_dump($redis->sort('s')); // 1,2,3,4,5\nvar_dump($redis->sort('s', ['sort' => 'desc'])); // 5,4,3,2,1\nvar_dump($redis->sort('s', ['sort' => 'desc', 'store' => 'out'])); // (int)5\n~~~\n\n\n\n\n### ttl, pttl\n-----\n_**Description**_: Returns the time to live left for a given key in seconds (ttl), or milliseconds (pttl).\n\n##### *Parameters*\n*Key*: key\n\n##### *Return value*\n*LONG*:  The time to live in seconds.  If the key has no ttl, `-1` will be returned, and `-2` if the key doesn't exist.\n\n##### *Example*\n~~~php\n$redis->ttl('key');\n~~~\n\n### persist\n-----\n_**Description**_: Remove the expiration timer from a key.\n\n##### *Parameters*\n*Key*: key\n\n##### *Return value*\n*BOOL*: `TRUE` if a timeout was removed, `FALSE` if the key didn‚Äôt exist or didn‚Äôt have an expiration timer.\n\n##### *Example*\n~~~php\n$redis->persist('key');\n~~~\n\n### mSet, mSetNx\n-----\n_**Description**_: Sets multiple key-value pairs in one atomic command. MSETNX only returns TRUE if all the keys were set (see SETNX).\n\n##### *Parameters*\n*Pairs*: [key => value, ...]\n\n##### *Return value*\n*Bool* `TRUE` in case of success, `FALSE` in case of failure.\n\n##### *Example*\n~~~php\n\n$redis->mSet(['key0' => 'value0', 'key1' => 'value1']);\nvar_dump($redis->get('key0'));\nvar_dump($redis->get('key1'));\n\n~~~\nOutput:\n~~~\nstring(6) \"value0\"\nstring(6) \"value1\"\n~~~\n\n\n\n### dump\n-----\n_**Description**_: Dump a key out of a redis database, the value of which can later be passed into redis using the RESTORE command.  The data\nthat comes out of DUMP is a binary representation of the key as Redis stores it.\n##### *Parameters*\n*key* string\n##### *Return value*\nThe Redis encoded value of the key, or FALSE if the key doesn't exist\n##### *Examples*\n~~~php\n$redis->set('foo', 'bar');\n$val = $redis->dump('foo'); // $val will be the Redis encoded key value\n~~~\n\n### restore\n-----\n_**Description**_: Restore a key from the result of a DUMP operation.\n##### *Parameters*\n*key* string.  The key name  \n*ttl* integer.  How long the key should live (if zero, no expire will be set on the key)  \n*value* string (binary).  The Redis encoded key value (from DUMP)\n##### *Examples*\n~~~php\n$redis->set('foo', 'bar');\n$val = $redis->dump('foo');\n$redis->restore('bar', 0, $val); // The key 'bar', will now be equal to the key 'foo'\n~~~\n\n### migrate\n-----\n_**Description**_: Migrates a key to a different Redis instance.\n\n**Note:**: Redis introduced migrating multiple keys in 3.0.6, so you must have at least\nthat version in order to call `migrate` with an array of keys.\n\n##### *Parameters*\n*host* string.  The destination host  \n*port* integer.  The TCP port to connect to.  \n*key(s)* string or array.  \n*destination-db* integer.  The target DB.  \n*timeout* integer.  The maximum amount of time given to this transfer.  \n*copy* boolean, optional.  Should we send the COPY flag to redis.  \n*replace* boolean, optional.  Should we send the REPLACE flag to redis  \n##### *Examples*\n~~~php\n$redis->migrate('backup', 6379, 'foo', 0, 3600);\n$redis->migrate('backup', 6379, 'foo', 0, 3600, true, true); /* copy and replace */\n$redis->migrate('backup', 6379, 'foo', 0, 3600, false, true); /* just REPLACE flag */\n\n/* Migrate multiple keys (requires Redis >= 3.0.6)\n$redis->migrate('backup', 6379, ['key1', 'key2', 'key3'], 0, 3600);\n~~~\n\n\n\n## Hashes\n\n* [hDel](#hdel) - Delete one or more hash fields\n* [hExists](#hexists) - Determine if a hash field exists\n* [hGet](#hget) - Get the value of a hash field\n* [hGetAll](#hgetall) - Get all the fields and values in a hash\n* [hIncrBy](#hincrby) - Increment the integer value of a hash field by the given number\n* [hIncrByFloat](#hincrbyfloat) - Increment the float value of a hash field by the given amount\n* [hKeys](#hkeys) - Get all the fields in a hash\n* [hLen](#hlen) - Get the number of fields in a hash\n* [hMGet](#hmget) - Get the values of all the given hash fields\n* [hMSet](#hmset) - Set multiple hash fields to multiple values\n* [hSet](#hset) - Set the string value of a hash field\n* [hSetNx](#hsetnx) - Set the value of a hash field, only if the field does not exist\n* [hVals](#hvals) - Get all the values in a hash\n* [hScan](#hscan) - Scan a hash key for members\n* [hStrLen](#hstrlen) - Get the string length of the value associated with field in the hash\n\n### hSet\n-----\n_**Description**_: Adds a value to the hash stored at key.\n##### *Parameters*\n*key*  \n*hashKey*  \n*value*\n\n##### *Return value*\n*LONG* `1` if value didn't exist and was added successfully, `0` if the value was already present and was replaced, `FALSE` if there was an error.\n##### *Example*\n~~~php\n$redis->del('h')\n$redis->hSet('h', 'key1', 'hello'); /* 1, 'key1' => 'hello' in the hash at \"h\" */\n$redis->hGet('h', 'key1'); /* returns \"hello\" */\n\n$redis->hSet('h', 'key1', 'plop'); /* 0, value was replaced. */\n$redis->hGet('h', 'key1'); /* returns \"plop\" */\n~~~\n\n### hSetNx\n-----\n_**Description**_: Adds a value to the hash stored at key only if this field isn't already in the hash.\n\n##### *Return value*\n*BOOL* `TRUE` if the field was set, `FALSE` if it was already present.\n\n##### *Example*\n~~~php\n$redis->del('h')\n$redis->hSetNx('h', 'key1', 'hello'); /* TRUE, 'key1' => 'hello' in the hash at \"h\" */\n$redis->hSetNx('h', 'key1', 'world'); /* FALSE, 'key1' => 'hello' in the hash at \"h\". No change since the field wasn't replaced. */\n~~~\n\n\n### hGet\n-----\n_**Description**_: Gets a value from the hash stored at key. If the hash table doesn't exist, or the key doesn't exist, `FALSE` is returned.\n##### *Parameters*\n*key*  \n*hashKey*\n\n##### *Return value*\n*STRING* The value, if the command executed successfully  \n*BOOL* `FALSE` in case of failure\n\n\n### hLen\n-----\n_**Description**_: Returns the length of a hash, in number of items\n##### *Parameters*\n*key*\n\n##### *Return value*\n*LONG* the number of items in a hash, `FALSE` if the key doesn't exist or isn't a hash.\n##### *Example*\n~~~php\n$redis->del('h')\n$redis->hSet('h', 'key1', 'hello');\n$redis->hSet('h', 'key2', 'plop');\n$redis->hLen('h'); /* returns 2 */\n~~~\n\n### hDel\n-----\n_**Description**_: Removes a value from the hash stored at key. If the hash table doesn't exist, or the key doesn't exist, `FALSE` is returned.\n##### *Parameters*\n*key*  \n*hashKey1*  \n*hashKey2*  \n...\n\n##### *Return value*\n*LONG* the number of deleted keys, 0 if the key doesn't exist, `FALSE` if the key isn't a hash.\n\n\n### hKeys\n-----\n_**Description**_: Returns the keys in a hash, as an array of strings.\n\n##### *Parameters*\n*Key*: key\n\n##### *Return value*\nAn array of elements, the keys of the hash. This works like PHP's array_keys().\n\n##### *Example*\n~~~php\n$redis->del('h');\n$redis->hSet('h', 'a', 'x');\n$redis->hSet('h', 'b', 'y');\n$redis->hSet('h', 'c', 'z');\n$redis->hSet('h', 'd', 't');\nvar_dump($redis->hKeys('h'));\n~~~\n\nOutput:\n~~~\narray(4) {\n  [0]=>\n  string(1) \"a\"\n  [1]=>\n  string(1) \"b\"\n  [2]=>\n  string(1) \"c\"\n  [3]=>\n  string(1) \"d\"\n}\n~~~\nThe order is random and corresponds to redis' own internal representation of the set structure.\n\n### hVals\n-----\n_**Description**_: Returns the values in a hash, as an array of strings.\n\n##### *Parameters*\n*Key*: key\n\n##### *Return value*\nAn array of elements, the values of the hash. This works like PHP's array_values().\n\n##### *Example*\n~~~php\n$redis->del('h');\n$redis->hSet('h', 'a', 'x');\n$redis->hSet('h', 'b', 'y');\n$redis->hSet('h', 'c', 'z');\n$redis->hSet('h', 'd', 't');\nvar_dump($redis->hVals('h'));\n~~~\n\nOutput:\n~~~\narray(4) {\n  [0]=>\n  string(1) \"x\"\n  [1]=>\n  string(1) \"y\"\n  [2]=>\n  string(1) \"z\"\n  [3]=>\n  string(1) \"t\"\n}\n~~~\nThe order is random and corresponds to redis' own internal representation of the set structure.\n\n### hGetAll\n-----\n_**Description**_: Returns the whole hash, as an array of strings indexed by strings.\n\n##### *Parameters*\n*Key*: key\n\n##### *Return value*\nAn array of elements, the contents of the hash.\n\n##### *Example*\n~~~php\n$redis->del('h');\n$redis->hSet('h', 'a', 'x');\n$redis->hSet('h', 'b', 'y');\n$redis->hSet('h', 'c', 'z');\n$redis->hSet('h', 'd', 't');\nvar_dump($redis->hGetAll('h'));\n~~~\n\nOutput:\n~~~\narray(4) {\n  [\"a\"]=>\n  string(1) \"x\"\n  [\"b\"]=>\n  string(1) \"y\"\n  [\"c\"]=>\n  string(1) \"z\"\n  [\"d\"]=>\n  string(1) \"t\"\n}\n~~~\nThe order is random and corresponds to redis' own internal representation of the set structure.\n\n### hExists\n-----\n_**Description**_: Verify if the specified member exists in a key.\n##### *Parameters*\n*key*  \n*memberKey*\n##### *Return value*\n*BOOL*: If the member exists in the hash table, return `TRUE`, otherwise return `FALSE`.\n##### *Examples*\n~~~php\n$redis->hSet('h', 'a', 'x');\n$redis->hExists('h', 'a'); /*  TRUE */\n$redis->hExists('h', 'NonExistingKey'); /* FALSE */\n~~~\n\n### hIncrBy\n-----\n_**Description**_: Increments the value of a member from a hash by a given amount.\n##### *Parameters*\n*key*  \n*member*  \n*value*: (integer) value that will be added to the member's value\n##### *Return value*\n*LONG* the new value\n##### *Examples*\n~~~php\n$redis->del('h');\n$redis->hIncrBy('h', 'x', 2); /* returns 2: h[x] = 2 now. */\n$redis->hIncrBy('h', 'x', 1); /* h[x] ‚Üê 2 + 1. Returns 3 */\n~~~\n\n### hIncrByFloat\n-----\n_**Description**_: Increments the value of a hash member by the provided float value\n##### *Parameters*\n*key*  \n*member*  \n*value*: (float) value that will be added to the member's value\n##### *Return value*\n*FLOAT* the new value\n##### *Examples*\n~~~php\n$redis->del('h');\n$redis->hIncrByFloat('h','x', 1.5); /* returns 1.5: h[x] = 1.5 now */\n$redis->hIncrByFloat('h', 'x', 1.5); /* returns 3.0: h[x] = 3.0 now */\n$redis->hIncrByFloat('h', 'x', -3.0); /* returns 0.0: h[x] = 0.0 now */\n~~~\n\n### hMSet\n-----\n_**Description**_: Fills in a whole hash. Non-string values are converted to string, using the standard `(string)` cast. NULL values are stored as empty strings.\n##### *Parameters*\n*key*  \n*members*: key ‚Üí value array\n##### *Return value*\n*BOOL*\n##### *Examples*\n~~~php\n$redis->del('user:1');\n$redis->hMSet('user:1', ['name' => 'Joe', 'salary' => 2000]);\n$redis->hIncrBy('user:1', 'salary', 100); // Joe earns 100 more now.\n~~~\n\n### hMGet\n-----\n_**Description**_: Retrieve the values associated to the specified fields in the hash.\n##### *Parameters*\n*key*  \n*memberKeys* Array\n##### *Return value*\n*Array* An array of elements, the values of the specified fields in the hash, with the hash keys as array keys.\n##### *Examples*\n~~~php\n$redis->del('h');\n$redis->hSet('h', 'field1', 'value1');\n$redis->hSet('h', 'field2', 'value2');\n$redis->hMGet('h', ['field1', 'field2']); /* returns ['field1' => 'value1', 'field2' => 'value2'] */\n~~~\n\n### hScan\n-----\n_**Description**_:  Scan a HASH value for members, with an optional pattern and count\n##### *Parameters*\n*key*: String  \n*iterator*: Long (reference)  \n*pattern*: Optional pattern to match against  \n*count*: How many keys to return in a go (only a suggestion to Redis)\n##### *Return value*\n*Array* An array of members that match our pattern\n\n##### *Examples*\n~~~php\n$it = NULL;\n/* Don't ever return an empty array until we're done iterating */\n$redis->setOption(Redis::OPT_SCAN, Redis::SCAN_RETRY);\nwhile($arr_keys = $redis->hScan('hash', $it)) {\n    foreach($arr_keys as $str_field => $str_value) {\n        echo \"$str_field => $str_value\\n\"; /* Print the hash member and value */\n    }\n}\n~~~\n\n### hStrLen\n-----\n_**Description**_: Get the string length of the value associated with field in the hash stored at key.\n##### *Parameters*\n*key*: String  \n*field*: String\n##### *Return value*\n*LONG* the string length of the value associated with field, or zero when field is not present in the hash or key does not exist at all.\n\n## Lists\n\n* [blPop, brPop](#blpop-brpop) - Remove and get the first/last element in a list\n* [bRPopLPush](#brpoplpush) - Pop a value from a list, push it to another list and return it\n* [lIndex](#lindex) - Get an element from a list by its index\n* [lInsert](#linsert) - Insert an element before or after another element in a list\n* [lLen](#llen) - Get the length/size of a list\n* [lPop](#lpop) - Remove and get the first element in a list\n* [lPush](#lpush) - Prepend one or multiple values to a list\n* [lPushx](#lpushx) - Prepend a value to a list, only if the list exists\n* [lRange](#lrange) - Get a range of elements from a list\n* [lRem](#lrem) - Remove elements from a list\n* [lSet](#lset) - Set the value of an element in a list by its index\n* [lTrim](#ltrim) - Trim a list to the specified range\n* [rPop](#rpop) - Remove and get the last element in a list\n* [rPopLPush](#rpoplpush) - Remove the last element in a list, append it to another list and return it (redis >= 1.1)\n* [rPush](#rpush) - Append one or multiple values to a list\n* [rPushX](#rpushx) - Append a value to a list, only if the list exists\n\n### blPop, brPop\n-----\n_**Description**_: Is a blocking lPop(rPop) primitive. If at least one of the lists contains at least one element, the element will be popped from the head of the list and returned to the caller.\nIf all the list identified by the keys passed in arguments are empty, blPop will block during the specified timeout until an element is pushed to one of those lists. This element will be popped.\n\n##### *Parameters*\n*ARRAY* Array containing the keys of the lists  \n*INTEGER* Timeout  \nOr  \n*STRING* Key1  \n*STRING* Key2  \n*STRING* Key3  \n...  \n*STRING* Keyn  \n*INTEGER* Timeout\n\n##### *Return value*\n*ARRAY* ['listName', 'element']\n\n##### *Example*\n~~~php\n/* Non blocking feature */\n$redis->lPush('key1', 'A');\n$redis->del('key2');\n\n$redis->blPop('key1', 'key2', 10); /* ['key1', 'A'] */\n/* OR */\n$redis->blPop(['key1', 'key2'], 10); /* ['key1', 'A'] */\n\n$redis->brPop('key1', 'key2', 10); /* ['key1', 'A'] */\n/* OR */\n$redis->brPop(['key1', 'key2'], 10); /* ['key1', 'A'] */\n\n/* Blocking feature */\n\n/* process 1 */\n$redis->del('key1');\n$redis->blPop('key1', 10);\n/* blocking for 10 seconds */\n\n/* process 2 */\n$redis->lPush('key1', 'A');\n\n/* process 1 */\n/* ['key1', 'A'] is returned*/\n~~~\n\n### bRPopLPush\n-----\n_**Description**_: A blocking version of `rPopLPush`, with an integral timeout in the third parameter.\n\n##### *Parameters*\n*Key*: srckey  \n*Key*: dstkey  \n*Long*: timeout\n\n##### *Return value*\n*STRING* The element that was moved in case of success, `FALSE` in case of timeout.\n\n### lIndex\n-----\n_**Description**_: Return the specified element of the list stored at the specified key.\n\n0 the first element, 1 the second ...  \n-1 the last element, -2 the penultimate ...\n\nReturn `FALSE` in case of a bad index or a key that doesn't point to a list.\n\n##### *Parameters*\n*key*  \n*index*\n\n##### *Return value*\n*String* the element at this index  \n*Bool* `FALSE` if the key identifies a non-string data type, or no value corresponds to this index in the list `Key`.\n\n##### *Example*\n~~~php\n$redis->rPush('key1', 'A');\n$redis->rPush('key1', 'B');\n$redis->rPush('key1', 'C'); /* key1 => [ 'A', 'B', 'C' ] */\n$redis->lindex('key1', 0); /* 'A' */\n$redis->lindex('key1', -1); /* 'C' */\n$redis->lindex('key1', 10); /* `FALSE` */\n~~~\n\n### lInsert\n-----\n_**Description**_: Insert value in the list before or after the pivot value.\n\nThe parameter options specify the position of the insert (before or after).\nIf the list didn't exists, or the pivot didn't exists, the value is not inserted.\n\n##### *Parameters*\n*key*  \n*position*  Redis::BEFORE | Redis::AFTER  \n*pivot*  \n*value*\n\n##### *Return value*\nThe number of the elements in the list, -1 if the pivot didn't exists.\n\n##### *Example*\n~~~php\n$redis->del('key1');\n$redis->lInsert('key1', Redis::AFTER, 'A', 'X'); /* 0 */\n\n$redis->lPush('key1', 'A');\n$redis->lPush('key1', 'B');\n$redis->lPush('key1', 'C');\n\n$redis->lInsert('key1', Redis::BEFORE, 'C', 'X'); /* 4 */\n$redis->lRange('key1', 0, -1); /* ['A', 'B', 'X', 'C'] */\n\n$redis->lInsert('key1', Redis::AFTER, 'C', 'Y'); /* 5 */\n$redis->lRange('key1', 0, -1); /* ['A', 'B', 'X', 'C', 'Y'] */\n\n$redis->lInsert('key1', Redis::AFTER, 'W', 'value'); /* -1 */\n~~~\n\n### lPop\n-----\n_**Description**_: Return and remove the first element of the list.\n\n##### *Parameters*\n*key*\n\n##### *Return value*\n*STRING* if command executed successfully  \n*BOOL* `FALSE` in case of failure (empty list)\n\n##### *Example*\n~~~php\n$redis->rPush('key1', 'A');\n$redis->rPush('key1', 'B');\n$redis->rPush('key1', 'C'); /* key1 => [ 'A', 'B', 'C' ] */\n$redis->lPop('key1'); /* key1 => [ 'B', 'C' ] */\n~~~\n\n### lPush\n-----\n_**Description**_: Adds one or more values to the head of a LIST.  Creates the list if the key didn't exist. If the key exists and is not a list, `FALSE` is returned.\n\n##### *Prototype*\n~~~php\n$redis->lPush($key, $entry [, $entry, $entry]);\n~~~\n\n##### *Return value*\n*LONG* The new length of the list in case of success, `FALSE` in case of Failure.\n\n##### *Examples*\n~~~php\n$redis->del('key1');\n$redis->lPush('key1', 'F'); // returns 1\n$redis->lPush('key1', 'E'); // returns 2\n$redis->lPush('key1', 'D'); // returns 3\n/* key1 now contains: [ 'D', 'E', 'F' ] */\n\n$redis->lPush('key1', 'C', 'B', 'A'); // Returns 6\n/* key1 now contains: [ 'A', 'B', 'C', 'D', 'E', 'F' ]\n~~~\n\n### lPushx\n-----\n_**Description**_: Adds the string value to the head (left) of the list if the list exists.\n\n##### *Parameters*\n*key*  \n*value* String, value to push in key\n\n##### *Return value*\n*LONG* The new length of the list in case of success, `FALSE` in case of Failure.\n\n##### *Examples*\n~~~php\n$redis->del('key1');\n$redis->lPushx('key1', 'A'); // returns 0\n$redis->lPush('key1', 'A'); // returns 1\n$redis->lPushx('key1', 'B'); // returns 2\n$redis->lPushx('key1', 'C'); // returns 3\n/* key1 now points to the following list: [ 'A', 'B', 'C' ] */\n~~~\n\n### lRange\n-----\n_**Description**_: Returns the specified elements of the list stored at the specified key in the range [start, end]. start and stop are interpreted as indices:  \n0 the first element, 1 the second ...  \n-1 the last element, -2 the penultimate ...\n\n##### *Parameters*\n*key*  \n*start*  \n*end*\n\n##### *Return value*\n*Array* containing the values in specified range.\n\n##### *Example*\n~~~php\n$redis->rPush('key1', 'A');\n$redis->rPush('key1', 'B');\n$redis->rPush('key1', 'C');\n$redis->lRange('key1', 0, -1); /* ['A', 'B', 'C'] */\n~~~\n\n### lRem\n-----\n_**Description**_: Removes the first `count` occurrences of the value element from the list. If count is zero, all the matching elements are removed. If count is negative, elements are removed from tail to head.\n\n**Note**: The argument order is not the same as in the Redis documentation. This difference is kept for compatibility reasons.\n\n##### *Parameters*\n*key*  \n*value*  \n*count*\n\n##### *Return value*\n*LONG* the number of elements to remove  \n*BOOL* `FALSE` if the value identified by key is not a list.\n\n##### *Example*\n~~~php\n$redis->lPush('key1', 'A');\n$redis->lPush('key1', 'B');\n$redis->lPush('key1', 'C');\n$redis->lPush('key1', 'A');\n$redis->lPush('key1', 'A');\n\n$redis->lRange('key1', 0, -1); /* ['A', 'A', 'C', 'B', 'A'] */\n$redis->lRem('key1', 'A', 2); /* 2 */\n$redis->lRange('key1', 0, -1); /* ['C', 'B', 'A'] */\n~~~\n\n### lSet\n-----\n_**Description**_: Set the list at index with the new value.\n\n##### *Parameters*\n*key*  \n*index*  \n*value*\n\n##### *Return value*\n*BOOL* `TRUE` if the new value was set. `FALSE` if the index is out of range, or data type identified by key is not a list.\n\n##### *Example*\n~~~php\n$redis->rPush('key1', 'A');\n$redis->rPush('key1', 'B');\n$redis->rPush('key1', 'C'); /* key1 => [ 'A', 'B', 'C' ] */\n$redis->lindex('key1', 0); /* 'A' */\n$redis->lSet('key1', 0, 'X');\n$redis->lindex('key1', 0); /* 'X' */\n~~~\n\n### lTrim\n-----\n_**Description**_: Trims an existing list so that it will contain only a specified range of elements.\n\n##### *Parameters*\n*key*  \n*start*  \n*stop*\n\n##### *Return value*\n*Array*  \n*Bool* return `FALSE` if the key identify a non-list value.\n\n##### *Example*\n~~~php\n$redis->rPush('key1', 'A');\n$redis->rPush('key1', 'B');\n$redis->rPush('key1', 'C');\n$redis->lRange('key1', 0, -1); /* ['A', 'B', 'C'] */\n$redis->lTrim('key1', 0, 1);\n$redis->lRange('key1', 0, -1); /* ['A', 'B'] */\n~~~\n\n### rPop\n-----\n_**Description**_: Returns and removes the last element of the list.\n\n##### *Parameters*\n*key*\n\n##### *Return value*\n*STRING* if command executed successfully  \n*BOOL* `FALSE` in case of failure (empty list)\n\n##### *Example*\n~~~php\n$redis->rPush('key1', 'A');\n$redis->rPush('key1', 'B');\n$redis->rPush('key1', 'C'); /* key1 => [ 'A', 'B', 'C' ] */\n$redis->rPop('key1'); /* key1 => [ 'A', 'B' ] */\n~~~\n\n### rPopLPush\n-----\n_**Description**_: Pops a value from the tail of a list, and pushes it to the front of another list. Also return this value. (redis >= 1.1)\n\n##### *Parameters*\n*Key*: srckey  \n*Key*: dstkey\n\n##### *Return value*\n*STRING* The element that was moved in case of success, `FALSE` in case of failure.\n\n##### *Example*\n~~~php\n$redis->del('x', 'y');\n\n$redis->lPush('x', 'abc');\n$redis->lPush('x', 'def');\n$redis->lPush('y', '123');\n$redis->lPush('y', '456');\n\n// move the last of x to the front of y.\nvar_dump($redis->rPopLPush('x', 'y'));\nvar_dump($redis->lRange('x', 0, -1));\nvar_dump($redis->lRange('y', 0, -1));\n\n~~~\nOutput:\n~~~\nstring(3) \"abc\"\narray(1) {\n  [0]=>\n  string(3) \"def\"\n}\narray(3) {\n  [0]=>\n  string(3) \"abc\"\n  [1]=>\n  string(3) \"456\"\n  [2]=>\n  string(3) \"123\"\n}\n~~~\n\n### rPush\n-----\n_**Description**_: Adds one or more entries to the tail of a LIST. Redis will create the list if it doesn't exist.\n\n##### *Prototype*\n~~~php\n$redis->rPush($key, $entry [, $entry, $entry]);\n~~~\n\n##### *Return value*\n*LONG* The new length of the list in case of success, `FALSE` in case of Failure.\n\n##### *Examples*\n~~~php\n$redis->del('key1');\n$redis->rPush('key1', 'A');           // returns 1\n$redis->rPush('key1', 'B');           // returns 2\n$redis->rPush('key1', 'C');           // returns 3\n$redis->rPush('key1', 'D', 'E', 'F'); // returns 6\n/* key1 now contains: [ 'A', 'B', 'C', 'D', 'E', 'F' ] */\n~~~\n\n### rPushX\n-----\n_**Description**_: Adds the string value to the tail (right) of the list if the list exists. `FALSE` in case of Failure.\n\n##### *Parameters*\n*key*  \n*value* String, value to push in key\n\n##### *Return value*\n*LONG* The new length of the list in case of success, `FALSE` in case of Failure.\n\n##### *Examples*\n~~~php\n$redis->del('key1');\n$redis->rPushX('key1', 'A'); // returns 0\n$redis->rPush('key1', 'A'); // returns 1\n$redis->rPushX('key1', 'B'); // returns 2\n$redis->rPushX('key1', 'C'); // returns 3\n/* key1 now points to the following list: [ 'A', 'B', 'C' ] */\n~~~\n\n### lLen\n-----\n_**Description**_: Returns the size of a list identified by Key.\n\nIf the list didn't exist or is empty, the command returns 0. If the data type identified by Key is not a list, the command return `FALSE`.\n\n##### *Parameters*\n*Key*\n\n##### *Return value*\n*LONG* The size of the list identified by Key exists.  \n*BOOL* `FALSE` if the data type identified by Key is not list\n\n##### *Example*\n~~~php\n$redis->rPush('key1', 'A');\n$redis->rPush('key1', 'B');\n$redis->rPush('key1', 'C'); /* key1 => [ 'A', 'B', 'C' ] */\n$redis->lLen('key1');/* 3 */\n$redis->rPop('key1');\n$redis->lLen('key1');/* 2 */\n~~~\n\n\n## Sets\n\n* [sAdd](#sadd) - Add one or more members to a set\n* [sCard](#scard) - Get the number of members in a set\n* [sDiff](#sdiff) - Subtract multiple sets\n* [sDiffStore](#sdiffstore) - Subtract multiple sets and store the resulting set in a key\n* [sInter](#sinter) - Intersect multiple sets\n* [sInterStore](#sinterstore) - Intersect multiple sets and store the resulting set in a key\n* [sIsMember](#sismember) - Determine if a given value is a member of a set\n* [sMembers](#smembers) - Get all the members in a set\n* [sMove](#smove) - Move a member from one set to another\n* [sPop](#spop) - Remove and return one or more members of a set at random\n* [sRandMember](#srandmember) - Get one or multiple random members from a set\n* [sRem](#srem) - Remove one or more members from a set\n* [sUnion](#sunion) - Add multiple sets\n* [sUnionStore](#sunionstore) - Add multiple sets and store the resulting set in a key\n* [sScan](#sscan) - Scan a set for members\n\n### sAdd\n-----\n_**Description**_: Adds a value to the set value stored at key.\n##### *Parameters*\n*key*  \n*value*\n\n##### *Return value*\n*LONG* the number of elements added to the set.\n##### *Example*\n~~~php\n$redis->sAdd('key1' , 'member1'); /* 1, 'key1' => {'member1'} */\n$redis->sAdd('key1' , 'member2', 'member3'); /* 2, 'key1' => {'member1', 'member2', 'member3'}*/\n$redis->sAdd('key1' , 'member2'); /* 0, 'key1' => {'member1', 'member2', 'member3'}*/\n~~~\n\n### sCard\n-----\n_**Description**_: Returns the cardinality of the set identified by key.\n##### *Parameters*\n*key*\n##### *Return value*\n*LONG* the cardinality of the set identified by key, 0 if the set doesn't exist.\n##### *Example*\n~~~php\n$redis->sAdd('key1' , 'member1');\n$redis->sAdd('key1' , 'member2');\n$redis->sAdd('key1' , 'member3'); /* 'key1' => {'member1', 'member2', 'member3'}*/\n$redis->sCard('key1'); /* 3 */\n$redis->sCard('keyX'); /* 0 */\n~~~\n\n### sDiff\n-----\n_**Description**_: Performs the difference between N sets and returns it.\n\n##### *Parameters*\n*Keys*: key1, key2, ... , keyN: Any number of keys corresponding to sets in redis.\n\n##### *Return value*\n*Array of strings*: The difference of the first set will all the others.\n\n##### *Example*\n~~~php\n$redis->del('s0', 's1', 's2');\n\n$redis->sAdd('s0', '1');\n$redis->sAdd('s0', '2');\n$redis->sAdd('s0', '3');\n$redis->sAdd('s0', '4');\n\n$redis->sAdd('s1', '1');\n$redis->sAdd('s2', '3');\n\nvar_dump($redis->sDiff('s0', 's1', 's2'));\n~~~\nReturn value: all elements of s0 that are neither in s1 nor in s2.\n~~~\narray(2) {\n  [0]=>\n  string(1) \"4\"\n  [1]=>\n  string(1) \"2\"\n}\n~~~\n\n### sDiffStore\n-----\n_**Description**_: Performs the same action as sDiff, but stores the result in the first key\n##### *Parameters*\n*Key*: dstkey, the key to store the diff into.\n\n*Keys*: key1, key2, ... , keyN: Any number of keys corresponding to sets in redis\n##### *Return value*\n*INTEGER*: The cardinality of the resulting set, or `FALSE` in case of a missing key.\n\n##### *Example*\n~~~php\n$redis->del('s0', 's1', 's2');\n\n$redis->sAdd('s0', '1');\n$redis->sAdd('s0', '2');\n$redis->sAdd('s0', '3');\n$redis->sAdd('s0', '4');\n\n$redis->sAdd('s1', '1');\n$redis->sAdd('s2', '3');\n\nvar_dump($redis->sDiffStore('dst', 's0', 's1', 's2'));\nvar_dump($redis->sMembers('dst'));\n~~~\nReturn value: the number of elements of s0 that are neither in s1 nor in s2.\n~~~\nint(2)\narray(2) {\n  [0]=>\n  string(1) \"4\"\n  [1]=>\n  string(1) \"2\"\n}\n~~~\n\n### sInter\n-----\n_**Description**_: Returns the members of a set resulting from the intersection of all the sets held at the specified keys.\n\nIf just a single key is specified, then this command produces the members of this set. If one of the keys\nis missing, `FALSE` is returned.\n\n##### *Parameters*\n\nkey1, key2, keyN: keys identifying the different sets on which we will apply the intersection.\n\n##### *Return value*\n\nArray, contain the result of the intersection between those keys. If the intersection between the different sets is empty, the return value will be empty array.\n\n##### *Examples*\n~~~php\n$redis->sAdd('key1', 'val1');\n$redis->sAdd('key1', 'val2');\n$redis->sAdd('key1', 'val3');\n$redis->sAdd('key1', 'val4');\n\n$redis->sAdd('key2', 'val3');\n$redis->sAdd('key2', 'val4');\n\n$redis->sAdd('key3', 'val3');\n$redis->sAdd('key3', 'val4');\n\nvar_dump($redis->sInter('key1', 'key2', 'key3'));\n~~~\n\nOutput:\n\n~~~\narray(2) {\n  [0]=>\n  string(4) \"val4\"\n  [1]=>\n  string(4) \"val3\"\n}\n~~~\n\n### sInterStore\n-----\n_**Description**_: Performs a sInter command and stores the result in a new set.\n##### *Parameters*\n*Key*: dstkey, the key to store the diff into.\n\n*Keys*: key1, key2... keyN. key1..keyN are intersected as in sInter.\n\n##### *Return value*\n*INTEGER*: The cardinality of the resulting set, or `FALSE` in case of a missing key.\n\n##### *Example*\n~~~php\n$redis->sAdd('key1', 'val1');\n$redis->sAdd('key1', 'val2');\n$redis->sAdd('key1', 'val3');\n$redis->sAdd('key1', 'val4');\n\n$redis->sAdd('key2', 'val3');\n$redis->sAdd('key2', 'val4');\n\n$redis->sAdd('key3', 'val3');\n$redis->sAdd('key3', 'val4');\n\nvar_dump($redis->sInterStore('output', 'key1', 'key2', 'key3'));\nvar_dump($redis->sMembers('output'));\n~~~\n\nOutput:\n\n~~~\nint(2)\n\narray(2) {\n  [0]=>\n  string(4) \"val4\"\n  [1]=>\n  string(4) \"val3\"\n}\n~~~\n\n### sIsMember\n-----\n_**Description**_: Checks if `value` is a member of the set stored at the key `key`.\n##### *Parameters*\n*key*  \n*value*\n\n##### *Return value*\n*BOOL* `TRUE` if `value` is a member of the set at key `key`, `FALSE` otherwise.\n##### *Example*\n~~~php\n$redis->sAdd('key1' , 'member1');\n$redis->sAdd('key1' , 'member2');\n$redis->sAdd('key1' , 'member3'); /* 'key1' => {'member1', 'member2', 'member3'}*/\n\n$redis->sIsMember('key1', 'member1'); /* TRUE */\n$redis->sIsMember('key1', 'memberX'); /* FALSE */\n~~~\n\n### sMembers\n-----\n_**Description**_: Returns the contents of a set.\n\n##### *Parameters*\n*Key*: key\n\n##### *Return value*\nAn array of elements, the contents of the set.\n\n##### *Example*\n~~~php\n$redis->del('s');\n$redis->sAdd('s', 'a');\n$redis->sAdd('s', 'b');\n$redis->sAdd('s', 'a');\n$redis->sAdd('s', 'c');\nvar_dump($redis->sMembers('s'));\n~~~\n\nOutput:\n~~~\narray(3) {\n  [0]=>\n  string(1) \"c\"\n  [1]=>\n  string(1) \"a\"\n  [2]=>\n  string(1) \"b\"\n}\n~~~\nThe order is random and corresponds to redis' own internal representation of the set structure.\n\n### sMove\n-----\n_**Description**_: Moves the specified member from the set at srcKey to the set at dstKey.\n##### *Parameters*\n*srcKey*  \n*dstKey*  \n*member*\n##### *Return value*\n*BOOL* If the operation is successful, return `TRUE`. If the srcKey and/or dstKey didn't exist, and/or the member didn't exist in srcKey, `FALSE` is returned.\n##### *Example*\n~~~php\n$redis->sAdd('key1' , 'member11');\n$redis->sAdd('key1' , 'member12');\n$redis->sAdd('key1' , 'member13'); /* 'key1' => {'member11', 'member12', 'member13'}*/\n$redis->sAdd('key2' , 'member21');\n$redis->sAdd('key2' , 'member22'); /* 'key2' => {'member21', 'member22'}*/\n$redis->sMove('key1', 'key2', 'member13'); /* 'key1' =>  {'member11', 'member12'} */\n\t\t\t\t\t/* 'key2' =>  {'member21', 'member22', 'member13'} */\n\n~~~\n\n### sPop\n-----\n_**Description**_: Removes and returns a random element from the set value at Key.\n##### *Parameters*\n*key*  \n*count*: Integer, optional\n##### *Return value (without count argument)*\n*String* \"popped\" value  \n*Bool* `FALSE` if set identified by key is empty or doesn't exist.\n##### *Return value (with count argument)*\n*Array*: Member(s) returned or an empty array if the set doesn't exist  \n*Bool*: `FALSE` on error if the key is not a set\n##### *Example*\n~~~php\n$redis->sAdd('key1' , 'member1');\n$redis->sAdd('key1' , 'member2');\n$redis->sAdd('key1' , 'member3'); /* 'key1' => {'member3', 'member1', 'member2'}*/\n$redis->sPop('key1'); /* 'member1', 'key1' => {'member3', 'member2'} */\n$redis->sPop('key1'); /* 'member3', 'key1' => {'member2'} */\n\n/* With count */\n$redis->sAdd('key2', 'member1', 'member2', 'member3');\n$redis->sPop('key2', 3); /* Will return all members but in no particular order */\n~~~\n\n### sRandMember\n-----\n_**Description**_: Returns a random element from the set value at Key, without removing it.\n##### *Parameters*\n*key*  \n*count* (Integer, optional)\n##### *Return value*\nIf no count is provided, a random *String* value from the set will be returned.  If a count\nis provided, an array of values from the set will be returned.  Read about the different\nways to use the count here: [SRANDMEMBER](http://redis.io/commands/srandmember)\n*Bool* `FALSE` if set identified by key is empty or doesn't exist.\n##### *Example*\n~~~php\n$redis->sAdd('key1' , 'member1');\n$redis->sAdd('key1' , 'member2');\n$redis->sAdd('key1' , 'member3'); /* 'key1' => {'member3', 'member1', 'member2'}*/\n\n// No count\n$redis->sRandMember('key1'); /* 'member1', 'key1' => {'member3', 'member1', 'member2'} */\n$redis->sRandMember('key1'); /* 'member3', 'key1' => {'member3', 'member1', 'member2'} */\n\n// With a count\n$redis->sRandMember('key1', 3); // Will return an array with all members from the set\n$redis->sRandMember('key1', 2); // Will an array with 2 members of the set\n$redis->sRandMember('key1', -100); // Will return an array of 100 elements, picked from our set (with dups)\n$redis->sRandMember('empty-set', 100); // Will return an empty array\n$redis->sRandMember('not-a-set', 100); // Will return FALSE\n~~~\n\n### sRem\n-----\n_**Description**_: Removes the specified member from the set value stored at key.\n##### *Parameters*\n*key*  \n*member*\n##### *Return value*\n*LONG* The number of elements removed from the set.\n##### *Example*\n~~~php\n$redis->sAdd('key1' , 'member1');\n$redis->sAdd('key1' , 'member2');\n$redis->sAdd('key1' , 'member3'); /* 'key1' => {'member1', 'member2', 'member3'}*/\n$redis->sRem('key1', 'member2', 'member3'); /*return 2. 'key1' => {'member1'} */\n~~~\n\n### sUnion\n-----\n_**Description**_: Performs the union between N sets and returns it.\n\n##### *Parameters*\n*Keys*: key1, key2, ... , keyN: Any number of keys corresponding to sets in redis.\n\n##### *Return value*\n*Array of strings*: The union of all these sets.\n\n**Note:** `sUnion` can also take a single array with keys (see example below).\n\n##### *Example*\n~~~php\n$redis->del('s0', 's1', 's2');\n\n$redis->sAdd('s0', '1');\n$redis->sAdd('s0', '2');\n$redis->sAdd('s1', '3');\n$redis->sAdd('s1', '1');\n$redis->sAdd('s2', '3');\n$redis->sAdd('s2', '4');\n\n/* Get the union with variadic arguments */\nvar_dump($redis->sUnion('s0', 's1', 's2'));\n\n/* Pass a single array */\nvar_dump($redis->sUnion(['s0', 's1', 's2']));\n\n~~~\nReturn value: all elements that are either in s0 or in s1 or in s2.\n~~~\narray(4) {\n  [0]=>\n  string(1) \"3\"\n  [1]=>\n  string(1) \"4\"\n  [2]=>\n  string(1) \"1\"\n  [3]=>\n  string(1) \"2\"\n}\n~~~\n\n### sUnionStore\n-----\n_**Description**_: Performs the same action as sUnion, but stores the result in the first key\n\n##### *Parameters*\n*Key*: dstkey, the key to store the diff into.\n\n*Keys*: key1, key2, ... , keyN: Any number of keys corresponding to sets in redis.\n\n##### *Return value*\n*INTEGER*: The cardinality of the resulting set, or `FALSE` in case of a missing key.\n\n##### *Example*\n~~~php\n$redis->del('s0', 's1', 's2');\n\n$redis->sAdd('s0', '1');\n$redis->sAdd('s0', '2');\n$redis->sAdd('s1', '3');\n$redis->sAdd('s1', '1');\n$redis->sAdd('s2', '3');\n$redis->sAdd('s2', '4');\n\nvar_dump($redis->sUnionStore('dst', 's0', 's1', 's2'));\nvar_dump($redis->sMembers('dst'));\n~~~\nReturn value: the number of elements that are either in s0 or in s1 or in s2.\n~~~\nint(4)\narray(4) {\n  [0]=>\n  string(1) \"3\"\n  [1]=>\n  string(1) \"4\"\n  [2]=>\n  string(1) \"1\"\n  [3]=>\n  string(1) \"2\"\n}\n~~~\n\n### sScan\n-----\n_**Description**_: Scan a set for members\n\n##### *Parameters*\n*Key*: The set to search  \n*iterator*: LONG (reference) to the iterator as we go  \n*pattern*: String, optional pattern to match against  \n*count*: How many members to return at a time (Redis might return a different amount)\n\n##### *Return value*\n*Array, boolean*: PHPRedis will return an array of keys or FALSE when we're done iterating\n\n##### *Example*\n~~~php\n$it = NULL;\n$redis->setOption(Redis::OPT_SCAN, Redis::SCAN_RETRY); /* don't return empty results until we're done */\nwhile($arr_mems = $redis->sScan('set', $it, \"*pattern*\")) {\n    foreach($arr_mems as $str_mem) {\n        echo \"Member: $str_mem\\n\";\n    }\n}\n\n$it = NULL;\n$redis->setOption(Redis::OPT_SCAN, Redis::SCAN_NORETRY); /* return after each iteration, even if empty */\nwhile(($arr_mems = $redis->sScan('set', $it, \"*pattern*\"))!==FALSE) {\n    if(count($arr_mems) > 0) {\n        foreach($arr_mems as $str_mem) {\n            echo \"Member found: $str_mem\\n\";\n        }\n    } else {\n        echo \"No members in this iteration, iterator value: $it\\n\";\n    }\n}\n~~~\n\n## Sorted sets\n\n* [bzPop](#bzpop) - Block until Redis can pop the highest or lowest scoring member from one or more ZSETs.\n* [zAdd](#zadd) - Add one or more members to a sorted set or update its score if it already exists\n* [zCard](#zcard) - Get the number of members in a sorted set\n* [zCount](#zcount) - Count the members in a sorted set with scores within the given values\n* [zDiff](#zdiff) - Computes the difference between the first and all successive input sorted sets and return the resulting sorted set\n* [zdiffstore](#zdiffstore) - Computes the difference between the first and all successive input sorted sets and stores the result in a new key\n* [zIncrBy](#zincrby) - Increment the score of a member in a sorted set\n* [zInter](#zinter) - Intersect multiple sorted sets and return the resulting sorted set\n* [zinterstore](#zinterstore) - Intersect multiple sorted sets and store the resulting sorted set in a new key\n* [zMscore](#zmscore) - Get the scores associated with the given members in a sorted set\n* [zPop](#zpop) - Redis can pop the highest or lowest scoring member from one a ZSET.\n* [zRange](#zrange) - Return a range of members in a sorted set, by index\n* [zRangeByScore, zRevRangeByScore](#zrangebyscore-zrevrangebyscore) - Return a range of members in a sorted set, by score\n* [zRangeByLex](#zrangebylex) - Return a lexicographical range from members that share the same score\n* [zRank, zRevRank](#zrank-zrevrank) - Determine the index of a member in a sorted set\n* [zRem](#zrem) - Remove one or more members from a sorted set\n* [zRemRangeByRank](#zremrangebyrank) - Remove all members in a sorted set within the given indexes\n* [zRemRangeByScore](#zremrangebyscore) - Remove all members in a sorted set within the given scores\n* [zRevRange](#zrevrange) - Return a range of members in a sorted set, by index, with scores ordered from high to low\n* [zScore](#zscore) - Get the score associated with the given member in a sorted set\n* [zUnion](#zunion) - Add multiple sorted sets and return the resulting sorted set\n* [zunionstore](#zunionstore) - Add multiple sorted sets and store the resulting sorted set in a new key\n* [zScan](#zscan) - Scan a sorted set for members\n\n### bzPop\n-----\n_**Description**_: Block until Redis can pop the highest or lowest scoring members from one or more ZSETs.  There are two commands (`BZPOPMIN` and `BZPOPMAX` for popping the lowest and highest scoring elements respectively.)\n\n##### *Prototype*\n~~~php\n$redis->bzPopMin(array $keys, int $timeout): array\n$redis->bzPopMax(array $keys, int $timeout): array\n\n$redis->bzPopMin(string $key1, string $key2, ... int $timeout): array\n$redis->bzPopMax(string $key1, string $key2, ... int $timeout): array\n~~~\n\n##### *Return value*\n*ARRAY:* Either an array with the key member and score of the highest or lowest element or an empty array if the timeout was reached without an element to pop.\n\n##### *Example*\n~~~php\n/* Wait up to 5 seconds to pop the *lowest* scoring member from sets `zs1` and `zs2`. */\n$redis->bzPopMin(['zs1', 'zs2'], 5);\n$redis->bzPopMin('zs1', 'zs2', 5);\n\n/* Wait up to 5 seconds to pop the *highest* scoring member from sets `zs1` and `zs2` */\n$redis->bzPopMax(['zs1', 'zs2'], 5);\n$redis->bzPopMax('zs1', 'zs2', 5);\n~~~\n\n**Note:** Calling these functions with an array of keys or with a variable number of arguments is functionally identical.\n\n### zAdd\n-----\n_**Description**_: Add one or more members to a sorted set or update its score if it already exists\n\n\n##### *Prototype*\n~~~php\n$redis->zAdd($key, [ $options ,] $score, $value [, $score1, $value1, ...]);\n~~~\n\n##### *Parameters*\n*key*: string\n*options*: array (optional)\n*score*: double  \n*value*: string\n*score1*: double\n*value1*: string\n\n##### *Return value*\n*Long* 1 if the element is added. 0 otherwise.\n\n##### *Example*\n~~~php\n$redis->zAdd('key', 1, 'val1');\n$redis->zAdd('key', 0, 'val0');\n$redis->zAdd('key', 5, 'val5');\n$redis->zRange('key', 0, -1); // [val0, val1, val5]\n\n// From Redis 3.0.2 it's possible to add options like XX, NX, CH, INCR\n$redis->zAdd('key', ['CH'], 5, 'val5', 10, 'val10', 15, 'val15');\n~~~\n\n### zCard\n-----\n_**Description**_: Returns the cardinality of an ordered set.\n\n##### *Parameters*\n*key*\n\n##### *Return value*\n*Long*, the set's cardinality\n\n##### *Example*\n~~~php\n$redis->zAdd('key', 0, 'val0');\n$redis->zAdd('key', 2, 'val2');\n$redis->zAdd('key', 10, 'val10');\n$redis->zCard('key'); /* 3 */\n~~~\n\n### zCount\n-----\n_**Description**_: Returns the *number* of elements of the sorted set stored at the specified key which have scores in the range [start,end]. Adding a parenthesis before `start` or `end` excludes it from the range. +inf and -inf are also valid limits.\n\n##### *Parameters*\n*key*  \n*start*: string  \n*end*: string\n\n##### *Return value*\n*LONG* the size of a corresponding zRangeByScore.\n\n##### *Example*\n~~~php\n$redis->zAdd('key', 0, 'val0');\n$redis->zAdd('key', 2, 'val2');\n$redis->zAdd('key', 10, 'val10');\n$redis->zCount('key', 0, 3); /* 2, corresponding to ['val0', 'val2'] */\n~~~\n\n### zDiff\n-----\n_**Description**_: Computes the difference between the first and all successive input sorted sets in the first argument.  The result of the difference will be returned.\n\nThe second argument is a set of options.  It can define `WITHSCORES` so that the scores are returned as well.\n\n##### *Parameters*\n*arrayZSetKeys*  \n*arrayOptions* One option is available: `withscores => TRUE`.\n\n##### *Return value*\n*ARRAY* The result of the difference of sets.\n\n##### *Example*\n~~~php\n$redis->del('k1');\n$redis->del('k2');\n$redis->del('k3');\n\n$redis->zAdd('k1', 0, 'val0');\n$redis->zAdd('k1', 1, 'val1');\n$redis->zAdd('k1', 3, 'val3');\n\n$redis->zAdd('k2', 5, 'val1');\n\n$redis->zAdd('k3', 5, 'val0');\n$redis->zAdd('k3', 3, 'val4');\n\n$redis->zDiff(['k1', 'k2']); \t\t\t\t                 /* ['val0', 'val3'] */\n$redis->zDiff(['k2', 'k1']); \t\t\t\t                 /* [] */\n$redis->zDiff(['k1', 'k2'], ['withscores' => true]); /* ['val0' => 0.0, 'val3' => 3.0] */\n\n$redis->zDiff(['k1', 'k2', 'k3']);                   /* ['val3'] */\n$redis->zDiff(['k3', 'k2', 'k1']);                   /* ['val4'] */\n~~~\n\n### zdiffstore\n-----\n_**Description**_: Computes the difference between the first and all successive input sorted sets in the second argument. The result of the difference will be stored in the sorted set defined by the first argument.\n\n##### *Parameters*\n*keyOutput*  \n*arrayZSetKeys*  \n\n##### *Return value*\n*LONG* The number of values in the new sorted set.\n\n##### *Example*\n~~~php\n$redis->del('k1');\n$redis->del('k2');\n$redis->del('k3');\n\n$redis->zAdd('k1', 0, 'val0');\n$redis->zAdd('k1', 1, 'val1');\n$redis->zAdd('k1', 3, 'val3');\n\n$redis->zAdd('k2', 5, 'val1');\n\n$redis->zAdd('k3', 5, 'val0');\n$redis->zAdd('k3', 3, 'val4');\n\n$redis->zdiffstore('ko1', ['k1', 'k2']); \t\t   /* 2, 'ko1' => ['val0', 'val3'] */\n$redis->zdiffstore('ko2', ['k2', 'k1']); \t\t\t /* 0, 'ko2' => [] */\n\n$redis->zdiffstore('ko3', ['k1', 'k2', 'k3']); /* 1, 'ko3' => ['val3'] */\n$redis->zdiffstore('ko4', ['k3', 'k2', 'k1']); /* 1, 'k04' => ['val4'] */\n~~~\n\n### zIncrBy\n-----\n_**Description**_: Increments the score of a member from a sorted set by a given amount.\n\n##### *Parameters*\n*key*  \n*value*: (double) value that will be added to the member's score  \n*member*\n\n##### *Return value*\n*DOUBLE* the new value\n\n##### *Examples*\n~~~php\n$redis->del('key');\n$redis->zIncrBy('key', 2.5, 'member1'); /* key or member1 didn't exist, so member1's score is to 0 before the increment */\n\t\t\t\t\t  /* and now has the value 2.5  */\n$redis->zIncrBy('key', 1, 'member1'); /* 3.5 */\n~~~\n\n### zInter\n-----\n_**Description**_: Creates an intersection of sorted sets given in first argument. The result of the intersection will be returned.\n\nThe second optional argument defines `weights` to apply to the sorted sets in input. In this case, the `weights` will be multiplied by the score of each element in the sorted set before applying the aggregation.\nThe third argument is a set of options.  It can define the `AGGREGATE` option which specify how the results of the intersection are aggregated.  It can also define `WITHSCORES` so that the scores are returned as well.\n\n##### *Parameters*\n*arrayZSetKeys*  \n*arrayWeights*  \n*arrayOptions* Two options are available: `withscores => TRUE`, and `aggregate => $behaviour`.  Either \"SUM\", \"MIN\", or \"MAX\" defines the behaviour to use on duplicate entries during the zinter.\n\n##### *Return value*\n*ARRAY* The result of the intersection of sets.\n\n##### *Example*\n~~~php\n$redis->del('k1');\n$redis->del('k2');\n$redis->del('k3');\n\n$redis->zAdd('k1', 0, 'val0');\n$redis->zAdd('k1', 1, 'val1');\n$redis->zAdd('k1', 3, 'val3');\n\n$redis->zAdd('k2', 5, 'val1');\n$redis->zAdd('k2', 3, 'val3');\n\n$redis->zinter(['k1', 'k2']); \t\t\t\t/* ['val1', 'val3'] */\n$redis->zinter(['k1', 'k2'], [1, 1]); /* ['val1', 'val3'] */\n\n/* Weighted zinter */\n$redis->zinter(['k1', 'k2'], [1, 5], 'min'); /* ['val1', 'val3'] */\n$redis->zinter(['k1', 'k2'], [1, 5], 'max'); /* ['val3', 'val1'] */\n~~~\n\n### zinterstore\n-----\n_**Description**_: Creates an intersection of sorted sets given in second argument. The result of the intersection will be stored in the sorted set defined by the first argument.\n\nThe third optional argument defines `weights` to apply to the sorted sets in input. In this case, the `weights` will be multiplied by the score of each element in the sorted set before applying the aggregation.\nThe forth argument defines the `AGGREGATE` option which specify how the results of the intersection are aggregated.\n\n##### *Parameters*\n*keyOutput*  \n*arrayZSetKeys*  \n*arrayWeights*  \n*aggregateFunction* Either \"SUM\", \"MIN\", or \"MAX\": defines the behaviour to use on duplicate entries during the zinterstore.\n\n##### *Return value*\n*LONG* The number of values in the new sorted set.\n\n##### *Example*\n~~~php\n$redis->del('k1');\n$redis->del('k2');\n$redis->del('k3');\n\n$redis->del('ko1');\n$redis->del('ko2');\n$redis->del('ko3');\n$redis->del('ko4');\n\n$redis->zAdd('k1', 0, 'val0');\n$redis->zAdd('k1', 1, 'val1');\n$redis->zAdd('k1', 3, 'val3');\n\n$redis->zAdd('k2', 5, 'val1');\n$redis->zAdd('k2', 3, 'val3');\n\n$redis->zinterstore('ko1', ['k1', 'k2']); \t\t\t\t/* 2, 'ko1' => ['val1', 'val3'] */\n$redis->zinterstore('ko2', ['k1', 'k2'], [1, 1]); /* 2, 'ko2' => ['val1', 'val3'] */\n\n/* Weighted zinterstore */\n$redis->zinterstore('ko3', ['k1', 'k2'], [1, 5], 'min'); /* 2, 'ko3' => ['val1', 'val3'] */\n$redis->zinterstore('ko4', ['k1', 'k2'], [1, 5], 'max'); /* 2, 'ko4' => ['val3', 'val1'] */\n~~~\n\n### zMscore\n-----\n_**Description**_: Returns the scores of the given members in the specified sorted set.\n\n##### *Parameters*\n*key*  \n*members*: member1, member2, ... , memberN: Any number of members in the specified sorted set.\n\n##### *Return value*\n*ARRAY* or *FALSE* when the key is not found.  Array entries corresponding to members that do not exist will be `false`.\n\n##### *Example*\n~~~php\n$redis->zAdd('key', 2.5, 'val2');\n$redis->zAdd('key', 4.5, 'val4');\n\n$redis->zMscore('key', 'val2', 'val3', 'val4'); /* [2.5, false, 4.5] */\n~~~\n\n### zPop\n-----\n_**Description**_: Can pop the highest or lowest scoring members from one ZSETs. There are two commands (`ZPOPMIN` and `ZPOPMAX` for popping the lowest and highest scoring elements respectively.)\n\n##### *Prototype*\n~~~php\n$redis->zPopMin(string $key, int $count): array\n$redis->zPopMax(string $key, int $count): array\n\n$redis->zPopMin(string $key, int $count): array\n$redis->zPopMax(string $key, int $count): array\n~~~\n\n##### *Return value*\n*ARRAY:* Either an array with the key member and score of the highest or lowest element or an empty array if there is no element available.\n\n##### *Example*\n~~~php\n/* Pop the *lowest* scoring member from set `zs1`. */\n$redis->zPopMin('zs1', 5);\n\n/* Pop the *highest* scoring member from set `zs1`. */\n$redis->zPopMax('zs1', 5);\n~~~\n\n### zRange\n-----\n_**Description**_: Returns a range of elements from the ordered set stored at the specified key, with values in the range [start, end].\n\nStart and stop are interpreted as zero-based indices:  \n`0` the first element, `1` the second ...  \n`-1` the last element, `-2` the penultimate ...  \n\n##### *Parameters*\n*key*\n*start*: long  \n*end*: long  \n*withscores*: bool = false\n\n##### *Return value*\n*Array* containing the values in specified range.\n\n##### *Example*\n~~~php\n$redis->zAdd('key1', 0, 'val0');\n$redis->zAdd('key1', 2, 'val2');\n$redis->zAdd('key1', 10, 'val10');\n$redis->zRange('key1', 0, -1); /* ['val0', 'val2', 'val10'] */\n\n// with scores\n$redis->zRange('key1', 0, -1, true); /* ['val0' => 0, 'val2' => 2, 'val10' => 10] */\n~~~\n\n### zRangeByScore, zRevRangeByScore\n-----\n_**Description**_: Returns the elements of the sorted set stored at the specified key which have scores in the range [start,end]. Adding a parenthesis before `start` or `end` excludes it from the range. +inf and -inf are also valid limits. zRevRangeByScore returns the same items in reverse order, when the `start` and `end` parameters are swapped.\n\n##### *Parameters*\n*key*  \n*start*: string  \n*end*: string  \n*options*: array\n\nTwo options are available: `withscores => TRUE`, and `limit => [$offset, $count]`\n\n##### *Return value*\n*Array* containing the values in specified range.\n\n##### *Example*\n~~~php\n$redis->zAdd('key', 0, 'val0');\n$redis->zAdd('key', 2, 'val2');\n$redis->zAdd('key', 10, 'val10');\n$redis->zRangeByScore('key', 0, 3); /* ['val0', 'val2'] */\n$redis->zRangeByScore('key', 0, 3, ['withscores' => TRUE]); /* ['val0' => 0, 'val2' => 2] */\n$redis->zRangeByScore('key', 0, 3, ['limit' => [1, 1]]); /* ['val2'] */\n$redis->zRangeByScore('key', 0, 3, ['withscores' => TRUE, 'limit' => [1, 1]]); /* ['val2' => 2] */\n$redis->zRangeByScore('key', '-inf', '+inf', ['withscores' => TRUE]); /* ['val0' => 0, 'val2' => 2, 'val10' => 10] */\n~~~\n\n### zRangeByLex\n-----\n_**Description**_:  Returns a lexicographical range of members in a sorted set, assuming the members have the same score.  The min and max values are required to start with '(' (exclusive), '[' (inclusive), or be exactly the values '-' (negative inf) or '+' (positive inf).  The command must be called with either three *or* five arguments or will return FALSE.\n\n##### *Parameters*\n*key*: The ZSET you wish to run against  \n*min*: The minimum alphanumeric value you wish to get  \n*max*: The maximum alphanumeric value you wish to get  \n*offset*:  Optional argument if you wish to start somewhere other than the first element.  \n*limit*: Optional argument if you wish to limit the number of elements returned.\n\n##### *Return value*\n*Array* containing the values in the specified range.\n\n##### *Example*\n~~~php\nforeach(['a','b','c','d','e','f','g'] as $c)\n    $redis->zAdd('key',0,$c);\n\n$redis->zRangeByLex('key','-','[c') /* ['a','b','c']; */\n$redis->zRangeByLex('key','-','(c') /* ['a','b'] */\n$redis->zRangeByLex('key','-','[c',1,2) /* ['b','c'] */\n~~~\n\n### zRank, zRevRank\n-----\n_**Description**_: Returns the rank of a given member in the specified sorted set, starting at 0 for the item with the smallest score. zRevRank starts at 0 for the item with the *largest* score.\n\n##### *Parameters*\n*key*  \n*member*\n\n##### *Return value*\n*Long*, the item's rank.\n\n##### *Example*\n~~~php\n$redis->del('z');\n$redis->zAdd('key', 1, 'one');\n$redis->zAdd('key', 2, 'two');\n$redis->zRank('key', 'one'); /* 0 */\n$redis->zRank('key', 'two'); /* 1 */\n$redis->zRevRank('key', 'one'); /* 1 */\n$redis->zRevRank('key', 'two'); /* 0 */\n~~~\n\n### zRem\n-----\n_**Description**_: Delete one or more members from a sorted set.\n\n##### *Prototype*\n~~~php\n$redis->zRem($key, $member [, $member ...]);\n~~~\n\n##### *Return value*\n*LONG:* The number of members deleted.\n\n##### *Example*\n~~~php\n$redis->zAdd('key', 0, 'val0', 1, 'val1', 2, 'val2');\n$redis->zRem('key', 'val0', 'val1', 'val2'); // Returns: 3\n~~~\n\n### zRemRangeByRank\n-----\n_**Description**_: Deletes the elements of the sorted set stored at the specified key which have rank in the range [start,end].\n\n##### *Parameters*\n*key*  \n*start*: LONG  \n*end*: LONG\n\n##### *Return value*\n*LONG* The number of values deleted from the sorted set\n\n##### *Example*\n~~~php\n$redis->zAdd('key', 1, 'one');\n$redis->zAdd('key', 2, 'two');\n$redis->zAdd('key', 3, 'three');\n$redis->zRemRangeByRank('key', 0, 1); /* 2 */\n$redis->zRange('key', 0, -1, ['withscores' => TRUE]); /* ['three' => 3] */\n~~~\n\n### zRemRangeByScore\n-----\n_**Description**_: Deletes the elements of the sorted set stored at the specified key which have scores in the range [start,end].\n\n##### *Parameters*\n*key*  \n*start*: double or \"+inf\" or \"-inf\" string  \n*end*: double or \"+inf\" or \"-inf\" string\n\n##### *Return value*\n*LONG* The number of values deleted from the sorted set\n\n##### *Example*\n~~~php\n$redis->zAdd('key', 0, 'val0');\n$redis->zAdd('key', 2, 'val2');\n$redis->zAdd('key', 10, 'val10');\n$redis->zRemRangeByScore('key', 0, 3); /* 2 */\n~~~\n\n### zRevRange\n-----\n_**Description**_: Returns the elements of the sorted set stored at the specified key in the range [start, end] in reverse order. start and stop are interpreted as zero-based indices:  \n`0` the first element, `1` the second ...  \n`-1` the last element, `-2` the penultimate ...\n\n##### *Parameters*\n*key*  \n*start*: long  \n*end*: long  \n*withscores*: bool = false\n\n##### *Return value*\n*Array* containing the values in specified range.\n\n##### *Example*\n~~~php\n$redis->zAdd('key', 0, 'val0');\n$redis->zAdd('key', 2, 'val2');\n$redis->zAdd('key', 10, 'val10');\n$redis->zRevRange('key', 0, -1); /* ['val10', 'val2', 'val0'] */\n\n// with scores\n$redis->zRevRange('key', 0, -1, true); /* ['val10' => 10, 'val2' => 2, 'val0' => 0] */\n~~~\n\n### zScore\n-----\n_**Description**_: Returns the score of a given member in the specified sorted set.\n\n##### *Parameters*\n*key*  \n*member*\n\n##### *Return value*\n*Double* or *FALSE* when the value is not found\n\n##### *Example*\n~~~php\n$redis->zAdd('key', 2.5, 'val2');\n$redis->zScore('key', 'val2'); /* 2.5 */\n~~~\n\n### zUnion\n-----\n_**Description**_: Creates an union of sorted sets given in first argument. The result of the union will be returned.\n\nThe second optional argument defines `weights` to apply to the sorted sets in input. In this case, the `weights` will be multiplied by the score of each element in the sorted set before applying the aggregation.\nThe third argument is a set of options.  It can define the `AGGREGATE` option which specify how the results of the intersection are aggregated.  It can also define `WITHSCORES` so that the scores are returned as well.\n\n##### *Parameters*\n*arrayZSetKeys*  \n*arrayWeights*  \n*arrayOptions* Two options are available: `withscores => TRUE`, and `aggregate => $behaviour`.  Either \"SUM\", \"MIN\", or \"MAX\" defines the behaviour to use on duplicate entries during the zunion.\n\n##### *Return value*\n*ARRAY* The result of the union of sets.\n\n##### *Example*\n~~~php\n$redis->del('k1');\n$redis->del('k2');\n$redis->del('k3');\n\n$redis->zAdd('k1', 0, 'val0');\n$redis->zAdd('k1', 1, 'val1');\n\n$redis->zAdd('k2', 2, 'val2');\n$redis->zAdd('k2', 3, 'val3');\n\n$redis->zunion(['k1', 'k2']); /* ['val0', 'val1', 'val2', 'val3'] */\n\n/* Weighted zunion */\n$redis->zunion(['k1', 'k2'], [1, 1]); /* ['val0', 'val1', 'val2', 'val3'] */\n$redis->zunion(['k1', 'k2'], [5, 1]); /* ['val0', 'val2', 'val3', 'val1'] */\n~~~\n\n### zunionstore\n-----\n_**Description**_: Creates an union of sorted sets given in second argument. The result of the union will be stored in the sorted set defined by the first argument.\n\nThe third optional argument defines `weights` to apply to the sorted sets in input. In this case, the `weights` will be multiplied by the score of each element in the sorted set before applying the aggregation.\nThe forth argument defines the `AGGREGATE` option which specify how the results of the union are aggregated.\n\n##### *Parameters*\n*keyOutput*  \n*arrayZSetKeys*  \n*arrayWeights*  \n*aggregateFunction* Either \"SUM\", \"MIN\", or \"MAX\": defines the behaviour to use on duplicate entries during the zunionstore.\n\n##### *Return value*\n*LONG* The number of values in the new sorted set.\n\n##### *Example*\n~~~php\n$redis->del('k1');\n$redis->del('k2');\n$redis->del('k3');\n$redis->del('ko1');\n$redis->del('ko2');\n$redis->del('ko3');\n\n$redis->zAdd('k1', 0, 'val0');\n$redis->zAdd('k1', 1, 'val1');\n\n$redis->zAdd('k2', 2, 'val2');\n$redis->zAdd('k2', 3, 'val3');\n\n$redis->zunionstore('ko1', ['k1', 'k2']); /* 4, 'ko1' => ['val0', 'val1', 'val2', 'val3'] */\n\n/* Weighted zunionstore */\n$redis->zunionstore('ko2', ['k1', 'k2'], [1, 1]); /* 4, 'ko2' => ['val0', 'val1', 'val2', 'val3'] */\n$redis->zunionstore('ko3', ['k1', 'k2'], [5, 1]); /* 4, 'ko3' => ['val0', 'val2', 'val3', 'val1'] */\n~~~\n\n### zScan\n-----\n_**Description**_: Scan a sorted set for members, with optional pattern and count\n\n##### *Parameters*\n*key*: String, the set to scan  \n*iterator*: Long (reference), initialized to NULL  \n*pattern*: String (optional), the pattern to match  \n*count*: How many keys to return per iteration (Redis might return a different number)\n\n##### *Return value*\n*Array, boolean* PHPRedis will return matching keys from Redis, or FALSE when iteration is complete\n\n##### *Example*\n~~~php\n$it = NULL;\n$redis->setOption(Redis::OPT_SCAN, Redis::SCAN_RETRY);\nwhile($arr_matches = $redis->zScan('zset', $it, '*pattern*')) {\n    foreach($arr_matches as $str_mem => $f_score) {\n        echo \"Key: $str_mem, Score: $f_score\\n\";\n    }\n}\n~~~\n\n## HyperLogLogs\n\n### pfAdd\n-----\n\n_**Description**_:  Adds the specified elements to the specified HyperLogLog.\n\n##### *Prototype*  \n~~~php\n$redis->pfAdd($key, Array $elements);\n~~~\n\n##### *Parameters*\n_Key_  \n_Array of values_  \n\n##### *Return value*\n*Integer*:  1 if at least 1 HyperLogLog internal register was altered. 0 otherwise.\n\n##### *Example*\n~~~php\n$redis->pfAdd('hll', ['a', 'b', 'c']); // (int) 1\n$redis->pfAdd('hll', ['a', 'b']); // (int) 0\n~~~\n\n### pfCount\n-----\n\n_**Description**_:  Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).\n\n##### *Prototype*  \n~~~php\n$redis->pfCount($key);\n$redis->pfCount(Array $keys);\n~~~\n\n##### *Parameters*\n_Key_ or _Array of keys_  \n\n##### *Return value*\n*Integer*:  The approximated number of unique elements observed via [pfAdd](#pfAdd).\n\n##### *Example*\n~~~php\n$redis->pfAdd('hll1', ['a', 'b', 'c']); // (int) 1\n$redis->pfCount('hll1'); // (int) 3\n\n$redis->pfAdd('hll2', ['d', 'e', 'a']); // (int) 1\n$redis->pfCount('hll2'); // (int) 3\n\n$redis->pfCount(['hll1', 'hll2']); // (int) 5\n~~~\n\n### pfMerge\n-----\n\n_**Description**_:  Merge N different HyperLogLogs into a single one.\n\n##### *Prototype*  \n~~~php\n$redis->pfMerge($destkey, Array $sourceKeys);\n~~~\n\n##### *Parameters*\n_Destination Key_  \n_Array of Source Keys_  \n\n##### *Return value*\n*BOOL*: `TRUE` on success, `FALSE` on error.\n\n##### *Example*\n~~~php\n$redis->pfAdd('hll1', ['a', 'b', 'c']); // (int) 1\n$redis->pfAdd('hll2', ['d', 'e', 'a']); // (int) 1\n\n$redis->pfMerge('hll3', ['hll1', 'hll2']); // true\n\n$redis->pfCount('hll3'); // (int) 5\n~~~\n\n## Geocoding\n\n### geoAdd\n-----\n\n##### *Prototype*  \n~~~php\n$redis->geoAdd($key, $longitude, $latitude, $member [, $longitude, $latitude, $member, ...]);\n~~~\n\n_**Description**_:  Add one or more geospatial items to the specified key.  This function must be called with at least one _longitude, latitude, member_ triplet.\n\n##### *Return value*\n*Integer*:  The number of elements added to the geospatial key.\n\n##### *Example*\n~~~php\n$redis->del(\"myplaces\");\n\n/* Since the key will be new, $result will be 2 */\n$result = $redis->geoAdd(\n    \"myplaces\",\n    -122.431, 37.773, \"San Francisco\",\n    -157.858, 21.315, \"Honolulu\"\n);\n~~~  \n\n### geoHash\n-----\n\n##### *Prototype*\n~~~php\n$redis->geoHash($key, $member [, $member, $member, ...]);\n~~~\n\n_**Description**_:  Retrieve Geohash strings for one or more elements of a geospatial index.  \n\n##### *Return value*  \n*Array*:  One or more Redis Geohash encoded strings.  \n\n##### *Example*  \n~~~php\n$redis->geoAdd(\"hawaii\", -157.858, 21.306, \"Honolulu\", -156.331, 20.798, \"Maui\");\n$hashes = $redis->geoHash(\"hawaii\", \"Honolulu\", \"Maui\");\nvar_dump($hashes);\n~~~\n\n##### *Output*  \n~~~\narray(2) {\n  [0]=>\n  string(11) \"87z9pyek3y0\"\n  [1]=>\n  string(11) \"8e8y6d5jps0\"\n}\n~~~\n\n### geoPos\n-----\n\n##### *Prototype*  \n~~~php\n$redis->geoPos($key, $member [, $member, $member, ...]);\n~~~\n\n_**Description**_:  Return longitude, latitude positions for each requested member.\n\n##### *Return value*  \n*Array*:  One or more longitude/latitude positions\n\n##### *Example*  \n~~~php\n$redis->geoAdd(\"hawaii\", -157.858, 21.306, \"Honolulu\", -156.331, 20.798, \"Maui\");\n$positions = $redis->geoPos(\"hawaii\", \"Honolulu\", \"Maui\");\nvar_dump($positions);\n~~~\n\n##### *Output*  \n~~~\narray(2) {\n  [0]=>\n  array(2) {\n    [0]=>\n    string(22) \"-157.85800248384475708\"\n    [1]=>\n    string(19) \"21.3060004581273077\"\n  }\n  [1]=>\n  array(2) {\n    [0]=>\n    string(22) \"-156.33099943399429321\"\n    [1]=>\n    string(20) \"20.79799924753607598\"\n  }\n}\n~~~\n\n### GeoDist  \n-----\n\n##### *Prototype*  \n~~~php\n$redis->geoDist($key, $member1, $member2 [, $unit]);\n~~~\n\n\n_**Description**_:  Return the distance between two members in a geospatial set.  If units are passed it must be one of the following values:\n\n* 'm' => Meters\n* 'km' => Kilometers\n* 'mi' => Miles\n* 'ft' => Feet\n\n##### *Return value*\n*Double*:  The distance between the two passed members in the units requested (meters by default).  \n\n##### *Example*\n~~~php\n$redis->geoAdd(\"hawaii\", -157.858, 21.306, \"Honolulu\", -156.331, 20.798, \"Maui\");\n\n$meters = $redis->geoDist(\"hawaii\", \"Honolulu\", \"Maui\");\n$kilometers = $redis->geoDist(\"hawaii\", \"Honolulu\", \"Maui\", 'km');\n$miles = $redis->geoDist(\"hawaii\", \"Honolulu\", \"Maui\", 'mi');\n$feet = $redis->geoDist(\"hawaii\", \"Honolulu\", \"Maui\", 'ft');\n\necho \"Distance between Honolulu and Maui:\\n\";\necho \"  meters    : $meters\\n\";\necho \"  kilometers: $kilometers\\n\";\necho \"  miles     : $miles\\n\";\necho \"  feet      : $feet\\n\";\n\n/* Bad unit */\n$inches = $redis->geoDist(\"hawaii\", \"Honolulu\", \"Maui\", 'in');\necho \"Invalid unit returned:\\n\";\nvar_dump($inches);\n~~~  \n\n##### *Output*  \n~~~\nDistance between Honolulu and Maui:\n  meters    : 168275.204\n  kilometers: 168.2752\n  miles     : 104.5616\n  feet      : 552084.0028\nInvalid unit returned:\nbool(false)\n~~~\n\n### geoRadius\n-----\n\n##### *Prototype*\n~~~php\n$redis->geoRadius($key, $longitude, $latitude, $radius, $unit [, Array $options]);\n~~~\n\n_**Description**_:  Return members of a set with geospatial information that are within the radius specified by the caller. \n\n##### *Options Array*\nThe georadius command can be called with various options that control how Redis returns results.  The following table describes the options phpredis supports.  All options are case insensitive.  \n\n| Key       | Value       | Description\n| :---      | :---        | :---- |\n| COUNT     | integer > 0 | Limit how many results are returned\n|           | WITHCOORD   | Return longitude and latitude of matching members\n|           | WITHDIST    | Return the distance from the center\n|           | WITHHASH    | Return the raw geohash-encoded score\n|           | ASC         | Sort results in ascending order\n|           | DESC        | Sort results in descending order\n| STORE     | _key_       | Store results in _key_\n| STOREDIST | _key_       | Store the results as distances in _key_\n\n *Note*:  It doesn't make sense to pass both `ASC` and `DESC` options but if both are passed the last one passed will be used.  \n *Note*:  When using `STORE[DIST]` in Redis Cluster, the store key must has to the same slot as the query key or you will get a `CROSSLOT` error.\n\n##### *Return value*\n*Mixed*:  When no `STORE` option is passed, this function returns an array of results.  If it is passed this function returns the number of stored entries.\n \n##### *Example*\n~~~php\n/* Add some cities */\n$redis->geoAdd(\"hawaii\", -157.858, 21.306, \"Honolulu\", -156.331, 20.798, \"Maui\");\n\necho \"Within 300 miles of Honolulu:\\n\";\nvar_dump($redis->geoRadius(\"hawaii\", -157.858, 21.306, 300, 'mi'));\n\necho \"\\nWithin 300 miles of Honolulu with distances:\\n\";\n$options = ['WITHDIST'];\nvar_dump($redis->geoRadius(\"hawaii\", -157.858, 21.306, 300, 'mi', $options));\n\necho \"\\nFirst result within 300 miles of Honolulu with distances:\\n\";\n$options['count'] = 1;\nvar_dump($redis->geoRadius(\"hawaii\", -157.858, 21.306, 300, 'mi', $options));\n\necho \"\\nFirst result within 300 miles of Honolulu with distances in descending sort order:\\n\";\n$options[] = 'DESC';\nvar_dump($redis->geoRadius(\"hawaii\", -157.858, 21.306, 300, 'mi', $options));\n~~~\n\n##### *Output*\n~~~\nWithin 300 miles of Honolulu:\narray(2) {\n  [0]=>\n  string(8) \"Honolulu\"\n  [1]=>\n  string(4) \"Maui\"\n}\n\nWithin 300 miles of Honolulu with distances:\narray(2) {\n  [0]=>\n  array(2) {\n    [0]=>\n    string(8) \"Honolulu\"\n    [1]=>\n    string(6) \"0.0002\"\n  }\n  [1]=>\n  array(2) {\n    [0]=>\n    string(4) \"Maui\"\n    [1]=>\n    string(8) \"104.5615\"\n  }\n}\n\nFirst result within 300 miles of Honolulu with distances:\narray(1) {\n  [0]=>\n  array(2) {\n    [0]=>\n    string(8) \"Honolulu\"\n    [1]=>\n    string(6) \"0.0002\"\n  }\n}\n\nFirst result within 300 miles of Honolulu with distances in descending sort order:\narray(1) {\n  [0]=>\n  array(2) {\n    [0]=>\n    string(4) \"Maui\"\n    [1]=>\n    string(8) \"104.5615\"\n  }\n}\n~~~\n\n### geoRadiusByMember\n\n##### *Prototype*\n~~~php\n$redis->geoRadiusByMember($key, $member, $radius, $units [, Array $options]);\n~~~\n\n_**Description**_: This method is identical to [geoRadius](#georadius) except that instead of passing a longitude and latitude as the \"source\" you pass an existing member in the geospatial set.\n\n##### *Options Array*\nSee [geoRadius](#georadius) command for options array.\n\n##### *Return value*\n*Array*:  The zero or more entries that are close enough to the member given the distance and radius specified.  \n\n##### *Example*\n~~~php\n$redis->geoAdd(\"hawaii\", -157.858, 21.306, \"Honolulu\", -156.331, 20.798, \"Maui\");\n\necho \"Within 300 miles of Honolulu:\\n\";\nvar_dump($redis->geoRadiusByMember(\"hawaii\", \"Honolulu\", 300, 'mi'));\n\necho \"\\nFirst match within 300 miles of Honolulu:\\n\";\nvar_dump($redis->geoRadiusByMember(\"hawaii\", \"Honolulu\", 300, 'mi', ['count' => 1]));\n~~~\n\n##### *Output*\n~~~\nWithin 300 miles of Honolulu:\narray(2) {\n  [0]=>\n  string(8) \"Honolulu\"\n  [1]=>\n  string(4) \"Maui\"\n}\n\nFirst match within 300 miles of Honolulu:\narray(1) {\n  [0]=>\n  string(8) \"Honolulu\"\n}\n~~~\n\n## Streams\n\n* [xAck](#xack) - Acknowledge one or more pending messages\n* [xAdd](#xadd) - Add a message to a stream\n* [xClaim](#xclaim) - Acquire ownership of a pending message\n* [xDel](#xdel) - Remove a message from a stream\n* [xGroup](#xgroup) - Manage consumer groups\n* [xInfo](#xinfo) - Get information about a stream\n* [xLen](#xlen) - Get the length of a stream\n* [xPending](#xpending) - Inspect pending messages in a stream\n* [xRange](#xrange) - Query a range of messages from a stream\n* [xRead](#xread) - Read message(s) from a stream\n* [xReadGroup](#xreadgroup) - Read stream messages with a group and consumer\n* [xRevRange](#xrevrange) - Query one or more messages from end to start\n* [xTrim](#xtrim) - Trim a stream's size\n\n### xAck\n-----\n\n##### *Prototype*\n~~~php\n$obj_redis->xAck($stream, $group, $arr_messages);\n~~~\n\n_**Description**_:  Acknowledge one or more messages on behalf of a consumer group.\n\n##### *Return value*\n*long*:  The number of messages Redis reports as acknowledged.\n\n##### *Example*\n~~~php\n$obj_redis->xAck('stream', 'group1', ['1530063064286-0', '1530063064286-1']);\n~~~\n\n### xAdd\n-----\n\n##### *Prototype*\n~~~php\n$obj_redis->xAdd($str_key, $str_id, $arr_message[, $i_maxlen, $boo_approximate]);\n~~~\n\n_**Description**_:  Add a message to a stream\n\n##### *Return value*\n*String*:  The added message ID\n\n##### *Example*\n~~~php\n$obj_redis->xAdd('mystream', \"*\", ['field' => 'value']);\n$obj_redis->xAdd('mystream', \"*\", ['field' => 'value'], 1000); // set max length of stream to 1000\n$obj_redis->xAdd('mystream', \"*\", ['field' => 'value'], 1000, true); // set max length of stream to ~1000\n~~~\n\n### xClaim\n-----\n\n##### *Prototype*\n~~~php\n$obj_redis->xClaim($str_key, $str_group, $str_consumer, $min_idle_time, $arr_ids, [$arr_options]);\n~~~\n\n_**Description**_:  Claim ownership of one or more pending messages.\n\n#### *Options Array*\n~~~php\n$options = [\n    /* Note:  'TIME', and 'IDLE' are mutually exclusive */\n    'IDLE' => $value, /* Set the idle time to $value ms  */,\n    'TIME' => $value, /* Set the idle time to now - $value */\n    'RETRYCOUNT' => $value, /* Update message retrycount to $value */\n    'FORCE', /* Claim the message(s) even if they're not pending anywhere */\n    'JUSTID', /* Instruct Redis to only return IDs */\n];\n~~~\n\n##### *Return value*\n*Array*:  Either an array of message IDs along with corresponding data, or just an array of IDs (if the 'JUSTID' option was passed).\n\n##### *Example*\n~~~php\n$ids = ['1530113681011-0', '1530113681011-1', '1530113681011-2'];\n\n/* Without any options */\n$obj_redis->xClaim(\n    'mystream', 'group1', 'myconsumer1', 0, $ids\n);\n\n/* With options */\n$obj_redis->xClaim(\n    'mystream', 'group1', 'myconsumer2', 0, $ids,\n    [\n        'IDLE' => time() * 1000,\n        'RETRYCOUNT' => 5,\n        'FORCE',\n        'JUSTID'\n    ]\n);\n~~~\n\n### xDel\n-----\n\n##### *Prototype*\n~~~php\n$obj_redis->xDel($str_key, $arr_ids);\n~~~\n\n_**Description**_:  Delete one or more messages from a stream.\n\n##### *Return value*\n*long*:  The number of messages removed\n\n##### *Example*\n~~~php\n$obj_redis->xDel('mystream', ['1530115304877-0', '1530115305731-0']);\n~~~\n\n### xGroup\n-----\n\n##### *Prototype*\n~~~php\n$obj_redis->xGroup('HELP');\n$obj_redis->xGroup('CREATE', $str_key, $str_group, $str_msg_id, [$boo_mkstream]);\n$obj_redis->xGroup('SETID', $str_key, $str_group, $str_msg_id);\n$obj_redis->xGroup('DESTROY', $str_key, $str_group);\n$obj_redis->xGroup('DELCONSUMER', $str_key, $str_group, $str_consumer_name);\n~~~\n\n_**Description**_:  This command is used in order to create, destroy, or manage consumer groups.\n\n##### *Return value*\n*Mixed*:  This command returns different types depending on the specific XGROUP command executed.\n\n##### *Example*\n~~~php\n$obj_redis->xGroup('CREATE', 'mystream', 'mygroup', '0');\n$obj_redis->xGroup('CREATE', 'mystream', 'mygroup2', '0', true); /* Create stream if non-existent. */\n$obj_redis->xGroup('DESTROY', 'mystream', 'mygroup');\n~~~\n\n### xInfo\n-----\n\n##### *Prototype*\n~~~php\n$obj_redis->xInfo('CONSUMERS', $str_stream, $str_group);\n$obj_redis->xInfo('GROUPS', $str_stream);\n$obj_redis->xInfo('STREAM', $str_stream [, 'FULL' [, $i_count]]);\n$obj_redis->xInfo('HELP');\n~~~\n\n_**Description**_:  Get information about a stream or consumer groups.\n\n##### *Return value*\n*Mixed*:  This command returns different types depending on which subcommand is used.\n\n##### *Example*\n~~~php\n$obj_redis->xInfo('STREAM', 'mystream');\n$obj_redis->xInfo('STREAM', 'mystream', 'FULL', 10);\n~~~\n\n### xLen\n-----\n\n##### *Prototype*\n~~~php\n$obj_redis->xLen($str_stream);\n~~~\n\n_**Description**_:  Get the length of a given stream\n\n##### *Return value*\n*Long*:  The number of messages in the stream.\n\n##### *Example*\n~~~php\n$obj_redis->xLen('mystream');\n~~~\n\n### xPending\n-----\n\n##### *Prototype*\n~~~php\n$obj_redis->xPending($str_stream, $str_group [, $str_start, $str_end, $i_count, $str_consumer]);\n~~~\n\n_**Description**_:  Get information about pending messages in a given stream.\n\n##### *Return value*\n*Array*:  Information about the pending messages, in various forms depending on the specific invocation of XPENDING.\n\n##### *Examples*\n~~~php\n$obj_redis->xPending('mystream', 'mygroup');\n$obj_redis->xPending('mystream', 'mygroup', '-', '+', 1, 'consumer-1');\n~~~\n\n### xRange\n-----\n\n##### *Prototype*\n~~~php\n$obj_redis->xRange($str_stream, $str_start, $str_end [, $i_count]);\n~~~\n\n_**Description**_:  Get a range of messages from a given stream.\n\n##### *Return value*\n*Array*:  The messages in the stream within the requested range.\n\n##### *Example*\n~~~php\n/* Get everything in this stream */\n$obj_redis->xRange('mystream', '-', '+');\n\n/* Only the first two messages */\n$obj_redis->xRange('mystream', '-', '+', 2);\n~~~\n\n### xRead\n-----\n\n##### *Prototype*\n~~~php\n$obj_redis->xRead($arr_streams [, $i_count, $i_block]);\n~~~\n\n_**Description**_:  Read data from one or more streams and only return IDs greater than sent in the command.\n\n##### *Return value*\n*Array*:  The messages in the stream newer than the IDs passed to Redis (if any).\n\n##### *Example*\n~~~php\n$obj_redis->xRead(['stream1' => '1535222584555-0', 'stream2' => '1535222584555-0']);\n\n/* --- Possible output  ---\nArray\n(\n    [stream1] => Array\n        (\n            [1535222584555-1] => Array\n                (\n                    [key:1] => val:1\n                )\n\n        )\n\n    [stream2] => Array\n        (\n            [1535222584555-1] => Array\n                (\n                    [key:1] => val:1\n                )\n\n        )\n\n)\n*/\n\n// Receive only new message ($ = last id) and wait for one new message unlimited time\n$obj_redis->xRead(['stream1' => '$'], 1, 0);\n~~~\n\n### xReadGroup\n-----\n\n##### *Prototype*\n~~~php\n$obj_redis->xReadGroup($str_group, $str_consumer, $arr_streams [, $i_count, $i_block]);\n~~~\n\n_**Description**_:  This method is similar to xRead except that it supports reading messages for a specific consumer group.\n\n##### *Return value*\n*Array*:  The messages delivered to this consumer group (if any).\n\n##### *Examples*\n~~~php\n/* Consume messages for 'mygroup', 'consumer1' */\n$obj_redis->xReadGroup('mygroup', 'consumer1', ['s1' => 0, 's2' => 0]);\n\n/* Consume messages for 'mygroup', 'consumer1' which were not consumed yet by the group */\n$obj_redis->xReadGroup('mygroup', 'consumer1', ['s1' => '>', 's2' => '>']);\n\n/* Read a single message as 'consumer2' wait for up to a second until a message arrives. */\n$obj_redis->xReadGroup('mygroup', 'consumer2', ['s1' => 0, 's2' => 0], 1, 1000);\n~~~\n\n### xRevRange\n-----\n\n##### *Prototype*\n~~~php\n$obj_redis->xRevRange($str_stream, $str_end, $str_start [, $i_count]);\n~~~\n\n_**Description**_:  This is identical to xRange except the results come back in reverse order.  Also note that Redis reverses the order of \"start\" and \"end\".\n\n##### *Return value*\n*Array*:  The messages in the range specified.\n\n##### *Example*\n~~~php\n$obj_redis->xRevRange('mystream', '+', '-');\n~~~\n\n### xTrim\n-----\n\n##### *Prototype*\n~~~php\n$obj_redis->xTrim($str_stream, $i_max_len [, $boo_approximate]);\n~~~\n\n_**Description**_:  Trim the stream length to a given maximum.  If the \"approximate\" flag is pasesed, Redis will use your size as a hint but only trim trees in whole nodes (this is more efficient).\n\n##### *Return value*\n*long*:  The number of messages trimmed from the stream.\n\n##### *Example*\n~~~php\n/* Trim to exactly 100 messages */\n$obj_redis->xTrim('mystream', 100);\n\n/* Let Redis approximate the trimming */\n$obj_redis->xTrim('mystream', 100, true);\n~~~\n\n## Pub/sub\n\n* [pSubscribe](#psubscribe) - Subscribe to channels by pattern\n* [publish](#publish) - Post a message to a channel\n* [subscribe](#subscribe) - Subscribe to channels\n* [pubSub](#pubsub) - Introspection into the pub/sub subsystem\n\n### pSubscribe\n-----\n_**Description**_: Subscribe to channels by pattern\n\n##### *Parameters*\n*patterns*: An array of patterns to match  \n*callback*: Either a string or an array with an object and method.  The callback will get four arguments ($redis, $pattern, $channel, $message)  \n*return value*: Mixed.  Any non-null return value in the callback will be returned to the caller.  \n##### *Example*\n~~~php\nfunction pSubscribe($redis, $pattern, $chan, $msg) {\n\techo \"Pattern: $pattern\\n\";\n\techo \"Channel: $chan\\n\";\n\techo \"Payload: $msg\\n\";\n}\n~~~\n\n### publish\n-----\n_**Description**_: Publish messages to channels. Warning: this function will probably change in the future.\n\n##### *Parameters*\n*channel*: a channel to publish to  \n*message*: string\n\n##### *Example*\n~~~php\n$redis->publish('chan-1', 'hello, world!'); // send message.\n~~~\n\n### subscribe\n-----\n_**Description**_: Subscribe to channels. Warning: this function will probably change in the future.\n\n##### *Parameters*\n*channels*: an array of channels to subscribe to  \n*callback*: either a string or [$instance, 'method_name']. The callback function receives 3 parameters: the redis instance, the channel name, and the message.\n*return value*:  Mixed.  Any non-null return value in the callback will be returned to the caller.\n##### *Example*\n~~~php\nfunction f($redis, $chan, $msg) {\n\tswitch($chan) {\n\t\tcase 'chan-1':\n\t\t\t...\n\t\t\tbreak;\n\n\t\tcase 'chan-2':\n\t\t\t...\n\t\t\tbreak;\n\n\t\tcase 'chan-2':\n\t\t\t...\n\t\t\tbreak;\n\t}\n}\n\n$redis->subscribe(['chan-1', 'chan-2', 'chan-3'], 'f'); // subscribe to 3 chans\n~~~\n\n### pubSub\n-----\n_**Description**_: A command allowing you to get information on the Redis pub/sub system.\n\n##### *Parameters*\n*keyword*: String, which can be: \"channels\", \"numsub\", or \"numpat\"  \n*argument*:  Optional, variant.  For the \"channels\" subcommand, you can pass a string pattern.  For \"numsub\" an array of channel names.\n\n##### *Return value*\n*CHANNELS*: Returns an array where the members are the matching channels.  \n*NUMSUB*:  Returns a key/value array where the keys are channel names and values are their counts.  \n*NUMPAT*:  Integer return containing the number active pattern subscriptions\n\n##### *Example*\n~~~php\n$redis->pubSub(\"channels\"); /*All channels */\n$redis->pubSub(\"channels\", \"*pattern*\"); /* Just channels matching your pattern */\n$redis->pubSub(\"numsub\", [\"chan1\", \"chan2\"]); /*Get subscriber counts for 'chan1' and 'chan2'*/\n$redis->pubSub(\"numpat\"); /* Get the number of pattern subscribers */\n\n\n~~~\n\n## Generic\n1. [rawCommand](#rawcommand) - Execute any generic command against the server.\n\n### rawCommand\n-----\n_**Description**_: A method to execute any arbitrary command against the a Redis server\n\n##### *Parameters*\nThis method is variadic and takes a dynamic number of arguments of various types (string, long, double), but must be passed at least one argument (the command keyword itself).\n\n##### *Return value*\nThe return value can be various types depending on what the server itself returns.   No post processing is done to the returned value and must be handled by the client code.\n\n##### *Example*\n```php\n/* Returns: true */\n$redis->rawCommand(\"set\", \"foo\", \"bar\");\n\n/* Returns: \"bar\" */\n$redis->rawCommand(\"get\", \"foo\");\n\n/* Returns: 3 */\n$redis->rawCommand(\"rpush\", \"mylist\", \"one\", 2, 3.5);\n\n/* Returns: [\"one\", \"2\", \"3.5000000000000000\"] */\n$redis->rawCommand(\"lrange\", \"mylist\", 0, -1);\n```\n\n## Transactions\n\n1. [multi, exec, discard](#multi-exec-discard) - Enter and exit transactional mode\n2. [watch, unwatch](#watch-unwatch) - Watches a key for modifications by another client.\n\n### multi, exec, discard.\n-----\n_**Description**_: Enter and exit transactional mode.\n\n##### *Parameters*\n(optional) `Redis::MULTI` or `Redis::PIPELINE`. Defaults to `Redis::MULTI`. A `Redis::MULTI` block of commands runs as a single transaction; a `Redis::PIPELINE` block is simply transmitted faster to the server, but without any guarantee of atomicity. `discard` cancels a transaction.\n\n##### *Return value*\n`multi()` returns the Redis instance and enters multi-mode. Once in multi-mode, all subsequent method calls return the same object until `exec()` is called.\n\n##### *Example*\n~~~php\n$ret = $redis->multi()\n    ->set('key1', 'val1')\n    ->get('key1')\n    ->set('key2', 'val2')\n    ->get('key2')\n    ->exec();\n\n/*\n$ret == [0 => TRUE, 1 => 'val1', 2 => TRUE, 3 => 'val2'];\n*/\n~~~\n\n### watch, unwatch\n-----\n_**Description**_: Watches a key for modifications by another client.\n\nIf the key is modified between `WATCH` and `EXEC`, the MULTI/EXEC transaction will fail (return `FALSE`). `unwatch` cancels all the watching of all keys by this client.\n\n##### *Parameters*\n*keys*: string for one key or array for a list of keys\n\n##### *Example*\n~~~php\n$redis->watch('x'); // or for a list of keys: $redis->watch(['x','another key']);\n/* long code here during the execution of which other clients could well modify `x` */\n$ret = $redis->multi()\n    ->incr('x')\n    ->exec();\n/*\n$ret = FALSE if x has been modified between the call to WATCH and the call to EXEC.\n*/\n~~~\n\n\n\n## Scripting\n\n* [eval](#eval) - Evaluate a LUA script serverside\n* [evalSha](#evalsha) - Evaluate a LUA script serverside, from the SHA1 hash of the script instead of the script itself\n* [script](#script) - Execute the Redis SCRIPT command to perform various operations on the scripting subsystem\n* [getLastError](#getlasterror) - The last error message (if any)\n* [clearLastError](#clearlasterror) - Clear the last error message\n* [_prefix](#_prefix) - A utility method to prefix the value with the prefix setting for phpredis\n* [_unserialize](#_unserialize) - A utility method to unserialize data with whatever serializer is set up\n* [_serialize](#_serialize) - A utility method to serialize data with whatever serializer is set up\n\n### eval\n-----\n_**Description**_: Evaluate a LUA script serverside\n\n##### *Parameters*\n*script* string.  \n*args* array, optional.  \n*num_keys* int, optional.\n\n##### *Return value*\nMixed.  What is returned depends on what the LUA script itself returns, which could be a scalar value (int/string), or an array.\nArrays that are returned can also contain other arrays, if that's how it was set up in your LUA script.  If there is an error\nexecuting the LUA script, the getLastError() function can tell you the message that came back from Redis (e.g. compile error).\n\n##### *Examples*\n~~~php\n$redis->eval(\"return 1\"); // Returns an integer: 1\n$redis->eval(\"return {1,2,3}\"); // Returns [1,2,3]\n$redis->del('mylist');\n$redis->rpush('mylist','a');\n$redis->rpush('mylist','b');\n$redis->rpush('mylist','c');\n// Nested response:  [1,2,3,['a','b','c']];\n$redis->eval(\"return {1,2,3,redis.call('lrange','mylist',0,-1)}\");\n~~~\n\n### evalSha\n-----\n_**Description**_: Evaluate a LUA script serverside, from the SHA1 hash of the script instead of the script itself.\n\nIn order to run this command Redis will have to have already loaded the script,\neither by running it or via the SCRIPT LOAD command.\n\n##### *Parameters*\n*script_sha* string.  The sha1 encoded hash of the script you want to run.  \n*args* array, optional.  Arguments to pass to the LUA script.  \n*num_keys* int, optional.  The number of arguments that should go into the KEYS array, vs. the ARGV array when Redis spins the script\n\n##### *Return value*\nMixed.  See EVAL\n\n##### *Examples*\n~~~php\n$script = 'return 1';\n$sha = $redis->script('load', $script);\n$redis->evalSha($sha); // Returns 1\n~~~\n\n### script\n-----\n_**Description**_: Execute the Redis SCRIPT command to perform various operations on the scripting subsystem.\n\n##### *Usage*\n~~~php\n$redis->script('load', $script);\n$redis->script('flush');\n$redis->script('kill');\n$redis->script('exists', $script1, [$script2, $script3, ...]);\n~~~\n\n##### *Return value*\n* SCRIPT LOAD will return the SHA1 hash of the passed script on success, and FALSE on failure.\n* SCRIPT FLUSH should always return TRUE\n* SCRIPT KILL will return true if a script was able to be killed and false if not\n* SCRIPT EXISTS will return an array with TRUE or FALSE for each passed script\n\n### client\n-----\n_**Description**_: Issue the CLIENT command with various arguments.\n\nThe Redis CLIENT command can be used in four ways.\n* CLIENT LIST\n* CLIENT GETNAME\n* CLIENT SETNAME [name]\n* CLIENT KILL [ip:port]\n\n##### *Usage*\n~~~php\n$redis->client('list'); // Get a list of clients\n$redis->client('getname'); // Get the name of the current connection\n$redis->client('setname', 'somename'); // Set the name of the current connection\n$redis->client('kill', <ip:port>); // Kill the process at ip:port\n~~~\n\n##### *Return value*\nThis will vary depending on which client command was executed.\n\n* CLIENT LIST will return an array of arrays with client information.\n* CLIENT GETNAME will return the client name or false if none has been set\n* CLIENT SETNAME will return true if it can be set and false if not\n* CLIENT KILL will return true if the client can be killed, and false if not\n\nNote:  phpredis will attempt to reconnect so you can actually kill your own connection\nbut may not notice losing it!\n### getLastError\n-----\n_**Description**_: The last error message (if any)\n\n##### *Parameters*\n*none*\n\n##### *Return value*\nA string with the last returned script based error message, or NULL if there is no error\n\n##### *Examples*\n~~~php\n$redis->eval('this-is-not-lua');\n$err = $redis->getLastError();\n// \"ERR Error compiling script (new function): user_script:1: '=' expected near '-'\"\n~~~\n\n### clearLastError\n-----\n_**Description**_: Clear the last error message\n\n##### *Parameters*\n*none*\n\n##### *Return value*\n*BOOL* TRUE\n\n##### *Examples*\n~~~php\n$redis->set('x', 'a');\n$redis->incr('x');\n$err = $redis->getLastError();\n// \"ERR value is not an integer or out of range\"\n$redis->clearLastError();\n$err = $redis->getLastError();\n// NULL\n~~~\n\n### _prefix\n-----\n_**Description**_: A utility method to prefix the value with the prefix setting for phpredis.\n\n##### *Parameters*\n*value* string.  The value you wish to prefix\n\n##### *Return value*\nIf a prefix is set up, the value now prefixed.  If there is no prefix, the value will be returned unchanged.\n\n##### *Examples*\n~~~php\n$redis->setOption(Redis::OPT_PREFIX, 'my-prefix:');\n$redis->_prefix('my-value'); // Will return 'my-prefix:my-value'\n~~~\n\n### _serialize\n-----\n_**Description**_: A utility method to serialize values manually.\n\nThis method allows you to serialize a value with whatever serializer is configured, manually.\nThis can be useful for serialization/unserialization of data going in and out of EVAL commands\nas phpredis can't automatically do this itself.  Note that if no serializer is set, phpredis\nwill change Array values to 'Array', and Objects to 'Object'.\n\n##### *Parameters*\n*value*:  Mixed.  The value to be serialized\n\n##### *Examples*\n~~~php\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_NONE);\n$redis->_serialize(\"foo\"); // returns \"foo\"\n$redis->_serialize([]); // Returns \"Array\"\n$redis->_serialize(new stdClass()); // Returns \"Object\"\n\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP);\n$redis->_serialize(\"foo\"); // Returns 's:3:\"foo\";'\n~~~\n\n### _unserialize\n-----\n_**Description**_: A utility method to unserialize data with whatever serializer is set up.\n\nIf there is no serializer set, the value will be returned unchanged.  If there is a serializer set up,\nand the data passed in is malformed, an exception will be thrown. This can be useful if phpredis is\nserializing values, and you return something from redis in a LUA script that is serialized.\n\n##### *Parameters*\n*value* string.  The value to be unserialized\n\n##### *Examples*\n~~~php\n$redis->setOption(Redis::OPT_SERIALIZER, Redis::SERIALIZER_PHP);\n$redis->_unserialize('a:3:{i:0;i:1;i:1;i:2;i:2;i:3;}'); // Will return [1,2,3]\n~~~\n\n\n\n## Introspection\n\n### isConnected\n-----\n_**Description**_:  A method to determine if a phpredis object thinks it's connected to a server\n\n##### *Parameters*\nNone\n\n##### *Return value*\n*Boolean* Returns TRUE if phpredis thinks it's connected and FALSE if not\n\n### getHost\n-----\n_**Description**_:  Retrieve our host or unix socket that we're connected to\n\n##### *Parameters*\nNone\n\n##### *Return value*\n*Mixed* The host or unix socket we're connected to or FALSE if we're not connected\n\n\n### getPort\n-----\n_**Description**_:  Get the port we're connected to\n\n##### *Parameters*\nNone\n\n##### *Return value*\n*Mixed* Returns the port we're connected to or FALSE if we're not connected\n\n### getDbNum\n-----\n_**Description**_:  Get the database number phpredis is pointed to\n\n##### *Parameters*\nNone\n\n##### *Return value*\n*Mixed* Returns the database number (LONG) phpredis thinks it's pointing to or FALSE if we're not connected\n\n### getTimeout\n-----\n_**Description**_:  Get the (write) timeout in use for phpredis\n\n##### *Parameters*\nNone\n\n##### *Return value*\n*Mixed* The timeout (DOUBLE) specified in our connect call or FALSE if we're not connected\n\n### getReadTimeout\n_**Description**_:  Get the read timeout specified to phpredis or FALSE if we're not connected\n\n##### *Parameters*\nNone\n\n##### *Return value*\n*Mixed*  Returns the read timeout (which can be set using setOption and Redis::OPT_READ_TIMEOUT) or FALSE if we're not connected\n\n### getPersistentID\n-----\n_**Description**_:  Gets the persistent ID that phpredis is using\n\n##### *Parameters*\nNone\n\n##### *Return value*\n*Mixed* Returns the persistent id phpredis is using (which will only be set if connected with pconnect), NULL if we're not\nusing a persistent ID, and FALSE if we're not connected\n\n### getAuth\n-----\n_**Description**_:  Get the password (or username and password if using Redis 6 ACLs) used to authenticate the connection.\n\n### *Parameters*\nNone\n\n### *Return value*\n*Mixed*  Returns NULL if no username/password are set, the password string if a password is set, and a `[username, password]` array if authenticated with a username and password.\n"
        },
        {
          "name": "arrays.md",
          "type": "blob",
          "size": 9.775390625,
          "content": "Redis Arrays\n============\n\nA Redis array is an isolated namespace in which keys are related in some manner. Keys are distributed across a number of Redis instances, using consistent hashing. A hash function is used to spread the keys across the array in order to keep a uniform distribution. **This feature was added as the result of a generous sponsorship by [A+E Networks](http://www.aetn.com/).**\n\nAn array is composed of the following:\n\n* A list of Redis hosts.\n* A key extraction function, used to hash part of the key in order to distribute related keys on the same node (optional). This is set by the \"function\" option.\n* A list of nodes previously in the ring, only present after a node has been added or removed. When a read command is sent to the array (e.g. GET, LRANGE...), the key is first queryied in the main ring, and then in the secondary ring if it was not found in the main one. Optionally, the keys can be migrated automatically when this happens. Write commands will always go to the main ring. This is set by the \"previous\" option.\n* An optional index in the form of a Redis set per node, used to migrate keys when nodes are added or removed; set by the \"index\" option.\n* An option to rehash the array automatically as nodes are added or removed, set by the \"autorehash\" option.\n\n## Creating an array\n\nThere are several ways of creating Redis arrays;  they can be pre-defined in redis.ini using `new RedisArray(string $name);`, or created dynamically using `new RedisArray(array $hosts, array $options);`\n\n#### Declaring a new array with a list of nodes\n<pre>\n$ra = new RedisArray(array(\"host1\", \"host2:63792\", \"host2:6380\"));\n</pre>\n\n\n#### Declaring a new array with a list of nodes and a function to extract a part of the key\n<pre>\nfunction extract_key_part($k) {\n    return substr($k, 0, 3);\t// hash only on first 3 characters.\n}\n$ra = new RedisArray(array(\"host1\", \"host2:63792\", \"host2:6380\"), array(\"function\" => \"extract_key_part\"));\n</pre>\n\n#### Defining a \"previous\" array when nodes are added or removed.\nWhen a new node is added to an array, phpredis needs to know about it. The old list of nodes becomes the ‚Äúprevious‚Äù array, and the new list of nodes is used as a main ring. Right after a node has been added, some read commands will point to the wrong nodes and will need to look up the keys in the previous ring.\n\n<pre>\n// adding host3 to a ring containing host1 and host2. Read commands will look in the previous ring if the data is not found in the main ring.\n$ra = new RedisArray(array(\"host1\", \"host2\", \"host3\"), array(\"previous\" => array(\"host1\", \"host2\")));\n</pre>\n\n#### Specifying the \"retry_interval\" parameter\nThe retry_interval is used to specify a delay in milliseconds between reconnection attempts in case the client loses connection with a server\n<pre>\n$ra = new RedisArray(array(\"host1\", \"host2:63792\", \"host2:6380\"), array(\"retry_interval\" => 100));\n</pre>\n\n#### Specifying the \"lazy_connect\" parameter\nThis option is useful when a cluster has many shards but not of them are necessarily used at one time.\n<pre>\n$ra = new RedisArray(array(\"host1\", \"host2:63792\", \"host2:6380\"), array(\"lazy_connect\" => true));\n</pre>\n\n#### Specifying the \"connect_timeout\" parameter\nThe connect_timeout value is a double and is used to specify a timeout in number of seconds when creating redis socket connections used in the RedisArray.\n<pre>\n$ra = new RedisArray(array(\"host1\", \"host2:63792\", \"host2:6380\"), array(\"connect_timeout\" => 0.5));\n</pre>\n\n#### Specifying the \"read_timeout\" parameter\nThe read_timeout value is a double and is used to specify a timeout in number of seconds when waiting response from the server.\n<pre>\n$ra = new RedisArray(array(\"host1\", \"host2:63792\", \"host2:6380\"), array(\"read_timeout\" => 0.5));\n</pre>\n\n#### Specifying the \"algorithm\" parameter\nThe algorithm value is a string and is used to specify the name of key hashing algorithm. The list of possible values may be found using PHP function `hash_algos`.\nIf algorithm is not supported by PHP `hash` function default algorithm will be used (CRC32 with 0xffffffff initial value).\n<pre>\n$ra = new RedisArray(array(\"host1\", \"host2:63792\", \"host2:6380\"), array(\"algorithm\" => \"md5\"));\n</pre>\n\n#### Specifying the \"consistent\" parameter\nThe value is boolean. When enabled RedisArray uses \"ketama\" distribution algorithm (currently without ability to set weight to each server).\nThis option applies to main and previous ring if specified.\n<pre>\n$ra = new RedisArray(array(\"host1\", \"host2:63792\", \"host2:6380\"), array(\"consistent\" => true));\n</pre>\n\n#### Specifying the \"auth\" parameter\nThe value is string and used to specify the password for authenticate with the server prior to sending commands\n<pre>\n$ra = new RedisArray(array(\"host1\", \"host2:63792\", \"host2:6380\"), array(\"auth\" => \"mysecretpassword\"));\n</pre>\n\n#### Defining arrays in Redis.ini\n\nBecause php.ini parameters must be pre-defined, Redis Arrays must all share the same .ini settings.\n\n<pre>\n// list available Redis Arrays\nini_set('redis.array.names', 'users,friends');\n\n// set host names for each array.\nini_set('redis.arrays.hosts', 'users[]=localhost:6379&users[]=localhost:6380&users[]=localhost:6381&users[]=localhost:6382&friends[]=localhost');\n\n// set functions\nini_set('redis.arrays.functions', 'users=user_hash');\n\n// use index only for users\nini_set('redis.arrays.index', 'users=1,friends=0');\n\n// use password for authentication\nini_set('redis.arrays.auth', 'users=mysecretpassword')\n</pre>\n\n## Usage\n\nRedis arrays can be used just as Redis objects:\n<pre>\n$ra = new RedisArray(\"users\");\n$ra->set(\"user1:name\", \"Joe\");\n$ra->set(\"user2:name\", \"Mike\");\n</pre>\n\n\n## Key hashing\nBy default and in order to be compatible with other libraries, phpredis will try to find a substring enclosed in curly braces within the key name, and use it to distribute the data.\n\nFor instance, the keys ‚Äú{user:1}:name‚Äù and ‚Äú{user:1}:email‚Äù will be stored on the same server as only ‚Äúuser:1‚Äù will be hashed. You can provide a custom function name in your redis array with the \"function\" option; this function will be called every time a key needs to be hashed. It should take a string and return a string.\n\n\n## Custom key distribution function\nIn order to control the distribution of keys by hand, you can provide a custom function or closure that returns the server number, which is the index in the array of servers that you created the RedisArray object with.\n\nFor instance, instantiate a RedisArray object with `new RedisArray([\"us-host\", \"uk-host\", \"de-host\"], [\"distributor\" => \"dist\"]);` and write a function called \"dist\" that will return `2` for all the keys that should end up on the \"de-host\" server.\n\n### Example\n<pre>\n$ra = new RedisArray(array(\"host1\", \"host2\", \"host3\", \"host4\", \"host5\", \"host6\", \"host7\", \"host8\"), array(\"distributor\" => array(2, 2)));\n</pre>\n\nThis declares that we started with 2 shards and moved to 4 then 8 shards. The number of initial shards is 2 and the resharding level (or number of iterations) is 2.\n\n## Migrating keys\n\nWhen a node is added or removed from a ring, RedisArray instances must be instantiated with a ‚Äúprevious‚Äù list of nodes. A single call to `$ra->_rehash()` causes all the keys to be redistributed according to the new list of nodes. Passing a callback function to `_rehash()` makes it possible to track the progress of that operation: the function is called with a node name and a number of keys that will be examined, e.g. `_rehash(function ($host, $count){ ... });`.\n\nIt is possible to automate this process, by setting `'autorehash' => TRUE` in the constructor options. This will cause keys to be migrated when they need to be read from the previous array.\n\nIn order to migrate keys, they must all be examined and rehashed. If the \"index\" option was set, a single key per node lists all keys present there. Otherwise, the `KEYS` command is used to list them.\nIf a ‚Äúprevious‚Äù list of servers is provided, it will be used as a backup ring when keys can not be found in the current ring. Writes will always go to the new ring, whilst reads will go to the new ring first, and to the second ring as a backup.\n\nAdding and/or removing several instances is supported.\n\n### Example\n<pre>\n$ra = new RedisArray(\"users\"); // load up a new config from redis.ini, using the ‚Äú.previous‚Äù listing.\n$ra->_rehash();\n</pre>\n\nRunning this code will:\n\n* Create a new ring with the updated list of nodes.\n* Server by server, look up all the keys in the previous list of nodes.\n* Rehash each key and possibly move it to another server.\n* Update the array object with the new list of nodes.\n\n## Multi/exec\nMulti/exec is still available, but must be run on a single node:\n<pre>\n$host = $ra->_target(\"{users}:user1:name\");\t// find host first\n$ra->multi($host)\t// then run transaction on that host.\n   ->del(\"{users}:user1:name\")\n   ->srem(\"{users}:index\", \"user1\")\n   ->exec();\n</pre>\n\n## Limitations\nKey arrays offer no guarantee when using Redis commands that span multiple keys. Except for the use of MGET, MSET, and DEL, a single connection will be used and all the keys read or written there.  Running KEYS() on a RedisArray object will execute the command on each node and return an associative array of keys, indexed by host name.\n\n## Array info\nRedisArray objects provide several methods to help understand the state of the cluster. These methods start with an underscore.\n\n* `$ra->_hosts()` ‚Üí returns a list of hosts for the selected array.\n* `$ra->_function()` ‚Üí returns the name of the function used to extract key parts during consistent hashing.\n* `$ra->_target($key)` ‚Üí returns the host to be used for a certain key.\n* `$ra->_instance($host)` ‚Üí returns a redis instance connected to a specific node; use with `_target` to get a single Redis object.\n* `$ra->_continuum()` ‚Üí returns a list of points on continuum; may be useful with custom distributor function.\n\n## Running the unit tests\n<pre>\n$ cd tests\n$ ./mkring.sh start\n$ php array-tests.php\n</pre>\n\n"
        },
        {
          "name": "backoff.c",
          "type": "blob",
          "size": 2.7744140625,
          "content": "#include \"common.h\"\n\n#if PHP_VERSION_ID < 80400\n#include <ext/standard/php_rand.h>\n#else\n#include <ext/random/php_random.h>\n#endif\n\n#include \"backoff.h\"\n\nstatic zend_ulong random_range(zend_ulong min, zend_ulong max) {\n    if (max < min) {\n        return php_mt_rand_range(max, min);\n    }\n\n    return php_mt_rand_range(min, max);\n}\n\nstatic zend_ulong redis_default_backoff(struct RedisBackoff *self, unsigned int retry_index) {\n    zend_ulong backoff = retry_index ? self->base : random_range(0, self->base);\n    return MIN(self->cap, backoff);\n}\n\nstatic zend_ulong redis_constant_backoff(struct RedisBackoff *self, unsigned int retry_index) {\n    zend_ulong backoff = self->base;\n    return MIN(self->cap, backoff);\n}\n\nstatic zend_ulong redis_uniform_backoff(struct RedisBackoff *self, unsigned int retry_index) {\n    zend_ulong backoff = random_range(0, self->base);\n    return MIN(self->cap, backoff);\n}\n\nstatic zend_ulong redis_exponential_backoff(struct RedisBackoff *self, unsigned int retry_index) {\n    zend_ulong pow = MIN(retry_index, 10);\n    zend_ulong backoff = self->base * (1 << pow);\n    return MIN(self->cap, backoff);\n}\n\nstatic zend_ulong redis_full_jitter_backoff(struct RedisBackoff *self, unsigned int retry_index) {\n    zend_ulong pow = MIN(retry_index, 10);\n    zend_ulong backoff = self->base * (1 << pow);\n    zend_ulong cap = MIN(self->cap, backoff);\n    return random_range(0, cap);\n}\n\nstatic zend_ulong redis_equal_jitter_backoff(struct RedisBackoff *self, unsigned int retry_index) {\n    zend_ulong pow = MIN(retry_index, 10);\n    zend_ulong backoff = self->base * (1 << pow);\n    zend_ulong temp = MIN(self->cap, backoff);\n    return temp / 2 + random_range(0, temp) / 2;\n}\n\nstatic zend_ulong redis_decorrelated_jitter_backoff(struct RedisBackoff *self, unsigned int retry_index) {\n    self->previous_backoff = random_range(self->base, self->previous_backoff * 3);\n    return MIN(self->cap, self->previous_backoff);\n}\n\ntypedef zend_ulong (*redis_backoff_algorithm)(struct RedisBackoff *self, unsigned int retry_index);\n\nstatic redis_backoff_algorithm redis_backoff_algorithms[REDIS_BACKOFF_ALGORITHMS] = {\n    redis_default_backoff,\n    redis_decorrelated_jitter_backoff,\n    redis_full_jitter_backoff,\n    redis_equal_jitter_backoff,\n    redis_exponential_backoff,\n    redis_uniform_backoff,\n    redis_constant_backoff,\n};\n\nvoid redis_initialize_backoff(struct RedisBackoff *self, unsigned long retry_interval) {\n    self->algorithm = 0; // default backoff\n    self->base = retry_interval;\n    self->cap = retry_interval;\n    self->previous_backoff = 0;\n}\n\nvoid redis_backoff_reset(struct RedisBackoff *self) {\n    self->previous_backoff = 0;\n}\n\nzend_ulong redis_backoff_compute(struct RedisBackoff *self, unsigned int retry_index) {\n    return redis_backoff_algorithms[self->algorithm](self, retry_index);\n}\n"
        },
        {
          "name": "backoff.h",
          "type": "blob",
          "size": 0.6494140625,
          "content": "#ifndef REDIS_BACKOFF_H\n#define REDIS_BACKOFF_H\n\n/* {{{ struct RedisBackoff */\nstruct RedisBackoff {\n    unsigned int algorithm;        /* index of algorithm function, returns backoff in microseconds*/\n    zend_ulong   base;             /* base backoff in microseconds */\n    zend_ulong   cap;              /* max backoff in microseconds */\n    zend_ulong   previous_backoff; /* previous backoff in microseconds */\n};\n/* }}} */\n\nvoid redis_initialize_backoff(struct RedisBackoff *self, unsigned long retry_interval);\nvoid redis_backoff_reset(struct RedisBackoff *self);\nzend_ulong redis_backoff_compute(struct RedisBackoff *self, unsigned int retry_index);\n\n#endif\n"
        },
        {
          "name": "cluster.md",
          "type": "blob",
          "size": 12.4775390625,
          "content": "Redis Cluster\n=============\n\nRedis introduces cluster support as of version 3.0.0, and to communicate with a cluster using phpredis one needs to use the RedisCluster class.  For the majority of operations the RedisCluster class can act as a drop-in replacement for the Redis class without needing to modify how it's called. **This feature was added as the result of a generous sponsorship by [Tradesy](https://www.tradesy.com/)**\n\n## Creating and connecting to a cluster\n\nTo maintain consistency with the RedisArray class, one can create and connect to a cluster either by passing it one or more 'seed' nodes, or by defining these in redis.ini as a 'named' cluster.\n\n#### Declaring a cluster with an array of seeds\n```php\n// Create a cluster setting three nodes as seeds\n$obj_cluster = new RedisCluster(NULL, ['host:7000', 'host:7001', 'host:7003']);\n\n// Connect and specify timeout and read_timeout\n$obj_cluster = new RedisCluster(NULL, [\"host:7000\", \"host:7001\"], 1.5, 1.5);\n\n// Connect with read/write timeout as well as specify that phpredis should use\n// persistent connections to each node.\n$obj_cluster = new RedisCluster(NULL, [\"host:7000\", \"host:7001\"], 1.5, 1.5, true);\n\n// Connect with cluster using password.\n$obj_cluster = new RedisCluster(NULL, [\"host:7000\", \"host:7001\"], 1.5, 1.5, true, \"password\");\n\n// Connect with cluster using TLS\n// last argument is an optional array with [SSL context options](https://www.php.net/manual/en/context.ssl.php) (TLS options)\n// If value is array (even empty), it will connect via TLS.  If not, it will connect without TLS.\n// Note: If the seeds start with \"ssl:// or tls://\", it will connect to the seeds via TLS, but the subsequent connections will connect without TLS if this value is null.  So, if your nodes require TLS, this value must be an array, even if empty.\n$obj_cluster = new RedisCluster(NULL, [\"host:7000\", \"host:7001\"], 1.5, 1.5, true, NULL, [\"verify_peer\" => false]);\n```\n\n#### Loading a cluster configuration by name\nIn order to load a named array, one must first define the seed nodes in redis.ini.  The following lines would define the cluster 'mycluster', and be loaded automatically by phpredis.\n\n```ini\n# In redis.ini\nredis.clusters.seeds = \"mycluster[]=localhost:7000&test[]=localhost:7001\"\nredis.clusters.timeout = \"mycluster=5\"\nredis.clusters.read_timeout = \"mycluster=10\"\nredis.clusters.auth = \"mycluster=password\"\n```\n\nThen, this cluster can be loaded by doing the following\n\n```php\n$obj_cluster = new RedisCluster('mycluster');\n```\n\n## Connection process\n\nOn construction, the RedisCluster class will iterate over the provided seed nodes until it can attain a connection to the cluster and run CLUSTER SLOTS to map every node in the cluster locally.  Once the keyspace is mapped, RedisCluster will only connect to nodes when it needs to (e.g. you're getting a key that we believe is on that node.)\n\n## Slot caching\nEach time the `RedisCluster` class is constructed from scratch, phpredis needs to execute a `CLUSTER SLOTS` command to map the keyspace.  Although this isn't an expensive command, it does require a round trip for each newly created object, which is inefficient.  Starting from PhpRedis 5.0.0 these slots can be cached by setting `redis.clusters.cache_slots = 1` in `php.ini`.\n\n## Timeouts\nBecause Redis cluster is intended to provide high availability, timeouts do not work in the same way they do in normal socket communication.  It's fully possible to have a timeout or even exception on a given socket (say in the case that a master node has failed), and continue to serve the request if and when a slave can be promoted as the new master.\n\nThe way RedisCluster handles user specified timeout values is that every time a command is sent to the cluster, we record the time at the start of the request and then again every time we have to re-issue the command to a different node (either because Redis cluster responded with MOVED/ASK or because we failed to communicate with a given node).  Once we detect having been in the command loop for longer than our specified timeout, an error is raised.\n\n## Keyspace map\nAs previously described, RedisCluster makes an initial mapping of every master (and any slaves) on construction, which it uses to determine which nodes to direct a given command.  However, one of the core functionalities of Redis cluster is that this keyspace can change while the cluster is running.\n\nBecause of this, the RedisCluster class will update its keyspace mapping whenever it receives a MOVED error when requesting data.  In the case that we receive ASK redirection, it follows the Redis specification and requests the key from the ASK node, prefixed with an ASKING command.\n\n## Automatic slave failover / distribution\nBy default, RedisCluster will only ever send commands to master nodes, but can be configured differently for readonly commands if requested.\n\n```php\n// The default option, only send commands to master nodes\n$obj_cluster->setOption(RedisCluster::OPT_SLAVE_FAILOVER, RedisCluster::FAILOVER_NONE);\n\n// In the event we can't reach a master, and it has slaves, failover for read commands\n$obj_cluster->setOption(RedisCluster::OPT_SLAVE_FAILOVER, RedisCluster::FAILOVER_ERROR);\n\n// Always distribute readonly commands between masters and slaves, at random\n$obj_cluster->setOption(\n    RedisCluster::OPT_SLAVE_FAILOVER, RedisCluster::FAILOVER_DISTRIBUTE\n);\n\n// Always distribute readonly commands to the slaves, at random\n$obj_cluster->setOption(\n    RedisCluster::OPT_SLAVE_FAILOVER, RedisCluster::FAILOVER_DISTRIBUTE_SLAVES\n);\n```\n\n## Main command loop\nWith the exception of commands that are directed to a specific node, each command executed via RedisCluster is processed through a command loop, where we make the request, handle any MOVED or ASK redirection, and repeat if necessary.  This continues until one of the following conditions is met:\n\n1.  We fail to communicate with *any* node that we are aware of, in which case a `RedisClusterException` is raised.\n2.  We have been bounced around longer than the timeout which was set on construction.\n3.  Redis cluster returns to us a `CLUSTERDOWN` error, in which case a `RedisClusterException` is raised.\n4.  We receive a valid response, in which case the data is returned to the caller.\n\n## Transactions\nThe RedisCluster class fully supports MULTI ... EXEC transactions, including commands such as MGET and MSET which operate on multiple keys.  There are considerations that must be taken into account here however.\n\nWhen you call `RedisCluster->multi()`, the cluster is put into a MULTI state, but the MULTI command is not delivered to any nodes until a key is requested on that node.  In addition, calls to EXEC will always return an array (even in the event that a transaction to a given node failed), as the commands can be going to any number of nodes depending on what is called.\n\nConsider the following example:\n\n```php\n// Cluster is put into MULTI state locally\n$obj_cluster->multi();\n\n// The cluster will issue MULTI on this node first (and only once)\n$obj_cluster->get(\"mykey\");\n$obj_cluster->set(\"mykey\", \"new_value\");\n\n// If 'myotherkey' maps to a different node, MULTI will be issued there\n// before requesting the key\n$obj_cluster->get(\"myotherkey\");\n\n// This will always return an array, even in the event of a failed transaction\n// on one of the nodes, in which case that element will be FALSE\nprint_r($obj_cluster->exec());\n```\n\n## Pipelining\nThe RedisCluster class does not support pipelining as there is no way to detect whether the keys still live where our map indicates that they do and would therefore be inherently unsafe.  It would be possible to implement this support as an option if there is demand for such a feature.\n\n## Multiple key commands\nRedis cluster does allow commands that operate on multiple keys, but only if all of those keys hash to the same slot.  Note that it is not enough that the keys are all on the same node, but must actually hash to the exact same hash slot.\n\nFor all of these multiple key commands (with the exception of MGET and MSET), the RedisCluster class will verify each key maps to the same hash slot and raise a \"CROSSSLOT\" warning, returning false if they don't.\n\n### MGET, MSET, DEL, and UNLINK\nRedisCluster has specialized processing for MGET, MSET, DEL, and UNLINK which allows you to send any number of keys (hashing to whichever slots) without having to consider where they live.  The way this works, is that the RedisCluster class will split the command as it iterates through keys, delivering a subset of commands per each key's slot.\n\n*Note:  If you send keys that hash to more than one slot, these commands are no longer atomic.*\n\n```php\n// This will send two `MGET` commands.  One for `{hash1}` keys, and one for `otherkey`\n$obj_cluster->mget([\"{hash1}key1\",\"{hash1}key2\",\"{hash1}key3\",\"otherkey\"]);\n```\n\nThis operation can also be done in MULTI mode transparently.\n\n## Directed node commands\nThere are a variety of commands which have to be directed at a specific node.  In the case of these commands, the caller can either pass a key (which will be hashed and used to direct our command), or an array with host:port.\n\n```php\n// This will be directed at the slot/node which would store \"mykey\"\n$obj_cluster->echo(\"mykey\",\"Hello World!\");\n\n// Here we're iterating all of our known masters, and delivering the command there\nforeach ($obj_cluster->_masters() as $arr_master) {\n\t$obj_cluster->echo($arr_master, \"Hello: \" . implode(':', $arr_master));\n}\n```\n\nIn the case of all commands which need to be directed at a node, the calling convention is identical to the Redis call, except that they require an additional (first) argument in order to deliver the command.  Following is a list of each of these commands:\n\n1. ACL\n1. BGREWRITEAOF\n1. BGSAVE\n1. CLIENT\n1. CLUSTER\n1. CONFIG\n1. DBSIZE\n1. ECHO\n1. FLUSHALL\n1. FLUSHDB\n1. INFO\n1. LASTSAVE\n1. PING\n1. PUBSUB\n1. RANDOMKEY\n1. RAWCOMMAND\n1. ROLE\n1. SAVE\n1. SCAN\n1. SCRIPT\n1. SLOWLOG\n1. TIME\n\n## Session Handler\nYou can use the cluster functionality of phpredis to store PHP session information in a Redis cluster as you can with a non cluster-enabled Redis instance.\n\nTo do this, you must configure your `session.save_handler` and `session.save_path` INI variables to give phpredis enough information to communicate with the cluster.\n\n```ini\nsession.save_handler = rediscluster\nsession.save_path = \"seed[]=host1:port1&seed[]=host2:port2&seed[]=hostN:portN&timeout=2&read_timeout=2&failover=error&persistent=1&auth=password&stream[verify_peer]=0\"\n```\n\n### session.session_handler\nSet this variable to \"rediscluster\" to inform phpredis that this is a cluster instance.\n\n### session.save_path\nThe save path for cluster based session storage takes the form of a PHP GET request, and requires that you specify at least one `seed` node.  Other options you can specify are as follows:\n\n* _timeout (double)_:  The amount of time phpredis will wait when connecting or writing to the cluster.\n* _read\\_timeout (double)_: The amount of time phpredis will wait for a result from the cluster.\n* _persistent_: Tells phpredis whether persistent connections should be used.\n* _failover (string)_:  How phpredis should distribute session reads between master and slave nodes.\n  * _none_ : phpredis will only communicate with master nodes\n  * _error_: phpredis will communicate with master nodes unless one fails, in which case an attempt will be made to read session information from a slave.\n  * _distribute_: phpredis will randomly distribute session reads between masters and any attached slaves (load balancing).\n* _auth (string, empty by default)_:  The password used to authenticate with the server prior to sending commands.\n* _stream (array)_: ssl/tls stream context options.\n\n### redis.session.early_refresh\nUnder normal operation, the client will refresh the session's expiry ttl whenever the session is closed. However, we can save this additional round-trip by updating the ttl when the session is opened instead ( This means that sessions that have not been modified will not send further commands to the server ).\n\nTo enable, set the following INI variable:\n```ini\nredis.session.early_refresh = 1\n```\nNote: This is disabled by default since it may significantly reduce the session lifetime for long-running scripts. Redis server version 6.2+ required.\n\n### Session compression\n\nFollowing INI variables can be used to configure session compression:\n~~~\n; Should session compression be enabled? Possible values are zstd, lzf, lz4, none. Defaults to: none\nredis.session.compression = zstd\n; What compression level should be used? Compression level depends on used library. For most deployments range 1-9 should be fine. Defaults to: 3\nredis.session.compression_level = 3\n~~~\n"
        },
        {
          "name": "cluster_library.c",
          "type": "blob",
          "size": 94.1611328125,
          "content": "#include \"php_redis.h\"\n#include \"common.h\"\n#include \"library.h\"\n#include \"redis_commands.h\"\n#include \"cluster_library.h\"\n#include \"crc16.h\"\n#include <zend_exceptions.h>\n\nextern zend_class_entry *redis_cluster_exception_ce;\nint le_cluster_slot_cache;\n\n/* Debugging methods/\nstatic void cluster_dump_nodes(redisCluster *c) {\n    redisClusterNode *p;\n\n    ZEND_HASH_FOREACH_PTR(c->nodes, p) {\n        if (p == NULL) {\n            continue;\n        }\n\n        const char *slave = (p->slave) ? \"slave\" : \"master\";\n        php_printf(\"%d %s %d %d\", p->sock->port, slave,p->sock->prefix_len,\n            p->slot);\n\n        php_printf(\"\\n\");\n    } ZEND_HASH_FOREACH_END();\n}\n\nstatic void cluster_log(char *fmt, ...)\n{\n    va_list args;\n    char buffer[1024];\n\n    va_start(args, fmt);\n    vsnprintf(buffer,sizeof(buffer),fmt,args);\n    va_end(args);\n\n    fprintf(stderr, \"%s\\n\", buffer);\n}\n\n// Debug function to dump a clusterReply structure recursively\nstatic void dump_reply(clusterReply *reply, int indent) {\n    smart_string buf = {0};\n    int i;\n\n    switch(reply->type) {\n        case TYPE_ERR:\n            smart_string_appendl(&buf, \"(error) \", sizeof(\"(error) \")-1);\n            smart_string_appendl(&buf, reply->str, reply->len);\n            break;\n        case TYPE_LINE:\n            smart_string_appendl(&buf, reply->str, reply->len);\n            break;\n        case TYPE_INT:\n            smart_string_appendl(&buf, \"(integer) \", sizeof(\"(integer) \")-1);\n            smart_string_append_long(&buf, reply->integer);\n            break;\n        case TYPE_BULK:\n            smart_string_appendl(&buf,\"\\\"\", 1);\n            smart_string_appendl(&buf, reply->str, reply->len);\n            smart_string_appendl(&buf, \"\\\"\", 1);\n            break;\n        case TYPE_MULTIBULK:\n            if (reply->elements < 0) {\n                smart_string_appendl(&buf, \"(nil)\", sizeof(\"(nil)\")-1);\n            } else {\n                for (i = 0; i < reply->elements; i++) {\n                    dump_reply(reply->element[i], indent+2);\n                }\n            }\n            break;\n        default:\n            break;\n    }\n\n    if (buf.len > 0) {\n        for (i = 0; i < indent; i++) {\n            php_printf(\" \");\n        }\n\n        smart_string_0(&buf);\n        php_printf(\"%s\", buf.c);\n        php_printf(\"\\n\");\n\n        efree(buf.c);\n    }\n}\n*/\n\n\n/* Recursively free our reply object.  If free_data is non-zero we'll also free\n * the payload data (strings) themselves.  If not, we just free the structs */\nvoid cluster_free_reply(clusterReply *reply, int free_data) {\n    long long i;\n\n    switch(reply->type) {\n        case TYPE_ERR:\n        case TYPE_LINE:\n        case TYPE_BULK:\n            if (free_data && reply->str)\n                efree(reply->str);\n            break;\n        case TYPE_MULTIBULK:\n            if (reply->element) {\n                if (reply->elements > 0) {\n                    for (i = 0; i < reply->elements && reply->element[i]; i++) {\n                        cluster_free_reply(reply->element[i], free_data);\n                    }\n                }\n                efree(reply->element);\n            }\n            break;\n        default:\n            break;\n    }\n    efree(reply);\n}\n\nstatic int\ncluster_multibulk_resp_recursive(RedisSock *sock, size_t elements,\n                                 clusterReply **element, int status_strings)\n{\n    int i;\n    size_t sz;\n    clusterReply *r;\n    long len;\n    char buf[1024];\n\n    for (i = 0; i < elements; i++) {\n        r = element[i] = ecalloc(1, sizeof(clusterReply));\n\n        // Bomb out, flag error condition on a communication failure\n        if (redis_read_reply_type(sock, &r->type, &len) < 0) {\n            return FAILURE;\n        }\n\n        /* Set our reply len */\n        r->len = len;\n\n        switch(r->type) {\n            case TYPE_ERR:\n            case TYPE_LINE:\n                if (redis_sock_gets(sock,buf,sizeof(buf),&sz) < 0) {\n                    return FAILURE;\n                }\n                r->len = (long long)sz;\n                if (status_strings) r->str = estrndup(buf, r->len);\n                break;\n            case TYPE_INT:\n                r->integer = len;\n                break;\n            case TYPE_BULK:\n                if (r->len >= 0) {\n                    r->str = redis_sock_read_bulk_reply(sock,r->len);\n                    if (!r->str) {\n                        return FAILURE;\n                    }\n                }\n                break;\n            case TYPE_MULTIBULK:\n                r->elements = r->len;\n                if (r->elements > 0) {\n                    r->element = ecalloc(r->len, sizeof(*r->element));\n                    if (cluster_multibulk_resp_recursive(sock, r->elements, r->element, status_strings) < 0) {\n                        return FAILURE;\n                    }\n                }\n                break;\n            default:\n                return FAILURE;\n        }\n    }\n    return SUCCESS;\n}\n\n/* Return the socket for a slot and slave index */\nstatic RedisSock *cluster_slot_sock(redisCluster *c, unsigned short slot,\n                                    zend_ulong slaveidx)\n{\n    redisClusterNode *node;\n\n    /* Return the master if we're not looking for a slave */\n    if (slaveidx == 0) {\n        return SLOT_SOCK(c, slot);\n    }\n\n    /* Abort if we can't find this slave */\n    if (!SLOT_SLAVES(c, slot) ||\n        (node = zend_hash_index_find_ptr(SLOT_SLAVES(c,slot), slaveidx)) == NULL\n    ) {\n        return NULL;\n    }\n\n    /* Success, return the slave */\n    return node->sock;\n}\n\n/* Read the response from a cluster */\nclusterReply *cluster_read_resp(redisCluster *c, int status_strings) {\n    return cluster_read_sock_resp(c->cmd_sock, c->reply_type,\n                                  status_strings ? c->line_reply : NULL,\n                                  c->reply_len);\n}\n\n/* Read any sort of response from the socket, having already issued the\n * command and consumed the reply type and meta info (length) */\nclusterReply*\ncluster_read_sock_resp(RedisSock *redis_sock, REDIS_REPLY_TYPE type,\n                       char *line_reply, long long len)\n{\n    clusterReply *r;\n\n    r = ecalloc(1, sizeof(clusterReply));\n    r->type = type;\n\n    switch(r->type) {\n        case TYPE_INT:\n            r->integer = len;\n            break;\n        case TYPE_LINE:\n            if (line_reply) {\n                r->str = estrndup(line_reply, len);\n                r->len = len;\n            }\n            REDIS_FALLTHROUGH;\n        case TYPE_ERR:\n            return r;\n        case TYPE_BULK:\n            r->len = len;\n            r->str = redis_sock_read_bulk_reply(redis_sock, len);\n            if (r->len != -1 && !r->str) {\n                cluster_free_reply(r, 1);\n                return NULL;\n            }\n            break;\n        case TYPE_MULTIBULK:\n            r->elements = len;\n            if (r->elements > 0) {\n                r->element = ecalloc(len, sizeof(clusterReply*));\n                if (cluster_multibulk_resp_recursive(redis_sock, len, r->element, line_reply != NULL) < 0) {\n                    cluster_free_reply(r, 1);\n                    return NULL;\n                }\n            }\n            break;\n        default:\n            cluster_free_reply(r, 1);\n            return NULL;\n    }\n\n    // Success, return the reply\n    return r;\n}\n\n/*\n * Helpers to send various 'control type commands to a specific node, e.g.\n * MULTI, ASKING, READONLY, READWRITE, etc\n */\n\n/* Send a command to the specific socket and validate reply type */\nstatic int cluster_send_direct(RedisSock *redis_sock, char *cmd, int cmd_len,\n                               REDIS_REPLY_TYPE type)\n{\n    char buf[1024];\n\n    /* Connect to the socket if we aren't yet and send our command, validate the reply type, and consume the first line */\n    if (!CLUSTER_SEND_PAYLOAD(redis_sock,cmd,cmd_len) ||\n        !CLUSTER_VALIDATE_REPLY_TYPE(redis_sock, type) ||\n        !redis_sock_gets_raw(redis_sock, buf, sizeof(buf))) return -1;\n\n    /* Success! */\n    return 0;\n}\n\nstatic int cluster_send_asking(RedisSock *redis_sock) {\n    return cluster_send_direct(redis_sock, ZEND_STRL(RESP_ASKING_CMD), TYPE_LINE);\n}\n\n/* Send READONLY to a specific RedisSock unless it's already flagged as being\n * in READONLY mode.  If we can send the command, we flag the socket as being\n * in that mode. */\nstatic int cluster_send_readonly(RedisSock *redis_sock) {\n    int ret;\n\n    /* We don't have to do anything if we're already in readonly mode */\n    if (redis_sock->readonly) return 0;\n\n    /* Return success if we can send it */\n    ret = cluster_send_direct(redis_sock, ZEND_STRL(RESP_READONLY_CMD), TYPE_LINE);\n\n    /* Flag this socket as READONLY if our command worked */\n    redis_sock->readonly = !ret;\n\n    /* Return the result of our send */\n    return ret;\n}\n\n/* Send MULTI to a specific ReidsSock */\nstatic int cluster_send_multi(redisCluster *c, short slot) {\n    if (cluster_send_direct(SLOT_SOCK(c,slot), ZEND_STRL(RESP_MULTI_CMD), TYPE_LINE) == 0) {\n        c->flags->txBytes += sizeof(RESP_MULTI_CMD) - 1;\n        c->cmd_sock->mode = MULTI;\n        return 0;\n    }\n    return -1;\n}\n\n/* Send EXEC to a given slot.  We can use the normal command processing mechanism\n * here because we know we'll only have sent MULTI to the master nodes.  We can't\n * failover inside a transaction, as we don't know if the transaction will only\n * be readonly commands, or contain write commands as well */\nPHP_REDIS_API int cluster_send_exec(redisCluster *c, short slot) {\n    int retval;\n\n    /* Send exec */\n    retval = cluster_send_slot(c, slot, ZEND_STRL(RESP_EXEC_CMD), TYPE_MULTIBULK);\n\n    /* We'll either get a length corresponding to the number of commands sent to\n     * this node, or -1 in the case of EXECABORT or WATCH failure. */\n    c->multi_len[slot] = c->reply_len > 0 ? 1 : -1;\n\n    /* Return our retval */\n    return retval;\n}\n\nPHP_REDIS_API int cluster_send_discard(redisCluster *c, short slot) {\n    if (cluster_send_direct(SLOT_SOCK(c,slot), ZEND_STRL(RESP_DISCARD_CMD), TYPE_LINE))\n    {\n        return 0;\n    }\n    return -1;\n}\n\n/*\n * Cluster key distribution helpers.  For a small handlful of commands, we want\n * to distribute them across 1-N nodes.  These methods provide simple containers\n * for the purposes of splitting keys/values in this way\n * */\n\n/* Free cluster distribution list inside a HashTable */\nstatic void cluster_dist_free_ht(zval *p) {\n    clusterDistList *dl = *(clusterDistList**)p;\n    int i;\n\n    for (i = 0; i < dl->len; i++) {\n        if (dl->entry[i].key_free)\n            efree(dl->entry[i].key);\n        if (dl->entry[i].val_free)\n            efree(dl->entry[i].val);\n    }\n\n    efree(dl->entry);\n    efree(dl);\n}\n\n/* Spin up a HashTable that will contain distribution lists */\nHashTable *cluster_dist_create(void) {\n    HashTable *ret;\n\n    ALLOC_HASHTABLE(ret);\n    zend_hash_init(ret, 0, NULL, cluster_dist_free_ht, 0);\n\n    return ret;\n}\n\n/* Free distribution list */\nvoid cluster_dist_free(HashTable *ht) {\n    zend_hash_destroy(ht);\n    efree(ht);\n}\n\n/* Create a clusterDistList object */\nstatic clusterDistList *cluster_dl_create(void) {\n    clusterDistList *dl;\n\n    dl        = emalloc(sizeof(clusterDistList));\n    dl->entry = emalloc(CLUSTER_KEYDIST_ALLOC * sizeof(clusterKeyVal));\n    dl->size  = CLUSTER_KEYDIST_ALLOC;\n    dl->len   = 0;\n\n    return dl;\n}\n\n/* Add a key to a dist list, returning the keval entry */\nstatic clusterKeyVal *cluster_dl_add_key(clusterDistList *dl, char *key,\n                                         int key_len, int key_free)\n{\n    // Reallocate if required\n    if (dl->len == dl->size) {\n        dl->entry = erealloc(dl->entry, sizeof(clusterKeyVal) * dl->size * 2);\n        dl->size *= 2;\n    }\n\n    // Set key info\n    dl->entry[dl->len].key = key;\n    dl->entry[dl->len].key_len = key_len;\n    dl->entry[dl->len].key_free = key_free;\n\n    // NULL out any values\n    dl->entry[dl->len].val = NULL;\n    dl->entry[dl->len].val_len = 0;\n    dl->entry[dl->len].val_free = 0;\n\n    return &(dl->entry[dl->len++]);\n}\n\n/* Add a key, returning a pointer to the entry where passed for easy adding\n * of values to match this key */\nint cluster_dist_add_key(redisCluster *c, HashTable *ht, char *key,\n                          size_t key_len, clusterKeyVal **kv)\n{\n    int key_free;\n    short slot;\n    clusterDistList *dl;\n    clusterKeyVal *retptr;\n\n    // Prefix our key and hash it\n    key_free = redis_key_prefix(c->flags, &key, &key_len);\n    slot = cluster_hash_key(key, key_len);\n\n    // We can't do this if we don't fully understand the keyspace\n    if (c->master[slot] == NULL) {\n        if (key_free) efree(key);\n        return FAILURE;\n    }\n\n    // Look for this slot\n    if ((dl = zend_hash_index_find_ptr(ht, (zend_ulong)slot)) == NULL) {\n        dl = cluster_dl_create();\n        zend_hash_index_update_ptr(ht, (zend_ulong)slot, dl);\n    }\n\n    // Now actually add this key\n    retptr = cluster_dl_add_key(dl, key, key_len, key_free);\n\n    // Push our return pointer if requested\n    if (kv) *kv = retptr;\n\n    return SUCCESS;\n}\n\n/* Provided a clusterKeyVal, add a value */\nvoid cluster_dist_add_val(redisCluster *c, clusterKeyVal *kv, zval *z_val\n                        )\n{\n    char *val;\n    size_t val_len;\n    int val_free;\n\n    // Serialize our value\n    val_free = redis_pack(c->flags, z_val, &val, &val_len);\n\n    // Attach it to the provided keyval entry\n    kv->val = val;\n    kv->val_len = val_len;\n    kv->val_free = val_free;\n}\n\n/* Free allocated memory for a clusterMultiCmd */\nvoid cluster_multi_free(clusterMultiCmd *mc) {\n    efree(mc->cmd.c);\n    efree(mc->args.c);\n}\n\n/* Add an argument to a clusterMultiCmd */\nvoid cluster_multi_add(clusterMultiCmd *mc, char *data, int data_len) {\n    mc->argc++;\n    redis_cmd_append_sstr(&(mc->args), data, data_len);\n}\n\n/* Finalize a clusterMultiCmd by constructing the whole thing */\nvoid cluster_multi_fini(clusterMultiCmd *mc) {\n    mc->cmd.len = 0;\n    redis_cmd_init_sstr(&(mc->cmd), mc->argc, mc->kw, mc->kw_len);\n    smart_string_appendl(&(mc->cmd), mc->args.c, mc->args.len);\n}\n\n/* Set our last error string encountered */\nstatic void\ncluster_set_err(redisCluster *c, char *err, int err_len)\n{\n    // Free our last error\n    if (c->err != NULL) {\n        zend_string_release(c->err);\n        c->err = NULL;\n    }\n    if (err != NULL && err_len > 0) {\n        c->err = zend_string_init(err, err_len, 0);\n        if (err_len >= sizeof(\"CLUSTERDOWN\") - 1 &&\n            !memcmp(err, \"CLUSTERDOWN\", sizeof(\"CLUSTERDOWN\") - 1)\n        ) {\n            c->clusterdown = 1;\n        }\n    }\n}\n\n/* Destructor for slaves */\nstatic void ht_free_slave(zval *data) {\n    if (*(redisClusterNode**)data) {\n        cluster_free_node(*(redisClusterNode**)data);\n    }\n}\n\n/* Get the hash slot for a given key */\nunsigned short cluster_hash_key(const char *key, int len) {\n    int s, e;\n\n    // Find first occurrence of {, if any\n    for (s = 0; s < len; s++) {\n        if (key[s]=='{') break;\n    }\n\n    // There is no '{', hash everything\n    if (s == len) return crc16(key, len) & REDIS_CLUSTER_MOD;\n\n    // Found it, look for a tailing '}'\n    for (e =s + 1; e < len; e++) {\n        if (key[e] == '}') break;\n    }\n\n    // Hash the whole key if we don't find a tailing } or if {} is empty\n    if (e == len || e == s+1) return crc16(key, len) & REDIS_CLUSTER_MOD;\n\n    // Hash just the bit between { and }\n    return crc16((char*)key+s+1,e-s-1) & REDIS_CLUSTER_MOD;\n}\n\nunsigned short cluster_hash_key_zstr(zend_string *key) {\n    return cluster_hash_key(ZSTR_VAL(key), ZSTR_LEN(key));\n}\n\n/* Grab the current time in milliseconds */\nlong long mstime(void) {\n    struct timeval tv;\n    long long mst;\n\n    gettimeofday(&tv, NULL);\n    mst = ((long long)tv.tv_sec)*1000;\n    mst += tv.tv_usec/1000;\n\n    return mst;\n}\n\n/* Hash a key from a ZVAL */\nunsigned short cluster_hash_key_zval(zval *z_key) {\n    const char *kptr;\n    char buf[255];\n    int klen;\n\n    // Switch based on ZVAL type\n    switch(Z_TYPE_P(z_key)) {\n        case IS_STRING:\n            kptr = Z_STRVAL_P(z_key);\n            klen = Z_STRLEN_P(z_key);\n            break;\n        case IS_LONG:\n            klen = snprintf(buf,sizeof(buf),ZEND_LONG_FMT,Z_LVAL_P(z_key));\n            kptr = (const char *)buf;\n            break;\n        case IS_DOUBLE:\n            klen = snprintf(buf,sizeof(buf),\"%f\",Z_DVAL_P(z_key));\n            kptr = (const char *)buf;\n            break;\n        case IS_ARRAY:\n            kptr = \"Array\";\n            klen = sizeof(\"Array\")-1;\n            break;\n        case IS_OBJECT:\n            kptr = \"Object\";\n            klen = sizeof(\"Object\")-1;\n            break;\n        default:\n            kptr = \"\";\n            klen = 0;\n    }\n\n    // Hash the string representation\n    return cluster_hash_key(kptr, klen);\n}\n\n/* Fisher-Yates shuffle for integer array */\nstatic void fyshuffle(int *array, size_t len) {\n    int temp, n = len;\n    size_t r;\n\n    /* Randomize */\n    while (n > 1) {\n        r = ((int)((double)n-- * (rand() / (RAND_MAX+1.0))));\n        temp = array[n];\n        array[n] = array[r];\n        array[r] = temp;\n    };\n}\n\n/* Execute a CLUSTER SLOTS command against the seed socket, and return the\n * reply or NULL on failure. */\nclusterReply* cluster_get_slots(RedisSock *redis_sock)\n{\n    clusterReply *r;\n    REDIS_REPLY_TYPE type;\n    long len;\n\n    // Send the command to the socket and consume reply type\n    if (redis_sock_write(redis_sock, RESP_CLUSTER_SLOTS_CMD,\n                        sizeof(RESP_CLUSTER_SLOTS_CMD)-1) < 0 ||\n                        redis_read_reply_type(redis_sock, &type, &len) < 0)\n    {\n        return NULL;\n    }\n\n    // Consume the rest of our response\n    if ((r = cluster_read_sock_resp(redis_sock, type, NULL, len)) == NULL ||\n       r->type != TYPE_MULTIBULK || r->elements < 1)\n    {\n        if (r) cluster_free_reply(r, 1);\n        return NULL;\n    }\n\n    // Return our reply\n    return r;\n}\n\n/* Create a cluster node */\nstatic redisClusterNode*\ncluster_node_create(redisCluster *c, char *host, size_t host_len,\n                    unsigned short port, unsigned short slot, short slave)\n{\n    redisClusterNode *node = emalloc(sizeof(redisClusterNode));\n\n    // It lives in at least this slot, flag slave status\n    node->slot   = slot;\n    node->slave  = slave;\n    node->slaves = NULL;\n\n    /* Initialize our list of slot ranges */\n    zend_llist_init(&node->slots, sizeof(redisSlotRange), NULL, 0);\n\n    // Attach socket\n    node->sock = redis_sock_create(host, host_len, port,\n                                   c->flags->timeout, c->flags->read_timeout,\n                                   c->flags->persistent, NULL, 0);\n\n    /* Stream context */\n    node->sock->stream_ctx = c->flags->stream_ctx;\n\n    redis_sock_set_auth(node->sock, c->flags->user, c->flags->pass);\n\n    return node;\n}\n\n/* Attach a slave to a master */\nPHP_REDIS_API int\ncluster_node_add_slave(redisClusterNode *master, redisClusterNode *slave)\n{\n    zend_ulong index;\n\n    // Allocate our slaves hash table if we haven't yet\n    if (!master->slaves) {\n        ALLOC_HASHTABLE(master->slaves);\n        zend_hash_init(master->slaves, 0, NULL, ht_free_slave, 0);\n        index = 1;\n    } else {\n        index = master->slaves->nNextFreeElement;\n    }\n\n    return zend_hash_index_update_ptr(master->slaves, index, slave) != NULL;\n}\n\n/* Sanity check/validation for CLUSTER SLOTS command */\n#define VALIDATE_SLOTS_OUTER(r) \\\n    (r->elements >= 3 && r2->element[0]->type == TYPE_INT && \\\n     r->element[1]->type == TYPE_INT)\n#define VALIDATE_SLOTS_INNER(r) \\\n    (r->type == TYPE_MULTIBULK && r->elements >= 2 && \\\n     r->element[0]->type == TYPE_BULK && r->element[1]->type == TYPE_INT)\n\n/* Use the output of CLUSTER SLOTS to map our nodes */\nstatic int cluster_map_slots(redisCluster *c, clusterReply *r) {\n    redisClusterNode *pnode, *master, *slave;\n    redisSlotRange range;\n    int i,j, hlen, klen;\n    short low, high;\n    clusterReply *r2, *r3;\n    unsigned short port;\n    char *host, key[1024];\n    zend_hash_clean(c->nodes);\n    for (i = 0; i < r->elements; i++) {\n        // Inner response\n        r2 = r->element[i];\n\n        // Validate outer and master slot\n        if (!VALIDATE_SLOTS_OUTER(r2) || !VALIDATE_SLOTS_INNER(r2->element[2])) {\n            return -1;\n        }\n\n        // Master\n        r3 = r2->element[2];\n\n        // Grab our slot range, as well as master host/port\n        low  = (unsigned short)r2->element[0]->integer;\n        high = (unsigned short)r2->element[1]->integer;\n        host = r3->element[0]->str;\n        hlen = r3->element[0]->len;\n        port = (unsigned short)r3->element[1]->integer;\n\n        // If the node is new, create and add to nodes.  Otherwise use it.\n        klen = snprintf(key, sizeof(key), \"%s:%d\", host, port);\n        if ((pnode = zend_hash_str_find_ptr(c->nodes, key, klen)) == NULL) {\n            master = cluster_node_create(c, host, hlen, port, low, 0);\n            zend_hash_str_update_ptr(c->nodes, key, klen, master);\n\n            // Attach slaves first time we encounter a given master in order to avoid registering the slaves multiple times\n            for (j = 3; j< r2->elements; j++) {\n                r3 = r2->element[j];\n                if (!VALIDATE_SLOTS_INNER(r3)) {\n                    return -1;\n                }\n\n                // Skip slaves where the host is \"\"\n                if (r3->element[0]->len == 0) continue;\n\n                // Attach this node to our slave\n                slave = cluster_node_create(c, r3->element[0]->str,\n                    (int)r3->element[0]->len,\n                    (unsigned short)r3->element[1]->integer, low, 1);\n                cluster_node_add_slave(master, slave);\n            }\n        } else {\n            master = pnode;\n        }\n\n        // Attach this node to each slot in the range\n        for (j = low; j<= high; j++) {\n            c->master[j] = master;\n        }\n\n        /* Append to our list of slot ranges */\n        range.low = low; range.high = high;\n        zend_llist_add_element(&master->slots, &range);\n    }\n\n    // Success\n    return 0;\n}\n\n/* Free a redisClusterNode structure */\nPHP_REDIS_API void cluster_free_node(redisClusterNode *node) {\n    if (node->slaves) {\n        zend_hash_destroy(node->slaves);\n        efree(node->slaves);\n    }\n\n    zend_llist_destroy(&node->slots);\n    redis_free_socket(node->sock);\n\n    efree(node);\n}\n\n/* Get or create a redisClusterNode that corresponds to the asking redirection */\nstatic redisClusterNode *cluster_get_asking_node(redisCluster *c) {\n    redisClusterNode *pNode;\n    char key[1024];\n    int key_len;\n\n    /* Hashed by host:port */\n    key_len = snprintf(key, sizeof(key), \"%s:%u\", c->redir_host, c->redir_port);\n\n    /* See if we've already attached to it */\n    if ((pNode = zend_hash_str_find_ptr(c->nodes, key, key_len)) != NULL) {\n        return pNode;\n    }\n\n    /* This host:port is unknown to us, so add it */\n    pNode = cluster_node_create(c, c->redir_host, c->redir_host_len,\n        c->redir_port, c->redir_slot, 0);\n\n    /* Return the node */\n   return pNode;\n}\n\n/* Get or create a node at the host:port we were asked to check, and return the\n * redis_sock for it. */\nstatic RedisSock *cluster_get_asking_sock(redisCluster *c) {\n    return cluster_get_asking_node(c)->sock;\n}\n\n/* Our context seeds will be a hash table with RedisSock* pointers */\nstatic void ht_free_seed(zval *data) {\n    RedisSock *redis_sock = *(RedisSock**)data;\n    if (redis_sock) redis_free_socket(redis_sock);\n}\n\n/* Free redisClusterNode objects we've stored */\nstatic void ht_free_node(zval *data) {\n    redisClusterNode *node = *(redisClusterNode**)data;\n    cluster_free_node(node);\n}\n\n/* zend_llist of slot ranges -> persistent array */\nstatic redisSlotRange *slot_range_list_clone(zend_llist *src, size_t *count) {\n    redisSlotRange *dst, *range;\n    size_t i = 0;\n\n    *count = zend_llist_count(src);\n    dst = pemalloc(*count * sizeof(*dst), 1);\n\n    range = zend_llist_get_first(src);\n    while (range) {\n        memcpy(&dst[i++], range, sizeof(*range));\n        range = zend_llist_get_next(src);\n     }\n\n    return dst;\n}\n\n/* Construct a redisCluster object */\nPHP_REDIS_API redisCluster *cluster_create(double timeout, double read_timeout,\n                                           int failover, int persistent)\n{\n    redisCluster *c;\n\n    /* Actual our actual cluster structure */\n    c = ecalloc(1, sizeof(redisCluster));\n\n    /* Initialize flags and settings */\n    c->flags = ecalloc(1, sizeof(RedisSock));\n    c->flags->timeout = timeout;\n    c->flags->read_timeout = read_timeout;\n    c->flags->persistent = persistent;\n    c->subscribed_slot = -1;\n    c->clusterdown = 0;\n    c->failover = failover;\n    c->err = NULL;\n\n    /* Set up our waitms based on timeout */\n    c->waitms  = (long)(1000 * (timeout + read_timeout));\n\n    /* Allocate our seeds hash table */\n    ALLOC_HASHTABLE(c->seeds);\n    zend_hash_init(c->seeds, 0, NULL, ht_free_seed, 0);\n\n    /* Allocate our nodes HashTable */\n    ALLOC_HASHTABLE(c->nodes);\n    zend_hash_init(c->nodes, 0, NULL, ht_free_node, 0);\n\n    return c;\n}\n\nPHP_REDIS_API void\ncluster_free(redisCluster *c, int free_ctx)\n{\n    /* Disconnect from each node we're connected to */\n    cluster_disconnect(c, 0);\n\n    /* Free any allocated prefix */\n    if (c->flags->prefix) zend_string_release(c->flags->prefix);\n\n    redis_sock_free_auth(c->flags);\n    efree(c->flags);\n\n    /* Call hash table destructors */\n    zend_hash_destroy(c->seeds);\n    zend_hash_destroy(c->nodes);\n\n    /* Free hash tables themselves */\n    efree(c->seeds);\n    efree(c->nodes);\n\n    /* Free any error we've got */\n    if (c->err) zend_string_release(c->err);\n\n    if (c->cache_key) {\n        /* Invalidate persistent cache if the cluster has changed */\n        if (c->redirections) {\n            zend_hash_del(&EG(persistent_list), c->cache_key);\n        }\n\n        /* Release our hold on the cache key */\n        zend_string_release(c->cache_key);\n    }\n\n    /* Free structure itself */\n    if (free_ctx) efree(c);\n}\n\n/* Create a cluster slot cache structure */\nPHP_REDIS_API\nredisCachedCluster *cluster_cache_create(zend_string *hash, HashTable *nodes) {\n    redisCachedCluster *cc;\n    redisCachedMaster *cm;\n    redisClusterNode *node, *slave;\n\n    cc = pecalloc(1, sizeof(*cc), 1);\n    cc->hash = zend_string_dup(hash, 1);\n\n    /* Copy nodes */\n    cc->master = pecalloc(zend_hash_num_elements(nodes), sizeof(*cc->master), 1);\n    ZEND_HASH_FOREACH_PTR(nodes, node) {\n        /* Skip slaves */\n        if (node->slave) continue;\n\n        cm = &cc->master[cc->count];\n\n        /* Duplicate host/port and clone slot ranges */\n        cm->host.addr = zend_string_dup(node->sock->host, 1);\n        cm->host.port = node->sock->port;\n\n        /* Copy over slot ranges */\n        cm->slot = slot_range_list_clone(&node->slots, &cm->slots);\n\n        /* Attach any slave nodes we have. */\n        if (node->slaves) {\n            /* Allocate memory for slaves */\n            cm->slave = pecalloc(zend_hash_num_elements(node->slaves), sizeof(*cm->slave), 1);\n\n            /* Copy host/port information for each slave */\n            ZEND_HASH_FOREACH_PTR(node->slaves, slave) {\n                cm->slave[cm->slaves].addr = zend_string_dup(slave->sock->host, 1);\n                cm->slave[cm->slaves].port = slave->sock->port;\n                cm->slaves++;\n            } ZEND_HASH_FOREACH_END();\n        }\n\n        cc->count++;\n    } ZEND_HASH_FOREACH_END();\n\n    return cc;\n}\n\nstatic void cluster_free_cached_master(redisCachedMaster *cm) {\n    size_t i;\n\n    /* Free each slave entry */\n    for (i = 0; i < cm->slaves; i++) {\n        zend_string_release(cm->slave[i].addr);\n    }\n\n    /* Free other elements */\n    zend_string_release(cm->host.addr);\n    pefree(cm->slave, 1);\n    pefree(cm->slot, 1);\n}\n\nstatic redisClusterNode*\ncached_master_clone(redisCluster *c, redisCachedMaster *cm) {\n    redisClusterNode *node;\n    size_t i;\n\n    node = cluster_node_create(c, ZSTR_VAL(cm->host.addr), ZSTR_LEN(cm->host.addr),\n                               cm->host.port, cm->slot[0].low, 0);\n\n    /* Now copy in our slot ranges */\n    for (i = 0; i < cm->slots; i++) {\n        zend_llist_add_element(&node->slots, &cm->slot[i]);\n    }\n\n    return node;\n}\n\n/* Destroy a persistent cached cluster */\nPHP_REDIS_API void cluster_cache_free(redisCachedCluster *rcc) {\n    size_t i;\n\n    /* Free masters */\n    for (i = 0; i < rcc->count; i++) {\n        cluster_free_cached_master(&rcc->master[i]);\n    }\n\n    zend_string_release(rcc->hash);\n    pefree(rcc->master, 1);\n    pefree(rcc, 1);\n}\n\n/* Initialize cluster from cached slots */\nPHP_REDIS_API\nvoid cluster_init_cache(redisCluster *c, redisCachedCluster *cc) {\n    RedisSock *sock;\n    redisClusterNode *mnode, *slave;\n    redisCachedMaster *cm;\n    char key[HOST_NAME_MAX];\n    size_t keylen, i, j, s;\n    int *map;\n\n    /* Randomize seeds */\n    map = emalloc(sizeof(*map) * cc->count);\n    for (i = 0; i < cc->count; i++) map[i] = i;\n    fyshuffle(map, cc->count);\n\n    /* Duplicate the hash key so we can invalidate when redirected */\n    c->cache_key = zend_string_copy(cc->hash);\n\n    /* Iterate over masters */\n    for (i = 0; i < cc->count; i++) {\n        /* Grab the next master */\n        cm = &cc->master[map[i]];\n\n        /* Hash our host and port */\n        keylen = snprintf(key, sizeof(key), \"%s:%u\", ZSTR_VAL(cm->host.addr), cm->host.port);\n\n        /* Create socket */\n        sock = redis_sock_create(ZSTR_VAL(cm->host.addr), ZSTR_LEN(cm->host.addr), cm->host.port,\n                                 c->flags->timeout, c->flags->read_timeout, c->flags->persistent,\n                                 NULL, 0);\n\n        /* Stream context */\n        sock->stream_ctx = c->flags->stream_ctx;\n\n        /* Add to seed nodes */\n        zend_hash_str_update_ptr(c->seeds, key, keylen, sock);\n\n        /* Create master node */\n        mnode = cached_master_clone(c, cm);\n\n        /* Add our master */\n        zend_hash_str_update_ptr(c->nodes, key, keylen, mnode);\n\n        /* Attach any slaves */\n        for (s = 0; s < cm->slaves; s++) {\n            zend_string *host = cm->slave[s].addr;\n            slave = cluster_node_create(c, ZSTR_VAL(host), ZSTR_LEN(host), cm->slave[s].port, 0, 1);\n            cluster_node_add_slave(mnode, slave);\n        }\n\n        /* Hook up direct slot access */\n        for (j = 0; j < cm->slots; j++) {\n            for (s = cm->slot[j].low; s <= cm->slot[j].high; s++) {\n                c->master[s] = mnode;\n            }\n        }\n    }\n\n    efree(map);\n}\n\n/* Initialize seeds.  By the time we get here we've already validated our\n * seeds array and know we have a non-empty array of strings all in\n * host:port format. */\nPHP_REDIS_API void\ncluster_init_seeds(redisCluster *c, zend_string **seeds, uint32_t nseeds)\n{\n    RedisSock *sock;\n    char *seed, *sep, key[1024];\n    int key_len, i, *map;\n\n    /* Get a randomized order to hit our seeds */\n    map = ecalloc(nseeds, sizeof(*map));\n    for (i = 0; i < nseeds; i++) map[i] = i;\n    fyshuffle(map, nseeds);\n\n    for (i = 0; i < nseeds; i++) {\n        seed = ZSTR_VAL(seeds[map[i]]);\n\n        sep = strrchr(seed, ':');\n        ZEND_ASSERT(sep != NULL);\n\n        // Allocate a structure for this seed\n        sock = redis_sock_create(seed, sep - seed, atoi(sep + 1),\n                                 c->flags->timeout, c->flags->read_timeout,\n                                 c->flags->persistent, NULL, 0);\n\n        /* Stream context */\n        sock->stream_ctx = c->flags->stream_ctx;\n\n        /* Credentials */\n        redis_sock_set_auth(sock, c->flags->user, c->flags->pass);\n\n        // Index this seed by host/port\n        key_len = snprintf(key, sizeof(key), \"%s:%u\", ZSTR_VAL(sock->host),\n            sock->port);\n\n        // Add to our seed HashTable\n        zend_hash_str_update_ptr(c->seeds, key, key_len, sock);\n    }\n\n    efree(map);\n}\n\n/* Initial mapping of our cluster keyspace */\nPHP_REDIS_API int cluster_map_keyspace(redisCluster *c) {\n    RedisSock *seed;\n    clusterReply *slots = NULL;\n    int mapped = 0;\n\n    // Iterate over seeds until we can get slots\n    ZEND_HASH_FOREACH_PTR(c->seeds, seed) {\n        // Attempt to connect to this seed node\n        if (seed == NULL || redis_sock_server_open(seed) != SUCCESS) {\n            continue;\n        }\n\n        // Parse out cluster nodes.  Flag mapped if we are valid\n        slots = cluster_get_slots(seed);\n        if (slots) {\n            mapped = !cluster_map_slots(c, slots);\n            // Bin anything mapped, if we failed somewhere\n            if (!mapped) {\n                memset(c->master, 0, sizeof(redisClusterNode*)*REDIS_CLUSTER_SLOTS);\n            }\n        }\n        redis_sock_disconnect(seed, 0, 1);\n        if (mapped) break;\n    } ZEND_HASH_FOREACH_END();\n\n    // Clean up slots reply if we got one\n    if (slots) cluster_free_reply(slots, 1);\n\n    // Throw an exception if we couldn't map\n    if (!mapped) {\n        CLUSTER_THROW_EXCEPTION(\"Couldn't map cluster keyspace using any provided seed\", 0);\n        return FAILURE;\n    }\n\n    return SUCCESS;\n}\n\n/* Parse the MOVED OR ASK redirection payload when we get such a response\n * and apply this information to our cluster.  If we encounter a parse error\n * nothing in the cluster will be modified, and -1 is returned. */\nstatic int cluster_set_redirection(redisCluster* c, char *msg, int moved)\n{\n    char *host, *port;\n\n    /* The Redis Cluster specification suggests clients do not update\n     * their slot mapping for an ASK redirection, only for MOVED */\n    if (moved) c->redirections++;\n\n    /* Move past \"MOVED\" or \"ASK */\n    msg += moved ? MOVED_LEN : ASK_LEN;\n\n    /* Make sure we can find host */\n    if ((host = strchr(msg, ' ')) == NULL) return -1;\n    *host++ = '\\0';\n\n    /* Find port, searching right to left in case of IPv6 */\n    if ((port = strrchr(host, ':')) == NULL) return -1;\n    *port++ = '\\0';\n\n    // Success, apply it\n    c->redir_type = moved ? REDIR_MOVED : REDIR_ASK;\n    strncpy(c->redir_host, host, sizeof(c->redir_host) - 1);\n    c->redir_host_len = port - host - 1;\n    c->redir_slot = (unsigned short)atoi(msg);\n    c->redir_port = (unsigned short)atoi(port);\n\n    return 0;\n}\n\n/* Once we write a command to a node in our cluster, this function will check\n * the reply type and extract information from those that will specify a length\n * bit.  If we encounter an error condition, we'll check for MOVED or ASK\n * redirection, parsing out slot host and port so the caller can take\n * appropriate action.\n *\n * In the case of a non MOVED/ASK error, we will set our cluster error\n * condition so GetLastError can be queried by the client.\n *\n * This function will return -1 on a critical error (e.g. parse/communication\n * error, 0 if no redirection was encountered, and 1 if the data was moved. */\nstatic int cluster_check_response(redisCluster *c, REDIS_REPLY_TYPE *reply_type)\n{\n    size_t sz;\n\n    // Clear out any prior error state and our last line response\n    CLUSTER_CLEAR_ERROR(c);\n    CLUSTER_CLEAR_REPLY(c);\n\n    if (-1 == redis_check_eof(c->cmd_sock, 1, 1) ||\n       EOF == (*reply_type = redis_sock_getc(c->cmd_sock)))\n    {\n        return -1;\n    }\n\n    // In the event of an ERROR, check if it's a MOVED/ASK error\n    if (*reply_type == TYPE_ERR) {\n        char inbuf[4096];\n        size_t nbytes;\n        int moved;\n\n        // Attempt to read the error\n        if (!redis_sock_get_line(c->cmd_sock, inbuf, sizeof(inbuf), &nbytes)) {\n            return -1;\n        }\n\n        // Check for MOVED or ASK redirection\n        if ((moved = IS_MOVED(inbuf)) || IS_ASK(inbuf)) {\n            /* Make sure we can parse the redirection host and port */\n            return !cluster_set_redirection(c, inbuf, moved) ? 1 : -1;\n        }\n        // Capture the error string Redis returned\n        cluster_set_err(c, inbuf, strlen(inbuf)-2);\n        return 0;\n    }\n\n    // Fetch the first line of our response from Redis.\n    if (redis_sock_gets(c->cmd_sock,c->line_reply,sizeof(c->line_reply),\n                       &sz) < 0)\n    {\n        return -1;\n    }\n\n    // For replies that will give us a numeric length, convert it\n    if (*reply_type != TYPE_LINE) {\n        c->reply_len = strtol(c->line_reply, NULL, 10);\n    } else {\n        c->reply_len = (long long)sz;\n    }\n\n    // Clear out any previous error, and return that the data is here\n    CLUSTER_CLEAR_ERROR(c);\n    return 0;\n}\n\n/* Disconnect from each node we're connected to */\nPHP_REDIS_API void cluster_disconnect(redisCluster *c, int force) {\n    redisClusterNode *node, *slave;\n\n    ZEND_HASH_FOREACH_PTR(c->nodes, node) {\n        if (node == NULL) continue;\n\n        /* Disconnect from the master */\n        redis_sock_disconnect(node->sock, force, 1);\n\n        /* We also want to disconnect any slave connections so they will be pooled\n         * in the event we are using persistent connections and connection pooling. */\n        if (node->slaves) {\n            ZEND_HASH_FOREACH_PTR(node->slaves, slave) {\n                redis_sock_disconnect(slave->sock, force, 1);\n            } ZEND_HASH_FOREACH_END();\n        }\n    } ZEND_HASH_FOREACH_END();\n}\n\n/* This method attempts to write our command at random to the master and any\n * attached slaves, until we either successufly do so, or fail. */\nstatic int cluster_dist_write(redisCluster *c, const char *cmd, size_t sz,\n                              int nomaster)\n{\n    int i, count = 1, *nodes;\n    RedisSock *redis_sock;\n\n    /* Determine our overall node count */\n    if (c->master[c->cmd_slot]->slaves) {\n        count += zend_hash_num_elements(c->master[c->cmd_slot]->slaves);\n    }\n\n    /* Allocate memory for master + slaves or just slaves */\n    nodes = emalloc(sizeof(int)*count);\n\n    /* Populate our array with the master and each of it's slaves, then\n     * randomize them, so we will pick from the master or some slave.  */\n    for (i = 0; i < count; i++) nodes[i] = i;\n    fyshuffle(nodes, count);\n\n    /* Iterate through our nodes until we find one we can write to or fail */\n    for (i = 0; i < count; i++) {\n        /* Skip if this is the master node and we don't want to query that */\n        if (nomaster && nodes[i] == 0)\n           continue;\n\n        /* Get the slave for this index */\n        redis_sock = cluster_slot_sock(c, c->cmd_slot, nodes[i]);\n        if (!redis_sock) continue;\n\n        /* If we're not on the master, attempt to send the READONLY command to\n         * this slave, and skip it if that fails */\n        if (nodes[i] == 0 || cluster_send_readonly(redis_sock) == 0) {\n            /* Attempt to send the command */\n            if (CLUSTER_SEND_PAYLOAD(redis_sock, cmd, sz)) {\n                c->cmd_sock = redis_sock;\n                efree(nodes);\n                return 0;\n            }\n        }\n    }\n\n    /* Clean up our shuffled array */\n    efree(nodes);\n\n    /* Couldn't send to the master or any slave */\n    return -1;\n}\n\n/* Attempt to write our command to the current c->cmd_sock socket.  For write\n * commands, we attempt to query the master for this slot, and in the event of\n * a failure, try to query every remaining node for a redirection.\n *\n * If we're issuing a readonly command, we use one of three strategies, depending\n * on our redisCluster->failover setting.\n *\n * REDIS_FAILOVER_NONE:\n *   The command is treated just like a write command, and will only be executed\n *   against the known master for this slot.\n * REDIS_FAILOVER_ERROR:\n *   If we're unable to communicate with this slot's master, we attempt the query\n *   against any slaves (at random) that this master has.\n * REDIS_FAILOVER_DISTRIBUTE:\n *   We pick at random from the master and any slaves it has.  This option will\n *   load balance between masters and slaves\n * REDIS_FAILOVER_DISTRIBUTE_SLAVES:\n *   We pick at random from slave nodes of a given master.  This option is\n *   used to load balance read queries against N slaves.\n *\n * Once we are able to find a node we can write to, we check for MOVED or\n * ASKING redirection, such that the keyspace can be updated.\n*/\nstatic int cluster_sock_write(redisCluster *c, const char *cmd, size_t sz,\n                              int direct)\n{\n    redisClusterNode *seed_node;\n    RedisSock *redis_sock;\n    int failover, nomaster;\n\n    /* First try the socket requested */\n    redis_sock = c->cmd_sock;\n\n    /* Readonly is irrelevant if we're not configured to failover */\n    failover = c->readonly && c->failover != REDIS_FAILOVER_NONE ?\n        c->failover : REDIS_FAILOVER_NONE;\n\n    /* If in ASK redirection, get/create the node for that host:port, otherwise\n     * just use the command socket. */\n    if (c->redir_type == REDIR_ASK) {\n        if (cluster_send_asking(c->cmd_sock) < 0) {\n            return -1;\n        }\n    }\n\n    /* Attempt to send our command payload to the cluster.  If we're not set up\n     * to failover, just try the master.  If we're configured to failover on\n     * error, try the master and then fall back to any slaves.  When we're set\n     * up to distribute the commands, try to write to any node on this slot\n     * at random. */\n    if (failover == REDIS_FAILOVER_NONE) {\n        /* Success if we can send our payload to the master */\n        if (CLUSTER_SEND_PAYLOAD(redis_sock, cmd, sz)) return 0;\n    } else if (failover == REDIS_FAILOVER_ERROR) {\n        /* Try the master, then fall back to any slaves we may have */\n        if (CLUSTER_SEND_PAYLOAD(redis_sock, cmd, sz) ||\n           !cluster_dist_write(c, cmd, sz, 1)) return 0;\n    } else {\n        /* Include or exclude master node depending on failover option and\n         * attempt to make our write */\n        nomaster = failover == REDIS_FAILOVER_DISTRIBUTE_SLAVES;\n        if (!cluster_dist_write(c, cmd, sz, nomaster)) {\n            /* We were able to write to a master or slave at random */\n            return 0;\n        }\n    }\n\n    /* Don't fall back if direct communication with this slot is required. */\n    if (direct) return -1;\n\n    /* Fall back by attempting the request against every known node */\n    ZEND_HASH_FOREACH_PTR(c->nodes, seed_node) {\n        /* Skip this node if it's the one that failed, or if it's a slave */\n        if (seed_node == NULL || seed_node->sock == redis_sock || seed_node->slave) continue;\n\n        /* Connect to this node if we haven't already and attempt to write our request to this node */\n        if (CLUSTER_SEND_PAYLOAD(seed_node->sock, cmd, sz)) {\n            c->cmd_slot = seed_node->slot;\n            c->cmd_sock = seed_node->sock;\n            return 0;\n        }\n    } ZEND_HASH_FOREACH_END();\n\n    /* We were unable to write to any node in our cluster */\n    return -1;\n}\n\n/* Helper to find if we've got a host:port mapped in our cluster nodes. */\nstatic redisClusterNode *cluster_find_node(redisCluster *c, const char *host,\n                                           unsigned short port)\n{\n    int key_len;\n    char key[1024];\n\n    key_len = snprintf(key,sizeof(key),\"%s:%d\", host, port);\n\n    return zend_hash_str_find_ptr(c->nodes, key, key_len);\n}\n\n/* Provided a redisCluster object, the slot where we thought data was and\n * the slot where data was moved, update our node mapping */\nstatic void cluster_update_slot(redisCluster *c) {\n    redisClusterNode *node;\n    char key[1024];\n    size_t klen;\n\n    /* Do we already have the new slot mapped */\n    if (c->master[c->redir_slot]) {\n        /* No need to do anything if it's the same node */\n        if (!CLUSTER_REDIR_CMP(c, SLOT_SOCK(c,c->redir_slot))) {\n            return;\n        }\n\n        /* Check to see if we have this new node mapped */\n        node = cluster_find_node(c, c->redir_host, c->redir_port);\n\n        if (node) {\n            /* Just point to this slot */\n            c->master[c->redir_slot] = node;\n        } else {\n            /* If the redirected node is a replica of the previous slot owner, a failover has taken place.\n            We must then remap the cluster's keyspace in order to update the cluster's topology. */\n            redisClusterNode *prev_master = SLOT(c,c->redir_slot);\n            redisClusterNode *slave;\n            ZEND_HASH_FOREACH_PTR(prev_master->slaves, slave) {\n                if (slave == NULL) {\n                    continue;\n                }\n                if (!CLUSTER_REDIR_CMP(c, slave->sock)) {\n                    // Detected a failover, the redirected node was a replica\n                    // Remap the cluster's keyspace\n                    cluster_map_keyspace(c);\n                    return;\n                }\n            } ZEND_HASH_FOREACH_END();\n\n            /* Create our node */\n            node = cluster_node_create(c, c->redir_host, c->redir_host_len,\n                c->redir_port, c->redir_slot, 0);\n\n            /* Our node is new, so keep track of it for cleanup */\n            klen = snprintf(key, sizeof(key), \"%s:%d\", c->redir_host, c->redir_port);\n            zend_hash_str_update_ptr(c->nodes, key, klen, node);\n\n            /* Now point our slot at the node */\n            c->master[c->redir_slot] = node;\n        }\n    } else {\n        /* Check to see if the ip and port are mapped */\n        node = cluster_find_node(c, c->redir_host, c->redir_port);\n        if (!node) {\n            node = cluster_node_create(c, c->redir_host, c->redir_host_len,\n                c->redir_port, c->redir_slot, 0);\n        }\n\n        /* Map the slot to this node */\n        c->master[c->redir_slot] = node;\n    }\n\n    /* Update slot inside of node, so it can be found for command sending */\n    node->slot = c->redir_slot;\n\n    /* Make sure we unflag this node as a slave, as Redis Cluster will only ever\n     * direct us to master nodes. */\n    node->slave = 0;\n}\n\n/* Abort any transaction in process, by sending DISCARD to any nodes that\n * have active transactions in progress.  If we can't send DISCARD, we need\n * to disconnect as it would leave us in an undefined state. */\nPHP_REDIS_API int cluster_abort_exec(redisCluster *c) {\n    clusterFoldItem *fi = c->multi_head;\n\n    /* Loop through our fold items */\n    while (fi) {\n        if (SLOT_SOCK(c,fi->slot)->mode == MULTI) {\n            if (cluster_send_discard(c, fi->slot) < 0) {\n                cluster_disconnect(c, 0);\n                return -1;\n            }\n            SLOT_SOCK(c,fi->slot)->mode = ATOMIC;\n            SLOT_SOCK(c,fi->slot)->watching = 0;\n        }\n        fi = fi->next;\n    }\n\n    /* Update our overall cluster state */\n    c->flags->mode = ATOMIC;\n\n    /* Success */\n    return 0;\n}\n\n/* Iterate through our slots, looking for the host/port in question.  This\n * should perform well enough as in almost all situations, a few or a few\n * dozen servers will map all the slots */\nPHP_REDIS_API short cluster_find_slot(redisCluster *c, const char *host,\n                               unsigned short port)\n{\n    int i;\n\n    for (i = 0; i < REDIS_CLUSTER_SLOTS; i++) {\n        if (c->master[i] && c->master[i]->sock &&\n           c->master[i]->sock->port == port &&\n           !strcasecmp(ZSTR_VAL(c->master[i]->sock->host), host))\n        {\n            return i;\n        }\n    }\n\n    // We didn't find it\n    return -1;\n}\n\n/* Send a command to a specific slot */\nPHP_REDIS_API int cluster_send_slot(redisCluster *c, short slot, char *cmd,\n                             int cmd_len, REDIS_REPLY_TYPE rtype)\n{\n    /* Point our cluster to this slot and it's socket */\n    c->cmd_slot = slot;\n    c->cmd_sock = SLOT_SOCK(c, slot);\n\n    /* Enable multi mode on this slot if we've been directed to but haven't\n     * send it to this node yet */\n    if (c->flags->mode == MULTI && c->cmd_sock->mode != MULTI) {\n        if (cluster_send_multi(c, slot) == -1) {\n            CLUSTER_THROW_EXCEPTION(\"Unable to enter MULTI mode on requested slot\", 0);\n            return -1;\n        }\n    }\n\n    /* Try the slot */\n    if (cluster_sock_write(c, cmd, cmd_len, 1) == -1) {\n        return -1;\n    }\n    c->flags->txBytes += cmd_len;\n\n    /* Check our response */\n    if (cluster_check_response(c, &c->reply_type) != 0 ||\n       (rtype != TYPE_EOF && rtype != c->reply_type)) return -1;\n\n    /* Success */\n    return 0;\n}\n\n/* Send a command to given slot in our cluster.  If we get a MOVED or ASK error\n * we attempt to send the command to the node as directed. */\nPHP_REDIS_API short cluster_send_command(redisCluster *c, short slot, const char *cmd,\n                                         int cmd_len)\n{\n    int resp, timedout = 0;\n    long msstart;\n\n    if (!SLOT(c, slot)) {\n        zend_throw_exception_ex(redis_cluster_exception_ce, 0,\n            \"The slot %d is not covered by any node in this cluster\", slot);\n        return -1;\n    }\n    /* Set the slot we're operating against as well as it's socket.  These can\n     * change during our request loop if we have a master failure and are\n     * configured to fall back to slave nodes, or if we have to fall back to\n     * a different slot due to no nodes serving this slot being reachable. */\n    c->cmd_slot = slot;\n    c->cmd_sock = SLOT_SOCK(c, slot);\n\n    /* Get the current time in milliseconds to handle any timeout */\n    msstart = mstime();\n\n    /* Our main cluster request/reply loop.  This loop runs until we're able to\n     * get a valid reply from a node, hit our \"request\" timeout, or encounter a\n     * CLUSTERDOWN state from Redis Cluster. */\n    do {\n        /* Send MULTI to the socket if we're in MULTI mode but haven't yet */\n        if (c->flags->mode == MULTI && c->cmd_sock->mode != MULTI) {\n            /* We have to fail if we can't send MULTI to the node */\n            if (cluster_send_multi(c, slot) == -1) {\n                CLUSTER_THROW_EXCEPTION(\"Unable to enter MULTI mode on requested slot\", 0);\n                return -1;\n            }\n        }\n\n        /* Attempt to deliver our command to the node, and that failing, to any\n         * node until we find one that is available. */\n        if (cluster_sock_write(c, cmd, cmd_len, 0) == -1) {\n            /* We have to abort, as no nodes are reachable */\n            CLUSTER_THROW_EXCEPTION(\"Can't communicate with any node in the cluster\", 0);\n            return -1;\n        }\n\n        /* Check response and short-circuit on success or communication error */\n        resp = cluster_check_response(c, &c->reply_type);\n        if (resp <= 0) {\n            break;\n        }\n\n        /* Handle MOVED or ASKING redirection */\n        if (resp == 1) {\n           /* Abort if we're in a transaction as it will be invalid */\n           if (c->flags->mode == MULTI) {\n               CLUSTER_THROW_EXCEPTION(\"Can't process MULTI sequence when cluster is resharding\", 0);\n               return -1;\n           }\n\n           if (c->redir_type == REDIR_MOVED) {\n               /* For MOVED redirection we want to update our cached mapping */\n               cluster_update_slot(c);\n               c->cmd_sock = SLOT_SOCK(c, slot);\n           } else if (c->redir_type == REDIR_ASK) {\n               /* For ASK redirection we want to redirect but not update slot mapping */\n               c->cmd_sock = cluster_get_asking_sock(c);\n           }\n        }\n\n        /* See if we've timed out in the command loop */\n        timedout = c->waitms ? mstime() - msstart >= c->waitms : 0;\n    } while (!c->clusterdown && !timedout);\n\n    // If we've detected the cluster is down, throw an exception\n    if (c->clusterdown) {\n        CLUSTER_THROW_EXCEPTION(\"The Redis Cluster is down (CLUSTERDOWN)\", 0);\n        return -1;\n    } else if (timedout || resp == -1) {\n        // Make sure the socket is reconnected, it such that it is in a clean state\n        redis_sock_disconnect(c->cmd_sock, 1, 1);\n\n        if (timedout) {\n            CLUSTER_THROW_EXCEPTION(\"Timed out attempting to find data in the correct node!\", 0);\n        } else {\n            CLUSTER_THROW_EXCEPTION(\"Error processing response from Redis node!\", 0);\n        }\n\n        return -1;\n    }\n\n    /* Clear redirection flag */\n    c->redir_type = REDIR_NONE;\n\n    // Success, return the slot where data exists.\n    return 0;\n}\n\n/* RedisCluster response handlers.  These methods all have the same prototype\n * and set the proper return value for the calling cluster method.  These\n * methods will never be called in the case of a communication error when\n * we try to send the request to the Cluster *or* if a non MOVED or ASK\n * error is encountered, in which case our response processing macro will\n * short circuit and RETURN_FALSE, as the error will have already been\n * consumed. */\n\n/* RAW bulk response handler */\nPHP_REDIS_API void cluster_bulk_raw_resp(INTERNAL_FUNCTION_PARAMETERS,\n                                  redisCluster *c, void *ctx)\n{\n    char *resp;\n\n    // Make sure we can read the response\n    if (c->reply_type != TYPE_BULK ||\n       (resp = redis_sock_read_bulk_reply(c->cmd_sock, c->reply_len)) == NULL)\n    {\n        if (c->flags->mode != MULTI) {\n            RETURN_FALSE;\n        } else {\n            add_next_index_bool(&c->multi_resp, 0);\n            return;\n        }\n    }\n\n    // Return our response raw\n    CLUSTER_RETURN_STRING(c, resp, c->reply_len);\n    efree(resp);\n}\n\nPHP_REDIS_API void\ncluster_single_line_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx)\n{\n    char *p;\n\n    /* Cluster already has the reply so abort if this isn't a LINE response *or* if for\n     * some freaky reason we don't detect a null terminator */\n    if (c->reply_type != TYPE_LINE || !(p = memchr(c->line_reply,'\\0',sizeof(c->line_reply)))) {\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        CLUSTER_RETURN_STRING(c, c->line_reply, p - c->line_reply);\n    } else {\n        add_next_index_stringl(&c->multi_resp, c->line_reply, p - c->line_reply);\n    }\n}\n\n/* BULK response handler */\nPHP_REDIS_API void cluster_bulk_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                              void *ctx)\n{\n    char *resp;\n\n    // Make sure we can read the response\n    if (c->reply_type != TYPE_BULK ||\n       (resp = redis_sock_read_bulk_reply(c->cmd_sock, c->reply_len)) == NULL)\n    {\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        if (!redis_unpack(c->flags, resp, c->reply_len, return_value)) {\n            CLUSTER_RETURN_STRING(c, resp, c->reply_len);\n        }\n    } else {\n        zval z_unpacked;\n        if (redis_unpack(c->flags, resp, c->reply_len, &z_unpacked)) {\n            add_next_index_zval(&c->multi_resp, &z_unpacked);\n        } else {\n            add_next_index_stringl(&c->multi_resp, resp, c->reply_len);\n        }\n    }\n    efree(resp);\n}\n\n/* Bulk response where we expect a double */\nPHP_REDIS_API void cluster_dbl_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                             void *ctx)\n{\n    char *resp;\n    double dbl;\n\n    // Make sure we can read the response\n    if (c->reply_type != TYPE_BULK ||\n       (resp = redis_sock_read_bulk_reply(c->cmd_sock, c->reply_len)) == NULL)\n    {\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    // Convert to double, free response\n    dbl = atof(resp);\n    efree(resp);\n\n    CLUSTER_RETURN_DOUBLE(c, dbl);\n}\n\n/* A boolean response.  If we get here, we've consumed the '+' reply\n * type and will now just verify we can read the OK */\nPHP_REDIS_API void cluster_bool_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                              void *ctx)\n{\n    // Check that we have +OK\n    if (c->reply_type != TYPE_LINE || c->reply_len != 2 ||\n       c->line_reply[0] != 'O' || c->line_reply[1] != 'K')\n    {\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    CLUSTER_RETURN_BOOL(c, 1);\n}\n\n/* Boolean response, specialized for PING */\nPHP_REDIS_API void cluster_ping_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                              void *ctx)\n{\n    if (c->reply_type != TYPE_LINE || c->reply_len != 4 ||\n       memcmp(c->line_reply,\"PONG\",sizeof(\"PONG\")-1))\n    {\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    CLUSTER_RETURN_BOOL(c, 1);\n}\n\nPHP_REDIS_API void\ncluster_hrandfield_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx)\n{\n    if (ctx == NULL) {\n        cluster_bulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        cluster_mbulk_raw_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR + 1) {\n        return cluster_mbulk_zipdbl_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n    }\n}\n\nPHP_REDIS_API void\ncluster_pop_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx)\n{\n    if (ctx == NULL) {\n        cluster_bulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        cluster_mbulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n    }\n}\n\nPHP_REDIS_API void\ncluster_lpos_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx)\n{\n    zval zret = {0};\n\n    c->cmd_sock->null_mbulk_as_null = c->flags->null_mbulk_as_null;\n    if (redis_read_lpos_response(&zret, c->cmd_sock, c->reply_type, c->reply_len, ctx) < 0) {\n        ZVAL_FALSE(&zret);\n    }\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        RETVAL_ZVAL(&zret, 0, 1);\n    } else {\n        add_next_index_zval(&c->multi_resp, &zret);\n    }\n}\n\nPHP_REDIS_API void\ncluster_geosearch_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx) {\n    zval zret = {0};\n\n    c->cmd_sock->null_mbulk_as_null = c->flags->null_mbulk_as_null;\n    if (c->reply_type != TYPE_MULTIBULK ||\n        redis_read_geosearch_response(&zret, c->cmd_sock, c->reply_len, ctx != NULL) < 0)\n    {\n        ZVAL_FALSE(&zret);\n    }\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        RETVAL_ZVAL(&zret, 0, 1);\n    } else {\n        add_next_index_zval(&c->multi_resp, &zret);\n    }\n}\n\nPHP_REDIS_API void\ncluster_zdiff_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx) {\n    if (ctx == NULL) {\n        cluster_mbulk_raw_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        cluster_mbulk_zipdbl_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n    }\n}\n\nPHP_REDIS_API void\ncluster_zadd_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx) {\n    ZEND_ASSERT(ctx == NULL || ctx == PHPREDIS_CTX_PTR);\n\n    if (ctx == NULL) {\n        cluster_long_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else {\n        cluster_dbl_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    }\n}\n\n\nPHP_REDIS_API void\ncluster_zrandmember_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx) {\n    if (ctx == NULL) {\n        cluster_bulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        cluster_mbulk_raw_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR + 1) {\n        cluster_mbulk_zipdbl_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n    }\n}\n\nPHP_REDIS_API void\ncluster_srandmember_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx) {\n    if (ctx == NULL) {\n        cluster_bulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        cluster_mbulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n    }\n}\n\nPHP_REDIS_API void\ncluster_object_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx) {\n    ZEND_ASSERT(ctx == PHPREDIS_CTX_PTR || ctx == PHPREDIS_CTX_PTR + 1);\n\n    if (ctx == PHPREDIS_CTX_PTR) {\n        cluster_long_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else {\n        cluster_bulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    }\n}\n\nPHP_REDIS_API void\ncluster_set_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx)\n{\n    if (ctx == NULL) {\n        cluster_bool_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else {\n        cluster_bulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    }\n}\n\n/* 1 or 0 response, for things like SETNX */\nPHP_REDIS_API void cluster_1_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                           void *ctx)\n{\n    // Validate our reply type, and check for a zero\n    if (c->reply_type != TYPE_INT || c->reply_len == 0) {\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    CLUSTER_RETURN_BOOL(c, 1);\n}\n\n/* Generic integer response */\nPHP_REDIS_API void cluster_long_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                              void *ctx)\n{\n    if (c->reply_type != TYPE_INT) {\n        CLUSTER_RETURN_FALSE(c);\n    }\n    CLUSTER_RETURN_LONG(c, c->reply_len);\n}\n\n/* TYPE response handler */\nPHP_REDIS_API void cluster_type_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                              void *ctx)\n{\n    // Make sure we got the right kind of response\n    if (c->reply_type != TYPE_LINE) {\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    // Switch on the type\n    if (redis_strncmp(c->line_reply, ZEND_STRL(\"string\")) == 0) {\n        CLUSTER_RETURN_LONG(c, REDIS_STRING);\n    } else if (redis_strncmp(c->line_reply, ZEND_STRL(\"set\")) == 0) {\n        CLUSTER_RETURN_LONG(c, REDIS_SET);\n    } else if (redis_strncmp(c->line_reply, ZEND_STRL(\"list\")) == 0) {\n        CLUSTER_RETURN_LONG(c, REDIS_LIST);\n    } else if (redis_strncmp(c->line_reply, ZEND_STRL(\"hash\")) == 0) {\n        CLUSTER_RETURN_LONG(c, REDIS_HASH);\n    } else if (redis_strncmp(c->line_reply, ZEND_STRL(\"zset\")) == 0) {\n        CLUSTER_RETURN_LONG(c, REDIS_ZSET);\n    } else if (redis_strncmp(c->line_reply, ZEND_STRL(\"stream\")) == 0) {\n        CLUSTER_RETURN_LONG(c, REDIS_STREAM);\n    } else {\n        CLUSTER_RETURN_LONG(c, REDIS_NOT_FOUND);\n    }\n}\n\n/* SUBSCRIBE/PSCUBSCRIBE handler */\nPHP_REDIS_API void cluster_sub_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                             void *ctx)\n{\n    subscribeContext *sctx = (subscribeContext*)ctx;\n    zval z_tab, *z_tmp;\n    int pull = 0;\n\n\n    // Consume each MULTI BULK response (one per channel/pattern)\n    while (sctx->argc--) {\n        if (!cluster_zval_mbulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c,\n            pull, mbulk_resp_loop_raw, &z_tab)\n        ) {\n            efree(sctx);\n            RETURN_FALSE;\n        }\n\n        if ((z_tmp = zend_hash_index_find(Z_ARRVAL(z_tab), 0)) == NULL ||\n            strcasecmp(Z_STRVAL_P(z_tmp), sctx->kw) != 0\n        ) {\n            zval_dtor(&z_tab);\n            efree(sctx);\n            RETURN_FALSE;\n        }\n\n        zval_dtor(&z_tab);\n        pull = 1;\n    }\n\n    // Set up our callback pointers\n    zval z_ret, z_args[4];\n    sctx->cb.fci.retval = &z_ret;\n    sctx->cb.fci.params = z_args;\n\n    /* We're in a subscribe loop */\n    c->subscribed_slot = c->cmd_slot;\n\n    /* Multibulk response, {[pattern], type, channel, payload} */\n    while (1) {\n        /* Arguments */\n        zval *z_type, *z_chan, *z_pat = NULL, *z_data;\n        int tab_idx = 1, is_pmsg;\n\n        // Get the next subscribe response\n        if (!cluster_zval_mbulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, 1, mbulk_resp_loop, &z_tab) ||\n            (z_type = zend_hash_index_find(Z_ARRVAL(z_tab), 0)) == NULL\n        ) {\n            break;\n        }\n\n        // Make sure we have a message or pmessage\n        if (zend_string_equals_literal(Z_STR_P(z_type), \"message\") ||\n            zend_string_equals_literal(Z_STR_P(z_type), \"pmessage\"))\n        {\n            is_pmsg = *Z_STRVAL_P(z_type) == 'p';\n        } else {\n            zval_dtor(&z_tab);\n            continue;\n        }\n\n        if (is_pmsg && (z_pat = zend_hash_index_find(Z_ARRVAL(z_tab), tab_idx++)) == NULL) {\n            break;\n        }\n\n        // Extract channel and data\n        if ((z_chan = zend_hash_index_find(Z_ARRVAL(z_tab), tab_idx++)) == NULL ||\n           (z_data = zend_hash_index_find(Z_ARRVAL(z_tab), tab_idx++)) == NULL\n        ) {\n            break;\n        }\n\n        // Always pass our object through\n        z_args[0] = *getThis();\n\n        // Set up calbacks depending on type\n        if (is_pmsg) {\n            z_args[1] = *z_pat;\n            z_args[2] = *z_chan;\n            z_args[3] = *z_data;\n        } else {\n            z_args[1] = *z_chan;\n            z_args[2] = *z_data;\n        }\n\n        // Set arg count\n        sctx->cb.fci.param_count = tab_idx;\n\n        // Execute our callback\n        if (zend_call_function(&sctx->cb.fci, &sctx->cb.fci_cache) != SUCCESS) {\n            break;\n        }\n\n        // If we have a return value, free it\n        zval_ptr_dtor(&z_ret);\n\n        zval_dtor(&z_tab);\n    }\n\n    // We're no longer subscribing, due to an error\n    c->subscribed_slot = -1;\n\n    // Cleanup\n    zval_dtor(&z_tab);\n    efree(sctx);\n\n    // Failure\n    RETURN_FALSE;\n}\n\n/* UNSUBSCRIBE/PUNSUBSCRIBE */\nPHP_REDIS_API void cluster_unsub_resp(INTERNAL_FUNCTION_PARAMETERS,\n                               redisCluster *c, void *ctx)\n{\n    subscribeContext *sctx = (subscribeContext*)ctx;\n    zval z_tab, *z_chan, *z_flag;\n    int pull = 0, argc = sctx->argc;\n\n    efree(sctx);\n    array_init(return_value);\n\n    // Consume each response\n    while (argc--) {\n        // Fail if we didn't get an array or can't find index 1\n        if (!cluster_zval_mbulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, pull, mbulk_resp_loop_raw, &z_tab) ||\n            (z_chan = zend_hash_index_find(Z_ARRVAL(z_tab), 1)) == NULL\n        ) {\n            zval_dtor(&z_tab);\n            zval_dtor(return_value);\n            RETURN_FALSE;\n        }\n\n        // Find the flag for this channel/pattern\n        if ((z_flag = zend_hash_index_find(Z_ARRVAL(z_tab), 2)) == NULL ||\n            Z_STRLEN_P(z_flag) != 2\n        ) {\n            zval_dtor(&z_tab);\n            zval_dtor(return_value);\n            RETURN_FALSE;\n        }\n\n        // Redis will give us either :1 or :0 here\n        char *flag = Z_STRVAL_P(z_flag);\n\n        // Add result\n        add_assoc_bool(return_value, Z_STRVAL_P(z_chan), flag[1] == '1');\n\n        zval_dtor(&z_tab);\n        pull = 1;\n    }\n}\n\n/* Recursive MULTI BULK -> PHP style response handling */\nstatic void cluster_mbulk_variant_resp(clusterReply *r, int null_mbulk_as_null,\n                                       zval *z_ret)\n{\n    zval z_sub_ele;\n    long long i;\n\n    switch(r->type) {\n        case TYPE_INT:\n            add_next_index_long(z_ret, r->integer);\n            break;\n        case TYPE_LINE:\n            if (r->str) {\n                add_next_index_stringl(z_ret, r->str, r->len);\n            } else {\n                add_next_index_bool(z_ret, 1);\n            }\n            break;\n        case TYPE_BULK:\n            if (r->len > -1) {\n                add_next_index_stringl(z_ret, r->str, r->len);\n            } else {\n                add_next_index_null(z_ret);\n            }\n            break;\n        case TYPE_MULTIBULK:\n            if (r->elements < 0 && null_mbulk_as_null) {\n                add_next_index_null(z_ret);\n            } else {\n                array_init(&z_sub_ele);\n                for (i = 0; i < r->elements; i++) {\n                    cluster_mbulk_variant_resp(r->element[i], null_mbulk_as_null, &z_sub_ele);\n                }\n                add_next_index_zval(z_ret, &z_sub_ele);\n            }\n            break;\n        default:\n            add_next_index_bool(z_ret, 0);\n            break;\n    }\n}\n\n/* Variant response handling, for things like EVAL and various other responses\n * where we just map the replies from Redis type values to PHP ones directly. */\nstatic void\ncluster_variant_resp_generic(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                             int status_strings, void *ctx)\n{\n    clusterReply *r;\n    zval zv, *z_arr = &zv;\n    long long i;\n\n    // Make sure we can read it\n    if ((r = cluster_read_resp(c, status_strings)) == NULL) {\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    // Handle ATOMIC vs. MULTI mode in a separate switch\n    if (CLUSTER_IS_ATOMIC(c)) {\n        switch(r->type) {\n            case TYPE_INT:\n                RETVAL_LONG(r->integer);\n                break;\n            case TYPE_ERR:\n                RETVAL_FALSE;\n                break;\n            case TYPE_LINE:\n                if (status_strings) {\n                    RETVAL_STRINGL(r->str, r->len);\n                } else {\n                    RETVAL_TRUE;\n                }\n                break;\n            case TYPE_BULK:\n                if (r->len < 0) {\n                    RETVAL_NULL();\n                } else {\n                    RETVAL_STRINGL(r->str, r->len);\n                }\n                break;\n            case TYPE_MULTIBULK:\n                if (r->elements < 0 && c->flags->null_mbulk_as_null) {\n                    RETVAL_NULL();\n                } else {\n                    array_init(z_arr);\n                    for (i = 0; i < r->elements; i++) {\n                        cluster_mbulk_variant_resp(r->element[i], c->flags->null_mbulk_as_null, z_arr);\n                    }\n                    RETVAL_ZVAL(z_arr, 0, 0);\n                }\n                break;\n            default:\n                RETVAL_FALSE;\n                break;\n        }\n    } else {\n        switch(r->type) {\n            case TYPE_INT:\n                add_next_index_long(&c->multi_resp, r->integer);\n                break;\n            case TYPE_ERR:\n                add_next_index_bool(&c->multi_resp, 0);\n                break;\n            case TYPE_LINE:\n                if (status_strings) {\n                    add_next_index_stringl(&c->multi_resp, r->str, r->len);\n                } else {\n                    add_next_index_bool(&c->multi_resp, 1);\n                }\n                break;\n            case TYPE_BULK:\n                if (r->len < 0) {\n                    add_next_index_null(&c->multi_resp);\n                } else {\n                    add_next_index_stringl(&c->multi_resp, r->str, r->len);\n                }\n                break;\n            case TYPE_MULTIBULK:\n                if (r->elements < 0 && c->flags->null_mbulk_as_null) {\n                    add_next_index_null(&c->multi_resp);\n                } else {\n                    cluster_mbulk_variant_resp(r, c->flags->null_mbulk_as_null, &c->multi_resp);\n                }\n                break;\n            default:\n                add_next_index_bool(&c->multi_resp, 0);\n                break;\n        }\n    }\n\n    // Free our response structs, but not allocated data itself\n    cluster_free_reply(r, 1);\n}\n\nPHP_REDIS_API void\ncluster_zrange_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx) {\n    cluster_cb cb;\n\n    ZEND_ASSERT(ctx == NULL || ctx == PHPREDIS_CTX_PTR);\n\n    cb = ctx ? cluster_mbulk_zipdbl_resp : cluster_mbulk_resp;\n\n    cb(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, ctx);\n}\n\nPHP_REDIS_API void cluster_variant_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                                        void *ctx)\n{\n    cluster_variant_resp_generic(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, 0, ctx);\n}\n\nPHP_REDIS_API void cluster_variant_raw_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                                            void *ctx)\n{\n    cluster_variant_resp_generic(INTERNAL_FUNCTION_PARAM_PASSTHRU, c,\n                                 c->flags->reply_literal, ctx);\n}\n\nPHP_REDIS_API void cluster_variant_resp_strings(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                                        void *ctx)\n{\n    cluster_variant_resp_generic(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, 1, ctx);\n}\n\n/* Generic MULTI BULK response processor */\nPHP_REDIS_API void cluster_gen_mbulk_resp(INTERNAL_FUNCTION_PARAMETERS,\n                                   redisCluster *c, mbulk_cb cb, void *ctx)\n{\n    zval z_result;\n\n    /* Abort if the reply isn't MULTIBULK or has an invalid length */\n    if (c->reply_type != TYPE_MULTIBULK || c->reply_len < -1) {\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    if (c->reply_len == -1 && c->flags->null_mbulk_as_null) {\n        ZVAL_NULL(&z_result);\n    } else {\n        array_init(&z_result);\n\n        if (c->reply_len > 0) {\n            /* Push serialization settings from the cluster into our socket */\n            c->cmd_sock->serializer = c->flags->serializer;\n            c->cmd_sock->compression = c->flags->compression;\n\n            /* Call our specified callback */\n            if (cb(c->cmd_sock, &z_result, c->reply_len, ctx) == FAILURE) {\n                zval_dtor(&z_result);\n                CLUSTER_RETURN_FALSE(c);\n            }\n        }\n    }\n\n    // Success, make this array our return value\n    if (CLUSTER_IS_ATOMIC(c)) {\n        RETVAL_ZVAL(&z_result, 0, 1);\n    } else {\n        add_next_index_zval(&c->multi_resp, &z_result);\n    }\n}\n\n/* HSCAN, SSCAN, ZSCAN */\nPHP_REDIS_API int\ncluster_scan_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                  REDIS_SCAN_TYPE type, uint64_t *cursor)\n{\n    char *pit;\n\n    // We always want to see a MULTIBULK response with two elements\n    if (c->reply_type != TYPE_MULTIBULK || c->reply_len != 2)\n    {\n        return FAILURE;\n    }\n\n    // Read the BULK size\n    if (cluster_check_response(c, &c->reply_type) ||\n        c->reply_type != TYPE_BULK)\n    {\n        return FAILURE;\n    }\n\n    // Read the iterator\n    if ((pit = redis_sock_read_bulk_reply(c->cmd_sock,c->reply_len)) == NULL)\n    {\n        return FAILURE;\n    }\n\n    // Push the new iterator value to our caller\n    *cursor = strtoull(pit, NULL, 10);\n    efree(pit);\n\n    // We'll need another MULTIBULK response for the payload\n    if (cluster_check_response(c, &c->reply_type) < 0) {\n        return FAILURE;\n    }\n\n    // Use the proper response callback depending on scan type\n    switch(type) {\n        case TYPE_SCAN:\n            cluster_mbulk_raw_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU,c,NULL);\n            break;\n        case TYPE_SSCAN:\n            cluster_mbulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU,c,NULL);\n            break;\n        case TYPE_HSCAN:\n            cluster_mbulk_zipstr_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU,c,NULL);\n            break;\n        case TYPE_ZSCAN:\n            cluster_mbulk_zipdbl_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU,c,NULL);\n            break;\n        default:\n            return FAILURE;\n    }\n\n    // Success\n    return SUCCESS;\n}\n\n/* INFO response */\nPHP_REDIS_API void cluster_info_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                              void *ctx)\n{\n    zval z_result;\n    char *info;\n\n    // Read our bulk response\n    if ((info = redis_sock_read_bulk_reply(c->cmd_sock, c->reply_len)) == NULL)\n    {\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    /* Parse response, free memory */\n    redis_parse_info_response(info, &z_result);\n    efree(info);\n\n    // Return our array\n    if (CLUSTER_IS_ATOMIC(c)) {\n        RETVAL_ZVAL(&z_result, 0, 1);\n    } else {\n        add_next_index_zval(&c->multi_resp, &z_result);\n    }\n}\n\n/* CLIENT LIST response */\nPHP_REDIS_API void cluster_client_list_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                                     void *ctx)\n{\n    char *info;\n    zval z_result;\n\n    /* Read the bulk response */\n    info = redis_sock_read_bulk_reply(c->cmd_sock, c->reply_len);\n    if (info == NULL) {\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    /* Parse it and free the bulk string */\n    redis_parse_client_list_response(info, &z_result);\n    efree(info);\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        RETVAL_ZVAL(&z_result, 0, 1);\n    } else {\n        add_next_index_zval(&c->multi_resp, &z_result);\n    }\n}\n\n/* XRANGE */\nPHP_REDIS_API void\ncluster_xrange_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx) {\n    zval z_messages;\n\n    array_init(&z_messages);\n\n    c->cmd_sock->serializer = c->flags->serializer;\n    c->cmd_sock->compression = c->flags->compression;\n\n    if (redis_read_stream_messages(c->cmd_sock, c->reply_len, &z_messages) < 0) {\n        zval_dtor(&z_messages);\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        RETVAL_ZVAL(&z_messages, 0, 1);\n    } else {\n        add_next_index_zval(&c->multi_resp, &z_messages);\n    }\n}\n\n/* XREAD */\nPHP_REDIS_API void\ncluster_xread_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx) {\n    zval z_streams;\n\n    c->cmd_sock->serializer = c->flags->serializer;\n    c->cmd_sock->compression = c->flags->compression;\n\n    if (c->reply_len == -1 && c->flags->null_mbulk_as_null) {\n        ZVAL_NULL(&z_streams);\n    } else {\n        array_init(&z_streams);\n        if (redis_read_stream_messages_multi(c->cmd_sock, c->reply_len, &z_streams) < 0) {\n            zval_dtor(&z_streams);\n            CLUSTER_RETURN_FALSE(c);\n        }\n    }\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        RETVAL_ZVAL(&z_streams, 0, 1);\n    } else {\n        add_next_index_zval(&c->multi_resp, &z_streams);\n    }\n}\n\n/* XCLAIM */\nPHP_REDIS_API void\ncluster_xclaim_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx) {\n    zval z_msg;\n\n    array_init(&z_msg);\n\n    ZEND_ASSERT(ctx == NULL || ctx == PHPREDIS_CTX_PTR);\n\n    if (redis_read_xclaim_reply(c->cmd_sock, c->reply_len, ctx == PHPREDIS_CTX_PTR, &z_msg) < 0) {\n        zval_dtor(&z_msg);\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        RETVAL_ZVAL(&z_msg, 0, 1);\n    } else {\n        add_next_index_zval(&c->multi_resp, &z_msg);\n    }\n\n}\n\n/* XINFO */\nPHP_REDIS_API void\ncluster_xinfo_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx)\n{\n    zval z_ret;\n\n    array_init(&z_ret);\n    if (redis_read_xinfo_response(c->cmd_sock, &z_ret, c->reply_len) != SUCCESS) {\n        zval_dtor(&z_ret);\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        RETURN_ZVAL(&z_ret, 0, 1);\n    }\n    add_next_index_zval(&c->multi_resp, &z_ret);\n}\n\n/* LMPOP, ZMPOP, BLMPOP, BZMPOP */\nPHP_REDIS_API void\ncluster_mpop_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx)\n{\n    zval z_ret;\n\n    c->cmd_sock->null_mbulk_as_null = c->flags->null_mbulk_as_null;\n    if (redis_read_mpop_response(c->cmd_sock, &z_ret, c->reply_len, ctx) == FAILURE) {\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        RETURN_ZVAL(&z_ret, 0, 0);\n    }\n    add_next_index_zval(&c->multi_resp, &z_ret);\n}\n\nstatic void\ncluster_acl_custom_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx,\n                        int (*cb)(RedisSock*, zval*, long))\n{\n    zval z_ret;\n\n    array_init(&z_ret);\n    if (cb(c->cmd_sock, &z_ret, c->reply_len) != SUCCESS) {\n        zval_dtor(&z_ret);\n        CLUSTER_RETURN_FALSE(c);\n    }\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        RETURN_ZVAL(&z_ret, 0, 1);\n    }\n    add_next_index_zval(&c->multi_resp, &z_ret);\n}\n\nPHP_REDIS_API void\ncluster_acl_getuser_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx) {\n    cluster_acl_custom_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, ctx, redis_read_acl_getuser_reply);\n}\n\nPHP_REDIS_API void\ncluster_acl_log_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx) {\n    cluster_acl_custom_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, ctx, redis_read_acl_log_reply);\n}\n\n/* MULTI BULK response loop where we might pull the next one */\nPHP_REDIS_API zval *cluster_zval_mbulk_resp(INTERNAL_FUNCTION_PARAMETERS,\n                                     redisCluster *c, int pull, mbulk_cb cb, zval *z_ret)\n{\n    ZVAL_NULL(z_ret);\n\n    // Pull our next response if directed\n    if (pull) {\n        if (cluster_check_response(c, &c->reply_type) < 0)\n        {\n            return NULL;\n        }\n    }\n\n    // Validate reply type and length\n    if (c->reply_type != TYPE_MULTIBULK || c->reply_len == -1) {\n        return NULL;\n    }\n\n    array_init(z_ret);\n\n    // Call our callback\n    if (cb(c->cmd_sock, z_ret, c->reply_len, NULL) == FAILURE) {\n        zval_dtor(z_ret);\n        return NULL;\n    }\n\n    return z_ret;\n}\n\n/* MULTI MULTI BULK reply (for EXEC) */\nPHP_REDIS_API void cluster_multi_mbulk_resp(INTERNAL_FUNCTION_PARAMETERS,\n                                     redisCluster *c, void *ctx)\n{\n    zval *multi_resp = &c->multi_resp;\n    array_init(multi_resp);\n\n    clusterFoldItem *fi = c->multi_head;\n    while (fi) {\n        /* Make sure our transaction didn't fail here */\n        if (c->multi_len[fi->slot] > -1) {\n            /* Set the slot where we should look for responses.  We don't allow\n             * failover inside a transaction, so it will be the master we have\n             * mapped. */\n            c->cmd_slot = fi->slot;\n            c->cmd_sock = SLOT_SOCK(c, fi->slot);\n\n            if (cluster_check_response(c, &c->reply_type) < 0) {\n                zval_dtor(multi_resp);\n                RETURN_FALSE;\n            }\n\n            fi->callback(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, fi->ctx);\n        } else {\n            /* Just add false */\n            add_next_index_bool(multi_resp, 0);\n        }\n        fi = fi->next;\n    }\n\n    // Set our return array\n    zval_dtor(return_value);\n    RETVAL_ZVAL(multi_resp, 0, 1);\n}\n\n/* Generic handler for MGET */\nPHP_REDIS_API void cluster_mbulk_mget_resp(INTERNAL_FUNCTION_PARAMETERS,\n                                    redisCluster *c, void *ctx)\n{\n    clusterMultiCtx *mctx = (clusterMultiCtx*)ctx;\n\n    /* Protect against an invalid response type, -1 response length, and failure\n     * to consume the responses. */\n    c->cmd_sock->serializer = c->flags->serializer;\n    c->cmd_sock->compression = c->flags->compression;\n    short fail = c->reply_type != TYPE_MULTIBULK || c->reply_len == -1 ||\n        mbulk_resp_loop(c->cmd_sock, mctx->z_multi, c->reply_len, NULL) == FAILURE;\n\n    // If we had a failure, pad results with FALSE to indicate failure.  Non\n    // existent keys (e.g. for MGET will come back as NULL)\n    if (fail) {\n        while (mctx->count--) {\n            add_next_index_bool(mctx->z_multi, 0);\n        }\n    }\n\n    // If this is the tail of our multi command, we can set our returns\n    if (mctx->last) {\n        if (CLUSTER_IS_ATOMIC(c)) {\n            RETVAL_ZVAL(mctx->z_multi, 0, 1);\n        } else {\n            add_next_index_zval(&c->multi_resp, mctx->z_multi);\n        }\n\n        efree(mctx->z_multi);\n    }\n\n    // Clean up this context item\n    efree(mctx);\n}\n\n/* Handler for MSETNX */\nPHP_REDIS_API void cluster_msetnx_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                                void *ctx)\n{\n    clusterMultiCtx *mctx = (clusterMultiCtx*)ctx;\n    int real_argc = mctx->count/2;\n\n    // Protect against an invalid response type\n    if (c->reply_type != TYPE_INT) {\n        php_error_docref(0, E_WARNING,\n            \"Invalid response type for MSETNX\");\n        while (real_argc--) {\n            add_next_index_bool(mctx->z_multi, 0);\n        }\n        return;\n    }\n\n    // Response will be 1/0 per key, so the client can match them up\n    while (real_argc--) {\n        add_next_index_long(mctx->z_multi, c->reply_len);\n    }\n\n    // Set return value if it's our last response\n    if (mctx->last) {\n        if (CLUSTER_IS_ATOMIC(c)) {\n            RETVAL_ZVAL(mctx->z_multi, 0, 0);\n        } else {\n            add_next_index_zval(&c->multi_resp, mctx->z_multi);\n        }\n        efree(mctx->z_multi);\n    }\n\n    // Free multi context\n    efree(mctx);\n}\n\n/* Handler for DEL */\nPHP_REDIS_API void cluster_del_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                             void *ctx)\n{\n    clusterMultiCtx *mctx = (clusterMultiCtx*)ctx;\n\n    // If we get an invalid reply, inform the client\n    if (c->reply_type != TYPE_INT) {\n        php_error_docref(0, E_WARNING,\n            \"Invalid reply type returned for DEL command\");\n        efree(mctx);\n        return;\n    }\n\n    // Increment by the number of keys deleted\n    Z_LVAL_P(mctx->z_multi) += c->reply_len;\n\n    if (mctx->last) {\n        if (CLUSTER_IS_ATOMIC(c)) {\n            ZVAL_LONG(return_value, Z_LVAL_P(mctx->z_multi));\n        } else {\n            add_next_index_long(&c->multi_resp, Z_LVAL_P(mctx->z_multi));\n        }\n        efree(mctx->z_multi);\n    }\n\n    efree(ctx);\n}\n\n/* Handler for MSET */\nPHP_REDIS_API void cluster_mset_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                              void *ctx)\n{\n    clusterMultiCtx *mctx = (clusterMultiCtx*)ctx;\n\n    // If we get an invalid reply type something very wrong has happened,\n    // and we have to abort.\n    if (c->reply_type != TYPE_LINE) {\n        php_error_docref(0, E_ERROR,\n            \"Invalid reply type returned for MSET command\");\n        zval_dtor(mctx->z_multi);\n        efree(mctx->z_multi);\n        efree(mctx);\n        RETURN_FALSE;\n    }\n\n    // Set our return if it's the last call\n    if (mctx->last) {\n        if (CLUSTER_IS_ATOMIC(c)) {\n            ZVAL_BOOL(return_value, zval_is_true(mctx->z_multi));\n        } else {\n            add_next_index_bool(&c->multi_resp, zval_is_true(mctx->z_multi));\n        }\n        efree(mctx->z_multi);\n    }\n\n    efree(mctx);\n}\n\n/* Raw MULTI BULK reply */\nPHP_REDIS_API void\ncluster_mbulk_raw_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx)\n{\n    cluster_gen_mbulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c,\n        mbulk_resp_loop_raw, NULL);\n}\n\n/* Unserialize all the things */\nPHP_REDIS_API void\ncluster_mbulk_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx)\n{\n    cluster_gen_mbulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c,\n        mbulk_resp_loop, NULL);\n}\n\n/* For handling responses where we get key, value, key, value that\n * we will turn into key => value, key => value. */\nPHP_REDIS_API void\ncluster_mbulk_zipstr_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                          void *ctx)\n{\n    cluster_gen_mbulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c,\n        mbulk_resp_loop_zipstr, NULL);\n}\n\n/* Handling key,value to key=>value where the values are doubles */\nPHP_REDIS_API void\ncluster_mbulk_zipdbl_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                          void *ctx)\n{\n    cluster_gen_mbulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c,\n        mbulk_resp_loop_zipdbl, NULL);\n}\n\nPHP_REDIS_API void\ncluster_mbulk_dbl_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                       void *ctx)\n{\n    cluster_gen_mbulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c,\n        mbulk_resp_loop_dbl, ctx);\n}\n\n/* Associate multi bulk response (for HMGET really) */\nPHP_REDIS_API void\ncluster_mbulk_assoc_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                         void *ctx)\n{\n    cluster_gen_mbulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c,\n        mbulk_resp_loop_assoc, ctx);\n}\n\n/*\n * Various MULTI BULK reply callback functions\n */\n\nint mbulk_resp_loop_dbl(RedisSock *redis_sock, zval *z_result,\n                        long long count, void *ctx)\n{\n    char *line;\n    int line_len;\n\n    while (count--) {\n        line = redis_sock_read(redis_sock, &line_len);\n        if (line != NULL) {\n            add_next_index_double(z_result, atof(line));\n            efree(line);\n        } else {\n            add_next_index_bool(z_result, 0);\n        }\n    }\n\n    return SUCCESS;\n}\n\n/* MULTI BULK response where we don't touch the values (e.g. KEYS) */\nint mbulk_resp_loop_raw(RedisSock *redis_sock, zval *z_result,\n                        long long count, void *ctx)\n{\n    char *line;\n    int line_len;\n\n    // Iterate over the number we have\n    while (count--) {\n        // Read the line, which should never come back null\n        line = redis_sock_read(redis_sock, &line_len);\n        if (line == NULL) return FAILURE;\n\n        // Add to our result array\n        add_next_index_stringl(z_result, line, line_len);\n        efree(line);\n    }\n\n    // Success!\n    return SUCCESS;\n}\n\n/* MULTI BULK response where we unserialize everything */\nint mbulk_resp_loop(RedisSock *redis_sock, zval *z_result,\n                    long long count, void *ctx)\n{\n    char *line;\n    int line_len;\n\n    /* Iterate over the lines we have to process */\n    while (count--) {\n        /* Read our line */\n        line = redis_sock_read(redis_sock, &line_len);\n\n        if (line != NULL) {\n            zval z_unpacked;\n            if (redis_unpack(redis_sock, line, line_len, &z_unpacked)) {\n                add_next_index_zval(z_result, &z_unpacked);\n            } else {\n                add_next_index_stringl(z_result, line, line_len);\n            }\n            efree(line);\n        } else {\n            add_next_index_bool(z_result, 0);\n        }\n    }\n\n    return SUCCESS;\n}\n\n/* MULTI BULK response where we turn key1,value1 into key1=>value1 */\nint mbulk_resp_loop_zipstr(RedisSock *redis_sock, zval *z_result,\n                           long long count, void *ctx)\n{\n    char *line, *key = NULL;\n    int line_len, key_len = 0;\n    long long idx = 0;\n\n    // Our count will need to be divisible by 2\n    if (count % 2 != 0) {\n        return -1;\n    }\n\n    // Iterate through our elements\n    while (count--) {\n        // Grab our line, bomb out on failure\n        line = redis_sock_read(redis_sock, &line_len);\n        if (!line) return -1;\n\n        if (idx++ % 2 == 0) {\n            // Save our key and length\n            key = line;\n            key_len = line_len;\n        } else {\n            /* Attempt unpacking */\n            zval z_unpacked;\n            if (redis_unpack(redis_sock, line, line_len, &z_unpacked)) {\n                add_assoc_zval(z_result, key, &z_unpacked);\n            } else {\n                add_assoc_stringl_ex(z_result, key, key_len, line, line_len);\n            }\n\n            efree(line);\n            efree(key);\n        }\n    }\n\n    return SUCCESS;\n}\n\n/* MULTI BULK loop processor where we expect key,score key, score */\nint mbulk_resp_loop_zipdbl(RedisSock *redis_sock, zval *z_result,\n                           long long count, void *ctx)\n{\n    char *line, *key = NULL;\n    int line_len, key_len = 0;\n    long long idx = 0;\n\n    // Our context will need to be divisible by 2\n    if (count %2 != 0) {\n        return -1;\n    }\n\n    // While we have elements\n    while (count--) {\n        line = redis_sock_read(redis_sock, &line_len);\n        if (line != NULL) {\n            if (idx++ % 2 == 0) {\n                key = line;\n                key_len = line_len;\n            } else {\n                zval zv, *z = &zv;\n                if (redis_unpack(redis_sock,key,key_len, z)) {\n                    zend_string *zstr = zval_get_string(z);\n                    add_assoc_double_ex(z_result, ZSTR_VAL(zstr), ZSTR_LEN(zstr), atof(line));\n                    zend_string_release(zstr);\n                    zval_dtor(z);\n                } else {\n                    add_assoc_double_ex(z_result, key, key_len, atof(line));\n                }\n\n                /* Free our key and line */\n                efree(key);\n                efree(line);\n            }\n        }\n    }\n\n    return SUCCESS;\n}\n\n/* MULTI BULK where we're passed the keys, and we attach vals */\nint mbulk_resp_loop_assoc(RedisSock *redis_sock, zval *z_result,\n                          long long count, void *ctx)\n{\n    char *line;\n    int line_len, i;\n    zval *z_keys = ctx;\n\n    // Loop while we've got replies\n    for (i = 0; i < count; ++i) {\n        zend_string *zstr = zval_get_string(&z_keys[i]);\n        line = redis_sock_read(redis_sock, &line_len);\n\n        if (line != NULL) {\n            zval z_unpacked;\n            if (redis_unpack(redis_sock, line, line_len, &z_unpacked)) {\n                add_assoc_zval_ex(z_result, ZSTR_VAL(zstr), ZSTR_LEN(zstr), &z_unpacked);\n            } else {\n                add_assoc_stringl_ex(z_result, ZSTR_VAL(zstr), ZSTR_LEN(zstr), line, line_len);\n            }\n            efree(line);\n        } else {\n            add_assoc_bool_ex(z_result, ZSTR_VAL(zstr), ZSTR_LEN(zstr), 0);\n        }\n\n        // Clean up key context\n        zend_string_release(zstr);\n        zval_dtor(&z_keys[i]);\n    }\n\n    // Clean up our keys overall\n    efree(z_keys);\n\n    // Success!\n    return SUCCESS;\n}\n\n/* Free an array of zend_string seeds */\nvoid free_seed_array(zend_string **seeds, uint32_t nseeds) {\n    int i;\n\n    if (seeds == NULL)\n        return;\n\n    for (i = 0; i < nseeds; i++)\n        zend_string_release(seeds[i]);\n\n    efree(seeds);\n}\n\nstatic zend_string **get_valid_seeds(HashTable *input, uint32_t *nseeds) {\n    HashTable *valid;\n    uint32_t count, idx = 0;\n    zval *z_seed;\n    zend_string *zkey, **seeds = NULL;\n\n    /* Short circuit if we don't have any sees */\n    count = zend_hash_num_elements(input);\n    if (count == 0)\n        return NULL;\n\n    ALLOC_HASHTABLE(valid);\n    zend_hash_init(valid, count, NULL, NULL, 0);\n\n    ZEND_HASH_FOREACH_VAL(input, z_seed) {\n        ZVAL_DEREF(z_seed);\n\n        if (Z_TYPE_P(z_seed) != IS_STRING) {\n            php_error_docref(NULL, E_WARNING, \"Skipping non-string entry in seeds array\");\n            continue;\n        } else if (strrchr(Z_STRVAL_P(z_seed), ':') == NULL) {\n            php_error_docref(NULL, E_WARNING,\n                \"Seed '%s' not in host:port format, ignoring\", Z_STRVAL_P(z_seed));\n            continue;\n        }\n\n        /* Add as a key to avoid duplicates */\n        zend_hash_str_add_empty_element(valid, Z_STRVAL_P(z_seed), Z_STRLEN_P(z_seed));\n    } ZEND_HASH_FOREACH_END();\n\n    /* We need at least one valid seed */\n    count = zend_hash_num_elements(valid);\n    if (count == 0)\n        goto cleanup;\n\n    /* Populate our return array */\n    seeds = ecalloc(count, sizeof(*seeds));\n    ZEND_HASH_FOREACH_STR_KEY(valid, zkey) {\n        seeds[idx++] = zend_string_copy(zkey);\n    } ZEND_HASH_FOREACH_END();\n\n    *nseeds = idx;\n\ncleanup:\n    zend_hash_destroy(valid);\n    FREE_HASHTABLE(valid);\n\n    return seeds;\n}\n\n/* Validate cluster construction arguments and return a sanitized and validated\n * array of seeds */\nzend_string**\ncluster_validate_args(double timeout, double read_timeout, HashTable *seeds,\n                      uint32_t *nseeds, char **errstr)\n{\n    zend_string **retval;\n\n    if (timeout > INT_MAX) {\n        if (errstr) *errstr = \"Invalid timeout\";\n        return NULL;\n    }\n\n    if (read_timeout > INT_MAX) {\n        if (errstr) *errstr = \"Invalid read timeout\";\n        return NULL;\n    }\n\n    retval = get_valid_seeds(seeds, nseeds);\n    if (retval == NULL && errstr)\n        *errstr = \"No valid seeds detected\";\n\n    return retval;\n}\n\n/* Helper function to compare to host:port seeds */\nstatic int cluster_cmp_seeds(const void *a, const void *b) {\n    zend_string *za = *(zend_string **)a;\n    zend_string *zb = *(zend_string **)b;\n    return strcmp(ZSTR_VAL(za), ZSTR_VAL(zb));\n}\n\nstatic void cluster_swap_seeds(void *a, void *b) {\n    zend_string **za, **zb, *tmp;\n\n    za = a;\n    zb = b;\n\n    tmp = *za;\n    *za = *zb;\n    *zb = tmp;\n}\n\n/* Turn an array of cluster seeds into a string we can cache.  If we get here we know\n * we have at least one entry and that every entry is a string in the form host:port */\n#define SLOT_CACHE_PREFIX \"phpredis_slots:\"\nzend_string *cluster_hash_seeds(zend_string **seeds, uint32_t count) {\n    smart_str hash = {0};\n    size_t i;\n\n    /* Sort our seeds so any any array with identical seeds hashes to the same key\n     * regardless of what order the user gives them to us in. */\n    zend_sort(seeds, count, sizeof(*seeds), cluster_cmp_seeds, cluster_swap_seeds);\n\n    /* Global phpredis hash prefix */\n    smart_str_appendl(&hash, SLOT_CACHE_PREFIX, sizeof(SLOT_CACHE_PREFIX) - 1);\n\n    /* Construct our actual hash */\n    for (i = 0; i < count; i++) {\n        smart_str_appendc(&hash, '[');\n        smart_str_append_ex(&hash, seeds[i], 0);\n        smart_str_appendc(&hash, ']');\n    }\n\n    /* Null terminate */\n    smart_str_0(&hash);\n\n    /* Return the internal zend_string */\n    return hash.s;\n}\n\nPHP_REDIS_API redisCachedCluster *cluster_cache_load(zend_string *hash) {\n    zend_resource *le;\n\n    /* Look for cached slot information */\n    le = zend_hash_find_ptr(&EG(persistent_list), hash);\n\n    if (le != NULL) {\n        /* Sanity check on our list type */\n        if (le->type == le_cluster_slot_cache) {\n            /* Success, return the cached entry */\n            return le->ptr;\n        }\n        php_error_docref(0, E_WARNING, \"Invalid slot cache resource\");\n    }\n\n    /* Not found */\n    return NULL;\n}\n\n/* Cache a cluster's slot information in persistent_list if it's enabled */\nPHP_REDIS_API void cluster_cache_store(zend_string *hash, HashTable *nodes) {\n    redisCachedCluster *cc = cluster_cache_create(hash, nodes);\n\n    redis_register_persistent_resource(cc->hash, cc, le_cluster_slot_cache);\n}\n\n\n/* vim: set tabstop=4 softtabstop=4 expandtab shiftwidth=4: */\n"
        },
        {
          "name": "cluster_library.h",
          "type": "blob",
          "size": 19.2705078125,
          "content": "#ifndef _PHPREDIS_CLUSTER_LIBRARY_H\n#define _PHPREDIS_CLUSTER_LIBRARY_H\n\n#include \"common.h\"\n\n#ifdef ZTS\n#include \"TSRM.h\"\n#endif\n\n/* Redis cluster hash slots and N-1 which we'll use to find it */\n#define REDIS_CLUSTER_SLOTS 16384\n#define REDIS_CLUSTER_MOD   (REDIS_CLUSTER_SLOTS-1)\n\n/* Complete representation for various commands in RESP */\n#define RESP_UNWATCH_CMD       \"*1\\r\\n$7\\r\\nUNWATCH\\r\\n\"\n#define RESP_CLUSTER_SLOTS_CMD \"*2\\r\\n$7\\r\\nCLUSTER\\r\\n$5\\r\\nSLOTS\\r\\n\"\n#define RESP_ASKING_CMD        \"*1\\r\\n$6\\r\\nASKING\\r\\n\"\n#define RESP_READONLY_CMD      \"*1\\r\\n$8\\r\\nREADONLY\\r\\n\"\n#define RESP_READWRITE_CMD     \"*1\\r\\n$9\\r\\nREADWRITE\\r\\n\"\n\n#define RESP_READONLY_CMD_LEN (sizeof(RESP_READONLY_CMD)-1)\n\n/* MOVED/ASK comparison macros */\n#define IS_MOVED(p) (p[0]=='M' && p[1]=='O' && p[2]=='V' && p[3]=='E' && \\\n                     p[4]=='D' && p[5]==' ')\n#define IS_ASK(p)   (p[0]=='A' && p[1]=='S' && p[2]=='K' && p[3]==' ')\n\n/* MOVED/ASK lengths */\n#define MOVED_LEN (sizeof(\"MOVED \")-1)\n#define ASK_LEN   (sizeof(\"ASK \")-1)\n\n/* Initial allocation size for key distribution container */\n#define CLUSTER_KEYDIST_ALLOC 8\n\n/* Macros to access nodes, sockets, and streams for a given slot */\n#define SLOT(c,s) (c->master[s])\n#define SLOT_SOCK(c,s) (SLOT(c,s)->sock)\n#define SLOT_STREAM(c,s) (SLOT_SOCK(c,s)->stream)\n#define SLOT_SLAVES(c,s) (c->master[s]->slaves)\n\n/* Compare redirection slot information with the passed node */\n#define CLUSTER_REDIR_CMP(c, sock) \\\n    (sock->port != c->redir_port || \\\n    ZSTR_LEN(sock->host) != c->redir_host_len || \\\n    memcmp(ZSTR_VAL(sock->host),c->redir_host,c->redir_host_len))\n\n/* Clear out our \"last error\" */\n#define CLUSTER_CLEAR_ERROR(c) do { \\\n    if (c->err) { \\\n        zend_string_release(c->err); \\\n        c->err = NULL; \\\n    } \\\n    c->clusterdown = 0; \\\n} while (0)\n\n/* Protected sending of data down the wire to a RedisSock->stream */\n#define CLUSTER_SEND_PAYLOAD(sock, buf, len) \\\n    (sock && !redis_sock_server_open(sock) && sock->stream && !redis_check_eof(sock, 0, 1) && \\\n     redis_sock_write_raw(sock, buf, len) == len)\n\n/* Macro to read our reply type character */\n#define CLUSTER_VALIDATE_REPLY_TYPE(sock, type) \\\n    (redis_check_eof(sock, 1, 1) == 0 && redis_sock_getc(sock) == type)\n\n/* Reset our last single line reply buffer and length */\n#define CLUSTER_CLEAR_REPLY(c) \\\n    *c->line_reply = '\\0'; c->reply_len = 0;\n\n/* Helper to determine if we're in MULTI mode */\n#define CLUSTER_IS_ATOMIC(c) (c->flags->mode != MULTI)\n\n/* Helper that either returns false or adds false in multi mode */\n#define CLUSTER_RETURN_FALSE(c) \\\n    if(CLUSTER_IS_ATOMIC(c)) { \\\n        RETURN_FALSE; \\\n    } else { \\\n        add_next_index_bool(&c->multi_resp, 0); \\\n        return; \\\n    }\n\n/* Helper to either return a bool value or add it to MULTI response */\n#define CLUSTER_RETURN_BOOL(c, b) \\\n    if(CLUSTER_IS_ATOMIC(c)) { \\\n        RETURN_BOOL(b); \\\n    } else { \\\n        add_next_index_bool(&c->multi_resp, b); \\\n    }\n\n/* Helper to respond with a double or add it to our MULTI response */\n#define CLUSTER_RETURN_DOUBLE(c, d) \\\n    if(CLUSTER_IS_ATOMIC(c)) { \\\n        RETURN_DOUBLE(d); \\\n    } else { \\\n        add_next_index_double(&c->multi_resp, d); \\\n    }\n\n/* Helper to return a string value */\n#define CLUSTER_RETURN_STRING(c, str, len) \\\n    if(CLUSTER_IS_ATOMIC(c)) { \\\n        RETVAL_STRINGL(str, len); \\\n    } else { \\\n        add_next_index_stringl(&c->multi_resp, str, len); \\\n    } \\\n\n/* Return a LONG value */\n#define CLUSTER_RETURN_LONG(c, val) \\\n    if(CLUSTER_IS_ATOMIC(c)) { \\\n        RETURN_LONG(val); \\\n    } else { \\\n        add_next_index_long(&c->multi_resp, val); \\\n    }\n\n/* Macro to clear out a clusterMultiCmd structure */\n#define CLUSTER_MULTI_CLEAR(mc) \\\n    mc->cmd.len  = 0; \\\n    mc->args.len = 0; \\\n    mc->argc     = 0; \\\n\n/* Initialize a clusterMultiCmd with a keyword and length */\n#define CLUSTER_MULTI_INIT(mc, keyword, keyword_len) \\\n    mc.kw     = keyword; \\\n    mc.kw_len = keyword_len; \\\n\n#define CLUSTER_CACHING_ENABLED() (INI_INT(\"redis.clusters.cache_slots\") == 1)\n\n/* Cluster redirection enum */\ntypedef enum CLUSTER_REDIR_TYPE {\n    REDIR_NONE,\n    REDIR_MOVED,\n    REDIR_ASK\n} CLUSTER_REDIR_TYPE;\n\n/* MULTI BULK response callback typedef */\ntypedef int  (*mbulk_cb)(RedisSock*,zval*,long long, void*);\n\n/* A list of covered slot ranges */\ntypedef struct redisSlotRange {\n    unsigned short low;\n    unsigned short high;\n} redisSlotRange;\n\n/* Simple host/port information for our cache */\ntypedef struct redisCachedHost {\n    zend_string *addr;\n    unsigned short port;\n} redisCachedHost;\n\n/* Storage for a cached master node */\ntypedef struct redisCachedMaster {\n    redisCachedHost host;\n\n    redisSlotRange *slot;   /* Slots and count */\n    size_t slots;\n\n    redisCachedHost *slave; /* Slaves and their count */\n    size_t slaves;\n} redisCachedMaster;\n\ntypedef struct redisCachedCluster {\n    // int rsrc_id;               /* Zend resource ID */\n    zend_string *hash;         /* What we're cached by */\n    redisCachedMaster *master; /* Array of masters */\n    size_t count;              /* Number of masters */\n} redisCachedCluster;\n\n/* A Redis Cluster master node */\ntypedef struct redisClusterNode {\n    RedisSock *sock;      /* Our Redis socket in question */\n    short slot;           /* One slot we believe this node serves */\n    zend_llist slots;     /* List of all slots we believe this node serves */\n    unsigned short slave; /* Are we a slave */\n    HashTable *slaves;    /* Hash table of slaves */\n} redisClusterNode;\n\n/* Forward declarations */\ntypedef struct clusterFoldItem clusterFoldItem;\n\n/* RedisCluster implementation structure */\ntypedef struct redisCluster {\n\n    /* One RedisSock struct for serialization and prefix information */\n    RedisSock *flags;\n\n    /* How long in milliseconds should we wait when being bounced around */\n    long waitms;\n\n    /* Are we flagged as being in readonly mode, meaning we could fall back to\n     * a given master's slave */\n    short readonly;\n\n    /* RedisCluster failover options (never, on error, to load balance) */\n    short failover;\n\n    /* Hash table of seed host/ports */\n    HashTable *seeds;\n\n    /* RedisCluster masters, by direct slot */\n    redisClusterNode *master[REDIS_CLUSTER_SLOTS];\n\n    /* All RedisCluster objects we've created/are connected to */\n    HashTable *nodes;\n\n    /* Transaction handling linked list, and where we are as we EXEC */\n    clusterFoldItem *multi_head;\n    clusterFoldItem *multi_curr;\n\n    /* When we issue EXEC to nodes, we need to keep track of how many replies\n     * we have, as this can fail for various reasons (EXECABORT, watch, etc.) */\n    char multi_len[REDIS_CLUSTER_SLOTS];\n\n    /* Variable to store MULTI response */\n    zval multi_resp;\n\n    /* Flag for when we get a CLUSTERDOWN error */\n    short clusterdown;\n\n    /* Key to our persistent list cache and number of redirections we've\n     * received since construction */\n    zend_string *cache_key;\n    uint64_t redirections;\n\n    /* The last ERROR we encountered */\n    zend_string *err;\n\n    /* The slot our command is operating on, as well as it's socket */\n    unsigned short cmd_slot;\n    RedisSock *cmd_sock;\n\n    /* The slot where we're subscribed */\n    short subscribed_slot;\n\n    /* The first line of our last reply, not including our reply type byte\n     * or the trailing \\r\\n */\n    char line_reply[1024];\n\n    /* The last reply type and length or integer response we got */\n    REDIS_REPLY_TYPE reply_type;\n    long long reply_len;\n\n    /* Last MOVED or ASK redirection response information */\n    CLUSTER_REDIR_TYPE redir_type;\n    char               redir_host[255];\n    int                redir_host_len;\n    unsigned short     redir_slot;\n    unsigned short     redir_port;\n\n    /* Zend object handler */\n    zend_object std;\n} redisCluster;\n\n/* RedisCluster response processing callback */\ntypedef void (*cluster_cb)(INTERNAL_FUNCTION_PARAMETERS, redisCluster*, void*);\n\n/* Context for processing transactions */\nstruct clusterFoldItem {\n    /* Response processing callback */\n    cluster_cb callback;\n\n    /* The actual socket where we send this request */\n    unsigned short slot;\n\n    /* Any context we need to send to our callback */\n    void *ctx;\n\n    /* Next item in our list */\n    struct clusterFoldItem *next;\n};\n\n/* Key and value container, with info if they need freeing */\ntypedef struct clusterKeyVal {\n    char *key, *val;\n    int  key_len,  val_len;\n    int  key_free, val_free;\n} clusterKeyVal;\n\n/* Container to hold keys (and possibly values) for when we need to distribute\n * commands across more than 1 node (e.g. WATCH, MGET, MSET, etc) */\ntypedef struct clusterDistList {\n    clusterKeyVal *entry;\n    size_t len, size;\n} clusterDistList;\n\n/* Context for things like MGET/MSET/MSETNX.  When executing in MULTI mode,\n * we'll want to re-integrate into one running array, except for the last\n * command execution, in which we'll want to return the value (or add it) */\ntypedef struct clusterMultiCtx {\n    /* Our running array */\n    zval *z_multi;\n\n    /* How many keys did we request for this bit */\n    int count;\n\n    /* Is this the last entry */\n    short last;\n} clusterMultiCtx;\n\n/* Container for things like MGET, MSET, and MSETNX, which split the command\n * into a header and payload while aggregating to a specific slot. */\ntypedef struct clusterMultiCmd {\n    /* Keyword and keyword length */\n    char *kw;\n    int  kw_len;\n\n    /* Arguments in our payload */\n    int argc;\n\n    /* The full command, built into cmd, and args as we aggregate */\n    smart_string cmd;\n    smart_string args;\n} clusterMultiCmd;\n\n/* Hiredis like structure for processing any sort of reply Redis Cluster might\n * give us, including N level deep nested multi-bulk replies.  Unlike hiredis\n * we don't encode errors, here as that's handled in the cluster structure. */\ntypedef struct clusterReply {\n    REDIS_REPLY_TYPE type;         /* Our reply type */\n    size_t integer;                /* Integer reply */\n    long long len;                 /* Length of our string */\n    char *str;                     /* String reply */\n    long long elements;            /* Count of array elements */\n    struct clusterReply **element; /* Array elements */\n} clusterReply;\n\n/* Direct variant response handler */\nclusterReply *cluster_read_resp(redisCluster *c, int status_strings);\nclusterReply *cluster_read_sock_resp(RedisSock *redis_sock,\n    REDIS_REPLY_TYPE type, char *line_reply, long long reply_len);\nvoid cluster_free_reply(clusterReply *reply, int free_data);\n\n/* Cluster distribution helpers for WATCH */\nHashTable *cluster_dist_create(void);\nvoid cluster_dist_free(HashTable *ht);\nint cluster_dist_add_key(redisCluster *c, HashTable *ht, char *key,\n    size_t key_len, clusterKeyVal **kv);\nvoid cluster_dist_add_val(redisCluster *c, clusterKeyVal *kv, zval *val\n   );\n\n/* Aggregation for multi commands like MGET, MSET, and MSETNX */\nvoid cluster_multi_init(clusterMultiCmd *mc, char *kw, int kw_len);\nvoid cluster_multi_free(clusterMultiCmd *mc);\nvoid cluster_multi_add(clusterMultiCmd *mc, char *data, int data_len);\nvoid cluster_multi_fini(clusterMultiCmd *mc);\n\n/* Hash a key to it's slot, using the Redis Cluster hash algorithm */\nunsigned short cluster_hash_key_zval(zval *key);\nunsigned short cluster_hash_key(const char *key, int len);\nunsigned short cluster_hash_key_zstr(zend_string *key);\n\n/* Validate and sanitize cluster construction args */\nzend_string** cluster_validate_args(double timeout, double read_timeout,\n    HashTable *seeds, uint32_t *nseeds, char **errstr);\n\nvoid free_seed_array(zend_string **seeds, uint32_t nseeds);\n\n/* Generate a unique hash string from seeds array */\nzend_string *cluster_hash_seeds(zend_string **seeds, uint32_t nseeds);\n\n/* Get the current time in milliseconds */\nlong long mstime(void);\n\nPHP_REDIS_API short cluster_send_command(redisCluster *c, short slot, const char *cmd,\n    int cmd_len);\n\nPHP_REDIS_API void cluster_disconnect(redisCluster *c, int force);\n\nPHP_REDIS_API int cluster_send_exec(redisCluster *c, short slot);\nPHP_REDIS_API int cluster_send_discard(redisCluster *c, short slot);\nPHP_REDIS_API int cluster_abort_exec(redisCluster *c);\n\nPHP_REDIS_API short cluster_find_slot(redisCluster *c, const char *host,\n    unsigned short port);\nPHP_REDIS_API int cluster_send_slot(redisCluster *c, short slot, char *cmd,\n    int cmd_len, REDIS_REPLY_TYPE rtype);\n\nPHP_REDIS_API redisCluster *cluster_create(double timeout, double read_timeout,\n    int failover, int persistent);\nPHP_REDIS_API void cluster_free(redisCluster *c, int free_ctx);\nPHP_REDIS_API void cluster_init_seeds(redisCluster *c, zend_string **seeds, uint32_t nseeds);\nPHP_REDIS_API int cluster_map_keyspace(redisCluster *c);\nPHP_REDIS_API void cluster_free_node(redisClusterNode *node);\n\n/* Functions for interacting with cached slots maps */\nPHP_REDIS_API redisCachedCluster *cluster_cache_create(zend_string *hash, HashTable *nodes);\nPHP_REDIS_API void cluster_cache_free(redisCachedCluster *rcc);\nPHP_REDIS_API void cluster_init_cache(redisCluster *c, redisCachedCluster *rcc);\n\n/* Functions to facilitate cluster slot caching */\n\nPHP_REDIS_API char **cluster_sock_read_multibulk_reply(RedisSock *redis_sock, int *len);\n\nPHP_REDIS_API void cluster_cache_store(zend_string *hash, HashTable *nodes);\nPHP_REDIS_API redisCachedCluster *cluster_cache_load(zend_string *hash);\n\n/*\n * Redis Cluster response handlers.  Our response handlers generally take the\n * following form:\n *      PHP_REDIS_API void handler(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n *          void *ctx)\n *\n * Reply handlers are responsible for setting the PHP return value (either to\n * something valid, or FALSE in the case of some failures).\n */\n\nPHP_REDIS_API void cluster_bool_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_ping_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_pop_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_object_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_lpos_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_hrandfield_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_zdiff_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_zadd_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_zrandmember_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_srandmember_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_set_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_geosearch_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_single_line_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_bulk_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_bulk_raw_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_dbl_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_1_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_long_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_type_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_sub_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\nPHP_REDIS_API void cluster_unsub_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\n\nPHP_REDIS_API void cluster_zrange_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n    void *ctx);\n\nPHP_REDIS_API void cluster_variant_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\n\nPHP_REDIS_API void cluster_variant_raw_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\n\nPHP_REDIS_API void cluster_variant_resp_strings(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\n\n/* MULTI BULK response functions */\nPHP_REDIS_API void cluster_gen_mbulk_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, mbulk_cb func, void *ctx);\nPHP_REDIS_API void cluster_mbulk_raw_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\nPHP_REDIS_API void cluster_mbulk_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\nPHP_REDIS_API void cluster_mbulk_zipstr_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\nPHP_REDIS_API void cluster_mbulk_zipdbl_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\nPHP_REDIS_API void cluster_mbulk_dbl_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\nPHP_REDIS_API void cluster_mbulk_assoc_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\nPHP_REDIS_API void cluster_multi_mbulk_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\nPHP_REDIS_API zval *cluster_zval_mbulk_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, int pull, mbulk_cb cb, zval *z_ret);\n\n/* Handlers for things like DEL/MGET/MSET/MSETNX */\nPHP_REDIS_API void cluster_del_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\nPHP_REDIS_API void cluster_mbulk_mget_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\nPHP_REDIS_API void cluster_mset_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\nPHP_REDIS_API void cluster_msetnx_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\n\n/* Response handler for ZSCAN, SSCAN, and HSCAN */\nPHP_REDIS_API int cluster_scan_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, REDIS_SCAN_TYPE type, uint64_t *cursor);\n\n/* INFO response handler */\nPHP_REDIS_API void cluster_info_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\n\n/* CLIENT LIST response handler */\nPHP_REDIS_API void cluster_client_list_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\n\n/* Custom STREAM handlers */\nPHP_REDIS_API void cluster_xread_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\nPHP_REDIS_API void cluster_xrange_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\nPHP_REDIS_API void cluster_xclaim_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\nPHP_REDIS_API void cluster_xinfo_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\n\nPHP_REDIS_API void cluster_mpop_resp(INTERNAL_FUNCTION_PARAMETERS,\n    redisCluster *c, void *ctx);\n\n/* Custom ACL handlers */\nPHP_REDIS_API void cluster_acl_getuser_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx);\nPHP_REDIS_API void cluster_acl_log_resp(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, void *ctx);\n\n/* MULTI BULK processing callbacks */\nint mbulk_resp_loop(RedisSock *redis_sock, zval *z_result,\n    long long count, void *ctx);\nint mbulk_resp_loop_raw(RedisSock *redis_sock, zval *z_result,\n    long long count, void *ctx);\nint mbulk_resp_loop_zipstr(RedisSock *redis_sock, zval *z_result,\n    long long count, void *ctx);\nint mbulk_resp_loop_dbl(RedisSock *redis_sock, zval *z_result,\n    long long count, void *ctx);\nint mbulk_resp_loop_zipdbl(RedisSock *redis_sock, zval *z_result,\n    long long count, void *ctx);\nint mbulk_resp_loop_assoc(RedisSock *redis_sock, zval *z_result,\n    long long count, void *ctx);\n\n#endif\n\n/* vim: set tabstop=4 softtabstop=4 expandtab shiftwidth=4: */\n"
        },
        {
          "name": "common.h",
          "type": "blob",
          "size": 10.541015625,
          "content": "#include \"php.h\"\n#include \"php_ini.h\"\n\n#ifndef REDIS_COMMON_H\n#define REDIS_COMMON_H\n\n#define PHPREDIS_CTX_PTR ((char *)0xDEADC0DE)\n#define PHPREDIS_NOTUSED(v) ((void)v)\n\n#include \"zend_llist.h\"\n#include <ext/standard/php_var.h>\n#include <ext/standard/php_math.h>\n#include <zend_smart_str.h>\n#include <ext/standard/php_smart_string.h>\n\n#define PHPREDIS_GET_OBJECT(class_entry, o) (class_entry *)((char *)o - XtOffsetOf(class_entry, std))\n#define PHPREDIS_ZVAL_GET_OBJECT(class_entry, z) PHPREDIS_GET_OBJECT(class_entry, Z_OBJ_P(z))\n\n/* We'll fallthrough if we want to */\n#ifndef __has_attribute\n#define __has_attribute(x) 0\n#endif\n#if __has_attribute(__fallthrough__)\n#define REDIS_FALLTHROUGH __attribute__((__fallthrough__))\n#else\n#define REDIS_FALLTHROUGH do { } while (0)\n#endif\n\n/* NULL check so Eclipse doesn't go crazy */\n#ifndef NULL\n#define NULL   ((void *) 0)\n#endif\n\n#include \"backoff.h\"\n\ntypedef enum {\n    REDIS_SOCK_STATUS_FAILED = -1,\n    REDIS_SOCK_STATUS_DISCONNECTED,\n    REDIS_SOCK_STATUS_CONNECTED,\n    REDIS_SOCK_STATUS_AUTHENTICATED,\n    REDIS_SOCK_STATUS_READY\n} redis_sock_status;\n\n#define _NL \"\\r\\n\"\n\n/* properties */\n#define REDIS_NOT_FOUND 0\n#define REDIS_STRING    1\n#define REDIS_SET       2\n#define REDIS_LIST      3\n#define REDIS_ZSET      4\n#define REDIS_HASH      5\n#define REDIS_STREAM    6\n\n#ifdef PHP_WIN32\n#define PHP_REDIS_API __declspec(dllexport)\n#define phpredis_atoi64(p) _atoi64((p))\n#else\n#define PHP_REDIS_API\n#define phpredis_atoi64(p) atoll((p))\n#endif\n\n/* reply types */\ntypedef enum _REDIS_REPLY_TYPE {\n    TYPE_EOF       = -1,\n    TYPE_LINE      = '+',\n    TYPE_INT       = ':',\n    TYPE_ERR       = '-',\n    TYPE_BULK      = '$',\n    TYPE_MULTIBULK = '*'\n} REDIS_REPLY_TYPE;\n\n/* SCAN variants */\ntypedef enum _REDIS_SCAN_TYPE {\n    TYPE_SCAN,\n    TYPE_SSCAN,\n    TYPE_HSCAN,\n    TYPE_ZSCAN\n} REDIS_SCAN_TYPE;\n\n/* PUBSUB subcommands */\ntypedef enum _PUBSUB_TYPE {\n    PUBSUB_CHANNELS,\n    PUBSUB_NUMSUB,\n    PUBSUB_NUMPAT\n} PUBSUB_TYPE;\n\n#define REDIS_SUBSCRIBE_IDX  0\n#define REDIS_PSUBSCRIBE_IDX 1\n#define REDIS_SSUBSCRIBE_IDX 2\n#define REDIS_SUBS_BUCKETS   3\n\n/* options */\n#define REDIS_OPT_SERIALIZER         1\n#define REDIS_OPT_PREFIX             2\n#define REDIS_OPT_READ_TIMEOUT       3\n#define REDIS_OPT_SCAN               4\n#define REDIS_OPT_FAILOVER           5\n#define REDIS_OPT_TCP_KEEPALIVE      6\n#define REDIS_OPT_COMPRESSION        7\n#define REDIS_OPT_REPLY_LITERAL      8\n#define REDIS_OPT_COMPRESSION_LEVEL  9\n#define REDIS_OPT_NULL_MBULK_AS_NULL 10\n#define REDIS_OPT_MAX_RETRIES        11\n#define REDIS_OPT_BACKOFF_ALGORITHM  12\n#define REDIS_OPT_BACKOFF_BASE       13\n#define REDIS_OPT_BACKOFF_CAP        14\n\n/* cluster options */\n#define REDIS_FAILOVER_NONE              0\n#define REDIS_FAILOVER_ERROR             1\n#define REDIS_FAILOVER_DISTRIBUTE        2\n#define REDIS_FAILOVER_DISTRIBUTE_SLAVES 3\n/* serializers */\ntypedef enum {\n    REDIS_SERIALIZER_NONE,\n    REDIS_SERIALIZER_PHP,\n    REDIS_SERIALIZER_IGBINARY,\n    REDIS_SERIALIZER_MSGPACK,\n    REDIS_SERIALIZER_JSON\n} redis_serializer;\n/* compression */\n#define REDIS_COMPRESSION_NONE 0\n#define REDIS_COMPRESSION_LZF  1\n#define REDIS_COMPRESSION_ZSTD 2\n#define REDIS_COMPRESSION_LZ4  3\n\n/* SCAN options */\n#define REDIS_SCAN_NORETRY 0\n#define REDIS_SCAN_RETRY   1\n#define REDIS_SCAN_PREFIX  2\n#define REDIS_SCAN_NOPREFIX 3\n\n/* BACKOFF_ALGORITHM options */\n#define REDIS_BACKOFF_ALGORITHMS                    7\n#define REDIS_BACKOFF_ALGORITHM_DEFAULT             0\n#define REDIS_BACKOFF_ALGORITHM_DECORRELATED_JITTER 1\n#define REDIS_BACKOFF_ALGORITHM_FULL_JITTER         2\n#define REDIS_BACKOFF_ALGORITHM_EQUAL_JITTER        3\n#define REDIS_BACKOFF_ALGORITHM_EXPONENTIAL         4\n#define REDIS_BACKOFF_ALGORITHM_UNIFORM             5\n#define REDIS_BACKOFF_ALGORITHM_CONSTANT            6\n\n/* GETBIT/SETBIT offset range limits */\n#define BITOP_MIN_OFFSET 0\n#define BITOP_MAX_OFFSET 4294967295U\n\n/* Transaction modes */\n#define ATOMIC   0\n#define MULTI    1\n#define PIPELINE 2\n\n#define PHPREDIS_DEBUG_LOGGING 0\n\n#if PHP_VERSION_ID < 80000\n#define Z_PARAM_ARRAY_HT_OR_NULL(dest) \\\n        Z_PARAM_ARRAY_HT_EX(dest, 1, 0)\n#define Z_PARAM_STR_OR_NULL(dest) \\\n        Z_PARAM_STR_EX(dest, 1, 0)\n#define Z_PARAM_ZVAL_OR_NULL(dest) \\\n\tZ_PARAM_ZVAL_EX(dest, 1, 0)\n#define Z_PARAM_BOOL_OR_NULL(dest, is_null) \\\n\tZ_PARAM_BOOL_EX(dest, is_null, 1, 0)\n#endif\n\n#if PHPREDIS_DEBUG_LOGGING == 1\n#define redisDbgFmt(fmt, ...) \\\n    php_printf(\"%s:%d:%s(): \" fmt \"\\n\", __FILE__, __LINE__, __func__, __VA_ARGS__)\n#define redisDbgStr(str) phpredisDebugFmt(\"%s\", str)\n#else\n#define redisDbgFmt(fmt, ...) ((void)0)\n#define redisDbgStr(str) ((void)0)\n#endif\n\n#define IS_ATOMIC(redis_sock) (redis_sock->mode == ATOMIC)\n#define IS_MULTI(redis_sock) (redis_sock->mode & MULTI)\n#define IS_PIPELINE(redis_sock) (redis_sock->mode & PIPELINE)\n\n#define PIPELINE_ENQUEUE_COMMAND(cmd, cmd_len) do { \\\n    smart_string_appendl(&redis_sock->pipeline_cmd, cmd, cmd_len); \\\n} while (0)\n\n#define REDIS_SAVE_CALLBACK(callback, closure_context) do { \\\n    fold_item *fi = redis_add_reply_callback(redis_sock); \\\n    fi->fun = callback; \\\n    fi->ctx = closure_context; \\\n} while (0)\n\n#define REDIS_PROCESS_REQUEST(redis_sock, cmd, cmd_len) \\\n    if (IS_PIPELINE(redis_sock)) { \\\n        PIPELINE_ENQUEUE_COMMAND(cmd, cmd_len); \\\n    } else if (redis_sock_write(redis_sock, cmd, cmd_len) < 0) { \\\n        efree(cmd); \\\n        RETURN_FALSE; \\\n    } \\\n    efree(cmd);\n\n#define REDIS_PROCESS_RESPONSE_CLOSURE(function, closure_context) \\\n    if (!IS_PIPELINE(redis_sock)) { \\\n        if (redis_response_enqueued(redis_sock) != SUCCESS) { \\\n            RETURN_FALSE; \\\n        } \\\n    } \\\n    REDIS_SAVE_CALLBACK(function, closure_context); \\\n    RETURN_ZVAL(getThis(), 1, 0); \\\n\n#define REDIS_PROCESS_RESPONSE(function) else { \\\n    REDIS_PROCESS_RESPONSE_CLOSURE(function, NULL) \\\n}\n\n/* Process a command assuming our command where our command building\n * function is redis_<cmdname>_cmd */\n#define REDIS_PROCESS_CMD(cmdname, resp_func) \\\n    RedisSock *redis_sock; char *cmd; int cmd_len; void *ctx=NULL; \\\n    if ((redis_sock = redis_sock_get(getThis(), 0)) == NULL || \\\n       redis_##cmdname##_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU,redis_sock, \\\n                             &cmd, &cmd_len, NULL, &ctx)==FAILURE) { \\\n            RETURN_FALSE; \\\n    } \\\n    REDIS_PROCESS_REQUEST(redis_sock, cmd, cmd_len); \\\n    if (IS_ATOMIC(redis_sock)) { \\\n        resp_func(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, NULL, ctx); \\\n    } else { \\\n        REDIS_PROCESS_RESPONSE_CLOSURE(resp_func, ctx) \\\n    }\n\n/* Process a command but with a specific command building function\n * and keyword which is passed to us*/\n#define REDIS_PROCESS_KW_CMD(kw, cmdfunc, resp_func) \\\n    RedisSock *redis_sock; char *cmd; int cmd_len; void *ctx=NULL; \\\n    if ((redis_sock = redis_sock_get(getThis(), 0)) == NULL || \\\n       cmdfunc(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, kw, &cmd, \\\n               &cmd_len, NULL, &ctx)==FAILURE) { \\\n            RETURN_FALSE; \\\n    } \\\n    REDIS_PROCESS_REQUEST(redis_sock, cmd, cmd_len); \\\n    if (IS_ATOMIC(redis_sock)) { \\\n        resp_func(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, NULL, ctx); \\\n    } else { \\\n        REDIS_PROCESS_RESPONSE_CLOSURE(resp_func, ctx) \\\n    }\n\n/* Case sensitive compare against compile-time static string */\n#define REDIS_STRCMP_STATIC(s, len, sstr) \\\n    (len == sizeof(sstr) - 1 && !strncmp(s, sstr, len))\n\n/* Case insensitive compare against compile-time static string */\n#define REDIS_STRICMP_STATIC(s, len, sstr) \\\n    (len == sizeof(sstr) - 1 && !strncasecmp(s, sstr, len))\n\n/* On some versions of glibc strncmp is a macro. This wrapper allows us to\n   use it in combination with ZEND_STRL in those cases. */\nstatic inline int redis_strncmp(const char *s1, const char *s2, size_t n) {\n    return strncmp(s1, s2, n);\n}\n\n/* Test if a zval is a string and (case insensitive) matches a static string */\n#define ZVAL_STRICMP_STATIC(zv, sstr) \\\n    REDIS_STRICMP_STATIC(Z_STRVAL_P(zv), Z_STRLEN_P(zv), sstr)\n\n/* Case insensitive compare of a zend_string to a static string */\n#define ZSTR_STRICMP_STATIC(zs, sstr) \\\n    REDIS_STRICMP_STATIC(ZSTR_VAL(zs), ZSTR_LEN(zs), sstr)\n\n#define REDIS_ENABLE_MODE(redis_sock, m) (redis_sock->mode |= m)\n#define REDIS_DISABLE_MODE(redis_sock, m) (redis_sock->mode &= ~m)\n\n/* HOST_NAME_MAX doesn't exist everywhere */\n#ifndef HOST_NAME_MAX\n    #if defined(_POSIX_HOST_NAME_MAX)\n        #define HOST_NAME_MAX _POSIX_HOST_NAME_MAX\n    #elif defined(MAXHOSTNAMELEN)\n        #define HOST_NAME_MAX MAXHOSTNAMELEN\n    #else\n        #define HOST_NAME_MAX 255\n    #endif\n#endif\n\n/* Complete representation for various commands in RESP */\n#define RESP_MULTI_CMD         \"*1\\r\\n$5\\r\\nMULTI\\r\\n\"\n#define RESP_EXEC_CMD          \"*1\\r\\n$4\\r\\nEXEC\\r\\n\"\n#define RESP_DISCARD_CMD       \"*1\\r\\n$7\\r\\nDISCARD\\r\\n\"\n\n/* {{{ struct RedisSock */\ntypedef struct {\n    php_stream          *stream;\n    php_stream_context  *stream_ctx;\n    zend_string         *host;\n    int                 port;\n    zend_string         *user;\n    zend_string         *pass;\n    double              timeout;\n    double              read_timeout;\n    long                retry_interval;\n    int                 max_retries;\n    struct RedisBackoff backoff;\n    redis_sock_status   status;\n    int                 persistent;\n    int                 watching;\n    zend_string         *persistent_id;\n    HashTable           *subs[REDIS_SUBS_BUCKETS];\n    redis_serializer    serializer;\n    int                 compression;\n    int                 compression_level;\n    long                dbNumber;\n\n    zend_string         *prefix;\n\n    short               mode;\n    struct fold_item    *reply_callback;\n    size_t              reply_callback_count;\n    size_t              reply_callback_capacity;\n    smart_string        pipeline_cmd;\n\n    zend_string         *err;\n\n    int                 scan;\n\n    int                 readonly;\n    int                 reply_literal;\n    int                 null_mbulk_as_null;\n    int                 tcp_keepalive;\n    int                 sentinel;\n    size_t              txBytes;\n    size_t              rxBytes;\n} RedisSock;\n/* }}} */\n\n/* Redis response handler function callback prototype */\ntypedef void (*ResultCallback)(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\ntypedef int (*FailableResultCallback)(INTERNAL_FUNCTION_PARAMETERS, RedisSock*, zval*, void*);\n\ntypedef struct fold_item {\n    FailableResultCallback fun;\n    void *ctx;\n} fold_item;\n\ntypedef struct {\n    zend_llist list;\n    int nb_active;\n} ConnectionPool;\n\ntypedef struct {\n    RedisSock *sock;\n    zend_object std;\n} redis_object;\n\nextern const zend_function_entry *redis_get_methods(void);\n\n#endif\n"
        },
        {
          "name": "composer.json",
          "type": "blob",
          "size": 1.8349609375,
          "content": "\n{\n    \"name\": \"phpredis/phpredis\",\n    \"type\": \"php-ext\",\n    \"license\": \"PHP-3.01\",\n    \"description\": \"A PHP extension for Redis\",\n    \"require\": {\n        \"php\": \">= 7.4.0\"\n    },\n    \"php-ext\": {\n        \"extension-name\": \"redis\",\n        \"configure-options\": [\n            {\n                \"name\": \"enable-redis\",\n                \"description\": \"Enable redis support\"\n            },\n            {\n                \"name\": \"disable-redis-session\",\n                \"description\": \"Disable session support\"\n            },\n            {\n                \"name\": \"disable-redis-json\",\n                \"description\": \"Disable json serializer support\"\n            },\n            {\n                \"name\": \"enable-redis-igbinary\",\n                \"description\": \"Enable igbinary serializer support\"\n            },\n            {\n                \"name\": \"enable-redis-msgpack\",\n                \"description\": \"Enable msgpack serializer support\"\n            },\n            {\n                \"name\": \"enable-redis-lzf\",\n                \"description\": \"Enable lzf compression support\"\n            },\n            {\n                \"name\": \"with-liblzf\",\n                \"description\": \"Use system liblzf\",\n                \"needs-value\": true\n            },\n            {\n                \"name\": \"enable-redis-zstd\",\n                \"description\": \"Enable Zstd compression support\"\n            },\n            {\n                \"name\": \"with-libzstd\",\n                \"description\": \"Use system libzstd\",\n                \"needs-value\": true\n            },\n            {\n                \"name\": \"enable-redis-lz4\",\n                \"description\": \"Enable lz4 compression support\"\n            },\n            {\n                \"name\": \"with-liblz4\",\n                \"description\": \"Use system liblz4\",\n                \"needs-value\": true\n            }\n        ],\n        \"priority\": 60\n    }\n}\n"
        },
        {
          "name": "config.m4",
          "type": "blob",
          "size": 10.7666015625,
          "content": "dnl $Id$\ndnl config.m4 for extension redis\n\nPHP_ARG_ENABLE(redis, whether to enable redis support,\ndnl Make sure that the comment is aligned:\n[  --enable-redis               Enable redis support])\n\nPHP_ARG_ENABLE(redis-session, whether to enable sessions,\n[  --disable-redis-session      Disable session support], yes, no)\n\nPHP_ARG_ENABLE(redis-json, whether to enable json serializer support,\n[  --disable-redis-json         Disable json serializer support], yes, no)\n\nPHP_ARG_ENABLE(redis-igbinary, whether to enable igbinary serializer support,\n[  --enable-redis-igbinary Enable igbinary serializer support], no, no)\n\nPHP_ARG_ENABLE(redis-msgpack, whether to enable msgpack serializer support,\n[  --enable-redis-msgpack       Enable msgpack serializer support], no, no)\n\nPHP_ARG_ENABLE(redis-lzf, whether to enable lzf compression,\n[  --enable-redis-lzf      Enable lzf compression support], no, no)\n\nPHP_ARG_WITH(liblzf, use system liblzf,\n[  --with-liblzf[=DIR]       Use system liblzf], no, no)\n\nPHP_ARG_ENABLE(redis-zstd, whether to enable Zstd compression,\n[  --enable-redis-zstd     Enable Zstd compression support], no, no)\n\nPHP_ARG_WITH(libzstd, use system libzstd,\n[  --with-libzstd[=DIR]      Use system libzstd], yes, no)\n\nPHP_ARG_ENABLE(redis-lz4, whether to enable lz4 compression,\n[  --enable-redis-lz4      Enable lz4 compression support], no, no)\n\nPHP_ARG_WITH(liblz4, use system liblz4,\n[  --with-liblz4[=DIR]       Use system liblz4], no, no)\n\nif test \"$PHP_REDIS\" != \"no\"; then\n\n  if test \"$PHP_REDIS_SESSION\" != \"no\"; then\n    AC_DEFINE(PHP_SESSION,1,[redis sessions])\n  fi\n\n  AC_MSG_CHECKING([for hash includes])\n  hash_inc_path=\"\"\n  if test -f \"$abs_srcdir/include/php/ext/hash/php_hash.h\"; then\n    hash_inc_path=\"$abs_srcdir/include/php\"\n  elif test -f \"$abs_srcdir/ext/hash/php_hash.h\"; then\n    hash_inc_path=\"$abs_srcdir\"\n  elif test -f \"$phpincludedir/ext/hash/php_hash.h\"; then\n    hash_inc_path=\"$phpincludedir\"\n  else\n    for i in php php7; do\n      if test -f \"$prefix/include/$i/ext/hash/php_hash.h\"; then\n        hash_inc_path=\"$prefix/include/$i\"\n      fi\n    done\n  fi\n\n  if test \"$hash_inc_path\" = \"\"; then\n    AC_MSG_ERROR([Cannot find php_hash.h])\n  else\n    AC_MSG_RESULT([$hash_inc_path])\n  fi\n\n  if test \"$PHP_REDIS_JSON\" != \"no\"; then\n    AC_MSG_CHECKING([for json includes])\n    json_inc_path=\"\"\n    if test -f \"$abs_srcdir/include/php/ext/json/php_json.h\"; then\n      json_inc_path=\"$abs_srcdir/include/php\"\n    elif test -f \"$abs_srcdir/ext/json/php_json.h\"; then\n      json_inc_path=\"$abs_srcdir\"\n    elif test -f \"$phpincludedir/ext/json/php_json.h\"; then\n      json_inc_path=\"$phpincludedir\"\n    else\n      for i in php php7; do\n        if test -f \"$prefix/include/$i/ext/json/php_json.h\"; then\n          json_inc_path=\"$prefix/include/$i\"\n        fi\n      done\n    fi\n\n    if test \"$json_inc_path\" = \"\"; then\n      AC_MSG_ERROR([Cannot find php_json.h])\n    else\n      AC_MSG_RESULT([$json_inc_path])\n    fi\n  fi\n\n  AC_MSG_CHECKING([for redis json support])\n  if test \"$PHP_REDIS_JSON\" != \"no\"; then\n    AC_MSG_RESULT([enabled])\n    AC_DEFINE(HAVE_REDIS_JSON,1,[Whether redis json serializer is enabled])\n    JSON_INCLUDES=\"-I$json_inc_path\"\n    JSON_EXT_DIR=\"$json_inc_path/ext\"\n    ifdef([PHP_ADD_EXTENSION_DEP],\n    [\n      PHP_ADD_EXTENSION_DEP(redis, json)\n    ])\n    PHP_ADD_INCLUDE($JSON_EXT_DIR)\n  else\n    JSON_INCLUDES=\"\"\n    AC_MSG_RESULT([disabled])\n  fi\n\n  if test \"$PHP_REDIS_IGBINARY\" != \"no\"; then\n    AC_MSG_CHECKING([for igbinary includes])\n    igbinary_inc_path=\"\"\n\n    if test -f \"$abs_srcdir/include/php/ext/igbinary/igbinary.h\"; then\n      igbinary_inc_path=\"$abs_srcdir/include/php\"\n    elif test -f \"$abs_srcdir/ext/igbinary/igbinary.h\"; then\n      igbinary_inc_path=\"$abs_srcdir\"\n    elif test -f \"$phpincludedir/ext/igbinary/igbinary.h\"; then\n      igbinary_inc_path=\"$phpincludedir\"\n    else\n      for i in php php7; do\n        if test -f \"$prefix/include/$i/ext/igbinary/igbinary.h\"; then\n          igbinary_inc_path=\"$prefix/include/$i\"\n        fi\n      done\n    fi\n\n    if test \"$igbinary_inc_path\" = \"\"; then\n      AC_MSG_ERROR([Cannot find igbinary.h])\n    else\n      AC_MSG_RESULT([$igbinary_inc_path])\n    fi\n  fi\n\n  AC_MSG_CHECKING([for redis igbinary support])\n  if test \"$PHP_REDIS_IGBINARY\" != \"no\"; then\n    AC_MSG_RESULT([enabled])\n    AC_DEFINE(HAVE_REDIS_IGBINARY,1,[Whether redis igbinary serializer is enabled])\n    IGBINARY_INCLUDES=\"-I$igbinary_inc_path\"\n    IGBINARY_EXT_DIR=\"$igbinary_inc_path/ext\"\n    ifdef([PHP_ADD_EXTENSION_DEP],\n    [\n      PHP_ADD_EXTENSION_DEP(redis, igbinary)\n    ])\n    PHP_ADD_INCLUDE($IGBINARY_EXT_DIR)\n  else\n    IGBINARY_INCLUDES=\"\"\n    AC_MSG_RESULT([disabled])\n  fi\n\n  if test \"$PHP_REDIS_MSGPACK\" != \"no\"; then\n    AC_MSG_CHECKING([for msgpack includes])\n    msgpack_inc_path=\"\"\n\n    if test -f \"$abs_srcdir/include/php/ext/msgpack/php_msgpack.h\"; then\n      msgpack_inc_path=\"$abs_srcdir/include/php\"\n    elif test -f \"$abs_srcdir/ext/msgpack/php_msgpack.h\"; then\n      msgpack_inc_path=\"$abs_srcdir\"\n    elif test -f \"$phpincludedir/ext/msgpack/php_msgpack.h\"; then\n      msgpack_inc_path=\"$phpincludedir\"\n    else\n      for i in php php7; do\n        if test -f \"$prefix/include/$i/ext/msgpack/php_msgpack.h\"; then\n          msgpack_inc_path=\"$prefix/include/$i\"\n        fi\n      done\n    fi\n\n    if test \"$msgpack_inc_path\" = \"\"; then\n      AC_MSG_ERROR([Cannot find php_msgpack.h])\n    else\n      AC_MSG_RESULT([$msgpack_inc_path])\n    fi\n  fi\n\n  if test \"$PHP_REDIS_MSGPACK\" != \"no\"; then\n    AC_MSG_CHECKING([for php msgpack version >= 2.0.3])\n    MSGPACK_VERSION=`$EGREP \"define PHP_MSGPACK_VERSION\" $msgpack_inc_path/ext/msgpack/php_msgpack.h | $SED -e 's/[[^0-9\\.]]//g'`\n    if test `echo $MSGPACK_VERSION | $SED -e 's/[[^0-9]]/ /g' | $AWK '{print $1*1000 + $2*100 + $3*10 + $4}'` -lt 2030; then\n      AC_MSG_ERROR([version >= 2.0.3 required])\n    else\n      AC_MSG_RESULT([yes])\n    fi\n\n    AC_DEFINE(HAVE_REDIS_MSGPACK,1,[Whether redis msgpack serializer is enabled])\n    MSGPACK_INCLUDES=\"-I$msgpack_inc_path\"\n    MSGPACK_EXT_DIR=\"$msgpack_inc_path/ext\"\n    ifdef([PHP_ADD_EXTENSION_DEP],\n    [\n      PHP_ADD_EXTENSION_DEP(redis, msgpack)\n    ])\n    PHP_ADD_INCLUDE($MSGPACK_EXT_DIR)\n  else\n    MSGPACK_INCLUDES=\"\"\n  fi\n\n  AC_PATH_PROG(PKG_CONFIG, pkg-config, no)\n\n  if test \"$PHP_REDIS_LZF\" != \"no\"; then\n    AC_DEFINE(HAVE_REDIS_LZF, 1, [ ])\n\n    if test \"$PHP_LIBLZF\" = \"yes\" && test -x \"$PKG_CONFIG\" && $PKG_CONFIG --exists liblzf; then\n      AC_MSG_CHECKING(for liblzf using pkg-config)\n\n      LIBLZF_INC=`$PKG_CONFIG liblzf --cflags`\n      LIBLZF_LIB=`$PKG_CONFIG liblzf --libs`\n      LIBLZF_VER=`$PKG_CONFIG liblzf --modversion`\n      AC_MSG_RESULT(found version $LIBLZF_VER)\n      PHP_EVAL_LIBLINE($LIBLZF_LIB, REDIS_SHARED_LIBADD)\n      PHP_EVAL_INCLINE($LIBLZF_INC)\n\n    elif test \"$PHP_LIBLZF\" != \"no\"; then\n      AC_MSG_CHECKING(for liblzf files in default path)\n      for i in $PHP_LIBLZF /usr/local /usr; do\n        if test -r $i/include/lzf.h; then\n          AC_MSG_RESULT(found in $i)\n          LIBLZF_DIR=$i\n          break\n        fi\n      done\n      if test -z \"$LIBLZF_DIR\"; then\n        AC_MSG_RESULT([not found])\n        AC_MSG_ERROR([Please reinstall the liblzf distribution])\n      fi\n      PHP_CHECK_LIBRARY(lzf, lzf_compress,\n      [\n        PHP_ADD_LIBRARY_WITH_PATH(lzf, $LIBLZF_DIR/$PHP_LIBDIR, REDIS_SHARED_LIBADD)\n        PHP_ADD_INCLUDE($LIBLZF_DIR/include)\n      ], [\n        AC_MSG_ERROR([could not find usable liblzf])\n      ], [\n        -L$LIBLZF_DIR/$PHP_LIBDIR\n      ])\n    else\n      PHP_ADD_INCLUDE(liblzf)\n      PHP_ADD_INCLUDE($srcdir/liblzf)\n      PHP_ADD_BUILD_DIR(liblzf)\n      lzf_sources=\"liblzf/lzf_c.c liblzf/lzf_d.c\"\n    fi\n  fi\n\n  if test \"$PHP_REDIS_LZ4\" != \"no\"; then\n    AC_DEFINE(HAVE_REDIS_LZ4, 1, [ ])\n\n    if test \"$PHP_LIBLZ4\" = \"yes\" && test -x \"$PKG_CONFIG\" && $PKG_CONFIG --exists liblz4; then\n      AC_MSG_CHECKING(for liblz4 using pkg-config)\n\n      LIBLZ4_VER=`$PKG_CONFIG liblz4 --modversion`\n      LIBLZ4_INC=`$PKG_CONFIG liblz4 --cflags`\n      LIBLZ4_LIB=`$PKG_CONFIG liblz4 --libs`\n      AC_MSG_RESULT(found version $LIBLZ4_VER)\n      PHP_EVAL_LIBLINE($LIBLZ4_LIB, REDIS_SHARED_LIBADD)\n      PHP_EVAL_INCLINE($LIBLZ4_INC)\n\n    elif test \"$PHP_LIBLZ4\" != \"no\"; then\n      AC_MSG_CHECKING(for liblz4 files in default path)\n      for i in $PHP_LIBLZ4 /usr/local /usr; do\n        if test -r $i/include/lz4.h; then\n          AC_MSG_RESULT(found in $i)\n          LIBLZ4_DIR=$i\n          break\n        fi\n      done\n      if test -z \"$LIBLZ4_DIR\"; then\n        AC_MSG_RESULT([not found])\n        AC_MSG_ERROR([Please reinstall the liblz4 distribution])\n      fi\n      PHP_CHECK_LIBRARY(lz4, LZ4_compress,\n      [\n        PHP_ADD_LIBRARY_WITH_PATH(lz4, $LIBLZ4_DIR/$PHP_LIBDIR, REDIS_SHARED_LIBADD)\n        PHP_ADD_INCLUDE($LIBLZ4_DIR/include)\n      ], [\n        AC_MSG_ERROR([could not find usable liblz4])\n      ], [\n        -L$LIBLZ4_DIR/$PHP_LIBDIR\n      ])\n    else\n      AC_MSG_ERROR([only system liblz4 is supported])\n    fi\n  fi\n\n  if test \"$PHP_REDIS_ZSTD\" != \"no\"; then\n    AC_DEFINE(HAVE_REDIS_ZSTD, 1, [ ])\n\n    if test \"$PHP_LIBZSTD\" = \"yes\" && test -x \"$PKG_CONFIG\" && $PKG_CONFIG --exists libzstd; then\n      AC_MSG_CHECKING(for libzstd using pkg-config)\n\n      LIBZSTD_VER=`$PKG_CONFIG libzstd --modversion`\n      if $PKG_CONFIG libzstd --atleast-version 1.3.0; then\n        LIBZSTD_INC=`$PKG_CONFIG libzstd --cflags`\n        LIBZSTD_LIB=`$PKG_CONFIG libzstd --libs`\n        AC_MSG_RESULT(found version $LIBZSTD_VER)\n        PHP_EVAL_LIBLINE($LIBZSTD_LIB, REDIS_SHARED_LIBADD)\n        PHP_EVAL_INCLINE($LIBZSTD_INC)\n      else\n        AC_MSG_ERROR([found version $LIBZSTD_VER, version 1.3.0 required])\n      fi\n\n    elif test \"$PHP_LIBZSTD\" != \"no\"; then\n      AC_MSG_CHECKING(for libzstd files in default path)\n      for i in $PHP_LIBZSTD /usr/local /usr; do\n        if test -r $i/include/zstd.h; then\n          AC_MSG_RESULT(found in $i)\n          LIBZSTD_DIR=$i\n          break\n        fi\n      done\n      if test -z \"$LIBZSTD_DIR\"; then\n        AC_MSG_RESULT([not found])\n        AC_MSG_ERROR([Please reinstall the libzstd distribution])\n      fi\n      PHP_CHECK_LIBRARY(zstd, ZSTD_getFrameContentSize,\n      [\n        PHP_ADD_LIBRARY_WITH_PATH(zstd, $LIBZSTD_DIR/$PHP_LIBDIR, REDIS_SHARED_LIBADD)\n        PHP_ADD_INCLUDE($LIBZSTD_DIR/include)\n      ], [\n        AC_MSG_ERROR([could not find usable libzstd, version 1.3.0 required])\n      ], [\n        -L$LIBZSTD_DIR/$PHP_LIBDIR\n      ])\n    else\n      AC_MSG_ERROR([only system libzstd is supported])\n    fi\n  fi\n\n  AC_CHECK_PROG([GIT], [git], [yes], [no])\n  if test \"$GIT\" = \"yes\" && test -d \"$srcdir/.git\"; then\n    AC_DEFINE_UNQUOTED(GIT_REVISION, [\"$(git log -1 --format=%H)\"], [ ])\n  fi\n\n  PHP_SUBST(REDIS_SHARED_LIBADD)\n  PHP_NEW_EXTENSION(redis, redis.c redis_commands.c library.c redis_session.c redis_array.c redis_array_impl.c redis_cluster.c cluster_library.c redis_sentinel.c sentinel_library.c backoff.c $lzf_sources, $ext_shared)\nfi\n"
        },
        {
          "name": "config.w32",
          "type": "blob",
          "size": 0.9462890625,
          "content": "// vim: ft=javascript:\r\n\r\nARG_ENABLE(\"redis\", \"whether to enable redis support\", \"no\");\r\nARG_ENABLE(\"redis-session\", \"whether to enable sessions\", \"yes\");\r\nARG_ENABLE(\"redis-igbinary\", \"whether to enable igbinary serializer support\", \"no\");\r\n\r\nif (PHP_REDIS != \"no\") {\r\n\tvar sources = \"redis.c redis_commands.c library.c redis_session.c redis_array.c redis_array_impl.c redis_cluster.c cluster_library.c redis_sentinel.c sentinel_library.c backoff.c\";\r\n\tif (PHP_REDIS_SESSION != \"no\") {\r\n\t\tADD_EXTENSION_DEP(\"redis\", \"session\");\r\n\t\tADD_FLAG(\"CFLAGS_REDIS\", ' /D PHP_SESSION=1 ');\r\n\t\tAC_DEFINE(\"HAVE_REDIS_SESSION\", 1);\r\n\t}\r\n\r\n\tif (PHP_REDIS_IGBINARY != \"no\") {\r\n\t\tif (CHECK_HEADER_ADD_INCLUDE(\"igbinary.h\", \"CFLAGS_REDIS\", configure_module_dirname + \"\\\\..\\\\igbinary\")) {\r\n\r\n\t\t\tADD_EXTENSION_DEP(\"redis\", \"igbinary\");\r\n\t\t\tAC_DEFINE(\"HAVE_REDIS_IGBINARY\", 1);\r\n\t\t} else {\r\n\t\t\tWARNING(\"redis igbinary support not enabled\");\r\n\t\t}\r\n\t}\r\n\tEXTENSION(\"redis\", sources);\r\n\r\n}\r\n\r\n"
        },
        {
          "name": "crc16.h",
          "type": "blob",
          "size": 4.3779296875,
          "content": "/*\n * Copyright 2001-2010 Georges Menie (www.menie.org)\n * Copyright 2010 Salvatore Sanfilippo (adapted to Redis coding style)\n * All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the University of California, Berkeley nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* CRC16 implementation according to CCITT standards.\n *\n * Note by @antirez: this is actually the XMODEM CRC 16 algorithm, using the\n * following parameters:\n *\n * Name                       : \"XMODEM\", also known as \"ZMODEM\", \"CRC-16/ACORN\"\n * Width                      : 16 bit\n * Poly                       : 1021 (That is actually x^16 + x^12 + x^5 + 1)\n * Initialization             : 0000\n * Reflect Input byte         : False\n * Reflect Output CRC         : False\n * Xor constant to output CRC : 0000\n * Output for \"123456789\"     : 31C3\n */\n\n#include <stdint.h>\n\nstatic const uint16_t crc16tab[256]= {\n    0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,\n    0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,\n    0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,\n    0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,\n    0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,\n    0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,\n    0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,\n    0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,\n    0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,\n    0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,\n    0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,\n    0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,\n    0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,\n    0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,\n    0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,\n    0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,\n    0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,\n    0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,\n    0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,\n    0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,\n    0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,\n    0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,\n    0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,\n    0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,\n    0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,\n    0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,\n    0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,\n    0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,\n    0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,\n    0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,\n    0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,\n    0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0\n};\n\nstatic inline uint16_t crc16(const char *buf, int len) {\n    int counter;\n    uint16_t crc = 0;\n    for (counter = 0; counter < len; counter++)\n            crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *buf++)&0x00FF];\n    return crc;\n}\n"
        },
        {
          "name": "debian.control",
          "type": "blob",
          "size": 0.3017578125,
          "content": "Package: phpredis\nVersion: 2.2.7\nSection: web \nPriority: optional\nArchitecture: all\nEssential: no\nDepends: \nPre-Depends: \nRecommends: php5\nSuggests: \nInstalled-Size: \nMaintainer: Nicolas Favre-Felix [n.favre-felix@owlient.eu]\nConflicts: \nReplaces: \nProvides: phpredis\nDescription: Redis C extension for PHP5.\n"
        },
        {
          "name": "debian",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "doctum-config.php",
          "type": "blob",
          "size": 0.6982421875,
          "content": "<?php\n\nuse Doctum\\Doctum;\nuse Doctum\\Version\\GitVersionCollection;\nuse Doctum\\RemoteRepository\\GitHubRemoteRepository;\n\nuse Symfony\\Component\\Finder\\Finder;\n\n$root = realpath(__DIR__);\n\n$iterator = Finder::create()\n    ->files()\n    ->name('*.stub.php')\n    ->in($root);\n\n//$versions = GitVersionCollection::create($root)\n//    ->add('develop', 'develop');\n\nreturn new Doctum($iterator, [\n    'title' => 'PhpRedis API',\n    'language' => 'en',\n    'source_dir' => $root,\n    'build_dir' => \"{$root}/docs\",\n    'cache_dir' => \"{$root}/docs/.cache\",\n    'base_url' => 'https://phpredis.github.io/',\n//    'versions' => $versions,\n    'remote_repository' => new GitHubRemoteRepository('phpredis/phpredis', $root),\n]);\n"
        },
        {
          "name": "doctum.md",
          "type": "blob",
          "size": 0.158203125,
          "content": "# API Documentation\n\n```bash\ncurl -O https://doctum.long-term.support/releases/latest/doctum.phar\nchmod +x doctum.phar\n\n./doctum.phar update doctum-config.php\n```"
        },
        {
          "name": "liblzf",
          "type": "commit",
          "content": null
        },
        {
          "name": "library.c",
          "type": "blob",
          "size": 134.12109375,
          "content": "#include \"php_redis.h\"\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"common.h\"\n#include \"php_network.h\"\n#include <sys/types.h>\n\n#ifdef HAVE_REDIS_IGBINARY\n#include \"igbinary/igbinary.h\"\n#endif\n#ifdef HAVE_REDIS_MSGPACK\n#include \"msgpack/php_msgpack.h\"\n#endif\n\n#ifdef HAVE_REDIS_LZF\n#include <lzf.h>\n\n    #ifndef LZF_MARGIN\n        #define LZF_MARGIN 128\n    #endif\n#endif\n\n#ifdef HAVE_REDIS_ZSTD\n#include <zstd.h>\n#endif\n\n#ifdef HAVE_REDIS_LZ4\n#include <lz4.h>\n#include <lz4hc.h>\n\n/* uint8_t crf + int length */\n#define REDIS_LZ4_HDR_SIZE (sizeof(uint8_t) + sizeof(int))\n#if defined(LZ4HC_CLEVEL_MAX)\n/* version >= 1.7.5 */\n#define REDIS_LZ4_MAX_CLEVEL LZ4HC_CLEVEL_MAX\n\n#elif defined (LZ4HC_MAX_CLEVEL)\n/* version >= 1.7.3 */\n#define REDIS_LZ4_MAX_CLEVEL LZ4HC_MAX_CLEVEL\n\n#else\n/* older versions */\n#define REDIS_LZ4_MAX_CLEVEL 12\n#endif\n#endif\n\n#include <zend_exceptions.h>\n#include \"php_redis.h\"\n#include \"library.h\"\n#include \"redis_commands.h\"\n\n#ifdef HAVE_REDIS_JSON\n#include <ext/json/php_json.h>\n#endif\n\n#include <ext/hash/php_hash.h>\n\n#if PHP_VERSION_ID < 80400\n#include <ext/standard/php_rand.h>\n#else\n#include <ext/random/php_random.h>\n#endif\n\n#define UNSERIALIZE_NONE 0\n#define UNSERIALIZE_KEYS 1\n#define UNSERIALIZE_VALS 2\n#define UNSERIALIZE_ALL  3\n\n#define SCORE_DECODE_NONE 0\n#define SCORE_DECODE_INT  1\n#define SCORE_DECODE_DOUBLE 2\n\n#define REDIS_CALLBACKS_INIT_SIZE      8\n#define REDIS_CALLBACKS_MAX_DOUBLE 32768\n#define REDIS_CALLBACKS_ADD_SIZE    4096\n\n/* PhpRedis often returns either FALSE or NULL depending on whether we have\n * an option set, so this macro just wraps that often repeated logic */\n#define REDIS_ZVAL_NULL(sock_, zv_) \\\n    do { \\\n        if ((sock_)->null_mbulk_as_null) { \\\n            ZVAL_NULL((zv_)); \\\n        } else { \\\n            ZVAL_FALSE((zv_)); \\\n        } \\\n    } while (0)\n\n#ifndef PHP_WIN32\n    #include <netinet/tcp.h> /* TCP_NODELAY */\n    #include <sys/socket.h>  /* SO_KEEPALIVE */\n#else\n    #include <winsock.h>\n#endif\n\nextern zend_class_entry *redis_ce;\nextern zend_class_entry *redis_exception_ce;\n\nextern int le_redis_pconnect;\n\nstatic int redis_mbulk_reply_zipped_raw_variant(RedisSock *redis_sock, zval *zret, int count);\n\n/* Register a persistent resource in a a way that works for every PHP 7 version. */\nvoid redis_register_persistent_resource(zend_string *id, void *ptr, int le_id) {\n    zend_register_persistent_resource(ZSTR_VAL(id), ZSTR_LEN(id), ptr, le_id);\n}\n\n/* Do not allocate empty string or string with one character */\nstatic zend_always_inline void redis_add_next_index_stringl(zval *arg, const char *str, size_t length) {\n    zval tmp;\n    ZVAL_STRINGL_FAST(&tmp, str, length);\n    zend_hash_next_index_insert(Z_ARRVAL_P(arg), &tmp);\n}\n\nstatic ConnectionPool *\nredis_sock_get_connection_pool(RedisSock *redis_sock)\n{\n    ConnectionPool *pool;\n    zend_resource *le;\n    zend_string *persistent_id;\n\n    /* Generate our unique pool id depending on configuration */\n    persistent_id = redis_pool_spprintf(redis_sock, INI_STR(\"redis.pconnect.pool_pattern\"));\n\n    /* Return early if we can find the pool */\n    if ((le = zend_hash_find_ptr(&EG(persistent_list), persistent_id))) {\n        zend_string_release(persistent_id);\n        return le->ptr;\n    }\n\n    /* Create the pool and store it in our persistent list */\n    pool = pecalloc(1, sizeof(*pool), 1);\n    zend_llist_init(&pool->list, sizeof(php_stream *), NULL, 1);\n    redis_register_persistent_resource(persistent_id, pool, le_redis_pconnect);\n\n    zend_string_release(persistent_id);\n    return pool;\n}\n\n/* Helper to reselect the proper DB number when we reconnect */\nstatic int reselect_db(RedisSock *redis_sock) {\n    char *cmd, *response;\n    int cmd_len, response_len;\n\n    cmd_len = redis_spprintf(redis_sock, NULL, &cmd, \"SELECT\", \"d\",\n                             redis_sock->dbNumber);\n\n    if (redis_sock_write(redis_sock, cmd, cmd_len) < 0) {\n        efree(cmd);\n        return -1;\n    }\n\n    efree(cmd);\n\n    if ((response = redis_sock_read(redis_sock, &response_len)) == NULL) {\n        return -1;\n    }\n\n    if (redis_strncmp(response, ZEND_STRL(\"+OK\"))) {\n        efree(response);\n        return -1;\n    }\n\n    efree(response);\n    return 0;\n}\n\n/* Append an AUTH command to a smart string if necessary.  This will either\n * append the new style AUTH <user> <password>, old style AUTH <password>, or\n * append no command at all.  Function returns 1 if we appended a command\n * and 0 otherwise. */\nstatic int redis_sock_append_auth(RedisSock *redis_sock, smart_string *str) {\n    /* We need a password at least */\n    if (redis_sock->pass == NULL)\n        return 0;\n\n    REDIS_CMD_INIT_SSTR_STATIC(str, !!redis_sock->user + !!redis_sock->pass, \"AUTH\");\n\n    if (redis_sock->user)\n        redis_cmd_append_sstr_zstr(str, redis_sock->user);\n\n    redis_cmd_append_sstr_zstr(str, redis_sock->pass);\n\n    /* We appended a command */\n    return 1;\n}\n\nPHP_REDIS_API void\nredis_sock_set_auth(RedisSock *redis_sock, zend_string *user, zend_string *pass)\n{\n    /* Release existing user/pass */\n    redis_sock_free_auth(redis_sock);\n\n    /* Set new user/pass */\n    redis_sock->user = user ? zend_string_copy(user) : NULL;\n    redis_sock->pass = pass ? zend_string_copy(pass) : NULL;\n}\n\n\nPHP_REDIS_API void\nredis_sock_set_auth_zval(RedisSock *redis_sock, zval *zv) {\n    zend_string *user, *pass;\n\n    if (redis_extract_auth_info(zv, &user, &pass) == FAILURE)\n        return;\n\n    redis_sock_set_auth(redis_sock, user, pass);\n\n    if (user) zend_string_release(user);\n    if (pass) zend_string_release(pass);\n}\n\nPHP_REDIS_API void\nredis_sock_free_auth(RedisSock *redis_sock) {\n    if (redis_sock->user) {\n        zend_string_release(redis_sock->user);\n        redis_sock->user = NULL;\n    }\n\n    if (redis_sock->pass) {\n        zend_string_release(redis_sock->pass);\n        redis_sock->pass = NULL;\n    }\n}\n\nPHP_REDIS_API char *\nredis_sock_auth_cmd(RedisSock *redis_sock, int *cmdlen) {\n    smart_string cmd = {0};\n\n    if (redis_sock_append_auth(redis_sock, &cmd) == 0) {\n        return NULL;\n    }\n\n    *cmdlen = cmd.len;\n    return cmd.c;\n}\n\n/* Send Redis AUTH and process response */\nPHP_REDIS_API int redis_sock_auth(RedisSock *redis_sock) {\n    char *cmd, inbuf[4096];\n    int cmdlen;\n    size_t len;\n\n    if ((cmd = redis_sock_auth_cmd(redis_sock, &cmdlen)) == NULL)\n        return SUCCESS;\n\n    if (redis_sock_write(redis_sock, cmd, cmdlen) < 0) {\n        efree(cmd);\n        return FAILURE;\n    }\n    efree(cmd);\n\n    if (redis_sock_gets(redis_sock, inbuf, sizeof(inbuf) - 1, &len) < 0 ||\n        redis_strncmp(inbuf, ZEND_STRL(\"+OK\")))\n    {\n        return FAILURE;\n    }\n    return SUCCESS;\n}\n\n/* Helper function and macro to test a RedisSock error prefix. */\n#define REDIS_SOCK_ERRCMP_STATIC(rs, s) redis_sock_errcmp(rs, s, sizeof(s)-1)\nstatic int redis_sock_errcmp(RedisSock *redis_sock, const char *err, size_t errlen) {\n    return ZSTR_LEN(redis_sock->err) >= errlen &&\n           memcmp(ZSTR_VAL(redis_sock->err), err, errlen) == 0;\n}\n\n/* Helper function that will throw an exception for a small number of ERR codes\n * returned by Redis.  Typically we just return FALSE to the caller in the event\n * of an ERROR reply, but for the following error types:\n *    1) MASTERDOWN\n *    2) AUTH\n *    3) LOADING\n */\nstatic void\nredis_error_throw(RedisSock *redis_sock)\n{\n    /* Short circuit if we have no redis_sock or any error */\n    if (redis_sock == NULL || redis_sock->err == NULL)\n        return;\n\n    /* Redis 6 decided to add 'ERR AUTH' which has a normal 'ERR' prefix\n     * but is actually an authentication error that we will want to throw\n     * an exception for, so just short circuit if this is any other 'ERR'\n     * prefixed error. */\n    if (REDIS_SOCK_ERRCMP_STATIC(redis_sock, \"ERR\") &&\n        !REDIS_SOCK_ERRCMP_STATIC(redis_sock, \"ERR AUTH\")) return;\n\n    /* We may want to flip this logic and check for MASTERDOWN, AUTH,\n     * and LOADING but that may have side effects (esp for things like\n     * Disque) */\n    if (!REDIS_SOCK_ERRCMP_STATIC(redis_sock, \"NOSCRIPT\") &&\n        !REDIS_SOCK_ERRCMP_STATIC(redis_sock, \"NOQUORUM\") &&\n        !REDIS_SOCK_ERRCMP_STATIC(redis_sock, \"NOGOODSLAVE\") &&\n        !REDIS_SOCK_ERRCMP_STATIC(redis_sock, \"WRONGTYPE\") &&\n        !REDIS_SOCK_ERRCMP_STATIC(redis_sock, \"BUSYGROUP\") &&\n        !REDIS_SOCK_ERRCMP_STATIC(redis_sock, \"NOGROUP\"))\n    {\n        REDIS_THROW_EXCEPTION(ZSTR_VAL(redis_sock->err), 0);\n    }\n}\n\nstatic int\nread_mbulk_header(RedisSock *redis_sock, int *nelem)\n{\n    char line[4096];\n    size_t len;\n\n    /* Throws exception on failure */\n    if (redis_sock_gets(redis_sock, line, sizeof(line) - 1, &len) < 0) {\n        return FAILURE;\n    }\n\n    if (*line != TYPE_MULTIBULK) {\n        if (*line == TYPE_ERR) {\n            redis_sock_set_err(redis_sock, line + 1, len - 1);\n        }\n        return FAILURE;\n    }\n\n    *nelem = atoi(line + 1);\n\n    return SUCCESS;\n}\n\nPHP_REDIS_API int\nredis_check_eof(RedisSock *redis_sock, zend_bool no_retry, zend_bool no_throw)\n{\n    unsigned int retry_index;\n    char *errmsg;\n\n    if (!redis_sock || !redis_sock->stream || redis_sock->status == REDIS_SOCK_STATUS_FAILED) {\n        if (!no_throw) {\n            REDIS_THROW_EXCEPTION( \"Connection closed\", 0);\n        }\n        return -1;\n    }\n\n    /* NOITCE: set errno = 0 here\n     *\n     * There is a bug in php socket stream to check liveness of a connection:\n     * if (0 >= recv(sock->socket, &buf, sizeof(buf), MSG_PEEK) && php_socket_errno() != EWOULDBLOCK) {\n     *    alive = 0;\n     * }\n     * If last errno is EWOULDBLOCK and recv returns 0 because of connection closed, alive would not be\n     * set to 0. However, the connection is close indeed. The php_stream_eof is not reliable. This will\n     * cause a \"read error on connection\" exception when use a closed persistent connection.\n     *\n     * We work around this by set errno = 0 first.\n     *\n     * Bug fix of php: https://github.com/php/php-src/pull/1456\n     * */\n    errno = 0;\n    if (php_stream_eof(redis_sock->stream) == 0) {\n        /* Success */\n        return 0;\n    } else if (redis_sock->mode == MULTI || redis_sock->watching) {\n        errmsg = \"Connection lost and socket is in MULTI/watching mode\";\n    } else {\n        errmsg = \"Connection lost\";\n        redis_backoff_reset(&redis_sock->backoff);\n        for (retry_index = 0; !no_retry && retry_index < redis_sock->max_retries; ++retry_index) {\n            /* close existing stream before reconnecting */\n            if (redis_sock->stream) {\n                /* reconnect no need to reset mode, it will cause pipeline mode socket exception */\n                redis_sock_disconnect(redis_sock, 1, 0);\n            }\n            /* Sleep based on our backoff algorithm */\n            zend_ulong delay = redis_backoff_compute(&redis_sock->backoff, retry_index);\n            if (delay != 0)\n                usleep(delay);\n\n            /* reconnect */\n            if (redis_sock_connect(redis_sock) == 0) {\n                /* check for EOF again. */\n                errno = 0;\n                if (php_stream_eof(redis_sock->stream) == 0) {\n                    if (redis_sock_auth(redis_sock) != SUCCESS) {\n                        errmsg = \"AUTH failed while reconnecting\";\n                        break;\n                    }\n                    redis_sock->status = REDIS_SOCK_STATUS_AUTHENTICATED;\n\n                    /* If we're using a non-zero db, reselect it */\n                    if (redis_sock->dbNumber && reselect_db(redis_sock) != 0) {\n                        errmsg = \"SELECT failed while reconnecting\";\n                        break;\n                    }\n                    redis_sock->status = REDIS_SOCK_STATUS_READY;\n                    /* Success */\n                    return 0;\n                }\n            }\n        }\n    }\n    /* close stream and mark socket as failed */\n    redis_sock_disconnect(redis_sock, 1, 1);\n    redis_sock->status = REDIS_SOCK_STATUS_FAILED;\n    if (!no_throw) {\n        REDIS_THROW_EXCEPTION( errmsg, 0);\n    }\n    return -1;\n}\n\nPHP_REDIS_API int\nredis_sock_read_scan_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                           REDIS_SCAN_TYPE type, uint64_t *cursor)\n{\n    REDIS_REPLY_TYPE reply_type;\n    long reply_info;\n    char err[4096], *p_iter;\n    size_t errlen;\n\n    /* Our response should have two multibulk replies */\n    if(redis_read_reply_type(redis_sock, &reply_type, &reply_info)<0\n       || reply_type != TYPE_MULTIBULK || reply_info != 2)\n    {\n        if (reply_type == TYPE_ERR) {\n            if (redis_sock_gets(redis_sock, err, sizeof(err), &errlen) == 0) {\n                redis_sock_set_err(redis_sock, err, errlen);\n            }\n        }\n\n        return -1;\n    }\n\n    /* The BULK response iterator */\n    if(redis_read_reply_type(redis_sock, &reply_type, &reply_info)<0\n       || reply_type != TYPE_BULK)\n    {\n        return -1;\n    }\n\n    /* Attempt to read the iterator */\n    if(!(p_iter = redis_sock_read_bulk_reply(redis_sock, reply_info))) {\n        return -1;\n    }\n\n    /* Push the iterator out to the caller */\n    *cursor = strtoull(p_iter, NULL, 10);\n    efree(p_iter);\n\n    /* Read our actual keys/members/etc differently depending on what kind of\n       scan command this is.  They all come back in slightly different ways */\n    switch(type) {\n        case TYPE_SCAN:\n            return redis_mbulk_reply_raw(INTERNAL_FUNCTION_PARAM_PASSTHRU,\n                redis_sock, NULL, NULL);\n        case TYPE_SSCAN:\n            return redis_sock_read_multibulk_reply(\n                INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, NULL, NULL);\n        case TYPE_ZSCAN:\n            return redis_mbulk_reply_zipped_keys_dbl(INTERNAL_FUNCTION_PARAM_PASSTHRU,\n                redis_sock, NULL, NULL);\n        case TYPE_HSCAN:\n            return redis_mbulk_reply_zipped_vals(INTERNAL_FUNCTION_PARAM_PASSTHRU,\n                redis_sock, NULL, NULL);\n        default:\n            return -1;\n    }\n}\n\nPHP_REDIS_API int\nredis_pubsub_response(INTERNAL_FUNCTION_PARAMETERS,\n                      RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    if (ctx == NULL) {\n        return redis_long_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        return redis_read_variant_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR + 1) {\n        return redis_mbulk_reply_zipped_keys_int(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n        return FAILURE;\n    }\n}\n\nstatic void\nht_free_subs(zval *data)\n{\n    efree(Z_PTR_P(data));\n}\n\nPHP_REDIS_API int redis_subscribe_response(INTERNAL_FUNCTION_PARAMETERS,\n                                    RedisSock *redis_sock, zval *z_tab,\n                                    void *ctx)\n{\n    HashTable *subs;\n    subscribeCallback *cb;\n    subscribeContext *sctx = (subscribeContext*)ctx;\n    zval *z_tmp, z_resp;\n    int i;\n\n    ALLOC_HASHTABLE(subs);\n    zend_hash_init(subs, 0, NULL, ht_free_subs, 0);\n    // Consume response(s) from subscribe, which will vary on argc\n    while(sctx->argc--) {\n        ZVAL_NULL(&z_resp);\n        if (!redis_sock_read_multibulk_reply_zval(redis_sock, &z_resp)) {\n            goto error;\n        }\n\n        // We'll need to find the command response\n        if ((z_tmp = zend_hash_index_find(Z_ARRVAL(z_resp), 0)) == NULL) {\n            goto error;\n        }\n\n        // Make sure the command response matches the command we called\n        if(strcasecmp(Z_STRVAL_P(z_tmp), sctx->kw) !=0) {\n            goto error;\n        }\n\n        if ((z_tmp = zend_hash_index_find(Z_ARRVAL(z_resp), 1)) == NULL) {\n            goto error;\n        }\n\n        zend_hash_str_update_mem(subs, Z_STRVAL_P(z_tmp), Z_STRLEN_P(z_tmp),\n                                    &sctx->cb, sizeof(sctx->cb));\n\n        zval_dtor(&z_resp);\n    }\n\n    if (strcasecmp(sctx->kw, \"ssubscribe\") == 0) {\n        i = REDIS_SSUBSCRIBE_IDX;\n    } else if (strcasecmp(sctx->kw, \"psubscribe\") == 0) {\n        i = REDIS_PSUBSCRIBE_IDX;\n    } else {\n        i = REDIS_SUBSCRIBE_IDX;\n    }\n\n    efree(sctx);\n\n    if (redis_sock->subs[i]) {\n        zend_string *zkey;\n\n        ZEND_HASH_FOREACH_STR_KEY_PTR(subs, zkey, cb) {\n            zend_hash_update_mem(redis_sock->subs[i], zkey, cb, sizeof(*cb));\n        } ZEND_HASH_FOREACH_END();\n        zend_hash_destroy(subs);\n        efree(subs);\n\n        RETVAL_TRUE;\n        return SUCCESS;\n    }\n\n    redis_sock->subs[i] = subs;\n    /* Multibulk response, {[pattern], type, channel, payload } */\n    while (redis_sock->subs[i]) {\n        zval z_ret, z_args[4], *z_type, *z_chan, *z_pat = NULL, *z_data;\n        int tab_idx = 1, is_pmsg = 0;\n        HashTable *ht_tab;\n        zend_string *zs;\n\n        ZVAL_NULL(&z_resp);\n        if (!redis_sock_read_multibulk_reply_zval(redis_sock, &z_resp)) {\n            goto failure;\n        }\n\n        ht_tab = Z_ARRVAL(z_resp);\n\n        if ((z_type = zend_hash_index_find(ht_tab, 0)) == NULL ||\n           Z_TYPE_P(z_type) != IS_STRING\n        ) {\n            goto failure;\n        }\n\n        // Check for message or pmessage\n        if (zend_string_equals_literal_ci(Z_STR_P(z_type), \"message\") ||\n            zend_string_equals_literal_ci(Z_STR_P(z_type), \"pmessage\") ||\n            zend_string_equals_literal_ci(Z_STR_P(z_type), \"smessage\")\n        ) {\n            is_pmsg = *Z_STRVAL_P(z_type)=='p';\n        } else {\n            zval_dtor(&z_resp);\n            continue;\n        }\n\n        // Extract pattern if it's a pmessage\n        if (is_pmsg) {\n            z_pat = zend_hash_index_find(ht_tab, tab_idx++);\n            if (z_pat == NULL || Z_TYPE_P(z_pat) != IS_STRING)\n                goto failure;\n        }\n\n        /* Extract channel */\n        z_chan = zend_hash_index_find(ht_tab, tab_idx++);\n        if (z_chan == NULL || Z_TYPE_P(z_chan) != IS_STRING)\n            goto failure;\n\n        /* Finally, extract data */\n        z_data = zend_hash_index_find(ht_tab, tab_idx++);\n        if (z_data == NULL)\n            goto failure;\n\n        /* Find our callback, either by channel or pattern string */\n        zs = z_pat != NULL ? Z_STR_P(z_pat) : Z_STR_P(z_chan);\n        if ((cb = zend_hash_find_ptr(redis_sock->subs[i], zs)) == NULL)\n            goto failure;\n\n        // Different args for SUBSCRIBE and PSUBSCRIBE\n        z_args[0] = *getThis();\n        if(is_pmsg) {\n            z_args[1] = *z_pat;\n            z_args[2] = *z_chan;\n            z_args[3] = *z_data;\n        } else {\n            z_args[1] = *z_chan;\n            z_args[2] = *z_data;\n        }\n\n        // Set arg count\n        cb->fci.param_count = tab_idx;\n        cb->fci.retval = &z_ret;\n        cb->fci.params = z_args;\n\n        // Execute callback\n        if (zend_call_function(&cb->fci, &cb->fci_cache) != SUCCESS) {\n            goto failure;\n        }\n\n        // If we have a return value free it\n        zval_ptr_dtor(&z_ret);\n        zval_dtor(&z_resp);\n    }\n\n    RETVAL_TRUE;\n    return SUCCESS;\n\n    // This is an error state, clean up\nerror:\n    efree(sctx);\n    zend_hash_destroy(subs);\n    efree(subs);\nfailure:\n    zval_dtor(&z_resp);\n    RETVAL_FALSE;\n    return FAILURE;\n}\n\nPHP_REDIS_API int redis_unsubscribe_response(INTERNAL_FUNCTION_PARAMETERS,\n                                      RedisSock *redis_sock, zval *z_tab,\n                                      void *ctx)\n{\n    subscribeContext *sctx = (subscribeContext*)ctx;\n    zval *z_chan, z_ret, z_resp;\n    int i;\n\n    if (strcasecmp(sctx->kw, \"sunsubscribe\") == 0) {\n        i = REDIS_SSUBSCRIBE_IDX;\n    } else if (strcasecmp(sctx->kw, \"punsubscribe\") == 0) {\n        i = REDIS_PSUBSCRIBE_IDX;\n    } else {\n        i = REDIS_SUBSCRIBE_IDX;\n    }\n    if (!sctx->argc && redis_sock->subs[i]) {\n        sctx->argc = zend_hash_num_elements(redis_sock->subs[i]);\n    }\n\n    array_init(&z_ret);\n\n    while (sctx->argc--) {\n        ZVAL_NULL(&z_resp);\n        if (!redis_sock_read_multibulk_reply_zval(redis_sock, &z_resp) ||\n            (z_chan = zend_hash_index_find(Z_ARRVAL(z_resp), 1)) == NULL\n        ) {\n            efree(sctx);\n            zval_dtor(&z_resp);\n            zval_dtor(&z_ret);\n            RETVAL_FALSE;\n            return FAILURE;\n        }\n\n        if (!redis_sock->subs[i] ||\n            !zend_hash_str_exists(redis_sock->subs[i], Z_STRVAL_P(z_chan), Z_STRLEN_P(z_chan))\n        ) {\n            add_assoc_bool_ex(&z_ret, Z_STRVAL_P(z_chan), Z_STRLEN_P(z_chan), 0);\n        } else {\n            zend_hash_str_del(redis_sock->subs[i], Z_STRVAL_P(z_chan), Z_STRLEN_P(z_chan));\n            add_assoc_bool_ex(&z_ret, Z_STRVAL_P(z_chan), Z_STRLEN_P(z_chan), 1);\n        }\n\n        zval_dtor(&z_resp);\n    }\n\n    efree(sctx);\n\n    if (redis_sock->subs[i] && !zend_hash_num_elements(redis_sock->subs[i])) {\n        zend_hash_destroy(redis_sock->subs[i]);\n        efree(redis_sock->subs[i]);\n        redis_sock->subs[i] = NULL;\n    }\n\n    RETVAL_ZVAL(&z_ret, 0, 1);\n    return SUCCESS;\n}\n\nPHP_REDIS_API zval *\nredis_sock_read_multibulk_reply_zval(RedisSock *redis_sock, zval *z_tab)\n{\n    int numElems;\n\n    if (read_mbulk_header(redis_sock, &numElems) < 0) {\n        ZVAL_NULL(z_tab);\n        return NULL;\n    }\n    array_init(z_tab);\n    redis_mbulk_reply_loop(redis_sock, z_tab, numElems, UNSERIALIZE_ALL);\n\n    return z_tab;\n}\n\n/**\n * redis_sock_read_bulk_reply\n */\nPHP_REDIS_API char *\nredis_sock_read_bulk_reply(RedisSock *redis_sock, int bytes)\n{\n    int offset = 0, nbytes;\n    char *reply;\n    ssize_t got;\n\n    if (-1 == bytes || -1 == redis_check_eof(redis_sock, 1, 0)) {\n        return NULL;\n    }\n\n    /* + 2 for \\r\\n */\n    nbytes = bytes + 2;\n\n    /* Allocate memory for string */\n    reply = emalloc(nbytes);\n\n    /* Consume bulk string */\n    while (offset < nbytes) {\n        got = redis_sock_read_raw(redis_sock, reply + offset, nbytes - offset);\n        if (got < 0 || (got == 0 && php_stream_eof(redis_sock->stream)))\n            break;\n\n        offset += got;\n    }\n\n    /* Protect against reading too few bytes */\n    if (offset < nbytes) {\n        /* Error or EOF */\n        REDIS_THROW_EXCEPTION(\"socket error on read socket\", 0);\n        efree(reply);\n        return NULL;\n    }\n\n    /* Null terminate reply string */\n    reply[bytes] = '\\0';\n\n    return reply;\n}\n\n/**\n * redis_sock_read\n */\nPHP_REDIS_API char *\nredis_sock_read(RedisSock *redis_sock, int *buf_len)\n{\n    char inbuf[4096];\n    size_t len;\n\n    *buf_len = 0;\n    if (redis_sock_gets(redis_sock, inbuf, sizeof(inbuf) - 1, &len) < 0) {\n        return NULL;\n    }\n\n    switch(inbuf[0]) {\n        case '-':\n            redis_sock_set_err(redis_sock, inbuf+1, len);\n\n            /* Filter our ERROR through the few that should actually throw */\n            redis_error_throw(redis_sock);\n\n            return NULL;\n        case '$':\n            *buf_len = atoi(inbuf + 1);\n            return redis_sock_read_bulk_reply(redis_sock, *buf_len);\n\n        case '*':\n            /* For null multi-bulk replies (like timeouts from brpoplpush): */\n            if(memcmp(inbuf + 1, \"-1\", 2) == 0) {\n                return NULL;\n            }\n            REDIS_FALLTHROUGH;\n        case '+':\n        case ':':\n            /* Single Line Reply */\n            /* +OK or :123 */\n            if (len > 1) {\n                *buf_len = len;\n                return estrndup(inbuf, *buf_len);\n            }\n            REDIS_FALLTHROUGH;\n        default:\n            zend_throw_exception_ex(redis_exception_ce, 0,\n                \"protocol error, got '%c' as reply type byte\\n\",\n                inbuf[0]\n            );\n    }\n\n    return NULL;\n}\n\n/* A simple union to store the various arg types we might handle in our\n * redis_spprintf command formatting function */\nunion resparg {\n    char *str;\n    zend_string *zstr;\n    zval *zv;\n    int ival;\n    long lval;\n    double dval;\n};\n\nstatic zend_string *redis_hash_auth(zend_string *user, zend_string *pass) {\n    zend_string *algo, *hex;\n    smart_str salted = {0};\n    const php_hash_ops *ops;\n    unsigned char *digest;\n    void *ctx;\n\n    /* No op if there is not username/password */\n    if (user == NULL && pass == NULL)\n        return NULL;\n\n    /* Theoretically impossible but check anyway */\n    algo = zend_string_init(\"sha256\", sizeof(\"sha256\") - 1, 0);\n    if ((ops = redis_hash_fetch_ops(algo)) == NULL) {\n        zend_string_release(algo);\n        return NULL;\n    }\n\n    /* Hash username + password with our salt global */\n    smart_str_alloc(&salted, 256, 0);\n    if (user) smart_str_append_ex(&salted, user, 0);\n    if (pass) smart_str_append_ex(&salted, pass, 0);\n    smart_str_appendl_ex(&salted, REDIS_G(salt), sizeof(REDIS_G(salt)), 0);\n\n    ctx = emalloc(ops->context_size);\n#if PHP_VERSION_ID >= 80100\n    ops->hash_init(ctx,NULL);\n#else\n    ops->hash_init(ctx);\n#endif\n    ops->hash_update(ctx, (const unsigned char *)ZSTR_VAL(salted.s), ZSTR_LEN(salted.s));\n\n    digest = emalloc(ops->digest_size);\n    ops->hash_final(digest, ctx);\n    efree(ctx);\n\n    hex = zend_string_safe_alloc(ops->digest_size, 2, 0, 0);\n    php_hash_bin2hex(ZSTR_VAL(hex), digest, ops->digest_size);\n    ZSTR_VAL(hex)[2 * ops->digest_size] = 0;\n\n    efree(digest);\n    zend_string_release(algo);\n    smart_str_free(&salted);\n\n    return hex;\n}\n\nstatic void append_auth_hash(smart_str *dst, zend_string *user, zend_string *pass) {\n    zend_string *s;\n\n    if ((s = redis_hash_auth(user, pass)) != NULL) {\n        smart_str_appendc(dst, ':');\n        smart_str_append_ex(dst, s, 0);\n        zend_string_release(s);\n    }\n}\n\n/* A printf like function to generate our connection pool hash value. */\nPHP_REDIS_API zend_string *\nredis_pool_spprintf(RedisSock *redis_sock, char *fmt, ...) {\n    smart_str str = {0};\n\n    smart_str_alloc(&str, 128, 0);\n\n    /* We always include phpredis_<host>:<port> */\n    smart_str_appendl(&str, \"phpredis_\", sizeof(\"phpredis_\") - 1);\n    smart_str_append_ex(&str, redis_sock->host, 0);\n    smart_str_appendc(&str, ':');\n    smart_str_append_long(&str, (zend_long)redis_sock->port);\n\n    /* Short circuit if we don't have a pattern */\n    if (fmt == NULL) {\n        smart_str_0(&str);\n        return str.s;\n    }\n\n    while (*fmt) {\n        switch (*fmt) {\n            case 'i':\n                if (redis_sock->persistent_id) {\n                    smart_str_appendc(&str, ':');\n                    smart_str_append_ex(&str, redis_sock->persistent_id, 0);\n                }\n                break;\n            case 'u':\n                smart_str_appendc(&str, ':');\n                if (redis_sock->user) {\n                    smart_str_append_ex(&str, redis_sock->user, 0);\n                }\n                break;\n            case 'p':\n                append_auth_hash(&str, NULL, redis_sock->pass);\n                break;\n            case 'a':\n                append_auth_hash(&str, redis_sock->user, redis_sock->pass);\n                break;\n            default:\n                /* Maybe issue a php_error_docref? */\n                break;\n        }\n\n        fmt++;\n    }\n\n    smart_str_0(&str);\n    return str.s;\n}\n\n/* A printf like method to construct a Redis RESP command.  It has been extended\n * to take a few different format specifiers that are convenient to phpredis.\n *\n * s - C string followed by length as a\n * S - Pointer to a zend_string\n * k - Same as 's' but the value will be prefixed if phpredis is set up do do\n *     that and the working slot will be set if it has been passed.\n * v - A z_val which will be serialized if phpredis is configured to serialize.\n * f - A double value\n * F - Alias to 'f'\n * i - An integer\n * d - Alias to 'i'\n * l - A long\n * L - Alias to 'l'\n */\nPHP_REDIS_API int\nredis_spprintf(RedisSock *redis_sock, short *slot, char **ret, char *kw, char *fmt, ...) {\n    smart_string cmd = {0};\n    va_list ap;\n    union resparg arg;\n    char *dup;\n    int argfree;\n    size_t arglen;\n\n    va_start(ap, fmt);\n\n    /* Header */\n    redis_cmd_init_sstr(&cmd, strlen(fmt), kw, strlen(kw));\n\n    while (*fmt) {\n        switch (*fmt) {\n            case 's':\n                arg.str = va_arg(ap, char*);\n                arglen = va_arg(ap, size_t);\n                redis_cmd_append_sstr(&cmd, arg.str, arglen);\n                break;\n            case 'S':\n                arg.zstr = va_arg(ap, zend_string*);\n                redis_cmd_append_sstr(&cmd, ZSTR_VAL(arg.zstr), ZSTR_LEN(arg.zstr));\n                break;\n            case 'k':\n                arg.str = va_arg(ap, char*);\n                arglen = va_arg(ap, size_t);\n                argfree = redis_key_prefix(redis_sock, &arg.str, &arglen);\n                redis_cmd_append_sstr(&cmd, arg.str, arglen);\n                if (slot) *slot = cluster_hash_key(arg.str, arglen);\n                if (argfree) efree(arg.str);\n                break;\n            case 'v':\n                arg.zv = va_arg(ap, zval*);\n                argfree = redis_pack(redis_sock, arg.zv, &dup, &arglen);\n                redis_cmd_append_sstr(&cmd, dup, arglen);\n                if (argfree) efree(dup);\n                break;\n            case 'f':\n            case 'F':\n                arg.dval = va_arg(ap, double);\n                redis_cmd_append_sstr_dbl(&cmd, arg.dval);\n                break;\n            case 'i':\n            case 'd':\n                arg.ival = va_arg(ap, int);\n                redis_cmd_append_sstr_int(&cmd, arg.ival);\n                break;\n            case 'l':\n            case 'L':\n                arg.lval = va_arg(ap, long);\n                redis_cmd_append_sstr_long(&cmd, arg.lval);\n                break;\n        }\n\n        fmt++;\n    }\n    /* varargs cleanup */\n    va_end(ap);\n\n    /* Null terminate */\n    smart_string_0(&cmd);\n\n    /* Push command string, return length */\n    *ret = cmd.c;\n    return cmd.len;\n}\n\n/*\n * Given a smart string, number of arguments, a keyword, and the length of the keyword\n * initialize our smart string with the proper Redis header for the command to follow\n */\nint redis_cmd_init_sstr(smart_string *str, int num_args, char *keyword, int keyword_len) {\n    smart_string_appendc(str, '*');\n    smart_string_append_long(str, num_args + 1);\n    smart_string_appendl(str, _NL, sizeof(_NL) -1);\n    smart_string_appendc(str, '$');\n    smart_string_append_long(str, keyword_len);\n    smart_string_appendl(str, _NL, sizeof(_NL) - 1);\n    smart_string_appendl(str, keyword, keyword_len);\n    smart_string_appendl(str, _NL, sizeof(_NL) - 1);\n    return str->len;\n}\n\n/*\n * Append a command sequence to a smart_string\n */\nint redis_cmd_append_sstr(smart_string *str, char *append, int append_len) {\n    smart_string_appendc(str, '$');\n    smart_string_append_long(str, append_len);\n    smart_string_appendl(str, _NL, sizeof(_NL) - 1);\n    smart_string_appendl(str, append, append_len);\n    smart_string_appendl(str, _NL, sizeof(_NL) - 1);\n\n    /* Return our new length */\n    return str->len;\n}\n\n/*\n * Append an integer to a smart string command\n */\nint redis_cmd_append_sstr_int(smart_string *str, int append) {\n    return redis_cmd_append_sstr_long(str, (long) append);\n}\n\n/*\n * Append a long to a smart string command\n */\nint redis_cmd_append_sstr_long(smart_string *str, long append) {\n    char long_buf[32];\n    char *result = zend_print_long_to_buf(long_buf + sizeof(long_buf) - 1, append);\n    int int_len = long_buf + sizeof(long_buf) - 1 - result;\n    return redis_cmd_append_sstr(str, result, int_len);\n}\n\n/*\n * Append a 64-bit integer to our command\n */\nint redis_cmd_append_sstr_i64(smart_string *str, int64_t append) {\n    char nbuf[21];\n    int len = snprintf(nbuf, sizeof(nbuf), \"%\" PRId64, append);\n    return redis_cmd_append_sstr(str, nbuf, len);\n}\n\n/*\n * Append a 64-bit unsigned integer to our command\n */\nint redis_cmd_append_sstr_u64(smart_string *str, uint64_t append) {\n    char nbuf[21];\n    int len = snprintf(nbuf, sizeof(nbuf), \"%\" PRIu64, append);\n    return redis_cmd_append_sstr(str, nbuf, len);\n}\n\n/*\n * Append a double to a smart string command\n */\nint\nredis_cmd_append_sstr_dbl(smart_string *str, double value)\n{\n    char tmp[64], *p;\n    int len;\n\n    /* Convert to string */\n    len = snprintf(tmp, sizeof(tmp), \"%.17g\", value);\n\n    /* snprintf depends on locale, replace comma with point */\n    if ((p = strchr(tmp, ',')) != NULL) *p = '.';\n\n    // Append the string\n    return redis_cmd_append_sstr(str, tmp, len);\n}\n\n/* Append a zval to a redis command.  If redis_sock is passed as non-null we will\n * the value may be serialized, if we're configured to do that. */\nint redis_cmd_append_sstr_zval(smart_string *str, zval *z, RedisSock *redis_sock) {\n    int valfree, retval;\n    zend_string *zstr, *tmp;\n    size_t vallen;\n    char *val;\n\n    if (redis_sock != NULL) {\n        valfree = redis_pack(redis_sock, z, &val, &vallen);\n        retval = redis_cmd_append_sstr(str, val, vallen);\n        if (valfree) efree(val);\n    } else {\n        zstr = zval_get_tmp_string(z, &tmp);\n        retval = redis_cmd_append_sstr(str, ZSTR_VAL(zstr), ZSTR_LEN(zstr));\n        zend_tmp_string_release(tmp);\n    }\n\n    return retval;\n}\n\nint redis_cmd_append_sstr_zstr(smart_string *str, zend_string *zstr) {\n    return redis_cmd_append_sstr(str, ZSTR_VAL(zstr), ZSTR_LEN(zstr));\n}\n\n/* Append a string key to a redis command.  This function takes care of prefixing the key\n * for the caller and setting the slot argument if it is passed non null */\nint redis_cmd_append_sstr_key(smart_string *str, char *key, size_t len, RedisSock *redis_sock, short *slot) {\n    int valfree, retval;\n\n    valfree = redis_key_prefix(redis_sock, &key, &len);\n    if (slot) *slot = cluster_hash_key(key, len);\n    retval = redis_cmd_append_sstr(str, key, len);\n    if (valfree) efree(key);\n\n    return retval;\n}\n\nint redis_cmd_append_sstr_key_zstr(smart_string *dst, zend_string *key, RedisSock *redis_sock, short *slot) {\n    return redis_cmd_append_sstr_key(dst, ZSTR_VAL(key), ZSTR_LEN(key), redis_sock, slot);\n}\n\nint redis_cmd_append_sstr_key_zval(smart_string *dst, zval *zv, RedisSock *redis_sock, short *slot) {\n    zend_string *key, *tmp;\n    int res;\n\n    key = zval_get_tmp_string(zv, &tmp);\n    res = redis_cmd_append_sstr_key(dst, ZSTR_VAL(key), ZSTR_LEN(key), redis_sock, slot);\n    zend_tmp_string_release(tmp);\n\n    return res;\n}\n\nint redis_cmd_append_sstr_key_long(smart_string *dst, zend_long lval, RedisSock *redis_sock, short *slot) {\n    char buf[64];\n    size_t len;\n    int res;\n\n    len = snprintf(buf, sizeof(buf), ZEND_LONG_FMT, lval);\n    res = redis_cmd_append_sstr_key(dst, buf, len, redis_sock, slot);\n\n    return res;\n}\n\n/* Append an array key to a redis smart string command.  This function\n * handles the boilerplate conditionals around string or integer keys */\nint redis_cmd_append_sstr_arrkey(smart_string *cmd, zend_string *kstr, zend_ulong idx)\n{\n    char *arg, kbuf[128];\n    int len;\n\n    if (kstr) {\n        len = ZSTR_LEN(kstr);\n        arg = ZSTR_VAL(kstr);\n    } else {\n        len = snprintf(kbuf, sizeof(kbuf), \"%ld\", (long)idx);\n        arg = (char*)kbuf;\n    }\n\n    return redis_cmd_append_sstr(cmd, arg, len);\n}\n\nPHP_REDIS_API int\nredis_bulk_double_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx) {\n\n    char *response;\n    int response_len;\n    double ret;\n\n    if ((response = redis_sock_read(redis_sock, &response_len)) == NULL) {\n        if (IS_ATOMIC(redis_sock)) {\n            RETVAL_FALSE;\n        } else {\n            add_next_index_bool(z_tab, 0);\n        }\n        return FAILURE;\n    }\n\n    ret = atof(response);\n    efree(response);\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_DOUBLE(ret);\n    } else {\n        add_next_index_double(z_tab, ret);\n    }\n\n    return SUCCESS;\n}\n\nPHP_REDIS_API int redis_type_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx) {\n    char *response;\n    int response_len;\n    long l;\n\n    if ((response = redis_sock_read(redis_sock, &response_len)) == NULL) {\n        if (IS_ATOMIC(redis_sock)) {\n            RETVAL_FALSE;\n        } else {\n            add_next_index_bool(z_tab, 0);\n        }\n        return FAILURE;\n    }\n\n    if (redis_strncmp(response, ZEND_STRL(\"+string\")) == 0) {\n        l = REDIS_STRING;\n    } else if (redis_strncmp(response, ZEND_STRL(\"+set\")) == 0){\n        l = REDIS_SET;\n    } else if (redis_strncmp(response, ZEND_STRL(\"+list\")) == 0){\n        l = REDIS_LIST;\n    } else if (redis_strncmp(response, ZEND_STRL(\"+zset\")) == 0){\n        l = REDIS_ZSET;\n    } else if (redis_strncmp(response, ZEND_STRL(\"+hash\")) == 0){\n        l = REDIS_HASH;\n    } else if (redis_strncmp(response, ZEND_STRL(\"+stream\")) == 0) {\n        l = REDIS_STREAM;\n    } else {\n        l = REDIS_NOT_FOUND;\n    }\n\n    efree(response);\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_LONG(l);\n    } else {\n        add_next_index_long(z_tab, l);\n    }\n\n    return SUCCESS;\n}\n\nPHP_REDIS_API int\nredis_config_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx) {\n    FailableResultCallback cb = ctx;\n\n    ZEND_ASSERT(cb == redis_boolean_response || cb == redis_mbulk_reply_zipped_raw);\n\n    return cb(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, ctx);\n}\n\nPHP_REDIS_API int\nredis_zrange_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx) {\n    FailableResultCallback cb;\n\n    /* Whether or not we have WITHSCORES */\n    ZEND_ASSERT(ctx == NULL || ctx == PHPREDIS_CTX_PTR);\n\n    cb = ctx ? redis_mbulk_reply_zipped_keys_dbl : redis_sock_read_multibulk_reply;\n\n    return cb(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, ctx);\n}\n\nPHP_REDIS_API int\nredis_srandmember_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx) {\n    FailableResultCallback cb;\n\n    /* Whether or not we have a COUNT argument */\n    ZEND_ASSERT(ctx == NULL || ctx == PHPREDIS_CTX_PTR);\n\n    cb = ctx ? redis_sock_read_multibulk_reply : redis_string_response;\n\n    return cb(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, ctx);\n}\n\nPHP_REDIS_API int redis_info_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx) {\n    char *response;\n    int response_len;\n    zval z_ret;\n\n    /* Read bulk response */\n    if ((response = redis_sock_read(redis_sock, &response_len)) == NULL) {\n        RETVAL_FALSE;\n        return FAILURE;\n    }\n\n    /* Parse it into a zval array */\n    ZVAL_UNDEF(&z_ret);\n    redis_parse_info_response(response, &z_ret);\n\n    /* Free source response */\n    efree(response);\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&z_ret, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &z_ret);\n    }\n\n    return SUCCESS;\n}\n\nPHP_REDIS_API void\nredis_parse_info_response(char *response, zval *z_ret)\n{\n    char *p1, *s1 = NULL;\n\n    ZVAL_FALSE(z_ret);\n    if ((p1 = php_strtok_r(response, _NL, &s1)) != NULL) {\n        array_init(z_ret);\n        do {\n            if (*p1 == '#') continue;\n            char *p;\n            zend_uchar type;\n            zend_long lval;\n            double dval;\n            if ((p = strchr(p1, ':')) != NULL) {\n                type = is_numeric_string(p + 1, strlen(p + 1), &lval, &dval, 0);\n                switch (type) {\n                case IS_LONG:\n                    add_assoc_long_ex(z_ret, p1, p - p1, lval);\n                    break;\n                case IS_DOUBLE:\n                    add_assoc_double_ex(z_ret, p1, p - p1, dval);\n                    break;\n                default:\n                    add_assoc_string_ex(z_ret, p1, p - p1, p + 1);\n                }\n            } else {\n                add_next_index_string(z_ret, p1);\n            }\n        } while ((p1 = php_strtok_r(NULL, _NL, &s1)) != NULL);\n    }\n}\n\nstatic void\nredis_parse_client_info(char *info, zval *z_ret)\n{\n    char *p1, *s1 = NULL;\n\n    ZVAL_FALSE(z_ret);\n    if ((p1 = php_strtok_r(info, \" \", &s1)) != NULL) {\n        array_init(z_ret);\n        do {\n            char *p;\n            zend_uchar type;\n            zend_long lval;\n            double dval;\n            if ((p = strchr(p1, '=')) != NULL) {\n                type = is_numeric_string(p + 1, strlen(p + 1), &lval, &dval, 0);\n                switch (type) {\n                case IS_LONG:\n                    add_assoc_long_ex(z_ret, p1, p - p1, lval);\n                    break;\n                case IS_DOUBLE:\n                    add_assoc_double_ex(z_ret, p1, p - p1, dval);\n                    break;\n                default:\n                    add_assoc_string_ex(z_ret, p1, p - p1, p + 1);\n                }\n            } else {\n                add_next_index_string(z_ret, p1);\n            }\n        } while ((p1 = php_strtok_r(NULL, \" \", &s1)) != NULL);\n    }\n}\n\nstatic int\nredis_client_info_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    char *resp;\n    int resp_len;\n    zval z_ret;\n\n    /* Make sure we can read the bulk response from Redis */\n    if ((resp = redis_sock_read(redis_sock, &resp_len)) == NULL) {\n        RETVAL_FALSE;\n        return FAILURE;\n    }\n\n    /* Parse it out */\n    redis_parse_client_info(resp, &z_ret);\n\n    /* Free our response */\n    efree(resp);\n\n    /* Return or append depending if we're atomic */\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&z_ret, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &z_ret);\n    }\n\n    return SUCCESS;\n}\n\n/*\n * Specialized handling of the CLIENT LIST output so it comes out in a simple way for PHP userland code\n * to handle.\n */\nPHP_REDIS_API int\nredis_client_list_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx) {\n    char *resp;\n    int resp_len;\n    zval z_ret;\n\n    /* Make sure we can read the bulk response from Redis */\n    if ((resp = redis_sock_read(redis_sock, &resp_len)) == NULL) {\n        RETVAL_FALSE;\n        return FAILURE;\n    } else if (resp_len > 0) {\n        /* Parse it out */\n        redis_parse_client_list_response(resp, &z_ret);\n    } else {\n        array_init(&z_ret);\n    }\n\n    /* Free our response */\n    efree(resp);\n\n    /* Return or append depending if we're atomic */\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&z_ret, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &z_ret);\n    }\n\n    return SUCCESS;\n}\n\nPHP_REDIS_API void\nredis_parse_client_list_response(char *response, zval *z_ret)\n{\n    char *p, *s = NULL;\n\n    ZVAL_FALSE(z_ret);\n    if ((p = php_strtok_r(response, _NL, &s)) != NULL) {\n        array_init(z_ret);\n        do {\n            zval z_sub;\n            redis_parse_client_info(p, &z_sub);\n            add_next_index_zval(z_ret, &z_sub);\n        } while ((p = php_strtok_r(NULL, _NL, &s)) != NULL);\n    }\n}\n\nPHP_REDIS_API int\nredis_zadd_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    FailableResultCallback cb;\n\n    ZEND_ASSERT(ctx == NULL || ctx == PHPREDIS_CTX_PTR);\n\n    cb = ctx ? redis_bulk_double_response : redis_long_response;\n\n    return cb(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n}\n\nPHP_REDIS_API int\nredis_zrandmember_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    if (ctx == NULL) {\n        return redis_string_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        return redis_mbulk_reply_raw(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR + 1) {\n        return redis_mbulk_reply_zipped_keys_dbl(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n        return FAILURE;\n    }\n}\n\nPHP_REDIS_API int\nredis_zdiff_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    if (ctx == NULL) {\n        return redis_mbulk_reply_raw(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        return redis_mbulk_reply_zipped_keys_dbl(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n        return FAILURE;\n    }\n}\n\nPHP_REDIS_API int\nredis_set_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    if (ctx == NULL) {\n        return redis_boolean_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        return redis_string_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n        return FAILURE;\n    }\n}\n\nPHP_REDIS_API int\nredis_hrandfield_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    if (ctx == NULL) {\n        return redis_string_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        return redis_mbulk_reply_raw(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR + 1) {\n        return redis_mbulk_reply_zipped_raw(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n        return FAILURE;\n    }\n}\n\nPHP_REDIS_API int\nredis_pop_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    if (ctx == NULL) {\n        return redis_string_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        return redis_sock_read_multibulk_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n        return FAILURE;\n    }\n}\n\nPHP_REDIS_API int\nredis_object_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx) {\n    ZEND_ASSERT(ctx == PHPREDIS_CTX_PTR || ctx == PHPREDIS_CTX_PTR + 1);\n\n    if (ctx == PHPREDIS_CTX_PTR) {\n        return redis_long_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else {\n        return redis_string_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    }\n}\n\nPHP_REDIS_API int\nredis_read_lpos_response(zval *zdst, RedisSock *redis_sock, char reply_type,\n                         long long elements, void *ctx)\n{\n    char inbuf[4096];\n    size_t len;\n    int i;\n\n    if (ctx == NULL) {\n        if (reply_type != TYPE_INT && reply_type != TYPE_BULK)\n            return FAILURE;\n\n        if (elements > -1) {\n            ZVAL_LONG(zdst, elements);\n        } else {\n            REDIS_ZVAL_NULL(redis_sock, zdst);\n        }\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        if (reply_type != TYPE_MULTIBULK)\n            return FAILURE;\n\n        array_init(zdst);\n\n        for (i = 0;  i < elements; ++i) {\n            if (redis_sock_gets(redis_sock, inbuf, sizeof(inbuf), &len) < 0) {\n                zval_dtor(zdst);\n                return FAILURE;\n            }\n            add_next_index_long(zdst, atol(inbuf + 1));\n        }\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n        return FAILURE;\n    }\n\n    return SUCCESS;\n}\n\n\nPHP_REDIS_API int\nredis_lpos_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    char inbuf[1024] = {0};\n    int res = SUCCESS;\n    zval zdst = {0};\n    size_t len;\n\n    /* Attempt to read the LPOS response */\n    if (redis_sock_gets(redis_sock, inbuf, sizeof(inbuf), &len) < 0 ||\n        redis_read_lpos_response(&zdst, redis_sock, *inbuf, atoll(inbuf+1), ctx) < 0)\n    {\n        ZVAL_FALSE(&zdst);\n        res = FAILURE;\n    }\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&zdst, 0, 0);\n    } else {\n        add_next_index_zval(z_tab, &zdst);\n    }\n\n    return res;\n}\n\nPHP_REDIS_API int\nredis_select_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab,\n                      void *ctx)\n{\n    if (redis_boolean_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL) < 0)\n        return FAILURE;\n\n    redis_sock->dbNumber = (long)(uintptr_t)ctx;\n    return SUCCESS;\n}\n\nPHP_REDIS_API int\nredis_boolean_response_impl(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                            zval *z_tab, void *ctx,\n                            SuccessCallback success_callback)\n{\n\n    char *response;\n    int response_len;\n    zend_bool ret = 0;\n\n    if ((response = redis_sock_read(redis_sock, &response_len)) != NULL) {\n        ret = (*response == '+');\n        efree(response);\n    }\n\n    if (ret && success_callback != NULL) {\n        success_callback(redis_sock);\n    }\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_BOOL(ret);\n    } else {\n        add_next_index_bool(z_tab, ret);\n    }\n\n    return ret ? SUCCESS : FAILURE;\n}\n\nPHP_REDIS_API int redis_boolean_response(INTERNAL_FUNCTION_PARAMETERS,\n                                   RedisSock *redis_sock, zval *z_tab,\n                                   void *ctx)\n{\n    return redis_boolean_response_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock,\n                                       z_tab, ctx, NULL);\n}\n\nPHP_REDIS_API int redis_long_response(INTERNAL_FUNCTION_PARAMETERS,\n                                      RedisSock *redis_sock, zval * z_tab,\n                                      void *ctx)\n{\n\n    char *response;\n    int response_len;\n\n    if ((response = redis_sock_read(redis_sock, &response_len)) == NULL || *response != TYPE_INT) {\n        if (IS_ATOMIC(redis_sock)) {\n            RETVAL_FALSE;\n        } else {\n            add_next_index_bool(z_tab, 0);\n        }\n        if (response) efree(response);\n        return FAILURE;\n    }\n\n    int64_t ret = phpredis_atoi64(response + 1);\n\n    if (IS_ATOMIC(redis_sock)) {\n        if (ret > LONG_MAX) { /* overflow */\n            RETVAL_STRINGL(response + 1, response_len - 1);\n        } else {\n            RETVAL_LONG((long)ret);\n        }\n    } else {\n        if (ret > LONG_MAX) { /* overflow */\n            add_next_index_stringl(z_tab, response + 1, response_len - 1);\n        } else {\n            add_next_index_long(z_tab, (long)ret);\n        }\n    }\n\n    efree(response);\n    return SUCCESS;\n}\n\n/* Helper method to convert [key, value, key, value] into [key => value,\n * key => value] when returning data to the caller.  Depending on our decode\n * flag we'll convert the value data types */\nstatic void array_zip_values_and_scores(RedisSock *redis_sock, zval *z_tab,\n                                        int decode)\n{\n\n    zval z_ret, z_sub;\n    HashTable *keytable = Z_ARRVAL_P(z_tab);\n\n    array_init_size(&z_ret, zend_hash_num_elements(keytable) / 2);\n\n    for(zend_hash_internal_pointer_reset(keytable);\n        zend_hash_has_more_elements(keytable) == SUCCESS;\n        zend_hash_move_forward(keytable)) {\n\n        zval *z_key_p, *z_value_p;\n\n        if ((z_key_p = zend_hash_get_current_data(keytable)) == NULL) {\n            continue;   /* this should never happen, according to the PHP people. */\n        }\n\n        /* get current value, a key */\n        zend_string *hkey = Z_STR_P(z_key_p);\n\n        /* move forward */\n        zend_hash_move_forward(keytable);\n\n        /* fetch again */\n        if ((z_value_p = zend_hash_get_current_data(keytable)) == NULL) {\n            continue;   /* this should never happen, according to the PHP people. */\n        }\n\n        /* get current value, a hash value now. */\n        char *hval = Z_STRVAL_P(z_value_p);\n\n        /* Decode the score depending on flag */\n        if (decode == SCORE_DECODE_INT && Z_STRLEN_P(z_value_p) > 0) {\n            ZVAL_LONG(&z_sub, atoi(hval+1));\n        } else if (decode == SCORE_DECODE_DOUBLE) {\n            ZVAL_DOUBLE(&z_sub, atof(hval));\n        } else {\n            ZVAL_ZVAL(&z_sub, z_value_p, 1, 0);\n        }\n        zend_symtable_update(Z_ARRVAL_P(&z_ret), hkey, &z_sub);\n    }\n\n    /* replace */\n    zval_dtor(z_tab);\n    ZVAL_ZVAL(z_tab, &z_ret, 0, 0);\n}\n\nstatic int\narray_zip_values_recursive(zval *z_tab)\n{\n    zend_string *zkey;\n    zval z_ret, z_sub, *zv;\n\n    array_init(&z_ret);\n    for (zend_hash_internal_pointer_reset(Z_ARRVAL_P(z_tab));\n         zend_hash_has_more_elements(Z_ARRVAL_P(z_tab)) == SUCCESS;\n         zend_hash_move_forward(Z_ARRVAL_P(z_tab))\n    ) {\n        if ((zv = zend_hash_get_current_data(Z_ARRVAL_P(z_tab))) == NULL) {\n            zval_dtor(&z_ret);\n            return FAILURE;\n        }\n        if (Z_TYPE_P(zv) == IS_STRING) {\n            zkey = zval_get_string(zv);\n            zend_hash_move_forward(Z_ARRVAL_P(z_tab));\n            if ((zv = zend_hash_get_current_data(Z_ARRVAL_P(z_tab))) == NULL) {\n                zend_string_release(zkey);\n                zval_dtor(&z_ret);\n                return FAILURE;\n            }\n            if (Z_TYPE_P(zv) == IS_ARRAY && array_zip_values_recursive(zv) != SUCCESS) {\n                zend_string_release(zkey);\n                zval_dtor(&z_ret);\n                return FAILURE;\n            }\n            ZVAL_ZVAL(&z_sub, zv, 1, 0);\n            add_assoc_zval_ex(&z_ret, ZSTR_VAL(zkey), ZSTR_LEN(zkey), &z_sub);\n            zend_string_release(zkey);\n        } else {\n            if (Z_TYPE_P(zv) == IS_ARRAY && array_zip_values_recursive(zv) != SUCCESS) {\n                zval_dtor(&z_ret);\n                return FAILURE;\n            }\n            ZVAL_ZVAL(&z_sub, zv, 1, 0);\n            add_next_index_zval(&z_ret, &z_sub);\n        }\n    }\n    zval_dtor(z_tab);\n    ZVAL_ZVAL(z_tab, &z_ret, 0, 0);\n    return SUCCESS;\n}\n\nstatic int\nredis_mbulk_reply_zipped(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                         zval *z_tab, int unserialize, int decode)\n{\n    int numElems;\n\n    if (read_mbulk_header(redis_sock, &numElems) < 0) {\n        if (IS_ATOMIC(redis_sock)) {\n            RETVAL_FALSE;\n        } else {\n            add_next_index_bool(z_tab, 0);\n        }\n        return FAILURE;\n    }\n    zval z_multi_result;\n\n    if (numElems < 1) {\n        ZVAL_EMPTY_ARRAY(&z_multi_result);\n    } else {\n        array_init_size(&z_multi_result, numElems); /* pre-allocate array for multi's results. */\n\n        /* Grab our key, value, key, value array */\n        redis_mbulk_reply_loop(redis_sock, &z_multi_result, numElems, unserialize);\n\n        /* Zip keys and values */\n        array_zip_values_and_scores(redis_sock, &z_multi_result, decode);\n    }\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&z_multi_result, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &z_multi_result);\n    }\n\n    return 0;\n}\n\nstatic int\ngeosearch_cast(zval *zv)\n{\n    if (Z_TYPE_P(zv) == IS_ARRAY) {\n        zend_hash_apply(Z_ARRVAL_P(zv), geosearch_cast);\n    } else if (Z_TYPE_P(zv) == IS_STRING) {\n        convert_to_double(zv);\n    }\n    return SUCCESS;\n}\n\nPHP_REDIS_API int\nredis_read_mpop_response(RedisSock *redis_sock, zval *zdst, int elements,\n                         void *ctx)\n{\n    int subele, keylen;\n    zval zele = {0};\n    char *key;\n\n    ZEND_ASSERT(ctx == NULL || ctx == PHPREDIS_CTX_PTR);\n\n    if (elements < 0) {\n        REDIS_ZVAL_NULL(redis_sock, zdst);\n        return SUCCESS;\n    }\n\n    /* Invariant:  We should have two elements */\n    ZEND_ASSERT(elements == 2);\n\n    array_init(zdst);\n\n    /* Key name and number of entries */\n    if ((key = redis_sock_read(redis_sock, &keylen)) == NULL ||\n        read_mbulk_header(redis_sock, &elements) < 0 || elements < 0)\n    {\n        if (key) efree(key);\n        goto fail;\n    }\n\n    add_next_index_stringl(zdst, key, keylen);\n    efree(key);\n\n    array_init_size(&zele, elements);\n\n    if (ctx == PHPREDIS_CTX_PTR) {\n        int i;\n        for (i = 0; i < elements; i++) {\n            if (read_mbulk_header(redis_sock, &subele) < 0 || subele != 2) {\n                zval_dtor(&zele);\n                goto fail;\n            }\n            redis_mbulk_reply_loop(redis_sock, &zele, subele, UNSERIALIZE_KEYS);\n        }\n\n        array_zip_values_and_scores(redis_sock, &zele, SCORE_DECODE_DOUBLE);\n    } else {\n        redis_mbulk_reply_loop(redis_sock, &zele, elements, UNSERIALIZE_ALL);\n    }\n\n    add_next_index_zval(zdst, &zele);\n\n    return SUCCESS;\n\nfail:\n    zval_dtor(zdst);\n    ZVAL_FALSE(zdst);\n\n    return FAILURE;\n}\n\nPHP_REDIS_API int\nredis_mpop_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                    zval *z_tab, void *ctx)\n{\n    int elements, res = SUCCESS;\n    zval zret = {0};\n\n    if (read_mbulk_header(redis_sock, &elements) == FAILURE ||\n        redis_read_mpop_response(redis_sock, &zret, elements, ctx) == FAILURE)\n    {\n        res = FAILURE;\n        ZVAL_FALSE(&zret);\n    }\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&zret, 0, 0);\n    } else {\n        add_next_index_zval(z_tab, &zret);\n    }\n\n    return res;\n}\n\n#if PHP_VERSION_ID < 80200\nstatic HashTable *zend_array_to_list(HashTable *arr) {\n    zval zret = {0}, *zv;\n\n    array_init_size(&zret, zend_hash_num_elements(arr));\n\n    ZEND_HASH_FOREACH_VAL(arr, zv) {\n        Z_TRY_ADDREF_P(zv);\n        add_next_index_zval(&zret, zv);\n    } ZEND_HASH_FOREACH_END();\n\n    return Z_ARRVAL(zret);\n}\n#endif\n\nPHP_REDIS_API int\nredis_read_geosearch_response(zval *zdst, RedisSock *redis_sock,\n                              long long elements, int with_aux_data)\n{\n    zval z_multi_result, z_sub, *z_ele, *zv;\n    zend_string *zkey;\n\n    /* Handle the trivial \"empty\" result first */\n    if (elements < 0 && redis_sock->null_mbulk_as_null) {\n        ZVAL_NULL(zdst);\n        return SUCCESS;\n    }\n\n    array_init(zdst);\n\n    if (with_aux_data == 0) {\n        redis_mbulk_reply_loop(redis_sock, zdst, elements, UNSERIALIZE_NONE);\n    } else {\n        array_init(&z_multi_result);\n\n        redis_read_multibulk_recursive(redis_sock, elements, 0, &z_multi_result);\n\n        ZEND_HASH_FOREACH_VAL(Z_ARRVAL(z_multi_result), z_ele) {\n            // The first item in the sub-array is always the name of the returned item\n            zv = zend_hash_index_find(Z_ARRVAL_P(z_ele), 0);\n            zkey = zval_get_string(zv);\n\n            zend_hash_index_del(Z_ARRVAL_P(z_ele), 0);\n\n            // The other information is returned in the following order as successive\n            // elements of the sub-array: distance, geohash, coordinates\n            zend_hash_apply(Z_ARRVAL_P(z_ele), geosearch_cast);\n\n            // Reindex elements so they start at zero */\n            ZVAL_ARR(&z_sub, zend_array_to_list(Z_ARRVAL_P(z_ele)));\n\n            add_assoc_zval_ex(zdst, ZSTR_VAL(zkey), ZSTR_LEN(zkey), &z_sub);\n            zend_string_release(zkey);\n        } ZEND_HASH_FOREACH_END();\n\n        // Cleanup\n        zval_dtor(&z_multi_result);\n    }\n\n    return SUCCESS;\n}\n\nPHP_REDIS_API int\nredis_geosearch_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                         zval *z_tab, void *ctx)\n{\n    zval zret = {0};\n    int elements;\n\n    if (read_mbulk_header(redis_sock, &elements) < 0 ||\n        redis_read_geosearch_response(&zret, redis_sock, elements, ctx != NULL) < 0)\n    {\n        ZVAL_FALSE(&zret);\n    }\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&zret, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &zret);\n    }\n\n    return SUCCESS;\n}\n\nstatic int\nredis_client_trackinginfo_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    int numElems;\n    zval z_ret;\n\n    if (read_mbulk_header(redis_sock, &numElems) < 0) {\n        if (IS_ATOMIC(redis_sock)) {\n            RETVAL_FALSE;\n        } else {\n            add_next_index_bool(z_tab, 0);\n        }\n        return FAILURE;\n    }\n\n    array_init(&z_ret);\n    redis_read_multibulk_recursive(redis_sock, numElems, 0, &z_ret);\n    array_zip_values_and_scores(redis_sock, &z_ret, 0);\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&z_ret, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &z_ret);\n    }\n\n    return SUCCESS;\n}\n\nPHP_REDIS_API int\nredis_client_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    if (ctx == NULL) {\n        return redis_client_info_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        return redis_client_list_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR + 1) {\n        return redis_boolean_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR + 2) {\n        return redis_long_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR + 3) {\n        return redis_string_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR + 4) {\n        return redis_client_trackinginfo_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n        return FAILURE;\n    }\n}\n\nstatic int\nredis_function_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    int numElems;\n    zval z_ret;\n\n    if (read_mbulk_header(redis_sock, &numElems) < 0) {\n        if (IS_ATOMIC(redis_sock)) {\n            RETVAL_FALSE;\n        } else {\n            add_next_index_bool(z_tab, 0);\n        }\n        return FAILURE;\n    }\n\n    array_init(&z_ret);\n    redis_read_multibulk_recursive(redis_sock, numElems, 0, &z_ret);\n    array_zip_values_recursive(&z_ret);\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&z_ret, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &z_ret);\n    }\n\n    return SUCCESS;\n}\n\n\nPHP_REDIS_API int\nredis_function_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    if (ctx == NULL) {\n        return redis_boolean_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        return redis_string_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR + 1) {\n        return redis_function_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n        return FAILURE;\n    }\n}\n\nstatic int\nredis_command_info_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    int numElems;\n    zval z_ret;\n\n    if (read_mbulk_header(redis_sock, &numElems) < 0) {\n        if (IS_ATOMIC(redis_sock)) {\n            RETVAL_FALSE;\n        } else {\n            add_next_index_bool(z_tab, 0);\n        }\n        return FAILURE;\n    }\n\n    array_init(&z_ret);\n    redis_read_multibulk_recursive(redis_sock, numElems, 0, &z_ret);\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&z_ret, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &z_ret);\n    }\n\n    return SUCCESS;\n}\n\nPHP_REDIS_API int\nredis_command_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    if (ctx == NULL) {\n        return redis_command_info_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        return redis_long_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR + 1) {\n        return redis_mbulk_reply_raw(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n        return FAILURE;\n    }\n}\n\n/* Helper function to consume Redis stream message data.  This is useful for\n * multiple stream callers (e.g. XREAD[GROUP], and X[REV]RANGE handlers). */\nPHP_REDIS_API int\nredis_read_stream_messages(RedisSock *redis_sock, int count, zval *z_ret\n                          )\n{\n    zval z_message;\n    int i, mhdr, fields;\n    char *id = NULL;\n    int idlen;\n\n    /* Iterate over each message */\n    for (i = 0; i < count; i++) {\n        /* Consume inner multi-bulk header, message ID itself and finally\n         * the multi-bulk header for field and values */\n        if ((read_mbulk_header(redis_sock, &mhdr) < 0 || mhdr != 2) ||\n            ((id = redis_sock_read(redis_sock, &idlen)) == NULL) ||\n            (read_mbulk_header(redis_sock, &fields) < 0 ||\n            (fields > 0 && fields % 2 != 0)))\n        {\n            if (id) efree(id);\n            return -1;\n        }\n\n        if (fields < 0) {\n            add_assoc_null_ex(z_ret, id, idlen);\n        } else {\n            array_init(&z_message);\n            redis_mbulk_reply_loop(redis_sock, &z_message, fields, UNSERIALIZE_VALS);\n            array_zip_values_and_scores(redis_sock, &z_message, SCORE_DECODE_NONE);\n            add_assoc_zval_ex(z_ret, id, idlen, &z_message);\n        }\n        efree(id);\n    }\n\n    return 0;\n}\n\nPHP_REDIS_API int\nredis_xrange_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   zval *z_tab, void *ctx)\n{\n    zval z_messages;\n    int messages;\n\n    array_init(&z_messages);\n\n    if (read_mbulk_header(redis_sock, &messages) < 0 ||\n        redis_read_stream_messages(redis_sock, messages, &z_messages) < 0)\n    {\n        zval_dtor(&z_messages);\n        if (IS_ATOMIC(redis_sock)) {\n            RETVAL_FALSE;\n        } else {\n            add_next_index_bool(z_tab, 0);\n        }\n        return -1;\n    }\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&z_messages, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &z_messages);\n    }\n\n    return 0;\n}\n\nPHP_REDIS_API int\nredis_read_stream_messages_multi(RedisSock *redis_sock, int count, zval *z_streams\n                                )\n{\n    zval z_messages;\n    int i, shdr, messages;\n    char *id = NULL;\n    int idlen;\n\n    for (i = 0; i < count; i++) {\n        if ((read_mbulk_header(redis_sock, &shdr) < 0 || shdr != 2) ||\n            (id = redis_sock_read(redis_sock, &idlen)) == NULL ||\n            read_mbulk_header(redis_sock, &messages) < 0)\n        {\n            if (id) efree(id);\n            return -1;\n        }\n\n        array_init(&z_messages);\n\n        if (redis_read_stream_messages(redis_sock, messages, &z_messages) < 0)\n            goto failure;\n\n        add_assoc_zval_ex(z_streams, id, idlen, &z_messages);\n        efree(id);\n    }\n\n    return 0;\nfailure:\n    efree(id);\n    zval_dtor(&z_messages);\n    return -1;\n}\n\nPHP_REDIS_API int\nredis_xread_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                  zval *z_tab, void *ctx)\n{\n    zval z_rv;\n    int streams;\n\n    if (read_mbulk_header(redis_sock, &streams) < 0)\n        goto failure;\n\n    if (streams == -1 && redis_sock->null_mbulk_as_null) {\n        ZVAL_NULL(&z_rv);\n    } else {\n        array_init(&z_rv);\n        if (redis_read_stream_messages_multi(redis_sock, streams, &z_rv) < 0)\n            goto cleanup;\n    }\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&z_rv, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &z_rv);\n    }\n    return 0;\n\ncleanup:\n    zval_dtor(&z_rv);\nfailure:\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_FALSE;\n    } else {\n        add_next_index_bool(z_tab, 0);\n    }\n    return -1;\n}\n\n/* A helper method to read X[AUTO]CLAIM messages into an array.  */\nstatic int\nredis_read_xclaim_ids(RedisSock *redis_sock, int count, zval *rv) {\n    zval z_msg;\n    REDIS_REPLY_TYPE type;\n    char *id = NULL;\n    int i, fields, idlen;\n    long li;\n\n    for (i = 0; i < count; i++) {\n        id = NULL;\n\n        /* Consume inner reply type */\n        if (redis_read_reply_type(redis_sock, &type, &li) < 0 ||\n            (type != TYPE_BULK && type != TYPE_MULTIBULK) ||\n            (type == TYPE_BULK && li <= 0)) return -1;\n\n        /* TYPE_BULK is the JUSTID variant, otherwise it's standard xclaim response */\n        if (type == TYPE_BULK) {\n            if ((id = redis_sock_read_bulk_reply(redis_sock, (size_t)li)) == NULL)\n                return -1;\n\n            add_next_index_stringl(rv, id, li);\n            efree(id);\n        } else {\n            if ((li != 2 || (id = redis_sock_read(redis_sock, &idlen)) == NULL) ||\n                (read_mbulk_header(redis_sock, &fields) < 0 || fields % 2 != 0))\n            {\n                if (id) efree(id);\n                return -1;\n            }\n\n            array_init(&z_msg);\n\n            redis_mbulk_reply_loop(redis_sock, &z_msg, fields, UNSERIALIZE_VALS);\n            array_zip_values_and_scores(redis_sock, &z_msg, SCORE_DECODE_NONE);\n            add_assoc_zval_ex(rv, id, idlen, &z_msg);\n            efree(id);\n        }\n    }\n\n    return 0;\n}\n\n/* Read an X[AUTO]CLAIM reply having already consumed the reply-type byte. */\nPHP_REDIS_API int\nredis_read_xclaim_reply(RedisSock *redis_sock, int count, int is_xautoclaim, zval *rv) {\n    REDIS_REPLY_TYPE type;\n    zval z_msgs = {0};\n    char *id = NULL;\n    long id_len = 0;\n    int messages = 0;\n\n    ZEND_ASSERT(!is_xautoclaim || (count == 2 || count == 3));\n\n    ZVAL_UNDEF(rv);\n\n    /* If this is XAUTOCLAIM consume the BULK ID and then the actual number of IDs.\n     * Otherwise, our 'count' argument is the number of IDs. */\n    if (is_xautoclaim) {\n        if (redis_read_reply_type(redis_sock, &type, &id_len) < 0 || type != TYPE_BULK)\n            goto failure;\n        if ((id = redis_sock_read_bulk_reply(redis_sock, id_len)) == NULL)\n            goto failure;\n        if (read_mbulk_header(redis_sock, &messages) < 0)\n            goto failure;\n    } else {\n        messages = count;\n    }\n\n    array_init(&z_msgs);\n\n    if (redis_read_xclaim_ids(redis_sock, messages, &z_msgs) < 0)\n        goto failure;\n\n    /* If XAUTOCLAIM we now need to consume the final array of message IDs */\n    if (is_xautoclaim) {\n        zval z_deleted = {0};\n\n        if (count == 3 && redis_sock_read_multibulk_reply_zval(redis_sock, &z_deleted) == NULL)\n            goto failure;\n\n        array_init(rv);\n\n        // Package up ID and message\n        add_next_index_stringl(rv, id, id_len);\n        add_next_index_zval(rv, &z_msgs);\n\n        // Add deleted messages if they exist\n        if (count == 3)\n            add_next_index_zval(rv, &z_deleted);\n\n        efree(id);\n    } else {\n        // We just want the messages\n        ZVAL_COPY_VALUE(rv, &z_msgs);\n    }\n\n    return 0;\n\nfailure:\n    zval_dtor(&z_msgs);\n    zval_dtor(rv);\n    if (id) efree(id);\n\n    return -1;\n}\n\nPHP_REDIS_API int\nredis_xclaim_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   zval *z_tab, void *ctx)\n{\n    zval z_ret = {0};\n    int count;\n\n    ZEND_ASSERT(ctx == NULL || ctx == PHPREDIS_CTX_PTR);\n\n    if (read_mbulk_header(redis_sock, &count) < 0)\n        goto failure;\n\n    if (redis_read_xclaim_reply(redis_sock, count, ctx == PHPREDIS_CTX_PTR, &z_ret) < 0)\n        goto failure;\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&z_ret, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &z_ret);\n    }\n\n    return 0;\n\nfailure:\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_FALSE;\n    } else {\n        add_next_index_bool(z_tab, 0);\n    }\n    return -1;\n}\n\nPHP_REDIS_API int\nredis_read_xinfo_response(RedisSock *redis_sock, zval *z_ret, int elements)\n{\n    zval zv;\n    int i, len = 0;\n    char *key = NULL, *data;\n    REDIS_REPLY_TYPE type;\n    long li;\n\n    for (i = 0; i < elements; ++i) {\n        if (redis_read_reply_type(redis_sock, &type, &li) < 0) {\n            goto failure;\n        }\n        switch (type) {\n        case TYPE_BULK:\n            if ((data = redis_sock_read_bulk_reply(redis_sock, li)) == NULL) {\n                if (!key) goto failure;\n                add_assoc_null_ex(z_ret, key, len);\n                efree(key);\n                key = NULL;\n            } else if (key) {\n                add_assoc_stringl_ex(z_ret, key, len, data, li);\n                efree(data);\n                efree(key);\n                key = NULL;\n            } else {\n                key = data;\n                len = li;\n            }\n            break;\n        case TYPE_INT:\n            if (key) {\n                add_assoc_long_ex(z_ret, key, len, li);\n                efree(key);\n                key = NULL;\n            } else {\n                len = spprintf(&key, 0, \"%ld\", li);\n            }\n            break;\n        case TYPE_MULTIBULK:\n            array_init(&zv);\n            if (redis_read_xinfo_response(redis_sock, &zv, li) != SUCCESS) {\n                zval_dtor(&zv);\n                goto failure;\n            }\n            if (key) {\n                add_assoc_zval_ex(z_ret, key, len, &zv);\n                efree(key);\n                key = NULL;\n            } else {\n                add_next_index_zval(z_ret, &zv);\n            }\n            break;\n        default:\n            goto failure;\n        }\n    }\n\n    return SUCCESS;\n\nfailure:\n    if (key) efree(key);\n    return FAILURE;\n}\n\nPHP_REDIS_API int\nredis_xinfo_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    zval z_ret;\n    int elements;\n\n    if (read_mbulk_header(redis_sock, &elements) == SUCCESS) {\n        array_init(&z_ret);\n        if (redis_read_xinfo_response(redis_sock, &z_ret, elements) == SUCCESS) {\n            if (IS_ATOMIC(redis_sock)) {\n                RETVAL_ZVAL(&z_ret, 0, 1);\n            } else {\n                add_next_index_zval(z_tab, &z_ret);\n            }\n            return SUCCESS;\n        }\n        zval_dtor(&z_ret);\n    }\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_FALSE;\n    } else {\n        add_next_index_bool(z_tab, 0);\n    }\n    return FAILURE;\n}\n\nPHP_REDIS_API int\nredis_acl_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    if (ctx == NULL) {\n        return redis_read_variant_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR) {\n        return redis_boolean_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR + 1) {\n        return redis_string_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR + 2) {\n        return redis_long_response(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR + 3) {\n        return redis_acl_getuser_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else if (ctx == PHPREDIS_CTX_PTR + 4) {\n        return redis_acl_log_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, NULL);\n    } else {\n        ZEND_ASSERT(!\"memory corruption?\");\n        return FAILURE;\n    }\n}\n\nPHP_REDIS_API int\nredis_read_acl_log_reply(RedisSock *redis_sock, zval *zret, long count) {\n    zval zsub;\n    int i, nsub;\n\n    for (i = 0; i < count; i++) {\n        if (read_mbulk_header(redis_sock, &nsub) < 0 || nsub % 2 != 0)\n            return FAILURE;\n\n        array_init(&zsub);\n        if (redis_mbulk_reply_zipped_raw_variant(redis_sock, &zsub, nsub) == FAILURE)\n            return FAILURE;\n\n        add_next_index_zval(zret, &zsub);\n    }\n\n    return SUCCESS;\n}\n\nPHP_REDIS_API int\nredis_read_acl_getuser_reply(RedisSock *redis_sock, zval *zret, long count) {\n    REDIS_REPLY_TYPE type;\n    zval zv;\n    char *key, *val;\n    long vlen;\n    int klen, i;\n\n    for (i = 0; i < count; i += 2) {\n        if (!(key = redis_sock_read(redis_sock, &klen)) ||\n            redis_read_reply_type(redis_sock, &type, &vlen) < 0 ||\n            (type != TYPE_BULK && type != TYPE_MULTIBULK) ||\n            vlen > INT_MAX)\n        {\n            if (key) efree(key);\n            return FAILURE;\n        }\n\n        if (type == TYPE_BULK) {\n            if (!(val = redis_sock_read_bulk_reply(redis_sock, (int)vlen)))\n                return FAILURE;\n            add_assoc_stringl_ex(zret, key, klen, val, vlen);\n            efree(val);\n        } else {\n            array_init(&zv);\n            redis_mbulk_reply_loop(redis_sock, &zv, (int)vlen, UNSERIALIZE_NONE);\n            add_assoc_zval_ex(zret, key, klen, &zv);\n        }\n\n        efree(key);\n    }\n\n    return SUCCESS;\n}\n\nint redis_acl_custom_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx,\n                           int (*cb)(RedisSock*, zval*, long)) {\n    REDIS_REPLY_TYPE type;\n    int res = FAILURE;\n    zval zret;\n    long len;\n\n    if (redis_read_reply_type(redis_sock, &type, &len) == 0 && type == TYPE_MULTIBULK) {\n        array_init(&zret);\n\n        res = cb(redis_sock, &zret, len);\n        if (res == FAILURE) {\n            zval_dtor(&zret);\n            ZVAL_FALSE(&zret);\n        }\n    } else {\n        ZVAL_FALSE(&zret);\n    }\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&zret, 0, 0);\n    } else {\n        add_next_index_zval(z_tab, &zret);\n    }\n\n    return res;\n}\n\nint redis_acl_getuser_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx) {\n    return redis_acl_custom_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, ctx,\n                                  redis_read_acl_getuser_reply);\n}\n\nint redis_acl_log_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx) {\n    return redis_acl_custom_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, ctx,\n                                  redis_read_acl_log_reply);\n}\n\n/* Zipped key => value reply but we don't touch anything (e.g. CONFIG GET) */\nPHP_REDIS_API int redis_mbulk_reply_zipped_raw(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    return redis_mbulk_reply_zipped(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock,\n        z_tab, UNSERIALIZE_NONE, SCORE_DECODE_NONE);\n}\n\n/* Zipped key => value reply unserializing keys and decoding the score as an integer (PUBSUB) */\nPHP_REDIS_API int redis_mbulk_reply_zipped_keys_int(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                                               zval *z_tab, void *ctx)\n{\n    return redis_mbulk_reply_zipped(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock,\n        z_tab, UNSERIALIZE_KEYS, SCORE_DECODE_INT);\n}\n\n/* Zipped key => value reply unserializing keys and decoding the score as a double (ZSET commands) */\nPHP_REDIS_API int redis_mbulk_reply_zipped_keys_dbl(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                                                    zval *z_tab, void *ctx)\n{\n    return redis_mbulk_reply_zipped(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock,\n        z_tab, UNSERIALIZE_KEYS, SCORE_DECODE_DOUBLE);\n}\n\n/* Zipped key => value reply where only the values are unserialized (e.g. HMGET) */\nPHP_REDIS_API int redis_mbulk_reply_zipped_vals(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                                               zval *z_tab, void *ctx)\n{\n    return redis_mbulk_reply_zipped(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock,\n        z_tab, UNSERIALIZE_VALS, SCORE_DECODE_NONE);\n}\n\nPHP_REDIS_API int\nredis_1_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    char *response;\n    int response_len;\n    zend_bool ret = 0;\n\n    if ((response = redis_sock_read(redis_sock, &response_len)) != NULL) {\n        ret = (response[1] == '1');\n        efree(response);\n    }\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_BOOL(ret);\n    } else {\n        add_next_index_bool(z_tab, ret);\n    }\n\n    return ret ? SUCCESS : FAILURE;\n}\n\nPHP_REDIS_API int redis_string_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx) {\n\n    char *response;\n    int response_len;\n\n    if ((response = redis_sock_read(redis_sock, &response_len))\n                                    == NULL)\n    {\n        if (IS_ATOMIC(redis_sock)) {\n            RETVAL_FALSE;\n        } else {\n            add_next_index_bool(z_tab, 0);\n        }\n        return FAILURE;\n    }\n    if (IS_ATOMIC(redis_sock)) {\n        if (!redis_unpack(redis_sock, response, response_len, return_value)) {\n            RETVAL_STRINGL_FAST(response, response_len);\n        }\n    } else {\n        zval z_unpacked;\n        if (redis_unpack(redis_sock, response, response_len, &z_unpacked)) {\n            add_next_index_zval(z_tab, &z_unpacked);\n        } else {\n            redis_add_next_index_stringl(z_tab, response, response_len);\n        }\n    }\n\n    efree(response);\n    return SUCCESS;\n}\n\n/* like string response, but never unserialized. */\nPHP_REDIS_API int\nredis_ping_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                    zval *z_tab, void *ctx)\n{\n\n    char *response;\n    int response_len;\n\n    if ((response = redis_sock_read(redis_sock, &response_len))\n                                    == NULL)\n    {\n        if (IS_ATOMIC(redis_sock)) {\n            RETVAL_FALSE;\n        } else {\n            add_next_index_bool(z_tab, 0);\n        }\n        return FAILURE;\n    }\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_STRINGL(response, response_len);\n    } else {\n        add_next_index_stringl(z_tab, response, response_len);\n    }\n\n    efree(response);\n    return SUCCESS;\n}\n\nPHP_REDIS_API int\nredis_sock_configure(RedisSock *redis_sock, HashTable *opts)\n{\n    zend_string *zkey;\n    zval *val;\n\n    ZEND_HASH_FOREACH_STR_KEY_VAL(opts, zkey, val) {\n        if (zkey == NULL) {\n            continue;\n        }\n        ZVAL_DEREF(val);\n        if (zend_string_equals_literal_ci(zkey, \"host\")) {\n            if (Z_TYPE_P(val) != IS_STRING) {\n                REDIS_VALUE_EXCEPTION(\"Invalid host\");\n                return FAILURE;\n            }\n            if (redis_sock->host) zend_string_release(redis_sock->host);\n            redis_sock->host = zval_get_string(val);\n        } else if (zend_string_equals_literal_ci(zkey, \"port\")) {\n            if (Z_TYPE_P(val) != IS_LONG) {\n                REDIS_VALUE_EXCEPTION(\"Invalid port\");\n                return FAILURE;\n            }\n            redis_sock->port = zval_get_long(val);\n        } else if (zend_string_equals_literal_ci(zkey, \"connectTimeout\")) {\n            if (Z_TYPE_P(val) != IS_LONG && Z_TYPE_P(val) != IS_DOUBLE) {\n                REDIS_VALUE_EXCEPTION(\"Invalid connect timeout\");\n                return FAILURE;\n            }\n            redis_sock->timeout = zval_get_double(val);\n        } else if (zend_string_equals_literal_ci(zkey, \"readTimeout\")) {\n            if (Z_TYPE_P(val) != IS_LONG && Z_TYPE_P(val) != IS_DOUBLE) {\n                REDIS_VALUE_EXCEPTION(\"Invalid read timeout\");\n                return FAILURE;\n            }\n            redis_sock->read_timeout = zval_get_double(val);\n        } else if (zend_string_equals_literal_ci(zkey, \"persistent\")) {\n            if (Z_TYPE_P(val) == IS_STRING) {\n                if (redis_sock->persistent_id) zend_string_release(redis_sock->persistent_id);\n                redis_sock->persistent_id = zval_get_string(val);\n                redis_sock->persistent = 1;\n            } else {\n                redis_sock->persistent = zval_is_true(val);\n            }\n        } else if (zend_string_equals_literal_ci(zkey, \"retryInterval\")) {\n            if (Z_TYPE_P(val) != IS_LONG && Z_TYPE_P(val) != IS_DOUBLE) {\n                REDIS_VALUE_EXCEPTION(\"Invalid retry interval\");\n                return FAILURE;\n            }\n            redis_sock->retry_interval = zval_get_long(val);\n        } else if (zend_string_equals_literal_ci(zkey, \"ssl\")) {\n            if (redis_sock_set_stream_context(redis_sock, val) != SUCCESS) {\n                REDIS_VALUE_EXCEPTION(\"Invalid SSL context options\");\n                return FAILURE;\n            }\n        } else if (zend_string_equals_literal_ci(zkey, \"auth\")) {\n            if (Z_TYPE_P(val) != IS_STRING && Z_TYPE_P(val) != IS_ARRAY) {\n                REDIS_VALUE_EXCEPTION(\"Invalid auth credentials\");\n                return FAILURE;\n            }\n            redis_sock_set_auth_zval(redis_sock, val);\n        } else if (zend_string_equals_literal_ci(zkey, \"backoff\")) {\n            if (redis_sock_set_backoff(redis_sock, val) != SUCCESS) {\n                REDIS_VALUE_EXCEPTION(\"Invalid backoff options\");\n                return FAILURE;\n            }\n        } else {\n             php_error_docref(NULL, E_WARNING, \"Skip unknown option '%s'\", ZSTR_VAL(zkey));\n        }\n    } ZEND_HASH_FOREACH_END();\n\n    return SUCCESS;\n}\n\n/**\n * redis_sock_create\n */\nPHP_REDIS_API RedisSock*\nredis_sock_create(char *host, int host_len, int port,\n                  double timeout, double read_timeout,\n                  int persistent, char *persistent_id,\n                  long retry_interval)\n{\n    RedisSock *redis_sock;\n\n    redis_sock = ecalloc(1, sizeof(RedisSock));\n    redis_sock->host = zend_string_init(host, host_len, 0);\n    redis_sock->status = REDIS_SOCK_STATUS_DISCONNECTED;\n    redis_sock->retry_interval = retry_interval * 1000;\n    redis_sock->max_retries = 10;\n    redis_initialize_backoff(&redis_sock->backoff, redis_sock->retry_interval);\n    redis_sock->persistent = persistent;\n\n    if (persistent && persistent_id != NULL) {\n        redis_sock->persistent_id = zend_string_init(persistent_id, strlen(persistent_id), 0);\n    }\n\n    redis_sock->port    = port;\n    redis_sock->timeout = timeout;\n    redis_sock->read_timeout = read_timeout;\n\n    redis_sock->serializer = REDIS_SERIALIZER_NONE;\n    redis_sock->compression = REDIS_COMPRESSION_NONE;\n    redis_sock->mode = ATOMIC;\n\n    return redis_sock;\n}\n\nstatic int redis_uniqid(char *buf, size_t buflen) {\n    static unsigned long counter = 0;\n    struct timeval tv;\n\n    gettimeofday(&tv, NULL);\n\n    return snprintf(buf, buflen, \"phpredis:%08lx%05lx:%08lx\",\n                    (long)tv.tv_sec, (long)tv.tv_usec, counter++);\n}\n\nstatic int redis_stream_liveness_check(php_stream *stream) {\n    return php_stream_set_option(stream, PHP_STREAM_OPTION_CHECK_LIVENESS,\n                                 0, NULL) == PHP_STREAM_OPTION_RETURN_OK ?\n                                 SUCCESS : FAILURE;\n}\n\n/* Try to get the underlying socket FD for use with poll/select.\n * Returns -1 on failure. */\nstatic php_socket_t redis_stream_fd_for_select(php_stream *stream) {\n    php_socket_t fd;\n    int flags;\n\n    flags = PHP_STREAM_AS_FD_FOR_SELECT | PHP_STREAM_CAST_INTERNAL;\n    if (php_stream_cast(stream, flags, (void*)&fd, 1) == FAILURE)\n        return -1;\n\n    return fd;\n}\n\nstatic int redis_detect_dirty_config(void) {\n    int val = INI_INT(\"redis.pconnect.pool_detect_dirty\");\n\n    if (val >= 0 && val <= 2)\n        return val;\n    else if (val > 2)\n        return 2;\n    else\n        return 0;\n}\n\nstatic int redis_pool_poll_timeout(void) {\n    int val = INI_INT(\"redis.pconnect.pool_poll_timeout\");\n    if (val >= 0)\n        return val;\n\n    return 0;\n}\n\n#define REDIS_POLL_FD_SET(_pfd, _fd, _events) \\\n    (_pfd).fd = _fd; (_pfd).events = _events; (_pfd).revents = 0\n\n/* Try to determine if the socket is out of sync (has unconsumed replies) */\nstatic int redis_stream_detect_dirty(php_stream *stream) {\n    php_socket_t fd;\n    php_pollfd pfd;\n    int rv, action;\n\n    /* Short circuit if this is disabled */\n    if ((action = redis_detect_dirty_config()) == 0)\n        return SUCCESS;\n\n    /* Seek past unconsumed bytes if we detect them */\n    if (stream->readpos < stream->writepos) {\n        redisDbgFmt(\"%s on unconsumed buffer (%ld < %ld)\",\n                    action > 1 ? \"Aborting\" : \"Seeking\",\n                    (long)stream->readpos, (long)stream->writepos);\n\n        /* Abort if we are configured to immediately fail */\n        if (action == 1)\n            return FAILURE;\n\n        /* Seek to the end of buffered data */\n        zend_off_t offset = stream->writepos - stream->readpos;\n        if (php_stream_seek(stream, offset, SEEK_CUR) == FAILURE)\n            return FAILURE;\n    }\n\n    /* Get the underlying FD */\n    if ((fd = redis_stream_fd_for_select(stream)) == -1)\n        return FAILURE;\n\n    /* We want to detect a readable socket (it shouldn't be) */\n    REDIS_POLL_FD_SET(pfd, fd, PHP_POLLREADABLE);\n    rv = php_poll2(&pfd, 1, redis_pool_poll_timeout());\n\n    /* If we detect the socket is readable, it's dirty which is\n     * a failure.  Otherwise as best we can tell it's good.\n     * TODO:  We could attempt to consume up to N bytes */\n    redisDbgFmt(\"Detected %s socket\", rv > 0 ? \"readable\" : \"unreadable\");\n    return rv == 0 ? SUCCESS : FAILURE;\n}\n\nstatic int\nredis_sock_check_liveness(RedisSock *redis_sock)\n{\n    char id[64], inbuf[4096];\n    int idlen, auth;\n    smart_string cmd = {0};\n    size_t len;\n\n    /* Short circuit if PHP detects the stream isn't live */\n    if (redis_stream_liveness_check(redis_sock->stream) != SUCCESS)\n        goto failure;\n\n    /* Short circuit if we detect the stream is \"dirty\", can't or are\n       configured not to try and fix it */\n    if (redis_stream_detect_dirty(redis_sock->stream) != SUCCESS)\n        goto failure;\n\n    redis_sock->status = REDIS_SOCK_STATUS_CONNECTED;\n    if (!INI_INT(\"redis.pconnect.echo_check_liveness\")) {\n        return SUCCESS;\n    }\n\n    /* AUTH (if we need it) */\n    auth = redis_sock_append_auth(redis_sock, &cmd);\n\n    /* ECHO challenge/response */\n    idlen = redis_uniqid(id, sizeof(id));\n    REDIS_CMD_INIT_SSTR_STATIC(&cmd, 1, \"ECHO\");\n    redis_cmd_append_sstr(&cmd, id, idlen);\n\n    /* Send command(s) and make sure we can consume reply(ies) */\n    if (redis_sock_write(redis_sock, cmd.c, cmd.len) < 0) {\n        smart_string_free(&cmd);\n        goto failure;\n    }\n    smart_string_free(&cmd);\n\n    if (redis_sock_gets(redis_sock, inbuf, sizeof(inbuf) - 1, &len) < 0) {\n        goto failure;\n    }\n\n    if (auth) {\n        if (redis_strncmp(inbuf, ZEND_STRL(\"+OK\")) == 0 ||\n            redis_strncmp(inbuf, ZEND_STRL(\"-ERR Client sent AUTH\")) == 0)\n        {\n            /* successfully authenticated or authentication isn't required */\n            if (redis_sock_gets(redis_sock, inbuf, sizeof(inbuf) - 1, &len) < 0) {\n                goto failure;\n            }\n        } else if (redis_strncmp(inbuf, ZEND_STRL(\"-NOAUTH\")) == 0) {\n            /* connection is fine but authentication failed, next command must\n             * fail too */\n            if (redis_sock_gets(redis_sock, inbuf, sizeof(inbuf) - 1, &len) < 0\n                || redis_strncmp(inbuf, ZEND_STRL(\"-NOAUTH\")) != 0)\n            {\n                goto failure;\n            }\n            return SUCCESS;\n        } else {\n            goto failure;\n        }\n        redis_sock->status = REDIS_SOCK_STATUS_AUTHENTICATED;\n    } else {\n        if (redis_strncmp(inbuf, ZEND_STRL(\"-NOAUTH\")) == 0) {\n            /* connection is fine but authentication required */\n            return SUCCESS;\n        }\n    }\n\n    /* check echo response */\n    if ((redis_sock->sentinel && (\n        redis_strncmp(inbuf, ZEND_STRL(\"-ERR unknown command\")) != 0 ||\n        strstr(inbuf, id) == NULL\n    )) || *inbuf != TYPE_BULK || atoi(inbuf + 1) != idlen ||\n        redis_sock_gets(redis_sock, inbuf, sizeof(inbuf) - 1, &len) < 0 ||\n        redis_strncmp(inbuf, id, idlen) != 0\n    ) {\n        goto failure;\n    }\n\n    return SUCCESS;\nfailure:\n    redis_sock->status = REDIS_SOCK_STATUS_DISCONNECTED;\n    if (redis_sock->stream) {\n        php_stream_pclose(redis_sock->stream);\n        redis_sock->stream = NULL;\n    }\n    return FAILURE;\n}\n\n/**\n * redis_sock_connect\n */\nPHP_REDIS_API int redis_sock_connect(RedisSock *redis_sock)\n{\n    struct timeval tv, read_tv, *tv_ptr = NULL;\n    zend_string *persistent_id = NULL, *estr = NULL;\n    char host[1024], scheme[8], *pos, *address;\n    const char *fmtstr = \"%s://%s:%d\";\n    int host_len, usocket = 0, err = 0, tcp_flag = 1;\n    ConnectionPool *p = NULL;\n\n    if (redis_sock->stream != NULL) {\n        redis_sock_disconnect(redis_sock, 0, 1);\n    }\n\n    address = ZSTR_VAL(redis_sock->host);\n    if ((pos = strstr(address, \"://\")) == NULL) {\n        strcpy(scheme, redis_sock->stream_ctx ? \"ssl\" : \"tcp\");\n    } else {\n        snprintf(scheme, sizeof(scheme), \"%.*s\", (int)(pos - address), address);\n        address = pos + sizeof(\"://\") - 1;\n    }\n    if (address[0] == '/' && redis_sock->port < 1) {\n        host_len = snprintf(host, sizeof(host), \"unix://%s\", address);\n        usocket = 1;\n    } else {\n        if(redis_sock->port == 0)\n            redis_sock->port = 6379;\n\n#ifdef HAVE_IPV6\n        /* If we've got IPv6 and find a colon in our address, convert to proper\n         * IPv6 [host]:port format */\n        if (strchr(address, ':') != NULL && strchr(address, '[') == NULL) {\n            fmtstr = \"%s://[%s]:%d\";\n        }\n#endif\n        host_len = snprintf(host, sizeof(host), fmtstr, scheme, address, redis_sock->port);\n    }\n\n    if (redis_sock->persistent) {\n        if (INI_INT(\"redis.pconnect.pooling_enabled\")) {\n            p = redis_sock_get_connection_pool(redis_sock);\n            if (zend_llist_count(&p->list) > 0) {\n                redis_sock->stream = *(php_stream **)zend_llist_get_last(&p->list);\n                zend_llist_remove_tail(&p->list);\n\n                if (redis_sock_check_liveness(redis_sock) == SUCCESS) {\n                    return SUCCESS;\n                }\n\n                p->nb_active--;\n            }\n\n            int limit = INI_INT(\"redis.pconnect.connection_limit\");\n            if (limit > 0 && p->nb_active >= limit) {\n                redis_sock_set_err(redis_sock, ZEND_STRL(\"Connection limit reached\"));\n                return FAILURE;\n            }\n\n            gettimeofday(&tv, NULL);\n            persistent_id = strpprintf(0, \"phpredis_%ld%ld\", tv.tv_sec, (long)tv.tv_usec);\n        } else {\n            if (redis_sock->persistent_id) {\n                persistent_id = strpprintf(0, \"phpredis:%s:%s\", host, ZSTR_VAL(redis_sock->persistent_id));\n            } else {\n                persistent_id = strpprintf(0, \"phpredis:%s:%f\", host, redis_sock->timeout);\n            }\n        }\n    }\n\n    tv.tv_sec  = (time_t)redis_sock->timeout;\n    tv.tv_usec = (int)((redis_sock->timeout - tv.tv_sec) * 1000000);\n    if (tv.tv_sec != 0 || tv.tv_usec != 0) {\n        tv_ptr = &tv;\n    }\n\n    redis_sock->stream = php_stream_xport_create(host, host_len,\n        0, STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT,\n        persistent_id ? ZSTR_VAL(persistent_id) : NULL,\n        tv_ptr, redis_sock->stream_ctx, &estr, &err);\n\n    if (persistent_id) {\n        zend_string_release(persistent_id);\n    }\n\n    if (!redis_sock->stream) {\n        if (estr) {\n            redis_sock_set_err(redis_sock, ZSTR_VAL(estr), ZSTR_LEN(estr));\n            zend_string_release(estr);\n        }\n        return FAILURE;\n    }\n\n    if (p) p->nb_active++;\n\n    /* Attempt to set TCP_NODELAY/TCP_KEEPALIVE if we're not using a unix socket. */\n    if (!usocket) {\n        php_netstream_data_t *sock = (php_netstream_data_t*)redis_sock->stream->abstract;\n        err = setsockopt(sock->socket, IPPROTO_TCP, TCP_NODELAY, (char*) &tcp_flag, sizeof(tcp_flag));\n        PHPREDIS_NOTUSED(err);\n        err = setsockopt(sock->socket, SOL_SOCKET, SO_KEEPALIVE, (char*) &redis_sock->tcp_keepalive, sizeof(redis_sock->tcp_keepalive));\n        PHPREDIS_NOTUSED(err);\n    }\n\n    php_stream_auto_cleanup(redis_sock->stream);\n\n    read_tv.tv_sec  = (time_t)redis_sock->read_timeout;\n    read_tv.tv_usec = (int)((redis_sock->read_timeout - read_tv.tv_sec) * 1000000);\n\n    if (read_tv.tv_sec != 0 || read_tv.tv_usec != 0) {\n        php_stream_set_option(redis_sock->stream,PHP_STREAM_OPTION_READ_TIMEOUT,\n            0, &read_tv);\n    }\n    php_stream_set_option(redis_sock->stream,\n        PHP_STREAM_OPTION_WRITE_BUFFER, PHP_STREAM_BUFFER_NONE, NULL);\n\n    redis_sock->status = REDIS_SOCK_STATUS_CONNECTED;\n\n    return SUCCESS;\n}\n\n/**\n * redis_sock_server_open\n */\nPHP_REDIS_API int\nredis_sock_server_open(RedisSock *redis_sock)\n{\n    if (redis_sock) {\n        switch (redis_sock->status) {\n        case REDIS_SOCK_STATUS_DISCONNECTED:\n            if (redis_sock_connect(redis_sock) != SUCCESS) {\n                break;\n            }\n            redis_sock->status = REDIS_SOCK_STATUS_CONNECTED;\n            // fall through\n        case REDIS_SOCK_STATUS_CONNECTED:\n            if (redis_sock_auth(redis_sock) != SUCCESS) {\n                break;\n            }\n            redis_sock->status = REDIS_SOCK_STATUS_AUTHENTICATED;\n            // fall through\n        case REDIS_SOCK_STATUS_AUTHENTICATED:\n            if (redis_sock->dbNumber && reselect_db(redis_sock) != SUCCESS) {\n                break;\n            }\n            redis_sock->status = REDIS_SOCK_STATUS_READY;\n            // fall through\n        case REDIS_SOCK_STATUS_READY:\n            return SUCCESS;\n        default:\n            return FAILURE;\n        }\n    }\n    return FAILURE;\n}\n\n/**\n * redis_sock_disconnect\n */\nPHP_REDIS_API int\nredis_sock_disconnect(RedisSock *redis_sock, int force, int is_reset_mode)\n{\n    if (redis_sock == NULL) {\n        return FAILURE;\n    } else if (redis_sock->stream) {\n        if (redis_sock->persistent) {\n            ConnectionPool *p = NULL;\n            if (INI_INT(\"redis.pconnect.pooling_enabled\")) {\n                p = redis_sock_get_connection_pool(redis_sock);\n            }\n            if (force || !IS_ATOMIC(redis_sock)) {\n                php_stream_pclose(redis_sock->stream);\n                redis_free_reply_callbacks(redis_sock);\n                if (p) p->nb_active--;\n            } else if (p) {\n                zend_llist_prepend_element(&p->list, &redis_sock->stream);\n            }\n        } else {\n            php_stream_close(redis_sock->stream);\n        }\n        redis_sock->stream = NULL;\n    }\n    if (is_reset_mode) {\n        redis_sock->mode = ATOMIC;\n    }\n    redis_sock->status = REDIS_SOCK_STATUS_DISCONNECTED;\n    redis_sock->watching = 0;\n\n    return SUCCESS;\n}\n\n/**\n * redis_sock_set_err\n */\nPHP_REDIS_API void\nredis_sock_set_err(RedisSock *redis_sock, const char *msg, int msg_len)\n{\n    // Free our last error\n    if (redis_sock->err != NULL) {\n        zend_string_release(redis_sock->err);\n        redis_sock->err = NULL;\n    }\n\n    if (msg != NULL && msg_len > 0) {\n        // Copy in our new error message\n        redis_sock->err = zend_string_init(msg, msg_len, 0);\n    }\n}\n\nPHP_REDIS_API int\nredis_sock_set_stream_context(RedisSock *redis_sock, zval *options)\n{\n    zend_string *zkey;\n    zval *z_ele;\n\n    if (!redis_sock || Z_TYPE_P(options) != IS_ARRAY)\n        return FAILURE;\n\n    if (!redis_sock->stream_ctx)\n        redis_sock->stream_ctx = php_stream_context_alloc();\n\n    ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARRVAL_P(options), zkey, z_ele) {\n        if (zkey != NULL) {\n            php_stream_context_set_option(redis_sock->stream_ctx, \"ssl\", ZSTR_VAL(zkey), z_ele);\n        }\n    } ZEND_HASH_FOREACH_END();\n\n    return SUCCESS;\n}\n\nPHP_REDIS_API int\nredis_sock_set_backoff(RedisSock *redis_sock, zval *options)\n{\n    zend_string *zkey;\n    zend_long val;\n    zval *z_ele;\n\n    if (!redis_sock || Z_TYPE_P(options) != IS_ARRAY) {\n        return FAILURE;\n    }\n\n    ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARRVAL_P(options), zkey, z_ele) {\n        if (zkey != NULL) {\n            ZVAL_DEREF(z_ele);\n            if (zend_string_equals_literal_ci(zkey, \"algorithm\")) {\n                if ((val = zval_get_long(z_ele)) < 0 || val >= REDIS_BACKOFF_ALGORITHMS) {\n                    return FAILURE;\n                }\n                redis_sock->backoff.algorithm = val;\n            } else if (zend_string_equals_literal_ci(zkey, \"base\")) {\n                if ((val = zval_get_long(z_ele)) < 0) {\n                    return FAILURE;\n                }\n                redis_sock->backoff.base = val * 1000;\n            } else if (zend_string_equals_literal_ci(zkey, \"cap\")) {\n                if ((val = zval_get_long(z_ele)) < 0) {\n                    return FAILURE;\n                }\n                redis_sock->backoff.cap = val * 1000;\n            } else {\n                php_error_docref(NULL, E_WARNING, \"Skip unknown backoff option '%s'\", ZSTR_VAL(zkey));\n            }\n        }\n    } ZEND_HASH_FOREACH_END();\n\n    return SUCCESS;\n}\n\n/**\n * redis_sock_read_multibulk_reply\n */\nPHP_REDIS_API int redis_sock_read_multibulk_reply(INTERNAL_FUNCTION_PARAMETERS,\n                                           RedisSock *redis_sock, zval *z_tab,\n                                           void *ctx)\n{\n    zval z_multi_result;\n    int numElems;\n\n    if (read_mbulk_header(redis_sock, &numElems) < 0) {\n        if (IS_ATOMIC(redis_sock)) {\n            RETVAL_FALSE;\n        } else {\n            add_next_index_bool(z_tab, 0);\n        }\n        return FAILURE;\n    }\n    if (numElems == -1 && redis_sock->null_mbulk_as_null) {\n        ZVAL_NULL(&z_multi_result);\n    } else if (numElems < 1) {\n        ZVAL_EMPTY_ARRAY(&z_multi_result);\n    } else {\n        array_init_size(&z_multi_result, numElems);\n        redis_mbulk_reply_loop(redis_sock, &z_multi_result, numElems, UNSERIALIZE_ALL);\n    }\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&z_multi_result, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &z_multi_result);\n    }\n\n    return 0;\n}\n\n/* Like multibulk reply, but don't touch the values, they won't be unserialized\n * (this is used by HKEYS). */\nPHP_REDIS_API int\nredis_mbulk_reply_raw(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    int numElems;\n\n    if (read_mbulk_header(redis_sock, &numElems) < 0) {\n        if (IS_ATOMIC(redis_sock)) {\n            RETVAL_FALSE;\n        } else {\n            add_next_index_bool(z_tab, 0);\n        }\n        return FAILURE;\n    }\n    zval z_multi_result;\n\n    if (numElems < 1) {\n        ZVAL_EMPTY_ARRAY(&z_multi_result);\n    } else {\n        array_init_size(&z_multi_result, numElems); /* pre-allocate array for multi's results. */\n        redis_mbulk_reply_loop(redis_sock, &z_multi_result, numElems, UNSERIALIZE_NONE);\n    }\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&z_multi_result, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &z_multi_result);\n    }\n\n    return SUCCESS;\n}\n\nPHP_REDIS_API int\nredis_mbulk_reply_double(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    char *line;\n    int i, numElems, len;\n    zval z_multi_result;\n\n    if (read_mbulk_header(redis_sock, &numElems) < 0) {\n        if (IS_ATOMIC(redis_sock)) {\n            RETVAL_FALSE;\n        } else {\n            add_next_index_bool(z_tab, 0);\n        }\n        return FAILURE;\n    }\n\n    if (numElems < 1) {\n        ZVAL_EMPTY_ARRAY(&z_multi_result);\n    } else {\n        array_init_size(&z_multi_result, numElems);\n        for (i = 0; i < numElems; ++i) {\n            if ((line = redis_sock_read(redis_sock, &len)) == NULL) {\n                add_next_index_bool(&z_multi_result, 0);\n                continue;\n            }\n            add_next_index_double(&z_multi_result, atof(line));\n            efree(line);\n        }\n    }\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&z_multi_result, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &z_multi_result);\n    }\n\n    return SUCCESS;\n}\n\nPHP_REDIS_API void\nredis_mbulk_reply_loop(RedisSock *redis_sock, zval *z_tab, int count,\n                       int unserialize)\n{\n    zval z_unpacked;\n    char *line;\n    int i, len;\n\n    for (i = 0; i < count; ++i) {\n        if ((line = redis_sock_read(redis_sock, &len)) == NULL) {\n            add_next_index_bool(z_tab, 0);\n            continue;\n        }\n\n        /* We will attempt unserialization, if we're unserializing everything,\n         * or if we're unserializing keys and we're on a key, or we're\n         * unserializing values and we're on a value! */\n        int unwrap = (\n            (unserialize == UNSERIALIZE_ALL) ||\n            (unserialize == UNSERIALIZE_KEYS && i % 2 == 0) ||\n            (unserialize == UNSERIALIZE_VALS && i % 2 != 0)\n        );\n\n        if (unwrap && redis_unpack(redis_sock, line, len, &z_unpacked)) {\n            add_next_index_zval(z_tab, &z_unpacked);\n        } else {\n            redis_add_next_index_stringl(z_tab, line, len);\n        }\n        efree(line);\n    }\n}\n\nstatic int\nredis_mbulk_reply_zipped_raw_variant(RedisSock *redis_sock, zval *zret, int count) {\n    REDIS_REPLY_TYPE type;\n    char *key, *val;\n    int keylen, i;\n    zend_long lval;\n    double dval;\n    long vallen;\n\n    for (i = 0; i < count; i+= 2) {\n        /* Keys should always be bulk strings */\n        if ((key = redis_sock_read(redis_sock, &keylen)) == NULL)\n            return FAILURE;\n\n        /* This can vary */\n        if (redis_read_reply_type(redis_sock, &type, &vallen) < 0) {\n            efree(key);\n            return FAILURE;\n        }\n\n        if (type == TYPE_BULK) {\n            if (vallen > INT_MAX || (val = redis_sock_read_bulk_reply(redis_sock, (int)vallen)) == NULL) {\n                efree(key);\n                return FAILURE;\n            }\n\n            /* Possibly overkill, but provides really nice types */\n            switch (is_numeric_string(val, vallen, &lval, &dval, 0)) {\n                case IS_LONG:\n                    add_assoc_long_ex(zret, key, keylen, lval);\n                    break;\n                case IS_DOUBLE:\n                    add_assoc_double_ex(zret, key, keylen, dval);\n                    break;\n                default:\n                    add_assoc_stringl_ex(zret, key, keylen, val, vallen);\n            }\n\n            efree(val);\n        } else if (type == TYPE_INT) {\n            add_assoc_long_ex(zret, key, keylen, (zend_long)vallen);\n        } else {\n            add_assoc_null_ex(zret, key, keylen);\n        }\n\n        efree(key);\n    }\n\n    return SUCCESS;\n}\n\n/* Specialized multibulk processing for HMGET where we need to pair requested\n * keys with their returned values */\nPHP_REDIS_API int redis_mbulk_reply_assoc(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    char *response;\n    int response_len, retval;\n    int i, numElems;\n\n    zval *z_keys = ctx;\n\n    if (read_mbulk_header(redis_sock, &numElems) < 0) {\n        if (IS_ATOMIC(redis_sock)) {\n            RETVAL_FALSE;\n        } else {\n            add_next_index_bool(z_tab, 0);\n        }\n        retval = FAILURE;\n        goto end;\n    }\n\n    zval z_multi_result;\n    array_init_size(&z_multi_result, numElems); /* pre-allocate array for multi's results. */\n\n    for(i = 0; i < numElems; ++i) {\n        zend_string *tmp_str;\n        zend_string *zstr = zval_get_tmp_string(&z_keys[i], &tmp_str);\n        response = redis_sock_read(redis_sock, &response_len);\n        zval z_unpacked;\n        if (response != NULL) {\n            if (!redis_unpack(redis_sock, response, response_len, &z_unpacked)) {\n                ZVAL_STRINGL(&z_unpacked, response, response_len);\n            }\n            efree(response);\n        } else {\n            ZVAL_FALSE(&z_unpacked);\n        }\n        zend_symtable_update(Z_ARRVAL(z_multi_result), zstr, &z_unpacked);\n        zend_tmp_string_release(tmp_str);\n    }\n\n    if (IS_ATOMIC(redis_sock)) {\n        RETVAL_ZVAL(&z_multi_result, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &z_multi_result);\n    }\n\n    retval = SUCCESS;\n\nend:\n    // Cleanup z_keys\n    for (i = 0; Z_TYPE(z_keys[i]) != IS_NULL; ++i) {\n        zval_dtor(&z_keys[i]);\n    }\n    efree(z_keys);\n\n    return retval;\n}\n\n/**\n * redis_sock_write\n */\nPHP_REDIS_API int\nredis_sock_write(RedisSock *redis_sock, char *cmd, size_t sz)\n{\n    if (redis_check_eof(redis_sock, 0, 0) == 0 &&\n        redis_sock_write_raw(redis_sock, cmd, sz) == sz)\n    {\n        return sz;\n    }\n\n    return -1;\n}\n\n/* Grow array to double size if we need more space */\nfold_item*\nredis_add_reply_callback(RedisSock *redis_sock) {\n    if (UNEXPECTED(redis_sock->reply_callback_count == redis_sock->reply_callback_capacity)) {\n        if (redis_sock->reply_callback_capacity == 0) {\n            redis_sock->reply_callback_capacity = REDIS_CALLBACKS_INIT_SIZE;\n        } else if (redis_sock->reply_callback_capacity < REDIS_CALLBACKS_MAX_DOUBLE) {\n            redis_sock->reply_callback_capacity *= 2;\n        } else {\n            redis_sock->reply_callback_capacity += REDIS_CALLBACKS_ADD_SIZE;\n        }\n        redis_sock->reply_callback = erealloc(redis_sock->reply_callback, redis_sock->reply_callback_capacity * sizeof(fold_item));\n    }\n    return &redis_sock->reply_callback[redis_sock->reply_callback_count++];\n}\n\nvoid\nredis_free_reply_callbacks(RedisSock *redis_sock)\n{\n    if (redis_sock->reply_callback != NULL) {\n        efree(redis_sock->reply_callback);\n        redis_sock->reply_callback = NULL;\n        redis_sock->reply_callback_count = 0;\n        redis_sock->reply_callback_capacity = 0;\n    }\n}\n\n/**\n * redis_free_socket\n */\nPHP_REDIS_API void redis_free_socket(RedisSock *redis_sock)\n{\n    int i;\n\n    if (redis_sock->prefix) {\n        zend_string_release(redis_sock->prefix);\n    }\n    smart_string_free(&redis_sock->pipeline_cmd);\n    if (redis_sock->err) {\n        zend_string_release(redis_sock->err);\n    }\n    if (redis_sock->persistent_id) {\n        zend_string_release(redis_sock->persistent_id);\n    }\n    if (redis_sock->host) {\n        zend_string_release(redis_sock->host);\n    }\n    for (i = 0; i < REDIS_SUBS_BUCKETS; ++i) {\n        if (redis_sock->subs[i]) {\n            zend_hash_destroy(redis_sock->subs[i]);\n            efree(redis_sock->subs[i]);\n            redis_sock->subs[i] = NULL;\n        }\n    }\n    redis_sock_free_auth(redis_sock);\n    redis_free_reply_callbacks(redis_sock);\n    efree(redis_sock);\n}\n\n#ifdef HAVE_REDIS_LZ4\n/* Implementation of CRC8 for our LZ4 checksum value */\nstatic uint8_t crc8(unsigned char *input, size_t len) {\n    size_t i;\n    uint8_t crc = 0xFF;\n\n    while (len--) {\n        crc ^= *input++;\n        for (i = 0; i < 8; i++) {\n            if (crc & 0x80)\n                crc = (uint8_t)(crc << 1) ^ 0x31;\n            else\n                crc <<= 1;\n        }\n    }\n\n    return crc;\n}\n#endif\n\nPHP_REDIS_API int\nredis_compress(RedisSock *redis_sock, char **dst, size_t *dstlen, char *buf, size_t len) {\n    switch (redis_sock->compression) {\n        case REDIS_COMPRESSION_LZF:\n#ifdef HAVE_REDIS_LZF\n            {\n                char *data;\n                uint32_t res;\n                double size;\n\n                /* preserve compatibility with PECL lzf_compress margin (greater of 4% and LZF_MARGIN) */\n                size = len + MIN(UINT_MAX - len, MAX(LZF_MARGIN, len / 25));\n                data = emalloc(size);\n                if ((res = lzf_compress(buf, len, data, size)) > 0) {\n                    *dst = data;\n                    *dstlen = res;\n                    return 1;\n                }\n                efree(data);\n            }\n#endif\n            break;\n        case REDIS_COMPRESSION_ZSTD:\n#ifdef HAVE_REDIS_ZSTD\n            {\n                char *data;\n                size_t size;\n                int level;\n\n                if (redis_sock->compression_level < 1) {\n#ifdef ZSTD_CLEVEL_DEFAULT\n                    level = ZSTD_CLEVEL_DEFAULT;\n#else\n                    level = 3;\n#endif\n                } else if (redis_sock->compression_level > ZSTD_maxCLevel()) {\n                    level = ZSTD_maxCLevel();\n                } else {\n                    level = redis_sock->compression_level;\n                }\n\n                size = ZSTD_compressBound(len);\n                data = emalloc(size);\n                size = ZSTD_compress(data, size, buf, len, level);\n                if (!ZSTD_isError(size)) {\n                    *dst = erealloc(data, size);\n                    *dstlen = size;\n                    return 1;\n                }\n                efree(data);\n            }\n#endif\n            break;\n        case REDIS_COMPRESSION_LZ4:\n#ifdef HAVE_REDIS_LZ4\n            {\n                /* Compressing empty data is pointless */\n                if (len < 1)\n                    break;\n\n                /* Compressing more than INT_MAX bytes would require multiple blocks */\n                if (len > INT_MAX) {\n                    php_error_docref(NULL, E_WARNING,\n                        \"LZ4: compressing > %d bytes not supported\", INT_MAX);\n                    break;\n                }\n\n                int old_len = len, lz4len, lz4bound;\n                uint8_t crc = crc8((unsigned char*)&old_len, sizeof(old_len));\n                char *lz4buf, *lz4pos;\n\n                lz4bound = LZ4_compressBound(len);\n                lz4buf = emalloc(REDIS_LZ4_HDR_SIZE + lz4bound);\n                lz4pos = lz4buf;\n\n                /* Copy and move past crc8 length checksum */\n                memcpy(lz4pos, &crc, sizeof(crc));\n                lz4pos += sizeof(crc);\n\n                /* Copy and advance past length */\n                memcpy(lz4pos, &old_len, sizeof(old_len));\n                lz4pos += sizeof(old_len);\n\n                if (redis_sock->compression_level <= 0 || redis_sock->compression_level > REDIS_LZ4_MAX_CLEVEL) {\n                    lz4len = LZ4_compress_default(buf, lz4pos, old_len, lz4bound);\n                } else {\n                    lz4len = LZ4_compress_HC(buf, lz4pos, old_len, lz4bound, redis_sock->compression_level);\n                }\n\n                if (lz4len <= 0) {\n                    efree(lz4buf);\n                    break;\n                }\n\n                *dst = lz4buf;\n                *dstlen = lz4len + REDIS_LZ4_HDR_SIZE;\n                return 1;\n            }\n#endif\n            break;\n    }\n\n    *dst = buf;\n    *dstlen = len;\n    return 0;\n}\n\nPHP_REDIS_API int\nredis_uncompress(RedisSock *redis_sock, char **dst, size_t *dstlen, const char *src, size_t len) {\n    switch (redis_sock->compression) {\n        case REDIS_COMPRESSION_LZF:\n#ifdef HAVE_REDIS_LZF\n            {\n                char *data = NULL;\n                uint32_t res;\n                int i;\n\n                if (len == 0)\n                    break;\n\n                /* Grow our buffer until we succeed or get a non E2BIG error */\n                errno = E2BIG;\n                for (i = 2; errno == E2BIG; i *= 2) {\n                    data = erealloc(data, len * i);\n                    if ((res = lzf_decompress(src, len, data, len * i)) > 0) {\n                        *dst = data;\n                        *dstlen = res;\n                        return 1;\n                    }\n                }\n\n                efree(data);\n                break;\n            }\n#endif\n            break;\n        case REDIS_COMPRESSION_ZSTD:\n#ifdef HAVE_REDIS_ZSTD\n            {\n                char *data;\n                unsigned long long zlen;\n\n                zlen = ZSTD_getFrameContentSize(src, len);\n                if (zlen == ZSTD_CONTENTSIZE_ERROR || zlen == ZSTD_CONTENTSIZE_UNKNOWN || zlen > INT_MAX)\n                    break;\n\n                data = emalloc(zlen);\n                *dstlen = ZSTD_decompress(data, zlen, src, len);\n                if (ZSTD_isError(*dstlen) || *dstlen != zlen) {\n                    efree(data);\n                    break;\n                }\n\n                *dst = data;\n                return 1;\n            }\n#endif\n            break;\n        case REDIS_COMPRESSION_LZ4:\n#ifdef HAVE_REDIS_LZ4\n            {\n                char *data;\n                int datalen;\n                uint8_t lz4crc;\n\n                /* We must have at least enough bytes for our header, and can't have more than\n                 * INT_MAX + our header size. */\n                if (len < REDIS_LZ4_HDR_SIZE || len > INT_MAX + REDIS_LZ4_HDR_SIZE)\n                    break;\n\n                /* Operate on copies in case our CRC fails */\n                const char *copy = src;\n                size_t copylen = len;\n\n                /* Read in our header bytes */\n                memcpy(&lz4crc, copy, sizeof(uint8_t));\n                copy += sizeof(uint8_t); copylen -= sizeof(uint8_t);\n                memcpy(&datalen, copy, sizeof(int));\n                copy += sizeof(int); copylen -= sizeof(int);\n\n                /* Make sure our CRC matches (TODO:  Maybe issue a docref error?) */\n                if (crc8((unsigned char*)&datalen, sizeof(datalen)) != lz4crc)\n                    break;\n\n                /* Finally attempt decompression */\n                data = emalloc(datalen);\n                if (LZ4_decompress_safe(copy, data, copylen, datalen) > 0) {\n                    *dst = data;\n                    *dstlen = datalen;\n                    return 1;\n                }\n\n                efree(data);\n            }\n#endif\n            break;\n    }\n\n    *dst = (char*)src;\n    *dstlen = len;\n    return 0;\n}\n\nPHP_REDIS_API int\nredis_pack(RedisSock *redis_sock, zval *z, char **val, size_t *val_len) {\n    size_t tmplen;\n    int tmpfree;\n    char *tmp;\n\n    /* First serialize */\n    tmpfree = redis_serialize(redis_sock, z, &tmp, &tmplen);\n\n    /* Now attempt compression */\n    if (redis_compress(redis_sock, val, val_len, tmp, tmplen)) {\n        if (tmpfree) efree(tmp);\n        return 1;\n    }\n\n    return tmpfree;\n}\n\nPHP_REDIS_API int\nredis_unpack(RedisSock *redis_sock, const char *src, int srclen, zval *zdst) {\n    size_t len;\n    char *buf;\n\n    /* Uncompress, then unserialize */\n    if (redis_uncompress(redis_sock, &buf, &len, src, srclen)) {\n        if (!redis_unserialize(redis_sock, buf, len, zdst)) {\n            ZVAL_STRINGL_FAST(zdst, buf, len);\n        }\n        efree(buf);\n        return 1;\n    }\n\n    return redis_unserialize(redis_sock, buf, len, zdst);\n}\n\nPHP_REDIS_API int\n\nredis_serialize(RedisSock *redis_sock, zval *z, char **val, size_t *val_len)\n{\n    php_serialize_data_t ht;\n\n    smart_str sstr = {0};\n#ifdef HAVE_REDIS_IGBINARY\n    size_t sz;\n    uint8_t *val8;\n#endif\n\n    *val = \"\";\n    *val_len = 0;\n    switch(redis_sock->serializer) {\n        case REDIS_SERIALIZER_NONE:\n            switch(Z_TYPE_P(z)) {\n                case IS_STRING:\n                    *val = Z_STRVAL_P(z);\n                    *val_len = Z_STRLEN_P(z);\n                    break;\n\n                case IS_OBJECT:\n                    *val = \"Object\";\n                    *val_len = 6;\n                    break;\n\n                case IS_ARRAY:\n                    *val = \"Array\";\n                    *val_len = 5;\n                    break;\n\n                default: { /* copy */\n                    zend_string *zstr = zval_get_string_func(z);\n                    if (ZSTR_IS_INTERNED(zstr)) { // do not reallocate interned strings\n                        *val = ZSTR_VAL(zstr);\n                        *val_len = ZSTR_LEN(zstr);\n                        return 0;\n                    }\n                    *val = estrndup(ZSTR_VAL(zstr), ZSTR_LEN(zstr));\n                    *val_len = ZSTR_LEN(zstr);\n                    zend_string_efree(zstr);\n                    return 1;\n                }\n            }\n            break;\n        case REDIS_SERIALIZER_PHP:\n            PHP_VAR_SERIALIZE_INIT(ht);\n            php_var_serialize(&sstr, z, &ht);\n\n            *val = estrndup(ZSTR_VAL(sstr.s), ZSTR_LEN(sstr.s));\n            *val_len = ZSTR_LEN(sstr.s);\n\n            smart_str_free(&sstr);\n            PHP_VAR_SERIALIZE_DESTROY(ht);\n\n            return 1;\n\n        case REDIS_SERIALIZER_MSGPACK:\n#ifdef HAVE_REDIS_MSGPACK\n            php_msgpack_serialize(&sstr, z);\n            *val = estrndup(ZSTR_VAL(sstr.s), ZSTR_LEN(sstr.s));\n            *val_len = ZSTR_LEN(sstr.s);\n            smart_str_free(&sstr);\n\n            return 1;\n#endif\n            break;\n        case REDIS_SERIALIZER_IGBINARY:\n#ifdef HAVE_REDIS_IGBINARY\n            if(igbinary_serialize(&val8, (size_t *)&sz, z) == 0) {\n                *val = (char*)val8;\n                *val_len = sz;\n                return 1;\n            }\n#endif\n            break;\n        case REDIS_SERIALIZER_JSON:\n#ifdef HAVE_REDIS_JSON\n            php_json_encode(&sstr, z, PHP_JSON_OBJECT_AS_ARRAY);\n            *val = estrndup(ZSTR_VAL(sstr.s), ZSTR_LEN(sstr.s));\n            *val_len = ZSTR_LEN(sstr.s);\n            smart_str_free(&sstr);\n            return 1;\n#endif\n            break;\n        EMPTY_SWITCH_DEFAULT_CASE()\n    }\n\n    return 0;\n}\n\nPHP_REDIS_API int\nredis_unserialize(RedisSock* redis_sock, const char *val, int val_len,\n                  zval *z_ret)\n{\n\n    php_unserialize_data_t var_hash;\n    int ret = 0;\n\n    switch(redis_sock->serializer) {\n        case REDIS_SERIALIZER_NONE:\n            /* Nothing to do */\n            break;\n        case REDIS_SERIALIZER_PHP:\n            PHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n            ret = php_var_unserialize(z_ret, (const unsigned char **)&val,\n                                      (const unsigned char *)val + val_len,\n                                       &var_hash);\n\n            PHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n            break;\n\n        case REDIS_SERIALIZER_MSGPACK:\n#ifdef HAVE_REDIS_MSGPACK\n            ret = !php_msgpack_unserialize(z_ret, (char *)val, (size_t)val_len);\n#endif\n            break;\n\n        case REDIS_SERIALIZER_IGBINARY:\n#ifdef HAVE_REDIS_IGBINARY\n            /*\n             * Check if the given string starts with an igbinary header.\n             *\n             * A modern igbinary string consists of the following format:\n             *\n             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n             * | header (4) | type (1) | ... (n) |  NUL (1) |\n             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n             *\n             * With header being three zero bytes and one non-zero version\n             * specifier.  At the time of this comment, there is only version\n             * 0x01 and 0x02, but newer versions will use subsequent\n             * values.\n             *\n             * Not all versions contain a trailing \\x00 so don't check for that.\n             */\n            if (val_len < 5 || memcmp(val, \"\\x00\\x00\\x00\", 3) || val[3] < '\\x01' || val[3] > '\\x04')\n            {\n                /* This is most definitely not an igbinary string, so do\n                   not try to unserialize this as one. */\n                break;\n            }\n\n            ret = !igbinary_unserialize((const uint8_t *)val, (size_t)val_len, z_ret);\n#endif\n            break;\n        case REDIS_SERIALIZER_JSON:\n#ifdef HAVE_REDIS_JSON\n    #if (PHP_MAJOR_VERSION == 7 && PHP_MINOR_VERSION < 1)\n            JSON_G(error_code) = PHP_JSON_ERROR_NONE;\n            php_json_decode(z_ret, (char*)val, val_len, 1, PHP_JSON_PARSER_DEFAULT_DEPTH);\n            ret = JSON_G(error_code) == PHP_JSON_ERROR_NONE;\n    #else\n            ret = !php_json_decode(z_ret, (char *)val, val_len, 1, PHP_JSON_PARSER_DEFAULT_DEPTH);\n    #endif\n#endif\n            break;\n        EMPTY_SWITCH_DEFAULT_CASE()\n    }\n\n    return ret;\n}\n\nPHP_REDIS_API int\nredis_key_prefix(RedisSock *redis_sock, char **key, size_t *key_len) {\n    int ret_len;\n    char *ret;\n\n    if (redis_sock->prefix == NULL) {\n        return 0;\n    }\n\n    ret_len = ZSTR_LEN(redis_sock->prefix) + *key_len;\n    ret = ecalloc(1 + ret_len, 1);\n    memcpy(ret, ZSTR_VAL(redis_sock->prefix), ZSTR_LEN(redis_sock->prefix));\n    memcpy(ret + ZSTR_LEN(redis_sock->prefix), *key, *key_len);\n\n    *key = ret;\n    *key_len = ret_len;\n    return 1;\n}\n\n/* This is very similar to PHP >= 7.4 zend_string_concat2 only we are taking\n * two zend_string arguments rather than two char*, size_t pairs */\nstatic zend_string *redis_zstr_concat(zend_string *prefix, zend_string *suffix) {\n    zend_string *res;\n    size_t len;\n\n    ZEND_ASSERT(prefix != NULL && suffix != NULL);\n\n    len = ZSTR_LEN(prefix) + ZSTR_LEN(suffix);\n    res = zend_string_alloc(len, 0);\n\n    memcpy(ZSTR_VAL(res), ZSTR_VAL(prefix), ZSTR_LEN(prefix));\n    memcpy(ZSTR_VAL(res) + ZSTR_LEN(prefix), ZSTR_VAL(suffix), ZSTR_LEN(suffix));\n    ZSTR_VAL(res)[len] = '\\0';\n\n    return res;\n}\n\nPHP_REDIS_API zend_string *\nredis_key_prefix_zval(RedisSock *redis_sock, zval *zv) {\n    zend_string *zstr, *dup;\n\n    zstr = zval_get_string(zv);\n    if (redis_sock->prefix == NULL)\n        return zstr;\n\n    dup = redis_zstr_concat(redis_sock->prefix, zstr);\n\n    zend_string_release(zstr);\n\n    return dup;\n}\n\nPHP_REDIS_API zend_string *\nredis_key_prefix_zstr(RedisSock *redis_sock, zend_string *key) {\n    if (redis_sock->prefix == NULL)\n        return zend_string_copy(key);\n\n    return redis_zstr_concat(redis_sock->prefix, key);\n}\n\n/*\n * Processing for variant reply types (think EVAL)\n */\n\nPHP_REDIS_API int\nredis_sock_gets(RedisSock *redis_sock, char *buf, int buf_size, size_t *line_size) {\n    // Handle EOF\n    if(-1 == redis_check_eof(redis_sock, 1, 0)) {\n        return -1;\n    }\n\n    if(redis_sock_get_line(redis_sock, buf, buf_size, line_size) == NULL) {\n        if (redis_sock->port < 0) {\n            snprintf(buf, buf_size, \"read error on connection to %s\", ZSTR_VAL(redis_sock->host));\n        } else {\n            snprintf(buf, buf_size, \"read error on connection to %s:%d\", ZSTR_VAL(redis_sock->host), redis_sock->port);\n        }\n        // Close our socket\n        redis_sock_disconnect(redis_sock, 1, 1);\n\n        // Throw a read error exception\n        REDIS_THROW_EXCEPTION(buf, 0);\n        return FAILURE;\n    }\n\n    /* We don't need \\r\\n */\n    *line_size-=2;\n    buf[*line_size]='\\0';\n\n    /* Success! */\n    return 0;\n}\n\nPHP_REDIS_API int\nredis_read_reply_type(RedisSock *redis_sock, REDIS_REPLY_TYPE *reply_type,\n                      long *reply_info)\n{\n    size_t nread;\n\n    // Make sure we haven't lost the connection, even trying to reconnect\n    if(-1 == redis_check_eof(redis_sock, 1, 0)) {\n        // Failure\n        *reply_type = EOF;\n        return -1;\n    }\n\n    // Attempt to read the reply-type byte\n    if((*reply_type = redis_sock_getc(redis_sock)) == EOF) {\n        REDIS_THROW_EXCEPTION( \"socket error on read socket\", 0);\n        return -1;\n    }\n\n    // If this is a BULK, MULTI BULK, or simply an INTEGER response, we can\n    // extract the value or size info here\n    if(*reply_type == TYPE_INT || *reply_type == TYPE_BULK ||\n       *reply_type == TYPE_MULTIBULK)\n    {\n        // Buffer to hold size information\n        char inbuf[255];\n\n        /* Read up to our newline */\n        if (redis_sock_get_line(redis_sock, inbuf, sizeof(inbuf), &nread) == NULL) {\n            return -1;\n        }\n\n        /* Set our size response */\n        *reply_info = atol(inbuf);\n    }\n\n    /* Success! */\n    return 0;\n}\n\n/*\n * Read a single line response, having already consumed the reply-type byte\n */\nstatic int\nredis_read_variant_line(RedisSock *redis_sock, REDIS_REPLY_TYPE reply_type,\n                        int as_string, zval *z_ret)\n{\n    // Buffer to read our single line reply\n    char inbuf[4096];\n    size_t len;\n\n    /* Attempt to read our single line reply */\n    if(redis_sock_gets(redis_sock, inbuf, sizeof(inbuf), &len) < 0) {\n        return -1;\n    }\n\n    /* Throw exception on SYNC error otherwise just set error string */\n    if(reply_type == TYPE_ERR) {\n        redis_sock_set_err(redis_sock, inbuf, len);\n        redis_error_throw(redis_sock);\n        ZVAL_FALSE(z_ret);\n    } else if (as_string) {\n        ZVAL_STRINGL(z_ret, inbuf, len);\n    } else {\n        ZVAL_TRUE(z_ret);\n    }\n\n    return 0;\n}\n\nPHP_REDIS_API int\nredis_read_variant_bulk(RedisSock *redis_sock, int size, zval *z_ret\n                       )\n{\n    // Attempt to read the bulk reply\n    char *bulk_resp = redis_sock_read_bulk_reply(redis_sock, size);\n\n    /* Set our reply to FALSE on failure, and the string on success */\n    if(bulk_resp == NULL) {\n        ZVAL_FALSE(z_ret);\n        return -1;\n    }\n    ZVAL_STRINGL(z_ret, bulk_resp, size);\n    efree(bulk_resp);\n    return 0;\n}\n\nPHP_REDIS_API int\nredis_read_multibulk_recursive(RedisSock *redis_sock, long long elements, int status_strings,\n                               zval *z_ret)\n{\n    long reply_info;\n    REDIS_REPLY_TYPE reply_type;\n    zval z_subelem;\n\n    // Iterate while we have elements\n    while(elements > 0) {\n        // Attempt to read our reply type\n        if(redis_read_reply_type(redis_sock, &reply_type, &reply_info\n                                ) < 0)\n        {\n            zend_throw_exception_ex(redis_exception_ce, 0,\n                \"protocol error, couldn't parse MULTI-BULK response\\n\");\n            return FAILURE;\n        }\n\n        // Switch on our reply-type byte\n        switch(reply_type) {\n            case TYPE_ERR:\n            case TYPE_LINE:\n                redis_read_variant_line(redis_sock, reply_type, status_strings,\n                                        &z_subelem);\n                add_next_index_zval(z_ret, &z_subelem);\n                break;\n            case TYPE_INT:\n                // Add our long value\n                add_next_index_long(z_ret, reply_info);\n                break;\n            case TYPE_BULK:\n                // Init a zval for our bulk response, read and add it\n                redis_read_variant_bulk(redis_sock, reply_info, &z_subelem);\n                add_next_index_zval(z_ret, &z_subelem);\n                break;\n            case TYPE_MULTIBULK:\n                if (reply_info < 0 && redis_sock->null_mbulk_as_null) {\n                    add_next_index_null(z_ret);\n                } else {\n                    array_init(&z_subelem);\n                    if (reply_info > 0) {\n                        redis_read_multibulk_recursive(redis_sock, reply_info, status_strings, &z_subelem);\n                    }\n                    add_next_index_zval(z_ret, &z_subelem);\n                }\n                break;\n            default:\n                // Stop the compiler from whinging\n                break;\n        }\n\n        /* Decrement our element counter */\n        elements--;\n    }\n\n    return 0;\n}\n\nstatic int\nvariant_reply_generic(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      int status_strings, int null_mbulk_as_null,\n                      zval *z_tab, void *ctx)\n{\n    // Reply type, and reply size vars\n    REDIS_REPLY_TYPE reply_type;\n    long reply_info;\n    zval z_ret;\n\n    // Attempt to read our header\n    if(redis_read_reply_type(redis_sock,&reply_type,&reply_info) < 0) {\n        return -1;\n    }\n\n    /* Switch based on our top level reply type */\n    switch(reply_type) {\n        case TYPE_ERR:\n        case TYPE_LINE:\n            redis_read_variant_line(redis_sock, reply_type, status_strings, &z_ret);\n            break;\n        case TYPE_INT:\n            ZVAL_LONG(&z_ret, reply_info);\n            break;\n        case TYPE_BULK:\n            redis_read_variant_bulk(redis_sock, reply_info, &z_ret);\n            break;\n        case TYPE_MULTIBULK:\n            if (reply_info > -1) {\n                array_init(&z_ret);\n                redis_read_multibulk_recursive(redis_sock, reply_info, status_strings, &z_ret);\n            } else {\n                if (null_mbulk_as_null) {\n                    ZVAL_NULL(&z_ret);\n                } else {\n                    array_init(&z_ret);\n                }\n            }\n            break;\n        default:\n            zend_throw_exception_ex(redis_exception_ce, 0,\n                \"protocol error, got '%c' as reply-type byte\\n\", reply_type);\n            return FAILURE;\n    }\n\n    if (IS_ATOMIC(redis_sock)) {\n        /* Set our return value */\n        RETVAL_ZVAL(&z_ret, 0, 1);\n    } else {\n        add_next_index_zval(z_tab, &z_ret);\n    }\n\n    /* Success */\n    return 0;\n}\n\nPHP_REDIS_API int\nredis_read_raw_variant_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                             zval *z_tab, void *ctx)\n{\n    return variant_reply_generic(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock,\n                                 redis_sock->reply_literal,\n                                 redis_sock->null_mbulk_as_null,\n                                 z_tab, ctx);\n}\n\nPHP_REDIS_API int\nredis_read_variant_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                         zval *z_tab, void *ctx)\n{\n    return variant_reply_generic(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, 0,\n                                 redis_sock->null_mbulk_as_null, z_tab, ctx);\n}\n\nPHP_REDIS_API int\nredis_read_variant_reply_strings(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                                 zval *z_tab, void *ctx)\n{\n    return variant_reply_generic(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, 1, 0, z_tab, ctx);\n}\n\n/* The user may wish to send us something like [NULL, 'password'] or\n * [false, 'password'] so don't convert NULL or FALSE into \"\". */\nstatic int redisTrySetAuthArg(zend_string **dst, zval *zsrc) {\n    if (Z_TYPE_P(zsrc) == IS_NULL || Z_TYPE_P(zsrc) == IS_FALSE)\n        return FAILURE;\n\n    *dst = zval_get_string(zsrc);\n\n    return SUCCESS;\n}\n\nPHP_REDIS_API\nint redis_extract_auth_info(zval *ztest, zend_string **user, zend_string **pass) {\n    zval *zv;\n    HashTable *ht;\n    int num;\n\n    /* Null out user and password */\n    *user = *pass = NULL;\n\n    /* User passed nothing */\n    if (ztest == NULL)\n        return FAILURE;\n\n    /* Handle a non-array first */\n    if (Z_TYPE_P(ztest) != IS_ARRAY) {\n        return redisTrySetAuthArg(pass, ztest);\n    }\n\n    /* Handle the array case */\n    ht = Z_ARRVAL_P(ztest);\n    num = zend_hash_num_elements(ht);\n\n    /* Something other than one or two entries makes no sense */\n    if (num != 1 && num != 2) {\n        php_error_docref(NULL, E_WARNING, \"When passing an array as auth it must have one or two elements!\");\n        return FAILURE;\n    }\n\n    if (num == 2) {\n        if ((zv = REDIS_HASH_STR_FIND_STATIC(ht, \"user\")) ||\n            (zv = zend_hash_index_find(ht, 0)))\n        {\n            redisTrySetAuthArg(user, zv);\n        }\n\n        if ((zv = REDIS_HASH_STR_FIND_STATIC(ht, \"pass\")) ||\n            (zv = zend_hash_index_find(ht, 1)))\n        {\n            redisTrySetAuthArg(pass, zv);\n        }\n    } else if ((zv = REDIS_HASH_STR_FIND_STATIC(ht, \"pass\")) ||\n               (zv = zend_hash_index_find(ht, 0)))\n    {\n        redisTrySetAuthArg(pass, zv);\n    }\n\n    /* If we at least have a password, we're good */\n    if (*pass != NULL)\n        return SUCCESS;\n\n    /* Failure, clean everything up so caller doesn't need to care */\n    if (*user) zend_string_release(*user);\n    *user = NULL;\n\n    return FAILURE;\n}\n\n/* Helper methods to extract configuration settings from a hash table */\n\nzval *redis_hash_str_find_type(HashTable *ht, const char *key, int keylen, int type) {\n    zval *zv = zend_hash_str_find(ht, key, keylen);\n    if (zv == NULL || Z_TYPE_P(zv) != type)\n        return NULL;\n\n    return zv;\n}\n\nvoid redis_conf_double(HashTable *ht, const char *key, int keylen, double *dval) {\n    zval *zv = zend_hash_str_find(ht, key, keylen);\n    if (zv == NULL)\n        return;\n\n    *dval = zval_get_double(zv);\n}\n\nvoid redis_conf_bool(HashTable *ht, const char *key, int keylen, int *ival) {\n    zend_string *zstr = NULL;\n\n    redis_conf_string(ht, key, keylen, &zstr);\n    if (zstr == NULL)\n        return;\n\n    *ival = zend_string_equals_literal_ci(zstr, \"true\") ||\n            zend_string_equals_literal_ci(zstr, \"yes\") ||\n            zend_string_equals_literal_ci(zstr, \"1\");\n\n    zend_string_release(zstr);\n}\n\nvoid redis_conf_zend_bool(HashTable *ht, const char *key, int keylen, zend_bool *bval) {\n    zval *zv = zend_hash_str_find(ht, key, keylen);\n    if (zv == NULL)\n        return;\n\n    *bval = zend_is_true(zv);\n}\n\nvoid redis_conf_long(HashTable *ht, const char *key, int keylen, zend_long *lval) {\n    zval *zv = zend_hash_str_find(ht, key, keylen);\n    if (zv == NULL)\n        return;\n\n    *lval = zval_get_long(zv);\n}\n\nvoid redis_conf_int(HashTable *ht, const char *key, int keylen, int *ival) {\n    zval *zv = zend_hash_str_find(ht, key, keylen);\n    if (zv == NULL)\n        return;\n\n    *ival = zval_get_long(zv);\n}\n\nvoid redis_conf_string(HashTable *ht, const char *key, size_t keylen,\n                       zend_string **sval)\n{\n    zval *zv = zend_hash_str_find(ht, key, keylen);\n    if (zv == NULL)\n        return;\n\n    *sval = zval_get_string(zv);\n}\n\nvoid redis_conf_zval(HashTable *ht, const char *key, size_t keylen, zval *zret,\n                     int copy, int dtor)\n{\n    zval *zv = zend_hash_str_find(ht, key, keylen);\n    if (zv == NULL)\n        return;\n\n    ZVAL_ZVAL(zret, zv, copy, dtor);\n}\n\nvoid redis_conf_auth(HashTable *ht, const char *key, size_t keylen,\n                     zend_string **user, zend_string **pass)\n{\n    zval *zv = zend_hash_str_find(ht, key, keylen);\n    if (zv == NULL)\n        return;\n\n    redis_extract_auth_info(zv, user, pass);\n}\n\n/* Update a zval with the current 64 bit scan cursor.  This presents a problem\n * because we can only represent up to 63 bits in a PHP integer.  So depending\n * on the cursor value, we may need to represent it as a string. */\nvoid redisSetScanCursor(zval *zv, uint64_t cursor) {\n    char tmp[21];\n    size_t len;\n\n    ZEND_ASSERT(zv != NULL && (Z_TYPE_P(zv) == IS_LONG ||\n                               Z_TYPE_P(zv) == IS_STRING));\n\n    if (Z_TYPE_P(zv) == IS_STRING)\n        zend_string_release(Z_STR_P(zv));\n\n    if (cursor > ZEND_LONG_MAX) {\n        len = snprintf(tmp, sizeof(tmp), \"%llu\", (unsigned long long)cursor);\n        ZVAL_STRINGL(zv, tmp, len);\n    } else {\n        ZVAL_LONG(zv, cursor);\n    }\n}\n\n/* Get a Redis SCAN cursor value out of a zval.  These are always taken as a\n * reference argument that that must be `null`, `int`, or `string`.  */\nuint64_t redisGetScanCursor(zval *zv, zend_bool *was_zero) {\n    ZEND_ASSERT(zv != NULL && (Z_TYPE_P(zv) == IS_LONG ||\n                               Z_TYPE_P(zv) == IS_STRING ||\n                               Z_TYPE_P(zv) == IS_NULL));\n\n    if (Z_TYPE_P(zv) == IS_NULL) {\n        convert_to_long(zv);\n        *was_zero = 0;\n        return 0;\n    } else if (Z_TYPE_P(zv) == IS_STRING) {\n        *was_zero = Z_STRLEN_P(zv) == 1 && Z_STRVAL_P(zv)[0] == '0';\n        return strtoull(Z_STRVAL_P(zv), NULL, 10);\n    } else {\n        *was_zero = Z_LVAL_P(zv) == 0;\n        return Z_LVAL_P(zv);\n    }\n}\n\n/* vim: set tabstop=4 softtabstop=4 expandtab shiftwidth=4: */\n"
        },
        {
          "name": "library.h",
          "type": "blob",
          "size": 16.4404296875,
          "content": "#ifndef REDIS_LIBRARY_H\n#define REDIS_LIBRARY_H\n\n/* Non cluster command helper */\n#define REDIS_SPPRINTF(ret, kw, fmt, ...) \\\n    redis_spprintf(redis_sock, NULL, ret, kw, fmt, ##__VA_ARGS__)\n\n#define REDIS_CMD_APPEND_SSTR_STATIC(sstr, str) \\\n    redis_cmd_append_sstr(sstr, str, sizeof(str)-1);\n\n#define REDIS_CMD_APPEND_SSTR_OPT_STATIC(sstr, opt, str) \\\n    if (opt) REDIS_CMD_APPEND_SSTR_STATIC(sstr, str);\n\n#define REDIS_CMD_INIT_SSTR_STATIC(sstr, argc, keyword) \\\n    redis_cmd_init_sstr(sstr, argc, keyword, sizeof(keyword)-1);\n\n#define REDIS_THROW_EXCEPTION(msg, code) \\\n    zend_throw_exception(redis_exception_ce, (msg), code)\n\n#define CLUSTER_THROW_EXCEPTION(msg, code) \\\n    zend_throw_exception(redis_cluster_exception_ce, (msg), code)\n\n#define redis_sock_write_sstr(redis_sock, sstr) \\\n    redis_sock_write(redis_sock, (sstr)->c, (sstr)->len)\n\n#if PHP_VERSION_ID < 80000\n    #define redis_hash_fetch_ops(zstr) php_hash_fetch_ops(ZSTR_VAL((zstr)), ZSTR_LEN((zstr)))\n\n    /* use RedisException when ValueError not available */\n    #define REDIS_VALUE_EXCEPTION(m) REDIS_THROW_EXCEPTION(m, 0)\n    #define RETURN_THROWS() RETURN_FALSE\n    /* ZVAL_STRINGL_FAST and RETVAL_STRINGL_FAST macros are supported since PHP 8 */\n    #define ZVAL_STRINGL_FAST(z, s, l) ZVAL_STRINGL(z, s, l)\n    #define RETVAL_STRINGL_FAST(s, l) RETVAL_STRINGL(s, l)\n#else\n    #define redis_hash_fetch_ops(zstr) php_hash_fetch_ops(zstr)\n\n    #define REDIS_VALUE_EXCEPTION(m) zend_value_error(m)\n#endif\n\n\nvoid redis_register_persistent_resource(zend_string *id, void *ptr, int le_id);\nfold_item* redis_add_reply_callback(RedisSock *redis_sock);\nvoid redis_free_reply_callbacks(RedisSock *redis_sock);\n\nPHP_REDIS_API int redis_extract_auth_info(zval *ztest, zend_string **user, zend_string **pass);\n\nint redis_cmd_init_sstr(smart_string *str, int num_args, char *keyword, int keyword_len);\nint redis_cmd_append_sstr(smart_string *str, char *append, int append_len);\nint redis_cmd_append_sstr_int(smart_string *str, int append);\nint redis_cmd_append_sstr_long(smart_string *str, long append);\nint redis_cmd_append_sstr_i64(smart_string *str, int64_t append);\nint redis_cmd_append_sstr_u64(smart_string *str, uint64_t append);\nint redis_cmd_append_sstr_dbl(smart_string *str, double value);\nint redis_cmd_append_sstr_zstr(smart_string *str, zend_string *zstr);\nint redis_cmd_append_sstr_zval(smart_string *str, zval *z, RedisSock *redis_sock);\nint redis_cmd_append_sstr_key(smart_string *str, char *key, size_t len, RedisSock *redis_sock, short *slot);\nint redis_cmd_append_sstr_key_zstr(smart_string *str, zend_string *key, RedisSock *redis_sock, short *slot);\nint redis_cmd_append_sstr_key_zval(smart_string *dst, zval *zv, RedisSock *redis_sock, short *slot);\nint redis_cmd_append_sstr_key_long(smart_string *dst, zend_long lval, RedisSock *redis_sock, short *slot);\nint redis_cmd_append_sstr_arrkey(smart_string *cmd, zend_string *kstr, zend_ulong idx);\n\nPHP_REDIS_API int redis_spprintf(RedisSock *redis_sock, short *slot, char **ret, char *kw, char *fmt, ...);\nPHP_REDIS_API zend_string *redis_pool_spprintf(RedisSock *redis_sock, char *fmt, ...);\n\nPHP_REDIS_API char *redis_sock_read(RedisSock *redis_sock, int *buf_len);\nPHP_REDIS_API int redis_sock_gets(RedisSock *redis_sock, char *buf, int buf_size, size_t* line_len);\nPHP_REDIS_API int redis_1_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_long_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval* z_tab, void *ctx);\ntypedef void (*SuccessCallback)(RedisSock *redis_sock);\nPHP_REDIS_API int redis_boolean_response_impl(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx, SuccessCallback success_callback);\nPHP_REDIS_API int redis_boolean_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_bulk_double_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_string_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_ping_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_info_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_config_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_zrange_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API void redis_parse_info_response(char *response, zval *z_ret);\nPHP_REDIS_API void redis_parse_client_list_response(char *response, zval *z_ret);\nPHP_REDIS_API int redis_type_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API RedisSock* redis_sock_create(char *host, int host_len, int port, double timeout, double read_timeout, int persistent, char *persistent_id, long retry_interval);\nPHP_REDIS_API int redis_sock_configure(RedisSock *redis_sock, HashTable *opts);\nPHP_REDIS_API int redis_sock_connect(RedisSock *redis_sock);\nPHP_REDIS_API int redis_sock_server_open(RedisSock *redis_sock);\nPHP_REDIS_API int redis_sock_auth(RedisSock *redis_sock);\nPHP_REDIS_API char *redis_sock_auth_cmd(RedisSock *redis_sock, int *cmdlen);\nPHP_REDIS_API void redis_sock_set_auth(RedisSock *redis_sock, zend_string *user, zend_string *pass);\nPHP_REDIS_API void redis_sock_set_auth_zval(RedisSock *redis_sock, zval *zv);\nPHP_REDIS_API void redis_sock_free_auth(RedisSock *redis_sock);\nPHP_REDIS_API int redis_sock_disconnect(RedisSock *redis_sock, int force, int is_reset_mode);\nPHP_REDIS_API zval *redis_sock_read_multibulk_reply_zval(RedisSock *redis_sock, zval *z_tab);\nPHP_REDIS_API int redis_sock_read_single_line(RedisSock *redis_sock, char *buffer,\n    size_t buflen, size_t *linelen, int set_err);\nPHP_REDIS_API char *redis_sock_read_bulk_reply(RedisSock *redis_sock, int bytes);\nPHP_REDIS_API int redis_sock_read_multibulk_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *_z_tab, void *ctx);\nPHP_REDIS_API void redis_mbulk_reply_loop(RedisSock *redis_sock, zval *z_tab, int count, int unserialize);\n\n\nPHP_REDIS_API int redis_mbulk_reply_raw(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_mbulk_reply_zipped_raw(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_mbulk_reply_zipped_vals(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_mbulk_reply_zipped_keys_int(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_mbulk_reply_zipped_keys_dbl(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_mbulk_reply_assoc(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_mbulk_reply_double(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\n\nvoid redisSetScanCursor(zval *zv, uint64_t cursor);\nuint64_t redisGetScanCursor(zval *zv, zend_bool *was_zero);\n\nPHP_REDIS_API int redis_sock_read_scan_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, REDIS_SCAN_TYPE type, uint64_t *cursor);\n\nPHP_REDIS_API int redis_xrange_reply(INTERNAL_FUNCTION_PARAMETERS,\n    RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_xread_reply(INTERNAL_FUNCTION_PARAMETERS,\n    RedisSock *redis_sock, zval *z_tab, void *ctx);\n\nPHP_REDIS_API int redis_xclaim_reply(INTERNAL_FUNCTION_PARAMETERS,\n    RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_read_xclaim_reply(\n    RedisSock *redis_sock, int count, int is_xautoclaim, zval *rv);\n\nPHP_REDIS_API int redis_xinfo_reply(INTERNAL_FUNCTION_PARAMETERS,\n    RedisSock *redis_sock, zval *z_tab, void *ctx);\n\nPHP_REDIS_API int redis_pubsub_response(INTERNAL_FUNCTION_PARAMETERS,\n    RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_subscribe_response(INTERNAL_FUNCTION_PARAMETERS,\n    RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_unsubscribe_response(INTERNAL_FUNCTION_PARAMETERS,\n    RedisSock *redis_sock, zval *z_tab, void *ctx);\n\nPHP_REDIS_API int redis_sock_write(RedisSock *redis_sock, char *cmd, size_t sz);\nPHP_REDIS_API int redis_check_eof(RedisSock *redis_sock, zend_bool no_retry, zend_bool no_throw);\nPHP_REDIS_API RedisSock *redis_sock_get(zval *id, int nothrow);\nPHP_REDIS_API void redis_free_socket(RedisSock *redis_sock);\nPHP_REDIS_API void redis_sock_set_err(RedisSock *redis_sock, const char *msg, int msg_len);\nPHP_REDIS_API int redis_sock_set_stream_context(RedisSock *redis_sock, zval *options);\nPHP_REDIS_API int redis_sock_set_backoff(RedisSock *redis_sock, zval *options);\n\nPHP_REDIS_API int\nredis_serialize(RedisSock *redis_sock, zval *z, char **val, size_t *val_len);\nPHP_REDIS_API int\nredis_key_prefix(RedisSock *redis_sock, char **key, size_t *key_len);\nPHP_REDIS_API zend_string*\nredis_key_prefix_zval(RedisSock *redis_sock, zval *zv);\nPHP_REDIS_API zend_string *\nredis_key_prefix_zstr(RedisSock *redis_sock, zend_string *key);\n\nPHP_REDIS_API int\nredis_unserialize(RedisSock *redis_sock, const char *val, int val_len, zval *z_ret);\n\nPHP_REDIS_API int\nredis_compress(RedisSock *redis_sock, char **dst, size_t *dstlen, char *buf, size_t len);\nPHP_REDIS_API int\nredis_uncompress(RedisSock *redis_sock, char **dst, size_t *dstlen, const char *src, size_t len);\n\nPHP_REDIS_API int redis_pack(RedisSock *redis_sock, zval *z, char **val, size_t *val_len);\nPHP_REDIS_API int redis_unpack(RedisSock *redis_sock, const char *val, int val_len, zval *z_ret);\n\nPHP_REDIS_API int\nredis_read_stream_messages(RedisSock *redis_sock, int count, zval *z_ret);\nPHP_REDIS_API int\nredis_read_stream_messages_multi(RedisSock *redis_sock, int count, zval *z_ret);\nPHP_REDIS_API int\nredis_read_xinfo_response(RedisSock *redis_sock, zval *z_ret, int elements);\n\nPHP_REDIS_API int\nredis_mpop_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                    zval *z_tab, void *ctx);\n\nPHP_REDIS_API int\nredis_read_mpop_response(RedisSock *redis_sock, zval *zdst, int elements, void *ctx);\n\n/* Specialized ACL reply handlers */\nPHP_REDIS_API int redis_acl_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_read_acl_getuser_reply(RedisSock *redis_sock, zval *zret, long len);\nPHP_REDIS_API int redis_acl_getuser_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_read_acl_log_reply(RedisSock *redis_sock, zval *zret, long count);\nPHP_REDIS_API int redis_acl_log_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\n\n/*\n* Variant Read methods, mostly to implement eval\n*/\n\nPHP_REDIS_API int redis_read_reply_type(RedisSock *redis_sock, REDIS_REPLY_TYPE *reply_type, long *reply_info);\nPHP_REDIS_API int redis_read_variant_bulk(RedisSock *redis_sock, int size, zval *z_ret);\nPHP_REDIS_API int redis_read_multibulk_recursive(RedisSock *redis_sock, long long elements, int status_strings, zval *z_ret);\nPHP_REDIS_API int redis_read_variant_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_read_raw_variant_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_read_variant_reply_strings(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_client_list_reply(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\n\nPHP_REDIS_API int redis_zadd_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_zrandmember_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_zdiff_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_set_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_read_geosearch_response(zval *zdst, RedisSock *redis_sock, long long elements, int with_aux_data);\nPHP_REDIS_API int redis_geosearch_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_hrandfield_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_pop_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\n\nPHP_REDIS_API int redis_srandmember_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_lpos_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_object_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_read_lpos_response(zval *zdst, RedisSock *redis_sock, char reply_type, long long elements, void *ctx);\n\nPHP_REDIS_API int redis_client_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_function_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_command_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\nPHP_REDIS_API int redis_select_response(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\n\n/* Helper methods to get configuration values from a HashTable. */\n\n#define REDIS_HASH_STR_FIND_STATIC(ht, sstr) \\\n    zend_hash_str_find(ht, sstr, sizeof(sstr) - 1)\n#define REDIS_HASH_STR_FIND_TYPE_STATIC(ht, sstr, type) \\\n    redis_hash_str_find_type(ht, sstr, sizeof(sstr) - 1, type)\n\n#define REDIS_CONF_DOUBLE_STATIC(ht, sstr, dval) \\\n    redis_conf_double(ht, sstr, sizeof(sstr) - 1, dval)\n#define REDIS_CONF_BOOL_STATIC(ht, sstr, rval) \\\n    redis_conf_bool(ht, sstr, sizeof(sstr) - 1, rval)\n#define REDIS_CONF_ZEND_BOOL_STATIC(ht, sstr, bval) \\\n    redis_conf_zend_bool(ht, sstr, sizeof(sstr) - 1, bval)\n#define REDIS_CONF_LONG_STATIC(ht, sstr, lval) \\\n    redis_conf_long(ht, sstr, sizeof(sstr) - 1, lval)\n#define REDIS_CONF_INT_STATIC(ht, sstr, ival) \\\n    redis_conf_int(ht, sstr, sizeof(sstr) - 1, ival)\n#define REDIS_CONF_STRING_STATIC(ht, sstr, sval) \\\n    redis_conf_string(ht, sstr, sizeof(sstr) - 1, sval)\n#define REDIS_CONF_ZVAL_STATIC(ht, sstr, zret, copy, dtor) \\\n    redis_conf_zval(ht, sstr, sizeof(sstr) - 1, zret, copy, dtor)\n#define REDIS_CONF_AUTH_STATIC(ht, sstr, user, pass) \\\n    redis_conf_auth(ht, sstr, sizeof(sstr) - 1, user, pass)\n\nzval *redis_hash_str_find_type(HashTable *ht, const char *key, int keylen, int type);\nvoid redis_conf_double(HashTable *ht, const char *key, int keylen, double *dval);\nvoid redis_conf_bool(HashTable *ht, const char *key, int keylen, int *bval);\nvoid redis_conf_zend_bool(HashTable *ht, const char *key, int keylen, zend_bool *bval);\nvoid redis_conf_long(HashTable *ht, const char *key, int keylen, zend_long *lval);\nvoid redis_conf_int(HashTable *ht, const char *key, int keylen, int *ival);\nvoid redis_conf_string(HashTable *ht, const char *key, size_t keylen, zend_string **sval);\nvoid redis_conf_zval(HashTable *ht, const char *key, size_t keylen, zval *zret, int copy, int dtor);\nvoid redis_conf_auth(HashTable *ht, const char *key, size_t keylen, zend_string **user, zend_string **pass);\n\nstatic inline char *redis_sock_get_line(RedisSock *redis_sock, char *buf, size_t buf_size, size_t *nread) {\n    char *res;\n\n    res = php_stream_get_line(redis_sock->stream, buf, buf_size, nread);\n    if (res != NULL)\n        redis_sock->rxBytes += *nread;\n\n    return res;\n}\n\nstatic inline char redis_sock_getc(RedisSock *redis_sock) {\n    char res;\n\n    res = php_stream_getc(redis_sock->stream);\n    if (res != EOF)\n        redis_sock->rxBytes++;\n\n    return res;\n}\n\nstatic inline ssize_t redis_sock_read_raw(RedisSock *redis_sock, char *buf, size_t buf_size) {\n    ssize_t nread;\n\n    nread = php_stream_read(redis_sock->stream, buf, buf_size);\n    if (nread > 0)\n        redis_sock->rxBytes += nread;\n\n    return nread;\n}\n\nstatic inline ssize_t redis_sock_write_raw(RedisSock *redis_sock, const char *buf, size_t buf_size) {\n    ssize_t nwritten;\n\n    nwritten = php_stream_write(redis_sock->stream, buf, buf_size);\n    if (nwritten > 0)\n        redis_sock->txBytes += nwritten;\n\n    return nwritten;\n}\n\nstatic inline char *redis_sock_gets_raw(RedisSock *redis_sock, char *buf, size_t buf_size) {\n    size_t nread;\n\n    return redis_sock_get_line(redis_sock, buf, buf_size, &nread);\n}\n\n#endif\n"
        },
        {
          "name": "mkdeb-apache2.sh",
          "type": "blob",
          "size": 0.62109375,
          "content": "#!/bin/sh\nphpize\n./configure CFLAGS=\"-O3\"\nmake clean all\nDIR=`php-config --extension-dir | cut -c 2-`\n\nrm -rf debian\n\nmkdir -p debian\nmkdir -p debian/DEBIAN\nmkdir -p debian/$DIR\n\ncp debian.control debian/DEBIAN/control\n\nUBUNTU=`uname -v | grep -ci ubuntu`\nmkdir -p debian/etc/php5/apache2/conf.d/\nif [ $UBUNTU = \"0\" ]; then\n\tmkdir -p debian/etc/php5/cli/conf.d/\nfi\n\necho \"extension=redis.so\" >> debian/etc/php5/apache2/conf.d/redis.ini\n\nif [ $UBUNTU = \"0\" ]; then\n\tcp debian/etc/php5/apache2/conf.d/redis.ini debian/etc/php5/cli/conf.d/redis.ini\nfi\n\ncp modules/redis.so debian/$DIR\ndpkg -b debian phpredis-`uname -m`.deb\nrm -rf debian/\n"
        },
        {
          "name": "mkdeb.sh",
          "type": "blob",
          "size": 0.4599609375,
          "content": "#!/bin/sh\nphpize\n./configure CFLAGS=\"-O3\"\nmake clean all\nDIR=`php-config --extension-dir | cut -c 2-`\n\nrm -rf debian\n\nmkdir -p debian\nmkdir -p debian/DEBIAN\nmkdir -p debian/$DIR\n\ncp debian.control debian/DEBIAN/control\n\nUBUNTU=`uname -v | grep -ci ubuntu`\nmkdir -p debian/etc/php5/conf.d/\necho \"extension=redis.so\" >> debian/etc/php5/conf.d/redis.ini\n\ncp modules/redis.so debian/$DIR\ndpkg -b debian phpredis-`git describe --abbrev=0 --tags`_`uname -m`.deb\nrm -rf debian/\n"
        },
        {
          "name": "package.xml",
          "type": "blob",
          "size": 76.71484375,
          "content": "<?xml version=\"1.0\"?>\n<package packagerversion=\"1.4.11\" version=\"2.0\" xmlns=\"http://pear.php.net/dtd/package-2.0\" xmlns:tasks=\"http://pear.php.net/dtd/tasks-1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://pear.php.net/dtd/tasks-1.0\nhttp://pear.php.net/dtd/tasks-1.0.xsd\nhttp://pear.php.net/dtd/package-2.0\nhttp://pear.php.net/dtd/package-2.0.xsd\">\n <name>redis</name>\n <channel>pecl.php.net</channel>\n <summary>PHP extension for interfacing with key-value stores</summary>\n <description>\n   This extension provides an API for communicating with RESP-based key-value\n   stores, such as Redis, Valkey, and KeyDB.\n </description>\n <lead>\n  <name>Michael Grunder</name>\n  <user>mgrunder</user>\n  <email>michael.grunder@gmail.com</email>\n  <active>yes</active>\n </lead>\n <lead>\n  <name>Pavlo Yatsukhnenko</name>\n  <user>yatsukhnenko</user>\n  <email>p.yatsukhnenko@gmail.com</email>\n  <active>yes</active>\n </lead>\n <date>2024-10-04</date>\n <version>\n  <release>6.1.0</release>\n  <api>6.0.0</api>\n </version>\n <stability>\n  <release>stable</release>\n  <api>stable</api>\n </stability>\n <license uri=\"http://www.php.net/license\">PHP</license>\n <notes>\n    Sponsors\n\n    Audiomack - https://audiomack.com\n    Open LMS - https://openlms.net\n    Avtandil Kikabidze - https://github.com/akalongman\n    Ty Karok - https://github.com/karock\n    Object Cache Pro for WordPress - https://objectcache.pro\n\n    --- 6.1.0 ---\n\n    NOTE: There were no changes to C code between 6.1.0RC2 and 6.1.0\n\n    Documentation:\n\n    * Update package.xml to make it clearer that we support many key-value stores\n      [52e69ede] (Remi Collet)\n    * Fix redis.io urls [0bae4bb0] (Vincent Langlet)\n\n    Tests/CI:\n\n    * Fix 2 tests with redis 6.2 [cc1be322] (Remi Collet)\n\n    --- 6.1.0RC2 ---\n\n    Fixed:\n\n    * Fixed a `SIGABRT` error in PHP 8.4 [a75a7e5a] (Michael Grunder)\n    * Clean up code for unsupported versions of PHP [37cebdd7] (Remi Collet)\n    * Add `SessionHelpers.php` to `package.xml`[e9474b80] (Remi Collet)\n    * 8.4 implicit null fix, bump version [bff3a22e, 30c8f90c] [Remi Collet]\n\n    Changed:\n\n    * Raised minimum supported PHP version to 7.4 [8b519423] (Michael Grunder)\n\n    Removed:\n\n    * Removed erroneously duplicated changelog entries [40c89736] (Michael Grunder)\n\n    Tests/CI:\n\n    * Move to upload artifacts v4 [9d380500] (Michael Grunder)\n\n    Added:\n\n    * Added `composer.json` to support PIE (PHP Installer for Extensions) [b59e35a6]\n      (James Titcumb)\n\n    --- 6.1.0RC1 ---\n\n    Fixed:\n\n    * Fix random connection timeouts with Redis Cluster. [eb7f31e7] (Jozsef Koszo)\n    * Fix argument count issue in HSET with associative array [6ea5b3e0]\n      (Viktor Djupsjobacka)\n    * SRANDMEMBER can return any type because of serialization. [6673b5b2]\n      (Michael Grunder)\n    * Fix HRANDFIELD command when WITHVALUES is used. [99f9fd83] (Michael Grunder)\n    * Allow context array to be nullable [50529f56] (Michael Grunder)\n    * Fix a macOS (M1) compiler warning. [7de29d57] (Michael Grunder)\n    * `GETEX` documentation/updates and implentation in `RedisCluster` [981c6931]\n      (Michael Grunder)\n    * Refactor redis_script_cmd and fix to `flush` subcommand. [7c551424]\n      (Pavlo Yatsukhnenko)\n    * Update liveness check and fix PHP 8.4 compilation error. [c139de3a]\n      (Michael Grunder)\n    * Rework how we declare ZSTD min/max constants. [34b5bd81] (Michael Grunder)\n    * Fix memory leak if we fail in ps_open_redis. [0e926165] (Michael Grunder)\n    * Fix segfault and remove redundant macros [a9e53fd1] (Pavlo Yatsukhnenko)\n    * Fix PHP 8.4 includes [a51215ce] (Michael Grunder)\n    * Handle arbitrarily large `SCAN` cursors properly. [2612d444, e52f0afa]\n      (Michael Grunder)\n    * Improve warning when we encounter an invalid EXPIRY in SET [732e466a]\n      (Michael Grunder)\n    * Fix Arginfo / zpp mismatch for DUMP command [50e5405c] (Pavlo Yatsukhnenko)\n    * RedisCluster::publish returns a cluster_long_resp [14f93339] (Alexandre Choura)\n    * Fix segfault when passing just false to auth. [6dc0a0be] (Michael Grunder)\n    * the VALUE argument type for hSetNx must be the same as for hSet [df074dbe]\n      (Uladzimir Tsykun)\n    * Other fixes [e18f6c6d, 3d7be358, 2b555c89, fa1a283a, 37c5f8d4] (Michael Grunder, Viktor Szepe)\n\n    Added:\n\n    * Compression support for PHP sessions. [da4ab0a7] (bitactive)\n    * Support for early_refresh in Redis sessions to match cluster behavior\n      [b6989018] (Bitactive)\n    * Implement WAITAOF command. [ed7c9f6f] (Michael Grunder)\n\n    Removed:\n\n    * PHP 7.1, 7.2, and 7.3 CI jobs [d68c30f8, dc39bd55] (Michael Grunder)\n\n    Changed:\n\n    * Fix the time unit of retry_interval [3fdd52b4] (woodong)\n\n    Documentation:\n\n    * Many documentation fixes. [eeb51099] (Michael Dwyer)\n    * fix missing code tags [f865d5b9] (divinity76)\n    * Mention Valkey support [5f1eecfb] (PlavorSeol)\n    * Mention KeyDB support in README.md [37fa3592] (Tim Starling)\n    * Remove mention of pickle [c7a73abb] (David Baker)\n    * Add session.save_path examples [8a39caeb] (Martin Vancl)\n    * Tighter return types for Redis::(keys|hKeys|hVals|hGetAll) [77ab62bc]\n      (Benjamin Morel)\n    * Update stubs [4d233977, ff305349, 12966a74, a4a283ab, 8f8ff72a]\n      (Michael Grunder, Takayasu Oyama, Pavlo Yatsukhnenko)\n    * Fix config.m4 when using custom dep paths [ece3f7be] (Michael Grunder)\n    * Fix retry_internal documentation [142c1f4a] (SplotyCode)\n    * Fix anchor link [9b5cad31] (Git'Fellow)\n    * Fix typo in link [bfd379f0] (deiga)\n    * Fix Fedora package url [60b1ba14, 717713e1] (Dmitrii Kotov)\n    * Update Redis Sentinel documentation to reflect changes to constructor in 6.0\n      release [dc05d65c] (Pavlo Yatsukhnenko)\n\n    Tests/CI:\n\n    * Avoid fatal error in test execution. [57304970] (Michael Grunder)\n    * Refactor unit test framework. [b1771def] (Michael Grunder)\n    * Get unit tests working in `php-cgi`. [b808cc60] (Michael Grunder)\n    * Switch to `ZEND_STRL` in more places. [7050c989, f8c762e7] (Michael Grunder)\n    * Workaround weird PHP compiler crash. [d3b2d87b] (Michael Grunder)\n    * Refactor tests (formatting, modernization, etc). [dab6a62d, c6cd665b, 78b70ca8,\n      3c125b09, 18b0da72, b88e72b1, 0f94d9c1, 59965971, 3dbc2bd8, 9b90c03b, c0d6f042]\n      (Michael Grunder)\n    * Spelling fixes [0d89e928] (Michael Grunder)\n    * Added Valkey support. [f350dc34] (Michael Grunder)\n    * Add a test for session compression. [9f3ca98c] (Michael Grunder)\n    * Test against valkey [a819a44b] (Michael Grunder)\n    * sessionSaveHandler injection. [9f8f80ca] (Pavlo Yatsukhnenko)\n    * KeyDB addiions [54d62c72, d9c48b78] (Michael Grunder)\n    * Add PHP 8.3 to CI [78d15140, e051a5db] (Robert Kelcak, Pavlo Yatsukhnenko)\n    * Use newInstance in RedisClusterTest [954fbab8] (Pavlo Yatsukhnenko)\n    * Use actions/checkout@v4 [f4c2ac26] (Pavlo Yatsukhnenko)\n    * Cluster nodes from ENV [eda39958, 0672703b] (Pavlo Yatsukhnenko)\n    * Ensure we're talking to redis-server in our high ports test. [7825efbc]\n      (Michael Grunder)\n    * Add missing option to installation example [2bddd84f] (Pavlo Yatsukhnenko)\n    * Fix typo in link [8f6bc98f] (Timo Sand)\n    * Update tests to allow users to use a custom class. [5f6ce414] (Michael Grunder)\n </notes>\n <contents>\n  <dir name=\"/\">\n   <file role='doc' name='LICENSE'/>\n   <file role='doc' name='CREDITS'/>\n   <file role='doc' name='README.md'/>\n   <file role='src' name='INSTALL.md'/>\n   <file role='doc' name='arrays.md'/>\n   <file role='doc' name='cluster.md'/>\n   <file role='doc' name='sentinel.md'/>\n   <file role='src' name='backoff.c'/>\n   <file role='src' name='backoff.h'/>\n   <file role='src' name='cluster_library.c'/>\n   <file role='src' name='cluster_library.h'/>\n   <file role='src' name='common.h'/>\n   <file role='src' name='config.m4'/>\n   <file role='src' name='config.w32'/>\n   <file role='src' name='crc16.h'/>\n   <file role='src' name='library.c'/>\n   <file role='src' name='library.h'/>\n   <file role='src' name='php_redis.h'/>\n   <file role='src' name='redis.c'/>\n   <file role='src' name='redis.stub.php'/>\n   <file role='src' name='redis_arginfo.h'/>\n   <file role='src' name='redis_legacy_arginfo.h'/>\n   <file role='src' name='redis_array.c'/>\n   <file role='src' name='redis_array.h'/>\n   <file role='src' name='redis_array.stub.php'/>\n   <file role='src' name='redis_array_arginfo.h'/>\n   <file role='src' name='redis_array_legacy_arginfo.h'/>\n   <file role='src' name='redis_array_impl.c'/>\n   <file role='src' name='redis_array_impl.h'/>\n   <file role='src' name='redis_cluster.c'/>\n   <file role='src' name='redis_cluster.h'/>\n   <file role='src' name='redis_cluster.stub.php'/>\n   <file role='src' name='redis_cluster_arginfo.h'/>\n   <file role='src' name='redis_cluster_legacy_arginfo.h'/>\n   <file role='src' name='redis_commands.c'/>\n   <file role='src' name='redis_commands.h'/>\n   <file role='src' name='redis_session.c'/>\n   <file role='src' name='redis_session.h'/>\n   <file role='src' name='redis_sentinel.c'/>\n   <file role='src' name='redis_sentinel.h'/>\n   <file role='src' name='redis_sentinel.stub.php'/>\n   <file role='src' name='redis_sentinel_arginfo.h'/>\n   <file role='src' name='redis_sentinel_legacy_arginfo.h'/>\n   <file role='src' name='sentinel_library.c'/>\n   <file role='src' name='sentinel_library.h'/>\n   <dir name='liblzf'>\n     <file role='doc' name='LICENSE'/>\n     <file role='doc' name='README'/>\n     <file role='src' name='lzf.h'/>\n     <file role='src' name='lzfP.h'/>\n     <file role='src' name='lzf_c.c'/>\n     <file role='src' name='lzf_d.c'/>\n   </dir> <!-- liblzf -->\n   <dir name='tests'>\n     <file role='test' name='RedisArrayTest.php'/>\n     <file role='test' name='RedisClusterTest.php'/>\n     <file role='test' name='RedisSentinelTest.php'/>\n     <file role='test' name='RedisTest.php'/>\n     <file role='test' name='TestRedis.php'/>\n     <file role='test' name='TestSuite.php'/>\n     <file role='test' name='getSessionData.php'/>\n     <file role='test' name='regenerateSessionId.php'/>\n     <file role='test' name='startSession.php'/>\n     <file role='test' name='SessionHelpers.php'/>\n     <file role='test' name='make-cluster.sh'/>\n     <file role='test' name='mkring.sh'/>\n   </dir> <!-- tests -->\n  </dir> <!-- / -->\n </contents>\n <dependencies>\n  <required>\n   <php>\n    <min>7.4.0</min>\n   </php>\n   <pearinstaller>\n    <min>1.4.0b1</min>\n   </pearinstaller>\n  </required>\n </dependencies>\n <providesextension>redis</providesextension>\n <extsrcrelease>\n  <configureoption name=\"enable-redis-igbinary\" prompt=\"enable igbinary serializer support?\" default=\"no\"/>\n  <configureoption name=\"enable-redis-lzf\" prompt=\"enable lzf compression support?\" default=\"no\"/>\n  <configureoption name=\"enable-redis-zstd\" prompt=\"enable zstd compression support?\" default=\"no\"/>\n  <configureoption name=\"enable-redis-msgpack\" prompt=\"enable msgpack serializer support?\" default=\"no\"/>\n  <configureoption name=\"enable-redis-lz4\" prompt=\"enable lz4 compression?\" default=\"no\"/>\n  <configureoption name=\"with-liblz4\" prompt=\"use system liblz4?\" default=\"yes\"/>\n </extsrcrelease>\n <changelog>\n <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>6.1.0</release><api>6.0.0</api></version>\n   <date>2024-10-04</date>\n   <notes>\n    --- Sponsors ---\n\n    Audiomack - https://audiomack.com\n    Open LMS - https://openlms.net\n    Avtandil Kikabidze - https://github.com/akalongman\n    Ty Karok - https://github.com/karock\n    Object Cache Pro for WordPress - https://objectcache.pro\n\n    --- 6.1.0 ---\n\n    NOTE: There were no changes to C code between 6.1.0RC2 and 6.1.0\n\n    Documentation:\n\n    * Update package.xml to make it clearer that we support many key-value stores\n      [52e69ede] (Remi Collet)\n    * Fix redis.io urls [0bae4bb0] (Vincent Langlet)\n\n    Tests/CI:\n\n    * Fix 2 tests with redis 6.2 [cc1be322] (Remi Collet)\n\n\n    --- 6.1.0RC2 ---\n\n    Fixed:\n\n    * Fixed a `SIGABRT` error in PHP 8.4 [a75a7e5a] (Michael Grunder)\n    * Clean up code for unsupported versions of PHP [37cebdd7] (Remi Collet)\n    * Add `SessionHelpers.php` to `package.xml`[e9474b80] (Remi Collet)\n\n    Changed:\n\n    * Raised minimum supported PHP version to 7.4 [8b519423] (Michael Grunder)\n\n    Removed:\n\n    * Removed erroneously duplicated changelog entries [40c89736] (Michael Grunder)\n\n    Tests/CI:\n\n    * Move to upload artifacts v4 [9d380500] (Michael Grunder)\n\n    Added:\n\n    * Added `composer.json` to support PIE (PHP Installer for Extensions) [b59e35a6]\n      (James Titcumb)\n\n    --- 6.1.0RC1 ---\n\n    Fixed:\n\n    * Fix random connection timeouts with Redis Cluster. [eb7f31e7] (Jozsef Koszo)\n    * Fix argument count issue in HSET with associative array [6ea5b3e0]\n      (Viktor Djupsjobacka)\n    * SRANDMEMBER can return any type because of serialization. [6673b5b2]\n      (Michael Grunder)\n    * Fix HRANDFIELD command when WITHVALUES is used. [99f9fd83] (Michael Grunder)\n    * Allow context array to be nullable [50529f56] (Michael Grunder)\n    * Fix a macOS (M1) compiler warning. [7de29d57] (Michael Grunder)\n    * `GETEX` documentation/updates and implentation in `RedisCluster` [981c6931]\n      (Michael Grunder)\n    * Refactor redis_script_cmd and fix to `flush` subcommand. [7c551424]\n      (Pavlo Yatsukhnenko)\n    * Update liveness check and fix PHP 8.4 compilation error. [c139de3a]\n      (Michael Grunder)\n    * Rework how we declare ZSTD min/max constants. [34b5bd81] (Michael Grunder)\n    * Fix memory leak if we fail in ps_open_redis. [0e926165] (Michael Grunder)\n    * Fix segfault and remove redundant macros [a9e53fd1] (Pavlo Yatsukhnenko)\n    * Fix PHP 8.4 includes [a51215ce] (Michael Grunder)\n    * Handle arbitrarily large `SCAN` cursors properly. [2612d444, e52f0afa]\n      (Michael Grunder)\n    * Improve warning when we encounter an invalid EXPIRY in SET [732e466a]\n      (Michael Grunder)\n    * Fix Arginfo / zpp mismatch for DUMP command [50e5405c] (Pavlo Yatsukhnenko)\n    * RedisCluster::publish returns a cluster_long_resp [14f93339] (Alexandre Choura)\n    * Fix segfault when passing just false to auth. [6dc0a0be] (Michael Grunder)\n    * the VALUE argument type for hSetNx must be the same as for hSet [df074dbe]\n      (Uladzimir Tsykun)\n    * Other fixes [e18f6c6d, 3d7be358, 2b555c89, fa1a283a, 37c5f8d4] (Michael Grunder, Viktor Szepe)\n\n    Added:\n\n    * Compression support for PHP sessions. [da4ab0a7] (bitactive)\n    * Support for early_refresh in Redis sessions to match cluster behavior\n      [b6989018] (Bitactive)\n    * Implement WAITAOF command. [ed7c9f6f] (Michael Grunder)\n\n    Removed:\n\n    * PHP 7.1, 7.2, and 7.3 CI jobs [d68c30f8, dc39bd55] (Michael Grunder)\n\n    Changed:\n\n    * Fix the time unit of retry_interval [3fdd52b4] (woodong)\n\n    Documentation:\n\n    * Many documentation fixes. [eeb51099] (Michael Dwyer)\n    * fix missing code tags [f865d5b9] (divinity76)\n    * Mention Valkey support [5f1eecfb] (PlavorSeol)\n    * Mention KeyDB support in README.md [37fa3592] (Tim Starling)\n    * Remove mention of pickle [c7a73abb] (David Baker)\n    * Add session.save_path examples [8a39caeb] (Martin Vancl)\n    * Tighter return types for Redis::(keys|hKeys|hVals|hGetAll) [77ab62bc]\n      (Benjamin Morel)\n    * Update stubs [4d233977, ff305349, 12966a74, a4a283ab, 8f8ff72a, 5d293245]\n      (Michael Grunder, Takayasu Oyama, Pavlo Yatsukhnenko)\n    * Fix config.m4 when using custom dep paths [ece3f7be] (Michael Grunder)\n    * Fix retry_internal documentation [142c1f4a] (SplotyCode)\n    * Fix anchor link [9b5cad31] (Git'Fellow)\n    * Fix typo in link [bfd379f0] (deiga)\n    * Fix Fedora package url [60b1ba14, 717713e1] (Dmitrii Kotov)\n    * Update Redis Sentinel documentation to reflect changes to constructor in 6.0\n      release [dc05d65c] (Pavlo Yatsukhnenko)\n\n    Tests/CI:\n\n    * Avoid fatal error in test execution. [57304970] (Michael Grunder)\n    * Refactor unit test framework. [b1771def] (Michael Grunder)\n    * Get unit tests working in `php-cgi`. [b808cc60] (Michael Grunder)\n    * Switch to `ZEND_STRL` in more places. [7050c989, f8c762e7] (Michael Grunder)\n    * Workaround weird PHP compiler crash. [d3b2d87b] (Michael Grunder)\n    * Refactor tests (formatting, modernization, etc). [dab6a62d, c6cd665b, 78b70ca8,\n      3c125b09, 18b0da72, b88e72b1, 0f94d9c1, 59965971, 3dbc2bd8, 9b90c03b, c0d6f042]\n      (Michael Grunder)\n    * Spelling fixes [0d89e928] (Michael Grunder)\n    * Added Valkey support. [f350dc34] (Michael Grunder)\n    * Add a test for session compression. [9f3ca98c] (Michael Grunder)\n    * Test against valkey [a819a44b] (Michael Grunder)\n    * sessionSaveHandler injection. [9f8f80ca] (Pavlo Yatsukhnenko)\n    * KeyDB addiions [54d62c72, d9c48b78] (Michael Grunder)\n    * Add PHP 8.3 to CI [78d15140, e051a5db] (Robert Kelcak, Pavlo Yatsukhnenko)\n    * Use newInstance in RedisClusterTest [954fbab8] (Pavlo Yatsukhnenko)\n    * Use actions/checkout@v4 [f4c2ac26] (Pavlo Yatsukhnenko)\n    * Cluster nodes from ENV [eda39958, 0672703b] (Pavlo Yatsukhnenko)\n    * Ensure we're talking to redis-server in our high ports test. [7825efbc]\n      (Michael Grunder)\n    * Add missing option to installation example [2bddd84f] (Pavlo Yatsukhnenko)\n    * Fix typo in link [8f6bc98f] (Timo Sand)\n    * Update tests to allow users to use a custom class. [5f6ce414] (Michael Grunder)\n   </notes>\n </release>\n <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>6.0.2</release><api>6.0.0</api></version>\n   <date>2023-10-22</date>\n   <notes>\n    --- Sponsors ---\n\n    Audiomack - https://audiomack.com\n    Open LMS - https://openlms.net\n    BlueHost - https://bluehost.com\n    Object Cache Pro for WordPress - https://objectcache.pro\n    Avtandil Kikabidze - https://github.com/akalongman\n    Zaher Ghaibeh - https://github.com/zaherg\n    BatchLabs - https://batch.com\n    Stackhero - https://github.com/stackhero-io\n    Florian Levis - https://github.com/Gounlaf\n    Luis Zarate - https://github.com/jlzaratec\n\n    ---\n\n    phpredis 6.0.2\n\n    This release contains fixes for OBJECT, PSUBSCRIBE and SCAN commands.\n    You can find a detailed list of changes in CHANGELOG.md and package.xml\n    or by inspecting the git commit logs.\n\n    * Fix deprecation error when passing null to match_type parameter.[b835aaa3] (Pavlo Yatsukhnenko)\n    * Fix flaky test and OBJECT in a pipeline. [a7f51f70] (Michael Grunder)\n    * Find our callback by pattern with PSUBSCRIBE [2f276dcd] (Michael Grunder)\n   </notes>\n </release>\n <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>6.0.1</release><api>6.0.0</api></version>\n   <date>2023-09-23</date>\n   <notes>\n    --- Sponsors ---\n\n    Audiomack - https://audiomack.com\n    Open LMS - https://openlms.net/\n    BlueHost - https://bluehost.com\n    Object Cache Pro for WordPress - https://objectcache.pro/\n    Avtandil Kikabidze - https://github.com/akalongman\n    Zaher Ghaibeh - https://github.com/zaherg\n    BatchLabs - https://batch.com\n    Stackhero - https://github.com/stackhero-io\n    Florian Levis - https://github.com/Gounlaf\n    Luis Zarate - https://github.com/jlzaratec\n\n    ---\n\n    phpredis 6.0.1\n\n    This release contains fix for unknown expiration modifier issue\n    as well as memory leak and segfault in exec function\n    and small documentation improvements.\n\n    You can find a detailed list of changes in CHANGELOG.md and package.xml\n    or by inspecting the git commit logs.\n\n    * Fix  memory leak and segfault in Redis::exec [362e1141] (Pavlo Yatsukhnenko), (Markus Podar)\n    * Fix unknown expiration modifier [264c0c7e, 95bd184b] (Pavlo Yatsukhnenko)\n    * Update documentation [3674d663, 849bedb6, 1ad95b63] (Till Kruss), (Joost OrangeJuiced)\n   </notes>\n </release>\n <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>6.0.0</release><api>6.0.0</api></version>\n   <date>2023-09-09</date>\n   <notes>\n    --- Sponsors ---\n\n    Audiomack - https://audiomack.com\n    Open LMS - https://openlms.net\n    BlueHost - https://bluehost.com\n    Object Cache Pro for WordPress - https://objectcache.pro\n    Avtandil Kikabidze - https://github.com/akalongman\n    Zaher Ghaibeh - https://github.com/zaherg\n    BatchLabs - https://batch.com\n    Luis Zarate - https://github.com/jlzaratec\n\n    phpredis 6.0.0\n\n    - There were no changes between 6.0.0 and 6.0.0RC2.\n\n    ---\n\n    phpredis 6.0.0RC2\n\n    * Fix arginfo for arguments that default to null [8d99b7d1] (Nicolas Grekas)\n    * Fix C99 usages [54d9ca45] (Remi Collet)\n    * Raise minimal supported version to 7.2 [e10b9a85] (Remi Collet)\n\n    ---\n\n    phpredis 6.0.0RC1\n\n    * Fix restoring keys when using compression [82e08723] (Till Kruss)\n    * Fix missing auth in RedisSentinel stub [5db85561] (Lu Fei)\n    * Fix RedisSentinel pconnect check [42cbd88a] (Pavlo Yatsukhnenko)\n    * Fix NULL-pointer dereferences and handle possible UB [36457555] (Pavlo Yatsukhnenko)\n    * Fix security alerts [ee210f86, fb6a297c] (Pavlo Yatsukhnenko), (Michael Grunder)\n    * Fix segfault [55bf0202] (Pavlo Yatsukhnenko)\n    * Fix default host length [c40f9d6c] (Pavlo Yatsukhnenko)\n    * Fix redis session standalone stream ssl context [ed10f365, d1bc6727, 2ff11df5] (patricio.dorantes)\n    * Fix segfault with session+tls [a471c87a] (Pavlo Yatsukhnenko)\n    * Fix non standards conforming prototypes. [b3ce0486] (Michael Grunder)\n    * Avoid registering the same replicas multiple times [f2bfd723] (Marius Adam)\n    * Better unix:// or file:// detection. [d05d301b] (Michael Grunder)\n    * Future proof our igbinary header check [69355faa] (Michael Grunder)\n    * Fix BITOP cross-slot bug [af13f951] (Michael Grunder)\n    * SENTINEL RESET returns a long. [0243dd9d] (Michael Grunder)\n    * Fix redis_sock_read_multibulk_multi_reply_loop logic [d9cb5946, 5a643b62] (Pavlo Yatsukhnenko)\n    * Fix RPOP to unserialize/decompress data. [02c91d59] (Michael Grunder)\n    * Fix testObject for redis 7.2 [fea19b52, dcb95a3f] (Remi Collet)\n    * Fix bug: the pipeline mode socket return an unexpected result after reconnecting [a3327d9d] (thomaston)\n    * Fix stub files [9aa5f387, 74cf49f5, 8b1eafe8, e392dd88, b5ea5fd7, 71758b09, 2a6dee5d] (Nicolas Grekas), (Michael Grunder)\n    * Update documentation [b64d93e1, 703d71b5, eba1c6d2, 0f502c9e, 130b5d0b, 21c3ef94, b7bf22d4, 50151e7a, b9950727, ab4ce4ab, 8d80ca5b, c4de8667, 6982941b, 375d093d, 43da8dd9, 71344612, b9de0b97, 2d8a8a44, a2b0c86f, e0b24be1, e609fbe8, c4aef956, df50b2ad, cc2383f0, 0dd2836f, 7d5db510, 99340889, 70a55f3e, b04684d4, 980ea6b1, bb06ffa3, b8679d7a, 854f3aa4, a5c47901, cf63e96e, f05ba819, 17db2328, 450904f7, 114f4d60, 142bddf0, 87fa36d6, 531177d4, ecf65144, 53d142d9, c14a9e3a, 72f8eb25, 872b6931] (Karina Kwiatek), (Nicolas Grekas), (Muhammad Dyas Yaskur), (sergkash7), (Dawid Polak), (Michael Grunder), (Yurun), (twosee), (Juha), (Till Kruss)\n    * Allow to pass null as iterator [14d121bb] (Pavlo Yatsukhnenko)\n    * Add NOMKSTREAM option to XADD command. [f9436e25] (Pavlo Yatsukhnenko)\n    * Don't allow reconnect on read response [5a269ab6] (Pavlo Yatsukhnenko)\n    * Reset multi/pipline transaction on pconnect close [0879770a] (Pavlo Yatsukhnenko)\n    * Use read_mbulk_header helper where possible [ca8b4c93] (Pavlo Yatsukhnenko)\n    * Allow to pass null as auth argument [41517753] (Pavlo Yatsukhnenko)\n    * Refactor redis_parse_client_list_response [68136a29, aaa4c91a, 1fb2935b, cf2c052c] (Pavlo Yatsukhnenko)\n    * Refactor subscribe/unsubscribe [3c9e159c] (Pavlo Yatsukhnenko)\n    * Change PHPREDIS_CTX_PTR type [de3635da] (Pavlo Yatsukhnenko)\n    * Refactor redis_parse_info_response [982bd13b] (Pavlo Yatsukhnenko)\n    * Allow IPv6 address within square brackets [c28ad7bb] (Pavlo Yatsukhnenko)\n    * Allow multiple field-value pairs for hmset command. [e858e8e3] (Pavlo Yatsukhnenko)\n    * Refactor MINIT and use @generate-class-entries in stub files [3675f442] (Remi Collet)\n    * Use spl_ce_RuntimeException [3cd5ac1e, a7e5ea64] (Remi Collet)\n    * Regenerate arginfo using 8.2.0 [a38e08da] (Remi Collet)\n    * Refactor client command [a8d10291] (Pavlo Yatsukhnenko)\n    * Pull COUNT/ANY parsing into a helper function [d67b2020] (Michael Grunder)\n    * Return false or NULL on empty lpos response [39a01ac7] (Michael Grunder)\n    * BLPOP with a float timeout [a98605f2, dc9af529] (Michael Grunder)\n    * Make sure we set an error for key based scans [98fda1b8] (Michael Grunder)\n    * Add back a default switch case for setoption handler [87464932] (Michael Grunder)\n    * Update stubs so the tests pass in strict mode [bebd398c] (Michael Grunder)\n    * Move where we generate our salt [d2044c9f] (Michael Grunder)\n    * Refactor XINFO handler [3b0d8b77] (Michael Grunder)\n    * Refactor and fix XPENDING handler [457953f4] (Michael Grunder)\n    * Refactor FLUSHDB and update docs. [54a084e5] (Michael Grunder)\n    * Add missing directed node command to docs and refactor stubs. [5ac92d25] (Michael Grunder)\n    * Refactor BITPOS and implement BIT/BYTE option. [4d8afd38] (Michael Grunder)\n    * INFO with multiple sections [44d03ca0] (Michael Grunder)\n    * Refactor SLOWLOG command [d87f1428] (Michael Grunder)\n    * Refactor SORT and add SORT_RO command [8c7c5a3a] (Michael Grunder)\n    * Use ZEND_STRL in redis_commands.c [78de25a3] (Pavlo Yatsukhnenko)\n    * Refactor PubSub command [2a0d1c1e] (Pavlo Yatsukhnenko)\n    * Refactor SLAVEOF handler [f2cef8be] (Michael Grunder)\n    * Refactor ACL command [504810a5] (Pavlo Yatsukhnenko)\n    * Use fast_zpp API [376d4d27] (Pavlo Yatsukhnenko)\n    * Fix XAUTOCLAIM response handler [0b7bd83f] (Michael Grunder)\n    * Refactor command command [ff863f3f] (Pavlo Yatsukhnenko)\n    * Refactor rawCommand and WAIT [79c9d224] (Michael Grunder)\n    * Refactor SELECT command [86f15cca] (Michael Grunder)\n    * Refactor SRANDMEMBER command. [f62363c2] (Michael Grunder)\n    * Refactor OBJECT command. [acb5db76] (Michael Grunder)\n    * Refactor gen_varkey_cmd [3efa59cb] (Michael Grunder)\n    * Refactor MGET command. [8cb6dd17] (Michael Grunder)\n    * Refactor INFO and SCRIPT commands. [3574ef08] (Michael Grunder)\n    * Refactor MSET and MSETNX commands. [6d104481] (Michael Grunder)\n    * Refactor HMSET command. [90eb0470] (Michael Grunder)\n    * Refactor PFCOUNT command. [19fd7e0c] (Michael Grunder)\n    * Refactor SMOVE command. [204a02c5] (Michael Grunder)\n    * Rework ZRANGE argument handling. [aa0938a4] (Michael Grunder)\n    * Refactor a couple more command methods. [5b560ccf, c8224b93, 40e1b1bf, ccd419a4] (Michael Grunder)\n    * Refactor HMGET command [bb66a547] (Michael Grunder)\n    * Refactor CLIENT command [77c4f7a3] (Pavlo Yatsukhnenko)\n    * Refactor redis_long_response [f14a80db] (Pavlo Yatsukhnenko)\n    * Synchronize Redis and RedisSentinel constructors [ebb2386e] (Pavlo Yatsukhnenko)\n    * Use redis_sock_connect on connect [f6c8b9c6] (Pavlo Yatsukhnenko)\n    * Auto-select db in redis_sock_server_open [6930a81c] (Pavlo Yatsukhnenko)\n    * Use on-stack allocated valiables [7a055cad] (Pavlo Yatsukhnenko)\n    * Add XAUTOCLAIM command [01f3342c] (Pavlo Yatsukhnenko)\n    * Add SYNC arg to FLUSHALL and FLUSHDB, and ASYNC/SYNC arg to SCRIPT FLUSH [750b6cf3] (Pavlo Yatsukhnenko)\n    * Add reset command [947a2d38] (Pavlo Yatsukhnenko)\n    * Add hRandField command [fe397371] (Pavlo Yatsukhnenko)\n    * Add PXAT/EXAT arguments to SET command. [0a160685] (Pavlo Yatsukhnenko)\n    * Add GETEX, GETDEL commands. [11861d95] (Pavlo Yatsukhnenko)\n    * Add FAILOVER command. [4b767be7] (Pavlo Yatsukhnenko)\n    * Backoff settings in constructor [e6b3fe54] (Pavlo Yatsukhnenko)\n    * Add the COUNT argument to LPOP and RPOP [df97cc35] (Pavlo Yatsukhnenko)\n    * Unsubscribe from all channels [0f1ca0cc] (Pavlo Yatsukhnenko)\n    * Add lPos command. [687a5c78] (Pavlo Yatsukhnenko)\n    * Add the ANY argument to GEOSEARCH and GEORADIUS [bf6f31e3] (Pavlo Yatsukhnenko)\n    * Add 'BIT'/'BYTE' modifier to BITCOUNT + tests [a3d2f131] (Michael Grunder)\n    * Add missing configureoption entries in package.xml [59053f10] (Michele Locati)\n    * Implement CONFIG RESETSTAT [239678a0] (Michael Grunder)\n    * SINTERCARD and ZINTERCARD commands [64300508] (Michael Grunder)\n    * LCS command [c0e839f6] (Michael Grunder)\n    * EXPIRETIME and PEXPIRETIME [f5b2a09b] (Michael Grunder)\n    * [B]LMPOP and [B]ZMPOP commands [6ea978eb] (Michael Grunder)\n    * Implement new RESTORE options [9a3fe401] (Michael Grunder)\n    * Add new Redis 6.2.0 XTRIM options [6b34d17f] (Michael Grunder)\n    * Implement AUTH/AUTH2 arguments for MIGRATE [114d79d1] (Michael Grunder)\n    * Implement CONFIG REWRITE [525958ea] (Michael Grunder)\n    * Implement Redis 7.0.0 [P]EXPIRE[AT] [options 872ae107] (Michael Grunder)\n    * Variadic CONFIG GET/SET [36ef4bd8, a176f586] (Michael Grunder)\n    * EVAL_RO and EVALSHA_RO [f3a40830] (Michael Grunder)\n    * Implement ZRANGESTORE and add ZRANGE options [71bcbcb9] (Michael Grunder)\n    * XGROUP DELCONSUMER and ENTRIESREAD [1343f500] (Michael Grunder)\n    * Expose the transferred number of bytes [e0a88b7b, 90828019, 7a4cee2d] (Pavlo Yatsukhnenko), (Michael Grunder)\n    * TOUCH command [dc1f2398] (Michael Grunder)\n    * Redis Sentinel TLS support [f2bb2cdb] (Pavlo Yatsukhnenko)\n    * Add the CH, NX, XX arguments to GEOADD [2bb64038, e8f5b517] (Pavlo Yatsukhnenko)\n    * Implement SMISMEMBER for RedisCluster [abfac47b] (Michael Grunder)\n    * Implement ssubscribe/sunsubscribe [7644736e] (Pavlo Yatsukhnenko)\n    * Implement BLMOVE and add LMOVE/BLMOVE to cluster. [121e9d9c] (Michael Grunder)\n    * Implement LPOS for RedisCluster [7121aaae] (Michael Grunder)\n    * Implement GEOSEARCH and GEOSEARCHSTORE for RedisCluster. [fa5d1af9] (Michael Grunder)\n    * Implement HRANDFIELD for RedisCluster [e222b85e] (Michael Grunder)\n    * Implement COPY for RedisCluster [40a2c254] (Michael Grunder)\n    * Implement new ZSET commands for cluster [27900f39] (Michael Grunder)\n    * Add cluster support for strict sessions and lazy write [b6cf6361] (Michael Grunder)\n    * Add function command [90a0e9cc] (Pavlo Yatsukhnenko)\n    * Add FCALL/FCALL_RO commands [7c46ad2c] (Pavlo Yatsukhnenko)\n    * Remove unused macros [831d6118] (Pavlo Yatsukhnenko)\n\n   </notes>\n </release>\n <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>5.3.7</release><api>5.3.7</api></version>\n   <date>2022-02-15</date>\n   <notes>\n    --- Sponsors ---\n\n    Audiomack - https://audiomack.com\n    Open LMS - https://openlms.net\n    BlueHost - https://bluehost.com\n    Object Cache Pro for WordPress - https://objectcache.pro\n    Avtandil Kikabidze - https://github.com/akalongman\n    Zaher Ghaibeh - https://github.com/zaherg\n    BatchLabs - https://batch.com\n    Luis Zarate - https://github.com/jlzaratec\n\n    phpredis 5.3.7\n\n    - There were no changes between 5.3.7 and 5.3.7RC2.\n\n    ---\n\n    phpredis 5.3.7RC2\n\n    - There were no changes between 5.3.7RC2 and 5.3.7RC1.\n\n    ---\n\n    phpredis 5.3.7RC1\n\n    - Fix RedisArray::[hsz]scan and tests [08a9d5db, 0264de18] (Pavlo Yatsukhnenko, Michael Grunder)\n    - Fix RedisArray::scan [8689ab1c] (Pavlo Yatsukhnenko)\n    - Fix LZF decompression logic [0719c1ec] (Michael Grunder)\n\n   </notes>\n </release>\n <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>5.3.6</release><api>5.3.6</api></version>\n   <date>2022-01-17</date>\n   <notes>\n    --- Sponsors ---\n\n    Audiomack - https://audiomack.com\n    Open LMS - https://openlms.net\n    BlueHost - https://bluehost.com\n    Object Cache Pro for WordPress - https://objectcache.pro\n    Avtandil Kikabidze - https://github.com/akalongman\n    Zaher Ghaibeh - https://github.com/zaherg\n    BatchLabs - https://batch.com\n    Luis Zarate - https://github.com/jlzaratec\n\n    ---\n\n    phpredis 5.3.6\n\n    - Fix a segfault in RedisArray::del [d2f2a7d9] (Pavlo Yatsukhnenko)\n\n   </notes>\n </release>\n <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>5.3.5</release><api>5.3.5</api></version>\n   <date>2021-12-18</date>\n   <notes>\n    phpredis 5.3.5\n\n    This release adds support for exponential backoff w/jitter, experimental\n    support for detecting a dirty connection, as well as many other fixes\n    and improvements.\n\n    You can find a detailed list of changes in Changelog.md and package.xml\n    or by inspecting the git commit logs.\n\n    --- Sponsors ---\n\n    Audiomack - https://audiomack.com\n    Open LMS - https://openlms.net\n    BlueHost - https://bluehost.com\n    Object Cache Pro for WordPress - https://objectcache.pro\n    Avtandil Kikabidze - https://github.com/akalongman\n    Zaher Ghaibeh - https://github.com/zaherg\n    BatchLabs - https://batch.com\n    Luis Zarate - https://github.com/jlzaratec\n\n    ---\n\n    phpredis 5.3.5\n\n    * Fix typo in cluster_scan_resp [44affad2] (Michael Grunder)\n\n    ---\n\n    phpredis 5.3.5RC1\n\n    * Fixed segfault in redis_setoption_handler [692e4e84] (Pavlo Yatsukhnenko)\n    * Fix masters array in the event of a cluster failover [bce692962] (Bar Shaul)\n    * Fix 32 bit type error [672dec87f] (Remi Collet)\n    * Fix radix character in certain locales [89a871e24] (Pavlo Yatsukhnenko)\n    * ZSTD Validation fix [6a77ef5cd] (Michael Grunder)\n    * Remove superfluous typecast [b2871471f] (Remi Collet)\n\n    * Updated documentation [f84168657, d017788e7, 20ac84710, 0adf05260,\n      aee29bf73, 09a095e72, 12ffbf33a, ff331af98, a6bdb8731, 305c15840,\n      1aa10e93a, d78b0c79d, c6d37c27c, a6303f5b9, d144bd2c7, a6fb815ef, 9ef862bc6]\n     (neodisco, Clement Tessier, T. Todua, dengliming, Maxime Cornet,\n      Emanuele Filannino Michael Grunder)\n\n    * Travis CI Fixes\n      [a43f4586e, 4fde8178f, 7bd5415ac, fdb8c4bb7, d4f407470]\n      (Pavlo Yatsukhnenko)\n\n    * Minor fixes/cleanup\n      [2e190adc1, 99975b592, 9d0879fa5, 22b06457b]\n      (Pavlo Yatsukhnenko)\n\n    * Fix RedisArray constructor bug\n      [85dc883ba](https://github.com/phpredis/phpredis/commit/85dc883ba)\n      ([Pavlo Yatsukhnenko](https://github.com/yatsukhnenko))\n\n    * Moved to GitHub Actions\n      [4d2afa786, 502d09fd5] (Pavlo Yatsukhnenko)\n\n    * Use more appropriate array iteration macro\n      [6008900c2] (Pavlo Yatsukhnenko)\n\n    * Clean up session tests\n      [ab25ae7f3] (Michael Grunder)\n\n    * RedisArray refactors [1250f0001, 017b2ea7f, 37ed3f079]\n      (Pavlo Yatsukhnenko)\n\n    * Use zend_parse_parameters_none helper\n      [a26b14dbe] (Remi Collet)\n\n    * Support for various exponential backoff strategies\n      [#1986, #1993, 732eb8dcb, 05129c3a3, 5bba6a7fc],\n      (Nathaniel Braun)\n\n    * Added experimental support for detecting a dirty connection\n      [d68579562] (Michael Grunder)\n\n    * Created distinct compression utility methods (pack/unpack)\n      [#1939, da2790aec] (Michael Grunder)\n\n    * SMISMEMBER Command\n      [#1894, ae2382472, ed283e1ab] (Pavlo Yatsukhnenko)\n   </notes>\n </release>\n <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>5.3.4</release><api>5.3.4</api></version>\n   <date>2021-03-24</date>\n   <notes>\n    phpredis 5.3.4\n\n    This release fixes a multi/pipeline segfault on apple silicon as well as\n    two small compression related bugs.\n\n    You can find a detailed list of changes in CHANGELOG.md and package.xml\n\n    * Fix multi/pipeline segfault on Apple silicon [e0796d48] (Michael Grunder)\n    * Pass compression flag on HMGET in RedisCluster [edc724e6] (Adam Olley)\n    * Abide by ZSTD error return constants [8400ed1c] (Michael Grunder)\n    * Fix timing related CI session tests [9b986bf8] (Michael Grunder)\n\n    * Sponsors\n      ~ Audiomack - https://audiomack.com\n      ~ Open LMS - https://openlms.net\n      ~ BlueHost - https://bluehost.com\n      ~ Object Cache Pro for WordPress - https://objectcache.pro\n      ~ Avtandil Kikabidze - https://github.com/akalongman\n      ~ Zaher Ghaibeh - https://github.com/zaherg\n      ~ BatchLabs - https://batch.com\n   </notes>\n </release>\n <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>5.3.3</release><api>5.3.3</api></version>\n   <date>2021-02-01</date>\n   <notes>\n    phpredis 5.3.3\n\n    This release mostly includes just small PHP 8 Windows compatibility fixes\n    such that pecl.php.net can automatically build Windows DLLs.\n\n    You can find a detailed list of changes in CHANGELOG.md and package.xml\n\n    * Fix PHP8 Windows includes [270b4db8] (Jan-E)\n    * Fix hash ops for php 8.0.1 [87297cbb] (defender-11)\n    * Disable cloning Redis and RedisCluster objects [cd05a344]\n      (Michael Grunder)\n\n    * Sponsors\n      ~ Audiomack - https://audiomack.com\n      ~ BlueHost - https://bluehost.com\n      ~ Redis Cache Pro for WordPress - https://wprediscache.com\n      ~ Avtandil Kikabidze - https://github.com/akalongman\n      ~ Zaher Ghaibeh - https://github.com/zaherg\n      ~ BatchLabs - https://batch.com\n   </notes>\n  </release>\n\n  <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>5.3.2</release><api>5.3.2</api></version>\n   <date>2020-10-22</date>\n   <notes>\n    This release containse some bugfixes and small improvements.\n    You can find a detailed list of changes in CHANGELOG.md and package.xml\n\n    * Sponsors\n      ~ Audiomack - https://audiomack.com\n      ~ BlueHost - https://bluehost.com\n      ~ Redis Cache Pro for WordPress - https://wprediscache.com\n      ~ Avtandil Kikabidze - https://github.com/akalongman\n      ~ Oleg Babushkin - https://github.com/olbabushkin\n\n    phpredis 5.3.2\n\n    * Use \"%.17g\" sprintf format for doubles as done in Redis server. [32be3006] (Pavlo Yatsukhnenko)\n    * Allow to pass NULL as RedisCluster stream context options. [72024afe] (Pavlo Yatsukhnenko)\n\n    ---\n\n    phpredis 5.3.2RC2\n\n    ---\n\n    * Verify SET options are strings before testing them as strings [514bc371] (Michael Grunder)\n\n    ---\n\n    phpredis 5.3.2RC1\n\n    ---\n    * Fix cluster segfault when dealing with NULL multi bulk replies in RedisCluster [950e8de8] (Michael Grunder, Alex Offshore)\n    * Fix xReadGroup() must return message id [500916a4] (Pavlo Yatsukhnenko)\n    * Fix memory leak in rediscluster session handler [b2cffffc] (Pavlo Yatsukhnenko)\n    * Fix XInfo() returns false if the stream is empty [5719c9f7, 566fdeeb] (Pavlo Yatsukhnenko, Michael Grunder)\n    * Relax requirements on set's expire argument [36458071] (Michael Grunder)\n    * Refactor redis_sock_check_liveness [c5950644] (Pavlo Yatsukhnenko)\n    * PHP8 compatibility [a7662da7, f4a30cb2, 17848791] (Pavlo Yatsukhnenko, Remi Collet)\n    * Update documentation [c9ed151d, 398c99d9] (Ali Alwash, Gregoire Pineau)\n    * Add Redis::OPT_NULL_MULTIBULK_AS_NULL setting to treat NULL multi bulk replies as NULL instead of []. [950e8de8] (Michael Grunder, Alex Offshore)\n    * Allow to specify stream context for rediscluster session handler [a8daaff8, 4fbe7df7] (Pavlo Yatsukhnenko)\n    * Add new parameter to RedisCluster to specify stream ssl/tls context. [f771ea16] (Pavlo Yatsukhnenko)\n    * Add new parameter to RedisSentinel to specify auth information [81c502ae] (Pavlo Yatsukhnenko)\n   </notes>\n  </release>\n\n  <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>5.3.1</release><api>5.3.1</api></version>\n   <date>2020-07-07</date>\n   <notes>\n    phpredis 5.3.1\n\n    This is a small bugfix release that fixes a couple of issues in 5.3.0.\n\n    You should upgrade if you're using persistent_id in session.save_path or\n    of if you're having trouble building 5.3.0 because the php_hash_bin2hex\n    symbol is missing.\n\n    You can find a detailed list of changes in CHANGELOG.md and package.xml\n\n    * Sponsors\n      ~ Audiomack - https://audiomack.com\n      ~ BlueHost - https://bluehost.com\n      ~ Redis Cache Pro for WordPress - https://wprediscache.com\n      ~ Avtandil Kikabidze - https://github.com/akalongman\n\n    ---\n    * Properly clean up on session start failure [066cff6a] (Michael Grunder)\n    * Treat NULL as a failure for redis_extract_auth_info [49428a2f, 14ac969d]\n      (Michael Grunder)\n    * Don't dereference a NULL zend_string or efree one [ff2e160f, 7fed06f2]\n      (Michael Grunder)\n    * Fix config.m4 messages and test for and include php_hash.h [83a1b7c5,\n      3c56289c, 08f202e7] (Remi Collet)\n    * Add openSUSE installation instructions [13a168f4] (Pavlo Yatsukhnenko)\n    * Remove EOL Fedora installation instructions [b4779e6a] (Remi Collet)\n   </notes>\n  </release>\n  <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>5.3.0</release><api>5.3.0</api></version>\n   <date>2020-06-30</date>\n   <notes>\n    phpredis 5.3.0\n\n    This release contains initial support for Redis 6 ACLs, LZ4 compression,\n    and many more fixes and improvements.\n\n    You can find a detailed list of changes in CHANGELOG.md and package.xml\n\n    A special thanks to BlueHost for sponsoring ACL support \\o/\n\n    * Sponsors\n      ~ Audiomack - https://audiomack.com\n      ~ BlueHost - https://bluehost.com\n      ~ Redis Cache Pro for WordPress - https://wprediscache.com\n      ~ Avtandil Kikabidze - https://github.com/akalongman\n\n    phpredis 5.3.0\n\n    - There were no changes between 5.3.0RC2 and 5.3.0.\n\n    ---\n\n    phpredis 5.3.0RC2\n\n    ---\n\n    * Fix LZ4 configuration and use pkg-config if we have it [df398cb0]\n      (Remi Collet)\n    * Make sure persistent pool ID is NULL terminated [0838b5bd, 57bb95bf]\n      (Michael Grunder)\n    * Run LZ4 tests in Travis [3ba3f06d] (Michael Grunder)\n\n    phpredis 5.3.0RC1\n\n    ---\n\n    * Support for Redis 6 ACLs [a311cc4e] (Michael Grunder)\n    * LZ4 Compression [04def9fb] (Ilia Alshanetsky)\n    * Support for new Redis 6 arguments (XINFO FULL, SET KEEPTTL) [a0c53e0b,\n      f9c7bb57] (Michael Grunder, Victor Kislov)\n    * Support for TLS connections [890ee0e6, b0671296] (Pavlo Yatsukhnenko)\n    * New option Redis::SCAN_PREFIX, Redis::SCAN_NOPREFIX [e80600e2] (Pavlo\n      Yatsukhnenko)\n    * Configurable unit test authentication arguments [e37f38a3, 201a9759]\n      (Pavlo Yatsukhnenko, Michael Grunder)\n    * Improved cluster slot caching mechanism to fix a couple of bugs and make\n      it more efficient. [5ca4141c] (Michael Grunder)\n    * Stop calling Redis constructor when creating a RedisArray [e41e19a8]\n      (Pavlo Yatsukhnenko)\n    * Use ZEND_LONG_FMT instead of system `long` [5bf88124] (Michael Grunder)\n    * Use long for SCAN iteration to fix potential overflow [f13f9b7c]\n      (Victor Kislov)\n    * Fix config.m4 to test for the variable $PHP_REDIS_JSON and not the\n      literal PHP_REDIS_JSON [20a3dc72] (Mizuki Nakano)\n    * Fix compiler warnings [b9b383f4, 215828e] (Remi Collet),\n      Pavlo Yatsukhnenko)\n    * Avoid use-after-free of RediSock [8c45816d] (Pavlo Yatsukhnenko)\n    * Fixed ZADD arginfo [a8e2b021] (Pavlo Yatsukhnenko)\n    * Store AUTH information in flags RedisSock rather than duplicating\n      information. [58dab564] (Pavlo Yatsukhnenko)\n    * Refactor redis_sock_get_connection_pool logic. [73212e1]\n      (Pavlo Yatsukhnenko)\n    * Updated documentation to show LPUSH and RPUSH are variadic and fixed DEL\n      documentation. [92f8dde1] (Michael Grunder)\n    * Authenticate in redis_server_sock_open [4ef465b5] (Pavlo Yatsukhnenko)\n    * Dynamically include json.so in unit tests based on configuration\n      [0ce7ca2f] (Michael Grunder)\n    * Update save_path logic in Redis Cluster session unit tests [dd66fce]\n      (Pavlo Yatsukhnenko)\n    * Refactoring various bits of logic [bbcf32a3, a42cf189, 460c8f29,\n      b7f9df75] (Pavlo Yatsukhnenko)\n    * Use the portable `ZEND_LONG_FORMAT` family instead of C format specifiers\n      [b9b383f4](Remi Collet)\n    * PHP 8 compatibility [9ee94ca4, 7e4c7b3e] (Pavlo Yatsukhnenko)\n    * Refactor PHPREDIS_GET_OBJECT macro [d5dadaf6, 190c0d34]\n      (Pavlo Yatsukhnenko)\n    * Fix documentation showing lPush and rPush are variadic [6808cd6a]\n      (Michael Grunder)\n   </notes>\n  </release>\n\n  <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>5.2.2</release><api>5.2.2</api></version>\n   <date>2020-05-05</date>\n   <notes>\n    phpredis 5.2.2\n\n    This is a bugfix release that contains a fix for authentication\n    when using persistent connections, and an option to make the\n    ECHO challenge response logic optional.\n\n    * Inexpensive liveness check, and making ECHO optional [56898f81] (Pavlo Yatsukhnenko)\n    * Move `AUTH` to `redis_sock_server_open` [80f2529b](Pavlo Yatsukhnenko)\n\n    * Sponsors\n      ~ Audiomack.com - https://audiomack.com\n      ~ Till Kruss - https://github.com/tillkruss\n   </notes>\n  </release>\n\n  <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>5.2.1</release><api>5.2.1</api></version>\n   <date>2020-03-19</date>\n   <notes>\n    phpredis 5.2.1\n\n    This is a bugfix release that fixes `redis->zAdd` arginfo as well as a\n    segfault when closing persistent connections.\n\n    * Fix arginfo for Redis::zadd [a8e2b021] (Pavlo Yatsukhnenko)\n    * Fix segfault on closing persistent stream [b7f9df75] (Pavlo Yatsukhnenko)\n\n    * Sponsors\n      ~ Audiomack.com - https://audiomack.com\n      ~ Till Kruss - https://github.com/tillkruss\n   </notes>\n  </release>\n\n\n\n  <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>5.2.0</release><api>5.2.0</api></version>\n   <date>2020-03-02</date>\n   <notes>\n    phpredis 5.2.0\n\n    - There were no changes between 5.2.0RC2 and 5.2.0.\n\n    phpredis 5.2.0RC2\n\n    * Include RedisSentinelTest.php in package.xml! [eddbfc8f] (Michael Grunder)\n    * Fix -Wmaybe-uninitialized warning [740b8c87] (Remi Collet)\n    * Fix improper destructor when zipping values and scores [371ae7ae]\n      (Michael Grunder)\n    * Use php_rand instead of php_mt_rand for liveness challenge string\n      [9ef2ed89] (Michael Grunder)\n\n    phpredis 5.2.0RC1\n\n    This release contains initial support for Redis Sentinel as well as many\n    smaller bug fixes and improvements.  It is especially of interest if you\n    use persistent connections, as we've added logic to make sure they are in\n    a good state when retrieving them from the pool.\n\n    IMPORTANT: Sentinel support is considered experimental and the API\n               will likely change based on user feedback.\n\n    * Sponsors\n      ~ Audiomack.com - https://audiomack.com\n      ~ Till Kruss - https://github.com/tillkruss\n\n    ---\n\n    * Initial support for RedisSentinel [90cb69f3, c94e28f1, 46da22b0, 5a609fa4,\n      383779ed] (Pavlo Yatsukhnenko)\n\n    * Housekeeping (spelling, doc changes, etc) [23f9de30, d07a8df6, 2d39b48d,\n      0ef488fc, 2c35e435, f52bd8a8, 2ddc5f21, 1ff7dfb7, db446138] (Tyson Andre,\n      Pavlo Yatsukhnenko, Michael Grunder, Tyson Andre)\n\n    * Fix for ASK redirections [ba73fbee] (Michael Grunder)\n    * Create specific 'test skipped' exception [c3d83d44] (Michael Grunder)\n    * Fixed memory leaks in RedisCluster [a107c9fc] (Michael Grunder)\n    * Fixes for session lifetime values that underflow or overflow  [7a79ad9c,\n      3c48a332] (Michael Grunder)\n    * Enables slot caching for Redis Cluster [23b1a9d8] (Michael Booth)\n\n    * Support TYPE argument for SCAN [8eb39a26, b1724b84, 53fb36c9, 544e641b]\n      (Pavlo Yatsukhnenko)\n\n    * Added challenge/response mechanism for persistent connections [a5f95925,\n      25cdaee6, 7b6072e0, 99ebd0cc, 3243f426] (Pavlo Yatsukhnenko, Michael Grunder)\n    phpredis 5.2.0RC2\n\n    * Include RedisSentinelTest.php in package.xml! [eddbfc8f] (Michael Grunder)\n    * Fix -Wmaybe-uninitialized warning [740b8c87] (Remi Collet)\n    * Fix improper destructor when zipping values and scores [371ae7ae]\n      (Michael Grunder)\n    * Use php_rand instead of php_mt_rand for liveness challenge string\n      [9ef2ed89] (Michael Grunder)\n\n    phpredis 5.2.0RC1\n\n    This release contains initial support for Redis Sentinel as well as many\n    smaller bug fixes and improvements.  It is especially of interest if you\n    use persistent connections, as we've added logic to make sure they are in\n    a good state when retrieving them from the pool.\n\n    IMPORTANT: Sentinel support is considered experimental and the API\n               will likely change based on user feedback.\n\n    * Sponsors\n      ~ Audiomack.com - https://audiomack.com\n      ~ Till Kruss - https://github.com/tillkruss\n\n    ---\n\n    * Initial support for RedisSentinel [90cb69f3, c94e28f1, 46da22b0, 5a609fa4,\n      383779ed] (Pavlo Yatsukhnenko)\n\n    * Housekeeping (spelling, doc changes, etc) [23f9de30, d07a8df6, 2d39b48d,\n      0ef488fc, 2c35e435, f52bd8a8, 2ddc5f21, 1ff7dfb7, db446138] (Tyson Andre,\n      Pavlo Yatsukhnenko, Michael Grunder, Tyson Andre)\n\n    * Fix for ASK redirections [ba73fbee] (Michael Grunder)\n    * Create specific 'test skipped' exception [c3d83d44] (Michael Grunder)\n    * Fixed memory leaks in RedisCluster [a107c9fc] (Michael Grunder)\n    * Fixes for session lifetime values that underflow or overflow  [7a79ad9c,\n      3c48a332] (Michael Grunder)\n    * Enables slot caching for Redis Cluster [23b1a9d8] (Michael Booth)\n\n    * Support TYPE argument for SCAN [8eb39a26, b1724b84, 53fb36c9, 544e641b]\n      (Pavlo Yatsukhnenko)\n\n    * Added challenge/response mechanism for persistent connections [a5f95925,\n      25cdaee6, 7b6072e0, 99ebd0cc, 3243f426] (Pavlo Yatsukhnenko, Michael Grunder)\n   </notes>\n  </release>\n  <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>5.1.1</release><api>5.1.0</api></version>\n   <date>2019-11-11</date>\n   <notes>\n      phpredis 5.1.1\n\n      This release contains only bugfix for unix-socket connection.\n\n      * Fix fail to connect to redis through unix socket [2bae8010, 9f4ededa] (Pavlo Yatsukhnenko, Michael Grunder)\n      * Documentation improvements (@fitztrev)\n   </notes>\n  </release>\n\n  <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>5.1.0</release><api>5.1.0</api></version>\n   <date>2019-10-31</date>\n   <notes>\n      This release contains important bugfixes and improvements.\n\n      phpredis 5.1.0\n\n      * Allow to specify scheme for session handler [53a8bcc7] (Pavlo Yatsukhnenko)\n      * Add documentation for hyperloglog [75a6f3fa, 96a0f0c3, 9686757a] (@rlunar)\n\n      phpredis 5.1.0RC2\n\n      * Fix missing null byte in PHP_MINFO_FUNCTION [8bc2240c] (Remi Collet)\n      * Remove dead code generic_unsubscribe_cmd [8ee4abbc] (Pavlo Yatsukhnenko)\n      * Add documentation for zpopmin and zpopmax [99ec24b3, 4ab1f940] (@alexander-schranz)\n\n      phpredis 5.1.0RC1\n\n      * Fix regression for multihost_distribute_call added in 112c77e3 [fbe0f804] (Pavlo Yatsukhnenko)\n      * Fix regression for conntecting to unix sockets with relative path added in 1f41da64 [17b139d8, 7ef17ce1] (Pavlo Yatsukhnenko)\n      * Fix unix-socket detection logic broken in 418428fa [a080b73f] (Pavlo Yatsukhnenko)\n      * Fix memory leak and bug with getLastError for redis_mbulk_reply_assoc and redis_mbulk_reply_zipped. [7f42d628, 3a622a07] (Pavlo Yatsukhnenko), (Michael Grunder)\n      * Fix bug with password contain \"#\" for redis_session [2bb08680] (Pavlo Yatsukhnenko)\n      * Add optional support for Zstd compression, using --enable-redis-ztsd. This requires libzstd version >= 1.3.0 [2abc61da] (Remi Collet)\n      * Fix overallocation in RedisCluster directed node commands [cf93649] (Michael Grunder)\n      * Also attach slaves when caching cluster slots [0d6d3fdd, b114fc26] (Michael Grunder)\n      * Use zend_register_persistent_resource_ex for connection pooling [fdada7ae, 7c6c43a6] (Pavlo Yatsukhnenko)\n      * Refactor redis_session [91a8e734, 978c3074] (Pavlo Yatsukhnenko)\n      * Documentation improvements (@Steveb-p, @tangix, @ljack-adista, @jdreesen, Michael Grunder)\n   </notes>\n  </release>\n\n  <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>5.0.0</release><api>5.0.0</api></version>\n   <date>2019-07-02</date>\n   <notes>\n    This release contains important improvements and breaking changes.\n    The most interesting are: drop PHP5 support, RedisCluster slots caching,\n    JSON and msgpack serializers, soft deprecation of non-Redis commands.\n\n    phpredis 5.0.0\n\n    * Remove HAVE_SPL [55c5586c] (@petk)\n    * Update Fedora installation instructions [90aa067c] (@remicollet)\n\n    phpredis 5.0.0RC2\n\n    * Allow compilation without JSON serialization enabled and fixes for deprecated\n      helper methods.  [235a27] (Pavlo Yatsukhnenko)\n    * Fix php msgpack >= 2.0.3 version requirement. [6973478..a537df8] (Michael Grunder)\n\n    phpredis 5.0.0RC1\n\n    * Enable connection pooling by default [8206b147] (Pavlo Yatsukhnenko)\n    * Soft deprecate methods that aren't actually Redis commands [a81b4f2d, 95c8aab9] (Pavlo Yatsukhnenko, Michael Grunder)\n    * Enable pooling for cluster slave nodes [17600dd1] (Michael Grunder)\n    * xInfo response format [4852a510, ac9dca0a] (Pavlo Yatsukhnenko)\n    * Make the XREADGROUP optional COUNT and BLOCK arguments nullable [0c17bd27] (Michael Grunder)\n    * Allow PING to take an optional argument [6e494170] (Michael Grunder)\n    * Allow ZRANGE to be called either with `true` or `['withscores' => true]` [19f3efcf] (Michael Grunder)\n    * Allow to specify server address as schema://host [418428fa] (Pavlo Yatsukhnenko)\n    * Allow persistent_id to be passed as NULL with strict_types enabled [60223762] (Michael Grunder)\n    * Add server address to exception message [e8fb49be, 34d6403d] (Pavlo Yatsukhnenko)\n    * Adds OPT_REPLY_LITERAL for rawCommand and EVAL [5cb30fb2] (Michael Grunder)\n    * JSON serializer [98bd2886, 96c57139] (Pavlo Yatsukhnenko, Michael Grunder)\n    * Add support for STREAM to the type command [d7450b2f, 068ce978, 8a45d18c] (Michael Grunder, Pavlo Yatsukhnenko)\n    * Fix TypeError when using built-in constants in `setOption` [4c7643ee] (@JoyceBabu)\n    * Handle references in MGET [60d8b679] (Michael Grunder)\n    * msgpack serializer [d5b8f833, 545250f3, 52bae8ab] (@bgort, Pavlo Yatsukhnenko, Michael Grunder)\n    * Add RedisCluster slots caching [9f0d7bc0, ea081e05] (Michael Grunder)\n    * Drop PHP5 support [f9928642, 46a50c12, 4601887d, 6ebb36ce, fdbe9d29] (Michael Grunder)\n    * Documentation improvements (@alexander-schranz, @cookieguru, Pavlo Yatsukhnenko, Michael Grunder)\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>4.3.0</release><api>4.3.0</api></version>\n   <date>2019-03-13</date>\n   <notes>\n      phpredis 4.3.0\n\n      This is probably the last release with PHP 5 support!!!\n\n      * Proper persistent connections pooling implementation [a3703820, c76e00fb, 0433dc03, c75b3b93] (Pavlo Yatsukhnenko)\n      * RedisArray auth [b5549cff, 339cfa2b, 6b411aa8] (Pavlo Yatsukhnenko)\n      * Use zend_string for storing key hashing algorithm [8cd165df, 64e6a57f] (Pavlo Yatsukhnenko)\n      * Add ZPOPMAX and ZPOPMIN support [46f03561, f89e941a, 2ec7d91a] (@mbezhanov, Michael Grunder)\n      * Implement GEORADIUS_RO and GEORADIUSBYMEMBER_RO [22d81a94] (Michael Grunder)\n      * Add callback parameter to subscribe/psubscribe arginfo [0653ff31] (Pavlo Yatsukhnenko)\n      * Don't check the number affected keys in PS_UPDATE_TIMESTAMP_FUNC [b00060ce] (Pavlo Yatsukhnenko)\n      * Xgroup updates [15995c06] (Michael Grunder)\n      * RedisCluster auth [c5994f2a] (Pavlo Yatsukhnenko)\n      * Cancel pipeline mode without executing commands [789256d7] (Pavlo Yatsukhnenko)\n      * Use zend_string for pipeline_cmd [e98f5116] (Pavlo Yatsukhnenko)\n      * Different key hashing algorithms from hash extension [850027ff] (Pavlo Yatsukhnenko)\n      * Breaking the lock acquire loop in case of network problems [61889cd7] (@SkydiveMarius)\n      * Implement consistent hashing algorithm for RedisArray [bb32e6f3, 71922bf1] (Pavlo Yatsukhnenko)\n      * Use zend_string for storing RedisArray hosts [602740d3, 3e7e1c83] (Pavlo Yatsukhnenko)\n      * Update lzf_compress to be compatible with PECL lzf extension [b27fd430] (@jrchamp)\n      * Fix RedisCluster keys memory leak [3b56b7db] (Michael Grunder)\n      * Directly use return_value in RedisCluster::keys method [ad10a49e] (Pavlo Yatsukhnenko)\n      * Fix segfault in Redis Cluster with inconsistent configuration [72749916, 6e455e2e] (Pavlo Yatsukhnenko)\n      * Masters info leakfix [91bd7426] (Michael Grunder)\n      * Refactor redis_sock_read_bulk_reply [bc4dbc4b] (Pavlo Yatsukhnenko)\n      * Remove unused parameter lazy_connect from redis_sock_create [c0793e8b] (Pavlo Yatsukhnenko)\n      * Remove useless ZEND_ACC_[C|D]TOR. [bc9b5597] (@twosee)\n      * Documentation improvements (@fanjiapeng, @alexander-schranz, @hmc, Pavlo Yatsukhnenko, Michael Grunder)\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>beta</release><api>beta</api></stability>\n   <version><release>4.2.0RC3</release><api>4.2.0RC3</api></version>\n   <date>2018-11-08</date>\n   <notes>\n      phpredis 4.2.0RC3\n\n      The main feature of this release is new Streams API implemented by Michael Grunder.\n\n      4.2.0RC3:\n\n      * Optimize close method [2a1ef961] (fanjiapeng)\n      * Prevent potential infinite loop for sessions [4e2de158] (Pavlo Yatsukhnenko)\n      * Fix coverty warnings [6f7ddd27] (Pavlo Yatsukhnenko)\n      * Fix session memory leaks [071a1d54, 92f14b14] (Pavlo Yatsukhnenko, Michael Grunder)\n      * Fix XCLAIM on 32-bit installs [18dc2aac] (Michael Grunder)\n      * Build warning fixes [b5093910, 51027044, 8b0f28cd] (Pavlo Yatsukhnenko, Remi Collet, twosee)\n\n      4.2.0RC2:\n\n      * Fix incorrect arginfo for `Redis::sRem` and `Redis::multi` [25b043ce] (Pavlo Yatsukhnenko)\n      * Update STREAM API to handle STATUS -> BULK reply change [0b97ec37] (Michael Grunder)\n      * Treat a -1 response from cluster_check_response as a timeout. [27df9220, 07ef7f4e, d1172426] (Michael Grunder)\n      * Use a ZSET instead of SET for EVAL tests [2e412373] (Michael Grunder)\n      * Missing space between command and args [0af2a7fe] (@remicollet)\n\n      4.2.0RC1:\n\n      * Streams API [2c9e0572] (Michael Grunder)\n      * Reset the socket after a timeout to make sure no wrong data is received [cd6ebc6d] (@marcdejonge)\n      * Modify session testing logic [bfd27471] (Michael Grunder)\n      * Allow '-' and '+' arguments and add tests for zLexCount and zRemRangeByLex [d4a08697] (Michael Grunder)\n      * Fix printf format warnings [dcde9331] (Pavlo Yatsukhnenko)\n      * Session module is required [58bd8cc8] (@remicollet)\n      * Set default values for ini entries [e206ce9c] (Pavlo Yatsukhnenko)\n      * Display ini entries in output of phpinfo [908ac4b3] (Pavlo Yatsukhnenko)\n      * Persistent connections can be closed via close method + change reconnection logic [1d997873] (Pavlo Yatsukhnenko)\n      * Documentation improvements (@mg, @elcheco, @lucascourot, @nolimitdev, Michael Grunder)\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>4.1.1</release><api>4.1.1</api></version>\n   <date>2018-08-01</date>\n   <notes>\n      phpredis 4.1.1\n\n      This release contains only bugfixes and documentation improvements\n\n      * Fix arginfo for Redis::set method [0c5e7f4d] (Pavlo Yatsukhnenko)\n      * Fix compression in RedisCluster [a53e1a34] (Pavlo Yatsukhnenko)\n      * Fix TravisCI builds [9bf32d30] (@jrchamp)\n      * Highlight php codes in documentation [c3b023b0] (@ackintosh)\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>4.1.0</release><api>4.1.0</api></version>\n   <date>2018-01-10</date>\n   <notes>\n      phpredis 4.1.0\n\n      The primary new feature of this release is session locking functionality. Thanks to @SkydiveMarius!\n\n      * Add callbacks validate_sid and update_timestamp to session handler [aaaf0f23] (@hongboliu)\n      * Call cluster_disconnect before destroying cluster object. [28ec4322] (Pavlo Yatsukhnenko)\n      * Bulk strings can be zero length. (Michael Grunder)\n      * Handle async parameter for flushDb and flushAll [beb6e8f3,acd10409,742cdd05] (Pavlo Yatsukhnenko)\n      * Split INSTALL and add more instructions [43613d9e,80d2a917] (@remicollet, Pavlo Yatsukhnenko)\n      * Only the first arg of connect and pconnect is required [063b5c1a] (@mathroc)\n      * Add session locking functionality [300c7251] (@SkydiveMarius, Michael Grunder, Pavlo Yatsukhnenko)\n      * Fix compression in RedisCluster [1aed74b4] (Pavlo Yatsukhnenko)\n      * Refactor geo* commands + documentation improvements (Michael Grunder)\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>4.0.2</release><api>4.0.2</api></version>\n   <date>2018-04-25</date>\n   <notes>\n      phpredis 4.0.2\n\n      This release contains only fix of exists method to take multiple keys\n      and return integer value (was broken in 4.0.1) Thanks @RanjanRohit!\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>4.0.1</release><api>4.0.1</api></version>\n   <date>2018-04-18</date>\n   <notes>\n      phpredis 4.0.1\n\n      * Fix arginfo for connect/pconnect issue #1337 [c3b228] (@mathroc)\n      * Don't leak a ZVAL [278232] (Michael Grunder)\n      * Fix config.m4 for lzf issue #1325 [20e173] (Pavlo Yatsukhnenko)\n      * Updates EXISTS documentation and notes change in 4.0.0 [bed186] (Michael Grunder)\n      * Fix typo in notes [0bed36] (@szepeviktor)\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>4.0.0</release><api>4.0.0</api></version>\n   <date>2018-03-17</date>\n   <notes>\n    phpredis 4.0.0\n\n    *** WARNING! THIS RELEASE CONTAINS BREAKING API CHANGES! ***\n\n    * Add proper ARGINFO for all methods. (Pavlo Yatsukhnenko, Michael Grunder)\n    * Let EXISTS take multiple keys [cccc39] (Michael Grunder)\n    * Use zend_string as returning value for ra_extract_key and ra_call_extractor [9cd05911] (Pavlo Yatsukhnenko)\n    * Implement SWAPDB and UNLINK commands [84f1f28b, 9e65c429] (Michael Grunder)\n    * Return real connection error as exception [5b9c0c60] (Pavlo Yatsukhnenko, Michael Grunder)\n    * Disallow using empty string as session name. [485db46f] (Pavlo Yatsukhnenko)\n    * Use zend_string for storing auth and prefix members [4b8336f7] (Pavlo Yatsukhnenko)\n    * The element of z_seeds may be a reference on php7 [367bc6aa, 1e63717a] (@janic716)\n    * Avoid connection in helper methods [91e9cfe1] (Pavlo Yatsukhnenko)\n    * Add tcp_keepalive option to redis sock [68c58513, 5101172a, 010336d5, 51e48729] (@git-hulk, Michael Grunder)\n    * More robust GEORADIUS COUNT validation [f7edee5d] (Michael Grunder)\n    * Add LZF compression (experimental) [e2c51251, 8cb2d5bd, 8657557] (Pavlo Yatsukhnenko)\n    * Allow to use empty string as persistent_id [ec4fd1bd] (Pavlo Yatsukhnenko)\n    * Don't use convert_to_string in redis_hmget_cmd [99335d6] (Pavlo Yatsukhnenko)\n    * Allow mixing MULTI and PIPELINE modes (experimental) [5874b0] (Pavlo Yatsukhnenko)\n    * PHP >=7.3.0 uses zend_string to store `php_url` elements [b566fb44] (@fmk)\n    * Documentation improvements (Michael Grunder, @TomA-R)\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>3.1.6</release><api>3.1.6</api></version>\n   <date>2018-01-03</date>\n   <notes>\n    phpredis 3.1.6\n\n    This release contains only fix of RedisArray distributor hashing function\n    which was broken in 3.1.4. Huge thanks to @rexchen123\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>3.1.5</release><api>3.1.5</api></version>\n   <date>2017-12-20</date>\n   <notes>\n    phpredis 3.1.5\n\n    This is interim release which contains only bug fixes.\n\n    * Fix segfault when extending Redis class in PHP 5 [d23eff] (Pavlo Yatsukhnenko)\n    * Fix RedisCluster constructor with PHP 7 strict scalar type [5c21d7] (Pavlo Yatsukhnenko)\n    * Allow to use empty string as persistent_id [344de5] (Pavlo Yatsukhnenko)\n    * Fix cluster_init_seeds. [db1347] (@adlagares)\n    * Fix z_seeds may be a reference [42581a] (@janic716)\n    * PHP >=7.3 uses zend_string for php_url elements [b566fb] (@fmk)\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>3.1.4</release><api>3.1.4</api></version>\n   <date>2017-09-27</date>\n   <notes>\n    phpredis 3.1.4\n\n    The primary new feature phpredis 3.1.4 is the ability to send MULTI .. EXEC blocks in pipeline mode.  There are\n    also many bugfixes and minor improvements to the api, listed below:\n\n    * Allow mixing MULTI and PIPELINE modes (experimental)!  [5874b0] (Pavlo Yatsukhnenko)\n\n    * Added integration for coverty static analysis and fixed several warnings\n      [faac8b0, eff7398, 4766c25, 0438ab4, 1e0b065, 733732a, 26eeda5, 735025, 42f1c9, af71d4] (Pavlo Yatsukhnenko)\n    * Added arginfo inrospection structures [81a0303, d5609fc, e5660be, 3c60e1f, 50dcb15, 6c2c6fa,\n      212e323, e23be2c, 682593d, f8de702, 4ef3acd, f116be9, 5c111dd, 9caa029, 0d69650, 6859828, 024e593,\n      3643ab6, f576fab, 122d41f, a09d0e6] (Tyson Andre, Pavlo Yatsukhnenko)\n    * Fixed link to redis cluster documentation [3b0b06] (Pavlo Yatsukhnenko)\n    * Remove unused PHP_RINIT and PHP_RSHUTDOWN functions [c760bf] (Pavlo Yatsukhnenko)\n    * Removed duplicate HGET in redis array hash table, formatting [d0b9c5] (Pavlo Yatsukhnenko)\n    * Treat NULL bulk as success for session read [659450] (Pavlo Yatsukhnenko)\n    * Refactor redis_send_discard [ea15ce] (Pavlo Yatsukhnenko)\n    * Updated runtime exception handling [8dcaa4, 7c1407] (Pavlo Yatsukhnenko)\n    * Added a github issue template [61aba9] (Pavlo Yatsukhnenko)\n    * Initialize gc member of zend_string [37f569) (Pavlo Yatsukhnenko)\n    * Fix valgrind warnings [471ce07, 1ab89e1, b624a8b] (Pavlo Yatsukhnenko)\n    * Fix php5/php7 compatibility layer [1ab89e, 4e3225] (Pavlo Yatsukhnenko)\n    * Fix typo in README.markdown [e47e44] (Mark Shehata)\n    * Improve redis array rehash [577a91] (Pavlo Yatsukhnenko)\n    * Change redis array pure_cmds from zval to hashtable [a56ed7] (Pavlo Yatsukhnenko)\n    * Don't try to set TCP_NODELAY on a unix socket and don't warn on multiple\n      calls to pipeline [d11798, 77aeba] (Michael Grunder)\n    * Use zend_string rather than char* for various context fields (err, prefix, etc) [2bf7b2] (Pavlo Yatsukhnenko)\n    * Various other library fixes [142b51, 4452f6, e672f4, 658ee3, c9df77, 4a0a46] (Pavlo Yatsukhnenko)\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>3.1.3</release><api>3.1.3</api></version>\n   <date>2017-07-15</date>\n   <notes>\n    phpredis 3.1.3\n\n    This release contains two big improvements:\n      1. Adding a new printf like command construction function with additionally format specifiers specific to phpredis.\n      2. Implementation of custom objects for Redis and RedisArray which eliminates double hash lookup.\n    Also many small improvements and bug fixes were made.\n\n    * A printf like method to construct a Redis RESP command [a4a0ed, d75081, bdd287, 0eaeae, b3d00d] (Michael Grunder)\n    * Use custom objects instead of zend_list for storing Redis/RedisArray [a765f8, 8fa85a] (Pavlo Yatsukhnenko)\n    * Make sure redisCluster members are all initialized on (re)creation [162d88] (Michael Grunder)\n    * Fix Null Bulk String response parsing in cluster library [058753] (Alberto Fernandez)\n    * Add hStrLen command [c52077, fb88e1] (Pavlo Yatsukhnenko)\n    * Add optional COUNT argument to sPop [d2e203] (Michael Grunder)\n    * Allow sInterStore to take one arg [26aec4, 4cd06b] (Michael Grunder)\n    * Allow MIGRATE to accept multiple keys [9aa3db] (Michael Grunder)\n    * Allow using numeric string in zInter command [ba0070] (Pavlo Yatsukhnenko)\n    * Use crc32 table from PHP distro [f81694] (Pavlo Yatsukhnenko)\n    * Use ZVAL_DEREF macros for dereference input variables [ad4596] (Pavlo Yatsukhnenko)\n    * Add configureoption tag to package.xml [750963] (Pavlo Yatsukhnenko)\n    * Fix read_timeout [18149e, b56dc4] (Pavlo Yatsukhnenko)\n    * Fix zval_get_string impl for PHP5 [4e56ba] (Pavlo Yatsukhnenko)\n    * Fix Redis/RedisArray segfaults [be5c1f, 635c3a, 1f8dde, 43e1e0] (Pavlo Yatsukhnenko)\n    * Fix memory leak and potential segfault [aa6ff7, 88efaa] (Michael Grunder)\n    * Throw exception for all non recoverable errors [e37239] (Pavlo Yatsukhnenko)\n    * Assume \"NULL bulk\" reply as success (empty session data) [4a81e1] (Pavlo Yatsukhnenko)\n    * Increase read buffers size [520e06] (Pavlo Yatsukhnenko)\n    * Better documentation [f0c25a, c5991f, 9ec9ae] (Michael Grunder)\n    * Better TravisCI integration [e37c08] (Pavlo Yatsukhnenko)\n    * Refactoring (Pavlo Yatsukhnenko, Michael Grunder)\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>3.1.2</release><api>3.1.2</api></version>\n   <date>2017-03-16</date>\n   <notes>\n   phpredis 3.1.2\n\n   * RedisArray segfault fix [564ce3] (Pavlo Yatsukhnenko)\n   * Small memory leak fix [645888b] (Mike Grunder)\n   * Segfault fix when recreating RedisCluster objects [abf7d4] (Michael Grunder)\n   * Fix for RedisCluster bulk response parsing [4121c4] (Alberto Fernandez)\n   * Re allow single array for sInterStore [6ef0c2, d01966] (Michael Grunder)\n   * Better TravisCI integration [4fd2f6] (Pavlo Yatsukhnenko)\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>beta</release><api>beta</api></stability>\n   <version><release>3.1.1RC2</release><api>3.1.1RC2</api></version>\n   <date>2017-01-16</date>\n   <notes>\n\n    phpredis 3.1.1RC2\n\n    * Additional test updates for 32 bit systems (@remicollet)\n    * ARM rounding issue in tests (@remicollet)\n    * Use new zend_list_close instead of zend_list_delete when reconnecting.\n    * Refactoring of redis_boolean_response_impl and redis_sock_write (@yatsukhnenko)\n\n    phpredis 3.1.1.RC1\n\n    This release contains mostly fixes for issues introduced when merging\n    the php 5 and 7 codebase into a single branch.\n\n    * Fixed a segfault in igbinary serialization (@yatsukhnenko)\n    * Restore 2.2.8/3.0.0 functionality to distinguish between an error\n      and simply empty session data. (@remicollet)\n    * Fix double to string conversion function (@yatsukhnenko)\n    * Use PHP_FE_END definition when available (@remicollet)\n    * Fixed various 'static function declared but not used' warnings\n    * Fixes to various calls which were typecasting pointers to the\n      wrong size. (@remicollet)\n\n    * Added php session unit test (@yatsukhnenko)\n    * Added explicit module dependency for igbinary (@remicollet)\n    * Added phpinfo serialization information (@remicollet)\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>3.1.0</release><api>3.1.0</api></version>\n   <date>2016-12-14</date>\n   <notes>\n    phpredis 3.1.0\n\n    In this version of phpredis codebase was unified to work with all versions of php \\o/\n    Also many bug fixes and some improvements has been made.\n\n    --- Improvements ---\n\n    * Support the client to Redis Cluster just having one master (andyli) [892e5646]\n    * Allow both long and strings that are longs for zrangebyscore offset/limit (Michael Grunder) [bdcdd2aa]\n    * Process NX|XX, CH and INCR options in zAdd command (Pavlo Yatsukhnenko) [71c9f7c8]\n\n    --- Fixes ---\n\n    * Fix incrby/decrby for large integers (Michael Grunder) [3a12758a]\n    * Use static declarations for spl_ce_RuntimeException decl (Jeremy Mikola) [a9857d69]\n    * Fixed method call problem causes session handler to display two times (ZiHang Gao) [24f86c49]\n    * psetex method returns '+OK' on success, not true (sitri@ndxbn) [afcd8445]\n    * Fix integer overflow for long (>32bit) increments in hIncrBy (iyesin) [58e1d799]\n    * Move zend_object handler to the end (Michael Grunder) [34107966]\n    * Using setOption on redis array causes immediate connection (Pavlo Yatsukhnenko) [f1a85b38]\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>2.2.8</release><api>2.2.8</api></version>\n   <date>2016-06-02</date>\n   <notes>\n    phpredis 2.2.8\n\n    The main improvement in this version of phpredis is support for Redis\n    Cluster.  This version of phpredis is intended for versions of php older\n    than 7.\n\n    In addition there have been many bug fixes and improvements to non cluster\n    related commands, which are listed below.\n\n    I've attempted to include everyone who contributed to the project in each fix\n    description and have included names or github user ids.\n\n    Thanks to everyone for submitting bug reports and pull requests.  A special\n    thanks to Remi Collet for helping with any and all packaging related issues\n\n    \\o/\n\n    --- Improvements ---\n\n    * Added randomization to our seed nodes to balance which instance is used\n      to map the keyspace (Vitaliy Stepanyuk) [32eb1c5f]\n    * Added support for IPv6 addresses\n\n    --- Fixes ---\n\n    * PHP liveness checking workaround (Shafreeck Sea) [c18d58b9]\n    * Various documentation and code formatting and style fixes (ares333,\n      sanpili, Bryan Nelson, linfangrong, Romero Malaquias, Viktor Szepe)\n    * Fix scan reply processing to use long instead of int to avoid overflow\n      (mixiaojiong).\n    * Fix potential segfault in Redis Cluster session storage (Sergei Lomakov)\n      [cc15aae]\n    * Fixed memory leak in discard function [17b1f427]\n    * Sanity check for igbinary unserialization (Maurus Cuelenaere) [3266b222,\n      5528297a]\n    * Fix segfault occurring from unclosed socket connection for Redis Cluster\n      (CatKang) [04196aee]\n    * Case insensitive zRangeByScore options\n    * Fixed dreaded size_t vs long long compiler warning\n   </notes>\n   </release>\n\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>2.2.7</release><api>2.2.7</api></version>\n   <date>2015-03-03</date>\n   <notes>\n      phpredis 2.2.7\n\n       -- Improvements ---\n\n       * Implemented PFADD, PFMERGE, and PFCOUNT command handling\n       * Implemented ZRANGEBYLEX command (holding off on ZREVRANGEBYLEX\n         as that won't be out until 3.0)\n       * Implemented getMode() so clients can detect whether we're in\n         ATOMIC/MULTI/PIPELINE mode.\n       * Implemented rawCommand() so clients can send arbitrary things to\n         the redis server\n       * Implemented DEBUG OBJECT (@michael-grunder, @isage)\n       * Added/abide by connect timeout for RedisArray\n       * Select to the last selected DB when phpredis reconnects\n\n       -- Fixes ---\n\n       * Fix a possible invalid free in _serialize\n       * Added SAVE and BGSAVE to \"distributable\" commands for RedisArray\n       * @welting -- Fixed invalid \"argc\" calculation re HLL commands\n       * Allow clients to break out of the subscribe loop and return context.\n       * Fixes a memory leak in SCAN when OPT_SCAN_RETRY id.\n       * @remicollet -- Fix possible segfault when igbinary is enabled.\n       * Add a couple of cases where we throw on an error (LOADING/NOAUTH/MASTERDOWN)\n       * Fix several issues with serialization NARY\n       * @itcom -- Fix missing TSRMLS_CC and a TSRMLS_DC/TSRMLS_CC typo\n   </notes>\n   </release>\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>2.2.5</release><api>2.2.5</api></version>\n   <date>2014-03-15</date>\n   <notes>\n    phpredis 2.2.5\n\n    This is a minor release with several bug fixes as well as additions to support\n    new commands that have been introduced to Redis since our last release.\n\n    A special thanks to everyone who helps the project by commenting on issues and\n    submitting pull requests!  :)\n\n    [NEW] Support for the BITPOS command\n    [NEW] Connection timeout option for RedisArray (@MikeToString)\n    [NEW] A _serialize method, to complement our existing _unserialize method\n    [NEW] Support for the PUBSUB command\n    [NEW] Support for SCAN, SSCAN, HSCAN, and ZSCAN\n    [NEW] Support for the WAIT command\n\n    [FIX] Handle the COPY and REPLACE arguments for the MIGRATE command\n\n    [DOC] Fix syntax error in documentation for the SET command (@mithunsatheesh)\n    [DOC] Homebrew documentation instructions (@mathias)\n\n   </notes>\n   </release>\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>2.2.4</release><api>2.2.4</api></version>\n   <date>2013-09-01</date>\n   <notes>\n   **\n   ** Features / Improvements\n   **\n\n   * Randomized reconnect delay for RedisArray @mobli\n     This feature adds an optional parameter when constructing a RedisArray object\n     such that a random delay will be introduced if reconnections are made,\n     mitigating any &apos;thundering herd&apos; type problems.\n\n   * Lazy connections to RedisArray servers @mobli\n     By default, RedisArray will attempt to connect to each server you pass in\n     the ring on construction.  This feature lets you specify that you would\n     rather have RedisArray only attempt a connection when it needs to get data\n     from a particular node (throughput/performance improvement).\n\n   * Allow LONG and STRING keys in MGET/MSET\n   * Extended SET options for Redis &gt;= 2.6.12\n   * Persistent connections and UNIX SOCKET support for RedisArray\n   * Allow aggregates for ZUNION/ZINTER without weights @mheijkoop\n   * Support for SLOWLOG command\n   * Reworked MGET algorithm to run in linear time regardless of key count.\n   * Reworked ZINTERSTORE/ZUNIONSTORE algorithm to run in linear time\n\n   **\n   ** Bug fixes\n   **\n\n   * C99 Compliance (or rather lack thereof) fix @mobli\n   * Added ZEND_ACC_CTOR and ZEND_ACC_DTOR @euskadi31\n   * Stop throwing and clearing an exception on connect failure @matmoi\n   * Fix a false positive unit test failure having to do with TTL returns\n   </notes>\n  </release>\n   <release>\n   <stability><release>stable</release><api>stable</api></stability>\n   <version><release>2.2.3</release><api>2.2.3</api></version>\n   <date>2013-04-29</date>\n   <notes>\n    First release to PECL\n   </notes>\n  </release>\n </changelog>\n</package>\n"
        },
        {
          "name": "php_redis.h",
          "type": "blob",
          "size": 2.35546875,
          "content": "/*\n  +----------------------------------------------------------------------+\n  | Copyright (c) 1997-2009 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt                                  |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Original author: Alfonso Jimenez <yo@alfonsojimenez.com>             |\n  | Maintainer: Nicolas Favre-Felix <n.favre-felix@owlient.eu>           |\n  | Maintainer: Michael Grunder <michael.grunder@gmail.com>              |\n  | Maintainer: Nasreddine Bouafif <n.bouafif@owlient.eu>                |\n  +----------------------------------------------------------------------+\n*/\n\n#include \"common.h\"\n\n#ifndef PHP_REDIS_H\n#define PHP_REDIS_H\n\n/* phpredis version */\n#define PHP_REDIS_VERSION \"6.1.0\"\n\n/* For convenience we store the salt as a printable hex string which requires 2\n * characters per byte + 1 for the NULL terminator */\n#define REDIS_SALT_BYTES 32\n#define REDIS_SALT_SIZE ((2 * REDIS_SALT_BYTES) + 1)\n\nZEND_BEGIN_MODULE_GLOBALS(redis)\n\tchar salt[REDIS_SALT_SIZE];\nZEND_END_MODULE_GLOBALS(redis)\n\nZEND_EXTERN_MODULE_GLOBALS(redis)\n#define REDIS_G(v) ZEND_MODULE_GLOBALS_ACCESSOR(redis, v)\n\n#ifdef ZTS\n#include \"TSRM.h\"\n#endif\n\nPHP_MINIT_FUNCTION(redis);\nPHP_MSHUTDOWN_FUNCTION(redis);\nPHP_MINFO_FUNCTION(redis);\n\nPHP_REDIS_API int redis_connect(INTERNAL_FUNCTION_PARAMETERS, int persistent);\n\nPHP_REDIS_API int redis_response_enqueued(RedisSock *redis_sock);\n\nPHP_REDIS_API int redis_sock_read_multibulk_multi_reply_loop(\n    INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab);\n\nextern zend_module_entry redis_module_entry;\n\n#define redis_module_ptr &redis_module_entry\n#define phpext_redis_ptr redis_module_ptr\n\n#endif\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */\n"
        },
        {
          "name": "redis.c",
          "type": "blob",
          "size": 82.6435546875,
          "content": "/* -*- Mode: C; tab-width: 4 -*- */\n/*\n  +----------------------------------------------------------------------+\n  | Copyright (c) 1997-2009 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt                                  |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Original author: Alfonso Jimenez <yo@alfonsojimenez.com>             |\n  | Maintainer: Nicolas Favre-Felix <n.favre-felix@owlient.eu>           |\n  | Maintainer: Nasreddine Bouafif <n.bouafif@owlient.eu>                |\n  | Maintainer: Michael Grunder <michael.grunder@gmail.com>              |\n  +----------------------------------------------------------------------+\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"php_redis.h\"\n#include \"redis_array.h\"\n#include \"redis_cluster.h\"\n#include \"redis_commands.h\"\n#include \"redis_sentinel.h\"\n#include <ext/spl/spl_exceptions.h>\n#include <zend_exceptions.h>\n#include <ext/standard/info.h>\n#include <ext/hash/php_hash.h>\n\n#if PHP_VERSION_ID < 80400\n#include <ext/standard/php_random.h>\n#else\n#include <ext/random/php_random.h>\n#endif\n\n#ifdef PHP_SESSION\n#include <ext/session/php_session.h>\n#endif\n\n#include \"library.h\"\n\n#ifdef HAVE_REDIS_ZSTD\n#include <zstd.h>\n#endif\n\n#ifdef HAVE_REDIS_LZ4\n#include <lz4.h>\n#endif\n\n#ifdef PHP_SESSION\nextern ps_module ps_mod_redis;\nextern ps_module ps_mod_redis_cluster;\n#endif\n\nzend_class_entry *redis_ce;\nzend_class_entry *redis_exception_ce;\n\n#if PHP_VERSION_ID < 80000\n#include \"redis_legacy_arginfo.h\"\n#else\n#include \"zend_attributes.h\"\n#include \"redis_arginfo.h\"\n#endif\n\nextern const zend_function_entry *redis_get_methods(void)\n{\n    return class_Redis_methods;\n}\n\nextern int le_cluster_slot_cache;\nint le_redis_pconnect;\n\nPHP_INI_BEGIN()\n    /* redis arrays */\n    PHP_INI_ENTRY(\"redis.arrays.algorithm\", \"\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.arrays.auth\", \"\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.arrays.autorehash\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.arrays.connecttimeout\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.arrays.distributor\", \"\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.arrays.functions\", \"\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.arrays.hosts\", \"\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.arrays.index\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.arrays.lazyconnect\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.arrays.names\", \"\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.arrays.pconnect\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.arrays.previous\", \"\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.arrays.readtimeout\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.arrays.retryinterval\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.arrays.consistent\", \"0\", PHP_INI_ALL, NULL)\n\n    /* redis cluster */\n    PHP_INI_ENTRY(\"redis.clusters.cache_slots\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.clusters.auth\", \"\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.clusters.persistent\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.clusters.read_timeout\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.clusters.seeds\", \"\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.clusters.timeout\", \"0\", PHP_INI_ALL, NULL)\n\n    /* redis pconnect */\n    PHP_INI_ENTRY(\"redis.pconnect.pooling_enabled\", \"1\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.pconnect.connection_limit\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.pconnect.echo_check_liveness\", \"1\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.pconnect.pool_detect_dirty\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.pconnect.pool_poll_timeout\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.pconnect.pool_pattern\", \"\", PHP_INI_ALL, NULL)\n\n    /* redis session */\n    PHP_INI_ENTRY(\"redis.session.locking_enabled\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.session.lock_expire\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.session.lock_retries\", \"100\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.session.lock_wait_time\", \"20000\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.session.early_refresh\", \"0\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.session.compression\", \"none\", PHP_INI_ALL, NULL)\n    PHP_INI_ENTRY(\"redis.session.compression_level\", \"3\", PHP_INI_ALL, NULL)\nPHP_INI_END()\n\nstatic const zend_module_dep redis_deps[] = {\n#ifdef HAVE_REDIS_IGBINARY\n     ZEND_MOD_REQUIRED(\"igbinary\")\n#endif\n#ifdef HAVE_REDIS_MSGPACK\n     ZEND_MOD_REQUIRED(\"msgpack\")\n#endif\n#ifdef HAVE_REDIS_JSON\n     ZEND_MOD_REQUIRED(\"json\")\n#endif\n#ifdef PHP_SESSION\n     ZEND_MOD_REQUIRED(\"session\")\n#endif\n     ZEND_MOD_END\n};\n\nZEND_DECLARE_MODULE_GLOBALS(redis)\n\nzend_module_entry redis_module_entry = {\n     STANDARD_MODULE_HEADER_EX,\n     NULL,\n     redis_deps,\n     \"redis\",\n     NULL,\n     PHP_MINIT(redis),\n     NULL,\n     NULL,\n     NULL,\n     PHP_MINFO(redis),\n     PHP_REDIS_VERSION,\n     PHP_MODULE_GLOBALS(redis),\n     NULL,\n     NULL,\n     NULL,\n     STANDARD_MODULE_PROPERTIES_EX\n};\n\n#ifdef COMPILE_DL_REDIS\nZEND_GET_MODULE(redis)\n#endif\n\nzend_object_handlers redis_object_handlers;\n\n/* Send a static DISCARD in case we're in MULTI mode. */\nstatic int\nredis_send_discard(RedisSock *redis_sock)\n{\n    char *resp;\n    int resp_len, result = FAILURE;\n\n    /* send our DISCARD command */\n    if (redis_sock_write(redis_sock, ZEND_STRL(RESP_DISCARD_CMD)) >= 0 &&\n       (resp = redis_sock_read(redis_sock,&resp_len)) != NULL)\n    {\n        /* success if we get OK */\n        result = (resp_len == 3 && redis_strncmp(resp, ZEND_STRL(\"+OK\")) == 0) ? SUCCESS:FAILURE;\n\n        /* free our response */\n        efree(resp);\n    }\n\n    /* return success/failure */\n    return result;\n}\n\n/* Passthru for destroying cluster cache */\nstatic void cluster_cache_dtor(zend_resource *rsrc) {\n    if (rsrc->ptr) {\n        cluster_cache_free(rsrc->ptr);\n    }\n}\n\nvoid\nfree_redis_object(zend_object *object)\n{\n    redis_object *redis = PHPREDIS_GET_OBJECT(redis_object, object);\n\n    zend_object_std_dtor(&redis->std);\n    if (redis->sock) {\n        redis_sock_disconnect(redis->sock, 0, 1);\n        redis_free_socket(redis->sock);\n    }\n}\n\nzend_object *\ncreate_redis_object(zend_class_entry *ce)\n{\n    redis_object *redis = ecalloc(1, sizeof(redis_object) + zend_object_properties_size(ce));\n\n    redis->sock = NULL;\n\n    zend_object_std_init(&redis->std, ce);\n    object_properties_init(&redis->std, ce);\n\n    memcpy(&redis_object_handlers, zend_get_std_object_handlers(), sizeof(redis_object_handlers));\n    redis_object_handlers.offset = XtOffsetOf(redis_object, std);\n    redis_object_handlers.free_obj = free_redis_object;\n    redis->std.handlers = &redis_object_handlers;\n\n    return &redis->std;\n}\n\nstatic zend_always_inline RedisSock *\nredis_sock_get_instance(zval *id, int no_throw)\n{\n    redis_object *redis;\n\n    if (Z_TYPE_P(id) == IS_OBJECT) {\n        redis = PHPREDIS_ZVAL_GET_OBJECT(redis_object, id);\n        if (redis->sock) {\n            return redis->sock;\n        }\n    }\n    // Throw an exception unless we've been requested not to\n    if (!no_throw) {\n        REDIS_THROW_EXCEPTION(\"Redis server went away\", 0);\n    }\n    return NULL;\n}\n\n/**\n * redis_sock_get\n */\nPHP_REDIS_API RedisSock *\nredis_sock_get(zval *id, int no_throw)\n{\n    RedisSock *redis_sock;\n\n    if ((redis_sock = redis_sock_get_instance(id, no_throw)) == NULL) {\n        return NULL;\n    }\n\n    if (redis_sock_server_open(redis_sock) < 0) {\n        if (!no_throw) {\n            char *errmsg = NULL;\n            if (redis_sock->port < 0) {\n                spprintf(&errmsg, 0, \"Redis server %s went away\", ZSTR_VAL(redis_sock->host));\n            } else {\n                spprintf(&errmsg, 0, \"Redis server %s:%d went away\", ZSTR_VAL(redis_sock->host), redis_sock->port);\n            }\n            REDIS_THROW_EXCEPTION(errmsg, 0);\n            efree(errmsg);\n        }\n        return NULL;\n    }\n\n    return redis_sock;\n}\n\n/**\n * redis_sock_get_direct\n * Returns our attached RedisSock pointer if we're connected\n */\nPHP_REDIS_API RedisSock *redis_sock_get_connected(INTERNAL_FUNCTION_PARAMETERS) {\n    zval *object;\n    RedisSock *redis_sock;\n\n    // If we can't grab our object, or get a socket, or we're not connected,\n    // return NULL\n    if((zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O\",\n       &object, redis_ce) == FAILURE) ||\n       (redis_sock = redis_sock_get(object, 1)) == NULL ||\n       redis_sock->status < REDIS_SOCK_STATUS_CONNECTED)\n    {\n        return NULL;\n    }\n\n    /* Return our socket */\n    return redis_sock;\n}\n\nstatic ZEND_RSRC_DTOR_FUNC(redis_connections_pool_dtor)\n{\n    if (res->ptr) {\n        ConnectionPool *p = res->ptr;\n        zend_llist_destroy(&p->list);\n        pefree(res->ptr, 1);\n    }\n}\n\nstatic void redis_random_hex_bytes(char *dst, size_t dstsize) {\n    char chunk[9], *ptr = dst;\n    ssize_t rem = dstsize, len, clen;\n    size_t bytes;\n\n    /* We need two characters per hex byte */\n    bytes = dstsize / 2;\n    zend_string *s = zend_string_alloc(bytes, 0);\n\n    /* First try to have PHP generate the bytes */\n    if (php_random_bytes_silent(ZSTR_VAL(s), bytes) == SUCCESS) {\n        php_hash_bin2hex(dst, (unsigned char *)ZSTR_VAL(s), bytes);\n        zend_string_release(s);\n        return;\n    }\n\n    /* PHP shouldn't have failed, but generate manually if it did. */\n    while (rem > 0) {\n        clen = snprintf(chunk, sizeof(chunk), \"%08x\", rand());\n        len = rem >= clen ? clen : rem;\n        memcpy(ptr, chunk, len);\n        ptr += len; rem -= len;\n    }\n\n    zend_string_release(s);\n}\n\n/**\n * PHP_MINIT_FUNCTION\n */\nPHP_MINIT_FUNCTION(redis)\n{\n    struct timeval tv;\n\n    /* Seed random generator (for RedisCluster failover) */\n    gettimeofday(&tv, NULL);\n    srand(tv.tv_usec * tv.tv_sec);\n\n    /* Generate our random salt */\n    redis_random_hex_bytes(REDIS_G(salt), sizeof(REDIS_G(salt)) - 1);\n    REDIS_G(salt)[sizeof(REDIS_G(salt)) - 1] = '\\0';\n\n    REGISTER_INI_ENTRIES();\n\n    /* Redis class */\n    redis_ce = register_class_Redis();\n    redis_ce->create_object = create_redis_object;\n\n    /* RedisArray class */\n    ZEND_MINIT(redis_array)(INIT_FUNC_ARGS_PASSTHRU);\n\n    /* RedisCluster class */\n    ZEND_MINIT(redis_cluster)(INIT_FUNC_ARGS_PASSTHRU);\n\n    /* RedisSentinel class */\n    ZEND_MINIT(redis_sentinel)(INIT_FUNC_ARGS_PASSTHRU);\n\n    /* Register our cluster cache list item */\n    le_cluster_slot_cache = zend_register_list_destructors_ex(NULL, cluster_cache_dtor,\n                                                              \"Redis cluster slot cache\",\n                                                              module_number);\n\n    /* RedisException class */\n    redis_exception_ce = register_class_RedisException(spl_ce_RuntimeException);\n\n#ifdef PHP_SESSION\n    php_session_register_module(&ps_mod_redis);\n    php_session_register_module(&ps_mod_redis_cluster);\n#endif\n\n    /* Register resource destructors */\n    le_redis_pconnect = zend_register_list_destructors_ex(NULL, redis_connections_pool_dtor,\n        \"phpredis persistent connections pool\", module_number);\n\n    return SUCCESS;\n}\n\nstatic const char *\nget_available_serializers(void)\n{\n#ifdef HAVE_REDIS_JSON\n    #ifdef HAVE_REDIS_IGBINARY\n        #ifdef HAVE_REDIS_MSGPACK\n            return \"php, json, igbinary, msgpack\";\n        #else\n            return \"php, json, igbinary\";\n        #endif\n    #else\n        #ifdef HAVE_REDIS_MSGPACK\n            return \"php, json, msgpack\";\n        #else\n            return \"php, json\";\n        #endif\n    #endif\n#else\n    #ifdef HAVE_REDIS_IGBINARY\n        #ifdef HAVE_REDIS_MSGPACK\n            return \"php, igbinary, msgpack\";\n        #else\n            return \"php, igbinary\";\n        #endif\n    #else\n        #ifdef HAVE_REDIS_MSGPACK\n            return \"php, msgpack\";\n        #else\n            return \"php\";\n        #endif\n    #endif\n#endif\n}\n\n/**\n * PHP_MINFO_FUNCTION\n */\nPHP_MINFO_FUNCTION(redis)\n{\n    smart_str names = {0,};\n\n    php_info_print_table_start();\n    php_info_print_table_header(2, \"Redis Support\", \"enabled\");\n    php_info_print_table_row(2, \"Redis Version\", PHP_REDIS_VERSION);\n    php_info_print_table_row(2, \"Redis Sentinel Version\", PHP_REDIS_SENTINEL_VERSION);\n#ifdef GIT_REVISION\n    php_info_print_table_row(2, \"Git revision\", \"$Id: \" GIT_REVISION \" $\");\n#endif\n    php_info_print_table_row(2, \"Available serializers\", get_available_serializers());\n#ifdef HAVE_REDIS_LZF\n    smart_str_appends(&names, \"lzf\");\n#endif\n#ifdef HAVE_REDIS_ZSTD\n    if (names.s) {\n        smart_str_appends(&names, \", \");\n    }\n    smart_str_appends(&names, \"zstd\");\n#endif\n#ifdef HAVE_REDIS_LZ4\n    if (names.s) {\n        smart_str_appends(&names, \", \");\n    }\n    smart_str_appends(&names, \"lz4\");\n#endif\n    if (names.s) {\n        smart_str_0(&names);\n        php_info_print_table_row(2, \"Available compression\", ZSTR_VAL(names.s));\n    }\n    smart_str_free(&names);\n    php_info_print_table_end();\n\n    DISPLAY_INI_ENTRIES();\n}\n\n/* {{{ proto Redis Redis::__construct(array $options = null)\n    Public constructor */\nPHP_METHOD(Redis, __construct)\n{\n    HashTable *opts = NULL;\n    redis_object *redis;\n\n    ZEND_PARSE_PARAMETERS_START(0, 1)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_ARRAY_HT_OR_NULL(opts)\n    ZEND_PARSE_PARAMETERS_END_EX(RETURN_THROWS());\n\n    redis = PHPREDIS_ZVAL_GET_OBJECT(redis_object, getThis());\n    redis->sock = redis_sock_create(ZEND_STRL(\"127.0.0.1\"), 6379, 0, 0, 0, NULL, 0);\n    if (opts != NULL && redis_sock_configure(redis->sock, opts) != SUCCESS) {\n        RETURN_THROWS();\n    }\n}\n/* }}} */\n\n/* {{{ proto Redis Redis::__destruct()\n    Public Destructor\n */\nPHP_METHOD(Redis,__destruct) {\n    if (zend_parse_parameters_none() == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    // Grab our socket\n    RedisSock *redis_sock;\n    if ((redis_sock = redis_sock_get_instance(getThis(), 1)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    // If we think we're in MULTI mode, send a discard\n    if (IS_MULTI(redis_sock)) {\n        if (!IS_PIPELINE(redis_sock) && redis_sock->stream) {\n            // Discard any multi commands, and free any callbacks that have been\n            // queued\n            redis_send_discard(redis_sock);\n        }\n        redis_free_reply_callbacks(redis_sock);\n    }\n}\n\n/* {{{ proto boolean Redis::connect(string host, int port [, double timeout [, long retry_interval]])\n */\nPHP_METHOD(Redis, connect)\n{\n    if (redis_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0) == FAILURE) {\n        RETURN_FALSE;\n    } else {\n        RETURN_TRUE;\n    }\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::pconnect(string host, int port [, double timeout])\n */\nPHP_METHOD(Redis, pconnect)\n{\n    if (redis_connect(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1) == FAILURE) {\n        RETURN_FALSE;\n    } else {\n        RETURN_TRUE;\n    }\n}\n/* }}} */\n\nPHP_REDIS_API int\nredis_connect(INTERNAL_FUNCTION_PARAMETERS, int persistent)\n{\n    zval *object, *context = NULL, *ele;\n    char *host = NULL, *persistent_id = NULL;\n    zend_long port = -1, retry_interval = 0;\n    size_t host_len, persistent_id_len;\n    double timeout = 0.0, read_timeout = 0.0;\n    redis_object *redis;\n    int af_unix;\n\n#ifdef ZTS\n    /* not sure how in threaded mode this works so disabled persistence at\n     * first */\n    persistent = 0;\n#endif\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(),\n                                     \"Os|lds!lda!\", &object, redis_ce, &host,\n                                     &host_len, &port, &timeout, &persistent_id,\n                                     &persistent_id_len, &retry_interval,\n                                     &read_timeout, &context) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    /* Disregard persistent_id if we're not opening a persistent connection */\n    if (!persistent) {\n        persistent_id = NULL;\n    }\n\n    if (timeout > INT_MAX) {\n        REDIS_VALUE_EXCEPTION(\"Invalid connect timeout\");\n        return FAILURE;\n    }\n\n    if (read_timeout > INT_MAX) {\n        REDIS_VALUE_EXCEPTION(\"Invalid read timeout\");\n        return FAILURE;\n    }\n\n    if (retry_interval < 0L || retry_interval > INT_MAX) {\n        REDIS_VALUE_EXCEPTION(\"Invalid retry interval\");\n        return FAILURE;\n    }\n\n    /* Does the host look like a unix socket */\n    af_unix = (host_len > 0 && host[0] == '/') ||\n              (host_len > 6 && (!strncasecmp(host, \"unix://\", sizeof(\"unix://\") - 1) ||\n                                !strncasecmp(host, \"file://\", sizeof(\"file://\") - 1)));\n\n    /* If it's not a unix socket, set to default */\n    if (port == -1 && !af_unix) {\n        port = 6379;\n    }\n\n    redis = PHPREDIS_ZVAL_GET_OBJECT(redis_object, object);\n\n    /* if there is a redis sock already we have to remove it */\n    if (redis->sock) {\n        redis_sock_disconnect(redis->sock, 0, 1);\n        redis_free_socket(redis->sock);\n    }\n\n    redis->sock = redis_sock_create(host, host_len, port, timeout, read_timeout, persistent,\n        persistent_id, retry_interval);\n\n    if (context) {\n        /* Stream context (e.g. TLS) */\n        if ((ele = REDIS_HASH_STR_FIND_STATIC(Z_ARRVAL_P(context), \"stream\"))) {\n            redis_sock_set_stream_context(redis->sock, ele);\n        }\n\n        /* AUTH */\n        if ((ele = REDIS_HASH_STR_FIND_STATIC(Z_ARRVAL_P(context), \"auth\"))) {\n            redis_sock_set_auth_zval(redis->sock, ele);\n        }\n    }\n\n    if (redis_sock_connect(redis->sock) != SUCCESS) {\n        if (redis->sock->err) {\n            REDIS_THROW_EXCEPTION(ZSTR_VAL(redis->sock->err), 0);\n        }\n        redis_free_socket(redis->sock);\n        redis->sock = NULL;\n        return FAILURE;\n    }\n\n    return SUCCESS;\n}\n\n/* {{{ proto long Redis::bitop(string op, string key, ...) */\nPHP_METHOD(Redis, bitop) {\n    REDIS_PROCESS_CMD(bitop, redis_long_response);\n}\n\n/* }}} */\n\n/* {{{ proto long Redis::bitcount(string key, [int start], [int end])\n */\nPHP_METHOD(Redis, bitcount)\n{\n    REDIS_PROCESS_CMD(bitcount, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto integer Redis::bitpos(string key, int bit, [int start, int end]) */\nPHP_METHOD(Redis, bitpos)\n{\n    REDIS_PROCESS_CMD(bitpos, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::close()\n */\nPHP_METHOD(Redis, close)\n{\n    RedisSock *redis_sock = redis_sock_get_connected(INTERNAL_FUNCTION_PARAM_PASSTHRU);\n\n    if (redis_sock_disconnect(redis_sock, 1, 1) == SUCCESS) {\n        RETURN_TRUE;\n    }\n    RETURN_FALSE;\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::set(string key, mixed val, long timeout,\n *                              [array opt) */\nPHP_METHOD(Redis, set) {\n    REDIS_PROCESS_CMD(set, redis_set_response);\n}\n\n/* {{{ proto boolean Redis::setex(string key, long expire, string value)\n */\nPHP_METHOD(Redis, setex)\n{\n    REDIS_PROCESS_KW_CMD(\"SETEX\", redis_key_long_val_cmd, redis_boolean_response);\n}\n\n/* {{{ proto boolean Redis::psetex(string key, long expire, string value)\n */\nPHP_METHOD(Redis, psetex)\n{\n    REDIS_PROCESS_KW_CMD(\"PSETEX\", redis_key_long_val_cmd, redis_boolean_response);\n}\n\n/* {{{ proto boolean Redis::setnx(string key, string value)\n */\nPHP_METHOD(Redis, setnx)\n{\n    REDIS_PROCESS_KW_CMD(\"SETNX\", redis_kv_cmd, redis_1_response);\n}\n\n/* }}} */\n\n/* {{{ proto string Redis::getSet(string key, string value)\n */\nPHP_METHOD(Redis, getset)\n{\n    REDIS_PROCESS_KW_CMD(\"GETSET\", redis_kv_cmd, redis_string_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::randomKey()\n */\nPHP_METHOD(Redis, randomKey)\n{\n    REDIS_PROCESS_KW_CMD(\"RANDOMKEY\", redis_empty_cmd, redis_ping_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::echo(string msg)\n */\nPHP_METHOD(Redis, echo)\n{\n    REDIS_PROCESS_KW_CMD(\"ECHO\", redis_str_cmd, redis_string_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::rename(string key_src, string key_dst)\n */\nPHP_METHOD(Redis, rename)\n{\n    REDIS_PROCESS_KW_CMD(\"RENAME\", redis_key_key_cmd, redis_boolean_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::renameNx(string key_src, string key_dst)\n */\nPHP_METHOD(Redis, renameNx)\n{\n    REDIS_PROCESS_KW_CMD(\"RENAMENX\", redis_key_key_cmd, redis_1_response);\n}\n/* }}} */\n\n/** {{{ proto bool Redis::reset()\n */\nPHP_METHOD(Redis, reset)\n{\n    char *response;\n    int response_len;\n    RedisSock *redis_sock;\n    smart_string cmd = {0};\n    zend_bool ret = 0;\n\n    if ((redis_sock = redis_sock_get(getThis(), 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    if (IS_PIPELINE(redis_sock)) {\n        php_error_docref(NULL, E_ERROR, \"Reset isn't allowed in pipeline mode!\");\n        RETURN_FALSE;\n    }\n\n    redis_cmd_init_sstr(&cmd, 0, \"RESET\", 5);\n\n    REDIS_PROCESS_REQUEST(redis_sock, cmd.c, cmd.len);\n\n    if ((response = redis_sock_read(redis_sock, &response_len)) != NULL) {\n        ret = REDIS_STRCMP_STATIC(response, response_len, \"+RESET\");\n        efree(response);\n    }\n\n    if (!ret) {\n        if (IS_ATOMIC(redis_sock)) {\n            RETURN_FALSE;\n        }\n        REDIS_THROW_EXCEPTION(\"Reset failed in multi mode!\", 0);\n        RETURN_ZVAL(getThis(), 1, 0);\n    }\n\n    redis_free_reply_callbacks(redis_sock);\n    redis_sock->status = REDIS_SOCK_STATUS_CONNECTED;\n    redis_sock->mode = ATOMIC;\n    redis_sock->dbNumber = 0;\n    redis_sock->watching = 0;\n\n    RETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto string Redis::get(string key)\n */\nPHP_METHOD(Redis, get)\n{\n    REDIS_PROCESS_KW_CMD(\"GET\", redis_key_cmd, redis_string_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::getDel(string key)\n */\nPHP_METHOD(Redis, getDel)\n{\n    REDIS_PROCESS_KW_CMD(\"GETDEL\", redis_key_cmd, redis_string_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::getEx(string key [, array $options = []])\n */\nPHP_METHOD(Redis, getEx)\n{\n    REDIS_PROCESS_CMD(getex, redis_string_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::ping()\n */\nPHP_METHOD(Redis, ping)\n{\n    REDIS_PROCESS_KW_CMD(\"PING\", redis_opt_str_cmd, redis_read_variant_reply);\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::incr(string key [,int value])\n */\nPHP_METHOD(Redis, incr){\n    REDIS_PROCESS_CMD(incr, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::incrBy(string key ,int value)\n */\nPHP_METHOD(Redis, incrBy){\n    REDIS_PROCESS_KW_CMD(\"INCRBY\", redis_key_long_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto float Redis::incrByFloat(string key, float value)\n */\nPHP_METHOD(Redis, incrByFloat) {\n    REDIS_PROCESS_KW_CMD(\"INCRBYFLOAT\", redis_key_dbl_cmd, redis_bulk_double_response);\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::decr(string key) */\nPHP_METHOD(Redis, decr)\n{\n    REDIS_PROCESS_CMD(decr, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::decrBy(string key ,int value)\n */\nPHP_METHOD(Redis, decrBy){\n    REDIS_PROCESS_KW_CMD(\"DECRBY\", redis_key_long_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::mget(array keys)\n */\nPHP_METHOD(Redis, mget) {\n    REDIS_PROCESS_CMD(mget, redis_sock_read_multibulk_reply);\n}\n\n/* {{{ proto boolean Redis::exists(string $key, string ...$more_keys)\n */\nPHP_METHOD(Redis, exists) {\n    REDIS_PROCESS_KW_CMD(\"EXISTS\", redis_varkey_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::touch(string $key, string ...$more_keys)\n */\nPHP_METHOD(Redis, touch) {\n    REDIS_PROCESS_KW_CMD(\"TOUCH\", redis_varkey_cmd, redis_long_response);\n}\n\n/* }}} */\n/* {{{ proto boolean Redis::del(string key)\n */\nPHP_METHOD(Redis, del) {\n    REDIS_PROCESS_KW_CMD(\"DEL\", redis_varkey_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::unlink(string $key1, string $key2 [, string $key3...]) }}}\n * {{{ proto long Redis::unlink(array $keys) */\nPHP_METHOD(Redis, unlink)\n{\n    REDIS_PROCESS_KW_CMD(\"UNLINK\", redis_varkey_cmd, redis_long_response);\n}\n\nPHP_REDIS_API void redis_set_watch(RedisSock *redis_sock)\n{\n    redis_sock->watching = 1;\n}\n\nPHP_REDIS_API int redis_watch_response(INTERNAL_FUNCTION_PARAMETERS,\n                                 RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    return redis_boolean_response_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock,\n        z_tab, ctx, redis_set_watch);\n}\n\n/* {{{ proto boolean Redis::watch(string key1, string key2...)\n */\nPHP_METHOD(Redis, watch) {\n    REDIS_PROCESS_KW_CMD(\"WATCH\", redis_varkey_cmd, redis_watch_response);\n}\n/* }}} */\n\nPHP_REDIS_API void redis_clear_watch(RedisSock *redis_sock)\n{\n    redis_sock->watching = 0;\n}\n\nPHP_REDIS_API int redis_unwatch_response(INTERNAL_FUNCTION_PARAMETERS,\n                                   RedisSock *redis_sock, zval *z_tab,\n                                   void *ctx)\n{\n    return redis_boolean_response_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock,\n                                       z_tab, ctx, redis_clear_watch);\n}\n\n/* {{{ proto boolean Redis::unwatch()\n */\nPHP_METHOD(Redis, unwatch)\n{\n    REDIS_PROCESS_KW_CMD(\"UNWATCH\", redis_empty_cmd, redis_unwatch_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::keys(string pattern)\n */\nPHP_METHOD(Redis, keys)\n{\n    REDIS_PROCESS_KW_CMD(\"KEYS\", redis_key_cmd, redis_mbulk_reply_raw);\n}\n/* }}} */\n\n/* {{{ proto int Redis::type(string key)\n */\nPHP_METHOD(Redis, type)\n{\n    REDIS_PROCESS_KW_CMD(\"TYPE\", redis_key_cmd, redis_type_response);\n}\n/* }}} */\n\n/* {{{ proto mixed Redis::acl(string $op, ...) }}} */\nPHP_METHOD(Redis, acl) {\n    REDIS_PROCESS_CMD(acl, redis_acl_response);\n}\n\n/* {{{ proto long Redis::append(string key, string val) */\nPHP_METHOD(Redis, append)\n{\n    REDIS_PROCESS_KW_CMD(\"APPEND\", redis_kv_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::GetRange(string key, long start, long end) */\nPHP_METHOD(Redis, getRange)\n{\n    REDIS_PROCESS_KW_CMD(\"GETRANGE\", redis_key_long_long_cmd,\n        redis_string_response);\n}\n/* }}} */\n\n/* {{{ proto mixed Redis::lcs(string $key1, string $key2, ?array $options = NULL); */\nPHP_METHOD(Redis, lcs) {\n    REDIS_PROCESS_CMD(lcs, redis_read_variant_reply);\n}\n/* }}} */\n\n/* {{{ proto string Redis::setRange(string key, long start, string value) */\nPHP_METHOD(Redis, setRange)\n{\n    REDIS_PROCESS_KW_CMD(\"SETRANGE\", redis_key_long_str_cmd,\n        redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::getbit(string key, long idx) */\nPHP_METHOD(Redis, getBit)\n{\n    REDIS_PROCESS_KW_CMD(\"GETBIT\", redis_key_long_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::setbit(string key, long idx, bool|int value) */\nPHP_METHOD(Redis, setBit)\n{\n    REDIS_PROCESS_CMD(setbit, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::strlen(string key) */\nPHP_METHOD(Redis, strlen)\n{\n    REDIS_PROCESS_KW_CMD(\"STRLEN\", redis_key_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::lPush(string key , string value)\n */\nPHP_METHOD(Redis, lPush)\n{\n    REDIS_PROCESS_KW_CMD(\"LPUSH\", redis_key_varval_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::rPush(string key , string value)\n */\nPHP_METHOD(Redis, rPush)\n{\n    REDIS_PROCESS_KW_CMD(\"RPUSH\", redis_key_varval_cmd, redis_long_response);\n}\n/* }}} */\n\nPHP_METHOD(Redis, lInsert)\n{\n    REDIS_PROCESS_CMD(linsert, redis_long_response);\n}\n\n/* {{{ proto long Redis::lPushx(string key, mixed value) */\nPHP_METHOD(Redis, lPushx)\n{\n    REDIS_PROCESS_KW_CMD(\"LPUSHX\", redis_kv_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::rPushx(string key, mixed value) */\nPHP_METHOD(Redis, rPushx)\n{\n    REDIS_PROCESS_KW_CMD(\"RPUSHX\", redis_kv_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::lPop(string key, [int count = 0]) */\nPHP_METHOD(Redis, lPop)\n{\n    REDIS_PROCESS_KW_CMD(\"LPOP\", redis_pop_cmd, redis_pop_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::lPos(string key, mixed value, [array options = null]) */\nPHP_METHOD(Redis, lPos)\n{\n    REDIS_PROCESS_CMD(lpos, redis_lpos_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::rPop(string key, [int count = 0]) */\nPHP_METHOD(Redis, rPop)\n{\n    REDIS_PROCESS_KW_CMD(\"RPOP\", redis_pop_cmd, redis_pop_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::blPop(string key1, string key2, ..., int timeout) */\nPHP_METHOD(Redis, blPop)\n{\n    REDIS_PROCESS_KW_CMD(\"BLPOP\", redis_blocking_pop_cmd, redis_sock_read_multibulk_reply);\n}\n/* }}} */\n\n/* {{{ proto string Redis::brPop(string key1, string key2, ..., int timeout) */\nPHP_METHOD(Redis, brPop)\n{\n    REDIS_PROCESS_KW_CMD(\"BRPOP\", redis_blocking_pop_cmd, redis_sock_read_multibulk_reply);\n}\n/* }}} */\n\n\n/* {{{ proto int Redis::lLen(string key) */\nPHP_METHOD(Redis, lLen)\n{\n    REDIS_PROCESS_KW_CMD(\"LLEN\", redis_key_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::blMove(string source, string destination, string wherefrom, string whereto, double $timeout) */\nPHP_METHOD(Redis, blmove) {\n    REDIS_PROCESS_KW_CMD(\"BLMOVE\", redis_lmove_cmd, redis_string_response);\n}\n\n/* {{{ proto string Redis::lMove(string source, string destination, string wherefrom, string whereto) */\nPHP_METHOD(Redis, lMove) {\n    REDIS_PROCESS_KW_CMD(\"LMOVE\", redis_lmove_cmd, redis_string_response);\n}\n\n/* {{{ proto boolean Redis::lrem(string list, string value, int count = 0) */\nPHP_METHOD(Redis, lrem)\n{\n    REDIS_PROCESS_CMD(lrem, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::ltrim(string key , int start , int end) */\nPHP_METHOD(Redis, ltrim)\n{\n    REDIS_PROCESS_KW_CMD(\"LTRIM\", redis_key_long_long_cmd,\n        redis_boolean_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::lindex(string key , int index) */\nPHP_METHOD(Redis, lindex)\n{\n    REDIS_PROCESS_KW_CMD(\"LINDEX\", redis_key_long_cmd, redis_string_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::lrange(string key, int start , int end) */\nPHP_METHOD(Redis, lrange)\n{\n    REDIS_PROCESS_KW_CMD(\"LRANGE\", redis_key_long_long_cmd,\n        redis_sock_read_multibulk_reply);\n}\n/* }}} */\n\n/* {{{ proto long Redis::sAdd(string key , mixed value) */\nPHP_METHOD(Redis, sAdd)\n{\n    REDIS_PROCESS_KW_CMD(\"SADD\", redis_key_varval_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::sAddArray(string key, array $values) */\nPHP_METHOD(Redis, sAddArray) {\n    REDIS_PROCESS_KW_CMD(\"SADD\", redis_key_val_arr_cmd, redis_long_response);\n} /* }}} */\n\n/* {{{ proto int Redis::scard(string key) */\nPHP_METHOD(Redis, scard)\n{\n    REDIS_PROCESS_KW_CMD(\"SCARD\", redis_key_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::srem(string set, string value) */\nPHP_METHOD(Redis, srem)\n{\n    REDIS_PROCESS_KW_CMD(\"SREM\", redis_key_varval_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::sMove(string src, string dst, mixed value) */\nPHP_METHOD(Redis, sMove)\n{\n    REDIS_PROCESS_CMD(smove, redis_1_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::sPop(string key) */\nPHP_METHOD(Redis, sPop)\n{\n    if (ZEND_NUM_ARGS() == 1) {\n        REDIS_PROCESS_KW_CMD(\"SPOP\", redis_key_cmd, redis_string_response);\n    } else if (ZEND_NUM_ARGS() == 2) {\n        REDIS_PROCESS_KW_CMD(\"SPOP\", redis_key_long_cmd, redis_sock_read_multibulk_reply);\n    } else {\n        ZEND_WRONG_PARAM_COUNT();\n    }\n\n}\n/* }}} */\n\n/* {{{ proto string Redis::sRandMember(string key [int count]) */\nPHP_METHOD(Redis, sRandMember)\n{\n    REDIS_PROCESS_CMD(srandmember, redis_srandmember_response);\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::sismember(string set, string value) */\nPHP_METHOD(Redis, sismember)\n{\n    REDIS_PROCESS_KW_CMD(\"SISMEMBER\", redis_kv_cmd, redis_1_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::sMembers(string set) */\nPHP_METHOD(Redis, sMembers)\n{\n    REDIS_PROCESS_KW_CMD(\"SMEMBERS\", redis_key_cmd,\n        redis_sock_read_multibulk_reply);\n}\n\n/* {{{ proto array Redis::sMisMember(string key, string member0, ...memberN) */\nPHP_METHOD(Redis, sMisMember)\n{\n    REDIS_PROCESS_KW_CMD(\"SMISMEMBER\", redis_key_varval_cmd, redis_read_variant_reply);\n}\n/* }}} */\n\n/* {{{ proto array Redis::sInter(string key0, ... string keyN) */\nPHP_METHOD(Redis, sInter) {\n    REDIS_PROCESS_KW_CMD(\"SINTER\", redis_varkey_cmd, redis_sock_read_multibulk_reply);\n}\n/* }}} */\n\nPHP_METHOD(Redis, sintercard) {\n    REDIS_PROCESS_KW_CMD(\"SINTERCARD\", redis_intercard_cmd, redis_long_response);\n}\n\n/* {{{ proto array Redis::sInterStore(string dst, string key0,...string keyN) */\nPHP_METHOD(Redis, sInterStore) {\n    REDIS_PROCESS_KW_CMD(\"SINTERSTORE\", redis_varkey_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::sUnion(string key0, ... string keyN) */\nPHP_METHOD(Redis, sUnion) {\n    REDIS_PROCESS_KW_CMD(\"SUNION\", redis_varkey_cmd, redis_sock_read_multibulk_reply);\n}\n/* }}} */\n\n/* {{{ proto array Redis::sUnionStore(array|string $key, string ...$srckeys) */\nPHP_METHOD(Redis, sUnionStore) {\n    REDIS_PROCESS_KW_CMD(\"SUNIONSTORE\", redis_varkey_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::sDiff(string key0, ... string keyN) */\nPHP_METHOD(Redis, sDiff) {\n    REDIS_PROCESS_KW_CMD(\"SDIFF\", redis_varkey_cmd, redis_sock_read_multibulk_reply);\n}\n/* }}} */\n\n/* {{{ proto array Redis::sDiffStore(string dst, string key0, ... keyN) */\nPHP_METHOD(Redis, sDiffStore) {\n    REDIS_PROCESS_KW_CMD(\"SDIFFSTORE\", redis_varkey_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::sort(string key, array options) */\nPHP_METHOD(Redis, sort) {\n    REDIS_PROCESS_KW_CMD(\"SORT\", redis_sort_cmd, redis_read_variant_reply);\n}\n\n/* {{{ proto array Redis::sort(string key, array options) */\nPHP_METHOD(Redis, sort_ro) {\n    REDIS_PROCESS_KW_CMD(\"SORT_RO\", redis_sort_cmd, redis_read_variant_reply);\n}\n\nstatic void\ngeneric_sort_cmd(INTERNAL_FUNCTION_PARAMETERS, int desc, int alpha)\n{\n    zval *object, *zele, *zget = NULL;\n    RedisSock *redis_sock;\n    zend_string *zpattern;\n    char *key = NULL, *pattern = NULL, *store = NULL;\n    size_t keylen, patternlen, storelen;\n    zend_long offset = -1, count = -1;\n    int argc = 1; /* SORT key is the simplest SORT command */\n    smart_string cmd = {0};\n\n    /* Parse myriad of sort arguments */\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(),\n                                     \"Os|s!z!lls\", &object, redis_ce, &key,\n                                     &keylen, &pattern, &patternlen, &zget,\n                                     &offset, &count, &store, &storelen)\n                                     == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    /* Ensure we're sorting something, and we can get context */\n    if (keylen == 0 || !(redis_sock = redis_sock_get(object, 0)))\n        RETURN_FALSE;\n\n    /* Start calculating argc depending on input arguments */\n    if (pattern && patternlen)     argc += 2; /* BY pattern */\n    if (offset >= 0 && count >= 0) argc += 3; /* LIMIT offset count */\n    if (alpha)                     argc += 1; /* ALPHA */\n    if (store)                     argc += 2; /* STORE destination */\n    if (desc)                      argc += 1; /* DESC (ASC is the default) */\n\n    /* GET is special.  It can be 0 .. N arguments depending what we have */\n    if (zget) {\n        if (Z_TYPE_P(zget) == IS_ARRAY)\n            argc += zend_hash_num_elements(Z_ARRVAL_P(zget));\n        else if (Z_STRLEN_P(zget) > 0) {\n            argc += 2; /* GET pattern */\n        }\n    }\n\n    /* Start constructing final command and append key */\n    redis_cmd_init_sstr(&cmd, argc, ZEND_STRL(\"SORT\"));\n    redis_cmd_append_sstr_key(&cmd, key, keylen, redis_sock, NULL);\n\n    /* BY pattern */\n    if (pattern && patternlen) {\n        redis_cmd_append_sstr(&cmd, ZEND_STRL(\"BY\"));\n        redis_cmd_append_sstr(&cmd, pattern, patternlen);\n    }\n\n    /* LIMIT offset count */\n    if (offset >= 0 && count >= 0) {\n        redis_cmd_append_sstr(&cmd, ZEND_STRL(\"LIMIT\"));\n        redis_cmd_append_sstr_long(&cmd, offset);\n        redis_cmd_append_sstr_long(&cmd, count);\n    }\n\n    /* Handle any number of GET pattern arguments we've been passed */\n    if (zget != NULL) {\n        if (Z_TYPE_P(zget) == IS_ARRAY) {\n            ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(zget), zele) {\n                zpattern = zval_get_string(zele);\n                redis_cmd_append_sstr(&cmd, ZEND_STRL(\"GET\"));\n                redis_cmd_append_sstr(&cmd, ZSTR_VAL(zpattern), ZSTR_LEN(zpattern));\n                zend_string_release(zpattern);\n            } ZEND_HASH_FOREACH_END();\n        } else {\n            zpattern = zval_get_string(zget);\n            redis_cmd_append_sstr(&cmd, ZEND_STRL(\"GET\"));\n            redis_cmd_append_sstr(&cmd, ZSTR_VAL(zpattern), ZSTR_LEN(zpattern));\n            zend_string_release(zpattern);\n        }\n    }\n\n    /* Append optional DESC and ALPHA modifiers */\n    if (desc)  redis_cmd_append_sstr(&cmd, ZEND_STRL(\"DESC\"));\n    if (alpha) redis_cmd_append_sstr(&cmd, ZEND_STRL(\"ALPHA\"));\n\n    /* Finally append STORE if we've got it */\n    if (store && storelen) {\n        redis_cmd_append_sstr(&cmd, ZEND_STRL(\"STORE\"));\n        redis_cmd_append_sstr_key(&cmd, store, storelen, redis_sock, NULL);\n    }\n\n    REDIS_PROCESS_REQUEST(redis_sock, cmd.c, cmd.len);\n    if (IS_ATOMIC(redis_sock)) {\n        if (redis_read_variant_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU,\n                                     redis_sock, NULL, NULL) < 0)\n        {\n            RETURN_FALSE;\n        }\n    }\n    REDIS_PROCESS_RESPONSE(redis_read_variant_reply);\n}\n\n/* {{{ proto array Redis::sortAsc(string key, string pattern, string get,\n *                                int start, int end, bool getList]) */\nPHP_METHOD(Redis, sortAsc)\n{\n    generic_sort_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 0);\n}\n/* }}} */\n\n/* {{{ proto array Redis::sortAscAlpha(string key, string pattern, string get,\n *                                     int start, int end, bool getList]) */\nPHP_METHOD(Redis, sortAscAlpha)\n{\n    generic_sort_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 1);\n}\n/* }}} */\n\n/* {{{ proto array Redis::sortDesc(string key, string pattern, string get,\n *                                 int start, int end, bool getList]) */\nPHP_METHOD(Redis, sortDesc)\n{\n    generic_sort_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1, 0);\n}\n/* }}} */\n\n/* {{{ proto array Redis::sortDescAlpha(string key, string pattern, string get,\n *                                      int start, int end, bool getList]) */\nPHP_METHOD(Redis, sortDescAlpha)\n{\n    generic_sort_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1, 1);\n}\n/* }}} */\n\n/* {{{ proto array Redis::expire(string key, int timeout) */\nPHP_METHOD(Redis, expire) {\n    REDIS_PROCESS_KW_CMD(\"EXPIRE\", redis_expire_cmd, redis_1_response);\n}\n/* }}} */\n\n/* {{{ proto bool Redis::pexpire(string key, long ms) */\nPHP_METHOD(Redis, pexpire) {\n    REDIS_PROCESS_KW_CMD(\"PEXPIRE\", redis_expire_cmd, redis_1_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::expireAt(string key, int timestamp) */\nPHP_METHOD(Redis, expireAt) {\n    REDIS_PROCESS_KW_CMD(\"EXPIREAT\", redis_expire_cmd, redis_1_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::pexpireAt(string key, int timestamp) */\nPHP_METHOD(Redis, pexpireAt) {\n    REDIS_PROCESS_KW_CMD(\"PEXPIREAT\", redis_expire_cmd, redis_1_response);\n}\n/* }}} */\n\n/* {{{ proto Redis::expiretime(string $key): int */\nPHP_METHOD(Redis, expiretime) {\n    REDIS_PROCESS_KW_CMD(\"EXPIRETIME\", redis_key_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto Redis::expiretime(string $key): int */\nPHP_METHOD(Redis, pexpiretime) {\n    REDIS_PROCESS_KW_CMD(\"PEXPIRETIME\", redis_key_cmd, redis_long_response);\n}\n\nPHP_METHOD(Redis, expiremember) {\n    REDIS_PROCESS_CMD(expiremember, redis_long_response);\n}\n\nPHP_METHOD(Redis, expirememberat) {\n    REDIS_PROCESS_CMD(expirememberat, redis_long_response);\n}\n\n/* }}} */\n/* {{{ proto array Redis::lSet(string key, int index, string value) */\nPHP_METHOD(Redis, lSet) {\n    REDIS_PROCESS_KW_CMD(\"LSET\", redis_key_long_val_cmd,\n        redis_boolean_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::save() */\nPHP_METHOD(Redis, save)\n{\n    REDIS_PROCESS_KW_CMD(\"SAVE\", redis_empty_cmd, redis_boolean_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::bgSave() */\nPHP_METHOD(Redis, bgSave)\n{\n    REDIS_PROCESS_KW_CMD(\"BGSAVE\", redis_empty_cmd, redis_boolean_response);\n}\n/* }}} */\n\n/* {{{ proto integer Redis::lastSave() */\nPHP_METHOD(Redis, lastSave)\n{\n    REDIS_PROCESS_KW_CMD(\"LASTSAVE\", redis_empty_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto bool Redis::failover([array to [,bool abort [,int timeout]]] ) */\nPHP_METHOD(Redis, failover)\n{\n    REDIS_PROCESS_CMD(failover, redis_boolean_response);\n}\n/* }}} */\n\n/* {{{ proto bool Redis::flushDB([bool async]) */\nPHP_METHOD(Redis, flushDB)\n{\n    REDIS_PROCESS_KW_CMD(\"FLUSHDB\", redis_flush_cmd, redis_boolean_response);\n}\n/* }}} */\n\n/* {{{ proto bool Redis::flushAll([bool async]) */\nPHP_METHOD(Redis, flushAll)\n{\n    REDIS_PROCESS_KW_CMD(\"FLUSHALL\", redis_flush_cmd, redis_boolean_response);\n}\n/* }}} */\n\n/* {{{ proto mixed Redis::function(string op, mixed ...args) */\nPHP_METHOD(Redis, function)\n{\n    REDIS_PROCESS_CMD(function, redis_function_response)\n}\n\n/* {{{ proto int Redis::dbSize() */\nPHP_METHOD(Redis, dbSize)\n{\n    REDIS_PROCESS_KW_CMD(\"DBSIZE\", redis_empty_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto bool Redis::auth(string passwd) */\nPHP_METHOD(Redis, auth) {\n    REDIS_PROCESS_CMD(auth, redis_boolean_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::persist(string key) */\nPHP_METHOD(Redis, persist) {\n    REDIS_PROCESS_KW_CMD(\"PERSIST\", redis_key_cmd, redis_1_response);\n}\n/* }}} */\n\n\n/* {{{ proto long Redis::ttl(string key) */\nPHP_METHOD(Redis, ttl) {\n    REDIS_PROCESS_KW_CMD(\"TTL\", redis_key_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::pttl(string key) */\nPHP_METHOD(Redis, pttl) {\n    REDIS_PROCESS_KW_CMD(\"PTTL\", redis_key_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::info() */\nPHP_METHOD(Redis, info) {\n    REDIS_PROCESS_CMD(info, redis_info_response);\n}\n/* }}} */\n\n/* {{{ proto bool Redis::select(long dbNumber) */\nPHP_METHOD(Redis, select) {\n    REDIS_PROCESS_CMD(select, redis_select_response);\n}\n/* }}} */\n\n/* {{{ proto bool Redis::swapdb(long srcdb, long dstdb) */\nPHP_METHOD(Redis, swapdb) {\n    REDIS_PROCESS_KW_CMD(\"SWAPDB\", redis_long_long_cmd, redis_boolean_response);\n}\n\n/* {{{ proto bool Redis::move(string key, long dbindex) */\nPHP_METHOD(Redis, move) {\n    REDIS_PROCESS_KW_CMD(\"MOVE\", redis_key_long_cmd, redis_1_response);\n}\n/* }}} */\n\n/* {{{ proto bool Redis::mset(array (key => value, ...)) */\nPHP_METHOD(Redis, mset) {\n    REDIS_PROCESS_KW_CMD(\"MSET\", redis_mset_cmd, redis_boolean_response);\n}\n/* }}} */\n\n\n/* {{{ proto bool Redis::msetnx(array (key => value, ...)) */\nPHP_METHOD(Redis, msetnx) {\n    REDIS_PROCESS_KW_CMD(\"MSETNX\", redis_mset_cmd, redis_1_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::rpoplpush(string srckey, string dstkey) */\nPHP_METHOD(Redis, rpoplpush)\n{\n    REDIS_PROCESS_KW_CMD(\"RPOPLPUSH\", redis_key_key_cmd, redis_string_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::brpoplpush(string src, string dst, int timeout) */\nPHP_METHOD(Redis, brpoplpush) {\n    REDIS_PROCESS_CMD(brpoplpush, redis_string_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::zAdd(string key, int score, string value) */\nPHP_METHOD(Redis, zAdd) {\n    REDIS_PROCESS_CMD(zadd, redis_zadd_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::zRandMember(string key, array options) */\nPHP_METHOD(Redis, zRandMember) {\n    REDIS_PROCESS_CMD(zrandmember, redis_zrandmember_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::zRange(string key,int start,int end,bool scores = 0) */\nPHP_METHOD(Redis, zRange) {\n    REDIS_PROCESS_KW_CMD(\"ZRANGE\", redis_zrange_cmd, redis_zrange_response);\n}\n/* }}} */\n\nPHP_METHOD(Redis, zrangestore) {\n    REDIS_PROCESS_KW_CMD(\"ZRANGESTORE\", redis_zrange_cmd, redis_long_response);\n}\n\n/* {{{ proto array Redis::zRevRange(string k, long s, long e, bool scores = 0) */\nPHP_METHOD(Redis, zRevRange) {\n    REDIS_PROCESS_KW_CMD(\"ZREVRANGE\", redis_zrange_cmd, redis_zrange_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::zRangeByScore(string k,string s,string e,array opt) */\nPHP_METHOD(Redis, zRangeByScore) {\n    REDIS_PROCESS_KW_CMD(\"ZRANGEBYSCORE\", redis_zrange_cmd, redis_zrange_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::zRevRangeByScore(string key, string start, string end,\n *                                         array options) */\nPHP_METHOD(Redis, zRevRangeByScore) {\n    REDIS_PROCESS_KW_CMD(\"ZREVRANGEBYSCORE\", redis_zrange_cmd, redis_zrange_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::zRangeByLex(string key, string min, string max, [\n *                                    offset, limit]) */\nPHP_METHOD(Redis, zRangeByLex) {\n    REDIS_PROCESS_KW_CMD(\"ZRANGEBYLEX\", redis_zrangebylex_cmd,\n        redis_sock_read_multibulk_reply);\n}\n/* }}} */\n\nPHP_METHOD(Redis, zRevRangeByLex) {\n    REDIS_PROCESS_KW_CMD(\"ZREVRANGEBYLEX\", redis_zrangebylex_cmd,\n        redis_sock_read_multibulk_reply);\n}\n/* }}} */\n\n/* {{{ proto long Redis::zLexCount(string key, string min, string max) */\nPHP_METHOD(Redis, zLexCount) {\n    REDIS_PROCESS_KW_CMD(\"ZLEXCOUNT\", redis_gen_zlex_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::zRemRangeByLex(string key, string min, string max) */\nPHP_METHOD(Redis, zRemRangeByLex) {\n    REDIS_PROCESS_KW_CMD(\"ZREMRANGEBYLEX\", redis_gen_zlex_cmd,\n        redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::zRem(string key, string member) */\nPHP_METHOD(Redis, zRem)\n{\n    REDIS_PROCESS_KW_CMD(\"ZREM\", redis_key_varval_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::zRemRangeByScore(string k, string s, string e) */\nPHP_METHOD(Redis, zRemRangeByScore)\n{\n    REDIS_PROCESS_KW_CMD(\"ZREMRANGEBYSCORE\", redis_key_str_str_cmd,\n        redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::zRemRangeByRank(string key, long start, long end) */\nPHP_METHOD(Redis, zRemRangeByRank)\n{\n    REDIS_PROCESS_KW_CMD(\"ZREMRANGEBYRANK\", redis_key_long_long_cmd,\n        redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::zCount(string key, string start , string end) */\nPHP_METHOD(Redis, zCount)\n{\n    REDIS_PROCESS_KW_CMD(\"ZCOUNT\", redis_key_str_str_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::zCard(string key) */\nPHP_METHOD(Redis, zCard)\n{\n    REDIS_PROCESS_KW_CMD(\"ZCARD\", redis_key_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto double Redis::zScore(string key, mixed member) */\nPHP_METHOD(Redis, zScore)\n{\n    REDIS_PROCESS_KW_CMD(\"ZSCORE\", redis_kv_cmd,\n        redis_bulk_double_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::zMscore(string key, string member0, ...memberN) */\nPHP_METHOD(Redis, zMscore)\n{\n    REDIS_PROCESS_KW_CMD(\"ZMSCORE\", redis_key_varval_cmd, redis_mbulk_reply_double);\n}\n/* }}} */\n\n/* {{{ proto long Redis::zRank(string key, string member) */\nPHP_METHOD(Redis, zRank) {\n    REDIS_PROCESS_KW_CMD(\"ZRANK\", redis_kv_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::zRevRank(string key, string member) */\nPHP_METHOD(Redis, zRevRank) {\n    REDIS_PROCESS_KW_CMD(\"ZREVRANK\", redis_kv_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto double Redis::zIncrBy(string key, double value, mixed member) */\nPHP_METHOD(Redis, zIncrBy)\n{\n    REDIS_PROCESS_CMD(zincrby, redis_bulk_double_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::zdiff(array keys, array options) */\nPHP_METHOD(Redis, zdiff) {\n    REDIS_PROCESS_CMD(zdiff, redis_zdiff_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::zinter(array keys, array|null weights, array options) */\nPHP_METHOD(Redis, zinter) {\n    REDIS_PROCESS_KW_CMD(\"ZINTER\", redis_zinterunion_cmd, redis_zdiff_response);\n}\n/* }}} */\n\nPHP_METHOD(Redis, zintercard) {\n    REDIS_PROCESS_KW_CMD(\"ZINTERCARD\", redis_intercard_cmd, redis_long_response);\n}\n\n/* {{{ proto array Redis::zunion(array keys, array|null weights, array options) */\nPHP_METHOD(Redis, zunion) {\n    REDIS_PROCESS_KW_CMD(\"ZUNION\", redis_zinterunion_cmd, redis_zdiff_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::zdiffstore(string destination, array keys) */\nPHP_METHOD(Redis, zdiffstore) {\n    REDIS_PROCESS_CMD(zdiffstore, redis_long_response);\n}\n/* }}} */\n\n/* zinterstore */\nPHP_METHOD(Redis, zinterstore) {\n    REDIS_PROCESS_KW_CMD(\"ZINTERSTORE\", redis_zinterunionstore_cmd, redis_long_response);\n}\n\n/* zunionstore */\nPHP_METHOD(Redis, zunionstore) {\n    REDIS_PROCESS_KW_CMD(\"ZUNIONSTORE\", redis_zinterunionstore_cmd, redis_long_response);\n}\n\n/* {{{ proto array Redis::zPopMax(string key) */\nPHP_METHOD(Redis, zPopMax)\n{\n    if (ZEND_NUM_ARGS() == 1) {\n        REDIS_PROCESS_KW_CMD(\"ZPOPMAX\", redis_key_cmd, redis_mbulk_reply_zipped_keys_dbl);\n    } else if (ZEND_NUM_ARGS() == 2) {\n        REDIS_PROCESS_KW_CMD(\"ZPOPMAX\", redis_key_long_cmd, redis_mbulk_reply_zipped_keys_dbl);\n    } else {\n        ZEND_WRONG_PARAM_COUNT();\n    }\n}\n/* }}} */\n\n/* {{{ proto array Redis::zPopMin(string key) */\nPHP_METHOD(Redis, zPopMin)\n{\n    if (ZEND_NUM_ARGS() == 1) {\n        REDIS_PROCESS_KW_CMD(\"ZPOPMIN\", redis_key_cmd, redis_mbulk_reply_zipped_keys_dbl);\n    } else if (ZEND_NUM_ARGS() == 2) {\n        REDIS_PROCESS_KW_CMD(\"ZPOPMIN\", redis_key_long_cmd, redis_mbulk_reply_zipped_keys_dbl);\n    } else {\n        ZEND_WRONG_PARAM_COUNT();\n    }\n}\n/* }}} */\n\n/* {{{ proto Redis::bzPopMax(Array[keys] [, timeout]): Array */\nPHP_METHOD(Redis, bzPopMax) {\n    REDIS_PROCESS_KW_CMD(\"BZPOPMAX\", redis_blocking_pop_cmd, redis_sock_read_multibulk_reply);\n}\n/* }}} */\n\n/* {{{ proto Redis::bzPopMin([keys] [, timeout]): Array */\nPHP_METHOD(Redis, bzPopMin) {\n    REDIS_PROCESS_KW_CMD(\"BZPOPMIN\", redis_blocking_pop_cmd, redis_sock_read_multibulk_reply);\n}\n/* }}} */\n\n/* {{{ proto Redis|array|false Redis::lmpop(array $keys, string $from, int $count = 1) */\nPHP_METHOD(Redis, lmpop) {\n    REDIS_PROCESS_KW_CMD(\"LMPOP\", redis_mpop_cmd, redis_mpop_response);\n}\n/* }}} */\n\n/* {{{ proto Redis|array|false Redis::blmpop(double $timeout, array $keys, string $from, int $count = 1) */\nPHP_METHOD(Redis, blmpop) {\n    REDIS_PROCESS_KW_CMD(\"BLMPOP\", redis_mpop_cmd, redis_mpop_response);\n}\n/* }}} */\n\n/* {{{ proto Redis|array|false Redis::zmpop(array $keys, string $from, int $count = 1) */\nPHP_METHOD(Redis, zmpop) {\n    REDIS_PROCESS_KW_CMD(\"ZMPOP\", redis_mpop_cmd, redis_mpop_response);\n}\n\n/* {{{ proto Redis|array|false Redis::bzmpop(double $timeout, array $keys, string $from, int $count = 1) */\nPHP_METHOD(Redis, bzmpop) {\n    REDIS_PROCESS_KW_CMD(\"BZMPOP\", redis_mpop_cmd, redis_mpop_response);\n}\n\n/* }}} */\n/* hashes */\n\n/* {{{ proto long Redis::hset(string key, string mem, string val) */\nPHP_METHOD(Redis, hSet)\n{\n    REDIS_PROCESS_CMD(hset, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto bool Redis::hSetNx(string key, string mem, string val) */\nPHP_METHOD(Redis, hSetNx)\n{\n    REDIS_PROCESS_CMD(hsetnx, redis_1_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::hget(string key, string mem) */\nPHP_METHOD(Redis, hGet)\n{\n    REDIS_PROCESS_KW_CMD(\"HGET\", redis_key_str_cmd, redis_string_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::hLen(string key) */\nPHP_METHOD(Redis, hLen)\n{\n    REDIS_PROCESS_KW_CMD(\"HLEN\", redis_key_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::hDel(string key, string mem1, ... memN) */\nPHP_METHOD(Redis, hDel)\n{\n    REDIS_PROCESS_CMD(hdel, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto bool Redis::hExists(string key, string mem) */\nPHP_METHOD(Redis, hExists)\n{\n    REDIS_PROCESS_KW_CMD(\"HEXISTS\", redis_key_str_cmd, redis_1_response);\n}\n\n/* {{{ proto array Redis::hkeys(string key) */\nPHP_METHOD(Redis, hKeys)\n{\n    REDIS_PROCESS_KW_CMD(\"HKEYS\", redis_key_cmd, redis_mbulk_reply_raw);\n}\n/* }}} */\n\n/* {{{ proto array Redis::hvals(string key) */\nPHP_METHOD(Redis, hVals)\n{\n    REDIS_PROCESS_KW_CMD(\"HVALS\", redis_key_cmd,\n        redis_sock_read_multibulk_reply);\n}\n\n/* {{{ proto array Redis::hgetall(string key) */\nPHP_METHOD(Redis, hGetAll) {\n    REDIS_PROCESS_KW_CMD(\"HGETALL\", redis_key_cmd, redis_mbulk_reply_zipped_vals);\n}\n/* }}} */\n\n/* {{{ proto double Redis::hIncrByFloat(string k, string me, double v) */\nPHP_METHOD(Redis, hIncrByFloat)\n{\n    REDIS_PROCESS_CMD(hincrbyfloat, redis_bulk_double_response);\n}\n/* }}} */\n\n/* {{{ proto long Redis::hincrby(string key, string mem, long byval) */\nPHP_METHOD(Redis, hIncrBy)\n{\n    REDIS_PROCESS_CMD(hincrby, redis_long_response);\n}\n/* }}} */\n\n/* {{{ array Redis::hMget(string hash, array keys) */\nPHP_METHOD(Redis, hMget) {\n    REDIS_PROCESS_CMD(hmget, redis_mbulk_reply_assoc);\n}\n/* }}} */\n\n/* {{{ proto bool Redis::hmset(string key, array keyvals) */\nPHP_METHOD(Redis, hMset)\n{\n    REDIS_PROCESS_CMD(hmset, redis_boolean_response);\n}\n/* }}} */\n\n/* {{{ proto bool Redis::hRandField(string key, [array $options]) */\nPHP_METHOD(Redis, hRandField)\n{\n    REDIS_PROCESS_CMD(hrandfield, redis_hrandfield_response);\n}\n/* }}} */\n\n\n/* {{{ proto long Redis::hstrlen(string key, string field) */\nPHP_METHOD(Redis, hStrLen) {\n    REDIS_PROCESS_CMD(hstrlen, redis_long_response);\n}\n/* }}} */\n\n/* flag : get, set {ATOMIC, MULTI, PIPELINE} */\n\nPHP_METHOD(Redis, multi)\n{\n\n    RedisSock *redis_sock;\n    char *resp;\n    int resp_len;\n    zval *object;\n    zend_long multi_value = MULTI;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(),\n                                     \"O|l\", &object, redis_ce, &multi_value)\n                                     == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    /* if the flag is activated, send the command, the reply will be \"QUEUED\"\n     * or -ERR */\n    if ((redis_sock = redis_sock_get(object, 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    if (multi_value == PIPELINE) {\n        /* Cannot enter pipeline mode in a MULTI block */\n        if (IS_MULTI(redis_sock)) {\n            php_error_docref(NULL, E_ERROR, \"Can't activate pipeline in multi mode!\");\n            RETURN_FALSE;\n        }\n\n        /* Enable PIPELINE if we're not already in one */\n        if (IS_ATOMIC(redis_sock)) {\n            REDIS_ENABLE_MODE(redis_sock, PIPELINE);\n        }\n    } else if (multi_value == MULTI) {\n        /* Don't want to do anything if we're already in MULTI mode */\n        if (!IS_MULTI(redis_sock)) {\n            if (IS_PIPELINE(redis_sock)) {\n                PIPELINE_ENQUEUE_COMMAND(RESP_MULTI_CMD, sizeof(RESP_MULTI_CMD) - 1);\n                REDIS_SAVE_CALLBACK(NULL, NULL);\n                REDIS_ENABLE_MODE(redis_sock, MULTI);\n            } else {\n                if (redis_sock_write(redis_sock, ZEND_STRL(RESP_MULTI_CMD)) < 0) {\n                    RETURN_FALSE;\n                }\n                if ((resp = redis_sock_read(redis_sock, &resp_len)) == NULL) {\n                    RETURN_FALSE;\n                } else if (redis_strncmp(resp, ZEND_STRL(\"+OK\")) != 0) {\n                    efree(resp);\n                    RETURN_FALSE;\n                }\n                efree(resp);\n                REDIS_ENABLE_MODE(redis_sock, MULTI);\n            }\n        }\n    } else {\n        php_error_docref(NULL, E_WARNING, \"Unknown mode sent to Redis::multi\");\n        RETURN_FALSE;\n    }\n\n    RETURN_ZVAL(getThis(), 1, 0);\n}\n\n/* discard */\nPHP_METHOD(Redis, discard)\n{\n    int ret = FAILURE;\n    RedisSock *redis_sock;\n    zval *object;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O\",\n                                     &object, redis_ce) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((redis_sock = redis_sock_get(object, 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    if (IS_PIPELINE(redis_sock)) {\n        ret = SUCCESS;\n        smart_string_free(&redis_sock->pipeline_cmd);\n    } else if (IS_MULTI(redis_sock)) {\n        ret = redis_send_discard(redis_sock);\n    }\n    if (ret == SUCCESS) {\n        redis_free_reply_callbacks(redis_sock);\n        redis_sock->mode = ATOMIC;\n        RETURN_TRUE;\n    }\n    RETURN_FALSE;\n}\n\nPHP_REDIS_API int\nredis_sock_read_multibulk_multi_reply(INTERNAL_FUNCTION_PARAMETERS,\n                                      RedisSock *redis_sock, zval *z_tab)\n{\n\n    char inbuf[4096];\n    size_t len;\n\n    if (redis_sock_gets(redis_sock, inbuf, sizeof(inbuf) - 1, &len) < 0 ||\n        *inbuf != TYPE_MULTIBULK || atoi(inbuf + 1) < 0\n    ) {\n        return FAILURE;\n    }\n\n    // No command issued, return empty immutable array\n    if (redis_sock->reply_callback == NULL) {\n        ZVAL_EMPTY_ARRAY(z_tab);\n        return SUCCESS;\n    }\n\n    array_init(z_tab);\n\n    return redis_sock_read_multibulk_multi_reply_loop(INTERNAL_FUNCTION_PARAM_PASSTHRU,\n                    redis_sock, z_tab);\n}\n\n\n/* exec */\nPHP_METHOD(Redis, exec)\n{\n    RedisSock *redis_sock;\n    int ret;\n    zval *object, z_ret;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(),\n                                     \"O\", &object, redis_ce) == FAILURE ||\n        (redis_sock = redis_sock_get(object, 0)) == NULL\n    ) {\n        RETURN_FALSE;\n    }\n\n    ZVAL_FALSE(&z_ret);\n\n    if (IS_MULTI(redis_sock)) {\n        if (IS_PIPELINE(redis_sock)) {\n            PIPELINE_ENQUEUE_COMMAND(RESP_EXEC_CMD, sizeof(RESP_EXEC_CMD) - 1);\n            REDIS_SAVE_CALLBACK(NULL, NULL);\n            REDIS_DISABLE_MODE(redis_sock, MULTI);\n            RETURN_ZVAL(getThis(), 1, 0);\n        }\n        if (redis_sock_write(redis_sock, ZEND_STRL(RESP_EXEC_CMD)) < 0) {\n            RETURN_FALSE;\n        }\n        ret = redis_sock_read_multibulk_multi_reply(\n            INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, &z_ret);\n        redis_free_reply_callbacks(redis_sock);\n        REDIS_DISABLE_MODE(redis_sock, MULTI);\n        redis_sock->watching = 0;\n        if (ret < 0) {\n            zval_dtor(&z_ret);\n            ZVAL_FALSE(&z_ret);\n        }\n    }\n\n    if (IS_PIPELINE(redis_sock)) {\n        if (redis_sock->pipeline_cmd.len == 0) {\n            /* Empty array when no command was run. */\n            ZVAL_EMPTY_ARRAY(&z_ret);\n        } else {\n            if (redis_sock_write(redis_sock, redis_sock->pipeline_cmd.c,\n                    redis_sock->pipeline_cmd.len) < 0) {\n                ZVAL_FALSE(&z_ret);\n            } else {\n                array_init(&z_ret);\n                if (redis_sock_read_multibulk_multi_reply_loop(\n                    INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, &z_ret) != SUCCESS) {\n                    zval_dtor(&z_ret);\n                    ZVAL_FALSE(&z_ret);\n                }\n            }\n            smart_string_free(&redis_sock->pipeline_cmd);\n        }\n        redis_free_reply_callbacks(redis_sock);\n        REDIS_DISABLE_MODE(redis_sock, PIPELINE);\n    }\n    RETURN_ZVAL(&z_ret, 0, 1);\n}\n\nPHP_REDIS_API int\nredis_response_enqueued(RedisSock *redis_sock)\n{\n    char *resp;\n    int resp_len, ret = FAILURE;\n\n    if ((resp = redis_sock_read(redis_sock, &resp_len)) != NULL) {\n        if (redis_strncmp(resp, ZEND_STRL(\"+QUEUED\")) == 0) {\n            ret = SUCCESS;\n        }\n        efree(resp);\n    }\n    return ret;\n}\n\nPHP_REDIS_API int\nredis_sock_read_multibulk_multi_reply_loop(INTERNAL_FUNCTION_PARAMETERS,\n                                           RedisSock *redis_sock, zval *z_tab)\n{\n    fold_item fi;\n    size_t i;\n\n    for (i = 0; i < redis_sock->reply_callback_count; i++) {\n        fi = redis_sock->reply_callback[i];\n        if (fi.fun) {\n            fi.fun(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, fi.ctx);\n            continue;\n        }\n        size_t len;\n        char inbuf[255];\n\n        if (redis_sock_gets(redis_sock, inbuf, sizeof(inbuf) - 1, &len) < 0 ||\n            redis_strncmp(inbuf, ZEND_STRL(\"+OK\")) != 0)\n        {\n            return FAILURE;\n        }\n\n        while (redis_sock->reply_callback[++i].fun) {\n            if (redis_response_enqueued(redis_sock) != SUCCESS) {\n                return FAILURE;\n            }\n        }\n\n        if (redis_sock_gets(redis_sock, inbuf, sizeof(inbuf) - 1, &len) < 0) {\n            return FAILURE;\n        }\n\n        zval z_ret;\n        array_init(&z_ret);\n        add_next_index_zval(z_tab, &z_ret);\n\n        int num = atol(inbuf + 1);\n\n        if (num > 0 && redis_read_multibulk_recursive(redis_sock, num, 0, &z_ret) < 0) {\n            return FAILURE;\n        }\n    }\n    return SUCCESS;\n}\n\nPHP_METHOD(Redis, pipeline)\n{\n    RedisSock *redis_sock;\n    zval *object;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(),\n                                     \"O\", &object, redis_ce) == FAILURE ||\n        (redis_sock = redis_sock_get(object, 0)) == NULL\n    ) {\n        RETURN_FALSE;\n    }\n\n    /* User cannot enter MULTI mode if already in a pipeline */\n    if (IS_MULTI(redis_sock)) {\n        php_error_docref(NULL, E_ERROR, \"Can't activate pipeline in multi mode!\");\n        RETURN_FALSE;\n    }\n\n    /* Enable pipeline mode unless we're already in that mode in which case this\n     * is just a NO OP */\n    if (IS_ATOMIC(redis_sock)) {\n        /* NB : we keep the function fold, to detect the last function.\n         * We need the response format of the n - 1 command. So, we can delete\n         * when n > 2, the { 1 .. n - 2} commands */\n        REDIS_ENABLE_MODE(redis_sock, PIPELINE);\n    }\n\n    RETURN_ZVAL(getThis(), 1, 0);\n}\n\n/* {{{ proto long Redis::publish(string channel, string msg) */\nPHP_METHOD(Redis, publish)\n{\n    REDIS_PROCESS_KW_CMD(\"PUBLISH\", redis_key_str_cmd, redis_long_response);\n}\n/* }}} */\n\n/* {{{ proto void Redis::psubscribe([pattern1, pattern2, ... patternN]) */\nPHP_METHOD(Redis, psubscribe)\n{\n    REDIS_PROCESS_KW_CMD(\"PSUBSCRIBE\", redis_subscribe_cmd,\n        redis_subscribe_response);\n}\n/* }}} */\n\n/* {{{ proto void Redis::ssubscribe([shardchannel1, shardchannel2, ... shardchannelN]) */\nPHP_METHOD(Redis, ssubscribe)\n{\n    REDIS_PROCESS_KW_CMD(\"SSUBSCRIBE\", redis_subscribe_cmd,\n        redis_subscribe_response);\n}\n/* }}} */\n\n/* {{{ proto void Redis::subscribe([channel1, channel2, ... channelN]) */\nPHP_METHOD(Redis, subscribe) {\n    REDIS_PROCESS_KW_CMD(\"SUBSCRIBE\", redis_subscribe_cmd,\n        redis_subscribe_response);\n}\n\n/**\n *  [ps]unsubscribe channel_0 channel_1 ... channel_n\n *  [ps]unsubscribe([channel_0, channel_1, ..., channel_n])\n * response format :\n * array(\n *    channel_0 => TRUE|FALSE,\n *    channel_1 => TRUE|FALSE,\n *    ...\n *    channel_n => TRUE|FALSE\n * );\n **/\n\nPHP_METHOD(Redis, unsubscribe)\n{\n    REDIS_PROCESS_KW_CMD(\"UNSUBSCRIBE\", redis_unsubscribe_cmd,\n        redis_unsubscribe_response);\n}\n\nPHP_METHOD(Redis, punsubscribe)\n{\n    REDIS_PROCESS_KW_CMD(\"PUNSUBSCRIBE\", redis_unsubscribe_cmd,\n        redis_unsubscribe_response);\n}\n\nPHP_METHOD(Redis, sunsubscribe)\n{\n    REDIS_PROCESS_KW_CMD(\"SUNSUBSCRIBE\", redis_unsubscribe_cmd,\n        redis_unsubscribe_response);\n}\n\nPHP_METHOD(Redis, waitaof) {\n    REDIS_PROCESS_CMD(waitaof, redis_read_variant_reply);\n}\n\n/* {{{ proto string Redis::bgrewriteaof() */\nPHP_METHOD(Redis, bgrewriteaof)\n{\n    REDIS_PROCESS_KW_CMD(\"BGREWRITEAOF\", redis_empty_cmd,\n        redis_boolean_response);\n}\n/* }}} */\n\n/* {{{ public function slaveof(string $host = NULL, int $port = NULL): Redis|bool }}} */\nPHP_METHOD(Redis, slaveof) {\n    REDIS_PROCESS_KW_CMD(\"SLAVEOF\", redis_replicaof_cmd, redis_boolean_response);\n}\n/* }}} */\n\n/* {{{ public function replicaof(string $host = NULL, int $port = NULL): Redis|bool }}} */\nPHP_METHOD(Redis, replicaof) {\n    REDIS_PROCESS_KW_CMD(\"REPLICAOF\", redis_replicaof_cmd, redis_boolean_response);\n}\n\n/* }}} */\n/* {{{ proto string Redis::object(key) */\nPHP_METHOD(Redis, object)\n{\n    REDIS_PROCESS_CMD(object, redis_object_response);\n}\n/* }}} */\n\n/* {{{ proto string Redis::getOption($option) */\nPHP_METHOD(Redis, getOption)\n{\n    RedisSock *redis_sock;\n\n    if ((redis_sock = redis_sock_get_instance(getThis(), 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    redis_getoption_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, NULL);\n}\n/* }}} */\n\n/* {{{ proto string Redis::setOption(string $option, mixed $value) */\nPHP_METHOD(Redis, setOption)\n{\n    RedisSock *redis_sock;\n\n    if ((redis_sock = redis_sock_get_instance(getThis(), 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    redis_setoption_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, NULL);\n}\n/* }}} */\n\n/* {{{ proto boolean Redis::config(string op, string key [, mixed value]) */\n/* {{{ proto public function config(string $op, string ...$args) }}} */\n// CONFIG SET/GET\nPHP_METHOD(Redis, config) {\n    REDIS_PROCESS_CMD(config, redis_config_response);\n}\n/* }}} */\n\n\n/* {{{ proto boolean Redis::slowlog(string arg, [int option]) */\nPHP_METHOD(Redis, slowlog) {\n    REDIS_PROCESS_CMD(slowlog, redis_read_variant_reply);\n}\n\n/* {{{ proto Redis::wait(int num_slaves, int ms) }}} */\nPHP_METHOD(Redis, wait) {\n    REDIS_PROCESS_KW_CMD(\"WAIT\", redis_long_long_cmd, redis_long_response);\n}\n\n/*\n * {{{ proto Redis::pubsub(\"channels\", pattern);\n *     proto Redis::pubsub(\"numsub\", Array channels);\n *     proto Redis::pubsub(\"numpat\"); }}}\n */\nPHP_METHOD(Redis, pubsub) {\n    REDIS_PROCESS_CMD(pubsub, redis_pubsub_response);\n}\n\n/* {{{ proto variant Redis::eval(string script, [array keys, long num_keys]) */\nPHP_METHOD(Redis, eval) {\n    REDIS_PROCESS_KW_CMD(\"EVAL\", redis_eval_cmd, redis_read_raw_variant_reply);\n}\n\n/* {{{ proto variant Redis::eval_ro(string script, [array keys, long num_keys]) */\nPHP_METHOD(Redis, eval_ro) {\n    REDIS_PROCESS_KW_CMD(\"EVAL_RO\", redis_eval_cmd, redis_read_raw_variant_reply);\n}\n\n/* {{{ proto variant Redis::evalsha(string sha1, [array keys, long num_keys]) */\nPHP_METHOD(Redis, evalsha) {\n    REDIS_PROCESS_KW_CMD(\"EVALSHA\", redis_eval_cmd, redis_read_raw_variant_reply);\n}\n\n/* {{{ proto variant Redis::evalsha_ro(string sha1, [array keys, long num_keys]) */\nPHP_METHOD(Redis, evalsha_ro) {\n    REDIS_PROCESS_KW_CMD(\"EVALSHA_RO\", redis_eval_cmd, redis_read_raw_variant_reply);\n}\n\n/* {{{ proto variant Redis::fcall(string fn [, array keys [, array args]]) */\nPHP_METHOD(Redis, fcall) {\n    REDIS_PROCESS_KW_CMD(\"FCALL\", redis_fcall_cmd, redis_read_raw_variant_reply);\n}\n\n/* {{{ proto variant Redis::fcall_ro(string fn [, array keys [, array args]]) */\nPHP_METHOD(Redis, fcall_ro) {\n    REDIS_PROCESS_KW_CMD(\"FCALL_RO\", redis_fcall_cmd, redis_read_raw_variant_reply);\n}\n\n/* {{{ public function script($args...): mixed }}} */\nPHP_METHOD(Redis, script) {\n    REDIS_PROCESS_CMD(script, redis_read_variant_reply);\n}\n\n/* {{{ proto DUMP key */\nPHP_METHOD(Redis, dump) {\n    REDIS_PROCESS_KW_CMD(\"DUMP\", redis_key_cmd, redis_string_response);\n}\n/* }}} */\n\n/* {{{ proto Redis::restore(ttl, key, value) */\nPHP_METHOD(Redis, restore) {\n    REDIS_PROCESS_CMD(restore, redis_boolean_response);\n}\n/* }}} */\n\n/* {{{ proto Redis::debug(string key) */\nPHP_METHOD(Redis, debug) {\n    REDIS_PROCESS_KW_CMD(\"DEBUG\", redis_key_cmd, redis_string_response);\n}\n/* }}} */\n\n/* {{{ proto Redis::migrate(host port key dest-db timeout [bool copy,\n *                          bool replace]) */\nPHP_METHOD(Redis, migrate) {\n    REDIS_PROCESS_CMD(migrate, redis_boolean_response);\n}\n\n/* {{{ proto Redis::_prefix(key) */\nPHP_METHOD(Redis, _prefix) {\n    RedisSock *redis_sock;\n\n    if ((redis_sock = redis_sock_get_instance(getThis(), 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    redis_prefix_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock);\n}\n\n/* {{{ proto Redis::_serialize(value) */\nPHP_METHOD(Redis, _serialize) {\n    RedisSock *redis_sock;\n\n    // Grab socket\n    if ((redis_sock = redis_sock_get_instance(getThis(), 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    redis_serialize_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock);\n}\n\n/* {{{ proto Redis::_unserialize(value) */\nPHP_METHOD(Redis, _unserialize) {\n    RedisSock *redis_sock;\n\n    // Grab socket\n    if ((redis_sock = redis_sock_get_instance(getThis(), 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    redis_unserialize_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock,\n        redis_exception_ce);\n}\n\nPHP_METHOD(Redis, _compress) {\n    RedisSock *redis_sock;\n\n    // Grab socket\n    if ((redis_sock = redis_sock_get_instance(getThis(), 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    redis_compress_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock);\n}\n\nPHP_METHOD(Redis, _uncompress) {\n    RedisSock *redis_sock;\n\n    // Grab socket\n    if ((redis_sock = redis_sock_get_instance(getThis(), 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    redis_uncompress_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock,\n        redis_exception_ce);\n}\n\nPHP_METHOD(Redis, _pack) {\n    RedisSock *redis_sock;\n\n    // Grab socket\n    if ((redis_sock = redis_sock_get_instance(getThis(), 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    redis_pack_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock);\n}\n\nPHP_METHOD(Redis, _unpack) {\n    RedisSock *redis_sock;\n\n    // Grab socket\n    if ((redis_sock = redis_sock_get_instance(getThis(), 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    redis_unpack_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock);\n}\n\n/* {{{ proto Redis::getLastError() */\nPHP_METHOD(Redis, getLastError) {\n    zval *object;\n    RedisSock *redis_sock;\n\n    // Grab our object\n    if(zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O\",\n                                    &object, redis_ce) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    // Grab socket\n    if ((redis_sock = redis_sock_get_instance(object, 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    /* Return our last error or NULL if we don't have one */\n    if (redis_sock->err) {\n        RETURN_STRINGL(ZSTR_VAL(redis_sock->err), ZSTR_LEN(redis_sock->err));\n    }\n    RETURN_NULL();\n}\n\n/* {{{ proto Redis::clearLastError() */\nPHP_METHOD(Redis, clearLastError) {\n    zval *object;\n    RedisSock *redis_sock;\n\n    // Grab our object\n    if(zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O\",\n                                    &object, redis_ce) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n    // Grab socket\n    if ((redis_sock = redis_sock_get_instance(object, 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    // Clear error message\n    if (redis_sock->err) {\n        zend_string_release(redis_sock->err);\n        redis_sock->err = NULL;\n    }\n\n    RETURN_TRUE;\n}\n\n/*\n * {{{ proto long Redis::getMode()\n */\nPHP_METHOD(Redis, getMode) {\n    zval *object;\n    RedisSock *redis_sock;\n\n    /* Grab our object */\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O\", &object, redis_ce) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    /* Grab socket */\n    if ((redis_sock = redis_sock_get_instance(object, 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    if (IS_PIPELINE(redis_sock)) {\n        RETVAL_LONG(PIPELINE);\n    } else if (IS_MULTI(redis_sock)) {\n        RETVAL_LONG(MULTI);\n    } else {\n        RETVAL_LONG(ATOMIC);\n    }\n}\n\n/* {{{ proto Redis::time() */\nPHP_METHOD(Redis, time) {\n    REDIS_PROCESS_KW_CMD(\"TIME\", redis_empty_cmd, redis_mbulk_reply_raw);\n}\n\n/* {{{ proto array Redis::role() */\nPHP_METHOD(Redis, role) {\n    REDIS_PROCESS_KW_CMD(\"ROLE\", redis_empty_cmd, redis_read_variant_reply);\n}\n\n/*\n * Introspection stuff\n */\n\n/* {{{ proto Redis::IsConnected */\nPHP_METHOD(Redis, isConnected) {\n    zval *object;\n    RedisSock *redis_sock;\n\n    /* Grab our object */\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O\", &object, redis_ce) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    /* Grab socket */\n    if ((redis_sock = redis_sock_get_instance(object, 1)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    RETURN_BOOL(redis_sock->status >= REDIS_SOCK_STATUS_CONNECTED);\n}\n\n/* {{{ proto Redis::getHost() */\nPHP_METHOD(Redis, getHost) {\n    RedisSock *redis_sock;\n\n    if((redis_sock = redis_sock_get_connected(INTERNAL_FUNCTION_PARAM_PASSTHRU))) {\n        RETURN_STRINGL(ZSTR_VAL(redis_sock->host), ZSTR_LEN(redis_sock->host));\n    } else {\n        RETURN_FALSE;\n    }\n}\n\n/* {{{ proto Redis::getPort() */\nPHP_METHOD(Redis, getPort) {\n    RedisSock *redis_sock;\n\n    if((redis_sock = redis_sock_get_connected(INTERNAL_FUNCTION_PARAM_PASSTHRU))) {\n        /* Return our port */\n        RETURN_LONG(redis_sock->port);\n    } else {\n        RETURN_FALSE;\n    }\n}\n\n/* {{{ proto Redis::getDBNum */\nPHP_METHOD(Redis, getDBNum) {\n    RedisSock *redis_sock;\n\n    if((redis_sock = redis_sock_get_connected(INTERNAL_FUNCTION_PARAM_PASSTHRU))) {\n        /* Return our db number */\n        RETURN_LONG(redis_sock->dbNumber);\n    } else {\n        RETURN_FALSE;\n    }\n}\n\nPHP_METHOD(Redis, getTransferredBytes) {\n    RedisSock *redis_sock;\n\n    if ((redis_sock = redis_sock_get_instance(getThis(), 0)) == NULL) {\n        RETURN_THROWS();\n    }\n\n    array_init_size(return_value, 2);\n    add_next_index_long(return_value, redis_sock->txBytes);\n    add_next_index_long(return_value, redis_sock->rxBytes);\n}\n\nPHP_METHOD(Redis, clearTransferredBytes) {\n    RedisSock *redis_sock;\n\n    if ((redis_sock = redis_sock_get_instance(getThis(), 0)) == NULL) {\n        RETURN_THROWS();\n    }\n\n    redis_sock->txBytes = 0;\n    redis_sock->rxBytes = 0;\n}\n\n/* {{{ proto Redis::getTimeout */\nPHP_METHOD(Redis, getTimeout) {\n    RedisSock *redis_sock;\n\n    if((redis_sock = redis_sock_get_connected(INTERNAL_FUNCTION_PARAM_PASSTHRU))) {\n        RETURN_DOUBLE(redis_sock->timeout);\n    } else {\n        RETURN_FALSE;\n    }\n}\n\n/* {{{ proto Redis::getReadTimeout */\nPHP_METHOD(Redis, getReadTimeout) {\n    RedisSock *redis_sock;\n\n    if((redis_sock = redis_sock_get_connected(INTERNAL_FUNCTION_PARAM_PASSTHRU))) {\n        RETURN_DOUBLE(redis_sock->read_timeout);\n    } else {\n        RETURN_FALSE;\n    }\n}\n\n/* {{{ proto Redis::getPersistentID */\nPHP_METHOD(Redis, getPersistentID) {\n    RedisSock *redis_sock;\n\n    if ((redis_sock = redis_sock_get_connected(INTERNAL_FUNCTION_PARAM_PASSTHRU)) == NULL) {\n        RETURN_FALSE;\n    } else if (redis_sock->persistent_id == NULL) {\n        RETURN_NULL();\n    }\n    RETURN_STRINGL(ZSTR_VAL(redis_sock->persistent_id), ZSTR_LEN(redis_sock->persistent_id));\n}\n\n/* {{{ proto Redis::getAuth */\nPHP_METHOD(Redis, getAuth) {\n    RedisSock *redis_sock;\n    zval zret;\n\n    if (zend_parse_parameters_none() == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    redis_sock = redis_sock_get_connected(INTERNAL_FUNCTION_PARAM_PASSTHRU);\n    if (redis_sock == NULL)\n        RETURN_FALSE;\n\n    if (redis_sock->user && redis_sock->pass) {\n        array_init(&zret);\n        add_next_index_str(&zret, zend_string_copy(redis_sock->user));\n        add_next_index_str(&zret, zend_string_copy(redis_sock->pass));\n        RETURN_ZVAL(&zret, 0, 0);\n    } else if (redis_sock->pass) {\n        RETURN_STR_COPY(redis_sock->pass);\n    } else {\n        RETURN_NULL();\n    }\n}\n\n/* {{{ proto mixed Redis::client(string $command, [ $arg1 ... $argN]) */\nPHP_METHOD(Redis, client) {\n    REDIS_PROCESS_CMD(client, redis_client_response);\n}\n/* }}} */\n\n/* {{{ proto mixed Redis::rawcommand(string $command, [ $arg1 ... $argN]) */\nPHP_METHOD(Redis, rawcommand) {\n    int argc, cmd_len;\n    char *cmd = NULL;\n    RedisSock *redis_sock;\n    zval *z_args;\n\n    ZEND_PARSE_PARAMETERS_START(1, -1)\n        Z_PARAM_VARIADIC('+', z_args, argc)\n    ZEND_PARSE_PARAMETERS_END();\n\n    if (redis_build_raw_cmd(z_args, argc, &cmd, &cmd_len) < 0 ||\n               (redis_sock = redis_sock_get(getThis(), 0)) == NULL\n    ) {\n        if (cmd) efree(cmd);\n        RETURN_FALSE;\n    }\n\n    /* Execute our command */\n    REDIS_PROCESS_REQUEST(redis_sock, cmd, cmd_len);\n    if (IS_ATOMIC(redis_sock)) {\n        redis_read_raw_variant_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU,redis_sock,NULL,NULL);\n    }\n    REDIS_PROCESS_RESPONSE(redis_read_variant_reply);\n}\n/* }}} */\n\n/* {{{ proto array Redis::command()\n *     proto array Redis::command('info', string cmd)\n *     proto array Redis::command('getkeys', array cmd_args) */\nPHP_METHOD(Redis, command) {\n    REDIS_PROCESS_CMD(command, redis_command_response);\n}\n/* }}} */\n\n/* {{{ proto array Redis::copy(string $source, string $destination, array $options = null) */\nPHP_METHOD(Redis, copy) {\n    REDIS_PROCESS_CMD(copy, redis_1_response)\n}\n/* }}} */\n\n/* Helper to format any combination of SCAN arguments */\nPHP_REDIS_API int\nredis_build_scan_cmd(char **cmd, REDIS_SCAN_TYPE type, char *key, int key_len,\n                     long iter, char *pattern, int pattern_len, int count,\n                     zend_string *match_type)\n{\n    smart_string cmdstr = {0};\n    char *keyword;\n    int argc;\n\n    /* Count our arguments +1 for key if it's got one, and + 2 for pattern */\n    /* or count given that they each carry keywords with them. */\n    argc = 1 + (key_len > 0) + (pattern_len > 0 ? 2 : 0) + (count > 0 ? 2 : 0) + (match_type ? 2 : 0);\n\n    /* Turn our type into a keyword */\n    switch(type) {\n        case TYPE_SCAN:\n            keyword = \"SCAN\";\n            break;\n        case TYPE_SSCAN:\n            keyword = \"SSCAN\";\n            break;\n        case TYPE_HSCAN:\n            keyword = \"HSCAN\";\n            break;\n        case TYPE_ZSCAN:\n        default:\n            keyword = \"ZSCAN\";\n            break;\n    }\n\n    /* Start the command */\n    redis_cmd_init_sstr(&cmdstr, argc, keyword, strlen(keyword));\n    if (key_len) redis_cmd_append_sstr(&cmdstr, key, key_len);\n    redis_cmd_append_sstr_long(&cmdstr, iter);\n\n    /* Append COUNT if we've got it */\n    if(count) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"COUNT\");\n        redis_cmd_append_sstr_int(&cmdstr, count);\n    }\n\n    /* Append MATCH if we've got it */\n    if(pattern_len) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"MATCH\");\n        redis_cmd_append_sstr(&cmdstr, pattern, pattern_len);\n    }\n\n    if (match_type) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"TYPE\");\n        redis_cmd_append_sstr(&cmdstr, ZSTR_VAL(match_type), ZSTR_LEN(match_type));\n    }\n\n    /* Return our command length */\n    *cmd = cmdstr.c;\n    return cmdstr.len;\n}\n\n/* {{{ proto redis::scan(&$iterator, [pattern, [count, [type]]]) */\nPHP_REDIS_API void\ngeneric_scan_cmd(INTERNAL_FUNCTION_PARAMETERS, REDIS_SCAN_TYPE type) {\n    zval *object, *z_cursor;\n    RedisSock *redis_sock;\n    HashTable *hash;\n    char *pattern = NULL, *cmd, *key = NULL;\n    int cmd_len, num_elements, key_free = 0, pattern_free = 0;\n    size_t key_len = 0, pattern_len = 0;\n    zend_string *match_type = NULL;\n    zend_long count = 0;\n    zend_bool completed;\n    uint64_t cursor;\n\n    /* Different prototype depending on if this is a key based scan */\n    if(type != TYPE_SCAN) {\n        // Requires a key\n        if(zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(),\n                                        \"Os!z/|s!l\", &object, redis_ce, &key,\n                                        &key_len, &z_cursor, &pattern,\n                                        &pattern_len, &count)==FAILURE)\n        {\n            RETURN_FALSE;\n        }\n    } else {\n        // Doesn't require a key\n        if(zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(),\n                                        \"Oz/|s!lS!\", &object, redis_ce, &z_cursor,\n                                        &pattern, &pattern_len, &count, &match_type)\n                                        == FAILURE)\n        {\n            RETURN_FALSE;\n        }\n    }\n\n    /* Grab our socket */\n    if ((redis_sock = redis_sock_get(object, 0)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    /* Calling this in a pipeline makes no sense */\n    if (!IS_ATOMIC(redis_sock)) {\n        php_error_docref(NULL, E_ERROR,\n            \"Can't call SCAN commands in multi or pipeline mode!\");\n        RETURN_FALSE;\n    }\n\n    /* Get our SCAN cursor short circuiting if we're done */\n    cursor = redisGetScanCursor(z_cursor, &completed);\n    if (completed)\n        RETURN_FALSE;\n\n    /* Prefix our key if we've got one and we have a prefix set */\n    if(key_len) {\n        key_free = redis_key_prefix(redis_sock, &key, &key_len);\n    }\n\n    if (redis_sock->scan & REDIS_SCAN_PREFIX) {\n        pattern_free = redis_key_prefix(redis_sock, &pattern, &pattern_len);\n    }\n\n    /**\n     * Redis can return to us empty keys, especially in the case where there\n     * are a large number of keys to scan, and we're matching against a\n     * pattern.  phpredis can be set up to abstract this from the user, by\n     * setting OPT_SCAN to REDIS_SCAN_RETRY.  Otherwise we will return empty\n     * keys and the user will need to make subsequent calls with an updated\n     * iterator.\n     */\n    do {\n        /* Free our previous reply if we're back in the loop.  We know we are\n         * if our return_value is an array */\n        if (Z_TYPE_P(return_value) == IS_ARRAY) {\n            zval_dtor(return_value);\n            ZVAL_NULL(return_value);\n        }\n\n        // Format our SCAN command\n        cmd_len = redis_build_scan_cmd(&cmd, type, key, key_len, (long)cursor,\n                                   pattern, pattern_len, count, match_type);\n\n        /* Execute our command getting our new iterator value */\n        REDIS_PROCESS_REQUEST(redis_sock, cmd, cmd_len);\n        if(redis_sock_read_scan_reply(INTERNAL_FUNCTION_PARAM_PASSTHRU,\n                                      redis_sock,type, &cursor) < 0)\n        {\n            if(key_free) efree(key);\n            RETURN_FALSE;\n        }\n\n        /* Get the number of elements */\n        hash = Z_ARRVAL_P(return_value);\n        num_elements = zend_hash_num_elements(hash);\n    } while (redis_sock->scan & REDIS_SCAN_RETRY && cursor != 0 &&\n            num_elements == 0);\n\n    /* Free our pattern if it was prefixed */\n    if (pattern_free) efree(pattern);\n\n    /* Free our key if it was prefixed */\n    if(key_free) efree(key);\n\n    /* Update our iterator reference */\n    redisSetScanCursor(z_cursor, cursor);\n}\n\nPHP_METHOD(Redis, scan) {\n    generic_scan_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, TYPE_SCAN);\n}\nPHP_METHOD(Redis, hscan) {\n    generic_scan_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, TYPE_HSCAN);\n}\nPHP_METHOD(Redis, sscan) {\n    generic_scan_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, TYPE_SSCAN);\n}\nPHP_METHOD(Redis, zscan) {\n    generic_scan_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, TYPE_ZSCAN);\n}\n\n/*\n * HyperLogLog based commands\n */\n\n/* {{{ proto Redis::pfAdd(string key, array elements) }}} */\nPHP_METHOD(Redis, pfadd) {\n    REDIS_PROCESS_CMD(pfadd, redis_long_response);\n}\n\n/* {{{ proto Redis::pfCount(string key) }}}*/\nPHP_METHOD(Redis, pfcount) {\n    REDIS_PROCESS_CMD(pfcount, redis_long_response);\n}\n\n/* {{{ proto Redis::pfMerge(string dstkey, array keys) }}}*/\nPHP_METHOD(Redis, pfmerge) {\n    REDIS_PROCESS_CMD(pfmerge, redis_boolean_response);\n}\n\n/*\n * Geo commands\n */\n\nPHP_METHOD(Redis, geoadd) {\n    REDIS_PROCESS_CMD(geoadd, redis_long_response);\n}\n\nPHP_METHOD(Redis, geohash) {\n    REDIS_PROCESS_KW_CMD(\"GEOHASH\", redis_key_varval_cmd, redis_mbulk_reply_raw);\n}\n\nPHP_METHOD(Redis, geopos) {\n    REDIS_PROCESS_KW_CMD(\"GEOPOS\", redis_key_varval_cmd, redis_read_variant_reply);\n}\n\nPHP_METHOD(Redis, geodist) {\n    REDIS_PROCESS_CMD(geodist, redis_bulk_double_response);\n}\n\nPHP_METHOD(Redis, georadius) {\n    REDIS_PROCESS_KW_CMD(\"GEORADIUS\", redis_georadius_cmd, redis_read_variant_reply);\n}\n\nPHP_METHOD(Redis, georadius_ro) {\n    REDIS_PROCESS_KW_CMD(\"GEORADIUS_RO\", redis_georadius_cmd, redis_read_variant_reply);\n}\n\nPHP_METHOD(Redis, georadiusbymember) {\n    REDIS_PROCESS_KW_CMD(\"GEORADIUSBYMEMBER\", redis_georadiusbymember_cmd, redis_read_variant_reply);\n}\n\nPHP_METHOD(Redis, georadiusbymember_ro) {\n    REDIS_PROCESS_KW_CMD(\"GEORADIUSBYMEMBER_RO\", redis_georadiusbymember_cmd, redis_read_variant_reply);\n}\n\nPHP_METHOD(Redis, geosearch) {\n    REDIS_PROCESS_CMD(geosearch, redis_geosearch_response);\n}\n\nPHP_METHOD(Redis, geosearchstore) {\n    REDIS_PROCESS_CMD(geosearchstore, redis_long_response);\n}\n\n/*\n * Streams\n */\n\nPHP_METHOD(Redis, xack) {\n    REDIS_PROCESS_CMD(xack, redis_long_response);\n}\n\nPHP_METHOD(Redis, xadd) {\n    REDIS_PROCESS_CMD(xadd, redis_read_variant_reply);\n}\n\nPHP_METHOD(Redis, xautoclaim) {\n    REDIS_PROCESS_CMD(xautoclaim, redis_xclaim_reply);\n}\n\nPHP_METHOD(Redis, xclaim) {\n    REDIS_PROCESS_CMD(xclaim, redis_xclaim_reply);\n}\n\nPHP_METHOD(Redis, xdel) {\n    REDIS_PROCESS_KW_CMD(\"XDEL\", redis_key_str_arr_cmd, redis_long_response);\n}\n\nPHP_METHOD(Redis, xgroup) {\n    REDIS_PROCESS_CMD(xgroup, redis_read_variant_reply);\n}\n\nPHP_METHOD(Redis, xinfo) {\n    REDIS_PROCESS_CMD(xinfo, redis_xinfo_reply);\n}\n\nPHP_METHOD(Redis, xlen) {\n    REDIS_PROCESS_KW_CMD(\"XLEN\", redis_key_cmd, redis_long_response);\n}\n\nPHP_METHOD(Redis, xpending) {\n    REDIS_PROCESS_CMD(xpending, redis_read_variant_reply_strings);\n}\n\nPHP_METHOD(Redis, xrange) {\n    REDIS_PROCESS_KW_CMD(\"XRANGE\", redis_xrange_cmd, redis_xrange_reply);\n}\n\nPHP_METHOD(Redis, xread) {\n    REDIS_PROCESS_CMD(xread, redis_xread_reply);\n}\n\nPHP_METHOD(Redis, xreadgroup) {\n    REDIS_PROCESS_CMD(xreadgroup, redis_xread_reply);\n}\n\nPHP_METHOD(Redis, xrevrange) {\n    REDIS_PROCESS_KW_CMD(\"XREVRANGE\", redis_xrange_cmd, redis_xrange_reply);\n}\n\nPHP_METHOD(Redis, xtrim) {\n    REDIS_PROCESS_CMD(xtrim, redis_long_response);\n}\n\n/* vim: set tabstop=4 softtabstop=4 expandtab shiftwidth=4: */\n"
        },
        {
          "name": "redis.stub.php",
          "type": "blob",
          "size": 180.0380859375,
          "content": "<?php\n\n/**\n * @generate-function-entries\n * @generate-legacy-arginfo\n * @generate-class-entries\n */\n\nclass Redis {\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_NOT_FOUND\n     *\n     */\n    public const REDIS_NOT_FOUND = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_STRING\n     *\n     */\n    public const REDIS_STRING = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_SET\n     *\n     */\n    public const REDIS_SET = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_LIST\n     *\n     */\n    public const REDIS_LIST = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_ZSET\n     *\n     */\n    public const REDIS_ZSET = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_HASH\n     *\n     */\n    public const REDIS_HASH = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_STREAM\n     *\n     */\n    public const REDIS_STREAM = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue ATOMIC\n     *\n     */\n    public const ATOMIC = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue MULTI\n     *\n     */\n    public const MULTI = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue PIPELINE\n     *\n     */\n    public const PIPELINE = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_OPT_SERIALIZER\n     *\n     */\n    public const OPT_SERIALIZER = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_OPT_PREFIX\n     *\n     */\n    public const OPT_PREFIX = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_OPT_READ_TIMEOUT\n     *\n     */\n    public const OPT_READ_TIMEOUT = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_OPT_TCP_KEEPALIVE\n     *\n     */\n    public const OPT_TCP_KEEPALIVE = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_OPT_COMPRESSION\n     *\n     */\n    public const OPT_COMPRESSION = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_OPT_REPLY_LITERAL\n     *\n     */\n    public const OPT_REPLY_LITERAL = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_OPT_COMPRESSION_LEVEL\n     *\n     */\n    public const OPT_COMPRESSION_LEVEL = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_OPT_NULL_MBULK_AS_NULL\n     *\n     */\n    public const OPT_NULL_MULTIBULK_AS_NULL = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_SERIALIZER_NONE\n     *\n     */\n    public const SERIALIZER_NONE = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_SERIALIZER_PHP\n     *\n     */\n    public const SERIALIZER_PHP = UNKNOWN;\n\n#ifdef HAVE_REDIS_IGBINARY\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_SERIALIZER_IGBINARY\n     *\n     */\n    public const SERIALIZER_IGBINARY = UNKNOWN;\n#endif\n\n#ifdef HAVE_REDIS_MSGPACK\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_SERIALIZER_MSGPACK\n     *\n     */\n    public const SERIALIZER_MSGPACK = UNKNOWN;\n#endif\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_SERIALIZER_JSON\n     *\n     */\n    public const SERIALIZER_JSON = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_COMPRESSION_NONE\n     *\n     */\n    public const COMPRESSION_NONE = UNKNOWN;\n\n#ifdef HAVE_REDIS_LZF\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_COMPRESSION_LZF\n     *\n     */\n    public const COMPRESSION_LZF = UNKNOWN;\n#endif\n\n#ifdef HAVE_REDIS_ZSTD\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_COMPRESSION_ZSTD\n     *\n     */\n    public const COMPRESSION_ZSTD = UNKNOWN;\n\n#ifdef ZSTD_CLEVEL_DEFAULT\n    /**\n     *\n     * @var int\n     * @cvalue ZSTD_CLEVEL_DEFAULT\n     *\n     */\n    public const COMPRESSION_ZSTD_DEFAULT = UNKNOWN;\n#else\n    /**\n     *\n     * @var int\n     *\n     */\n    public const COMPRESSION_ZSTD_DEFAULT = 3;\n#endif\n\n#if ZSTD_VERSION_NUMBER >= 10400\n    /**\n     *\n     * @var int\n     * @cvalue ZSTD_minCLevel()\n     *\n     */\n    public const COMPRESSION_ZSTD_MIN = UNKNOWN;\n#else\n    /**\n    *\n    * @var int\n    *\n    */\n    public const COMPRESSION_ZSTD_MIN = 1;\n#endif\n\n    /**\n     * @var int\n     * @cvalue ZSTD_maxCLevel()\n     */\n    public const COMPRESSION_ZSTD_MAX = UNKNOWN;\n#endif\n\n#ifdef HAVE_REDIS_LZ4\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_COMPRESSION_LZ4\n     *\n     */\n    public const COMPRESSION_LZ4 = UNKNOWN;\n#endif\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_OPT_SCAN\n     *\n     */\n    public const OPT_SCAN = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_SCAN_RETRY\n     *\n     */\n    public const SCAN_RETRY = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_SCAN_NORETRY\n     *\n     */\n    public const SCAN_NORETRY = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_SCAN_PREFIX\n     *\n     */\n    public const SCAN_PREFIX = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_SCAN_NOPREFIX\n     *\n     */\n    public const SCAN_NOPREFIX = UNKNOWN;\n\n    /**\n     *\n     * @var string\n     *\n     */\n    public const BEFORE = \"before\";\n\n    /**\n     *\n     * @var string\n     *\n     */\n    public const AFTER = \"after\";\n\n    /**\n     *\n     * @var string\n     *\n     */\n    public const LEFT = \"left\";\n\n    /**\n     *\n     * @var string\n     *\n     */\n    public const RIGHT = \"right\";\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_OPT_MAX_RETRIES\n     *\n     */\n    public const OPT_MAX_RETRIES = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_OPT_BACKOFF_ALGORITHM\n     *\n     */\n    public const OPT_BACKOFF_ALGORITHM = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_BACKOFF_ALGORITHM_DEFAULT\n     *\n     */\n    public const BACKOFF_ALGORITHM_DEFAULT = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_BACKOFF_ALGORITHM_CONSTANT\n     *\n     */\n    public const BACKOFF_ALGORITHM_CONSTANT = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_BACKOFF_ALGORITHM_UNIFORM\n     *\n     */\n    public const BACKOFF_ALGORITHM_UNIFORM = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_BACKOFF_ALGORITHM_EXPONENTIAL\n     *\n     */\n    public const BACKOFF_ALGORITHM_EXPONENTIAL = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_BACKOFF_ALGORITHM_FULL_JITTER\n     *\n     */\n    public const BACKOFF_ALGORITHM_FULL_JITTER = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_BACKOFF_ALGORITHM_EQUAL_JITTER\n     *\n     */\n    public const BACKOFF_ALGORITHM_EQUAL_JITTER = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_BACKOFF_ALGORITHM_DECORRELATED_JITTER\n     *\n     */\n    public const BACKOFF_ALGORITHM_DECORRELATED_JITTER = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_OPT_BACKOFF_BASE\n     *\n     */\n    public const OPT_BACKOFF_BASE = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_OPT_BACKOFF_CAP\n     *\n     */\n    public const OPT_BACKOFF_CAP = UNKNOWN;\n\n    /**\n     * Create a new Redis instance.  If passed sufficient information in the\n     * options array it is also possible to connect to an instance at the same\n     * time.\n     *\n     * **NOTE**:  Below is an example options array with various setting\n     *\n     *     $options = [\n     *         'host'           => 'localhost',\n     *         'port'           => 6379,\n     *         'readTimeout'    => 2.5,\n     *         'connectTimeout' => 2.5,\n     *         'persistent'     => true,\n     *\n     *         // Valid formats: NULL, ['user', 'pass'], 'pass', or ['pass']\n     *         'auth' => ['phpredis', 'phpredis'],\n     *\n     *         // See PHP stream options for valid SSL configuration settings.\n     *         'ssl' => ['verify_peer' => false],\n     *\n     *         // How quickly to retry a connection after we time out or it  closes.\n     *         // Note that this setting is overridden by 'backoff' strategies.\n     *         'retryInterval'  => 100,\n     *\n     *          // Which backoff algorithm to use.  'decorrelated jitter' is\n     *          // likely the best one for most solution, but there are many\n     *          // to choose from:\n     *          //     REDIS_BACKOFF_ALGORITHM_DEFAULT\n     *          //     REDIS_BACKOFF_ALGORITHM_CONSTANT\n     *          //     REDIS_BACKOFF_ALGORITHM_UNIFORM\n     *          //     REDIS_BACKOFF_ALGORITHM_EXPONENTIAL\n     *          //     REDIS_BACKOFF_ALGORITHM_FULL_JITTER\n     *          //     REDIS_BACKOFF_ALGORITHM_EQUAL_JITTER\n     *          //     REDIS_BACKOFF_ALGORITHM_DECORRELATED_JITTER\n     *          // 'base', and 'cap' are in milliseconds and represent the first\n     *          // delay redis will use when reconnecting, and the maximum delay\n     *          // we will reach while retrying.\n     *         'backoff' => [\n     *             'algorithm' => Redis::BACKOFF_ALGORITHM_DECORRELATED_JITTER,\n     *             'base'      => 500,\n     *             'cap'       => 750,\n     *         ]\n     *     ];\n     *\n     * Note: If you do wish to connect via the constructor, only 'host' is\n     *       strictly required, which will cause PhpRedis to connect to that\n     *       host on Redis' default port (6379).\n     *\n     *\n     * @see Redis::connect()\n     * @see https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n     * @param array $options\n     *\n     * @return Redis\n     */\n    public function __construct(?array $options = null);\n\n    public function __destruct();\n\n    /**\n     * Compress a value with the currently configured compressor as set with\n     * Redis::setOption().\n     *\n     * @see Redis::setOption()\n     *\n     * @param  string $value The value to be compressed\n     * @return string        The compressed result\n     *\n     */\n    public function _compress(string $value): string;\n\n    /**\n     * Uncompress the provided argument that has been compressed with the\n     * currently configured compressor as set with Redis::setOption().\n     *\n     * @see Redis::setOption()\n     *\n     * @param  string $value  The compressed value to uncompress.\n     * @return string         The uncompressed result.\n     *\n     */\n    public function _uncompress(string $value): string;\n\n    /**\n     * Prefix the passed argument with the currently set key prefix as set\n     * with Redis::setOption().\n     *\n     * @param string  $key The key/string to prefix\n     * @return string      The prefixed string\n     *\n     */\n    public function _prefix(string $key): string;\n\n    /**\n     * Serialize the provided value with the currently set serializer as set\n     * with Redis::setOption().\n     *\n     * @see Redis::setOption()\n     *\n     * @param mixed $value The value to serialize\n     * @return string      The serialized result\n     *\n     */\n    public function _serialize(mixed $value): string;\n\n    /**\n     * Unserialize the passed argument with the currently set serializer as set\n     * with Redis::setOption().\n     *\n     * @see Redis::setOption()\n     *\n     * @param string $value The value to unserialize\n     * @return mixed        The unserialized result\n     *\n     */\n    public function _unserialize(string $value): mixed;\n\n    /**\n     * Pack the provided value with the configured serializer and compressor\n     * as set with Redis::setOption().\n     *\n     * @param  mixed $value  The value to pack\n     * @return string        The packed result having been serialized and\n     *                       compressed.\n     */\n    public function _pack(mixed $value): string;\n\n    /**\n     * Unpack the provided value with the configured compressor and serializer\n     * as set with Redis::setOption().\n     *\n     * @param  string $value  The value which has been serialized and compressed.\n     * @return mixed          The uncompressed and eserialized value.\n     *\n     */\n    public function _unpack(string $value): mixed;\n\n    public function acl(string $subcmd, string ...$args): mixed;\n\n    /**\n     * Append data to a Redis STRING key.\n     *\n     * @param string $key   The key in question\n     * @param mixed $value  The data to append to the key.\n     *\n     * @return Redis|int|false The new string length of the key or false on failure.\n     *\n     * @see https://redis.io/commands/append\n     *\n     * @example\n     * $redis->set('foo', 'hello);\n     * $redis->append('foo', 'world');\n     */\n    public function append(string $key, mixed $value): Redis|int|false;\n\n    /**\n     * Authenticate a Redis connection after its been established.\n     *\n     *     $redis->auth('password');\n     *     $redis->auth(['password']);\n     *     $redis->auth(['username', 'password']);\n     *\n     * @see https://redis.io/commands/auth\n     *\n     * @param mixed $credentials A string password, or an array with one or two string elements.\n     * @return Redis|bool Whether the AUTH was successful.\n     *\n     */\n    public function auth(#[\\SensitiveParameter] mixed $credentials): Redis|bool;\n\n    /**\n     * Execute a save of the Redis database in the background.\n     *\n     * @see https://redis.io/commands/bgsave\n     *\n     * @return Redis|bool Whether the command was successful.\n     */\n    public function bgSave(): Redis|bool;\n\n    /**\n     * Asynchronously rewrite Redis' append-only file\n     *\n     * @see https://redis.io/commands/bgrewriteaof\n     *\n     * @return Redis|bool Whether the command was successful.\n     */\n    public function bgrewriteaof(): Redis|bool;\n\n    /**\n     * @see https://redis.io/commands/waitaof\n     *\n     * @return Redis|array\n     */\n    public function waitaof(int $numlocal, int $numreplicas, int $timeout): Redis|array|false;\n\n    /**\n     * Count the number of set bits in a Redis string.\n     *\n     * @see https://redis.io/commands/bitcount/\n     *\n     * @param string $key     The key in question (must be a string key)\n     * @param int    $start   The index where Redis should start counting.  If omitted it\n     *                        defaults to zero, which means the start of the string.\n     * @param int    $end     The index where Redis should stop counting.  If omitted it\n     *                        defaults to -1, meaning the very end of the string.\n     *\n     * @param bool   $bybit   Whether or not Redis should treat $start and $end as bit\n     *                        positions, rather than bytes.\n     *\n     * @return Redis|int|false The number of bits set in the requested range.\n     *\n     */\n    public function bitcount(string $key, int $start = 0, int $end = -1, bool $bybit = false): Redis|int|false;\n\n    public function bitop(string $operation, string $deskey, string $srckey, string ...$other_keys): Redis|int|false;\n\n    /**\n     * Return the position of the first bit set to 0 or 1 in a string.\n     *\n     * @see https://redis.io/commands/bitpos/\n     *\n     * @param string $key   The key to check (must be a string)\n     * @param bool   $bit   Whether to look for an unset (0) or set (1) bit.\n     * @param int    $start Where in the string to start looking.\n     * @param int    $end   Where in the string to stop looking.\n     * @param bool   $bybit If true, Redis will treat $start and $end as BIT values and not bytes, so if start\n     *                      was 0 and end was 2, Redis would only search the first two bits.\n     *\n     * @return Redis|int|false The position of the first set or unset bit.\n     **/\n    public function bitpos(string $key, bool $bit, int $start = 0, int $end = -1, bool $bybit = false): Redis|int|false;\n\n    /**\n     * Pop an element off the beginning of a Redis list or lists, potentially blocking up to a specified\n     * timeout.  This method may be called in two distinct ways, of which examples are provided below.\n     *\n     * @see https://redis.io/commands/blpop/\n     *\n     * @param string|array     $key_or_keys    This can either be a string key or an array of one or more\n     *                                         keys.\n     * @param string|float|int $timeout_or_key If the previous argument was a string key, this can either\n     *                                         be an additional key, or the timeout you wish to send to\n     *                                         the command.\n     *\n     * @return Redis|array|null|false Can return various things depending on command and data in Redis.\n     *\n     * @example\n     * $redis->blPop('list1', 'list2', 'list3', 1.5);\n     * $relay->blPop(['list1', 'list2', 'list3'], 1.5);\n     */\n    public function blPop(string|array $key_or_keys, string|float|int $timeout_or_key, mixed ...$extra_args): Redis|array|null|false;\n\n    /**\n     * Pop an element off of the end of a Redis list or lists, potentially blocking up to a specified timeout.\n     * The calling convention is identical to Redis::blPop() so see that documentation for more details.\n     *\n     * @see https://redis.io/commands/brpop/\n     * @see Redis::blPop()\n     *\n     */\n    public function brPop(string|array $key_or_keys, string|float|int $timeout_or_key, mixed ...$extra_args): Redis|array|null|false;\n\n    /**\n     * Pop an element from the end of a Redis list, pushing it to the beginning of another Redis list,\n     * optionally blocking up to a specified timeout.\n     *\n     * @see https://redis.io/commands/brpoplpush/\n     *\n     * @param string    $src     The source list\n     * @param string    $dst     The destination list\n     * @param int|float $timeout The number of seconds to wait.  Note that you must be connected\n     *                           to Redis >= 6.0.0 to send a floating point timeout.\n     *\n     */\n    public function brpoplpush(string $src, string $dst, int|float $timeout): Redis|string|false;\n\n    /**\n     * POP the maximum scoring element off of one or more sorted sets, blocking up to a specified\n     * timeout if no elements are available.\n     *\n     * Following are examples of the two main ways to call this method.\n     *\n     * **NOTE**:  We recommend calling this function with an array and a timeout as the other strategy\n     *            may be deprecated in future versions of PhpRedis\n     *\n     * @see https://redis.io/commands/bzpopmax\n     *\n     * @param string|array $key_or_keys    Either a string key or an array of one or more keys.\n     * @param string|int  $timeout_or_key  If the previous argument was an array, this argument\n     *                                     must be a timeout value.  Otherwise it could also be\n     *                                     another key.\n     * @param mixed       $extra_args      Can consist of additional keys, until the last argument\n     *                                     which needs to be a timeout.\n     *\n     * @return Redis|array|false The popped elements.\n     *\n     * @example\n     * $redis->bzPopMax('key1', 'key2', 'key3', 1.5);\n     * $redis->bzPopMax(['key1', 'key2', 'key3'], 1.5);\n     */\n    public function bzPopMax(string|array $key, string|int $timeout_or_key, mixed ...$extra_args): Redis|array|false;\n\n    /**\n     * POP the minimum scoring element off of one or more sorted sets, blocking up to a specified timeout\n     * if no elements are available\n     *\n     * This command is identical in semantics to bzPopMax so please see that method for more information.\n     *\n     * @see https://redis.io/commands/bzpopmin\n     * @see Redis::bzPopMax()\n     *\n     */\n    public function bzPopMin(string|array $key, string|int $timeout_or_key, mixed ...$extra_args): Redis|array|false;\n\n    /**\n     * POP one or more elements from one or more sorted sets, blocking up to a specified amount of time\n     * when no elements are available.\n     *\n     * @param float  $timeout How long to block if there are no element available\n     * @param array  $keys    The sorted sets to pop from\n     * @param string $from    The string 'MIN' or 'MAX' (case insensitive) telling Redis whether you wish to\n     *                        pop the lowest or highest scoring members from the set(s).\n     * @param int    $count   Pop up to how many elements.\n     *\n     * @return Redis|array|null|false This function will return an array of popped elements, or false\n     *                                depending on whether any elements could be popped within the\n     *                                specified timeout.\n     *\n     * NOTE:  If Redis::OPT_NULL_MULTIBULK_AS_NULL is set to true via Redis::setOption(), this method will\n     *        instead return NULL when Redis doesn't pop any elements.\n     */\n    public function bzmpop(float $timeout, array $keys, string $from, int $count = 1): Redis|array|null|false;\n\n    /**\n     * POP one or more of the highest or lowest scoring elements from one or more sorted sets.\n     *\n     * @see https://redis.io/commands/zmpop\n     *\n     * @param array  $keys  One or more sorted sets\n     * @param string $from  The string 'MIN' or 'MAX' (case insensitive) telling Redis whether you want to\n     *                      pop the lowest or highest scoring elements.\n     * @param int    $count Pop up to how many elements at once.\n     *\n     * @return Redis|array|null|false An array of popped elements or false if none could be popped.\n     */\n    public function zmpop(array $keys, string $from, int $count = 1): Redis|array|null|false;\n\n    /**\n     * Pop one or more elements from one or more Redis LISTs, blocking up to a specified timeout when\n     * no elements are available.\n     *\n     * @see https://redis.io/commands/blmpop\n     *\n     * @param float  $timeout The number of seconds Redis will block when no elements are available.\n     * @param array  $keys    One or more Redis LISTs to pop from.\n     * @param string $from    The string 'LEFT' or 'RIGHT' (case insensitive), telling Redis whether\n     *                        to pop elements from the beginning or end of the LISTs.\n     * @param int    $count   Pop up to how many elements at once.\n     *\n     * @return Redis|array|null|false One or more elements popped from the list(s) or false if all LISTs\n     *                                were empty.\n     */\n    public function blmpop(float $timeout, array $keys, string $from, int $count = 1): Redis|array|null|false;\n\n    /**\n     * Pop one or more elements off of one or more Redis LISTs.\n     *\n     * @see https://redis.io/commands/lmpop\n     *\n     * @param array  $keys  An array with one or more Redis LIST key names.\n     * @param string $from  The string 'LEFT' or 'RIGHT' (case insensitive), telling Redis whether to pop\\\n     *                      elements from the beginning or end of the LISTs.\n     * @param int    $count The maximum number of elements to pop at once.\n     *\n     * @return Redis|array|null|false One or more elements popped from the LIST(s) or false if all the LISTs\n     *                                were empty.\n     *\n     */\n    public function lmpop(array $keys, string $from, int $count = 1): Redis|array|null|false;\n\n    /**\n     * Reset any last error on the connection to NULL\n     *\n     * @see Redis::getLastError()\n     * @return bool This should always return true or throw an exception if we're not connected.\n     *\n     * @example\n     * $redis = new Redis(['host' => 'localhost']);\n     * $redis->set('string', 'this_is_a_string');\n     * $redis->smembers('string');\n     * var_dump($redis->getLastError());\n     * $redis->clearLastError();\n     * var_dump($redis->getLastError());\n     */\n    public function clearLastError(): bool;\n\n    public function client(string $opt, mixed ...$args): mixed;\n\n    public function close(): bool;\n\n    public function command(?string $opt = null, mixed ...$args): mixed;\n\n    /**\n     *  Execute the Redis CONFIG command in a variety of ways.\n     *\n     *  What the command does in particular depends on the `$operation` qualifier.\n     *  Operations that PhpRedis supports are: RESETSTAT, REWRITE, GET, and SET.\n     *\n     * @param string $operation The CONFIG operation to execute (e.g. GET, SET, REWRITE).\n     * @param array|string|null $key_or_settings One or more keys or values.\n     * @param string $value The value if this is a `CONFIG SET` operation.\n     * @see https://redis.io/commands/config\n     *\n     * @example\n     * $redis->config('GET', 'timeout');\n     * $redis->config('GET', ['timeout', 'databases']);\n     * $redis->config('SET', 'timeout', 30);\n     * $redis->config('SET', ['timeout' => 30, 'loglevel' => 'warning']);\n     */\n    public function config(string $operation, array|string|null $key_or_settings = null, ?string $value = null): mixed;\n\n    public function connect(string $host, int $port = 6379, float $timeout = 0, ?string $persistent_id = null,\n                            int $retry_interval = 0, float $read_timeout = 0, ?array $context = null): bool;\n\n    /**\n     * Make a copy of a key.\n     *\n     * $redis = new Redis(['host' => 'localhost']);\n     *\n     * @param string $src     The key to copy\n     * @param string $dst     The name of the new key created from the source key.\n     * @param array  $options An array with modifiers on how COPY should operate.\n     *                        <code>\n     *                        $options = [\n     *                            'REPLACE' => true|false # Whether to replace an existing key.\n     *                            'DB' => int             # Copy key to specific db.\n     *                        ];\n     *                        </code>\n     *\n     * @return Redis|bool True if the copy was completed and false if not.\n     *\n     * @see https://redis.io/commands/copy\n     *\n     * @example\n     * $redis->pipeline()\n     *       ->select(1)\n     *       ->del('newkey')\n     *       ->select(0)\n     *       ->del('newkey')\n     *       ->mset(['source1' => 'value1', 'exists' => 'old_value'])\n     *       ->exec();\n     *\n     * var_dump($redis->copy('source1', 'newkey'));\n     * var_dump($redis->copy('source1', 'newkey', ['db' => 1]));\n     * var_dump($redis->copy('source1', 'exists'));\n     * var_dump($redis->copy('source1', 'exists', ['REPLACE' => true]));\n     */\n    public function copy(string $src, string $dst, ?array $options = null): Redis|bool;\n\n    /**\n     * Return the number of keys in the currently selected Redis database.\n     *\n     * @see https://redis.io/commands/dbsize\n     *\n     * @return Redis|int The number of keys or false on failure.\n     *\n     * @example\n     * $redis = new Redis(['host' => 'localhost']);\n     * $redis->flushdb();\n     * $redis->set('foo', 'bar');\n     * var_dump($redis->dbsize());\n     * $redis->mset(['a' => 'a', 'b' => 'b', 'c' => 'c', 'd' => 'd']);\n     * var_dump($redis->dbsize());\n     */\n    public function dbSize(): Redis|int|false;\n\n    public function debug(string $key): Redis|string;\n\n    /**\n     * Decrement a Redis integer by 1 or a provided value.\n     *\n     * @param string $key The key to decrement\n     * @param int    $by  How much to decrement the key.  Note that if this value is\n     *                    not sent or is set to `1`, PhpRedis will actually invoke\n     *                    the 'DECR' command.  If it is any value other than `1`\n     *                    PhpRedis will actually send the `DECRBY` command.\n     *\n     * @return Redis|int|false The new value of the key or false on failure.\n     *\n     * @see https://redis.io/commands/decr\n     * @see https://redis.io/commands/decrby\n     *\n     * @example $redis->decr('counter');\n     * @example $redis->decr('counter', 2);\n     */\n    public function decr(string $key, int $by = 1): Redis|int|false;\n\n    /**\n     * Decrement a redis integer by a value\n     *\n     * @param string $key   The integer key to decrement.\n     * @param int    $value How much to decrement the key.\n     *\n     * @return Redis|int|false The new value of the key or false on failure.\n     *\n     * @see https://redis.io/commands/decrby\n     *\n     * @example $redis->decrby('counter', 1);\n     * @example $redis->decrby('counter', 2);\n     */\n    public function decrBy(string $key, int $value): Redis|int|false;\n\n    /**\n     * Delete one or more keys from Redis.\n     *\n     * This method can be called in two distinct ways.  The first is to pass a single array\n     * of keys to delete, and the second is to pass N arguments, all names of keys.  See\n     * below for an example of both strategies.\n     *\n     * @param array|string $key_or_keys Either an array with one or more key names or a string with\n     *                                  the name of a key.\n     * @param string       $other_keys  One or more additional keys passed in a variadic fashion.\n     *\n     * @return Redis|int|false The number of keys that were deleted\n     *\n     * @see https://redis.io/commands/del\n     *\n     * @example $redis->del('key:0', 'key:1');\n     * @example $redis->del(['key:2', 'key:3', 'key:4']);\n     */\n    public function del(array|string $key, string ...$other_keys): Redis|int|false;\n\n    /**\n     * @deprecated\n     * @alias Redis::del\n     */\n    public function delete(array|string $key, string ...$other_keys): Redis|int|false;\n\n    /**\n     * Discard a transaction currently in progress.\n     *\n     * @return Redis|bool  True if we could discard the transaction.\n     *\n     * @example\n     * $redis->getMode();\n     * $redis->set('foo', 'bar');\n     * $redis->discard();\n     * $redis->getMode();\n     */\n    public function discard(): Redis|bool;\n\n    /**\n     * Dump Redis' internal binary representation of a key.\n     *\n     * <code>\n     * $redis->zRange('new-zset', 0, -1, true);\n     * </code>\n     *\n     * @param string $key The key to dump.\n     *\n     * @return Redis|string A binary string representing the key's value.\n     *\n     * @see https://redis.io/commands/dump\n     *\n     * @example\n     * $redis->zadd('zset', 0, 'zero', 1, 'one', 2, 'two');\n     * $binary = $redis->dump('zset');\n     * $redis->restore('new-zset', 0, $binary);\n     */\n    public function dump(string $key): Redis|string|false;\n\n    /**\n     * Have Redis repeat back an arbitrary string to the client.\n     *\n     * @param string $str The string to echo\n     *\n     * @return Redis|string|false The string sent to Redis or false on failure.\n     *\n     * @see https://redis.io/commands/echo\n     *\n     * @example $redis->echo('Hello, World');\n     */\n    public function echo(string $str): Redis|string|false;\n\n    /**\n     * Execute a LUA script on the redis server.\n     *\n     * @see https://redis.io/commands/eval/\n     *\n     * @param string $script   A string containing the LUA script\n     * @param array  $args     An array of arguments to pass to this script\n     * @param int    $num_keys How many of the arguments are keys.  This is needed\n     *                         as redis distinguishes between key name arguments\n     *                         and other data.\n     *\n     * @return mixed LUA scripts may return arbitrary data so this method can return\n     *               strings, arrays, nested arrays, etc.\n     */\n    public function eval(string $script, array $args = [], int $num_keys = 0): mixed;\n\n    /**\n     * This is simply the read-only variant of eval, meaning the underlying script\n     * may not modify data in redis.\n     *\n     * @see Redis::eval_ro()\n     */\n    public function eval_ro(string $script_sha, array $args = [], int $num_keys = 0): mixed;\n\n    /**\n     * Execute a LUA script on the server but instead of sending the script, send\n     * the SHA1 hash of the script.\n     *\n     * @param string $script_sha The SHA1 hash of the lua code.  Note that the script\n     *                           must already exist on the server, either having been\n     *                           loaded with `SCRIPT LOAD` or having been executed directly\n     *                           with `EVAL` first.\n     * @param array  $args       Arguments to send to the script.\n     * @param int    $num_keys   The number of arguments that are keys\n     *\n     * @return mixed Returns whatever the specific script does.\n     *\n     * @see https://redis.io/commands/evalsha/\n     * @see Redis::eval();\n     *\n     */\n    public function evalsha(string $sha1, array $args = [], int $num_keys = 0): mixed;\n\n    /**\n     * This is simply the read-only variant of evalsha, meaning the underlying script\n     * may not modify data in redis.\n     *\n     * @see Redis::evalsha()\n     */\n    public function evalsha_ro(string $sha1, array $args = [], int $num_keys = 0): mixed;\n\n    /**\n     * Execute either a MULTI or PIPELINE block and return the array of replies.\n     *\n     * @return Redis|array|false The array of pipeline'd or multi replies or false on failure.\n     *\n     * @see https://redis.io/commands/exec\n     * @see https://redis.io/commands/multi\n     * @see Redis::pipeline()\n     * @see Redis::multi()\n     *\n     * @example\n     * $res = $redis->multi()\n     *              ->set('foo', 'bar')\n     *              ->get('foo')\n     *              ->del('list')\n     *              ->rpush('list', 'one', 'two', 'three')\n     *              ->exec();\n     */\n    public function exec(): Redis|array|false;\n\n    /**\n     * Test if one or more keys exist.\n     *\n     * @param mixed $key         Either an array of keys or a string key\n     * @param mixed $other_keys  If the previous argument was a string, you may send any number of\n     *                           additional keys to test.\n     *\n     * @return Redis|int|bool    The number of keys that do exist and false on failure\n     *\n     * @see https://redis.io/commands/exists\n     *\n     * @example $redis->exists(['k1', 'k2', 'k3']);\n     * @example $redis->exists('k4', 'k5', 'notakey');\n     */\n    public function exists(mixed $key, mixed ...$other_keys): Redis|int|bool;\n\n    /**\n     * Sets an expiration in seconds on the key in question.  If connected to\n     * redis-server >= 7.0.0 you may send an additional \"mode\" argument which\n     * modifies how the command will execute.\n     *\n     * @param string      $key  The key to set an expiration on.\n     * @param int         $timeout  The number of seconds after which key will be automatically deleted.\n     * @param string|null $mode  A two character modifier that changes how the\n     *                      command works.\n     *                      <code>\n     *                      NX - Set expiry only if key has no expiry\n     *                      XX - Set expiry only if key has an expiry\n     *                      LT - Set expiry only when new expiry is < current expiry\n     *                      GT - Set expiry only when new expiry is > current expiry\n     *                      </code>\n     *\n     * @return Redis|bool True if an expiration was set and false otherwise.\n     * @see https://redis.io/commands/expire\n     *\n     */\n    public function expire(string $key, int $timeout, ?string $mode = null): Redis|bool;\n\n    /*\n     * Set a key's expiration to a specific Unix timestamp in seconds.\n     *\n     * If connected to Redis >= 7.0.0 you can pass an optional 'mode' argument.\n     * @see Redis::expire() For a description of the mode argument.\n     *\n     * @param string $key The key to set an expiration on.\n     *\n     * @return Redis|bool True if an expiration was set, false if not.\n     *\n     */\n\n    /**\n     * Set a key to expire at an exact unix timestamp.\n     *\n     * @param string      $key The key to set an expiration on.\n     * @param int         $timestamp The unix timestamp to expire at.\n     * @param string|null $mode An option 'mode' that modifies how the command acts (see {@link Redis::expire}).\n     * @return Redis|bool True if an expiration was set, false if not.\n     *\n     * @see https://redis.io/commands/expireat\n     * @see https://redis.io/commands/expire\n     * @see Redis::expire()\n     */\n    public function expireAt(string $key, int $timestamp, ?string $mode = null): Redis|bool;\n\n    public function failover(?array $to = null, bool $abort = false, int $timeout = 0): Redis|bool;\n\n    /**\n     * Get the expiration of a given key as a unix timestamp\n     *\n     * @param string $key      The key to check.\n     *\n     * @return Redis|int|false The timestamp when the key expires, or -1 if the key has no expiry\n     *                         and -2 if the key doesn't exist.\n     *\n     * @see https://redis.io/commands/expiretime\n     *\n     * @example\n     * $redis->setEx('mykey', 60, 'myval');\n     * $redis->expiretime('mykey');\n     */\n    public function expiretime(string $key): Redis|int|false;\n\n    /**\n     * Get the expiration timestamp of a given Redis key but in milliseconds.\n     *\n     * @see https://redis.io/commands/pexpiretime\n     * @see Redis::expiretime()\n     *\n     * @param string $key      The key to check\n     *\n     * @return Redis|int|false The expiration timestamp of this key (in milliseconds) or -1 if the\n     *                         key has no expiration, and -2 if it does not exist.\n     */\n    public function pexpiretime(string $key): Redis|int|false;\n\n    /**\n     * Invoke a function.\n     *\n     * @param string $fn    The name of the function\n     * @param array  $keys  Optional list of keys\n     * @param array  $args  Optional list of args\n     *\n     * @return mixed        Function may return arbitrary data so this method can return\n     *                      strings, arrays, nested arrays, etc.\n     *\n     * @see https://redis.io/commands/fcall\n     */\n    public function fcall(string $fn, array $keys = [], array $args = []): mixed;\n\n    /**\n     * This is a read-only variant of the FCALL command that cannot execute commands that modify data.\n     *\n     * @param string $fn    The name of the function\n     * @param array  $keys  Optional list of keys\n     * @param array  $args  Optional list of args\n     *\n     * @return mixed        Function may return arbitrary data so this method can return\n     *                      strings, arrays, nested arrays, etc.\n     *\n     * @see https://redis.io/commands/fcall_ro\n     */\n    public function fcall_ro(string $fn, array $keys = [], array $args = []): mixed;\n\n    /**\n     * Deletes every key in all Redis databases\n     *\n     * @param  bool  $sync Whether to perform the task in a blocking or non-blocking way.\n     * @return bool\n     *\n     * @see https://redis.io/commands/flushall\n     */\n    public function flushAll(?bool $sync = null): Redis|bool;\n\n    /**\n     * Deletes all the keys of the currently selected database.\n     *\n     * @param  bool  $sync Whether to perform the task in a blocking or non-blocking way.\n     * @return bool\n     *\n     * @see https://redis.io/commands/flushdb\n     */\n    public function flushDB(?bool $sync = null): Redis|bool;\n\n    /**\n     * Functions is an API for managing code to be executed on the server.\n     *\n     * @param string $operation         The subcommand you intend to execute.  Valid options are as follows\n     *                                  'LOAD'      - Create a new library with the given library name and code.\n     *                                  'DELETE'    - Delete the given library.\n     *                                  'LIST'      - Return general information on all the libraries\n     *                                  'STATS'     - Return information about the current function running\n     *                                  'KILL'      - Kill the current running function\n     *                                  'FLUSH'     - Delete all the libraries\n     *                                  'DUMP'      - Return a serialized payload representing the current libraries\n     *                                  'RESTORE'   - Restore the libraries represented by the given payload\n     * @param member $args              Additional arguments\n     *\n     * @return Redis|bool|string|array  Depends on subcommand.\n     *\n     * @see https://redis.io/commands/function\n     */\n    public function function(string $operation, mixed ...$args): Redis|bool|string|array;\n\n    /**\n     * Add one or more members to a geospacial sorted set\n     *\n     * @param string $key The sorted set to add data to.\n     * @param float  $lng The longitude of the first member\n     * @param float  $lat The latitude of the first member.\n     * @param member $other_triples_and_options You can continue to pass longitude, latitude, and member\n     *               arguments to add as many members as you wish.  Optionally, the final argument may be\n     *               a string with options for the command @see Redis documentation for the options.\n     *\n     * @return Redis|int|false The number of added elements is returned.  If the 'CH' option is specified,\n     *                         the return value is the number of members *changed*.\n     *\n     * @example $redis->geoAdd('cities', -121.8374, 39.7284, 'Chico', -122.03218, 37.322, 'Cupertino');\n     * @example $redis->geoadd('cities', -121.837478, 39.728494, 'Chico', ['XX', 'CH']);\n     *\n     * @see https://redis.io/commands/geoadd\n     */\n\n    public function geoadd(string $key, float $lng, float $lat, string $member, mixed ...$other_triples_and_options): Redis|int|false;\n\n    /**\n     * Get the distance between two members of a geospacially encoded sorted set.\n     *\n     * @param string $key  The Sorted set to query.\n     * @param string $src  The first member.\n     * @param string $dst  The second member.\n     * @param string $unit Which unit to use when computing distance, defaulting to meters.\n     *                     <code>\n     *                     M  - meters\n     *                     KM - kilometers\n     *                     FT - feet\n     *                     MI - miles\n     *                     </code>\n     *\n     * @return Redis|float|false The calculated distance in whichever units were specified or false\n     *                           if one or both members did not exist.\n     *\n     * @example $redis->geodist('cities', 'Chico', 'Cupertino', 'mi');\n     *\n     * @see https://redis.io/commands/geodist\n     */\n    public function geodist(string $key, string $src, string $dst, ?string $unit = null): Redis|float|false;\n\n    /**\n     * Retrieve one or more GeoHash encoded strings for members of the set.\n     *\n     * @param string $key           The key to query\n     * @param string $member        The first member to request\n     * @param string $other_members One or more additional members to request.\n     *\n     * @return Redis|array|false    An array of GeoHash encoded values.\n     *\n     * @see https://redis.io/commands/geohash\n     * @see https://en.wikipedia.org/wiki/Geohash\n     *\n     * @example $redis->geohash('cities', 'Chico', 'Cupertino');\n     */\n    public function geohash(string $key, string $member, string ...$other_members): Redis|array|false;\n\n    /**\n     * Return the longitude and latitude for one or more members of a geospacially encoded sorted set.\n     *\n     * @param string $key           The set to query.\n     * @param string $member        The first member to query.\n     * @param string $other_members One or more members to query.\n     *\n     * @return An array of longitude and latitude pairs.\n     *\n     * @see https://redis.io/commands/geopos\n     *\n     * @example $redis->geopos('cities', 'Seattle', 'New York');\n     */\n    public function geopos(string $key, string $member, string ...$other_members): Redis|array|false;\n\n    /**\n     * Retrieve members of a geospacially sorted set that are within a certain radius of a location.\n     *\n     * @param string $key     The set to query\n     * @param float  $lng     The longitude of the location to query.\n     * @param float  $lat     The latitude of the location to query.\n     * @param float  $radius  The radius of the area to include.\n     * @param string $unit    The unit of the provided radius (defaults to 'meters).\n     *                        See {@link Redis::geodist} for possible units.\n     * @param array  $options An array of options that modifies how the command behaves.\n     *                        <code>\n     *                        $options = [\n     *                            'WITHCOORD',     # Return members and their coordinates.\n     *                            'WITHDIST',      # Return members and their distances from the center.\n     *                            'WITHHASH',      # Return members GeoHash string.\n     *                            'ASC' | 'DESC',  # The sort order of returned members\n     *\n     *                            # Limit to N returned members.  Optionally a two element array may be\n     *                            # passed as the `LIMIT` argument, and the `ANY` argument.\n     *                            'COUNT' => [<int>], or [<int>, <bool>]\n     *\n     *                            # Instead of returning members, store them in the specified key.\n     *                            'STORE' => <string>\n     *\n     *                            # Store the distances in the specified key\n     *                            'STOREDIST' => <string>\n     *                        ];\n     *                        </code>\n     *\n     * @return mixed This command can return various things, depending on the options passed.\n     *\n     * @see https://redis.io/commands/georadius\n     *\n     * @example $redis->georadius('cities', 47.608013, -122.335167, 1000, 'km');\n     */\n    public function georadius(string $key, float $lng, float $lat, float $radius, string $unit, array $options = []): mixed;\n\n    /**\n     * A readonly variant of `GEORADIUS` that may be executed on replicas.\n     *\n     * @see Redis::georadius\n     */\n    public function georadius_ro(string $key, float $lng, float $lat, float $radius, string $unit, array $options = []): mixed;\n\n    /**\n     * Similar to `GEORADIUS` except it uses a member as the center of the query.\n     *\n     * @param string $key     The key to query.\n     * @param string $member  The member to treat as the center of the query.\n     * @param float  $radius  The radius from the member to include.\n     * @param string $unit    The unit of the provided radius\n     *                        See {@link Redis::geodist} for possible units.\n     * @param array  $options An array with various options to modify the command's behavior.\n     *                        See {@link Redis::georadius} for options.\n     *\n     * @return mixed This command can return various things depending on options.\n     *\n     * @example $redis->georadiusbymember('cities', 'Seattle', 200, 'mi');\n     */\n    public function georadiusbymember(string $key, string $member, float $radius, string $unit, array $options = []): mixed;\n\n    /**\n     * This is the read-only variant of `GEORADIUSBYMEMBER` that can be run on replicas.\n     */\n    public function georadiusbymember_ro(string $key, string $member, float $radius, string $unit, array $options = []): mixed;\n\n    /**\n     * Search a geospacial sorted set for members in various ways.\n     *\n     * @param string          $key      The set to query.\n     * @param array|string    $position Either a two element array with longitude and latitude, or\n     *                                  a string representing a member of the set.\n     * @param array|int|float $shape    Either a number representine the radius of a circle to search, or\n     *                                  a two element array representing the width and height of a box\n     *                                  to search.\n     * @param string          $unit     The unit of our shape.  See {@link Redis::geodist} for possible units.\n     * @param array           $options  @see {@link Redis::georadius} for options.  Note that the `STORE`\n     *                                  options are not allowed for this command.\n     */\n    public function geosearch(string $key, array|string $position, array|int|float $shape, string $unit, array $options = []): array;\n\n    /**\n     * Search a geospacial sorted set for members within a given area or range, storing the results into\n     * a new set.\n     *\n     * @param string $dst The destination where results will be stored.\n     * @param string $src The key to query.\n     * @param array|string    $position Either a two element array with longitude and latitude, or\n     *                                  a string representing a member of the set.\n     * @param array|int|float $shape    Either a number representine the radius of a circle to search, or\n     *                                  a two element array representing the width and height of a box\n     *                                  to search.\n     * @param string          $unit     The unit of our shape.  See {@link Redis::geodist} for possible units.\n     * @param array           $options\n     *                        <code>\n     *                        $options = [\n     *                            'ASC' | 'DESC',  # The sort order of returned members\n     *                            'WITHDIST'       # Also store distances.\n     *\n     *                            # Limit to N returned members.  Optionally a two element array may be\n     *                            # passed as the `LIMIT` argument, and the `ANY` argument.\n     *                            'COUNT' => [<int>], or [<int>, <bool>]\n     *                        ];\n     *                        </code>\n     */\n    public function geosearchstore(string $dst, string $src, array|string $position, array|int|float $shape, string $unit, array $options = []): Redis|array|int|false;\n\n    /**\n     * Retrieve a string keys value.\n     *\n     * @param  string  $key The key to query\n     * @return mixed   The keys value or false if it did not exist.\n     *\n     * @see https://redis.io/commands/get\n     *\n     * @example $redis->get('foo');\n     */\n    public function get(string $key): mixed;\n\n    /**\n     * Get the authentication information on the connection, if any.\n     *\n     * @return mixed The authentication information used to authenticate the connection.\n     *\n     * @see Redis::auth()\n     */\n    public function getAuth(): mixed;\n\n    /**\n     * Get the bit at a given index in a string key.\n     *\n     * @param string $key The key to query.\n     * @param int    $idx The Nth bit that we want to query.\n     *\n     * @example $redis->getbit('bitmap', 1337);\n     *\n     * @see https://redis.io/commands/getbit\n     */\n    public function getBit(string $key, int $idx): Redis|int|false;\n\n    /**\n     * Get the value of a key and optionally set it's expiration.\n     *\n     * @param string $key    The key to query\n     * @param array $options Options to modify how the command works.\n     *                       <code>\n     *                       $options = [\n     *                           'EX'     => <seconds>      # Expire in N seconds\n     *                           'PX'     => <milliseconds> # Expire in N milliseconds\n     *                           'EXAT'   => <timestamp>    # Expire at a unix timestamp (in seconds)\n     *                           'PXAT'   => <mstimestamp>  # Expire at a unix timestamp (in milliseconds);\n     *                           'PERSIST'                  # Remove any configured expiration on the key.\n     *                       ];\n     *                       </code>\n     *\n     * @return Redis|string|bool The key's value or false if it didn't exist.\n     *\n     * @see https://redis.io/commands/getex\n     *\n     * @example $redis->getEx('mykey', ['EX' => 60]);\n     */\n    public function getEx(string $key, array $options = []): Redis|string|bool;\n\n    /**\n     * Get the database number PhpRedis thinks we're connected to.\n     *\n     * This value is updated internally in PhpRedis each time {@link Redis::select} is called.\n     *\n     * @return The database we're connected to.\n     *\n     * @see Redis::select()\n     * @see https://redis.io/commands/select\n     */\n    public function getDBNum(): int;\n\n    /**\n     * Get a key from Redis and delete it in an atomic operation.\n     *\n     * @param string $key The key to get/delete.\n     * @return Redis|string|bool The value of the key or false if it didn't exist.\n     *\n     * @see https://redis.io/commands/getdel\n     *\n     * @example $redis->getdel('token:123');\n     */\n    public function getDel(string $key): Redis|string|bool;\n\n    /**\n     * Return the host or Unix socket we are connected to.\n     *\n     * @return string The host or Unix socket.\n     */\n    public function getHost(): string;\n\n    /**\n     * Get the last error returned to us from Redis, if any.\n     *\n     * @return string The error string or NULL if there is none.\n     */\n    public function getLastError(): ?string;\n\n    /**\n     * Returns whether the connection is in ATOMIC, MULTI, or PIPELINE mode\n     *\n     * @return int The mode we're in.\n     *\n     */\n    public function getMode(): int;\n\n    /**\n     * Retrieve the value of a configuration setting as set by Redis::setOption()\n     *\n     * @see Redis::setOption() for a detailed list of options and their values.\n     *\n     * @return mixed The setting itself or false on failure\n     */\n    public function getOption(int $option): mixed;\n\n    /**\n     * Get the persistent connection ID, if there is one.\n     *\n     * @return string The ID or NULL if we don't have one.\n     */\n    public function getPersistentID(): ?string;\n\n    /**\n     * Get the port we are connected to.  This number will be zero if we are connected to a unix socket.\n     *\n     * @return int The port.\n     */\n    public function getPort(): int;\n\n    /**\n     * Retrieve a substring of a string by index.\n     *\n     * @param string $key   The string to query.\n     * @param int    $start The zero-based starting index.\n     * @param int    $end   The zero-based ending index.\n     *\n     * @return Redis|string|false The substring or false on failure.\n     *\n     * @see https://redis.io/commands/getrange\n     *\n     * @example\n     * $redis->set('silly-word', 'Supercalifragilisticexpialidocious');\n     * echo $redis->getRange('silly-word', 0, 4) . \"\\n\";\n     */\n    public function getRange(string $key, int $start, int $end): Redis|string|false;\n\n    /**\n     * Get the longest common subsequence between two string keys.\n     *\n     * @param string $key1    The first key to check\n     * @param string $key2    The second key to check\n     * @param array  $options An optional array of modifiers for the command.\n     *\n     *                        <code>\n     *                        $options = [\n     *                            'MINMATCHLEN'  => int  # Exclude matching substrings that are less than this value\n     *\n     *                            'WITHMATCHLEN' => bool # Whether each match should also include its length.\n     *\n     *                            'LEN'                  # Return the length of the longest subsequence\n     *\n     *                            'IDX'                  # Each returned match will include the indexes where the\n     *                                                   # match occurs in each string.\n     *                        ];\n     *                        </code>\n     *\n     *                        NOTE:  'LEN' cannot be used with 'IDX'.\n     *\n     * @return Redis|string|array|int|false Various reply types depending on options.\n     *\n     * @see https://redis.io/commands/lcs\n     *\n     * @example\n     * $redis->set('seq1', 'gtaggcccgcacggtctttaatgtatccctgtttaccatgccatacctgagcgcatacgc');\n     * $redis->set('seq2', 'aactcggcgcgagtaccaggccaaggtcgttccagagcaaagactcgtgccccgctgagc');\n     * echo $redis->lcs('seq1', 'seq2') . \"\\n\";\n     */\n    public function lcs(string $key1, string $key2, ?array $options = null): Redis|string|array|int|false;\n\n    /**\n     * Get the currently set read timeout on the connection.\n     *\n     * @return float The timeout.\n     */\n    public function getReadTimeout(): float;\n\n    /**\n     * Sets a key and returns any previously set value, if the key already existed.\n     *\n     * @param string $key The key to set.\n     * @param mixed $value The value to set the key to.\n     *\n     * @return Redis|string|false The old value of the key or false if it didn't exist.\n     *\n     * @see https://redis.io/commands/getset\n     *\n     * @example\n     * $redis->getset('captain', 'Pike');\n     * $redis->getset('captain', 'Kirk');\n     */\n    public function getset(string $key, mixed $value): Redis|string|false;\n\n    /**\n     * Retrieve any set connection timeout\n     *\n     * @return float The currently set timeout or false on failure (e.g. we aren't connected).\n     */\n    public function getTimeout(): float|false;\n\n    /**\n     * Get the number of bytes sent and received on the socket.\n     *\n     * @return array An array in the form [$sent_bytes, $received_bytes]\n     */\n    public function getTransferredBytes(): array;\n\n    /**\n     * Reset the number of bytes sent and received on the socket.\n     *\n     * @return void\n     */\n    public function clearTransferredBytes(): void;\n\n    /**\n     * Remove one or more fields from a hash.\n     *\n     * @param string $key          The hash key in question.\n     * @param string $field        The first field to remove\n     * @param string $other_fields One or more additional fields to remove.\n     *\n     * @return Redis|int|false     The number of fields actually removed.\n     *\n     * @see https://redis.io/commands/hdel\n     *\n     * @example $redis->hDel('communication', 'Alice', 'Bob');\n     */\n    public function hDel(string $key, string $field, string ...$other_fields): Redis|int|false;\n\n    /**\n     * Checks whether a field exists in a hash.\n     *\n     * @param string $key   The hash to query.\n     * @param string $field The field to check\n     *\n     * @return Redis|bool   True if it exists, false if not.\n     *\n     * @see https://redis.io/commands/hexists\n     *\n     * @example $redis->hExists('communication', 'Alice');\n     */\n    public function hExists(string $key, string $field): Redis|bool;\n\n    public function hGet(string $key, string $member): mixed;\n\n    /**\n     * Read every field and value from a hash.\n     *\n     * @param string $key The hash to query.\n     * @return Redis|array<string, mixed>|false All fields and values or false if the key didn't exist.\n     *\n     * @see https://redis.io/commands/hgetall\n     *\n     * @example $redis->hgetall('myhash');\n     */\n    public function hGetAll(string $key): Redis|array|false;\n\n    /**\n     * Increment a hash field's value by an integer\n     *\n     * @param string $key   The hash to modify\n     * @param string $field The field to increment\n     * @param int    $value How much to increment the value.\n     *\n     * @return Redis|int|false The new value of the field.\n     *\n     * @see https://redis.io/commands/hincrby\n     *\n     * @example\n     * $redis->hMSet('player:1', ['name' => 'Alice', 'score' => 0]);\n     * $redis->hincrby('player:1', 'score', 10);\n     *\n     */\n    public function hIncrBy(string $key, string $field, int $value): Redis|int|false;\n\n    /**\n     * Increment a hash field by a floating point value\n     *\n     * @param string $key The hash with the field to increment.\n     * @param string $field The field to increment.\n     *\n     * @return Redis|float|false The field value after incremented.\n     *\n     * @see https://redis.io/commands/hincrbyfloat\n     *\n     * @example\n     * $redis->hincrbyfloat('numbers', 'tau', 2 * 3.1415926);\n     */\n    public function hIncrByFloat(string $key, string $field, float $value): Redis|float|false;\n\n    /**\n     * Retrieve all of the fields of a hash.\n     *\n     * @param string $key The hash to query.\n     *\n     * @return Redis|list<string>|false The fields in the hash or false if the hash doesn't exist.\n     *\n     * @see https://redis.io/commands/hkeys\n     *\n     * @example $redis->hkeys('myhash');\n     */\n    public function hKeys(string $key): Redis|array|false;\n\n    /**\n     * Get the number of fields in a hash.\n     *\n     * @see https://redis.io/commands/hlen\n     *\n     * @param string $key The hash to check.\n     *\n     * @return Redis|int|false The number of fields or false if the key didn't exist.\n     *\n     * @example $redis->hlen('myhash');\n     */\n    public function hLen(string $key): Redis|int|false;\n\n    /**\n     * Get one or more fields from a hash.\n     *\n     * @param string $key    The hash to query.\n     * @param array  $fields One or more fields to query in the hash.\n     *\n     * @return Redis|array|false The fields and values or false if the key didn't exist.\n     *\n     * @see https://redis.io/commands/hmget\n     *\n     * @example $redis->hMGet('player:1', ['name', 'score']);\n     */\n    public function hMget(string $key, array $fields): Redis|array|false;\n\n    /**\n     * Add or update one or more hash fields and values\n     *\n     * @param string $key        The hash to create/update\n     * @param array  $fieldvals  An associative array with fields and their values.\n     *\n     * @return Redis|bool True if the operation was successful\n     *\n     * @see https://redis.io/commands/hmset\n     *\n     * @example $redis->hmset('updates', ['status' => 'starting', 'elapsed' => 0]);\n     */\n    public function hMset(string $key, array $fieldvals): Redis|bool;\n\n    /**\n     * Get one or more random field from a hash.\n     *\n     * @param string $key     The hash to query.\n     * @param array  $options An array of options to modify how the command behaves.\n     *\n     *                        <code>\n     *                        $options = [\n     *                            'COUNT'      => int  # An optional number of fields to return.\n     *                            'WITHVALUES' => bool # Also return the field values.\n     *                        ];\n     *                        </code>\n     *\n     * @return Redis|array|string One or more random fields (and possibly values).\n     *\n     * @see https://redis.io/commands/hrandfield\n     *\n     * @example $redis->hrandfield('settings');\n     * @example $redis->hrandfield('settings', ['count' => 2, 'withvalues' => true]);\n     */\n    public function hRandField(string $key, ?array $options = null): Redis|string|array|false;\n\n    /**\n     * Add or update one or more hash fields and values.\n     *\n     * @param string $key             The hash to create/update.\n     * @param mixed  $fields_and_vals Argument pairs of fields and values. Alternatively, an associative array with the\n     *                                fields and their values.\n     *\n     * @return Redis|int|false The number of fields that were added, or false on failure.\n     *\n     * @see https://redis.io/commands/hset/\n     *\n     * @example $redis->hSet('player:1', 'name', 'Kim', 'score', 78);\n     * @example $redis->hSet('player:1', ['name' => 'Kim', 'score' => 78]);\n     */\n    public function hSet(string $key, mixed ...$fields_and_vals): Redis|int|false;\n\n    /**\n     * Set a hash field and value, but only if that field does not exist\n     *\n     * @param string $key   The hash to update.\n     * @param string $field The value to set.\n     *\n     * @return Redis|bool True if the field was set and false if not.\n     *\n     * @see https://redis.io/commands/hsetnx\n     *\n     * @example\n     * $redis->hsetnx('player:1', 'lock', 'enabled');\n     * $redis->hsetnx('player:1', 'lock', 'enabled');\n     */\n    public function hSetNx(string $key, string $field, mixed $value): Redis|bool;\n\n    /**\n     * Get the string length of a hash field\n     *\n     * @param string $key   The hash to query.\n     * @param string $field The field to query.\n     *\n     * @return Redis|int|false The string length of the field or false.\n     *\n     * @example\n     * $redis = new Redis(['host' => 'localhost']);\n     * $redis->del('hash');\n     * $redis->hmset('hash', ['50bytes' => str_repeat('a', 50)]);\n     * $redis->hstrlen('hash', '50bytes');\n     *\n     * @see https://redis.io/commands/hstrlen\n     */\n    public function hStrLen(string $key, string $field): Redis|int|false;\n\n    /**\n     * Get all of the values from a hash.\n     *\n     * @param string $key The hash to query.\n     *\n     * @return Redis|list<mixed>|false The values from the hash.\n     *\n     * @see https://redis.io/commands/hvals\n     *\n     * @example $redis->hvals('player:1');\n     */\n    public function hVals(string $key): Redis|array|false;\n\n\n    /**\n     * Iterate over the fields and values of a hash in an incremental fashion.\n     *\n     * @see https://redis.io/commands/hscan\n     * @see https://redis.io/commands/scan\n     *\n     * @param string $key       The hash to query.\n     * @param int    $iterator  The scan iterator, which should be initialized to NULL before the first call.\n     *                          This value will be updated after every call to hscan, until it reaches zero\n     *                          meaning the scan is complete.\n     * @param string|null $pattern An optional glob-style pattern to filter fields with.\n     * @param int    $count     An optional hint to Redis about how many fields and values to return per HSCAN.\n     *\n     * @return Redis|array|bool An array with a subset of fields and values.\n     *\n     * @example\n     * $redis = new Redis(['host' => 'localhost']);\n     *\n     * $redis->del('big-hash');\n     *\n     * for ($i = 0; $i < 1000; $i++) {\n     *     $fields[\"field:$i\"] = \"value:$i\";\n     * }\n     *\n     * $redis->hmset('big-hash', $fields);\n     *\n     * $it = null;\n     *\n     * do {\n     *     // Scan the hash but limit it to fields that match '*:1?3'\n     *     $fields = $redis->hscan('big-hash', $it, '*:1?3');\n     *\n     *     foreach ($fields as $field => $value) {\n     *         echo \"[$field] => $value\\n\";\n     *     }\n     * } while ($it != 0);\n     */\n    public function hscan(string $key, null|int|string &$iterator, ?string $pattern = null, int $count = 0): Redis|array|bool;\n\n    /**\n     * Set an expiration on a key member (KeyDB only).\n     *\n     * @see https://docs.keydb.dev/docs/commands/#expiremember\n     *\n     * @param string $key The key to expire\n     * @param string $field The field to expire\n     * @param string|null $unit The unit of the ttl (s, or ms).\n     */\n    public function expiremember(string $key, string $field, int $ttl, ?string $unit = null): Redis|int|false;\n\n    /**\n     * Set an expiration on a key membert to a specific unix timestamp (KeyDB only).\n     *\n     * @see https://docs.keydb.dev/docs/commands/#expirememberat\n     *\n     * @param string $key The key to expire\n     * @param string $field The field to expire\n     * @param int $timestamp The unix timestamp to expire at.\n     */\n    public function expirememberat(string $key, string $field, int $timestamp): Redis|int|false;\n\n    /**\n     * Increment a key's value, optionally by a specific amount.\n     *\n     * @see https://redis.io/commands/incr\n     * @see https://redis.io/commands/incrby\n     *\n     * @param string $key The key to increment\n     * @param int    $by  An optional amount to increment by.\n     *\n     * @return Redis|int|false  The new value of the key after incremented.\n     *\n     * @example $redis->incr('mycounter');\n     * @example $redis->incr('mycounter', 10);\n     */\n    public function incr(string $key, int $by = 1): Redis|int|false;\n\n    /**\n     * Increment a key by a specific integer value\n     *\n     * @see https://redis.io/commands/incrby\n     *\n     * @param string $key   The key to increment.\n     * @param int    $value The amount to increment.\n     *\n     * @example\n     * $redis->set('primes', 2);\n     * $redis->incrby('primes', 1);\n     * $redis->incrby('primes', 2);\n     * $redis->incrby('primes', 2);\n     * $redis->incrby('primes', 4);\n     */\n    public function incrBy(string $key, int $value): Redis|int|false;\n\n    /**\n     * Increment a numeric key by a floating point value.\n     *\n     * @param string $key The key to increment\n     * @param floag $value How much to increment (or decrement) the value.\n     *\n     * @return Redis|float|false The new value of the key or false if the key didn't contain a string.\n     *\n     * @example\n     * $redis->incrbyfloat('tau', 3.1415926);\n     * $redis->incrbyfloat('tau', 3.1415926);\n     */\n    public function incrByFloat(string $key, float $value): Redis|float|false;\n\n    /**\n     * Retrieve information about the connected redis-server.  If no arguments are passed to\n     * this function, redis will return every info field.  Alternatively you may pass a specific\n     * section you want returned (e.g. 'server', or 'memory') to receive only information pertaining\n     * to that section.\n     *\n     * If connected to Redis server >= 7.0.0 you may pass multiple optional sections.\n     *\n     * @see https://redis.io/commands/info/\n     *\n     * @param string $sections Optional section(s) you wish Redis server to return.\n     *\n     * @return Redis|array|false\n     */\n    public function info(string ...$sections): Redis|array|false;\n\n    /**\n     * Check if we are currently connected to a Redis instance.\n     *\n     * @return bool True if we are, false if not\n     */\n    public function isConnected(): bool;\n\n    /**\n     * @param string $pattern\n     * @return Redis|list<string>|false\n     */\n    public function keys(string $pattern);\n\n    /**\n     * @param mixed $elements\n     * @return Redis|int|false\n     */\n    public function lInsert(string $key, string $pos, mixed $pivot, mixed $value);\n\n    /**\n     * Retrieve the length of a list.\n     *\n     * @param string $key The list\n     *\n     * @return Redis|int|false The number of elements in the list or false on failure.\n     */\n    public function lLen(string $key): Redis|int|false;\n\n    /**\n     * Move an element from one list into another.\n     *\n     * @param string $src       The source list.\n     * @param string $dst       The destination list\n     * @param string $wherefrom Where in the source list to retrieve the element.  This can be either\n     *                          - `Redis::LEFT`, or `Redis::RIGHT`.\n     * @param string $whereto   Where in the destination list to put the element.  This can be either\n     *                          - `Redis::LEFT`, or `Redis::RIGHT`.\n     * @return Redis|string|false The element removed from the source list.\n     *\n     * @example\n     * $redis->rPush('numbers', 'one', 'two', 'three');\n     * $redis->lMove('numbers', 'odds', Redis::LEFT, Redis::LEFT);\n     */\n    public function lMove(string $src, string $dst, string $wherefrom, string $whereto): Redis|string|false;\n\n    /**\n     * Move an element from one list to another, blocking up to a timeout until an element is available.\n     *\n     * @param string $src       The source list\n     * @param string $dst       The destination list\n     * @param string $wherefrom Where in the source list to extract the element.\n     *                          - `Redis::LEFT`, or `Redis::RIGHT`.\n     * @param string $whereto   Where in the destination list to put the element.\n     *                          - `Redis::LEFT`, or `Redis::RIGHT`.\n     * @param float $timeout    How long to block for an element.\n     *\n     * @return Redis|string|false;\n     *\n     * @example\n     * @redis->lPush('numbers', 'one');\n     * @redis->blmove('numbers', 'odds', Redis::LEFT, Redis::LEFT 1.0);\n     * // This call will block, if no additional elements are in 'numbers'\n     * @redis->blmove('numbers', 'odds', Redis::LEFT, Redis::LEFT, 1.0);\n     */\n    public function blmove(string $src, string $dst, string $wherefrom, string $whereto, float $timeout): Redis|string|false;\n\n    /**\n     * Pop one or more elements off a list.\n     *\n     * @param string $key   The list to pop from.\n     * @param int    $count Optional number of elements to remove.  By default one element is popped.\n     * @return Redis|null|bool|int|array Will return the element(s) popped from the list or false/NULL\n     *                                   if none was removed.\n     *\n     * @see https://redis.io/commands/lpop\n     *\n     * @example $redis->lpop('mylist');\n     * @example $redis->lpop('mylist', 4);\n     */\n    public function lPop(string $key, int $count = 0): Redis|bool|string|array;\n\n    /**\n     * Retrieve the index of an element in a list.\n     *\n     * @param string $key     The list to query.\n     * @param mixed  $value   The value to search for.\n     * @param array  $options Options to configure how the command operates\n     *                        <code>\n     *                        $options = [\n     *                            # How many matches to return.  By default a single match is returned.\n     *                            # If count is set to zero, it means unlimited.\n     *                            'COUNT' => <num-matches>\n     *\n     *                            # Specify which match you want returned.  `RANK` 1 means \"the first match\"\n     *                            # 2 means the second, and so on.  If passed as a negative number the\n     *                            # RANK is computed right to left, so a `RANK` of -1 means \"the last match\".\n     *                            'RANK'  => <rank>\n     *\n     *                            # This argument allows you to limit how many elements Redis will search before\n     *                            # returning.  This is useful to prevent Redis searching very long lists while\n     *                            # blocking the client.\n     *                            'MAXLEN => <max-len>\n     *                        ];\n     *                        </code>\n     *\n     * @return Redis|null|bool|int|array Returns one or more of the matching indexes, or null/false if none were found.\n     */\n    public function lPos(string $key, mixed $value, ?array $options = null): Redis|null|bool|int|array;\n\n    /**\n     * Prepend one or more elements to a list.\n     *\n     * @param string      $key       The list to prepend.\n     * @param mixed       $elements  One or more elements to prepend.\n     *\n     * @return Redis|int The new length of the list after prepending.\n     *\n     * @see https://redis.io/commands/lpush\n     *\n     * @example $redis->lPush('mylist', 'cat', 'bear', 'aligator');\n     */\n    public function lPush(string $key, mixed ...$elements): Redis|int|false;\n\n    /**\n     * Append one or more elements to a list.\n     *\n     * @param string $key      The list to append to.\n     * @param mixed  $elements one or more elements to append.\n     *\n     * @return Redis|int|false The new length of the list\n     *\n     * @see https://redis.io/commands/rpush\n     *\n     * @example $redis->rPush('mylist', 'xray', 'yankee', 'zebra');\n     */\n    public function rPush(string $key, mixed ...$elements): Redis|int|false;\n\n    /**\n     * Prepend an element to a list but only if the list exists\n     *\n     * @param string $key   The key to prepend to.\n     * @param mixed  $value The value to prepend.\n     *\n     * @return Redis|int|false The new length of the list.\n     *\n     */\n    public function lPushx(string $key, mixed $value): Redis|int|false;\n\n    /**\n     * Append an element to a list but only if the list exists\n     *\n     * @param string $key   The key to prepend to.\n     * @param mixed  $value The value to prepend.\n     *\n     * @return Redis|int|false The new length of the list.\n     *\n     */\n    public function rPushx(string $key, mixed $value): Redis|int|false;\n\n    /**\n     * Set a list element at an index to a specific value.\n     *\n     * @param string $key   The list to modify.\n     * @param int    $index The position of the element to change.\n     * @param mixed  $value The new value.\n     *\n     * @return Redis|bool True if the list was modified.\n     *\n     * @see https://redis.io/commands/lset\n     */\n    public function lSet(string $key, int $index, mixed $value): Redis|bool;\n\n    /**\n     * Retrieve the last time Redis' database was persisted to disk.\n     *\n     * @return int The unix timestamp of the last save time\n     *\n     * @see https://redis.io/commands/lastsave\n     */\n    public function lastSave(): int;\n\n    /**\n     * Get the element of a list by its index.\n     *\n     * @param string $key   The key to query\n     * @param int    $index The index to check.\n     * @return mixed The index or NULL/false if the element was not found.\n     */\n    public function lindex(string $key, int $index): mixed;\n\n    /**\n     * Retrieve elements from a list.\n     *\n     * @param string $key   The list to query.\n     * @param int    $start The beginning index to retrieve.  This number can be negative\n     *                      meaning start from the end of the list.\n     * @param int    $end   The end index to retrieve.  This can also be negative to start\n     *                      from the end of the list.\n     *\n     * @return Redis|array|false The range of elements between the indexes.\n     *\n     * @example $redis->lrange('mylist', 0, -1);  // the whole list\n     * @example $redis->lrange('mylist', -2, -1); // the last two elements in the list.\n     */\n    public function lrange(string $key, int $start , int $end): Redis|array|false;\n\n    /**\n     * Remove one or more matching elements from a list.\n     *\n     * @param string $key   The list to truncate.\n     * @param mixed  $value The value to remove.\n     * @param int    $count How many elements matching the value to remove.\n     *\n     * @return Redis|int|false The number of elements removed.\n     *\n     * @see https://redis.io/commands/lrem\n     */\n    public function lrem(string $key, mixed $value, int $count = 0): Redis|int|false;\n\n    /**\n     * Trim a list to a subrange of elements.\n     *\n     * @param string $key   The list to trim\n     * @param int    $start The starting index to keep\n     * @param int    $end   The ending index to keep.\n     *\n     * @return Redis|bool true if the list was trimmed.\n     *\n     * @example $redis->ltrim('mylist', 0, 3);  // Keep the first four elements\n     */\n    public function ltrim(string $key, int $start , int $end): Redis|bool;\n\n    /**\n     * Get one or more string keys.\n     *\n     * @param array $keys The keys to retrieve\n     * @return Redis|array|false an array of keys with their values.\n     *\n     * @example $redis->mget(['key1', 'key2']);\n     */\n    public function mget(array $keys): Redis|array|false;\n\n    public function migrate(string $host, int $port, string|array $key, int $dstdb, int $timeout,\n                            bool $copy = false, bool $replace = false,\n                            #[\\SensitiveParameter] mixed $credentials = null): Redis|bool;\n\n    /**\n     * Move a key to a different database on the same redis instance.\n     *\n     * @param string $key The key to move\n     * @return Redis|bool True if the key was moved\n     */\n    public function move(string $key, int $index): Redis|bool;\n\n    /**\n     * Set one or more string keys.\n     *\n     * @param array $key_values An array with keys and their values.\n     * @return Redis|bool True if the keys could be set.\n     *\n     * @see https://redis.io/commands/mset\n     *\n     * @example $redis->mSet(['foo' => 'bar', 'baz' => 'bop']);\n     */\n    public function mset(array $key_values): Redis|bool;\n\n    /**\n     * Set one or more string keys but only if none of the key exist.\n     *\n     * @param array $key_values An array of keys with their values.\n     *\n     * @return Redis|bool True if the keys were set and false if not.\n     *\n     * @see https://redis.io/commands/msetnx\n     *\n     * @example $redis->msetnx(['foo' => 'bar', 'baz' => 'bop']);\n     */\n    public function msetnx(array $key_values): Redis|bool;\n\n    /**\n     * Begin a transaction.\n     *\n     * @param int $value  The type of transaction to start.  This can either be `Redis::MULTI` or\n     *                    `Redis::PIPELINE'.\n     *\n     * @return Redis|bool True if the transaction could be started.\n     *\n     * @see https://redis.io/commands/multi\n     *\n     * @example\n     * $redis->multi();\n     * $redis->set('foo', 'bar');\n     * $redis->get('foo');\n     * $redis->exec();\n     */\n    public function multi(int $value = Redis::MULTI): bool|Redis;\n\n    public function object(string $subcommand, string $key): Redis|int|string|false;\n\n    /**\n     * @deprecated\n     * @alias Redis::connect\n     */\n    public function open(string $host, int $port = 6379, float $timeout = 0, ?string $persistent_id = null, int $retry_interval = 0, float $read_timeout = 0, ?array $context = null): bool;\n\n    public function pconnect(string $host, int $port = 6379, float $timeout = 0, ?string $persistent_id = null, int $retry_interval = 0, float $read_timeout = 0, ?array $context = null): bool;\n\n    /**\n     * Remove the expiration from a key.\n     *\n     * @param string $key The key to operate against.\n     *\n     * @return Redis|bool True if a timeout was removed and false if it was not or the key didn't exist.\n     */\n    public function persist(string $key): Redis|bool;\n\n    /**\n     *  Sets an expiration in milliseconds on a given key.  If connected to Redis >= 7.0.0\n     *  you can pass an optional mode argument that modifies how the command will execute.\n     *\n     *  @see Redis::expire() for a description of the mode argument.\n     *\n     *  @param string      $key  The key to set an expiration on.\n     *  @param int         $timeout  The number of milliseconds after which key will be automatically deleted.\n     *  @param string|null $mode  A two character modifier that changes how the\n     *                       command works.\n     *\n     *  @return Redis|bool   True if an expiry was set on the key, and false otherwise.\n     */\n    public function pexpire(string $key, int $timeout, ?string $mode = null): bool;\n\n    /**\n     * Set a key's expiration to a specific Unix Timestamp in milliseconds.  If connected to\n     * Redis >= 7.0.0 you can pass an optional 'mode' argument.\n     *\n     * @see Redis::expire() For a description of the mode argument.\n     *\n     *  @param string      $key  The key to set an expiration on.\n     *  @param int         $timestamp The unix timestamp to expire at.\n     *  @param string|null $mode A two character modifier that changes how the\n     *                       command works.\n     *\n     *  @return Redis|bool   True if an expiration was set on the key, false otherwise.\n     */\n    public function pexpireAt(string $key, int $timestamp, ?string $mode = null): Redis|bool;\n\n    /**\n     * Add one or more elements to a Redis HyperLogLog key\n     *\n     * @see https://redis.io/commands/pfadd\n     *\n     * @param string $key      The key in question.\n     *\n     * @param array  $elements One or more elements to add.\n     *\n     * @return Redis|int Returns 1 if the set was altered, and zero if not.\n     */\n    public function pfadd(string $key, array $elements): Redis|int;\n\n    /**\n     * Retrieve the cardinality of a Redis HyperLogLog key.\n     *\n     * @see https://redis.io/commands/pfcount\n     *\n     * @param string $key_or_keys Either one key or an array of keys\n     *\n     * @return Redis|int The estimated cardinality of the set.\n     */\n    public function pfcount(array|string $key_or_keys): Redis|int|false;\n\n    /**\n     * Merge one or more source HyperLogLog sets into a destination set.\n     *\n     * @see https://redis.io/commands/pfmerge\n     *\n     * @param string $dst     The destination key.\n     * @param array  $srckeys One or more source keys.\n     *\n     * @return Redis|bool Always returns true.\n     */\n    public function pfmerge(string $dst, array $srckeys): Redis|bool;\n\n    /**\n     * PING the redis server with an optional string argument.\n     *\n     * @see https://redis.io/commands/ping\n     *\n     * @param string $message An optional string message that Redis will reply with, if passed.\n     *\n     * @return Redis|string|false If passed no message, this command will simply return `true`.\n     *                            If a message is passed, it will return the message.\n     *\n     * @example $redis->ping();\n     * @example $redis->ping('beep boop');\n     */\n    public function ping(?string $message = null): Redis|string|bool;\n\n    /**\n     * Enter into pipeline mode.\n     *\n     * Pipeline mode is the highest performance way to send many commands to Redis\n     * as they are aggregated into one stream of commands and then all sent at once\n     * when the user calls Redis::exec().\n     *\n     * NOTE:  That this is shorthand for Redis::multi(Redis::PIPELINE)\n     *\n     * @return Redis The redis object is returned, to facilitate method chaining.\n     *\n     * @example\n     * $redis->pipeline()\n     *       ->set('foo', 'bar')\n     *       ->del('mylist')\n     *       ->rpush('mylist', 'a', 'b', 'c')\n     *       ->exec();\n     */\n    public function pipeline(): bool|Redis;\n\n    /**\n     * @deprecated\n     * @alias Redis::pconnect\n     */\n    public function popen(string $host, int $port = 6379, float $timeout = 0, ?string $persistent_id = null, int $retry_interval = 0, float $read_timeout = 0, ?array $context = null): bool;\n\n    /**\n     * Set a key with an expiration time in milliseconds\n     *\n     * @param string $key    The key to set\n     * @param int    $expire The TTL to set, in milliseconds.\n     * @param mixed  $value  The value to set the key to.\n     *\n     * @return Redis|bool True if the key could be set.\n     *\n     * @example $redis->psetex('mykey', 1000, 'myval');\n     */\n    public function psetex(string $key, int $expire, mixed $value): Redis|bool;\n\n    /**\n     * Subscribe to one or more glob-style patterns\n     *\n     * @param array     $patterns One or more patterns to subscribe to.\n     * @param callable  $cb       A callback with the following prototype:\n     *\n     *                            <code>\n     *                            function ($redis, $channel, $message) { }\n     *                            </code>\n     *\n     * @see https://redis.io/commands/psubscribe\n     *\n     * @return bool True if we were subscribed.\n     */\n    public function psubscribe(array $patterns, callable $cb): bool;\n\n    /**\n     * Get a keys time to live in milliseconds.\n     *\n     * @param string $key The key to check.\n     *\n     * @return Redis|int|false The key's TTL or one of two special values if it has none.\n     *                         <code>\n     *                         -1 - The key has no TTL.\n     *                         -2 - The key did not exist.\n     *                         </code>\n     *\n     * @see https://redis.io/commands/pttl\n     *\n     * @example $redis->pttl('ttl-key');\n     */\n    public function pttl(string $key): Redis|int|false;\n\n    /**\n     * Publish a message to a pubsub channel\n     *\n     * @see https://redis.io/commands/publish\n     *\n     * @param string $channel The channel to publish to.\n     * @param string $message The message itself.\n     *\n     * @return Redis|int The number of subscribed clients to the given channel.\n     */\n    public function publish(string $channel, string $message): Redis|int|false;\n\n    public function pubsub(string $command, mixed $arg = null): mixed;\n\n    /**\n     * Unsubscribe from one or more channels by pattern\n     *\n     * @see https://redis.io/commands/punsubscribe\n     * @see https://redis.io/commands/subscribe\n     * @see Redis::subscribe()\n     *\n     * @param array $patterns One or more glob-style patterns of channel names.\n     *\n     * @return Redis|array|bool  The array of subscribed patterns or false on failure.\n     */\n    public function punsubscribe(array $patterns): Redis|array|bool;\n\n    /**\n     * Pop one or more elements from the end of a list.\n     *\n     * @param string $key   A redis LIST key name.\n     * @param int    $count The maximum number of elements to pop at once.\n     *                      NOTE:  The `count` argument requires Redis >= 6.2.0\n     *\n     * @return Redis|array|string|bool One or more popped elements or false if all were empty.\n     *\n     * @see https://redis.io/commands/rpop\n     *\n     * @example $redis->rPop('mylist');\n     * @example $redis->rPop('mylist', 4);\n     */\n    public function rPop(string $key, int $count = 0): Redis|array|string|bool;\n\n    /**\n     * Return a random key from the current database\n     *\n     * @see https://redis.io/commands/randomkey\n     *\n     * @return Redis|string|false A random key name or false if no keys exist\n     *\n     */\n    public function randomKey(): Redis|string|false;\n\n    /**\n     * Execute any arbitrary Redis command by name.\n     *\n     * @param string $command The command to execute\n     * @param mixed  $args    One or more arguments to pass to the command.\n     *\n     * @return mixed Can return any number of things depending on command executed.\n     *\n     * @example $redis->rawCommand('del', 'mystring', 'mylist');\n     * @example $redis->rawCommand('set', 'mystring', 'myvalue');\n     * @example $redis->rawCommand('rpush', 'mylist', 'one', 'two', 'three');\n     */\n    public function rawcommand(string $command, mixed ...$args): mixed;\n\n    /**\n     * Unconditionally rename a key from $old_name to $new_name\n     *\n     * @see https://redis.io/commands/rename\n     *\n     * @param string $old_name The original name of the key\n     * @param string $new_name The new name for the key\n     *\n     * @return Redis|bool True if the key was renamed or false if not.\n     */\n    public function rename(string $old_name, string $new_name): Redis|bool;\n\n    /**\n     * Renames $key_src to $key_dst but only if newkey does not exist.\n     *\n     * @see https://redis.io/commands/renamenx\n     *\n     * @param string $key_src The source key name\n     * @param string $key_dst The destination key name.\n     *\n     * @return Redis|bool True if the key was renamed, false if not.\n     *\n     * @example\n     * $redis->set('src', 'src_key');\n     * $redis->set('existing-dst', 'i_exist');\n     *\n     * $redis->renamenx('src', 'dst');\n     * $redis->renamenx('dst', 'existing-dst');\n     */\n    public function renameNx(string $key_src, string $key_dst): Redis|bool;\n\n    /**\n     * Reset the state of the connection.\n     *\n     * @return Redis|bool Should always return true unless there is an error.\n     */\n    public function reset(): Redis|bool;\n\n    /**\n     * Restore a key by the binary payload generated by the DUMP command.\n     *\n     * @param string $key     The name of the key you wish to create.\n     * @param int    $ttl     What Redis should set the key's TTL (in milliseconds) to once it is created.\n     *                        Zero means no TTL at all.\n     * @param string $value   The serialized binary value of the string (generated by DUMP).\n     * @param array  $options An array of additional options that modifies how the command operates.\n     *\n     *                        <code>\n     *                        $options = [\n     *                            'ABSTTL'          # If this is present, the `$ttl` provided by the user should\n     *                                              # be an absolute timestamp, in milliseconds()\n     *\n     *                            'REPLACE'         # This flag instructs Redis to store the key even if a key with\n     *                                              # that name already exists.\n     *\n     *                            'IDLETIME' => int # Tells Redis to set the keys internal 'idletime' value to a\n     *                                              # specific number (see the Redis command OBJECT for more info).\n     *                            'FREQ'     => int # Tells Redis to set the keys internal 'FREQ' value to a specific\n     *                                              # number (this relates to Redis' LFU eviction algorithm).\n     *                        ];\n     *                        </code>\n     *\n     * @return Redis|bool     True if the key was stored, false if not.\n     *\n     * @see https://redis.io/commands/restore\n     * @see https://redis.io/commands/dump\n     * @see Redis::dump()\n     *\n     * @example\n     * $redis->sAdd('captains', 'Janeway', 'Picard', 'Sisko', 'Kirk', 'Archer');\n     * $serialized = $redis->dump('captains');\n     *\n     * $redis->restore('captains-backup', 0, $serialized);\n     */\n    public function restore(string $key, int $ttl, string $value, ?array $options = null): Redis|bool;\n\n    /**\n     * Query whether the connected instance is a primary or replica\n     *\n     * @return mixed Will return an array with the role of the connected instance unless there is\n     *               an error.\n     */\n    public function role(): mixed;\n\n    /**\n     * Atomically pop an element off the end of a Redis LIST and push it to the beginning of\n     * another.\n     *\n     * @param string $srckey The source key to pop from.\n     * @param string $dstkey The destination key to push to.\n     *\n     * @return Redis|string|false The popped element or false if the source key was empty.\n     *\n     * @see https://redis.io/commands/rpoplpush\n     *\n     * @example\n     * $redis->pipeline()\n     *       ->del('list1', 'list2')\n     *       ->rpush('list1', 'list1-1', 'list1-2')\n     *       ->rpush('list2', 'list2-1', 'list2-2')\n     *       ->exec();\n     *\n     * $redis->rpoplpush('list2', 'list1');\n     */\n    public function rpoplpush(string $srckey, string $dstkey): Redis|string|false;\n\n    /**\n     * Add one or more values to a Redis SET key.\n     *\n     * @param string $key           The key name\n     * @param mixed  $member        A value to add to the set.\n     * @param mixed  $other_members One or more additional values to add\n     *\n     * @return Redis|int|false The number of values added to the set.\n     *\n     * @see https://redis.io/commands/sadd\n     *\n     * @example\n     * $redis->del('myset');\n     *\n     * $redis->sadd('myset', 'foo', 'bar', 'baz');\n     * $redis->sadd('myset', 'foo', 'new');\n     */\n    public function sAdd(string $key, mixed $value, mixed ...$other_values): Redis|int|false;\n\n    /**\n     * Add one or more values to a Redis SET key.  This is an alternative to Redis::sadd() but\n     * instead of being variadic, takes a single array of values.\n     *\n     * @see https://redis.io/commands/sadd\n     * @see Redis::sadd()\n     *\n     * @param string $key       The set to add values to.\n     * @param array  $values    One or more members to add to the set.\n     * @return Redis|int|false  The number of members added to the set.\n     *\n     * @example\n     * $redis->del('myset');\n     *\n     * $redis->sAddArray('myset', ['foo', 'bar', 'baz']);\n     * $redis->sAddArray('myset', ['foo', 'new']);\n     */\n    public function sAddArray(string $key, array $values): int;\n\n    /**\n     * Given one or more Redis SETS, this command returns all of the members from the first\n     * set that are not in any subsequent set.\n     *\n     * @param string $key        The first set\n     * @param string $other_keys One or more additional sets\n     *\n     * @return Redis|array|false Returns the elements from keys 2..N that don't exist in the\n     *                           first sorted set, or false on failure.\n     *\n     * @see https://redis.io/commands/sdiff\n     *\n     * @example\n     * $redis->pipeline()\n     *       ->del('set1', 'set2', 'set3')\n     *       ->sadd('set1', 'apple', 'banana', 'carrot', 'date')\n     *       ->sadd('set2', 'carrot')\n     *       ->sadd('set3', 'apple', 'carrot', 'eggplant')\n     *       ->exec();\n     *\n     * $redis->sdiff('set1', 'set2', 'set3');\n     */\n    public function sDiff(string $key, string ...$other_keys): Redis|array|false;\n\n    /**\n     * This method performs the same operation as SDIFF except it stores the resulting diff\n     * values in a specified destination key.\n     *\n     * @see https://redis.io/commands/sdiffstore\n     * @see Redis::sdiff()\n     *\n     * @param string $dst The key where to store the result\n     * @param string $key The first key to perform the DIFF on\n     * @param string $other_keys One or more additional keys.\n     *\n     * @return Redis|int|false The number of values stored in the destination set or false on failure.\n     */\n    public function sDiffStore(string $dst, string $key, string ...$other_keys): Redis|int|false;\n\n    /**\n     * Given one or more Redis SET keys, this command will return all of the elements that are\n     * in every one.\n     *\n     * @see https://redis.io/commands/sinter\n     *\n     * @param string $key        The first SET key to intersect.\n     * @param string $other_keys One or more Redis SET keys.\n     *\n     * @example\n     * <code>\n     * $redis->pipeline()\n     *       ->del('alice_likes', 'bob_likes', 'bill_likes')\n     *       ->sadd('alice_likes', 'asparagus', 'broccoli', 'carrot', 'potato')\n     *       ->sadd('bob_likes', 'asparagus', 'carrot', 'potato')\n     *       ->sadd('bill_likes', 'broccoli', 'potato')\n     *       ->exec();\n     *\n     * var_dump($redis->sinter('alice_likes', 'bob_likes', 'bill_likes'));\n     * </code>\n     */\n    public function sInter(array|string $key, string ...$other_keys): Redis|array|false;\n\n    /**\n     * Compute the intersection of one or more sets and return the cardinality of the result.\n     *\n     * @param array $keys  One or more set key names.\n     * @param int   $limit A maximum cardinality to return.  This is useful to put an upper bound\n     *                     on the amount of work Redis will do.\n     *\n     * @return Redis|int|false The\n     *\n     * @see https://redis.io/commands/sintercard\n     *\n     * @example\n     * <code>\n     * $redis->sAdd('set1', 'apple', 'pear', 'banana', 'carrot');\n     * $redis->sAdd('set2', 'apple',         'banana');\n     * $redis->sAdd('set3',          'pear', 'banana');\n     *\n     * $redis->sInterCard(['set1', 'set2', 'set3']);\n     * </code>\n     */\n    public function sintercard(array $keys, int $limit = -1): Redis|int|false;\n\n    /**\n     * Perform the intersection of one or more Redis SETs, storing the result in a destination\n     * key, rather than returning them.\n     *\n     * @param array|string $key_or_keys Either a string key, or an array of keys (with at least two\n     *                                  elements, consisting of the destination key name and one\n     *                                  or more source keys names.\n     * @param string       $other_keys  If the first argument was a string, subsequent arguments should\n     *                                  be source key names.\n     *\n     * @return Redis|int|false          The number of values stored in the destination key or false on failure.\n     *\n     * @see https://redis.io/commands/sinterstore\n     * @see Redis::sinter()\n     * <code>\n     * @example $redis->sInterStore(['dst', 'src1', 'src2', 'src3']);\n     * @example $redis->sInterStore('dst', 'src1', 'src'2', 'src3');\n     * </code>\n     */\n    public function sInterStore(array|string $key, string ...$other_keys): Redis|int|false;\n\n    /**\n     * Retrieve every member from a set key.\n     *\n     * @param string $key The set name.\n     *\n     * @return Redis|array|false Every element in the set or false on failure.\n     *\n     * @see https://redis.io/commands/smembers\n     *\n     * @example\n     * $redis->sAdd('tng-crew', ...['Picard', 'Riker', 'Data', 'Worf', 'La Forge', 'Troi', 'Crusher', 'Broccoli']);\n     * $redis->sMembers('tng-crew');\n     */\n    public function sMembers(string $key): Redis|array|false;\n\n    /**\n     * Check if one or more values are members of a set.\n     *\n     * @see https://redis.io/commands/smismember\n     * @see https://redis.io/commands/smember\n     * @see Redis::smember()\n     *\n     * @param string $key           The set to query.\n     * @param string $member        The first value to test if exists in the set.\n     * @param string $other_members Any number of additional values to check.\n     *\n     * @return Redis|array|false An array of integers representing whether each passed value\n     *                           was a member of the set.\n     *\n     * @example\n     * $redis->sAdd('ds9-crew', ...[\"Sisko\", \"Kira\", \"Dax\", \"Worf\", \"Bashir\", \"O'Brien\"]);\n     * $members = $redis->sMIsMember('ds9-crew', ...['Sisko', 'Picard', 'Data', 'Worf']);\n     */\n    public function sMisMember(string $key, string $member, string ...$other_members): Redis|array|false;\n\n    /**\n     * Pop a member from one set and push it onto another.  This command will create the\n     * destination set if it does not currently exist.\n     *\n     * @see https://redis.io/commands/smove\n     *\n     * @param string $src   The source set.\n     * @param string $dst   The destination set.\n     * @param mixed  $value The member you wish to move.\n     *\n     * @return Redis|bool   True if the member was moved, and false if it wasn't in the set.\n     *\n     * @example\n     * $redis->sAdd('numbers', 'zero', 'one', 'two', 'three', 'four');\n     * $redis->sMove('numbers', 'evens', 'zero');\n     * $redis->sMove('numbers', 'evens', 'two');\n     * $redis->sMove('numbers', 'evens', 'four');\n     */\n    public function sMove(string $src, string $dst, mixed $value): Redis|bool;\n\n    /**\n     * Remove one or more elements from a set.\n     *\n     * @see https://redis.io/commands/spop\n     *\n     * @param string $key    The set in question.\n     * @param int    $count  An optional number of members to pop.   This defaults to\n     *                       removing one element.\n     *\n     * @example\n     * $redis->del('numbers', 'evens');\n     * $redis->sAdd('numbers', 'zero', 'one', 'two', 'three', 'four');\n     * $redis->sPop('numbers');\n     */\n    public function sPop(string $key, int $count = 0): Redis|string|array|false;\n\n    /**\n     * Retrieve one or more random members of a set.\n     *\n     * @param string $key   The set to query.\n     * @param int    $count An optional count of members to return.\n     *\n     *                      If this value is positive, Redis will return *up to* the requested\n     *                      number but with unique elements that will never repeat.  This means\n     *                      you may receive fewer then `$count` replies.\n     *\n     *                      If the number is negative, Redis will return the exact number requested\n     *                      but the result may contain duplicate elements.\n     *\n     * @return Redis|array|string|false One or more random members or false on failure.\n     *\n     * @see https://redis.io/commands/srandmember\n     *\n     * @example $redis->sRandMember('myset');\n     * @example $redis->sRandMember('myset', 10);\n     * @example $redis->sRandMember('myset', -10);\n     */\n    public function sRandMember(string $key, int $count = 0): mixed;\n\n    /**\n     * Returns the union of one or more Redis SET keys.\n     *\n     * @see https://redis.io/commands/sunion\n     *\n     * @param string $key         The first SET to do a union with\n     * @param string $other_keys  One or more subsequent keys\n     *\n     * @return Redis|array|false  The union of the one or more input sets or false on failure.\n     *\n     * @example $redis->sunion('set1', 'set2');\n     */\n    public function sUnion(string $key, string ...$other_keys): Redis|array|false;\n\n    /**\n     * Perform a union of one or more Redis SET keys and store the result in a new set\n     *\n     * @see https://redis.io/commands/sunionstore\n     * @see Redis::sunion()\n     *\n     * @param string $dst        The destination key\n     * @param string $key        The first source key\n     * @param string $other_keys One or more additional source keys\n     *\n     * @return Redis|int|false   The number of elements stored in the destination SET or\n     *                           false on failure.\n     */\n    public function sUnionStore(string $dst, string $key, string ...$other_keys): Redis|int|false;\n\n    /**\n     * Persist the Redis database to disk.  This command will block the server until the save is\n     * completed.  For a nonblocking alternative, see Redis::bgsave().\n     *\n     * @see https://redis.io/commands/save\n     * @see Redis::bgsave()\n     *\n     * @return Redis|bool Returns true unless an error occurs.\n     */\n    public function save(): Redis|bool;\n\n    /**\n     * Incrementally scan the Redis keyspace, with optional pattern and type matching.\n     *\n     * A note about Redis::SCAN_NORETRY and Redis::SCAN_RETRY.\n     *\n     * For convenience, PhpRedis can retry SCAN commands itself when Redis returns an empty array of\n     * keys with a nonzero iterator.  This can happen when matching against a pattern that very few\n     * keys match inside a key space with a great many keys.  The following example demonstrates how\n     * to use Redis::scan() with the option disabled and enabled.\n     *\n     * @param int    $iterator The cursor returned by Redis for every subsequent call to SCAN.  On\n     *                         the initial invocation of the call, it should be initialized by the\n     *                         caller to NULL.  Each time SCAN is invoked, the iterator will be\n     *                         updated to a new number, until finally Redis will set the value to\n     *                         zero, indicating that the scan is complete.\n     *\n     * @param string|null $pattern An optional glob-style pattern for matching key names.  If passed as\n     *                         NULL, it is the equivalent of sending '*' (match every key).\n     *\n     * @param int    $count    A hint to redis that tells it how many keys to return in a single\n     *                         call to SCAN.  The larger the number, the longer Redis may block\n     *                         clients while iterating the key space.\n     *\n     * @param string $type     An optional argument to specify which key types to scan (e.g.\n     *                         'STRING', 'LIST', 'SET')\n     *\n     * @return array|false     An array of keys, or false if no keys were returned for this\n     *                         invocation of scan.  Note that it is possible for Redis to return\n     *                         zero keys before having scanned the entire key space, so the caller\n     *                         should instead continue to SCAN until the iterator reference is\n     *                         returned to zero.\n     *\n     * @see https://redis.io/commands/scan\n     * @see Redis::setOption()\n     *\n     * @example\n     * $redis = new Redis(['host' => 'localhost']);\n     *\n     * $redis->setOption(Redis::OPT_SCAN, Redis::SCAN_NORETRY);\n     *\n     * $it = null;\n     *\n     * do {\n     *     $keys = $redis->scan($it, '*zorg*');\n     *     foreach ($keys as $key) {\n     *         echo \"KEY: $key\\n\";\n     *     }\n     * } while ($it != 0);\n     *\n     * $redis->setOption(Redis::OPT_SCAN, Redis::SCAN_RETRY);\n     *\n     * $it = null;\n     *\n     * // When Redis::SCAN_RETRY is enabled, we can use simpler logic, as we will never receive an\n     * // empty array of keys when the iterator is nonzero.\n     * while ($keys = $redis->scan($it, '*zorg*')) {\n     *     foreach ($keys as $key) {\n     *         echo \"KEY: $key\\n\";\n     *     }\n     * }\n     */\n    public function scan(null|int|string &$iterator, ?string $pattern = null, int $count = 0, ?string $type = null): array|false;\n\n    /**\n     * Retrieve the number of members in a Redis set.\n     *\n     * @param string $key The set to get the cardinality of.\n     *\n     * @return Redis|int|false The cardinality of the set or false on failure.\n     *\n     * @see https://redis.io/commands/scard\n     *\n     * @example $redis->scard('set');\n     */\n    public function scard(string $key): Redis|int|false;\n\n    /**\n     * An administrative command used to interact with LUA scripts stored on the server.\n     *\n     * @see https://redis.io/commands/script\n     *\n     * @param string $command The script suboperation to execute.\n     * @param mixed  $args    One or more additional argument\n     *\n     * @return mixed This command returns various things depending on the specific operation executed.\n     *\n     * @example $redis->script('load', 'return 1');\n     * @example $redis->script('exists', sha1('return 1'));\n     */\n    public function script(string $command, mixed ...$args): mixed;\n\n    /**\n     * Select a specific Redis database.\n     *\n     * @param int $db The database to select.  Note that by default Redis has 16 databases (0-15).\n     *\n     * @return Redis|bool true on success and false on failure\n     *\n     * @see https://redis.io/commands/select\n     *\n     * @example $redis->select(1);\n     */\n    public function select(int $db): Redis|bool;\n\n    /**\n     * Create or set a Redis STRING key to a value.\n     *\n     * @param string    $key     The key name to set.\n     * @param mixed     $value   The value to set the key to.\n     * @param array|int $options Either an array with options for how to perform the set or an\n     *                           integer with an expiration.  If an expiration is set PhpRedis\n     *                           will actually send the `SETEX` command.\n     *\n     * OPTION                         DESCRIPTION\n     * ------------                   --------------------------------------------------------------\n     * ['EX' => 60]                   expire 60 seconds.\n     * ['PX' => 6000]                 expire in 6000 milliseconds.\n     * ['EXAT' => time() + 10]        expire in 10 seconds.\n     * ['PXAT' => time()*1000 + 1000] expire in 1 second.\n     * ['KEEPTTL' => true]            Redis will not update the key's current TTL.\n     * ['XX']                         Only set the key if it already exists.\n     * ['NX']                         Only set the key if it doesn't exist.\n     * ['GET']                        Instead of returning `+OK` return the previous value of the\n     *                                key or NULL if the key didn't exist.\n     *\n     * @return Redis|string|bool True if the key was set or false on failure.\n     *\n     * @see https://redis.io/commands/set\n     * @see https://redis.io/commands/setex\n     *\n     * @example $redis->set('key', 'value');\n     * @example $redis->set('key', 'expires_in_60_seconds', 60);\n     */\n    public function set(string $key, mixed $value, mixed $options = null): Redis|string|bool;\n\n    /**\n     * Set a specific bit in a Redis string to zero or one\n     *\n     * @see https://redis.io/commands/setbit\n     *\n     * @param string $key    The Redis STRING key to modify\n     * @param bool   $value  Whether to set the bit to zero or one.\n     *\n     * @return Redis|int|false The original value of the bit or false on failure.\n     *\n     * @example\n     * $redis->set('foo', 'bar');\n     * $redis->setbit('foo', 7, 1);\n     */\n    public function setBit(string $key, int $idx, bool $value): Redis|int|false;\n\n    /**\n     * Update or append to a Redis string at a specific starting index\n     *\n     * @see https://redis.io/commands/setrange\n     *\n     * @param string $key    The key to update\n     * @param int    $index  Where to insert the provided value\n     * @param string $value  The value to copy into the string.\n     *\n     * @return Redis|int|false The new length of the string or false on failure\n     *\n     * @example\n     * $redis->set('message', 'Hello World');\n     * $redis->setRange('message', 6, 'Redis');\n     */\n    public function setRange(string $key, int $index, string $value): Redis|int|false;\n\n    /**\n     * Set a configurable option on the Redis object.\n     *\n     * Following are a list of options you can set:\n     *\n     * | OPTION          | TYPE | DESCRIPTION |\n     * | --------------- | ---- | ----------- |\n     * | OPT_MAX_RETRIES | int  | The maximum number of times Redis will attempt to reconnect if it gets disconnected, before throwing an exception. |\n     * | OPT_SCAN        | enum | Redis::OPT_SCAN_RETRY, or Redis::OPT_SCAN_NORETRY.  Whether PhpRedis should automatically SCAN again when zero keys but a nonzero iterator are returned. |\n     * | OPT_SERIALIZER  | enum | Set the automatic data serializer.<br>`Redis::SERIALIZER_NONE`<br>`Redis::SERIALIZER_PHP`<br>`Redis::SERIALIZER_IGBINARY`<br>`Redis::SERIALIZER_MSGPACK`, `Redis::SERIALIZER_JSON`|\n     * | OPT_PREFIX | string | A string PhpRedis will use to prefix every key we read or write. |\n     * | OPT_READ_TIMEOUT | float | How long PhpRedis will block for a response from Redis before throwing a 'read error on connection' exception. |\n     * | OPT_TCP_KEEPALIVE | bool |   Set or disable TCP_KEEPALIVE on the connection. |\n     * | OPT_COMPRESSION | enum | Set the compression algorithm<br>`Redis::COMPRESSION_NONE`<br>`Redis::COMPRESSION_LZF`<br>`Redis::COMPRESSION_LZ4`<br> `Redis::COMPRESSION_ZSTD` |\n     * | OPT_REPLY_LITERAL | bool | If set to true, PhpRedis will return the literal string Redis returns for LINE replies (e.g. '+OK'), rather than `true`. |\n     * | OPT_COMPRESSION_LEVEL | int | Set a specific compression level if Redis is compressing data. |\n     * | OPT_NULL_MULTIBULK_AS_NULL | bool | Causes PhpRedis to return `NULL` rather than `false` for NULL MULTIBULK replies |\n     * | OPT_BACKOFF_ALGORITHM | enum | The exponential backoff strategy to use. |\n     * | OPT_BACKOFF_BASE | int | The minimum delay between retries when backing off. |\n     * | OPT_BACKOFF_CAP  | int | The maximum delay between replies when backing off. |\n     *\n     * @see Redis::getOption()\n     * @see Redis::__construct() for details about backoff strategies.\n     *\n     * @param int    $option The option constant.\n     * @param mixed  $value  The option value.\n     *\n     * @return bool  true if the setting was updated, false if not.\n     *\n     */\n    public function setOption(int $option, mixed $value): bool;\n\n    /**\n     * Set a Redis STRING key with a specific expiration in seconds.\n     *\n     * @param string $key     The name of the key to set.\n     * @param int    $expire  The key's expiration in seconds.\n     * @param mixed  $value   The value to set the key.\n     *\n     * @return Redis|bool True on success or false on failure.\n     *\n     * @example $redis->setex('60s-ttl', 60, 'some-value');\n     */\n    public function setex(string $key, int $expire, mixed $value);\n\n    /**\n     * Set a key to a value, but only if that key does not already exist.\n     *\n     * @see https://redis.io/commands/setnx\n     *\n     * @param string $key   The key name to set.\n     * @param mixed  $value What to set the key to.\n     *\n     * @return Redis|bool Returns true if the key was set and false otherwise.\n     *\n     * @example $redis->setnx('existing-key', 'existing-value');\n     * @example $redis->setnx('new-key', 'new-value');\n     */\n    public function setnx(string $key, mixed $value): Redis|bool;\n\n    /**\n     * Check whether a given value is the member of a Redis SET.\n     *\n     * @param string $key   The redis set to check.\n     * @param mixed  $value The value to test.\n     *\n     * @return Redis|bool True if the member exists and false if not.\n     *\n     * @example $redis->sismember('myset', 'mem1', 'mem2');\n     */\n    public function sismember(string $key, mixed $value): Redis|bool;\n\n    /**\n     * Turn a redis instance into a replica of another or promote a replica\n     * to a primary.\n     *\n     * This method and the corresponding command in Redis has been marked deprecated\n     * and users should instead use Redis::replicaof() if connecting to redis-server\n     * >= 5.0.0.\n     *\n     * @deprecated\n     *\n     * @see https://redis.io/commands/slaveof\n     * @see https://redis.io/commands/replicaof\n     * @see Redis::replicaof()\n     */\n    public function slaveof(?string $host = null, int $port = 6379): Redis|bool;\n\n    /**\n     * Used to turn a Redis instance into a replica of another, or to remove\n     * replica status promoting the instance to a primary.\n     *\n     * @see https://redis.io/commands/replicaof\n     * @see https://redis.io/commands/slaveof\n     * @see Redis::slaveof()\n     *\n     * @param string $host The host of the primary to start replicating.\n     * @param string $port The port of the primary to start replicating.\n     *\n     * @return Redis|bool Success if we were successfully able to start replicating a primary or\n     *                    were able to promote the replicat to a primary.\n     *\n     * @example\n     * $redis = new Redis(['host' => 'localhost']);\n     *\n     * // Attempt to become a replica of a Redis instance at 127.0.0.1:9999\n     * $redis->replicaof('127.0.0.1', 9999);\n     *\n     * // When passed no arguments, PhpRedis will deliver the command `REPLICAOF NO ONE`\n     * // attempting to promote the instance to a primary.\n     * $redis->replicaof();\n     */\n    public function replicaof(?string $host = null, int $port = 6379): Redis|bool;\n\n    /**\n     * Update one or more keys last modified metadata.\n     *\n     * @see https://redis.io/commands/touch/\n     *\n     * @param array|string $key    Either the first key or if passed as the only argument\n     *                             an array of keys.\n     * @param string $more_keys    One or more keys to send to the command.\n     *\n     * @return Redis|int|false     This command returns the number of keys that exist and\n     *                             had their last modified time reset\n     */\n    public function touch(array|string $key_or_array, string ...$more_keys): Redis|int|false;\n\n    /**\n     * Interact with Redis' slowlog functionality in various ways, depending\n     * on the value of 'operation'.\n     *\n     * @category administration\n     *\n     * @param string $operation  The operation you wish to perform.¬† This can\n     *                           be one of the following values:\n     *                           'GET'   - Retrieve the Redis slowlog as an array.\n     *                           'LEN'   - Retrieve the length of the slowlog.\n     *                           'RESET' - Remove all slowlog entries.\n     * @param int    $length     This optional argument can be passed when operation\n     *                           is 'get' and will specify how many elements to retrieve.\n     *                           If omitted Redis will send up to a default number of\n     *                           entries, which is configurable.\n     *\n     *                           Note:  With Redis >= 7.0.0 you can send -1 to mean \"all\".\n     *\n     * @return mixed\n     *\n     * @see https://redis.io/commands/slowlog/\n     *\n     * @example $redis->slowlog('get', -1);   // Retrieve all slowlog entries.\n     * @example $redis->slowlog('len');       // Retrieve slowlog length.\n     * @example $redis->slowlog('reset');     // Reset the slowlog.\n     */\n    public function slowlog(string $operation, int $length = 0): mixed;\n\n    /**\n     * Sort the contents of a Redis key in various ways.\n     *\n     * @see https://redis.io/commands/sort/\n     *\n     * @param string $key     The key you wish to sort\n     * @param array  $options Various options controlling how you would like the\n     *                        data sorted.  See blow for a detailed description\n     *                        of this options array.\n     *\n     * @return mixed This command can either return an array with the sorted data\n     *               or the number of elements placed in a destination set when\n     *               using the STORE option.\n     *\n     * @example\n     * $options = [\n     *     'SORT'  => 'ASC'|| 'DESC' // Sort in descending or descending order.\n     *     'ALPHA' => true || false  // Whether to sort alphanumerically.\n     *     'LIMIT' => [0, 10]        // Return a subset of the data at offset, count\n     *     'BY'    => 'weight_*'     // For each element in the key, read data from the\n     *                                  external key weight_* and sort based on that value.\n     *     'GET'   => 'weight_*'     // For each element in the source key, retrieve the\n     *                                  data from key weight_* and return that in the result\n     *                                  rather than the source keys' element.  This can\n     *                                  be used in combination with 'BY'\n     * ];\n     */\n    public function sort(string $key, ?array $options = null): mixed;\n\n    /**\n     * This is simply a read-only variant of the sort command\n     *\n     * @see Redis::sort()\n     */\n    public function sort_ro(string $key, ?array $options = null): mixed;\n\n    /**\n     * @deprecated\n     */\n    public function sortAsc(string $key, ?string $pattern = null, mixed $get = null, int $offset = -1, int $count = -1, ?string $store = null): array;\n\n    /**\n     * @deprecated\n     */\n    public function sortAscAlpha(string $key, ?string $pattern = null, mixed $get = null, int $offset = -1, int $count = -1, ?string $store = null): array;\n\n    /**\n     * @deprecated\n     */\n    public function sortDesc(string $key, ?string $pattern = null, mixed $get = null, int $offset = -1, int $count = -1, ?string $store = null): array;\n\n    /**\n     * @deprecated\n     */\n    public function sortDescAlpha(string $key, ?string $pattern = null, mixed $get = null, int $offset = -1, int $count = -1, ?string $store = null): array;\n\n    /**\n     * Remove one or more values from a Redis SET key.\n     *\n     * @see https://redis.io/commands/srem\n     *\n     * @param string $key         The Redis SET key in question.\n     * @param mixed  $value       The first value to remove.\n     * @param mixed  $more_values One or more additional values to remove.\n     *\n     * @return Redis|int|false    The number of values removed from the set or false on failure.\n     *\n     * @example $redis->sRem('set1', 'mem1', 'mem2', 'not-in-set');\n     */\n    public function srem(string $key, mixed $value, mixed ...$other_values): Redis|int|false;\n\n    /**\n     * Scan the members of a redis SET key.\n     *\n     * @see https://redis.io/commands/sscan\n     * @see https://redis.io/commands/scan\n     * @see Redis::setOption()\n     *\n     * @param string $key       The Redis SET key in question.\n     * @param int    $iterator  A reference to an iterator which should be initialized to NULL that\n     *                          PhpRedis will update with the value returned from Redis after each\n     *                          subsequent call to SSCAN.  Once this cursor is zero you know all\n     *                          members have been traversed.\n     * @param string|null $pattern An optional glob style pattern to match against, so Redis only\n     *                          returns the subset of members matching this pattern.\n     * @param int    $count     A hint to Redis as to how many members it should scan in one command\n     *                          before returning members for that iteration.\n     *\n     * @example\n     * $redis->del('myset');\n     * for ($i = 0; $i < 10000; $i++) {\n     *     $redis->sAdd('myset', \"member:$i\");\n     * }\n     * $redis->sadd('myset', 'foofoo');\n     *\n     * $redis->setOption(Redis::OPT_SCAN, Redis::SCAN_NORETRY);\n     *\n     * $scanned = 0;\n     * $it = null;\n     *\n     * // Without Redis::SCAN_RETRY we may receive empty results and\n     * // a nonzero iterator.\n     * do {\n     *     // Scan members containing '5'\n     *     $members = $redis->sscan('myset', $it, '*5*');\n     *     foreach ($members as $member) {\n     *          echo \"NORETRY: $member\\n\";\n     *          $scanned++;\n     *     }\n     * } while ($it != 0);\n     * echo \"TOTAL: $scanned\\n\";\n     *\n     * $redis->setOption(Redis::OPT_SCAN, Redis::SCAN_RETRY);\n     *\n     * $scanned = 0;\n     * $it = null;\n     *\n     * // With Redis::SCAN_RETRY PhpRedis will never return an empty array\n     * // when the cursor is non-zero\n     * while (($members = $redis->sscan('myset', $it, '*5*'))) {\n     *     foreach ($members as $member) {\n     *         echo \"RETRY: $member\\n\";\n     *         $scanned++;\n     *     }\n     * }\n     */\n    public function sscan(string $key, null|int|string &$iterator, ?string $pattern = null, int $count = 0): array|false;\n\n    /**\n     * Subscribes the client to the specified shard channels.\n     *\n     * @param array    $channels One or more channel names.\n     * @param callable $cb       The callback PhpRedis will invoke when we receive a message\n     *                           from one of the subscribed channels.\n     *\n     * @return bool True on success, false on faiilure.  Note that this command will block the\n     *              client in a subscribe loop, waiting for messages to arrive.\n     *\n     * @see https://redis.io/commands/ssubscribe\n     *\n     * @example\n     * $redis = new Redis(['host' => 'localhost']);\n     *\n     * $redis->ssubscribe(['channel-1', 'channel-2'], function ($redis, $channel, $message) {\n     *     echo \"[$channel]: $message\\n\";\n     *\n     *     // Unsubscribe from the message channel when we read 'quit'\n     *     if ($message == 'quit') {\n     *         echo \"Unsubscribing from '$channel'\\n\";\n     *         $redis->sunsubscribe([$channel]);\n     *     }\n     * });\n     *\n     * // Once we read 'quit' from both channel-1 and channel-2 the subscribe loop will be\n     * // broken and this command will execute.\n     * echo \"Subscribe loop ended\\n\";\n     */\n    public function ssubscribe(array $channels, callable $cb): bool;\n\n    /**\n     * Retrieve the length of a Redis STRING key.\n     *\n     * @param string $key The key we want the length of.\n     *\n     * @return Redis|int|false The length of the string key if it exists, zero if it does not, and\n     *                         false on failure.\n     *\n     * @see https://redis.io/commands/strlen\n     *\n     * @example $redis->strlen('mykey');\n     */\n    public function strlen(string $key): Redis|int|false;\n\n    /**\n     * Subscribe to one or more Redis pubsub channels.\n     *\n     * @param array    $channels One or more channel names.\n     * @param callable $cb       The callback PhpRedis will invoke when we receive a message\n     *                           from one of the subscribed channels.\n     *\n     * @return bool True on success, false on faiilure.  Note that this command will block the\n     *              client in a subscribe loop, waiting for messages to arrive.\n     *\n     * @see https://redis.io/commands/subscribe\n     *\n     * @example\n     * $redis = new Redis(['host' => 'localhost']);\n     *\n     * $redis->subscribe(['channel-1', 'channel-2'], function ($redis, $channel, $message) {\n     *     echo \"[$channel]: $message\\n\";\n     *\n     *     // Unsubscribe from the message channel when we read 'quit'\n     *     if ($message == 'quit') {\n     *         echo \"Unsubscribing from '$channel'\\n\";\n     *         $redis->unsubscribe([$channel]);\n     *     }\n     * });\n     *\n     * // Once we read 'quit' from both channel-1 and channel-2 the subscribe loop will be\n     * // broken and this command will execute.\n     * echo \"Subscribe loop ended\\n\";\n     */\n    public function subscribe(array $channels, callable $cb): bool;\n\n    /**\n     * Unsubscribes the client from the given shard channels,\n     * or from all of them if none is given.\n     *\n     * @param array $channels One or more channels to unsubscribe from.\n     * @return Redis|array|bool The array of unsubscribed channels.\n     *\n     * @see https://redis.io/commands/sunsubscribe\n     * @see Redis::ssubscribe()\n     *\n     * @example\n     * $redis->ssubscribe(['channel-1', 'channel-2'], function ($redis, $channel, $message) {\n     *     if ($message == 'quit') {\n     *         echo \"$channel => 'quit' detected, unsubscribing!\\n\";\n     *         $redis->sunsubscribe([$channel]);\n     *     } else {\n     *         echo \"$channel => $message\\n\";\n     *     }\n     * });\n     *\n     * echo \"We've unsubscribed from both channels, exiting\\n\";\n     */\n    public function sunsubscribe(array $channels): Redis|array|bool;\n\n    /**\n     * Atomically swap two Redis databases so that all of the keys in the source database will\n     * now be in the destination database and vice-versa.\n     *\n     * Note: This command simply swaps Redis' internal pointer to the database and is therefore\n     * very fast, regardless of the size of the underlying databases.\n     *\n     * @param int $src The source database number\n     * @param int $dst The destination database number\n     *\n     * @return Redis|bool Success if the databases could be swapped and false on failure.\n     *\n     * @see https://redis.io/commands/swapdb\n     * @see Redis::del()\n     *\n     * @example\n     * $redis->select(0);\n     * $redis->set('db0-key', 'db0-value');\n     * $redis->swapdb(0, 1);\n     * $redis->get('db0-key');\n     */\n    public function swapdb(int $src, int $dst): Redis|bool;\n\n    /**\n     * Retrieve the server time from the connected Redis instance.\n     *\n     * @see https://redis.io/commands/time\n     *\n     * @return A two element array consisting of a Unix Timestamp and the number of microseconds\n     *         elapsed since the second.\n     *\n     * @example $redis->time();\n     */\n    public function time(): Redis|array;\n\n    /**\n     * Get the amount of time a Redis key has before it will expire, in seconds.\n     *\n     * @param string $key      The Key we want the TTL for.\n     * @return Redis|int|false (a) The number of seconds until the key expires, or -1 if the key has\n     *                         no expiration, and -2 if the key does not exist.  In the event of an\n     *                         error, this command will return false.\n     *\n     * @see https://redis.io/commands/ttl\n     *\n     * @example $redis->ttl('mykey');\n     */\n    public function ttl(string $key): Redis|int|false;\n\n    /**\n     * Get the type of a given Redis key.\n     *\n     * @see https://redis.io/commands/type\n     *\n     * @param  string $key     The key to check\n     * @return Redis|int|false The Redis type constant or false on failure.\n     *\n     * The Redis class defines several type constants that correspond with Redis key types.\n     *\n     *     Redis::REDIS_NOT_FOUND\n     *     Redis::REDIS_STRING\n     *     Redis::REDIS_SET\n     *     Redis::REDIS_LIST\n     *     Redis::REDIS_ZSET\n     *     Redis::REDIS_HASH\n     *     Redis::REDIS_STREAM\n     *\n     * @example\n     * foreach ($redis->keys('*') as $key) {\n     *     echo \"$key => \" . $redis->type($key) . \"\\n\";\n     * }\n     */\n    public function type(string $key): Redis|int|false;\n\n    /**\n     * Delete one or more keys from the Redis database.  Unlike this operation, the actual\n     * deletion is asynchronous, meaning it is safe to delete large keys without fear of\n     * Redis blocking for a long period of time.\n     *\n     * @param array|string $key_or_keys Either an array with one or more keys or a string with\n     *                                  the first key to delete.\n     * @param string       $other_keys  If the first argument passed to this method was a string\n     *                                  you may pass any number of additional key names.\n     *\n     * @return Redis|int|false The number of keys deleted or false on failure.\n     *\n     * @see https://redis.io/commands/unlink\n     * @see https://redis.io/commands/del\n     * @see Redis::del()\n     *\n     * @example $redis->unlink('key1', 'key2', 'key3');\n     * @example $redis->unlink(['key1', 'key2', 'key3']);\n     */\n    public function unlink(array|string $key, string ...$other_keys): Redis|int|false;\n\n    /**\n     * Unsubscribe from one or more subscribed channels.\n     *\n     * @param array $channels One or more channels to unsubscribe from.\n     * @return Redis|array|bool The array of unsubscribed channels.\n     *\n     * @see https://redis.io/commands/unsubscribe\n     * @see Redis::subscribe()\n     *\n     * @example\n     * $redis->subscribe(['channel-1', 'channel-2'], function ($redis, $channel, $message) {\n     *     if ($message == 'quit') {\n     *         echo \"$channel => 'quit' detected, unsubscribing!\\n\";\n     *         $redis->unsubscribe([$channel]);\n     *     } else {\n     *         echo \"$channel => $message\\n\";\n     *     }\n     * });\n     *\n     * echo \"We've unsubscribed from both channels, exiting\\n\";\n     */\n    public function unsubscribe(array $channels): Redis|array|bool;\n\n    /**\n     * Remove any previously WATCH'ed keys in a transaction.\n     *\n     * @see https://redis.io/commands/unwatch\n     * @see https://redis.io/commands/unwatch\n     * @see Redis::watch()\n     *\n     * @return True on success and false on failure.\n     */\n    public function unwatch(): Redis|bool;\n\n    /**\n     * Watch one or more keys for conditional execution of a transaction.\n     *\n     * @param array|string $key_or_keys  Either an array with one or more key names, or a string key name\n     * @param string       $other_keys   If the first argument was passed as a string, any number of additional\n     *                                   string key names may be passed variadically.\n     * @return Redis|bool\n     *\n     *\n     * @see https://redis.io/commands/watch\n     * @see https://redis.io/commands/unwatch\n     *\n     * @example\n     * $redis1 = new Redis(['host' => 'localhost']);\n     * $redis2 = new Redis(['host' => 'localhost']);\n     *\n     * // Start watching 'incr-key'\n     * $redis1->watch('incr-key');\n     *\n     * // Retrieve its value.\n     * $val = $redis1->get('incr-key');\n     *\n     * // A second client modifies 'incr-key' after we read it.\n     * $redis2->set('incr-key', 0);\n     *\n     * // Because another client changed the value of 'incr-key' after we read it, this\n     * // is no longer a proper increment operation, but because we are `WATCH`ing the\n     * // key, this transaction will fail and we can try again.\n     * //\n     * // If were to comment out the above `$redis2->set('incr-key', 0)` line the\n     * // transaction would succeed.\n     * $redis1->multi();\n     * $redis1->set('incr-key', $val + 1);\n     * $res = $redis1->exec();\n     *\n     * // bool(false)\n     * var_dump($res);\n     */\n    public function watch(array|string $key, string ...$other_keys): Redis|bool;\n\n    /**\n     * Block the client up to the provided timeout until a certain number of replicas have confirmed\n     * receiving them.\n     *\n     * @see https://redis.io/commands/wait\n     *\n     * @param int $numreplicas The number of replicas we want to confirm write operations\n     * @param int $timeout     How long to wait (zero meaning forever).\n     *\n     * @return Redis|int|false The number of replicas that have confirmed or false on failure.\n     *\n     */\n    public function wait(int $numreplicas, int $timeout): int|false;\n\n    /**\n     * Acknowledge one or more messages that are pending (have been consumed using XREADGROUP but\n     * not yet acknowledged by XACK.)\n     *\n     * @param string $key   The stream to query.\n     * @param string $group The consumer group to use.\n     * @param array  $ids   An array of stream entry IDs.\n     *\n     * @return int|false The number of acknowledged messages\n     *\n     * @see https://redis.io/commands/xack\n     * @see https://redis.io/commands/xreadgroup\n     * @see Redis::xack()\n     *\n     * @example\n     * $redis->xAdd('ships', '*', ['name' => 'Enterprise']);\n     * $redis->xAdd('ships', '*', ['name' => 'Defiant']);\n     *\n     * $redis->xGroup('CREATE', 'ships', 'Federation', '0-0');\n     *\n     * // Consume a single message with the consumer group 'Federation'\n     * $ship = $redis->xReadGroup('Federation', 'Picard', ['ships' => '>'], 1);\n     *\n     * /* Retrieve the ID of the message we read.\n     * assert(isset($ship['ships']));\n     * $id = key($ship['ships']);\n     *\n     * // The message we just read is now pending.\n     * $res = $redis->xPending('ships', 'Federation'));\n     * var_dump($res);\n     *\n     * // We can tell Redis we were able to process the message by using XACK\n     * $res = $redis->xAck('ships', 'Federation', [$id]);\n     * assert($res === 1);\n     *\n     * // The message should no longer be pending.\n     * $res = $redis->xPending('ships', 'Federation');\n     * var_dump($res);\n     */\n    public function xack(string $key, string $group, array $ids): int|false;\n\n    /**\n     * Append a message to a stream.\n     *\n     * @param string $key        The stream name.\n     * @param string $id         The ID for the message we want to add.  This can be the special value '*'\n     *                           which means Redis will generate the ID that appends the message to the\n     *                           end of the stream.  It can also be a value in the form <ms>-* which will\n     *                           generate an ID that appends to the end of entries with the same <ms> value\n     *                           (if any exist).\n     * @param int    $maxlen     If specified Redis will append the new message but trim any number of the\n     *                           oldest messages in the stream until the length is <= $maxlen.\n     * @param bool   $approx     Used in conjunction with `$maxlen`, this flag tells Redis to trim the stream\n     *                           but in a more efficient way, meaning the trimming may not be exactly to\n     *                           `$maxlen` values.\n     * @param bool   $nomkstream If passed as `TRUE`, the stream must exist for Redis to append the message.\n     *\n     * @see https://redis.io/commands/xadd\n     *\n     * @example $redis->xAdd('ds9-season-1', '1-1', ['title' => 'Emissary Part 1']);\n     * @example $redis->xAdd('ds9-season-1', '1-2', ['title' => 'A Man Alone']);\n     */\n    public function xadd(string $key, string $id, array $values, int $maxlen = 0, bool $approx = false, bool $nomkstream = false): Redis|string|false;\n\n    /**\n     * This command allows a consumer to claim pending messages that have been idle for a specified period of time.\n     * Its purpose is to provide a mechanism for picking up messages that may have had a failed consumer.\n     *\n     * @see https://redis.io/commands/xautoclaim\n     * @see https://redis.io/commands/xclaim\n     * @see https://redis.io/docs/data-types/streams-tutorial/\n     *\n     * @param string $key      The stream to check.\n     * @param string $group    The consumer group to query.\n     * @param string $consumer Which consumer to check.\n     * @param int    $min_idle The minimum time in milliseconds for the message to have been pending.\n     * @param string $start    The minimum message id to check.\n     * @param int    $count    An optional limit on how many messages are returned.\n     * @param bool   $justid   If the client only wants message IDs and not all of their data.\n     *\n     * @return Redis|array|bool An array of pending IDs or false if there are none, or on failure.\n     *\n     * @example\n     * $redis->xGroup('CREATE', 'ships', 'combatants', '0-0', true);\n     *\n     * $redis->xAdd('ships', '1424-74205', ['name' => 'Defiant']);\n     *\n     * // Consume the ['name' => 'Defiant'] message\n     * $msgs = $redis->xReadGroup('combatants', \"Jem'Hadar\", ['ships' => '>'], 1);\n     *\n     * // The \"Jem'Hadar\" consumer has the message presently\n     * $pending = $redis->xPending('ships', 'combatants');\n     * var_dump($pending);\n     *\n     * // Assume control of the pending message with a different consumer.\n     * $res = $redis->xAutoClaim('ships', 'combatants', 'Sisko', 0, '0-0');\n     *\n     * // Now the 'Sisko' consumer owns the message\n     * $pending = $redis->xPending('ships', 'combatants');\n     * var_dump($pending);\n     */\n    public function xautoclaim(string $key, string $group, string $consumer, int $min_idle, string $start, int $count = -1, bool $justid = false): Redis|bool|array;\n\n    /**\n     * This method allows a consumer to take ownership of pending stream entries, by ID.  Another\n     * command that does much the same thing but does not require passing specific IDs is `Redis::xAutoClaim`.\n     *\n     * @see https://redis.io/commands/xclaim\n     * @see https://redis.io/commands/xautoclaim.\n     *\n     * @param string $key            The stream we wish to claim messages for.\n     * @param string $group          Our consumer group.\n     * @param string $consumer       Our consumer.\n     * @param int    $min_idle_time  The minimum idle-time in milliseconds a message must have for ownership to be transferred.\n     * @param array  $options        An options array that modifies how the command operates.\n     *\n     *                               <code>\n     *                               # Following is an options array describing every option you can pass.  Note that\n     *                               # 'IDLE', and 'TIME' are mutually exclusive.\n     *                               $options = [\n     *                                   'IDLE'       => 3            # Set the idle time of the message to a 3.  By default\n     *                                                                # the idle time is set to zero.\n     *                                   'TIME'       => 1000*time()  # Same as IDLE except it takes a unix timestamp in\n     *                                                                # milliseconds.\n     *                                   'RETRYCOUNT' => 0            # Set the retry counter to zero.  By default XCLAIM\n     *                                                                # doesn't modify the counter.\n     *                                   'FORCE'                      # Creates the pending message entry even if IDs are\n     *                                                                # not already\n     *                                                                # in the PEL with another client.\n     *                                   'JUSTID'                     # Return only an array of IDs rather than the messages\n     *                                                                # themselves.\n     *                               ];\n     *                               </code>\n     *\n     * @return Redis|array|bool      An array of claimed messages or false on failure.\n     *\n     * @example\n     * $redis->xGroup('CREATE', 'ships', 'combatants', '0-0', true);\n     *\n     * $redis->xAdd('ships', '1424-74205', ['name' => 'Defiant']);\n     *\n     * // Consume the ['name' => 'Defiant'] message\n     * $msgs = $redis->xReadGroup('combatants', \"Jem'Hadar\", ['ships' => '>'], 1);\n     *\n     * // The \"Jem'Hadar\" consumer has the message presently\n     * $pending = $redis->xPending('ships', 'combatants');\n     * var_dump($pending);\n     *\n     * assert($pending && isset($pending[1]));\n     *\n     * // Claim the message by ID.\n     * $claimed = $redis->xClaim('ships', 'combatants', 'Sisko', 0, [$pending[1]], ['JUSTID']);\n     * var_dump($claimed);\n     *\n     * // Now the 'Sisko' consumer owns the message\n     * $pending = $redis->xPending('ships', 'combatants');\n     * var_dump($pending);\n     */\n    public function xclaim(string $key, string $group, string $consumer, int $min_idle, array $ids, array $options): Redis|array|bool;\n\n    /**\n     * Remove one or more specific IDs from a stream.\n     *\n     * @param string $key The stream to modify.\n     * @param array $ids One or more message IDs to remove.\n     *\n     * @return Redis|int|false The number of messages removed or false on failure.\n     *\n     * @example $redis->xDel('stream', ['1-1', '2-1', '3-1']);\n     */\n    public function xdel(string $key, array $ids): Redis|int|false;\n\n    /**\n     * XGROUP\n     *\n     * Perform various operation on consumer groups for a particular Redis STREAM.  What the command does\n     * is primarily based on which operation is passed.\n     *\n     * @see https://redis.io/commands/xgroup/\n     *\n     * @param string $operation      The subcommand you intend to execute.  Valid options are as follows\n     *                               'HELP'           - Redis will return information about the command\n     *                                                  Requires: none\n     *                               'CREATE'         - Create a consumer group.\n     *                                                  Requires:  Key, group, consumer.\n     *                               'SETID'          - Set the ID of an existing consumer group for the stream.\n     *                                                  Requires:  Key, group, id.\n     *                               'CREATECONSUMER' - Create a new consumer group for the stream.  You must\n     *                                                  also pass key, group, and the consumer name you wish to\n     *                                                  create.\n     *                                                  Requires:  Key, group, consumer.\n     *                               'DELCONSUMER'    - Delete a consumer from group attached to the stream.\n     *                                                  Requires:  Key, group, consumer.\n     *                               'DESTROY'        - Delete a consumer group from a stream.\n     *                                                  Requires:  Key, group.\n     * @param string $key            The STREAM we're operating on.\n     * @param string $group          The consumer group we want to create/modify/delete.\n     * @param string $id_or_consumer The STREAM id (e.g. '$') or consumer group.  See the operation section\n     *                               for information about which to send.\n     * @param bool   $mkstream       This flag may be sent in combination with the 'CREATE' operation, and\n     *                               cause Redis to also create the STREAM if it doesn't currently exist.\n     *\n     * @param bool   $entriesread    Allows you to set Redis' 'entries-read' STREAM value.  This argument is\n     *                               only relevant to the 'CREATE' and 'SETID' operations.\n     *                               Note:  Requires Redis >= 7.0.0.\n     *\n     * @return mixed                 This command return various results depending on the operation performed.\n     */\n    public function xgroup(string $operation, ?string $key = null, ?string $group = null, ?string $id_or_consumer = null,\n                           bool $mkstream = false, int $entries_read = -2): mixed;\n\n    /**\n     * Retrieve information about a stream key.\n     *\n     * @param string $operation The specific info operation to perform.\n     * @param string $arg1      The first argument (depends on operation)\n     * @param string $arg2      The second argument\n     * @param int    $count     The COUNT argument to `XINFO STREAM`\n     *\n     * @return mixed This command can return different things depending on the operation being called.\n     *\n     * @see https://redis.io/commands/xinfo\n     *\n     * @example $redis->xInfo('CONSUMERS', 'stream');\n     * @example $redis->xInfo('GROUPS', 'stream');\n     * @example $redis->xInfo('STREAM', 'stream');\n     */\n    public function xinfo(string $operation, ?string $arg1 = null, ?string $arg2 = null, int $count = -1): mixed;\n\n\n    /**\n     * Get the number of messages in a Redis STREAM key.\n     *\n     * @param string $key The Stream to check.\n     *\n     * @return Redis|int|false The number of messages or false on failure.\n     *\n     * @see https://redis.io/commands/xlen\n     *\n     * @example $redis->xLen('stream');\n     */\n    public function xlen(string $key): Redis|int|false;\n\n    /**\n     * Interact with stream messages that have been consumed by a consumer group but not yet\n     * acknowledged with XACK.\n     *\n     * @see https://redis.io/commands/xpending\n     * @see https://redis.io/commands/xreadgroup\n     *\n     * @param string $key      The stream to inspect.\n     * @param string $group    The user group we want to see pending messages from.\n     * @param string $start    The minimum ID to consider.\n     * @param string $string   The maximum ID to consider.\n     * @param string $count    Optional maximum number of messages to return.\n     * @param string $consumer If provided, limit the returned messages to a specific consumer.\n     *\n     * @return Redis|array|false The pending messages belonging to the stream or false on failure.\n     *\n     */\n    public function xpending(string $key, string $group, ?string $start = null, ?string $end = null, int $count = -1, ?string $consumer = null): Redis|array|false;\n\n    /**\n     * Get a range of entries from a STREAM key.\n     *\n     * @param string $key   The stream key name to list.\n     * @param string $start The minimum ID to return.\n     * @param string $end   The maximum ID to return.\n     * @param int    $count An optional maximum number of entries to return.\n     *\n     * @return Redis|array|bool The entries in the stream within the requested range or false on failure.\n     *\n     * @see https://redis.io/commands/xrange\n     *\n     * @example $redis->xRange('stream', '0-1', '0-2');\n     * @example $redis->xRange('stream', '-', '+');\n     */\n    public function xrange(string $key, string $start, string $end, int $count = -1): Redis|array|bool;\n\n    /**\n     * Consume one or more unconsumed elements in one or more streams.\n     *\n     * @param array $streams An associative array with stream name keys and minimum id values.\n     * @param int   $count   An optional limit to how many entries are returned *per stream*\n     * @param int   $block   An optional maximum number of milliseconds to block the caller if no\n     *                       data is available on any of the provided streams.\n     *\n     * @return Redis|array|bool An array of read elements or false if there aren't any.\n     *\n     * @see https://redis.io/commands/xread\n     *\n     * @example\n     * $redis->xAdd('s03', '3-1', ['title' => 'The Search, Part I']);\n     * $redis->xAdd('s03', '3-2', ['title' => 'The Search, Part II']);\n     * $redis->xAdd('s03', '3-3', ['title' => 'The House Of Quark']);\n     * $redis->xAdd('s04', '4-1', ['title' => 'The Way of the Warrior']);\n     * $redis->xAdd('s04', '4-3', ['title' => 'The Visitor']);\n     * $redis->xAdd('s04', '4-4', ['title' => 'Hippocratic Oath']);\n     *\n     * $redis->xRead(['s03' => '3-2', 's04' => '4-1']);\n     */\n    public function xread(array $streams, int $count = -1, int $block = -1): Redis|array|bool;\n\n    /**\n     * Read one or more messages using a consumer group.\n     *\n     * @param string $group     The consumer group to use.\n     * @param string $consumer  The consumer to use.\n     * @param array  $streams   An array of stream names and message IDs\n     * @param int    $count     Optional maximum number of messages to return\n     * @param int    $block     How long to block if there are no messages available.\n     *\n     * @return Redis|array|bool Zero or more unread messages or false on failure.\n     *\n     * @see https://redis.io/commands/xreadgroup\n     *\n     * @example\n     * $redis->xGroup('CREATE', 'episodes', 'ds9', '0-0', true);\n     *\n     * $redis->xAdd('episodes', '1-1', ['title' => 'Emissary: Part 1']);\n     * $redis->xAdd('episodes', '1-2', ['title' => 'A Man Alone']);\n     *\n     * $messages = $redis->xReadGroup('ds9', 'sisko', ['episodes' => '>']);\n     *\n     * // After having read the two messages, add another\n     * $redis->xAdd('episodes', '1-3', ['title' => 'Emissary: Part 2']);\n     *\n     * // Acknowledge the first two read messages\n     * foreach ($messages as $stream => $stream_messages) {\n     *     $ids = array_keys($stream_messages);\n     *     $redis->xAck('stream', 'ds9', $ids);\n     * }\n     *\n     * // We can now pick up where we left off, and will only get the final message\n     * $msgs = $redis->xReadGroup('ds9', 'sisko', ['episodes' => '>']);\n     */\n    public function xreadgroup(string $group, string $consumer, array $streams, int $count = 1, int $block = 1): Redis|array|bool;\n\n    /**\n     * Get a range of entries from a STREAM key in reverse chronological order.\n     *\n     * @param string $key   The stream key to query.\n     * @param string $end   The maximum message ID to include.\n     * @param string $start The minimum message ID to include.\n     * @param int    $count An optional maximum number of messages to include.\n     *\n     * @return Redis|array|bool The entries within the requested range, from newest to oldest.\n     *\n     * @see https://redis.io/commands/xrevrange\n     * @see https://redis.io/commands/xrange\n     *\n     * @example $redis->xRevRange('stream', '0-2', '0-1');\n     * @example $redis->xRevRange('stream', '+', '-');\n     */\n    public function xrevrange(string $key, string $end, string $start, int $count = -1): Redis|array|bool;\n\n    /**\n     * Truncate a STREAM key in various ways.\n     *\n     * @param string $key       The STREAM key to trim.\n     * @param string $threshold This can either be a maximum length, or a minimum id.\n     *                          MAXLEN - An integer describing the maximum desired length of the stream after the command.\n     *                          MINID  - An ID that will become the new minimum ID in the stream, as Redis will trim all\n     *                                   messages older than this ID.\n     * @param bool   $approx    Whether redis is allowed to do an approximate trimming of the stream.  This is\n     *                          more efficient for Redis given how streams are stored internally.\n     * @param bool   $minid     When set to `true`, users should pass a minimum ID to the `$threshold` argument.\n     * @param int    $limit     An optional upper bound on how many entries to trim during the command.\n     *\n     * @return Redis|int|false  The number of entries deleted from the stream.\n     *\n     * @see https://redis.io/commands/xtrim\n     *\n     * @example $redis->xTrim('stream', 3);\n     * @example $redis->xTrim('stream', '2-1', false, true);\n     */\n    public function xtrim(string $key, string $threshold, bool $approx = false, bool $minid = false, int $limit = -1): Redis|int|false;\n\n    /**\n     * Add one or more elements and scores to a Redis sorted set.\n     *\n     * @param string       $key                  The sorted set in question.\n     * @param array|float  $score_or_options     Either the score for the first element, or an array of options.\n     *                                           <code>\n     *                                            $options = [\n     *                                                'NX',       # Only update elements that already exist\n     *                                                'NX',       # Only add new elements but don't update existing ones.\n     *\n     *                                                'LT'        # Only update existing elements if the new score is\n     *                                                            # less than the existing one.\n     *                                                'GT'        # Only update existing elements if the new score is\n     *                                                            # greater than the existing one.\n     *\n     *                                                'CH'        # Instead of returning the number of elements added,\n     *                                                            # Redis will return the number Of elements that were\n     *                                                            # changed in the operation.\n     *\n     *                                                'INCR'      # Instead of setting each element to the provide score,\n     *                                                            # increment the element by the\n     *                                                            # provided score, much like ZINCRBY.  When this option\n     *                                                            # is passed, you may only send a single score and member.\n     *                                            ];\n     *\n     *                                            Note:  'GX', 'LT', and 'NX' cannot be passed together, and PhpRedis\n     *                                                   will send whichever one is last in the options array.\n     *\n     * @param mixed        $more_scores_and_mems A variadic number of additional scores and members.\n     *\n     * @return Redis|int|false The return value varies depending on the options passed.\n     *\n     * Following is information about the options that may be passed as the second argument:\n     *\n     * @see https://redis.io/commands/zadd\n     *\n     * @example $redis->zadd('zs', 1, 'first', 2, 'second', 3, 'third');\n     * @example $redis->zAdd('zs', ['XX'], 8, 'second', 99, 'new-element');\n     */\n    public function zAdd(string $key, array|float $score_or_options, mixed ...$more_scores_and_mems): Redis|int|float|false;\n\n    /**\n     * Return the number of elements in a sorted set.\n     *\n     * @param string $key The sorted set to retrieve cardinality from.\n     *\n     * @return Redis|int|false The number of elements in the set or false on failure\n     *\n     * @see https://redis.io/commands/zcard\n     *\n     * @example $redis->zCard('zs');\n     */\n    public function zCard(string $key): Redis|int|false;\n\n    /**\n     * Count the number of members in a sorted set with scores inside a provided range.\n     *\n     * @param string $key The sorted set to check.\n     * @param int|string $min The minimum score to include in the count\n     * @param int|string $max The maximum score to include in the count\n     *\n     * NOTE:  In addition to a floating point score you may pass the special values of '-inf' and\n     *        '+inf' meaning negative and positive infinity, respectively.\n     *\n     * @see https://redis.io/commands/zcount\n     *\n     * @example $redis->zCount('fruit-rankings', '0', '+inf');\n     * @example $redis->zCount('fruit-rankings', 50, 60);\n     * @example $redis->zCount('fruit-rankings', '-inf', 0);\n     */\n    public function zCount(string $key, int|string $start, int|string $end): Redis|int|false;\n\n    /**\n     * Create or increment the score of a member in a Redis sorted set\n     *\n     * @param string $key   The sorted set in question.\n     * @param float  $value How much to increment the score.\n     *\n     * @return Redis|float|false The new score of the member or false on failure.\n     *\n     * @see https://redis.io/commands/zincrby\n     *\n     * @example $redis->zIncrBy('zs', 5.0, 'bananas');\n     * @example $redis->zIncrBy('zs', 2.0, 'eggplants');\n     */\n    public function zIncrBy(string $key, float $value, mixed $member): Redis|float|false;\n\n    /**\n     * Count the number of elements in a sorted set whose members fall within the provided\n     * lexographical range.\n     *\n     * @param string $key The sorted set to check.\n     * @param string $min The minimum matching lexographical string\n     * @param string $max The maximum matching lexographical string\n     *\n     * @return Redis|int|false The number of members that fall within the range or false on failure.\n     *\n     * @see https://redis.io/commands/zlexcount\n     *\n     * @example\n     * $redis->zAdd('captains', 0, 'Janeway', 0, 'Kirk', 0, 'Picard', 0, 'Sisko', 0, 'Archer');\n     * $redis->zLexCount('captains', '[A', '[S');\n     */\n    public function zLexCount(string $key, string $min, string $max): Redis|int|false;\n\n    /**\n     * Retrieve the score of one or more members in a sorted set.\n     *\n     * @see https://redis.io/commands/zmscore\n     *\n     * @param string $key           The sorted set\n     * @param mixed  $member        The first member to return the score from\n     * @param mixed  $other_members One or more additional members to return the scores of.\n     *\n     * @return Redis|array|false An array of the scores of the requested elements.\n     *\n     * @example\n     * $redis->zAdd('zs', 0, 'zero', 1, 'one', 2, 'two', 3, 'three');\n     *\n     * $redis->zMScore('zs', 'zero', 'two');\n     * $redis->zMScore('zs', 'one', 'not-a-member');\n     */\n    public function zMscore(string $key, mixed $member, mixed ...$other_members): Redis|array|false;\n\n    /**\n     * Pop one or more of the highest scoring elements from a sorted set.\n     *\n     * @param string $key   The sorted set to pop elements from.\n     * @param int    $count An optional count of elements to pop.\n     *\n     * @return Redis|array|false All of the popped elements with scores or false on failure\n     *\n     * @see https://redis.io/commands/zpopmax\n     *\n     * @example\n     * $redis->zAdd('zs', 0, 'zero', 1, 'one', 2, 'two', 3, 'three');\n     *\n     * $redis->zPopMax('zs');\n     * $redis->zPopMax('zs', 2);.\n     */\n    public function zPopMax(string $key, ?int $count = null): Redis|array|false;\n\n    /**\n     * Pop one or more of the lowest scoring elements from a sorted set.\n     *\n     * @param string $key   The sorted set to pop elements from.\n     * @param int    $count An optional count of elements to pop.\n     *\n     * @return Redis|array|false The popped elements with their scores or false on failure.\n     *\n     * @see https://redis.io/commands/zpopmin\n     *\n     * @example\n     * $redis->zAdd('zs', 0, 'zero', 1, 'one', 2, 'two', 3, 'three');\n     *\n     * $redis->zPopMin('zs');\n     * $redis->zPopMin('zs', 2);\n     */\n    public function zPopMin(string $key, ?int $count = null): Redis|array|false;\n\n    /**\n     * Retrieve a range of elements of a sorted set between a start and end point.\n     * How the command works in particular is greatly affected by the options that\n     * are passed in.\n     *\n     * @param string          $key     The sorted set in question.\n     * @param mixed           $start   The starting index we want to return.\n     * @param mixed           $end     The final index we want to return.\n     *\n     * @param array|bool|null $options This value may either be an array of options to pass to\n     *                                 the command, or for historical purposes a boolean which\n     *                                 controls just the 'WITHSCORES' option.\n     *                                 <code>\n     *                                 $options = [\n     *                                     'WITHSCORES' => true,     # Return both scores and members.\n     *                                     'LIMIT'      => [10, 10], # Start at offset 10 and return 10 elements.\n     *                                     'REV'                     # Return the elements in reverse order\n     *                                     'BYSCORE',                # Treat `start` and `end` as scores instead\n     *                                     'BYLEX'                   # Treat `start` and `end` as lexicographical values.\n     *                                 ];\n     *                                 </code>\n     *\n     *                                 Note:  'BYLEX' and 'BYSCORE' are mutually exclusive.\n     *\n     *\n     * @return Redis|array|false  An array with matching elements or false on failure.\n     *\n     * @see https://redis.io/commands/zrange/\n     * @category zset\n     *\n     * @example $redis->zRange('zset', 0, -1);\n     * @example $redis->zRange('zset', '-inf', 'inf', ['byscore']);\n     */\n    public function zRange(string $key, string|int $start, string|int $end, array|bool|null $options = null): Redis|array|false;\n\n    /**\n     * Retrieve a range of elements from a sorted set by legographical range.\n     *\n     * @param string $key    The sorted set to retrieve elements from\n     * @param string $min    The minimum legographical value to return\n     * @param string $max    The maximum legographical value to return\n     * @param int    $offset An optional offset within the matching values to return\n     * @param int    $count  An optional count to limit the replies to (used in conjunction with offset)\n     *\n     * @return Redis|array|false An array of matching elements or false on failure.\n     *\n     * @see https://redis.io/commands/zrangebylex\n     *\n     * @example\n     * $redis = new Redis(['host' => 'localhost']);\n     * $redis->zAdd('captains', 0, 'Janeway', 0, 'Kirk', 0, 'Picard', 0, 'Sisko', 0, 'Archer');\n     *\n     * $redis->zRangeByLex('captains', '[A', '[S');\n     * $redis->zRangeByLex('captains', '[A', '[S', 2, 2);\n     */\n    public function zRangeByLex(string $key, string $min, string $max, int $offset = -1, int $count = -1): Redis|array|false;\n\n    /**\n     * Retrieve a range of members from a sorted set by their score.\n     *\n     * @param string $key     The sorted set to query.\n     * @param string $start   The minimum score of elements that Redis should return.\n     * @param string $end     The maximum score of elements that Redis should return.\n     * @param array  $options Options that change how Redis will execute the command.\n     *\n     *                        OPTION       TYPE            MEANING\n     *                        'WITHSCORES' bool            Whether to also return scores.\n     *                        'LIMIT'      [offset, count] Limit the reply to a subset of elements.\n     *\n     * @return Redis|array|false The number of matching elements or false on failure.\n     *\n     * @see https://redis.io/commands/zrangebyscore\n     *\n     * @example $redis->zRangeByScore('zs', 20, 30, ['WITHSCORES' => true]);\n     * @example $redis->zRangeByScore('zs', 20, 30, ['WITHSCORES' => true, 'LIMIT' => [5, 5]]);\n     */\n    public function zRangeByScore(string $key, string $start, string $end, array $options = []): Redis|array|false;\n\n    /**\n     * This command is similar to ZRANGE except that instead of returning the values directly\n     * it will store them in a destination key provided by the user\n     *\n     * @param string           $dstkey  The key to store the resulting element(s)\n     * @param string           $srckey  The source key with element(s) to retrieve\n     * @param string           $start   The starting index to store\n     * @param string           $end     The ending index to store\n     * @param array|bool|null  $options Our options array that controls how the command will function.\n     *\n     * @return Redis|int|false The number of elements stored in $dstkey or false on failure.\n     *\n     * @see https://redis.io/commands/zrange/\n     * @see Redis::zRange\n     * @category zset\n     *\n     * See {@link Redis::zRange} for a full description of the possible options.\n     */\n    public function zrangestore(string $dstkey, string $srckey, string $start, string $end,\n                                array|bool|null $options = null): Redis|int|false;\n\n    /**\n     * Retrieve one or more random members from a Redis sorted set.\n     *\n     * @param string $key     The sorted set to pull random members from.\n     * @param array  $options One or more options that determine exactly how the command operates.\n     *\n     *                        OPTION       TYPE     MEANING\n     *                        'COUNT'      int      The number of random members to return.\n     *                        'WITHSCORES' bool     Whether to return scores and members instead of\n     *\n     * @return Redis|string|array One or more random elements.\n     *\n     * @see https://redis.io/commands/zrandmember\n     *\n     * @example $redis->zRandMember('zs', ['COUNT' =>¬†2, 'WITHSCORES' => true]);\n     */\n    public function zRandMember(string $key, ?array $options = null): Redis|string|array;\n\n    /**\n     * Get the rank of a member of a sorted set, by score.\n     *\n     * @param string $key     The sorted set to check.\n     * @param mixed  $member The member to test.\n     *\n     * @return Redis|int|false The rank of the requested member.\n     * @see https://redis.io/commands/zrank\n     *\n     * @example $redis->zRank('zs', 'zero');\n     * @example $redis->zRank('zs', 'three');\n     */\n    public function zRank(string $key, mixed $member): Redis|int|false;\n\n    /**\n     * Remove one or more members from a Redis sorted set.\n     *\n     * @param mixed $key           The sorted set in question.\n     * @param mixed $member        The first member to remove.\n     * @param mixed $other_members One or more members to remove passed in a variadic fashion.\n     *\n     * @return Redis|int|false The number of members that were actually removed or false on failure.\n     *\n     * @see https://redis.io/commands/zrem\n     *\n     * @example $redis->zRem('zs', 'mem:0', 'mem:1', 'mem:2', 'mem:6', 'mem:7', 'mem:8', 'mem:9');\n     */\n    public function zRem(mixed $key, mixed $member, mixed ...$other_members): Redis|int|false;\n\n    /**\n     * Remove zero or more elements from a Redis sorted set by legographical range.\n     *\n     * @param string $key The sorted set to remove elements from.\n     * @param string $min The start of the lexographical range to remove.\n     * @param string $max The end of the lexographical range to remove\n     *\n     * @return Redis|int|false The number of elements removed from the set or false on failure.\n     *\n     * @see https://redis.io/commands/zremrangebylex\n     * @see Redis::zrangebylex()\n     *\n     * @example $redis->zRemRangeByLex('zs', '[a', '(b');\n     * @example $redis->zRemRangeByLex('zs', '(banana', '(eggplant');\n     */\n    public function zRemRangeByLex(string $key, string $min, string $max): Redis|int|false;\n\n    /**\n     * Remove one or more members of a sorted set by their rank.\n     *\n     * @param string $key    The sorted set where we want to remove members.\n     * @param int    $start  The rank when we want to start removing members\n     * @param int    $end    The rank we want to stop removing membersk.\n     *\n     * @return Redis|int|false The number of members removed from the set or false on failure.\n     *\n     * @see https://redis.io/commands/zremrangebyrank\n     *\n     * @example $redis->zRemRangeByRank('zs', 0, 3);\n     */\n    public function zRemRangeByRank(string $key, int $start, int $end): Redis|int|false;\n\n    /**\n     * Remove one or more members of a sorted set by their score.\n     *\n     * @param string $key    The sorted set where we want to remove members.\n     * @param int    $start  The lowest score to remove.\n     * @param int    $end    The highest score to remove.\n     *\n     * @return Redis|int|false The number of members removed from the set or false on failure.\n     *\n     * @see https://redis.io/commands/zremrangebyrank\n     *\n     * @example\n     * $redis->zAdd('zs', 2, 'two', 4, 'four', 6, 'six');\n     * $redis->zRemRangeByScore('zs', 2, 4);\n     */\n    public function zRemRangeByScore(string $key, string $start, string $end): Redis|int|false;\n\n    /**\n     * List the members of a Redis sorted set in reverse order\n     *\n     * @param string $key        The sorted set in question.\n     * @param int    $start      The index to start listing elements\n     * @param int    $end        The index to stop listing elements.\n     * @param mixed  $withscores Whether or not Redis should also return each members score.  See\n     *                           the example below demonstrating how it may be used.\n     *\n     * @return Redis|array|false The members (and possibly scores) of the matching elements or false\n     *                           on failure.\n     *\n     * @see https://redis.io/commands/zrevrange\n     *\n     * @example $redis->zRevRange('zs', 0, -1);\n     * @example $redis->zRevRange('zs', 2, 3);\n     * @example $redis->zRevRange('zs', 0, -1, true);\n     * @example $redis->zRevRange('zs', 0, -1, ['withscores' => true]);\n     */\n    public function zRevRange(string $key, int $start, int $end, mixed $scores = null): Redis|array|false;\n\n    /**\n     * List members of a Redis sorted set within a legographical range, in reverse order.\n     *\n     * @param string $key    The sorted set to list\n     * @param string $min    The maximum legographical element to include in the result.\n     * @param string $min    The minimum lexographical element to include in the result.\n     * @param string $offset An option offset within the matching elements to start at.\n     * @param string $count  An optional count to limit the replies to.\n     *\n     * @return Redis|array|false The matching members or false on failure.\n     *\n     * @see https://redis.io/commands/zrevrangebylex\n     * @see Redis::zrangebylex()\n     *\n     * @example $redis->zRevRangeByLex('captains', '[Q', '[J');\n     * @example $redis->zRevRangeByLex('captains', '[Q', '[J', 1, 2);\n     */\n    public function zRevRangeByLex(string $key, string $max, string $min, int $offset = -1, int $count = -1): Redis|array|false;\n\n    /**\n     * List elements from a Redis sorted set by score, highest to lowest\n     *\n     * @param string $key     The sorted set to query.\n     * @param string $max     The highest score to include in the results.\n     * @param string $min     The lowest score to include in the results.\n     * @param array  $options An options array that modifies how the command executes.\n     *\n     *                        <code>\n     *                        $options = [\n     *                            'WITHSCORES' => true|false # Whether or not to return scores\n     *                            'LIMIT' => [offset, count] # Return a subset of the matching members\n     *                        ];\n     *                        </code>\n     *\n     *                        NOTE:  For legacy reason, you may also simply pass `true` for the\n     *                               options argument, to mean `WITHSCORES`.\n     *\n     * @return Redis|array|false The matching members in reverse order of score or false on failure.\n     *\n     * @see https://redis.io/commands/zrevrangebyscore\n     *\n     * @example\n     * $redis->zadd('oldest-people', 122.4493, 'Jeanne Calment', 119.2932, 'Kane Tanaka',\n     *                               119.2658, 'Sarah Knauss',   118.7205, 'Lucile Randon',\n     *                               117.7123, 'Nabi Tajima',    117.6301, 'Marie-Louise Meilleur',\n     *                               117.5178, 'Violet Brown',   117.3753, 'Emma Morano',\n     *                               117.2219, 'Chiyo Miyako',   117.0740, 'Misao Okawa');\n     *\n     * $redis->zRevRangeByScore('oldest-people', 122, 119);\n     * $redis->zRevRangeByScore('oldest-people', 'inf', 118);\n     * $redis->zRevRangeByScore('oldest-people', '117.5', '-inf', ['LIMIT' => [0, 1]]);\n     */\n    public function zRevRangeByScore(string $key, string $max, string $min, array|bool $options = []): Redis|array|false;\n\n    /**\n    * Retrieve a member of a sorted set by reverse rank.\n    *\n    * @param string $key      The sorted set to query.\n    * @param mixed  $member   The member to look up.\n    *\n    * @return Redis|int|false The reverse rank (the rank if counted high to low) of the member or\n    *                         false on failure.\n    * @see https://redis.io/commands/zrevrank\n    *\n    * @example\n    * $redis->zAdd('ds9-characters', 10, 'Sisko', 9, 'Garak', 8, 'Dax', 7, 'Odo');\n    *\n    * $redis->zrevrank('ds9-characters', 'Sisko');\n    * $redis->zrevrank('ds9-characters', 'Garak');\n    */\n    public function zRevRank(string $key, mixed $member): Redis|int|false;\n\n    /**\n     * Get the score of a member of a sorted set.\n     *\n     * @param string $key    The sorted set to query.\n     * @param mixed  $member The member we wish to query.\n     *\n     * @return The score of the requested element or false if it is not found.\n     *\n     * @see https://redis.io/commands/zscore\n     *\n     * @example\n     * $redis->zAdd('telescopes', 11.9, 'LBT', 10.4, 'GTC', 10, 'HET');\n     * $redis->zScore('telescopes', 'LBT');\n     */\n    public function zScore(string $key, mixed $member): Redis|float|false;\n\n    /**\n     * Given one or more sorted set key names, return every element that is in the first\n     * set but not any of the others.\n     *\n     * @param array $keys    One or more sorted sets.\n     * @param array $options An array which can contain ['WITHSCORES' => true] if you want Redis to\n     *                       return members and scores.\n     *\n     * @return Redis|array|false An array of members or false on failure.\n     *\n     * @see https://redis.io/commands/zdiff\n     *\n     * @example\n     * $redis->zAdd('primes', 1, 'one', 3, 'three', 5, 'five');\n     * $redis->zAdd('evens', 2, 'two', 4, 'four');\n     * $redis->zAdd('mod3', 3, 'three', 6, 'six');\n     *\n     * $redis->zDiff(['primes', 'evens', 'mod3']);\n     */\n    public function zdiff(array $keys, ?array $options = null): Redis|array|false;\n\n    /**\n     * Store the difference of one or more sorted sets in a destination sorted set.\n     *\n     * See {@link Redis::zdiff} for a more detailed description of how the diff operation works.\n     *\n     * @param string $key  The destination set name.\n     * @param array  $keys One or more source key names\n     *\n     * @return Redis|int|false The number of elements stored in the destination set or false on\n     *                         failure.\n     *\n     * @see https://redis.io/commands/zdiff\n     * @see Redis::zdiff()\n     */\n    public function zdiffstore(string $dst, array $keys): Redis|int|false;\n\n    /**\n     * Compute the intersection of one or more sorted sets and return the members\n     *\n     * @param array $keys    One or more sorted sets.\n     * @param array $weights An optional array of weights to be applied to each set when performing\n     *                       the intersection.\n     * @param array $options Options for how Redis should combine duplicate elements when performing the\n     *                       intersection.  See Redis::zunion() for details.\n     *\n     * @return Redis|array|false All of the members that exist in every set.\n     *\n     * @see https://redis.io/commands/zinter\n     *\n     * @example\n     * $redis->zAdd('TNG', 2, 'Worf', 2.5, 'Data', 4.0, 'Picard');\n     * $redis->zAdd('DS9', 2.5, 'Worf', 3.0, 'Kira', 4.0, 'Sisko');\n     *\n     * $redis->zInter(['TNG', 'DS9']);\n     * $redis->zInter(['TNG', 'DS9'], NULL, ['withscores' => true]);\n     * $redis->zInter(['TNG', 'DS9'], NULL, ['withscores' => true, 'aggregate' => 'max']);\n     */\n    public function zinter(array $keys, ?array $weights = null, ?array $options = null): Redis|array|false;\n\n    /**\n     * Similar to ZINTER but instead of returning the intersected values, this command returns the\n     * cardinality of the intersected set.\n     *\n     * @see https://redis.io/commands/zintercard\n     * @see https://redis.io/commands/zinter\n     * @see Redis::zinter()\n     *\n     * @param array $keys   One or more sorted set key names.\n     * @param int   $limit  An optional upper bound on the returned cardinality.  If set to a value\n     *                      greater than zero, Redis will stop processing the intersection once the\n     *                      resulting cardinality reaches this limit.\n     *\n     * @return Redis|int|false The cardinality of the intersection or false on failure.\n     *\n     * @example\n     * $redis->zAdd('zs1', 1, 'one', 2, 'two', 3, 'three', 4, 'four');\n     * $redis->zAdd('zs2', 2, 'two', 4, 'four');\n     *\n     * $redis->zInterCard(['zs1', 'zs2']);\n     */\n    public function zintercard(array $keys, int $limit = -1): Redis|int|false;\n\n    /**\n     * Compute the intersection of one or more sorted sets storing the result in a new sorted set.\n     *\n     * @param string $dst       The destination sorted set to store the intersected values.\n     * @param array  $keys      One or more sorted set key names.\n     * @param array  $weights   An optional array of floats to weight each passed input set.\n     * @param string $aggregate An optional aggregation method to use.\n     *\n     *                          'SUM' - Store sum of all intersected members (this is the default).\n     *                          'MIN' - Store minimum value for each intersected member.\n     *                          'MAX' - Store maximum value for each intersected member.\n     *\n     * @return Redis|int|false  The total number of members writtern to the destination set or false on failure.\n     *\n     * @see https://redis.io/commands/zinterstore\n     * @see https://redis.io/commands/zinter\n     *\n     * @example\n     * $redis->zAdd('zs1', 3, 'apples', 2, 'pears');\n     * $redis->zAdd('zs2', 4, 'pears', 3, 'bananas');\n     * $redis->zAdd('zs3', 2, 'figs', 3, 'pears');\n     *\n     * $redis->zInterStore('fruit-sum', ['zs1', 'zs2', 'zs3']);\n     * $redis->zInterStore('fruit-max', ['zs1', 'zs2', 'zs3'], NULL, 'MAX');\n     */\n    public function zinterstore(string $dst, array $keys, ?array $weights = null, ?string $aggregate = null): Redis|int|false;\n\n    /**\n     * Scan the members of a sorted set incrementally, using a cursor\n     *\n     * @param string $key        The sorted set to scan.\n     * @param int    $iterator   A reference to an iterator that should be initialized to NULL initially, that\n     *                           will be updated after each subsequent call to ZSCAN.  Once the iterator\n     *                           has returned to zero the scan is complete\n     * @param string|null $pattern An optional glob-style pattern that limits which members are returned during\n     *                           the scanning process.\n     * @param int    $count      A hint for Redis that tells it how many elements it should test before returning\n     *                           from the call.  The higher the more work Redis may do in any one given call to\n     *                           ZSCAN potentially blocking for longer periods of time.\n     *\n     * @return Redis|array|false An array of elements or false on failure.\n     *\n     * @see https://redis.io/commands/zscan\n     * @see https://redis.io/commands/scan\n     * @see Redis::scan()\n     *\n     * NOTE:  See Redis::scan() for detailed example code on how to call SCAN like commands.\n     *\n     */\n    public function zscan(string $key, null|int|string &$iterator, ?string $pattern = null, int $count = 0): Redis|array|false;\n\n    /**\n     * Retrieve the union of one or more sorted sets\n     *\n     * @param array $keys     One or more sorted set key names\n     * @param array $weights  An optional array with floating point weights used when performing the union.\n     *                        Note that if this argument is passed, it must contain the same number of\n     *                        elements as the $keys array.\n     * @param array $options  An array that modifies how this command functions.\n     *\n     *                        <code>\n     *                        $options = [\n     *                            # By default when members exist in more than one set Redis will SUM\n     *                            # total score for each match.  Instead, it can return the AVG, MIN,\n     *                            # or MAX value based on this option.\n     *                            'AGGREGATE' => 'sum' | 'min' | 'max'\n     *\n     *                            # Whether Redis should also return each members aggregated score.\n     *                            'WITHSCORES' => true | false\n     *                        ]\n     *                        </code>\n     *\n     * @return Redis|array|false The union of each sorted set or false on failure\n     *\n     * @example\n     * $redis->del('store1', 'store2', 'store3');\n     * $redis->zAdd('store1', 1, 'apples', 3, 'pears', 6, 'bananas');\n     * $redis->zAdd('store2', 3, 'apples', 5, 'coconuts', 2, 'bananas');\n     * $redis->zAdd('store3', 2, 'bananas', 6, 'apples', 4, 'figs');\n     *\n     * $redis->zUnion(['store1', 'store2', 'store3'], NULL, ['withscores' => true]);\n     * $redis->zUnion(['store1', 'store3'], [2, .5], ['withscores' => true]);\n     * $redis->zUnion(['store1', 'store3'], [2, .5], ['withscores' => true, 'aggregate' => 'MIN']);\n     */\n    public function zunion(array $keys, ?array $weights = null, ?array $options = null): Redis|array|false;\n\n    /**\n     * Perform a union on one or more Redis sets and store the result in a destination sorted set.\n     *\n     * @param string $dst       The destination set to store the union.\n     * @param array  $keys      One or more input keys on which to perform our union.\n     * @param array  $weights   An optional weights array used to weight each input set.\n     * @param string $aggregate An optional modifier in how Redis will combine duplicate members.\n     *                          Valid:  'MIN', 'MAX', 'SUM'.\n     *\n     * @return Redis|int|false The number of members stored in the destination set or false on failure.\n     *\n     * @see https://redis.io/commands/zunionstore\n     * @see Redis::zunion()\n     *\n     * @example\n     * $redis->zAdd('zs1', 1, 'one', 3, 'three');\n     * $redis->zAdd('zs1', 2, 'two', 4, 'four');\n     * $redis->zadd('zs3', 1, 'one', 7, 'five');\n     *\n     * $redis->zUnionStore('dst', ['zs1', 'zs2', 'zs3']);\n     */\n    public function zunionstore(string $dst, array $keys, ?array $weights = null, ?string $aggregate = null): Redis|int|false;\n}\n\nclass RedisException extends RuntimeException {}\n"
        },
        {
          "name": "redis_arginfo.h",
          "type": "blob",
          "size": 100.1396484375,
          "content": "/* This is a generated file, edit the .stub.php file instead.\n * Stub hash: bacbe6b1d55da4ba6d370fff1090e8de0363c4c2 */\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis___construct, 0, 0, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis___destruct, 0, 0, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis__compress, 0, 1, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis__uncompress arginfo_class_Redis__compress\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis__prefix, 0, 1, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis__serialize, 0, 1, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis__unserialize, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis__pack arginfo_class_Redis__serialize\n\n#define arginfo_class_Redis__unpack arginfo_class_Redis__unserialize\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_acl, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, subcmd, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, args, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_append, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_auth, 0, 1, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, credentials, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_bgSave, 0, 0, Redis, MAY_BE_BOOL)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_bgrewriteaof arginfo_class_Redis_bgSave\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_waitaof, 0, 3, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, numlocal, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, numreplicas, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, timeout, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_bitcount, 0, 1, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, start, IS_LONG, 0, \"0\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, end, IS_LONG, 0, \"-1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, bybit, _IS_BOOL, 0, \"false\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_bitop, 0, 3, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, operation, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, deskey, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, srckey, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_keys, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_bitpos, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, bit, _IS_BOOL, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, start, IS_LONG, 0, \"0\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, end, IS_LONG, 0, \"-1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, bybit, _IS_BOOL, 0, \"false\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_blPop, 0, 2, Redis, MAY_BE_ARRAY|MAY_BE_NULL|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_MASK(0, key_or_keys, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_MASK(0, timeout_or_key, MAY_BE_STRING|MAY_BE_DOUBLE|MAY_BE_LONG, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, extra_args, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_brPop arginfo_class_Redis_blPop\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_brpoplpush, 0, 3, Redis, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, src, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(0, timeout, MAY_BE_LONG|MAY_BE_DOUBLE, NULL)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_bzPopMax, 0, 2, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_MASK(0, key, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_MASK(0, timeout_or_key, MAY_BE_STRING|MAY_BE_LONG, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, extra_args, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_bzPopMin arginfo_class_Redis_bzPopMax\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_bzmpop, 0, 3, Redis, MAY_BE_ARRAY|MAY_BE_NULL|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, timeout, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO(0, from, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"1\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zmpop, 0, 2, Redis, MAY_BE_ARRAY|MAY_BE_NULL|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO(0, from, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"1\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_blmpop arginfo_class_Redis_bzmpop\n\n#define arginfo_class_Redis_lmpop arginfo_class_Redis_zmpop\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_clearLastError, 0, 0, _IS_BOOL, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_client, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, opt, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, args, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_close arginfo_class_Redis_clearLastError\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_command, 0, 0, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, opt, IS_STRING, 1, \"null\")\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, args, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_config, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, operation, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(0, key_or_settings, MAY_BE_ARRAY|MAY_BE_STRING|MAY_BE_NULL, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, value, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_connect, 0, 1, _IS_BOOL, 0)\n\tZEND_ARG_TYPE_INFO(0, host, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, port, IS_LONG, 0, \"6379\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, timeout, IS_DOUBLE, 0, \"0\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, persistent_id, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, retry_interval, IS_LONG, 0, \"0\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, read_timeout, IS_DOUBLE, 0, \"0\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, context, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_copy, 0, 2, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, src, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_dbSize, 0, 0, Redis, MAY_BE_LONG|MAY_BE_FALSE)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_debug, 0, 1, Redis, MAY_BE_STRING)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_decr, 0, 1, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, by, IS_LONG, 0, \"1\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_decrBy, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_del, 0, 1, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_MASK(0, key, MAY_BE_ARRAY|MAY_BE_STRING, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_keys, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_delete arginfo_class_Redis_del\n\n#define arginfo_class_Redis_discard arginfo_class_Redis_bgSave\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_dump, 0, 1, Redis, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_echo, 0, 1, Redis, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, str, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_eval, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, script, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, args, IS_ARRAY, 0, \"[]\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, num_keys, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_eval_ro, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, script_sha, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, args, IS_ARRAY, 0, \"[]\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, num_keys, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_evalsha, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, sha1, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, args, IS_ARRAY, 0, \"[]\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, num_keys, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_evalsha_ro arginfo_class_Redis_evalsha\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_exec, 0, 0, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_exists, 0, 1, Redis, MAY_BE_LONG|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_MIXED, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_keys, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_expire, 0, 2, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, timeout, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, mode, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_expireAt, 0, 2, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, timestamp, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, mode, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_failover, 0, 0, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, to, IS_ARRAY, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, abort, _IS_BOOL, 0, \"false\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, timeout, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_expiretime, 0, 1, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_pexpiretime arginfo_class_Redis_expiretime\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_fcall, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, fn, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, keys, IS_ARRAY, 0, \"[]\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, args, IS_ARRAY, 0, \"[]\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_fcall_ro arginfo_class_Redis_fcall\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_flushAll, 0, 0, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, sync, _IS_BOOL, 1, \"null\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_flushDB arginfo_class_Redis_flushAll\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_function, 0, 1, Redis, MAY_BE_BOOL|MAY_BE_STRING|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, operation, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, args, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_geoadd, 0, 4, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, lng, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, lat, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_triples_and_options, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_geodist, 0, 3, Redis, MAY_BE_DOUBLE|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, src, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, unit, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_geohash, 0, 2, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_members, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_geopos arginfo_class_Redis_geohash\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_georadius, 0, 5, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, lng, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, lat, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, radius, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, unit, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 0, \"[]\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_georadius_ro arginfo_class_Redis_georadius\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_georadiusbymember, 0, 4, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, radius, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, unit, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 0, \"[]\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_georadiusbymember_ro arginfo_class_Redis_georadiusbymember\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_geosearch, 0, 4, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(0, position, MAY_BE_ARRAY|MAY_BE_STRING, NULL)\n\tZEND_ARG_TYPE_MASK(0, shape, MAY_BE_ARRAY|MAY_BE_LONG|MAY_BE_DOUBLE, NULL)\n\tZEND_ARG_TYPE_INFO(0, unit, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 0, \"[]\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_geosearchstore, 0, 5, Redis, MAY_BE_ARRAY|MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, src, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(0, position, MAY_BE_ARRAY|MAY_BE_STRING, NULL)\n\tZEND_ARG_TYPE_MASK(0, shape, MAY_BE_ARRAY|MAY_BE_LONG|MAY_BE_DOUBLE, NULL)\n\tZEND_ARG_TYPE_INFO(0, unit, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 0, \"[]\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_get, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_getAuth, 0, 0, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_getBit, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, idx, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_getEx, 0, 1, Redis, MAY_BE_STRING|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 0, \"[]\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_getDBNum, 0, 0, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_getDel, 0, 1, Redis, MAY_BE_STRING|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_getHost, 0, 0, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_getLastError, 0, 0, IS_STRING, 1)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_getMode arginfo_class_Redis_getDBNum\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_getOption, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, option, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_getPersistentID arginfo_class_Redis_getLastError\n\n#define arginfo_class_Redis_getPort arginfo_class_Redis_getDBNum\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_getRange, 0, 3, Redis, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_lcs, 0, 2, Redis, MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key1, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, key2, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_getReadTimeout, 0, 0, IS_DOUBLE, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_getset, 0, 2, Redis, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_Redis_getTimeout, 0, 0, MAY_BE_DOUBLE|MAY_BE_FALSE)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_getTransferredBytes, 0, 0, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_clearTransferredBytes, 0, 0, IS_VOID, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_hDel, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, field, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_fields, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_hExists, 0, 2, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, field, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_hGet, 0, 2, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_hGetAll, 0, 1, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_hIncrBy, 0, 3, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, field, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_hIncrByFloat, 0, 3, Redis, MAY_BE_DOUBLE|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, field, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_DOUBLE, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_hKeys arginfo_class_Redis_hGetAll\n\n#define arginfo_class_Redis_hLen arginfo_class_Redis_expiretime\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_hMget, 0, 2, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, fields, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_hMset, 0, 2, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, fieldvals, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_hRandField, 0, 1, Redis, MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_hSet, 0, 1, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, fields_and_vals, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_hSetNx, 0, 3, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, field, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_hStrLen, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, field, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_hVals arginfo_class_Redis_hGetAll\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_hscan, 0, 2, Redis, MAY_BE_ARRAY|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(1, iterator, MAY_BE_NULL|MAY_BE_LONG|MAY_BE_STRING, NULL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, pattern, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_expiremember, 0, 3, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, field, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, ttl, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, unit, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_expirememberat, 0, 3, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, field, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, timestamp, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_incr arginfo_class_Redis_decr\n\n#define arginfo_class_Redis_incrBy arginfo_class_Redis_decrBy\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_incrByFloat, 0, 2, Redis, MAY_BE_DOUBLE|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_DOUBLE, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_info, 0, 0, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, sections, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_isConnected arginfo_class_Redis_clearLastError\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_keys, 0, 0, 1)\n\tZEND_ARG_TYPE_INFO(0, pattern, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_lInsert, 0, 0, 4)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, pos, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, pivot, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_lLen arginfo_class_Redis_expiretime\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_lMove, 0, 4, Redis, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, src, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, wherefrom, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, whereto, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_blmove, 0, 5, Redis, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, src, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, wherefrom, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, whereto, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, timeout, IS_DOUBLE, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_lPop, 0, 1, Redis, MAY_BE_BOOL|MAY_BE_STRING|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_lPos, 0, 2, Redis, MAY_BE_NULL|MAY_BE_BOOL|MAY_BE_LONG|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_lPush, 0, 1, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, elements, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_rPush arginfo_class_Redis_lPush\n\n#define arginfo_class_Redis_lPushx arginfo_class_Redis_append\n\n#define arginfo_class_Redis_rPushx arginfo_class_Redis_append\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_lSet, 0, 3, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, index, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_lastSave arginfo_class_Redis_getDBNum\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_lindex, 0, 2, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, index, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_lrange, 0, 3, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_lrem, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_ltrim, 0, 3, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_mget, 0, 1, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_migrate, 0, 5, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, host, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, port, IS_LONG, 0)\n\tZEND_ARG_TYPE_MASK(0, key, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_INFO(0, dstdb, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, timeout, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, copy, _IS_BOOL, 0, \"false\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, replace, _IS_BOOL, 0, \"false\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, credentials, IS_MIXED, 0, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_move, 0, 2, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, index, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_mset, 0, 1, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key_values, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_msetnx arginfo_class_Redis_mset\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_multi, 0, 0, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, value, IS_LONG, 0, \"Redis::MULTI\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_object, 0, 2, Redis, MAY_BE_LONG|MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, subcommand, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_open arginfo_class_Redis_connect\n\n#define arginfo_class_Redis_pconnect arginfo_class_Redis_connect\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_persist, 0, 1, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_pexpire, 0, 2, _IS_BOOL, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, timeout, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, mode, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_pexpireAt arginfo_class_Redis_expireAt\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_pfadd, 0, 2, Redis, MAY_BE_LONG)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, elements, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_pfcount, 0, 1, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_MASK(0, key_or_keys, MAY_BE_ARRAY|MAY_BE_STRING, NULL)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_pfmerge, 0, 2, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, srckeys, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_ping, 0, 0, Redis, MAY_BE_STRING|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, message, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_pipeline, 0, 0, Redis, MAY_BE_BOOL)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_popen arginfo_class_Redis_connect\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_psetex, 0, 3, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, expire, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_psubscribe, 0, 2, _IS_BOOL, 0)\n\tZEND_ARG_TYPE_INFO(0, patterns, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO(0, cb, IS_CALLABLE, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_pttl arginfo_class_Redis_expiretime\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_publish, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, channel, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, message, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_pubsub, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, command, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, arg, IS_MIXED, 0, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_punsubscribe, 0, 1, Redis, MAY_BE_ARRAY|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, patterns, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_rPop, 0, 1, Redis, MAY_BE_ARRAY|MAY_BE_STRING|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_randomKey, 0, 0, Redis, MAY_BE_STRING|MAY_BE_FALSE)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_rawcommand, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, command, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, args, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_rename, 0, 2, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, old_name, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, new_name, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_renameNx, 0, 2, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key_src, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, key_dst, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_reset arginfo_class_Redis_bgSave\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_restore, 0, 3, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, ttl, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_role arginfo_class_Redis_getAuth\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_rpoplpush, 0, 2, Redis, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, srckey, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, dstkey, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_sAdd, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_values, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_sAddArray, 0, 2, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, values, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_sDiff, 0, 1, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_keys, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_sDiffStore, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_keys, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_sInter, 0, 1, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_MASK(0, key, MAY_BE_ARRAY|MAY_BE_STRING, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_keys, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_sintercard, 0, 1, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, limit, IS_LONG, 0, \"-1\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_sInterStore arginfo_class_Redis_del\n\n#define arginfo_class_Redis_sMembers arginfo_class_Redis_hGetAll\n\n#define arginfo_class_Redis_sMisMember arginfo_class_Redis_geohash\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_sMove, 0, 3, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, src, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_sPop, 0, 1, Redis, MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_sRandMember, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_sUnion arginfo_class_Redis_sDiff\n\n#define arginfo_class_Redis_sUnionStore arginfo_class_Redis_sDiffStore\n\n#define arginfo_class_Redis_save arginfo_class_Redis_bgSave\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_Redis_scan, 0, 1, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_MASK(1, iterator, MAY_BE_NULL|MAY_BE_LONG|MAY_BE_STRING, NULL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, pattern, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, type, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_scard arginfo_class_Redis_expiretime\n\n#define arginfo_class_Redis_script arginfo_class_Redis_rawcommand\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_select, 0, 1, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, db, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_set, 0, 2, Redis, MAY_BE_STRING|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_MIXED, 0, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_setBit, 0, 3, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, idx, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, value, _IS_BOOL, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_setRange, 0, 3, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, index, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_setOption, 0, 2, _IS_BOOL, 0)\n\tZEND_ARG_TYPE_INFO(0, option, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_setex, 0, 0, 3)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, expire, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_setnx, 0, 2, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_sismember arginfo_class_Redis_setnx\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_slaveof, 0, 0, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, host, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, port, IS_LONG, 0, \"6379\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_replicaof arginfo_class_Redis_slaveof\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_touch, 0, 1, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_MASK(0, key_or_array, MAY_BE_ARRAY|MAY_BE_STRING, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, more_keys, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_slowlog, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, operation, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, length, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_sort, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_sort_ro arginfo_class_Redis_sort\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_sortAsc, 0, 1, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, pattern, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, get, IS_MIXED, 0, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, offset, IS_LONG, 0, \"-1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"-1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, store, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_sortAscAlpha arginfo_class_Redis_sortAsc\n\n#define arginfo_class_Redis_sortDesc arginfo_class_Redis_sortAsc\n\n#define arginfo_class_Redis_sortDescAlpha arginfo_class_Redis_sortAsc\n\n#define arginfo_class_Redis_srem arginfo_class_Redis_sAdd\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_Redis_sscan, 0, 2, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(1, iterator, MAY_BE_NULL|MAY_BE_LONG|MAY_BE_STRING, NULL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, pattern, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_ssubscribe, 0, 2, _IS_BOOL, 0)\n\tZEND_ARG_TYPE_INFO(0, channels, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO(0, cb, IS_CALLABLE, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_strlen arginfo_class_Redis_expiretime\n\n#define arginfo_class_Redis_subscribe arginfo_class_Redis_ssubscribe\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_sunsubscribe, 0, 1, Redis, MAY_BE_ARRAY|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, channels, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_swapdb, 0, 2, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, src, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_time, 0, 0, Redis, MAY_BE_ARRAY)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_ttl arginfo_class_Redis_expiretime\n\n#define arginfo_class_Redis_type arginfo_class_Redis_expiretime\n\n#define arginfo_class_Redis_unlink arginfo_class_Redis_del\n\n#define arginfo_class_Redis_unsubscribe arginfo_class_Redis_sunsubscribe\n\n#define arginfo_class_Redis_unwatch arginfo_class_Redis_bgSave\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_watch, 0, 1, Redis, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_MASK(0, key, MAY_BE_ARRAY|MAY_BE_STRING, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_keys, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_Redis_wait, 0, 2, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, numreplicas, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, timeout, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_Redis_xack, 0, 3, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, group, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, ids, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_xadd, 0, 3, Redis, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, id, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, values, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, maxlen, IS_LONG, 0, \"0\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, approx, _IS_BOOL, 0, \"false\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, nomkstream, _IS_BOOL, 0, \"false\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_xautoclaim, 0, 5, Redis, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, group, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, consumer, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, min_idle, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"-1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, justid, _IS_BOOL, 0, \"false\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_xclaim, 0, 6, Redis, MAY_BE_ARRAY|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, group, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, consumer, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, min_idle, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, ids, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO(0, options, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_xdel, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, ids, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_xgroup, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, operation, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, key, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, group, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, id_or_consumer, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, mkstream, _IS_BOOL, 0, \"false\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, entries_read, IS_LONG, 0, \"-2\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_Redis_xinfo, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, operation, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, arg1, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, arg2, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"-1\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_xlen arginfo_class_Redis_expiretime\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_xpending, 0, 2, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, group, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, start, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, end, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"-1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, consumer, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_xrange, 0, 3, Redis, MAY_BE_ARRAY|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"-1\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_xread, 0, 1, Redis, MAY_BE_ARRAY|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, streams, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"-1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, block, IS_LONG, 0, \"-1\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_xreadgroup, 0, 3, Redis, MAY_BE_ARRAY|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, group, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, consumer, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, streams, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, block, IS_LONG, 0, \"1\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_xrevrange, 0, 3, Redis, MAY_BE_ARRAY|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"-1\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_xtrim, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, threshold, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, approx, _IS_BOOL, 0, \"false\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, minid, _IS_BOOL, 0, \"false\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, limit, IS_LONG, 0, \"-1\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zAdd, 0, 2, Redis, MAY_BE_LONG|MAY_BE_DOUBLE|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(0, score_or_options, MAY_BE_ARRAY|MAY_BE_DOUBLE, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, more_scores_and_mems, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_zCard arginfo_class_Redis_expiretime\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zCount, 0, 3, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(0, start, MAY_BE_LONG|MAY_BE_STRING, NULL)\n\tZEND_ARG_TYPE_MASK(0, end, MAY_BE_LONG|MAY_BE_STRING, NULL)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zIncrBy, 0, 3, Redis, MAY_BE_DOUBLE|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zLexCount, 0, 3, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, min, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, max, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zMscore, 0, 2, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_MIXED, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_members, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zPopMax, 0, 1, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 1, \"null\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_zPopMin arginfo_class_Redis_zPopMax\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zRange, 0, 3, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(0, start, MAY_BE_STRING|MAY_BE_LONG, NULL)\n\tZEND_ARG_TYPE_MASK(0, end, MAY_BE_STRING|MAY_BE_LONG, NULL)\n\tZEND_ARG_TYPE_MASK(0, options, MAY_BE_ARRAY|MAY_BE_BOOL|MAY_BE_NULL, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zRangeByLex, 0, 3, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, min, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, max, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, offset, IS_LONG, 0, \"-1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"-1\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zRangeByScore, 0, 3, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 0, \"[]\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zrangestore, 0, 4, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, dstkey, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, srckey, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(0, options, MAY_BE_ARRAY|MAY_BE_BOOL|MAY_BE_NULL, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zRandMember, 0, 1, Redis, MAY_BE_STRING|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zRank, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zRem, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_MIXED, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_members, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_zRemRangeByLex arginfo_class_Redis_zLexCount\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zRemRangeByRank, 0, 3, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zRemRangeByScore, 0, 3, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zRevRange, 0, 3, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, scores, IS_MIXED, 0, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zRevRangeByLex, 0, 3, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, max, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, min, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, offset, IS_LONG, 0, \"-1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"-1\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zRevRangeByScore, 0, 3, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, max, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, min, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(0, options, MAY_BE_ARRAY|MAY_BE_BOOL, \"[]\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_zRevRank arginfo_class_Redis_zRank\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zScore, 0, 2, Redis, MAY_BE_DOUBLE|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zdiff, 0, 1, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zdiffstore, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zinter, 0, 1, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, weights, IS_ARRAY, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_zintercard arginfo_class_Redis_sintercard\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zinterstore, 0, 2, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, weights, IS_ARRAY, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, aggregate, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_Redis_zscan, 0, 2, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(1, iterator, MAY_BE_NULL|MAY_BE_LONG|MAY_BE_STRING, NULL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, pattern, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_zunion arginfo_class_Redis_zinter\n\n#define arginfo_class_Redis_zunionstore arginfo_class_Redis_zinterstore\n\n\nZEND_METHOD(Redis, __construct);\nZEND_METHOD(Redis, __destruct);\nZEND_METHOD(Redis, _compress);\nZEND_METHOD(Redis, _uncompress);\nZEND_METHOD(Redis, _prefix);\nZEND_METHOD(Redis, _serialize);\nZEND_METHOD(Redis, _unserialize);\nZEND_METHOD(Redis, _pack);\nZEND_METHOD(Redis, _unpack);\nZEND_METHOD(Redis, acl);\nZEND_METHOD(Redis, append);\nZEND_METHOD(Redis, auth);\nZEND_METHOD(Redis, bgSave);\nZEND_METHOD(Redis, bgrewriteaof);\nZEND_METHOD(Redis, waitaof);\nZEND_METHOD(Redis, bitcount);\nZEND_METHOD(Redis, bitop);\nZEND_METHOD(Redis, bitpos);\nZEND_METHOD(Redis, blPop);\nZEND_METHOD(Redis, brPop);\nZEND_METHOD(Redis, brpoplpush);\nZEND_METHOD(Redis, bzPopMax);\nZEND_METHOD(Redis, bzPopMin);\nZEND_METHOD(Redis, bzmpop);\nZEND_METHOD(Redis, zmpop);\nZEND_METHOD(Redis, blmpop);\nZEND_METHOD(Redis, lmpop);\nZEND_METHOD(Redis, clearLastError);\nZEND_METHOD(Redis, client);\nZEND_METHOD(Redis, close);\nZEND_METHOD(Redis, command);\nZEND_METHOD(Redis, config);\nZEND_METHOD(Redis, connect);\nZEND_METHOD(Redis, copy);\nZEND_METHOD(Redis, dbSize);\nZEND_METHOD(Redis, debug);\nZEND_METHOD(Redis, decr);\nZEND_METHOD(Redis, decrBy);\nZEND_METHOD(Redis, del);\nZEND_METHOD(Redis, discard);\nZEND_METHOD(Redis, dump);\nZEND_METHOD(Redis, echo);\nZEND_METHOD(Redis, eval);\nZEND_METHOD(Redis, eval_ro);\nZEND_METHOD(Redis, evalsha);\nZEND_METHOD(Redis, evalsha_ro);\nZEND_METHOD(Redis, exec);\nZEND_METHOD(Redis, exists);\nZEND_METHOD(Redis, expire);\nZEND_METHOD(Redis, expireAt);\nZEND_METHOD(Redis, failover);\nZEND_METHOD(Redis, expiretime);\nZEND_METHOD(Redis, pexpiretime);\nZEND_METHOD(Redis, fcall);\nZEND_METHOD(Redis, fcall_ro);\nZEND_METHOD(Redis, flushAll);\nZEND_METHOD(Redis, flushDB);\nZEND_METHOD(Redis, function);\nZEND_METHOD(Redis, geoadd);\nZEND_METHOD(Redis, geodist);\nZEND_METHOD(Redis, geohash);\nZEND_METHOD(Redis, geopos);\nZEND_METHOD(Redis, georadius);\nZEND_METHOD(Redis, georadius_ro);\nZEND_METHOD(Redis, georadiusbymember);\nZEND_METHOD(Redis, georadiusbymember_ro);\nZEND_METHOD(Redis, geosearch);\nZEND_METHOD(Redis, geosearchstore);\nZEND_METHOD(Redis, get);\nZEND_METHOD(Redis, getAuth);\nZEND_METHOD(Redis, getBit);\nZEND_METHOD(Redis, getEx);\nZEND_METHOD(Redis, getDBNum);\nZEND_METHOD(Redis, getDel);\nZEND_METHOD(Redis, getHost);\nZEND_METHOD(Redis, getLastError);\nZEND_METHOD(Redis, getMode);\nZEND_METHOD(Redis, getOption);\nZEND_METHOD(Redis, getPersistentID);\nZEND_METHOD(Redis, getPort);\nZEND_METHOD(Redis, getRange);\nZEND_METHOD(Redis, lcs);\nZEND_METHOD(Redis, getReadTimeout);\nZEND_METHOD(Redis, getset);\nZEND_METHOD(Redis, getTimeout);\nZEND_METHOD(Redis, getTransferredBytes);\nZEND_METHOD(Redis, clearTransferredBytes);\nZEND_METHOD(Redis, hDel);\nZEND_METHOD(Redis, hExists);\nZEND_METHOD(Redis, hGet);\nZEND_METHOD(Redis, hGetAll);\nZEND_METHOD(Redis, hIncrBy);\nZEND_METHOD(Redis, hIncrByFloat);\nZEND_METHOD(Redis, hKeys);\nZEND_METHOD(Redis, hLen);\nZEND_METHOD(Redis, hMget);\nZEND_METHOD(Redis, hMset);\nZEND_METHOD(Redis, hRandField);\nZEND_METHOD(Redis, hSet);\nZEND_METHOD(Redis, hSetNx);\nZEND_METHOD(Redis, hStrLen);\nZEND_METHOD(Redis, hVals);\nZEND_METHOD(Redis, hscan);\nZEND_METHOD(Redis, expiremember);\nZEND_METHOD(Redis, expirememberat);\nZEND_METHOD(Redis, incr);\nZEND_METHOD(Redis, incrBy);\nZEND_METHOD(Redis, incrByFloat);\nZEND_METHOD(Redis, info);\nZEND_METHOD(Redis, isConnected);\nZEND_METHOD(Redis, keys);\nZEND_METHOD(Redis, lInsert);\nZEND_METHOD(Redis, lLen);\nZEND_METHOD(Redis, lMove);\nZEND_METHOD(Redis, blmove);\nZEND_METHOD(Redis, lPop);\nZEND_METHOD(Redis, lPos);\nZEND_METHOD(Redis, lPush);\nZEND_METHOD(Redis, rPush);\nZEND_METHOD(Redis, lPushx);\nZEND_METHOD(Redis, rPushx);\nZEND_METHOD(Redis, lSet);\nZEND_METHOD(Redis, lastSave);\nZEND_METHOD(Redis, lindex);\nZEND_METHOD(Redis, lrange);\nZEND_METHOD(Redis, lrem);\nZEND_METHOD(Redis, ltrim);\nZEND_METHOD(Redis, mget);\nZEND_METHOD(Redis, migrate);\nZEND_METHOD(Redis, move);\nZEND_METHOD(Redis, mset);\nZEND_METHOD(Redis, msetnx);\nZEND_METHOD(Redis, multi);\nZEND_METHOD(Redis, object);\nZEND_METHOD(Redis, pconnect);\nZEND_METHOD(Redis, persist);\nZEND_METHOD(Redis, pexpire);\nZEND_METHOD(Redis, pexpireAt);\nZEND_METHOD(Redis, pfadd);\nZEND_METHOD(Redis, pfcount);\nZEND_METHOD(Redis, pfmerge);\nZEND_METHOD(Redis, ping);\nZEND_METHOD(Redis, pipeline);\nZEND_METHOD(Redis, psetex);\nZEND_METHOD(Redis, psubscribe);\nZEND_METHOD(Redis, pttl);\nZEND_METHOD(Redis, publish);\nZEND_METHOD(Redis, pubsub);\nZEND_METHOD(Redis, punsubscribe);\nZEND_METHOD(Redis, rPop);\nZEND_METHOD(Redis, randomKey);\nZEND_METHOD(Redis, rawcommand);\nZEND_METHOD(Redis, rename);\nZEND_METHOD(Redis, renameNx);\nZEND_METHOD(Redis, reset);\nZEND_METHOD(Redis, restore);\nZEND_METHOD(Redis, role);\nZEND_METHOD(Redis, rpoplpush);\nZEND_METHOD(Redis, sAdd);\nZEND_METHOD(Redis, sAddArray);\nZEND_METHOD(Redis, sDiff);\nZEND_METHOD(Redis, sDiffStore);\nZEND_METHOD(Redis, sInter);\nZEND_METHOD(Redis, sintercard);\nZEND_METHOD(Redis, sInterStore);\nZEND_METHOD(Redis, sMembers);\nZEND_METHOD(Redis, sMisMember);\nZEND_METHOD(Redis, sMove);\nZEND_METHOD(Redis, sPop);\nZEND_METHOD(Redis, sRandMember);\nZEND_METHOD(Redis, sUnion);\nZEND_METHOD(Redis, sUnionStore);\nZEND_METHOD(Redis, save);\nZEND_METHOD(Redis, scan);\nZEND_METHOD(Redis, scard);\nZEND_METHOD(Redis, script);\nZEND_METHOD(Redis, select);\nZEND_METHOD(Redis, set);\nZEND_METHOD(Redis, setBit);\nZEND_METHOD(Redis, setRange);\nZEND_METHOD(Redis, setOption);\nZEND_METHOD(Redis, setex);\nZEND_METHOD(Redis, setnx);\nZEND_METHOD(Redis, sismember);\nZEND_METHOD(Redis, slaveof);\nZEND_METHOD(Redis, replicaof);\nZEND_METHOD(Redis, touch);\nZEND_METHOD(Redis, slowlog);\nZEND_METHOD(Redis, sort);\nZEND_METHOD(Redis, sort_ro);\nZEND_METHOD(Redis, sortAsc);\nZEND_METHOD(Redis, sortAscAlpha);\nZEND_METHOD(Redis, sortDesc);\nZEND_METHOD(Redis, sortDescAlpha);\nZEND_METHOD(Redis, srem);\nZEND_METHOD(Redis, sscan);\nZEND_METHOD(Redis, ssubscribe);\nZEND_METHOD(Redis, strlen);\nZEND_METHOD(Redis, subscribe);\nZEND_METHOD(Redis, sunsubscribe);\nZEND_METHOD(Redis, swapdb);\nZEND_METHOD(Redis, time);\nZEND_METHOD(Redis, ttl);\nZEND_METHOD(Redis, type);\nZEND_METHOD(Redis, unlink);\nZEND_METHOD(Redis, unsubscribe);\nZEND_METHOD(Redis, unwatch);\nZEND_METHOD(Redis, watch);\nZEND_METHOD(Redis, wait);\nZEND_METHOD(Redis, xack);\nZEND_METHOD(Redis, xadd);\nZEND_METHOD(Redis, xautoclaim);\nZEND_METHOD(Redis, xclaim);\nZEND_METHOD(Redis, xdel);\nZEND_METHOD(Redis, xgroup);\nZEND_METHOD(Redis, xinfo);\nZEND_METHOD(Redis, xlen);\nZEND_METHOD(Redis, xpending);\nZEND_METHOD(Redis, xrange);\nZEND_METHOD(Redis, xread);\nZEND_METHOD(Redis, xreadgroup);\nZEND_METHOD(Redis, xrevrange);\nZEND_METHOD(Redis, xtrim);\nZEND_METHOD(Redis, zAdd);\nZEND_METHOD(Redis, zCard);\nZEND_METHOD(Redis, zCount);\nZEND_METHOD(Redis, zIncrBy);\nZEND_METHOD(Redis, zLexCount);\nZEND_METHOD(Redis, zMscore);\nZEND_METHOD(Redis, zPopMax);\nZEND_METHOD(Redis, zPopMin);\nZEND_METHOD(Redis, zRange);\nZEND_METHOD(Redis, zRangeByLex);\nZEND_METHOD(Redis, zRangeByScore);\nZEND_METHOD(Redis, zrangestore);\nZEND_METHOD(Redis, zRandMember);\nZEND_METHOD(Redis, zRank);\nZEND_METHOD(Redis, zRem);\nZEND_METHOD(Redis, zRemRangeByLex);\nZEND_METHOD(Redis, zRemRangeByRank);\nZEND_METHOD(Redis, zRemRangeByScore);\nZEND_METHOD(Redis, zRevRange);\nZEND_METHOD(Redis, zRevRangeByLex);\nZEND_METHOD(Redis, zRevRangeByScore);\nZEND_METHOD(Redis, zRevRank);\nZEND_METHOD(Redis, zScore);\nZEND_METHOD(Redis, zdiff);\nZEND_METHOD(Redis, zdiffstore);\nZEND_METHOD(Redis, zinter);\nZEND_METHOD(Redis, zintercard);\nZEND_METHOD(Redis, zinterstore);\nZEND_METHOD(Redis, zscan);\nZEND_METHOD(Redis, zunion);\nZEND_METHOD(Redis, zunionstore);\n\n\nstatic const zend_function_entry class_Redis_methods[] = {\n\tZEND_ME(Redis, __construct, arginfo_class_Redis___construct, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, __destruct, arginfo_class_Redis___destruct, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, _compress, arginfo_class_Redis__compress, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, _uncompress, arginfo_class_Redis__uncompress, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, _prefix, arginfo_class_Redis__prefix, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, _serialize, arginfo_class_Redis__serialize, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, _unserialize, arginfo_class_Redis__unserialize, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, _pack, arginfo_class_Redis__pack, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, _unpack, arginfo_class_Redis__unpack, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, acl, arginfo_class_Redis_acl, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, append, arginfo_class_Redis_append, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, auth, arginfo_class_Redis_auth, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bgSave, arginfo_class_Redis_bgSave, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bgrewriteaof, arginfo_class_Redis_bgrewriteaof, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, waitaof, arginfo_class_Redis_waitaof, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bitcount, arginfo_class_Redis_bitcount, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bitop, arginfo_class_Redis_bitop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bitpos, arginfo_class_Redis_bitpos, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, blPop, arginfo_class_Redis_blPop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, brPop, arginfo_class_Redis_brPop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, brpoplpush, arginfo_class_Redis_brpoplpush, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bzPopMax, arginfo_class_Redis_bzPopMax, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bzPopMin, arginfo_class_Redis_bzPopMin, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bzmpop, arginfo_class_Redis_bzmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zmpop, arginfo_class_Redis_zmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, blmpop, arginfo_class_Redis_blmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lmpop, arginfo_class_Redis_lmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, clearLastError, arginfo_class_Redis_clearLastError, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, client, arginfo_class_Redis_client, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, close, arginfo_class_Redis_close, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, command, arginfo_class_Redis_command, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, config, arginfo_class_Redis_config, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, connect, arginfo_class_Redis_connect, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, copy, arginfo_class_Redis_copy, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, dbSize, arginfo_class_Redis_dbSize, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, debug, arginfo_class_Redis_debug, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, decr, arginfo_class_Redis_decr, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, decrBy, arginfo_class_Redis_decrBy, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, del, arginfo_class_Redis_del, ZEND_ACC_PUBLIC)\n\tZEND_MALIAS(Redis, delete, del, arginfo_class_Redis_delete, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, discard, arginfo_class_Redis_discard, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, dump, arginfo_class_Redis_dump, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, echo, arginfo_class_Redis_echo, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, eval, arginfo_class_Redis_eval, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, eval_ro, arginfo_class_Redis_eval_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, evalsha, arginfo_class_Redis_evalsha, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, evalsha_ro, arginfo_class_Redis_evalsha_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, exec, arginfo_class_Redis_exec, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, exists, arginfo_class_Redis_exists, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, expire, arginfo_class_Redis_expire, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, expireAt, arginfo_class_Redis_expireAt, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, failover, arginfo_class_Redis_failover, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, expiretime, arginfo_class_Redis_expiretime, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pexpiretime, arginfo_class_Redis_pexpiretime, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, fcall, arginfo_class_Redis_fcall, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, fcall_ro, arginfo_class_Redis_fcall_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, flushAll, arginfo_class_Redis_flushAll, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, flushDB, arginfo_class_Redis_flushDB, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, function, arginfo_class_Redis_function, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, geoadd, arginfo_class_Redis_geoadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, geodist, arginfo_class_Redis_geodist, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, geohash, arginfo_class_Redis_geohash, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, geopos, arginfo_class_Redis_geopos, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, georadius, arginfo_class_Redis_georadius, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, georadius_ro, arginfo_class_Redis_georadius_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, georadiusbymember, arginfo_class_Redis_georadiusbymember, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, georadiusbymember_ro, arginfo_class_Redis_georadiusbymember_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, geosearch, arginfo_class_Redis_geosearch, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, geosearchstore, arginfo_class_Redis_geosearchstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, get, arginfo_class_Redis_get, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getAuth, arginfo_class_Redis_getAuth, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getBit, arginfo_class_Redis_getBit, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getEx, arginfo_class_Redis_getEx, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getDBNum, arginfo_class_Redis_getDBNum, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getDel, arginfo_class_Redis_getDel, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getHost, arginfo_class_Redis_getHost, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getLastError, arginfo_class_Redis_getLastError, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getMode, arginfo_class_Redis_getMode, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getOption, arginfo_class_Redis_getOption, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getPersistentID, arginfo_class_Redis_getPersistentID, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getPort, arginfo_class_Redis_getPort, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getRange, arginfo_class_Redis_getRange, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lcs, arginfo_class_Redis_lcs, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getReadTimeout, arginfo_class_Redis_getReadTimeout, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getset, arginfo_class_Redis_getset, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getTimeout, arginfo_class_Redis_getTimeout, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getTransferredBytes, arginfo_class_Redis_getTransferredBytes, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, clearTransferredBytes, arginfo_class_Redis_clearTransferredBytes, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hDel, arginfo_class_Redis_hDel, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hExists, arginfo_class_Redis_hExists, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hGet, arginfo_class_Redis_hGet, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hGetAll, arginfo_class_Redis_hGetAll, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hIncrBy, arginfo_class_Redis_hIncrBy, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hIncrByFloat, arginfo_class_Redis_hIncrByFloat, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hKeys, arginfo_class_Redis_hKeys, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hLen, arginfo_class_Redis_hLen, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hMget, arginfo_class_Redis_hMget, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hMset, arginfo_class_Redis_hMset, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hRandField, arginfo_class_Redis_hRandField, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hSet, arginfo_class_Redis_hSet, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hSetNx, arginfo_class_Redis_hSetNx, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hStrLen, arginfo_class_Redis_hStrLen, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hVals, arginfo_class_Redis_hVals, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hscan, arginfo_class_Redis_hscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, expiremember, arginfo_class_Redis_expiremember, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, expirememberat, arginfo_class_Redis_expirememberat, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, incr, arginfo_class_Redis_incr, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, incrBy, arginfo_class_Redis_incrBy, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, incrByFloat, arginfo_class_Redis_incrByFloat, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, info, arginfo_class_Redis_info, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, isConnected, arginfo_class_Redis_isConnected, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, keys, arginfo_class_Redis_keys, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lInsert, arginfo_class_Redis_lInsert, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lLen, arginfo_class_Redis_lLen, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lMove, arginfo_class_Redis_lMove, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, blmove, arginfo_class_Redis_blmove, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lPop, arginfo_class_Redis_lPop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lPos, arginfo_class_Redis_lPos, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lPush, arginfo_class_Redis_lPush, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, rPush, arginfo_class_Redis_rPush, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lPushx, arginfo_class_Redis_lPushx, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, rPushx, arginfo_class_Redis_rPushx, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lSet, arginfo_class_Redis_lSet, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lastSave, arginfo_class_Redis_lastSave, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lindex, arginfo_class_Redis_lindex, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lrange, arginfo_class_Redis_lrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lrem, arginfo_class_Redis_lrem, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, ltrim, arginfo_class_Redis_ltrim, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, mget, arginfo_class_Redis_mget, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, migrate, arginfo_class_Redis_migrate, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, move, arginfo_class_Redis_move, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, mset, arginfo_class_Redis_mset, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, msetnx, arginfo_class_Redis_msetnx, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, multi, arginfo_class_Redis_multi, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, object, arginfo_class_Redis_object, ZEND_ACC_PUBLIC)\n\tZEND_MALIAS(Redis, open, connect, arginfo_class_Redis_open, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, pconnect, arginfo_class_Redis_pconnect, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, persist, arginfo_class_Redis_persist, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pexpire, arginfo_class_Redis_pexpire, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pexpireAt, arginfo_class_Redis_pexpireAt, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pfadd, arginfo_class_Redis_pfadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pfcount, arginfo_class_Redis_pfcount, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pfmerge, arginfo_class_Redis_pfmerge, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, ping, arginfo_class_Redis_ping, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pipeline, arginfo_class_Redis_pipeline, ZEND_ACC_PUBLIC)\n\tZEND_MALIAS(Redis, popen, pconnect, arginfo_class_Redis_popen, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, psetex, arginfo_class_Redis_psetex, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, psubscribe, arginfo_class_Redis_psubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pttl, arginfo_class_Redis_pttl, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, publish, arginfo_class_Redis_publish, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pubsub, arginfo_class_Redis_pubsub, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, punsubscribe, arginfo_class_Redis_punsubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, rPop, arginfo_class_Redis_rPop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, randomKey, arginfo_class_Redis_randomKey, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, rawcommand, arginfo_class_Redis_rawcommand, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, rename, arginfo_class_Redis_rename, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, renameNx, arginfo_class_Redis_renameNx, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, reset, arginfo_class_Redis_reset, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, restore, arginfo_class_Redis_restore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, role, arginfo_class_Redis_role, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, rpoplpush, arginfo_class_Redis_rpoplpush, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sAdd, arginfo_class_Redis_sAdd, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sAddArray, arginfo_class_Redis_sAddArray, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sDiff, arginfo_class_Redis_sDiff, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sDiffStore, arginfo_class_Redis_sDiffStore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sInter, arginfo_class_Redis_sInter, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sintercard, arginfo_class_Redis_sintercard, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sInterStore, arginfo_class_Redis_sInterStore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sMembers, arginfo_class_Redis_sMembers, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sMisMember, arginfo_class_Redis_sMisMember, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sMove, arginfo_class_Redis_sMove, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sPop, arginfo_class_Redis_sPop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sRandMember, arginfo_class_Redis_sRandMember, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sUnion, arginfo_class_Redis_sUnion, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sUnionStore, arginfo_class_Redis_sUnionStore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, save, arginfo_class_Redis_save, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, scan, arginfo_class_Redis_scan, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, scard, arginfo_class_Redis_scard, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, script, arginfo_class_Redis_script, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, select, arginfo_class_Redis_select, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, set, arginfo_class_Redis_set, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, setBit, arginfo_class_Redis_setBit, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, setRange, arginfo_class_Redis_setRange, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, setOption, arginfo_class_Redis_setOption, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, setex, arginfo_class_Redis_setex, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, setnx, arginfo_class_Redis_setnx, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sismember, arginfo_class_Redis_sismember, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, slaveof, arginfo_class_Redis_slaveof, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, replicaof, arginfo_class_Redis_replicaof, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, touch, arginfo_class_Redis_touch, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, slowlog, arginfo_class_Redis_slowlog, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sort, arginfo_class_Redis_sort, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sort_ro, arginfo_class_Redis_sort_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sortAsc, arginfo_class_Redis_sortAsc, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, sortAscAlpha, arginfo_class_Redis_sortAscAlpha, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, sortDesc, arginfo_class_Redis_sortDesc, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, sortDescAlpha, arginfo_class_Redis_sortDescAlpha, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, srem, arginfo_class_Redis_srem, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sscan, arginfo_class_Redis_sscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, ssubscribe, arginfo_class_Redis_ssubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, strlen, arginfo_class_Redis_strlen, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, subscribe, arginfo_class_Redis_subscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sunsubscribe, arginfo_class_Redis_sunsubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, swapdb, arginfo_class_Redis_swapdb, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, time, arginfo_class_Redis_time, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, ttl, arginfo_class_Redis_ttl, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, type, arginfo_class_Redis_type, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, unlink, arginfo_class_Redis_unlink, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, unsubscribe, arginfo_class_Redis_unsubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, unwatch, arginfo_class_Redis_unwatch, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, watch, arginfo_class_Redis_watch, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, wait, arginfo_class_Redis_wait, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xack, arginfo_class_Redis_xack, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xadd, arginfo_class_Redis_xadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xautoclaim, arginfo_class_Redis_xautoclaim, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xclaim, arginfo_class_Redis_xclaim, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xdel, arginfo_class_Redis_xdel, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xgroup, arginfo_class_Redis_xgroup, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xinfo, arginfo_class_Redis_xinfo, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xlen, arginfo_class_Redis_xlen, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xpending, arginfo_class_Redis_xpending, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xrange, arginfo_class_Redis_xrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xread, arginfo_class_Redis_xread, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xreadgroup, arginfo_class_Redis_xreadgroup, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xrevrange, arginfo_class_Redis_xrevrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xtrim, arginfo_class_Redis_xtrim, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zAdd, arginfo_class_Redis_zAdd, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zCard, arginfo_class_Redis_zCard, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zCount, arginfo_class_Redis_zCount, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zIncrBy, arginfo_class_Redis_zIncrBy, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zLexCount, arginfo_class_Redis_zLexCount, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zMscore, arginfo_class_Redis_zMscore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zPopMax, arginfo_class_Redis_zPopMax, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zPopMin, arginfo_class_Redis_zPopMin, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRange, arginfo_class_Redis_zRange, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRangeByLex, arginfo_class_Redis_zRangeByLex, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRangeByScore, arginfo_class_Redis_zRangeByScore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zrangestore, arginfo_class_Redis_zrangestore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRandMember, arginfo_class_Redis_zRandMember, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRank, arginfo_class_Redis_zRank, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRem, arginfo_class_Redis_zRem, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRemRangeByLex, arginfo_class_Redis_zRemRangeByLex, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRemRangeByRank, arginfo_class_Redis_zRemRangeByRank, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRemRangeByScore, arginfo_class_Redis_zRemRangeByScore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRevRange, arginfo_class_Redis_zRevRange, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRevRangeByLex, arginfo_class_Redis_zRevRangeByLex, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRevRangeByScore, arginfo_class_Redis_zRevRangeByScore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRevRank, arginfo_class_Redis_zRevRank, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zScore, arginfo_class_Redis_zScore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zdiff, arginfo_class_Redis_zdiff, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zdiffstore, arginfo_class_Redis_zdiffstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zinter, arginfo_class_Redis_zinter, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zintercard, arginfo_class_Redis_zintercard, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zinterstore, arginfo_class_Redis_zinterstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zscan, arginfo_class_Redis_zscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zunion, arginfo_class_Redis_zunion, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zunionstore, arginfo_class_Redis_zunionstore, ZEND_ACC_PUBLIC)\n\tZEND_FE_END\n};\n\n\nstatic const zend_function_entry class_RedisException_methods[] = {\n\tZEND_FE_END\n};\n\nstatic zend_class_entry *register_class_Redis(void)\n{\n\tzend_class_entry ce, *class_entry;\n\n\tINIT_CLASS_ENTRY(ce, \"Redis\", class_Redis_methods);\n\tclass_entry = zend_register_internal_class_ex(&ce, NULL);\n\n\tzval const_REDIS_NOT_FOUND_value;\n\tZVAL_LONG(&const_REDIS_NOT_FOUND_value, REDIS_NOT_FOUND);\n\tzend_string *const_REDIS_NOT_FOUND_name = zend_string_init_interned(\"REDIS_NOT_FOUND\", sizeof(\"REDIS_NOT_FOUND\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_REDIS_NOT_FOUND_name, &const_REDIS_NOT_FOUND_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_REDIS_NOT_FOUND_name);\n\n\tzval const_REDIS_STRING_value;\n\tZVAL_LONG(&const_REDIS_STRING_value, REDIS_STRING);\n\tzend_string *const_REDIS_STRING_name = zend_string_init_interned(\"REDIS_STRING\", sizeof(\"REDIS_STRING\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_REDIS_STRING_name, &const_REDIS_STRING_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_REDIS_STRING_name);\n\n\tzval const_REDIS_SET_value;\n\tZVAL_LONG(&const_REDIS_SET_value, REDIS_SET);\n\tzend_string *const_REDIS_SET_name = zend_string_init_interned(\"REDIS_SET\", sizeof(\"REDIS_SET\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_REDIS_SET_name, &const_REDIS_SET_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_REDIS_SET_name);\n\n\tzval const_REDIS_LIST_value;\n\tZVAL_LONG(&const_REDIS_LIST_value, REDIS_LIST);\n\tzend_string *const_REDIS_LIST_name = zend_string_init_interned(\"REDIS_LIST\", sizeof(\"REDIS_LIST\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_REDIS_LIST_name, &const_REDIS_LIST_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_REDIS_LIST_name);\n\n\tzval const_REDIS_ZSET_value;\n\tZVAL_LONG(&const_REDIS_ZSET_value, REDIS_ZSET);\n\tzend_string *const_REDIS_ZSET_name = zend_string_init_interned(\"REDIS_ZSET\", sizeof(\"REDIS_ZSET\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_REDIS_ZSET_name, &const_REDIS_ZSET_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_REDIS_ZSET_name);\n\n\tzval const_REDIS_HASH_value;\n\tZVAL_LONG(&const_REDIS_HASH_value, REDIS_HASH);\n\tzend_string *const_REDIS_HASH_name = zend_string_init_interned(\"REDIS_HASH\", sizeof(\"REDIS_HASH\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_REDIS_HASH_name, &const_REDIS_HASH_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_REDIS_HASH_name);\n\n\tzval const_REDIS_STREAM_value;\n\tZVAL_LONG(&const_REDIS_STREAM_value, REDIS_STREAM);\n\tzend_string *const_REDIS_STREAM_name = zend_string_init_interned(\"REDIS_STREAM\", sizeof(\"REDIS_STREAM\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_REDIS_STREAM_name, &const_REDIS_STREAM_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_REDIS_STREAM_name);\n\n\tzval const_ATOMIC_value;\n\tZVAL_LONG(&const_ATOMIC_value, ATOMIC);\n\tzend_string *const_ATOMIC_name = zend_string_init_interned(\"ATOMIC\", sizeof(\"ATOMIC\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_ATOMIC_name, &const_ATOMIC_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_ATOMIC_name);\n\n\tzval const_MULTI_value;\n\tZVAL_LONG(&const_MULTI_value, MULTI);\n\tzend_string *const_MULTI_name = zend_string_init_interned(\"MULTI\", sizeof(\"MULTI\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_MULTI_name, &const_MULTI_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_MULTI_name);\n\n\tzval const_PIPELINE_value;\n\tZVAL_LONG(&const_PIPELINE_value, PIPELINE);\n\tzend_string *const_PIPELINE_name = zend_string_init_interned(\"PIPELINE\", sizeof(\"PIPELINE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_PIPELINE_name, &const_PIPELINE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_PIPELINE_name);\n\n\tzval const_OPT_SERIALIZER_value;\n\tZVAL_LONG(&const_OPT_SERIALIZER_value, REDIS_OPT_SERIALIZER);\n\tzend_string *const_OPT_SERIALIZER_name = zend_string_init_interned(\"OPT_SERIALIZER\", sizeof(\"OPT_SERIALIZER\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_SERIALIZER_name, &const_OPT_SERIALIZER_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_SERIALIZER_name);\n\n\tzval const_OPT_PREFIX_value;\n\tZVAL_LONG(&const_OPT_PREFIX_value, REDIS_OPT_PREFIX);\n\tzend_string *const_OPT_PREFIX_name = zend_string_init_interned(\"OPT_PREFIX\", sizeof(\"OPT_PREFIX\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_PREFIX_name, &const_OPT_PREFIX_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_PREFIX_name);\n\n\tzval const_OPT_READ_TIMEOUT_value;\n\tZVAL_LONG(&const_OPT_READ_TIMEOUT_value, REDIS_OPT_READ_TIMEOUT);\n\tzend_string *const_OPT_READ_TIMEOUT_name = zend_string_init_interned(\"OPT_READ_TIMEOUT\", sizeof(\"OPT_READ_TIMEOUT\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_READ_TIMEOUT_name, &const_OPT_READ_TIMEOUT_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_READ_TIMEOUT_name);\n\n\tzval const_OPT_TCP_KEEPALIVE_value;\n\tZVAL_LONG(&const_OPT_TCP_KEEPALIVE_value, REDIS_OPT_TCP_KEEPALIVE);\n\tzend_string *const_OPT_TCP_KEEPALIVE_name = zend_string_init_interned(\"OPT_TCP_KEEPALIVE\", sizeof(\"OPT_TCP_KEEPALIVE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_TCP_KEEPALIVE_name, &const_OPT_TCP_KEEPALIVE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_TCP_KEEPALIVE_name);\n\n\tzval const_OPT_COMPRESSION_value;\n\tZVAL_LONG(&const_OPT_COMPRESSION_value, REDIS_OPT_COMPRESSION);\n\tzend_string *const_OPT_COMPRESSION_name = zend_string_init_interned(\"OPT_COMPRESSION\", sizeof(\"OPT_COMPRESSION\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_COMPRESSION_name, &const_OPT_COMPRESSION_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_COMPRESSION_name);\n\n\tzval const_OPT_REPLY_LITERAL_value;\n\tZVAL_LONG(&const_OPT_REPLY_LITERAL_value, REDIS_OPT_REPLY_LITERAL);\n\tzend_string *const_OPT_REPLY_LITERAL_name = zend_string_init_interned(\"OPT_REPLY_LITERAL\", sizeof(\"OPT_REPLY_LITERAL\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_REPLY_LITERAL_name, &const_OPT_REPLY_LITERAL_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_REPLY_LITERAL_name);\n\n\tzval const_OPT_COMPRESSION_LEVEL_value;\n\tZVAL_LONG(&const_OPT_COMPRESSION_LEVEL_value, REDIS_OPT_COMPRESSION_LEVEL);\n\tzend_string *const_OPT_COMPRESSION_LEVEL_name = zend_string_init_interned(\"OPT_COMPRESSION_LEVEL\", sizeof(\"OPT_COMPRESSION_LEVEL\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_COMPRESSION_LEVEL_name, &const_OPT_COMPRESSION_LEVEL_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_COMPRESSION_LEVEL_name);\n\n\tzval const_OPT_NULL_MULTIBULK_AS_NULL_value;\n\tZVAL_LONG(&const_OPT_NULL_MULTIBULK_AS_NULL_value, REDIS_OPT_NULL_MBULK_AS_NULL);\n\tzend_string *const_OPT_NULL_MULTIBULK_AS_NULL_name = zend_string_init_interned(\"OPT_NULL_MULTIBULK_AS_NULL\", sizeof(\"OPT_NULL_MULTIBULK_AS_NULL\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_NULL_MULTIBULK_AS_NULL_name, &const_OPT_NULL_MULTIBULK_AS_NULL_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_NULL_MULTIBULK_AS_NULL_name);\n\n\tzval const_SERIALIZER_NONE_value;\n\tZVAL_LONG(&const_SERIALIZER_NONE_value, REDIS_SERIALIZER_NONE);\n\tzend_string *const_SERIALIZER_NONE_name = zend_string_init_interned(\"SERIALIZER_NONE\", sizeof(\"SERIALIZER_NONE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SERIALIZER_NONE_name, &const_SERIALIZER_NONE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SERIALIZER_NONE_name);\n\n\tzval const_SERIALIZER_PHP_value;\n\tZVAL_LONG(&const_SERIALIZER_PHP_value, REDIS_SERIALIZER_PHP);\n\tzend_string *const_SERIALIZER_PHP_name = zend_string_init_interned(\"SERIALIZER_PHP\", sizeof(\"SERIALIZER_PHP\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SERIALIZER_PHP_name, &const_SERIALIZER_PHP_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SERIALIZER_PHP_name);\n#if defined(HAVE_REDIS_IGBINARY)\n\n\tzval const_SERIALIZER_IGBINARY_value;\n\tZVAL_LONG(&const_SERIALIZER_IGBINARY_value, REDIS_SERIALIZER_IGBINARY);\n\tzend_string *const_SERIALIZER_IGBINARY_name = zend_string_init_interned(\"SERIALIZER_IGBINARY\", sizeof(\"SERIALIZER_IGBINARY\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SERIALIZER_IGBINARY_name, &const_SERIALIZER_IGBINARY_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SERIALIZER_IGBINARY_name);\n#endif\n#if defined(HAVE_REDIS_MSGPACK)\n\n\tzval const_SERIALIZER_MSGPACK_value;\n\tZVAL_LONG(&const_SERIALIZER_MSGPACK_value, REDIS_SERIALIZER_MSGPACK);\n\tzend_string *const_SERIALIZER_MSGPACK_name = zend_string_init_interned(\"SERIALIZER_MSGPACK\", sizeof(\"SERIALIZER_MSGPACK\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SERIALIZER_MSGPACK_name, &const_SERIALIZER_MSGPACK_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SERIALIZER_MSGPACK_name);\n#endif\n\n\tzval const_SERIALIZER_JSON_value;\n\tZVAL_LONG(&const_SERIALIZER_JSON_value, REDIS_SERIALIZER_JSON);\n\tzend_string *const_SERIALIZER_JSON_name = zend_string_init_interned(\"SERIALIZER_JSON\", sizeof(\"SERIALIZER_JSON\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SERIALIZER_JSON_name, &const_SERIALIZER_JSON_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SERIALIZER_JSON_name);\n\n\tzval const_COMPRESSION_NONE_value;\n\tZVAL_LONG(&const_COMPRESSION_NONE_value, REDIS_COMPRESSION_NONE);\n\tzend_string *const_COMPRESSION_NONE_name = zend_string_init_interned(\"COMPRESSION_NONE\", sizeof(\"COMPRESSION_NONE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_NONE_name, &const_COMPRESSION_NONE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_NONE_name);\n#if defined(HAVE_REDIS_LZF)\n\n\tzval const_COMPRESSION_LZF_value;\n\tZVAL_LONG(&const_COMPRESSION_LZF_value, REDIS_COMPRESSION_LZF);\n\tzend_string *const_COMPRESSION_LZF_name = zend_string_init_interned(\"COMPRESSION_LZF\", sizeof(\"COMPRESSION_LZF\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_LZF_name, &const_COMPRESSION_LZF_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_LZF_name);\n#endif\n#if defined(HAVE_REDIS_ZSTD)\n\n\tzval const_COMPRESSION_ZSTD_value;\n\tZVAL_LONG(&const_COMPRESSION_ZSTD_value, REDIS_COMPRESSION_ZSTD);\n\tzend_string *const_COMPRESSION_ZSTD_name = zend_string_init_interned(\"COMPRESSION_ZSTD\", sizeof(\"COMPRESSION_ZSTD\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_ZSTD_name, &const_COMPRESSION_ZSTD_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_ZSTD_name);\n#endif\n#if defined(HAVE_REDIS_ZSTD) && defined(ZSTD_CLEVEL_DEFAULT)\n\n\tzval const_COMPRESSION_ZSTD_DEFAULT_value;\n\tZVAL_LONG(&const_COMPRESSION_ZSTD_DEFAULT_value, ZSTD_CLEVEL_DEFAULT);\n\tzend_string *const_COMPRESSION_ZSTD_DEFAULT_name = zend_string_init_interned(\"COMPRESSION_ZSTD_DEFAULT\", sizeof(\"COMPRESSION_ZSTD_DEFAULT\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_ZSTD_DEFAULT_name, &const_COMPRESSION_ZSTD_DEFAULT_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_ZSTD_DEFAULT_name);\n#endif\n#if defined(HAVE_REDIS_ZSTD) && !(defined(ZSTD_CLEVEL_DEFAULT))\n\n\tzval const_COMPRESSION_ZSTD_DEFAULT_value;\n\tZVAL_LONG(&const_COMPRESSION_ZSTD_DEFAULT_value, 3);\n\tzend_string *const_COMPRESSION_ZSTD_DEFAULT_name = zend_string_init_interned(\"COMPRESSION_ZSTD_DEFAULT\", sizeof(\"COMPRESSION_ZSTD_DEFAULT\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_ZSTD_DEFAULT_name, &const_COMPRESSION_ZSTD_DEFAULT_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_ZSTD_DEFAULT_name);\n#endif\n#if defined(HAVE_REDIS_ZSTD) && ZSTD_VERSION_NUMBER >= 10400\n\n\tzval const_COMPRESSION_ZSTD_MIN_value;\n\tZVAL_LONG(&const_COMPRESSION_ZSTD_MIN_value, ZSTD_minCLevel());\n\tzend_string *const_COMPRESSION_ZSTD_MIN_name = zend_string_init_interned(\"COMPRESSION_ZSTD_MIN\", sizeof(\"COMPRESSION_ZSTD_MIN\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_ZSTD_MIN_name, &const_COMPRESSION_ZSTD_MIN_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_ZSTD_MIN_name);\n#endif\n#if defined(HAVE_REDIS_ZSTD) && !(ZSTD_VERSION_NUMBER >= 10400)\n\n\tzval const_COMPRESSION_ZSTD_MIN_value;\n\tZVAL_LONG(&const_COMPRESSION_ZSTD_MIN_value, 1);\n\tzend_string *const_COMPRESSION_ZSTD_MIN_name = zend_string_init_interned(\"COMPRESSION_ZSTD_MIN\", sizeof(\"COMPRESSION_ZSTD_MIN\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_ZSTD_MIN_name, &const_COMPRESSION_ZSTD_MIN_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_ZSTD_MIN_name);\n#endif\n#if defined(HAVE_REDIS_ZSTD)\n\n\tzval const_COMPRESSION_ZSTD_MAX_value;\n\tZVAL_LONG(&const_COMPRESSION_ZSTD_MAX_value, ZSTD_maxCLevel());\n\tzend_string *const_COMPRESSION_ZSTD_MAX_name = zend_string_init_interned(\"COMPRESSION_ZSTD_MAX\", sizeof(\"COMPRESSION_ZSTD_MAX\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_ZSTD_MAX_name, &const_COMPRESSION_ZSTD_MAX_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_ZSTD_MAX_name);\n#endif\n#if defined(HAVE_REDIS_LZ4)\n\n\tzval const_COMPRESSION_LZ4_value;\n\tZVAL_LONG(&const_COMPRESSION_LZ4_value, REDIS_COMPRESSION_LZ4);\n\tzend_string *const_COMPRESSION_LZ4_name = zend_string_init_interned(\"COMPRESSION_LZ4\", sizeof(\"COMPRESSION_LZ4\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_LZ4_name, &const_COMPRESSION_LZ4_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_LZ4_name);\n#endif\n\n\tzval const_OPT_SCAN_value;\n\tZVAL_LONG(&const_OPT_SCAN_value, REDIS_OPT_SCAN);\n\tzend_string *const_OPT_SCAN_name = zend_string_init_interned(\"OPT_SCAN\", sizeof(\"OPT_SCAN\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_SCAN_name, &const_OPT_SCAN_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_SCAN_name);\n\n\tzval const_SCAN_RETRY_value;\n\tZVAL_LONG(&const_SCAN_RETRY_value, REDIS_SCAN_RETRY);\n\tzend_string *const_SCAN_RETRY_name = zend_string_init_interned(\"SCAN_RETRY\", sizeof(\"SCAN_RETRY\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SCAN_RETRY_name, &const_SCAN_RETRY_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SCAN_RETRY_name);\n\n\tzval const_SCAN_NORETRY_value;\n\tZVAL_LONG(&const_SCAN_NORETRY_value, REDIS_SCAN_NORETRY);\n\tzend_string *const_SCAN_NORETRY_name = zend_string_init_interned(\"SCAN_NORETRY\", sizeof(\"SCAN_NORETRY\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SCAN_NORETRY_name, &const_SCAN_NORETRY_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SCAN_NORETRY_name);\n\n\tzval const_SCAN_PREFIX_value;\n\tZVAL_LONG(&const_SCAN_PREFIX_value, REDIS_SCAN_PREFIX);\n\tzend_string *const_SCAN_PREFIX_name = zend_string_init_interned(\"SCAN_PREFIX\", sizeof(\"SCAN_PREFIX\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SCAN_PREFIX_name, &const_SCAN_PREFIX_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SCAN_PREFIX_name);\n\n\tzval const_SCAN_NOPREFIX_value;\n\tZVAL_LONG(&const_SCAN_NOPREFIX_value, REDIS_SCAN_NOPREFIX);\n\tzend_string *const_SCAN_NOPREFIX_name = zend_string_init_interned(\"SCAN_NOPREFIX\", sizeof(\"SCAN_NOPREFIX\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SCAN_NOPREFIX_name, &const_SCAN_NOPREFIX_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SCAN_NOPREFIX_name);\n\n\tzval const_BEFORE_value;\n\tzend_string *const_BEFORE_value_str = zend_string_init(\"before\", strlen(\"before\"), 1);\n\tZVAL_STR(&const_BEFORE_value, const_BEFORE_value_str);\n\tzend_string *const_BEFORE_name = zend_string_init_interned(\"BEFORE\", sizeof(\"BEFORE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BEFORE_name, &const_BEFORE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BEFORE_name);\n\n\tzval const_AFTER_value;\n\tzend_string *const_AFTER_value_str = zend_string_init(\"after\", strlen(\"after\"), 1);\n\tZVAL_STR(&const_AFTER_value, const_AFTER_value_str);\n\tzend_string *const_AFTER_name = zend_string_init_interned(\"AFTER\", sizeof(\"AFTER\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_AFTER_name, &const_AFTER_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_AFTER_name);\n\n\tzval const_LEFT_value;\n\tzend_string *const_LEFT_value_str = zend_string_init(\"left\", strlen(\"left\"), 1);\n\tZVAL_STR(&const_LEFT_value, const_LEFT_value_str);\n\tzend_string *const_LEFT_name = zend_string_init_interned(\"LEFT\", sizeof(\"LEFT\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_LEFT_name, &const_LEFT_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_LEFT_name);\n\n\tzval const_RIGHT_value;\n\tzend_string *const_RIGHT_value_str = zend_string_init(\"right\", strlen(\"right\"), 1);\n\tZVAL_STR(&const_RIGHT_value, const_RIGHT_value_str);\n\tzend_string *const_RIGHT_name = zend_string_init_interned(\"RIGHT\", sizeof(\"RIGHT\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_RIGHT_name, &const_RIGHT_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_RIGHT_name);\n\n\tzval const_OPT_MAX_RETRIES_value;\n\tZVAL_LONG(&const_OPT_MAX_RETRIES_value, REDIS_OPT_MAX_RETRIES);\n\tzend_string *const_OPT_MAX_RETRIES_name = zend_string_init_interned(\"OPT_MAX_RETRIES\", sizeof(\"OPT_MAX_RETRIES\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_MAX_RETRIES_name, &const_OPT_MAX_RETRIES_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_MAX_RETRIES_name);\n\n\tzval const_OPT_BACKOFF_ALGORITHM_value;\n\tZVAL_LONG(&const_OPT_BACKOFF_ALGORITHM_value, REDIS_OPT_BACKOFF_ALGORITHM);\n\tzend_string *const_OPT_BACKOFF_ALGORITHM_name = zend_string_init_interned(\"OPT_BACKOFF_ALGORITHM\", sizeof(\"OPT_BACKOFF_ALGORITHM\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_BACKOFF_ALGORITHM_name, &const_OPT_BACKOFF_ALGORITHM_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_BACKOFF_ALGORITHM_name);\n\n\tzval const_BACKOFF_ALGORITHM_DEFAULT_value;\n\tZVAL_LONG(&const_BACKOFF_ALGORITHM_DEFAULT_value, REDIS_BACKOFF_ALGORITHM_DEFAULT);\n\tzend_string *const_BACKOFF_ALGORITHM_DEFAULT_name = zend_string_init_interned(\"BACKOFF_ALGORITHM_DEFAULT\", sizeof(\"BACKOFF_ALGORITHM_DEFAULT\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BACKOFF_ALGORITHM_DEFAULT_name, &const_BACKOFF_ALGORITHM_DEFAULT_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BACKOFF_ALGORITHM_DEFAULT_name);\n\n\tzval const_BACKOFF_ALGORITHM_CONSTANT_value;\n\tZVAL_LONG(&const_BACKOFF_ALGORITHM_CONSTANT_value, REDIS_BACKOFF_ALGORITHM_CONSTANT);\n\tzend_string *const_BACKOFF_ALGORITHM_CONSTANT_name = zend_string_init_interned(\"BACKOFF_ALGORITHM_CONSTANT\", sizeof(\"BACKOFF_ALGORITHM_CONSTANT\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BACKOFF_ALGORITHM_CONSTANT_name, &const_BACKOFF_ALGORITHM_CONSTANT_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BACKOFF_ALGORITHM_CONSTANT_name);\n\n\tzval const_BACKOFF_ALGORITHM_UNIFORM_value;\n\tZVAL_LONG(&const_BACKOFF_ALGORITHM_UNIFORM_value, REDIS_BACKOFF_ALGORITHM_UNIFORM);\n\tzend_string *const_BACKOFF_ALGORITHM_UNIFORM_name = zend_string_init_interned(\"BACKOFF_ALGORITHM_UNIFORM\", sizeof(\"BACKOFF_ALGORITHM_UNIFORM\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BACKOFF_ALGORITHM_UNIFORM_name, &const_BACKOFF_ALGORITHM_UNIFORM_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BACKOFF_ALGORITHM_UNIFORM_name);\n\n\tzval const_BACKOFF_ALGORITHM_EXPONENTIAL_value;\n\tZVAL_LONG(&const_BACKOFF_ALGORITHM_EXPONENTIAL_value, REDIS_BACKOFF_ALGORITHM_EXPONENTIAL);\n\tzend_string *const_BACKOFF_ALGORITHM_EXPONENTIAL_name = zend_string_init_interned(\"BACKOFF_ALGORITHM_EXPONENTIAL\", sizeof(\"BACKOFF_ALGORITHM_EXPONENTIAL\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BACKOFF_ALGORITHM_EXPONENTIAL_name, &const_BACKOFF_ALGORITHM_EXPONENTIAL_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BACKOFF_ALGORITHM_EXPONENTIAL_name);\n\n\tzval const_BACKOFF_ALGORITHM_FULL_JITTER_value;\n\tZVAL_LONG(&const_BACKOFF_ALGORITHM_FULL_JITTER_value, REDIS_BACKOFF_ALGORITHM_FULL_JITTER);\n\tzend_string *const_BACKOFF_ALGORITHM_FULL_JITTER_name = zend_string_init_interned(\"BACKOFF_ALGORITHM_FULL_JITTER\", sizeof(\"BACKOFF_ALGORITHM_FULL_JITTER\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BACKOFF_ALGORITHM_FULL_JITTER_name, &const_BACKOFF_ALGORITHM_FULL_JITTER_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BACKOFF_ALGORITHM_FULL_JITTER_name);\n\n\tzval const_BACKOFF_ALGORITHM_EQUAL_JITTER_value;\n\tZVAL_LONG(&const_BACKOFF_ALGORITHM_EQUAL_JITTER_value, REDIS_BACKOFF_ALGORITHM_EQUAL_JITTER);\n\tzend_string *const_BACKOFF_ALGORITHM_EQUAL_JITTER_name = zend_string_init_interned(\"BACKOFF_ALGORITHM_EQUAL_JITTER\", sizeof(\"BACKOFF_ALGORITHM_EQUAL_JITTER\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BACKOFF_ALGORITHM_EQUAL_JITTER_name, &const_BACKOFF_ALGORITHM_EQUAL_JITTER_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BACKOFF_ALGORITHM_EQUAL_JITTER_name);\n\n\tzval const_BACKOFF_ALGORITHM_DECORRELATED_JITTER_value;\n\tZVAL_LONG(&const_BACKOFF_ALGORITHM_DECORRELATED_JITTER_value, REDIS_BACKOFF_ALGORITHM_DECORRELATED_JITTER);\n\tzend_string *const_BACKOFF_ALGORITHM_DECORRELATED_JITTER_name = zend_string_init_interned(\"BACKOFF_ALGORITHM_DECORRELATED_JITTER\", sizeof(\"BACKOFF_ALGORITHM_DECORRELATED_JITTER\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BACKOFF_ALGORITHM_DECORRELATED_JITTER_name, &const_BACKOFF_ALGORITHM_DECORRELATED_JITTER_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BACKOFF_ALGORITHM_DECORRELATED_JITTER_name);\n\n\tzval const_OPT_BACKOFF_BASE_value;\n\tZVAL_LONG(&const_OPT_BACKOFF_BASE_value, REDIS_OPT_BACKOFF_BASE);\n\tzend_string *const_OPT_BACKOFF_BASE_name = zend_string_init_interned(\"OPT_BACKOFF_BASE\", sizeof(\"OPT_BACKOFF_BASE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_BACKOFF_BASE_name, &const_OPT_BACKOFF_BASE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_BACKOFF_BASE_name);\n\n\tzval const_OPT_BACKOFF_CAP_value;\n\tZVAL_LONG(&const_OPT_BACKOFF_CAP_value, REDIS_OPT_BACKOFF_CAP);\n\tzend_string *const_OPT_BACKOFF_CAP_name = zend_string_init_interned(\"OPT_BACKOFF_CAP\", sizeof(\"OPT_BACKOFF_CAP\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_BACKOFF_CAP_name, &const_OPT_BACKOFF_CAP_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_BACKOFF_CAP_name);\n#if (PHP_VERSION_ID >= 80000)\n\n\n\tzend_string *attribute_name_SensitiveParameter_func_auth_arg0_0 = zend_string_init_interned(\"SensitiveParameter\", sizeof(\"SensitiveParameter\") - 1, 1);\n\tzend_add_parameter_attribute(zend_hash_str_find_ptr(&class_entry->function_table, \"auth\", sizeof(\"auth\") - 1), 0, attribute_name_SensitiveParameter_func_auth_arg0_0, 0);\n\tzend_string_release(attribute_name_SensitiveParameter_func_auth_arg0_0);\n\n\tzend_string *attribute_name_SensitiveParameter_func_migrate_arg7_0 = zend_string_init_interned(\"SensitiveParameter\", sizeof(\"SensitiveParameter\") - 1, 1);\n\tzend_add_parameter_attribute(zend_hash_str_find_ptr(&class_entry->function_table, \"migrate\", sizeof(\"migrate\") - 1), 7, attribute_name_SensitiveParameter_func_migrate_arg7_0, 0);\n\tzend_string_release(attribute_name_SensitiveParameter_func_migrate_arg7_0);\n#endif\n\n\treturn class_entry;\n}\n\nstatic zend_class_entry *register_class_RedisException(zend_class_entry *class_entry_RuntimeException)\n{\n\tzend_class_entry ce, *class_entry;\n\n\tINIT_CLASS_ENTRY(ce, \"RedisException\", class_RedisException_methods);\n\tclass_entry = zend_register_internal_class_ex(&ce, class_entry_RuntimeException);\n\n\treturn class_entry;\n}\n"
        },
        {
          "name": "redis_array.c",
          "type": "blob",
          "size": 35.818359375,
          "content": "/*\n  +----------------------------------------------------------------------+\n  | Copyright (c) 1997-2009 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt                                  |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Nicolas Favre-Felix <n.favre-felix@owlient.eu>               |\n  | Maintainer: Michael Grunder <michael.grunder@gmail.com>              |\n  +----------------------------------------------------------------------+\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"common.h\"\n#include \"library.h\"\n#include \"redis_array.h\"\n#include \"redis_array_impl.h\"\n\n#include <ext/standard/info.h>\n#include <zend_exceptions.h>\n\n/* Simple macro to detect failure in a RedisArray call */\n#define RA_CALL_FAILED(rv, cmd) ( \\\n    (Z_TYPE_P(rv) == IS_FALSE) || \\\n    (Z_TYPE_P(rv) == IS_ARRAY && zend_hash_num_elements(Z_ARRVAL_P(rv)) == 0) || \\\n    (Z_TYPE_P(rv) == IS_LONG && Z_LVAL_P(rv) == 0 && !strcasecmp(cmd, \"TYPE\")) \\\n)\n\nextern zend_class_entry *redis_ce;\nzend_class_entry *redis_array_ce;\n\n#if PHP_VERSION_ID < 80000\n#include \"redis_array_legacy_arginfo.h\"\n#else\n#include \"zend_attributes.h\"\n#include \"redis_array_arginfo.h\"\n#endif\n\nPHP_MINIT_FUNCTION(redis_array)\n{\n    /* RedisSentinel class */\n    redis_array_ce = register_class_RedisArray();\n    redis_array_ce->create_object = create_redis_array_object;\n\n    return SUCCESS;\n}\n\nstatic void\nredis_array_free(RedisArray *ra)\n{\n    int i;\n\n    /* continuum */\n    if (ra->continuum) {\n        efree(ra->continuum->points);\n        efree(ra->continuum);\n    }\n\n    /* Redis objects */\n    for(i = 0; i< ra->count; i++) {\n        zval_dtor(&ra->redis[i]);\n        zend_string_release(ra->hosts[i]);\n    }\n    efree(ra->redis);\n    efree(ra->hosts);\n\n    /* delete hash function */\n    zval_dtor(&ra->z_fun);\n\n    /* Distributor */\n    zval_dtor(&ra->z_dist);\n\n    /* Hashing algorithm */\n    if (ra->algorithm) zend_string_release(ra->algorithm);\n\n    /* Delete pur commands */\n    zend_hash_destroy(ra->pure_cmds);\n    FREE_HASHTABLE(ra->pure_cmds);\n\n    /* Free structure itself */\n    efree(ra);\n}\n\ntypedef struct {\n    RedisArray *ra;\n    zend_object std;\n} redis_array_object;\n\nzend_object_handlers redis_array_object_handlers;\n\nvoid\nfree_redis_array_object(zend_object *object)\n{\n    redis_array_object *obj = PHPREDIS_GET_OBJECT(redis_array_object, object);\n\n    if (obj->ra) {\n        if (obj->ra->prev) redis_array_free(obj->ra->prev);\n        redis_array_free(obj->ra);\n    }\n    zend_object_std_dtor(&obj->std);\n}\n\nzend_object *\ncreate_redis_array_object(zend_class_entry *ce)\n{\n    redis_array_object *obj = ecalloc(1, sizeof(redis_array_object) + zend_object_properties_size(ce));\n\n    obj->ra = NULL;\n\n    zend_object_std_init(&obj->std, ce);\n    object_properties_init(&obj->std, ce);\n\n    memcpy(&redis_array_object_handlers, zend_get_std_object_handlers(), sizeof(redis_array_object_handlers));\n    redis_array_object_handlers.offset = XtOffsetOf(redis_array_object, std);\n    redis_array_object_handlers.free_obj = free_redis_array_object;\n    obj->std.handlers = &redis_array_object_handlers;\n\n    return &obj->std;\n}\n\n/**\n * redis_array_get\n */\nPHP_REDIS_API RedisArray *\nredis_array_get(zval *id)\n{\n    redis_array_object *obj;\n\n    if (Z_TYPE_P(id) == IS_OBJECT) {\n        obj = PHPREDIS_ZVAL_GET_OBJECT(redis_array_object, id);\n        return obj->ra;\n    }\n    return NULL;\n}\n\n/* {{{ proto RedisArray RedisArray::__construct()\n    Public constructor */\nPHP_METHOD(RedisArray, __construct)\n{\n    zval *z0, z_fun, z_dist, *zpData, *z_opts = NULL;\n    RedisArray *ra = NULL;\n    zend_bool b_index = 0, b_autorehash = 0, b_pconnect = 0, consistent = 0;\n    HashTable *hPrev = NULL, *hOpts = NULL;\n    zend_long l_retry_interval = 0;\n      zend_bool b_lazy_connect = 0;\n    double d_connect_timeout = 0, read_timeout = 0.0;\n    zend_string *algorithm = NULL, *user = NULL, *pass = NULL;\n    redis_array_object *obj;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"z|a\", &z0, &z_opts) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    /* Bail if z0 isn't a string or an array.\n     * Note:  WRONG_PARAM_COUNT seems wrong but this is what we have been doing\n     *        for ages so we can't really change it until the next major version.\n     */\n    if (Z_TYPE_P(z0) != IS_ARRAY && Z_TYPE_P(z0) != IS_STRING) {\n#if PHP_VERSION_ID < 80000\n        WRONG_PARAM_COUNT;\n#else\n        zend_argument_type_error(1, \"must be of type string|array, %s given\", zend_zval_type_name(z0));\n        RETURN_THROWS();\n#endif\n    }\n\n    /* If it's a string we want to load the array from ini information */\n    if (Z_TYPE_P(z0) == IS_STRING) {\n        ra = ra_load_array(Z_STRVAL_P(z0));\n        goto finish;\n    }\n\n    ZVAL_NULL(&z_fun);\n    ZVAL_NULL(&z_dist);\n\n    /* extract options */\n    if(z_opts) {\n        hOpts = Z_ARRVAL_P(z_opts);\n\n        /* extract previous ring. */\n        zpData = REDIS_HASH_STR_FIND_STATIC(hOpts, \"previous\");\n        if (zpData && Z_TYPE_P(zpData) == IS_ARRAY && zend_hash_num_elements(Z_ARRVAL_P(zpData)) > 0) {\n            hPrev = Z_ARRVAL_P(zpData);\n        }\n\n\n        REDIS_CONF_AUTH_STATIC(hOpts, \"auth\", &user, &pass);\n        REDIS_CONF_ZVAL_STATIC(hOpts, \"function\", &z_fun, 1, 0);\n        REDIS_CONF_ZVAL_STATIC(hOpts, \"distributor\", &z_dist, 1, 0);\n        REDIS_CONF_STRING_STATIC(hOpts, \"algorithm\", &algorithm);\n        REDIS_CONF_ZEND_BOOL_STATIC(hOpts, \"index\", &b_index);\n        REDIS_CONF_ZEND_BOOL_STATIC(hOpts, \"autorehash\", &b_autorehash);\n        REDIS_CONF_ZEND_BOOL_STATIC(hOpts, \"pconnect\", &b_pconnect);\n        REDIS_CONF_LONG_STATIC(hOpts, \"retry_interval\", &l_retry_interval);\n        REDIS_CONF_ZEND_BOOL_STATIC(hOpts, \"lazy_connect\", &b_lazy_connect);\n        REDIS_CONF_ZEND_BOOL_STATIC(hOpts, \"consistent\", &consistent);\n        REDIS_CONF_DOUBLE_STATIC(hOpts, \"connect_timeout\", &d_connect_timeout);\n        REDIS_CONF_DOUBLE_STATIC(hOpts, \"read_timeout\", &read_timeout);\n    }\n\n    ra = ra_make_array(Z_ARRVAL_P(z0), &z_fun, &z_dist, hPrev, b_index,\n                       b_pconnect, l_retry_interval, b_lazy_connect,\n                       d_connect_timeout, read_timeout, consistent,\n                       algorithm, user, pass);\n\n    if (algorithm) zend_string_release(algorithm);\n    if (user) zend_string_release(user);\n    if (pass) zend_string_release(pass);\n    zval_dtor(&z_dist);\n    zval_dtor(&z_fun);\n\nfinish:\n\n    if(ra) {\n        ra->auto_rehash = b_autorehash;\n        ra->connect_timeout = d_connect_timeout;\n        if(ra->prev) ra->prev->auto_rehash = b_autorehash;\n        obj = PHPREDIS_ZVAL_GET_OBJECT(redis_array_object, getThis());\n        obj->ra = ra;\n    }\n}\n\nstatic void\nra_forward_call(INTERNAL_FUNCTION_PARAMETERS, RedisArray *ra, const char *cmd,\n                int cmd_len, zval *z_args, zval *z_new_target)\n{\n\n    zval z_fun, *redis_inst, *z_callargs, *zp_tmp;\n    char *key = NULL; /* set to avoid \"unused-but-set-variable\" */\n    int i, key_len = 0, argc;\n    HashTable *h_args;\n    zend_bool b_write_cmd = 0;\n\n    h_args = Z_ARRVAL_P(z_args);\n    if ((argc = zend_hash_num_elements(h_args)) == 0) {\n        RETURN_FALSE;\n    }\n\n    if(ra->z_multi_exec) {\n        redis_inst = ra->z_multi_exec; /* we already have the instance */\n    } else {\n        /* extract key and hash it. */\n        if ((zp_tmp = zend_hash_index_find(h_args, 0)) == NULL || Z_TYPE_P(zp_tmp) != IS_STRING) {\n            php_error_docref(NULL, E_ERROR, \"Could not find key\");\n            RETURN_FALSE;\n        }\n        key = Z_STRVAL_P(zp_tmp);\n        key_len = Z_STRLEN_P(zp_tmp);\n\n        /* find node */\n        redis_inst = ra_find_node(ra, key, key_len, NULL);\n        if(!redis_inst) {\n            php_error_docref(NULL, E_ERROR, \"Could not find any redis servers for this key.\");\n            RETURN_FALSE;\n        }\n    }\n\n    /* pass call through */\n    ZVAL_STRINGL(&z_fun, cmd, cmd_len); /* method name */\n    z_callargs = ecalloc(argc, sizeof(*z_callargs));\n\n    /* copy args to array */\n    i = 0;\n    ZEND_HASH_FOREACH_VAL(h_args, zp_tmp) {\n        ZVAL_ZVAL(&z_callargs[i], zp_tmp, 1, 0);\n        i++;\n    } ZEND_HASH_FOREACH_END();\n\n    /* multi/exec */\n    if(ra->z_multi_exec) {\n        call_user_function(&redis_ce->function_table, ra->z_multi_exec, &z_fun, return_value, argc, z_callargs);\n        zval_dtor(return_value);\n        zval_dtor(&z_fun);\n        for (i = 0; i < argc; ++i) {\n            zval_dtor(&z_callargs[i]);\n        }\n        efree(z_callargs);\n        RETURN_ZVAL(getThis(), 1, 0);\n    }\n\n    /* check if write cmd */\n    b_write_cmd = ra_is_write_cmd(ra, cmd, cmd_len);\n\n    /* CALL! */\n    if(ra->index && b_write_cmd) {\n        /* add MULTI + SADD */\n        ra_index_multi(redis_inst, MULTI);\n        /* call using discarded temp value and extract exec results after. */\n        call_user_function(&redis_ce->function_table, redis_inst, &z_fun, return_value, argc, z_callargs);\n        zval_dtor(return_value);\n\n        /* add keys to index. */\n        ra_index_key(key, key_len, redis_inst);\n\n        /* call EXEC */\n        ra_index_exec(redis_inst, return_value, 0);\n    } else { /* call directly through. */\n        call_user_function(&redis_ce->function_table, redis_inst, &z_fun, return_value, argc, z_callargs);\n\n        if (!b_write_cmd) {\n            /* check if we have an error. */\n            if (ra->prev && RA_CALL_FAILED(return_value, cmd)) { /* there was an error reading, try with prev ring. */\n                /* Free previous return value */\n                zval_dtor(return_value);\n\n                /* ERROR, FALLBACK TO PREVIOUS RING and forward a reference to the first redis instance we were looking at. */\n                ra_forward_call(INTERNAL_FUNCTION_PARAM_PASSTHRU, ra->prev, cmd, cmd_len, z_args, z_new_target ? z_new_target : redis_inst);\n            }\n\n            /* Autorehash if the key was found on the previous node if this is a read command and auto rehashing is on */\n            if (ra->auto_rehash && z_new_target && !RA_CALL_FAILED(return_value, cmd)) { /* move key from old ring to new ring */\n                ra_move_key(key, key_len, redis_inst, z_new_target);\n            }\n        }\n    }\n\n    /* cleanup */\n    zval_dtor(&z_fun);\n    for (i = 0; i < argc; ++i) {\n        zval_dtor(&z_callargs[i]);\n    }\n    efree(z_callargs);\n}\n\nPHP_METHOD(RedisArray, __call)\n{\n    zval *object;\n    RedisArray *ra;\n    zval *z_args;\n\n    char *cmd;\n    size_t cmd_len;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"Osa\",\n                &object, redis_array_ce, &cmd, &cmd_len, &z_args) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    ra_forward_call(INTERNAL_FUNCTION_PARAM_PASSTHRU, ra, cmd, cmd_len, z_args, NULL);\n}\n\nPHP_METHOD(RedisArray, _hosts)\n{\n    zval *object;\n    int i;\n    RedisArray *ra;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O\",\n                &object, redis_array_ce) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    array_init(return_value);\n    for(i = 0; i < ra->count; ++i) {\n        add_next_index_stringl(return_value, ZSTR_VAL(ra->hosts[i]), ZSTR_LEN(ra->hosts[i]));\n    }\n}\n\nPHP_METHOD(RedisArray, _target)\n{\n    zval *object;\n    RedisArray *ra;\n    char *key;\n    size_t key_len;\n    zval *redis_inst;\n    int i;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"Os\",\n                &object, redis_array_ce, &key, &key_len) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    redis_inst = ra_find_node(ra, key, key_len, &i);\n    if(redis_inst) {\n        RETURN_STRINGL(ZSTR_VAL(ra->hosts[i]), ZSTR_LEN(ra->hosts[i]));\n    } else {\n        RETURN_NULL();\n    }\n}\n\nPHP_METHOD(RedisArray, _instance)\n{\n    zval *object;\n    RedisArray *ra;\n    zend_string *host;\n    zval *z_redis;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"OS\",\n                &object, redis_array_ce, &host) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    if ((z_redis = ra_find_node_by_name(ra, host)) == NULL) {\n        RETURN_NULL();\n    }\n    RETURN_ZVAL(z_redis, 1, 0);\n}\n\nPHP_METHOD(RedisArray, _function)\n{\n    zval *object;\n    RedisArray *ra;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O\",\n                &object, redis_array_ce) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    RETURN_ZVAL(&ra->z_fun, 1, 0);\n}\n\nPHP_METHOD(RedisArray, _distributor)\n{\n    zval *object;\n    RedisArray *ra;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O\",\n                &object, redis_array_ce) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    RETURN_ZVAL(&ra->z_dist, 1, 0);\n}\n\nPHP_METHOD(RedisArray, _rehash)\n{\n    zval *object;\n    RedisArray *ra;\n    zend_fcall_info z_cb = {0};\n    zend_fcall_info_cache z_cb_cache = {0};\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O|f\",\n                &object, redis_array_ce, &z_cb, &z_cb_cache) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    if (ZEND_NUM_ARGS() == 0) {\n        ra_rehash(ra, NULL, NULL);\n    } else {\n        ra_rehash(ra, &z_cb, &z_cb_cache);\n    }\n}\n\nPHP_METHOD(RedisArray, _continuum)\n{\n    int i;\n    zval *object, z_ret;\n    RedisArray *ra;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O\",\n                &object, redis_array_ce) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    array_init(return_value);\n    if (ra->continuum) {\n        for (i = 0; i < ra->continuum->nb_points; ++i) {\n            array_init(&z_ret);\n            add_assoc_long(&z_ret, \"index\", ra->continuum->points[i].index);\n            add_assoc_long(&z_ret, \"value\", ra->continuum->points[i].value);\n            add_next_index_zval(return_value, &z_ret);\n        }\n    }\n}\n\n\nstatic void\nmultihost_distribute_call(RedisArray *ra, zval *return_value, zval *z_fun, int argc, zval *argv)\n{\n    zval z_tmp;\n    int i;\n\n    /* Init our array return */\n    array_init(return_value);\n\n    /* Iterate our RedisArray nodes */\n    for (i = 0; i < ra->count; ++i) {\n        /* Call each node in turn */\n        call_user_function(&redis_array_ce->function_table, &ra->redis[i], z_fun, &z_tmp, argc, argv);\n\n        /* Add the result for this host */\n        add_assoc_zval_ex(return_value, ZSTR_VAL(ra->hosts[i]), ZSTR_LEN(ra->hosts[i]), &z_tmp);\n    }\n}\n\nstatic void\nmultihost_distribute(INTERNAL_FUNCTION_PARAMETERS, const char *method_name)\n{\n    zval *object, z_fun;\n    RedisArray *ra;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O\",\n                &object, redis_array_ce) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    /* prepare call */\n    ZVAL_STRING(&z_fun, method_name);\n\n    multihost_distribute_call(ra, return_value, &z_fun, 0, NULL);\n\n    zval_dtor(&z_fun);\n}\n\nstatic void\nmultihost_distribute_flush(INTERNAL_FUNCTION_PARAMETERS, const char *method_name)\n{\n    zval *object, z_fun, z_args[1];\n    zend_bool async = 0;\n    RedisArray *ra;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O|b\",\n                                     &object, redis_array_ce, &async) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    /* prepare call */\n    ZVAL_STRING(&z_fun, method_name);\n    ZVAL_BOOL(&z_args[0], async);\n\n    multihost_distribute_call(ra, return_value, &z_fun, 1, z_args);\n\n    zval_dtor(&z_fun);\n}\n\nPHP_METHOD(RedisArray, info)\n{\n    multihost_distribute(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"INFO\");\n}\n\nPHP_METHOD(RedisArray, ping)\n{\n    multihost_distribute(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"PING\");\n}\n\nPHP_METHOD(RedisArray, flushdb)\n{\n    multihost_distribute_flush(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"FLUSHDB\");\n}\n\nPHP_METHOD(RedisArray, flushall)\n{\n    multihost_distribute_flush(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"FLUSHALL\");\n}\n\nPHP_METHOD(RedisArray, save)\n{\n    multihost_distribute(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"SAVE\");\n}\n\nPHP_METHOD(RedisArray, bgsave)\n{\n    multihost_distribute(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"BGSAVE\");\n}\n\n\nPHP_METHOD(RedisArray, keys)\n{\n    zval *object, z_fun, z_args[1];\n    RedisArray *ra;\n    char *pattern;\n    size_t pattern_len;\n\n    /* Make sure the prototype is correct */\n    if(zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"Os\",\n                                    &object, redis_array_ce, &pattern, &pattern_len) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    /* Make sure we can grab our RedisArray object */\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    /* Set up our function call (KEYS) */\n    ZVAL_STRINGL(&z_fun, \"KEYS\", 4);\n\n    /* We will be passing with one string argument (the pattern) */\n    ZVAL_STRINGL(z_args, pattern, pattern_len);\n\n    multihost_distribute_call(ra, return_value, &z_fun, 1, z_args);\n\n    zval_dtor(&z_args[0]);\n    zval_dtor(&z_fun);\n}\n\nPHP_METHOD(RedisArray, getOption)\n{\n    zval *object, z_fun, z_args[1];\n    RedisArray *ra;\n    zend_long opt;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"Ol\",\n                &object, redis_array_ce, &opt) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    /* prepare call */\n    ZVAL_STRINGL(&z_fun, \"getOption\", 9);\n\n    /* copy arg */\n    ZVAL_LONG(&z_args[0], opt);\n\n    multihost_distribute_call(ra, return_value, &z_fun, 1, z_args);\n\n    zval_dtor(&z_fun);\n}\n\nPHP_METHOD(RedisArray, setOption)\n{\n    zval *object, z_fun, z_args[2];\n    RedisArray *ra;\n    zend_long opt;\n    char *val_str;\n    size_t val_len;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"Ols\",\n                &object, redis_array_ce, &opt, &val_str, &val_len) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    /* prepare call */\n    ZVAL_STRINGL(&z_fun, \"setOption\", 9);\n\n    /* copy args */\n    ZVAL_LONG(&z_args[0], opt);\n    ZVAL_STRINGL(&z_args[1], val_str, val_len);\n\n    multihost_distribute_call(ra, return_value, &z_fun, 2, z_args);\n\n    zval_dtor(&z_args[1]);\n    zval_dtor(&z_fun);\n}\n\nPHP_METHOD(RedisArray, select)\n{\n    zval *object, z_fun, z_args[1];\n    RedisArray *ra;\n    zend_long opt;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"Ol\",\n                &object, redis_array_ce, &opt) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    /* prepare call */\n    ZVAL_STRINGL(&z_fun, \"select\", 6);\n\n    /* copy args */\n    ZVAL_LONG(&z_args[0], opt);\n\n    multihost_distribute_call(ra, return_value, &z_fun, 1, z_args);\n\n    zval_dtor(&z_fun);\n}\n\n#define HANDLE_MULTI_EXEC(ra, cmd, cmdlen) do { \\\n    if (ra && ra->z_multi_exec) { \\\n        int i, num_varargs; \\\n        zval *varargs = NULL, z_arg_array; \\\n        if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O*\", \\\n                                            &object, redis_array_ce, &varargs, &num_varargs) == FAILURE) { \\\n            RETURN_FALSE;\\\n        } \\\n        /* copy all args into a zval hash table */\\\n        array_init(&z_arg_array); \\\n        for (i = 0; i < num_varargs; i++) { \\\n            zval z_tmp; \\\n            ZVAL_ZVAL(&z_tmp, &varargs[i], 1, 0); \\\n            add_next_index_zval(&z_arg_array, &z_tmp); \\\n        } \\\n        /* call */\\\n        ra_forward_call(INTERNAL_FUNCTION_PARAM_PASSTHRU, ra, cmd, cmdlen, &z_arg_array, NULL); \\\n        zval_dtor(&z_arg_array); \\\n        return; \\\n    } \\\n} while(0)\n\n/* MGET will distribute the call to several nodes and regroup the values. */\nPHP_METHOD(RedisArray, mget)\n{\n    zval *object, *z_keys, *data, z_ret, *z_cur, z_tmp_array, z_fun, z_arg, **argv;\n    int i, j, n, *pos, argc, *argc_each;\n    HashTable *h_keys;\n    RedisArray *ra;\n\n    if ((ra = redis_array_get(getThis())) == NULL) {\n        RETURN_FALSE;\n    }\n\n    /* Multi/exec support */\n    HANDLE_MULTI_EXEC(ra, \"MGET\", sizeof(\"MGET\") - 1);\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"Oa\",\n                &object, redis_array_ce, &z_keys) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n\n    /* init data structures */\n    h_keys = Z_ARRVAL_P(z_keys);\n    if ((argc = zend_hash_num_elements(h_keys)) == 0) {\n        RETURN_FALSE;\n    }\n    argv = ecalloc(argc, sizeof(*argv));\n    pos = ecalloc(argc, sizeof(*pos));\n\n    argc_each = ecalloc(ra->count, sizeof(*argc_each));\n\n    /* associate each key to a redis node */\n    i = 0;\n    ZEND_HASH_FOREACH_VAL(h_keys, data) {\n        /* If we need to represent a long key as a string */\n        unsigned int key_len;\n        char kbuf[40], *key_lookup;\n\n        /* Handle the possibility that we're a reference */\n        ZVAL_DEREF(data);\n\n        /* Convert to a string for hash lookup if it isn't one */\n        if (Z_TYPE_P(data) == IS_STRING) {\n            key_len = Z_STRLEN_P(data);\n            key_lookup = Z_STRVAL_P(data);\n        } else if (Z_TYPE_P(data) == IS_LONG) {\n            key_len = snprintf(kbuf, sizeof(kbuf), ZEND_LONG_FMT, Z_LVAL_P(data));\n            key_lookup = (char*)kbuf;\n        } else {\n            /* phpredis proper can only use string or long keys, so restrict to that here */\n            php_error_docref(NULL, E_ERROR, \"MGET: all keys must be strings or longs\");\n            RETVAL_FALSE;\n            goto cleanup;\n        }\n\n        /* Find our node */\n        if (ra_find_node(ra, key_lookup, key_len, &pos[i]) == NULL) {\n            RETVAL_FALSE;\n            goto cleanup;\n        }\n\n        argc_each[pos[i]]++;    /* count number of keys per node */\n        argv[i++] = data;\n    } ZEND_HASH_FOREACH_END();\n\n    /* prepare call */\n    array_init(&z_tmp_array);\n    ZVAL_STRINGL(&z_fun, \"MGET\", sizeof(\"MGET\") - 1);\n\n    /* calls */\n    for(n = 0; n < ra->count; ++n) { /* for each node */\n        /* We don't even need to make a call to this node if no keys go there */\n        if(!argc_each[n]) continue;\n\n        /* copy args for MGET call on node. */\n        array_init(&z_arg);\n\n        for(i = 0; i < argc; ++i) {\n            if (pos[i] == n) {\n                ZVAL_ZVAL(&z_ret, argv[i], 1, 0);\n                add_next_index_zval(&z_arg, &z_ret);\n            }\n        }\n\n        /* call MGET on the node */\n        call_user_function(&redis_ce->function_table, &ra->redis[n], &z_fun, &z_ret, 1, &z_arg);\n\n        /* cleanup args array */\n        zval_dtor(&z_arg);\n\n        /* Error out if we didn't get a proper response */\n        if (Z_TYPE(z_ret) != IS_ARRAY) {\n            /* cleanup */\n            zval_dtor(&z_ret);\n            zval_dtor(&z_tmp_array);\n            RETVAL_FALSE;\n            goto cleanup;\n        }\n\n        for(i = 0, j = 0; i < argc; ++i) {\n            if (pos[i] != n || (z_cur = zend_hash_index_find(Z_ARRVAL(z_ret), j++)) == NULL) continue;\n\n            ZVAL_ZVAL(&z_arg, z_cur, 1, 0);\n            add_index_zval(&z_tmp_array, i, &z_arg);\n        }\n        zval_dtor(&z_ret);\n    }\n\n    zval_dtor(&z_fun);\n\n    array_init(return_value);\n    /* copy temp array in the right order to return_value */\n    for(i = 0; i < argc; ++i) {\n        if ((z_cur = zend_hash_index_find(Z_ARRVAL(z_tmp_array), i)) == NULL) continue;\n\n        ZVAL_ZVAL(&z_arg, z_cur, 1, 0);\n        add_next_index_zval(return_value, &z_arg);\n    }\n\n    /* cleanup */\n    zval_dtor(&z_tmp_array);\ncleanup:\n    efree(argv);\n    efree(pos);\n    efree(argc_each);\n}\n\n\n/* MSET will distribute the call to several nodes and regroup the values. */\nPHP_METHOD(RedisArray, mset)\n{\n    zval *object, *z_keys, z_argarray, *data, z_fun, z_ret, **argv;\n    int i = 0, n, *pos, argc, *argc_each, key_len;\n    RedisArray *ra;\n    HashTable *h_keys;\n    char *key, kbuf[40];\n    zend_string **keys, *zkey;\n    zend_ulong idx;\n\n    if ((ra = redis_array_get(getThis())) == NULL) {\n        RETURN_FALSE;\n    }\n\n    /* Multi/exec support */\n    HANDLE_MULTI_EXEC(ra, \"MSET\", sizeof(\"MSET\") - 1);\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"Oa\",\n                                     &object, redis_array_ce, &z_keys) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    /* init data structures */\n    h_keys = Z_ARRVAL_P(z_keys);\n    if ((argc = zend_hash_num_elements(h_keys)) == 0) {\n        RETURN_FALSE;\n    }\n    argv = ecalloc(argc, sizeof(*argv));\n    pos = ecalloc(argc, sizeof(*pos));\n    keys = ecalloc(argc, sizeof(*keys));\n\n    argc_each = ecalloc(ra->count, sizeof(*argc_each));\n\n    /* associate each key to a redis node */\n    ZEND_HASH_FOREACH_KEY_VAL(h_keys, idx, zkey, data) {\n        /* If the key isn't a string, make a string representation of it */\n        if (zkey) {\n            key_len = ZSTR_LEN(zkey);\n            key = ZSTR_VAL(zkey);\n        } else {\n            key_len = snprintf(kbuf, sizeof(kbuf), ZEND_ULONG_FMT, idx);\n            key = kbuf;\n        }\n\n        if (ra_find_node(ra, key, (int)key_len, &pos[i]) == NULL) {\n            for (n = 0; n < i; ++n) {\n                zend_string_release(keys[n]);\n            }\n            efree(keys);\n            efree(argv);\n            efree(pos);\n            efree(argc_each);\n            RETURN_FALSE;\n        }\n\n        argc_each[pos[i]]++;    /* count number of keys per node */\n        keys[i] = zkey ? zend_string_copy(zkey) : zend_string_init(key, key_len, 0);\n        argv[i] = data;\n        i++;\n    } ZEND_HASH_FOREACH_END();\n\n\n    /* prepare call */\n    ZVAL_STRINGL(&z_fun, \"MSET\", sizeof(\"MSET\") - 1);\n\n    /* calls */\n    for (n = 0; n < ra->count; ++n) { /* for each node */\n        /* We don't even need to make a call to this node if no keys go there */\n        if(!argc_each[n]) continue;\n\n        int found = 0;\n\n        /* copy args */\n        array_init(&z_argarray);\n        for(i = 0; i < argc; ++i) {\n            if(pos[i] != n) continue;\n\n            if (argv[i] == NULL) {\n                ZVAL_NULL(&z_ret);\n            } else {\n                ZVAL_ZVAL(&z_ret, argv[i], 1, 0);\n            }\n            add_assoc_zval_ex(&z_argarray, ZSTR_VAL(keys[i]), ZSTR_LEN(keys[i]), &z_ret);\n            found++;\n        }\n\n        if(!found) {\n            zval_dtor(&z_argarray);\n            continue; /* don't run empty MSETs */\n        }\n\n        if(ra->index) { /* add MULTI */\n            ra_index_multi(&ra->redis[n], MULTI);\n            call_user_function(&redis_ce->function_table, &ra->redis[n], &z_fun, &z_ret, 1, &z_argarray);\n            ra_index_keys(&z_argarray, &ra->redis[n]); /* use SADD to add keys to node index */\n            ra_index_exec(&ra->redis[n], NULL, 0); /* run EXEC */\n        } else {\n            call_user_function(&redis_ce->function_table, &ra->redis[n], &z_fun, &z_ret, 1, &z_argarray);\n        }\n\n        zval_dtor(&z_argarray);\n        zval_dtor(&z_ret);\n    }\n\n    zval_dtor(&z_fun);\n\n    /* Free any keys that we needed to allocate memory for, because they weren't strings */\n    for(i = 0; i < argc; i++) {\n        zend_string_release(keys[i]);\n    }\n\n    /* cleanup */\n    efree(keys);\n    efree(argv);\n    efree(pos);\n    efree(argc_each);\n\n    RETURN_TRUE;\n}\n\n/* Generic handler for DEL or UNLINK which behave identically to phpredis */\nstatic void\nra_generic_del(INTERNAL_FUNCTION_PARAMETERS, char *kw, int kw_len)\n{\n    zval *object, z_keys, z_fun, *data, z_ret, *z_args, **argv;\n    int i, n, *pos, argc = ZEND_NUM_ARGS(), *argc_each, free_zkeys = 0;\n    HashTable *h_keys;\n    RedisArray *ra;\n    long total = 0;\n\n    if ((ra = redis_array_get(getThis())) == NULL) {\n        RETURN_FALSE;\n    }\n\n    /* Multi/exec support */\n    HANDLE_MULTI_EXEC(ra, kw, kw_len);\n\n    /* get all args in z_args */\n    z_args = ecalloc(argc, sizeof(*z_args));\n    if (zend_get_parameters_array(ht, argc, z_args) == FAILURE) {\n        efree(z_args);\n        RETURN_FALSE;\n    }\n\n    /* if single array arg, point z_keys to it. */\n    if (argc == 1 && Z_TYPE(z_args[0]) == IS_ARRAY) {\n        z_keys = z_args[0];\n    } else {\n        /* copy all elements to z_keys */\n        array_init(&z_keys);\n        for (i = 0; i < argc; ++i) {\n            ZVAL_ZVAL(&z_ret, &z_args[i], 1, 0);\n            add_next_index_zval(&z_keys, &z_ret);\n        }\n        free_zkeys = 1;\n    }\n\n    /* init data structures */\n    h_keys = Z_ARRVAL(z_keys);\n    if ((argc = zend_hash_num_elements(h_keys)) == 0) {\n        if (free_zkeys) zval_dtor(&z_keys);\n        efree(z_args);\n        RETURN_FALSE;\n    }\n    argv = ecalloc(argc, sizeof(*argv));\n    pos = ecalloc(argc, sizeof(*pos));\n\n    argc_each = ecalloc(ra->count, sizeof(*argc_each));\n\n    /* associate each key to a redis node */\n    i = 0;\n    ZEND_HASH_FOREACH_VAL(h_keys, data) {\n        if (Z_TYPE_P(data) != IS_STRING) {\n            php_error_docref(NULL, E_ERROR, \"DEL: all keys must be string.\");\n            RETVAL_FALSE;\n            goto cleanup;\n        }\n\n        if (ra_find_node(ra, Z_STRVAL_P(data), Z_STRLEN_P(data), &pos[i]) == NULL) {\n            RETVAL_FALSE;\n            goto cleanup;\n        }\n        argc_each[pos[i]]++;    /* count number of keys per node */\n        argv[i++] = data;\n    } ZEND_HASH_FOREACH_END();\n\n    /* prepare call */\n    ZVAL_STRINGL(&z_fun, kw, kw_len);\n\n    /* calls */\n    for(n = 0; n < ra->count; ++n) { /* for each node */\n        /* We don't even need to make a call to this node if no keys go there */\n        if(!argc_each[n]) continue;\n\n        int found = 0;\n        zval z_argarray;\n\n        /* copy args */\n        array_init(&z_argarray);\n        for(i = 0; i < argc; ++i) {\n            if (pos[i] == n) {\n                ZVAL_ZVAL(&z_ret, argv[i], 1, 0);\n                add_next_index_zval(&z_argarray, &z_ret);\n                found++;\n            }\n        }\n\n        if(!found) {    /* don't run empty DEL or UNLINK commands */\n            zval_dtor(&z_argarray);\n            continue;\n        }\n\n        if(ra->index) { /* add MULTI */\n            ra_index_multi(&ra->redis[n], MULTI);\n            call_user_function(&redis_ce->function_table, &ra->redis[n], &z_fun, &z_ret, 1, &z_argarray);\n            ra_index_del(&z_argarray, &ra->redis[n]); /* use SREM to remove keys from node index */\n            ra_index_exec(&ra->redis[n], &z_ret, 0); /* run EXEC */\n        } else {\n            call_user_function(&redis_ce->function_table, &ra->redis[n], &z_fun, &z_ret, 1, &z_argarray);\n        }\n        total += Z_LVAL(z_ret);    /* increment total */\n\n        zval_dtor(&z_argarray);\n        zval_dtor(&z_ret);\n    }\n\n    zval_dtor(&z_fun);\n\n    RETVAL_LONG(total);\n\ncleanup:\n    efree(argv);\n    efree(pos);\n    efree(argc_each);\n\n    if(free_zkeys) {\n        zval_dtor(&z_keys);\n    }\n    efree(z_args);\n}\n\n/* DEL will distribute the call to several nodes and regroup the values. */\nPHP_METHOD(RedisArray, del)\n{\n    ra_generic_del(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"DEL\", sizeof(\"DEL\")-1);\n}\n\nPHP_METHOD(RedisArray, unlink) {\n    ra_generic_del(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"UNLINK\", sizeof(\"UNLINK\") - 1);\n}\n\nstatic void\nra_generic_scan_cmd(INTERNAL_FUNCTION_PARAMETERS, const char *kw, int kw_len)\n{\n    RedisArray *ra;\n    zend_string *key, *pattern = NULL;\n    zval *object, *redis_inst, *z_cursor, z_fun, z_args[4];\n    zend_long count = 0;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"OSz/|S!l\",\n            &object, redis_array_ce, &key, &z_cursor, &pattern, &count) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    if ((redis_inst = ra_find_node(ra, ZSTR_VAL(key), ZSTR_LEN(key), NULL)) == NULL) {\n        php_error_docref(NULL, E_ERROR, \"Could not find any redis servers for this key.\");\n        RETURN_FALSE;\n    }\n\n    ZVAL_STR(&z_args[0], key);\n    ZVAL_NEW_REF(&z_args[1], z_cursor);\n    if (pattern) ZVAL_STR(&z_args[2], pattern);\n    ZVAL_LONG(&z_args[3], count);\n\n    ZVAL_STRINGL(&z_fun, kw, kw_len);\n    call_user_function(&redis_ce->function_table, redis_inst, &z_fun, return_value, ZEND_NUM_ARGS(), z_args);\n    zval_dtor(&z_fun);\n\n    ZVAL_ZVAL(z_cursor, &z_args[1], 0, 1);\n}\n\nPHP_METHOD(RedisArray, hscan)\n{\n    ra_generic_scan_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"HSCAN\", sizeof(\"HSCAN\") - 1);\n}\n\nPHP_METHOD(RedisArray, sscan)\n{\n    ra_generic_scan_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"SSCAN\", sizeof(\"SSCAN\") - 1);\n}\n\nPHP_METHOD(RedisArray, zscan)\n{\n    ra_generic_scan_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"ZSCAN\", sizeof(\"ZSCAN\") - 1);\n}\n\nPHP_METHOD(RedisArray, scan)\n{\n    RedisArray *ra;\n    zend_string *host, *pattern = NULL;\n    zval *object, *redis_inst, *z_iter, z_fun, z_args[3];\n    zend_long count = 0;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"Oz/S|S!l\",\n            &object, redis_array_ce, &z_iter, &host, &pattern, &count) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    if ((redis_inst = ra_find_node_by_name(ra, host)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    ZVAL_NEW_REF(&z_args[0], z_iter);\n    if (pattern) ZVAL_STR(&z_args[1], pattern);\n    ZVAL_LONG(&z_args[2], count);\n\n    ZVAL_STRING(&z_fun, \"SCAN\");\n    call_user_function(&redis_ce->function_table, redis_inst, &z_fun, return_value, ZEND_NUM_ARGS() - 1, z_args);\n    zval_dtor(&z_fun);\n\n    ZVAL_ZVAL(z_iter, &z_args[0], 0, 1);\n}\n\nPHP_METHOD(RedisArray, multi)\n{\n    zval *object;\n    RedisArray *ra;\n    zval *z_redis;\n    zend_string *host;\n    zend_long multi_value = MULTI;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"OS|l\",\n                &object, redis_array_ce, &host, &multi_value) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    /* find node */\n    if ((z_redis = ra_find_node_by_name(ra, host)) == NULL) {\n        RETURN_FALSE;\n    }\n\n    if(multi_value != MULTI && multi_value != PIPELINE) {\n        RETURN_FALSE;\n    }\n\n    /* save multi object */\n    ra->z_multi_exec = z_redis;\n\n    /* switch redis instance to multi/exec mode. */\n    ra_index_multi(z_redis, multi_value);\n\n    /* return this. */\n    RETURN_ZVAL(object, 1, 0);\n}\n\nPHP_METHOD(RedisArray, exec)\n{\n    zval *object;\n    RedisArray *ra;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O\",\n                &object, redis_array_ce) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL || !ra->z_multi_exec) {\n        RETURN_FALSE;\n    }\n\n    /* switch redis instance out of multi/exec mode. */\n    ra_index_exec(ra->z_multi_exec, return_value, 1);\n\n    /* remove multi object */\n    ra->z_multi_exec = NULL;\n}\n\nPHP_METHOD(RedisArray, discard)\n{\n    zval *object;\n    RedisArray *ra;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O\",\n                &object, redis_array_ce) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL || !ra->z_multi_exec) {\n        RETURN_FALSE;\n    }\n\n    /* switch redis instance out of multi/exec mode. */\n    ra_index_discard(ra->z_multi_exec, return_value);\n\n    /* remove multi object */\n    ra->z_multi_exec = NULL;\n}\n\nPHP_METHOD(RedisArray, unwatch)\n{\n    zval *object;\n    RedisArray *ra;\n\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), \"O\",\n                &object, redis_array_ce) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if ((ra = redis_array_get(object)) == NULL || !ra->z_multi_exec) {\n        RETURN_FALSE;\n    }\n\n    /* unwatch keys, stay in multi/exec mode. */\n    ra_index_unwatch(ra->z_multi_exec, return_value);\n}\n"
        },
        {
          "name": "redis_array.h",
          "type": "blob",
          "size": 1.2724609375,
          "content": "#ifndef REDIS_ARRAY_H\n#define REDIS_ARRAY_H\n\n#if (defined(_MSC_VER) && _MSC_VER <= 1920)\n#include \"win32/php_stdint.h\"\n#else\n#include <stdint.h>\n#endif\n#include \"common.h\"\n\ntypedef struct {\n    uint32_t value;\n    int index;\n} ContinuumPoint;\n\ntypedef struct {\n    size_t nb_points;\n    ContinuumPoint *points;\n} Continuum;\n\ntypedef struct RedisArray_ {\n    int count;\n    zend_string **hosts;    /* array of host:port strings */\n    zval *redis;            /* array of Redis instances */\n    zval *z_multi_exec;     /* Redis instance to be used in multi-exec */\n    zend_bool index;        /* use per-node index */\n    zend_bool auto_rehash;  /* migrate keys on read operations */\n    zend_bool pconnect;     /* should we use pconnect */\n    zval z_fun;             /* key extractor, callable */\n    zval z_dist;            /* key distributor, callable */\n    zend_string *algorithm; /* key hashing algorithm name */\n    HashTable *pure_cmds;   /* hash table */\n    double connect_timeout; /* socket connect timeout */\n    double read_timeout;    /* socket read timeout */\n    Continuum *continuum;\n    struct RedisArray_ *prev;\n} RedisArray;\n\nextern zend_class_entry *redis_array_ce;\nextern PHP_MINIT_FUNCTION(redis_array);\nextern zend_object *create_redis_array_object(zend_class_entry *ce);\n\n#endif\n"
        },
        {
          "name": "redis_array.stub.php",
          "type": "blob",
          "size": 2.05078125,
          "content": "<?php\n\n/**\n * @generate-function-entries\n * @generate-legacy-arginfo\n * @generate-class-entries\n */\n\nclass RedisArray {\n\n    public function __call(string $function_name, array $arguments): mixed;\n\n    public function __construct(string|array $name_or_hosts, ?array $options = null);\n\n    public function _continuum(): bool|array;\n\n    public function _distributor(): bool|callable;\n\n    public function _function(): bool|callable;\n\n    public function _hosts(): bool|array;\n\n    public function _instance(string $host): bool|null|Redis;\n\n    public function _rehash(?callable $fn = null): bool|null;\n\n    public function _target(string $key): bool|string|null;\n\n    public function bgsave(): array;\n\n    public function del(string|array $key, string ...$otherkeys): bool|int;\n\n    public function discard(): bool|null;\n\n    public function exec(): bool|null|array;\n\n    public function flushall(): bool|array;\n\n    public function flushdb(): bool|array;\n\n    public function getOption(int $opt): bool|array;\n\n    public function hscan(string $key, null|int|string &$iterator, ?string $pattern = null, int $count = 0): bool|array;\n\n    public function info(): bool|array;\n\n    public function keys(string $pattern): bool|array;\n\n    public function mget(array $keys): bool|array;\n\n    public function mset(array $pairs): bool;\n\n    public function multi(string $host, ?int $mode = null): bool|RedisArray;\n\n    public function ping(): bool|array;\n\n    public function save(): bool|array;\n\n    public function scan(null|int|string &$iterator, string $node, ?string $pattern = null, int $count = 0): bool|array;\n\n    public function select(int $index): bool|array;\n\n    public function setOption(int $opt, string $value): bool|array;\n\n    public function sscan(string $key, null|int|string &$iterator, ?string $pattern = null, int $count = 0): bool|array;\n\n    public function unlink(string|array $key, string ...$otherkeys): bool|int;\n\n    public function unwatch(): bool|null;\n\n    public function zscan(string $key, null|int|string &$iterator, ?string $pattern = null, int $count = 0): bool|array;\n}\n"
        },
        {
          "name": "redis_array_arginfo.h",
          "type": "blob",
          "size": 8.4873046875,
          "content": "/* This is a generated file, edit the .stub.php file instead.\n * Stub hash: ddb92422452cb767a7d6694aa8ac60d883db6672 */\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisArray___call, 0, 2, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, function_name, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, arguments, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray___construct, 0, 0, 1)\n\tZEND_ARG_TYPE_MASK(0, name_or_hosts, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisArray__continuum, 0, 0, MAY_BE_BOOL|MAY_BE_ARRAY)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisArray__distributor, 0, 0, MAY_BE_BOOL|MAY_BE_CALLABLE)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisArray__function arginfo_class_RedisArray__distributor\n\n#define arginfo_class_RedisArray__hosts arginfo_class_RedisArray__continuum\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisArray__instance, 0, 1, Redis, MAY_BE_BOOL|MAY_BE_NULL)\n\tZEND_ARG_TYPE_INFO(0, host, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisArray__rehash, 0, 0, _IS_BOOL, 1)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, fn, IS_CALLABLE, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisArray__target, 0, 1, MAY_BE_BOOL|MAY_BE_STRING|MAY_BE_NULL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisArray_bgsave, 0, 0, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisArray_del, 0, 1, MAY_BE_BOOL|MAY_BE_LONG)\n\tZEND_ARG_TYPE_MASK(0, key, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, otherkeys, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisArray_discard, 0, 0, _IS_BOOL, 1)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisArray_exec, 0, 0, MAY_BE_BOOL|MAY_BE_NULL|MAY_BE_ARRAY)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisArray_flushall arginfo_class_RedisArray__continuum\n\n#define arginfo_class_RedisArray_flushdb arginfo_class_RedisArray__continuum\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisArray_getOption, 0, 1, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, opt, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisArray_hscan, 0, 2, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(1, iterator, MAY_BE_NULL|MAY_BE_LONG|MAY_BE_STRING, NULL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, pattern, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisArray_info arginfo_class_RedisArray__continuum\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisArray_keys, 0, 1, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, pattern, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisArray_mget, 0, 1, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisArray_mset, 0, 1, _IS_BOOL, 0)\n\tZEND_ARG_TYPE_INFO(0, pairs, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisArray_multi, 0, 1, RedisArray, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, host, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, mode, IS_LONG, 1, \"null\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisArray_ping arginfo_class_RedisArray__continuum\n\n#define arginfo_class_RedisArray_save arginfo_class_RedisArray__continuum\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisArray_scan, 0, 2, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_MASK(1, iterator, MAY_BE_NULL|MAY_BE_LONG|MAY_BE_STRING, NULL)\n\tZEND_ARG_TYPE_INFO(0, node, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, pattern, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisArray_select, 0, 1, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, index, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisArray_setOption, 0, 2, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, opt, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisArray_sscan arginfo_class_RedisArray_hscan\n\n#define arginfo_class_RedisArray_unlink arginfo_class_RedisArray_del\n\n#define arginfo_class_RedisArray_unwatch arginfo_class_RedisArray_discard\n\n#define arginfo_class_RedisArray_zscan arginfo_class_RedisArray_hscan\n\n\nZEND_METHOD(RedisArray, __call);\nZEND_METHOD(RedisArray, __construct);\nZEND_METHOD(RedisArray, _continuum);\nZEND_METHOD(RedisArray, _distributor);\nZEND_METHOD(RedisArray, _function);\nZEND_METHOD(RedisArray, _hosts);\nZEND_METHOD(RedisArray, _instance);\nZEND_METHOD(RedisArray, _rehash);\nZEND_METHOD(RedisArray, _target);\nZEND_METHOD(RedisArray, bgsave);\nZEND_METHOD(RedisArray, del);\nZEND_METHOD(RedisArray, discard);\nZEND_METHOD(RedisArray, exec);\nZEND_METHOD(RedisArray, flushall);\nZEND_METHOD(RedisArray, flushdb);\nZEND_METHOD(RedisArray, getOption);\nZEND_METHOD(RedisArray, hscan);\nZEND_METHOD(RedisArray, info);\nZEND_METHOD(RedisArray, keys);\nZEND_METHOD(RedisArray, mget);\nZEND_METHOD(RedisArray, mset);\nZEND_METHOD(RedisArray, multi);\nZEND_METHOD(RedisArray, ping);\nZEND_METHOD(RedisArray, save);\nZEND_METHOD(RedisArray, scan);\nZEND_METHOD(RedisArray, select);\nZEND_METHOD(RedisArray, setOption);\nZEND_METHOD(RedisArray, sscan);\nZEND_METHOD(RedisArray, unlink);\nZEND_METHOD(RedisArray, unwatch);\nZEND_METHOD(RedisArray, zscan);\n\n\nstatic const zend_function_entry class_RedisArray_methods[] = {\n\tZEND_ME(RedisArray, __call, arginfo_class_RedisArray___call, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, __construct, arginfo_class_RedisArray___construct, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, _continuum, arginfo_class_RedisArray__continuum, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, _distributor, arginfo_class_RedisArray__distributor, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, _function, arginfo_class_RedisArray__function, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, _hosts, arginfo_class_RedisArray__hosts, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, _instance, arginfo_class_RedisArray__instance, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, _rehash, arginfo_class_RedisArray__rehash, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, _target, arginfo_class_RedisArray__target, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, bgsave, arginfo_class_RedisArray_bgsave, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, del, arginfo_class_RedisArray_del, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, discard, arginfo_class_RedisArray_discard, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, exec, arginfo_class_RedisArray_exec, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, flushall, arginfo_class_RedisArray_flushall, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, flushdb, arginfo_class_RedisArray_flushdb, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, getOption, arginfo_class_RedisArray_getOption, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, hscan, arginfo_class_RedisArray_hscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, info, arginfo_class_RedisArray_info, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, keys, arginfo_class_RedisArray_keys, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, mget, arginfo_class_RedisArray_mget, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, mset, arginfo_class_RedisArray_mset, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, multi, arginfo_class_RedisArray_multi, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, ping, arginfo_class_RedisArray_ping, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, save, arginfo_class_RedisArray_save, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, scan, arginfo_class_RedisArray_scan, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, select, arginfo_class_RedisArray_select, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, setOption, arginfo_class_RedisArray_setOption, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, sscan, arginfo_class_RedisArray_sscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, unlink, arginfo_class_RedisArray_unlink, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, unwatch, arginfo_class_RedisArray_unwatch, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, zscan, arginfo_class_RedisArray_zscan, ZEND_ACC_PUBLIC)\n\tZEND_FE_END\n};\n\nstatic zend_class_entry *register_class_RedisArray(void)\n{\n\tzend_class_entry ce, *class_entry;\n\n\tINIT_CLASS_ENTRY(ce, \"RedisArray\", class_RedisArray_methods);\n\tclass_entry = zend_register_internal_class_ex(&ce, NULL);\n\n\treturn class_entry;\n}\n"
        },
        {
          "name": "redis_array_impl.c",
          "type": "blob",
          "size": 35.55078125,
          "content": "/*\n  +----------------------------------------------------------------------+\n  | Copyright (c) 1997-2009 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt                                  |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Nicolas Favre-Felix <n.favre-felix@owlient.eu>               |\n  | Maintainer: Michael Grunder <michael.grunder@gmail.com>              |\n  +----------------------------------------------------------------------+\n*/\n#include \"redis_array_impl.h\"\n#include \"php_redis.h\"\n#include \"library.h\"\n\n#include \"php_variables.h\"\n#include \"SAPI.h\"\n#include \"ext/standard/url.h\"\n#include \"ext/standard/crc32.h\"\n#include \"ext/standard/md5.h\"\n\n#include \"ext/hash/php_hash.h\"\n\n#define PHPREDIS_INDEX_NAME \"__phpredis_array_index__\"\n\nextern zend_class_entry *redis_ce;\n\nstatic RedisArray *\nra_load_hosts(RedisArray *ra, HashTable *hosts, zend_string *user,\n              zend_string *pass, long retry_interval, zend_bool b_lazy_connect)\n{\n    int i = 0, host_len;\n    char *host, *p;\n    short port;\n    zval *zpData;\n    redis_object *redis;\n\n    /* init connections */\n    ZEND_HASH_FOREACH_VAL(hosts, zpData) {\n        if (Z_TYPE_P(zpData) != IS_STRING) {\n            return NULL;\n        }\n\n        /* default values */\n        host = Z_STRVAL_P(zpData);\n        host_len = Z_STRLEN_P(zpData);\n        ra->hosts[i] = zend_string_init(host, host_len, 0);\n        port = 6379;\n\n        if((p = strrchr(host, ':'))) { /* found port */\n            host_len = p - host;\n            port = (short)atoi(p+1);\n        } else if(strchr(host,'/') != NULL) { /* unix socket */\n            port = -1;\n        }\n\n        /* create Redis object */\n        object_init_ex(&ra->redis[i], redis_ce);\n        redis = PHPREDIS_ZVAL_GET_OBJECT(redis_object, &ra->redis[i]);\n\n        /* create socket */\n        redis->sock = redis_sock_create(host, host_len, port, ra->connect_timeout,\n                                        ra->read_timeout, ra->pconnect, NULL,\n                                        retry_interval);\n\n        redis_sock_set_auth(redis->sock, user, pass);\n\n        if (!b_lazy_connect) {\n            if (redis_sock_server_open(redis->sock) < 0) {\n                ra->count = ++i;\n                return NULL;\n            }\n        }\n\n        ra->count = ++i;\n    } ZEND_HASH_FOREACH_END();\n\n    return ra;\n}\n\n/* List pure functions */\nvoid\nra_init_function_table(RedisArray *ra)\n{\n    ALLOC_HASHTABLE(ra->pure_cmds);\n    zend_hash_init(ra->pure_cmds, 0, NULL, NULL, 0);\n\n    #define ra_add_pure_cmd(cmd) \\\n        zend_hash_str_update_ptr(ra->pure_cmds, cmd, sizeof(cmd) - 1, NULL);\n\n    ra_add_pure_cmd(\"EXISTS\");\n    ra_add_pure_cmd(\"GET\");\n    ra_add_pure_cmd(\"GETBIT\");\n    ra_add_pure_cmd(\"GETRANGE\");\n    ra_add_pure_cmd(\"HEXISTS\");\n    ra_add_pure_cmd(\"HGET\");\n    ra_add_pure_cmd(\"HGETALL\");\n    ra_add_pure_cmd(\"HKEYS\");\n    ra_add_pure_cmd(\"HLEN\");\n    ra_add_pure_cmd(\"HMGET\");\n    ra_add_pure_cmd(\"HVALS\");\n    ra_add_pure_cmd(\"LINDEX\");\n    ra_add_pure_cmd(\"LLEN\");\n    ra_add_pure_cmd(\"LRANGE\");\n    ra_add_pure_cmd(\"OBJECT\");\n    ra_add_pure_cmd(\"SCARD\");\n    ra_add_pure_cmd(\"SDIFF\");\n    ra_add_pure_cmd(\"SINTER\");\n    ra_add_pure_cmd(\"SISMEMBER\");\n    ra_add_pure_cmd(\"SMEMBERS\");\n    ra_add_pure_cmd(\"SRANDMEMBER\");\n    ra_add_pure_cmd(\"STRLEN\");\n    ra_add_pure_cmd(\"SUNION\");\n    ra_add_pure_cmd(\"TYPE\");\n    ra_add_pure_cmd(\"ZCARD\");\n    ra_add_pure_cmd(\"ZCOUNT\");\n    ra_add_pure_cmd(\"ZRANGE\");\n    ra_add_pure_cmd(\"ZRANK\");\n    ra_add_pure_cmd(\"ZREVRANGE\");\n    ra_add_pure_cmd(\"ZREVRANGEBYSCORE\");\n    ra_add_pure_cmd(\"ZREVRANK\");\n    ra_add_pure_cmd(\"ZSCORE\");\n\n    #undef ra_add_pure_cmd\n}\n\nstatic int\nra_find_name(const char *name) {\n\n    const char *ini_names, *p, *next;\n    /* php_printf(\"Loading redis array with name=[%s]\\n\", name); */\n\n    ini_names = INI_STR(\"redis.arrays.names\");\n    for(p = ini_names; p;) {\n        next = strchr(p, ',');\n        if(next) {\n            if(redis_strncmp(p, name, next - p) == 0) {\n                return 1;\n            }\n        } else {\n            if(strcmp(p, name) == 0) {\n                return 1;\n            }\n            break;\n        }\n        p = next + 1;\n    }\n\n    return 0;\n}\n\n/* load array from INI settings */\nRedisArray *ra_load_array(const char *name) {\n    zval *z_data, z_tmp, z_fun, z_dist;\n    zval z_params_hosts;\n    zval z_params_prev;\n    RedisArray *ra = NULL;\n\n    zend_string *algorithm = NULL, *user = NULL, *pass = NULL;\n    zend_bool b_index = 0, b_autorehash = 0, b_pconnect = 0, consistent = 0;\n    zend_long l_retry_interval = 0;\n    zend_bool b_lazy_connect = 0;\n    double d_connect_timeout = 0, read_timeout = 0.0;\n    HashTable *hHosts = NULL, *hPrev = NULL;\n    size_t name_len = strlen(name);\n    char *iptr;\n\n    /* find entry */\n    if(!ra_find_name(name))\n        return ra;\n\n    ZVAL_NULL(&z_fun);\n    ZVAL_NULL(&z_dist);\n\n    /* find hosts */\n    array_init(&z_params_hosts);\n    if ((iptr = INI_STR(\"redis.arrays.hosts\")) != NULL) {\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_params_hosts);\n        if ((z_data = zend_hash_str_find(Z_ARRVAL(z_params_hosts), name, name_len)) != NULL) {\n            hHosts = Z_ARRVAL_P(z_data);\n        }\n    }\n\n    /* find previous hosts */\n    array_init(&z_params_prev);\n    if ((iptr = INI_STR(\"redis.arrays.previous\")) != NULL) {\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_params_prev);\n        if ((z_data = zend_hash_str_find(Z_ARRVAL(z_params_prev), name, name_len)) != NULL) {\n            if (Z_TYPE_P(z_data) == IS_ARRAY) {\n                hPrev = Z_ARRVAL_P(z_data);\n            }\n        }\n    }\n\n    /* find function */\n    if ((iptr = INI_STR(\"redis.arrays.functions\")) != NULL) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        redis_conf_zval(Z_ARRVAL(z_tmp), name, name_len, &z_fun, 1, 0);\n        zval_dtor(&z_tmp);\n    }\n\n    /* find distributor */\n    if ((iptr = INI_STR(\"redis.arrays.distributor\")) != NULL) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        redis_conf_zval(Z_ARRVAL(z_tmp), name, name_len, &z_dist, 1, 0);\n        zval_dtor(&z_tmp);\n    }\n\n    /* find hash algorithm */\n    if ((iptr = INI_STR(\"redis.arrays.algorithm\")) != NULL) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        redis_conf_string(Z_ARRVAL(z_tmp), name, name_len, &algorithm);\n        zval_dtor(&z_tmp);\n    }\n\n    /* find index option */\n    if ((iptr = INI_STR(\"redis.arrays.index\")) != NULL) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        redis_conf_zend_bool(Z_ARRVAL(z_tmp), name, name_len, &b_index);\n        zval_dtor(&z_tmp);\n    }\n\n    /* find autorehash option */\n    if ((iptr = INI_STR(\"redis.arrays.autorehash\")) != NULL) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        redis_conf_zend_bool(Z_ARRVAL(z_tmp), name, name_len, &b_autorehash);\n        zval_dtor(&z_tmp);\n    }\n\n    /* find retry interval option */\n    if ((iptr = INI_STR(\"redis.arrays.retryinterval\")) != NULL) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        redis_conf_long(Z_ARRVAL(z_tmp), name, name_len, &l_retry_interval);\n        zval_dtor(&z_tmp);\n    }\n\n    /* find pconnect option */\n    if ((iptr = INI_STR(\"redis.arrays.pconnect\")) != NULL) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        redis_conf_zend_bool(Z_ARRVAL(z_tmp), name, name_len, &b_pconnect);\n        zval_dtor(&z_tmp);\n    }\n\n    /* find lazy connect option */\n    if ((iptr = INI_STR(\"redis.arrays.lazyconnect\")) != NULL) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        redis_conf_zend_bool(Z_ARRVAL(z_tmp), name, name_len, &b_lazy_connect);\n        zval_dtor(&z_tmp);\n    }\n\n    /* find connect timeout option */\n    if ((iptr = INI_STR(\"redis.arrays.connecttimeout\")) != NULL) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        redis_conf_double(Z_ARRVAL(z_tmp), name, name_len, &d_connect_timeout);\n        zval_dtor(&z_tmp);\n    }\n\n    /* find read timeout option */\n    if ((iptr = INI_STR(\"redis.arrays.readtimeout\")) != NULL) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        redis_conf_double(Z_ARRVAL(z_tmp), name, name_len, &read_timeout);\n        zval_dtor(&z_tmp);\n    }\n\n    /* find consistent option */\n    if ((iptr = INI_STR(\"redis.arrays.consistent\")) != NULL) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        if ((z_data = zend_hash_str_find(Z_ARRVAL(z_tmp), name, name_len)) != NULL) {\n            consistent = Z_TYPE_P(z_data) == IS_STRING &&\n                         redis_strncmp(Z_STRVAL_P(z_data), ZEND_STRL(\"1\")) == 0;\n        }\n        zval_dtor(&z_tmp);\n    }\n\n    /* find auth option */\n    if ((iptr = INI_STR(\"redis.arrays.auth\")) != NULL) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        redis_conf_auth(Z_ARRVAL(z_tmp), name, name_len, &user, &pass);\n        zval_dtor(&z_tmp);\n    }\n\n    /* create RedisArray object */\n    ra = ra_make_array(hHosts, &z_fun, &z_dist, hPrev, b_index, b_pconnect, l_retry_interval,\n                       b_lazy_connect, d_connect_timeout, read_timeout, consistent, algorithm,\n                       user, pass);\n    if (ra) {\n        ra->auto_rehash = b_autorehash;\n        if(ra->prev) ra->prev->auto_rehash = b_autorehash;\n    }\n\n    if (algorithm) zend_string_release(algorithm);\n    if (user) zend_string_release(user);\n    if (pass) zend_string_release(pass);\n\n    zval_dtor(&z_params_hosts);\n    zval_dtor(&z_params_prev);\n    zval_dtor(&z_dist);\n    zval_dtor(&z_fun);\n\n    return ra;\n}\n\nstatic int\nra_points_cmp(const void *v1, const void *v2)\n{\n    const ContinuumPoint *p1 = v1, *p2 = v2;\n\n    return p1->value < p2->value ? - 1 : p1->value > p2->value;\n}\n\nstatic Continuum *\nra_make_continuum(zend_string **hosts, int nb_hosts)\n{\n    int i, j, k, len, idx = 0;\n    char host[HOST_NAME_MAX];\n    unsigned char digest[16];\n    PHP_MD5_CTX ctx;\n    Continuum *c;\n\n    c = ecalloc(1, sizeof(*c));\n    c->nb_points = nb_hosts * 160; /* 40 hashes, 4 numbers per hash = 160 points per server */\n    c->points = ecalloc(c->nb_points, sizeof(*c->points));\n\n    for (i = 0; i < nb_hosts; ++i) {\n        for (j = 0; j < 40; ++j) {\n            len = snprintf(host, sizeof(host), \"%.*s-%u\", (int)ZSTR_LEN(hosts[i]), ZSTR_VAL(hosts[i]), j);\n            PHP_MD5Init(&ctx);\n            PHP_MD5Update(&ctx, host, len);\n            PHP_MD5Final(digest, &ctx);\n            for (k = 0; k < 4; ++k) {\n                c->points[idx].index = i;\n                c->points[idx++].value = (digest[3 + k * 4] << 24)\n                    | (digest[2 + k * 4] << 16)\n                    | (digest[1 + k * 4] << 8)\n                    | (digest[k * 4]);\n            }\n        }\n    }\n    qsort(c->points, c->nb_points, sizeof(*c->points), ra_points_cmp);\n    return c;\n}\n\nRedisArray *\nra_make_array(HashTable *hosts, zval *z_fun, zval *z_dist, HashTable *hosts_prev,\n              zend_bool b_index, zend_bool b_pconnect, long retry_interval,\n              zend_bool b_lazy_connect, double connect_timeout, double read_timeout,\n              zend_bool consistent, zend_string *algorithm, zend_string *user,\n              zend_string *pass)\n{\n    int i, count;\n    RedisArray *ra;\n\n    if (!hosts || (count = zend_hash_num_elements(hosts)) == 0) return NULL;\n\n    /* create object */\n    ra = emalloc(sizeof(RedisArray));\n    ra->hosts = ecalloc(count, sizeof(*ra->hosts));\n    ra->redis = ecalloc(count, sizeof(*ra->redis));\n    ra->count = 0;\n    ra->z_multi_exec = NULL;\n    ra->index = b_index;\n    ra->auto_rehash = 0;\n    ra->pconnect = b_pconnect;\n    ra->connect_timeout = connect_timeout;\n    ra->read_timeout = read_timeout;\n    ra->continuum = NULL;\n    ra->algorithm = NULL;\n\n    if (ra_load_hosts(ra, hosts, user, pass, retry_interval, b_lazy_connect) == NULL || !ra->count) {\n        for (i = 0; i < ra->count; ++i) {\n            zval_dtor(&ra->redis[i]);\n            zend_string_release(ra->hosts[i]);\n        }\n        efree(ra->redis);\n        efree(ra->hosts);\n        efree(ra);\n        return NULL;\n    }\n\n    ra->prev = hosts_prev ? ra_make_array(hosts_prev, z_fun, z_dist, NULL, b_index, b_pconnect, retry_interval, b_lazy_connect, connect_timeout, read_timeout, consistent, algorithm, user, pass) : NULL;\n\n    /* init array data structures */\n    ra_init_function_table(ra);\n\n    /* Set hash function and distribtor if provided */\n    ZVAL_ZVAL(&ra->z_fun, z_fun, 1, 0);\n    ZVAL_ZVAL(&ra->z_dist, z_dist, 1, 0);\n    if (algorithm) ra->algorithm = zend_string_copy(algorithm);\n\n    /* init continuum */\n    if (consistent) {\n        ra->continuum = ra_make_continuum(ra->hosts, ra->count);\n    }\n\n    return ra;\n}\n\n\n/* call userland key extraction function */\nzend_string *\nra_call_extractor(RedisArray *ra, const char *key, int key_len)\n{\n    zend_string *out = NULL;\n    zval z_ret, z_argv;\n\n    /* check that we can call the extractor function */\n    if (!zend_is_callable_ex(&ra->z_fun, NULL, 0, NULL, NULL, NULL)) {\n        php_error_docref(NULL, E_ERROR, \"Could not call extractor function\");\n        return NULL;\n    }\n\n    ZVAL_NULL(&z_ret);\n    /* call extraction function */\n    ZVAL_STRINGL(&z_argv, key, key_len);\n    call_user_function(EG(function_table), NULL, &ra->z_fun, &z_ret, 1, &z_argv);\n\n    if (Z_TYPE(z_ret) == IS_STRING) {\n        out = zval_get_string(&z_ret);\n    }\n\n    zval_dtor(&z_argv);\n    zval_dtor(&z_ret);\n    return out;\n}\n\nstatic zend_string *\nra_extract_key(RedisArray *ra, const char *key, int key_len)\n{\n    char *start, *end;\n\n    if (Z_TYPE(ra->z_fun) != IS_NULL) {\n        return ra_call_extractor(ra, key, key_len);\n    } else if ((start = strchr(key, '{')) == NULL || (end = strchr(start + 1, '}')) == NULL) {\n        return zend_string_init(key, key_len, 0);\n    }\n    /* found substring */\n    return zend_string_init(start + 1, end - start - 1, 0);\n}\n\n/* call userland key distributor function */\nint\nra_call_distributor(RedisArray *ra, const char *key, int key_len)\n{\n    int ret;\n    zval z_ret, z_argv;\n\n    /* check that we can call the extractor function */\n    if (!zend_is_callable_ex(&ra->z_dist, NULL, 0, NULL, NULL, NULL)) {\n        php_error_docref(NULL, E_ERROR, \"Could not call distributor function\");\n        return -1;\n    }\n\n    ZVAL_NULL(&z_ret);\n    /* call extraction function */\n    ZVAL_STRINGL(&z_argv, key, key_len);\n    call_user_function(EG(function_table), NULL, &ra->z_dist, &z_ret, 1, &z_argv);\n\n    ret = (Z_TYPE(z_ret) == IS_LONG) ? Z_LVAL(z_ret) : -1;\n\n    zval_dtor(&z_argv);\n    zval_dtor(&z_ret);\n    return ret;\n}\n\nzval *\nra_find_node(RedisArray *ra, const char *key, int key_len, int *out_pos)\n{\n    int pos;\n    zend_string *out;\n\n    /* extract relevant part of the key */\n    if ((out = ra_extract_key(ra, key, key_len)) == NULL) {\n        return NULL;\n    }\n\n    if (Z_TYPE(ra->z_dist) == IS_NULL) {\n        int i;\n        unsigned long ret = 0xffffffff;\n        const php_hash_ops *ops;\n\n        /* hash */\n        if (ra->algorithm && (ops = redis_hash_fetch_ops(ra->algorithm))) {\n            void *ctx = emalloc(ops->context_size);\n            unsigned char *digest = emalloc(ops->digest_size);\n\n#if PHP_VERSION_ID >= 80100\n            ops->hash_init(ctx,NULL);\n#else\n            ops->hash_init(ctx);\n#endif\n            ops->hash_update(ctx, (const unsigned char *)ZSTR_VAL(out), ZSTR_LEN(out));\n            ops->hash_final(digest, ctx);\n\n            memcpy(&ret, digest, MIN(sizeof(ret), ops->digest_size));\n            ret %= 0xffffffff;\n\n            efree(digest);\n            efree(ctx);\n        } else {\n            for (i = 0; i < ZSTR_LEN(out); ++i) {\n                CRC32(ret, ZSTR_VAL(out)[i]);\n            }\n        }\n\n        /* get position on ring */\n        if (ra->continuum) {\n            int left = 0, right = ra->continuum->nb_points;\n            while (left < right) {\n                i = (int)((left + right) / 2);\n                if (ra->continuum->points[i].value < ret) {\n                    left = i + 1;\n                } else {\n                    right = i;\n                }\n            }\n            if (right == ra->continuum->nb_points) {\n                right = 0;\n            }\n            pos = ra->continuum->points[right].index;\n        } else {\n            pos = (int)((ret ^ 0xffffffff) * ra->count / 0xffffffff);\n        }\n    } else {\n        pos = ra_call_distributor(ra, key, key_len);\n        if (pos < 0 || pos >= ra->count) {\n            zend_string_release(out);\n            return NULL;\n        }\n    }\n    zend_string_release(out);\n\n    if(out_pos) *out_pos = pos;\n\n    return &ra->redis[pos];\n}\n\nzval *\nra_find_node_by_name(RedisArray *ra, zend_string *host) {\n\n    int i;\n    for(i = 0; i < ra->count; ++i) {\n        if (zend_string_equals(host, ra->hosts[i])) {\n            return &ra->redis[i];\n        }\n    }\n    return NULL;\n}\n\nvoid\nra_index_multi(zval *z_redis, long multi_value) {\n\n    zval z_fun_multi, z_ret;\n    zval z_args[1];\n\n    /* run MULTI */\n    ZVAL_STRINGL(&z_fun_multi, \"MULTI\", 5);\n    ZVAL_LONG(&z_args[0], multi_value);\n    call_user_function(&redis_ce->function_table, z_redis, &z_fun_multi, &z_ret, 1, z_args);\n    zval_dtor(&z_fun_multi);\n    zval_dtor(&z_ret);\n}\n\nstatic void\nra_index_change_keys(const char *cmd, zval *z_keys, zval *z_redis) {\n\n    int i, argc;\n    zval z_fun, z_ret, *z_args;\n\n    /* alloc */\n    argc = 1 + zend_hash_num_elements(Z_ARRVAL_P(z_keys));\n    z_args = ecalloc(argc, sizeof(zval));\n\n    /* prepare first parameters */\n    ZVAL_STRING(&z_fun, cmd);\n    ZVAL_STRINGL(&z_args[0], PHPREDIS_INDEX_NAME, sizeof(PHPREDIS_INDEX_NAME) - 1);\n\n    /* prepare keys */\n    for(i = 0; i < argc - 1; ++i) {\n        zval *zv = zend_hash_index_find(Z_ARRVAL_P(z_keys), i);\n        if (zv == NULL) {\n            ZVAL_NULL(&z_args[i+1]);\n        } else {\n            z_args[i+1] = *zv;\n        }\n    }\n\n    /* run cmd */\n    call_user_function(&redis_ce->function_table, z_redis, &z_fun, &z_ret, argc, z_args);\n\n    zval_dtor(&z_args[0]);\n    zval_dtor(&z_fun);\n    zval_dtor(&z_ret);\n    efree(z_args);      /* free container */\n}\n\nvoid\nra_index_del(zval *z_keys, zval *z_redis) {\n    ra_index_change_keys(\"SREM\", z_keys, z_redis);\n}\n\nvoid\nra_index_keys(zval *z_pairs, zval *z_redis) {\n\n    zval z_keys, *z_val;\n    zend_string *zkey;\n    zend_ulong idx;\n\n    /* Initialize key array */\n    array_init_size(&z_keys, zend_hash_num_elements(Z_ARRVAL_P(z_pairs)));\n\n    /* Go through input array and add values to the key array */\n    ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL_P(z_pairs), idx, zkey, z_val) {\n        zval z_new;\n\n        PHPREDIS_NOTUSED(z_val);\n\n        if (zkey) {\n            ZVAL_STRINGL(&z_new, ZSTR_VAL(zkey), ZSTR_LEN(zkey));\n        } else {\n            ZVAL_LONG(&z_new, idx);\n        }\n        zend_hash_next_index_insert(Z_ARRVAL(z_keys), &z_new);\n    } ZEND_HASH_FOREACH_END();\n\n    /* add keys to index */\n    ra_index_change_keys(\"SADD\", &z_keys, z_redis);\n\n    /* cleanup */\n    zval_dtor(&z_keys);\n}\n\nvoid\nra_index_key(const char *key, int key_len, zval *z_redis) {\n\n    zval z_fun_sadd, z_ret, z_args[2];\n\n    /* prepare args */\n    ZVAL_STRINGL(&z_fun_sadd, \"SADD\", 4);\n\n    ZVAL_STRINGL(&z_args[0], PHPREDIS_INDEX_NAME, sizeof(PHPREDIS_INDEX_NAME) - 1);\n    ZVAL_STRINGL(&z_args[1], key, key_len);\n\n    /* run SADD */\n    call_user_function(&redis_ce->function_table, z_redis, &z_fun_sadd, &z_ret, 2, z_args);\n    zval_dtor(&z_fun_sadd);\n    zval_dtor(&z_args[1]);\n    zval_dtor(&z_args[0]);\n    zval_dtor(&z_ret);\n}\n\nvoid\nra_index_exec(zval *z_redis, zval *return_value, int keep_all) {\n\n    zval z_fun_exec, z_ret, *zp_tmp;\n\n    /* run EXEC */\n    ZVAL_STRINGL(&z_fun_exec, \"EXEC\", 4);\n    call_user_function(&redis_ce->function_table, z_redis, &z_fun_exec, &z_ret, 0, NULL);\n    zval_dtor(&z_fun_exec);\n\n    /* extract first element of exec array and put into return_value. */\n    if(Z_TYPE(z_ret) == IS_ARRAY) {\n        if(return_value) {\n                if(keep_all) {\n                    zp_tmp = &z_ret;\n                    RETVAL_ZVAL(zp_tmp, 1, 0);\n                } else if ((zp_tmp = zend_hash_index_find(Z_ARRVAL(z_ret), 0)) != NULL) {\n                    RETVAL_ZVAL(zp_tmp, 1, 0);\n                }\n        }\n    }\n    zval_dtor(&z_ret);\n\n    /* zval *zptr = &z_ret; */\n    /* php_var_dump(&zptr, 0); */\n}\n\nvoid\nra_index_discard(zval *z_redis, zval *return_value) {\n\n    zval z_fun_discard, z_ret;\n\n    /* run DISCARD */\n    ZVAL_STRINGL(&z_fun_discard, \"DISCARD\", 7);\n    call_user_function(&redis_ce->function_table, z_redis, &z_fun_discard, &z_ret, 0, NULL);\n\n    zval_dtor(&z_fun_discard);\n    zval_dtor(&z_ret);\n}\n\nvoid\nra_index_unwatch(zval *z_redis, zval *return_value) {\n\n    zval z_fun_unwatch, z_ret;\n\n    /* run UNWATCH */\n    ZVAL_STRINGL(&z_fun_unwatch, \"UNWATCH\", 7);\n    call_user_function(&redis_ce->function_table, z_redis, &z_fun_unwatch, &z_ret, 0, NULL);\n\n    zval_dtor(&z_fun_unwatch);\n    zval_dtor(&z_ret);\n}\n\nzend_bool\nra_is_write_cmd(RedisArray *ra, const char *cmd, int cmd_len) {\n\n    zend_bool ret;\n    int i;\n    char *cmd_up = emalloc(1 + cmd_len);\n    /* convert to uppercase */\n    for(i = 0; i < cmd_len; ++i)\n        cmd_up[i] = toupper(cmd[i]);\n    cmd_up[cmd_len] = 0;\n\n    ret = zend_hash_str_exists(ra->pure_cmds, cmd_up, cmd_len);\n\n    efree(cmd_up);\n    return !ret;\n}\n\n/* run TYPE to find the type */\nstatic zend_bool\nra_get_key_type(zval *z_redis, const char *key, int key_len, zval *z_from, long *res) {\n\n    int i = 0;\n    zval z_fun, z_ret, z_arg, *z_data;\n    long success = 1;\n\n    /* Pipelined */\n    ra_index_multi(z_from, PIPELINE);\n\n    /* prepare args */\n    ZVAL_STRINGL(&z_arg, key, key_len);\n\n    /* run TYPE */\n    ZVAL_NULL(&z_ret);\n    ZVAL_STRINGL(&z_fun, \"TYPE\", 4);\n    call_user_function(&redis_ce->function_table, z_redis, &z_fun, &z_ret, 1, &z_arg);\n    zval_dtor(&z_fun);\n    zval_dtor(&z_ret);\n\n    /* run TYPE */\n    ZVAL_NULL(&z_ret);\n    ZVAL_STRINGL(&z_fun, \"TTL\", 3);\n    call_user_function(&redis_ce->function_table, z_redis, &z_fun, &z_ret, 1, &z_arg);\n    zval_dtor(&z_fun);\n    zval_dtor(&z_ret);\n\n    /* Get the result from the pipeline. */\n    ra_index_exec(z_from, &z_ret, 1);\n    if (Z_TYPE(z_ret) == IS_ARRAY) {\n        ZEND_HASH_FOREACH_VAL(Z_ARRVAL(z_ret), z_data) {\n            if (z_data == NULL || Z_TYPE_P(z_data) != IS_LONG) {\n                success = 0;\n                break;\n            }\n            /* Get the result - Might change in the future to handle doubles as well */\n            res[i++] = Z_LVAL_P(z_data);\n        } ZEND_HASH_FOREACH_END();\n    }\n    zval_dtor(&z_arg);\n    zval_dtor(&z_ret);\n    return success;\n}\n\n/* delete key from source server index during rehashing */\nstatic void\nra_remove_from_index(zval *z_redis, const char *key, int key_len) {\n\n    zval z_fun_srem, z_ret, z_args[2];\n\n    /* run SREM on source index */\n    ZVAL_STRINGL(&z_fun_srem, \"SREM\", 4);\n    ZVAL_STRINGL(&z_args[0], PHPREDIS_INDEX_NAME, sizeof(PHPREDIS_INDEX_NAME) - 1);\n    ZVAL_STRINGL(&z_args[1], key, key_len);\n\n    call_user_function(&redis_ce->function_table, z_redis, &z_fun_srem, &z_ret, 2, z_args);\n\n    /* cleanup */\n    zval_dtor(&z_fun_srem);\n    zval_dtor(&z_args[1]);\n    zval_dtor(&z_args[0]);\n    zval_dtor(&z_ret);\n}\n\n\n/* delete key from source server during rehashing */\nstatic zend_bool\nra_del_key(const char *key, int key_len, zval *z_from) {\n\n    zval z_fun_del, z_ret, z_args[1];\n\n    /* in a transaction */\n    ra_index_multi(z_from, MULTI);\n\n    /* run DEL on source */\n    ZVAL_STRINGL(&z_fun_del, \"DEL\", 3);\n    ZVAL_STRINGL(&z_args[0], key, key_len);\n    call_user_function(&redis_ce->function_table, z_from, &z_fun_del, &z_ret, 1, z_args);\n    zval_dtor(&z_fun_del);\n    zval_dtor(&z_args[0]);\n    zval_dtor(&z_ret);\n\n    /* remove key from index */\n    ra_remove_from_index(z_from, key, key_len);\n\n    /* close transaction */\n    ra_index_exec(z_from, NULL, 0);\n\n    return 1;\n}\n\nstatic zend_bool\nra_expire_key(const char *key, int key_len, zval *z_to, long ttl) {\n\n    zval z_fun_expire, z_ret, z_args[2];\n\n    if (ttl > 0)\n    {\n        /* run EXPIRE on target */\n        ZVAL_STRINGL(&z_fun_expire, \"EXPIRE\", 6);\n        ZVAL_STRINGL(&z_args[0], key, key_len);\n        ZVAL_LONG(&z_args[1], ttl);\n        call_user_function(&redis_ce->function_table, z_to, &z_fun_expire, &z_ret, 2, z_args);\n        zval_dtor(&z_fun_expire);\n        zval_dtor(&z_args[0]);\n        zval_dtor(&z_ret);\n    }\n\n    return 1;\n}\n\nstatic zend_bool\nra_move_zset(const char *key, int key_len, zval *z_from, zval *z_to, long ttl) {\n\n    zval z_fun_zrange, z_fun_zadd, z_ret, z_ret_dest, z_args[4], *z_zadd_args, *z_score_p;\n    int i, count;\n    HashTable *h_zset_vals;\n    zend_string *zkey;\n    zend_ulong idx;\n\n    /* run ZRANGE key 0 -1 WITHSCORES on source */\n    ZVAL_STRINGL(&z_fun_zrange, \"ZRANGE\", 6);\n    ZVAL_STRINGL(&z_args[0], key, key_len);\n    ZVAL_STRINGL(&z_args[1], \"0\", 1);\n    ZVAL_STRINGL(&z_args[2], \"-1\", 2);\n    ZVAL_BOOL(&z_args[3], 1);\n    call_user_function(&redis_ce->function_table, z_from, &z_fun_zrange, &z_ret, 4, z_args);\n    zval_dtor(&z_fun_zrange);\n    zval_dtor(&z_args[2]);\n    zval_dtor(&z_args[1]);\n    zval_dtor(&z_args[0]);\n\n\n    if(Z_TYPE(z_ret) != IS_ARRAY) { /* key not found or replaced */\n        /* TODO: report? */\n        zval_dtor(&z_ret);\n        return 0;\n    }\n\n    /* we now have an array of value ‚Üí score pairs in z_ret. */\n    h_zset_vals = Z_ARRVAL(z_ret);\n\n    /* allocate argument array for ZADD */\n    count = zend_hash_num_elements(h_zset_vals);\n    z_zadd_args = ecalloc((1 + 2*count), sizeof(zval));\n\n    ZVAL_STRINGL(&z_zadd_args[0], key, key_len);\n\n    i = 1;\n    ZEND_HASH_FOREACH_KEY_VAL(h_zset_vals, idx, zkey, z_score_p) {\n        /* add score */\n        ZVAL_DOUBLE(&z_zadd_args[i], Z_DVAL_P(z_score_p));\n\n        /* add value */\n        if (zkey) {\n            ZVAL_STRINGL(&z_zadd_args[i+1], ZSTR_VAL(zkey), ZSTR_LEN(zkey));\n        } else {\n            ZVAL_LONG(&z_zadd_args[i+1], (long)idx);\n        }\n        i += 2;\n    } ZEND_HASH_FOREACH_END();\n\n    /* run ZADD on target */\n    ZVAL_STRINGL(&z_fun_zadd, \"ZADD\", 4);\n    call_user_function(&redis_ce->function_table, z_to, &z_fun_zadd, &z_ret_dest, 1 + 2 * count, z_zadd_args);\n\n    /* Expire if needed */\n    ra_expire_key(key, key_len, z_to, ttl);\n\n    /* cleanup */\n    zval_dtor(&z_fun_zadd);\n    zval_dtor(&z_ret_dest);\n    zval_dtor(&z_ret);\n\n    /* Free the array itself */\n    for (i = 0; i < 1 + 2 * count; i++) {\n        zval_dtor(&z_zadd_args[i]);\n    }\n    efree(z_zadd_args);\n\n    return 1;\n}\n\nstatic zend_bool\nra_move_string(const char *key, int key_len, zval *z_from, zval *z_to, long ttl) {\n\n    zval z_fun_get, z_fun_set, z_ret, z_args[3];\n\n    /* run GET on source */\n    ZVAL_STRINGL(&z_fun_get, \"GET\", 3);\n    ZVAL_STRINGL(&z_args[0], key, key_len);\n    call_user_function(&redis_ce->function_table, z_from, &z_fun_get, &z_ret, 1, z_args);\n    zval_dtor(&z_fun_get);\n\n    if(Z_TYPE(z_ret) != IS_STRING) { /* key not found or replaced */\n        /* TODO: report? */\n        zval_dtor(&z_args[0]);\n        zval_dtor(&z_ret);\n        return 0;\n    }\n\n    /* run SET on target */\n    if (ttl > 0) {\n        ZVAL_STRINGL(&z_fun_set, \"SETEX\", 5);\n        ZVAL_LONG(&z_args[1], ttl);\n        ZVAL_STRINGL(&z_args[2], Z_STRVAL(z_ret), Z_STRLEN(z_ret)); /* copy z_ret to arg 1 */\n        zval_dtor(&z_ret); /* free memory from our previous call */\n        call_user_function(&redis_ce->function_table, z_to, &z_fun_set, &z_ret, 3, z_args);\n        /* cleanup */\n        zval_dtor(&z_args[2]);\n    } else {\n        ZVAL_STRINGL(&z_fun_set, \"SET\", 3);\n        ZVAL_STRINGL(&z_args[1], Z_STRVAL(z_ret), Z_STRLEN(z_ret)); /* copy z_ret to arg 1 */\n        zval_dtor(&z_ret); /* free memory from our previous return value */\n        call_user_function(&redis_ce->function_table, z_to, &z_fun_set, &z_ret, 2, z_args);\n        /* cleanup */\n        zval_dtor(&z_args[1]);\n    }\n    zval_dtor(&z_fun_set);\n    zval_dtor(&z_args[0]);\n    zval_dtor(&z_ret);\n\n    return 1;\n}\n\nstatic zend_bool\nra_move_hash(const char *key, int key_len, zval *z_from, zval *z_to, long ttl) {\n    zval z_fun_hgetall, z_fun_hmset, z_ret_dest, z_args[2];\n\n    /* run HGETALL on source */\n    ZVAL_STRINGL(&z_args[0], key, key_len);\n    ZVAL_STRINGL(&z_fun_hgetall, \"HGETALL\", 7);\n    call_user_function(&redis_ce->function_table, z_from, &z_fun_hgetall, &z_args[1], 1, z_args);\n    zval_dtor(&z_fun_hgetall);\n\n    if (Z_TYPE(z_args[1]) != IS_ARRAY) { /* key not found or replaced */\n        /* TODO: report? */\n        zval_dtor(&z_args[1]);\n        zval_dtor(&z_args[0]);\n        return 0;\n    }\n\n    /* run HMSET on target */\n    ZVAL_STRINGL(&z_fun_hmset, \"HMSET\", 5);\n    call_user_function(&redis_ce->function_table, z_to, &z_fun_hmset, &z_ret_dest, 2, z_args);\n    zval_dtor(&z_fun_hmset);\n    zval_dtor(&z_ret_dest);\n\n    /* Expire if needed */\n    ra_expire_key(key, key_len, z_to, ttl);\n\n    /* cleanup */\n    zval_dtor(&z_args[1]);\n    zval_dtor(&z_args[0]);\n\n    return 1;\n}\n\nstatic zend_bool\nra_move_collection(const char *key, int key_len, zval *z_from, zval *z_to,\n        int list_count, const char **cmd_list,\n        int add_count, const char **cmd_add, long ttl) {\n\n    zval z_fun_retrieve, z_fun_sadd, z_ret, *z_retrieve_args, *z_sadd_args, *z_data_p;\n    int count, i;\n    HashTable *h_set_vals;\n\n    /* run retrieval command on source */\n    ZVAL_STRING(&z_fun_retrieve, cmd_list[0]);  /* set the command */\n\n    z_retrieve_args = ecalloc(list_count, sizeof(zval));\n    /* set the key */\n    ZVAL_STRINGL(&z_retrieve_args[0], key, key_len);\n\n    /* possibly add some other args if they were provided. */\n    for(i = 1; i < list_count; ++i) {\n        ZVAL_STRING(&z_retrieve_args[i], cmd_list[i]);\n    }\n\n    call_user_function(&redis_ce->function_table, z_from, &z_fun_retrieve, &z_ret, list_count, z_retrieve_args);\n\n    /* cleanup */\n    zval_dtor(&z_fun_retrieve);\n    for(i = 0; i < list_count; ++i) {\n        zval_dtor(&z_retrieve_args[i]);\n    }\n    efree(z_retrieve_args);\n\n    if(Z_TYPE(z_ret) != IS_ARRAY) { /* key not found or replaced */\n        /* TODO: report? */\n        zval_dtor(&z_ret);\n        return 0;\n    }\n\n    /* run SADD/RPUSH on target */\n    h_set_vals = Z_ARRVAL(z_ret);\n    count = 1 + zend_hash_num_elements(h_set_vals);\n    ZVAL_STRING(&z_fun_sadd, cmd_add[0]);\n    z_sadd_args = ecalloc(count, sizeof(zval));\n    ZVAL_STRINGL(&z_sadd_args[0], key, key_len);\n\n    i = 1;\n    ZEND_HASH_FOREACH_VAL(h_set_vals, z_data_p) {\n        /* add set elements */\n        ZVAL_ZVAL(&z_sadd_args[i], z_data_p, 1, 0);\n        i++;\n    } ZEND_HASH_FOREACH_END();\n\n    /* Clean up our input return value */\n    zval_dtor(&z_ret);\n\n    call_user_function(&redis_ce->function_table, z_to, &z_fun_sadd, &z_ret, count, z_sadd_args);\n\n    /* cleanup */\n    zval_dtor(&z_fun_sadd);\n    for (i = 0; i < count; i++) {\n        zval_dtor(&z_sadd_args[i]);\n    }\n    efree(z_sadd_args);\n\n    /* Clean up our output return value */\n    zval_dtor(&z_ret);\n\n    /* Expire if needed */\n    ra_expire_key(key, key_len, z_to, ttl);\n\n    return 1;\n}\n\nstatic zend_bool\nra_move_set(const char *key, int key_len, zval *z_from, zval *z_to, long ttl) {\n\n    const char *cmd_list[] = {\"SMEMBERS\"};\n    const char *cmd_add[] = {\"SADD\"};\n    return ra_move_collection(key, key_len, z_from, z_to, 1, cmd_list, 1, cmd_add, ttl);\n}\n\nstatic zend_bool\nra_move_list(const char *key, int key_len, zval *z_from, zval *z_to, long ttl) {\n\n    const char *cmd_list[] = {\"LRANGE\", \"0\", \"-1\"};\n    const char *cmd_add[] = {\"RPUSH\"};\n    return ra_move_collection(key, key_len, z_from, z_to, 3, cmd_list, 1, cmd_add, ttl);\n}\n\nvoid\nra_move_key(const char *key, int key_len, zval *z_from, zval *z_to) {\n\n    long res[2] = {0}, type, ttl;\n    zend_bool success = 0;\n    if (ra_get_key_type(z_from, key, key_len, z_from, res)) {\n        type = res[0];\n        ttl = res[1];\n        /* open transaction on target server */\n        ra_index_multi(z_to, MULTI);\n        switch(type) {\n            case REDIS_STRING:\n                success = ra_move_string(key, key_len, z_from, z_to, ttl);\n                break;\n\n            case REDIS_SET:\n                success = ra_move_set(key, key_len, z_from, z_to, ttl);\n                break;\n\n            case REDIS_LIST:\n                success = ra_move_list(key, key_len, z_from, z_to, ttl);\n                break;\n\n            case REDIS_ZSET:\n                success = ra_move_zset(key, key_len, z_from, z_to, ttl);\n                break;\n\n            case REDIS_HASH:\n                success = ra_move_hash(key, key_len, z_from, z_to, ttl);\n                break;\n\n            default:\n                /* TODO: report? */\n                break;\n        }\n    }\n\n    if(success) {\n        ra_del_key(key, key_len, z_from);\n        ra_index_key(key, key_len, z_to);\n    }\n\n    /* close transaction */\n    ra_index_exec(z_to, NULL, 0);\n}\n\n/* callback with the current progress, with hostname and count */\nstatic void\nzval_rehash_callback(zend_fcall_info *z_cb, zend_fcall_info_cache *z_cb_cache,\n    zend_string *hostname, long count) {\n\n    zval zv, *z_ret = &zv;\n\n    ZVAL_NULL(z_ret);\n\n    zval z_args[2];\n\n    ZVAL_STRINGL(&z_args[0], ZSTR_VAL(hostname), ZSTR_LEN(hostname));\n    ZVAL_LONG(&z_args[1], count);\n\n    z_cb->params = z_args;\n    z_cb->retval = z_ret;\n\n    z_cb->param_count = 2;\n\n    /* run cb(hostname, count) */\n    zend_call_function(z_cb, z_cb_cache);\n\n    /* cleanup */\n    zval_dtor(&z_args[0]);\n    zval_dtor(z_ret);\n}\n\nstatic void\nra_rehash_server(RedisArray *ra, zval *z_redis, zend_string *hostname, zend_bool b_index,\n        zend_fcall_info *z_cb, zend_fcall_info_cache *z_cb_cache) {\n\n    HashTable *h_keys;\n    long count = 0;\n    zval z_fun, z_ret, z_argv, *z_ele;\n\n    /* list all keys */\n    if (b_index) {\n        ZVAL_STRING(&z_fun, \"SMEMBERS\");\n        ZVAL_STRING(&z_argv, PHPREDIS_INDEX_NAME);\n    } else {\n        ZVAL_STRING(&z_fun, \"KEYS\");\n        ZVAL_STRING(&z_argv, \"*\");\n    }\n    ZVAL_NULL(&z_ret);\n    call_user_function(&redis_ce->function_table, z_redis, &z_fun, &z_ret, 1, &z_argv);\n    zval_dtor(&z_argv);\n    zval_dtor(&z_fun);\n\n    if (Z_TYPE(z_ret) == IS_ARRAY) {\n        h_keys = Z_ARRVAL(z_ret);\n        count = zend_hash_num_elements(h_keys);\n    }\n\n    if (!count) {\n        zval_dtor(&z_ret);\n        return;\n    }\n\n    /* callback */\n    if(z_cb && z_cb_cache) {\n        zval_rehash_callback(z_cb, z_cb_cache, hostname, count);\n    }\n\n    /* for each key, redistribute */\n    ZEND_HASH_FOREACH_VAL(h_keys, z_ele) {\n        int pos = 0;\n        /* check that we're not moving to the same node. */\n        zval *z_target = ra_find_node(ra, Z_STRVAL_P(z_ele), Z_STRLEN_P(z_ele), &pos);\n\n        if (z_target && !zend_string_equals(hostname, ra->hosts[pos])) { /* different host */\n            ra_move_key(Z_STRVAL_P(z_ele), Z_STRLEN_P(z_ele), z_redis, z_target);\n        }\n\n    } ZEND_HASH_FOREACH_END();\n\n    /* cleanup */\n    zval_dtor(&z_ret);\n}\n\nvoid\nra_rehash(RedisArray *ra, zend_fcall_info *z_cb, zend_fcall_info_cache *z_cb_cache) {\n    int i;\n\n    /* redistribute the data, server by server. */\n    if(!ra->prev)\n        return; /* TODO: compare the two rings for equality */\n\n    for(i = 0; i < ra->prev->count; ++i) {\n        ra_rehash_server(ra, &ra->prev->redis[i], ra->prev->hosts[i], ra->index, z_cb, z_cb_cache);\n    }\n}\n\n"
        },
        {
          "name": "redis_array_impl.h",
          "type": "blob",
          "size": 1.5048828125,
          "content": "#ifndef REDIS_ARRAY_IMPL_H\n#define REDIS_ARRAY_IMPL_H\n\n#if (defined(_MSC_VER) && _MSC_VER <= 1920)\n#include <win32/php_stdint.h>\n#else\n#include <stdint.h>\n#endif\n\n#include \"redis_array.h\"\n\nRedisArray *ra_load_array(const char *name);\n\nRedisArray *ra_make_array(HashTable *hosts, zval *z_fun, zval *z_dist,\n                          HashTable *hosts_prev, zend_bool b_index,\n                          zend_bool b_pconnect, long retry_interval,\n                          zend_bool b_lazy_connect, double connect_timeout,\n                          double read_timeout, zend_bool consistent,\n                          zend_string *algorithm, zend_string *auth,\n                          zend_string *pass);\n\nzval *ra_find_node_by_name(RedisArray *ra, zend_string *host);\nzval *ra_find_node(RedisArray *ra, const char *key, int key_len, int *out_pos);\nvoid ra_init_function_table(RedisArray *ra);\n\nvoid ra_move_key(const char *key, int key_len, zval *z_from, zval *z_to);\nvoid ra_index_multi(zval *z_redis, long multi_value);\n\nvoid ra_index_key(const char *key, int key_len, zval *z_redis);\nvoid ra_index_keys(zval *z_pairs, zval *z_redis);\nvoid ra_index_del(zval *z_keys, zval *z_redis);\nvoid ra_index_exec(zval *z_redis, zval *return_value, int keep_all);\nvoid ra_index_discard(zval *z_redis, zval *return_value);\nvoid ra_index_unwatch(zval *z_redis, zval *return_value);\nzend_bool ra_is_write_cmd(RedisArray *ra, const char *cmd, int cmd_len);\n\nvoid ra_rehash(RedisArray *ra, zend_fcall_info *z_cb, zend_fcall_info_cache *z_cb_cache);\n\n#endif\n"
        },
        {
          "name": "redis_array_legacy_arginfo.h",
          "type": "blob",
          "size": 6.98828125,
          "content": "/* This is a generated file, edit the .stub.php file instead.\n * Stub hash: ddb92422452cb767a7d6694aa8ac60d883db6672 */\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray___call, 0, 0, 2)\n\tZEND_ARG_INFO(0, function_name)\n\tZEND_ARG_INFO(0, arguments)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray___construct, 0, 0, 1)\n\tZEND_ARG_INFO(0, name_or_hosts)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray__continuum, 0, 0, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisArray__distributor arginfo_class_RedisArray__continuum\n\n#define arginfo_class_RedisArray__function arginfo_class_RedisArray__continuum\n\n#define arginfo_class_RedisArray__hosts arginfo_class_RedisArray__continuum\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray__instance, 0, 0, 1)\n\tZEND_ARG_INFO(0, host)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray__rehash, 0, 0, 0)\n\tZEND_ARG_INFO(0, fn)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray__target, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisArray_bgsave arginfo_class_RedisArray__continuum\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray_del, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_VARIADIC_INFO(0, otherkeys)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisArray_discard arginfo_class_RedisArray__continuum\n\n#define arginfo_class_RedisArray_exec arginfo_class_RedisArray__continuum\n\n#define arginfo_class_RedisArray_flushall arginfo_class_RedisArray__continuum\n\n#define arginfo_class_RedisArray_flushdb arginfo_class_RedisArray__continuum\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray_getOption, 0, 0, 1)\n\tZEND_ARG_INFO(0, opt)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray_hscan, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(1, iterator)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisArray_info arginfo_class_RedisArray__continuum\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray_keys, 0, 0, 1)\n\tZEND_ARG_INFO(0, pattern)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray_mget, 0, 0, 1)\n\tZEND_ARG_INFO(0, keys)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray_mset, 0, 0, 1)\n\tZEND_ARG_INFO(0, pairs)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray_multi, 0, 0, 1)\n\tZEND_ARG_INFO(0, host)\n\tZEND_ARG_INFO(0, mode)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisArray_ping arginfo_class_RedisArray__continuum\n\n#define arginfo_class_RedisArray_save arginfo_class_RedisArray__continuum\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray_scan, 0, 0, 2)\n\tZEND_ARG_INFO(1, iterator)\n\tZEND_ARG_INFO(0, node)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray_select, 0, 0, 1)\n\tZEND_ARG_INFO(0, index)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisArray_setOption, 0, 0, 2)\n\tZEND_ARG_INFO(0, opt)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisArray_sscan arginfo_class_RedisArray_hscan\n\n#define arginfo_class_RedisArray_unlink arginfo_class_RedisArray_del\n\n#define arginfo_class_RedisArray_unwatch arginfo_class_RedisArray__continuum\n\n#define arginfo_class_RedisArray_zscan arginfo_class_RedisArray_hscan\n\n\nZEND_METHOD(RedisArray, __call);\nZEND_METHOD(RedisArray, __construct);\nZEND_METHOD(RedisArray, _continuum);\nZEND_METHOD(RedisArray, _distributor);\nZEND_METHOD(RedisArray, _function);\nZEND_METHOD(RedisArray, _hosts);\nZEND_METHOD(RedisArray, _instance);\nZEND_METHOD(RedisArray, _rehash);\nZEND_METHOD(RedisArray, _target);\nZEND_METHOD(RedisArray, bgsave);\nZEND_METHOD(RedisArray, del);\nZEND_METHOD(RedisArray, discard);\nZEND_METHOD(RedisArray, exec);\nZEND_METHOD(RedisArray, flushall);\nZEND_METHOD(RedisArray, flushdb);\nZEND_METHOD(RedisArray, getOption);\nZEND_METHOD(RedisArray, hscan);\nZEND_METHOD(RedisArray, info);\nZEND_METHOD(RedisArray, keys);\nZEND_METHOD(RedisArray, mget);\nZEND_METHOD(RedisArray, mset);\nZEND_METHOD(RedisArray, multi);\nZEND_METHOD(RedisArray, ping);\nZEND_METHOD(RedisArray, save);\nZEND_METHOD(RedisArray, scan);\nZEND_METHOD(RedisArray, select);\nZEND_METHOD(RedisArray, setOption);\nZEND_METHOD(RedisArray, sscan);\nZEND_METHOD(RedisArray, unlink);\nZEND_METHOD(RedisArray, unwatch);\nZEND_METHOD(RedisArray, zscan);\n\n\nstatic const zend_function_entry class_RedisArray_methods[] = {\n\tZEND_ME(RedisArray, __call, arginfo_class_RedisArray___call, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, __construct, arginfo_class_RedisArray___construct, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, _continuum, arginfo_class_RedisArray__continuum, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, _distributor, arginfo_class_RedisArray__distributor, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, _function, arginfo_class_RedisArray__function, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, _hosts, arginfo_class_RedisArray__hosts, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, _instance, arginfo_class_RedisArray__instance, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, _rehash, arginfo_class_RedisArray__rehash, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, _target, arginfo_class_RedisArray__target, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, bgsave, arginfo_class_RedisArray_bgsave, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, del, arginfo_class_RedisArray_del, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, discard, arginfo_class_RedisArray_discard, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, exec, arginfo_class_RedisArray_exec, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, flushall, arginfo_class_RedisArray_flushall, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, flushdb, arginfo_class_RedisArray_flushdb, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, getOption, arginfo_class_RedisArray_getOption, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, hscan, arginfo_class_RedisArray_hscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, info, arginfo_class_RedisArray_info, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, keys, arginfo_class_RedisArray_keys, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, mget, arginfo_class_RedisArray_mget, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, mset, arginfo_class_RedisArray_mset, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, multi, arginfo_class_RedisArray_multi, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, ping, arginfo_class_RedisArray_ping, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, save, arginfo_class_RedisArray_save, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, scan, arginfo_class_RedisArray_scan, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, select, arginfo_class_RedisArray_select, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, setOption, arginfo_class_RedisArray_setOption, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, sscan, arginfo_class_RedisArray_sscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, unlink, arginfo_class_RedisArray_unlink, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, unwatch, arginfo_class_RedisArray_unwatch, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisArray, zscan, arginfo_class_RedisArray_zscan, ZEND_ACC_PUBLIC)\n\tZEND_FE_END\n};\n\nstatic zend_class_entry *register_class_RedisArray(void)\n{\n\tzend_class_entry ce, *class_entry;\n\n\tINIT_CLASS_ENTRY(ce, \"RedisArray\", class_RedisArray_methods);\n\tclass_entry = zend_register_internal_class_ex(&ce, NULL);\n\n\treturn class_entry;\n}\n"
        },
        {
          "name": "redis_cluster.c",
          "type": "blob",
          "size": 95.4052734375,
          "content": "/*\n  +----------------------------------------------------------------------+\n  | Copyright (c) 1997-2009 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt                                  |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Michael Grunder <michael.grunder@gmail.com>                  |\n  | Maintainer: Nicolas Favre-Felix <n.favre-felix@owlient.eu>           |\n  +----------------------------------------------------------------------+\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"common.h\"\n#include \"php_redis.h\"\n#include \"ext/standard/info.h\"\n#include \"crc16.h\"\n#include \"redis_cluster.h\"\n#include \"redis_commands.h\"\n#include <ext/spl/spl_exceptions.h>\n#include <zend_exceptions.h>\n#include \"library.h\"\n#include <php_variables.h>\n#include <SAPI.h>\n\nzend_class_entry *redis_cluster_ce;\n\n/* Exception handler */\nzend_class_entry *redis_cluster_exception_ce;\n\n#if PHP_VERSION_ID < 80000\n#include \"redis_cluster_legacy_arginfo.h\"\n#else\n#include \"zend_attributes.h\"\n#include \"redis_cluster_arginfo.h\"\n#endif\n\nPHP_MINIT_FUNCTION(redis_cluster)\n{\n    redis_cluster_ce = register_class_RedisCluster();\n    redis_cluster_ce->create_object = create_cluster_context;\n\n    redis_cluster_exception_ce = register_class_RedisClusterException(spl_ce_RuntimeException);\n\n    return SUCCESS;\n}\n\n/* Handlers for RedisCluster */\nzend_object_handlers RedisCluster_handlers;\n\n/* Our context seeds will be a hash table with RedisSock* pointers */\nstatic void ht_free_seed(zval *data) {\n    RedisSock *redis_sock = *(RedisSock**)data;\n    if (redis_sock) redis_free_socket(redis_sock);\n}\n\n/* Free redisClusterNode objects we've stored */\nstatic void ht_free_node(zval *data) {\n    redisClusterNode *node = *(redisClusterNode**)data;\n    cluster_free_node(node);\n}\n\n/* Create redisCluster context */\nzend_object * create_cluster_context(zend_class_entry *class_type) {\n    redisCluster *cluster;\n\n    // Allocate our actual struct\n    cluster = ecalloc(1, sizeof(redisCluster) + zend_object_properties_size(class_type));\n\n    // We're not currently subscribed anywhere\n    cluster->subscribed_slot = -1;\n\n    // Allocate our RedisSock we'll use to store prefix/serialization flags\n    cluster->flags = ecalloc(1, sizeof(RedisSock));\n\n    // Allocate our hash table for seeds\n    ALLOC_HASHTABLE(cluster->seeds);\n    zend_hash_init(cluster->seeds, 0, NULL, ht_free_seed, 0);\n\n    // Allocate our hash table for connected Redis objects\n    ALLOC_HASHTABLE(cluster->nodes);\n    zend_hash_init(cluster->nodes, 0, NULL, ht_free_node, 0);\n\n    // Initialize it\n    zend_object_std_init(&cluster->std, class_type);\n\n    object_properties_init(&cluster->std, class_type);\n    memcpy(&RedisCluster_handlers, zend_get_std_object_handlers(), sizeof(RedisCluster_handlers));\n    RedisCluster_handlers.offset = XtOffsetOf(redisCluster, std);\n    RedisCluster_handlers.free_obj = free_cluster_context;\n\n    cluster->std.handlers = &RedisCluster_handlers;\n\n    return &cluster->std;\n}\n\n/* Free redisCluster context */\nvoid free_cluster_context(zend_object *object) {\n    redisCluster *cluster = PHPREDIS_GET_OBJECT(redisCluster, object);\n\n    cluster_free(cluster, 0);\n    zend_object_std_dtor(&cluster->std);\n}\n\n/* Take user provided seeds and return unique and valid ones */\n/* Attempt to connect to a Redis cluster provided seeds and timeout options */\nstatic void redis_cluster_init(redisCluster *c, HashTable *ht_seeds, double timeout,\n                               double read_timeout, int persistent, zend_string *user,\n                               zend_string *pass, zval *context)\n{\n    zend_string *hash = NULL, **seeds;\n    redisCachedCluster *cc;\n    uint32_t nseeds;\n    char *err;\n\n    /* Validate our arguments and get a sanitized seed array */\n    seeds = cluster_validate_args(timeout, read_timeout, ht_seeds, &nseeds, &err);\n    if (seeds == NULL) {\n        CLUSTER_THROW_EXCEPTION(err, 0);\n        return;\n    }\n\n    if (user && ZSTR_LEN(user))\n        c->flags->user = zend_string_copy(user);\n    if (pass && ZSTR_LEN(pass))\n        c->flags->pass = zend_string_copy(pass);\n    if (context) {\n        redis_sock_set_stream_context(c->flags, context);\n    }\n\n    c->flags->timeout = timeout;\n    c->flags->read_timeout = read_timeout;\n    c->flags->persistent = persistent;\n    c->waitms = (long)(1000 * (timeout + read_timeout));\n\n    /* Attempt to load slots from cache if caching is enabled */\n    if (CLUSTER_CACHING_ENABLED()) {\n        /* Exit early if we can load from cache */\n        hash = cluster_hash_seeds(seeds, nseeds);\n        if ((cc = cluster_cache_load(hash))) {\n            cluster_init_cache(c, cc);\n            goto cleanup;\n        }\n    }\n\n    /* Initialize seeds and attempt to map keyspace */\n    cluster_init_seeds(c, seeds, nseeds);\n    if (cluster_map_keyspace(c) == SUCCESS && hash)\n        cluster_cache_store(hash, c->nodes);\n\ncleanup:\n    if (hash) zend_string_release(hash);\n    free_seed_array(seeds, nseeds);\n}\n\n\n/* Attempt to load a named cluster configured in php.ini */\nvoid redis_cluster_load(redisCluster *c, char *name, int name_len) {\n    zval z_seeds, z_tmp, *z_value;\n    zend_string *user = NULL, *pass = NULL;\n    double timeout = 0, read_timeout = 0;\n    int persistent = 0;\n    char *iptr;\n    HashTable *ht_seeds = NULL;\n\n    /* Seeds */\n    array_init(&z_seeds);\n    if ((iptr = INI_STR(\"redis.clusters.seeds\")) != NULL) {\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_seeds);\n    }\n    if ((z_value = zend_hash_str_find(Z_ARRVAL(z_seeds), name, name_len)) != NULL) {\n        ht_seeds = Z_ARRVAL_P(z_value);\n    } else {\n        zval_dtor(&z_seeds);\n        CLUSTER_THROW_EXCEPTION(\"Couldn't find seeds for cluster\", 0);\n        return;\n    }\n\n    /* Connection timeout */\n    if ((iptr = INI_STR(\"redis.clusters.timeout\")) != NULL) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        redis_conf_double(Z_ARRVAL(z_tmp), name, name_len, &timeout);\n        zval_dtor(&z_tmp);\n    }\n\n    /* Read timeout */\n    if ((iptr = INI_STR(\"redis.clusters.read_timeout\")) != NULL) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        redis_conf_double(Z_ARRVAL(z_tmp), name, name_len, &read_timeout);\n        zval_dtor(&z_tmp);\n    }\n\n    /* Persistent connections */\n    if ((iptr = INI_STR(\"redis.clusters.persistent\")) != NULL) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        redis_conf_bool(Z_ARRVAL(z_tmp), name, name_len, &persistent);\n        zval_dtor(&z_tmp);\n    }\n\n    if ((iptr = INI_STR(\"redis.clusters.auth\"))) {\n        array_init(&z_tmp);\n        sapi_module.treat_data(PARSE_STRING, estrdup(iptr), &z_tmp);\n        redis_conf_auth(Z_ARRVAL(z_tmp), name, name_len, &user, &pass);\n        zval_dtor(&z_tmp);\n    }\n\n    /* Attempt to create/connect to the cluster */\n    redis_cluster_init(c, ht_seeds, timeout, read_timeout, persistent, user, pass, NULL);\n\n    /* Clean up */\n    zval_dtor(&z_seeds);\n    if (user) zend_string_release(user);\n    if (pass) zend_string_release(pass);\n}\n\n/*\n * PHP Methods\n */\n\n/* Create a RedisCluster Object */\nPHP_METHOD(RedisCluster, __construct) {\n    zval *object, *z_seeds = NULL, *z_auth = NULL, *context = NULL;\n    zend_string *user = NULL, *pass = NULL;\n    double timeout = 0.0, read_timeout = 0.0;\n    size_t name_len;\n    zend_bool persistent = 0;\n    redisCluster *c = GET_CONTEXT();\n    char *name;\n\n    // Parse arguments\n    if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(),\n                                    \"Os!|addbza!\", &object, redis_cluster_ce, &name,\n                                    &name_len, &z_seeds, &timeout, &read_timeout,\n                                    &persistent, &z_auth, &context) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    /* If we've got a string try to load from INI */\n    if (ZEND_NUM_ARGS() < 2) {\n        if (name_len == 0) { // Require a name\n            CLUSTER_THROW_EXCEPTION(\"You must specify a name or pass seeds!\", 0);\n        }\n        redis_cluster_load(c, name, name_len);\n        return;\n    }\n\n    /* The normal case, loading from arguments */\n    redis_extract_auth_info(z_auth, &user, &pass);\n    redis_cluster_init(c, Z_ARRVAL_P(z_seeds), timeout, read_timeout,\n                       persistent, user, pass, context);\n\n    if (user) zend_string_release(user);\n    if (pass) zend_string_release(pass);\n}\n\n/*\n * RedisCluster method implementation\n */\n\n/* {{{ proto bool RedisCluster::close() */\nPHP_METHOD(RedisCluster, close) {\n    cluster_disconnect(GET_CONTEXT(), 1);\n    RETURN_TRUE;\n}\n\n/* {{{ proto string RedisCluster::get(string key) */\nPHP_METHOD(RedisCluster, get) {\n    CLUSTER_PROCESS_KW_CMD(\"GET\", redis_key_cmd, cluster_bulk_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::set(string key, string value) */\nPHP_METHOD(RedisCluster, set) {\n    CLUSTER_PROCESS_CMD(set, cluster_set_resp, 0);\n}\n/* }}} */\n\n/* Generic handler for MGET/MSET/MSETNX */\nstatic int\ndistcmd_resp_handler(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c, short slot,\n                     clusterMultiCmd *mc, zval *z_ret, int last, cluster_cb cb)\n{\n    clusterMultiCtx *ctx;\n\n    // Finalize multi command\n    cluster_multi_fini(mc);\n\n    // Spin up multi context\n    ctx = emalloc(sizeof(clusterMultiCtx));\n    ctx->z_multi = z_ret;\n    ctx->count   = mc->argc;\n    ctx->last    = last;\n\n    // Attempt to send the command\n    if (cluster_send_command(c,slot,mc->cmd.c,mc->cmd.len) < 0 || c->err != NULL) {\n        efree(ctx);\n        return -1;\n    }\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        // Process response now\n        cb(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, (void*)ctx);\n    } else {\n        CLUSTER_ENQUEUE_RESPONSE(c, slot, cb, ctx);\n    }\n\n    // Clear out our command but retain allocated memory\n    CLUSTER_MULTI_CLEAR(mc);\n\n    return 0;\n}\n\n/* Container struct for a key/value pair pulled from an array */\ntypedef struct clusterKeyValHT {\n    char kbuf[22];\n\n    char  *key;\n    size_t key_len;\n    int key_free;\n    short slot;\n\n    char *val;\n    size_t val_len;\n    int val_free;\n} clusterKeyValHT;\n\n/* Helper to pull a key/value pair from a HashTable */\nstatic int get_key_val_ht(redisCluster *c, HashTable *ht, HashPosition *ptr,\n                          clusterKeyValHT *kv)\n{\n    zval *z_val;\n    zend_ulong idx;\n\n    // Grab the key, convert it to a string using provided kbuf buffer if it's\n    // a LONG style key\n    zend_string *zkey;\n    switch (zend_hash_get_current_key_ex(ht, &zkey, &idx, ptr)) {\n        case HASH_KEY_IS_STRING:\n            kv->key_len = ZSTR_LEN(zkey);\n            kv->key = ZSTR_VAL(zkey);\n            break;\n        case HASH_KEY_IS_LONG:\n            kv->key_len = snprintf(kv->kbuf,sizeof(kv->kbuf),\"%ld\",(long)idx);\n            kv->key     = kv->kbuf;\n            break;\n        default:\n            CLUSTER_THROW_EXCEPTION(\"Internal Zend HashTable error\", 0);\n            return -1;\n    }\n\n    // Prefix our key if we need to, set the slot\n    kv->key_free = redis_key_prefix(c->flags, &(kv->key), &(kv->key_len));\n    kv->slot     = cluster_hash_key(kv->key, kv->key_len);\n\n    // Now grab our value\n    if ((z_val = zend_hash_get_current_data_ex(ht, ptr)) == NULL) {\n        CLUSTER_THROW_EXCEPTION(\"Internal Zend HashTable error\", 0);\n        return -1;\n    }\n\n    // Serialize our value if required\n    kv->val_free = redis_pack(c->flags,z_val,&(kv->val),&(kv->val_len));\n\n    // Success\n    return 0;\n}\n\n/* Helper to pull, prefix, and hash a key from a HashTable value */\nstatic int get_key_ht(redisCluster *c, HashTable *ht, HashPosition *ptr,\n                      clusterKeyValHT *kv)\n{\n    zval *z_key;\n\n    if ((z_key = zend_hash_get_current_data_ex(ht, ptr)) == NULL) {\n        // Shouldn't happen, but check anyway\n        CLUSTER_THROW_EXCEPTION(\"Internal Zend HashTable error\", 0);\n        return -1;\n    }\n\n    // Always want to work with strings\n    convert_to_string(z_key);\n\n    kv->key = Z_STRVAL_P(z_key);\n    kv->key_len = Z_STRLEN_P(z_key);\n    kv->key_free = redis_key_prefix(c->flags, &(kv->key), &(kv->key_len));\n\n    // Hash our key\n    kv->slot = cluster_hash_key(kv->key, kv->key_len);\n\n    // Success\n    return 0;\n}\n\n/* Turn variable arguments into a HashTable for processing */\nstatic HashTable *method_args_to_ht(zval *z_args, int argc) {\n    HashTable *ht_ret;\n    int i;\n\n    /* Allocate our hash table */\n    ALLOC_HASHTABLE(ht_ret);\n    zend_hash_init(ht_ret, argc, NULL, NULL, 0);\n\n    /* Populate our return hash table with our arguments */\n    for (i = 0; i < argc; i++) {\n        zend_hash_next_index_insert(ht_ret, &z_args[i]);\n    }\n\n    /* Return our hash table */\n    return ht_ret;\n}\n\n/* Convenience handler for commands that take multiple keys such as\n * MGET, DEL, and UNLINK */\nstatic int cluster_mkey_cmd(INTERNAL_FUNCTION_PARAMETERS, char *kw, int kw_len,\n                            zval *z_ret, cluster_cb cb)\n{\n    redisCluster *c = GET_CONTEXT();\n    clusterMultiCmd mc = {0};\n    clusterKeyValHT kv;\n    zval *z_args;\n    HashTable *ht_arr;\n    HashPosition ptr;\n    int i = 1, argc = ZEND_NUM_ARGS(), ht_free = 0;\n    short slot;\n\n    /* If we don't have any arguments we're invalid */\n    if (!argc) return -1;\n\n    /* Extract our arguments into an array */\n    z_args = ecalloc(argc, sizeof(zval));\n    if (zend_get_parameters_array(ht, argc, z_args) == FAILURE) {\n        efree(z_args);\n        return -1;\n    }\n\n    /* Determine if we're working with a single array or variadic args */\n    if (argc == 1 && Z_TYPE(z_args[0]) == IS_ARRAY) {\n        ht_arr = Z_ARRVAL(z_args[0]);\n        argc = zend_hash_num_elements(ht_arr);\n        if (!argc) {\n            efree(z_args);\n            return -1;\n        }\n    } else {\n        ht_arr = method_args_to_ht(z_args, argc);\n        ht_free = 1;\n    }\n\n    /* MGET is readonly, DEL is not */\n    c->readonly = kw_len == 4 && CLUSTER_IS_ATOMIC(c);\n\n    // Initialize our \"multi\" command handler with command/len\n    CLUSTER_MULTI_INIT(mc, kw, kw_len);\n\n    // Process the first key outside of our loop, so we don't have to check if\n    // it's the first iteration every time, needlessly\n    zend_hash_internal_pointer_reset_ex(ht_arr, &ptr);\n    if (get_key_ht(c, ht_arr, &ptr, &kv) < 0) {\n        efree(z_args);\n        return -1;\n    }\n\n    // Process our key and add it to the command\n    cluster_multi_add(&mc, kv.key, kv.key_len);\n\n    // Free key if we prefixed\n    if (kv.key_free) efree(kv.key);\n\n    // Move to the next key\n    zend_hash_move_forward_ex(ht_arr, &ptr);\n\n    // Iterate over keys 2...N\n    slot = kv.slot;\n    while (zend_hash_has_more_elements_ex(ht_arr, &ptr) ==SUCCESS) {\n        if (get_key_ht(c, ht_arr, &ptr, &kv) < 0) {\n            cluster_multi_free(&mc);\n            if (ht_free) {\n                zend_hash_destroy(ht_arr);\n                efree(ht_arr);\n            }\n            efree(z_args);\n            return -1;\n        }\n\n        // If the slots have changed, kick off the keys we've aggregated\n        if (slot != kv.slot) {\n            // Process this batch of MGET keys\n            if (distcmd_resp_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, slot,\n                                    &mc, z_ret, i == argc, cb) < 0)\n            {\n                cluster_multi_free(&mc);\n                if (ht_free) {\n                    zend_hash_destroy(ht_arr);\n                    efree(ht_arr);\n                }\n                efree(z_args);\n                return -1;\n            }\n        }\n\n        // Add this key to the command\n        cluster_multi_add(&mc, kv.key, kv.key_len);\n\n        // Free key if we prefixed\n        if (kv.key_free) efree(kv.key);\n\n        // Update the last slot we encountered, and the key we're on\n        slot = kv.slot;\n        i++;\n\n        zend_hash_move_forward_ex(ht_arr, &ptr);\n    }\n    efree(z_args);\n\n    // If we've got straggler(s) process them\n    if (mc.argc > 0) {\n        if (distcmd_resp_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, slot,\n                                &mc, z_ret, 1, cb) < 0)\n        {\n            cluster_multi_free(&mc);\n            if (ht_free) {\n                zend_hash_destroy(ht_arr);\n                efree(ht_arr);\n            }\n            return -1;\n        }\n    }\n\n    // Free our command\n    cluster_multi_free(&mc);\n\n    /* Clean up our hash table if we constructed it from variadic args */\n    if (ht_free) {\n        zend_hash_destroy(ht_arr);\n        efree(ht_arr);\n    }\n\n    /* Return our object if we're in MULTI mode */\n    if (!CLUSTER_IS_ATOMIC(c))\n        RETVAL_ZVAL(getThis(), 1, 0);\n\n    // Success\n    return 0;\n}\n\n/* Handler for both MSET and MSETNX */\nstatic int cluster_mset_cmd(INTERNAL_FUNCTION_PARAMETERS, char *kw, int kw_len,\n                            zval *z_ret, cluster_cb cb)\n{\n    redisCluster *c = GET_CONTEXT();\n    clusterKeyValHT kv;\n    clusterMultiCmd mc = {0};\n    zval *z_arr;\n    HashTable *ht_arr;\n    HashPosition ptr;\n    int i = 1, argc;\n    short slot;\n\n    // Parse our arguments\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"a\", &z_arr) == FAILURE) {\n        return -1;\n    }\n\n    // No reason to send zero args\n    ht_arr = Z_ARRVAL_P(z_arr);\n    if ((argc = zend_hash_num_elements(ht_arr)) == 0) {\n        return -1;\n    }\n\n    /* This is a write command */\n    c->readonly = 0;\n\n    // Set up our multi command handler\n    CLUSTER_MULTI_INIT(mc, kw, kw_len);\n\n    // Process the first key/value pair outside of our loop\n    zend_hash_internal_pointer_reset_ex(ht_arr, &ptr);\n    if (get_key_val_ht(c, ht_arr, &ptr, &kv) ==-1) return -1;\n    zend_hash_move_forward_ex(ht_arr, &ptr);\n\n    // Add this to our multi cmd, set slot, free key if we prefixed\n    cluster_multi_add(&mc, kv.key, kv.key_len);\n    cluster_multi_add(&mc, kv.val, kv.val_len);\n    if (kv.key_free) efree(kv.key);\n    if (kv.val_free) efree(kv.val);\n\n    // While we've got more keys to set\n    slot = kv.slot;\n    while (zend_hash_has_more_elements_ex(ht_arr, &ptr) ==SUCCESS) {\n        // Pull the next key/value pair\n        if (get_key_val_ht(c, ht_arr, &ptr, &kv) ==-1) {\n            return -1;\n        }\n\n        // If the slots have changed, process responses\n        if (slot != kv.slot) {\n            if (distcmd_resp_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, c,\n                                    slot, &mc, z_ret, i == argc, cb) < 0)\n            {\n                cluster_multi_free(&mc);\n                return -1;\n            }\n        }\n\n        // Add this key and value to our command\n        cluster_multi_add(&mc, kv.key, kv.key_len);\n        cluster_multi_add(&mc, kv.val, kv.val_len);\n\n        // Free our key and value if we need to\n        if (kv.key_free) efree(kv.key);\n        if (kv.val_free) efree(kv.val);\n\n        // Update our slot, increment position\n        slot = kv.slot;\n        i++;\n\n        // Move on\n        zend_hash_move_forward_ex(ht_arr, &ptr);\n    }\n\n    // If we've got stragglers, process them too\n    if (mc.argc > 0) {\n        if (distcmd_resp_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, slot, &mc,\n                                z_ret, 1, cb) < 0)\n        {\n            cluster_multi_free(&mc);\n            return -1;\n        }\n    }\n\n    // Free our command\n    cluster_multi_free(&mc);\n\n    /* Return our object if we're in MULTI mode */\n    if (!CLUSTER_IS_ATOMIC(c))\n        RETVAL_ZVAL(getThis(), 1, 0);\n\n    // Success\n    return 0;\n}\n\n/* Generic passthru for DEL and UNLINK which act identically */\nstatic void cluster_generic_delete(INTERNAL_FUNCTION_PARAMETERS,\n                                   char *kw, int kw_len)\n{\n    zval *z_ret = emalloc(sizeof(*z_ret));\n\n    // Initialize a LONG value to zero for our return\n    ZVAL_LONG(z_ret, 0);\n\n    // Parse args, process\n    if (cluster_mkey_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, kw, kw_len, z_ret,\n                        cluster_del_resp) < 0)\n    {\n        efree(z_ret);\n        RETURN_FALSE;\n    }\n}\n\n/* {{{ proto array RedisCluster::del(string key1, string key2, ... keyN) */\nPHP_METHOD(RedisCluster, del) {\n    cluster_generic_delete(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"DEL\", sizeof(\"DEL\") - 1);\n}\n\n/* {{{ proto array RedisCluster::unlink(string key1, string key2, ... keyN) */\nPHP_METHOD(RedisCluster, unlink) {\n    cluster_generic_delete(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"UNLINK\", sizeof(\"UNLINK\") - 1);\n}\n\n/* {{{ proto array RedisCluster::mget(array keys) */\nPHP_METHOD(RedisCluster, mget) {\n    zval *z_ret = emalloc(sizeof(*z_ret));\n\n    array_init(z_ret);\n\n    // Parse args, process\n    if (cluster_mkey_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"MGET\",\n                        sizeof(\"MGET\")-1, z_ret, cluster_mbulk_mget_resp) < 0)\n    {\n        zval_dtor(z_ret);\n        efree(z_ret);\n        RETURN_FALSE;\n    }\n}\n\n/* {{{ proto bool RedisCluster::mset(array keyvalues) */\nPHP_METHOD(RedisCluster, mset) {\n    zval *z_ret = emalloc(sizeof(*z_ret));\n\n    ZVAL_TRUE(z_ret);\n\n    // Parse args and process.  If we get a failure, free zval and return FALSE.\n    if (cluster_mset_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"MSET\",\n                        sizeof(\"MSET\")-1, z_ret, cluster_mset_resp) ==-1)\n    {\n        efree(z_ret);\n        RETURN_FALSE;\n    }\n}\n\n/* {{{ proto array RedisCluster::msetnx(array keyvalues) */\nPHP_METHOD(RedisCluster, msetnx) {\n    zval *z_ret = emalloc(sizeof(*z_ret));\n\n    array_init(z_ret);\n\n    // Parse args and process.  If we get a failure, free mem and return FALSE\n    if (cluster_mset_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"MSETNX\",\n                         sizeof(\"MSETNX\")-1, z_ret, cluster_msetnx_resp) ==-1)\n    {\n        zval_dtor(z_ret);\n        efree(z_ret);\n        RETURN_FALSE;\n    }\n}\n/* }}} */\n\nPHP_METHOD(RedisCluster, getex) {\n    CLUSTER_PROCESS_CMD(getex, cluster_bulk_resp, 0);\n}\n\n/* {{{ proto bool RedisCluster::setex(string key, string value, int expiry) */\nPHP_METHOD(RedisCluster, setex) {\n    CLUSTER_PROCESS_KW_CMD(\"SETEX\", redis_key_long_val_cmd, cluster_bool_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::psetex(string key, string value, int expiry) */\nPHP_METHOD(RedisCluster, psetex) {\n    CLUSTER_PROCESS_KW_CMD(\"PSETEX\", redis_key_long_val_cmd, cluster_bool_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::setnx(string key, string value) */\nPHP_METHOD(RedisCluster, setnx) {\n    CLUSTER_PROCESS_KW_CMD(\"SETNX\", redis_kv_cmd, cluster_1_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto string RedisCluster::getSet(string key, string value) */\nPHP_METHOD(RedisCluster, getset) {\n    CLUSTER_PROCESS_KW_CMD(\"GETSET\", redis_kv_cmd, cluster_bulk_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto int RedisCluster::exists(string $key, string ...$more_keys) */\nPHP_METHOD(RedisCluster, exists) {\n    CLUSTER_PROCESS_KW_CMD(\"EXISTS\", redis_varkey_cmd, cluster_long_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto int RedisCluster::exists(string $key, string ...$more_keys) */\nPHP_METHOD(RedisCluster, touch) {\n    CLUSTER_PROCESS_KW_CMD(\"TOUCH\", redis_varkey_cmd, cluster_long_resp, 0);\n}\n\n/* }}} */\n/* {{{ proto array Redis::keys(string pattern) */\nPHP_METHOD(RedisCluster, keys) {\n    redisCluster *c = GET_CONTEXT();\n    redisClusterNode *node;\n    size_t pat_len;\n    char *pat, *cmd;\n    clusterReply *resp;\n    int i, cmd_len;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &pat, &pat_len)\n                             == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    /* Prefix and then build our command */\n    cmd_len = redis_spprintf(c->flags, NULL, &cmd, \"KEYS\", \"k\", pat, pat_len);\n\n    array_init(return_value);\n\n    /* Treat as readonly */\n    c->readonly = CLUSTER_IS_ATOMIC(c);\n\n    /* Iterate over our known nodes */\n    ZEND_HASH_FOREACH_PTR(c->nodes, node) {\n        if (node == NULL) continue;\n        if (cluster_send_slot(c, node->slot, cmd, cmd_len, TYPE_MULTIBULK\n                            ) < 0)\n        {\n            php_error_docref(0, E_ERROR, \"Can't send KEYS to %s:%d\",\n                ZSTR_VAL(node->sock->host), node->sock->port);\n            zval_dtor(return_value);\n            efree(cmd);\n            RETURN_FALSE;\n        }\n\n        /* Ensure we can get a response */\n        resp = cluster_read_resp(c, 0);\n        if (!resp) {\n            php_error_docref(0, E_WARNING,\n                \"Can't read response from %s:%d\", ZSTR_VAL(node->sock->host),\n                node->sock->port);\n            continue;\n        }\n\n        /* Iterate keys, adding to our big array */\n        for(i = 0; i < resp->elements; i++) {\n            /* Skip non bulk responses, they should all be bulk */\n            if (resp->element[i]->type != TYPE_BULK) {\n                continue;\n            }\n\n            add_next_index_stringl(return_value, resp->element[i]->str,\n                resp->element[i]->len);\n        }\n\n        /* Free response, don't free data */\n        cluster_free_reply(resp, 1);\n    } ZEND_HASH_FOREACH_END();\n\n    efree(cmd);\n}\n/* }}} */\n\n/* {{{ proto int RedisCluster::type(string key) */\nPHP_METHOD(RedisCluster, type) {\n    CLUSTER_PROCESS_KW_CMD(\"TYPE\", redis_key_cmd, cluster_type_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto string RedisCluster::pop(string key, [int count = 0]) */\nPHP_METHOD(RedisCluster, lpop) {\n    CLUSTER_PROCESS_KW_CMD(\"LPOP\", redis_pop_cmd, cluster_pop_resp, 0);\n}\n/* }}} */\n\nPHP_METHOD(RedisCluster, lpos) {\n    CLUSTER_PROCESS_CMD(lpos, cluster_lpos_resp, 1);\n}\n\n/* {{{ proto string RedisCluster::rpop(string key, [int count = 0]) */\nPHP_METHOD(RedisCluster, rpop) {\n    CLUSTER_PROCESS_KW_CMD(\"RPOP\", redis_pop_cmd, cluster_pop_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::lset(string key, long index, string val) */\nPHP_METHOD(RedisCluster, lset) {\n    CLUSTER_PROCESS_KW_CMD(\"LSET\", redis_key_long_val_cmd, cluster_bool_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto string RedisCluster::spop(string key) */\nPHP_METHOD(RedisCluster, spop) {\n    if (ZEND_NUM_ARGS() == 1) {\n        CLUSTER_PROCESS_KW_CMD(\"SPOP\", redis_key_cmd, cluster_bulk_resp, 0);\n    } else if (ZEND_NUM_ARGS() == 2) {\n        CLUSTER_PROCESS_KW_CMD(\"SPOP\", redis_key_long_cmd, cluster_mbulk_resp, 0);\n    } else {\n        ZEND_WRONG_PARAM_COUNT();\n    }\n}\n/* }}} */\n\n/* {{{ proto string|array RedisCluster::srandmember(string key, [long count]) */\nPHP_METHOD(RedisCluster, srandmember) {\n    CLUSTER_PROCESS_CMD(srandmember, cluster_srandmember_resp, 1);\n}\n\n/* {{{ proto string RedisCluster::strlen(string key) */\nPHP_METHOD(RedisCluster, strlen) {\n    CLUSTER_PROCESS_KW_CMD(\"STRLEN\", redis_key_cmd, cluster_long_resp, 1);\n}\n\n/* {{{ proto long RedisCluster::lpush(string key, string val1, ... valN) */\nPHP_METHOD(RedisCluster, lpush) {\n    CLUSTER_PROCESS_KW_CMD(\"LPUSH\", redis_key_varval_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::rpush(string key, string val1, ... valN) */\nPHP_METHOD(RedisCluster, rpush) {\n    CLUSTER_PROCESS_KW_CMD(\"RPUSH\", redis_key_varval_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::blpop(string key1, ... keyN, long timeout) */\nPHP_METHOD(RedisCluster, blpop) {\n    CLUSTER_PROCESS_KW_CMD(\"BLPOP\", redis_blocking_pop_cmd, cluster_mbulk_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::brpop(string key1, ... keyN, long timeout */\nPHP_METHOD(RedisCluster, brpop) {\n    CLUSTER_PROCESS_KW_CMD(\"BRPOP\", redis_blocking_pop_cmd, cluster_mbulk_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::rpushx(string key, mixed value) */\nPHP_METHOD(RedisCluster, rpushx) {\n    CLUSTER_PROCESS_KW_CMD(\"RPUSHX\", redis_kv_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::lpushx(string key, mixed value) */\nPHP_METHOD(RedisCluster, lpushx) {\n    CLUSTER_PROCESS_KW_CMD(\"LPUSHX\", redis_kv_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::linsert(string k,string pos,mix pvt,mix val) */\nPHP_METHOD(RedisCluster, linsert) {\n    CLUSTER_PROCESS_CMD(linsert, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto string RedisCluster::lindex(string key, long index) */\nPHP_METHOD(RedisCluster, lindex) {\n    CLUSTER_PROCESS_KW_CMD(\"LINDEX\", redis_key_long_cmd, cluster_bulk_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::lrem(string key, long count, string val) */\nPHP_METHOD(RedisCluster, lrem) {\n    CLUSTER_PROCESS_CMD(lrem, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto string RedisCluster::rpoplpush(string key, string key) */\nPHP_METHOD(RedisCluster, rpoplpush) {\n    CLUSTER_PROCESS_KW_CMD(\"RPOPLPUSH\", redis_key_key_cmd, cluster_bulk_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto string RedisCluster::brpoplpush(string key, string key, long tm) */\nPHP_METHOD(RedisCluster, brpoplpush) {\n    CLUSTER_PROCESS_CMD(brpoplpush, cluster_bulk_resp, 0);\n}\n/* }}} */\n\nPHP_METHOD(RedisCluster, lmove) {\n    CLUSTER_PROCESS_KW_CMD(\"LMOVE\", redis_lmove_cmd, cluster_bulk_resp, 0);\n}\n\nPHP_METHOD(RedisCluster, blmove) {\n    CLUSTER_PROCESS_KW_CMD(\"BLMOVE\", redis_lmove_cmd, cluster_bulk_resp, 0);\n}\n\n/* {{{ proto long RedisCluster::llen(string key)  */\nPHP_METHOD(RedisCluster, llen) {\n    CLUSTER_PROCESS_KW_CMD(\"LLEN\", redis_key_cmd, cluster_long_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::scard(string key) */\nPHP_METHOD(RedisCluster, scard) {\n    CLUSTER_PROCESS_KW_CMD(\"SCARD\", redis_key_cmd, cluster_long_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::smembers(string key) */\nPHP_METHOD(RedisCluster, smembers) {\n    CLUSTER_PROCESS_KW_CMD(\"SMEMBERS\", redis_key_cmd, cluster_mbulk_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::sismember(string key) */\nPHP_METHOD(RedisCluster, sismember) {\n    CLUSTER_PROCESS_KW_CMD(\"SISMEMBER\", redis_kv_cmd, cluster_1_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::smismember(string key, string member0, ...memberN) */\nPHP_METHOD(RedisCluster, smismember) {\n    CLUSTER_PROCESS_KW_CMD(\"SMISMEMBER\", redis_key_varval_cmd, cluster_variant_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::sadd(string key, string val1 [, ...]) */\nPHP_METHOD(RedisCluster, sadd) {\n    CLUSTER_PROCESS_KW_CMD(\"SADD\", redis_key_varval_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::saddarray(string key, array values) */\nPHP_METHOD(RedisCluster, saddarray) {\n    CLUSTER_PROCESS_KW_CMD(\"SADD\", redis_key_val_arr_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::srem(string key, string val1 [, ...]) */\nPHP_METHOD(RedisCluster, srem) {\n    CLUSTER_PROCESS_KW_CMD(\"SREM\", redis_key_varval_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::sunion(string key1, ... keyN) */\nPHP_METHOD(RedisCluster, sunion) {\n    CLUSTER_PROCESS_KW_CMD(\"SUNION\", redis_varkey_cmd, cluster_mbulk_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::sunionstore(string dst, string k1, ... kN) */\nPHP_METHOD(RedisCluster, sunionstore) {\n    CLUSTER_PROCESS_KW_CMD(\"SUNIONSTORE\", redis_varkey_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ ptoto array RedisCluster::sinter(string k1, ... kN) */\nPHP_METHOD(RedisCluster, sinter) {\n    CLUSTER_PROCESS_KW_CMD(\"SINTER\", redis_varkey_cmd, cluster_mbulk_resp, 0);\n}\n\n/* {{{ proto RedisCluster::sintercard(array $keys, int $count = -1) */\nPHP_METHOD(RedisCluster, sintercard) {\n    CLUSTER_PROCESS_KW_CMD(\"SINTERCARD\", redis_intercard_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* }}} */\n\n/* {{{ ptoto long RedisCluster::sinterstore(string dst, string k1, ... kN) */\nPHP_METHOD(RedisCluster, sinterstore) {\n    CLUSTER_PROCESS_KW_CMD(\"SINTERSTORE\", redis_varkey_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::sdiff(string k1, ... kN) */\nPHP_METHOD(RedisCluster, sdiff) {\n    CLUSTER_PROCESS_KW_CMD(\"SDIFF\", redis_varkey_cmd, cluster_mbulk_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::sdiffstore(string dst, string k1, ... kN) */\nPHP_METHOD(RedisCluster, sdiffstore) {\n    CLUSTER_PROCESS_KW_CMD(\"SDIFFSTORE\", redis_varkey_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::smove(string src, string dst, string mem) */\nPHP_METHOD(RedisCluster, smove) {\n    CLUSTER_PROCESS_CMD(smove, cluster_1_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::persist(string key) */\nPHP_METHOD(RedisCluster, persist) {\n    CLUSTER_PROCESS_KW_CMD(\"PERSIST\", redis_key_cmd, cluster_1_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::ttl(string key) */\nPHP_METHOD(RedisCluster, ttl) {\n    CLUSTER_PROCESS_KW_CMD(\"TTL\", redis_key_cmd, cluster_long_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::pttl(string key) */\nPHP_METHOD(RedisCluster, pttl) {\n    CLUSTER_PROCESS_KW_CMD(\"PTTL\", redis_key_cmd, cluster_long_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::zcard(string key) */\nPHP_METHOD(RedisCluster, zcard) {\n    CLUSTER_PROCESS_KW_CMD(\"ZCARD\", redis_key_cmd, cluster_long_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto double RedisCluster::zscore(string key) */\nPHP_METHOD(RedisCluster, zscore) {\n    CLUSTER_PROCESS_KW_CMD(\"ZSCORE\", redis_kv_cmd, cluster_dbl_resp, 1);\n}\n/* }}} */\n\nPHP_METHOD(RedisCluster, zmscore) {\n    CLUSTER_PROCESS_KW_CMD(\"ZMSCORE\", redis_key_varval_cmd, cluster_mbulk_dbl_resp, 1);\n}\n\n/* {{{ proto long RedisCluster::zadd(string key,double score,string mem, ...) */\nPHP_METHOD(RedisCluster, zadd) {\n    CLUSTER_PROCESS_CMD(zadd, cluster_zadd_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto double RedisCluster::zincrby(string key, double by, string mem) */\nPHP_METHOD(RedisCluster, zincrby) {\n    CLUSTER_PROCESS_CMD(zincrby, cluster_dbl_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto RedisCluster::zremrangebyscore(string k, string s, string e) */\nPHP_METHOD(RedisCluster, zremrangebyscore) {\n    CLUSTER_PROCESS_KW_CMD(\"ZREMRANGEBYSCORE\", redis_key_str_str_cmd,\n        cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto RedisCluster::zcount(string key, string s, string e) */\nPHP_METHOD(RedisCluster, zcount) {\n    CLUSTER_PROCESS_KW_CMD(\"ZCOUNT\", redis_key_str_str_cmd, cluster_long_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::zrank(string key, mixed member) */\nPHP_METHOD(RedisCluster, zrank) {\n    CLUSTER_PROCESS_KW_CMD(\"ZRANK\", redis_kv_cmd, cluster_long_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::zrevrank(string key, mixed member) */\nPHP_METHOD(RedisCluster, zrevrank) {\n    CLUSTER_PROCESS_KW_CMD(\"ZREVRANK\", redis_kv_cmd, cluster_long_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::hlen(string key) */\nPHP_METHOD(RedisCluster, hlen) {\n    CLUSTER_PROCESS_KW_CMD(\"HLEN\", redis_key_cmd, cluster_long_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::hkeys(string key) */\nPHP_METHOD(RedisCluster, hkeys) {\n    CLUSTER_PROCESS_KW_CMD(\"HKEYS\", redis_key_cmd, cluster_mbulk_raw_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::hvals(string key) */\nPHP_METHOD(RedisCluster, hvals) {\n    CLUSTER_PROCESS_KW_CMD(\"HVALS\", redis_key_cmd, cluster_mbulk_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto string RedisCluster::hget(string key, string mem) */\nPHP_METHOD(RedisCluster, hget) {\n    CLUSTER_PROCESS_KW_CMD(\"HGET\", redis_key_str_cmd, cluster_bulk_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::hset(string key, string mem, string val) */\nPHP_METHOD(RedisCluster, hset) {\n    CLUSTER_PROCESS_CMD(hset, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::hsetnx(string key, string mem, string val) */\nPHP_METHOD(RedisCluster, hsetnx) {\n    CLUSTER_PROCESS_CMD(hsetnx, cluster_1_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::hgetall(string key) */\nPHP_METHOD(RedisCluster, hgetall) {\n    CLUSTER_PROCESS_KW_CMD(\"HGETALL\", redis_key_cmd,\n        cluster_mbulk_zipstr_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::hexists(string key, string member) */\nPHP_METHOD(RedisCluster, hexists) {\n    CLUSTER_PROCESS_KW_CMD(\"HEXISTS\", redis_key_str_cmd, cluster_1_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::hincr(string key, string mem, long val) */\nPHP_METHOD(RedisCluster, hincrby) {\n    CLUSTER_PROCESS_CMD(hincrby, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto double RedisCluster::hincrbyfloat(string k, string m, double v) */\nPHP_METHOD(RedisCluster, hincrbyfloat) {\n    CLUSTER_PROCESS_CMD(hincrbyfloat, cluster_dbl_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::hmset(string key, array key_vals) */\nPHP_METHOD(RedisCluster, hmset) {\n    CLUSTER_PROCESS_CMD(hmset, cluster_bool_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::hrandfield(string key, [array $options]) */\nPHP_METHOD(RedisCluster, hrandfield) {\n    CLUSTER_PROCESS_CMD(hrandfield, cluster_hrandfield_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::hdel(string key, string mem1, ... memN) */\nPHP_METHOD(RedisCluster, hdel) {\n    CLUSTER_PROCESS_CMD(hdel, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::hmget(string key, array members) */\nPHP_METHOD(RedisCluster, hmget) {\n    CLUSTER_PROCESS_CMD(hmget, cluster_mbulk_assoc_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::hstrlen(string key, string field) */\nPHP_METHOD(RedisCluster, hstrlen) {\n    CLUSTER_PROCESS_CMD(hstrlen, cluster_long_resp, 1);\n}\n/* }}} */\n\n\n/* {{{ proto string RedisCluster::dump(string key) */\nPHP_METHOD(RedisCluster, dump) {\n    CLUSTER_PROCESS_KW_CMD(\"DUMP\", redis_key_cmd, cluster_bulk_raw_resp, 1);\n}\n\n/* {{{ proto long RedisCluster::incr(string key) */\nPHP_METHOD(RedisCluster, incr) {\n    CLUSTER_PROCESS_CMD(incr, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::incrby(string key, long byval) */\nPHP_METHOD(RedisCluster, incrby) {\n    CLUSTER_PROCESS_KW_CMD(\"INCRBY\", redis_key_long_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::decr(string key) */\nPHP_METHOD(RedisCluster, decr) {\n    CLUSTER_PROCESS_CMD(decr, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::decrby(string key, long byval) */\nPHP_METHOD(RedisCluster, decrby) {\n    CLUSTER_PROCESS_KW_CMD(\"DECRBY\", redis_key_long_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto double RedisCluster::incrbyfloat(string key, double val) */\nPHP_METHOD(RedisCluster, incrbyfloat) {\n    CLUSTER_PROCESS_KW_CMD(\"INCRBYFLOAT\", redis_key_dbl_cmd,\n        cluster_dbl_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto double RedisCluster::decrbyfloat(string key, double val) */\nPHP_METHOD(RedisCluster, decrbyfloat) {\n    CLUSTER_PROCESS_KW_CMD(\"DECRBYFLOAT\", redis_key_dbl_cmd,\n        cluster_dbl_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::expire(string key, long sec) */\nPHP_METHOD(RedisCluster, expire) {\n    CLUSTER_PROCESS_KW_CMD(\"EXPIRE\", redis_expire_cmd, cluster_1_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::expireat(string key, long ts) */\nPHP_METHOD(RedisCluster, expireat) {\n    CLUSTER_PROCESS_KW_CMD(\"EXPIREAT\", redis_expire_cmd, cluster_1_resp, 0);\n}\n\n/* {{{ proto bool RedisCluster::pexpire(string key, long ms) */\nPHP_METHOD(RedisCluster, pexpire) {\n    CLUSTER_PROCESS_KW_CMD(\"PEXPIRE\", redis_expire_cmd, cluster_1_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::pexpireat(string key, long ts) */\nPHP_METHOD(RedisCluster, pexpireat) {\n    CLUSTER_PROCESS_KW_CMD(\"PEXPIREAT\", redis_expire_cmd, cluster_1_resp, 0);\n}\n/* }}} */\n\n/* {{{ Redis::expiretime(string $key): int */\nPHP_METHOD(RedisCluster, expiretime) {\n    CLUSTER_PROCESS_KW_CMD(\"EXPIRETIME\", redis_key_cmd, cluster_long_resp, 1);\n}\n\n/* {{{ Redis::pexpiretime(string $key): int */\nPHP_METHOD(RedisCluster, pexpiretime) {\n    CLUSTER_PROCESS_KW_CMD(\"PEXPIRETIME\", redis_key_cmd, cluster_long_resp, 1);\n}\n\n/* {{{ proto long RedisCluster::append(string key, string val) */\nPHP_METHOD(RedisCluster, append) {\n    CLUSTER_PROCESS_KW_CMD(\"APPEND\", redis_kv_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::getbit(string key, long val) */\nPHP_METHOD(RedisCluster, getbit) {\n    CLUSTER_PROCESS_KW_CMD(\"GETBIT\", redis_key_long_cmd, cluster_long_resp, 1);\n}\n/* }}} */\n\nPHP_METHOD(RedisCluster, expiremember) {\n    CLUSTER_PROCESS_CMD(expiremember, cluster_long_resp, 0);\n}\n\nPHP_METHOD(RedisCluster, expirememberat) {\n    CLUSTER_PROCESS_CMD(expiremember, cluster_long_resp, 0);\n}\n\n/* {{{ proto long RedisCluster::setbit(string key, long offset, bool onoff) */\nPHP_METHOD(RedisCluster, setbit) {\n    CLUSTER_PROCESS_CMD(setbit, cluster_long_resp, 0);\n}\n\n/* {{{ proto long RedisCluster::bitop(string op,string key,[string key2,...]) */\nPHP_METHOD(RedisCluster, bitop)\n{\n    CLUSTER_PROCESS_CMD(bitop, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::bitcount(string key, [int start, int end]) */\nPHP_METHOD(RedisCluster, bitcount) {\n    CLUSTER_PROCESS_CMD(bitcount, cluster_long_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::bitpos(string key, int bit, [int s, int end]) */\nPHP_METHOD(RedisCluster, bitpos) {\n    CLUSTER_PROCESS_CMD(bitpos, cluster_long_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto string Redis::lget(string key, long index) */\nPHP_METHOD(RedisCluster, lget) {\n    CLUSTER_PROCESS_KW_CMD(\"LINDEX\", redis_key_long_cmd, cluster_bulk_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto string RedisCluster::getrange(string key, long start, long end) */ PHP_METHOD(RedisCluster, getrange) {\n    CLUSTER_PROCESS_KW_CMD(\"GETRANGE\", redis_key_long_long_cmd,\n        cluster_bulk_resp, 1);\n}\n/* }}} */\n\n/* {{{ prot RedisCluster::lcs(string $key1, string $key2, ?array $options = NULL): mixed; */\nPHP_METHOD(RedisCluster, lcs) {\n    CLUSTER_PROCESS_CMD(lcs, cluster_variant_resp, 1);\n}\n\n/* {{{ proto Redis|array|false Redis::lmpop(array $keys, string $from, int $count = 1) */\nPHP_METHOD(RedisCluster, lmpop) {\n    CLUSTER_PROCESS_KW_CMD(\"LMPOP\", redis_mpop_cmd, cluster_mpop_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto Redis|array|false Redis::blmpop(double $timeout, array $keys, string $from, int $count = 1) */\nPHP_METHOD(RedisCluster, blmpop) {\n    CLUSTER_PROCESS_KW_CMD(\"BLMPOP\", redis_mpop_cmd, cluster_mpop_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto Redis|array|false Redis::zmpop(array $keys, string $from, int $count = 1) */\nPHP_METHOD(RedisCluster, zmpop) {\n    CLUSTER_PROCESS_KW_CMD(\"ZMPOP\", redis_mpop_cmd, cluster_mpop_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto Redis|array|false Redis::bzmpop(double $timeout, array $keys, string $from, int $count = 1) */\nPHP_METHOD(RedisCluster, bzmpop) {\n    CLUSTER_PROCESS_KW_CMD(\"BZMPOP\", redis_mpop_cmd, cluster_mpop_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto string RedisCluster::ltrim(string key, long start, long end) */\nPHP_METHOD(RedisCluster, ltrim) {\n    CLUSTER_PROCESS_KW_CMD(\"LTRIM\", redis_key_long_long_cmd, cluster_bool_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::lrange(string key, long start, long end) */\nPHP_METHOD(RedisCluster, lrange) {\n    CLUSTER_PROCESS_KW_CMD(\"LRANGE\", redis_key_long_long_cmd,\n        cluster_mbulk_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::zremrangebyrank(string k, long s, long e) */\nPHP_METHOD(RedisCluster, zremrangebyrank) {\n    CLUSTER_PROCESS_KW_CMD(\"ZREMRANGEBYRANK\", redis_key_long_long_cmd,\n        cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::publish(string key, string msg) */\nPHP_METHOD(RedisCluster, publish) {\n    CLUSTER_PROCESS_KW_CMD(\"PUBLISH\", redis_key_str_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::rename(string key1, string key2) */\nPHP_METHOD(RedisCluster, rename) {\n    CLUSTER_PROCESS_KW_CMD(\"RENAME\", redis_key_key_cmd, cluster_bool_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::renamenx(string key1, string key2) */\nPHP_METHOD(RedisCluster, renamenx) {\n    CLUSTER_PROCESS_KW_CMD(\"RENAMENX\", redis_key_key_cmd, cluster_1_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::pfcount(string key) */\nPHP_METHOD(RedisCluster, pfcount) {\n    CLUSTER_PROCESS_CMD(pfcount, cluster_long_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::pfadd(string key, array vals) */\nPHP_METHOD(RedisCluster, pfadd) {\n    CLUSTER_PROCESS_CMD(pfadd, cluster_1_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::pfmerge(string key, array keys) */\nPHP_METHOD(RedisCluster, pfmerge) {\n    CLUSTER_PROCESS_CMD(pfmerge, cluster_bool_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto boolean RedisCluster::restore(string key, long ttl, string val) */\nPHP_METHOD(RedisCluster, restore) {\n    CLUSTER_PROCESS_CMD(restore, cluster_bool_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::setrange(string key, long offset, string val) */\nPHP_METHOD(RedisCluster, setrange) {\n    CLUSTER_PROCESS_KW_CMD(\"SETRANGE\", redis_key_long_str_cmd,\n        cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto\n *     array RedisCluster::zrange(string k, long s, long e, bool score = 0) */\nPHP_METHOD(RedisCluster, zrange) {\n    CLUSTER_PROCESS_KW_CMD(\"ZRANGE\", redis_zrange_cmd, cluster_zrange_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto\n *     array RedisCluster::zrange(string $dstkey, string $srckey, long s, long e, array|bool $options = false) */\nPHP_METHOD(RedisCluster, zrangestore) {\n    CLUSTER_PROCESS_KW_CMD(\"ZRANGESTORE\", redis_zrange_cmd, cluster_long_resp, 0);\n}\n\n/* }}} */\n/* {{{ proto\n *     array RedisCluster::zrevrange(string k,long s,long e,bool scores = 0) */\nPHP_METHOD(RedisCluster, zrevrange) {\n    CLUSTER_PROCESS_KW_CMD(\"ZREVRANGE\", redis_zrange_cmd, cluster_zrange_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto array\n *     RedisCluster::zrangebyscore(string k, long s, long e, array opts) */\nPHP_METHOD(RedisCluster, zrangebyscore) {\n    CLUSTER_PROCESS_KW_CMD(\"ZRANGEBYSCORE\", redis_zrange_cmd, cluster_zrange_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto RedisCluster::zunionstore(string dst, array keys, [array weights,\n *                                     string agg]) */\nPHP_METHOD(RedisCluster, zunionstore) {\n    CLUSTER_PROCESS_KW_CMD(\"ZUNIONSTORE\", redis_zinterunionstore_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\nPHP_METHOD(RedisCluster, zdiff) {\n    CLUSTER_PROCESS_CMD(zdiff, cluster_zdiff_resp, 1);\n}\n\nPHP_METHOD(RedisCluster, zdiffstore) {\n    CLUSTER_PROCESS_CMD(zdiffstore, cluster_long_resp, 0);\n}\n\nPHP_METHOD(RedisCluster, zinter) {\n    CLUSTER_PROCESS_KW_CMD(\"ZUNION\", redis_zinterunion_cmd, cluster_zdiff_resp, 1);\n}\n\nPHP_METHOD(RedisCluster, zunion) {\n    CLUSTER_PROCESS_KW_CMD(\"ZINTER\", redis_zinterunion_cmd, cluster_zdiff_resp, 1);\n}\n\n/* {{{ proto array RedisCluster::zrandmember(string key, array options) */\nPHP_METHOD(RedisCluster, zrandmember) {\n    CLUSTER_PROCESS_CMD(zrandmember, cluster_zrandmember_resp, 1);\n}\n\n/* }}} */\n/* {{{ proto RedisCluster::zinterstore(string dst, array keys, [array weights,\n *                                     string agg]) */\nPHP_METHOD(RedisCluster, zinterstore) {\n    CLUSTER_PROCESS_KW_CMD(\"ZINTERSTORE\", redis_zinterunionstore_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto RedisCluster::zintercard(array $keys, int $count = -1) */\nPHP_METHOD(RedisCluster, zintercard) {\n    CLUSTER_PROCESS_KW_CMD(\"ZINTERCARD\", redis_intercard_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto RedisCluster::zrem(string key, string val1, ... valN) */\nPHP_METHOD(RedisCluster, zrem) {\n    CLUSTER_PROCESS_KW_CMD(\"ZREM\", redis_key_varval_cmd, cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto array\n *     RedisCluster::zrevrangebyscore(string k, long s, long e, array opts) */\nPHP_METHOD(RedisCluster, zrevrangebyscore) {\n    CLUSTER_PROCESS_KW_CMD(\"ZREVRANGEBYSCORE\", redis_zrange_cmd, cluster_zrange_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::zrangebylex(string key, string min, string max,\n *                                           [offset, count]) */\nPHP_METHOD(RedisCluster, zrangebylex) {\n    CLUSTER_PROCESS_KW_CMD(\"ZRANGEBYLEX\", redis_zrangebylex_cmd,\n        cluster_mbulk_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::zrevrangebylex(string key, string min,\n *                                              string min, [long off, long limit) */\nPHP_METHOD(RedisCluster, zrevrangebylex) {\n    CLUSTER_PROCESS_KW_CMD(\"ZREVRANGEBYLEX\", redis_zrangebylex_cmd,\n        cluster_mbulk_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::zlexcount(string key, string min, string max) */\nPHP_METHOD(RedisCluster, zlexcount) {\n    CLUSTER_PROCESS_KW_CMD(\"ZLEXCOUNT\", redis_gen_zlex_cmd, cluster_long_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::zremrangebylex(string key, string min, string max) */\nPHP_METHOD(RedisCluster, zremrangebylex) {\n    CLUSTER_PROCESS_KW_CMD(\"ZREMRANGEBYLEX\", redis_gen_zlex_cmd,\n        cluster_long_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::zpopmax(string key) */\nPHP_METHOD(RedisCluster, zpopmax) {\n    if (ZEND_NUM_ARGS() == 1) {\n        CLUSTER_PROCESS_KW_CMD(\"ZPOPMAX\", redis_key_cmd, cluster_mbulk_zipdbl_resp, 0);\n    } else if (ZEND_NUM_ARGS() == 2) {\n        CLUSTER_PROCESS_KW_CMD(\"ZPOPMAX\", redis_key_long_cmd, cluster_mbulk_zipdbl_resp, 0);\n    } else {\n        ZEND_WRONG_PARAM_COUNT();\n    }\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::zpopmin(string key) */\nPHP_METHOD(RedisCluster, zpopmin) {\n    if (ZEND_NUM_ARGS() == 1) {\n        CLUSTER_PROCESS_KW_CMD(\"ZPOPMIN\", redis_key_cmd, cluster_mbulk_zipdbl_resp, 0);\n    } else if (ZEND_NUM_ARGS() == 2) {\n        CLUSTER_PROCESS_KW_CMD(\"ZPOPMIN\", redis_key_long_cmd, cluster_mbulk_zipdbl_resp, 0);\n    } else {\n        ZEND_WRONG_PARAM_COUNT();\n    }\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::bzPopMin(Array keys [, timeout]) }}} */\nPHP_METHOD(RedisCluster, bzpopmax) {\n    CLUSTER_PROCESS_KW_CMD(\"BZPOPMAX\", redis_blocking_pop_cmd, cluster_mbulk_resp, 0);\n}\n\n/* {{{ proto array RedisCluster::bzPopMax(Array keys [, timeout]) }}} */\nPHP_METHOD(RedisCluster, bzpopmin) {\n    CLUSTER_PROCESS_KW_CMD(\"BZPOPMIN\", redis_blocking_pop_cmd, cluster_mbulk_resp, 0);\n}\n\n/* {{{ proto RedisCluster::sort(string key, array options) */\nPHP_METHOD(RedisCluster, sort) {\n    CLUSTER_PROCESS_KW_CMD(\"SORT\", redis_sort_cmd, cluster_variant_resp, 0);\n}\n\n/* {{{ proto RedisCluster::sort_ro(string key, array options) */\nPHP_METHOD(RedisCluster, sort_ro) {\n    CLUSTER_PROCESS_KW_CMD(\"SORT_RO\", redis_sort_cmd, cluster_variant_resp, 1);\n}\n\n/* {{{ proto RedisCluster::object(string subcmd, string key) */\nPHP_METHOD(RedisCluster, object) {\n    CLUSTER_PROCESS_CMD(object, cluster_object_resp, 1);\n}\n\n/* {{{ proto null RedisCluster::subscribe(array chans, callable cb) */\nPHP_METHOD(RedisCluster, subscribe) {\n    CLUSTER_PROCESS_KW_CMD(\"SUBSCRIBE\", redis_subscribe_cmd, cluster_sub_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto null RedisCluster::psubscribe(array pats, callable cb) */\nPHP_METHOD(RedisCluster, psubscribe) {\n    CLUSTER_PROCESS_KW_CMD(\"PSUBSCRIBE\", redis_subscribe_cmd, cluster_sub_resp, 0);\n}\n/* }}} */\n\nstatic void generic_unsub_cmd(INTERNAL_FUNCTION_PARAMETERS, redisCluster *c,\n                              char *kw)\n{\n    char *cmd;\n    int cmd_len;\n    void *ctx;\n    short slot;\n\n    // There is not reason to unsubscribe outside of a subscribe loop\n    if (c->subscribed_slot == -1) {\n        php_error_docref(0, E_WARNING,\n            \"You can't unsubscribe outside of a subscribe loop\");\n        RETURN_FALSE;\n    }\n\n    // Call directly because we're going to set the slot manually\n    if (redis_unsubscribe_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, c->flags, kw,\n                             &cmd, &cmd_len, &slot, &ctx)\n                             == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    // This has to operate on our subscribe slot\n    if (cluster_send_slot(c, c->subscribed_slot, cmd, cmd_len, TYPE_MULTIBULK\n                        ) == FAILURE)\n    {\n        CLUSTER_THROW_EXCEPTION(\"Failed to UNSUBSCRIBE within our subscribe loop!\", 0);\n        RETURN_FALSE;\n    }\n\n    // Now process response from the slot we're subscribed on\n    cluster_unsub_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, ctx);\n\n    // Cleanup our command\n    efree(cmd);\n}\n\n/* {{{ proto array RedisCluster::unsubscribe(array chans) */\nPHP_METHOD(RedisCluster, unsubscribe) {\n    generic_unsub_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, GET_CONTEXT(),\n        \"UNSUBSCRIBE\");\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::punsubscribe(array pats) */\nPHP_METHOD(RedisCluster, punsubscribe) {\n    generic_unsub_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, GET_CONTEXT(),\n        \"PUNSUBSCRIBE\");\n}\n/* }}} */\n\n/* {{{ proto mixed RedisCluster::eval(string script, [array args, int numkeys) */\nPHP_METHOD(RedisCluster, eval) {\n    CLUSTER_PROCESS_KW_CMD(\"EVAL\", redis_eval_cmd, cluster_variant_raw_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto mixed RedisCluster::eval_ro(string script, [array args, int numkeys) */\nPHP_METHOD(RedisCluster, eval_ro) {\n    CLUSTER_PROCESS_KW_CMD(\"EVAL_RO\", redis_eval_cmd, cluster_variant_raw_resp, 1);\n}\n/* }}} */\n\n/* {{{ proto mixed RedisCluster::evalsha(string sha, [array args, int numkeys]) */\nPHP_METHOD(RedisCluster, evalsha) {\n    CLUSTER_PROCESS_KW_CMD(\"EVALSHA\", redis_eval_cmd, cluster_variant_raw_resp, 0);\n}\n/* }}} */\n\n/* {{{ proto mixed RedisCluster::evalsha_ro(string sha, [array args, int numkeys]) */\nPHP_METHOD(RedisCluster, evalsha_ro) {\n    CLUSTER_PROCESS_KW_CMD(\"EVALSHA_RO\", redis_eval_cmd, cluster_variant_raw_resp, 1);\n}\n\n/* }}} */\n/* Commands that do not interact with Redis, but just report stuff about\n * various options, etc */\n\n/* {{{ proto string RedisCluster::getmode() */\nPHP_METHOD(RedisCluster, getmode) {\n    redisCluster *c = GET_CONTEXT();\n    RETURN_LONG(c->flags->mode);\n}\n/* }}} */\n\n/* {{{ proto string RedisCluster::getlasterror() */\nPHP_METHOD(RedisCluster, getlasterror) {\n    redisCluster *c = GET_CONTEXT();\n\n    if (c->err) {\n        RETURN_STRINGL(ZSTR_VAL(c->err), ZSTR_LEN(c->err));\n    }\n    RETURN_NULL();\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::clearlasterror() */\nPHP_METHOD(RedisCluster, clearlasterror) {\n    redisCluster *c = GET_CONTEXT();\n\n    if (c->err) {\n        zend_string_release(c->err);\n        c->err = NULL;\n    }\n\n    RETURN_TRUE;\n}\n\nstatic void redisSumNodeBytes(redisClusterNode *node, zend_long *tx, zend_long *rx) {\n    struct redisClusterNode *slave;\n\n    *tx += node->sock->txBytes;\n    *rx += node->sock->rxBytes;\n\n    if (node->slaves) {\n        ZEND_HASH_FOREACH_PTR(node->slaves, slave) {\n            *tx += slave->sock->txBytes;\n            *rx += slave->sock->rxBytes;\n        } ZEND_HASH_FOREACH_END();\n    }\n}\n\nstatic void redisClearNodeBytes(redisClusterNode *node) {\n    struct redisClusterNode *slave;\n\n    node->sock->txBytes = 0;\n    node->sock->rxBytes = 0;\n\n    if (node->slaves) {\n        ZEND_HASH_FOREACH_PTR(node->slaves, slave) {\n            slave->sock->txBytes = 0;\n            slave->sock->rxBytes = 0;\n        } ZEND_HASH_FOREACH_END();\n    }\n}\n\nPHP_METHOD(RedisCluster, gettransferredbytes) {\n    redisCluster *c = GET_CONTEXT();\n    zend_long rx = 0, tx = 0;\n    redisClusterNode *node;\n\n    ZEND_HASH_FOREACH_PTR(c->nodes, node) {\n        redisSumNodeBytes(node, &tx, &rx);\n    } ZEND_HASH_FOREACH_END();\n\n    array_init_size(return_value, 2);\n    add_next_index_long(return_value, tx);\n    add_next_index_long(return_value, rx);\n}\n/* }}} */\n\nPHP_METHOD(RedisCluster, cleartransferredbytes) {\n    redisCluster *c = GET_CONTEXT();\n    redisClusterNode *node;\n\n    ZEND_HASH_FOREACH_PTR(c->nodes, node) {\n        redisClearNodeBytes(node);\n    } ZEND_HASH_FOREACH_END();\n}\n\n/* {{{ proto long RedisCluster::getOption(long option */\nPHP_METHOD(RedisCluster, getoption) {\n    redisCluster *c = GET_CONTEXT();\n    redis_getoption_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, c->flags, c);\n}\n/* }}} */\n\n/* {{{ proto bool RedisCluster::setOption(long option, mixed value) */\nPHP_METHOD(RedisCluster, setoption) {\n    redisCluster *c = GET_CONTEXT();\n    redis_setoption_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, c->flags, c);\n}\n/* }}} */\n\n/* {{{ proto string RedisCluster::_prefix(string key) */\nPHP_METHOD(RedisCluster, _prefix) {\n    redisCluster *c = GET_CONTEXT();\n    redis_prefix_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, c->flags);\n}\n/* }}} */\n\n/* {{{ proto string RedisCluster::_serialize(mixed val) */\nPHP_METHOD(RedisCluster, _serialize) {\n    redisCluster *c = GET_CONTEXT();\n    redis_serialize_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, c->flags);\n}\n/* }}} */\n\n/* {{{ proto mixed RedisCluster::_unserialize(string val) */\nPHP_METHOD(RedisCluster, _unserialize) {\n    redisCluster *c = GET_CONTEXT();\n    redis_unserialize_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU,\n        c->flags, redis_cluster_exception_ce);\n}\n/* }}} */\n\nPHP_METHOD(RedisCluster, _compress) {\n    redisCluster *c = GET_CONTEXT();\n    redis_compress_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, c->flags);\n}\n\nPHP_METHOD(RedisCluster, _uncompress) {\n    redisCluster *c = GET_CONTEXT();\n    redis_uncompress_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, c->flags,\n                             redis_cluster_exception_ce);\n}\n\nPHP_METHOD(RedisCluster, _pack) {\n    redisCluster *c = GET_CONTEXT();\n    redis_pack_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, c->flags);\n}\n\nPHP_METHOD(RedisCluster, _unpack) {\n    redisCluster *c = GET_CONTEXT();\n    redis_unpack_handler(INTERNAL_FUNCTION_PARAM_PASSTHRU, c->flags);\n}\n\n/* {{{ proto array RedisCluster::_masters() */\nPHP_METHOD(RedisCluster, _masters) {\n    redisCluster *c = GET_CONTEXT();\n    redisClusterNode *node;\n\n    array_init(return_value);\n\n    ZEND_HASH_FOREACH_PTR(c->nodes, node) {\n        if (node == NULL) break;\n\n        zval z_sub;\n\n        array_init(&z_sub);\n\n        add_next_index_stringl(&z_sub, ZSTR_VAL(node->sock->host), ZSTR_LEN(node->sock->host));\n        add_next_index_long(&z_sub, node->sock->port);\n        add_next_index_zval(return_value, &z_sub);\n    } ZEND_HASH_FOREACH_END();\n}\n\nPHP_METHOD(RedisCluster, _redir) {\n    redisCluster *c = GET_CONTEXT();\n    char buf[255];\n    size_t len;\n\n    len = snprintf(buf, sizeof(buf), \"%s:%d\", c->redir_host, c->redir_port);\n    if (*c->redir_host && c->redir_host_len) {\n        RETURN_STRINGL(buf, len);\n    } else {\n        RETURN_NULL();\n    }\n}\n\n/*\n * Transaction handling\n */\n\n/* {{{ proto bool RedisCluster::multi() */\nPHP_METHOD(RedisCluster, multi) {\n    redisCluster *c = GET_CONTEXT();\n    zend_long value = MULTI;\n\n    ZEND_PARSE_PARAMETERS_START(0, 1)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_LONG(value)\n    ZEND_PARSE_PARAMETERS_END();\n\n    if (value != MULTI) {\n        php_error_docref(NULL, E_WARNING, \"RedisCluster does not support PIPELINING\");\n    }\n\n    if (c->flags->mode == MULTI) {\n        php_error_docref(NULL, E_WARNING,\n            \"RedisCluster is already in MULTI mode, ignoring\");\n        RETURN_FALSE;\n    }\n\n    /* Flag that we're in MULTI mode */\n    c->flags->mode = MULTI;\n\n    c->flags->txBytes = 0;\n    c->flags->rxBytes = 0;\n\n    /* Return our object so we can chain MULTI calls */\n    RETVAL_ZVAL(getThis(), 1, 0);\n}\n\n/* {{{ proto bool RedisCluster::watch() */\nPHP_METHOD(RedisCluster, watch) {\n    redisCluster *c = GET_CONTEXT();\n    HashTable *ht_dist;\n    clusterDistList *dl;\n    smart_string cmd = {0};\n    zval *z_args;\n    int argc = ZEND_NUM_ARGS(), i;\n    zend_ulong slot;\n    zend_string *zstr;\n\n    // Disallow in MULTI mode\n    if (c->flags->mode == MULTI) {\n        php_error_docref(NULL, E_WARNING,\n            \"WATCH command not allowed in MULTI mode\");\n        RETURN_FALSE;\n    }\n\n    // Don't need to process zero arguments\n    if (!argc) RETURN_FALSE;\n\n    // Create our distribution HashTable\n    ht_dist = cluster_dist_create();\n\n    // Allocate args, and grab them\n    z_args = emalloc(sizeof(zval) * argc);\n    if (zend_get_parameters_array(ht, argc, z_args) == FAILURE) {\n        efree(z_args);\n        cluster_dist_free(ht_dist);\n        RETURN_FALSE;\n    }\n\n    // Loop through arguments, prefixing if needed\n    for(i = 0 ; i < argc; i++) {\n        // We'll need the key as a string\n        zstr = zval_get_string(&z_args[i]);\n\n        // Add this key to our distribution handler\n        if (cluster_dist_add_key(c, ht_dist, ZSTR_VAL(zstr), ZSTR_LEN(zstr), NULL) == FAILURE) {\n            CLUSTER_THROW_EXCEPTION(\"Can't issue WATCH command as the keyspace isn't fully mapped\", 0);\n            zend_string_release(zstr);\n            RETURN_FALSE;\n        }\n        zend_string_release(zstr);\n    }\n\n    // Iterate over each node we'll be sending commands to\n    ZEND_HASH_FOREACH_PTR(ht_dist, dl) {\n        // Grab the clusterDistList pointer itself\n        if (dl == NULL) {\n            CLUSTER_THROW_EXCEPTION(\"Internal error in a PHP HashTable\", 0);\n            cluster_dist_free(ht_dist);\n            efree(z_args);\n            efree(cmd.c);\n            RETURN_FALSE;\n        } else if (zend_hash_get_current_key(ht_dist, NULL, &slot) != HASH_KEY_IS_LONG) {\n            break;\n        }\n\n        // Construct our watch command for this node\n        redis_cmd_init_sstr(&cmd, dl->len, \"WATCH\", sizeof(\"WATCH\")-1);\n        for (i = 0; i < dl->len; i++) {\n            redis_cmd_append_sstr(&cmd, dl->entry[i].key,\n                dl->entry[i].key_len);\n        }\n\n        // If we get a failure from this, we have to abort\n        if (cluster_send_command(c,(short)slot,cmd.c,cmd.len) ==-1) {\n            RETURN_FALSE;\n        }\n\n        // This node is watching\n        SLOT_SOCK(c, (short)slot)->watching = 1;\n\n        // Zero out our command buffer\n        cmd.len = 0;\n    } ZEND_HASH_FOREACH_END();\n\n    // Cleanup\n    cluster_dist_free(ht_dist);\n    efree(z_args);\n    efree(cmd.c);\n\n    RETURN_TRUE;\n}\n\n/* {{{ proto bool RedisCluster::unwatch() */\nPHP_METHOD(RedisCluster, unwatch) {\n    redisCluster *c = GET_CONTEXT();\n    short slot;\n\n    // Send UNWATCH to nodes that need it\n    for(slot = 0; slot < REDIS_CLUSTER_SLOTS; slot++) {\n        if (c->master[slot] && SLOT_SOCK(c,slot)->watching) {\n            if (cluster_send_slot(c, slot, RESP_UNWATCH_CMD,\n                                 sizeof(RESP_UNWATCH_CMD)-1,\n                                 TYPE_LINE) ==-1)\n            {\n                CLUSTER_RETURN_BOOL(c, 0);\n            }\n\n            // No longer watching\n            SLOT_SOCK(c,slot)->watching = 0;\n        }\n    }\n\n    CLUSTER_RETURN_BOOL(c, 1);\n}\n\n/* {{{ proto array RedisCluster::exec() */\nPHP_METHOD(RedisCluster, exec) {\n    redisCluster *c = GET_CONTEXT();\n    clusterFoldItem *fi;\n\n    // Verify we are in fact in multi mode\n    if (CLUSTER_IS_ATOMIC(c)) {\n        php_error_docref(NULL, E_WARNING, \"RedisCluster is not in MULTI mode\");\n        RETURN_FALSE;\n    }\n\n    // First pass, send EXEC and abort on failure\n    fi = c->multi_head;\n    while (fi) {\n        if (SLOT_SOCK(c, fi->slot)->mode == MULTI) {\n            if ( cluster_send_exec(c, fi->slot) < 0) {\n                cluster_abort_exec(c);\n                CLUSTER_THROW_EXCEPTION(\"Error processing EXEC across the cluster\", 0);\n\n                // Free our queue, reset MULTI state\n                CLUSTER_FREE_QUEUE(c);\n                CLUSTER_RESET_MULTI(c);\n\n                RETURN_FALSE;\n            }\n            SLOT_SOCK(c, fi->slot)->mode     = ATOMIC;\n            SLOT_SOCK(c, fi->slot)->watching = 0;\n        }\n        fi = fi->next;\n    }\n\n    // MULTI multi-bulk response handler\n    cluster_multi_mbulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n\n    // Free our callback queue, any enqueued distributed command context items\n    // and reset our MULTI state.\n    CLUSTER_FREE_QUEUE(c);\n    CLUSTER_RESET_MULTI(c);\n}\n\n/* {{{ proto bool RedisCluster::discard() */\nPHP_METHOD(RedisCluster, discard) {\n    redisCluster *c = GET_CONTEXT();\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        php_error_docref(NULL, E_WARNING, \"Cluster is not in MULTI mode\");\n        RETURN_FALSE;\n    }\n\n    if (cluster_abort_exec(c) < 0) {\n        CLUSTER_RESET_MULTI(c);\n    }\n\n    CLUSTER_FREE_QUEUE(c);\n\n    RETURN_TRUE;\n}\n\n/* Get a slot either by key (string) or host/port array */\nstatic short\ncluster_cmd_get_slot(redisCluster *c, zval *z_arg)\n{\n    size_t key_len;\n    int key_free;\n    zval *z_host, *z_port;\n    short slot;\n    char *key;\n    zend_string *zstr;\n\n    /* If it's a string, treat it as a key.  Otherwise, look for a two\n     * element array */\n    if (Z_TYPE_P(z_arg) ==IS_STRING || Z_TYPE_P(z_arg) ==IS_LONG ||\n       Z_TYPE_P(z_arg) ==IS_DOUBLE)\n    {\n        /* Allow for any scalar here */\n        zstr = zval_get_string(z_arg);\n        key = ZSTR_VAL(zstr);\n        key_len = ZSTR_LEN(zstr);\n\n        /* Hash it */\n        key_free = redis_key_prefix(c->flags, &key, &key_len);\n        slot = cluster_hash_key(key, key_len);\n        zend_string_release(zstr);\n        if (key_free) efree(key);\n    } else if (Z_TYPE_P(z_arg) == IS_ARRAY &&\n        (z_host = zend_hash_index_find(Z_ARRVAL_P(z_arg), 0)) != NULL &&\n        (z_port = zend_hash_index_find(Z_ARRVAL_P(z_arg), 1)) != NULL &&\n        Z_TYPE_P(z_host) == IS_STRING && Z_TYPE_P(z_port) == IS_LONG\n    ) {\n        /* Attempt to find this specific node by host:port */\n        slot = cluster_find_slot(c,(const char *)Z_STRVAL_P(z_host),\n            (unsigned short)Z_LVAL_P(z_port));\n\n        /* Inform the caller if they've passed bad data */\n        if (slot < 0) {\n            php_error_docref(0, E_WARNING, \"Unknown node %s:\" ZEND_LONG_FMT,\n                Z_STRVAL_P(z_host), Z_LVAL_P(z_port));\n        }\n    } else {\n        php_error_docref(0, E_WARNING,\n            \"Directed commands must be passed a key or [host,port] array\");\n        return -1;\n    }\n\n    return slot;\n}\n\n/* Generic handler for things we want directed at a given node, like SAVE,\n * BGSAVE, FLUSHDB, FLUSHALL, etc */\nstatic void\ncluster_empty_node_cmd(INTERNAL_FUNCTION_PARAMETERS, char *kw,\n                       REDIS_REPLY_TYPE reply_type, cluster_cb cb)\n{\n    redisCluster *c = GET_CONTEXT();\n    char *cmd;\n    int cmd_len;\n    zval *z_arg;\n    short slot;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"z\", &z_arg) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    // One argument means find the node (treated like a key), and two means\n    // send the command to a specific host and port\n    slot = cluster_cmd_get_slot(c, z_arg);\n    if (slot < 0) {\n        RETURN_FALSE;\n    }\n\n    // Construct our command\n    cmd_len = redis_spprintf(NULL, NULL, &cmd, kw, \"\");\n\n    // Kick off our command\n    if (cluster_send_slot(c, slot, cmd, cmd_len, reply_type) < 0) {\n        CLUSTER_THROW_EXCEPTION(\"Unable to send command at a specific node\", 0);\n        efree(cmd);\n        RETURN_FALSE;\n    }\n\n    // Our response callback\n    cb(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n\n    // Free our command\n    efree(cmd);\n}\n\nstatic void\ncluster_flush_cmd(INTERNAL_FUNCTION_PARAMETERS, char *kw, REDIS_REPLY_TYPE reply_type, cluster_cb cb)\n{\n    redisCluster *c = GET_CONTEXT();\n    char *cmd;\n    int cmd_len;\n    zval *z_arg;\n    zend_bool async = 0;\n    short slot;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"z|b\", &z_arg, &async) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    // One argument means find the node (treated like a key), and two means\n    // send the command to a specific host and port\n    slot = cluster_cmd_get_slot(c, z_arg);\n    if (slot < 0) {\n        RETURN_FALSE;\n    }\n\n    // Construct our command\n    if (async) {\n        cmd_len = redis_spprintf(NULL, NULL, &cmd, kw, \"s\", \"ASYNC\", sizeof(\"ASYNC\") - 1);\n    } else {\n        cmd_len = redis_spprintf(NULL, NULL, &cmd, kw, \"\");\n    }\n\n\n    // Kick off our command\n    if (cluster_send_slot(c, slot, cmd, cmd_len, reply_type) < 0) {\n        CLUSTER_THROW_EXCEPTION(\"Unable to send command at a specific node\", 0);\n        efree(cmd);\n        RETURN_FALSE;\n    }\n\n    // Our response callback\n    cb(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n\n    // Free our command\n    efree(cmd);\n}\n\n/* Generic routine for handling various commands which need to be directed at\n * a node, but have complex syntax.  We simply parse out the arguments and send\n * the command as constructed by the caller */\nstatic void cluster_raw_cmd(INTERNAL_FUNCTION_PARAMETERS, char *kw, int kw_len)\n{\n    redisCluster *c = GET_CONTEXT();\n    smart_string cmd = {0};\n    zval *z_args;\n    short slot;\n    int i, argc = ZEND_NUM_ARGS();\n\n    /* Commands using this pass-through don't need to be enabled in MULTI mode */\n    if (!CLUSTER_IS_ATOMIC(c)) {\n        php_error_docref(0, E_WARNING,\n            \"Command can't be issued in MULTI mode\");\n        RETURN_FALSE;\n    }\n\n    /* We at least need the key or [host,port] argument */\n    if (argc < 1) {\n        php_error_docref(0, E_WARNING,\n            \"Command requires at least an argument to direct to a node\");\n        RETURN_FALSE;\n    }\n\n    /* Allocate an array to process arguments */\n    z_args = emalloc(argc * sizeof(zval));\n\n    /* Grab args */\n    if (zend_get_parameters_array(ht, argc, z_args) == FAILURE) {\n        efree(z_args);\n        RETURN_FALSE;\n    }\n\n    /* First argument needs to be the \"where\" */\n    if ((slot = cluster_cmd_get_slot(c, &z_args[0])) < 0) {\n        efree(z_args);\n        RETURN_FALSE;\n    }\n\n    /* Initialize our command */\n    redis_cmd_init_sstr(&cmd, argc-1, kw, kw_len);\n\n    /* Iterate, appending args */\n    for(i = 1; i < argc; i++) {\n        zend_string *zstr = zval_get_string(&z_args[i]);\n        redis_cmd_append_sstr(&cmd, ZSTR_VAL(zstr), ZSTR_LEN(zstr));\n        zend_string_release(zstr);\n    }\n\n    /* Send it off */\n    if (cluster_send_slot(c, slot, cmd.c, cmd.len, TYPE_EOF) < 0) {\n        CLUSTER_THROW_EXCEPTION(\"Couldn't send command to node\", 0);\n        efree(cmd.c);\n        efree(z_args);\n        RETURN_FALSE;\n    }\n\n    /* Read the response variant */\n    cluster_variant_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n\n    efree(cmd.c);\n    efree(z_args);\n}\n\n/* Generic method for HSCAN, SSCAN, and ZSCAN */\nstatic void cluster_kscan_cmd(INTERNAL_FUNCTION_PARAMETERS,\n                              REDIS_SCAN_TYPE type)\n{\n    redisCluster *c = GET_CONTEXT();\n    char *cmd, *pat = NULL, *key = NULL;\n    size_t key_len = 0, pat_len = 0, pat_free = 0;\n    int cmd_len, key_free = 0;\n    short slot;\n    zval *z_it;\n    HashTable *hash;\n    long num_ele;\n    zend_long count = 0;\n    zend_bool completed;\n    uint64_t cursor;\n\n    // Can't be in MULTI mode\n    if (!CLUSTER_IS_ATOMIC(c)) {\n        CLUSTER_THROW_EXCEPTION(\"SCAN type commands can't be called in MULTI mode!\", 0);\n        RETURN_FALSE;\n    }\n\n    /* Parse arguments */\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz/|s!l\", &key,\n                             &key_len, &z_it, &pat, &pat_len, &count) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    /* Treat as readonly */\n    c->readonly = 1;\n\n    /* Get our scan cursor and return early if we're done */\n    cursor = redisGetScanCursor(z_it, &completed);\n    if (completed)\n        RETURN_FALSE;\n\n    // Apply any key prefix we have, get the slot\n    key_free = redis_key_prefix(c->flags, &key, &key_len);\n    slot = cluster_hash_key(key, key_len);\n\n    if (c->flags->scan & REDIS_SCAN_PREFIX) {\n        pat_free = redis_key_prefix(c->flags, &pat, &pat_len);\n    }\n\n    // If SCAN_RETRY is set, loop until we get a zero iterator or until\n    // we get non-zero elements.  Otherwise we just send the command once.\n    do {\n        /* Free our return value if we're back in the loop */\n        if (Z_TYPE_P(return_value) == IS_ARRAY) {\n            zval_dtor(return_value);\n            ZVAL_NULL(return_value);\n        }\n\n        // Create command\n        cmd_len = redis_fmt_scan_cmd(&cmd, type, key, key_len, cursor, pat, pat_len,\n            count);\n\n        // Send it off\n        if (cluster_send_command(c, slot, cmd, cmd_len) == FAILURE)\n        {\n            CLUSTER_THROW_EXCEPTION(\"Couldn't send SCAN command\", 0);\n            if (key_free) efree(key);\n            efree(cmd);\n            RETURN_FALSE;\n        }\n\n        // Read response\n        if (cluster_scan_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, type,\n                              &cursor) == FAILURE)\n        {\n            CLUSTER_THROW_EXCEPTION(\"Couldn't read SCAN response\", 0);\n            if (key_free) efree(key);\n            efree(cmd);\n            RETURN_FALSE;\n        }\n\n        // Count the elements we got back\n        hash = Z_ARRVAL_P(return_value);\n        num_ele = zend_hash_num_elements(hash);\n\n        // Free our command\n        efree(cmd);\n    } while (c->flags->scan & REDIS_SCAN_RETRY && cursor != 0 && num_ele == 0);\n\n    // Free our pattern\n    if (pat_free) efree(pat);\n\n    // Free our key\n    if (key_free) efree(key);\n\n    // Update iterator reference\n    redisSetScanCursor(z_it, cursor);\n}\n\nstatic int redis_acl_op_readonly(zend_string *op) {\n    /* Only return read-only for operations we know to be */\n    if (ZSTR_STRICMP_STATIC(op, \"LIST\") ||\n        ZSTR_STRICMP_STATIC(op, \"USERS\") ||\n        ZSTR_STRICMP_STATIC(op, \"GETUSER\") ||\n        ZSTR_STRICMP_STATIC(op, \"CAT\") ||\n        ZSTR_STRICMP_STATIC(op, \"GENPASS\") ||\n        ZSTR_STRICMP_STATIC(op, \"WHOAMI\") ||\n        ZSTR_STRICMP_STATIC(op, \"LOG\")) return 1;\n\n    return 0;\n}\n\nPHP_METHOD(RedisCluster, acl) {\n    redisCluster *c = GET_CONTEXT();\n    smart_string cmdstr = {0};\n    int argc = ZEND_NUM_ARGS(), i, readonly;\n    cluster_cb cb;\n    zend_string *zs;\n    zval *zargs;\n    void *ctx = NULL;\n    short slot;\n\n    /* ACL in cluster needs a slot argument, and then at least the op */\n    if (argc < 2) {\n        WRONG_PARAM_COUNT;\n        RETURN_FALSE;\n    }\n\n    /* Grab all our arguments and determine the command slot */\n    zargs = emalloc(argc * sizeof(*zargs));\n    if (zend_get_parameters_array(ht, argc, zargs) == FAILURE ||\n        (slot = cluster_cmd_get_slot(c, &zargs[0]) < 0))\n    {\n        efree(zargs);\n        RETURN_FALSE;\n    }\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc - 1, \"ACL\");\n\n    /* Read the op, determine if it's readonly, and add it */\n    zs = zval_get_string(&zargs[1]);\n    readonly = redis_acl_op_readonly(zs);\n    redis_cmd_append_sstr_zstr(&cmdstr, zs);\n\n    /* We have specialized handlers for GETUSER and LOG, whereas every\n     * other ACL command can be handled generically */\n    if (zend_string_equals_literal_ci(zs, \"GETUSER\")) {\n        cb = cluster_acl_getuser_resp;\n    } else if (zend_string_equals_literal_ci(zs, \"LOG\")) {\n        cb = cluster_acl_log_resp;\n    } else {\n        cb = cluster_variant_resp;\n    }\n\n    zend_string_release(zs);\n\n    /* Process remaining args */\n    for (i = 2; i < argc; i++) {\n        zs = zval_get_string(&zargs[i]);\n        redis_cmd_append_sstr_zstr(&cmdstr, zs);\n        zend_string_release(zs);\n    }\n\n    /* Can we use replicas? */\n    c->readonly = readonly && CLUSTER_IS_ATOMIC(c);\n\n    /* Kick off our command */\n    if (cluster_send_slot(c, slot, cmdstr.c, cmdstr.len, TYPE_EOF) < 0) {\n        CLUSTER_THROW_EXCEPTION(\"Unabler to send ACL command\", 0);\n        efree(zargs);\n        RETURN_FALSE;\n    }\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        cb(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else {\n        CLUSTER_ENQUEUE_RESPONSE(c, slot, cb, ctx);\n    }\n\n    efree(cmdstr.c);\n    efree(zargs);\n}\n\n/* {{{ proto RedisCluster::scan(string master, long it [, string pat, long cnt]) */\nPHP_METHOD(RedisCluster, scan) {\n    redisCluster *c = GET_CONTEXT();\n    char *cmd, *pat = NULL;\n    size_t pat_len = 0;\n    int cmd_len;\n    short slot;\n    zval *zcursor, *z_node;\n    long num_ele, pat_free = 0;\n    zend_long count = 0;\n    zend_bool completed;\n    uint64_t cursor;\n\n    /* Treat as read-only */\n    c->readonly = CLUSTER_IS_ATOMIC(c);\n\n    /* Can't be in MULTI mode */\n    if (!CLUSTER_IS_ATOMIC(c)) {\n        CLUSTER_THROW_EXCEPTION(\"SCAN type commands can't be called in MULTI mode\", 0);\n        RETURN_FALSE;\n    }\n\n    /* Parse arguments */\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"z/z|s!l\", &zcursor,\n                             &z_node, &pat, &pat_len, &count) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    /* Get the scan cursor and return early if we're done */\n    cursor = redisGetScanCursor(zcursor, &completed);\n    if (completed)\n        RETURN_FALSE;\n\n    if (c->flags->scan & REDIS_SCAN_PREFIX) {\n        pat_free = redis_key_prefix(c->flags, &pat, &pat_len);\n    }\n\n    /* With SCAN_RETRY on, loop until we get some keys, otherwise just return\n     * what Redis does, as it does */\n    do {\n        /* Free our return value if we're back in the loop */\n        if (Z_TYPE_P(return_value) == IS_ARRAY) {\n            zval_dtor(return_value);\n            ZVAL_NULL(return_value);\n        }\n\n        /* Construct our command */\n        cmd_len = redis_fmt_scan_cmd(&cmd, TYPE_SCAN, NULL, 0, cursor, pat, pat_len,\n            count);\n\n        if ((slot = cluster_cmd_get_slot(c, z_node)) < 0) {\n           RETURN_FALSE;\n        }\n\n        // Send it to the node in question\n        if (cluster_send_command(c, slot, cmd, cmd_len) < 0)\n        {\n            CLUSTER_THROW_EXCEPTION(\"Couldn't send SCAN to node\", 0);\n            efree(cmd);\n            RETURN_FALSE;\n        }\n\n        if (cluster_scan_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, TYPE_SCAN,\n                              &cursor) == FAILURE || Z_TYPE_P(return_value) != IS_ARRAY)\n        {\n            CLUSTER_THROW_EXCEPTION(\"Couldn't process SCAN response from node\", 0);\n            efree(cmd);\n            RETURN_FALSE;\n        }\n\n        efree(cmd);\n\n        num_ele = zend_hash_num_elements(Z_ARRVAL_P(return_value));\n    } while (c->flags->scan & REDIS_SCAN_RETRY && cursor != 0 && num_ele == 0);\n\n    if (pat_free) efree(pat);\n\n    redisSetScanCursor(zcursor, cursor);\n}\n/* }}} */\n\n/* {{{ proto RedisCluster::sscan(string key, long it [string pat, long cnt]) */\nPHP_METHOD(RedisCluster, sscan) {\n    cluster_kscan_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, TYPE_SSCAN);\n}\n/* }}} */\n\n/* {{{ proto RedisCluster::zscan(string key, long it [string pat, long cnt]) */\nPHP_METHOD(RedisCluster, zscan) {\n    cluster_kscan_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, TYPE_ZSCAN);\n}\n/* }}} */\n\n/* {{{ proto RedisCluster::hscan(string key, long it [string pat, long cnt]) */\nPHP_METHOD(RedisCluster, hscan) {\n    cluster_kscan_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, TYPE_HSCAN);\n}\n/* }}} */\n\n/* {{{ proto RedisCluster::save(string key)\n *     proto RedisCluster::save(array host_port) */\nPHP_METHOD(RedisCluster, save) {\n    cluster_empty_node_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"SAVE\", TYPE_LINE,\n        cluster_bool_resp);\n}\n/* }}} */\n\n/* {{{ proto RedisCluster::bgsave(string key)\n *     proto RedisCluster::bgsave(array host_port) */\nPHP_METHOD(RedisCluster, bgsave) {\n    cluster_empty_node_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"BGSAVE\",\n        TYPE_LINE, cluster_bool_resp);\n}\n/* }}} */\n\n/* {{{ proto RedisCluster::flushdb(string key, [bool async])\n *     proto RedisCluster::flushdb(array host_port, [bool async]) */\nPHP_METHOD(RedisCluster, flushdb) {\n    cluster_flush_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"FLUSHDB\",\n        TYPE_LINE, cluster_bool_resp);\n}\n/* }}} */\n\n/* {{{ proto RedisCluster::flushall(string key, [bool async])\n *     proto RedisCluster::flushall(array host_port, [bool async]) */\nPHP_METHOD(RedisCluster, flushall) {\n    cluster_flush_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"FLUSHALL\",\n        TYPE_LINE, cluster_bool_resp);\n}\n/* }}} */\n\n/* {{{ proto RedisCluster::dbsize(string key)\n *     proto RedisCluster::dbsize(array host_port) */\nPHP_METHOD(RedisCluster, dbsize) {\n    cluster_empty_node_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"DBSIZE\",\n        TYPE_INT, cluster_long_resp);\n}\n/* }}} */\n\n/* {{{ proto RedisCluster::bgrewriteaof(string key)\n *     proto RedisCluster::bgrewriteaof(array host_port) */\nPHP_METHOD(RedisCluster, bgrewriteaof) {\n    cluster_empty_node_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"BGREWRITEAOF\",\n        TYPE_LINE, cluster_bool_resp);\n}\n/* }}} */\n\n/* {{{ proto RedisCluster::lastsave(string key)\n *     proto RedisCluster::lastsave(array $host_port) */\nPHP_METHOD(RedisCluster, lastsave) {\n    cluster_empty_node_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"LASTSAVE\",\n        TYPE_INT, cluster_long_resp);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::info(string key, [string $arg])\n *     proto array RedisCluster::info(array host_port, [string $arg]) */\nPHP_METHOD(RedisCluster, info) {\n    redisCluster *c = GET_CONTEXT();\n    zval *node = NULL, *args = NULL;\n    smart_string cmdstr = {0};\n    REDIS_REPLY_TYPE rtype;\n    zend_string *section;\n    void *ctx = NULL;\n    int i, argc;\n    short slot;\n\n    ZEND_PARSE_PARAMETERS_START(1, -1)\n        Z_PARAM_ZVAL(node)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_VARIADIC('*', args, argc)\n    ZEND_PARSE_PARAMETERS_END();\n\n    if ((slot = cluster_cmd_get_slot(c, node)) < 0)\n        RETURN_FALSE;\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc, \"INFO\");\n\n    /* Direct this command at the master */\n    c->readonly = 0;\n\n    for (i = 0; i < argc; i++) {\n        section = zval_get_string(&args[i]);\n        redis_cmd_append_sstr_zstr(&cmdstr, section);\n        zend_string_release(section);\n    }\n\n    rtype = CLUSTER_IS_ATOMIC(c) ? TYPE_BULK : TYPE_LINE;\n    if (cluster_send_slot(c, slot, cmdstr.c, cmdstr.len, rtype) < 0) {\n        CLUSTER_THROW_EXCEPTION(\"Unable to send INFO command to specific node\", 0);\n        efree(cmdstr.c);\n        RETURN_FALSE;\n    }\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        cluster_info_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else {\n        CLUSTER_ENQUEUE_RESPONSE(c, slot, cluster_info_resp, ctx);\n    }\n\n    efree(cmdstr.c);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::client('list')\n *     proto bool RedisCluster::client('kill', $ipport)\n *     proto bool RedisCluster::client('setname', $name)\n *     proto string RedisCluster::client('getname')\n */\nPHP_METHOD(RedisCluster, client) {\n    redisCluster *c = GET_CONTEXT();\n    char *cmd, *opt = NULL, *arg = NULL;\n    int cmd_len;\n    size_t opt_len, arg_len = 0;\n    REDIS_REPLY_TYPE rtype;\n    zval *z_node;\n    short slot;\n    cluster_cb cb;\n\n    /* Parse args */\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"zs|s\", &z_node, &opt,\n                              &opt_len, &arg, &arg_len) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    /* Make sure we can properly resolve the slot */\n    slot = cluster_cmd_get_slot(c, z_node);\n    if (slot < 0) RETURN_FALSE;\n\n    /* Our return type and reply callback is different for all subcommands */\n    if (opt_len == 4 && !strncasecmp(opt, \"list\", 4)) {\n        rtype = CLUSTER_IS_ATOMIC(c) ? TYPE_BULK : TYPE_LINE;\n        cb = cluster_client_list_resp;\n    } else if ((opt_len == 4 && !strncasecmp(opt, \"kill\", 4)) ||\n               (opt_len == 7 && !strncasecmp(opt, \"setname\", 7)))\n    {\n        rtype = TYPE_LINE;\n        cb = cluster_bool_resp;\n    } else if (opt_len == 7 && !strncasecmp(opt, \"getname\", 7)) {\n        rtype = CLUSTER_IS_ATOMIC(c) ? TYPE_BULK : TYPE_LINE;\n        cb = cluster_bulk_resp;\n    } else {\n        php_error_docref(NULL, E_WARNING,\n            \"Invalid CLIENT subcommand (LIST, KILL, GETNAME, and SETNAME are valid\");\n        RETURN_FALSE;\n    }\n\n    /* Construct the command */\n    if (ZEND_NUM_ARGS() == 3) {\n        cmd_len = redis_spprintf(NULL, NULL, &cmd, \"CLIENT\", \"ss\",\n            opt, opt_len, arg, arg_len);\n    } else if (ZEND_NUM_ARGS() == 2) {\n        cmd_len = redis_spprintf(NULL, NULL, &cmd, \"CLIENT\", \"s\",\n            opt, opt_len);\n    } else {\n        zend_wrong_param_count();\n        RETURN_FALSE;\n    }\n\n    /* Attempt to write our command */\n    if (cluster_send_slot(c, slot, cmd, cmd_len, rtype) < 0) {\n        CLUSTER_THROW_EXCEPTION(\"Unable to send CLIENT command to specific node\", 0);\n        efree(cmd);\n        RETURN_FALSE;\n    }\n\n    /* Now enqueue or process response */\n    if (CLUSTER_IS_ATOMIC(c)) {\n        cb(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else {\n        void *ctx = NULL;\n        CLUSTER_ENQUEUE_RESPONSE(c, slot, cb, ctx);\n    }\n\n    efree(cmd);\n}\n\n/* {{{ proto mixed RedisCluster::cluster(variant) */\nPHP_METHOD(RedisCluster, cluster) {\n    cluster_raw_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"CLUSTER\",\n        sizeof(\"CLUSTER\")-1);\n}\n/* }}} */\n\n/* }}} */\n\n/* {{{ proto mixed RedisCluster::config(string key, ...)\n *     proto mixed RedisCluster::config(array host_port, ...) */\nPHP_METHOD(RedisCluster, config) {\n    cluster_raw_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"CONFIG\",\n        sizeof(\"CONFIG\")-1);\n}\n/* }}} */\n\n/* {{{ proto mixed RedisCluster::pubsub(string key, ...)\n *     proto mixed RedisCluster::pubsub(array host_port, ...) */\nPHP_METHOD(RedisCluster, pubsub) {\n    cluster_raw_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"PUBSUB\",\n        sizeof(\"PUBSUB\")-1);\n}\n/* }}} */\n\n/* {{{ proto mixed RedisCluster::script(string key, ...)\n *     proto mixed RedisCluster::script(array host_port, ...) */\nPHP_METHOD(RedisCluster, script) {\n    redisCluster *c = GET_CONTEXT();\n    smart_string cmd = {0};\n    zval *z_args;\n    short slot;\n    int argc = ZEND_NUM_ARGS();\n\n    /* Commands using this pass-through don't need to be enabled in MULTI mode */\n    if (!CLUSTER_IS_ATOMIC(c)) {\n        php_error_docref(0, E_WARNING,\n            \"Command can't be issued in MULTI mode\");\n        RETURN_FALSE;\n    }\n\n    /* We at least need the key or [host,port] argument */\n    if (argc < 2) {\n        php_error_docref(0, E_WARNING,\n            \"Command requires at least an argument to direct to a node\");\n        RETURN_FALSE;\n    }\n\n    /* Allocate an array to process arguments */\n    z_args = ecalloc(argc, sizeof(zval));\n\n    /* Grab args */\n    if (zend_get_parameters_array(ht, argc, z_args) == FAILURE ||\n        (slot = cluster_cmd_get_slot(c, &z_args[0])) < 0 ||\n        redis_build_script_cmd(&cmd, argc - 1, &z_args[1]) == NULL\n    ) {\n        efree(z_args);\n        RETURN_FALSE;\n    }\n\n    /* Send it off */\n    if (cluster_send_slot(c, slot, cmd.c, cmd.len, TYPE_EOF) < 0) {\n        CLUSTER_THROW_EXCEPTION(\"Couldn't send command to node\", 0);\n        efree(cmd.c);\n        efree(z_args);\n        RETURN_FALSE;\n    }\n\n    /* Read the response variant */\n    cluster_variant_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n\n    efree(cmd.c);\n    efree(z_args);\n}\n/* }}} */\n\n/* {{{ proto mixed RedisCluster::slowlog(string key, ...)\n *     proto mixed RedisCluster::slowlog(array host_port, ...) */\nPHP_METHOD(RedisCluster, slowlog) {\n    cluster_raw_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"SLOWLOG\",\n        sizeof(\"SLOWLOG\")-1);\n}\n/* }}} */\n\n/* {{{ proto int RedisCluster::geoadd(string key, float long float lat string mem, ...) */\nPHP_METHOD(RedisCluster, geoadd) {\n    CLUSTER_PROCESS_CMD(geoadd, cluster_long_resp, 0);\n}\n\n/* {{{ proto array RedisCluster::geohash(string key, string mem1, [string mem2...]) */\nPHP_METHOD(RedisCluster, geohash) {\n    CLUSTER_PROCESS_KW_CMD(\"GEOHASH\", redis_key_varval_cmd, cluster_mbulk_raw_resp, 1);\n}\n\n/* {{{ proto array RedisCluster::geopos(string key, string mem1, [string mem2...]) */\nPHP_METHOD(RedisCluster, geopos) {\n    CLUSTER_PROCESS_KW_CMD(\"GEOPOS\", redis_key_varval_cmd, cluster_variant_resp, 1);\n}\n\n/* {{{ proto array RedisCluster::geodist(string key, string mem1, string mem2 [string unit]) */\nPHP_METHOD(RedisCluster, geodist) {\n    CLUSTER_PROCESS_CMD(geodist, cluster_dbl_resp, 1);\n}\n\n/* {{{ proto array RedisCluster::georadius() }}} */\nPHP_METHOD(RedisCluster, georadius) {\n    CLUSTER_PROCESS_KW_CMD(\"GEORADIUS\", redis_georadius_cmd, cluster_variant_resp, 1);\n}\n\n/* {{{ proto array RedisCluster::georadius() }}} */\nPHP_METHOD(RedisCluster, georadius_ro) {\n    CLUSTER_PROCESS_KW_CMD(\"GEORADIUS_RO\", redis_georadius_cmd, cluster_variant_resp, 1);\n}\n\n/* {{{ proto array RedisCluster::georadiusbymember() }}} */\nPHP_METHOD(RedisCluster, georadiusbymember) {\n    CLUSTER_PROCESS_KW_CMD(\"GEORADIUSBYMEMBER\", redis_georadiusbymember_cmd, cluster_variant_resp, 1);\n}\n\n/* {{{ proto array RedisCluster::georadiusbymember() }}} */\nPHP_METHOD(RedisCluster, georadiusbymember_ro) {\n    CLUSTER_PROCESS_KW_CMD(\"GEORADIUSBYMEMBER_RO\", redis_georadiusbymember_cmd, cluster_variant_resp, 1);\n}\n\nPHP_METHOD(RedisCluster, geosearch) {\n    CLUSTER_PROCESS_CMD(geosearch, cluster_geosearch_resp, 1);\n}\n\nPHP_METHOD(RedisCluster, geosearchstore) {\n    CLUSTER_PROCESS_CMD(geosearchstore, cluster_long_resp, 0);\n}\n\n\n/* {{{ proto array RedisCluster::role(string key)\n *     proto array RedisCluster::role(array host_port) */\nPHP_METHOD(RedisCluster, role) {\n    cluster_empty_node_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"ROLE\",\n        TYPE_MULTIBULK, cluster_variant_resp);\n}\n\n/* {{{ proto array RedisCluster::time(string key)\n *     proto array RedisCluster::time(array host_port) */\nPHP_METHOD(RedisCluster, time) {\n    cluster_empty_node_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"TIME\",\n        TYPE_MULTIBULK, cluster_variant_resp);\n}\n/* }}} */\n\n/* {{{ proto string RedisCluster::randomkey(string key)\n *     proto string RedisCluster::randomkey(array host_port) */\nPHP_METHOD(RedisCluster, randomkey) {\n    cluster_empty_node_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, \"RANDOMKEY\",\n        TYPE_BULK, cluster_bulk_resp);\n}\n/* }}} */\n\nPHP_METHOD(RedisCluster, waitaof) {\n    zend_long numlocal, numreplicas, timeout;\n    redisCluster *c = GET_CONTEXT();\n    smart_string cmdstr = {0};\n    void *ctx = NULL;\n    short slot;\n    zval *node;\n\n    ZEND_PARSE_PARAMETERS_START(4, 4)\n        Z_PARAM_ZVAL(node)\n        Z_PARAM_LONG(numlocal)\n        Z_PARAM_LONG(numreplicas)\n        Z_PARAM_LONG(timeout)\n    ZEND_PARSE_PARAMETERS_END();\n\n    if (numlocal < 0 || numreplicas < 0 || timeout < 0) {\n        php_error_docref(NULL, E_WARNING, \"No arguments can be negative\");\n        RETURN_FALSE;\n    }\n\n    slot = cluster_cmd_get_slot(c, node);\n    if (slot < 0) {\n        RETURN_FALSE;\n    }\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 3, \"WAITAOF\");\n    redis_cmd_append_sstr_long(&cmdstr, numlocal);\n    redis_cmd_append_sstr_long(&cmdstr, numreplicas);\n    redis_cmd_append_sstr_long(&cmdstr, timeout);\n\n    c->readonly = 0;\n\n    if (cluster_send_slot(c, slot, cmdstr.c, cmdstr.len, TYPE_MULTIBULK) < 0) {\n        CLUSTER_THROW_EXCEPTION(\"Unable to send command at the specified node\", 0);\n        smart_string_free(&cmdstr);\n        RETURN_FALSE;\n    }\n\n    if (CLUSTER_IS_ATOMIC(c)) {\n        cluster_variant_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else {\n        CLUSTER_ENQUEUE_RESPONSE(c, slot, cluster_variant_resp, ctx);\n    }\n\n    smart_string_free(&cmdstr);\n}\n\n/* {{{ proto bool RedisCluster::ping(string key| string msg)\n *     proto bool RedisCluster::ping(array host_port| string msg) */\nPHP_METHOD(RedisCluster, ping) {\n    redisCluster *c = GET_CONTEXT();\n    REDIS_REPLY_TYPE rtype;\n    void *ctx = NULL;\n    zval *z_node;\n    char *cmd, *arg = NULL;\n    int cmdlen;\n    size_t arglen;\n    short slot;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"z|s!\", &z_node, &arg,\n                              &arglen) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    /* Treat this as a readonly command */\n    c->readonly = CLUSTER_IS_ATOMIC(c);\n\n    /* Grab slot either by key or host/port */\n    slot = cluster_cmd_get_slot(c, z_node);\n    if (slot < 0) {\n        RETURN_FALSE;\n    }\n\n    /* Construct our command */\n    if (arg != NULL) {\n        cmdlen = redis_spprintf(NULL, NULL, &cmd, \"PING\", \"s\", arg, arglen);\n    } else {\n        cmdlen = redis_spprintf(NULL, NULL, &cmd, \"PING\", \"\");\n    }\n\n    /* Send it off */\n    rtype = CLUSTER_IS_ATOMIC(c) && arg != NULL ? TYPE_BULK : TYPE_LINE;\n    if (cluster_send_slot(c, slot, cmd, cmdlen, rtype) < 0) {\n        CLUSTER_THROW_EXCEPTION(\"Unable to send command at the specified node\", 0);\n        efree(cmd);\n        RETURN_FALSE;\n    }\n\n    /* We're done with our command */\n    efree(cmd);\n\n    /* Process response */\n    if (CLUSTER_IS_ATOMIC(c)) {\n        if (arg != NULL) {\n            cluster_bulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n        } else {\n            /* If we're atomic and didn't send an argument then we have already\n             * processed the reply (which must have been successful. */\n            RETURN_TRUE;\n        }\n    } else {\n        if (arg != NULL) {\n            CLUSTER_ENQUEUE_RESPONSE(c, slot, cluster_bulk_resp, ctx);\n        } else {\n            CLUSTER_ENQUEUE_RESPONSE(c, slot, cluster_variant_resp, ctx);\n        }\n\n        RETURN_ZVAL(getThis(), 1, 0);\n    }\n}\n/* }}} */\n\n/* {{{ proto long RedisCluster::xack(string key, string group, array ids) }}} */\nPHP_METHOD(RedisCluster, xack) {\n    CLUSTER_PROCESS_CMD(xack, cluster_long_resp, 0);\n}\n\n/* {{{ proto string RedisCluster::xadd(string key, string id, array field_values) }}} */\nPHP_METHOD(RedisCluster, xadd) {\n    CLUSTER_PROCESS_CMD(xadd, cluster_bulk_raw_resp, 0);\n}\n\n/* {{{ proto array RedisCluster::xclaim(string key, string group, string consumer,\n *                                      long min_idle_time, array ids, array options) */\nPHP_METHOD(RedisCluster, xclaim) {\n    CLUSTER_PROCESS_CMD(xclaim, cluster_xclaim_resp, 0);\n}\n\nPHP_METHOD(RedisCluster, xautoclaim) {\n    CLUSTER_PROCESS_CMD(xautoclaim, cluster_xclaim_resp, 0);\n}\n\nPHP_METHOD(RedisCluster, xdel) {\n    CLUSTER_PROCESS_KW_CMD(\"XDEL\", redis_key_str_arr_cmd, cluster_long_resp, 0);\n}\n\n/* {{{ proto variant RedisCluster::xgroup(string op, [string key, string arg1, string arg2]) }}} */\nPHP_METHOD(RedisCluster, xgroup) {\n    CLUSTER_PROCESS_CMD(xgroup, cluster_variant_resp, 0);\n}\n\n/* {{{ proto variant RedisCluster::xinfo(string op, [string arg1, string arg2]); */\nPHP_METHOD(RedisCluster, xinfo) {\n    CLUSTER_PROCESS_CMD(xinfo, cluster_xinfo_resp, 0);\n}\n\n/* {{{ proto string RedisCluster::xlen(string key) }}} */\nPHP_METHOD(RedisCluster, xlen) {\n    CLUSTER_PROCESS_KW_CMD(\"XLEN\", redis_key_cmd, cluster_long_resp, 1);\n}\n\nPHP_METHOD(RedisCluster, xpending) {\n    CLUSTER_PROCESS_CMD(xpending, cluster_variant_resp_strings, 1);\n}\n\nPHP_METHOD(RedisCluster, xrange) {\n    CLUSTER_PROCESS_KW_CMD(\"XRANGE\", redis_xrange_cmd, cluster_xrange_resp, 1);\n}\n\nPHP_METHOD(RedisCluster, xrevrange) {\n    CLUSTER_PROCESS_KW_CMD(\"XREVRANGE\", redis_xrange_cmd, cluster_xrange_resp, 1);\n}\n\nPHP_METHOD(RedisCluster, xread) {\n    CLUSTER_PROCESS_CMD(xread, cluster_xread_resp, 1);\n}\n\nPHP_METHOD(RedisCluster, xreadgroup) {\n    CLUSTER_PROCESS_CMD(xreadgroup, cluster_xread_resp, 0);\n}\n\nPHP_METHOD(RedisCluster, xtrim) {\n    CLUSTER_PROCESS_CMD(xtrim, cluster_long_resp, 0);\n}\n\n\n\n/* {{{ proto string RedisCluster::echo(string key, string msg)\n *     proto string RedisCluster::echo(array host_port, string msg) */\nPHP_METHOD(RedisCluster, echo) {\n    redisCluster *c = GET_CONTEXT();\n    REDIS_REPLY_TYPE rtype;\n    zval *z_arg;\n    char *cmd, *msg;\n    int cmd_len;\n    size_t msg_len;\n    short slot;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"zs\", &z_arg, &msg,\n                             &msg_len) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    /* Treat this as a readonly command */\n    c->readonly = CLUSTER_IS_ATOMIC(c);\n\n    /* Grab slot either by key or host/port */\n    slot = cluster_cmd_get_slot(c, z_arg);\n    if (slot < 0) {\n        RETURN_FALSE;\n    }\n\n    /* Construct our command */\n    cmd_len = redis_spprintf(NULL, NULL, &cmd, \"ECHO\", \"s\", msg, msg_len);\n\n    /* Send it off */\n    rtype = CLUSTER_IS_ATOMIC(c) ? TYPE_BULK : TYPE_LINE;\n    if (cluster_send_slot(c,slot,cmd,cmd_len,rtype) < 0) {\n        CLUSTER_THROW_EXCEPTION(\"Unable to send command at the specified node\", 0);\n        efree(cmd);\n        RETURN_FALSE;\n    }\n\n    /* Process bulk response */\n    if (CLUSTER_IS_ATOMIC(c)) {\n        cluster_bulk_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else {\n        void *ctx = NULL;\n        CLUSTER_ENQUEUE_RESPONSE(c, slot, cluster_bulk_resp, ctx);\n    }\n\n    efree(cmd);\n}\n/* }}} */\n\n/* {{{ proto mixed RedisCluster::rawcommand(string $key, string $cmd, [ $argv1 .. $argvN])\n *     proto mixed RedisCluster::rawcommand(array $host_port, string $cmd, [ $argv1 .. $argvN]) */\nPHP_METHOD(RedisCluster, rawcommand) {\n    REDIS_REPLY_TYPE rtype;\n    int argc = ZEND_NUM_ARGS(), cmd_len;\n    redisCluster *c = GET_CONTEXT();\n    char *cmd = NULL;\n    zval *z_args;\n    short slot;\n\n    /* Sanity check on our arguments */\n    if (argc < 2) {\n        php_error_docref(NULL, E_WARNING,\n            \"You must pass at least node information as well as at least a command.\");\n        RETURN_FALSE;\n    }\n    z_args = emalloc(argc * sizeof(zval));\n    if (zend_get_parameters_array(ht, argc, z_args) == FAILURE) {\n        php_error_docref(NULL, E_WARNING,\n            \"Internal PHP error parsing method parameters.\");\n        efree(z_args);\n        RETURN_FALSE;\n    } else if (redis_build_raw_cmd(&z_args[1], argc-1, &cmd, &cmd_len) ||\n               (slot = cluster_cmd_get_slot(c, &z_args[0])) < 0)\n    {\n        if (cmd) efree(cmd);\n        efree(z_args);\n        RETURN_FALSE;\n    }\n\n    /* Free argument array */\n    efree(z_args);\n\n    /* Direct the command */\n    rtype = CLUSTER_IS_ATOMIC(c) ? TYPE_EOF : TYPE_LINE;\n    if (cluster_send_slot(c,slot,cmd,cmd_len,rtype) < 0) {\n        CLUSTER_THROW_EXCEPTION(\"Unable to send command to the specified node\", 0);\n        efree(cmd);\n        RETURN_FALSE;\n    }\n\n    /* Process variant response */\n    if (CLUSTER_IS_ATOMIC(c)) {\n        cluster_variant_raw_resp(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, NULL);\n    } else {\n        void *ctx = NULL;\n        CLUSTER_ENQUEUE_RESPONSE(c, slot, cluster_variant_raw_resp, ctx);\n    }\n\n    efree(cmd);\n}\n/* }}} */\n\n/* {{{ proto array RedisCluster::command()\n *     proto array RedisCluster::command('INFO', string cmd)\n *     proto array RedisCluster::command('GETKEYS', array cmd_args) */\nPHP_METHOD(RedisCluster, command) {\n    CLUSTER_PROCESS_CMD(command, cluster_variant_resp, 0);\n}\n\nPHP_METHOD(RedisCluster, copy) {\n    CLUSTER_PROCESS_CMD(copy, cluster_1_resp, 0)\n}\n\n/* vim: set tabstop=4 softtabstop=4 expandtab shiftwidth=4: */\n\n"
        },
        {
          "name": "redis_cluster.h",
          "type": "blob",
          "size": 3.3984375,
          "content": "#ifndef REDIS_CLUSTER_H\n#define REDIS_CLUSTER_H\n\n#include \"cluster_library.h\"\n#include <php.h>\n#include <stddef.h>\n\n/* Get attached object context */\n#define GET_CONTEXT() PHPREDIS_ZVAL_GET_OBJECT(redisCluster, getThis())\n\n/* Command building/processing is identical for every command */\n#define CLUSTER_BUILD_CMD(name, c, cmd, cmd_len, slot) \\\n    redis_##name##_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, c->flags, &cmd, \\\n                       &cmd_len, &slot)\n\n/* Append information required to handle MULTI commands to the tail of our MULTI\n * linked list. */\n#define CLUSTER_ENQUEUE_RESPONSE(c, slot, cb, ctx) \\\n    clusterFoldItem *_item; \\\n    _item = emalloc(sizeof(clusterFoldItem)); \\\n    _item->callback = cb; \\\n    _item->slot = slot; \\\n    _item->ctx = ctx; \\\n    _item->next = NULL; \\\n    if(c->multi_head == NULL) { \\\n        c->multi_head = _item; \\\n        c->multi_curr = _item; \\\n    } else { \\\n        c->multi_curr->next = _item; \\\n        c->multi_curr = _item; \\\n    } \\\n\n/* Simple macro to free our enqueued callbacks after we EXEC */\n#define CLUSTER_FREE_QUEUE(c) \\\n    clusterFoldItem *_item = c->multi_head, *_tmp; \\\n    while(_item) { \\\n        _tmp = _item->next; \\\n        efree(_item); \\\n        _item = _tmp; \\\n    } \\\n    c->multi_head = c->multi_curr = NULL; \\\n\n/* Reset anything flagged as MULTI */\n#define CLUSTER_RESET_MULTI(c) \\\n    redisClusterNode *_node; \\\n    ZEND_HASH_FOREACH_PTR(c->nodes, _node) { \\\n        if (_node == NULL) break; \\\n        _node->sock->watching = 0; \\\n        _node->sock->mode = ATOMIC; \\\n    } ZEND_HASH_FOREACH_END(); \\\n    c->flags->watching = 0; \\\n    c->flags->mode     = ATOMIC; \\\n\n/* Simple 1-1 command -> response macro */\n#define CLUSTER_PROCESS_CMD(cmdname, resp_func, readcmd) \\\n    redisCluster *c = GET_CONTEXT(); \\\n    c->readonly = CLUSTER_IS_ATOMIC(c) && readcmd; \\\n    char *cmd; int cmd_len; short slot; void *ctx=NULL; \\\n    if(redis_##cmdname##_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU,c->flags, &cmd, \\\n                             &cmd_len, &slot, &ctx)==FAILURE) { \\\n        RETURN_FALSE; \\\n    } \\\n    if(cluster_send_command(c,slot,cmd,cmd_len)<0 || c->err!=NULL) {\\\n        efree(cmd); \\\n        RETURN_FALSE; \\\n    } \\\n    efree(cmd); \\\n    if(c->flags->mode == MULTI) { \\\n        CLUSTER_ENQUEUE_RESPONSE(c, slot, resp_func, ctx); \\\n        RETURN_ZVAL(getThis(), 1, 0); \\\n    } \\\n    resp_func(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, ctx);\n\n/* More generic processing, where only the keyword differs */\n#define CLUSTER_PROCESS_KW_CMD(kw, cmdfunc, resp_func, readcmd) \\\n    redisCluster *c = GET_CONTEXT(); \\\n    c->readonly = CLUSTER_IS_ATOMIC(c) && readcmd; \\\n    char *cmd; int cmd_len; short slot; void *ctx=NULL; \\\n    if(cmdfunc(INTERNAL_FUNCTION_PARAM_PASSTHRU, c->flags, kw, &cmd, &cmd_len,\\\n               &slot,&ctx)==FAILURE) { \\\n        RETURN_FALSE; \\\n    } \\\n    if(cluster_send_command(c,slot,cmd,cmd_len)<0 || c->err!=NULL) { \\\n        efree(cmd); \\\n        RETURN_FALSE; \\\n    } \\\n    efree(cmd); \\\n    if(c->flags->mode == MULTI) { \\\n        CLUSTER_ENQUEUE_RESPONSE(c, slot, resp_func, ctx); \\\n        RETURN_ZVAL(getThis(), 1, 0); \\\n    } \\\n    resp_func(INTERNAL_FUNCTION_PARAM_PASSTHRU, c, ctx);\n\nextern zend_class_entry *redis_cluster_ce;\nextern zend_class_entry *redis_cluster_exception_ce;\nextern PHP_MINIT_FUNCTION(redis_cluster);\nextern zend_object * create_cluster_context(zend_class_entry *class_type);\nextern void free_cluster_context(zend_object *object);\n\n#endif\n"
        },
        {
          "name": "redis_cluster.stub.php",
          "type": "blob",
          "size": 33.2001953125,
          "content": "<?php\n\n/**\n * @generate-function-entries\n * @generate-legacy-arginfo\n * @generate-class-entries\n */\n\nclass RedisCluster {\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_OPT_FAILOVER\n     *\n     */\n    public const OPT_SLAVE_FAILOVER = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_FAILOVER_NONE\n     *\n     */\n    public const FAILOVER_NONE = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_FAILOVER_ERROR\n     *\n     */\n    public const FAILOVER_ERROR = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_FAILOVER_DISTRIBUTE\n     *\n     */\n    public const FAILOVER_DISTRIBUTE = UNKNOWN;\n\n    /**\n     *\n     * @var int\n     * @cvalue REDIS_FAILOVER_DISTRIBUTE_SLAVES\n     *\n     */\n    public const FAILOVER_DISTRIBUTE_SLAVES = UNKNOWN;\n\n    public function __construct(string|null $name, ?array $seeds = null, int|float $timeout = 0, int|float $read_timeout = 0, bool $persistent = false, #[\\SensitiveParameter] mixed $auth = null, ?array $context = null);\n\n    /**\n     * @see Redis::_compress()\n     */\n    public function _compress(string $value): string;\n\n    /**\n     * @see Redis::_uncompress()\n     */\n    public function _uncompress(string $value): string;\n\n    /**\n     * @see Redis::_serialize()\n     */\n    public function _serialize(mixed $value): bool|string;\n\n    /**\n     * @see Redis::_unserialize()\n     */\n    public function _unserialize(string $value): mixed;\n\n    /**\n     * @see Redis::_pack()\n     */\n    public function _pack(mixed $value): string;\n\n    /**\n     * @see Redis::_unpack()\n     */\n    public function _unpack(string $value): mixed;\n\n    /**\n     * @see Redis::_prefix()\n     */\n    public function _prefix(string $key): bool|string;\n\n    public function _masters(): array;\n\n    public function _redir(): string|null;\n\n    /**\n     * @see Redis::acl\n     */\n    public function acl(string|array $key_or_address, string $subcmd, string ...$args): mixed;\n\n    /**\n     * @see Redis::append()\n     */\n    public function append(string $key, mixed $value): RedisCluster|bool|int;\n\n    /**\n     * @see Redis::bgrewriteaof\n     */\n    public function bgrewriteaof(string|array $key_or_address): RedisCluster|bool;\n\n    public function waitaof(string|array $key_or_address, int $numlocal,\n                            int $numreplicas, int $timeout): RedisCluster|array|false;\n\n    /**\n     * @see Redis::bgsave\n     */\n    public function bgsave(string|array $key_or_address): RedisCluster|bool;\n\n    /**\n     * @see Redis::bitcount\n     */\n    public function bitcount(string $key, int $start = 0, int $end = -1, bool $bybit = false): RedisCluster|bool|int;\n\n    /**\n     * @see Redis::bitop\n     */\n    public function bitop(string $operation, string $deskey, string $srckey, string ...$otherkeys): RedisCluster|bool|int;\n\n    /**\n     * Return the position of the first bit set to 0 or 1 in a string.\n     *\n     * @see https://https://redis.io/commands/bitpos/\n     *\n     * @param string $key   The key to check (must be a string)\n     * @param bool   $bit   Whether to look for an unset (0) or set (1) bit.\n     * @param int    $start Where in the string to start looking.\n     * @param int    $end   Where in the string to stop looking.\n     * @param bool   $bybit If true, Redis will treat $start and $end as BIT values and not bytes, so if start\n     *                      was 0 and end was 2, Redis would only search the first two bits.\n     */\n    public function bitpos(string $key, bool $bit, int $start = 0, int $end = -1, bool $bybit = false): RedisCluster|int|false;\n\n    /**\n     * See Redis::blpop()\n     */\n    public function blpop(string|array $key, string|float|int $timeout_or_key, mixed ...$extra_args): RedisCluster|array|null|false;\n\n    /**\n     * See Redis::brpop()\n     */\n    public function brpop(string|array $key, string|float|int $timeout_or_key, mixed ...$extra_args): RedisCluster|array|null|false;\n\n    /**\n     * See Redis::brpoplpush()\n     */\n    public function brpoplpush(string $srckey, string $deskey, int $timeout): mixed;\n\n    /**\n     * Move an element from one list into another.\n     *\n     * @see Redis::lmove\n     */\n    public function lmove(string $src, string $dst, string $wherefrom, string $whereto): Redis|string|false;\n\n    /**\n     * Move an element from one list to another, blocking up to a timeout until an element is available.\n     *\n     * @see Redis::blmove\n     *\n     */\n    public function blmove(string $src, string $dst, string $wherefrom, string $whereto, float $timeout): Redis|string|false;\n\n    /**\n     * @see Redis::bzpopmax\n     */\n    public function bzpopmax(string|array $key, string|int $timeout_or_key, mixed ...$extra_args): array;\n\n    /**\n     * @see Redis::bzpopmin\n     */\n    public function bzpopmin(string|array $key, string|int $timeout_or_key, mixed ...$extra_args): array;\n\n    /**\n     * @see Redis::bzmpop\n     */\n    public function bzmpop(float $timeout, array $keys, string $from, int $count = 1): RedisCluster|array|null|false;\n\n    /**\n     * @see Redis::zmpop\n     */\n    public function zmpop(array $keys, string $from, int $count = 1): RedisCluster|array|null|false;\n\n    /**\n     * @see Redis::blmpop()\n     */\n    public function blmpop(float $timeout, array $keys, string $from, int $count = 1): RedisCluster|array|null|false;\n\n    /**\n     * @see Redis::lmpop()\n     */\n    public function lmpop(array $keys, string $from, int $count = 1): RedisCluster|array|null|false;\n\n    /**\n     * @see Redis::clearlasterror()\n     */\n    public function clearlasterror(): bool;\n\n    /**\n     * @see Redis::client\n     */\n    public function client(string|array $key_or_address, string $subcommand, ?string $arg = null): array|string|bool;\n\n    /**\n     * @see Redis::close\n     */\n    public function close(): bool;\n\n    /**\n     * @see Redis::cluster\n     */\n    public function cluster(string|array $key_or_address, string $command, mixed ...$extra_args): mixed;\n\n    /**\n     * @see Redis::command\n     */\n    public function command(mixed ...$extra_args): mixed;\n\n    /**\n     * @see Redis::config()\n     */\n    public function config(string|array $key_or_address, string $subcommand, mixed ...$extra_args): mixed;\n\n    /**\n     * @see Redis::dbsize()\n     */\n    public function dbsize(string|array $key_or_address): RedisCluster|int;\n\n    /**\n     * @see https://redis.io/commands/copy\n     */\n    public function copy(string $src, string $dst, ?array $options = null): RedisCluster|bool;\n\n    /**\n     * @see Redis::decr()\n     */\n    public function decr(string $key, int $by = 1): RedisCluster|int|false;\n\n    /**\n     * @see Redis::decrby()\n     */\n    public function decrby(string $key, int $value): RedisCluster|int|false;\n\n    /**\n     * @see Redis::decrbyfloat\n     */\n    public function decrbyfloat(string $key, float $value): float;\n\n    /**\n     * @see Redis::del()\n     */\n    public function del(array|string $key, string ...$other_keys): RedisCluster|int|false;\n\n    /**\n     * @see Redis::discard\n     */\n    public function discard(): bool;\n\n    /**\n     * @see Redis::dump\n     */\n    public function dump(string $key): RedisCluster|string|false;\n\n    /**\n     * @see Redis::echo()\n     */\n    public function echo(string|array $key_or_address, string $msg): RedisCluster|string|false;\n\n    /**\n     * @see Redis::eval\n     */\n    public function eval(string $script, array $args = [], int $num_keys = 0): mixed;\n\n    /**\n     * @see Redis::eval_ro\n     */\n    public function eval_ro(string $script, array $args = [], int $num_keys = 0): mixed;\n\n    /**\n     * @see Redis::evalsha\n     */\n    public function evalsha(string $script_sha, array $args = [], int $num_keys = 0): mixed;\n\n    /**\n     * @see Redis::evalsha_ro\n     */\n    public function evalsha_ro(string $script_sha, array $args = [], int $num_keys = 0): mixed;\n\n    /**\n     * @see Redis::exec()\n     */\n    public function exec(): array|false;\n\n    /**\n     * @see Redis::exists\n     */\n    public function exists(mixed $key, mixed ...$other_keys): RedisCluster|int|bool;\n\n    /**\n     * @see Redis::touch()\n     */\n    public function touch(mixed $key, mixed ...$other_keys): RedisCluster|int|bool;\n\n    /**\n     * @see Redis::expire\n     */\n    public function expire(string $key, int $timeout, ?string $mode = null): RedisCluster|bool;\n\n    /**\n     * @see Redis::expireat\n     */\n    public function expireat(string $key, int $timestamp, ?string $mode = null): RedisCluster|bool;\n\n    /**\n     * @see Redis::expiretime()\n     */\n    public function expiretime(string $key): RedisCluster|int|false;\n\n    /**\n     * @see Redis::pexpiretime()\n     */\n    public function pexpiretime(string $key): RedisCluster|int|false;\n\n    /**\n     * @see Redis::flushall\n     */\n    public function flushall(string|array $key_or_address, bool $async = false): RedisCluster|bool;\n\n    /**\n     * @see Redis::flushdb\n     */\n    public function flushdb(string|array $key_or_address, bool $async = false): RedisCluster|bool;\n\n    /**\n     * @see Redis::geoadd\n     */\n    public function geoadd(string $key, float $lng, float $lat, string $member, mixed ...$other_triples_and_options): RedisCluster|int|false;\n\n    /**\n     * @see Redis::geodist\n     */\n    public function geodist(string $key, string $src, string $dest, ?string $unit = null): RedisCluster|float|false;\n\n    /**\n     * @see Redis::geohash\n     */\n    public function geohash(string $key, string $member, string ...$other_members): RedisCluster|array|false;\n\n    /**\n     * @see Redis::geopos\n     */\n    public function geopos(string $key, string $member, string ...$other_members): RedisCluster|array|false;\n\n    /**\n     * @see Redis::georadius\n     */\n    public function georadius(string $key, float $lng, float $lat, float $radius, string $unit, array $options = []): mixed;\n\n    /**\n     * @see Redis::georadius_ro\n     */\n    public function georadius_ro(string $key, float $lng, float $lat, float $radius, string $unit, array $options = []): mixed;\n\n    /**\n     * @see Redis::georadiusbymember\n     */\n    public function georadiusbymember(string $key, string $member, float $radius, string $unit, array $options = []): mixed;\n\n    /**\n     * @see Redis::georadiusbymember_ro\n     */\n    public function georadiusbymember_ro(string $key, string $member, float $radius, string $unit, array $options = []): mixed;\n\n    /**\n     * @see https://redis.io/commands/geosearch\n     */\n    public function geosearch(string $key, array|string $position, array|int|float $shape, string $unit, array $options = []): RedisCluster|array;\n\n    /**\n     * @see https://redis.io/commands/geosearchstore\n     */\n    public function geosearchstore(string $dst, string $src, array|string $position, array|int|float $shape, string $unit, array $options = []): RedisCluster|array|int|false;\n\n    /**\n     * @see Redis::get\n     */\n    public function get(string $key): mixed;\n\n    /**\n     * @see Redis::getEx\n     */\n    public function getex(string $key, array $options = []): RedisCluster|string|false;\n\n    /**\n     * @see Redis::getbit\n     */\n    public function getbit(string $key, int $value): RedisCluster|int|false;\n\n    /**\n     * @see Redis::getlasterror\n     */\n    public function getlasterror(): string|null;\n\n    /**\n     * @see Redis::getmode\n     */\n    public function getmode(): int;\n\n    /**\n     * @see Redis::getoption\n     */\n    public function getoption(int $option): mixed;\n\n    /**\n     * @see Redis::getrange\n     */\n    public function getrange(string $key, int $start, int $end): RedisCluster|string|false;\n\n    /**\n     * @see Redis::lcs\n     */\n    public function lcs(string $key1, string $key2, ?array $options = null): RedisCluster|string|array|int|false;\n\n    /**\n     * @see Redis::getset\n     */\n    public function getset(string $key, mixed $value): RedisCluster|string|bool;\n\n    /**\n     * @see Redis::gettransferredbytes\n     */\n    public function gettransferredbytes(): array|false;\n\n    /**\n     * @see Redis::cleartransferredbytes\n     */\n    public function cleartransferredbytes(): void;\n\n    /**\n     * @see Redis::hdel\n     */\n    public function hdel(string $key, string $member, string ...$other_members): RedisCluster|int|false;\n\n    /**\n     * @see Redis::hexists\n     */\n    public function hexists(string $key, string $member): RedisCluster|bool;\n\n    /**\n     * @see Redis::hget\n     */\n    public function hget(string $key, string $member): mixed;\n\n    /**\n     * @see Redis::hgetall\n     */\n    public function hgetall(string $key): RedisCluster|array|false;\n\n    /**\n     * @see Redis::hincrby\n     */\n    public function hincrby(string $key, string $member, int $value): RedisCluster|int|false;\n\n    /**\n     * @see Redis::hincrbyfloat\n     */\n    public function hincrbyfloat(string $key, string $member, float $value): RedisCluster|float|false;\n\n    /**\n     * @see Redis::hkeys\n     */\n    public function hkeys(string $key): RedisCluster|array|false;\n\n    /**\n     * @see Redis::hlen\n     */\n    public function hlen(string $key): RedisCluster|int|false;\n\n    /**\n     * @see Redis::hmget\n     */\n    public function hmget(string $key, array $keys): RedisCluster|array|false;\n\n    /**\n     * @see Redis::hmset\n     */\n    public function hmset(string $key, array $key_values): RedisCluster|bool;\n\n    /**\n     * @see Redis::hscan\n     */\n    public function hscan(string $key, null|int|string &$iterator, ?string $pattern = null, int $count = 0): array|bool;\n\n    /**\n     * @see Redis::expiremember\n     */\n    public function expiremember(string $key, string $field, int $ttl, ?string $unit = null): Redis|int|false;\n\n    /**\n     * @see Redis::expirememberat\n     */\n    public function expirememberat(string $key, string $field, int $timestamp): Redis|int|false;\n\n    /**\n     * @see https://redis.io/commands/hrandfield\n     */\n    public function hrandfield(string $key, ?array $options = null): RedisCluster|string|array;\n\n    /**\n     * @see Redis::hset\n     */\n    public function hset(string $key, string $member, mixed $value): RedisCluster|int|false;\n\n    /**\n     * @see Redis::hsetnx\n     */\n    public function hsetnx(string $key, string $member, mixed $value): RedisCluster|bool;\n\n    /**\n     * @see Redis::hstrlen\n     */\n    public function hstrlen(string $key, string $field): RedisCluster|int|false;\n\n    /**\n     * @see Redis::hvals\n     */\n    public function hvals(string $key): RedisCluster|array|false;\n\n    /**\n     * @see Redis::incr\n     */\n    public function incr(string $key, int $by = 1): RedisCluster|int|false;\n\n    /**\n     * @see Redis::incrby\n     */\n    public function incrby(string $key, int $value): RedisCluster|int|false;\n\n    /**\n     * @see Redis::incrbyfloat\n     */\n    public function incrbyfloat(string $key, float $value): RedisCluster|float|false;\n\n    /**\n     * Retrieve information about the connected redis-server.  If no arguments are passed to\n     * this function, redis will return every info field.  Alternatively you may pass a specific\n     * section you want returned (e.g. 'server', or 'memory') to receive only information pertaining\n     * to that section.\n     *\n     * If connected to Redis server >= 7.0.0 you may pass multiple optional sections.\n     *\n     * @see https://redis.io/commands/info/\n     *\n     * @param string|array $key_or_address Either a key name or array with host and port indicating\n     *                                     which cluster node we want to send the command to.\n     * @param string       $sections       Optional section(s) you wish Redis server to return.\n     *\n     * @return RedisCluster|array|false\n     */\n    public function info(string|array $key_or_address, string ...$sections): RedisCluster|array|false;\n\n    /**\n     * @see Redis::keys\n     */\n    public function keys(string $pattern): RedisCluster|array|false;\n\n    /**\n     * @see Redis::lastsave\n     */\n    public function lastsave(string|array $key_or_address): RedisCluster|int|false;\n\n    /**\n     * @see Redis::lget\n     */\n    public function lget(string $key, int $index): RedisCluster|string|bool;\n\n    /**\n     * @see Redis::lindex\n     */\n    public function lindex(string $key, int $index): mixed;\n\n    /**\n     * @see Redis::linsert\n     */\n    public function linsert(string $key, string $pos, mixed $pivot, mixed $value): RedisCluster|int|false;\n\n    /**\n     * @see Redis::llen\n     */\n    public function llen(string $key): RedisCluster|int|bool;\n\n    /**\n     * @see Redis::lpop\n     */\n    public function lpop(string $key, int $count = 0): RedisCluster|bool|string|array;\n\n    /**\n     * @see Redis::lpos\n     */\n    public function lpos(string $key, mixed $value, ?array $options = null): Redis|null|bool|int|array;\n\n    /**\n     * @see Redis::lpush\n     */\n    public function lpush(string $key, mixed $value, mixed ...$other_values): RedisCluster|int|bool;\n\n    /**\n     * @see Redis::lpushx\n     */\n    public function lpushx(string $key, mixed $value): RedisCluster|int|bool;\n\n    /**\n     * @see Redis::lrange\n     */\n    public function lrange(string $key, int $start, int $end): RedisCluster|array|false;\n\n    /**\n     * @see Redis::lrem\n     */\n    public function lrem(string $key, mixed $value, int $count = 0): RedisCluster|int|bool;\n\n    /**\n     * @see Redis::lset\n     */\n    public function lset(string $key, int $index, mixed $value): RedisCluster|bool;\n\n    /**\n     * @see Redis::ltrim\n     */\n    public function ltrim(string $key, int $start, int $end): RedisCluster|bool;\n\n    /**\n     * @see Redis::mget\n     */\n    public function mget(array $keys): RedisCluster|array|false;\n\n    /**\n     * @see Redis::mset\n     */\n    public function mset(array $key_values): RedisCluster|bool;\n\n    /**\n     * @see Redis::msetnx\n     */\n    public function msetnx(array $key_values): RedisCluster|array|false;\n\n    /* We only support Redis::MULTI in RedisCluster but take the argument\n       so we can test MULTI..EXEC with RedisTest.php and in the event\n       we add pipeline support in the future. */\n    public function multi(int $value = Redis::MULTI): RedisCluster|bool;\n\n    /**\n     * @see Redis::object\n     */\n    public function object(string $subcommand, string $key): RedisCluster|int|string|false;\n\n    /**\n     * @see Redis::persist\n     */\n    public function persist(string $key): RedisCluster|bool;\n\n    /**\n     * @see Redis::pexpire\n     */\n    public function pexpire(string $key, int $timeout, ?string $mode = null): RedisCluster|bool;\n\n    /**\n     * @see Redis::pexpireat\n     */\n    public function pexpireat(string $key, int $timestamp, ?string $mode = null): RedisCluster|bool;\n\n\n    /**\n     * @see Redis::pfadd()\n     */\n    public function pfadd(string $key, array $elements): RedisCluster|bool;\n\n    /**\n     * @see Redis::pfcount()\n     */\n    public function pfcount(string $key): RedisCluster|int|false;\n\n    /**\n     * @see Redis::pfmerge()\n     */\n    public function pfmerge(string $key, array $keys): RedisCluster|bool;\n\n    /**\n     * PING an instance in the redis cluster.\n     *\n     * @see Redis::ping()\n     *\n     * @param string|array $key_or_address Either a key name or a two element array with host and\n     *                                     address, informing RedisCluster which node to ping.\n     *\n     * @param string       $message        An optional message to send.\n     *\n     * @return mixed This method always returns `true` if no message was sent, and the message itself\n     *               if one was.\n     */\n    public function ping(string|array $key_or_address, ?string $message = null): mixed;\n\n    /**\n     * @see Redis::psetex\n     */\n    public function psetex(string $key, int $timeout, string $value): RedisCluster|bool;\n\n    /**\n     * @see Redis::psubscribe\n     */\n    public function psubscribe(array $patterns, callable $callback): void;\n\n    /**\n     * @see Redis::pttl\n     */\n    public function pttl(string $key): RedisCluster|int|false;\n\n    /**\n     * @see Redis::publish\n     */\n    public function publish(string $channel, string $message): RedisCluster|bool|int;\n\n    /**\n     * @see Redis::pubsub\n     */\n    public function pubsub(string|array $key_or_address, string ...$values): mixed;\n\n    /**\n     * @see Redis::punsubscribe\n     */\n    public function punsubscribe(string $pattern, string ...$other_patterns): bool|array;\n\n    /**\n     * @see Redis::randomkey\n     */\n    public function randomkey(string|array $key_or_address): RedisCluster|bool|string;\n\n    /**\n     * @see Redis::rawcommand\n     */\n    public function rawcommand(string|array $key_or_address, string $command, mixed ...$args): mixed;\n\n    /**\n     * @see Redis::rename\n     */\n    public function rename(string $key_src, string $key_dst): RedisCluster|bool;\n\n    /**\n     * @see Redis::renamenx\n     */\n    public function renamenx(string $key, string $newkey): RedisCluster|bool;\n\n    /**\n     * @see Redis::restore\n     */\n    public function restore(string $key, int $timeout, string $value, ?array $options = null): RedisCluster|bool;\n\n    /**\n     * @see Redis::role\n     */\n    public function role(string|array $key_or_address): mixed;\n\n    /**\n     * @see Redis::rpop()\n     */\n    public function rpop(string $key, int $count = 0): RedisCluster|bool|string|array;\n\n    /**\n     * @see Redis::rpoplpush()\n     */\n    public function rpoplpush(string $src, string $dst): RedisCluster|bool|string;\n\n    /**\n     * @see Redis::rpush\n     */\n    public function rpush(string $key, mixed ...$elements): RedisCluster|int|false;\n\n    /**\n     * @see Redis::rpushx\n     */\n    public function rpushx(string $key, string $value): RedisCluster|bool|int;\n\n    /**\n     * @see Redis::sadd()\n     */\n    public function sadd(string $key, mixed $value, mixed ...$other_values): RedisCluster|int|false;\n\n    /**\n     * @see Redis::saddarray()\n     */\n    public function saddarray(string $key, array $values): RedisCluster|bool|int;\n\n    /**\n     * @see Redis::save\n     */\n    public function save(string|array $key_or_address): RedisCluster|bool;\n\n    /**\n     * @see Redis::scan\n     */\n    public function scan(null|int|string &$iterator, string|array $key_or_address, ?string $pattern = null, int $count = 0): bool|array;\n\n    /**\n     * @see Redis::scard\n     */\n    public function scard(string $key): RedisCluster|int|false;\n\n    /**\n     * @see Redis::script\n     */\n    public function script(string|array $key_or_address, mixed ...$args): mixed;\n\n    /**\n     * @see Redis::sdiff()\n     */\n    public function sdiff(string $key, string ...$other_keys): RedisCluster|array|false;\n\n    /**\n     * @see Redis::sdiffstore()\n     */\n    public function sdiffstore(string $dst, string $key, string ...$other_keys): RedisCluster|int|false;\n\n    /**\n     * @see https://redis.io/commands/set\n     */\n    public function set(string $key, mixed $value, mixed $options = null): RedisCluster|string|bool;\n\n    /**\n     * @see Redis::setbit\n     */\n    public function setbit(string $key, int $offset, bool $onoff): RedisCluster|int|false;\n\n    /**\n     * @see Redis::setex\n     */\n    public function setex(string $key, int $expire, mixed $value): RedisCluster|bool;\n\n    /**\n     * @see Redis::setnx\n     */\n    public function setnx(string $key, mixed $value): RedisCluster|bool;\n\n    /**\n     * @see Redis::setoption\n     */\n    public function setoption(int $option, mixed $value): bool;\n\n    /**\n     * @see Redis::setrange\n     */\n    public function setrange(string $key, int $offset, string $value): RedisCluster|int|false;\n\n    /**\n     * @see Redis::sinter()\n     */\n    public function sinter(array|string $key, string ...$other_keys): RedisCluster|array|false;\n\n    /**\n     * @see Redis::sintercard\n     */\n    public function sintercard(array $keys, int $limit = -1): RedisCluster|int|false;\n\n    /**\n     * @see Redis::sinterstore()\n     */\n    public function sinterstore(array|string $key, string ...$other_keys): RedisCluster|int|false;\n\n    /**\n     * @see Redis::sismember\n     */\n    public function sismember(string $key, mixed $value): RedisCluster|bool;\n\n    /**\n     * @see Redis::smismember\n     */\n    public function smismember(string $key, string $member, string ...$other_members): RedisCluster|array|false;\n\n    /**\n     * @see Redis::slowlog\n     */\n    public function slowlog(string|array $key_or_address, mixed ...$args): mixed;\n\n    /**\n     * @see Redis::smembers()\n     */\n    public function smembers(string $key): RedisCluster|array|false;\n\n    /**\n     * @see Redis::smove()\n     */\n    public function smove(string $src, string $dst, string $member): RedisCluster|bool;\n\n    /**\n     * @see Redis::sort()\n     */\n    public function sort(string $key, ?array $options = null): RedisCluster|array|bool|int|string;\n\n    /**\n     * @see Redis::sort_ro()\n     */\n    public function sort_ro(string $key, ?array $options = null): RedisCluster|array|bool|int|string;\n\n    /**\n     * @see Redis::spop\n     */\n    public function spop(string $key, int $count = 0): RedisCluster|string|array|false;\n\n    /**\n     * @see Redis::srandmember\n     */\n    public function srandmember(string $key, int $count = 0): RedisCluster|string|array|false;\n\n    /**\n     * @see Redis::srem\n     */\n    public function srem(string $key, mixed $value, mixed ...$other_values): RedisCluster|int|false;\n\n    /**\n     * @see Redis::sscan\n     */\n    public function sscan(string $key, null|int|string &$iterator, ?string $pattern = null, int $count = 0): array|false;\n\n    /**\n     * @see Redis::strlen\n     */\n    public function strlen(string $key): RedisCluster|int|false;\n\n    /**\n     * @see Redis::subscribe\n     */\n    public function subscribe(array $channels, callable $cb): void;\n\n    /**\n     * @see Redis::sunion()\n     */\n    public function sunion(string $key, string ...$other_keys): RedisCluster|bool|array;\n\n    /**\n     * @see Redis::sunionstore()\n     */\n    public function sunionstore(string $dst, string $key, string ...$other_keys): RedisCluster|int|false;\n\n    /**\n     * @see Redis::time\n     */\n    public function time(string|array $key_or_address): RedisCluster|bool|array;\n\n    /**\n     * @see Redis::ttl\n     */\n    public function ttl(string $key): RedisCluster|int|false;\n\n    /**\n     * @see Redis::type\n     */\n    public function type(string $key): RedisCluster|int|false;\n\n    /**\n     * @see Redis::unsubscribe\n     */\n    public function unsubscribe(array $channels): bool|array;\n\n    /**\n     * @see Redis::unlink\n     */\n    public function unlink(array|string $key, string ...$other_keys): RedisCluster|int|false;\n\n    /**\n     * @see Redis::unwatch\n     */\n    public function unwatch(): bool;\n\n    /**\n     * @see Redis::watch\n     */\n    public function watch(string $key, string ...$other_keys): RedisCluster|bool;\n\n    /**\n     * @see Redis::xack\n     */\n    public function xack(string $key, string $group, array $ids): RedisCluster|int|false;\n\n    /**\n     * @see Redis::xadd\n     */\n    public function xadd(string $key, string $id, array $values, int $maxlen = 0, bool $approx = false): RedisCluster|string|false;\n\n    /**\n     * @see Redis::xclaim\n     */\n    public function xclaim(string $key, string $group, string $consumer, int $min_iddle, array $ids, array $options): RedisCluster|string|array|false;\n\n    /**\n     * @see Redis::xdel\n     */\n    public function xdel(string $key, array $ids): RedisCluster|int|false;\n\n    /**\n     * @see Redis::xgroup\n     */\n    public function xgroup(string $operation, ?string $key = null, ?string $group = null, ?string $id_or_consumer = null,\n                           bool $mkstream = false, int $entries_read = -2): mixed;\n\n    /**\n     * @see Redis::xautoclaim\n     */\n    public function xautoclaim(string $key, string $group, string $consumer, int $min_idle, string $start, int $count = -1, bool $justid = false): RedisCluster|bool|array;\n\n    /**\n     * @see Redis::xinfo\n     */\n    public function xinfo(string $operation, ?string $arg1 = null, ?string $arg2 = null, int $count = -1): mixed;\n\n    /**\n     * @see Redis::xlen\n     */\n    public function xlen(string $key): RedisCluster|int|false;\n\n    /**\n     * @see Redis::xpending\n     */\n    public function xpending(string $key, string $group, ?string $start = null, ?string $end = null, int $count = -1, ?string $consumer = null): RedisCluster|array|false;\n\n    /**\n     * @see Redis::xrange\n     */\n    public function xrange(string $key, string $start, string $end, int $count = -1): RedisCluster|bool|array;\n\n    /**\n     * @see Redis::xread\n     */\n    public function xread(array $streams, int $count = -1, int $block = -1): RedisCluster|bool|array;\n\n    /**\n     * @see Redis::xreadgroup\n     */\n    public function xreadgroup(string $group, string $consumer, array $streams, int $count = 1, int $block = 1): RedisCluster|bool|array;\n\n    /**\n     * @see Redis::xrevrange\n     */\n    public function xrevrange(string $key, string $start, string $end, int $count = -1): RedisCluster|bool|array;\n\n    /**\n     * @see Redis::xtrim\n     */\n    public function xtrim(string $key, int $maxlen, bool $approx = false, bool $minid = false, int $limit = -1): RedisCluster|int|false;\n\n    /**\n     * @see Redis::zadd\n     */\n    public function zadd(string $key, array|float $score_or_options, mixed ...$more_scores_and_mems): RedisCluster|int|float|false;\n\n    /**\n     * @see Redis::zcard\n     */\n    public function zcard(string $key): RedisCluster|int|false;\n\n    /**\n     * @see Redis::zcount\n     */\n    public function zcount(string $key, string $start, string $end): RedisCluster|int|false;\n\n    /**\n     * @see Redis::zincrby\n     */\n    public function zincrby(string $key, float $value, string $member): RedisCluster|float|false;\n\n    /**\n     * @see Redis::zinterstore\n     */\n    public function zinterstore(string $dst, array $keys, ?array $weights = null, ?string $aggregate = null): RedisCluster|int|false;\n\n    /**\n     * @see Redis::zintercard\n     */\n    public function zintercard(array $keys, int $limit = -1): RedisCluster|int|false;\n\n    /**\n     * @see Redis::zlexcount\n     */\n    public function zlexcount(string $key, string $min, string $max): RedisCluster|int|false;\n\n    /**\n     * @see Redis::zpopmax\n     */\n    public function zpopmax(string $key, ?int $value = null): RedisCluster|bool|array;\n\n    /**\n     * @see Redis::zpopmin\n     */\n    public function zpopmin(string $key, ?int $value = null): RedisCluster|bool|array;\n\n    /**\n     * @see Redis::zrange\n     */\n    public function zrange(string $key, mixed $start, mixed $end, array|bool|null $options = null): RedisCluster|array|bool;\n\n    /**\n     * @see Redis::zrangestore\n     */\n    public function zrangestore(string $dstkey, string $srckey, int $start, int $end,\n                                array|bool|null $options = null): RedisCluster|int|false;\n\n    /**\n     * @see https://redis.io/commands/zrandmember\n     */\n    public function zrandmember(string $key, ?array $options = null): RedisCluster|string|array;\n\n    /**\n     * @see Redis::zrangebylex\n     */\n    public function zrangebylex(string $key, string $min, string $max, int $offset = -1, int $count = -1): RedisCluster|array|false;\n\n    /**\n     * @see Redis::zrangebyscore\n     */\n    public function zrangebyscore(string $key, string $start, string $end, array $options = []): RedisCluster|array|false;\n\n    /**\n     * @see Redis::zrank\n     */\n    public function zrank(string $key, mixed $member): RedisCluster|int|false;\n\n    /**\n     * @see Redis::zrem\n     */\n    public function zrem(string $key, string $value, string ...$other_values): RedisCluster|int|false;\n\n    /**\n     * @see Redis::zremrangebylex\n     */\n    public function zremrangebylex(string $key, string $min, string $max): RedisCluster|int|false;\n\n    /**\n     * @see Redis::zremrangebyrank\n     */\n    public function zremrangebyrank(string $key, string $min, string $max): RedisCluster|int|false;\n\n    /**\n     * @see Redis::zremrangebyscore\n     */\n    public function zremrangebyscore(string $key, string $min, string $max): RedisCluster|int|false;\n\n    /**\n     * @see Redis::zrevrange\n     */\n    public function zrevrange(string $key, string $min, string $max, ?array $options = null): RedisCluster|bool|array;\n\n    /**\n     * @see Redis::zrevrangebylex\n     */\n    public function zrevrangebylex(string $key, string $min, string $max, ?array $options = null): RedisCluster|bool|array;\n\n    /**\n     * @see Redis::zrevrangebyscore\n     */\n    public function zrevrangebyscore(string $key, string $min, string $max, ?array $options = null): RedisCluster|bool|array;\n\n    /**\n     * @see Redis::zrevrank\n     */\n    public function zrevrank(string $key, mixed $member): RedisCluster|int|false;\n\n    /**\n     * @see Redis::zscan\n     */\n    public function zscan(string $key, null|int|string &$iterator, ?string $pattern = null, int $count = 0): RedisCluster|bool|array;\n\n    /**\n     * @see Redis::zscore\n     */\n    public function zscore(string $key, mixed $member): RedisCluster|float|false;\n\n    /**\n     * @see https://redis.io/commands/zmscore\n     */\n    public function zmscore(string $key, mixed $member, mixed ...$other_members): Redis|array|false;\n\n    /**\n     * @see Redis::zunionstore\n     */\n    public function zunionstore(string $dst, array $keys, ?array $weights = null, ?string $aggregate = null): RedisCluster|int|false;\n\n    /**\n     * @see https://redis.io/commands/zinter\n     */\n    public function zinter(array $keys, ?array $weights = null, ?array $options = null): RedisCluster|array|false;\n\n    /**\n     * @see https://redis.io/commands/zdiffstore\n     */\n    public function zdiffstore(string $dst, array $keys): RedisCluster|int|false;\n\n    /**\n     * @see https://redis.io/commands/zunion\n     */\n    public function zunion(array $keys, ?array $weights = null, ?array $options = null): RedisCluster|array|false;\n\n    /**\n     * @see https://redis.io/commands/zdiff\n     */\n    public function zdiff(array $keys, ?array $options = null): RedisCluster|array|false;\n}\n\nclass RedisClusterException extends RuntimeException {}\n"
        },
        {
          "name": "redis_cluster_arginfo.h",
          "type": "blob",
          "size": 79.63671875,
          "content": "/* This is a generated file, edit the .stub.php file instead.\n * Stub hash: b9310b607794caa862d509ba316a2a512d2736fe */\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster___construct, 0, 0, 1)\n\tZEND_ARG_TYPE_INFO(0, name, IS_STRING, 1)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, seeds, IS_ARRAY, 1, \"null\")\n\tZEND_ARG_TYPE_MASK(0, timeout, MAY_BE_LONG|MAY_BE_DOUBLE, \"0\")\n\tZEND_ARG_TYPE_MASK(0, read_timeout, MAY_BE_LONG|MAY_BE_DOUBLE, \"0\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, persistent, _IS_BOOL, 0, \"false\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, auth, IS_MIXED, 0, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, context, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster__compress, 0, 1, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster__uncompress arginfo_class_RedisCluster__compress\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisCluster__serialize, 0, 1, MAY_BE_BOOL|MAY_BE_STRING)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster__unserialize, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster__pack, 0, 1, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster__unpack arginfo_class_RedisCluster__unserialize\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisCluster__prefix, 0, 1, MAY_BE_BOOL|MAY_BE_STRING)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster__masters, 0, 0, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster__redir, 0, 0, IS_STRING, 1)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_acl, 0, 2, IS_MIXED, 0)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_INFO(0, subcmd, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, args, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_append, 0, 2, RedisCluster, MAY_BE_BOOL|MAY_BE_LONG)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_bgrewriteaof, 0, 1, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_waitaof, 0, 4, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_INFO(0, numlocal, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, numreplicas, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, timeout, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_bgsave arginfo_class_RedisCluster_bgrewriteaof\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_bitcount, 0, 1, RedisCluster, MAY_BE_BOOL|MAY_BE_LONG)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, start, IS_LONG, 0, \"0\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, end, IS_LONG, 0, \"-1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, bybit, _IS_BOOL, 0, \"false\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_bitop, 0, 3, RedisCluster, MAY_BE_BOOL|MAY_BE_LONG)\n\tZEND_ARG_TYPE_INFO(0, operation, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, deskey, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, srckey, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, otherkeys, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_bitpos, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, bit, _IS_BOOL, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, start, IS_LONG, 0, \"0\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, end, IS_LONG, 0, \"-1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, bybit, _IS_BOOL, 0, \"false\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_blpop, 0, 2, RedisCluster, MAY_BE_ARRAY|MAY_BE_NULL|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_MASK(0, key, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_MASK(0, timeout_or_key, MAY_BE_STRING|MAY_BE_DOUBLE|MAY_BE_LONG, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, extra_args, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_brpop arginfo_class_RedisCluster_blpop\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_brpoplpush, 0, 3, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, srckey, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, deskey, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, timeout, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_lmove, 0, 4, Redis, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, src, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, wherefrom, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, whereto, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_blmove, 0, 5, Redis, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, src, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, wherefrom, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, whereto, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, timeout, IS_DOUBLE, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_bzpopmax, 0, 2, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_MASK(0, key, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_MASK(0, timeout_or_key, MAY_BE_STRING|MAY_BE_LONG, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, extra_args, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_bzpopmin arginfo_class_RedisCluster_bzpopmax\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_bzmpop, 0, 3, RedisCluster, MAY_BE_ARRAY|MAY_BE_NULL|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, timeout, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO(0, from, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"1\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zmpop, 0, 2, RedisCluster, MAY_BE_ARRAY|MAY_BE_NULL|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO(0, from, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"1\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_blmpop arginfo_class_RedisCluster_bzmpop\n\n#define arginfo_class_RedisCluster_lmpop arginfo_class_RedisCluster_zmpop\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_clearlasterror, 0, 0, _IS_BOOL, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisCluster_client, 0, 2, MAY_BE_ARRAY|MAY_BE_STRING|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_INFO(0, subcommand, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, arg, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_close arginfo_class_RedisCluster_clearlasterror\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_cluster, 0, 2, IS_MIXED, 0)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_INFO(0, command, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, extra_args, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_command, 0, 0, IS_MIXED, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, extra_args, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_config, 0, 2, IS_MIXED, 0)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_INFO(0, subcommand, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, extra_args, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_dbsize, 0, 1, RedisCluster, MAY_BE_LONG)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_copy, 0, 2, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, src, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_decr, 0, 1, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, by, IS_LONG, 0, \"1\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_decrby, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_decrbyfloat, 0, 2, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_DOUBLE, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_del, 0, 1, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_MASK(0, key, MAY_BE_ARRAY|MAY_BE_STRING, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_keys, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_discard arginfo_class_RedisCluster_clearlasterror\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_dump, 0, 1, RedisCluster, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_echo, 0, 2, RedisCluster, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_INFO(0, msg, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_eval, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, script, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, args, IS_ARRAY, 0, \"[]\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, num_keys, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_eval_ro arginfo_class_RedisCluster_eval\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_evalsha, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, script_sha, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, args, IS_ARRAY, 0, \"[]\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, num_keys, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_evalsha_ro arginfo_class_RedisCluster_evalsha\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisCluster_exec, 0, 0, MAY_BE_ARRAY|MAY_BE_FALSE)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_exists, 0, 1, RedisCluster, MAY_BE_LONG|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_MIXED, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_keys, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_touch arginfo_class_RedisCluster_exists\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_expire, 0, 2, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, timeout, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, mode, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_expireat, 0, 2, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, timestamp, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, mode, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_expiretime, 0, 1, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_pexpiretime arginfo_class_RedisCluster_expiretime\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_flushall, 0, 1, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, async, _IS_BOOL, 0, \"false\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_flushdb arginfo_class_RedisCluster_flushall\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_geoadd, 0, 4, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, lng, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, lat, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_triples_and_options, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_geodist, 0, 3, RedisCluster, MAY_BE_DOUBLE|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, src, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, dest, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, unit, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_geohash, 0, 2, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_members, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_geopos arginfo_class_RedisCluster_geohash\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_georadius, 0, 5, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, lng, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, lat, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, radius, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, unit, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 0, \"[]\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_georadius_ro arginfo_class_RedisCluster_georadius\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_georadiusbymember, 0, 4, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, radius, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, unit, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 0, \"[]\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_georadiusbymember_ro arginfo_class_RedisCluster_georadiusbymember\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_geosearch, 0, 4, RedisCluster, MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(0, position, MAY_BE_ARRAY|MAY_BE_STRING, NULL)\n\tZEND_ARG_TYPE_MASK(0, shape, MAY_BE_ARRAY|MAY_BE_LONG|MAY_BE_DOUBLE, NULL)\n\tZEND_ARG_TYPE_INFO(0, unit, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 0, \"[]\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_geosearchstore, 0, 5, RedisCluster, MAY_BE_ARRAY|MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, src, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(0, position, MAY_BE_ARRAY|MAY_BE_STRING, NULL)\n\tZEND_ARG_TYPE_MASK(0, shape, MAY_BE_ARRAY|MAY_BE_LONG|MAY_BE_DOUBLE, NULL)\n\tZEND_ARG_TYPE_INFO(0, unit, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 0, \"[]\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_get, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_getex, 0, 1, RedisCluster, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 0, \"[]\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_getbit arginfo_class_RedisCluster_decrby\n\n#define arginfo_class_RedisCluster_getlasterror arginfo_class_RedisCluster__redir\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_getmode, 0, 0, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_getoption, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, option, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_getrange, 0, 3, RedisCluster, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_lcs, 0, 2, RedisCluster, MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key1, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, key2, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_getset, 0, 2, RedisCluster, MAY_BE_STRING|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_gettransferredbytes arginfo_class_RedisCluster_exec\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_cleartransferredbytes, 0, 0, IS_VOID, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_hdel, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_members, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_hexists, 0, 2, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_hget, 0, 2, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_hgetall, 0, 1, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_hincrby, 0, 3, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_hincrbyfloat, 0, 3, RedisCluster, MAY_BE_DOUBLE|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_DOUBLE, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_hkeys arginfo_class_RedisCluster_hgetall\n\n#define arginfo_class_RedisCluster_hlen arginfo_class_RedisCluster_expiretime\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_hmget, 0, 2, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_hmset, 0, 2, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, key_values, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisCluster_hscan, 0, 2, MAY_BE_ARRAY|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(1, iterator, MAY_BE_NULL|MAY_BE_LONG|MAY_BE_STRING, NULL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, pattern, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_expiremember, 0, 3, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, field, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, ttl, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, unit, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_expirememberat, 0, 3, Redis, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, field, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, timestamp, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_hrandfield, 0, 1, RedisCluster, MAY_BE_STRING|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_hset, 0, 3, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_hsetnx, 0, 3, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_hstrlen, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, field, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_hvals arginfo_class_RedisCluster_hgetall\n\n#define arginfo_class_RedisCluster_incr arginfo_class_RedisCluster_decr\n\n#define arginfo_class_RedisCluster_incrby arginfo_class_RedisCluster_decrby\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_incrbyfloat, 0, 2, RedisCluster, MAY_BE_DOUBLE|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_DOUBLE, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_info, 0, 1, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, sections, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_keys, 0, 1, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, pattern, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_lastsave, 0, 1, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_lget, 0, 2, RedisCluster, MAY_BE_STRING|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, index, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_lindex, 0, 2, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, index, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_linsert, 0, 4, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, pos, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, pivot, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_llen, 0, 1, RedisCluster, MAY_BE_LONG|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_lpop, 0, 1, RedisCluster, MAY_BE_BOOL|MAY_BE_STRING|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_lpos, 0, 2, Redis, MAY_BE_NULL|MAY_BE_BOOL|MAY_BE_LONG|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_lpush, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_values, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_lpushx, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_lrange, 0, 3, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_lrem, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_lset, 0, 3, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, index, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_ltrim, 0, 3, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_LONG, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_mget, 0, 1, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_mset, 0, 1, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key_values, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_msetnx, 0, 1, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key_values, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_multi, 0, 0, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, value, IS_LONG, 0, \"Redis::MULTI\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_object, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, subcommand, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_persist, 0, 1, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_pexpire arginfo_class_RedisCluster_expire\n\n#define arginfo_class_RedisCluster_pexpireat arginfo_class_RedisCluster_expireat\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_pfadd, 0, 2, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, elements, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_pfcount arginfo_class_RedisCluster_expiretime\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_pfmerge, 0, 2, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_ping, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, message, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_psetex, 0, 3, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, timeout, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_psubscribe, 0, 2, IS_VOID, 0)\n\tZEND_ARG_TYPE_INFO(0, patterns, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO(0, callback, IS_CALLABLE, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_pttl arginfo_class_RedisCluster_expiretime\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_publish, 0, 2, RedisCluster, MAY_BE_BOOL|MAY_BE_LONG)\n\tZEND_ARG_TYPE_INFO(0, channel, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, message, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_pubsub, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, values, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisCluster_punsubscribe, 0, 1, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, pattern, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_patterns, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_randomkey, 0, 1, RedisCluster, MAY_BE_BOOL|MAY_BE_STRING)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_rawcommand, 0, 2, IS_MIXED, 0)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_INFO(0, command, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, args, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_rename, 0, 2, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key_src, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, key_dst, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_renamenx, 0, 2, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, newkey, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_restore, 0, 3, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, timeout, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_role, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_rpop arginfo_class_RedisCluster_lpop\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_rpoplpush, 0, 2, RedisCluster, MAY_BE_BOOL|MAY_BE_STRING)\n\tZEND_ARG_TYPE_INFO(0, src, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_rpush, 0, 1, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, elements, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_rpushx, 0, 2, RedisCluster, MAY_BE_BOOL|MAY_BE_LONG)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_sadd, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_values, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_saddarray, 0, 2, RedisCluster, MAY_BE_BOOL|MAY_BE_LONG)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, values, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_save arginfo_class_RedisCluster_bgrewriteaof\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisCluster_scan, 0, 2, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_MASK(1, iterator, MAY_BE_NULL|MAY_BE_LONG|MAY_BE_STRING, NULL)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, pattern, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_scard arginfo_class_RedisCluster_expiretime\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_script, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, args, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_sdiff, 0, 1, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_keys, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_sdiffstore, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_keys, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_set, 0, 2, RedisCluster, MAY_BE_STRING|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_MIXED, 0, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_setbit, 0, 3, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, offset, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, onoff, _IS_BOOL, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_setex, 0, 3, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, expire, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_setnx, 0, 2, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_setoption, 0, 2, _IS_BOOL, 0)\n\tZEND_ARG_TYPE_INFO(0, option, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_setrange, 0, 3, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, offset, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_sinter, 0, 1, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_MASK(0, key, MAY_BE_ARRAY|MAY_BE_STRING, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_keys, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_sintercard, 0, 1, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, limit, IS_LONG, 0, \"-1\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_sinterstore arginfo_class_RedisCluster_del\n\n#define arginfo_class_RedisCluster_sismember arginfo_class_RedisCluster_setnx\n\n#define arginfo_class_RedisCluster_smismember arginfo_class_RedisCluster_geohash\n\n#define arginfo_class_RedisCluster_slowlog arginfo_class_RedisCluster_script\n\n#define arginfo_class_RedisCluster_smembers arginfo_class_RedisCluster_hgetall\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_smove, 0, 3, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, src, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_sort, 0, 1, RedisCluster, MAY_BE_ARRAY|MAY_BE_BOOL|MAY_BE_LONG|MAY_BE_STRING)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_sort_ro arginfo_class_RedisCluster_sort\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_spop, 0, 1, RedisCluster, MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_srandmember arginfo_class_RedisCluster_spop\n\n#define arginfo_class_RedisCluster_srem arginfo_class_RedisCluster_sadd\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisCluster_sscan, 0, 2, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(1, iterator, MAY_BE_NULL|MAY_BE_LONG|MAY_BE_STRING, NULL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, pattern, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_strlen arginfo_class_RedisCluster_expiretime\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_subscribe, 0, 2, IS_VOID, 0)\n\tZEND_ARG_TYPE_INFO(0, channels, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO(0, cb, IS_CALLABLE, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_sunion, 0, 1, RedisCluster, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_keys, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_sunionstore arginfo_class_RedisCluster_sdiffstore\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_time, 0, 1, RedisCluster, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_MASK(0, key_or_address, MAY_BE_STRING|MAY_BE_ARRAY, NULL)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_ttl arginfo_class_RedisCluster_expiretime\n\n#define arginfo_class_RedisCluster_type arginfo_class_RedisCluster_expiretime\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_class_RedisCluster_unsubscribe, 0, 1, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, channels, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_unlink arginfo_class_RedisCluster_del\n\n#define arginfo_class_RedisCluster_unwatch arginfo_class_RedisCluster_clearlasterror\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_watch, 0, 1, RedisCluster, MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_keys, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_xack, 0, 3, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, group, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, ids, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_xadd, 0, 3, RedisCluster, MAY_BE_STRING|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, id, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, values, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, maxlen, IS_LONG, 0, \"0\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, approx, _IS_BOOL, 0, \"false\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_xclaim, 0, 6, RedisCluster, MAY_BE_STRING|MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, group, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, consumer, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, min_iddle, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, ids, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO(0, options, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_xdel, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, ids, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_xgroup, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, operation, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, key, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, group, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, id_or_consumer, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, mkstream, _IS_BOOL, 0, \"false\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, entries_read, IS_LONG, 0, \"-2\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_xautoclaim, 0, 5, RedisCluster, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, group, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, consumer, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, min_idle, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"-1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, justid, _IS_BOOL, 0, \"false\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisCluster_xinfo, 0, 1, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, operation, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, arg1, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, arg2, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"-1\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_xlen arginfo_class_RedisCluster_expiretime\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_xpending, 0, 2, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, group, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, start, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, end, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"-1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, consumer, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_xrange, 0, 3, RedisCluster, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"-1\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_xread, 0, 1, RedisCluster, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, streams, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"-1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, block, IS_LONG, 0, \"-1\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_xreadgroup, 0, 3, RedisCluster, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, group, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, consumer, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, streams, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, block, IS_LONG, 0, \"1\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_xrevrange arginfo_class_RedisCluster_xrange\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_xtrim, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, maxlen, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, approx, _IS_BOOL, 0, \"false\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, minid, _IS_BOOL, 0, \"false\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, limit, IS_LONG, 0, \"-1\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zadd, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_DOUBLE|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(0, score_or_options, MAY_BE_ARRAY|MAY_BE_DOUBLE, NULL)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, more_scores_and_mems, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_zcard arginfo_class_RedisCluster_expiretime\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zcount, 0, 3, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zincrby, 0, 3, RedisCluster, MAY_BE_DOUBLE|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_DOUBLE, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zinterstore, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, weights, IS_ARRAY, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, aggregate, IS_STRING, 1, \"null\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_zintercard arginfo_class_RedisCluster_sintercard\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zlexcount, 0, 3, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, min, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, max, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zpopmax, 0, 1, RedisCluster, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, value, IS_LONG, 1, \"null\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_zpopmin arginfo_class_RedisCluster_zpopmax\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zrange, 0, 3, RedisCluster, MAY_BE_ARRAY|MAY_BE_BOOL)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_MIXED, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_MIXED, 0)\n\tZEND_ARG_TYPE_MASK(0, options, MAY_BE_ARRAY|MAY_BE_BOOL|MAY_BE_NULL, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zrangestore, 0, 4, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, dstkey, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, srckey, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_LONG, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_LONG, 0)\n\tZEND_ARG_TYPE_MASK(0, options, MAY_BE_ARRAY|MAY_BE_BOOL|MAY_BE_NULL, \"null\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_zrandmember arginfo_class_RedisCluster_hrandfield\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zrangebylex, 0, 3, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, min, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, max, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, offset, IS_LONG, 0, \"-1\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"-1\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zrangebyscore, 0, 3, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, start, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, end, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 0, \"[]\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zrank, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zrem, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, value, IS_STRING, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_values, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_zremrangebylex arginfo_class_RedisCluster_zlexcount\n\n#define arginfo_class_RedisCluster_zremrangebyrank arginfo_class_RedisCluster_zlexcount\n\n#define arginfo_class_RedisCluster_zremrangebyscore arginfo_class_RedisCluster_zlexcount\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zrevrange, 0, 3, RedisCluster, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, min, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, max, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_zrevrangebylex arginfo_class_RedisCluster_zrevrange\n\n#define arginfo_class_RedisCluster_zrevrangebyscore arginfo_class_RedisCluster_zrevrange\n\n#define arginfo_class_RedisCluster_zrevrank arginfo_class_RedisCluster_zrank\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zscan, 0, 2, RedisCluster, MAY_BE_BOOL|MAY_BE_ARRAY)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_MASK(1, iterator, MAY_BE_NULL|MAY_BE_LONG|MAY_BE_STRING, NULL)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, pattern, IS_STRING, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, count, IS_LONG, 0, \"0\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zscore, 0, 2, RedisCluster, MAY_BE_DOUBLE|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zmscore, 0, 2, Redis, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, key, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, member, IS_MIXED, 0)\n\tZEND_ARG_VARIADIC_TYPE_INFO(0, other_members, IS_MIXED, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_zunionstore arginfo_class_RedisCluster_zinterstore\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zinter, 0, 1, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, weights, IS_ARRAY, 1, \"null\")\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zdiffstore, 0, 2, RedisCluster, MAY_BE_LONG|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, dst, IS_STRING, 0)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_zunion arginfo_class_RedisCluster_zinter\n\nZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_class_RedisCluster_zdiff, 0, 1, RedisCluster, MAY_BE_ARRAY|MAY_BE_FALSE)\n\tZEND_ARG_TYPE_INFO(0, keys, IS_ARRAY, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\n\nZEND_METHOD(RedisCluster, __construct);\nZEND_METHOD(RedisCluster, _compress);\nZEND_METHOD(RedisCluster, _uncompress);\nZEND_METHOD(RedisCluster, _serialize);\nZEND_METHOD(RedisCluster, _unserialize);\nZEND_METHOD(RedisCluster, _pack);\nZEND_METHOD(RedisCluster, _unpack);\nZEND_METHOD(RedisCluster, _prefix);\nZEND_METHOD(RedisCluster, _masters);\nZEND_METHOD(RedisCluster, _redir);\nZEND_METHOD(RedisCluster, acl);\nZEND_METHOD(RedisCluster, append);\nZEND_METHOD(RedisCluster, bgrewriteaof);\nZEND_METHOD(RedisCluster, waitaof);\nZEND_METHOD(RedisCluster, bgsave);\nZEND_METHOD(RedisCluster, bitcount);\nZEND_METHOD(RedisCluster, bitop);\nZEND_METHOD(RedisCluster, bitpos);\nZEND_METHOD(RedisCluster, blpop);\nZEND_METHOD(RedisCluster, brpop);\nZEND_METHOD(RedisCluster, brpoplpush);\nZEND_METHOD(RedisCluster, lmove);\nZEND_METHOD(RedisCluster, blmove);\nZEND_METHOD(RedisCluster, bzpopmax);\nZEND_METHOD(RedisCluster, bzpopmin);\nZEND_METHOD(RedisCluster, bzmpop);\nZEND_METHOD(RedisCluster, zmpop);\nZEND_METHOD(RedisCluster, blmpop);\nZEND_METHOD(RedisCluster, lmpop);\nZEND_METHOD(RedisCluster, clearlasterror);\nZEND_METHOD(RedisCluster, client);\nZEND_METHOD(RedisCluster, close);\nZEND_METHOD(RedisCluster, cluster);\nZEND_METHOD(RedisCluster, command);\nZEND_METHOD(RedisCluster, config);\nZEND_METHOD(RedisCluster, dbsize);\nZEND_METHOD(RedisCluster, copy);\nZEND_METHOD(RedisCluster, decr);\nZEND_METHOD(RedisCluster, decrby);\nZEND_METHOD(RedisCluster, decrbyfloat);\nZEND_METHOD(RedisCluster, del);\nZEND_METHOD(RedisCluster, discard);\nZEND_METHOD(RedisCluster, dump);\nZEND_METHOD(RedisCluster, echo);\nZEND_METHOD(RedisCluster, eval);\nZEND_METHOD(RedisCluster, eval_ro);\nZEND_METHOD(RedisCluster, evalsha);\nZEND_METHOD(RedisCluster, evalsha_ro);\nZEND_METHOD(RedisCluster, exec);\nZEND_METHOD(RedisCluster, exists);\nZEND_METHOD(RedisCluster, touch);\nZEND_METHOD(RedisCluster, expire);\nZEND_METHOD(RedisCluster, expireat);\nZEND_METHOD(RedisCluster, expiretime);\nZEND_METHOD(RedisCluster, pexpiretime);\nZEND_METHOD(RedisCluster, flushall);\nZEND_METHOD(RedisCluster, flushdb);\nZEND_METHOD(RedisCluster, geoadd);\nZEND_METHOD(RedisCluster, geodist);\nZEND_METHOD(RedisCluster, geohash);\nZEND_METHOD(RedisCluster, geopos);\nZEND_METHOD(RedisCluster, georadius);\nZEND_METHOD(RedisCluster, georadius_ro);\nZEND_METHOD(RedisCluster, georadiusbymember);\nZEND_METHOD(RedisCluster, georadiusbymember_ro);\nZEND_METHOD(RedisCluster, geosearch);\nZEND_METHOD(RedisCluster, geosearchstore);\nZEND_METHOD(RedisCluster, get);\nZEND_METHOD(RedisCluster, getex);\nZEND_METHOD(RedisCluster, getbit);\nZEND_METHOD(RedisCluster, getlasterror);\nZEND_METHOD(RedisCluster, getmode);\nZEND_METHOD(RedisCluster, getoption);\nZEND_METHOD(RedisCluster, getrange);\nZEND_METHOD(RedisCluster, lcs);\nZEND_METHOD(RedisCluster, getset);\nZEND_METHOD(RedisCluster, gettransferredbytes);\nZEND_METHOD(RedisCluster, cleartransferredbytes);\nZEND_METHOD(RedisCluster, hdel);\nZEND_METHOD(RedisCluster, hexists);\nZEND_METHOD(RedisCluster, hget);\nZEND_METHOD(RedisCluster, hgetall);\nZEND_METHOD(RedisCluster, hincrby);\nZEND_METHOD(RedisCluster, hincrbyfloat);\nZEND_METHOD(RedisCluster, hkeys);\nZEND_METHOD(RedisCluster, hlen);\nZEND_METHOD(RedisCluster, hmget);\nZEND_METHOD(RedisCluster, hmset);\nZEND_METHOD(RedisCluster, hscan);\nZEND_METHOD(RedisCluster, expiremember);\nZEND_METHOD(RedisCluster, expirememberat);\nZEND_METHOD(RedisCluster, hrandfield);\nZEND_METHOD(RedisCluster, hset);\nZEND_METHOD(RedisCluster, hsetnx);\nZEND_METHOD(RedisCluster, hstrlen);\nZEND_METHOD(RedisCluster, hvals);\nZEND_METHOD(RedisCluster, incr);\nZEND_METHOD(RedisCluster, incrby);\nZEND_METHOD(RedisCluster, incrbyfloat);\nZEND_METHOD(RedisCluster, info);\nZEND_METHOD(RedisCluster, keys);\nZEND_METHOD(RedisCluster, lastsave);\nZEND_METHOD(RedisCluster, lget);\nZEND_METHOD(RedisCluster, lindex);\nZEND_METHOD(RedisCluster, linsert);\nZEND_METHOD(RedisCluster, llen);\nZEND_METHOD(RedisCluster, lpop);\nZEND_METHOD(RedisCluster, lpos);\nZEND_METHOD(RedisCluster, lpush);\nZEND_METHOD(RedisCluster, lpushx);\nZEND_METHOD(RedisCluster, lrange);\nZEND_METHOD(RedisCluster, lrem);\nZEND_METHOD(RedisCluster, lset);\nZEND_METHOD(RedisCluster, ltrim);\nZEND_METHOD(RedisCluster, mget);\nZEND_METHOD(RedisCluster, mset);\nZEND_METHOD(RedisCluster, msetnx);\nZEND_METHOD(RedisCluster, multi);\nZEND_METHOD(RedisCluster, object);\nZEND_METHOD(RedisCluster, persist);\nZEND_METHOD(RedisCluster, pexpire);\nZEND_METHOD(RedisCluster, pexpireat);\nZEND_METHOD(RedisCluster, pfadd);\nZEND_METHOD(RedisCluster, pfcount);\nZEND_METHOD(RedisCluster, pfmerge);\nZEND_METHOD(RedisCluster, ping);\nZEND_METHOD(RedisCluster, psetex);\nZEND_METHOD(RedisCluster, psubscribe);\nZEND_METHOD(RedisCluster, pttl);\nZEND_METHOD(RedisCluster, publish);\nZEND_METHOD(RedisCluster, pubsub);\nZEND_METHOD(RedisCluster, punsubscribe);\nZEND_METHOD(RedisCluster, randomkey);\nZEND_METHOD(RedisCluster, rawcommand);\nZEND_METHOD(RedisCluster, rename);\nZEND_METHOD(RedisCluster, renamenx);\nZEND_METHOD(RedisCluster, restore);\nZEND_METHOD(RedisCluster, role);\nZEND_METHOD(RedisCluster, rpop);\nZEND_METHOD(RedisCluster, rpoplpush);\nZEND_METHOD(RedisCluster, rpush);\nZEND_METHOD(RedisCluster, rpushx);\nZEND_METHOD(RedisCluster, sadd);\nZEND_METHOD(RedisCluster, saddarray);\nZEND_METHOD(RedisCluster, save);\nZEND_METHOD(RedisCluster, scan);\nZEND_METHOD(RedisCluster, scard);\nZEND_METHOD(RedisCluster, script);\nZEND_METHOD(RedisCluster, sdiff);\nZEND_METHOD(RedisCluster, sdiffstore);\nZEND_METHOD(RedisCluster, set);\nZEND_METHOD(RedisCluster, setbit);\nZEND_METHOD(RedisCluster, setex);\nZEND_METHOD(RedisCluster, setnx);\nZEND_METHOD(RedisCluster, setoption);\nZEND_METHOD(RedisCluster, setrange);\nZEND_METHOD(RedisCluster, sinter);\nZEND_METHOD(RedisCluster, sintercard);\nZEND_METHOD(RedisCluster, sinterstore);\nZEND_METHOD(RedisCluster, sismember);\nZEND_METHOD(RedisCluster, smismember);\nZEND_METHOD(RedisCluster, slowlog);\nZEND_METHOD(RedisCluster, smembers);\nZEND_METHOD(RedisCluster, smove);\nZEND_METHOD(RedisCluster, sort);\nZEND_METHOD(RedisCluster, sort_ro);\nZEND_METHOD(RedisCluster, spop);\nZEND_METHOD(RedisCluster, srandmember);\nZEND_METHOD(RedisCluster, srem);\nZEND_METHOD(RedisCluster, sscan);\nZEND_METHOD(RedisCluster, strlen);\nZEND_METHOD(RedisCluster, subscribe);\nZEND_METHOD(RedisCluster, sunion);\nZEND_METHOD(RedisCluster, sunionstore);\nZEND_METHOD(RedisCluster, time);\nZEND_METHOD(RedisCluster, ttl);\nZEND_METHOD(RedisCluster, type);\nZEND_METHOD(RedisCluster, unsubscribe);\nZEND_METHOD(RedisCluster, unlink);\nZEND_METHOD(RedisCluster, unwatch);\nZEND_METHOD(RedisCluster, watch);\nZEND_METHOD(RedisCluster, xack);\nZEND_METHOD(RedisCluster, xadd);\nZEND_METHOD(RedisCluster, xclaim);\nZEND_METHOD(RedisCluster, xdel);\nZEND_METHOD(RedisCluster, xgroup);\nZEND_METHOD(RedisCluster, xautoclaim);\nZEND_METHOD(RedisCluster, xinfo);\nZEND_METHOD(RedisCluster, xlen);\nZEND_METHOD(RedisCluster, xpending);\nZEND_METHOD(RedisCluster, xrange);\nZEND_METHOD(RedisCluster, xread);\nZEND_METHOD(RedisCluster, xreadgroup);\nZEND_METHOD(RedisCluster, xrevrange);\nZEND_METHOD(RedisCluster, xtrim);\nZEND_METHOD(RedisCluster, zadd);\nZEND_METHOD(RedisCluster, zcard);\nZEND_METHOD(RedisCluster, zcount);\nZEND_METHOD(RedisCluster, zincrby);\nZEND_METHOD(RedisCluster, zinterstore);\nZEND_METHOD(RedisCluster, zintercard);\nZEND_METHOD(RedisCluster, zlexcount);\nZEND_METHOD(RedisCluster, zpopmax);\nZEND_METHOD(RedisCluster, zpopmin);\nZEND_METHOD(RedisCluster, zrange);\nZEND_METHOD(RedisCluster, zrangestore);\nZEND_METHOD(RedisCluster, zrandmember);\nZEND_METHOD(RedisCluster, zrangebylex);\nZEND_METHOD(RedisCluster, zrangebyscore);\nZEND_METHOD(RedisCluster, zrank);\nZEND_METHOD(RedisCluster, zrem);\nZEND_METHOD(RedisCluster, zremrangebylex);\nZEND_METHOD(RedisCluster, zremrangebyrank);\nZEND_METHOD(RedisCluster, zremrangebyscore);\nZEND_METHOD(RedisCluster, zrevrange);\nZEND_METHOD(RedisCluster, zrevrangebylex);\nZEND_METHOD(RedisCluster, zrevrangebyscore);\nZEND_METHOD(RedisCluster, zrevrank);\nZEND_METHOD(RedisCluster, zscan);\nZEND_METHOD(RedisCluster, zscore);\nZEND_METHOD(RedisCluster, zmscore);\nZEND_METHOD(RedisCluster, zunionstore);\nZEND_METHOD(RedisCluster, zinter);\nZEND_METHOD(RedisCluster, zdiffstore);\nZEND_METHOD(RedisCluster, zunion);\nZEND_METHOD(RedisCluster, zdiff);\n\n\nstatic const zend_function_entry class_RedisCluster_methods[] = {\n\tZEND_ME(RedisCluster, __construct, arginfo_class_RedisCluster___construct, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _compress, arginfo_class_RedisCluster__compress, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _uncompress, arginfo_class_RedisCluster__uncompress, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _serialize, arginfo_class_RedisCluster__serialize, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _unserialize, arginfo_class_RedisCluster__unserialize, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _pack, arginfo_class_RedisCluster__pack, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _unpack, arginfo_class_RedisCluster__unpack, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _prefix, arginfo_class_RedisCluster__prefix, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _masters, arginfo_class_RedisCluster__masters, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _redir, arginfo_class_RedisCluster__redir, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, acl, arginfo_class_RedisCluster_acl, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, append, arginfo_class_RedisCluster_append, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bgrewriteaof, arginfo_class_RedisCluster_bgrewriteaof, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, waitaof, arginfo_class_RedisCluster_waitaof, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bgsave, arginfo_class_RedisCluster_bgsave, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bitcount, arginfo_class_RedisCluster_bitcount, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bitop, arginfo_class_RedisCluster_bitop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bitpos, arginfo_class_RedisCluster_bitpos, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, blpop, arginfo_class_RedisCluster_blpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, brpop, arginfo_class_RedisCluster_brpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, brpoplpush, arginfo_class_RedisCluster_brpoplpush, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lmove, arginfo_class_RedisCluster_lmove, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, blmove, arginfo_class_RedisCluster_blmove, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bzpopmax, arginfo_class_RedisCluster_bzpopmax, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bzpopmin, arginfo_class_RedisCluster_bzpopmin, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bzmpop, arginfo_class_RedisCluster_bzmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zmpop, arginfo_class_RedisCluster_zmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, blmpop, arginfo_class_RedisCluster_blmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lmpop, arginfo_class_RedisCluster_lmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, clearlasterror, arginfo_class_RedisCluster_clearlasterror, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, client, arginfo_class_RedisCluster_client, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, close, arginfo_class_RedisCluster_close, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, cluster, arginfo_class_RedisCluster_cluster, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, command, arginfo_class_RedisCluster_command, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, config, arginfo_class_RedisCluster_config, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, dbsize, arginfo_class_RedisCluster_dbsize, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, copy, arginfo_class_RedisCluster_copy, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, decr, arginfo_class_RedisCluster_decr, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, decrby, arginfo_class_RedisCluster_decrby, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, decrbyfloat, arginfo_class_RedisCluster_decrbyfloat, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, del, arginfo_class_RedisCluster_del, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, discard, arginfo_class_RedisCluster_discard, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, dump, arginfo_class_RedisCluster_dump, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, echo, arginfo_class_RedisCluster_echo, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, eval, arginfo_class_RedisCluster_eval, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, eval_ro, arginfo_class_RedisCluster_eval_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, evalsha, arginfo_class_RedisCluster_evalsha, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, evalsha_ro, arginfo_class_RedisCluster_evalsha_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, exec, arginfo_class_RedisCluster_exec, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, exists, arginfo_class_RedisCluster_exists, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, touch, arginfo_class_RedisCluster_touch, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, expire, arginfo_class_RedisCluster_expire, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, expireat, arginfo_class_RedisCluster_expireat, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, expiretime, arginfo_class_RedisCluster_expiretime, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pexpiretime, arginfo_class_RedisCluster_pexpiretime, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, flushall, arginfo_class_RedisCluster_flushall, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, flushdb, arginfo_class_RedisCluster_flushdb, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, geoadd, arginfo_class_RedisCluster_geoadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, geodist, arginfo_class_RedisCluster_geodist, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, geohash, arginfo_class_RedisCluster_geohash, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, geopos, arginfo_class_RedisCluster_geopos, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, georadius, arginfo_class_RedisCluster_georadius, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, georadius_ro, arginfo_class_RedisCluster_georadius_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, georadiusbymember, arginfo_class_RedisCluster_georadiusbymember, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, georadiusbymember_ro, arginfo_class_RedisCluster_georadiusbymember_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, geosearch, arginfo_class_RedisCluster_geosearch, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, geosearchstore, arginfo_class_RedisCluster_geosearchstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, get, arginfo_class_RedisCluster_get, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, getex, arginfo_class_RedisCluster_getex, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, getbit, arginfo_class_RedisCluster_getbit, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, getlasterror, arginfo_class_RedisCluster_getlasterror, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, getmode, arginfo_class_RedisCluster_getmode, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, getoption, arginfo_class_RedisCluster_getoption, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, getrange, arginfo_class_RedisCluster_getrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lcs, arginfo_class_RedisCluster_lcs, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, getset, arginfo_class_RedisCluster_getset, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, gettransferredbytes, arginfo_class_RedisCluster_gettransferredbytes, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, cleartransferredbytes, arginfo_class_RedisCluster_cleartransferredbytes, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hdel, arginfo_class_RedisCluster_hdel, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hexists, arginfo_class_RedisCluster_hexists, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hget, arginfo_class_RedisCluster_hget, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hgetall, arginfo_class_RedisCluster_hgetall, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hincrby, arginfo_class_RedisCluster_hincrby, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hincrbyfloat, arginfo_class_RedisCluster_hincrbyfloat, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hkeys, arginfo_class_RedisCluster_hkeys, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hlen, arginfo_class_RedisCluster_hlen, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hmget, arginfo_class_RedisCluster_hmget, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hmset, arginfo_class_RedisCluster_hmset, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hscan, arginfo_class_RedisCluster_hscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, expiremember, arginfo_class_RedisCluster_expiremember, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, expirememberat, arginfo_class_RedisCluster_expirememberat, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hrandfield, arginfo_class_RedisCluster_hrandfield, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hset, arginfo_class_RedisCluster_hset, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hsetnx, arginfo_class_RedisCluster_hsetnx, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hstrlen, arginfo_class_RedisCluster_hstrlen, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hvals, arginfo_class_RedisCluster_hvals, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, incr, arginfo_class_RedisCluster_incr, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, incrby, arginfo_class_RedisCluster_incrby, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, incrbyfloat, arginfo_class_RedisCluster_incrbyfloat, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, info, arginfo_class_RedisCluster_info, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, keys, arginfo_class_RedisCluster_keys, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lastsave, arginfo_class_RedisCluster_lastsave, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lget, arginfo_class_RedisCluster_lget, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lindex, arginfo_class_RedisCluster_lindex, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, linsert, arginfo_class_RedisCluster_linsert, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, llen, arginfo_class_RedisCluster_llen, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lpop, arginfo_class_RedisCluster_lpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lpos, arginfo_class_RedisCluster_lpos, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lpush, arginfo_class_RedisCluster_lpush, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lpushx, arginfo_class_RedisCluster_lpushx, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lrange, arginfo_class_RedisCluster_lrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lrem, arginfo_class_RedisCluster_lrem, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lset, arginfo_class_RedisCluster_lset, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, ltrim, arginfo_class_RedisCluster_ltrim, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, mget, arginfo_class_RedisCluster_mget, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, mset, arginfo_class_RedisCluster_mset, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, msetnx, arginfo_class_RedisCluster_msetnx, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, multi, arginfo_class_RedisCluster_multi, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, object, arginfo_class_RedisCluster_object, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, persist, arginfo_class_RedisCluster_persist, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pexpire, arginfo_class_RedisCluster_pexpire, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pexpireat, arginfo_class_RedisCluster_pexpireat, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pfadd, arginfo_class_RedisCluster_pfadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pfcount, arginfo_class_RedisCluster_pfcount, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pfmerge, arginfo_class_RedisCluster_pfmerge, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, ping, arginfo_class_RedisCluster_ping, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, psetex, arginfo_class_RedisCluster_psetex, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, psubscribe, arginfo_class_RedisCluster_psubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pttl, arginfo_class_RedisCluster_pttl, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, publish, arginfo_class_RedisCluster_publish, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pubsub, arginfo_class_RedisCluster_pubsub, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, punsubscribe, arginfo_class_RedisCluster_punsubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, randomkey, arginfo_class_RedisCluster_randomkey, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, rawcommand, arginfo_class_RedisCluster_rawcommand, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, rename, arginfo_class_RedisCluster_rename, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, renamenx, arginfo_class_RedisCluster_renamenx, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, restore, arginfo_class_RedisCluster_restore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, role, arginfo_class_RedisCluster_role, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, rpop, arginfo_class_RedisCluster_rpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, rpoplpush, arginfo_class_RedisCluster_rpoplpush, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, rpush, arginfo_class_RedisCluster_rpush, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, rpushx, arginfo_class_RedisCluster_rpushx, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sadd, arginfo_class_RedisCluster_sadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, saddarray, arginfo_class_RedisCluster_saddarray, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, save, arginfo_class_RedisCluster_save, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, scan, arginfo_class_RedisCluster_scan, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, scard, arginfo_class_RedisCluster_scard, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, script, arginfo_class_RedisCluster_script, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sdiff, arginfo_class_RedisCluster_sdiff, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sdiffstore, arginfo_class_RedisCluster_sdiffstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, set, arginfo_class_RedisCluster_set, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, setbit, arginfo_class_RedisCluster_setbit, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, setex, arginfo_class_RedisCluster_setex, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, setnx, arginfo_class_RedisCluster_setnx, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, setoption, arginfo_class_RedisCluster_setoption, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, setrange, arginfo_class_RedisCluster_setrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sinter, arginfo_class_RedisCluster_sinter, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sintercard, arginfo_class_RedisCluster_sintercard, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sinterstore, arginfo_class_RedisCluster_sinterstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sismember, arginfo_class_RedisCluster_sismember, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, smismember, arginfo_class_RedisCluster_smismember, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, slowlog, arginfo_class_RedisCluster_slowlog, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, smembers, arginfo_class_RedisCluster_smembers, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, smove, arginfo_class_RedisCluster_smove, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sort, arginfo_class_RedisCluster_sort, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sort_ro, arginfo_class_RedisCluster_sort_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, spop, arginfo_class_RedisCluster_spop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, srandmember, arginfo_class_RedisCluster_srandmember, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, srem, arginfo_class_RedisCluster_srem, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sscan, arginfo_class_RedisCluster_sscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, strlen, arginfo_class_RedisCluster_strlen, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, subscribe, arginfo_class_RedisCluster_subscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sunion, arginfo_class_RedisCluster_sunion, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sunionstore, arginfo_class_RedisCluster_sunionstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, time, arginfo_class_RedisCluster_time, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, ttl, arginfo_class_RedisCluster_ttl, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, type, arginfo_class_RedisCluster_type, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, unsubscribe, arginfo_class_RedisCluster_unsubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, unlink, arginfo_class_RedisCluster_unlink, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, unwatch, arginfo_class_RedisCluster_unwatch, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, watch, arginfo_class_RedisCluster_watch, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xack, arginfo_class_RedisCluster_xack, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xadd, arginfo_class_RedisCluster_xadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xclaim, arginfo_class_RedisCluster_xclaim, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xdel, arginfo_class_RedisCluster_xdel, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xgroup, arginfo_class_RedisCluster_xgroup, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xautoclaim, arginfo_class_RedisCluster_xautoclaim, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xinfo, arginfo_class_RedisCluster_xinfo, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xlen, arginfo_class_RedisCluster_xlen, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xpending, arginfo_class_RedisCluster_xpending, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xrange, arginfo_class_RedisCluster_xrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xread, arginfo_class_RedisCluster_xread, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xreadgroup, arginfo_class_RedisCluster_xreadgroup, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xrevrange, arginfo_class_RedisCluster_xrevrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xtrim, arginfo_class_RedisCluster_xtrim, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zadd, arginfo_class_RedisCluster_zadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zcard, arginfo_class_RedisCluster_zcard, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zcount, arginfo_class_RedisCluster_zcount, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zincrby, arginfo_class_RedisCluster_zincrby, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zinterstore, arginfo_class_RedisCluster_zinterstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zintercard, arginfo_class_RedisCluster_zintercard, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zlexcount, arginfo_class_RedisCluster_zlexcount, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zpopmax, arginfo_class_RedisCluster_zpopmax, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zpopmin, arginfo_class_RedisCluster_zpopmin, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrange, arginfo_class_RedisCluster_zrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrangestore, arginfo_class_RedisCluster_zrangestore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrandmember, arginfo_class_RedisCluster_zrandmember, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrangebylex, arginfo_class_RedisCluster_zrangebylex, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrangebyscore, arginfo_class_RedisCluster_zrangebyscore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrank, arginfo_class_RedisCluster_zrank, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrem, arginfo_class_RedisCluster_zrem, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zremrangebylex, arginfo_class_RedisCluster_zremrangebylex, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zremrangebyrank, arginfo_class_RedisCluster_zremrangebyrank, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zremrangebyscore, arginfo_class_RedisCluster_zremrangebyscore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrevrange, arginfo_class_RedisCluster_zrevrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrevrangebylex, arginfo_class_RedisCluster_zrevrangebylex, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrevrangebyscore, arginfo_class_RedisCluster_zrevrangebyscore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrevrank, arginfo_class_RedisCluster_zrevrank, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zscan, arginfo_class_RedisCluster_zscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zscore, arginfo_class_RedisCluster_zscore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zmscore, arginfo_class_RedisCluster_zmscore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zunionstore, arginfo_class_RedisCluster_zunionstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zinter, arginfo_class_RedisCluster_zinter, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zdiffstore, arginfo_class_RedisCluster_zdiffstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zunion, arginfo_class_RedisCluster_zunion, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zdiff, arginfo_class_RedisCluster_zdiff, ZEND_ACC_PUBLIC)\n\tZEND_FE_END\n};\n\n\nstatic const zend_function_entry class_RedisClusterException_methods[] = {\n\tZEND_FE_END\n};\n\nstatic zend_class_entry *register_class_RedisCluster(void)\n{\n\tzend_class_entry ce, *class_entry;\n\n\tINIT_CLASS_ENTRY(ce, \"RedisCluster\", class_RedisCluster_methods);\n\tclass_entry = zend_register_internal_class_ex(&ce, NULL);\n\n\tzval const_OPT_SLAVE_FAILOVER_value;\n\tZVAL_LONG(&const_OPT_SLAVE_FAILOVER_value, REDIS_OPT_FAILOVER);\n\tzend_string *const_OPT_SLAVE_FAILOVER_name = zend_string_init_interned(\"OPT_SLAVE_FAILOVER\", sizeof(\"OPT_SLAVE_FAILOVER\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_SLAVE_FAILOVER_name, &const_OPT_SLAVE_FAILOVER_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_SLAVE_FAILOVER_name);\n\n\tzval const_FAILOVER_NONE_value;\n\tZVAL_LONG(&const_FAILOVER_NONE_value, REDIS_FAILOVER_NONE);\n\tzend_string *const_FAILOVER_NONE_name = zend_string_init_interned(\"FAILOVER_NONE\", sizeof(\"FAILOVER_NONE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_FAILOVER_NONE_name, &const_FAILOVER_NONE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_FAILOVER_NONE_name);\n\n\tzval const_FAILOVER_ERROR_value;\n\tZVAL_LONG(&const_FAILOVER_ERROR_value, REDIS_FAILOVER_ERROR);\n\tzend_string *const_FAILOVER_ERROR_name = zend_string_init_interned(\"FAILOVER_ERROR\", sizeof(\"FAILOVER_ERROR\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_FAILOVER_ERROR_name, &const_FAILOVER_ERROR_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_FAILOVER_ERROR_name);\n\n\tzval const_FAILOVER_DISTRIBUTE_value;\n\tZVAL_LONG(&const_FAILOVER_DISTRIBUTE_value, REDIS_FAILOVER_DISTRIBUTE);\n\tzend_string *const_FAILOVER_DISTRIBUTE_name = zend_string_init_interned(\"FAILOVER_DISTRIBUTE\", sizeof(\"FAILOVER_DISTRIBUTE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_FAILOVER_DISTRIBUTE_name, &const_FAILOVER_DISTRIBUTE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_FAILOVER_DISTRIBUTE_name);\n\n\tzval const_FAILOVER_DISTRIBUTE_SLAVES_value;\n\tZVAL_LONG(&const_FAILOVER_DISTRIBUTE_SLAVES_value, REDIS_FAILOVER_DISTRIBUTE_SLAVES);\n\tzend_string *const_FAILOVER_DISTRIBUTE_SLAVES_name = zend_string_init_interned(\"FAILOVER_DISTRIBUTE_SLAVES\", sizeof(\"FAILOVER_DISTRIBUTE_SLAVES\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_FAILOVER_DISTRIBUTE_SLAVES_name, &const_FAILOVER_DISTRIBUTE_SLAVES_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_FAILOVER_DISTRIBUTE_SLAVES_name);\n#if (PHP_VERSION_ID >= 80000)\n\n\n\tzend_string *attribute_name_SensitiveParameter_func___construct_arg5_0 = zend_string_init_interned(\"SensitiveParameter\", sizeof(\"SensitiveParameter\") - 1, 1);\n\tzend_add_parameter_attribute(zend_hash_str_find_ptr(&class_entry->function_table, \"__construct\", sizeof(\"__construct\") - 1), 5, attribute_name_SensitiveParameter_func___construct_arg5_0, 0);\n\tzend_string_release(attribute_name_SensitiveParameter_func___construct_arg5_0);\n#endif\n\n\treturn class_entry;\n}\n\nstatic zend_class_entry *register_class_RedisClusterException(zend_class_entry *class_entry_RuntimeException)\n{\n\tzend_class_entry ce, *class_entry;\n\n\tINIT_CLASS_ENTRY(ce, \"RedisClusterException\", class_RedisClusterException_methods);\n\tclass_entry = zend_register_internal_class_ex(&ce, class_entry_RuntimeException);\n\n\treturn class_entry;\n}\n"
        },
        {
          "name": "redis_cluster_legacy_arginfo.h",
          "type": "blob",
          "size": 56.9501953125,
          "content": "/* This is a generated file, edit the .stub.php file instead.\n * Stub hash: b9310b607794caa862d509ba316a2a512d2736fe */\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster___construct, 0, 0, 1)\n\tZEND_ARG_INFO(0, name)\n\tZEND_ARG_INFO(0, seeds)\n\tZEND_ARG_INFO(0, timeout)\n\tZEND_ARG_INFO(0, read_timeout)\n\tZEND_ARG_INFO(0, persistent)\n\tZEND_ARG_INFO(0, auth)\n\tZEND_ARG_INFO(0, context)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster__compress, 0, 0, 1)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster__uncompress arginfo_class_RedisCluster__compress\n\n#define arginfo_class_RedisCluster__serialize arginfo_class_RedisCluster__compress\n\n#define arginfo_class_RedisCluster__unserialize arginfo_class_RedisCluster__compress\n\n#define arginfo_class_RedisCluster__pack arginfo_class_RedisCluster__compress\n\n#define arginfo_class_RedisCluster__unpack arginfo_class_RedisCluster__compress\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster__prefix, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster__masters, 0, 0, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster__redir arginfo_class_RedisCluster__masters\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_acl, 0, 0, 2)\n\tZEND_ARG_INFO(0, key_or_address)\n\tZEND_ARG_INFO(0, subcmd)\n\tZEND_ARG_VARIADIC_INFO(0, args)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_append, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_bgrewriteaof, 0, 0, 1)\n\tZEND_ARG_INFO(0, key_or_address)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_waitaof, 0, 0, 4)\n\tZEND_ARG_INFO(0, key_or_address)\n\tZEND_ARG_INFO(0, numlocal)\n\tZEND_ARG_INFO(0, numreplicas)\n\tZEND_ARG_INFO(0, timeout)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_bgsave arginfo_class_RedisCluster_bgrewriteaof\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_bitcount, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, end)\n\tZEND_ARG_INFO(0, bybit)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_bitop, 0, 0, 3)\n\tZEND_ARG_INFO(0, operation)\n\tZEND_ARG_INFO(0, deskey)\n\tZEND_ARG_INFO(0, srckey)\n\tZEND_ARG_VARIADIC_INFO(0, otherkeys)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_bitpos, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, bit)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, end)\n\tZEND_ARG_INFO(0, bybit)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_blpop, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, timeout_or_key)\n\tZEND_ARG_VARIADIC_INFO(0, extra_args)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_brpop arginfo_class_RedisCluster_blpop\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_brpoplpush, 0, 0, 3)\n\tZEND_ARG_INFO(0, srckey)\n\tZEND_ARG_INFO(0, deskey)\n\tZEND_ARG_INFO(0, timeout)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_lmove, 0, 0, 4)\n\tZEND_ARG_INFO(0, src)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, wherefrom)\n\tZEND_ARG_INFO(0, whereto)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_blmove, 0, 0, 5)\n\tZEND_ARG_INFO(0, src)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, wherefrom)\n\tZEND_ARG_INFO(0, whereto)\n\tZEND_ARG_INFO(0, timeout)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_bzpopmax arginfo_class_RedisCluster_blpop\n\n#define arginfo_class_RedisCluster_bzpopmin arginfo_class_RedisCluster_blpop\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_bzmpop, 0, 0, 3)\n\tZEND_ARG_INFO(0, timeout)\n\tZEND_ARG_INFO(0, keys)\n\tZEND_ARG_INFO(0, from)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_zmpop, 0, 0, 2)\n\tZEND_ARG_INFO(0, keys)\n\tZEND_ARG_INFO(0, from)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_blmpop arginfo_class_RedisCluster_bzmpop\n\n#define arginfo_class_RedisCluster_lmpop arginfo_class_RedisCluster_zmpop\n\n#define arginfo_class_RedisCluster_clearlasterror arginfo_class_RedisCluster__masters\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_client, 0, 0, 2)\n\tZEND_ARG_INFO(0, key_or_address)\n\tZEND_ARG_INFO(0, subcommand)\n\tZEND_ARG_INFO(0, arg)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_close arginfo_class_RedisCluster__masters\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_cluster, 0, 0, 2)\n\tZEND_ARG_INFO(0, key_or_address)\n\tZEND_ARG_INFO(0, command)\n\tZEND_ARG_VARIADIC_INFO(0, extra_args)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_command, 0, 0, 0)\n\tZEND_ARG_VARIADIC_INFO(0, extra_args)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_config, 0, 0, 2)\n\tZEND_ARG_INFO(0, key_or_address)\n\tZEND_ARG_INFO(0, subcommand)\n\tZEND_ARG_VARIADIC_INFO(0, extra_args)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_dbsize arginfo_class_RedisCluster_bgrewriteaof\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_copy, 0, 0, 2)\n\tZEND_ARG_INFO(0, src)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_decr, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, by)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_decrby arginfo_class_RedisCluster_append\n\n#define arginfo_class_RedisCluster_decrbyfloat arginfo_class_RedisCluster_append\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_del, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_VARIADIC_INFO(0, other_keys)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_discard arginfo_class_RedisCluster__masters\n\n#define arginfo_class_RedisCluster_dump arginfo_class_RedisCluster__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_echo, 0, 0, 2)\n\tZEND_ARG_INFO(0, key_or_address)\n\tZEND_ARG_INFO(0, msg)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_eval, 0, 0, 1)\n\tZEND_ARG_INFO(0, script)\n\tZEND_ARG_INFO(0, args)\n\tZEND_ARG_INFO(0, num_keys)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_eval_ro arginfo_class_RedisCluster_eval\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_evalsha, 0, 0, 1)\n\tZEND_ARG_INFO(0, script_sha)\n\tZEND_ARG_INFO(0, args)\n\tZEND_ARG_INFO(0, num_keys)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_evalsha_ro arginfo_class_RedisCluster_evalsha\n\n#define arginfo_class_RedisCluster_exec arginfo_class_RedisCluster__masters\n\n#define arginfo_class_RedisCluster_exists arginfo_class_RedisCluster_del\n\n#define arginfo_class_RedisCluster_touch arginfo_class_RedisCluster_del\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_expire, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, timeout)\n\tZEND_ARG_INFO(0, mode)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_expireat, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, timestamp)\n\tZEND_ARG_INFO(0, mode)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_expiretime arginfo_class_RedisCluster__prefix\n\n#define arginfo_class_RedisCluster_pexpiretime arginfo_class_RedisCluster__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_flushall, 0, 0, 1)\n\tZEND_ARG_INFO(0, key_or_address)\n\tZEND_ARG_INFO(0, async)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_flushdb arginfo_class_RedisCluster_flushall\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_geoadd, 0, 0, 4)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, lng)\n\tZEND_ARG_INFO(0, lat)\n\tZEND_ARG_INFO(0, member)\n\tZEND_ARG_VARIADIC_INFO(0, other_triples_and_options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_geodist, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, src)\n\tZEND_ARG_INFO(0, dest)\n\tZEND_ARG_INFO(0, unit)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_geohash, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, member)\n\tZEND_ARG_VARIADIC_INFO(0, other_members)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_geopos arginfo_class_RedisCluster_geohash\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_georadius, 0, 0, 5)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, lng)\n\tZEND_ARG_INFO(0, lat)\n\tZEND_ARG_INFO(0, radius)\n\tZEND_ARG_INFO(0, unit)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_georadius_ro arginfo_class_RedisCluster_georadius\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_georadiusbymember, 0, 0, 4)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, member)\n\tZEND_ARG_INFO(0, radius)\n\tZEND_ARG_INFO(0, unit)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_georadiusbymember_ro arginfo_class_RedisCluster_georadiusbymember\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_geosearch, 0, 0, 4)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, position)\n\tZEND_ARG_INFO(0, shape)\n\tZEND_ARG_INFO(0, unit)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_geosearchstore, 0, 0, 5)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, src)\n\tZEND_ARG_INFO(0, position)\n\tZEND_ARG_INFO(0, shape)\n\tZEND_ARG_INFO(0, unit)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_get arginfo_class_RedisCluster__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_getex, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_getbit arginfo_class_RedisCluster_append\n\n#define arginfo_class_RedisCluster_getlasterror arginfo_class_RedisCluster__masters\n\n#define arginfo_class_RedisCluster_getmode arginfo_class_RedisCluster__masters\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_getoption, 0, 0, 1)\n\tZEND_ARG_INFO(0, option)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_getrange, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, end)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_lcs, 0, 0, 2)\n\tZEND_ARG_INFO(0, key1)\n\tZEND_ARG_INFO(0, key2)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_getset arginfo_class_RedisCluster_append\n\n#define arginfo_class_RedisCluster_gettransferredbytes arginfo_class_RedisCluster__masters\n\n#define arginfo_class_RedisCluster_cleartransferredbytes arginfo_class_RedisCluster__masters\n\n#define arginfo_class_RedisCluster_hdel arginfo_class_RedisCluster_geohash\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_hexists, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, member)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_hget arginfo_class_RedisCluster_hexists\n\n#define arginfo_class_RedisCluster_hgetall arginfo_class_RedisCluster__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_hincrby, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, member)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_hincrbyfloat arginfo_class_RedisCluster_hincrby\n\n#define arginfo_class_RedisCluster_hkeys arginfo_class_RedisCluster__prefix\n\n#define arginfo_class_RedisCluster_hlen arginfo_class_RedisCluster__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_hmget, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, keys)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_hmset, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, key_values)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_hscan, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(1, iterator)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_expiremember, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, field)\n\tZEND_ARG_INFO(0, ttl)\n\tZEND_ARG_INFO(0, unit)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_expirememberat, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, field)\n\tZEND_ARG_INFO(0, timestamp)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_hrandfield arginfo_class_RedisCluster_getex\n\n#define arginfo_class_RedisCluster_hset arginfo_class_RedisCluster_hincrby\n\n#define arginfo_class_RedisCluster_hsetnx arginfo_class_RedisCluster_hincrby\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_hstrlen, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, field)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_hvals arginfo_class_RedisCluster__prefix\n\n#define arginfo_class_RedisCluster_incr arginfo_class_RedisCluster_decr\n\n#define arginfo_class_RedisCluster_incrby arginfo_class_RedisCluster_append\n\n#define arginfo_class_RedisCluster_incrbyfloat arginfo_class_RedisCluster_append\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_info, 0, 0, 1)\n\tZEND_ARG_INFO(0, key_or_address)\n\tZEND_ARG_VARIADIC_INFO(0, sections)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_keys, 0, 0, 1)\n\tZEND_ARG_INFO(0, pattern)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_lastsave arginfo_class_RedisCluster_bgrewriteaof\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_lget, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, index)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_lindex arginfo_class_RedisCluster_lget\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_linsert, 0, 0, 4)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, pos)\n\tZEND_ARG_INFO(0, pivot)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_llen arginfo_class_RedisCluster__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_lpop, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_lpos, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, value)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_lpush, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, value)\n\tZEND_ARG_VARIADIC_INFO(0, other_values)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_lpushx arginfo_class_RedisCluster_append\n\n#define arginfo_class_RedisCluster_lrange arginfo_class_RedisCluster_getrange\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_lrem, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, value)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_lset, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_ltrim arginfo_class_RedisCluster_getrange\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_mget, 0, 0, 1)\n\tZEND_ARG_INFO(0, keys)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_mset, 0, 0, 1)\n\tZEND_ARG_INFO(0, key_values)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_msetnx arginfo_class_RedisCluster_mset\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_multi, 0, 0, 0)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_object, 0, 0, 2)\n\tZEND_ARG_INFO(0, subcommand)\n\tZEND_ARG_INFO(0, key)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_persist arginfo_class_RedisCluster__prefix\n\n#define arginfo_class_RedisCluster_pexpire arginfo_class_RedisCluster_expire\n\n#define arginfo_class_RedisCluster_pexpireat arginfo_class_RedisCluster_expireat\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_pfadd, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, elements)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_pfcount arginfo_class_RedisCluster__prefix\n\n#define arginfo_class_RedisCluster_pfmerge arginfo_class_RedisCluster_hmget\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_ping, 0, 0, 1)\n\tZEND_ARG_INFO(0, key_or_address)\n\tZEND_ARG_INFO(0, message)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_psetex, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, timeout)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_psubscribe, 0, 0, 2)\n\tZEND_ARG_INFO(0, patterns)\n\tZEND_ARG_INFO(0, callback)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_pttl arginfo_class_RedisCluster__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_publish, 0, 0, 2)\n\tZEND_ARG_INFO(0, channel)\n\tZEND_ARG_INFO(0, message)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_pubsub, 0, 0, 1)\n\tZEND_ARG_INFO(0, key_or_address)\n\tZEND_ARG_VARIADIC_INFO(0, values)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_punsubscribe, 0, 0, 1)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_VARIADIC_INFO(0, other_patterns)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_randomkey arginfo_class_RedisCluster_bgrewriteaof\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_rawcommand, 0, 0, 2)\n\tZEND_ARG_INFO(0, key_or_address)\n\tZEND_ARG_INFO(0, command)\n\tZEND_ARG_VARIADIC_INFO(0, args)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_rename, 0, 0, 2)\n\tZEND_ARG_INFO(0, key_src)\n\tZEND_ARG_INFO(0, key_dst)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_renamenx, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, newkey)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_restore, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, timeout)\n\tZEND_ARG_INFO(0, value)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_role arginfo_class_RedisCluster_bgrewriteaof\n\n#define arginfo_class_RedisCluster_rpop arginfo_class_RedisCluster_lpop\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_rpoplpush, 0, 0, 2)\n\tZEND_ARG_INFO(0, src)\n\tZEND_ARG_INFO(0, dst)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_rpush, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_VARIADIC_INFO(0, elements)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_rpushx arginfo_class_RedisCluster_append\n\n#define arginfo_class_RedisCluster_sadd arginfo_class_RedisCluster_lpush\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_saddarray, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, values)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_save arginfo_class_RedisCluster_bgrewriteaof\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_scan, 0, 0, 2)\n\tZEND_ARG_INFO(1, iterator)\n\tZEND_ARG_INFO(0, key_or_address)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_scard arginfo_class_RedisCluster__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_script, 0, 0, 1)\n\tZEND_ARG_INFO(0, key_or_address)\n\tZEND_ARG_VARIADIC_INFO(0, args)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_sdiff arginfo_class_RedisCluster_del\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_sdiffstore, 0, 0, 2)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_VARIADIC_INFO(0, other_keys)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_set arginfo_class_RedisCluster_lpos\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_setbit, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, offset)\n\tZEND_ARG_INFO(0, onoff)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_setex, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, expire)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_setnx arginfo_class_RedisCluster_append\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_setoption, 0, 0, 2)\n\tZEND_ARG_INFO(0, option)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_setrange, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, offset)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_sinter arginfo_class_RedisCluster_del\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_sintercard, 0, 0, 1)\n\tZEND_ARG_INFO(0, keys)\n\tZEND_ARG_INFO(0, limit)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_sinterstore arginfo_class_RedisCluster_del\n\n#define arginfo_class_RedisCluster_sismember arginfo_class_RedisCluster_append\n\n#define arginfo_class_RedisCluster_smismember arginfo_class_RedisCluster_geohash\n\n#define arginfo_class_RedisCluster_slowlog arginfo_class_RedisCluster_script\n\n#define arginfo_class_RedisCluster_smembers arginfo_class_RedisCluster__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_smove, 0, 0, 3)\n\tZEND_ARG_INFO(0, src)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, member)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_sort arginfo_class_RedisCluster_getex\n\n#define arginfo_class_RedisCluster_sort_ro arginfo_class_RedisCluster_getex\n\n#define arginfo_class_RedisCluster_spop arginfo_class_RedisCluster_lpop\n\n#define arginfo_class_RedisCluster_srandmember arginfo_class_RedisCluster_lpop\n\n#define arginfo_class_RedisCluster_srem arginfo_class_RedisCluster_lpush\n\n#define arginfo_class_RedisCluster_sscan arginfo_class_RedisCluster_hscan\n\n#define arginfo_class_RedisCluster_strlen arginfo_class_RedisCluster__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_subscribe, 0, 0, 2)\n\tZEND_ARG_INFO(0, channels)\n\tZEND_ARG_INFO(0, cb)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_sunion arginfo_class_RedisCluster_del\n\n#define arginfo_class_RedisCluster_sunionstore arginfo_class_RedisCluster_sdiffstore\n\n#define arginfo_class_RedisCluster_time arginfo_class_RedisCluster_bgrewriteaof\n\n#define arginfo_class_RedisCluster_ttl arginfo_class_RedisCluster__prefix\n\n#define arginfo_class_RedisCluster_type arginfo_class_RedisCluster__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_unsubscribe, 0, 0, 1)\n\tZEND_ARG_INFO(0, channels)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_unlink arginfo_class_RedisCluster_del\n\n#define arginfo_class_RedisCluster_unwatch arginfo_class_RedisCluster__masters\n\n#define arginfo_class_RedisCluster_watch arginfo_class_RedisCluster_del\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_xack, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, group)\n\tZEND_ARG_INFO(0, ids)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_xadd, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, id)\n\tZEND_ARG_INFO(0, values)\n\tZEND_ARG_INFO(0, maxlen)\n\tZEND_ARG_INFO(0, approx)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_xclaim, 0, 0, 6)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, group)\n\tZEND_ARG_INFO(0, consumer)\n\tZEND_ARG_INFO(0, min_iddle)\n\tZEND_ARG_INFO(0, ids)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_xdel, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, ids)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_xgroup, 0, 0, 1)\n\tZEND_ARG_INFO(0, operation)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, group)\n\tZEND_ARG_INFO(0, id_or_consumer)\n\tZEND_ARG_INFO(0, mkstream)\n\tZEND_ARG_INFO(0, entries_read)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_xautoclaim, 0, 0, 5)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, group)\n\tZEND_ARG_INFO(0, consumer)\n\tZEND_ARG_INFO(0, min_idle)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, count)\n\tZEND_ARG_INFO(0, justid)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_xinfo, 0, 0, 1)\n\tZEND_ARG_INFO(0, operation)\n\tZEND_ARG_INFO(0, arg1)\n\tZEND_ARG_INFO(0, arg2)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_xlen arginfo_class_RedisCluster__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_xpending, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, group)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, end)\n\tZEND_ARG_INFO(0, count)\n\tZEND_ARG_INFO(0, consumer)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_xrange, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, end)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_xread, 0, 0, 1)\n\tZEND_ARG_INFO(0, streams)\n\tZEND_ARG_INFO(0, count)\n\tZEND_ARG_INFO(0, block)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_xreadgroup, 0, 0, 3)\n\tZEND_ARG_INFO(0, group)\n\tZEND_ARG_INFO(0, consumer)\n\tZEND_ARG_INFO(0, streams)\n\tZEND_ARG_INFO(0, count)\n\tZEND_ARG_INFO(0, block)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_xrevrange arginfo_class_RedisCluster_xrange\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_xtrim, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, maxlen)\n\tZEND_ARG_INFO(0, approx)\n\tZEND_ARG_INFO(0, minid)\n\tZEND_ARG_INFO(0, limit)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_zadd, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, score_or_options)\n\tZEND_ARG_VARIADIC_INFO(0, more_scores_and_mems)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_zcard arginfo_class_RedisCluster__prefix\n\n#define arginfo_class_RedisCluster_zcount arginfo_class_RedisCluster_getrange\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_zincrby, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, value)\n\tZEND_ARG_INFO(0, member)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_zinterstore, 0, 0, 2)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, keys)\n\tZEND_ARG_INFO(0, weights)\n\tZEND_ARG_INFO(0, aggregate)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_zintercard arginfo_class_RedisCluster_sintercard\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_zlexcount, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, min)\n\tZEND_ARG_INFO(0, max)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_zpopmax, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_zpopmin arginfo_class_RedisCluster_zpopmax\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_zrange, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, end)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_zrangestore, 0, 0, 4)\n\tZEND_ARG_INFO(0, dstkey)\n\tZEND_ARG_INFO(0, srckey)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, end)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_zrandmember arginfo_class_RedisCluster_getex\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_zrangebylex, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, min)\n\tZEND_ARG_INFO(0, max)\n\tZEND_ARG_INFO(0, offset)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_zrangebyscore arginfo_class_RedisCluster_zrange\n\n#define arginfo_class_RedisCluster_zrank arginfo_class_RedisCluster_hexists\n\n#define arginfo_class_RedisCluster_zrem arginfo_class_RedisCluster_lpush\n\n#define arginfo_class_RedisCluster_zremrangebylex arginfo_class_RedisCluster_zlexcount\n\n#define arginfo_class_RedisCluster_zremrangebyrank arginfo_class_RedisCluster_zlexcount\n\n#define arginfo_class_RedisCluster_zremrangebyscore arginfo_class_RedisCluster_zlexcount\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_zrevrange, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, min)\n\tZEND_ARG_INFO(0, max)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_zrevrangebylex arginfo_class_RedisCluster_zrevrange\n\n#define arginfo_class_RedisCluster_zrevrangebyscore arginfo_class_RedisCluster_zrevrange\n\n#define arginfo_class_RedisCluster_zrevrank arginfo_class_RedisCluster_hexists\n\n#define arginfo_class_RedisCluster_zscan arginfo_class_RedisCluster_hscan\n\n#define arginfo_class_RedisCluster_zscore arginfo_class_RedisCluster_hexists\n\n#define arginfo_class_RedisCluster_zmscore arginfo_class_RedisCluster_geohash\n\n#define arginfo_class_RedisCluster_zunionstore arginfo_class_RedisCluster_zinterstore\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_zinter, 0, 0, 1)\n\tZEND_ARG_INFO(0, keys)\n\tZEND_ARG_INFO(0, weights)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_zdiffstore, 0, 0, 2)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, keys)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisCluster_zunion arginfo_class_RedisCluster_zinter\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisCluster_zdiff, 0, 0, 1)\n\tZEND_ARG_INFO(0, keys)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n\nZEND_METHOD(RedisCluster, __construct);\nZEND_METHOD(RedisCluster, _compress);\nZEND_METHOD(RedisCluster, _uncompress);\nZEND_METHOD(RedisCluster, _serialize);\nZEND_METHOD(RedisCluster, _unserialize);\nZEND_METHOD(RedisCluster, _pack);\nZEND_METHOD(RedisCluster, _unpack);\nZEND_METHOD(RedisCluster, _prefix);\nZEND_METHOD(RedisCluster, _masters);\nZEND_METHOD(RedisCluster, _redir);\nZEND_METHOD(RedisCluster, acl);\nZEND_METHOD(RedisCluster, append);\nZEND_METHOD(RedisCluster, bgrewriteaof);\nZEND_METHOD(RedisCluster, waitaof);\nZEND_METHOD(RedisCluster, bgsave);\nZEND_METHOD(RedisCluster, bitcount);\nZEND_METHOD(RedisCluster, bitop);\nZEND_METHOD(RedisCluster, bitpos);\nZEND_METHOD(RedisCluster, blpop);\nZEND_METHOD(RedisCluster, brpop);\nZEND_METHOD(RedisCluster, brpoplpush);\nZEND_METHOD(RedisCluster, lmove);\nZEND_METHOD(RedisCluster, blmove);\nZEND_METHOD(RedisCluster, bzpopmax);\nZEND_METHOD(RedisCluster, bzpopmin);\nZEND_METHOD(RedisCluster, bzmpop);\nZEND_METHOD(RedisCluster, zmpop);\nZEND_METHOD(RedisCluster, blmpop);\nZEND_METHOD(RedisCluster, lmpop);\nZEND_METHOD(RedisCluster, clearlasterror);\nZEND_METHOD(RedisCluster, client);\nZEND_METHOD(RedisCluster, close);\nZEND_METHOD(RedisCluster, cluster);\nZEND_METHOD(RedisCluster, command);\nZEND_METHOD(RedisCluster, config);\nZEND_METHOD(RedisCluster, dbsize);\nZEND_METHOD(RedisCluster, copy);\nZEND_METHOD(RedisCluster, decr);\nZEND_METHOD(RedisCluster, decrby);\nZEND_METHOD(RedisCluster, decrbyfloat);\nZEND_METHOD(RedisCluster, del);\nZEND_METHOD(RedisCluster, discard);\nZEND_METHOD(RedisCluster, dump);\nZEND_METHOD(RedisCluster, echo);\nZEND_METHOD(RedisCluster, eval);\nZEND_METHOD(RedisCluster, eval_ro);\nZEND_METHOD(RedisCluster, evalsha);\nZEND_METHOD(RedisCluster, evalsha_ro);\nZEND_METHOD(RedisCluster, exec);\nZEND_METHOD(RedisCluster, exists);\nZEND_METHOD(RedisCluster, touch);\nZEND_METHOD(RedisCluster, expire);\nZEND_METHOD(RedisCluster, expireat);\nZEND_METHOD(RedisCluster, expiretime);\nZEND_METHOD(RedisCluster, pexpiretime);\nZEND_METHOD(RedisCluster, flushall);\nZEND_METHOD(RedisCluster, flushdb);\nZEND_METHOD(RedisCluster, geoadd);\nZEND_METHOD(RedisCluster, geodist);\nZEND_METHOD(RedisCluster, geohash);\nZEND_METHOD(RedisCluster, geopos);\nZEND_METHOD(RedisCluster, georadius);\nZEND_METHOD(RedisCluster, georadius_ro);\nZEND_METHOD(RedisCluster, georadiusbymember);\nZEND_METHOD(RedisCluster, georadiusbymember_ro);\nZEND_METHOD(RedisCluster, geosearch);\nZEND_METHOD(RedisCluster, geosearchstore);\nZEND_METHOD(RedisCluster, get);\nZEND_METHOD(RedisCluster, getex);\nZEND_METHOD(RedisCluster, getbit);\nZEND_METHOD(RedisCluster, getlasterror);\nZEND_METHOD(RedisCluster, getmode);\nZEND_METHOD(RedisCluster, getoption);\nZEND_METHOD(RedisCluster, getrange);\nZEND_METHOD(RedisCluster, lcs);\nZEND_METHOD(RedisCluster, getset);\nZEND_METHOD(RedisCluster, gettransferredbytes);\nZEND_METHOD(RedisCluster, cleartransferredbytes);\nZEND_METHOD(RedisCluster, hdel);\nZEND_METHOD(RedisCluster, hexists);\nZEND_METHOD(RedisCluster, hget);\nZEND_METHOD(RedisCluster, hgetall);\nZEND_METHOD(RedisCluster, hincrby);\nZEND_METHOD(RedisCluster, hincrbyfloat);\nZEND_METHOD(RedisCluster, hkeys);\nZEND_METHOD(RedisCluster, hlen);\nZEND_METHOD(RedisCluster, hmget);\nZEND_METHOD(RedisCluster, hmset);\nZEND_METHOD(RedisCluster, hscan);\nZEND_METHOD(RedisCluster, expiremember);\nZEND_METHOD(RedisCluster, expirememberat);\nZEND_METHOD(RedisCluster, hrandfield);\nZEND_METHOD(RedisCluster, hset);\nZEND_METHOD(RedisCluster, hsetnx);\nZEND_METHOD(RedisCluster, hstrlen);\nZEND_METHOD(RedisCluster, hvals);\nZEND_METHOD(RedisCluster, incr);\nZEND_METHOD(RedisCluster, incrby);\nZEND_METHOD(RedisCluster, incrbyfloat);\nZEND_METHOD(RedisCluster, info);\nZEND_METHOD(RedisCluster, keys);\nZEND_METHOD(RedisCluster, lastsave);\nZEND_METHOD(RedisCluster, lget);\nZEND_METHOD(RedisCluster, lindex);\nZEND_METHOD(RedisCluster, linsert);\nZEND_METHOD(RedisCluster, llen);\nZEND_METHOD(RedisCluster, lpop);\nZEND_METHOD(RedisCluster, lpos);\nZEND_METHOD(RedisCluster, lpush);\nZEND_METHOD(RedisCluster, lpushx);\nZEND_METHOD(RedisCluster, lrange);\nZEND_METHOD(RedisCluster, lrem);\nZEND_METHOD(RedisCluster, lset);\nZEND_METHOD(RedisCluster, ltrim);\nZEND_METHOD(RedisCluster, mget);\nZEND_METHOD(RedisCluster, mset);\nZEND_METHOD(RedisCluster, msetnx);\nZEND_METHOD(RedisCluster, multi);\nZEND_METHOD(RedisCluster, object);\nZEND_METHOD(RedisCluster, persist);\nZEND_METHOD(RedisCluster, pexpire);\nZEND_METHOD(RedisCluster, pexpireat);\nZEND_METHOD(RedisCluster, pfadd);\nZEND_METHOD(RedisCluster, pfcount);\nZEND_METHOD(RedisCluster, pfmerge);\nZEND_METHOD(RedisCluster, ping);\nZEND_METHOD(RedisCluster, psetex);\nZEND_METHOD(RedisCluster, psubscribe);\nZEND_METHOD(RedisCluster, pttl);\nZEND_METHOD(RedisCluster, publish);\nZEND_METHOD(RedisCluster, pubsub);\nZEND_METHOD(RedisCluster, punsubscribe);\nZEND_METHOD(RedisCluster, randomkey);\nZEND_METHOD(RedisCluster, rawcommand);\nZEND_METHOD(RedisCluster, rename);\nZEND_METHOD(RedisCluster, renamenx);\nZEND_METHOD(RedisCluster, restore);\nZEND_METHOD(RedisCluster, role);\nZEND_METHOD(RedisCluster, rpop);\nZEND_METHOD(RedisCluster, rpoplpush);\nZEND_METHOD(RedisCluster, rpush);\nZEND_METHOD(RedisCluster, rpushx);\nZEND_METHOD(RedisCluster, sadd);\nZEND_METHOD(RedisCluster, saddarray);\nZEND_METHOD(RedisCluster, save);\nZEND_METHOD(RedisCluster, scan);\nZEND_METHOD(RedisCluster, scard);\nZEND_METHOD(RedisCluster, script);\nZEND_METHOD(RedisCluster, sdiff);\nZEND_METHOD(RedisCluster, sdiffstore);\nZEND_METHOD(RedisCluster, set);\nZEND_METHOD(RedisCluster, setbit);\nZEND_METHOD(RedisCluster, setex);\nZEND_METHOD(RedisCluster, setnx);\nZEND_METHOD(RedisCluster, setoption);\nZEND_METHOD(RedisCluster, setrange);\nZEND_METHOD(RedisCluster, sinter);\nZEND_METHOD(RedisCluster, sintercard);\nZEND_METHOD(RedisCluster, sinterstore);\nZEND_METHOD(RedisCluster, sismember);\nZEND_METHOD(RedisCluster, smismember);\nZEND_METHOD(RedisCluster, slowlog);\nZEND_METHOD(RedisCluster, smembers);\nZEND_METHOD(RedisCluster, smove);\nZEND_METHOD(RedisCluster, sort);\nZEND_METHOD(RedisCluster, sort_ro);\nZEND_METHOD(RedisCluster, spop);\nZEND_METHOD(RedisCluster, srandmember);\nZEND_METHOD(RedisCluster, srem);\nZEND_METHOD(RedisCluster, sscan);\nZEND_METHOD(RedisCluster, strlen);\nZEND_METHOD(RedisCluster, subscribe);\nZEND_METHOD(RedisCluster, sunion);\nZEND_METHOD(RedisCluster, sunionstore);\nZEND_METHOD(RedisCluster, time);\nZEND_METHOD(RedisCluster, ttl);\nZEND_METHOD(RedisCluster, type);\nZEND_METHOD(RedisCluster, unsubscribe);\nZEND_METHOD(RedisCluster, unlink);\nZEND_METHOD(RedisCluster, unwatch);\nZEND_METHOD(RedisCluster, watch);\nZEND_METHOD(RedisCluster, xack);\nZEND_METHOD(RedisCluster, xadd);\nZEND_METHOD(RedisCluster, xclaim);\nZEND_METHOD(RedisCluster, xdel);\nZEND_METHOD(RedisCluster, xgroup);\nZEND_METHOD(RedisCluster, xautoclaim);\nZEND_METHOD(RedisCluster, xinfo);\nZEND_METHOD(RedisCluster, xlen);\nZEND_METHOD(RedisCluster, xpending);\nZEND_METHOD(RedisCluster, xrange);\nZEND_METHOD(RedisCluster, xread);\nZEND_METHOD(RedisCluster, xreadgroup);\nZEND_METHOD(RedisCluster, xrevrange);\nZEND_METHOD(RedisCluster, xtrim);\nZEND_METHOD(RedisCluster, zadd);\nZEND_METHOD(RedisCluster, zcard);\nZEND_METHOD(RedisCluster, zcount);\nZEND_METHOD(RedisCluster, zincrby);\nZEND_METHOD(RedisCluster, zinterstore);\nZEND_METHOD(RedisCluster, zintercard);\nZEND_METHOD(RedisCluster, zlexcount);\nZEND_METHOD(RedisCluster, zpopmax);\nZEND_METHOD(RedisCluster, zpopmin);\nZEND_METHOD(RedisCluster, zrange);\nZEND_METHOD(RedisCluster, zrangestore);\nZEND_METHOD(RedisCluster, zrandmember);\nZEND_METHOD(RedisCluster, zrangebylex);\nZEND_METHOD(RedisCluster, zrangebyscore);\nZEND_METHOD(RedisCluster, zrank);\nZEND_METHOD(RedisCluster, zrem);\nZEND_METHOD(RedisCluster, zremrangebylex);\nZEND_METHOD(RedisCluster, zremrangebyrank);\nZEND_METHOD(RedisCluster, zremrangebyscore);\nZEND_METHOD(RedisCluster, zrevrange);\nZEND_METHOD(RedisCluster, zrevrangebylex);\nZEND_METHOD(RedisCluster, zrevrangebyscore);\nZEND_METHOD(RedisCluster, zrevrank);\nZEND_METHOD(RedisCluster, zscan);\nZEND_METHOD(RedisCluster, zscore);\nZEND_METHOD(RedisCluster, zmscore);\nZEND_METHOD(RedisCluster, zunionstore);\nZEND_METHOD(RedisCluster, zinter);\nZEND_METHOD(RedisCluster, zdiffstore);\nZEND_METHOD(RedisCluster, zunion);\nZEND_METHOD(RedisCluster, zdiff);\n\n\nstatic const zend_function_entry class_RedisCluster_methods[] = {\n\tZEND_ME(RedisCluster, __construct, arginfo_class_RedisCluster___construct, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _compress, arginfo_class_RedisCluster__compress, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _uncompress, arginfo_class_RedisCluster__uncompress, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _serialize, arginfo_class_RedisCluster__serialize, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _unserialize, arginfo_class_RedisCluster__unserialize, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _pack, arginfo_class_RedisCluster__pack, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _unpack, arginfo_class_RedisCluster__unpack, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _prefix, arginfo_class_RedisCluster__prefix, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _masters, arginfo_class_RedisCluster__masters, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, _redir, arginfo_class_RedisCluster__redir, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, acl, arginfo_class_RedisCluster_acl, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, append, arginfo_class_RedisCluster_append, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bgrewriteaof, arginfo_class_RedisCluster_bgrewriteaof, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, waitaof, arginfo_class_RedisCluster_waitaof, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bgsave, arginfo_class_RedisCluster_bgsave, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bitcount, arginfo_class_RedisCluster_bitcount, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bitop, arginfo_class_RedisCluster_bitop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bitpos, arginfo_class_RedisCluster_bitpos, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, blpop, arginfo_class_RedisCluster_blpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, brpop, arginfo_class_RedisCluster_brpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, brpoplpush, arginfo_class_RedisCluster_brpoplpush, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lmove, arginfo_class_RedisCluster_lmove, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, blmove, arginfo_class_RedisCluster_blmove, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bzpopmax, arginfo_class_RedisCluster_bzpopmax, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bzpopmin, arginfo_class_RedisCluster_bzpopmin, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, bzmpop, arginfo_class_RedisCluster_bzmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zmpop, arginfo_class_RedisCluster_zmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, blmpop, arginfo_class_RedisCluster_blmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lmpop, arginfo_class_RedisCluster_lmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, clearlasterror, arginfo_class_RedisCluster_clearlasterror, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, client, arginfo_class_RedisCluster_client, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, close, arginfo_class_RedisCluster_close, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, cluster, arginfo_class_RedisCluster_cluster, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, command, arginfo_class_RedisCluster_command, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, config, arginfo_class_RedisCluster_config, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, dbsize, arginfo_class_RedisCluster_dbsize, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, copy, arginfo_class_RedisCluster_copy, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, decr, arginfo_class_RedisCluster_decr, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, decrby, arginfo_class_RedisCluster_decrby, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, decrbyfloat, arginfo_class_RedisCluster_decrbyfloat, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, del, arginfo_class_RedisCluster_del, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, discard, arginfo_class_RedisCluster_discard, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, dump, arginfo_class_RedisCluster_dump, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, echo, arginfo_class_RedisCluster_echo, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, eval, arginfo_class_RedisCluster_eval, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, eval_ro, arginfo_class_RedisCluster_eval_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, evalsha, arginfo_class_RedisCluster_evalsha, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, evalsha_ro, arginfo_class_RedisCluster_evalsha_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, exec, arginfo_class_RedisCluster_exec, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, exists, arginfo_class_RedisCluster_exists, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, touch, arginfo_class_RedisCluster_touch, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, expire, arginfo_class_RedisCluster_expire, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, expireat, arginfo_class_RedisCluster_expireat, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, expiretime, arginfo_class_RedisCluster_expiretime, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pexpiretime, arginfo_class_RedisCluster_pexpiretime, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, flushall, arginfo_class_RedisCluster_flushall, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, flushdb, arginfo_class_RedisCluster_flushdb, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, geoadd, arginfo_class_RedisCluster_geoadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, geodist, arginfo_class_RedisCluster_geodist, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, geohash, arginfo_class_RedisCluster_geohash, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, geopos, arginfo_class_RedisCluster_geopos, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, georadius, arginfo_class_RedisCluster_georadius, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, georadius_ro, arginfo_class_RedisCluster_georadius_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, georadiusbymember, arginfo_class_RedisCluster_georadiusbymember, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, georadiusbymember_ro, arginfo_class_RedisCluster_georadiusbymember_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, geosearch, arginfo_class_RedisCluster_geosearch, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, geosearchstore, arginfo_class_RedisCluster_geosearchstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, get, arginfo_class_RedisCluster_get, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, getex, arginfo_class_RedisCluster_getex, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, getbit, arginfo_class_RedisCluster_getbit, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, getlasterror, arginfo_class_RedisCluster_getlasterror, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, getmode, arginfo_class_RedisCluster_getmode, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, getoption, arginfo_class_RedisCluster_getoption, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, getrange, arginfo_class_RedisCluster_getrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lcs, arginfo_class_RedisCluster_lcs, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, getset, arginfo_class_RedisCluster_getset, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, gettransferredbytes, arginfo_class_RedisCluster_gettransferredbytes, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, cleartransferredbytes, arginfo_class_RedisCluster_cleartransferredbytes, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hdel, arginfo_class_RedisCluster_hdel, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hexists, arginfo_class_RedisCluster_hexists, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hget, arginfo_class_RedisCluster_hget, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hgetall, arginfo_class_RedisCluster_hgetall, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hincrby, arginfo_class_RedisCluster_hincrby, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hincrbyfloat, arginfo_class_RedisCluster_hincrbyfloat, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hkeys, arginfo_class_RedisCluster_hkeys, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hlen, arginfo_class_RedisCluster_hlen, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hmget, arginfo_class_RedisCluster_hmget, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hmset, arginfo_class_RedisCluster_hmset, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hscan, arginfo_class_RedisCluster_hscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, expiremember, arginfo_class_RedisCluster_expiremember, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, expirememberat, arginfo_class_RedisCluster_expirememberat, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hrandfield, arginfo_class_RedisCluster_hrandfield, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hset, arginfo_class_RedisCluster_hset, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hsetnx, arginfo_class_RedisCluster_hsetnx, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hstrlen, arginfo_class_RedisCluster_hstrlen, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, hvals, arginfo_class_RedisCluster_hvals, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, incr, arginfo_class_RedisCluster_incr, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, incrby, arginfo_class_RedisCluster_incrby, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, incrbyfloat, arginfo_class_RedisCluster_incrbyfloat, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, info, arginfo_class_RedisCluster_info, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, keys, arginfo_class_RedisCluster_keys, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lastsave, arginfo_class_RedisCluster_lastsave, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lget, arginfo_class_RedisCluster_lget, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lindex, arginfo_class_RedisCluster_lindex, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, linsert, arginfo_class_RedisCluster_linsert, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, llen, arginfo_class_RedisCluster_llen, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lpop, arginfo_class_RedisCluster_lpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lpos, arginfo_class_RedisCluster_lpos, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lpush, arginfo_class_RedisCluster_lpush, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lpushx, arginfo_class_RedisCluster_lpushx, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lrange, arginfo_class_RedisCluster_lrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lrem, arginfo_class_RedisCluster_lrem, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, lset, arginfo_class_RedisCluster_lset, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, ltrim, arginfo_class_RedisCluster_ltrim, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, mget, arginfo_class_RedisCluster_mget, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, mset, arginfo_class_RedisCluster_mset, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, msetnx, arginfo_class_RedisCluster_msetnx, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, multi, arginfo_class_RedisCluster_multi, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, object, arginfo_class_RedisCluster_object, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, persist, arginfo_class_RedisCluster_persist, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pexpire, arginfo_class_RedisCluster_pexpire, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pexpireat, arginfo_class_RedisCluster_pexpireat, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pfadd, arginfo_class_RedisCluster_pfadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pfcount, arginfo_class_RedisCluster_pfcount, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pfmerge, arginfo_class_RedisCluster_pfmerge, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, ping, arginfo_class_RedisCluster_ping, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, psetex, arginfo_class_RedisCluster_psetex, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, psubscribe, arginfo_class_RedisCluster_psubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pttl, arginfo_class_RedisCluster_pttl, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, publish, arginfo_class_RedisCluster_publish, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, pubsub, arginfo_class_RedisCluster_pubsub, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, punsubscribe, arginfo_class_RedisCluster_punsubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, randomkey, arginfo_class_RedisCluster_randomkey, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, rawcommand, arginfo_class_RedisCluster_rawcommand, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, rename, arginfo_class_RedisCluster_rename, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, renamenx, arginfo_class_RedisCluster_renamenx, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, restore, arginfo_class_RedisCluster_restore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, role, arginfo_class_RedisCluster_role, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, rpop, arginfo_class_RedisCluster_rpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, rpoplpush, arginfo_class_RedisCluster_rpoplpush, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, rpush, arginfo_class_RedisCluster_rpush, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, rpushx, arginfo_class_RedisCluster_rpushx, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sadd, arginfo_class_RedisCluster_sadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, saddarray, arginfo_class_RedisCluster_saddarray, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, save, arginfo_class_RedisCluster_save, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, scan, arginfo_class_RedisCluster_scan, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, scard, arginfo_class_RedisCluster_scard, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, script, arginfo_class_RedisCluster_script, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sdiff, arginfo_class_RedisCluster_sdiff, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sdiffstore, arginfo_class_RedisCluster_sdiffstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, set, arginfo_class_RedisCluster_set, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, setbit, arginfo_class_RedisCluster_setbit, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, setex, arginfo_class_RedisCluster_setex, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, setnx, arginfo_class_RedisCluster_setnx, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, setoption, arginfo_class_RedisCluster_setoption, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, setrange, arginfo_class_RedisCluster_setrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sinter, arginfo_class_RedisCluster_sinter, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sintercard, arginfo_class_RedisCluster_sintercard, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sinterstore, arginfo_class_RedisCluster_sinterstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sismember, arginfo_class_RedisCluster_sismember, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, smismember, arginfo_class_RedisCluster_smismember, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, slowlog, arginfo_class_RedisCluster_slowlog, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, smembers, arginfo_class_RedisCluster_smembers, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, smove, arginfo_class_RedisCluster_smove, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sort, arginfo_class_RedisCluster_sort, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sort_ro, arginfo_class_RedisCluster_sort_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, spop, arginfo_class_RedisCluster_spop, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, srandmember, arginfo_class_RedisCluster_srandmember, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, srem, arginfo_class_RedisCluster_srem, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sscan, arginfo_class_RedisCluster_sscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, strlen, arginfo_class_RedisCluster_strlen, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, subscribe, arginfo_class_RedisCluster_subscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sunion, arginfo_class_RedisCluster_sunion, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, sunionstore, arginfo_class_RedisCluster_sunionstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, time, arginfo_class_RedisCluster_time, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, ttl, arginfo_class_RedisCluster_ttl, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, type, arginfo_class_RedisCluster_type, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, unsubscribe, arginfo_class_RedisCluster_unsubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, unlink, arginfo_class_RedisCluster_unlink, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, unwatch, arginfo_class_RedisCluster_unwatch, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, watch, arginfo_class_RedisCluster_watch, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xack, arginfo_class_RedisCluster_xack, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xadd, arginfo_class_RedisCluster_xadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xclaim, arginfo_class_RedisCluster_xclaim, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xdel, arginfo_class_RedisCluster_xdel, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xgroup, arginfo_class_RedisCluster_xgroup, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xautoclaim, arginfo_class_RedisCluster_xautoclaim, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xinfo, arginfo_class_RedisCluster_xinfo, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xlen, arginfo_class_RedisCluster_xlen, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xpending, arginfo_class_RedisCluster_xpending, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xrange, arginfo_class_RedisCluster_xrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xread, arginfo_class_RedisCluster_xread, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xreadgroup, arginfo_class_RedisCluster_xreadgroup, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xrevrange, arginfo_class_RedisCluster_xrevrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, xtrim, arginfo_class_RedisCluster_xtrim, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zadd, arginfo_class_RedisCluster_zadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zcard, arginfo_class_RedisCluster_zcard, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zcount, arginfo_class_RedisCluster_zcount, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zincrby, arginfo_class_RedisCluster_zincrby, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zinterstore, arginfo_class_RedisCluster_zinterstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zintercard, arginfo_class_RedisCluster_zintercard, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zlexcount, arginfo_class_RedisCluster_zlexcount, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zpopmax, arginfo_class_RedisCluster_zpopmax, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zpopmin, arginfo_class_RedisCluster_zpopmin, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrange, arginfo_class_RedisCluster_zrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrangestore, arginfo_class_RedisCluster_zrangestore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrandmember, arginfo_class_RedisCluster_zrandmember, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrangebylex, arginfo_class_RedisCluster_zrangebylex, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrangebyscore, arginfo_class_RedisCluster_zrangebyscore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrank, arginfo_class_RedisCluster_zrank, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrem, arginfo_class_RedisCluster_zrem, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zremrangebylex, arginfo_class_RedisCluster_zremrangebylex, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zremrangebyrank, arginfo_class_RedisCluster_zremrangebyrank, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zremrangebyscore, arginfo_class_RedisCluster_zremrangebyscore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrevrange, arginfo_class_RedisCluster_zrevrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrevrangebylex, arginfo_class_RedisCluster_zrevrangebylex, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrevrangebyscore, arginfo_class_RedisCluster_zrevrangebyscore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zrevrank, arginfo_class_RedisCluster_zrevrank, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zscan, arginfo_class_RedisCluster_zscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zscore, arginfo_class_RedisCluster_zscore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zmscore, arginfo_class_RedisCluster_zmscore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zunionstore, arginfo_class_RedisCluster_zunionstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zinter, arginfo_class_RedisCluster_zinter, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zdiffstore, arginfo_class_RedisCluster_zdiffstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zunion, arginfo_class_RedisCluster_zunion, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisCluster, zdiff, arginfo_class_RedisCluster_zdiff, ZEND_ACC_PUBLIC)\n\tZEND_FE_END\n};\n\n\nstatic const zend_function_entry class_RedisClusterException_methods[] = {\n\tZEND_FE_END\n};\n\nstatic zend_class_entry *register_class_RedisCluster(void)\n{\n\tzend_class_entry ce, *class_entry;\n\n\tINIT_CLASS_ENTRY(ce, \"RedisCluster\", class_RedisCluster_methods);\n\tclass_entry = zend_register_internal_class_ex(&ce, NULL);\n\n\tzval const_OPT_SLAVE_FAILOVER_value;\n\tZVAL_LONG(&const_OPT_SLAVE_FAILOVER_value, REDIS_OPT_FAILOVER);\n\tzend_string *const_OPT_SLAVE_FAILOVER_name = zend_string_init_interned(\"OPT_SLAVE_FAILOVER\", sizeof(\"OPT_SLAVE_FAILOVER\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_SLAVE_FAILOVER_name, &const_OPT_SLAVE_FAILOVER_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_SLAVE_FAILOVER_name);\n\n\tzval const_FAILOVER_NONE_value;\n\tZVAL_LONG(&const_FAILOVER_NONE_value, REDIS_FAILOVER_NONE);\n\tzend_string *const_FAILOVER_NONE_name = zend_string_init_interned(\"FAILOVER_NONE\", sizeof(\"FAILOVER_NONE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_FAILOVER_NONE_name, &const_FAILOVER_NONE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_FAILOVER_NONE_name);\n\n\tzval const_FAILOVER_ERROR_value;\n\tZVAL_LONG(&const_FAILOVER_ERROR_value, REDIS_FAILOVER_ERROR);\n\tzend_string *const_FAILOVER_ERROR_name = zend_string_init_interned(\"FAILOVER_ERROR\", sizeof(\"FAILOVER_ERROR\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_FAILOVER_ERROR_name, &const_FAILOVER_ERROR_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_FAILOVER_ERROR_name);\n\n\tzval const_FAILOVER_DISTRIBUTE_value;\n\tZVAL_LONG(&const_FAILOVER_DISTRIBUTE_value, REDIS_FAILOVER_DISTRIBUTE);\n\tzend_string *const_FAILOVER_DISTRIBUTE_name = zend_string_init_interned(\"FAILOVER_DISTRIBUTE\", sizeof(\"FAILOVER_DISTRIBUTE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_FAILOVER_DISTRIBUTE_name, &const_FAILOVER_DISTRIBUTE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_FAILOVER_DISTRIBUTE_name);\n\n\tzval const_FAILOVER_DISTRIBUTE_SLAVES_value;\n\tZVAL_LONG(&const_FAILOVER_DISTRIBUTE_SLAVES_value, REDIS_FAILOVER_DISTRIBUTE_SLAVES);\n\tzend_string *const_FAILOVER_DISTRIBUTE_SLAVES_name = zend_string_init_interned(\"FAILOVER_DISTRIBUTE_SLAVES\", sizeof(\"FAILOVER_DISTRIBUTE_SLAVES\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_FAILOVER_DISTRIBUTE_SLAVES_name, &const_FAILOVER_DISTRIBUTE_SLAVES_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_FAILOVER_DISTRIBUTE_SLAVES_name);\n\n\treturn class_entry;\n}\n\nstatic zend_class_entry *register_class_RedisClusterException(zend_class_entry *class_entry_RuntimeException)\n{\n\tzend_class_entry ce, *class_entry;\n\n\tINIT_CLASS_ENTRY(ce, \"RedisClusterException\", class_RedisClusterException_methods);\n\tclass_entry = zend_register_internal_class_ex(&ce, class_entry_RuntimeException);\n\n\treturn class_entry;\n}\n"
        },
        {
          "name": "redis_commands.c",
          "type": "blob",
          "size": 207.2763671875,
          "content": "/* -*- Mode: C; tab-width: 4 -*- */\n/*\n  +----------------------------------------------------------------------+\n  | Copyright (c) 1997-2009 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt                                  |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Original Author: Michael Grunder <michael.grunder@gmail.com          |\n  | Maintainer: Nicolas Favre-Felix <n.favre-felix@owlient.eu>           |\n  +----------------------------------------------------------------------+\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"redis_commands.h\"\n\n#include \"php_network.h\"\n\n#ifndef PHP_WIN32\n#include <netinet/tcp.h> /* TCP_KEEPALIVE */\n#else\n#include <winsock.h>\n#endif\n\n#include <zend_exceptions.h>\n\n/* Georadius sort type */\ntypedef enum geoSortType {\n    SORT_NONE,\n    SORT_ASC,\n    SORT_DESC\n} geoSortType;\n\n/* Georadius store type */\ntypedef enum geoStoreType {\n    STORE_NONE,\n    STORE_COORD,\n    STORE_DIST\n} geoStoreType;\n\n/* Georadius options structure */\ntypedef struct geoOptions {\n    int withcoord;\n    int withdist;\n    int withhash;\n    long count;\n    zend_bool any;\n    geoSortType sort;\n    geoStoreType store;\n    zend_string *key;\n} geoOptions;\n\ntypedef struct redisLcsOptions {\n    zend_bool len;\n    zend_bool idx;\n    zend_long minmatchlen;\n    zend_bool withmatchlen;\n} redisLcsOptions;\n\ntypedef struct redisRestoreOptions {\n    zend_bool replace;\n    zend_bool absttl;\n    zend_long idletime;\n    zend_long freq;\n} redisRestoreOptions;\n\n#define REDIS_ZCMD_HAS_DST_KEY      (1 << 0)\n#define REDIS_ZCMD_HAS_WITHSCORES   (1 << 1)\n#define REDIS_ZCMD_HAS_BY_LEX_SCORE (1 << 2)\n#define REDIS_ZCMD_HAS_REV          (1 << 3)\n#define REDIS_ZCMD_HAS_LIMIT        (1 << 4)\n#define REDIS_ZCMD_INT_RANGE        (1 << 5)\n#define REDIS_ZCMD_HAS_AGGREGATE    (1 << 6)\n\n/* ZRANGE, ZRANGEBYSCORE, ZRANGESTORE options */\ntypedef struct redisZcmdOptions {\n    zend_bool withscores;\n    zend_bool byscore;\n    zend_bool bylex;\n    zend_bool rev;\n    zend_string *aggregate;\n    struct {\n        zend_bool enabled;\n        zend_long offset;\n        zend_long count;\n    } limit;\n} redisZcmdOptions;\n\n/* Local passthrough macro for command construction.  Given that these methods\n * are generic (so they work whether the caller is Redis or RedisCluster) we\n * will always have redis_sock, slot*, and */\n#define REDIS_CMD_SPPRINTF(ret, kw, fmt, ...) \\\n    redis_spprintf(redis_sock, slot, ret, kw, fmt, ##__VA_ARGS__)\n\n/* Generic commands based on method signature and what kind of things we're\n * processing.  Lots of Redis commands take something like key, value, or\n * key, value long.  Each unique signature like this is written only once */\n\n/* A command that takes no arguments */\nint redis_empty_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                    char *kw, char **cmd, int *cmd_len, short *slot,\n                    void **ctx)\n{\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"\");\n    return SUCCESS;\n}\n\n/* Helper to construct a raw command.  Given that the cluster and non cluster\n * versions are different (RedisCluster needs an additional argument to direct\n * the command) we take the start of our array and count */\nint redis_build_raw_cmd(zval *z_args, int argc, char **cmd, int *cmd_len)\n{\n    smart_string cmdstr = {0};\n    int i;\n\n    /* Make sure our first argument is a string */\n    if (Z_TYPE(z_args[0]) != IS_STRING) {\n        php_error_docref(NULL, E_WARNING,\n            \"When sending a 'raw' command, the first argument must be a string!\");\n        return FAILURE;\n    }\n\n    /* Initialize our command string */\n    redis_cmd_init_sstr(&cmdstr, argc-1, Z_STRVAL(z_args[0]), Z_STRLEN(z_args[0]));\n\n    for (i = 1; i < argc; i++) {\n       switch (Z_TYPE(z_args[i])) {\n            case IS_STRING:\n                redis_cmd_append_sstr(&cmdstr, Z_STRVAL(z_args[i]),\n                    Z_STRLEN(z_args[i]));\n                break;\n            case IS_LONG:\n                redis_cmd_append_sstr_long(&cmdstr,Z_LVAL(z_args[i]));\n                break;\n            case IS_DOUBLE:\n                redis_cmd_append_sstr_dbl(&cmdstr,Z_DVAL(z_args[i]));\n                break;\n            default:\n                php_error_docref(NULL, E_WARNING,\n                    \"Raw command arguments must be scalar values!\");\n                efree(cmdstr.c);\n                return FAILURE;\n        }\n    }\n\n    /* Push command and length to caller */\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nsmart_string *\nredis_build_script_cmd(smart_string *cmd, int argc, zval *z_args)\n{\n    int i;\n    zend_string *zstr;\n\n    if (Z_TYPE(z_args[0]) != IS_STRING) {\n        return NULL;\n    }\n    // Branch based on the directive\n    if (zend_string_equals_literal_ci(Z_STR(z_args[0]), \"kill\")) {\n        // Simple SCRIPT_KILL command\n        REDIS_CMD_INIT_SSTR_STATIC(cmd, argc, \"SCRIPT\");\n        redis_cmd_append_sstr(cmd, ZEND_STRL(\"KILL\"));\n    } else if (zend_string_equals_literal_ci(Z_STR(z_args[0]), \"flush\")) {\n        // Simple SCRIPT FLUSH [ASYNC | SYNC]\n        if (argc > 1 && (\n            Z_TYPE(z_args[1]) != IS_STRING || (\n                !zend_string_equals_literal_ci(Z_STR(z_args[1]), \"sync\") &&\n                !zend_string_equals_literal_ci(Z_STR(z_args[1]), \"async\")\n            )\n        )) {\n            return NULL;\n        }\n        REDIS_CMD_INIT_SSTR_STATIC(cmd, argc, \"SCRIPT\");\n        redis_cmd_append_sstr(cmd, ZEND_STRL(\"FLUSH\"));\n        if (argc > 1) {\n            redis_cmd_append_sstr(cmd, Z_STRVAL(z_args[1]), Z_STRLEN(z_args[1]));\n        }\n    } else if (zend_string_equals_literal_ci(Z_STR(z_args[0]), \"load\")) {\n        // Make sure we have a second argument, and it's not empty.  If it is\n        // empty, we can just return an empty array (which is what Redis does)\n        if (argc < 2 || Z_TYPE(z_args[1]) != IS_STRING || Z_STRLEN(z_args[1]) < 1) {\n            return NULL;\n        }\n        // Format our SCRIPT LOAD command\n        REDIS_CMD_INIT_SSTR_STATIC(cmd, argc, \"SCRIPT\");\n        redis_cmd_append_sstr(cmd, ZEND_STRL(\"LOAD\"));\n        redis_cmd_append_sstr(cmd, Z_STRVAL(z_args[1]), Z_STRLEN(z_args[1]));\n    } else if (zend_string_equals_literal_ci(Z_STR(z_args[0]), \"exists\")) {\n        // Make sure we have a second argument\n        if (argc < 2) {\n            return NULL;\n        }\n        /* Construct our SCRIPT EXISTS command */\n        REDIS_CMD_INIT_SSTR_STATIC(cmd, argc, \"SCRIPT\");\n        redis_cmd_append_sstr(cmd, ZEND_STRL(\"EXISTS\"));\n\n        for (i = 1; i < argc; ++i) {\n            zstr = zval_get_string(&z_args[i]);\n            redis_cmd_append_sstr(cmd, ZSTR_VAL(zstr), ZSTR_LEN(zstr));\n            zend_string_release(zstr);\n        }\n    } else {\n        /* Unknown directive */\n        return NULL;\n    }\n    return cmd;\n}\n\n/* Command that takes one optional string */\nint redis_opt_str_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, char *kw,\n                      char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *arg = NULL;\n    size_t arglen;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"|s!\", &arg, &arglen) == FAILURE) {\n        return FAILURE;\n    }\n\n    if (arg != NULL) {\n        *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"s\", arg, arglen);\n    } else {\n        *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"\");\n    }\n\n    return SUCCESS;\n}\n\n/* Generic command where we just take a string and do nothing to it*/\nint redis_str_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, char *kw,\n                  char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *arg;\n    size_t arg_len;\n\n    // Parse args\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &arg, &arg_len)\n                             ==FAILURE)\n    {\n        return FAILURE;\n    }\n\n    // Build the command without molesting the string\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"s\", arg, arg_len);\n\n    return SUCCESS;\n}\n\n/* Key, long, zval (serialized) */\nint redis_key_long_val_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                           char *kw, char **cmd, int *cmd_len, short *slot,\n                           void **ctx)\n{\n    char *key = NULL;\n    size_t key_len;\n    zend_long expire;\n    zval *z_val;\n\n    ZEND_PARSE_PARAMETERS_START(3, 3)\n        Z_PARAM_STRING(key, key_len)\n        Z_PARAM_LONG(expire)\n        Z_PARAM_ZVAL(z_val)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"klv\", key, key_len, expire, z_val);\n\n    return SUCCESS;\n}\n\n/* Generic key, long, string (unserialized) */\nint redis_key_long_str_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                           char *kw, char **cmd, int *cmd_len, short *slot,\n                           void **ctx)\n{\n    char *key, *val;\n    size_t key_len, val_len;\n    zend_long lval;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sls\", &key, &key_len,\n                             &lval, &val, &val_len) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"kds\", key, key_len, (int)lval, val, val_len);\n\n    return SUCCESS;\n}\n\n/* Generic command construction when we just take a key and value */\nint redis_kv_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                 char *kw, char **cmd, int *cmd_len, short *slot,\n                 void **ctx)\n{\n    char *key;\n    size_t key_len;\n    zval *z_val;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz\", &key, &key_len,\n                             &z_val) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"kv\", key, key_len, z_val);\n\n    return SUCCESS;\n}\n\n/* Generic command that takes a key and an unserialized value */\nint redis_key_str_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char *kw, char **cmd, int *cmd_len, short *slot,\n                      void **ctx)\n{\n    char *key, *val;\n    size_t key_len, val_len;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\", &key, &key_len,\n                             &val, &val_len) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    // Construct command\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"ks\", key, key_len, val, val_len);\n\n    return SUCCESS;\n}\n\n/* Key, string, string without serialization (ZCOUNT, ZREMRANGEBYSCORE) */\nint redis_key_str_str_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                          char *kw, char **cmd, int *cmd_len, short *slot,\n                          void **ctx)\n{\n    char *k, *v1, *v2;\n    size_t klen, v1len, v2len;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sss\", &k, &klen,\n                             &v1, &v1len, &v2, &v2len) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"kss\", k, klen, v1, v1len, v2, v2len);\n\n    // Success!\n    return SUCCESS;\n}\n\n/* Generic command that takes two keys */\nint redis_key_key_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char *kw, char **cmd, int *cmd_len, short *slot,\n                      void **ctx)\n{\n    zend_string *key1 = NULL, *key2 = NULL;\n    smart_string cmdstr = {0};\n    short slot2;\n\n    ZEND_PARSE_PARAMETERS_START(2, 2)\n        Z_PARAM_STR(key1)\n        Z_PARAM_STR(key2)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    redis_cmd_init_sstr(&cmdstr, 2, kw, strlen(kw));\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key1, redis_sock, slot);\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key2, redis_sock, slot ? &slot2 : NULL);\n\n    if (slot && *slot != slot2) {\n        php_error_docref(0, E_WARNING, \"Keys don't hash to the same slot\");\n        smart_string_free(&cmdstr);\n        return FAILURE;\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\n/* Generic command construction where we take a key and a long */\nint redis_key_long_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                       char *kw, char **cmd, int *cmd_len, short *slot,\n                       void **ctx)\n{\n    zend_string *key = NULL;\n    zend_long lval = 0;\n\n    ZEND_PARSE_PARAMETERS_START(2, 2)\n        Z_PARAM_STR(key)\n        Z_PARAM_LONG(lval)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"kl\", ZSTR_VAL(key), ZSTR_LEN(key), lval);\n\n    return SUCCESS;\n}\n\n/* long, long */\nint redis_long_long_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                        char *kw, char **cmd, int *cmd_len, short *slot,\n                        void **ctx)\n{\n    zend_long l1 = 0, l2 = 0;\n\n    ZEND_PARSE_PARAMETERS_START(2, 2)\n        Z_PARAM_LONG(l1)\n        Z_PARAM_LONG(l2)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"ll\", l1, l2);\n\n    return SUCCESS;\n}\n\n/* key, long, long */\nint redis_key_long_long_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                            char *kw, char **cmd, int *cmd_len, short *slot,\n                            void **ctx)\n{\n    char *key;\n    size_t key_len;\n    zend_long val1, val2;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sll\", &key, &key_len,\n                             &val1, &val2) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"kll\", key, key_len, val1, val2);\n\n    return SUCCESS;\n}\n\n/* Generic command where we take a single key */\nint redis_key_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                  char *kw, char **cmd, int *cmd_len, short *slot,\n                  void **ctx)\n{\n    char *key;\n    size_t key_len;\n\n    ZEND_PARSE_PARAMETERS_START(1, 1)\n        Z_PARAM_STRING(key, key_len);\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"k\", key, key_len);\n\n    return SUCCESS;\n}\n\nint\nredis_failover_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    int argc;\n    smart_string cmdstr = {0};\n    zend_bool abort = 0, force = 0;\n    zend_long timeout = 0, port = 0;\n    zend_string *zkey, *host = NULL;\n    zval *z_to = NULL, *z_ele;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"|a!bl\",\n                              &z_to, &abort, &timeout) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    if (z_to != NULL) {\n        ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARRVAL_P(z_to), zkey, z_ele) {\n            if (zkey != NULL) {\n                ZVAL_DEREF(z_ele);\n                if (zend_string_equals_literal_ci(zkey, \"host\")) {\n                    host = zval_get_string(z_ele);\n                } else if (zend_string_equals_literal_ci(zkey, \"port\")) {\n                    port = zval_get_long(z_ele);\n                } else if (zend_string_equals_literal_ci(zkey, \"force\")) {\n                    force = zval_is_true(z_ele);\n                }\n            }\n        } ZEND_HASH_FOREACH_END();\n        if (!host || !port) {\n            php_error_docref(NULL, E_WARNING, \"host and port must be provided!\");\n            if (host) zend_string_release(host);\n            return FAILURE;\n        }\n    }\n\n    argc = (host && port ? 3 + force : 0) + abort + (timeout > 0 ? 2 : 0);\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc, \"FAILOVER\");\n\n    if (host && port) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"TO\");\n        redis_cmd_append_sstr_zstr(&cmdstr, host);\n        redis_cmd_append_sstr_int(&cmdstr, port);\n        if (force) {\n            REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"FORCE\");\n        }\n        zend_string_release(host);\n    }\n\n    if (abort) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"ABORT\");\n    }\n    if (timeout > 0) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"TIMEOUT\");\n        redis_cmd_append_sstr_long(&cmdstr, timeout);\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nint redis_flush_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n               char *kw, char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    zend_bool sync = 0;\n    zend_bool is_null = 1;\n\n    ZEND_PARSE_PARAMETERS_START(0, 1)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_BOOL_OR_NULL(sync, is_null)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    redis_cmd_init_sstr(&cmdstr, !is_null, kw, strlen(kw));\n    if (!is_null) {\n        ZEND_ASSERT(sync == 0 || sync == 1);\n        if (sync == 0) {\n            REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"ASYNC\");\n        } else {\n            REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"SYNC\");\n        }\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* Generic command where we take a key and a double */\nint redis_key_dbl_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char *kw, char **cmd, int *cmd_len, short *slot,\n                      void **ctx)\n{\n    char *key;\n    size_t key_len;\n    double val;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sd\", &key, &key_len,\n                             &val) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"kf\", key, key_len, val);\n\n    return SUCCESS;\n}\n\n/* Generic to construct SCAN and variant commands */\nint redis_fmt_scan_cmd(char **cmd, REDIS_SCAN_TYPE type, char *key, int key_len,\n                       uint64_t it, char *pat, int pat_len, long count)\n{\n    static char *kw[] = {\"SCAN\",\"SSCAN\",\"HSCAN\",\"ZSCAN\"};\n    int argc;\n    smart_string cmdstr = {0};\n\n    // Figure out our argument count\n    argc = 1 + (type!=TYPE_SCAN) + (pat_len>0?2:0) + (count>0?2:0);\n\n    redis_cmd_init_sstr(&cmdstr, argc, kw[type], strlen(kw[type]));\n\n    // Append our key if it's not a regular SCAN command\n    if (type != TYPE_SCAN) {\n        redis_cmd_append_sstr(&cmdstr, key, key_len);\n    }\n\n    // Append cursor\n    redis_cmd_append_sstr_u64(&cmdstr, it);\n\n    // Append count if we've got one\n    if (count) {\n        redis_cmd_append_sstr(&cmdstr, ZEND_STRL(\"COUNT\"));\n        redis_cmd_append_sstr_long(&cmdstr, count);\n    }\n\n    // Append pattern if we've got one\n    if (pat_len) {\n        redis_cmd_append_sstr(&cmdstr, ZEND_STRL(\"MATCH\"));\n        redis_cmd_append_sstr(&cmdstr,pat,pat_len);\n    }\n\n    // Push command to the caller, return length\n    *cmd = cmdstr.c;\n    return cmdstr.len;\n}\n\nvoid redis_get_zcmd_options(redisZcmdOptions *dst, zval *src, int flags) {\n    zval *zv, *zoff, *zcnt;\n    zend_string *key;\n\n    ZEND_ASSERT(dst != NULL);\n\n    memset(dst, 0, sizeof(*dst));\n\n    if (src == NULL)\n        return;\n\n    if (Z_TYPE_P(src) != IS_ARRAY) {\n        if (Z_TYPE_P(src) == IS_TRUE && (flags & REDIS_ZCMD_HAS_WITHSCORES))\n            dst->withscores = 1;\n        return;\n    }\n\n    ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARRVAL_P(src), key, zv) {\n        ZVAL_DEREF(zv);\n\n        if (key) {\n            if ((flags & REDIS_ZCMD_HAS_WITHSCORES) && zend_string_equals_literal_ci(key, \"WITHSCORES\"))\n                dst->withscores = zval_is_true(zv);\n            else if ((flags & REDIS_ZCMD_HAS_LIMIT) && zend_string_equals_literal_ci(key, \"LIMIT\") &&\n                     Z_TYPE_P(zv) == IS_ARRAY)\n            {\n                if ((zoff = zend_hash_index_find(Z_ARRVAL_P(zv), 0)) != NULL &&\n                    (zcnt = zend_hash_index_find(Z_ARRVAL_P(zv), 1)) != NULL)\n                {\n                    dst->limit.enabled = 1;\n                    dst->limit.offset = zval_get_long(zoff);\n                    dst->limit.count = zval_get_long(zcnt);\n                } else {\n                    php_error_docref(NULL, E_WARNING, \"LIMIT offset and count must be an array with twe elements\");\n                }\n            } else if ((flags & REDIS_ZCMD_HAS_AGGREGATE && zend_string_equals_literal_ci(key, \"AGGREGATE\")) &&\n                       Z_TYPE_P(zv) == IS_STRING)\n            {\n                if (Z_TYPE_P(zv) != IS_STRING || (!zend_string_equals_literal_ci(Z_STR_P(zv), \"SUM\") &&\n                                                  !zend_string_equals_literal_ci(Z_STR_P(zv), \"MIN\") &&\n                                                  !zend_string_equals_literal_ci(Z_STR_P(zv), \"MAX\")))\n                {\n                    php_error_docref(NULL, E_WARNING, \"Valid AGGREGATE options are 'SUM', 'MIN', or 'MAX'\");\n                } else {\n                    dst->aggregate = Z_STR_P(zv);\n                }\n            }\n        } else if (Z_TYPE_P(zv) == IS_STRING) {\n            key = Z_STR_P(zv);\n\n            if ((flags & REDIS_ZCMD_HAS_BY_LEX_SCORE) && zend_string_equals_literal_ci(key, \"BYSCORE\"))\n                dst->byscore = 1, dst->bylex = 0;\n            else if ((flags & REDIS_ZCMD_HAS_BY_LEX_SCORE) && zend_string_equals_literal_ci(key, \"BYLEX\"))\n                dst->bylex = 1, dst->byscore = 0;\n            else if ((flags & REDIS_ZCMD_HAS_REV) && zend_string_equals_literal_ci(key, \"REV\"))\n                dst->rev = 1;\n            else if ((flags & REDIS_ZCMD_HAS_WITHSCORES && zend_string_equals_literal_ci(key, \"WITHSCORES\")))\n                dst->withscores = 1;\n        }\n    } ZEND_HASH_FOREACH_END();\n}\n\n// + ZRANGE               key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCORES]\n// + ZRANGESTORE      dst src   min  max [BYSCORE | BYLEX] [REV] [LIMIT offset count]\n// + ZREVRANGE            key start stop                                              [WITHSCORES]\n// + ZRANGEBYSCORE        key   min  max                         [LIMIT offset count] [WITHSCORES]\n// + ZREVRANGEBYSCORE     key   max  min                         [LIMIT offset count] [WITHSCORES]\n// - ZRANGEBYLEX          key   min  max                         [LIMIT offset count]\n// - ZREVRANGEBYLEX       key   max  min                         [LIMIT offset count]\n// - ZDIFF                                                                            [WITHSCORES]\n// - ZUNION                                                                           [WITHSCORES] [AGGREGATE X]\n// - ZINTER                                                                           [WITHSCORES] [AGGREGATE X]\nstatic int redis_get_zcmd_flags(const char *kw) {\n    size_t len = strlen(kw);\n\n    if (REDIS_STRICMP_STATIC(kw, len, \"ZRANGESTORE\")) {\n        return REDIS_ZCMD_HAS_DST_KEY |\n               REDIS_ZCMD_HAS_WITHSCORES |\n               REDIS_ZCMD_HAS_BY_LEX_SCORE |\n               REDIS_ZCMD_HAS_REV |\n               REDIS_ZCMD_HAS_LIMIT;\n    } else if (REDIS_STRICMP_STATIC(kw, len, \"ZRANGE\")) {\n        return REDIS_ZCMD_HAS_WITHSCORES |\n               REDIS_ZCMD_HAS_BY_LEX_SCORE |\n               REDIS_ZCMD_HAS_REV |\n               REDIS_ZCMD_HAS_LIMIT;\n    } else if (REDIS_STRICMP_STATIC(kw, len, \"ZREVRANGE\")) {\n        return REDIS_ZCMD_HAS_WITHSCORES |\n               REDIS_ZCMD_INT_RANGE;\n    } else if (REDIS_STRICMP_STATIC(kw, len, \"ZRANGEBYSCORE\") ||\n               REDIS_STRICMP_STATIC(kw, len, \"ZREVRANGEBYSCORE\"))\n    {\n        return REDIS_ZCMD_HAS_LIMIT |\n               REDIS_ZCMD_HAS_WITHSCORES;\n    } else if (REDIS_STRICMP_STATIC(kw, len, \"ZRANGEBYLEX\") ||\n               REDIS_STRICMP_STATIC(kw, len, \"ZREVRANGEBYLEX\"))\n    {\n        return REDIS_ZCMD_HAS_LIMIT;\n    } else if (REDIS_STRICMP_STATIC(kw, len, \"ZDIFF\")) {\n        return REDIS_ZCMD_HAS_WITHSCORES;\n    } else if (REDIS_STRICMP_STATIC(kw, len, \"ZINTER\") ||\n               REDIS_STRICMP_STATIC(kw, len, \"ZUNION\"))\n    {\n        return REDIS_ZCMD_HAS_WITHSCORES |\n               REDIS_ZCMD_HAS_AGGREGATE;\n    }\n\n    /* Reaching this line means a compile-time error */\n    ZEND_ASSERT(0);\n}\n\n/* Validate ZLEX* min/max argument strings */\nstatic int validate_zlex_arg(const char *str, size_t len) {\n    return (len  > 1 && (*str == '[' || *str == '(')) ||\n           (len == 1 && (*str == '+' || *str == '-'));\n}\n\nstatic int validate_zlex_arg_zval(zval *z) {\n    return Z_TYPE_P(z) == IS_STRING && validate_zlex_arg(Z_STRVAL_P(z), Z_STRLEN_P(z));\n}\n\nint redis_zrange_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char *kw, char **cmd, int *cmd_len, short *slot,\n                     void **ctx)\n{\n    zval *zoptions = NULL, *zstart = NULL, *zend = NULL;\n    zend_string *dst = NULL, *src = NULL;\n    zend_long start = 0, end = 0;\n    smart_string cmdstr = {0};\n    redisZcmdOptions opt;\n    int min_argc, flags;\n    short slot2;\n\n    flags = redis_get_zcmd_flags(kw);\n\n    min_argc = 3 + (flags & REDIS_ZCMD_HAS_DST_KEY);\n    ZEND_PARSE_PARAMETERS_START(min_argc, min_argc + 1)\n        if (flags & REDIS_ZCMD_HAS_DST_KEY) {\n            Z_PARAM_STR(dst)\n        }\n        Z_PARAM_STR(src)\n        if (flags & REDIS_ZCMD_INT_RANGE) {\n            Z_PARAM_LONG(start)\n            Z_PARAM_LONG(end)\n        } else {\n            Z_PARAM_ZVAL(zstart)\n            Z_PARAM_ZVAL(zend)\n        }\n        Z_PARAM_OPTIONAL\n        Z_PARAM_ZVAL_OR_NULL(zoptions)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    redis_get_zcmd_options(&opt, zoptions, flags);\n\n    if (opt.bylex) {\n        ZEND_ASSERT(!(flags & REDIS_ZCMD_INT_RANGE));\n        if (!validate_zlex_arg_zval(zstart) || !validate_zlex_arg_zval(zend)) {\n            php_error_docref(NULL, E_WARNING, \"Legographical args must start with '[' or '(' or be '+' or '-'\");\n            return FAILURE;\n        }\n    }\n\n    redis_cmd_init_sstr(&cmdstr, min_argc + !!opt.bylex + !!opt.byscore +\n                                 !!opt.rev + !!opt.withscores +\n                                 (opt.limit.enabled ? 3 : 0), kw, strlen(kw));\n\n    if (flags & REDIS_ZCMD_HAS_DST_KEY)\n        redis_cmd_append_sstr_key_zstr(&cmdstr, dst, redis_sock, slot);\n    redis_cmd_append_sstr_key_zstr(&cmdstr, src, redis_sock, &slot2);\n\n    /* Protect the user from crossslot errors */\n    if ((flags & REDIS_ZCMD_HAS_DST_KEY) && slot && *slot != slot2) {\n        php_error_docref(NULL, E_WARNING, \"destination and source keys must map to the same slot\");\n        efree(cmdstr.c);\n        return FAILURE;\n    }\n\n    if (flags & REDIS_ZCMD_INT_RANGE) {\n        redis_cmd_append_sstr_long(&cmdstr, start);\n        redis_cmd_append_sstr_long(&cmdstr, end);\n    } else {\n        redis_cmd_append_sstr_zval(&cmdstr, zstart, NULL);\n        redis_cmd_append_sstr_zval(&cmdstr, zend, NULL);\n    }\n\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, opt.byscore, \"BYSCORE\");\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, opt.bylex, \"BYLEX\");\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, opt.rev, \"REV\");\n\n    if (opt.limit.enabled) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"LIMIT\");\n        redis_cmd_append_sstr_long(&cmdstr, opt.limit.offset);\n        redis_cmd_append_sstr_long(&cmdstr, opt.limit.count);\n    }\n\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, opt.withscores, \"WITHSCORES\");\n\n    if (slot) *slot = slot2;\n    *ctx = opt.withscores ? PHPREDIS_CTX_PTR : NULL;\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nstatic int redis_build_config_get_cmd(smart_string *dst, zval *val) {\n    zend_string *zstr;\n    int ncfg;\n    zval *zv;\n\n    if (val == NULL || (Z_TYPE_P(val) != IS_STRING && Z_TYPE_P(val) != IS_ARRAY)) {\n        php_error_docref(NULL, E_WARNING, \"Must pass a string or array of values to CONFIG GET\");\n        return FAILURE;\n    } else if (Z_TYPE_P(val) == IS_ARRAY && zend_hash_num_elements(Z_ARRVAL_P(val)) == 0) {\n        php_error_docref(NULL, E_WARNING, \"Cannot pass an empty array to CONFIG GET\");\n        return FAILURE;\n    }\n\n    ncfg = Z_TYPE_P(val) == IS_STRING ? 1 : zend_hash_num_elements(Z_ARRVAL_P(val));\n\n    REDIS_CMD_INIT_SSTR_STATIC(dst, 1 + ncfg, \"CONFIG\");\n    REDIS_CMD_APPEND_SSTR_STATIC(dst, \"GET\");\n\n    if (Z_TYPE_P(val) == IS_STRING) {\n        redis_cmd_append_sstr_zstr(dst, Z_STR_P(val));\n    } else {\n        ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(val), zv) {\n            ZVAL_DEREF(zv);\n\n            zstr = zval_get_string(zv);\n            redis_cmd_append_sstr_zstr(dst, zstr);\n            zend_string_release(zstr);\n        } ZEND_HASH_FOREACH_END();\n    }\n\n    return SUCCESS;\n}\n\nstatic int redis_build_config_set_cmd(smart_string *dst, zval *key, zend_string *val) {\n    zend_string *zkey, *zstr;\n    zval *zv;\n\n    /* Legacy case:  CONFIG SET <string> <string> */\n    if (key != NULL && val != NULL) {\n        REDIS_CMD_INIT_SSTR_STATIC(dst, 3, \"CONFIG\");\n        REDIS_CMD_APPEND_SSTR_STATIC(dst, \"SET\");\n\n        zstr = zval_get_string(key);\n        redis_cmd_append_sstr_zstr(dst, zstr);\n        zend_string_release(zstr);\n\n        redis_cmd_append_sstr_zstr(dst, val);\n\n        return SUCCESS;\n    }\n\n    /* Now we must have an array with at least one element */\n    if (key == NULL || Z_TYPE_P(key) != IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_P(key)) == 0) {\n        php_error_docref(NULL, E_WARNING, \"Must either pass two strings to CONFIG SET or a non-empty array of values\");\n        return FAILURE;\n    }\n\n    REDIS_CMD_INIT_SSTR_STATIC(dst, 1 + (2 * zend_hash_num_elements(Z_ARRVAL_P(key))), \"CONFIG\");\n    REDIS_CMD_APPEND_SSTR_STATIC(dst, \"SET\");\n\n    ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARRVAL_P(key), zkey, zv) {\n        if (zkey == NULL)\n            goto fail;\n\n        ZVAL_DEREF(zv);\n\n        redis_cmd_append_sstr_zstr(dst, zkey);\n\n        zstr = zval_get_string(zv);\n        redis_cmd_append_sstr_zstr(dst, zstr);\n        zend_string_release(zstr);\n    } ZEND_HASH_FOREACH_END();\n\n    return SUCCESS;\n\nfail:\n    php_error_docref(NULL, E_WARNING, \"Must pass an associate array of config keys and values\");\n    efree(dst->c);\n    memset(dst, 0, sizeof(*dst));\n    return FAILURE;\n}\n\nint\nredis_config_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                 char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *op = NULL, *arg = NULL;\n    smart_string cmdstr = {0};\n    int res = FAILURE;\n    zval *key = NULL;\n\n    ZEND_PARSE_PARAMETERS_START(1, 3)\n        Z_PARAM_STR(op)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_ZVAL_OR_NULL(key)\n        Z_PARAM_STR_OR_NULL(arg)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (zend_string_equals_literal_ci(op, \"RESETSTAT\") ||\n        zend_string_equals_literal_ci(op, \"REWRITE\"))\n    {\n        REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1, \"CONFIG\");\n        redis_cmd_append_sstr_zstr(&cmdstr, op);\n        *ctx = redis_boolean_response;\n        res  = SUCCESS;\n    } else if (zend_string_equals_literal_ci(op, \"GET\")) {\n        res  = redis_build_config_get_cmd(&cmdstr, key);\n        *ctx = redis_mbulk_reply_zipped_raw;\n    } else if (zend_string_equals_literal_ci(op, \"SET\")) {\n        res  = redis_build_config_set_cmd(&cmdstr, key, arg);\n        *ctx = redis_boolean_response;\n    } else {\n        php_error_docref(NULL, E_WARNING, \"Unknown operation '%s'\", ZSTR_VAL(op));\n        return FAILURE;\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return res;\n}\n\nint\nredis_function_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    zend_string *op = NULL, *arg;\n    zval *argv = NULL;\n    int i, argc = 0;\n\n    ZEND_PARSE_PARAMETERS_START(1, -1)\n        Z_PARAM_STR(op)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_VARIADIC('*', argv, argc)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    for (i = 0; i < argc; ++i) {\n        if (Z_TYPE(argv[i]) != IS_STRING) {\n            php_error_docref(NULL, E_WARNING, \"invalid argument\");\n            return FAILURE;\n        }\n    }\n\n    if (zend_string_equals_literal_ci(op, \"DELETE\")) {\n        if (argc < 1) {\n            php_error_docref(NULL, E_WARNING, \"argument required\");\n            return FAILURE;\n        }\n    } else if (zend_string_equals_literal_ci(op, \"DUMP\")) {\n        *ctx = PHPREDIS_CTX_PTR;\n    } else if (zend_string_equals_literal_ci(op, \"FLUSH\")) {\n        if (argc > 0 &&\n            !zend_string_equals_literal_ci(Z_STR(argv[0]), \"SYNC\") &&\n            !zend_string_equals_literal_ci(Z_STR(argv[0]), \"ASYNC\")\n        ) {\n            php_error_docref(NULL, E_WARNING, \"invalid argument\");\n            return FAILURE;\n        }\n    } else if (zend_string_equals_literal_ci(op, \"KILL\")) {\n        // noop\n    } else if (zend_string_equals_literal_ci(op, \"LIST\")) {\n        if (argc > 0) {\n            if (zend_string_equals_literal_ci(Z_STR(argv[0]), \"LIBRARYNAME\")) {\n                if (argc < 2) {\n                    php_error_docref(NULL, E_WARNING, \"argument required\");\n                    return FAILURE;\n                }\n            } else if (!zend_string_equals_literal_ci(Z_STR(argv[0]), \"WITHCODE\")) {\n                php_error_docref(NULL, E_WARNING, \"invalid argument\");\n                return FAILURE;\n            }\n        }\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    } else if (zend_string_equals_literal_ci(op, \"LOAD\")) {\n        if (argc < 1 || (\n            zend_string_equals_literal_ci(Z_STR(argv[0]), \"REPLACE\") && argc < 2\n        )) {\n            php_error_docref(NULL, E_WARNING, \"argument required\");\n            return FAILURE;\n        }\n        *ctx = PHPREDIS_CTX_PTR;\n    } else if (zend_string_equals_literal_ci(op, \"RESTORE\")) {\n        if (argc < 1 || (\n            argc > 1 &&\n            !zend_string_equals_literal_ci(Z_STR(argv[1]), \"FLUSH\") &&\n            !zend_string_equals_literal_ci(Z_STR(argv[1]), \"APPEND\") &&\n            !zend_string_equals_literal_ci(Z_STR(argv[1]), \"REPLACE\")\n        )) {\n            php_error_docref(NULL, E_WARNING, \"invalid argument\");\n            return FAILURE;\n        }\n    } else if (zend_string_equals_literal_ci(op, \"STATS\")) {\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    } else {\n        php_error_docref(NULL, E_WARNING, \"Unknown operation '%s'\", ZSTR_VAL(op));\n        return FAILURE;\n    }\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1 + argc, \"FUNCTION\");\n    redis_cmd_append_sstr_zstr(&cmdstr, op);\n\n    for (i = 0; i < argc; i++) {\n        arg = zval_get_string(&argv[i]);\n        redis_cmd_append_sstr_zstr(&cmdstr, arg);\n        zend_string_release(arg);\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nint\nredis_fcall_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                char *kw, char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    HashTable *keys = NULL, *args = NULL;\n    smart_string cmdstr = {0};\n    zend_string *fn = NULL;\n    zval *zv;\n\n    ZEND_PARSE_PARAMETERS_START(1, 3)\n        Z_PARAM_STR(fn)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_ARRAY_HT(keys)\n        Z_PARAM_ARRAY_HT(args)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    redis_cmd_init_sstr(&cmdstr, 2 + (keys ? zend_hash_num_elements(keys) : 0) +\n        (args ? zend_hash_num_elements(args) : 0), kw, strlen(kw));\n    redis_cmd_append_sstr_zstr(&cmdstr, fn);\n    redis_cmd_append_sstr_long(&cmdstr, keys ? zend_hash_num_elements(keys) : 0);\n\n    if (keys != NULL) {\n        ZEND_HASH_FOREACH_VAL(keys, zv) {\n            redis_cmd_append_sstr_key_zval(&cmdstr, zv, redis_sock, slot);\n        } ZEND_HASH_FOREACH_END();\n    }\n\n    if (args != NULL) {\n        ZEND_HASH_FOREACH_VAL(args, zv) {\n            redis_cmd_append_sstr_zval(&cmdstr, zv, redis_sock);\n        } ZEND_HASH_FOREACH_END();\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nint\nredis_zrandmember_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key;\n    int count = 0;\n    size_t key_len;\n    smart_string cmdstr = {0};\n    zend_bool withscores = 0;\n    zval *z_opts = NULL, *z_ele;\n    zend_string *zkey;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\",\n                              &key, &key_len, &z_opts) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    if (z_opts != NULL) {\n        ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARRVAL_P(z_opts), zkey, z_ele) {\n            if (zkey != NULL) {\n                ZVAL_DEREF(z_ele);\n                if (zend_string_equals_literal_ci(zkey, \"count\")) {\n                    count = zval_get_long(z_ele);\n                } else if (zend_string_equals_literal_ci(zkey, \"withscores\")) {\n                    withscores = zval_is_true(z_ele);\n                }\n            }\n        } ZEND_HASH_FOREACH_END();\n    }\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1 + (count != 0) + withscores, \"ZRANDMEMBER\");\n    redis_cmd_append_sstr_key(&cmdstr, key, key_len, redis_sock, slot);\n\n    if (count != 0) {\n        redis_cmd_append_sstr_long(&cmdstr, count);\n        *ctx = PHPREDIS_CTX_PTR;\n    }\n\n    if (withscores) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"WITHSCORES\");\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    }\n\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\nint\nredis_zdiff_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zval *z_keys, *z_opts = NULL, *z_key;\n    redisZcmdOptions opts = {0};\n    smart_string cmdstr = {0};\n    int numkeys, flags;\n    short s2 = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"a|a\",\n                              &z_keys, &z_opts) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    if ((numkeys = zend_hash_num_elements(Z_ARRVAL_P(z_keys))) == 0) {\n        return FAILURE;\n    }\n\n    flags = redis_get_zcmd_flags(\"ZDIFF\");\n    redis_get_zcmd_options(&opts, z_opts, flags);\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1 + numkeys + opts.withscores, \"ZDIFF\");\n    redis_cmd_append_sstr_long(&cmdstr, numkeys);\n\n    ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(z_keys), z_key) {\n        ZVAL_DEREF(z_key);\n        redis_cmd_append_sstr_key_zval(&cmdstr, z_key, redis_sock, slot);\n\n        if (slot && s2 && s2 != *slot) {\n            php_error_docref(NULL, E_WARNING, \"Not all keys map to the same slot!\");\n            efree(cmdstr.c);\n            return FAILURE;\n        }\n\n        if (slot) s2 = *slot;\n    } ZEND_HASH_FOREACH_END();\n\n    if (opts.withscores) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"WITHSCORES\");\n        *ctx = PHPREDIS_CTX_PTR;\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\nstatic int redis_cmd_append_sstr_score(smart_string *dst, zval *score) {\n    zend_uchar type;\n    zend_long lval;\n    size_t cmdlen;\n    double dval;\n\n    /* Get current command length */\n    cmdlen = dst->len;\n\n    if (Z_TYPE_P(score) == IS_LONG) {\n        redis_cmd_append_sstr_long(dst, Z_LVAL_P(score));\n    } else if (Z_TYPE_P(score) == IS_DOUBLE) {\n        redis_cmd_append_sstr_dbl(dst, Z_DVAL_P(score));\n    } else if (Z_TYPE_P(score) == IS_STRING) {\n        type = is_numeric_string(Z_STRVAL_P(score), Z_STRLEN_P(score), &lval, &dval, 0);\n        if (type == IS_LONG) {\n            redis_cmd_append_sstr_long(dst, lval);\n        } else if (type == IS_DOUBLE) {\n            redis_cmd_append_sstr_dbl(dst, dval);\n        } else if (zend_string_equals_literal_ci(Z_STR_P(score), \"-inf\") ||\n                   zend_string_equals_literal_ci(Z_STR_P(score), \"+inf\") ||\n                   zend_string_equals_literal_ci(Z_STR_P(score), \"inf\"))\n        {\n            redis_cmd_append_sstr_zstr(dst, Z_STR_P(score));\n        }\n    }\n\n    /* Success if we appended something */\n    if (dst->len > cmdlen)\n        return SUCCESS;\n\n    /* Nothing appended, failure */\n    php_error_docref(NULL, E_WARNING, \"scores must be numeric or '-inf', 'inf', '+inf'\");\n    return FAILURE;\n}\n\nint redis_intercard_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                        char *kw, char **cmd, int *cmd_len, short *slot,\n                        void **ctx)\n{\n    smart_string cmdstr = {0};\n    zend_long limit = -1;\n    HashTable *keys;\n    zend_string *key;\n    zval *zv;\n\n    ZEND_PARSE_PARAMETERS_START(1, 2)\n        Z_PARAM_ARRAY_HT(keys)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_LONG(limit)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (zend_hash_num_elements(keys) == 0) {\n        php_error_docref(NULL, E_WARNING, \"Must pass at least one key\");\n        return FAILURE;\n    } else if (ZEND_NUM_ARGS() == 2 && limit < 0) {\n        php_error_docref(NULL, E_WARNING, \"LIMIT cannot be negative\");\n        return FAILURE;\n    }\n\n    redis_cmd_init_sstr(&cmdstr, 1 + zend_hash_num_elements(keys) + (limit > 0 ? 2 : 0), kw, strlen(kw));\n    redis_cmd_append_sstr_long(&cmdstr, zend_hash_num_elements(keys));\n\n    if (slot) *slot = -1;\n\n    ZEND_HASH_FOREACH_VAL(keys, zv) {\n        key = redis_key_prefix_zval(redis_sock, zv);\n\n        if (slot) {\n            if (*slot == -1) {\n                *slot = cluster_hash_key_zstr(key);\n            } else if (*slot != cluster_hash_key_zstr(key)) {\n                php_error_docref(NULL, E_WARNING, \"All keys don't hash to the same slot\");\n                efree(cmdstr.c);\n                zend_string_release(key);\n                return FAILURE;\n            }\n        }\n\n        redis_cmd_append_sstr_zstr(&cmdstr, key);\n        zend_string_release(key);\n    } ZEND_HASH_FOREACH_END();\n\n    if (limit > 0) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"LIMIT\");\n        redis_cmd_append_sstr_long(&cmdstr, limit);\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\nint redis_replicaof_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                        char *kw, char **cmd, int *cmd_len, short *slot,\n                        void **ctx)\n{\n    zend_string *host = NULL;\n    zend_long port = 6379;\n\n    ZEND_PARSE_PARAMETERS_START(0, 2)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_STR(host)\n        Z_PARAM_LONG(port)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (port < 0 || port > UINT16_MAX) {\n        php_error_docref(NULL, E_WARNING, \"Invalid port %ld\", (long)port);\n        return FAILURE;\n    }\n\n    if (ZEND_NUM_ARGS() == 2) {\n        *cmd_len = REDIS_SPPRINTF(cmd, kw, \"Sd\", host, (int)port);\n    } else {\n        *cmd_len = REDIS_SPPRINTF(cmd, kw, \"ss\", ZEND_STRL(\"NO\"), ZEND_STRL(\"ONE\"));\n    }\n\n    return SUCCESS;\n}\n\nint\nredis_zinterunion_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char *kw, char **cmd, int *cmd_len, short *slot,\n                      void **ctx)\n{\n    zval *z_keys, *z_weights = NULL, *z_opts = NULL, *z_ele;\n    redisZcmdOptions opts = {0};\n    smart_string cmdstr = {0};\n    int numkeys, flags;\n    short s2 = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"a|a!a\",\n                             &z_keys, &z_weights, &z_opts) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    if ((numkeys = zend_hash_num_elements(Z_ARRVAL_P(z_keys))) == 0) {\n        return FAILURE;\n    }\n\n    if (z_weights && zend_hash_num_elements(Z_ARRVAL_P(z_weights)) != numkeys) {\n        php_error_docref(NULL, E_WARNING, \"WEIGHTS and keys array should be the same size!\");\n        return FAILURE;\n    }\n\n    flags = redis_get_zcmd_flags(kw);\n    redis_get_zcmd_options(&opts, z_opts, flags);\n\n    redis_cmd_init_sstr(&cmdstr, 1 + numkeys + (z_weights ? 1 + numkeys : 0) + (opts.aggregate ? 2 : 0) + opts.withscores, kw, strlen(kw));\n    redis_cmd_append_sstr_long(&cmdstr, numkeys);\n\n    ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(z_keys), z_ele) {\n        ZVAL_DEREF(z_ele);\n        redis_cmd_append_sstr_key_zval(&cmdstr, z_ele, redis_sock, slot);\n        if (slot) {\n            if (s2 && s2 != *slot) {\n                php_error_docref(NULL, E_WARNING, \"Not all keys hash to the same slot\");\n                efree(cmdstr.c);\n                return FAILURE;\n            }\n            s2 = *slot;\n        }\n    } ZEND_HASH_FOREACH_END();\n\n    if (z_weights) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"WEIGHTS\");\n        ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(z_weights), z_ele) {\n            ZVAL_DEREF(z_ele);\n            if (redis_cmd_append_sstr_score(&cmdstr, z_ele) == FAILURE) {\n                efree(cmdstr.c);\n                return FAILURE;\n            }\n        } ZEND_HASH_FOREACH_END();\n    }\n\n    if (opts.aggregate) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"AGGREGATE\");\n        redis_cmd_append_sstr_zstr(&cmdstr, opts.aggregate);\n    }\n\n    if (opts.withscores) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"WITHSCORES\");\n        *ctx = PHPREDIS_CTX_PTR;\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\nint\nredis_zdiffstore_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    zend_string *dst = NULL;\n    HashTable *keys = NULL;\n    zend_ulong nkeys;\n    short s2 = 0;\n    zval *zkey;\n\n    ZEND_PARSE_PARAMETERS_START(2, 2)\n        Z_PARAM_STR(dst)\n        Z_PARAM_ARRAY_HT(keys)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    nkeys = zend_hash_num_elements(keys);\n    if (nkeys == 0)\n        return FAILURE;\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 2 + nkeys, \"ZDIFFSTORE\");\n    redis_cmd_append_sstr_key_zstr(&cmdstr, dst, redis_sock, slot);\n    redis_cmd_append_sstr_long(&cmdstr, nkeys);\n\n    ZEND_HASH_FOREACH_VAL(keys, zkey) {\n        ZVAL_DEREF(zkey);\n        redis_cmd_append_sstr_key_zval(&cmdstr, zkey, redis_sock, slot ? &s2 : NULL);\n        if (slot && *slot != s2) {\n            php_error_docref(NULL, E_WARNING, \"All keys must hash to the same slot\");\n            efree(cmdstr.c);\n            return FAILURE;\n        }\n    } ZEND_HASH_FOREACH_END();\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\n/* ZUNIONSTORE, ZINTERSTORE */\nint\nredis_zinterunionstore_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char *kw, char **cmd, int *cmd_len, short *slot,\n                     void **ctx)\n{\n    HashTable *keys = NULL, *weights = NULL;\n    smart_string cmdstr = {0};\n    zend_string *dst = NULL;\n    zend_string *agg = NULL;\n    zend_ulong nkeys;\n    zval *zv = NULL;\n    short s2 = 0;\n\n    ZEND_PARSE_PARAMETERS_START(2, 4)\n        Z_PARAM_STR(dst)\n        Z_PARAM_ARRAY_HT(keys)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_ARRAY_HT_OR_NULL(weights)\n        Z_PARAM_STR_OR_NULL(agg)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    nkeys = zend_hash_num_elements(keys);\n    if (nkeys == 0)\n        return FAILURE;\n\n    if (weights != NULL && zend_hash_num_elements(weights) != nkeys) {\n        php_error_docref(NULL, E_WARNING, \"WEIGHTS and keys array must be the same size!\");\n        return FAILURE;\n    }\n\n    // AGGREGATE option\n    if (agg != NULL && (!zend_string_equals_literal_ci(agg, \"SUM\") &&\n                        !zend_string_equals_literal_ci(agg, \"MIN\") &&\n                        !zend_string_equals_literal_ci(agg, \"MAX\")))\n    {\n        php_error_docref(NULL, E_WARNING, \"AGGREGATE option must be 'SUM', 'MIN', or 'MAX'\");\n        return FAILURE;\n    }\n\n    redis_cmd_init_sstr(&cmdstr, 2 + nkeys + (weights ? 1 + nkeys : 0) + (agg ? 2 : 0), kw, strlen(kw));\n    redis_cmd_append_sstr_key_zstr(&cmdstr, dst, redis_sock, slot);\n    redis_cmd_append_sstr_int(&cmdstr, nkeys);\n\n    ZEND_HASH_FOREACH_VAL(keys, zv) {\n        ZVAL_DEREF(zv);\n        redis_cmd_append_sstr_key_zval(&cmdstr, zv, redis_sock, slot ? &s2 : NULL);\n        if (slot && s2 != *slot) {\n            php_error_docref(NULL, E_WARNING, \"All keys don't hash to the same slot!\");\n            efree(cmdstr.c);\n            return FAILURE;\n        }\n    } ZEND_HASH_FOREACH_END();\n\n    if (weights) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"WEIGHTS\");\n        ZEND_HASH_FOREACH_VAL(weights, zv) {\n            ZVAL_DEREF(zv);\n            if (redis_cmd_append_sstr_score(&cmdstr, zv) == FAILURE) {\n                efree(cmdstr.c);\n                return FAILURE;\n            }\n        } ZEND_HASH_FOREACH_END();\n    }\n\n    if (agg) {\n        redis_cmd_append_sstr(&cmdstr, ZEND_STRL(\"AGGREGATE\"));\n        redis_cmd_append_sstr_zstr(&cmdstr, agg);\n    }\n\n    // Push out values\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nint redis_pubsub_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    HashTable *channels = NULL;\n    smart_string cmdstr = {0};\n    zend_string *op, *pattern = NULL;\n    zval *arg = NULL, *z_chan;\n\n    ZEND_PARSE_PARAMETERS_START(1, 2)\n        Z_PARAM_STR(op)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_ZVAL(arg)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (zend_string_equals_literal_ci(op, \"NUMPAT\")) {\n        *ctx = NULL;\n    } else if (zend_string_equals_literal_ci(op, \"CHANNELS\") ||\n        zend_string_equals_literal_ci(op, \"SHARDCHANNELS\")\n    ) {\n        if (arg != NULL) {\n            if (Z_TYPE_P(arg) != IS_STRING) {\n                php_error_docref(NULL, E_WARNING, \"Invalid pattern value\");\n                return FAILURE;\n            }\n            pattern = zval_get_string(arg);\n        }\n        *ctx = PHPREDIS_CTX_PTR;\n    } else if (zend_string_equals_literal_ci(op, \"NUMSUB\") ||\n        zend_string_equals_literal_ci(op, \"SHARDNUMSUB\")\n    ) {\n        if (arg != NULL) {\n            if (Z_TYPE_P(arg) != IS_ARRAY) {\n                php_error_docref(NULL, E_WARNING, \"Invalid channels value\");\n                return FAILURE;\n            }\n            channels = Z_ARRVAL_P(arg);\n        }\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    } else {\n        php_error_docref(NULL, E_WARNING, \"Unknown PUBSUB operation '%s'\", ZSTR_VAL(op));\n        return FAILURE;\n    }\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1 + !!pattern + (channels ? zend_hash_num_elements(channels) : 0), \"PUBSUB\");\n    redis_cmd_append_sstr_zstr(&cmdstr, op);\n\n    if (pattern != NULL) {\n        redis_cmd_append_sstr_zstr(&cmdstr, pattern);\n        zend_string_release(pattern);\n    } else if (channels != NULL) {\n        ZEND_HASH_FOREACH_VAL(channels, z_chan) {\n            redis_cmd_append_sstr_key_zval(&cmdstr, z_chan, redis_sock, slot);\n        } ZEND_HASH_FOREACH_END();\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* SUBSCRIBE/PSUBSCRIBE/SSUBSCRIBE */\nint redis_subscribe_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                        char *kw, char **cmd, int *cmd_len, short *slot,\n                        void **ctx)\n{\n    zval *z_arr, *z_chan;\n    HashTable *ht_chan;\n    smart_string cmdstr = {0};\n    subscribeContext *sctx = ecalloc(1, sizeof(*sctx));\n    unsigned short shardslot = REDIS_CLUSTER_SLOTS;\n    short s2;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"af\", &z_arr,\n                             &sctx->cb.fci, &sctx->cb.fci_cache) == FAILURE)\n    {\n        efree(sctx);\n        return FAILURE;\n    }\n\n    ht_chan    = Z_ARRVAL_P(z_arr);\n    sctx->kw   = kw;\n    sctx->argc = zend_hash_num_elements(ht_chan);\n\n    if (sctx->argc == 0) {\n        efree(sctx);\n        return FAILURE;\n    }\n\n    if (strcasecmp(kw, \"ssubscribe\") == 0) {\n        zend_hash_internal_pointer_reset(ht_chan);\n        if ((z_chan = zend_hash_get_current_data(ht_chan)) == NULL) {\n            php_error_docref(NULL, E_WARNING, \"Internal Zend HashTable error\");\n            efree(sctx);\n            return FAILURE;\n        }\n        shardslot = cluster_hash_key_zval(z_chan);\n    }\n\n    // Start command construction\n    redis_cmd_init_sstr(&cmdstr, sctx->argc, kw, strlen(kw));\n\n    // Iterate over channels\n    ZEND_HASH_FOREACH_VAL(ht_chan, z_chan) {\n        redis_cmd_append_sstr_key_zval(&cmdstr, z_chan, redis_sock, slot ? &s2 : NULL);\n\n        if (slot && (shardslot != REDIS_CLUSTER_SLOTS && s2 != shardslot)) {\n            php_error_docref(NULL, E_WARNING, \"All shard channels needs to belong to a single slot\");\n            smart_string_free(&cmdstr);\n            efree(sctx);\n            return FAILURE;\n        }\n    } ZEND_HASH_FOREACH_END();\n\n    // Push values out\n    *cmd_len = cmdstr.len;\n    *cmd     = cmdstr.c;\n    *ctx     = (void*)sctx;\n\n    if (shardslot != REDIS_CLUSTER_SLOTS) {\n        if (slot) *slot = shardslot;\n    } else {\n        // Pick a slot at random\n        CMD_RAND_SLOT(slot);\n    }\n\n    return SUCCESS;\n}\n\n/* UNSUBSCRIBE/PUNSUBSCRIBE/SUNSUBSCRIBE */\nint redis_unsubscribe_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                          char *kw, char **cmd, int *cmd_len, short *slot,\n                          void **ctx)\n{\n    smart_string cmdstr = {0};\n    subscribeContext *sctx;\n    HashTable *channels;\n    zval *channel;\n\n    ZEND_PARSE_PARAMETERS_START(1, 1)\n        Z_PARAM_ARRAY_HT(channels)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (zend_hash_num_elements(channels) == 0)\n        return FAILURE;\n\n    sctx = ecalloc(1, sizeof(*sctx));\n    sctx->kw = kw;\n    sctx->argc = zend_hash_num_elements(channels);\n\n    redis_cmd_init_sstr(&cmdstr, sctx->argc, kw, strlen(kw));\n\n    ZEND_HASH_FOREACH_VAL(channels, channel) {\n        redis_cmd_append_sstr_key_zval(&cmdstr, channel, redis_sock, slot);\n    } ZEND_HASH_FOREACH_END();\n\n    *cmd_len = cmdstr.len;\n    *cmd = cmdstr.c;\n    *ctx = sctx;\n\n    return SUCCESS;\n}\n\n/* ZRANGEBYLEX/ZREVRANGEBYLEX */\nint redis_zrangebylex_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                          char *kw, char **cmd, int *cmd_len, short *slot,\n                          void **ctx)\n{\n    char *key, *min, *max;\n    size_t key_len, min_len, max_len;\n    int argc = ZEND_NUM_ARGS();\n    zend_long offset, count;\n\n    /* We need either 3 or 5 arguments for this to be valid */\n    if (argc != 3 && argc != 5) {\n        php_error_docref(0, E_WARNING, \"Must pass either 3 or 5 arguments\");\n        return FAILURE;\n    }\n\n    if (zend_parse_parameters(argc, \"sss|ll\", &key, &key_len, &min, &min_len,\n                             &max, &max_len, &offset, &count) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    /* min and max must start with '(' or '[', or be either '-' or '+' */\n    if (!validate_zlex_arg(min, min_len) || !validate_zlex_arg(max, max_len)) {\n        php_error_docref(NULL, E_WARNING,\n            \"Min/Max args can be '-' or '+', or start with '[' or '('\");\n        return FAILURE;\n    }\n\n    /* Construct command */\n    if (argc == 3) {\n        *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"kss\", key, key_len, min, min_len,\n            max, max_len);\n    } else {\n        *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"ksssll\", key, key_len, min, min_len,\n            max, max_len, \"LIMIT\", 5, offset, count);\n    }\n\n    return SUCCESS;\n}\n\n/* ZLEXCOUNT/ZREMRANGEBYLEX */\nint redis_gen_zlex_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                       char *kw, char **cmd, int *cmd_len, short *slot,\n                       void **ctx)\n{\n    char *key, *min, *max;\n    size_t key_len, min_len, max_len;\n\n    /* Parse args */\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sss\", &key, &key_len,\n                             &min, &min_len, &max, &max_len) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    /* Quick sanity check on min/max */\n    if (!validate_zlex_arg(min, min_len) || !validate_zlex_arg(max, max_len)) {\n        php_error_docref(NULL, E_WARNING,\n            \"Min/Max args can be '-' or '+', or start with '[' or '('\");\n        return FAILURE;\n    }\n\n    /* Construct command */\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"kss\", key, key_len, min, min_len,\n        max, max_len);\n\n    return SUCCESS;\n}\n\n/* EVAL and EVALSHA */\nint redis_eval_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, char *kw,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *lua;\n    int argc = 0;\n    zval *z_arr = NULL, *z_ele;\n    HashTable *ht_arr;\n    zend_long num_keys = 0;\n    smart_string cmdstr = {0};\n    size_t lua_len;\n    zend_string *zstr;\n    short prevslot = -1;\n\n    /* Parse args */\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|al\", &lua, &lua_len,\n                             &z_arr, &num_keys) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    /* Grab arg count */\n    if (z_arr != NULL) {\n        ht_arr = Z_ARRVAL_P(z_arr);\n        argc = zend_hash_num_elements(ht_arr);\n    }\n\n    /* EVAL[SHA] {script || sha1} {num keys}  */\n    redis_cmd_init_sstr(&cmdstr, 2 + argc, kw, strlen(kw));\n    redis_cmd_append_sstr(&cmdstr, lua, lua_len);\n    redis_cmd_append_sstr_long(&cmdstr, num_keys);\n\n    // Iterate over our args if we have any\n    if (argc > 0) {\n        ZEND_HASH_FOREACH_VAL(ht_arr, z_ele) {\n            zstr = zval_get_string(z_ele);\n\n            /* If we're still on a key, prefix it check slot */\n            if (num_keys-- > 0) {\n                redis_cmd_append_sstr_key(&cmdstr, ZSTR_VAL(zstr), ZSTR_LEN(zstr), redis_sock, slot);\n\n                /* If we have been passed a slot, all keys must match */\n                if (slot) {\n                    if (prevslot != -1 && prevslot != *slot) {\n                        zend_string_release(zstr);\n                        php_error_docref(0, E_WARNING, \"All keys do not map to the same slot\");\n                        return FAILURE;\n                    }\n                    prevslot = *slot;\n                }\n            } else {\n                redis_cmd_append_sstr(&cmdstr, ZSTR_VAL(zstr), ZSTR_LEN(zstr));\n            }\n\n            zend_string_release(zstr);\n        } ZEND_HASH_FOREACH_END();\n    } else {\n        /* Any slot will do */\n        CMD_RAND_SLOT(slot);\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\n/* Commands that take a key followed by a variable list of serializable\n * values (RPUSH, LPUSH, SADD, SREM, etc...) */\nint redis_key_varval_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                         char *kw, char **cmd, int *cmd_len, short *slot,\n                         void **ctx)\n{\n    zval *args = NULL;\n    zend_string *key = NULL;\n    smart_string cmdstr = {0};\n    size_t i;\n    int argc = 0;\n\n    ZEND_PARSE_PARAMETERS_START(2, -1)\n        Z_PARAM_STR(key)\n        Z_PARAM_VARIADIC('*', args, argc)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    /* Initialize our command */\n    redis_cmd_init_sstr(&cmdstr, argc + 1, kw, strlen(kw));\n\n    /* Append key */\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n\n    /* Add members */\n    for (i = 0; i < argc; i++) {\n        redis_cmd_append_sstr_zval(&cmdstr, &args[i], redis_sock);\n    }\n\n    // Push out values\n    *cmd     = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    // Success!\n    return SUCCESS;\n}\n\n/* Commands that take a key and then an array of values */\nstatic int gen_key_arr_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                           char *kw, zend_bool pack_values, char **cmd, int *cmd_len,\n                           short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    HashTable *values = NULL;\n    zend_string *key = NULL;\n    zval *zv;\n\n    ZEND_PARSE_PARAMETERS_START(2, 2)\n        Z_PARAM_STR(key)\n        Z_PARAM_ARRAY_HT(values)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (zend_hash_num_elements(values) == 0)\n        return FAILURE;\n\n    redis_cmd_init_sstr(&cmdstr, 1 + zend_hash_num_elements(values), kw, strlen(kw));\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n\n    ZEND_HASH_FOREACH_VAL(values, zv) {\n        redis_cmd_append_sstr_zval(&cmdstr, zv, pack_values ? redis_sock : NULL);\n    } ZEND_HASH_FOREACH_END();\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nint redis_key_val_arr_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                        char *kw, char **cmd, int *cmd_len, short *slot,\n                        void **ctx)\n{\n    return gen_key_arr_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, kw,\n        1, cmd, cmd_len, slot, ctx);\n}\n\nint redis_key_str_arr_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                        char *kw, char **cmd, int *cmd_len, short *slot,\n                        void **ctx)\n{\n    return gen_key_arr_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, kw,\n        0, cmd, cmd_len, slot, ctx);\n}\n\n/* Generic function that takes one or more non-serialized arguments */\nstatic int\ngen_vararg_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n               uint32_t min_argc, char *kw, char **cmd, int *cmd_len,\n               short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    zval *argv = NULL;\n    int argc = 0;\n    uint32_t i;\n\n    ZEND_PARSE_PARAMETERS_START(min_argc, -1)\n        Z_PARAM_VARIADIC('*', argv, argc)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    redis_cmd_init_sstr(&cmdstr, argc, kw, strlen(kw));\n\n    for (i = 0; i < argc; i++) {\n        redis_cmd_append_sstr_zval(&cmdstr, &argv[i], NULL);\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nint redis_mset_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char *kw, char **cmd, int *cmd_len, short *slot,\n                   void **ctx)\n{\n    smart_string cmdstr = {0};\n    HashTable *kvals = NULL;\n    zend_string *key;\n    zend_ulong idx;\n    zval *zv;\n\n    ZEND_PARSE_PARAMETERS_START(1, 1)\n        Z_PARAM_ARRAY_HT(kvals)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (zend_hash_num_elements(kvals) == 0)\n        return FAILURE;\n\n    redis_cmd_init_sstr(&cmdstr, zend_hash_num_elements(kvals) * 2, kw, strlen(kw));\n\n    ZEND_HASH_FOREACH_KEY_VAL(kvals, idx, key, zv) {\n        ZVAL_DEREF(zv);\n        if (key) {\n            redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, NULL);\n        } else {\n            redis_cmd_append_sstr_key_long(&cmdstr, idx, redis_sock, NULL);\n        }\n        redis_cmd_append_sstr_zval(&cmdstr, zv, redis_sock);\n    } ZEND_HASH_FOREACH_END();\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* Generic function that takes a variable number of keys, with an optional\n * timeout value.  This can handle various SUNION/SUNIONSTORE/BRPOP type\n * commands. */\nstatic int gen_varkey_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                          char *kw, int kw_len, zend_bool has_timeout,\n                          char **cmd, int *cmd_len, short *slot)\n{\n    zval *argv = NULL, ztimeout = {0}, *zv;\n    smart_string cmdstr = {0};\n    uint32_t min_argc;\n    short kslot = -1;\n    int single_array;\n    int argc = 0;\n\n    min_argc = has_timeout ? 2 : 1;\n\n    ZEND_PARSE_PARAMETERS_START(min_argc, -1)\n        Z_PARAM_VARIADIC('*', argv, argc)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    single_array = argc == min_argc && Z_TYPE(argv[0]) == IS_ARRAY;\n\n    if (has_timeout) {\n        if (single_array)\n            ZVAL_COPY_VALUE(&ztimeout, &argv[1]);\n        else\n            ZVAL_COPY_VALUE(&ztimeout, &argv[argc - 1]);\n\n        if (Z_TYPE(ztimeout) != IS_LONG && Z_TYPE(ztimeout) != IS_DOUBLE) {\n            php_error_docref(NULL, E_WARNING, \"Timeout must be a long or double\");\n            return FAILURE;\n        }\n    }\n\n    // If we're running a single array, rework args\n    if (single_array) {\n        /* Need at least one argument */\n        argc = zend_hash_num_elements(Z_ARRVAL(argv[0]));\n        if (argc == 0)\n            return FAILURE;\n\n        if (has_timeout) argc++;\n    }\n\n    // Begin construction of our command\n    redis_cmd_init_sstr(&cmdstr, argc, kw, kw_len);\n\n    if (single_array) {\n        ZEND_HASH_FOREACH_VAL(Z_ARRVAL(argv[0]), zv) {\n            redis_cmd_append_sstr_key_zval(&cmdstr, zv, redis_sock, slot);\n            if (slot) {\n                if (kslot != -1 && *slot != kslot)\n                    goto cross_slot;\n                kslot = *slot;\n            }\n        } ZEND_HASH_FOREACH_END();\n    } else {\n        uint32_t i;\n        for(i = 0; i < argc - !!has_timeout; i++) {\n            redis_cmd_append_sstr_key_zval(&cmdstr, &argv[i], redis_sock, slot);\n            if (slot) {\n                if (kslot != -1 && *slot != kslot)\n                    goto cross_slot;\n                kslot = *slot;\n            }\n        }\n    }\n\n    if (Z_TYPE(ztimeout) == IS_DOUBLE) {\n        redis_cmd_append_sstr_dbl(&cmdstr, Z_DVAL(ztimeout));\n    } else if (Z_TYPE(ztimeout) == IS_LONG) {\n        redis_cmd_append_sstr_long(&cmdstr, Z_LVAL(ztimeout));\n    }\n\n    // Push out parameters\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n\ncross_slot:\n    efree(cmdstr.c);\n    php_error_docref(NULL, E_WARNING, \"Not all keys hash to the same slot!\");\n    return FAILURE;\n}\n\nint redis_mpop_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, char *kw,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    int argc, blocking, is_zmpop;\n    smart_string cmdstr = {0};\n    zend_string *from = NULL;\n    HashTable *keys = NULL;\n    double timeout = 0.0;\n    zend_long count = 1;\n    short slot2 = -1;\n    zval *zv;\n\n    /* Sanity check on our keyword */\n    ZEND_ASSERT(kw != NULL && *kw != '\\0' && *(kw+1) != '\\0');\n\n    blocking = tolower(*kw) == 'b';\n    is_zmpop = tolower(kw[blocking]) == 'z';\n\n    ZEND_PARSE_PARAMETERS_START(2 + blocking, 3 + blocking) {\n        if (blocking) {\n            Z_PARAM_DOUBLE(timeout)\n        }\n        Z_PARAM_ARRAY_HT(keys)\n        Z_PARAM_STR(from);\n        Z_PARAM_OPTIONAL\n        Z_PARAM_LONG(count);\n    } ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (zend_hash_num_elements(keys) == 0) {\n        php_error_docref(NULL, E_WARNING, \"Must pass at least one key\");\n        return FAILURE;\n    } else if (count < 1) {\n        php_error_docref(NULL, E_WARNING, \"Count must be > 0\");\n        return FAILURE;\n    } else if (!is_zmpop && !(zend_string_equals_literal_ci(from, \"LEFT\") ||\n                              zend_string_equals_literal_ci(from, \"RIGHT\")))\n    {\n        php_error_docref(NULL, E_WARNING, \"from must be either 'LEFT' or 'RIGHT'\");\n        return FAILURE;\n    } else if (is_zmpop && !(zend_string_equals_literal_ci(from, \"MIN\") ||\n                             zend_string_equals_literal_ci(from, \"MAX\")))\n    {\n        php_error_docref(NULL, E_WARNING, \"from must be either 'MIN' or 'MAX'\");\n        return FAILURE;\n    }\n\n    argc = 2 + !!blocking + zend_hash_num_elements(keys) + (count != 1 ? 2 : 0);\n    redis_cmd_init_sstr(&cmdstr, argc, kw, strlen(kw));\n\n    if (blocking) redis_cmd_append_sstr_dbl(&cmdstr, timeout);\n    redis_cmd_append_sstr_long(&cmdstr, zend_hash_num_elements(keys));\n\n    if (slot) *slot = -1;\n\n    ZEND_HASH_FOREACH_VAL(keys, zv) {\n        redis_cmd_append_sstr_key_zval(&cmdstr, zv, redis_sock, slot);\n        if (slot) {\n            if (slot2 != -1 && *slot != slot2) {\n                php_error_docref(NULL, E_WARNING, \"All keys don't hash to the same slot\");\n                efree(cmdstr.c);\n                return FAILURE;\n            }\n            slot2 = *slot;\n        }\n    } ZEND_HASH_FOREACH_END();\n\n    redis_cmd_append_sstr_zstr(&cmdstr, from);\n\n    if (count != 1) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"COUNT\");\n        redis_cmd_append_sstr_long(&cmdstr, count);\n    }\n\n    *ctx = is_zmpop ? PHPREDIS_CTX_PTR : NULL;\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nint redis_info_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    return gen_vararg_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, 0,\n                          \"INFO\", cmd, cmd_len, slot, ctx);\n}\n\nint redis_script_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    int argc = 0;\n    smart_string cmdstr = {0};\n    zval *argv = NULL;\n\n    ZEND_PARSE_PARAMETERS_START(1, -1)\n        Z_PARAM_VARIADIC('*', argv, argc)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (redis_build_script_cmd(&cmdstr, argc, argv) == NULL) {\n        return FAILURE;\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* Generic handling of every blocking pop command (BLPOP, BZPOP[MIN/MAX], etc */\nint redis_blocking_pop_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                           char *kw, char **cmd, int *cmd_len, short *slot,\n                           void **ctx)\n{\n    return gen_varkey_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, kw,\n        strlen(kw), 1, cmd, cmd_len, slot);\n}\n\n/*\n * Commands with specific signatures or that need unique functions because they\n * have specific processing (argument validation, etc) that make them unique\n */\n\nint\nredis_pop_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n              char *kw, char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key;\n    size_t key_len;\n    smart_string cmdstr = {0};\n    zend_long count = 0;\n\n    // Make sure the function is being called correctly\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|l\",\n                              &key, &key_len, &count) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    redis_cmd_init_sstr(&cmdstr, 1 + (count > 0), kw, strlen(kw));\n    redis_cmd_append_sstr_key(&cmdstr, key, key_len, redis_sock, slot);\n    if (count > 0) {\n        redis_cmd_append_sstr_long(&cmdstr, (long)count);\n        *ctx = PHPREDIS_CTX_PTR;\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nint\nredis_acl_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n              char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    zend_string *op, *zstr;\n    zval *z_args = NULL;\n    int argc = 0, i;\n\n    ZEND_PARSE_PARAMETERS_START(1, -1)\n        Z_PARAM_STR(op)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_VARIADIC('*', z_args, argc)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (zend_string_equals_literal_ci(op, \"CAT\") ||\n        zend_string_equals_literal_ci(op, \"LIST\") ||\n        zend_string_equals_literal_ci(op, \"USERS\")\n    ) {\n        *ctx = NULL;\n    } else if (zend_string_equals_literal_ci(op, \"LOAD\") ||\n        zend_string_equals_literal_ci(op, \"SAVE\")\n    ) {\n        *ctx = PHPREDIS_CTX_PTR;\n    } else if (zend_string_equals_literal_ci(op, \"GENPASS\") ||\n        zend_string_equals_literal_ci(op, \"WHOAMI\")\n    ) {\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    } else if (zend_string_equals_literal_ci(op, \"SETUSER\")) {\n        if (argc < 1) {\n            php_error_docref(NULL, E_WARNING, \"ACL SETUSER requires at least one argument\");\n            return FAILURE;\n        }\n        *ctx = PHPREDIS_CTX_PTR;\n    } else if (zend_string_equals_literal_ci(op, \"DELUSER\")) {\n        if (argc < 1) {\n            php_error_docref(NULL, E_WARNING, \"ACL DELUSER requires at least one argument\");\n            return FAILURE;\n        }\n        *ctx = PHPREDIS_CTX_PTR + 2;\n    } else if (zend_string_equals_literal_ci(op, \"GETUSER\")) {\n        if (argc < 1) {\n            php_error_docref(NULL, E_WARNING, \"ACL GETUSER requires at least one argument\");\n            return FAILURE;\n        }\n        *ctx = PHPREDIS_CTX_PTR + 3;\n    } else if (zend_string_equals_literal_ci(op, \"DRYRUN\")) {\n        if (argc < 2) {\n            php_error_docref(NULL, E_WARNING, \"ACL DRYRUN requires at least two arguments\");\n            return FAILURE;\n        }\n        *ctx = PHPREDIS_CTX_PTR;\n    } else if (zend_string_equals_literal_ci(op, \"LOG\")) {\n        if (argc > 0 && Z_TYPE(z_args[0]) == IS_STRING && ZVAL_STRICMP_STATIC(&z_args[0], \"RESET\")) {\n            *ctx = PHPREDIS_CTX_PTR;\n        } else {\n            *ctx = PHPREDIS_CTX_PTR + 4;\n        }\n    } else {\n        php_error_docref(NULL, E_WARNING, \"Unknown ACL operation '%s'\", ZSTR_VAL(op));\n        return FAILURE;\n    }\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1 + argc, \"ACL\");\n    redis_cmd_append_sstr_zstr(&cmdstr, op);\n\n    for (i = 0; i < argc; ++i) {\n        zstr = zval_get_string(&z_args[i]);\n        redis_cmd_append_sstr_zstr(&cmdstr, zstr);\n        zend_string_release(zstr);\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nint redis_waitaof_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_long numlocal, numreplicas, timeout;\n    smart_string cmdstr = {0};\n\n    ZEND_PARSE_PARAMETERS_START(3, 3)\n        Z_PARAM_LONG(numlocal)\n        Z_PARAM_LONG(numreplicas)\n        Z_PARAM_LONG(timeout)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (numlocal < 0 || numreplicas < 0 || timeout < 0) {\n        php_error_docref(NULL, E_WARNING, \"No arguments can be negative\");\n        return FAILURE;\n    }\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 3, \"WAITAOF\");\n    redis_cmd_append_sstr_long(&cmdstr, numlocal);\n    redis_cmd_append_sstr_long(&cmdstr, numreplicas);\n    redis_cmd_append_sstr_long(&cmdstr, timeout);\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* Attempt to pull a long expiry from a zval.  We're more restrictave than zval_get_long\n * because that function will return integers from things like open file descriptors\n * which should simply fail as a TTL */\nstatic int redis_try_get_expiry(zval *zv, zend_long *lval) {\n    double dval;\n\n    /* Success on an actual long or double */\n    if (Z_TYPE_P(zv) == IS_LONG || Z_TYPE_P(zv) == IS_DOUBLE) {\n        *lval = zval_get_long(zv);\n        return SUCCESS;\n    }\n\n    /* Automatically fail if we're not a string */\n    if (Z_TYPE_P(zv) != IS_STRING)\n        return FAILURE;\n\n    /* Attempt to get a long from the string */\n    switch (is_numeric_string(Z_STRVAL_P(zv), Z_STRLEN_P(zv), lval, &dval, 0)) {\n        case IS_DOUBLE:\n            *lval = dval;\n            REDIS_FALLTHROUGH;\n        case IS_LONG:\n            return SUCCESS;\n        default:\n            return FAILURE;\n    }\n}\n\n/* SET */\nint redis_set_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                  char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key = NULL, *exp_type = NULL, *set_type = NULL;\n    zval *z_value, *z_opts=NULL;\n    smart_string cmdstr = {0};\n    zend_long expire = -1;\n    zend_bool get = 0;\n    long keep_ttl = 0;\n    size_t key_len;\n\n    #define setExpiryWarning(zv) \\\n        php_error_docref(NULL, E_WARNING, \"%s passed as EXPIRY is invalid \" \\\n                         \"(must be an int, float, or numeric string >= 1)\", \\\n                         zend_zval_type_name((zv)))\n\n    // Make sure the function is being called correctly\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz|z\", &key, &key_len,\n                             &z_value, &z_opts) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n\n    // Check for an options array\n    if (z_opts && Z_TYPE_P(z_opts) == IS_ARRAY) {\n        HashTable *kt = Z_ARRVAL_P(z_opts);\n        zend_string *zkey;\n        zval *v;\n\n        /* Iterate our option array */\n        ZEND_HASH_FOREACH_STR_KEY_VAL(kt, zkey, v) {\n            ZVAL_DEREF(v);\n            /* Detect PX or EX argument and validate timeout */\n            if (zkey && (zend_string_equals_literal_ci(zkey, \"EX\") ||\n                         zend_string_equals_literal_ci(zkey, \"PX\") ||\n                         zend_string_equals_literal_ci(zkey, \"EXAT\") ||\n                         zend_string_equals_literal_ci(zkey, \"PXAT\"))\n            ) {\n                if (redis_try_get_expiry(v, &expire) == FAILURE || expire < 1) {\n                    setExpiryWarning(v);\n                    return FAILURE;\n                }\n\n                exp_type = ZSTR_VAL(zkey);\n            } else if (Z_TYPE_P(v) == IS_STRING) {\n                if (zend_string_equals_literal_ci(Z_STR_P(v), \"KEEPTTL\")) {\n                    keep_ttl  = 1;\n                } else if (zend_string_equals_literal_ci(Z_STR_P(v), \"GET\")) {\n                    get = 1;\n                } else if (zend_string_equals_literal_ci(Z_STR_P(v), \"NX\") ||\n                           zend_string_equals_literal_ci(Z_STR_P(v), \"XX\"))\n                {\n                    set_type = Z_STRVAL_P(v);\n                }\n            }\n        } ZEND_HASH_FOREACH_END();\n    } else if (z_opts && Z_TYPE_P(z_opts) != IS_NULL) {\n        if (redis_try_get_expiry(z_opts, &expire) == FAILURE || expire < 1) {\n            setExpiryWarning(z_opts);\n            return FAILURE;\n        }\n    }\n\n    /* Protect the user from syntax errors but give them some info about what's wrong */\n    if (exp_type && keep_ttl) {\n        php_error_docref(NULL, E_WARNING, \"KEEPTTL can't be combined with EX or PX option\");\n        return FAILURE;\n    }\n\n    /* Backward compatibility:  If we are passed no options except an EXPIRE ttl, we\n     * actually execute a SETEX command */\n    if (expire > 0 && !exp_type && !set_type && !keep_ttl) {\n        *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"SETEX\", \"klv\", key, key_len, expire, z_value);\n        return SUCCESS;\n    }\n\n    /* Calculate argc based on options set */\n    int argc = 2 + (exp_type ? 2 : 0) + (set_type != NULL) + (keep_ttl != 0) + get;\n\n    /* Initial SET <key> <value> */\n    redis_cmd_init_sstr(&cmdstr, argc, \"SET\", 3);\n    redis_cmd_append_sstr_key(&cmdstr, key, key_len, redis_sock, slot);\n    redis_cmd_append_sstr_zval(&cmdstr, z_value, redis_sock);\n\n    if (exp_type) {\n        redis_cmd_append_sstr(&cmdstr, exp_type, strlen(exp_type));\n        redis_cmd_append_sstr_long(&cmdstr, (long)expire);\n    }\n\n    if (set_type)\n        redis_cmd_append_sstr(&cmdstr, set_type, strlen(set_type));\n    if (keep_ttl)\n        redis_cmd_append_sstr(&cmdstr, \"KEEPTTL\", 7);\n    if (get) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"GET\");\n        *ctx = PHPREDIS_CTX_PTR;\n    }\n\n    /* Push command and length to the caller */\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n\n    #undef setExpiryWarning\n}\n\n/* MGET */\nint redis_mget_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    HashTable *keys = NULL;\n    zval *zkey;\n\n    /* RedisCluster has a custom MGET implementation */\n    ZEND_ASSERT(slot == NULL);\n\n    ZEND_PARSE_PARAMETERS_START(1, 1)\n        Z_PARAM_ARRAY_HT(keys)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (zend_hash_num_elements(keys) == 0)\n        return FAILURE;\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, zend_hash_num_elements(keys), \"MGET\");\n\n    ZEND_HASH_FOREACH_VAL(keys, zkey) {\n        ZVAL_DEREF(zkey);\n        redis_cmd_append_sstr_key_zval(&cmdstr, zkey, redis_sock, slot);\n    } ZEND_HASH_FOREACH_END();\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nint\nredis_getex_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    char *key, *exp_type = NULL;\n    zval *z_opts = NULL, *z_ele;\n    zend_long expire = -1;\n    zend_bool persist = 0;\n    zend_string *zkey;\n    size_t key_len;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\",\n                              &key, &key_len, &z_opts) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    if (z_opts != NULL) {\n        ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARRVAL_P(z_opts), zkey, z_ele) {\n            if (zkey != NULL) {\n                ZVAL_DEREF(z_ele);\n                if (ZSTR_STRICMP_STATIC(zkey, \"EX\") ||\n                    ZSTR_STRICMP_STATIC(zkey, \"PX\") ||\n                    ZSTR_STRICMP_STATIC(zkey, \"EXAT\") ||\n                    ZSTR_STRICMP_STATIC(zkey, \"PXAT\")\n                ) {\n                    exp_type = ZSTR_VAL(zkey);\n                    expire = zval_get_long(z_ele);\n                    persist = 0;\n                } else if (ZSTR_STRICMP_STATIC(zkey, \"PERSIST\")) {\n                    persist = zval_is_true(z_ele);\n                    exp_type = NULL;\n                }\n            } else if (Z_TYPE_P(z_ele) == IS_STRING &&\n                       zend_string_equals_literal_ci(Z_STR_P(z_ele), \"PERSIST\"))\n            {\n                persist = zval_is_true(z_ele);\n                exp_type = NULL;\n            }\n        } ZEND_HASH_FOREACH_END();\n    }\n\n    if (exp_type != NULL && expire < 1) {\n        php_error_docref(NULL, E_WARNING, \"EXPIRE can't be < 1\");\n        return FAILURE;\n    }\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1 + (exp_type ? 2 : persist), \"GETEX\");\n    redis_cmd_append_sstr_key(&cmdstr, key, key_len, redis_sock, slot);\n\n    if (exp_type != NULL) {\n        redis_cmd_append_sstr(&cmdstr, exp_type, strlen(exp_type));\n        redis_cmd_append_sstr_long(&cmdstr, expire);\n    } else if (persist) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"PERSIST\");\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* BRPOPLPUSH */\nint redis_brpoplpush_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                         char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *src = NULL, *dst = NULL;\n    double timeout = 0;\n\n    ZEND_PARSE_PARAMETERS_START(3, 3)\n        Z_PARAM_STR(src)\n        Z_PARAM_STR(dst)\n        Z_PARAM_DOUBLE(timeout)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    src = redis_key_prefix_zstr(redis_sock, src);\n    dst = redis_key_prefix_zstr(redis_sock, dst);\n\n    if (slot && (*slot = cluster_hash_key_zstr(src)) != cluster_hash_key_zstr(dst)) {\n        php_error_docref(NULL, E_WARNING, \"Keys must hash to the same slot\");\n        zend_string_release(src);\n        zend_string_release(dst);\n        return FAILURE;\n    }\n\n    /* Consistency with Redis.  If timeout < 0 use RPOPLPUSH */\n    if (timeout < 0) {\n        *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"RPOPLPUSH\", \"SS\", src, dst);\n    } else if (fabs(timeout - (long)timeout) < .0001) {\n        *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"BRPOPLPUSH\", \"SSd\", src, dst, (long)timeout);\n    } else {\n        *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"BRPOPLPUSH\", \"SSf\", src, dst, timeout);\n    }\n\n    zend_string_release(src);\n    zend_string_release(dst);\n\n    return SUCCESS;\n}\n\n/* To maintain backward compatibility with earlier versions of phpredis, we\n * allow for an optional \"increment by\" argument for INCR and DECR even though\n * that's not how Redis proper works */\n#define TYPE_INCR 0\n#define TYPE_DECR 1\n\n/* Handle INCR(BY) and DECR(BY) depending on optional increment value */\nstatic int\nredis_atomic_increment(INTERNAL_FUNCTION_PARAMETERS, int type,\n                       RedisSock *redis_sock, char **cmd, int *cmd_len,\n                       short *slot, void **ctx)\n{\n    char *key;\n    size_t key_len;\n    zend_long val = 1;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|l\", &key, &key_len,\n                              &val) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    /* If our value is 1 we use INCR/DECR.  For other values, treat the call as\n     * an INCRBY or DECRBY call */\n    if (type == TYPE_INCR) {\n        if (val == 1) {\n            *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"INCR\", \"k\", key, key_len);\n        } else {\n            *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"INCRBY\", \"kl\", key, key_len, val);\n        }\n    } else {\n        if (val == 1) {\n            *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"DECR\", \"k\", key, key_len);\n        } else {\n            *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"DECRBY\", \"kl\", key, key_len, val);\n        }\n    }\n\n    /* Success */\n    return SUCCESS;\n}\n\n/* INCR */\nint redis_incr_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    return redis_atomic_increment(INTERNAL_FUNCTION_PARAM_PASSTHRU,\n        TYPE_INCR, redis_sock, cmd, cmd_len, slot, ctx);\n}\n\n/* DECR */\nint redis_decr_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    return redis_atomic_increment(INTERNAL_FUNCTION_PARAM_PASSTHRU,\n        TYPE_DECR, redis_sock, cmd, cmd_len, slot, ctx);\n}\n\n/* HINCRBY */\nint redis_hincrby_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key, *mem;\n    size_t key_len, mem_len;\n    zend_long byval;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"ssl\", &key, &key_len,\n                             &mem, &mem_len, &byval) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    // Construct command\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"HINCRBY\", \"ksl\", key, key_len, mem, mem_len, byval);\n\n    // Success\n    return SUCCESS;\n}\n\n/* HINCRBYFLOAT */\nint redis_hincrbyfloat_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                           char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key, *mem;\n    size_t key_len, mem_len;\n    double byval;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"ssd\", &key, &key_len,\n                             &mem, &mem_len, &byval) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    // Construct command\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"HINCRBYFLOAT\", \"ksf\", key, key_len, mem,\n                                 mem_len, byval);\n\n    // Success\n    return SUCCESS;\n}\n\n/* HMGET */\nint redis_hmget_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                    char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zval *field = NULL, *zctx = NULL;\n    smart_string cmdstr = {0};\n    HashTable *fields = NULL;\n    zend_string *key = NULL;\n    zend_ulong valid = 0, i;\n\n    ZEND_PARSE_PARAMETERS_START(2, 2)\n        Z_PARAM_STR(key)\n        Z_PARAM_ARRAY_HT(fields)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (zend_hash_num_elements(fields) == 0)\n        return FAILURE;\n\n    zctx = ecalloc(1 + zend_hash_num_elements(fields), sizeof(*zctx));\n\n    ZEND_HASH_FOREACH_VAL(fields, field) {\n        ZVAL_DEREF(field);\n        if (!((Z_TYPE_P(field) == IS_STRING && Z_STRLEN_P(field) > 0) || Z_TYPE_P(field) == IS_LONG))\n            continue;\n\n        ZVAL_COPY(&zctx[valid++], field);\n    } ZEND_HASH_FOREACH_END();\n\n    if (valid == 0) {\n        efree(zctx);\n        return FAILURE;\n    }\n\n    ZVAL_NULL(&zctx[valid]);\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1 + valid, \"HMGET\");\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n\n    for (i = 0; i < valid; i++) {\n        redis_cmd_append_sstr_zval(&cmdstr, &zctx[i], NULL);\n    }\n\n    // Push out command, length, and key context\n    *cmd     = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    *ctx     = zctx;\n\n    return SUCCESS;\n}\n\n/* HMSET */\nint redis_hmset_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                    char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    zend_string *key = NULL;\n    HashTable *ht = NULL;\n    uint32_t fields;\n    zend_ulong idx;\n    zval *zv;\n\n    ZEND_PARSE_PARAMETERS_START(2, 2)\n        Z_PARAM_STR(key)\n        Z_PARAM_ARRAY_HT(ht)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    fields = zend_hash_num_elements(ht);\n    if (fields == 0)\n        return FAILURE;\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1 + (2 * fields), \"HMSET\");\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n\n    ZEND_HASH_FOREACH_KEY_VAL(ht, idx, key, zv) {\n        if (key) {\n            redis_cmd_append_sstr_zstr(&cmdstr, key);\n        } else {\n            redis_cmd_append_sstr_long(&cmdstr, idx);\n        }\n        redis_cmd_append_sstr_zval(&cmdstr, zv, redis_sock);\n    } ZEND_HASH_FOREACH_END();\n\n    *cmd_len = cmdstr.len;\n    *cmd = cmdstr.c;\n\n    return SUCCESS;\n}\n\n/* HSTRLEN */\nint\nredis_hstrlen_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                  char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key, *field;\n    size_t key_len, field_len;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\", &key, &key_len,\n                              &field, &field_len) == FAILURE\n    ) {\n        return FAILURE;\n    }\n\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"HSTRLEN\", \"ks\", key, key_len, field, field_len);\n\n    return SUCCESS;\n}\n\nstatic void redis_get_lcs_options(redisLcsOptions *dst, HashTable *ht) {\n    zend_string *key;\n    zval *zv;\n\n    ZEND_ASSERT(dst != NULL);\n\n    memset(dst, 0, sizeof(*dst));\n\n    if (ht == NULL)\n        return;\n\n    ZEND_HASH_FOREACH_STR_KEY_VAL(ht, key, zv) {\n        if (key) {\n            if (zend_string_equals_literal_ci(key, \"LEN\")) {\n                dst->idx = 0;\n                dst->len = zval_is_true(zv);\n            } else if (zend_string_equals_literal_ci(key, \"IDX\")) {\n                dst->len = 0;\n                dst->idx = zval_is_true(zv);\n            } else if (zend_string_equals_literal_ci(key, \"MINMATCHLEN\")) {\n                dst->minmatchlen = zval_get_long(zv);\n            } else if (zend_string_equals_literal_ci(key, \"WITHMATCHLEN\")) {\n                dst->withmatchlen = zval_is_true(zv);\n            } else {\n                php_error_docref(NULL, E_WARNING, \"Unknown LCS option '%s'\", ZSTR_VAL(key));\n            }\n        } else if (Z_TYPE_P(zv) == IS_STRING) {\n            if (zend_string_equals_literal_ci(Z_STR_P(zv), \"LEN\")) {\n                dst->idx = 0;\n                dst->len = 1;\n            } else if (zend_string_equals_literal_ci(Z_STR_P(zv), \"IDX\")) {\n                dst->idx = 1;\n                dst->len = 0;\n            } else if (zend_string_equals_literal_ci(Z_STR_P(zv), \"WITHMATCHLEN\")) {\n                dst->withmatchlen = 1;\n            }\n        }\n    } ZEND_HASH_FOREACH_END();\n}\n\n/* LCS */\nint redis_lcs_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                  char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *key1 = NULL, *key2 = NULL;\n    smart_string cmdstr = {0};\n    HashTable *ht = NULL;\n    redisLcsOptions opt;\n    int argc;\n\n    ZEND_PARSE_PARAMETERS_START(2, 3)\n        Z_PARAM_STR(key1)\n        Z_PARAM_STR(key2)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_ARRAY_HT_OR_NULL(ht)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    key1 = redis_key_prefix_zstr(redis_sock, key1);\n    key2 = redis_key_prefix_zstr(redis_sock, key2);\n\n    if (slot) {\n        *slot = cluster_hash_key_zstr(key1);\n        if (*slot != cluster_hash_key_zstr(key2)) {\n            php_error_docref(NULL, E_WARNING, \"Warning, not all keys hash to the same slot!\");\n            zend_string_release(key1);\n            zend_string_release(key2);\n            return FAILURE;\n        }\n    }\n\n    redis_get_lcs_options(&opt, ht);\n\n    argc = 2 + !!opt.idx + !!opt.len + !!opt.withmatchlen + (opt.minmatchlen ? 2 : 0);\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc, \"LCS\");\n\n    redis_cmd_append_sstr_zstr(&cmdstr, key1);\n    redis_cmd_append_sstr_zstr(&cmdstr, key2);\n\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, opt.idx, \"IDX\");\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, opt.len, \"LEN\");\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, opt.withmatchlen, \"WITHMATCHLEN\");\n\n    if (opt.minmatchlen) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"MINMATCHLEN\");\n        redis_cmd_append_sstr_long(&cmdstr, opt.minmatchlen);\n    }\n\n    zend_string_release(key1);\n    zend_string_release(key2);\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\nint redis_slowlog_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    enum {SLOWLOG_GET, SLOWLOG_LEN, SLOWLOG_RESET} mode;\n    smart_string cmdstr = {0};\n    zend_string *op = NULL;\n    zend_long arg = 0;\n\n    ZEND_PARSE_PARAMETERS_START(1, 2)\n        Z_PARAM_STR(op)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_LONG(arg)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (zend_string_equals_literal_ci(op, \"GET\")) {\n        mode = SLOWLOG_GET;\n    } else if (zend_string_equals_literal_ci(op, \"LEN\")) {\n        mode = SLOWLOG_LEN;\n    } else if (zend_string_equals_literal_ci(op, \"RESET\")) {\n        mode = SLOWLOG_RESET;\n    } else {\n        php_error_docref(NULL, E_WARNING, \"Unknown SLOWLOG operation '%s'\", ZSTR_VAL(op));\n        return FAILURE;\n    }\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1 + (mode == SLOWLOG_GET && ZEND_NUM_ARGS() == 2), \"SLOWLOG\");\n    redis_cmd_append_sstr_zstr(&cmdstr, op);\n\n    if (mode == SLOWLOG_GET && ZEND_NUM_ARGS() == 2)\n        redis_cmd_append_sstr_long(&cmdstr, arg);\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nvoid redis_get_restore_options(redisRestoreOptions *dst, HashTable *ht) {\n    zend_string *key;\n    zend_long lval;\n    zval *zv;\n\n    ZEND_ASSERT(dst != NULL);\n\n    memset(dst, 0, sizeof(*dst));\n    dst->idletime = dst->freq = -1;\n\n    if (ht == NULL)\n        return;\n\n    ZEND_HASH_FOREACH_STR_KEY_VAL(ht, key, zv) {\n        ZVAL_DEREF(zv);\n\n        if (key) {\n            if (zend_string_equals_literal_ci(key, \"IDLETIME\")) {\n                lval = zval_get_long(zv);\n                if (lval < 0) {\n                    php_error_docref(NULL, E_WARNING, \"IDLETIME must be >= 0\");\n                } else {\n                    dst->idletime = lval;\n                    dst->freq = -1;\n                }\n            } else if (zend_string_equals_literal_ci(key, \"FREQ\")) {\n                lval = zval_get_long(zv);\n                if (lval < 0 || lval > 255) {\n                    php_error_docref(NULL, E_WARNING, \"FREQ must be >= 0 and <= 255\");\n                } else {\n                    dst->freq = lval;\n                    dst->idletime = -1;\n                }\n            } else {\n                php_error_docref(NULL, E_WARNING, \"Unknown RESTORE option '%s'\", ZSTR_VAL(key));\n            }\n        } else if (Z_TYPE_P(zv) == IS_STRING) {\n            if (zend_string_equals_literal_ci(Z_STR_P(zv), \"REPLACE\")) {\n                dst->replace = 1;\n            } else if (zend_string_equals_literal_ci(Z_STR_P(zv), \"ABSTTL\")) {\n                dst->absttl = 1;\n            } else {\n                php_error_docref(NULL, E_WARNING, \"Unknown RESTORE option '%s'\", Z_STRVAL_P(zv));\n            }\n        }\n    } ZEND_HASH_FOREACH_END();\n}\n\n/* RESTORE */\nint redis_restore_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *key, *value = NULL;\n    smart_string cmdstr = {0};\n    HashTable *options = NULL;\n    redisRestoreOptions opt;\n    zend_long timeout = 0;\n    int argc;\n\n    ZEND_PARSE_PARAMETERS_START(3, 4) {\n        Z_PARAM_STR(key)\n        Z_PARAM_LONG(timeout)\n        Z_PARAM_STR(value)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_ARRAY_HT_OR_NULL(options)\n    } ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    redis_get_restore_options(&opt, options);\n\n    argc = 3 + (opt.idletime>-1?2:0) + (opt.freq>-1?2:0) + !!opt.absttl + !!opt.replace;\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc, \"RESTORE\");\n\n    redis_cmd_append_sstr_key(&cmdstr, ZSTR_VAL(key), ZSTR_LEN(key), redis_sock, slot);\n    redis_cmd_append_sstr_long(&cmdstr, timeout);\n    redis_cmd_append_sstr_zstr(&cmdstr, value);\n\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, opt.replace, \"REPLACE\");\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, opt.absttl, \"ABSTTL\");\n\n    if (opt.idletime > -1) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"IDLETIME\");\n        redis_cmd_append_sstr_long(&cmdstr, opt.idletime);\n    }\n\n    if (opt.freq > -1) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"FREQ\");\n        redis_cmd_append_sstr_long(&cmdstr, opt.freq);\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* BITPOS key bit [start [end [BYTE | BIT]]] */\nint redis_bitpos_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_long start = 0, end = -1;\n    zend_bool bit = 0, bybit = 0;\n    smart_string cmdstr = {0};\n    zend_string *key = NULL;\n\n    ZEND_PARSE_PARAMETERS_START(2, 5)\n        Z_PARAM_STR(key)\n        Z_PARAM_BOOL(bit)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_LONG(start)\n        Z_PARAM_LONG(end)\n        Z_PARAM_BOOL(bybit)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 2 + (ZEND_NUM_ARGS() > 2 ? 2 : 0) + !!bybit, \"BITPOS\");\n\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n    redis_cmd_append_sstr_long(&cmdstr, bit);\n\n    /* Start and length if we were passed either */\n    if (ZEND_NUM_ARGS() > 2) {\n        redis_cmd_append_sstr_long(&cmdstr, start);\n        redis_cmd_append_sstr_long(&cmdstr, end);\n    }\n\n    /* Finally, BIT or BYTE if we were passed that argument */\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, !!bybit, \"BIT\");\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* BITOP */\nint redis_bitop_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                    char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zval *z_args;\n    int i, argc = ZEND_NUM_ARGS();\n    smart_string cmdstr = {0};\n    short s2;\n\n    // Allocate space for args, parse them as an array\n    z_args = emalloc(argc * sizeof(zval));\n    if (zend_get_parameters_array(ht, argc, z_args) == FAILURE ||\n       argc < 3 || Z_TYPE(z_args[0]) != IS_STRING)\n    {\n        efree(z_args);\n        return FAILURE;\n    }\n\n    // If we were passed a slot pointer, init to a sentinel value\n    if (slot) *slot = -1;\n\n    // Initialize command construction, add our operation argument\n    redis_cmd_init_sstr(&cmdstr, argc, ZEND_STRL(\"BITOP\"));\n    redis_cmd_append_sstr(&cmdstr, Z_STRVAL(z_args[0]), Z_STRLEN(z_args[0]));\n\n    // Now iterate over our keys argument\n    for (i = 1; i < argc; i++) {\n        // Append the key\n        redis_cmd_append_sstr_key_zval(&cmdstr, &z_args[i], redis_sock, slot ? &s2 : NULL);\n\n        // Verify slot if this is a Cluster request\n        if (slot) {\n            if (*slot != -1 && s2 != *slot) {\n                php_error_docref(NULL, E_WARNING, \"Warning, not all keys hash to the same slot!\");\n                efree(z_args);\n                efree(cmdstr.c);\n                return FAILURE;\n            }\n            *slot = s2;\n        }\n    }\n\n    // Free our argument array\n    efree(z_args);\n\n    // Push out variables\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* BITCOUNT */\nint redis_bitcount_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key;\n    size_t key_len;\n    zend_long start = 0, end = -1;\n    zend_bool isbit = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|llb\", &key, &key_len,\n                             &start, &end, &isbit) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    if (isbit) {\n        *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"BITCOUNT\", \"kdds\", key, key_len,\n                                     (int)start, (int)end, \"BIT\", 3);\n    } else {\n        *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"BITCOUNT\", \"kdd\", key, key_len,\n                                     (int)start, (int)end);\n    }\n\n    return SUCCESS;\n}\n\n/* PFADD and PFMERGE are the same except that in one case we serialize,\n * and in the other case we key prefix */\nstatic int redis_gen_pf_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                            char *kw, int kw_len, int is_keys, char **cmd,\n                            int *cmd_len, short *slot)\n{\n    smart_string cmdstr = {0};\n    zend_string *key = NULL;\n    HashTable *ht = NULL;\n    zval *z_ele;\n    int argc=1;\n    short s2;\n\n    // Parse arguments\n    ZEND_PARSE_PARAMETERS_START(2, 2)\n        Z_PARAM_STR(key)\n        Z_PARAM_ARRAY_HT(ht)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    argc += zend_hash_num_elements(ht);\n\n    // We need at least two arguments\n    if (argc < 2) {\n        return FAILURE;\n    }\n\n    redis_cmd_init_sstr(&cmdstr, argc, kw, kw_len);\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n\n    // Append our array of keys or serialized values */\n    ZEND_HASH_FOREACH_VAL(ht, z_ele) {\n        if (is_keys) {\n            redis_cmd_append_sstr_key_zval(&cmdstr, z_ele, redis_sock, slot ? &s2 : NULL);\n            if (slot && *slot != s2) {\n                php_error_docref(0, E_WARNING, \"All keys must hash to the same slot!\");\n                return FAILURE;\n            }\n        } else {\n            redis_cmd_append_sstr_zval(&cmdstr, z_ele, redis_sock);\n        }\n    } ZEND_HASH_FOREACH_END();\n\n    // Push output arguments\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* PFADD */\nint redis_pfadd_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                    char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    return redis_gen_pf_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock,\n        ZEND_STRL(\"PFADD\"), 0, cmd, cmd_len, slot);\n}\n\n/* PFMERGE */\nint redis_pfmerge_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    return redis_gen_pf_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock,\n        ZEND_STRL(\"PFMERGE\"), 1, cmd, cmd_len, slot);\n}\n\n/* PFCOUNT */\nint redis_pfcount_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    zval *zarg = NULL, *zv;\n    short slot2 = -1;\n    uint32_t keys;\n\n    ZEND_PARSE_PARAMETERS_START(1, 1)\n        Z_PARAM_ZVAL(zarg)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (Z_TYPE_P(zarg) == IS_STRING) {\n        REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1, \"PFCOUNT\");\n        redis_cmd_append_sstr_key_zstr(&cmdstr, Z_STR_P(zarg), redis_sock, slot);\n    } else if (Z_TYPE_P(zarg) == IS_ARRAY) {\n        keys = zend_hash_num_elements(Z_ARRVAL_P(zarg));\n        if (keys == 0)\n            return FAILURE;\n\n        REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, keys, \"PFCOUNT\");\n\n        ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(zarg), zv) {\n            redis_cmd_append_sstr_key_zval(&cmdstr, zv, redis_sock, slot);\n            if (slot) {\n                if (slot2 != -1 && slot2 != *slot)\n                    goto cross_slot;\n                slot2 = *slot;\n            }\n        } ZEND_HASH_FOREACH_END();\n    } else {\n        php_error_docref(NULL, E_WARNING, \"Argument must be either an array or a string\");\n        return FAILURE;\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n\ncross_slot:\n    php_error_docref(NULL, E_WARNING, \"Not all keys hash to the same slot!\");\n    efree(cmdstr.c);\n    return FAILURE;\n}\n\nint redis_auth_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *user = NULL, *pass = NULL;\n    zval *ztest;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"z!\", &ztest) == FAILURE ||\n        redis_extract_auth_info(ztest, &user, &pass) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    /* Construct either AUTH <user> <pass> or AUTH <pass> */\n    if (user && pass) {\n        *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"AUTH\", \"SS\", user, pass);\n    } else {\n        *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"AUTH\", \"S\", pass);\n    }\n\n    redis_sock_set_auth(redis_sock, user, pass);\n\n    if (user) zend_string_release(user);\n    if (pass) zend_string_release(pass);\n\n    return SUCCESS;\n}\n\n/* SETBIT */\nint redis_setbit_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key;\n    size_t key_len;\n    zend_long offset;\n    zend_bool val;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"slb\", &key, &key_len,\n                             &offset, &val) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    // Validate our offset\n    if (offset < BITOP_MIN_OFFSET || offset > BITOP_MAX_OFFSET) {\n        php_error_docref(0, E_WARNING,\n            \"Invalid OFFSET for bitop command (must be between 0-2^32-1)\");\n        return FAILURE;\n    }\n\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"SETBIT\", \"kld\", key, key_len, offset, (int)val);\n\n    return SUCCESS;\n}\n\nint redis_lmove_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *src = NULL, *dst = NULL, *from = NULL, *to = NULL;\n    smart_string cmdstr = {0};\n    double timeout = 0.0;\n    short slot2 = 0;\n    int blocking;\n\n    blocking = toupper(*kw) == 'B';\n\n    ZEND_PARSE_PARAMETERS_START(4 + !!blocking, 4 + !!blocking)\n        Z_PARAM_STR(src)\n        Z_PARAM_STR(dst)\n        Z_PARAM_STR(from)\n        Z_PARAM_STR(to)\n        if (blocking) {\n            Z_PARAM_DOUBLE(timeout)\n        }\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (!zend_string_equals_literal_ci(from, \"LEFT\") && !zend_string_equals_literal_ci(from, \"RIGHT\")) {\n        php_error_docref(NULL, E_WARNING, \"Wherefrom argument must be 'LEFT' or 'RIGHT'\");\n        return FAILURE;\n    } else if (!zend_string_equals_literal_ci(to, \"LEFT\") && !zend_string_equals_literal_ci(to, \"RIGHT\")) {\n        php_error_docref(NULL, E_WARNING, \"Whereto argument must be 'LEFT' or 'RIGHT'\");\n        return FAILURE;\n    }\n\n    redis_cmd_init_sstr(&cmdstr, 4 + !!blocking, kw, strlen(kw));\n    redis_cmd_append_sstr_key_zstr(&cmdstr, src, redis_sock, slot);\n    redis_cmd_append_sstr_key_zstr(&cmdstr, dst, redis_sock, slot ? &slot2 : NULL);\n\n    /* Protect the user from CROSSLOT errors */\n    if (slot && slot2 != *slot) {\n        php_error_docref(NULL, E_WARNING, \"Both keys must hash to the same slot!\");\n        efree(cmdstr.c);\n        return FAILURE;\n    }\n\n    redis_cmd_append_sstr_zstr(&cmdstr, from);\n    redis_cmd_append_sstr_zstr(&cmdstr, to);\n    if (blocking) redis_cmd_append_sstr_dbl(&cmdstr, timeout);\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* LINSERT */\nint redis_linsert_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key, *pos;\n    size_t key_len, pos_len;\n    zval *z_val, *z_pivot;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sszz\", &key, &key_len,\n                             &pos, &pos_len, &z_pivot, &z_val) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    // Validate position\n    if (strcasecmp(pos, \"after\") && strcasecmp(pos, \"before\")) {\n        php_error_docref(NULL, E_WARNING,\n            \"Position must be either 'BEFORE' or 'AFTER'\");\n        return FAILURE;\n    }\n\n    /* Construct command */\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"LINSERT\", \"ksvv\", key, key_len, pos,\n                                 pos_len, z_pivot, z_val);\n\n    // Success\n    return SUCCESS;\n}\n\n/* LREM */\nint redis_lrem_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key;\n    size_t key_len;\n    zend_long count = 0;\n    zval *z_val;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz|l\", &key, &key_len,\n                             &z_val, &count) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    /* Construct command */\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"LREM\", \"kdv\", key, key_len, count, z_val);\n\n    // Success!\n    return SUCCESS;\n}\n\nint\nredis_lpos_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n               char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key;\n    int argc = 2;\n    size_t key_len;\n    smart_string cmdstr = {0};\n    zend_bool withrank = 0;\n    zend_long rank = 0, count = -1, maxlen = -1;\n    zend_string *zkey;\n    zval *z_val, *z_ele, *z_opts = NULL;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz|a\",\n                              &key, &key_len, &z_val, &z_opts) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    if (z_opts != NULL) {\n        ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARRVAL_P(z_opts), zkey, z_ele) {\n            if (zkey != NULL) {\n                ZVAL_DEREF(z_ele);\n                if (zend_string_equals_literal_ci(zkey, \"count\")) {\n                    count = zval_get_long(z_ele);\n                } else if (zend_string_equals_literal_ci(zkey, \"maxlen\")) {\n                    maxlen = zval_get_long(z_ele);\n                } else if (zend_string_equals_literal_ci(zkey, \"rank\")) {\n                    rank = zval_get_long(z_ele);\n                    withrank = 1;\n                }\n            }\n        } ZEND_HASH_FOREACH_END();\n    }\n\n    argc += (withrank ? 2 : 0) + (count >= 0 ? 2 : 0) + (maxlen >= 0 ? 2 : 0);\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc, \"LPOS\");\n\n    redis_cmd_append_sstr_key(&cmdstr, key, key_len, redis_sock, slot);\n    redis_cmd_append_sstr_zval(&cmdstr, z_val, redis_sock);\n\n    if (withrank) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"RANK\");\n        redis_cmd_append_sstr_long(&cmdstr, rank);\n    }\n\n    if (count >= 0) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"COUNT\");\n        redis_cmd_append_sstr_long(&cmdstr, count);\n        *ctx = PHPREDIS_CTX_PTR;\n    }\n\n    if (maxlen >= 0) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"MAXLEN\");\n        redis_cmd_append_sstr_long(&cmdstr, maxlen);\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nint redis_smove_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                    char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *src = NULL, *dst = NULL;\n    smart_string cmdstr = {0};\n    zval *zv = NULL;\n    short slot2;\n\n    ZEND_PARSE_PARAMETERS_START(3, 3) {\n        Z_PARAM_STR(src)\n        Z_PARAM_STR(dst)\n        Z_PARAM_ZVAL(zv)\n    } ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 3, \"SMOVE\");\n    redis_cmd_append_sstr_key_zstr(&cmdstr, src, redis_sock, slot);\n    redis_cmd_append_sstr_key_zstr(&cmdstr, dst, redis_sock, slot ? &slot2 : NULL);\n    redis_cmd_append_sstr_zval(&cmdstr, zv, redis_sock);\n\n    if (slot && *slot != slot2) {\n        php_error_docref(0, E_WARNING, \"Source and destination keys don't hash to the same slot!\");\n        efree(cmdstr.c);\n        return FAILURE;\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* HSET */\nint redis_hset_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    int i, argc;\n    smart_string cmdstr = {0};\n    zend_string *key, *zkey;\n    zval *args, *z_ele;\n\n    ZEND_PARSE_PARAMETERS_START(2, -1)\n        Z_PARAM_STR(key)\n        Z_PARAM_VARIADIC('*', args, argc)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (argc == 1) {\n        if (Z_TYPE_P(args) != IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_P(args)) == 0) {\n            return FAILURE;\n        }\n\n        /* Initialize our command */\n        redis_cmd_init_sstr(&cmdstr, 1 + zend_hash_num_elements(Z_ARRVAL_P(args)) * 2, ZEND_STRL(\"HSET\"));\n\n        /* Append key */\n        redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n\n        ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARRVAL_P(args), zkey, z_ele) {\n            if (zkey != NULL) {\n                ZVAL_DEREF(z_ele);\n                redis_cmd_append_sstr(&cmdstr, ZSTR_VAL(zkey), ZSTR_LEN(zkey));\n                redis_cmd_append_sstr_zval(&cmdstr, z_ele, redis_sock);\n            }\n        } ZEND_HASH_FOREACH_END();\n    } else {\n        if (argc % 2 != 0) {\n            return FAILURE;\n        }\n\n        /* Initialize our command */\n        redis_cmd_init_sstr(&cmdstr, argc + 1, ZEND_STRL(\"HSET\"));\n\n        /* Append key */\n        redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n\n        for (i = 0; i < argc; ++i) {\n            if (i % 2) {\n                redis_cmd_append_sstr_zval(&cmdstr, &args[i], redis_sock);\n            } else {\n                redis_cmd_append_sstr_zval(&cmdstr, &args[i], NULL);\n            }\n        }\n    }\n\n    // Push out values\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* HSETNX */\nint redis_hsetnx_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key, *mem;\n    size_t key_len, mem_len;\n    zval *z_val;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"ssz\", &key, &key_len,\n                             &mem, &mem_len, &z_val) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    /* Construct command */\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"HSETNX\", \"ksv\", key, key_len, mem, mem_len, z_val);\n\n    // Success\n    return SUCCESS;\n}\n\nint\nredis_hrandfield_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key;\n    int count = 0;\n    size_t key_len;\n    smart_string cmdstr = {0};\n    zend_bool withvalues = 0;\n    zval *z_opts = NULL, *z_ele;\n    zend_string *zkey;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\",\n                              &key, &key_len, &z_opts) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    if (z_opts != NULL) {\n        ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARRVAL_P(z_opts), zkey, z_ele) {\n            if (zkey != NULL) {\n                ZVAL_DEREF(z_ele);\n                if (zend_string_equals_literal_ci(zkey, \"count\")) {\n                    count = zval_get_long(z_ele);\n                } else if (zend_string_equals_literal_ci(zkey, \"withvalues\")) {\n                    withvalues = zval_is_true(z_ele);\n                }\n            } else if (Z_TYPE_P(z_ele) == IS_STRING) {\n                if (zend_string_equals_literal_ci(Z_STR_P(z_ele), \"WITHVALUES\")) {\n                    withvalues = 1;\n                }\n            }\n        } ZEND_HASH_FOREACH_END();\n    }\n\n    /* If we're sending WITHVALUES we must also send a count */\n    if (count == 0 && withvalues)\n        count = 1;\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1 + (count != 0) + withvalues, \"HRANDFIELD\");\n    redis_cmd_append_sstr_key(&cmdstr, key, key_len, redis_sock, slot);\n\n    if (count != 0) {\n        redis_cmd_append_sstr_long(&cmdstr, count);\n        *ctx = PHPREDIS_CTX_PTR;\n    }\n\n    if (withvalues) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"WITHVALUES\");\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    }\n\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\nint redis_select_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_long db = 0;\n\n    ZEND_PARSE_PARAMETERS_START(1, 1)\n        Z_PARAM_LONG(db)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (db < 0 || db > INT_MAX)\n        return FAILURE;\n\n    *ctx = (void*)(uintptr_t)db;\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"SELECT\", \"d\", db);\n\n    return SUCCESS;\n}\n\n/* SRANDMEMBER */\nint redis_srandmember_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                          char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    uint32_t argc = ZEND_NUM_ARGS();\n    smart_string cmdstr = {0};\n    zend_string *key = NULL;\n    zend_long count = 0;\n\n    ZEND_PARSE_PARAMETERS_START(1, 2)\n        Z_PARAM_STR(key)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_LONG(count)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, ZEND_NUM_ARGS(), \"SRANDMEMBER\");\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n    if (argc == 2)\n        redis_cmd_append_sstr_long(&cmdstr, count);\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    *ctx = argc == 2 ? PHPREDIS_CTX_PTR : NULL;\n\n    return SUCCESS;\n}\n\n/* ZINCRBY */\nint redis_zincrby_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key;\n    size_t key_len;\n    double incrby;\n    zval *z_val;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sdz\", &key, &key_len,\n                             &incrby, &z_val) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"ZINCRBY\", \"kfv\", key, key_len, incrby, z_val);\n\n    return SUCCESS;\n}\n\n/* SORT */\nint redis_sort_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char *kw, char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zval *z_opts=NULL, *z_ele, z_argv;\n    char *key;\n    HashTable *ht_opts;\n    smart_string cmdstr = {0};\n    size_t key_len;\n    int key_free;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &key, &key_len,\n                             &z_opts) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    // If we don't have an options array, the command is quite simple\n    if (!z_opts || zend_hash_num_elements(Z_ARRVAL_P(z_opts)) == 0) {\n        // Construct command\n        *cmd_len = REDIS_CMD_SPPRINTF(cmd, kw, \"k\", key, key_len);\n\n        return SUCCESS;\n    }\n\n    // Create our hash table to hold our sort arguments\n    array_init(&z_argv);\n\n    // SORT <key>\n    key_free = redis_key_prefix(redis_sock, &key, &key_len);\n    add_next_index_stringl(&z_argv, key, key_len);\n    if (key_free) efree(key);\n\n    // Set slot\n    CMD_SET_SLOT(slot,key,key_len);\n\n    // Grab the hash table\n    ht_opts = Z_ARRVAL_P(z_opts);\n\n    // Handle BY pattern\n    if (((z_ele = zend_hash_str_find(ht_opts, \"by\", sizeof(\"by\") - 1)) != NULL ||\n         (z_ele = zend_hash_str_find(ht_opts, \"BY\", sizeof(\"BY\") - 1)) != NULL\n        ) && Z_TYPE_P(z_ele) == IS_STRING\n    ) {\n        // \"BY\" option is disabled in cluster\n        if (slot) {\n            php_error_docref(NULL, E_WARNING,\n                \"SORT BY option is not allowed in Redis Cluster\");\n            zval_dtor(&z_argv);\n            return FAILURE;\n        }\n\n        // ... BY <pattern>\n        add_next_index_stringl(&z_argv, \"BY\", sizeof(\"BY\") - 1);\n        add_next_index_stringl(&z_argv, Z_STRVAL_P(z_ele), Z_STRLEN_P(z_ele));\n    }\n\n    // Handle ASC/DESC option\n    if (((z_ele = zend_hash_str_find(ht_opts, \"sort\", sizeof(\"sort\") - 1)) != NULL ||\n         (z_ele = zend_hash_str_find(ht_opts, \"SORT\", sizeof(\"SORT\") - 1)) != NULL\n        ) && Z_TYPE_P(z_ele) == IS_STRING\n    ) {\n        // 'asc'|'desc'\n        add_next_index_stringl(&z_argv, Z_STRVAL_P(z_ele), Z_STRLEN_P(z_ele));\n    }\n\n    // STORE option\n    if (((z_ele = zend_hash_str_find(ht_opts, \"store\", sizeof(\"store\") - 1)) != NULL ||\n         (z_ele = zend_hash_str_find(ht_opts, \"STORE\", sizeof(\"STORE\") - 1)) != NULL\n        ) && Z_TYPE_P(z_ele) == IS_STRING\n    ) {\n        // Slot verification\n        int cross_slot = slot && *slot != cluster_hash_key(\n            Z_STRVAL_P(z_ele), Z_STRLEN_P(z_ele));\n\n        if (cross_slot) {\n            php_error_docref(0, E_WARNING,\n                \"Error, SORT key and STORE key have different slots!\");\n            zval_dtor(&z_argv);\n            return FAILURE;\n        }\n\n        // STORE <key>\n        add_next_index_stringl(&z_argv, \"STORE\", sizeof(\"STORE\") - 1);\n        add_next_index_stringl(&z_argv, Z_STRVAL_P(z_ele), Z_STRLEN_P(z_ele));\n\n        // We are using STORE\n        *ctx = PHPREDIS_CTX_PTR;\n    }\n\n    // GET option\n    if (((z_ele = zend_hash_str_find(ht_opts, \"get\", sizeof(\"get\") - 1)) != NULL ||\n         (z_ele = zend_hash_str_find(ht_opts, \"GET\", sizeof(\"GET\") - 1)) != NULL\n        ) && (Z_TYPE_P(z_ele) == IS_STRING || Z_TYPE_P(z_ele) == IS_ARRAY)\n    ) {\n        // Disabled in cluster\n        if (slot) {\n            php_error_docref(NULL, E_WARNING,\n                \"GET option for SORT disabled in Redis Cluster\");\n            zval_dtor(&z_argv);\n            return FAILURE;\n        }\n\n        // If it's a string just add it\n        if (Z_TYPE_P(z_ele) == IS_STRING) {\n            add_next_index_stringl(&z_argv, \"GET\", sizeof(\"GET\") - 1);\n            add_next_index_stringl(&z_argv, Z_STRVAL_P(z_ele), Z_STRLEN_P(z_ele));\n        } else {\n            int added = 0;\n            zval *z_key;\n\n            ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(z_ele), z_key) {\n                // If we can't get the data, or it's not a string, skip\n                if (z_key == NULL || Z_TYPE_P(z_key) != IS_STRING) {\n                    continue;\n                }\n                /* Add get per thing we're getting */\n                add_next_index_stringl(&z_argv, \"GET\", sizeof(\"GET\") - 1);\n\n                // Add this key to our argv array\n                add_next_index_stringl(&z_argv, Z_STRVAL_P(z_key), Z_STRLEN_P(z_key));\n                added++;\n            } ZEND_HASH_FOREACH_END();\n\n            // Make sure we were able to add at least one\n            if (added == 0) {\n                php_error_docref(NULL, E_WARNING,\n                    \"Array of GET values requested, but none are valid\");\n                zval_dtor(&z_argv);\n                return FAILURE;\n            }\n        }\n    }\n\n    // ALPHA\n    if (((z_ele = zend_hash_str_find(ht_opts, \"alpha\", sizeof(\"alpha\") - 1)) != NULL ||\n         (z_ele = zend_hash_str_find(ht_opts, \"ALPHA\", sizeof(\"ALPHA\") - 1)) != NULL) &&\n         zval_is_true(z_ele)\n    ) {\n        add_next_index_stringl(&z_argv, \"ALPHA\", sizeof(\"ALPHA\") - 1);\n    }\n\n    // LIMIT <offset> <count>\n    if (((z_ele = zend_hash_str_find(ht_opts, \"limit\", sizeof(\"limit\") - 1)) != NULL ||\n         (z_ele = zend_hash_str_find(ht_opts, \"LIMIT\", sizeof(\"LIMIT\") - 1)) != NULL\n        ) && Z_TYPE_P(z_ele) == IS_ARRAY\n    ) {\n        HashTable *ht_off = Z_ARRVAL_P(z_ele);\n        zval *z_off, *z_cnt;\n\n        if ((z_off = zend_hash_index_find(ht_off, 0)) != NULL &&\n            (z_cnt = zend_hash_index_find(ht_off, 1)) != NULL\n        ) {\n            if ((Z_TYPE_P(z_off) != IS_STRING && Z_TYPE_P(z_off) != IS_LONG) ||\n                (Z_TYPE_P(z_cnt) != IS_STRING && Z_TYPE_P(z_cnt) != IS_LONG)\n            ) {\n                php_error_docref(NULL, E_WARNING,\n                    \"LIMIT options on SORT command must be longs or strings\");\n                zval_dtor(&z_argv);\n                return FAILURE;\n            }\n\n            // Add LIMIT argument\n            add_next_index_stringl(&z_argv, \"LIMIT\", sizeof(\"LIMIT\") - 1);\n\n            long low, high;\n            if (Z_TYPE_P(z_off) == IS_STRING) {\n                low = atol(Z_STRVAL_P(z_off));\n            } else {\n                low = Z_LVAL_P(z_off);\n            }\n            if (Z_TYPE_P(z_cnt) == IS_STRING) {\n                high = atol(Z_STRVAL_P(z_cnt));\n            } else {\n                high = Z_LVAL_P(z_cnt);\n            }\n\n            // Add our two LIMIT arguments\n            add_next_index_long(&z_argv, low);\n            add_next_index_long(&z_argv, high);\n        }\n    }\n\n    // Start constructing our command\n    HashTable *ht_argv = Z_ARRVAL_P(&z_argv);\n    redis_cmd_init_sstr(&cmdstr, zend_hash_num_elements(ht_argv), kw, strlen(kw));\n\n    // Iterate through our arguments\n    ZEND_HASH_FOREACH_VAL(ht_argv, z_ele) {\n        // Args are strings or longs\n        if (Z_TYPE_P(z_ele) == IS_STRING) {\n            redis_cmd_append_sstr(&cmdstr,Z_STRVAL_P(z_ele),\n                Z_STRLEN_P(z_ele));\n        } else {\n            redis_cmd_append_sstr_long(&cmdstr, Z_LVAL_P(z_ele));\n        }\n    } ZEND_HASH_FOREACH_END();\n\n    /* Clean up our arguments array.  Note we don't have to free any prefixed\n     * key as that we didn't duplicate the pointer if we prefixed */\n    zval_dtor(&z_argv);\n\n    // Push our length and command\n    *cmd_len = cmdstr.len;\n    *cmd     = cmdstr.c;\n\n    // Success!\n    return SUCCESS;\n}\n\n/* HDEL */\nint redis_hdel_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    zend_string *key = NULL;\n    int i;\n    int argc = 0;\n    zval *args;\n\n    ZEND_PARSE_PARAMETERS_START(2, -1)\n        Z_PARAM_STR(key)\n        Z_PARAM_VARIADIC('*', args, argc)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    // Start command construction\n    redis_cmd_init_sstr(&cmdstr, argc + 1, ZEND_STRL(\"HDEL\"));\n\n    // Append key\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n\n    // Iterate through the members we're removing\n    for (i = 0; i < argc; i++) {\n        redis_cmd_append_sstr_zval(&cmdstr, &args[i], NULL);\n    }\n\n    // Push out values\n    *cmd     = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    // Success!\n    return SUCCESS;\n}\n\n/* ZADD */\nint redis_zadd_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *zstr, *key = NULL, *exp_type = NULL, *range_type = NULL;\n    zend_bool ch = 0, incr = 0;\n    smart_string cmdstr = {0};\n    zval *argv = NULL, *z_opt;\n    int argc = 0, pos = 0;\n\n    ZEND_PARSE_PARAMETERS_START(3, -1)\n        Z_PARAM_STR(key)\n        Z_PARAM_VARIADIC('*', argv, argc)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    // Need key, [NX|XX] [LT|GT] [CH] [INCR] score, value, [score, value...] */\n    if (argc % 2 != 0) {\n        if (Z_TYPE(argv[0]) != IS_ARRAY) {\n            return FAILURE;\n        }\n\n        ZEND_HASH_FOREACH_VAL(Z_ARRVAL(argv[0]), z_opt) {\n            if (Z_TYPE_P(z_opt) == IS_STRING) {\n                zstr = Z_STR_P(z_opt);\n                if (zend_string_equals_literal_ci(zstr, \"NX\") || zend_string_equals_literal_ci(zstr, \"XX\")) {\n                    exp_type = Z_STR_P(z_opt);\n                } else if (zend_string_equals_literal_ci(zstr, \"LT\") || zend_string_equals_literal_ci(zstr, \"GT\")) {\n                    range_type = Z_STR_P(z_opt);\n                } else if (zend_string_equals_literal_ci(zstr, \"CH\")) {\n                    ch = 1;\n                } else if (zend_string_equals_literal_ci(zstr, \"INCR\")) {\n                    if (argc != 3) {\n                        // Only one score-element pair can be specified in this mode.\n                        return FAILURE;\n                    }\n                    incr = 1;\n                }\n            }\n        } ZEND_HASH_FOREACH_END();\n\n        pos++;\n    }\n\n    // Start command construction\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1 + (argc - pos) + !!exp_type + !!range_type + !!ch + !!incr, \"ZADD\");\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n\n    if (exp_type) redis_cmd_append_sstr_zstr(&cmdstr, exp_type);\n    if (range_type) redis_cmd_append_sstr_zstr(&cmdstr, range_type);\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, ch, \"CH\");\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, incr, \"INCR\");\n\n    // Now the rest of our arguments\n    while (pos < argc) {\n        // Append score and member\n        if (redis_cmd_append_sstr_score(&cmdstr, &argv[pos]) == FAILURE) {\n            smart_string_free(&cmdstr);\n            return FAILURE;\n        }\n\n        redis_cmd_append_sstr_zval(&cmdstr, &argv[pos+1], redis_sock);\n\n        pos += 2;\n    }\n\n    // Push output values\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    *ctx = incr ? PHPREDIS_CTX_PTR : NULL;\n\n    return SUCCESS;\n}\n\n/* OBJECT */\nint redis_object_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *subcmd = NULL, *key = NULL;\n    smart_string cmdstr = {0};\n\n    ZEND_PARSE_PARAMETERS_START(2, 2)\n        Z_PARAM_STR(subcmd)\n        Z_PARAM_STR(key)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (zend_string_equals_literal_ci(subcmd, \"REFCOUNT\") ||\n        zend_string_equals_literal_ci(subcmd, \"IDLETIME\"))\n    {\n        *ctx = PHPREDIS_CTX_PTR;\n    } else if (zend_string_equals_literal_ci(subcmd, \"ENCODING\")) {\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    } else {\n        php_error_docref(NULL, E_WARNING, \"Invalid subcommand sent to OBJECT\");\n        return FAILURE;\n    }\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 2, \"OBJECT\");\n    redis_cmd_append_sstr_zstr(&cmdstr, subcmd);\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\nint\nredis_geoadd_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                 char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zval *z_args, *z_ele;\n    smart_string cmdstr = {0};\n    zend_bool ch = 0;\n    zend_string *zstr;\n    char *mode = NULL;\n    int argc, i;\n\n    // We at least need a key and three values\n    if ((argc = ZEND_NUM_ARGS()) < 4 || (argc % 3 != 1 && argc % 3 != 2)) {\n        zend_wrong_param_count();\n        return FAILURE;\n    }\n\n    // Make sure we at least have a key, and we can get other args\n    z_args = ecalloc(argc, sizeof(*z_args));\n    if (zend_get_parameters_array(ht, argc, z_args) == FAILURE) {\n        efree(z_args);\n        return FAILURE;\n    }\n\n    if (argc % 3 == 2) {\n        argc--;\n        if (Z_TYPE(z_args[argc]) != IS_ARRAY) {\n            php_error_docref(NULL, E_WARNING, \"Invalid options value\");\n            efree(z_args);\n            return FAILURE;\n        }\n        ZEND_HASH_FOREACH_VAL(Z_ARRVAL(z_args[argc]), z_ele) {\n            ZVAL_DEREF(z_ele);\n            if (Z_TYPE_P(z_ele) == IS_STRING) {\n                if (zend_string_equals_literal_ci(Z_STR_P(z_ele), \"NX\") ||\n                    zend_string_equals_literal_ci(Z_STR_P(z_ele), \"XX\"))\n                {\n                    mode = Z_STRVAL_P(z_ele);\n                } else if (zend_string_equals_literal_ci(Z_STR_P(z_ele), \"CH\")) {\n                    ch = 1;\n                }\n            }\n        } ZEND_HASH_FOREACH_END();\n    }\n\n    /* Initialize our command */\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc + (mode != NULL) + ch, \"GEOADD\");\n\n    /* Append key */\n    zstr = zval_get_string(&z_args[0]);\n    redis_cmd_append_sstr_key(&cmdstr, ZSTR_VAL(zstr), ZSTR_LEN(zstr), redis_sock, slot);\n    zend_string_release(zstr);\n\n    /* Append options */\n    if (mode != NULL) {\n        redis_cmd_append_sstr(&cmdstr, mode, strlen(mode));\n    }\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, ch, \"CH\");\n\n    /* Append members */\n    for (i = 1; i < argc; ++i) {\n        redis_cmd_append_sstr_zval(&cmdstr, &z_args[i], redis_sock);\n    }\n\n    // Cleanup arg array\n    efree(z_args);\n\n    // Push out values\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* GEODIST */\nint redis_geodist_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key, *source, *dest, *unit = NULL;\n    size_t keylen, sourcelen, destlen, unitlen;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sss|s\", &key, &keylen,\n                              &source, &sourcelen, &dest, &destlen, &unit,\n                              &unitlen) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    /* Construct command */\n    if (unit != NULL) {\n        *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"GEODIST\", \"ksss\", key, keylen, source,\n                                     sourcelen, dest, destlen, unit, unitlen);\n    } else {\n        *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"GEODIST\", \"kss\", key, keylen, source,\n                                     sourcelen, dest, destlen);\n    }\n\n    return SUCCESS;\n}\n\ngeoStoreType get_georadius_store_type(zend_string *key) {\n    if (ZSTR_LEN(key) == 5 && !strcasecmp(ZSTR_VAL(key), \"store\")) {\n        return STORE_COORD;\n    } else if (ZSTR_LEN(key) == 9 && !strcasecmp(ZSTR_VAL(key), \"storedist\")) {\n        return STORE_DIST;\n    }\n\n    return STORE_NONE;\n}\n\n/* Helper function to get COUNT and possible ANY flag which is passable to\n * both GEORADIUS and GEOSEARCH */\nstatic int get_georadius_count_options(zval *optval, geoOptions *opts) {\n    zval *z_tmp;\n\n    /* Short circuit on bad options */\n    if (Z_TYPE_P(optval) != IS_ARRAY && Z_TYPE_P(optval) != IS_LONG)\n        goto error;\n\n    if (Z_TYPE_P(optval) == IS_ARRAY) {\n        z_tmp = zend_hash_index_find(Z_ARRVAL_P(optval), 0);\n        if (z_tmp) {\n            if (Z_TYPE_P(z_tmp) != IS_LONG || Z_LVAL_P(z_tmp) <= 0)\n                goto error;\n            opts->count = Z_LVAL_P(z_tmp);\n        }\n\n        z_tmp = zend_hash_index_find(Z_ARRVAL_P(optval), 1);\n        if (z_tmp) {\n            opts->any = zval_is_true(z_tmp);\n        }\n    } else {\n        if (Z_LVAL_P(optval) <= 0)\n            goto error;\n        opts->count = Z_LVAL_P(optval);\n    }\n\n    return SUCCESS;\n\nerror:\n    php_error_docref(NULL, E_WARNING, \"Invalid COUNT value\");\n    return FAILURE;\n}\n\n/* Helper function to extract optional arguments for GEORADIUS and GEORADIUSBYMEMBER */\nstatic int get_georadius_opts(HashTable *ht, geoOptions *opts) {\n    zend_string *zkey;\n    char *optstr;\n    zval *optval;\n\n    /* Iterate over our argument array, collating which ones we have */\n    ZEND_HASH_FOREACH_STR_KEY_VAL(ht, zkey, optval) {\n        ZVAL_DEREF(optval);\n\n        /* If the key is numeric it's a non value option */\n        if (zkey) {\n            if (zend_string_equals_literal_ci(zkey, \"COUNT\")) {\n                if (get_georadius_count_options(optval, opts) == FAILURE) {\n                    if (opts->key) zend_string_release(opts->key);\n                    return FAILURE;\n                }\n            } else if (opts->store == STORE_NONE) {\n                opts->store = get_georadius_store_type(zkey);\n                if (opts->store != STORE_NONE) {\n                    opts->key = zval_get_string(optval);\n                }\n            }\n        } else {\n            /* Option needs to be a string */\n            if (Z_TYPE_P(optval) != IS_STRING) continue;\n\n            optstr = Z_STRVAL_P(optval);\n\n            if (!strcasecmp(optstr, \"withcoord\")) {\n                opts->withcoord = 1;\n            } else if (!strcasecmp(optstr, \"withdist\")) {\n                opts->withdist = 1;\n            } else if (!strcasecmp(optstr, \"withhash\")) {\n                opts->withhash = 1;\n            } else if (!strcasecmp(optstr, \"asc\")) {\n                opts->sort = SORT_ASC;\n            } else if (!strcasecmp(optstr, \"desc\")) {\n                opts->sort = SORT_DESC;\n            }\n        }\n    } ZEND_HASH_FOREACH_END();\n\n    /* STORE and STOREDIST are not compatible with the WITH* options */\n    if (opts->key != NULL && (opts->withcoord || opts->withdist || opts->withhash)) {\n        php_error_docref(NULL, E_WARNING,\n            \"STORE[DIST] is not compatible with WITHCOORD, WITHDIST or WITHHASH\");\n\n        if (opts->key) zend_string_release(opts->key);\n        return FAILURE;\n    }\n\n    /* Success */\n    return SUCCESS;\n}\n\n/* Helper to append options to a GEORADIUS or GEORADIUSBYMEMBER command */\nvoid append_georadius_opts(RedisSock *redis_sock, smart_string *str, short *slot,\n                           geoOptions *opt)\n{\n    if (opt->withcoord)\n        REDIS_CMD_APPEND_SSTR_STATIC(str, \"WITHCOORD\");\n    if (opt->withdist)\n        REDIS_CMD_APPEND_SSTR_STATIC(str, \"WITHDIST\");\n    if (opt->withhash)\n        REDIS_CMD_APPEND_SSTR_STATIC(str, \"WITHHASH\");\n\n    /* Append sort if it's not GEO_NONE */\n    if (opt->sort == SORT_ASC) {\n        REDIS_CMD_APPEND_SSTR_STATIC(str, \"ASC\");\n    } else if (opt->sort == SORT_DESC) {\n        REDIS_CMD_APPEND_SSTR_STATIC(str, \"DESC\");\n    }\n\n    /* Append our count if we've got one */\n    if (opt->count) {\n        REDIS_CMD_APPEND_SSTR_STATIC(str, \"COUNT\");\n        redis_cmd_append_sstr_long(str, opt->count);\n        if (opt->any) {\n            REDIS_CMD_APPEND_SSTR_STATIC(str, \"ANY\");\n        }\n    }\n\n    /* Append store options if we've got them */\n    if (opt->store != STORE_NONE && opt->key != NULL) {\n        if (opt->store == STORE_COORD) {\n            REDIS_CMD_APPEND_SSTR_STATIC(str, \"STORE\");\n        } else {\n            REDIS_CMD_APPEND_SSTR_STATIC(str, \"STOREDIST\");\n        }\n\n        redis_cmd_append_sstr_key_zstr(str, opt->key, redis_sock, slot);\n    }\n}\n\n/* GEORADIUS / GEORADIUS_RO */\nint redis_georadius_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                        char *kw, char **cmd, int *cmd_len, short *slot,\n                        void **ctx)\n{\n    zend_string *key = NULL, *unit = NULL;\n    double lng = 0, lat = 0, radius = 0;\n    smart_string cmdstr = {0};\n    HashTable *opts = NULL;\n    geoOptions gopts = {0};\n    short store_slot = -1;\n    uint32_t argc;\n\n    ZEND_PARSE_PARAMETERS_START(5, 6)\n        Z_PARAM_STR(key)\n        Z_PARAM_DOUBLE(lng)\n        Z_PARAM_DOUBLE(lat)\n        Z_PARAM_DOUBLE(radius)\n        Z_PARAM_STR(unit)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_ARRAY_HT_OR_NULL(opts)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    /* Parse any GEORADIUS options we have */\n    if (opts != NULL && get_georadius_opts(opts, &gopts) != SUCCESS)\n        return FAILURE;\n\n    /* Increment argc depending on options */\n    argc = 5 + gopts.withcoord + gopts.withdist + gopts.withhash +\n               (gopts.sort != SORT_NONE) + (gopts.count ? 2 + gopts.any : 0) +\n               (gopts.store != STORE_NONE ? 2 : 0);\n\n    /* Begin construction of our command */\n    redis_cmd_init_sstr(&cmdstr, argc, kw, strlen(kw));\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n\n    /* Append required arguments */\n    redis_cmd_append_sstr_dbl(&cmdstr, lng);\n    redis_cmd_append_sstr_dbl(&cmdstr, lat);\n    redis_cmd_append_sstr_dbl(&cmdstr, radius);\n    redis_cmd_append_sstr_zstr(&cmdstr, unit);\n\n    /* Append optional arguments */\n    append_georadius_opts(redis_sock, &cmdstr, slot ? &store_slot : NULL, &gopts);\n\n    /* Free key if it was prefixed */\n    if (gopts.key) zend_string_release(gopts.key);\n\n    /* Protect the user from CROSSSLOT if we're in cluster */\n    if (slot && gopts.store != STORE_NONE && *slot != store_slot) {\n        php_error_docref(NULL, E_WARNING,\n            \"Key and STORE[DIST] key must hash to the same slot\");\n        efree(cmdstr.c);\n        return FAILURE;\n    }\n\n    /* Set slot, command and len, and return */\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* GEORADIUSBYMEMBER/GEORADIUSBYMEMBER_RO\n *    key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] */\nint redis_georadiusbymember_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                                char *kw, char **cmd, int *cmd_len, short *slot,\n                                void **ctx)\n{\n    char *key, *mem, *unit;\n    size_t keylen, memlen, unitlen;\n    short store_slot = 0;\n    int keyfree, argc = 4;\n    double radius;\n    geoOptions gopts = {0};\n    zval *opts = NULL;\n    smart_string cmdstr = {0};\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"ssds|a\", &key, &keylen,\n                              &mem, &memlen, &radius, &unit, &unitlen, &opts) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    if (opts != NULL) {\n        /* Attempt to parse our options array */\n        if (get_georadius_opts(Z_ARRVAL_P(opts), &gopts) == FAILURE) {\n            return FAILURE;\n        }\n    }\n\n    /* Increment argc based on options */\n    argc += gopts.withcoord + gopts.withdist + gopts.withhash +\n            (gopts.sort != SORT_NONE) + (gopts.count ? 2 + gopts.any : 0) +\n            (gopts.store != STORE_NONE ? 2 : 0);\n\n    /* Begin command construction*/\n    redis_cmd_init_sstr(&cmdstr, argc, kw, strlen(kw));\n\n    /* Prefix our key if we're prefixing and set the slot */\n    keyfree = redis_key_prefix(redis_sock, &key, &keylen);\n    CMD_SET_SLOT(slot, key, keylen);\n\n    /* Append required arguments */\n    redis_cmd_append_sstr(&cmdstr, key, keylen);\n    redis_cmd_append_sstr(&cmdstr, mem, memlen);\n    redis_cmd_append_sstr_long(&cmdstr, radius);\n    redis_cmd_append_sstr(&cmdstr, unit, unitlen);\n\n    /* Append options */\n    append_georadius_opts(redis_sock, &cmdstr, slot ? &store_slot : NULL, &gopts);\n\n    /* Free key if we prefixed */\n    if (keyfree) efree(key);\n    if (gopts.key) zend_string_release(gopts.key);\n\n    /* Protect the user from CROSSSLOT if we're in cluster */\n    if (slot && gopts.store != STORE_NONE && *slot != store_slot) {\n        php_error_docref(NULL, E_WARNING,\n            \"Key and STORE[DIST] key must hash to the same slot\");\n        efree(cmdstr.c);\n        return FAILURE;\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nint\nredis_geosearch_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                    char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    char *key, *unit;\n    int argc = 2;\n    size_t keylen, unitlen;\n    geoOptions gopts = {0};\n    smart_string cmdstr = {0};\n    zval *position, *shape, *opts = NULL, *z_ele;\n    zend_string *zkey, *zstr;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"szzs|a\",\n                              &key, &keylen, &position, &shape,\n                              &unit, &unitlen, &opts) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    if (Z_TYPE_P(position) == IS_STRING && Z_STRLEN_P(position) > 0) {\n        argc += 2;\n    } else if (Z_TYPE_P(position) == IS_ARRAY && zend_hash_num_elements(Z_ARRVAL_P(position)) == 2) {\n        argc += 3;\n    } else {\n        php_error_docref(NULL, E_WARNING, \"Invalid position\");\n        return FAILURE;\n    }\n\n    if (Z_TYPE_P(shape) == IS_LONG || Z_TYPE_P(shape) == IS_DOUBLE) {\n        argc += 2;\n    } else if (Z_TYPE_P(shape) == IS_ARRAY) {\n        argc += 3;\n    } else {\n        php_error_docref(NULL, E_WARNING, \"Invalid shape dimensions\");\n        return FAILURE;\n    }\n\n    /* Attempt to parse our options array */\n    if (opts != NULL) {\n        ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARRVAL_P(opts), zkey, z_ele) {\n            ZVAL_DEREF(z_ele);\n            if (zkey != NULL && zend_string_equals_literal_ci(zkey, \"COUNT\")) {\n                if (get_georadius_count_options(z_ele, &gopts) == FAILURE) {\n                    return FAILURE;\n                }\n            } else if (Z_TYPE_P(z_ele) == IS_STRING) {\n                zstr = Z_STR_P(z_ele);\n                if (zend_string_equals_literal_ci(zstr, \"WITHCOORD\")) {\n                    gopts.withcoord = 1;\n                } else if (zend_string_equals_literal_ci(zstr, \"WITHDIST\")) {\n                    gopts.withdist = 1;\n                } else if (zend_string_equals_literal_ci(zstr, \"WITHHASH\")) {\n                    gopts.withhash = 1;\n                } else if (zend_string_equals_literal_ci(zstr, \"ASC\")) {\n                    gopts.sort = SORT_ASC;\n                } else if (zend_string_equals_literal_ci(zstr, \"DESC\")) {\n                    gopts.sort = SORT_DESC;\n                }\n            }\n        } ZEND_HASH_FOREACH_END();\n    }\n\n    /* Increment argc based on options */\n    argc += gopts.withcoord + gopts.withdist + gopts.withhash\n         + (gopts.sort != SORT_NONE) + (gopts.count ? 2 + gopts.any : 0);\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc, \"GEOSEARCH\");\n    redis_cmd_append_sstr_key(&cmdstr, key, keylen, redis_sock, slot);\n\n    if (Z_TYPE_P(position) == IS_ARRAY) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"FROMLONLAT\");\n        ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(position), z_ele) {\n            ZVAL_DEREF(z_ele);\n            redis_cmd_append_sstr_dbl(&cmdstr, zval_get_double(z_ele));\n        } ZEND_HASH_FOREACH_END();\n    } else {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"FROMMEMBER\");\n        redis_cmd_append_sstr(&cmdstr, Z_STRVAL_P(position), Z_STRLEN_P(position));\n    }\n\n    if (Z_TYPE_P(shape) == IS_ARRAY) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"BYBOX\");\n        ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(shape), z_ele) {\n            ZVAL_DEREF(z_ele);\n            redis_cmd_append_sstr_dbl(&cmdstr, zval_get_double(z_ele));\n        } ZEND_HASH_FOREACH_END();\n    } else {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"BYRADIUS\");\n        redis_cmd_append_sstr_dbl(&cmdstr, zval_get_double(shape));\n    }\n    redis_cmd_append_sstr(&cmdstr, unit, unitlen);\n\n    /* Append optional arguments */\n    if (gopts.withcoord) REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"WITHCOORD\");\n    if (gopts.withdist) REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"WITHDIST\");\n    if (gopts.withhash) REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"WITHHASH\");\n\n    /* Append sort if it's not GEO_NONE */\n    if (gopts.sort == SORT_ASC) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"ASC\");\n    } else if (gopts.sort == SORT_DESC) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"DESC\");\n    }\n\n    /* Append our count if we've got one */\n    if (gopts.count) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"COUNT\");\n        redis_cmd_append_sstr_long(&cmdstr, gopts.count);\n        if (gopts.any) {\n            REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"ANY\");\n        }\n    }\n\n    if ((argc = gopts.withcoord + gopts.withdist + gopts.withhash) > 0) {\n        *ctx = PHPREDIS_CTX_PTR;\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nint\nredis_geosearchstore_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                         char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    int argc = 3;\n    char *dest, *src, *unit;\n    size_t destlen, srclen, unitlen;\n    geoOptions gopts = {0};\n    smart_string cmdstr = {0};\n    zval *position, *shape, *opts = NULL, *z_ele;\n    zend_string *zkey;\n    short s2 = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sszzs|a\",\n                              &dest, &destlen, &src, &srclen, &position, &shape,\n                              &unit, &unitlen, &opts) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    if (Z_TYPE_P(position) == IS_STRING && Z_STRLEN_P(position) > 0) {\n        argc += 2;\n    } else if (Z_TYPE_P(position) == IS_ARRAY && zend_hash_num_elements(Z_ARRVAL_P(position)) == 2) {\n        argc += 3;\n    } else {\n        php_error_docref(NULL, E_WARNING, \"Invalid position\");\n        return FAILURE;\n    }\n\n    if (Z_TYPE_P(shape) == IS_LONG || Z_TYPE_P(shape) == IS_DOUBLE) {\n        argc += 2;\n    } else if (Z_TYPE_P(shape) == IS_ARRAY) {\n        argc += 3;\n    } else {\n        php_error_docref(NULL, E_WARNING, \"Invalid shape dimensions\");\n        return FAILURE;\n    }\n\n    /* Attempt to parse our options array */\n    if (opts != NULL) {\n        ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARRVAL_P(opts), zkey, z_ele) {\n            ZVAL_DEREF(z_ele);\n            if (zkey != NULL) {\n                if (zend_string_equals_literal_ci(zkey, \"COUNT\")) {\n                    if (Z_TYPE_P(z_ele) != IS_LONG || Z_LVAL_P(z_ele) <= 0) {\n                        php_error_docref(NULL, E_WARNING, \"COUNT must be an integer > 0!\");\n                        return FAILURE;\n                    }\n                    gopts.count = Z_LVAL_P(z_ele);\n                }\n            } else if (Z_TYPE_P(z_ele) == IS_STRING) {\n                if (!strcasecmp(Z_STRVAL_P(z_ele), \"ASC\")) {\n                    gopts.sort = SORT_ASC;\n                } else if (!strcasecmp(Z_STRVAL_P(z_ele), \"DESC\")) {\n                    gopts.sort = SORT_DESC;\n                } else if (!strcasecmp(Z_STRVAL_P(z_ele), \"STOREDIST\")) {\n                    gopts.store = STORE_DIST;\n                }\n            }\n        } ZEND_HASH_FOREACH_END();\n\n    }\n\n    /* Increment argc based on options */\n    argc += gopts.withcoord + gopts.withdist + gopts.withhash\n         + (gopts.sort != SORT_NONE) + (gopts.count ? 2 : 0)\n         + (gopts.store != STORE_NONE);\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc, \"GEOSEARCHSTORE\");\n    redis_cmd_append_sstr_key(&cmdstr, dest, destlen, redis_sock, slot);\n    redis_cmd_append_sstr_key(&cmdstr, src, srclen, redis_sock, slot ? &s2 : NULL);\n\n    if (slot && *slot != s2) {\n        php_error_docref(NULL, E_WARNING, \"All keys must hash to the same slot\");\n        efree(cmdstr.c);\n        return FAILURE;\n    }\n\n    if (Z_TYPE_P(position) == IS_ARRAY) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"FROMLONLAT\");\n        ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(position), z_ele) {\n            ZVAL_DEREF(z_ele);\n            redis_cmd_append_sstr_dbl(&cmdstr, zval_get_double(z_ele));\n        } ZEND_HASH_FOREACH_END();\n    } else {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"FROMMEMBER\");\n        redis_cmd_append_sstr(&cmdstr, Z_STRVAL_P(position), Z_STRLEN_P(position));\n    }\n\n    if (Z_TYPE_P(shape) == IS_ARRAY) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"BYBOX\");\n        ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(shape), z_ele) {\n            ZVAL_DEREF(z_ele);\n            redis_cmd_append_sstr_dbl(&cmdstr, zval_get_double(z_ele));\n        } ZEND_HASH_FOREACH_END();\n    } else {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"BYRADIUS\");\n        redis_cmd_append_sstr_dbl(&cmdstr, zval_get_double(shape));\n    }\n    redis_cmd_append_sstr(&cmdstr, unit, unitlen);\n\n    /* Append sort if it's not GEO_NONE */\n    if (gopts.sort == SORT_ASC) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"ASC\");\n    } else if (gopts.sort == SORT_DESC) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"DESC\");\n    }\n\n    /* Append our count if we've got one */\n    if (gopts.count) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"COUNT\");\n        redis_cmd_append_sstr_long(&cmdstr, gopts.count);\n    }\n\n    if (gopts.store == STORE_DIST) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"STOREDIST\");\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/*  MIGRATE host port <key | \"\"> destination-db timeout [COPY] [REPLACE]\n            [[AUTH password] | [AUTH2 username password]] [KEYS key [key ...]]\n\n    Starting with Redis version 3.0.0: Added the COPY and REPLACE options.\n    Starting with Redis version 3.0.6: Added the KEYS option.\n    Starting with Redis version 4.0.7: Added the AUTH option.\n    Starting with Redis version 6.0.0: Added the AUTH2 option.\n*/\n\n/* MIGRATE */\nint redis_migrate_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *host = NULL, *key = NULL, *user = NULL, *pass = NULL;\n    zend_long destdb = 0, port = 0, timeout = 0;\n    zval *zkeys = NULL, *zkey, *zauth = NULL;\n    zend_bool copy = 0, replace = 0;\n    smart_string cmdstr = {0};\n    int argc;\n\n    ZEND_PARSE_PARAMETERS_START(5, 8)\n        Z_PARAM_STR(host)\n        Z_PARAM_LONG(port)\n        Z_PARAM_ZVAL(zkeys)\n        Z_PARAM_LONG(destdb)\n        Z_PARAM_LONG(timeout)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_BOOL(copy)\n        Z_PARAM_BOOL(replace)\n        Z_PARAM_ZVAL_OR_NULL(zauth)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    /* Sanity check on our optional AUTH argument */\n    if (zauth && redis_extract_auth_info(zauth, &user, &pass) == FAILURE) {\n        php_error_docref(NULL, E_WARNING, \"AUTH must be a string or an array with one or two strings\");\n        user = pass = NULL;\n    }\n\n    /* Protect against being passed an array with zero elements */\n    if (Z_TYPE_P(zkeys) == IS_ARRAY && zend_hash_num_elements(Z_ARRVAL_P(zkeys)) == 0) {\n        php_error_docref(NULL, E_WARNING, \"Keys array cannot be empty\");\n        return FAILURE;\n    }\n\n    /* host, port, key|\"\", dest-db, timeout, [copy, replace] [KEYS key1..keyN] */\n    argc = 5 + copy + replace + (user||pass ? 1 : 0) + (user != NULL) + (pass != NULL);\n    if (Z_TYPE_P(zkeys) == IS_ARRAY) {\n        /* +1 for the \"KEYS\" argument itself */\n        argc += 1 + zend_hash_num_elements(Z_ARRVAL_P(zkeys));\n    }\n\n    /* Initialize MIGRATE command with host and port */\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc, \"MIGRATE\");\n    redis_cmd_append_sstr_zstr(&cmdstr, host);\n    redis_cmd_append_sstr_long(&cmdstr, port);\n\n    /* If passed a keys array the keys come later, otherwise pass the key to\n     * migrate here */\n    if (Z_TYPE_P(zkeys) == IS_ARRAY) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"\");\n    } else {\n        key = redis_key_prefix_zval(redis_sock, zkeys);\n        redis_cmd_append_sstr_zstr(&cmdstr, key);\n        zend_string_release(key);\n    }\n\n    redis_cmd_append_sstr_long(&cmdstr, destdb);\n    redis_cmd_append_sstr_long(&cmdstr, timeout);\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, copy, \"COPY\");\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, replace, \"REPLACE\");\n\n    if (user && pass) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"AUTH2\");\n        redis_cmd_append_sstr_zstr(&cmdstr, user);\n        redis_cmd_append_sstr_zstr(&cmdstr, pass);\n    } else if (pass) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"AUTH\");\n        redis_cmd_append_sstr_zstr(&cmdstr, pass);\n    }\n\n    /* Append actual keys if we've got a keys array */\n    if (Z_TYPE_P(zkeys) == IS_ARRAY) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"KEYS\");\n\n        ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(zkeys), zkey) {\n            key = redis_key_prefix_zval(redis_sock, zkey);\n            redis_cmd_append_sstr_zstr(&cmdstr, key);\n            zend_string_release(key);\n        } ZEND_HASH_FOREACH_END();\n    }\n\n    if (user) zend_string_release(user);\n    if (pass) zend_string_release(pass);\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\n/* A generic passthru function for variadic key commands that take one or more\n * keys.  This is essentially all of them except ones that STORE data. */\nint redis_varkey_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char *kw, char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    return gen_varkey_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock,\n                          kw, strlen(kw), 0, cmd, cmd_len, slot);\n}\n\nstatic int\nredis_build_client_list_command(smart_string *cmdstr, int argc, zval *z_args)\n{\n    zend_string *zkey;\n    zval *z_ele, *type = NULL, *id = NULL;\n\n    if (argc > 0) {\n        if (Z_TYPE(z_args[0]) != IS_ARRAY) {\n            return FAILURE;\n        }\n        ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARRVAL(z_args[0]), zkey, z_ele) {\n            if (zkey != NULL) {\n                ZVAL_DEREF(z_ele);\n                if (zend_string_equals_literal_ci(zkey, \"type\")) {\n                    if (Z_TYPE_P(z_ele) != IS_STRING || (\n                        !ZVAL_STRICMP_STATIC(z_ele, \"normal\") &&\n                        !ZVAL_STRICMP_STATIC(z_ele, \"master\") &&\n                        !ZVAL_STRICMP_STATIC(z_ele, \"replica\") &&\n                        !ZVAL_STRICMP_STATIC(z_ele, \"pubsub\")\n                    )) {\n                        return FAILURE;\n                    }\n                    type = z_ele;\n                } else if (zend_string_equals_literal_ci(zkey, \"id\")) {\n                    if (Z_TYPE_P(z_ele) != IS_STRING && (\n                        Z_TYPE_P(z_ele) != IS_ARRAY ||\n                        !zend_hash_num_elements(Z_ARRVAL_P(z_ele))\n                    )) {\n                        return FAILURE;\n                    }\n                    id = z_ele;\n                }\n            }\n        } ZEND_HASH_FOREACH_END();\n    }\n    REDIS_CMD_INIT_SSTR_STATIC(cmdstr, 1 + (type ? 2 : 0) + (\n        id ? (Z_TYPE_P(id) == IS_ARRAY ? 1 + zend_hash_num_elements(Z_ARRVAL_P(id)) : 2) : 0\n    ), \"CLIENT\");\n    REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"LIST\");\n    if (type != NULL) {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"TYPE\");\n        redis_cmd_append_sstr(cmdstr, Z_STRVAL_P(type), Z_STRLEN_P(type));\n    }\n    if (id != NULL) {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"ID\");\n        if (Z_TYPE_P(id) == IS_ARRAY) {\n            ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(id), z_ele) {\n                if (Z_TYPE_P(z_ele) == IS_STRING) {\n                    redis_cmd_append_sstr(cmdstr, Z_STRVAL_P(z_ele), Z_STRLEN_P(z_ele));\n                } else {\n                    zkey = zval_get_string(z_ele);\n                    redis_cmd_append_sstr(cmdstr, ZSTR_VAL(zkey), ZSTR_LEN(zkey));\n                    zend_string_release(zkey);\n                }\n            } ZEND_HASH_FOREACH_END();\n        } else {\n            redis_cmd_append_sstr(cmdstr, Z_STRVAL_P(id), Z_STRLEN_P(id));\n        }\n    }\n    return SUCCESS;\n}\n\nstatic int\nredis_build_client_kill_command(smart_string *cmdstr, int argc, zval *z_args)\n{\n    zend_string *zkey;\n    zval *z_ele, *id = NULL, *type = NULL, *address = NULL, *opts = NULL,\n        *user = NULL, *addr = NULL, *laddr = NULL, *skipme = NULL;\n\n    if (argc > 0) {\n        if (argc > 1) {\n            if (Z_TYPE(z_args[0]) != IS_STRING || Z_TYPE(z_args[1]) != IS_ARRAY) {\n                return FAILURE;\n            }\n            address = &z_args[0];\n            opts = &z_args[1];\n        } else if (Z_TYPE(z_args[0]) == IS_STRING) {\n            address = &z_args[0];\n        } else if (Z_TYPE(z_args[0]) == IS_ARRAY) {\n            opts = &z_args[0];\n        } else {\n            return FAILURE;\n        }\n        if (opts != NULL) {\n            ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARRVAL_P(opts), zkey, z_ele) {\n                if (zkey != NULL) {\n                    ZVAL_DEREF(z_ele);\n                    if (Z_TYPE_P(z_ele) != IS_STRING) {\n                        return FAILURE;\n                    }\n                    if (zend_string_equals_literal_ci(zkey, \"id\")) {\n                        id = z_ele;\n                    } else if (zend_string_equals_literal_ci(zkey, \"type\")) {\n                        if (!ZVAL_STRICMP_STATIC(z_ele, \"normal\") &&\n                            !ZVAL_STRICMP_STATIC(z_ele, \"master\") &&\n                            !ZVAL_STRICMP_STATIC(z_ele, \"slave\") &&\n                            !ZVAL_STRICMP_STATIC(z_ele, \"replica\") &&\n                            !ZVAL_STRICMP_STATIC(z_ele, \"pubsub\")\n                        ) {\n                            return FAILURE;\n                        }\n                        type = z_ele;\n                    } else if (zend_string_equals_literal_ci(zkey, \"user\")) {\n                        user = z_ele;\n                    } else if (zend_string_equals_literal_ci(zkey, \"addr\")) {\n                        addr = z_ele;\n                    } else if (zend_string_equals_literal_ci(zkey, \"laddr\")) {\n                        laddr = z_ele;\n                    } else if (zend_string_equals_literal_ci(zkey, \"skipme\")) {\n                        if (!ZVAL_STRICMP_STATIC(z_ele, \"yes\") &&\n                            !ZVAL_STRICMP_STATIC(z_ele, \"no\")\n                        ) {\n                            return FAILURE;\n                        }\n                        skipme = z_ele;\n                    }\n                }\n            } ZEND_HASH_FOREACH_END();\n        }\n    }\n    REDIS_CMD_INIT_SSTR_STATIC(cmdstr, 1 + (address != 0) + (id ? 2 : 0)\n        + (type ? 2 : 0) + (user ? 2 : 0) + (addr ? 2 : 0) + (laddr ? 2 : 0)\n        + (skipme ? 2 : 0), \"CLIENT\");\n    REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"KILL\");\n    if (address != NULL) {\n        redis_cmd_append_sstr(cmdstr, Z_STRVAL_P(address), Z_STRLEN_P(address));\n    }\n    if (id != NULL) {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"ID\");\n        redis_cmd_append_sstr(cmdstr, Z_STRVAL_P(id), Z_STRLEN_P(id));\n    }\n    if (type != NULL) {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"TYPE\");\n        redis_cmd_append_sstr(cmdstr, Z_STRVAL_P(type), Z_STRLEN_P(type));\n    }\n    if (user != NULL) {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"USER\");\n        redis_cmd_append_sstr(cmdstr, Z_STRVAL_P(user), Z_STRLEN_P(user));\n    }\n    if (addr != NULL) {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"ADDR\");\n        redis_cmd_append_sstr(cmdstr, Z_STRVAL_P(addr), Z_STRLEN_P(addr));\n    }\n    if (laddr != NULL) {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"LADDR\");\n        redis_cmd_append_sstr(cmdstr, Z_STRVAL_P(laddr), Z_STRLEN_P(laddr));\n    }\n    if (skipme != NULL) {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"SKIPME\");\n        redis_cmd_append_sstr(cmdstr, Z_STRVAL_P(skipme), Z_STRLEN_P(skipme));\n    }\n    return SUCCESS;\n}\n\nstatic int\nredis_build_client_tracking_command(smart_string *cmdstr, int argc, zval *z_args)\n{\n    zend_string *zkey;\n    zval *z_ele, *redirect = NULL, *prefix = NULL;\n    zend_bool bcast = 0, optin = 0, optout = 0, noloop = 0;\n\n    if (argc < 1) {\n        return FAILURE;\n    }\n    if (argc > 1) {\n        if (Z_TYPE(z_args[1]) != IS_ARRAY) {\n            return FAILURE;\n        }\n        ZEND_HASH_FOREACH_STR_KEY_VAL(Z_ARRVAL(z_args[1]), zkey, z_ele) {\n            if (zkey != NULL) {\n                ZVAL_DEREF(z_ele);\n                if (zend_string_equals_literal_ci(zkey, \"redirect\")) {\n                    if (Z_TYPE_P(z_ele) != IS_STRING) {\n                        return FAILURE;\n                    }\n                    redirect = z_ele;\n                } else if (zend_string_equals_literal_ci(zkey, \"prefix\")) {\n                    if (Z_TYPE_P(z_ele) != IS_STRING && Z_TYPE_P(z_ele) != IS_ARRAY) {\n                        return FAILURE;\n                    }\n                    prefix = z_ele;\n                } else if (zend_string_equals_literal_ci(zkey, \"bcast\")) {\n                    bcast = zval_is_true(z_ele);\n                } else if (zend_string_equals_literal_ci(zkey, \"optin\")) {\n                    optin = zval_is_true(z_ele);\n                } else if (zend_string_equals_literal_ci(zkey, \"optout\")) {\n                    optout = zval_is_true(z_ele);\n                } else if (zend_string_equals_literal_ci(zkey, \"noloop\")) {\n                    noloop = zval_is_true(z_ele);\n                }\n            }\n        } ZEND_HASH_FOREACH_END();\n    }\n    REDIS_CMD_INIT_SSTR_STATIC(cmdstr, 2 + (redirect ? 2 : 0)\n        + (prefix ? 2 * zend_hash_num_elements(Z_ARRVAL_P(prefix)) : 0)\n        + bcast + optin + optout + noloop, \"CLIENT\");\n    REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"TRACKING\");\n    if (Z_TYPE(z_args[0]) == IS_STRING && (\n        ZVAL_STRICMP_STATIC(&z_args[0], \"on\") ||\n        ZVAL_STRICMP_STATIC(&z_args[0], \"off\")\n    )) {\n        redis_cmd_append_sstr(cmdstr, Z_STRVAL(z_args[0]), Z_STRLEN(z_args[0]));\n    } else if (zval_is_true(&z_args[0])) {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"ON\");\n    } else {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"OFF\");\n    }\n    if (redirect != NULL) {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"REDIRECT\");\n        redis_cmd_append_sstr(cmdstr, Z_STRVAL_P(redirect), Z_STRLEN_P(redirect));\n    }\n    if (prefix != NULL) {\n        if (Z_TYPE_P(prefix) == IS_ARRAY) {\n            ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(prefix), z_ele) {\n                REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"PREFIX\");\n                if (Z_TYPE_P(z_ele) == IS_STRING) {\n                    redis_cmd_append_sstr(cmdstr, Z_STRVAL_P(z_ele), Z_STRLEN_P(z_ele));\n                } else {\n                    zkey = zval_get_string(z_ele);\n                    redis_cmd_append_sstr(cmdstr, ZSTR_VAL(zkey), ZSTR_LEN(zkey));\n                    zend_string_release(zkey);\n                }\n            } ZEND_HASH_FOREACH_END();\n        } else {\n            REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"PREFIX\");\n            redis_cmd_append_sstr(cmdstr, Z_STRVAL_P(prefix), Z_STRLEN_P(prefix));\n        }\n    }\n    if (bcast) {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"BCAST\");\n    }\n    if (optin) {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"OPTIN\");\n    }\n    if (optout) {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"OPTOUT\");\n    }\n    if (noloop) {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"NOLOOP\");\n    }\n    return SUCCESS;\n}\n\nint\nredis_client_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                 char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    zend_string *op = NULL;\n    zval *z_args = NULL;\n    int argc = 0;\n\n    ZEND_PARSE_PARAMETERS_START(1, -1)\n        Z_PARAM_STR(op)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_VARIADIC('*', z_args, argc)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (zend_string_equals_literal_ci(op, \"INFO\")) {\n        REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1, \"CLIENT\");\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"INFO\");\n    } else if (zend_string_equals_literal_ci(op, \"LIST\")) {\n        if (redis_build_client_list_command(&cmdstr, argc, z_args) != 0) {\n            return FAILURE;\n        }\n        *ctx = PHPREDIS_CTX_PTR;\n    } else if (zend_string_equals_literal_ci(op, \"CACHING\")) {\n        if (argc < 1) {\n            return FAILURE;\n        }\n        REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 2, \"CLIENT\");\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"CACHING\");\n        if (Z_TYPE(z_args[0]) == IS_STRING && (\n            ZVAL_STRICMP_STATIC(&z_args[0], \"yes\") ||\n            ZVAL_STRICMP_STATIC(&z_args[0], \"no\")\n        )) {\n            redis_cmd_append_sstr(&cmdstr, Z_STRVAL(z_args[0]), Z_STRLEN(z_args[0]));\n        } else if (zval_is_true(&z_args[0])) {\n            REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"YES\");\n        } else {\n            REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"NO\");\n        }\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    } else if (zend_string_equals_literal_ci(op, \"GETNAME\")) {\n        REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1, \"CLIENT\");\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"GETNAME\");\n        *ctx = PHPREDIS_CTX_PTR + 3;\n    } else if (zend_string_equals_literal_ci(op, \"GETREDIR\") || zend_string_equals_literal_ci(op, \"ID\")) {\n        REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1, \"CLIENT\");\n        redis_cmd_append_sstr(&cmdstr, ZSTR_VAL(op), ZSTR_LEN(op));\n        *ctx = PHPREDIS_CTX_PTR + 2;\n    } else if (zend_string_equals_literal_ci(op, \"KILL\")) {\n        if (redis_build_client_kill_command(&cmdstr, argc, z_args) != 0) {\n            return FAILURE;\n        }\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    } else if (zend_string_equals_literal_ci(op, \"NO-EVICT\")) {\n        if (argc < 1) {\n            return FAILURE;\n        }\n        REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 2, \"CLIENT\");\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"NO-EVICT\");\n        if (Z_TYPE(z_args[0]) == IS_STRING && (\n            ZVAL_STRICMP_STATIC(&z_args[0], \"on\") ||\n            ZVAL_STRICMP_STATIC(&z_args[0], \"off\")\n        )) {\n            redis_cmd_append_sstr(&cmdstr, Z_STRVAL(z_args[0]), Z_STRLEN(z_args[0]));\n        } else if (zval_is_true(&z_args[0])) {\n            REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"ON\");\n        } else {\n            REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"OFF\");\n        }\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    } else if (zend_string_equals_literal_ci(op, \"PAUSE\")) {\n        if (argc < 1 || Z_TYPE(z_args[0]) != IS_LONG || (\n            argc > 1 && (\n                Z_TYPE(z_args[1]) != IS_STRING || (\n                    !ZVAL_STRICMP_STATIC(&z_args[1], \"write\") &&\n                    !ZVAL_STRICMP_STATIC(&z_args[1], \"all\")\n                )\n            )\n        )) {\n            return FAILURE;\n        }\n        REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc > 1 ? 3 : 2, \"CLIENT\");\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"PAUSE\");\n        redis_cmd_append_sstr_long(&cmdstr, Z_LVAL(z_args[0]));\n        if (argc > 1) {\n            redis_cmd_append_sstr(&cmdstr, Z_STRVAL(z_args[1]), Z_STRLEN(z_args[1]));\n        }\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    } else if (zend_string_equals_literal_ci(op, \"REPLY\")) {\n        if (argc > 0 && (\n            Z_TYPE(z_args[0]) != IS_STRING || (\n                !ZVAL_STRICMP_STATIC(&z_args[0], \"on\") &&\n                !ZVAL_STRICMP_STATIC(&z_args[0], \"off\") &&\n                !ZVAL_STRICMP_STATIC(&z_args[0], \"skip\")\n            )\n        )) {\n            return FAILURE;\n        }\n        REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc > 0 ? 2 : 1, \"CLIENT\");\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"REPLY\");\n        if (argc > 0) {\n            redis_cmd_append_sstr(&cmdstr, Z_STRVAL(z_args[0]), Z_STRLEN(z_args[0]));\n        }\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    } else if (zend_string_equals_literal_ci(op, \"SETNAME\")) {\n        if (argc < 1 || Z_TYPE(z_args[0]) != IS_STRING) {\n            return FAILURE;\n        }\n        REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 2, \"CLIENT\");\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"SETNAME\");\n        redis_cmd_append_sstr(&cmdstr, Z_STRVAL(z_args[0]), Z_STRLEN(z_args[0]));\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    } else if (zend_string_equals_literal_ci(op, \"TRACKING\")) {\n        if (redis_build_client_tracking_command(&cmdstr, argc, z_args) != 0) {\n            return FAILURE;\n        }\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    } else if (zend_string_equals_literal_ci(op, \"TRACKINGINFO\")) {\n        REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1, \"CLIENT\");\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"TRACKINGINFO\");\n        *ctx = PHPREDIS_CTX_PTR + 4;\n    } else if (zend_string_equals_literal_ci(op, \"UNBLOCK\")) {\n        if (argc < 1 || Z_TYPE(z_args[0]) != IS_STRING || (\n            argc > 1 && (\n                Z_TYPE(z_args[1]) != IS_STRING || (\n                    !ZVAL_STRICMP_STATIC(&z_args[1], \"timeout\") &&\n                    !ZVAL_STRICMP_STATIC(&z_args[1], \"error\")\n                )\n            )\n        )) {\n            return FAILURE;\n        }\n        REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc > 1 ? 3 : 2, \"CLIENT\");\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"UNBLOCK\");\n        redis_cmd_append_sstr(&cmdstr, Z_STRVAL(z_args[0]), Z_STRLEN(z_args[0]));\n        if (argc > 1) {\n            redis_cmd_append_sstr(&cmdstr, Z_STRVAL(z_args[1]), Z_STRLEN(z_args[1]));\n        }\n        *ctx = PHPREDIS_CTX_PTR + 2;\n    } else if (zend_string_equals_literal_ci(op, \"UNPAUSE\")) {\n        REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 2, \"CLIENT\");\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"UNPAUSE\");\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    } else {\n        return FAILURE;\n    }\n\n    // Push out values\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* COMMAND */\nint redis_command_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    zend_string *op = NULL, *zstr;\n    zval *z_args = NULL;\n    int i, argc = 0;\n\n    ZEND_PARSE_PARAMETERS_START(0, -1)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_STR(op)\n        Z_PARAM_VARIADIC('*', z_args, argc)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (op == NULL) {\n        *ctx = NULL;\n        argc = 0;\n    } else if (zend_string_equals_literal_ci(op, \"COUNT\")) {\n        *ctx = PHPREDIS_CTX_PTR;\n        argc = 0;\n    } else if (zend_string_equals_literal_ci(op, \"DOCS\") ||\n        zend_string_equals_literal_ci(op, \"INFO\")\n    ) {\n        *ctx = NULL;\n    } else if (zend_string_equals_literal_ci(op, \"GETKEYS\") ||\n        zend_string_equals_literal_ci(op, \"LIST\")\n    ) {\n        *ctx = PHPREDIS_CTX_PTR + 1;\n    } else if (zend_string_equals_literal_ci(op, \"GETKEYSANDFLAGS\")) {\n        *ctx = PHPREDIS_CTX_PTR + 2;\n    } else {\n        php_error_docref(NULL, E_WARNING, \"Unknown COMMAND operation '%s'\", ZSTR_VAL(op));\n        return FAILURE;\n    }\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, !!op + argc, \"COMMAND\");\n    if (op) redis_cmd_append_sstr_zstr(&cmdstr, op);\n\n    for (i = 0; i < argc; ++i) {\n        zstr = zval_get_string(&z_args[i]);\n        redis_cmd_append_sstr(&cmdstr, ZSTR_VAL(zstr), ZSTR_LEN(zstr));\n        zend_string_release(zstr);\n    }\n\n    // Push out values\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    /* Any slot will do */\n    CMD_RAND_SLOT(slot);\n\n    return SUCCESS;\n}\n\nint\nredis_copy_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n               char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *src = NULL, *dst = NULL;\n    smart_string cmdstr = {0};\n    HashTable *opts = NULL;\n    zend_bool replace = 0;\n    zend_string *zkey;\n    zend_long db = -1;\n    short slot2;\n    zval *zv;\n\n    ZEND_PARSE_PARAMETERS_START(2, 3)\n        Z_PARAM_STR(src)\n        Z_PARAM_STR(dst)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_ARRAY_HT_OR_NULL(opts)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (opts != NULL) {\n        ZEND_HASH_FOREACH_STR_KEY_VAL(opts, zkey, zv) {\n            if (zkey == NULL)\n                continue;\n\n            ZVAL_DEREF(zv);\n            if (zend_string_equals_literal_ci(zkey, \"db\")) {\n                db = zval_get_long(zv);\n            } else if (zend_string_equals_literal_ci(zkey, \"replace\")) {\n                replace = zval_is_true(zv);\n            }\n        } ZEND_HASH_FOREACH_END();\n    }\n\n    if (slot && db != -1) {\n        php_error_docref(NULL, E_WARNING, \"Can't copy to a specific DB in cluster mode\");\n        return FAILURE;\n    }\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 2 + (db > -1 ? 2 : 0) + replace, \"COPY\");\n    redis_cmd_append_sstr_key_zstr(&cmdstr, src, redis_sock, slot);\n    redis_cmd_append_sstr_key_zstr(&cmdstr, dst, redis_sock, slot ? &slot2 : NULL);\n\n    if (slot && *slot != slot2) {\n        php_error_docref(NULL, E_WARNING, \"Keys must hash to the same slot!\");\n        efree(cmdstr.c);\n        return FAILURE;\n    }\n\n    if (db > -1) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"DB\");\n        redis_cmd_append_sstr_long(&cmdstr, db);\n    }\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, replace, \"REPLACE\");\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\n/* XADD */\nint redis_xadd_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    zend_string *arrkey;\n    zval *z_fields, *value;\n    zend_long maxlen = 0;\n    zend_bool approx = 0, nomkstream = 0;\n    zend_ulong idx;\n    HashTable *ht_fields;\n    int fcount, argc;\n    char *key, *id;\n    size_t keylen, idlen;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"ssa|lbb\", &key, &keylen,\n                              &id, &idlen, &z_fields, &maxlen, &approx,\n                              &nomkstream) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    /* At least one field and string are required */\n    ht_fields = Z_ARRVAL_P(z_fields);\n    if ((fcount = zend_hash_num_elements(ht_fields)) == 0) {\n        return FAILURE;\n    }\n\n    if (maxlen < 0 || (maxlen == 0 && approx != 0)) {\n        php_error_docref(NULL, E_WARNING,\n            \"Warning:  Invalid MAXLEN argument or approximate flag\");\n    }\n\n\n    /* Calculate argc for XADD.  It's a bit complex because we've got\n     * an optional MAXLEN argument which can either take the form MAXLEN N\n     * or MAXLEN ~ N */\n    argc = 2 + nomkstream + (fcount * 2) + (maxlen > 0 ? (approx ? 3 : 2) : 0);\n\n    /* XADD key ID field string [field string ...] */\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc, \"XADD\");\n    redis_cmd_append_sstr_key(&cmdstr, key, keylen, redis_sock, slot);\n\n    if (nomkstream) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"NOMKSTREAM\");\n    }\n\n    /* Now append our MAXLEN bits if we've got them */\n    if (maxlen > 0) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"MAXLEN\");\n        REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, approx, \"~\");\n        redis_cmd_append_sstr_long(&cmdstr, maxlen);\n    }\n\n    /* Now append ID and field(s) */\n    redis_cmd_append_sstr(&cmdstr, id, idlen);\n    ZEND_HASH_FOREACH_KEY_VAL(ht_fields, idx, arrkey, value) {\n        redis_cmd_append_sstr_arrkey(&cmdstr, arrkey, idx);\n        redis_cmd_append_sstr_zval(&cmdstr, value, redis_sock);\n    } ZEND_HASH_FOREACH_END();\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\n// XPENDING key group [start end count [consumer] [idle]]\nint redis_xpending_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                       char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *key = NULL, *group = NULL, *start = NULL, *end = NULL,\n                *consumer = NULL;\n    zend_long count = -1, idle = 0;\n    smart_string cmdstr = {0};\n    int argc;\n\n    ZEND_PARSE_PARAMETERS_START(2, 7)\n        Z_PARAM_STR(key)\n        Z_PARAM_STR(group)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_STR_OR_NULL(start)\n        Z_PARAM_STR_OR_NULL(end)\n        Z_PARAM_LONG(count)\n        Z_PARAM_STR_OR_NULL(consumer)\n        Z_PARAM_LONG(idle)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    /* If we've been passed a start argument, we also need end and count */\n    if (start != NULL && (end == NULL || count < 0)) {\n        php_error_docref(NULL, E_WARNING, \"'$start' must be accompanied by '$end' and '$count' arguments\");\n        return FAILURE;\n    }\n\n    /* Calculate argc.  It's either 2, 5, 6 or 7 */\n    argc = 2 + (start != NULL ? 3 + (consumer != NULL) + (idle != 0) : 0);\n\n    /* Construct command and add required arguments */\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc, \"XPENDING\");\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n    redis_cmd_append_sstr_zstr(&cmdstr, group);\n\n    /* Add optional argumentst */\n    if (start) {\n        if (idle != 0) {\n            REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"IDLE\");\n            redis_cmd_append_sstr_long(&cmdstr, (long)idle);\n        }\n        redis_cmd_append_sstr_zstr(&cmdstr, start);\n        redis_cmd_append_sstr_zstr(&cmdstr, end);\n        redis_cmd_append_sstr_long(&cmdstr, (long)count);\n\n        /* Finally add consumer if we have it */\n        if (consumer) redis_cmd_append_sstr_zstr(&cmdstr, consumer);\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\n/* X[REV]RANGE key start end [COUNT count] */\nint redis_xrange_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char *kw, char **cmd, int *cmd_len, short *slot,\n                     void **ctx)\n{\n    smart_string cmdstr = {0};\n    char *key, *start, *end;\n    size_t keylen, startlen, endlen;\n    zend_long count = -1;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sss|l\", &key, &keylen,\n                              &start, &startlen, &end, &endlen, &count)\n                              == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    redis_cmd_init_sstr(&cmdstr, 3 + (2 * (count > -1)), kw, strlen(kw));\n    redis_cmd_append_sstr_key(&cmdstr, key, keylen, redis_sock, slot);\n    redis_cmd_append_sstr(&cmdstr, start, startlen);\n    redis_cmd_append_sstr(&cmdstr, end, endlen);\n\n    if (count > -1) {\n        redis_cmd_append_sstr(&cmdstr, ZEND_STRL(\"COUNT\"));\n        redis_cmd_append_sstr_long(&cmdstr, count);\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\n/* Helper function to take an associative array and append the Redis\n * STREAMS stream [stream...] id [id ...] arguments to a command string. */\nstatic int\nappend_stream_args(smart_string *cmdstr, HashTable *ht, RedisSock *redis_sock,\n                   short *slot)\n{\n    char *kptr, kbuf[40];\n    int klen, i, pos = 0;\n    zend_string *key, *idstr;\n    short oldslot = -1;\n    zval **id;\n    zend_ulong idx;\n\n    /* Append STREAM qualifier */\n    REDIS_CMD_APPEND_SSTR_STATIC(cmdstr, \"STREAMS\");\n\n    /* Allocate memory to keep IDs */\n    id = emalloc(sizeof(*id) * zend_hash_num_elements(ht));\n\n    /* Iterate over our stream => id array appending streams and retaining each\n     * value for final arguments */\n    ZEND_HASH_FOREACH_KEY_VAL(ht, idx, key, id[pos++]) {\n        if (key) {\n            klen = ZSTR_LEN(key);\n            kptr = ZSTR_VAL(key);\n        } else {\n            klen = snprintf(kbuf, sizeof(kbuf), \"%ld\", (long)idx);\n            kptr = (char*)kbuf;\n        }\n\n        /* Append stream key */\n        redis_cmd_append_sstr_key(cmdstr, kptr, klen, redis_sock, slot);\n\n        /* Protect the user against CROSSSLOT to avoid confusion */\n        if (slot) {\n            if (oldslot != -1 && *slot != oldslot) {\n                php_error_docref(NULL, E_WARNING,\n                    \"Warning, not all keys hash to the same slot!\");\n                efree(id);\n                return FAILURE;\n            }\n            oldslot = *slot;\n        }\n    } ZEND_HASH_FOREACH_END();\n\n    /* Add our IDs */\n    for (i = 0; i < pos; i++) {\n        idstr = zval_get_string(id[i]);\n        redis_cmd_append_sstr(cmdstr, ZSTR_VAL(idstr), ZSTR_LEN(idstr));\n        zend_string_release(idstr);\n    }\n\n    /* Clean up ID container array */\n    efree(id);\n\n    return 0;\n}\n\n/* XREAD [COUNT count] [BLOCK ms] STREAMS key [key ...] id [id ...] */\nint redis_xread_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                    char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    zend_long count = -1, block = -1;\n    zval *z_streams;\n    int argc, scount;\n    HashTable *kt;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"a|ll\", &z_streams,\n                              &count, &block) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    /* At least one stream and ID is required */\n    kt = Z_ARRVAL_P(z_streams);\n    if ((scount = zend_hash_num_elements(kt)) < 1) {\n        return FAILURE;\n    }\n\n    /* Calculate argc and start constructing command */\n    argc = 1 + (2 * scount) + (2 * (count > -1)) + (2 * (block > -1));\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc, \"XREAD\");\n\n    /* Append COUNT if we have it */\n    if (count > -1) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"COUNT\");\n        redis_cmd_append_sstr_long(&cmdstr, count);\n    }\n\n    /* Append BLOCK if we have it */\n    if (block > -1) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"BLOCK\");\n        redis_cmd_append_sstr_long(&cmdstr, block);\n    }\n\n    /* Append final STREAM key [key ...] id [id ...] arguments */\n    if (append_stream_args(&cmdstr, kt, redis_sock, slot) < 0) {\n        efree(cmdstr.c);\n        return FAILURE;\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\n/* XREADGROUP GROUP group consumer [COUNT count] [BLOCK ms]\n * STREAMS key [key ...] id [id ...] */\nint redis_xreadgroup_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                         char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    zval *z_streams;\n    HashTable *kt;\n    char *group, *consumer;\n    size_t grouplen, consumerlen;\n    int scount, argc;\n    zend_long count, block;\n    zend_bool no_count = 1, no_block = 1;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"ssa|l!l!\", &group,\n                              &grouplen, &consumer, &consumerlen, &z_streams,\n                              &count, &no_count, &block, &no_block) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    /* Negative COUNT or BLOCK is illegal so abort immediately */\n    if ((!no_count && count < 0) || (!no_block && block < 0)) {\n        php_error_docref(NULL, E_WARNING, \"Negative values for COUNT or BLOCK are illegal.\");\n        return FAILURE;\n    }\n\n    /* Redis requires at least one stream */\n    kt = Z_ARRVAL_P(z_streams);\n    if ((scount = zend_hash_num_elements(kt)) < 1) {\n        return FAILURE;\n    }\n\n    /* Calculate argc and start constructing commands */\n    argc = 4 + (2 * scount) + (2 * !no_count) + (2 * !no_block);\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc, \"XREADGROUP\");\n\n    /* Group and consumer */\n    REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"GROUP\");\n    redis_cmd_append_sstr(&cmdstr, group, grouplen);\n    redis_cmd_append_sstr(&cmdstr, consumer, consumerlen);\n\n    /* Append COUNT if we have it */\n    if (!no_count) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"COUNT\");\n        redis_cmd_append_sstr_long(&cmdstr, count);\n    }\n\n    /* Append BLOCK argument if we have it */\n    if (!no_block) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"BLOCK\");\n        redis_cmd_append_sstr_long(&cmdstr, block);\n    }\n\n    /* Finally append stream and id args */\n    if (append_stream_args(&cmdstr, kt, redis_sock, slot) < 0) {\n        efree(cmdstr.c);\n        return FAILURE;\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\n/* XACK key group id [id ...] */\nint redis_xack_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                   char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    char *key, *group;\n    size_t keylen, grouplen;\n    zend_string *idstr;\n    zval *z_ids, *z_id;\n    HashTable *ht_ids;\n    int idcount;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"ssa\", &key, &keylen,\n                              &group, &grouplen, &z_ids) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    ht_ids = Z_ARRVAL_P(z_ids);\n    if ((idcount = zend_hash_num_elements(ht_ids)) < 1) {\n        return FAILURE;\n    }\n\n    /* Create command and add initial arguments */\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 2 + idcount, \"XACK\");\n    redis_cmd_append_sstr_key(&cmdstr, key, keylen, redis_sock, slot);\n    redis_cmd_append_sstr(&cmdstr, group, grouplen);\n\n    /* Append IDs */\n    ZEND_HASH_FOREACH_VAL(ht_ids, z_id) {\n        idstr = zval_get_string(z_id);\n        redis_cmd_append_sstr(&cmdstr, ZSTR_VAL(idstr), ZSTR_LEN(idstr));\n        zend_string_release(idstr);\n    } ZEND_HASH_FOREACH_END();\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\n/* XCLAIM options container */\ntypedef struct xclaimOptions {\n    struct {\n        char *type;\n        int64_t time;\n    } idle;\n    zend_long retrycount;\n    int force;\n    int justid;\n} xclaimOptions;\n\n/* Attempt to extract an int64_t from the provided zval */\nstatic int zval_get_i64(zval *zv, int64_t *retval) {\n    if (Z_TYPE_P(zv) == IS_LONG) {\n        *retval = (int64_t)Z_LVAL_P(zv);\n        return SUCCESS;\n    } else if (Z_TYPE_P(zv) == IS_DOUBLE) {\n        *retval = (int64_t)Z_DVAL_P(zv);\n        return SUCCESS;\n    } else if (Z_TYPE_P(zv) == IS_STRING) {\n        zend_long lval;\n        double dval;\n\n        switch (is_numeric_string(Z_STRVAL_P(zv), Z_STRLEN_P(zv), &lval, &dval, 1)) {\n            case IS_LONG:\n                *retval = (int64_t)lval;\n                return SUCCESS;\n            case IS_DOUBLE:\n                *retval = (int64_t)dval;\n                return SUCCESS;\n        }\n    }\n\n    /* If we make it here we have failed */\n    return FAILURE;\n}\n\n/* Helper function to get an integer XCLAIM argument.  This can overflow a\n * 32-bit PHP long so we have to extract it as an int64_t.  If the value is\n * not a valid number or negative, we'll inform the user of the problem and\n * that the argument is being ignored. */\nstatic int64_t get_xclaim_i64_arg(const char *key, zval *zv) {\n    int64_t retval = -1;\n\n    /* Extract an i64, and if we can't let the user know there is an issue. */\n    if (zval_get_i64(zv, &retval) == FAILURE || retval < 0) {\n        php_error_docref(NULL, E_WARNING,\n            \"Invalid XCLAIM option '%s' will be ignored\", key);\n    }\n\n    return retval;\n}\n\n/* Helper to extract XCLAIM options */\nstatic void get_xclaim_options(zval *z_arr, xclaimOptions *opt) {\n    zend_string *zkey;\n    HashTable *ht;\n    zval *zv;\n\n    /* Initialize options array to sane defaults */\n    memset(opt, 0, sizeof(*opt));\n    opt->retrycount = -1;\n    opt->idle.time = -1;\n\n    /* Early return if we don't have any options */\n    if (z_arr == NULL)\n        return;\n\n    /* Iterate over our options array */\n    ht = Z_ARRVAL_P(z_arr);\n    ZEND_HASH_FOREACH_STR_KEY_VAL(ht, zkey, zv) {\n        if (zkey) {\n            if (zend_string_equals_literal_ci(zkey, \"TIME\")) {\n                opt->idle.type = \"TIME\";\n                opt->idle.time = get_xclaim_i64_arg(\"TIME\", zv);\n            } else if (zend_string_equals_literal_ci(zkey, \"IDLE\")) {\n                opt->idle.type = \"IDLE\";\n                opt->idle.time = get_xclaim_i64_arg(\"IDLE\", zv);\n            } else if (zend_string_equals_literal_ci(zkey, \"RETRYCOUNT\")) {\n                opt->retrycount = zval_get_long(zv);\n            }\n        } else if (Z_TYPE_P(zv) == IS_STRING) {\n            if (zend_string_equals_literal_ci(Z_STR_P(zv), \"FORCE\")) {\n                opt->force = 1;\n            } else if (zend_string_equals_literal_ci(Z_STR_P(zv), \"JUSTID\")) {\n                opt->justid = 1;\n            }\n        }\n    } ZEND_HASH_FOREACH_END();\n}\n\n/* Count argc for any options we may have */\nstatic int xclaim_options_argc(xclaimOptions *opt) {\n    int argc = 0;\n\n    if (opt->idle.type != NULL && opt->idle.time != -1)\n        argc += 2;\n    if (opt->retrycount != -1)\n        argc += 2;\n    if (opt->force)\n        argc++;\n    if (opt->justid)\n        argc++;\n\n    return argc;\n}\n\n/* Append XCLAIM options */\nstatic void append_xclaim_options(smart_string *cmd, xclaimOptions *opt) {\n    /* IDLE/TIME long */\n    if (opt->idle.type != NULL && opt->idle.time != -1) {\n        redis_cmd_append_sstr(cmd, opt->idle.type, strlen(opt->idle.type));\n        redis_cmd_append_sstr_i64(cmd, opt->idle.time);\n    }\n\n    /* RETRYCOUNT */\n    if (opt->retrycount != -1) {\n        REDIS_CMD_APPEND_SSTR_STATIC(cmd, \"RETRYCOUNT\");\n        redis_cmd_append_sstr_long(cmd, opt->retrycount);\n    }\n\n    /* FORCE and JUSTID */\n    if (opt->force)\n        REDIS_CMD_APPEND_SSTR_STATIC(cmd, \"FORCE\");\n    if (opt->justid)\n        REDIS_CMD_APPEND_SSTR_STATIC(cmd, \"JUSTID\");\n}\n\n\nint\nredis_xautoclaim_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    char *key, *group, *consumer, *start;\n    size_t keylen, grouplen, consumerlen, startlen;\n    zend_long min_idle, count = -1;\n    zend_bool justid = 0;\n    int argc;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sssls|lb\", &key, &keylen,\n                              &group, &grouplen, &consumer, &consumerlen,\n                              &min_idle, &start, &startlen, &count, &justid\n                              ) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    argc = 5 + (count > 0 ? 2 : 0) + justid;\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc, \"XAUTOCLAIM\");\n    redis_cmd_append_sstr_key(&cmdstr, key, keylen, redis_sock, slot);\n    redis_cmd_append_sstr(&cmdstr, group, grouplen);\n    redis_cmd_append_sstr(&cmdstr, consumer, consumerlen);\n    redis_cmd_append_sstr_long(&cmdstr, min_idle);\n    redis_cmd_append_sstr(&cmdstr, start, startlen);\n\n    if (count > 0) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"COUNT\");\n        redis_cmd_append_sstr_long(&cmdstr, count);\n    }\n\n    if (justid) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"JUSTID\");\n    }\n\n    // Set the context to distinguish XCLAIM from XAUTOCLAIM which\n    // have slightly different reply structures.\n    *ctx = PHPREDIS_CTX_PTR;\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\treturn SUCCESS;\n}\n\n/* XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2>\n          [IDLE <milliseconds>] [TIME <mstime>] [RETRYCOUNT <count>]\n          [FORCE] [JUSTID] */\nint redis_xclaim_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n\t\t\t\t\t char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    smart_string cmdstr = {0};\n    char *key, *group, *consumer;\n    size_t keylen, grouplen, consumerlen;\n    zend_long min_idle;\n    int argc, id_count;\n    zval *z_ids, *z_id, *z_opts = NULL;\n    zend_string *zstr;\n    HashTable *ht_ids;\n    xclaimOptions opts;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"sssla|a\", &key, &keylen,\n                              &group, &grouplen, &consumer, &consumerlen, &min_idle,\n                              &z_ids, &z_opts) == FAILURE)\n    {\n        return FAILURE;\n    }\n\n    /* At least one id is required */\n    ht_ids = Z_ARRVAL_P(z_ids);\n    if ((id_count = zend_hash_num_elements(ht_ids)) < 1) {\n        return FAILURE;\n    }\n\n    /* Extract options array if we've got them */\n    get_xclaim_options(z_opts, &opts);\n\n    /* Now we have enough information to calculate argc */\n    argc = 4 + id_count + xclaim_options_argc(&opts);\n\n    /* Start constructing our command */\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc, \"XCLAIM\");\n    redis_cmd_append_sstr_key(&cmdstr, key, keylen, redis_sock, slot);\n    redis_cmd_append_sstr(&cmdstr, group, grouplen);\n    redis_cmd_append_sstr(&cmdstr, consumer, consumerlen);\n    redis_cmd_append_sstr_long(&cmdstr, min_idle);\n\n    /* Add IDs */\n    ZEND_HASH_FOREACH_VAL(ht_ids, z_id) {\n        zstr = zval_get_string(z_id);\n        redis_cmd_append_sstr(&cmdstr, ZSTR_VAL(zstr), ZSTR_LEN(zstr));\n        zend_string_release(zstr);\n    } ZEND_HASH_FOREACH_END();\n\n    /* Finally add our options */\n    append_xclaim_options(&cmdstr, &opts);\n\n    /* Success */\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\treturn SUCCESS;\n}\n\n/* XGROUP HELP\n * XGROUP CREATE          key group id       [MKSTREAM] [ENTRIESREAD <n>]\n * XGROUP SETID           key group id                  [ENTRIESREAD <n>]\n * XGROUP CREATECONSUMER  key group consumer\n * XGROUP DELCONSUMER     key group consumer\n * XGROUP DESTROY         key group\n */\nint redis_xgroup_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *op = NULL, *key = NULL, *group = NULL, *id_or_consumer = NULL;\n    int nargs, is_create = 0, is_setid = 0;\n    zend_long entries_read = -2;\n    smart_string cmdstr = {0};\n    zend_bool mkstream = 0;\n\n    ZEND_PARSE_PARAMETERS_START(1, 6)\n        Z_PARAM_STR(op)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_STR(key)\n        Z_PARAM_STR(group)\n        Z_PARAM_STR(id_or_consumer)\n        Z_PARAM_BOOL(mkstream)\n        Z_PARAM_LONG(entries_read)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (zend_string_equals_literal_ci(op, \"HELP\")) {\n        nargs = 0;\n    } else if ((is_create = zend_string_equals_literal_ci(op, \"CREATE\")) ||\n               (is_setid  = zend_string_equals_literal_ci(op, \"SETID\")) ||\n                            zend_string_equals_literal_ci(op, \"CREATECONSUMER\") ||\n                            zend_string_equals_literal_ci(op, \"DELCONSUMER\"))\n    {\n        nargs = 3;\n    } else if (zend_string_equals_literal_ci(op, \"DESTROY\")) {\n        nargs = 2;\n    } else {\n        php_error_docref(NULL, E_WARNING, \"Unknown XGROUP operation '%s'\", ZSTR_VAL(op));\n        return FAILURE;\n    }\n\n    if (ZEND_NUM_ARGS() < nargs) {\n        php_error_docref(NULL, E_WARNING, \"Operation '%s' requires %d arguments\", ZSTR_VAL(op), nargs);\n        return FAILURE;\n    }\n\n    mkstream &= is_create;\n    if (!(is_create || is_setid))\n        entries_read = -2;\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1 + nargs + !!mkstream + (entries_read != -2 ? 2 : 0), \"XGROUP\");\n    redis_cmd_append_sstr_zstr(&cmdstr, op);\n\n    if (nargs-- > 0) redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n    if (nargs-- > 0) redis_cmd_append_sstr_zstr(&cmdstr, group);\n    if (nargs-- > 0) redis_cmd_append_sstr_zstr(&cmdstr, id_or_consumer);\n\n    REDIS_CMD_APPEND_SSTR_OPT_STATIC(&cmdstr, !!mkstream, \"MKSTREAM\");\n    if (entries_read != -2) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"ENTRIESREAD\");\n        redis_cmd_append_sstr_long(&cmdstr, entries_read);\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n/* XINFO CONSUMERS key group\n * XINFO GROUPS key\n * XINFO STREAM key [FULL [COUNT N]]\n * XINFO HELP */\nint redis_xinfo_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *op = NULL, *key = NULL, *arg = NULL;\n    smart_string cmdstr = {0};\n    zend_long count = -1;\n\n    ZEND_PARSE_PARAMETERS_START(1, 4)\n        Z_PARAM_STR(op)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_STR_OR_NULL(key)\n        Z_PARAM_STR_OR_NULL(arg)\n        Z_PARAM_LONG(count)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if ((arg != NULL && key == NULL) || (count != -1 && (key == NULL || arg == NULL))) {\n        php_error_docref(NULL, E_WARNING, \"Cannot pass a non-null optional argument after a NULL one.\");\n        return FAILURE;\n    }\n\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, 1 + (key != NULL) + (arg != NULL) + (count > -1 ? 2 : 0), \"XINFO\");\n    redis_cmd_append_sstr_zstr(&cmdstr, op);\n\n    if (key != NULL)\n        redis_cmd_append_sstr_key(&cmdstr, ZSTR_VAL(key), ZSTR_LEN(key), redis_sock, slot);\n    if (arg != NULL)\n        redis_cmd_append_sstr_zstr(&cmdstr, arg);\n\n    if (count > -1) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"COUNT\");\n        redis_cmd_append_sstr_long(&cmdstr, count);\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\n// XTRIM key <MAXLEN | MINID> [= | ~] threshold [LIMIT count]\nint redis_xtrim_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                    char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *key = NULL, *threshold = NULL;\n    zend_bool approx = 0, minid = 0;\n    smart_string cmdstr = {0};\n    zend_long limit = -1;\n    int argc;\n\n    ZEND_PARSE_PARAMETERS_START(2, 5)\n        Z_PARAM_STR(key)\n        Z_PARAM_STR(threshold)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_BOOL(approx)\n        Z_PARAM_BOOL(minid)\n        Z_PARAM_LONG(limit)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    argc = 4 + (approx && limit > -1 ? 2 : 0);\n    REDIS_CMD_INIT_SSTR_STATIC(&cmdstr, argc, \"XTRIM\");\n\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n\n    if (minid) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"MINID\");\n    } else {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"MAXLEN\");\n    }\n\n    if (approx) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"~\");\n    } else {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"=\");\n    }\n\n    redis_cmd_append_sstr_zstr(&cmdstr, threshold);\n\n    if (limit > -1 && approx) {\n        REDIS_CMD_APPEND_SSTR_STATIC(&cmdstr, \"LIMIT\");\n        redis_cmd_append_sstr_long(&cmdstr, limit);\n    } else if (limit > -1) {\n        php_error_docref(NULL, E_WARNING, \"Cannot use LIMIT without an approximate match, ignoring\");\n    } else if (ZEND_NUM_ARGS() == 5) {\n        php_error_docref(NULL, E_WARNING, \"Limit must be >= 0\");\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n    return SUCCESS;\n}\n\n// [P]EXPIRE[AT] [NX | XX | GT | LT]\nint redis_expire_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char *kw, char **cmd, int *cmd_len, short *slot,\n                     void **ctx)\n{\n    zend_string *key = NULL, *mode = NULL;\n    smart_string cmdstr = {0};\n    zend_long timeout = 0;\n\n    ZEND_PARSE_PARAMETERS_START(2, 3)\n        Z_PARAM_STR(key)\n        Z_PARAM_LONG(timeout)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_STR_OR_NULL(mode)\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    if (mode != NULL && !(zend_string_equals_literal_ci(mode, \"NX\") ||\n                          zend_string_equals_literal_ci(mode, \"XX\") ||\n                          zend_string_equals_literal_ci(mode, \"LT\") ||\n                          zend_string_equals_literal_ci(mode, \"GT\")))\n    {\n        php_error_docref(NULL, E_WARNING, \"Unknown expiration modifier '%s'\", ZSTR_VAL(mode));\n        return FAILURE;\n    }\n\n    redis_cmd_init_sstr(&cmdstr, 2 + (mode != NULL), kw, strlen(kw));\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n    redis_cmd_append_sstr_long(&cmdstr, timeout);\n    if (mode != NULL) redis_cmd_append_sstr_zstr(&cmdstr, mode);\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\nstatic int\ngeneric_expiremember_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                         char *kw, size_t kw_len, int has_unit, char **cmd,\n                         int *cmd_len, short *slot)\n{\n    zend_string *key, *mem, *unit = NULL;\n    smart_string cmdstr = {0};\n    zend_long expiry;\n\n    ZEND_PARSE_PARAMETERS_START(3, has_unit ? 4 : 3)\n        Z_PARAM_STR(key)\n        Z_PARAM_STR(mem)\n        Z_PARAM_LONG(expiry)\n        if (has_unit) {\n            Z_PARAM_OPTIONAL\n            Z_PARAM_STR_OR_NULL(unit)\n        }\n    ZEND_PARSE_PARAMETERS_END_EX(return FAILURE);\n\n    redis_cmd_init_sstr(&cmdstr, 3 + (unit != NULL), kw, kw_len);\n    redis_cmd_append_sstr_key_zstr(&cmdstr, key, redis_sock, slot);\n    redis_cmd_append_sstr_zstr(&cmdstr, mem);\n    redis_cmd_append_sstr_long(&cmdstr, expiry);\n\n    if (unit != NULL) {\n        redis_cmd_append_sstr_zstr(&cmdstr, unit);\n    }\n\n    *cmd = cmdstr.c;\n    *cmd_len = cmdstr.len;\n\n    return SUCCESS;\n}\n\n\nint redis_expiremember_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                           char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    return generic_expiremember_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU,\n                                    redis_sock, ZEND_STRL(\"EXPIREMEMBER\"), 1,\n                                    cmd, cmd_len, slot);\n}\n\nint redis_expirememberat_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                             char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    return generic_expiremember_cmd(INTERNAL_FUNCTION_PARAM_PASSTHRU,\n                                    redis_sock, ZEND_STRL(\"EXPIREMEMBERAT\"), 0,\n                                    cmd, cmd_len, slot);\n}\n\nint\nredis_sentinel_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    if (zend_parse_parameters_none() == FAILURE) {\n\n        return FAILURE;\n    }\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"SENTINEL\", \"s\", kw, strlen(kw));\n    return SUCCESS;\n}\n\nint\nredis_sentinel_str_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx)\n{\n    zend_string *name;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"S\", &name) == FAILURE) {\n        return FAILURE;\n    }\n    *cmd_len = REDIS_CMD_SPPRINTF(cmd, \"SENTINEL\", \"sS\", kw, strlen(kw), name);\n    return SUCCESS;\n}\n\n/*\n * Redis commands that don't deal with the server at all.  The RedisSock*\n * pointer is the only thing retrieved differently, so we just take that\n * in addition to the standard INTERNAL_FUNCTION_PARAMETERS for arg parsing,\n * return value handling, and thread safety. */\n\nvoid redis_getoption_handler(INTERNAL_FUNCTION_PARAMETERS,\n                             RedisSock *redis_sock, redisCluster *c)\n{\n    zend_long option;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"l\", &option)\n                              == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    // Return the requested option\n    switch(option) {\n        case REDIS_OPT_SERIALIZER:\n            RETURN_LONG(redis_sock->serializer);\n        case REDIS_OPT_COMPRESSION:\n            RETURN_LONG(redis_sock->compression);\n        case REDIS_OPT_COMPRESSION_LEVEL:\n            RETURN_LONG(redis_sock->compression_level);\n        case REDIS_OPT_PREFIX:\n            if (redis_sock->prefix) {\n                RETURN_STRINGL(ZSTR_VAL(redis_sock->prefix), ZSTR_LEN(redis_sock->prefix));\n            }\n            RETURN_NULL();\n        case REDIS_OPT_READ_TIMEOUT:\n            RETURN_DOUBLE(redis_sock->read_timeout);\n        case REDIS_OPT_TCP_KEEPALIVE:\n            RETURN_LONG(redis_sock->tcp_keepalive);\n        case REDIS_OPT_SCAN:\n            RETURN_LONG(redis_sock->scan);\n        case REDIS_OPT_REPLY_LITERAL:\n            RETURN_LONG(redis_sock->reply_literal);\n        case REDIS_OPT_NULL_MBULK_AS_NULL:\n            RETURN_LONG(redis_sock->null_mbulk_as_null);\n        case REDIS_OPT_FAILOVER:\n            RETURN_LONG(c->failover);\n        case REDIS_OPT_MAX_RETRIES:\n            RETURN_LONG(redis_sock->max_retries);\n        case REDIS_OPT_BACKOFF_ALGORITHM:\n            RETURN_LONG(redis_sock->backoff.algorithm);\n        case REDIS_OPT_BACKOFF_BASE:\n            RETURN_LONG(redis_sock->backoff.base / 1000);\n        case REDIS_OPT_BACKOFF_CAP:\n            RETURN_LONG(redis_sock->backoff.cap / 1000);\n        default:\n            RETURN_FALSE;\n    }\n}\n\nvoid redis_setoption_handler(INTERNAL_FUNCTION_PARAMETERS,\n                             RedisSock *redis_sock, redisCluster *c)\n{\n    zend_long val_long, option;\n    zval *val;\n    zend_string *val_str;\n    struct timeval read_tv;\n    int tcp_keepalive = 0;\n    php_netstream_data_t *sock;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"lz\", &option,\n                              &val) == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    switch(option) {\n        case REDIS_OPT_SERIALIZER:\n            val_long = zval_get_long(val);\n            if (val_long == REDIS_SERIALIZER_NONE\n                || val_long == REDIS_SERIALIZER_PHP\n                || val_long == REDIS_SERIALIZER_JSON\n#ifdef HAVE_REDIS_IGBINARY\n                || val_long == REDIS_SERIALIZER_IGBINARY\n#endif\n#ifdef HAVE_REDIS_MSGPACK\n                || val_long == REDIS_SERIALIZER_MSGPACK\n#endif\n            ) {\n                redis_sock->serializer = val_long;\n                RETURN_TRUE;\n            }\n            break;\n        case REDIS_OPT_REPLY_LITERAL:\n            val_long = zval_get_long(val);\n            redis_sock->reply_literal = val_long != 0;\n            RETURN_TRUE;\n        case REDIS_OPT_NULL_MBULK_AS_NULL:\n            val_long = zval_get_long(val);\n            redis_sock->null_mbulk_as_null = val_long != 0;\n            RETURN_TRUE;\n        case REDIS_OPT_COMPRESSION:\n            val_long = zval_get_long(val);\n            if (val_long == REDIS_COMPRESSION_NONE\n#ifdef HAVE_REDIS_LZF\n                || val_long == REDIS_COMPRESSION_LZF\n#endif\n#ifdef HAVE_REDIS_ZSTD\n                || val_long == REDIS_COMPRESSION_ZSTD\n#endif\n#ifdef HAVE_REDIS_LZ4\n                || val_long == REDIS_COMPRESSION_LZ4\n#endif\n            ) {\n                redis_sock->compression = val_long;\n                RETURN_TRUE;\n            }\n            break;\n        case REDIS_OPT_COMPRESSION_LEVEL:\n            val_long = zval_get_long(val);\n            redis_sock->compression_level = val_long;\n            RETURN_TRUE;\n        case REDIS_OPT_PREFIX:\n            if (redis_sock->prefix) {\n                zend_string_release(redis_sock->prefix);\n                redis_sock->prefix = NULL;\n            }\n            val_str = zval_get_string(val);\n            if (ZSTR_LEN(val_str) > 0) {\n                redis_sock->prefix = val_str;\n            } else {\n                zend_string_release(val_str);\n            }\n            RETURN_TRUE;\n        case REDIS_OPT_READ_TIMEOUT:\n            redis_sock->read_timeout = zval_get_double(val);\n            if (redis_sock->stream) {\n                read_tv.tv_sec  = (time_t)redis_sock->read_timeout;\n                read_tv.tv_usec = (int)((redis_sock->read_timeout -\n                                         read_tv.tv_sec) * 1000000);\n                php_stream_set_option(redis_sock->stream,\n                                      PHP_STREAM_OPTION_READ_TIMEOUT, 0,\n                                      &read_tv);\n            }\n            RETURN_TRUE;\n        case REDIS_OPT_TCP_KEEPALIVE:\n\n            /* Don't set TCP_KEEPALIVE if we're using a unix socket. */\n            if (ZSTR_VAL(redis_sock->host)[0] == '/' && redis_sock->port < 1) {\n                RETURN_FALSE;\n            }\n            tcp_keepalive = zval_get_long(val) > 0 ? 1 : 0;\n            if (redis_sock->tcp_keepalive == tcp_keepalive) {\n                RETURN_TRUE;\n            }\n            if (redis_sock->stream) {\n                /* set TCP_KEEPALIVE */\n                sock = (php_netstream_data_t*)redis_sock->stream->abstract;\n                if (setsockopt(sock->socket, SOL_SOCKET, SO_KEEPALIVE, (char*)&tcp_keepalive,\n                            sizeof(tcp_keepalive)) == -1) {\n                    RETURN_FALSE;\n                }\n                redis_sock->tcp_keepalive = tcp_keepalive;\n            }\n            RETURN_TRUE;\n        case REDIS_OPT_SCAN:\n            val_long = zval_get_long(val);\n            if (val_long == REDIS_SCAN_NORETRY) {\n                redis_sock->scan &= ~REDIS_SCAN_RETRY;\n            } else if (val_long == REDIS_SCAN_NOPREFIX) {\n                redis_sock->scan &= ~REDIS_SCAN_PREFIX;\n            } else if (val_long == REDIS_SCAN_RETRY || val_long == REDIS_SCAN_PREFIX) {\n                redis_sock->scan |= val_long;\n            } else {\n                break;\n            }\n            RETURN_TRUE;\n        case REDIS_OPT_FAILOVER:\n            if (c == NULL) RETURN_FALSE;\n            val_long = zval_get_long(val);\n            if (val_long == REDIS_FAILOVER_NONE ||\n                val_long == REDIS_FAILOVER_ERROR ||\n                val_long == REDIS_FAILOVER_DISTRIBUTE ||\n                val_long == REDIS_FAILOVER_DISTRIBUTE_SLAVES)\n            {\n                c->failover = val_long;\n                RETURN_TRUE;\n            }\n            break;\n        case REDIS_OPT_MAX_RETRIES:\n            val_long = zval_get_long(val);\n            if(val_long >= 0) {\n                redis_sock->max_retries = val_long;\n                RETURN_TRUE;\n            }\n            break;\n        case REDIS_OPT_BACKOFF_ALGORITHM:\n            val_long = zval_get_long(val);\n            if(val_long >= 0 &&\n               val_long < REDIS_BACKOFF_ALGORITHMS) {\n                redis_sock->backoff.algorithm = val_long;\n                RETURN_TRUE;\n            }\n            break;\n        case REDIS_OPT_BACKOFF_BASE:\n            val_long = zval_get_long(val);\n            if(val_long >= 0) {\n                redis_sock->backoff.base = val_long * 1000;\n                RETURN_TRUE;\n            }\n            break;\n        case REDIS_OPT_BACKOFF_CAP:\n            val_long = zval_get_long(val);\n            if(val_long >= 0) {\n                redis_sock->backoff.cap = val_long * 1000;\n                RETURN_TRUE;\n            }\n            break;\n        default:\n            php_error_docref(NULL, E_WARNING, \"Unknown option '\" ZEND_LONG_FMT \"'\", option);\n            break;\n    }\n    RETURN_FALSE;\n}\n\nvoid redis_prefix_handler(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock) {\n    char *key;\n    size_t key_len;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &key, &key_len)\n                             ==FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    if (redis_sock->prefix) {\n        int keyfree = redis_key_prefix(redis_sock, &key, &key_len);\n        RETVAL_STRINGL(key, key_len);\n        if (keyfree) efree(key);\n    } else {\n        RETURN_STRINGL(key, key_len);\n    }\n}\n\nvoid redis_serialize_handler(INTERNAL_FUNCTION_PARAMETERS,\n                             RedisSock *redis_sock)\n{\n    zval *z_val;\n    char *val;\n    size_t val_len;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"z\", &z_val) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    int val_free = redis_serialize(redis_sock, z_val, &val, &val_len);\n\n    RETVAL_STRINGL(val, val_len);\n    if (val_free) efree(val);\n}\n\nvoid redis_unserialize_handler(INTERNAL_FUNCTION_PARAMETERS,\n                               RedisSock *redis_sock, zend_class_entry *ex)\n{\n    char *value;\n    size_t value_len;\n\n    // Parse our arguments\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &value, &value_len)\n                                    == FAILURE)\n    {\n        RETURN_FALSE;\n    }\n\n    // We only need to attempt unserialization if we have a serializer running\n    if (redis_sock->serializer == REDIS_SERIALIZER_NONE) {\n        // Just return the value that was passed to us\n        RETURN_STRINGL(value, value_len);\n    }\n\n    zval z_ret;\n    if (!redis_unserialize(redis_sock, value, value_len, &z_ret)) {\n        // Badly formed input, throw an exception\n        zend_throw_exception(ex, \"Invalid serialized data, or unserialization error\", 0);\n        RETURN_FALSE;\n    }\n    RETURN_ZVAL(&z_ret, 0, 0);\n}\n\nvoid redis_compress_handler(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock) {\n    zend_string *zstr;\n    size_t len;\n    char *buf;\n    int cmp_free;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"S\", &zstr) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    cmp_free = redis_compress(redis_sock, &buf, &len, ZSTR_VAL(zstr), ZSTR_LEN(zstr));\n    RETVAL_STRINGL(buf, len);\n    if (cmp_free) efree(buf);\n}\n\nvoid redis_uncompress_handler(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                              zend_class_entry *ex)\n{\n    zend_string *zstr;\n    size_t len;\n    char *buf;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"S\", &zstr) == FAILURE) {\n        RETURN_FALSE;\n    } else if (ZSTR_LEN(zstr) == 0 || redis_sock->compression == REDIS_COMPRESSION_NONE) {\n        RETURN_STR_COPY(zstr);\n    }\n\n    if (!redis_uncompress(redis_sock, &buf, &len, ZSTR_VAL(zstr), ZSTR_LEN(zstr))) {\n        zend_throw_exception(ex, \"Invalid compressed data or uncompression error\", 0);\n        RETURN_FALSE;\n    }\n\n    RETVAL_STRINGL(buf, len);\n    efree(buf);\n}\n\nvoid redis_pack_handler(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock) {\n    int valfree;\n    size_t len;\n    char *val;\n    zval *zv;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"z\", &zv) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    valfree = redis_pack(redis_sock, zv, &val, &len);\n    RETVAL_STRINGL(val, len);\n    if (valfree) efree(val);\n}\n\nvoid redis_unpack_handler(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock) {\n    zend_string *str;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS(), \"S\", &str) == FAILURE) {\n        RETURN_FALSE;\n    }\n\n    if (redis_unpack(redis_sock, ZSTR_VAL(str), ZSTR_LEN(str), return_value) == 0) {\n        RETURN_STR_COPY(str);\n    }\n}\n/* vim: set tabstop=4 softtabstop=4 expandtab shiftwidth=4: */\n"
        },
        {
          "name": "redis_commands.h",
          "type": "blob",
          "size": 17.7275390625,
          "content": "#ifndef REDIS_COMMANDS_H\n#define REDIS_COMMANDS_H\n\n#include \"common.h\"\n#include \"library.h\"\n#include \"cluster_library.h\"\n\n/* Pick a random slot, any slot (for stuff like publish/subscribe) */\n#define CMD_RAND_SLOT(slot) \\\n    if(slot) *slot = rand() % REDIS_CLUSTER_MOD\n\n/* Macro for setting the slot if we've been asked to */\n#define CMD_SET_SLOT(slot,key,key_len) \\\n    if (slot) *slot = cluster_hash_key(key,key_len);\n\n/* Simple container so we can push subscribe context out */\ntypedef struct {\n    zend_fcall_info fci;\n    zend_fcall_info_cache fci_cache;\n} subscribeCallback;\n\ntypedef struct subscribeContext {\n    char *kw;\n    int argc;\n    subscribeCallback cb;\n} subscribeContext;\n\n/* Construct a raw command */\nint redis_build_raw_cmd(zval *z_args, int argc, char **cmd, int *cmd_len);\n\n/* Construct a script command */\nsmart_string *redis_build_script_cmd(smart_string *cmd, int argc, zval *z_args);\n\n/* Redis command generics.  Many commands share common prototypes meaning that\n * we can write one function to handle all of them.  For example, there are\n * many COMMAND key value commands, or COMMAND key commands. */\n\nint redis_replicaof_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                        char *kw, char **cmd, int *cmd_len, short *slot,\n                        void **ctx);\n\nint redis_empty_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_opt_str_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, char *kw,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_str_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_key_long_val_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_key_long_str_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_kv_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_key_str_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_key_key_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_key_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_key_long_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_long_long_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_key_long_long_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_key_str_str_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_key_dbl_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_key_varval_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_key_val_arr_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_key_str_arr_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_pop_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_blocking_pop_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\n/* Construct SCAN and similar commands, as well as check iterator  */\nint redis_scan_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    REDIS_SCAN_TYPE type, char **cmd, int *cmd_len);\n\n/* ZRANGE, ZREVRANGE, ZRANGEBYSCORE, and ZREVRANGEBYSCORE callback type */\ntypedef int (*zrange_cb)(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                         char *,char**,int*,int*,short*,void**);\n\nint redis_zrange_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_config_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_function_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_zrandmember_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_zdiff_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_zinterunion_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_zdiffstore_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_zinterunionstore_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_intercard_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                        char *kw, char **cmd, int *cmd_len, short *slot,\n                        void **ctx);\n\nint redis_slowlog_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_lcs_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                  char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_mpop_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, char *kw,\n                   char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_restore_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_pubsub_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_subscribe_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_unsubscribe_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_zrangebylex_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_gen_zlex_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_eval_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_fcall_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_failover_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_flush_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_xrange_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_georadius_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_georadiusbymember_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_geosearch_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_geosearchstore_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\n/* Commands which need a unique construction mechanism.  This is either because\n * they don't share a signature with any other command, or because there is\n * specific processing we do (e.g. verifying subarguments) that make them\n * unique */\n\nint redis_waitaof_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                      char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_info_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_script_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_acl_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_set_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_getex_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_brpoplpush_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_incr_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_decr_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_hincrby_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_hincrbyfloat_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_hmget_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_mget_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_hmset_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_hstrlen_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_bitop_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_bitcount_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_bitpos_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_pfcount_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_pfadd_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_pfmerge_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_auth_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_setbit_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_linsert_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_lrem_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_lpos_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_smove_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_hrandfield_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_hset_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_hsetnx_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_srandmember_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_select_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n                     char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_zincrby_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_hdel_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_zadd_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_object_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_client_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_command_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_copy_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_fmt_scan_cmd(char **cmd, REDIS_SCAN_TYPE type, char *key, int key_len,\n    uint64_t it, char *pat, int pat_len, long count);\n\nint redis_geoadd_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_geodist_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_migrate_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_xadd_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_xautoclaim_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_xclaim_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_xpending_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_xack_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_xgroup_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_xinfo_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_xread_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_xreadgroup_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_xtrim_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_expiremember_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_expirememberat_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_lmove_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_expire_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_varkey_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_vararg_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_mset_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_sentinel_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_sentinel_str_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\nint redis_sort_cmd(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock,\n    char *kw, char **cmd, int *cmd_len, short *slot, void **ctx);\n\n/* Commands that don't communicate with Redis at all (such as getOption,\n * setOption, _prefix, _serialize, etc).  These can be handled in one place\n * with the method of grabbing our RedisSock* object in different ways\n * depending if this is a Redis object or a RedisCluster object. */\n\nvoid redis_getoption_handler(INTERNAL_FUNCTION_PARAMETERS,\n    RedisSock *redis_sock, redisCluster *c);\nvoid redis_setoption_handler(INTERNAL_FUNCTION_PARAMETERS,\n    RedisSock *redis_sock, redisCluster *c);\nvoid redis_prefix_handler(INTERNAL_FUNCTION_PARAMETERS,\n    RedisSock *redis_sock);\nvoid redis_serialize_handler(INTERNAL_FUNCTION_PARAMETERS,\n    RedisSock *redis_sock);\nvoid redis_unserialize_handler(INTERNAL_FUNCTION_PARAMETERS,\n    RedisSock *redis_sock, zend_class_entry *ex);\nvoid redis_compress_handler(INTERNAL_FUNCTION_PARAMETERS,\n    RedisSock *redis_sock);\nvoid redis_uncompress_handler(INTERNAL_FUNCTION_PARAMETERS,\n    RedisSock *redis_sock, zend_class_entry *ex);\n\nvoid redis_pack_handler(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock);\nvoid redis_unpack_handler(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock);\n\n#endif\n\n/* vim: set tabstop=4 softtabstop=4 expandtab shiftwidth=4: */\n"
        },
        {
          "name": "redis_legacy_arginfo.h",
          "type": "blob",
          "size": 75.828125,
          "content": "/* This is a generated file, edit the .stub.php file instead.\n * Stub hash: bacbe6b1d55da4ba6d370fff1090e8de0363c4c2 */\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis___construct, 0, 0, 0)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis___destruct, 0, 0, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis__compress, 0, 0, 1)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis__uncompress arginfo_class_Redis__compress\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis__prefix, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis__serialize arginfo_class_Redis__compress\n\n#define arginfo_class_Redis__unserialize arginfo_class_Redis__compress\n\n#define arginfo_class_Redis__pack arginfo_class_Redis__compress\n\n#define arginfo_class_Redis__unpack arginfo_class_Redis__compress\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_acl, 0, 0, 1)\n\tZEND_ARG_INFO(0, subcmd)\n\tZEND_ARG_VARIADIC_INFO(0, args)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_append, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_auth, 0, 0, 1)\n\tZEND_ARG_INFO(0, credentials)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_bgSave arginfo_class_Redis___destruct\n\n#define arginfo_class_Redis_bgrewriteaof arginfo_class_Redis___destruct\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_waitaof, 0, 0, 3)\n\tZEND_ARG_INFO(0, numlocal)\n\tZEND_ARG_INFO(0, numreplicas)\n\tZEND_ARG_INFO(0, timeout)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_bitcount, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, end)\n\tZEND_ARG_INFO(0, bybit)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_bitop, 0, 0, 3)\n\tZEND_ARG_INFO(0, operation)\n\tZEND_ARG_INFO(0, deskey)\n\tZEND_ARG_INFO(0, srckey)\n\tZEND_ARG_VARIADIC_INFO(0, other_keys)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_bitpos, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, bit)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, end)\n\tZEND_ARG_INFO(0, bybit)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_blPop, 0, 0, 2)\n\tZEND_ARG_INFO(0, key_or_keys)\n\tZEND_ARG_INFO(0, timeout_or_key)\n\tZEND_ARG_VARIADIC_INFO(0, extra_args)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_brPop arginfo_class_Redis_blPop\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_brpoplpush, 0, 0, 3)\n\tZEND_ARG_INFO(0, src)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, timeout)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_bzPopMax, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, timeout_or_key)\n\tZEND_ARG_VARIADIC_INFO(0, extra_args)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_bzPopMin arginfo_class_Redis_bzPopMax\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_bzmpop, 0, 0, 3)\n\tZEND_ARG_INFO(0, timeout)\n\tZEND_ARG_INFO(0, keys)\n\tZEND_ARG_INFO(0, from)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_zmpop, 0, 0, 2)\n\tZEND_ARG_INFO(0, keys)\n\tZEND_ARG_INFO(0, from)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_blmpop arginfo_class_Redis_bzmpop\n\n#define arginfo_class_Redis_lmpop arginfo_class_Redis_zmpop\n\n#define arginfo_class_Redis_clearLastError arginfo_class_Redis___destruct\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_client, 0, 0, 1)\n\tZEND_ARG_INFO(0, opt)\n\tZEND_ARG_VARIADIC_INFO(0, args)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_close arginfo_class_Redis___destruct\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_command, 0, 0, 0)\n\tZEND_ARG_INFO(0, opt)\n\tZEND_ARG_VARIADIC_INFO(0, args)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_config, 0, 0, 1)\n\tZEND_ARG_INFO(0, operation)\n\tZEND_ARG_INFO(0, key_or_settings)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_connect, 0, 0, 1)\n\tZEND_ARG_INFO(0, host)\n\tZEND_ARG_INFO(0, port)\n\tZEND_ARG_INFO(0, timeout)\n\tZEND_ARG_INFO(0, persistent_id)\n\tZEND_ARG_INFO(0, retry_interval)\n\tZEND_ARG_INFO(0, read_timeout)\n\tZEND_ARG_INFO(0, context)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_copy, 0, 0, 2)\n\tZEND_ARG_INFO(0, src)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_dbSize arginfo_class_Redis___destruct\n\n#define arginfo_class_Redis_debug arginfo_class_Redis__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_decr, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, by)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_decrBy arginfo_class_Redis_append\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_del, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_VARIADIC_INFO(0, other_keys)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_delete arginfo_class_Redis_del\n\n#define arginfo_class_Redis_discard arginfo_class_Redis___destruct\n\n#define arginfo_class_Redis_dump arginfo_class_Redis__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_echo, 0, 0, 1)\n\tZEND_ARG_INFO(0, str)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_eval, 0, 0, 1)\n\tZEND_ARG_INFO(0, script)\n\tZEND_ARG_INFO(0, args)\n\tZEND_ARG_INFO(0, num_keys)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_eval_ro, 0, 0, 1)\n\tZEND_ARG_INFO(0, script_sha)\n\tZEND_ARG_INFO(0, args)\n\tZEND_ARG_INFO(0, num_keys)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_evalsha, 0, 0, 1)\n\tZEND_ARG_INFO(0, sha1)\n\tZEND_ARG_INFO(0, args)\n\tZEND_ARG_INFO(0, num_keys)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_evalsha_ro arginfo_class_Redis_evalsha\n\n#define arginfo_class_Redis_exec arginfo_class_Redis___destruct\n\n#define arginfo_class_Redis_exists arginfo_class_Redis_del\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_expire, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, timeout)\n\tZEND_ARG_INFO(0, mode)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_expireAt, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, timestamp)\n\tZEND_ARG_INFO(0, mode)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_failover, 0, 0, 0)\n\tZEND_ARG_INFO(0, to)\n\tZEND_ARG_INFO(0, abort)\n\tZEND_ARG_INFO(0, timeout)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_expiretime arginfo_class_Redis__prefix\n\n#define arginfo_class_Redis_pexpiretime arginfo_class_Redis__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_fcall, 0, 0, 1)\n\tZEND_ARG_INFO(0, fn)\n\tZEND_ARG_INFO(0, keys)\n\tZEND_ARG_INFO(0, args)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_fcall_ro arginfo_class_Redis_fcall\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_flushAll, 0, 0, 0)\n\tZEND_ARG_INFO(0, sync)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_flushDB arginfo_class_Redis_flushAll\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_function, 0, 0, 1)\n\tZEND_ARG_INFO(0, operation)\n\tZEND_ARG_VARIADIC_INFO(0, args)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_geoadd, 0, 0, 4)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, lng)\n\tZEND_ARG_INFO(0, lat)\n\tZEND_ARG_INFO(0, member)\n\tZEND_ARG_VARIADIC_INFO(0, other_triples_and_options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_geodist, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, src)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, unit)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_geohash, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, member)\n\tZEND_ARG_VARIADIC_INFO(0, other_members)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_geopos arginfo_class_Redis_geohash\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_georadius, 0, 0, 5)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, lng)\n\tZEND_ARG_INFO(0, lat)\n\tZEND_ARG_INFO(0, radius)\n\tZEND_ARG_INFO(0, unit)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_georadius_ro arginfo_class_Redis_georadius\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_georadiusbymember, 0, 0, 4)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, member)\n\tZEND_ARG_INFO(0, radius)\n\tZEND_ARG_INFO(0, unit)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_georadiusbymember_ro arginfo_class_Redis_georadiusbymember\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_geosearch, 0, 0, 4)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, position)\n\tZEND_ARG_INFO(0, shape)\n\tZEND_ARG_INFO(0, unit)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_geosearchstore, 0, 0, 5)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, src)\n\tZEND_ARG_INFO(0, position)\n\tZEND_ARG_INFO(0, shape)\n\tZEND_ARG_INFO(0, unit)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_get arginfo_class_Redis__prefix\n\n#define arginfo_class_Redis_getAuth arginfo_class_Redis___destruct\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_getBit, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, idx)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_getEx, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_getDBNum arginfo_class_Redis___destruct\n\n#define arginfo_class_Redis_getDel arginfo_class_Redis__prefix\n\n#define arginfo_class_Redis_getHost arginfo_class_Redis___destruct\n\n#define arginfo_class_Redis_getLastError arginfo_class_Redis___destruct\n\n#define arginfo_class_Redis_getMode arginfo_class_Redis___destruct\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_getOption, 0, 0, 1)\n\tZEND_ARG_INFO(0, option)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_getPersistentID arginfo_class_Redis___destruct\n\n#define arginfo_class_Redis_getPort arginfo_class_Redis___destruct\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_getRange, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, end)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_lcs, 0, 0, 2)\n\tZEND_ARG_INFO(0, key1)\n\tZEND_ARG_INFO(0, key2)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_getReadTimeout arginfo_class_Redis___destruct\n\n#define arginfo_class_Redis_getset arginfo_class_Redis_append\n\n#define arginfo_class_Redis_getTimeout arginfo_class_Redis___destruct\n\n#define arginfo_class_Redis_getTransferredBytes arginfo_class_Redis___destruct\n\n#define arginfo_class_Redis_clearTransferredBytes arginfo_class_Redis___destruct\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_hDel, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, field)\n\tZEND_ARG_VARIADIC_INFO(0, other_fields)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_hExists, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, field)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_hGet, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, member)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_hGetAll arginfo_class_Redis__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_hIncrBy, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, field)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_hIncrByFloat arginfo_class_Redis_hIncrBy\n\n#define arginfo_class_Redis_hKeys arginfo_class_Redis__prefix\n\n#define arginfo_class_Redis_hLen arginfo_class_Redis__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_hMget, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, fields)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_hMset, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, fieldvals)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_hRandField arginfo_class_Redis_getEx\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_hSet, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_VARIADIC_INFO(0, fields_and_vals)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_hSetNx arginfo_class_Redis_hIncrBy\n\n#define arginfo_class_Redis_hStrLen arginfo_class_Redis_hExists\n\n#define arginfo_class_Redis_hVals arginfo_class_Redis__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_hscan, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(1, iterator)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_expiremember, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, field)\n\tZEND_ARG_INFO(0, ttl)\n\tZEND_ARG_INFO(0, unit)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_expirememberat, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, field)\n\tZEND_ARG_INFO(0, timestamp)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_incr arginfo_class_Redis_decr\n\n#define arginfo_class_Redis_incrBy arginfo_class_Redis_append\n\n#define arginfo_class_Redis_incrByFloat arginfo_class_Redis_append\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_info, 0, 0, 0)\n\tZEND_ARG_VARIADIC_INFO(0, sections)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_isConnected arginfo_class_Redis___destruct\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_keys, 0, 0, 1)\n\tZEND_ARG_INFO(0, pattern)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_lInsert, 0, 0, 4)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, pos)\n\tZEND_ARG_INFO(0, pivot)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_lLen arginfo_class_Redis__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_lMove, 0, 0, 4)\n\tZEND_ARG_INFO(0, src)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, wherefrom)\n\tZEND_ARG_INFO(0, whereto)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_blmove, 0, 0, 5)\n\tZEND_ARG_INFO(0, src)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, wherefrom)\n\tZEND_ARG_INFO(0, whereto)\n\tZEND_ARG_INFO(0, timeout)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_lPop, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_lPos, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, value)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_lPush, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_VARIADIC_INFO(0, elements)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_rPush arginfo_class_Redis_lPush\n\n#define arginfo_class_Redis_lPushx arginfo_class_Redis_append\n\n#define arginfo_class_Redis_rPushx arginfo_class_Redis_append\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_lSet, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, index)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_lastSave arginfo_class_Redis___destruct\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_lindex, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, index)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_lrange arginfo_class_Redis_getRange\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_lrem, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, value)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_ltrim arginfo_class_Redis_getRange\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_mget, 0, 0, 1)\n\tZEND_ARG_INFO(0, keys)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_migrate, 0, 0, 5)\n\tZEND_ARG_INFO(0, host)\n\tZEND_ARG_INFO(0, port)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, dstdb)\n\tZEND_ARG_INFO(0, timeout)\n\tZEND_ARG_INFO(0, copy)\n\tZEND_ARG_INFO(0, replace)\n\tZEND_ARG_INFO(0, credentials)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_move arginfo_class_Redis_lindex\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_mset, 0, 0, 1)\n\tZEND_ARG_INFO(0, key_values)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_msetnx arginfo_class_Redis_mset\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_multi, 0, 0, 0)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_object, 0, 0, 2)\n\tZEND_ARG_INFO(0, subcommand)\n\tZEND_ARG_INFO(0, key)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_open arginfo_class_Redis_connect\n\n#define arginfo_class_Redis_pconnect arginfo_class_Redis_connect\n\n#define arginfo_class_Redis_persist arginfo_class_Redis__prefix\n\n#define arginfo_class_Redis_pexpire arginfo_class_Redis_expire\n\n#define arginfo_class_Redis_pexpireAt arginfo_class_Redis_expireAt\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_pfadd, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, elements)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_pfcount, 0, 0, 1)\n\tZEND_ARG_INFO(0, key_or_keys)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_pfmerge, 0, 0, 2)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, srckeys)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_ping, 0, 0, 0)\n\tZEND_ARG_INFO(0, message)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_pipeline arginfo_class_Redis___destruct\n\n#define arginfo_class_Redis_popen arginfo_class_Redis_connect\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_psetex, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, expire)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_psubscribe, 0, 0, 2)\n\tZEND_ARG_INFO(0, patterns)\n\tZEND_ARG_INFO(0, cb)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_pttl arginfo_class_Redis__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_publish, 0, 0, 2)\n\tZEND_ARG_INFO(0, channel)\n\tZEND_ARG_INFO(0, message)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_pubsub, 0, 0, 1)\n\tZEND_ARG_INFO(0, command)\n\tZEND_ARG_INFO(0, arg)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_punsubscribe, 0, 0, 1)\n\tZEND_ARG_INFO(0, patterns)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_rPop arginfo_class_Redis_lPop\n\n#define arginfo_class_Redis_randomKey arginfo_class_Redis___destruct\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_rawcommand, 0, 0, 1)\n\tZEND_ARG_INFO(0, command)\n\tZEND_ARG_VARIADIC_INFO(0, args)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_rename, 0, 0, 2)\n\tZEND_ARG_INFO(0, old_name)\n\tZEND_ARG_INFO(0, new_name)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_renameNx, 0, 0, 2)\n\tZEND_ARG_INFO(0, key_src)\n\tZEND_ARG_INFO(0, key_dst)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_reset arginfo_class_Redis___destruct\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_restore, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, ttl)\n\tZEND_ARG_INFO(0, value)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_role arginfo_class_Redis___destruct\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_rpoplpush, 0, 0, 2)\n\tZEND_ARG_INFO(0, srckey)\n\tZEND_ARG_INFO(0, dstkey)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_sAdd, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, value)\n\tZEND_ARG_VARIADIC_INFO(0, other_values)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_sAddArray, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, values)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_sDiff arginfo_class_Redis_del\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_sDiffStore, 0, 0, 2)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_VARIADIC_INFO(0, other_keys)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_sInter arginfo_class_Redis_del\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_sintercard, 0, 0, 1)\n\tZEND_ARG_INFO(0, keys)\n\tZEND_ARG_INFO(0, limit)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_sInterStore arginfo_class_Redis_del\n\n#define arginfo_class_Redis_sMembers arginfo_class_Redis__prefix\n\n#define arginfo_class_Redis_sMisMember arginfo_class_Redis_geohash\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_sMove, 0, 0, 3)\n\tZEND_ARG_INFO(0, src)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_sPop arginfo_class_Redis_lPop\n\n#define arginfo_class_Redis_sRandMember arginfo_class_Redis_lPop\n\n#define arginfo_class_Redis_sUnion arginfo_class_Redis_del\n\n#define arginfo_class_Redis_sUnionStore arginfo_class_Redis_sDiffStore\n\n#define arginfo_class_Redis_save arginfo_class_Redis___destruct\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_scan, 0, 0, 1)\n\tZEND_ARG_INFO(1, iterator)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_INFO(0, count)\n\tZEND_ARG_INFO(0, type)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_scard arginfo_class_Redis__prefix\n\n#define arginfo_class_Redis_script arginfo_class_Redis_rawcommand\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_select, 0, 0, 1)\n\tZEND_ARG_INFO(0, db)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_set arginfo_class_Redis_lPos\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_setBit, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, idx)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_setRange arginfo_class_Redis_lSet\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_setOption, 0, 0, 2)\n\tZEND_ARG_INFO(0, option)\n\tZEND_ARG_INFO(0, value)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_setex arginfo_class_Redis_psetex\n\n#define arginfo_class_Redis_setnx arginfo_class_Redis_append\n\n#define arginfo_class_Redis_sismember arginfo_class_Redis_append\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_slaveof, 0, 0, 0)\n\tZEND_ARG_INFO(0, host)\n\tZEND_ARG_INFO(0, port)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_replicaof arginfo_class_Redis_slaveof\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_touch, 0, 0, 1)\n\tZEND_ARG_INFO(0, key_or_array)\n\tZEND_ARG_VARIADIC_INFO(0, more_keys)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_slowlog, 0, 0, 1)\n\tZEND_ARG_INFO(0, operation)\n\tZEND_ARG_INFO(0, length)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_sort arginfo_class_Redis_getEx\n\n#define arginfo_class_Redis_sort_ro arginfo_class_Redis_getEx\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_sortAsc, 0, 0, 1)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, pattern)\n\tZEND_ARG_INFO(0, get)\n\tZEND_ARG_INFO(0, offset)\n\tZEND_ARG_INFO(0, count)\n\tZEND_ARG_INFO(0, store)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_sortAscAlpha arginfo_class_Redis_sortAsc\n\n#define arginfo_class_Redis_sortDesc arginfo_class_Redis_sortAsc\n\n#define arginfo_class_Redis_sortDescAlpha arginfo_class_Redis_sortAsc\n\n#define arginfo_class_Redis_srem arginfo_class_Redis_sAdd\n\n#define arginfo_class_Redis_sscan arginfo_class_Redis_hscan\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_ssubscribe, 0, 0, 2)\n\tZEND_ARG_INFO(0, channels)\n\tZEND_ARG_INFO(0, cb)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_strlen arginfo_class_Redis__prefix\n\n#define arginfo_class_Redis_subscribe arginfo_class_Redis_ssubscribe\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_sunsubscribe, 0, 0, 1)\n\tZEND_ARG_INFO(0, channels)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_swapdb, 0, 0, 2)\n\tZEND_ARG_INFO(0, src)\n\tZEND_ARG_INFO(0, dst)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_time arginfo_class_Redis___destruct\n\n#define arginfo_class_Redis_ttl arginfo_class_Redis__prefix\n\n#define arginfo_class_Redis_type arginfo_class_Redis__prefix\n\n#define arginfo_class_Redis_unlink arginfo_class_Redis_del\n\n#define arginfo_class_Redis_unsubscribe arginfo_class_Redis_sunsubscribe\n\n#define arginfo_class_Redis_unwatch arginfo_class_Redis___destruct\n\n#define arginfo_class_Redis_watch arginfo_class_Redis_del\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_wait, 0, 0, 2)\n\tZEND_ARG_INFO(0, numreplicas)\n\tZEND_ARG_INFO(0, timeout)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_xack, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, group)\n\tZEND_ARG_INFO(0, ids)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_xadd, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, id)\n\tZEND_ARG_INFO(0, values)\n\tZEND_ARG_INFO(0, maxlen)\n\tZEND_ARG_INFO(0, approx)\n\tZEND_ARG_INFO(0, nomkstream)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_xautoclaim, 0, 0, 5)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, group)\n\tZEND_ARG_INFO(0, consumer)\n\tZEND_ARG_INFO(0, min_idle)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, count)\n\tZEND_ARG_INFO(0, justid)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_xclaim, 0, 0, 6)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, group)\n\tZEND_ARG_INFO(0, consumer)\n\tZEND_ARG_INFO(0, min_idle)\n\tZEND_ARG_INFO(0, ids)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_xdel, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, ids)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_xgroup, 0, 0, 1)\n\tZEND_ARG_INFO(0, operation)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, group)\n\tZEND_ARG_INFO(0, id_or_consumer)\n\tZEND_ARG_INFO(0, mkstream)\n\tZEND_ARG_INFO(0, entries_read)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_xinfo, 0, 0, 1)\n\tZEND_ARG_INFO(0, operation)\n\tZEND_ARG_INFO(0, arg1)\n\tZEND_ARG_INFO(0, arg2)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_xlen arginfo_class_Redis__prefix\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_xpending, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, group)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, end)\n\tZEND_ARG_INFO(0, count)\n\tZEND_ARG_INFO(0, consumer)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_xrange, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, end)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_xread, 0, 0, 1)\n\tZEND_ARG_INFO(0, streams)\n\tZEND_ARG_INFO(0, count)\n\tZEND_ARG_INFO(0, block)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_xreadgroup, 0, 0, 3)\n\tZEND_ARG_INFO(0, group)\n\tZEND_ARG_INFO(0, consumer)\n\tZEND_ARG_INFO(0, streams)\n\tZEND_ARG_INFO(0, count)\n\tZEND_ARG_INFO(0, block)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_xrevrange, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, end)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_xtrim, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, threshold)\n\tZEND_ARG_INFO(0, approx)\n\tZEND_ARG_INFO(0, minid)\n\tZEND_ARG_INFO(0, limit)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_zAdd, 0, 0, 2)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, score_or_options)\n\tZEND_ARG_VARIADIC_INFO(0, more_scores_and_mems)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_zCard arginfo_class_Redis__prefix\n\n#define arginfo_class_Redis_zCount arginfo_class_Redis_getRange\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_zIncrBy, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, value)\n\tZEND_ARG_INFO(0, member)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_zLexCount, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, min)\n\tZEND_ARG_INFO(0, max)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_zMscore arginfo_class_Redis_geohash\n\n#define arginfo_class_Redis_zPopMax arginfo_class_Redis_lPop\n\n#define arginfo_class_Redis_zPopMin arginfo_class_Redis_lPop\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_zRange, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, end)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_zRangeByLex, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, min)\n\tZEND_ARG_INFO(0, max)\n\tZEND_ARG_INFO(0, offset)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_zRangeByScore arginfo_class_Redis_zRange\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_zrangestore, 0, 0, 4)\n\tZEND_ARG_INFO(0, dstkey)\n\tZEND_ARG_INFO(0, srckey)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, end)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_zRandMember arginfo_class_Redis_getEx\n\n#define arginfo_class_Redis_zRank arginfo_class_Redis_hGet\n\n#define arginfo_class_Redis_zRem arginfo_class_Redis_geohash\n\n#define arginfo_class_Redis_zRemRangeByLex arginfo_class_Redis_zLexCount\n\n#define arginfo_class_Redis_zRemRangeByRank arginfo_class_Redis_getRange\n\n#define arginfo_class_Redis_zRemRangeByScore arginfo_class_Redis_getRange\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_zRevRange, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, start)\n\tZEND_ARG_INFO(0, end)\n\tZEND_ARG_INFO(0, scores)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_zRevRangeByLex, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, max)\n\tZEND_ARG_INFO(0, min)\n\tZEND_ARG_INFO(0, offset)\n\tZEND_ARG_INFO(0, count)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_zRevRangeByScore, 0, 0, 3)\n\tZEND_ARG_INFO(0, key)\n\tZEND_ARG_INFO(0, max)\n\tZEND_ARG_INFO(0, min)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_zRevRank arginfo_class_Redis_hGet\n\n#define arginfo_class_Redis_zScore arginfo_class_Redis_hGet\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_zdiff, 0, 0, 1)\n\tZEND_ARG_INFO(0, keys)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_zdiffstore, 0, 0, 2)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, keys)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_zinter, 0, 0, 1)\n\tZEND_ARG_INFO(0, keys)\n\tZEND_ARG_INFO(0, weights)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_zintercard arginfo_class_Redis_sintercard\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_Redis_zinterstore, 0, 0, 2)\n\tZEND_ARG_INFO(0, dst)\n\tZEND_ARG_INFO(0, keys)\n\tZEND_ARG_INFO(0, weights)\n\tZEND_ARG_INFO(0, aggregate)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_Redis_zscan arginfo_class_Redis_hscan\n\n#define arginfo_class_Redis_zunion arginfo_class_Redis_zinter\n\n#define arginfo_class_Redis_zunionstore arginfo_class_Redis_zinterstore\n\n\nZEND_METHOD(Redis, __construct);\nZEND_METHOD(Redis, __destruct);\nZEND_METHOD(Redis, _compress);\nZEND_METHOD(Redis, _uncompress);\nZEND_METHOD(Redis, _prefix);\nZEND_METHOD(Redis, _serialize);\nZEND_METHOD(Redis, _unserialize);\nZEND_METHOD(Redis, _pack);\nZEND_METHOD(Redis, _unpack);\nZEND_METHOD(Redis, acl);\nZEND_METHOD(Redis, append);\nZEND_METHOD(Redis, auth);\nZEND_METHOD(Redis, bgSave);\nZEND_METHOD(Redis, bgrewriteaof);\nZEND_METHOD(Redis, waitaof);\nZEND_METHOD(Redis, bitcount);\nZEND_METHOD(Redis, bitop);\nZEND_METHOD(Redis, bitpos);\nZEND_METHOD(Redis, blPop);\nZEND_METHOD(Redis, brPop);\nZEND_METHOD(Redis, brpoplpush);\nZEND_METHOD(Redis, bzPopMax);\nZEND_METHOD(Redis, bzPopMin);\nZEND_METHOD(Redis, bzmpop);\nZEND_METHOD(Redis, zmpop);\nZEND_METHOD(Redis, blmpop);\nZEND_METHOD(Redis, lmpop);\nZEND_METHOD(Redis, clearLastError);\nZEND_METHOD(Redis, client);\nZEND_METHOD(Redis, close);\nZEND_METHOD(Redis, command);\nZEND_METHOD(Redis, config);\nZEND_METHOD(Redis, connect);\nZEND_METHOD(Redis, copy);\nZEND_METHOD(Redis, dbSize);\nZEND_METHOD(Redis, debug);\nZEND_METHOD(Redis, decr);\nZEND_METHOD(Redis, decrBy);\nZEND_METHOD(Redis, del);\nZEND_METHOD(Redis, discard);\nZEND_METHOD(Redis, dump);\nZEND_METHOD(Redis, echo);\nZEND_METHOD(Redis, eval);\nZEND_METHOD(Redis, eval_ro);\nZEND_METHOD(Redis, evalsha);\nZEND_METHOD(Redis, evalsha_ro);\nZEND_METHOD(Redis, exec);\nZEND_METHOD(Redis, exists);\nZEND_METHOD(Redis, expire);\nZEND_METHOD(Redis, expireAt);\nZEND_METHOD(Redis, failover);\nZEND_METHOD(Redis, expiretime);\nZEND_METHOD(Redis, pexpiretime);\nZEND_METHOD(Redis, fcall);\nZEND_METHOD(Redis, fcall_ro);\nZEND_METHOD(Redis, flushAll);\nZEND_METHOD(Redis, flushDB);\nZEND_METHOD(Redis, function);\nZEND_METHOD(Redis, geoadd);\nZEND_METHOD(Redis, geodist);\nZEND_METHOD(Redis, geohash);\nZEND_METHOD(Redis, geopos);\nZEND_METHOD(Redis, georadius);\nZEND_METHOD(Redis, georadius_ro);\nZEND_METHOD(Redis, georadiusbymember);\nZEND_METHOD(Redis, georadiusbymember_ro);\nZEND_METHOD(Redis, geosearch);\nZEND_METHOD(Redis, geosearchstore);\nZEND_METHOD(Redis, get);\nZEND_METHOD(Redis, getAuth);\nZEND_METHOD(Redis, getBit);\nZEND_METHOD(Redis, getEx);\nZEND_METHOD(Redis, getDBNum);\nZEND_METHOD(Redis, getDel);\nZEND_METHOD(Redis, getHost);\nZEND_METHOD(Redis, getLastError);\nZEND_METHOD(Redis, getMode);\nZEND_METHOD(Redis, getOption);\nZEND_METHOD(Redis, getPersistentID);\nZEND_METHOD(Redis, getPort);\nZEND_METHOD(Redis, getRange);\nZEND_METHOD(Redis, lcs);\nZEND_METHOD(Redis, getReadTimeout);\nZEND_METHOD(Redis, getset);\nZEND_METHOD(Redis, getTimeout);\nZEND_METHOD(Redis, getTransferredBytes);\nZEND_METHOD(Redis, clearTransferredBytes);\nZEND_METHOD(Redis, hDel);\nZEND_METHOD(Redis, hExists);\nZEND_METHOD(Redis, hGet);\nZEND_METHOD(Redis, hGetAll);\nZEND_METHOD(Redis, hIncrBy);\nZEND_METHOD(Redis, hIncrByFloat);\nZEND_METHOD(Redis, hKeys);\nZEND_METHOD(Redis, hLen);\nZEND_METHOD(Redis, hMget);\nZEND_METHOD(Redis, hMset);\nZEND_METHOD(Redis, hRandField);\nZEND_METHOD(Redis, hSet);\nZEND_METHOD(Redis, hSetNx);\nZEND_METHOD(Redis, hStrLen);\nZEND_METHOD(Redis, hVals);\nZEND_METHOD(Redis, hscan);\nZEND_METHOD(Redis, expiremember);\nZEND_METHOD(Redis, expirememberat);\nZEND_METHOD(Redis, incr);\nZEND_METHOD(Redis, incrBy);\nZEND_METHOD(Redis, incrByFloat);\nZEND_METHOD(Redis, info);\nZEND_METHOD(Redis, isConnected);\nZEND_METHOD(Redis, keys);\nZEND_METHOD(Redis, lInsert);\nZEND_METHOD(Redis, lLen);\nZEND_METHOD(Redis, lMove);\nZEND_METHOD(Redis, blmove);\nZEND_METHOD(Redis, lPop);\nZEND_METHOD(Redis, lPos);\nZEND_METHOD(Redis, lPush);\nZEND_METHOD(Redis, rPush);\nZEND_METHOD(Redis, lPushx);\nZEND_METHOD(Redis, rPushx);\nZEND_METHOD(Redis, lSet);\nZEND_METHOD(Redis, lastSave);\nZEND_METHOD(Redis, lindex);\nZEND_METHOD(Redis, lrange);\nZEND_METHOD(Redis, lrem);\nZEND_METHOD(Redis, ltrim);\nZEND_METHOD(Redis, mget);\nZEND_METHOD(Redis, migrate);\nZEND_METHOD(Redis, move);\nZEND_METHOD(Redis, mset);\nZEND_METHOD(Redis, msetnx);\nZEND_METHOD(Redis, multi);\nZEND_METHOD(Redis, object);\nZEND_METHOD(Redis, pconnect);\nZEND_METHOD(Redis, persist);\nZEND_METHOD(Redis, pexpire);\nZEND_METHOD(Redis, pexpireAt);\nZEND_METHOD(Redis, pfadd);\nZEND_METHOD(Redis, pfcount);\nZEND_METHOD(Redis, pfmerge);\nZEND_METHOD(Redis, ping);\nZEND_METHOD(Redis, pipeline);\nZEND_METHOD(Redis, psetex);\nZEND_METHOD(Redis, psubscribe);\nZEND_METHOD(Redis, pttl);\nZEND_METHOD(Redis, publish);\nZEND_METHOD(Redis, pubsub);\nZEND_METHOD(Redis, punsubscribe);\nZEND_METHOD(Redis, rPop);\nZEND_METHOD(Redis, randomKey);\nZEND_METHOD(Redis, rawcommand);\nZEND_METHOD(Redis, rename);\nZEND_METHOD(Redis, renameNx);\nZEND_METHOD(Redis, reset);\nZEND_METHOD(Redis, restore);\nZEND_METHOD(Redis, role);\nZEND_METHOD(Redis, rpoplpush);\nZEND_METHOD(Redis, sAdd);\nZEND_METHOD(Redis, sAddArray);\nZEND_METHOD(Redis, sDiff);\nZEND_METHOD(Redis, sDiffStore);\nZEND_METHOD(Redis, sInter);\nZEND_METHOD(Redis, sintercard);\nZEND_METHOD(Redis, sInterStore);\nZEND_METHOD(Redis, sMembers);\nZEND_METHOD(Redis, sMisMember);\nZEND_METHOD(Redis, sMove);\nZEND_METHOD(Redis, sPop);\nZEND_METHOD(Redis, sRandMember);\nZEND_METHOD(Redis, sUnion);\nZEND_METHOD(Redis, sUnionStore);\nZEND_METHOD(Redis, save);\nZEND_METHOD(Redis, scan);\nZEND_METHOD(Redis, scard);\nZEND_METHOD(Redis, script);\nZEND_METHOD(Redis, select);\nZEND_METHOD(Redis, set);\nZEND_METHOD(Redis, setBit);\nZEND_METHOD(Redis, setRange);\nZEND_METHOD(Redis, setOption);\nZEND_METHOD(Redis, setex);\nZEND_METHOD(Redis, setnx);\nZEND_METHOD(Redis, sismember);\nZEND_METHOD(Redis, slaveof);\nZEND_METHOD(Redis, replicaof);\nZEND_METHOD(Redis, touch);\nZEND_METHOD(Redis, slowlog);\nZEND_METHOD(Redis, sort);\nZEND_METHOD(Redis, sort_ro);\nZEND_METHOD(Redis, sortAsc);\nZEND_METHOD(Redis, sortAscAlpha);\nZEND_METHOD(Redis, sortDesc);\nZEND_METHOD(Redis, sortDescAlpha);\nZEND_METHOD(Redis, srem);\nZEND_METHOD(Redis, sscan);\nZEND_METHOD(Redis, ssubscribe);\nZEND_METHOD(Redis, strlen);\nZEND_METHOD(Redis, subscribe);\nZEND_METHOD(Redis, sunsubscribe);\nZEND_METHOD(Redis, swapdb);\nZEND_METHOD(Redis, time);\nZEND_METHOD(Redis, ttl);\nZEND_METHOD(Redis, type);\nZEND_METHOD(Redis, unlink);\nZEND_METHOD(Redis, unsubscribe);\nZEND_METHOD(Redis, unwatch);\nZEND_METHOD(Redis, watch);\nZEND_METHOD(Redis, wait);\nZEND_METHOD(Redis, xack);\nZEND_METHOD(Redis, xadd);\nZEND_METHOD(Redis, xautoclaim);\nZEND_METHOD(Redis, xclaim);\nZEND_METHOD(Redis, xdel);\nZEND_METHOD(Redis, xgroup);\nZEND_METHOD(Redis, xinfo);\nZEND_METHOD(Redis, xlen);\nZEND_METHOD(Redis, xpending);\nZEND_METHOD(Redis, xrange);\nZEND_METHOD(Redis, xread);\nZEND_METHOD(Redis, xreadgroup);\nZEND_METHOD(Redis, xrevrange);\nZEND_METHOD(Redis, xtrim);\nZEND_METHOD(Redis, zAdd);\nZEND_METHOD(Redis, zCard);\nZEND_METHOD(Redis, zCount);\nZEND_METHOD(Redis, zIncrBy);\nZEND_METHOD(Redis, zLexCount);\nZEND_METHOD(Redis, zMscore);\nZEND_METHOD(Redis, zPopMax);\nZEND_METHOD(Redis, zPopMin);\nZEND_METHOD(Redis, zRange);\nZEND_METHOD(Redis, zRangeByLex);\nZEND_METHOD(Redis, zRangeByScore);\nZEND_METHOD(Redis, zrangestore);\nZEND_METHOD(Redis, zRandMember);\nZEND_METHOD(Redis, zRank);\nZEND_METHOD(Redis, zRem);\nZEND_METHOD(Redis, zRemRangeByLex);\nZEND_METHOD(Redis, zRemRangeByRank);\nZEND_METHOD(Redis, zRemRangeByScore);\nZEND_METHOD(Redis, zRevRange);\nZEND_METHOD(Redis, zRevRangeByLex);\nZEND_METHOD(Redis, zRevRangeByScore);\nZEND_METHOD(Redis, zRevRank);\nZEND_METHOD(Redis, zScore);\nZEND_METHOD(Redis, zdiff);\nZEND_METHOD(Redis, zdiffstore);\nZEND_METHOD(Redis, zinter);\nZEND_METHOD(Redis, zintercard);\nZEND_METHOD(Redis, zinterstore);\nZEND_METHOD(Redis, zscan);\nZEND_METHOD(Redis, zunion);\nZEND_METHOD(Redis, zunionstore);\n\n\nstatic const zend_function_entry class_Redis_methods[] = {\n\tZEND_ME(Redis, __construct, arginfo_class_Redis___construct, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, __destruct, arginfo_class_Redis___destruct, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, _compress, arginfo_class_Redis__compress, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, _uncompress, arginfo_class_Redis__uncompress, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, _prefix, arginfo_class_Redis__prefix, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, _serialize, arginfo_class_Redis__serialize, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, _unserialize, arginfo_class_Redis__unserialize, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, _pack, arginfo_class_Redis__pack, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, _unpack, arginfo_class_Redis__unpack, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, acl, arginfo_class_Redis_acl, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, append, arginfo_class_Redis_append, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, auth, arginfo_class_Redis_auth, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bgSave, arginfo_class_Redis_bgSave, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bgrewriteaof, arginfo_class_Redis_bgrewriteaof, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, waitaof, arginfo_class_Redis_waitaof, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bitcount, arginfo_class_Redis_bitcount, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bitop, arginfo_class_Redis_bitop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bitpos, arginfo_class_Redis_bitpos, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, blPop, arginfo_class_Redis_blPop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, brPop, arginfo_class_Redis_brPop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, brpoplpush, arginfo_class_Redis_brpoplpush, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bzPopMax, arginfo_class_Redis_bzPopMax, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bzPopMin, arginfo_class_Redis_bzPopMin, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, bzmpop, arginfo_class_Redis_bzmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zmpop, arginfo_class_Redis_zmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, blmpop, arginfo_class_Redis_blmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lmpop, arginfo_class_Redis_lmpop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, clearLastError, arginfo_class_Redis_clearLastError, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, client, arginfo_class_Redis_client, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, close, arginfo_class_Redis_close, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, command, arginfo_class_Redis_command, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, config, arginfo_class_Redis_config, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, connect, arginfo_class_Redis_connect, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, copy, arginfo_class_Redis_copy, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, dbSize, arginfo_class_Redis_dbSize, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, debug, arginfo_class_Redis_debug, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, decr, arginfo_class_Redis_decr, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, decrBy, arginfo_class_Redis_decrBy, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, del, arginfo_class_Redis_del, ZEND_ACC_PUBLIC)\n\tZEND_MALIAS(Redis, delete, del, arginfo_class_Redis_delete, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, discard, arginfo_class_Redis_discard, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, dump, arginfo_class_Redis_dump, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, echo, arginfo_class_Redis_echo, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, eval, arginfo_class_Redis_eval, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, eval_ro, arginfo_class_Redis_eval_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, evalsha, arginfo_class_Redis_evalsha, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, evalsha_ro, arginfo_class_Redis_evalsha_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, exec, arginfo_class_Redis_exec, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, exists, arginfo_class_Redis_exists, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, expire, arginfo_class_Redis_expire, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, expireAt, arginfo_class_Redis_expireAt, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, failover, arginfo_class_Redis_failover, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, expiretime, arginfo_class_Redis_expiretime, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pexpiretime, arginfo_class_Redis_pexpiretime, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, fcall, arginfo_class_Redis_fcall, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, fcall_ro, arginfo_class_Redis_fcall_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, flushAll, arginfo_class_Redis_flushAll, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, flushDB, arginfo_class_Redis_flushDB, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, function, arginfo_class_Redis_function, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, geoadd, arginfo_class_Redis_geoadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, geodist, arginfo_class_Redis_geodist, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, geohash, arginfo_class_Redis_geohash, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, geopos, arginfo_class_Redis_geopos, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, georadius, arginfo_class_Redis_georadius, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, georadius_ro, arginfo_class_Redis_georadius_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, georadiusbymember, arginfo_class_Redis_georadiusbymember, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, georadiusbymember_ro, arginfo_class_Redis_georadiusbymember_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, geosearch, arginfo_class_Redis_geosearch, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, geosearchstore, arginfo_class_Redis_geosearchstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, get, arginfo_class_Redis_get, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getAuth, arginfo_class_Redis_getAuth, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getBit, arginfo_class_Redis_getBit, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getEx, arginfo_class_Redis_getEx, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getDBNum, arginfo_class_Redis_getDBNum, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getDel, arginfo_class_Redis_getDel, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getHost, arginfo_class_Redis_getHost, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getLastError, arginfo_class_Redis_getLastError, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getMode, arginfo_class_Redis_getMode, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getOption, arginfo_class_Redis_getOption, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getPersistentID, arginfo_class_Redis_getPersistentID, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getPort, arginfo_class_Redis_getPort, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getRange, arginfo_class_Redis_getRange, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lcs, arginfo_class_Redis_lcs, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getReadTimeout, arginfo_class_Redis_getReadTimeout, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getset, arginfo_class_Redis_getset, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getTimeout, arginfo_class_Redis_getTimeout, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, getTransferredBytes, arginfo_class_Redis_getTransferredBytes, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, clearTransferredBytes, arginfo_class_Redis_clearTransferredBytes, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hDel, arginfo_class_Redis_hDel, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hExists, arginfo_class_Redis_hExists, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hGet, arginfo_class_Redis_hGet, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hGetAll, arginfo_class_Redis_hGetAll, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hIncrBy, arginfo_class_Redis_hIncrBy, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hIncrByFloat, arginfo_class_Redis_hIncrByFloat, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hKeys, arginfo_class_Redis_hKeys, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hLen, arginfo_class_Redis_hLen, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hMget, arginfo_class_Redis_hMget, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hMset, arginfo_class_Redis_hMset, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hRandField, arginfo_class_Redis_hRandField, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hSet, arginfo_class_Redis_hSet, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hSetNx, arginfo_class_Redis_hSetNx, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hStrLen, arginfo_class_Redis_hStrLen, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hVals, arginfo_class_Redis_hVals, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, hscan, arginfo_class_Redis_hscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, expiremember, arginfo_class_Redis_expiremember, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, expirememberat, arginfo_class_Redis_expirememberat, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, incr, arginfo_class_Redis_incr, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, incrBy, arginfo_class_Redis_incrBy, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, incrByFloat, arginfo_class_Redis_incrByFloat, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, info, arginfo_class_Redis_info, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, isConnected, arginfo_class_Redis_isConnected, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, keys, arginfo_class_Redis_keys, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lInsert, arginfo_class_Redis_lInsert, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lLen, arginfo_class_Redis_lLen, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lMove, arginfo_class_Redis_lMove, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, blmove, arginfo_class_Redis_blmove, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lPop, arginfo_class_Redis_lPop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lPos, arginfo_class_Redis_lPos, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lPush, arginfo_class_Redis_lPush, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, rPush, arginfo_class_Redis_rPush, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lPushx, arginfo_class_Redis_lPushx, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, rPushx, arginfo_class_Redis_rPushx, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lSet, arginfo_class_Redis_lSet, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lastSave, arginfo_class_Redis_lastSave, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lindex, arginfo_class_Redis_lindex, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lrange, arginfo_class_Redis_lrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, lrem, arginfo_class_Redis_lrem, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, ltrim, arginfo_class_Redis_ltrim, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, mget, arginfo_class_Redis_mget, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, migrate, arginfo_class_Redis_migrate, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, move, arginfo_class_Redis_move, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, mset, arginfo_class_Redis_mset, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, msetnx, arginfo_class_Redis_msetnx, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, multi, arginfo_class_Redis_multi, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, object, arginfo_class_Redis_object, ZEND_ACC_PUBLIC)\n\tZEND_MALIAS(Redis, open, connect, arginfo_class_Redis_open, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, pconnect, arginfo_class_Redis_pconnect, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, persist, arginfo_class_Redis_persist, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pexpire, arginfo_class_Redis_pexpire, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pexpireAt, arginfo_class_Redis_pexpireAt, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pfadd, arginfo_class_Redis_pfadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pfcount, arginfo_class_Redis_pfcount, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pfmerge, arginfo_class_Redis_pfmerge, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, ping, arginfo_class_Redis_ping, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pipeline, arginfo_class_Redis_pipeline, ZEND_ACC_PUBLIC)\n\tZEND_MALIAS(Redis, popen, pconnect, arginfo_class_Redis_popen, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, psetex, arginfo_class_Redis_psetex, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, psubscribe, arginfo_class_Redis_psubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pttl, arginfo_class_Redis_pttl, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, publish, arginfo_class_Redis_publish, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, pubsub, arginfo_class_Redis_pubsub, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, punsubscribe, arginfo_class_Redis_punsubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, rPop, arginfo_class_Redis_rPop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, randomKey, arginfo_class_Redis_randomKey, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, rawcommand, arginfo_class_Redis_rawcommand, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, rename, arginfo_class_Redis_rename, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, renameNx, arginfo_class_Redis_renameNx, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, reset, arginfo_class_Redis_reset, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, restore, arginfo_class_Redis_restore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, role, arginfo_class_Redis_role, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, rpoplpush, arginfo_class_Redis_rpoplpush, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sAdd, arginfo_class_Redis_sAdd, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sAddArray, arginfo_class_Redis_sAddArray, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sDiff, arginfo_class_Redis_sDiff, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sDiffStore, arginfo_class_Redis_sDiffStore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sInter, arginfo_class_Redis_sInter, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sintercard, arginfo_class_Redis_sintercard, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sInterStore, arginfo_class_Redis_sInterStore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sMembers, arginfo_class_Redis_sMembers, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sMisMember, arginfo_class_Redis_sMisMember, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sMove, arginfo_class_Redis_sMove, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sPop, arginfo_class_Redis_sPop, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sRandMember, arginfo_class_Redis_sRandMember, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sUnion, arginfo_class_Redis_sUnion, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sUnionStore, arginfo_class_Redis_sUnionStore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, save, arginfo_class_Redis_save, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, scan, arginfo_class_Redis_scan, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, scard, arginfo_class_Redis_scard, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, script, arginfo_class_Redis_script, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, select, arginfo_class_Redis_select, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, set, arginfo_class_Redis_set, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, setBit, arginfo_class_Redis_setBit, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, setRange, arginfo_class_Redis_setRange, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, setOption, arginfo_class_Redis_setOption, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, setex, arginfo_class_Redis_setex, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, setnx, arginfo_class_Redis_setnx, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sismember, arginfo_class_Redis_sismember, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, slaveof, arginfo_class_Redis_slaveof, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, replicaof, arginfo_class_Redis_replicaof, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, touch, arginfo_class_Redis_touch, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, slowlog, arginfo_class_Redis_slowlog, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sort, arginfo_class_Redis_sort, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sort_ro, arginfo_class_Redis_sort_ro, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sortAsc, arginfo_class_Redis_sortAsc, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, sortAscAlpha, arginfo_class_Redis_sortAscAlpha, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, sortDesc, arginfo_class_Redis_sortDesc, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, sortDescAlpha, arginfo_class_Redis_sortDescAlpha, ZEND_ACC_PUBLIC|ZEND_ACC_DEPRECATED)\n\tZEND_ME(Redis, srem, arginfo_class_Redis_srem, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sscan, arginfo_class_Redis_sscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, ssubscribe, arginfo_class_Redis_ssubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, strlen, arginfo_class_Redis_strlen, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, subscribe, arginfo_class_Redis_subscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, sunsubscribe, arginfo_class_Redis_sunsubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, swapdb, arginfo_class_Redis_swapdb, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, time, arginfo_class_Redis_time, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, ttl, arginfo_class_Redis_ttl, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, type, arginfo_class_Redis_type, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, unlink, arginfo_class_Redis_unlink, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, unsubscribe, arginfo_class_Redis_unsubscribe, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, unwatch, arginfo_class_Redis_unwatch, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, watch, arginfo_class_Redis_watch, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, wait, arginfo_class_Redis_wait, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xack, arginfo_class_Redis_xack, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xadd, arginfo_class_Redis_xadd, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xautoclaim, arginfo_class_Redis_xautoclaim, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xclaim, arginfo_class_Redis_xclaim, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xdel, arginfo_class_Redis_xdel, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xgroup, arginfo_class_Redis_xgroup, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xinfo, arginfo_class_Redis_xinfo, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xlen, arginfo_class_Redis_xlen, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xpending, arginfo_class_Redis_xpending, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xrange, arginfo_class_Redis_xrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xread, arginfo_class_Redis_xread, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xreadgroup, arginfo_class_Redis_xreadgroup, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xrevrange, arginfo_class_Redis_xrevrange, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, xtrim, arginfo_class_Redis_xtrim, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zAdd, arginfo_class_Redis_zAdd, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zCard, arginfo_class_Redis_zCard, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zCount, arginfo_class_Redis_zCount, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zIncrBy, arginfo_class_Redis_zIncrBy, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zLexCount, arginfo_class_Redis_zLexCount, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zMscore, arginfo_class_Redis_zMscore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zPopMax, arginfo_class_Redis_zPopMax, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zPopMin, arginfo_class_Redis_zPopMin, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRange, arginfo_class_Redis_zRange, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRangeByLex, arginfo_class_Redis_zRangeByLex, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRangeByScore, arginfo_class_Redis_zRangeByScore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zrangestore, arginfo_class_Redis_zrangestore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRandMember, arginfo_class_Redis_zRandMember, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRank, arginfo_class_Redis_zRank, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRem, arginfo_class_Redis_zRem, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRemRangeByLex, arginfo_class_Redis_zRemRangeByLex, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRemRangeByRank, arginfo_class_Redis_zRemRangeByRank, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRemRangeByScore, arginfo_class_Redis_zRemRangeByScore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRevRange, arginfo_class_Redis_zRevRange, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRevRangeByLex, arginfo_class_Redis_zRevRangeByLex, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRevRangeByScore, arginfo_class_Redis_zRevRangeByScore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zRevRank, arginfo_class_Redis_zRevRank, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zScore, arginfo_class_Redis_zScore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zdiff, arginfo_class_Redis_zdiff, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zdiffstore, arginfo_class_Redis_zdiffstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zinter, arginfo_class_Redis_zinter, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zintercard, arginfo_class_Redis_zintercard, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zinterstore, arginfo_class_Redis_zinterstore, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zscan, arginfo_class_Redis_zscan, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zunion, arginfo_class_Redis_zunion, ZEND_ACC_PUBLIC)\n\tZEND_ME(Redis, zunionstore, arginfo_class_Redis_zunionstore, ZEND_ACC_PUBLIC)\n\tZEND_FE_END\n};\n\n\nstatic const zend_function_entry class_RedisException_methods[] = {\n\tZEND_FE_END\n};\n\nstatic zend_class_entry *register_class_Redis(void)\n{\n\tzend_class_entry ce, *class_entry;\n\n\tINIT_CLASS_ENTRY(ce, \"Redis\", class_Redis_methods);\n\tclass_entry = zend_register_internal_class_ex(&ce, NULL);\n\n\tzval const_REDIS_NOT_FOUND_value;\n\tZVAL_LONG(&const_REDIS_NOT_FOUND_value, REDIS_NOT_FOUND);\n\tzend_string *const_REDIS_NOT_FOUND_name = zend_string_init_interned(\"REDIS_NOT_FOUND\", sizeof(\"REDIS_NOT_FOUND\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_REDIS_NOT_FOUND_name, &const_REDIS_NOT_FOUND_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_REDIS_NOT_FOUND_name);\n\n\tzval const_REDIS_STRING_value;\n\tZVAL_LONG(&const_REDIS_STRING_value, REDIS_STRING);\n\tzend_string *const_REDIS_STRING_name = zend_string_init_interned(\"REDIS_STRING\", sizeof(\"REDIS_STRING\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_REDIS_STRING_name, &const_REDIS_STRING_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_REDIS_STRING_name);\n\n\tzval const_REDIS_SET_value;\n\tZVAL_LONG(&const_REDIS_SET_value, REDIS_SET);\n\tzend_string *const_REDIS_SET_name = zend_string_init_interned(\"REDIS_SET\", sizeof(\"REDIS_SET\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_REDIS_SET_name, &const_REDIS_SET_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_REDIS_SET_name);\n\n\tzval const_REDIS_LIST_value;\n\tZVAL_LONG(&const_REDIS_LIST_value, REDIS_LIST);\n\tzend_string *const_REDIS_LIST_name = zend_string_init_interned(\"REDIS_LIST\", sizeof(\"REDIS_LIST\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_REDIS_LIST_name, &const_REDIS_LIST_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_REDIS_LIST_name);\n\n\tzval const_REDIS_ZSET_value;\n\tZVAL_LONG(&const_REDIS_ZSET_value, REDIS_ZSET);\n\tzend_string *const_REDIS_ZSET_name = zend_string_init_interned(\"REDIS_ZSET\", sizeof(\"REDIS_ZSET\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_REDIS_ZSET_name, &const_REDIS_ZSET_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_REDIS_ZSET_name);\n\n\tzval const_REDIS_HASH_value;\n\tZVAL_LONG(&const_REDIS_HASH_value, REDIS_HASH);\n\tzend_string *const_REDIS_HASH_name = zend_string_init_interned(\"REDIS_HASH\", sizeof(\"REDIS_HASH\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_REDIS_HASH_name, &const_REDIS_HASH_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_REDIS_HASH_name);\n\n\tzval const_REDIS_STREAM_value;\n\tZVAL_LONG(&const_REDIS_STREAM_value, REDIS_STREAM);\n\tzend_string *const_REDIS_STREAM_name = zend_string_init_interned(\"REDIS_STREAM\", sizeof(\"REDIS_STREAM\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_REDIS_STREAM_name, &const_REDIS_STREAM_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_REDIS_STREAM_name);\n\n\tzval const_ATOMIC_value;\n\tZVAL_LONG(&const_ATOMIC_value, ATOMIC);\n\tzend_string *const_ATOMIC_name = zend_string_init_interned(\"ATOMIC\", sizeof(\"ATOMIC\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_ATOMIC_name, &const_ATOMIC_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_ATOMIC_name);\n\n\tzval const_MULTI_value;\n\tZVAL_LONG(&const_MULTI_value, MULTI);\n\tzend_string *const_MULTI_name = zend_string_init_interned(\"MULTI\", sizeof(\"MULTI\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_MULTI_name, &const_MULTI_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_MULTI_name);\n\n\tzval const_PIPELINE_value;\n\tZVAL_LONG(&const_PIPELINE_value, PIPELINE);\n\tzend_string *const_PIPELINE_name = zend_string_init_interned(\"PIPELINE\", sizeof(\"PIPELINE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_PIPELINE_name, &const_PIPELINE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_PIPELINE_name);\n\n\tzval const_OPT_SERIALIZER_value;\n\tZVAL_LONG(&const_OPT_SERIALIZER_value, REDIS_OPT_SERIALIZER);\n\tzend_string *const_OPT_SERIALIZER_name = zend_string_init_interned(\"OPT_SERIALIZER\", sizeof(\"OPT_SERIALIZER\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_SERIALIZER_name, &const_OPT_SERIALIZER_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_SERIALIZER_name);\n\n\tzval const_OPT_PREFIX_value;\n\tZVAL_LONG(&const_OPT_PREFIX_value, REDIS_OPT_PREFIX);\n\tzend_string *const_OPT_PREFIX_name = zend_string_init_interned(\"OPT_PREFIX\", sizeof(\"OPT_PREFIX\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_PREFIX_name, &const_OPT_PREFIX_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_PREFIX_name);\n\n\tzval const_OPT_READ_TIMEOUT_value;\n\tZVAL_LONG(&const_OPT_READ_TIMEOUT_value, REDIS_OPT_READ_TIMEOUT);\n\tzend_string *const_OPT_READ_TIMEOUT_name = zend_string_init_interned(\"OPT_READ_TIMEOUT\", sizeof(\"OPT_READ_TIMEOUT\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_READ_TIMEOUT_name, &const_OPT_READ_TIMEOUT_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_READ_TIMEOUT_name);\n\n\tzval const_OPT_TCP_KEEPALIVE_value;\n\tZVAL_LONG(&const_OPT_TCP_KEEPALIVE_value, REDIS_OPT_TCP_KEEPALIVE);\n\tzend_string *const_OPT_TCP_KEEPALIVE_name = zend_string_init_interned(\"OPT_TCP_KEEPALIVE\", sizeof(\"OPT_TCP_KEEPALIVE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_TCP_KEEPALIVE_name, &const_OPT_TCP_KEEPALIVE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_TCP_KEEPALIVE_name);\n\n\tzval const_OPT_COMPRESSION_value;\n\tZVAL_LONG(&const_OPT_COMPRESSION_value, REDIS_OPT_COMPRESSION);\n\tzend_string *const_OPT_COMPRESSION_name = zend_string_init_interned(\"OPT_COMPRESSION\", sizeof(\"OPT_COMPRESSION\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_COMPRESSION_name, &const_OPT_COMPRESSION_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_COMPRESSION_name);\n\n\tzval const_OPT_REPLY_LITERAL_value;\n\tZVAL_LONG(&const_OPT_REPLY_LITERAL_value, REDIS_OPT_REPLY_LITERAL);\n\tzend_string *const_OPT_REPLY_LITERAL_name = zend_string_init_interned(\"OPT_REPLY_LITERAL\", sizeof(\"OPT_REPLY_LITERAL\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_REPLY_LITERAL_name, &const_OPT_REPLY_LITERAL_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_REPLY_LITERAL_name);\n\n\tzval const_OPT_COMPRESSION_LEVEL_value;\n\tZVAL_LONG(&const_OPT_COMPRESSION_LEVEL_value, REDIS_OPT_COMPRESSION_LEVEL);\n\tzend_string *const_OPT_COMPRESSION_LEVEL_name = zend_string_init_interned(\"OPT_COMPRESSION_LEVEL\", sizeof(\"OPT_COMPRESSION_LEVEL\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_COMPRESSION_LEVEL_name, &const_OPT_COMPRESSION_LEVEL_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_COMPRESSION_LEVEL_name);\n\n\tzval const_OPT_NULL_MULTIBULK_AS_NULL_value;\n\tZVAL_LONG(&const_OPT_NULL_MULTIBULK_AS_NULL_value, REDIS_OPT_NULL_MBULK_AS_NULL);\n\tzend_string *const_OPT_NULL_MULTIBULK_AS_NULL_name = zend_string_init_interned(\"OPT_NULL_MULTIBULK_AS_NULL\", sizeof(\"OPT_NULL_MULTIBULK_AS_NULL\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_NULL_MULTIBULK_AS_NULL_name, &const_OPT_NULL_MULTIBULK_AS_NULL_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_NULL_MULTIBULK_AS_NULL_name);\n\n\tzval const_SERIALIZER_NONE_value;\n\tZVAL_LONG(&const_SERIALIZER_NONE_value, REDIS_SERIALIZER_NONE);\n\tzend_string *const_SERIALIZER_NONE_name = zend_string_init_interned(\"SERIALIZER_NONE\", sizeof(\"SERIALIZER_NONE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SERIALIZER_NONE_name, &const_SERIALIZER_NONE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SERIALIZER_NONE_name);\n\n\tzval const_SERIALIZER_PHP_value;\n\tZVAL_LONG(&const_SERIALIZER_PHP_value, REDIS_SERIALIZER_PHP);\n\tzend_string *const_SERIALIZER_PHP_name = zend_string_init_interned(\"SERIALIZER_PHP\", sizeof(\"SERIALIZER_PHP\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SERIALIZER_PHP_name, &const_SERIALIZER_PHP_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SERIALIZER_PHP_name);\n#if defined(HAVE_REDIS_IGBINARY)\n\n\tzval const_SERIALIZER_IGBINARY_value;\n\tZVAL_LONG(&const_SERIALIZER_IGBINARY_value, REDIS_SERIALIZER_IGBINARY);\n\tzend_string *const_SERIALIZER_IGBINARY_name = zend_string_init_interned(\"SERIALIZER_IGBINARY\", sizeof(\"SERIALIZER_IGBINARY\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SERIALIZER_IGBINARY_name, &const_SERIALIZER_IGBINARY_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SERIALIZER_IGBINARY_name);\n#endif\n#if defined(HAVE_REDIS_MSGPACK)\n\n\tzval const_SERIALIZER_MSGPACK_value;\n\tZVAL_LONG(&const_SERIALIZER_MSGPACK_value, REDIS_SERIALIZER_MSGPACK);\n\tzend_string *const_SERIALIZER_MSGPACK_name = zend_string_init_interned(\"SERIALIZER_MSGPACK\", sizeof(\"SERIALIZER_MSGPACK\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SERIALIZER_MSGPACK_name, &const_SERIALIZER_MSGPACK_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SERIALIZER_MSGPACK_name);\n#endif\n\n\tzval const_SERIALIZER_JSON_value;\n\tZVAL_LONG(&const_SERIALIZER_JSON_value, REDIS_SERIALIZER_JSON);\n\tzend_string *const_SERIALIZER_JSON_name = zend_string_init_interned(\"SERIALIZER_JSON\", sizeof(\"SERIALIZER_JSON\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SERIALIZER_JSON_name, &const_SERIALIZER_JSON_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SERIALIZER_JSON_name);\n\n\tzval const_COMPRESSION_NONE_value;\n\tZVAL_LONG(&const_COMPRESSION_NONE_value, REDIS_COMPRESSION_NONE);\n\tzend_string *const_COMPRESSION_NONE_name = zend_string_init_interned(\"COMPRESSION_NONE\", sizeof(\"COMPRESSION_NONE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_NONE_name, &const_COMPRESSION_NONE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_NONE_name);\n#if defined(HAVE_REDIS_LZF)\n\n\tzval const_COMPRESSION_LZF_value;\n\tZVAL_LONG(&const_COMPRESSION_LZF_value, REDIS_COMPRESSION_LZF);\n\tzend_string *const_COMPRESSION_LZF_name = zend_string_init_interned(\"COMPRESSION_LZF\", sizeof(\"COMPRESSION_LZF\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_LZF_name, &const_COMPRESSION_LZF_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_LZF_name);\n#endif\n#if defined(HAVE_REDIS_ZSTD)\n\n\tzval const_COMPRESSION_ZSTD_value;\n\tZVAL_LONG(&const_COMPRESSION_ZSTD_value, REDIS_COMPRESSION_ZSTD);\n\tzend_string *const_COMPRESSION_ZSTD_name = zend_string_init_interned(\"COMPRESSION_ZSTD\", sizeof(\"COMPRESSION_ZSTD\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_ZSTD_name, &const_COMPRESSION_ZSTD_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_ZSTD_name);\n#endif\n#if defined(HAVE_REDIS_ZSTD) && defined(ZSTD_CLEVEL_DEFAULT)\n\n\tzval const_COMPRESSION_ZSTD_DEFAULT_value;\n\tZVAL_LONG(&const_COMPRESSION_ZSTD_DEFAULT_value, ZSTD_CLEVEL_DEFAULT);\n\tzend_string *const_COMPRESSION_ZSTD_DEFAULT_name = zend_string_init_interned(\"COMPRESSION_ZSTD_DEFAULT\", sizeof(\"COMPRESSION_ZSTD_DEFAULT\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_ZSTD_DEFAULT_name, &const_COMPRESSION_ZSTD_DEFAULT_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_ZSTD_DEFAULT_name);\n#endif\n#if defined(HAVE_REDIS_ZSTD) && !(defined(ZSTD_CLEVEL_DEFAULT))\n\n\tzval const_COMPRESSION_ZSTD_DEFAULT_value;\n\tZVAL_LONG(&const_COMPRESSION_ZSTD_DEFAULT_value, 3);\n\tzend_string *const_COMPRESSION_ZSTD_DEFAULT_name = zend_string_init_interned(\"COMPRESSION_ZSTD_DEFAULT\", sizeof(\"COMPRESSION_ZSTD_DEFAULT\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_ZSTD_DEFAULT_name, &const_COMPRESSION_ZSTD_DEFAULT_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_ZSTD_DEFAULT_name);\n#endif\n#if defined(HAVE_REDIS_ZSTD) && ZSTD_VERSION_NUMBER >= 10400\n\n\tzval const_COMPRESSION_ZSTD_MIN_value;\n\tZVAL_LONG(&const_COMPRESSION_ZSTD_MIN_value, ZSTD_minCLevel());\n\tzend_string *const_COMPRESSION_ZSTD_MIN_name = zend_string_init_interned(\"COMPRESSION_ZSTD_MIN\", sizeof(\"COMPRESSION_ZSTD_MIN\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_ZSTD_MIN_name, &const_COMPRESSION_ZSTD_MIN_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_ZSTD_MIN_name);\n#endif\n#if defined(HAVE_REDIS_ZSTD) && !(ZSTD_VERSION_NUMBER >= 10400)\n\n\tzval const_COMPRESSION_ZSTD_MIN_value;\n\tZVAL_LONG(&const_COMPRESSION_ZSTD_MIN_value, 1);\n\tzend_string *const_COMPRESSION_ZSTD_MIN_name = zend_string_init_interned(\"COMPRESSION_ZSTD_MIN\", sizeof(\"COMPRESSION_ZSTD_MIN\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_ZSTD_MIN_name, &const_COMPRESSION_ZSTD_MIN_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_ZSTD_MIN_name);\n#endif\n#if defined(HAVE_REDIS_ZSTD)\n\n\tzval const_COMPRESSION_ZSTD_MAX_value;\n\tZVAL_LONG(&const_COMPRESSION_ZSTD_MAX_value, ZSTD_maxCLevel());\n\tzend_string *const_COMPRESSION_ZSTD_MAX_name = zend_string_init_interned(\"COMPRESSION_ZSTD_MAX\", sizeof(\"COMPRESSION_ZSTD_MAX\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_ZSTD_MAX_name, &const_COMPRESSION_ZSTD_MAX_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_ZSTD_MAX_name);\n#endif\n#if defined(HAVE_REDIS_LZ4)\n\n\tzval const_COMPRESSION_LZ4_value;\n\tZVAL_LONG(&const_COMPRESSION_LZ4_value, REDIS_COMPRESSION_LZ4);\n\tzend_string *const_COMPRESSION_LZ4_name = zend_string_init_interned(\"COMPRESSION_LZ4\", sizeof(\"COMPRESSION_LZ4\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_COMPRESSION_LZ4_name, &const_COMPRESSION_LZ4_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_COMPRESSION_LZ4_name);\n#endif\n\n\tzval const_OPT_SCAN_value;\n\tZVAL_LONG(&const_OPT_SCAN_value, REDIS_OPT_SCAN);\n\tzend_string *const_OPT_SCAN_name = zend_string_init_interned(\"OPT_SCAN\", sizeof(\"OPT_SCAN\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_SCAN_name, &const_OPT_SCAN_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_SCAN_name);\n\n\tzval const_SCAN_RETRY_value;\n\tZVAL_LONG(&const_SCAN_RETRY_value, REDIS_SCAN_RETRY);\n\tzend_string *const_SCAN_RETRY_name = zend_string_init_interned(\"SCAN_RETRY\", sizeof(\"SCAN_RETRY\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SCAN_RETRY_name, &const_SCAN_RETRY_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SCAN_RETRY_name);\n\n\tzval const_SCAN_NORETRY_value;\n\tZVAL_LONG(&const_SCAN_NORETRY_value, REDIS_SCAN_NORETRY);\n\tzend_string *const_SCAN_NORETRY_name = zend_string_init_interned(\"SCAN_NORETRY\", sizeof(\"SCAN_NORETRY\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SCAN_NORETRY_name, &const_SCAN_NORETRY_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SCAN_NORETRY_name);\n\n\tzval const_SCAN_PREFIX_value;\n\tZVAL_LONG(&const_SCAN_PREFIX_value, REDIS_SCAN_PREFIX);\n\tzend_string *const_SCAN_PREFIX_name = zend_string_init_interned(\"SCAN_PREFIX\", sizeof(\"SCAN_PREFIX\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SCAN_PREFIX_name, &const_SCAN_PREFIX_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SCAN_PREFIX_name);\n\n\tzval const_SCAN_NOPREFIX_value;\n\tZVAL_LONG(&const_SCAN_NOPREFIX_value, REDIS_SCAN_NOPREFIX);\n\tzend_string *const_SCAN_NOPREFIX_name = zend_string_init_interned(\"SCAN_NOPREFIX\", sizeof(\"SCAN_NOPREFIX\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_SCAN_NOPREFIX_name, &const_SCAN_NOPREFIX_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_SCAN_NOPREFIX_name);\n\n\tzval const_BEFORE_value;\n\tzend_string *const_BEFORE_value_str = zend_string_init(\"before\", strlen(\"before\"), 1);\n\tZVAL_STR(&const_BEFORE_value, const_BEFORE_value_str);\n\tzend_string *const_BEFORE_name = zend_string_init_interned(\"BEFORE\", sizeof(\"BEFORE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BEFORE_name, &const_BEFORE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BEFORE_name);\n\n\tzval const_AFTER_value;\n\tzend_string *const_AFTER_value_str = zend_string_init(\"after\", strlen(\"after\"), 1);\n\tZVAL_STR(&const_AFTER_value, const_AFTER_value_str);\n\tzend_string *const_AFTER_name = zend_string_init_interned(\"AFTER\", sizeof(\"AFTER\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_AFTER_name, &const_AFTER_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_AFTER_name);\n\n\tzval const_LEFT_value;\n\tzend_string *const_LEFT_value_str = zend_string_init(\"left\", strlen(\"left\"), 1);\n\tZVAL_STR(&const_LEFT_value, const_LEFT_value_str);\n\tzend_string *const_LEFT_name = zend_string_init_interned(\"LEFT\", sizeof(\"LEFT\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_LEFT_name, &const_LEFT_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_LEFT_name);\n\n\tzval const_RIGHT_value;\n\tzend_string *const_RIGHT_value_str = zend_string_init(\"right\", strlen(\"right\"), 1);\n\tZVAL_STR(&const_RIGHT_value, const_RIGHT_value_str);\n\tzend_string *const_RIGHT_name = zend_string_init_interned(\"RIGHT\", sizeof(\"RIGHT\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_RIGHT_name, &const_RIGHT_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_RIGHT_name);\n\n\tzval const_OPT_MAX_RETRIES_value;\n\tZVAL_LONG(&const_OPT_MAX_RETRIES_value, REDIS_OPT_MAX_RETRIES);\n\tzend_string *const_OPT_MAX_RETRIES_name = zend_string_init_interned(\"OPT_MAX_RETRIES\", sizeof(\"OPT_MAX_RETRIES\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_MAX_RETRIES_name, &const_OPT_MAX_RETRIES_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_MAX_RETRIES_name);\n\n\tzval const_OPT_BACKOFF_ALGORITHM_value;\n\tZVAL_LONG(&const_OPT_BACKOFF_ALGORITHM_value, REDIS_OPT_BACKOFF_ALGORITHM);\n\tzend_string *const_OPT_BACKOFF_ALGORITHM_name = zend_string_init_interned(\"OPT_BACKOFF_ALGORITHM\", sizeof(\"OPT_BACKOFF_ALGORITHM\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_BACKOFF_ALGORITHM_name, &const_OPT_BACKOFF_ALGORITHM_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_BACKOFF_ALGORITHM_name);\n\n\tzval const_BACKOFF_ALGORITHM_DEFAULT_value;\n\tZVAL_LONG(&const_BACKOFF_ALGORITHM_DEFAULT_value, REDIS_BACKOFF_ALGORITHM_DEFAULT);\n\tzend_string *const_BACKOFF_ALGORITHM_DEFAULT_name = zend_string_init_interned(\"BACKOFF_ALGORITHM_DEFAULT\", sizeof(\"BACKOFF_ALGORITHM_DEFAULT\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BACKOFF_ALGORITHM_DEFAULT_name, &const_BACKOFF_ALGORITHM_DEFAULT_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BACKOFF_ALGORITHM_DEFAULT_name);\n\n\tzval const_BACKOFF_ALGORITHM_CONSTANT_value;\n\tZVAL_LONG(&const_BACKOFF_ALGORITHM_CONSTANT_value, REDIS_BACKOFF_ALGORITHM_CONSTANT);\n\tzend_string *const_BACKOFF_ALGORITHM_CONSTANT_name = zend_string_init_interned(\"BACKOFF_ALGORITHM_CONSTANT\", sizeof(\"BACKOFF_ALGORITHM_CONSTANT\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BACKOFF_ALGORITHM_CONSTANT_name, &const_BACKOFF_ALGORITHM_CONSTANT_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BACKOFF_ALGORITHM_CONSTANT_name);\n\n\tzval const_BACKOFF_ALGORITHM_UNIFORM_value;\n\tZVAL_LONG(&const_BACKOFF_ALGORITHM_UNIFORM_value, REDIS_BACKOFF_ALGORITHM_UNIFORM);\n\tzend_string *const_BACKOFF_ALGORITHM_UNIFORM_name = zend_string_init_interned(\"BACKOFF_ALGORITHM_UNIFORM\", sizeof(\"BACKOFF_ALGORITHM_UNIFORM\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BACKOFF_ALGORITHM_UNIFORM_name, &const_BACKOFF_ALGORITHM_UNIFORM_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BACKOFF_ALGORITHM_UNIFORM_name);\n\n\tzval const_BACKOFF_ALGORITHM_EXPONENTIAL_value;\n\tZVAL_LONG(&const_BACKOFF_ALGORITHM_EXPONENTIAL_value, REDIS_BACKOFF_ALGORITHM_EXPONENTIAL);\n\tzend_string *const_BACKOFF_ALGORITHM_EXPONENTIAL_name = zend_string_init_interned(\"BACKOFF_ALGORITHM_EXPONENTIAL\", sizeof(\"BACKOFF_ALGORITHM_EXPONENTIAL\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BACKOFF_ALGORITHM_EXPONENTIAL_name, &const_BACKOFF_ALGORITHM_EXPONENTIAL_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BACKOFF_ALGORITHM_EXPONENTIAL_name);\n\n\tzval const_BACKOFF_ALGORITHM_FULL_JITTER_value;\n\tZVAL_LONG(&const_BACKOFF_ALGORITHM_FULL_JITTER_value, REDIS_BACKOFF_ALGORITHM_FULL_JITTER);\n\tzend_string *const_BACKOFF_ALGORITHM_FULL_JITTER_name = zend_string_init_interned(\"BACKOFF_ALGORITHM_FULL_JITTER\", sizeof(\"BACKOFF_ALGORITHM_FULL_JITTER\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BACKOFF_ALGORITHM_FULL_JITTER_name, &const_BACKOFF_ALGORITHM_FULL_JITTER_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BACKOFF_ALGORITHM_FULL_JITTER_name);\n\n\tzval const_BACKOFF_ALGORITHM_EQUAL_JITTER_value;\n\tZVAL_LONG(&const_BACKOFF_ALGORITHM_EQUAL_JITTER_value, REDIS_BACKOFF_ALGORITHM_EQUAL_JITTER);\n\tzend_string *const_BACKOFF_ALGORITHM_EQUAL_JITTER_name = zend_string_init_interned(\"BACKOFF_ALGORITHM_EQUAL_JITTER\", sizeof(\"BACKOFF_ALGORITHM_EQUAL_JITTER\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BACKOFF_ALGORITHM_EQUAL_JITTER_name, &const_BACKOFF_ALGORITHM_EQUAL_JITTER_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BACKOFF_ALGORITHM_EQUAL_JITTER_name);\n\n\tzval const_BACKOFF_ALGORITHM_DECORRELATED_JITTER_value;\n\tZVAL_LONG(&const_BACKOFF_ALGORITHM_DECORRELATED_JITTER_value, REDIS_BACKOFF_ALGORITHM_DECORRELATED_JITTER);\n\tzend_string *const_BACKOFF_ALGORITHM_DECORRELATED_JITTER_name = zend_string_init_interned(\"BACKOFF_ALGORITHM_DECORRELATED_JITTER\", sizeof(\"BACKOFF_ALGORITHM_DECORRELATED_JITTER\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_BACKOFF_ALGORITHM_DECORRELATED_JITTER_name, &const_BACKOFF_ALGORITHM_DECORRELATED_JITTER_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_BACKOFF_ALGORITHM_DECORRELATED_JITTER_name);\n\n\tzval const_OPT_BACKOFF_BASE_value;\n\tZVAL_LONG(&const_OPT_BACKOFF_BASE_value, REDIS_OPT_BACKOFF_BASE);\n\tzend_string *const_OPT_BACKOFF_BASE_name = zend_string_init_interned(\"OPT_BACKOFF_BASE\", sizeof(\"OPT_BACKOFF_BASE\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_BACKOFF_BASE_name, &const_OPT_BACKOFF_BASE_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_BACKOFF_BASE_name);\n\n\tzval const_OPT_BACKOFF_CAP_value;\n\tZVAL_LONG(&const_OPT_BACKOFF_CAP_value, REDIS_OPT_BACKOFF_CAP);\n\tzend_string *const_OPT_BACKOFF_CAP_name = zend_string_init_interned(\"OPT_BACKOFF_CAP\", sizeof(\"OPT_BACKOFF_CAP\") - 1, 1);\n\tzend_declare_class_constant_ex(class_entry, const_OPT_BACKOFF_CAP_name, &const_OPT_BACKOFF_CAP_value, ZEND_ACC_PUBLIC, NULL);\n\tzend_string_release(const_OPT_BACKOFF_CAP_name);\n\n\treturn class_entry;\n}\n\nstatic zend_class_entry *register_class_RedisException(zend_class_entry *class_entry_RuntimeException)\n{\n\tzend_class_entry ce, *class_entry;\n\n\tINIT_CLASS_ENTRY(ce, \"RedisException\", class_RedisException_methods);\n\tclass_entry = zend_register_internal_class_ex(&ce, class_entry_RuntimeException);\n\n\treturn class_entry;\n}\n"
        },
        {
          "name": "redis_sentinel.c",
          "type": "blob",
          "size": 3.5107421875,
          "content": "/*\n  +----------------------------------------------------------------------+\n  | Copyright (c) The PHP Group                                          |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt                                  |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Author: Pavlo Yatsukhnenko <yatsukhnenko@gmail.com>                  |\n  | Maintainer: Michael Grunder <michael.grunder@gmail.com>              |\n  +----------------------------------------------------------------------+\n*/\n\n#include \"php_redis.h\"\n#include \"redis_commands.h\"\n#include \"redis_sentinel.h\"\n#include <zend_exceptions.h>\n\nzend_class_entry *redis_sentinel_ce;\nextern zend_class_entry *redis_exception_ce;\n\n#if PHP_VERSION_ID < 80000\n#include \"redis_sentinel_legacy_arginfo.h\"\n#else\n#include \"zend_attributes.h\"\n#include \"redis_sentinel_arginfo.h\"\n#endif\n\nPHP_MINIT_FUNCTION(redis_sentinel)\n{\n    /* RedisSentinel class */\n    redis_sentinel_ce = register_class_RedisSentinel();\n    redis_sentinel_ce->create_object = create_sentinel_object;\n\n    return SUCCESS;\n}\n\nPHP_METHOD(RedisSentinel, __construct)\n{\n    HashTable *opts = NULL;\n    redis_sentinel_object *sentinel;\n\n    ZEND_PARSE_PARAMETERS_START(0, 1)\n        Z_PARAM_OPTIONAL\n        Z_PARAM_ARRAY_HT_OR_NULL(opts)\n    ZEND_PARSE_PARAMETERS_END_EX(RETURN_THROWS());\n\n    sentinel = PHPREDIS_ZVAL_GET_OBJECT(redis_sentinel_object, getThis());\n    sentinel->sock = redis_sock_create(ZEND_STRL(\"127.0.0.1\"), 26379, 0, 0, 0, NULL, 0);\n    if (opts != NULL && redis_sock_configure(sentinel->sock, opts) != SUCCESS) {\n        RETURN_THROWS();\n    }\n    sentinel->sock->sentinel = 1;\n}\n\nPHP_METHOD(RedisSentinel, ckquorum)\n{\n    REDIS_PROCESS_KW_CMD(\"ckquorum\", redis_sentinel_str_cmd, redis_boolean_response);\n}\n\nPHP_METHOD(RedisSentinel, failover)\n{\n    REDIS_PROCESS_KW_CMD(\"failover\", redis_sentinel_str_cmd, redis_boolean_response);\n}\n\nPHP_METHOD(RedisSentinel, flushconfig)\n{\n    REDIS_PROCESS_KW_CMD(\"flushconfig\", redis_sentinel_cmd, redis_boolean_response);\n}\n\nPHP_METHOD(RedisSentinel, getMasterAddrByName)\n{\n    REDIS_PROCESS_KW_CMD(\"get-master-addr-by-name\", redis_sentinel_str_cmd, redis_mbulk_reply_raw);\n}\n\nPHP_METHOD(RedisSentinel, master)\n{\n    REDIS_PROCESS_KW_CMD(\"master\", redis_sentinel_str_cmd, redis_mbulk_reply_zipped_raw);\n}\n\nPHP_METHOD(RedisSentinel, masters)\n{\n    REDIS_PROCESS_KW_CMD(\"masters\", redis_sentinel_cmd, sentinel_mbulk_reply_zipped_assoc);\n}\n\nPHP_METHOD(RedisSentinel, myid)\n{\n    REDIS_PROCESS_KW_CMD(\"myid\", redis_sentinel_cmd, redis_string_response);\n}\n\nPHP_METHOD(RedisSentinel, ping)\n{\n    REDIS_PROCESS_KW_CMD(\"ping\", redis_empty_cmd, redis_boolean_response);\n}\n\nPHP_METHOD(RedisSentinel, reset)\n{\n    REDIS_PROCESS_KW_CMD(\"reset\", redis_sentinel_str_cmd, redis_long_response);\n}\n\nPHP_METHOD(RedisSentinel, sentinels)\n{\n    REDIS_PROCESS_KW_CMD(\"sentinels\", redis_sentinel_str_cmd, sentinel_mbulk_reply_zipped_assoc);\n}\n\nPHP_METHOD(RedisSentinel, slaves)\n{\n    REDIS_PROCESS_KW_CMD(\"slaves\", redis_sentinel_str_cmd, sentinel_mbulk_reply_zipped_assoc);\n}\n"
        },
        {
          "name": "redis_sentinel.h",
          "type": "blob",
          "size": 0.236328125,
          "content": "#ifndef REDIS_SENTINEL_H\n#define REDIS_SENTINEL_H\n\n#include \"sentinel_library.h\"\n\n#define PHP_REDIS_SENTINEL_VERSION \"1.0\"\n\nextern zend_class_entry *redis_sentinel_ce;\nextern PHP_MINIT_FUNCTION(redis_sentinel);\n\n#endif /* REDIS_SENTINEL_H */\n"
        },
        {
          "name": "redis_sentinel.stub.php",
          "type": "blob",
          "size": 1.0068359375,
          "content": "<?php\n\n/**\n * @generate-function-entries\n * @generate-legacy-arginfo\n * @generate-class-entries\n */\n\nclass RedisSentinel {\n\n    public function __construct(?array $options = null);\n\n\t/** @return bool|RedisSentinel */\n    public function ckquorum(string $master);\n\n\t/** @return bool|RedisSentinel */\n    public function failover(string $master);\n\n\t/** @return bool|RedisSentinel */\n    public function flushconfig();\n\n\t/** @return array|bool|RedisSentinel */\n    public function getMasterAddrByName(string $master);\n\n\t/** @return array|bool|RedisSentinel */\n    public function master(string $master);\n\n\t/** @return array|bool|RedisSentinel */\n    public function masters();\n\n    public function myid(): string;\n\n\t/** @return bool|RedisSentinel */\n    public function ping();\n\n\t/** @return int|RedisSentinel */\n    public function reset(string $pattern);\n\n\t/** @return array|bool|RedisSentinel */\n    public function sentinels(string $master);\n\n\t/** @return array|bool|RedisSentinel */\n    public function slaves(string $master);\n}\n"
        },
        {
          "name": "redis_sentinel_arginfo.h",
          "type": "blob",
          "size": 3.1484375,
          "content": "/* This is a generated file, edit the .stub.php file instead.\n * Stub hash: ca40579af888c5bb0661cd0201d840297474479a */\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisSentinel___construct, 0, 0, 0)\n\tZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, options, IS_ARRAY, 1, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisSentinel_ckquorum, 0, 0, 1)\n\tZEND_ARG_TYPE_INFO(0, master, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisSentinel_failover arginfo_class_RedisSentinel_ckquorum\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisSentinel_flushconfig, 0, 0, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisSentinel_getMasterAddrByName arginfo_class_RedisSentinel_ckquorum\n\n#define arginfo_class_RedisSentinel_master arginfo_class_RedisSentinel_ckquorum\n\n#define arginfo_class_RedisSentinel_masters arginfo_class_RedisSentinel_flushconfig\n\nZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_class_RedisSentinel_myid, 0, 0, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisSentinel_ping arginfo_class_RedisSentinel_flushconfig\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisSentinel_reset, 0, 0, 1)\n\tZEND_ARG_TYPE_INFO(0, pattern, IS_STRING, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisSentinel_sentinels arginfo_class_RedisSentinel_ckquorum\n\n#define arginfo_class_RedisSentinel_slaves arginfo_class_RedisSentinel_ckquorum\n\n\nZEND_METHOD(RedisSentinel, __construct);\nZEND_METHOD(RedisSentinel, ckquorum);\nZEND_METHOD(RedisSentinel, failover);\nZEND_METHOD(RedisSentinel, flushconfig);\nZEND_METHOD(RedisSentinel, getMasterAddrByName);\nZEND_METHOD(RedisSentinel, master);\nZEND_METHOD(RedisSentinel, masters);\nZEND_METHOD(RedisSentinel, myid);\nZEND_METHOD(RedisSentinel, ping);\nZEND_METHOD(RedisSentinel, reset);\nZEND_METHOD(RedisSentinel, sentinels);\nZEND_METHOD(RedisSentinel, slaves);\n\n\nstatic const zend_function_entry class_RedisSentinel_methods[] = {\n\tZEND_ME(RedisSentinel, __construct, arginfo_class_RedisSentinel___construct, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, ckquorum, arginfo_class_RedisSentinel_ckquorum, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, failover, arginfo_class_RedisSentinel_failover, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, flushconfig, arginfo_class_RedisSentinel_flushconfig, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, getMasterAddrByName, arginfo_class_RedisSentinel_getMasterAddrByName, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, master, arginfo_class_RedisSentinel_master, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, masters, arginfo_class_RedisSentinel_masters, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, myid, arginfo_class_RedisSentinel_myid, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, ping, arginfo_class_RedisSentinel_ping, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, reset, arginfo_class_RedisSentinel_reset, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, sentinels, arginfo_class_RedisSentinel_sentinels, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, slaves, arginfo_class_RedisSentinel_slaves, ZEND_ACC_PUBLIC)\n\tZEND_FE_END\n};\n\nstatic zend_class_entry *register_class_RedisSentinel(void)\n{\n\tzend_class_entry ce, *class_entry;\n\n\tINIT_CLASS_ENTRY(ce, \"RedisSentinel\", class_RedisSentinel_methods);\n\tclass_entry = zend_register_internal_class_ex(&ce, NULL);\n\n\treturn class_entry;\n}\n"
        },
        {
          "name": "redis_sentinel_legacy_arginfo.h",
          "type": "blob",
          "size": 3.03515625,
          "content": "/* This is a generated file, edit the .stub.php file instead.\n * Stub hash: ca40579af888c5bb0661cd0201d840297474479a */\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisSentinel___construct, 0, 0, 0)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisSentinel_ckquorum, 0, 0, 1)\n\tZEND_ARG_INFO(0, master)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisSentinel_failover arginfo_class_RedisSentinel_ckquorum\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisSentinel_flushconfig, 0, 0, 0)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisSentinel_getMasterAddrByName arginfo_class_RedisSentinel_ckquorum\n\n#define arginfo_class_RedisSentinel_master arginfo_class_RedisSentinel_ckquorum\n\n#define arginfo_class_RedisSentinel_masters arginfo_class_RedisSentinel_flushconfig\n\n#define arginfo_class_RedisSentinel_myid arginfo_class_RedisSentinel_flushconfig\n\n#define arginfo_class_RedisSentinel_ping arginfo_class_RedisSentinel_flushconfig\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_class_RedisSentinel_reset, 0, 0, 1)\n\tZEND_ARG_INFO(0, pattern)\nZEND_END_ARG_INFO()\n\n#define arginfo_class_RedisSentinel_sentinels arginfo_class_RedisSentinel_ckquorum\n\n#define arginfo_class_RedisSentinel_slaves arginfo_class_RedisSentinel_ckquorum\n\n\nZEND_METHOD(RedisSentinel, __construct);\nZEND_METHOD(RedisSentinel, ckquorum);\nZEND_METHOD(RedisSentinel, failover);\nZEND_METHOD(RedisSentinel, flushconfig);\nZEND_METHOD(RedisSentinel, getMasterAddrByName);\nZEND_METHOD(RedisSentinel, master);\nZEND_METHOD(RedisSentinel, masters);\nZEND_METHOD(RedisSentinel, myid);\nZEND_METHOD(RedisSentinel, ping);\nZEND_METHOD(RedisSentinel, reset);\nZEND_METHOD(RedisSentinel, sentinels);\nZEND_METHOD(RedisSentinel, slaves);\n\n\nstatic const zend_function_entry class_RedisSentinel_methods[] = {\n\tZEND_ME(RedisSentinel, __construct, arginfo_class_RedisSentinel___construct, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, ckquorum, arginfo_class_RedisSentinel_ckquorum, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, failover, arginfo_class_RedisSentinel_failover, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, flushconfig, arginfo_class_RedisSentinel_flushconfig, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, getMasterAddrByName, arginfo_class_RedisSentinel_getMasterAddrByName, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, master, arginfo_class_RedisSentinel_master, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, masters, arginfo_class_RedisSentinel_masters, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, myid, arginfo_class_RedisSentinel_myid, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, ping, arginfo_class_RedisSentinel_ping, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, reset, arginfo_class_RedisSentinel_reset, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, sentinels, arginfo_class_RedisSentinel_sentinels, ZEND_ACC_PUBLIC)\n\tZEND_ME(RedisSentinel, slaves, arginfo_class_RedisSentinel_slaves, ZEND_ACC_PUBLIC)\n\tZEND_FE_END\n};\n\nstatic zend_class_entry *register_class_RedisSentinel(void)\n{\n\tzend_class_entry ce, *class_entry;\n\n\tINIT_CLASS_ENTRY(ce, \"RedisSentinel\", class_RedisSentinel_methods);\n\tclass_entry = zend_register_internal_class_ex(&ce, NULL);\n\n\treturn class_entry;\n}\n"
        },
        {
          "name": "redis_session.c",
          "type": "blob",
          "size": 41.2060546875,
          "content": "/* -*- Mode: C; tab-width: 4 -*- */\n/*\n  +----------------------------------------------------------------------+\n  | Copyright (c) 1997-2009 The PHP Group                                |\n  +----------------------------------------------------------------------+\n  | This source file is subject to version 3.01 of the PHP license,      |\n  | that is bundled with this package in the file LICENSE, and is        |\n  | available through the world-wide-web at the following url:           |\n  | http://www.php.net/license/3_01.txt                                  |\n  | If you did not receive a copy of the PHP license and are unable to   |\n  | obtain it through the world-wide-web, please send a note to          |\n  | license@php.net so we can mail you a copy immediately.               |\n  +----------------------------------------------------------------------+\n  | Original author: Alfonso Jimenez <yo@alfonsojimenez.com>             |\n  | Maintainer: Nicolas Favre-Felix <n.favre-felix@owlient.eu>           |\n  | Maintainer: Nasreddine Bouafif <n.bouafif@owlient.eu>                |\n  | Maintainer: Michael Grunder <michael.grunder@gmail.com>              |\n  +----------------------------------------------------------------------+\n*/\n\n#include \"common.h\"\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef PHP_SESSION\n#include \"ext/standard/info.h\"\n#include \"php_redis.h\"\n#include \"redis_session.h\"\n#include <zend_exceptions.h>\n\n#include \"library.h\"\n#include \"cluster_library.h\"\n\n#include \"php.h\"\n#include \"php_ini.h\"\n#include \"php_variables.h\"\n#include \"SAPI.h\"\n#include \"ext/standard/url.h\"\n\n#define REDIS_SESSION_PREFIX \"PHPREDIS_SESSION:\"\n#define CLUSTER_SESSION_PREFIX \"PHPREDIS_CLUSTER_SESSION:\"\n\n/* Session lock LUA as well as its SHA1 hash */\n#define LOCK_RELEASE_LUA_STR \"if redis.call(\\\"get\\\",KEYS[1]) == ARGV[1] then return redis.call(\\\"del\\\",KEYS[1]) else return 0 end\"\n#define LOCK_RELEASE_LUA_LEN (sizeof(LOCK_RELEASE_LUA_STR) - 1)\n#define LOCK_RELEASE_SHA_STR \"b70c2384248f88e6b75b9f89241a180f856ad852\"\n#define LOCK_RELEASE_SHA_LEN (sizeof(LOCK_RELEASE_SHA_STR) - 1)\n\n/* Check if a response is the Redis +OK status response */\n#define IS_REDIS_OK(r, len) (r != NULL && len == 3 && !memcmp(r, \"+OK\", 3))\n#define NEGATIVE_LOCK_RESPONSE 1\n\n#define CLUSTER_DEFAULT_PREFIX() \\\n    zend_string_init(CLUSTER_SESSION_PREFIX, sizeof(CLUSTER_SESSION_PREFIX) - 1, 0)\n\nps_module ps_mod_redis = {\n    PS_MOD_UPDATE_TIMESTAMP(redis)\n};\n\nps_module ps_mod_redis_cluster = {\n    PS_MOD_UPDATE_TIMESTAMP(rediscluster)\n};\n\ntypedef struct {\n    zend_bool is_locked;\n    zend_string *session_key;\n    zend_string *lock_key;\n    zend_string *lock_secret;\n} redis_session_lock_status;\n\ntypedef struct redis_pool_member_ {\n\n    RedisSock *redis_sock;\n    int weight;\n    struct redis_pool_member_ *next;\n\n} redis_pool_member;\n\ntypedef struct {\n\n    int totalWeight;\n    int count;\n\n    redis_pool_member *head;\n    redis_session_lock_status lock_status;\n\n} redis_pool;\n\n// static char *session_conf_string(HashTable *ht, const char *key, size_t keylen) {\n// }\n\nPHP_REDIS_API void\nredis_pool_add(redis_pool *pool, RedisSock *redis_sock, int weight)\n{\n    redis_pool_member *rpm = ecalloc(1, sizeof(redis_pool_member));\n    rpm->redis_sock = redis_sock;\n    rpm->weight = weight;\n\n    rpm->next = pool->head;\n    pool->head = rpm;\n\n    pool->totalWeight += weight;\n}\n\nPHP_REDIS_API void\nredis_pool_free(redis_pool *pool) {\n\n    redis_pool_member *rpm, *next;\n\n    if (pool == NULL)\n        return;\n\n    rpm = pool->head;\n    while (rpm) {\n        next = rpm->next;\n        redis_sock_disconnect(rpm->redis_sock, 0, 1);\n        redis_free_socket(rpm->redis_sock);\n        efree(rpm);\n        rpm = next;\n    }\n\n    /* Cleanup after our lock */\n    if (pool->lock_status.session_key) zend_string_release(pool->lock_status.session_key);\n    if (pool->lock_status.lock_secret) zend_string_release(pool->lock_status.lock_secret);\n    if (pool->lock_status.lock_key) zend_string_release(pool->lock_status.lock_key);\n\n    /* Cleanup pool itself */\n    efree(pool);\n}\n\n/* Retrieve session.gc_maxlifetime from php.ini protecting against an integer overflow */\nstatic int session_gc_maxlifetime(void) {\n    zend_long value = INI_INT(\"session.gc_maxlifetime\");\n    if (value > INT_MAX) {\n        php_error_docref(NULL, E_NOTICE, \"session.gc_maxlifetime overflows INT_MAX, truncating.\");\n        return INT_MAX;\n    } else if (value <= 0) {\n        php_error_docref(NULL, E_NOTICE, \"session.gc_maxlifetime is <= 0, defaulting to 1440 seconds\");\n        return 1440;\n    }\n\n    return value;\n}\n\n/* Retrieve redis.session.compression from php.ini */\nstatic int session_compression_type(void) {\n    const char *compression = INI_STR(\"redis.session.compression\");\n    if(compression == NULL || *compression == '\\0' || strncasecmp(compression, \"none\", sizeof(\"none\") - 1) == 0) {\n        return REDIS_COMPRESSION_NONE;\n    }\n\n#ifdef HAVE_REDIS_LZF\n    if(strncasecmp(compression, \"lzf\", sizeof(\"lzf\") - 1) == 0) {\n        return REDIS_COMPRESSION_LZF;\n    }\n#endif\n#ifdef HAVE_REDIS_ZSTD\n    if(strncasecmp(compression, \"zstd\", sizeof(\"zstd\") - 1) == 0) {\n        return REDIS_COMPRESSION_ZSTD;\n    }\n#endif\n#ifdef HAVE_REDIS_LZ4\n    if(strncasecmp(compression, \"lz4\", sizeof(\"lz4\") - 1) == 0) {\n        return REDIS_COMPRESSION_LZ4;\n    }\n#endif\n\n    // E_NOTICE when outside of valid values\n    php_error_docref(NULL, E_NOTICE, \"redis.session.compression is outside of valid values, disabling\");\n\n    return REDIS_COMPRESSION_NONE;\n}\n\n/* Helper to compress session data */\nstatic int\nsession_compress_data(RedisSock *redis_sock, char *data, size_t len,\n                      char **compressed_data, size_t *compressed_len)\n{\n    if (redis_sock->compression) {\n        if(redis_compress(redis_sock, compressed_data, compressed_len, data, len)) {\n            return 1;\n        }\n    }\n\n    *compressed_data = data;\n    *compressed_len = len;\n\n    return 0;\n}\n\n/* Helper to uncompress session data */\nstatic int\nsession_uncompress_data(RedisSock *redis_sock, char *data, size_t len,\n                                   char **decompressed_data, size_t *decompressed_len) {\n    if (redis_sock->compression) {\n        if(redis_uncompress(redis_sock, decompressed_data, decompressed_len, data, len)) {\n            return 1;\n        }\n    }\n\n    *decompressed_data = data;\n    *decompressed_len = len;\n\n    return 0;\n}\n\n/* Send a command to Redis.  Returns byte count written to socket (-1 on failure) */\nstatic int redis_simple_cmd(RedisSock *redis_sock, char *cmd, int cmdlen,\n                              char **reply, int *replylen)\n{\n    *reply = NULL;\n    int len_written = redis_sock_write(redis_sock, cmd, cmdlen);\n\n    if (len_written >= 0) {\n        *reply = redis_sock_read(redis_sock, replylen);\n    }\n\n    return len_written;\n}\n\nPHP_REDIS_API redis_pool_member *\nredis_pool_get_sock(redis_pool *pool, const char *key) {\n\n    unsigned int pos, i;\n    memcpy(&pos, key, sizeof(pos));\n    pos %= pool->totalWeight;\n\n    redis_pool_member *rpm = pool->head;\n\n    for(i = 0; i < pool->totalWeight;) {\n        if (pos >= i && pos < i + rpm->weight) {\n            if (redis_sock_server_open(rpm->redis_sock) == 0) {\n                return rpm;\n            }\n        }\n        i += rpm->weight;\n        rpm = rpm->next;\n    }\n\n    return NULL;\n}\n\n/* Helper to set our session lock key */\nstatic int set_session_lock_key(RedisSock *redis_sock, char *cmd, int cmd_len\n                               )\n{\n    char *reply;\n    int sent_len, reply_len;\n\n    sent_len = redis_simple_cmd(redis_sock, cmd, cmd_len, &reply, &reply_len);\n    if (reply) {\n        if (IS_REDIS_OK(reply, reply_len)) {\n            efree(reply);\n            return SUCCESS;\n        }\n\n        efree(reply);\n    }\n\n    /* Return FAILURE in case of network problems */\n    return sent_len >= 0 ? NEGATIVE_LOCK_RESPONSE : FAILURE;\n}\n\nstatic int lock_acquire(RedisSock *redis_sock, redis_session_lock_status *lock_status\n                       )\n{\n    char *cmd, hostname[HOST_NAME_MAX] = {0}, suffix[] = \"_LOCK\";\n    int cmd_len, lock_wait_time, retries, i, set_lock_key_result, expiry;\n\n    /* Short circuit if we are already locked or not using session locks */\n    if (lock_status->is_locked || !INI_INT(\"redis.session.locking_enabled\"))\n        return SUCCESS;\n\n    /* How long to wait between attempts to acquire lock */\n    lock_wait_time = INI_INT(\"redis.session.lock_wait_time\");\n    if (lock_wait_time == 0) {\n        lock_wait_time = 20000;\n    }\n\n    /* Maximum number of times to retry (-1 means infinite) */\n    retries = INI_INT(\"redis.session.lock_retries\");\n    if (retries == 0) {\n        retries = 100;\n    }\n\n    /* How long should the lock live (in seconds) */\n    expiry = INI_INT(\"redis.session.lock_expire\");\n    if (expiry == 0) {\n        expiry = INI_INT(\"max_execution_time\");\n    }\n\n    /* Generate our qualified lock key */\n    if (lock_status->lock_key) zend_string_release(lock_status->lock_key);\n    lock_status->lock_key = zend_string_alloc(ZSTR_LEN(lock_status->session_key) + sizeof(suffix) - 1, 0);\n    memcpy(ZSTR_VAL(lock_status->lock_key), ZSTR_VAL(lock_status->session_key), ZSTR_LEN(lock_status->session_key));\n    memcpy(ZSTR_VAL(lock_status->lock_key) + ZSTR_LEN(lock_status->session_key), suffix, sizeof(suffix) - 1);\n\n    /* Calculate lock secret */\n    gethostname(hostname, HOST_NAME_MAX);\n    if (lock_status->lock_secret) zend_string_release(lock_status->lock_secret);\n    lock_status->lock_secret = strpprintf(0, \"%s|%ld\", hostname, (long)getpid());\n\n    if (expiry > 0) {\n        cmd_len = REDIS_SPPRINTF(&cmd, \"SET\", \"SSssd\", lock_status->lock_key,\n                                 lock_status->lock_secret, \"NX\", 2, \"PX\", 2,\n                                 expiry * 1000);\n    } else {\n        cmd_len = REDIS_SPPRINTF(&cmd, \"SET\", \"SSs\", lock_status->lock_key,\n                                 lock_status->lock_secret, \"NX\", 2);\n    }\n\n    /* Attempt to get our lock */\n    for (i = 0; retries == -1 || i <= retries; i++) {\n        set_lock_key_result = set_session_lock_key(redis_sock, cmd, cmd_len);\n\n        if (set_lock_key_result == SUCCESS) {\n            lock_status->is_locked = 1;\n            break;\n        } else if (set_lock_key_result == FAILURE) {\n            /* In case of network problems, break the loop and report to userland */\n            lock_status->is_locked = 0;\n            break;\n        }\n\n        /* Sleep unless we're done making attempts */\n        if (retries == -1 || i < retries) {\n            usleep(lock_wait_time);\n        }\n    }\n\n    /* Cleanup SET command */\n    efree(cmd);\n\n    /* Success if we're locked */\n    return lock_status->is_locked ? SUCCESS : FAILURE;\n}\n\n#define IS_LOCK_SECRET(reply, len, secret) (len == ZSTR_LEN(secret) && !redis_strncmp(reply, ZSTR_VAL(secret), len))\nstatic int write_allowed(RedisSock *redis_sock, redis_session_lock_status *lock_status)\n{\n    if (!INI_INT(\"redis.session.locking_enabled\")) {\n        return 1;\n    }\n    /* If locked and redis.session.lock_expire is not set => TTL=max_execution_time\n       Therefore it is guaranteed that the current process is still holding the lock */\n\n    if (lock_status->is_locked && INI_INT(\"redis.session.lock_expire\") != 0) {\n        char *cmd, *reply = NULL;\n        int replylen, cmdlen;\n        /* Command to get our lock key value and compare secrets */\n        cmdlen = REDIS_SPPRINTF(&cmd, \"GET\", \"S\", lock_status->lock_key);\n\n        /* Attempt to refresh the lock */\n        redis_simple_cmd(redis_sock, cmd, cmdlen, &reply, &replylen);\n        /* Cleanup */\n        efree(cmd);\n\n        if (reply == NULL) {\n            lock_status->is_locked = 0;\n        } else {\n            lock_status->is_locked = IS_LOCK_SECRET(reply, replylen, lock_status->lock_secret);\n            efree(reply);\n        }\n\n        /* Issue a warning if we're not locked.  We don't attempt to refresh the lock\n         * if we aren't flagged as locked, so if we're not flagged here something\n         * failed */\n        if (!lock_status->is_locked) {\n            php_error_docref(NULL, E_WARNING, \"Session lock expired\");\n        }\n    }\n\n    return lock_status->is_locked;\n}\n\n/* Release any session lock we hold and cleanup allocated lock data.  This function\n * first attempts to use EVALSHA and then falls back to EVAL if EVALSHA fails.  This\n * will cause Redis to cache the script, so subsequent calls should then succeed\n * using EVALSHA. */\nstatic void lock_release(RedisSock *redis_sock, redis_session_lock_status *lock_status)\n{\n    char *cmd, *reply;\n    int i, cmdlen, replylen;\n\n    /* Keywords, command, and length fallbacks */\n    const char *kwd[] = {\"EVALSHA\", \"EVAL\"};\n    const char *lua[] = {LOCK_RELEASE_SHA_STR, LOCK_RELEASE_LUA_STR};\n    int len[] = {LOCK_RELEASE_SHA_LEN, LOCK_RELEASE_LUA_LEN};\n\n    /* We first want to try EVALSHA and then fall back to EVAL */\n    for (i = 0; lock_status->is_locked && i < sizeof(kwd)/sizeof(*kwd); i++) {\n        /* Construct our command */\n        cmdlen = REDIS_SPPRINTF(&cmd, (char*)kwd[i], \"sdSS\", lua[i], len[i], 1,\n            lock_status->lock_key, lock_status->lock_secret);\n\n        /* Send it off */\n        redis_simple_cmd(redis_sock, cmd, cmdlen, &reply, &replylen);\n\n        /* Release lock and cleanup reply if we got one */\n        if (reply != NULL) {\n            lock_status->is_locked = 0;\n            efree(reply);\n        }\n\n        /* Cleanup command */\n        efree(cmd);\n    }\n\n    /* Something has failed if we are still locked */\n    if (lock_status->is_locked) {\n        php_error_docref(NULL, E_WARNING, \"Failed to release session lock\");\n    }\n}\n\n#define REDIS_URL_STR(umem) ZSTR_VAL(umem)\n\n/* {{{ PS_OPEN_FUNC\n */\nPS_OPEN_FUNC(redis)\n{\n    php_url *url;\n    zval params, context, *zv;\n    int i, j, path_len;\n\n    redis_pool *pool = ecalloc(1, sizeof(*pool));\n\n    for (i = 0, j = 0, path_len = strlen(save_path); i < path_len; i = j + 1) {\n        /* find beginning of url */\n        while ( i< path_len && (isspace(save_path[i]) || save_path[i] == ','))\n            i++;\n\n        /* find end of url */\n        j = i;\n        while (j<path_len && !isspace(save_path[j]) && save_path[j] != ',')\n            j++;\n\n        if (i < j) {\n            int weight = 1;\n            double timeout = 86400.0, read_timeout = 0.0;\n            int persistent = 0, db = -1;\n            zend_long retry_interval = 0;\n            zend_string *persistent_id = NULL, *prefix = NULL;\n            zend_string *user = NULL, *pass = NULL;\n\n            /* translate unix: into file: */\n            if (!redis_strncmp(save_path+i, ZEND_STRL(\"unix:\"))) {\n                int len = j-i;\n                char *path = estrndup(save_path+i, len);\n                memcpy(path, \"file:\", sizeof(\"file:\")-1);\n                url = php_url_parse_ex(path, len);\n                efree(path);\n            } else {\n                url = php_url_parse_ex(save_path+i, j-i);\n            }\n\n            if (!url) {\n                char *path = estrndup(save_path+i, j-i);\n                php_error_docref(NULL, E_WARNING,\n                    \"Failed to parse session.save_path (error at offset %d, url was '%s')\", i, path);\n                efree(path);\n\n                goto fail;\n            }\n\n            ZVAL_NULL(&context);\n            /* parse parameters */\n            if (url->query != NULL) {\n                HashTable *ht;\n                char *query;\n                array_init(&params);\n\n                if (url->fragment) {\n                    spprintf(&query, 0, \"%s#%s\", REDIS_URL_STR(url->query), REDIS_URL_STR(url->fragment));\n                } else {\n                    query = estrdup(REDIS_URL_STR(url->query));\n                }\n\n                sapi_module.treat_data(PARSE_STRING, query, &params);\n                ht = Z_ARRVAL(params);\n\n                REDIS_CONF_INT_STATIC(ht, \"weight\", &weight);\n                REDIS_CONF_BOOL_STATIC(ht, \"persistent\", &persistent);\n                REDIS_CONF_INT_STATIC(ht, \"database\", &db);\n                REDIS_CONF_DOUBLE_STATIC(ht, \"timeout\", &timeout);\n                REDIS_CONF_DOUBLE_STATIC(ht, \"read_timeout\", &read_timeout);\n                REDIS_CONF_LONG_STATIC(ht, \"retry_interval\", &retry_interval);\n                REDIS_CONF_STRING_STATIC(ht, \"persistent_id\", &persistent_id);\n                REDIS_CONF_STRING_STATIC(ht, \"prefix\", &prefix);\n                REDIS_CONF_AUTH_STATIC(ht, \"auth\", &user, &pass);\n\n                if ((zv = REDIS_HASH_STR_FIND_TYPE_STATIC(ht, \"stream\", IS_ARRAY)) != NULL) {\n                    ZVAL_ZVAL(&context, zv, 1, 0);\n                }\n\n                zval_dtor(&params);\n            }\n\n            if ((url->path == NULL && url->host == NULL) || weight <= 0 || timeout <= 0) {\n                char *path = estrndup(save_path+i, j-i);\n                php_error_docref(NULL, E_WARNING,\n                    \"Failed to parse session.save_path (error at offset %d, url was '%s')\", i, path);\n                efree(path);\n\n                php_url_free(url);\n                if (persistent_id) zend_string_release(persistent_id);\n                if (prefix) zend_string_release(prefix);\n                if (user) zend_string_release(user);\n                if (pass) zend_string_release(pass);\n\n                goto fail;\n            }\n\n            RedisSock *redis_sock;\n            char *addr, *scheme;\n            size_t addrlen;\n            int port, addr_free = 0;\n\n            scheme = url->scheme ? REDIS_URL_STR(url->scheme) : \"tcp\";\n            if (url->host) {\n                port = url->port;\n                addrlen = spprintf(&addr, 0, \"%s://%s\", scheme, REDIS_URL_STR(url->host));\n                addr_free = 1;\n            } else { /* unix */\n                port = 0;\n                addr = REDIS_URL_STR(url->path);\n                addrlen = strlen(addr);\n            }\n\n            redis_sock = redis_sock_create(addr, addrlen, port, timeout, read_timeout,\n                                           persistent, persistent_id ? ZSTR_VAL(persistent_id) : NULL,\n                                           retry_interval);\n\n            if (db >= 0) { /* default is -1 which leaves the choice to redis. */\n                redis_sock->dbNumber = db;\n            }\n\n            redis_sock->compression = session_compression_type();\n            redis_sock->compression_level = INI_INT(\"redis.session.compression_level\");\n\n            if (Z_TYPE(context) == IS_ARRAY) {\n                redis_sock_set_stream_context(redis_sock, &context);\n            }\n\n            redis_pool_add(pool, redis_sock, weight);\n            redis_sock->prefix = prefix;\n            redis_sock_set_auth(redis_sock, user, pass);\n\n            if (addr_free) efree(addr);\n            if (persistent_id) zend_string_release(persistent_id);\n            if (user) zend_string_release(user);\n            if (pass) zend_string_release(pass);\n            php_url_free(url);\n        }\n    }\n\n    if (pool->head) {\n        PS_SET_MOD_DATA(pool);\n        return SUCCESS;\n    }\n\nfail:\n    redis_pool_free(pool);\n    PS_SET_MOD_DATA(NULL);\n    return FAILURE;\n}\n/* }}} */\n\n/* {{{ PS_CLOSE_FUNC\n */\nPS_CLOSE_FUNC(redis)\n{\n    redis_pool *pool = PS_GET_MOD_DATA();\n\n    if (pool) {\n        if (pool->lock_status.session_key) {\n            redis_pool_member *rpm = redis_pool_get_sock(pool, ZSTR_VAL(pool->lock_status.session_key));\n\n            RedisSock *redis_sock = rpm ? rpm->redis_sock : NULL;\n            if (redis_sock) {\n                lock_release(redis_sock, &pool->lock_status);\n            }\n        }\n\n        redis_pool_free(pool);\n        PS_SET_MOD_DATA(NULL);\n    }\n\n    return SUCCESS;\n}\n/* }}} */\n\nstatic zend_string *\nredis_session_key(RedisSock *redis_sock, const char *key, int key_len)\n{\n    zend_string *session;\n    char default_prefix[] = REDIS_SESSION_PREFIX;\n    char *prefix = default_prefix;\n    size_t prefix_len = sizeof(default_prefix)-1;\n\n    if (redis_sock->prefix) {\n        prefix = ZSTR_VAL(redis_sock->prefix);\n        prefix_len = ZSTR_LEN(redis_sock->prefix);\n    }\n\n    /* build session key */\n    session = zend_string_alloc(key_len + prefix_len, 0);\n    memcpy(ZSTR_VAL(session), prefix, prefix_len);\n    memcpy(ZSTR_VAL(session) + prefix_len, key, key_len);\n\n    return session;\n}\n\n/* {{{ PS_CREATE_SID_FUNC\n */\nPS_CREATE_SID_FUNC(redis)\n{\n    int retries = 3;\n    redis_pool *pool = PS_GET_MOD_DATA();\n\n    if (!pool) {\n        return php_session_create_id(NULL);\n    }\n\n    while (retries-- > 0) {\n        zend_string* sid = php_session_create_id((void **) &pool);\n        redis_pool_member *rpm = redis_pool_get_sock(pool, ZSTR_VAL(sid));\n\n        RedisSock *redis_sock = rpm ? rpm->redis_sock : NULL;\n\n        if (!redis_sock) {\n            php_error_docref(NULL, E_NOTICE, \"Redis connection not available\");\n            zend_string_release(sid);\n            return php_session_create_id(NULL);\n        }\n\n        if (pool->lock_status.session_key) zend_string_release(pool->lock_status.session_key);\n        pool->lock_status.session_key = redis_session_key(redis_sock, ZSTR_VAL(sid), ZSTR_LEN(sid));\n\n        if (lock_acquire(redis_sock, &pool->lock_status) == SUCCESS) {\n            return sid;\n        }\n\n        zend_string_release(pool->lock_status.session_key);\n        zend_string_release(sid);\n\n        sid = NULL;\n    }\n\n    php_error_docref(NULL, E_WARNING,\n        \"Acquiring session lock failed while creating session_id\");\n\n    return NULL;\n}\n/* }}} */\n\n/* {{{ PS_VALIDATE_SID_FUNC\n */\nPS_VALIDATE_SID_FUNC(redis)\n{\n    char *cmd, *response;\n    int cmd_len, response_len;\n\n    const char *skey = ZSTR_VAL(key);\n    size_t skeylen = ZSTR_LEN(key);\n\n    if (!skeylen) return FAILURE;\n\n    redis_pool *pool = PS_GET_MOD_DATA();\n    redis_pool_member *rpm = redis_pool_get_sock(pool, skey);\n    RedisSock *redis_sock = rpm ? rpm->redis_sock : NULL;\n    if (!redis_sock) {\n        php_error_docref(NULL, E_WARNING, \"Redis connection not available\");\n        return FAILURE;\n    }\n\n    /* send EXISTS command */\n    zend_string *session = redis_session_key(redis_sock, skey, skeylen);\n    cmd_len = REDIS_SPPRINTF(&cmd, \"EXISTS\", \"S\", session);\n    zend_string_release(session);\n    if (redis_sock_write(redis_sock, cmd, cmd_len) < 0 || (response = redis_sock_read(redis_sock, &response_len)) == NULL) {\n        php_error_docref(NULL, E_WARNING, \"Error communicating with Redis server\");\n        efree(cmd);\n        return FAILURE;\n    }\n\n    efree(cmd);\n\n    if (response_len == 2 && response[0] == ':' && response[1] == '1') {\n        efree(response);\n        return SUCCESS;\n    } else {\n        efree(response);\n        return FAILURE;\n    }\n}\n/* }}} */\n\n/* {{{ PS_UPDATE_TIMESTAMP_FUNC\n */\nPS_UPDATE_TIMESTAMP_FUNC(redis)\n{\n    char *cmd, *response;\n    int cmd_len, response_len;\n\n    const char *skey = ZSTR_VAL(key);\n    size_t skeylen = ZSTR_LEN(key);\n\n    if (!skeylen) return FAILURE;\n\n    /* No need to update the session timestamp if we've already done so */\n    if (INI_INT(\"redis.session.early_refresh\")) {\n        return SUCCESS;\n    }\n\n    redis_pool *pool = PS_GET_MOD_DATA();\n    redis_pool_member *rpm = redis_pool_get_sock(pool, skey);\n    RedisSock *redis_sock = rpm ? rpm->redis_sock : NULL;\n    if (!redis_sock) {\n        php_error_docref(NULL, E_WARNING, \"Redis connection not available\");\n        return FAILURE;\n    }\n\n    /* send EXPIRE command */\n    zend_string *session = redis_session_key(redis_sock, skey, skeylen);\n    cmd_len = REDIS_SPPRINTF(&cmd, \"EXPIRE\", \"Sd\", session, session_gc_maxlifetime());\n    zend_string_release(session);\n\n    if (redis_sock_write(redis_sock, cmd, cmd_len) < 0 || (response = redis_sock_read(redis_sock, &response_len)) == NULL) {\n        php_error_docref(NULL, E_WARNING, \"Error communicating with Redis server\");\n        efree(cmd);\n        return FAILURE;\n    }\n\n    efree(cmd);\n\n    if (response_len == 2 && response[0] == ':') {\n        efree(response);\n        return SUCCESS;\n    } else {\n        efree(response);\n        return FAILURE;\n    }\n}\n/* }}} */\n\n/* {{{ PS_READ_FUNC\n */\nPS_READ_FUNC(redis)\n{\n    char *resp, *cmd, *compressed_buf;\n    int resp_len, cmd_len, compressed_free;\n    const char *skey = ZSTR_VAL(key);\n    size_t skeylen = ZSTR_LEN(key), compressed_len;\n\n    if (!skeylen) return FAILURE;\n\n    redis_pool *pool = PS_GET_MOD_DATA();\n    redis_pool_member *rpm = redis_pool_get_sock(pool, skey);\n    RedisSock *redis_sock = rpm ? rpm->redis_sock : NULL;\n    if (!redis_sock) {\n        php_error_docref(NULL, E_WARNING, \"Redis connection not available\");\n        return FAILURE;\n    }\n\n    /* send GET command */\n    if (pool->lock_status.session_key) zend_string_release(pool->lock_status.session_key);\n    pool->lock_status.session_key = redis_session_key(redis_sock, skey, skeylen);\n\n    /* Update the session ttl if early refresh is enabled */\n    if (INI_INT(\"redis.session.early_refresh\")) {\n        cmd_len = REDIS_SPPRINTF(&cmd, \"GETEX\", \"Ssd\", pool->lock_status.session_key,\n                                 \"EX\", 2, session_gc_maxlifetime());\n    } else {\n        cmd_len = REDIS_SPPRINTF(&cmd, \"GET\", \"S\", pool->lock_status.session_key);\n    }\n\n    if (lock_acquire(redis_sock, &pool->lock_status) != SUCCESS) {\n        php_error_docref(NULL, E_WARNING, \"Failed to acquire session lock\");\n        efree(cmd);\n        return FAILURE;\n    }\n\n    if (redis_sock_write(redis_sock, cmd, cmd_len) < 0) {\n        php_error_docref(NULL, E_WARNING, \"Error communicating with Redis server\");\n        efree(cmd);\n        return FAILURE;\n    }\n\n    efree(cmd);\n\n    /* Read response from Redis.  If we get a NULL response from redis_sock_read\n     * this can indicate an error, OR a \"NULL bulk\" reply (empty session data)\n     * in which case we can reply with success. */\n    if ((resp = redis_sock_read(redis_sock, &resp_len)) == NULL && resp_len != -1) {\n        php_error_docref(NULL, E_WARNING, \"Error communicating with Redis server\");\n        return FAILURE;\n    }\n\n    if (resp_len < 0) {\n        *val = ZSTR_EMPTY_ALLOC();\n    } else {\n        compressed_free = session_uncompress_data(redis_sock, resp, resp_len, &compressed_buf, &compressed_len);\n        *val = zend_string_init(compressed_buf, compressed_len, 0);\n        if (compressed_free) {\n            efree(compressed_buf); // Free the buffer allocated by redis_uncompress\n        }\n    }\n\n    efree(resp);\n\n    return SUCCESS;\n}\n/* }}} */\n\n/* {{{ PS_WRITE_FUNC\n */\nPS_WRITE_FUNC(redis)\n{\n    char *cmd, *response;\n    int cmd_len, response_len, compressed_free;\n    const char *skey = ZSTR_VAL(key);\n    size_t skeylen = ZSTR_LEN(key), svallen = ZSTR_LEN(val);\n    char *sval;\n\n    if (!skeylen) return FAILURE;\n\n    redis_pool *pool = PS_GET_MOD_DATA();\n    redis_pool_member *rpm = redis_pool_get_sock(pool, skey);\n    RedisSock *redis_sock = rpm ? rpm->redis_sock : NULL;\n    if (!redis_sock) {\n        php_error_docref(NULL, E_WARNING, \"Redis connection not available\");\n        return FAILURE;\n    }\n\n    /* send SET command */\n    zend_string *session = redis_session_key(redis_sock, skey, skeylen);\n\n    compressed_free = session_compress_data(redis_sock, ZSTR_VAL(val), ZSTR_LEN(val),\n                                            &sval, &svallen);\n\n    cmd_len = REDIS_SPPRINTF(&cmd, \"SETEX\", \"Sds\", session, session_gc_maxlifetime(), sval, svallen);\n    zend_string_release(session);\n    if (compressed_free) {\n        efree(sval);\n    }\n\n    if (!write_allowed(redis_sock, &pool->lock_status)) {\n        php_error_docref(NULL, E_WARNING, \"Unable to write session: session lock not held\");\n        efree(cmd);\n        return FAILURE;\n    }\n\n    if (redis_sock_write(redis_sock, cmd, cmd_len ) < 0 || (response = redis_sock_read(redis_sock, &response_len)) == NULL) {\n        php_error_docref(NULL, E_WARNING, \"Error communicating with Redis server\");\n        efree(cmd);\n        return FAILURE;\n    }\n\n    efree(cmd);\n\n    if (IS_REDIS_OK(response, response_len)) {\n        efree(response);\n        return SUCCESS;\n    } else {\n        php_error_docref(NULL, E_WARNING, \"Error writing session data to Redis: %s\", response);\n        efree(response);\n        return FAILURE;\n    }\n}\n/* }}} */\n\n/* {{{ PS_DESTROY_FUNC\n */\nPS_DESTROY_FUNC(redis)\n{\n    char *cmd, *response;\n    int cmd_len, response_len;\n    const char *skey = ZSTR_VAL(key);\n    size_t skeylen = ZSTR_LEN(key);\n\n    redis_pool *pool = PS_GET_MOD_DATA();\n    redis_pool_member *rpm = redis_pool_get_sock(pool, skey);\n    RedisSock *redis_sock = rpm ? rpm->redis_sock : NULL;\n    if (!redis_sock) {\n        php_error_docref(NULL, E_WARNING, \"Redis connection not available\");\n        return FAILURE;\n    }\n\n    /* Release lock */\n    lock_release(redis_sock, &pool->lock_status);\n\n    /* send DEL command */\n    zend_string *session = redis_session_key(redis_sock, skey, skeylen);\n    cmd_len = REDIS_SPPRINTF(&cmd, \"DEL\", \"S\", session);\n    zend_string_release(session);\n    if (redis_sock_write(redis_sock, cmd, cmd_len) < 0 || (response = redis_sock_read(redis_sock, &response_len)) == NULL) {\n        php_error_docref(NULL, E_WARNING, \"Error communicating with Redis server\");\n        efree(cmd);\n        return FAILURE;\n    }\n\n    efree(cmd);\n\n    if (response_len == 2 && response[0] == ':' && (response[1] == '0' || response[1] == '1')) {\n        efree(response);\n        return SUCCESS;\n    } else {\n        efree(response);\n        return FAILURE;\n    }\n}\n/* }}} */\n\n/* {{{ PS_GC_FUNC\n */\nPS_GC_FUNC(redis)\n{\n    return SUCCESS;\n}\n/* }}} */\n\n/**\n * Redis Cluster session handler functions\n */\n\n/* Prefix a session key */\nstatic char *cluster_session_key(redisCluster *c, const char *key, int keylen,\n                                 int *skeylen, short *slot) {\n    char *skey;\n\n    *skeylen = keylen + ZSTR_LEN(c->flags->prefix);\n    skey = emalloc(*skeylen);\n    memcpy(skey, ZSTR_VAL(c->flags->prefix), ZSTR_LEN(c->flags->prefix));\n    memcpy(skey + ZSTR_LEN(c->flags->prefix), key, keylen);\n\n    *slot = cluster_hash_key(skey, *skeylen);\n\n    return skey;\n}\n\nPS_OPEN_FUNC(rediscluster) {\n    redisCluster *c;\n    zval z_conf, *zv, *context;\n    HashTable *ht_conf, *ht_seeds;\n    double timeout = 0, read_timeout = 0;\n    int persistent = 0, failover = REDIS_FAILOVER_NONE;\n    zend_string *prefix = NULL, *user = NULL, *pass = NULL, *failstr = NULL;\n\n    /* Parse configuration for session handler */\n    array_init(&z_conf);\n    sapi_module.treat_data(PARSE_STRING, estrdup(save_path), &z_conf);\n\n    /* We need seeds */\n    zv = REDIS_HASH_STR_FIND_TYPE_STATIC(Z_ARRVAL(z_conf), \"seed\", IS_ARRAY);\n    if (zv == NULL) {\n        zval_dtor(&z_conf);\n        return FAILURE;\n    }\n\n    /* Grab a copy of our config hash table and keep seeds array */\n    ht_conf = Z_ARRVAL(z_conf);\n    ht_seeds = Z_ARRVAL_P(zv);\n\n    /* Optional configuration settings */\n    REDIS_CONF_DOUBLE_STATIC(ht_conf, \"timeout\", &timeout);\n    REDIS_CONF_DOUBLE_STATIC(ht_conf, \"read_timeout\", &read_timeout);\n    REDIS_CONF_BOOL_STATIC(ht_conf, \"persistent\", &persistent);\n\n    /* Sanity check on our timeouts */\n    if (timeout < 0 || read_timeout < 0) {\n        php_error_docref(NULL, E_WARNING,\n            \"Can't set negative timeout values in session configuration\");\n        zval_dtor(&z_conf);\n        return FAILURE;\n    }\n\n    REDIS_CONF_STRING_STATIC(ht_conf, \"prefix\", &prefix);\n    REDIS_CONF_AUTH_STATIC(ht_conf, \"auth\", &user, &pass);\n    REDIS_CONF_STRING_STATIC(ht_conf, \"failover\", &failstr);\n\n    /* Need to massage failover string if we have it */\n    if (failstr) {\n        if (zend_string_equals_literal_ci(failstr, \"error\")) {\n            failover = REDIS_FAILOVER_ERROR;\n        } else if (zend_string_equals_literal_ci(failstr, \"distribute\")) {\n            failover = REDIS_FAILOVER_DISTRIBUTE;\n        }\n    }\n\n    redisCachedCluster *cc;\n    zend_string **seeds, *hash = NULL;\n    uint32_t nseeds;\n\n    #define CLUSTER_SESSION_CLEANUP() \\\n        if (hash) zend_string_release(hash); \\\n        if (failstr) zend_string_release(failstr); \\\n        if (prefix) zend_string_release(prefix); \\\n        if (user) zend_string_release(user); \\\n        if (pass) zend_string_release(pass); \\\n        free_seed_array(seeds, nseeds); \\\n        zval_dtor(&z_conf); \\\n\n    /* Extract at least one valid seed or abort */\n    seeds = cluster_validate_args(timeout, read_timeout, ht_seeds, &nseeds, NULL);\n    if (seeds == NULL) {\n        php_error_docref(NULL, E_WARNING, \"No valid seeds detected\");\n        CLUSTER_SESSION_CLEANUP();\n        return FAILURE;\n    }\n\n    c = cluster_create(timeout, read_timeout, failover, persistent);\n\n    if (prefix) {\n        c->flags->prefix = zend_string_copy(prefix);\n    } else {\n        c->flags->prefix = CLUSTER_DEFAULT_PREFIX();\n    }\n\n    c->flags->compression = session_compression_type();\n    c->flags->compression_level = INI_INT(\"redis.session.compression_level\");\n\n    redis_sock_set_auth(c->flags, user, pass);\n\n    if ((context = REDIS_HASH_STR_FIND_TYPE_STATIC(ht_conf, \"stream\", IS_ARRAY)) != NULL) {\n        redis_sock_set_stream_context(c->flags, context);\n    }\n\n    /* First attempt to load from cache */\n    if (CLUSTER_CACHING_ENABLED()) {\n        hash = cluster_hash_seeds(seeds, nseeds);\n        if ((cc = cluster_cache_load(hash))) {\n            cluster_init_cache(c, cc);\n            goto success;\n        }\n    }\n\n    /* Initialize seed array, and attempt to map keyspace */\n    cluster_init_seeds(c, seeds, nseeds);\n    if (cluster_map_keyspace(c) != SUCCESS)\n        goto failure;\n\n    /* Now cache our cluster if caching is enabled */\n    if (hash)\n        cluster_cache_store(hash, c->nodes);\n\nsuccess:\n    CLUSTER_SESSION_CLEANUP();\n    PS_SET_MOD_DATA(c);\n    return SUCCESS;\n\nfailure:\n    CLUSTER_SESSION_CLEANUP();\n    cluster_free(c, 1);\n    return FAILURE;\n}\n\n/* {{{ PS_CREATE_SID_FUNC\n */\nPS_CREATE_SID_FUNC(rediscluster)\n{\n    redisCluster *c = PS_GET_MOD_DATA();\n    clusterReply *reply;\n    char *cmd, *skey;\n    zend_string *sid;\n    int cmdlen, skeylen;\n    int retries = 3;\n    short slot;\n\n    if (!c) {\n        return php_session_create_id(NULL);\n    }\n\n    if (INI_INT(\"session.use_strict_mode\") == 0) {\n        return php_session_create_id((void **) &c);\n    }\n\n    while (retries-- > 0) {\n        sid = php_session_create_id((void **) &c);\n\n        /* Create session key if it doesn't already exist */\n        skey = cluster_session_key(c, ZSTR_VAL(sid), ZSTR_LEN(sid), &skeylen, &slot);\n        cmdlen = redis_spprintf(NULL, NULL, &cmd, \"SET\", \"ssssd\", skey,\n                        skeylen, \"\", 0, \"NX\", 2, \"EX\", 2, session_gc_maxlifetime());\n\n        efree(skey);\n\n        /* Attempt to kick off our command */\n        c->readonly = 0;\n        if (cluster_send_command(c,slot,cmd,cmdlen) < 0 || c->err) {\n            php_error_docref(NULL, E_NOTICE, \"Redis connection not available\");\n            efree(cmd);\n            zend_string_release(sid);\n            return php_session_create_id(NULL);;\n        }\n\n        efree(cmd);\n\n        /* Attempt to read reply */\n        reply = cluster_read_resp(c, 1);\n\n        if (!reply || c->err) {\n            php_error_docref(NULL, E_NOTICE, \"Unable to read redis response\");\n        } else if (reply->len > 0) {\n            cluster_free_reply(reply, 1);\n            break;\n        } else {\n            php_error_docref(NULL, E_NOTICE, \"Redis sid collision on %s, retrying %d time(s)\", sid->val, retries);\n        }\n\n        if (reply) {\n            cluster_free_reply(reply, 1);\n        }\n\n        zend_string_release(sid);\n        sid = NULL;\n    }\n\n    return sid;\n}\n/* }}} */\n\n/* {{{ PS_VALIDATE_SID_FUNC\n */\nPS_VALIDATE_SID_FUNC(rediscluster)\n{\n    redisCluster *c = PS_GET_MOD_DATA();\n    clusterReply *reply;\n    char *cmd, *skey;\n    int cmdlen, skeylen;\n    int res = FAILURE;\n    short slot;\n\n    /* Check key is valid and whether it already exists */\n    if (php_session_valid_key(ZSTR_VAL(key)) == FAILURE) {\n        php_error_docref(NULL, E_NOTICE, \"Invalid session key: %s\", ZSTR_VAL(key));\n        return FAILURE;\n    }\n\n    skey = cluster_session_key(c, ZSTR_VAL(key), ZSTR_LEN(key), &skeylen, &slot);\n    cmdlen = redis_spprintf(NULL, NULL, &cmd, \"EXISTS\", \"s\", skey, skeylen);\n    efree(skey);\n\n    /* We send to master, to ensure consistency */\n    c->readonly = 0;\n    if (cluster_send_command(c,slot,cmd,cmdlen) < 0 || c->err) {\n        php_error_docref(NULL, E_NOTICE, \"Redis connection not available\");\n        efree(cmd);\n        return FAILURE;\n    }\n\n    efree(cmd);\n\n    /* Attempt to read reply */\n    reply = cluster_read_resp(c, 0);\n\n    if (!reply || c->err) {\n        php_error_docref(NULL, E_NOTICE, \"Unable to read redis response\");\n        res = FAILURE;\n    } else if (reply->integer == 1) {\n        res = SUCCESS;\n    }\n\n     /* Clean up */\n    if (reply) {\n        cluster_free_reply(reply, 1);\n    }\n\n    return res;\n}\n/* }}} */\n\n/* {{{ PS_UPDATE_TIMESTAMP_FUNC\n */\nPS_UPDATE_TIMESTAMP_FUNC(rediscluster) {\n    redisCluster *c = PS_GET_MOD_DATA();\n    clusterReply *reply;\n    char *cmd, *skey;\n    int cmdlen, skeylen;\n    short slot;\n\n    /* No need to update the session timestamp if we've already done so */\n    if (INI_INT(\"redis.session.early_refresh\")) {\n        return SUCCESS;\n    }\n\n    /* Set up command and slot info */\n    skey = cluster_session_key(c, ZSTR_VAL(key), ZSTR_LEN(key), &skeylen, &slot);\n    cmdlen = redis_spprintf(NULL, NULL, &cmd, \"EXPIRE\", \"sd\", skey,\n                            skeylen, session_gc_maxlifetime());\n    efree(skey);\n\n    /* Attempt to send EXPIRE command */\n    c->readonly = 0;\n    if (cluster_send_command(c,slot,cmd,cmdlen) < 0 || c->err) {\n        php_error_docref(NULL, E_NOTICE, \"Redis unable to update session expiry\");\n        efree(cmd);\n        return FAILURE;\n    }\n\n    /* Clean up our command */\n    efree(cmd);\n\n    /* Attempt to read reply */\n    reply = cluster_read_resp(c, 0);\n    if (!reply || c->err) {\n        if (reply) cluster_free_reply(reply, 1);\n        return FAILURE;\n    }\n\n    /* Clean up */\n    cluster_free_reply(reply, 1);\n\n    return SUCCESS;\n}\n/* }}} */\n\n/* {{{ PS_READ_FUNC\n */\nPS_READ_FUNC(rediscluster) {\n    redisCluster *c = PS_GET_MOD_DATA();\n    clusterReply *reply;\n    char *cmd, *skey, *compressed_buf;\n    int cmdlen, skeylen, free_flag, compressed_free;\n    size_t compressed_len;\n    short slot;\n\n    /* Set up our command and slot information */\n    skey = cluster_session_key(c, ZSTR_VAL(key), ZSTR_LEN(key), &skeylen, &slot);\n\n    /* Update the session ttl if early refresh is enabled */\n    if (INI_INT(\"redis.session.early_refresh\")) {\n        cmdlen = redis_spprintf(NULL, NULL, &cmd, \"GETEX\", \"ssd\", skey,\n                                skeylen, \"EX\", 2, session_gc_maxlifetime());\n        c->readonly = 0;\n    } else {\n        cmdlen = redis_spprintf(NULL, NULL, &cmd, \"GET\", \"s\", skey, skeylen);\n        c->readonly = 1;\n    }\n\n    efree(skey);\n\n    /* Attempt to kick off our command */\n    if (cluster_send_command(c,slot,cmd,cmdlen) < 0 || c->err) {\n        efree(cmd);\n        return FAILURE;\n    }\n\n    /* Clean up command */\n    efree(cmd);\n\n    /* Attempt to read reply */\n    reply = cluster_read_resp(c, 0);\n    if (!reply || c->err) {\n        if (reply) cluster_free_reply(reply, 1);\n        return FAILURE;\n    }\n\n    /* Push reply value to caller */\n    if (reply->str == NULL) {\n        *val = ZSTR_EMPTY_ALLOC();\n    } else {\n        compressed_free = session_uncompress_data(c->flags, reply->str, reply->len, &compressed_buf, &compressed_len);\n        *val = zend_string_init(compressed_buf, compressed_len, 0);\n        if (compressed_free) {\n            efree(compressed_buf); // Free the buffer allocated by redis_uncompress\n        }\n    }\n\n    free_flag = 1;\n\n    /* Clean up */\n    cluster_free_reply(reply, free_flag);\n\n    /* Success! */\n    return SUCCESS;\n}\n\n/* {{{ PS_WRITE_FUNC\n */\nPS_WRITE_FUNC(rediscluster) {\n    redisCluster *c = PS_GET_MOD_DATA();\n    clusterReply *reply;\n    char *cmd, *skey, *sval;\n    int cmdlen, skeylen, compressed_free;\n    size_t svallen;\n    short slot;\n\n    compressed_free = session_compress_data(c->flags, ZSTR_VAL(val), ZSTR_LEN(val),\n                                            &sval, &svallen);\n\n    /* Set up command and slot info */\n    skey = cluster_session_key(c, ZSTR_VAL(key), ZSTR_LEN(key), &skeylen, &slot);\n    cmdlen = redis_spprintf(NULL, NULL, &cmd, \"SETEX\", \"sds\", skey,\n                            skeylen, session_gc_maxlifetime(),\n                            sval, svallen);\n    efree(skey);\n    if (compressed_free) {\n        efree(sval);\n    }\n\n    /* Attempt to send command */\n    c->readonly = 0;\n    if (cluster_send_command(c,slot,cmd,cmdlen) < 0 || c->err) {\n        efree(cmd);\n        return FAILURE;\n    }\n\n    /* Clean up our command */\n    efree(cmd);\n\n    /* Attempt to read reply */\n    reply = cluster_read_resp(c, 0);\n    if (!reply || c->err) {\n        if (reply) cluster_free_reply(reply, 1);\n        return FAILURE;\n    }\n\n    /* Clean up*/\n    cluster_free_reply(reply, 1);\n\n    return SUCCESS;\n}\n\n/* {{{ PS_DESTROY_FUNC(rediscluster)\n */\nPS_DESTROY_FUNC(rediscluster) {\n    redisCluster *c = PS_GET_MOD_DATA();\n    clusterReply *reply;\n    char *cmd, *skey;\n    int cmdlen, skeylen;\n    short slot;\n\n    /* Set up command and slot info */\n    skey = cluster_session_key(c, ZSTR_VAL(key), ZSTR_LEN(key), &skeylen, &slot);\n\n    cmdlen = redis_spprintf(NULL, NULL, &cmd, \"DEL\", \"s\", skey, skeylen);\n    efree(skey);\n\n    /* Attempt to send command */\n    if (cluster_send_command(c,slot,cmd,cmdlen) < 0 || c->err) {\n        efree(cmd);\n        return FAILURE;\n    }\n\n    /* Clean up our command */\n    efree(cmd);\n\n    /* Attempt to read reply */\n    reply = cluster_read_resp(c, 0);\n    if (!reply || c->err) {\n        if (reply) cluster_free_reply(reply, 1);\n        return FAILURE;\n    }\n\n    /* Clean up our reply */\n    cluster_free_reply(reply, 1);\n\n    return SUCCESS;\n}\n\n/* {{{ PS_CLOSE_FUNC\n */\nPS_CLOSE_FUNC(rediscluster)\n{\n    redisCluster *c = PS_GET_MOD_DATA();\n    if (c) {\n        cluster_free(c, 1);\n        PS_SET_MOD_DATA(NULL);\n    }\n    return SUCCESS;\n}\n\n/* {{{ PS_GC_FUNC\n */\nPS_GC_FUNC(rediscluster) {\n    return SUCCESS;\n}\n\n#endif\n\n/* vim: set tabstop=4 expandtab: */\n"
        },
        {
          "name": "redis_session.h",
          "type": "blob",
          "size": 0.6064453125,
          "content": "#ifndef REDIS_SESSION_H\n#define REDIS_SESSION_H\n#ifdef PHP_SESSION\n#include \"ext/session/php_session.h\"\n\nPS_OPEN_FUNC(redis);\nPS_CLOSE_FUNC(redis);\nPS_READ_FUNC(redis);\nPS_WRITE_FUNC(redis);\nPS_DESTROY_FUNC(redis);\nPS_GC_FUNC(redis);\nPS_CREATE_SID_FUNC(redis);\n\nPS_VALIDATE_SID_FUNC(redis);\nPS_UPDATE_TIMESTAMP_FUNC(redis);\n\nPS_OPEN_FUNC(rediscluster);\nPS_CLOSE_FUNC(rediscluster);\nPS_READ_FUNC(rediscluster);\nPS_WRITE_FUNC(rediscluster);\nPS_DESTROY_FUNC(rediscluster);\nPS_GC_FUNC(rediscluster);\nPS_CREATE_SID_FUNC(rediscluster);\nPS_VALIDATE_SID_FUNC(rediscluster);\nPS_UPDATE_TIMESTAMP_FUNC(rediscluster);\n\n#endif\n#endif\n"
        },
        {
          "name": "rpm",
          "type": "tree",
          "content": null
        },
        {
          "name": "sentinel.md",
          "type": "blob",
          "size": 7.560546875,
          "content": "Redis Sentinel\n==============\n\nRedis Sentinel provides high availability for Redis. In practical terms this means that using Sentinel you can create a Redis deployment that resists without human intervention certain kinds of failures.\n\nRedis Sentinel also provides other collateral tasks such as monitoring, notifications and acts as a configuration provider for clients.\n\n## Class RedisSentinel\n-----\n\n##### *Parameters*\n\n*host*: String, IP address or hostname  \n*port*: Int (optional, default is 26379)  \n*timeout*: Float, value in seconds (optional, default is 0 meaning unlimited)  \n*persistent*: String, persistent connection id (optional, default is NULL meaning not persistent)  \n*retry_interval*: Int, value in milliseconds (optional, default is 0)  \n*read_timeout*: Float, value in seconds (optional, default is 0 meaning unlimited)  \n*auth*:String, or an Array with one or two elements, used to authenticate with the redis-sentinel. (optional, default is NULL meaning NOAUTH)\n\n##### *Examples for version 6.0 or later*\n\n~~~php\n$sentinel = new RedisSentinel([\n  'host' => '127.0.0.1',\n]); // default parameters\n$sentinel = new RedisSentinel([\n  'host' => '127.0.0.1',\n  'port' => 26379,\n  'connectTimeout' => 2.5,\n]); // 2.5 sec timeout.\n$sentinel = new RedisSentinel([\n  'host' => '127.0.0.1',\n  'port' => 26379,\n  'connectTimeout' => 2.5,\n  'persistent' => 'sentinel',\n]); // persistent connection with id 'sentinel'\n$sentinel = new RedisSentinel([\n  'host' => '127.0.0.1',\n  'port' => 26379,\n  'connectTimeout' => 2.5,\n  'persistent' => '',\n]); // also persistent connection with id ''\n$sentinel = new RedisSentinel([\n  'host' => '127.0.0.1',\n  'port' => 26379,\n  'connectTimeout' => 1,\n  'persistent' => null,\n  'retryInterval' => 100,\n]); // 1 sec timeout, 100ms delay between reconnection attempts.\n$sentinel = new RedisSentinel([\n  'host' => '127.0.0.1',\n  'port' => 26379,\n  'connectTimeout' => 0,\n  'persistent' => null,\n  'retryInterval' => 0,\n  'readTimeout' => 0,\n  'auth' => 'secret',\n]); // connect sentinel with password authentication\n~~~\n\n##### *Examples for versions older than 6.0*\n\n~~~php\n$sentinel = new RedisSentinel('127.0.0.1'); // default parameters\n$sentinel = new RedisSentinel('127.0.0.1', 26379, 2.5); // 2.5 sec timeout.\n$sentinel = new RedisSentinel('127.0.0.1', 26379, 0, 'sentinel'); // persistent connection with id 'sentinel'\n$sentinel = new RedisSentinel('127.0.0.1', 26379, 0, ''); // also persistent connection with id ''\n$sentinel = new RedisSentinel('127.0.0.1', 26379, 1, null, 100); // 1 sec timeout, 100ms delay between reconnection attempts.\n$sentinel = new RedisSentinel('127.0.0.1', 26379, 0, NULL, 0, 0, \"secret\"); // connect sentinel with password authentication\n~~~\n\n### Usage\n-----\n\n* [ckquorum](#ckquorum) - Check if the current Sentinel configuration is able to reach the quorum needed to failover.\n* [failover](#failover) - Force a failover as if the master was not reachable.\n* [flushconfig](#flushconfig) - Force Sentinel to rewrite its configuration on disk.\n* [getMasterAddrByName](#getMasterAddrByName) - Return the ip and port number of the master with that name.\n* [master](#master) - Return the state and info of the specified master.\n* [masters](#masters) - Return a list of monitored masters and their state.\n* [ping](#ping) - Ping the sentinel.\n* [reset](#reset) - Reset all the masters with matching name.\n* [sentinels](#sentinels) - Return a list of sentinel instances for this master, and their state.\n* [slaves](#slaves) - Return a list of replicas for this master, and their state.\n\n-----\n\n### ckquorum\n-----\n_**Description**_: Check if the current Sentinel configuration is able to reach the quorum needed to failover a master, and the majority needed to authorize the failover. This command should be used in monitoring systems to check if a Sentinel deployment is ok.\n\n##### *Parameters*\n*String*: master name\n\n##### *Return value*\n*Bool*: `TRUE` in case of success, `FALSE` in case of failure.\n\n##### *Example*\n~~~php\n$sentinel->ckquorum('mymaster');\n~~~\n\n### failover\n-----\n_**Description**_: Force a failover as if the master was not reachable, and without asking for agreement to other Sentinels (however a new version of the configuration will be published so that the other Sentinels will update their configurations).\n\n##### *Parameters*\n*String*: master name\n\n##### *Return value*\n*Bool*: `TRUE` in case of success, `FALSE` in case of failure.\n\n##### *Example*\n~~~php\n$sentinel->failover('mymaster');\n~~~\n\n### flushconfig\n-----\n_**Description**_: Force Sentinel to rewrite its configuration on disk, including the current Sentinel state. Normally Sentinel rewrites the configuration every time something changes in its state (in the context of the subset of the state which is persisted on disk across restart). However sometimes it is possible that the configuration file is lost because of operation errors, disk failures, package upgrade scripts or configuration managers. In those cases a way to to force Sentinel to rewrite the configuration file is handy. This command works even if the previous configuration file is completely missing.\n\n##### *Parameters*\n(none)\n\n##### *Return value*\n*Bool*: `TRUE` in case of success, `FALSE` in case of failure.\n\n##### *Example*\n~~~php\n$sentinel->flushconfig();\n~~~\n\n### getMasterAddrByName\n-----\n_**Description**_: Return the ip and port number of the master with that name. If a failover is in progress or terminated successfully for this master it returns the address and port of the promoted replica.\n\n##### *Parameters*\n*String*: master name\n\n##### *Return value*\n*Array*, *Bool*: ['address', 'port'] in case of success, `FALSE` in case of failure.\n\n##### *Example*\n~~~php\n$sentinel->getMasterAddrByName('mymaster');\n~~~\n\n### master\n-----\n_**Description**_: Return the state and info of the specified master.\n\n##### *Parameters*\n*String*: master name\n\n##### *Return value*\n*Array*, *Bool*: Associative array with info in case of success, `FALSE` in case of failure.\n\n##### *Example*\n~~~php\n$sentinel->master('mymaster');\n~~~\n\n### masters\n-----\n_**Description**_: Return a list of monitored masters and their state.\n\n##### *Parameters*\n(none)\n\n##### *Return value*\n*Array*, *Bool*: List of arrays with info for each master in case of success, `FALSE` in case of failure.\n\n##### *Example*\n~~~php\n$sentinel->masters();\n~~~\n\n### ping\n-----\n_**Description**_: Ping the sentinel.\n\n##### *Parameters*\n(none)\n\n##### *Return value*\n*Bool*: `TRUE` in case of success, `FALSE` in case of failure.\n\n##### *Example*\n~~~php\n$sentinel->ping();\n~~~\n\n### reset\n-----\n_**Description**_: This command will reset all the masters with matching name. The pattern argument is a glob-style pattern. The reset process clears any previous state in a master (including a failover in progress), and removes every replica and sentinel already discovered and associated with the master.\n\n##### *Parameters*\n*String*: pattern\n\n##### *Return value*\n*Bool*: `TRUE` in case of success, `FALSE` in case of failure.\n\n##### *Example*\n~~~php\n$sentinel->reset('*');\n~~~\n\n### sentinels\n-----\n_**Description**_: Return a list of sentinel instances for this master, and their state.\n\n##### *Parameters*\n*String*: master name\n\n##### *Return value*\n*Array*, *Bool*: List of arrays with info for each sentinels in case of success, `FALSE` in case of failure.\n\n##### *Example*\n~~~php\n$sentinel->sentinels('mymaster');\n~~~\n\n### slaves\n-----\n_**Description**_: Return a list of replicas for this master, and their state.\n\n##### *Parameters*\n*String*: master name\n\n##### *Return value*\n*Array*, *Bool*: List of arrays with info for each replicas in case of success, `FALSE` in case of failure.\n\n##### *Example*\n~~~php\n$sentinel->slaves('mymaster');\n~~~\n"
        },
        {
          "name": "sentinel_library.c",
          "type": "blob",
          "size": 1.9423828125,
          "content": "#include \"sentinel_library.h\"\n\nstatic zend_object_handlers redis_sentinel_object_handlers;\n\nstatic void\nfree_redis_sentinel_object(zend_object *object)\n{\n    redis_sentinel_object *obj = PHPREDIS_GET_OBJECT(redis_sentinel_object, object);\n\n    if (obj->sock) {\n        redis_sock_disconnect(obj->sock, 0, 1);\n        redis_free_socket(obj->sock);\n    }\n    zend_object_std_dtor(&obj->std);\n}\n\nzend_object *\ncreate_sentinel_object(zend_class_entry *ce)\n{\n    redis_sentinel_object *obj = ecalloc(1, sizeof(*obj) + zend_object_properties_size(ce));\n\n    zend_object_std_init(&obj->std, ce);\n    object_properties_init(&obj->std, ce);\n\n    memcpy(&redis_sentinel_object_handlers, zend_get_std_object_handlers(), sizeof(redis_sentinel_object_handlers));\n    redis_sentinel_object_handlers.offset = XtOffsetOf(redis_sentinel_object, std);\n    redis_sentinel_object_handlers.free_obj = free_redis_sentinel_object;\n    obj->std.handlers = &redis_sentinel_object_handlers;\n\n    return &obj->std;\n}\n\nPHP_REDIS_API int\nsentinel_mbulk_reply_zipped_assoc(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx)\n{\n    char inbuf[4096];\n    int i, nelem;\n    size_t len;\n    zval z_ret;\n\n    /* Throws exception on failure */\n    if (redis_sock_gets(redis_sock, inbuf, sizeof(inbuf) - 1, &len) < 0) {\n        RETVAL_FALSE;\n        return FAILURE;\n    }\n\n    if (*inbuf != TYPE_MULTIBULK) {\n        if (*inbuf == TYPE_ERR) {\n            redis_sock_set_err(redis_sock, inbuf + 1, len - 1);\n        }\n\n        RETVAL_FALSE;\n        return FAILURE;\n    }\n    array_init(&z_ret);\n    nelem = atoi(inbuf + 1);\n    for (i = 0; i < nelem; ++i) {\n        /* redis_mbulk_reply_zipped_raw calls redis_mbulk_reply_zipped\n         * which puts result into return_value via RETVAL_ZVAL */\n        redis_mbulk_reply_zipped_raw(INTERNAL_FUNCTION_PARAM_PASSTHRU, redis_sock, z_tab, ctx);\n        add_next_index_zval(&z_ret, return_value);\n    }\n\n    RETVAL_ZVAL(&z_ret, 0, 1);\n    return SUCCESS;\n}\n"
        },
        {
          "name": "sentinel_library.h",
          "type": "blob",
          "size": 0.3740234375,
          "content": "#ifndef REDIS_SENTINEL_LIBRARY_H\n#define REDIS_SENTINEL_LIBRARY_H\n\n#include \"common.h\"\n#include \"library.h\"\n\ntypedef redis_object redis_sentinel_object;\n\nzend_object *create_sentinel_object(zend_class_entry *ce);\n\nPHP_REDIS_API int sentinel_mbulk_reply_zipped_assoc(INTERNAL_FUNCTION_PARAMETERS, RedisSock *redis_sock, zval *z_tab, void *ctx);\n\n#endif /* REDIS_SENTINEL_LIBRARY_H */\n"
        },
        {
          "name": "serialize.list",
          "type": "blob",
          "size": 0.3994140625,
          "content": "This file lists which methods support serialization. Only indented methods have been ported.\n\n\tget\n\tset\n\tsetex\n\tsetnx\n\tgetSet\n\tmGet\nappend\ngetRange\nstrlen\n\tlPush\n\tlPushx\n\trPush\n\trPushx\n\tlPop\n\trPop\n\tblPop\n\tbrPop\n\tlRange\n\tlRem\n\tlIndex\n\tlSet\n\tlInsert\n\n\tsAdd\n\tsRem\n\tsMove\n\tsIsMember\n\n\tzAdd\n\tzRem\n\tzScore\n\tzRank\n\tzRevRank\n\tzIncrBy\n\n\tmset\n\n\thGet\n\thSet\n\thGetAll\n\thExists\n\thMset\n\thMget\n\npublish\nsubscribe\nunsubscribe\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}