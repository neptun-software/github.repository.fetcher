{
  "metadata": {
    "timestamp": 1736710440453,
    "page": 82,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "DaveGamble/cJSON",
      "stars": 11036,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.41796875,
          "content": "root = true\n\n\n[*]\nindent_style = space\nindent_size = 4\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[Makefile]\nindent_style = tab\nindent_size = unset\n\n# ignore external repositories and test inputs\n[tests/{unity,json-patch-tests,inputs}/*]\nindent_style = unset\nindent_size = unset\nend_of_line = unset\ncharset = unset\ntrim_trailing_whitespace = unset\ninsert_final_newline = unset\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.33203125,
          "content": "*  \t\t\t\t\ttext=auto\n/tests/inputs/*\ttext eol=lf\n\n.gitattributes          export-ignore\n.gitignore              export-ignore\n.github                 export-ignore\n.editorconfig           export-ignore\n.travis.yml             export-ignore\n\n# Linguist incorrectly identified the headers as C++, manually override this.\n*.h linguist-language=C\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1669921875,
          "content": ".svn\ntest\n*.o\n*.a\n*.so\n*.swp\n*.patch\ntags\n*.dylib*\nbuild/\ncJSON_test\ncJSON_test_utils\nlibcjson.so.*\nlibcjson_utils.so.*\n*.orig\n.vscode\n.idea\ncmake-build-debug\n*.lst\n*.lss\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.587890625,
          "content": "dist: trusty\nsudo: false\nlanguage: c\nenv:\n  matrix:\n    - VALGRIND=On SANITIZERS=Off\n    - VALGRIND=Off SANITIZERS=Off\n    - VALGRIND=Off SANITIZERS=On\ncompiler:\n  - gcc\n  - clang\naddons:\n  apt:\n    packages:\n      - valgrind\n      - libasan0\n      - lib32asan0\n      # currently not supported on travis:\n      # - libasan1\n      # - libasan2\n      # - libubsan0\n      - llvm\nscript:\n  - mkdir build\n  - cd build\n  - cmake .. -DENABLE_CJSON_UTILS=On -DENABLE_VALGRIND=\"${VALGRIND}\" -DENABLE_SAFE_STACK=\"${VALGRIND}\" -DENABLE_SANITIZERS=\"${SANITIZERS}\"\n  - make\n  - make test CTEST_OUTPUT_ON_FAILURE=On\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 24.857421875,
          "content": "1.7.18 (May 13, 2024)\n======\nFixes:\n------\n* Add NULL check to cJSON_SetValuestring()(CVE-2024-31755), see #839 and #840\n* Remove non-functional list handling of compiler flags, see #851\n* Fix heap buffer overflow, see #852\n* remove misused optimization flag -01, see #854\n* Set free'd pointers to NULL whenever they are not reassigned immediately after, see #855 and #833\n\n1.7.17 (Dec 26, 2023)\n======\nFixes:\n------\n* Fix null reference in cJSON_SetValuestring(CVE-2023-50472), see #809\n* Fix null reference in cJSON_InsertItemInArray(CVE-2023-50471), see #809 and #810\n\n1.7.16 (Jul 5, 2023)\n======\nFeatures:\n------\n* Add an option for ENABLE_CJSON_VERSION_SO in CMakeLists.txt, see #534\n* Add cmake_policy to CMakeLists.txt, see #163\n* Add cJSON_SetBoolValue, see #639\n* Add meson documentation, see #761\n\nFixes:\n------\n* Fix memory leak in merge_patch, see #611\n* Fix conflicting target names 'uninstall', see #617\n* Bump cmake version to 3.0 and use new version syntax, see #587\n* Print int without decimal places, see #630\n* Fix 'cjson_utils-static' target not exist, see #625\n* Add allocate check for replace_item_in_object, see #675\n* Fix a null pointer crash in cJSON_ReplaceItemViaPointer, see #726\n\n1.7.15 (Aug 25, 2021)\n======\nFixes:\n------\n* Fix potential core dumped for strrchr, see [#546](https://github.com/DaveGamble/cJSON/pull/546)\n* Fix null pointer crash in cJSON_CreateXxArray, see [#538](https://github.com/DaveGamble/cJSON/pull/538)\n* Fix several null pointer problems on allocation failure, see [#526](https://github.com/DaveGamble/cJSON/pull/526)\n* Fix a possible dereference of null pointer, see [#519](https://github.com/DaveGamble/cJSON/pull/519)\n* Fix windows build failure about defining nan, see [#518](https://github.com/DaveGamble/cJSON/pull/518)\n\n1.7.14 (Sep 3, 2020)\n======\nFixes:\n------\n* optimize the way to find tail node, see [#503](https://github.com/DaveGamble/cJSON/pull/503)\n* Fix WError error on macosx because NAN is a float. Thanks @sappo, see [#484](https://github.com/DaveGamble/cJSON/pull/484)\n* Fix some bugs in detach and replace. Thanks @miaoerduo, see [#456](https://github.com/DaveGamble/cJSON/pull/456)\n\n1.7.13 (Apr 2, 2020)\n======\nFeatures:\n---------\n* add new API of cJSON_ParseWithLength without breaking changes. Thanks @caglarivriz, see [#358](https://github.com/DaveGamble/cJSON/pull/358)  \n* add new API of cJSON_GetNumberValue. Thanks @Intuition, see[#385](https://github.com/DaveGamble/cJSON/pull/385)  \n* add uninstall target function for CMake. See [#402](https://github.com/DaveGamble/cJSON/pull/402)  \n* Improve performance of adding item to array. Thanks @xiaomianhehe, see [#430](https://github.com/DaveGamble/cJSON/pull/430), [#448](https://github.com/DaveGamble/cJSON/pull/448)  \n* add new API of cJSON_SetValuestring, for changing the valuestring safely. See [#451](https://github.com/DaveGamble/cJSON/pull/451)  \n* add return value for cJSON_AddItemTo... and cJSON_ReplaceItem... (check if the operation successful). See [#453](https://github.com/DaveGamble/cJSON/pull/453)  \n\nFixes:\n------\n* Fix clang -Wfloat-equal warning. Thanks @paulmalovanyi, see [#368](https://github.com/DaveGamble/cJSON/pull/368)  \n* Fix make failed in mac os. See [#405](https://github.com/DaveGamble/cJSON/pull/405)  \n* Fix memory leak in cJSONUtils_FindPointerFromObjectTo. Thanks @andywolk for reporting, see [#414](https://github.com/DaveGamble/cJSON/issues/414)  \n* Fix bug in encode_string_as_pointer. Thanks @AIChangJiang for reporting, see [#439](https://github.com/DaveGamble/cJSON/issues/439)  \n\n1.7.12 (May 17, 2019)\n======\nFixes:\n------\n* Fix infinite loop in `cJSON_Minify` (potential Denial of Service). Thanks @Alanscut for reporting, see [#354](https://github.com/DaveGamble/cJSON/issues/354)\n* Fix link error for Visual Studio. Thanks @tan-wei, see [#352](https://github.com/DaveGamble/cJSON/pull/352).\n* Undefine `true` and `false` for `cJSON_Utils` before redefining them. Thanks @raiden00pl, see [#347](https://github.com/DaveGamble/cJSON/pull/347).\n\n1.7.11 (Apr 15, 2019)\n======\nFixes:\n------\n* Fix a bug where cJSON_Minify could overflow it's buffer, both reading and writing. This is a security issue, see [#338](https://github.com/DaveGamble/cJSON/issues/338). Big thanks @bigric3 for reporting.\n* Unset `true` and `false` macros before setting them if they exist. See [#339](https://github.com/DaveGamble/cJSON/issues/339), thanks @raiden00pl for reporting\n\n1.7.10 (Dec 21, 2018)\n======\nFixes:\n------\n* Fix package config file for `libcjson`. Thanks @shiluotang for reporting [#321](https://github.com/DaveGamble/cJSON/issues/321)\n* Correctly split lists in `cJSON_Utils`'s merge sort. Thanks @andysCaplin for the fix [#322](https://github.com/DaveGamble/cJSON/issues/322)\n\n1.7.9 (Dec 16, 2018)\n=====\nFixes:\n------\n* Fix a bug where `cJSON_GetObjectItemCaseSensitive` would pass a nullpointer to `strcmp` when called on an array, see [#315](https://github.com/DaveGamble/cJSON/issues/315). Thanks @yuweol for reporting.\n* Fix error in `cJSON_Utils` where the case sensitivity was not respected, see [#317](https://github.com/DaveGamble/cJSON/pull/317). Thanks @yuta-oxo for fixing.\n* Fix some warnings detected by the Visual Studio Static Analyzer, see [#307](https://github.com/DaveGamble/cJSON/pull/307). Thanks @bnason-nf\n\n1.7.8 (Sep 22, 2018)\n======\nFixes:\n------\n* cJSON now works with the `__stdcall` calling convention on Windows, see [#295](https://github.com/DaveGamble/cJSON/pull/295), thanks @zhindes for contributing\n\n1.7.7 (May 22, 2018)\n=====\nFixes:\n------\n* Fix a memory leak when realloc fails, see [#267](https://github.com/DaveGamble/cJSON/issues/267), thanks @AlfieDeng for reporting\n* Fix a typo in the header file, see [#266](https://github.com/DaveGamble/cJSON/pull/266), thanks @zhaozhixu\n\n1.7.6 (Apr 13, 2018)\n=====\nFixes:\n------\n* Add `SONAME` to the ELF files built by the Makefile, see [#252](https://github.com/DaveGamble/cJSON/issues/252), thanks @YanhaoMo for reporting\n* Add include guards and `extern \"C\"` to `cJSON_Utils.h`, see [#256](https://github.com/DaveGamble/cJSON/issues/256), thanks @daschfg for reporting\n\nOther changes:\n* Mark the Makefile as deprecated in the README.\n\n1.7.5 (Mar 23, 2018)\n=====\nFixes:\n------\n* Fix a bug in the JSON Patch implementation of `cJSON Utils`, see [#251](https://github.com/DaveGamble/cJSON/pull/251), thanks @bobkocisko.\n\n1.7.4 (Mar 3, 2018)\n=====\nFixes:\n------\n* Fix potential use after free if the `string` parameter to `cJSON_AddItemToObject` is an alias of the `string` property of the object that is added,see [#248](https://github.com/DaveGamble/cJSON/issues/248). Thanks @hhallen for reporting.\n\n1.7.3 (Feb 8, 2018)\n=====\nFixes:\n------\n* Fix potential double free, thanks @projectgus for reporting [#241](https://github.com/DaveGamble/cJSON/issues/241)\n\n1.7.2 (Feb 6, 2018)\n=====\nFixes:\n------\n* Fix the use of GNUInstallDirs variables and the pkgconfig file. Thanks @zeerd for reporting [#240](https://github.com/DaveGamble/cJSON/pull/240)\n\n1.7.1 (Jan 10, 2018)\n=====\nFixes:\n------\n* Fixed an Off-By-One error that could lead to an out of bounds write. Thanks @liuyunbin for reporting [#230](https://github.com/DaveGamble/cJSON/issues/230)\n* Fixed two errors with buffered printing. Thanks @liuyunbin for reporting [#230](https://github.com/DaveGamble/cJSON/issues/230)\n\n1.7.0 (Dec 31, 2017)\n=====\nFeatures:\n---------\n* Large rewrite of the documentation, see [#215](https://github.com/DaveGamble/cJSON/pull/215)\n* Added the `cJSON_GetStringValue` function\n* Added the `cJSON_CreateStringReference` function\n* Added the `cJSON_CreateArrayReference` function\n* Added the `cJSON_CreateObjectReference` function\n* The `cJSON_Add...ToObject` macros are now functions that return a pointer to the added item, see [#226](https://github.com/DaveGamble/cJSON/pull/226)\n\nFixes:\n------\n* Fix a problem with `GNUInstallDirs` in the CMakeLists.txt, thanks @yangfl, see [#210](https://github.com/DaveGamble/cJSON/pull/210)\n* Fix linking the tests when building as static library, see [#213](https://github.com/DaveGamble/cJSON/issues/213)\n* New overrides for the CMake option `BUILD_SHARED_LIBS`, see [#207](https://github.com/DaveGamble/cJSON/issues/207)\n\nOther Changes:\n--------------\n* Readme: Explain how to include cJSON, see [#211](https://github.com/DaveGamble/cJSON/pull/211)\n* Removed some trailing spaces in the code, thanks @yangfl, see [#212](https://github.com/DaveGamble/cJSON/pull/212)\n* Updated [Unity](https://github.com/ThrowTheSwitch/Unity) and [json-patch-tests](https://github.com/json-patch/json-patch-tests)\n\n1.6.0 (Oct 9, 2017)\n=====\nFeatures:\n---------\n* You can now build cJSON as both shared and static library at once with CMake using `-DBUILD_SHARED_AND_STATIC_LIBS=On`, see [#178](https://github.com/DaveGamble/cJSON/issues/178)\n* UTF-8 byte order marks are now ignored, see [#184](https://github.com/DaveGamble/cJSON/issues/184)\n* Locales can now be disabled with the option `-DENABLE_LOCALES=Off`, see [#202](https://github.com/DaveGamble/cJSON/issues/202), thanks @Casperinous\n* Better support for MSVC and Visual Studio\n\nOther Changes:\n--------------\n* Add the new warnings `-Wswitch-enum`, `-Wused-but-makred-unused`, `-Wmissing-variable-declarations`, `-Wunused-macro`\n* More number printing tests.\n* Continuous integration testing with AppVeyor (semi automatic at this point), thanks @simon-p-r\n\n1.5.9 (Sep 8, 2017)\n=====\nFixes:\n------\n* Set the global error pointer even if `return_parse_end` is passed to `cJSON_ParseWithOpts`, see [#200](https://github.com/DaveGamble/cJSON/pull/200), thanks @rmallins\n\n1.5.8 (Aug 21, 2017)\n=====\nFixes:\n------\n* Fix `make test` in the Makefile, thanks @YanhaoMo for reporting this [#195](https://github.com/DaveGamble/cJSON/issues/195)\n\n1.5.7 (Jul 13, 2017)\n=====\nFixes:\n------\n* Fix a bug where realloc failing would return a pointer to an invalid memory address. This is a security issue as it could potentially be used by an attacker to write to arbitrary memory addresses, see [#189](https://github.com/DaveGamble/cJSON/issues/189),  fixed in [954d61e](https://github.com/DaveGamble/cJSON/commit/954d61e5e7cb9dc6c480fc28ac1cdceca07dd5bd), big thanks @timothyjohncarney for reporting this issue\n* Fix a spelling mistake in the AFL fuzzer dictionary, see [#185](https://github.com/DaveGamble/cJSON/pull/185), thanks @jwilk\n\n1.5.6 (Jun 28, 2017)\n=====\nFixes:\n------\n* Make cJSON a lot more tolerant about passing NULL pointers to its functions, it should now fail safely instead of dereferencing the pointer, see [#183](https://github.com/DaveGamble/cJSON/pull/183). Thanks @msichal for reporting [#182](https://github.com/DaveGamble/cJSON/issues/182)\n\n1.5.5 (Jun 15, 2017)\n=====\nFixes:\n------\n* Fix pointers to nested arrays in cJSON_Utils, see [9abe](https://github.com/DaveGamble/cJSON/commit/9abe75e072050f34732a7169740989a082b65134)\n* Fix an error with case sensitivity handling in cJSON_Utils, see [b9cc911](https://github.com/DaveGamble/cJSON/commit/b9cc911831b0b3e1bb72f142389428e59f882b38)\n* Fix cJSON_Compare for arrays that are prefixes of the other and objects that are a subset of the other, see [03ba72f](https://github.com/DaveGamble/cJSON/commit/03ba72faec115160d1f3aea5582d9b6af5d3e473) and [#180](https://github.com/DaveGamble/cJSON/issues/180), thanks @zhengqb for reporting\n\n1.5.4 (Jun 5, 2017)\n======\nFixes:\n------\n* Fix build with GCC 7.1.1 and optimization level `-O2`, see [bfbd8fe](https://github.com/DaveGamble/cJSON/commit/bfbd8fe0d85f1dd21e508748fc10fc4c27cc51be)\n\nOther Changes:\n--------------\n* Update [Unity](https://github.com/ThrowTheSwitch/Unity) to 3b69beaa58efc41bbbef70a32a46893cae02719d\n\n1.5.3 (May 23, 2017)\n=====\nFixes:\n------\n* Fix `cJSON_ReplaceItemInObject` not keeping the name of an item, see [#174](https://github.com/DaveGamble/cJSON/issues/174)\n\n1.5.2 (May 10, 2017)\n=====\nFixes:\n------\n* Fix a reading buffer overflow in `parse_string`, see [a167d9e](https://github.com/DaveGamble/cJSON/commit/a167d9e381e5c84bc03de4e261757b031c0c690d)\n* Fix compiling with -Wcomma, see [186cce3](https://github.com/DaveGamble/cJSON/commit/186cce3ece6ce6dfcb58ac8b2a63f7846c3493ad)\n* Remove leftover attribute from tests, see [b537ca7](https://github.com/DaveGamble/cJSON/commit/b537ca70a35680db66f1f5b8b437f7114daa699a)\n\n1.5.1 (May 6, 2017)\n=====\nFixes:\n------\n* Add gcc version guard to the Makefile, see [#164](https://github.com/DaveGamble/cJSON/pull/164), thanks @juvasquezg\n* Fix incorrect free in `cJSON_Utils` if custom memory allocator is used, see [#166](https://github.com/DaveGamble/cJSON/pull/166), thanks @prefetchnta\n\n1.5.0 (May 2, 2017)\n=====\nFeatures:\n* cJSON finally prints numbers without losing precision, see [#153](https://github.com/DaveGamble/cJSON/pull/153), thanks @DeboraG\n* `cJSON_Compare` recursively checks if two cJSON items contain the same values, see [#148](https://github.com/DaveGamble/cJSON/pull/148)\n* Provide case sensitive versions of every function where it matters, see [#158](https://github.com/DaveGamble/cJSON/pull/158) and [#159](https://github.com/DaveGamble/cJSON/pull/159)\n* Added `cJSON_ReplaceItemViaPointer` and `cJSON_DetachItemViaPointer`\n* Added `cJSON_free` and `cJSON_malloc` that expose the internal configured memory allocators. see [02a05ee](https://github.com/DaveGamble/cJSON/commit/02a05eea4e6ba41811f130b322660bea8918e1a0)\n\n\nEnhancements:\n-------------\n* Parse into a buffer, this will allow parsing `\\u0000` in the future (not quite yet though)\n* General simplifications and readability improvements\n* More unit tests\n* Update [unity](https://github.com/ThrowTheSwitch/Unity) testing library to 2.4.1\n* Add the [json-patch-tests](https://github.com/json-patch/json-patch-tests) test suite to test cJSON_Utils.\n* Move all tests from `test_utils.c` to unit tests with unity.\n\nFixes:\n------\n* Fix some warnings with the Microsoft compiler, see [#139](https://github.com/DaveGamble/cJSON/pull/139), thanks @PawelWMS\n* Fix several bugs in cJSON_Utils, mostly found with [json-patch-tests](https://github.com/json-patch/json-patch-tests)\n* Prevent a stack overflow by specifying a maximum nesting depth `CJSON_NESTING_LIMIT`\n\nOther Changes:\n--------------\n* Move generated files in the `library_config` subdirectory.\n\n1.4.7 (Apr 19, 2017)\n=====\nFixes:\n------\n* Fix `cJSONUtils_ApplyPatches`, it was completely broken and apparently nobody noticed (or at least reported it), see [075a06f](https://github.com/DaveGamble/cJSON/commit/075a06f40bdc4f836c7dd7cad690d253a57cfc50)\n* Fix inconsistent prototype for `cJSON_GetObjectItemCaseSensitive`, see [51d3df6](https://github.com/DaveGamble/cJSON/commit/51d3df6c9f7b56b860c8fb24abe7bab255cd4fa9), thanks @PawelWMS\n\n1.4.6 (Apr 9, 2017)\n=====\nFixes:\n------\n* Several corrections in the README\n* Making clear that `valueint` should not be written to\n* Fix overflow detection in `ensure`, see [2683d4d](https://github.com/DaveGamble/cJSON/commit/2683d4d9873df87c4bdccc523903ddd78d1ad250)\n* Fix a potential null pointer dereference in cJSON_Utils, see [795c3ac](https://github.com/DaveGamble/cJSON/commit/795c3acabed25c9672006b2c0f40be8845064827)\n* Replace incorrect `sizeof('\\0')` with `sizeof(\"\")`, see [84237ff](https://github.com/DaveGamble/cJSON/commit/84237ff48e69825c94261c624eb0376d0c328139)\n* Add caveats section to the README, see [50b3c30](https://github.com/DaveGamble/cJSON/commit/50b3c30dfa89830f8f477ce33713500740ac3b79)\n* Make cJSON locale independent, see [#146](https://github.com/DaveGamble/cJSON/pull/146), Thanks @peterh for reporting\n* Fix compiling without CMake with MSVC, see [#147](https://github.com/DaveGamble/cJSON/pull/147), Thanks @dertuxmalwieder for reporting\n\n1.4.5 (Mar 28, 2017)\n=====\nFixes:\n------\n* Fix bug in `cJSON_SetNumberHelper`, thanks @mmkeeper, see [#138](https://github.com/DaveGamble/cJSON/issues/138) and [ef34500](https://github.com/DaveGamble/cJSON/commit/ef34500693e8c4a2849d41a4bd66fd19c9ec46c2)\n* Workaround for internal compiler error in GCC 5.4.0 and 6.3.1 on x86 (2f65e80a3471d053fdc3f8aed23d01dd1782a5cb [GCC bugreport](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80097))\n\n1.4.4 (Mar 24, 2017)\n=====\nFixes:\n------\n* Fix a theoretical integer overflow, (not sure if it is possible on actual hardware), see [e58f7ec](https://github.com/DaveGamble/cJSON/commit/e58f7ec027d00b7cdcbf63e518c1b5268b29b3da)\n* Fix an off by one error, see [cc84a44](https://github.com/DaveGamble/cJSON/commit/cc84a446be20cc283bafdc4d94c050ba1111ac02), thanks @gatzka\n* Double check the offset of the print buffer in `ensure`, see [1934059](https://github.com/DaveGamble/cJSON/commit/1934059554b9a0971e00f79e96900f422cfdd114)\n\nImprovements:\n* Add a note in the header about required buffer size when using `cJSON_PrintPreallocated`, see [4bfb8800](https://github.com/DaveGamble/cJSON/commit/4bfb88009342fb568295a7f6dc4b7fee74fbf022)\n\n1.4.3 (Mar 19, 2017)\n=====\nFixes:\n------\n* Fix compilation of the tests on 32 bit PowerPC and potentially other systems, see [4ec6e76](https://github.com/DaveGamble/cJSON/commit/4ec6e76ea2eec16f54b58e8c95b4c734e59481e4)\n* Fix compilation with old GCC compilers (4.3+ were tested), see [227d33](https://github.com/DaveGamble/cJSON/commit/227d3398d6b967879761ebe02c1b63dbd6ea6e0d), [466eb8e](https://github.com/DaveGamble/cJSON/commit/466eb8e3f8a65080f2b3ca4a79ab7b72bd539dba), see also [#126](https://github.com/DaveGamble/cJSON/issues/126)\n\n1.4.2 (Mar 16, 2017)\n=====\nFixes:\n------\n* Fix minimum required cmake version, see [30e1e7a](https://github.com/DaveGamble/cJSON/commit/30e1e7af7c63db9b55f5a3cda977a6c032f0b132)\n* Fix detection of supported compiler flags, see [76e5296](https://github.com/DaveGamble/cJSON/commit/76e5296d0d05ceb3018a9901639e0e171b44a557)\n* Run `cJSON_test` and `cJSON_test_utils` along with unity tests, see [c597601](https://github.com/DaveGamble/cJSON/commit/c597601cf151a757dcf800548f18034d4ddfe2cb)\n\n1.4.1 (Mar 16, 2017)\n=====\nFixes:\n------ \n* Make `print_number` abort with a failure in out of memory situations, see [cf1842](https://github.com/DaveGamble/cJSON/commit/cf1842dc6f64c49451a022308b4415e4d468be0a)\n\n1.4.0 (Mar 4, 2017)\n=====\nFeatures\n--------\n* Functions to check the type of an item, see [#120](https://github.com/DaveGamble/cJSON/pull/120)\n* Use dllexport on windows and fvisibility on Unix systems for public functions, see [#116](https://github.com/DaveGamble/cJSON/pull/116), thanks @mjerris\n* Remove trailing zeroes from printed numbers, see [#123](https://github.com/DaveGamble/cJSON/pull/123)\n* Expose the internal boolean type `cJSON_bool` in the header, see [2d3520e](https://github.com/DaveGamble/cJSON/commit/2d3520e0b9d0eb870e8886e8a21c571eeddbb310)\n\nFixes\n* Fix handling of NULL pointers in `cJSON_ArrayForEach`, see [b47d0e3](https://github.com/DaveGamble/cJSON/commit/b47d0e34caaef298edfb7bd09a72cfff21d231ff)\n* Make it compile with GCC 7 (fix -Wimplicit-fallthrough warning), see [9d07917](https://github.com/DaveGamble/cJSON/commit/9d07917feb1b613544a7513d19233d4c851ad7ad)\n\nOther Improvements\n* internally use realloc if available ([#110](https://github.com/DaveGamble/cJSON/pull/110))\n* builtin support for fuzzing with [afl](http://lcamtuf.coredump.cx/afl/) ([#111](https://github.com/DaveGamble/cJSON/pull/111))\n* unit tests for the print functions ([#112](https://github.com/DaveGamble/cJSON/pull/112))\n* Always use buffered printing ([#113](https://github.com/DaveGamble/cJSON/pull/113))\n* simplify the print functions ([#114](https://github.com/DaveGamble/cJSON/pull/114))\n* Add the compiler flags `-Wdouble-conversion`, `-Wparentheses` and `-Wcomma` ([#122](https://github.com/DaveGamble/cJSON/pull/122))\n\n1.3.2 (Mar 1, 2017)\n=====\nFixes:\n------\n* Don't build the unity library if testing is disabled, see [#121](https://github.com/DaveGamble/cJSON/pull/121). Thanks @ffontaine\n\n1.3.1 (Feb 27, 2017)\n=====\nFixes:\n------\n* Bugfix release that fixes an out of bounds read, see [#118](https://github.com/DaveGamble/cJSON/pull/118). This shouldn't have any security implications.\n\n1.3.0 (Feb 17, 2017)\n=====\nThis release includes a lot of rework in the parser and includes the Cunity unit testing framework, as well as some fixes. I increased the minor version number because there were quite a lot of internal changes.\n\nFeatures:\n* New type for cJSON structs: `cJSON_Invalid`, see [#108](https://github.com/DaveGamble/cJSON/pull/108)\n\nFixes:\n------\n* runtime checks for a lot of potential integer overflows\n* fix incorrect return in cJSON_PrintBuffered [cf9d57d](https://github.com/DaveGamble/cJSON/commit/cf9d57d56cac21fc59465b8d26cf29bf6d2a87b3)\n* fix several potential issues found by [Coverity](https://scan.coverity.com/projects/cjson)\n* fix potentially undefined behavior when assigning big numbers to `valueint` ([41e2837](https://github.com/DaveGamble/cJSON/commit/41e2837df1b1091643aff073f2313f6ff3cc10f4))\n  * Numbers exceeding `INT_MAX` or lower than `INT_MIN` will be explicitly assigned to `valueint` as `INT_MAX` and `INT_MIN` respectively (saturation on overflow).\n  * fix the `cJSON_SetNumberValue` macro ([87f7727](https://github.com/DaveGamble/cJSON/commit/87f77274de6b3af00fb9b9a7f3b900ef382296c2)), this slightly changes the behavior, see commit message\n\nIntroduce unit tests\n--------------------\n\n* Started writing unit tests with the [Cunity](https://github.com/ThrowTheSwitch/Unity) testing framework. Currently this covers the parser functions.\n\nAlso:\n* Support for running the tests with [Valgrind](http://valgrind.org)\n* Support for compiling the tests with [AddressSanitizer](https://github.com/google/sanitizers) and [UndefinedBehaviorSanitizer](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html).\n* `travis.yml` file for running unit tests on travis. (not enabled for the repository yet though [#102](https://github.com/DaveGamble/cJSON/issues/102)\n\nSimplifications\n---------------\n\nAfter having unit tests for the parser function in place, I started refactoring the parser functions (as well as others) and making them easier to read and maintain.\n* Use `strtod` from the standard library for parsing numbers ([0747669](https://github.com/DaveGamble/cJSON/commit/074766997246481dfc72bfa78f07898a2716473f))\n* Use goto-fail in several parser functions ([#100](https://github.com/DaveGamble/cJSON/pull/100))\n* Rewrite/restructure all of the parsing functions to be easier to understand and have less code paths doing the same as another. ([#109](https://github.com/DaveGamble/cJSON/pull/109))\n* Simplify the buffer allocation strategy to always doubling the needed amount ([9f6fa94](https://github.com/DaveGamble/cJSON/commit/9f6fa94c91a87b71e4c6868dbf2ce431a48517b0))\n* Combined `cJSON_AddItemToObject` and `cJSON_AddItemToObjectCS` to one function ([cf862d](https://github.com/DaveGamble/cJSON/commit/cf862d0fed7f9407e4b046d78d3d8050d2080d12))\n\nOther changes\n-------------\n* Prevent the usage of incompatible C and header versions via preprocessor directive ([123bb1](https://github.com/DaveGamble/cJSON/commit/123bb1af7bfae41d805337fef4b41045ef6c7d25))\n* Let CMake automatically detect compiler flags\n* Add new compiler flags (`-Wundef`, `-Wswitch-default`, `-Wconversion`, `-fstack-protector-strong`) ([#98](https://github.com/DaveGamble/cJSON/pull/98))\n* Change internal sizes from `int` to `size_t` ([ecd5678](https://github.com/DaveGamble/cJSON/commit/ecd5678527a6bc422da694e5be9e9979878fe6a0))\n* Change internal strings from `char*` to `unsigned char*` ([28b9ba4](https://github.com/DaveGamble/cJSON/commit/28b9ba4334e0f7309e867e874a31f395c0ac2474))\n* Add `const` in more places\n\n1.2.1 (Jan 31, 2017)\n=====\nFixes:\n------\n* Fixes a potential null pointer dereference in cJSON_Utils, discovered using clang's static analyzer by @bnason-nf, see [#96](https://github.com/DaveGamble/cJSON/issues/96)\n\n1.2.0 (Jan 9, 2017)\n=====\nFeatures:\n---------\n* Add a new type of cJSON item for raw JSON and support printing it. Thanks @loigu, see [#65](https://github.com/DaveGamble/cJSON/pull/65), [#90](https://github.com/DaveGamble/cJSON/pull/90)\n\nFixes:\n------\n* Compiler warning if const is casted away, Thanks @gatzka, see [#83](https://github.com/DaveGamble/cJSON/pull/83)\n* Fix compile error with strict-overflow on PowerPC, see [#85](https://github.com/DaveGamble/cJSON/issues/85)\n* Fix typo in the README, thanks @MicroJoe, see [#88](https://github.com/DaveGamble/cJSON/pull/88)\n* Add compile flag for compatibility with C++ compilers\n\n1.1.0 (Dec 6, 2016)\n=====\n* Add a function `cJSON_PrintPreallocated` to print to a preallocated buffer, thanks @ChisholmKyle, see [#72](https://github.com/DaveGamble/cJSON/pull/72)\n* More compiler warnings when using Clang or GCC, thanks @gatzka, see [#75](https://github.com/DaveGamble/cJSON/pull/75), [#78](https://github.com/DaveGamble/cJSON/pull/78)\n* fixed a memory leak in `cJSON_Duplicate`, thanks @alperakcan, see [#81](https://github.com/DaveGamble/cJSON/pull/81)\n* fix the `ENABLE_CUSTOM_COMPILER_FLAGS` cmake option\n\n1.0.2 (Nov 25, 2016)\n=====\n* Rename internal boolean type, see [#71](https://github.com/DaveGamble/cJSON/issues/71).\n\n1.0.1 (Nov 20, 2016)\n=====\nSmall bugfix release.\n* Fixes a bug with the use of the cJSON structs type in cJSON_Utils, see [d47339e](https://github.com/DaveGamble/cJSON/commit/d47339e2740360e6e0994527d5e4752007480f3a)\n* improve code readability\n* initialize all variables\n\n1.0.0 (Nov 17, 2016)\n=====\nThis is the first official versioned release of cJSON. It provides an API version for the shared library and improved Makefile and CMake build files.\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 9.9658203125,
          "content": "set(CMAKE_LEGACY_CYGWIN_WIN32 0)\ncmake_minimum_required(VERSION 3.0)\n\nproject(cJSON\n    VERSION 1.7.18\n    LANGUAGES C)\n\ncmake_policy(SET CMP0054 NEW)  # set CMP0054 policy\n\ninclude(GNUInstallDirs)\n\nset(CJSON_VERSION_SO 1)\nset(CJSON_UTILS_VERSION_SO 1)\n\nset(custom_compiler_flags)\n\ninclude(CheckCCompilerFlag)\noption(ENABLE_CUSTOM_COMPILER_FLAGS \"Enables custom compiler flags\" ON)\nif (ENABLE_CUSTOM_COMPILER_FLAGS)\n    if ((\"${CMAKE_C_COMPILER_ID}\" STREQUAL \"Clang\") OR (\"${CMAKE_C_COMPILER_ID}\" STREQUAL \"GNU\"))\n        list(APPEND custom_compiler_flags\n            -std=c89\n            -pedantic\n            -Wall\n            -Wextra\n            -Werror\n            -Wstrict-prototypes\n            -Wwrite-strings\n            -Wshadow\n            -Winit-self\n            -Wcast-align\n            -Wformat=2\n            -Wmissing-prototypes\n            -Wstrict-overflow=2\n            -Wcast-qual\n            -Wundef\n            -Wswitch-default\n            -Wconversion\n            -Wc++-compat\n            -fstack-protector-strong\n            -Wcomma\n            -Wdouble-promotion\n            -Wparentheses\n            -Wformat-overflow\n            -Wunused-macros\n            -Wmissing-variable-declarations\n            -Wused-but-marked-unused\n            -Wswitch-enum\n        )\n    elseif(\"${CMAKE_C_COMPILER_ID}\" STREQUAL \"MSVC\")\n        # Disable warning c4001 - nonstandard extension 'single line comment' was used\n        # Define _CRT_SECURE_NO_WARNINGS to disable deprecation warnings for \"insecure\" C library functions\n        list(APPEND custom_compiler_flags\n            /GS\n            /Za\n            /sdl\n            /W4\n            /wd4001\n            /D_CRT_SECURE_NO_WARNINGS\n        )\n    endif()\nendif()\n\noption(ENABLE_SANITIZERS \"Enables AddressSanitizer and UndefinedBehaviorSanitizer.\" OFF)\nif (ENABLE_SANITIZERS)\n    list(APPEND custom_compiler_flags\n        -fno-omit-frame-pointer\n        -fsanitize=address\n        -fsanitize=undefined\n        -fsanitize=float-cast-overflow\n        -fsanitize-address-use-after-scope\n        -fsanitize=integer\n        -fno-sanitize-recover\n        )\nendif()\n\noption(ENABLE_SAFE_STACK \"Enables the SafeStack instrumentation pass by the Code Pointer Integrity Project\" OFF)\nif (ENABLE_SAFE_STACK)\n    if (ENABLE_SANITIZERS)\n        message(FATAL_ERROR \"ENABLE_SAFE_STACK cannot be used in combination with ENABLE_SANITIZERS\")\n    endif()\n    list(APPEND custom_compiler_flags\n        -fsanitize=safe-stack\n        )\nendif()\n\noption(ENABLE_PUBLIC_SYMBOLS \"Export library symbols.\" On)\nif (ENABLE_PUBLIC_SYMBOLS)\n    list(APPEND custom_compiler_flags -fvisibility=hidden)\n    add_definitions(-DCJSON_EXPORT_SYMBOLS -DCJSON_API_VISIBILITY)\nendif()\noption(ENABLE_HIDDEN_SYMBOLS \"Hide library symbols.\" Off)\nif (ENABLE_HIDDEN_SYMBOLS)\n    add_definitions(-DCJSON_HIDE_SYMBOLS -UCJSON_API_VISIBILITY)\nendif()\n\n# apply custom compiler flags\nforeach(compiler_flag ${custom_compiler_flags})\n    #remove problematic characters\n    string(REGEX REPLACE \"[^a-zA-Z0-9]\" \"\" current_variable ${compiler_flag})\n\n    CHECK_C_COMPILER_FLAG(${compiler_flag} \"FLAG_SUPPORTED_${current_variable}\")\n    if (FLAG_SUPPORTED_${current_variable})\n        set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${compiler_flag}\")\n    endif()\nendforeach()\n\noption(BUILD_SHARED_LIBS \"Build shared libraries\" ON)\noption(ENABLE_TARGET_EXPORT \"Enable exporting of CMake targets. Disable when it causes problems!\" ON)\n\n#cJSON\nset(CJSON_LIB cjson)\n\nfile(GLOB HEADERS cJSON.h)\nset(SOURCES cJSON.c)\n\noption(BUILD_SHARED_AND_STATIC_LIBS \"Build both shared and static libraries\" Off)\noption(CJSON_OVERRIDE_BUILD_SHARED_LIBS \"Override BUILD_SHARED_LIBS with CJSON_BUILD_SHARED_LIBS\" OFF)\noption(CJSON_BUILD_SHARED_LIBS \"Overrides BUILD_SHARED_LIBS if CJSON_OVERRIDE_BUILD_SHARED_LIBS is enabled\" ON)\noption(ENABLE_CJSON_VERSION_SO \"Enables cJSON so version\" ON)\n\nif ((CJSON_OVERRIDE_BUILD_SHARED_LIBS AND CJSON_BUILD_SHARED_LIBS) OR ((NOT CJSON_OVERRIDE_BUILD_SHARED_LIBS) AND BUILD_SHARED_LIBS))\n    set(CJSON_LIBRARY_TYPE SHARED)\nelse()\n    set(CJSON_LIBRARY_TYPE STATIC)\nendif()\n\n\nif (NOT BUILD_SHARED_AND_STATIC_LIBS)\n    add_library(\"${CJSON_LIB}\" \"${CJSON_LIBRARY_TYPE}\" \"${HEADERS}\" \"${SOURCES}\")\nelse()\n    # See https://cmake.org/Wiki/CMake_FAQ#How_do_I_make_my_shared_and_static_libraries_have_the_same_root_name.2C_but_different_suffixes.3F\n    add_library(\"${CJSON_LIB}\" SHARED \"${HEADERS}\" \"${SOURCES}\")\n    add_library(\"${CJSON_LIB}-static\" STATIC \"${HEADERS}\" \"${SOURCES}\")\n    set_target_properties(\"${CJSON_LIB}-static\" PROPERTIES OUTPUT_NAME \"${CJSON_LIB}\")\n    set_target_properties(\"${CJSON_LIB}-static\" PROPERTIES PREFIX \"lib\")\nendif()\nif (NOT WIN32)\n    target_link_libraries(\"${CJSON_LIB}\" m)\nendif()\n\nconfigure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/library_config/libcjson.pc.in\"\n    \"${CMAKE_CURRENT_BINARY_DIR}/libcjson.pc\" @ONLY)\n\ninstall(FILES cJSON.h DESTINATION \"${CMAKE_INSTALL_FULL_INCLUDEDIR}/cjson\")\ninstall (FILES \"${CMAKE_CURRENT_BINARY_DIR}/libcjson.pc\" DESTINATION \"${CMAKE_INSTALL_FULL_LIBDIR}/pkgconfig\")\ninstall(TARGETS \"${CJSON_LIB}\"\n    EXPORT \"${CJSON_LIB}\"\n    ARCHIVE DESTINATION \"${CMAKE_INSTALL_FULL_LIBDIR}\"\n    LIBRARY DESTINATION \"${CMAKE_INSTALL_FULL_LIBDIR}\"\n    RUNTIME DESTINATION \"${CMAKE_INSTALL_FULL_BINDIR}\"\n    INCLUDES DESTINATION \"${CMAKE_INSTALL_FULL_INCLUDEDIR}\"\n)\nif (BUILD_SHARED_AND_STATIC_LIBS)\n    install(TARGETS \"${CJSON_LIB}-static\"\n    EXPORT \"${CJSON_LIB}\" \n    ARCHIVE DESTINATION \"${CMAKE_INSTALL_FULL_LIBDIR}\"\n    INCLUDES DESTINATION \"${CMAKE_INSTALL_FULL_INCLUDEDIR}\"\n)\nendif()\nif(ENABLE_TARGET_EXPORT)\n    # export library information for CMake projects\n    install(EXPORT \"${CJSON_LIB}\" DESTINATION \"${CMAKE_INSTALL_FULL_LIBDIR}/cmake/cJSON\")\nendif()\n\nif(ENABLE_CJSON_VERSION_SO)\n    set_target_properties(\"${CJSON_LIB}\"\n        PROPERTIES\n            SOVERSION \"${CJSON_VERSION_SO}\"\n            VERSION \"${PROJECT_VERSION}\")\nendif()\n\n#cJSON_Utils\noption(ENABLE_CJSON_UTILS \"Enable building the cJSON_Utils library.\" OFF)\nif(ENABLE_CJSON_UTILS)\n    set(CJSON_UTILS_LIB cjson_utils)\n\n    file(GLOB HEADERS_UTILS cJSON_Utils.h)\n    set(SOURCES_UTILS cJSON_Utils.c)\n\n    if (NOT BUILD_SHARED_AND_STATIC_LIBS)\n        add_library(\"${CJSON_UTILS_LIB}\" \"${CJSON_LIBRARY_TYPE}\" \"${HEADERS_UTILS}\" \"${SOURCES_UTILS}\")\n        target_link_libraries(\"${CJSON_UTILS_LIB}\" \"${CJSON_LIB}\")\n    else()\n        add_library(\"${CJSON_UTILS_LIB}\" SHARED \"${HEADERS_UTILS}\" \"${SOURCES_UTILS}\")\n        target_link_libraries(\"${CJSON_UTILS_LIB}\" \"${CJSON_LIB}\")\n        add_library(\"${CJSON_UTILS_LIB}-static\" STATIC \"${HEADERS_UTILS}\" \"${SOURCES_UTILS}\")\n        target_link_libraries(\"${CJSON_UTILS_LIB}-static\" \"${CJSON_LIB}-static\")\n        set_target_properties(\"${CJSON_UTILS_LIB}-static\" PROPERTIES OUTPUT_NAME \"${CJSON_UTILS_LIB}\")\n        set_target_properties(\"${CJSON_UTILS_LIB}-static\" PROPERTIES PREFIX \"lib\")\n    endif()\n\n    configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/library_config/libcjson_utils.pc.in\"\n        \"${CMAKE_CURRENT_BINARY_DIR}/libcjson_utils.pc\" @ONLY)\n\n    install(TARGETS \"${CJSON_UTILS_LIB}\"\n        EXPORT \"${CJSON_UTILS_LIB}\"\n        ARCHIVE DESTINATION \"${CMAKE_INSTALL_FULL_LIBDIR}\"\n        LIBRARY DESTINATION \"${CMAKE_INSTALL_FULL_LIBDIR}\"\n        RUNTIME DESTINATION \"${CMAKE_INSTALL_FULL_BINDIR}\"\n        INCLUDES DESTINATION \"${CMAKE_INSTALL_FULL_INCLUDEDIR}\"\n    )\n    if (BUILD_SHARED_AND_STATIC_LIBS)\n        install(TARGETS \"${CJSON_UTILS_LIB}-static\" \n        EXPORT \"${CJSON_UTILS_LIB}\" \n        ARCHIVE DESTINATION \"${CMAKE_INSTALL_FULL_LIBDIR}\"\n        INCLUDES DESTINATION \"${CMAKE_INSTALL_FULL_INCLUDEDIR}\"\n        )\n    endif()\n    install(FILES cJSON_Utils.h DESTINATION \"${CMAKE_INSTALL_FULL_INCLUDEDIR}/cjson\")\n    install (FILES \"${CMAKE_CURRENT_BINARY_DIR}/libcjson_utils.pc\" DESTINATION \"${CMAKE_INSTALL_FULL_LIBDIR}/pkgconfig\")\n    if(ENABLE_TARGET_EXPORT)\n      # export library information for CMake projects\n      install(EXPORT \"${CJSON_UTILS_LIB}\" DESTINATION \"${CMAKE_INSTALL_FULL_LIBDIR}/cmake/cJSON\")\n    endif()\n\n    if(ENABLE_CJSON_VERSION_SO)\n        set_target_properties(\"${CJSON_UTILS_LIB}\"\n            PROPERTIES\n                SOVERSION \"${CJSON_UTILS_VERSION_SO}\"\n                VERSION \"${PROJECT_VERSION}\")\n    endif()\nendif()\n\n# create the other package config files\nconfigure_file(\n    \"${CMAKE_CURRENT_SOURCE_DIR}/library_config/cJSONConfig.cmake.in\"\n    ${PROJECT_BINARY_DIR}/cJSONConfig.cmake @ONLY)\nconfigure_file(\n    \"${CMAKE_CURRENT_SOURCE_DIR}/library_config/cJSONConfigVersion.cmake.in\"\n    ${PROJECT_BINARY_DIR}/cJSONConfigVersion.cmake @ONLY)\n\nif(ENABLE_TARGET_EXPORT)\n    # Install package config files\n    install(FILES ${PROJECT_BINARY_DIR}/cJSONConfig.cmake\n        ${PROJECT_BINARY_DIR}/cJSONConfigVersion.cmake\n        DESTINATION \"${CMAKE_INSTALL_FULL_LIBDIR}/cmake/cJSON\")\nendif()\n\noption(ENABLE_CJSON_TEST \"Enable building cJSON test\" ON)\nif(ENABLE_CJSON_TEST)\n    enable_testing()\n\n    set(TEST_CJSON cJSON_test)\n    add_executable(\"${TEST_CJSON}\" test.c)\n    target_link_libraries(\"${TEST_CJSON}\" \"${CJSON_LIB}\")\n\n    add_test(NAME ${TEST_CJSON} COMMAND \"${CMAKE_CURRENT_BINARY_DIR}/${TEST_CJSON}\")\n\n    # Disable -fsanitize=float-divide-by-zero for cJSON_test\n    if (FLAG_SUPPORTED_fsanitizefloatdividebyzero)\n        if (\"${CMAKE_VERSION}\" VERSION_LESS \"2.8.12\")\n            set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -fno-sanitize=float-divide-by-zero\")\n        else()\n            target_compile_options(${TEST_CJSON} PRIVATE \"-fno-sanitize=float-divide-by-zero\")\n        endif()\n    endif()\n\n    #\"check\" target that automatically builds everything and runs the tests\n    add_custom_target(check\n        COMMAND ${CMAKE_CTEST_COMMAND} --output-on-failure\n        DEPENDS ${TEST_CJSON})\nendif()\n\n#Create the uninstall target\noption(ENABLE_CJSON_UNINSTALL \"Enable creating uninstall target\" ON)\nif(ENABLE_CJSON_UNINSTALL)\n  add_custom_target(uninstall \"${CMAKE_COMMAND}\" -P\n    \"${PROJECT_SOURCE_DIR}/library_config/uninstall.cmake\")\nendif()\n\n# Enable the use of locales\noption(ENABLE_LOCALES \"Enable the use of locales\" ON)\nif(ENABLE_LOCALES)\n\tadd_definitions(-DENABLE_LOCALES)\nendif()\n\nadd_subdirectory(tests)\nadd_subdirectory(fuzzing)\n"
        },
        {
          "name": "CONTRIBUTORS.md",
          "type": "blob",
          "size": 3.9208984375,
          "content": "Contributors\n============\n\nOriginal Author: \n- [Dave Gamble](https://github.com/DaveGamble)  \n\nCurrent Maintainer: \n- [Max Bruckner](https://github.com/FSMaxB) \n- [Alan Wang](https://github.com/Alanscut)\n\nContributors:  \n* [Ajay Bhargav](https://github.com/ajaybhargav)\n* [AlexanderVasiljev](https://github.com/AlexanderVasiljev)\n* [Alper Akcan](https://github.com/alperakcan)\n* [Andrew Tang](https://github.com/singku)\n* [Andy](https://github.com/mlh0101)\n* [Anton Sergeev](https://github.com/anton-sergeev)\n* [Benbuck Nason](https://github.com/bnason-nf)\n* [Bernt Johan Damslora](https://github.com/bjda)\n* [Bob Kocisko](https://github.com/bobkocisko)\n* [Christian Schulze](https://github.com/ChristianSch)\n* [Casperinous](https://github.com/Casperinous)\n* [ChenYuan](https://github.com/zjuchenyuan)\n* [Debora Grosse](https://github.com/DeboraG)\n* [dieyushi](https://github.com/dieyushi)\n* [Dōngwén Huáng (黄东文)](https://github.com/DongwenHuang)\n* [Donough Liu](https://github.com/ldm0)\n* [Erez Oxman](https://github.com/erez-o)\n* Eswar Yaganti\n* [Evan Todd](https://github.com/etodd)\n* [Fabrice Fontaine](https://github.com/ffontaine)\n* Ian Mobley\n* Irwan Djadjadi\n* [hopper-vul](https://github.com/hopper-vul)\n* [HuKeping](https://github.com/HuKeping)\n* [IvanVoid](https://github.com/npi3pak)\n* [Jakub Wilk](https://github.com/jwilk)\n* [Jiri Zouhar](https://github.com/loigu)\n* [Jonathan Fether](https://github.com/jfether)\n* [Joshua Arulsamy](https://github.com/jarulsamy)\n* [Julian Ste](https://github.com/julian-st)\n* [Julián Vásquez](https://github.com/juvasquezg)\n* [Junbo Zheng](https://github.com/Junbo-Zheng)\n* [Kevin Branigan](https://github.com/kbranigan)\n* [Kevin Sapper](https://github.com/sappo)\n* [Kyle Chisholm](https://github.com/ChisholmKyle)\n* [Linus Wallgren](https://github.com/ecksun)\n* [Luo Jin](https://github.com/Up-wind)\n* [Max](https://github.com/maebex)\n* [MaxBrandtner](https://github.com/MaxBrandtner)\n* [Mateusz Szafoni](https://github.com/raiden00pl)\n* Mike Pontillo\n* [miaoerduo](https://github.com/miaoerduo)\n* [mohawk2](https://github.com/mohawk2)\n* [Mike Jerris](https://github.com/mjerris)\n* [Mike Robinson](https://github.com/mhrobinson)\n* [Moorthy](https://github.com/moorthy-bs)\n* [myd7349](https://github.com/myd7349)\n* [NancyLi1013](https://github.com/NancyLi1013)\n* [Orri](https://github.com/sbvoxel)\n* Paulo Antonio Alvarez\n* [Paweł Malowany](https://github.com/PawelMalowany)\n* [Pawel Winogrodzki](https://github.com/PawelWMS)\n* [prefetchnta](https://github.com/prefetchnta)\n* [Rafael Leal Dias](https://github.com/rafaeldias)\n* [Randy](https://github.com/randy408)\n* [raiden00pl](https://github.com/raiden00pl)\n* [Robin Mallinson](https://github.com/rmallins)\n* [Rod Vagg](https://github.com/rvagg)\n* [Roland Meertens](https://github.com/rmeertens)\n* [Romain Porte](https://github.com/MicroJoe)\n* [SANJEEV BA](https://github.com/basanjeev)\n* [Sang-Heon Jeon](https://github.com/lntuition)\n* [Sayan Bandyopadhyay](https://github.com/saynb)\n* [Simon Sobisch](https://github.com/GitMensch)\n* [Simon Ricaldone](https://github.com/simon-p-r)\n* [Stoian Ivanov](https://github.com/sdrsdr)\n* [SuperH-0630](https://github.com/SuperH-0630)\n* [Square789](https://github.com/Square789)\n* [Stephan Gatzka](https://github.com/gatzka)\n* [Tony Langhammer](https://github.com/BigBrainAFK)\n* [Vemake](https://github.com/vemakereporter)\n* [Wei Tan](https://github.com/tan-wei)\n* [Weston Schmidt](https://github.com/schmidtw)\n* [xiaomianhehe](https://github.com/xiaomianhehe)\n* [yangfl](https://github.com/yangfl)\n* [yuta-oxo](https://github.com/yuta-oxo)\n* [Zach Hindes](https://github.com/zhindes)\n* [Zhao Zhixu](https://github.com/zhaozhixu)\n* [10km](https://github.com/10km)\n\nAnd probably more people on [SourceForge](https://sourceforge.net/p/cjson/bugs/search/?q=status%3Aclosed-rejected+or+status%3Aclosed-out-of-date+or+status%3Awont-fix+or+status%3Aclosed-fixed+or+status%3Aclosed&page=0)\n\nAlso thanks to all the people who reported bugs and suggested new features.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05859375,
          "content": "Copyright (c) 2009-2017 Dave Gamble and cJSON contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 4.541015625,
          "content": "CJSON_OBJ = cJSON.o\nUTILS_OBJ = cJSON_Utils.o\nCJSON_LIBNAME = libcjson\nUTILS_LIBNAME = libcjson_utils\nCJSON_TEST = cJSON_test\n\nCJSON_TEST_SRC = cJSON.c test.c\n\nLDLIBS = -lm\n\nLIBVERSION = 1.7.18\nCJSON_SOVERSION = 1\nUTILS_SOVERSION = 1\n\nCJSON_SO_LDFLAG=-Wl,-soname=$(CJSON_LIBNAME).so.$(CJSON_SOVERSION)\nUTILS_SO_LDFLAG=-Wl,-soname=$(UTILS_LIBNAME).so.$(UTILS_SOVERSION)\n\nPREFIX ?= /usr/local\nINCLUDE_PATH ?= include/cjson\nLIBRARY_PATH ?= lib\n\nINSTALL_INCLUDE_PATH = $(DESTDIR)$(PREFIX)/$(INCLUDE_PATH)\nINSTALL_LIBRARY_PATH = $(DESTDIR)$(PREFIX)/$(LIBRARY_PATH)\n\nINSTALL ?= cp -a\n\nCC = gcc -std=c89\n\n# validate gcc version for use fstack-protector-strong\nMIN_GCC_VERSION = \"4.9\"\nGCC_VERSION := \"`$(CC) -dumpversion`\"\nIS_GCC_ABOVE_MIN_VERSION := $(shell expr \"$(GCC_VERSION)\" \">=\" \"$(MIN_GCC_VERSION)\")\nifeq \"$(IS_GCC_ABOVE_MIN_VERSION)\" \"1\"\n    CFLAGS += -fstack-protector-strong\nelse\n    CFLAGS += -fstack-protector\nendif\n\nPIC_FLAGS = -fPIC\nR_CFLAGS = $(PIC_FLAGS) -pedantic -Wall -Werror -Wstrict-prototypes -Wwrite-strings -Wshadow -Winit-self -Wcast-align -Wformat=2 -Wmissing-prototypes -Wstrict-overflow=2 -Wcast-qual -Wc++-compat -Wundef -Wswitch-default -Wconversion $(CFLAGS)\n\nuname := $(shell sh -c 'uname -s 2>/dev/null || echo false')\n\n#library file extensions\nSHARED = so\nSTATIC = a\n\n## create dynamic (shared) library on Darwin (base OS for MacOSX and IOS)\nifeq (Darwin, $(uname))\n\tSHARED = dylib\n\tCJSON_SO_LDFLAG = \"\"\n\tUTILS_SO_LDFLAG = \"\"\nendif\n\n#cJSON library names\nCJSON_SHARED = $(CJSON_LIBNAME).$(SHARED)\nCJSON_SHARED_VERSION = $(CJSON_LIBNAME).$(SHARED).$(LIBVERSION)\nCJSON_SHARED_SO = $(CJSON_LIBNAME).$(SHARED).$(CJSON_SOVERSION)\nCJSON_STATIC = $(CJSON_LIBNAME).$(STATIC)\n\n#cJSON_Utils library names\nUTILS_SHARED = $(UTILS_LIBNAME).$(SHARED)\nUTILS_SHARED_VERSION = $(UTILS_LIBNAME).$(SHARED).$(LIBVERSION)\nUTILS_SHARED_SO = $(UTILS_LIBNAME).$(SHARED).$(UTILS_SOVERSION)\nUTILS_STATIC = $(UTILS_LIBNAME).$(STATIC)\n\nSHARED_CMD = $(CC) -shared -o\n\n.PHONY: all shared static tests clean install\n\nall: shared static tests\n\nshared: $(CJSON_SHARED) $(UTILS_SHARED)\n\nstatic: $(CJSON_STATIC) $(UTILS_STATIC)\n\ntests: $(CJSON_TEST)\n\ntest: tests\n\t./$(CJSON_TEST)\n\n.c.o:\n\t$(CC) -c $(R_CFLAGS) $<\n\n#tests\n#cJSON\n$(CJSON_TEST): $(CJSON_TEST_SRC) cJSON.h\n\t$(CC) $(R_CFLAGS) $(CJSON_TEST_SRC)  -o $@ $(LDLIBS) -I.\n\n#static libraries\n#cJSON\n$(CJSON_STATIC): $(CJSON_OBJ)\n\t$(AR) rcs $@ $<\n#cJSON_Utils\n$(UTILS_STATIC): $(UTILS_OBJ)\n\t$(AR) rcs $@ $<\n\n#shared libraries .so.1.0.0\n#cJSON\n$(CJSON_SHARED_VERSION): $(CJSON_OBJ)\n\t$(CC) -shared -o $@ $< $(CJSON_SO_LDFLAG) $(LDFLAGS)\n#cJSON_Utils\n$(UTILS_SHARED_VERSION): $(UTILS_OBJ)\n\t$(CC) -shared -o $@ $< $(CJSON_OBJ) $(UTILS_SO_LDFLAG) $(LDFLAGS)\n\n#objects\n#cJSON\n$(CJSON_OBJ): cJSON.c cJSON.h\n#cJSON_Utils\n$(UTILS_OBJ): cJSON_Utils.c cJSON_Utils.h cJSON.h\n\n\n#links .so -> .so.1 -> .so.1.0.0\n#cJSON\n$(CJSON_SHARED_SO): $(CJSON_SHARED_VERSION)\n\tln -s $(CJSON_SHARED_VERSION) $(CJSON_SHARED_SO)\n$(CJSON_SHARED): $(CJSON_SHARED_SO)\n\tln -s $(CJSON_SHARED_SO) $(CJSON_SHARED)\n#cJSON_Utils\n$(UTILS_SHARED_SO): $(UTILS_SHARED_VERSION)\n\tln -s $(UTILS_SHARED_VERSION) $(UTILS_SHARED_SO)\n$(UTILS_SHARED): $(UTILS_SHARED_SO)\n\tln -s $(UTILS_SHARED_SO) $(UTILS_SHARED)\n\n#install\n#cJSON\ninstall-cjson:\n\tmkdir -p $(INSTALL_LIBRARY_PATH) $(INSTALL_INCLUDE_PATH)\n\t$(INSTALL) cJSON.h $(INSTALL_INCLUDE_PATH)\n\t$(INSTALL) $(CJSON_SHARED) $(CJSON_SHARED_SO) $(CJSON_SHARED_VERSION) $(INSTALL_LIBRARY_PATH)\n#cJSON_Utils\ninstall-utils: install-cjson\n\t$(INSTALL) cJSON_Utils.h $(INSTALL_INCLUDE_PATH)\n\t$(INSTALL) $(UTILS_SHARED) $(UTILS_SHARED_SO) $(UTILS_SHARED_VERSION) $(INSTALL_LIBRARY_PATH)\n\ninstall: install-cjson install-utils\n\n#uninstall\n#cJSON\nuninstall-cjson: uninstall-utils\n\t$(RM) $(INSTALL_LIBRARY_PATH)/$(CJSON_SHARED)\n\t$(RM) $(INSTALL_LIBRARY_PATH)/$(CJSON_SHARED_VERSION)\n\t$(RM) $(INSTALL_LIBRARY_PATH)/$(CJSON_SHARED_SO)\n\t$(RM) $(INSTALL_INCLUDE_PATH)/cJSON.h\n\t\n#cJSON_Utils\nuninstall-utils:\n\t$(RM) $(INSTALL_LIBRARY_PATH)/$(UTILS_SHARED)\n\t$(RM) $(INSTALL_LIBRARY_PATH)/$(UTILS_SHARED_VERSION)\n\t$(RM) $(INSTALL_LIBRARY_PATH)/$(UTILS_SHARED_SO)\n\t$(RM) $(INSTALL_INCLUDE_PATH)/cJSON_Utils.h\n\nremove-dir:\n\t$(if $(wildcard $(INSTALL_LIBRARY_PATH)/*.*),,rmdir $(INSTALL_LIBRARY_PATH))\n\t$(if $(wildcard $(INSTALL_INCLUDE_PATH)/*.*),,rmdir $(INSTALL_INCLUDE_PATH))\n\nuninstall: uninstall-utils uninstall-cjson remove-dir\n\nclean:\n\t$(RM) $(CJSON_OBJ) $(UTILS_OBJ) #delete object files\n\t$(RM) $(CJSON_SHARED) $(CJSON_SHARED_VERSION) $(CJSON_SHARED_SO) $(CJSON_STATIC) #delete cJSON\n\t$(RM) $(UTILS_SHARED) $(UTILS_SHARED_VERSION) $(UTILS_SHARED_SO) $(UTILS_STATIC) #delete cJSON_Utils\n\t$(RM) $(CJSON_TEST)  #delete test\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 26.984375,
          "content": "# cJSON\n\nUltralightweight JSON parser in ANSI C.\n\n## Table of contents\n* [License](#license)\n* [Usage](#usage)\n  * [Welcome to cJSON](#welcome-to-cjson)\n  * [Building](#building)\n    * [Copying the source](#copying-the-source)\n    * [CMake](#cmake)\n    * [Makefile](#makefile)\n    * [Meson](#meson)\n    * [Vcpkg](#Vcpkg)\n  * [Including cJSON](#including-cjson)\n  * [Data Structure](#data-structure)\n  * [Working with the data structure](#working-with-the-data-structure)\n    * [Basic types](#basic-types)\n    * [Arrays](#arrays)\n    * [Objects](#objects)\n  * [Parsing JSON](#parsing-json)\n  * [Printing JSON](#printing-json)\n  * [Example](#example)\n    * [Printing](#printing)\n    * [Parsing](#parsing)\n  * [Caveats](#caveats)\n    * [Zero Character](#zero-character)\n    * [Character Encoding](#character-encoding)\n    * [C Standard](#c-standard)\n    * [Floating Point Numbers](#floating-point-numbers)\n    * [Deep Nesting Of Arrays And Objects](#deep-nesting-of-arrays-and-objects)\n    * [Thread Safety](#thread-safety)\n    * [Case Sensitivity](#case-sensitivity)\n    * [Duplicate Object Members](#duplicate-object-members)\n  * [Enjoy cJSON!](#enjoy-cjson)\n\n## License\n\nMIT License\n\n>  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors\n>\n>  Permission is hereby granted, free of charge, to any person obtaining a copy\n>  of this software and associated documentation files (the \"Software\"), to deal\n>  in the Software without restriction, including without limitation the rights\n>  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n>  copies of the Software, and to permit persons to whom the Software is\n>  furnished to do so, subject to the following conditions:\n>\n>  The above copyright notice and this permission notice shall be included in\n>  all copies or substantial portions of the Software.\n>\n>  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n>  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n>  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n>  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n>  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n>  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n>  THE SOFTWARE.\n\n## Usage\n\n### Welcome to cJSON.\n\ncJSON aims to be the dumbest possible parser that you can get your job done with.\nIt's a single file of C, and a single header file.\n\nJSON is described best here: http://www.json.org/\nIt's like XML, but fat-free. You use it to move data around, store things, or just\ngenerally represent your program's state.\n\nAs a library, cJSON exists to take away as much legwork as it can, but not get in your way.\nAs a point of pragmatism (i.e. ignoring the truth), I'm going to say that you can use it\nin one of two modes: Auto and Manual. Let's have a quick run-through.\n\nI lifted some JSON from this page: http://www.json.org/fatfree.html\nThat page inspired me to write cJSON, which is a parser that tries to share the same\nphilosophy as JSON itself. Simple, dumb, out of the way.\n\n### Building\n\nThere are several ways to incorporate cJSON into your project.\n\n#### copying the source\n\nBecause the entire library is only one C file and one header file, you can just copy `cJSON.h` and `cJSON.c` to your projects source and start using it.\n\ncJSON is written in ANSI C (C89) in order to support as many platforms and compilers as possible.\n\n#### CMake\n\nWith CMake, cJSON supports a full blown build system. This way you get the most features. CMake with an equal or higher version than 2.8.5 is supported. With CMake it is recommended to do an out of tree build, meaning the compiled files are put in a directory separate from the source files. So in order to build cJSON with CMake on a Unix platform, make a `build` directory and run CMake inside it.\n\n```\nmkdir build\ncd build\ncmake ..\n```\n\nThis will create a Makefile and a bunch of other files. You can then compile it:\n\n```\nmake\n```\n\nAnd install it with `make install` if you want. By default it installs the headers `/usr/local/include/cjson` and the libraries to `/usr/local/lib`. It also installs files for pkg-config to make it easier to detect and use an existing installation of CMake. And it installs CMake config files, that can be used by other CMake based projects to discover the library.\n\nYou can change the build process with a list of different options that you can pass to CMake. Turn them on with `On` and off with `Off`:\n\n* `-DENABLE_CJSON_TEST=On`: Enable building the tests. (on by default)\n* `-DENABLE_CJSON_UTILS=On`: Enable building cJSON_Utils. (off by default)\n* `-DENABLE_TARGET_EXPORT=On`: Enable the export of CMake targets. Turn off if it makes problems. (on by default)\n* `-DENABLE_CUSTOM_COMPILER_FLAGS=On`: Enable custom compiler flags (currently for Clang, GCC and MSVC). Turn off if it makes problems. (on by default)\n* `-DENABLE_VALGRIND=On`: Run tests with [valgrind](http://valgrind.org). (off by default)\n* `-DENABLE_SANITIZERS=On`: Compile cJSON with [AddressSanitizer](https://github.com/google/sanitizers/wiki/AddressSanitizer) and [UndefinedBehaviorSanitizer](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html) enabled (if possible). (off by default)\n* `-DENABLE_SAFE_STACK`: Enable the [SafeStack](https://clang.llvm.org/docs/SafeStack.html) instrumentation pass. Currently only works with the Clang compiler. (off by default)\n* `-DBUILD_SHARED_LIBS=On`: Build the shared libraries. (on by default)\n* `-DBUILD_SHARED_AND_STATIC_LIBS=On`: Build both shared and static libraries. (off by default)\n* `-DCMAKE_INSTALL_PREFIX=/usr`: Set a prefix for the installation.\n* `-DENABLE_LOCALES=On`: Enable the usage of localeconv method. ( on by default )\n* `-DCJSON_OVERRIDE_BUILD_SHARED_LIBS=On`: Enable overriding the value of `BUILD_SHARED_LIBS` with `-DCJSON_BUILD_SHARED_LIBS`.\n* `-DENABLE_CJSON_VERSION_SO`: Enable cJSON so version. ( on by default )\n\nIf you are packaging cJSON for a distribution of Linux, you would probably take these steps for example:\n```\nmkdir build\ncd build\ncmake .. -DENABLE_CJSON_UTILS=On -DENABLE_CJSON_TEST=Off -DCMAKE_INSTALL_PREFIX=/usr\nmake\nmake DESTDIR=$pkgdir install\n```\n\nOn Windows CMake is usually used to create a Visual Studio solution file by running it inside the Developer Command Prompt for Visual Studio, for exact steps follow the official documentation from CMake and Microsoft and use the online search engine of your choice. The descriptions of the the options above still generally apply, although not all of them work on Windows.\n\n#### Makefile\n\n**NOTE:** This Method is deprecated. Use CMake if at all possible. Makefile support is limited to fixing bugs.\n\nIf you don't have CMake available, but still have GNU make. You can use the makefile to build cJSON:\n\nRun this command in the directory with the source code and it will automatically compile static and shared libraries and a little test program (not the full test suite).\n\n```\nmake all\n```\n\nIf you want, you can install the compiled library to your system using `make install`. By default it will install the headers in `/usr/local/include/cjson` and the libraries in `/usr/local/lib`. But you can change this behavior by setting the `PREFIX` and `DESTDIR` variables: `make PREFIX=/usr DESTDIR=temp install`. And uninstall them with: `make PREFIX=/usr DESTDIR=temp uninstall`.\n\n#### Meson\n\nTo make cjson work in a project using meson, the libcjson dependency has to be included:\n\n```meson\nproject('c-json-example', 'c')\n\ncjson = dependency('libcjson')\n\nexample = executable(\n    'example',\n    'example.c',\n    dependencies: [cjson],\n)\n```\n\n\n#### Vcpkg\n\nYou can download and install cJSON using the [vcpkg](https://github.com/Microsoft/vcpkg) dependency manager:\n```\ngit clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh\n./vcpkg integrate install\nvcpkg install cjson\n```\n\nThe cJSON port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please [create an issue or pull request](https://github.com/Microsoft/vcpkg) on the vcpkg repository.\n\n### Including cJSON\n\nIf you installed it via CMake or the Makefile, you can include cJSON like this:\n\n```c\n#include <cjson/cJSON.h>\n```\n\n### Data Structure\n\ncJSON represents JSON data using the `cJSON` struct data type:\n\n```c\n/* The cJSON structure: */\ntypedef struct cJSON\n{\n    struct cJSON *next;\n    struct cJSON *prev;\n    struct cJSON *child;\n    int type;\n    char *valuestring;\n    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */\n    int valueint;\n    double valuedouble;\n    char *string;\n} cJSON;\n```\n\nAn item of this type represents a JSON value. The type is stored in `type` as a bit-flag (**this means that you cannot find out the type by just comparing the value of `type`**).\n\nTo check the type of an item, use the corresponding `cJSON_Is...` function. It does a `NULL` check followed by a type check and returns a boolean value if the item is of this type.\n\nThe type can be one of the following:\n\n* `cJSON_Invalid` (check with `cJSON_IsInvalid`): Represents an invalid item that doesn't contain any value. You automatically have this type if you set the item to all zero bytes.\n* `cJSON_False` (check with `cJSON_IsFalse`): Represents a `false` boolean value. You can also check for boolean values in general with `cJSON_IsBool`.\n* `cJSON_True` (check with `cJSON_IsTrue`): Represents a `true` boolean value. You can also check for boolean values in general with `cJSON_IsBool`.\n* `cJSON_NULL` (check with `cJSON_IsNull`): Represents a `null` value.\n* `cJSON_Number` (check with `cJSON_IsNumber`): Represents a number value. The value is stored as a double in `valuedouble` and also in `valueint`. If the number is outside of the range of an integer, `INT_MAX` or `INT_MIN` are used for `valueint`.\n* `cJSON_String` (check with `cJSON_IsString`): Represents a string value. It is stored in the form of a zero terminated string in `valuestring`.\n* `cJSON_Array` (check with `cJSON_IsArray`): Represent an array value. This is implemented by pointing `child` to a linked list of `cJSON` items that represent the values in the array. The elements are linked together using `next` and `prev`, where the first element has `prev.next == NULL` and the last element `next == NULL`.\n* `cJSON_Object` (check with `cJSON_IsObject`): Represents an object value. Objects are stored same way as an array, the only difference is that the items in the object store their keys in `string`.\n* `cJSON_Raw` (check with `cJSON_IsRaw`): Represents any kind of JSON that is stored as a zero terminated array of characters in `valuestring`. This can be used, for example, to avoid printing the same static JSON over and over again to save performance. cJSON will never create this type when parsing. Also note that cJSON doesn't check if it is valid JSON.\n\nAdditionally there are the following two flags:\n\n* `cJSON_IsReference`: Specifies that the item that `child` points to and/or `valuestring` is not owned by this item, it is only a reference. So `cJSON_Delete` and other functions will only deallocate this item, not its `child`/`valuestring`.\n* `cJSON_StringIsConst`: This means that `string` points to a constant string. This means that `cJSON_Delete` and other functions will not try to deallocate `string`.\n\n### Working with the data structure\n\nFor every value type there is a `cJSON_Create...` function that can be used to create an item of that type.\nAll of these will allocate a `cJSON` struct that can later be deleted with `cJSON_Delete`.\nNote that you have to delete them at some point, otherwise you will get a memory leak.  \n**Important**: If you have added an item to an array or an object already, you **mustn't** delete it with `cJSON_Delete`. Adding it to an array or object transfers its ownership so that when that array or object is deleted, \nit gets deleted as well. You also could use `cJSON_SetValuestring` to change a `cJSON_String`'s `valuestring`, and you needn't to free the previous `valuestring` manually.\n\n#### Basic types\n\n* **null** is created with `cJSON_CreateNull`\n* **booleans** are created with `cJSON_CreateTrue`, `cJSON_CreateFalse` or `cJSON_CreateBool`\n* **numbers** are created with `cJSON_CreateNumber`. This will set both `valuedouble` and `valueint`. If the number is outside of the range of an integer, `INT_MAX` or `INT_MIN` are used for `valueint`\n* **strings** are created with `cJSON_CreateString` (copies the string) or with `cJSON_CreateStringReference` (directly points to the string. This means that `valuestring` won't be deleted by `cJSON_Delete` and you are responsible for its lifetime, useful for constants)\n\n#### Arrays\n\nYou can create an empty array with `cJSON_CreateArray`. `cJSON_CreateArrayReference` can be used to create an array that doesn't \"own\" its content, so its content doesn't get deleted by `cJSON_Delete`.\n\nTo add items to an array, use `cJSON_AddItemToArray` to append items to the end.\nUsing `cJSON_AddItemReferenceToArray` an element can be added as a reference to another item, array or string. This means that `cJSON_Delete` will not delete that items `child` or `valuestring` properties, so no double frees are occurring if they are already used elsewhere.\nTo insert items in the middle, use `cJSON_InsertItemInArray`. It will insert an item at the given 0 based index and shift all the existing items to the right.\n\nIf you want to take an item out of an array at a given index and continue using it, use `cJSON_DetachItemFromArray`, it will return the detached item, so be sure to assign it to a pointer, otherwise you will have a memory leak.\n\nDeleting items is done with `cJSON_DeleteItemFromArray`. It works like `cJSON_DetachItemFromArray`, but deletes the detached item via `cJSON_Delete`.\n\nYou can also replace an item in an array in place. Either with `cJSON_ReplaceItemInArray` using an index or with `cJSON_ReplaceItemViaPointer` given a pointer to an element. `cJSON_ReplaceItemViaPointer` will return `0` if it fails. What this does internally is to detach the old item, delete it and insert the new item in its place.\n\nTo get the size of an array, use `cJSON_GetArraySize`. Use `cJSON_GetArrayItem` to get an element at a given index.\n\nBecause an array is stored as a linked list, iterating it via index is inefficient (`O(n²)`), so you can iterate over an array using the `cJSON_ArrayForEach` macro in `O(n)` time complexity.\n\n#### Objects\n\nYou can create an empty object with `cJSON_CreateObject`. `cJSON_CreateObjectReference` can be used to create an object that doesn't \"own\" its content, so its content doesn't get deleted by `cJSON_Delete`.\n\nTo add items to an object, use `cJSON_AddItemToObject`. Use `cJSON_AddItemToObjectCS` to add an item to an object with a name that is a constant or reference (key of the item, `string` in the `cJSON` struct), so that it doesn't get freed by `cJSON_Delete`.\nUsing `cJSON_AddItemReferenceToArray` an element can be added as a reference to another object, array or string. This means that `cJSON_Delete` will not delete that items `child` or `valuestring` properties, so no double frees are occurring if they are already used elsewhere.\n\nIf you want to take an item out of an object, use `cJSON_DetachItemFromObjectCaseSensitive`, it will return the detached item, so be sure to assign it to a pointer, otherwise you will have a memory leak.\n\nDeleting items is done with `cJSON_DeleteItemFromObjectCaseSensitive`. It works like `cJSON_DetachItemFromObjectCaseSensitive` followed by `cJSON_Delete`.\n\nYou can also replace an item in an object in place. Either with `cJSON_ReplaceItemInObjectCaseSensitive` using a key or with `cJSON_ReplaceItemViaPointer` given a pointer to an element. `cJSON_ReplaceItemViaPointer` will return `0` if it fails. What this does internally is to detach the old item, delete it and insert the new item in its place.\n\nTo get the size of an object, you can use `cJSON_GetArraySize`, this works because internally objects are stored as arrays.\n\nIf you want to access an item in an object, use `cJSON_GetObjectItemCaseSensitive`.\n\nTo iterate over an object, you can use the `cJSON_ArrayForEach` macro the same way as for arrays.\n\ncJSON also provides convenient helper functions for quickly creating a new item and adding it to an object, like `cJSON_AddNullToObject`. They return a pointer to the new item or `NULL` if they failed.\n\n### Parsing JSON\n\nGiven some JSON in a zero terminated string, you can parse it with `cJSON_Parse`.\n\n```c\ncJSON *json = cJSON_Parse(string);\n```\n\nGiven some JSON in a string (whether zero terminated or not), you can parse it with `cJSON_ParseWithLength`.\n\n```c\ncJSON *json = cJSON_ParseWithLength(string, buffer_length);\n```\n\nIt will parse the JSON and allocate a tree of `cJSON` items that represents it. Once it returns, you are fully responsible for deallocating it after use with `cJSON_Delete`.\n\nThe allocator used by `cJSON_Parse` is `malloc` and `free` by default but can be changed (globally) with `cJSON_InitHooks`.\n\nIf an error occurs a pointer to the position of the error in the input string can be accessed using `cJSON_GetErrorPtr`. Note though that this can produce race conditions in multithreading scenarios, in that case it is better to use `cJSON_ParseWithOpts` with `return_parse_end`.\nBy default, characters in the input string that follow the parsed JSON will not be considered as an error.\n\nIf you want more options, use `cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)`.\n`return_parse_end` returns a pointer to the end of the JSON in the input string or the position that an error occurs at (thereby replacing `cJSON_GetErrorPtr` in a thread safe way). `require_null_terminated`, if set to `1` will make it an error if the input string contains data after the JSON.\n\nIf you want more options giving buffer length, use `cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated)`.\n\n### Printing JSON\n\nGiven a tree of `cJSON` items, you can print them as a string using `cJSON_Print`.\n\n```c\nchar *string = cJSON_Print(json);\n```\n\nIt will allocate a string and print a JSON representation of the tree into it. Once it returns, you are fully responsible for deallocating it after use with your allocator. (usually `free`, depends on what has been set with `cJSON_InitHooks`).\n\n`cJSON_Print` will print with whitespace for formatting. If you want to print without formatting, use `cJSON_PrintUnformatted`.\n\nIf you have a rough idea of how big your resulting string will be, you can use `cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)`. `fmt` is a boolean to turn formatting with whitespace on and off. `prebuffer` specifies the first buffer size to use for printing. `cJSON_Print` currently uses 256 bytes for its first buffer size. Once printing runs out of space, a new buffer is allocated and the old gets copied over before printing is continued.\n\nThese dynamic buffer allocations can be completely avoided by using `cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)`. It takes a buffer to a pointer to print to and its length. If the length is reached, printing will fail and it returns `0`. In case of success, `1` is returned. Note that you should provide 5 bytes more than is actually needed, because cJSON is not 100% accurate in estimating if the provided memory is enough.\n\n### Example\n\nIn this example we want to build and parse the following JSON:\n\n```json\n{\n    \"name\": \"Awesome 4K\",\n    \"resolutions\": [\n        {\n            \"width\": 1280,\n            \"height\": 720\n        },\n        {\n            \"width\": 1920,\n            \"height\": 1080\n        },\n        {\n            \"width\": 3840,\n            \"height\": 2160\n        }\n    ]\n}\n```\n\n#### Printing\n\nLet's build the above JSON and print it to a string:\n\n```c\n//create a monitor with a list of supported resolutions\n//NOTE: Returns a heap allocated string, you are required to free it after use.\nchar *create_monitor(void)\n{\n    const unsigned int resolution_numbers[3][2] = {\n        {1280, 720},\n        {1920, 1080},\n        {3840, 2160}\n    };\n    char *string = NULL;\n    cJSON *name = NULL;\n    cJSON *resolutions = NULL;\n    cJSON *resolution = NULL;\n    cJSON *width = NULL;\n    cJSON *height = NULL;\n    size_t index = 0;\n\n    cJSON *monitor = cJSON_CreateObject();\n    if (monitor == NULL)\n    {\n        goto end;\n    }\n\n    name = cJSON_CreateString(\"Awesome 4K\");\n    if (name == NULL)\n    {\n        goto end;\n    }\n    /* after creation was successful, immediately add it to the monitor,\n     * thereby transferring ownership of the pointer to it */\n    cJSON_AddItemToObject(monitor, \"name\", name);\n\n    resolutions = cJSON_CreateArray();\n    if (resolutions == NULL)\n    {\n        goto end;\n    }\n    cJSON_AddItemToObject(monitor, \"resolutions\", resolutions);\n\n    for (index = 0; index < (sizeof(resolution_numbers) / (2 * sizeof(int))); ++index)\n    {\n        resolution = cJSON_CreateObject();\n        if (resolution == NULL)\n        {\n            goto end;\n        }\n        cJSON_AddItemToArray(resolutions, resolution);\n\n        width = cJSON_CreateNumber(resolution_numbers[index][0]);\n        if (width == NULL)\n        {\n            goto end;\n        }\n        cJSON_AddItemToObject(resolution, \"width\", width);\n\n        height = cJSON_CreateNumber(resolution_numbers[index][1]);\n        if (height == NULL)\n        {\n            goto end;\n        }\n        cJSON_AddItemToObject(resolution, \"height\", height);\n    }\n\n    string = cJSON_Print(monitor);\n    if (string == NULL)\n    {\n        fprintf(stderr, \"Failed to print monitor.\\n\");\n    }\n\nend:\n    cJSON_Delete(monitor);\n    return string;\n}\n```\n\nAlternatively we can use the `cJSON_Add...ToObject` helper functions to make our lives a little easier:\n\n```c\n//NOTE: Returns a heap allocated string, you are required to free it after use.\nchar *create_monitor_with_helpers(void)\n{\n    const unsigned int resolution_numbers[3][2] = {\n        {1280, 720},\n        {1920, 1080},\n        {3840, 2160}\n    };\n    char *string = NULL;\n    cJSON *resolutions = NULL;\n    size_t index = 0;\n\n    cJSON *monitor = cJSON_CreateObject();\n\n    if (cJSON_AddStringToObject(monitor, \"name\", \"Awesome 4K\") == NULL)\n    {\n        goto end;\n    }\n\n    resolutions = cJSON_AddArrayToObject(monitor, \"resolutions\");\n    if (resolutions == NULL)\n    {\n        goto end;\n    }\n\n    for (index = 0; index < (sizeof(resolution_numbers) / (2 * sizeof(int))); ++index)\n    {\n        cJSON *resolution = cJSON_CreateObject();\n\n        if (cJSON_AddNumberToObject(resolution, \"width\", resolution_numbers[index][0]) == NULL)\n        {\n            goto end;\n        }\n\n        if (cJSON_AddNumberToObject(resolution, \"height\", resolution_numbers[index][1]) == NULL)\n        {\n            goto end;\n        }\n\n        cJSON_AddItemToArray(resolutions, resolution);\n    }\n\n    string = cJSON_Print(monitor);\n    if (string == NULL)\n    {\n        fprintf(stderr, \"Failed to print monitor.\\n\");\n    }\n\nend:\n    cJSON_Delete(monitor);\n    return string;\n}\n```\n\n#### Parsing\n\nIn this example we will parse a JSON in the above format and check if the monitor supports a Full HD resolution while printing some diagnostic output:\n\n```c\n/* return 1 if the monitor supports full hd, 0 otherwise */\nint supports_full_hd(const char * const monitor)\n{\n    const cJSON *resolution = NULL;\n    const cJSON *resolutions = NULL;\n    const cJSON *name = NULL;\n    int status = 0;\n    cJSON *monitor_json = cJSON_Parse(monitor);\n    if (monitor_json == NULL)\n    {\n        const char *error_ptr = cJSON_GetErrorPtr();\n        if (error_ptr != NULL)\n        {\n            fprintf(stderr, \"Error before: %s\\n\", error_ptr);\n        }\n        status = 0;\n        goto end;\n    }\n\n    name = cJSON_GetObjectItemCaseSensitive(monitor_json, \"name\");\n    if (cJSON_IsString(name) && (name->valuestring != NULL))\n    {\n        printf(\"Checking monitor \\\"%s\\\"\\n\", name->valuestring);\n    }\n\n    resolutions = cJSON_GetObjectItemCaseSensitive(monitor_json, \"resolutions\");\n    cJSON_ArrayForEach(resolution, resolutions)\n    {\n        cJSON *width = cJSON_GetObjectItemCaseSensitive(resolution, \"width\");\n        cJSON *height = cJSON_GetObjectItemCaseSensitive(resolution, \"height\");\n\n        if (!cJSON_IsNumber(width) || !cJSON_IsNumber(height))\n        {\n            status = 0;\n            goto end;\n        }\n\n        if ((width->valuedouble == 1920) && (height->valuedouble == 1080))\n        {\n            status = 1;\n            goto end;\n        }\n    }\n\nend:\n    cJSON_Delete(monitor_json);\n    return status;\n}\n```\n\nNote that there are no NULL checks except for the result of `cJSON_Parse` because `cJSON_GetObjectItemCaseSensitive` checks for `NULL` inputs already, so a `NULL` value is just propagated and `cJSON_IsNumber` and `cJSON_IsString` return `0` if the input is `NULL`.\n\n### Caveats\n\n#### Zero Character\n\ncJSON doesn't support strings that contain the zero character `'\\0'` or `\\u0000`. This is impossible with the current API because strings are zero terminated.\n\n#### Character Encoding\n\ncJSON only supports UTF-8 encoded input. In most cases it doesn't reject invalid UTF-8 as input though, it just propagates it through as is. As long as the input doesn't contain invalid UTF-8, the output will always be valid UTF-8.\n\n#### C Standard\n\ncJSON is written in ANSI C (or C89, C90). If your compiler or C library doesn't follow this standard, correct behavior is not guaranteed.\n\nNOTE: ANSI C is not C++ therefore it shouldn't be compiled with a C++ compiler. You can compile it with a C compiler and link it with your C++ code however. Although compiling with a C++ compiler might work, correct behavior is not guaranteed.\n\n#### Floating Point Numbers\n\ncJSON does not officially support any `double` implementations other than IEEE754 double precision floating point numbers. It might still work with other implementations but bugs with these will be considered invalid.\n\nThe maximum length of a floating point literal that cJSON supports is currently 63 characters.\n\n#### Deep Nesting Of Arrays And Objects\n\ncJSON doesn't support arrays and objects that are nested too deeply because this would result in a stack overflow. To prevent this cJSON limits the depth to `CJSON_NESTING_LIMIT` which is 1000 by default but can be changed at compile time.\n\n#### Thread Safety\n\nIn general cJSON is **not thread safe**.\n\nHowever it is thread safe under the following conditions:\n\n* `cJSON_GetErrorPtr` is never used (the `return_parse_end` parameter of `cJSON_ParseWithOpts` can be used instead)\n* `cJSON_InitHooks` is only ever called before using cJSON in any threads.\n* `setlocale` is never called before all calls to cJSON functions have returned.\n\n#### Case Sensitivity\n\nWhen cJSON was originally created, it didn't follow the JSON standard and didn't make a distinction between uppercase and lowercase letters. If you want the correct, standard compliant, behavior, you need to use the `CaseSensitive` functions where available.\n\n#### Duplicate Object Members\n\ncJSON supports parsing and printing JSON that contains objects that have multiple members with the same name. `cJSON_GetObjectItemCaseSensitive` however will always only return the first one.\n\n# Enjoy cJSON!\n\n- Dave Gamble (original author)\n- Max Bruckner and Alan Wang (current maintainer)\n- and the other [cJSON contributors](CONTRIBUTORS.md)\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.6962890625,
          "content": "# Security Policy\n\n## Supported Versions\n\nSecurity is of the highest importance and all security vulnerabilities or suspected security vulnerabilities should be reported to cjson team privately, to minimize attacks against current users of cjson before they are fixed. Vulnerabilities will be investigated and patched on the next patch (or minor) release as soon as possible. This information could be kept entirely internal to the project.\n\n## Reporting a Vulnerability\n\nIf you know of a publicly disclosed security vulnerability for cjson, please IMMEDIATELY contact wp_scut@163.com and peterlee@apache.org to inform the cjson Team.\n\nIMPORTANT: Do not file public issues on GitHub for security vulnerabilities.\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 2.23046875,
          "content": "os: Visual Studio 2015\n\n# ENABLE_CUSTOM_COMPILER_FLAGS - on by default\n# ENABLE_SANITIZERS - off by default\n# ENABLE_PUBLIC_SYMBOLS - on by default\n# BUILD_SHARED_LIBS - on by default\n# ENABLE_TARGET_EXPORT - on by default\n# ENABLE_CJSON_UTILS - off by default\n# ENABLE_CJSON_TEST -on by default\n# ENABLE_VALGRIND - off by default\n# ENABLE_FUZZING - off by default\n\nenvironment:\n  matrix:\n    - GENERATOR: \"Visual Studio 14 2015\"\n      BUILD_SHARED_LIBS: ON\n      ENABLE_CJSON_TEST: OFF\n      ENABLE_CJSON_UTILS: ON\n\n    - GENERATOR: \"Visual Studio 14 2015\"\n      BUILD_SHARED_LIBS: OFF\n      ENABLE_CJSON_TEST: OFF\n      ENABLE_CJSON_UTILS: ON\n\n    - GENERATOR: \"Visual Studio 12 2013\"\n      BUILD_SHARED_LIBS: ON\n      ENABLE_CJSON_TEST: OFF\n      ENABLE_CJSON_UTILS: ON\n\n    - GENERATOR: \"Visual Studio 12 2013\"\n      BUILD_SHARED_LIBS: OFF\n      ENABLE_CJSON_TEST: OFF\n      ENABLE_CJSON_UTILS: ON\n\n    - GENERATOR: \"Visual Studio 11 2012\"\n      BUILD_SHARED_LIBS: ON\n      ENABLE_CJSON_TEST: OFF\n      ENABLE_CJSON_UTILS: ON\n\n    - GENERATOR: \"Visual Studio 11 2012\"\n      BUILD_SHARED_LIBS: OFF\n      ENABLE_CJSON_TEST: OFF\n      ENABLE_CJSON_UTILS: ON\n\n    - GENERATOR: \"Visual Studio 10 2010\"\n      BUILD_SHARED_LIBS: ON\n      ENABLE_CJSON_TEST: OFF\n      ENABLE_CJSON_UTILS: ON\n\n    - GENERATOR: \"Visual Studio 10 2010\"\n      BUILD_SHARED_LIBS: OFF\n      ENABLE_CJSON_TEST: OFF\n      ENABLE_CJSON_UTILS: ON\n\n    - GENERATOR: \"Visual Studio 9 2008\"\n      BUILD_SHARED_LIBS: ON\n      ENABLE_CJSON_TEST: OFF\n      ENABLE_CJSON_UTILS: ON\n\n    - GENERATOR: \"Visual Studio 9 2008\"\n      BUILD_SHARED_LIBS: OFF\n      ENABLE_CJSON_TEST: OFF\n      ENABLE_CJSON_UTILS: ON\n\n\nplatform:\n  - x86\n  - x64\nmatrix:\n  exclude:\n  - platform: x64\n    GENERATOR: \"Visual Studio 9 2008\"\n\nconfiguration:\n  - Release\n\n\nbuild_script:\n  - ps: if($env:PLATFORM -eq \"x64\") { $env:CMAKE_GEN_SUFFIX=\" Win64\" }\n  - cmake \"-G%GENERATOR%%CMAKE_GEN_SUFFIX%\" -DBUILD_SHARED_LIBS=%BUILD_SHARED_LIBS% -DENABLE_CJSON_TEST=%ENABLE_CJSON_TEST%  -H. -Bbuild\n  - cmake --build build --config \"%CONFIGURATION%\"\n\n\non_failure:\n  - ps: if(Test-Path builds/CMakeFiles/CMakeOutput.log) { cat builds/CMakeFiles/CMakeOutput.log }\n  - ps: if(Test-Path builds/CMakeFiles/CMakeError.log) { cat builds/CMakeFiles/CMakeError.log }"
        },
        {
          "name": "cJSON.c",
          "type": "blob",
          "size": 77.6435546875,
          "content": "/*\n  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n/* cJSON */\n/* JSON parser in C. */\n\n/* disable warnings about old C89 functions in MSVC */\n#if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#ifdef __GNUC__\n#pragma GCC visibility push(default)\n#endif\n#if defined(_MSC_VER)\n#pragma warning (push)\n/* disable warning about single line comments in system headers */\n#pragma warning (disable : 4001)\n#endif\n\n#include <string.h>\n#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <ctype.h>\n#include <float.h>\n\n#ifdef ENABLE_LOCALES\n#include <locale.h>\n#endif\n\n#if defined(_MSC_VER)\n#pragma warning (pop)\n#endif\n#ifdef __GNUC__\n#pragma GCC visibility pop\n#endif\n\n#include \"cJSON.h\"\n\n/* define our own boolean type */\n#ifdef true\n#undef true\n#endif\n#define true ((cJSON_bool)1)\n\n#ifdef false\n#undef false\n#endif\n#define false ((cJSON_bool)0)\n\n/* define isnan and isinf for ANSI C, if in C99 or above, isnan and isinf has been defined in math.h */\n#ifndef isinf\n#define isinf(d) (isnan((d - d)) && !isnan(d))\n#endif\n#ifndef isnan\n#define isnan(d) (d != d)\n#endif\n\n#ifndef NAN\n#ifdef _WIN32\n#define NAN sqrt(-1.0)\n#else\n#define NAN 0.0/0.0\n#endif\n#endif\n\ntypedef struct {\n    const unsigned char *json;\n    size_t position;\n} error;\nstatic error global_error = { NULL, 0 };\n\nCJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)\n{\n    return (const char*) (global_error.json + global_error.position);\n}\n\nCJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item)\n{\n    if (!cJSON_IsString(item))\n    {\n        return NULL;\n    }\n\n    return item->valuestring;\n}\n\nCJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item)\n{\n    if (!cJSON_IsNumber(item))\n    {\n        return (double) NAN;\n    }\n\n    return item->valuedouble;\n}\n\n/* This is a safeguard to prevent copy-pasters from using incompatible C and header files */\n#if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) || (CJSON_VERSION_PATCH != 18)\n    #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.\n#endif\n\nCJSON_PUBLIC(const char*) cJSON_Version(void)\n{\n    static char version[15];\n    sprintf(version, \"%i.%i.%i\", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);\n\n    return version;\n}\n\n/* Case insensitive string comparison, doesn't consider two NULL pointers equal though */\nstatic int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)\n{\n    if ((string1 == NULL) || (string2 == NULL))\n    {\n        return 1;\n    }\n\n    if (string1 == string2)\n    {\n        return 0;\n    }\n\n    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)\n    {\n        if (*string1 == '\\0')\n        {\n            return 0;\n        }\n    }\n\n    return tolower(*string1) - tolower(*string2);\n}\n\ntypedef struct internal_hooks\n{\n    void *(CJSON_CDECL *allocate)(size_t size);\n    void (CJSON_CDECL *deallocate)(void *pointer);\n    void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);\n} internal_hooks;\n\n#if defined(_MSC_VER)\n/* work around MSVC error C2322: '...' address of dllimport '...' is not static */\nstatic void * CJSON_CDECL internal_malloc(size_t size)\n{\n    return malloc(size);\n}\nstatic void CJSON_CDECL internal_free(void *pointer)\n{\n    free(pointer);\n}\nstatic void * CJSON_CDECL internal_realloc(void *pointer, size_t size)\n{\n    return realloc(pointer, size);\n}\n#else\n#define internal_malloc malloc\n#define internal_free free\n#define internal_realloc realloc\n#endif\n\n/* strlen of character literals resolved at compile time */\n#define static_strlen(string_literal) (sizeof(string_literal) - sizeof(\"\"))\n\nstatic internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };\n\nstatic unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)\n{\n    size_t length = 0;\n    unsigned char *copy = NULL;\n\n    if (string == NULL)\n    {\n        return NULL;\n    }\n\n    length = strlen((const char*)string) + sizeof(\"\");\n    copy = (unsigned char*)hooks->allocate(length);\n    if (copy == NULL)\n    {\n        return NULL;\n    }\n    memcpy(copy, string, length);\n\n    return copy;\n}\n\nCJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)\n{\n    if (hooks == NULL)\n    {\n        /* Reset hooks */\n        global_hooks.allocate = malloc;\n        global_hooks.deallocate = free;\n        global_hooks.reallocate = realloc;\n        return;\n    }\n\n    global_hooks.allocate = malloc;\n    if (hooks->malloc_fn != NULL)\n    {\n        global_hooks.allocate = hooks->malloc_fn;\n    }\n\n    global_hooks.deallocate = free;\n    if (hooks->free_fn != NULL)\n    {\n        global_hooks.deallocate = hooks->free_fn;\n    }\n\n    /* use realloc only if both free and malloc are used */\n    global_hooks.reallocate = NULL;\n    if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))\n    {\n        global_hooks.reallocate = realloc;\n    }\n}\n\n/* Internal constructor. */\nstatic cJSON *cJSON_New_Item(const internal_hooks * const hooks)\n{\n    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));\n    if (node)\n    {\n        memset(node, '\\0', sizeof(cJSON));\n    }\n\n    return node;\n}\n\n/* Delete a cJSON structure. */\nCJSON_PUBLIC(void) cJSON_Delete(cJSON *item)\n{\n    cJSON *next = NULL;\n    while (item != NULL)\n    {\n        next = item->next;\n        if (!(item->type & cJSON_IsReference) && (item->child != NULL))\n        {\n            cJSON_Delete(item->child);\n        }\n        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))\n        {\n            global_hooks.deallocate(item->valuestring);\n            item->valuestring = NULL;\n        }\n        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))\n        {\n            global_hooks.deallocate(item->string);\n            item->string = NULL;\n        }\n        global_hooks.deallocate(item);\n        item = next;\n    }\n}\n\n/* get the decimal point character of the current locale */\nstatic unsigned char get_decimal_point(void)\n{\n#ifdef ENABLE_LOCALES\n    struct lconv *lconv = localeconv();\n    return (unsigned char) lconv->decimal_point[0];\n#else\n    return '.';\n#endif\n}\n\ntypedef struct\n{\n    const unsigned char *content;\n    size_t length;\n    size_t offset;\n    size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */\n    internal_hooks hooks;\n} parse_buffer;\n\n/* check if the given size is left to read in a given parse buffer (starting with 1) */\n#define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))\n/* check if the buffer can be accessed at the given index (starting with 0) */\n#define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))\n#define cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))\n/* get a pointer to the buffer at the position */\n#define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)\n\n/* Parse the input text to generate a number, and populate the result into item. */\nstatic cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)\n{\n    double number = 0;\n    unsigned char *after_end = NULL;\n    unsigned char number_c_string[64];\n    unsigned char decimal_point = get_decimal_point();\n    size_t i = 0;\n\n    if ((input_buffer == NULL) || (input_buffer->content == NULL))\n    {\n        return false;\n    }\n\n    /* copy the number into a temporary buffer and replace '.' with the decimal point\n     * of the current locale (for strtod)\n     * This also takes care of '\\0' not necessarily being available for marking the end of the input */\n    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)\n    {\n        switch (buffer_at_offset(input_buffer)[i])\n        {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case '+':\n            case '-':\n            case 'e':\n            case 'E':\n                number_c_string[i] = buffer_at_offset(input_buffer)[i];\n                break;\n\n            case '.':\n                number_c_string[i] = decimal_point;\n                break;\n\n            default:\n                goto loop_end;\n        }\n    }\nloop_end:\n    number_c_string[i] = '\\0';\n\n    number = strtod((const char*)number_c_string, (char**)&after_end);\n    if (number_c_string == after_end)\n    {\n        return false; /* parse_error */\n    }\n\n    item->valuedouble = number;\n\n    /* use saturation in case of overflow */\n    if (number >= INT_MAX)\n    {\n        item->valueint = INT_MAX;\n    }\n    else if (number <= (double)INT_MIN)\n    {\n        item->valueint = INT_MIN;\n    }\n    else\n    {\n        item->valueint = (int)number;\n    }\n\n    item->type = cJSON_Number;\n\n    input_buffer->offset += (size_t)(after_end - number_c_string);\n    return true;\n}\n\n/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */\nCJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)\n{\n    if (number >= INT_MAX)\n    {\n        object->valueint = INT_MAX;\n    }\n    else if (number <= (double)INT_MIN)\n    {\n        object->valueint = INT_MIN;\n    }\n    else\n    {\n        object->valueint = (int)number;\n    }\n\n    return object->valuedouble = number;\n}\n\n/* Note: when passing a NULL valuestring, cJSON_SetValuestring treats this as an error and return NULL */\nCJSON_PUBLIC(char*) cJSON_SetValuestring(cJSON *object, const char *valuestring)\n{\n    char *copy = NULL;\n    size_t v1_len;\n    size_t v2_len;\n    /* if object's type is not cJSON_String or is cJSON_IsReference, it should not set valuestring */\n    if ((object == NULL) || !(object->type & cJSON_String) || (object->type & cJSON_IsReference))\n    {\n        return NULL;\n    }\n    /* return NULL if the object is corrupted or valuestring is NULL */\n    if (object->valuestring == NULL || valuestring == NULL)\n    {\n        return NULL;\n    }\n\n    v1_len = strlen(valuestring);\n    v2_len = strlen(object->valuestring);\n\n    if (v1_len <= v2_len)\n    {\n        /* strcpy does not handle overlapping string: [X1, X2] [Y1, Y2] => X2 < Y1 or Y2 < X1 */\n        if (!( valuestring + v1_len < object->valuestring || object->valuestring + v2_len < valuestring ))\n        {\n            return NULL;\n        }\n        strcpy(object->valuestring, valuestring);\n        return object->valuestring;\n    }\n    copy = (char*) cJSON_strdup((const unsigned char*)valuestring, &global_hooks);\n    if (copy == NULL)\n    {\n        return NULL;\n    }\n    if (object->valuestring != NULL)\n    {\n        cJSON_free(object->valuestring);\n    }\n    object->valuestring = copy;\n\n    return copy;\n}\n\ntypedef struct\n{\n    unsigned char *buffer;\n    size_t length;\n    size_t offset;\n    size_t depth; /* current nesting depth (for formatted printing) */\n    cJSON_bool noalloc;\n    cJSON_bool format; /* is this print a formatted print */\n    internal_hooks hooks;\n} printbuffer;\n\n/* realloc printbuffer if necessary to have at least \"needed\" bytes more */\nstatic unsigned char* ensure(printbuffer * const p, size_t needed)\n{\n    unsigned char *newbuffer = NULL;\n    size_t newsize = 0;\n\n    if ((p == NULL) || (p->buffer == NULL))\n    {\n        return NULL;\n    }\n\n    if ((p->length > 0) && (p->offset >= p->length))\n    {\n        /* make sure that offset is valid */\n        return NULL;\n    }\n\n    if (needed > INT_MAX)\n    {\n        /* sizes bigger than INT_MAX are currently not supported */\n        return NULL;\n    }\n\n    needed += p->offset + 1;\n    if (needed <= p->length)\n    {\n        return p->buffer + p->offset;\n    }\n\n    if (p->noalloc) {\n        return NULL;\n    }\n\n    /* calculate new buffer size */\n    if (needed > (INT_MAX / 2))\n    {\n        /* overflow of int, use INT_MAX if possible */\n        if (needed <= INT_MAX)\n        {\n            newsize = INT_MAX;\n        }\n        else\n        {\n            return NULL;\n        }\n    }\n    else\n    {\n        newsize = needed * 2;\n    }\n\n    if (p->hooks.reallocate != NULL)\n    {\n        /* reallocate with realloc if available */\n        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);\n        if (newbuffer == NULL)\n        {\n            p->hooks.deallocate(p->buffer);\n            p->length = 0;\n            p->buffer = NULL;\n\n            return NULL;\n        }\n    }\n    else\n    {\n        /* otherwise reallocate manually */\n        newbuffer = (unsigned char*)p->hooks.allocate(newsize);\n        if (!newbuffer)\n        {\n            p->hooks.deallocate(p->buffer);\n            p->length = 0;\n            p->buffer = NULL;\n\n            return NULL;\n        }\n\n        memcpy(newbuffer, p->buffer, p->offset + 1);\n        p->hooks.deallocate(p->buffer);\n    }\n    p->length = newsize;\n    p->buffer = newbuffer;\n\n    return newbuffer + p->offset;\n}\n\n/* calculate the new length of the string in a printbuffer and update the offset */\nstatic void update_offset(printbuffer * const buffer)\n{\n    const unsigned char *buffer_pointer = NULL;\n    if ((buffer == NULL) || (buffer->buffer == NULL))\n    {\n        return;\n    }\n    buffer_pointer = buffer->buffer + buffer->offset;\n\n    buffer->offset += strlen((const char*)buffer_pointer);\n}\n\n/* securely comparison of floating-point variables */\nstatic cJSON_bool compare_double(double a, double b)\n{\n    double maxVal = fabs(a) > fabs(b) ? fabs(a) : fabs(b);\n    return (fabs(a - b) <= maxVal * DBL_EPSILON);\n}\n\n/* Render the number nicely from the given item into a string. */\nstatic cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output_pointer = NULL;\n    double d = item->valuedouble;\n    int length = 0;\n    size_t i = 0;\n    unsigned char number_buffer[26] = {0}; /* temporary buffer to print the number into */\n    unsigned char decimal_point = get_decimal_point();\n    double test = 0.0;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* This checks for NaN and Infinity */\n    if (isnan(d) || isinf(d))\n    {\n        length = sprintf((char*)number_buffer, \"null\");\n    }\n    else if(d == (double)item->valueint)\n    {\n        length = sprintf((char*)number_buffer, \"%d\", item->valueint);\n    }\n    else\n    {\n        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */\n        length = sprintf((char*)number_buffer, \"%1.15g\", d);\n\n        /* Check whether the original double can be recovered */\n        if ((sscanf((char*)number_buffer, \"%lg\", &test) != 1) || !compare_double((double)test, d))\n        {\n            /* If not, print with 17 decimal places of precision */\n            length = sprintf((char*)number_buffer, \"%1.17g\", d);\n        }\n    }\n\n    /* sprintf failed or buffer overrun occurred */\n    if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))\n    {\n        return false;\n    }\n\n    /* reserve appropriate space in the output */\n    output_pointer = ensure(output_buffer, (size_t)length + sizeof(\"\"));\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    /* copy the printed number to the output and replace locale\n     * dependent decimal point with '.' */\n    for (i = 0; i < ((size_t)length); i++)\n    {\n        if (number_buffer[i] == decimal_point)\n        {\n            output_pointer[i] = '.';\n            continue;\n        }\n\n        output_pointer[i] = number_buffer[i];\n    }\n    output_pointer[i] = '\\0';\n\n    output_buffer->offset += (size_t)length;\n\n    return true;\n}\n\n/* parse 4 digit hexadecimal number */\nstatic unsigned parse_hex4(const unsigned char * const input)\n{\n    unsigned int h = 0;\n    size_t i = 0;\n\n    for (i = 0; i < 4; i++)\n    {\n        /* parse digit */\n        if ((input[i] >= '0') && (input[i] <= '9'))\n        {\n            h += (unsigned int) input[i] - '0';\n        }\n        else if ((input[i] >= 'A') && (input[i] <= 'F'))\n        {\n            h += (unsigned int) 10 + input[i] - 'A';\n        }\n        else if ((input[i] >= 'a') && (input[i] <= 'f'))\n        {\n            h += (unsigned int) 10 + input[i] - 'a';\n        }\n        else /* invalid */\n        {\n            return 0;\n        }\n\n        if (i < 3)\n        {\n            /* shift left to make place for the next nibble */\n            h = h << 4;\n        }\n    }\n\n    return h;\n}\n\n/* converts a UTF-16 literal to UTF-8\n * A literal can be one or two sequences of the form \\uXXXX */\nstatic unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)\n{\n    long unsigned int codepoint = 0;\n    unsigned int first_code = 0;\n    const unsigned char *first_sequence = input_pointer;\n    unsigned char utf8_length = 0;\n    unsigned char utf8_position = 0;\n    unsigned char sequence_length = 0;\n    unsigned char first_byte_mark = 0;\n\n    if ((input_end - first_sequence) < 6)\n    {\n        /* input ends unexpectedly */\n        goto fail;\n    }\n\n    /* get the first utf16 sequence */\n    first_code = parse_hex4(first_sequence + 2);\n\n    /* check that the code is valid */\n    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))\n    {\n        goto fail;\n    }\n\n    /* UTF16 surrogate pair */\n    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))\n    {\n        const unsigned char *second_sequence = first_sequence + 6;\n        unsigned int second_code = 0;\n        sequence_length = 12; /* \\uXXXX\\uXXXX */\n\n        if ((input_end - second_sequence) < 6)\n        {\n            /* input ends unexpectedly */\n            goto fail;\n        }\n\n        if ((second_sequence[0] != '\\\\') || (second_sequence[1] != 'u'))\n        {\n            /* missing second half of the surrogate pair */\n            goto fail;\n        }\n\n        /* get the second utf16 sequence */\n        second_code = parse_hex4(second_sequence + 2);\n        /* check that the code is valid */\n        if ((second_code < 0xDC00) || (second_code > 0xDFFF))\n        {\n            /* invalid second half of the surrogate pair */\n            goto fail;\n        }\n\n\n        /* calculate the unicode codepoint from the surrogate pair */\n        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));\n    }\n    else\n    {\n        sequence_length = 6; /* \\uXXXX */\n        codepoint = first_code;\n    }\n\n    /* encode as UTF-8\n     * takes at maximum 4 bytes to encode:\n     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */\n    if (codepoint < 0x80)\n    {\n        /* normal ascii, encoding 0xxxxxxx */\n        utf8_length = 1;\n    }\n    else if (codepoint < 0x800)\n    {\n        /* two bytes, encoding 110xxxxx 10xxxxxx */\n        utf8_length = 2;\n        first_byte_mark = 0xC0; /* 11000000 */\n    }\n    else if (codepoint < 0x10000)\n    {\n        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */\n        utf8_length = 3;\n        first_byte_mark = 0xE0; /* 11100000 */\n    }\n    else if (codepoint <= 0x10FFFF)\n    {\n        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */\n        utf8_length = 4;\n        first_byte_mark = 0xF0; /* 11110000 */\n    }\n    else\n    {\n        /* invalid unicode codepoint */\n        goto fail;\n    }\n\n    /* encode as utf8 */\n    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)\n    {\n        /* 10xxxxxx */\n        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);\n        codepoint >>= 6;\n    }\n    /* encode first byte */\n    if (utf8_length > 1)\n    {\n        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);\n    }\n    else\n    {\n        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);\n    }\n\n    *output_pointer += utf8_length;\n\n    return sequence_length;\n\nfail:\n    return 0;\n}\n\n/* Parse the input text into an unescaped cinput, and populate item. */\nstatic cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)\n{\n    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;\n    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;\n    unsigned char *output_pointer = NULL;\n    unsigned char *output = NULL;\n\n    /* not a string */\n    if (buffer_at_offset(input_buffer)[0] != '\\\"')\n    {\n        goto fail;\n    }\n\n    {\n        /* calculate approximate size of the output (overestimate) */\n        size_t allocation_length = 0;\n        size_t skipped_bytes = 0;\n        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\\\"'))\n        {\n            /* is escape sequence */\n            if (input_end[0] == '\\\\')\n            {\n                if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)\n                {\n                    /* prevent buffer overflow when last input character is a backslash */\n                    goto fail;\n                }\n                skipped_bytes++;\n                input_end++;\n            }\n            input_end++;\n        }\n        if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\\\"'))\n        {\n            goto fail; /* string ended unexpectedly */\n        }\n\n        /* This is at most how much we need for the output */\n        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;\n        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(\"\"));\n        if (output == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n    }\n\n    output_pointer = output;\n    /* loop through the string literal */\n    while (input_pointer < input_end)\n    {\n        if (*input_pointer != '\\\\')\n        {\n            *output_pointer++ = *input_pointer++;\n        }\n        /* escape sequence */\n        else\n        {\n            unsigned char sequence_length = 2;\n            if ((input_end - input_pointer) < 1)\n            {\n                goto fail;\n            }\n\n            switch (input_pointer[1])\n            {\n                case 'b':\n                    *output_pointer++ = '\\b';\n                    break;\n                case 'f':\n                    *output_pointer++ = '\\f';\n                    break;\n                case 'n':\n                    *output_pointer++ = '\\n';\n                    break;\n                case 'r':\n                    *output_pointer++ = '\\r';\n                    break;\n                case 't':\n                    *output_pointer++ = '\\t';\n                    break;\n                case '\\\"':\n                case '\\\\':\n                case '/':\n                    *output_pointer++ = input_pointer[1];\n                    break;\n\n                /* UTF-16 literal */\n                case 'u':\n                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);\n                    if (sequence_length == 0)\n                    {\n                        /* failed to convert UTF16-literal to UTF-8 */\n                        goto fail;\n                    }\n                    break;\n\n                default:\n                    goto fail;\n            }\n            input_pointer += sequence_length;\n        }\n    }\n\n    /* zero terminate the output */\n    *output_pointer = '\\0';\n\n    item->type = cJSON_String;\n    item->valuestring = (char*)output;\n\n    input_buffer->offset = (size_t) (input_end - input_buffer->content);\n    input_buffer->offset++;\n\n    return true;\n\nfail:\n    if (output != NULL)\n    {\n        input_buffer->hooks.deallocate(output);\n        output = NULL;\n    }\n\n    if (input_pointer != NULL)\n    {\n        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);\n    }\n\n    return false;\n}\n\n/* Render the cstring provided to an escaped version that can be printed. */\nstatic cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)\n{\n    const unsigned char *input_pointer = NULL;\n    unsigned char *output = NULL;\n    unsigned char *output_pointer = NULL;\n    size_t output_length = 0;\n    /* numbers of additional characters needed for escaping */\n    size_t escape_characters = 0;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* empty string */\n    if (input == NULL)\n    {\n        output = ensure(output_buffer, sizeof(\"\\\"\\\"\"));\n        if (output == NULL)\n        {\n            return false;\n        }\n        strcpy((char*)output, \"\\\"\\\"\");\n\n        return true;\n    }\n\n    /* set \"flag\" to 1 if something needs to be escaped */\n    for (input_pointer = input; *input_pointer; input_pointer++)\n    {\n        switch (*input_pointer)\n        {\n            case '\\\"':\n            case '\\\\':\n            case '\\b':\n            case '\\f':\n            case '\\n':\n            case '\\r':\n            case '\\t':\n                /* one character escape sequence */\n                escape_characters++;\n                break;\n            default:\n                if (*input_pointer < 32)\n                {\n                    /* UTF-16 escape sequence uXXXX */\n                    escape_characters += 5;\n                }\n                break;\n        }\n    }\n    output_length = (size_t)(input_pointer - input) + escape_characters;\n\n    output = ensure(output_buffer, output_length + sizeof(\"\\\"\\\"\"));\n    if (output == NULL)\n    {\n        return false;\n    }\n\n    /* no characters have to be escaped */\n    if (escape_characters == 0)\n    {\n        output[0] = '\\\"';\n        memcpy(output + 1, input, output_length);\n        output[output_length + 1] = '\\\"';\n        output[output_length + 2] = '\\0';\n\n        return true;\n    }\n\n    output[0] = '\\\"';\n    output_pointer = output + 1;\n    /* copy the string */\n    for (input_pointer = input; *input_pointer != '\\0'; (void)input_pointer++, output_pointer++)\n    {\n        if ((*input_pointer > 31) && (*input_pointer != '\\\"') && (*input_pointer != '\\\\'))\n        {\n            /* normal character, copy */\n            *output_pointer = *input_pointer;\n        }\n        else\n        {\n            /* character needs to be escaped */\n            *output_pointer++ = '\\\\';\n            switch (*input_pointer)\n            {\n                case '\\\\':\n                    *output_pointer = '\\\\';\n                    break;\n                case '\\\"':\n                    *output_pointer = '\\\"';\n                    break;\n                case '\\b':\n                    *output_pointer = 'b';\n                    break;\n                case '\\f':\n                    *output_pointer = 'f';\n                    break;\n                case '\\n':\n                    *output_pointer = 'n';\n                    break;\n                case '\\r':\n                    *output_pointer = 'r';\n                    break;\n                case '\\t':\n                    *output_pointer = 't';\n                    break;\n                default:\n                    /* escape and print as unicode codepoint */\n                    sprintf((char*)output_pointer, \"u%04x\", *input_pointer);\n                    output_pointer += 4;\n                    break;\n            }\n        }\n    }\n    output[output_length + 1] = '\\\"';\n    output[output_length + 2] = '\\0';\n\n    return true;\n}\n\n/* Invoke print_string_ptr (which is useful) on an item. */\nstatic cJSON_bool print_string(const cJSON * const item, printbuffer * const p)\n{\n    return print_string_ptr((unsigned char*)item->valuestring, p);\n}\n\n/* Predeclare these prototypes. */\nstatic cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer);\nstatic cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer);\nstatic cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer);\nstatic cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer);\nstatic cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);\nstatic cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);\n\n/* Utility to jump whitespace and cr/lf */\nstatic parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)\n{\n    if ((buffer == NULL) || (buffer->content == NULL))\n    {\n        return NULL;\n    }\n\n    if (cannot_access_at_index(buffer, 0))\n    {\n        return buffer;\n    }\n\n    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))\n    {\n       buffer->offset++;\n    }\n\n    if (buffer->offset == buffer->length)\n    {\n        buffer->offset--;\n    }\n\n    return buffer;\n}\n\n/* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */\nstatic parse_buffer *skip_utf8_bom(parse_buffer * const buffer)\n{\n    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))\n    {\n        return NULL;\n    }\n\n    if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), \"\\xEF\\xBB\\xBF\", 3) == 0))\n    {\n        buffer->offset += 3;\n    }\n\n    return buffer;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)\n{\n    size_t buffer_length;\n\n    if (NULL == value)\n    {\n        return NULL;\n    }\n\n    /* Adding null character size due to require_null_terminated. */\n    buffer_length = strlen(value) + sizeof(\"\");\n\n    return cJSON_ParseWithLengthOpts(value, buffer_length, return_parse_end, require_null_terminated);\n}\n\n/* Parse an object - create a new root, and populate. */\nCJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated)\n{\n    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n    cJSON *item = NULL;\n\n    /* reset error position */\n    global_error.json = NULL;\n    global_error.position = 0;\n\n    if (value == NULL || 0 == buffer_length)\n    {\n        goto fail;\n    }\n\n    buffer.content = (const unsigned char*)value;\n    buffer.length = buffer_length;\n    buffer.offset = 0;\n    buffer.hooks = global_hooks;\n\n    item = cJSON_New_Item(&global_hooks);\n    if (item == NULL) /* memory fail */\n    {\n        goto fail;\n    }\n\n    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))\n    {\n        /* parse failure. ep is set. */\n        goto fail;\n    }\n\n    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */\n    if (require_null_terminated)\n    {\n        buffer_skip_whitespace(&buffer);\n        if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\\0')\n        {\n            goto fail;\n        }\n    }\n    if (return_parse_end)\n    {\n        *return_parse_end = (const char*)buffer_at_offset(&buffer);\n    }\n\n    return item;\n\nfail:\n    if (item != NULL)\n    {\n        cJSON_Delete(item);\n    }\n\n    if (value != NULL)\n    {\n        error local_error;\n        local_error.json = (const unsigned char*)value;\n        local_error.position = 0;\n\n        if (buffer.offset < buffer.length)\n        {\n            local_error.position = buffer.offset;\n        }\n        else if (buffer.length > 0)\n        {\n            local_error.position = buffer.length - 1;\n        }\n\n        if (return_parse_end != NULL)\n        {\n            *return_parse_end = (const char*)local_error.json + local_error.position;\n        }\n\n        global_error = local_error;\n    }\n\n    return NULL;\n}\n\n/* Default options for cJSON_Parse */\nCJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)\n{\n    return cJSON_ParseWithOpts(value, 0, 0);\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length)\n{\n    return cJSON_ParseWithLengthOpts(value, buffer_length, 0, 0);\n}\n\n#define cjson_min(a, b) (((a) < (b)) ? (a) : (b))\n\nstatic unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)\n{\n    static const size_t default_buffer_size = 256;\n    printbuffer buffer[1];\n    unsigned char *printed = NULL;\n\n    memset(buffer, 0, sizeof(buffer));\n\n    /* create buffer */\n    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);\n    buffer->length = default_buffer_size;\n    buffer->format = format;\n    buffer->hooks = *hooks;\n    if (buffer->buffer == NULL)\n    {\n        goto fail;\n    }\n\n    /* print the value */\n    if (!print_value(item, buffer))\n    {\n        goto fail;\n    }\n    update_offset(buffer);\n\n    /* check if reallocate is available */\n    if (hooks->reallocate != NULL)\n    {\n        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);\n        if (printed == NULL) {\n            goto fail;\n        }\n        buffer->buffer = NULL;\n    }\n    else /* otherwise copy the JSON over to a new buffer */\n    {\n        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);\n        if (printed == NULL)\n        {\n            goto fail;\n        }\n        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));\n        printed[buffer->offset] = '\\0'; /* just to be sure */\n\n        /* free the buffer */\n        hooks->deallocate(buffer->buffer);\n        buffer->buffer = NULL;\n    }\n\n    return printed;\n\nfail:\n    if (buffer->buffer != NULL)\n    {\n        hooks->deallocate(buffer->buffer);\n        buffer->buffer = NULL;\n    }\n\n    if (printed != NULL)\n    {\n        hooks->deallocate(printed);\n        printed = NULL;\n    }\n\n    return NULL;\n}\n\n/* Render a cJSON item/entity/structure to text. */\nCJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)\n{\n    return (char*)print(item, true, &global_hooks);\n}\n\nCJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)\n{\n    return (char*)print(item, false, &global_hooks);\n}\n\nCJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)\n{\n    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n\n    if (prebuffer < 0)\n    {\n        return NULL;\n    }\n\n    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);\n    if (!p.buffer)\n    {\n        return NULL;\n    }\n\n    p.length = (size_t)prebuffer;\n    p.offset = 0;\n    p.noalloc = false;\n    p.format = fmt;\n    p.hooks = global_hooks;\n\n    if (!print_value(item, &p))\n    {\n        global_hooks.deallocate(p.buffer);\n        p.buffer = NULL;\n        return NULL;\n    }\n\n    return (char*)p.buffer;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)\n{\n    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n\n    if ((length < 0) || (buffer == NULL))\n    {\n        return false;\n    }\n\n    p.buffer = (unsigned char*)buffer;\n    p.length = (size_t)length;\n    p.offset = 0;\n    p.noalloc = true;\n    p.format = format;\n    p.hooks = global_hooks;\n\n    return print_value(item, &p);\n}\n\n/* Parser core - when encountering text, process appropriately. */\nstatic cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)\n{\n    if ((input_buffer == NULL) || (input_buffer->content == NULL))\n    {\n        return false; /* no input */\n    }\n\n    /* parse the different types of values */\n    /* null */\n    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), \"null\", 4) == 0))\n    {\n        item->type = cJSON_NULL;\n        input_buffer->offset += 4;\n        return true;\n    }\n    /* false */\n    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), \"false\", 5) == 0))\n    {\n        item->type = cJSON_False;\n        input_buffer->offset += 5;\n        return true;\n    }\n    /* true */\n    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), \"true\", 4) == 0))\n    {\n        item->type = cJSON_True;\n        item->valueint = 1;\n        input_buffer->offset += 4;\n        return true;\n    }\n    /* string */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\\\"'))\n    {\n        return parse_string(item, input_buffer);\n    }\n    /* number */\n    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))\n    {\n        return parse_number(item, input_buffer);\n    }\n    /* array */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))\n    {\n        return parse_array(item, input_buffer);\n    }\n    /* object */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))\n    {\n        return parse_object(item, input_buffer);\n    }\n\n    return false;\n}\n\n/* Render a value to text. */\nstatic cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output = NULL;\n\n    if ((item == NULL) || (output_buffer == NULL))\n    {\n        return false;\n    }\n\n    switch ((item->type) & 0xFF)\n    {\n        case cJSON_NULL:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"null\");\n            return true;\n\n        case cJSON_False:\n            output = ensure(output_buffer, 6);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"false\");\n            return true;\n\n        case cJSON_True:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"true\");\n            return true;\n\n        case cJSON_Number:\n            return print_number(item, output_buffer);\n\n        case cJSON_Raw:\n        {\n            size_t raw_length = 0;\n            if (item->valuestring == NULL)\n            {\n                return false;\n            }\n\n            raw_length = strlen(item->valuestring) + sizeof(\"\");\n            output = ensure(output_buffer, raw_length);\n            if (output == NULL)\n            {\n                return false;\n            }\n            memcpy(output, item->valuestring, raw_length);\n            return true;\n        }\n\n        case cJSON_String:\n            return print_string(item, output_buffer);\n\n        case cJSON_Array:\n            return print_array(item, output_buffer);\n\n        case cJSON_Object:\n            return print_object(item, output_buffer);\n\n        default:\n            return false;\n    }\n}\n\n/* Build an array from input text. */\nstatic cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)\n{\n    cJSON *head = NULL; /* head of the linked list */\n    cJSON *current_item = NULL;\n\n    if (input_buffer->depth >= CJSON_NESTING_LIMIT)\n    {\n        return false; /* to deeply nested */\n    }\n    input_buffer->depth++;\n\n    if (buffer_at_offset(input_buffer)[0] != '[')\n    {\n        /* not an array */\n        goto fail;\n    }\n\n    input_buffer->offset++;\n    buffer_skip_whitespace(input_buffer);\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))\n    {\n        /* empty array */\n        goto success;\n    }\n\n    /* check if we skipped to the end of the buffer */\n    if (cannot_access_at_index(input_buffer, 0))\n    {\n        input_buffer->offset--;\n        goto fail;\n    }\n\n    /* step back to character in front of the first element */\n    input_buffer->offset--;\n    /* loop through the comma separated array elements */\n    do\n    {\n        /* allocate next item */\n        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));\n        if (new_item == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n\n        /* attach next item to list */\n        if (head == NULL)\n        {\n            /* start the linked list */\n            current_item = head = new_item;\n        }\n        else\n        {\n            /* add to the end and advance */\n            current_item->next = new_item;\n            new_item->prev = current_item;\n            current_item = new_item;\n        }\n\n        /* parse next value */\n        input_buffer->offset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_value(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse value */\n        }\n        buffer_skip_whitespace(input_buffer);\n    }\n    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));\n\n    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')\n    {\n        goto fail; /* expected end of array */\n    }\n\nsuccess:\n    input_buffer->depth--;\n\n    if (head != NULL) {\n        head->prev = current_item;\n    }\n\n    item->type = cJSON_Array;\n    item->child = head;\n\n    input_buffer->offset++;\n\n    return true;\n\nfail:\n    if (head != NULL)\n    {\n        cJSON_Delete(head);\n    }\n\n    return false;\n}\n\n/* Render an array to text */\nstatic cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output_pointer = NULL;\n    size_t length = 0;\n    cJSON *current_element = item->child;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* Compose the output array. */\n    /* opening square bracket */\n    output_pointer = ensure(output_buffer, 1);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    *output_pointer = '[';\n    output_buffer->offset++;\n    output_buffer->depth++;\n\n    while (current_element != NULL)\n    {\n        if (!print_value(current_element, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n        if (current_element->next)\n        {\n            length = (size_t) (output_buffer->format ? 2 : 1);\n            output_pointer = ensure(output_buffer, length + 1);\n            if (output_pointer == NULL)\n            {\n                return false;\n            }\n            *output_pointer++ = ',';\n            if(output_buffer->format)\n            {\n                *output_pointer++ = ' ';\n            }\n            *output_pointer = '\\0';\n            output_buffer->offset += length;\n        }\n        current_element = current_element->next;\n    }\n\n    output_pointer = ensure(output_buffer, 2);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n    *output_pointer++ = ']';\n    *output_pointer = '\\0';\n    output_buffer->depth--;\n\n    return true;\n}\n\n/* Build an object from the text. */\nstatic cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)\n{\n    cJSON *head = NULL; /* linked list head */\n    cJSON *current_item = NULL;\n\n    if (input_buffer->depth >= CJSON_NESTING_LIMIT)\n    {\n        return false; /* to deeply nested */\n    }\n    input_buffer->depth++;\n\n    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))\n    {\n        goto fail; /* not an object */\n    }\n\n    input_buffer->offset++;\n    buffer_skip_whitespace(input_buffer);\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))\n    {\n        goto success; /* empty object */\n    }\n\n    /* check if we skipped to the end of the buffer */\n    if (cannot_access_at_index(input_buffer, 0))\n    {\n        input_buffer->offset--;\n        goto fail;\n    }\n\n    /* step back to character in front of the first element */\n    input_buffer->offset--;\n    /* loop through the comma separated array elements */\n    do\n    {\n        /* allocate next item */\n        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));\n        if (new_item == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n\n        /* attach next item to list */\n        if (head == NULL)\n        {\n            /* start the linked list */\n            current_item = head = new_item;\n        }\n        else\n        {\n            /* add to the end and advance */\n            current_item->next = new_item;\n            new_item->prev = current_item;\n            current_item = new_item;\n        }\n\n        if (cannot_access_at_index(input_buffer, 1))\n        {\n            goto fail; /* nothing comes after the comma */\n        }\n\n        /* parse the name of the child */\n        input_buffer->offset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_string(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse name */\n        }\n        buffer_skip_whitespace(input_buffer);\n\n        /* swap valuestring and string, because we parsed the name */\n        current_item->string = current_item->valuestring;\n        current_item->valuestring = NULL;\n\n        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))\n        {\n            goto fail; /* invalid object */\n        }\n\n        /* parse the value */\n        input_buffer->offset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_value(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse value */\n        }\n        buffer_skip_whitespace(input_buffer);\n    }\n    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));\n\n    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))\n    {\n        goto fail; /* expected end of object */\n    }\n\nsuccess:\n    input_buffer->depth--;\n\n    if (head != NULL) {\n        head->prev = current_item;\n    }\n\n    item->type = cJSON_Object;\n    item->child = head;\n\n    input_buffer->offset++;\n    return true;\n\nfail:\n    if (head != NULL)\n    {\n        cJSON_Delete(head);\n    }\n\n    return false;\n}\n\n/* Render an object to text. */\nstatic cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output_pointer = NULL;\n    size_t length = 0;\n    cJSON *current_item = item->child;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* Compose the output: */\n    length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\\n */\n    output_pointer = ensure(output_buffer, length + 1);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    *output_pointer++ = '{';\n    output_buffer->depth++;\n    if (output_buffer->format)\n    {\n        *output_pointer++ = '\\n';\n    }\n    output_buffer->offset += length;\n\n    while (current_item)\n    {\n        if (output_buffer->format)\n        {\n            size_t i;\n            output_pointer = ensure(output_buffer, output_buffer->depth);\n            if (output_pointer == NULL)\n            {\n                return false;\n            }\n            for (i = 0; i < output_buffer->depth; i++)\n            {\n                *output_pointer++ = '\\t';\n            }\n            output_buffer->offset += output_buffer->depth;\n        }\n\n        /* print key */\n        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n\n        length = (size_t) (output_buffer->format ? 2 : 1);\n        output_pointer = ensure(output_buffer, length);\n        if (output_pointer == NULL)\n        {\n            return false;\n        }\n        *output_pointer++ = ':';\n        if (output_buffer->format)\n        {\n            *output_pointer++ = '\\t';\n        }\n        output_buffer->offset += length;\n\n        /* print value */\n        if (!print_value(current_item, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n\n        /* print comma if not last */\n        length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));\n        output_pointer = ensure(output_buffer, length + 1);\n        if (output_pointer == NULL)\n        {\n            return false;\n        }\n        if (current_item->next)\n        {\n            *output_pointer++ = ',';\n        }\n\n        if (output_buffer->format)\n        {\n            *output_pointer++ = '\\n';\n        }\n        *output_pointer = '\\0';\n        output_buffer->offset += length;\n\n        current_item = current_item->next;\n    }\n\n    output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n    if (output_buffer->format)\n    {\n        size_t i;\n        for (i = 0; i < (output_buffer->depth - 1); i++)\n        {\n            *output_pointer++ = '\\t';\n        }\n    }\n    *output_pointer++ = '}';\n    *output_pointer = '\\0';\n    output_buffer->depth--;\n\n    return true;\n}\n\n/* Get Array size/item / object item. */\nCJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)\n{\n    cJSON *child = NULL;\n    size_t size = 0;\n\n    if (array == NULL)\n    {\n        return 0;\n    }\n\n    child = array->child;\n\n    while(child != NULL)\n    {\n        size++;\n        child = child->next;\n    }\n\n    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */\n\n    return (int)size;\n}\n\nstatic cJSON* get_array_item(const cJSON *array, size_t index)\n{\n    cJSON *current_child = NULL;\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    current_child = array->child;\n    while ((current_child != NULL) && (index > 0))\n    {\n        index--;\n        current_child = current_child->next;\n    }\n\n    return current_child;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)\n{\n    if (index < 0)\n    {\n        return NULL;\n    }\n\n    return get_array_item(array, (size_t)index);\n}\n\nstatic cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n    current_element = object->child;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n\n    if ((current_element == NULL) || (current_element->string == NULL)) {\n        return NULL;\n    }\n\n    return current_element;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)\n{\n    return get_object_item(object, string, false);\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)\n{\n    return get_object_item(object, string, true);\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)\n{\n    return cJSON_GetObjectItem(object, string) ? 1 : 0;\n}\n\n/* Utility for array list handling. */\nstatic void suffix_object(cJSON *prev, cJSON *item)\n{\n    prev->next = item;\n    item->prev = prev;\n}\n\n/* Utility for handling references. */\nstatic cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)\n{\n    cJSON *reference = NULL;\n    if (item == NULL)\n    {\n        return NULL;\n    }\n\n    reference = cJSON_New_Item(hooks);\n    if (reference == NULL)\n    {\n        return NULL;\n    }\n\n    memcpy(reference, item, sizeof(cJSON));\n    reference->string = NULL;\n    reference->type |= cJSON_IsReference;\n    reference->next = reference->prev = NULL;\n    return reference;\n}\n\nstatic cJSON_bool add_item_to_array(cJSON *array, cJSON *item)\n{\n    cJSON *child = NULL;\n\n    if ((item == NULL) || (array == NULL) || (array == item))\n    {\n        return false;\n    }\n\n    child = array->child;\n    /*\n     * To find the last item in array quickly, we use prev in array\n     */\n    if (child == NULL)\n    {\n        /* list is empty, start new one */\n        array->child = item;\n        item->prev = item;\n        item->next = NULL;\n    }\n    else\n    {\n        /* append to the end */\n        if (child->prev)\n        {\n            suffix_object(child->prev, item);\n            array->child->prev = item;\n        }\n    }\n\n    return true;\n}\n\n/* Add item to array/object. */\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item)\n{\n    return add_item_to_array(array, item);\n}\n\n#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))\n    #pragma GCC diagnostic push\n#endif\n#ifdef __GNUC__\n#pragma GCC diagnostic ignored \"-Wcast-qual\"\n#endif\n/* helper function to cast away const */\nstatic void* cast_away_const(const void* string)\n{\n    return (void*)string;\n}\n#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))\n    #pragma GCC diagnostic pop\n#endif\n\n\nstatic cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)\n{\n    char *new_key = NULL;\n    int new_type = cJSON_Invalid;\n\n    if ((object == NULL) || (string == NULL) || (item == NULL) || (object == item))\n    {\n        return false;\n    }\n\n    if (constant_key)\n    {\n        new_key = (char*)cast_away_const(string);\n        new_type = item->type | cJSON_StringIsConst;\n    }\n    else\n    {\n        new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);\n        if (new_key == NULL)\n        {\n            return false;\n        }\n\n        new_type = item->type & ~cJSON_StringIsConst;\n    }\n\n    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))\n    {\n        hooks->deallocate(item->string);\n    }\n\n    item->string = new_key;\n    item->type = new_type;\n\n    return add_item_to_array(object, item);\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)\n{\n    return add_item_to_object(object, string, item, &global_hooks, false);\n}\n\n/* Add an item to an object with constant string as key */\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)\n{\n    return add_item_to_object(object, string, item, &global_hooks, true);\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)\n{\n    if (array == NULL)\n    {\n        return false;\n    }\n\n    return add_item_to_array(array, create_reference(item, &global_hooks));\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)\n{\n    if ((object == NULL) || (string == NULL))\n    {\n        return false;\n    }\n\n    return add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name)\n{\n    cJSON *null = cJSON_CreateNull();\n    if (add_item_to_object(object, name, null, &global_hooks, false))\n    {\n        return null;\n    }\n\n    cJSON_Delete(null);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name)\n{\n    cJSON *true_item = cJSON_CreateTrue();\n    if (add_item_to_object(object, name, true_item, &global_hooks, false))\n    {\n        return true_item;\n    }\n\n    cJSON_Delete(true_item);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name)\n{\n    cJSON *false_item = cJSON_CreateFalse();\n    if (add_item_to_object(object, name, false_item, &global_hooks, false))\n    {\n        return false_item;\n    }\n\n    cJSON_Delete(false_item);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)\n{\n    cJSON *bool_item = cJSON_CreateBool(boolean);\n    if (add_item_to_object(object, name, bool_item, &global_hooks, false))\n    {\n        return bool_item;\n    }\n\n    cJSON_Delete(bool_item);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)\n{\n    cJSON *number_item = cJSON_CreateNumber(number);\n    if (add_item_to_object(object, name, number_item, &global_hooks, false))\n    {\n        return number_item;\n    }\n\n    cJSON_Delete(number_item);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)\n{\n    cJSON *string_item = cJSON_CreateString(string);\n    if (add_item_to_object(object, name, string_item, &global_hooks, false))\n    {\n        return string_item;\n    }\n\n    cJSON_Delete(string_item);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)\n{\n    cJSON *raw_item = cJSON_CreateRaw(raw);\n    if (add_item_to_object(object, name, raw_item, &global_hooks, false))\n    {\n        return raw_item;\n    }\n\n    cJSON_Delete(raw_item);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name)\n{\n    cJSON *object_item = cJSON_CreateObject();\n    if (add_item_to_object(object, name, object_item, &global_hooks, false))\n    {\n        return object_item;\n    }\n\n    cJSON_Delete(object_item);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)\n{\n    cJSON *array = cJSON_CreateArray();\n    if (add_item_to_object(object, name, array, &global_hooks, false))\n    {\n        return array;\n    }\n\n    cJSON_Delete(array);\n    return NULL;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)\n{\n    if ((parent == NULL) || (item == NULL) || (item != parent->child && item->prev == NULL))\n    {\n        return NULL;\n    }\n\n    if (item != parent->child)\n    {\n        /* not the first element */\n        item->prev->next = item->next;\n    }\n    if (item->next != NULL)\n    {\n        /* not the last element */\n        item->next->prev = item->prev;\n    }\n\n    if (item == parent->child)\n    {\n        /* first element */\n        parent->child = item->next;\n    }\n    else if (item->next == NULL)\n    {\n        /* last element */\n        parent->child->prev = item->prev;\n    }\n\n    /* make sure the detached item doesn't point anywhere anymore */\n    item->prev = NULL;\n    item->next = NULL;\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)\n{\n    if (which < 0)\n    {\n        return NULL;\n    }\n\n    return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));\n}\n\nCJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)\n{\n    cJSON_Delete(cJSON_DetachItemFromArray(array, which));\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)\n{\n    cJSON *to_detach = cJSON_GetObjectItem(object, string);\n\n    return cJSON_DetachItemViaPointer(object, to_detach);\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)\n{\n    cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);\n\n    return cJSON_DetachItemViaPointer(object, to_detach);\n}\n\nCJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)\n{\n    cJSON_Delete(cJSON_DetachItemFromObject(object, string));\n}\n\nCJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)\n{\n    cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));\n}\n\n/* Replace array/object items with new ones. */\nCJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)\n{\n    cJSON *after_inserted = NULL;\n\n    if (which < 0 || newitem == NULL)\n    {\n        return false;\n    }\n\n    after_inserted = get_array_item(array, (size_t)which);\n    if (after_inserted == NULL)\n    {\n        return add_item_to_array(array, newitem);\n    }\n\n    if (after_inserted != array->child && after_inserted->prev == NULL) {\n        /* return false if after_inserted is a corrupted array item */\n        return false;\n    }\n\n    newitem->next = after_inserted;\n    newitem->prev = after_inserted->prev;\n    after_inserted->prev = newitem;\n    if (after_inserted == array->child)\n    {\n        array->child = newitem;\n    }\n    else\n    {\n        newitem->prev->next = newitem;\n    }\n    return true;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)\n{\n    if ((parent == NULL) || (parent->child == NULL) || (replacement == NULL) || (item == NULL))\n    {\n        return false;\n    }\n\n    if (replacement == item)\n    {\n        return true;\n    }\n\n    replacement->next = item->next;\n    replacement->prev = item->prev;\n\n    if (replacement->next != NULL)\n    {\n        replacement->next->prev = replacement;\n    }\n    if (parent->child == item)\n    {\n        if (parent->child->prev == parent->child)\n        {\n            replacement->prev = replacement;\n        }\n        parent->child = replacement;\n    }\n    else\n    {   /*\n         * To find the last item in array quickly, we use prev in array.\n         * We can't modify the last item's next pointer where this item was the parent's child\n         */\n        if (replacement->prev != NULL)\n        {\n            replacement->prev->next = replacement;\n        }\n        if (replacement->next == NULL)\n        {\n            parent->child->prev = replacement;\n        }\n    }\n\n    item->next = NULL;\n    item->prev = NULL;\n    cJSON_Delete(item);\n\n    return true;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)\n{\n    if (which < 0)\n    {\n        return false;\n    }\n\n    return cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);\n}\n\nstatic cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)\n{\n    if ((replacement == NULL) || (string == NULL))\n    {\n        return false;\n    }\n\n    /* replace the name in the replacement */\n    if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))\n    {\n        cJSON_free(replacement->string);\n    }\n    replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);\n    if (replacement->string == NULL)\n    {\n        return false;\n    }\n\n    replacement->type &= ~cJSON_StringIsConst;\n\n    return cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)\n{\n    return replace_item_in_object(object, string, newitem, false);\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)\n{\n    return replace_item_in_object(object, string, newitem, true);\n}\n\n/* Create basic types: */\nCJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_NULL;\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_True;\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_False;\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = boolean ? cJSON_True : cJSON_False;\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_Number;\n        item->valuedouble = num;\n\n        /* use saturation in case of overflow */\n        if (num >= INT_MAX)\n        {\n            item->valueint = INT_MAX;\n        }\n        else if (num <= (double)INT_MIN)\n        {\n            item->valueint = INT_MIN;\n        }\n        else\n        {\n            item->valueint = (int)num;\n        }\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_String;\n        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);\n        if(!item->valuestring)\n        {\n            cJSON_Delete(item);\n            return NULL;\n        }\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if (item != NULL)\n    {\n        item->type = cJSON_String | cJSON_IsReference;\n        item->valuestring = (char*)cast_away_const(string);\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if (item != NULL) {\n        item->type = cJSON_Object | cJSON_IsReference;\n        item->child = (cJSON*)cast_away_const(child);\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child) {\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if (item != NULL) {\n        item->type = cJSON_Array | cJSON_IsReference;\n        item->child = (cJSON*)cast_away_const(child);\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_Raw;\n        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);\n        if(!item->valuestring)\n        {\n            cJSON_Delete(item);\n            return NULL;\n        }\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type=cJSON_Array;\n    }\n\n    return item;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if (item)\n    {\n        item->type = cJSON_Object;\n    }\n\n    return item;\n}\n\n/* Create Arrays: */\nCJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for(i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber(numbers[i]);\n        if (!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    if (a && a->child) {\n        a->child->prev = n;\n    }\n\n    return a;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for(i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber((double)numbers[i]);\n        if(!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    if (a && a->child) {\n        a->child->prev = n;\n    }\n\n    return a;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for(i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber(numbers[i]);\n        if(!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    if (a && a->child) {\n        a->child->prev = n;\n    }\n\n    return a;\n}\n\nCJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (strings == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for (i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateString(strings[i]);\n        if(!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p,n);\n        }\n        p = n;\n    }\n\n    if (a && a->child) {\n        a->child->prev = n;\n    }\n\n    return a;\n}\n\n/* Duplication */\ncJSON * cJSON_Duplicate_rec(const cJSON *item, size_t depth, cJSON_bool recurse);\n\nCJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)\n{\n    return cJSON_Duplicate_rec(item, 0, recurse );\n}\n\ncJSON * cJSON_Duplicate_rec(const cJSON *item, size_t depth, cJSON_bool recurse)\n{\n    cJSON *newitem = NULL;\n    cJSON *child = NULL;\n    cJSON *next = NULL;\n    cJSON *newchild = NULL;\n\n    /* Bail on bad ptr */\n    if (!item)\n    {\n        goto fail;\n    }\n    /* Create new item */\n    newitem = cJSON_New_Item(&global_hooks);\n    if (!newitem)\n    {\n        goto fail;\n    }\n    /* Copy over all vars */\n    newitem->type = item->type & (~cJSON_IsReference);\n    newitem->valueint = item->valueint;\n    newitem->valuedouble = item->valuedouble;\n    if (item->valuestring)\n    {\n        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);\n        if (!newitem->valuestring)\n        {\n            goto fail;\n        }\n    }\n    if (item->string)\n    {\n        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);\n        if (!newitem->string)\n        {\n            goto fail;\n        }\n    }\n    /* If non-recursive, then we're done! */\n    if (!recurse)\n    {\n        return newitem;\n    }\n    /* Walk the ->next chain for the child. */\n    child = item->child;\n    while (child != NULL)\n    {\n        if(depth >= CJSON_CIRCULAR_LIMIT) {\n            goto fail;\n        }\n        newchild = cJSON_Duplicate_rec(child, depth + 1, true); /* Duplicate (with recurse) each item in the ->next chain */\n        if (!newchild)\n        {\n            goto fail;\n        }\n        if (next != NULL)\n        {\n            /* If newitem->child already set, then crosswire ->prev and ->next and move on */\n            next->next = newchild;\n            newchild->prev = next;\n            next = newchild;\n        }\n        else\n        {\n            /* Set newitem->child and move to it */\n            newitem->child = newchild;\n            next = newchild;\n        }\n        child = child->next;\n    }\n    if (newitem && newitem->child)\n    {\n        newitem->child->prev = newchild;\n    }\n\n    return newitem;\n\nfail:\n    if (newitem != NULL)\n    {\n        cJSON_Delete(newitem);\n    }\n\n    return NULL;\n}\n\nstatic void skip_oneline_comment(char **input)\n{\n    *input += static_strlen(\"//\");\n\n    for (; (*input)[0] != '\\0'; ++(*input))\n    {\n        if ((*input)[0] == '\\n') {\n            *input += static_strlen(\"\\n\");\n            return;\n        }\n    }\n}\n\nstatic void skip_multiline_comment(char **input)\n{\n    *input += static_strlen(\"/*\");\n\n    for (; (*input)[0] != '\\0'; ++(*input))\n    {\n        if (((*input)[0] == '*') && ((*input)[1] == '/'))\n        {\n            *input += static_strlen(\"*/\");\n            return;\n        }\n    }\n}\n\nstatic void minify_string(char **input, char **output) {\n    (*output)[0] = (*input)[0];\n    *input += static_strlen(\"\\\"\");\n    *output += static_strlen(\"\\\"\");\n\n\n    for (; (*input)[0] != '\\0'; (void)++(*input), ++(*output)) {\n        (*output)[0] = (*input)[0];\n\n        if ((*input)[0] == '\\\"') {\n            (*output)[0] = '\\\"';\n            *input += static_strlen(\"\\\"\");\n            *output += static_strlen(\"\\\"\");\n            return;\n        } else if (((*input)[0] == '\\\\') && ((*input)[1] == '\\\"')) {\n            (*output)[1] = (*input)[1];\n            *input += static_strlen(\"\\\"\");\n            *output += static_strlen(\"\\\"\");\n        }\n    }\n}\n\nCJSON_PUBLIC(void) cJSON_Minify(char *json)\n{\n    char *into = json;\n\n    if (json == NULL)\n    {\n        return;\n    }\n\n    while (json[0] != '\\0')\n    {\n        switch (json[0])\n        {\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n                json++;\n                break;\n\n            case '/':\n                if (json[1] == '/')\n                {\n                    skip_oneline_comment(&json);\n                }\n                else if (json[1] == '*')\n                {\n                    skip_multiline_comment(&json);\n                } else {\n                    json++;\n                }\n                break;\n\n            case '\\\"':\n                minify_string(&json, (char**)&into);\n                break;\n\n            default:\n                into[0] = json[0];\n                json++;\n                into++;\n        }\n    }\n\n    /* and null-terminate. */\n    *into = '\\0';\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Invalid;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_False;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xff) == cJSON_True;\n}\n\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & (cJSON_True | cJSON_False)) != 0;\n}\nCJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_NULL;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Number;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_String;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Array;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Object;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Raw;\n}\n\nCJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)\n{\n    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)))\n    {\n        return false;\n    }\n\n    /* check if type is valid */\n    switch (a->type & 0xFF)\n    {\n        case cJSON_False:\n        case cJSON_True:\n        case cJSON_NULL:\n        case cJSON_Number:\n        case cJSON_String:\n        case cJSON_Raw:\n        case cJSON_Array:\n        case cJSON_Object:\n            break;\n\n        default:\n            return false;\n    }\n\n    /* identical objects are equal */\n    if (a == b)\n    {\n        return true;\n    }\n\n    switch (a->type & 0xFF)\n    {\n        /* in these cases and equal type is enough */\n        case cJSON_False:\n        case cJSON_True:\n        case cJSON_NULL:\n            return true;\n\n        case cJSON_Number:\n            if (compare_double(a->valuedouble, b->valuedouble))\n            {\n                return true;\n            }\n            return false;\n\n        case cJSON_String:\n        case cJSON_Raw:\n            if ((a->valuestring == NULL) || (b->valuestring == NULL))\n            {\n                return false;\n            }\n            if (strcmp(a->valuestring, b->valuestring) == 0)\n            {\n                return true;\n            }\n\n            return false;\n\n        case cJSON_Array:\n        {\n            cJSON *a_element = a->child;\n            cJSON *b_element = b->child;\n\n            for (; (a_element != NULL) && (b_element != NULL);)\n            {\n                if (!cJSON_Compare(a_element, b_element, case_sensitive))\n                {\n                    return false;\n                }\n\n                a_element = a_element->next;\n                b_element = b_element->next;\n            }\n\n            /* one of the arrays is longer than the other */\n            if (a_element != b_element) {\n                return false;\n            }\n\n            return true;\n        }\n\n        case cJSON_Object:\n        {\n            cJSON *a_element = NULL;\n            cJSON *b_element = NULL;\n            cJSON_ArrayForEach(a_element, a)\n            {\n                /* TODO This has O(n^2) runtime, which is horrible! */\n                b_element = get_object_item(b, a_element->string, case_sensitive);\n                if (b_element == NULL)\n                {\n                    return false;\n                }\n\n                if (!cJSON_Compare(a_element, b_element, case_sensitive))\n                {\n                    return false;\n                }\n            }\n\n            /* doing this twice, once on a and b to prevent true comparison if a subset of b\n             * TODO: Do this the proper way, this is just a fix for now */\n            cJSON_ArrayForEach(b_element, b)\n            {\n                a_element = get_object_item(a, b_element->string, case_sensitive);\n                if (a_element == NULL)\n                {\n                    return false;\n                }\n\n                if (!cJSON_Compare(b_element, a_element, case_sensitive))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        default:\n            return false;\n    }\n}\n\nCJSON_PUBLIC(void *) cJSON_malloc(size_t size)\n{\n    return global_hooks.allocate(size);\n}\n\nCJSON_PUBLIC(void) cJSON_free(void *object)\n{\n    global_hooks.deallocate(object);\n    object = NULL;\n}\n"
        },
        {
          "name": "cJSON.h",
          "type": "blob",
          "size": 16.009765625,
          "content": "/*\n  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n#ifndef cJSON__h\n#define cJSON__h\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n#if !defined(__WINDOWS__) && (defined(WIN32) || defined(WIN64) || defined(_MSC_VER) || defined(_WIN32))\n#define __WINDOWS__\n#endif\n\n#ifdef __WINDOWS__\n\n/* When compiling for windows, we specify a specific calling convention to avoid issues where we are being called from a project with a different default calling convention.  For windows you have 3 define options:\n\nCJSON_HIDE_SYMBOLS - Define this in the case where you don't want to ever dllexport symbols\nCJSON_EXPORT_SYMBOLS - Define this on library build when you want to dllexport symbols (default)\nCJSON_IMPORT_SYMBOLS - Define this if you want to dllimport symbol\n\nFor *nix builds that support visibility attribute, you can define similar behavior by\n\nsetting default visibility to hidden by adding\n-fvisibility=hidden (for gcc)\nor\n-xldscope=hidden (for sun cc)\nto CFLAGS\n\nthen using the CJSON_API_VISIBILITY flag to \"export\" the same symbols the way CJSON_EXPORT_SYMBOLS does\n\n*/\n\n#define CJSON_CDECL __cdecl\n#define CJSON_STDCALL __stdcall\n\n/* export symbols by default, this is necessary for copy pasting the C and header file */\n#if !defined(CJSON_HIDE_SYMBOLS) && !defined(CJSON_IMPORT_SYMBOLS) && !defined(CJSON_EXPORT_SYMBOLS)\n#define CJSON_EXPORT_SYMBOLS\n#endif\n\n#if defined(CJSON_HIDE_SYMBOLS)\n#define CJSON_PUBLIC(type)   type CJSON_STDCALL\n#elif defined(CJSON_EXPORT_SYMBOLS)\n#define CJSON_PUBLIC(type)   __declspec(dllexport) type CJSON_STDCALL\n#elif defined(CJSON_IMPORT_SYMBOLS)\n#define CJSON_PUBLIC(type)   __declspec(dllimport) type CJSON_STDCALL\n#endif\n#else /* !__WINDOWS__ */\n#define CJSON_CDECL\n#define CJSON_STDCALL\n\n#if (defined(__GNUC__) || defined(__SUNPRO_CC) || defined (__SUNPRO_C)) && defined(CJSON_API_VISIBILITY)\n#define CJSON_PUBLIC(type)   __attribute__((visibility(\"default\"))) type\n#else\n#define CJSON_PUBLIC(type) type\n#endif\n#endif\n\n/* project version */\n#define CJSON_VERSION_MAJOR 1\n#define CJSON_VERSION_MINOR 7\n#define CJSON_VERSION_PATCH 18\n\n#include <stddef.h>\n\n/* cJSON Types: */\n#define cJSON_Invalid (0)\n#define cJSON_False  (1 << 0)\n#define cJSON_True   (1 << 1)\n#define cJSON_NULL   (1 << 2)\n#define cJSON_Number (1 << 3)\n#define cJSON_String (1 << 4)\n#define cJSON_Array  (1 << 5)\n#define cJSON_Object (1 << 6)\n#define cJSON_Raw    (1 << 7) /* raw json */\n\n#define cJSON_IsReference 256\n#define cJSON_StringIsConst 512\n\n/* The cJSON structure: */\ntypedef struct cJSON\n{\n    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */\n    struct cJSON *next;\n    struct cJSON *prev;\n    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */\n    struct cJSON *child;\n\n    /* The type of the item, as above. */\n    int type;\n\n    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */\n    char *valuestring;\n    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */\n    int valueint;\n    /* The item's number, if type==cJSON_Number */\n    double valuedouble;\n\n    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */\n    char *string;\n} cJSON;\n\ntypedef struct cJSON_Hooks\n{\n      /* malloc/free are CDECL on Windows regardless of the default calling convention of the compiler, so ensure the hooks allow passing those functions directly. */\n      void *(CJSON_CDECL *malloc_fn)(size_t sz);\n      void (CJSON_CDECL *free_fn)(void *ptr);\n} cJSON_Hooks;\n\ntypedef int cJSON_bool;\n\n/* Limits how deeply nested arrays/objects can be before cJSON rejects to parse them.\n * This is to prevent stack overflows. */\n#ifndef CJSON_NESTING_LIMIT\n#define CJSON_NESTING_LIMIT 1000\n#endif\n\n/* Limits the length of circular references can be before cJSON rejects to parse them.\n * This is to prevent stack overflows. */\n#ifndef CJSON_CIRCULAR_LIMIT\n#define CJSON_CIRCULAR_LIMIT 10000\n#endif\n\n/* returns the version of cJSON as a string */\nCJSON_PUBLIC(const char*) cJSON_Version(void);\n\n/* Supply malloc, realloc and free functions to cJSON */\nCJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks);\n\n/* Memory Management: the caller is always responsible to free the results from all variants of cJSON_Parse (with cJSON_Delete) and cJSON_Print (with stdlib free, cJSON_Hooks.free_fn, or cJSON_free as appropriate). The exception is cJSON_PrintPreallocated, where the caller has full responsibility of the buffer. */\n/* Supply a block of JSON, and this returns a cJSON object you can interrogate. */\nCJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value);\nCJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length);\n/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */\n/* If you supply a ptr in return_parse_end and parsing fails, then return_parse_end will contain a pointer to the error so will match cJSON_GetErrorPtr(). */\nCJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);\nCJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated);\n\n/* Render a cJSON entity to text for transfer/storage. */\nCJSON_PUBLIC(char *) cJSON_Print(const cJSON *item);\n/* Render a cJSON entity to text for transfer/storage without any formatting. */\nCJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item);\n/* Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted */\nCJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt);\n/* Render a cJSON entity to text using a buffer already allocated in memory with given length. Returns 1 on success and 0 on failure. */\n/* NOTE: cJSON is not always 100% accurate in estimating how much memory it will use, so to be safe allocate 5 bytes more than you actually need */\nCJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format);\n/* Delete a cJSON entity and all subentities. */\nCJSON_PUBLIC(void) cJSON_Delete(cJSON *item);\n\n/* Returns the number of items in an array (or object). */\nCJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array);\n/* Retrieve item number \"index\" from array \"array\". Returns NULL if unsuccessful. */\nCJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);\n/* Get item \"string\" from object. Case insensitive. */\nCJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string);\nCJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string);\nCJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string);\n/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */\nCJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void);\n\n/* Check item type and return its value */\nCJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item);\nCJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item);\n\n/* These functions check the type of an item */\nCJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item);\nCJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item);\n\n/* These calls create a cJSON item of the appropriate type. */\nCJSON_PUBLIC(cJSON *) cJSON_CreateNull(void);\nCJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void);\nCJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void);\nCJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean);\nCJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num);\nCJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string);\n/* raw json */\nCJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw);\nCJSON_PUBLIC(cJSON *) cJSON_CreateArray(void);\nCJSON_PUBLIC(cJSON *) cJSON_CreateObject(void);\n\n/* Create a string where valuestring references a string so\n * it will not be freed by cJSON_Delete */\nCJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string);\n/* Create an object/array that only references it's elements so\n * they will not be freed by cJSON_Delete */\nCJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child);\nCJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child);\n\n/* These utilities create an Array of count items.\n * The parameter count cannot be greater than the number of elements in the number array, otherwise array access will be out of bounds.*/\nCJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count);\nCJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count);\nCJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count);\nCJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count);\n\n/* Append item to the specified array/object. */\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item);\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);\n/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object.\n * WARNING: When this function was used, make sure to always check that (item->type & cJSON_StringIsConst) is zero before\n * writing to `item->string` */\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item);\n/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);\nCJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item);\n\n/* Remove/Detach items from Arrays/Objects. */\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item);\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which);\nCJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which);\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string);\nCJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string);\nCJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string);\nCJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string);\n\n/* Update array items. */\nCJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem); /* Shifts pre-existing items to the right. */\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement);\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem);\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);\nCJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object,const char *string,cJSON *newitem);\n\n/* Duplicate a cJSON item */\nCJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse);\n/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will\n * need to be released. With recurse!=0, it will duplicate any children connected to the item.\n * The item->next and ->prev pointers are always zero on return from Duplicate. */\n/* Recursively compare two cJSON items for equality. If either a or b is NULL or invalid, they will be considered unequal.\n * case_sensitive determines if object keys are treated case sensitive (1) or case insensitive (0) */\nCJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive);\n\n/* Minify a strings, remove blank characters(such as ' ', '\\t', '\\r', '\\n') from strings.\n * The input pointer json cannot point to a read-only address area, such as a string constant, \n * but should point to a readable and writable address area. */\nCJSON_PUBLIC(void) cJSON_Minify(char *json);\n\n/* Helper functions for creating and adding items to an object at the same time.\n * They return the added item or NULL on failure. */\nCJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name);\nCJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name);\nCJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name);\nCJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);\nCJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);\nCJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);\nCJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw);\nCJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name);\nCJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name);\n\n/* When assigning an integer value, it needs to be propagated to valuedouble too. */\n#define cJSON_SetIntValue(object, number) ((object) ? (object)->valueint = (object)->valuedouble = (number) : (number))\n/* helper for the cJSON_SetNumberValue macro */\nCJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number);\n#define cJSON_SetNumberValue(object, number) ((object != NULL) ? cJSON_SetNumberHelper(object, (double)number) : (number))\n/* Change the valuestring of a cJSON_String object, only takes effect when type of object is cJSON_String */\nCJSON_PUBLIC(char*) cJSON_SetValuestring(cJSON *object, const char *valuestring);\n\n/* If the object is not a boolean type this does nothing and returns cJSON_Invalid else it returns the new type*/\n#define cJSON_SetBoolValue(object, boolValue) ( \\\n    (object != NULL && ((object)->type & (cJSON_False|cJSON_True))) ? \\\n    (object)->type=((object)->type &(~(cJSON_False|cJSON_True)))|((boolValue)?cJSON_True:cJSON_False) : \\\n    cJSON_Invalid\\\n)\n\n/* Macro for iterating over an array or object */\n#define cJSON_ArrayForEach(element, array) for(element = (array != NULL) ? (array)->child : NULL; element != NULL; element = element->next)\n\n/* malloc/free objects using the malloc/free functions that have been set with cJSON_InitHooks */\nCJSON_PUBLIC(void *) cJSON_malloc(size_t size);\nCJSON_PUBLIC(void) cJSON_free(void *object);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "cJSON_Utils.c",
          "type": "blob",
          "size": 39.7744140625,
          "content": "/*\n  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n/* disable warnings about old C89 functions in MSVC */\n#if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#ifdef __GNUCC__\n#pragma GCC visibility push(default)\n#endif\n#if defined(_MSC_VER)\n#pragma warning (push)\n/* disable warning about single line comments in system headers */\n#pragma warning (disable : 4001)\n#endif\n\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <math.h>\n\n#if defined(_MSC_VER)\n#pragma warning (pop)\n#endif\n#ifdef __GNUCC__\n#pragma GCC visibility pop\n#endif\n\n#include \"cJSON_Utils.h\"\n\n/* define our own boolean type */\n#ifdef true\n#undef true\n#endif\n#define true ((cJSON_bool)1)\n\n#ifdef false\n#undef false\n#endif\n#define false ((cJSON_bool)0)\n\nstatic unsigned char* cJSONUtils_strdup(const unsigned char* const string)\n{\n    size_t length = 0;\n    unsigned char *copy = NULL;\n\n    length = strlen((const char*)string) + sizeof(\"\");\n    copy = (unsigned char*) cJSON_malloc(length);\n    if (copy == NULL)\n    {\n        return NULL;\n    }\n    memcpy(copy, string, length);\n\n    return copy;\n}\n\n/* string comparison which doesn't consider NULL pointers equal */\nstatic int compare_strings(const unsigned char *string1, const unsigned char *string2, const cJSON_bool case_sensitive)\n{\n    if ((string1 == NULL) || (string2 == NULL))\n    {\n        return 1;\n    }\n\n    if (string1 == string2)\n    {\n        return 0;\n    }\n\n    if (case_sensitive)\n    {\n        return strcmp((const char*)string1, (const char*)string2);\n    }\n\n    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)\n    {\n        if (*string1 == '\\0')\n        {\n            return 0;\n        }\n    }\n\n    return tolower(*string1) - tolower(*string2);\n}\n\n/* securely comparison of floating-point variables */\nstatic cJSON_bool compare_double(double a, double b)\n{\n    double maxVal = fabs(a) > fabs(b) ? fabs(a) : fabs(b);\n    return (fabs(a - b) <= maxVal * DBL_EPSILON);\n}\n\n\n/* Compare the next path element of two JSON pointers, two NULL pointers are considered unequal: */\nstatic cJSON_bool compare_pointers(const unsigned char *name, const unsigned char *pointer, const cJSON_bool case_sensitive)\n{\n    if ((name == NULL) || (pointer == NULL))\n    {\n        return false;\n    }\n\n    for (; (*name != '\\0') && (*pointer != '\\0') && (*pointer != '/'); (void)name++, pointer++) /* compare until next '/' */\n    {\n        if (*pointer == '~')\n        {\n            /* check for escaped '~' (~0) and '/' (~1) */\n            if (((pointer[1] != '0') || (*name != '~')) && ((pointer[1] != '1') || (*name != '/')))\n            {\n                /* invalid escape sequence or wrong character in *name */\n                return false;\n            }\n            else\n            {\n                pointer++;\n            }\n        }\n        else if ((!case_sensitive && (tolower(*name) != tolower(*pointer))) || (case_sensitive && (*name != *pointer)))\n        {\n            return false;\n        }\n    }\n    if (((*pointer != 0) && (*pointer != '/')) != (*name != 0))\n    {\n        /* one string has ended, the other not */\n        return false;;\n    }\n\n    return true;\n}\n\n/* calculate the length of a string if encoded as JSON pointer with ~0 and ~1 escape sequences */\nstatic size_t pointer_encoded_length(const unsigned char *string)\n{\n    size_t length;\n    for (length = 0; *string != '\\0'; (void)string++, length++)\n    {\n        /* character needs to be escaped? */\n        if ((*string == '~') || (*string == '/'))\n        {\n            length++;\n        }\n    }\n\n    return length;\n}\n\n/* copy a string while escaping '~' and '/' with ~0 and ~1 JSON pointer escape codes */\nstatic void encode_string_as_pointer(unsigned char *destination, const unsigned char *source)\n{\n    for (; source[0] != '\\0'; (void)source++, destination++)\n    {\n        if (source[0] == '/')\n        {\n            destination[0] = '~';\n            destination[1] = '1';\n            destination++;\n        }\n        else if (source[0] == '~')\n        {\n            destination[0] = '~';\n            destination[1] = '0';\n            destination++;\n        }\n        else\n        {\n            destination[0] = source[0];\n        }\n    }\n\n    destination[0] = '\\0';\n}\n\nCJSON_PUBLIC(char *) cJSONUtils_FindPointerFromObjectTo(const cJSON * const object, const cJSON * const target)\n{\n    size_t child_index = 0;\n    cJSON *current_child = 0;\n\n    if ((object == NULL) || (target == NULL))\n    {\n        return NULL;\n    }\n\n    if (object == target)\n    {\n        /* found */\n        return (char*)cJSONUtils_strdup((const unsigned char*)\"\");\n    }\n\n    /* recursively search all children of the object or array */\n    for (current_child = object->child; current_child != NULL; (void)(current_child = current_child->next), child_index++)\n    {\n        unsigned char *target_pointer = (unsigned char*)cJSONUtils_FindPointerFromObjectTo(current_child, target);\n        /* found the target? */\n        if (target_pointer != NULL)\n        {\n            if (cJSON_IsArray(object))\n            {\n                /* reserve enough memory for a 64 bit integer + '/' and '\\0' */\n                unsigned char *full_pointer = (unsigned char*)cJSON_malloc(strlen((char*)target_pointer) + 20 + sizeof(\"/\"));\n                /* check if conversion to unsigned long is valid\n                 * This should be eliminated at compile time by dead code elimination\n                 * if size_t is an alias of unsigned long, or if it is bigger */\n                if (child_index > ULONG_MAX)\n                {\n                    cJSON_free(target_pointer);\n                    cJSON_free(full_pointer);\n                    return NULL;\n                }\n                sprintf((char*)full_pointer, \"/%lu%s\", (unsigned long)child_index, target_pointer); /* /<array_index><path> */\n                cJSON_free(target_pointer);\n\n                return (char*)full_pointer;\n            }\n\n            if (cJSON_IsObject(object))\n            {\n                unsigned char *full_pointer = (unsigned char*)cJSON_malloc(strlen((char*)target_pointer) + pointer_encoded_length((unsigned char*)current_child->string) + 2);\n                full_pointer[0] = '/';\n                encode_string_as_pointer(full_pointer + 1, (unsigned char*)current_child->string);\n                strcat((char*)full_pointer, (char*)target_pointer);\n                cJSON_free(target_pointer);\n\n                return (char*)full_pointer;\n            }\n\n            /* reached leaf of the tree, found nothing */\n            cJSON_free(target_pointer);\n            return NULL;\n        }\n    }\n\n    /* not found */\n    return NULL;\n}\n\n/* non broken version of cJSON_GetArrayItem */\nstatic cJSON *get_array_item(const cJSON *array, size_t item)\n{\n    cJSON *child = array ? array->child : NULL;\n    while ((child != NULL) && (item > 0))\n    {\n        item--;\n        child = child->next;\n    }\n\n    return child;\n}\n\nstatic cJSON_bool decode_array_index_from_pointer(const unsigned char * const pointer, size_t * const index)\n{\n    size_t parsed_index = 0;\n    size_t position = 0;\n\n    if ((pointer[0] == '0') && ((pointer[1] != '\\0') && (pointer[1] != '/')))\n    {\n        /* leading zeroes are not permitted */\n        return 0;\n    }\n\n    for (position = 0; (pointer[position] >= '0') && (pointer[0] <= '9'); position++)\n    {\n        parsed_index = (10 * parsed_index) + (size_t)(pointer[position] - '0');\n\n    }\n\n    if ((pointer[position] != '\\0') && (pointer[position] != '/'))\n    {\n        return 0;\n    }\n\n    *index = parsed_index;\n\n    return 1;\n}\n\nstatic cJSON *get_item_from_pointer(cJSON * const object, const char * pointer, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = object;\n\n    if (pointer == NULL)\n    {\n        return NULL;\n    }\n\n    /* follow path of the pointer */\n    while ((pointer[0] == '/') && (current_element != NULL))\n    {\n        pointer++;\n        if (cJSON_IsArray(current_element))\n        {\n            size_t index = 0;\n            if (!decode_array_index_from_pointer((const unsigned char*)pointer, &index))\n            {\n                return NULL;\n            }\n\n            current_element = get_array_item(current_element, index);\n        }\n        else if (cJSON_IsObject(current_element))\n        {\n            current_element = current_element->child;\n            /* GetObjectItem. */\n            while ((current_element != NULL) && !compare_pointers((unsigned char*)current_element->string, (const unsigned char*)pointer, case_sensitive))\n            {\n                current_element = current_element->next;\n            }\n        }\n        else\n        {\n            return NULL;\n        }\n\n        /* skip to the next path token or end of string */\n        while ((pointer[0] != '\\0') && (pointer[0] != '/'))\n        {\n            pointer++;\n        }\n    }\n\n    return current_element;\n}\n\nCJSON_PUBLIC(cJSON *) cJSONUtils_GetPointer(cJSON * const object, const char *pointer)\n{\n    return get_item_from_pointer(object, pointer, false);\n}\n\nCJSON_PUBLIC(cJSON *) cJSONUtils_GetPointerCaseSensitive(cJSON * const object, const char *pointer)\n{\n    return get_item_from_pointer(object, pointer, true);\n}\n\n/* JSON Patch implementation. */\nstatic void decode_pointer_inplace(unsigned char *string)\n{\n    unsigned char *decoded_string = string;\n\n    if (string == NULL) {\n        return;\n    }\n\n    for (; *string; (void)decoded_string++, string++)\n    {\n        if (string[0] == '~')\n        {\n            if (string[1] == '0')\n            {\n                decoded_string[0] = '~';\n            }\n            else if (string[1] == '1')\n            {\n                decoded_string[1] = '/';\n            }\n            else\n            {\n                /* invalid escape sequence */\n                return;\n            }\n\n            string++;\n        }\n    }\n\n    decoded_string[0] = '\\0';\n}\n\n/* non-broken cJSON_DetachItemFromArray */\nstatic cJSON *detach_item_from_array(cJSON *array, size_t which)\n{\n    cJSON *c = array->child;\n    while (c && (which > 0))\n    {\n        c = c->next;\n        which--;\n    }\n    if (!c)\n    {\n        /* item doesn't exist */\n        return NULL;\n    }\n    if (c != array->child)\n    {\n        /* not the first element */\n        c->prev->next = c->next;\n    }\n    if (c->next)\n    {\n        c->next->prev = c->prev;\n    }\n    if (c == array->child)\n    {\n        array->child = c->next;\n    }\n    else if (c->next == NULL)\n    {\n        array->child->prev = c->prev;\n    }\n    /* make sure the detached item doesn't point anywhere anymore */\n    c->prev = c->next = NULL;\n\n    return c;\n}\n\n/* detach an item at the given path */\nstatic cJSON *detach_path(cJSON *object, const unsigned char *path, const cJSON_bool case_sensitive)\n{\n    unsigned char *parent_pointer = NULL;\n    unsigned char *child_pointer = NULL;\n    cJSON *parent = NULL;\n    cJSON *detached_item = NULL;\n\n    /* copy path and split it in parent and child */\n    parent_pointer = cJSONUtils_strdup(path);\n    if (parent_pointer == NULL) {\n        goto cleanup;\n    }\n\n    child_pointer = (unsigned char*)strrchr((char*)parent_pointer, '/'); /* last '/' */\n    if (child_pointer == NULL)\n    {\n        goto cleanup;\n    }\n    /* split strings */\n    child_pointer[0] = '\\0';\n    child_pointer++;\n\n    parent = get_item_from_pointer(object, (char*)parent_pointer, case_sensitive);\n    decode_pointer_inplace(child_pointer);\n\n    if (cJSON_IsArray(parent))\n    {\n        size_t index = 0;\n        if (!decode_array_index_from_pointer(child_pointer, &index))\n        {\n            goto cleanup;\n        }\n        detached_item = detach_item_from_array(parent, index);\n    }\n    else if (cJSON_IsObject(parent))\n    {\n        detached_item = cJSON_DetachItemFromObject(parent, (char*)child_pointer);\n    }\n    else\n    {\n        /* Couldn't find object to remove child from. */\n        goto cleanup;\n    }\n\ncleanup:\n    if (parent_pointer != NULL)\n    {\n        cJSON_free(parent_pointer);\n    }\n\n    return detached_item;\n}\n\n/* sort lists using mergesort */\nstatic cJSON *sort_list(cJSON *list, const cJSON_bool case_sensitive)\n{\n    cJSON *first = list;\n    cJSON *second = list;\n    cJSON *current_item = list;\n    cJSON *result = list;\n    cJSON *result_tail = NULL;\n\n    if ((list == NULL) || (list->next == NULL))\n    {\n        /* One entry is sorted already. */\n        return result;\n    }\n\n    while ((current_item != NULL) && (current_item->next != NULL) && (compare_strings((unsigned char*)current_item->string, (unsigned char*)current_item->next->string, case_sensitive) < 0))\n    {\n        /* Test for list sorted. */\n        current_item = current_item->next;\n    }\n    if ((current_item == NULL) || (current_item->next == NULL))\n    {\n        /* Leave sorted lists unmodified. */\n        return result;\n    }\n\n    /* reset pointer to the beginning */\n    current_item = list;\n    while (current_item != NULL)\n    {\n        /* Walk two pointers to find the middle. */\n        second = second->next;\n        current_item = current_item->next;\n        /* advances current_item two steps at a time */\n        if (current_item != NULL)\n        {\n            current_item = current_item->next;\n        }\n    }\n    if ((second != NULL) && (second->prev != NULL))\n    {\n        /* Split the lists */\n        second->prev->next = NULL;\n        second->prev = NULL;\n    }\n\n    /* Recursively sort the sub-lists. */\n    first = sort_list(first, case_sensitive);\n    second = sort_list(second, case_sensitive);\n    result = NULL;\n\n    /* Merge the sub-lists */\n    while ((first != NULL) && (second != NULL))\n    {\n        cJSON *smaller = NULL;\n        if (compare_strings((unsigned char*)first->string, (unsigned char*)second->string, case_sensitive) < 0)\n        {\n            smaller = first;\n        }\n        else\n        {\n            smaller = second;\n        }\n\n        if (result == NULL)\n        {\n            /* start merged list with the smaller element */\n            result_tail = smaller;\n            result = smaller;\n        }\n        else\n        {\n            /* add smaller element to the list */\n            result_tail->next = smaller;\n            smaller->prev = result_tail;\n            result_tail = smaller;\n        }\n\n        if (first == smaller)\n        {\n            first = first->next;\n        }\n        else\n        {\n            second = second->next;\n        }\n    }\n\n    if (first != NULL)\n    {\n        /* Append rest of first list. */\n        if (result == NULL)\n        {\n            return first;\n        }\n        result_tail->next = first;\n        first->prev = result_tail;\n    }\n    if (second != NULL)\n    {\n        /* Append rest of second list */\n        if (result == NULL)\n        {\n            return second;\n        }\n        result_tail->next = second;\n        second->prev = result_tail;\n    }\n\n    return result;\n}\n\nstatic void sort_object(cJSON * const object, const cJSON_bool case_sensitive)\n{\n    if (object == NULL)\n    {\n        return;\n    }\n    object->child = sort_list(object->child, case_sensitive);\n}\n\nstatic cJSON_bool compare_json(cJSON *a, cJSON *b, const cJSON_bool case_sensitive)\n{\n    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)))\n    {\n        /* mismatched type. */\n        return false;\n    }\n    switch (a->type & 0xFF)\n    {\n        case cJSON_Number:\n            /* numeric mismatch. */\n            if ((a->valueint != b->valueint) || (!compare_double(a->valuedouble, b->valuedouble)))\n            {\n                return false;\n            }\n            else\n            {\n                return true;\n            }\n\n        case cJSON_String:\n            /* string mismatch. */\n            if (strcmp(a->valuestring, b->valuestring) != 0)\n            {\n                return false;\n            }\n            else\n            {\n                return true;\n            }\n\n        case cJSON_Array:\n            for ((void)(a = a->child), b = b->child; (a != NULL) && (b != NULL); (void)(a = a->next), b = b->next)\n            {\n                cJSON_bool identical = compare_json(a, b, case_sensitive);\n                if (!identical)\n                {\n                    return false;\n                }\n            }\n\n            /* array size mismatch? (one of both children is not NULL) */\n            if ((a != NULL) || (b != NULL))\n            {\n                return false;\n            }\n            else\n            {\n                return true;\n            }\n\n        case cJSON_Object:\n            sort_object(a, case_sensitive);\n            sort_object(b, case_sensitive);\n            for ((void)(a = a->child), b = b->child; (a != NULL) && (b != NULL); (void)(a = a->next), b = b->next)\n            {\n                cJSON_bool identical = false;\n                /* compare object keys */\n                if (compare_strings((unsigned char*)a->string, (unsigned char*)b->string, case_sensitive))\n                {\n                    /* missing member */\n                    return false;\n                }\n                identical = compare_json(a, b, case_sensitive);\n                if (!identical)\n                {\n                    return false;\n                }\n            }\n\n            /* object length mismatch (one of both children is not null) */\n            if ((a != NULL) || (b != NULL))\n            {\n                return false;\n            }\n            else\n            {\n                return true;\n            }\n\n        default:\n            break;\n    }\n\n    /* null, true or false */\n    return true;\n}\n\n/* non broken version of cJSON_InsertItemInArray */\nstatic cJSON_bool insert_item_in_array(cJSON *array, size_t which, cJSON *newitem)\n{\n    cJSON *child = array->child;\n    while (child && (which > 0))\n    {\n        child = child->next;\n        which--;\n    }\n    if (which > 0)\n    {\n        /* item is after the end of the array */\n        return 0;\n    }\n    if (child == NULL)\n    {\n        cJSON_AddItemToArray(array, newitem);\n        return 1;\n    }\n\n    /* insert into the linked list */\n    newitem->next = child;\n    newitem->prev = child->prev;\n    child->prev = newitem;\n\n    /* was it at the beginning */\n    if (child == array->child)\n    {\n        array->child = newitem;\n    }\n    else\n    {\n        newitem->prev->next = newitem;\n    }\n\n    return 1;\n}\n\nstatic cJSON *get_object_item(const cJSON * const object, const char* name, const cJSON_bool case_sensitive)\n{\n    if (case_sensitive)\n    {\n        return cJSON_GetObjectItemCaseSensitive(object, name);\n    }\n\n    return cJSON_GetObjectItem(object, name);\n}\n\nenum patch_operation { INVALID, ADD, REMOVE, REPLACE, MOVE, COPY, TEST };\n\nstatic enum patch_operation decode_patch_operation(const cJSON * const patch, const cJSON_bool case_sensitive)\n{\n    cJSON *operation = get_object_item(patch, \"op\", case_sensitive);\n    if (!cJSON_IsString(operation))\n    {\n        return INVALID;\n    }\n\n    if (strcmp(operation->valuestring, \"add\") == 0)\n    {\n        return ADD;\n    }\n\n    if (strcmp(operation->valuestring, \"remove\") == 0)\n    {\n        return REMOVE;\n    }\n\n    if (strcmp(operation->valuestring, \"replace\") == 0)\n    {\n        return REPLACE;\n    }\n\n    if (strcmp(operation->valuestring, \"move\") == 0)\n    {\n        return MOVE;\n    }\n\n    if (strcmp(operation->valuestring, \"copy\") == 0)\n    {\n        return COPY;\n    }\n\n    if (strcmp(operation->valuestring, \"test\") == 0)\n    {\n        return TEST;\n    }\n\n    return INVALID;\n}\n\n/* overwrite and existing item with another one and free resources on the way */\nstatic void overwrite_item(cJSON * const root, const cJSON replacement)\n{\n    if (root == NULL)\n    {\n        return;\n    }\n\n    if (root->string != NULL)\n    {\n        cJSON_free(root->string);\n    }\n    if (root->valuestring != NULL)\n    {\n        cJSON_free(root->valuestring);\n    }\n    if (root->child != NULL)\n    {\n        cJSON_Delete(root->child);\n    }\n\n    memcpy(root, &replacement, sizeof(cJSON));\n}\n\nstatic int apply_patch(cJSON *object, const cJSON *patch, const cJSON_bool case_sensitive)\n{\n    cJSON *path = NULL;\n    cJSON *value = NULL;\n    cJSON *parent = NULL;\n    enum patch_operation opcode = INVALID;\n    unsigned char *parent_pointer = NULL;\n    unsigned char *child_pointer = NULL;\n    int status = 0;\n\n    path = get_object_item(patch, \"path\", case_sensitive);\n    if (!cJSON_IsString(path))\n    {\n        /* malformed patch. */\n        status = 2;\n        goto cleanup;\n    }\n\n    opcode = decode_patch_operation(patch, case_sensitive);\n    if (opcode == INVALID)\n    {\n        status = 3;\n        goto cleanup;\n    }\n    else if (opcode == TEST)\n    {\n        /* compare value: {...} with the given path */\n        status = !compare_json(get_item_from_pointer(object, path->valuestring, case_sensitive), get_object_item(patch, \"value\", case_sensitive), case_sensitive);\n        goto cleanup;\n    }\n\n    /* special case for replacing the root */\n    if (path->valuestring[0] == '\\0')\n    {\n        if (opcode == REMOVE)\n        {\n            static const cJSON invalid = { NULL, NULL, NULL, cJSON_Invalid, NULL, 0, 0, NULL};\n\n            overwrite_item(object, invalid);\n\n            status = 0;\n            goto cleanup;\n        }\n\n        if ((opcode == REPLACE) || (opcode == ADD))\n        {\n            value = get_object_item(patch, \"value\", case_sensitive);\n            if (value == NULL)\n            {\n                /* missing \"value\" for add/replace. */\n                status = 7;\n                goto cleanup;\n            }\n\n            value = cJSON_Duplicate(value, 1);\n            if (value == NULL)\n            {\n                /* out of memory for add/replace. */\n                status = 8;\n                goto cleanup;\n            }\n\n            overwrite_item(object, *value);\n\n            /* delete the duplicated value */\n            cJSON_free(value);\n            value = NULL;\n\n            /* the string \"value\" isn't needed */\n            if (object->string != NULL)\n            {\n                cJSON_free(object->string);\n                object->string = NULL;\n            }\n\n            status = 0;\n            goto cleanup;\n        }\n    }\n\n    if ((opcode == REMOVE) || (opcode == REPLACE))\n    {\n        /* Get rid of old. */\n        cJSON *old_item = detach_path(object, (unsigned char*)path->valuestring, case_sensitive);\n        if (old_item == NULL)\n        {\n            status = 13;\n            goto cleanup;\n        }\n        cJSON_Delete(old_item);\n        if (opcode == REMOVE)\n        {\n            /* For Remove, this job is done. */\n            status = 0;\n            goto cleanup;\n        }\n    }\n\n    /* Copy/Move uses \"from\". */\n    if ((opcode == MOVE) || (opcode == COPY))\n    {\n        cJSON *from = get_object_item(patch, \"from\", case_sensitive);\n        if (from == NULL)\n        {\n            /* missing \"from\" for copy/move. */\n            status = 4;\n            goto cleanup;\n        }\n\n        if (opcode == MOVE)\n        {\n            value = detach_path(object, (unsigned char*)from->valuestring, case_sensitive);\n        }\n        if (opcode == COPY)\n        {\n            value = get_item_from_pointer(object, from->valuestring, case_sensitive);\n        }\n        if (value == NULL)\n        {\n            /* missing \"from\" for copy/move. */\n            status = 5;\n            goto cleanup;\n        }\n        if (opcode == COPY)\n        {\n            value = cJSON_Duplicate(value, 1);\n        }\n        if (value == NULL)\n        {\n            /* out of memory for copy/move. */\n            status = 6;\n            goto cleanup;\n        }\n    }\n    else /* Add/Replace uses \"value\". */\n    {\n        value = get_object_item(patch, \"value\", case_sensitive);\n        if (value == NULL)\n        {\n            /* missing \"value\" for add/replace. */\n            status = 7;\n            goto cleanup;\n        }\n        value = cJSON_Duplicate(value, 1);\n        if (value == NULL)\n        {\n            /* out of memory for add/replace. */\n            status = 8;\n            goto cleanup;\n        }\n    }\n\n    /* Now, just add \"value\" to \"path\". */\n\n    /* split pointer in parent and child */\n    parent_pointer = cJSONUtils_strdup((unsigned char*)path->valuestring);\n    if (parent_pointer) {\n        child_pointer = (unsigned char*)strrchr((char*)parent_pointer, '/');\n    }\n    if (child_pointer != NULL)\n    {\n        child_pointer[0] = '\\0';\n        child_pointer++;\n    }\n    parent = get_item_from_pointer(object, (char*)parent_pointer, case_sensitive);\n    decode_pointer_inplace(child_pointer);\n\n    /* add, remove, replace, move, copy, test. */\n    if ((parent == NULL) || (child_pointer == NULL))\n    {\n        /* Couldn't find object to add to. */\n        status = 9;\n        goto cleanup;\n    }\n    else if (cJSON_IsArray(parent))\n    {\n        if (strcmp((char*)child_pointer, \"-\") == 0)\n        {\n            cJSON_AddItemToArray(parent, value);\n            value = NULL;\n        }\n        else\n        {\n            size_t index = 0;\n            if (!decode_array_index_from_pointer(child_pointer, &index))\n            {\n                status = 11;\n                goto cleanup;\n            }\n\n            if (!insert_item_in_array(parent, index, value))\n            {\n                status = 10;\n                goto cleanup;\n            }\n            value = NULL;\n        }\n    }\n    else if (cJSON_IsObject(parent))\n    {\n        if (case_sensitive)\n        {\n            cJSON_DeleteItemFromObjectCaseSensitive(parent, (char*)child_pointer);\n        }\n        else\n        {\n            cJSON_DeleteItemFromObject(parent, (char*)child_pointer);\n        }\n        cJSON_AddItemToObject(parent, (char*)child_pointer, value);\n        value = NULL;\n    }\n    else /* parent is not an object */\n    {\n        /* Couldn't find object to add to. */\n        status = 9;\n        goto cleanup;\n    }\n\ncleanup:\n    if (value != NULL)\n    {\n        cJSON_Delete(value);\n    }\n    if (parent_pointer != NULL)\n    {\n        cJSON_free(parent_pointer);\n    }\n\n    return status;\n}\n\nCJSON_PUBLIC(int) cJSONUtils_ApplyPatches(cJSON * const object, const cJSON * const patches)\n{\n    const cJSON *current_patch = NULL;\n    int status = 0;\n\n    if (!cJSON_IsArray(patches))\n    {\n        /* malformed patches. */\n        return 1;\n    }\n\n    if (patches != NULL)\n    {\n        current_patch = patches->child;\n    }\n\n    while (current_patch != NULL)\n    {\n        status = apply_patch(object, current_patch, false);\n        if (status != 0)\n        {\n            return status;\n        }\n        current_patch = current_patch->next;\n    }\n\n    return 0;\n}\n\nCJSON_PUBLIC(int) cJSONUtils_ApplyPatchesCaseSensitive(cJSON * const object, const cJSON * const patches)\n{\n    const cJSON *current_patch = NULL;\n    int status = 0;\n\n    if (!cJSON_IsArray(patches))\n    {\n        /* malformed patches. */\n        return 1;\n    }\n\n    if (patches != NULL)\n    {\n        current_patch = patches->child;\n    }\n\n    while (current_patch != NULL)\n    {\n        status = apply_patch(object, current_patch, true);\n        if (status != 0)\n        {\n            return status;\n        }\n        current_patch = current_patch->next;\n    }\n\n    return 0;\n}\n\nstatic void compose_patch(cJSON * const patches, const unsigned char * const operation, const unsigned char * const path, const unsigned char *suffix, const cJSON * const value)\n{\n    cJSON *patch = NULL;\n\n    if ((patches == NULL) || (operation == NULL) || (path == NULL))\n    {\n        return;\n    }\n\n    patch = cJSON_CreateObject();\n    if (patch == NULL)\n    {\n        return;\n    }\n    cJSON_AddItemToObject(patch, \"op\", cJSON_CreateString((const char*)operation));\n\n    if (suffix == NULL)\n    {\n        cJSON_AddItemToObject(patch, \"path\", cJSON_CreateString((const char*)path));\n    }\n    else\n    {\n        size_t suffix_length = pointer_encoded_length(suffix);\n        size_t path_length = strlen((const char*)path);\n        unsigned char *full_path = (unsigned char*)cJSON_malloc(path_length + suffix_length + sizeof(\"/\"));\n\n        sprintf((char*)full_path, \"%s/\", (const char*)path);\n        encode_string_as_pointer(full_path + path_length + 1, suffix);\n\n        cJSON_AddItemToObject(patch, \"path\", cJSON_CreateString((const char*)full_path));\n        cJSON_free(full_path);\n    }\n\n    if (value != NULL)\n    {\n        cJSON_AddItemToObject(patch, \"value\", cJSON_Duplicate(value, 1));\n    }\n    cJSON_AddItemToArray(patches, patch);\n}\n\nCJSON_PUBLIC(void) cJSONUtils_AddPatchToArray(cJSON * const array, const char * const operation, const char * const path, const cJSON * const value)\n{\n    compose_patch(array, (const unsigned char*)operation, (const unsigned char*)path, NULL, value);\n}\n\nstatic void create_patches(cJSON * const patches, const unsigned char * const path, cJSON * const from, cJSON * const to, const cJSON_bool case_sensitive)\n{\n    if ((from == NULL) || (to == NULL))\n    {\n        return;\n    }\n\n    if ((from->type & 0xFF) != (to->type & 0xFF))\n    {\n        compose_patch(patches, (const unsigned char*)\"replace\", path, 0, to);\n        return;\n    }\n\n    switch (from->type & 0xFF)\n    {\n        case cJSON_Number:\n            if ((from->valueint != to->valueint) || !compare_double(from->valuedouble, to->valuedouble))\n            {\n                compose_patch(patches, (const unsigned char*)\"replace\", path, NULL, to);\n            }\n            return;\n\n        case cJSON_String:\n            if (strcmp(from->valuestring, to->valuestring) != 0)\n            {\n                compose_patch(patches, (const unsigned char*)\"replace\", path, NULL, to);\n            }\n            return;\n\n        case cJSON_Array:\n        {\n            size_t index = 0;\n            cJSON *from_child = from->child;\n            cJSON *to_child = to->child;\n            unsigned char *new_path = (unsigned char*)cJSON_malloc(strlen((const char*)path) + 20 + sizeof(\"/\")); /* Allow space for 64bit int. log10(2^64) = 20 */\n\n            /* generate patches for all array elements that exist in both \"from\" and \"to\" */\n            for (index = 0; (from_child != NULL) && (to_child != NULL); (void)(from_child = from_child->next), (void)(to_child = to_child->next), index++)\n            {\n                /* check if conversion to unsigned long is valid\n                 * This should be eliminated at compile time by dead code elimination\n                 * if size_t is an alias of unsigned long, or if it is bigger */\n                if (index > ULONG_MAX)\n                {\n                    cJSON_free(new_path);\n                    return;\n                }\n                sprintf((char*)new_path, \"%s/%lu\", path, (unsigned long)index); /* path of the current array element */\n                create_patches(patches, new_path, from_child, to_child, case_sensitive);\n            }\n\n            /* remove leftover elements from 'from' that are not in 'to' */\n            for (; (from_child != NULL); (void)(from_child = from_child->next))\n            {\n                /* check if conversion to unsigned long is valid\n                 * This should be eliminated at compile time by dead code elimination\n                 * if size_t is an alias of unsigned long, or if it is bigger */\n                if (index > ULONG_MAX)\n                {\n                    cJSON_free(new_path);\n                    return;\n                }\n                sprintf((char*)new_path, \"%lu\", (unsigned long)index);\n                compose_patch(patches, (const unsigned char*)\"remove\", path, new_path, NULL);\n            }\n            /* add new elements in 'to' that were not in 'from' */\n            for (; (to_child != NULL); (void)(to_child = to_child->next), index++)\n            {\n                compose_patch(patches, (const unsigned char*)\"add\", path, (const unsigned char*)\"-\", to_child);\n            }\n            cJSON_free(new_path);\n            return;\n        }\n\n        case cJSON_Object:\n        {\n            cJSON *from_child = NULL;\n            cJSON *to_child = NULL;\n            sort_object(from, case_sensitive);\n            sort_object(to, case_sensitive);\n\n            from_child = from->child;\n            to_child = to->child;\n            /* for all object values in the object with more of them */\n            while ((from_child != NULL) || (to_child != NULL))\n            {\n                int diff;\n                if (from_child == NULL)\n                {\n                    diff = 1;\n                }\n                else if (to_child == NULL)\n                {\n                    diff = -1;\n                }\n                else\n                {\n                    diff = compare_strings((unsigned char*)from_child->string, (unsigned char*)to_child->string, case_sensitive);\n                }\n\n                if (diff == 0)\n                {\n                    /* both object keys are the same */\n                    size_t path_length = strlen((const char*)path);\n                    size_t from_child_name_length = pointer_encoded_length((unsigned char*)from_child->string);\n                    unsigned char *new_path = (unsigned char*)cJSON_malloc(path_length + from_child_name_length + sizeof(\"/\"));\n\n                    sprintf((char*)new_path, \"%s/\", path);\n                    encode_string_as_pointer(new_path + path_length + 1, (unsigned char*)from_child->string);\n\n                    /* create a patch for the element */\n                    create_patches(patches, new_path, from_child, to_child, case_sensitive);\n                    cJSON_free(new_path);\n\n                    from_child = from_child->next;\n                    to_child = to_child->next;\n                }\n                else if (diff < 0)\n                {\n                    /* object element doesn't exist in 'to' --> remove it */\n                    compose_patch(patches, (const unsigned char*)\"remove\", path, (unsigned char*)from_child->string, NULL);\n\n                    from_child = from_child->next;\n                }\n                else\n                {\n                    /* object element doesn't exist in 'from' --> add it */\n                    compose_patch(patches, (const unsigned char*)\"add\", path, (unsigned char*)to_child->string, to_child);\n\n                    to_child = to_child->next;\n                }\n            }\n            return;\n        }\n\n        default:\n            break;\n    }\n}\n\nCJSON_PUBLIC(cJSON *) cJSONUtils_GeneratePatches(cJSON * const from, cJSON * const to)\n{\n    cJSON *patches = NULL;\n\n    if ((from == NULL) || (to == NULL))\n    {\n        return NULL;\n    }\n\n    patches = cJSON_CreateArray();\n    create_patches(patches, (const unsigned char*)\"\", from, to, false);\n\n    return patches;\n}\n\nCJSON_PUBLIC(cJSON *) cJSONUtils_GeneratePatchesCaseSensitive(cJSON * const from, cJSON * const to)\n{\n    cJSON *patches = NULL;\n\n    if ((from == NULL) || (to == NULL))\n    {\n        return NULL;\n    }\n\n    patches = cJSON_CreateArray();\n    create_patches(patches, (const unsigned char*)\"\", from, to, true);\n\n    return patches;\n}\n\nCJSON_PUBLIC(void) cJSONUtils_SortObject(cJSON * const object)\n{\n    sort_object(object, false);\n}\n\nCJSON_PUBLIC(void) cJSONUtils_SortObjectCaseSensitive(cJSON * const object)\n{\n    sort_object(object, true);\n}\n\nstatic cJSON *merge_patch(cJSON *target, const cJSON * const patch, const cJSON_bool case_sensitive)\n{\n    cJSON *patch_child = NULL;\n\n    if (!cJSON_IsObject(patch))\n    {\n        /* scalar value, array or NULL, just duplicate */\n        cJSON_Delete(target);\n        return cJSON_Duplicate(patch, 1);\n    }\n\n    if (!cJSON_IsObject(target))\n    {\n        cJSON_Delete(target);\n        target = cJSON_CreateObject();\n    }\n\n    patch_child = patch->child;\n    while (patch_child != NULL)\n    {\n        if (cJSON_IsNull(patch_child))\n        {\n            /* NULL is the indicator to remove a value, see RFC7396 */\n            if (case_sensitive)\n            {\n                cJSON_DeleteItemFromObjectCaseSensitive(target, patch_child->string);\n            }\n            else\n            {\n                cJSON_DeleteItemFromObject(target, patch_child->string);\n            }\n        }\n        else\n        {\n            cJSON *replace_me = NULL;\n            cJSON *replacement = NULL;\n\n            if (case_sensitive)\n            {\n                replace_me = cJSON_DetachItemFromObjectCaseSensitive(target, patch_child->string);\n            }\n            else\n            {\n                replace_me = cJSON_DetachItemFromObject(target, patch_child->string);\n            }\n\n            replacement = merge_patch(replace_me, patch_child, case_sensitive);\n            if (replacement == NULL)\n            {\n                cJSON_Delete(target);\n                return NULL;\n            }\n\n            cJSON_AddItemToObject(target, patch_child->string, replacement);\n        }\n        patch_child = patch_child->next;\n    }\n    return target;\n}\n\nCJSON_PUBLIC(cJSON *) cJSONUtils_MergePatch(cJSON *target, const cJSON * const patch)\n{\n    return merge_patch(target, patch, false);\n}\n\nCJSON_PUBLIC(cJSON *) cJSONUtils_MergePatchCaseSensitive(cJSON *target, const cJSON * const patch)\n{\n    return merge_patch(target, patch, true);\n}\n\nstatic cJSON *generate_merge_patch(cJSON * const from, cJSON * const to, const cJSON_bool case_sensitive)\n{\n    cJSON *from_child = NULL;\n    cJSON *to_child = NULL;\n    cJSON *patch = NULL;\n    if (to == NULL)\n    {\n        /* patch to delete everything */\n        return cJSON_CreateNull();\n    }\n    if (!cJSON_IsObject(to) || !cJSON_IsObject(from))\n    {\n        return cJSON_Duplicate(to, 1);\n    }\n\n    sort_object(from, case_sensitive);\n    sort_object(to, case_sensitive);\n\n    from_child = from->child;\n    to_child = to->child;\n    patch = cJSON_CreateObject();\n    if (patch == NULL)\n    {\n        return NULL;\n    }\n    while (from_child || to_child)\n    {\n        int diff;\n        if (from_child != NULL)\n        {\n            if (to_child != NULL)\n            {\n                diff = strcmp(from_child->string, to_child->string);\n            }\n            else\n            {\n                diff = -1;\n            }\n        }\n        else\n        {\n            diff = 1;\n        }\n\n        if (diff < 0)\n        {\n            /* from has a value that to doesn't have -> remove */\n            cJSON_AddItemToObject(patch, from_child->string, cJSON_CreateNull());\n\n            from_child = from_child->next;\n        }\n        else if (diff > 0)\n        {\n            /* to has a value that from doesn't have -> add to patch */\n            cJSON_AddItemToObject(patch, to_child->string, cJSON_Duplicate(to_child, 1));\n\n            to_child = to_child->next;\n        }\n        else\n        {\n            /* object key exists in both objects */\n            if (!compare_json(from_child, to_child, case_sensitive))\n            {\n                /* not identical --> generate a patch */\n                cJSON_AddItemToObject(patch, to_child->string, cJSONUtils_GenerateMergePatch(from_child, to_child));\n            }\n\n            /* next key in the object */\n            from_child = from_child->next;\n            to_child = to_child->next;\n        }\n    }\n    if (patch->child == NULL)\n    {\n        /* no patch generated */\n        cJSON_Delete(patch);\n        return NULL;\n    }\n\n    return patch;\n}\n\nCJSON_PUBLIC(cJSON *) cJSONUtils_GenerateMergePatch(cJSON * const from, cJSON * const to)\n{\n    return generate_merge_patch(from, to, false);\n}\n\nCJSON_PUBLIC(cJSON *) cJSONUtils_GenerateMergePatchCaseSensitive(cJSON * const from, cJSON * const to)\n{\n    return generate_merge_patch(from, to, true);\n}\n"
        },
        {
          "name": "cJSON_Utils.h",
          "type": "blob",
          "size": 3.845703125,
          "content": "/*\n  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n#ifndef cJSON_Utils__h\n#define cJSON_Utils__h\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n#include \"cJSON.h\"\n\n/* Implement RFC6901 (https://tools.ietf.org/html/rfc6901) JSON Pointer spec. */\nCJSON_PUBLIC(cJSON *) cJSONUtils_GetPointer(cJSON * const object, const char *pointer);\nCJSON_PUBLIC(cJSON *) cJSONUtils_GetPointerCaseSensitive(cJSON * const object, const char *pointer);\n\n/* Implement RFC6902 (https://tools.ietf.org/html/rfc6902) JSON Patch spec. */\n/* NOTE: This modifies objects in 'from' and 'to' by sorting the elements by their key */\nCJSON_PUBLIC(cJSON *) cJSONUtils_GeneratePatches(cJSON * const from, cJSON * const to);\nCJSON_PUBLIC(cJSON *) cJSONUtils_GeneratePatchesCaseSensitive(cJSON * const from, cJSON * const to);\n/* Utility for generating patch array entries. */\nCJSON_PUBLIC(void) cJSONUtils_AddPatchToArray(cJSON * const array, const char * const operation, const char * const path, const cJSON * const value);\n/* Returns 0 for success. */\nCJSON_PUBLIC(int) cJSONUtils_ApplyPatches(cJSON * const object, const cJSON * const patches);\nCJSON_PUBLIC(int) cJSONUtils_ApplyPatchesCaseSensitive(cJSON * const object, const cJSON * const patches);\n\n/*\n// Note that ApplyPatches is NOT atomic on failure. To implement an atomic ApplyPatches, use:\n//int cJSONUtils_AtomicApplyPatches(cJSON **object, cJSON *patches)\n//{\n//    cJSON *modme = cJSON_Duplicate(*object, 1);\n//    int error = cJSONUtils_ApplyPatches(modme, patches);\n//    if (!error)\n//    {\n//        cJSON_Delete(*object);\n//        *object = modme;\n//    }\n//    else\n//    {\n//        cJSON_Delete(modme);\n//    }\n//\n//    return error;\n//}\n// Code not added to library since this strategy is a LOT slower.\n*/\n\n/* Implement RFC7386 (https://tools.ietf.org/html/rfc7396) JSON Merge Patch spec. */\n/* target will be modified by patch. return value is new ptr for target. */\nCJSON_PUBLIC(cJSON *) cJSONUtils_MergePatch(cJSON *target, const cJSON * const patch);\nCJSON_PUBLIC(cJSON *) cJSONUtils_MergePatchCaseSensitive(cJSON *target, const cJSON * const patch);\n/* generates a patch to move from -> to */\n/* NOTE: This modifies objects in 'from' and 'to' by sorting the elements by their key */\nCJSON_PUBLIC(cJSON *) cJSONUtils_GenerateMergePatch(cJSON * const from, cJSON * const to);\nCJSON_PUBLIC(cJSON *) cJSONUtils_GenerateMergePatchCaseSensitive(cJSON * const from, cJSON * const to);\n\n/* Given a root object and a target object, construct a pointer from one to the other. */\nCJSON_PUBLIC(char *) cJSONUtils_FindPointerFromObjectTo(const cJSON * const object, const cJSON * const target);\n\n/* Sorts the members of the object into alphabetical order. */\nCJSON_PUBLIC(void) cJSONUtils_SortObject(cJSON * const object);\nCJSON_PUBLIC(void) cJSONUtils_SortObjectCaseSensitive(cJSON * const object);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "fuzzing",
          "type": "tree",
          "content": null
        },
        {
          "name": "library_config",
          "type": "tree",
          "content": null
        },
        {
          "name": "test.c",
          "type": "blob",
          "size": 7.5302734375,
          "content": "/*\n  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"cJSON.h\"\n\n/* Used by some code below as an example datatype. */\nstruct record\n{\n    const char *precision;\n    double lat;\n    double lon;\n    const char *address;\n    const char *city;\n    const char *state;\n    const char *zip;\n    const char *country;\n};\n\n\n/* Create a bunch of objects as demonstration. */\nstatic int print_preallocated(cJSON *root)\n{\n    /* declarations */\n    char *out = NULL;\n    char *buf = NULL;\n    char *buf_fail = NULL;\n    size_t len = 0;\n    size_t len_fail = 0;\n\n    /* formatted print */\n    out = cJSON_Print(root);\n\n    /* create buffer to succeed */\n    /* the extra 5 bytes are because of inaccuracies when reserving memory */\n    len = strlen(out) + 5;\n    buf = (char*)malloc(len);\n    if (buf == NULL)\n    {\n        printf(\"Failed to allocate memory.\\n\");\n        exit(1);\n    }\n\n    /* create buffer to fail */\n    len_fail = strlen(out);\n    buf_fail = (char*)malloc(len_fail);\n    if (buf_fail == NULL)\n    {\n        printf(\"Failed to allocate memory.\\n\");\n        exit(1);\n    }\n\n    /* Print to buffer */\n    if (!cJSON_PrintPreallocated(root, buf, (int)len, 1)) {\n        printf(\"cJSON_PrintPreallocated failed!\\n\");\n        if (strcmp(out, buf) != 0) {\n            printf(\"cJSON_PrintPreallocated not the same as cJSON_Print!\\n\");\n            printf(\"cJSON_Print result:\\n%s\\n\", out);\n            printf(\"cJSON_PrintPreallocated result:\\n%s\\n\", buf);\n        }\n        free(out);\n        free(buf_fail);\n        free(buf);\n        return -1;\n    }\n\n    /* success */\n    printf(\"%s\\n\", buf);\n\n    /* force it to fail */\n    if (cJSON_PrintPreallocated(root, buf_fail, (int)len_fail, 1)) {\n        printf(\"cJSON_PrintPreallocated failed to show error with insufficient memory!\\n\");\n        printf(\"cJSON_Print result:\\n%s\\n\", out);\n        printf(\"cJSON_PrintPreallocated result:\\n%s\\n\", buf_fail);\n        free(out);\n        free(buf_fail);\n        free(buf);\n        return -1;\n    }\n\n    free(out);\n    free(buf_fail);\n    free(buf);\n    return 0;\n}\n\n/* Create a bunch of objects as demonstration. */\nstatic void create_objects(void)\n{\n    /* declare a few. */\n    cJSON *root = NULL;\n    cJSON *fmt = NULL;\n    cJSON *img = NULL;\n    cJSON *thm = NULL;\n    cJSON *fld = NULL;\n    int i = 0;\n\n    /* Our \"days of the week\" array: */\n    const char *strings[7] =\n    {\n        \"Sunday\",\n        \"Monday\",\n        \"Tuesday\",\n        \"Wednesday\",\n        \"Thursday\",\n        \"Friday\",\n        \"Saturday\"\n    };\n    /* Our matrix: */\n    int numbers[3][3] =\n    {\n        {0, -1, 0},\n        {1, 0, 0},\n        {0 ,0, 1}\n    };\n    /* Our \"gallery\" item: */\n    int ids[4] = { 116, 943, 234, 38793 };\n    /* Our array of \"records\": */\n    struct record fields[2] =\n    {\n        {\n            \"zip\",\n            37.7668,\n            -1.223959e+2,\n            \"\",\n            \"SAN FRANCISCO\",\n            \"CA\",\n            \"94107\",\n            \"US\"\n        },\n        {\n            \"zip\",\n            37.371991,\n            -1.22026e+2,\n            \"\",\n            \"SUNNYVALE\",\n            \"CA\",\n            \"94085\",\n            \"US\"\n        }\n    };\n    volatile double zero = 0.0;\n\n    /* Here we construct some JSON standards, from the JSON site. */\n\n    /* Our \"Video\" datatype: */\n    root = cJSON_CreateObject();\n    cJSON_AddItemToObject(root, \"name\", cJSON_CreateString(\"Jack (\\\"Bee\\\") Nimble\"));\n    cJSON_AddItemToObject(root, \"format\", fmt = cJSON_CreateObject());\n    cJSON_AddStringToObject(fmt, \"type\", \"rect\");\n    cJSON_AddNumberToObject(fmt, \"width\", 1920);\n    cJSON_AddNumberToObject(fmt, \"height\", 1080);\n    cJSON_AddFalseToObject (fmt, \"interlace\");\n    cJSON_AddNumberToObject(fmt, \"frame rate\", 24);\n\n    /* Print to text */\n    if (print_preallocated(root) != 0) {\n        cJSON_Delete(root);\n        exit(EXIT_FAILURE);\n    }\n    cJSON_Delete(root);\n\n    /* Our \"days of the week\" array: */\n    root = cJSON_CreateStringArray(strings, 7);\n\n    if (print_preallocated(root) != 0) {\n        cJSON_Delete(root);\n        exit(EXIT_FAILURE);\n    }\n    cJSON_Delete(root);\n\n    /* Our matrix: */\n    root = cJSON_CreateArray();\n    for (i = 0; i < 3; i++)\n    {\n        cJSON_AddItemToArray(root, cJSON_CreateIntArray(numbers[i], 3));\n    }\n\n    /* cJSON_ReplaceItemInArray(root, 1, cJSON_CreateString(\"Replacement\")); */\n\n    if (print_preallocated(root) != 0) {\n        cJSON_Delete(root);\n        exit(EXIT_FAILURE);\n    }\n    cJSON_Delete(root);\n\n    /* Our \"gallery\" item: */\n    root = cJSON_CreateObject();\n    cJSON_AddItemToObject(root, \"Image\", img = cJSON_CreateObject());\n    cJSON_AddNumberToObject(img, \"Width\", 800);\n    cJSON_AddNumberToObject(img, \"Height\", 600);\n    cJSON_AddStringToObject(img, \"Title\", \"View from 15th Floor\");\n    cJSON_AddItemToObject(img, \"Thumbnail\", thm = cJSON_CreateObject());\n    cJSON_AddStringToObject(thm, \"Url\", \"http:/*www.example.com/image/481989943\");\n    cJSON_AddNumberToObject(thm, \"Height\", 125);\n    cJSON_AddStringToObject(thm, \"Width\", \"100\");\n    cJSON_AddItemToObject(img, \"IDs\", cJSON_CreateIntArray(ids, 4));\n\n    if (print_preallocated(root) != 0) {\n        cJSON_Delete(root);\n        exit(EXIT_FAILURE);\n    }\n    cJSON_Delete(root);\n\n    /* Our array of \"records\": */\n    root = cJSON_CreateArray();\n    for (i = 0; i < 2; i++)\n    {\n        cJSON_AddItemToArray(root, fld = cJSON_CreateObject());\n        cJSON_AddStringToObject(fld, \"precision\", fields[i].precision);\n        cJSON_AddNumberToObject(fld, \"Latitude\", fields[i].lat);\n        cJSON_AddNumberToObject(fld, \"Longitude\", fields[i].lon);\n        cJSON_AddStringToObject(fld, \"Address\", fields[i].address);\n        cJSON_AddStringToObject(fld, \"City\", fields[i].city);\n        cJSON_AddStringToObject(fld, \"State\", fields[i].state);\n        cJSON_AddStringToObject(fld, \"Zip\", fields[i].zip);\n        cJSON_AddStringToObject(fld, \"Country\", fields[i].country);\n    }\n\n    /* cJSON_ReplaceItemInObject(cJSON_GetArrayItem(root, 1), \"City\", cJSON_CreateIntArray(ids, 4)); */\n\n    if (print_preallocated(root) != 0) {\n        cJSON_Delete(root);\n        exit(EXIT_FAILURE);\n    }\n    cJSON_Delete(root);\n\n    root = cJSON_CreateObject();\n    cJSON_AddNumberToObject(root, \"number\", 1.0 / zero);\n\n    if (print_preallocated(root) != 0) {\n        cJSON_Delete(root);\n        exit(EXIT_FAILURE);\n    }\n    cJSON_Delete(root);\n}\n\nint CJSON_CDECL main(void)\n{\n    /* print the version */\n    printf(\"Version: %s\\n\", cJSON_Version());\n\n    /* Now some samplecode for building objects concisely: */\n    create_objects();\n\n    return 0;\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "valgrind.supp",
          "type": "blob",
          "size": 0.0595703125,
          "content": "{\n\tsuppress_ld_on_armv7\n\tMemcheck:Cond\n\t...\n\tobj:*/ld-*.so\n}\n"
        }
      ]
    }
  ]
}