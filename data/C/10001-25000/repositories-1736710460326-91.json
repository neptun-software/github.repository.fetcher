{
  "metadata": {
    "timestamp": 1736710460326,
    "page": 91,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "libretro/RetroArch",
      "stars": 10711,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.44140625,
          "content": "# EditorConfig: https://EditorConfig.org\n\n# Top-most EditorConfig file\nroot = true\n\n# Unix-style newlines with a newline ending every file\n[*]\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\ncharset = utf-8\n\n# 3 space indentation\n[*.{c,h,js,css,html}]\nindent_style = space\nindent_size = 3\n\n# 2 space indentation\n[*.{json,xml,yaml,yml}]\nindent_style = space\nindent_size = 2\n\n# Tab indentation\n[Makefile*]\nindent_style = tab\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 3.978515625,
          "content": "*.o\n*.obj\n*.pdb\n*.exe\n*.bmpobj\n*.binobj\n*.so\n*.so.*\n*.dll\n*.a\n*.elf\n*.dol\n*.map\n*.swp\n*.cache\n*.gcda\n*.lcbk\n*.gcno\n.tmp\n.tmp.c\n.tmp.cxx\n.moc.h\n.moc.cpp\n*.log\n/.project\n/.externalToolBuilders/\n/retroarch\n/retroarch.cfg\n/retroarch.exe\n/retroarch_debug.exe\n/config.h\n/config.mk\n*.ncb\n*.sdf\n*.opensdf\n*.suo\nDebug\nRelease\nipch\n*.user\n/bootstrap/gx/wii/app_booter/app_booter.bin\n/wii/app_booter/app_booter.bin\n*.zip\nRetroArch-w32/\nRetroArch-w64/\n.DS_Store\n*/build/*\n*.pbxuser\n!default.pbxuser\n*.mode1v3\n!default.mode1v3\n*.mode2v3\n!default.mode2v3\n*.perspectivev3\n!default.perspectivev3\nxcuserdata\nprofile\n*.moved-aside\nDerivedData\n.idea/\n*.hmap\napple/tmp\napple/*.mobileprovision\napple/RetroArch_iOS.xcodeproj/project.xcworkspace/*\n/Cg/\n/GL/\n/SDL/\n/ffmpeg/\n/freetype2/\n/ft2build.h\n/iconv.h\n/phoenix/\n/python/\n/rsound.h\n.pc\n/media/shaders_glsl/\n/media/shaders_slang/\n/obj-w32/\n.cproject\n.settings\nlibretro-super\nrun.sh\nconvert_rumble.awk\n*~\nassets\ninfo\ncontent_favorites.lpl\ncontent_history.lpl\ncontent_image_history.lpl\ncontent_music_history.lpl\ncontent_video_history.lpl\nsaves\nscreenshots\nautoconfig\nconfig\ndatabase\noverlays\nplaylists\nstates\ncheats\nthumbnails\ndocs/html\nsystem\nshaders/shaders_cg\nshaders/shaders_glsl\nshaders/shaders_slang\n\n# Qt Creator\n*.cflags\n*.cxxflags\n*.creator*\n*.config\n*.files\n*.includes\n\n# Wii U\n*.depend\n*.rpx\n*.last\nwiiu/wut/elf2rpl/elf2rpl\n/pkg/wiiu/retroarch\n/pkg/wiiu/wiiu\n/pkg/wiiu/rpx\n/wiiu-devel.properties\n\n# 3ds\n/.lst\n*.3dsx\n*.cia\n*.3ds\n*.bnr\n*.smdh\n/retroarch_3ds.core\n/retroarch_3ds.icn\n/retroarch_3ds_salamander.icn\n\n# Ctags\n/tags\n\n# CLion\n/cmake-build-debug/\n.run\n\n# Android\n/pkg/android/phoenix/obj/\n/pkg/android/phoenix/assets/\n/pkg/android/phoenix/libs/\n/pkg/android/phoenix/bin/\n/pkg/android/phoenix/gen/\n/pkg/android/phoenix/local.properties\n/pkg/android/phoenix/gradle.properties\n/pkg/android/phoenix/.gradle\n/pkg/android/phoenix/.externalNativeBuild\n/pkg/android/phoenix/build\n\n# Cloned by libretro-fetch.sh\n/media/assets/\n/media/autoconfig/\n/media/overlays/\n/media/shaders_cg/\n/media/libretrodb/\n\ncompile_commands.json\npkg/apple/iOS/build/\npkg/apple/build/\nui/drivers/qt/moc_*\nui/drivers/moc_*\n\nobj-unix/\n.vagrant/\n\n# Visual Studio\n/pkg/msvc/Release Cg/*.iobj\n/pkg/msvc/Release Cg/*.ipdb\n/pkg/msvc/Release Cg/*.lpl\n/pkg/msvc/Release Cg/*.cfg\n/pkg/msvc/*.db\n/pkg/msvc/.vs\n/pkg/msvc/*/.vs\n*.tlog\n*.lastbuildstate\n*.FileListAbsolute.txt\n*.res\nretroarch.cfg\nMakefile.local\npkg/msvc/**/ARM\npkg/msvc/**/ARM64\npkg/msvc/**/* Cg\npkg/msvc/**/* QT\npkg/msvc/**/* QT+CG\npkg/msvc/**/x64\n\n# Emscripten artifacts\n\nretroarch.js\nretroarch.js.mem\n*.bc\n*.wasm\n\n# only ignore .js files in the repo root\n/*.js\n\n# Switch\n*.d\nexefs/*\nretroarch_switch.pfs0\nretroarch_switch.lst\nretroarch_switch.nacp\nretroarch_switch.nro\nretroarch_switch.nso\n\n# PS2\n*_irx.c\n\n# Wayland\ngfx/common/wayland/fractional-scale-v1.c\ngfx/common/wayland/fractional-scale-v1.h\ngfx/common/wayland/viewporter.c\ngfx/common/wayland/viewporter.h\ngfx/common/wayland/idle-inhibit-unstable-v1.c\ngfx/common/wayland/idle-inhibit-unstable-v1.h\ngfx/common/wayland/xdg-shell-unstable-v6.c\ngfx/common/wayland/xdg-shell-unstable-v6.h\ngfx/common/wayland/xdg-decoration-unstable-v1.h\ngfx/common/wayland/xdg-decoration-unstable-v1.c\ngfx/common/wayland/xdg-shell.c\ngfx/common/wayland/xdg-shell.h\ngfx/common/wayland/pointer-constraints-unstable-v1.c\ngfx/common/wayland/pointer-constraints-unstable-v1.h\ngfx/common/wayland/relative-pointer-unstable-v1.c\ngfx/common/wayland/relative-pointer-unstable-v1.h\ngfx/common/wayland/viewporter.c\ngfx/common/wayland/viewporter.h\ngfx/common/wayland/cursor-shape-v1.h\ngfx/common/wayland/cursor-shape-v1.c\ngfx/common/wayland/tablet-unstable-v2.h\ngfx/common/wayland/tablet-unstable-v2.c\ngfx/common/wayland/content-type-v1.h\ngfx/common/wayland/content-type-v1.c\ngfx/common/wayland/single-pixel-buffer-v1.h\ngfx/common/wayland/single-pixel-buffer-v1.c\n\n# libretro-common samples\nlibretro-common/samples/streams/rzip/rzip\n\n# DINGUX\n*.opk\n\n#VITA\nparam.sfo\n*.wo\n*.elf\n*.self\n*.vpk\n/.vs\n/deps/SPIRV-Cross/out/build/x64-Debug\n\n# Visual Studio Code\n.vscode/\n\n# Clazy\n*.clazy.yaml\n"
        },
        {
          "name": ".gitlab-ci.yml",
          "type": "blob",
          "size": 42.8974609375,
          "content": "image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-amd64-ubuntu:latest\n\nstages:\n  - build-prepare\n  - build\n  - prepare-for-static-cores\n  - trigger-static-cores\n\nbuild-retroarch-windows-x64:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-mxe-win64-cross:gcc10\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n    STRIP_BIN:  1\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - retroarch.exe\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"MOC=/usr/lib/mxe/usr/x86_64-w64-mingw32.shared/qt5/bin/moc ./configure --host=x86_64-w64-mingw32.shared\"\n    - \"make -j$NUMPROC\"\n    - if [ $STRIP_BIN -eq 1 ]; then strip --strip-unneeded retroarch.exe; fi\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/redist\"\n    - \"cd libretro-common/audio/dsp_filters && make -j$NUMPROC platform=win compiler=x86_64-w64-mingw32.static-gcc build=release && make -j$NUMPROC platform=win compiler=x86_64-w64-mingw32.static-gcc build=release strip && cd -\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.dll ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.dsp ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cd gfx/video_filters && make -j$NUMPROC platform=win compiler=x86_64-w64-mingw32.static-gcc build=release && make -j$NUMPROC platform=win compiler=x86_64-w64-mingw32.static-gcc build=release strip && cd -\"\n    - \"cp -f gfx/video_filters/*.dll ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f retroarch.cfg ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg/retroarch.default.cfg\"\n    - \"echo -e '[Paths]\\nPlugins = ./' > ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg/qt.conf\"\n    - \"/bin/bash /usr/lib/mxe/tools/copydlldeps.sh\n        --infile retroarch.exe\n        --destdir ${MEDIA_PATH}/${CI_PROJECT_NAME}/redist/\n        --recursivesrcdir /usr/lib/mxe/usr/x86_64-w64-mingw32.shared/\n        --enforcedir /usr/lib/mxe/usr/x86_64-w64-mingw32.shared/qt5/plugins/bearer/\n        --enforcedir /usr/lib/mxe/usr/x86_64-w64-mingw32.shared/qt5/plugins/iconengines/\n        --enforcedir /usr/lib/mxe/usr/x86_64-w64-mingw32.shared/qt5/plugins/imageformats/\n        --enforcedir /usr/lib/mxe/usr/x86_64-w64-mingw32.shared/qt5/plugins/platforms/\n        --enforcedir /usr/lib/mxe/usr/x86_64-w64-mingw32.shared/qt5/plugins/styles/\n        --copy\n        --objdump x86_64-w64-mingw32.shared-objdump\"\n    - \"cp -f nvdaControllerClient64.dll ${MEDIA_PATH}/${CI_PROJECT_NAME}/redist/nvdaControllerClient64.dll\"\n    - \"rm -f ${MEDIA_PATH}/${CI_PROJECT_NAME}/redist/opengl32.dll\"\n\nbuild-retroarch-windows-i686:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-mxe-win32-cross:gcc10\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n    STRIP_BIN:  1\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - retroarch.exe\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"MOC=/usr/lib/mxe/usr/i686-w64-mingw32.shared/qt5/bin/moc ./configure --host=i686-w64-mingw32.shared\"\n    - \"make -j$NUMPROC\"\n    - if [ $STRIP_BIN -eq 1 ]; then strip --strip-unneeded retroarch.exe; fi\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/redist\"\n    - \"cd libretro-common/audio/dsp_filters && make -j$NUMPROC platform=win compiler=i686-w64-mingw32.static-gcc build=release && make -j$NUMPROC platform=win compiler=i686-w64-mingw32.static-gcc build=release strip && cd -\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.dll ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.dsp ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cd gfx/video_filters && make -j$NUMPROC platform=win compiler=i686-w64-mingw32.static-gcc build=release && make -j$NUMPROC platform=win compiler=i686-w64-mingw32.static-gcc build=release strip && cd -\"\n    - \"cp -f gfx/video_filters/*.dll ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f retroarch.cfg ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg/retroarch.default.cfg\"\n    - \"echo -e '[Paths]\\nPlugins = ./' > ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg/qt.conf\"\n    - \"/bin/bash /usr/lib/mxe/tools/copydlldeps.sh\n        --infile retroarch.exe\n        --destdir ${MEDIA_PATH}/${CI_PROJECT_NAME}/redist/\n        --recursivesrcdir /usr/lib/mxe/usr/i686-w64-mingw32.shared/\n        --enforcedir /usr/lib/mxe/usr/i686-w64-mingw32.shared/qt5/plugins/bearer/\n        --enforcedir /usr/lib/mxe/usr/i686-w64-mingw32.shared/qt5/plugins/iconengines/\n        --enforcedir /usr/lib/mxe/usr/i686-w64-mingw32.shared/qt5/plugins/imageformats/\n        --enforcedir /usr/lib/mxe/usr/i686-w64-mingw32.shared/qt5/plugins/platforms/\n        --enforcedir /usr/lib/mxe/usr/i686-w64-mingw32.shared/qt5/plugins/styles/\n        --copy\n        --objdump i686-w64-mingw32.shared-objdump\"\n    - \"rm -f ${MEDIA_PATH}/${CI_PROJECT_NAME}/redist/opengl32.dll\"\n\nbuild-retroarch-windows-msvc10-x64:\n  tags:\n    - msvc2010\n  stage: build\n  variables:\n    MEDIA_PATH:     .media\n    MSYSTEM:        MINGW64\n    ARCH:           x86_64\n    MSYS_BIN_DIR:   C:\\msys64\\usr\\bin\n    SDK_BIN_DIR:    C:\\Program Files\\Microsoft SDKs\\Windows\\v7.1\\Bin\n    RCEDIT_BIN_DIR: C:\\Program Files\\rcedit\n    PEDEPS_BIN_DIR: C:\\Program Files\\pedeps-0.1.9-win64\\bin\n    MSVC_PLATFORM:  windows_msvc2010_x64\n  before_script:\n    - $Env:HOME = \".\"\n    - $Env:Path += -join(\";\", \"$Env:MSYS_BIN_DIR\", \";\", \"$Env:SDK_BIN_DIR\", \";\", \"$Env:RCEDIT_BIN_DIR\", \";\", \"$Env:PEDEPS_BIN_DIR\")\n  artifacts:\n    paths:\n    - retroarch.exe\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - |\n      $ErrorActionPreference = 'Stop'\n      # Build RetroArch\n      bash.exe -l -c \"make -f Makefile.griffin platform=$Env:MSVC_PLATFORM\"\n      if ($LastExitCode -ne 0){throw \"Failed to build RetroArch\"}\n      mt.exe -nologo -manifest \"retroarch.exe.manifest\" -outputresource:\"retroarch.exe;#1\"\n      if ($LastExitCode -ne 0){throw \"Failed to add manifest to RetroArch binary\"}\n      rcedit-x64.exe \"retroarch.exe\" --set-icon \"media\\retroarch.ico\"\n      if ($LastExitCode -ne 0){throw \"Failed to set icon of RetroArch binary\"}\n      # Create .media subdirectories\n      New-Item -Path \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/filters/audio\" -ItemType Directory\n      New-Item -Path \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/filters/video\" -ItemType Directory\n      New-Item -Path \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/pkg\" -ItemType Directory\n      New-Item -Path \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/redist\" -ItemType Directory\n      # Copy audio/video filters\n      Get-ChildItem -Path \"libretro-common/audio/dsp_filters/*\" -Include *.dsp | Copy-Item -Destination \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/filters/audio\"\n      Get-ChildItem -Path \"gfx/video_filters/*\" -Include *.filt | Copy-Item -Destination \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/filters/video\"\n      # Copy default config file\n      Copy-Item -Path \"retroarch.cfg\" -Destination \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/pkg/retroarch.default.cfg\"\n      # Copy dll dependencies\n      # (note that msvc builds should not have any, but this\n      # may change in the future)\n      copypedeps.exe -r retroarch.exe \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/redist\"\n      if ($LastExitCode -ne 0){throw \"Failed to copy RetroArch dependencies\"}\n      Remove-Item \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/redist/retroarch.exe\" -ErrorAction Ignore\n\nbuild-retroarch-windows-msvc10-i686:\n  tags:\n    - msvc2010\n  stage: build\n  variables:\n    MEDIA_PATH:     .media\n    MSYSTEM:        MINGW32\n    ARCH:           x86\n    MSYS_BIN_DIR:   C:\\msys64\\usr\\bin\n    SDK_BIN_DIR:    C:\\Program Files\\Microsoft SDKs\\Windows\\v7.1\\Bin\n    RCEDIT_BIN_DIR: C:\\Program Files\\rcedit\n    PEDEPS_BIN_DIR: C:\\Program Files\\pedeps-0.1.9-win64\\bin\n    MSVC_PLATFORM:  windows_msvc2010_x86\n  before_script:\n    - $Env:HOME = \".\"\n    - $Env:Path += -join(\";\", \"$Env:MSYS_BIN_DIR\", \";\", \"$Env:SDK_BIN_DIR\", \";\", \"$Env:RCEDIT_BIN_DIR\", \";\", \"$Env:PEDEPS_BIN_DIR\")\n  artifacts:\n    paths:\n    - retroarch.exe\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - |\n      $ErrorActionPreference = 'Stop'\n      # Build RetroArch\n      bash.exe -l -c \"make -f Makefile.griffin platform=$Env:MSVC_PLATFORM\"\n      if ($LastExitCode -ne 0){throw \"Failed to build RetroArch\"}\n      mt.exe -nologo -manifest \"retroarch.exe.manifest\" -outputresource:\"retroarch.exe;#1\"\n      if ($LastExitCode -ne 0){throw \"Failed to add manifest to RetroArch binary\"}\n      rcedit-x64.exe \"retroarch.exe\" --set-icon \"media\\retroarch.ico\"\n      if ($LastExitCode -ne 0){throw \"Failed to set icon of RetroArch binary\"}\n      # Create .media subdirectories\n      New-Item -Path \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/filters/audio\" -ItemType Directory\n      New-Item -Path \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/filters/video\" -ItemType Directory\n      New-Item -Path \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/pkg\" -ItemType Directory\n      New-Item -Path \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/redist\" -ItemType Directory\n      # Copy audio/video filters\n      Get-ChildItem -Path \"libretro-common/audio/dsp_filters/*\" -Include *.dsp | Copy-Item -Destination \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/filters/audio\"\n      Get-ChildItem -Path \"gfx/video_filters/*\" -Include *.filt | Copy-Item -Destination \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/filters/video\"\n      # Copy default config file\n      Copy-Item -Path \"retroarch.cfg\" -Destination \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/pkg/retroarch.default.cfg\"\n      # Copy dll dependencies\n      # (note that msvc builds should not have any, but this\n      # may change in the future)\n      copypedeps.exe -r retroarch.exe \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/redist\"\n      if ($LastExitCode -ne 0){throw \"Failed to copy RetroArch dependencies\"}\n      Remove-Item \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/redist/retroarch.exe\" -ErrorAction Ignore\n\nbuild-retroarch-windows-msvc05-i686:\n  tags:\n    - win10\n  stage: build\n  variables:\n    MEDIA_PATH:     .media\n    MSYSTEM:        MINGW32\n    ARCH:           x86\n    MSYS_BIN_DIR:   C:\\msys64\\usr\\bin\n    SDK_BIN_DIR:    C:\\Program Files\\Microsoft SDKs\\Windows\\v7.1\\Bin\n    RCEDIT_BIN_DIR: C:\\Program Files\\rcedit\n    PEDEPS_BIN_DIR: C:\\Program Files\\pedeps-0.1.9-win64\\bin\n    VS80COMNTOOLS:  C:\\Program Files (x86)\\Microsoft Visual Studio 8\\Common7\\Tools\\\n    MSVC_PLATFORM:  windows_msvc2005_x86\n  before_script:\n    - $Env:HOME = \".\"\n    - $Env:Path += -join(\";\", \"$Env:MSYS_BIN_DIR\", \";\", \"$Env:SDK_BIN_DIR\", \";\", \"$Env:RCEDIT_BIN_DIR\", \";\", \"$Env:PEDEPS_BIN_DIR\")\n  artifacts:\n    paths:\n    - retroarch.exe\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - |\n      $ErrorActionPreference = 'Stop'\n      # Build RetroArch\n      bash.exe -l -c \"make -f Makefile.griffin platform=$Env:MSVC_PLATFORM\"\n      if ($LastExitCode -ne 0){throw \"Failed to build RetroArch\"}\n      mt.exe -nologo -manifest \"retroarch.exe.manifest\" -outputresource:\"retroarch.exe;#1\"\n      if ($LastExitCode -ne 0){throw \"Failed to add manifest to RetroArch binary\"}\n      rcedit-x64.exe \"retroarch.exe\" --set-icon \"media\\retroarch.ico\"\n      if ($LastExitCode -ne 0){throw \"Failed to set icon of RetroArch binary\"}\n      # Create .media subdirectories\n      New-Item -Path \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/filters/audio\" -ItemType Directory\n      New-Item -Path \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/filters/video\" -ItemType Directory\n      New-Item -Path \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/pkg\" -ItemType Directory\n      New-Item -Path \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/redist\" -ItemType Directory\n      # Copy audio/video filters\n      Get-ChildItem -Path \"libretro-common/audio/dsp_filters/*\" -Include *.dsp | Copy-Item -Destination \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/filters/audio\"\n      Get-ChildItem -Path \"gfx/video_filters/*\" -Include *.filt | Copy-Item -Destination \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/filters/video\"\n      # Copy default config file\n      Copy-Item -Path \"retroarch.cfg\" -Destination \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/pkg/retroarch.default.cfg\"\n      # Copy dll dependencies\n      # (note that msvc builds should not have any, but this\n      # may change in the future)\n      copypedeps.exe -r retroarch.exe \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/redist\"\n      if ($LastExitCode -ne 0){throw \"Failed to copy RetroArch dependencies\"}\n      Remove-Item \"$Env:MEDIA_PATH/$Env:CI_PROJECT_NAME/redist/retroarch.exe\" -ErrorAction Ignore\n\nbuild-retroarch-linux-x64:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-amd64-ubuntu:xenial-gcc9\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n    STRIP_BIN:  1\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - retroarch\n    - retroarch_qt\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    # Qt build\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/AppDirQt\"\n    - \"./configure --prefix=/usr\"\n    - \"make -j$NUMPROC\"\n    - if [ $STRIP_BIN -eq 1 ]; then strip --strip-unneeded retroarch; fi\n    - \"make install DESTDIR=${MEDIA_PATH}/${CI_PROJECT_NAME}/AppDirQt prefix=/usr\"\n    - \"rm -rf ${MEDIA_PATH}/${CI_PROJECT_NAME}/AppDirQt/etc\"\n    - \"cd ${MEDIA_PATH}/${CI_PROJECT_NAME}/ && tar -czf AppDirQt.tar.gz AppDirQt && rm -rf AppDirQt && cd -\"\n    - \"mv -f retroarch retroarch_qt\"\n    # Non-Qt build\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/AppDir\"\n    - \"make clean\"\n    - \"./configure --disable-qt --prefix=/usr\"\n    - \"make -j$NUMPROC\"\n    - if [ $STRIP_BIN -eq 1 ]; then strip --strip-unneeded retroarch; fi\n    - \"make install DESTDIR=${MEDIA_PATH}/${CI_PROJECT_NAME}/AppDir prefix=/usr\"\n    - \"rm -rf ${MEDIA_PATH}/${CI_PROJECT_NAME}/AppDir/etc\"\n    - \"cd ${MEDIA_PATH}/${CI_PROJECT_NAME}/ && tar -czf AppDir.tar.gz AppDir && rm -rf AppDir && cd -\"\n    # Filters\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cd libretro-common/audio/dsp_filters && make -j$NUMPROC build=release && make -j$NUMPROC build=release strip && cd -\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.so ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.dsp ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cd gfx/video_filters && make -j$NUMPROC build=release && make -j$NUMPROC build=release strip && cd -\"\n    - \"cp -f gfx/video_filters/*.so ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n\nbuild-retroarch-linux-i686:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-i386-ubuntu:xenial-gcc9\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n    STRIP_BIN:  1\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - retroarch\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    # Qt build\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/AppDirQt\"\n    - \"./configure --prefix=/usr\"\n    - \"make -j$NUMPROC\"\n    - if [ $STRIP_BIN -eq 1 ]; then strip --strip-unneeded retroarch; fi\n    - \"make install DESTDIR=${MEDIA_PATH}/${CI_PROJECT_NAME}/AppDirQt prefix=/usr\"\n    - \"rm -rf ${MEDIA_PATH}/${CI_PROJECT_NAME}/AppDirQt/etc\"\n    - \"cd ${MEDIA_PATH}/${CI_PROJECT_NAME}/ && tar -czf AppDirQt.tar.gz AppDirQt && rm -rf AppDirQt && cd -\"\n    - \"mv -f retroarch retroarch_qt\"\n    # Non-Qt build\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/AppDir\"\n    - \"make clean\"\n    - \"./configure --disable-qt --prefix=/usr\"\n    - \"make -j$NUMPROC\"\n    - if [ $STRIP_BIN -eq 1 ]; then strip --strip-unneeded retroarch; fi\n    - \"make install DESTDIR=${MEDIA_PATH}/${CI_PROJECT_NAME}/AppDir prefix=/usr\"\n    - \"rm -rf ${MEDIA_PATH}/${CI_PROJECT_NAME}/AppDir/etc\"\n    - \"cd ${MEDIA_PATH}/${CI_PROJECT_NAME}/ && tar -czf AppDir.tar.gz AppDir && rm -rf AppDir && cd -\"\n    # Filters\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cd libretro-common/audio/dsp_filters && make -j$NUMPROC build=release && make -j$NUMPROC build=release strip && cd -\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.so ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.dsp ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cd gfx/video_filters && make -j$NUMPROC build=release && make -j$NUMPROC build=release strip && cd -\"\n    - \"cp -f gfx/video_filters/*.so ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n  \n.build-retroarch-macos-xcode:\n  # Metal/Universal x86_64 arm64 is default\n  tags:\n    - macosx-packaging\n  stage: build\n  variables:\n    XCARCHIVE_PATH: pkg/apple/build/RetroArchUniversal\n    XCPROJECT_NAME: RetroArch_Metal\n    XCCONFIG: GitLabCI.xcconfig\n  artifacts:\n    paths:\n    - ${XCPROJECT_NAME}.zip\n    - retroarch-repo/\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - xcodebuild -project pkg/apple/${XCPROJECT_NAME}.xcodeproj -config Release -scheme RetroArch -archivePath ${XCARCHIVE_PATH} -xcconfig pkg/apple/${XCCONFIG} archive\n    - xcodebuild -exportArchive -archivePath ${XCARCHIVE_PATH}.xcarchive -exportPath . -exportOptionsPlist pkg/apple/OSX/ExportOptions.plist\n    - ditto -c -k --sequesterRsrc --keepParent RetroArch.app ${XCPROJECT_NAME}.zip\n    - mkdir .retroarch-repo\n    - \"cp -R ./* .retroarch-repo\"\n    - echo '#define GIT_VERSION ' $(git rev-parse --short HEAD) > .retroarch-repo/.git_version.h\n    - \"mv .retroarch-repo/ retroarch-repo/\"\n\n# Mac OS Universal, Metal\nbuild-retroarch-osx-universal-metal:\n  extends: .build-retroarch-macos-xcode\n\nbuild-retroarch-osx-opengl-x64:\n  extends: .build-retroarch-macos-xcode\n  variables:\n    XCARCHIVE_PATH: pkg/apple/build/RetroArchOpenGL\n    XCPROJECT_NAME: RetroArch\n    XCCONFIG: OpenGL_GitLabCI.xcconfig\n\n#build-retroarch-osx-ppc:\n#  stage: build\n#  artifacts:\n#    paths:\n#    - ${XCPROJECT_NAME}.zip\n#    - retroarch-repo/\n#    expire_in: 10 min\n#  dependencies: []\n#  variables:\n#    XCPROJECT_NAME: RetroArch\n#    XCCONFIG: OpenGL_GitLabCI.xcconfig\n#  tags:\n#   - macosx-legacy\n#  script:\n#    - xcodebuild -target RetroArch -configuration Release -project pkg/apple/RetroArch_PPC.xcodeproj ONLY_ACTIVE_ARCH=NO\n#    - pushd pkg/apple/build/Release/\n#    - ditto -c -k --sequesterRsrc --keepParent RetroArch.app ${XCPROJECT_NAME}.zip\n#    - popd\n#    - mv pkg/apple/build/Release/RetroArch.zip ${XCPROJECT_NAME}.zip\n#    - mkdir .retroarch-repo\n#    - \"cp -r ./* .retroarch-repo\"\n#    - \"mv .retroarch-repo/ retroarch-repo/\"\n\nbuild-retroarch-ios-arm64:\n  extends: .build-retroarch-macos-xcode\n  tags:\n    - mac-apple-silicon\n  variables:\n    XCPROJECT_NAME: RetroArch_iOS13\n    XCCONFIG: GitLabCI.xcconfig\n    XCSCHEME: \"RetroArch iOS Release\"\n    XCDESTINATION: \"generic/platform=iOS\"\n  artifacts:\n    paths:\n    - retroarch-repo/\n    expire_in: 10 min\n  script:\n    - xcodebuild -project pkg/apple/${XCPROJECT_NAME}.xcodeproj -destination ${XCDESTINATION} -config Release -scheme \"${XCSCHEME}\" -xcconfig pkg/apple/iOS/${XCCONFIG} build\n    - mkdir .retroarch-repo\n    - \"cp -r ./* .retroarch-repo\"\n    - echo '#define GIT_VERSION ' $(git rev-parse --short HEAD) > .retroarch-repo/.git_version.h\n    - \"mv .retroarch-repo/ retroarch-repo/\"\n\nbuild-retroarch-ios9:\n  extends: .build-retroarch-macos-xcode\n  variables:\n    XCPROJECT_NAME: RetroArch_iOS9\n    XCCONFIG: GitLabCI.xcconfig\n    XCSCHEME: \"RetroArchiOS9\"\n  artifacts:\n    paths:\n    - retroarch-repo/\n    expire_in: 10 min\n  script:\n    - xcodebuild -project pkg/apple/${XCPROJECT_NAME}.xcodeproj -config Release -scheme \"${XCSCHEME}\" -xcconfig pkg/apple/iOS/GitLabCI.xcconfig build\n    - mkdir .retroarch-repo\n    - \"cp -r ./* .retroarch-repo\"\n    - echo '#define GIT_VERSION ' $(git rev-parse --short HEAD) > .retroarch-repo/.git_version.h\n    - \"mv .retroarch-repo/ retroarch-repo/\"\n\nbuild-retroarch-tvos-arm64:\n  extends: build-retroarch-ios-arm64\n  variables:\n    XCSCHEME: \"RetroArch tvOS Release\"\n    XCDESTINATION: \"generic/platform=tvOS\"\n\nbuild-retroarch-dingux-mips32:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-dingux:latest\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n    STRIP_BIN:  1\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - retroarch\n    - retroarch_rg350.opk\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"make -j$NUMPROC -f Makefile.rg350\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.dsp ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n\nbuild-retroarch-dingux-odbeta-mips32:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-dingux:odbeta\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n    STRIP_BIN:  1\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - retroarch\n    - retroarch_rg350_odbeta.opk\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"make -j$NUMPROC -f Makefile.rg350_odbeta\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.dsp ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n\nbuild-retroarch-rs90-odbeta-mips32:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-dingux:odbeta\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n    STRIP_BIN:  1\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - retroarch\n    - retroarch_rs90_odbeta.opk\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"make -j$NUMPROC -f Makefile.rs90\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.dsp ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n\nbuild-retroarch-retrofw-mips32:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-dingux:odbeta\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n    STRIP_BIN:  1\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - retroarch\n    - retroarch_retrofw.opk\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"make -j$NUMPROC -f Makefile.retrofw\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.dsp ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n\nbuild-retroarch-miyoo-arm32:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-dingux:latest\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n    STRIP_BIN:  1\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - retroarch\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"make -j$NUMPROC -f Makefile.miyoo\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.dsp ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f pkg/miyoo/20a-retroarch ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n\nbuild-retroarch-android-normal:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-android:latest\n  stage: build\n  artifacts:\n    paths:\n    - retroarch-precompiled/\n    expire_in: 10 min\n  script:\n  script:\n    - |\n      set -e\n      cd pkg/android/phoenix\n      ./gradlew assembleNormalRelease\n      cd -\n      mkdir .retroarch-precompiled\n      cp -r ./* .retroarch-precompiled/\n      mv .retroarch-precompiled/ retroarch-precompiled/\n\nbuild-retroarch-android-aarch64:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-android:latest\n  stage: build\n  artifacts:\n    paths:\n    - retroarch-precompiled/\n    expire_in: 10 min\n  script:\n    - |\n      set -e\n      cd pkg/android/phoenix\n      ./gradlew assembleAarch64Release\n      cd -\n      mkdir .retroarch-precompiled\n      cp -r ./* .retroarch-precompiled/\n      mv .retroarch-precompiled/ retroarch-precompiled/\n\nbuild-retroarch-android-ra32:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-android:latest\n  stage: build\n  artifacts:\n    paths:\n    - retroarch-precompiled/\n    expire_in: 10 min\n  script:\n    - |\n      set -e\n      cd pkg/android/phoenix\n      ./gradlew assembleRa32Release\n      cd -\n      mkdir .retroarch-precompiled\n      cp -r ./* .retroarch-precompiled/\n      mv .retroarch-precompiled/ retroarch-precompiled/\n\nbuild-retroarch-android-playstore-normal:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-android:latest\n  stage: build\n  artifacts:\n    paths:\n    - retroarch-precompiled/\n    expire_in: 10 min\n  script:\n    - |\n      set -e\n      cd pkg/android/phoenix\n      ./gradlew bundlePlayStoreNormalRelease\n      cd -\n      mkdir .retroarch-precompiled\n      cp -r ./* .retroarch-precompiled/\n      mv .retroarch-precompiled/ retroarch-precompiled/\n\nbuild-retroarch-android-playstore-plus:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-android:latest\n  stage: build\n  artifacts:\n    paths:\n    - retroarch-precompiled/\n    expire_in: 10 min\n  script:\n    - |\n      set -e\n      cd pkg/android/phoenix\n      ./gradlew bundlePlayStorePlusRelease\n      cd -\n      mkdir .retroarch-precompiled\n      cp -r ./* .retroarch-precompiled/\n      mv .retroarch-precompiled/ retroarch-precompiled/\n\nbuild-static-retroarch-libnx-aarch64:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-libnx-devkitpro:latest\n  stage: prepare-for-static-cores\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  retroarch-precompiled/\n    expire_in: 10 min\n  dependencies: []\n  needs:\n    # Static dummy builds without a core so its a good check if it properly builds\n    - build-static-retroarch-dummy-libnx-aarch64\n  script:\n    # Allow failure since we don't have a core\n    - \"make -f Makefile.libnx -j$NUMPROC ||:\"\n    - \"mkdir .retroarch-precompiled\"\n    - \"cp -r ./* .retroarch-precompiled/\"\n    - \"mv .retroarch-precompiled/ retroarch-precompiled/\"\n\nbuild-static-retroarch-dummy-libnx-aarch64:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-libnx-devkitpro:latest\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - retroarch_switch.nro\n    - retroarch_switch.elf\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"make -f Makefile.libnx -j$NUMPROC HAVE_STATIC_DUMMY=1\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f pkg/libnx/retroarch.jpg ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n\nbuild-static-retroarch-psp:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-psp:latest\n  stage: prepare-for-static-cores\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  retroarch-precompiled/\n    expire_in: 10 min\n  dependencies: []\n  needs:\n    # Dummy build requires no core\n    - build-static-retroarch-dummy-psp\n  script:\n    # We need to boostrap before compile\n    - \"(cd bootstrap/psp1/kernel_functions_prx/ && make && cd -)\"\n    # Allow failure since we don't have a core\n    - \"make -f Makefile.psp1 -j$NUMPROC ||:\"\n    - \"mkdir .retroarch-precompiled\"\n    - \"cp -r ./* .retroarch-precompiled/\"\n    - \"mv .retroarch-precompiled/ retroarch-precompiled/\"\n\nbuild-static-retroarch-dummy-psp:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-psp:latest\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - EBOOT.PBP\n    - kernel_functions.prx\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"(cd bootstrap/psp1/kernel_functions_prx/ && make && cd -)\"\n    - \"make -f Makefile.psp1.salamander -j$NUMPROC\"\n    - \"make -C bootstrap/psp1/kernel_functions_prx/\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n    - \"cp -f pkg/psp1/ICON0.PNG ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n    - \"cp -f pkg/psp1/PIC1.PNG ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n\nbuild-static-retroarch-vita:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-vita:latest\n  stage: prepare-for-static-cores\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  retroarch-precompiled/\n    -  retroarch-precompiled-gl/\n    expire_in: 10 min\n  dependencies: []\n  needs:\n    # Dummy build requires no core\n    - build-static-retroarch-dummy-vita\n  script:\n    # Allow failure since we don't have a core\n    - \"make -f Makefile.vita -j$NUMPROC ||:\"\n    - \"mkdir .retroarch-precompiled\"\n    - \"cp -r ./* .retroarch-precompiled/\"\n    - \"make -f Makefile.vita clean\"\n    - \"HAVE_VITAGLES=1 make -f Makefile.vita -j$NUMPROC ||:\"\n    - \"mkdir .retroarch-precompiled-gl\"\n    - \"cp -r ./* .retroarch-precompiled-gl/\"\n    - \"mv .retroarch-precompiled/ retroarch-precompiled/\"\n    - \"mv .retroarch-precompiled-gl/ retroarch-precompiled-gl/\"\n\nbuild-static-retroarch-dummy-vita:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-vita:latest\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  eboot.bin\n    -  param.sfo\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"make -f Makefile.vita.salamander -j$NUMPROC\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -fr pkg/vita/* ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n\nbuild-static-retroarch-ps2:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-ps2:latest\n  stage: prepare-for-static-cores\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  retroarch-precompiled/\n    expire_in: 10 min\n  dependencies: []\n  needs:\n    # Dummy build requires no core\n    - build-static-retroarch-dummy-ps2\n  script:\n    # Allow failure since we don't have a core\n    - \"make -f Makefile.ps2 -j$NUMPROC ||:\"\n    - \"mkdir .retroarch-precompiled\"\n    - \"cp -r ./* .retroarch-precompiled/\"\n    - \"mv .retroarch-precompiled/ retroarch-precompiled/\"\n\nbuild-static-retroarch-dummy-ps2:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-ps2:latest\n  stage: build\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  raboot.elf\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"make -f Makefile.ps2.salamander -j$NUMPROC release\"\n\nbuild-static-retroarch-psl1ght:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-psl1ght:latest\n  stage: prepare-for-static-cores\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  retroarch-precompiled/\n    expire_in: 10 min\n  dependencies: []\n  needs:\n    # Dummy build requires no core\n    - build-static-retroarch-dummy-psl1ght\n  script:\n    # Allow failure since we don't have a core\n    - \"make -f Makefile.psl1ght -j$NUMPROC ||:\"\n    - \"mkdir .retroarch-precompiled\"\n    - \"cp -r ./* .retroarch-precompiled/\"\n    - \"mv .retroarch-precompiled/ retroarch-precompiled/\"\n\nbuild-static-retroarch-dummy-psl1ght:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-psl1ght:latest\n  stage: build\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  retroarch_psl1ght_salamander.elf\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"make -f Makefile.psl1ght.salamander -j$NUMPROC create-salamander\"\n\nbuild-static-retroarch-orbis:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-orbis:latest\n  stage: prepare-for-static-cores\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  retroarch-precompiled/\n    expire_in: 10 min\n  dependencies: []\n  needs:\n    # Dummy build requires no core\n    - build-static-retroarch-dummy-orbis\n  script:\n    # Allow failure since we don't have a core\n    - \"make -f Makefile.orbis -j$NUMPROC ||:\"\n    - \"mkdir .retroarch-precompiled\"\n    - \"cp -r ./* .retroarch-precompiled/\"\n    - \"mv .retroarch-precompiled/ retroarch-precompiled/\"\n\nbuild-static-retroarch-dummy-orbis:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-orbis:latest\n  stage: build\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  retroarch_orbis.self\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"make -f Makefile.orbis -j$NUMPROC HAVE_STATIC_DUMMY=1\"\n\nbuild-static-retroarch-djgpp:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-djgpp-build-container:latest\n  stage: prepare-for-static-cores\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  retroarch-precompiled/\n    expire_in: 10 min\n  dependencies: []\n  needs: []\n  script:\n    # Allow failure since we don't have a core\n    - \"make -f Makefile.dos -j$NUMPROC ||:\"\n    - \"mkdir .retroarch-precompiled\"\n    - \"cp -r ./* .retroarch-precompiled/\"\n    - \"mv .retroarch-precompiled/ retroarch-precompiled/\"\n\nbuild-static-retroarch-ctr:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-devkitpro:latest\n  stage: prepare-for-static-cores\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  retroarch-precompiled/\n    expire_in: 10 min\n  dependencies: []\n  needs:\n    # Dummy build requires no core\n    - build-static-retroarch-dummy-ctr\n  script:\n    # Allow failure since we don't have a core\n    - \"make -f Makefile.ctr -j$NUMPROC USE_CTRULIB_2=1 ||:\"\n    - \"mkdir .retroarch-precompiled\"\n    - \"cp -r ./* .retroarch-precompiled/\"\n    - \"mv .retroarch-precompiled/ retroarch-precompiled/\"\n\nbuild-static-retroarch-ctr-legacy:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-devkitpro:ctr-legacy\n  stage: prepare-for-static-cores\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  retroarch-precompiled/\n    expire_in: 10 min\n  dependencies: []\n  needs: []\n  script:\n    # Allow failure since we don't have a core\n    - \"make -f Makefile.ctr -j$NUMPROC ||:\"\n    - \"mkdir .retroarch-precompiled\"\n    - \"cp -r ./* .retroarch-precompiled/\"\n    - \"mv .retroarch-precompiled/ retroarch-precompiled/\"\n\nbuild-static-retroarch-dummy-ctr:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-devkitpro:latest\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - retroarch_3ds.cia\n    - RetroArch.3dsx\n    - RetroArch.smdh\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"make -f Makefile.ctr.salamander -j$NUMPROC USE_CTRULIB_2=1\"\n    - \"mv -f retroarch_3ds_salamander.cia retroarch_3ds.cia\"\n    - \"mv -f retroarch_3ds_salamander.3dsx RetroArch.3dsx\"\n    - \"mv -f retroarch_3ds_salamander.smdh RetroArch.smdh\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.dsp ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n\nbuild-static-retroarch-wiiu:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-wiiu:latest\n  stage: prepare-for-static-cores\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  retroarch-precompiled/\n    expire_in: 10 min\n  dependencies: []\n  needs:\n    # Dummy build requires no core\n    - build-static-retroarch-dummy-wiiu\n  script:\n    # Allow failure since we don't have a core\n    - \"make -f Makefile.wiiu -j$NUMPROC ||:\"\n    - \"mkdir .retroarch-precompiled\"\n    - \"cp -r ./* .retroarch-precompiled/\"\n    - \"mv .retroarch-precompiled/ retroarch-precompiled/\"\n\nbuild-static-retroarch-dummy-wiiu:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-wiiu:latest\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - retroarch.rpx\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"make -f Makefile.wiiu -j$NUMPROC SALAMANDER_BUILD=1\"\n    - \"mv -f retroarch_wiiu_salamander.rpx retroarch.rpx\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f pkg/wiiu/icon.png ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n    - \"cp -f pkg/wiiu/meta.xml ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n\nbuild-static-retroarch-wii:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-devkitpro:latest\n  stage: prepare-for-static-cores\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  retroarch-precompiled/\n    expire_in: 10 min\n  dependencies: []\n  needs:\n    # Dummy build requires no core\n    - build-static-retroarch-dummy-wii\n  script:\n    # Allow failure since we don't have a core\n    - \"make -f Makefile.wii -j$NUMPROC EXTERNAL_LIBOGC=1 GX_PTHREAD_LEGACY=0 ||:\"\n    - \"mkdir .retroarch-precompiled\"\n    - \"cp -r ./* .retroarch-precompiled/\"\n    - \"mv .retroarch-precompiled/ retroarch-precompiled/\"\n\nbuild-static-retroarch-dummy-wii:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-devkitpro:latest\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - boot.dol\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"make -f Makefile.wii.salamander -j$NUMPROC EXTERNAL_LIBOGC=1 GX_PTHREAD_LEGACY=0\"\n    - \"mv -f retroarch-salamander_wii.dol boot.dol\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.dsp ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f pkg/wii/icon.png ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n    - \"cp -f pkg/wii/meta.xml ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n\nbuild-static-retroarch-ngc:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-devkitpro:latest\n  stage: prepare-for-static-cores\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    -  retroarch-precompiled/\n    expire_in: 10 min\n  dependencies: []\n  needs:\n    # Dummy build requires no core\n    - build-static-retroarch-dummy-ngc\n  script:\n    # Allow failure since we don't have a core\n    - \"make -f Makefile.ngc -j$NUMPROC EXTERNAL_LIBOGC=1 GX_PTHREAD_LEGACY=0 ||:\"\n    - \"mkdir .retroarch-precompiled\"\n    - \"cp -r ./* .retroarch-precompiled/\"\n    - \"mv .retroarch-precompiled/ retroarch-precompiled/\"\n\nbuild-static-retroarch-dummy-ngc:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-devkitpro:latest\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.dsp ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n\nbuild-static-retroarch-emscripten:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-emscripten:latest\n  stage: prepare-for-static-cores\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - retroarch-precompiled/\n    expire_in: 10 min\n  dependencies: []\n  needs:\n    # Dummy build requires no core\n    - build-static-retroarch-dummy-emscripten\n  script:\n    # Allow failure since we don't have a core\n    - \"emmake make -f Makefile.emscripten -j$NUMPROC ||:\"\n    - \"mkdir .retroarch-precompiled\"\n    - \"cp -r ./* .retroarch-precompiled/\"\n    - \"mv .retroarch-precompiled/ retroarch-precompiled/\"\n\nbuild-static-retroarch-dummy-emscripten:\n  image: $CI_SERVER_HOST:5050/libretro-infrastructure/libretro-build-amd64-ubuntu:latest\n  stage: build\n  variables:\n    MEDIA_PATH: .media\n  before_script:\n    - export NUMPROC=$(($(nproc)/3))\n  artifacts:\n    paths:\n    - ${MEDIA_PATH}\n    expire_in: 10 min\n  dependencies: []\n  script:\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"mkdir -p ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg/media\"\n    - \"cp -f libretro-common/audio/dsp_filters/*.dsp ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/audio\"\n    - \"cp -f gfx/video_filters/*.filt ${MEDIA_PATH}/${CI_PROJECT_NAME}/filters/video\"\n    - \"cp -rf pkg/emscripten/libretro ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg\"\n    - \"cp -f media/canvas.png ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg/media\"\n    - \"cp -f media/icon_dark.ico ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg/media\"\n    - \"cp -f media/icon_light.ico ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg/media\"\n    - \"cp -f media/invader_dark.png ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg/media\"\n    - \"cp -f media/invader_light.png ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg/media\"\n    - \"cp -f media/libretro-logo.png ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg/media\"\n    - \"cp -f media/retroarch-16x16.ico ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg/media\"\n    - \"cp -f media/retroarch-16x16.png ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg/media\"\n    - \"cp -f media/retroarch-96x96.png ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg/media\"\n    - \"cp -f media/retroarch.ico ${MEDIA_PATH}/${CI_PROJECT_NAME}/pkg/media\"\n\ntrigger_static-cores:\n  stage: trigger-static-cores\n  needs:\n  - build-static-retroarch-libnx-aarch64\n  - build-static-retroarch-psp\n  - build-static-retroarch-vita\n  - build-static-retroarch-ps2\n  - build-static-retroarch-psl1ght\n  - build-static-retroarch-orbis\n  - build-static-retroarch-ctr\n  - build-static-retroarch-ctr-legacy\n  - build-static-retroarch-wiiu\n  - build-static-retroarch-wii\n  - build-static-retroarch-ngc\n  - build-static-retroarch-emscripten\n  dependencies: []\n  script:\n    # Dummy for now\n    - /bin/true\n"
        },
        {
          "name": ".project",
          "type": "blob",
          "size": 0.7919921875,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<projectDescription>\n\t<name>RetroArch_</name>\n\t<comment></comment>\n\t<projects>\n\t</projects>\n\t<buildSpec>\n\t\t<buildCommand>\n\t\t\t<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>\n\t\t\t<triggers>clean,full,incremental,</triggers>\n\t\t\t<arguments>\n\t\t\t</arguments>\n\t\t</buildCommand>\n\t\t<buildCommand>\n\t\t\t<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>\n\t\t\t<triggers>full,incremental,</triggers>\n\t\t\t<arguments>\n\t\t\t</arguments>\n\t\t</buildCommand>\n\t</buildSpec>\n\t<natures>\n\t\t<nature>org.eclipse.cdt.core.cnature</nature>\n\t\t<nature>org.eclipse.cdt.core.ccnature</nature>\n\t\t<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>\n\t\t<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>\n\t</natures>\n</projectDescription>\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 5.2646484375,
          "content": "# This setting is to prevent travis to launch duplicate builds on PRs\nbranches:\n  only:\n    - master\n    - /^v.*$/\n\n# Use 'generic' to be able to override CC/CXX for clang\nlanguage: generic\n\n# Use a release with a longer normal LTS\ndist: xenial\n\nmatrix:\n  include:\n    - compiler: mingw-x86\n      addons: true\n      env: CROSS_COMPILE=i686-w64-mingw32- CFLAGS=\"-D_WIN32_WINNT=0x0501\"\n    - compiler: mingw-x86\n      addons: true\n      env: C89_BUILD=1 CROSS_COMPILE=i686-w64-mingw32- CFLAGS=\"-D_WIN32_WINNT=0x0501\"\n    - compiler: mingw-x86\n      addons: true\n      env: CXX_BUILD=1 CROSS_COMPILE=i686-w64-mingw32- CFLAGS=\"-D_WIN32_WINNT=0x0501\"\n    - compiler: mingw-x64\n      addons: true\n      env: CROSS_COMPILE=x86_64-w64-mingw32- CFLAGS=\"-D_WIN32_WINNT=0x0501\"\n    - compiler: mingw-x64\n      addons: true\n      env: C89_BUILD=1 CROSS_COMPILE=x86_64-w64-mingw32- CFLAGS=\"-D_WIN32_WINNT=0x0501\"\n    - compiler: mingw-x64\n      addons: true\n      env: CXX_BUILD=1 CROSS_COMPILE=x86_64-w64-mingw32- CFLAGS=\"-D_WIN32_WINNT=0x0501\"\n    - compiler: gcc\n      env: CC=gcc-8 CXX=g++-8\n    - compiler: gcc\n      env: CC=\"gcc-8 --sysroot=/\" CXX=\"g++-8 --sysroot=/\"\n    - compiler: gcc\n      env: C89_BUILD=1 CC=gcc-8 CXX=g++-8\n    - compiler: gcc\n      env: CXX_BUILD=1 CC=gcc-8 CXX=g++-8\n    - compiler: gcc\n      env: DISABLE_MENU=1 CC=gcc-8 CXX=g++-8\n    - compiler: gcc\n      env: DISABLE_NETWORKING=1 CC=gcc-8 CXX=g++-8\n    - compiler: gcc\n      env: DISABLE_OVERLAY=1 CC=gcc-8 CXX=g++-8\n    - compiler: gcc\n      env: DISABLE_CDROM=1 CC=gcc-8 CXX=g++-8\n    - compiler: gcc\n      env: DISABLE_VIDEO_LAYOUT=1 CC=gcc-8 CXX=g++-8\n    - compiler: gcc\n      env: DISABLE_THREADS=1 CC=gcc-8 CXX=g++-8\n    - compiler: gcc\n      env: DISABLE_AUDIOMIXER=1 CC=gcc-8 CXX=g++-8\n    - compiler: gcc\n      env: ENABLE_GLES=1 CC=gcc-8 CXX=g++-8\n    - compiler: gcc\n      env: ENABLE_GLES=1 ENABLE_GLES3=1 CC=gcc-8 CXX=g++-8\n    - compiler: clang\n      env: CC=clang-6.0 CXX=clang++-6.0\n    - compiler: clang\n      env: C89_BUILD=1 CC=clang-6.0 CXX=clang++-6.0\n    - compiler: clang\n      env: CXX_BUILD=1 CC=clang-6.0 CXX=clang++-6.0\n    - os: osx\n      env: CC=clang CXX=clang++\n    - name: OSX OpenGL Make\n      os: osx\n      osx_image: xcode11.2\n      script:\n        - ./configure --enable-opengl --disable-metal\n        - make\n    - language: android\n      # Android builds are only supported on Trusty\n      dist: trusty\n      android:\n        components:\n          - tools\n          - build-tools-29.0.3\n          - android-29\n      install:\n        - echo y | sdkmanager \"ndk-bundle\"\n      before_script:\n        - export ANDROID_NDK_HOME=$ANDROID_HOME/ndk-bundle\n      script:\n        - cd pkg/android/phoenix\n        - ./gradlew assembleNormalRelease\n\njobs:\n  allow_failure:\n    - os: osx\n\nbefore_install:\n  - |\n     if [[ \"$CC\" =~ ^gcc-8.* ]]; then\n       # Install a more recent gcc than the default\n       sudo apt-get install -y g++-8\n     elif [ \"$CC\" = clang-6.0 ]; then\n       # Install a more recent clang than the default\n       sudo apt-get install -y clang-6.0\n     elif [ \"$CROSS_COMPILE\" = i686-w64-mingw32- ]; then\n       sudo update-alternatives --set i686-w64-mingw32-g++ /usr/bin/i686-w64-mingw32-g++-posix\n     elif [ \"$CROSS_COMPILE\" = x86_64-w64-mingw32- ]; then\n       sudo update-alternatives --set x86_64-w64-mingw32-g++ /usr/bin/x86_64-w64-mingw32-g++-posix\n     fi\n\nbefore_script:\n  - |\n     if [ -n \"$CROSS_COMPILE\" ]; then\n       ARGS=\"$ARGS --disable-d3d8 --disable-d3d9 --disable-d3d10 --disable-d3d11 --disable-d3d12\"\n     fi\n  - |\n     if [ -n \"$DISABLE_MENU\" ]; then\n       ARGS=\"$ARGS --disable-menu\"\n     fi\n  - |\n     if [ -n \"$DISABLE_OVERLAY\" ]; then\n       ARGS=\"$ARGS --disable-overlay\"\n     fi\n  - |\n     if [ -n \"$DISABLE_NETWORKING\" ]; then\n       ARGS=\"$ARGS --disable-networking\"\n     fi\n  - |\n     if [ -n \"$DISABLE_CDROM\" ]; then\n       ARGS=\"$ARGS --disable-cdrom\"\n     fi\n  - |\n     if [ -n \"$DISABLE_VIDEO_LAYOUT\" ]; then\n       ARGS=\"$ARGS --disable-video_layout\"\n     fi\n  - |\n     if [ -n \"$DISABLE_THREADS\" ]; then\n       ARGS=\"$ARGS --disable-threads --disable-glslang\"\n     fi\n  - |\n     if [ -n \"$DISABLE_AUDIOMIXER\" ]; then\n       ARGS=\"$ARGS --disable-audiomixer\"\n     fi\n  - |\n     if [ -n \"$ENABLE_GLES\" ]; then\n       ARGS=\"$ARGS --enable-opengles\"\n     fi\n  - |\n     if [ -n \"$ENABLE_GLES3\" ]; then\n       ARGS=\"$ARGS --enable-opengles3\"\n     fi\n  - echo \"Configure arguments = $ARGS\"\n\nscript:\n  - ./configure $ARGS\n  - |\n     if [ -n \"$C89_BUILD\" ]; then\n       make C89_BUILD=1\n     elif [ -n \"$CXX_BUILD\" ]; then\n       make CXX_BUILD=1\n     else\n       make\n     fi\n\nenv:\n  global:\n   - ARGS=\"\"\n   - MAKEFLAGS=\"-j2\"\n   - secure: \"qc91ReC3OlzSh2gFaSH6TYzC2qIQvgA2AZff6J13eaH8xijAhuMzttZ0rMQJ0DWCIhPeUb0kIzVyaGoe4MwPALzpw1C1AznIWiZJ53HN+hWCOcS/af7YVPk6HPySnwqrS+Wv3AIIvIKFV2mxv21F/JbT/N+pArlRrp904Xj+KPo=\"\naddons:\n  apt:\n    packages:\n      - libsdl2-dev\n      - libusb-1.0-0-dev\n      - qtbase5-dev\n      - qtdeclarative5-dev\n    sources:\n      - ubuntu-toolchain-r-test\n      - llvm-toolchain-xenial\n  coverity_scan:\n    project:\n      name: \"RetroArch\"\n      description: \"RetroArch is the official reference frontend for the libretro API.\"\n    notification_email: libretro@gmail.com\n    build_command_prepend: \"./configure; make clean\"\n    build_command:   \"make\"\n    branch_pattern: coverity_scan\nnotifications:\n  email: true\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "10bpc-gl.diff",
          "type": "blob",
          "size": 2.841796875,
          "content": "diff --git a/gfx/drivers_context/wgl_ctx.c b/gfx/drivers_context/wgl_ctx.c\nindex b90a8e40c3..e57c4df194 100644\n--- a/gfx/drivers_context/wgl_ctx.c\n+++ b/gfx/drivers_context/wgl_ctx.c\n@@ -78,6 +78,47 @@\n #ifndef WGL_CONTEXT_DEBUG_BIT_ARB\n #define WGL_CONTEXT_DEBUG_BIT_ARB 0x0001\n #endif\n+\n+#ifndef WGL_ACCELERATION_ARB\n+#define WGL_ACCELERATION_ARB                    0x2003\n+#endif\n+\n+#ifndef WGL_FULL_ACCELERATION_ARB\n+#define WGL_FULL_ACCELERATION_ARB               0x2027\n+#endif\n+\n+#ifndef WGL_DRAW_TO_WINDOW_ARB\n+#define WGL_DRAW_TO_WINDOW_ARB                  0x2001\n+#endif\n+\n+#ifndef WGL_DOUBLE_BUFFER_ARB\n+#define WGL_DOUBLE_BUFFER_ARB                   0x2011\n+#endif\n+\n+#ifndef WGL_RED_BITS_ARB\n+#define WGL_RED_BITS_ARB                        0x2015\n+#endif\n+\n+#ifndef WGL_GREEN_BITS_ARB\n+#define WGL_GREEN_BITS_ARB                      0x2017\n+#endif\n+\n+#ifndef WGL_BLUE_BITS_ARB\n+#define WGL_BLUE_BITS_ARB                       0x2019\n+#endif\n+\n+#ifndef WGL_ALPHA_BITS_ARB\n+#define WGL_ALPHA_BITS_ARB                      0x201B\n+#endif\n+\n+#ifndef WGL_PIXEL_TYPE_ARB\n+#define WGL_PIXEL_TYPE_ARB                      0x2013\n+#endif\n+\n+#ifndef WGL_TYPE_RGBA_ARB\n+#define WGL_TYPE_RGBA_ARB                       0x202B\n+#endif\n+\n #endif\n\n #if defined(HAVE_OPENGL)\n@@ -313,6 +354,43 @@ static void create_gl_context(HWND hwnd, bool *quit)\n          RARCH_LOG(\"[WGL]: Adaptive VSync supported.\\n\");\n          wgl_adaptive_vsync = true;\n       }\n+      if (wgl_has_extension(\"WGL_ARB_pixel_format\", extensions))\n+      {\n+         BOOL (WINAPI * wglChoosePixelFormatARB)\n+         (HDC hdc,\n+                                 const int *piAttribIList,\n+                                 const FLOAT *pfAttribFList,\n+                                 UINT nMaxFormats,\n+                                 int *piFormats,\n+                                 UINT *nNumFormats);\n+         UINT nMatchingFormats;\n+         int index = 0;\n+         int attribsDesired[] = {\n+            WGL_DRAW_TO_WINDOW_ARB, 1,\n+            WGL_ACCELERATION_ARB, WGL_FULL_ACCELERATION_ARB,\n+            WGL_PIXEL_TYPE_ARB, WGL_TYPE_RGBA_ARB,\n+            WGL_RED_BITS_ARB, 10,\n+            WGL_GREEN_BITS_ARB, 10,\n+            WGL_BLUE_BITS_ARB, 10,\n+            WGL_ALPHA_BITS_ARB, 2,\n+            WGL_DOUBLE_BUFFER_ARB, 1,\n+            0,0\n+         };\n+         wglChoosePixelFormatARB = (BOOL (WINAPI *) (HDC, const int *,\n+                  const FLOAT*, UINT, int*, UINT*))\n+            gfx_ctx_wgl_get_proc_address(\"wglChoosePixelFormatARB\");\n+\n+         RARCH_LOG(\"[WGL]: ARB pixel format supported.\\n\");\n+\n+         if (wglChoosePixelFormatARB(win32_hdc, attribsDesired,\n+                  NULL, 1, &index, &nMatchingFormats))\n+         {\n+            if (nMatchingFormats == 0)\n+            {\n+               RARCH_WARN(\"No 10bpc WGL_ARB_pixel_formats found!\\n\");\n+            }\n+         }\n+      }\n    }\n }\n #endif\n"
        },
        {
          "name": "AUTHORS.h",
          "type": "blob",
          "size": 9.4560546875,
          "content": "static const char *retroarch_contributors_list = R\"(\nRetroArch and the libretro team would like to\nacknowledge the following contributors:\n\n1ch (L0sted)\n23rd\n6lackmag3\nA Schain (aschain)\nAaron Oneal (aarononeal)\nAaron Ramirez (aaronbytes)\nAbadede\nAdam Londero (alondero)\nAdam Mechtley (amechtley)\nAdriano de Moura Leite (amlib)\nAdrien Moulin (elyosh)\nAethyrion\najefr\nAKuHAK\nAlberto Alonso Ruibal (albertoruibal)\nAlberto Fustinoni (albertofustinoni)\nAlberto Simon (asimonf)\nAlcaro\naldebaran27\nAleksey Samoilov (Sunderland93)\nAlessandro Mangone (Vektor) (zevektor)\nAlex Folland (AlexFolland)\nAlex Kornitzer (alexkornitzer)\nAlexander Spady (alkaseltzerspadt)\nAlexander Trufanov (trufanov-nok)\nAlexandre Garcia (Alexandre-Garcia)\nAlfredo Monclus (alfrix)\naliaspider\nalphanu1\naltiereslima\nAlwin Garside (Yogarine)\namtz\nAnders Storhaug (andersstorhaug)\nAndre Leiradella (leiradel)\nAndrs (fr500)\nAndy Nguyen (TheOfficialFloW)\nAnthony J. Bentley (bentley)\nAntonio Jose Ramos Marquez (psxdev)\nantonioginer\nApaczer\nAridRayne\nArnaudFaucher\narpruss\narstn\nArtem Polishchuk (tim77)\nArto Vainiolehto (arakerlu)\nasavah\nAsh (ashquarky)\nAshura (CoalaJoe)\nAvton1\nayssia\nBananaRama203\nbarbudreadmon\nBarry Rowe (BarryJRowe)\nBartomiej Burdukiewicz (dev-0x7C6)\nBashar Astifan (basharast)\nbearoso\nBen Hamilton (Ben Gertzfield) (bhamiltoncx)\nbenklop\nbenutzer193\nBernhard Schelling (schellingb)\nblackgur\nbmaupin\nBobby Smith (bslenul)\nBoris Timofeev (btimofeev)\nBrad (SpiralBrad)\nBraden Farmer (farmerbb)\nBrandon Johnson (BinaryFissionGames)\nBreno Dantas Mendona (brenodantas10)\nBrian Hoem (ZornTaov)\nBrian Koropoff (bkoropoff)\nBrian S. Stephan (bsstephan)\nBringerethOfLight\nBrunnis\nbsmith (DogParty)\nbubuleur\nbulzipke\nC.W. Betts (MaddTheSane)\nCasey Borders (CaseyB)\nCatGreen90\nceb33\ncedorg\ncelerizer\nCharlne (julianaito)\nCheezeCake\nChris Merrett (chrisfu)\nChristian Murphy (grimpunch)\nchristianhaitian\nChristoffer Tibell (Brottweiler)\nChristopher Snowhill (kode54)\nchu (9chu)\nChuck Smith (chucksmith)\nCidVonHighwind\nclienthax\ncold-brewed\nColin Kinloch (ColinKinloch)\nCompCom\nComradeEcho\nconfusedguy9\nConn O'Griofa (psyke83)\nConnor McLaughlin (stenzek)\nConrad Kreyling (konistehrad)\nCozmoP\nCpasjuste\ncpsw\nCray Elliott (MP2E)\nCrestwave\nCrewMdk\nCristi Mitrana (cmitu)\nCristian Sandu (crazyquark)\ncrystalct\nCTCaer\ncucholix\ncudencuden\nCyberLabSystems\nDaehan Kim (iAmGhost)\ndalter\nDan Weiss (Dwedit)\ndanieljg\nDaniil Zhilin (LaserMoai)\ndankcushions\nDarren Thompson (DiscoStarslayer)\nDave (freakdave)\nDave Leaver (danzel)\nDavid CARLIER (devnexen)\nDavid Demelier (markand)\nDavid Erickson (daviderickson)\nDavid G. F. (davidgfnet)\nDavid Lawson (dmrlawson)\nDavid Walters (hiddenasbestos)\ndbaronica\nDEX357\ndiablodiab\ndibas\nDiego A. (SuperrSonic)\nDiego Viola (diegoviola)\ndigitalisland-nino\nDiogo Barros (BlueKore)\nDmitry Sergeenkov (DuMOHsmol)\ndor3k\nDoug Christman (dobyrch)\ndriver1998\nDudu Akiva (duduke)\nduganchen\ndukemiller\nduskgao\nDylan Scott (dyscott)\nDystopian\neadmaster\nEduard Strehlau (Herdinger)\nekipan\nElvira Khabirova (parport0)\nembercold\nEmmanuel Martin (daliaetnano)\nEthan Lee (flibitijibibo)\nextrowerk\nEzio-PS\nF (erbridge)\nFabio (Oibaf66)\nFabio Ritrovato (Sephiroth87)\nFayne Aldan (FayneAldan)\nfff (felinben)\nFilipe Azevedo (pasnox)\nFIX94\nFlame Sage (flamesage)\nflyinghead\nFmT0\nfrancescotintori\nFrancisco Javier Trujillo Mata (fjtrujy)\nFrancisco Jos Garca Garca (frangarcj)\nFreeShippingParty\nfuzzydunlops732 (JKoppel93)\nGABO1423\nGabriel (Ghabry)\nGameDragon2k\nGarrett Brown (garbear)\ngatecat (daveshah1)\nGavinDarkglider\ngblues\nGeoffrey Plitt (GeoffreyPlitt)\nGiovanni Cascione (spleen1981)\nGlenn Hevey (hevey)\nGooger\ngordon-fish\ngouchi\nGregor Richards (GregorR)\nGrzegorz Raciborski (graciborski)\nGui Andrade (archshift)\nGuillaume Thiolliere (thiolliere)\nGuo Yunhe (guoyunhe)\nGustavo Maciel Dias Vieira (gmdvieira)\ngvbr\nhadess\nHans-Kristian Arntzen (Themaister)\nHenri Gomez (hgomez)\nHenri Gomez (hgomez-sonarsource)\nHenry Castro (hcvcastro)\nHigor E. (heuripedes)\nhizzlekizzle\nHugo B. (hug0b)\nHugo Hromic (hhromic)\nhunterk\nHyllian\nHyperspaceMadness\ni30817\nim4potato\nImJezze\nbrahim Gngr (igungor)\nJack (jakcron)\nJacob (cubtekki)\nJacob (RegenJacob)\nJacob Patterson (jacobpa)\njacobsson (Roet-Ivar)\nJahed\nJake Stine (jstine35)\nJames Le Cuirot (chewi)\nJames Sexton (Bezier89)\nJamiras\nJan Holthuis (Holzhaus)\nJason Tomsic (plaidman)\nJavier Martinez Canillas (martinezjavier)\nJay McCarthy (jeapostrophe)\njdgleaver\nJean-Andr Santoni (kivutar)\nJean-Paul Mari (djipi)\nJean-Sbastien Guay (Skylark13)\nJeff (jeffbdavenport)\nJeff Sousa (LordeIlluminati)\njess (winneon)\nJesse Talavera-Greenberg (JesseTG)\nJoan Coll Cerdn (johanbcn)\nJob Adrian Salinas Gonzalez (efylan)\nJoe Osborn (JoeOsborn)\nJoel (joel16)\nJoel Puig Rubio (XXLuigiMario)\nJoerg Sonnenberger (jsonn)\nJohannes Schickel (lordhoto)\nJohn Parton (john-parton)\nJohn Regan (jprjr)\nJon Maddox (maddox)\nJonathan (JonnyMe)\nJonathan Relf (jonathanrelf)\nJoohan Lee (losernator)\nJools Wills (joolswills)\nJose Lage Miguez (Joselagem)\nJoseph Carter (knghtbrd)\nJoseph Conan Montgomery (Grotke)\njsd1982 (JamesDunne)\njSTE0\nJuanVCS\nJustin Jacobs (dorkster)\nJustin Weiss (justinweiss)\nJustMeDaFaq\nKangmo-Ahn\nKarl Forshaw (karlforshaw)\nKate Eckhart (katepango)\nKeith Bowes (keithbowes)\nKen Rossato (rossato)\nkikmon\nKopert\nKrzysztof Haadyn (krzys_h) (krzys-h)\nkurumushi\nkwyxz\nl3iggs\nlambolighting\nlasers\nLawrence Kesteloot (lkesteloot)\nLazyBumHorse\nLazyFunker\nLennard Kittner (Lennard599)\nLibretroAdmin\nLionel Flandrin (simias)\nlittleguy77\nliushuyu\nLogan McNaughton (loganmc10)\nlordashram\nLothar Serra Mari (lotharsm)\nLubosz Sarnecki (lubosz)\nlucasmr\nlucianposton\nlxerandrew\nm4xw\nmahoneyt944\nMahyar Koshkouei (deltabeard)\nMai (lioncash)\nMajorPainTheCactus\nmaksun\nManuel Alfayate Corchete (vanfanel)\nMarcelo Munhoz Plos (mpelos)\nMarcus Crisostomo (mcrisostomo)\nmarkwkidd\nMaschell\nMats (Myaats)\nMatt Sephton (gingerbeardman)\nMatthew Bauer (matthewbauer)\nMatthew Wang (asakous)\nMax K. (langerhans)\nMaxime Gauduin (alucryd)\nmeancoot\nmeepingsnesroms\nmeleu\nMerry Mello (merryMellody)\nmicechal\nMichael Burgardt (DisasterMo)\nMichael K. (kuxii2016)\nMichael Lelli (ToadKing)\nmickski56\nMico Chopitea (micochops)\nmiguelpinheiro\nMike Swanson (chungy)\nmikeOSX\nminucce\nmisson20000\nMohmoud (esoptron) (Hedonium)\nMonroe88\nMorgane (MorganeAD)\nmprobinson\nMrHuu\nMrJs (mrjschulte)\nMuhamed Hobi (mmhobi7)\nmuzuiget\nN/A (inactive123)\nNargash\nNathan S. (natinusala)\nNathanStrong-Tripwire\nnattycleopatra\nNaveen (naveensrinivasan)\nnayslayer\nnegativeExponent\nNeil Barkhina (nbarkhina)\nneil4\nnetux79\nnfnty\nnfp0\nnia (alarixnia)\nNicolas Adenis-Lamarre (nadenislamarre)\nNicolas Guillaumin (nguillaumin)\nNicolas Roehm (NicolasRoehm)\nNik (WerWolv)\nNikita Vakhrushev (XF10C)\nNikola Koci (nikola-kocic)\nNikos Chantziaras (realnc)\nNils Hasenbanck (hasenbanck)\nnjordan64\nnosh01\nnot6 (r-type)\nnotaz\nnstCactus\nnurupo\nOggom\nOh Won Sik (dnjstlr555)\nOleg Shevchenko (olsh)\nOmar Saleem (ofsaleem)\nopendata26\nOphidon\norbea\nOschowa\nOsirizX\nOV2\nPalmic (mpalomas)\npamapa\nPaolo Bonzini (bonzini)\nPaul McCarty (notabeatle)\npcjco\nPedro Ferraz (ferrazpedro)\nPedro Ribeiro (pedrib)\nPeter J Kos (pkos)\nPhilippe Simons (loki666)\npinumbernumber\nPiotr Dobrowolski (Informatic)\npjft\nPoligraf\npponso1\npyroesp\nR-YaTian\nRafael Toledo (rafaeltoledo)\nRamiro Morales (ramiro)\nRaphal Zumer (rzumer)\nredenvelope2000\nReid Kleckner (rnk)\nrepojohnray\nretrotails\nrevvv\nreztek\nRichard Howell (rmaz)\nRinnegatamante\nrlnilsen\nRob Loach (RobLoach)\nRobin de Rooij (rrooij)\nRomain Gay (vikbez)\nRomain Graillot (notnotme)\nRomain TISSERAND (rtissera)\nRoman Fomin (rfomin)\nRoman Kalashnikov (lunixoid)\nRoyerson\nrsn8887\nRuben Nine (rnine)\nRyan C. Gordon (icculus)\nRyan Kuba (thelamer)\nRyunam\nrz5\nSage (neonfuz)\nSaggi Mizrahi (ficoos)\nSAKUJ0\nSalvador (salvacam)\nSam (44100hertz)\nSam Lantinga (slouken)\nSam Stenvall (Jalle19)\nSamuel P. (p-sam)\nSanaki\nScheiker\nSean O'Neil (seanocali)\nSebastien Ronsse (sronsse)\nSecularSteve\nSefa Eyeoglu (Scrumplex)\nSergei Nikitin (Kert)\nSergei Trofimovich (trofi)\nSergi Granell (xerpi)\nSergio Padrino (sergiou87)\nsergio-br2 (sergiobenrocha2)\nSeth Kingsley (sethk)\nShadow (ShadowOne333)\nShane Mouton (ismouton)\nshantigilbert\nShfty\nShizeeg Unadequatov (shizeeg)\nSimpleTease\nSindenLightgun\nSirrempat\nslotek\nSoar Qin (soarqin)\nsonninnos\nSou Bunnbu (iyzsong)\nsparklewind\nspec-chum\nStefan (gizmo98)\nstefan-gr\nstellarporter\nStephanie Gawroriski (XerTheSquirrel)\nSteve Cox (stevenjamescox)\nStevoisiak\nstoofin\nStormedBubbles\nstrotlog\nStuart Carnie (stuartcarnie)\nSunguk Lee (d3m3vilurr)\nSupernature2k\nSven (RetroSven)\nSwizzy\nSylvain Colinet (Skarsnik)\nSzunti\nTadek Kijkowski (monkeyman79)\nTatsuya79\nTerry Lewis (terry-au)\nthedax\ntheheroGAC\nTheMrIron2\nThePhxRises\nTheRhysWyrill\nThomas Lorblanchs (Zlika)\nTilman M. Jaeschke (asciibeats)\nTim Van den Langenbergh (tmtvl)\nTobias Gruetzmacher (TobiX)\nTobias Jakobi (tobiasjakobi)\nTodd Laney (ToddLa)\nTom Kelemen (ToKe79)\nTor Arne Vestb (torarnv)\nTorsten Paul (t-paul)\nTotalCaesar659\ntr12345\nTroggleMonkey\ntunip3\ntxorion\nTyler Loch (TylerLoch)\nURBANsUNITED\nvaguerant\nVal Packett (valpackett)\nValerio Proietti (kamicane)\nvgmoose\nViachaslau Khalikin (viachaslavic)\nVicki Pfau (endrift)\nVicky C Lau (vickychenglau)\nvin (suseme)\nVincent Pelletier (vpelletier)\nVladimir Panteleev (CyberShadow)\nVladimir Serbinenko (phcoder)\nVctor \"IlDucci\" (IlDucci)\nwaitingmoon\nWarning: Non-Potable Water (warningnonpotablewater)\nwebgeek1234\nWeedy Weed Smoker (WeedyWeedSmoker)\nwhorsemaster\nWiimpathy\nWiktor Strzbaa (wiktorek140)\nWoohyun Shin (sinusinu)\nxenomorph-us\nxhp-creations\nYari (hyarsan)\nyesfish (huwpascoe)\nYongwoon Cho (ssangkong)\nyoshisuga\nZer0xFF\nzeromus\nzlice\nrico Nogueira Rolim (ericonr)\nmercan Kmr (fpscan)\n (cxd4)\n)\";\n"
        },
        {
          "name": "CHANGES.md",
          "type": "blob",
          "size": 252.173828125,
          "content": "# Future\n- AUDIO/PIPEWIRE: Fix app launch when pipewire service is stopped\n- GENERAL: Fix save state auto increment\n- GENERAL: Fix softpatching with periods/dots in the file name\n- GENERAL: Fix compilation with --enable-videocore\n- MENU: Add SSL support to the information list\n- IOS: Ensure webserver notice can be dismissed\n- VIDEO/SHADERS: Allow exact refresh rate sync with shader subframes\n\n# 1.20.0\n- AUDIO: Fix audio handling in case of RARCH_NETPLAY_CTL_USE_CORE_PACKET_INTERFACE\n- AUDIO: Include missing audio filters on some platforms\n- AUDIO/PIPEWIRE: Add PipeWire audio driver\n- AUDIO/PIPEWIRE: Add PipeWire microphone driver\n- APPLE: Hide threaded video setting\n- APPLE: Use mfi joypad driver by default\n- APPLE: Include holani, noods, mrboom, yabause, bsnes-jg core in App Store builds\n- CHEEVOS: Add rarity and points to achievement unlock widget\n- CHEEVOS: Add rank to leaderboard submission notification\n- CHEEVOS: Update to rcheevos 11.5\n- CHEEVOS: Update to rcheevos 11.6\n- CHEEVOS: Show rcheevos game image in Discord rich presence\n- CHEEVOS: Use translated strings for achievement messages\n- CLOUDSYNC: Allow saves and configs to be synced optionally\n- CLOUDSYNC: Add iCloud cloud sync driver\n- CLOUDSYNC: Speed up by upload/download in parallel\n- CLOUDSYNC: Allow thumbnails and system dir to be synced optionally\n- CLOUDSYNC: Enable CloudSync on Android (non-SSL)\n- CLOUDSYNC: Add more logs in failure situations\n- CLOUDSYNC: Fixes for reauthentication and parallel sync\n- CLOUDSYNC: Fixes for file resurrection\n- CLOUDSYNC: Enable CloudSync on Windows\n- CRT/SWITCHRES: Update switchres to 2.2.1\n- GENERAL: Support for mbedtls v3\n- GENERAL: Automatic Frame Delay refactor\n- GENERAL: Remove Frame Rest, obsoleted by Frame Delay refactor\n- GENERAL: Wrap around auto increment save state indexes when amount of states is limited\n- GENERAL: Enable CHD hashing for Switch and DOS\n- GENERAL: Enable auto save state when new content is loaded\n- GENERAL: Improve Preemptive Frames when pointing device is used\n- GENERAL: Fix building with menu disabled\n- HAIKU: Restore Haiku build\n- INPUT: Allow to select a preferred/reserved device for each player\n- INPUT: Enable Caps, Num, Scroll Lock modifiers on multiple platforms\n- INPUT: Autoconfig extension with alternative name/vid/pid\n- INPUT: Fix autoconfig profile saving when device is not in the default port\n- INPUT: Change classic turbo mode to work independently of which key was pressed first\n- INPUT: Pointer and lightgun handling sanitization on Windows and Linux desktop platforms. These input drivers will now report edge and offscreen positions in a harmonized way, and will not return 0 instead.\n- INPUT/DINPUT: Fix detection of quick shift key presses\n- INPUT/HID: Fix crash on macOS when disconnecting the controller a second time\n- INPUT/LINUX: Add illuminance sensor support to the linuxraw, sdl2, udev, and x11 input drivers\n- INPUT/Remaps: Sort and apply remaps based on the specific connected controller\n- INPUT/UDEV: Enable mouse buttons 4 and 5\n- INPUT/WAYLAND: Enable horizontal scroll and mouse buttons 4 and 5\n- INPUT/WAYLAND: Simulate lightgun input for cores\n- INPUT/WAYLAND: Support for cursor-shape-v1 protocol\n- INPUT/X11: Enable mouse buttons 4 and 5\n- iOS: Enable vibration by default\n- iOS: Better handling of physical mice/magic keyboard trackpad\n- iOS: Mouse grab fixes\n- iOS: Fix mouse cursor movement when button is held down\n- iOS: Fix microphone support request and entitlement\n- iOS: Enable compilation back to iOS 12\n- iOS: Fix OpenGL ES context usage on iOS 9\n- iOS/TVOS: Add Opera to App Store build\n- iOS/TVOS: Bring NEON defines in line with ARM64\n- iOS/TVOS: Flush save files on backgrounding\n- LIBRETRO: Support RETRO_ENVIRONMENT_GET_FILE_BROWSER_START_DIRECTORY\n- LIBRETRO: Support \"/\" as a file extension for loading a directory as content\n- FFMPEG: Fix crash when playing back a file with 96 kHz audio\n- MACOS: New display server, including support for ProMotion 120Hz V-Sync\n- MACOS: Create App Store build\n- MACOS: Generate key up events for command keys\n- MIDI: Fix long messages (SysEx) in WinMM driver\n- MIDI: Fix lingering notes on close in Alsa driver\n- MENU: Support local thumbnails in other image formats than png (jpg/jpeg, bmp, tga)\n- MENU: Delete also savestate thumbnails when savestates are garbage collected\n- MENU: Option to disable analog stick menu navigation\n- MENU: Fix pause toggle to not clear fast forward state\n- MENU: Fix search playlist index in XMB/Ozone\n- MENU: Fix renamed entry display\n- MENU: Filter unknown extensions also inside zip files\n- MENU: Add icons for present / missing firmware on core info page\n- MENU: Ignore other hotkeys when menu toggle is pressed\n- MENU: Fix menu jumping when using L3+R3 combo\n- MENU: System Information now only shows features relevant for the platform\n- MENU/GLUI: Make Show Sublabels options effective\n- MENU/GLUI: Icon fixes\n- MENU/XMB: Allow playlist icons to be individually customized, by looking for images in Named_Logos\n- MENU/OZONE: Add Selenium theme for Ozone\n- MENU/OZONE: Touchscreen improvements\n- MENU/OZONE: Add a touch-sensitive Resume button in the lower right corner\n- NETPLAY: Add East Asian relay server\n- OVERLAY: Add option to load overlay based on system name\n- PS2: Fix several broken cores depending on pthread\n- QT: Enable building with Qt6\n- QT: Fix input panel\n- RECORDING: New WAV recording driver (audio only)\n- REMOTE RETROPAD: Add gyro/acceleration/light sensor test screen\n- REMOTE RETROPAD: Add pointer test screen\n- REPLAY: Replay format extended to support external tools\n- TVOS: Support bluetooth keyboards on tvOS\n- TVOS: Fixes to run correctly on TVOS13\n- TVOS: Better handling of Siri remote\n- TVOS: WebDAV server for adding files more easily\n- TVOS: Add Settings.app option to reset retroarch.cfg\n- TVOS: Bring minimum tvos version down to 13.0\n- VIDEO: Show and use exact refresh rate (3 decimals) and interlace/doublestrike where available\n- VIDEO: Allow setting viewport bias to offset viewport horizontally/vertically\n- VIDEO: Support viewport bias also with integer overscale and custom aspect ratios\n- VIDEO: Use shader path from CLI for shader cycling\n- VIDEO: Pixel perfect integer scaling improvements: axis options, smart mode\n- VIDEO: Add upscale 1.66x filter\n- VIDEO/D3D: Fix GPU screenshots\n- VIDEO/KMS: Force fullscreen when KMS is used\n- VIDEO/OpenGLES: Improve version directive granularity\n- VIDEO/SHADERS: Fix memory leak when shader parameter step is 0.0\n- VIDEO/SHADERS: Add 2 uniforms, OriginalAspect and OriginalAspectRot.\n- VIDEO/SHADERS: Add CoreFPS and FrameTimeDelta uniforms.\n- VIDEO/SLANG: Support optional includes\n- VIDEO/VULKAN: Fix Vulkan window freezes when swapchain becomes suboptimal\n- VIDEO/VULKAN: Prefer IMMEDIATE mode without vsync\n- VIDEO/X11: Support inhibit of Xss screensaver\n- VIDEO/WAYLAND: Support for content-type-v1 protocol\n- VITA: Enable analog L2/R2 triggers when a DS3 controller is used with PS Vita\n- WAYLAND: Fix segfault when relative pointer is not supported\n- WAYLAND: Use reverse DNS name for desktop file and icon\n- WAYLAND: Commit viewport resizes for more responsive display when resizing window\n- WINDOWS: Fix restart if path to executable contains non-ASCII symbols\n- WINDOWS: Hide directories starting with $ from file browser\n\n# 1.19.1\n- (WASAPI) Only write when running and fix deadlock\n\n# 1.19.0\n- AI: Revert AI translation to previous version (fix for translation not working with HW rendered cores)\n- APPLE: Try to use system preferred language\n- APPLE: Correctly register for filetypes uniquely\n- APPLE/MFI: improved Switch Online controller support through MFi\n- AUDIO: Bring back audio toggling on menu toggle\n- CHEEVOS: Build a default RetroAchievements memory map when no RetroAchievements game is loaded\n- CHEEVOS: Update to rcheevos 11.3\n- CHEEVOS: fix hardcore acting as if it's enabled when it isn't\n- CLANG: Fix clang error incompatible-pointer-types-discards-qualifiers\n- CLOUDSYNC/LINUX: Enable Cloud Sync by default on Linux builds with network (#16456)\n- CLOUDSYNC/WEBOS: Enable Cloud Sync by default on Linux builds with network (#16456)\n- CORE: Set compute fps stats logging to debug level\n- EMSCRIPTEN: Added M2000 to core selection dropdown\n- FFMPEG: Add compatibility with FFMPEG 7.0\n- GLSLANG: Remove unneeded ENABLE_HLSL code from glslang\n- GENERAL: Memory leak: Dynamic allocation from msg_hash_get_help_us_enum was not freed.\n- INPUT/KEYBOARD: Add support for multimedia keys - Extended RETROK_ values with 18 new items, commonly found on\n\"multimedia\" keyboards. Mapping added for SDL, X11, Wayland, dinput, winraw keymaps.\n- INPUT/MFI: Pressure sensitive left/right triggers\n- INPUT/MFI: Fix Start + L1/L2/R2 combinations\n- INPUT/MFI: Support strong and weak rumble\n- INTL: Fetch translations from Crowdin\n- INTL: Add Galician and Norwegian to list of languages\n- LAKKA: Display reboot/shutdown message also when not saving config on exit\n- LAKKA: Provide update URL and target name at buildtime\n- LIBRETRO: Add a debug message for the SET_ROTATION callback\n- macOS: Default Accessibility on if VoiceOver is on\n- iOS: default audio sync on again, also more mfi logging\n- iOS: Fix Import Content\n- iOS: Fix ios-arm64 nightly build crash\n- iOS: Import content from iCloud\n- iOS: Fix #16485 crash on startup\n- iOS: Display app icon in app icon picker in materialui\n- iOS/tvOS: Various QoL improvements\n- iOS/tvOS: Fix a couple more path name mangling bugs\n- iOS/tvOS: Better way of packaging Frameworks\n- iOS/tvOS: define PACKAGE_VERSION to be App Store MARKETING_VERSION\n- iOS/tvOS: Fix keyboard handling for app store builds\n- iOS/tvOS: Fix escaping the sandbox for jailbroken devices\n- iOS/tvOS: default accessibility on if voice over is enabled\n- iOS/tvOS: better way of reporting available memory\n- macOS/iOS/tvOS: enable text-to-speech using AVSpeechSynthesizer.\n- tvOS: Fix scaling for 720p\n- MENU: New function in Quick Menu: Add to Playlist\n- MENU/XMB: New theme: FlatUX, designed to merge FlatUI and Retroactive themes into a single, unified design\n- NETWORKING/RETROPAD CORE:  Fix socket close method\n- PIXMAN: Update pixman-private.h - patch to fix build issue with musl\n- PLAYLIST: Cleanup 'Add to Playlist' (#16495)\n- SCANNING: Fix for scanning PSP ISOs (and probably few others)\n- SAVES: Fix core config saving\n- SAVES: Fix save new config name when core loaded\n- SAVESTATES: Increase save state chunk size for all platforms - Even a class 6 or class 10 SD card can handle reads and writes on the order of MB/s, which means a 4KB chunk size is just wasting time in syscalls.  This could maybe be fixed with a buffering reader but I don't feel comfortable tweaking libretro-common's VFS to handle that.  Instead, I thought it would be good to both remove an ifdef and increase the chunk size to 128KB.  For cores with small states this will should make state saving virtually instantaneous, and for cores with large states it should be a 32x speedup.\n- VIDEO: Fix crash when using threaded video - for Mesa 23.2 and later\n- VIDEO/GL: Fix reinitialization of the threaded gl drivers\n- VIDEO/VULKAN: Add support for A2R10G10B10 HDR format\n- VIDEO/VULKAN: Implement HDR readback - screenshot support\n- WAYLAND: Ignore configure events during splash (fix not remembering window size)\n- WAYLAND: Use frontend signal handler to quit (fix quit by window close)\n- WAYLAND: Commit viewport resizes (window resize is more responsive)\n- UWP: Align MESA to alpha-2-resfix - Remove wrong resolution special handling for OPENGL\n- UWP: 4K fix: align MESA reading of ClientRect to retroarch procedure, this fixes max resolution being set to 1080p. As reading must be done inside an UI thread and is in fact an async operation which might delay frame generation, the reading itself is doen once and cached, give that changing resolution while the app is running is an unlikely corner-case use\n- WINDOWS: Windows mouse ungrab must release the mouse instead of confine it to the current desktop (#16488)\n- WINDOWS: Fix numlock/pause key release events\n\n# 1.18.0\n- AI: Fix narrator language when AI translation and menu languages are different\n- DISK CONTROL: Add option to disable initial disk change\n- DISK CONTROL: Visibility option for disk control notifications\n- DRM: Fix mode vrefresh calculation. When using an interlaced/doublescan mode, the vertical refresh rate is mis-calculated.\n- EMSCRIPTEN: Fix mouse Y parameter translation in rwebinput\n- INPUT: Fix input state combos including R3 and false triggers of RETROK_UNKNOWN\n- INPUT: Add a new turbo mode, \"Classic (Toggle)\"\n- INPUT: Fix bind hold when axis does not rest at 0\n- INPUT: Limit axis threshold setting to sensible values\n- INPUT: Add Overlay Mouse, Lightgun, and Pointer\n- INPUT/ANDROID: Fix mouse grab behavior on Android\n- INPUT/LINUXRAW: Fix device name and hotplug reconnect\n- IOS: Minor iOS JIT availability information\n- IOS/TVOS: Pause application on applicationWillResignActive\n- LIBRETRO: Add Doxygen-styled comments to parts of the libretro API\n- LUA: Update Lua to version 5.3.6\n- MENU: Add sublabels for input bind common entries\n- MENU: Don't load history and favorites if size is 0\n- MENU: Don't disable fast forward when entering menu\n- MENU: Widget position, size, color, icon adjustments\n- MENU: Fix savestate slots in Qt UI\n- MENU: Reorder and reduce depth of User Interface menu\n- MENU/OZONE: Fix sidebar wraparound, visibility after config load, crash after playlist delete\n- MENU/OZONE: Fix sidebar and sublabel animations\n- OSX/MACOS: Fix crash on non-Metal build\n- OSX/MACOS: Add portable.txt as flag for portable install\n- REMOTE RETROPAD: add display for analog axes, indication of inputs already pressed\n- SAVES: Allow combining saves in content dir with save sorting\n- SHADER: Added rolling scan line simulation based on the shader subframe feature. This is implemented with a scrolling scissor rect rather than in the shader itself as this is more efficient although may not work for every shader pass - we may need an option to exclude certain passes. The implementation simply divides the screen up by the number of sub frames and then moves the scissor rect down over the screen over the number of sub frames\n- TVOS: Force asset re-extraction when cache is deleted\n- TVOS: Add history and favorites to Top Shelf\n- TVOS: Fix crash when history item does not have a label\n- UWP: Enable HAVE_ACCESSIBILITY for UWP builds\n- UWP: Allow UWP build to work with a modified version of Mesa Gallium D3D12\n- VIDEO: Add subframe shader support for Vulkan/GLcore/DX10-11-12, enabling shaders to run at higher framerate than the content\n- VIDEO: Fix restoring fullscreen/windowed setting when unloading override\n- VIDEO/VULKAN: Fix HDR with Vulkan after reinit\n- VIDEO/VULKAN: Remove the use of oldSwapchain\n- VIDEO/GL2: Fix OpenGL ES version detection\n- WEBDAV: Fixed SEGFAULT in WebDav task sync + type changes\n- WEBOS: Fix build, add core location on webosbrew.org\n- WIN32: Fix Alt+Enter not working when menubar is disabled\n\n# 1.17.0\n- ACCESSIBILITY/TTS: fix target language and missing espeak handling on Linux\n- AI: AI service reworked: performance increase, automatic translation, configurable subtitle placement, and more\n- APPLE: Fix WebDAV crash with digest auth (Cloud Sync)\n- APPLE: Cloud sync fixes - ignore .DS_Store files and re-sync on app foreground\n- APPLE: Don't re-create default directories\n- APPLE: Show Git information correctly\n- AUDIO/SYNC: Handle Hz skew adjustment for high refresh rates better (BFI, swap interval)\n- AUDIO/MIXER: Separate ffmpeg/mpv and audiomixer conditionals\n- AUDIO/WASAPI: Reworked shared buffer operation for more flexibility, fixed exclusive mode last buffer looping when entering menu\n- CONFIG/OVERRIDES: Fix setting savefile_directory in override file\n- CONFIG: Force fixed locale for numbers\n- CHEEVOS: Upgrade to rcheevos 11.0\n- CHEEVOS: Use rc_client for state management\n- CHEEVOS: Don't track disc changes when achievements are disabled\n- CHEEVOS: Reinitialize rewind buffer after loading game with achievements\n- CHEEVOS: Inform user when server is unreachable\n- CHEEVOS: Fix crash on first load of game with achievements with threaded video\n- EMSCRIPTEN: Increase chunk size for reads/writes\n- EMSCRIPTEN: Modularize the JavaScript and clean up the web build\n- EMSCRIPTEN: Prefix core name with libretro_ for exports\n- EMSCRIPTEN: replace dashes with underscores in corenames (fix for vitaquake cores)\n- EMSCRIPTEN: Use ZipFS for web player asset bundle\n- EMSCRIPTEN: Change default audio rate to 44100\n- IOS: Fix widget on IOS17\n- IOS: Exit instead of crash on some errors\n- IOS: Fix ios-vulkan-ppsspp\n- IOS: Enable HDR support on IOS\n- IOS: Add option to disable respecting silent mode\n- IOS: Allow ignoring safe area (fullscreen over notch)\n- IOS: Default to not enabling keyboard gamepad\n- IOS: Fix XRGB8888 in GL driver\n- IOS: Allow changing the app icon\n- IOS: Add HAVE_ACCESSIBILITY to iOS builds\n- IOS/TVOS: Create GL context as GLES3 to fix some rendering performance problems\n- INPUT: Fix ghost input when setting RETROK_UNKNOWN\n- INPUT: Default 'Bind Hold' to 0 to prevent problems with controllers not resting at null state\n- INPUT: Add a setting to allow turbo d-pad directions\n- INPUT: Don't save mouse buttons to autoconfig\n- INPUT/MENU: Add option for merging 'Hotkey Enable' device types\n- INPUT/mFI: disable secondary_joypad to prevent issues with controllers detected both as HID and mFI\n- INPUT/UDEV: Change event detection to polling in udev_joypad\n- INPUT/WAYLAND: Use unaccelerated pointer motion to prevent mouse dead zone\n- LAKKA: Add new menu options for Switch (overclock, CEC, BT ERTM)\n- LIBRETRO: Add environment command to get playlist path\n- LIBRETRO/NETPACKET:\nSwitch environment call number from 76 to 78 (retire 76 as it was never used by any core)\nSimplify broadcasts by removing the option to send to all but one client, use an explicit RETRO_NETPACKET_BROADCAST constant instead\nSeparate explicit flushing and querying of incoming packet into two operations\nEnable a core to specify a protocol version string which can get used instead of core version to determine compatibility between two players\nLog and notify a separate message when there is a content crc mismatch while using this interface to convey it being less severe\n- MENU: Fix menu analog stick navigation (1.16.0.1)\n- MENU: Add option to find thumbnail images by playlist rom filename (1.16.0.2)\n- MENU: Don't process menu events while input is being flushed (1.16.0.2)\n- MENU: Prevent proceeding to next bind when single binding (1.16.0.3)\n- MENU: Fix touchscreen menu false positives in case of overlap\n- MENU: Sort playlists ignoring extension (Playstation 2 should come after Playstation)\n- MENU: Treat System Volume Information folder as hidden on all platforms\n- MENU: Add Belarusian language option\n- MENU: Fix savestate thumbnail behavior when navigating back to playlist while content is still running\n- MENU: Fix word wrapped widget length\n- MENU: Add help text to controller drivers\n- MENU: Fix quit on content close option\n- MENU: Fix thumbnails in History for content loaded through Load Content\n- MENU: Flexible thumbnail matching (ROM name - database name - short name)\n- MENU: Remove legacy thumbnail pack downloader\n- MENU/GLUI: Icon corrections\n- MENU/OZONE: Thumbnail related fixes (missing thumbnail bar, fullscreen thumbnail flashing, sidebar focus)\n- MENU/RGUI: Fix text scaling in 16:9\n- MENU/XMB: Background images take precedence over color themes, default image opacity set the same as color theme opacity\n- MENU/XMB: Fix segmentation fault when background image is missing\n- MENU/XMB: Several corrections and cleanups\n- MENU/XMB: Layout/thumbnail fixes - Thumbnail layout adjustments, Header title improvements, Handheld layout adjustments\n- NETWORKING/NETPLAY: Add support for joining MITM servers from command line\n- NETWORKING/NETPACKET: Interface connection flow improvements\n- OSX: Fix mouse support for MelonDS DS on OSX\n- OSX: Option to create a portable build\n- PATCHES: Add support for XDelta-formatted patches.\n- PATCHES: Fix patching for cores that support contentless mode\n- PS2: Fix for no sound\n- PS2: Fix 0-byte logs and add memory stats\n- PSP: Fix memory leak in audio driver\n- RUNLOOP: Frame Rest, experimental sleep feature aiming to lower CPU usage and temperature when using certain CPU hungry vsync modes\n- RPI: Fix videocore + switchres compile failure\n- SCAN: Do CRC check on PSP/PSP(PSN) content\n- TVOS: Enable overlay support\n- VIDEO/BFI: Black Frame Insertion added to DirectX10/11/12. BFI Hz range now covers every 60hz multiple under 1000hz. Variable Strobe length via new 'Dark Frames' option, algorithm to auto select 'decent' Dark Frames choice.\n- VIDEO/GLSL: Add FinalViewportSize support to GLSL\n- VIDEO/GLSL: Change rotation type to int to maximize compatibility\n- VIDEO: Use video refresh rate instead of core refresh rate for menu frame limiting\n- VIDEO: Limit paused video refresh rate\n- VIDEO: Enforce swap interval 1 in menu if vsync is on\n- WII: Enable Cheevos for Wii builds\n- WIIU: Fix config file and core info reading\n- WIIU: Fix \"Up\" and \"Left\" directional input for both Analog sticks for GC Adapter\n- WIIU: Fix 3 USB controllers (NES/SNES/Retrode)\n- WIIU: Fix file descriptor leak\n- WIN32: Prefer D3D11 and WASAPI as default video and audio drivers\n- WIN32: Fix window size when aspect ratio is < 0\n- WIN32: Fix screen resolution always tied to the main monitor\n- WAYLAND: Enable fallback for screensaver inhibit via D-Bus\n- WAYLAND: Introduce wp_fractional_scale_v1 protocol for proper fractional scaling\n- WAYLAND: Update wayland-protocols version to 1.31\n\n# 1.16.0\n- 3DS: Update __system_initArgv\n- 3DS: Update SquirrelJME 3DS Core information along with icons.\n- ANDROID: Rewrite input handling to better support AINPUT_SOURCE_STYLUS\n- ANDROID: Prevent the android quick tap mouse click emulation while pressing a button on the on-screen overlay\n- AUDIO: Fast-Forward Audio Resampling\n- AUDIO: Reinit audio on audio sync toggle\n- AUDIO: Count audio samples in stats when rate control is disabled\n- AUDIO/PULSEAUDIO: Support device list for PulseAudio\n- AUDIO/WASAPI: WASAPI Frame Delay fix + cleanups\n- AUDIO/WASAPI/MIDI: Frame Delay correction\n- ARCHIVE/ZIP: Improve ZIP decompression\nThis reduces the amount of memory Retroarch needs to extract a ROM file.\nIt will only need the size of the ROM plus 128KiB to extract the file\nfrom the ZIP. Previously it needed as much as twice that amount if the\ncompression ratio was not great. This is useful on memory constrained\nplatforms and has no impact on platforms with plenty of memory.\nHandles all cases correctly (with and without MMAP, for cores that\nrequire fullpath or not, small and big ZIP files).\n- APPLE: Add default keyboard overlay directory to platform_darwin\n- APPLE: Update to MoltenVK 1.2.4\n- APPLE: Don't include MoltenVK library in Load Core menu list\n- APPLE: Enable AltServer JIT for builds installed by Xcode\n- APPLE: The default pthread stack size on Apple is too small for detect_ps2_game, so increase it\n- APPLE: Introduce Cloud Sync via a WebDAV service on iOS/TVOS/MacOS\n- CHEEVOS: Upgrade to rcheevos 10.7\n- CHEEVOS: Don't initialize rcheevos memory unless used\n- CHEEVOS: Add progress tracker widget\n- CHEEVOS: Eliminate leaderboard tracker stutter\n- CHEEVOS: Expand leaderboard visibility settings\n- CHEEVOS: Collapse trackers with same value definition\n- CHEEVOS: prevent frame step when hitting rewind button while paused in hardcore\n- CHEEVOS: disallow video_swap_interval and black_frame_insertion in hardcore\n- CRT/SWITCHRES: Don't always force core aspect ratio\n- CRT/SWITCHRES: Fix aspect ratio for tate games on a horizontal screen\n- CRT/SWITCHRES: Add PAL threshold option for automatic refresh rate switch\n- CRT/SWITCHRES/KMS: Add KMS modeswitch\n- COMMAND: Make cmd interface more useful for replay information\n- CONFIG: Allow all systems to check for backslashes (Windows) as last slash in path. Improves portable core logic\n- D3D11: Fix memory corruption in d3d11_gfx_init\n- D3D12: Enable blending when drawing the menu\n- D3D12: Move fence signaling out of d3d12_gfx_sync\n- D3D12/LIBRETRO: Add D3D12 HW_render support\n- DOWNLOADS/THUMBNAILS: Prevent directory creation on bogus thumbnail downloads\n- EMSCRIPTEN: Fix Emscripten sleep function/macro\n- EMSCRIPTEN/RWEBAUDIO: Fix RWebAudioInit race condition\n- EMSCRIPTEN/OPENAL: Make openal default audio driver\n- FFMPEG: Fix RetroArch fails to restart streaming when video re-inits and instead starts recording\n- FRAMESKIP: Use refresh rate instead of core fps for frameskip timing\n- INPUT: Combo hold + 'enable_hotkey' correction. Fixed issue with having menu toggle hold combo in different button than 'enable_hotkey', which caused 'enable_hotkey' to also act as menu toggle if held long enough, and simplified and unified duplicate code in start+select holds to a single function.\n- INPUT: input_keyboard_event: Don't check hotkey binds when device is RETRO_DEVICE_POINTER\n- INPUT: Add input_keymaps_translate_rk_to_ascii() for correct character input to input_keyboard_event\n- INPUT: input_overlay_poll: Delay clearing INPUT_OVERLAY_BLOCKED flag until there is no overlay input (Avoids stray input after osk_toggle)\n- INPUT: Send keyboard events for modifiers before other keys (for correct modifier+key input if hitboxes overlap)\n- INPUT: Remember currently set keyboard mapping bits during same config read, because otherwise customized keybinds can get cleared out of the bits on the next iteration, causing keyboard events to get passed to the core when they should get blocked.\n- INPUT/AUTOCONFIG: Reinit after updating autoconf profiles\n- INPUT/LINUX/UDEV: Log mouse devices in info level\n- INPUT/LINUX/UDEV: First working version of udev driver with touchscreen support and gestures.\n- INPUT/WAYLAND: Add wayland to input driver list\n- INPUT/MENU: move port X binds into retropad binds submenu and add appropriate help text and sublabels to discourage people from messing around in there unnecessarily\n- INPUT/MENU: Add menu icons to 'RetroPad Binds'\n- INPUT/MENU/OSK: Allow more keyboard actions with menu osk\n- INPUT/REMAP: Remap label fix when no autoconf profile active\n- INPUT/REMAP: Add 'Save As' option for remaps and overrides\n- INPUT/OVERLAY: Add overlay parameter to control x/y separation in auto-scale mode\n- INPUT/OVERLAY: Revive/rewrite Keyboard Overlay and OSK Toggle. Add keyboard overlay preset, keyboard submenu,\nand osk_toggle hotkey. Use overlay caching for osk_toggle.\n- INPUT/OVERLAY: Overlay Caching. Adds overlay_cache_ptr to keep a disabled overlay in memory when it's expected to be shown again.\nMost input_overlay_deinit calls are replaced with input_overlay_unload, which caches the overlay unless initing/deiniting core or disabling overlays.\nLoading a cached overlay is done as a swap, intended for osk_toggle.\n- INPUT/OVERLAY: Add input_overlay_check_mouse_cursor() to preserve show/hide mouse behavior\n- INPUT/OVERLAY: Don't apply input_overlay_show_mouse_cursor in windowed mode (controlled by mouse grab only)\n- INPUT/REMAPPING: Stop always reseting to defaults on remap delete\n- INPUT/SDL: Fix rumble on PS4/PS5 controllers connected via bluetooth\n- IOS: JIT support in iOS\n- IOS: Use AltKit to try to enable JIT on iOS\n- IOS: Fix thumbnails in history on iOS\n- IOS: Enable option to rumble iOS device instead of controller\n- IOS: Fix including audio/video filters on iOS\n- IOS: Haptic feedback for overlay on iOS\n- IOS: On iOS, stop/start audio on interruptions\n- IOS: Add accelerometer and gyroscope sensors to iOS\n- IOS: iOS needs to targets 13 due to some keyboard emulation, but tvOS does not\n- IOS/TVOS: Rework JIT availability checks\n- IOS/TVOS: When updating playlist with detected core path, used resolved core path\n- IOS/TVOS: Implement memory queries on iOS/tvOS\n- IOS/TVOS: Netplay discovery through bonjour/mdns\n- IOS/TVOS: Improve some log formatting on iOS/tvOS\n- IOS/TVOS: Preliminary MetricKit support on iOS/tvOS\n- TVOS: Fix analog stick handling after adding Siri remote tap support\n- TVOS: Also handle tap events on tvOS\n- TVOS: Back up retroarch.cfg to NSUserDefaults on tvOS.\n- TVOS: tvOS has its own beautiful screensavers and I would like them\n- TVOS: tvOS Siri remote handling\n- TVOS: Fix accidental left/right keypresses on tvOS\n- TVOS/CONFIG: Avoid a crash if there is no backed up config file on tvOS\nIt's not really usable as a game controller, but it is good for going\nthrough the menu as a simple LRUD.\nThis also adds better support for names of mFI controllers, as well as\nbeing able to do the expected tvOS behavior of \"backing out\" of the app.\n- TVOS: AltKit support for tvOS\n- INTL: Fix language detection in Canada to English\n- LANGEXTRA: Enable language autodetect for all builds with LANGEXTRA\n- LIBRETRO: Add new context hardware render enums - enables autodetection of DX12 for PS2 core\n- LIBRETRO: Add API to check JIT availability on iOS\n- LIBRETRO: Allow RETRO_ENVIRONMENT_SET_MEMORY_MAPS also after core startup. Change the comment in libretro.h about the removed limit and handle the environment call during core runtime in RetroArch.\n- LIBRETRO/MICROPHONE: Add new API for microphone support.\n- LIBRETRO: Add new API for querying the device's power state.\n- LIBRETRO/VFS: Rewrite retro_vfs_file_remove_impl\n- LINUX: Input driver fix 8+ joypads. It was reported that controllers beyond 8 worked only partially (analogs yes, but not buttons), and the found fix was also confirmed.\n- MIDI: Show MIDI output first\n- MENU: Reorganize 'Saving' menu\n- MENU: Start directory browsing from current value\n- MENU: Fix menu toggle combo hold with same 'enable_hotkey'\n- MENU: Add menu scroll home+end actions\n- MENU: Move 'systemfiles_in_content_dir' from Saving to Core\n- MENU: Menu navigation acceleration adjustments\n- MENU: Audio synchronization menu cleanup\n- MENU: Menu value label cleanup\n- MENU: Show playlist history/favorites icons by default\n- MENU: Remove advanced option flag from video rotation + orientation\n- MENU: Combine audio resampler menu with audio output menu\n- MENU: Microphone menu cleanup\n- MENU: Add missing menu visibility option for content dir override\n- MENU: Fix menu refresh in action_ok_network\n- MENU: Video settings menu cleanup\n- MENU: Try to declutter Quick Menu\n- MENU: Change network port menu options to 'allow_input' mode\n- MENU: Preselect current core in \"Set Core Assocation\" menu for more carefree usage\n- MENU: Focus back to \"Set Core Association\" item after returning from the menu instead of first item\n- MENU: Replaced hack fix for focusing the first item after returning from core suggestion \"Run\" menu after association reset\n- MENU: Fixed setting core association in history/favorites after resetting it and running without setting\n- MENU: Relocate playlist manager core association options to prevent accidental resets with Start\n- MENU: Fraction setting wraparound rounding correction\n- MENU: Add more missing sublabels\n- MENU: 'Updater Settings' relocation\n- MENU: Search box usability improvements\n- MENU/RGUI: Implement 'Remember Selection' option\n- MENU/RGUI: Fix savestate thumbnail fullscreen cancel action\n- MENU/RGUI: Fix and add toggle for playlist thumbnails\n- MENU/OZONE: Update Dracula theme\n- MENU/OZONE: Return to sidebar from playlist manage quick access\n- MENU/OZONE: Sidebar multiline scrolling\n- MENU/OZONE: Avoid crash if ozone sidebar_index_size is 0\n- MENU/OZONE: Prevent metadata and footer overlap\n- MENU/OZONE: Sublabel width tweak\n- MENU/OZONE: Mouse hover selection fix\n- MENU/XMB: Message/help box adjustments\n- MENU/XMB: XMB menu playlist index bugfix\n- MENU/XMB: Playlist label limit fixes\n- MENU/XMB: Prevent playlist label truncating long items even when right thumbnail is not enabled/visible\n- MENU/XMB: Prevent playlist label length resetting to full width on every item change while thumbnail is pending\n- MENU/XMB: Stop showing playlist entry index outside of playlists\n- MENU/XMB: Fix menu focus issue when returning from \"Set Core Association\" if playlist index is greater than the previous menu\n- MENU/EXPLORE: Prevent flashing when browsing fullscreen thumbnails\n- MENU/EXPLORE: Match label ticker length behavior with playlists\n- MENU/SOUNDS: Fix certain audio drivers from hanging when menu pause is enabled with menu sounds\n- MENU/SOUNDS: Fix menu sounds stopping after fullscreen toggle / video reinit\n- MENU/QT/WIMP: Cleanup Desktop Menu welcome text\n- MENU/OVERLAYS: Reorder overlay menu\n- MICROPHONE: Add support for microphones.\n- MICROPHONE/ALSA: Add `alsa` and `alsathread` microphone drivers.\n- MICROPHONE/SDL: Add `sdl2` microphone driver.\n- MICROPHONE/WASAPI: Add `wasapi` microphone driver.\n- MOBILE: On mobile in portrait mode, don't override custom viewport\n- NETWORKING: Enhance netpacket interface\n- NETWORKING/NETPLAY: Enable core host to refuse connecting new players to limit the number of connected players\n- NETWORKING/NETPLAY: Enable a core to flush outgoing packets and read incoming packets without waiting for the next frame (can be used for lower latency or blocking reads)\n- OPENDINGUX/RG350: Enable networking for RG350\n- OPENGL/WAYLAND: Add frame callback after egl_swap_buffers to improve latency when max_swapchain <= 2\n- OSD/STATISTICS: Show current video + audio drivers in statistics\n- OSD/STATISTICS: Ensure statistics text is aligned left\n- OSX/MACOS: Fix steam OSX core path\n- OSX/MACOS: Add HAVE_STDIN_CMD support\n- OSX/MACOS: fix mouse grab in windowed mode\n- OSX/MACOS/IOS/TVOS: Enable SSL in macos/ios/tvos builds\n- PLAYLIST: Change default playlist last played time format\n- PS3/PSL1GHT: Add overlay support\n- RUNLOOP: Don't count frames while paused\n- SERENITYOS: Add SerenityOS to the list of supported operating systems\n- SCANNER: Improve scanner console output\n- SCANNER: More scanner console output coloring\n- SCANNER: Improve CLI scan console output\n- SCANNER: Add content import/scan via CLI\n- SCANNER/PS1: Serial extraction is now considered a failure if PSX.EXE is found, allowing CRC fallback and actually fixing the game scanning\n- VIDEO: Correct rotated core provided aspect ratio\n- VIDEO: Minor adjustments to refresh rate switch behavior\n- VIDEO: Fix windowed viewport with libretro rotation\n- VIDEO/SDL2: Use \"nearest\" scaling in menus\n- TASKS: Fix corrupt task progress percentage\n- XVIDEO/MENU: Add menu support to xvideo gfx driver, making it usable\n- UWP: Fix modifier keys ( shift, ctrl, alt ) as well as F10 not being detected on the UWP platform\n- VULKAN: Ignore Fast-Forward Frameskip option\n- VULKAN/KHR_DISPLAY: Support screen refresh rate with Vulkan KHR_Display context\n- WIN32: Increase maximum window limit\n- WIN32/WINDOWSXP/MSVC2010: Fix invisible menu display\n- WAYLAND: Remove splash screen\n- WAYLAND: Check for pointer before locking it\n- WAYLAND: Add mouse grab/lock functionality\n- WAYLAND: Get system wayland-protocols path via pkg-config\n\n# 1.15.0\n- AI SERVICE: Fix NVDA switching to Powershell on speak\n- ANDROID: In Android builds, add input_android_physical_keyboard configuration option and its corresponding menu entry to force a device to act as a physical keyboard. When running on Android, RetroArch considers most devices that emit dpad events as gamepads, even if they also emit other keyboard events; this is usually the right thing to do, but it has the side effect of not letting some actual keyboards (e.g.: Logitech K480) act as such inside RetroArch. This configuration option allows users to manually select a specific input device to act as a physical keyboard instead of a gamepad, which is handy when emulating computers as opposed to consoles.\n- APPLE: Add App Category to a few places it should have been\n- APPLE/MFI: Prevent crash when controller player index is unset (-1)\n- AUTOMATIC FRAME DELAY: Helped delay to decrease easier when it should and helped delay to stay put when it should when triggering pause & menu with or without pause & fast-forward & slow-motion & geometry change\n- AUTOMATIC FRAME DELAY: Recalibrate delay on video reinit (fullscreen toggle and such)\n- AUTOMATIC FRAME DELAY: Show (x effective) only in menu item and not in dropdown list items when auto is enabled\n- CHEEVOS: Allow repositioning of RetroAchievement notifications\n- CHEEVOS/MENU: Add Achievements Visibility submenu option\n- CHEEVOS/MENU: Startup Summary split off from Verbose Mode, added option to hide for games with zero core cheevos\n- CHEEVOS/MENU: 'Unlocks/Mastery' split into two options\n- CHEEVOS/MENU: 'Account/Login Messages' split off from 'Verbose', gated all login success/error messages\n- CONFIG/INPUT: Unload restores current global config\n- CONFIG/INPUT/OVERRIDES: Removing a file does not unload current override\n- CONFIG/INPUT/OVERRIDES: Saving an empty override removes the file if it exists, and won't save when it does not\n- CONFIG/INPUT/OVERRIDES: Prevent the use of RUNLOOP_FLAG_OVERRIDES_ACTIVE with appendconfig\n- CORE OPTION: Core option setting type checks. Added checks for getting and setting core option type, since otherwise there will be a crash on close content after browsing to core option categories. Also fixed the no-show switch icon for lone wolf \"Lock Installed Core\".\n- CLI: Update selected save slot when start with cli --entryslot\n- CLI: Decouple config CLI append and config overrides\n- CLI/MENU/XMB: Stop showing bogus previous icon on CLI launch\n- D3D9: Fixed display driver scissoring implementation  - can now accept 0 width/height\n- D3D10: Fixed display driver scissoring implementation - can now accept 0 width/height\n- D3D11: Fixed display driver scissoring implementation - can now accept 0 width/height\n- D3D11: Fixed build when HAVE_DXGI_HDR is not defined\n- D3D11: Moved waitable swapchain waiting to happen always even when resizing swapchain\n- D3D12: Fixed display driver scissoring implementation - can now accept 0 width/height\n- D3D12: Fixed window scaling issue, which was caused by swapchain resize function not using the same flags (waitable swapchain) as swapchain creation\n- D3D12: Fixed swapchain scissoring issue (visual + crash) after manually resizing window to smaller size\n- D3D12: Fixed eventual crashing issue on video reinit when swapchain is being freed\n- D3D12: Moved waitable swapchain waiting to happen always even when resizing swapchain\n- EMSCRIPTEN: Add HAVE_PATCH support for Emscripten\n- EMSCRIPTEN: Add BSV/Replay support for Emscripten\n- EMSCRIPTEN: Add command and stdin_cmd features to emscripten RA. update libretro.js to show how commands could be sent over emscripten stdin.\n- FRAME DELAY/MENU: Show Frame Delay without VSync\n- GENERAL: Start unpause restriction. Limit the feature using retropad start button to unpause RA to the setting it was made for; \"pause on controller disconnect\".\n- GENERAL: Savestate thumbnail aspect ratio fallback. Thanks to at least one certain core that announces aspect ratio as 0, we have to add the same fallback in savestate thumbnails that is happening elsewhere in normal video driver use anyway.\n- GENERAL: Add support for system subdirs per core/database. Added the trivial and graceful automatic ability to send a different system directory to cores if it exists, for keeping the system dir more sane. First by using the core/library name just like in configs and saves, and then by playlist name, like in thumbnails, and of course default to the current global system dir.\n- GENERAL: Ignore system subdir replacement if subdir has subdirs.\n- GENERAL: Restore cached video driver always on quit\n- IOS: Include 'Update Core Info Files'\n- IOS: Fix #14778 - In addition to sending logs to asl_client, add them to the logfile.\n- IOS/VULKAN/MOLTENVK: Vulkan video driver on iOS\n- LATENCY/PREEMPTIVE FRAMES: Add Preemptive Frames to Latency Settings. RunAhead alternative that reruns core logic to \"rewrite history\" before the current frame. Frames are only rerun when the controller state changes, so it's faster overall.\n- LATENCY/PREEMPTIVE FRAMES: Call retro_run before retro_serialize (#14893). Fixes preemptive frames not starting up with a few cores\n- LIBRETRO-COMMON/VFS/FILESTREAM: Fixes filestream_vscanf regression\n- LOCALIZATION: Updates\n- LOCALIZATION: Enable localization of video rotation, orientation, and aspect ratio option values.\n- LOCALIZATION: Mixer stream localization also added\n- LOCALIZATION/MENU/HELP: Context dependent help text for audio and video drivers. Language corrections\n- LOCALIZATION/MENU/LANGUAGE: Language submenu now shows the progress of translated strings for each language.\n- LOCALIZATION: Help texts now localizable through Crowdin.\n- LIBRETRO: Enable RETRO_ENVIRONMENT_SET_SUPPORT_NO_GAME for libretro-video-processor\n- LIBRETRO/HW: Add GET_HW_CONTEXT_NEGOTIATION_INTERFACE_SUPPORT. Works around issues in v1 interface where it was not possible to\nquery what frontend would do when faces with newer interface versions. This env-call gives stronger guarantees how things have to work.\n- INPUT: Allowing keyboard hotkeys to work without hotkey modifier if modifier is only mapped to RetroPad\n- INPUT: Allowing keyboard hotkey keys for typing if hotkey modifier is set to keyboard but not pressed\n- INPUT: Allowing keyboard RetroPad keys for typing if emulated device type is \"None\"\n- INPUT/AUTOCONFIG: Check for 'enable_hotkey' also from autoconf binds\n- INPUT/BLUETOOTH: Fix a crash in for BT HID devices. (#14922) pad_connection_destroy() frees slots, no need to free it again.\n- INPUT/BSV/REPLAY: Don't start video recording when BSV recording starts\n- INPUT/BSV/REPLAY: Don't double-record inputs in BSV recording\n- INPUT/BSV/REPLAY: Don't autoload states if a BSV file is being played back or recorded\n- INPUT/BSV/REPLAY: Moved BSV initialization before autoload code\n- INPUT/BSV/REPLAY: Don't trigger autoload code if there is bsv movie state\n- INPUT/BSV/REPLAY: Allow for both -e and -R to start a BSV file recording at a state\n- INPUT/BSV/REPLAY: Add keyboard recording support to BSV\n- INPUT/BSV/REPLAY: Fix BSV playback from a starting state for DOSbox\n- INPUT/BSV/REPLAY: Associate states with replays. Now states can be saved and loaded during replay recording and playback in a way that keeps the integrity of the recording. Recordings also have a (moderately) unique identifier associated with them.\n- INPUT/BSV/REPLAY: Add checkpointing feature for replay recordings. If cores are not deterministic, or if they only have bounded determinism, we can obtain less drift if replay files also contain periodic checkpoint states.  These are configured by the new retroarch setting replay_checkpoint_interval (measured in seconds).  States are inserted into the replay file in between frames. This also fixes the settings display for the replay autoincrement max keep setting.\n- INPUT/FRAMEADVANCE: Use non-rendering pause mode when frameadvance is triggered\n- INPUT/HOTKEYS/OVERLAYS: Do not block input overlay hotkeys\n- INPUT/HOTKEYS: Hotkey blocking correction. Turned out the previous hotkey blocking changes worked properly only with winraw driver and not the rest (at least with Windows), because input_keyboard_event() could be called at the wrong moment, and thus storing keyboard menu press there broke the separation of controller Guide menu button and keyboard menu key. Also allowed the blocking to work in both directions so that controller hotkeys won't get blocked if only keyboard has \"enable_hotkey\" bind.\n- INPUT/LINUX/UDEV: Fix udev guns input when id_mouse is not id_joystick\n- MENU: Rename 'Standalone Cores' to 'Contentless Cores'\n- MENU: Music files should also obey builtin_mediaplayer_enable (#14967) Disabling the built in media player should be possible for music files\nas well. Without this, sound files can not be opened from file browser with cores that support them.\n- MENU: Relocated items to a more logical order\n- MENU: Corrected some title capitalizations (when/before/after are not low case, but for/the/a are)\n- MENU/AUDIO: Add dropdown menu for audio device\n- MENU/HELP: Help for turbo modes (#14919). Help text added for each of the selectable turbo modes.\n- MENU/INPUT: Add unified back action to all menu drivers. Usability boost for all menu drivers resulting in similar behavior as with Ozone currently, which is pressing back/cancel enough the selection jumps first to Main Menu and when pressed again jumps to the first item, so that when a core is running, Quick Menu is very quickly accessible from anywhere. And when core is not running, the first item would be Load Core.\n- MENU/INPUT: Override bind save + menu manager overhaul\n- MENU/INPUT: Allowed and fixed input bind saving to overrides\n- MENU/INPUT: Overhauled override menu\n- MENU/INPUT: Pressing Start on the top active file entry reloads current overrides as startup would\n- MENU/SUBLABELS: All under \"Configuration File\" + moved \"Reset to Defaults\" to bottom\n- MENU/SUBLABELS: Quick Menu > Controls > Port x Controls\n- MENU/SUBLABELS: Port x Controls > Device Type\n- MENU/RGUI: Fix disabled menu item color. The effect was not working properly, since transparency meant using the core output color as background.\n- MENU/XMB: Horizontal icon animation fix\n- MENU/XMB: Fixed playlist manager icons to take Explore Views into account properly\n- MENU/XMB: Changed XMB Explore View title to match Ozone\n- MENU/XMB: Added \"Switch Icons\" option\n- MENU/XMB: Fix MENU_ACTION_CANCEL when search is active. Nasty issue discovered in XMB which broke search term cancelation.\n- MENU/XMB: Layout corrections:\n- MENU/XMB: More room for longer item labels and values\n- MENU/XMB: \"Core Downloader\" has extra space for item and \"installed\" indicator\n- MENU/XMB: Fixed \"Menu Scale Factor\" to not require restarting to get the actual end result\n- MENU/XMB: Adjusted scale factor to behave better with both layouts\n- MENU/XMB: Fixed savestate thumbnails and adjusted vertical fade factor in \"Handheld\" layout\n- MENU/XMB: Changed thumbnail shadow to outline and tightened fullscreen thumbnail margins\n- MENU/XMB: Adjusted global shadow opacity\n- MENU/XMB: Remove \"Framebuffer opacity\" from XMB as it does not use it. Also, rename the corresponding menu title, since \"framebuffer\" is not that intuitive.\n- MENU/OZONE: Fixed playlist manager icons to take Explore Views into account properly\n- MENU/OZONE: Refresh thumbnail on close content hotkey\n- MENU/OZONE: Ozone footer enhancements (#14926). Add Help button (Select) and Reset to Default (Start) to footer where applicable.\n- MENU/OZONE: Ozone footer enhancements (#14934). Display Help footer only if there is actual info to be displayed, either actual help, or sublabel if it is not visible otherwise.\n- MENU/OZONE: Ozone footer enhancement: Scan button (#14949). Display Scan button in footer when it is applicable.\n- MENU/OZONE: Add Clear button to Ozone footer (#14947). Add indication of Clear button when it is applicable (currently: keybinds).\n- MENU/MATERIALUI: Added missing Favorites+History icons in playlist manager\n- MENU/MATERIALUI: Added \"Switch Icons\" option\n- MENU/CHEATS: Added missing icons in cheats (Delete + Copy After/Before)\n- MENU/CHEATS: Fixed label capitalization in cheats (Add New After/Before This)\n- MENU/SOUNDS: Add scrolling sounds for RGUI, XMB, MaterialUI and Ozone.\n- MENU/SOUNDS: Better scrolling sound implementation, add new 'notice back' sound\n- MENU/SOUNDS: Scroll sound fixes. Correctly get list size in xmb.c for playing scrolling sound when switching categories, play the scrolling sound when pressing cancel in ozone, play the sound when scrolling with ZL and ZR, play the correct sound when scrolling with L\n- MENU/WIDGETS: Show square sized widget on volume mute. Volume widget is currently fixed size always, and thus showing a lot of empty space when muting, therefore shorten the box to icon size only when muting.\n- MIYOO: L3/R3 support for Dingux Gamepad controller device.\n- NETWORKING: Call ssl_socket_close for SSL sockets\n- NETWORKING/CHEEVOS: net_http - Temporary fix for cheevos crash. Don't use new timeout/poll code for cheevos HTTP requests.\n- NETWORKING/MENU: Network information cleanup:\n- NETWORKING/MENU: Remove extra space from : delimiter\n- NETWORKING/MENU: Trim useless/duplicate garbage from the end of ipv6 address. Windows shows %[adapter number], Linux shows %[adapter name], which already shows before the address\n- NETWORKING/STDIN: Add LOAD_STATE_SLOT N command to stdin/network protocol\n- OSD/STATISTICS: Add Run-Ahead data to on-screen statistics\n- OSD/STATISTICS: Notification font + statistics adjustments\n- OSD/STATISTICS: Finetuned statistics layout to be more compact and aligned\n- OSD/STATISTICS: Group Run-Ahead and Frame Delay as \"Latency\"\n- OSD/STATISTICS: Try to scale font as small as possible/readable if stats won't fit\n- OSD/STATISTICS/FONT: Allow reseting notification font with RetroPad Y to \"null\", which uses the fallback pixel font\n- OSD/STATISTICS/FONT: Show \"Default\" instead of empty with default font\n- OSD/STATISTICS/FONT: Start browsing font from assets instead of root\n- OSX/MACOS: Steam platform support\n- OSX/MACOS: Set LSApplicationCategoryType to games\n- OSX/MACOS: Include OpenGL video driver on Metal macOS builds (10.13 and higher)\n- OSX/MACOS: Fix a few mac windowed mode settings -\n- OSX/MACOS: Use \"Remember window position and size\" setting (fixes #14806)\n- OSX/MACOS: Implement window opacity\n- OSX/MACOS: Enable \"Show window decorations\" toggle\n- OSX/MACOS: Hide \"Disable composition\" option (osx does not support disabling composition)\n- OSX/MACOS: Make sure to use the file system path name, not the URL name\n- OSX/MACOS/IOHIDMANAGER: Various memory access fixes to prevent crashes (#14459) (#15000). Prevent double free and null dereference when the controller is quickly reconnected. Handle error when controller device query returns null instead of crashing.\n- OSX/MACOS/METAL BUILD: Fix input events (keyboard/mouse) sometimes going lost when switching between fullscreen and windowed mode. Fixes lots of longstanding issues\n- OSX/MACOS/OPENGL: Fix for fullscreen OpenGL driver in Metal macOS build\n- OSX/MACOS/VULKAN/MOLTENVK: Default to Vulkan driver when available (for 10.13 Metal Universal build)\n- OSX/MACOS/VULKAN/MOLTENVK: Updated Vulkan on Metal for OSX via MoltenVK\n- OSX/MACOS/VULKAN/MOLTENVK/HDR: Fix non-HDR colors\n- OSX/MACOS/SLANG: The change to apply shaders would be executed and then a command to apply shaders would immeidately be enqueued, to run asynchronously\nafter the current event handler, which then did exactly the same. Fixes issue #14789 - Turning on shaders on Metal build 1.14.0 stable for Mac OS will slow emulation drastically thing, creating a busy loop.\n- PS2: Avoid loading extra drivers when not needed. Fixed a bug where it wasn't using the variable extra_drivers, for loading the specific IRX needed drivers. This is increasing compatibility with some specific PS2 models that sometimes fail when loading cores.\n- PS3/PSL1GHT: Add improvements to the RSX driver (#14965)\n- PS3/PSL1GHT: Add modern_alpha_blend and modern_opaque rsx shaders\n- PS3/PSL1GHT: Add perf improvements to the rsx driver\n- PS3/PSL1GHT: Add RSX video driver\n- PS3/PSL1GHT/MENU/XMB: Do XMB menu scaling for psl1ght\n- PS3/PSL1GHT: Update Makefile to use latest shaders and more UI menu options\n- PS3/PSL1GHT: Default folders normalization\n- PS3/PSL1GHT: Fix video rotation\n- PS3/PSL1GHT: Fix HTTP download\n- QB/CONFIGURE: Add new flags - HAVE_UPDATE_CORE_INFO, ASSETS_DIR, FILTERS_DIR\n- RECORDING: Add recordings to video history playlist\n- REWIND: Don't take rewind steps while menu pause active\n- RUNLOOP: Currently when core is paused, video output will be stopped completely too, making it impossible to animate widgets while paused, therefore:\n- RUNLOOP: Added a new runloop state for pause which renders last cached frame\n- RUNLOOP: Allowed rewinding while paused so that it acts like backwards frameadvance. Also moved rewind step taking before menu iteration so that steps won't be lost while in menu when menu_pause is disabled\n- RUNLOOP: State load and reset while paused will forget pause for x frames in order to show proper output\n- RUNLOOP: Allowed reading pause hotkey while menu is active\n- RUNLOOP: Allowed reading screenshot hotkey while menu is active\n- RUNLOOP: Joined 2 fullscreen hotkey checks to one (Any ideas why they were separated for paused and non-paused states, since one works fine for both..?)\n- RUNLOOP: Implement GET_HW_CONTEXT_NEGOTIATION_INTERFACE_SUPPORT. Fairly trivial. Just report the latest version.\n- SAVESTATES: State slot hotkey adjustments -\n- SAVESTATES: Allow selecting -1 Auto slot with hotkeys\n- SAVESTATES: Allow wrap-around from -1 to 999 and backwards\n- SAVESTATES: Show failure message when trying to load a state that does not exist instead of plain \"Loading state\"\n- SAVESTATES: Shorten the duration of slot change notification\n- SAVESTATES: Change the widget type to the same type as shader toggle for better back and forth action. Closes [Widgets] Save state slot switcher\n- SHADERS: Append Preset feature\n- SHADERS: Prepend Preset feature\n- SHADERS: Shader Preset - Wildcard Replacement in Paths on Load. When a simple preset loads, text wildcards which are found in paths inside the presets will be replaced with values coming from the current RetroArch context. The replacement will be executed on both texture paths and reference paths.\n- SHADERS/SLANG/SPIRVCROSS: Update to latest SPIRV-Cross, fixing Metal shader compilation issues along the way\n- STATICALLY LINKED/SALAMANDER: Fix salamander config save on fork for static platforms\n- TVOS/VULKAN/MOLTENVK: Vulkan on tvOS\n- VIDEO: Allow manual video swap interval forcing. The addition of auto swap interval effectively prevented manual forcing, which is beneficial when the rate is not reported properly. Therefore use the interval in the calculation only when using automatic interval.\n- VULKAN: Fix crash when using multiple physical devices and HW core (#14889)\n- VULKAN: Detect if wrong PhysicalDevice is returned.\n- VULKAN: Actually query physical device before creating core device.\n- VULKAN: Define and implement v2 of context negotiation interface\n- VULKAN: Add v2 of context negotiation interface.\n- VULKAN: Add vkEnumerateInstanceVersion symbol.\n- VULKAN: Implement v2 context negotiation\n- VULKAN: Use compute shaders to upload RGB565\n- VULKAN: Fix regression with RGB565 and OriginalHistory.\n- VULKAN/WAYLAND: Don't clamp the number of requested images. Due to an unfortunate \"feature\", MESA always reports 4 as the Vulkan surface's minImageCount in Wayland.\nHowever, values of 2 and 3 work perfectly well, even if they are out of spec, providing way better latencies when using the Vulkan backend on Wayland.\nSo this removes the artificial clamping that was being done to desired_swapchain_images, because it's not really necessary and was causing very noticeable input lag on Wayland+Vulkan.\n- VULKAN/MENU/RGUI: Fix RGUI on Vulkan on platforms that don't have _pack16 VkFormats\n- VULKAN/MACOS/OSX: avoid using _PACK16 pixel formats on platforms without them\n- WAYLAND: On scaled desktops the wayland backend deciding to resize based on values multiplied by the scale factor twice. Resulting in continuous attempts to rebuild the swapchain when in fullscreen.\n- WAYLAND: Wait for splash screen configuration. Before, configuration (resize) events for the initial wayland window could happen before or after set_video_mode which could result in a small or corrupted window. Now we make sure that the initial window has processed it's resize events before window size is set by set_video_mode.\n- WAYLAND: Changes the initial window to show a RetroArch logo copied from the icon of the X11 backend.\n- WAYLAND: Build pointer-constraints and relative-pointer protocols.\n- WAYLAND/GL: GL is sometimes not rescaling property (Super + Left).\n- WIN32: Ignore window limiting with fixed position. The other resizing part already took this into account, but WM_GETMINMAXINFO did not.\n- WIN32/INPUT: Add support for mouse button swap\n- WIN32: Fix keyboard event characters. Added sending key chars to all input drivers (currently they only send scan codes), and also missing mods for raw.\n- WIN32: Fix restart if path has spaces. CreateProcess does not like to have anything executable path related in the second parameter lpCommandLine if the path has spaces. Thus strip everything from args except the actual parameters.\n\n# 1.14.0\n- AUDIO/COREAUDIO/APPLE: Allow coreaudio3 driver to work with audio devices that have 2 or more output channels\n- CHEEVOS: Fix construction of Cheevos badge path\n- CLI: Fixed not getting any output when running --version or --features without --verbose\n- CLI: Fixed crash when running empty - parameter (it proceeded to content loading)\n- CLI: Reformatted --features to require less rows and to be more consistent\n- CLI: Added -V shorthand for --version\n- CLI: Tab removal + whitespace nits\n- CONFIG/MIDI: Prevent MIDI startup error with old configurations\n- D3D11: Fix when using shaders with TATE mode arcades etc\n- D3D12: Fix when using shaders with TATE mode arcades etc\n- D3D12: Added support for break on errors  (development aid - define DEVICE_DEBUG to use)\n- D3D12: Added support for DRED (device remove extended data) (development aid - define DEVICE_DEBUG to use)\n- D3D12: Made D3D12 viewport and scissors to behave more like Vulkan drivers (or be more correct)\n- D3D12: Fixed validation error on start up due to buffers not being setup correctly for one frame\n- D3D12: Fixed some shaders not appearing with the d3d12 driver - this reintroduces a validation error though but it seems to work as in not crash and is the old RA behaviour. Guess we need a different way of fixing the validation issue.\n- DATABASE/EXPLORE/VIEW: Bugfix - RGUI did not clear thumbnail on non-playlist items such as Save and Delete\nmenu_explore_get_entry_playlist_index() returns -1 on invalid entries, but the variable where it was stored was unsigned\n- DATABASE/EXPLORE/VIEW: Bugfix - XMB+Ozone cleared thumbnail in Quick Menu when navigating away from Run\n- DRM/ODROID GO2: Implement get_video_size for DRM GL context driver\n- FASTFORWARD: Restore framelimit on fastforward toggle. Fast-forward was broken after toggling vrr_runloop off, since it will force frame limit to 1.0 (even on every frame) and never restores it. So let's make sure the wanted ratio is applied when toggling FF (Fastforward).\n- FFMPEG CORE: Fix runtime error in FFmpeg core when build with FFmpeg n5.1.2 and OpenGL ES\n- GFX/VIDEO FILTERS: (picoscale_256x_320x240) Added snn function to upscale Fuse (ZX Spectrum) core borderless output to 320x240. ZX Spectrum resolution of 256x192 was previously unsupported.\n- HOTKEYS: Further reorder internal hotkey items for consistency and removed SEND_DEBUG_INFO, OVERLAY_NEXT and OSK from visible hotkey bind list. \"Send Debug Info\" stuff is removed as much as possible without breakage due to translation files.\n- INPUT/AUTOCONFIG: Disable 'pause on controller disconnect' by default - was enabled by default on 1.13.0\n- INPUT/MENU: Device Index menu refactor\n- INPUT/OVERLAY: Fix analog drift blocking touch input (could occur on overlay_next if physical inputs shown on overlay)\n- INPUT/OVERLAY: Fix overlay_next buttons lighting up in unison\n- INPUT/OVERLAY: Skip meta keys in input_overlay_add_inputs (not supported by input_state_internal)\n- INPUT/WINDOWS/WINRAW: Fix mouse position when using input overlay with mouse cursor\n- INPUT/WINDOWS/WINRAW: Fixed mouse position to use the same method required for menu items and pointer when simulating input overlays with mouse, since it won't work with multi mouse method\n- INPUT/WINDOWS/WINRAW: Fixed passing mouse position to core also when using aforementioned method\n- LEAPFROG: Add Leapfrog (LFx000) Target\n- LOCALIZATION: Updates\n- LOCALIZATION/INPUT/IME/MENU/ONSCREEN KEYBOARD: Extended IME and Korean OSK\n- MENU: Cleanup of help texts\n- MENU: Allow toggling info off with the same button\n- MENU: Allow menu wallpaper/background reset. Let's also remove the current wallpaper from the screen when pressing Start.\n- MENU: Null driver shows with different color (Added for all menus the ability to show \"disabled\" items with a muted color)\n- MENU/DRIVERS: Menu driver first, Audio Resampler removed because it is enough to exist under audio settings\n- MENU/INPUT: Moved \"Confirm Quit\" to Input menu\n- MENU/INPUT/HOTKEYS: Input hotkey menu completely overhauled to keep related entries together, and also adjusted some labels and sublabels\n- MENU/OVERLAY: Fix overlays behind menu without core running. \"Show Overlay Behind Menu\" is currently broken with Ozone and XMB (with any other color theme than Plain) when running without a core.\n- MENU/MATERIALUI: Fix home screen on first startup - no more stray entries\n- MENU/OZONE: Allowed drawing sidebar and thumbnail bar background color also when core is running\n- MENU/OZONE: Stopped using different padding and position for savestate thumbnails vs imageviewer\n- MENU/OZONE: Removed gradient background effect when core is running, because some themes already have gradient background, which creates ugly rough steps\n- MENU/OZONE: Fixed \"Gray Light\" theme from using the same background as \"Gray Dark\", which makes selection cursor near impossible to see\n- MENU/OZONE: Some whitespace corrections\n- MENU/UX: Extend OFF menu value colors\n- MENU/UX: Menu icon improvements - Menu Visibility icons (Quick Menu + Settings)\n- MENU/UX: Menu icon improvements - Playlist Manager icons\n- MENU/UX: Menu icon improvements - Explore icon as database icon\n- MENU/UX: Menu icon improvements - View and filter icons as cursor icon (folder icon in GLUI)\n- MENU/UX: Menu icon improvements - View save + delete icons\n- MENU/UX: Menu icon improvements - Moved Explore + Views below Standalone Cores\n- MENU/UX/OZONE: Removed icons from menus where others items don't have icons, and added icons to menus where the rest have icons\n- MENU/UX/OZONE: Changed the way \"no icon\" is handled from kludgy way of not drawing SUBSETTING icon\n- MENU/UX/XMB: Changed playlist entry index positioning to bottom right when thumbnails are in vertical mode, because big lists will overlap with arrow and current \"breadcrumb\" icons when the position is next to current selection\n- MENU/UX/XMB: Added a rather nasty hack to prevent showing wrong icons under Explore as \"breadcrumb\" icon\n- MENU/UX/XMB: Optimized certain icon drawing loops (Main horizontal icons were looped even when not visible, and all previous \"breadcrumb\" icons were looped when only one certain was needed)\n- MENU/UX/MATERIALUI: Fixed showing icons where there should not be any (Waitable Swapchains, Show Recording + Streaming)\n- OSX/MACOS: Fixed Cocoa keyboard not allowing to map Analog stick\n- PS2: Use the recently created ps2_drivers which makes easier the loading and init of all the drivers: Memory Card, USB, HDD, Audio, Controllers\n- PS2: Adds exFat support for USB, and probably solves some unexpected issues when using an HDD driver for booting cores/games.\n- SDL GFX: Fix no menu on start/blank screen issue.\n- SRAM: Don't init SRAM saving without content (gets rid of the redundant logging)\n\n# 1.13.0\n- 3DS: Remove debug button combo to shutdown RA\n- 3DS: Remove MaterialUI as per MrHuu recommendation\n- ANDROID: Enable 'Vibrate On Key Press' by default\n- ANDROID: Turn 'Threaded Video' off by default\n- CHEEVOS: Upgrade to rcheevos 10.5\n- COMPILATION: Fixed compiling with --disable-menu\n- CONFIG: Don't show override notification with appendconfig alone\n- DATABASE/PLAYLISTS: Playlist + database changes - Cleanup 'entry_slot', fallback label + logging\n- FRONTEND: Fix default remaps folder for various cores: remap should be nested in config folder\n- GFX/VIDEO FILTERS: Prevent video filter init if game is not running\n- HOTKEYS: Fix shader toggle and add hotkey + sublabel\n- HOTKEYS: Cleanups and corrections - Keep hotkey pause and menu pause separate in order to not trigger unwanted pause when toggling menu regardless if menu will pause or not\n- HOTKEYS: Cleanups and corrections - Allow unpausing with Start (makes resuming more convenient after controller disconnect if menu does not pause)\n- IOS13+: Pointer movement accuracy. iPad Trackpad Pointer Movement Accuracy through absolute location (for iOS 13.4 and above)\n- IOS13+: Adds iPad Trackpad Support to iOS13 Project (for iOS 13.4 and above)\n- INPUT: Fixed the way devices were previously indexed. Input devices were only being indexed in order and would stop at the first time an input has no device connected to it. The problem is when a device gets disconnected, that input will have no devices connected to it, but the next input may still have a device connected. So, that makes changing the port of the currently connected devices impossible.\n- INPUT/AUTOCONFIG: Add option for pause on controller disconnect\n- INPUT/AUTOCONFIG: Driver independent disconnection notification. Should show disconnect notification now properly on Windows with XInput and/or DirectInput pads\n- INPUT/HID: Added usb hid controllers for the famous ZeroDelay encoder and also for \"Kade: Kick Ass Dynamic Encoder\" to be able to use some custom arcade sticks.\n- INPUT/OVERLAY: Add eightway area types.\n- INPUT/OVERLAY: Ignore hitboxes with zero area. I.e. Set 'reach_x' or 'reach_y' to zero to ensure no hitbox math is done. This simplifies designating animation-only descriptors (e.g. for eightway areas) or obsolete descriptors.\n- INPUT/OVERLAY: Add 'reach' and 'exclusive' for hitboxes. Allows stretching hitboxes and handling their overlap.\n- INPUT/OVERLAY: Fix overlay next_index for unnamed targets\n- INPUT/MENU: Addition to analog stick menu navigation\n- INPUT/MENU: Enable menu navigation also with right analog stick\n- INPUT/MENU: Add option for swapping menu scrolling buttons\n- LOCALIZATION: Updates\n- LOCALIZATION: Add Hungarian language option\n- MENU: Thumbnail fullscreen toggle behavior correction\n- MENU: Consistent left-right scrolling for Quick Menu items\n- MENU: Remove useless sublabel from System Information\n- MENU: Improve widget appearance with missing assets\n- MENU/QT/WIMP: Remove SSL/TLS check at startup\n- MENU/OZONE: Show metadata helper in footer only with second thumbnail\n- MENU/OZONE: Footer improvements - Add \"Cycle thumbnails\" helper when suitable\n- MENU/OZONE: Footer improvements - Show \"Search\" helper only when search function is enabled\n- MENU/OZONE: Footer improvements - Fix \"Thumbnails available\" helper for save states\n- MENU/OZONE: Footer improvements - Tighten padding between icon and title, and widen between helpers\n- MENU/OZONE: Launching anything from a View no longer throws Quick Menu off the screen\n- MENU/OZONE: Save state thumbnails in slot dropdown obeys fullscreen toggle properly when content launched via CLI\n- MENU/OZONE: Save state thumbnail dropdown wont allow fullscreen toggle when it shouldnt\n- MENU/OZONE: Selection position remembering in non-playlists wont flash the first entry\n- MENU/OZONE: Remember selection per main tabs\n- MENU/OZONE: Remove incomplete assets warning\n- MENU/OZONE: Add option to adjust cursor memory when changing menu tabs\n- MENU/OZONE: Further extend texture support for Core Option categories\n- MENU/XMB: Remove incomplete assets warning\n- MENU/XMB: Add truncate playlist name option\n- MENU/XMB: Improve background image selector\n- MENU/XMB: Add option to adjust cursor memory when changing menu tabs\n- MENU/XMB: Further extend texture support for Core Option categories\n- MENU/MATERIALUI: Remove incomplete assets warning\n- OSX: Fixed Z/X keys not working on the macOS port\n- OSX: Fixed RETROK_LMETA not working on macOS port. The RETROK_LMETA key was not defined in the rarch_key_map_apple_hid\n- OSX: Fix broken fullscreen mode in macOS Ventura\n- PS2: Fix Error saving remaps and runtime logs\n- PS3: Fix Core Remap Overwrite Fail\n- QB: Don't fail if OSDependent/OGLCompiler libraries are not present\n- SCANNER/PS1: Improved scanning of PS1 discs\n- SCANNER/PS2: Added serial scanning of PS2 discs - should now scan DVDs and other discs which were previously missed\n- THUMBNAIL: If you rename title, you cannot use the thumbnail image. because the thumbnail filename and the title must be the same.\nIf there is no thumbnail with title, find the thumbnail image with rom-name. This has nothing to do with IME.\n- THREADED VIDEO/GLCORE: Fix regression 'Shader presets dont load, when video driver is set to glcore'\n- VULKAN: Fix HDR inverse tonemapping. Only skip tonemapper if HDR10 is explicitly enabled by last shader pass. Otherwise, we are simply just inheriting the bit-depth of the swapchain.\n\n# 1.12.0\n- CONFIG/CLI: Allow use of --appendconfig with override cfgs instead of getting ignored\n- CONFIG/LOGGING: No more console startup logging if logging to file\n- CONFIG: Saves config on exit only once instead of (worst case scenario) 3 times\n- DATABASE/EXPLORE/VIEW: Add View feature - Add saving of a filter set in the Explore menu into a so called \"View\" file which then gets listed alongside playlists. This also adds the ability to filter a category by range in the Explore menu and not just filter on exact matches.\n- FILEBROWSER: Fix regression - certain extensions keep disappearing\n- IOS: New modern iOS version (targeting iOS 13 and up), leverages Swift\n- IOS: Fixes to iOS toolbar\n- IOS16: Add iOS 16 lock screen widget\n- IOS13+: Added emulator keyboard\n- IOS13+: Add JIT support for non-jailbroken devices\n- IOS13+: Added support for touch mouse handler\n- IOS13+: Changed click-and-drag behavior to double tap hold and drag\n- INPUT/HAPTIC/OVERLAYS/ANDROID: Improve haptic feedback for input overlays\n- LINUX/MALI FBDEV: Add conditional support for OpenGL ES 3.x\n- LOCALIZATION: Updates\n- LOCALIZATION/ENGLISH: Add British English language option\n- LOGGING/QT: Increase log buffer to 2048 characters - Vulkan validation layer\n  messages output correctly now.\n- MENU/XMB: Remember selection per main tabs. Addresses the following : collection playlists can contain hundreds or thousands of items. When scrolling through one, pressing left or right by accident can be common. This resets the playlist to the top\n- MIST/STEAM/STEAMDECK: Don't expose Black Frame Insertion (BFI) if we are running on a Steam Deck\n- NETWORKING/WINDOWS: Disable poll support for MSVC 2010 and earlier. WSAPoll is not supported on Windows XP and earlier.\n- NETWORKING/WIIU: Fix socket_connect_with_timeout for WIIU\n- NETWORKING/WIIU: Fixes RetroAchievements login\n- NETWORKING/WIIU: Fixes other online updater functionality\n- SAVESTATES/NOTIFICATIONS: Add delay to savestate notifications, so that GPU savestate screenshots stay untouched\n- SAVESTATES/SCREENSHOTS: Avoid 'video_gpu_screenshot' with savestates. Allow GPU screenshots with savestates only when there is no other way of getting a screenshot.\n- SCREENSHOTS/VULKAN: Unload screenshot widget texture early. Fixes Vulkan crash when closing content while a screenshot widget is still on-screen\n- SCREENSHOTS/VULKAN: Fix screenshot widget crash when ticker animating\n- WAYLAND: Set correct app ID\n- WIIU: Add some missing default directories\n- WIIU: Get mkdir working on WiiU (directory creation)\n\n# 1.11.1\n- GENERAL: Fix DEFAULT_FILL_TITLE_MACRO\n- NETWORKING: Add the const qualifier to some function parameters\n- NETWORKING/NETPLAY/UPNP: Add a private or CGNAT address warning to UPnP\n- SAVESTATES/SCREENSHOTS: Avoid 'video_gpu_screenshot' with savestates\n- UWP: Better 'Save on quit' fix\n\n# 1.11.0\n- 3DS: Add unique ID's\n- 3DS: Add bottom menu options\n- 3DS: Set bottom_asset directory default\n- 3DS: Only enable internal counter with CONSOLE_LOG defined\n- 3DS: Set default bottom font values\n- 3DS: Fix CIA installation issues\n- 3DS: Support latest libctru\n- ANDROID: Add HAVE_ACCESSIBILITY\n- ANDROID: Gingerbread support\n- ANDROID: Touchpads support\n- ANDROID: Builtin Xperia Play autoconfig profile\n- ANDROID: Disable Feral GameMode for Android - only available on Linux\n- ANDROID: Add a configurable workaround for Android reconnecting devices\n- ANDROID/FDROID: Add F-Droid metadata to repo in Fastlane format\n- AUDIO/AUDIO MIXER: Add missing locks for thread safety\n- AUDIO/AUDIO MIXER: Fix audio mixer memory leak + remove redundant 'single threaded' rthreads implementation\n- AUTOSAVE: Change/improve exit behavior of autosave thread - if condition variable is signaled, the loop is ran another last time so we can do a final check/save before stopping the thread.\n- CDROM: Fix memory leak caught with asan - buf passed to filestream_read_file\n- CORE INFO/NETPLAY: Ensure current core info is initialized at runloop_event_init_core when netplay is enabled\n- CHEEVOS: Upgrade to rcheevos 10.4\n- CHEEVOS: Allow creating auto savestate in hardcore\n- CHEEVOS: prevent invalid memory reference if game has achievements but core doesn't expose memory\n- CHEEVOS: Release achievement badge textures when video driver is deinitialized\n- CHEEVOS: Re-enforce hardcore limitations once achievements are loade\n- CHEEVOS/MENU/MATERIALUI: Show achievement badge icons in MaterialUI driver\n- D3D9: D3D9 has been split up into two drivers - D3D9 HLSL (max compatibility, no shader support yet) and D3D9 Cg (dependent on deprecated Nvidia Cg runtime library)\n- D3D9/HLSL/XMB: XMB fix\n- D3D9/CG: D3D9 Cg driver fixed\n- D3D11: Fix overlay not showing up\n- D3D11/12: Reduce lag with WaitForVBlank - this rather simple addition seems to make D3D11/12 very very close to Vulkan/GLCore regarding input lag.\n- D3D11/12: Add waitable swapchains and max frame latency option\n- D3D11/12: Make waitable swapchains optional\n- DATABASE: Reformat 'rdb_entry_int' - Nitpick adjustments for database entries: Capitalize \"Release Date\", and remove space before : from Release Date rows which use integer\n- DATABASE/EXPLORE: Allow On-Demand Thumbnails in Explore menu\n- DATABASE/EXPLORE/MENU/OZONE/XMB/RGUI: Explore menu thumbnails\n- DISC CONTROL: Better Disc Control append focus\n- DOS/DJGPP: Add a workaround for libc bug\n- AUTOMATIC FRAME DELAY: Added slowmotion resiliency\n- AUTOMATIC FRAME DELAY: Added string representation for seeing the current effective delay without opening statistics\n- AUTOMATIC FRAME DELAY: Added \"ms\" to logging and \"(ms)\" to label just like in Audio Latency\n- GENERAL: Don't bake in OpenAL and libcaca by default unless explicitly enabled with configure switch.\n- GENERAL: Reduce amount of strlen calls\n- GENERAL: Reduce or simply sin/cosf calls\n- GFX: Fix readability and precision issues in aspectratio_lut\n- GFX: Add option to manually enable/disable automatic refresh rate switching\n- GFX: Enable automatic configuration of 'VSync Swap Interval'\n- GFX/FONT/FREETYPE: Use FT_New_Memory_Face - first read it from file to memory beforehand -\nthis solves an asset extraction issue when selecting 'Update Assets' - apparently FT_New_Face keeps an open file handle to the font file which\nprevents it from being overwritten/deleted while the program is still running.\n- GFX/THUMBNAILS: Thumbnail aspect ratio fix\n- GFX/THREADED VIDEO: Optimizations, fixes and cleanups\n- GFX/VIDEO FILTERS: Add Upscale_240x160-320x240 video filter with 'mixed' method\n- GLSLANG: Fix compilation with ./configure --disable-builtinglslang - was missing linking against -lMachineIndependent and -lGenericCodeGen static libs\n- INPUT: Fix off by one error for input_block_timeout setting. Also default to 0 for this setting (pretty massive performance gain)\n- INPUT: Analog button mapping fixes\n- INPUT/HID/OSX: Fix DualShock3 support\n- INPUT/HID/LINUX: (qb) Disable HAVE_HID by default for now for Linux as long as there are no working backends for both\n- INPUT/HID/WINDOWS: (qb) Disable HAVE_HID by default for now for Windows as long as there are no working backends for both\n- INPUT/HID/WIIU: Fix DualShock3 support\n- INPUT/OVERLAY: Block pointer input when overlay is pressed\n- INPUT/REMAPPING: input_remapping_save_file - existing remapping file was needlessly reloaded\n- INPUT/REMAPPING: Add option to disable automatic saving of input remap files\n- INPUT/LINUX/UDEV: Fix lightgun scaling on Y axis\n- INPUT/LINUX/X11/LED: Add LED keyboard driver\n- INPUT/WINDOWS/LED: LED keyboard driver cleanup\n- INPUT/WINDOWS/WINRAW: Clear key states when unfocused\n- INPUT/WINDOWS/WINRAW: Fix pointer device position\n- IOS: iOS app icon fixes & revisions\n- LIBRETRO/SAVESTATES: Implement an api call for context awareness\n- LOCALIZATION: Updates\n- LOCALIZATION: Add Catalan language option\n- LOCALIZATION: Fix some bad localization\n- LINUX: Make memfd_create call more backwards compatible by calling it through syscall - on older systems, you'll have to include linux/memfd.h for the MFD_ defines, and call memfd_create() via the the syscall(2) wrapper (and include unistd.h and sys/syscall.h for it work). We exclude linux/memfd.h header include because we already provide the MFD_ defines in case they are missing\n- LINUX/MALI FBDEV: Fix assertion failed on video threaded switch\n- MENU: Menu paging navigation adjustments\n- MENU: New Menu Items for disabling Info & Search buttons in the menu\n- MENU: Allow the user to use volume up/down/mute hotkeys from within the menu\n- MENU: Add missing sublabels for non-running Quick Menu\n- MENU: Reorganize Quick Menu Information\n- MENU: Savestate thumbnails - Savestate slot reset action\n- MENU: Allow changing savestate slots with left/right on save/load\n- MENU: Add 'Ago' to playlist last played styles\n- MENU: Add proper icons for shader items\n- MENU/MATERIALUI: Add icon for 'Download Thumbnails'\n- MENU/XMB: Add options for hiding header and horizontal title margin\n- MENU/XMB: Dynamic wallpaper fixes\n- MENU/XMB: Add Daite XMB Icon Theme\n- MENU/XMB/OZONE: Savestate thumbnail aspect ratio\n- MENU/XMB/OZONE: Core option category icon refinements\n- MENU/XMB/OZONE: Fullscreen thumbnail browsing\n- MENU/XMB/OZONE: Add playlist icons under 'Load Content'\n- MENU/XMB/OZONE: Thumbnail improvements\n- MENU/XMB/OZONE: Savestate thumbnail fullscreen + dropdown\n- MENU/XMB/OZONE: Prevent unnecessary thumbnail requests when scrolling through playlists\n- MENU/OZONE: Fix playlist thumbnail mouse hover after returning from Quick Menu\n- MENU/OZONE: Thumbnail visibility corrections\n- MENU/OZONE: Playlist metadata reformat\n- MENU/OZONE: Savestate thumbnail fixes\n- MENU/OZONE: Add savestate thumbnails\n- MENU/OZONE: Header icon spacing adjustment\n- MENU/RGUI: Savestate thumbnails\n- MENU/SETTINGS: Turn Advanced Settings on by default, this entire filtering of settings will need a complete rethink anyways\n- MENU/WIDGETS: Widget color + position adjustments\n- MIYOO: Exclude unused HAVE_HID for Miyoo\n- MIYOO: Enable screenshots\n- MIYOO: Enable rewind\n- NETWORK: Allow MITM server selection on OK callback\n- NETWORK: Replace socket_select calls\n- NETWORK: Implement binary network streams\n- NETWORK: Poll support\n- NETWORK: Check connect errno for successful connection\n- NETWORK: Get rid of the timeout_enable parameter for socket_connect\n- NETWORK: Fix getnameinfo_retro's port value for HAVE_SOCKET_LEGACY platforms\n- NETWORK: Define inet_ntop and inet_pton for older Windows versions\n- NETWORK: Define isinprogress function\n- NETWORK/NATT: Move natt files to \"network\"\n- NETWORK/NETWORK STREAMS: Add function netstream_eof\n- NETWORK/NETPLAY: Fix game CRC parsing\n- NETWORK/NETPLAY: Disable and hide stateless mode\n- NETWORK/NETPLAY: Change default for input sharing to \"no sharing\"\n- NETWORK/NETPLAY: Enforce a timeout during connection\n- NETWORK/NETPLAY: Disallow clients from loading states and resetting\n- NETWORK/NETPLAY: Special saves directory for client\n- NETWORK/NETPLAY: Ensure current content is reloaded before joining a host\n- NETWORK/NETPLAY: Fix client info devices index\n- NETWORK/NETPLAY: Fix input for some cores when hosting\n- NETWORK/NETPLAY: Memory leak fixes\n- NETWORK/NETPLAY: Force a core update when starting netplay\n- NETWORK/NETPLAY: Fix NAT traversal announce for HAVE_SOCKET_LEGACY platforms\n- NETWORK/NETPLAY: Refactor fork arguments\n- NETWORK/NETPLAY: Fix content reload deadlocks on static core platforms\n- NETWORK/NETPLAY: Disallow netplay start when content is not loaded for static core platforms\n- NETWORK/NETPLAY: Show client slowdown information\n- NETWORK/NETPLAY: Improve check frames menu entry\n- NETWORK/NETPLAY: Do not try to receive new data if the data is in the buffer\n- NETWORK/NETPLAY: Copy data on receive, even if the buffer is full\n- NETWORK/NETPLAY: Fix lobby sublabel CRC display on some platforms\n- NETWORK/NETPLAY: Support for customizing chat colors\n- NETWORK/NETPLAY: Small launch compatibility patch adjustments\n- NETWORK/NETPLAY: Support for banning clients\n- NETWORK/NETPLAY: Minor tweaks to the find content task\n- NETWORK/NETPLAY: Support for gathering client info and kicking\n- NETWORK/NETPLAY: Fix possible deadlock\n- NETWORK/NETPLAY: Initialize client's allow_pausing to true\n- NETWORK/NETPLAY: Disable netplay for unsupported cores - with stateless mode being disabled for now, there is no reason not to include this. Refuse to initialize netplay when the current core is not supported (no proper savestates support)\n- NETWORK/NETPLAY/DISCOVERY: Ensure fixed width ints on packet struct\n- NETWORK/NETPLAY/DISCOVERY: Support for IPv4 tunneling (6to4)\n- NETWORK/NETPLAY/DISCOVERY/TASKS: Netplay/LAN Discovery Task refactor -  aims to prevent blocking the main thread while awaiting for the LAN discovery timeout; This is accomplished by moving the whole discovery functionality into its task and using a non-blocking timer to finish the task. Also fixes discovery sockets not being made non-blocking, which could cause the main thread to hang for very long periods of time every pre-frame.\n- NETWORK/NETPLAY/TASKS: Find content task refactor - fixes many issues along the way, including a couple of nasty memory leaks that would leak thousands of bytes each time the task ran. It also expands the original concept by matching currently run content by filename (CRC matching is always performed first though).\n- NETWORK/NETPLAY/TASKS: Find content task refactor - Ensure CRC32 is 8 characters long\n- NETWORK/NETPLAY/LOBBY: Add setting for filtering out rooms with non-installed cores\n- NETWORK/NETPLAY/LOBBY: Hide older (incompatible) rooms\n- NETWORK/NETPLAY/LOBBY: Add a toggleable filter for passworded rooms. In addition, move lobby filters into its own submenu for better organization.\n- NETWORK/NETPLAY/MENU: Chat supported info for the host kick submenu\n- NETWORK/NETPLAY/MENU: Localize relay servers\n- NETWORK/NETPLAY/MENU: Host Ban Submenu\n- NETWORK/NETPLAY/MENU: Add client devices info to the kick sub-menu\n- NETWORK/NETPLAY/MENU: Path: Netplay -> Host -> Kick Client - Allows the host to kick clients. Allows the host to view client information: connected clients (names), status (playing/spectating) and ping.\n- NETWORK/NETPLAY/VITA: Add net_ifinfo support\n- NETWORK/NETPLAY/VITA: Enable partial LAN discovery\n- NETWORK/NETPLAY/VITA: Change default UDP port to 19492\n- NETWORK/NETPLAY/VITA: Do not multiply negative timeout values\n- NETWORK/NETPLAY/VITA: Fix epoll's timeout parameter\n- NETWORK/NETPLAY/VITA: Launch compatibility patch\n- NETWORK/NETPLAY/3DS: Launch compatibility patch\n- NETWORK/NETPLAY/3DS: Adapt POLL for 3DS platform\n- NETWORK/NETPLAY/PS3: Launch compatibility patch\n- NETWORK/NETPLAY/WII: Enable net_ifinfo for some features. In practice, this only allows the netplay's UPnP task to succeed on the Wii.\n- NETWORK/NETPLAY/WIIU: Launch compatibility patch\n- NETWORK/NETPLAY/SWITCH: Launch compatibility patch\n- NETWORK/UPNP: Attempt support for remaining platforms\n- NETWORK/UPNP: Support for IPv4 tunneling\n- ODROID GO2: Increase DEFAULT_MAX_PADS to 8 for ODROIDGO2, since that impacts the RG351[X] consoles. The RG351[X] have a USB host controller and can have an arbitrary number of USB gamepads.\n- ONLINE UPDATER: Online Updater menu reorganizing\n- OSX: Fixed items of system top menu bar on macOS\n- OSX: Revision to macOS app icon set\n- PLAYLISTS: Ensure history list will contain CRC32\n- PLAYLISTS: Fix CRC32 comparison - as state->content_crc has \"|crc\" suffix.\n- PS4/ORBIS: Orbis/PS4 Support using OrbisDev toolchain\n- PS4/ORBIS: Update xxHash dependecy\n- PS4/ORBIS: Shader cache\n- RETROFW: Exclude unused HAVE_HID for RetroFW\n- RETROFW: Support battery indicator on RetroFW\n- RETROFW: Enable menu toggle button on retrofw devices\n- SHADERS: Shader Preset Loading of Multiple additional #references lines for settings\n- SHADERS: Shader Load Extra Parameter Reference Files - this adds the ability to put additional #reference lines inside shader presets which will load additional settings. The first reference in the preset still needs to point at a chain of presets which ends with a shader chain, and subsequent #reference lines will load presets which only have parameter values adjustment. This allows presets to be made with a modular selection of settings. For example with the Mega Bezel one additional reference could point at a preset which contained settings for Night mode vs Day mode, and another reference could point to a preset which contained settings for how much the screen should be zoomed in.\n- SHADERS/MENU: Increase shader scale max value\n- SCANNER/DC: Fix Redump bin/cue scan for some DC games\n- SCANNER/GC/WII: Add RVZ/WIA scan support for GC/Wii\n- SCANNER/PS1: Improved success rate of Serial scanning on PS1 by adding support for the xx.xxx format\n- SCANNER/PS1: Changed return value of detect_ps1_game function to actuially return a failure when the Serial couldn't be extracted. Scanner will then fallback on   crc check, and usually ends up finding the games in the database.\n- SWITCH: Enable RWAV (WAV audio file) support\n- STRING: Do not assume char is unsigned\n- TASKS: More thread-awareness in task callbacks\n- TASKS: Fix race condition at task_queue_wait\n- TVOS: Revised tvOS icons w/ updated alien.\n- VFS: Fix various VFS / file stream issues\n- VULKAN: Fix more validation errors\n- VULKAN: Attempt to fix validation errors with HDR swapchain. Always use final render pass type equal to swapchain format. Use more direct logic to expose if filter chain emits HDR10 color space or not\n- VULKAN/ANDROID: Honor SUBOPTIMAL on non-Android since you'd want to recreate swapchains then. On Android it can be promoted to SUCCESS.\nSUBOPTIMAL_KHR can happen there when rotation (pre-rotate) is wrong.\n- VULKAN/DEBUG: Automatically mark buffer/images/memory with names\n- VULKAN/DEBUG: Move over to VK_EXT_debug_utils. Debug marker is deprecated years ago.\n- VULKAN/HDR: Fix leak of HDR UBO buffer\n- VULKAN/BFI: Fix BFI (Black Frame Insertion) regression\n- WINDOWS: Fix exclusive fullscreen video refresh rate when vsync swap interval is not equal to one - refresh rate in exclusive fullscreen mode was being incorrectly multiplied by vsync swap interval, breaking swap interval functionality at the gfx driver level\n- WIN32: Do optimization for Windows where we only update the title with SetWindowText when the previous title differs from the current title\n- WIN32: Skip console attach when logging to file\n- WIN32: Remove black margins with borderless non-fullscreen window\n- WIN32/TASKBAR: Release ITaskbarList3 on failed HrInit - pointer wasn't NULL'd, thus set_window_progress would cause weird behavior\n- WII/GX: Fix potential datarace\n- WIIU: Implement sysconf and __clear_cache\n- WIIU: Add OS memory mapping imports\n- UWP: Added launch protocol arg 'forceExit' so a frontend can tell an already-running RetroArch UWP instance to quit.\n- UWP: Enable core downloader/updater\n- UWP: Remove copy permissions as its inefficient as we can just directly assign the new ACL and that works\n- Xbox/UWP: Remove expandedResources\n- Xbox/UWP: UWP OnSuspending crash fix\n- Xbox/UWP: Enable savestate file compression by default for UWP/Xbox - got told there are no more issues with it\n- Xbox/UWP: Add support for 4k to angle on xbox for MSVC2017 build\n\n# 1.10.3\n- ANDROID: Decouple Play Core dependency to bring app into compliance for F-Droid\n- ANDROID: Allow audio playback capture on android\n- AI/SERVICE: Disable AI Service setting by default\n- BLUETOOTH/LAKKA: bluetoothctl: add / modify pairing steps\n- CHEEVOS: Disallow manual frame delay setting in Hardcore Mode\n- DATABASE: Serial scanning for Wii now includes WBFS\n- INPUT: Allow proper descriptor declaration for analog triggers\n- INPUT/MAPPING: Fix offset + crash when clearing input port binds\n- INPUT/MAPPING: Fix saving of 'Analog to Digital Type' when configuration overrides are used\n- INPUT/MAPPING: Fix saving of 'Analog to Digital Type' when configuration overrides are used\n- LOCALIZATION: Add Valencian language option\n- LOCALIZATION: Updates\n- MENU/SETTINGS: Move 'Show Menu Bar' under 'Windowed Mode' settings\n- MENU/SETTINGS: Add sublabels for 'Subsystems' and 'Input Deadzone/Sensitivity'\n- MENU/SETTINGS: Move 'On-Screen Notifications' to top\n- MENU/XMB: Unified the shadow alpha value to a slightly darker one for better readability\n- MENU/XMB: Corrected the option label and sublabel for actual behavior\n- MIYOO: Enable ALSA audio driver and default to it\n- PSP: Take out extra languages/localization, adds about 4/5MB to the binary, and RAM is limited on PSP (32MB and 64MB RAM models)\n- STATIC PLATFORMS: Populate all history list metadata when launching content from playlists\n- STEAM: Introduce Steam Rich Presence\n- VIDEO: Fast-Forward Frameskip improvement\n- VIDEO/THREADED: Stability fixes\n- WINDOWS/WINRAW: Fix multiple light guns\n- WIIU: Fix USB get_device_name(), don't truncate to three chars\n\n# 1.10.2\n- 3DS: Add a menu toggle for switching between old and new 3DS speeds, located in the 'Power Management' menu. Enabled by default, hidden on old 3DS devices.\n- AUDIO/MIXER: Free audio voices properly\n- CHEEVOS: Update to rcheevos 10.3.3\n- CHEEVOS: Support for Arduboy\n- CHEEVOS: Fix tab sequences in rich presence being turned into t character\n- CHEEVOS: Fix overflow when parsing float value that has more than 9 digits after the decimal\n- CHEEVOS: Fix memory mapping when disconnect mask breaks a region into multiple blocks\n- CORES: Enable manual selection of which cores are displayed in the 'Standalone Cores' menu\n- DATABASE/EXPLORE: Added more categories to the Explore menu\n- INPUT: Fix analog stick not working with 'Unified Menu Controls'\n- INPUT/MAPPING: Add 'Manage Remap Files' submenu + automatically save input remaps when closing content\n- INPUT/MAPPING: Add 'Reset Input Mapping' option to 'Manage Remap Files' menu\n- INPUT/MAPPING: Fix keyboard device remap nulling\n- IOS/IOS13+: Support a toolbar that allows toggling of onscreen keyboard and touch mouse\n- LIBRETRO: RETRO_ENVIRONMENT_SHUTDOWN fix - ensure core is properly unloaded when RETRO_ENVIRONMENT_SHUTDOWN is called\n- LIBRETRO: RETRO_ENVIRONMENT_SHUTDOWN fix - ensure menu stack is properly flushed when RETRO_ENVIRONMENT_SHUTDOWN is called\n- LINUX/MALI FBDEV: Fix segfault switching video threaded from quickmenu\n- LOCALIZATION: Add Czech language support\n- MMAP: Handle disconnect bits on both sides of len\n- MIYOO: Improve CPU architecture and model name identification for Miyoo\n- MENU/SETTINGS: Remove 'Advanced Settings' flag from 'Settings > Core' menu\n- MENU/MATERIALUI: Add 'Gray Dark + Light' themes\n- MENU/RGUI: Add 6x10 extended ASCII and Latin Extended A and B fonts.  These will enable most Latin alphabets to be displayed in RGUI.\n- MENU/RGUI: Add 'Gray Dark + Light' themes\n- MENU/XMB: Add title margin adjustment\n- MENU/XMB: Vertical fade corrections\n- MENU/OZONE: The size of the thumbnail bar can now be changed though a new option (Settings->User interface->Appearance) up to double its normal size.\n- MENU/OZONE: Add 'Gray Dark + Light' themes\n- MENU/OZONE: Add thumbnail scale option\n- HOTKEYS: Added hotkey for toggling sync to exact content framerate\n- HOTKEYS: Prevent log spam when using rewind hotkey with cores that don't support rewind, if rewind functionality itself is disabled\n- HOTKEYS: Add hotkey for toggling sync to exact content framerate\n- PS3/PSL1GHT: Add RSX graphics support\n- PS3/PSL1GHT: Add libco support\n- PS3/PSL1GHT: Add experimental PSMove support\n- RS90: Optimise layout of sdl_rs90_video\n- STEAM: Use native OSK (Onscreen Keyboard) instead of built-in RetroArch version\n- STEAM: New built-in core DLC downloader\n- STEAM: Swap OK/Cancel buttons by default\n- VIDEO/HDR: Removed redundant copy of buffer in HDR mode if the shader has already a HDR format i.e. R10G10B10A2 (updated Vulkan/D3D11/D3D12 drivers)\n- VIDEO/HDR: Fixed crash when using stock shader and HDR and previous optimisation\n- WAYLAND: Dynamically load libdecor at runtime\n- WAYLAND: Fix splash screen when using xdg_toplevel\n- WAYLAND: SHM anti-collision for the splash screen\n- WAYLAND: Skip splash screen if window is not ready\n- WII: Fix find_connection_entry(): needs unsigned int\nOtherwise the USB gamepad cannot be found, if VID/PID has leading zero. This issue happened with Retrode gamepad adapter\n- WII: Rework Retrode gamepad implementation to support multi_pad interface\n- WII: Fix - Unplugging and re-plugging now works again\n- WII: vWii- Only gamepad 1 is supported, because multi_pad is currently only relevant in the Wii U implementation\n- WIIU: Implemented the multi_pad interface according to input/connect/connect_wiiugca.c\n- WIIU: Add Optimize for Gamepad option\n- WIIU: Fix USB gamepad support\n\n# 1.10.1\n- ANDROID: Add `HAVE_LANGEXTRA` back to makefile\n- ANDROID: Include adaptive launcher icons\n- ANDROID: Populate external storage devices inside the file browser on Android 11+ devices\n- CHEEVOS: add mastery placard\n- CHEEVOS: more description message for missing RetroAchievements credentials\n- CHEEVOS: prevent occasional infinite wait loading multi-disc game from secondary disc\n- CHEEVOS: stop load process if unable to retrieve achievement data\n- CHEEVOS: support for identifying Dreamcast CHDs\n- CHEEVOS: Updated to 10.3.2\n- CONTENTLESS CORES: Disable per-game and per-content-directory remaps when running contentless cores\n- CONTENTLESS CORES: Disable per-game and per-content-directory shader presets\n- CONTENTLESS CORES: Enable config overrides\n- CONTENTLESS CORES: Enable runtime logging\n- CORE INFORMATION: Show core version\n- CORE UPDATER: Add 'Core System Files Downloader'\n- CORES/SETTINGS: Add 'Standalone Cores' menu\n- D3D10/D3D11: Add Vsync swap interval\n- EMSCRIPTEN: Enable 7zip\n- GBA: New GBA filter Upscale_240x160-320x240\n- GONG: Removed now that it's a standalone core\n- HISTORY/FAVORITES: Fix default core on 'Add to Favorites'\n- INPUT/WAYLAND: Allow toggling mouse grabs\n- INPUT/WAYLAND: Release keys and mouse buttons on lost focus\n- iOS: Support for custom keyboard and touch mouse support, among other iOS 13 features\n- LIBRETRO: Fix crash when cores using RETRO_ENVIRONMENT_SET_AUDIO_CALLBACK return false from retro_load_game()\n- LIBRETRO: Add optional frame skipping when fast-forwarding\n- LOCALIZATION: Fetch translations from Crowdin\n- LOCALIZATION: OSD fonts for Chinese, Korean, Arabic and Persian\n- LOCALIZATION: Translation fixes for various languages\n- MENU/RGUI: Add dynamic theme\n- MIYOO: Enable NEAREST audio resampler\n- MIYOO: Support battery level\n- NETPLAY: Disable savestates on stateless mode\n- NGC/Wii: Several improvements\n- OSX: Enable compilation on PPC\n- OZONE/XMB: Improve efficiency/accuracy of History/Favorites icon rendering\n- RECORDING/FFMPEG: Fix building against FFmpeg 5.0\n- RETROARCH INFORMATION: No longer report on enabled Python support, which was removed in RetroArch 1.7.8\n- SAVESTATES: Disable save states based on save state support level defined in core info files\n- UNIX/WINDOWS: Allow setting the default libretro_directory via environment variable\n- WAYLAND/VULKAN: Fix Wayland Vulkan not reacting to initial resize\n- WINDOWS/WINRAW: Enable mouse overlay control\n- Xbox/UWP: Fix CHD not working with Cheevos / Add 7zip support.\n\n# 1.10.0\n- 3DS: Add Jaxe, A5200 and WASM4 cores\n- 3DS: Fix rotation\n- ARCHIVE: Allow loading files from archive subdirectory\n- AUDIO: Remove frame limit from audio batch callback. Before, if a core used the audio batch callback, there would be a hidden cap of 1024 on the number of audio frames that could be sent. If a core exceeded this value, any excess samples were silently discarded. While this is sufficient for 'normal' samplerates/framerates, it means that e.g. a core using the batch callback to send 44100 Hz audio at 30 fps with would have entirely broken sound. This has been fixed by removing the audio batch frame limit.\n- AUDIO/RESAMPLER/NEON: Implement sinc kaiser NEON function\n- CHEEVOS: Reset hardcore default to enabled; show message when trying to load state in hardcore\n- CHEEVOS: Fix memory map conversion\n- CHEEVOS: Check netplay status when unlocking achievements\n- CHEEVOS: Support for hashing buffered NDS ROMs\n- CHEEVOS: Fix hung task whe badge doesn't exist\n- CLI: Load save states from command-line or playlist\n- CORE INFO CACHE/SETTINGS: Restore missing 'Cache Core Info Files' menu entry\n- DATABASE: Serial scanning for Gamecube/MegaCD/SegaCD/Saturn/PSX/PSP/Dreamcast/Wii\n- EMSCRIPTEN: Add Jaxe, WASM4 cores\n- FILE IO: Fix incorrect file names for remap files when the content path doesn't have a preceding slash\n- INPUT/OVERLAY: Added support for showing the overlay behind the menu instead of in front. This is currently only supported on the GL, Vulkan, D3D 9/10/11/12 and 3DS drivers.\n- INPUT/UDEV: Convert abs mouse from screen to viewport coordinates; fix relative mouse coords\n- INPUT/WAYLAND: Ignore mouse clicks on window decoration\n- INPUT/WAYLAND: Add scroll wheel support\n- LINUX: Added support for Linux GameMode (https://github.com/FeralInteractive/gamemode), which can be toggled on/off in the Power Management or Latency settings menus.\n- LOCALIZATION: Fetch translations from Crowdin\n- LOCALIZATION: Add Indonesian, Swedish and Ukrainian language options\n- LOCALIZATION/MENU/RGUI: Enable Indonesian and Swedish localisations for RGUI\n- LOGGING: Logging cleanups\n- LOGGING: Stop logging FPS statistics twice on quit\n- LOGGING: Log font rendering backend only once\n- HOTKEYS: Added a hotkey toggle for the on-screen technical statistics.\n- HOTKEYS: Add delay + acceleration to volume hotkeys\n- MENU: Add option for showing notifications only in menu\n- MENU/RGUI: Add Finnish to supported languages\n- MENU/XMB: Optional vertical list item fade\n- MENU/XMB/OZONE: Category + History/Favorites icons\n- NETWORK: Fix dummy notification - no longer shows a netplay initialization failed notification when netplay is not enabled\n- NETWORK: LAN addresses only for UPnP - Some router devices might accept non-LAN addresses without raising an error.\n- NETWORK: Filter out non-connectable rooms. Add an option for filtering out non-connectable netplay rooms.\n- NETWORK: Netplay spectator notification fix. Fix double notification when the host switches to spectator.\n- NETWORK: Prevents long-term pausing from clients dishonoring allow pausing\n- NETWORK/LOBBY: Lobby Viewer: Filter out rooms that are not running RetroArch\n- NETWORK/LOBBY: Lobby Viewer: Display a non-connectable tag to non-connectable rooms\n- NETWORK/LOBBY: Host: Display warning if we are announcing to the internet but our room isn't connectable from there\n- NETWORK/RELAY: Custom relay server support - Add support for custom user-ran relay servers\n- NETWORK/RELAY: Replace Canadian relay server with Singapore relay server. Current relays: New York/USA, Madrid/Spain, Sao Paulo/Brazil, Singapore\n- NETWORK/UPNP: Various refactors/improvements, no more dependent on miniupnpc\n- NETWORK/UPNP: Various UPnP binding fixes for specific routers\n- NETWORK/UPNP: Accept IGD v2 service types\n- NETWORK/UPNP: Delay lobby server announcing - delay the announcing in order to give UPnP's port forwarding more time. Fix the remaining truncation warnings.\n- NETWORK/UPNP: Smart interface selection - Find the most suitable address for UPnP by scoring interfaces on how close their address is to the device's address\n- OPENGL1: Fix buffer overflow - RetroArch would sometimes crashes at startup when loading asset textures with GL1 driver\n- PS3: PSL1GHT port added to Gitlab CI\n- VULKAN: Double combined image sampler descriptor pool size - fix segfaults with AMD GPUs using RADV\n- VULKAN: Emulate mailbox only with Vsync enabled - otherwise have it disabled - useful for VRR/G-Sync/FreeSync\n- VULKAN/SWAPCHAIN: Vulkan max swapchain images option adjustments: removed value 1, since it won't be used - Video reinit on change, so that there is no need to restart or toggle fullscreen\n- VULKAN/HDR: HDR support - tested on Windows\n- WAYLAND: Add libdecor for client side decoration\n- WAYLAND: Use any display for initial metrics\n- WAYLAND: Fix the window closing, if RetroArch is build without libdecor\n- WAYLAND: Use checked sizes in EGL resize\n- WAYLAND: Fix window title update\n- WEBOS: Fix webOS build and run\n- WIIU: Fix rotation\n- UWP/XBOX: Fix content over 4GB (approx) failing to load, improve/speed up copy/load times\n- UWP/XBOX: Fix scanning for playlists\n- UWP/XBOX: Move content copied to LocalState to a dedicated dir and clear on startup\n- UWP/XBOX: Make content copy to a specific cache directory in the LocalState folder when it's copied\n- UWP/XBOX: Auto delete VFS cache dir on startup\n- UWP/XBOX: Make resolution switching automatic and fix angle output issues\n- UWP/XBOX: Force ANGLE to render at 1080p regardless of screensize as the output is 1080p regardless of screensize. This fixes an issue where at 4k any angle output would be zoomed into a corner.\n- UWP/XBOX: Set resolution based on display resolution (auto 4k)\n- UWP/XBOX: Set driver to D3D11 if booting with opengl\n- UWP/XBOX: Reset width and height of output on boot to match display\n- UWP/XBOX: Mitigate need for VFS cores on NTFS drives\n- UWP/XBOX: Make check for standard I/O by access rather than the just assuming based on path string\n- UWP/XBOX: Add code to auto permissions so files can be accessed by non VFS cores (no exFAT or FAT32 support yet)\n\n# 1.9.14\n- ANDROID/PLAYSTORE: Implement MANAGE_EXTERNAL_STORAGE permission\n- ANDROID/PLAYSTORE: Bump up SDK level to 30 to comply with Play Store policies\n- AUDIO/MIXER: Increase sample buffer padding\n- CHEEVOS: Disallow achievements when spectating netplay\n- CHEEVOS: Fix need-to-activate achievement logic for non-hardcore\n- CHEEVOS: Don't queue rewind re-init if already on main thread\n- CHEEVOS: Ignore unofficial achievements unless setting is enabled\n- CHEEVOS: Use SSL host when available\n- CHEEVOS: Validate hashes for secondary discs in multi-disc games\n- CHEEVOS: Ensure placard is initialized on main thread when game has no achievements\n- CHEEVOS: Audit achievement settings defaults and visibility\n- CHEEVOS: Show error message when no password provided\n- CHEEVOS: Use widget for game loaded achievement progress\n- CONFIG: Honor config_save_on_exit when Reboot/Shutdown is called\n- DISK CONTROL: Focus on current content entry in Disk Control append/insert\n- FRAMEDELAY: Auto Frame Delay Improvements - swap interval handling, D3DX handling, and delay target resets also on core restart. It should now work with high refresh rates and also with Direct3D 10/11/12 drivers\n- INPUT/GYRO/ACCELEROMETER/ANDROID: Re-enable Gyroscope & Accelerometer when RetroArch resumes or regains focus\n- INPUT/HID: Fix gamepad disconnect on unrecognized HID device\n- LAKKA: Patch to fix keyboard typing\n- LAKKA: CD-ROM eject menu item\n- LAKKA/BLUETOOTH: Add option to remove pairing\n- LAKKA/SWITCH: Disable rumble gain\n- LAKKA/SWITCH: Disable cpu scaling, uses its own CPU governor\n- LOGGING: Logging cleanups. A bunch of unifications and reformattings (capitalizations, dots, quotes, prefixes etc). Also added a few missing things, such as Run-Ahead error logging and LED interface init logging when it is enabled.\n- NETPLAY: Networking - should not print country for a local lobby\n- NETPLAY: Added setting to allow/disallow players other than the host from pausing the game.\n- NETPLAY: Added a sublabel for netplay max connections.\n- NETPLAY: Fixed port override macro from not being set immediately after the port setting.\n- NETPLAY: Show passworded rooms on lobby\n- NETWORK: Make HTTP header parsing case insensitive\n- NETWORK/UPNP: Fixed memory leaks\n- NETWORK/UPNP: Added a task_queue_wait to prevent executing two nat tasks at once, so it's also thread safe now\n- NETWORK/UPNP: Switch to a permanent lease time, but request it to be removed when we do netplay_free. Switch to a permanent lease time, but request it to be removed when we do netplay_free.\n- NETWORK/UPNP: Only use a single interface for UPnP, return on the first one found instead of iterating over all of them and opening them one by one\n- OVERLAYS: Revert changes\n- RETROFW: Add OSS audio\n- VIDEO/ROTATION: Always return false if rotation can't occur. RETRO_ENVIRONMENT_SET_ROTATION should return false when rotation has been forcefully disabled in frontend, that way the core can decide if aspect ratio should be rotated or not for vertical games. Useful for FBNeo for instance.\n- VULKAN: Avoid hard crash when capturing screenshot in emulating mailbox.\n- WIIU: Make wiiu_gfx_load_texture code safer\n- WIIU: Fix keyboard support.\n\n# 1.9.13\n- CHEEVOS/MSVC2010: Add Cheevos support\n- CRT/SWITCHRES: Fixes some issue where scaling is incorrect in some video modes for CRT output.\n- FRAMEDELAY: Add 'Automatic Frame Delay' option\n- INPUT: Add 'All users control the menu' setting - any gamepad can control the menu when this is enabled. Only limitation right now is that only player 1 can toggle the menu, but any set Menu Toggle Controller Combo will work fine for all users, so this should be acceptable for now\n- INPUT/UDEV: Fix Dolphin bar and safeguard against not adding devices with no mouse or touch buttons detected\n- NETPLAY/CLI: -C/--connect commandline fix\n- NETPLAY: Other improvements\n- NETPLAY: Remove forced disconnection on unknown netplay command -\nwill be backwards compatible with any version that removed this\ndisconnect. instead of disconnecting, we just read the data and\nignore, like most network implementations do\n- TASKS/CHEEVOS: Replace coroutines with tasks/thread\n- TASKS/DATABASE/EXPLORE: Initialise 'Explore' menu on a background thread - no more stall when hovering over the Explore tab\n\n# 1.9.12\n- 3DS: Ensure parallax barrier is disabled when '3DS Display Mode' is '2D'\n- COMMAND: Command interface should work again\n- INPUT/HID: Rewrote the HID deregistration algorithm; it should no longer cause issues when dealing with multiple pads of the same HID/VID combo\n- INPUT/HID: Fix initialization bug that caused wiimotes to fail to register without an accessory attached\n- INPUT/HID: Fix Wiimote regression\n- INPUT/HID/MAC: Get Sony Sixaxis (DualShock 3) working on MacOS\n- INPUT/UDEV: Add extra abs check for dolphinbar\n- INPUT/UDEV: Add relative left mouse button when pointer device is not abs\n- INPUT/WAYLAND: Fix keyboard input on Wayland - fixes 'Certain cores ignore user input'\n- NETPLAY: Improvements from Cthulhu\n- OPENDINGUX: Fix HAS_ANALOG/HAS_MENU_TOGGLE defines in sdl_dingux joypad driver\n- LIBRETRO: Enable SRAM for contentless cores\n- LIBRETRO: Add environment callback to get the rate retro_run is called - GET_THROTTLE_STATE and RETRO_THROTTLE_UNBLOCKED environment callback\n- LINUX: Update metadata manifest\n- MENU/OZONE: New themes - Solarized Light, Solarized Dark\n- WINDOWS/WIN9X: Fix non-ASCII text display in window title\n\n# 1.9.11\n- ANDROID: New launcher logo - will fill the corners on the homescreen\n- D3D9: Driver works again (RGUI only and software rendered cores work, no shader support yet)\n- HID/MAC: WiiU GameCube Adapter now works\n- HID/WIIU: WiiU and general HID subsystem unified/merged\n- INPUT: Refactor menu toggle combo button logic to allow quit combo button\n- INPUT/UDEV: Add mouse relative check and set appropriately to fix issue\n- LIBNX/SWITCH: Splitted Joycon button mapping\n- LIBRETRO: Add environment callback to enable cores to notify the frontend that a core otion value has changed\n- MIYOO: Add initial port\n- OPENDINGUX/RG350: Enable tinyalsa for the RG350\n- PS2: Add 'Change Resolution' option\n- PS2: Add option to change video windows offsets\n- STEAM/LINUX: Move to new 'soldier' runtime\n- WAYLAND: Remove xdg-shell-v6 protocol\n- WINDOWS: Fix non-ASCII text display in window title\n- WINDOWS 11: Shows Windows 11 version name now (Information -> System Information)\n- UWP: Further improvements to WinRT VFS layer\n\n# 1.9.10\n- 3DS: Add bottom screen idle state\n- 3DS: Add unique IDs for Gearboy/Gearcoleco/Gearsystem, correct CAP32 code\n- 3DS/SAVESTATES: Fix RAM states to file when core deinits\n- AUDIO/MIXER: Pad sample buffers to prevent potential heap-buffer-overflows when resampling (fixes crash when using 30 kHz menu audio files)\n- AUDIO/LINUX/SNAP: Add JACK support\n- CHEEVOS: Don't write achievement credentials to overrides\n- CHEEVOS: Disable slowmotion when enabling hardcore mode\n- D3D9: Fixed MVP matrix issue for RGUI texture (main game frame still won't show up though)\n- D3D11/D3D12/HDR: Fixed contrast to be more correct - now scales from 0-10 linearly and behaves more the way you'd expect it to - changed name to ditch legacy settings users may have\n- D3D11/HDR: Fixed D3D11's blend, rasterizer and topology states not being set to the sames when using HDR and leaving the menu - caused issues with PCSX2's Shadow of the Colossus\n- D3D11/D3D12/HDR: Added ability to skip inverse tonemapper to the shader via the constant buffer using 'inverse_tonemap' - set to 0.0f to skip\n- D3D11/D3D12/HDR: Fixed potential bug when swapping between hdr and sdr and the bit depth not being set correctly\n- D3D11/D3D12/HDR: Added numerous helper functions to help create the correct values to colour the UI - normally the white UI elements should be rendered at paper white not max brightness for various reasons\n- BUGFIX/ANDROID: Fix crash that could happen on Android with Sameboy core - would crash on rumble function\n- GFX/WIDGETS: New regular widget message appearance\n- INPUT/MOUSE: Add distinct mouse zero index label for drivers that do not support multimouse\n- INPUT/RUMBLE: Add generic rumble gain to input settings\n- INPUT/UDEV/X11: Add workaround to fix keyboard input when using X11 + Udev\n- LIBNX/SWITCH: Add Video Filters support\n- LOCALIZATION: Fetch translations from Crowdin\n- OPENDINGUX/BETA: Disable OpenAL\n- PLAYLISTS: Add 'Refresh Playlist' option\n- STEAM: Initial release on Steam\n- UWP/VFS/XBOX: Improvements and bugfixes to UWP VFS driver\n- VIDEO/REFRESH RATE: Automatic PAL/NTSC refresh rate switch where available - as long as the platform display server allows changing refresh rates and the display has the desired refresh rate\n- VIDEO FILTERS: Add 'Picoscale_256x-320x240' video filter\n- WIIU/HID: Fix analog inputs on HID devices\n\n# 1.9.9\n- 3DS: Add bottom touchscreen menu\n- 3DS/SAVESTATES: Save and load save states to and from RAM\n- AUDIO/MIXER: Ensure than menu sounds are re-enabled when calling CMD_EVENT_AUDIO_REINIT\n- AUDIO/RESAMPLER/MIXER: Fix menu sounds (audio mixing) when using the 'sinc' resampler with quality lower than 'normal'\n- AUDIO/CONVERSION/ARM NEON: Add intrinsic NEON versions for float_to_s16/s16_to_float - should lead to optimized codepaths for AArch64/ARMv7 architectures without being dependent on ASM codepaths.\n- AUDIO/RESAMPLER/ARM NEON: Add intrinsic NEON version for lanczos sinc function - should lead to optimized codepaths for AArch64/ARMv7 architectures without being dependent on ASM codepaths.\n- CHEEVOS: Upgrade to rcheevos 10.2\n- CHEATS: Add enhanced search functionality to the 'Cheats' menu\n- CHEATS/RUNAHEAD: Fix cheats when using second instance runahead\n- CONFIG: Add option to (force-)write current core options to disk (Quick Menu)\n- CORE INFO CACHE: Remove core path from core info cache. Should make core info caches portable now (for example: you can move RetroArch to a separate dir and they would still work).\n- D3D11: Use Shader Model 5.0 for frontend shaders if D3D11 Feature level is at least 11.0 or higher. Should fix some new shaders that require SM 5.0 (like AMD FSR)\n- D3D11: Add HDR support (disabled for UWP for now)\n- D3D12: Add HDR support (disabled for UWP for now)\n- EMSCRIPTEN: Fixed web player bug with filesystem and runtime\n- INPUT/OVERLAY: Fix overlay input when analog to digital mapping is enabled\n- INPUT/UDEV: Look for \"ID_INPUT_KEY\", not \"ID_INPUT_KEYBOARD\"\n- INPUT/WINRAW: Fix crash when overlay is enabled\n- MAC/METAL: Add Discord RPC support\n- MENU: Allow 'Custom Aspect Ratio (X Position)/(Y Position)/(Width)/(Height)' to be entered manually via keyboard\n- MENU: Allow 'Vertical Refresh Rate' to be entered manually via keyboard\n- MENU/SHADERS: Highlight currently selected value in Shader Parameter drop-down lists\n- STABILITY: Safer way of avoiding the race condition in\naudio_driver_sample/audio_driver_sample_batch - we can check\naudio-suspended to see if we're doing a fs/windowed toggle - enhances stability when fullscreen toggling/tearing down context\n- STABILITY: When audio driver write callback function fails, don't\nturn audio off completely - look if audio_driver_output_samples_conv_buf\nis non-NULL first before we attempt to write audio - enhances stability when fullscreen toggling/tearing down context\n- STABILITY: Input robustness for cores that use internal threading\n(full teardown/setup), no audio should be processed at this point in\ntime\n- VIDEO: Screen resolution list sanitizing\n- VULKAN: Fix some Vulkan validation layer errors\n- UWP: Updated icons courtesy of Danp142\n- UWP/XBOX: Disable CPU model check on Xbox as it doesn't work and can even crash\n- UWP/VFS/XBOX: Code cleanup and simplification of UWP VFS driver\n\n\n# 1.9.8\n- AUDIO/WINDOWS/WASAPI: Stop deactivating audio on fast forward\n- CHEEVOS: Hide challenge indicators when resetting\n- CHEEVOS: Support for more than 64 memory regions\n- CHEEVOS: Automatically retry 'http error code -1'\n- CONTENT INFORMATION: Show content info label+path rows always\n- CORE OPTIONS: Core option categories implemented\n- CORE OPTIONS: Add option to disable core option categories\n- D3D10/11/12: Fix gfx_display_draw_texture - fixes OSK (On-Screen Keyboard) issues\n- DATABASE: Fix heap-buffer-overflow when fetching CRC values\n- DATABASE/EXPLORE: Fix CRC32 reading in explore menu\n- DATABASE/LIBRETRODB: Fix writing of numerical values\n- DATABASE/LIBRETRODB: Fix libretro-db loading on big endian platforms\n- DUMMY CORE: Skip state_manager_event_{deinit/init} when core type is dummy, should skip warning spam 'Implementation uses threaded audio. Cannot use rewind..' when using rewind\n- INPUT/UDEV: Limit udev device scan to subsystem 'input'\n- INPUT/SDL2/WINDOWS: Fix keyboard event keycodes\n- INPUT/WAYLAND: Fixes a bug where the first player's mouse, pointer, and lightgun are echoed to the other ports. Now, those other ports correctly report zero. In the future support for multiple mouselike devices will need to be added, which is a bigger project\n- INPUT/WAYLAND: The driver now respects keyboard_mapping_blocked\n- INPUT/WAYLAND: When possible, deprecated lightgun defines are replaced with the new ones. The coordinates are still using the old relative callbacks\n- INPUT/WINRAW: Trigger joypad driver reinit on DEVICECHANGE - avoids fullscreen toggle\n- INPUT/WINRAW: Alt sticky fix\n- INPUT/WINRAW: Prevent Alt getting stuck when Alt-Tabbing\n- INPUT/WINRAW: Add pointer status\n- INPUT/WINRAW: Add missing analog keybinds\n- LIBNX/SWITCH: Fix poll missing for controller 2-8\n- LIBNX/SWITCH: Fix layout not applied correctly and hangs when splitting joycons\n- LIBRETRO: Core options category API implemented\n- LIBRETRO: Fix RETRO_ENVIRONMENT_SET_FASTFORWARDING_OVERRIDE callback when runahead is enabled\n- LIBRETRO: Add environment callback for enabling core option menu visibility updates without toggling Quick Menu\n- LOGGING: Starting logging and verbose mode before first config load\n- LINUX: In some Linux Desktop Environments, like Budgie, task bar feature is unable to pin applications. With StartupWMClass= present in .desktop file, it is possible to pin the application\n- LOCALIZATION: Fetch translations from Crowdin\n- MENU: Relocate 'Manage Playlists' to top\n- MENU: Fullscreen resolution width/height settings no longer require 'advanced settings'\n- MENU/REFRESH RATE: Fix double notifications with refresh rate settings\n- MENU/OZONE: Ensure the existence of values used in selection calculation\n- MENU/OZONE/VULKAN: Casting to unsigned caused an integer overflow and after float promotion would lead to 'x' being a garbage value, leading to problems when this value was passed to vkCmdSetViewport. This stops Vulkan validation layers from complaining about it\n- METAL: Fixed font driver memory leaks\n- MOUSE: Change default mouse index to port index\n- MOUSE: Friendly names for mice where available\n- OSX: Fix some memory leaks\n- OSX: Fix controller duplication bug\n- PS2: Implement alpha for the video driver\n- PS2: Aspect ratio handling\n- RETROFW: Initial port\n- UWP/XBOX: Enable Explore tab by default - seems to work fine\n- UWP/XBOX: Fix startup issues with latest Xbox Dashboard updates - ANGLE cores still show up wrong\n- UWP/XBOX: fix issue where files where opened as OPENALWAYS instead of OPENEXISTING this fixes beetle cores\n- UWP/XBOX: fix issue where filesizes where not returned properly, this fixes loading arcade dat files\n- UWP/TRANSLATION: Enabled translation services for both UWP MSVC2017 and 2019. No TTS speech yet.\n- VIDEO: Fix refresh rate 59Hz rounding\n- WINDOWS: Remember original refresh rate\n- WINDOWS/VULKAN: Refresh rate fixes + cleanups\n- WIIU: Fix L3/R3 buttons\n- WIIU: Compress RPX libretro cores\n- WIIU: Add ICInvalidateRange (necessary for JITs)\n- WIIU: Slight filesystem optimisation\n- WIIU: Add option for running without core info (emscripten-style)\n\n# 1.9.7\n- 3DS: Add unique ID's\n- CRT/SWITCHRES: Fixed some Monitor index bugs ad updated to the latest SR2\n- CRT/SWITCHRES: Fixed monitor index corruption on Windows and added correct fractal scaling. Only used when required\n- CRT/SWITCHRES: Updated log defines to match SR upstream.\n- CRT/SWITCHRES: Added new SR_CONFIG_PATHS for non Windows and Linux systems.\nNot that SR works on them but to fix RA compile issues\n- CRT/SWITCHRES: Updated SR2 code base to latest. Added supprt for windows monitor indexing. Fixed monitor index bug where index 1 was not being used correctly and \"auto\" was not being sent.\n- CRT/SWITCHRES: Updated swithres for x86 windows fix\n- CRT/SWITCHRES: fixed SR2 auto issue\n- CRT/SWITCHRES: Fixed auto monitor bug\n- CRT/SWITCHRES: Fixed monitor index corruption on Windows\n- CRT/SWITCHRES: Fixed buffer size bug\n- CRT/SWITCHRES: Added correct fractal scalling. only used when required.\n- CORE INFO: Automatically disable core info cache when core info directory is read-only\n- EMSCRIPTEN: add MAME2003 / MAME2003-plus to web.libretro\n- INPUT/UDEV: udev fixes add pointer pressed to pointer device to allow udev users to access this device\n- LIBNX/SWITCH: Enable 7zip support\n- LINUX/XDG: Prevent xdg-screensaver's \"Protocol error\" messages\n- LOCALIZATION: Fetch translations from Crowdin\n- LOCALIZATION: Add missing languages for the first startup\n- MENU/XMB/WIDGETS: Add workaround for FPU bug that breaks scale factor comparisons on certain platforms (fixes XMB thumbnails on 32bit Linux/Windows)\n- MENU/RGUI: Enable fullscreen thumbnail toggle using RetroPad 'start' button\n- MENU/RGUI: Fix sublabel length when menu clock is disabled\n- NETWORK/HTTP: Fix HTTP progress indication for large files on 32-bit systems\n- NETWORK/NATT: implement natt fix from void()\n- OPENDINGUX: Fix display when cores 'drop' frames\n- OPENDINGUX BETA: Use ALSA audio driver by default\n- OPENDINGUX BETA: Fix IPU scaling when running 256x224 (SNES/Genesis) content\n- PATHS: Fix garbled path string\n- PS2: Implement proper ps2_font driver instead of using the font driver from gskit\n- PS2: Use BDM for increasing up USB stability\n- PS3: First basic RSX driver for PSL1GHT\n- RS90: Initial port\n- RS90: Fix offset of OSD text\n- RS90: Disable menu clock by default\n- RS90: Hide 'Bilinear Filtering' video option\n- RS90: Move appdata (retroarch) base directory to external microsd card\n- RS90: Add optional approximate 'semi-linear' scaling filter\n- SHADERS: Max Shader Parameters increased to 1024\n- VIDEO: Add 'Integer Scale Overlay' - Force integer scaling to round up to the next larger integer instead of rounding down\n- VIDEO: New 'Full' aspect ratio added. This aspect ratio is useful when used with a shader which has a border in it. The aspect ratio is set to the full window area, so that the viewport spans the whole viewport. When using a border type shader like the Mega Bezel this allows the graphics to span the whole window regardless of the user's monitor aspect ratio\n- VITA: Wrong flags for not piglet version\n- UNIX: Correct backlight max_brightness path\n- UWP/XBOX: Default to Direct3D11 driver on UWP builds\n- UWP/XBOX: Do not use windowed mode on UWP/Xbox by default, set default resolution to 1920x1080 by default. Should fix display issues with Dolphin/PCSX2 on Xbox\n- WIIU: Fix inputs breaking when connecting/disconnecting remotes\n- WIIU: Input - ignore some bogus KPAD results\n- WIIU: Font rendering fixes - render font lines with correct spacing, and only sample alpha channel when rendering fonts\n- WIIU/NETWORK: Network speed optimisations - WINSCALE, TCP sACK, large buffers\n- WIIU/LIBFAT: Increase cache size on WiiU\n- WIIU/FILE IO: Filesystem optimisations - add fast path for already aligned buffers\n- WIIU/FILE IO: Use 128K vbufs for WiiU - we have loads of RAM and large vbufs are very beneficial\n- WIIU/MENU/OZONE: Fix Ozone rendering error (scissor fix)\n- WIIU/MENU/OZONE: Use Ozone icons instead of XMB Monochrome\n\n# 1.9.6\n- ARCHIVE: Fix archive delimiter detection when file path contains no slashes\n- ANDROID: Do not duplicate port 0 mouse and gun inputs to other ports\n- AUDIO/XAUDIO2: Fail instead of crashing when disconnecting an audio device\n- CHEEVOS: Reset cached progress each time menu is opened\n- CRT/SWITCHRES: Add support for switchres.ini core and directory overrides\n- D3D11: Don't use allow tearing flag with blit swap chains. Also disables the flip model if the allow tearing flag is not supported.\n- D3D11: Disable DXGI's ALT+ENTER handling\n- D3D11: Don't pass ALLOW_TEARING when unsupported\n- D3D11: Fix non-vsynced output without flip, black screens in fullscreen\n- D3D12: Relocated 'd3d12_gfx_sync'\n- D3D12: Fixed swap interval option\n- GFX: Fix uninitialized variables in gfx_display_draw_cursor\n- HISTORY: Hide 'Add to Favorites' when viewing an entry of the favorites playlist\n- INPUT: 'Analog to Digital Type' usability improvements\n- INPUT: Add support for mapping multiple controllers to a single input device\n- INPUT/REMAPPING: Add support for mapping multiple controllers to a single input device\n- INPUT/LIGHTGUN: Bind lightgun trigger to first mouse button by default\n- INPUT/WINDOWS/RAWINPUT: Mouse access violation fix\n- INPUT/UDEV: Only add mouse if it has buttons and add vebose device friendly names\n- INPUT/UDEV: Skip mouse with no button errors and keep the rest\n- INPUT/UDEV: Fix Game Focus mode\n- INPUT/UDEV/X11: Change udev driver for dual lightgun support in X11\n- LIBNX/SWITCH: Update to libnx 4.0.0\n- LOCALIZATION: Fetch translations from Crowdin\n- LOCALIZATION: Fix Switchres menu texts\n- MENU/OZONE: Ensure sidebar display status is updated correctly when performing rapid menu navigation\n- MENU/XMB: Dynamic wallpaper fix\n- MENU/XMB: Icon opacity fix\n- MENU/QT/WIMP: Fix default core detection when playlist file name does not match 'db_name'\n- PLAYLISTS: Optimise scanning of large rom sets\n- SECURITY: Plug so-called high-risk vulnerability related to Powershell - avoid injection - don't send speech input as commandline argument\n- UWP/XBOX: Add expanded resources Rescap to increase performance of UWP version in app mode on Xbox\n- WINDOWS/INSTALLER: Add smarter isEmptyDir reference implementation that looks for subdirectories from NSIS documentation\n- WINDOWS/INSTALLER: Register new function DirectorySet that is called when pressing the \"Next\" button on the MUI_PAGE_DIRECTORY, aka the install folder selection GUI. DirectorySet contains the criteria for an acceptable folder, which are:\n  - `IfFileExists \"$INSTDIR\\retroarch.exe\"` returns 1\n  - `IfFileExists \"$INSTDIR\\*.*` returns 0, there is no existing folder\n  - `IfFileExists \"$INSTDIR\\*.*\"` returns 1, there is a folder, and `isEmptyDir` returns 1, therefore the folder is empty, including of subdirectories\n- X11: Fix threaded video segfault\n\n# 1.9.5\n- ALSATHREAD: Make alsathread default for all ALSA devices with threads\n- ARCHIVE: Fix loading of archived content with file names containing '#' characters\n- CHEEVOS: Upgrade to rcheevos 10.1\n- CHEEVOS: Challenge indicators\n- CHEEVOS: Group achievements by category in quick menu\n- CHEEVOS: Relabel 'Start Active' with 'Encore Mode'\n- D3D10: Window title should now update\n- D3D11: Window title should now update\n- D3D11: Allow fastforward in fullscreen\n- D3D12: Window title should now update\n- D3D12: Allow fastforward in fullscreen\n- CRT/SWITCHRES: New implementation\n- FONTS: Improve message wrapping with CJK languages\n- FONTS: Fix garbled characters when converting encodings\n- INPUT: Allow the 8 analog stick directions to be used as keys for core keyboard mappings\n- LIBRETRO: Add API extension for setting 'need_fullpath' based on content file extension and to request persistent frontend content data buffers\n- MENU/SEARCH: Add enhanced search functionality to the 'Manage Cores' menu\n- OPENDINGUX: Fix black screens when triggering gfx driver initialisation via menu actions\n- UNIX: Get better battery stats on sysfs nodes\n- VIDEO: Extend Frame Delay range to 19 to accommodate PAL land too\n- WIFI/LAKKA: Add nmcli to wifi drivers\n- WIFI/LAKKA: Add wifi configuration menu\n- X11: fix fullscreen when swapping monitors/resolution\n\n# 1.9.4\n- CHEEVOS: update rcheevos to v10.0.0\n- CONTENT LOADING/FILE IO: Prevent unnecessary extraction (to disk) of compressed content files when need_fullpath is false\n- CORE INFO/FILE IO: Enable core info cache by default now for all platforms\n- CORE INFO/REGRESSION FIX: Fix regression caused by core info file caching - Downloads was no longer showing up in Load Content\n- FILE IO/COMPRESSED: Ability to load content inside ZIP files directly into RAM\n- INPUT/OVERLAYS: Add option to select between 'touched' elements and physical controller inputs when showing inputs on overlays\n- INPUT REMAPPING/OVERLAYS: Prevent duplicate inputs when using remaps with input overlays\n- LAKKA: Add brightness restore hook\n- LOCALIZATION: Fetch translations from Crowdin\n- MENU/OZONE: Added simple playlist entry enumeration\n- MENU/XMB: Fix display of 'Maximum Users' menu entry dropdown list\n- PS3/PSL1GHT: Joypad driver works again\n- PSTV: Fix Vita input driver for PSTV\n- PSTV: Support for 720p on PSTV when using 'Unlock framebuffer' in Sharpscale plugin\n- PSTV: Fix scaling on PSTV when not using 720p\n- RPNG: Fix some memory corruption if processing broken input PNG file\n- SECURITY: Fix CVE-2021-28927\n\n# 1.9.3\n- 3DS: Disable menu screensaver animations in XMB/GLUI\n- COMMAND: Initialize netcmd->cmd_source_len before recvfrom()\n- CONTENT LOADING/STATICALLY LINKED: Ensure 'Always Reload Core on Run Content' setting is applied when loading content via the file browser\n- CONTENT LOADING/EMSCRIPTEN: Fix content loading via file browser on platforms with 'broken' core handling (i.e. emscripten)\n- CORE INFO: Skip whitespace when writing compressed core info cache files\n- CORE INFO/FILE IO: Core Info cache; significant file I/O performance improvements on systems with slow disk file I/O\n- CORE INFO/FILE IO: Enable core info cache by default on all 'console' platforms\n- FREEBSD: FreeBSD build fix\n- LAKKA: Support for tweaking CPU governors/scaling policies\n- LAKKA: This adds managed policies and settings to store them and reload them at startup\n- LIBRETRO API: Add API extension for cores to override frontend fast-forward state\n- MENU/RGUI: Fix saving of config files/overrides when 'Lock Menu Aspect Ratio' is enabled\n- SHADERS: Fix 'Auto-Shader Delay' functionality\n- UWP/D3D11: Disable mipmap generation\n- UWP/XBOX: Add 'Force 4K resolution' option (Force the resolution to the fullscreen size on Xbox, if set to 0, a fixed value of 3840 x 2160 will be used)\n\n# 1.9.2\n- 3DS: Enable graphics widgets / overlays\n- 3DS: Load texture images as BGR colors\n- 3DS: Change default asset directory\n- CHEEVOS: Allow rcheevos_patch_address to be called on game without achievements\n- CHEEVOS: Update achievement memory maps (add Supervision)\n- CONFIG/FILE: Use hash map to optimise key/value lookups\n- CORE INFO: Performance optimisations + code clean-ups/refactors\n- CRT/SWITCHRES: Fixed CRTSwitchRes framebuffer bug\n- DISCORD/RP: Fix regression\n- DRM: set the correct video mode\n- FASTFORWARD: Enforce minimum fastforward_ratio of 1.0\n- FONTS/FREETYPE/STB_UNICODE/BITMAPFONT: Prevent texture bleed when rendering text at non-integer scales\n- INPUT: Ensure that 'retro_set_controller_port_device' is called when updating 'Max Users'\n- INPUT/XEGL/MOUSE: Fix xegl_ctx.c mouse activation\n- INPUT/SDL: Fix crash in SDL input driver when analogs are bound.\n- INPUT/POINTER: Add scaling to pointer input.\n- INPUT REMAPPING: Fix regression on loading file\n- INPUT REMAPPING: Fix regression where disabling input remapping would disable input\n- IOS: Disable system button gestures on iOS 14\n- IOS: Prevent potential crash on controller connect - randomly would get a crash when connecting a game controller while RA was running\n- LAKKA: Add menu for time zone setting\n- LOGGING: RARCH_LOG_V checking for verbosity level is not necessary and can cause issues; removed said check.\n- LOGGING: Silence inappropriate cheatfile logging\n- IOS/MAC: Add CPU VFP unit detection for Darwin\n- MAC: Swallow 'escape' key being pressed - would previously make the game toggle between fullscreen and windowed\n- MAC: Intel and ARM64 timer change proposal.\n- MAC/ARM64: run_fast_mode disabled for 64 bits invalid instructions.\n- MAC/OPENGL: Fix codesigning issue\n- MAC/UNIVERSAL: Add TTS translation service support.\n- MENU: Add optional menu screensaver\n- MENU: Add search filter support to cheats and overlays file browser menus\n- MENU/FILEBROWSER: Enhanced 'Load Content' file browser search functionality\n- MENU/INPUT: Block accidental diagonals in menu navigation\n- MENU/RGUI: Add option to disable menu transparency\n- MENU/RGUI: Fix display of 'Video > Scaling' menu when 'Lock Menu Aspect Ratio' is enabled\n- MENU/MATERIALUI: Add icon to 'Turbo Fire' menu entry\n- MENU/OZONE: Ozone Dracula theme\n- OPENDINGUX/BETA: Fix IPU scaling when running GBA-resolution content\n- OPENDINGUX/BETA: Add 50Hz support\n- OPENDINGUX: Enable 'SaveRAM Autosave Interval' by default\n- PATCHES: Added multi-softpatching support + OSD messages for patches\n- RHMAP: Track the complete string in rhmap\n- VITA: Align VM block size to 1MB - should fix one of the issues with gpSP\n- WINDOWS/GDI: Fix non-ASCII text rendering\n- XEGL: Fix mouse not working when using OpenGLES with X11\n\n# 1.9.1\n- 3DS: Graphics widgets support\n- 3DS: On error, only init gfx on salamander build. This prevents graphical issues if the gfx is already initialized.\nWhich should always be the case if called from a running core\n- 3DS: Update error applet\n- 3DS: Enable online Core Updater\n- 3DS: Guard threading\n- 3DS: Allow sideways screen rotation\n- 3DS: Enable threading and add a threaded audio driver\n- ANDROID: Implementation of fullscreen over notch function (for Android 9.0 and up)\n- ANDROID: Add Play Store module support.\n- ANDROID: Add option to switch all installed cores to Play Store versions\n- AUDIO: Memalign audio buffers to 64 bytes. This is the most common cache line size, helps with performance. Also fixes issues with platforms like PSP that wrongly assume that malloc returns aligned buffers (to 16bytes). This recently broke the PSP builds\n- AUDIO/ALSA: Fix float format detection\n- AUDIO/JACK: Deinterleave in the process callback. This allows us to avoid the extra copy to the deinterleave buffer and lets us use only a single jack ringbuffer.\n- AUDIO/JACK: (Audio/JACK) Fix non-blocking write. Previously we would wait on the condition variable even in the non-blocking case. This improves fast-forward performance massively and brings JACK in line with other backends in that regard.\n- AUDIO/XAUDIO2: Fix threaded audio bugs with cores like Dinothawr\n- CONFIG: Add support for saving per-directory core options and deleting core option overrides\n- CONFIG: Enable saving of changed parameters when '#include' directives are used\n- CONFIG/DIRS: Enable configuration of the directories used for Favorites, History, Images, Music and Video playlists\n- CONFIG/REMAPS: Allow loading core remaps without content\n- CONFIG/OVERRIDES: Fix empty override paths when launching without content\n- CHEATS: Maximum search value corrections\n- CHEEVOS: Generic memory mapping using rcheevos\n- CHEEVOS: Ensure badge textures are released before video driver is deinitialized. Should fix crashes with slang shaders.\n- CHEEVOS: Include achievement runtime state in save states\n- CHEEVOS: Prevent hardcore toggle when emu-handled cheats are active\n- CHEEVOS: Add confirmation submenu to achievements hardcore toggle\n- CHEEVOS: Calculate leaderboard widget spacing based on video resolution\n- CHEEVOS: Show unsupported core message when viewing achievement list for unsupported core\n- CHEEVOS: Allow disabling leaderboard notifications and trackers separately\n- CHEEVOS: Add display widget for active leaderboards\n- CHEEVOS/CORE OPTIONS: Core options blacklist. Disables hardcore mode when certain core options are set.\n- CLI: Add option for quitting on close content\n- CONTEXT/DRIVER SWITCHING: Allow context switching from gl to glcore\n- CORE OPTIONS: Add option to reset all core options for current core/content\n- CORE OPTIONS: Add per-folder core options\n- CRT/SWITCHRES: Improvements\n- CRT/SWITCHRES: Low resolution switch bug fix - This allows resolutions lower that 32x224 like 256x224 to work\n- CORE DOWNLOADER: Enhanced core downloader search functionality\n- D3D10: Should now be able to use shaders with hardware-accelerated libretro cores\n- D3D11: Should now be able to use shaders with hardware-accelerated libretro cores\n- D3D11: Skip shader/stock blend when we don't have a texture. This happens if the core calls video_cb with the frame set to null on\nthe first frame, and was causing black screens/driver resets. The ffmpeg core seems to do this.\n- D3D11: Fix shaders with scaled framebuffers\n- D3D11: Add flip model support - fallback to blit model for OSes where flip model is not supported (windows 7 and earlier). Will add a menu option later allowing the user to switch inbetween the two\n- D3D12: Should now be able to use shaders with hardware-accelerated libretro cores\n- D3D10/11/12: Increase sprite capacity, we need this so that the hardware rendered menu drivers doesn't glitch out\n- DRM: Fix race condition in drm_surface_set_aspect\n- DRM/KMS: add support for custom hdmi_timings / modes\n- DATABASE: Fix crash that could happen when selecting cursor\n- DATABASE/EXPLORE: Fix - Prevent segfault when accessing 'Explore' menu\n- EMSCRIPTEN: Only report back one screen pointer for rwebinput, fixes lockup when clicking on an overlay\n- FILEIO/PERFORMANCE: Only attempt to call dir_check_defaults once per runtime session\n- FILEIO/PERFORMANCE/3DS: Increase file buffer size and savestate chunk size. This seems to help with saving large savestates.\n- FONTS: Improve handling of Arabic and Persian text\n- FONTS/FREETYPE: Use fontconfig to select fonts if available\n- INPUT: Add hold mode for turbo fire 'Single Button'\n- INPUT MAPPING: Refresh bind list on device type change\n- INPUT MAPPING/REMAPPING: Minor bugfix - Remap file browsing starts navigation at input_remapping_directory even if the core-subdir (where saved files go) exists\nHaving remaps for many different cores makes finding the active core files cumbersome, especially because remaps are not compatible between different cores (but maybe for cores emulating the same hardware)\n- IOS: Take out 'Core Downloader' from iOS 9/iOS 11 builds\n- IOS: IOSApp doesn't crash anymore when a file is shared to it\n- INPUT: Keyboard device mapper rework\n- INPUT: New input bind order scan/clear fix\n- INPUT: Duplicate key event blocking additions\n- INPUT: Prevent duplicate key events with hotkeys + keyboard device type\n- INPUT: Keyboard LED driver\n- INPUT/AUTOCONFIG: Allow controllers with no/empty names to work.\n- INPUT/GAME FOCUS: Add option to automatically enable 'game focus' mode when running/resuming content\n- INPUT/HOTKEYS: Hotkey for Close Content / Unload Core\n- INPUT/LIBCEC: Map libcec-daemon keys to RETROK\n- INPUT/X11: Enable keyboard input when mouse cursor is not inside the RetroArch window but window still has focus\n- INPUT/X11: Fix mouse input when mouse is grabbed\n- INPUT/UDEV/RUMBLE: Fix rumble.\n- INPUT/WINDOWS/DINPUT: Simultaneous shift sticky fix\n- INPUT/WINDOWS/DINPUT: Prevent Win-key from opening Start Menu\n- INPUT/WINDOWS/DINPUT: Option for disabling Windows hotkeys\n- INPUT/WINDOWS/DINPUT: Mouse grabbing/clipping with Alt-Tab\n- INPUT/WINDOWS/DINPUT: Mouse grab fixes\n- INPUT/WINDOWS/RAWINPUT: Key position fixes\n- INPUT/WINDOWS/RAWINPUT: Mouse grab fixes\n- INPUT/WINDOWS/RAWINPUT: Prevent outside window mouse clicks when grabbed\n- INPUT/WINDOWS/RAWINPUT: Option for disabling Windows hotkeys\n- INPUT MAPPING/REMAPPING: Major bugfix - Remap file having a different device type requires manual intervention after loading for the core to register the type properly\n- JSON: New faster json parser/writer library rjson\n- JSON/RJSON: Replace rapidjson parser/writer in discord-rpc with rjson\n- LIBRETRO: Add API extension for cores to query the number of active inputs provided by the frontend\n- LIBRETRO: Ensure RARCH_CTL_CORE_OPTIONS_LIST_GET returns false if no core options are available\n- LIBRETRO: Add API extension for overriding frontend audio latency\n- LIBRETRO: Add API extension for cores to monitor frontend audio buffer occupancy\n- LINUX: Also show /run/media or /run/media/$USER in drives list\n- LINUX: Adjust brightness according to the limit. Seems like some platforms feature non-standard maximums, but the variable is correclty exported for us to use\n- LOCALIZATION: Add Finnish language\n- LOGS/SHADER: Shader log spam reduction\n- LOGS/CONFIG: Config logging cleanup\n- LOGS/SAVESTATE: Config logging cleanup\n- MAC: Apple Silicon/Mac M1 support\n- MAC: Code signing/notarization\n- MAC: Fix a leak with NSTemporaryDirectory() on ARC (Automatic Reference Counting) code\n- MAC: Support bundle assets extraction on macOS\n- MAC: Universal Metal build for both ARM and Intel Macs\n- MAC/UNIVERSAL: Add CoreAudio3 audio driver for Metal Universal build\n- MAC/IOS: Only extract assets once on first install\n- MENU: Add 'L2 + R2' menu toggle gamepad combo\n- MENU: Menu text improvements; clarifications, consistency, text mistakes,\n- MENU: Tweak menu scroll initial hold delays\n- MENU: Restrict menu acceleration to navigation buttons\n- MENU: Add 'Menu Driver' setting to 'User Interface'\n- MENU: Relocate 'Menu Scroll' settings.\n- MENU: Separate 'Turbo Fire' menu.\n- MENU: Dropdown menu for 'Custom Aspect Ratio' setting.\n- MENU: Reorder Mouse Index next to Device Index\n- MENU: Submenu for Device Index/Mouse Index\n- MENU: Reorganize User Interface menu\n- MENU: Add 'Remove DSP Plugin' menu entry\n- MENU: Hide 'Auto-Shader Delay' menu setting when shaders are unavailable\n- MENU/ANIMATIONS: Fix non-smooth text ticker + reduce line ticker code duplication\n- MENU/ANIMATIONS/OZONE: Add cursor wiggle animation\n- MENU/ANIMATIONS/OZONE: Implement wiggling for main menu when wrap-around is disabled\n- MENU/NOTIFICATIONS: On-Screen Notifications' menu clean-ups\n- MENU/NOTIFICATIONS: Add option to show/hide Refresh Rate notification\n- MENU/FILEBROWSER: Start auto-selecting last used path for more file browser menu entries\n- MENU/INPUT: Input port label adjustments\n- MENU/INPUT/XMB: Proper control port icons\n- MENU/INPUT/OZONE: Proper control port icons\n- MENU/QUICK MENU: Add remap clearing ability under Quick Menu controls\n- MENU/QUICK MENU: Cap 'State Slot' drop-down list to a maximum of 1000 (+Auto) entries\n- MENU: Customizable menu scroll hold delay.\n- MENU/DESKTOP: Fix mouse cursor limited by window range on F5 press\n- MENU/DESKTOP: Add simple shader option\n- MENU/DESKTOP/WINDOWS: Remove broken 'Update RetroArch' functionality for Windows. We want this to not only be system agnostic if we bring it back, but also work outside of the Qt desktop interface\n- MENU/OZONE: New Theme - Twilight Zone\n- MENU/RGUI: Add 3:2, 5:3 and 3:2/5:3 (centered) aspects\n- MENU/RGUI/TEXT RENDERING: Add Russian language text support\n- MENU/RGUI/TEXT RENDERING: Add support for CJK punctuation glyphs\n- MIDI/WINMM: Recover from MIDI messages not handled by the device\n- MIDI/WINMM: Fix winmm midi driver hanging on content closing\n- NETWORK: Add READ/WRITE_CORE_MEMORY network commands\n- NETWORK: Fix backwards condition in socket blocking behavior\n- NETWORK/NETPLAY: Attempt IPv4 when IPv6 fails\n- OGA/VIDEO: support for OGS\n- OGA: This keeps the tradition DRM driver along with the OGA one. The probe\nfunction skips the driver if the screen is non rotated to fall back to\nthe regular DRM driver.\n- OGA: Fix messages from not disappearing\n- OGA: Implement RETRO_ENVIRONMENT_GET_CURRENT_SOFTWARE_FRAMEBUFFER. This is a faster rendering codepath for software rendered libretro cores that some libretro cores use right now. Video drivers in RetroArch have to explicitly implement this for this codepath to work at runtime.\n- OPENDINGUX: Add/Optimise rumble interface\n- OPENDINGUX: Fix frozen video when enabling fast forward\n- OPENDINGUX/SDL: OSD font clean-up\n- OPENDINGUX/SDL: Enable selection of image interpolation method when using 'sdl_dingux' gfx driver\n- OPENDINGUX/SDL: Enable integer scaling when using the 'sdl_dingux' gfx driver\n- OVERLAYS: Add option to scale overlays automatically (with aspect ratio correction)\n- OVERLAYS: Hide Overlay When Gamepad is Connected. Overlays will be hidden automatically when a gamepad is connected in port 1, and shown again when the gamepad is disconnected.\n- OVERLAYS: New default overlays for mobile (neo-retropad)\n- OVERLAYS: In addition to overlay scale, the user can now set an Overlay Aspect Adjustment factor. Most overlays are designed for 16:9 displays, which means they become stretched/ugly on modern wide aspect phones and suchlike. By changing the Overlay Aspect Adjustment factor, a user can scale the overlay width/height to achieve a uniform appearance regardless of display resolution.\n- OVERLAYS: Since scaling a gamepad overlay can result in buttons being squished too close together (or being pulled too far apart), the user can now adjust the effective spacing of the different 'halves' of an overlay via Overlay Horizontal Separation and Overlay Vertical Separation factors. Overlay Horizontal Separation divides the overlay in two vertically (left/right, at the centre point), and applies a spacing offset (positive or negative) between the UI elements on each side; Overlay Vertical Separation does the same, but the split is horizontal (top/bottom)\n- OVERLAYS/FIX: The Overlay X Offset and Overlay Y Offset options have been fixed, and now work correctly\n- OVERLAYS/FIX: All of the above options (and Overlay Scale) are configured and saved independently for landscape and portrait display orientations - so adjusting everything for a nice landscape layout won't break the portrait display\n- OVERLAYS/FIX: When using the Vulkan gfx driver, memory is leaked every time an overlay is freed\n- OVERLAYS/FIX: When threaded video is enabled, loading overlays with no images (i.e. utility-type overlays, where everything is hidden until the screen is touched) can generate segfaults due to improper usage of realloc()\n- OVERLAYS/FIX: When Show Inputs on Overlay is enabled, ASAN reports bit shift errors due to an incorrect range check when handling turbo inputs - essentially, there is no upper limit to the considered input id range, which means overlay hotkeys (menu toggle, etc.) are incorrectly treated as having turbo support, causing bit shifts using wildly inappropriate id indices\n- PLAYLISTS/PORTABLE: Fixed first load initialization\n- PS2: Added Multitap support (up to 8 players)\n- PS2: Fix for not recognized digital and other non-standard controllers\n- PS2: Fix Quitting from RA\n- PS2: Add Audio mixer\n- REWIND: Prevent 'Rewind Frames' from being set to '1' incorrectly on load content\n- RUNAHEAD: Add Run-Ahead Toggle hotkey with notifications\n- RBUF/ANIMATIONS: Simplify gfx_animation by switching from dynarray to rbuf\n- RBUF/CORE UPDATER: Replace static entries array with dynamic array via RBUF library\n- RBUF/M3U: Replace static entries array with dynamic array via RBUF library\n- SENSORS:  Android (crash-)fixes/improvements + add option to disable sensor input\n- SDL2/VIDEO: Get the SDL2 video driver to work in Wayland/KMS\n- SAVESTATES: Adding savestate garbage collector for autoincrement stavestates. As some issues indicate, there's an issue with\nthe autoincrement save slot feature: slot index will increase and very old saves won't be deleted. This adds support to delete old save states with a user defined\nsave state limit (global). Instead of wrapping around the slot counter it will simply delete the oldest save, since it is simpler. For now there's a limit of one deletion per save, which ensures a user cannot delete many saves by accident if they set the limit too low.\n- SAVESTATES/SAVEFILES: Ensure save file and playlist compression is disabled by default\n- SHADERS: Add option to remember last selected shader preset/shader pass directories\n- SHADERS: Use last selected shader preset directory when changing shaders via previous/next hotkeys\n- SHADERS: Remove Parameters line\n- SHADERS: Shaders fix for duplicate parameters loading bug\n- SHADERS: Fix Crash change num shader passes in UI\n- SHADERS/SLANG: Fix slang shaders with rotation\n- STREAMING/FFMPEG: Add Facebook Game Stream option (for embedded ffmpeg core-enabled RetroArch builds)\n- SWITCH: Fix input bind icons being off by one line\n- SWITCH: Fix audio issues\n- TLS/SSL: Add BearSSL support, as alternative to mbedTLS\n- VIDEO: AddVariable BFI (Black Frame Insertion)\n- VIDEO/DRM GO2: Dynamic resolution support\n- VIDEO FILTERS: Video filter optimisations\n- VIDEO FILTERS: Add several LCD-effect video filters\n- VIDEO FILTERS: Gameboy/Dot_Matrix video filters: Add XRGB8888 support\n- VIDEO FILTERS: Add Normal4x video filter\n- VIDEO FILTERS: Add 'Upscale_256x-320x240' video filter\n- VIDEO FILTERS: Add 'Upscale1.5x' video filter\n- VITA: Disable temporarily VitaGL\n- VITA: Fix bubble name\n- VITA: proper handling of boot params\n- VITA: Default menu scale 1.5x to improve readability\n- WIFI/LAKKA: Add a proper WiFi menu, with Enable/Disable & Disconnect options. This also allows WiFi passwords to be remembered. The underlying tool (connman) allows to store passswords (that's why it auto connects whenever you boot a Lakka device), so we expose this so that the user does not have to re-input the pass when connecting to a saved wifi.\n- WII/HID: Added HID support for HORI mini wired ps4 gamepad\n- WINDOWS: Add support for accelerators to main win32 message loop\n- WINDOWS: Add accelerators for Open (Ctrl+O) and Fullscreen (Alt+Enter)\n- WINDOWS: Fixes some file I/O failures on Windows when paths are longer than 260 characters.\n- WINDOWS: Fix crashing on startup on Windows when using Chinese Simplified language.\n- WINDOWS/XP: The OpenGL 1 video driver is now the default for maximum backwards compatibility upon first startup. It's of course always possible for the user to change this.\n- WINDOWS/MENUBAR: Load accelerators, Localize Win32 menu items to current language, and display shortcut keys\n- WINDOWS/MENUBAR: Add 'Reinit' to Menubar\n- WINDOWS/MSVC: Fix rewind crash on MSVC build when using SSE2\n- UWP: Don't default to XMB menu by default, default to Ozone instead\n- UWP/VFS: Use Win32 file APIs when possible - better file I/O performance\n- WIIU/FILEIO/PERFORMANCE: Faster startup times - remove the path_is_valid() call when loading textures\n- WIIU: Fix touchscreen mouse emulation\n\n# 1.9.0\n- 3DS: Fix sound crackling when paused\n- ANDROID/VIBRATION: Fixes \"Vibrate on Key Press\" having no effect on Android devices, which occurred because only the off time/strength was defined in what should have been a pair of off/on values\n- AUTOCONFIG: Ensure correct directory is used when saving autoconfig profiles\n- BLUETOOTH: Add a Bluetooth driver (Lakka-only for now)\n- CHEATS: Fix for wrong number of remaining cheat search matches on some machines\n- CHEEVOS: Option to play sound on achievement unlock.\n- CHEEVOS: Upgrade to rcheevos 9.1\n- CHEEVOS: Restore display of unlocked achievements across hardcore modes\n- CHEEVOS: Hash buffered data when available\n- CHEEVOS: Fix 'Auto Save State freezes RetroArch while Cheevos is enabled'\n- CORE OPTIONS: Pressing OK (or clicking/tapping) on a 'boolean toggle' core option no longer opens a drop-down list. The value now toggles directly, just like boolean options everywhere else in the menu\n- CORE OPTIONS: Toggling an option that changes the number of core options being displayed (i.e. things like `Show Advanced Audio/Video Settings) no longer resets the navigation pointer to the start of the list\n- CORE OPTIONS: Before, RetroArch would identify core option values as being 'boolean' if they had labels matching the specific strings enabled or disabled. Most core devs would abide by this, but not always... As a result, we sometimes would end up with misidentified values, with all kinds of Enabled, Off, True, etc. strings littering the menu, in place of proper toggle switches. All boolean-type value labels are now detected, and replaced with standard ON/OFF strings.\n- CLI: A new command line option --load-menu-on-error has been added\n- CRT: On the fly CRT porch adjuments - these changes allow a user to adjust how the porch algorithm generates the 15khz/31khz output. Giving the ability to change over/under scan.\n- CONFIG FILE: Optimise parsing of configuration files\n- D3D9/D3D11: Fix core-initiated D3D9/D3D11 driver switches\n- DRIVERS: Implemented protection to avoid setting critical drivers to nothing thus preventing the user from locking him/herself out of the program\n- EMSCRIPTEN: Fix input code to ignore unknown keys\n- FFMPEG CORE: Prevent seeking past the end of files (hang fix)\n- FILE I/O: VFS and NBIO interfaces will now use 64-bit fseek/ftell where possible, should allow for reading/writing to files bigger than 2GB\n- INPUT MAPPING/REMAPPING: Add input remap drop-down lists\n- IOS: Fixed iOS 6 version\n- IOS: Hide the home indicator as it obscures the content too frequently\n- IOS/METAL: Metal video driver now works on RetroArch iOS\n- IOS/METAL: Support getting video metrics to support proper touchscreen interactions\n- LOCALIZATION: Updates for several languages (synchronized from Crowdin)\n- MEMORY/LINUX/ANDROID: Fix reporting of free memory\n- MEMORY/WINDOWS: Fix reporting of free memory\n- MENU: Enlarged INT/UINT selection limit from 999 to 9999\n- MENU: Fix cursor forced to first entry after displaying lists\n- MENU: Make Notification Font option visible when Graphics Widgets are enabled\n- MENU/RGUI: Add optional 'toggle switch' icons\n- MENU/WIDGETS: Add optional widget-based 'load content' launch feedback animation\n- MENU/WIDGETS: Make notification font size option visible when graphics widgets are enabled\n- ODROID GO ADVANCE: Video driver - fix race condition with RGUI callback\n- PLAYLISTS: Change playlists to use dynamic arrays. Instead of a fixed initial 12MB memory allocation (99999 * 128 byte (on 64bit arch)), use a dynamically growing array\n- PLAYLISTS: Playlist base content directory paths - portable playlists\n- PLAYLISTS/SEARCH: Enhanced playlist search functionality\n- PLAYLISTS/DATABASE: Add 'Explore' view\n- PLAYLISTS/DATABASE/EXPLORE: Show system icons in explore view\n- PS2: Improve FPS Limiter\n- RUNAHEAD: Prevent runahead from being disabled *permanently* when an error occurs\n- SCANNER: Add more region codes for GameCube/Wii game detection\n- SHADERS/SLANG: Increased Slang max Parameters, Textures & Passes\n- VIDEO FILTERS/BLARGG: Make Blargg_snes filter customizable\n- WINDOWS/RAWINPUT: Fix invalid calls to dinput_handle_message when input driver is not set to dinput\n- X11: Add lightgun support\n\n# 1.8.9\n- AUTO SAVESTATES: Ensure save states are correctly flushed to disk when quitting RetroArch (fixes broken save states when exiting RetroArch - without first closing content - with 'Auto Save State' enabled)\n- BUILTIN CORES: Builtin cores like ffmpeg and imageviewer would previously try  to erroneously load a dynamic core named 'builtin' - this would fail and would just be a wasteful operation - this now skips dylib loading in libretro_get_system_info for builtin cores\n- CHEEVOS: Report API errors when unlocking achievements or submitting leaderboards\n- CHEEVOS: Support less common file extensions\n- CHEEVOS: Disable hardcore mode when playing BSV file\n- CHEEVOS: Correctly report unlocked non-hardcore achievements when hardcore is paused\n- CHEEVOS/M3U: Bugfix - did not handle absolute/relative paths in M3U files correctly before\n- CHEEVOS/M3U: Bugfix - it didn't handle comments/directives\n- CHEEVOS/M3U: Bugfix - it doesn't handle trailing whitespace\n- CHEEVOS/M3U: Bugfix - failed when loading M3U files with certain line endings\n- CORE MANAGEMENT: Add 'core management' menu (Settings -> Core)\n- CORE MANAGEMENT: Add option to backup/restore installed cores\n- CORE MANAGEMENT: Improved core selection logic\n- CORE INFO: Search search optimisations\n- CORE DOWNLOADER: Rename 'Core Updater' to 'Core Downloader'\n- CORE DOWNLOADER: Add 'Show Experimental Cores' setting under Settings > Network > Updater\n- CORE DOWNLOADER: Core licenses are now shown for all entries in the Core Updater menu\n- CORE DOWNLOADER: Pressing RetroPad select on a Core Updater entry will now display any text in the description field of its info file\n- CORE DOWNLOADER: Installed cores are now highlighted via a [#] symbol\n- CORE DOWNLOADER: Pressing RetroPad start on a selected, installed entry opens the Core Information menu (when using Material UI, swiping left or right triggers the same action). This means we can now view bios info etc. - and more importantly delete cores - without jumping through all the hoops of loading a core first and navigating all over the place\n- CORE DOWNLOADER/UPDATER: Add option to automatically backup cores when updating\n- DISK CONTROL: Enable 'Load New Disc' while disk tray is open\n- INPUT: Added a hotkey delay option to allow hotkey input to work properly when it is assigned to another action\n- INPUT: Remove 'All Users Control Menu' setting, was buggy and will be properly reintroduced after input overhaul\n- LINUX: Set default saves/save states/system paths\n- LOCALIZATION: Add Persian language\n- LOCALIZATION: Add Hebrew language\n- LOCALIZATION: Add Asturian language\n- MENU: Proper line wrapping for message dialog boxes\n- MENU/HOTKEYS: Add sublabels to all hotkey bind entries\n- MENU/QUICK MENU: Suppress the display of 'empty' quick menu listings when closing content\n- MENU/OZONE: Performance improvements\n- MENU/SDL: Add mouse controls\n- OPENGL1/VITA: Initial changes for HW context without FBO\n- OVERLAYS: Add options for moving the on-screen overlay\n- PLAYLISTS/WINDOWS: Fix core path entries in image/video/music history playlists\n- PS2: Add back CDFS support\n- SDL/GL: Advertise GLSL support\n- VIDEO/WIDGETS: Fix heap-use-after-free errors, leading to memory corruption\n- VITA: Added custom bubbles support\n- VITA: VitaGL update\n- VULKAN/WSI: Better frame pacing\n- VULKAN/WSI: Fix Intel Mesa being broken when using Fences, we have to use Semaphores to acquire the swapchain or the entire GPU stalls\n- VULKAN/WSI: Add support for either using fences or semaphores when syncing\n- VULKAN/WSI: Prefer using semaphores for integrated GPUs as it promotes better throughput over fences\n- VULKAN/WSI/ANDROID: Do not use mailbox emulation on Android\n- UWP/XBOX: Potentially improve performance by enabling 'Game Mode'\n\n# 1.8.8\n- AUDIO/JACK: Fix regression introduced after 1.8.4 - would hang at startup\n- CHEEVOS: Disable hardcore when cheats are enabled\n- CHD: Return false when special track cannot be found\n- DISCORD/MATCHMAKING: Fix Discord 'Ask To Join' functionality\n- FILE PATH: Various file path handling optimisations\n- FONT: Fix Arabic, Chinese and Korean font rendering\n- INPUT MAPPING/REMAPPING: Restore broken 'reset to default' functionality with RetroPad 'start' button\n- INPUT MAPPING/REMAPPING: Fix 'reset to default' action for analog sticks and undefined core inputs\n- LOCALIZATION: Update Arabic translation\n- LOCALIZATION: Update Chinese (Simplified) translation\n- LOCALIZATION: Update Chinese (Traditional) translation\n- LOCALIZATION: Update German translation\n- LOCALIZATION: Update Greek translation\n- LOCALIZATION: Update Spanish translation\n- LOCALIZATION: Update French translation\n- LOCALIZATION: Update Italian translation\n- LOCALIZATION: Update Japanese translation\n- LOCALIZATION: Update Korean translation\n- LOCALIZATION: Update Dutch translation\n- LOCALIZATION: Update Polish translation\n- LOCALIZATION: Update Portuguese Brazilian translation\n- LOCALIZATION: Update Russian translation\n- LOCALIZATION: Update Turkish translation\n- LOCALIZATION: Update Vietnamese translation\n- LOCALIZATION: Add Slovak translation\n- MENU: Small buffer optimizations\n- MENU/THUMBNAILS/BUGFIX: Fix heap-use-after-free error\n- MENU/OZONE: Add option to sort playlists after name truncation\n- MENU/OZONE/ANDROIDTV: Default to Ozone menu driver\n- MENU/OZONE/ANDROID: Gamepad-like devices default to Ozone now (Shield Portable)\n- NETPLAY: Lower announcement rate\n- OVERLAYS: Fix memory leak when loading overlays\n- SHADER PRESETS: Improved shader preset dirs\n- TIME/DATE: Enable configuration of date seperator in clock and runtime 'last played' displays\n- VITA: Fix upside-down vertical games\n- UWP: Enable playlist and savefile compression by default (because of slow file I/O)\n- WIIU: Gamepad hotplugging support\n- WIIU: Theoretical multi-gamepad support\n- VIDEO/WIDGETS: Fix overlapping text when simultaneous pop-up notifications and core/shader messages are being displayed\n- X11: Fix crash in x11_display_server_get_screen_orientation\n- X11/XSHM: Allow X11/XHSM video driver to operate without SHM extension\n- X11/XSHM: Fix compatibility with X11 input driver\n- XVIDEO: Fix keyboard input initialization\n- XVIDEO/XWAYLAND: Fix XVideo support on xwayland (by supporting I420 and YZ12)\n\n# 1.8.7\n- 3DS: Add IDs for Frodo\n- 3DS: Enable basic networking / cheevos\n- CHEEVOS/BUGFIX: Opening achievements list would crash RetroArch with badges enabled (on new games)\n- CHEEVOS: Option to start a session with all achievements active\n- CHEEVOS: Don't perform unnecessary cheevos initialisation when cheevos are disabled. Should reduce startup times when loading content.\n- CORE OPTIONS: Disable 'Use Global Core Options File' by default\n- DOS/DJGPP: Add 32bit color support for cores\n- GLCORE: Switch to glcore video driver when requested by a core\n- LINUX/XDG: Use GenericName correctly in desktop entry\n- MAC/COCOA: Fix mouse cursor tracking\n- MENU/MATERIALUI: Add desktop-style playlist view mode\n- MENU/MATERIALUI/DESKTOPVIEW: When scrolling playlists, show last selected thumbnails while waiting for next entry to load\n- MENU/MATERIALUI: Limit tab switch rate when input repeat is active\n- MENU/OZONE: Fix sidebar playlist sort order when 'Truncate Playlist Names' is enabled\n- MENU/RGUI: Adjusted menu defaults, adjusted default scrolling speed\n- MENU/RGUI: Enable custom wallpaper when menu size is reduced at low resolutions\n- MENU/XMB: Limit tab switch rate when input repeat is active\n- NETPLAY: Fix regressions introduced in 1.8.5\n- RGUI: Add option to always stretch menu to fill the screen\n- WIIU: Enable graphics widgets\n\n# 1.8.6\n- 3DS: Add IDs for UZEM, TGB Dual, and NeoCD\n- 3DS: Fix font driver horizontal text alignment\n- 3DS: Allow button presses up to INPUT_MAX_USERS - this enables the 3DS to bind and use buttons and axis for users up to the maximum set by 'Max Users' in the input settings menu.\n- 3DS: Disable video filter if upscaled resolution exceeds hardware limits. The 3DS has a maximum video buffer size of 2048x2048. This is sufficient for every core that it supports, but when using software video filters the core output resolution is doubled. This is made worse by the fact that the video filter upscaling buffer size is dependent upon the maximum output resolution of the core - which in some cases is very large indeed (e.g. pcsx-rearmed sets a maximum width of 1024, for enhanced resolution support). The 3DS has very limited 'linear memory' for graphics buffer purposes, and a large base core buffer + video filter buffer can easily exceed this - which may also disable video output, or cause a crash. This PR very simply adds a 3DS-specific check to the video filter initialisation: if the resultant upscaling buffer exceeds the hardware limitation, then the filter is automatically disabled.\n- 3DS/FONT/BUGFIX: Text colour was wrong: the RGBA channels were muddled, and R was always set to 255\n- 3DS/FONT/BUGFIX: When drawing multiline strings, the line spacing was completely incorrect\n- 3DS/FONT: Improves the appearance of the drop shadow effect on notification text.\n- 3DS/ARCHIVE/7Z: Re-enable 7zip support.\n- ARCHIVE/ZIP: Expand functionality of 'rzip_stream' interface. This PR expands the functionality of the new rzip_stream archived stream interface such that it now has almost complete feature parity with the standard file_stream interface, and can therefore be used as a drop-in replacement in most situations\n- AI SERVICE: Hide redundant entries when service is disabled\n- AI SERVICE: Added in auto-translate support\n- AI SERVICE: support for NVDA and SAPI narration\n- AUTOCONFIG: Use correct port index in input device configured/disconnected notifications\n- BUGFIX: Fix race condition where task could momentarily not be in the queue when reordering\n- CHEEVOS/BUGFIX: Prevent null reference rendering achievement list while closing application\n- CHEEVOS/BUGFIX: Report non-memorymap GBA cores as unsupported\n- COMMANDLINE: Advise against using -s and -S variables on the command line. \n- CONFIG FILE: Only write config files to disk when parameters change\n- CONFIG FILE/BUGFIX: RetroArch no longer crashes when attempting to save a config file after 'unsetting' a parameter (currently, this can be triggered quite easily by manipulating input remaps)\n- CONFIG FILE/BUGFIX: When using Material UI, RetroArch no longer modifies the wrong setting (or segfaults...) when tapping entries in the Quick Menu > Controls input remapping submenu\n- CONFIG FILE/BUGFIX: Quite a few real and potential memory leaks have been fixed.\n- CHD: Fixes a crash caused by ignoring the return value from one of the CHD library functions\n- FASTFORWARDING: A new Mute When Fast-Forwarding option has been added under Settings > Audio. When enabled, users can fast forward without having to listen to distorted audio.\n- GLCORE/SLANG: Set filter and wrap mode correctly when intialising shader textures. Before, the glcore shader driver did not correctly initialise loaded textures. The texture filtering and wrap mode were forced on texture creation, but these settings were not recorded - subsequent updates would set garbage values, that would resolve to linear filtering OFF and wrap mode = CLAMP_TO_EDGE.\n- LOCALIZATION: Update Japanese translation\n- LOCALIZATION: Update Spanish translation\n- LOCALIZATION: Update Portuguese Brazilian translation\n- IOS: Set audio session category to ambient so sound does not get cut off on interruption (phone call/playing back audio)\n- MAC/IOHIDMANAGER/BUGFIX: Fix for Mayflash N64 adapter. In case last hatswitch does not match cookie. For the mayflash N64 adapter, I was getting a BAD EXC ADDRESS (in mac OS 10.13) for this line (tmp was NULL). Retroarch would crash in the gui if I pressed a button from the DPAD on controller 2. With this change, it no longer crashes in the gui and still registers the button push.\n- MAC/COCOA: Fix mouse input - this brings back two lines of code that have been removed over time but\nappear to be required in order for mouse input to work on macOS\n- METAL/BUGFIX: GPU capture on Metal/OSX/NVidia could crash\n- METAL/BUGFIX: Taking screenshots could capture black frames. Resulting PNG screenshots were black.\n- METAL/BUGFIX: Corrupted image due to incorrect viewport copy when taking screenshot\n- MENU: Prevent font-related segfaults when using extremely small scales/window sizes\n- MENU: Fix 'gfx_display_draw_texture_slice()'\n- MENU/FONT: Enable correct vertical alignment of text (+ font rendering fixes)\n- MENU/RGUI: Enable automatic menu size reduction when running at low resolutions (down to 256x192)\n- MENU/OZONE: Update timedate style options for Last Played sublabel metadata\n- MENU/OZONE: Hide 'Menu Color Theme' setting when 'Use preferred system color theme' is enabled\n- MENU/OZONE: Fix thumbnail switching via 'scan' button functionality\n- MENU/OZONE: Prevent glitches when rendering Ozone's selection cursor\n- MENU/OZONE: Enable proper vertical text alignment + thumbnail display improvements\n- MENU/OZONE: Enable second thumbnail/content metadata toggle using RetroPad 'select'\n- MENU/OZONE: Refactor footer display\n- MENU/OZONE: Hide thumbnail button hints when viewing file browser lists\n- MENU/OZONE/INPUT/BUGFIX: Fix undefined behaviour when using touch screen to change input remaps\n- MENU/OZONE/INPUT/BUGFIX: It turns out that Windows reports negative pointer coordinates when the mouse cursor goes beyond the left hand edge of the RetroArch window (this doesn't happen on Linux, so I never encountered this issue before!). As a result, if Ozone is currently not showing the sidebar (menu depth > 1), moving the cursor off the left edge of the window generates a false positive 'cursor in sidebar' event - which breaks menu navigation, as described in #10419. With this PR, we now handle 'cursor in sidebar' status correctly in all cases\n- MENU/OZONE/INPUT/BUGFIX: Pointer input is now correctly disabled when message boxes are displayed\n- MENU/XMB: Fix thumbnail switching via 'scan' button functionality\n- ODROID GO ADVANCE: Add DRM HW context driver\n- PSL1GHT: Initial port\n- PSL1GHT/KEYBOARD: Implement PSL1GHT keyboard\n- PLAYLIST/BUGFIX: Improve handling of 'broken' playlists - RetroArch will no longer segfault when attempting to run content via a playlist entry with missing path or core path fields.\n- PLAYLIST/BUGFIX: Improve handling of 'broken' playlists - when a playlist entry has either core path and/or core name set to NULL, DETECT or an empty string, attempting to load content will fallback to the normal 'core selection' code (currently this happens only if both core path and core name are DETECT - this is wholly inadequate!)\n- PLAYLIST/BUGFIX: RetroArch will no longer segfault when attempting to fetch content runtime information when core path is NULL\n- PLAYLIST/BUGFIX: Core name + runtime info will only be displayed on playlists and in the Information submenu if both the core path and core name fields are 'valid' (i.e. not NULL or DETECT)\n- PLAYLIST/BUGFIX: When handling entries with missing path fields, the menu sorting order now matches that of the playlist sorting order (at present, everything goes out of sync when paths are empty). Moreover, entries with missing path fields can now be 'selected', so users can remove them (currently, hitting A on such an entry immediately tries - and fails - to load the content, so the only way to remove the broken entry is via the Playlist Management > Clean Playlist feature)\n- PLAYLIST: Add optional per-playlist alphabetical sorting\n- PLAYLIST: Omit whitespace when writing compressed JSON format playlists\n- PLAYLIST: Add optional playlist compression\n- QNX: Support analog sticks\n- SAVESTATES: Add optional save state compression (enabled by default now)\n- SRAM: Add optional save (SRAM) file compression\n- SCANNER: Prevent redundant playlist entries when handling M3U content\n- SCANNER/ANDROID: Fix content scanner being unable to identify certain games from CHD images (raw data sector/subcode)\n- TASKS/BUGFIX: Fix task deadlocks\n- TASKS/SCREENSHOT/BUGFIX: Fix heap-use-after-free error when widgets are disabled\n- TVOS: Disable overlays for tvOS, fix app icon\n- VIDEO/WIDGETS/BUGFIX: The font ascender/descender metrics added in #10375 are now used to achieve 'pixel perfect' vertical text alignment\n- VIDEO/WIDGETS/BUGFIX: Message queue text now uses its own dedicated font. Previously, a single (larger) font was used for all active widgets, and this was scaled down for message queue items. This 'squished' the text a little; more importantly, when using the stb font renderers (on Android. etc.) it caused ugly artefacts around the edges of glyphs due to pixel interpolation errors. Now that a correctly sized font is used, the message queue is always rendered cleanly.\n- VIDEO/WIDGETS/BUGFIX: Previously, each widget font was 'flushed' (font_driver_flush()) at least once a frame. This is quite a slow operation. Now we only flush fonts if they have actually been used.\n- VULKAN/BUGFIX: Fix display of statistics text\n- UNIX/BUGFIX: Fix overflow when computing total memory on i386\n- WIIU/BUGFIX: Fix font driver horizontal text alignment\n- WIIU/BUGFIX: Fix non-vertex coordinates in draws using tex shader\n- WIIU/BUGFIX: Update and fix meta.xml file for the WiiU release. This change makes it so the information from the meta.xml file parsed for the WiiU's Homebrew Launcher is displayed properly.\n\n# 1.8.5\n- 3DS: Keep the bottom screen hidden on sleep/wakeup. When the 3DS wakes back up after being closed, the bottom screen needs to be reinitialized. Adding the condition here will cause the screen to be turned on or off based on the state of ctr_bottom_screen_enabled, as you'd expect\n- ANDROID/CHROMEBOOK/CRASH: Fix Chromebook crashes (on x86 x64) when touching the screen\n- BUGFIX: Prevent double input when using 'return' key (hardware) to close on-screen keyboard\n- BUGFIX: Fix mouse capture hotkey not working\n- BUGFIX: Avoid overflow when calculating multiplying performance counter\n- BUGFIX: Retroarch overlay displaying \"Game remap file loaded.\" on the overlay instead of \"Core remap file loaded.\" when only a core remap file is present\n- CHEEVOS/BUGFIX: Achievement triggers could cause Retroarch to Crash\n- CHEEVOS: Don't block Sameboy core because it only exposes some memory\n- CHEEVOS: Support for extended Sega CD memory\n- CHEEVOS: Show RetroAchievements Hash in content information list\n- CHEEVOS: If the core says it's exposing SYSTEM_RAM, give it the benefit of the doubt\n- CHEEVOS: RetroAchievements rich presence for RA.org website/Discord\n- CHEEVOS: Reset token when username or password changes\n- CHEEVOS: Display measured progress on locked achievements\n- CHEEVOS: Queue multiple popups\n- CHEEVOS: Add delay retries to leaderboard submits\n- CHEEVOS: Prevent buffer overflow when encountering an unknown macro\n- CORE UPDATER: Prevent hang when fetching core list if HTTP transfer fails\n- DISK CONTROL: Add disk labels to 'disk inserted' notifications\n- EMSCRIPTEN: Recreate input event listeners properly\n- FFMPEG CORE: Fix crash on seeking when using HW decoding in some cases\n- LIBRETRO: Add disk control interface API extension\n- LINUX: Avoid possible crash when running retroarch at startup\n- LINUX/GLX: Fix threaded video crashes/instability because of GLX OML sync callbacks\n- LOCALIZATION: Update French translation\n- LOCALIZATION: Update Korean translation\n- LOCALIZATION: Update Polish translation\n- LOCALIZATION: Update Spanish translation\n- LOCALIZATION: Update Portuguese Brazilian translation\n- MENU: Add Menu Scroll Acceleration option\n- MENU: Automatically select currently checked item when opening drop-down lists\n- MENU: Fix smooth (vertical) line ticker scroll speed\n- MENU: Don't flush on override/remap messages\n- MENU/DATETIME: Adds some new timedate styles that follow the DD/MM/YYYY format, found in several European countries\n- MENU/DATETIME: Modifies the existing translation files in order to accommodate the new options that are now available\n- MENU/DATETIME: Reorders the timedate view options based on a decreasing order of the quantity of information displayed, so that they are more convenient to switch around and easily categorized\n- MENU/BUGFIX: Fix bug - if you were in XMB and you would set menu driver to RGUI, you could no longer go to the left or right tab\n- MENU/MATERIALUI: Add option to remove navigation bar\n- MENU/OZONE: Add DPI-based scaling\n- MENU/OZONE: Add rudimentary pointer support\n- MENU/OZONE: Add 'Nord' and 'Gruvbox Dark' themes\n- MENU/OZONE/POINTER: Pointer can be used to switch between sidebar and entries list\n- MENU/OZONE/POINTER: Pointer can be used to select sidebar and entries list items\n- MENU/OZONE/POINTER: Both sidebar and entries list can be scrolled by dragging\n- MENU/OZONE/POINTER: Clicking/pressing the header or footer produces a 'cancel' action\n- MENU/OZONE/POINTER: Cursor focus follows mouse pointer from sidebar to entries list (and vice versa)\n- MENU/OZONE/POINTER: In entries list, item under cursor is automatically selected (with some fudging to ensure this doesn't break mouse wheel scrolling)\n- MENU/OZONE/POINTER: In sidebar, item under cursor is not automatically selected (this is too jarring)\n- MENU/RGUI: Add 'Flux' theme\n- MENU/XMB: New color themes 'Cube Purple', 'Family Red', etc\n- NETPLAY/MENU/BUGFIX: Fix Netplay Stateless Mode doesn't save. Affects other netplay settings which can be overridden by commandline option\n- ODROID GO ADVANCE: Rotation support\n- NETPLAY/ROOMS/BUGFIX: Prevent out-of-bounds array indexing when displaying/selecting netplay rooms in menus\n- SCANNER: Add 'Arcade DAT Filter' Option\n- SCANNER: Add scanning Korea and Asia PS1 discs\n- SCANNER: Add support for scanning PSP Korean\n- VIDEO: Set hardware 'Bilinear filtering' off by default\n- VIDEO/WIDGETS: Widgets are now menu-independent\n- VIDEO/WIDGETS: Allow notifications to use full screen width when not displaying menu\n- VIDEO/WIDGETS: DPI-based scaling\n- VIDEO/WIDGETS: Fix volume widget scaling\n- VIDEO/WIDGETS: Add independent widget scale override settings for fullscreen/windowed modes\n- VIDEO/WIDGETS/BUGFIX: Prevent improper display of (old style) OSD text when widgets are enabled\n- VIDEO/WIDGETS/THREADED/BUGFIX: Fix issue - corruption of menu widgets when running some cores (e.g. VICE) with threaded video enabled\n- WIFI/CONNMANCTL: Display more characters from SSID\n\n# 1.8.4\n- ANDROID/BUGFIX: Prevent crash when Android device is minimized and you go back to the app\n- CAMERA/BUGFIX: Fix crash when a core requires the camera driver and the platform only has a null driver. This would crash mgba on Wii for example\n- DISK CONTROL: Cycle Disk Tray now becomes Eject Disk or Insert Disk depending upon current drive state\n- DISK CONTROL: Current Disk Index is only shown when the current disk has been ejected\n- DISK CONTROL: The old Insert Disk entry has been changed to Load New Disk, and is only shown when a disk is currently inserted (this is because loading a new disk from the filesystem - i.e. bypassing the m3u playlist disk index interface - automatically ejects and inserts disks, and so cannot be done while the virtual drive is empty)\n- DISK CONTROL: The Current Disk Index may now be set more easily via a drop-down list.\n- DISK CONTROL: Selecting Eject Disk automatically moves the menu selection to the Current Disk Index entry\n- DISK CONTROL: Selecting an index via the Current Disk Index drop-down list automatically moves the menu selection back to Insert Disk\n- DISK CONTROL: The Disk Control entry sublabels have been changed for greater clarity\n- DISK CONTROL: All of the horrendous notification spam has been removed. Notifications are now only shown in the event of an error, or when the menu itself does not provide sufficient visual feedback (note that using hotkeys to swap disks still produces the old style notifications, since this is typically only done while content is running - i.e. no menu). The duration of disk-related info notifications has also been reduced to a more sane level.\n- DISK CONTROL: A new Resume content after changing disks option has been added under Settings > User Interface. When enabled (default setting), content is resumed automatically after selecting either Insert Disk or Load New Disk (when disabled, the menu remains open, obviously...)\n- DISK CONTROL/BUGFIX: The Disk Control menu now has the correct title\n- DISK CONTROL/BUGFIX: Selecting a disk via the Load New Disk file browser no longer flushes the user back to the top level menu (it now correctly returns to the Disk Control menu)\n- LIBNX/SWITCH: Updated libnx integration to v3.0.0. This also cherry-picks libnx commit 583d6bb92dcbb33b6bb4a0fa1a9df6e3725d6ef6, which should fix the requirement having to turn rumble off and on in the system settings once per reboot\n- PLAYLISTS: Add 'Clean Playlist' option\n\n# 1.8.3\n- ANDROID/BUGFIX: Fix 'Install or Restore Core' regression\n- BUGFIX: Ensure core info is always initialised when calling 'drivers_init()'. This bug could prevent cores from doing content runtime logging\n- BUGFIX/MENU: History size can only be set to 1 at a minimum\n- BUGFIX/MENU: (XMB/OZONE) Fix 'quick menu' detection. XMB would not display savestate thumbnails in the quick menu if it was accessed via the main menu\n- BUGFIX/CRASH/CORE UPDATER: Fix potential double free error\n- BUGFIX/CRASH/OPENGL/WINDOWS: Fix regression in 1.8.2 that would cause GL-based cores to fail because it would try to erroneously load libGLESv2.dll instead of OpenGL32.dll (cores affected: VitaQuake 2/3/Dhewm3, possibly more)\n- BUGFIX/MENU/DESKTOP UI: Show desktop menu on startup does not launch Qt UI on Linux\n- BUGFIX: Entries in the Playlist Thumbnails Updater list were displaying improper sublabels. I have no idea when this broke... The issue is now fixed\n- CHEEVOS: Don't disable achievement when AddAddress generates an out-of-range address\n- CHEEVOS: Don't reset triggers/leaderboards that failed to load\n- CHEEVOS: Don't count unsupported achievements as unlocked\n- CORE UPDATER: Display number of cores updated when updating installed cores\n- DINGUX: Initial port\n- D3D11: Block FL9_3 devices from D3D11 driver because they don't work anyway (current D3D11 driver uses SM4.0 which requires FL10_0 and up)\n- D3D11: Fallback to GL driver when D3D11 fails\n- EMSCRIPTEN: Fix assets\n- HISTORY/FAVORITES: Bump up default to 200 entries from 100\n- FFMPEG CORE: Implement packet buffer, fixes MP4 video playback for many files\n- LOCALIZATION: Update Italian translation\n- LOCALIZATION: Update Polish translation\n- LOCALIZATION: Update Russian translation\n- LOCALIZATION: Update Spanish translation\n- MENU: Added 'Hosting' menu under Netplay menu\n- MENU: Added 'Subsystems' menu\n- MENU/FILEBROWSER: Fix file selection issues when starting from (or navigating to) the top level directory\n- MENU/WIDGETS: Prevent looping of task title text\n- RASPBERRY PI: Fix BGRA8888 color inversion issues in the menu and elsewhere with VideoCore GL drivers\n- NETPLAY/RELAY: Add Sao Paulo (Brazil) relay server\n- NETPLAY/RELAY: Fix the spectator bug when using the relay server  When a player switches into the spectator mode (pressing i) while using the relay server, all players will disconnect.\n- NETPLAY/RELAY: Overall stability has improved. Fixed a memory leak that would cause the relay server to become unresponsive after some time.\n- NETPLAY/RELAY: Fixed critical bug that would cause all players to be disconnected from the relay server if one player was leaving the game. That bug had been open for one year and we were finally able to fix it.\n- SWITCH/LIBNX/BUGFIX: Fix onscreen keyboard input regression\n- THUMBNAIL UPDATER: When waiting for individual thumbnail file http transfers to complete, the task status checking is more accurate. This uses the same method as the new core updater - we now wait until the task is 'really' complete, instead of relying on the (slightly nebulous) 'task finished' state\n- UWP: Add ANGLE support\n- UWP: Wire up get_metrics to the fake context of D3D9/10/11/12 driver, enabling proper scaling and mouse/touch gestures\n- VITA: Re-add Online Updater\n- VULKAN: Fix font driver 'vulkan_get_message_width()' function\n- VIDEO FILTERS: Only use threads when the number exceeds 1. Fixes race conditions with some CPU filters on Vita\n- WINDOWS: Add ANGLE support for x64, separate binary (for now?)\n\n# 1.8.2\n- BUG/CRASH/GLSLANG: Fix glslang crashing error - managed to reproduce an issue which has been plaguing\nusers for a while, where glslang throws an assert after closing a game (and starting a new one). This would affect all video drivers that use Slang for shaders, such as D3D10/11/12/Vulkan/Metal\n- CHEEVOS: Display Unofficial and Unsupported achievement states\n- CHEEVOS: Pass RetroArch and core versions through User-Agent HTTP header\n- CHEEVOS: Use PSX.EXE if SYSTEM.CNF cannot be found\n- CHEEVOS: Prevent loading state while achievements are still being fetched from server\n- CHEEVOS: Pause hardcore if core doesn't support achievements\n- CHEEVOS/CRASH: Fix AddressSanitizer + CHD cause hard crash when Cheevos are enabled\n- CORE UPDATER: Only download when new core is available\n- CORE UPDATER: Add option to update all installed cores\n- DRM/KMS: Better detection for the current video mode\n- DYNAMIC RATE CONTROL: Support DRC even when using a vsync swap interval higher than 1\n- EMSCRIPTEN: Fix bug in Emscripten input code\n- EMSCRIPTEN: Changes to support upgraded emscripten SDK\n- FFMPEG CORE: Hardware accelerated video decoding\n- FFMPEG CORE: Implement send/receive encoding API, will allow for hardware accelerated AMD video encoding\n- FFMPEG CORE: The video FIFO can be removed, since we have a ring buffer in its place. This removes unneeded copy operations and as a positive side improves overall decoding speed. Makes 8k60p SW and 4k60p HW decoding feasible on many systems. For now the ring buffer is 32 images deep. This limitation will be removed, once audio and video decoder have their own packet handling.\n- INPUT: Fix 'Analog stick controls menu even if autoconfig disabled'\n- INPUT/TURBO: Added alternate Turbo-Mode 'Single Button' - For systems supporting only a single button, the turbo-button will toggle firing that button without the need to hold it. When holding the button turbo will be suspended and resumed when the button is released. Holding the button may have a different function to just tapping it.\n- IOS: Forcibly disable Threaded Video until UIWindow concurrency issues are fixed\n- INPUT/ANALOG: Fix radial analog deadzone scaling\n- INPUT/ANALOG: Implement proper analog button deadzone\n- INPUT/MENU: Analog stick controls menu even if autoconfig disabled\n- LOCALIZATION: Update Italian translation\n- LOCALIZATION: Update French translation\n- LOCALIZATION: Update Polish translation\n- LOCALIZATION: Update Portuguese Brazilian Translation\n- LOCALIZATION: Update Turkish translation\n- LINUX/LOCALIZATION: Correct Droid Sans Fallback font path in Linux. This should fix Chinese/Korean font display issues on Fedora/RHEL/CentOS/openSUSE/SLE\n- MENU/BUGFIX: When using a keyboard/gamepad/mouse wheel to navigate, the menu scroll position is always maintained and updated in a consistent (and expected) fashion\n- MENU/BUGFIX: When resizing the window, or changing the orientation of a mobile device, the current scroll position is correctly preserved\n- MENU/BUGFIX: All 'normal' pointer input is now inhibited when showing message boxes\n- MENU/BUGFIX: The pointer actions 'select' and 'cancel' both now properly close a message box if it is currently being shown\n- MENU/BUGFIX: Pointer 'select' and 'cancel' actions are now inhibited when an input bind dialog is active\n- MENU/INPUT: Change 'User' terminology to 'Port' for input binding\n- MENU/LINUX: Add proper drives to Load Content\n- MENU/MATERIALUI: Halt scrolling when pointer is pressed/stationary\n- MENU/MATERIALUI: Dual thumbnail view\n- MENU/MATERIALUI: Fullscreen thumbnail viewer for boxart\n- MENU/MATERIALUI: Scroll rapidly by press and holding the scrollbar\n- MENU/RGUI: New theme 'Flux'\n- MENU/OZONE: Thumbnails now have a fade-in animation\n- MENU/OZONE: Fullscreen thumbnail viewer for boxart and pictures\n- MENU/QT/WIMP: Fix dock titles getting cut off\n- MENU/XMB: Fullscreen thumbnail viewer for boxart and pictures\n- MENU/USABILITY: Selectively hide 'Disallow Non-Slave Mode Clients' if 'Allow Slave-Mode Clients' is disabled\n- MENU/USABILITY: Hide 'Show desktop menu on startup' if 'Desktop menu' setting itself is disabled\n- MENU/USABILITY: Reimplement Quick Menu - > Shaders -> Watch shader files for changes - can now be turned on/off through touch\n- MENU/USABILITY: Refactor Quick Menu - Controls - each port now has its own submenu\n- MENU/USABILITY: Quick Menu - Cheats - Delete All no longer requires five right button presses - this should fix this functionality for mobile touch users too\n- MENU/USABILITY: Hide Refresh Rate options when Threaded Video is enabled - these settings do nothing with Threaded Video\n- MENU/USABILITY: Hide Logging Verbosity levels behind Logging Verbosity\n- MENU/USABILITY: Get rid of 'Port Number' label for Port Binds screen\n- MENU/USABILITY/MOBILE: Should no longer crash when clicking on a cheat entry\n- MENU/USABILITY: Shader parameters now have a dropdown list\n- MENU/USABILITY: Shader passes now has a dropdown list\n- MENU/USABILITY: Video - Hide Windowed Mode settings selectively\n- MENU/USABILITY: Video - Hide Fullscreen Mode settings if windowed mode is not supported by context driver\n- MENU/USABILITY: Selectively hide Network Command Port\n- MENU/USABILITY: Selectively hide Relay Server Location\n- MENU/USABILITY: User Interface -> Appearance - Selectively hide XMB Horizontal Animation setting\n- MENU/USABILITY: Playlists - more selective hiding\n- MENU/USABILITY: Selectively hide Rewind Settings\n- MENU/USABILITY: Selectively hide Overlay Settings\n- MENU/USABILITY: Selectively hide FPS Update Interval based on Display Framerate being enabled\n- MENU/USABILITY: Selectively hide Onscreen Notifications BG Color Settings\n- MENU/USABILITY: Settings -> Logging - Hide 'Log To File Timestamp' if 'Log To File' is disabled\n- MENU/USABILITY: Video -> Scaling - Hide Custom Viewport X/Y when Integer Scale is enabled as description indicates\n- MENU/USABILITY: Achievement submenu - selectively hide\n- MENU/USABILITY: Settings -> Video -> Aspect ratio - selectively hide/show values based on whether you have Custom or Config selected\n- MENU/USABILITY: Settings -> Video -> Selectively hide Hard Sync\n- MENU/USABILITY: Settings -> Video -> Implement selective hiding for VSync and Hard Sync\n- MENU/USABILITY: Selective hiding of Runahead settings based on global setting\n- MENU/USABILITY: Add Input -> Haptic Feedback submenu\n- MENU/USABILITY: Add Input -> Menu Controls submenu\n- MENU/USABILITY: Settings -> Video -> Max Swapchain Images - Add OK action\n- MENU/USABILITY: Input - Implement OK action for Bind Hold, Turbo Period and Duty Cycle\n- MENU/USABILITY: Input - Hotkey Binds refactor\n- MENU/USABILITY: Move 'Press Quit Twice' and 'Menu Toggle Gamepad Combo' to Input -> Hotkey Binds\n- MENU/USABILITY: Video - Add sublabel for Video Output submenu\n- MENU/USABILITY:  If 'Favorites Tab' is disabled, don't show 'Add To Favorites' option in Quick Menu/Playlist menu\n- MENU/USABILITY: If On-Demand Thumbnail Downloader is enabled, hide 'Download Thumbnails' from playlist menu screen\n- MENU/USABILITY: Add Audio Driver setting to Audio -> Output\n- MENU/USABILITY: Add Audio -> Resampler settings\n- MENU/USABILITY: Add Audio -> Output and Audio -> Synchronization\n- OPENGL: Shaders are now working properly (only in OpenGL) when rotating both from Core API rotation and from menu video rotation. The fix is clearly visible with crt-royale for example\n- OPENGL: 1:1 PAR is now correct when rotating (both from Core API rotation and from menu video rotation, as you said, in the latter case you currently have to change Aspect Ratio after menu video rotation for it to work)\n- OPENGL: When using Custom Aspect Ratio and rotation (both from Core API rotation and from menu video rotation), Integer Scaling is now working properly (correct multiples of internal resolution). Even when Integer Scaling is not activated, the Custom AR width / height are now correctly labeled using (1x), (2x), ... suffixes. You also have to activate Integer Scaling after menu video rotation for it to work\n- OPENGL: For all other Aspect Ratio options, Integer Scaling and rotation (both from Core API rotation and from menu video rotation) are now working properly together (correct multiples of internal resolution). You also have to activate Integer Scaling after menu video rotation for it to work\n- OPENBSD/POWERPC: Should build now on OpenBSD PowerPC\n- PLAYLISTS: Pressing 'Start' or long touching a playlist will bring you to a Playlist submenu where you can set a default core, setup thumbnail view, delete the playlist, etc\n- OSX: Forcibly disable Threaded Video until NSWindow concurrency issues are fixed\n- PSP: Solving issue exiting RetroArch by HOME button\n- SCANNER: Manual scanner, not dependent on database files\n- SCANNER/MANUAL: Add option to scan inside archives\n- SCANNER/MANUAL: Enable automatic naming of arcade content via DAT files. This is compatible with DAT files in either Logiqx XML or MAME List XML format.\n- VIDEO: Do not reinit video driver on SET_SYSTEM_AV_INFO unless needed\n- VIDEO: Support DRC even when using a vsync swap interval higher than 1\n- VIDEO LAYOUT: Fixed XML parsing of attributes with spaces, should fix issues with several video layouts\n- VITA: GL1 driver support\n- VITA/VITA2D: Several improvements to Vita 2D driver - menu widgets implemented\n- VITA/VITA2D: Fix clipping and reduce number of calls\n- VULKAN/ANDROID: Workaround weird WSI return codes in landscape mode -  Android WSI wants you to use preTransform, and if it is not used correctly, Android 10 will return VK_SUBOPTIMAL_KHR, and we would create a new swapchain every frame. This workaround just ignores this error, since it's not really an error. A more \"proper\" fix is to use prerotate and modify the MVP matrices,\nwhich might help certain devices with crummy display processors\n- VULKAN/ANDROID: Recreate swapchain on orientation change. ANativeWindow getWidth/Height does not detect any changes when using\nVulkan, so use the old onContentRectChanged callback to get notified when size changed. Use those values instead when figuring out how large swapchain to create\n- WINDOWS/XINPUT: Get rid of 128 byte device name limit for XInput device discover - when device name was too long, it would not be picked up by the XInput driver and would instead fallback to DirectInput\n- WINDOWS: ANGLE OpenGL ES 2 support\n- UWP: Fix crashes on startup / prompt for folder permissions when trying to load custom.ini\n- UWP: Fix - Mouse input is offset on high DPI monitors\n- UWP: Fix - Keyboard input hangs sometimes\n- UWP: Fix - Multi-touch support\n- UWP: Fix - Enable menu touch input by default\n- UWP: Fix - Get user language\n- UWP: Fix - Get CPU model name\n- UWP: Fix - Use GLUI instead of XMB on Windows Mobile 10\n- UWP: ANGLE OpenGL ES 2 support\n\n# (1.8.1)\n- BUGFIX/MENU: Fix menu rendering with Mali GPUs after changing video dimensions\n- CDROM: Adds pregap support to cdfs helper methods\n- CHEEVOS: Provides the new PCEngine hashing algorithm for RetroAchievements\n- LOCALIZATION: Update French translation\n- LOCALIZATION: Update Polish translation\n- LOCALIZATION: Update Spanish translation\n- MENU/MATERIALUI: Initial thumbnail support\n- MENU/MATERIALUI: Cutie / Virtual Boy theme added\n- MENU/MATERIALUI: Bugfix - Under certain extreme circumstances, entries with very long sublabel strings could have their text prematurely 'clipped' as the entry is scrolled beyond the top of the screen\n- MENU/MATERIALUI: Bugfix - Certain setting value strings were unnecessarily truncated (with a ...) when using smooth ticker text\n- MENU/XMB: Sunbeam theme added\n- SWITCH: Accelerometer, gyroscope and illuminance sensor support\n- VITA: Accelerometer and gyroscope sensor support\n\n# (1.8.0)\n- AI SERVICE: Added in fix for BMP returns to AI service. Added in label passing to AI service call\n- BSV: Fix BSV recording/playback\n- BUGFIX: Fix crash when setting Thumbnail Directory\n- BUGFIX/STABILITY: Set \"Automatically Add Content to Playlist\" to false by default, this was unstable on PS3 and Mac and other platforms potentially as well.\n- COMMON: Graceful driver switching for Windows and Linux\n- COMMON: Cache frame before converting 0RGB1555\n- LAKKA: Wi-Fi Access Point settings\n- MENU: Menu scaling improvements\n- MENU/MATERIALUI: There are no longer any animation glitches when 'wraparound' scrolling from the last entry in a list to the first, or when performing horizontal swipe navigation gestures on certain settings-type entries\n- MENU/MATERIALUI: List entries underneath the title and navigation bars are no longer highlighted when touching the title/navigation bars (this was only a cosmetic issue, but it was annoying...)\n- MENU/MATERIALUI: The current menu list is no longer reloaded when pressing the currently active tab on the navigation bar\n- MENU/MATERIALUI: The ticker text spacer has been set to a 'bullet' character (same as Ozone)\n- MENU/MATERIALUI: The default colour theme has been set to 'Ozone Dark'\n- MENU/MATERIALUI: Three new colour themes have been added.\n- MENU/MATERIALUI: A new Menu Transition Animation option has been added under User Interface > Appearance. When this is enabled, menu transition events are animated\n- MENU/MATERIALUI: The navigation bar is now shown at all times - i.e. it is an actual navigation tool, rather than a 'top-level-menu' curiosity\n- MENU/MATERIALUI: Two new context-sensitive buttons have been added to the navigation bar - back button and resume button\n- MENU/MATERIALUI: A new Auto-Rotate Navigation Bar option has been added under User Interface > Appearance. When enabled (this is the default setting), the navigation bar is moved to the right hand side of the screen when using landscape screen orientations.\n- MENU/MATERIALUI: The playlists tab is now correctly hidden when User Interface > Views > Show Playlist Tabs is disabled\n- MENU/MATERIALUI: Material UI now correctly readjusts its layout when screen orientation changes on mobile devices\n- MENU/MATERIALUI: Material UI now resizes in real-time when the user manually sets the Menu Scale Factor (this never worked properly with the old DPI override)\n- MENU/MATERIALUI: Material UI no longer leaks memory on 'context reset' (fonts were previously never free()'d)\n- MENU/MATERIALUI: A new Android-style 'system bar' has been added. This shows current core name, clock and battery level\n- MENU/MATERIALUI: A new search icon is shown on the title bar when viewing playlists and file browser lists. Pressing this launches the search interface\n- MENU/MATERIALUI: The title bar now uses a larger font, and the sublabel font has also been enlarged a little, to more closely align with Material UI standards\n- MENU/MATERIALUI: A number (quite a large number) of layout/spacing issues have been fixed\n- MENU/MATERIALUI: The existing colour theme handling code is not fit for purpose, so the whole lot got ripped out and reimplemented. In doing so, also adjusted all the theme colours to better match Material UI standards - with a few liberties taken for aesthetic purposes.\n- OSD: Fix fast forward indicator when not using menu widgets\n- PSP1: Remove duplicated FPS indicator on the screen\n- SWITCH: Make audren threaded audio driver the new default\n- VIDEO LAYOUT: Add video layout mame overlay compatibility. Enabled for Windows/Linux/OSX/iOS/Android/libnx. Only works with GL driver for now, no glcore yet\n\n# (1.7.9) (v2)\n- 3DS: Fix 3DS screen flickering when OSD is enabled\n- IOS: Fix crash that could happen at startup\n- MENU/MATERIALUI: Change DPI scaling back to original - too many issues with current implementation, requires a redesign\n\n# (1.7.9)\n- AI SERVICE: Image mode is now much faster, it now saves the image in-memory in PNG format then passes it along to the translation service\n- BUGFIX: Touch input - When using an overlay to toggle the quick menu on touchscreen devices, we no longer get 'phantom' menu input - i.e. the old bug of hitting the toggle and instantly resuming content (or performing a save state) is fixed\n- BUGFIX: Networking - RetroArch crashed when pressing left while Relay Server Location entry was selected\n- BUGFIX: Networking - fix memory leak that could happen at exit after a network\noperation had run\n- CHEEVOS: Improve handling of line endings when calculating CD hashes for retroachievements\n- CHEEVOS: Add support for Sega CD/Saturn; reduce hash calls to server\n- FPGA: Add initial FPGA port for Z-Turn boards - not really release-ready yet, will need community support to continue. Currently employs naive framebuffer approach, not fullspeed\n- GL1: GLDirect (D3D9 to OGL1.1 wrapper) support\n- GONG: Stability fixes\n- LINUX/UDEV: Fix touchscreen/lightgun issues\n- MENU/MATERIALUI: MaterialUI no longer 'forgets' its place when navigating backwards in menus, and navigation in general is 'cleaner'.\n- MENU/MATERIALUI: Add initial gesture support\n- MENU/MATERIALUI: Improved touch support\n- MENU/MATERIALUI: Bugfix - Random' items are no longer automatically highlighted when performing standard up/down 'flick' scrolling through lists (items are only highlighted when you keep the pointer still for > 200 ms)\n- MENU/MATERIALUI: Bugfix - The display no longer 'jerks' for one frame when navigating backwards through lists\n- MENU/MATERIALUI: Bugfix - The Material UI scaling factor is now based upon the device-reported screen DPI value (previously it relied upon a hard-coded magic number, which was never correct)\n- MENU/RGUI: Functional mouse/touchscreen support\n- MENU/ONSCREEN KEYBOARD: On-screen keyboard entry via mouse/touchscreen has been tidied up - no more double inputs (or unwanted menu interaction in the background)\n- MENU/MOUSE: Mouse wheel up/down is now a proper 'up/down', same as using cursor keys or a dpad\n- MENU/MOUSE: Mouse wheel tilt left/right has been wired up to normal 'left/right' commands. Also further improved mouse wheel tilt\n- MENU/OZONE: Add option to toggle between static and scrolling content metadata\n- MENU/XMB: Add full gesture support\n- MENU/OSX: Fixed mouse buttons - mouse down events were not hooked up\n- MENU: When navigating backwards from a core options drop-down list (i.e. pressing select or cancel), the last menu position is remembered (instead of resetting back to the first core option item each time)\n- MENU: Add mouse/touchscreen gesture support\n- MENU: Add option to delete playlists (Settings > Playlists > Playlist Management)\n- MOBILE (ANDROID/IOS): Add option to automatically rotate overlays when changing orientation\n- OSD: Memory details should now be available on every platform (get_mem_total and get_mem_free need to be implemented in the frontend driver for it to work)\n- OSD: Memory details can now be shown individually without FPS and frame count\n- PS2: Fix memory leaks in font/video driver\n- SWITCH: Set default aspect ratio to core provided instead of 4:3\n- THREADED VIDEO: Fix FPS text in threaded video mode\n- VITA: Set default aspect ratio to core provided instead of 4:3\n- VITA: Add system language detection\n- VITA: More memory support\n- WIN32: Log window now has title 'Logging Console'\n- WII: Add Wiimote lightgun support\n\n# 1.7.8 (v4)\n- COMMON: Enable customisation of runtime 'last played' display format.\n- CHEEVOS:  Add hashing support for PSX (bin/cue, chd, or real CD) (for real this time, got added in the CHANGELOG for v2 then reverted before it hit release)\n- IOS: Update for iOS 13, fix the asset packaging issues\n- LOCALIZATION: Update Portuguese Brazilian Translation\n- MENU: Add 12-hour time/date versions of all formats\n- SWITCH: Add 'AI Service' option to Switch (untested)\n- SWITCH: Update to newest libnx\n\n# 1.7.8 (v3)\n- GLCORE: Ensure correct scaling of menu texture (with RGUI)\n- IPS: Soft-Patch any IPS size\n- METAL: Fix overlay issue - setup correct viewport before rendering overlay\n- METAL/STB: Fix font driver issue with AMD GPUs on MacOS.\n- MENU/RGUI: Correctly rescale menu when resizing window if aspect ratio lock is enabled.\n- OSX: Remove OSX suffix in window title\n- PSP: Fix audio conversion code\n- REMAPS: Fix analog remapping regression -analog remapping would break controls\n\n# 1.7.8 (v2)\n- 3DS: Fix 3DS startup crash\n- AI SERVICE: Fix 'Japanese' setting\n- D3D12: Fix runtime error at startup\n- CHEEVOS: Fix Achievements badges\n- CHEEVOS: Add hashing support for PSX (bin/cue, chd, or real CD)\n- GLCORE: Fix regression - shaders don't work\n- IOS: Use launch storyboard to properly support all screen sizes\n- LOCALIZATION: Update Japanese translation\n- LOCALIZATION: Update Korean translation\n- LOCALIZATION: Update Polish translation\n- MENU/XMB: Smooth vertical ticker scrolling\n- OSX: Fix potential OSX startup crash\n- PATCH: Fix IPS patches\n- PLAYLISTS: Fix playlist heap corruption bug. Would also cause potential crashes on OSX and 3DS at startup\n- SHADERS: Fix shader loading and saving in content-less cores\n- SHADERS: Implement video_shader_delay setting. Screen grabbing software like streaming software can interfere with the loading of shaders, resulting in graphical glitches or freezes. This PR adds a video_shader_delay setting (in ms) and (advanced) menu entries Video -> Auto-Shader Delay, allowing to work around the issue\n\n\n# 1.7.8\n- 3DS: Fix C-Stick y-axis inversion\n- 3DS: Update all icon/banner images\n- AI: Add AI Service functionality (enabled for Windows/Mac/Linux/Android/iOS).\n- APPLE (MAC/IOS/TVOS): Fix autodetect for mFI controllers: properly call autodetect add on the connect notification, and add call to disconnect on GameController disconnect notification.\n- ANDROID: Implemented multi-touch touchscreen support\n- ANDROID: Now can be built with Gradle/Android Studio\n- AUDIO/WINDOWS: You can now select between audio devices for XAudio2/DirectSound/XAudio2 by pressing left/right on the Audio Device option.\n- AUDIO/WINDOWS: Setting the device by either index number or name string should work.\n- BLISS-BOX: Add 4 new pad types from firmware 3.0\n- BPS/UPS: Re-allocation target_data variable for target patch size (can now apply bigger patches without extra-bytes on memory)\n- CDROM: Added real CD-ROM functionality for Windows and Linux.\n- CDROM: Added disc dumping.\n- COMMON: Add separate frontend logging\n- COMMON: Ability to set FPS update interval (used in the window titlebar/FPS widget)\n- COMMON: Add 'Reset Frame Time Counter' functionality, enable it by default for resizing the window, loading/saving shader presets, fastforwarding, etc.\n- COMMON: Add optional 'on demand' thumbnail downloads\n- COMMON: Add new playlist-based thumbnail downloader. Hide the legacy thumbnail pack version by default\n- COMMON: Show license per core (if available) inside 'Load Core'\n- COMMON: Add option to load content from (and dump) CD-ROM discs\n- COMMON: Re-enable '--log-file' command line option\n- COMMON: Default playlist core association is now stored as metadata inside each playlist\n- COMMON: Fix playlist format detection\n- COMMON: Favorites playlist size can now be set independently of content history size. Values can be set from 0-999, or '-1' for unlimited (99999)\n- COMMON: Prevent adding new items to favorites when playlist is full (old entries are no longer overwritten)\n- COMMON: Prevent loading content with cores that require an incompatible graphics API version from the current one\n- COMMON: Saved shader presets are now portable across platforms and use relative paths\n- COMMON: Add '--set-shader' command line option which works like an override for automatic shader presets\n- COMMON: Add global shader presets\n- COMMON: Remove 'video_shader' setting, shaders are not saved automatically anymore\n- CORE OPTIONS: When saving core option overrides, only include settings for the current core\n- CORE OPTIONS: Add option to save core options per-core\n- CPU FILTERS: Add Scanline2x filter\n- DINPUT: Cleanup magic numbers mess surrounding hat code\n- GAMECUBE: Add default video/audio filter directories\n- GL/MALI400: Fix menu issues on Mali 400 series GPUs, should also fix 'RetroArch flickers black on ARM Mali GPUs (Android/ARM Linux)\n- GL/GLCORE: Use highest supported OpenGL Core version on Windows and X11\n- GL1: Ignore alpha in core video, fixes XRGB8888 rendering in some cores\n- GLCORE: Don't hardcode shader cross compilation target version but poll it. glcore would always only use the minimum target shader version, i.e. GLSL ES 3.00 for OpenGL ES 3.0+ or GLSL 1.50 for OpenGL 3.2+\n- D3D10/11/12/SLANG: Added \"FrameDirection\" slang semantic. Works fine with braid-rewind shader, not entirely perfect with D3D12 though\n- D3D10/11/12: Add option to select which GPU to render with\n- D3D10/11: Fix maintaining aspect ratio when resizing window\n- GLCORE/SLANG: Added \"FrameDirection\" slang semantic\n- HID: Add Retrode support. Should work on Wii/WiiU.\n- INPUT: Menu toggle hotkey can now be bound to another keyboard key and it will toggle properly\n- IOS: Correctly centers screen on iPhone X landscape\n- IOS: Implemented multi-touch touchscreen support\n- IOS: Add in more Apple Model numbers for RetroRating Added in all current Apple Model numbers and set a base rating of 19\n- IOS: Remove pause indicator; show the native UI menu using 4-finger swipe down gesture\n- IOS: Support L3/R3 in iOS 12.1, Options buttons in MFi/PS4/XBox One controllers in iOS 13\n- LIBRETRO: Add new core options interface, allows for localization, sublabels and more\n- LIBRETRO: Add new bitmask input codepath, for RETRO_DEVICE_ID_JOYPAD only for now\n- LOCALIZATION: Update Korean translation\n- LOCALIZATION: Update Japanese translation\n- LOCALIZATION: Update Portuguese Brazilian Translation\n- LOCALIZATION: Update Polish translation\n- LOCALIZATION: Update Turkish translation\n- MENU: Add smooth ticker text\n- MENU: Ability to hide every settings submenu (User Interface -> Views -> Settings)\n- MENU: Ability to hide nearly every quick menu entry (User Interface -> Views -> Quick Menu)\n- MENU: Fix longstanding menu display issues on Mali400 GPUs (on ARM hardware, SBCs and mobile phones/tablets)\n- MENU: Fix Record -> Streaming Quality, and Record -> Recording Threads settings\n- MENU: Fix history playlist navigation after running content\n- NENU: Menu entry performance optimisations\n- MENU: Add option to show 'remove playlist entry' only on history/favourites\n- MENU: Overhaul content 'Information' menu display\n- MENU: Add new 'Playlist Management' submenu. Allows default core associations to be set (via dropdown list), and all existing associations to be reset\n- MENU: Add 'Set Core Association' option to Quick Menu\n- MENU: Add option to remain in menu after saving/loading states\n- MENU: Pressing the Start button on 'Load Core' will unload the core.\n- MENU: After a core is running, Load Core will be hidden from view until you select 'Close Content' from the Quick Menu.\n- MENU/WIDGETS: All widgets are now properly cleaned up, fixing the frozen widgets bug when loading / closing content\n- MENU/WIDGETS: Fix crash with tasks\n- MENU/WIDGETS: Widgets are now drawn above the overlay with OpenGL and Vulkan\n- MENU/WIDGETS: Fine tune progress bar colors\n- MENU/WIDGETS: Have the progression widget always resize\n- MENU/THUMBNAILS: Ensure that displayed thumbnails are always refreshed correctly after selecting 'Download Thumbnails' from Quick Menu\n- MENU/THUMBNAILS: Make PNG image loading/processing non-blocking on non-threaded systems\n- MENU/OZONE: Add it for PS3\n- MENU/OZONE: Fix regression in 1.7.7 - OSX/macOS - was unable to start it\n- MENU/OZONE: Fix sublabel spacing\n- MENU/OZONE: Add toggle to enable/disable playlist name truncation in Ozone\n- MENU/OZONE: (Ozone) Fix display of (semi-)transparent thumbnails\n- MENU/XMB: Add menu animation settings\n- MENU/XMB: Add optional thumbnail scaling\n- MENU/XMB: Fix display of long sublabels. Text that would exceed the display area now scrolls line-by-line\n- MENU/XMB/OZONE: Add optional thumbnail upscaling\n- MENU/QT/WIMP: Add core option sublabels as tooltips, add buttons to reset one/all core options\n- MENU/QT/WIMP: Word-wrap core option tooltips\n- MENU/QT/WIMP: Path selector fixes\n- MENU/RGUI: Enable playlist display on platforms without database support\n- MENU/RGUI: Make particle effects framerate independent + add animation speed setting\n- MIDI: correct pitch bend in ALSA driver - MIDI standard pitch bend center position is 0x2000 but ALSA's is 0\n- MIDI: Fix SysEx handling. We need to clear the event status after each message. Otherwise, after a SysEx message the first byte of the next event will incorrectly inherit its delta_time. This causes a delay of several seconds in nearly every MT-32 games which uses a lot of long SysEx.\n- METAL/SLANG: Added \"FrameDirection\" slang semantic\n- NETBSD: Audioio is now the default audio driver\n- NETBSD: Fix a segfault when starting RetroArch with an empty configuration file and LANG unset in the environment\n- OSD: OSD is now drawn above the overlay with Vulkan\n- OSX: Fix regression with Cocoa GL - shader / preset loading was getting stuck in an infinite loop\n- OSX: Add improved menu resizing for window resizing\n- PLAYLISTS: Add history/favourites to 'Playlist Management' menu\n- RECORD: Fix Twitch streaming\n- REMOTE RETROPAD: Fix for Remote RetroPad input - fixes processing of Remote RetroPad input. None of the remote inputs are being executed both in menu and in game. This is due to the way current key binds are being detected which block processing of any remote input. It's been tested using Remote RetroPad core on Android including digital dpad and analog control input.\n- RUNAHEAD/MSVC2010:  Build in runahead support for MSVC2010 and up\n- RUNAHEAD/VITA: Build in runahead support for Vita version\n- SAVESTATES: Allow auto save states also in cores that support no content as long as some content is loaded\n- SCALER: Fix SSE2 path for ARGB/BGRA -> BGR24 - should fix screenshots being taken for XRGB888 (viewport)\n- SCANNER: Skip all databases with incompatible file extensions, whether content is inside an archive or not\n- SCANNER: Fix hang on empty files inside archives\n- SHADERS: Add proper shader compatibility checks\n- SHADERS: Enable Cg shaders for D3D9\n- SHADERS: Remove 'video_shader' setting, replace it with global presets that make more sense\n- SHADERS: #reference directive for shaders. Presets can point to other existing presets if they are unchanged\n- SHADERS: Will attempt to cache the shader/preset into memory before loading to avoid costly getline/gets/getc operations\n- SHADERS: New --set-shader commandline option\n- SHADERS/MENU: Prevent undefined behaviour when failing to load shaders\n- SHADERS/MENU: Pressing the Start button on 'Load Shader Preset' will reset all shader passes and apply changes, effectively disabling the shaders\n- SHADERS/MENU: New menu options for removing shader presets (global/core/parent/etc).\n- SWITCH :Add Audren audio driver.\n- SWITCH: Fix splitting and joining of joycon controllers. Before this fix, splitting and joining of joycons only ever worked sporadically\n- SWITCH: Proper x/y scaling for pointer devices, fixes touch lightgun\n- THUMBNAILS: Add optional On-Demand Thumbnails.\n- UDEV: Fix wrong udev devices order\n- UDEV/X11: Mouse pointer should work now in X11 environment with no Display\n- VITA: Update Vita2D\n- VULKAN/SLANG: Added \"FrameDirection\" slang semantic\n- VULKAN: Add option to select which GPU to render with\n- VULKAN: Validate non-causal filter chain for texture inputs. We only validated for UBO inputs apparently.\n- WINDOWS: Menubar should no longer be disabled when threaded video is enabled\n- WINDOWS: Add improved menu resizing for window resizing\n- WINDOWS: Properly set initial directory for menubar 'Load Core' option\n- WII: Add default video/audio filter directories\n- WII: Fix RGUI display corruption\n- WII: Fix HID joypad drivers\n- WII: Add optional overscan correction\n- WII: Fix recursive path_mkdir() operations\n- WII: Add widescreen RGUI support\n- WIIU: Scale menu to viewport size; respect filtering settings for menu\n- WIIU/RGUI: RGUI does its own transparency effects in the texture, so we don't have to add another 50% on that\n- WIIU/RGUI: Use correct pixelformat ordering for menu texture\n- WIIU/SLANG: Added \"FrameDirection\" slang semantic\n- X11: Add improved menu resizing for window resizing\n- X11: Add non-evdev keycodes to fix keyboard input on non-Linux systems with X11\n\n# 1.7.7\n- 3DS: Add unique IDs to prevent cores overwriting each other\n- 3DS: Fix screen tearing when running 50Hz content\n- ANDROID: We now target API level 26 (minimum is still API level 9)\n- ANDROID: Add option to vibrate on touch (works in menu or overlay)\n- ANDROID: Add device vibration option for cores that support rumble\n- ANDROID: Add gamepad vibration support for cores that support rumble\n- ANDROID: Allow stylus/pen to move mouse without pressing down\n- AUDIO: Avoid deadlocks in certain audio drivers when toggling menu sounds on\n- BLISS-BOX: Support PSX Jogcon (requires firmware 3.0)\n- CHEEVOS: Fix crash when reading memory that is out of range\n- CHEEVOS: New Cheevos implementation enabled by default\n- CHEEVOS: Pop-up badges when an achievement is triggered\n- CRT: Dynamic super resolution support\n- DISCORD: Fix potential crash when username is empty and discord is disabled\n- DISCORD: Ask to join support for Linux\n- INPUT/ANDROID: Add \"Input Block Timeout\" option\n- COMMON: For platforms without HAVE_THREADS, don't automatically resume content when saving/loading states\n- COMMON: Make playlist sorting optional and consistent\n- COMMON: Fix sorting of playlists with blank labels\n- COMMON: Fix content scanner creating false positive playlist entries that also have wrong label and crc32\n- COMMON: Add some MMX-optimized pixel conversion routines\n- COMMON: Fix typo preventing some SSE2-optimized pixel conversions from being used\n- COMMON: Add option to track how long content has been running over time\n- COMMON: Fix buffer overflows in system information\n- COMMON: Add option to change screen orientation via the windowing system (Android, Windows, X11)\n- COMMON: Show CPU model name in log\n- COMMON: Add \"Help -> Send Debug Info\" option (and F10 hotkey) to send diagnostic info to the RetroArch team for help with problems\n- COMMON: Show GPU device name/version in log\n- COMMON: Add menu option to write log info to a file\n- COMMON: Add subsystem support for playlists. Subsystem info is automatically saved to the history playlist for easy relaunching\n- GL: Add new \"gl1\" OpenGL 1.1 compliant video driver for legacy GPUs and software renderers\n- GL: Add a new \"glcore\" driver with slang support (requires GL 3.2+ or GLES3)\n- GL: Draw OSD on top of overlay\n- GONG: Add savestate support\n- GONG: Add video refresh rate core options\n- GONG: Two player support via core option\n- GUI: Fix text alignment when using stb_unicode\n- GUI: Fix text display issues when using Japanese (and other unicode-dependent language) text with stb_unicode\n- GUI: Set language on first startup to the user's preferred OS language (Windows, *nix and Android)\n- INPUT: Add (scaled radial) analog deadzone and sensitivity options\n- LIBRETRO: Add Turkish language support\n- LIBRETRO: Allow non-accelerated video to rotate the display\n- LOCALIZATION: Update Chinese (Simplified) translation\n- LOCALIZATION: Update Chinese (Traditional) translation\n- LOCALIZATION: Update Dutch translation\n- LOCALIZATION: Update French translation\n- LOCALIZATION: Update German translation\n- LOCALIZATION: Update Japanese translation\n- LOCALIZATION: Update Polish translation\n- LOCALIZATION: Update Russian translation\n- LOCALIZATION: Update Spanish translation\n- LOCALIZATION: Add new Turkish translation\n- MIDI: Fix startup crash in midi driver\n- MENU: Bugfix - you can no longer get stuck in Online Updater -> Update Core screen when toggling between ingame and menu\n- MENU: Selectively hide 'Take Screenshot' for video drivers that don't support taking screenshots\n- MENU: Framerate independent menu rendering. MaterialUI/Ozone/XMB/RGUI can now run at higher framerates\n- MENU: Thumbnails work in history list\n- MENU: Menu widgets\n- MENU: Add memory statistics support to more context drivers\n- MENU: Enable ozone driver for UWP builds\n- MENU: Add optional \"looping\" menu text ticker with configurable speed\n- MENU: Fix core video rendering when using ozone with GL cores that implement the scissor test\n- MENU: Add optional playlist sublabels (associated core + play time, where available)\n- MENU: Dropdown list settings now apply immediately\n- MENU: Add setting to require pressing the \"Exit RetroArch\" hotkey twice to confirm\n- MENU: Now able to run at higher refresh rates than 60Hz\n- MENU: Enable \"Add to Favorites\" without loading a core\n- MENU: Allow core name to be hidden on history/favorites playlists\n- MENU: Populate crc32 and db_name fields when adding history/favourites playlist entries\n- MENU: Fix TTF files not showing in OSD/menu font selection screen\n- MENU: Fix audio/video filters not showing in file browser\n- MENU/MaterialUI: Add subsystem support\n- MENU/MaterialUI: Add currently selected entry in dropdown menus\n- MENU/OZONE: Add mouse support on entries (no sidebar yet)\n- MENU/OZONE: Allow collapsing the sidebar\n- MENU/OZONE: Add thumbnail support\n- MENU/OZONE: Battery notifications\n- MENU/OZONE: Add wifi icon for network entries\n- MENU/QT/WIMP: Add git version and build date to Help->About window\n- MENU/QT/WIMP: Fix content loading via the file browser\n- MENU/QT/WIMP: Add new settings window to control all RetroArch settings\n- MENU/RGUI: Improve playlist titles\n- MENU/RGUI: Add option to hide associated cores in playlists\n- MENU/RGUI: Add internal upscaling option\n- MENU/RGUI: Add subsystem support\n- MENU/RGUI: Add menu sublabel support\n- MENU/RGUI: Re-enable \"Load Core\" option when content is loaded\n- MENU/RGUI: Add optional \"Collections\" entry to main menu\n- MENU/RGUI: Add \"Lock Menu Aspect Ratio\" option\n- MENU/RGUI: Add \"full width\" layout option\n- MENU/RGUI: Ensure menu color theme is applied immediately\n- MENU/RGUI: Fix \"Lock Menu Aspect Ratio\" option when using custom viewports\n- MENU/RGUI: Add widescreen support\n- MENU/RGUI: Allow text to be centred when selecting widescreen layouts\n- MENU/RGUI: Add inline playlist thumbnail support\n- MENU/RGUI: Add optional shadow effects\n- MENU/RGUI: Performance optimizations\n- MENU/RGUI: Add optional extended ASCII support\n- MENU/RGUI: Add optional delay when loading thumbnails\n- MENU/RGUI: Add on-screen keyboard\n- MENU/RGUI: Battery notifications\n- MENU/XMB: Prevent crashes when resizing to a tiny window\n- MENU/XMB: XMB honors the 'show menu sublabels' setting now - was previously RGUI only\n- NETPLAY: Fix stall-out causing total disconnection with >2 players\n- NETPLAY: Different (more intuitive?) default netplay share policy\n- NETPLAY: Add hotkey option to toggle hosting on/off\n- NETWORKING: Encode URLs to allow for spaces in directory names\n- OSX: Prevent crash on exit\n- OSX: Metal is now the default video driver for the RetroArch Metal build\n- OSX: Enable CoreAudio v3 driver for Metal\n- OSX/MACOS/IOS: Now uses the STB Unicode font driver\n- PS2: CDFS support\n- PS2: Implemented analog support for ps2 controllers\n- PS2: Fix audio freeze after restarting core\n- PS2: Fix issues with load state and the font driver\n- PS2: File I/O now works for USB and network host\n- PS2: Support cores with extra padding in their frame buffers\n- SCANNER: New option 'Scan without core match'. When this is enabled,\nsupported extensions by all installed cores are not checked, and instead\nit will add all content it finds to a playlist. This way, you can install the core you need later on after scanning. Not enabled by default\n- SHADERS: Don't alphabetize shader presets\n- SWITCH: Add rumble support\n- SWITCH: Add USB keyboard support\n- VITA: Add bluetooth mouse and keyboard support\n- VULKAN: Fix color issues with RGBA8888 swapchains in readback (screenshots)\n- WII: Don't init overlay when RAM is beyond 72MB\n- WII: Skip CRC calculation on content load, can improve load times of larger games by several seconds\n- WINDOWS: Fall back to gl1 driver if accelerated GPU driver is unavailable\n- WINDOWS: Allow winraw and xinput to work without dinput (needed for WinRT)\n- WINDOWS: Add MSVC2017 ARM desktop support\n- UWP: Fix rewind by opting for slower codepath\n- UWP: Fix relative path name issues when loading shaders\n- UWP: Optimizations for VFS system\n\n# 1.7.6\n- ANDROID: Fix Xperia Play input binding\n- CHEEVOS: Reset when hardcore mode is toggled\n- CHEEVOS: Update the hashing methods to identify NES, SNES and Lynx games (more accurate and accepting headerless ROMs)\n- COMMON: Add new JSON playlist format\n- COMMON: Fix playlist corruption when deleting items\n- COMMON: Fix archive progress display calculation\n- COMMON: Fix playlist entries appearing with previously used names\n- COMMON: Fix screenshot filename with no core or content\n- COMMON: Allow compiling without menu support\n- CORE UPDATER: Allow sideloading cores from the menu\n- CPU FILTERS: Add Normal2x filter\n- CRT/LINUX: New Linux switching method partially implemented\n- CRT/LINUX: Linux restore desktop resolution fixed\n- CRT/LINUX: Monitor index switching and auto enumerate for output detection in Linux (still working on the windows method)\n- CRT/RASPBERRY PI: Initial support\n- DATE: Add Date / Time style options\n- DEBUGGING: Add an integrated crash handler for debug builds (see https://docs.libretro.com/tech/debugging)\n- DISCORD: Register the application name properly\n- DISK CONTROL: Remember the last used folder / current active folder to make disk-swapping faster\n- INPUT: Add new menu toggle (hold start button for 2 seconds)\n- INPUT: Fix arrow keys being incorrectly bound as numpad keys\n- INPUT/SDL: Flush the joypad events. Decreases cpu usage over time with the SDL joypad driver\n- LOCALIZATION: Add Greek translation\n- LOCALIZATION: Update German translation\n- LOCALIZATION: Update Italian translation\n- LOCALIZATION: Update Japanese translation\n- LOCALIZATION: Update Simplified Chinese translation\n- LOCALIZATION: Update Spanish translation\n- MENU: New \"ozone\" menu driver\n- MENU: Only show CRT SwitchRes if video display server is implemented (Windows/Linux for now)\n- MENU: User Interface -> Appearance -> 'Menu Font Green/Blue Color' settings now work properly\n- MENU: Add option to enable in-menu sound effects\n- MENU/D3D: Scissoring support (will be used for Ozone and menu widgets)\n- MENU/QT/WIMP: Allow building with MSVC2017\n- MENU/QT/WIMP: Add detailed file browser table\n- MENU/QT/WIMP: New grid view implementation that is faster and loads thumbnails on-demand\n- MENU/QT/WIMP: Thumbnail drag and drop support\n- MENU/RGUI: Overhaul custom theme interface + add wallpaper support\n- MENU/RGUI: Thumbnail support and thumbnail downscaling\n- MENU: Hide password values\n- MENU/SOUNDS: Implement in-menu sound effects (not enabled by default for now, still experimental)\n- MIDI: Add a Linux ALSA driver for MIDI\n- NETPLAY: Force fast-save-states when netplay is enabled\n- NETPLAY: Allow quick joining subsystem lobbies\n- OSX: Initial CoreAudio V3 audio driver (not yet used in release builds)\n- OSX: OpenGL 3.2 Core support for cores\n- PS2: Initial PlayStation2 port\n- PS4: Initial PlayStation4 port\n- RECORDING: Implement recording options in the menu complete with quality profiles, streaming, and proper file naming\n- SCANNER: Fix GDI disc scanning\n- SHADERS: Fix auto shader preset loading on D3D10, D3D11, D3D12\n- SUBSYSTEM: Allow more than 10 subsystems\n- SUBSYSTEM: Cores that use subsystem for complex scenarios can now load content without starting a regular content first\n- SUBSYSTEM: Remember the last used folder to make loading subsystem type content faster\n- SWITCH/LIBNX: Improve touch scaling calculation\n- SWITCH: Proper button labels\n- TVOS: Initial tvOS port\n- VULKAN: Fix RGUI crashing at startup\n- VULKAN/RGUI: Enable 'Menu Linear Filter' option\n- VULKAN: Fix secondary screens in overlays not working\n- WAYLAND: Implement idle-inhibit support (needed for screensaver suspend)\n- WAYLAND: Fix fullscreen toggle\n- WIIU: Initial netplay peer-to-peer support. Network information working\n- WINDOWS/WSA: Network Information info is blank until first network operation\n- WINDOWS: Fix an ancient bug that caused wrong mappings for keyboard arrows\n- WINDOWS: Remember window size and position if so desired\n- WINDOWS: SSL/TLS connections now work properly\n- WINDOWS: Fall back to GDI driver if no accelerated graphics driver is found\n- UWP: Initial UWP port\n- VFS: Update to version 3\n- XBONE: Initial Xbox One port\n- XMB/OZONE: Add more icons\n- XMB: Add Automatic Inverted theme\n- ???: Easter Egg\n\n# 1.7.5\n- CAMERA: Fix Video4Linux2 driver that broke years ago\n- CONFIG: Add 'Reset To Defaults' setting in Configurations. Thi will reset your config file to defaults\n- CHEATS: Add support for Rumble when increase or decrease by the rumble value\n- CHEATS: Add cheat variables to allow for updating large portions of memory\n- CHEEVOS: Prevent loading states before achievements are fully loaded\n- CRT: New porches and interlaced bug fix\n- CRT: New functionality, ability to switch between 15KHz and 31KHz, etc\n- COMMON: Support for \"OEM-102\" key (usually '\\' on Euro keyboards)\n- DISCORD: Add 'Ask To Join' Feature\n- EMSCRIPTEN: Add stb_font support\n- INPUT: Add new menu toggle combos 'L3 + R' and 'L + R' (useful for Switch)\n- IOS: Use safe area to account for notch for iPhone X and adjust main view\n- LOCALIZATION: Update Portuguese / Brazilian translation\n- LOCALIZATION: Update Japanese translation\n- LOCALIZATION: Update Polish translation\n- LOCALIZATION: Update Spanish translation\n- MENU: Add dropdown lists for many settings\n- MENU: Fix crash that could happen when changing core's options on Android\n- MENU/QT/WIMP: Add option to rename playlists\n- MENU/QT/WIMP: Add option to filter extensions inside archives when adding to a playlist\n- MENU/QT/WIMP: Rename playlist entries with 2 single clicks\n- MENU/QT/WIMP: Fix shader parameter checkboxes not working\n- METAL: Add screenshot support\n- NETPLAY: Save lobby details received back from server after first announcement\n- OPENGL/GLX: Implement Adaptive VSync - GLX_EXT_swap_control_tear\n- OPENGL/WGL: Implement Adaptive VSync - WGL_EXT_swap_control_tear\n- RUNAHEAD: Fix performance degradation that could happen over time (after approx. 30 mins). Fixed input IDs outside of range 0-35 causing slow performance in runahead\n- SWITCH: Add stb_font support\n- SWITCH: Add Retro Achievements support\n- SWITCH: Add networking support\n- SWITCH: Add touchscreen support\n- SWITCH: Add OpenGL support\n- SWITCH: Merging of RetroNX Nintendo Switch port, based on libnx SDK\n- VULKAN: Fix race condition in threaded mailbox emulation\n- VULKAN: Maintenance fixes\n- WIIU: Fix menu lag when built with DevKitPro r32\n\n# 1.7.4\n- ANDROID: Add sustained performance mode, can be turned on/off in Power Management settings menu\n- ANDROID: Powerstate/battery level support\n- CHEEVOS: Fix crash when scrolling Achievement List while Unofficial Achievements enabled (#6732)\n- CHEEVOS: Added hitcounts support for PauseIf/ResetIf (#6817)\n- COMMON: Automatically hide \"Configuration Override options\" in Quick Menu\n- COMMON: Small Bugfix to not trigger savestate code when pressing Reset\n- COMMON: Added libsixel video driver\n- EMSCRIPTEN: Fix Game Focus Toggle\n- HID/OSX: Fix to set hid device registration deterministic (#6497), to address issue #6640 re-adding dynamic device registration\n- LOCALIZATION: Update Italian translation\n- LOCALIZATION: Update Japanese translation\n- LOCALIZATION: Update Polish translation\n- LOCALIZATION: Update Portuguese / Brazilian translation\n- LOCALIZATION: Update Russian translation\n- LOCALIZATION: Update Spanish translation\n- MIDI: Add MIDI support to the libretro API. Dosbox is the first proof of concept core implementing libretro MIDI\n- MIDI: Add a Windows driver for MIDI, based on winmm\n- MENU/QT/WIMP: Qt QSlider styling for Dark Theme\n- MENU/QT/WIMP: Remove button ghostly inside highlighting\n- MENU/QT/WIMP: Initial grid view\n- MENU/QT/WIMP: Drag&drop to add new playlist items, add option to add/edit/delete playlists\n- MENU/QT/WIMP: Add menu option to update RetroArch (Windows only for now)\n- MENU/QT/WIMP: Add menu option to manage shaders\n- MENU/QT/WIMP: Add menu option to manage core options\n- MENU/XMB: Add new icons for the settings\n- MENU/XMB: Add an option to show the desktop ui\n- METAL: Initial work-in-progress video driver for Metal. macOS-only right now, and currently requires macOS 10.13\n- METAL: Supports XMB/MaterialUI, has a menu display driver. Has a font rendering driver\n- METAL/SLANG: Slang shaders should be compatible with Metal video driver\n- NETWORK: Enable SSL/TLS support by default for desktop platforms\n- QNX: Fix Game Focus Toggle\n- PS3: Add audio mixer support for FLAC and MP3\n- PSP: Use proper button labels, fix inverted R-Stick Y axis\n- REMAPS: Fix the way offsets are calculated for keyboard remapping\n- RUNAHEAD: Fix full-screen mode change breaking Secondary Core's environment variables\n- VITA: Use proper button labels, fix inverted R-Stick Y axis\n- VITA: Add imc0: mount\n- VITA: Use sceCtrlIsMultiControllerSupported to detect\n- VULKAN: Fix two validation errors\n- VULKAN: Try to avoid creating swapchains redundantly. Should fix black screen and having to alt tab out of window again to get display working on Nvidia GPUs (Windows)\n- VULKAN/OSX: Initial MoltenVK support. Not enabled yet, several MoltenVK bugs should be fixed first before we can have it fully working\n- WINDOWS/DINPUT: Add rumble support\n- WINDOWS/DINPUT: Fix Game Focus Toggle\n- WINDOWS/RAWINPUT: Fix Game Focus Toggle\n- X11: Fix Game Focus Toggle\n- WII: Change deflicker setting to work in 480p or higher, and always enables vfilter so that the user can easily change brightness\n- WIIU: Fix out-of-bounds rendering bug\n- WIIU: Implement UDP broadcast network logging on Wii U\n- WIIU: Audio should no longer clip\n\n# 1.7.3\n- AUDIO: Audio mixer supports FLAC/MP3 file types now!\n- COMMON: Fixed bug 'crashing in cores that don't range check retro_set_controller_type'. Some people were having crashes when device is set to RETRO_DEVICE_NONE and the cores don't check the number of ports, in VBAM's case it was overflowing and crashing. QuickNES was crashing too\n- COMMON: Fixed buffer overflow in url encoding (affecting MSVC2010/2013)\n- COMMON: (QuickMenu) Added Configuration Override submenu\n- HID: Merge new HID subsystem\n- HID: Fix WaveBird support for the Wii U GCA\n- HID/OSX: Fix regression with IODHIDManager - gamepads which are connected later would not be autoconfigured\n- LOCALIZATION: Update Italian translation\n- LOCALIZATION: Update Japanese translation\n- LOCALIZATION: Update Portuguese translation\n- MENU: New WIMP Qt GUI!\n- MENU: Audio mixer now works in the menu without any cores loaded. You have to enable the setting 'Enable menu audio' for this to work\n- REMAPPING/OVERLAYS: Fix regression - overlays could no longer be remapped\n- SCANNER: Add Wii Backup File WBFS support\n- X11: CRT SwitchRes support for X11/Linux\n\n# 1.7.2\n- ANDROID/OPENSL: Prevent crashes when setting audio latency too low (buffer count can never be lower than 2 now)\n- CRT: Added CRT SwitchRes\n- COMMON: Hide the 'Core delete' option if the 'Core updater' is also hidden\n- COMMON: Add way to reset core association for playlist entry\n- COMMON: Fix invalid long command line options causing infinite loop on Windows\n- COMMON: Add OSD statistics for video/audio/core\n- COMMON: Added runahead system; allows you to drive down latency even further\n- COMMON: Fix buggy behavior that could happen with ZIP file reading on some platforms as a result of not initializing struct\n- CHEEVOS: Support Atari 2600, Virtual Boy, and Arcade (only Neo Geo, CPS-1, CPS-2 and CPS-3 and only with fbalpha core)\n- CHEEVOS: Add option to automatically take a screenshot when an achievement is triggered\n- CHEEVOS: Fixed incompatibilities with Neo Geo Pocket achievement sets\n- CHEEVOS: Store only login token, not password\n- D3D10: Added D3D10 driver to release build. Has working shaders (Slang), overlay, and menu display driver support. Should be on par capabilities wise\nwith D3D11 driver except for there being no hardware rendering right now\n- D3D11: Experimental hardware renderer. Allows for libretro cores to use D3D11 for hardware rendering. First core to use this is PPSSPP\n- D3D11: Increase backwards compatibility, shaders compile with Shader Model 4.0 now, added support for more feature levels\n- D3D10/D3D11/D3D12: Fix crashes with completely black or white thumbnail textures in XMB\n- GUI: Support disabling window decorations on Windows and Linux\n- LIBRETRO: Addition - Functions to enable and disable audio and video, and an environment function to query status of audio and video enables\n- LOCALIZATION: Update Italian translation\n- LOCALIZATION: Update Polish translation\n- MENU: Add Rewind/Latency/Overlay settings to Quick Menu, add options to show/hide them (User Interface -> Views -> Quick Menu)\n- MENU/RGUI: Only show Menu Linear Filter for RGUI and only show it for\nvideo drivers that implement it (D3D8/9/10/11/12/GL)\n- MENU/RGUI: Add User Interface -> Appearance options\n- MENU/RGUI: D3D8/D3D9: Hookup Menu Linear Filter\n- MENU/XMB: Disable XMB shadow icons by default for PowerPC and ARM for performance reasons\n- MENU/XMB: Left/right thumbnails are now automatically scaled according to layout\n- MENU/XMB: Add Left Thumbnails (additional to the right)\n- MENU/XMB: Fixed left/right tab regression\n- MENU/XMB: Fix scaling of tall images that were cut on bottom previously\n- MENU/XMB: Menu scale factor setting now changes texts length, image scaling and margins\n- MENU/XMB: Mouse cursor scales correctly now\n- MENU/XMB: Add toggle to show/hide Playlist tabs\n- MENU/XMB: Add menu layout - can switch between Desktop, Handheld and Auto\n- MENU/XMB: Don't load menu pipeline shaders unless XMB is selected (D3D10/D3D11/D3D12/GL/Vulkan)\n- MENU/VIDEO: Only show black frame insertion for the video drivers/context drivers\nthat support it (so far this includes - D3D8/D3D9, OpenGL, Vulkan)\n- MENU/VIDEO:  Only show max swapchain images if supported by video driver and/or context driver (so far this includes - DRM EGL context driver, VideoCore EGL context driver, Vulkan)\n- MENU/MaterialUI: Automatic DPI Scaling should be much improved now, now scales as expected at 1440p and 4K resolutions\n- MENU/MaterialUI: Fix wrong calculation of an entry height causing long playlists to end up outside of screen range. This also could cause crashes on low DPI screens\n- IOS: Fixed crash when opening downloaded roms from Safari or using the \"Open in..\" functionality. Added the compiler flag to support keyboard remapping to controls\n- IOS: Fixed buffer overlap that caused a crash while trying to download GLSL shaders from the buildbot\n- PS3: fix URLS\n- REMAPS: Mapping keyboard keys from more than one gamepad (works with dosbox)\n- REMAPS: Mapping more than one button to the same action\n- REMAPS: Unmapping buttons\n- REMAPS: Unmapping analogs\n- REMAPS: Mapping a button to trigger an analog response (tested with mupen, can run on SM64 with the d-pad now, triggers a full analog tilt)\n- REMAPS: Mapping an analog to another analog (having more than one analog mapped to the same output causes issues)\n- REMAPS: Mapping an analog to produce a button response\n- SCANNER: Should be able to scan dual-layer Wii disc images now, filestream code now supports files larger than 4GB\n- SHADERS/SLANG: Slang shaders should work again on Android version and MSVC versions (basically all the Griffin-based versions)\n- SHADERS: If GL context is GLES2/3/Core context, Cg shaders are unavailable. Applies to shader list too\n- SHADERS: Hide cg/glsl shaders from being able to be selected if D3D8/9/10/11/Vulkan video drivers are selected\n- SHADERS: Hide slang shaders from being able to be selected if D3D8/9/OpenGL video drivers are selected\n- SHADERS: Prevent crashes from occurring if we have the GL video driver in use and we try to skip to a slang shader through next/previous hotkeys\n- SHADERS: Fix shader parameter increase / decrease functions\n- SUBSYSTEM: handle savestates properly (cart1 + cart2.state0)\n- VULKAN/X11: Fix X11 Vulkan bug from Wayland driver\n- VULKAN: Fix multi-line text spacing in menus with Vulkan driver\n- WINDOWS XP: Add Cheevos support\n- WINDOWS/MSVC 2003/2005/2010/2013/2015/2017: Add Cheevos support\n- VITA: Bugfix for 'PS Vita takes many time to start to accept input' issue\n- X11: Allow compositor disabling on X11 fullscreen through _NET_WM_BYPASS_COMPOSITOR\n- X11: Prioritize _NET_WM_STATE_FULLSCREEN_ in true fullscreen mode\n- WIIU: Fix OOB read/write in keyboard driver\n\n# 1.7.1\n- 3DS: Now correctly reports amount of CPU cores\n- 3DS: Frontend rating is now correctly implemented for both New 3DS/2DS and Old 3DS/2DS\n- 3DS: Initial networking support, HTTP requests won't work yet\n- 3DS: Now reports memory and battery state\n- AUDIO: Added 'Audio Resampler Quality' setting to Audio Settings. Setting this higher will increase sound quality at the expense of sound latency and/or performance. Setting this value lower will improve sound latency/performance at the expense of sound quality. Only has an effect if the Sinc resampler is used, and you have to restart the game for changes to take effect\n- CHEEVOS: Fix unofficial achievements not being loaded\n- CHEEVOS: Show savestate menu entries when no achievements are found even if hardcore mode is enabled\n- CHEEVOS: Support Neo Geo Pocket\n- COMMON: Bugfix for issue related to 'Windows mouse pointer visible when running MESS or MAME cores'\n- COMMON: Fix bug 'Last item in a Playlist is ignored'\n- COMMON: New LED API. Driver implemented for Raspberry Pi, proof of concept implemented for core MAME 2003\n- COMMON: Add quick menu option to watch shader files for changes and recompile them automatically (Linux only for now)\n- D3D8: Direct3D 8 can now work on systems that have Direct3D 8 installed\n- D3D9: Add menu support for MaterialUI/XMB\n- D3D10: Initial video driver implementation\n- D3D11: Initial video driver implementation\n- D3D11: SPIRV-Cross/slang shader support for D3D11\n- D3D12: Initial video driver implementation\n- DINPUT: don't reinitialize input driver on network events / media insertion / network drive connection\n- INPUT: show friendly names when available under input binds and system information\n- INPUT: show the config name when available under system information\n- GUI: Allow changing menu font color\n- GUI: Menu visibility options for RGUI and MaterialUI\n- GUI/MaterialUI: Works now with D3D8, D3D9 Cg, D3D11 and D3D12 drivers\n- GUI/XMB: Add Monochrome Inverted icon theme\n- GUI/XMB: Allow changing menu scale to 200%\n- GUI/XMB: Works now with D3D8, D3D9 Cg, D3D11 and D3D12 drivers. Menu shader effects currently don't work on D3D8/D3D9 Cg\n- HAIKU: Restored port\n- KEYMAPPER: prevent a condition that caused input_menu_toggle to stop working when a RETRO_DEVICE_KEYBOARD type device is enabled\n- GL: ignore hard gpu sync when fast-forwarding\n- IOS10/11: Handle hardware keyboards and iCade controllers\n- LOCALIZATION: Update Italian translation\n- LOCALIZATION: Update Japanese translation\n- LOCALIZATION: Update Portuguese-Brazilian translation\n- LOCALIZATION: Update Spanish translation\n- NETPLAY: Add menu option to select different MITM (relay) server locations\n- OSX: Modify HID buttons detection algorithm\n- QB: Added --datarootdir, --sysconfdir, --bindir, --docdir and --mandir\n- QB: Deprecated --global-config-dir, --with-bin_dir and --with-man_dir\n- SHADERS: Allow saving of shader presets based on the parent directory (Saving one for */foo/bar/mario.sfc* would result in *shaders/presets/corename/bar.ext*). We decided it's safer to still isolate the presets to a single core because different cores may treat video output differently\n- SHADERS: Don't save the path to the current preset to the main config. This was causing weird behavior, instead it will try to load *currentconfig.ext* and it will save a preset with that name when select *apply shader preset*. The resulting shader will restore properly after restarting and even after core/parent/game specific presets are loaded\n- SOLARIS: Initial port\n- SWITCH: Initial Nintendo Switch port, based on libtransistor SDK\n- PS3: Enable Cheevos\n- PSP: Enable threading support through pthreads\n- SHADERS: SPIRV-Cross/slang shader support for D3D11\n- SHIELD ATV: Allow the remote / gamepad takeover hack to work with the 2017 gamepad\n- SUBSYSTEM: Subsystem saves now respect the save directory\n- SUBSYSTEM: You can now load subsystem games from the menu (see https://github.com/libretro/RetroArch/pull/6282 for caveats)\n- VULKAN: Fix swapchain recreation bug on Nvidia GPUs with Windows 10 (resolved in Windows Nvidia driver version 390.77)\n- WINDOWS: Improved Unicode support (for cores/directory creation and 7zip archives)\n- WINDOWS: Show progress meter on taskbar for downloads (Windows 7 and up)\n- WINDOWS: WS_EX_LAYERED drastically decreases performance, so only set it when needed (transparency in windowed mode)\n- WIIU: Overlay support\n- WIIU: Transparency support in menu + overlays\n- WIIU: Increased stability during core switching\n- WIIU: Shader support\n- WIIU: Menu shader effects added (shaders)\n- WIIU: Add missing time/clock support. (also fixes RTC [Real Time Clock] in Gambatte)\n- XBOX OG: Restored port\n\n# 1.7.0\n- CHEEVOS: Add badges for achievements, shows thumbnail images of achievements\n- CHEEVOS: Leaderboard support\n- CHEEVOS: Only disable savestates on hardcore mode if achievements are not available\n- COMMANDLINE: Fix fullscreen toggle switch\n- COMMON: Add 'Automatically Load Content To Playlist' feature, enabled by default\n- COMMON: Fix slowmotion ratio always being reset back to 1\n- COMMON: Optimized NBIO implementations now for Apple, Windows, and Linux. Uses mmap for Linux/Windows/BSD if/when available. File I/O should now be much faster for loading images inside the menu\n- COMMON: Native Blissbox support now for latest firmware as of writing (2.0). Implementation through libusb and/or native Windows HID\n- COMMON: New lightgun API\n- COMMON: New VFS (Virtual File System) API\n- COMMON: Fixed some playlist bugs\n- COMMON: New snow shader\n- COMMON: Fix Quick Menu title, no longer shows 'Select File'\n- COMMON: Fix loading cores that require no content one after another\n- COMMON: Map Delete key to Y button for non-unified menu keyboard controls\n- COMMON: Fix for relative paths being normalised and generating a duplicate history entry\n- EMSCRIPTEN: Fix references to browserfs\n- FREEBSD: Support libusb HID input driver\n- HAIKU: Buildfix\n- INPUT: Map clear button to DEL key\n- LINUX/X11: Add RetroArch logo to window title bar\n- LINUX/X11: Input driver now supports new lightgun code\n- LINUX/X11: Support window transparency (requires a compositing window manager)\n- LOBBIES: Fix for crash on join netplay rooms via touch / glui\n- LOCALIZATION: Update Italian translation\n- LOCALIZATION: Update Japanese translation\n- LOCALIZATION: Update Portuguese-Brazilian translation\n- LOCALIZATION: Update Polish translation\n- LOCALIZATION: Update Russian translation\n- MENU: Snowflake menu shader effect\n- OSX/PPC: Fix the GL2 renderchain, had to use EXT versions of framebuffer/renderbuffer functions\n- PS3: HTTP requests / downloads should now work\n- PS3: Core Updater now works\n- PS3: Improved font rendering, enable STB Unicode font renderer\n- PSP: Make it work with Vita's Adrenaline\n- PSP: Fix audio sync\n- PSP: Fix content loading, port should be functional again\n- PSP: Use 64MB when available\n- SCANNER: Fix crash from Windows-incompatible format string\n- VITA: Improve packaging, installation times\n- WIIU: Disabled the controller patcher for now since it was the source of many stability issues\n- VULKAN: Various stability fixes for WSI\n- WINDOWS: Add MSVC 2017 solution\n- WINDOWS: Get rid of the empty console window in MSVC 2010 builds\n- WINDOWS: Raw input driver now supports new lightgun code\n- WINDOWS: Use configured OSD/text message color on GDI driver\n- WINDOWS/XINPUT: Populate XInput VID/PID from DInput so autoconfig doesn't rely solely on joypad names\n- WINDOWS/XINPUT: Fix crash that occurs in some situations with Steam running and a Steam Controller plugged in\n- WINDOWS: Improve version reporting under System Information\n- WINDOWS: Support window transparency\n- WINDOWS: Correct usage of GetWindowPlacement per MS docs, fixes game window position on Win95/98\n- WINDOWS: Added Visual Studio 2017 support\n\n# 1.6.9\n- COMMON: Small memory leak\n- NETPLAY: Fix network command only working once\n\n# 1.6.8\n- Audio: Fix the Audio DSP picker\n- CHEEVOS: Add support for Atari Lynx cheevos\n- CHEEVOS: Add support for RetroAchievements Leaderboards\n- GUI: (MaterialUI) Fix crash that happened on context reset with Vulkan\n- GUI: (MaterialUI) Skip querying and drawing items that are not visible; Cache content height and bbox calculation\n- GUI: (MaterialUI) Fix entry box highlight calculation\n- GUI: (XMB) Skip drawing the fading list when it is already transparent. Optimization\n- GUI: (XMB) Comment out visible item calculation in xmb_draw_items()\n- GUI: (RGUI) Prevent crashes when using a non-English language reliant on UTF8\n- GUI: Add menu option for OSD background color\n- GUI: Add menu option for OSD text color\n- GUI: Add menu option to remove frame count from OSD\n- GUI: Allow wraparound of int/float settings when pressing the left key\n- INPUT/LIBRETRO: Add support for more mouse buttons (buttons 4/5)\n- INPUT/LIBRETRO: Add support for analog buttons\n- INPUT: Always show the controls menu even if descriptors are not set\n- INPUT: Fix input descriptors not being set on cores that don't implement the controllers interface\n- INPUT: Apply descriptors only for the amount of cores the core supports\n- INPUT: Implement keyboard to gamepad input remapping (limited to one gamepad device for now)\n- INPUT: Fix absolute mouse move handling on the winraw driver\n- INPUT: Ignore keyboard input if window is not active on udev driver\n- INPUT: Sanitize the filenames of autoconfig profiles before saving\n- LOBBIES: Fix crash on navigating left / right from the lobby menu\n- LOCALIZATION: Update Dutch translation\n- LOCALIZATION: Update Italian translation\n- LOCALIZATION: Update Japanese translation\n- LOCALIZATION: Update Portuguese-Brazilian translation\n- LOCALIZATION: Update Russian translation\n- LINUX/ARMHF: Set buildbot updater URL to armhf location instead of blank string\n- LINUX/PI: Broadcom VC4: Add Videocore config option\n- LINUX/UDEV: Fix - RetroArch reads keyboard input when not focused with the udev input driver\n- NETPLAY: Fix disconnection not fully deinitializing Netplay\n- NETPLAY: Fix lan rooms when there is more than one room\n- NETPLAY: Fix lan rooms on systems where all addresses are treated as IPv6\n- COMMON: Fix clear/free loop conditionals in playlists\n- WINDOWS/GDI: Fix flickering of text\n- WINDOWS/GDI: Fix graphics corruption on Windows 98\n- WINDOWS/GDI: Allow compiling without DirectInput8 for NT support\n- WINDOWS/WGL: Try to use wglSwapLayerBuffers instead of SwapBuffers if possible (for more optimal performance)\n- WINDOWS: Fix menubar text corruption on Japanese locale systems\n- WINDOWS: Support Unicode file I/O (can now display CJK characters in file browser for example)\n- WINDOWS: Support Windows 95, NT3.51, NT4\n- WINDOWS: add Makefile.griffin targets for msvc6,2003,2005,2010,2012,2013\n- WII: Use custom, embedded libogc SDK\n- WIIU: Initial touchscreen support for WiiU gamepad\n- WIIU: Add Cheevos support\n- SCANNER: Fix archive scanning\n- SCANNER: Support CHD files\n- SCANNER: Support Gamecube ISO scanning\n- SCANNER: Use primary data track of disc images for CRC lookups rather than cue files.  This is slower but finds matches more reliably, and is necessary for CHD files to work at all.  Update your databases!\n- SCANNER: Fall back on looking inside archives when matching MAME/FBA content (most recent cores only).  If you had difficulty with content being detected before, you may have better luck now.  Update your databases and core info!\n\n# 1.6.7\n- SCANNER: Fix directory scanning\n- SCANNER: Fix file scanning\n- COMMON: Fix 'Disk Image Append' option\n- FREEBSD: Compatibility fixes for Video4Linux2 camera driver\n- GUI: (MaterialUI) Add disk image append icons\n- GUI: (MaterialUI) Improve word wrapping when menu icons are enabled\n- GUI: (MaterialUI) Add User Interface -> Appearance -> Menu Icons Enable. You can turn on/off the icons on the lefthand side of the menu entries\n- GUI: Performance optimizations for XMB menu driver - only calculates visible items\n- LOCALIZATION: Update Italian translation\n\n# 1.6.6\n- 3DS: Fixes serious performance regression that affected every core; rewind was always implicitly enabled\n- AUDIO: MOD/S3M/XM sound should now be properly mixed in with the core's sound\n- GUI: Visual makeover of MaterialUI\n- GUI: Added 'Music', 'Images' and 'Video' collection options to RGUI/MaterialUI\n- GUI: Allow the user to add 'Favorites'\n- GUI: Allow the user to rename entries\n- GUI: Performance optimizations for XMB menu driver\n- LOCALIZATION: Update Italian translation\n- INPUT: Overlay controller response - when we press buttons on the gamepad or keyboard, the corresponding buttons on the overlay will be highlighted as well\n- NETBSD: Silence some compilation warnings\n- COMMON: Fixed bug 'Deleting an entry from a playlist would not update the list view inside XMB'\n- COMMON: Fix inet_ntop_compat on Unix\n- LOBBY: Add skeleton to add help descriptions to lobbies\n\n# 1.6.5\nSkipped this one\n\n# 1.6.4\n\n- ANDROID: Fire Stick & Fire TV remote overrides gamepad port 0 on button press and viceversa like SHIELD devices\n- ANDROID: Provide default save / system / state / screenshot locations\n- AUDIO: Audio mixer supports MOD/S3M/XM file types now!\n- INPUT: input swap override flag (for remotes) is cleared correctly\n- INPUT: allow specifying libretro device in remap files\n- INPUT: allow specifying analog dpad mode in remap files\n- INPUT: allow saving libretro device to remap files\n- INPUT: allow saving analog dpad mode to remap files\n- INPUT: allow removing core and game remap files from the menu\n- COMMON: Cores can now request to set a 'shared context'. You no longer need to explicitly enable 'Shared Hardware Context' for Citra/OpenLara/Dolphin\n- COMMON: Add 'Delete Core' option to Core Information menu\n- COMMON: Allow Max Timing Skew to be set to 0\n- COMMON: Change the \"content dir\" behavior so it works on either a flag or an empty directory setting, now platform drivers can provide defaults for save / system / state / screenshot dirs and still allow the content dir functionality, these settings are under settings / saving and flagged as advanced\n- GUI: You can turn on/off 'Horizontal Animation' now for the XMB menu. Turning animations off can result in a performance boost\n- GUI: Fix sublabel word-wrapping in XMB where multi-byte languages were cut off too soon\n- LOCALIZATION: Update Dutch translation\n- LOCALIZATION: Update Traditional Chinese translation\n- LOCALIZATION: Update Italian translation\n- LOCALIZATION: Update Russian translation\n- WINDOWS: Provide default save / system / state / screenshot locations\n- LOBBIES: Show what country the host is in\n- MENU: Enable OSD text rendering for gdi and libcaca drivers\n- WINDOWS 98/ME/2K: Set default directory for MSVC 2005 RetroArch version\n- WII: Better V-Sync handling, backported from SuperrSonic\n- WIIU: Exception handler rewritten\n\n# 1.6.3\n- IOS: Fix GL regression - 32bit color format cores were no longer rendering\n- CHEEVOS: Add support for N64 cheevos and other small fixes\n- CHEEVOS: Add 'Achievements -> Achievements Verbose Mode'. Ability to display cheevos related messages in OSD, useful for RetroAchievements users\n- AUDIO: Audio mixer's volume can now be independently increased/decreased, and muted\n- AUDIO: Mute now no longer disables/enables audio but instead properly mutes the audio volume. Mute is also independent from the audio mixer volume\n- INPUT: Add mouse index selection; ability now to select between different mice\n- INPUT: Fix 'All Users Control Menu' setting\n- LINUX: Add a tinyalsa audio driver. Doesn't require asoundlib, should be self-contained and lower-level\n- LOBBIES: Announce the RetroArch version too\n- LOCALIZATION: Add Traditional Chinese translation\n- LOCALIZATION: Update French translation\n- LOCALIZATION: Update Italian translation\n- LOCALIZATION: Update Japanese translation\n- LOCALIZATION: Update Russian translation\n- MENU: Add 'User Interface -> Views'. Ability to display/hide online updater and core updater options\n- NETPLAY: Disconnecting one client shouldn't cause everyone to disconnect anymore\n- NETWORK: SSL/TLS support, disabled by default\n- SCANNER: Fix PS1 game scanning\n- SCANNER: Move content list builder into scanner task with progress, fixes menu freeze with large playlists\n- SDL2: Fix 'SDL2 driver does not see the hat on wired Xbox 360 controller\"\n- SETTINGS: Fix regression 'Custom Viewport is no longer overridable per-core or per-game'\n- VITA: Add cheevos support\n- VITA: Add support for external USB if mounted\n- WAYLAND: Fix menu mouse input\n- WII: Add support for single-port 'PS1/PS2 to USB controller adapter\n\n# 1.6.0\n- ANDROID: Allow remotes to retain OK/Cancel position when menu_swap_ok_cancel is enabled\n- ANDROID: Improve autoconf fallback\n- ANDROID: Improve shield portable/gamepad device grouping workaround\n- ANDROID: Runtime permission checking\n- AUDIO: Audio mixer support. Mix up to 8 streams with the game's audio\n- AUTOSAVE/SRAM - Fix bug #3829 / #4820 (https://github.com/libretro/RetroArch/issues/3829)\n- ENDIANNESS: Fixed database scanning. Should fix scanning on PS3/WiiU/Wii, etc\n- LOBBIES: Fallback to filename based matching if no CRC matches are found (for people making playlists by hand)\n- LOBBIES: GUI refinement, show stop hosting when a host has been started, show disconnect when playing as client\n- LOBBIES: if the game is already loaded it will try to connect directly instead of re-loading content (non-fullpath cores only)\n- LOBBIES: unify both netplay menus\n- LOCALIZATION/GUI: Korean font should display properly now with XMB/MaterialUI's default font\n- LOCALIZATION: Update German translation\n- LOCALIZATION: Update Japanese translation\n- LOCALIZATION: Update Russian translation\n- LOCALIZATION: Update/finish French translation\n- MENU: Improved rendering for XMB ribbon; using additive blending (Vulkan/GL)\n- MISC: Various frontend optimizations\n- NET: Fix bug #4703 (https://github.com/libretro/RetroArch/issues/4703)\n- OSX/MACOS: Fixes serious memory leak\n- THUMBNAILS: Thumbnails show up now in Load Content -> Collection, Information -> Database\n- VIDEO: Fix threaded video regression; tickering of menu entries would no longer work\n- VITA: Fix 30fps menu (poke into input now instead of reading the entire input buffer which apparently is slow)\n- VITA: Fix frame throttle\n- VITA: Fix slow I/O\n- VULKAN: Fix some crashes on loading some thumbnails\n- VULKAN: Unicode font rendering support. Should fix bad character encoding for French characters, etc\n- WII: Fix crashing issues which could occur with the dummy core\n- WIIU: HID Controller support\n- WIIU: Initial network/netplay support\n- WIIU: XMB/MaterialUI menu driver support\n- WINDOWS: Added RawInput input driver for low-latency, low-level input\n- WINDOWS: Added WASAPI audio driver for low-latency audio. Both shared and exclusive mode\n- WINDOWS: Core mouse input should be relative again in cores\n\n# 1.5.0\n- ANDROID: Autoconf fallback\n- ANDROID: Mouse support / Emulated mouse support\n- AUTOCONF: Fix partial matches for pad name\n- CHEEVOS: Fix crashes in the cheevos description menu\n- CHEEVOS: WIP leaderboards support\n- COMMON: 9-slice texture drawing support\n- COMMON: Threading fixes\n- CORETEXT/APPLE: Ability to load menu display font drivers and loading of custom font\n- DOS: Add keyboard driver\n- DOS: Improve color accuracy and scaling\n- GUI: Add a symbol page in the OSK\n- GUI: Allow changing icon theme on the fly\n- GUI: Better dialogs for XMB\n- GUI: Various settings are now only visible when advanced settings is enabled\n- LOCALIZATION: Add/update Korean translation\n- LOCALIZATION: Rewrite German translation\n- LOCALIZATION: Update several English sublabels\n- LOCALIZATION: Update several Japanese labels\n- MOBILE: Long-tap a setting to reset to default\n- MOBILE: Single-tap for menu entry selection\n- NET: Allow manual netplay content loading\n- NET: Announcing network games to the public lobby is optional now\n- NET: Bake in miniupnpc\n- NET: Fix netplay join for contentless cores\n- NET: Fix netplay rooms being pushed on the wrong tab\n- NET: Lan games show next to lobbies with (lan) and connect via the private IP address\n- NET: Use new lobby system with MITM support\n- NUKLEAR: Update to current version\n- SCANNER: Always add 7z & zip to supported extensions\n- VULKAN: Add snow/bokeh shader pipeline effects - at parity with GL now\n- VULKAN: Find supported composite alpha in swapchain\n- WIIU: Keyboard support\n- WINDOWS: Fix loading of core/content via file menu\n- WINDOWS: Logging to file no longer spawns an empty window\n\n# 1.4.1\n\n\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 5.4775390625,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, caste, color, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at:\n\n * Via E-Mail to <libretro@gmail.com>, please include in the subject line\n   `RETROARCH COC` so that your e-mail may reach the correct party.\n\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.1, available at\n[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].\n\nCommunity Impact Guidelines were inspired by\n[Mozilla's code of conduct enforcement ladder][Mozilla CoC].\n\nFor answers to common questions about this code of conduct, see the FAQ at\n[https://www.contributor-covenant.org/faq][FAQ]. Translations are available\nat [https://www.contributor-covenant.org/translations][translations].\n\n[homepage]: https://www.contributor-covenant.org\n[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html\n[Mozilla CoC]: https://github.com/mozilla/diversity\n[FAQ]: https://www.contributor-covenant.org/faq\n[translations]: https://www.contributor-covenant.org/translations\n"
        },
        {
          "name": "CODING-GUIDELINES",
          "type": "blob",
          "size": 4.21875,
          "content": "Refer also to this page for more information -\nhttps://docs.libretro.com/development/coding-standards/\n\nStruct ordering\n---------------\n\nFor POD-types, try to order structs as follows (first to last):\n\n   * long double     (8 bytes, 16 bytes [64bit x86], 12 bytes [32bit x86])\n   * double          (8 bytes)\n   * int64_t         (8 bytes,         8 bytes [32bit ARM],\n                      4 bytes [32bit x86])\n   * uint64_t        (4 bytes [32bit], 8 bytes [32bit ARM], 8 bytes [64bit])\n   * pointer         (4 bytes [32bit], 8 bytes [64bit] [1])\n   * intptr_t        (4 bytes [32bit], 8 bytes [64bit] [1])\n   * uintptr_t       (4 bytes [32bit], 8 bytes [64bit] [1])\n   * ptrdiff_t       (4 bytes [32bit], 8 bytes [64bit] [1])\n   * ssize_t         (4 bytes [32bit], 8 bytes [64bit])\n   * size_t          (4 bytes [32bit], 8 bytes [64bit])\n   * jmp_buf         (4 bytes)\n   * long            (4 bytes [64bit Win], 8 bytes [64bit non-Win],\n                      4 bytes [32bit])\n   * int32_t         (4 bytes)\n   * unsigned        (4 bytes)\n   * float           (4 bytes)\n   * int             (4 bytes)\n   * enum            (4 bytes)\n   * int16_t         (2 bytes)\n   * char            (1 byte)\n   * bool            (1 byte)\n\n   [1] PS3 uses 4 byte pointers despite having a 64bit processor\n\n   Struct members should be sorted by alignment. Therefore, structs\n   should be sorted by the largest type inside them.\n\n   For example, take a struct like this:\n\n   typedef struct\n   {\n      size_t capacity;\n      bool old_format;\n      bool compress;\n      bool fuzzy_archive_match;\n      bool autofix_paths;\n      char path[PATH_MAX_LENGTH];\n      char base_content_directory[DIR_MAX_LENGTH];\n   } playlist_config_t;\n\nsize_t has the biggest alignment here, so 'struct playlist_config_t'\ninside a struct should come before or after size_t.\n\n*** BEST PRACTICES ***\n\n* If we have pointers and size variable pairs, it's best to\ninterleave them to increase the probability they go in the\nsame cacheline. It also makes the code more readable, that\nthese two variables are connected.\n\nExample:\n\n   struct a\n   {\n      char* b;\n      size_t b_len;\n      char* c;\n      size_t c_len;\n   };\n\nStack size\n----------\n\nYou have to assume that stack size is going to be limited in\nRetroArch. Some game consoles (and other embedded systems)\nmight have a default stack size as low as 128Kb or less.\nBe conservative with stack size but don't try to put very\nsmall structs on heap either [to avoid memory fragmentation\namong other things]. A balancing act here is necessary.\n\nBe mindful that heap allocations are slow compared to stack.\n\nFunctions\n---------\n- Avoid doing small getter/setter functions. We want a function\nto justify its function call overhead by doing a significant\nbody of work. Small one-line getter/setter functions for what\nis predominantly C-style structs is not useful, plus it leads\nto people thinking this function is more complex than it\nactually is, thus obfuscating the sourcecode instead of it\nbeing easier to read.\n\nIf you can find examples in the codebase that violate this\nguideline, do not hesitate to point them out to us.\n\nVariable declaration\n--------------------\nFor C source files, we have to insist you stick to the following:\n\n- Declare variables either at the start of a function or the start\n   of a code block, depending on the scope they need.\n- Do not do initial for loop declarations. Refer to the bulletpoint above:\n   either declare them at the start of the function, or at the start\n   of the code block.\n\nNot doing this would break compilation on platforms where we are compiling\nthese C source files in C89 compatibility mode. If such issues occur in pull\nrequests, we have to request that it be fixed.\n\nVLA (Variable Length Array)\n---------------------------\nDo not use VLAs (Variable Length Array) in C source files. These are not\nC89-compliant.\n\nMiscellaneous\n-------------\n- Brace usage follows \"Allman style\". The brace associated with a control statement is placed on the following line,\n  indented to the same level as the control statement.\n  Statements within the braces are indented to the next level.\n- A single statement block must not include brackets (unless the block uses a macro that expands into multiple lines)\n- If possible, avoid 'while (true)' and use 'for (;;)' instead\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 5.931640625,
          "content": "# Contributing to RetroArch\n\nIf you are a developer who wishes to contribute to the development of _RetroArch_; or if you have\nfound a bug and wish to submit a minor patch and/or bug report, please read this document.\n\nActive discussions happen on our [Discord](https://discordapp.com/invite/27Xxm2h), mostly within\nthe _Programming_ channel category. We value discussions that happen in real time around\nthese contributions.\n\nPlease do note that contributors to _RetroArch_ do such contributions within their spare time.\nWe do prefer to keep a professional and non-aggressive atmosphere around the project, along\nwith any disagreements to be settled professionally without insults, name calling, or otherwise.\nIf there are any issues, we are willing to have discussions about it.\n\n## Submitting Bug Reports\n\nBug reports for _RetroArch_ may fall into a few categories:\n\n * _RetroArch_ itself, the user interface and API around all of the various cores.\n * Individual _Core_, that interacts with _RetroArch_.\n * Supplementary data provided within _RetroArch_, such as controller autoconfigs, databases,\n   thumbnails...\n * The [documentation set](https://docs.libretro.com/)\n\nWhen submitting a bug report, ensure that the report is submitted to the correct repository.\n * For _RetroArch_ itself, submit an issue to the [RetroArch](https://github.com/libretro/RetroArch)\n   repository. Please read and fill the issue template.\n * For other cores, please use the search function within the [libretro Organization](https://github.com/libretro)\n   on GitHub. Issues that are specific to a core and not _RetroArch_ are likely to be closed\n   very quickly. If an issue is suspected with _RetroArch_, please make sure to test with\n    multiple cores to be sure that is is not isolated.\n * For database content, submit an issue to\n   [libretro-database repo](https://github.com/libretro/libretro-database) or ask in the\n   _database_ channel on Discord.\n * For controller autoconfigs, submit an issue to\n   [retroarch-joypad-autoconfig repo](https://github.com/libretro/retroarch-joypad-autoconfig)\n * For actual thumbnail images, submit an issue to\n   [libretro-thumbnails](https://github.com/libretro-thumbnails/libretro-thumbnails) repo\n   or ask in the _database_ channel on Discord.\n * For documentation, submit an issue to [libretro-docs](https://github.com/libretro/libretro-docs)\n   repo or ask in the _documentation_ channel.\n * For translations, please see [here](https://docs.libretro.com/development/retroarch/new-translations-crowdin/).\n\nIf the issue occurs during runtime, please paste the verbose log output:\n\n * If using the main interface, enable verbose logging with _Settings_ -> _Logging_ ->\n   _Logging Verbosity_. Ensure both _Log to File_ and _Timestamp log Files_ is enabled.\n   Set frontend log level to _0 (Debug)_.\n * Or run _RetroArch_ with the verbose (`-v`) flag and get the log from the console.\n\nIf the error happens during compilation and/or building, paste the output of `./configure`\nand `make` accordingly. If using an IDE, please paste any of the errors and log output.\n\n## Submitting Pull Requests\n\nAny and all contributions should be submitted through Pull Requests on\n[GitHub](https://github.com/libretro/RetroArch/pulls). The process requires that you fork the\nrepository, make the appropriate changes, and then open a pull request on _GitHub_. If your\npull request is for a proof-of-concept then please indicate as such.\n\nYour pull request will then be reviewed. There may be comments and requests for additional\nchanges to be made. It may also be possible that the changes will not be accepted. Otherwise, it\nmay be merged in when it is fully approved. The final approval of merge requests is at the\ndiscretion of the project.\n\nIf you want to develop a larger feature or make broad changes, please do join our\n[Discord](https://discordapp.com/invite/27Xxm2h) server to discuss. The discussion is\nnecessary to prevent the possibility of major work being done which will not be accepted at all.\n\n## libretro API\n\nIf you wish to contribute additional functionality to _libretro_'s API, there are considerations\nthat must be accepted. Please note that because this API affects multiple different projects, we\nhighly value and require API and ABI stability and backwards-compatibility. Due to this\nrequirement, there will be additional scrutiny in reviews for this added functionality.\n\nAny and all features will be added only when **necessary** for an existing _libretro_ core to\nproperly function. Hypothetical implementations of _libretro_ are not considered.\n\n## Coding style\n\nWe highly value a consistent code style throughout the entire code base, please make sure you look\nthrough the existing code to get a feel for the coding style. When submitting a pull request, it may\nbe asked to fix any coding style issues before submission. In other cases, there may be a follow-up\npull request making the code style consistent.\n\nFor full guidelines please see the [Coding Standards](https://docs.libretro.com/development/coding-standards/).\n\nSome non-obvious things to be aware of:\n\n  - Code should be both C89 and ISO C++ compatible. This is a requirement for XBox 360 and MSVC to\n    properly build. Think of it as a C++ compatible subset of C99.\n  - There must be no warnings in your code (enabled by `-Wall` for GCC compilers), do also note that\n    different compilers may produce different warnings.\n  - Avoid using deprecated APIs, these will be removed in the future at some point.\n\n## Copyright Headers and AUTHORS\n\nIf you have contributed a chunk of source code that is written to you, you should add yourself to\nthe copyright header in the file. If you have made a significant contribution you should add\nyourself to the `AUTHORS` file, adding your full name, e-mail, and the feature you worked on.\n\n## Commit Access\n\nContributors who show a good track record of pull requests over time may eventually\nget commit access to the repository. This may happen when looking through pull requests\nover long amounts of time becomes a burden.\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 34.3232421875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n"
        },
        {
          "name": "Doxyfile",
          "type": "blob",
          "size": 112.8583984375,
          "content": "# Doxyfile 1.9.1\n\n# This file describes the settings to be used by the documentation system\n# doxygen (www.doxygen.org) for a project.\n#\n# All text after a double hash (##) is considered a comment and is placed in\n# front of the TAG it is preceding.\n#\n# All text after a single hash (#) is considered a comment and will be ignored.\n# The format is:\n# TAG = value [value, ...]\n# For lists, items can also be appended using:\n# TAG += value [value, ...]\n# Values that contain spaces should be placed between quotes (\\\" \\\").\n\n#---------------------------------------------------------------------------\n# Project related configuration options\n#---------------------------------------------------------------------------\n\n# This tag specifies the encoding used for all characters in the configuration\n# file that follow. The default is UTF-8 which is also the encoding used for all\n# text before the first occurrence of this tag. Doxygen uses libiconv (or the\n# iconv built into libc) for the transcoding. See\n# https://www.gnu.org/software/libiconv/ for the list of possible encodings.\n# The default value is: UTF-8.\n\nDOXYFILE_ENCODING      = UTF-8\n\n# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by\n# double-quotes, unless you are using Doxywizard) that should identify the\n# project for which the documentation is generated. This name is used in the\n# title of most generated pages and in a few other places.\n# The default value is: My Project.\n\nPROJECT_NAME           = RetroArch\n\n# The PROJECT_NUMBER tag can be used to enter a project or revision number. This\n# could be handy for archiving the generated documentation or if some version\n# control system is used.\n\nPROJECT_NUMBER         =\n\n# Using the PROJECT_BRIEF tag one can provide an optional one line description\n# for a project that appears at the top of each page and should give viewer a\n# quick idea about the purpose of the project. Keep the description short.\n\nPROJECT_BRIEF          =\n\n# With the PROJECT_LOGO tag one can specify a logo or an icon that is included\n# in the documentation. The maximum height of the logo should not exceed 55\n# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy\n# the logo to the output directory.\n\nPROJECT_LOGO           =\n\n# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path\n# into which the generated documentation will be written. If a relative path is\n# entered, it will be relative to the location where doxygen was started. If\n# left blank the current directory will be used.\n\nOUTPUT_DIRECTORY       = docs\n\n# If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-\n# directories (in 2 levels) under the output directory of each output format and\n# will distribute the generated files over these directories. Enabling this\n# option can be useful when feeding doxygen a huge amount of source files, where\n# putting all generated files in the same directory would otherwise causes\n# performance problems for the file system.\n# The default value is: NO.\n\nCREATE_SUBDIRS         = NO\n\n# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII\n# characters to appear in the names of generated files. If set to NO, non-ASCII\n# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode\n# U+3044.\n# The default value is: NO.\n\nALLOW_UNICODE_NAMES    = NO\n\n# The OUTPUT_LANGUAGE tag is used to specify the language in which all\n# documentation generated by doxygen is written. Doxygen will use this\n# information to generate all constant output in the proper language.\n# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,\n# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),\n# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,\n# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),\n# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,\n# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,\n# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,\n# Ukrainian and Vietnamese.\n# The default value is: English.\n\nOUTPUT_LANGUAGE        = English\n\n# The OUTPUT_TEXT_DIRECTION tag is used to specify the direction in which all\n# documentation generated by doxygen is written. Doxygen will use this\n# information to generate all generated output in the proper direction.\n# Possible values are: None, LTR, RTL and Context.\n# The default value is: None.\n\nOUTPUT_TEXT_DIRECTION  = None\n\n# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member\n# descriptions after the members that are listed in the file and class\n# documentation (similar to Javadoc). Set to NO to disable this.\n# The default value is: YES.\n\nBRIEF_MEMBER_DESC      = YES\n\n# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief\n# description of a member or function before the detailed description\n#\n# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the\n# brief descriptions will be completely suppressed.\n# The default value is: YES.\n\nREPEAT_BRIEF           = YES\n\n# This tag implements a quasi-intelligent brief description abbreviator that is\n# used to form the text in various listings. Each string in this list, if found\n# as the leading text of the brief description, will be stripped from the text\n# and the result, after processing the whole list, is used as the annotated\n# text. Otherwise, the brief description is used as-is. If left blank, the\n# following values are used ($name is automatically replaced with the name of\n# the entity):The $name class, The $name widget, The $name file, is, provides,\n# specifies, contains, represents, a, an and the.\n\nABBREVIATE_BRIEF       = \"The $name class\" \\\n                         \"The $name widget\" \\\n                         \"The $name file\" \\\n                         is \\\n                         provides \\\n                         specifies \\\n                         contains \\\n                         represents \\\n                         a \\\n                         an \\\n                         the\n\n# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then\n# doxygen will generate a detailed section even if there is only a brief\n# description.\n# The default value is: NO.\n\nALWAYS_DETAILED_SEC    = NO\n\n# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all\n# inherited members of a class in the documentation of that class as if those\n# members were ordinary class members. Constructors, destructors and assignment\n# operators of the base classes will not be shown.\n# The default value is: NO.\n\nINLINE_INHERITED_MEMB  = NO\n\n# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path\n# before files name in the file list and in the header files. If set to NO the\n# shortest path that makes the file name unique will be used\n# The default value is: YES.\n\nFULL_PATH_NAMES        = YES\n\n# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.\n# Stripping is only done if one of the specified strings matches the left-hand\n# part of the path. The tag can be used to show relative paths in the file list.\n# If left blank the directory from which doxygen is run is used as the path to\n# strip.\n#\n# Note that you can specify absolute paths here, but also relative paths, which\n# will be relative from the directory where doxygen is started.\n# This tag requires that the tag FULL_PATH_NAMES is set to YES.\n\nSTRIP_FROM_PATH        =\n\n# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the\n# path mentioned in the documentation of a class, which tells the reader which\n# header file to include in order to use a class. If left blank only the name of\n# the header file containing the class definition is used. Otherwise one should\n# specify the list of include paths that are normally passed to the compiler\n# using the -I flag.\n\nSTRIP_FROM_INC_PATH    =\n\n# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but\n# less readable) file names. This can be useful is your file systems doesn't\n# support long names like on DOS, Mac, or CD-ROM.\n# The default value is: NO.\n\nSHORT_NAMES            = YES\n\n# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the\n# first line (until the first dot) of a Javadoc-style comment as the brief\n# description. If set to NO, the Javadoc-style will behave just like regular Qt-\n# style comments (thus requiring an explicit @brief command for a brief\n# description.)\n# The default value is: NO.\n\nJAVADOC_AUTOBRIEF      = YES\n\n# If the JAVADOC_BANNER tag is set to YES then doxygen will interpret a line\n# such as\n# /***************\n# as being the beginning of a Javadoc-style comment \"banner\". If set to NO, the\n# Javadoc-style will behave just like regular comments and it will not be\n# interpreted by doxygen.\n# The default value is: NO.\n\nJAVADOC_BANNER         = NO\n\n# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first\n# line (until the first dot) of a Qt-style comment as the brief description. If\n# set to NO, the Qt-style will behave just like regular Qt-style comments (thus\n# requiring an explicit \\brief command for a brief description.)\n# The default value is: NO.\n\nQT_AUTOBRIEF           = NO\n\n# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a\n# multi-line C++ special comment block (i.e. a block of //! or /// comments) as\n# a brief description. This used to be the default behavior. The new default is\n# to treat a multi-line C++ comment block as a detailed description. Set this\n# tag to YES if you prefer the old behavior instead.\n#\n# Note that setting this tag to YES also means that rational rose comments are\n# not recognized any more.\n# The default value is: NO.\n\nMULTILINE_CPP_IS_BRIEF = NO\n\n# By default Python docstrings are displayed as preformatted text and doxygen's\n# special commands cannot be used. By setting PYTHON_DOCSTRING to NO the\n# doxygen's special commands can be used and the contents of the docstring\n# documentation blocks is shown as doxygen documentation.\n# The default value is: YES.\n\nPYTHON_DOCSTRING       = YES\n\n# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the\n# documentation from any documented member that it re-implements.\n# The default value is: YES.\n\nINHERIT_DOCS           = YES\n\n# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new\n# page for each member. If set to NO, the documentation of a member will be part\n# of the file/class/namespace that contains it.\n# The default value is: NO.\n\nSEPARATE_MEMBER_PAGES  = NO\n\n# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen\n# uses this value to replace tabs by spaces in code fragments.\n# Minimum value: 1, maximum value: 16, default value: 4.\n\nTAB_SIZE               = 4\n\n# This tag can be used to specify a number of aliases that act as commands in\n# the documentation. An alias has the form:\n# name=value\n# For example adding\n# \"sideeffect=@par Side Effects:\\n\"\n# will allow you to put the command \\sideeffect (or @sideeffect) in the\n# documentation, which will result in a user-defined paragraph with heading\n# \"Side Effects:\". You can put \\n's in the value part of an alias to insert\n# newlines (in the resulting output). You can put ^^ in the value part of an\n# alias to insert a newline as if a physical newline was in the original file.\n# When you need a literal { or } or , in the value part of an alias you have to\n# escape them by means of a backslash (\\), this can lead to conflicts with the\n# commands \\{ and \\} for these it is advised to use the version @{ and @} or use\n# a double escape (\\\\{ and \\\\})\n\nALIASES                = \"setby{1}=@par Set by^^The \\1.\"\n\n# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources\n# only. Doxygen will then generate output that is more tailored for C. For\n# instance, some of the names that are used will be different. The list of all\n# members will be omitted, etc.\n# The default value is: NO.\n\nOPTIMIZE_OUTPUT_FOR_C  = YES\n\n# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or\n# Python sources only. Doxygen will then generate output that is more tailored\n# for that language. For instance, namespaces will be presented as packages,\n# qualified scopes will look different, etc.\n# The default value is: NO.\n\nOPTIMIZE_OUTPUT_JAVA   = NO\n\n# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran\n# sources. Doxygen will then generate output that is tailored for Fortran.\n# The default value is: NO.\n\nOPTIMIZE_FOR_FORTRAN   = NO\n\n# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL\n# sources. Doxygen will then generate output that is tailored for VHDL.\n# The default value is: NO.\n\nOPTIMIZE_OUTPUT_VHDL   = NO\n\n# Set the OPTIMIZE_OUTPUT_SLICE tag to YES if your project consists of Slice\n# sources only. Doxygen will then generate output that is more tailored for that\n# language. For instance, namespaces will be presented as modules, types will be\n# separated into more groups, etc.\n# The default value is: NO.\n\nOPTIMIZE_OUTPUT_SLICE  = NO\n\n# Doxygen selects the parser to use depending on the extension of the files it\n# parses. With this tag you can assign which parser to use for a given\n# extension. Doxygen has a built-in mapping, but you can override or extend it\n# using this tag. The format is ext=language, where ext is a file extension, and\n# language is one of the parsers supported by doxygen: IDL, Java, JavaScript,\n# Csharp (C#), C, C++, D, PHP, md (Markdown), Objective-C, Python, Slice, VHDL,\n# Fortran (fixed format Fortran: FortranFixed, free formatted Fortran:\n# FortranFree, unknown formatted Fortran: Fortran. In the later case the parser\n# tries to guess whether the code is fixed or free formatted code, this is the\n# default for Fortran type files). For instance to make doxygen treat .inc files\n# as Fortran files (default is PHP), and .f files as C (default is Fortran),\n# use: inc=Fortran f=C.\n#\n# Note: For files without extension you can use no_extension as a placeholder.\n#\n# Note that for custom extensions you also need to set FILE_PATTERNS otherwise\n# the files are not read by doxygen. When specifying no_extension you should add\n# * to the FILE_PATTERNS.\n#\n# Note see also the list of default file extension mappings.\n\nEXTENSION_MAPPING      =\n\n# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments\n# according to the Markdown format, which allows for more readable\n# documentation. See https://daringfireball.net/projects/markdown/ for details.\n# The output of markdown processing is further processed by doxygen, so you can\n# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in\n# case of backward compatibilities issues.\n# The default value is: YES.\n\nMARKDOWN_SUPPORT       = YES\n\n# When the TOC_INCLUDE_HEADINGS tag is set to a non-zero value, all headings up\n# to that level are automatically included in the table of contents, even if\n# they do not have an id attribute.\n# Note: This feature currently applies only to Markdown headings.\n# Minimum value: 0, maximum value: 99, default value: 5.\n# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.\n\nTOC_INCLUDE_HEADINGS   = 0\n\n# When enabled doxygen tries to link words that correspond to documented\n# classes, or namespaces to their corresponding documentation. Such a link can\n# be prevented in individual cases by putting a % sign in front of the word or\n# globally by setting AUTOLINK_SUPPORT to NO.\n# The default value is: YES.\n\nAUTOLINK_SUPPORT       = YES\n\n# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want\n# to include (a tag file for) the STL sources as input, then you should set this\n# tag to YES in order to let doxygen match functions declarations and\n# definitions whose arguments contain STL classes (e.g. func(std::string);\n# versus func(std::string) {}). This also make the inheritance and collaboration\n# diagrams that involve STL classes more complete and accurate.\n# The default value is: NO.\n\nBUILTIN_STL_SUPPORT    = NO\n\n# If you use Microsoft's C++/CLI language, you should set this option to YES to\n# enable parsing support.\n# The default value is: NO.\n\nCPP_CLI_SUPPORT        = NO\n\n# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:\n# https://www.riverbankcomputing.com/software/sip/intro) sources only. Doxygen\n# will parse them like normal C++ but will assume all classes use public instead\n# of private inheritance when no explicit protection keyword is present.\n# The default value is: NO.\n\nSIP_SUPPORT            = NO\n\n# For Microsoft's IDL there are propget and propput attributes to indicate\n# getter and setter methods for a property. Setting this option to YES will make\n# doxygen to replace the get and set methods by a property in the documentation.\n# This will only work if the methods are indeed getting or setting a simple\n# type. If this is not the case, or you want to show the methods anyway, you\n# should set this option to NO.\n# The default value is: YES.\n\nIDL_PROPERTY_SUPPORT   = YES\n\n# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC\n# tag is set to YES then doxygen will reuse the documentation of the first\n# member in the group (if any) for the other members of the group. By default\n# all members of a group must be documented explicitly.\n# The default value is: NO.\n\nDISTRIBUTE_GROUP_DOC   = NO\n\n# If one adds a struct or class to a group and this option is enabled, then also\n# any nested class or struct is added to the same group. By default this option\n# is disabled and one has to add nested compounds explicitly via \\ingroup.\n# The default value is: NO.\n\nGROUP_NESTED_COMPOUNDS = NO\n\n# Set the SUBGROUPING tag to YES to allow class member groups of the same type\n# (for instance a group of public functions) to be put as a subgroup of that\n# type (e.g. under the Public Functions section). Set it to NO to prevent\n# subgrouping. Alternatively, this can be done per class using the\n# \\nosubgrouping command.\n# The default value is: YES.\n\nSUBGROUPING            = YES\n\n# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions\n# are shown inside the group in which they are included (e.g. using \\ingroup)\n# instead of on a separate page (for HTML and Man pages) or section (for LaTeX\n# and RTF).\n#\n# Note that this feature does not work in combination with\n# SEPARATE_MEMBER_PAGES.\n# The default value is: NO.\n\nINLINE_GROUPED_CLASSES = NO\n\n# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions\n# with only public data fields or simple typedef fields will be shown inline in\n# the documentation of the scope in which they are defined (i.e. file,\n# namespace, or group documentation), provided this scope is documented. If set\n# to NO, structs, classes, and unions are shown on a separate page (for HTML and\n# Man pages) or section (for LaTeX and RTF).\n# The default value is: NO.\n\nINLINE_SIMPLE_STRUCTS  = YES\n\n# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or\n# enum is documented as struct, union, or enum with the name of the typedef. So\n# typedef struct TypeS {} TypeT, will appear in the documentation as a struct\n# with name TypeT. When disabled the typedef will appear as a member of a file,\n# namespace, or class. And the struct will be named TypeS. This can typically be\n# useful for C code in case the coding convention dictates that all compound\n# types are typedef'ed and only the typedef is referenced, never the tag name.\n# The default value is: NO.\n\nTYPEDEF_HIDES_STRUCT   = NO\n\n# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This\n# cache is used to resolve symbols given their name and scope. Since this can be\n# an expensive process and often the same symbol appears multiple times in the\n# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small\n# doxygen will become slower. If the cache is too large, memory is wasted. The\n# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range\n# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536\n# symbols. At the end of a run doxygen will report the cache usage and suggest\n# the optimal cache size from a speed point of view.\n# Minimum value: 0, maximum value: 9, default value: 0.\n\nLOOKUP_CACHE_SIZE      = 0\n\n# The NUM_PROC_THREADS specifies the number threads doxygen is allowed to use\n# during processing. When set to 0 doxygen will based this on the number of\n# cores available in the system. You can set it explicitly to a value larger\n# than 0 to get more control over the balance between CPU load and processing\n# speed. At this moment only the input processing can be done using multiple\n# threads. Since this is still an experimental feature the default is set to 1,\n# which efficively disables parallel processing. Please report any issues you\n# encounter. Generating dot graphs in parallel is controlled by the\n# DOT_NUM_THREADS setting.\n# Minimum value: 0, maximum value: 32, default value: 1.\n\nNUM_PROC_THREADS       = 16\n\n#---------------------------------------------------------------------------\n# Build related configuration options\n#---------------------------------------------------------------------------\n\n# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in\n# documentation are documented, even if no documentation was available. Private\n# class members and static file members will be hidden unless the\n# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.\n# Note: This will also disable the warnings about undocumented members that are\n# normally produced when WARNINGS is set to YES.\n# The default value is: NO.\n\nEXTRACT_ALL            = YES\n\n# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will\n# be included in the documentation.\n# The default value is: NO.\n\nEXTRACT_PRIVATE        = NO\n\n# If the EXTRACT_PRIV_VIRTUAL tag is set to YES, documented private virtual\n# methods of a class will be included in the documentation.\n# The default value is: NO.\n\nEXTRACT_PRIV_VIRTUAL   = NO\n\n# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal\n# scope will be included in the documentation.\n# The default value is: NO.\n\nEXTRACT_PACKAGE        = YES\n\n# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be\n# included in the documentation.\n# The default value is: NO.\n\nEXTRACT_STATIC         = YES\n\n# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined\n# locally in source files will be included in the documentation. If set to NO,\n# only classes defined in header files are included. Does not have any effect\n# for Java sources.\n# The default value is: YES.\n\nEXTRACT_LOCAL_CLASSES  = YES\n\n# This flag is only useful for Objective-C code. If set to YES, local methods,\n# which are defined in the implementation section but not in the interface are\n# included in the documentation. If set to NO, only methods in the interface are\n# included.\n# The default value is: NO.\n\nEXTRACT_LOCAL_METHODS  = YES\n\n# If this flag is set to YES, the members of anonymous namespaces will be\n# extracted and appear in the documentation as a namespace called\n# 'anonymous_namespace{file}', where file will be replaced with the base name of\n# the file that contains the anonymous namespace. By default anonymous namespace\n# are hidden.\n# The default value is: NO.\n\nEXTRACT_ANON_NSPACES   = NO\n\n# If this flag is set to YES, the name of an unnamed parameter in a declaration\n# will be determined by the corresponding definition. By default unnamed\n# parameters remain unnamed in the output.\n# The default value is: YES.\n\nRESOLVE_UNNAMED_PARAMS = YES\n\n# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all\n# undocumented members inside documented classes or files. If set to NO these\n# members will be included in the various overviews, but no documentation\n# section is generated. This option has no effect if EXTRACT_ALL is enabled.\n# The default value is: NO.\n\nHIDE_UNDOC_MEMBERS     = NO\n\n# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all\n# undocumented classes that are normally visible in the class hierarchy. If set\n# to NO, these classes will be included in the various overviews. This option\n# has no effect if EXTRACT_ALL is enabled.\n# The default value is: NO.\n\nHIDE_UNDOC_CLASSES     = NO\n\n# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend\n# declarations. If set to NO, these declarations will be included in the\n# documentation.\n# The default value is: NO.\n\nHIDE_FRIEND_COMPOUNDS  = NO\n\n# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any\n# documentation blocks found inside the body of a function. If set to NO, these\n# blocks will be appended to the function's detailed documentation block.\n# The default value is: NO.\n\nHIDE_IN_BODY_DOCS      = NO\n\n# The INTERNAL_DOCS tag determines if documentation that is typed after a\n# \\internal command is included. If the tag is set to NO then the documentation\n# will be excluded. Set it to YES to include the internal documentation.\n# The default value is: NO.\n\nINTERNAL_DOCS          = NO\n\n# With the correct setting of option CASE_SENSE_NAMES doxygen will better be\n# able to match the capabilities of the underlying filesystem. In case the\n# filesystem is case sensitive (i.e. it supports files in the same directory\n# whose names only differ in casing), the option must be set to YES to properly\n# deal with such files in case they appear in the input. For filesystems that\n# are not case sensitive the option should be be set to NO to properly deal with\n# output files written for symbols that only differ in casing, such as for two\n# classes, one named CLASS and the other named Class, and to also support\n# references to files without having to specify the exact matching casing. On\n# Windows (including Cygwin) and MacOS, users should typically set this option\n# to NO, whereas on Linux or other Unix flavors it should typically be set to\n# YES.\n# The default value is: system dependent.\n\nCASE_SENSE_NAMES       = YES\n\n# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with\n# their full class and namespace scopes in the documentation. If set to YES, the\n# scope will be hidden.\n# The default value is: NO.\n\nHIDE_SCOPE_NAMES       = YES\n\n# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will\n# append additional text to a page's title, such as Class Reference. If set to\n# YES the compound reference will be hidden.\n# The default value is: NO.\n\nHIDE_COMPOUND_REFERENCE= NO\n\n# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of\n# the files that are included by a file in the documentation of that file.\n# The default value is: YES.\n\nSHOW_INCLUDE_FILES     = YES\n\n# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each\n# grouped member an include statement to the documentation, telling the reader\n# which file to include in order to use the member.\n# The default value is: NO.\n\nSHOW_GROUPED_MEMB_INC  = NO\n\n# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include\n# files with double quotes in the documentation rather than with sharp brackets.\n# The default value is: NO.\n\nFORCE_LOCAL_INCLUDES   = NO\n\n# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the\n# documentation for inline members.\n# The default value is: YES.\n\nINLINE_INFO            = YES\n\n# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the\n# (detailed) documentation of file and class members alphabetically by member\n# name. If set to NO, the members will appear in declaration order.\n# The default value is: YES.\n\nSORT_MEMBER_DOCS       = NO\n\n# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief\n# descriptions of file, namespace and class members alphabetically by member\n# name. If set to NO, the members will appear in declaration order. Note that\n# this will also influence the order of the classes in the class list.\n# The default value is: NO.\n\nSORT_BRIEF_DOCS        = NO\n\n# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the\n# (brief and detailed) documentation of class members so that constructors and\n# destructors are listed first. If set to NO the constructors will appear in the\n# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.\n# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief\n# member documentation.\n# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting\n# detailed member documentation.\n# The default value is: NO.\n\nSORT_MEMBERS_CTORS_1ST = NO\n\n# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy\n# of group names into alphabetical order. If set to NO the group names will\n# appear in their defined order.\n# The default value is: NO.\n\nSORT_GROUP_NAMES       = NO\n\n# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by\n# fully-qualified names, including namespaces. If set to NO, the class list will\n# be sorted only by class name, not including the namespace part.\n# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.\n# Note: This option applies only to the class list, not to the alphabetical\n# list.\n# The default value is: NO.\n\nSORT_BY_SCOPE_NAME     = NO\n\n# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper\n# type resolution of all parameters of a function it will reject a match between\n# the prototype and the implementation of a member function even if there is\n# only one candidate or it is obvious which candidate to choose by doing a\n# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still\n# accept a match between prototype and implementation in such cases.\n# The default value is: NO.\n\nSTRICT_PROTO_MATCHING  = YES\n\n# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo\n# list. This list is created by putting \\todo commands in the documentation.\n# The default value is: YES.\n\nGENERATE_TODOLIST      = YES\n\n# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test\n# list. This list is created by putting \\test commands in the documentation.\n# The default value is: YES.\n\nGENERATE_TESTLIST      = YES\n\n# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug\n# list. This list is created by putting \\bug commands in the documentation.\n# The default value is: YES.\n\nGENERATE_BUGLIST       = YES\n\n# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)\n# the deprecated list. This list is created by putting \\deprecated commands in\n# the documentation.\n# The default value is: YES.\n\nGENERATE_DEPRECATEDLIST= YES\n\n# The ENABLED_SECTIONS tag can be used to enable conditional documentation\n# sections, marked by \\if <section_label> ... \\endif and \\cond <section_label>\n# ... \\endcond blocks.\n\nENABLED_SECTIONS       =\n\n# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the\n# initial value of a variable or macro / define can have for it to appear in the\n# documentation. If the initializer consists of more lines than specified here\n# it will be hidden. Use a value of 0 to hide initializers completely. The\n# appearance of the value of individual variables and macros / defines can be\n# controlled using \\showinitializer or \\hideinitializer command in the\n# documentation regardless of this setting.\n# Minimum value: 0, maximum value: 10000, default value: 30.\n\nMAX_INITIALIZER_LINES  = 30\n\n# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at\n# the bottom of the documentation of classes and structs. If set to YES, the\n# list will mention the files that were used to generate the documentation.\n# The default value is: YES.\n\nSHOW_USED_FILES        = YES\n\n# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This\n# will remove the Files entry from the Quick Index and from the Folder Tree View\n# (if specified).\n# The default value is: YES.\n\nSHOW_FILES             = YES\n\n# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces\n# page. This will remove the Namespaces entry from the Quick Index and from the\n# Folder Tree View (if specified).\n# The default value is: YES.\n\nSHOW_NAMESPACES        = YES\n\n# The FILE_VERSION_FILTER tag can be used to specify a program or script that\n# doxygen should invoke to get the current version for each file (typically from\n# the version control system). Doxygen will invoke the program by executing (via\n# popen()) the command command input-file, where command is the value of the\n# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided\n# by doxygen. Whatever the program writes to standard output is used as the file\n# version. For an example see the documentation.\n\nFILE_VERSION_FILTER    =\n\n# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed\n# by doxygen. The layout file controls the global structure of the generated\n# output files in an output format independent way. To create the layout file\n# that represents doxygen's defaults, run doxygen with the -l option. You can\n# optionally specify a file name after the option, if omitted DoxygenLayout.xml\n# will be used as the name of the layout file.\n#\n# Note that if you run doxygen from a directory containing a file called\n# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE\n# tag is left empty.\n\nLAYOUT_FILE            =\n\n# The CITE_BIB_FILES tag can be used to specify one or more bib files containing\n# the reference definitions. This must be a list of .bib files. The .bib\n# extension is automatically appended if omitted. This requires the bibtex tool\n# to be installed. See also https://en.wikipedia.org/wiki/BibTeX for more info.\n# For LaTeX the style of the bibliography can be controlled using\n# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the\n# search path. See also \\cite for info how to create references.\n\nCITE_BIB_FILES         =\n\n#---------------------------------------------------------------------------\n# Configuration options related to warning and progress messages\n#---------------------------------------------------------------------------\n\n# The QUIET tag can be used to turn on/off the messages that are generated to\n# standard output by doxygen. If QUIET is set to YES this implies that the\n# messages are off.\n# The default value is: NO.\n\nQUIET                  = YES\n\n# The WARNINGS tag can be used to turn on/off the warning messages that are\n# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES\n# this implies that the warnings are on.\n#\n# Tip: Turn warnings on while writing the documentation.\n# The default value is: YES.\n\nWARNINGS               = YES\n\n# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate\n# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag\n# will automatically be disabled.\n# The default value is: YES.\n\nWARN_IF_UNDOCUMENTED   = YES\n\n# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for\n# potential errors in the documentation, such as not documenting some parameters\n# in a documented function, or documenting parameters that don't exist or using\n# markup commands wrongly.\n# The default value is: YES.\n\nWARN_IF_DOC_ERROR      = YES\n\n# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that\n# are documented, but have no documentation for their parameters or return\n# value. If set to NO, doxygen will only warn about wrong or incomplete\n# parameter documentation, but not about the absence of documentation. If\n# EXTRACT_ALL is set to YES then this flag will automatically be disabled.\n# The default value is: NO.\n\nWARN_NO_PARAMDOC       = NO\n\n# If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when\n# a warning is encountered. If the WARN_AS_ERROR tag is set to FAIL_ON_WARNINGS\n# then doxygen will continue running as if WARN_AS_ERROR tag is set to NO, but\n# at the end of the doxygen process doxygen will return with a non-zero status.\n# Possible values are: NO, YES and FAIL_ON_WARNINGS.\n# The default value is: NO.\n\nWARN_AS_ERROR          = NO\n\n# The WARN_FORMAT tag determines the format of the warning messages that doxygen\n# can produce. The string should contain the $file, $line, and $text tags, which\n# will be replaced by the file and line number from which the warning originated\n# and the warning text. Optionally the format may contain $version, which will\n# be replaced by the version of the file (if it could be obtained via\n# FILE_VERSION_FILTER)\n# The default value is: $file:$line: $text.\n\nWARN_FORMAT            = \"$file:$line: $text\"\n\n# The WARN_LOGFILE tag can be used to specify a file to which warning and error\n# messages should be written. If left blank the output is written to standard\n# error (stderr).\n\nWARN_LOGFILE           =\n\n#---------------------------------------------------------------------------\n# Configuration options related to the input files\n#---------------------------------------------------------------------------\n\n# The INPUT tag is used to specify the files and/or directories that contain\n# documented source files. You may enter file names like myfile.cpp or\n# directories like /usr/src/myproject. Separate the files or directories with\n# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING\n# Note: If this tag is empty the current directory is searched.\n\nINPUT                  = libretro-common\n\n# This tag can be used to specify the character encoding of the source files\n# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses\n# libiconv (or the iconv built into libc) for the transcoding. See the libiconv\n# documentation (see:\n# https://www.gnu.org/software/libiconv/) for the list of possible encodings.\n# The default value is: UTF-8.\n\nINPUT_ENCODING         = UTF-8\n\n# If the value of the INPUT tag contains directories, you can use the\n# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and\n# *.h) to filter out the source-files in the directories.\n#\n# Note that for custom extensions or not directly supported extensions you also\n# need to set EXTENSION_MAPPING for the extension otherwise the files are not\n# read by doxygen.\n#\n# Note the list of default checked file patterns might differ from the list of\n# default file extension mappings.\n#\n# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cpp,\n# *.c++, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h,\n# *.hh, *.hxx, *.hpp, *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc,\n# *.m, *.markdown, *.md, *.mm, *.dox (to be provided as doxygen C comment),\n# *.py, *.pyw, *.f90, *.f95, *.f03, *.f08, *.f18, *.f, *.for, *.vhd, *.vhdl,\n# *.ucf, *.qsf and *.ice.\n\nFILE_PATTERNS          = *.h\n\n# The RECURSIVE tag can be used to specify whether or not subdirectories should\n# be searched for input files as well.\n# The default value is: NO.\n\nRECURSIVE              = YES\n\n# The EXCLUDE tag can be used to specify files and/or directories that should be\n# excluded from the INPUT source files. This way you can easily exclude a\n# subdirectory from a directory tree whose root is specified with the INPUT tag.\n#\n# Note that relative paths are relative to the directory from which doxygen is\n# run.\n\nEXCLUDE                =\n\n# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or\n# directories that are symbolic links (a Unix file system feature) are excluded\n# from the input.\n# The default value is: NO.\n\nEXCLUDE_SYMLINKS       = NO\n\n# If the value of the INPUT tag contains directories, you can use the\n# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude\n# certain files from those directories.\n#\n# Note that the wildcards are matched against the file with absolute path, so to\n# exclude all test directories for example use the pattern */test/*\n\nEXCLUDE_PATTERNS       = */libretro-common/rthreads/* \\\n                         */libretro-common/formats/* \\\n                         */libretro-common/crt/* \\\n                         */libretro-common/samples/* \\\n                         */libretro-common/include/glsym/*\n\n# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names\n# (namespaces, classes, functions, etc.) that should be excluded from the\n# output. The symbol name can be a fully qualified name, a word, or if the\n# wildcard * is used, a substring. Examples: ANamespace, AClass,\n# AClass::ANamespace, ANamespace::*Test\n#\n# Note that the wildcards are matched against the file with absolute path, so to\n# exclude all test directories use the pattern */test/*\n\nEXCLUDE_SYMBOLS        = bool \\\n                         void \\\n                         const\n\n# The EXAMPLE_PATH tag can be used to specify one or more files or directories\n# that contain example code fragments that are included (see the \\include\n# command).\n\nEXAMPLE_PATH           =\n\n# If the value of the EXAMPLE_PATH tag contains directories, you can use the\n# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and\n# *.h) to filter out the source-files in the directories. If left blank all\n# files are included.\n\nEXAMPLE_PATTERNS       = *\n\n# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be\n# searched for input files to be used with the \\include or \\dontinclude commands\n# irrespective of the value of the RECURSIVE tag.\n# The default value is: NO.\n\nEXAMPLE_RECURSIVE      = NO\n\n# The IMAGE_PATH tag can be used to specify one or more files or directories\n# that contain images that are to be included in the documentation (see the\n# \\image command).\n\nIMAGE_PATH             =\n\n# The INPUT_FILTER tag can be used to specify a program that doxygen should\n# invoke to filter for each input file. Doxygen will invoke the filter program\n# by executing (via popen()) the command:\n#\n# <filter> <input-file>\n#\n# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the\n# name of an input file. Doxygen will then use the output that the filter\n# program writes to standard output. If FILTER_PATTERNS is specified, this tag\n# will be ignored.\n#\n# Note that the filter must not add or remove lines; it is applied before the\n# code is scanned, but not when the output code is generated. If lines are added\n# or removed, the anchors will not be placed correctly.\n#\n# Note that for custom extensions or not directly supported extensions you also\n# need to set EXTENSION_MAPPING for the extension otherwise the files are not\n# properly processed by doxygen.\n\nINPUT_FILTER           =\n\n# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern\n# basis. Doxygen will compare the file name with each pattern and apply the\n# filter if there is a match. The filters are a list of the form: pattern=filter\n# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how\n# filters are used. If the FILTER_PATTERNS tag is empty or if none of the\n# patterns match the file name, INPUT_FILTER is applied.\n#\n# Note that for custom extensions or not directly supported extensions you also\n# need to set EXTENSION_MAPPING for the extension otherwise the files are not\n# properly processed by doxygen.\n\nFILTER_PATTERNS        =\n\n# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using\n# INPUT_FILTER) will also be used to filter the input files that are used for\n# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).\n# The default value is: NO.\n\nFILTER_SOURCE_FILES    = NO\n\n# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file\n# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and\n# it is also possible to disable source filtering for a specific pattern using\n# *.ext= (so without naming a filter).\n# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.\n\nFILTER_SOURCE_PATTERNS =\n\n# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that\n# is part of the input, its contents will be placed on the main page\n# (index.html). This can be useful if you have a project on for instance GitHub\n# and want to reuse the introduction page also for the doxygen output.\n\nUSE_MDFILE_AS_MAINPAGE =\n\n#---------------------------------------------------------------------------\n# Configuration options related to source browsing\n#---------------------------------------------------------------------------\n\n# If the SOURCE_BROWSER tag is set to YES then a list of source files will be\n# generated. Documented entities will be cross-referenced with these sources.\n#\n# Note: To get rid of all source code in the generated output, make sure that\n# also VERBATIM_HEADERS is set to NO.\n# The default value is: NO.\n\nSOURCE_BROWSER         = NO\n\n# Setting the INLINE_SOURCES tag to YES will include the body of functions,\n# classes and enums directly into the documentation.\n# The default value is: NO.\n\nINLINE_SOURCES         = NO\n\n# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any\n# special comment blocks from generated source code fragments. Normal C, C++ and\n# Fortran comments will always remain visible.\n# The default value is: YES.\n\nSTRIP_CODE_COMMENTS    = YES\n\n# If the REFERENCED_BY_RELATION tag is set to YES then for each documented\n# entity all documented functions referencing it will be listed.\n# The default value is: NO.\n\nREFERENCED_BY_RELATION = NO\n\n# If the REFERENCES_RELATION tag is set to YES then for each documented function\n# all documented entities called/used by that function will be listed.\n# The default value is: NO.\n\nREFERENCES_RELATION    = NO\n\n# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set\n# to YES then the hyperlinks from functions in REFERENCES_RELATION and\n# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will\n# link to the documentation.\n# The default value is: YES.\n\nREFERENCES_LINK_SOURCE = YES\n\n# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the\n# source code will show a tooltip with additional information such as prototype,\n# brief description and links to the definition and documentation. Since this\n# will make the HTML file larger and loading of large files a bit slower, you\n# can opt to disable this feature.\n# The default value is: YES.\n# This tag requires that the tag SOURCE_BROWSER is set to YES.\n\nSOURCE_TOOLTIPS        = YES\n\n# If the USE_HTAGS tag is set to YES then the references to source code will\n# point to the HTML generated by the htags(1) tool instead of doxygen built-in\n# source browser. The htags tool is part of GNU's global source tagging system\n# (see https://www.gnu.org/software/global/global.html). You will need version\n# 4.8.6 or higher.\n#\n# To use it do the following:\n# - Install the latest version of global\n# - Enable SOURCE_BROWSER and USE_HTAGS in the configuration file\n# - Make sure the INPUT points to the root of the source tree\n# - Run doxygen as normal\n#\n# Doxygen will invoke htags (and that will in turn invoke gtags), so these\n# tools must be available from the command line (i.e. in the search path).\n#\n# The result: instead of the source browser generated by doxygen, the links to\n# source code will now point to the output of htags.\n# The default value is: NO.\n# This tag requires that the tag SOURCE_BROWSER is set to YES.\n\nUSE_HTAGS              = NO\n\n# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a\n# verbatim copy of the header file for each class for which an include is\n# specified. Set to NO to disable this.\n# See also: Section \\class.\n# The default value is: YES.\n\nVERBATIM_HEADERS       = YES\n\n# If the CLANG_ASSISTED_PARSING tag is set to YES then doxygen will use the\n# clang parser (see:\n# http://clang.llvm.org/) for more accurate parsing at the cost of reduced\n# performance. This can be particularly helpful with template rich C++ code for\n# which doxygen's built-in parser lacks the necessary type information.\n# Note: The availability of this option depends on whether or not doxygen was\n# generated with the -Duse_libclang=ON option for CMake.\n# The default value is: NO.\n\nCLANG_ASSISTED_PARSING = NO\n\n# If clang assisted parsing is enabled and the CLANG_ADD_INC_PATHS tag is set to\n# YES then doxygen will add the directory of each input to the include path.\n# The default value is: YES.\n\nCLANG_ADD_INC_PATHS    = YES\n\n# If clang assisted parsing is enabled you can provide the compiler with command\n# line options that you would normally use when invoking the compiler. Note that\n# the include paths will already be set by doxygen for the files and directories\n# specified with INPUT and INCLUDE_PATH.\n# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.\n\nCLANG_OPTIONS          =\n\n# If clang assisted parsing is enabled you can provide the clang parser with the\n# path to the directory containing a file called compile_commands.json. This\n# file is the compilation database (see:\n# http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html) containing the\n# options used when the source files were built. This is equivalent to\n# specifying the -p option to a clang tool, such as clang-check. These options\n# will then be passed to the parser. Any options specified with CLANG_OPTIONS\n# will be added as well.\n# Note: The availability of this option depends on whether or not doxygen was\n# generated with the -Duse_libclang=ON option for CMake.\n\nCLANG_DATABASE_PATH    =\n\n#---------------------------------------------------------------------------\n# Configuration options related to the alphabetical class index\n#---------------------------------------------------------------------------\n\n# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all\n# compounds will be generated. Enable this if the project contains a lot of\n# classes, structs, unions or interfaces.\n# The default value is: YES.\n\nALPHABETICAL_INDEX     = YES\n\n# In case all classes in a project start with a common prefix, all classes will\n# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag\n# can be used to specify a prefix (or a list of prefixes) that should be ignored\n# while generating the index headers.\n# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.\n\nIGNORE_PREFIX          = retro_ \\\n                         RETRO_\n\n#---------------------------------------------------------------------------\n# Configuration options related to the HTML output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output\n# The default value is: YES.\n\nGENERATE_HTML          = YES\n\n# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a\n# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of\n# it.\n# The default directory is: html.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_OUTPUT            = html\n\n# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each\n# generated HTML page (for example: .htm, .php, .asp).\n# The default value is: .html.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_FILE_EXTENSION    = .html\n\n# The HTML_HEADER tag can be used to specify a user-defined HTML header file for\n# each generated HTML page. If the tag is left blank doxygen will generate a\n# standard header.\n#\n# To get valid HTML the header file that includes any scripts and style sheets\n# that doxygen needs, which is dependent on the configuration options used (e.g.\n# the setting GENERATE_TREEVIEW). It is highly recommended to start with a\n# default header using\n# doxygen -w html new_header.html new_footer.html new_stylesheet.css\n# YourConfigFile\n# and then modify the file new_header.html. See also section \"Doxygen usage\"\n# for information on how to generate the default header that doxygen normally\n# uses.\n# Note: The header is subject to change so you typically have to regenerate the\n# default header when upgrading to a newer version of doxygen. For a description\n# of the possible markers and block names see the documentation.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_HEADER            =\n\n# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each\n# generated HTML page. If the tag is left blank doxygen will generate a standard\n# footer. See HTML_HEADER for more information on how to generate a default\n# footer and what special commands can be used inside the footer. See also\n# section \"Doxygen usage\" for information on how to generate the default footer\n# that doxygen normally uses.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_FOOTER            =\n\n# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style\n# sheet that is used by each HTML page. It can be used to fine-tune the look of\n# the HTML output. If left blank doxygen will generate a default style sheet.\n# See also section \"Doxygen usage\" for information on how to generate the style\n# sheet that doxygen normally uses.\n# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as\n# it is more robust and this tag (HTML_STYLESHEET) will in the future become\n# obsolete.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_STYLESHEET        =\n\n# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined\n# cascading style sheets that are included after the standard style sheets\n# created by doxygen. Using this option one can overrule certain style aspects.\n# This is preferred over using HTML_STYLESHEET since it does not replace the\n# standard style sheet and is therefore more robust against future updates.\n# Doxygen will copy the style sheet files to the output directory.\n# Note: The order of the extra style sheet files is of importance (e.g. the last\n# style sheet in the list overrules the setting of the previous ones in the\n# list). For an example see the documentation.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_EXTRA_STYLESHEET  =\n\n# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or\n# other source files which should be copied to the HTML output directory. Note\n# that these files will be copied to the base HTML output directory. Use the\n# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these\n# files. In the HTML_STYLESHEET file, use the file name only. Also note that the\n# files will be copied as-is; there are no commands or markers available.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_EXTRA_FILES       =\n\n# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen\n# will adjust the colors in the style sheet and background images according to\n# this color. Hue is specified as an angle on a colorwheel, see\n# https://en.wikipedia.org/wiki/Hue for more information. For instance the value\n# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300\n# purple, and 360 is red again.\n# Minimum value: 0, maximum value: 359, default value: 220.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_COLORSTYLE_HUE    = 220\n\n# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors\n# in the HTML output. For a value of 0 the output will use grayscales only. A\n# value of 255 will produce the most vivid colors.\n# Minimum value: 0, maximum value: 255, default value: 100.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_COLORSTYLE_SAT    = 100\n\n# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the\n# luminance component of the colors in the HTML output. Values below 100\n# gradually make the output lighter, whereas values above 100 make the output\n# darker. The value divided by 100 is the actual gamma applied, so 80 represents\n# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not\n# change the gamma.\n# Minimum value: 40, maximum value: 240, default value: 80.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_COLORSTYLE_GAMMA  = 80\n\n# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML\n# page will contain the date and time when the page was generated. Setting this\n# to YES can help to show when doxygen was last run and thus if the\n# documentation is up to date.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_TIMESTAMP         = NO\n\n# If the HTML_DYNAMIC_MENUS tag is set to YES then the generated HTML\n# documentation will contain a main index with vertical navigation menus that\n# are dynamically created via JavaScript. If disabled, the navigation index will\n# consists of multiple levels of tabs that are statically embedded in every HTML\n# page. Disable this option to support browsers that do not have JavaScript,\n# like the Qt help browser.\n# The default value is: YES.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_DYNAMIC_MENUS     = YES\n\n# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML\n# documentation will contain sections that can be hidden and shown after the\n# page has loaded.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_DYNAMIC_SECTIONS  = NO\n\n# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries\n# shown in the various tree structured indices initially; the user can expand\n# and collapse entries dynamically later on. Doxygen will expand the tree to\n# such a level that at most the specified number of entries are visible (unless\n# a fully collapsed tree already exceeds this amount). So setting the number of\n# entries 1 will produce a full collapsed tree by default. 0 is a special value\n# representing an infinite number of entries and will result in a full expanded\n# tree by default.\n# Minimum value: 0, maximum value: 9999, default value: 100.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_INDEX_NUM_ENTRIES = 100\n\n# If the GENERATE_DOCSET tag is set to YES, additional index files will be\n# generated that can be used as input for Apple's Xcode 3 integrated development\n# environment (see:\n# https://developer.apple.com/xcode/), introduced with OSX 10.5 (Leopard). To\n# create a documentation set, doxygen will generate a Makefile in the HTML\n# output directory. Running make will produce the docset in that directory and\n# running make install will install the docset in\n# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at\n# startup. See https://developer.apple.com/library/archive/featuredarticles/Doxy\n# genXcode/_index.html for more information.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nGENERATE_DOCSET        = NO\n\n# This tag determines the name of the docset feed. A documentation feed provides\n# an umbrella under which multiple documentation sets from a single provider\n# (such as a company or product suite) can be grouped.\n# The default value is: Doxygen generated docs.\n# This tag requires that the tag GENERATE_DOCSET is set to YES.\n\nDOCSET_FEEDNAME        = \"Doxygen generated docs\"\n\n# This tag specifies a string that should uniquely identify the documentation\n# set bundle. This should be a reverse domain-name style string, e.g.\n# com.mycompany.MyDocSet. Doxygen will append .docset to the name.\n# The default value is: org.doxygen.Project.\n# This tag requires that the tag GENERATE_DOCSET is set to YES.\n\nDOCSET_BUNDLE_ID       = org.doxygen.Project\n\n# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify\n# the documentation publisher. This should be a reverse domain-name style\n# string, e.g. com.mycompany.MyDocSet.documentation.\n# The default value is: org.doxygen.Publisher.\n# This tag requires that the tag GENERATE_DOCSET is set to YES.\n\nDOCSET_PUBLISHER_ID    = org.doxygen.Publisher\n\n# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.\n# The default value is: Publisher.\n# This tag requires that the tag GENERATE_DOCSET is set to YES.\n\nDOCSET_PUBLISHER_NAME  = Publisher\n\n# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three\n# additional HTML index files: index.hhp, index.hhc, and index.hhk. The\n# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop\n# (see:\n# https://www.microsoft.com/en-us/download/details.aspx?id=21138) on Windows.\n#\n# The HTML Help Workshop contains a compiler that can convert all HTML output\n# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML\n# files are now used as the Windows 98 help format, and will replace the old\n# Windows help format (.hlp) on all Windows platforms in the future. Compressed\n# HTML files also contain an index, a table of contents, and you can search for\n# words in the documentation. The HTML workshop also contains a viewer for\n# compressed HTML files.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nGENERATE_HTMLHELP      = NO\n\n# The CHM_FILE tag can be used to specify the file name of the resulting .chm\n# file. You can add a path in front of the file if the result should not be\n# written to the html output directory.\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\n\nCHM_FILE               =\n\n# The HHC_LOCATION tag can be used to specify the location (absolute path\n# including file name) of the HTML help compiler (hhc.exe). If non-empty,\n# doxygen will try to run the HTML help compiler on the generated index.hhp.\n# The file has to be specified with full path.\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\n\nHHC_LOCATION           =\n\n# The GENERATE_CHI flag controls if a separate .chi index file is generated\n# (YES) or that it should be included in the main .chm file (NO).\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\n\nGENERATE_CHI           = NO\n\n# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)\n# and project file content.\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\n\nCHM_INDEX_ENCODING     =\n\n# The BINARY_TOC flag controls whether a binary table of contents is generated\n# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it\n# enables the Previous and Next buttons.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\n\nBINARY_TOC             = NO\n\n# The TOC_EXPAND flag can be set to YES to add extra items for group members to\n# the table of contents of the HTML help documentation and to the tree view.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTMLHELP is set to YES.\n\nTOC_EXPAND             = NO\n\n# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and\n# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that\n# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help\n# (.qch) of the generated HTML documentation.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nGENERATE_QHP           = NO\n\n# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify\n# the file name of the resulting .qch file. The path specified is relative to\n# the HTML output folder.\n# This tag requires that the tag GENERATE_QHP is set to YES.\n\nQCH_FILE               =\n\n# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help\n# Project output. For more information please see Qt Help Project / Namespace\n# (see:\n# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#namespace).\n# The default value is: org.doxygen.Project.\n# This tag requires that the tag GENERATE_QHP is set to YES.\n\nQHP_NAMESPACE          = org.doxygen.Project\n\n# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt\n# Help Project output. For more information please see Qt Help Project / Virtual\n# Folders (see:\n# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#virtual-folders).\n# The default value is: doc.\n# This tag requires that the tag GENERATE_QHP is set to YES.\n\nQHP_VIRTUAL_FOLDER     = doc\n\n# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom\n# filter to add. For more information please see Qt Help Project / Custom\n# Filters (see:\n# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-filters).\n# This tag requires that the tag GENERATE_QHP is set to YES.\n\nQHP_CUST_FILTER_NAME   =\n\n# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the\n# custom filter to add. For more information please see Qt Help Project / Custom\n# Filters (see:\n# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-filters).\n# This tag requires that the tag GENERATE_QHP is set to YES.\n\nQHP_CUST_FILTER_ATTRS  =\n\n# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this\n# project's filter section matches. Qt Help Project / Filter Attributes (see:\n# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#filter-attributes).\n# This tag requires that the tag GENERATE_QHP is set to YES.\n\nQHP_SECT_FILTER_ATTRS  =\n\n# The QHG_LOCATION tag can be used to specify the location (absolute path\n# including file name) of Qt's qhelpgenerator. If non-empty doxygen will try to\n# run qhelpgenerator on the generated .qhp file.\n# This tag requires that the tag GENERATE_QHP is set to YES.\n\nQHG_LOCATION           =\n\n# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be\n# generated, together with the HTML files, they form an Eclipse help plugin. To\n# install this plugin and make it available under the help contents menu in\n# Eclipse, the contents of the directory containing the HTML and XML files needs\n# to be copied into the plugins directory of eclipse. The name of the directory\n# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.\n# After copying Eclipse needs to be restarted before the help appears.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nGENERATE_ECLIPSEHELP   = NO\n\n# A unique identifier for the Eclipse help plugin. When installing the plugin\n# the directory name containing the HTML and XML files should also have this\n# name. Each documentation set should have its own identifier.\n# The default value is: org.doxygen.Project.\n# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.\n\nECLIPSE_DOC_ID         = org.doxygen.Project\n\n# If you want full control over the layout of the generated HTML pages it might\n# be necessary to disable the index and replace it with your own. The\n# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top\n# of each HTML page. A value of NO enables the index and the value YES disables\n# it. Since the tabs in the index contain the same information as the navigation\n# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nDISABLE_INDEX          = NO\n\n# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index\n# structure should be generated to display hierarchical information. If the tag\n# value is set to YES, a side panel will be generated containing a tree-like\n# index structure (just like the one that is generated for HTML Help). For this\n# to work a browser that supports JavaScript, DHTML, CSS and frames is required\n# (i.e. any modern browser). Windows users are probably better off using the\n# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can\n# further fine-tune the look of the index. As an example, the default style\n# sheet generated by doxygen has an example that shows how to put an image at\n# the root of the tree instead of the PROJECT_NAME. Since the tree basically has\n# the same information as the tab index, you could consider setting\n# DISABLE_INDEX to YES when enabling this option.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nGENERATE_TREEVIEW      = YES\n\n# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that\n# doxygen will group on one line in the generated HTML documentation.\n#\n# Note that a value of 0 will completely suppress the enum values from appearing\n# in the overview section.\n# Minimum value: 0, maximum value: 20, default value: 4.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nENUM_VALUES_PER_LINE   = 4\n\n# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used\n# to set the initial width (in pixels) of the frame in which the tree is shown.\n# Minimum value: 0, maximum value: 1500, default value: 250.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nTREEVIEW_WIDTH         = 250\n\n# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to\n# external symbols imported via tag files in a separate window.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nEXT_LINKS_IN_WINDOW    = NO\n\n# If the HTML_FORMULA_FORMAT option is set to svg, doxygen will use the pdf2svg\n# tool (see https://github.com/dawbarton/pdf2svg) or inkscape (see\n# https://inkscape.org) to generate formulas as SVG images instead of PNGs for\n# the HTML output. These images will generally look nicer at scaled resolutions.\n# Possible values are: png (the default) and svg (looks nicer but requires the\n# pdf2svg or inkscape tool).\n# The default value is: png.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nHTML_FORMULA_FORMAT    = png\n\n# Use this tag to change the font size of LaTeX formulas included as images in\n# the HTML documentation. When you change the font size after a successful\n# doxygen run you need to manually remove any form_*.png images from the HTML\n# output directory to force them to be regenerated.\n# Minimum value: 8, maximum value: 50, default value: 10.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nFORMULA_FONTSIZE       = 10\n\n# Use the FORMULA_TRANSPARENT tag to determine whether or not the images\n# generated for formulas are transparent PNGs. Transparent PNGs are not\n# supported properly for IE 6.0, but are supported on all modern browsers.\n#\n# Note that when changing this option you need to delete any form_*.png files in\n# the HTML output directory before the changes have effect.\n# The default value is: YES.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nFORMULA_TRANSPARENT    = YES\n\n# The FORMULA_MACROFILE can contain LaTeX \\newcommand and \\renewcommand commands\n# to create new LaTeX commands to be used in formulas as building blocks. See\n# the section \"Including formulas\" for details.\n\nFORMULA_MACROFILE      =\n\n# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see\n# https://www.mathjax.org) which uses client side JavaScript for the rendering\n# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX\n# installed or if you want to formulas look prettier in the HTML output. When\n# enabled you may also need to install MathJax separately and configure the path\n# to it using the MATHJAX_RELPATH option.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nUSE_MATHJAX            = NO\n\n# When MathJax is enabled you can set the default output format to be used for\n# the MathJax output. See the MathJax site (see:\n# http://docs.mathjax.org/en/v2.7-latest/output.html) for more details.\n# Possible values are: HTML-CSS (which is slower, but has the best\n# compatibility), NativeMML (i.e. MathML) and SVG.\n# The default value is: HTML-CSS.\n# This tag requires that the tag USE_MATHJAX is set to YES.\n\nMATHJAX_FORMAT         = HTML-CSS\n\n# When MathJax is enabled you need to specify the location relative to the HTML\n# output directory using the MATHJAX_RELPATH option. The destination directory\n# should contain the MathJax.js script. For instance, if the mathjax directory\n# is located at the same level as the HTML output directory, then\n# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax\n# Content Delivery Network so you can quickly see the result without installing\n# MathJax. However, it is strongly recommended to install a local copy of\n# MathJax from https://www.mathjax.org before deployment.\n# The default value is: https://cdn.jsdelivr.net/npm/mathjax@2.\n# This tag requires that the tag USE_MATHJAX is set to YES.\n\nMATHJAX_RELPATH        = https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/\n\n# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax\n# extension names that should be enabled during MathJax rendering. For example\n# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols\n# This tag requires that the tag USE_MATHJAX is set to YES.\n\nMATHJAX_EXTENSIONS     =\n\n# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces\n# of code that will be used on startup of the MathJax code. See the MathJax site\n# (see:\n# http://docs.mathjax.org/en/v2.7-latest/output.html) for more details. For an\n# example see the documentation.\n# This tag requires that the tag USE_MATHJAX is set to YES.\n\nMATHJAX_CODEFILE       =\n\n# When the SEARCHENGINE tag is enabled doxygen will generate a search box for\n# the HTML output. The underlying search engine uses javascript and DHTML and\n# should work on any modern browser. Note that when using HTML help\n# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)\n# there is already a search function so this one should typically be disabled.\n# For large projects the javascript based search engine can be slow, then\n# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to\n# search using the keyboard; to jump to the search box use <access key> + S\n# (what the <access key> is depends on the OS and browser, but it is typically\n# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down\n# key> to jump into the search results window, the results can be navigated\n# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel\n# the search. The filter options can be selected when the cursor is inside the\n# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>\n# to select a filter and <Enter> or <escape> to activate or cancel the filter\n# option.\n# The default value is: YES.\n# This tag requires that the tag GENERATE_HTML is set to YES.\n\nSEARCHENGINE           = YES\n\n# When the SERVER_BASED_SEARCH tag is enabled the search engine will be\n# implemented using a web server instead of a web client using JavaScript. There\n# are two flavors of web server based searching depending on the EXTERNAL_SEARCH\n# setting. When disabled, doxygen will generate a PHP script for searching and\n# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing\n# and searching needs to be provided by external tools. See the section\n# \"External Indexing and Searching\" for details.\n# The default value is: NO.\n# This tag requires that the tag SEARCHENGINE is set to YES.\n\nSERVER_BASED_SEARCH    = NO\n\n# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP\n# script for searching. Instead the search results are written to an XML file\n# which needs to be processed by an external indexer. Doxygen will invoke an\n# external search engine pointed to by the SEARCHENGINE_URL option to obtain the\n# search results.\n#\n# Doxygen ships with an example indexer (doxyindexer) and search engine\n# (doxysearch.cgi) which are based on the open source search engine library\n# Xapian (see:\n# https://xapian.org/).\n#\n# See the section \"External Indexing and Searching\" for details.\n# The default value is: NO.\n# This tag requires that the tag SEARCHENGINE is set to YES.\n\nEXTERNAL_SEARCH        = NO\n\n# The SEARCHENGINE_URL should point to a search engine hosted by a web server\n# which will return the search results when EXTERNAL_SEARCH is enabled.\n#\n# Doxygen ships with an example indexer (doxyindexer) and search engine\n# (doxysearch.cgi) which are based on the open source search engine library\n# Xapian (see:\n# https://xapian.org/). See the section \"External Indexing and Searching\" for\n# details.\n# This tag requires that the tag SEARCHENGINE is set to YES.\n\nSEARCHENGINE_URL       =\n\n# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed\n# search data is written to a file for indexing by an external tool. With the\n# SEARCHDATA_FILE tag the name of this file can be specified.\n# The default file is: searchdata.xml.\n# This tag requires that the tag SEARCHENGINE is set to YES.\n\nSEARCHDATA_FILE        = searchdata.xml\n\n# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the\n# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is\n# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple\n# projects and redirect the results back to the right project.\n# This tag requires that the tag SEARCHENGINE is set to YES.\n\nEXTERNAL_SEARCH_ID     =\n\n# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen\n# projects other than the one defined by this configuration file, but that are\n# all added to the same external search index. Each project needs to have a\n# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of\n# to a relative location where the documentation can be found. The format is:\n# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...\n# This tag requires that the tag SEARCHENGINE is set to YES.\n\nEXTRA_SEARCH_MAPPINGS  =\n\n#---------------------------------------------------------------------------\n# Configuration options related to the LaTeX output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.\n# The default value is: YES.\n\nGENERATE_LATEX         = NO\n\n# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a\n# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of\n# it.\n# The default directory is: latex.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_OUTPUT           = latex\n\n# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be\n# invoked.\n#\n# Note that when not enabling USE_PDFLATEX the default is latex when enabling\n# USE_PDFLATEX the default is pdflatex and when in the later case latex is\n# chosen this is overwritten by pdflatex. For specific output languages the\n# default can have been set differently, this depends on the implementation of\n# the output language.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_CMD_NAME         = latex\n\n# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate\n# index for LaTeX.\n# Note: This tag is used in the Makefile / make.bat.\n# See also: LATEX_MAKEINDEX_CMD for the part in the generated output file\n# (.tex).\n# The default file is: makeindex.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nMAKEINDEX_CMD_NAME     = makeindex\n\n# The LATEX_MAKEINDEX_CMD tag can be used to specify the command name to\n# generate index for LaTeX. In case there is no backslash (\\) as first character\n# it will be automatically added in the LaTeX code.\n# Note: This tag is used in the generated output file (.tex).\n# See also: MAKEINDEX_CMD_NAME for the part in the Makefile / make.bat.\n# The default value is: makeindex.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_MAKEINDEX_CMD    = makeindex\n\n# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX\n# documents. This may be useful for small projects and may help to save some\n# trees in general.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nCOMPACT_LATEX          = NO\n\n# The PAPER_TYPE tag can be used to set the paper type that is used by the\n# printer.\n# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x\n# 14 inches) and executive (7.25 x 10.5 inches).\n# The default value is: a4.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nPAPER_TYPE             = a4\n\n# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names\n# that should be included in the LaTeX output. The package can be specified just\n# by its name or with the correct syntax as to be used with the LaTeX\n# \\usepackage command. To get the times font for instance you can specify :\n# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}\n# To use the option intlimits with the amsmath package you can specify:\n# EXTRA_PACKAGES=[intlimits]{amsmath}\n# If left blank no extra packages will be included.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nEXTRA_PACKAGES         =\n\n# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the\n# generated LaTeX document. The header should contain everything until the first\n# chapter. If it is left blank doxygen will generate a standard header. See\n# section \"Doxygen usage\" for information on how to let doxygen write the\n# default header to a separate file.\n#\n# Note: Only use a user-defined header if you know what you are doing! The\n# following commands have a special meaning inside the header: $title,\n# $datetime, $date, $doxygenversion, $projectname, $projectnumber,\n# $projectbrief, $projectlogo. Doxygen will replace $title with the empty\n# string, for the replacement values of the other commands the user is referred\n# to HTML_HEADER.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_HEADER           =\n\n# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the\n# generated LaTeX document. The footer should contain everything after the last\n# chapter. If it is left blank doxygen will generate a standard footer. See\n# LATEX_HEADER for more information on how to generate a default footer and what\n# special commands can be used inside the footer.\n#\n# Note: Only use a user-defined footer if you know what you are doing!\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_FOOTER           =\n\n# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined\n# LaTeX style sheets that are included after the standard style sheets created\n# by doxygen. Using this option one can overrule certain style aspects. Doxygen\n# will copy the style sheet files to the output directory.\n# Note: The order of the extra style sheet files is of importance (e.g. the last\n# style sheet in the list overrules the setting of the previous ones in the\n# list).\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_EXTRA_STYLESHEET =\n\n# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or\n# other source files which should be copied to the LATEX_OUTPUT output\n# directory. Note that the files will be copied as-is; there are no commands or\n# markers available.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_EXTRA_FILES      =\n\n# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is\n# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will\n# contain links (just like the HTML output) instead of page references. This\n# makes the output suitable for online browsing using a PDF viewer.\n# The default value is: YES.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nPDF_HYPERLINKS         = YES\n\n# If the USE_PDFLATEX tag is set to YES, doxygen will use the engine as\n# specified with LATEX_CMD_NAME to generate the PDF file directly from the LaTeX\n# files. Set this option to YES, to get a higher quality PDF documentation.\n#\n# See also section LATEX_CMD_NAME for selecting the engine.\n# The default value is: YES.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nUSE_PDFLATEX           = YES\n\n# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode\n# command to the generated LaTeX files. This will instruct LaTeX to keep running\n# if errors occur, instead of asking the user for help. This option is also used\n# when generating formulas in HTML.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_BATCHMODE        = NO\n\n# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the\n# index chapters (such as File Index, Compound Index, etc.) in the output.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_HIDE_INDICES     = NO\n\n# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source\n# code with syntax highlighting in the LaTeX output.\n#\n# Note that which sources are shown also depends on other settings such as\n# SOURCE_BROWSER.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_SOURCE_CODE      = NO\n\n# The LATEX_BIB_STYLE tag can be used to specify the style to use for the\n# bibliography, e.g. plainnat, or ieeetr. See\n# https://en.wikipedia.org/wiki/BibTeX and \\cite for more info.\n# The default value is: plain.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_BIB_STYLE        = plain\n\n# If the LATEX_TIMESTAMP tag is set to YES then the footer of each generated\n# page will contain the date and time when the page was generated. Setting this\n# to NO can help when comparing the output of multiple runs.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_TIMESTAMP        = NO\n\n# The LATEX_EMOJI_DIRECTORY tag is used to specify the (relative or absolute)\n# path from which the emoji images will be read. If a relative path is entered,\n# it will be relative to the LATEX_OUTPUT directory. If left blank the\n# LATEX_OUTPUT directory will be used.\n# This tag requires that the tag GENERATE_LATEX is set to YES.\n\nLATEX_EMOJI_DIRECTORY  =\n\n#---------------------------------------------------------------------------\n# Configuration options related to the RTF output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The\n# RTF output is optimized for Word 97 and may not look too pretty with other RTF\n# readers/editors.\n# The default value is: NO.\n\nGENERATE_RTF           = NO\n\n# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a\n# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of\n# it.\n# The default directory is: rtf.\n# This tag requires that the tag GENERATE_RTF is set to YES.\n\nRTF_OUTPUT             = rtf\n\n# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF\n# documents. This may be useful for small projects and may help to save some\n# trees in general.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_RTF is set to YES.\n\nCOMPACT_RTF            = NO\n\n# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will\n# contain hyperlink fields. The RTF file will contain links (just like the HTML\n# output) instead of page references. This makes the output suitable for online\n# browsing using Word or some other Word compatible readers that support those\n# fields.\n#\n# Note: WordPad (write) and others do not support links.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_RTF is set to YES.\n\nRTF_HYPERLINKS         = NO\n\n# Load stylesheet definitions from file. Syntax is similar to doxygen's\n# configuration file, i.e. a series of assignments. You only have to provide\n# replacements, missing definitions are set to their default value.\n#\n# See also section \"Doxygen usage\" for information on how to generate the\n# default style sheet that doxygen normally uses.\n# This tag requires that the tag GENERATE_RTF is set to YES.\n\nRTF_STYLESHEET_FILE    =\n\n# Set optional variables used in the generation of an RTF document. Syntax is\n# similar to doxygen's configuration file. A template extensions file can be\n# generated using doxygen -e rtf extensionFile.\n# This tag requires that the tag GENERATE_RTF is set to YES.\n\nRTF_EXTENSIONS_FILE    =\n\n# If the RTF_SOURCE_CODE tag is set to YES then doxygen will include source code\n# with syntax highlighting in the RTF output.\n#\n# Note that which sources are shown also depends on other settings such as\n# SOURCE_BROWSER.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_RTF is set to YES.\n\nRTF_SOURCE_CODE        = NO\n\n#---------------------------------------------------------------------------\n# Configuration options related to the man page output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for\n# classes and files.\n# The default value is: NO.\n\nGENERATE_MAN           = NO\n\n# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a\n# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of\n# it. A directory man3 will be created inside the directory specified by\n# MAN_OUTPUT.\n# The default directory is: man.\n# This tag requires that the tag GENERATE_MAN is set to YES.\n\nMAN_OUTPUT             = man\n\n# The MAN_EXTENSION tag determines the extension that is added to the generated\n# man pages. In case the manual section does not start with a number, the number\n# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is\n# optional.\n# The default value is: .3.\n# This tag requires that the tag GENERATE_MAN is set to YES.\n\nMAN_EXTENSION          = .3\n\n# The MAN_SUBDIR tag determines the name of the directory created within\n# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by\n# MAN_EXTENSION with the initial . removed.\n# This tag requires that the tag GENERATE_MAN is set to YES.\n\nMAN_SUBDIR             =\n\n# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it\n# will generate one additional man file for each entity documented in the real\n# man page(s). These additional files only source the real man page, but without\n# them the man command would be unable to find the correct page.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_MAN is set to YES.\n\nMAN_LINKS              = NO\n\n#---------------------------------------------------------------------------\n# Configuration options related to the XML output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that\n# captures the structure of the code including all documentation.\n# The default value is: NO.\n\nGENERATE_XML           = NO\n\n# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a\n# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of\n# it.\n# The default directory is: xml.\n# This tag requires that the tag GENERATE_XML is set to YES.\n\nXML_OUTPUT             = xml\n\n# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program\n# listings (including syntax highlighting and cross-referencing information) to\n# the XML output. Note that enabling this will significantly increase the size\n# of the XML output.\n# The default value is: YES.\n# This tag requires that the tag GENERATE_XML is set to YES.\n\nXML_PROGRAMLISTING     = YES\n\n# If the XML_NS_MEMB_FILE_SCOPE tag is set to YES, doxygen will include\n# namespace members in file scope as well, matching the HTML output.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_XML is set to YES.\n\nXML_NS_MEMB_FILE_SCOPE = NO\n\n#---------------------------------------------------------------------------\n# Configuration options related to the DOCBOOK output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files\n# that can be used to generate PDF.\n# The default value is: NO.\n\nGENERATE_DOCBOOK       = NO\n\n# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.\n# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in\n# front of it.\n# The default directory is: docbook.\n# This tag requires that the tag GENERATE_DOCBOOK is set to YES.\n\nDOCBOOK_OUTPUT         = docbook\n\n# If the DOCBOOK_PROGRAMLISTING tag is set to YES, doxygen will include the\n# program listings (including syntax highlighting and cross-referencing\n# information) to the DOCBOOK output. Note that enabling this will significantly\n# increase the size of the DOCBOOK output.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_DOCBOOK is set to YES.\n\nDOCBOOK_PROGRAMLISTING = NO\n\n#---------------------------------------------------------------------------\n# Configuration options for the AutoGen Definitions output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an\n# AutoGen Definitions (see http://autogen.sourceforge.net/) file that captures\n# the structure of the code including all documentation. Note that this feature\n# is still experimental and incomplete at the moment.\n# The default value is: NO.\n\nGENERATE_AUTOGEN_DEF   = NO\n\n#---------------------------------------------------------------------------\n# Configuration options related to Sqlite3 output\n#---------------------------------------------------------------------------\n\n#---------------------------------------------------------------------------\n# Configuration options related to the Perl module output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module\n# file that captures the structure of the code including all documentation.\n#\n# Note that this feature is still experimental and incomplete at the moment.\n# The default value is: NO.\n\nGENERATE_PERLMOD       = NO\n\n# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary\n# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI\n# output from the Perl module output.\n# The default value is: NO.\n# This tag requires that the tag GENERATE_PERLMOD is set to YES.\n\nPERLMOD_LATEX          = NO\n\n# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely\n# formatted so it can be parsed by a human reader. This is useful if you want to\n# understand what is going on. On the other hand, if this tag is set to NO, the\n# size of the Perl module output will be much smaller and Perl will parse it\n# just the same.\n# The default value is: YES.\n# This tag requires that the tag GENERATE_PERLMOD is set to YES.\n\nPERLMOD_PRETTY         = YES\n\n# The names of the make variables in the generated doxyrules.make file are\n# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful\n# so different doxyrules.make files included by the same Makefile don't\n# overwrite each other's variables.\n# This tag requires that the tag GENERATE_PERLMOD is set to YES.\n\nPERLMOD_MAKEVAR_PREFIX =\n\n#---------------------------------------------------------------------------\n# Configuration options related to the preprocessor\n#---------------------------------------------------------------------------\n\n# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all\n# C-preprocessor directives found in the sources and include files.\n# The default value is: YES.\n\nENABLE_PREPROCESSING   = YES\n\n# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names\n# in the source code. If set to NO, only conditional compilation will be\n# performed. Macro expansion can be done in a controlled way by setting\n# EXPAND_ONLY_PREDEF to YES.\n# The default value is: NO.\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\n\nMACRO_EXPANSION        = NO\n\n# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then\n# the macro expansion is limited to the macros specified with the PREDEFINED and\n# EXPAND_AS_DEFINED tags.\n# The default value is: NO.\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\n\nEXPAND_ONLY_PREDEF     = NO\n\n# If the SEARCH_INCLUDES tag is set to YES, the include files in the\n# INCLUDE_PATH will be searched if a #include is found.\n# The default value is: YES.\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\n\nSEARCH_INCLUDES        = YES\n\n# The INCLUDE_PATH tag can be used to specify one or more directories that\n# contain include files that are not input files but should be processed by the\n# preprocessor.\n# This tag requires that the tag SEARCH_INCLUDES is set to YES.\n\nINCLUDE_PATH           =\n\n# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard\n# patterns (like *.h and *.hpp) to filter out the header-files in the\n# directories. If left blank, the patterns specified with FILE_PATTERNS will be\n# used.\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\n\nINCLUDE_FILE_PATTERNS  =\n\n# The PREDEFINED tag can be used to specify one or more macro names that are\n# defined before the preprocessor is started (similar to the -D option of e.g.\n# gcc). The argument of the tag is a list of macros of the form: name or\n# name=definition (no spaces). If the definition and the \"=\" are omitted, \"=1\"\n# is assumed. To prevent a macro definition from being undefined via #undef or\n# recursively expanded use the := operator instead of the = operator.\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\n\nPREDEFINED             = DOXYGEN\n\n# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this\n# tag can be used to specify a list of macro names that should be expanded. The\n# macro definition that is found in the sources will be used. Use the PREDEFINED\n# tag if you want to use a different macro definition that overrules the\n# definition found in the source code.\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\n\nEXPAND_AS_DEFINED      =\n\n# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will\n# remove all references to function-like macros that are alone on a line, have\n# an all uppercase name, and do not end with a semicolon. Such function macros\n# are typically used for boiler-plate code, and will confuse the parser if not\n# removed.\n# The default value is: YES.\n# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.\n\nSKIP_FUNCTION_MACROS   = YES\n\n#---------------------------------------------------------------------------\n# Configuration options related to external references\n#---------------------------------------------------------------------------\n\n# The TAGFILES tag can be used to specify one or more tag files. For each tag\n# file the location of the external documentation should be added. The format of\n# a tag file without this location is as follows:\n# TAGFILES = file1 file2 ...\n# Adding location for the tag files is done as follows:\n# TAGFILES = file1=loc1 \"file2 = loc2\" ...\n# where loc1 and loc2 can be relative or absolute paths or URLs. See the\n# section \"Linking to external documentation\" for more information about the use\n# of tag files.\n# Note: Each tag file must have a unique name (where the name does NOT include\n# the path). If a tag file is not located in the directory in which doxygen is\n# run, you must also specify the path to the tagfile here.\n\nTAGFILES               =\n\n# When a file name is specified after GENERATE_TAGFILE, doxygen will create a\n# tag file that is based on the input files it reads. See section \"Linking to\n# external documentation\" for more information about the usage of tag files.\n\nGENERATE_TAGFILE       =\n\n# If the ALLEXTERNALS tag is set to YES, all external class will be listed in\n# the class index. If set to NO, only the inherited external classes will be\n# listed.\n# The default value is: NO.\n\nALLEXTERNALS           = NO\n\n# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed\n# in the modules index. If set to NO, only the current project's groups will be\n# listed.\n# The default value is: YES.\n\nEXTERNAL_GROUPS        = YES\n\n# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in\n# the related pages index. If set to NO, only the current project's pages will\n# be listed.\n# The default value is: YES.\n\nEXTERNAL_PAGES         = YES\n\n#---------------------------------------------------------------------------\n# Configuration options related to the dot tool\n#---------------------------------------------------------------------------\n\n# If the CLASS_DIAGRAMS tag is set to YES, doxygen will generate a class diagram\n# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to\n# NO turns the diagrams off. Note that this option also works with HAVE_DOT\n# disabled, but it is recommended to install and use dot, since it yields more\n# powerful graphs.\n# The default value is: YES.\n\nCLASS_DIAGRAMS         = NO\n\n# You can include diagrams made with dia in doxygen documentation. Doxygen will\n# then run dia to produce the diagram and insert it in the documentation. The\n# DIA_PATH tag allows you to specify the directory where the dia binary resides.\n# If left empty dia is assumed to be found in the default search path.\n\nDIA_PATH               =\n\n# If set to YES the inheritance and collaboration graphs will hide inheritance\n# and usage relations if the target is undocumented or is not a class.\n# The default value is: YES.\n\nHIDE_UNDOC_RELATIONS   = YES\n\n# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is\n# available from the path. This tool is part of Graphviz (see:\n# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent\n# Bell Labs. The other options in this section have no effect if this option is\n# set to NO\n# The default value is: YES.\n\nHAVE_DOT               = NO\n\n# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed\n# to run in parallel. When set to 0 doxygen will base this on the number of\n# processors available in the system. You can set it explicitly to a value\n# larger than 0 to get control over the balance between CPU load and processing\n# speed.\n# Minimum value: 0, maximum value: 32, default value: 0.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_NUM_THREADS        = 0\n\n# When you want a differently looking font in the dot files that doxygen\n# generates you can specify the font name using DOT_FONTNAME. You need to make\n# sure dot is able to find the font, which can be done by putting it in a\n# standard location or by setting the DOTFONTPATH environment variable or by\n# setting DOT_FONTPATH to the directory containing the font.\n# The default value is: Helvetica.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_FONTNAME           = Helvetica\n\n# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of\n# dot graphs.\n# Minimum value: 4, maximum value: 24, default value: 10.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_FONTSIZE           = 10\n\n# By default doxygen will tell dot to use the default font as specified with\n# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set\n# the path where dot can find it using this tag.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_FONTPATH           =\n\n# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for\n# each documented class showing the direct and indirect inheritance relations.\n# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nCLASS_GRAPH            = YES\n\n# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a\n# graph for each documented class showing the direct and indirect implementation\n# dependencies (inheritance, containment, and class references variables) of the\n# class with other documented classes.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nCOLLABORATION_GRAPH    = YES\n\n# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for\n# groups, showing the direct groups dependencies.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nGROUP_GRAPHS           = YES\n\n# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and\n# collaboration diagrams in a style similar to the OMG's Unified Modeling\n# Language.\n# The default value is: NO.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nUML_LOOK               = NO\n\n# If the UML_LOOK tag is enabled, the fields and methods are shown inside the\n# class node. If there are many fields or methods and many nodes the graph may\n# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the\n# number of items for each type to make the size more manageable. Set this to 0\n# for no limit. Note that the threshold may be exceeded by 50% before the limit\n# is enforced. So when you set the threshold to 10, up to 15 fields may appear,\n# but if the number exceeds 15, the total amount of fields shown is limited to\n# 10.\n# Minimum value: 0, maximum value: 100, default value: 10.\n# This tag requires that the tag UML_LOOK is set to YES.\n\nUML_LIMIT_NUM_FIELDS   = 10\n\n# If the DOT_UML_DETAILS tag is set to NO, doxygen will show attributes and\n# methods without types and arguments in the UML graphs. If the DOT_UML_DETAILS\n# tag is set to YES, doxygen will add type and arguments for attributes and\n# methods in the UML graphs. If the DOT_UML_DETAILS tag is set to NONE, doxygen\n# will not generate fields with class member information in the UML graphs. The\n# class diagrams will look similar to the default class diagrams but using UML\n# notation for the relationships.\n# Possible values are: NO, YES and NONE.\n# The default value is: NO.\n# This tag requires that the tag UML_LOOK is set to YES.\n\nDOT_UML_DETAILS        = NO\n\n# The DOT_WRAP_THRESHOLD tag can be used to set the maximum number of characters\n# to display on a single line. If the actual line length exceeds this threshold\n# significantly it will wrapped across multiple lines. Some heuristics are apply\n# to avoid ugly line breaks.\n# Minimum value: 0, maximum value: 1000, default value: 17.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_WRAP_THRESHOLD     = 17\n\n# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and\n# collaboration graphs will show the relations between templates and their\n# instances.\n# The default value is: NO.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nTEMPLATE_RELATIONS     = NO\n\n# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to\n# YES then doxygen will generate a graph for each documented file showing the\n# direct and indirect include dependencies of the file with other documented\n# files.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nINCLUDE_GRAPH          = YES\n\n# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are\n# set to YES then doxygen will generate a graph for each documented file showing\n# the direct and indirect include dependencies of the file with other documented\n# files.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nINCLUDED_BY_GRAPH      = YES\n\n# If the CALL_GRAPH tag is set to YES then doxygen will generate a call\n# dependency graph for every global function or class method.\n#\n# Note that enabling this option will significantly increase the time of a run.\n# So in most cases it will be better to enable call graphs for selected\n# functions only using the \\callgraph command. Disabling a call graph can be\n# accomplished by means of the command \\hidecallgraph.\n# The default value is: NO.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nCALL_GRAPH             = YES\n\n# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller\n# dependency graph for every global function or class method.\n#\n# Note that enabling this option will significantly increase the time of a run.\n# So in most cases it will be better to enable caller graphs for selected\n# functions only using the \\callergraph command. Disabling a caller graph can be\n# accomplished by means of the command \\hidecallergraph.\n# The default value is: NO.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nCALLER_GRAPH           = YES\n\n# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical\n# hierarchy of all classes instead of a textual one.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nGRAPHICAL_HIERARCHY    = YES\n\n# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the\n# dependencies a directory has on other directories in a graphical way. The\n# dependency relations are determined by the #include relations between the\n# files in the directories.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDIRECTORY_GRAPH        = YES\n\n# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images\n# generated by dot. For an explanation of the image formats see the section\n# output formats in the documentation of the dot tool (Graphviz (see:\n# http://www.graphviz.org/)).\n# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order\n# to make the SVG files visible in IE 9+ (other browsers do not have this\n# requirement).\n# Possible values are: png, png:cairo, png:cairo:cairo, png:cairo:gd, png:gd,\n# png:gd:gd, jpg, jpg:cairo, jpg:cairo:gd, jpg:gd, jpg:gd:gd, gif, gif:cairo,\n# gif:cairo:gd, gif:gd, gif:gd:gd, svg, png:gd, png:gd:gd, png:cairo,\n# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and\n# png:gdiplus:gdiplus.\n# The default value is: png.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_IMAGE_FORMAT       = svg\n\n# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to\n# enable generation of interactive SVG images that allow zooming and panning.\n#\n# Note that this requires a modern browser other than Internet Explorer. Tested\n# and working are Firefox, Chrome, Safari, and Opera.\n# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make\n# the SVG files visible. Older versions of IE do not have SVG support.\n# The default value is: NO.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nINTERACTIVE_SVG        = YES\n\n# The DOT_PATH tag can be used to specify the path where the dot tool can be\n# found. If left blank, it is assumed the dot tool can be found in the path.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_PATH               =\n\n# The DOTFILE_DIRS tag can be used to specify one or more directories that\n# contain dot files that are included in the documentation (see the \\dotfile\n# command).\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOTFILE_DIRS           =\n\n# The MSCFILE_DIRS tag can be used to specify one or more directories that\n# contain msc files that are included in the documentation (see the \\mscfile\n# command).\n\nMSCFILE_DIRS           =\n\n# The DIAFILE_DIRS tag can be used to specify one or more directories that\n# contain dia files that are included in the documentation (see the \\diafile\n# command).\n\nDIAFILE_DIRS           =\n\n# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the\n# path where java can find the plantuml.jar file. If left blank, it is assumed\n# PlantUML is not used or called during a preprocessing step. Doxygen will\n# generate a warning when it encounters a \\startuml command in this case and\n# will not generate output for the diagram.\n\nPLANTUML_JAR_PATH      =\n\n# When using plantuml, the PLANTUML_CFG_FILE tag can be used to specify a\n# configuration file for plantuml.\n\nPLANTUML_CFG_FILE      =\n\n# When using plantuml, the specified paths are searched for files specified by\n# the !include statement in a plantuml block.\n\nPLANTUML_INCLUDE_PATH  =\n\n# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes\n# that will be shown in the graph. If the number of nodes in a graph becomes\n# larger than this value, doxygen will truncate the graph, which is visualized\n# by representing a node as a red box. Note that doxygen if the number of direct\n# children of the root node in a graph is already larger than\n# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that\n# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.\n# Minimum value: 0, maximum value: 10000, default value: 50.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_GRAPH_MAX_NODES    = 50\n\n# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs\n# generated by dot. A depth value of 3 means that only nodes reachable from the\n# root by following a path via at most 3 edges will be shown. Nodes that lay\n# further from the root node will be omitted. Note that setting this option to 1\n# or 2 may greatly reduce the computation time needed for large code bases. Also\n# note that the size of a graph can be further restricted by\n# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.\n# Minimum value: 0, maximum value: 1000, default value: 0.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nMAX_DOT_GRAPH_DEPTH    = 0\n\n# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent\n# background. This is disabled by default, because dot on Windows does not seem\n# to support this out of the box.\n#\n# Warning: Depending on the platform used, enabling this option may lead to\n# badly anti-aliased labels on the edges of a graph (i.e. they become hard to\n# read).\n# The default value is: NO.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_TRANSPARENT        = NO\n\n# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output\n# files in one run (i.e. multiple -o and -T options on the command line). This\n# makes dot run faster, but since only newer versions of dot (>1.8.10) support\n# this, this feature is disabled by default.\n# The default value is: NO.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nDOT_MULTI_TARGETS      = YES\n\n# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page\n# explaining the meaning of the various boxes and arrows in the dot generated\n# graphs.\n# The default value is: YES.\n# This tag requires that the tag HAVE_DOT is set to YES.\n\nGENERATE_LEGEND        = YES\n\n# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate\n# files that are used to generate the various graphs.\n#\n# Note: This setting is not only used for dot files but also for msc and\n# plantuml temporary files.\n# The default value is: YES.\n\nDOT_CLEANUP            = YES\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 8.052734375,
          "content": "HAVE_FILE_LOGGER=1\nNEED_CXX_LINKER?=0\nNEED_GOLD_LINKER?=0\nMISSING_DECLS   =0\n\nifneq ($(C90_BUILD),)\n   C89_BUILD=1\nendif\n\ninclude config.mk\n\n# Put your favorite compile flags in this file, if you want different defaults than upstream.\n# Do not attempt to create that file upstream.\n# (It'd be better to put this comment in that file, but .gitignore doesn't work on files that exist in the repo.)\n-include Makefile.local\n\nifeq ($(HAVE_ANGLE), 1)\nTARGET = retroarch_angle\nelse\nTARGET = retroarch\nendif\n\nOBJ :=\nLIBS :=\nDEF_FLAGS := -I.\nASFLAGS :=\nDEFINES := -DHAVE_CONFIG_H -DRARCH_INTERNAL -D_FILE_OFFSET_BITS=64\nDEFINES += -DGLOBAL_CONFIG_DIR='\"$(GLOBAL_CONFIG_DIR)\"'\nDEFINES += -DASSETS_DIR='\"$(DESTDIR)$(ASSETS_DIR)\"'\nDEFINES += -DFILTERS_DIR='\"$(DESTDIR)$(FILTERS_DIR)\"'\nDEFINES += -DCORE_INFO_DIR='\"$(DESTDIR)$(CORE_INFO_DIR)\"'\n\nOBJDIR_BASE := obj-unix\n\nifeq ($(NEED_GOLD_LINKER), 1)\n   LDFLAGS += -fuse-ld=gold\nendif\n\nifeq ($(DEBUG), 1)\n   OBJDIR := $(OBJDIR_BASE)/debug\n   CFLAGS ?= -O0 -g\n   CXXFLAGS ?= -O0 -g\n   DEFINES += -DDEBUG -D_DEBUG\nelse\n   OBJDIR := $(OBJDIR_BASE)/release\n   CFLAGS ?= -O3\n   CXXFLAGS ?= -O3\n   DEF_FLAGS += -ffast-math\nendif\n\nDEF_FLAGS += -Wall -Wsign-compare\n\nifneq ($(findstring BSD,$(OS)),)\n   DEF_FLAGS += -DBSD\n   LDFLAGS += -L/usr/local/lib\n   UDEV_CFLAGS += -I/usr/local/include/libepoll-shim\n   UDEV_LIBS += -lepoll-shim\nendif\n\nifneq ($(findstring DOS,$(OS)),)\n   DEF_FLAGS += -march=i386\n   LDFLAGS += -lemu\nendif\n\nifneq ($(findstring FPGA,$(OS)),)\n   DEFINES += -DHAVE_FPGA\nendif\n\nifneq ($(findstring Win32,$(OS)),)\n   LDFLAGS += -static-libgcc -lwinmm -limm32\nendif\n\ninclude Makefile.common\n\nifeq ($(shell $(CC) -v 2>&1 | grep -c \"clang\"),1)\n   DEF_FLAGS += -Wno-invalid-source-encoding -Wno-incompatible-ms-struct\nendif\n\nifeq ($(shell $(CC) -v 2>&1 | grep -c \"tcc\"),1)\n   MD = -MD\nelse\n   MD = -MMD\nendif\n\nHEADERS = $(wildcard */*/*.h) $(wildcard */*.h) $(wildcard *.h)\n\nifeq ($(MISSING_DECLS), 1)\n   DEF_FLAGS += -Werror=missing-declarations\nendif\n\nifeq ($(HAVE_DYLIB), 1)\n   LIBS += $(DYLIB_LIB)\nendif\n\nifeq ($(HAVE_DYNAMIC), 1)\n   LIBS += $(DYLIB_LIB)\nelse\n   LIBS += $(libretro)\nendif\n\nifneq ($(V),1)\n   Q := @\nendif\n\nifeq ($(HAVE_DRMINGW), 1)\n   DEF_FLAGS += -DHAVE_DRMINGW\n   LDFLAGS += $(DRMINGW_LIBS)\nendif\n\nifneq ($(findstring Win32,$(OS)),)\n   LDFLAGS += -mwindows\nendif\n\nifneq ($(CXX_BUILD), 1)\n   ifneq ($(C89_BUILD),)\n      CFLAGS += -std=c89 -ansi -pedantic -Werror=pedantic -Wno-long-long -Werror=declaration-after-statement\n   else ifeq ($(HAVE_C99), 1)\n      CFLAGS += $(C99_CFLAGS)\n   endif\n\n   CFLAGS += -D_GNU_SOURCE\nendif\n\nDEF_FLAGS += $(INCLUDE_DIRS) -Ideps -Ideps/stb\n\nCFLAGS += $(DEF_FLAGS)\nCXXFLAGS += $(DEF_FLAGS) -D__STDC_CONSTANT_MACROS\nOBJCFLAGS :=  $(CFLAGS) -D__STDC_CONSTANT_MACROS\n\nifeq ($(HAVE_CXX), 1)\n   ifeq ($(CXX_BUILD), 1)\n      LINK = $(CXX)\n      CFLAGS   := $(CXXFLAGS) -xc++\n      CFLAGS   += -DCXX_BUILD\n      CXXFLAGS += -DCXX_BUILD\n   else ifeq ($(NEED_CXX_LINKER),1)\n      LINK = $(CXX)\n   else\n      LINK = $(CC)\n   endif\nelse\n   LINK = $(CC)\nendif\n\nRARCH_OBJ := $(addprefix $(OBJDIR)/,$(OBJ))\n\nifneq ($(X86),)\n   CFLAGS += -m32\n   CXXFLAGS += -m32\n   LDFLAGS += -m32\nendif\n\nifneq ($(SANITIZER),)\n   CFLAGS   := -fsanitize=$(SANITIZER) $(CFLAGS)\n   CXXFLAGS := -fsanitize=$(SANITIZER) $(CXXFLAGS)\n   LDFLAGS  := -fsanitize=$(SANITIZER) $(LDFLAGS)\nendif\n\nifneq ($(findstring $(GPERFTOOLS),profiler),)\n   LIBS += -lprofiler\nendif\nifneq ($(findstring $(GPERFTOOLS),tcmalloc),)\n   LIBS += -ltcmalloc\nendif\n\n# Qt MOC generation, required for QObject-derived classes\nifneq ($(MOC_HEADERS),)\n    # prefix moc_ to base filename of paths and change extension from h to cpp, so a/b/foo.h becomes a/b/moc_foo.cpp\n    MOC_SRC := $(join $(addsuffix moc_,$(addprefix $(OBJDIR)/,$(dir $(MOC_HEADERS)))), $(notdir $(MOC_HEADERS:.h=.cpp)))\n    MOC_OBJ := $(patsubst %.cpp,%.o,$(MOC_SRC))\n    RARCH_OBJ += $(MOC_OBJ)\nendif\n\nall: $(TARGET) config.mk\n\n$(MOC_SRC):\n\t@$(if $(Q), $(shell echo echo MOC $<),)\n\t$(eval MOC_TMP := $(patsubst %.h,%_moc.cpp,$@))\n\t$(Q)QT_SELECT=$(QT_VERSION) $(MOC) -o $(MOC_TMP) $<\n\n$(foreach x,$(join $(addsuffix :,$(MOC_SRC)),$(MOC_HEADERS)),$(eval $x))\n\n$(MOC_OBJ):\n\t@$(if $(Q), $(shell echo echo CXX $<),)\n\t$(Q)$(CXX) $(CPPFLAGS) $(CXXFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(foreach x,$(join $(addsuffix :,$(MOC_OBJ)),$(MOC_SRC)),$(eval $x))\n\nifeq ($(MAKECMDGOALS),clean)\nconfig.mk:\nelse\n-include $(RARCH_OBJ:.o=.d)\nifeq ($(HAVE_CONFIG_MK),)\nconfig.mk: configure qb/*\n\t@echo \"config.mk is outdated or non-existing. Run ./configure again.\"\n\t@exit 1\nendif\nendif\n\nSYMBOL_MAP := -Wl,-Map=output.map\n\n$(TARGET): $(RARCH_OBJ)\n\t@$(if $(Q), $(shell echo echo LD $@),)\n\t$(Q)$(LINK) -o $@ $(RARCH_OBJ) $(LIBS) $(LDFLAGS) $(LIBRARY_DIRS)\n\n$(OBJDIR)/%.o: %.c config.h config.mk\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CC $<),)\n\t$(Q)$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) $(MD) -c -o $@ $<\n\n$(OBJDIR)/%.o: %.cpp config.h config.mk\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CXX $<),)\n\t$(Q)$(CXX) $(CPPFLAGS) $(CXXFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.m\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo OBJC $<),)\n\t$(Q)$(CXX) $(OBJCFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.S config.h config.mk $(HEADERS)\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo AS $<),)\n\t$(Q)$(CC) $(CFLAGS) $(ASFLAGS) $(DEFINES) -c -o $@ $<\n\n$(OBJDIR)/%.o: %.rc $(HEADERS)\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo WINDRES $<),)\n\t$(Q)$(WINDRES) $(DEFINES) -o $@ $<\n\ninstall: $(TARGET)\n\tmkdir -p $(DESTDIR)$(BIN_DIR) 2>/dev/null || /bin/true\n\tmkdir -p $(DESTDIR)$(GLOBAL_CONFIG_DIR) 2>/dev/null || /bin/true\n\tmkdir -p $(DESTDIR)$(DATA_DIR)/applications 2>/dev/null || /bin/true\n\tmkdir -p $(DESTDIR)$(DATA_DIR)/metainfo 2>/dev/null || /bin/true\n\tmkdir -p $(DESTDIR)$(DOC_DIR) 2>/dev/null || /bin/true\n\tmkdir -p $(DESTDIR)$(MAN_DIR)/man6 2>/dev/null || /bin/true\n\tmkdir -p $(DESTDIR)$(DATA_DIR)/pixmaps 2>/dev/null || /bin/true\n\tcp $(TARGET) $(DESTDIR)$(BIN_DIR)\n\tcp tools/cg2glsl.py $(DESTDIR)$(BIN_DIR)/retroarch-cg2glsl\n\tcp retroarch.cfg $(DESTDIR)$(GLOBAL_CONFIG_DIR)\n\tcp com.libretro.RetroArch.metainfo.xml $(DESTDIR)$(DATA_DIR)/metainfo\n\tcp com.libretro.RetroArch.desktop $(DESTDIR)$(DATA_DIR)/applications\n\tcp docs/retroarch.6 $(DESTDIR)$(MAN_DIR)/man6\n\tcp docs/retroarch-cg2glsl.6 $(DESTDIR)$(MAN_DIR)/man6\n\tcp media/com.libretro.RetroArch.svg $(DESTDIR)$(DATA_DIR)/pixmaps\n\tcp COPYING $(DESTDIR)$(DOC_DIR)\n\tcp README.md $(DESTDIR)$(DOC_DIR)\n\tchmod 755 $(DESTDIR)$(BIN_DIR)/$(TARGET)\n\tchmod 755 $(DESTDIR)$(BIN_DIR)/retroarch-cg2glsl\n\tchmod 644 $(DESTDIR)$(GLOBAL_CONFIG_DIR)/retroarch.cfg\n\tchmod 644 $(DESTDIR)$(DATA_DIR)/applications/com.libretro.RetroArch.desktop\n\tchmod 644 $(DESTDIR)$(DATA_DIR)/metainfo/com.libretro.RetroArch.metainfo.xml\n\tchmod 644 $(DESTDIR)$(MAN_DIR)/man6/retroarch.6\n\tchmod 644 $(DESTDIR)$(MAN_DIR)/man6/retroarch-cg2glsl.6\n\tchmod 644 $(DESTDIR)$(DATA_DIR)/pixmaps/com.libretro.RetroArch.svg\n\t@if test -d media/assets && test $(HAVE_ASSETS); then \\\n\t\techo \"Installing media assets...\"; \\\n\t\tmkdir -p $(DESTDIR)$(ASSETS_DIR)/assets; \\\n\t\tif test $(HAVE_MATERIALUI) = 1; then \\\n\t\t\tcp -r media/assets/glui/ $(DESTDIR)$(ASSETS_DIR)/assets; \\\n\t\tfi; \\\n\t\tif test $(HAVE_XMB) = 1; then \\\n\t\t\tcp -r media/assets/xmb/ $(DESTDIR)$(ASSETS_DIR)/assets; \\\n\t\tfi; \\\n\t\tif test $(HAVE_OZONE) = 1; then \\\n\t\t\tcp -r media/assets/ozone/ $(DESTDIR)$(ASSETS_DIR)/assets; \\\n\t\tfi; \\\n\t\tcp media/assets/COPYING $(DESTDIR)$(DOC_DIR)/COPYING.assets; \\\n\t\techo \"Asset copying done.\"; \\\n\tfi\n\nuninstall:\n\trm -f $(DESTDIR)$(BIN_DIR)/$(TARGET)\n\trm -f $(DESTDIR)$(BIN_DIR)/retroarch-cg2glsl\n\trm -f $(DESTDIR)$(GLOBAL_CONFIG_DIR)/retroarch.cfg\n\trm -f $(DESTDIR)$(DATA_DIR)/applications/com.libretro.RetroArch.desktop\n\trm -f $(DESTDIR)$(DATA_DIR)/metainfo/com.libretro.RetroArch.metainfo.xml\n\trm -f $(DESTDIR)$(DATA_DIR)/pixmaps/com.libretro.RetroArch.svg\n\trm -f $(DESTDIR)$(DOC_DIR)/COPYING\n\trm -f $(DESTDIR)$(DOC_DIR)/COPYING.assets\n\trm -f $(DESTDIR)$(DOC_DIR)/README.md\n\trm -f $(DESTDIR)$(MAN_DIR)/man6/retroarch.6\n\trm -f $(DESTDIR)$(MAN_DIR)/man6/retroarch-cg2glsl.6\n\trm -rf $(DESTDIR)$(ASSETS_DIR)\n\nclean:\n\trm -rf $(OBJDIR_BASE)\n\trm -f $(TARGET)\n\trm -f *.d\n\n.PHONY: all install uninstall clean\n\nprint-%:\n\t@echo '$*=$($*)'\n"
        },
        {
          "name": "Makefile.apple",
          "type": "blob",
          "size": 0.6279296875,
          "content": "include Makefile.common\n\n# Qt MOC generation, required for QObject-derived classes\nifneq ($(MOC_HEADERS),)\n\t# prefix moc_ to base filename of paths and change extension from h to cpp, so a/b/foo.h becomes a/b/moc_foo.cpp\n\tMOC_SRC := $(join $(addsuffix moc_,$(dir $(MOC_HEADERS))), $(notdir $(MOC_HEADERS:.h=.cpp)))\nendif\n\nMOC ?= $(error missing moc path)\n\n.PHONY: generate\n\n$(MOC_SRC):\n\t@$(if $(Q), $(shell echo echo MOC $<),)\n\t$(eval MOC_TMP := $(patsubst %.h,%_moc.cpp,$@))\n\t$(MOC) -o $(MOC_TMP) $<\n\n$(foreach x,$(join $(addsuffix :,$(MOC_SRC)),$(MOC_HEADERS)),$(eval $x))\n\ngenerate: $(MOC_SRC)\n\t@echo $(MOC_SRC)\n\nprint-%:\n\t@echo '$*=$($*)'\n"
        },
        {
          "name": "Makefile.classic_sega_mini",
          "type": "blob",
          "size": 1.8828125,
          "content": "# This build was put together and is maintained by ModMyClassic.com for Libretro.\n# The purpose is to give Libretro a proper \"official\" build platform for classic consoles.\n# If you need any help in building for the classics or have any questions then please visit\n# https://modmyclassic.com and we will help in any way possible!\n\n# Building Prerequisites ##############\n# arm-linux-gnueabihf-strip\n\ninclude version.all\n\n# General Shared Variables ############\nTARGET := retroarch\n\n# Libretro Defines ####################\n#HAVE_CLASSIC = Classic Hook, disable some features\n#HAVE_C_A7A7 = Classic Armv7 Cortex A7 optimisation override\n#HAVE_SEGAM = Sega Mini Hook, change default configurations etc (TODO)\n\nall: $(TARGET)\n\nretroarch:\n\t#Build the RetroArch Binary for cross platform classics (ARMv7 Cortex A7)\n\tpatchelf --version #Check if you have patchelf installed... (sudo apt-get install patchelf)\n\tCFLAGS=\"-marm -mtune=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard\" ./configure --host=arm-linux-gnueabihf --disable-wayland --disable-x11 --disable-opengl --disable-opengl1 --disable-opengl_core --enable-mali_fbdev --disable-freetype --enable-opengles --enable-udev --enable-alsa --enable-neon --enable-floathard --disable-discord\n\tmake HAVE_CLASSIC=1 HAVE_C_A7A7=1 HAVE_SEGAM=1 -j #Cook it\n\tarm-linux-gnueabihf-strip -v retroarch\n\t@echo \"*********************************************************************\"\n\t@echo \"***   SEGA Mega Drive Mini RetroArch binary built successfully!   ***\"\n\t@echo \"*********************************************************************\"\nclean:\n\trm -rf obj-unix\n\trm -f *.d\n\trm -f *.o\n\trm -f audio/*.o\n\trm -f conf/*.o\n\trm -f gfx/*.o\n\trm -f gfx/drivers_font/*.o\n\trm -f gfx/drivers_font_renderer/*.o\n\trm -f gfx/drivers_context/*.o\n\trm -f gfx/py_state/*.o\n\trm -f compat/*.o\n\trm -f record/*.o\n\trm -f input/*.o\n\trm -f tools/*.o\n\trm -f $(BINDIR)/retroarch\n\trm -f $(PNDDIR)/readme.html\n\trm -f retroarch\n\n"
        },
        {
          "name": "Makefile.classic_snesc",
          "type": "blob",
          "size": 2.0869140625,
          "content": "# This build was put together and is maintained by ModMyClassic.com for Libretro.\n# The purpose is to give Libretro a proper \"official\" build platform for classic consoles.\n# If you need any help in building for the classics or have any questions then please visit\n# https://modmyclassic.com and we will help in any way possible!\n\n# INFO: THIS BUILD TARGET ALSO COVERS THE NESC!!!\n\n# Building Prerequisites ##############\n# arm-linux-gnueabihf-strip\n# patchelf\n\ninclude version.all\n\n# General Shared Variables ############\nTARGET := retroarch\n\n# Libretro Defines ####################\n#HAVE_CLASSIC = Classic Hook, disable some features\n#HAVE_C_A7A7 = Classic Armv7 Cortex A7 optimisation override\n#HAVE_HAKCHI = Hakchi Hook, change default configurations etc (TODO)\n\nall: $(TARGET)\n\nretroarch:\n\t#Build the RetroArch Binary for cross platform classics (ARMv7 Cortex A7)\n\tpatchelf --version #Check if you have patchelf installed... (sudo apt-get install patchelf)\n\tCFLAGS=\"-marm -mtune=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard\" ./configure --host=arm-linux-gnueabihf --disable-wayland --disable-x11 --disable-opengl --disable-opengl1 --disable-opengl_core --enable-mali_fbdev --disable-freetype --enable-opengles --enable-udev --enable-alsa --enable-neon --enable-floathard --disable-discord\n\tmake HAVE_CLASSIC=1 HAVE_C_A7A7=1 HAVE_HAKCHI=1 -j #Cook it\n\tarm-linux-gnueabihf-strip -v retroarch\n\tpatchelf --replace-needed libSDL2-2.0.so.0 libSDL2.so retroarch #libSDL2-2.0.so.0 sym link doesn't exist on native build. Just patch the binary...\n\t@echo \"*********************************************************************\"\n\t@echo \"***     NES/SNES Classic RetroArch binary built successfully!     ***\"\n\t@echo \"*********************************************************************\"\nclean:\n\trm -rf obj-unix\n\trm -f *.d\n\trm -f *.o\n\trm -f audio/*.o\n\trm -f conf/*.o\n\trm -f gfx/*.o\n\trm -f gfx/drivers_font/*.o\n\trm -f gfx/drivers_font_renderer/*.o\n\trm -f gfx/drivers_context/*.o\n\trm -f gfx/py_state/*.o\n\trm -f compat/*.o\n\trm -f record/*.o\n\trm -f input/*.o\n\trm -f tools/*.o\n\trm -f $(BINDIR)/retroarch\n\trm -f $(PNDDIR)/readme.html\n\trm -f retroarch\n\n"
        },
        {
          "name": "Makefile.common",
          "type": "blob",
          "size": 78.6708984375,
          "content": "ROOT_DIR          := .\nDEPS_DIR          := $(ROOT_DIR)/deps\nLIBRETRO_COMM_DIR := $(ROOT_DIR)/libretro-common\nWANT_WGL           = 0\n\nifeq ($(HAVE_STACK_USAGE), 1)\n   DEF_FLAGS += -fstack-usage\nendif\n\nifeq ($(HAVE_NOUNUSED), 1)\n   DEF_FLAGS += $(NOUNUSED_CFLAGS)\nendif\n\nifeq ($(HAVE_NOUNUSED_VARIABLE), 1)\n   DEF_FLAGS += $(NOUNUSED_VARIABLE_CFLAGS)\nendif\n\nifeq ($(HAVE_QT6), 1)\n   CXXFLAGS += $(CXX17_CFLAGS)\nelse ifeq ($(HAVE_CXX11), 1)\n   CXXFLAGS += $(CXX11_CFLAGS)\nendif\n\nifeq ($(HAVE_SAPI), 1)\n   LIBS += sapi.dll\nendif\n\nifeq ($(HAVE_GL_CONTEXT),)\n   HAVE_GL_CONTEXT = 0\n   HAVE_GL_MODERN  = 0\n\n   ifeq ($(HAVE_OPENGL), 1)\n      HAVE_GL_CONTEXT = 1\n      HAVE_GL_MODERN  = 1\n   endif\n\n   ifeq ($(HAVE_OPENGL1), 1)\n      HAVE_GL_CONTEXT = 1\n   endif\n\n   ifeq ($(HAVE_OPENGLES), 1)\n      HAVE_GL_CONTEXT = 1\n      HAVE_GL_MODERN  = 1\n   endif\n\n   ifeq ($(HAVE_OPENGLES3), 1)\n      HAVE_GL_CONTEXT = 1\n      HAVE_GL_MODERN  = 1\n   endif\nendif\n\nifeq ($(HAVE_LIBRETRODB),)\n   HAVE_LIBRETRODB = 1\nendif\n\nifeq ($(HAVE_SOCKET_LEGACY), 1)\n   DEFINES += -DHAVE_SOCKET_LEGACY\nendif\n\nifeq ($(HAVE_LIBRETRODB), 1)\n   DEFINES += -DHAVE_LIBRETRODB\nendif\n\nifeq ($(HAVE_VITA2D), 1)\n   DEFINES += -DHAVE_VITA2D\nendif\n\nifeq ($(HAVE_DYLIB), 1)\n   DEFINES += -DHAVE_DYLIB\nendif\n\nifeq ($(SCALER_NO_SIMD), 1)\n   DEFINES += -DSCALER_NO_SIMD\nendif\n\nifeq ($(HAVE_PRESERVE_DYLIB),1)\n   DEFINES += -DNO_DLCLOSE\nendif\n\nifeq ($(GL_DEBUG), 1)\n   DEFINES += -DGL_DEBUG\nendif\n\nifeq ($(VULKAN_DEBUG), 1)\n   DEFINES += -DVULKAN_DEBUG\nendif\n\nifeq ($(HAVE_FLOATHARD), 1)\n   DEF_FLAGS += $(FLOATHARD_CFLAGS)\n   ASFLAGS   += $(FLOATHARD_CFLAGS)\nendif\n\nifeq ($(HAVE_FLOATSOFTFP), 1)\n   DEF_FLAGS += $(FLOATSOFTFP_CFLAGS)\n   ASFLAGS   += $(FLOATSOFTFP_CFLAGS)\nendif\n\nifeq ($(TDM_GCC),)\n   LDCXXFLAGS += -static-libstdc++\nendif\n\nifeq ($(HAVE_FILE_LOGGER), 1)\n   DEFINES += -DHAVE_FILE_LOGGER\nendif\n\nifeq ($(HAVE_SHADERPIPELINE), 1)\n   DEFINES += -DHAVE_SHADERPIPELINE\nendif\n\nINCLUDE_DIRS += -I$(LIBRETRO_COMM_DIR)/include -I$(DEPS_DIR)\n\n# Switches\n#\nifeq ($(HAVE_NETPLAYDISCOVERY), 1)\n   DEFINES += -DHAVE_NETPLAYDISCOVERY\nendif\n\nifeq ($(HAVE_NETLOGGER), 1)\n   DEFINES += -DHAVE_LOGGER\n   OBJ += network/net_logger.o\nendif\n\n# System\n\nifneq ($(findstring BSD,$(OS)),)\n   BSD_LOCAL_INC += -I/usr/local/include\n   HAVE_UNIX = 1\nendif\n\nifneq ($(findstring Darwin,$(OS)),)\n   OSX := 1\n   LIBS += -framework AppKit\n   ARCHFLAGS=\n   MINVERFLAGS=\n   ifeq ($(shell uname -p),arm)\n      MINVERFLAGS = -mmacosx-version-min=10.15 -stdlib=libc++ # macOS  (Metal, ARM 64bit)\n   else ifeq ($(HAVE_METAL),1)\n      MINVERFLAGS = -mmacosx-version-min=10.13 -stdlib=libc++  # macOS  (Metal, x86 64bit)\n   else ifeq ($(shell uname -p),powerpc)\n      MINVERFLAGS = -mmacosx-version-min=10.5  # macOSX (PowerPC 32-bit)\n   else ifeq ($(shell uname -m),i386)\n      MINVERFLAGS = -mmacosx-version-min=10.6  # macOSX (OpenGL, x86 32bit)\n   else\n      MINVERFLAGS = -mmacosx-version-min=10.7 -stdlib=libc++ # macOSX (OpenGL, x86 64bit)\n   endif\n\n\t# Build for a specific architecture when ARCH is defined as a switch\n   ifeq ($(ARCH),arm64)\n      MINVERFLAGS  = -mmacosx-version-min=10.15 -stdlib=libc++ # macOS  (Metal, ARM 64bit)\n      ARCHFLAGS    = -arch arm64\n   else ifeq ($(ARCH),x86_64)\n      ifeq ($(HAVE_METAL),1)\n         MINVERFLAGS  = -mmacosx-version-min=10.13 -stdlib=libc++\n      else\n         MINVERFLAGS  = -mmacosx-version-min=10.7  -stdlib=libc++\n      endif\n      ARCHFLAGS       = -arch x86_64\n   else ifeq ($(ARCH),x86)\n      MINVERFLAGS     = -mmacosx-version-min=10.6\n      ARCHFLAGS       = -arch x86\n   else ifeq ($(ARCH),ppc)\n      MINVERFLAGS     = -mmacosx-version-min=10.5\n      ARCHFLAGS       = -arch ppc\n   endif\n   ifeq ($(BUILDBOT),1)\n      ARCHFLAGS       = -target $(LIBRETRO_APPLE_PLATFORM) -isysroot $(LIBRETRO_APPLE_ISYSROOT)\n   endif\n   DEF_FLAGS += $(MINVERFLAGS) $(ARCHFLAGS)\n   LDFLAGS   += $(MINVERFLAGS) $(ARCHFLAGS)\nelse\n   OSX := 0\nendif\n\nifneq ($(findstring Haiku,$(OS)),)\n   LIBS += -lroot -lnetwork\n   HAVE_UNIX = 1\nelse\n   LIBS += -lm\nendif\n\nifneq ($(findstring Linux,$(OS)),)\n   LIBS += -lrt\n   OBJ += input/drivers/linuxraw_input.o \\\n          input/common/linux_common.o \\\n          input/drivers_joypad/linuxraw_joypad.o\n   HAVE_UNIX = 1\nendif\n\nifeq ($(HAVE_UNIX), 1)\n   OBJ += frontend/drivers/platform_unix.o\n\n\tifeq ($(UNIX_CWD_ENV), 1)\n\t\tDEF_FLAGS += -DRARCH_UNIX_CWD_ENV\n\tendif\nendif\n\nifeq ($(TARGET), retroarch_3ds)\n   OBJ += frontend/drivers/platform_ctr.o\nendif\n\nifeq ($(TARGET), retroarch_ps2)\n   OBJ += frontend/drivers/platform_ps2.o\nendif\n\n# Git Version\nGIT_VERSION_CACHEDIR = $(if $(OBJDIR),$(OBJDIR),$(CURDIR))\nGIT_VERSION_CACHEFILE = $(GIT_VERSION_CACHEDIR)/git-version.cache\n\nifneq (,$(wildcard .git/index))  # Building inside a Git repository?\n   GIT_VERSION := $(shell git rev-parse --short HEAD 2>/dev/null)\nendif\n\nifneq (,$(wildcard $(GIT_VERSION_CACHEFILE)))  # Cached Git version?\n   GIT_VERSION_CACHE = $(shell cat \"$(GIT_VERSION_CACHEFILE)\" 2>/dev/null)\nendif\n\nifeq ($(GIT_VERSION),)\n   ifneq ($(GIT_VERSION_CACHE),)  # If no Git version, use cached if found\n      GIT_VERSION = $(GIT_VERSION_CACHE)\n   endif\nendif\n\nifneq ($(GIT_VERSION),)  # Enable version_git.o?\n   ifneq ($(GIT_VERSION),$(GIT_VERSION_CACHE))  # Update version_git.o?\n      $(shell \\\n         mkdir -p \"$(GIT_VERSION_CACHEDIR)\" && \\\n         echo \"$(GIT_VERSION)\" > \"$(GIT_VERSION_CACHEFILE)\" && \\\n         touch version_git.c)\n   endif\n   DEFINES += -DHAVE_GIT_VERSION -DGIT_VERSION=$(GIT_VERSION)\n   OBJ += version_git.o\nendif\n\n# General object files\nifeq ($(HAVE_DR_MP3), 1)\n   DEFINES += -DHAVE_DR_MP3\nendif\n\nOBJ += frontend/frontend_driver.o \\\n       retroarch.o \\\n       runloop.o \\\n       ui/ui_companion_driver.o \\\n       camera/camera_driver.o \\\n       record/record_driver.o \\\n       record/drivers/record_wav.o \\\n       command.o \\\n       msg_hash.o \\\n       intl/msg_hash_us.o \\\n       $(LIBRETRO_COMM_DIR)/queues/task_queue.o \\\n       tasks/task_content.o\n\nifeq ($(HAVE_PATCH), 1)\n   DEFINES += -DHAVE_PATCH\n   OBJ     += tasks/task_patch.o\n   ifeq ($(HAVE_XDELTA), 1)\n      DEFINES      += -DHAVE_XDELTA -DSECONDARY_DJW -DSECONDARY_LZMA -DSECONDARY_FGK\n      INCLUDE_DIRS += -I$(DEPS_DIR)/xdelta3 -I$(LIBRETRO_COMM_DIR)\n      LIBS         += -llzma\n      OBJ          += $(DEPS_DIR)/xdelta3/xdelta3.o\n      HEADERS      += xdelta3.h \\\n                      xdelta3-cfgs.h \\\n                      xdelta3-fgk.h \\\n                      xdelta3-hash.h \\\n                      xdelta3-internal.h \\\n                      xdelta3-list.h \\\n                      xdelta3-lzma.h \\\n                      xdelta3-second.h\n      # These headers are added to the makefile because xdelta3 does weird things\n      # with its #includes, which affects dependency tracking and project analysis\n      # (e.g. for IDEs).\n   endif\nendif\n\nOBJ += \\\n       save.o \\\n       tasks/task_save.o \\\n       tasks/task_movie.o \\\n       tasks/task_file_transfer.o \\\n       tasks/task_image.o \\\n       tasks/task_playlist_manager.o \\\n       tasks/task_manual_content_scan.o \\\n       tasks/task_core_backup.o \\\n       $(LIBRETRO_COMM_DIR)/encodings/encoding_utf.o \\\n       $(LIBRETRO_COMM_DIR)/encodings/encoding_crc32.o \\\n       $(LIBRETRO_COMM_DIR)/encodings/encoding_base64.o\n\nifeq ($(HAVE_TRANSLATE), 1)\n   OBJ += tasks/task_translation.o\nendif\n\nOBJ += \\\n       $(LIBRETRO_COMM_DIR)/compat/fopen_utf8.o \\\n       $(LIBRETRO_COMM_DIR)/compat/compat_strldup.o \\\n       $(LIBRETRO_COMM_DIR)/lists/file_list.o \\\n       $(LIBRETRO_COMM_DIR)/lists/dir_list.o \\\n       $(LIBRETRO_COMM_DIR)/file/retro_dirent.o \\\n       $(LIBRETRO_COMM_DIR)/streams/stdin_stream.o \\\n       $(LIBRETRO_COMM_DIR)/streams/file_stream.o \\\n       $(LIBRETRO_COMM_DIR)/streams/file_stream_transforms.o \\\n       $(LIBRETRO_COMM_DIR)/streams/interface_stream.o \\\n       $(LIBRETRO_COMM_DIR)/streams/memory_stream.o \\\n       $(LIBRETRO_COMM_DIR)/streams/network_stream.o \\\n       $(LIBRETRO_COMM_DIR)/vfs/vfs_implementation.o\n\nOBJ += \\\n       $(LIBRETRO_COMM_DIR)/lists/string_list.o \\\n       $(LIBRETRO_COMM_DIR)/string/stdstring.o \\\n       $(LIBRETRO_COMM_DIR)/memmap/memalign.o \\\n       $(LIBRETRO_COMM_DIR)/file/nbio/nbio_stdio.o\n\nOBJ += \\\n       $(LIBRETRO_COMM_DIR)/lists/linked_list.o \\\n       $(LIBRETRO_COMM_DIR)/lists/nested_list.o \\\n       $(LIBRETRO_COMM_DIR)/queues/generic_queue.o\n\nifneq ($(findstring Linux,$(OS)),)\n\tOBJ += $(LIBRETRO_COMM_DIR)/file/nbio/nbio_linux.o\nendif\nifneq ($(findstring Win32,$(OS)),)\n   OBJ += $(LIBRETRO_COMM_DIR)/file/nbio/nbio_windowsmmap.o\nendif\nifneq ($(findstring BSD,$(OS)),)\n\tOBJ += $(LIBRETRO_COMM_DIR)/file/nbio/nbio_unixmmap.o\nelse ifneq ($(findstring Darwin,$(OS)),)\n\tOBJ += $(LIBRETRO_COMM_DIR)/file/nbio/nbio_unixmmap.o\nendif\n\nOBJ += \\\n       $(LIBRETRO_COMM_DIR)/file/nbio/nbio_intf.o \\\n       $(LIBRETRO_COMM_DIR)/file/file_path.o \\\n       $(LIBRETRO_COMM_DIR)/file/file_path_io.o \\\n       file_path_special.o \\\n       $(LIBRETRO_COMM_DIR)/hash/lrc_hash.o \\\n       audio/audio_driver.o \\\n       input/input_driver.o \\\n       input/common/input_hid_common.o \\\n       led/led_driver.o \\\n       gfx/video_driver.o \\\n       gfx/gfx_display.o \\\n       gfx/gfx_animation.o \\\n       configuration.o \\\n       $(LIBRETRO_COMM_DIR)/dynamic/dylib.o \\\n       cores/dynamic_dummy.o \\\n       $(LIBRETRO_COMM_DIR)/queues/message_queue.o\n\nifeq ($(HAVE_MENU), 1)\n   OBJ += \\\n       gfx/gfx_thumbnail_path.o \\\n       gfx/gfx_thumbnail.o\nendif\n\nifeq ($(HAVE_MICROPHONE), 1)\n   DEFINES += -DHAVE_MICROPHONE\n   OBJ += audio/microphone_driver.o\nendif\n\nifeq ($(HAVE_REWIND), 1)\nDEFINES += -DHAVE_REWIND\nOBJ     += state_manager.o\nendif\n\nOBJ += \\\n       gfx/drivers_font_renderer/bitmapfont.o \\\n       gfx/drivers_font_renderer/bitmapfont_10x10.o \\\n       gfx/drivers_font_renderer/bitmapfont_6x10.o \\\n       tasks/task_autodetect.o \\\n       input/input_autodetect_builtin.o \\\n       input/input_keymaps.o \\\n       $(LIBRETRO_COMM_DIR)/queues/fifo_queue.o \\\n       $(LIBRETRO_COMM_DIR)/compat/compat_fnmatch.o \\\n       $(LIBRETRO_COMM_DIR)/compat/compat_posix_string.o\n\nifeq ($(HAVE_CHEATS), 1)\n   DEFINES += -DHAVE_CHEATS\n   OBJ     += cheat_manager.o\nendif\n\nifeq ($(HAVE_CORE_INFO_CACHE), 1)\n   DEFINES += -DHAVE_CORE_INFO_CACHE\nendif\n\nOBJ += \\\n       core_info.o \\\n       core_backup.o \\\n       core_option_manager.o \\\n       $(LIBRETRO_COMM_DIR)/file/config_file.o \\\n       $(LIBRETRO_COMM_DIR)/file/config_file_userdata.o \\\n       runtime_file.o \\\n       disk_index_file.o\n\nifeq ($(HAVE_SCREENSHOTS), 1)\n   DEFINES += -DHAVE_SCREENSHOTS\n   OBJ     += tasks/task_screenshot.o\nendif\n\nOBJ += \\\n       tasks/task_powerstate.o \\\n       $(LIBRETRO_COMM_DIR)/gfx/scaler/scaler.o \\\n       $(LIBRETRO_COMM_DIR)/gfx/scaler/pixconv.o \\\n       $(LIBRETRO_COMM_DIR)/gfx/scaler/scaler_int.o \\\n       $(LIBRETRO_COMM_DIR)/gfx/scaler/scaler_filter.o \\\n       gfx/font_driver.o\n\nifeq ($(HAVE_VIDEO_FILTER), 1)\nDEFINES += -DHAVE_VIDEO_FILTER\nOBJ     += gfx/video_filter.o\nendif\n\nifeq ($(HAVE_WINDOW_OFFSET), 1)\nDEFINES += -DHAVE_WINDOW_OFFSET\nendif\n\nOBJ     += $(LIBRETRO_COMM_DIR)/audio/resampler/audio_resampler.o\n\nifeq ($(HAVE_DSP_FILTER), 1)\nDEFINES += -DHAVE_DSP_FILTER\nOBJ     += $(LIBRETRO_COMM_DIR)/audio/dsp_filter.o\nendif\n\nOBJ += $(LIBRETRO_COMM_DIR)/audio/resampler/drivers/sinc_resampler.o\n\nifeq ($(HAVE_NEAREST_RESAMPLER), 1)\n   DEFINES += -DHAVE_NEAREST_RESAMPLER\n   OBJ     += $(LIBRETRO_COMM_DIR)/audio/resampler/drivers/nearest_resampler.o\nendif\n\nOBJ += \\\n       $(LIBRETRO_COMM_DIR)/utils/md5.o \\\n       playlist.o \\\n       $(LIBRETRO_COMM_DIR)/features/features_cpu.o \\\n       verbosity.o \\\n       $(LIBRETRO_COMM_DIR)/playlists/label_sanitization.o \\\n       $(LIBRETRO_COMM_DIR)/time/rtime.o \\\n       manual_content_scan.o \\\n       disk_control_interface.o\n\nifeq ($(HAVE_CONFIGFILE), 1)\n   DEFINES += -DHAVE_CONFIGFILE\nendif\n\nifeq ($(HAVE_BLISSBOX), 1)\n   DEFINES += -DHAVE_BLISSBOX\n\tOBJ += tasks/task_autodetect_blissbox.o\nendif\n\nifeq ($(HAVE_AUDIOMIXER), 1)\n   DEFINES += -DHAVE_AUDIOMIXER\n   OBJ += tasks/task_audio_mixer.o \\\n          $(LIBRETRO_COMM_DIR)/audio/audio_mix.o \\\n          $(LIBRETRO_COMM_DIR)/audio/audio_mixer.o\nendif\n\nifeq ($(HAVE_BSV_MOVIE), 1)\n   DEFINES += -DHAVE_BSV_MOVIE\nendif\n\nifeq ($(HAVE_RUNAHEAD), 1)\n   DEFINES += -DHAVE_RUNAHEAD\n   OBJ     += runahead.o\nendif\n\nifeq ($(HAVE_CC_RESAMPLER), 1)\n   DEFINES += -DHAVE_CC_RESAMPLER\n   OBJ += audio/drivers_resampler/cc_resampler.o\n\nifeq ($(HAVE_NEON),1)\n   OBJ += audio/drivers_resampler/cc_resampler_neon.o\nendif\nendif\n\nifeq ($(HAVE_LANGEXTRA), 1)\n   DEFINES += -DHAVE_LANGEXTRA\n   DEF_FLAGS += -finput-charset=UTF-8\nendif\n\nifneq ($(HAVE_GETOPT_LONG), 1)\n   OBJ += $(LIBRETRO_COMM_DIR)/compat/compat_getopt.o\nendif\n\nifneq ($(HAVE_STRCASESTR), 1)\n   OBJ += $(LIBRETRO_COMM_DIR)/compat/compat_strcasestr.o\nendif\n\nifneq ($(HAVE_STRL), 1)\n   OBJ += $(LIBRETRO_COMM_DIR)/compat/compat_strl.o\nendif\n\nOBJ += $(LIBRETRO_COMM_DIR)/formats/image_texture.o\n\nifeq ($(HAVE_IMAGEVIEWER), 1)\n   DEFINES += -DHAVE_IMAGEVIEWER\n   OBJ += cores/libretro-imageviewer/image_core.o\nendif\n\nifeq ($(HAVE_D3D9), 1)\n\tHAVE_HLSL = 1\nendif\n\nifeq ($(HAVE_CG), 1)\n   HAVE_SHADERS_COMMON = 1\nendif\nifeq ($(HAVE_GLSL), 1)\n   HAVE_SHADERS_COMMON = 1\nendif\nifeq ($(HAVE_HLSL), 1)\n   HAVE_SHADERS_COMMON = 1\nendif\nifeq ($(HAVE_SLANG), 1)\n   HAVE_SHADERS_COMMON = 1\nendif\n\n# Qt WIMP GUI\n\nifeq ($(HAVE_OPENSSL), 1)\n   DEF_FLAGS += $(OPENSSL_CFLAGS)\n   LIBS += $(OPENSSL_LIBS)\nendif\n\nifeq ($(HAVE_QT), 1)\n   OBJ += ui/drivers/ui_qt.o \\\n          ui/drivers/qt/gridview.o \\\n          ui/drivers/qt/qt_dialogs.o \\\n          ui/drivers/qt/qt_widgets.o \\\n          ui/drivers/qt/qt_playlist.o \\\n          ui/drivers/qt/qt_downloads.o\n    ifeq ($(HAVE_MENU), 1)\n       OBJ += ui/drivers/qt/qt_options.o\n    endif\n\n   MOC_HEADERS += ui/drivers/ui_qt.h \\\n                  ui/drivers/qt/ui_qt_load_core_window.h \\\n                  ui/drivers/qt/gridview.h \\\n                  ui/drivers/qt/qt_dialogs.h \\\n                  ui/drivers/qt/qt_widgets.h\n   ifeq ($(HAVE_MENU), 1)\n      MOC_HEADERS += ui/drivers/qt/qt_options.h\n   endif\n\n   DEFINES += -DHAVE_MAIN\nifeq ($(HAVE_QT6), 1)\n   CXXFLAGS += -DQT_DISABLE_DEPRECATED_BEFORE=0x060000 $(QT6CORE_CFLAGS) $(QT6GUI_CFLAGS) $(QT6WIDGETS_CFLAGS) $(QT6CONCURRENT_CFLAGS) $(QT6NETWORK_CFLAGS)\n   #DEF_FLAGS += $(QT6WEBENGINE_CFLAGS)\n   LIBS += $(QT6CORE_LIBS) $(QT6GUI_LIBS) $(QT6WIDGETS_LIBS) $(QT6CONCURRENT_LIBS) $(QT6NETWORK_LIBS)\n   #LIBS += $(QT6WEBENGINE_LIBS)\nelse\n   DEF_FLAGS += $(QT5CORE_CFLAGS) $(QT5GUI_CFLAGS) $(QT5WIDGETS_CFLAGS) $(QT5CONCURRENT_CFLAGS) $(QT5NETWORK_CFLAGS)\n   #DEF_FLAGS += $(QT5WEBENGINE_CFLAGS)\n   LIBS += $(QT5CORE_LIBS) $(QT5GUI_LIBS) $(QT5WIDGETS_LIBS) $(QT5CONCURRENT_LIBS) $(QT5NETWORK_LIBS)\n   #LIBS += $(QT5WEBENGINE_LIBS)\nendif\n\n   NEED_CXX_LINKER = 1\n\n   ifneq ($(findstring Linux,$(OS)),)\n      DEF_FLAGS += -fPIC\n   else ifneq ($(findstring BSD,$(OS)),)\n      DEF_FLAGS += -fPIC\n   endif\nendif\n\nifeq ($(HAVE_SSA),1)\n   LIBS += $(SSA_LIBS)\nendif\n\nifeq ($(HAVE_SSE),1)\n   DEF_FLAGS += $(SSE_LIBS)\nendif\n\n# LibretroDB\n\nifeq ($(HAVE_LIBRETRODB), 1)\n   OBJ += libretro-db/bintree.o \\\n          libretro-db/libretrodb.o \\\n          libretro-db/query.o \\\n          libretro-db/rmsgpack.o \\\n          libretro-db/rmsgpack_dom.o \\\n          database_info.o \\\n          tasks/task_database.o \\\n          tasks/task_database_cue.o\n\n   ifeq ($(HAVE_MENU), 1)\n      OBJ += menu/menu_explore.o \\\n             tasks/task_menu_explore.o\n   endif\nendif\n\nifeq ($(HAVE_BUILTINBEARSSL), 1)\n   HAVE_SSL = 1\n   DEFINES += -DHAVE_SSL -DHAVE_BEARSSL\n\n   # these -Is are only needed for BearSSL itself\n   INCLUDE_DIRS += -Ideps/bearssl-0.6/src -Ideps/bearssl-0.6/inc\n   OBJS_BEAR = deps/bearssl-0.6/src/aead/ccm.o \\\n               deps/bearssl-0.6/src/codec/ccopy.o \\\n               deps/bearssl-0.6/src/codec/dec32be.o \\\n               deps/bearssl-0.6/src/codec/dec32le.o \\\n               deps/bearssl-0.6/src/codec/dec64be.o \\\n               deps/bearssl-0.6/src/codec/enc32be.o \\\n               deps/bearssl-0.6/src/codec/enc32le.o \\\n               deps/bearssl-0.6/src/codec/enc64be.o \\\n               deps/bearssl-0.6/src/ec/ec_all_m31.o \\\n               deps/bearssl-0.6/src/ec/ec_c25519_m31.o \\\n               deps/bearssl-0.6/src/ec/ecdsa_atr.o \\\n               deps/bearssl-0.6/src/ec/ecdsa_i31_bits.o \\\n               deps/bearssl-0.6/src/ec/ecdsa_i31_vrfy_asn1.o \\\n               deps/bearssl-0.6/src/ec/ecdsa_i31_vrfy_raw.o \\\n               deps/bearssl-0.6/src/ec/ec_p256_m31.o \\\n               deps/bearssl-0.6/src/ec/ec_prime_i31.o \\\n               deps/bearssl-0.6/src/ec/ec_secp256r1.o \\\n               deps/bearssl-0.6/src/ec/ec_secp384r1.o \\\n               deps/bearssl-0.6/src/ec/ec_secp521r1.o \\\n               deps/bearssl-0.6/src/hash/ghash_ctmul64.o \\\n               deps/bearssl-0.6/src/hash/ghash_pclmul.o \\\n               deps/bearssl-0.6/src/hash/md5.o \\\n               deps/bearssl-0.6/src/hash/multihash.o \\\n               deps/bearssl-0.6/src/hash/sha1.o \\\n               deps/bearssl-0.6/src/hash/sha2big.o \\\n               deps/bearssl-0.6/src/hash/sha2small.o \\\n               deps/bearssl-0.6/src/int/i31_add.o \\\n               deps/bearssl-0.6/src/int/i31_bitlen.o \\\n               deps/bearssl-0.6/src/int/i31_decmod.o \\\n               deps/bearssl-0.6/src/int/i31_decode.o \\\n               deps/bearssl-0.6/src/int/i31_decred.o \\\n               deps/bearssl-0.6/src/int/i31_encode.o \\\n               deps/bearssl-0.6/src/int/i31_fmont.o \\\n               deps/bearssl-0.6/src/int/i31_iszero.o \\\n               deps/bearssl-0.6/src/int/i31_modpow2.o \\\n               deps/bearssl-0.6/src/int/i31_modpow.o \\\n               deps/bearssl-0.6/src/int/i31_montmul.o \\\n               deps/bearssl-0.6/src/int/i31_muladd.o \\\n               deps/bearssl-0.6/src/int/i31_ninv31.o \\\n               deps/bearssl-0.6/src/int/i31_rshift.o \\\n               deps/bearssl-0.6/src/int/i31_sub.o \\\n               deps/bearssl-0.6/src/int/i31_tmont.o \\\n               deps/bearssl-0.6/src/int/i32_div32.o \\\n               deps/bearssl-0.6/src/int/i62_modpow2.o \\\n               deps/bearssl-0.6/src/mac/hmac_ct.o \\\n               deps/bearssl-0.6/src/mac/hmac.o \\\n               deps/bearssl-0.6/src/rand/hmac_drbg.o \\\n               deps/bearssl-0.6/src/rand/sysrng.o \\\n               deps/bearssl-0.6/src/rsa/rsa_default_pkcs1_vrfy.o \\\n               deps/bearssl-0.6/src/rsa/rsa_default_pub.o \\\n               deps/bearssl-0.6/src/rsa/rsa_i31_pkcs1_vrfy.o \\\n               deps/bearssl-0.6/src/rsa/rsa_i31_pub.o \\\n               deps/bearssl-0.6/src/rsa/rsa_i62_pkcs1_vrfy.o \\\n               deps/bearssl-0.6/src/rsa/rsa_i62_pub.o \\\n               deps/bearssl-0.6/src/rsa/rsa_pkcs1_sig_unpad.o \\\n               deps/bearssl-0.6/src/ssl/prf_md5sha1.o \\\n               deps/bearssl-0.6/src/ssl/prf.o \\\n               deps/bearssl-0.6/src/ssl/prf_sha256.o \\\n               deps/bearssl-0.6/src/ssl/prf_sha384.o \\\n               deps/bearssl-0.6/src/ssl/ssl_client_default_rsapub.o \\\n               deps/bearssl-0.6/src/ssl/ssl_client_full.o \\\n               deps/bearssl-0.6/src/ssl/ssl_client.o \\\n               deps/bearssl-0.6/src/ssl/ssl_engine_default_aescbc.o \\\n               deps/bearssl-0.6/src/ssl/ssl_engine_default_aesccm.o \\\n               deps/bearssl-0.6/src/ssl/ssl_engine_default_aesgcm.o \\\n               deps/bearssl-0.6/src/ssl/ssl_engine_default_chapol.o \\\n               deps/bearssl-0.6/src/ssl/ssl_engine_default_descbc.o \\\n               deps/bearssl-0.6/src/ssl/ssl_engine_default_ecdsa.o \\\n               deps/bearssl-0.6/src/ssl/ssl_engine_default_rsavrfy.o \\\n               deps/bearssl-0.6/src/ssl/ssl_engine.o \\\n               deps/bearssl-0.6/src/ssl/ssl_hs_client.o \\\n               deps/bearssl-0.6/src/ssl/ssl_rec_cbc.o \\\n               deps/bearssl-0.6/src/ssl/ssl_rec_ccm.o \\\n               deps/bearssl-0.6/src/ssl/ssl_rec_chapol.o \\\n               deps/bearssl-0.6/src/ssl/ssl_rec_gcm.o \\\n               deps/bearssl-0.6/src/symcipher/aes_ct64_cbcdec.o \\\n               deps/bearssl-0.6/src/symcipher/aes_ct64_cbcenc.o \\\n               deps/bearssl-0.6/src/symcipher/aes_ct64_ctrcbc.o \\\n               deps/bearssl-0.6/src/symcipher/aes_ct64_ctr.o \\\n               deps/bearssl-0.6/src/symcipher/aes_ct64_dec.o \\\n               deps/bearssl-0.6/src/symcipher/aes_ct64_enc.o \\\n               deps/bearssl-0.6/src/symcipher/aes_ct64.o \\\n               deps/bearssl-0.6/src/symcipher/aes_x86ni_cbcdec.o \\\n               deps/bearssl-0.6/src/symcipher/aes_x86ni_cbcenc.o \\\n               deps/bearssl-0.6/src/symcipher/aes_x86ni_ctrcbc.o \\\n               deps/bearssl-0.6/src/symcipher/aes_x86ni_ctr.o \\\n               deps/bearssl-0.6/src/symcipher/aes_x86ni.o \\\n               deps/bearssl-0.6/src/symcipher/chacha20_ct.o \\\n               deps/bearssl-0.6/src/symcipher/chacha20_sse2.o \\\n               deps/bearssl-0.6/src/symcipher/des_ct_cbcdec.o \\\n               deps/bearssl-0.6/src/symcipher/des_ct_cbcenc.o \\\n               deps/bearssl-0.6/src/symcipher/des_ct.o \\\n               deps/bearssl-0.6/src/symcipher/des_support.o \\\n               deps/bearssl-0.6/src/symcipher/poly1305_ctmul.o \\\n               deps/bearssl-0.6/src/symcipher/poly1305_ctmulq.o \\\n               deps/bearssl-0.6/src/x509/x509_decoder.o \\\n               deps/bearssl-0.6/src/x509/x509_minimal_full.o \\\n               deps/bearssl-0.6/src/x509/x509_minimal.o \\\n\n   OBJ += $(OBJS_BEAR)\nelse ifeq ($(HAVE_BUILTINMBEDTLS), 1)\n   HAVE_SSL = 1\n   DEFINES += -DHAVE_SSL\n\n   ifeq ($(DEBUG), 1)\n      DEFINES += -DMBEDTLS_SSL_DEBUG_ALL\n   endif\n\n   # MinGW requires this for some reason,\n\t# even though the include paths are relative to the source\n   INCLUDE_DIRS += -Ideps/mbedtls\n\n   OBJS_TLS_CRYPTO = deps/mbedtls/aes.o \\\n                     deps/mbedtls/aesni.o \\\n                     deps/mbedtls/arc4.o \\\n                     deps/mbedtls/asn1parse.o \\\n                     deps/mbedtls/asn1write.o \\\n                     deps/mbedtls/base64.o \\\n                     deps/mbedtls/bignum.o \\\n                     deps/mbedtls/blowfish.o \\\n                     deps/mbedtls/camellia.o \\\n                     deps/mbedtls/ccm.o \\\n                     deps/mbedtls/cipher.o \\\n                     deps/mbedtls/cipher_wrap.o \\\n                     deps/mbedtls/ctr_drbg.o \\\n                     deps/mbedtls/des.o \\\n                     deps/mbedtls/dhm.o \\\n                     deps/mbedtls/ecdh.o \\\n                     deps/mbedtls/ecdsa.o \\\n                     deps/mbedtls/ecp.o \\\n                     deps/mbedtls/ecp_curves.o \\\n                     deps/mbedtls/entropy.o \\\n                     deps/mbedtls/entropy_poll.o \\\n                     deps/mbedtls/gcm.o \\\n                     deps/mbedtls/hmac_drbg.o \\\n                     deps/mbedtls/md.o \\\n                     deps/mbedtls/md5.o \\\n                     deps/mbedtls/md_wrap.o \\\n                     deps/mbedtls/oid.o \\\n                     deps/mbedtls/padlock.o \\\n                     deps/mbedtls/pem.o \\\n                     deps/mbedtls/pk.o \\\n                     deps/mbedtls/pk_wrap.o \\\n                     deps/mbedtls/pkcs12.o \\\n                     deps/mbedtls/pkcs5.o \\\n                     deps/mbedtls/pkparse.o \\\n                     deps/mbedtls/pkwrite.o \\\n                     deps/mbedtls/ripemd160.o \\\n                     deps/mbedtls/rsa.o \\\n                     deps/mbedtls/sha1.o \\\n                     deps/mbedtls/sha256.o \\\n                     deps/mbedtls/sha512.o \\\n                     deps/mbedtls/threading.o \\\n                     deps/mbedtls/timing.o \\\n                     deps/mbedtls/xtea.o\n\n   OBJS_TLS_X509 = deps/mbedtls/certs.o \\\n                   deps/mbedtls/x509.o \\\n                   deps/mbedtls/x509_create.o \\\n                   deps/mbedtls/x509_crl.o \\\n                   deps/mbedtls/x509_crt.o \\\n                   deps/mbedtls/x509_csr.o \\\n                   deps/mbedtls/x509write_crt.o \\\n                   deps/mbedtls/x509write_csr.o\n\n   OBJS_TLS = deps/mbedtls/debug.o \\\n              deps/mbedtls/net_sockets.o \\\n              deps/mbedtls/ssl_cache.o \\\n              deps/mbedtls/ssl_ciphersuites.o \\\n              deps/mbedtls/ssl_cli.o \\\n              deps/mbedtls/ssl_cookie.o \\\n              deps/mbedtls/ssl_srv.o \\\n              deps/mbedtls/ssl_ticket.o \\\n              deps/mbedtls/ssl_tls.o\n\n   OBJ += $(OBJS_TLS_CRYPTO) $(OBJS_TLS_X509) $(OBJS_TLS)\nelse ifeq ($(HAVE_SSL), 1)\n   DEFINES += -DHAVE_SSL\n   LIBS += $(SYSTEMMBEDTLS_LIBS) $(SYSTEMMBEDX509_LIBS) $(SYSTEMMBEDCRYPTO_LIBS)\n   DEF_FLAGS += $(SYSTEMMBEDTLS_CFLAGS) $(SYSTEMMBEDX509_CFLAGS) $(SYSTEMMBEDCRYPTO_CFLAGS)\nendif\n\n# Miscellaneous\n\nifeq ($(HAVE_COMMAND), 1)\n   DEFINES += -DHAVE_COMMAND\nendif\n\nifeq ($(HAVE_STDIN_CMD), 1)\n   DEFINES += -DHAVE_STDIN_CMD\nendif\n\nifeq ($(HAVE_EMSCRIPTEN), 1)\n   OBJ += frontend/drivers/platform_emscripten.o \\\n          input/drivers/rwebinput_input.o \\\n          input/drivers_joypad/rwebpad_joypad.o \\\n          camera/drivers/rwebcam.o\n   ifeq ($(HAVE_RWEBAUDIO), 1)\n      OBJ += audio/drivers/rwebaudio.o\n   endif\nendif\n\nifeq ($(HAVE_BLUETOOTH), 1)\n   OBJ += bluetooth/bluetooth_driver.o\n   OBJ += bluetooth/drivers/bluetoothctl.o\n   OBJ += tasks/task_bluetooth.o\n   ifeq ($(HAVE_DBUS), 1)\n      OBJ += bluetooth/drivers/bluez.o\n   endif\nendif\n\nifeq ($(HAVE_LAKKA), 1)\n   OBJ += network/drivers_wifi/connmanctl.o\n   OBJ += misc/cpufreq/cpufreq.o\nendif\n\nifeq ($(HAVE_WIFI), 1)\n   OBJ += network/wifi_driver.o\n   OBJ += tasks/task_wifi.o\n   OBJ += network/drivers_wifi/nmcli.o\n   DEFINES += -DHAVE_WIFI\nendif\n\n# Audio\n\nifeq ($(HAVE_COREAUDIO), 1)\n   DEFINES += -DHAVE_COREAUDIO\n   OBJ += audio/drivers/coreaudio.o\n   HAVE_COREAUDIO_LIBS = 1\nendif\n\nifeq ($(HAVE_COREAUDIO3), 1)\n   DEFINES += -DHAVE_COREAUDIO3\n   OBJ += audio/drivers/coreaudio3.o\n   HAVE_COREAUDIO_LIBS = 1\n   LIBS += -framework AudioToolBox -framework AVFoundation\nendif\n\nifeq ($(HAVE_COREAUDIO_LIBS), 1)\n   LIBS += -framework CoreServices -framework CoreAudio -framework AudioUnit\nendif\n\nifeq ($(HAVE_CORETEXT), 1)\n   OBJ += gfx/drivers_font_renderer/coretext.o\nendif\n\nifeq ($(HAVE_AUDIOIO), 1)\n   OBJ += audio/drivers/audioio.o\nendif\n\nifeq ($(HAVE_OSS), 1)\n   OBJ += audio/drivers/oss.o\nelse ifeq ($(HAVE_OSS_BSD), 1)\n   OBJ += audio/drivers/oss.o\nendif\n\nifeq ($(TARGET), retroarch_3ds)\n   OBJ += audio/drivers/ctr_csnd_audio.o \\\n          audio/drivers/ctr_dsp_audio.o\nifeq ($(HAVE_THREADS), 1)\n   OBJ += audio/drivers/ctr_dsp_thread_audio.o\nendif\nendif\n\nifeq ($(HAVE_ALSA), 1)\n   OBJ += audio/drivers/alsa.o \\\n          audio/common/alsa.o\n\n   ifeq ($(HAVE_MICROPHONE), 1)\n      OBJ += audio/drivers_microphone/alsa.o\n   endif\n\n   ifneq ($(HAVE_HAKCHI), 1)\n      ifneq ($(HAVE_SEGAM), 1)\n         ifneq ($(DINGUX), 1)\n            OBJ += midi/drivers/alsa_midi.o\n         endif\n      endif\n   endif\n\n   ifneq ($(MIYOO), 1)\n      ifeq ($(HAVE_THREADS), 1)\n         OBJ += audio/drivers/alsathread.o \\\n                audio/common/alsathread.o\n\n         ifeq ($(HAVE_MICROPHONE), 1)\n            OBJ += audio/drivers_microphone/alsathread.o\n         endif\n      endif\n   endif\n\n   LIBS += $(ALSA_LIBS)\n   DEF_FLAGS += $(ALSA_CFLAGS)\nendif\n\nifeq ($(HAVE_TINYALSA), 1)\n   OBJ += audio/drivers/tinyalsa.o\n   DEFINES += -DHAVE_TINYALSA\nendif\n\nifeq ($(HAVE_ROAR), 1)\n   OBJ += audio/drivers/roar.o\n   LIBS += $(ROAR_LIBS)\n   DEF_FLAGS += $(ROAR_CFLAGS)\nendif\n\nifeq ($(HAVE_AL), 1)\n   OBJ += audio/drivers/openal.o\n   ifeq ($(OSX),1)\n      LIBS += -framework OpenAL\n   else\n      LIBS += $(AL_LIBS)\n   endif\nendif\n\nifneq ($(findstring Darwin,$(OS)),)\n   OBJ += frontend/drivers/platform_darwin.o\nendif\n\nifeq ($(HAVE_JACK),1)\n   OBJ += audio/drivers/jack.o\n   LIBS += $(JACK_LIBS)\n   DEF_FLAGS += $(JACK_CFLAGS)\nendif\n\nifeq ($(HAVE_PULSE), 1)\n   OBJ += audio/drivers/pulse.o\n   LIBS += $(PULSE_LIBS)\n   DEF_FLAGS += $(PULSE_CFLAGS)\nendif\n\nifeq ($(HAVE_PIPEWIRE), 1)\n   OBJ += audio/drivers/pipewire.o \\\n          audio/common/pipewire.o\n\n   ifeq ($(HAVE_MICROPHONE), 1)\n      OBJ += audio/drivers_microphone/pipewire.o\n   endif\n\n   LIBS += $(PIPEWIRE_LIBS)\n   DEF_FLAGS += $(PIPEWIRE_CFLAGS)\nendif\n\nifeq ($(HAVE_OSS_LIB), 1)\n   LIBS += -lossaudio\nendif\n\nifeq ($(HAVE_RSOUND), 1)\n   OBJ += audio/drivers/rsound.o\n   DEF_FLAGS += $(RSOUND_CFLAGS)\n   LIBS += $(RSOUND_LIBS)\nendif\n\nifeq ($(HAVE_DSOUND), 1)\n   OBJ += audio/drivers/dsound.o\n   DEFINES += -DHAVE_DSOUND\n   HAVE_DX_COMMON  = 1\n   LIBS += -ldsound\nendif\n\nifeq ($(HAVE_WASAPI), 1)\n\tHAVE_MMDEVAPI = 1\n   OBJ += audio/drivers/wasapi.o \\\n          audio/common/wasapi.o\n   DEFINES += -DHAVE_WASAPI\n   LIBS += -lole32 -lksuser\n\n   ifeq ($(HAVE_MICROPHONE), 1)\n      OBJ += audio/drivers_microphone/wasapi.o\n      endif\nendif\n\nifeq ($(HAVE_XAUDIO), 1)\n   OBJ += audio/drivers/xaudio.o\n   DEFINES += -DHAVE_XAUDIO\n   LIBS += -lole32\nendif\n\nifeq ($(HAVE_MMDEVAPI), 1)\n\tOBJ += audio/common/mmdevice_common.o\nendif\n\nifeq ($(HAVE_WINMM), 1)\n   OBJ += midi/drivers/winmm_midi.o\n   DEFINES += -DHAVE_WINMM\n   LIBS += -lwinmm\nendif\n\n# Audio Resamplers\n\nifeq ($(HAVE_NEON),1)\n   OBJ += $(LIBRETRO_COMM_DIR)/audio/resampler/drivers/sinc_resampler_neon.o \\\n          memory/neon/memcpy-neon.o\n\n   DEFINES   += -DHAVE_NEON\n   ASFLAGS   += $(NEON_ASFLAGS)\n   DEF_FLAGS += $(NEON_CFLAGS)\nendif\n\nOBJ += $(LIBRETRO_COMM_DIR)/audio/conversion/s16_to_float.o \\\n       $(LIBRETRO_COMM_DIR)/audio/conversion/float_to_s16.o \\\n       $(LIBRETRO_COMM_DIR)/audio/conversion/mono_to_stereo_float.o \\\n       $(LIBRETRO_COMM_DIR)/audio/conversion/stereo_to_mono_float.o \\\n\nifeq ($(HAVE_RWAV), 1)\nDEFINES += -DHAVE_RWAV\nOBJ += $(LIBRETRO_COMM_DIR)/formats/wav/rwav.o\nendif\n\nifeq ($(HAVE_NEON),1)\n   OBJ += $(LIBRETRO_COMM_DIR)/audio/conversion/s16_to_float_neon.o \\\n          $(LIBRETRO_COMM_DIR)/audio/conversion/float_to_s16_neon.o\nendif\n\nHW_CONTEXT_MENU_DRIVERS=$(HAVE_MENU)\n\nifeq ($(HW_CONTEXT_MENU_DRIVERS),0)\n   ifeq ($(HAVE_GL_CONTEXT),1)\n      HW_CONTEXT_MENU_DRIVERS=1\n   endif\n   ifeq ($(HAVE_VULKAN),1)\n      HW_CONTEXT_MENU_DRIVERS=1\n   endif\nendif\n\n# XMB and MaterialUI are always enabled if supported and not explicitly disabled\nifeq ($(HW_CONTEXT_MENU_DRIVERS), 1)\n   ifeq ($(HAVE_RGUI),)\n      HAVE_RGUI = 1\n   endif\n\n   ifeq ($(HAVE_MATERIALUI),)\n      HAVE_MATERIALUI = 1\n   endif\n\n   ifeq ($(HAVE_XMB),)\n      HAVE_XMB = 1\n   endif\n\n   ifeq ($(HAVE_OZONE),)\n      HAVE_OZONE = 1\n   endif\nelse\n   HAVE_RGUI        ?= 0\n   HAVE_MATERIALUI  ?= 0\n   HAVE_XMB         ?= 0\n   HAVE_OZONE       ?= 0\nendif\n\nifeq ($(HAVE_MENU), 1)\n   DEFINES += -DHAVE_MENU\n   HAVE_MENU_COMMON = 1\n\n   ifeq ($(HAVE_GFX_WIDGETS), 1)\n      DEFINES += -DHAVE_GFX_WIDGETS\n   endif\n\n   ifeq ($(HAVE_RGUI), 1)\n      OBJ += menu/drivers/rgui.o\n      DEFINES += -DHAVE_RGUI\n   endif\n\n   ifeq ($(HAVE_MATERIALUI), 1)\n      OBJ += menu/drivers/materialui.o\n      DEFINES += -DHAVE_MATERIALUI\n      HAVE_ASSETS = 1\n      HAVE_MENU_SCREENSAVER = 1\n   endif\n\n   ifeq ($(HAVE_XMB), 1)\n      OBJ += menu/drivers/xmb.o\n      DEFINES += -DHAVE_XMB\n      HAVE_ASSETS = 1\n      HAVE_MENU_SCREENSAVER = 1\n   endif\n\n   ifeq ($(HAVE_OZONE), 1)\n      OBJ += menu/drivers/ozone.o\n      DEFINES += -DHAVE_OZONE\n      HAVE_ASSETS = 1\n      HAVE_MENU_SCREENSAVER = 1\n   endif\n\n   ifeq ($(HAVE_MENU_SCREENSAVER), 1)\n      OBJ += menu/menu_screensaver.o\n   endif\nendif\n\nifeq ($(HAVE_BLUETOOTH), 1)\n   DEFINES += -DHAVE_BLUETOOTH\nendif\n\nifeq ($(HAVE_LAKKA), 1)\n   DEFINES += -DHAVE_LAKKA\n   ifneq ($(HAVE_LAKKA_PROJECT),)\n      DEFINES += -DHAVE_LAKKA_PROJECT=\\\"${HAVE_LAKKA_PROJECT}\\\"\n   else\n      $(error You asked for Lakka, but you did not specify a target device name in HAVE_LAKKA_PROJECT)\n   endif\n   ifneq ($(HAVE_LAKKA_SERVER),)\n      DEFINES += -DHAVE_LAKKA_SERVER=\\\"${HAVE_LAKKA_SERVER}\\\"\n   else\n      $(error You asked for Lakka, but you did not specify update server in HAVE_LAKKA_SERVER)\n   endif\nendif\n\nifeq ($(HAVE_LAKKA_SWITCH), 1)\n   DEFINES += -DHAVE_LAKKA_SWITCH\nendif\n\nifeq ($(HAVE_MENU_COMMON), 1)\n   OBJ += menu/menu_setting.o \\\n          menu/menu_driver.o \\\n          menu/cbs/menu_cbs_ok.o \\\n          menu/cbs/menu_cbs_cancel.o \\\n          menu/cbs/menu_cbs_select.o \\\n          menu/cbs/menu_cbs_start.o \\\n          menu/cbs/menu_cbs_info.o \\\n          menu/cbs/menu_cbs_left.o \\\n          menu/cbs/menu_cbs_right.o \\\n          menu/cbs/menu_cbs_deferred_push.o \\\n          menu/cbs/menu_cbs_scan.o \\\n          menu/cbs/menu_cbs_get_value.o \\\n          menu/cbs/menu_cbs_label.o \\\n          menu/cbs/menu_cbs_sublabel.o \\\n          menu/cbs/menu_cbs_title.o \\\n          menu/menu_displaylist.o \\\n          menu/menu_contentless_cores.o\nendif\n\nifeq ($(HAVE_GFX_WIDGETS), 1)\n   OBJ += gfx/gfx_widgets.o\n\n   ifeq ($(HAVE_SCREENSHOTS), 1)\n       OBJ += gfx/widgets/gfx_widget_screenshot.o\n   endif\n\n   OBJ += \\\n          gfx/widgets/gfx_widget_volume.o \\\n          gfx/widgets/gfx_widget_generic_message.o \\\n          gfx/widgets/gfx_widget_libretro_message.o \\\n          gfx/widgets/gfx_widget_progress_message.o \\\n          gfx/widgets/gfx_widget_load_content_animation.o\n   ifeq ($(HAVE_CHEEVOS), 1)\n       OBJ += gfx/widgets/gfx_widget_achievement_popup.o \\\n              gfx/widgets/gfx_widget_leaderboard_display.o\n   endif\nendif\n\nifeq ($(HAVE_OVERLAY), 1)\n   DEFINES += -DHAVE_OVERLAY\n   OBJ += tasks/task_overlay.o \\\n          led/drivers/led_overlay.o\nendif\n\nifeq ($(HAVE_STB_FONT), 1)\n   OBJ += gfx/drivers_font_renderer/stb.o\n   OBJ += gfx/drivers_font_renderer/stb_unicode.o\n   DEFINES += -DHAVE_STB_FONT\nendif\n\nifeq ($(HAVE_FREETYPE), 1)\n   OBJ += gfx/drivers_font_renderer/freetype.o\n   LIBS += $(FREETYPE_LIBS)\n   DEF_FLAGS += $(FREETYPE_CFLAGS)\n   ifeq ($(HAVE_FREETYPE), 1)\n      LIBS += $(FONTCONFIG_LIBS)\n      DEF_FLAGS += $(FONTCONFIG_CFLAGS)\n   endif\nendif\n\nifeq ($(HAVE_THREADS), 1)\n   OBJ += $(LIBRETRO_COMM_DIR)/rthreads/rthreads.o \\\n          gfx/video_thread_wrapper.o \\\n          audio/audio_thread_wrapper.o\n   DEFINES += -DHAVE_THREADS\n   ifeq ($(findstring Haiku,$(OS)),)\n      LIBS += $(THREADS_LIBS)\n   endif\nendif\n\nifeq ($(HAVE_THREAD_STORAGE), 1)\n   DEFINES += -DHAVE_THREAD_STORAGE\nendif\n\nifeq ($(HAVE_VITA2D), 1)\n   OBJ += $(DEPS_DIR)/libvita2d/source/vita2d.o \\\n          $(DEPS_DIR)/libvita2d/source/vita2d_texture.o \\\n          $(DEPS_DIR)/libvita2d/source/vita2d_draw.o \\\n          $(DEPS_DIR)/libvita2d/source/utils.o\n\n   OBJ += $(DEPS_DIR)/libvita2d/shader/clear_v_gxp.o \\\n          $(DEPS_DIR)/libvita2d/shader/clear_f_gxp.o \\\n          $(DEPS_DIR)/libvita2d/shader/color_v_gxp.o \\\n          $(DEPS_DIR)/libvita2d/shader/color_f_gxp.o \\\n          $(DEPS_DIR)/libvita2d/shader/texture_v_gxp.o \\\n          $(DEPS_DIR)/libvita2d/shader/texture_f_gxp.o \\\n          $(DEPS_DIR)/libvita2d/shader/texture_tint_v_gxp.o \\\n          $(DEPS_DIR)/libvita2d/shader/texture_tint_f_gxp.o\n\n   OBJ += gfx/drivers/vita2d_gfx.o\n\n   INCLUDE_DIRS += -I$(DEPS_DIR)/libvita2d/include\nendif\n\nifeq ($(TARGET), retroarch_3ds)\n   OBJ += gfx/drivers/ctr_gfx.o \\\n          input/drivers/ctr_input.o \\\n          input/drivers_joypad/ctr_joypad.o\nendif\n\nifeq ($(TARGET), retroarch_ps2)\n   OBJ += gfx/drivers/ps2_gfx.o \\\n          input/drivers/ps2_input.o \\\n          input/drivers_joypad/ps2_joypad.o \\\n          audio/drivers/ps2_audio.o\nendif\n\nifeq ($(TARGET), retroarch_orbis)\n   OBJ +=  input/drivers/ps4_input.o \\\n\t\t\t  input/drivers_joypad/ps4_joypad.o \\\n\t\t\t  audio/drivers/psp_audio.o\nendif\n\nifeq ($(TARGET), retroarch_vita)\n   OBJ +=  input/drivers/psp_input.o \\\n\t\t\t  input/drivers_joypad/psp_joypad.o \\\n\t\t\t  audio/drivers/psp_audio.o \\\n\t\t\t  frontend/drivers/platform_psp.o\nendif\n\nifeq ($(TARGET), retroarch_wiiu)\n   OBJ +=  gfx/drivers/gx2_gfx.o \\\n\t   input/drivers/wiiu_input.o \\\n\t   input/drivers_joypad/wiiu_joypad.o \\\n\t   input/drivers_joypad/wiiu/wpad_driver.o \\\n\t   input/drivers_joypad/wiiu/kpad_driver.o \\\n\t   input/drivers_joypad/wiiu/pad_functions.o \\\n\t   audio/drivers/wiiu_audio.o \\\n\t   frontend/drivers/platform_wiiu.o\n\n      ifeq ($(WIIU_HID),1)\n         DEFINES += -DWIIU_HID\n\t\t\tINCLUDE_DIRS += -Iinput/include\n         OBJ += input/drivers_joypad/wiiu/hidpad_driver.o\n         OBJ += input/drivers_hid/wiiu_hid.o\n      endif\nendif\n\nifeq ($(TARGET), retroarch_switch)\n   ifeq ($(HAVE_LIBNX), 1)\n      OBJ += gfx/drivers/switch_nx_gfx.o \\\n             audio/drivers/switch_libnx_audren_audio.o \\\n             audio/drivers/switch_libnx_audren_thread_audio.o\n      ifeq ($(HAVE_OPENGL), 1)\n         OBJ += gfx/drivers_context/switch_ctx.o\n      endif\n   endif\n   OBJ += audio/drivers/switch_audio.o \\\n          audio/drivers/switch_thread_audio.o \\\n          input/drivers/switch_input.o \\\n          input/drivers_joypad/switch_joypad.o \\\n          frontend/drivers/platform_switch.o\nendif\n\nifeq ($(TARGET), retroarch_orbis)\n   OBJ += gfx/drivers_context/orbis_ctx.o \\\n          frontend/drivers/platform_orbis.o\nendif\n\nifeq ($(DINGUX), 1)\n   OBJ += dingux/dingux_utils.o\nendif\n\nifeq ($(HAVE_WAYLAND), 1)\n OBJ += gfx/drivers_context/wayland_ctx.o \\\n        input/common/wayland_common.o \\\n        input/drivers/wayland_input.o \\\n        gfx/common/wayland_common.o \\\n        gfx/common/wayland/fractional-scale-v1.o \\\n        gfx/common/wayland/viewporter.o \\\n        gfx/common/wayland/xdg-shell.o \\\n        gfx/common/wayland/idle-inhibit-unstable-v1.o \\\n        gfx/common/wayland/xdg-decoration-unstable-v1.o \\\n        gfx/common/wayland/pointer-constraints-unstable-v1.o \\\n        gfx/common/wayland/relative-pointer-unstable-v1.o \\\n        gfx/common/wayland/cursor-shape-v1.o \\\n        gfx/common/wayland/tablet-unstable-v2.o \\\n        gfx/common/wayland/content-type-v1.o \\\n        gfx/common/wayland/single-pixel-buffer-v1.o\n\n   ifeq ($(HAVE_VULKAN), 1)\n      OBJ += gfx/drivers_context/wayland_vk_ctx.o\n   endif\n\n DEF_FLAGS += $(WAYLAND_CFLAGS) $(WAYLAND_CURSOR_CFLAGS)\n LIBS += $(WAYLAND_LIBS) $(WAYLAND_CURSOR_LIBS)\n\n ifeq ($(HAVE_LIBDECOR), 1)\n    DEFINES += -DHAVE_LIBDECOR_H\n    DEF_FLAGS += $(LIBDECOR_CFLAGS)\n endif\n\nendif\n\n# XML\nOBJ += \\\n       $(LIBRETRO_COMM_DIR)/formats/xml/rxml.o \\\n       $(LIBRETRO_COMM_DIR)/formats/logiqx_dat/logiqx_dat.o \\\n       deps/yxml/yxml.o\n\n#Input\n\nifeq ($(HAVE_DINPUT), 1)\n   HAVE_DX_COMMON  = 1\n   LIBS += -ldinput8 -lole32\n   DEFINES += -DHAVE_DINPUT\n   OBJ += input/drivers/dinput.o\n   OBJ += input/drivers_joypad/dinput_joypad.o\nendif\n\nifeq ($(HAVE_XINPUT), 1)\n   DEFINES += -DHAVE_XINPUT\n   ifeq ($(HAVE_DINPUT), 1)\n      OBJ += input/drivers_joypad/xinput_hybrid_joypad.o\n   else\n      OBJ += input/drivers_joypad/xinput_joypad.o\n   endif\nendif\n\nifeq ($(HAVE_OPENDINGUX_FBDEV), 1)\n   OBJ += gfx/drivers_context/opendingux_fbdev_ctx.o\nendif\n\nifeq ($(HAVE_X11), 1)\n   OBJ += input/common/input_x11_common.o \\\n          input/drivers/x11_input.o \\\n          gfx/common/x11_common.o \\\n          gfx/common/xinerama_common.o \\\n          gfx/display_servers/dispserv_x11.o\n\n   LIBS += $(X11_LIBS) $(XEXT_LIBS) $(XF86VM_LIBS) $(XINERAMA_LIBS) $(XRANDR_LIBS)\n   DEFINES += -DHAVE_X11\n   DEF_FLAGS += $(X11_CFLAGS) $(XEXT_CFLAGS) $(XF86VM_CFLAGS) $(XINERAMA_CFLAGS)\n   ifeq ($(HAVE_XCB),1)\n      LIBS += -lX11-xcb\n   endif\n   ifeq ($(HAVE_XSCRNSAVER),1)\n      LIBS += -lXss\n   endif\n   ifneq ($(HAVE_OPENGLES), 1)\n      OBJ += gfx/drivers_context/x_ctx.o\n   endif\n   ifeq ($(HAVE_VULKAN), 1)\n      OBJ += gfx/drivers_context/x_vk_ctx.o\n   endif\nendif\n\nifeq ($(HAVE_XCB),1)\n   DEF_FLAGS += $(XCB_CFLAGS)\n   LIBS      += $(XCB_LIBS)\nendif\n\nifeq ($(HAVE_XKBCOMMON), 1)\n   DEF_FLAGS += $(XKBCOMMON_CFLAGS)\n   OBJ += input/drivers_keyboard/keyboard_event_xkb.o\n   LIBS += $(XKBCOMMON_LIBS)\nendif\n\nifeq ($(HAVE_DBUS), 1)\n   LIBS += $(DBUS_LIBS)\n   DEF_FLAGS += $(DBUS_CFLAGS)\n   OBJ += gfx/common/dbus_common.o\nendif\n\nifeq ($(HAVE_UDEV), 1)\n   DEF_FLAGS += $(UDEV_CFLAGS)\n   LIBS += $(UDEV_LIBS)\n   OBJ += input/drivers/udev_input.o \\\n          input/drivers_joypad/udev_joypad.o\nendif\n\nifeq ($(HAVE_LIBUSB), 1)\n   DEFINES += -DHAVE_LIBUSB\n   OBJ += input/drivers_hid/libusb_hid.o\n   DEF_FLAGS += $(LIBUSB_CFLAGS)\n   LIBS += $(LIBUSB_LIBS)\nendif\n\nifeq ($(HAVE_IOHIDMANAGER), 1)\n   HAVE_HID=1\n   DEFINES += -DHAVE_IOHIDMANAGER\n   OBJ += input/drivers_hid/iohidmanager_hid.o\n   LIBS += -framework IOKit\nendif\n\nifeq ($(HAVE_HID), 1)\n   DEFINES += -DHAVE_HID\n   OBJ += input/drivers_joypad/hid_joypad.o \\\n          input/connect/joypad_connection.o \\\n          input/connect/connect_ps2adapter.o \\\n          input/connect/connect_psxadapter.o \\\n          input/connect/connect_ps3.o \\\n          input/connect/connect_ps4.o \\\n          input/connect/connect_ps4_hori_mini.o \\\n          input/connect/connect_wii.o \\\n          input/connect/connect_retrode.o \\\n          input/connect/connect_nesusb.o \\\n          input/connect/connect_snesusb.o \\\n          input/connect/connect_wiiupro.o \\\n\t  input/connect/connect_kade.o \\\n\t  input/connect/connect_zerodelay_dragonrise.o \\\n          input/connect/connect_wiiugca.o\nendif\n\nifeq ($(HAVE_PARPORT), 1)\n   OBJ += input/drivers_joypad/parport_joypad.o\nendif\n\nifneq ($(findstring Win32,$(OS)),)\nifeq ($(HAVE_WINRAWINPUT), 1)\n   DEFINES += -DHAVE_WINRAWINPUT\n   OBJ     += input/drivers/winraw_input.o\nendif\nendif\n\nifeq ($(HAVE_LIBSHAKE), 1)\nifeq ($(OSX), 1)\n   DEFINES      += -DHAVE_LIBSHAKE\n   INCLUDE_DIRS += -I$(DEPS_DIR)/libShake/include\n   OBJ          += $(DEPS_DIR)/libShake/src/common/error.o \\\n                   $(DEPS_DIR)/libShake/src/common/helpers.o \\\n                   $(DEPS_DIR)/libShake/src/common/presets.o \\\n                   $(DEPS_DIR)/libShake/src/osx/shake.o\nelse ifeq ($(HAVE_UNIX), 1)\n   DEFINES      += -DHAVE_LIBSHAKE\n   INCLUDE_DIRS += -I$(DEPS_DIR)/libShake/include\n   OBJ          += $(DEPS_DIR)/libShake/src/common/error.o \\\n                   $(DEPS_DIR)/libShake/src/common/helpers.o \\\n                   $(DEPS_DIR)/libShake/src/common/presets.o \\\n                   $(DEPS_DIR)/libShake/src/linux/shake.o\nendif\nendif\n\n# Companion UI\n\nifneq ($(findstring Win32,$(OS)),)\n   OBJ += ui/drivers/ui_win32.o\nendif\n\n# Video\n\nOBJ += gfx/drivers_context/gfx_null_ctx.o\n\nifeq ($(HAVE_KMS), 1)\n   HAVE_AND_WILL_USE_DRM = 1\n   OBJ += gfx/drivers_context/drm_ctx.o \\\n\t\t  gfx/display_servers/dispserv_kms.o\n\nifeq ($(HAVE_ODROIDGO2), 1)\n   OBJ += gfx/drivers_context/drm_go2_ctx.o\nendif\n   DEF_FLAGS += $(GBM_CFLAGS) $(DRM_CFLAGS)\n   LIBS += $(GBM_LIBS) $(DRM_LIBS)\nendif\n\nifeq ($(HAVE_CACA), 1)\n   DEFINES += -DHAVE_CACA\n   OBJ += gfx/drivers/caca_gfx.o\n   LIBS += $(CACA_LIBS)\n   DEF_FLAGS += $(CACA_CFLAGS)\nendif\n\nifeq ($(HAVE_SIXEL), 1)\n   DEFINES += -DHAVE_SIXEL\n   INCLUDE_DIRS += -I/usr/include/sixel\n   OBJ += gfx/drivers/sixel_gfx.o\n   LIBS += $(SIXEL_LIBS)\n   DEF_FLAGS += $(SIXEL_CFLAGS)\nendif\n\nifeq ($(HAVE_NETWORK_VIDEO), 1)\n   ifneq ($(NETWORK_VIDEO_HOST),)\n      DEFINES += -DNETWORK_VIDEO_HOST=$(NETWORK_VIDEO_HOST)\n   else\n      DEFINES += -DNETWORK_VIDEO_HOST=127.0.0.1\n   endif\n\n   ifneq ($(NETWORK_VIDEO_PORT),)\n      DEFINES += -DNETWORK_VIDEO_PORT=$(NETWORK_VIDEO_PORT)\n   else\n      DEFINES += -DNETWORK_VIDEO_PORT=4953\n   endif\n\n   DEFINES += -DHAVE_NETWORK_VIDEO\n   OBJ += gfx/drivers/network_gfx.o\nendif\n\nifeq ($(HAVE_PLAIN_DRM), 1)\n   OBJ += gfx/drivers/drm_gfx.o\n   ifneq ($(HAVE_LAKKA), 1)\n      INCLUDE_DIRS += -I/usr/include/libdrm\n   endif\n   LIBS += -ldrm\nendif\n\nifeq ($(HAVE_VITAGL), 1)\n   DEFINES += -DHAVE_OPENGL1 -DHAVE_VITAGL\n   OBJ += gfx/drivers/gl1.o \\\n          gfx/drivers_context/vita_ctx.o\nendif\n\nifeq ($(HAVE_VITAGLES), 1)\n   OBJ += gfx/drivers_context/vita_ctx.o\nendif\n\nifeq ($(HAVE_GL_CONTEXT), 1)\n   OBJ += gfx/common/gl_common.o\n   ifeq ($(HAVE_GL_MODERN), 1)\n      DEFINES += -DHAVE_OPENGL\n      OBJ += gfx/drivers/gl2.o \\\n             $(LIBRETRO_COMM_DIR)/gfx/gl_capabilities.o\n   endif\n\n   OBJ += $(LIBRETRO_COMM_DIR)/glsym/rglgen.o\n\n   ifeq ($(HAVE_OPENGL1), 1)\n      DEFINES += -DHAVE_OPENGL1\n      OBJ += gfx/drivers/gl1.o\n   endif\n\n   ifeq ($(HAVE_VIDEOCORE), 1)\n      OBJ += gfx/drivers_context/vc_egl_ctx.o\n   endif\n\n   ifeq ($(HAVE_EMSCRIPTEN), 1)\n      OBJ += gfx/drivers_context/emscriptenegl_ctx.o\n   endif\n\n   ifeq ($(HAVE_MALI_FBDEV), 1)\n      OBJ += gfx/drivers_context/mali_fbdev_ctx.o\n   endif\n\n   ifeq ($(HAVE_VIVANTE_FBDEV), 1)\n      OBJ += gfx/drivers_context/vivante_fbdev_ctx.o\n   endif\n\n   ifeq ($(HAVE_X11), 1)\n      ifeq ($(HAVE_EGL), 1)\n         OBJ += gfx/drivers_context/xegl_ctx.o\n      endif\n   endif\n\n   ifeq ($(HAVE_OSMESA), 1)\n      OBJ  += gfx/drivers_context/osmesa_ctx.o\n      LIBS += -lOSMesa\n   endif\n\n   ifeq ($(HAVE_FFMPEG), 1)\n      ifneq ($(HAVE_OPENGLES), 1)\n         OBJ += cores/libretro-ffmpeg/ffmpeg_fft.o\n         DEFINES += -DHAVE_GL_FFT\n         INCLUDE_DIRS += -I$(DEPS_DIR)\n      endif\n   endif\n\n\n   ifeq ($(HAVE_MPV), 1)\n      OBJ += cores/libretro-mpv/mpv-libretro.o\n      DEFINES += -DHAVE_MPV\n      INCLUDE_DIRS += -I$(DEPS_DIR)\n      LIBS += -lmpv\n   endif\n\n   ifeq ($(HAVE_OPENGLES), 1)\n      DEFINES += -DHAVE_OPENGLES\n      LIBS += $(OPENGLES_LIBS)\n      DEF_FLAGS += $(OPENGLES_CFLAGS)\n      ifeq ($(HAVE_OPENGLES3), 1)\n         DEFINES += -DHAVE_OPENGLES3\n      else\n         DEFINES += -DHAVE_OPENGLES2\n      endif\n      OBJ += $(LIBRETRO_COMM_DIR)/glsym/glsym_es2.o\n   else\n      DEFINES += -DHAVE_GL_SYNC\n      OBJ += $(LIBRETRO_COMM_DIR)/glsym/glsym_gl.o\n      GL_LIBS := $(OPENGL_LIBS)\n      ifeq ($(OSX), 1)\n         GL_LIBS := -framework OpenGL\n      else ifneq ($(findstring Win32,$(OS)),)\n         GL_LIBS := -lopengl32 -lgdi32 -lcomdlg32\n    WANT_WGL=1\n      endif\n      LIBS += $(GL_LIBS)\n   endif\n\nendif\n\nifeq ($(HAVE_METAL), 1)\n   DEFINES += -DHAVE_METAL\n   LIBS += -framework Metal -framework MetalKit\n   # Metal code relies on ARC (Automatic Reference Counting), enable it\n   DEF_FLAGS += -fobjc-arc\n   OBJ += \\\n\t  gfx/common/metal/metal_renderer.o \\\n\t  gfx/drivers/metal.o\nendif\n\nifeq ($(HAVE_EGL), 1)\n   DEFINES += -DHAVE_EGL\n   DEF_FLAGS += $(EGL_CFLAGS)\n   OBJ += gfx/common/egl_common.o\n\nifeq ($(HAVE_DYNAMIC_EGL), 1)\n\tDEFINES += -DHAVE_DYNAMIC_EGL\nelse\n   LIBS += $(EGL_LIBS)\nendif\n\nendif\n\nifeq ($(HAVE_SDL2), 1)\n   HAVE_SDL_COMMON = 1\n   OBJ += gfx/drivers/sdl2_gfx.o \\\n\t\t\t gfx/common/sdl2_common.o\n   DEF_FLAGS += $(SDL2_CFLAGS)\n   LIBS += $(SDL2_LIBS)\n\n   ifeq ($(HAVE_MICROPHONE), 1)\n      OBJ += audio/drivers_microphone/sdl_microphone.o\n      # Microphones are not supported by SDL 1.x\n   endif\nelse ifeq ($(HAVE_SDL), 1)\n   HAVE_SDL_COMMON = 1\n   OBJ += gfx/drivers/sdl_gfx.o\n   DEF_FLAGS += $(SDL_CFLAGS)\n   LIBS += $(SDL_LIBS)\nelse ifeq ($(HAVE_SDL_DINGUX), 1)\n   HAVE_SDL_COMMON = 1\n   DEF_FLAGS += -DHAVE_SDL -DHAVE_SDL_DINGUX\n\n   ifeq ($(RS90), 1)\n      OBJ += gfx/drivers/sdl_rs90_gfx.o\n   else ifeq ($(MIYOO), 1)\n      OBJ += gfx/drivers/sdl_rs90_gfx.o\n   else\n      OBJ += gfx/drivers/sdl_dingux_gfx.o\n   endif\n\n   OBJ += input/drivers/sdl_dingux_input.o \\\n          input/drivers_joypad/sdl_dingux_joypad.o\n   DEF_FLAGS += $(SDL_DINGUX_CFLAGS)\n   LIBS += $(SDL_DINGUX_LIBS)\nendif\n\nifeq ($(HAVE_SDL_COMMON), 1)\n   OBJ += input/drivers/sdl_input.o \\\n          input/drivers_joypad/sdl_joypad.o \\\n          audio/drivers/sdl_audio.o\n\n   ifeq ($(HAVE_GL_CONTEXT), 1)\n      OBJ += gfx/drivers_context/sdl_gl_ctx.o\n   endif\n\n   INCLUDE_DIRS += $(BSD_LOCAL_INC)\nendif\n\nifeq ($(HAVE_XSHM), 1)\n   OBJ += gfx/drivers/xshm_gfx.o\nendif\n\nifeq ($(HAVE_VULKAN), 1)\n   ifneq ($(findstring Win32,$(OS)),)\n      WANT_WGL = 1\n      # Trivial temporary workaround for MinGW and glslang.\n      CXXFLAGS += -fpermissive\n   endif\n\n   CXXFLAGS += -Wno-switch -Wno-sign-compare -fno-strict-aliasing -Wno-reorder -Wno-parentheses\n\n   OBJ += gfx/drivers/vulkan.o \\\n          gfx/common/vulkan_common.o \\\n          $(LIBRETRO_COMM_DIR)/vulkan/vulkan_symbol_wrapper.o\n\n   ifeq ($(HAVE_SLANG), 1)\n      OBJ += gfx/drivers_shader/shader_vulkan.o\n   endif\n\n   ifeq ($(HAVE_VULKAN_DISPLAY), 1)\n      OBJ += gfx/drivers_context/khr_display_ctx.o\n   endif\n   NEED_CXX_LINKER = 1\n   DEFINES += -DHAVE_VULKAN\n   INCLUDE_DIRS += -Igfx/include\nendif\n\nifeq ($(HAVE_OPENGL_CORE), 1)\n   OBJ += gfx/drivers/gl3.o \\\n\t  gfx/drivers_shader/shader_gl3.o\n\n   DEFINES += -DHAVE_OPENGL_CORE\n   NEED_CXX_LINKER  = 1\nendif\n\nifeq ($(HAVE_OMAP), 1)\n   OBJ += gfx/drivers/omap_gfx.o\nendif\n\nifeq ($(HAVE_EXYNOS), 1)\n   OBJ += gfx/drivers/exynos_gfx.o\n   LIBS += $(DRM_LIBS) $(EXYNOS_LIBS)\n   DEF_FLAGS += $(DRM_CFLAGS) $(EXYNOS_CFLAGS)\n   HAVE_AND_WILL_USE_DRM = 1\nendif\n\nifeq ($(HAVE_AND_WILL_USE_DRM), 1)\n   OBJ += gfx/common/drm_common.o\nendif\n\nifeq ($(HAVE_DISPMANX), 1)\n   OBJ += gfx/drivers/dispmanx_gfx.o\n   HAVE_VIDEOCORE = 1\nendif\n\nifeq ($(HAVE_SUNXI), 1)\n   OBJ += gfx/drivers/sunxi_gfx.o \\\n          gfx/include/pixman/pixman-arm-neon-asm.o\nendif\n\nifeq ($(HAVE_VG), 1)\n   OBJ += gfx/drivers/vg.o\n   DEF_FLAGS += $(VG_CFLAGS)\n   LIBS += $(VG_LIBS)\nendif\n\nifeq ($(HAVE_XVIDEO), 1)\n   OBJ += gfx/drivers/xvideo.o\n   LIBS += $(XVIDEO_LIBS)\n   DEF_FLAGS += $(XVIDEO_CFLAGS)\nendif\n\nifeq ($(HAVE_D3D9), 1)\n   HAVE_D3D_COMMON = 1\n   DEFINES += -DHAVE_D3D9\n   ifeq ($(HAVE_D3DX9), 1)\n      HAVE_D3DX_COMMON = 1\n   endif\n   ifneq ($(HAVE_DYLIB), 1)\n      LIBS += $(D3D9_LIBS)\n      ifeq ($(HAVE_D3DX9), 1)\n         LIBS += $(D3DX9_LIBS)\n      endif\n   endif\n   HAVE_DX_COMMON  = 1\n   OBJ  += gfx/drivers_font/d3d9x_w32_font.o\n   ifeq ($(HAVE_CG), 1)\n      LIBS += -lcgD3D9\n      OBJ  += gfx/drivers/d3d9cg.o\n   endif\nendif\n\nifeq ($(HAVE_D3D10), 1)\n   HAVE_D3D_COMMON = 1\n   OBJ += gfx/drivers/d3d10.o \\\n          gfx/common/d3d10_common.o\n   DEFINES += -DHAVE_D3D10\nendif\n\nifeq ($(HAVE_D3D11), 1)\n   HAVE_D3D_COMMON = 1\n   OBJ += gfx/drivers/d3d11.o \\\n          gfx/common/d3d11_common.o\n   DEFINES += -DHAVE_D3D11\nendif\n\nifeq ($(HAVE_D3D12), 1)\n   HAVE_D3D_COMMON = 1\n   OBJ += gfx/drivers/d3d12.o \\\n          gfx/common/d3d12_common.o\n   DEFINES += -DHAVE_D3D12\nendif\n\nifneq ($(findstring 1, $(HAVE_D3D10) $(HAVE_D3D11) $(HAVE_D3D12)),)\n   INCLUDE_DIRS += -isystemgfx/include/dxsdk\n   OBJ += gfx/common/d3dcompiler_common.o \\\n          gfx/common/dxgi_common.o\n   DEF_FLAGS += -Wno-unknown-pragmas\nendif\n\nifeq ($(HAVE_D3D8), 1)\n   HAVE_D3D_COMMON = 1\n   HAVE_DX_COMMON  = 1\n   DEFINES += -DHAVE_D3D8\n   ifeq ($(HAVE_D3DX8), 1)\n      HAVE_D3DX_COMMON = 1\n   endif\n   ifneq ($(HAVE_DYLIB), 1)\n      LIBS += $(D3D8_LIBS)\n      ifeq ($(HAVE_D3DX8), 1)\n         LIBS += $(D3DX8_LIBS)\n      endif\n   endif\nendif\n\nifeq ($(HAVE_D3DX_COMMON), 1)\n   DEFINES += -DHAVE_D3DX\nendif\n\nifeq ($(HAVE_DX_COMMON), 1)\n   LIBS += -ldxguid\nendif\n\nifeq ($(HAVE_D3D8), 1)\n   DEFINES += -DHAVE_D3D8\n   OBJ += gfx/drivers/d3d8.o\nendif\n\nifeq ($(HAVE_D3D9), 1)\n   DEFINES += -DHAVE_D3D9\n   OBJ += gfx/common/d3d9_common.o\nendif\n\nifeq ($(HAVE_D3D_COMMON), 1)\n   DEFINES += -DHAVE_D3D\n   OBJ     += gfx/common/d3d_common.o\nendif\n\nifeq ($(HAVE_CG), 1)\n   DEFINES += -DHAVE_CG\n   OBJ += gfx/drivers_shader/shader_gl_cg.o\n   LIBS += $(CG_LIBS)\nendif\n\nifeq ($(HAVE_GLSL), 1)\n   DEFINES += -DHAVE_GLSL\n   OBJ += gfx/drivers_shader/shader_glsl.o\nendif\n\nifeq ($(HAVE_HLSL),1)\n   DEFINES += -DHAVE_HLSL\n   OBJ += gfx/drivers/d3d9hlsl.o\nendif\n\nifeq ($(HAVE_SLANG),1)\n   DEFINES += -DHAVE_SLANG\n   OBJ += gfx/drivers_shader/slang_process.o\n   OBJ += gfx/drivers_shader/glslang_util.o\n   OBJ += gfx/drivers_shader/glslang_util_cxx.o\n   OBJ += gfx/drivers_shader/slang_reflection.o\nendif\n\nifeq ($(HAVE_SHADERS_COMMON), 1)\n   OBJ += gfx/video_shader_parse.o\nendif\n\nifeq ($(HAVE_BUILTINGLSLANG), 1)\n   NEED_CXX_LINKER = 1\n   HAVE_GLSLANG_COMMON = 1\n\n   ifneq ($(findstring Win32,$(OS)),)\n      GLSLANG_PLATFORM := Windows\n   else\n      GLSLANG_PLATFORM := Unix\n   endif\n\n   DEFINES += -DHAVE_BUILTINGLSLANG\n\n   INCLUDE_DIRS += \\\n      -I$(DEPS_DIR)/glslang/glslang/glslang/OSDependent/$(GLSLANG_PLATFORM) \\\n      -I$(DEPS_DIR)/glslang/glslang/OGLCompilersDLL \\\n      -I$(DEPS_DIR)/glslang/glslang/glslang/MachineIndependent \\\n      -I$(DEPS_DIR)/glslang/glslang/glslang/Public \\\n      -I$(DEPS_DIR)/glslang/glslang/SPIRV\n\n   GLSLANG_SOURCES := \\\n      gfx/drivers_shader/glslang.cpp \\\n\t\t$(DEPS_DIR)/glslang/glslang/SPIRV/GlslangToSpv.cpp \\\n\t\t$(DEPS_DIR)/glslang/glslang/SPIRV/InReadableOrder.cpp \\\n\t\t$(DEPS_DIR)/glslang/glslang/SPIRV/Logger.cpp \\\n\t\t$(DEPS_DIR)/glslang/glslang/SPIRV/SpvBuilder.cpp \\\n      $(wildcard $(DEPS_DIR)/glslang/glslang/glslang/GenericCodeGen/*.cpp) \\\n      $(wildcard $(DEPS_DIR)/glslang/glslang/OGLCompilersDLL/*.cpp) \\\n      $(wildcard $(DEPS_DIR)/glslang/glslang/glslang/MachineIndependent/*.cpp) \\\n      $(wildcard $(DEPS_DIR)/glslang/glslang/glslang/MachineIndependent/preprocessor/*.cpp) \\\n      $(DEPS_DIR)/glslang/glslang/glslang/OSDependent/$(GLSLANG_PLATFORM)/ossource.cpp\nelse ifeq ($(HAVE_GLSLANG),1)\n   HAVE_GLSLANG_COMMON = 1\n   GLSLANG_SOURCES := gfx/drivers_shader/glslang.cpp\n\n   # The order of these libs are somewhat specific\n   LIBS += $(GLSLANG_LIBS) \\\n           $(GLSLANG_MACHINEINDEPENDENT_LIBS) \\\n           $(GLSLANG_GENERICCODEGEN_LIBS) \\\n           $(GLSLANG_OSDEPENDENT_LIBS) \\\n           $(GLSLANG_OGLCOMPILER_LIBS) \\\n           $(GLSLANG_SPIRV_LIBS) \\\n           $(GLSLANG_SPIRV_TOOLS_OPT_LIBS) \\\n           $(GLSLANG_SPIRV_TOOLS_LIBS)\nendif\n\nifeq ($(HAVE_GLSLANG_COMMON), 1)\n   DEFINES += -DHAVE_GLSLANG\n   OBJ += $(GLSLANG_SOURCES_C:.c=.o)\n   OBJ += $(GLSLANG_SOURCES:.cpp=.o)\nendif\n\nifeq ($(HAVE_SPIRV_CROSS), 1)\n   DEFINES += -DHAVE_SPIRV_CROSS\n   INCLUDE_DIRS += -I$(DEPS_DIR)/SPIRV-Cross\n   OBJ += $(DEPS_DIR)/SPIRV-Cross/spirv_cross.o\n   OBJ += $(DEPS_DIR)/SPIRV-Cross/spirv_cfg.o\n   OBJ += $(DEPS_DIR)/SPIRV-Cross/spirv_glsl.o\n   OBJ += $(DEPS_DIR)/SPIRV-Cross/spirv_hlsl.o\n   OBJ += $(DEPS_DIR)/SPIRV-Cross/spirv_msl.o\n   OBJ += $(DEPS_DIR)/SPIRV-Cross/spirv_parser.o\n   OBJ += $(DEPS_DIR)/SPIRV-Cross/spirv_cross_parsed_ir.o\nendif\n\nifeq ($(WANT_WGL), 1)\n   OBJ += gfx/drivers_context/wgl_ctx.o\n   ifeq ($(HAVE_VULKAN),1)\n      OBJ += gfx/drivers_context/w_vk_ctx.o\n   endif\n   LIBS += -lcomctl32\nendif\n\n# Compression/Archive\n\nOBJ += $(LIBRETRO_COMM_DIR)/file/archive_file.o \\\n       $(LIBRETRO_COMM_DIR)/streams/trans_stream.o \\\n       $(LIBRETRO_COMM_DIR)/streams/trans_stream_pipe.o\n\nifeq ($(HAVE_7ZIP),1)\n   INCLUDE_DIRS += -I$(DEPS_DIR)/7zip\n   HAVE_COMPRESSION = 1\n   DEFINES += -DHAVE_7ZIP -D_7ZIP_ST\n   7ZOBJ = $(DEPS_DIR)/7zip/7zArcIn.o \\\n           $(DEPS_DIR)/7zip/7zBuf.o \\\n           $(DEPS_DIR)/7zip/7zCrc.o \\\n           $(DEPS_DIR)/7zip/7zCrcOpt.o \\\n           $(DEPS_DIR)/7zip/7zDec.o \\\n           $(DEPS_DIR)/7zip/CpuArch.o \\\n           $(DEPS_DIR)/7zip/Delta.o \\\n           $(DEPS_DIR)/7zip/LzFind.o \\\n           $(DEPS_DIR)/7zip/LzmaDec.o \\\n           $(DEPS_DIR)/7zip/Lzma2Dec.o \\\n           $(DEPS_DIR)/7zip/LzmaEnc.o \\\n           $(DEPS_DIR)/7zip/Bra.o \\\n           $(DEPS_DIR)/7zip/Bra86.o \\\n           $(DEPS_DIR)/7zip/BraIA64.o \\\n           $(DEPS_DIR)/7zip/Bcj2.o \\\n           $(DEPS_DIR)/7zip/7zFile.o \\\n           $(DEPS_DIR)/7zip/7zStream.o\n\n   OBJ +=  $(LIBRETRO_COMM_DIR)/file/archive_file_7z.o \\\n           $(7ZOBJ)\nendif\n\nifeq ($(HAVE_IBXM), 1)\n   DEFINES += -DHAVE_IBXM\n   OBJ += $(DEPS_DIR)/ibxm/ibxm.o\nendif\n\nifeq ($(HAVE_BUILTINFLAC),1)\n   HAVE_FLAC = 1\n   DEFINES += -DHAVE_FLAC -DHAVE_DR_FLAC  -DHAVE_STDINT_H -DHAVE_LROUND -DFLAC__HAS_OGG=0 \\\n              -DFLAC_PACKAGE_VERSION=\"\\\"retroarch\\\"\"\n   INCLUDE_DIRS += -I$(DEPS_DIR) -I$(DEPS_DIR)/libFLAC/include\n   FLACOBJ = $(DEPS_DIR)/libFLAC/bitmath.o \\\n             $(DEPS_DIR)/libFLAC/bitreader.o \\\n             $(DEPS_DIR)/libFLAC/cpu.o \\\n             $(DEPS_DIR)/libFLAC/crc.o \\\n             $(DEPS_DIR)/libFLAC/fixed.o \\\n             $(DEPS_DIR)/libFLAC/float.o \\\n             $(DEPS_DIR)/libFLAC/format.o \\\n             $(DEPS_DIR)/libFLAC/lpc.o \\\n             $(DEPS_DIR)/libFLAC/lpc_intrin_avx2.o \\\n             $(DEPS_DIR)/libFLAC/lpc_intrin_sse2.o \\\n             $(DEPS_DIR)/libFLAC/lpc_intrin_sse41.o \\\n             $(DEPS_DIR)/libFLAC/lpc_intrin_sse.o \\\n             $(DEPS_DIR)/libFLAC/md5.o \\\n             $(DEPS_DIR)/libFLAC/memory.o \\\n             $(DEPS_DIR)/libFLAC/stream_decoder.o\n   ifneq ($(findstring Win32,$(OS)),)\n      DEFINES += -DHAVE_FSEEKO\n      # make sure not to use this on legacy Windows versions that don't have W-functions implemented\n      DEFINES += -DNEED_UTF8_SUPPORT\n      FLACOBJ += $(DEPS_DIR)/libFLAC/windows_unicode_filenames.o\n   endif\n   OBJ += $(FLACOBJ)\nelse ifeq ($(HAVE_FLAC),1)\n   DEFINES += -DHAVE_FLAC\n   LIBS    += $(FLAC_LIBS)\nendif\n\nifeq ($(HAVE_BUILTINZLIB), 1)\n   HAVE_ZLIB_COMMON = 1\n   OBJ += $(DEPS_DIR)/libz/adler32.o \\\n          $(DEPS_DIR)/libz/libz-crc32.o \\\n          $(DEPS_DIR)/libz/deflate.o \\\n          $(DEPS_DIR)/libz/gzclose.o \\\n          $(DEPS_DIR)/libz/gzlib.o \\\n          $(DEPS_DIR)/libz/gzread.o \\\n          $(DEPS_DIR)/libz/gzwrite.o \\\n          $(DEPS_DIR)/libz/inffast.o \\\n          $(DEPS_DIR)/libz/inflate.o \\\n          $(DEPS_DIR)/libz/inftrees.o \\\n          $(DEPS_DIR)/libz/trees.o \\\n          $(DEPS_DIR)/libz/zutil.o\n   INCLUDE_DIRS += -I$(LIBRETRO_COMM_DIR)/include/compat/zlib\nelse ifeq ($(HAVE_ZLIB),1)\n   HAVE_ZLIB_COMMON = 1\n   LIBS += $(ZLIB_LIBS)\nendif\n\nifeq ($(HAVE_ZLIB_COMMON), 1)\n   OBJ += $(LIBRETRO_COMM_DIR)/file/archive_file_zlib.o \\\n          $(LIBRETRO_COMM_DIR)/streams/trans_stream_zlib.o \\\n          $(LIBRETRO_COMM_DIR)/streams/rzip_stream.o\n   DEFINES += -DHAVE_ZLIB\n   HAVE_COMPRESSION = 1\n\n   ifeq ($(HAVE_CHD), 1)\n      INCLUDE_DIRS += -I$(LIBRETRO_COMM_DIR)/formats/libchdr\n      DEFINES += -DHAVE_CHD -DWANT_SUBCODE -DWANT_RAW_DATA_SECTOR\n      ifeq ($(HAVE_STATIC_CORES), 1)\n         DEFINES += -Dbitstream_overflow=retroarch_internal_bitstream_overflow\n         DEFINES += -Dcreate_bitstream=retroarch_internal_create_bitstream\n         DEFINES += -Dbitstream_peek=retroarch_internal_bitstream_peek\n         DEFINES += -Dbitstream_remove=retroarch_internal_bitstream_remove\n         DEFINES += -Dbitstream_read=retroarch_internal_bitstream_read\n         DEFINES += -Dbitstream_read_offset=retroarch_internal_bitstream_read_offset\n         DEFINES += -Dbitstream_flush=retroarch_internal_bitstream_flush\n\n         DEFINES += -Decc_compute_bytes=retroarch_internal_ecc_compute_bytes\n         DEFINES += -Decc_verify=retroarch_internal_ecc_verify\n         DEFINES += -Decc_generate=retroarch_internal_ecc_generate\n         DEFINES += -Decc_clear=retroarch_internal_ecc_clear\n\n         DEFINES += -Ds_cd_sync_header=retroarch_internal_s_cd_sync_header\n         DEFINES += -Dchd_open_file=retroarch_internal_chd_open_file\n         DEFINES += -Dchd_precache=retroarch_internal_chd_precache\n         DEFINES += -Dchd_open=retroarch_internal_chd_open\n         DEFINES += -Dchd_close=retroarch_internal_chd_close\n         DEFINES += -Dchd_core_file=retroarch_internal_chd_core_file\n         DEFINES += -Dchd_error_string=retroarch_internal_chd_error_string\n         DEFINES += -Dchd_get_header=retroarch_internal_chd_get_header\n         DEFINES += -Dchd_read=retroarch_internal_chd_read\n         DEFINES += -Dchd_get_metadata=retroarch_internal_chd_get_metadata\n         DEFINES += -Dchd_codec_config=retroarch_internal_chd_codec_config\n         DEFINES += -Dchd_get_codec_name=retroarch_internal_chd_get_codec_name\n\n         DEFINES += -Dcreate_huffman_decoder=retroarch_internal_create_huffman_decoder\n         DEFINES += -Ddelete_huffman_decoder=retroarch_internal_delete_huffman_decoder\n         DEFINES += -Dhuffman_decode_one=retroarch_internal_huffman_decode_one\n         DEFINES += -Dhuffman_import_tree_rle=retroarch_internal_huffman_import_tree_rle\n         DEFINES += -Dhuffman_import_tree_huffman=retroarch_internal_huffman_import_tree_huffman\n         DEFINES += -Dhuffman_compute_tree_from_histo=retroarch_internal_huffman_compute_tree_from_histo\n         DEFINES += -Dhuffman_build_tree=retroarch_internal_huffman_build_tree\n         DEFINES += -Dhuffman_assign_canonical_codes=retroarch_internal_huffman_assign_canonical_codes\n         DEFINES += -Dhuffman_build_lookup_table=retroarch_internal_huffman_build_lookup_table\n\n         DEFINES += -Dcdzl_codec_init=retroarch_internal_cdzl_codec_init\n         DEFINES += -Dcdzl_codec_free=retroarch_internal_cdzl_codec_free\n         DEFINES += -Dcdzl_codec_decompress=retroarch_internal_cdzl_codec_decompress\n         DEFINES += -Dzlib_codec_init=retroarch_internal_zlib_codec_init\n         DEFINES += -Dzlib_codec_free=retroarch_internal_zlib_codec_free\n         DEFINES += -Dzlib_codec_decompress=retroarch_internal_zlib_codec_decompress\n         DEFINES += -Dzlib_fast_alloc=retroarch_internal_zlib_fast_alloc\n         DEFINES += -Dzlib_fast_free=retroarch_internal_zlib_fast_free\n\n         DEFINES += -Dchdstream_open=retroarch_internal_chdstream_open\n         DEFINES += -Dchdstream_close=retroarch_internal_chdstream_close\n         DEFINES += -Dchdstream_read=retroarch_internal_chdstream_read\n         DEFINES += -Dchdstream_getc=retroarch_internal_chdstream_getc\n         DEFINES += -Dchdstream_gets=retroarch_internal_chdstream_gets\n         DEFINES += -Dchdstream_tell=retroarch_internal_chdstream_tell\n         DEFINES += -Dchdstream_rewind=retroarch_internal_chdstream_rewind\n         DEFINES += -Dchdstream_seek=retroarch_internal_chdstream_seek\n         DEFINES += -Dchdstream_get_size=retroarch_internal_chdstream_get_size\n         DEFINES += -Dchdstream_get_track_start=retroarch_internal_chdstream_get_track_start\n         DEFINES += -Dchdstream_get_frame_size=retroarch_internal_chdstream_get_frame_size\n         DEFINES += -Dchdstream_get_first_track_sector=retroarch_internal_chdstream_get_first_track_sector\n\n         DEFINES += -Dflac_decoder_init=retroarch_internal_flac_decoder_init\n         DEFINES += -Dflac_decoder_free=retroarch_internal_flac_decoder_free\n         DEFINES += -Dflac_decoder_reset=retroarch_internal_flac_decoder_reset\n         DEFINES += -Dflac_decoder_decode_interleaved=retroarch_internal_flac_decoder_decode_interleaved\n         DEFINES += -Dflac_decoder_finish=retroarch_internal_flac_decoder_finish\n         DEFINES += -Dflac_decoder_read_callback_static=retroarch_internal_flac_decoder_read_callback_static\n         DEFINES += -Dflac_decoder_read_callback=retroarch_internal_flac_decoder_read_callback\n         DEFINES += -Dflac_decoder_metadata_callback_static=retroarch_internal_flac_decoder_metadata_callback_static\n         DEFINES += -Dflac_decoder_tell_callback_static=retroarch_internal_flac_decoder_tell_callback_static\n         DEFINES += -Dflac_decoder_write_callback_static=retroarch_internal_flac_decoder_write_callback_static\n         DEFINES += -Dflac_decoder_write_callback=retroarch_internal_flac_decoder_write_callback\n         DEFINES += -Dflac_decoder_error_callback_static=retroarch_internal_flac_decoder_error_callback_static\n         DEFINES += -Dcdfl_codec_init=retroarch_internal_cdfl_codec_init\n         DEFINES += -Dcdfl_codec_free=retroarch_internal_cdfl_codec_free\n         DEFINES += -Dcdfl_codec_decompress=retroarch_internal_cdfl_codec_decompress\n\n         DEFINES += -Dlzma_allocator_init=retroarch_internal_lzma_allocator_init\n         DEFINES += -Dlzma_allocator_free=retroarch_internal_lzma_allocator_free\n         DEFINES += -Dlzma_codec_init=retroarch_internal_lzma_codec_init\n         DEFINES += -Dlzma_codec_free=retroarch_internal_lzma_codec_free\n         DEFINES += -Dlzma_codec_decompress=retroarch_internal_lzma_codec_decompress\n         DEFINES += -Dcdlz_codec_init=retroarch_internal_cdlz_codec_init\n         DEFINES += -Dcdlz_codec_free=retroarch_internal_cdlz_codec_free\n         DEFINES += -Dcdlz_codec_decompress=retroarch_internal_cdlz_codec_decompress\n      endif\n      OBJ     += $(LIBRETRO_COMM_DIR)/formats/libchdr/libchdr_bitstream.o \\\n                 $(LIBRETRO_COMM_DIR)/formats/libchdr/libchdr_cdrom.o \\\n                 $(LIBRETRO_COMM_DIR)/formats/libchdr/libchdr_chd.o \\\n                 $(LIBRETRO_COMM_DIR)/formats/libchdr/libchdr_huffman.o \\\n                 $(LIBRETRO_COMM_DIR)/streams/chd_stream.o \\\n                 $(LIBRETRO_COMM_DIR)/formats/libchdr/libchdr_zlib.o\n\n      ifeq ($(HAVE_FLAC),1)\n         OBJ += $(LIBRETRO_COMM_DIR)/formats/libchdr/libchdr_flac.o \\\n                $(LIBRETRO_COMM_DIR)/formats/libchdr/libchdr_flac_codec.o\n      endif\n\n      ifeq ($(HAVE_7ZIP), 1)\n         OBJ += $(LIBRETRO_COMM_DIR)/formats/libchdr/libchdr_lzma.o\n      endif\n   endif\nendif\n\nifeq ($(HAVE_CDROM), 1)\n   ifeq ($(CDROM_DEBUG), 1)\n      DEFINES += -DCDROM_DEBUG\n   endif\n\n   DEFINES += -DHAVE_CDROM\n   OBJ += $(LIBRETRO_COMM_DIR)/cdrom/cdrom.o \\\n\t\t\t $(LIBRETRO_COMM_DIR)/vfs/vfs_implementation_cdrom.o \\\n\t\t\t $(LIBRETRO_COMM_DIR)/media/media_detect_cd.o \\\n\t\t\t tasks/task_content_disc.o\nendif\n\nifeq ($(HAVE_RTGA), 1)\n   DEFINES += -DHAVE_RTGA\n   OBJ += $(LIBRETRO_COMM_DIR)/formats/tga/rtga.o\nendif\n\nifeq ($(HAVE_RPNG), 1)\n   DEFINES += -DHAVE_RPNG\n   OBJ += $(LIBRETRO_COMM_DIR)/formats/png/rpng.o \\\n          $(LIBRETRO_COMM_DIR)/formats/png/rpng_encode.o\nendif\n\nifeq ($(HAVE_RJPEG), 1)\n   DEFINES += -DHAVE_RJPEG\n   OBJ += $(LIBRETRO_COMM_DIR)/formats/jpeg/rjpeg.o\nendif\n\nifeq ($(HAVE_RBMP), 1)\n   DEFINES += -DHAVE_RBMP\n   OBJ += $(LIBRETRO_COMM_DIR)/formats/bmp/rbmp.o\nendif\n\nOBJ += $(LIBRETRO_COMM_DIR)/formats/bmp/rbmp_encode.o \\\n       $(LIBRETRO_COMM_DIR)/formats/json/rjson.o \\\n       $(LIBRETRO_COMM_DIR)/formats/image_transfer.o \\\n       $(LIBRETRO_COMM_DIR)/formats/m3u/m3u_file.o\n\n# Video4Linux 2\n\nifeq ($(HAVE_V4L2),1)\n   OBJ += camera/drivers/video4linux2.o\n   ifeq ($(HAVE_VIDEOPROCESSOR),1)\n      DEFINES += -DHAVE_VIDEOPROCESSOR\n      OBJ += cores/libretro-video-processor/video_processor_v4l2.o\n   endif\n   DEFINES += -DHAVE_V4L2\n   LIBS += $(V4L2_LIBS)\nendif\n\n# Accessibility\nifeq ($(HAVE_ACCESSIBILITY), 1)\n   DEFINES += -DHAVE_ACCESSIBILITY\n\nifeq ($(HAVE_SAPI), 1)\nifneq ($(findstring Win32,$(OS)),)\n   LIBS += -lsapi\nendif\nendif\n\nendif\n\n\n\n# Things that depend on network availability\n\nifeq ($(HAVE_NETWORKING), 1)\n   DEFINES += -DHAVE_NETWORKING\n   OBJ += $(LIBRETRO_COMM_DIR)/net/net_compat.o \\\n          $(LIBRETRO_COMM_DIR)/net/net_http.o \\\n          $(LIBRETRO_COMM_DIR)/net/net_http_parse.o \\\n          $(LIBRETRO_COMM_DIR)/net/net_socket.o \\\n          core_updater_list.o \\\n          network/natt.o \\\n          tasks/task_http.o \\\n          tasks/task_netplay_lan_scan.o \\\n          tasks/task_netplay_nat_traversal.o \\\n          tasks/task_netplay_find_content.o\n\n   ifeq ($(HAVE_MENU), 1)\n      OBJ += tasks/task_pl_thumbnail_download.o\n   endif\n\n   ifeq ($(HAVE_MENU_COMMON), 1)\n      OBJ += tasks/task_core_updater.o\n   endif\n\n   ifneq ($(findstring Linux,$(OS)),)\n      HAVE_CLOUDSYNC = 1\n   endif\n\n   ifneq ($(findstring Win,$(OS)),)\n      HAVE_CLOUDSYNC = 1\n   endif\n\n   ifeq ($(HAVE_CLOUDSYNC), 1)\n      DEFINES += -DHAVE_CLOUDSYNC\n      OBJ += tasks/task_cloudsync.o \\\n             network/cloud_sync/webdav.o \\\n             network/cloud_sync_driver.o\n   endif\n\n   ifeq ($(HAVE_BUILTINBEARSSL), 1)\n      OBJ += $(LIBRETRO_COMM_DIR)/net/net_socket_ssl_bear.o\n   else ifeq ($(HAVE_SSL), 1)\n      OBJ += $(LIBRETRO_COMM_DIR)/net/net_socket_ssl_mbed.o\n   endif\n\n   ifeq ($(HAVE_IFINFO), 1)\n      DEFINES += -DHAVE_IFINFO\n      OBJ += $(LIBRETRO_COMM_DIR)/net/net_ifinfo.o\n   endif\n\n   ifeq ($(WANT_IFADDRS), 1)\n      DEFINES += -DWANT_IFADDRS\n      OBJ += $(LIBRETRO_COMM_DIR)/compat/compat_ifaddrs.o\n   endif\n\n   ifneq ($(findstring Win32,$(OS)),)\n      LIBS += -lws2_32 -liphlpapi\n   endif\n\n   # Netplay\n   DEFINES += -DHAVE_NETWORK_CMD\n   OBJ += \\\n\t  network/netplay/netplay_frontend.o \\\n\t  network/netplay/netplay_room_parse.o\n\n   # RetroAchievements\n   ifeq ($(HAVE_CHEEVOS), 1)\n      DEFINES += -DHAVE_CHEEVOS -DRC_CLIENT_SUPPORTS_HASH\n      INCLUDE_DIRS += -Ideps/rcheevos/include\n\n      ifneq ($(HAVE_THREADS), 1)\n         DEFINES += -DRC_NO_THREADS\n      else ifneq (,$(filter GEKKO,$(CFLAGS)))\n         # Gekko (Wii) and 3DS use custom pthread wrappers (see rthreads.c)\n         DEFINES += -DRC_NO_THREADS\n      else ifneq (,$(filter _3DS,$(CFLAGS)))\n         DEFINES += -DRC_NO_THREADS\n      endif\n\n      OBJ += cheevos/cheevos.o \\\n             cheevos/cheevos_client.o \\\n             cheevos/cheevos_menu.o \\\n             $(LIBRETRO_COMM_DIR)/formats/cdfs/cdfs.o \\\n             deps/rcheevos/src/rc_client.o \\\n             deps/rcheevos/src/rc_compat.o \\\n             deps/rcheevos/src/rc_libretro.o \\\n             deps/rcheevos/src/rc_util.o \\\n             deps/rcheevos/src/rcheevos/alloc.o \\\n             deps/rcheevos/src/rcheevos/condition.o \\\n             deps/rcheevos/src/rcheevos/condset.o \\\n             deps/rcheevos/src/rcheevos/consoleinfo.o \\\n             deps/rcheevos/src/rcheevos/format.o \\\n             deps/rcheevos/src/rcheevos/lboard.o \\\n             deps/rcheevos/src/rcheevos/memref.o \\\n             deps/rcheevos/src/rcheevos/operand.o \\\n             deps/rcheevos/src/rcheevos/richpresence.o \\\n             deps/rcheevos/src/rcheevos/runtime.o \\\n             deps/rcheevos/src/rcheevos/runtime_progress.o \\\n             deps/rcheevos/src/rcheevos/trigger.o \\\n             deps/rcheevos/src/rcheevos/value.o \\\n             deps/rcheevos/src/rhash/aes.o \\\n             deps/rcheevos/src/rhash/cdreader.o \\\n             deps/rcheevos/src/rhash/hash.o \\\n             deps/rcheevos/src/rapi/rc_api_common.o \\\n             deps/rcheevos/src/rapi/rc_api_info.o \\\n             deps/rcheevos/src/rapi/rc_api_runtime.o \\\n             deps/rcheevos/src/rapi/rc_api_user.o \\\n\n      ifeq ($(HAVE_LUA), 1)\n         DEFINES += -DHAVE_LUA \\\n                    -DLUA_32BITS\n         INCLUDE_DIRS += -Ideps/lua/src\n         OBJ += deps/lua/src/lapi.o \\\n                deps/lua/src/lcode.o \\\n                deps/lua/src/lctype.o \\\n                deps/lua/src/ldebug.o \\\n                deps/lua/src/ldo.o \\\n                deps/lua/src/ldump.o \\\n                deps/lua/src/lfunc.o \\\n                deps/lua/src/lgc.o \\\n                deps/lua/src/llex.o \\\n                deps/lua/src/lmem.o \\\n                deps/lua/src/lobject.o \\\n                deps/lua/src/lopcodes.o \\\n                deps/lua/src/lparser.o \\\n                deps/lua/src/lstate.o \\\n                deps/lua/src/lstring.o \\\n                deps/lua/src/ltable.o \\\n                deps/lua/src/ltm.o \\\n                deps/lua/src/lundump.o \\\n                deps/lua/src/lvm.o \\\n                deps/lua/src/lzio.o \\\n                deps/lua/src/lauxlib.o \\\n                deps/lua/src/lbaselib.o \\\n                deps/lua/src/lbitlib.o \\\n                deps/lua/src/lcorolib.o \\\n                deps/lua/src/ldblib.o \\\n                deps/lua/src/liolib.o \\\n                deps/lua/src/lmathlib.o \\\n                deps/lua/src/loslib.o \\\n                deps/lua/src/lstrlib.o \\\n                deps/lua/src/ltablib.o \\\n                deps/lua/src/lutf8lib.o \\\n                deps/lua/src/loadlib.o \\\n                deps/lua/src/linit.o\n      else\n         DEFINES += -DRC_DISABLE_LUA\n      endif\n\n   endif\n\n   ifeq ($(HAVE_DISCORD), 1)\n      NEED_CXX_LINKER = 1\n      HAVE_PRESENCE = 1\n      DEFINES += -DHAVE_DISCORD\n      INCLUDE_DIRS += -Ideps/discord-rpc/include\n\n      ifneq ($(HAVE_THREADS), 1)\n         DEFINES += -DDISCORD_DISABLE_IO_THREAD\n      endif\n\n      OBJ     += deps/discord-rpc/src/discord_rpc.o \\\n                 deps/discord-rpc/src/rpc_connection.o \\\n                 deps/discord-rpc/src/serialization.o\n\n      OBJ     += network/discord.o\n\n      ifneq ($(findstring Win32,$(OS)),)\n         OBJ  += deps/discord-rpc/src/discord_register_win.o \\\n                 deps/discord-rpc/src/connection_win.o\n         LIBS += -lpsapi -ladvapi32\n      endif\n      ifneq ($(findstring Linux,$(OS)),)\n         OBJ  += deps/discord-rpc/src/discord_register_linux.o \\\n                 deps/discord-rpc/src/connection_unix.o\n      endif\n      ifneq ($(findstring Darwin,$(OS)),)\n         OBJ  += deps/discord-rpc/src/discord_register_osx.o \\\n                 deps/discord-rpc/src/connection_unix.o\n      endif\n   endif\n\n   ifeq ($(HAVE_TRANSLATE), 1)\n      DEFINES += -DHAVE_TRANSLATE\n   endif\n\n   ifeq ($(HAVE_NETWORKGAMEPAD), 1)\n      OBJ += cores/libretro-net-retropad/net_retropad_core.o\n   endif\nendif\n\nifneq ($(findstring FPGA,$(OS)),)\n   OBJ += gfx/drivers/fpga_gfx.o\nendif\n\nifneq ($(findstring Win32,$(OS)),)\n   OBJ += media/rarch.o \\\n          gfx/common/win32_common.o \\\n          frontend/drivers/platform_win32.o \\\n          gfx/display_servers/dispserv_win32.o\n\n   ifeq ($(HAVE_GDI), 1)\n      OBJ += gfx/drivers/gdi_gfx.o\n      LIBS += -lmsimg32\n   endif\n   LIBS += -lhid -lsetupapi\nendif\n\nifeq ($(HAVE_ANGLE), 1)\n\tOBJ += gfx/common/angle_common.o\n\tDEFINES += -DHAVE_ANGLE\nendif\n\n# Record\n\nifeq ($(HAVE_FFMPEG), 1)\n   OBJ += record/drivers/record_ffmpeg.o \\\n          cores/libretro-ffmpeg/ffmpeg_core.o \\\n          cores/libretro-ffmpeg/packet_buffer.o \\\n          cores/libretro-ffmpeg/video_buffer.o \\\n          $(LIBRETRO_COMM_DIR)/rthreads/tpool.o\n\n   LIBS += $(AVCODEC_LIBS) $(AVFORMAT_LIBS) $(AVUTIL_LIBS) $(SWSCALE_LIBS) $(SWRESAMPLE_LIBS) $(FFMPEG_LIBS)\n   DEFINES += -DHAVE_FFMPEG\n   DEF_FLAGS += $(AVCODEC_CFLAGS) $(AVFORMAT_CFLAGS) $(AVUTIL_CFLAGS) $(SWSCALE_CFLAGS) $(SWRESAMPLE_CFLAGS) \\\n                -Wno-deprecated-declarations\n   INCLUDE_DIRS += -Iffmpeg\nendif\n\n# CRT mode switching\nifeq ($(HAVE_CRTSWITCHRES), 1)\n   INCLUDE_DIRS += -I$(DEPS_DIR)/switchres\n   OBJ += gfx/video_crt_switch.o \\\n          $(DEPS_DIR)/switchres/monitor.o \\\n          $(DEPS_DIR)/switchres/modeline.o \\\n          $(DEPS_DIR)/switchres/switchres.o \\\n          $(DEPS_DIR)/switchres/display.o \\\n          $(DEPS_DIR)/switchres/custom_video.o \\\n          $(DEPS_DIR)/switchres/log.o \\\n          $(DEPS_DIR)/switchres/switchres_wrapper.o \\\n          $(DEPS_DIR)/switchres/edid.o\n   ifneq ($(findstring Win32,$(OS)),)\n      OBJ += $(DEPS_DIR)/switchres/display_windows.o \\\n             $(DEPS_DIR)/switchres/custom_video_ati_family.o \\\n             $(DEPS_DIR)/switchres/custom_video_ati.o \\\n             $(DEPS_DIR)/switchres/custom_video_adl.o \\\n             $(DEPS_DIR)/switchres/custom_video_pstrip.o \\\n             $(DEPS_DIR)/switchres/resync_windows.o\n   endif\n   ifneq ($(findstring Linux,$(OS)),)\n      OBJ += $(DEPS_DIR)/switchres/display_linux.o\n      ifeq ($(HAVE_X11)$(HAVE_XRANDR), 11)\n         OBJ += $(DEPS_DIR)/switchres/custom_video_xrandr.o\n         DEFINES += -DSR_WITH_XRANDR\n      endif\n   endif\n   ifneq ($(findstring Win32,$(OS)),)\n      DEFINES += -DSR_WIN32_STATIC\n   endif\n   LIBS += -lstdc++\nendif\n\nifeq ($(HAVE_COMPRESSION), 1)\n   DEFINES += -DHAVE_COMPRESSION\n   OBJ     += tasks/task_decompress.o\nendif\n\nifeq ($(HAVE_COCOA), 1)\n   HAVE_COCOA_COMMON = 1\nendif\nifeq ($(HAVE_COCOA_METAL), 1)\n   HAVE_COCOA_COMMON = 1\nendif\n\nifeq ($(HAVE_COCOA_COMMON),1)\n   DEFINES += -DHAVE_MAIN -DOSX\n   OBJ += input/drivers/cocoa_input.o \\\n          ui/drivers/ui_cocoa.o \\\n          ui/drivers/cocoa/cocoa_common.o\n\n   ifeq ($(HAVE_OPENGL), 1)\n           DEFINES += -DGL_SILENCE_DEPRECATION\n\t   OBJ += gfx/drivers_context/cocoa_gl_ctx.o\n   endif\n   ifeq ($(HAVE_VULKAN), 1)\n\t   OBJ += gfx/drivers_context/cocoa_vk_ctx.o\n   endif\nendif\n\nifneq ($(findstring DOS,$(OS)),)\n   OBJ += gfx/drivers/vga_gfx.o \\\n          input/drivers/dos_input.o \\\n          input/drivers_joypad/dos_joypad.o \\\n          frontend/drivers/platform_dos.o\nendif\n\nifeq ($(HAVE_STATIC_VIDEO_FILTERS), 1)\n   OBJ += gfx/video_filters/2xsai.o \\\n          gfx/video_filters/super2xsai.o \\\n          gfx/video_filters/supereagle.o \\\n          gfx/video_filters/2xbr.o \\\n          gfx/video_filters/darken.o \\\n          gfx/video_filters/epx.o \\\n          gfx/video_filters/scale2x.o \\\n          gfx/video_filters/blargg_ntsc_snes.o \\\n          gfx/video_filters/lq2x.o \\\n          gfx/video_filters/phosphor2x.o \\\n          gfx/video_filters/normal2x.o \\\n          gfx/video_filters/normal2x_width.o \\\n          gfx/video_filters/normal2x_height.o \\\n          gfx/video_filters/normal4x.o \\\n          gfx/video_filters/scanline2x.o \\\n          gfx/video_filters/grid2x.o \\\n          gfx/video_filters/grid3x.o \\\n          gfx/video_filters/gameboy3x.o \\\n          gfx/video_filters/gameboy4x.o \\\n          gfx/video_filters/dot_matrix_3x.o \\\n          gfx/video_filters/dot_matrix_4x.o \\\n          gfx/video_filters/upscale_1_5x.o \\\n          gfx/video_filters/upscale_1_66x_fast.o \\\n          gfx/video_filters/upscale_256x_320x240.o \\\n          gfx/video_filters/picoscale_256x_320x240.o \\\n          gfx/video_filters/upscale_240x160_320x240.o \\\n          gfx/video_filters/upscale_mix_240x160_320x240.o\nendif\n\nifeq ($(WANT_IOSUHAX), 1)\n   DEFINES += -DHAVE_IOSUHAX\n   INCLUDE_DIRS += -I$(DEPS_DIR)/libiosuhax/include\n   OBJ += $(DEPS_DIR)/libiosuhax/source/iosuhax.o \\\n          $(DEPS_DIR)/libiosuhax/source/iosuhax_devoptab.o \\\n          $(DEPS_DIR)/libiosuhax/source/iosuhax_disc_interface.o\nendif\n\nifeq ($(WANT_LIBFAT), 1)\n   DEFINES += -DHAVE_LIBFAT\n   INCLUDE_DIRS += -I$(DEPS_DIR)/libfat/include\n   OBJ += $(DEPS_DIR)/libfat/cache.o \\\n          $(DEPS_DIR)/libfat/directory.o \\\n          $(DEPS_DIR)/libfat/disc.o \\\n          $(DEPS_DIR)/libfat/fatdir.o \\\n          $(DEPS_DIR)/libfat/fatfile.o \\\n          $(DEPS_DIR)/libfat/file_allocation_table.o \\\n          $(DEPS_DIR)/libfat/filetime.o \\\n          $(DEPS_DIR)/libfat/libfat.o \\\n          $(DEPS_DIR)/libfat/lock.o \\\n          $(DEPS_DIR)/libfat/partition.o\nendif\n\nifeq ($(HAVE_STATIC_AUDIO_FILTERS), 1)\n   OBJ += libretro-common/audio/dsp_filters/chorus.o \\\n          libretro-common/audio/dsp_filters/crystalizer.o \\\n          libretro-common/audio/dsp_filters/echo.o \\\n          libretro-common/audio/dsp_filters/eq.o \\\n          libretro-common/audio/dsp_filters/iir.o \\\n          libretro-common/audio/dsp_filters/panning.o \\\n          libretro-common/audio/dsp_filters/phaser.o \\\n          libretro-common/audio/dsp_filters/reverb.o \\\n          libretro-common/audio/dsp_filters/tremolo.o \\\n          libretro-common/audio/dsp_filters/vibrato.o \\\n          libretro-common/audio/dsp_filters/wahwah.o\nendif\n\nifeq ($(HAVE_RPILED), 1)\n   OBJ += led/drivers/led_rpi.o \\\n          led/drivers/led_sys_linux.o\nendif\n\nifneq ($(findstring Win32,$(OS)),)\n   OBJ += led/drivers/led_win32_keyboard.o\nendif\n\nifeq ($(HAVE_X11), 1)\n   OBJ += led/drivers/led_x11_keyboard.o\nendif\n\nifeq ($(HAVE_VITAGLES), 1)\n   DEFINES += -DHAVE_VITAGLES\n   INCLUDE_DIRS += -I$(DEPS_DIR)/Pigs-In-A-Blanket/include\n   SOURCES := $(DEPS_DIR)/Pigs-In-A-Blanket/src\n   OBJ += $(patsubst %.c,%.o,$(foreach dir,$(SOURCES), $(wildcard $(dir)/*.c)))\nendif\n\nifeq ($(HAVE_WEBOS), 1)\n  DEFINES += -DWEBOS\nendif\n\nifeq ($(HAVE_TEST_DRIVERS), 1)\n  DEFINES += -DHAVE_TEST_DRIVERS\n  OBJ += input/drivers_joypad/test_joypad.o\n  OBJ += input/drivers/test_input.o\nendif\n\n\n#####################################\n### Android Play Feature Delivery ###\n### (Play Store build core        ###\n###  downloader)                  ###\n#####################################\nifeq ($(ANDROID), 1)\n   OBJ += play_feature_delivery/play_feature_delivery.o\nendif\n\n### Steam integration using mist\nifeq ($(HAVE_MIST), 1)\n   HAVE_PRESENCE = 1\n   DEFINES += -DHAVE_MIST\n   INCLUDE_DIRS += -I$(MIST_PATH)/include\n   LDFLAGS   += -L$(MIST_PATH) -lmist\n   OBJ += steam/steam.o tasks/task_steam.o\nendif\n\n### Shared rich presence code for Discord and Steam\n\nifeq ($(HAVE_PRESENCE), 1)\n   DEFINES += -DHAVE_PRESENCE\n   OBJ += network/presence.o\nendif\n\n##################################\n### Classic Platform specifics ###\n###############WIP################\n# Help at https://modmyclassic.com\n\nifeq ($(HAVE_CLASSIC), 1)\n  DEFINES += -DHAVE_CLASSIC\nendif\n\nifeq ($(HAVE_C_A7A7), 1)\n   C_A7A7_OPT = -Ofast \\\n                -fno-lto \\\n                -fdata-sections -ffunction-sections -Wl,--gc-sections \\\n                -fno-stack-protector -fno-ident -fomit-frame-pointer \\\n                -falign-functions=1 -falign-jumps=1 -falign-loops=1 \\\n                -fno-unwind-tables -fno-asynchronous-unwind-tables -fno-unroll-loops \\\n                -fmerge-all-constants -fno-math-errno \\\n                -marm -mtune=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard\n   DEF_FLAGS += $(C_A7A7_OPT)\n   CC_VERSION := $(shell $(CC) -dumpversion)\n   ifneq (4.9,$(firstword $(sort $(CC_VERSION) 4.9))) # if version < 4.9\n      DEF_FLAGS += -march=armv7-a\n   else\n      DEF_FLAGS += -march=armv7ve\n      # If gcc is 5.0 or later\n      ifeq (5,$(firstword $(sort $(CC_VERSION) 5)))\n         LDFLAGS += -static-libgcc -static-libstdc++\n      endif\n   endif\nendif\n\nifeq ($(HAVE_HAKCHI), 1)\n   DEFINES += -DHAVE_HAKCHI\nendif\n\nifeq ($(HAVE_SEGAM), 1)\n   DEFINES += -DHAVE_SEGAM\nendif\n\nifeq ($(HAVE_ODROIDGO2), 1)\n  DEFINES += -DHAVE_ODROIDGO2\n  LIBS += -lrga -lpng -lz\n  INCLUDE_DIRS += -I$(DEPS_DIR)/libgo2/include\n  OBJ += $(DEPS_DIR)/libgo2/src/display.o \\\n         $(DEPS_DIR)/libgo2/src/queue.o \\\n         gfx/drivers/oga_gfx.o\nendif\n\n##################################\n"
        },
        {
          "name": "Makefile.ctr",
          "type": "blob",
          "size": 8.7919921875,
          "content": "TARGET := retroarch_3ds\nLIBRETRO =\n\nDEBUG                   = 0\nCONSOLE_LOG             = 0\nGRIFFIN_BUILD           = 1\nHAVE_STATIC_DUMMY ?= 0\nWHOLE_ARCHIVE_LINK      = 0\nBUILD_3DSX              = 1\nBUILD_3DS               = 0\nBUILD_CIA               = 1\nLIBCTRU_NO_DEPRECATION  = 1\nUSE_CTRULIB_2          ?= 0\nLOAD_WITHOUT_CORE_INFO ?= 0\n\nAPP_TITLE            = RetroArch 3DS\nAPP_DESCRIPTION      = RetroArch 3DS\nAPP_AUTHOR           = Team Libretro\nAPP_PRODUCT_CODE     = RETROARCH-3DS\nAPP_UNIQUE_ID        = 0xBAC00\nAPP_ICON             = pkg/ctr/assets/default.png\nAPP_BANNER           = pkg/ctr/assets/libretro_banner.png\nAPP_AUDIO            = pkg/ctr/assets/silent.wav\nAPP_RSF              = pkg/ctr/tools/template.rsf\nAPP_SYSTEM_MODE      = 64MB\nAPP_SYSTEM_MODE_EXT  = 124MB\nAPP_BIG_TEXT_SECTION = 0\nAPP_USE_SVCHAX       = 0\n\ninclude pkg/ctr/Makefile.cores\n\nOBJ :=\nOBJ += gfx/drivers/ctr_shaders/ctr_sprite.o\nOBJ += ctr/ctr_system.o\nOBJ += ctr/ctr_memory.o\nOBJ += ctr/ctr_linear.o\nOBJ += ctr/gpu_old.o\nOBJ += ctr/exec-3dsx/exec_cia.o \\\n\tctr/exec-3dsx/exec_3dsx.o \\\n\tctr/exec-3dsx/mini-hb-menu/launch.o \\\n\tctr/exec-3dsx/mini-hb-menu/loaders/rosalina.o \\\n\tctr/exec-3dsx/mini-hb-menu/loaders/hax2.o\n\nifeq ($(APP_BIG_TEXT_SECTION), 1)\n\tAPP_USE_SVCHAX = 1\n\tLDFLAGS  += -Wl,--defsym,__ctr_patch_services=__service_ptr\nendif\n\nifeq ($(APP_USE_SVCHAX), 1)\n\tOBJ += ctr/ctr_svchax.o\nendif\n\nDEFINES :=\nifeq ($(GRIFFIN_BUILD), 1)\n\tOBJ += griffin/griffin.o\n\tDEFINES += -DHAVE_GRIFFIN=1 -DHAVE_MENU -DHAVE_CONFIGFILE -DHAVE_RGUI -DHAVE_XMB -DHAVE_LIBRETRODB -DHAVE_CC_RESAMPLER\n\tDEFINES += -DHAVE_ZLIB -DHAVE_7ZIP -D_7ZIP_ST -DHAVE_RPNG -DHAVE_RJPEG -DHAVE_RBMP -DHAVE_RTGA\n\tDEFINES += -DHAVE_NETWORKING -DHAVE_IFINFO -DHAVE_CHEEVOS -DRC_DISABLE_LUA -DHAVE_ONLINE_UPDATER -DHAVE_UPDATE_CORES\n\tDEFINES += -DHAVE_UPDATE_CORE_INFO\n\t#DEFINES += -DHAVE_UPDATE_ASSETS\n\tDEFINES += -DHAVE_PATCH -DHAVE_RWAV\n\tDEFINES += -DHAVE_SCREENSHOTS\n\tDEFINES += -DHAVE_REWIND\n\tDEFINES += -DHAVE_THREADS\n\tDEFINES += -DHAVE_GFX_WIDGETS\n\tDEFINES += -DHAVE_OVERLAY\n\tDEFINES += -DHAVE_CORE_INFO_CACHE\n\t#DEFINES += -DHAVE_SOCKET_LEGACY\n\t#-DHAVE_SSL -DHAVE_BUILTINMBEDTLS -DMBEDTLS_SSL_DEBUG_ALL\n\t#ssl is currently incompatible with griffin due to use of the \"static\" flag on repeating functions that will conflict when included in one file\nelse\n\tHAVE_CC_RESAMPLER = 1\n\tHAVE_MENU_COMMON = 1\n\tHAVE_RTGA = 1\n\tHAVE_RPNG = 1\n\tHAVE_RJPEG = 1\n\tHAVE_RBMP = 1\n\tHAVE_MENU = 1\n\tHAVE_RGUI = 1\n\tHAVE_ZLIB = 1\n\tHAVE_7ZIP = 1\n\tHAVE_BUILTINZLIB = 1\n\tHAVE_LIBRETRODB = 1\n\tHAVE_XMB = 1\n\tHAVE_STATIC_VIDEO_FILTERS = 1\n\tHAVE_STATIC_AUDIO_FILTERS = 1\n\tHAVE_PATCH = 1\n\tHAVE_SCREENSHOTS = 1\n\tHAVE_REWIND = 1\n\tHAVE_AUDIOMIXER = 1\n\tHAVE_RWAV = 1\n\t#HAVE_NETWORKING = 1\n\t#HAVE_IFINFO = 1\n\t#HAVE_CHEEVOS = 1\n\t#HAVE_SOCKET_LEGACY = 1\n\tHAVE_THREADS = 1\n\t#HAVE_SSL = 1\n\t#HAVE_BUILTINMBEDTLS = 1\n\tHAVE_CORE_INFO_CACHE = 1\n\n\tinclude Makefile.common\n\tCFLAGS += $(DEF_FLAGS)\n\tBLACKLIST :=\n\tBLACKLIST += input/input_overlay.o\n\tBLACKLIST += tasks/task_overlay.o\n\tOBJ := $(filter-out $(BLACKLIST),$(OBJ))\nendif\n\nifeq ($(strip $(DEVKITPRO)),)\n\t$(error \"Please set DEVKITPRO in your environment. export DEVKITPRO=<path to>devkitpro\")\nendif\nifeq ($(strip $(DEVKITARM)),)\n\t$(error \"Please set DEVKITARM in your environment. export DEVKITARM=<path to>devkitarm\")\nendif\n\nifeq ($(strip $(CTRULIB)),)\n\tCTRULIB = $(DEVKITPRO)/libctru\nendif\n\nifeq ($(strip $(USE_CTRULIB_2)),1)\n\tCFLAGS += -DUSE_CTRULIB_2\nendif\n\nifeq ($(LOAD_WITHOUT_CORE_INFO),1)\n\tCFLAGS += -DLOAD_WITHOUT_CORE_INFO\nendif\n\nifeq ($(strip $(DEVKITTOOLS)),)\n\tifeq ($(strip $(USE_CTRULIB_2)),1)\n\t\tDEVKITTOOLS = $(DEVKITPRO)/tools\n\telse\n\t\tDEVKITTOOLS = $(DEVKITARM)\n\tendif\nendif\n\nAPP_TITLE         := $(shell echo \"$(APP_TITLE)\" | cut -c1-128)\nAPP_DESCRIPTION   := $(shell echo \"$(APP_DESCRIPTION)\" | cut -c1-256)\nAPP_AUTHOR        := $(shell echo \"$(APP_AUTHOR)\" | cut -c1-128)\nAPP_PRODUCT_CODE  := $(shell echo $(APP_PRODUCT_CODE) | cut -c1-16)\nAPP_UNIQUE_ID     := $(shell echo $(APP_UNIQUE_ID) | cut -c1-7)\n\nAPP_VERSION_MAJOR := $(shell shuf -i 0-63 -n 1)\nAPP_VERSION_MINOR := $(shell shuf -i 0-63 -n 1)\nAPP_VERSION_MICRO := $(shell shuf -i 0-15 -n 1)\n\nMAKEROM_ARGS_COMMON = -rsf $(APP_RSF) -exefslogo -elf $(TARGET).elf -icon $(TARGET).icn -banner $(TARGET).bnr \\\n\t-DAPP_TITLE=\"$(APP_TITLE)\" -DAPP_PRODUCT_CODE=\"$(APP_PRODUCT_CODE)\" -DAPP_UNIQUE_ID=$(APP_UNIQUE_ID) \\\n\t-DAPP_SYSTEM_MODE=$(APP_SYSTEM_MODE) -DAPP_SYSTEM_MODE_EXT=$(APP_SYSTEM_MODE_EXT) \\\n\t-major \"$(APP_VERSION_MAJOR)\" -minor \"$(APP_VERSION_MINOR)\" -micro \"$(APP_VERSION_MICRO)\"\n\nINCDIRS := -I$(CTRULIB)/include\nLIBDIRS := -L. -L$(CTRULIB)/lib\n\nARCH     := -march=armv6k -mtune=mpcore -mfloat-abi=hard -marm -mfpu=vfp -mtp=soft\n\nCFLAGS\t+= -mword-relocations \\\n\t   -fomit-frame-pointer -ffast-math \\\n\t   -Werror=implicit-function-declaration \\\n\t   $(ARCH)\n\n#CFLAGS\t+= -Wall\nCFLAGS\t+= -DARM11 -D_3DS\n\nifeq ($(strip $(USE_CTRULIB_2)),1)\n   CFLAGS\t+= -D__3DS__\nendif\n\nifeq ($(DEBUG), 1)\n   CFLAGS\t+= -O0 -g\nelse\n   CFLAGS\t+= -O3\nendif\n\nifeq ($(CONSOLE_LOG), 1)\n   CFLAGS\t+= -DCONSOLE_LOG\nendif\n\nifeq ($(LIBCTRU_NO_DEPRECATION), 1)\n   CFLAGS\t+= -DLIBCTRU_NO_DEPRECATION\nendif\n\nifeq ($(WHOLE_ARCHIVE_LINK), 1)\n   WHOLE_START := -Wl,--whole-archive\n   WHOLE_END := -Wl,--no-whole-archive\nendif\n\nCFLAGS += -I. \\\n\t  -Ideps \\\n\t  -Ideps/7zip \\\n\t  -Ideps/stb \\\n\t  -Ideps/rcheevos/include \\\n\t  -Ilibretro-common/include \\\n\t  -Ilibretro-common/include/compat/zlib\n\nCFLAGS += -DRARCH_INTERNAL -DRARCH_CONSOLE\nCFLAGS += -DHAVE_DSP_FILTER\nCFLAGS += -DHAVE_VIDEO_FILTER\nCFLAGS += -DHAVE_FILTERS_BUILTIN $(DEFINES)\nCFLAGS += -DHAVE_CHEATS\n\nCXXFLAGS := $(CFLAGS) -fno-rtti -fno-exceptions -std=gnu++11\n\nASFLAGS\t := -g $(ARCH) -O3\nLDFLAGS  += -specs=ctr/3dsx_custom.specs -g $(ARCH) -Wl,-Map,$(notdir $*.map)\nCFLAGS   += -std=gnu99 -ffast-math\n\nLIB_CORE      :=\nLIB_CORE_FULL :=\n\nifeq ($(HAVE_STATIC_DUMMY),1)\n  DEFINES += -DHAVE_STATIC_DUMMY\nelse\n  LIB_CORE      += -lretro_ctr\n  LIB_CORE_FULL += libretro_ctr.a\nendif\n\nLIBS\t:= $(WHOLE_START) $(LIB_CORE) $(WHOLE_END) -lm\n\nifeq ($(DEBUG), 1)\n\tLIBS\t+= -lctrud\nelse\n\tLIBS\t+= -lctru\nendif\n\nifeq ($(BUILD_3DSX), 1)\n\tTARGET_3DSX := $(TARGET).3dsx $(TARGET).smdh\nendif\n\nifeq ($(BUILD_3DS), 1)\n\tTARGET_3DS := $(TARGET).3ds\nendif\n\nifeq ($(BUILD_CIA), 1)\n\tTARGET_CIA := $(TARGET).cia\nendif\n\n.PHONY: $(BUILD) clean all\n\nall: $(TARGET)\n\n$(TARGET): $(TARGET_3DSX) $(TARGET_3DS) $(TARGET_CIA)\n$(TARGET).3dsx: $(TARGET).elf\n$(TARGET).elf: $(OBJ) $(LIB_CORE_FULL)\n\nPREFIX\t\t:=\t$(DEVKITARM)/bin/arm-none-eabi-\n\nCC      := $(PREFIX)gcc\nCXX     := $(PREFIX)g++\nAS      := $(PREFIX)as\nAR      := $(PREFIX)ar\nOBJCOPY := $(PREFIX)objcopy\nSTRIP   := $(PREFIX)strip\nNM      := $(PREFIX)nm\nLD      := $(CXX)\n\nifeq ($(strip $(CTRBANNERTOOL)),)\n\tifneq ($(findstring Linux,$(shell uname)),)\n\t\tBANNERTOOL = pkg/ctr/tools/bannertool-linux\n\telse ifneq ($(findstring Darwin,$(shell uname)),)\n\t\tBANNERTOOL = pkg/ctr/tools/bannertool-mac\n\telse\n\t\tBANNERTOOL = pkg/ctr/tools/bannertool.exe\n\tendif\nelse\n\tBANNERTOOL = $(CTRBANNERTOOL)\nendif\n\nifeq ($(strip $(CTRMAKEROM)),)\n\tifneq ($(findstring Linux,$(shell uname)),)\n\t\tMAKEROM    = pkg/ctr/tools/makerom-linux\n\telse ifneq ($(findstring Darwin,$(shell uname)),)\n\t\tMAKEROM    = pkg/ctr/tools/makerom-mac\n\telse\n\t\tMAKEROM    = pkg/ctr/tools/makerom.exe\n\tendif\nelse\n\tMAKEROM = $(CTRMAKEROM)\nendif\n\n%.o: %.vsh %.gsh\n\t$(DEVKITTOOLS)/bin/picasso $^ -o $*.shbin\n\t$(DEVKITTOOLS)/bin/bin2s $*.shbin | $(PREFIX)as -o $@\n\trm $*.shbin\n\n%.o: %.vsh\n\t$(DEVKITTOOLS)/bin/picasso $^ -o $*.shbin\n\t$(DEVKITTOOLS)/bin/bin2s $*.shbin | $(PREFIX)as -o $@\n\trm $*.shbin\n\n%.o: %.cpp\n\t$(CXX) -c -o $@ $< $(CXXFLAGS) $(INCDIRS)\n\n%.o: %.c\n\t$(CC) -c -o $@ $< $(CFLAGS) $(INCDIRS)\n\n%.o: %.s\n\t$(CC) -c -o $@ $< $(ASFLAGS)\n\n%.o: %.S\n\t$(CC) -c -o $@ $< $(ASFLAGS)\n\n%.a:\n\t$(AR) -rc $@ $^\n\n%.vsh:\n\n$(TARGET).smdh: $(TARGET).elf $(APP_ICON)\n\t$(DEVKITTOOLS)/bin/smdhtool --create \"$(APP_TITLE)\" \"$(APP_DESCRIPTION)\" \"$(APP_AUTHOR)\" $(APP_ICON) $@\n\n$(TARGET).3dsx: $(TARGET).elf\nifeq ($(APP_BIG_TEXT_SECTION), 1)\n\tcp pkg/ctr/big_text_section.xml $(TARGET).xml\nelse\n\trm -f $(TARGET).xml\nendif\n\t$(DEVKITTOOLS)/bin/3dsxtool $< $@ $(_3DSXFLAGS)\n\n$(TARGET).elf: ctr/3dsx_custom_crt0.o\n\t$(LD) $(LDFLAGS) $(OBJ) $(LIBDIRS) $(LIBS) -o $@\n\t$(NM) -CSn $@ > $(notdir $*.lst)\n\n$(TARGET).bnr: $(TARGET).elf $(APP_BANNER) $(APP_AUDIO)\n\t$(BANNERTOOL) makebanner -i \"$(APP_BANNER)\" -a \"$(APP_AUDIO)\" -o $@\n\n$(TARGET).icn: $(TARGET).elf $(APP_ICON)\n\t$(BANNERTOOL) makesmdh -s \"$(APP_TITLE)\" -l \"$(APP_TITLE)\" -p \"$(APP_AUTHOR)\" -i $(APP_ICON) -o $@\n\n$(TARGET).3ds: $(TARGET).elf $(TARGET).bnr $(TARGET).icn $(APP_RSF)\n\t$(MAKEROM) -f cci -o $@ $(MAKEROM_ARGS_COMMON) -DAPP_ENCRYPTED=true\n\n$(TARGET).cia: $(TARGET).elf $(TARGET).bnr $(TARGET).icn $(APP_RSF)\n\t$(MAKEROM) -f cia -o $@ $(MAKEROM_ARGS_COMMON) -DAPP_ENCRYPTED=false\n\nclean:\n\trm -f $(OBJ)\n\trm -f $(TARGET).3dsx\n\trm -f $(TARGET).elf\n\trm -f $(TARGET).3ds\n\trm -f $(TARGET).cia\n\trm -f $(TARGET).smdh\n\trm -f $(TARGET).bnr\n\trm -f $(TARGET).icn\n\trm -f ctr/ctr_config_*.o\n\trm -f ctr/3dsx_custom_crt0.o\n\n.PHONY: clean\n"
        },
        {
          "name": "Makefile.ctr.salamander",
          "type": "blob",
          "size": 6.3798828125,
          "content": "TARGET := retroarch_3ds_salamander\nLIBRETRO =\n\nDEBUG                   = 0\nCONSOLE_LOG             = 0\nBUILD_3DSX              = 1\nBUILD_3DS               = 0\nBUILD_CIA               = 1\nUSE_CTRULIB_2          ?= 0\n\nAPP_TITLE            = RetroArch 3DS\nAPP_DESCRIPTION      = RetroArch 3DS\nAPP_AUTHOR           = Team Libretro\nAPP_PRODUCT_CODE     = RETROARCH-3DS\nAPP_UNIQUE_ID        = 0xBAC00\nAPP_ICON             = pkg/ctr/assets/default.png\nAPP_BANNER           = pkg/ctr/assets/libretro_banner.png\nAPP_AUDIO            = pkg/ctr/assets/silent.wav\nAPP_RSF              = pkg/ctr/tools/template.rsf\nAPP_SYSTEM_MODE      = 64MB\nAPP_SYSTEM_MODE_EXT  = 124MB\n\nOBJ := ctr/ctr_system.o \\\n\t\t ctr/ctr_memory.o \\\n\t\t ctr/ctr_linear.o \\\n\t\t frontend/frontend_salamander.o \\\n\t\t frontend/frontend_driver.o \\\n\t\t frontend/drivers/platform_ctr.o \\\n\t\t libretro-common/encodings/encoding_utf.o \\\n\t\t libretro-common/compat/compat_strcasestr.o \\\n\t\t libretro-common/compat/fopen_utf8.o \\\n\t\t libretro-common/file/file_path.o \\\n\t\t libretro-common/file/file_path_io.o \\\n\t\t libretro-common/string/stdstring.o \\\n\t\t libretro-common/lists/string_list.o \\\n\t\t libretro-common/lists/dir_list.o \\\n\t\t libretro-common/file/retro_dirent.o \\\n\t\t libretro-common/compat/compat_strl.o \\\n\t\t libretro-common/compat/compat_strldup.o \\\n\t\t libretro-common/file/config_file.o \\\n\t\t libretro-common/streams/file_stream.o \\\n\t\t libretro-common/vfs/vfs_implementation.o \\\n\t\t libretro-common/hash/lrc_hash.o \\\n\t\t libretro-common/time/rtime.o \\\n\t\t verbosity.o\n\nOBJ += ctr/exec-3dsx/exec_cia.o \\\n\tctr/exec-3dsx/exec_3dsx.o \\\n\tctr/exec-3dsx/mini-hb-menu/launch.o \\\n\tctr/exec-3dsx/mini-hb-menu/loaders/rosalina.o \\\n\tctr/exec-3dsx/mini-hb-menu/loaders/hax2.o\n\nifeq ($(strip $(DEVKITPRO)),)\n\t$(error \"Please set DEVKITPRO in your environment. export DEVKITPRO=<path to>devkitpro\")\nendif\n\nifeq ($(strip $(USE_CTRULIB_2)),1)\n\tCFLAGS += -DUSE_CTRULIB_2\nendif\n\nifeq ($(strip $(DEVKITTOOLS)),)\n\tifeq ($(strip $(USE_CTRULIB_2)),1)\n\t\tDEVKITTOOLS = $(DEVKITPRO)/tools\n\telse\n\t\tDEVKITTOOLS = $(DEVKITARM)\n\tendif\nendif\n\nifeq ($(strip $(CTRULIB)),)\n\tCTRULIB = $(DEVKITPRO)/libctru\nendif\n\nAPP_TITLE         := $(shell echo \"$(APP_TITLE)\" | cut -c1-128)\nAPP_DESCRIPTION   := $(shell echo \"$(APP_DESCRIPTION)\" | cut -c1-256)\nAPP_AUTHOR        := $(shell echo \"$(APP_AUTHOR)\" | cut -c1-128)\nAPP_PRODUCT_CODE  := $(shell echo $(APP_PRODUCT_CODE) | cut -c1-16)\nAPP_UNIQUE_ID     := $(shell echo $(APP_UNIQUE_ID) | cut -c1-7)\n\nMAKEROM_ARGS_COMMON = -rsf $(APP_RSF) -exefslogo -elf $(TARGET).elf -icon $(TARGET).icn -banner $(TARGET).bnr -DAPP_TITLE=\"$(APP_TITLE)\" -DAPP_PRODUCT_CODE=\"$(APP_PRODUCT_CODE)\" -DAPP_UNIQUE_ID=$(APP_UNIQUE_ID) -DAPP_SYSTEM_MODE=$(APP_SYSTEM_MODE) -DAPP_SYSTEM_MODE_EXT=$(APP_SYSTEM_MODE_EXT)\n\nINCDIRS := -I$(CTRULIB)/include\nLIBDIRS := -L. -L$(CTRULIB)/lib\n\nARCH     := -march=armv6k -mtune=mpcore -mfloat-abi=hard -marm -mfpu=vfp -mtp=soft\n\nCFLAGS\t+=\t-mword-relocations \\\n\t\t\t-fomit-frame-pointer -ffast-math \\\n         -Werror=implicit-function-declaration \\\n\t\t\t$(ARCH)\n\n#CFLAGS\t+= -Wall\nCFLAGS\t+=\t-DARM11 -D_3DS\n\nifeq ($(strip $(USE_CTRULIB_2)),1)\n   CFLAGS\t+= -D__3DS__\nendif\n\nifeq ($(DEBUG), 1)\n   CFLAGS\t+= -O0 -g\nelse\n   CFLAGS\t+= -O3\nendif\n\nifeq ($(CONSOLE_LOG), 1)\n   CFLAGS\t+= -DCONSOLE_LOG\nendif\n\nCFLAGS += -I. -Ideps/7zip -Ideps/stb -Ilibretro-common/include -Ilibretro-common/include/compat/zlib\n\n#CFLAGS += -DRARCH_INTERNAL\nCFLAGS += -DRARCH_CONSOLE -DIS_SALAMANDER\n\nCXXFLAGS\t:= $(CFLAGS) -fno-rtti -fno-exceptions -std=gnu++11\n\nASFLAGS\t:=\t-g $(ARCH) -O3\nLDFLAGS  +=\t-specs=ctr/3dsx_custom.specs -g $(ARCH) -Wl,-Map,$(notdir $*.map)\n\nCFLAGS   += -std=gnu99 -ffast-math\n\nLIBS\t:= -lctru -lm\n\nifeq ($(BUILD_3DSX), 1)\nTARGET_3DSX := $(TARGET).3dsx $(TARGET).smdh\nendif\n\nifeq ($(BUILD_3DS), 1)\nTARGET_3DS := $(TARGET).3ds\nendif\n\nifeq ($(BUILD_CIA), 1)\nTARGET_CIA := $(TARGET).cia\nendif\n\n.PHONY: $(BUILD) clean all\n\nall: $(TARGET)\n\n$(TARGET): $(TARGET_3DSX) $(TARGET_3DS) $(TARGET_CIA)\n$(TARGET).3dsx: $(TARGET).elf\n$(TARGET).elf: $(OBJ)\n\nPREFIX\t\t:=\t$(DEVKITARM)/bin/arm-none-eabi-\n\nCC      := $(PREFIX)gcc\nCXX     := $(PREFIX)g++\nAS      := $(PREFIX)as\nAR      := $(PREFIX)ar\nOBJCOPY := $(PREFIX)objcopy\nSTRIP   := $(PREFIX)strip\nNM      := $(PREFIX)nm\nLD      := $(CXX)\n\nifeq ($(strip $(CTRBANNERTOOL)),)\n\tifneq ($(findstring Linux,$(shell uname)),)\n\t\tBANNERTOOL = pkg/ctr/tools/bannertool-linux\n\telse ifneq ($(findstring Darwin,$(shell uname)),)\n\t\tBANNERTOOL = pkg/ctr/tools/bannertool-mac\n\telse\n\t\tBANNERTOOL = pkg/ctr/tools/bannertool.exe\n\tendif\nelse\n\tBANNERTOOL = $(CTRBANNERTOOL)\nendif\n\nifeq ($(strip $(CTRMAKEROM)),)\n\tifneq ($(findstring Linux,$(shell uname)),)\n\t\tMAKEROM    = pkg/ctr/tools/makerom-linux\n\telse ifneq ($(findstring Darwin,$(shell uname)),)\n\t\tMAKEROM    = pkg/ctr/tools/makerom-mac\n\telse\n\t\tMAKEROM    = pkg/ctr/tools/makerom.exe\n\tendif\nelse\n\tMAKEROM = $(CTRMAKEROM)\nendif\n\n%.o: %.vsh %.gsh\n\t$(DEVKITTOOLS)/bin/picasso $^ -o $*.shbin\n\t$(DEVKITTOOLS)/bin/bin2s $*.shbin | $(PREFIX)as -o $@\n\trm $*.shbin\n\n%.o: %.vsh\n\t$(DEVKITTOOLS)/bin/picasso $^ -o $*.shbin\n\t$(DEVKITTOOLS)/bin/bin2s $*.shbin | $(PREFIX)as -o $@\n\trm $*.shbin\n\n%.o: %.cpp\n\t$(CXX) -c -o $@ $< $(CXXFLAGS) $(INCDIRS)\n\n%.o: %.c\n\t$(CC) -c -o $@ $< $(CFLAGS) $(INCDIRS)\n\n%.o: %.s\n\t$(CC) -c -o $@ $< $(ASFLAGS)\n\n%.o: %.S\n\t$(CC) -c -o $@ $< $(ASFLAGS)\n\n%.a:\n\t$(AR) -rc $@ $^\n\n%.vsh:\n\n$(TARGET).smdh: $(APP_ICON)\n\t$(DEVKITTOOLS)/bin/smdhtool --create \"$(APP_TITLE)\" \"$(APP_DESCRIPTION)\" \"$(APP_AUTHOR)\" $(APP_ICON) $@\n\n$(TARGET).3dsx: $(TARGET).elf\nifeq ($(APP_BIG_TEXT_SECTION), 1)\n\tcp pkg/ctr/big_text_section.xml $(TARGET).xml\nelse\n\trm -f $(TARGET).xml\nendif\n\t$(DEVKITTOOLS)/bin/3dsxtool $< $@ $(_3DSXFLAGS)\n\n$(TARGET).elf: ctr/3dsx_custom_crt0.o\n\t$(LD) $(LDFLAGS) $(OBJ) $(LIBDIRS) $(LIBS) -o $@\n\t$(NM) -CSn $@ > $(notdir $*.lst)\n\n$(TARGET).bnr: $(APP_BANNER) $(APP_AUDIO)\n\t$(BANNERTOOL) makebanner -i \"$(APP_BANNER)\" -a \"$(APP_AUDIO)\" -o $@\n\n$(TARGET).icn: $(APP_ICON)\n\t$(BANNERTOOL) makesmdh -s \"$(APP_TITLE)\" -l \"$(APP_TITLE)\" -p \"$(APP_AUTHOR)\" -i $(APP_ICON) -o $@\n\n$(TARGET).3ds: $(TARGET).elf $(TARGET).bnr $(TARGET).icn $(APP_RSF)\n\t$(MAKEROM) -f cci -o $@ $(MAKEROM_ARGS_COMMON) -DAPP_ENCRYPTED=true\n\n$(TARGET).cia: $(TARGET).elf $(TARGET).bnr $(TARGET).icn $(APP_RSF)\n\t$(MAKEROM) -f cia -o $@ $(MAKEROM_ARGS_COMMON) -DAPP_ENCRYPTED=false\n\nclean:\n\trm -f $(OBJ)\n\trm -f $(TARGET).3dsx\n\trm -f $(TARGET).elf\n\trm -f $(TARGET).3ds\n\trm -f $(TARGET).cia\n\trm -f $(TARGET).smdh\n\trm -f $(TARGET).bnr\n\trm -f $(TARGET).icn\n\trm -f ctr/ctr_config_*.o\n\trm -f ctr/3dsx_custom_crt0.o\n\n.PHONY: clean\n"
        },
        {
          "name": "Makefile.dingux",
          "type": "blob",
          "size": 5.2568359375,
          "content": "#########################\n## Toolchain variables ##\n#########################\n\n# Default toolchain directory\nTOOLCHAIN_DIR=/opt/gcw0-toolchain\n\n# All toolchain-related variables may be\n# overridden via the command line\nifdef GCW0_CC\nCC                    = $(GCW0_CC)\nelse\nCC                    = $(TOOLCHAIN_DIR)/usr/bin/mipsel-gcw0-linux-uclibc-gcc\nendif\n\nifdef GCW0_CXX\nCXX                   = $(GCW0_CXX)\nelse\nCXX                   = $(TOOLCHAIN_DIR)/usr/bin/mipsel-gcw0-linux-uclibc-g++\nendif\n\nGCW0_SDL_CONFIG      ?= $(TOOLCHAIN_DIR)/usr/mipsel-gcw0-linux-uclibc/sysroot/usr/bin/sdl-config\nGCW0_FREETYPE_CONFIG ?= $(TOOLCHAIN_DIR)/usr/mipsel-gcw0-linux-uclibc/sysroot/usr/bin/freetype-config\nGCW0_MK_SQUASH_FS    ?= $(TOOLCHAIN_DIR)/usr/bin/mksquashfs\n\nGCW0_INC_DIR         ?= $(TOOLCHAIN_DIR)/usr/mipsel-gcw0-linux-uclibc/sysroot/usr/include\nGCW0_LIB_DIR         ?= $(TOOLCHAIN_DIR)/usr/mipsel-gcw0-linux-uclibc/sysroot/usr/lib\n\n#########################\n#########################\n\nPACKAGE_NAME = retroarch\n\nDEBUG ?= 0\n\nDINGUX = 1\nHAVE_SCREENSHOTS = 1\nHAVE_REWIND = 1\nHAVE_7ZIP = 1\nHAVE_AL = 1\n# this freezes when switching back from menu\nHAVE_ALSA = 0\nHAVE_DSP_FILTER = 1\nHAVE_VIDEO_FILTER = 1\nHAVE_BUILTINMBEDTLS = 1\nHAVE_BUILTINZLIB = 1\nHAVE_C99 = 1\nHAVE_CC = 1\nHAVE_CC_RESAMPLER = 1\nHAVE_CHD = 1\nHAVE_CHEEVOS = 1\nHAVE_COMMAND = 0\nHAVE_CXX = 1\nHAVE_DR_MP3 = 1\nHAVE_DYNAMIC = 1\nHAVE_EGL = 1\nHAVE_FREETYPE = 1\nHAVE_GDI = 1\nHAVE_GETADDRINFO = 1\nHAVE_GETOPT_LONG = 1\nHAVE_GLSL = 1\nHAVE_HID = 1\nHAVE_IBXM = 1\nHAVE_IMAGEVIEWER = 1\nHAVE_LANGEXTRA = 1\nHAVE_LIBRETRODB = 1\nHAVE_MENU = 1\nHAVE_MENU_COMMON = 1\nHAVE_GFX_WIDGETS = 1\nHAVE_MMAP = 1\nHAVE_NETWORKING = 1\nHAVE_IFINFO = 1\nHAVE_OPENDINGUX_FBDEV = 1\nHAVE_OPENGL = 1\nHAVE_OPENGL1 = 0\nHAVE_OPENGLES = 1\nHAVE_OPENGLES3 = 0\nHAVE_OPENGL_CORE = 0\nHAVE_OPENSSL = 1\nHAVE_OVERLAY = 1\nHAVE_RBMP = 1\nHAVE_RJPEG = 1\nHAVE_RPILED = 1\nHAVE_RPNG = 1\nHAVE_RUNAHEAD = 1\nHAVE_SDL_DINGUX = 1\nHAVE_SHADERPIPELINE = 1\nHAVE_STB_FONT = 1\nHAVE_STB_IMAGE = 1\nHAVE_STB_VORBIS = 1\nHAVE_STDIN_CMD = 0\nHAVE_STRCASESTR = 1\nHAVE_THREADS = 1\nHAVE_TRANSLATE = 1\nHAVE_UDEV = 1\nHAVE_XMB = 1\nHAVE_ZLIB = 1\nHAVE_CONFIGFILE = 1\nHAVE_PATCH = 1\nHAVE_CHEATS = 1\nHAVE_LIBSHAKE = 1\nHAVE_CORE_INFO_CACHE = 1\n\nOS = Linux\nTARGET = retroarch\nOPK_NAME = retroarch.opk\n\nOBJ :=\nLINK := $(CXX)\nDEF_FLAGS := -march=mips32 -mtune=mips32r2 -mhard-float -ffast-math -fomit-frame-pointer\nDEF_FLAGS += -mplt -mno-shared\nDEF_FLAGS += -ffunction-sections -fdata-sections\nDEF_FLAGS += -I. -Ideps -Ideps/stb -DDINGUX=1 -MMD\nDEF_FLAGS += -Wall -Wno-unused-variable\nDEF_FLAGS += -std=gnu99 -D_GNU_SOURCE\nLIBS := -ldl -lz -lrt -lcrypto -lssl -ludev -pthread\nCFLAGS :=\nCXXFLAGS := -fno-exceptions -fno-rtti -std=c++11 -D__STDC_CONSTANT_MACROS\nASFLAGS :=\nLDFLAGS := -flto -Wl,--gc-sections\nINCLUDE_DIRS = -I$(GCW0_INC_DIR)\nLIBRARY_DIRS = -L$(GCW0_LIB_DIR)\nDEFINES := -DRARCH_INTERNAL -D_FILE_OFFSET_BITS=64 -UHAVE_STATIC_DUMMY\nDEFINES += -DHAVE_C99=1 -DHAVE_CXX=1 -DHAVE_OPENDINGUX_FBDEV=1\nDEFINES += -DHAVE_GETOPT_LONG=1 -DHAVE_STRCASESTR=1 -DHAVE_DYNAMIC=1\nDEFINES += -DHAVE_AL=1\nDEFINES += -DHAVE_ONLINE_UPDATER=1\nDEFINES += -DHAVE_UPDATE_ASSETS=1\nDEFINES += -DHAVE_UDEV=1\n\nSDL_DINGUX_CFLAGS := $(shell $(GCW0_SDL_CONFIG) --cflags)\nSDL_DINGUX_LIBS := $(shell $(GCW0_SDL_CONFIG) --libs)\nFREETYPE_CFLAGS := $(shell $(GCW0_FREETYPE_CONFIG) --cflags)\nFREETYPE_LIBS := $(shell $(GCW0_FREETYPE_CONFIG) --libs)\nAL_LIBS := -lopenal\nOPENGLES_CFLAGS := -DMESA_EGL_NO_X11_HEADERS\nOPENGLES_LIBS := -lGLESv2 -lEGL\nMMAP_LIBS = -lc\n\nOBJDIR_BASE := obj-unix\n\nifeq ($(DEBUG), 1)\n   OBJDIR := $(OBJDIR_BASE)/debug\n   DEF_FLAGS += -O0 -g -DDEBUG -D_DEBUG\nelse\n   OBJDIR := $(OBJDIR_BASE)/release\n   DEF_FLAGS += -O2 -DNDEBUG\nendif\n\ninclude Makefile.common\n\nDEF_FLAGS += $(INCLUDE_DIRS)\nCFLAGS += $(DEF_FLAGS)\nCXXFLAGS += $(DEF_FLAGS)\n\nHEADERS = $(wildcard */*/*.h) $(wildcard */*.h) $(wildcard *.h)\n\nQ := @\n\nRARCH_OBJ := $(addprefix $(OBJDIR)/,$(OBJ))\n\ndefine DESKTOP_ENTRY\n[Desktop Entry]\nName=RetroArch\nComment=Frontend for emulators, game engines\nExec=retroarch\nTerminal=false\nType=Application\nStartupNotify=true\nIcon=retroarch\nCategories=emulators;\nX-OD-NeedsDownscaling=true\nendef\nexport DESKTOP_ENTRY\n\nall: $(TARGET) opk\n\n-include $(RARCH_OBJ:.o=.d)\n\nSYMBOL_MAP := -Wl,-Map=output.map\n\n$(TARGET): $(RARCH_OBJ)\n\t@$(if $(Q), $(shell echo echo LD $@),)\n\t$(Q)$(LINK) -o $@ $(RARCH_OBJ) $(LIBS) $(LDFLAGS) $(LIBRARY_DIRS)\n\n$(OBJDIR)/%.o: %.c\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CC $<),)\n\t$(Q)$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) -c -o $@ $<\n\n$(OBJDIR)/%.o: %.cpp\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CXX $<),)\n\t$(Q)$(CXX) $(CPPFLAGS) $(CXXFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.m\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo OBJC $<),)\n\t$(Q)$(CXX) $(OBJCFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.S $(HEADERS)\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo AS $<),)\n\t$(Q)$(CC) $(CFLAGS) $(ASFLAGS) $(DEFINES) -c -o $@ $<\n\nclean:\n\trm -rf $(OBJDIR_BASE)\n\trm -f $(TARGET)\n\trm -f *.d\n\trm -rf $(OPK_NAME)\n\nopk: $(TARGET)\n\techo \"$$DESKTOP_ENTRY\" > default.gcw0.desktop\n\trm -f $(OPK_NAME)\n\tcp media/ico_src/icon32.png retroarch.png\n\t$(GCW0_MK_SQUASH_FS) retroarch default.gcw0.desktop retroarch.png $(OPK_NAME) -all-root -no-xattrs -noappend -no-exports\n\trm -f default.gcw0.desktop retroarch.png\n\n.PHONY: all clean opk\n\nprint-%:\n\t@echo '$*=$($*)'\n"
        },
        {
          "name": "Makefile.dos",
          "type": "blob",
          "size": 6.5751953125,
          "content": "include version.all\n\n#---------------------------------------------------------------------------------\n.SUFFIXES:\n#---------------------------------------------------------------------------------\n\nTOPDIR ?= $(CURDIR)\n\n\nDEBUG                  ?= 0\nWHOLE_ARCHIVE_LINK      = 0\nHAVE_STATIC_DUMMY ?= 0\nGRIFFIN_BUILD           = 0\n\nOBJ :=\n\nDEFINES := -DHAVE_DJGPP=1 -U__linux__ -U__linux -DRARCH_INTERNAL -DHAVE_STB_VORBIS\nCC := i586-pc-msdosdjgpp-gcc\nCXX := i586-pc-msdosdjgpp-g++\nTARGET := retrodos.exe\n\nRARCH_CONSOLE = 0\nHAVE_SHADERPIPELINE = 1\nHAVE_SPIRV_CROSS = 0\nHAVE_PATCH = 1\nHAVE_LUA = 0\nHAVE_CONFIGFILE = 1\nHAVE_GFX_WIDGETS = 1\nHAVE_LANGEXTRA = 1\nHAVE_DR_MP3 = 1\nHAVE_TRANSLATE = 0\nHAVE_SCREENSHOTS = 1\nHAVE_REWIND = 1\nHAVE_AUDIOMIXER = 1\nHAVE_CC_RESAMPLER = 1\nHAVE_MENU_COMMON = 1\nHAVE_RTGA = 1\nHAVE_RPNG = 1\nHAVE_RJPEG = 1\nHAVE_RBMP = 1\nHAVE_7ZIP = 1\nHAVE_ZLIB = 1\nHAVE_IMAGEVIEWER = 1\nHAVE_BUILTINZLIB = 1\nHAVE_LIBRETRODB = 1\nHAVE_DSP_FILTER = 1\nHAVE_VIDEO_FILTER = 1\nHAVE_STATIC_VIDEO_FILTERS = 1\nHAVE_STATIC_AUDIO_FILTERS = 1\nHAVE_STATIC_CORES = 1\nHAVE_FILTERS_BUILTIN = 1\nHAVE_MENU = 1\nHAVE_CONFIGFILE = 1\nHAVE_PATCH = 1\nHAVE_CHEATS = 1\nHAVE_RUNAHEAD = 1\nHAVE_NETWORKING = 0\nHAVE_IFINFO = 0\nHAVE_NETPLAYDISCOVERY = 0\nHAVE_OVERLAY             := 1\nHAVE_STB_FONT = 1\nHAVE_COMMAND             := 1\nHAVE_STDIN_CMD           := 1\nHAVE_CMD                 := 1\nHAVE_CHEEVOS = 0\nHAVE_CHD = 1\nHAVE_STB_VORBIS = 1\nHAVE_IBXM = 1\nHAVE_CORE_INFO_CACHE = 1\nHAVE_XDELTA = 0 # disabled because <lzma.h> isn't available (or we haven't figured out how to install it)\n\nHAVE_RGUI = 1\nHAVE_MATERIALUI = 0\nHAVE_XMB = 0\nHAVE_OZONE = 0\n\n\nOBJ := \\\n    frontend/drivers/platform_dos.o \\\n    gfx/drivers/vga_gfx.o \\\n    input/drivers/dos_input.o \\\n    input/drivers_joypad/dos_joypad.o\n\ninclude Makefile.common\n\n#---------------------------------------------------------------------------------\n# TARGET is the name of the output\n# BUILD is the directory where object files & intermediate files will be placed\n# SOURCES is a list of directories containing source code\n# DATA is a list of directories containing data files\n# INCLUDES is a list of directories containing header files\n# EXEFS_SRC is the optional input directory containing data copied into exefs, if anything this normally should only contain \"main.npdm\".\n# ROMFS is the directory containing data to be added to RomFS, relative to the Makefile (Optional)\n#\n# NO_ICON: if set to anything, do not use icon.\n# NO_NACP: if set to anything, no .nacp file is generated.\n# APP_TITLE is the name of the app stored in the .nacp file (Optional)\n# APP_AUTHOR is the author of the app stored in the .nacp file (Optional)\n# APP_VERSION is the version of the app stored in the .nacp file (Optional)\n# APP_TITLEID is the titleID of the app stored in the .nacp file (Optional)\n# ICON is the filename of the icon (.jpg), relative to the project folder.\n#   If not set, it attempts to use one of the following (in this order):\n#     - <Project name>.jpg\n#     - icon.jpg\n#     - <libnx folder>/default_icon.jpg\n#---------------------------------------------------------------------------------\nBUILD := build\nSOURCES := $(CURDIR)/source\nDATA := data\nINCLUDES :=\tinclude\nEXEFS_SRC := exefs_src\n\nAPP_TITLE := RetroArch\nAPP_VERSION := $(RARCH_VERSION)\nAPP_AUTHOR := libretro Team\nAPP_ICON := pkg/libnx/retroarch.jpg\n\n#---------------------------------------------------------------------------------\n# options for code generation\n#---------------------------------------------------------------------------------\nARCH\t:=\n\nCFLAGS := -g -Wall -O3 -fcommon -ffast-math -ffunction-sections \\\n          $(ARCH) $(DEFINES) $(INCLUDE_DIRS)\n\nCFLAGS += $(INCLUDE)\n\nifeq ($(HAVE_FILTERS_BUILTIN), 1)\n  CFLAGS += -DHAVE_FILTERS_BUILTIN\nendif\n\nifeq ($(strip $(HAVE_STATIC_DUMMY)),1)\n  CFLAGS\t+=\t-DHAVE_STATIC_DUMMY=1\nendif\n\nCXXFLAGS\t:= $(CFLAGS) -fno-rtti -fno-exceptions -std=gnu++11\n\nASFLAGS\t:=\t-g $(ARCH)\nLDFLAGS\t=\t$(ARCH) -Wl,--allow-multiple-definition -Wl,-Map,$(notdir $*.map)\n\n# add things from Makefile.common\nCFLAGS += $(DEF_FLAGS)\n\nLIBS\t:= -lstdc++ -lm\n\n#---------------------------------------------------------------------------------\n# no real need to edit anything past this point unless you need to add additional\n# rules for different file extensions\n#---------------------------------------------------------------------------------\nifneq ($(BUILD),$(notdir $(CURDIR)))\n#---------------------------------------------------------------------------------\n\nexport OUTPUT\t:=\t$(TARGET)\nexport TOPDIR\t:=\t$(CURDIR)\n\nexport VPATH\t:=\t$(foreach dir,$(SOURCES),$(CURDIR)/$(dir)) \\\n\t\t\t$(foreach dir,$(DATA),$(CURDIR)/$(dir))\n\nexport DEPSDIR\t:=\t$(CURDIR)/\n\nCFILES\t\t:=\t$(foreach dir,$(SOURCES),$(notdir $(wildcard $(dir)/*.c)))\nCPPFILES\t:=\t$(foreach dir,$(SOURCES),$(notdir $(wildcard $(dir)/*.cpp)))\nSFILES\t\t:=\t$(foreach dir,$(SOURCES),$(notdir $(wildcard $(dir)/*.s)))\nBINFILES\t:=\t$(foreach dir,$(DATA),$(notdir $(wildcard $(dir)/*.*)))\n\nexport OFILES \t:=\t$(OBJ)\n\nifeq ($(strip $(HAVE_STATIC_DUMMY)),)\n  OFILES += libretro_libnx.a\nendif\n\nexport HFILES_BIN\t:=\t$(addsuffix .h,$(subst .,_,$(BINFILES)))\n\nexport INCLUDE\t:=\t$(foreach dir,$(INCLUDES),-I$(CURDIR)/$(dir)) \\\n\t\t\t$(foreach dir,$(LIBDIRS),-I$(dir)/include) \\\n\t\t\t-I$(CURDIR)/$(BUILD)\n\nexport LIBPATHS\t:=\t$(foreach dir,$(LIBDIRS),-L$(dir)/lib)\n\nexport BUILD_EXEFS_SRC := $(TOPDIR)/$(EXEFS_SRC)\n\nifneq ($(APP_TITLEID),)\n\texport NACPFLAGS += --titleid=$(APP_TITLEID)\nendif\n\nifneq ($(ROMFS),)\n\texport NROFLAGS += --romfsdir=$(CURDIR)/$(ROMFS)\nendif\n\nLIB_CORE :=\n\nifeq ($(HAVE_STATIC_DUMMY),1)\n  DEFINES += -DHAVE_STATIC_DUMMY\nelse\n  LIB_CORE += -lretro_dos\nendif\n\nDEPENDS_TMP  := $(OFILES:.o=.d)\nDEPENDS      := $(filter-out libretro_libnx.a,$(DEPENDS_TMP))\n\n.PHONY: clean all\n\n#---------------------------------------------------------------------------------\n# main targets\n#---------------------------------------------------------------------------------\nall\t:\t$(OUTPUT)\n\n$(OUTPUT): $(OBJ)\n\t$(CXX) -o $@ $(LDFLAGS) $(LIBDIRS) $(OBJ) $(PLATEXTRA) -L. $(LIB_CORE) $(LIBS)\n\n%.o: %.c\n\t$(CC) -c -o $@ $(CFLAGS) $<\n\n%.o: %.cpp\n\t$(CXX) -c -o $@ $(CFLAGS) $<\n\nclean:\n\trm -f $(DEPENDS) $(OBJ) $(OUTPUT)\n\n#---------------------------------------------------------------------------------\n# you need a rule like this for each extension you use as binary data\n#---------------------------------------------------------------------------------\n%.bin.o\t%_bin.h :\t%.bin\n#---------------------------------------------------------------------------------\n\t@echo $(notdir $<)\n\t@$(bin2o)\n\n#---------------------------------------------------------------------------------------\nendif\n#---------------------------------------------------------------------------------------\n"
        },
        {
          "name": "Makefile.emscripten",
          "type": "blob",
          "size": 4.337890625,
          "content": "HAVE_STATIC_DUMMY ?= 0\nifeq ($(TARGET),)\nifeq ($(LIBRETRO),)\nTARGET := retroarch.js\nLIBRETRO = dummy\nelse\nTARGET := $(LIBRETRO)_libretro.js\nendif\nendif\n\nEOPT = USE_ZLIB=1 # Emscripten specific options\nEOPTS = $(addprefix -s $(EMPTY), $(EOPT)) # Add '-s ' to each option\n\nOS = Emscripten\nOBJ :=\nDEFINES := -DRARCH_INTERNAL -DHAVE_MAIN\nDEFINES += -DHAVE_FILTERS_BUILTIN\nHAVE_PATCH = 1\nHAVE_DSP_FILTER = 1\nHAVE_VIDEO_FILTER = 1\nHAVE_OVERLAY = 1\nHAVE_GLSL = 1\nHAVE_SCREENSHOTS = 1\nHAVE_REWIND = 1\nHAVE_AUDIOMIXER = 1\nHAVE_CC_RESAMPLER = 1\nHAVE_EGL    = 1\nHAVE_OPENGLES = 1\nHAVE_RJPEG  = 0\nHAVE_RPNG   = 1\nHAVE_EMSCRIPTEN = 1\nHAVE_MENU = 1\nHAVE_GFX_WIDGETS = 1\nHAVE_RGUI = 1\nHAVE_SDL = 0\nHAVE_SDL2 = 0\nHAVE_ZLIB = 1\nHAVE_SHADERPIPELINE = 1\nHAVE_STATIC_VIDEO_FILTERS = 1\nHAVE_STATIC_AUDIO_FILTERS = 1\nHAVE_STB_FONT = 1\nHAVE_CONFIGFILE = 1\nHAVE_COMMAND = 1\nHAVE_STDIN_CMD = 1\nHAVE_CHEATS = 1\nHAVE_IBXM = 1\nHAVE_CORE_INFO_CACHE = 1\nHAVE_7ZIP = 1\nHAVE_BSV_MOVIE = 1\nHAVE_AL = 1\n\n# WARNING -- READ BEFORE ENABLING\n# The rwebaudio driver is known to have several audio bugs, such as\n#  minor crackling, or the entire page freezing/crashing.\n#  It works perfectly on chrome, but even firefox has really bad audio quality.\n#  I should also note, the driver on iOS is completely broken (crashes the page).\n#  You have been warned.\nHAVE_RWEBAUDIO = 0\n\nASYNC ?= 0\nifeq ($(LIBRETRO), mupen64plus)\n   ASYNC = 1\nendif\n\nLTO ?= 0\nifeq ($(LIBRETRO), tyrquake)\n   LTO = 0\nendif\n\nPTHREAD ?= 0\n\nMEMORY ?= 134217728\n\nPRECISE_F32 = 1\n\nOBJDIR := obj-emscripten\n\n#if you compile with SDL2 flag add this Emscripten flag \"-s USE_SDL=2\" to LDFLAGS:\n\nLIBS    := -s USE_ZLIB=1\nLDFLAGS := -L. --no-heap-copy -s $(LIBS) -s TOTAL_MEMORY=$(MEMORY) -s NO_EXIT_RUNTIME=0 -s FULL_ES2=1 \\\n           -s \"EXPORTED_RUNTIME_METHODS=['callMain', 'FS', 'PATH', 'ERRNO_CODES']\" \\\n           -s ALLOW_MEMORY_GROWTH=1 -s \"EXPORTED_FUNCTIONS=['_main', '_malloc', '_cmd_savefiles', '_cmd_save_state', '_cmd_load_state', '_cmd_take_screenshot']\" \\\n           -s MODULARIZE=1 -s EXPORT_ES6=1 -s EXPORT_NAME=\"libretro_$(subst -,_,$(LIBRETRO))\" \\\n           -s DISABLE_DEPRECATED_FIND_EVENT_TARGET_BEHAVIOR=1 \\\n           --js-library emscripten/library_errno_codes.js \\\n           --js-library emscripten/library_rwebcam.js\n\nifeq ($(HAVE_RWEBAUDIO), 1)\n   LDFLAGS += --js-library emscripten/library_rwebaudio.js\n   DEFINES += -DHAVE_RWEBAUDIO\nendif\nifeq ($(HAVE_AL), 1)\n   LDFLAGS += -lopenal\n   DEFINES += -DHAVE_AL\n   ASYNC = 1\nendif\n\nifneq ($(PTHREAD), 0)\n   LDFLAGS += -s WASM_MEM_MAX=1073741824 -pthread -s PTHREAD_POOL_SIZE=$(PTHREAD)\n   CFLAGS += -pthread\n   HAVE_THREADS=1\nelse\n   HAVE_THREADS=0\nendif\n\nifeq ($(ASYNC), 1)\n   LDFLAGS += -s ASYNCIFY=$(ASYNC) -s ASYNCIFY_STACK_SIZE=8192 \n   ifeq ($(DEBUG), 1)\n     LDFLAGS += -s ASYNCIFY_DEBUG=1 # -s ASYNCIFY_ADVISE\n   endif\nendif\n\nifeq ($(HAVE_SDL2), 1)\n   LIBS += -s USE_SDL=2\n   DEFINES += -DHAVE_SDL2\nendif\n\ninclude Makefile.common\n\nCFLAGS += $(DEF_FLAGS) -Ideps -Ideps/stb\n\nlibretro :=\n\nifeq ($(HAVE_STATIC_DUMMY),1)\n  DEFINES += -DHAVE_STATIC_DUMMY\nelse\n  libretro += libretro_emscripten.bc\nendif\n\nifneq ($(V), 1)\n   Q := @\nendif\n\nifeq ($(DEBUG), 1)\n   LDFLAGS += -O0 -g -gsource-map -s SAFE_HEAP=1 -s STACK_OVERFLOW_CHECK=2 -s ASSERTIONS=1\n   CFLAGS += -O0 -g -gsource-map -s SAFE_HEAP=1 -s SAFE_HEAP_LOG=1 -s STACK_OVERFLOW_CHECK=2 -s ASSERTIONS=1\nelse\n   LDFLAGS += -O3 -s WASM=1\n   # WARNING: some optimizations can break some cores (ex: LTO breaks tyrquake)\n   LDFLAGS += -s PRECISE_F32=$(PRECISE_F32)\n   ifeq ($(LTO), 1)\n      LDFLAGS += --llvm-lto 3\n   endif\n   CFLAGS += -O3\nendif\n\n# 128 * 1024, double the usual emscripten stack size\nLDFLAGS += -s STACK_SIZE=131072\n\nLDFLAGS += --extern-pre-js emscripten/pre.js\n\nCFLAGS += -Wall -I. -Ilibretro-common/include -std=gnu99 #\\\n#          -s EXPORTED_FUNCTIONS=\"['_main', '_malloc', '_cmd_savefiles', '_cmd_save_state', '_cmd_take_screenshot']\"\n\nRARCH_OBJ := $(addprefix $(OBJDIR)/,$(OBJ))\n\nall: $(TARGET)\n\n$(TARGET): $(RARCH_OBJ) $(libretro)\n\t@$(if $(Q), $(shell echo echo LD $@),)\n\t$(Q)$(LD) -o $@ $(RARCH_OBJ) $(libretro) $(LIBS) $(LDFLAGS)\n\n$(OBJDIR)/%.o: %.c\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CC $<),)\n\t$(Q)$(CC) $(CFLAGS) $(DEFINES) $(EOPTS) -c -o $@ $<\n\n$(OBJDIR)/%.o: %.cpp\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CXX $<),)\n\t$(Q)$(CXX) $(CXXFLAGS) $(DEFINES) $(EOPTS) -c -o $@ $<\n\nclean:\n\trm -rf $(OBJDIR)\n\trm -f $(TARGET)\n\n.PHONY: all clean\n"
        },
        {
          "name": "Makefile.griffin",
          "type": "blob",
          "size": 45.9775390625,
          "content": "ROOT_DIR       := .\nDEPS_DIR       := $(ROOT_DIR)/deps\nDEBUG          = 0\nHAVE_LOGGER       = 0\nHAVE_FILE_LOGGER     = 0\nHAVE_CC_RESAMPLER    = 1\nWHOLE_ARCHIVE_LINK      = 0\nBIG_STACK            = 1\nPC_DEVELOPMENT_IP_ADDRESS  = 255.255.255.255\nPC_DEVELOPMENT_UDP_PORT    = 3490\nRARCH_CONSOLE        = 0\nUSBGECKO       = 0\n\nSPACE :=\nSPACE := $(SPACE) $(SPACE)\nBACKSLASH :=\nBACKSLASH := \\$(BACKSLASH)\nfilter_out1 = $(filter-out $(firstword $1),$1)\nfilter_out2 = $(call filter_out1,$(call filter_out1,$1))\n\nUNAME_ARCH = $(shell uname -m)\n\nifeq ($(UNAME_ARCH),x86_64)\n   HOST_ARCH = x64\nelse\n   HOST_ARCH = x86\nendif\n\nifneq ($(EMSCRIPTEN),)\n   platform = emscripten\nendif\n\nifeq ($(platform),)\n   platform = unix\n\n   ifeq ($(shell uname -s),)\n      platform = win\n   else ifneq ($(findstring MINGW,$(shell uname -s)),)\n      platform = win\n   else ifneq ($(findstring Darwin,$(shell uname -s)),)\n      platform = osx\n   else ifneq ($(findstring win,$(shell uname -s)),)\n      platform = win\n   endif\nendif\n\n# system platform\nsystem_platform = unix\n\nifeq ($(shell uname -s),)\n   EXE_EXT = .exe\n   system_platform = win\nelse ifneq ($(findstring Darwin,$(shell uname -s)),)\n   system_platform = osx\nelse ifneq ($(findstring MINGW,$(shell uname -s)),)\n   system_platform = win\nendif\n\nTARGET_NAME        := retroarch\n\nINCLUDE            :=\nLDFLAGS            :=\nLIBDIRS            :=\n\nSHADER_CG_DIR      := media/shaders_cg\nOVERLAY_DIR        := media/overlays\nSHADER_GLSL_DIR    := media/shaders_glsl\n\nPYTHON3            := python3$(EXE_EXT)\nGIT                := git$(EXE_EXT)\n\nifeq ($(WHOLE_ARCHIVE_LINK), 1)\n   WHOLE_START     := -Wl,--whole-archive\n   WHOLE_END       := -Wl,--no-whole-archive\nendif\n\nSTATIC_BUILD = 1\nifneq (,$(findstring msvc,$(platform)))\n   STATIC_BUILD = 0\nendif\nifneq (,$(findstring unix,$(platform)))\n   STATIC_BUILD = 0\nendif\nifeq (qnx, $(platform))\n   STATIC_BUILD = 0\nendif\n\nifeq ($(STATIC_BUILD), 0)\n   LIBS               := $(WHOLE_START) $(WHOLE_END)\nelse\n   LIBS               := $(WHOLE_START) -lretro_$(platform) $(WHOLE_END)\nendif\n\nlibogc_platform    :=\n\nifeq ($(platform), ngc)\n   libogc_platform    := 1\nelse ifeq ($(platform), wii)\n   libogc_platform    := 1\nendif\n\nHAVE_GFX_WIDGETS := 1\n\n# PS3\nifeq ($(platform), ps3)\n   #TODO\n   MEDIA_SHADER_DIR := pkg/ps3/USRDIR/cores/shaders\n   RARCH_CONSOLE          = 1\n\n# PS3 - Cobra\nelse ifeq ($(platform), ps3-cobra)\n   #TODO\n   MEDIA_SHADER_DIR := ps3/iso/PS3_GAME/USRDIR/cores/shaders\n   RARCH_CONSOLE          = 1\n\n# NGC/Wii - libogc\nelse ifeq ($(libogc_platform), 1)\n   EXTERNAL_LIBOGC   ?= 0\n   GX_PTHREAD_LEGACY ?= 1\n   CC = $(DEVKITPPC)/bin/powerpc-eabi-gcc$(EXE_EXT)\n   CXX = $(DEVKITPPC)/bin/powerpc-eabi-g++$(EXE_EXT)\n   LD = $(DEVKITPPC)/bin/powerpc-eabi-ld$(EXE_EXT)\n   ELF2DOL = $(DEVKITPPC)/bin/elf2dol$(EXE_EXT)\n   # Check whether ELF2DOL executable exists\n   # (path has changed in more recent toolchains)\n   ifeq (\"$(wildcard $(ELF2DOL))\",\"\")\n     ELF2DOL = $(DEVKITPRO)/tools/bin/elf2dol$(EXE_EXT)\n   endif\n   EXT_TARGET := $(TARGET_NAME)_$(platform).dol\n   EXT_INTER_TARGET := $(TARGET_NAME)_$(platform).elf\n\n   INCLUDE += -I.\n\n   ifeq ($(EXTERNAL_LIBOGC), 1)\n      CFLAGS   += -DEXTERNAL_LIBOGC\n      CXXFLAGS += -DEXTERNAL_LIBOGC\n      INCLUDE += -I$(DEVKITPRO)/libogc/include\n\n      ifeq ($(platform), ngc)\n         LIBDIRS += -L$(DEVKITPRO)/libogc/lib/cube\n      else ifeq ($(platform), wii)\n         LIBDIRS += -L$(DEVKITPRO)/libogc/lib/wii\n      endif\n\n   else\n      CFLAGS   += -DINTERNAL_LIBOGC\n      CXXFLAGS += -DINTERNAL_LIBOGC\n      INCLUDE += -Iwii/libogc/include\n\n      ifeq ($(platform), ngc)\n         LIBDIRS += -Lwii/libogc/libs/cube\n      else ifeq ($(platform), wii)\n         LIBDIRS += -Lwii/libogc/libs/wii\n      endif\n\n   endif\n\n   ifeq ($(GX_PTHREAD_LEGACY), 1)\n      CFLAGS   += -DGX_PTHREAD_LEGACY\n      CXXFLAGS += -DGX_PTHREAD_LEGACY\n   endif\n\n   ifeq ($(platform), ngc)\n      MACHDEP := -DHW_DOL -mogc\n   else ifeq ($(platform), wii)\n      MACHDEP := -DHW_RVL -mrvl\n   endif\n\n   LIBDIRS += -L.\n   MACHDEP += -DGEKKO -mcpu=750 -meabi -mhard-float\n\n   ifeq ($(platform), ngc)\n      LDFLAGS += $(MACHDEP) -Wl,-Map,$(notdir $(EXT_INTER_TARGET)).map\n\n      ifeq ($(BIG_STACK), 1)\n         LDFLAGS += -T bootstrap/gx/ogc.ld\n      endif\n   else ifeq ($(platform), wii)\n      LDFLAGS += $(MACHDEP) -Wl,-Map,$(notdir $(EXT_INTER_TARGET)).map,-wrap,malloc,-wrap,free,-wrap,memalign,-wrap,calloc,-wrap,realloc,-wrap,strdup,-wrap,strndup,-wrap,malloc_usable_size\n\n      ifeq ($(BIG_STACK), 1)\n        LDFLAGS += -T bootstrap/gx/rvl.ld\n      endif\n   endif\n\n   ifeq ($(EXTERNAL_LIBOGC), 1)\n      LIBS += -lfat\n   endif\n\n   ifeq ($(platform), wii)\n      LIBS += -lwiiuse -lbte\n\n      ifeq ($(USBGECKO), 1)\n        LIBS += -ldb\n      endif\n   else ifeq ($(platform), ngc)\n      ifeq ($(HAVE_LOGGER), 1)\n        LIBS += -lbba\n      endif\n   endif\n\n   LIBS += -logc\n\n   CFLAGS += -DGEKKO -U__INT32_TYPE__ -U __UINT32_TYPE__ -D__INT32_TYPE__=int\n\n   HAVE_RUNAHEAD            := 1\n   HAVE_DSP_FILTER          := 1\n   HAVE_VIDEO_FILTER        := 1\n   HAVE_FILTERS_BUILTIN     := 1\n   HAVE_THREADS             := 1\n   HAVE_RPNG                := 1\n   HAVE_RJPEG               := 1\n   HAVE_RBMP                := 1\n   HAVE_RTGA                := 1\n   HAVE_IBXM                := 1\n   HAVE_OVERLAY             := 1\n   HAVE_ZLIB                := 1\n   HAVE_7ZIP                := 1\n   HAVE_CONFIGFILE          := 1\n   HAVE_PATCH               := 1\n   HAVE_CHEATS              := 1\n   HAVE_SCREENSHOTS         := 1\n   HAVE_REWIND              := 1\n   HAVE_AUDIOMIXER          := 1\n   HAVE_RWAV                := 1\n   RARCH_CONSOLE             = 1\n   HAVE_CORE_INFO_CACHE     := 1\n\n   ifeq ($(platform), wii)\n      #HAVE_LANGEXTRA          := 1\n      HAVE_WIIUSB_HID          := 1\n      HAVE_RARCH_EXEC          := 1\n      HAVE_RSOUND              := 1\n\n      APP_BOOTER_DIR = wii/app_booter\n      PLATOBJS := $(APP_BOOTER_DIR)/app_booter.binobj\n\n      ifeq ($(USBGECKO), 1)\n         CFLAGS += -DUSBGECKO\n      endif\n   endif\n\n# Libxenon (Xbox 360)\nelse ifeq ($(platform), xenon360)\n   CC = xenon-gcc$(EXE_EXT)\n   CXX = xenon-g++$(EXE_EXT)\n   OBJCOPY = xenon-objcopy$(EXE_EXT)\n   LD    = xenon-ld$(EXE_EXT)\n   STRIP = xenon-strip$(EXE_EXT)\n   INCLUDE += -I$(DEVKITXENON)/usr/include\n\n   EXT_TARGET := $(TARGET_NAME)_$(platform).elf32\n   EXT_INTER_TARGET := $(TARGET_NAME)_$(platform).elf\n\n   LIBS                     += -lxenon -lm -lc\n\n   LIBDIRS                  += -L. -L$(DEVKITXENON)/usr/lib -L$(DEVKITXENON)/xenon/lib/32\n   LDFLAGS                  +=  -Wl,-q -m32 -n -T$(DEVKITXENON)/app.lds\n   PLATCFLAGS               := -DHAVE_GETOPT_LONG=1\n   PLATCFLAGS               += -maltivec -mhard-float -m32 -mpowerpc64 -mcpu=cell -mtune=cell -fno-pic -g -Wall -DXENON $(INCDIRS) -Wno-char-subscripts\n   PLATCFLAGS               += -u read -u _start -u exc_base\n   HAVE_THREADS             := 1\n   HAVE_GETOPT_LONG         := 1\n   RARCH_CONSOLE             = 1\n   HAVE_CONFIGFILE          := 1\n   HAVE_PATCH               := 1\n   HAVE_CHEATS              := 1\n\n# PSP\nelse ifeq ($(platform), psp1)\n   CC = psp-gcc$(EXE_EXT)\n   CXX = psp-g++$(EXE_EXT)\n   LD = psp-ld$(EXE_EXT)\n   INCLUDE += -I$(PSPSDK)/psp/sdk/include\n   EXT_TARGET := $(TARGET_NAME)_$(platform).elf\n   EXT_INTER_TARGET := $(TARGET_NAME)_$(platform).elf\n   PLATCFLAGS := -DPSP -D_PSP_FW_VERSION=150 -G0 \\\n      -D_MIPS_ARCH_ALLEGREX\n   LIBS +=  -lpspgu -lpspgum -lm -lpspaudio -lpspfpu -lpsppower -lpsprtc -lpspkernel\n\n   LIBDIRS += -L.\n   LDFLAGS +=  -Wl,-q\n\n   BUILD_PRX                 = 1\n   HAVE_RPNG                := 1\n   HAVE_RJPEG               := 1\n   HAVE_RBMP                := 1\n   HAVE_RTGA                := 1\n   HAVE_KERNEL_PRX          := 1\n   #HAVE_LANGEXTRA          := 1\n   RARCH_CONSOLE             = 1\n   HAVE_CONFIGFILE          := 1\n   HAVE_PATCH               := 1\n   HAVE_CHEATS              := 1\n   HAVE_CORE_INFO_CACHE     := 1\n\n   ifeq ($(BUILD_PRX), 1)\n      LDFLAGS += $(addprefix -L,$(PSPSDK)/lib) -specs=$(PSPSDK)/lib/prxspecs -Wl,-q,-T$(PSPSDK)/lib/linkfile.prx $(LDFLAGS)\n   endif\n\n# Vita\nelse ifeq ($(platform), vita)\n   CC = arm-vita-eabi-gcc$(EXE_EXT)\n   CXX = arm-vita-eabi-g++$(EXE_EXT)\n   LD = arm-vita-eabi-ld$(EXE_EXT)\n   EXT_TARGET := $(TARGET_NAME)_$(platform).velf\n   EXT_INTER_TARGET := $(TARGET_NAME)_$(platform).elf\n   MACHDEP := -DVITA\n   INCLUDE += -Ideps/libvita2d/include\n   PLATCFLAGS := -mfloat-abi=hard -fsingle-precision-constant \\\n        -mword-relocations -fno-unwind-tables -fno-asynchronous-unwind-tables -ftree-vectorize -fno-optimize-sibling-calls\n   LIBS += -lSceDisplay_stub -lSceGxm_stub -lSceNet_stub -lSceNetCtl_stub\\\n           -lSceSysmodule_stub -lSceCtrl_stub -lSceHid_stub -lSceTouch_stub -lSceAudio_stub -lSceFiber_stub\\\n           -lScePower_stub -lSceRtc_stub -lSceCommonDialog_stub -lScePgf_stub \\\n           -lSceMotion_stub -lSceAppMgr_stub -lpng -lm -lc\n\n   PLATOBJS += $(DEPS_DIR)/libvita2d/shader/clear_v_gxp.o \\\n      $(DEPS_DIR)/libvita2d/shader/clear_f_gxp.o \\\n      $(DEPS_DIR)/libvita2d/shader/color_v_gxp.o \\\n      $(DEPS_DIR)/libvita2d/shader/color_f_gxp.o \\\n      $(DEPS_DIR)/libvita2d/shader/texture_v_gxp.o \\\n      $(DEPS_DIR)/libvita2d/shader/texture_f_gxp.o \\\n      $(DEPS_DIR)/libvita2d/shader/texture_tint_f_gxp.o\n\n   PLATOBJS += \\\n      libretro-common/audio/conversion/s16_to_float_neon.o \\\n      libretro-common/audio/conversion/float_to_s16_neon.o \\\n      memory/neon/memcpy-neon.o \\\n      libretro-common/audio/resampler/drivers/sinc_resampler_neon.o \\\n      audio/drivers_resampler/cc_resampler_neon.o\n\n   LIBDIRS += -L.\n   LDFLAGS +=  -Wl,-q\n\n   HAVE_DSP_FILTER          := 1\n   HAVE_VIDEO_FILTER        := 1\n   HAVE_FILTERS_BUILTIN     := 1\n   HAVE_LANGEXTRA           := 1\n   HAVE_RPNG                := 1\n   HAVE_RJPEG               := 1\n   HAVE_RBMP                := 1\n   HAVE_RTGA                := 1\n   HAVE_ZLIB                := 1\n   HAVE_7ZIP                := 1\n   HAVE_VITA2D              := 1\n   HAVE_NETWORKING          := 1\n   HAVE_IFINFO              := 1\n   HAVE_NETPLAYDISCOVERY    := 1\n   HAVE_OVERLAY             := 1\n   HAVE_MATERIALUI          := 1\n   HAVE_XMB                 := 1\n   HAVE_STB_FONT            := 1\n   HAVE_THREADS             := 1\n   HAVE_LIBRETRODB          := 1\n   RARCH_CONSOLE             = 1\n   HAVE_CONFIGFILE          := 1\n   HAVE_PATCH               := 1\n   HAVE_CHEATS              := 1\n   HAVE_CORE_INFO_CACHE     := 1\nelse ifeq ($(platform), windows_msvc6_x86)\n   HAVE_RPNG                := 1\n   HAVE_RJPEG               := 1\n   HAVE_RBMP                := 1\n   HAVE_RTGA                := 1\n   HAVE_ZLIB                := 1\n   HAVE_7ZIP                := 1\n   HAVE_NETWORKING          := 0\n   HAVE_IFINFO              := 0\n   HAVE_NETWORK_CMD         := 0\n   HAVE_NETPLAYDISCOVERY    := 0\n   HAVE_OVERLAY             := 1\n   HAVE_MATERIALUI          := 1\n   HAVE_XMB                 := 1\n   HAVE_STB_FONT            := 1\n   HAVE_THREADS             := 1\n   HAVE_LIBRETRODB          := 1\n   HAVE_COMMAND             := 1\n   HAVE_STDIN_CMD           := 1\n   HAVE_CMD                 := 1\n   HAVE_DYLIB               := 1\n   HAVE_DYNAMIC             := 1\n   HAVE_GRIFFIN_CPP         := 1\n   HAVE_CONFIGFILE          := 1\n   HAVE_PATCH               := 1\n   HAVE_CHEATS              := 1\n   HAVE_CORE_INFO_CACHE     := 1\n\n   EXT_TARGET := $(TARGET_NAME).exe\n   EXT_INTER_TARGET := $(TARGET_NAME).exe\n   CC = cl.exe\n   CXX = cl.exe\n   LD = link.exe\n\n   PLATCFLAGS += -D_WIN32 -D_WIN32_WINNT=0x0351 -D__STDC_CONSTANT_MACROS -D_MBCS\n   LDFLAGS += shell32.lib user32.lib gdi32.lib comdlg32.lib winmm.lib ole32.lib\n\n   VCDIR ?= $(shell reg query \"HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\DevStudio\\6.0\\Products\\Microsoft Visual C++\" -v \"ProductDir\" | grep -io '[A-Z]:\\\\.*')\n\n   PATH := $(shell IFS=$$'\\n'; cygpath \"$(VCDIR)/bin\"):$(PATH)\n   PATH := $(PATH):$(shell IFS=$$'\\n'; cygpath \"$(VCDIR)/../Common/MSDev98/Bin\")\n   INCLUDE := $(shell IFS=$$'\\n'; cygpath -w \"$(VCDIR)/Include\")\n   LIB := $(shell IFS=$$'\\n'; cygpath -w \"$(VCDIR)/Lib\")\n\n   export INCLUDE := $(INCLUDE);$(INETSDK)\\Include;libretro-common\\include;libretro-common\\include\\compat\\msvc;gfx\\include;deps;deps\\stb\n   export LIB := $(LIB);$(INETSDK)\\Lib\nelse ifeq ($(platform), windows_msvc2003_x86)\n   HAVE_GDI                 := 1\n   HAVE_RPNG                := 1\n   HAVE_RJPEG               := 1\n   HAVE_RBMP                := 1\n   HAVE_RTGA                := 1\n   HAVE_ZLIB                := 1\n   HAVE_7ZIP                := 1\n   HAVE_NETWORKING          := 1\n   HAVE_IFINFO              := 0\n   HAVE_NETWORK_CMD         := 1\n   HAVE_NETPLAYDISCOVERY    := 1\n   HAVE_OVERLAY             := 1\n   HAVE_MATERIALUI          := 1\n   HAVE_XMB                 := 1\n   HAVE_STB_FONT            := 1\n   HAVE_THREADS             := 1\n   HAVE_LIBRETRODB          := 1\n   HAVE_COMMAND             := 1\n   HAVE_STDIN_CMD           := 1\n   HAVE_CMD                 := 1\n   HAVE_DYLIB               := 1\n   HAVE_DYNAMIC             := 1\n   HAVE_GRIFFIN_CPP         := 1\n   HAVE_CONFIGFILE          := 1\n   HAVE_PATCH               := 1\n   HAVE_CHEATS              := 1\n   HAVE_GFX_WIDGETS         := 1\n   HAVE_CORE_INFO_CACHE     := 1\n\n   EXT_TARGET := $(TARGET_NAME).exe\n   EXT_INTER_TARGET := $(TARGET_NAME).exe\n   CC = cl.exe\n   CXX = cl.exe\n   LD = link.exe\n\n   PLATCFLAGS += -D_WIN32 -DWINVER=0x0400 -D_WIN32_WINNT=0x0400 -D__STDC_CONSTANT_MACROS -D_MBCS -D_VC80_UPGRADE=0x0710\n   PLATCFLAGS += -DHAVE_GFX_WIDGETS\n   LDFLAGS += shell32.lib user32.lib gdi32.lib comdlg32.lib winmm.lib ole32.lib\n\n   PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS71COMNTOOLS)../../Vc7/bin\"):$(PATH)\n   PATH := $(PATH):$(shell IFS=$$'\\n'; cygpath \"$(VS71COMNTOOLS)../IDE\")\n   INCLUDE := $(shell IFS=$$'\\n'; cygpath -w \"$(VS71COMNTOOLS)../../Vc7/include\")\n   LIB := $(shell IFS=$$'\\n'; cygpath -w \"$(VS71COMNTOOLS)../../Vc7/lib\")\n\n   ifeq ($(HAVE_DIRECTX), 1)\n      PLATCFLAGS += -DHAVE_DINPUT -DHAVE_DSOUND\n      DXSDK_DIR := $(DXSDK_DIR:\\=)\n      export INCLUDE := $(INCLUDE);$(INETSDK)\\Include;$(DXSDK_DIR)\\Include;libretro-common\\include;libretro-common\\include\\compat\\msvc;gfx\\include;deps;deps\\stb\n      export LIB := $(LIB);$(INETSDK)\\Lib;$(DXSDK_DIR)\\Lib\\x86\n   else\n      export INCLUDE := $(INCLUDE);$(INETSDK)\\Include;libretro-common\\include;libretro-common\\include\\compat\\msvc;gfx\\include;deps;deps\\stb\n      export LIB := $(LIB);$(INETSDK)\\Lib\n   endif\nelse ifeq ($(platform), windows_msvc2005_x86)\n   HAVE_GDI                 := 1\n   HAVE_REWIND              := 1\n   HAVE_RPNG                := 1\n   HAVE_RJPEG               := 1\n   HAVE_RBMP                := 1\n   HAVE_RTGA                := 1\n   HAVE_ZLIB                := 1\n   HAVE_7ZIP                := 1\n   HAVE_NETWORKING          := 1\n   HAVE_IFINFO              := 0\n   HAVE_NETWORK_CMD         := 1\n   HAVE_NETPLAYDISCOVERY    := 1\n   HAVE_OVERLAY             := 1\n   HAVE_MATERIALUI          := 1\n   HAVE_XMB                 := 1\n   HAVE_OZONE               := 1\n   HAVE_STB_FONT            := 1\n   HAVE_THREADS             := 1\n   HAVE_LIBRETRODB          := 1\n   HAVE_COMMAND             := 1\n   HAVE_STDIN_CMD           := 1\n   HAVE_CMD                 := 1\n   HAVE_DYLIB               := 1\n   HAVE_DYNAMIC             := 1\n   HAVE_GRIFFIN_CPP         := 1\n   HAVE_RUNAHEAD            := 1\n   HAVE_DIRECTX             ?= 1\n   HAVE_OPENGL              := 1\n   HAVE_OPENGL1             := 1\n   HAVE_CONFIGFILE          := 1\n   HAVE_PATCH               := 1\n   HAVE_CHEATS              := 1\n   HAVE_DSP_FILTER          := 1\n   HAVE_VIDEO_FILTER        := 1\n   HAVE_FILTERS_BUILTIN     := 1\n   HAVE_GFX_WIDGETS         := 1\n   HAVE_CORE_INFO_CACHE     := 1\n\n   EXT_TARGET := $(TARGET_NAME).exe\n   EXT_INTER_TARGET := $(TARGET_NAME).exe\n   CC = cl.exe\n   CXX = cl.exe\n   LD = link.exe\n\n   PLATCFLAGS += -D_WIN32 -D_WIN32_WINNT=0x0410 -D__STDC_CONSTANT_MACROS -D_MBCS\n   PLATCFLAGS += -DHAVE_OPENGL -DHAVE_OPENGL1 -DHAVE_GLSL -DHAVE_OZONE -DHAVE_GFX_WIDGETS -DHAVE_CC_RESAMPLER\n   PLATCFLAGS += -DHAVE_ONLINE_UPDATER -DHAVE_UPDATE_ASSETS -DHAVE_UPDATE_CORES \n   PLATCFLAGS += -DHAVE_UPDATE_CORE_INFO \n   PLATCFLAGS += -DHAVE_CDROM\n   PLATCFLAGS += -bigobj\n\n   LDFLAGS += -MANIFEST shell32.lib user32.lib gdi32.lib comdlg32.lib winmm.lib ole32.lib msimg32.lib\n\n   PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS80COMNTOOLS)../../VC/bin\"):$(PATH)\n   PATH := $(PATH):$(shell IFS=$$'\\n'; cygpath \"$(VS80COMNTOOLS)../IDE\")\n   INCLUDE := $(shell IFS=$$'\\n'; cygpath -w \"$(VS80COMNTOOLS)../../VC/include\")\n   LIB := $(shell IFS=$$'\\n'; cygpath -w \"$(VS80COMNTOOLS)../../VC/lib\")\n\n   WindowsSdkDir := $(shell reg query \"HKLM\\SOFTWARE\\Microsoft\\MicrosoftSDK\\InstalledSDKs\\8F9E5EF3-A9A5-491B-A889-C58EFFECE8B3\" -v \"Install Dir\" | grep -o '[A-Z]:\\\\.*')\n\n   WindowsSDKIncludeDir := $(shell cygpath -w \"$(WindowsSdkDir)\\Include\")\n   WindowsSDKAtlIncludeDir := $(shell cygpath -w \"$(WindowsSdkDir)\\Include\\atl\")\n   WindowsSDKCrtIncludeDir := $(shell cygpath -w \"$(WindowsSdkDir)\\Include\\crt\")\n   WindowsSDKGlIncludeDir := $(shell cygpath -w \"$(WindowsSdkDir)\\Include\\gl\")\n   WindowsSDKMfcIncludeDir := $(shell cygpath -w \"$(WindowsSdkDir)\\Include\\mfc\")\n   WindowsSDKLibDir := $(shell cygpath -w \"$(WindowsSdkDir)\\Lib\")\n\n   INCLUDE := $(INCLUDE);$(WindowsSDKIncludeDir);$(WindowsSDKAtlIncludeDir);$(WindowsSDKCrtIncludeDir);$(WindowsSDKGlIncludeDir);$(WindowsSDKMfcIncludeDir);libretro/msvc/msvc-2005\n   LIB := $(LIB);$(WindowsSDKLibDir)\n\n   ifeq ($(HAVE_DIRECTX), 1)\n      PLATCFLAGS += -DHAVE_DINPUT -DHAVE_DSOUND -DHAVE_D3D -DHAVE_D3D8\n      DXSDK_DIR := $(DXSDK_DIR:\\=)\n      export INCLUDE := $(INCLUDE);$(INETSDK)\\Include;$(DXSDK_DIR)\\Include;libretro-common\\include;libretro-common\\include\\compat\\msvc;gfx\\include;deps;deps\\stb\n      export LIB := $(LIB);$(INETSDK)\\Lib;$(DXSDK_DIR)\\Lib\\x86\n   else\n      export INCLUDE := $(INCLUDE);$(INETSDK)\\Include;libretro-common\\include;libretro-common\\include\\compat\\msvc;gfx\\include;deps;deps\\stb\n      export LIB := $(LIB);$(INETSDK)\\Lib\n   endif\nelse ifneq (,$(findstring windows_msvc2010,$(platform)))\n   HAVE_GDI                 := 1\n   HAVE_CHEEVOS             := 1\n   HAVE_SCREENSHOTS         := 1\n   HAVE_REWIND              := 1\n   HAVE_AUDIOMIXER          := 1\n   HAVE_RWAV                := 1\n   HAVE_RPNG                := 1\n   HAVE_RJPEG               := 1\n   HAVE_RBMP                := 1\n   HAVE_RTGA                := 1\n   HAVE_ZLIB                := 1\n   HAVE_7ZIP                := 1\n   HAVE_NETWORKING          := 1\n   HAVE_IFINFO              := 1\n   HAVE_NETWORK_CMD         := 1\n   HAVE_NETPLAYDISCOVERY    := 1\n   HAVE_OVERLAY             := 1\n   HAVE_MATERIALUI          := 1\n   HAVE_XMB                 := 1\n   HAVE_OZONE               := 1\n   HAVE_STB_FONT            := 1\n   HAVE_THREADS             := 1\n   HAVE_LIBRETRODB          := 1\n   HAVE_COMMAND             := 1\n   HAVE_STDIN_CMD           := 1\n   HAVE_CMD                 := 1\n   HAVE_DYLIB               := 1\n   HAVE_DYNAMIC             := 1\n   HAVE_GRIFFIN_CPP         := 1\n   HAVE_RUNAHEAD            := 1\n   HAVE_DIRECTX             ?= 1\n   HAVE_OPENGL              := 1\n   HAVE_OPENGL1             := 1\n   HAVE_CONFIGFILE          := 1\n   HAVE_PATCH               := 1\n   HAVE_CHEATS              := 1\n   HAVE_DSP_FILTER          := 1\n   HAVE_VIDEO_FILTER        := 1\n   HAVE_FILTERS_BUILTIN     := 1\n   HAVE_GFX_WIDGETS         := 1\n   HAVE_CORE_INFO_CACHE     := 1\n\n   EXT_TARGET := $(TARGET_NAME).exe\n   EXT_INTER_TARGET := $(TARGET_NAME).exe\n   CC = cl.exe\n   CXX = cl.exe\n   LD = link.exe\n\n   PLATCFLAGS += -D_WIN32 -D__STDC_CONSTANT_MACROS -D_MBCS\n   PLATCFLAGS += -D__i686__ -D__SSE__ -D_CRT_NONSTDC_NO_WARNINGS -D_CRT_SECURE_NO_WARNINGS -D_WINDOWS\n   PLATCFLAGS += -DHAVE_CC_RESAMPLER -DHAVE_GL_SYNC -DHAVE_GLSL -DHAVE_IMAGEVIEWER -DHAVE_LANGEXTRA\n   PLATCFLAGS += -DHAVE_OPENGL -DHAVE_OPENGL1 -DHAVE_OZONE\n   PLATCFLAGS += -DHAVE_ONLINE_UPDATER -DHAVE_UPDATE_ASSETS -DHAVE_UPDATE_CORES\n   PLATCFLAGS += -DHAVE_UPDATE_CORE_INFO\n   PLATCFLAGS += -DWIN32 -DHAVE_CDROM\n   PLATCFLAGS += -DHAVE_GFX_WIDGETS\n   PLATCFLAGS += -bigobj\n\n   LDFLAGS += -MANIFEST shell32.lib user32.lib gdi32.lib comdlg32.lib winmm.lib ole32.lib iphlpapi.lib msimg32.lib\n\n   PlatformSuffix = $(subst windows_msvc2010_,,$(platform))\n\n   ifneq (,$(findstring x64,$(PlatformSuffix)))\n      ifeq ($(HOST_ARCH),x86)\n         # cross-compile for x64 from x86 host\n         PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS100COMNTOOLS)../../VC/bin/x86_amd64\"):$(PATH)\n      else\n         PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS100COMNTOOLS)../../VC/bin/amd64\"):$(PATH)\n      endif\n\n      LIB := $(shell IFS=$$'\\n'; cygpath -w \"$(VS100COMNTOOLS)../../VC/lib/amd64\")\n      WinArch = x64\n      PlatLib = Lib\\x64\n   else\n      PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS100COMNTOOLS)../../VC/bin\"):$(PATH)\n      LIB := $(shell IFS=$$'\\n'; cygpath -w \"$(VS100COMNTOOLS)../../VC/lib\")\n      WinArch = x86\n      PlatLib = Lib\n   endif\n\n   PATH := $(PATH):$(shell IFS=$$'\\n'; cygpath \"$(VS100COMNTOOLS)../IDE\")\n   INCLUDE := $(shell IFS=$$'\\n'; cygpath -w \"$(VS100COMNTOOLS)../../VC/include\")\n\n   WindowsSdkDir ?= $(shell reg query \"HKLM\\SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v7.1A\" -v \"InstallationFolder\" | grep -io '[A-Z]:\\\\.*')\n   WindowsSdkDir ?= $(shell reg query \"HKLM\\SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v7.0A\" -v \"InstallationFolder\" | grep -io '[A-Z]:\\\\.*')\n   WindowsSdkDir := $(WindowsSdkDir:\\=)\n\n   ifeq ($(HAVE_DIRECTX), 1)\n      PLATCFLAGS += -DHAVE_DINPUT -DHAVE_DSOUND -DHAVE_D3D -DHAVE_D3D8 -DHAVE_XAUDIO -DHAVE_XINPUT\n      DXSDK_DIR := $(DXSDK_DIR:\\=)\n      export INCLUDE := $(INCLUDE);$(WindowsSdkDir)\\Include;$(DXSDK_DIR)\\Include;libretro-common\\include;libretro-common\\include\\compat\\msvc;gfx\\include;deps;deps\\stb\n      export LIB := $(LIB);$(WindowsSdkDir)\\$(PlatLib);$(DXSDK_DIR)\\Lib\\$(WinArch)\n   else\n      export INCLUDE := $(INCLUDE);$(WindowsSdkDir)\\Include;libretro-common\\include;libretro-common\\include\\compat\\msvc;gfx\\include;deps;deps\\stb\n      export LIB := $(LIB);$(WindowsSdkDir)\\$(PlatLib)\n   endif\nelse ifneq (,$(findstring windows_msvc2012,$(platform)))\n   HAVE_GDI                 := 1\n   HAVE_SCREENSHOTS         := 1\n   HAVE_REWIND              := 1\n   HAVE_AUDIOMIXER          := 1\n   HAVE_RWAV                := 1\n   HAVE_RPNG                := 1\n   HAVE_RJPEG               := 1\n   HAVE_RBMP                := 1\n   HAVE_RTGA                := 1\n   HAVE_ZLIB                := 1\n   HAVE_7ZIP                := 1\n   HAVE_NETWORKING          := 1\n   HAVE_IFINFO              := 1\n   HAVE_NETWORK_CMD         := 1\n   HAVE_NETPLAYDISCOVERY    := 1\n   HAVE_OVERLAY             := 1\n   HAVE_MATERIALUI          := 1\n   HAVE_XMB                 := 1\n   HAVE_STB_FONT            := 1\n   HAVE_THREADS             := 1\n   HAVE_LIBRETRODB          := 1\n   HAVE_COMMAND             := 1\n   HAVE_STDIN_CMD           := 1\n   HAVE_CMD                 := 1\n   HAVE_DYLIB               := 1\n   HAVE_DYNAMIC             := 1\n   HAVE_GRIFFIN_CPP         := 1\n   HAVE_RUNAHEAD            := 1\n   HAVE_DIRECTX             ?= 1\n   HAVE_CONFIGFILE          := 1\n   HAVE_PATCH               := 1\n   HAVE_CHEATS              := 1\n   HAVE_CORE_INFO_CACHE     := 1\n\n   EXT_TARGET := $(TARGET_NAME).exe\n   EXT_INTER_TARGET := $(TARGET_NAME).exe\n   CC = cl.exe\n   CXX = cl.exe\n   LD = link.exe\n\n   PLATCFLAGS += -D_WIN32 -D__STDC_CONSTANT_MACROS -D_MBCS\n   PLATCFLAGS += -D__i686__ -D__MMX__ -D__SSE__ -D_CRT_NONSTDC_NO_WARNINGS -D_CRT_SECURE_NO_WARNINGS -D_WINDOWS -DHAVE_CC_RESAMPLER -DHAVE_GL_SYNC -DHAVE_GLSL -DHAVE_IMAGEVIEWER -DHAVE_LANGEXTRA -DHAVE_OPENGL -DHAVE_SHADERPIPELINE -DHAVE_ONLINE_UPDATER -DHAVE_UPDATE_ASSETS -DHAVE_UPDATE_CORES \n   PLATCFLAGS += -DHAVE_UPDATE_CORE_INFO\n   PLATCFLAGS += -DWIN32 -DHAVE_CDROM\n   LDFLAGS    += shell32.lib user32.lib gdi32.lib comdlg32.lib winmm.lib ole32.lib iphlpapi.lib\n\n   PlatformSuffix = $(subst windows_msvc2012_,,$(platform))\n\n   ifneq (,$(findstring x64,$(PlatformSuffix)))\n      ifeq ($(HOST_ARCH),x86)\n         # cross-compile for x64 from x86 host\n         PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS110COMNTOOLS)../../VC/bin/x86_amd64\"):$(PATH)\n      else\n         PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS110COMNTOOLS)../../VC/bin/amd64\"):$(PATH)\n      endif\n\n      LIB := $(shell IFS=$$'\\n'; cygpath -w \"$(VS110COMNTOOLS)../../VC/lib/amd64\")\n      WinArch = x64\n      PlatLib = Lib\\winv6.3\\um\\x64\n   else ifneq (,$(findstring arm,$(PlatformSuffix)))\n      PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS110COMNTOOLS)../../VC/bin/x86_arm\"):$(PATH)\n      LIB := $(shell IFS=$$'\\n'; cygpath -w \"$(VS110COMNTOOLS)../../VC/lib/arm\")\n      HAVE_DIRECTX = 0\n      PlatLib = Lib\\winv6.3\\um\\arm\n   else\n      PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS110COMNTOOLS)../../VC/bin\"):$(PATH)\n      LIB := $(shell IFS=$$'\\n'; cygpath -w \"$(VS110COMNTOOLS)../../VC/lib\")\n      WinArch = x86\n      PlatLib = Lib\\winv6.3\\um\\x86\n   endif\n\n   PATH := $(PATH):$(shell IFS=$$'\\n'; cygpath \"$(VS110COMNTOOLS)../IDE\")\n   INCLUDE := $(shell IFS=$$'\\n'; cygpath -w \"$(VS110COMNTOOLS)../../VC/include\")\n\n   WindowsSdkDir ?= $(shell reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots\" -v \"KitsRoot81\" | grep -io '[A-Z]:\\\\.*')\n   WindowsSdkDir := $(WindowsSdkDir:\\=)\n\n   ifeq ($(HAVE_DIRECTX), 1)\n      PLATCFLAGS += -DHAVE_DINPUT -DHAVE_DSOUND -DHAVE_D3D -DHAVE_D3D9 -DHAVE_XAUDIO -DHAVE_XINPUT\n      DXSDK_DIR := $(DXSDK_DIR:\\=)\n      export INCLUDE := $(INCLUDE);$(WindowsSdkDir)\\Include\\um;$(WindowsSdkDir)\\Include\\shared;$(DXSDK_DIR)\\Include;libretro-common\\include;libretro-common\\include\\compat\\msvc;gfx\\include;deps;deps\\stb\n      export LIB := $(LIB);$(WindowsSdkDir)\\$(PlatLib);$(DXSDK_DIR)\\Lib\\$(WinArch)\n   else\n      export INCLUDE := $(INCLUDE);$(WindowsSdkDir)\\Include\\um;$(WindowsSdkDir)\\Include\\shared;libretro-common\\include;libretro-common\\include\\compat\\msvc;gfx\\include;deps;deps\\stb\n      export LIB := $(LIB);$(WindowsSdkDir)\\$(PlatLib)\n   endif\nelse ifneq (,$(findstring windows_msvc2013,$(platform)))\n   HAVE_GDI                 := 1\n   HAVE_SCREENSHOTS         := 1\n   HAVE_REWIND              := 1\n   HAVE_AUDIOMIXER          := 1\n   HAVE_RWAV                := 1\n   HAVE_RPNG                := 1\n   HAVE_RJPEG               := 1\n   HAVE_RBMP                := 1\n   HAVE_RTGA                := 1\n   HAVE_ZLIB                := 1\n   HAVE_7ZIP                := 1\n   HAVE_NETWORKING          := 1\n   HAVE_IFINFO              := 1\n   HAVE_NETWORK_CMD         := 1\n   HAVE_NETPLAYDISCOVERY    := 1\n   HAVE_OVERLAY             := 1\n   HAVE_MATERIALUI          := 1\n   HAVE_XMB                 := 1\n   HAVE_STB_FONT            := 1\n   HAVE_THREADS             := 1\n   HAVE_LIBRETRODB          := 1\n   HAVE_COMMAND             := 1\n   HAVE_STDIN_CMD           := 1\n   HAVE_CMD                 := 1\n   HAVE_DYLIB               := 1\n   HAVE_DYNAMIC             := 1\n   HAVE_GRIFFIN_CPP         := 1\n   HAVE_RUNAHEAD            := 1\n   HAVE_DIRECTX             ?= 1\n   HAVE_CONFIGFILE          := 1\n   HAVE_PATCH               := 1\n   HAVE_CHEATS              := 1\n   HAVE_CORE_INFO_CACHE     := 1\n\n   EXT_TARGET := $(TARGET_NAME).exe\n   EXT_INTER_TARGET := $(TARGET_NAME).exe\n   CC = cl.exe\n   CXX = cl.exe\n   LD = link.exe\n\n   PLATCFLAGS += -D_WIN32 -D__STDC_CONSTANT_MACROS -D_MBCS\n   PLATCFLAGS += -D__i686__ -D__MMX__ -D__SSE__ -D_CRT_NONSTDC_NO_WARNINGS -D_CRT_SECURE_NO_WARNINGS -D_WINDOWS -DHAVE_CC_RESAMPLER -DHAVE_GL_SYNC -DHAVE_GLSL -DHAVE_IMAGEVIEWER -DHAVE_LANGEXTRA -DHAVE_OPENGL -DHAVE_SHADERPIPELINE -DHAVE_ONLINE_UPDATER -DHAVE_UPDATE_ASSETS -DHAVE_UPDATE_CORES \n   PLATCFLAGS += -DHAVE_UPDATE_CORE_INFO\n   PLATCFLAGS += -DWIN32 -DHAVE_CDROM\n   LDFLAGS    += shell32.lib user32.lib gdi32.lib comdlg32.lib winmm.lib ole32.lib iphlpapi.lib\n\n   PlatformSuffix = $(subst windows_msvc2013_,,$(platform))\n\n   ifneq (,$(findstring x64,$(PlatformSuffix)))\n      ifeq ($(HOST_ARCH),x86)\n         # cross-compile for x64 from x86 host\n         PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS120COMNTOOLS)../../VC/bin/x86_amd64\"):$(PATH)\n      else\n         PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS120COMNTOOLS)../../VC/bin/amd64\"):$(PATH)\n      endif\n\n      LIB := $(shell IFS=$$'\\n'; cygpath -w \"$(VS120COMNTOOLS)../../VC/lib/amd64\")\n      WinArch = x64\n      PlatLib = Lib\\winv6.3\\um\\x64\n   else ifneq (,$(findstring arm,$(PlatformSuffix)))\n      PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS120COMNTOOLS)../../VC/bin/x86_arm\"):$(PATH)\n      LIB := $(shell IFS=$$'\\n'; cygpath -w \"$(VS120COMNTOOLS)../../VC/lib/arm\")\n      HAVE_DIRECTX = 0\n      PlatLib = Lib\\winv6.3\\um\\arm\n   else\n      PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS120COMNTOOLS)../../VC/bin\"):$(PATH)\n      LIB := $(shell IFS=$$'\\n'; cygpath -w \"$(VS120COMNTOOLS)../../VC/lib\")\n      WinArch = x86\n      PlatLib = Lib\\winv6.3\\um\\x86\n   endif\n\n   PATH := $(PATH):$(shell IFS=$$'\\n'; cygpath \"$(VS120COMNTOOLS)../IDE\")\n   INCLUDE := $(shell IFS=$$'\\n'; cygpath -w \"$(VS120COMNTOOLS)../../VC/include\")\n\n   WindowsSdkDir ?= $(shell reg query \"HKLM\\SOFTWARE\\Microsoft\\Windows Kits\\Installed Roots\" -v \"KitsRoot81\" | grep -io '[A-Z]:\\\\.*')\n   WindowsSdkDir := $(WindowsSdkDir:\\=)\n\n   ifeq ($(HAVE_DIRECTX), 1)\n      PLATCFLAGS += -DHAVE_DINPUT -DHAVE_DSOUND -DHAVE_D3D -DHAVE_D3D9 -DHAVE_XAUDIO -DHAVE_XINPUT\n      DXSDK_DIR := $(DXSDK_DIR:\\=)\n      export INCLUDE := $(INCLUDE);$(WindowsSdkDir)\\Include\\um;$(WindowsSdkDir)\\Include\\shared;$(DXSDK_DIR)\\Include;libretro-common\\include;libretro-common\\include\\compat\\msvc;gfx\\include;deps;deps\\stb\n      export LIB := $(LIB);$(WindowsSdkDir)\\$(PlatLib);$(DXSDK_DIR)\\Lib\\$(WinArch)\n   else\n      export INCLUDE := $(INCLUDE);$(WindowsSdkDir)\\Include\\um;$(WindowsSdkDir)\\Include\\shared;libretro-common\\include;libretro-common\\include\\compat\\msvc;gfx\\include;deps;deps\\stb\n      export LIB := $(LIB);$(WindowsSdkDir)\\$(PlatLib)\n   endif\nelse ifneq (,$(findstring windows_msvc2015,$(platform)))\n   HAVE_GDI                 := 1\n   HAVE_SCREENSHOTS         := 1\n   HAVE_REWIND              := 1\n   HAVE_AUDIOMIXER          := 1\n   HAVE_RWAV                := 1\n   HAVE_RPNG                := 1\n   HAVE_RJPEG               := 1\n   HAVE_RBMP                := 1\n   HAVE_RTGA                := 1\n   HAVE_ZLIB                := 1\n   HAVE_7ZIP                := 1\n   HAVE_NETWORKING          := 1\n   HAVE_IFINFO              := 1\n   HAVE_NETWORK_CMD         := 1\n   HAVE_NETPLAYDISCOVERY    := 1\n   HAVE_OVERLAY             := 1\n   HAVE_MATERIALUI          := 1\n   HAVE_XMB                 := 1\n   HAVE_STB_FONT            := 1\n   HAVE_THREADS             := 1\n   HAVE_LIBRETRODB          := 1\n   HAVE_COMMAND             := 1\n   HAVE_STDIN_CMD           := 1\n   HAVE_CMD                 := 1\n   HAVE_DYLIB               := 1\n   HAVE_DYNAMIC             := 1\n   HAVE_GRIFFIN_CPP         := 1\n   HAVE_RUNAHEAD            := 1\n   HAVE_DIRECTX             ?= 1\n   HAVE_CONFIGFILE          := 1\n   HAVE_PATCH               := 1\n   HAVE_CHEATS              := 1\n   HAVE_CORE_INFO_CACHE     := 1\n\n   EXT_TARGET := $(TARGET_NAME).exe\n   EXT_INTER_TARGET := $(TARGET_NAME).exe\n   CC = cl.exe\n   CXX = cl.exe\n   LD = link.exe\n\n   PLATCFLAGS += -utf-8\n   PLATCFLAGS += -D_WIN32 -D__STDC_CONSTANT_MACROS -D_MBCS\n   PLATCFLAGS += -D__i686__ -D__MMX__ -D__SSE__ -D_CRT_NONSTDC_NO_WARNINGS -D_CRT_SECURE_NO_WARNINGS -D_WINDOWS -DHAVE_CC_RESAMPLER -DHAVE_GL_SYNC -DHAVE_GLSL -DHAVE_IMAGEVIEWER -DHAVE_LANGEXTRA -DHAVE_OPENGL -DHAVE_SHADERPIPELINE -DHAVE_ONLINE_UPDATER -DHAVE_UPDATE_ASSETS -DHAVE_UPDATE_CORES \n   PLATCFLAGS += -DHAVE_UPDATE_CORE_INFO\n   PLATCFLAGS += -DWIN32 -DHAVE_CDROM\n   LDFLAGS += shell32.lib user32.lib gdi32.lib comdlg32.lib winmm.lib ole32.lib iphlpapi.lib\n\n   PlatformSuffix = $(subst windows_msvc2015_,,$(platform))\n\n   ifneq (,$(findstring x64,$(PlatformSuffix)))\n      ifeq ($(HOST_ARCH),x86)\n         # cross-compile for x64 from x86 host\n         PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS140COMNTOOLS)../../VC/bin/x86_amd64\"):$(PATH)\n      else\n         PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS140COMNTOOLS)../../VC/bin/amd64\"):$(PATH)\n      endif\n\n      LIB := $(shell IFS=$$'\\n'; cygpath -w \"$(VS140COMNTOOLS)../../VC/lib/amd64\")\n      WinArch = x64\n      PlatLib = um\\x64\n      VCLib = amd64\n   else ifneq (,$(findstring arm,$(PlatformSuffix)))\n      PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS140COMNTOOLS)../../VC/bin/x86_arm\"):$(PATH)\n      LIB := $(shell IFS=$$'\\n'; cygpath -w \"$(VS140COMNTOOLS)../../VC/lib/arm\")\n      HAVE_DIRECTX = 0\n      WinArch = arm\n      PlatLib = um\\arm\n      VCLib = arm\n   else\n      PATH := $(shell IFS=$$'\\n'; cygpath \"$(VS140COMNTOOLS)../../VC/bin\"):$(PATH)\n      LIB := $(shell IFS=$$'\\n'; cygpath -w \"$(VS140COMNTOOLS)../../VC/lib\")\n      WinArch = x86\n      PlatLib = um\\x86\n      VCLib =\n   endif\n\n   PATH := $(PATH):$(shell IFS=$$'\\n'; cygpath \"$(VS140COMNTOOLS)../IDE\")\n   INCLUDE := $(shell IFS=$$'\\n'; cygpath -w \"$(VS140COMNTOOLS)../../VC/include\")\n\n   reg_query = $(call filter_out2,$(subst $2,,$(shell reg query \"$2\" -v \"$1\" 2>nul)))\n   fix_path = $(subst $(SPACE),\\ ,$(subst \\,/,$1))\n   WindowsSdkDir ?= $(call reg_query,InstallationFolder,HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Microsoft SDKs\\Windows\\v10.0)\n   WindowsSdkDir ?= $(call reg_query,InstallationFolder,HKEY_CURRENT_USER\\SOFTWARE\\Wow6432Node\\Microsoft\\Microsoft SDKs\\Windows\\v10.0)\n   WindowsSdkDir ?= $(call reg_query,InstallationFolder,HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v10.0)\n   WindowsSdkDir ?= $(call reg_query,InstallationFolder,HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\v10.0)\n   WindowsSdkDir := $(WindowsSdkDir)\n\n   WindowsSDKVersion ?= $(firstword $(foreach folder,$(subst $(subst \\,/,$(WindowsSdkDir)Include/),,$(wildcard $(call fix_path,$(WindowsSdkDir)Include\\*))),$(if $(wildcard $(call fix_path,$(WindowsSdkDir)Include/$(folder)/um/Windows.h)),$(folder),)))$(BACKSLASH)\n   WindowsSDKVersion := $(WindowsSDKVersion)\n\n   export INCLUDE := $(INCLUDE);$(VCINSTALLDIR)INCLUDE;$(VCINSTALLDIR)ATLMFC\\INCLUDE;$(WindowsSdkDir)include\\$(WindowsSDKVersion)ucrt;$(WindowsSdkDir)include\\$(WindowsSDKVersion)shared;$(WindowsSdkDir)include\\$(WindowsSDKVersion)um\n   export LIB := $(LIB);$(VCINSTALLDIR)LIB$(VCLib);$(VCINSTALLDIR)ATLMFC\\LIB$(VCLib);$(WindowsSdkDir)lib\\$(WindowsSDKVersion)ucrt\\$(WinArch);$(WindowsSdkDir)lib\\$(WindowsSDKVersion)$(PlatLib)\n\n   ifeq ($(HAVE_DIRECTX), 1)\n      PLATCFLAGS += -DHAVE_DINPUT -DHAVE_DSOUND -DHAVE_D3D -DHAVE_D3D9 -DHAVE_XAUDIO -DHAVE_XINPUT\n      DXSDK_DIR := $(DXSDK_DIR:\\=)\n      export INCLUDE := $(INCLUDE);$(DXSDK_DIR)\\Include;libretro-common\\include;libretro-common\\include\\compat\\msvc;gfx\\include;deps;deps\\stb\n      export LIB := $(LIB);$(DXSDK_DIR)\\Lib\\$(WinArch)\n   else\n      export INCLUDE := $(INCLUDE);libretro-common\\include;libretro-common\\include\\compat\\msvc;gfx\\include;deps;deps\\stb\n      export LIB := $(LIB)\n   endif\nelse ifeq (qnx,$(platform))\n   HAVE_SCREENSHOTS         := 1\n   HAVE_REWIND              := 1\n   HAVE_AUDIOMIXER          := 1\n   HAVE_RWAV                := 1\n   HAVE_RPNG                := 1\n   HAVE_RJPEG               := 1\n   HAVE_RBMP                := 1\n   HAVE_RTGA                := 1\n   HAVE_ZLIB                := 1\n   HAVE_7ZIP                := 1\n   HAVE_NETWORKING          := 1\n   HAVE_IFINFO              := 1\n   HAVE_NETWORK_CMD         := 1\n   HAVE_NETPLAYDISCOVERY    := 1\n   HAVE_OVERLAY             := 1\n   HAVE_MATERIALUI          := 1\n   HAVE_XMB                 := 1\n   HAVE_STB_FONT            := 1\n   HAVE_THREADS             := 1\n   HAVE_LIBRETRODB          := 1\n   HAVE_COMMAND             := 1\n   HAVE_STDIN_CMD           := 1\n   HAVE_CMD                 := 1\n   HAVE_DYLIB               := 1\n   HAVE_DYNAMIC             := 1\n   HAVE_GRIFFIN_CPP         := 0\n   WANT_GLSLANG             := 0\n   HAVE_CONFIGFILE          := 1\n   HAVE_PATCH               := 1\n   HAVE_CHEATS              := 1\n   HAVE_CORE_INFO_CACHE     := 1\n\n   CC=qcc -Vgcc_ntoarmv7le\n   CXX=QCC -Vgcc_ntoarmv7le\n\n   ifeq ($(DEBUG), 1)\n      LDFLAGS += -g\n   endif\n\n   PLATCFLAGS += -DHAVE_SHADERPIPELINE -DHAVE_OPENGL -DHAVE_OPENGLES -DHAVE_OPENGLES2 -DHAVE_OZONE -DHAVE_CC_RESAMPLER -DHAVE_CHEEVOS -DRC_DISABLE_LUA -DHAVE_GL_SYNC -DHAVE_GLSLANG -DHAVE_BUILTINGLSLANG -DHAVE_IMAGEVIEWER -DHAVE_LANGEXTRA -DHAVE_RUNAHEAD -DHAVE_GFX_WIDGETS -DHAVE_CONFIGFILE -DHAVE_PATCH -DHAVE_SPIRV_CROSS -DHAVE_STB_FONT -DHAVE_ONLINE_UPDATER -DHAVE_UPDATE_ASSETS -DHAVE_UPDATE_CORES \n   PLATCFLAGS += -DHAVE_UPDATE_CORE_INFO\n   PLATCFLAGS += -DHAVE_XMB -DRARCH_INTERNAL -DWANT_GLSLANG -DHAVE_XCB -DHAVE_EGL -DHAVE_BB10 -DHAVE_GLSL -DHAVE_AL -DHAVE_BSV_MOVIE -DRARCH_MOBILE\n   EXT_TARGET := $(TARGET_NAME)\n   EXT_INTER_TARGET := $(TARGET_NAME)\n   INCLUDE += -Ilibretro-common/include -Igfx/include -Ideps -Ideps/stb -Ideps/rcheevos/include -Ideps/SPIRV-Cross -Ideps/glslang -I.\n   LIBS += -lEGL -lbps -lscreen -lsocket -lm -lGLESv2 -lOpenAL\nelse ifneq (,$(findstring unix,$(platform)))\n   HAVE_SCREENSHOTS         := 1\n   HAVE_REWIND              := 1\n   HAVE_AUDIOMIXER          := 1\n   HAVE_RWAV                := 1\n   HAVE_RPNG                := 1\n   HAVE_RJPEG               := 1\n   HAVE_RBMP                := 1\n   HAVE_RTGA                := 1\n   HAVE_ZLIB                := 1\n   HAVE_7ZIP                := 1\n   HAVE_NETWORKING          := 1\n   HAVE_IFINFO              := 1\n   HAVE_NETWORK_CMD         := 1\n   HAVE_NETPLAYDISCOVERY    := 1\n   HAVE_OVERLAY             := 1\n   HAVE_MATERIALUI          := 1\n   HAVE_XMB                 := 1\n   HAVE_STB_FONT            := 1\n   HAVE_THREADS             := 1\n   HAVE_LIBRETRODB          := 1\n   HAVE_COMMAND             := 1\n   HAVE_STDIN_CMD           := 1\n   HAVE_CMD                 := 1\n   HAVE_DYLIB               := 1\n   HAVE_DYNAMIC             := 1\n   HAVE_GRIFFIN_CPP         := 1\n   WANT_GLSLANG             := 1\n   HAVE_CONFIGFILE          := 1\n   HAVE_PATCH               := 1\n   HAVE_CHEATS              := 1\n   HAVE_CORE_INFO_CACHE     := 1\n\n   PLATCFLAGS += -D__MMX__ -D__SSE__ -DHAVE_OPENGL -DHAVE_OPENGL1 -DHAVE_GLSL -DHAVE_SHADERPIPELINE -DHAVE_OZONE -DHAVE_CC_RESAMPLER -DHAVE_CHEEVOS -DRC_DISABLE_LUA -DHAVE_GL_SYNC -DHAVE_SLANG -DHAVE_GLSLANG -DHAVE_BUILTINGLSLANG -DHAVE_IMAGEVIEWER -DHAVE_LANGEXTRA -DHAVE_RUNAHEAD -DHAVE_GFX_WIDGETS -DHAVE_CONFIGFILE -DHAVE_PATCH -DHAVE_SPIRV_CROSS -DHAVE_STB_FONT -DHAVE_ONLINE_UPDATER -DHAVE_UPDATE_ASSETS -DHAVE_UPDATE_CORES \n   PLATCFLAGS += -DHAVE_UPDATE_CORE_INFO\n   PLATCFLAGS += -DHAVE_VULKAN -DHAVE_XMB -DRARCH_INTERNAL -DWANT_GLSLANG -DHAVE_X11 -DHAVE_XCB -DHAVE_UDEV -DHAVE_BSV_MOVIE -DHAVE_PULSE\n   EXT_TARGET := $(TARGET_NAME)\n   EXT_INTER_TARGET := $(TARGET_NAME)\n   INCLUDE += -Ilibretro-common/include -Igfx/include -Ideps -Ideps/stb -Ideps/rcheevos/include -Ideps/SPIRV-Cross -Ideps/glslang -I.\n   LIBS += -ldl -lm -lpthread -lGL -ludev -lpulse -lX11 -lX11-xcb -lXxf86vm\nendif\n\nifneq (,$(findstring msvc,$(platform)))\n   CFLAGS += -W3 $(MACHDEP) $(PLATCFLAGS)\nelse\n   CFLAGS += -Wall -std=gnu99 $(MACHDEP) $(PLATCFLAGS) $(INCLUDE)\n   INCLUDE += -I./libretro-common/include \\\n\t\t\t\t  -Ideps \\\n\t\t\t\t  -Ideps/stb\nendif\n\nOBJ = griffin/griffin.o  $(PLATOBJS)\n\nifeq ($(HAVE_GRIFFIN_CPP), 1)\n   OBJ += griffin/griffin_cpp.o\nendif\n\nifeq ($(WANT_GLSLANG), 1)\n\tOBJ += griffin/griffin_glslang.o\nendif\n\nifeq ($(HAVE_LOGGER), 1)\n   CFLAGS      += -DHAVE_LOGGER\n   CFLAGS      += -DPC_DEVELOPMENT_IP_ADDRESS=\\\"$(PC_DEVELOPMENT_IP_ADDRESS)\\\" -DPC_DEVELOPMENT_UDP_PORT=$(PC_DEVELOPMENT_UDP_PORT)\nendif\n\nifeq ($(platform), wii)\n   CFLAGS      += -DHAVE_SOCKET_LEGACY\nendif\n\nifeq ($(platform), vita)\n   CFLAGS      += -DHAVE_SOCKET_LEGACY\nendif\n\nifeq ($(HAVE_KERNEL_PRX), 1)\n   CFLAGS      += -DHAVE_KERNEL_PRX\nendif\n\nifeq ($(HAVE_WIIUSB_HID), 1)\n   CFLAGS      += -DHAVE_WIIUSB_HID -DHAVE_HID\nendif\n\nifeq ($(HAVE_VITA2D), 1)\n   CFLAGS      += -DHAVE_VITA2D\nendif\n\nifeq ($(HAVE_LIBRETRODB), 1)\n   CFLAGS      += -DHAVE_LIBRETRODB\nendif\n\nifeq ($(BIG_STACK),1)\n   CFLAGS      += -DBIG_STACK\nendif\n\nifeq ($(HAVE_RJPEG), 1)\n   CFLAGS      += -DHAVE_RJPEG\nendif\n\nifeq ($(HAVE_FILE_LOGGER), 1)\n   CFLAGS      += -DHAVE_FILE_LOGGER\nendif\n\nifeq ($(HAVE_RARCH_EXEC), 1)\n   CFLAGS      += -DHAVE_RARCH_EXEC\nendif\n\nifeq ($(HAVE_ZLIB), 1)\n   CFLAGS      += -DHAVE_ZLIB\n   CFLAGS      += -I./libretro-common/include/compat/zlib\nendif\n\nifeq ($(HAVE_RPNG), 1)\n   CFLAGS      += -DHAVE_RPNG\nendif\n\nifeq ($(HAVE_RBMP), 1)\n   CFLAGS      += -DHAVE_RBMP\nendif\n\nifeq ($(HAVE_RTGA), 1)\n   CFLAGS      += -DHAVE_RTGA\nendif\n\nifeq ($(HAVE_IMAGEVIEWER), 1)\n   CFLAGS      += -DHAVE_IMAGEVIEWER\nendif\n\nifeq ($(HAVE_BSV_MOVIE), 1)\n   CFLAGS      += -DHAVE_BSV_MOVIE\nendif\n\nifeq ($(HAVE_RUNAHEAD), 1)\n   CFLAGS      += -DHAVE_RUNAHEAD\nendif\n\nifeq ($(HAVE_7ZIP), 1)\n   CFLAGS      += -DHAVE_7ZIP -D_7ZIP_ST\nendif\n\nifeq ($(HAVE_SCREENSHOTS), 1)\n\tCFLAGS      += -DHAVE_SCREENSHOTS\nendif\n\nifeq ($(HAVE_REWIND), 1)\n\tCFLAGS      += -DHAVE_REWIND\nendif\n\nifeq ($(HAVE_AUDIOMIXER), 1)\n   CFLAGS      += -DHAVE_AUDIOMIXER\nendif\n\nifeq ($(HAVE_RWAV), 1)\n   CFLAGS      += -DHAVE_RWAV\nendif\n\nifeq ($(HAVE_OVERLAY), 1)\n   CFLAGS      += -DHAVE_OVERLAY\nendif\n\nifeq ($(HAVE_NETWORKING), 1)\n   CFLAGS      += -DHAVE_NETWORKING\nendif\n\nifeq ($(HAVE_IFINFO), 1)\n   CFLAGS      += -DHAVE_IFINFO\nendif\n\nifeq ($(HAVE_NETPLAYDISCOVERY), 1)\n   CFLAGS      += -DHAVE_NETPLAYDISCOVERY\nendif\n\nifeq ($(RARCH_CONSOLE), 1)\n   CFLAGS += -DRARCH_CONSOLE\nendif\n\nifeq ($(HAVE_CORE_INFO_CACHE), 1)\n   CFLAGS += -DHAVE_CORE_INFO_CACHE\nendif\n\nifeq ($(RARCH_MOBILE), 1)\n   CFLAGS += -DRARCH_MOBILE\nendif\n\nifneq (,$(findstring msvc,$(platform)))\n   CFLAGS += -DHAVE_RGUI -DHAVE_MENU -DHAVE_GRIFFIN=1 -DRARCH_INTERNAL\nelse\n   CFLAGS += -std=gnu99 -DHAVE_RGUI -DHAVE_MENU -DHAVE_GRIFFIN=1 -Wno-char-subscripts -DRARCH_INTERNAL\nendif\n\nifeq ($(HAVE_MATERIALUI), 1)\n   CFLAGS += -DHAVE_MATERIALUI\nendif\n\nifeq ($(HAVE_XMB), 1)\n   CFLAGS += -DHAVE_XMB\nendif\n\nifeq ($(HAVE_STB_FONT), 1)\n   CFLAGS += -DHAVE_STB_FONT\nendif\n\nifeq ($(HAVE_LANGEXTRA), 1)\n   CFLAGS += -DHAVE_LANGEXTRA\nendif\n\nifeq ($(HAVE_DSP_FILTER), 1)\n   CFLAGS += -DHAVE_DSP_FILTER\nendif\n\nifeq ($(HAVE_VIDEO_FILTER), 1)\n   CFLAGS += -DHAVE_VIDEO_FILTER\nendif\n\nifeq ($(HAVE_FILTERS_BUILTIN), 1)\n   CFLAGS += -DHAVE_FILTERS_BUILTIN\nendif\n\nifeq ($(HAVE_WINDOW_OFFSET), 1)\n   CFLAGS += -DHAVE_WINDOW_OFFSET\nendif\n\nifeq ($(HAVE_THREADS), 1)\n   CFLAGS += -DHAVE_THREADS\n\n   ifeq ($(platform), psp1)\n      LIBS += -lpthread-psp\n   endif\n\n   ifeq ($(platform), vita)\n      LIBS += -lpthread\n   endif\nendif\n\nifeq ($(HAVE_CONFIGFILE), 1)\n   CFLAGS += -DHAVE_CONFIGFILE\nendif\n\nifeq ($(HAVE_PATCH), 1)\n   CFLAGS += -DHAVE_PATCH\nendif\n\nifeq ($(HAVE_CHEATS), 1)\n\tCFLAGS += -DHAVE_CHEATS\nendif\n\nifeq ($(HAVE_RSOUND), 1)\n   CFLAGS += -DHAVE_RSOUND\nendif\n\nifeq ($(HAVE_GETOPT_LONG), 1)\n   CFLAGS += -DHAVE_GETOPT_LONG=1\nendif\n\nifeq ($(HAVE_DYLIB), 1)\n   CFLAGS += -DHAVE_DYLIB\nendif\n\nifeq ($(HAVE_NETWORK_CMD), 1)\n   CFLAGS += -DHAVE_NETWORK_CMD\nendif\n\nifeq ($(HAVE_COMMAND), 1)\n   CFLAGS += -DHAVE_COMMAND\nendif\n\nifeq ($(HAVE_STDIN_CMD), 1)\n   CFLAGS += -DHAVE_STDIN_CMD\nendif\n\nifeq ($(HAVE_DYNAMIC), 1)\n   CFLAGS += -DHAVE_DYNAMIC\nendif\n\nifeq ($(DEBUG), 1)\n   ifneq (,$(findstring msvc,$(platform)))\n      ifeq ($(platform), windows_msvc2003_x86)\n         CFLAGS += -Wp64\n      endif\n\n      CFLAGS += -Od -Zi -D_DEBUG -MTd\n      LDFLAGS += -DEBUG\n   else\n      CFLAGS += -O0 -g -DDEBUG\n   endif\nelse ifeq ($(platform), psp1)\n   CFLAGS += -O2\nelse ifeq ($(platform), vita)\n   CFLAGS += -O3\nelse ifneq (,$(findstring msvc,$(platform)))\n   ifeq ($(platform), windows_msvc2003_x86)\n      CFLAGS += -Wp64\n      LDFLAGS += -SUBSYSTEM:WINDOWS -ENTRY:mainCRTStartup\n   endif\n\n   CFLAGS += -O2 -DNDEBUG -MT\nelse\n   CFLAGS += -O3\nendif\n\nifneq (,$(findstring msvc,$(platform)))\n\tOBJOUT = -Fo\n\tLINKOUT = -out:\n\tLINK = link.exe\nelse\n\tOBJOUT   = -o\n\tLINKOUT  = -o\n\tLINK = $(CXX)\nendif\n\nall: $(EXT_TARGET)\n\n%.dol: %.elf\n\t$(ELF2DOL) $< $@\n\n%.velf: %.elf\nifneq ($(DEBUG), 1)\n\tarm-vita-eabi-strip -g $<\nendif\n\tvita-elf-create $< $@\n\tvita-make-fself -c -s $@ eboot.bin\n\n%.elf32: %.elf\nifeq ($(platform), xenon360)\n\t$(OBJCOPY) -O elf32-powerpc --adjust-vma 0x80000000 $< $@\nendif\n\n%.prx: %.elf\nifeq ($(platform),psp1)\n\tpsp-prxgen $< $@\nendif\n\n$(EXT_INTER_TARGET): $(OBJ)\n\t$(LINK) $(LINKOUT)$@ $(LDFLAGS) $(LIBDIRS) $(OBJ) $(PLATEXTRA) $(LIBS)\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $(OBJOUT)$@ $<\n\n%.o: %.cpp\n\t$(CXX) $(CFLAGS) -c $(OBJOUT)$@ $<\n\n%.o: %.S\n\t$(CC) $(CFLAGS) -c $(OBJOUT)$@ $<\n\n%.bmpobj: %.bmp\n\t$(LD) -r -b binary $(OBJOUT)$@ $<\n\n%.binobj: %.bin\n\t$(LD) -r -b binary $(OBJOUT)$@ $<\n\n$(APP_BOOTER_DIR)/app_booter.bin:\n\t$(MAKE) -C $(APP_BOOTER_DIR)\n\npkg: all\nifeq ($(platform), qnx)\n\tmkdir -p pkg/qnx/pkg\n\tcp -r $(EXT_TARGET) pkg/qnx/pkg/RetroArch\n\tcp -r media/canvas.png pkg/qnx/pkg/canvas.png\n\tcp -r media/retroarch-96x96.png pkg/qnx/pkg/retroarch-96x96.png\nelse ifeq ($(platform), wii)\n\tcp -r $(EXT_TARGET) pkg/wii/CORE.dol\nelse ifeq ($(platform), ngc)\n\tcp -r $(EXT_TARGET) pkg/ngc/CORE.dol\nelse ifeq ($(platform), psp1)\n\tpsp-fixup-imports$(EXT) $(EXT_TARGET)\nendif\n\nifeq ($(platform), qnx)\nretroarch-dev.bar: pkg\nifeq ($(QNX_DEBUGTOKEN),)\n\tblackberry-nativepackager -package $@ -devMode pkg/qnx/bar-descriptor.xml -C  pkg/qnx/pkg pkg/qnx/pkg/*\nelse\n\tblackberry-nativepackager -package $@ -devMode -debugToken $(QNX_DEBUGTOKEN) pkg/qnx/bar-descriptor.xml -C  pkg/qnx/pkg pkg/qnx/pkg/*\nendif\n\nretroarch-release.bar: pkg\n\tblackberry-nativepackager -package $@ pkg/qnx/bar-descriptor.xml -C  pkg/qnx/pkg pkg/qnx/pkg/*\nendif\n\nshaders-checkout:\n\t@if test -d $(SHADER_CG_DIR); then \\\n      echo \"[SHADER CHECKOUT::] Git pulling common-shaders...\"; \\\n      cd $(SHADER_CG_DIR); \\\n      $(GIT) pull; \\\n      cd ../../../../..; \\\n   else \\\n   echo \"[SHADER CHECKOUT::] Git cloning common-shaders first...\"; \\\n      $(GIT) clone git://github.com/libretro/common-shaders.git $(SHADER_CG_DIR); \\\n   fi\n\nshaders-deploy:\nifeq ($(platform), ps3)\n\t@if test -d $(MEDIA_SHADER_DIR); then \\\n      cp -r $(SHADER_CG_DIR)/* $(MEDIA_SHADER_DIR); \\\n   else \\\n   echo \"[DEPLOY PS3::] Creating PS3 shader directory first...\"; \\\n      mkdir -p $(MEDIA_SHADER_DIR) || bin/true; \\\n   fi\n   @echo \"[DEPLOY PS3::] Copied shaders to PS3 shaders directory.\"\nelse ifeq ($(platform), ps3-cobra)\n\t@if test -d $(MEDIA_SHADER_DIR); then \\\n      cp -r $(SHADER_CG_DIR)/* $(MEDIA_SHADER_DIR); \\\n   else \\\n   echo \"[DEPLOY PS3::] Creating PS3 shader directory first...\"; \\\n      mkdir -p $(MEDIA_SHADER_DIR) || bin/true; \\\n   fi\n   @echo \"[DEPLOY PS3::] Copied shaders to PS3 shaders directory.\"\nendif\n\nshaders-convert-glsl:\n\t$(PYTHON3) tools/cg2glsl.py $(SHADER_CG_DIR) $(SHADER_GLSL_DIR)\n\noverlays-checkout:\n\t@if test -d $(OVERLAY_DIR); then \\\n      echo \"[OVERLAY CHECKOUT::] Git pulling common-overlays...\"; \\\n      cd $(OVERLAY_DIR); \\\n      $(GIT) pull; \\\n      cd ../../../../..; \\\n   else \\\n   echo \"[OVERLAY CHECKOUT::] Git cloning common-overlays first...\"; \\\n      $(GIT) clone git://github.com/libretro/common-overlays.git $(OVERLAY_DIR); \\\n   fi\n\nclean:\n\trm -f $(EXT_TARGET)\n\trm -f $(EXT_INTER_TARGET)\n\trm -f $(OBJ)\nifeq ($(platform), wii)\n\t$(MAKE) -C $(APP_BOOTER_DIR) clean\nendif\n\n.PHONY: clean\n\nprint-%:\n\t@echo '$*=$($*)'\n"
        },
        {
          "name": "Makefile.lfx000",
          "type": "blob",
          "size": 6.6591796875,
          "content": "#########################\n## Toolchain variables ##\n#########################\n\n# Default toolchain directory\nTOOLCHAIN_DIR=\"$(HOST_DIR)\"\n\n# All toolchain-related variables may be\n# overridden via the command line\n\nifdef GCW0_CC\nCC                    = $(GCW0_CC)\nelse\nCC                    = $(TOOLCHAIN_DIR)/usr/bin/arm-linux-gcc\nendif\n\nifdef GCW0_CXX\nCXX                   = $(GCW0_CXX)\nelse\nCXX                   = $(TOOLCHAIN_DIR)/usr/bin/arm-linux-g++\nendif\n\nifdef GCW0_STRIP\nSTRIP                 = $(GCW0_STRIP)\nelse\nSTRIP                 = $(TOOLCHAIN_DIR)/usr/bin/arm-linux-strip\nendif\n\nGCW0_SDL_CONFIG      ?= $(TOOLCHAIN_DIR)/usr/arm-buildroot-linux-gnueabi/sysroot/usr/bin/sdl-config\nGCW0_FREETYPE_CONFIG ?= $(TOOLCHAIN_DIR)/usr/arm-buildroot-linux-gnueabi/sysroot/usr/bin/freetype-config\n\nGCW0_INC_DIR         ?= $(TOOLCHAIN_DIR)/usr/arm-buildroot-linux-gnueabi/sysroot/usr/include\nGCW0_LIB_DIR         ?= $(TOOLCHAIN_DIR)/usr/arm-buildroot-linux-gnueabi/sysroot/usr/lib\n\n#########################\n#########################\n\nPACKAGE_NAME = retroarch\n\nDEBUG ?= 0\n\nMIYOO = 1\nDINGUX = 1\nHAVE_SCREENSHOTS = 1\nHAVE_REWIND = 1\nHAVE_7ZIP = 1\nHAVE_AL = 0\nHAVE_ALSA = 1\nHAVE_DSP_FILTER = 1\nHAVE_VIDEO_FILTER = 1\nHAVE_STATIC_VIDEO_FILTERS = 1\nHAVE_STATIC_AUDIO_FILTERS = 1\nHAVE_FILTERS_BUILTIN\t= 1\nHAVE_BUILTINMBEDTLS = 0\nHAVE_BUILTINZLIB = 1\nHAVE_C99 = 1\nHAVE_CC = 1\nHAVE_CC_RESAMPLER = 1\nHAVE_CHD = 1\nHAVE_COMMAND = 0\nHAVE_CXX = 1\nHAVE_DR_MP3 = 1\nHAVE_DYNAMIC = 1\nHAVE_EGL = 0\nHAVE_FREETYPE = 0\nHAVE_GDI = 1\nHAVE_GETADDRINFO = 0\nHAVE_GETOPT_LONG = 1\nHAVE_GLSL = 0\nHAVE_HID = 0\nHAVE_IBXM = 1\nHAVE_IMAGEVIEWER = 0\nHAVE_LANGEXTRA = 0\nHAVE_LIBRETRODB = 1\nHAVE_MENU = 1\nHAVE_MENU_COMMON = 1\nHAVE_GFX_WIDGETS = 0\nHAVE_MMAP = 1\nHAVE_OPENDINGUX_FBDEV = 0\nHAVE_OPENGL = 0\nHAVE_OPENGL1 = 0\nHAVE_OPENGLES = 0\nHAVE_OPENGLES3 = 0\nHAVE_OPENGL_CORE = 0\nHAVE_OPENSSL = 0\nHAVE_OVERLAY = 0\nHAVE_RBMP = 1\nHAVE_RJPEG = 1\nHAVE_RPILED = 0\nHAVE_RPNG = 1\nHAVE_RUNAHEAD = 0\nHAVE_SDL_DINGUX = 1\nHAVE_SHADERPIPELINE = 0\nHAVE_STB_FONT = 0\nHAVE_STB_IMAGE = 0\nHAVE_STB_VORBIS = 0\nHAVE_STDIN_CMD = 0\nHAVE_STRCASESTR = 1\nHAVE_THREADS = 1\nHAVE_UDEV = 0\nHAVE_RGUI = 1\nHAVE_MATERIALUI = 0\nHAVE_XMB = 0\nHAVE_OZONE = 0\nHAVE_ZLIB = 1\nHAVE_CONFIGFILE = 1\nHAVE_PATCH = 1\nHAVE_CHEATS = 1\nHAVE_CHEEVOS = 0\nHAVE_LIBSHAKE = 0\nHAVE_CORE_INFO_CACHE = 1\n#HAVE_TINYALSA = 1\nHAVE_NEAREST_RESAMPLER = 1\n\nOS = Linux\nTARGET = retroarch\n\nOBJ :=\nLINK := $(CXX)\nDEF_FLAGS := -march=armv5te -mtune=arm926ej-s -ffast-math -fomit-frame-pointer\nDEF_FLAGS += -ffunction-sections -fdata-sections\nDEF_FLAGS += -I. -Ideps -Ideps/stb -DMIYOO=1 -DDINGUX -MMD\nDEF_FLAGS += -Wall -Wno-unused-variable -flto\nDEF_FLAGS += -std=gnu99 -D_GNU_SOURCE\nLIBS := -ldl -lz -lrt -pthread -lasound\nCFLAGS :=\nCXXFLAGS := -fno-exceptions -fno-rtti -std=c++11 -D__STDC_CONSTANT_MACROS\nASFLAGS :=\nLDFLAGS := -Wl,--gc-sections\nINCLUDE_DIRS = -I$(GCW0_INC_DIR)\nLIBRARY_DIRS = -L$(GCW0_LIB_DIR)\nDEFINES := -DRARCH_INTERNAL -D_FILE_OFFSET_BITS=64 -UHAVE_STATIC_DUMMY\nDEFINES += -DHAVE_C99=1 -DHAVE_CXX=1\nDEFINES += -DHAVE_GETOPT_LONG=1 -DHAVE_STRCASESTR=1 -DHAVE_DYNAMIC=1\nDEFINES += -DHAVE_FILTERS_BUILTIN -DHAVE_ALSA\n\nSDL_DINGUX_CFLAGS := $(shell $(GCW0_SDL_CONFIG) --cflags)\nSDL_DINGUX_LIBS := $(shell $(GCW0_SDL_CONFIG) --libs)\nFREETYPE_CFLAGS := $(shell $(GCW0_FREETYPE_CONFIG) --cflags)\nFREETYPE_LIBS := $(shell $(GCW0_FREETYPE_CONFIG) --libs)\nMMAP_LIBS = -lc\n\nOBJDIR_BASE := obj-unix\n\nifeq ($(DEBUG), 1)\n   OBJDIR := $(OBJDIR_BASE)/debug\n   DEF_FLAGS += -O0 -g -DDEBUG -D_DEBUG\nelse\n   OBJDIR := $(OBJDIR_BASE)/release\n   DEF_FLAGS += -O2 -DNDEBUG\nendif\n\ninclude Makefile.common\n\nDEF_FLAGS += $(INCLUDE_DIRS)\nLDFLAGS += $(CFLAGS) $(CXXFLAGS) $(DEF_FLAGS)\nCFLAGS += $(DEF_FLAGS)\nCXXFLAGS += $(DEF_FLAGS)\n\nHEADERS = $(wildcard */*/*.h) $(wildcard */*.h) $(wildcard *.h)\n\nQ := @\n\nRARCH_OBJ := $(addprefix $(OBJDIR)/,$(OBJ))\n\nall: $(TARGET)\n\n-include $(RARCH_OBJ:.o=.d)\n\nSYMBOL_MAP := -Wl,-Map=output.map\n\n$(TARGET): $(RARCH_OBJ)\n\t@$(if $(Q), $(shell echo echo LD $@),)\n\t$(Q)$(LINK) -o $@ $(RARCH_OBJ) $(LIBS) $(LDFLAGS) $(LIBRARY_DIRS)\n\nifeq ($(STRIP_BIN),1)\n\t$(STRIP) --strip-unneeded $(TARGET)\nendif\n\n$(OBJDIR)/%.o: %.c\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CC $<),)\n\t$(Q)$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) -c -o $@ $<\n\n$(OBJDIR)/%.o: %.cpp\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CXX $<),)\n\t$(Q)$(CXX) $(CPPFLAGS) $(CXXFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.m\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo OBJC $<),)\n\t$(Q)$(CXX) $(OBJCFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.S $(HEADERS)\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo AS $<),)\n\t$(Q)$(CC) $(CFLAGS) $(ASFLAGS) $(DEFINES) -c -o $@ $<\n\nclean:\n\trm -rf $(OBJDIR_BASE)\n\trm -f $(TARGET)\n\trm -f *.d\n\ninstall: $(TARGET)\n\tmkdir -p $(DESTDIR)$(BIN_DIR) 2>/dev/null || /bin/true\n\tmkdir -p $(DESTDIR)$(GLOBAL_CONFIG_DIR) 2>/dev/null || /bin/true\n\tmkdir -p $(DESTDIR)$(DATA_DIR)/applications 2>/dev/null || /bin/true\n\tmkdir -p $(DESTDIR)$(DATA_DIR)/metainfo 2>/dev/null || /bin/true\n\tmkdir -p $(DESTDIR)$(DOC_DIR) 2>/dev/null || /bin/true\n\tmkdir -p $(DESTDIR)$(MAN_DIR)/man6 2>/dev/null || /bin/true\n\tmkdir -p $(DESTDIR)$(DATA_DIR)/pixmaps 2>/dev/null || /bin/true\n\tcp $(TARGET) $(DESTDIR)$(BIN_DIR)\n\tcp tools/cg2glsl.py $(DESTDIR)$(BIN_DIR)/retroarch-cg2glsl\n\tcp retroarch.cfg $(DESTDIR)$(GLOBAL_CONFIG_DIR)\n\tcp com.libretro.RetroArch.metainfo.xml $(DESTDIR)$(DATA_DIR)/metainfo\n\tcp com.libretro.RetroArch.desktop $(DESTDIR)$(DATA_DIR)/applications\n\tcp docs/retroarch.6 $(DESTDIR)$(MAN_DIR)/man6\n\tcp docs/retroarch-cg2glsl.6 $(DESTDIR)$(MAN_DIR)/man6\n\tcp media/com.libretro.RetroArch.svg $(DESTDIR)$(DATA_DIR)/pixmaps\n\tcp COPYING $(DESTDIR)$(DOC_DIR)\n\tcp README.md $(DESTDIR)$(DOC_DIR)\n\tchmod 755 $(DESTDIR)$(BIN_DIR)/$(TARGET)\n\tchmod 755 $(DESTDIR)$(BIN_DIR)/retroarch-cg2glsl\n\tchmod 644 $(DESTDIR)$(GLOBAL_CONFIG_DIR)/retroarch.cfg\n\tchmod 644 $(DESTDIR)$(DATA_DIR)/applications/com.libretro.RetroArch.desktop\n\tchmod 644 $(DESTDIR)$(DATA_DIR)/metainfo/com.libretro.RetroArch.metainfo.xml\n\tchmod 644 $(DESTDIR)$(MAN_DIR)/man6/retroarch.6\n\tchmod 644 $(DESTDIR)$(MAN_DIR)/man6/retroarch-cg2glsl.6\n\tchmod 644 $(DESTDIR)$(DATA_DIR)/pixmaps/com.libretro.RetroArch.svg\n\t@if test -d media/assets && test $(HAVE_ASSETS); then \\\n\t\techo \"Installing media assets...\"; \\\n\t\tmkdir -p $(DESTDIR)$(ASSETS_DIR)/assets; \\\n\t\tif test $(HAVE_MATERIALUI) = 1; then \\\n\t\t\tcp -r media/assets/glui/ $(DESTDIR)$(ASSETS_DIR)/assets; \\\n\t\tfi; \\\n\t\tif test $(HAVE_XMB) = 1; then \\\n\t\t\tcp -r media/assets/xmb/ $(DESTDIR)$(ASSETS_DIR)/assets; \\\n\t\tfi; \\\n\t\tif test $(HAVE_OZONE) = 1; then \\\n\t\t\tcp -r media/assets/ozone/ $(DESTDIR)$(ASSETS_DIR)/assets; \\\n\t\tfi; \\\n\t\tcp media/assets/COPYING $(DESTDIR)$(DOC_DIR)/COPYING.assets; \\\n\t\techo \"Asset copying done.\"; \\\n\tfi\n\n.PHONY: all clean\n\nprint-%:\n\t@echo '$*=$($*)'\n"
        },
        {
          "name": "Makefile.libnx",
          "type": "blob",
          "size": 8.6240234375,
          "content": "include version.all\n\n#---------------------------------------------------------------------------------\n.SUFFIXES:\n#---------------------------------------------------------------------------------\n\nifeq ($(strip $(DEVKITPRO)),)\n$(error \"Please set DEVKITPRO in your environment. export DEVKITPRO=<path to>/devkitpro\")\nendif\n\nTOPDIR ?= $(CURDIR)\ninclude $(DEVKITPRO)/libnx/switch_rules\n\nTARGET := retroarch_switch\n\nDEBUG                  ?= 0\nWHOLE_ARCHIVE_LINK      = 0\nGRIFFIN_BUILD           = 0\n\nOBJ :=\n\nDEFINES := -D__SWITCH__=1 -U__linux__ -U__linux -DGLM_FORCE_PURE=1 -DRARCH_CONSOLE -DRARCH_INTERNAL -DGLOBAL_CONFIG_DIR='\"/switch\"' -DHAVE_STB_VORBIS\n\nHAVE_DR_MP3 = 1\nHAVE_TRANSLATE = 1\nHAVE_SCREENSHOTS = 1\nHAVE_REWIND = 1\nHAVE_AUDIOMIXER = 1\nHAVE_CC_RESAMPLER = 1\nHAVE_MENU_COMMON = 1\nHAVE_RTGA = 1\nHAVE_RPNG = 1\nHAVE_RJPEG = 1\nHAVE_RBMP = 1\nHAVE_RWAV = 1\nHAVE_7ZIP = 1\nHAVE_ZLIB = 1\nHAVE_BUILTINZLIB = 1\nHAVE_LIBRETRODB = 1\nHAVE_DSP_FILTER = 1\nHAVE_VIDEO_FILTER = 1\nHAVE_STATIC_VIDEO_FILTERS = 1\nHAVE_STATIC_AUDIO_FILTERS = 1\nHAVE_STATIC_CORES = 1\nHAVE_FILTERS_BUILTIN = 1\nHAVE_MENU = 1\nHAVE_CONFIGFILE = 1\nHAVE_PATCH = 1\nHAVE_CHEATS = 1\nHAVE_RUNAHEAD = 1\nHAVE_NETWORKING = 1\nHAVE_IFINFO = 1\nHAVE_NETPLAYDISCOVERY = 1\nHAVE_STB_FONT = 1\nHAVE_CHEEVOS = 1\nHAVE_CHD = 1\nHAVE_STB_VORBIS = 1\nHAVE_IBXM = 1\nHAVE_CORE_INFO_CACHE = 1\n\n# RetroArch libnx useful flags\nHAVE_THREADS = 1\nHAVE_PTHREADS = 1\nHAVE_FREETYPE = 0\nHAVE_SWITCH = 1\nHAVE_LIBNX = 1\nHAVE_OPENGL = 1\nHAVE_LANGEXTRA = 1\nHAVE_GFX_WIDGETS = 1\n\nifeq ($(HAVE_OPENGL), 1)\n  HAVE_EGL = 1\n  HAVE_SHADERPIPELINE = 1\n  HAVE_RGUI = 1\n  HAVE_MATERIALUI = 1\n  HAVE_XMB = 1\n  HAVE_OZONE = 1\n  HAVE_OVERLAY = 1\n  HAVE_GLSL = 1\nelse\n  HAVE_RGUI = 1\n  HAVE_MATERIALUI = 0\n  HAVE_XMB = 0\n  HAVE_OZONE = 0\nendif\n\ninclude Makefile.common\nBLACKLIST :=\n\nOBJ := $(filter-out $(BLACKLIST),$(OBJ))\n\n#---------------------------------------------------------------------------------\n# TARGET is the name of the output\n# BUILD is the directory where object files & intermediate files will be placed\n# SOURCES is a list of directories containing source code\n# DATA is a list of directories containing data files\n# INCLUDES is a list of directories containing header files\n# EXEFS_SRC is the optional input directory containing data copied into exefs, if anything this normally should only contain \"main.npdm\".\n# ROMFS is the directory containing data to be added to RomFS, relative to the Makefile (Optional)\n#\n# NO_ICON: if set to anything, do not use icon.\n# NO_NACP: if set to anything, no .nacp file is generated.\n# APP_TITLE is the name of the app stored in the .nacp file (Optional)\n# APP_AUTHOR is the author of the app stored in the .nacp file (Optional)\n# APP_VERSION is the version of the app stored in the .nacp file (Optional)\n# APP_TITLEID is the titleID of the app stored in the .nacp file (Optional)\n# ICON is the filename of the icon (.jpg), relative to the project folder.\n#   If not set, it attempts to use one of the following (in this order):\n#     - <Project name>.jpg\n#     - icon.jpg\n#     - <libnx folder>/default_icon.jpg\n#---------------------------------------------------------------------------------\nBUILD := build\nSOURCES := $(CURDIR)/source\nDATA := data\nINCLUDES :=\tinclude\nEXEFS_SRC := exefs_src\n#ROMFS := switch/romfs\n\nAPP_TITLE := RetroArch\nAPP_VERSION := $(RARCH_VERSION)\nAPP_AUTHOR := libretro Team\nAPP_ICON := pkg/libnx/retroarch.jpg\n\n#---------------------------------------------------------------------------------\n# options for code generation\n#---------------------------------------------------------------------------------\nARCH\t:=\t-march=armv8-a -mtune=cortex-a57 -mtp=soft -fPIE -mcpu=cortex-a57+crc+fp+simd\n\nCFLAGS := -g -Wall -O3 -fcommon -ffast-math -ffunction-sections \\\n          $(ARCH) $(DEFINES) $(INCLUDE_DIRS) -I$(LIBNX)/include -I$(PORTLIBS)/include/ -include $(LIBNX)/include/switch.h #$(shell $(PORTLIBS)/bin/freetype-config --cflags)\n\nCFLAGS += $(INCLUDE) -DSWITCH=1 -DHAVE_LIBNX=1 -DNXLINK=1 -DHAVE_SHADERPIPELINE -DHAVE_ONLINE_UPDATER -DHAVE_UPDATE_ASSETS -DHAVE_UPDATE_CORES -DHAVE_UPDATE_CORE_INFO -DHAVE_STB_FONT #-DHAVE_FREETYPE\n\nifeq ($(HAVE_FILTERS_BUILTIN), 1)\n  CFLAGS += -DHAVE_FILTERS_BUILTIN\nendif\n\nifeq ($(strip $(HAVE_STATIC_DUMMY)),1)\n  CFLAGS\t+=\t-DHAVE_STATIC_DUMMY=1\nendif\n\nCXXFLAGS\t:= $(CFLAGS) -fno-rtti -fno-exceptions -std=gnu++11\n\nASFLAGS\t:=\t-g $(ARCH)\nLDFLAGS\t=\t-specs=$(DEVKITPRO)/libnx/switch.specs $(ARCH) -Wl,--allow-multiple-definition -Wl,-Map,$(notdir $*.map)\n\n# add things from Makefile.common\nCFLAGS += $(DEF_FLAGS)\n\nLIBS\t:= -lswresample -lavformat -lavcodec -lavutil -lswscale -lstdc++ -lbz2 -lpng -lz -lnx -lvpx -lopus -llzma -lm\n\nifeq ($(HAVE_OPENGL), 1)\n  LIBS := -lEGL -lglapi -ldrm_nouveau $(LIBS)\nendif\n\n#---------------------------------------------------------------------------------\n# list of directories containing libraries, this must be the top level containing\n# include and lib\n#---------------------------------------------------------------------------------\nLIBDIRS := $(PORTLIBS) $(LIBNX)\n\n#---------------------------------------------------------------------------------\n# no real need to edit anything past this point unless you need to add additional\n# rules for different file extensions\n#---------------------------------------------------------------------------------\nifneq ($(BUILD),$(notdir $(CURDIR)))\n#---------------------------------------------------------------------------------\n\nexport OUTPUT\t:=\t$(TARGET)\nexport TOPDIR\t:=\t$(CURDIR)\n\nexport VPATH\t:=\t$(foreach dir,$(SOURCES),$(CURDIR)/$(dir)) \\\n\t\t\t$(foreach dir,$(DATA),$(CURDIR)/$(dir))\n\nexport DEPSDIR\t:=\t$(CURDIR)/\n\nCFILES\t\t:=\t$(foreach dir,$(SOURCES),$(notdir $(wildcard $(dir)/*.c)))\nCPPFILES\t:=\t$(foreach dir,$(SOURCES),$(notdir $(wildcard $(dir)/*.cpp)))\nSFILES\t\t:=\t$(foreach dir,$(SOURCES),$(notdir $(wildcard $(dir)/*.s)))\nBINFILES\t:=\t$(foreach dir,$(DATA),$(notdir $(wildcard $(dir)/*.*)))\n\n#---------------------------------------------------------------------------------\n# use CXX for linking C++ projects, CC for standard C\n#---------------------------------------------------------------------------------\nifeq ($(strip $(CPPFILES)),)\n#---------------------------------------------------------------------------------\n\texport LD\t:=\t$(CC)\n#---------------------------------------------------------------------------------\nelse\n#---------------------------------------------------------------------------------\n\texport LD\t:=\t$(CXX)\n#---------------------------------------------------------------------------------\nendif\n#---------------------------------------------------------------------------------\n\nexport OFILES \t:=\t$(OBJ)\n\nifeq ($(strip $(HAVE_STATIC_DUMMY)),)\n  OFILES += libretro_libnx.a\nendif\n\nexport HFILES_BIN\t:=\t$(addsuffix .h,$(subst .,_,$(BINFILES)))\n\nexport INCLUDE\t:=\t$(foreach dir,$(INCLUDES),-I$(CURDIR)/$(dir)) \\\n\t\t\t$(foreach dir,$(LIBDIRS),-I$(dir)/include) \\\n\t\t\t-I$(CURDIR)/$(BUILD)\n\nexport LIBPATHS\t:=\t$(foreach dir,$(LIBDIRS),-L$(dir)/lib)\n\nexport BUILD_EXEFS_SRC := $(TOPDIR)/$(EXEFS_SRC)\n\nifeq ($(strip $(ICON)),)\n\ticons := $(wildcard *.jpg)\n\tifneq (,$(findstring $(TARGET).jpg,$(icons)))\n\t\texport APP_ICON := $(TOPDIR)/$(TARGET).jpg\n\telse\n\t\tifneq (,$(findstring icon.jpg,$(icons)))\n\t\t\texport APP_ICON := $(TOPDIR)/icon.jpg\n\t\tendif\n\tendif\nelse\n\texport APP_ICON := $(TOPDIR)/$(ICON)\nendif\n\nifeq ($(strip $(NO_ICON)),)\n\texport NROFLAGS += --icon=$(APP_ICON)\nendif\n\nifeq ($(strip $(NO_NACP)),)\n\texport NROFLAGS += --nacp=$(CURDIR)/$(TARGET).nacp\nendif\n\nifneq ($(APP_TITLEID),)\n\texport NACPFLAGS += --titleid=$(APP_TITLEID)\nendif\n\nifneq ($(ROMFS),)\n\texport NROFLAGS += --romfsdir=$(CURDIR)/$(ROMFS)\nendif\n\nDEPENDS_TMP  := $(OFILES:.o=.d)\nDEPENDS      := $(filter-out libretro_libnx.a,$(DEPENDS_TMP))\n\n.PHONY: clean all\n\n#---------------------------------------------------------------------------------\n# main targets\n#---------------------------------------------------------------------------------\nall\t:\t$(OUTPUT).pfs0 $(OUTPUT).nro\n\n$(OUTPUT).pfs0\t:\t$(OUTPUT).nso\n\n$(OUTPUT).nso\t:\t$(OUTPUT).elf\n\nifeq ($(strip $(NO_NACP)),)\n$(OUTPUT).nro\t:\t$(OUTPUT).elf $(OUTPUT).nacp\nelse\n$(OUTPUT).nro\t:\t$(OUTPUT).elf\nendif\n\n$(OUTPUT).elf\t:\t$(OBJ)\n\nclean:\n\trm -f $(DEPENDS) $(OBJ) $(OUTPUT).pfs0 $(OUTPUT).nro $(OUTPUT).elf\n\n#---------------------------------------------------------------------------------\n# you need a rule like this for each extension you use as binary data\n#---------------------------------------------------------------------------------\n%.bin.o\t%_bin.h :\t%.bin\n#---------------------------------------------------------------------------------\n\t@echo $(notdir $<)\n\t@$(bin2o)\n\n#---------------------------------------------------------------------------------------\nendif\n#---------------------------------------------------------------------------------------\n"
        },
        {
          "name": "Makefile.libogc",
          "type": "blob",
          "size": 10.95703125,
          "content": "#---------------------------------------------------------------------------------\n.SUFFIXES:\n#---------------------------------------------------------------------------------\n\nifeq ($(strip $(DEVKITPRO)),)\n$(error \"Please set DEVKITPRO in your environment. export DEVKITPRO=<path to>devkitPro\")\nendif\n\nifeq ($(strip $(DEVKITPPC)),)\n$(error \"Please set DEVKITPPC in your environment. export DEVKITPPC=<path to>devkitPPC\")\nendif\n\nexport PATH\t:=\t$(DEVKITPPC)/bin:$(PATH)\n\nifeq ($(PLATFORM),)\nPLATFORM=wii\nendif\n\n#---------------------------------------------------------------------------------\n# change shell on Snow Leopard\n#---------------------------------------------------------------------------------\nUNAME_S\t:=\t$(shell uname -s)\nUNAME_R\t:=\t$(shell uname -r)\n\nifneq (,$(findstring Darwin,$(UNAME_S)))\n\tifneq (,$(findstring 10.8.0,$(UNAME_R)))\n\t\texport SHELL=/bin/bash\n\tendif\nendif\n\n#---------------------------------------------------------------------------------\n# path to tools\n#---------------------------------------------------------------------------------\nexport PORTLIBS\t:=\t$(DEVKITPRO)/portlibs/ppc\nexport PATH\t:=\t$(DEVKITPPC)/bin:$(PORTLIBS)/bin:$(PATH)\n\n#---------------------------------------------------------------------------------\n# the prefix on the compiler executables\n#---------------------------------------------------------------------------------\nPREFIX\t:=\tpowerpc-eabi-\n\nexport AS\t:=\t$(PREFIX)as\nexport CC\t:=\t$(PREFIX)gcc\nexport CXX\t:=\t$(PREFIX)g++\nexport AR\t:=\t$(PREFIX)ar\nexport OBJCOPY\t:=\t$(PREFIX)objcopy\n\nISVC=$(or $(VCBUILDHELPER_COMMAND),$(MSBUILDEXTENSIONSPATH32),$(MSBUILDEXTENSIONSPATH))\n\n#---------------------------------------------------------------------------------\n%.a:\n#---------------------------------------------------------------------------------\n\t@rm -f $@\n\t$(AR) -rc $@ $^\n\n#---------------------------------------------------------------------------------\n%.o: %.cpp\n\t$(CXX) $(CXXFLAGS) -c $< -o $@\n\n#---------------------------------------------------------------------------------\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n#---------------------------------------------------------------------------------\n%.o: %.m\n\t$(CC) $(OBJCFLAGS) -c $< -o $@\n\n#---------------------------------------------------------------------------------\n%.o: %.s\n\t$(CC) -x assembler-with-cpp $(ASFLAGS) -c $< -o $@\n\n#---------------------------------------------------------------------------------\n%.o: %.S\n\t$(CC) -x assembler-with-cpp $(ASFLAGS) -c $< -o $@\n\n#---------------------------------------------------------------------------------\n# canned command sequence for binary data\n#---------------------------------------------------------------------------------\ndefine bin2o\n\tbin2s -a 32 $< | $(AS) -o $(@)\n\techo \"extern const u8\" `(echo $(<F) | sed -e 's/^\\([0-9]\\)/_\\1/' | tr . _)`\"_end[];\" > `(echo $(<F) | tr . _)`.h\n\techo \"extern const u8\" `(echo $(<F) | sed -e 's/^\\([0-9]\\)/_\\1/' | tr . _)`\"[];\" >> `(echo $(<F) | tr . _)`.h\n\techo \"extern const u32\" `(echo $(<F) | sed -e 's/^\\([0-9]\\)/_\\1/' | tr . _)`_size\";\" >> `(echo $(<F) | tr . _)`.h\nendef\n\nBUILD\t\t:=\tbuild\n\nBUILD_LITE = 1\nCURDIR   = .\n\nexport BASEDIR\t\t:= $(CURDIR)\nexport DEPSDIR    := $(BASEDIR)/wii/libogc/deps\nexport LWIPDIR\t\t:= $(BASEDIR)/wii/libogc/lwip\nexport OGCDIR\t\t:= $(BASEDIR)/wii/libogc/libogc\nexport DBDIR\t\t:= $(BASEDIR)/wii/libogc/libdb\nexport BTEDIR\t\t:= $(BASEDIR)/wii/libogc/lwbt\nexport WIIUSEDIR\t:= $(BASEDIR)/wii/libogc/wiiuse\nexport LIBWIIKEYB\t:= $(BASEDIR)/wii/libogc/libwiikeyboard\nexport STUBSDIR\t:= $(BASEDIR)/wii/libogc/lockstubs\nexport LIBS\t\t\t:=\t$(BASEDIR)/wii/libogc/libs\n\nexport INCDIR\t\t:=\t$(BASEDIR)/wii/libogc/include\n\nexport LIBDIR\t\t:= $(LIBS)/$(PLATFORM)\n\n#---------------------------------------------------------------------------------\nBBALIB\t\t:= $(LIBDIR)/libbba\nOGCLIB\t\t:= $(LIBDIR)/libogc\nDBLIB\t\t\t:= $(LIBDIR)/libdb\nBTELIB\t\t:= $(LIBDIR)/libbte\nWIIUSELIB\t:= $(LIBDIR)/libwiiuse\nWIIKEYBLIB\t:= $(LIBDIR)/libwiikeyboard\nSTUBSLIB\t\t:= $(LIBDIR)/libgclibstubs\n\n#---------------------------------------------------------------------------------\nDEFAULTINCDIR := $(BASEDIR)/wii/libogc/include\nDEFINCS\t\t:= -I$(DEFAULTINCDIR)\nINCLUDES\t:=\t$(DEFINCS) \\\n\t\t\t\t-I$(BASEDIR)/wii/libogc \\\n\t\t\t\t-I$(DEFAULTINCDIR)/netif \\\n\t\t\t\t-I$(DEFAULTINCDIR)/ipv4 \\\n\t\t\t\t-I$(DEFAULTINCDIR)/sdcard \\\n\t\t\t\t-I$(DEFAULTINCDIR)/ogc \\\n\t\t\t\t-I$(DEFAULTINCDIR)/ogc/machine \\\n\t\t\t\t-I$(DEFAULTINCDIR)/bte \\\n\t\t\t\t-I$(DEFAULTINCDIR)/sdcard \\\n\t\t\t\t-I$(DEFAULTINCDIR)/wiikeyboard \\\n\t\t\t\t-I$(DEFAULTINCDIR)/wiiuse \\\n\t\t\t\t-I$(DEFAULTINCDIR)/di\n\nMACHDEP\t\t:= -DBIGENDIAN -DGEKKO -mcpu=750 -meabi -msdata=eabi -mhard-float -ffunction-sections -fdata-sections\n\nifeq ($(PLATFORM),wii)\nMACHDEP\t\t+=\t-DHW_RVL\nendif\n\nifeq ($(PLATFORM),cube)\nMACHDEP\t\t+=\t-DHW_DOL\nendif\n\nCFLAGS\t\t:= -DLIBOGC_INTERNAL -DNDEBUG -O2 -fno-strict-aliasing -mregnames -Wall $(MACHDEP) $(INCLUDES)\nASFLAGS\t\t:=\t$(MACHDEP) -mregnames -D_LANGUAGE_ASSEMBLY $(INCLUDES)\n\n#---------------------------------------------------------------------------------\nVPATH :=\t$(LWIPDIR)\t\t\t\t\\\n\t\t\t$(LWIPDIR)/arch/gc\t\t\\\n\t\t\t$(LWIPDIR)/arch/gc/netif\t\\\n\t\t\t$(LWIPDIR)/core\t\t\t\\\n\t\t\t$(LWIPDIR)/core/ipv4\t\\\n\t\t\t$(LWIPDIR)/netif\t\\\n\t\t\t$(OGCDIR)\t\t\t\\\n\t\t\t$(DBDIR)\t\t\t\\\n\t\t\t$(DBDIR)/uIP\t\t\\\n\t\t\t$(BTEDIR)\t\t\\\n\t\t\t$(WIIUSEDIR)\t\t\\\n\t\t\t$(SDCARDDIR)\t\t\t\\\n\t\t\t$(LIBWIIKEYB)\t\t\\\n\t\t\t$(STUBSDIR)\n\n#---------------------------------------------------------------------------------\nSOURCES_LWIP := $(LWIPDIR)/network.c \\\n\t\t\t\t\t $(LWIPDIR)/netio.c \\\n\t\t\t\t\t $(LWIPDIR)/arch/gc/netif/gcif.c\t\\\n\t\t\t\t\t $(LWIPDIR)/core/inet.c \\\n\t\t\t\t\t $(LWIPDIR)/core/mem.c \\\n\t\t\t\t\t $(LWIPDIR)/core/dhcp.c \\\n\t\t\t\t\t $(LWIPDIR)/core/raw.c\t\\\n\t\t\t\t\t $(LWIPDIR)/core/memp.c \\\n\t\t\t\t\t $(LWIPDIR)/core/netif.c \\\n\t\t\t\t\t $(LWIPDIR)/core/pbuf.c \\\n\t\t\t\t\t $(LWIPDIR)/core/stats.c \\\n\t\t\t\t\t $(LWIPDIR)/core/sys.c \\\n\t\t\t\t\t $(LWIPDIR)/core/tcp.c \\\n\t\t\t\t\t $(LWIPDIR)/core/tcp_in.c \\\n\t\t\t\t\t $(LWIPDIR)/core/tcp_out.c\t\\\n\t\t\t\t\t $(LWIPDIR)/core/udp.c \\\n\t\t\t\t\t $(LWIPDIR)/core/ipv4/icmp.c \\\n\t\t\t\t\t $(LWIPDIR)/core/ipv4/ip.c \\\n\t\t\t\t\t $(LWIPDIR)/core/ipv4/ip_frag.c \\\n\t\t\t\t\t $(LWIPDIR)/core/ipv4/ip_addr.c \\\n\t\t\t\t\t $(LWIPDIR)/netif/etharp.c \\\n\t\t\t\t\t $(LWIPDIR)/netif/loopif.c\n\nLWIPOBJ := $(SOURCES_LWIP:.c=.o)\n\n#---------------------------------------------------------------------------------\nSOURCES_OGC\t\t:=\t\\\n\t\t\t\t\t$(OGCDIR)/console.c \\\n\t\t\t\t\t$(OGCDIR)/lwp_priority.c \\\n\t\t\t\t\t$(OGCDIR)/lwp_queue.c \\\n\t\t\t\t\t$(OGCDIR)/lwp_threadq.c \\\n\t\t\t\t\t$(OGCDIR)/lwp_threads.c \\\n\t\t\t\t\t$(OGCDIR)/lwp_sema.c\t\\\n\t\t\t\t\t$(OGCDIR)/lwp_messages.c \\\n\t\t\t\t\t$(OGCDIR)/lwp.c \\\n\t\t\t\t\t$(OGCDIR)/lwp_stack.c \\\n\t\t\t\t\t$(OGCDIR)/lwp_mutex.c \t\\\n\t\t\t\t\t$(OGCDIR)/lwp_watchdog.c \\\n\t\t\t\t\t$(OGCDIR)/lwp_wkspace.c \\\n\t\t\t\t\t$(OGCDIR)/lwp_objmgr.c \\\n\t\t\t\t\t$(OGCDIR)/lwp_heap.c \\\n\t\t\t\t\t$(OGCDIR)/sys_state.c \\\n\t\t\t\t\t$(OGCDIR)/exception.c \\\n\t\t\t\t\t$(OGCDIR)/irq.c \\\n\t\t\t\t\t$(OGCDIR)/semaphore.c \\\n\t\t\t\t\t$(OGCDIR)/video.c \\\n\t\t\t\t\t$(OGCDIR)/pad.c \\\n\t\t\t\t\t$(OGCDIR)/exi.c \\\n\t\t\t\t\t$(OGCDIR)/mutex.c \\\n\t\t\t\t\t$(OGCDIR)/arqueue.c \\\n\t\t\t\t\t$(OGCDIR)/arqmgr.c\t\\\n\t\t\t\t\t$(OGCDIR)/system.c \\\n\t\t\t\t\t$(OGCDIR)/cond.c \\\n\t\t\t\t\t$(OGCDIR)/gx.c \\\n\t\t\t\t\t$(OGCDIR)/gu.c \\\n\t\t\t\t\t$(OGCDIR)/audio.c \\\n\t\t\t\t\t$(OGCDIR)/cache.c \\\n\t\t\t\t\t$(OGCDIR)/decrementer.c\t\t\t\\\n\t\t\t\t\t$(OGCDIR)/message.c \\\n\t\t\t\t\t$(OGCDIR)/card.c \\\n\t\t\t\t\t$(OGCDIR)/aram.c \\\n\t\t\t\t\t$(OGCDIR)/depackrnc1.c \\\n\t\t\t\t\t$(OGCDIR)/dsp.c \\\n\t\t\t\t\t$(OGCDIR)/si.c \\\n\t\t\t\t\t$(OGCDIR)/tpl.c \\\n\t\t\t\t\t$(OGCDIR)/ipc.c \\\n\t\t\t\t\t$(OGCDIR)/console_font_8x16.c \\\n\t\t\t\t\t$(OGCDIR)/timesupp.c \\\n\t\t\t\t\t$(OGCDIR)/lock_supp.c \\\n\t\t\t\t\t$(OGCDIR)/newlibc.c \\\n\t\t\t\t\t$(OGCDIR)/usbgecko.c \\\n\t\t\t\t\t$(OGCDIR)/usbmouse.c \\\n\t\t\t\t\t$(OGCDIR)/sbrk.c \\\n\t\t\t\t\t$(OGCDIR)/malloc_lock.c \\\n\t\t\t\t\t$(OGCDIR)/kprintf.c \\\n\t\t\t\t\t$(OGCDIR)/stm.c \\\n\t\t\t\t\t$(OGCDIR)/ios.c \\\n\t\t\t\t\t$(OGCDIR)/es.c \\\n\t\t\t\t\t$(OGCDIR)/isfs.c \\\n\t\t\t\t\t$(OGCDIR)/usb.c \\\n\t\t\t\t\t$(OGCDIR)/network_common.c \\\n\t\t\t\t\t$(OGCDIR)/sdgecko_io.c \\\n\t\t\t\t\t$(OGCDIR)/sdgecko_buf.c \\\n\t\t\t\t\t$(OGCDIR)/gcsd.c \\\n\t\t\t\t\t$(OGCDIR)/argv.c \\\n\t\t\t\t\t$(OGCDIR)/network_wii.c \\\n\t\t\t\t\t$(OGCDIR)/wiisd.c \\\n\t\t\t\t\t$(OGCDIR)/conf.c \\\n\t\t\t\t\t$(OGCDIR)/usbstorage.c \\\n\t\t\t\t\t$(OGCDIR)/texconv.c \\\n\t\t\t\t\t$(OGCDIR)/wiilaunch.c\n\nSOURCES_OGC_ASM := $(OGCDIR)/cache_asm.S \\\n\t\t\t\t\t\t $(OGCDIR)/decrementer_handler.S \\\n\t\t\t\t\t\t $(OGCDIR)/depackrnc.S \\\n\t\t\t\t\t\t $(OGCDIR)/exception_handler.S \\\n\t\t\t\t\t\t $(OGCDIR)/gu_psasm.S \\\n\t\t\t\t\t\t $(OGCDIR)/irq_handler.S \\\n\t\t\t\t\t\t $(OGCDIR)/lwp_handler.S \\\n\t\t\t\t\t\t $(OGCDIR)/ogc_crt0.S \\\n\t\t\t\t\t\t $(OGCDIR)/system_asm.S \\\n\t\t\t\t\t\t $(OGCDIR)/video_asm.S\n\nifneq ($(BUILD_LITE), 1)\nSOURCES_OGC += $(OGCDIR)/dvd.c\nendif\n\nOGCOBJ := $(SOURCES_OGC:.c=.o) $(SOURCES_OGC_ASM:.S=.o)\n\n#---------------------------------------------------------------------------------\nSOURCES_DB\t\t:=\t\\\n\t\t\t\t$(DBDIR)/uIP/uip_ip.c \\\n\t\t\t\t$(DBDIR)/uIP/uip_tcp.c \\\n\t\t\t\t$(DBDIR)/uIP/uip_pbuf.c \\\n\t\t\t\t$(DBDIR)/uIP/uip_netif.c \\\n\t\t\t\t$(DBDIR)/uIP/uip_arp.c \\\n\t\t\t\t$(DBDIR)/uIP/uip_arch.c \\\n\t\t\t\t$(DBDIR)/uIP/uip_icmp.c \\\n\t\t\t\t$(DBDIR)/uIP/memb.c \\\n\t\t\t\t$(DBDIR)/uIP/memr.c \\\n\t\t\t\t$(DBDIR)/uIP/bba.c \\\n\t\t\t\t$(DBDIR)/tcpip.c \\\n\t\t\t\t$(DBDIR)/debug.c \\\n\t\t\t\t$(DBDIR)/debug_handler.c \\\n\t\t\t\t$(DBDIR)/debug_supp.c \\\n\t\t\t\t$(DBDIR)/geckousb.c\n\nDBOBJ      := $(SOURCES_DB:.c=.o)\n\n#---------------------------------------------------------------------------------\nSOURCES_BTE\t\t:=\t\\\n\t\t\t\t\t$(BTEDIR)/bte.c \\\n\t\t\t\t\t$(BTEDIR)/hci.c \\\n\t\t\t\t\t$(BTEDIR)/l2cap.c \\\n\t\t\t\t\t$(BTEDIR)/btmemb.c \\\n\t\t\t\t\t$(BTEDIR)/btmemr.c \\\n\t\t\t\t\t$(BTEDIR)/btpbuf.c \\\n\t\t\t\t\t$(BTEDIR)/physbusif.c\n\nBTEOBJ      := $(SOURCES_BTE:.c=.o)\n\n#---------------------------------------------------------------------------------\nSOURCES_WIIUSE\t:=\t\\\n\t\t\t\t\t$(WIIUSEDIR)/classic.c \\\n\t\t\t\t\t$(WIIUSEDIR)/dynamics.c \\\n\t\t\t\t\t$(WIIUSEDIR)/events.c \\\n\t\t\t\t\t$(WIIUSEDIR)/io.c \\\n\t\t\t\t\t$(WIIUSEDIR)/io_wii.c \\\n\t\t\t\t\t$(WIIUSEDIR)/ir.c \\\n\t\t\t\t\t$(WIIUSEDIR)/nunchuk.c \\\n\t\t\t\t\t$(WIIUSEDIR)/wiiuse.c \\\n\t\t\t\t\t$(WIIUSEDIR)/speaker.c \\\n\t\t\t\t\t$(WIIUSEDIR)/wpad.c \\\n\t\t\t\t\t$(WIIUSEDIR)/motion_plus.c\n\nWIIUSEOBJ   := $(SOURCES_WIIUSE:.c=.o)\n\n#---------------------------------------------------------------------------------\nSOURCES_WIIKEYB = $(LIBWIIKEYB)/usbkeyboard.c \\\n\t\t\t\t\t\t$(LIBWIIKEYB)/keyboard.c \\\n\t\t\t\t\t\t$(LIBWIIKEYB)/ukbdmap.c \\\n\t\t\t\t\t\t$(LIBWIIKEYB)/wskbdutil.c\n\nWIIKEYBLIBOBJ\t:=\t$(SOURCES_WIIKEYB:.c=.o)\n\nLIBRARIES\t:=\t$(OGCLIB).a  $(DBLIB).a\n\nifeq ($(PLATFORM),cube)\nLIBRARIES\t+=\t$(BBALIB).a\nendif\nifeq ($(PLATFORM),wii)\nLIBRARIES\t+=\t$(BTELIB).a $(WIIUSELIB).a $(WIIKEYBLIB).a\nendif\n\nall: $(LIBRARIES)\n#---------------------------------------------------------------------------------\n$(BBALIB).a: $(LWIPOBJ)\n#---------------------------------------------------------------------------------\n$(OGCLIB).a: $(OGCOBJ)\n#---------------------------------------------------------------------------------\n$(DBLIB).a: $(DBOBJ)\n#---------------------------------------------------------------------------------\n$(WIIKEYBLIB).a: $(WIIKEYBLIBOBJ)\n#---------------------------------------------------------------------------------\n$(BTELIB).a: $(BTEOBJ)\n#---------------------------------------------------------------------------------\n$(WIIUSELIB).a: $(WIIUSEOBJ)\n#---------------------------------------------------------------------------------\n\n#---------------------------------------------------------------------------------\nclean:\n#---------------------------------------------------------------------------------\n\trm -fr $(LWIPOBJ) $(OGCOBJ) $(DBOBJ) $(BTEOBJ) $(WIIUSEOBJ) $(WIIKEYBLIBOBJ)\n\trm -f *.map\n"
        },
        {
          "name": "Makefile.miyoo",
          "type": "blob",
          "size": 4.7587890625,
          "content": "#########################\n## Toolchain variables ##\n#########################\n\n# Default toolchain directory\nTOOLCHAIN_DIR=/opt/miyoo\n\n# All toolchain-related variables may be\n# overridden via the command line\n\nifdef GCW0_CC\nCC                    = $(GCW0_CC)\nelse\nCC                    = $(TOOLCHAIN_DIR)/usr/bin/arm-linux-gcc\nendif\n\nifdef GCW0_CXX\nCXX                   = $(GCW0_CXX)\nelse\nCXX                   = $(TOOLCHAIN_DIR)/usr/bin/arm-linux-g++\nendif\n\nifdef GCW0_STRIP\nSTRIP                 = $(GCW0_STRIP)\nelse\nSTRIP                 = $(TOOLCHAIN_DIR)/usr/bin/arm-linux-strip\nendif\n\nGCW0_SDL_CONFIG      ?= $(TOOLCHAIN_DIR)/usr/arm-miyoo-linux-uclibcgnueabi/sysroot/usr/bin/sdl-config\nGCW0_FREETYPE_CONFIG ?= $(TOOLCHAIN_DIR)/usr/arm-miyoo-linux-uclibcgnueabi/sysroot/usr/bin/freetype-config\n\nGCW0_INC_DIR         ?= $(TOOLCHAIN_DIR)/usr/arm-miyoo-linux-uclibcgnueabi/sysroot/usr/include\nGCW0_LIB_DIR         ?= $(TOOLCHAIN_DIR)/usr/arm-miyoo-linux-uclibcgnueabi/sysroot/usr/lib\n\n#########################\n#########################\n\nPACKAGE_NAME = retroarch\n\nDEBUG ?= 0\n\nMIYOO = 1\nDINGUX = 1\nHAVE_SCREENSHOTS = 1\nHAVE_REWIND = 1\nHAVE_7ZIP = 1\nHAVE_AL = 0\nHAVE_ALSA = 1\nHAVE_DSP_FILTER = 1\nHAVE_VIDEO_FILTER = 1\nHAVE_STATIC_VIDEO_FILTERS = 1\nHAVE_STATIC_AUDIO_FILTERS = 1\nHAVE_FILTERS_BUILTIN\t= 1\nHAVE_BUILTINMBEDTLS = 0\nHAVE_BUILTINZLIB = 1\nHAVE_C99 = 1\nHAVE_CC = 1\nHAVE_CC_RESAMPLER = 1\nHAVE_CHD = 1\nHAVE_COMMAND = 0\nHAVE_CXX = 1\nHAVE_DR_MP3 = 1\nHAVE_DYNAMIC = 1\nHAVE_EGL = 0\nHAVE_FREETYPE = 0\nHAVE_GDI = 1\nHAVE_GETADDRINFO = 0\nHAVE_GETOPT_LONG = 1\nHAVE_GLSL = 0\nHAVE_HID = 0\nHAVE_IBXM = 1\nHAVE_IMAGEVIEWER = 0\nHAVE_LANGEXTRA = 0\nHAVE_LIBRETRODB = 1\nHAVE_MENU = 1\nHAVE_MENU_COMMON = 1\nHAVE_GFX_WIDGETS = 0\nHAVE_MMAP = 1\nHAVE_OPENDINGUX_FBDEV = 0\nHAVE_OPENGL = 0\nHAVE_OPENGL1 = 0\nHAVE_OPENGLES = 0\nHAVE_OPENGLES3 = 0\nHAVE_OPENGL_CORE = 0\nHAVE_OPENSSL = 0\nHAVE_OVERLAY = 0\nHAVE_RBMP = 1\nHAVE_RJPEG = 1\nHAVE_RPILED = 0\nHAVE_RPNG = 1\nHAVE_RUNAHEAD = 0\nHAVE_SDL_DINGUX = 1\nHAVE_SHADERPIPELINE = 0\nHAVE_STB_FONT = 0\nHAVE_STB_IMAGE = 0\nHAVE_STB_VORBIS = 0\nHAVE_STDIN_CMD = 0\nHAVE_STRCASESTR = 1\nHAVE_THREADS = 1\nHAVE_UDEV = 0\nHAVE_RGUI = 1\nHAVE_MATERIALUI = 0\nHAVE_XMB = 0\nHAVE_OZONE = 0\nHAVE_ZLIB = 1\nHAVE_CONFIGFILE = 1\nHAVE_PATCH = 1\nHAVE_XDELTA = 0 # Disabled until we figure out how to include <lzma.h>\nHAVE_CHEATS = 1\nHAVE_CHEEVOS = 0\nHAVE_LIBSHAKE = 0\nHAVE_CORE_INFO_CACHE = 1\n#HAVE_TINYALSA = 1\nHAVE_NEAREST_RESAMPLER = 1\n\nOS = Linux\nTARGET = retroarch\n\nOBJ :=\nLINK := $(CXX)\nDEF_FLAGS := -march=armv5te -mtune=arm926ej-s -ffast-math -fomit-frame-pointer\nDEF_FLAGS += -ffunction-sections -fdata-sections\nDEF_FLAGS += -I. -Ideps -Ideps/stb -DMIYOO=1 -DDINGUX -MMD\nDEF_FLAGS += -Wall -Wno-unused-variable -flto\nDEF_FLAGS += -std=gnu99 -D_GNU_SOURCE\nLIBS := -ldl -lz -lrt -pthread -lasound\nCFLAGS :=\nCXXFLAGS := -fno-exceptions -fno-rtti -std=c++11 -D__STDC_CONSTANT_MACROS\nASFLAGS :=\nLDFLAGS := -Wl,--gc-sections\nINCLUDE_DIRS = -I$(GCW0_INC_DIR)\nLIBRARY_DIRS = -L$(GCW0_LIB_DIR)\nDEFINES := -DRARCH_INTERNAL -D_FILE_OFFSET_BITS=64 -UHAVE_STATIC_DUMMY\nDEFINES += -DHAVE_C99=1 -DHAVE_CXX=1\nDEFINES += -DHAVE_GETOPT_LONG=1 -DHAVE_STRCASESTR=1 -DHAVE_DYNAMIC=1\nDEFINES += -DHAVE_FILTERS_BUILTIN -DHAVE_ALSA\n\nSDL_DINGUX_CFLAGS := $(shell $(GCW0_SDL_CONFIG) --cflags)\nSDL_DINGUX_LIBS := $(shell $(GCW0_SDL_CONFIG) --libs)\nFREETYPE_CFLAGS := $(shell $(GCW0_FREETYPE_CONFIG) --cflags)\nFREETYPE_LIBS := $(shell $(GCW0_FREETYPE_CONFIG) --libs)\nMMAP_LIBS = -lc\n\nOBJDIR_BASE := obj-unix\n\nifeq ($(DEBUG), 1)\n   OBJDIR := $(OBJDIR_BASE)/debug\n   DEF_FLAGS += -O0 -g -DDEBUG -D_DEBUG\nelse\n   OBJDIR := $(OBJDIR_BASE)/release\n   DEF_FLAGS += -O2 -DNDEBUG\nendif\n\ninclude Makefile.common\n\nDEF_FLAGS += $(INCLUDE_DIRS)\nLDFLAGS += $(CFLAGS) $(CXXFLAGS) $(DEF_FLAGS)\nCFLAGS += $(DEF_FLAGS)\nCXXFLAGS += $(DEF_FLAGS)\n\nHEADERS = $(wildcard */*/*.h) $(wildcard */*.h) $(wildcard *.h)\n\nQ := @\n\nRARCH_OBJ := $(addprefix $(OBJDIR)/,$(OBJ))\n\nall: $(TARGET)\n\n-include $(RARCH_OBJ:.o=.d)\n\nSYMBOL_MAP := -Wl,-Map=output.map\n\n$(TARGET): $(RARCH_OBJ)\n\t@$(if $(Q), $(shell echo echo LD $@),)\n\t$(Q)$(LINK) -o $@ $(RARCH_OBJ) $(LIBS) $(LDFLAGS) $(LIBRARY_DIRS)\n\nifeq ($(STRIP_BIN),1)\n\t$(STRIP) --strip-unneeded $(TARGET)\nendif\n\n$(OBJDIR)/%.o: %.c\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CC $<),)\n\t$(Q)$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) -c -o $@ $<\n\n$(OBJDIR)/%.o: %.cpp\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CXX $<),)\n\t$(Q)$(CXX) $(CPPFLAGS) $(CXXFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.m\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo OBJC $<),)\n\t$(Q)$(CXX) $(OBJCFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.S $(HEADERS)\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo AS $<),)\n\t$(Q)$(CC) $(CFLAGS) $(ASFLAGS) $(DEFINES) -c -o $@ $<\n\nclean:\n\trm -rf $(OBJDIR_BASE)\n\trm -f $(TARGET)\n\trm -f *.d\n\n.PHONY: all clean\n\nprint-%:\n\t@echo '$*=$($*)'\n"
        },
        {
          "name": "Makefile.msvc",
          "type": "blob",
          "size": 7.6142578125,
          "content": "TARGET\t\t    := retroarch.exe\nDEBUG           = 0\nGRIFFIN_BUILD   = 0\nOS              = Win32\nARCH            = amd64\n#TARGET_ARCH     = x86\nBUILD_DIR       = objs/msvc\nCXX_BUILD       = 0\n\nWindowsSdkDir = C:\\Program Files (x86)\\Windows Kits\\10\\$(NOTHING)\nWindowsSDKVersion := 10.0.14393.0\\$(NOTHING)\nVCINSTALLDIR := C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\$(NOTHING)\n\nHAVE_DSP_FILTER          := 1\nHAVE_VIDEO_FILTER        := 1\nHAVE_SCREENSHOTS         := 1\nHAVE_REWIND              := 1\nHAVE_AUDIOMIXER          := 1\nHAVE_D3DX                := 1\nHAVE_D3D8                := 0\nHAVE_D3D9                := 1\nHAVE_D3D10               := 1\nHAVE_D3D11               := 1\nHAVE_D3D12               := 1\nHAVE_CG                  := 1\nHAVE_OPENGL              := 1\nHAVE_OPENGL1             := 1\nHAVE_GFX_WIDGETS         := 1\nHAVE_VULKAN              := 1\nHAVE_XAUDIO              := 1\nHAVE_XINPUT              := 1\nHAVE_WASAPI              := 1\nHAVE_THREAD_STORAGE      := 1\nHAVE_WINMM               := 1\n\nHAVE_RPNG                := 1\nHAVE_ZLIB                := 1\nHAVE_CONFIGFILE          := 1\nHAVE_PATCH               := 1\nHAVE_MENU                := 1\nHAVE_RGUI                := 1\nHAVE_XMB                 := 1\nHAVE_MATERIALUI          := 1\nHAVE_STB_FONT            := 1\nHAVE_THREADS             := 1\nHAVE_LIBRETRODB          := 1\nHAVE_COMMAND             := 1\nHAVE_STDIN_CMD           := 1\nHAVE_CMD                 := 1\nHAVE_DYLIB               := 1\nHAVE_DYNAMIC             := 1\nHAVE_DINPUT              := 1\nHAVE_MENU_COMMON         := 1\nHAVE_BUILTINZLIB         := 1\n\nHAVE_RJPEG               := 1\nHAVE_RBMP                := 1\nHAVE_RTGA                := 1\nHAVE_7ZIP                := 1\nHAVE_NETWORKING          := 1\nHAVE_IFINFO              := 1\nHAVE_NETWORK_CMD         := 1\nHAVE_OVERLAY             := 1\nHAVE_LANGEXTRA           := 1\nHAVE_CHEEVOS             := 1\nHAVE_SHADERPIPELINE      := 1\nHAVE_IMAGEVIEWER         := 1\nHAVE_BSV_MOVIE           := 1\nHAVE_CHEATS              := 1\nHAVE_CORE_INFO_CACHE     := 1\n\nifeq ($(HAVE_D3D8), 1)\n   D3D8_LIBS := -ld3d8\n   ifeq ($(HAVE_D3DX), 1)\n      D3DX8_LIBS := -ld3dx8\n   endif\nendif\n\nifeq ($(HAVE_D3D9), 1)\n   D3D9_LIBS := -ld3d9\n   ifeq ($(HAVE_D3DX), 1)\n      D3DX9_LIBS := -ld3dx9\n   endif\nendif\n\ninclude Makefile.common\nINCLUDE_DIRS := $(patsubst  -isystem%,-I%,$(INCLUDE_DIRS))\nCFLAGS       := $(filter-out  -Wno-unknown-pragmas,$(DEF_FLAGS))\nCXXFLAGS     := $(filter-out  -fpermissive -Wno-switch -Wno-sign-compare -fno-strict-aliasing -Wno-maybe-uninitialized -Wno-reorder -Wno-parentheses,$(CXXFLAGS))\nLIBS         := $(filter-out  -lstdc++,$(LIBS))\n\nifeq ($(ARCH),x64)\n   ARCH := amd64\nendif\n\nARCH2 := $(ARCH)\nifeq ($(ARCH),amd64)\n   ARCH2 := x64\nendif\n\nifeq ($(TARGET_ARCH),)\n   TARGET_ARCH = $(ARCH)\nendif\n\nifeq ($(TARGET_ARCH),x64)\n   TARGET_ARCH = amd64\nendif\n\nTARGET_ARCH2 = $(TARGET_ARCH)\nifeq ($(TARGET_ARCH2),amd64)\n   TARGET_ARCH2 = x64\nendif\n\nCROSS = $(ARCH)\nifeq ($(ARCH),x86)\nCROSS =\nendif\n\nINCLUDE := $(VCINSTALLDIR)include;$(VCINSTALLDIR)atlmfc\\include;$(WindowsSdkDir)include\\$(WindowsSDKVersion)ucrt;$(WindowsSdkDir)include\\$(WindowsSDKVersion)shared;$(WindowsSdkDir)include\\$(WindowsSDKVersion)um;\nLIB     := $(VCINSTALLDIR)LIB\\$(CROSS);$(VCINSTALLDIR)atlmfc\\lib\\$(CROSS);$(WindowsSdkDir)lib\\$(WindowsSDKVersion)ucrt\\$(TARGET_ARCH2);$(WindowsSdkDir)lib\\$(WindowsSDKVersion)um\\$(TARGET_ARCH2);C:\\Program Files (x86)\\NVIDIA Corporation\\Cg\\lib.$(TARGET_ARCH2);C:\\Program Files (x86)\\Microsoft DirectX SDK (February 2010)\\Lib\\$(TARGET_ARCH2);\nLIBPATH := $(VCINSTALLDIR)LIB\\$(CROSS);$(VCINSTALLDIR)atlmfc\\lib\\$(CROSS);\n\nPATH := $(shell IFS=$$'\\n'; cygpath \"$(VCINSTALLDIR)bin\\\\$(CROSS)\"):$(shell IFS=$$'\\n'; cygpath \"$(WindowsSdkDir)\\bin\\\\$(ARCH2)\"):$(PATH)\n\nexport INCLUDE := $(INCLUDE)\nexport LIB     := $(LIB)\nexport LIBPATH := $(LIBPATH)\nexport PATH    := $(PATH)\n\n#$(info WindowsSdkDir : $(WindowsSdkDir))\n#$(info WindowsSDKVersion : $(WindowsSDKVersion))\n#$(info VCINSTALLDIR : $(VCINSTALLDIR))\n#$(info INCLUDE : $(INCLUDE))\n#$(info LIB : $(LIB))\n#$(info LIBPATH : $(LIBPATH))\n#$(info PATH : $(PATH))\n#$(error end)\n\nDEFINES += -D__SSE__ -D__SSE2__\nifeq ($(TARGET_ARCH2),x64)\nDEFINES += -D__x86_64__\nelse\n#DEFINES += -D__i686__\nendif\n\nFLAGS  += -nologo -MP\nFLAGS  += -Gm- -Zc:inline -fp:precise -Zc:forScope -GR- -Gd -Oi -volatile:iso\n#FLAGS  += -Zc:wchar_t -Zp16 -Z7\nFLAGS += -utf-8\n#FLAGS += -source-charset:utf-8\n\nCXXFLAGS += $(CFLAGS) -TP -EHsc\nifeq ($(CXX_BUILD),1)\n   CFLAGS  := $(CXXFLAGS)\n   DEFINES += -DCXX_BUILD\nelse\n   CFLAGS  += -TC\nendif\n\nWARNINGS += -WX -W3\nWARNINGS += -wd4101 -wd4996 -wd4244 -wd4267 -wd4090 -wd4305 -wd4146 -wd4334 -wd4018 -wd4800 -wd4838\n\nCC = cl.exe\nCXX = cl.exe\nLD = link.exe\nRC = rc.exe\n\nLIBS += shell32.lib user32.lib gdi32.lib comdlg32.lib winmm.lib ole32.lib\nLDFLAGS  += -nologo -wx -nxcompat -machine:$(TARGET_ARCH2)\n\nifeq ($(DEBUG),1)\n   FLAGS += -GS -Gy -Od -RTC1 -D_SECURE_SCL=1 -Zi\n   FLAGS += -MDd\n   LDFLAGS += -DEBUG\n   DEFINES += -DDEBUG -D_DEBUG\nelse\n   FLAGS += -GS- -Gy- -O2 -Ob2 -GF -GT -Oy -Ot -D_SECURE_SCL=0\n   FLAGS += -MD\nendif\n\nifeq ($(DEBUG),1)\n   BUILD_DIR := $(BUILD_DIR)-debug\nendif\n\nifeq ($(GRIFFIN_BUILD),1)\n   BUILD_DIR := $(BUILD_DIR)-griffin\nendif\n\nBUILD_DIR := $(BUILD_DIR)-$(TARGET_ARCH2)\n\nifneq ($(V), 1)\n   Q := @\nendif\n\nifeq ($(GRIFFIN_BUILD), 1)\n   OBJ       := griffin/griffin.o griffin/griffin_cpp.o\n   DEFINES   += -DHAVE_GRIFFIN -DUSE_MATH_DEFINES\nelse\n   BLACKLIST :=\n   OBJ := $(filter-out $(BLACKLIST),$(OBJ))\nendif\n\nDEFINES += -DRARCH_INTERNAL -DHAVE_SCREENSHOTS -DHAVE_REWIND -DHAVE_DYNAMIC -DJSON_STATIC\nINCLUDE_DIRS += -I. -Igfx/include\n\nOBJ := $(patsubst %rarch.o,%rarch.res,$(OBJ))\nOBJ := $(addprefix $(BUILD_DIR)/,$(OBJ))\nOBJ := $(OBJ:.o=.obj)\n\nLDFLAGS += -WX -SUBSYSTEM:WINDOWS -ENTRY:mainCRTStartup\n\nDEFINES := $(patsubst -f%,,$(DEFINES))\nLDFLAGS := $(patsubst -l%,%.lib,$(LDFLAGS))\nLIBS := $(filter-out -lm,$(LIBS))\nLIBS := $(patsubst -l%,%.lib,$(LIBS))\n\n#$(info INCLUDE_DIRS : $(INCLUDE_DIRS))\n#$(info DEFINES : $(DEFINES))\n#$(info CFLAGS : $(CFLAGS))\n#$(info CXXFLAGS : $(CXXFLAGS))\n#$(info LDFLAGS : $(LDFLAGS))\n#$(info LIBS : $(LIBS))\n#$(info OBJ : $(OBJ))\n#$(info target : $(TARGET))\n#$(info flags : $(FLAGS))\n#$(info INCLUDE : $(INCLUDE))\n#$(info LIB : $(LIB))\n#$(info LIBPATH : $(LIBPATH))\n#$(error end)\n\n$(info os     : $(OS))\n$(info host   : $(ARCH))\n$(info target : $(TARGET_ARCH))\n\nall: $(TARGET)\n\n%: $(BUILD_DIR)/%\n\tcp $< $@\n\nifeq ($(DEBUG),1)\n%.exe: $(BUILD_DIR)/%.exe\n\tcp $< $@\n\tcp $(BUILD_DIR)/$*.pdb $*.pbd\nendif\n\nSHELL:=$(SHELL) -o pipefail\n\nDEPFLAGS = -showIncludes | tee $(BUILD_DIR)/$*.dtemp | sed /'Note: including file:'/d\nMAKEDEPS = echo $@: $< \\\\ > $(BUILD_DIR)/$*.depend && \\\n           grep 'Note: including file:' $(BUILD_DIR)/$*.dtemp \\\n           | sed '/$(subst \\,\\\\,$(WindowsSdkDir))/Id; /$(subst \\,\\\\,$(VCINSTALLDIR))/Id; s/Note: including file:[ ]*//g; s/\\\\/\\//g; s/ /\\\\ /g; s/.*/   & \\\\/g' \\\n           >> $(BUILD_DIR)/$*.depend && \\\n           rm -f $(BUILD_DIR)/$*.dtemp\n\n#DEPFLAGS :=\n#MAKEDEPS :=\n\n$(BUILD_DIR)/%.obj: %.cpp\n\t@mkdir -p $(dir $@)\n\t$(Q)$(CXX) -c -Fo:$@ $< $(FLAGS) $(CXXFLAGS) $(DEFINES) $(INCLUDE_DIRS) $(WARNINGS) $(DEPFLAGS)\n\t@$(MAKEDEPS)\n\n$(BUILD_DIR)/%.obj: %.c\n\t@mkdir -p $(dir $@)\n\t$(Q)$(CC) -c -Fo:$@ $< $(FLAGS) $(CFLAGS) $(DEFINES) $(INCLUDE_DIRS) $(WARNINGS) $(DEPFLAGS)\n\t@$(MAKEDEPS)\n\n$(BUILD_DIR)/%.res: %.rc\n\t@mkdir -p $(dir $@)\n\t$(Q)$(RC) $<\n\t$(Q)mv $*.res $@\n\n$(BUILD_DIR)/$(TARGET): $(OBJ) .$(TARGET).last\n\t@touch .$(TARGET).last\n\t$(Q)$(LD) $(OBJ) $(LDFLAGS) $(LIBS) -out:$(BUILD_DIR)/$(TARGET)\n\n%.h %.hpp %.depend %.last: ;\n\nclean:\n\trm -f $(OBJ) $(TARGET)\n\trm -f $(BUILD_DIR)/$(TARGET)\n\trm -f .$(TARGET).last\n\trm -f $(OBJ:.obj=.depend)\n\n.PHONY: clean all\n.PRECIOUS: %.depend %.last\n\n-include $(patsubst %.obj,%.depend,$(filter %.obj,$(OBJ)))\n"
        },
        {
          "name": "Makefile.ngc",
          "type": "blob",
          "size": 6.2958984375,
          "content": "ROOT_DIR                  := .\nDEPS_DIR                  := $(ROOT_DIR)/deps\nDEBUG                     ?= 0\nHAVE_LOGGER                = 0\nHAVE_FILE_LOGGER           = 0\nHAVE_CC_RESAMPLER          = 1\nWHOLE_ARCHIVE_LINK         = 0\nBIG_STACK                  = 1\nPC_DEVELOPMENT_IP_ADDRESS  = 255.255.255.255\nPC_DEVELOPMENT_UDP_PORT    = 3490\nRARCH_CONSOLE              = 0\nUSBGECKO                   = 0\nHAVE_STATIC_DUMMY ?= 0\n\nSPACE      :=\nSPACE      := $(SPACE) $(SPACE)\nBACKSLASH  :=\nBACKSLASH  := \\$(BACKSLASH)\nfilter_out1 = $(filter-out $(firstword $1),$1)\nfilter_out2 = $(call filter_out1,$(call filter_out1,$1))\n\n# system platform\nsystem_platform = unix\nifeq ($(shell uname -s),)\n   EXE_EXT = .exe\n   system_platform = win\nelse ifneq ($(findstring Darwin,$(shell uname -s)),)\n   system_platform = osx\nelse ifneq ($(findstring MINGW,$(shell uname -s)),)\n   system_platform = win\nendif\n\nTARGET_NAME        := retroarch\n\nINCLUDE            :=\nLDFLAGS            :=\nLIBDIRS            :=\n\nifeq ($(LIBRETRO), nxengine)\n   WHOLE_ARCHIVE_LINK = 1\nendif\n\nifeq ($(WHOLE_ARCHIVE_LINK), 1)\n   WHOLE_START     := -Wl,--whole-archive\n   WHOLE_END       := -Wl,--no-whole-archive\nendif\n\nLIB_CORE :=\n\nifeq ($(HAVE_STATIC_DUMMY),1)\n  DEFINES += -DHAVE_STATIC_DUMMY\nelse\n  LIB_CORE += -lretro_ngc\nendif\n\nLIBS               := $(WHOLE_START) $(LIB_CORE) $(WHOLE_END)\n\nlibogc_platform    := 1\n\nEXTERNAL_LIBOGC   ?= 0\nGX_PTHREAD_LEGACY ?= 1\nCC                 = $(DEVKITPPC)/bin/powerpc-eabi-gcc$(EXE_EXT)\nCXX                = $(DEVKITPPC)/bin/powerpc-eabi-g++$(EXE_EXT)\nLD                 = $(DEVKITPPC)/bin/powerpc-eabi-ld$(EXE_EXT)\nELF2DOL            = $(DEVKITPPC)/bin/elf2dol$(EXE_EXT)\nEXT_TARGET        := $(TARGET_NAME)_ngc.dol\nEXT_INTER_TARGET  := $(TARGET_NAME)_ngc.elf\n\n# Check whether ELF2DOL executable exists\n# (path has changed in more recent toolchains)\nifeq (\"$(wildcard $(ELF2DOL))\",\"\")\n   ELF2DOL = $(DEVKITPRO)/tools/bin/elf2dol$(EXE_EXT)\nendif\n\nINCLUDE += -I.\n\nifeq ($(EXTERNAL_LIBOGC), 1)\n   CFLAGS   += -DEXTERNAL_LIBOGC\n   CXXFLAGS += -DEXTERNAL_LIBOGC\n   LIBDIRS += -L$(DEVKITPRO)/libogc/lib/cube\n   INCLUDE += -I$(DEVKITPRO)/libogc/include\nelse\n   CFLAGS   += -DINTERNAL_LIBOGC\n   CXXFLAGS += -DINTERNAL_LIBOGC\n   LIBDIRS += -Lwii/libogc/libs/cube\n   INCLUDE += -Iwii/libogc/include\nendif\n\nifeq ($(GX_PTHREAD_LEGACY), 1)\n   CFLAGS   += -DGX_PTHREAD_LEGACY\n   CXXFLAGS += -DGX_PTHREAD_LEGACY\nendif\n\nMACHDEP := -DHW_DOL -mogc\n\nLIBDIRS += -L.\nMACHDEP += -DGEKKO -mcpu=750 -meabi -mhard-float\n\nLDFLAGS += $(MACHDEP) -Wl,-Map,$(notdir $(EXT_INTER_TARGET)).map\n\nifeq ($(BIG_STACK), 1)\n   LDFLAGS += -T bootstrap/gx/ogc.ld\nendif\n\nifeq ($(EXTERNAL_LIBOGC), 1)\n   LIBS += -lfat\nendif\n\nifeq ($(HAVE_LOGGER), 1)\n  LIBS += -lbba\nendif\n\nLIBS += -logc\n\nCFLAGS += -DGEKKO -U__INT32_TYPE__ -U __UINT32_TYPE__ -D__INT32_TYPE__=int\n\nHAVE_RUNAHEAD            := 1\nHAVE_DSP_FILTER          := 1\nHAVE_VIDEO_FILTER        := 1\nHAVE_FILTERS_BUILTIN     := 1\nHAVE_THREADS             := 1\nHAVE_RPNG                := 1\nHAVE_RJPEG               := 1\nHAVE_RBMP                := 1\nHAVE_RTGA                := 1\nHAVE_IBXM                := 1\nHAVE_OVERLAY             := 1\nHAVE_ZLIB                := 1\nHAVE_7ZIP                := 1\nHAVE_CONFIGFILE          := 1\nHAVE_PATCH               := 1\nHAVE_XDELTA              := 0 # disabled because <lzma.h> isn't available (or we haven't figured out how to install it)\nHAVE_CHEATS              := 1\nHAVE_SCREENSHOTS         := 1\nHAVE_REWIND              := 1\nHAVE_AUDIOMIXER          := 1\nHAVE_RWAV                := 1\nRARCH_CONSOLE             = 1\nHAVE_CHEATS              := 1\nHAVE_CORE_INFO_CACHE     := 1\nHAVE_MENU_COMMON         := 1\nHAVE_MENU                := 1\nHAVE_BUILTINZLIB         := 1\nHAVE_STATIC_AUDIO_FILTERS := 1\nHAVE_STATIC_VIDEO_FILTERS := 1\nHAVE_XMB                 := 0\nHAVE_OZONE               := 0\nHAVE_RGUI                := 1\nHAVE_MATERIALUI          := 0\n\nINCLUDE += -I./libretro-common/include \\\n           -Ideps \\\n           -Ideps/stb\nCFLAGS += -Wall -std=gnu99 $(MACHDEP) $(PLATCFLAGS) $(INCLUDE)\n\nOBJ =  $(PLATOBJS) audio/drivers/gx_audio.o gfx/drivers/gx_gfx.o input/drivers/gx_input.o frontend/drivers/platform_gx.o input/drivers_joypad/gx_joypad.o\n\nifeq ($(EXTERNAL_LIBOGC), 0)\n   OBJ += wii/libogc/libfat/libfat.o wii/libogc/libfat/fatfile.o wii/libogc/libfat/file_allocation_table.o wii/libogc/libfat/cache.o wii/libogc/libfat/fatdir.o wii/libogc/libfat/partition.o wii/libogc/libfat/directory.o wii/libogc/libfat/filetime.o wii/libogc/libfat/disc.o\nendif\n\ninclude Makefile.common\n\nCFLAGS += $(DEFINES)\n\nifeq ($(WANT_GLSLANG), 1)\n\tOBJ += griffin/griffin_glslang.o\nendif\n\nifeq ($(HAVE_LOGGER), 1)\n   CFLAGS      += -DHAVE_LOGGER\n   CFLAGS      += -DPC_DEVELOPMENT_IP_ADDRESS=\\\"$(PC_DEVELOPMENT_IP_ADDRESS)\\\" -DPC_DEVELOPMENT_UDP_PORT=$(PC_DEVELOPMENT_UDP_PORT)\nendif\n\nifeq ($(HAVE_KERNEL_PRX), 1)\n   CFLAGS      += -DHAVE_KERNEL_PRX\nendif\n\nifeq ($(HAVE_WIIUSB_HID), 1)\n   CFLAGS      += -DHAVE_WIIUSB_HID -DHAVE_HID\nendif\n\nifeq ($(BIG_STACK),1)\n   CFLAGS      += -DBIG_STACK\nendif\n\nifeq ($(HAVE_FILE_LOGGER), 1)\n   CFLAGS      += -DHAVE_FILE_LOGGER\nendif\n\nifeq ($(HAVE_RARCH_EXEC), 1)\n   CFLAGS      += -DHAVE_RARCH_EXEC\nendif\n\nifeq ($(HAVE_ZLIB), 1)\n   CFLAGS      += -DHAVE_ZLIB\n   CFLAGS      += -I./libretro-common/include/compat/zlib\nendif\n\nifeq ($(RARCH_CONSOLE), 1)\n   CFLAGS += -DRARCH_CONSOLE\nendif\n\nifeq ($(RARCH_MOBILE), 1)\n   CFLAGS += -DRARCH_MOBILE\nendif\n\nCFLAGS += -std=gnu99 -DHAVE_RGUI -DHAVE_MENU -DHAVE_GRIFFIN=1 -Wno-char-subscripts -DRARCH_INTERNAL\n\nifeq ($(HAVE_FILTERS_BUILTIN), 1)\n   CFLAGS += -DHAVE_FILTERS_BUILTIN\nendif\n\nifeq ($(HAVE_RSOUND), 1)\n   CFLAGS += -DHAVE_RSOUND\nendif\n\nifeq ($(HAVE_GETOPT_LONG), 1)\n   CFLAGS += -DHAVE_GETOPT_LONG=1\nendif\n\nifeq ($(HAVE_NETWORK_CMD), 1)\n   CFLAGS += -DHAVE_NETWORK_CMD\nendif\n\nifeq ($(HAVE_DYNAMIC), 1)\n   CFLAGS += -DHAVE_DYNAMIC\nendif\n\nifeq ($(DEBUG), 1)\n   CFLAGS += -O0 -g -DDEBUG\nelse\n   CFLAGS += -O3\nendif\n\nOBJOUT   = -o\nLINKOUT  = -o\nLINK = $(CXX)\n\nall: $(EXT_TARGET)\n\n%.dol: %.elf\n\t$(ELF2DOL) $< $@\n\n$(EXT_INTER_TARGET): $(OBJ)\n\t$(LINK) $(LINKOUT)$@ $(LDFLAGS) $(LIBDIRS) $(OBJ) $(PLATEXTRA) $(LIBS)\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $(OBJOUT)$@ $<\n\n%.o: %.cpp\n\t$(CXX) $(CFLAGS) -c $(OBJOUT)$@ $<\n\n%.o: %.S\n\t$(CC) $(CFLAGS) -c $(OBJOUT)$@ $<\n\n%.binobj: %.bin\n\t$(LD) -r -b binary $(OBJOUT)$@ $<\n\nclean:\n\trm -f $(EXT_TARGET)\n\trm -f $(EXT_INTER_TARGET)\n\trm -f $(OBJ)\n\n.PHONY: clean\n\nprint-%:\n\t@echo '$*=$($*)'\n"
        },
        {
          "name": "Makefile.openpandora",
          "type": "blob",
          "size": 1.50390625,
          "content": "include version.all\n\nDEBUG    = 0\n\nCC       = $(PNDSDK)/bin/arm-none-linux-gnueabi-gcc\nLD       = $(PNDSDK)/bin/arm-none-linux-gnueabi-gcc -o\n\nTARGET  := retroarch-pandora\n\nLDDIRS   = -L. -L$(PNDSDK)/usr/lib\nINCDIRS  = -I. -I$(PNDSDK)/usr/include\n\nOBJ      = griffin/griffin.o audio/resamplers/sinc_resampler_neon.o libretro-common/conversion/s16_to_float_neon.o libretro-common/conversion/float_to_s16_neon.o\nLDFLAGS  = -L$(PNDSDK)/usr/lib -Wl,-rpath,$(PNDSDK)/usr/lib\n\nLIBS     = -lGLESv2 -lEGL -ldl -lm -lpthread -lrt -lasound\nDEFINES  = -std=gnu99\nDEFINES += -DHAVE_THREADS \\\n\t   -DHAVE_GETOPT_LONG=1 \\\n\t   -DHAVE_GRIFFIN \\\n\t   -DRARCH_INTERNAL \\\n\t   -DHAVE_CONFIGFILE \\\n\t   -DHAVE_PATCH \\\n\t   -DHAVE_SCREENSHOTS \\\n\t   -DHAVE_REWIND \\\n\t   -D__ARM_ARCH_6__ \\\n\t   -DHAVE_OPENGL \\\n\t   -DHAVE_OPENGLES \\\n\t   -DHAVE_OPENGLES2 \\\n\t   -DHAVE_GLSL \\\n\t   -DHAVE_DYNAMIC \\\n\t   -DHAVE_RPNG \\\n\t   -DHAVE_RJPEG \\\n\t   -DHAVE_OVERLAY \\\n\t   -DHAVE_ALSA \\\n\t   -DHAVE_ZLIB \\\n\t   -D__linux__ \\\n\t   -DHAVE_DSP_FILTER \\\n\t   -DHAVE_VIDEO_FILTER \\\n\t   -D__OPENPANDORA__ \\\n\t   -DPANDORA\nDEFINES += $(INCDIRS)\nDEFINES += -marm -march=armv7-a -mcpu=cortex-a8 -mtune=cortex-a8 -mfpu=neon -mfloat-abi=softfp -ftree-vectorize\n\nifeq ($(DEBUG), 1)\n   OPTIMIZE_LV\t:= -O0 -g\nelse\n   OPTIMIZE_LV\t:= -O3\nendif\n\nall: $(TARGET)\n\nCFLAGS := $(OPTIMIZE_LV) $(DEFINES)\n\n$(TARGET): $(OBJ)\n\t$(CC) -o $@ $(OBJ) $(LDFLAGS) $(LDDIRS) $(LIBS)\n\n%.o: %.S\n\t$(CC) $(CFLAGS) -c -o $@ $<\n\n%.o: %.c config.h\n\t$(CC) $(CFLAGS) -c -o $@ $<\n\nclean:\n\trm -f $(TARGET)\n\trm -f $(OBJ)\n\n.PHONY: clean\n"
        },
        {
          "name": "Makefile.orbis",
          "type": "blob",
          "size": 5.875,
          "content": "TARGET\t\t    := retroarch_orbis\nDEBUG               ?= 0\nGRIFFIN_BUILD        = 0\nWHOLE_ARCHIVE_LINK   = 0\n\nHAVE_STATIC_DUMMY ?= 0\nHAVE_GLES3 ?= 0\nHAVE_MOUSE ?= 0\nHAVE_KEYBOARD ?= 0\n\nPS4_TITLE_ID\t:= RETROARCH\nPS4_TITLE_NAME\t:= RetroArch\n\nPC_DEVELOPMENT_IP_ADDRESS  = 192.168.1.137\nPC_DEVELOPMENT_UDP_PORT\t   = 18194\n\nAUTH_INFO = 000000000000000000000000001C004000FF000000000080000000000000000000000000000000000000008000400040000000000000008000000000000000080040FFFF000000F000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\nOBJ += deps/xxHash/xxhash.o \\\n# \tinput/drivers/ps4_input.o \\\n# \tinput/drivers_joypad/ps4_joypad.o \\\n# \taudio/drivers/psp_audio.o \\\n# \tgfx/drivers_context/orbis_ctx.o \\\n# \tfrontend/drivers/platform_orbis.o\n\nifeq ($(HAVE_GLES3),1)\n  DEFINES += -DHAVE_OPENGLES3\nendif\n\nifeq ($(HAVE_STATIC_DUMMY),1)\n  DEFINES += -DHAVE_STATIC_DUMMY\nendif\n\nifeq ($(GRIFFIN_BUILD), 1)\n\tOBJ += griffin/griffin.o\n\tDEFINES += -DHAVE_GRIFFIN=1\n\tDEFINES += -DHAVE_MENU -DHAVE_LIBRETRODB -DHAVE_CONFIGFILE\n\tDEFINES += -DHAVE_ZLIB -DHAVE_RPNG -DHAVE_RJPEG -DHAVE_RBMP -DHAVE_RTGA -DHAVE_CC_RESAMPLER\n\tDEFINES += -DHAVE_CORE_INFO_CACHE\n\tifeq ($(DEBUG), 1)\n\t\tDEFINES += -DHAVE_NETLOGGER\n\tendif\nelse\n\n\tHAVE_FILTERS_BUILTIN\t:= 1\n\tHAVE_LANGEXTRA\t\t\t\t:= 1\n\tHAVE_IMAGEVIEWER \t\t\t:= 1\n\tHAVE_RPNG\t\t\t\t\t\t\t:= 1\n\tHAVE_RJPEG\t\t\t\t\t\t:= 1\n\tHAVE_RBMP\t\t\t\t\t\t\t:= 1\n\tHAVE_RTGA\t\t\t\t\t\t\t:= 1\n\tHAVE_ZLIB\t\t\t\t\t\t\t:= 1\n\tHAVE_BUILTINZLIB\t\t\t:= 1\n\tHAVE_OVERLAY\t\t\t\t\t:= 1\n\tHAVE_7ZIP\t\t\t\t\t\t\t:= 1\n\tHAVE_EGL \t\t\t\t\t\t\t:= 1\n\tHAVE_GFX_WIDGETS \t\t\t:= 1\n\tHAVE_GLSL      \t\t\t\t:= 1\n\tHAVE_SHADERPIPELINE  \t:= 1\n\tHAVE_OPENGL  \t\t\t\t\t:= 1\n\tHAVE_OPENGLES  \t\t\t\t:= 1\n\tHAVE_OPENGLES2  \t\t\t:= 1\n\tHAVE_NETWORKING\t\t\t\t:= 0\n\tHAVE_IFINFO\t\t\t\t:= 0\n\tHAVE_SOCKET_LEGACY\t\t:= 1\n\tHAVE_MENU\t\t\t\t\t\t\t:= 1\n\tHAVE_MENU_COMMON\t\t\t:= 1\n\tHAVE_RGUI\t\t\t\t\t\t\t:= 1\n\tHAVE_STB_FONT\t\t\t\t\t:= 1\n\tHAVE_STB_VORBIS\t\t\t\t:= 1\n\tHAVE_DR_FLAC\t\t\t\t\t:= 1\n\tHAVE_DR_MP3\t\t\t\t\t\t:= 1\n\tHAVE_MATERIALUI \t\t\t:= 1\n\tHAVE_XMB\t\t\t\t\t\t\t:= 1\n\tHAVE_OZONE\t\t\t\t\t\t:= 1\n\tHAVE_RGUI\t\t\t\t\t\t\t:= 1\n\tHAVE_THREADS\t\t\t\t\t:= 1\n\tHAVE_THREAD_ATTR\t\t\t:= 1\n\tHAVE_LIBRETRODB\t\t\t\t:= 1\n\tHAVE_CC_RESAMPLER\t\t\t:= 1\n\tHAVE_CHEEVOS\t\t\t\t\t:= 0\n\tHAVE_RUNAHEAD\t\t\t\t\t:= 1\n\tRARCH_CONSOLE\t\t\t\t\t:= 1\n\tHAVE_MAIN \t\t\t\t\t\t:= 1\n\tHAVE_ONLINE_UPDATER \t:= 1\n\tHAVE_COMPRESSION \t\t\t:= 1\n\tHAVE_UPDATE_ASSETS \t\t:= 1\n\tHAVE_UPDATE_CORES \t\t:= 1\n\tHAVE_UPDATE_CORE_INFO \t\t:= 1\n\tHAVE_CONFIGFILE \t\t\t:= 1\n\tHAVE_CHD \t\t\t\t\t\t\t:= 1\n\tHAVE_STATIC_VIDEO_FILTERS = 1\n\tHAVE_STATIC_AUDIO_FILTERS = 1\n\tHAVE_CORE_INFO_CACHE\t:= 1\n\n\tifeq ($(DEBUG), 1)\n\t\tHAVE_NETLOGGER = 1\n\tendif\n\n\tinclude Makefile.common\n\tCFLAGS += $(DEF_FLAGS)\n\tOBJ := $(filter-out $(BLACKLIST),$(OBJ))\nendif\n\nifeq ($(strip $(ORBISDEV)),)\n$(error \"Please set ORBISDEV in your environment. export ORBISDEV=<path to>orbisdev\")\nendif\n\nPREFIX := orbis-\nCC      := clang\nCXX     := clang++\nAS      := $(PREFIX)as\nAR      := $(PREFIX)ar\nOBJCOPY := $(PREFIX)objcopy\nSTRIP   := $(PREFIX)strip\nNM      := $(PREFIX)nm\nLD      := clang\n\nLIBDIRS += -L. -Lcores -Lbuild -L$(ORBISDEV)/usr/lib\nINCDIRS += -I. -Idefines -Ideps -Ideps/7zip -Ideps/libz -Ilibretro-common/include -Ideps/stb \\\n\t\t\t\t\t -Ilibretro-common/include/compat/zlib -Ideps/rcheevos/include -I$(ORBISDEV)/usr/include -I$(ORBISDEV)/usr/include/c++/v1 -I$(ORBISDEV)/usr/include/orbis\n\nARCHFLAGS += --target=x86_64-scei-ps4 -DORBIS -D__ORBIS__ -D__PS4__ -D_BSD_SOURCE\nDEFINES += -DRARCH_INTERNAL -DRARCH_CONSOLE -DHAVE_FILTERS_BUILTIN \\\n\t\t\t\t\t -DHAVE_XMB -DHAVE_RGUI -DHAVE_OZONE \\\n\t\t\t\t\t -DHAVE_ONLINE_UPDATER -DHAVE_UPDATE_CORES -DHAVE_UPDATE_CORE_INFO -DHAVE_UPDATE_ASSETS \\\n\n# Compiling with -Werror and disabling some warnings\nDEFINES += -Werror -Wno-macro-redefined -Wno-typedef-redefinition -Wno-non-literal-null-conversion -Wno-void-pointer-to-int-cast \\\n\t-Wno-format -Wno-tautological-constant-out-of-range-compare -Wno-implicit-function-declaration\n\nifeq ($(HAVE_KEYBOARD), 1)\n  DEFINES += -DHAVE_KEYBOARD\n  PS4_LIBS += -lSceDbgKeyboard_stub\nendif\n\nifeq ($(HAVE_MOUSE),1)\n  DEFINES += -DHAVE_MOUSE\n  PS4_LIBS += -lSceMouse_stub\nendif\n\nifneq ($(PC_DEVELOPMENT_IP_ADDRESS),)\n  DEFINES += -DPC_DEVELOPMENT_IP_ADDRESS='\"$(PC_DEVELOPMENT_IP_ADDRESS)\"'\nendif\n\nifneq ($(PC_DEVELOPMENT_UDP_PORT),)\n  DEFINES += -DPC_DEVELOPMENT_UDP_PORT=$(PC_DEVELOPMENT_UDP_PORT)\nendif\n\nifeq ($(WHOLE_ARCHIVE_LINK), 1)\n  WHOLE_START := --whole-archive\n  WHOLE_END := --no-whole-archive\nendif\n\nPS4_LIBS += -luser_mem_sys -lkernel_stub -lSceLibcInternal_stub -lunwind -lc++ -lc++abi -lc++experimental \\\n\t\t\t\t-lorbisLink -lkernelUtil -ldebugnet -lorbisNfs -lSceSysmodule_stub -lSceSystemService_stub -lSceNet_stub \\\n\t\t\t\t-lSceUserService_stub -lScePigletv2VSH_stub -lSceVideoOut_stub -lSceGnmDriver_stub -lorbisPad \\\n\t\t\t\t-lScePad_stub -lSceAudioOut_stub -lSceIme_stub -lSceNetCtl_stub -lSQLite\n\nifeq ($(HAVE_STATIC_DUMMY),1)\n  LIBS\t:= $(PS4_LIBS)\nelse\n  LIBS\t:= $(WHOLE_START) -lretro_orbis $(WHOLE_END) $(PS4_LIBS)\nendif\n\n\nCFLAGS   := $(ARCHFLAGS) $(INCDIRS) $(DEFINES)\nCXXFLAGS := $(ARCHFLAGS) $(INCDIRS) $(DEFINES)\nLDFLAGS  := $(LIBDIRS) -Wl,--gc-sections -Wl,-z -Wl,max-page-size=0x4000 -Wl,--dynamic-linker=\"/libexec/ld-elf.so.1\" -Wl,-pie -Wl,--eh-frame-hdr -target x86_64-scei-ps4-elf -T $(ORBISDEV)/usr/lib/linker.x\n\nifeq ($(DEBUG), 1)\n   CFLAGS += -O0 -fno-inline\n   CXXFLAGS += -O0 -fno-inline\nelse\n   CFLAGS += -O3\n   CXXFLAGS += -O3\nendif\n\nTARGETS := $(TARGET).self\n\nall: $(TARGETS)\n\nOBJOUT   = -o\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $(OBJOUT)$@ $<\n\n%.o: %.cpp\n\t$(CXX) $(CXXFLAGS) -c $(OBJOUT)$@ $<\n\n%.o: %.S\n\t$(CC) $(CFLAGS) -c $(OBJOUT)$@ $<\n\n%.o: %.s\n\t$(CC) -c $(OBJOUT)$@ $<\n\n$(TARGET).elf: $(OBJ)\n\t$(LD) $(ORBISDEV)/usr/lib/crt0.o $(OBJ) $(LDFLAGS) $(LIBS) -o $(TARGET).elf\n\n$(TARGET).oelf: $(TARGET).elf\n\t@orbis-elf-create $(TARGET).elf $(TARGET).oelf\n\n$(TARGET).self: $(TARGET).oelf\n\tpython $(ORBISDEV)/bin/make_fself.py --auth-info $(AUTH_INFO) $(TARGET).oelf $(TARGET).self\n\ninstall:\n\t@cp $(TARGET).self $(SELF_PATH_INSTALL)/homebrew.self\n\t@echo \"Installed!\"\n\nclean:\n\trm -f $(OBJ) $(TARGET).elf $(TARGET).oelf $(TARGET).self\n\n.PHONY: clean all\n"
        },
        {
          "name": "Makefile.orbis.salamander",
          "type": "blob",
          "size": 3.994140625,
          "content": "TARGET\t\t    := retroarch_orbis_salamander\n\nDEBUG               ?= 0\n\n\nPS4_TITLE_ID\t:= RETROARCH\nPS4_TITLE_NAME\t:= RetroArch\n\nPC_DEVELOPMENT_IP_ADDRESS  = 192.168.1.137\nPC_DEVELOPMENT_UDP_PORT\t   = 18194\n\nAUTH_INFO = 000000000000000000000000001C004000FF000000000080000000000000000000000000000000000000008000400040000000000000008000000000000000080040FFFF000000F000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\n\n\nendif\n\nifeq ($(strip $(ORBISDEV)),)\n$(error \"Please set ORBISDEV in your environment. export ORBISDEV=<path to>orbisdev\")\nendif\n\nPREFIX := orbis-\nCC      := clang\nCXX     := clang++\nAS      := $(PREFIX)as\nAR      := $(PREFIX)ar\nOBJCOPY := $(PREFIX)objcopy\nSTRIP   := $(PREFIX)strip\nNM      := $(PREFIX)nm\nLD      := clang\n\nLIBDIRS += -L. -Lcores -Lbuild -L$(ORBISDEV)/usr/lib\nINCDIRS += -I. -Idefines -Ilibretro-common/include -I$(ORBISDEV)/usr/include -I$(ORBISDEV)/usr/include/c++/v1 -I$(ORBISDEV)/usr/include/orbis\n\nARCHFLAGS += --target=x86_64-scei-ps4 -DORBIS -D__ORBIS__ -D__PS4__ -D_BSD_SOURCE\n\n\nDEFINES += -DORBIS -D__ORBIS__ -DIS_SALAMANDER -DRARCH_CONSOLE -D__PS4__ -D_BSD_SOURCE\n\n# Compiling with -Werror and disabling some warnings\nDEFINES += -Werror -Wno-macro-redefined -Wno-typedef-redefinition -Wno-non-literal-null-conversion -Wno-void-pointer-to-int-cast \\\n\t-Wno-format -Wno-tautological-constant-out-of-range-compare -Wno-implicit-function-declaration\n\nifeq ($(HAVE_FILE_LOGGER), 1)\n  DEFINES += -DHAVE_FILE_LOGGER\nendif\nifneq ($(PC_DEVELOPMENT_IP_ADDRESS),)\n  DEFINES += -DPC_DEVELOPMENT_IP_ADDRESS='\"$(PC_DEVELOPMENT_IP_ADDRESS)\"'\nendif\n\nifneq ($(PC_DEVELOPMENT_UDP_PORT),)\n  DEFINES += -DPC_DEVELOPMENT_UDP_PORT=$(PC_DEVELOPMENT_UDP_PORT)\nendif\n\nPS4_LIBS += -luser_mem_sys -lkernel_stub -lSceLibcInternal_stub -lunwind -lc++ -lc++abi -lc++experimental \\\n\t\t\t\t-lorbisLink -lkernelUtil -ldebugnet -lorbisNfs -lSceSysmodule_stub -lSceSystemService_stub -lSceNet_stub \\\n\t\t\t\t-lSceUserService_stub -lScePigletv2VSH_stub -lSceVideoOut_stub -lSceGnmDriver_stub -lorbisPad \\\n\t\t\t\t-lScePad_stub -lSceAudioOut_stub -lSceIme_stub -lSceNetCtl_stub -lSQLite\n\n\n  LIBS\t:= $(PS4_LIBS)\n\n\nCFLAGS   := $(ARCHFLAGS) $(INCDIRS) $(DEFINES)\nCXXFLAGS := $(ARCHFLAGS) $(INCDIRS) $(DEFINES)\nLDFLAGS  := $(LIBDIRS) -Wl,--gc-sections -Wl,-z -Wl,max-page-size=0x4000 -Wl,--dynamic-linker=\"/libexec/ld-elf.so.1\" -Wl,-pie -Wl,--eh-frame-hdr -target x86_64-scei-ps4-elf -T $(ORBISDEV)/usr/lib/linker.x\n\nifeq ($(DEBUG), 1)\n   CFLAGS += -O0 -fno-inline\n   CXXFLAGS += -O0 -fno-inline\nelse\n   CFLAGS += -O3\n   CXXFLAGS += -O3\nendif\n\nOBJS = frontend/frontend_salamander.o \\\n\t\t frontend/frontend_driver.o \\\n\t\t frontend/drivers/platform_orbis.o \\\n\t\t libretro-common/file/file_path.o \\\n\t\t libretro-common/file/file_path_io.o \\\n\t\t libretro-common/string/stdstring.o \\\n\t\t libretro-common/lists/string_list.o \\\n\t\t libretro-common/lists/dir_list.o \\\n\t\t libretro-common/file/retro_dirent.o \\\n\t\t libretro-common/encodings/encoding_utf.o \\\n\t\t libretro-common/compat/compat_strl.o \\\n\t\t libretro-common/compat/compat_strcasestr.o \\\n\t\t libretro-common/compat/fopen_utf8.o \\\n\t\t libretro-common/file/config_file.o \\\n\t\t libretro-common/streams/file_stream.o \\\n\t\t libretro-common/vfs/vfs_implementation.o \\\n\t\t libretro-common/hash/lrc_hash.o \\\n\t\t libretro-common/time/rtime.o \\\n         network/net_logger.o \\\n\t\t verbosity.o\n\nTARGETS := $(TARGET).elf\n\nall: $(TARGETS)\n\nOBJOUT   = -o\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $(OBJOUT)$@ $<\n\n%.o: %.cpp\n\t$(CXX) $(CXXFLAGS) -c $(OBJOUT)$@ $<\n\n%.o: %.S\n\t$(CC) $(CFLAGS) -c $(OBJOUT)$@ $<\n\n%.o: %.s\n\t$(CC) -c $(OBJOUT)$@ $<\n\n$(TARGET).elf: $(OBJ)\n\t$(LD) $(ORBISDEV)/usr/lib/crt0.o $(OBJ) $(LDFLAGS) $(LIBS) -o $(TARGET).elf\n\n$(TARGET).oelf: $(TARGET).elf\n\t@orbis-elf-create $(TARGET).elf $(TARGET).oelf\n\n$(TARGET).self: $(TARGET).oelf\n\tpython $(ORBISDEV)/bin/make_fself.py --auth-info $(AUTH_INFO) $(TARGET).oelf $(TARGET).self\n\ninstall:\n\t@cp $(TARGET).self $(SELF_PATH_INSTALL)/homebrew.self\n\t@echo \"Installed!\"\n\nclean:\n\trm -f $(OBJ) $(TARGET).elf $(TARGET).oelf $(TARGET).self\n\n.PHONY: clean all\n"
        },
        {
          "name": "Makefile.pandora",
          "type": "blob",
          "size": 1.1904296875,
          "content": "# Before using this Makefile, be sure to do:\n# $ source /usr/local/angstrom/arm/environment-setup\n# $ setprj retroarch\n\nPNDDIR=./pkg/pandora\nBINDIR=$(PNDDIR)/bin\n\nall: $(BINDIR)/retroarch\n\tmkdir -p $(PNDDIR)/lib\n\t@echo \"Put libretro-*.so files in $(PNDDIR)/lib/ before making pnd!\"\n\npnd: retroarch.pnd\n\ninstall: all $(BINDIR)/retroarch-zip $(PNDDIR)/readme.html\n\nretroarch:\n\t./configure --prefix=$PND_BASEDIR/$PRJ --disable-ffmpeg --disable-cg --disable-pulse --disable-jack --enable-opengles\n\tmake -f Makefile\n\n$(BINDIR)/retroarch: retroarch\n\tmkdir -p $(BINDIR)\n\tcp retroarch $(BINDIR)/retroarch\n\n$(BINDIR)/retroarch-zip: retroarch-zip\n\tmkdir -p $(BINDIR)\n\tcp retroarch-zip $(BINDIR)/retroarch-zip\n\n$(PNDDIR)/readme.html: README.md\n\tmarkdown README.md > $(PNDDIR)/readme.html\n\nretroarch.pnd: install\n\tpnd_make -c -p retroarch.pnd -d $(PNDDIR)/ -x $(PNDDIR)/PXML.xml -i $(PNDDIR)/icon.png\n\nclean:\n\trm -f *.o\n\trm -f audio/*.o\n\trm -f conf/*.o\n\trm -f gfx/*.o\n\trm -f gfx/drivers_font/*.o\n\trm -f gfx/drivers_font_renderer/*.o\n\trm -f gfx/drivers_context/*.o\n\trm -f gfx/py_state/*.o\n\trm -f compat/*.o\n\trm -f record/*.o\n\trm -f input/*.o\n\trm -f tools/*.o\n\trm -f $(BINDIR)/retroarch\n\trm -f $(PNDDIR)/readme.html\n\trm -f retroarch\n"
        },
        {
          "name": "Makefile.ps2",
          "type": "blob",
          "size": 3.0380859375,
          "content": "TARGET := retroarch_ps2\nTARGET_RELEASE = retroarchps2.elf\n\nBUILD_FOR_PCSX2    = 0\nDEBUG              = 0\nSCREEN_DEBUG       = 0\nGRIFFIN_BUILD      = 0\nHAVE_THREADS       = 0\nMUTE_WARNINGS      = 1\nWHOLE_ARCHIVE_LINK = 0\nHAVE_STATIC_DUMMY ?= 0\nPS2_IP = 192.168.1.10\n\nifeq ($(DEBUG), 1)\n   OPTIMIZE_LV\t:= -O0 -g\n\tDEFINES += -DDEBUG\nelse\n   OPTIMIZE_LV\t:= -O3\nendif\n\nifeq ($(MUTE_WARNINGS), 1)\n   DISABLE_WARNINGS := -Wno-unused -Wno-format -Wno-format-truncation\nendif\n\nifeq ($(HAVE_STATIC_DUMMY),1)\n  DEFINES += -DHAVE_STATIC_DUMMY\nelse\n  LIBS += -lretro_ps2\nendif\n\nifeq ($(SCREEN_DEBUG), 1)\nLIBS += -ldebug\nDEFINES += -DSCREEN_DEBUG\nendif\n\nifeq ($(BUILD_FOR_PCSX2), 1)\nDEFINES += -DBUILD_FOR_PCSX2\nendif\n\nDEFINES += -DRARCH_INTERNAL -DRARCH_CONSOLE\n\nifeq ($(GRIFFIN_BUILD), 1)\n\tOBJ += griffin/griffin.o\n\tDEFINES += -DHAVE_GRIFFIN=1 -DHAVE_SCREENSHOTS -DHAVE_REWIND -DHAVE_MENU -DHAVE_CONFIGFILE -DHAVE_PATCH -DHAVE_CHEATS\n\tDEFINES += -DHAVE_ZLIB -DHAVE_NO_BUILTINZLIB -DHAVE_RPNG -DHAVE_RJPEG -DHAVE_FILTERS_BUILTIN -DHAVE_7ZIP -D_7ZIP_ST -DHAVE_CC_RESAMPLER -DHAVE_AUDIOMIXER\n\tDEFINES += -DHAVE_VIDEO_FILTER -DHAVE_RGUI -DHAVE_WINDOW_OFFSET\n\tDEFINES += -DHAVE_DSP_FILTER\nelse\n\tHAVE_CC_RESAMPLER = 1\n\tHAVE_MENU_COMMON = 1\n\tHAVE_RPNG = 1\n\tHAVE_RJPEG = 1\n\tHAVE_RBMP = 1\n\tHAVE_MENU = 1\n\tHAVE_CONFIGFILE = 1\n\tHAVE_PATCH = 1\n\tHAVE_PATCH = 0 # disabled because <lzma.h> isn't available (or we haven't figured out how to install it)\n\tHAVE_CHEATS = 1\n\tHAVE_RGUI = 1\n\tHAVE_MATERIALUI = 0\n\tHAVE_XMB = 0\n\tHAVE_OZONE = 0\n\tHAVE_ZLIB = 1\n\tHAVE_NO_BUILTINZLIB = 1\n\tHAVE_7ZIP = 1\n\tHAVE_SCREENSHOTS = 1\n\tHAVE_REWIND = 1\n\tHAVE_AUDIOMIXER = 1\n\tHAVE_RWAV = 1\n\tHAVE_DSP_FILTER = 1\n\tHAVE_VIDEO_FILTER = 1\n\tHAVE_FILTERS_BUILTIN = 1\n\tHAVE_WINDOW_OFFSET = 1\n\n\tinclude Makefile.common\n\tCFLAGS += $(DEF_FLAGS)\n\tBLACKLIST :=\n\tOBJ := $(filter-out $(BLACKLIST),$(OBJ))\n\tINCDIRS += $(INCLUDE_DIRS)\nendif\n\nifeq ($(strip $(PS2SDK)),)\n$(error \"Please set PS2SDK in your environment. export PS2SDK=<path to>ps2sdk\")\nendif\n\nINCDIR = -I$(PS2DEV)/gsKit/include -I$(PS2SDK)/ports/include\nINCDIR += -Ilibretro-common/include -Ideps -Ideps/stb -Ideps/7zip\n\nLDFLAGS += -L$(PS2DEV)/gsKit/lib -L$(PS2SDK)/ports/lib -L.\n# Lib cdvd is needed to get proper time\nLIBS += -lpatches -lgskit -ldmakit -lps2_drivers -lz -lelf-loader\n\nCFLAGS = $(OPTIMIZE_LV) $(DISABLE_WARNINGS) $(DEFINES) -DPS2 -ffast-math -fsingle-precision-constant\nASFLAGS = $(CFLAGS)\n\nEE_OBJS += $(OBJ)\n\nEE_CFLAGS = $(CFLAGS)\nEE_CXXFLAGS = $(CFLAGS)\nEE_LDFLAGS = $(LDFLAGS)\nEE_LIBS = $(LIBS)\nEE_ASFLAGS = $(ASFLAGS)\nEE_INCS = $(INCDIR)\nEE_BIN = $(TARGET).elf\nEE_GPVAL = $(GPVAL)\n\nall: $(EE_BIN)\n\nclean:\n\trm -f $(EE_BIN) $(EE_OBJS)\n\nprepare:\n\tps2client -h $(PS2_IP) reset\n\tps2client -h $(PS2_IP) netdump\n\nrun:\n\tps2client -h $(PS2_IP) execee host:$(EE_BIN)\n\nsim:\nifeq ($(shell uname), Darwin)\n\t/Applications/PCSX2.app/Contents/MacOS/PCSX2 -elf $(PWD)/$(EE_BIN)\nelse\n\tPCSX2 -elf $(PWD)/$(EE_BIN) -nogui\nendif\n\ndebug: clean all run\n\nrelease: all\n\tps2-packer $(EE_BIN) $(TARGET_RELEASE)\n\n#Include preferences\ninclude $(PS2SDK)/samples/Makefile.pref\ninclude $(PS2SDK)/samples/Makefile.eeglobal_cpp\n"
        },
        {
          "name": "Makefile.ps2.salamander",
          "type": "blob",
          "size": 2.08984375,
          "content": "BUILD_FOR_PCSX2   = 0\nDEBUG             = 0\nSCREEN_DEBUG      = 0\nMUTE_WARNINGS     = 1\nPS2_IP = 192.168.1.150\n\nTARGET = raboot-debug.elf\nTARGET_RELEASE = raboot.elf\n\nifeq ($(DEBUG), 1)\n   OPTIMIZE_LV\t:= -O0 -g\n\tRARCH_DEFINES += -DDEBUG\nelse\n   OPTIMIZE_LV\t:= -O3\n\tLDFLAGS :=  -s\nendif\n\nifeq ($(MUTE_WARNINGS), 1)\n   DISABLE_WARNINGS := -Wno-unused -Wno-format -Wno-format-truncation\nendif\n\nINCDIR = -Ilibretro-common/include\nINCDIR += -I$(PS2SDK)/ports/include\nCFLAGS = $(OPTIMIZE_LV) $(DISABLE_WARNINGS) -ffast-math -fsingle-precision-constant\nASFLAGS = $(CFLAGS)\n\nRARCH_DEFINES += -DPS2 -DIS_SALAMANDER -DRARCH_CONSOLE\n\nLIBDIR =\nLDFLAGS += -L$(PS2SDK)/ports/lib\nLIBS = -lelf-loader -lps2_drivers -lpatches\n\nifeq ($(SCREEN_DEBUG), 1)\nLIBS += -ldebug\nRARCH_DEFINES += -DSCREEN_DEBUG\nendif\n\nifeq ($(BUILD_FOR_PCSX2), 1)\nRARCH_DEFINES += -DBUILD_FOR_PCSX2\nendif\n\nCFLAGS += $(RARCH_DEFINES)\n\nEE_OBJS = frontend/frontend_salamander.o \\\n\t\t frontend/frontend_driver.o \\\n\t\t frontend/drivers/platform_ps2.o \\\n\t\t libretro-common/file/file_path.o \\\n\t\t libretro-common/file/file_path_io.o \\\n\t\t libretro-common/string/stdstring.o \\\n\t\t libretro-common/lists/string_list.o \\\n\t\t libretro-common/lists/dir_list.o \\\n\t\t libretro-common/file/retro_dirent.o \\\n\t\t libretro-common/encodings/encoding_utf.o \\\n\t\t libretro-common/compat/fopen_utf8.o \\\n\t\t libretro-common/compat/compat_strl.o \\\n\t\t libretro-common/compat/compat_strldup.o \\\n\t\t libretro-common/compat/compat_strcasestr.o \\\n\t\t libretro-common/file/config_file.o \\\n\t\t libretro-common/streams/file_stream.o \\\n\t\t libretro-common/vfs/vfs_implementation.o \\\n\t\t libretro-common/hash/lrc_hash.o \\\n\t\t libretro-common/time/rtime.o \\\n\t\t verbosity.o\n\nEE_CFLAGS = $(CFLAGS)\nEE_CXXFLAGS = $(CFLAGS)\nEE_LDFLAGS = $(LDFLAGS)\nEE_LIBS = $(LIBS)\nEE_ASFLAGS = $(ASFLAGS)\nEE_INCS = $(INCDIR)\nEE_BIN = $(TARGET)\nEE_GPVAL = $(GPVAL)\n\nall: $(EE_BIN)\n\nclean:\n\trm -f $(EE_BIN) $(EE_OBJS)\n\ndebug: clean all run\n\nrun:\n\tps2client -h $(PS2_IP) execee host:$(EE_BIN)\n\nrelease: all\n\tps2-packer $(EE_BIN) $(TARGET_RELEASE)\n\n#Include preferences\ninclude $(PS2SDK)/samples/Makefile.pref\ninclude $(PS2SDK)/samples/Makefile.eeglobal_cpp\n"
        },
        {
          "name": "Makefile.psl1ght",
          "type": "blob",
          "size": 3.5810546875,
          "content": "#-------------------------------------------------------------------------------\n# Clear the implicit built in rules\n#-------------------------------------------------------------------------------\n.SUFFIXES:\n#-------------------------------------------------------------------------------\nifeq ($(strip $(PSL1GHT)),)\n$(error \"Please set PSL1GHT in your environment. export PSL1GHT=<path>\")\nendif\n \ninclude $(PSL1GHT)/ppu_rules\n\ninclude version.all\n\nDEBUG\t\t\t= 0\nHAVE_LOGGER\t\t= 0\nHAVE_FILE_LOGGER\t= 1\n\nPC_DEVELOPMENT_IP_ADDRESS\t= \"192.168.1.7\"\nPC_DEVELOPMENT_UDP_PORT\t\t= 3490\n\nCONTENTID\t\t= UP0001-SSNE10001_00-0000000000000001\nAPPID                   = SSNE10001\nTITLE                   = Retroarch PSL1GHT\nPACKAGE_BASENAME := retroarch_psl1ght\n\nELF_TARGET  := retroarch_psl1ght.elf\nSELF_TARGET := $(ELF_TARGET:.elf=.self)\nCORE_PATH    = pkg/psl1ght/pkg/USRDIR/cores/CORE.SELF\n\nINCLUDE += -I. -Ideps -Ideps/stb -Ilibretro-common/include/compat/zlib -Ilibretro-common/include $(LIBPSL1GHT_INC) -Iinclude -Idefines -I$(PORTLIBS)/include -I$(PORTLIBS)/include/freetype2\nLIBDIRS += -L. -L$(PORTLIBS)/lib\n\nMACHDEP := -D__PSL1GHT__ -D__PS3__ -mcpu=cell\nCFLAGS += -Wall $(MACHDEP) $(INCLUDE)\nLDFLAGS := $(MACHDEP)\nLIBS := -lretro_psl1ght -lrt -laudio -lrsx -lgcm_sys -lnet -lio -lsysutil -lsysmodule -lm -ljpgdec -lpngdec -llv2 -lnet -lnetctl -lsysfs -lfreetype -lcamera -lgem -lspurs\n\n# system platform\nsystem_platform = unix\nifeq ($(shell uname -a),)\nEXE_EXT = .exe\n   system_platform = win\nelse ifneq ($(findstring Darwin,$(shell uname -a)),)\n   system_platform = osx\nelse ifneq ($(findstring MINGW,$(shell uname -a)),)\n   system_platform = win\nendif\n\nPKG_SCRIPT\t\t= tools/ps3/ps3py/pkg.py\nifeq ($(shell uname), Linux)\nGIT\t\t\t= git\nelse\nGIT\t\t\t= git.exe\nendif\n\nSHADER_OBJS = gfx/drivers/rsx_shaders/modern_opaque.vpo.o \\\n              gfx/drivers/rsx_shaders/modern_opaque.fpo.o \\\n              gfx/drivers/rsx_shaders/modern_alpha_blend.vpo.o \\\n              gfx/drivers/rsx_shaders/modern_alpha_blend.fpo.o\n\nLIBCO_OBJ = libretro-common/libco/ps3.o\n\nOBJ = $(SHADER_OBJS) $(LIBCO_OBJ) libretro-common/memmap/memmap.o griffin/griffin.o\n\nifeq ($(HAVE_LOGGER), 1)\nCFLAGS\t\t+= -DHAVE_LOGGER\nendif\n\nifeq ($(HAVE_FILE_LOGGER), 1)\nCFLAGS\t\t+= -DHAVE_FILE_LOGGER\nendif\n\nSHARED_FLAGS :=\n\nSHARED_FLAGS += -DHAVE_GCM\nSHARED_FLAGS += -DHAVE_MENU \\\n\t\t-DHAVE_CONFIGFILE \\\n\t\t-DHAVE_PATCH \\\n\t\t-DHAVE_CHEATS \\\n\t\t-DRARCH_CONSOLE \\\n\t\t-DHAVE_OVERLAY \\\n\t\t-DHAVE_HEADSET \\\n\t\t-DHAVE_SYSMODULES \\\n\t\t-DHAVE_SYSUTILS \\\n\t\t-DHAVE_RARCH_EXEC \\\n\t\t-DHAVE_MOUSE \\\n\t\t-DHAVE_LIGHTGUN \\\n\t\t-DHAVE_ZLIB \\\n\t\t-DHAVE_RPNG \\\n\t\t-DHAVE_GRIFFIN=1 \\\n\t\t-DHAVE_NETWORKING=1 \\\n\t\t-DHAVE_SOCKET_LEGACY=1 \\\n\t\t-DPC_DEVELOPMENT_IP_ADDRESS=\\\"$(PC_DEVELOPMENT_IP_ADDRESS)\\\" \\\n\t\t-DPC_DEVELOPMENT_UDP_PORT=$(PC_DEVELOPMENT_UDP_PORT) \\\n\t\t-Wno-char-subscripts \\\n\t\t-DHAVE_CC_RESAMPLER \\\n\t\t-DRARCH_INTERNAL \\\n\t\t-DHAVE_SCREENSHOTS \\\n\t\t-DHAVE_REWIND \\\n\t\t-DHAVE_MULTIMAN \\\n\t\t-DHAVE_MEMINFO \\\n\t\t-DHAVE_RGUI \\\n\t\t-DHAVE_XMB \\\n\t\t-DHAVE_OZONE \\\n\t\t-DHAVE_GFX_WIDGETS \\\n\t\t-DHAVE_MENU_BUFFER \\\n\t\t-DHAVE_FREETYPE \\\n\t\t-DHAVE_CORE_INFO_CACHE \\\n\t\t-DHAVE_7ZIP \\\n\t\t-D_7ZIP_ST\n\nCFLAGS += -std=gnu99 $(SHARED_FLAGS)\nCXXFLAGS += $(SHARED_FLAGS)\n\nifeq ($(DEBUG), 1)\n   CFLAGS += -O0 -g\nelse\n   CFLAGS += -O3 -g\n   CXXFLAGS += -03 -g\nendif\n\nall: $(SELF_TARGET)\n\n$(ELF_TARGET): $(OBJ)\n\t$(CXX) -o $@ $(LDFLAGS) $(LIBDIRS) $(OBJ) $(LIBS)\n\ncreate-core: $(SELF_TARGET)\n\tcp $(SELF_TARGET) $(CORE_PATH) \n\npkg: create-core\n\t$(PKG) --contentid $(CONTENTID) pkg/psl1ght/pkg/ $(PACKAGE_BASENAME).pkg\n#\tcp $(PACKAGE_BASENAME).pkg $(PACKAGE_BASENAME).gnpdrm.pkg\n#\t$(PACKAGE_FINALIZE) $(PACKAGE_BASENAME).gnpdrm.pkg\n\nclean:\n\trm -f $(ELF_TARGET)\n\trm -f $(OBJ)\n\n.PHONY: clean\n"
        },
        {
          "name": "Makefile.psl1ght.salamander",
          "type": "blob",
          "size": 3.77734375,
          "content": "#-------------------------------------------------------------------------------\n# Clear the implicit built in rules\n#-------------------------------------------------------------------------------\n.SUFFIXES:\n#-------------------------------------------------------------------------------\nifeq ($(strip $(PSL1GHT)),)\n$(error \"Please set PSL1GHT in your environment. export PSL1GHT=<path>\")\nendif\n \ninclude $(PSL1GHT)/ppu_rules\n\ninclude version.all\n\nDEBUG\t\t\t= 0\nHAVE_LOGGER\t\t= 0\nHAVE_FILE_LOGGER\t= 1\n\nPC_DEVELOPMENT_IP_ADDRESS\t= \"192.168.1.7\"\nPC_DEVELOPMENT_UDP_PORT\t\t= 3490\n\nCONTENTID\t\t= UP0001-SSNE10001_00-0000000000000001\nAPPID                   = SSNE10001\nTITLE                   = Retroarch PSL1GHT\nPACKAGE_BASENAME := retroarch_psl1ght\n\nELF_TARGET := retroarch_psl1ght_salamander.elf\nELF_TARGET_NONSTRIPPED := retroarch_psl1ght_salamander_nonstripped.elf\nEBOOT_PATH\t\t= pkg/psl1ght/pkg/USRDIR/EBOOT.BIN\n\nINCLUDE += -I. -Ideps -Ideps/stb -Ilibretro-common/include/compat/zlib \\\n\t   -Ilibretro-common/include $(LIBPSL1GHT_INC) -Iinclude -Idefines\nLIBDIRS += -L.\n\nMACHDEP := -D__PS3__ -D__PSL1GHT__ -mcpu=cell -mhard-float -fmodulo-sched -ffunction-sections -fdata-sections\nCFLAGS += -Wall $(MACHDEP) $(INCLUDE)\nLDFLAGS := $(MACHDEP)\nLIBS :=  -lgcm_sys -lrsx -lsysutil -lio -lnet -lsysmodule -lrt -llv2 -lm -lsysfs\n\n# system platform\nsystem_platform = unix\nifeq ($(shell uname -a),)\nEXE_EXT = .exe\n   system_platform = win\nelse ifneq ($(findstring Darwin,$(shell uname -a)),)\n   system_platform = osx\nelse ifneq ($(findstring MINGW,$(shell uname -a)),)\n   system_platform = win\nendif\n\nPKG_SCRIPT\t\t= tools/ps3/ps3py/pkg.py\nifeq ($(shell uname), Linux)\nGIT\t\t\t= git\nelse\nGIT\t\t\t= git.exe\nendif\n\nOBJ\t\t= frontend/frontend_salamander.o \\\n\t\t\t\t  frontend/frontend_driver.o \\\n\t\t\t\t  frontend/drivers/platform_ps3.o \\\n\t\t\t\t  libretro-common/file/file_path.o \\\n\t\t\t\t  libretro-common/file/file_path_io.o \\\n\t\t\t\t  libretro-common/lists/dir_list.o \\\n\t\t\t\t  libretro-common/lists/string_list.o \\\n\t\t\t\t  libretro-common/file/retro_dirent.o \\\n\t\t\t\t  libretro-common/hash/lrc_hash.o \\\n\t\t\t\t  libretro-common/string/stdstring.o \\\n\t\t\t\t  libretro-common/encodings/encoding_utf.o \\\n\t\t\t\t  libretro-common/compat/compat_strl.o \\\n\t\t\t\t  libretro-common/compat/compat_strldup.o \\\n\t\t\t\t  libretro-common/compat/compat_strcasestr.o \\\n\t\t\t\t  libretro-common/compat/fopen_utf8.o \\\n\t\t\t\t  libretro-common/streams/file_stream.o \\\n\t\t\t\t  libretro-common/vfs/vfs_implementation.o \\\n\t\t\t\t  libretro-common/file/config_file.o \\\n\t\t\t\t  libretro-common/time/rtime.o \\\n\t\t\t\t  verbosity.o\n\nifeq ($(HAVE_LOGGER), 1)\nCFLAGS\t\t+= -DHAVE_LOGGER\nendif\n\nifeq ($(HAVE_FILE_LOGGER), 1)\nCFLAGS\t\t+= -DHAVE_FILE_LOGGER\nendif\n\nSHARED_FLAGS :=\n\nSHARED_FLAGS += -DHAVE_MENU -DHAVE_CONFIGFILE -DRARCH_CONSOLE -DHAVE_OVERLAY -DHAVE_HEADSET -DHAVE_CG -DHAVE_CG_RUNTIME_COMPILER -DHAVE_SYSMODULES -DHAVE_SYSUTILS -DHAVE_RARCH_EXEC -DHAVE_MOUSE  -DHAVE_ZLIB -DHAVE_RPNG -DHAVE_GRIFFIN=1 -DHAVE_NETWORKING=1 -DHAVE_SOCKET_LEGACY=1 -DPC_DEVELOPMENT_IP_ADDRESS=\\\"$(PC_DEVELOPMENT_IP_ADDRESS)\\\" -DPC_DEVELOPMENT_UDP_PORT=$(PC_DEVELOPMENT_UDP_PORT) -Wno-char-subscripts -DHAVE_CC_RESAMPLER -DHAVE_MULTIMAN -DHAVE_RGUI -DIS_SALAMANDER -DHAVE_GCM\nCFLAGS += -std=gnu99 $(SHARED_FLAGS)\nCXXFLAGS += $(SHARED_FLAGS)\n\nifeq ($(DEBUG), 1)\n   CFLAGS += -O0 -g\nelse\n   CFLAGS += -O3 -g\n   CXXFLAGS += -03 -g\nendif\n\nall: create-salamander\n\n$(ELF_TARGET_NONSTRIPPED): $(OBJ)\n\t$(CXX) -o $@ $(LDFLAGS) $(LIBDIRS) $(OBJ) $(LIBS)\n\n$(ELF_TARGET): $(ELF_TARGET_NONSTRIPPED)\n\t$(STRIP) $< -o $@\n\t$(SPRX) $@\n\ncreate-salamander: $(ELF_TARGET)\n\t$(SELF_NPDRM) $(ELF_TARGET) $(EBOOT_PATH) $(CONTENTID)\n\npkg: create-salamander\n\t$(PKG) --contentid $(CONTENTID) pkg/psl1ght/pkg/ $(PACKAGE_BASENAME).pkg\n#\tcp $(PACKAGE_BASENAME).pkg $(PACKAGE_BASENAME).gnpdrm.pkg\n#\t$(PACKAGE_FINALIZE) $(PACKAGE_BASENAME).gnpdrm.pkg\n\nclean:\n\trm -f $(ELF_TARGET)\n\trm -f $(OBJ)\n\n.PHONY: clean\n"
        },
        {
          "name": "Makefile.psp1",
          "type": "blob",
          "size": 2.056640625,
          "content": "BUILD_PRX              ?= 0\nPSP_LARGE_MEMORY       ?= 1\nDEBUG                  ?= 0\nHAVE_KERNEL_PRX        ?= 1\nHAVE_THREADS           ?= 1\nBIG_STACK              ?= 0\nLOAD_WITHOUT_CORE_INFO ?= 0\nHAVE_STATIC_DUMMY      ?= 0\nHAVE_XDELTA            ?= 1\nTARGET = retroarchpsp\n\nifeq ($(DEBUG), 1)\n   OPTIMIZE_LV\t:= -O0 -g\nelse\n   OPTIMIZE_LV\t:= -O3\nendif\n\nINCDIR = deps deps/stb deps/7zip libretro-common/include libretro-common/include/compat/zlib\nCFLAGS = $(OPTIMIZE_LV) -ffast-math -fsingle-precision-constant\nASFLAGS = $(CFLAGS)\n\nRARCH_DEFINES = -DPSP \\\n\t\t-D_MIPS_ARCH_ALLEGREX \\\n\t\t-DHAVE_ZLIB \\\n\t\t-DHAVE_AUDIOMIXER \\\n\t\t-DHAVE_RWAV \\\n\t\t-DHAVE_RPNG \\\n\t\t-DHAVE_RJPEG \\\n\t\t-DHAVE_GRIFFIN=1 \\\n\t\t-DRARCH_INTERNAL \\\n\t\t-DHAVE_SCREENSHOTS \\\n\t\t-DHAVE_REWIND \\\n\t\t-DRARCH_CONSOLE \\\n\t\t-DHAVE_MENU \\\n\t\t-DHAVE_CONFIGFILE \\\n\t\t-DHAVE_PATCH \\\n\t\t-DHAVE_CHEATS \\\n\t\t-DHAVE_RGUI \\\n\t\t-DHAVE_FILTERS_BUILTIN \\\n\t\t-DHAVE_DSP_FILTER \\\n\t\t-DHAVE_VIDEO_FILTER \\\n\t\t-DHAVE_7ZIP \\\n\t\t-D_7ZIP_ST \\\n\t\t-DHAVE_CC_RESAMPLER \\\n\t\t-DHAVE_CORE_INFO_CACHE\n\nLIBDIR =\nLDFLAGS = -L$(shell psp-config --psp-prefix)\n\nifeq ($(HAVE_STATIC_DUMMY),1)\n  RARCH_DEFINES += -DHAVE_STATIC_DUMMY\nelse\n  LIBS += -lretro_psp1\nendif\nLIBS += -lstdc++ -lpspgu -lpspgum -lpspaudio -lpspfpu -lpsppower -lpsprtc -lpthread\n\nifeq ($(HAVE_THREADS), 1)\nRARCH_DEFINES += -DHAVE_THREADS\nendif\n\nifeq ($(HAVE_KERNEL_PRX), 1)\nOBJS += bootstrap/psp1/kernel_functions.o\nCFLAGS += -DHAVE_KERNEL_PRX\nendif\n\nifeq ($(BIG_STACK), 1)\nCFLAGS += -DBIG_STACK\nendif\n\nifeq ($(LOAD_WITHOUT_CORE_INFO),1)\nRARCH_DEFINES += -DLOAD_WITHOUT_CORE_INFO\nendif\n\nCFLAGS += $(RARCH_DEFINES)\n\nEXTRA_TARGETS = EBOOT.PBP\nPSP_EBOOT_TITLE = RetroArch PSP1\n\nOBJS += griffin/griffin.o\n\nPSPSDK=$(shell psp-config --pspsdk-path)\ninclude $(PSPSDK)/lib/build.mak\n\npspsh-debug:\n\tpspsh -e reset\n\tread -p \"Start debugger in VSCode and press any key to continue... \\n\" -n1 -s\n\tpspsh -e debug ./retroarchpsp.prx\n\tpspsh\n\npspsh-run:\n\tpspsh -e reset\n\tpspsh -e ./retroarchpsp.prx\n\tpspsh\n\ndebug: clean all pspsh-debug\n\nrun: clean all pspsh-run\n\nsim:\n\t/Applications/PPSSPPSDL.app/Contents/MacOS/PPSSPPSDL $(shell pwd)/EBOOT.PBP\n"
        },
        {
          "name": "Makefile.psp1.salamander",
          "type": "blob",
          "size": 1.5283203125,
          "content": "BUILD_PRX         = 0\nPSP_LARGE_MEMORY  = 1\nHAVE_KERNEL_PRX   = 1\nDEBUG             = 0\n\nTARGET = retroarchpsp_salamander\n\nifeq ($(DEBUG), 1)\n   OPTIMIZE_LV\t:= -O0 -g\nelse\n   OPTIMIZE_LV\t:= -O3\nendif\n\nINCDIR = $(PSPPATH)/include libretro-common/include\nCFLAGS = $(OPTIMIZE_LV) -ffast-math -fsingle-precision-constant\nASFLAGS = $(CFLAGS)\n\nRARCH_DEFINES = -DPSP -DIS_SALAMANDER -DRARCH_CONSOLE\n\nLIBDIR =\nLDFLAGS =\nLIBS = -lstdc++ -lpsppower\n\nCFLAGS += $(RARCH_DEFINES)\n\nEXTRA_TARGETS   = EBOOT.PBP\nPSP_EBOOT_TITLE = RetroArch\nPSP_EBOOT_ICON  = pkg/psp1/ICON0.PNG\nPSP_EBOOT_PIC1  = pkg/psp1/PIC1.PNG\n\nOBJS = frontend/frontend_salamander.o \\\n\t\t frontend/frontend_driver.o \\\n\t\t frontend/drivers/platform_psp.o \\\n\t\t libretro-common/file/file_path.o \\\n\t\t libretro-common/file/file_path_io.o \\\n\t\t libretro-common/string/stdstring.o \\\n\t\t libretro-common/lists/string_list.o \\\n\t\t libretro-common/lists/dir_list.o \\\n\t\t libretro-common/file/retro_dirent.o \\\n\t\t libretro-common/encodings/encoding_utf.o \\\n\t\t libretro-common/compat/fopen_utf8.o \\\n\t\t libretro-common/compat/compat_strl.o \\\n\t\t libretro-common/compat/compat_strldup.o \\\n\t\t libretro-common/compat/compat_strcasestr.o \\\n\t\t libretro-common/file/config_file.o \\\n\t\t libretro-common/streams/file_stream.o \\\n\t\t libretro-common/vfs/vfs_implementation.o \\\n\t\t libretro-common/hash/lrc_hash.o \\\n\t\t libretro-common/time/rtime.o \\\n\t\t verbosity.o\n\nifeq ($(HAVE_KERNEL_PRX), 1)\nOBJS   += bootstrap/psp1/kernel_functions.o\nCFLAGS += -DHAVE_KERNEL_PRX\nendif\n\nPSPSDK=$(shell psp-config --pspsdk-path)\ninclude $(PSPSDK)/lib/build.mak\n"
        },
        {
          "name": "Makefile.retrofw",
          "type": "blob",
          "size": 5.6123046875,
          "content": "#########################\n## Toolchain variables ##\n#########################\n\n# Default toolchain directory\nTOOLCHAIN_DIR=/opt/retrofw-toolchain\n\n# All toolchain-related variables may be\n# overridden via the command line\nifdef RETROFW_CC\nCC                    = $(GCW0_CC)\nelse\nCC                    = $(TOOLCHAIN_DIR)/usr/bin/mipsel-linux-gcc\nendif\n\nifdef RETROFW_CXX\nCXX                   = $(GCW0_CXX)\nelse\nCXX                   = $(TOOLCHAIN_DIR)/usr/bin/mipsel-linux-g++\nendif\n\nifdef RETROFW_STRIP\nSTRIP                 = $(GCW0_STRIP)\nelse\nSTRIP                 = $(TOOLCHAIN_DIR)/usr/bin/mipsel-linux-strip\nendif\n\nGCW0_SDL_CONFIG      ?= $(TOOLCHAIN_DIR)/usr/mipsel-buildroot-linux-uclibc/sysroot/usr/bin/sdl-config\nGCW0_FREETYPE_CONFIG ?= $(TOOLCHAIN_DIR)/usr/mipsel-buildroot-linux-uclibc/sysroot/usr/bin/freetype-config\n#GCW0_MK_SQUASH_FS    ?= $(TOOLCHAIN_DIR)/usr/bin/mksquashfs\nGCW0_MK_SQUASH_FS    ?= mksquashfs\n\nGCW0_INC_DIR         ?= $(TOOLCHAIN_DIR)/usr/mipsel-buildroot-linux-uclibc/sysroot/usr/include\nGCW0_LIB_DIR         ?= $(TOOLCHAIN_DIR)/usr/mipsel-buildroot-linux-uclibc/sysroot/usr/lib\n\n#########################\n#########################\n\nPACKAGE_NAME = retroarch\nRETROFW = 1\n\nDEBUG ?= 0\n\nDINGUX = 1\nHAVE_SCREENSHOTS = 0\nHAVE_REWIND = 1\nHAVE_7ZIP = 1\nHAVE_AL = 0\n# ALSA freezes when switching back from menu\nHAVE_ALSA = 0\nHAVE_DSP_FILTER = 1\nHAVE_VIDEO_FILTER = 1\nHAVE_STATIC_VIDEO_FILTERS = 1\nHAVE_STATIC_AUDIO_FILTERS = 1\nHAVE_FILTERS_BUILTIN\t= 1\nHAVE_BUILTINMBEDTLS = 0\nHAVE_BUILTINZLIB = 1\nHAVE_C99 = 1\nHAVE_CC = 1\nHAVE_CC_RESAMPLER = 1\nHAVE_CHD = 1\nHAVE_COMMAND = 0\nHAVE_CXX = 1\nHAVE_DR_MP3 = 1\nHAVE_DYNAMIC = 1\nHAVE_EGL = 0\nHAVE_FREETYPE = 0\nHAVE_GDI = 1\nHAVE_GETADDRINFO = 0\nHAVE_GETOPT_LONG = 1\nHAVE_GLSL = 0\nHAVE_HID = 0\nHAVE_IBXM = 1\nHAVE_IMAGEVIEWER = 1\nHAVE_LANGEXTRA = 0\nHAVE_LIBRETRODB = 1\nHAVE_MENU = 1\nHAVE_MENU_COMMON = 1\nHAVE_GFX_WIDGETS = 0\nHAVE_MMAP = 1\nHAVE_OPENDINGUX_FBDEV = 0\nHAVE_OPENGL = 0\nHAVE_OPENGL1 = 0\nHAVE_OPENGLES = 0\nHAVE_OPENGLES3 = 0\nHAVE_OPENGL_CORE = 0\nHAVE_OPENSSL = 1\nHAVE_OVERLAY = 0\nHAVE_RBMP = 1\nHAVE_RJPEG = 1\nHAVE_RPILED = 0\nHAVE_RPNG = 1\nHAVE_RUNAHEAD = 0\nHAVE_SDL_DINGUX = 1\nHAVE_SHADERPIPELINE = 0\nHAVE_STB_FONT = 0\nHAVE_STB_IMAGE = 1\nHAVE_STB_VORBIS = 1\nHAVE_STDIN_CMD = 0\nHAVE_STRCASESTR = 1\nHAVE_THREADS = 1\nHAVE_UDEV = 0\nHAVE_RGUI = 1\nHAVE_MATERIALUI = 0\nHAVE_XMB = 0\nHAVE_OZONE = 0\nHAVE_ZLIB = 1\nHAVE_CONFIGFILE = 1\nHAVE_PATCH = 1\nHAVE_XDELTA = 0 # disabled because <lzma.h> isn't available (or we haven't figured out how to install it)\nHAVE_CHEATS = 1\nHAVE_CHEEVOS = 0\nHAVE_LIBSHAKE = 0\nHAVE_CORE_INFO_CACHE = 1\nHAVE_OSS =1\n\nOS = Linux\nTARGET = retroarch\nOPK_NAME = retroarch_retrofw.opk\n\nOBJ :=\nLINK := $(CXX)\nDEF_FLAGS := -march=mips32 -mtune=mips32 -mhard-float -ffast-math -fomit-frame-pointer\nDEF_FLAGS += -mplt -mno-shared\nDEF_FLAGS += -ffunction-sections -fdata-sections\nDEF_FLAGS += -I. -Ideps -Ideps/stb -DDINGUX=1 -DRETROFW=1 -MMD\nDEF_FLAGS += -Wall -Wno-unused-variable -flto\nDEF_FLAGS += -std=gnu99 -D_GNU_SOURCE\nLIBS := -ldl -lz -lrt -pthread\nCFLAGS :=\nCXXFLAGS := -fno-exceptions -fno-rtti -std=c++11 -D__STDC_CONSTANT_MACROS\nASFLAGS :=\nLDFLAGS := -Wl,--gc-sections\nINCLUDE_DIRS = -I$(GCW0_INC_DIR)\nLIBRARY_DIRS = -L$(GCW0_LIB_DIR)\nDEFINES := -DRARCH_INTERNAL -D_FILE_OFFSET_BITS=64 -UHAVE_STATIC_DUMMY\nDEFINES += -DHAVE_C99=1 -DHAVE_CXX=1\nDEFINES += -DHAVE_GETOPT_LONG=1 -DHAVE_STRCASESTR=1 -DHAVE_DYNAMIC=1\nDEFINES += -DHAVE_FILTERS_BUILTIN\nDEFINES += -DHAVE_OSS=1\n\nSDL_DINGUX_CFLAGS := $(shell $(GCW0_SDL_CONFIG) --cflags)\nSDL_DINGUX_LIBS := $(shell $(GCW0_SDL_CONFIG) --libs)\nFREETYPE_CFLAGS := $(shell $(GCW0_FREETYPE_CONFIG) --cflags)\nFREETYPE_LIBS := $(shell $(GCW0_FREETYPE_CONFIG) --libs)\nMMAP_LIBS = -lc\n\nOBJDIR_BASE := obj-unix\n\nifeq ($(DEBUG), 1)\n   OBJDIR := $(OBJDIR_BASE)/debug\n   DEF_FLAGS += -O0 -g -DDEBUG -D_DEBUG\nelse\n   OBJDIR := $(OBJDIR_BASE)/release\n   DEF_FLAGS += -O2 -DNDEBUG\nendif\n\ninclude Makefile.common\n\nDEF_FLAGS += $(INCLUDE_DIRS)\nLDFLAGS += $(CFLAGS) $(CXXFLAGS) $(DEF_FLAGS)\nCFLAGS += $(DEF_FLAGS)\nCXXFLAGS += $(DEF_FLAGS)\n\nHEADERS = $(wildcard */*/*.h) $(wildcard */*.h) $(wildcard *.h)\n\nQ := @\n\nRARCH_OBJ := $(addprefix $(OBJDIR)/,$(OBJ))\n\ndefine DESKTOP_ENTRY\n[Desktop Entry]\nName=RetroArch\nComment=Frontend for emulators, game engines\nExec=retroarch\nTerminal=false\nType=Application\nStartupNotify=true\nIcon=retroarch\nCategories=emulators;\nX-OD-NeedsDownscaling=true\nendef\nexport DESKTOP_ENTRY\n\n\nall: $(TARGET) opk\n\n-include $(RARCH_OBJ:.o=.d)\n\nSYMBOL_MAP := -Wl,-Map=output.map\n\n$(TARGET): $(RARCH_OBJ)\n\t@$(if $(Q), $(shell echo echo LD $@),)\n\t$(Q)$(LINK) -o $@ $(RARCH_OBJ) $(LIBS) $(LDFLAGS) $(LIBRARY_DIRS)\n\n$(OBJDIR)/%.o: %.c\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CC $<),)\n\t$(Q)$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) -c -o $@ $<\n\n$(OBJDIR)/%.o: %.cpp\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CXX $<),)\n\t$(Q)$(CXX) $(CPPFLAGS) $(CXXFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.m\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo OBJC $<),)\n\t$(Q)$(CXX) $(OBJCFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.S $(HEADERS)\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo AS $<),)\n\t$(Q)$(CC) $(CFLAGS) $(ASFLAGS) $(DEFINES) -c -o $@ $<\n\nclean:\n\trm -rf $(OBJDIR_BASE)\n\trm -f $(TARGET)\n\trm -f *.d\n\trm -rf $(OPK_NAME)\n\nopk: $(TARGET)\n\techo \"$$DESKTOP_ENTRY\" > default.retrofw.desktop\n\trm -f $(OPK_NAME)\n\tcp media/ico_src/icon32.png retroarch.png\n\tchmod +x retroarch\n\tchmod 777 retroarch\nifeq ($(STRIP_BIN),1)\n\t$(STRIP) --strip-unneeded retroarch\nendif\n\t$(GCW0_MK_SQUASH_FS) retroarch default.retrofw.desktop retroarch.png $(OPK_NAME) -all-root -no-xattrs -noappend -no-exports\n\trm -f default.retrofw.desktop retroarch.png\n\n.PHONY: all clean opk\n\nprint-%:\n\t@echo '$*=$($*)'\n"
        },
        {
          "name": "Makefile.rg350",
          "type": "blob",
          "size": 5.4619140625,
          "content": "#########################\n## Toolchain variables ##\n#########################\n\n# Default toolchain directory\nTOOLCHAIN_DIR=/opt/gcw0-toolchain\n\n# All toolchain-related variables may be\n# overridden via the command line\nifdef GCW0_CC\nCC                    = $(GCW0_CC)\nelse\nCC                    = $(TOOLCHAIN_DIR)/usr/bin/mipsel-gcw0-linux-uclibc-gcc\nendif\n\nifdef GCW0_CXX\nCXX                   = $(GCW0_CXX)\nelse\nCXX                   = $(TOOLCHAIN_DIR)/usr/bin/mipsel-gcw0-linux-uclibc-g++\nendif\n\nifdef GCW0_STRIP\nSTRIP                 = $(GCW0_STRIP)\nelse\nSTRIP                 = $(TOOLCHAIN_DIR)/usr/bin/mipsel-gcw0-linux-uclibc-strip\nendif\n\nGCW0_SDL_CONFIG      ?= $(TOOLCHAIN_DIR)/usr/mipsel-gcw0-linux-uclibc/sysroot/usr/bin/sdl-config\nGCW0_FREETYPE_CONFIG ?= $(TOOLCHAIN_DIR)/usr/mipsel-gcw0-linux-uclibc/sysroot/usr/bin/freetype-config\nGCW0_MK_SQUASH_FS    ?= $(TOOLCHAIN_DIR)/usr/bin/mksquashfs\n\nGCW0_INC_DIR         ?= $(TOOLCHAIN_DIR)/usr/mipsel-gcw0-linux-uclibc/sysroot/usr/include\nGCW0_LIB_DIR         ?= $(TOOLCHAIN_DIR)/usr/mipsel-gcw0-linux-uclibc/sysroot/usr/lib\n\n#########################\n#########################\n\nPACKAGE_NAME = retroarch\n\nDEBUG ?= 0\n\nDINGUX = 1\nHAVE_SCREENSHOTS = 0\nHAVE_REWIND = 1\nHAVE_7ZIP = 1\nHAVE_AL = 1\n# ALSA freezes when switching back from menu\nHAVE_ALSA = 0\nHAVE_DSP_FILTER = 1\nHAVE_VIDEO_FILTER = 1\nHAVE_STATIC_VIDEO_FILTERS = 1\nHAVE_STATIC_AUDIO_FILTERS = 1\nHAVE_FILTERS_BUILTIN\t= 1\nHAVE_BUILTINMBEDTLS = 0\nHAVE_BUILTINZLIB = 1\nHAVE_C99 = 1\nHAVE_CC = 1\nHAVE_CC_RESAMPLER = 1\nHAVE_CHD = 1\nHAVE_COMMAND = 0\nHAVE_CXX = 1\nHAVE_DR_MP3 = 1\nHAVE_DYNAMIC = 1\nHAVE_EGL = 0\nHAVE_FREETYPE = 0\nHAVE_GDI = 1\nHAVE_GETADDRINFO = 0\nHAVE_GETOPT_LONG = 1\nHAVE_GLSL = 0\nHAVE_HID = 1\nHAVE_IBXM = 1\nHAVE_IMAGEVIEWER = 1\nHAVE_LANGEXTRA = 0\nHAVE_LIBRETRODB = 1\nHAVE_MENU = 1\nHAVE_MENU_COMMON = 1\nHAVE_GFX_WIDGETS = 0\nHAVE_MMAP = 1\nHAVE_NETWORKING = 1\nHAVE_OPENDINGUX_FBDEV = 0\nHAVE_OPENGL = 0\nHAVE_OPENGL1 = 0\nHAVE_OPENGLES = 0\nHAVE_OPENGLES3 = 0\nHAVE_OPENGL_CORE = 0\nHAVE_OPENSSL = 1\nHAVE_OVERLAY = 0\nHAVE_RBMP = 1\nHAVE_RJPEG = 1\nHAVE_RPILED = 0\nHAVE_RPNG = 1\nHAVE_RUNAHEAD = 1\nHAVE_SDL_DINGUX = 1\nHAVE_SHADERPIPELINE = 0\nHAVE_STB_FONT = 0\nHAVE_STB_IMAGE = 1\nHAVE_STB_VORBIS = 1\nHAVE_STDIN_CMD = 0\nHAVE_STRCASESTR = 1\nHAVE_THREADS = 1\nHAVE_UDEV = 1\nHAVE_RGUI = 1\nHAVE_MATERIALUI = 0\nHAVE_XMB = 0\nHAVE_OZONE = 0\nHAVE_ZLIB = 1\nHAVE_CONFIGFILE = 1\nHAVE_PATCH = 1\nHAVE_CHEATS = 1\nHAVE_CHEEVOS = 0\nHAVE_LIBSHAKE = 1\nHAVE_CORE_INFO_CACHE = 1\n\nOS = Linux\nTARGET = retroarch\nOPK_NAME = retroarch_rg350.opk\n\nOBJ :=\nLINK := $(CXX)\nDEF_FLAGS := -march=mips32 -mtune=mips32r2 -mhard-float -ffast-math -fomit-frame-pointer\nDEF_FLAGS += -mplt -mno-shared\nDEF_FLAGS += -ffunction-sections -fdata-sections\nDEF_FLAGS += -I. -Ideps -Ideps/stb -DDINGUX=1 -MMD\nDEF_FLAGS += -Wall -Wno-unused-variable\nDEF_FLAGS += -std=gnu99 -D_GNU_SOURCE -flto\nLIBS := -ldl -lz -lrt -ludev -pthread\nCFLAGS :=\nCXXFLAGS := -fno-exceptions -fno-rtti -std=c++11 -D__STDC_CONSTANT_MACROS\nASFLAGS :=\nLDFLAGS := -Wl,--gc-sections\nINCLUDE_DIRS = -I$(GCW0_INC_DIR)\nLIBRARY_DIRS = -L$(GCW0_LIB_DIR)\nDEFINES := -DRARCH_INTERNAL -D_FILE_OFFSET_BITS=64 -UHAVE_STATIC_DUMMY\nDEFINES += -DHAVE_C99=1 -DHAVE_CXX=1\nDEFINES += -DHAVE_GETOPT_LONG=1 -DHAVE_STRCASESTR=1 -DHAVE_DYNAMIC=1\nDEFINES += -DHAVE_AL=1\nDEFINES += -DHAVE_FILTERS_BUILTIN\nDEFINES += -DHAVE_UDEV=1\n\nSDL_DINGUX_CFLAGS := $(shell $(GCW0_SDL_CONFIG) --cflags)\nSDL_DINGUX_LIBS := $(shell $(GCW0_SDL_CONFIG) --libs)\nFREETYPE_CFLAGS := $(shell $(GCW0_FREETYPE_CONFIG) --cflags)\nFREETYPE_LIBS := $(shell $(GCW0_FREETYPE_CONFIG) --libs)\nAL_LIBS := -lopenal\nMMAP_LIBS = -lc\n\nOBJDIR_BASE := obj-unix\n\nifeq ($(DEBUG), 1)\n   OBJDIR := $(OBJDIR_BASE)/debug\n   DEF_FLAGS += -O0 -g -DDEBUG -D_DEBUG\nelse\n   OBJDIR := $(OBJDIR_BASE)/release\n   DEF_FLAGS += -O2 -DNDEBUG\nendif\n\ninclude Makefile.common\n\nDEF_FLAGS += $(INCLUDE_DIRS)\nLDFLAGS += $(CFLAGS) $(CXXFLAGS) $(DEF_FLAGS)\nCFLAGS += $(DEF_FLAGS)\nCXXFLAGS += $(DEF_FLAGS)\n\nHEADERS = $(wildcard */*/*.h) $(wildcard */*.h) $(wildcard *.h)\n\nQ := @\n\nRARCH_OBJ := $(addprefix $(OBJDIR)/,$(OBJ))\n\ndefine DESKTOP_ENTRY\n[Desktop Entry]\nName=RetroArch\nComment=Frontend for emulators, game engines\nExec=retroarch\nTerminal=false\nType=Application\nStartupNotify=true\nIcon=retroarch\nCategories=emulators;\nX-OD-NeedsDownscaling=true\nendef\nexport DESKTOP_ENTRY\n\nall: $(TARGET) opk\n\n-include $(RARCH_OBJ:.o=.d)\n\nSYMBOL_MAP := -Wl,-Map=output.map\n\n$(TARGET): $(RARCH_OBJ)\n\t@$(if $(Q), $(shell echo echo LD $@),)\n\t$(Q)$(LINK) -o $@ $(RARCH_OBJ) $(LIBS) $(LDFLAGS) $(LIBRARY_DIRS)\n\n$(OBJDIR)/%.o: %.c\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CC $<),)\n\t$(Q)$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) -c -o $@ $<\n\n$(OBJDIR)/%.o: %.cpp\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CXX $<),)\n\t$(Q)$(CXX) $(CPPFLAGS) $(CXXFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.m\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo OBJC $<),)\n\t$(Q)$(CXX) $(OBJCFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.S $(HEADERS)\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo AS $<),)\n\t$(Q)$(CC) $(CFLAGS) $(ASFLAGS) $(DEFINES) -c -o $@ $<\n\nclean:\n\trm -rf $(OBJDIR_BASE)\n\trm -f $(TARGET)\n\trm -f *.d\n\trm -rf $(OPK_NAME)\n\nopk: $(TARGET)\n\techo \"$$DESKTOP_ENTRY\" > default.gcw0.desktop\n\trm -f $(OPK_NAME)\n\tcp media/ico_src/icon32.png retroarch.png\nifeq ($(STRIP_BIN),1)\n\t$(STRIP) --strip-unneeded retroarch\nendif\n\t$(GCW0_MK_SQUASH_FS) retroarch default.gcw0.desktop retroarch.png $(OPK_NAME) -all-root -no-xattrs -noappend -no-exports\n\trm -f default.gcw0.desktop retroarch.png\n\n.PHONY: all clean opk\n\nprint-%:\n\t@echo '$*=$($*)'\n"
        },
        {
          "name": "Makefile.rg350_odbeta",
          "type": "blob",
          "size": 5.4326171875,
          "content": "#########################\n## Toolchain variables ##\n#########################\n\n# Default toolchain directory\nTOOLCHAIN_DIR=/opt/gcw0-toolchain\n\n# All toolchain-related variables may be\n# overridden via the command line\nifdef GCW0_CC\nCC                    = $(GCW0_CC)\nelse\nCC                    = $(TOOLCHAIN_DIR)/usr/bin/mipsel-gcw0-linux-uclibc-gcc\nendif\n\nifdef GCW0_CXX\nCXX                   = $(GCW0_CXX)\nelse\nCXX                   = $(TOOLCHAIN_DIR)/usr/bin/mipsel-gcw0-linux-uclibc-g++\nendif\n\nifdef GCW0_STRIP\nSTRIP                 = $(GCW0_STRIP)\nelse\nSTRIP                 = $(TOOLCHAIN_DIR)/usr/bin/mipsel-gcw0-linux-uclibc-strip\nendif\n\nGCW0_SDL_CONFIG      ?= $(TOOLCHAIN_DIR)/usr/mipsel-gcw0-linux-uclibc/sysroot/usr/bin/sdl-config\nGCW0_FREETYPE_CONFIG ?= $(TOOLCHAIN_DIR)/usr/mipsel-gcw0-linux-uclibc/sysroot/usr/bin/freetype-config\nGCW0_MK_SQUASH_FS    ?= $(TOOLCHAIN_DIR)/usr/bin/mksquashfs\n\nGCW0_INC_DIR         ?= $(TOOLCHAIN_DIR)/usr/mipsel-gcw0-linux-uclibc/sysroot/usr/include\nGCW0_LIB_DIR         ?= $(TOOLCHAIN_DIR)/usr/mipsel-gcw0-linux-uclibc/sysroot/usr/lib\n\n#########################\n#########################\n\nPACKAGE_NAME = retroarch\n\nDEBUG ?= 0\n\nDINGUX = 1\nDINGUX_BETA = 1\nHAVE_SCREENSHOTS = 0\nHAVE_REWIND = 1\nHAVE_7ZIP = 1\nHAVE_AL = 0\nHAVE_ALSA = 1\nHAVE_DSP_FILTER = 1\nHAVE_VIDEO_FILTER = 1\nHAVE_STATIC_VIDEO_FILTERS = 1\nHAVE_STATIC_AUDIO_FILTERS = 1\nHAVE_FILTERS_BUILTIN\t= 1\nHAVE_BUILTINMBEDTLS = 0\nHAVE_BUILTINZLIB = 1\nHAVE_C99 = 1\nHAVE_CC = 1\nHAVE_CC_RESAMPLER = 1\nHAVE_CHD = 1\nHAVE_COMMAND = 0\nHAVE_CXX = 1\nHAVE_DR_MP3 = 1\nHAVE_DYNAMIC = 1\nHAVE_EGL = 0\nHAVE_FREETYPE = 0\nHAVE_GDI = 1\nHAVE_GETADDRINFO = 0\nHAVE_GETOPT_LONG = 1\nHAVE_GLSL = 0\nHAVE_HID = 1\nHAVE_IBXM = 1\nHAVE_IMAGEVIEWER = 1\nHAVE_LANGEXTRA = 0\nHAVE_LIBRETRODB = 1\nHAVE_MENU = 1\nHAVE_MENU_COMMON = 1\nHAVE_GFX_WIDGETS = 0\nHAVE_MMAP = 1\nHAVE_NETWORKING = 1\nHAVE_OPENDINGUX_FBDEV = 0\nHAVE_OPENGL = 0\nHAVE_OPENGL1 = 0\nHAVE_OPENGLES = 0\nHAVE_OPENGLES3 = 0\nHAVE_OPENGL_CORE = 0\nHAVE_OPENSSL = 1\nHAVE_OVERLAY = 0\nHAVE_RBMP = 1\nHAVE_RJPEG = 1\nHAVE_RPILED = 0\nHAVE_RPNG = 1\nHAVE_RUNAHEAD = 1\nHAVE_SDL_DINGUX = 1\nHAVE_SHADERPIPELINE = 0\nHAVE_STB_FONT = 0\nHAVE_STB_IMAGE = 1\nHAVE_STB_VORBIS = 1\nHAVE_STDIN_CMD = 0\nHAVE_STRCASESTR = 1\nHAVE_THREADS = 1\nHAVE_UDEV = 1\nHAVE_RGUI = 1\nHAVE_MATERIALUI = 0\nHAVE_XMB = 0\nHAVE_OZONE = 0\nHAVE_ZLIB = 1\nHAVE_CONFIGFILE = 1\nHAVE_PATCH = 1\nHAVE_CHEATS = 1\nHAVE_CHEEVOS = 0\nHAVE_LIBSHAKE = 1\nHAVE_TINYALSA = 1\nHAVE_CORE_INFO_CACHE = 1\n\nOS = Linux\nTARGET = retroarch\nOPK_NAME = retroarch_rg350_odbeta.opk\n\nOBJ :=\nLINK := $(CXX)\nDEF_FLAGS := -mplt -mno-shared\nDEF_FLAGS += -ffunction-sections -fdata-sections\nDEF_FLAGS += -ffast-math\nDEF_FLAGS += -I. -Ideps -Ideps/stb -DDINGUX=1 -DDINGUX_BETA=1 -MMD\nDEF_FLAGS += -Wall -Wno-unused-variable\nDEF_FLAGS += -std=gnu99 -D_GNU_SOURCE -flto\nDEF_FLAGS += -lasound\nLIBS := -ldl -lz -lrt -ludev -pthread\nCFLAGS :=\nCXXFLAGS := -fno-exceptions -fno-rtti -std=c++11 -D__STDC_CONSTANT_MACROS\nASFLAGS :=\nLDFLAGS := -Wl,--gc-sections\nINCLUDE_DIRS = -I$(GCW0_INC_DIR)\nLIBRARY_DIRS = -L$(GCW0_LIB_DIR)\nDEFINES := -DRARCH_INTERNAL -D_FILE_OFFSET_BITS=64 -UHAVE_STATIC_DUMMY\nDEFINES += -DHAVE_C99=1 -DHAVE_CXX=1\nDEFINES += -DHAVE_GETOPT_LONG=1 -DHAVE_STRCASESTR=1 -DHAVE_DYNAMIC=1\nDEFINES += -DHAVE_FILTERS_BUILTIN\nDEFINES += -DHAVE_UDEV=1\nDEFINES += -DHAVE_ALSA\n\nSDL_DINGUX_CFLAGS := $(shell $(GCW0_SDL_CONFIG) --cflags)\nSDL_DINGUX_LIBS := $(shell $(GCW0_SDL_CONFIG) --libs)\nFREETYPE_CFLAGS := $(shell $(GCW0_FREETYPE_CONFIG) --cflags)\nFREETYPE_LIBS := $(shell $(GCW0_FREETYPE_CONFIG) --libs)\nAL_LIBS := -lopenal\nMMAP_LIBS = -lc\n\nOBJDIR_BASE := obj-unix\n\nifeq ($(DEBUG), 1)\n   OBJDIR := $(OBJDIR_BASE)/debug\n   DEF_FLAGS += -O0 -g -DDEBUG -D_DEBUG\nelse\n   OBJDIR := $(OBJDIR_BASE)/release\n   DEF_FLAGS += -O2 -DNDEBUG\nendif\n\ninclude Makefile.common\n\nDEF_FLAGS += $(INCLUDE_DIRS)\nLDFLAGS += $(CFLAGS) $(CXXFLAGS) $(DEF_FLAGS)\nCFLAGS += $(DEF_FLAGS)\nCXXFLAGS += $(DEF_FLAGS)\n\nHEADERS = $(wildcard */*/*.h) $(wildcard */*.h) $(wildcard *.h)\n\nQ := @\n\nRARCH_OBJ := $(addprefix $(OBJDIR)/,$(OBJ))\n\ndefine DESKTOP_ENTRY\n[Desktop Entry]\nName=RetroArch\nComment=Frontend for emulators, game engines\nExec=retroarch\nTerminal=false\nType=Application\nStartupNotify=true\nIcon=retroarch\nCategories=emulators;\nX-OD-NeedsDownscaling=true\nendef\nexport DESKTOP_ENTRY\n\nall: $(TARGET) opk\n\n-include $(RARCH_OBJ:.o=.d)\n\nSYMBOL_MAP := -Wl,-Map=output.map\n\n$(TARGET): $(RARCH_OBJ)\n\t@$(if $(Q), $(shell echo echo LD $@),)\n\t$(Q)$(LINK) -o $@ $(RARCH_OBJ) $(LIBS) $(LDFLAGS) $(LIBRARY_DIRS)\n\n$(OBJDIR)/%.o: %.c\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CC $<),)\n\t$(Q)$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) -c -o $@ $<\n\n$(OBJDIR)/%.o: %.cpp\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CXX $<),)\n\t$(Q)$(CXX) $(CPPFLAGS) $(CXXFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.m\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo OBJC $<),)\n\t$(Q)$(CXX) $(OBJCFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.S $(HEADERS)\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo AS $<),)\n\t$(Q)$(CC) $(CFLAGS) $(ASFLAGS) $(DEFINES) -c -o $@ $<\n\nclean:\n\trm -rf $(OBJDIR_BASE)\n\trm -f $(TARGET)\n\trm -f *.d\n\trm -rf $(OPK_NAME)\n\nopk: $(TARGET)\n\techo \"$$DESKTOP_ENTRY\" > default.gcw0.desktop\n\trm -f $(OPK_NAME)\n\tcp media/ico_src/icon32.png retroarch.png\nifeq ($(STRIP_BIN),1)\n\t$(STRIP) --strip-unneeded retroarch\nendif\n\t$(GCW0_MK_SQUASH_FS) retroarch default.gcw0.desktop retroarch.png $(OPK_NAME) -all-root -no-xattrs -noappend -no-exports\n\trm -f default.gcw0.desktop retroarch.png\n\n.PHONY: all clean opk\n\nprint-%:\n\t@echo '$*=$($*)'\n"
        },
        {
          "name": "Makefile.rs90",
          "type": "blob",
          "size": 5.4931640625,
          "content": "#########################\n## Toolchain variables ##\n#########################\n\n# Alpha toolchain\nTOOLCHAIN_DIR=/opt/rs90-toolchain\n\n# All toolchain-related variables may be\n# overridden via the command line\nifdef GCW0_CC\nCC                    = $(GCW0_CC)\nelse\nCC                    = $(TOOLCHAIN_DIR)/usr/bin/mipsel-rs90-linux-musl-gcc\nendif\n\nifdef GCW0_CXX\nCXX                   = $(GCW0_CXX)\nelse\nCXX                   = $(TOOLCHAIN_DIR)/usr/bin/mipsel-rs90-linux-musl-g++\nendif\n\nifdef GCW0_STRIP\nSTRIP                 = $(GCW0_STRIP)\nelse\nSTRIP                 = $(TOOLCHAIN_DIR)/usr/bin/mipsel-rs90-linux-musl-strip\nendif\n\nGCW0_SDL_CONFIG      ?= $(TOOLCHAIN_DIR)/usr/mipsel-rs90-linux-musl/sysroot/usr/bin/sdl-config\nGCW0_FREETYPE_CONFIG ?= $(TOOLCHAIN_DIR)/usr/mipsel-rs90-linux-musl/sysroot/usr/bin/freetype-config\nGCW0_MK_SQUASH_FS    ?= $(TOOLCHAIN_DIR)/usr/bin/mksquashfs\n\nGCW0_INC_DIR         ?= $(TOOLCHAIN_DIR)/usr/mipsel-rs90-linux-musl/sysroot/usr/include\nGCW0_LIB_DIR         ?= $(TOOLCHAIN_DIR)/usr/mipsel-rs90-linux-musl/sysroot/usr/lib\n\n#########################\n#########################\n\nPACKAGE_NAME = retroarch\n\nDEBUG ?= 0\n\nRS90 = 1\nDINGUX = 1\nDINGUX_BETA = 1\nHAVE_SCREENSHOTS = 0\nHAVE_REWIND = 0\nHAVE_7ZIP = 1\nHAVE_AL = 0\nHAVE_ALSA = 1\nHAVE_DSP_FILTER = 1\nHAVE_VIDEO_FILTER = 1\nHAVE_STATIC_VIDEO_FILTERS = 1\nHAVE_STATIC_AUDIO_FILTERS = 1\nHAVE_FILTERS_BUILTIN\t= 1\nHAVE_BUILTINMBEDTLS = 0\nHAVE_BUILTINZLIB = 1\nHAVE_C99 = 1\nHAVE_CC = 1\nHAVE_CC_RESAMPLER = 1\n\nHAVE_CHD = 0\nHAVE_COMMAND = 0\nHAVE_CXX = 1\nHAVE_DR_MP3 = 0\nHAVE_DYNAMIC = 1\nHAVE_EGL = 0\nHAVE_FREETYPE = 0\nHAVE_GDI = 0\nHAVE_GETADDRINFO = 0\nHAVE_GETOPT_LONG = 1\nHAVE_GLSL = 0\nHAVE_HID = 0\nHAVE_IBXM = 0\nHAVE_IMAGEVIEWER = 0\nHAVE_LANGEXTRA = 0\nHAVE_LIBRETRODB = 1\nHAVE_MENU = 1\nHAVE_MENU_COMMON = 1\nHAVE_GFX_WIDGETS = 0\nHAVE_MMAP = 1\nHAVE_OPENDINGUX_FBDEV = 0\nHAVE_OPENGL = 0\nHAVE_OPENGL1 = 0\nHAVE_OPENGLES = 0\nHAVE_OPENGLES3 = 0\nHAVE_OPENGL_CORE = 0\nHAVE_OPENSSL = 0\nHAVE_OVERLAY = 0\nHAVE_RBMP = 1\nHAVE_RJPEG = 1\nHAVE_RPILED = 0\nHAVE_RPNG = 1\nHAVE_RUNAHEAD = 0\nHAVE_SDL_DINGUX = 1\nHAVE_SHADERPIPELINE = 0\nHAVE_STB_FONT = 0\nHAVE_STB_IMAGE = 0\nHAVE_STB_VORBIS = 0\nHAVE_STDIN_CMD = 0\nHAVE_STRCASESTR = 1\nHAVE_THREADS = 1\nHAVE_UDEV = 1\nHAVE_RGUI = 1\nHAVE_MATERIALUI = 0\nHAVE_XMB = 0\nHAVE_OZONE = 0\nHAVE_ZLIB = 1\nHAVE_CONFIGFILE = 1\nHAVE_PATCH = 1\nHAVE_XDELTA = 0 # Disabled until we figure out how to include <lzma.h>\nHAVE_CHEATS = 1\nHAVE_CHEEVOS = 0\nHAVE_LIBSHAKE = 0\nHAVE_TINYALSA = 1\nHAVE_NEAREST_RESAMPLER = 1\nHAVE_CORE_INFO_CACHE = 1\n\nOS = Linux\nTARGET = retroarch\nOPK_NAME = retroarch_rs90_odbeta.opk\n\nOBJ :=\nLINK := $(CXX)\nDEF_FLAGS := -mplt -mno-shared\nDEF_FLAGS += -ffunction-sections -fdata-sections\nDEF_FLAGS += -I. -Ideps -Ideps/stb -DRS90=1 -DDINGUX=1 -DDINGUX_BETA=1 -MMD\nDEF_FLAGS += -Wall -Wno-unused-variable\nDEF_FLAGS += -std=gnu99 -D_GNU_SOURopendinguxCE -flto -lasound\nLIBS := -ldl -lz -lrt -ludev -pthread\nCFLAGS :=\nCXXFLAGS := -fno-exceptions -fno-rtti -std=c++11 -D__STDC_CONSTANT_MACROS\nASFLAGS :=\nLDFLAGS := -Wl,--gc-sections\nINCLUDE_DIRS = -I$(GCW0_INC_DIR)\nLIBRARY_DIRS = -L$(GCW0_LIB_DIR)\nDEFINES := -DRARCH_INTERNAL -D_FILE_OFFSET_BITS=64 -UHAVE_STATIC_DUMMY\nDEFINES += -DHAVE_C99=1 -DHAVE_CXX=1\nDEFINES += -DHAVE_GETOPT_LONG=1 -DHAVE_STRCASESTR=1 -DHAVE_DYNAMIC=1\nDEFINES += -DHAVE_FILTERS_BUILTIN\nDEFINES += -DHAVE_UDEV=1\nDEFINES += -DHAVE_ALSA\nDEFINES += -DCC_RESAMPLER_PRECISION=0\n\nSDL_DINGUX_CFLAGS := $(shell $(GCW0_SDL_CONFIG) --cflags)\nSDL_DINGUX_LIBS := $(shell $(GCW0_SDL_CONFIG) --libs)\nFREETYPE_CFLAGS := $(shell $(GCW0_FREETYPE_CONFIG) --cflags)\nFREETYPE_LIBS := $(shell $(GCW0_FREETYPE_CONFIG) --libs)\nMMAP_LIBS = -lc\n\nOBJDIR_BASE := obj-unix\n\nifeq ($(DEBUG), 1)\n   OBJDIR := $(OBJDIR_BASE)/debug\n   DEF_FLAGS += -O0 -g -DDEBUG -D_DEBUG\nelse\n   OBJDIR := $(OBJDIR_BASE)/release\n   DEF_FLAGS += -Ofast -DNDEBUG\nendif\n\ninclude Makefile.common\n\nDEF_FLAGS += $(INCLUDE_DIRS)\nLDFLAGS += $(CFLAGS) $(CXXFLAGS) $(DEF_FLAGS)\nCFLAGS += $(DEF_FLAGS)\nCXXFLAGS += $(DEF_FLAGS)\n\nHEADERS = $(wildcard */*/*.h) $(wildcard */*.h) $(wildcard *.h)\n\nQ := @\n\nRARCH_OBJ := $(addprefix $(OBJDIR)/,$(OBJ))\n\ndefine DESKTOP_ENTRY\n[Desktop Entry]\nName=RetroArch\nComment=Frontend for emulators, game engines\nExec=retroarch\nTerminal=false\nType=Application\nStartupNotify=true\nIcon=retroarch\nCategories=emulators;\nX-OD-NeedsDownscaling=true\nendef\nexport DESKTOP_ENTRY\n\nall: $(TARGET) opk\n\n-include $(RARCH_OBJ:.o=.d)\n\nSYMBOL_MAP := -Wl,-Map=output.map\n\n$(TARGET): $(RARCH_OBJ)\n\t@$(if $(Q), $(shell echo echo LD $@),)\n\t$(Q)$(LINK) -o $@ $(RARCH_OBJ) $(LIBS) $(LDFLAGS) $(LIBRARY_DIRS)\n\n$(OBJDIR)/%.o: %.c\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CC $<),)\n\t$(Q)$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) -c -o $@ $<\n\n$(OBJDIR)/%.o: %.cpp\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo CXX $<),)\n\t$(Q)$(CXX) $(CPPFLAGS) $(CXXFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.m\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo OBJC $<),)\n\t$(Q)$(CXX) $(OBJCFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.S $(HEADERS)\n\t@mkdir -p $(dir $@)\n\t@$(if $(Q), $(shell echo echo AS $<),)\n\t$(Q)$(CC) $(CFLAGS) $(ASFLAGS) $(DEFINES) -c -o $@ $<\n\nclean:\n\trm -rf $(OBJDIR_BASE)\n\trm -f $(TARGET)\n\trm -f *.d\n\trm -rf $(OPK_NAME)\n\nopk: $(TARGET)\n\techo \"$$DESKTOP_ENTRY\" > default.rs90.desktop\n\trm -f $(OPK_NAME)\n\tcp media/ico_src/icon32.png retroarch.png\nifeq ($STRIP_BIN, 1)\n\t$(STRIP) --strip-unneeded retroarch\nendif\n\t$(GCW0_MK_SQUASH_FS) retroarch default.rs90.desktop retroarch.png $(OPK_NAME) -all-root -no-xattrs -noappend -no-exports\n\trm -f default.rs90.desktop retroarch.png\n\n.PHONY: all clean opk\n\nprint-%:\n\t@echo '$*=$($*)'\n"
        },
        {
          "name": "Makefile.switch",
          "type": "blob",
          "size": 2.23828125,
          "content": "TARGET := retroarch_switch\n\nDEBUG                  ?= 0\nGRIFFIN_BUILD           = 0\nWHOLE_ARCHIVE_LINK      = 0\n\nOBJ :=\n\nDEFINES := -DSWITCH=1 -U__linux__ -U__linux -DRARCH_INTERNAL -DHAVE_SCREENSHOTS -DHAVE_DYNAMIC -DHAVE_REWIND\n\nifeq ($(GRIFFIN_BUILD), 1)\n\tOBJ += griffin/griffin.o\n\tDEFINES += -DHAVE_GRIFFIN=1 -DHAVE_NEON -DHAVE_MATERIALUI -DHAVE_LIBRETRODB -DHAVE_CC_RESAMPLER\n\tDEFINES += -DHAVE_ZLIB -DHAVE_RPNG -DHAVE_RJPEG -DHAVE_RBMP -DHAVE_RTGA\n\tDEFINES += -DHAVE_RUNAHEAD -DHAVE_DYNAMIC\n\tDEFINES += -DHAVE_CONFIGFILE -DHAVE_PATCH -DHAVE_CHEATS\nelse\n\tHAVE_REWIND = 1\n\tHAVE_AUDIOMIXER = 1\n\tHAVE_RWAV       = 1\n\tHAVE_CC_RESAMPLER = 1\n\tHAVE_MENU_COMMON = 1\n\tHAVE_RTGA = 1\n\tHAVE_RPNG = 1\n\tHAVE_RJPEG = 1\n\tHAVE_RBMP = 1\n\tHAVE_RGUI = 1\n\tHAVE_ZLIB = 1\n\tHAVE_DSP_FILTER = 1\n\tHAVE_VIDEO_FILTER = 1\n\tHAVE_BUILTINZLIB = 1\n\tHAVE_LIBRETRODB = 1\n\tHAVE_MATERIALUI = 0 # enable later?\n\tHAVE_XMB = 0\n\tHAVE_STATIC_VIDEO_FILTERS = 1\n\tHAVE_STATIC_AUDIO_FILTERS = 1\n\tHAVE_MENU = 1\n\tHAVE_CONFIGFILE = 1\n\tHAVE_RUNAHEAD = 1\n\tHAVE_DYNAMIC = 1\n\tHAVE_PATCH   = 1\n\tHAVE_CHEATS  = 1\n\tHAVE_IBXM = 1\n\tHAVE_CORE_INFO_CACHE = 1\n\n\tinclude Makefile.common\n\tCFLAGS += $(DEF_FLAGS)\n\tBLACKLIST :=\n\tBLACKLIST += input/input_overlay.o\n\tBLACKLIST += tasks/task_overlay.o\n\tOBJ := $(filter-out $(BLACKLIST),$(OBJ))\nendif\n\nifeq ($(strip $(LIBTRANSISTOR_HOME)),)\n$(error \"Please set LIBTRANSISTOR_HOME in your environment. export LIBTRANSISTOR_HOME=<path/to/libtransistor/dist/>\")\nendif\n\ninclude $(LIBTRANSISTOR_HOME)/libtransistor.mk\n\nINCDIRS := -I. -Ideps -Ilibretro-common/include -Ilibretro-common/include/compat/zlib -Ideps/stb -I$(LIBTRANSISTOR_HOME)/build/sdl2_install/include/SDL2/\nLIBDIRS := -L.\n\nTARGETS := $(TARGET).nro\n\nCFLAGS += $(INCDIRS) $(DEFINES) -Wno-unused-command-line-argument -Werror-implicit-function-declaration\n\nall: $(TARGETS)\n\n$(TARGET).nro.so: $(OBJ) libretro_switch.a fs.squashfs.o $(LIBTRANSISTOR_NRO_LIB) $(LIBTRANSISTOR_COMMON_LIBS)\n\t$(LD) $(LD_FLAGS) --allow-multiple-definition -o $@ $(OBJ) libretro_switch.a fs.squashfs.o $(LIBTRANSISTOR_NRO_LDFLAGS) -lm\n\n%.squashfs.o: %.squashfs\n\t$(LD) -s -r -b binary -m aarch64elf -T $(LIBTRANSISTOR_HOME)/fs.T -o $@ $<\n\nfs.squashfs: fs/*\n\tmksquashfs $^ $@ -comp lz4 -nopad -noappend\n\nclean:\n\trm -f $(OBJ) $(TARGET).nro.so $(TARGET).nro\n\n.PHONY: clean all\n"
        },
        {
          "name": "Makefile.vita",
          "type": "blob",
          "size": 6.2373046875,
          "content": "TARGET\t\t    := retroarch_vita\nDEBUG               ?= 0\nHAVE_FILE_LOGGER\t= 1\nGRIFFIN_BUILD        = 0\nWHOLE_ARCHIVE_LINK   = 0\nHAVE_STATIC_DUMMY ?= 0\n\nVITA_TITLE_ID\t:= RETROARCH\nVITA_TITLE_NAME\t:= RetroArch\n\nPC_DEVELOPMENT_IP_ADDRESS  =\nPC_DEVELOPMENT_UDP_PORT\t   =\n\nOBJ :=\n\nSCE_LIBC_SIZE := 4194304\nDEFINES := -DHAVE_ONLINE_UPDATER -DHAVE_UPDATE_ASSETS -DHAVE_STB_VORBIS\nINCDIRS :=\n\nifeq ($(GRIFFIN_BUILD), 1)\n\tOBJ += griffin/griffin.o\n\tDEFINES += -DHAVE_GRIFFIN=1 \\\n\t\t   -DHAVE_REWIND \\\n\t\t   -DHAVE_NEON \\\n\t\t   -DHAVE_MENU \\\n\t\t   -DHAVE_CONFIGFILE \\\n\t\t   -DHAVE_PATCH \\\n\t\t   -DHAVE_CHEATS \\\n\t\t   -DHAVE_XMB \\\n\t\t   -DHAVE_MATERIALUI \\\n\t\t   -DHAVE_LIBRETRODB \\\n\t\t   -DHAVE_KEYMAPPER \\\n\t\t   -DHAVE_ZLIB \\\n\t\t   -DHAVE_RPNG \\\n\t\t   -DHAVE_RJPEG \\\n\t\t   -DHAVE_RBMP \\\n\t\t   -DHAVE_RTGA \\\n\t\t   -DHAVE_CC_RESAMPLER \\\n\t\t   -DHAVE_CORE_INFO_CACHE\n\tifeq ($(DEBUG), 1)\n\t\tDEFINES += -DHAVE_NETLOGGER\n\tendif\n\tINCDIRS += -I. \\\n\t\t   -Ideps/7zip \\\n\t\t   -Ilibretro-common/include \\\n\t\t   -Ilibretro-common/include/compat/zlib \\\n\t\t   -Ideps/stb\nelse\n\tHAVE_REWIND\t\t:= 1\n\tHAVE_UPDATE_ASSETS      := 1\n\tHAVE_ONLINE_UPDATER     := 1\n\tHAVE_NEON\t\t:= 1\n\tHAVE_DSP_FILTER\t\t:= 1\n\tHAVE_VIDEO_FILTER\t:= 1\n\tHAVE_SCREENSHOTS\t:= 1\n\tHAVE_FILTERS_BUILTIN\t:= 1\n\tHAVE_LANGEXTRA\t\t:= 1\n\tHAVE_RPNG\t\t:= 1\n\tHAVE_RJPEG\t\t:= 1\n\tHAVE_RBMP\t\t:= 1\n\tHAVE_RTGA\t\t:= 1\n\tHAVE_ZLIB\t\t:= 1\n\tHAVE_7ZIP\t\t:= 1\n   ifeq ($(HAVE_VITAGLES), 1)\n\tHAVE_VITA2D\t\t:= 0\n\tHAVE_VITAGL\t\t:= 0\n\tHAVE_VITAGLES \t\t:= 1\n\tHAVE_OPENGL \t\t:= 1\n\tHAVE_OPENGLES \t\t:= 1\n\tHAVE_OPENGLES2 \t\t:= 1\n\tHAVE_EGL \t\t:= 1\n\tHAVE_GLSL \t\t:= 1\n\tHAVE_SHADERPIPELINE \t:= 1\n   else\n\tHAVE_VITA2D\t\t:= 1\n\tHAVE_VITAGL\t\t:= 0\n   endif\n\tHAVE_NETWORKING\t\t:= 1\n\tHAVE_IFINFO\t\t:= 1\n\tHAVE_NETPLAYDISCOVERY\t:= 1\n\tHAVE_SOCKET_LEGACY\t:= 1\n\tHAVE_MENU\t\t:= 1\n\tHAVE_MENU_COMMON\t:= 1\n\tHAVE_GFX_WIDGETS \t:= 1\n\tHAVE_CONFIGFILE \t:= 1\n\tHAVE_PATCH      \t:= 1\n\tHAVE_XDELTA\t\t\t:= 1 # disabled because <lzma.h> isn't available (or we haven't figured out how to install it)\n\tHAVE_CHEATS     \t:= 1\n\tHAVE_OVERLAY\t\t:= 1\n\tHAVE_MATERIALUI\t\t:= 1\n\tHAVE_XMB\t\t:= 1\n\tHAVE_RGUI\t\t:= 1\n\tHAVE_STB_FONT\t\t:= 1\n\tHAVE_THREADS\t\t:= 1\n\tHAVE_LIBRETRODB\t\t:= 1\n\tHAVE_CC_RESAMPLER\t:= 1\n\tHAVE_CHEEVOS\t\t:= 1\n\tHAVE_RUNAHEAD\t\t:= 1\n\tRARCH_CONSOLE\t\t:= 1\n\tHAVE_STATIC_VIDEO_FILTERS = 1\n\tHAVE_STATIC_AUDIO_FILTERS = 1\n\tHAVE_AUDIOMIXER \t:= 1\n\tHAVE_RWAV       \t:= 1\n\tHAVE_CORE_INFO_CACHE    := 1\n\n\tifeq ($(DEBUG), 1)\n\t\tHAVE_NETLOGGER\t= 1\n\tendif\n\n\tinclude Makefile.common\n\tCFLAGS\t\t\t+= $(DEF_FLAGS)\n\tBLACKLIST \t\t:=\n\tOBJ\t\t\t:= $(filter-out $(BLACKLIST),$(OBJ))\n\tINCDIRS\t\t\t+= $(INCLUDE_DIRS)\nendif\n\nifeq ($(strip $(VITASDK)),)\n$(error \"Please set VITASDK in your environment. export VITASDK=<path to>vitasdk\")\nendif\n\nexport PATH := $(PATH):$(VITASDK)/bin\n\nPREFIX := arm-vita-eabi-\n\nCC      := $(PREFIX)gcc\nCXX     := $(PREFIX)g++\nAS      := $(PREFIX)as\nAR      := $(PREFIX)ar\nOBJCOPY := $(PREFIX)objcopy\nSTRIP   := $(PREFIX)strip\nNM      := $(PREFIX)nm\nLD      := $(CXX)\n\nLIBDIRS := -L.\n\nARCHFLAGS := -march=armv7-a -mfpu=neon -mfloat-abi=hard -DVITA\nifeq ($(HAVE_VITAGLES), 1)\n   ARCHFLAGS += -DSCE_LIBC_SIZE=$(SCE_LIBC_SIZE)\nendif\n\nCFLAGS    += $(ARCHFLAGS) -mword-relocations -fno-optimize-sibling-calls\n\nifeq ($(DEBUG), 1)\n   CFLAGS += -g -Og\nelse\n   CFLAGS += -O2\nendif\n\nASFLAGS := $(CFLAGS)\nLDFLAGS := -Wl,-q\n\nCFLAGS += -Wall -ffast-math\nCFLAGS += -DRARCH_INTERNAL -DHAVE_SCREENSHOTS -DRARCH_CONSOLE\nCFLAGS += -DHAVE_DSP_FILTER\nCFLAGS += -DHAVE_VIDEO_FILTER\nCFLAGS += -DHAVE_FILTERS_BUILTIN $(DEFINES)\n\nifneq ($(PC_DEVELOPMENT_IP_ADDRESS),)\n   CFLAGS += -DPC_DEVELOPMENT_IP_ADDRESS='\"$(PC_DEVELOPMENT_IP_ADDRESS)\"'\nendif\n\nifneq ($(PC_DEVELOPMENT_UDP_PORT),)\n   CFLAGS += -DPC_DEVELOPMENT_UDP_PORT=$(PC_DEVELOPMENT_UDP_PORT)\nendif\n\nifeq ($(WHOLE_ARCHIVE_LINK), 1)\n   WHOLE_START := -Wl,--whole-archive\n   WHOLE_END := -Wl,--no-whole-archive\nendif\nCXXFLAGS := $(CFLAGS) -fno-rtti -fno-exceptions\n\nVITA_LIBS := -lSceDisplay_stub -lSceGxm_stub -lSceNet_stub -lSceNetCtl_stub -lSceAppUtil_stub \\\n\t-lSceSysmodule_stub -lSceCtrl_stub -lSceHid_stub -lSceTouch_stub -lSceAudio_stub \\\n\t-lScePower_stub -lSceRtc_stub -lSceCommonDialog_stub -lScePgf_stub -lSceMotion_stub \\\n\t-lSceFiber_stub -lSceMotion_stub -lSceAppMgr_stub -lpthread -lpng -lz -lSceShaccCg_stub\n\nifeq ($(HAVE_VITAGLES), 1)\n   VITA_LIBS += -llibScePiglet_stub -ltaihen_stub\n   FSELF_FLAGS := -ss\nelse\n   VITA_LIBS += -lvitaGL -lvitashark\n   FSELF_FLAGS := -s\nendif\n\nLIBS\t:= $(WHOLE_START) \n\nifeq ($(HAVE_STATIC_DUMMY),1)\n  DEFINES += -DHAVE_STATIC_DUMMY\nelse\n  LIBS += -lretro_vita\nendif\n\nLIBS    += $(WHOLE_END) $(VITA_LIBS) -lm -lc\n\nTARGETS := $(TARGET).vpk\n\nDEPFLAGS    = -MT $@ -MMD -MP -MF $*.Tdepend\nPOSTCOMPILE = mv -f $*.Tdepend $*.depend\n\nall: $(TARGETS)\n\n%.o: %.cpp\n%.o: %.cpp %.depend\n\t$(CXX) -c -o $@ $< $(CXXFLAGS) $(INCDIRS) $(DEPFLAGS)\n\t$(POSTCOMPILE)\n\n%.o: %.c\n%.o: %.c %.depend\n\t$(CC) -c -o $@ $< $(CFLAGS) $(INCDIRS) $(DEPFLAGS)\n\t$(POSTCOMPILE)\n\n%.o: %.S\n%.o: %.S %.depend\n\t$(CC) -c -o $@ $< $(ASFLAGS) $(INCDIRS) $(DEPFLAGS)\n\t$(POSTCOMPILE)\n\n%.o: %.s\n%.o: %.s %.depend\n\t$(CC) -c -o $@ $< $(ASFLAGS) $(INCDIRS) $(DEPFLAGS)\n\t$(POSTCOMPILE)\n\n%.depend: ;\n\nliblibScePiglet_stub.a:\n\tmkdir -p deps/Pigs-In-A-Blanket/piglet_stub/libScePiglet\n\tvita-libs-gen deps/Pigs-In-A-Blanket/piglet_stub/nids.yml deps/Pigs-In-A-Blanket/piglet_stub/libScePiglet\n\tmake -C deps/Pigs-In-A-Blanket/piglet_stub/libScePiglet ARCH=arm-vita-eabi\n\tcp deps/Pigs-In-A-Blanket/piglet_stub/libScePiglet/liblibScePiglet_stub.a .\n\n$(TARGET).elf: $(OBJ) liblibScePiglet_stub.a\n\t$(LD) $(OBJ) $(LDFLAGS) $(LIBDIRS) $(LIBS) -o $@\n\n%.velf: %.elf\n\tcp $< $<.unstripped.elf\n\t$(PREFIX)strip -g $<\n\tvita-elf-create $< $@\n\n%.self: %.velf\n\tvita-make-fself -c $(FSELF_FLAGS) $< $@\n\n%.vpk: %.self\n\tvita-mksfoex -s TITLE_ID=$(VITA_TITLE_ID) \"$(VITA_TITLE_NAME)\" -d ATTRIBUTE2=12 param.sfo\n\tvita-pack-vpk -s param.sfo -b $< $@\n\nclean:\n\trm -f $(OBJ) $(TARGET).elf $(TARGET).elf.unstripped.elf $(TARGET).velf $(TARGET).self param.sfo $(TARGET).vpk \n\trm -rf  deps/Pigs-In-A-Blanket/piglet_stub/libScePiglet\n\trm -f $(OBJ:.o=.depend)\n\n# Useful for developers\nvpksend: $(TARGET).vpk\n\tcurl -T $< ftp://$(PSVITAIP):1337/ux0:/\n\nsend: $(TARGET).self\n\tcurl -T $< ftp://$(PSVITAIP):1337/ux0:/app/$(VITA_TITLE_ID)/eboot.bin\n\nlaunch: $(TARGET).self\n\tcurl -T $< ftp://$(PSVITAIP):1337/ux0:/app/$(VITA_TITLE_ID)/eboot.bin\n\techo \"launch $(VITA_TITLE_ID)\" | nc ${PSVITAIP} 1338\n\n.PHONY: clean all send vpksend\n.PRECIOUS: %.depend\n\n-include $(OBJ:.o=.depend)\n"
        },
        {
          "name": "Makefile.vita.salamander",
          "type": "blob",
          "size": 2.30078125,
          "content": "HAVE_FILE_LOGGER  = 0\nDEBUG             = 0\n\nTARGET = retroarchvita_salamander\nTITLE_ID = RETROVITA\n\nifeq ($(DEBUG), 1)\n   OPTIMIZE_LV\t:= -O0 -g\nelse\n   OPTIMIZE_LV\t:= -O2\nendif\n\nPREFIX  = arm-vita-eabi\nCC      = $(PREFIX)-gcc\n\nINCDIR = libretro-common/include\nCFLAGS = -Wl,-q $(OPTIMIZE_LV) -I$(INCDIR) -std=gnu99 -mfloat-abi=hard -ffast-math -fsingle-precision-constant -mword-relocations\nASFLAGS = $(CFLAGS)\n\nRARCH_DEFINES = -DVITA -DIS_SALAMANDER -DRARCH_CONSOLE\n\nLIBDIR =\nLDFLAGS =\nLIBS = -lSceDisplay_stub -lSceGxm_stub -lSceNet_stub -lSceNetCtl_stub -lSceAppUtil_stub\\\n     -lSceSysmodule_stub -lSceCtrl_stub -lSceHid_stub -lSceAudio_stub -lSceFiber_stub\\\n     -lScePower_stub -lSceRtc_stub -lSceCommonDialog_stub -lScePgf_stub -lSceMotion_stub \\\n     -lSceMotion_stub -lSceAppMgr_stub -lfreetype -lpng -lm -lc\n\nifeq ($(HAVE_FILE_LOGGER), 1)\nCFLAGS\t\t+= -DHAVE_FILE_LOGGER\nendif\n\nCFLAGS += $(RARCH_DEFINES)\n\nOBJS = frontend/frontend_salamander.o \\\n\t\t frontend/frontend_driver.o \\\n\t\t frontend/drivers/platform_psp.o \\\n\t\t libretro-common/file/file_path.o \\\n\t\t libretro-common/file/file_path_io.o \\\n\t\t libretro-common/string/stdstring.o \\\n\t\t libretro-common/lists/string_list.o \\\n\t\t libretro-common/lists/dir_list.o \\\n\t\t libretro-common/file/retro_dirent.o \\\n\t\t libretro-common/encodings/encoding_utf.o \\\n\t\t libretro-common/compat/compat_strl.o \\\n\t\t libretro-common/compat/compat_strldup.o \\\n\t\t libretro-common/compat/compat_strcasestr.o \\\n\t\t libretro-common/compat/fopen_utf8.o \\\n\t\t libretro-common/file/config_file.o \\\n\t\t libretro-common/streams/file_stream.o \\\n\t\t libretro-common/vfs/vfs_implementation.o \\\n\t\t libretro-common/hash/lrc_hash.o \\\n\t\t libretro-common/time/rtime.o \\\n\t\t verbosity.o\n\nall: $(TARGET).vpk\n\n%.vpk: eboot.bin\n\tvita-mksfoex -s TITLE_ID=$(TITLE_ID) \"RetroArch\" -d ATTRIBUTE2=12 param.sfo\n\tvita-pack-vpk -s param.sfo -b eboot.bin $@\n\neboot.bin: $(TARGET).velf\n\tvita-make-fself $< $@\n\n%.velf: %.elf\n\tvita-elf-create $< $@\n\n$(TARGET).elf: $(OBJS)\n\t$(CC) $(CFLAGS) $^ $(LIBS) -o $@\n\n%.o: %.png\n\t$(PREFIX)-ld -r -b binary -o $@ $^\n\nclean:\n\t@rm -rf $(TARGET).vpk $(TARGET).velf $(TARGET).elf $(OBJS) \\\n\t\teboot.bin param.sfo\n\nvpksend: $(TARGET).vpk\n\tcurl -T $(TARGET).vpk ftp://$(PSVITAIP):1337/ux0:/\n\t@echo \"Sent.\"\n\nPSVITAIP = 192.168.1.15\n\nsend: eboot.bin\n\tcurl -T eboot.bin ftp://$(PSVITAIP):1337/ux0:/app/$(TITLE_ID)/\n\t@echo \"Sent.\"\n"
        },
        {
          "name": "Makefile.webos",
          "type": "blob",
          "size": 6.5224609375,
          "content": "include version.all\r\n\r\nifneq ($(CROSS_COMPILE),arm-webos-linux-gnueabi-)\r\n    $(error You need webOS toolchain to build this. See https://github.com/webosbrew/native-toolchain)\r\nendif\r\n\r\nifdef SDKTARGETSYSROOT\r\n    $(warning OE-based toolchain isn't supported anymore. Please use https://github.com/webosbrew/native-toolchain)\r\n    STAGING_DIR = $(SDKTARGETSYSROOT)\r\nelse ifndef STAGING_DIR\r\n    $(error Can't find buildroot based toolchain. Please use https://github.com/webosbrew/native-toolchain)\r\nendif\r\n\r\nWEBOS_FREETYPE_CONFIG ?= $(STAGING_DIR)/usr/bin/freetype-config\r\n\r\nWEBOS_INC_DIR         ?= $(STAGING_DIR)/usr/include\r\nWEBOS_LIB_DIR         ?= $(STAGING_DIR)/usr/lib\r\n\r\nADD_SDL2_LIB          ?= 0\r\nSDL2_PREBUILT_ARCHIVE ?= https://github.com/webosbrew/SDL-webOS/releases/download/release-2.30.0-webos.2/SDL2-2.30.0-webos.tar.gz\r\n\r\n#########################\r\n#########################\r\n\r\nPACKAGE_NAME = com.retroarch\r\nPACKAGE_VERSION := $(patsubst \"%\",%,$(RARCH_VERSION))\r\n\r\nDEBUG ?= 0\r\n\r\nHAVE_CLOUDSYNC = 1\r\nHAVE_SCREENSHOTS = 1\r\nHAVE_REWIND = 1\r\nHAVE_7ZIP = 1\r\nHAVE_ACCESSIBILITY = 1\r\nHAVE_AL = 0\r\n# ALSA freezes when switching back from menu\r\nHAVE_ALSA = 0\r\nHAVE_ANGLE = 0\r\nHAVE_AUDIOIO = 0\r\nHAVE_AUDIOMIXER = 1\r\nHAVE_BLISSBOX = 0\r\nHAVE_BSV_MOVIE = 1\r\nHAVE_BUILTINBEARSSL = 0\r\nHAVE_BUILTINFLAC = 1\r\nHAVE_DSP_FILTER = 1\r\nHAVE_VIDEO_FILTER = 1\r\nHAVE_STATIC_VIDEO_FILTERS = 1\r\nHAVE_STATIC_AUDIO_FILTERS = 1\r\nHAVE_FILTERS_BUILTIN\t= 1\r\nHAVE_BUILTINMBEDTLS = 1\r\nHAVE_BUILTINZLIB = 1\r\nHAVE_C99 = 1\r\nHAVE_CC = 1\r\nHAVE_CC_RESAMPLER = 1\r\nHAVE_NEAREST_RESAMPLER = 1\r\nHAVE_CHD = 1\r\nHAVE_COMMAND = 1\r\nHAVE_CXX = 1\r\nHAVE_DR_MP3 = 1\r\nHAVE_DYNAMIC = 1\r\nHAVE_DYLIB = 1\r\nHAVE_EGL = 0\r\nHAVE_FREETYPE = 0\r\nHAVE_GDI = 1\r\nHAVE_GETADDRINFO = 1\r\nHAVE_GETOPT_LONG = 1\r\nHAVE_GLSL = 1\r\nHAVE_GLSLANG = 0\r\nHAVE_GLSLANG_HLSL = 0\r\nHAVE_GLSLANG_OGLCOMPILER = 0\r\nHAVE_GLSLANG_OSDEPENDENT = 0\r\nHAVE_GLSLANG_SPIRV = 0\r\nHAVE_GLSLANG_SPIRV_TOOLS = 0\r\nHAVE_GLSLANG_SPIRV_TOOLS_OPT = 0\r\nHAVE_HID = 1\r\nHAVE_IBXM = 1\r\nHAVE_IMAGEVIEWER = 1\r\nHAVE_LANGEXTRA = 1\r\nHAVE_LIBRETRODB = 1\r\nHAVE_MENU = 1\r\nHAVE_MENU_COMMON = 1\r\nHAVE_NEON = 1\r\nHAVE_NETWORKING = 1\r\nHAVE_IFINFO = 1\r\nHAVE_NETWORK_CMD = 1\r\nHAVE_NETPLAYDISCOVERY = 1\r\nHAVE_NETWORKGAMEPAD = 1\r\nHAVE_GFX_WIDGETS = 1\r\nHAVE_MMAP = 1\r\nHAVE_ONLINE_UPDATER = 1\r\nHAVE_OPENDINGUX_FBDEV = 0\r\nHAVE_OPENGL = 0\r\nHAVE_OPENGL1 = 0\r\nHAVE_OPENGL_CORE = 0\r\nHAVE_OPENGLES = 1\r\nHAVE_OPENGLES3 = 0\r\nHAVE_OPENGLES3_1 = 0\r\nHAVE_OPENGLES3_2 = 0\r\nHAVE_OPENSSL = 0\r\nHAVE_OVERLAY = 1\r\nHAVE_PULSE = 1\r\nHAVE_RBMP = 1\r\nHAVE_RJPEG = 1\r\nHAVE_RPILED = 0\r\nHAVE_RPNG = 1\r\nHAVE_RUNAHEAD = 1\r\nHAVE_SDL = 0\r\nHAVE_SDL2 = 1\r\nHAVE_SHADERPIPELINE = 1\r\nHAVE_STB_FONT = 1\r\nHAVE_STB_IMAGE = 1\r\nHAVE_STB_VORBIS = 1\r\nHAVE_STDIN_CMD = 1\r\nHAVE_STRCASESTR = 1\r\nHAVE_THREADS = 1\r\nHAVE_UDEV = 0\r\nHAVE_RGUI = 1\r\nHAVE_MATERIALUI = 0\r\nHAVE_XMB = 1\r\nHAVE_OZONE = 1\r\nHAVE_ZLIB = 1\r\nHAVE_CONFIGFILE = 1\r\nHAVE_PATCH = 1\r\nHAVE_CHEATS = 1\r\nHAVE_CHEEVOS = 1\r\nHAVE_LIBSHAKE = 1\r\nHAVE_UPDATE_ASSETS = 1\r\nHAVE_UPDATE_CORES = 1\r\nHAVE_UPDATE_CORE_INFO = 1\r\nHAVE_CORE_INFO_CACHE = 1\r\n\r\nOS = Linux\r\nTARGET = retroarch\r\n\r\nOBJ :=\r\nLINK := $(CC)\r\nDEF_FLAGS += -ffunction-sections -fdata-sections\r\nDEF_FLAGS += -I. -Ideps -Ideps/stb -DWEBOS=1 -MMD\r\nDEF_FLAGS += -Wall -Wno-unused-variable\r\nLIBS := -ldl -lz -lrt -pthread\r\nCFLAGS :=\r\nCXXFLAGS := -fno-exceptions -fno-rtti -std=c++11 -D__STDC_CONSTANT_MACROS\r\nASFLAGS :=\r\nLDFLAGS := -Wl,-rpath=\\$$ORIGIN/lib,--gc-sections\r\nINCLUDE_DIRS = -I$(WEBOS_INC_DIR)\r\nLIBRARY_DIRS = -L$(WEBOS_LIB_DIR)\r\nDEFINES := -DRARCH_INTERNAL -D_FILE_OFFSET_BITS=64 -UHAVE_STATIC_DUMMY\r\nDEFINES += -DHAVE_C99=1 -DHAVE_CXX=1 -D_GNU_SOURCE\r\nDEFINES += -DHAVE_GETOPT_LONG=1 -DHAVE_STRCASESTR=1 -DHAVE_DYNAMIC=1\r\nDEFINES += -DHAVE_FILTERS_BUILTIN\r\nDEFINES += -DHAVE_SDL2\r\nDEFINES += -DHAVE_PULSE\r\nDEFINES += -DHAVE_NETWORKING -DHAVE_IFINFO -DHAVE_ONLINE_UPDATER -DHAVE_UPDATE_ASSETS -DHAVE_UPDATE_CORES\r\nDEFINES += -DHAVE_UPDATE_CORE_INFO\r\n\r\nPKG_CONFIG=pkg-config\r\n\r\nSDL2_CFLAGS := $(shell $(PKG_CONFIG) --cflags sdl2)\r\nSDL2_LIBS := $(shell $(PKG_CONFIG) --libs sdl2)\r\nOPENGLES_LIBS = -lGLESv2\r\nPULSE_LIBS = $(shell $(PKG_CONFIG) --libs libpulse)\r\nMMAP_LIBS = -lc\r\nNEON_CFLAGS = -mfpu=neon\r\nNEON_ASFLAGS = -mfpu=neon\r\nNETWORKING_LIBS = -lc\r\n\r\nOBJDIR_BASE := obj-unix\r\n\r\nifeq ($(DEBUG), 1)\r\n   OBJDIR := $(OBJDIR_BASE)/debug\r\n   DEF_FLAGS += -O0 -g -DDEBUG -D_DEBUG\r\nelse\r\n   OBJDIR := $(OBJDIR_BASE)/release\r\n   DEF_FLAGS += -O2 -DNDEBUG\r\nendif\r\n\r\ninclude Makefile.common\r\n\r\nDEF_FLAGS += $(INCLUDE_DIRS)\r\nLDFLAGS += $(CFLAGS) $(CXXFLAGS) $(DEF_FLAGS)\r\nCFLAGS += $(DEF_FLAGS)\r\nCXXFLAGS += $(DEF_FLAGS)\r\n\r\nHEADERS = $(wildcard */*/*.h) $(wildcard */*.h) $(wildcard *.h)\r\n\r\nQ := @\r\n\r\nRARCH_OBJ := $(addprefix $(OBJDIR)/,$(OBJ))\r\n\r\ndefine APPINFO\r\n{\r\n    \"id\": \"$(PACKAGE_NAME)\",\r\n    \"version\": \"$(PACKAGE_VERSION)\",\r\n    \"vendor\": \"webosbrew.org\",\r\n    \"title\": \"RetroArch\",\r\n    \"icon\": \"icon160.png\",\r\n    \"main\": \"retroarch\",\r\n    \"iconColor\": \"#333333\",\r\n    \"type\": \"native\",\r\n    \"appDescription\": \"Emulation frontend\"\r\n}\r\nendef\r\nexport APPINFO\r\n\r\nall: $(TARGET) ipk\r\n\r\n-include $(RARCH_OBJ:.o=.d)\r\n\r\nSYMBOL_MAP := -Wl,-Map=output.map\r\n\r\n$(TARGET): $(RARCH_OBJ)\r\n\t@$(if $(Q), $(shell echo echo LD $@),)\r\n\t$(Q)$(LINK) -o $@ $(RARCH_OBJ) $(LIBS) $(LDFLAGS) $(LIBRARY_DIRS)\r\n\r\n$(OBJDIR)/%.o: %.c\r\n\t@mkdir -p $(dir $@)\r\n\t@$(if $(Q), $(shell echo echo CC $<),)\r\n\t$(Q)$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) -c -o $@ $<\r\n\r\n$(OBJDIR)/%.o: %.cpp\r\n\t@mkdir -p $(dir $@)\r\n\t@$(if $(Q), $(shell echo echo CXX $<),)\r\n\t$(Q)$(CXX) $(CPPFLAGS) $(CXXFLAGS) $(DEFINES) -MMD -c -o $@ $<\r\n\r\n$(OBJDIR)/%.o: %.m\r\n\t@mkdir -p $(dir $@)\r\n\t@$(if $(Q), $(shell echo echo OBJC $<),)\r\n\t$(Q)$(CXX) $(OBJCFLAGS) $(DEFINES) -MMD -c -o $@ $<\r\n\r\n$(OBJDIR)/%.o: %.S $(HEADERS)\r\n\t@mkdir -p $(dir $@)\r\n\t@$(if $(Q), $(shell echo echo AS $<),)\r\n\t$(Q)$(CC) $(CFLAGS) $(ASFLAGS) $(DEFINES) -c -o $@ $<\r\n\r\nclean:\r\n\trm -rf $(OBJDIR_BASE)\r\n\trm -f $(TARGET)\r\n\trm -f *.d\r\n\trm -rf SDL\r\n\trm -rf webos/*.ipk\r\n\trm -rf webos/dist\r\n\r\nsdl2: $(TARGET)\r\nifeq ($(ADD_SDL2_LIB), 1)\r\n\t@echo \"Downloading SDL2 prebuilt\"\r\n\tmkdir -p SDL\r\n\twget -qO - $(SDL2_PREBUILT_ARCHIVE) | tar -C SDL -zxvf -\r\nendif\r\n\r\nipk: $(TARGET) sdl2\r\n\trm -rf webos/dist\r\n\tmkdir -p webos/dist/lib\r\n\techo \"$$APPINFO\" > webos/dist/appinfo.json\r\n\tcp -t webos/dist -vf $(TARGET) webos/icon160.png\r\n\tcp -t webos/dist/lib -vf $(WEBOS_LIB_DIR)/libstdc++.so.6\r\nifeq ($(ADD_SDL2_LIB), 1)\r\n\tcp -t webos/dist/lib -vf SDL/lib/libSDL2-2.0.so.0\r\nendif\r\n\t$(STRIP) webos/dist/$(TARGET)\r\n\tcd webos && ares-package dist\r\n\r\ninstall: ipk\r\n\tares-install webos/$(PACKAGE_NAME)_$(PACKAGE_VERSION)_$(ARCH).ipk\r\n\r\nlaunch: install\r\n\tares-launch com.retroarch\r\n\r\n.PHONY: all clean ipk\r\n\r\nprint-%:\r\n\t@echo '$*=$($*)'\r\n"
        },
        {
          "name": "Makefile.wii",
          "type": "blob",
          "size": 7.3828125,
          "content": "ROOT_DIR                  := .\nDEPS_DIR                  := $(ROOT_DIR)/deps\nDEBUG                     ?= 0\nLOAD_WITHOUT_CORE_INFO    ?= 0\nHAVE_LOGGER                = 0\nHAVE_FILE_LOGGER           = 0\nHAVE_CC_RESAMPLER          = 1\nWHOLE_ARCHIVE_LINK         = 0\nBIG_STACK                  = 1\nHAVE_NETWORKING            = 1\nHAVE_IFINFO                = 1\nPC_DEVELOPMENT_IP_ADDRESS  = 255.255.255.255\nPC_DEVELOPMENT_UDP_PORT    = 3490\nRARCH_CONSOLE              = 0\nUSBGECKO                   = 0\nHAVE_STATIC_DUMMY ?= 0\n\nSPACE      :=\nSPACE      := $(SPACE) $(SPACE)\nBACKSLASH  :=\nBACKSLASH  := \\$(BACKSLASH)\nfilter_out1 = $(filter-out $(firstword $1),$1)\nfilter_out2 = $(call filter_out1,$(call filter_out1,$1))\n\n# system platform\nsystem_platform = unix\nifeq ($(shell uname -s),)\n   EXE_EXT = .exe\n   system_platform = win\nelse ifneq ($(findstring Darwin,$(shell uname -s)),)\n   system_platform = osx\nelse ifneq ($(findstring MINGW,$(shell uname -s)),)\n   system_platform = win\nendif\n\nTARGET_NAME        := retroarch\n\nINCLUDE            :=\nLDFLAGS            :=\nLIBDIRS            :=\n\nifeq ($(LIBRETRO), nxengine)\n   WHOLE_ARCHIVE_LINK = 1\nendif\n\nifeq ($(WHOLE_ARCHIVE_LINK), 1)\n   WHOLE_START     := -Wl,--whole-archive\n   WHOLE_END       := -Wl,--no-whole-archive\nendif\n\nLIB_CORE :=\n\nifeq ($(HAVE_STATIC_DUMMY),1)\n  DEFINES += -DHAVE_STATIC_DUMMY\nelse\n  LIB_CORE += -lretro_wii\nendif\n\nLIBS               := $(WHOLE_START) $(LIB_CORE) $(WHOLE_END)\n\nlibogc_platform    := 1\n\nEXTERNAL_LIBOGC   ?= 0\nGX_PTHREAD_LEGACY ?= 1\nCC                 = $(DEVKITPPC)/bin/powerpc-eabi-gcc$(EXE_EXT)\nCXX                = $(DEVKITPPC)/bin/powerpc-eabi-g++$(EXE_EXT)\nLD                 = $(DEVKITPPC)/bin/powerpc-eabi-ld$(EXE_EXT)\nELF2DOL            = $(DEVKITPPC)/bin/elf2dol$(EXE_EXT)\nEXT_TARGET        := $(TARGET_NAME)_wii.dol\nEXT_INTER_TARGET  := $(TARGET_NAME)_wii.elf\n\n# Check whether ELF2DOL executable exists\n# (path has changed in more recent toolchains)\nifeq (\"$(wildcard $(ELF2DOL))\",\"\")\n   ELF2DOL = $(DEVKITPRO)/tools/bin/elf2dol$(EXE_EXT)\nendif\n\nINCLUDE += -I.\n\nifeq ($(EXTERNAL_LIBOGC), 1)\n   CFLAGS   += -DEXTERNAL_LIBOGC\n   CXXFLAGS += -DEXTERNAL_LIBOGC\n   LIBDIRS += -L$(DEVKITPRO)/libogc/lib/wii\n   INCLUDE +=  -I$(DEVKITPRO)/libogc/include\nelse\n   CFLAGS   += -DINTERNAL_LIBOGC\n   CXXFLAGS += -DINTERNAL_LIBOGC\n   LIBDIRS += -Lwii/libogc/libs/wii\n   INCLUDE += -Iwii/libogc/include\nendif\n\nifeq ($(GX_PTHREAD_LEGACY), 1)\n   CFLAGS   += -DGX_PTHREAD_LEGACY\n   CXXFLAGS += -DGX_PTHREAD_LEGACY\nendif\n\nMACHDEP := -DHW_RVL -mrvl\n\nLIBDIRS += -L.\nMACHDEP += -DGEKKO -mcpu=750 -meabi -mhard-float\n\nLDFLAGS += $(MACHDEP) -Wl,-Map,$(notdir $(EXT_INTER_TARGET)).map,-wrap,malloc,-wrap,free,-wrap,memalign,-wrap,calloc,-wrap,realloc,-wrap,strdup,-wrap,strndup,-wrap,malloc_usable_size\n\nifeq ($(BIG_STACK), 1)\n   LDFLAGS += -T bootstrap/gx/rvl.ld\nendif\n\nifeq ($(EXTERNAL_LIBOGC), 1)\n   LIBS += -lfat\nendif\n\nLIBS += -lwiiuse -lbte\n\nifeq ($(USBGECKO), 1)\n  LIBS += -ldb\nendif\n \nifeq ($(HAVE_LOGGER), 1)\n  LIBS += -lbba\nendif\n\nLIBS += -logc\n\nCFLAGS += -DGEKKO -U__INT32_TYPE__ -U __UINT32_TYPE__ -D__INT32_TYPE__=int\n\nHAVE_RUNAHEAD            := 1\nHAVE_DSP_FILTER          := 1\nHAVE_VIDEO_FILTER        := 1\nHAVE_FILTERS_BUILTIN     := 1\nHAVE_THREADS             := 1\nHAVE_RPNG                := 1\nHAVE_RJPEG               := 1\nHAVE_RBMP                := 1\nHAVE_RTGA                := 1\nHAVE_IBXM                := 1\nHAVE_OVERLAY             := 1\nHAVE_ZLIB                := 1\nHAVE_7ZIP                := 1\nHAVE_CONFIGFILE          := 1\nHAVE_PATCH               := 1\nHAVE_XDELTA              := 0 # disabled because <lzma.h> isn't available (or we haven't figured out how to install it)\nHAVE_CHEATS              := 1\nHAVE_SCREENSHOTS         := 1\nHAVE_REWIND              := 1\nHAVE_AUDIOMIXER          := 1\nHAVE_RWAV                := 1\nRARCH_CONSOLE             = 1\nHAVE_CHEATS              := 1\nHAVE_CORE_INFO_CACHE     := 1\nHAVE_MENU_COMMON         := 1\nHAVE_MENU                := 1\nHAVE_BUILTINZLIB         := 1\nHAVE_STATIC_AUDIO_FILTERS := 1\nHAVE_STATIC_VIDEO_FILTERS := 1\n\n#HAVE_LANGEXTRA          := 1\nHAVE_WIIUSB_HID          := 1\nHAVE_HID                 := 1\nHAVE_RARCH_EXEC          := 1\nHAVE_RSOUND              := 0\nHAVE_XMB                 := 0\nHAVE_OZONE               := 0\nHAVE_RGUI                := 1\nHAVE_MATERIALUI          := 0\nHAVE_CHEEVOS             := 1\n\nCFLAGS      += -DHAVE_SOCKET_LEGACY -DHAVE_CHEEVOS\n\nAPP_BOOTER_DIR = wii/app_booter\nPLATOBJS := $(APP_BOOTER_DIR)/app_booter.binobj\n\nifeq ($(USBGECKO), 1)\n   CFLAGS += -DUSBGECKO\nendif\n\nINCLUDE += -I./libretro-common/include \\\n           -Ideps \\\n\t   -Ideps/rcheevos/include \\\n           -Ideps/stb\nCFLAGS += -Wall -std=gnu99 $(MACHDEP) $(PLATCFLAGS) $(INCLUDE)\n\nOBJ =  $(PLATOBJS) audio/drivers/gx_audio.o gfx/drivers/gx_gfx.o input/drivers/gx_input.o frontend/drivers/platform_gx.o input/drivers_joypad/gx_joypad.o memory/wii/mem2_manager.o gfx/drivers/gx_gfx_vi_encoder.o frontend/drivers/platform_wii.o input/drivers_hid/wiiusb_hid.o \n\nifeq ($(EXTERNAL_LIBOGC), 0)\n   OBJ += wii/libogc/libfat/libfat.o wii/libogc/libfat/fatfile.o wii/libogc/libfat/file_allocation_table.o wii/libogc/libfat/cache.o wii/libogc/libfat/fatdir.o wii/libogc/libfat/partition.o wii/libogc/libfat/directory.o wii/libogc/libfat/filetime.o wii/libogc/libfat/disc.o\nendif\n\ninclude Makefile.common\n\nCFLAGS += $(DEFINES) -DPC_DEVELOPMENT_IP_ADDRESS=\\\"$(PC_DEVELOPMENT_IP_ADDRESS)\\\" \\\n\t\t-DPC_DEVELOPMENT_UDP_PORT=$(PC_DEVELOPMENT_UDP_PORT) \\\n\n\nifeq ($(WANT_GLSLANG), 1)\n\tOBJ += griffin/griffin_glslang.o\nendif\n\nifeq ($(HAVE_LOGGER), 1)\n   CFLAGS      += -DHAVE_LOGGER\n   CFLAGS      += -DPC_DEVELOPMENT_IP_ADDRESS=\\\"$(PC_DEVELOPMENT_IP_ADDRESS)\\\" -DPC_DEVELOPMENT_UDP_PORT=$(PC_DEVELOPMENT_UDP_PORT)\nendif\n\nifeq ($(HAVE_KERNEL_PRX), 1)\n   CFLAGS      += -DHAVE_KERNEL_PRX\nendif\n\nifeq ($(HAVE_WIIUSB_HID), 1)\n   CFLAGS      += -DHAVE_WIIUSB_HID\nendif\n\nifeq ($(BIG_STACK),1)\n   CFLAGS      += -DBIG_STACK\nendif\n\nifeq ($(HAVE_FILE_LOGGER), 1)\n   CFLAGS      += -DHAVE_FILE_LOGGER\nendif\n\nifeq ($(HAVE_RARCH_EXEC), 1)\n   CFLAGS      += -DHAVE_RARCH_EXEC\nendif\n\nifeq ($(HAVE_ZLIB), 1)\n   CFLAGS      += -DHAVE_ZLIB\n   CFLAGS      += -I./libretro-common/include/compat/zlib\nendif\n\nifeq ($(RARCH_CONSOLE), 1)\n   CFLAGS += -DRARCH_CONSOLE\nendif\n\nifeq ($(RARCH_MOBILE), 1)\n   CFLAGS += -DRARCH_MOBILE\nendif\n\nCFLAGS += -std=gnu99 -DHAVE_RGUI -DHAVE_MENU -DHAVE_GRIFFIN=1 -Wno-char-subscripts -DRARCH_INTERNAL\n\nifeq ($(HAVE_FILTERS_BUILTIN), 1)\n   CFLAGS += -DHAVE_FILTERS_BUILTIN\nendif\n\nifeq ($(HAVE_RSOUND), 1)\n   CFLAGS += -DHAVE_RSOUND\nendif\n\nifeq ($(HAVE_GETOPT_LONG), 1)\n   CFLAGS += -DHAVE_GETOPT_LONG=1\nendif\n\nifeq ($(HAVE_NETWORK_CMD), 1)\n   CFLAGS += -DHAVE_NETWORK_CMD\nendif\n\nifeq ($(HAVE_DYNAMIC), 1)\n   CFLAGS += -DHAVE_DYNAMIC\nendif\n\nifeq ($(DEBUG), 1)\n   CFLAGS += -O0 -g -DDEBUG\nelse\n   CFLAGS += -O3\nendif\n\nifeq ($(LOAD_WITHOUT_CORE_INFO),1)\n   CFLAGS += -DLOAD_WITHOUT_CORE_INFO\nendif\n\nOBJOUT   = -o\nLINKOUT  = -o\nLINK = $(CXX)\n\nall: $(EXT_TARGET)\n\n%.dol: %.elf\n\t$(ELF2DOL) $< $@\n\n$(EXT_INTER_TARGET): $(OBJ)\n\t$(LINK) $(LINKOUT)$@ $(LDFLAGS) $(LIBDIRS) $(OBJ) $(PLATEXTRA) $(LIBS)\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $(OBJOUT)$@ $<\n\n%.o: %.cpp\n\t$(CXX) $(CFLAGS) -c $(OBJOUT)$@ $<\n\n%.o: %.S\n\t$(CC) $(CFLAGS) -c $(OBJOUT)$@ $<\n\n%.binobj: %.bin\n\t$(LD) -r -b binary $(OBJOUT)$@ $<\n\n$(APP_BOOTER_DIR)/app_booter.bin:\n\texport EXTERNAL_LIBOGC\n\t$(MAKE) -C $(APP_BOOTER_DIR)\n\nclean:\n\trm -f $(EXT_TARGET)\n\trm -f $(EXT_INTER_TARGET)\n\trm -f $(OBJ)\n\t$(MAKE) -C $(APP_BOOTER_DIR) clean\n\n.PHONY: clean\n\nprint-%:\n\t@echo '$*=$($*)'\n"
        },
        {
          "name": "Makefile.wii.salamander",
          "type": "blob",
          "size": 3.833984375,
          "content": "###\n##\n# Makefile for RetroArch Wii.\n##\n\nDEBUG              = 0\nHAVE_LOGGER        = 0\nHAVE_FILE_LOGGER   = 0\nEXTERNAL_LIBOGC   ?= 0\nGX_PTHREAD_LEGACY ?= 1\n\n# system platform\nsystem_platform = unix\nifeq ($(shell uname -a),)\nEXE_EXT = .exe\n   system_platform = win\nelse ifneq ($(findstring Darwin,$(shell uname -a)),)\n   system_platform = osx\nelse ifneq ($(findstring MINGW,$(shell uname -a)),)\n   system_platform = win\nendif\n\nPC_DEVELOPMENT_IP_ADDRESS\t= 255.255.255.255\nPC_DEVELOPMENT_UDP_PORT\t\t= 3490\n\nCC = $(DEVKITPPC)/bin/powerpc-eabi-gcc$(EXE_EXT)\nCXX = $(DEVKITPPC)/bin/powerpc-eabi-g++$(EXE_EXT)\nLD = $(DEVKITPPC)/bin/powerpc-eabi-ld$(EXE_EXT)\nELF2DOL = $(DEVKITPPC)/bin/elf2dol$(EXE_EXT)\n\n# Check whether ELF2DOL executable exists\n# (path has changed in more recent toolchains)\nifeq (\"$(wildcard $(ELF2DOL))\",\"\")\n   ELF2DOL = $(DEVKITPRO)/tools/bin/elf2dol$(EXE_EXT)\nendif\n\nDOL_TARGET := retroarch-salamander_wii.dol\nELF_TARGET := retroarch-salamander_wii.elf\n\nINCLUDE := -I. -Ilibretro-common/include -Ilibretro-common/include/compat/zlib\nifeq ($(EXTERNAL_LIBOGC), 1)\nINCLUDE += -I$(DEVKITPRO)/libogc/include\nLIBDIRS := -L$(DEVKITPRO)/libogc/lib/wii -L.\nelse\nINCLUDE += -Iwii/libogc/include\nLIBDIRS := -Lwii/libogc/libs/wii -L.\nendif\n\nifeq ($(GX_PTHREAD_LEGACY), 1)\n   CFLAGS   += -DGX_PTHREAD_LEGACY\n   CXXFLAGS += -DGX_PTHREAD_LEGACY\nendif\n\nMACHDEP := -DGEKKO -DHW_RVL -mrvl -mcpu=750 -meabi -mhard-float\nCFLAGS += -Wall -std=gnu99 $(MACHDEP) $(INCLUDE)\nLDFLAGS := $(MACHDEP) -Wl,-Map,$(notdir $(ELF_TARGET)).map\n\nifeq ($(EXTERNAL_LIBOGC), 1)\nLIBS := -lfat\nendif\n\nLIBS += -lwiiuse -logc -lbte\n\nAPP_BOOTER_DIR = wii/app_booter\n\nOBJ = frontend/frontend_salamander.o \\\n\t\tfrontend/frontend_driver.o \\\n\t\tfrontend/drivers/platform_gx.o \\\n\t\tfrontend/drivers/platform_wii.o \\\n\t\tlibretro-common/file/file_path.o \\\n\t\tlibretro-common/file/file_path_io.o \\\n\t\tlibretro-common/hash/lrc_hash.o \\\n\t\tlibretro-common/string/stdstring.o \\\n\t\tlibretro-common/lists/string_list.o \\\n\t\tlibretro-common/lists/dir_list.o \\\n\t\tlibretro-common/streams/file_stream.o \\\n\t\tlibretro-common/vfs/vfs_implementation.o \\\n\t\tlibretro-common/file/retro_dirent.o \\\n\t\tlibretro-common/encodings/encoding_utf.o \\\n\t\tlibretro-common/compat/compat_strl.o \\\n\t\tlibretro-common/compat/compat_strldup.o \\\n\t\tlibretro-common/compat/compat_strcasestr.o \\\n\t\tlibretro-common/compat/fopen_utf8.o \\\n\t\tlibretro-common/file/config_file.o \\\n\t\tlibretro-common/time/rtime.o \\\n\t\tverbosity.o \\\n\t\t$(APP_BOOTER_DIR)/app_booter.binobj\n\nifeq ($(EXTERNAL_LIBOGC), 1)\nelse\nOBJ += wii/libogc/libfat/cache.o \\\n\t\twii/libogc/libfat/directory.o \\\n\t\twii/libogc/libfat/disc.o \\\n\t\twii/libogc/libfat/fatdir.o \\\n\t\twii/libogc/libfat/fatfile.o \\\n\t\twii/libogc/libfat/file_allocation_table.o \\\n\t\twii/libogc/libfat/filetime.o \\\n\t\twii/libogc/libfat/libfat.o \\\n\t\twii/libogc/libfat/lock.o \\\n\t\twii/libogc/libfat/partition.o\nendif\n\nifeq ($(HAVE_LOGGER), 1)\nCFLAGS\t\t+= -DHAVE_LOGGER\nCFLAGS          += -DPC_DEVELOPMENT_IP_ADDRESS=\\\"$(PC_DEVELOPMENT_IP_ADDRESS)\\\" -DPC_DEVELOPMENT_UDP_PORT=$(PC_DEVELOPMENT_UDP_PORT)\nOBJ             += network/net_logger.o \\\n\t\t\t\t\t\t libretro-common/net/net_compat.o \\\n\t\t\t\t\t\t libretro-common/net/net_socket.o\nendif\n\nifeq ($(HAVE_FILE_LOGGER), 1)\nCFLAGS\t\t+= -DHAVE_FILE_LOGGER\nendif\n\nCFLAGS += -std=gnu99 -DIS_SALAMANDER -DRARCH_CONSOLE -DHAVE_RARCH_EXEC -DGEKKO -Wno-char-subscripts\n\nifeq ($(DEBUG), 1)\n   CFLAGS += -O0 -g\nelse\n   CFLAGS += -O3\nendif\n\nifeq ($(USBGECKO), 1)\nLIBS += -ldb\nCFLAGS += -DUSBGECKO\nendif\n\nall: $(DOL_TARGET)\n\n%.dol: %.elf\n\t$(ELF2DOL) $< $@\n\n$(ELF_TARGET): $(OBJ)\n\t$(CXX) -o $@ $(LDFLAGS) $(LIBDIRS) $(OBJ) $(LIBS)\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c -o $@ $<\n\n%.binobj: %.bin\n\t$(LD) -r -b binary -o $@ $<\n\n$(APP_BOOTER_DIR)/app_booter.bin:\n\texport EXTERNAL_LIBOGC\n\t$(MAKE) -C $(APP_BOOTER_DIR)\n\npkg: all\n\tcp -r $(DOL_TARGET) pkg/wii/boot.dol\n\nclean:\n\trm -f $(DOL_TARGET)\n\trm -f $(ELF_TARGET)\n\trm -f $(OBJ)\n\t$(MAKE) -C $(APP_BOOTER_DIR) clean\n\n.PHONY: clean\n"
        },
        {
          "name": "Makefile.wiiu",
          "type": "blob",
          "size": 10.1328125,
          "content": "TARGET := retroarch_wiiu\n\nBUILD_HBL_ELF              = 1\nBUILD_RPX                  = 1\nDEBUG                      = 0\nGRIFFIN_BUILD              = 0\nSALAMANDER_BUILD           = 0\nHAVE_STATIC_DUMMY ?= 0\nWHOLE_ARCHIVE_LINK         = 0\nWIIU_HID                   = 1\nHAVE_HID                   = 1\nHAVE_RUNAHEAD              = 1\nWIIU_LOG_RPX               = 0\nBUILD_DIR                  = objs/wiiu\nPC_DEVELOPMENT_TCP_PORT    ?=\nLOAD_WITHOUT_CORE_INFO     ?= 0\n\nifeq ($(SALAMANDER_BUILD),1)\n   BUILD_DIR := $(BUILD_DIR)-salamander\n   TARGET    := $(TARGET)_salamander\nelse ifeq ($(GRIFFIN_BUILD),1)\n   BUILD_DIR := $(BUILD_DIR)-griffin\nendif\n\nifeq ($(DEBUG),1)\n   BUILD_DIR := $(BUILD_DIR)-debug\nendif\n\nifneq ($(V), 1)\n   Q := @\nendif\n\nDEFINES :=\nOBJ :=\nINCDIRS :=\n\n#-----------------------------\n# Features and object files\n\nOBJ += wiiu/main.o\nOBJ += wiiu/system/memory.o\nOBJ += wiiu/system/atomic.o\nOBJ += wiiu/system/exception_handler.o\nOBJ += wiiu/system/missing_libc_functions.o\nOBJ += wiiu/fs/sd_fat_devoptab.o\nOBJ += wiiu/fs/fs_utils.o\nOBJ += wiiu/hbl.o\n\nRPX_OBJ = $(BUILD_DIR)/wiiu/system/stubs_rpl.o\nHBL_ELF_OBJ = $(BUILD_DIR)/wiiu/system/dynamic.o \\\n              $(BUILD_DIR)/wiiu/system/stubs_elf.o\n\nifeq ($(SALAMANDER_BUILD),1)\n   DEFINES += -DRARCH_CONSOLE -DIS_SALAMANDER\n\n   OBJ += frontend/frontend_salamander.o\n   OBJ += frontend/frontend_driver.o\n   OBJ += frontend/drivers/platform_wiiu.o\n   OBJ += libretro-common/encodings/encoding_utf.o\n   OBJ += libretro-common/compat/compat_strcasestr.o\n   OBJ += libretro-common/compat/fopen_utf8.o\n   OBJ += libretro-common/file/file_path.o\n   OBJ += libretro-common/file/file_path_io.o\n   OBJ += libretro-common/string/stdstring.o\n   OBJ += libretro-common/lists/string_list.o\n   OBJ += libretro-common/lists/dir_list.o\n   OBJ += libretro-common/file/retro_dirent.o\n   OBJ += libretro-common/compat/compat_strl.o\n   OBJ += libretro-common/compat/compat_strldup.o\n   OBJ += libretro-common/file/config_file.o\n   OBJ += libretro-common/streams/file_stream.o\n   OBJ += libretro-common/vfs/vfs_implementation.o\n   OBJ += libretro-common/hash/lrc_hash.o\n   OBJ += libretro-common/time/rtime.o\n   OBJ += verbosity.o\n\n# $(SALAMANDER_BUILD),0\nelse\n   DEFINES += -DRARCH_INTERNAL\n   DEFINES += -DHAVE_SCREENSHOTS\n   DEFINES += -DHAVE_KEYMAPPER\n   DEFINES += -DHAVE_ONLINE_UPDATER\n   DEFINES += -DHAVE_UPDATE_ASSETS\n   DEFINES += -DHAVE_UPDATE_CORES\n   DEFINES += -DHAVE_UPDATE_CORE_INFO\n   DEFINES += -DHAVE_FILTERS_BUILTIN\n   DEFINES += -DHAVE_SLANG\n   DEFINES += -DHAVE_SHADERPIPELINE\n\nifeq ($(HAVE_RUNAHEAD),1)\n   DEFINES += -DHAVE_RUNAHEAD\nendif\nifeq ($(LOAD_WITHOUT_CORE_INFO),1)\n   DEFINES += -DLOAD_WITHOUT_CORE_INFO\nendif\n\n   OBJ += wiiu/shader_utils.o\n   OBJ += gfx/drivers/gx2_shaders/tex.o\n   OBJ += gfx/drivers/gx2_shaders/sprite.o\n   OBJ += gfx/drivers/gx2_shaders/frame.o\n   OBJ += gfx/drivers/gx2_shaders/ribbon.o\n   OBJ += gfx/drivers/gx2_shaders/ribbon_simple.o\n   OBJ += gfx/drivers/gx2_shaders/bokeh.o\n   OBJ += gfx/drivers/gx2_shaders/snow.o\n   OBJ += gfx/drivers/gx2_shaders/snow_simple.o\n   OBJ += gfx/drivers/gx2_shaders/snowflake.o\n\n   ifeq ($(GRIFFIN_BUILD), 1)\n      OBJ += griffin/griffin.o griffin/griffin_cpp.o\n\n      INCDIRS += -Ilibretro-common/include/compat/zlib\n      # for stb, libfat, iosuhax\n      INCDIRS += -Ideps -Ideps/libfat/include -Ideps/libiosuhax/include\n      # pad_functions uses wiiu/input.h\n      INCDIRS += -Iinput/include\n      INCDIRS += -Ideps/SPIRV-Cross\n\n      DEFINES += -DHAVE_AUDIOMIXER\n      DEFINES += -DHAVE_RWAV\n      DEFINES += -DHAVE_GRIFFIN=1 -DHAVE_MENU -DHAVE_GFX_WIDGETS -DHAVE_CONFIGFILE -DHAVE_PATCH -DHAVE_CHEATS -DHAVE_RGUI -DHAVE_LIBRETRODB\n\t\tDEFINES += -DHAVE_REWIND\n      DEFINES += -DHAVE_ZLIB -DHAVE_RPNG -DHAVE_RJPEG -DHAVE_RBMP -DHAVE_RTGA -DHAVE_CC_RESAMPLER\n      DEFINES += -DHAVE_SPIRV_CROSS -DHAVE_SLANG\n      DEFINES += -DHAVE_STB_FONT -DHAVE_STB_VORBIS -DHAVE_LANGEXTRA -DHAVE_LIBRETRODB -DHAVE_NETWORKING -DHAVE_IFINFO -DHAVE_NETPLAYDISCOVERY\n      #DEFINES += -DWANT_IFADDRS\n      #DEFINES += -DHAVE_FREETYPE\n      DEFINES += -DHAVE_XMB -DHAVE_MATERIALUI\n      DEFINES += -DHAVE_HID\n      DEFINES += -DWANT_LIBFAT -DHAVE_LIBFAT -DWANT_IOSUHAX -DHAVE_IOSUHAX\n      DEFINES += -DHAVE_CORE_INFO_CACHE\n      DEFINES += -DSPIRV_CROSS_EXCEPTIONS_TO_ASSERTIONS\n\n   # $(GRIFFIN_BUILD),0\n   else\n      HAVE_SCREENSHOTS = 1\n      HAVE_AUDIOMIXER = 1\n      HAVE_RWAV = 1\n      HAVE_MENU_COMMON = 1\n      HAVE_GFX_WIDGETS = 1\n      HAVE_RTGA = 1\n      HAVE_RPNG = 1\n      HAVE_RJPEG = 1\n      HAVE_RBMP = 1\n      HAVE_CONFIGFILE = 1\n      HAVE_PATCH      = 1\n      HAVE_XDELTA     = 0 # disabled because <lzma.h> isn't available (or we haven't figured out how to install it)\n      HAVE_REWIND     = 1\n      HAVE_CHEATS     = 1\n      HAVE_MENU = 1\n      HAVE_RGUI = 1\n      HAVE_7ZIP = 1\n      HAVE_ZLIB = 1\n      HAVE_BUILTINZLIB = 0\n      HAVE_LIBRETRODB = 1\n      HAVE_MATERIALUI = 1\n      HAVE_XMB = 1\n      HAVE_STB_FONT = 1\n      #HAVE_FREETYPE = 1\n      HAVE_LANGEXTRA = 1\n      HAVE_LIBRETRODB = 1\n      HAVE_NETWORKING = 1\n      HAVE_IFINFO = 1\n      HAVE_NETPLAYDISCOVERY = 1\n      HAVE_CHEEVOS = 1\n      #WANT_IFADDRS = 1\n      HAVE_OVERLAY = 1\n      HAVE_SPIRV_CROSS = 1\n      HAVE_SLANG = 1\n      HAVE_DSP_FILTER = 1\n      HAVE_VIDEO_FILTER = 1\n      HAVE_STATIC_VIDEO_FILTERS = 1\n      HAVE_STATIC_AUDIO_FILTERS = 1\n      WANT_LIBFAT = 1\n      WANT_IOSUHAX = 1\n      HAVE_CORE_INFO_CACHE = 1\n\n      include Makefile.common\n      DEFINES += $(DEF_FLAGS)\n      INCDIRS += $(INCLUDE_DIRS)\n   endif\nendif\n\nOBJ := $(addprefix $(BUILD_DIR)/,$(OBJ))\n\n#-----------------------------\n# Compile flags\n\nDEFINES += -DWIIU -D__WUT__ -DHW_WUP -D__wiiu__\nDEFINES += -DHAVE_MAIN\nDEFINES += -DRARCH_CONSOLE\n\nifeq ($(WIIU_LOG_RPX),1)\n   DEFINES += -DWIIU_LOG_RPX\nendif\n\nifneq ($(PC_DEVELOPMENT_TCP_PORT),)\n   DEFINES += -DPC_DEVELOPMENT_TCP_PORT=$(PC_DEVELOPMENT_TCP_PORT)\nendif\n\nINCDIRS += -I.\nINCDIRS += -Ilibretro-common/include\nINCDIRS += -Iwiiu\nINCDIRS += -Iwiiu/include\n\nCFLAGS  := -mcpu=750 -meabi -mhard-float\nCFLAGS  += -ffast-math -Werror=implicit-function-declaration\nCFLAGS  += -ffunction-sections -fdata-sections\n#CFLAGS += -fomit-frame-pointer -mword-relocations\nCFLAGS += -Wall\n\nifeq ($(DEBUG), 1)\n   CFLAGS += -O0 -g\nelse\n   CFLAGS += -O3\nendif\n\nASFLAGS := $(CFLAGS) -mregnames\n\n#-----------------------------\n# Linking/library flags\n\nLIBDIRS := -L.\nLDFLAGS := $(CFLAGS)\n\nifeq ($(WHOLE_ARCHIVE_LINK), 1)\n   WHOLE_START := -Wl,--whole-archive\n   WHOLE_END := -Wl,--no-whole-archive\nendif\n\nLIB_CORE :=\n\nifeq ($(HAVE_STATIC_DUMMY),1)\n  DEFINES += -DHAVE_STATIC_DUMMY\nelse\n  LIB_CORE += -lretro_wiiu\nendif\n\n\nLIBS := $(WHOLE_START) $(LIB_CORE) $(WHOLE_END) -lm\n\n# Use portlibs zlib if deps/ isn't being used\nifeq ($(HAVE_ZLIB),1)\nifeq ($(HAVE_BUILTINZLIB),0)\n   INCDIRS += -I$(DEVKITPRO)/portlibs/ppc/include\n   LIBDIRS += -L$(DEVKITPRO)/portlibs/ppc/lib\n   # Bonus: libpng for cores that need it\n   LIBS += -lpng -lz\nendif\nendif\n\nLDFLAGS += -Wl,--gc-sections\n\nRPX_LDFLAGS      := -pie -fPIE\nRPX_LDFLAGS      += -z common-page-size=64 -z max-page-size=64\nRPX_LDFLAGS      += -T wiiu/link_rpl.ld\nRPX_LDFLAGS      += -nostartfiles\n\nHBL_ELF_LDFLAGS  := -T wiiu/link_elf.ld\n\n#-----------------------------\n# Compiler setup\n\nifeq ($(strip $(DEVKITPPC)),)\n$(error \"Please set DEVKITPPC in your environment. export DEVKITPPC=<path to>devkitPPC\")\nendif\nifeq ($(strip $(DEVKITPRO)),)\n$(error \"Please set DEVKITPRO in your environment. export DEVKITPRO=<path to>devkitPRO\")\nendif\n\nexport PATH   := $(PATH):$(DEVKITPPC)/bin\n\nPREFIX := powerpc-eabi-\n\nCC      := $(PREFIX)gcc\nCXX     := $(PREFIX)g++\nAS      := $(PREFIX)as\nAR      := $(PREFIX)ar\nOBJCOPY := $(PREFIX)objcopy\nSTRIP   := $(PREFIX)strip\nNM      := $(PREFIX)nm\nLD      := $(CXX)\n\nELF2RPL   := wiiu/wut/elf2rpl/elf2rpl\n\nifneq ($(findstring Linux,$(shell uname -a)),)\nelse ifneq ($(findstring Darwin,$(shell uname -a)),)\nelse\n   ELF2RPL   := $(ELF2RPL).exe\nendif\n\n#-----------------------------\n# Targets and build rules\n\nTARGETS :=\nifeq ($(BUILD_RPX), 1)\nTARGETS += $(TARGET).rpx\nendif\n\nifeq ($(BUILD_HBL_ELF), 1)\nTARGETS += $(TARGET).elf\nendif\n\nDEPFLAGS    = -MT $@ -MMD -MP -MF $(BUILD_DIR)/$*.depend\n\nall: $(TARGETS)\n\n%: $(BUILD_DIR)/%\n\tcp $< $@\n\n$(BUILD_DIR)/%.o: %.cpp %.depend\n\t@$(if $(Q), echo CXX $<,)\n\t@mkdir -p $(dir $@)\n\t$(Q)$(CXX) -c -o $@ $< $(CXXFLAGS) $(DEFINES) $(INCDIRS) $(DEPFLAGS)\n\n$(BUILD_DIR)/%.o: %.c %.depend\n\t@$(if $(Q), echo CC $<,)\n\t@mkdir -p $(dir $@)\n\t$(Q)$(CC) -c -o $@ $< $(CFLAGS) $(DEFINES) $(INCDIRS) $(DEPFLAGS)\n\n$(BUILD_DIR)/%.o: %.S %.depend\n\t@$(if $(Q), echo AS $<,)\n\t@mkdir -p $(dir $@)\n\t$(Q)$(CC) -c -o $@ $< $(ASFLAGS) $(DEFINES) $(INCDIRS) $(DEPFLAGS)\n\n$(BUILD_DIR)/%.o: %.s %.depend\n\t@$(if $(Q), echo AS $<,)\n\t@mkdir -p $(dir $@)\n\t$(Q)$(CC) -c -o $@ $< $(ASFLAGS) $(INCDIRS) $(DEPFLAGS)\n%.a:\n\t@$(if $(Q), echo AR $<,)\n\t@mkdir -p $(dir $@)\n\t$(Q)$(AR) -rc $@ $^\n\n%.depend: ;\n%.last: ;\n\n$(ELF2RPL):\n\t@$(if $(Q), echo MAKE $@,)\n\t$(Q)$(MAKE) -C wiiu/wut/elf2rpl/\n\n$(BUILD_DIR)/$(TARGET).elf: $(OBJ) $(HBL_ELF_OBJ) libretro_wiiu.a wiiu/link_elf.ld .$(TARGET).elf.last\n\t@$(if $(Q), echo LD $@,)\n\t@touch .$(TARGET).elf.last\n\t$(Q)$(LD) $(OBJ) $(HBL_ELF_OBJ) $(LDFLAGS) $(HBL_ELF_LDFLAGS) $(LIBDIRS) $(LIBS) -o $@\n\n$(BUILD_DIR)/$(TARGET).rpx.elf: $(OBJ) $(RPX_OBJ) libretro_wiiu.a wiiu/link_elf.ld\n\t@$(if $(Q), echo LD $@,)\n\t$(Q)$(LD) $(OBJ) $(RPX_OBJ) $(LDFLAGS) $(RPX_LDFLAGS) $(LIBDIRS)  $(LIBS) -o $@\n\n$(BUILD_DIR)/$(TARGET).large.rpx: $(BUILD_DIR)/$(TARGET).rpx.elf $(ELF2RPL) .$(TARGET).rpx.large.last\n\t@$(if $(Q), echo ELF2RPL $@,)\n\t@touch .$(TARGET).rpx.large.last\n\t$(Q)-$(ELF2RPL) $< $@\n\n$(BUILD_DIR)/$(TARGET).rpx: $(BUILD_DIR)/$(TARGET).large.rpx .$(TARGET).rpx.last\n\t@$(if $(Q), echo COMPRESS $@,)\n\t@touch .$(TARGET).rpx.large.last\n\t$(Q)wiiurpxtool -c $< $@\n\nclean:\n\t@$(if $(Q), echo $@,)\n\t$(Q)rm -f $(OBJ) $(RPX_OBJ) $(HBL_ELF_OBJ) $(TARGET).elf $(TARGET).rpx.elf $(TARGET).rpx\n\t$(Q)rm -f $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).rpx.elf $(BUILD_DIR)/$(TARGET).large.rpx $(BUILD_DIR)/$(TARGET).rpx\n\t$(Q)rm -f .$(TARGET).elf.last .$(TARGET).rpx.elf.last .$(TARGET).rpx.large.last .$(TARGET).rpx.last\n\t$(Q)rm -f $(OBJ:.o=.depend) $(RPX_OBJ:.o=.depend) $(HBL_ELF_OBJ:.o=.depend)\n\t$(Q)$(MAKE) -C wiiu/wut/elf2rpl/ clean\n\n.PHONY: clean all\n.PRECIOUS: %.depend %.last\n\n-include $(OBJ:.o=.depend) $(RPX_OBJ:.o=.depend) $(HBL_ELF_OBJ:.o=.depend)\n"
        },
        {
          "name": "Makefile.win",
          "type": "blob",
          "size": 3.6630859375,
          "content": "TARGET = retroarch.exe\n\nHAVE_SCREENSHOTS = 1\nHAVE_AUDIOMIXER = 1\nHAVE_RWAV = 1\nHAVE_DINPUT = 1\nHAVE_XAUDIO = 1\nHAVE_DSOUND = 1\nHAVE_WASAPI = 1\nHAVE_OPENGL = 1\nHAVE_DYLIB = 1\nHAVE_D3D9 = 1\nHAVE_NETWORKING = 1\nHAVE_IFINFO = 1\nHAVE_NETPLAYDISCOVERY = 1\nHAVE_STDIN_CMD = 1\nHAVE_COMMAND = 1\nHAVE_THREADS = 1\nHAVE_MENU = 1\nHAVE_CONFIGFILE = 1\nHAVE_PATCH      = 1\nHAVE_REWIND     = 1\nHAVE_CHEATS     = 1\nHAVE_RGUI = 1\nHAVE_MATERIALUI = 1\nHAVE_DSP_FILTER = 1\nHAVE_VIDEO_FILTER = 1\nHAVE_7ZIP = 1\nDYNAMIC = 1\nHAVE_CORE_INFO_CACHE = 1\n\nHAVE_XINPUT = 1\nHAVE_WINMM = 1\n\nHAVE_SDL      := 0\nHAVE_SDL2     := 0\nHAVE_RSOUND   := 0\n\nHAVE_STB_FONT := 1\nHAVE_FREETYPE := 1\nHAVE_FFMPEG   := 0\n\nHAVE_CG       := 1\nHAVE_ZLIB     := 1\nHAVE_CC_RESAMPLER := 1\n\nifeq ($(HAVE_CG), 1)\nCG_LIBS          := -lcg -lcgGL\nendif\n\nifeq ($(HAVE_FREETYPE), 1)\nFREETYPE_CFLAGS  := -DHAVE_FREETYPE -Ifreetype2\nFREETYPE_LIBS    := -lfreetype\nendif\n\nifeq ($(HAVE_SDL), 1)\nSDL_LIBS         := -lSDL\nSDL_CFLAGS       := -ISDL -DHAVE_SDL\nBSD_LOCAL_INC    :=\nendif\n\nifeq ($(HAVE_SDL2), 1)\nSDL2_LIBS        := -lSDL2\nSDL2_CFLAGS      := -ISDL2 -DHAVE_SDL2\nendif\n\nifeq ($(HAVE_D3D8), 1)\nD3D8_LIBS        := -ld3d8\nifeq ($(HAVE_D3DX), 1)\nD3DX8_LIBS       := -ld3dx8\nendif\nendif\n\nifeq ($(HAVE_D3D9), 1)\nD3D9_LIBS        := -ld3d9\nifeq ($(HAVE_D3DX), 1)\nD3DX9_LIBS       := -ld3dx9\nendif\nendif\n\nifeq ($(HAVE_RSOUND), 1)\nRSOUND_CFLAGS    := -DHAVE_RSOUND\nRSOUND_LIBS      := -lrsound\nendif\n\nifeq ($(HAVE_FFMPEG), 1)\nAVCODEC_LIBS     := -lavcodec\nAVUTIL_LIBS      := -lavutil\nSWSCALE_LIBS     := -lswscale\nAVFORMAT_LIBS    := -lavformat\nSWRESAMPLE_LIBS  := -lswresample\nFFMPEG_LIBS      := -lws2_32 -lz\nendif\n\nOBJDIR           := obj-w32\n\nOS               := Win32\nOBJ              :=\nLIBS             := -lm\nDEFINES\t\t\t  :=\nDEFINES          += -I. -Ilibretro-common/include -Ilibretro-common/include/compat/zlib -DRARCH_INTERNAL -DHAVE_SCREENSHOTS -DHAVE_OVERLAY\nLDFLAGS          := -L. -static-libgcc\n\ninclude Makefile.common\n\nHEADERS = $(wildcard */*/*.h) $(wildcard */*.h) $(wildcard *.h)\n\nifneq ($(HOST_PREFIX),)\n   CC = $(HOST_PREFIX)gcc\n   CXX = $(HOST_PREFIX)g++\n   WINDRES = $(HOST_PREFIX)windres\nelse\n   CC = gcc\n   CXX = g++\n   WINDRES = windres\nendif\n\nlibretro ?= -lretro\n\nifeq ($(DYNAMIC), 1)\n   DEFINES += -DHAVE_DYNAMIC\nelse\n   LIBS += $(libretro)\nendif\n\nifneq ($(V), 1)\n   Q := @\nendif\n\nifeq ($(DEBUG), 1)\n   CFLAGS += -O0 -g\n   CXXFLAGS += -O0 -g\nelse\n   CFLAGS += -O3 -ffast-math\n   CXXFLAGS += -O3 -ffast-math\nendif\n\nCFLAGS += $(DEF_FLAGS) -Wall -Wno-unused-result -Wno-unused-variable -I. -Ideps\nCXXFLAGS += -Wall -Wno-unused-result -Wno-unused-variable -I. -Ideps -std=c++98 -D__STDC_CONSTANT_MACROS\nifeq ($(CXX_BUILD), 1)\n   CFLAGS += -std=c++98 -xc++ -D__STDC_CONSTANT_MACROS\nelse\n   ifneq ($(GNU90_BUILD), 1)\n      CFLAGS += -std=gnu99\n   endif\nendif\n\nRARCH_OBJ := $(addprefix $(OBJDIR)/,$(OBJ))\n\nall: $(TARGET)\n\n-include $(RARCH_OBJ:.o=.d)\n\n$(TARGET): $(RARCH_OBJ)\n\t@$(if $(Q), $(shell echo echo LD $@),)\n\t$(Q)$(CXX) -o $@ $(RARCH_OBJ) $(LIBS) $(LDFLAGS) $(LDCXXFLAGS)\n\n#those mkdir shenanigans are really ugly, but I can't find any better solution\n$(OBJDIR)/%.o: %.c\n\t@-mkdir -p $(dir $@) || mkdir $(subst /,\\,$(dir $@)) || echo .\n\t@$(if $(Q), $(shell echo echo CC $<),)\n\t$(Q)$(CC) $(CFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.cpp | $(dir $@)\n\t@-mkdir -p $(dir $@) || mkdir $(subst /,\\,$(dir $@)) || echo .\n\t@$(if $(Q), $(shell echo echo CXX $<),)\n\t$(Q)$(CXX) $(CXXFLAGS) $(DEFINES) -MMD -c -o $@ $<\n\n$(OBJDIR)/%.o: %.rc $(HEADERS)\n\t@-mkdir -p $(dir $@) || mkdir $(subst /,\\,$(dir $@)) || echo .\n\t@$(if $(Q), $(shell echo echo WINDRES $<),)\n\t$(Q)$(WINDRES) $(DEFINES) -o $@ $<\n\nclean:\n\trm -rf $(OBJDIR)\n\trm -f $(TARGET)\n\trm -f *.d\n\n.PHONY: all install uninstall clean\n"
        },
        {
          "name": "README-OMAP.md",
          "type": "blob",
          "size": 1.787109375,
          "content": "# RetroArch OMAP video driver\n\nThe OMAP video driver for RetroArch uses the omapfb (OMAP framebuffer) driver from the Linux kernel. omapfb is not to be confused with omapdrm, which is the corresponding DRM driver.\nOMAP framebuffer support is available on platforms like the Pandora (OMAP3) handheld console, the Beagleboard (OMAP3) single-board computer or the Pandaboard (OMAP4), which is also a single-board computer.\nThe OMAP display hardware provides free scaling to native screen dimensions, using a high-quality polyphase filter.\n\n## DSS setup\n\nThe DSS is the underlying layer, which manages the OMAP display hardware. Through DSS we can setup which framebuffer device outputs to which display device. For example there are three framebuffer devices (fb0, fb1 and fb2) on the Pandaboard, each one connected to a 'overlay' device. The DSS controls are exported in '/sys/devices/platform/omapdss'. Here we configure fb1 to connect to our HDMI display connected to the board.\n\nFirst we disable the overlay we want to use and the two displays:\n\n    echo -n 0 > overlay1/enabled\n    echo -n 0 > display0/enabled\n    echo -n 0 > display1/enabled\n\nCheck that 'manager1' (name = tv) is connected to HDMI:\n\n    cat manager1/display:\n    hdmi\n\nThe free scaling property mentioned above is not available on all overlays. Here 'overlay1' supports zero-cost scaling.\n\nNow we connect 'overlay1' to 'manager1':\n\n    echo -n tv > overlay1/manager\n\nLast but not least enable the overlay and the HDMI display:\n\n    echo -n 1 > overlay1/enabled\n    echo -n 1 > display0/enabled\n\n## Configuration\n\nThe video driver name is 'omap'. It honors the following video settings:\n\n   - video\\_monitor\\_index (selects the fb device used, index = 1 -> fb0, index = 2 -> fb1, etc.)\n   - video\\_vsync (use to disable vsync, however this is not recommended)\n"
        },
        {
          "name": "README-exynos.md",
          "type": "blob",
          "size": 5.2421875,
          "content": "# RetroArch Exynos-G2D video driver\n\nThe Exynos-G2D video driver for RetroArch uses the Exynos DRM layer for presentation and the Exynos G2D block to scale and blit the emulator framebuffer to the screen. The G2D subsystem is a separate functional block on modern Samsung Exynos SoCs (in particular Exynos4412 and Exynos5250) that accelerates various kind of 2D blit operations. It can fill, copy, scale and blend pixel buffers and therefore provides adequate functionality for RetroArch purposes.\n\n## Reasons to use the driver\n\nHardware accelerated rendering on devices based on an Exynos SoC is usually restricted to the use of the GPU block, which is either a Mali or PowerVR IP. Both GPU types have the problem that interfacing with them requires a proprietary driver stack, comprised of kernel and userspace code. While the kernel code is open source, the userspace code is only available as a binary blob to the enduser.\n\nIf you want to use such a device with an upstream kernel, the GPU block will most likely not work for you. Also the chances of Mali or PowerVR kernel code being accepted upstream is very slim. Still, one might want to ask the question if using the GPU block for such trivial operations (basically scale and blend) is the right approach in the first place.\n\nSince the G2D block is present on all modern Exynos SoCs, the natural way of proceeding would be to use it instead of the GPU block. The G2D is still a dedicated piece of hardware, so all operations are offloaded from the CPU. It should be noted though, that using the G2D instead of the GPU removes the possibility to use GPU shaders to enhance the image quality of your emulator core of choice. If the user relies on these enhancements, then he's advised to continue using the GPU, most likely by using the EGL/GLES video driver.\n\nThe author uses a Hardkernel ODROID-X2, which is an developer board powered by an Exynos4412 SoC. The vendor supplied kernel, a Linux tree based on the 3.8.y branch, currently offers no way to use the G2D because of issues related to clock setup. However upstreaming work is in progress and a tree based on 3.15.y, with some slight modifications, is available from here:\n\n[odroid-3.15.y repository](https://github.com/tobiasjakobi/linux-odroid)\n\nPlease refer to the minimalistic documentation in README-ODROID for setup.\n\n## Performance analysis\n\nSome simple benchmarking was done to evaluate the performance of the G2D block. The test run was done with the snes9x-next emulation core and a game title that uses a native resolution of 256x224 pixels. The output screen was configured to a 1280x720 mode. Scaling to the output screen was done by keeping the native aspect ratio. In this case this would result in an output rectangle of size 822x720.\n\n    total memcpy calls: 18795\n    total g2d calls: 18795\n    total memcpy time: 8.978532 seconds\n    total g2d time: 29.703944 seconds\n    average time per memcpy call: 477.708540 microseconds\n    average time per g2d call: 1580.417345 microseconds\n\nThe average time to display the emulator framebuffer on screen is roughly 2058 microseconds, or around 486 frames per second. Assuming that the time consumption increases linearly with the amount of pixels processed, which is usually a safe assumption, scaling to an output rectangle of size 1920x1080 would yield a average duration of 7207 microseconds, which is still 138 frames per second.\n\n## Configuration\n\nThe video driver uses the libdrm API to interface with the DRM. Some patches are still missing in the upstream tree, therefore the user is advised to use the 'exynos' branch of the repository mentioned below.\n\n[libdrm repository](https://github.com/tobiasjakobi/libdrm)\n\nMake sure that the Exynos API support is enabled. If you're building libdrm from source, then use\n\n    ./configure --enable-exynos-experimental-api\n\nto enable it.\n\nThe video driver name is 'exynos'. It honors the following video settings:\n\n   - video\\_monitor\\_index\n   - video\\_fullscreen\\_x and video\\_fullscreen\\_y\n\nThe monitor index maps to the DRM connector index. If it is zero, then it just selects the first 'sane' connector, which means that it is connected to a display device and it provides at least one useable mode. If the value is non-zero, it forces the selection of this connector. For example, on the author's ODROID-X2, with an odroid-3.15.y kernel, the HDMI connector has index 1.\n\nThe two fullscreen parameters select the mode the DRM should select. If zero, the native connector mode is selected. If non-zero, the DRM tries to select the wanted mode. This might fail if the mode is not available from the connector.\n\n## Issues and TODOs\n\nThe driver still suffers from some issues.\n\n   - The aspect ratio computation can be improved. In particular the user supplied aspect ratio is currently unused.\n   - Font rendering and blitting is very inefficient since the backing buffer is cleared every frame. Introduce a invalidation rectangle which covers the region where font glyphs are drawn, and then only clear this region. Also consider converting the buffer to A8 color format and using global color (not sure if this is possible).\n   - Temporary GEM buffers are used as source for blitting operations. Support for the IOMMU has to be enabled, so that one can use the 'userptr' functionality.\n   - More TODOs are pointed out in the code itself.\n"
        },
        {
          "name": "README-mali_fbdev_r4p0.md",
          "type": "blob",
          "size": 3.2841796875,
          "content": "USAGE NOTES\n===========\n\nThis driver is meant for devices with Allwinner SoCs with Mali400 3D block and a\ngood fbdev implementation. It is derived from the old Android GLES driver.\n\nIt was meant to be used on Cubieboard/Cubieboard2/Cubietruck, but it should not\nbe used on an Odroid X2/U2/U3 where a superior solution (RetroArch exynos video driver) is available.\nFbdev implementation on Odroid hardware is missing WAITFORVSYNC ioctl, so use Exynos driver there.\n\nThis driver requires MALI r4p0 binary blobs for fbdev, and a kernel compatible with r4p0 binaries.\n\nSo we will use\n-This kernel          : https://github.com/mireq/linux-sunxi\n-This small patch     : https://gist.github.com/ssvb/8088519\n-Files in this thread : http://forum.odroid.com/viewtopic.php?f=52&t=4956\n\nFirst we will clone and build the kernel:\ngit clone https://github.com/mireq/linux-sunxi.git -b sunxi-3.4 --depth 1\n\nNow we edit drivers/video/sunxi/disp/dev_fb.c, and uncomment the line 1074:\n// Fb_wait_for_vsync(info);\n\nIt is assumed you have a cross-compiler installed, so we configure and build the kernel and modules:\n\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- sun7i_defconfig\n\n(This is for Cubieboard2, for other Sunxi boards look here: http://linux-sunxi.org/Linux_Kernel#Compilation)\n\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig\n\n(Just in case we want to customize kernel options. It is OK to build with default config)\n\nmake -j4 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- uImage modules\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- INSTALL_MOD_PATH=<path_to_rootfs_mountpoint> modules_install\n\ncp arch/arm/boot/uImage /<path_to_sd_rootfs_mountpoint>/boot/\n\nNow we should download and extract the EGL/GLES/GLES2 MALI FBDEV blobs from this thread:\n\nhttp://forum.odroid.com/viewtopic.php?f=52&t=4956\n\nThis is the exact link:\n\nhttp://builder.mdrjr.net/tools/r4p0-mp400-fbdev.tar\n\nCopy these libraries to /usr/lib.\n\nNow we need the headers. We can get them from here:\n\nhttp://malideveloper.arm.com/develop-for-mali/sdks/opengl-es-sdk-for-linux/#opengl-es-sdk-for-linux-download\n\nDownload whatever version you want. We just get the headers from here, not machine-dependant compiled code.\n\nExtract the files and copy the directories inside inc to /usr/include .\n\nAlso, copy simple_framework/inc/mali/EGL/fbdev_window.h to /usr/include/EGL .\n\nIn the end you should have this on your system:\n\n   /usr/include/EGL/\n      eglext.h\n      egl.h\n      eglplatform.h\n      fbdev_window.h\n   /usr/include/GLES/\n      glext.h\n      gl.h\n      glplatform.h\n   /usr/include/GLES2\n      gl2ext.h\n      gl2.h\n      gl2platform.h\n   /usr/include/GLES3\n      gl3ext.h\n      gl3.h\n      gl3platform.h\n\nTo enable mali_fbdev you must configure RetroArch with --enable-opengles and --enable-mali_fbdev.\n\nThis is an example of what you would use on a CubieBoard2 for a lightweight RetroArch:\n\n./configure --enable-opengles --enable-mali_fbdev --disable-x11 --disable-sdl2 --enable-floathard --disable-ffmpeg --disable-netplay --enable-udev --disable-sdl --disable-pulse --disable-oss --disable-freetype --disable-7zip\n\nNOTE: A TTY hack is used to auto-clean the console on exit, and the fbdev ioctls are used to retrieve\ncurrent video mode. Both things work good, but they are not exactly ideal solutions.\n\nIf you come up with something better, feel free to improve the driver.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.5537109375,
          "content": "[![Build Status](https://travis-ci.org/libretro/RetroArch.svg?branch=master)](https://travis-ci.org/libretro/RetroArch)\n[![Coverity Scan Build Status](https://scan.coverity.com/projects/8936/badge.svg)](https://scan.coverity.com/projects/retroarch)\n[![Crowdin](https://badges.crowdin.net/retroarch/localized.svg)](https://crowdin.com/project/retroarch)\n\n# RetroArch\n\nRetroArch is the reference frontend for the libretro API.\nPopular examples of implementations for this API includes video game system emulators and game engines as well as\nmore generalized 3D programs.\nThese programs are instantiated as dynamic libraries. We refer to these as \"libretro cores\".\n\n![XMB menu driver](docs/XMB-main-menu.jpg \"XMB menu driver\")\n\n![rgui menu driver](docs/rgui-main-menu.jpg \"rgui menu driver\")\n\n![glui menu driver](docs/glui-main-menu.jpg \"glui menu driver\")\n\n![ozone menu driver](docs/ozone-main-menu.jpg \"ozone menu driver\")\n\n## libretro\n\n[libretro](https://www.libretro.com) is an API that exposes generic audio/video/input callbacks.\nA frontend for libretro (such as RetroArch) handles video output, audio output, input and application lifecycle.\nA libretro core written in portable C or C++ can run seamlessly on many platforms with very little to no porting effort.\n\nWhile RetroArch is the reference frontend for libretro, several other projects have used the libretro\ninterface to include support for emulators and/or game engines. libretro is completely open and free for anyone to use.\n\n[libretro API header](https://github.com/libretro/RetroArch/blob/master/libretro-common/include/libretro.h)\n\n## Binaries\n\nLatest binaries are currently hosted on the [buildbot](http://buildbot.libretro.com/).\n\n## Support\n\nTo reach developers, either make an issue here on GitHub, make a thread on the [forum](https://www.libretro.com/forums/), chat on [discord](https://discord.gg/C4amCeV), or visit our IRC channel: #retroarch @ irc.freenode.org. You could create a post in [Reddit](https://www.reddit.com/r/RetroArch/) with *Technical Support* flair.\n\n## Documentation\n\nSee our [Documentation Center](https://docs.libretro.com/). On Unix, man-pages are provided.\nMore developer-centric stuff is found [here](https://docs.libretro.com/development/libretro-overview/).\n\n## Related projects\n\n   - Cg/HLSL shaders: [common-shaders](https://github.com/libretro/common-shaders)\n   - slang shaders: [slang-shaders](https://github.com/libretro/slang-shaders)\n   - GLSL shaders: [glsl-shaders](https://github.com/libretro/glsl-shaders)\n   - Helper scripts to build libretro implementations: [libretro-super](https://github.com/libretro/libretro-super)\n   - GitHub mirrors of projects, useful for generating diff files: [libretro-mirrors](https://github.com/libretro-mirrors/)\n\n## Philosophy\n\nRetroArch attempts to be small and lean\nwhile still having all the useful core features expected from an emulator.\nIt is designed to be very portable and features a gamepad-centric and touchscreen UI.\nIt also has a full-featured command-line interface.\n\nIn some areas, RetroArch goes beyond and emphasizes on not-so-common technical features such as multi-pass shader support,\nreal-time rewind (Braid-style), video recording (using FFmpeg), run-ahead input latency removal, etc.\n\nRetroArch also emphasizes being easy to integrate into various launcher frontends.\n\n## Platforms\n\nRetroArch has been ported to the following platforms:\n   - Android (2.x to most recent version)\n   - Apple iOS\n   - Apple macOS (PPC, x86-32 and x86-64)\n   - Apple tvOS\n   - Blackberry\n   - DOS\n   - Emscripten (WebAssembly and JavaScript)\n   - FreeBSD\n   - Haiku\n   - Linux\n   - Original Microsoft Xbox\n   - Microsoft Xbox 360 (Libxenon/XeXDK)\n   - Microsoft Xbox One\n   - Microsoft Xbox Series S/X\n   - Miyoo\n   - NetBSD\n   - Nintendo NES/SNES Classic Edition\n   - Nintendo GameCube\n   - Nintendo Wii\n   - Nintendo Switch\n   - Nintendo Wii U\n   - Nintendo 3DS/2DS\n   - OpenBSD\n   - OpenDingux\n   - PlayStation2\n   - PlayStation3\n   - PlayStation4\n   - PlayStation Portable\n   - PlayStation Vita\n   - Raspberry Pi\n   - ReactOS\n   - Redox OS\n   - RetroFW\n   - RS90\n   - SerenityOS\n   - Solaris\n   - Windows NT 3.5\n   - Windows 95\n   - Windows 98\n   - Windows 2000\n   - Windows XP\n   - Windows Millennium\n   - Windows Vista\n   - Windows 7\n   - Windows 8\n   - Windows 10\n   - Windows 11\n\n## Dependencies (PC)\n\nThere are no true hard dependencies per se.\n\nOn Windows, RetroArch can run with only Win32 as dependency.\n\nOn Linux, there are no true dependencies. For optimal usage, the\nfollowing dependencies come as recommended:\n\n   - GL headers / Vulkan headers\n   - X11 headers and libs, or EGL/KMS/GBM\n\nOSX port of RetroArch requires latest versions of Xcode to build.\n\nRetroArch can utilize these libraries if enabled:\n\n   - nvidia-cg-toolkit\n   - libfreetype2 (TTF font rendering on screen)\n\nRetroArch needs at least one of these audio driver libraries:\n\n   - ALSA\n   - OSS\n   - RoarAudio\n   - RSound\n   - OpenAL\n   - JACK\n   - SDL\n   - PulseAudio\n   - PipeWire\n   - XAudio2 (Win32, Xbox 360)\n   - DirectSound (Win32, Xbox 1)\n   - CoreAudio (OSX, iOS)\n\nTo run properly, RetroArch requires a libretro implementation present; however, as it's typically loaded\ndynamically, it's not required at build time.\n\n## Dependencies (Console ports, mobile)\n\nConsole ports have their own dependencies, but generally do not require\nanything other than what the respective SDKs provide.\n\n## Requirements\n\n### OpenGL1 ###\nYour videocard needs to at least support the OpenGL 1.1 spec.\n\n***Shaders***: N/A\n\n**Menu driver support**: MaterialUI, XMB, Ozone and RGUI should all work correctly.\nXMB won't have shader pipeline effects because of the aforementioned lack of shader\nsupport.\n\n### OpenGL2 ###\nYour videocard needs to at least support the OpenGL 2.1 spec.\n\n***Shaders:*** You can choose between either NVIDIA Cg shaders (deprecated, requires separate runtime\nto be installed on your system), or GLSL shaders.\n\n***Menu driver support:*** MaterialUI, XMB, Ozone and RGUI should all work correctly.\n\n### OpenGL3 ###\nYour videocard needs to at least support the OpenGL 3.2 core feature spec.\n\n***Shaders:*** You will be able to use modern Slang shaders with this driver.\n\n***Menu driver support:*** MaterialUI, XMB, Ozone and RGUI should all work correctly.\n\n### Direct3D 11 ###\nYour videocard needs to at least support the Direct3D11 11.0 spec. The card\nalso needs to support at least the Shader Model 4.0.\n\n***Shaders:*** You will be able to use modern Slang shaders with this driver.\n\n***Menu driver support:*** MaterialUI, XMB, Ozone and RGUI should all work correctly.\n\n### Vulkan ###\nYour videocard needs to at least support the Vulkan 1.0 spec.\n\n***Shaders:*** You will be able to use modern Slang shaders with this driver.\n\n***Menu driver support:*** MaterialUI, XMB, Ozone and RGUI should all work correctly.\n\n## Configuring\n\nThe default configuration is defined in `config.def.h`.\nIt is not recommended to change this unless you know what you're doing.\nThese can later be tweaked by using a config file.\nA sample configuration file is installed to `/etc/retroarch.cfg`. This is the system-wide config file.\n\nRetroArch will on startup create a config file in `$XDG\\_CONFIG\\_HOME/retroarch/retroarch.cfg` if it does not exist.\nUsers only need to configure a certain option if the desired value deviates from the value defined in config.def.h.\n\nTo configure joypads, use the built-in menu or manually configure them in `retroarch.cfg`.\n\n## Compiling and installing\n\nInstructions for compiling and installing RetroArch can be found in the [Libretro/RetroArch Documentation Center](https://docs.libretro.com/).\n\n## CRT 15Khz Resolution Switching\n\nCRT SwitchRes will turn on, on the fly. However, you will need to restart RetroArch to disable it. With CRT SwitchRes enable RetroArch will start in 2560 x 480 @ 60.\n\nIf you are running Windows, before enabling the CRT SwitchRes options please make sure you have installed CRTEmudriver and installed some modelines. The minimum modelines for all games to switch correctly are:\n\n- 2560 x 192 @ 60.000000\n- 2560 x 200 @ 60.000000\n- 2560 x 240 @ 60.000000\n- 2560 x 224 @ 60.000000\n- 2560 x 237 @ 60.000000\n- 2560 x 256 @ 50.000000\n- 2560 x 254 @ 55.000000\n- 2560 x 448 @ 60.000000\n- 2560 x 480 @ 60.000000\n\nInstall these modelines replacing 2560 with your desired super resolution. The above resolutions are NTSC only so if you would be playing any PAL content please add PAL modelines:\n\n- 2560 x 192 @ 50.000000\n- 2560 x 200 @ 50.000000\n- 2560 x 240 @ 50.000000\n- 2560 x 224 @ 50.000000\n- 2560 x 288 @ 50.000000\n- 2560 x 237 @ 50.000000\n- 2560 x 254 @ 55.000000\n- 2560 x 448 @ 50.000000\n- 2560 x 480 @ 50.000000\n\nSome games will require higher PAL resolutions which should also be installed:\n\n- 2560 x 512 @ 50.000000\n- 2560 x 576 @ 50.000000\n\nIdeally install all these modelines and everything will work great.\n\n## Super Resolutions\n\nThe default super resolution is 2560. It is displayed just under the CRT switch option, which can be found in video settings. This can be changed within the retroarch.cfg. The only compatible resolutions are 1920, 2560 and 3840. Any other resolutions will be ignored and native switching will be activated.\n\n## Native Resolutions\n\nIf native resolutions are activated you will need a whole new set of modelines:\n\n- 256 x 240 @ 50.006977 SNESpal\n- 256 x 448 @ 50.006977 SNESpal\n- 512 x 224 @ 50.006977 SNESpal\n- 512 x 240 @ 50.006977 SNESpal\n- 512 x 448 @ 50.006977 SNESpal\n- 256 x 240 @ 60.098812 SNESntsc\n- 256 x 448 @ 60.098812 SNESntsc\n- 512 x 240 @ 60.098812 SNESntsc\n- 512 x 224 @ 60.098812 SNESntsc\n- 512 x 448 @ 60.098812 SNESntsc\n- 256 x 192 @ 59.922745 MDntsc\n- 256 x 224 @ 59.922745 MDntsc\n- 320 x 224 @ 59.922745 MDntsc\n- 320 x 240 @ 59.922745 MDntsc\n- 320 x 448 @ 59.922745 MDntsc\n- 320 x 480 @ 59.922745 MDntsc\n- 256 x 192 @ 49.701458 MDpal\n- 256 x 224 @ 49.701458 MDpal\n- 320 x 224 @ 49.701458 MDpal\n- 320 x 240 @ 49.701458 MDpal\n- 320 x 288 @ 49.701458 MDpal\n- 320 x 448 @ 49.701458 MDpal\n- 320 x 480 @ 49.701458 MDpal\n- 320 x 576 @ 49.701458 MDpal\n- 256 x 288 @ 49.701458 MSYSpal\n- 256 x 240 @ 60.098812 NESntsc\n- 256 x 240 @ 50.006977 NESpal\n\n- 640 x 237 @ 60.130001 N64ntsc\n- 640 x 240 @ 60.130001 N64ntsc\n- 640 x 480 @ 60.130001 N64ntsc\n- 640 x 288 @ 50.000000 N64pal\n- 640 x 480 @ 50.000000 N64pal\n- 640 x 576 @ 50.000000 N64pal\n\n- 256 x 252 @ 49.759998 PSXpal\n- 320 x 252 @ 49.759998 PSXpal\n- 384 x 252 @ 49.759998 PSXpal\n- 640 x 252 @ 49.759998 PSXpal\n- 640 x 540 @ 49.759998 PSXpal\n\n- 384 x 240 @ 59.941002 PSXntsc\n- 256 x 480 @ 59.941002 PSXntsc\n\n- 352 x 240 @ 59.820000 Saturn/SGFX_NTSCp\n- 704 x 240 @ 59.820000 SaturnNTSCp\n- 352 x 480 @ 59.820000 SaturnNTSCi\n- 704 x 480 @ 59.820000 SaturnNTSCi\n- 352 x 288 @ 49.701458 SaturnPALp\n- 704 x 288 @ 49.701458 SaturnPALp\n- 352 x 576 @ 49.701458 SaturnPALi\n- 704 x 576 @ 49.701458 SaturnPALi\n\n- 240 x 160 @ 59.730000 GBA\n- 320 x 200 @ 60.000000 Doom\n\n// Arcade\n\n- 400 x 254 @ 54.706841 MK\n- 384 x 224 @ 59.637405 CPS1\n\nThese modelines are more accurate giving exact hz. However, some games may have unwanted results. This is due to mid-scanline resolution changes on the original hardware. For the best results super resolutions are the way to go.\n\n## CRT resolution switching & MAME\n\nSome arcade resolutions can be very different from consumer CRTs. There is resolution detection to ensure MAME games will be displayed in the closest available resolution but drawn at their native resolution within this resolution. Meaning that the MAME game will look just like the original hardware.\n\nMAME ROMs that run in a vertical aspect like DoDonPachi need to be rotated within MAME before resolution switching and aspect correction will work. Do this before enabling CRT SwitchRes so that RetroArch will run in your desktop resolution. Once you have rotated any games that may need it turn CRT SwitchRes on.\n\n## Socials\n\nThe links below belong to our official channels. Links other than this may have been created by fans, independent members or followers. We seriously recommend using our original resources.\n\n- [Website](https://www.retroarch.com/)\n- [Blog](https://libretro.com/)\n- [Facebook](https://www.facebook.com/libretro)\n- [Twitter](https://twitter.com/libretro)\n- [Reddit](https://www.reddit.com/r/RetroArch/)\n- [YouTube](https://www.youtube.com/Libretro)\n- [Google Post](https://posts.google.com/share/55Nhs2jG)\n- [Steam](https://store.steampowered.com/app/1118310/RetroArch/)\n- [YouTube Topic](https://www.youtube.com/channel/UC5q007PYyQPgin0HHbzF0zQ)\n- [Patreon](https://www.patreon.com/libretro)\n- [BOUNTYSOURCE](https://www.bountysource.com/teams/libretro/issues)\n- [Discord](https://discord.com/invite/VZ2b7wghxR)\n- [Teespring](https://teespring.com/stores/retroarch)\n- [Documentation](https://docs.libretro.com/)\n- [Forum](https://forums.libretro.com/)\n"
        },
        {
          "name": "accessibility.h",
          "type": "blob",
          "size": 3.400390625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2016 - Daniel De Matteis\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __RETROARCH_ACCESSIBILITY_H\n#define __RETROARCH_ACCESSIBILITY_H\n\n#include <stdint.h>\n#include <stddef.h>\n#include <sys/types.h>\n#include <stdlib.h>\n\n#include <boolean.h>\n#include <retro_inline.h>\n#include <retro_common_api.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"configuration.h\"\n\ntypedef struct\n{\n   int ai_service_auto;\n   /* Is text-to-speech accessibility turned on? */\n   bool enabled;\n} access_state_t;\n\nbool is_accessibility_enabled(bool accessibility_enable, bool accessibility_enabled);\n\n#ifdef HAVE_TRANSLATE\nbool is_narrator_running(bool accessibility_enable);\n#endif\n\n/*\n   This function does all the stuff needed to translate the game screen,\n   using the URL given in the settings.  Once the image from the frame\n   buffer is sent to the server, the callback will write the translated\n   image to the screen.\n\n   Supported client/services (thus far)\n   -VGTranslate client ( www.gitlab.com/spherebeaker/vg_translate )\n   -Ztranslate client/service ( www.ztranslate.net/docs/service )\n\n   To use a client, download the relevant code/release, configure\n   them, and run them on your local machine, or network.  Set the\n   retroarch configuration to point to your local client (usually\n   listening on localhost:4404 ) and enable translation service.\n\n   If you don't want to run a client, you can also use a service,\n   which is basically like someone running a client for you.  The\n   downside here is that your retroarch device will have to have\n   an internet connection, and you may have to sign up for it.\n\n   To make your own server, it must listen for a POST request, which\n   will consist of a JSON body, with the \"image\" field as a base64\n   encoded string of a 24bit-BMP/PNG that the will be translated.\n   The server must output the translated image in the form of a\n   JSON body, with the \"image\" field also as a base64 encoded\n   24bit-BMP, or as an alpha channel png.\n\n  \"paused\" boolean is passed in to indicate if the current call\n   was made during a paused frame.  Due to how the menu widgets work,\n   if the ai service is called in \"auto\" mode, then this call will\n   be made while the menu widgets unpause the core for a frame to update\n   the on-screen widgets.  To tell the ai service what the pause\n   mode is honestly, we store the runloop_paused variable from before\n   the handle_translation_cb wipes the widgets, and pass that in here.\n*/\nbool run_translation_service(settings_t *settings, bool paused);\n\nbool accessibility_speak_priority(\n      bool accessibility_enable,\n      unsigned accessibility_narrator_speech_speed,\n      const char* speak_text, int priority);\n\naccess_state_t *access_state_get_ptr(void);\n\n#endif\n"
        },
        {
          "name": "audio",
          "type": "tree",
          "content": null
        },
        {
          "name": "autosave.h",
          "type": "blob",
          "size": 1.125,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2016 - Daniel De Matteis\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __RARCH_AUTOSAVE_H\n#define __RARCH_AUTOSAVE_H\n\n#include <stddef.h>\n\n#include <retro_common_api.h>\n\nRETRO_BEGIN_DECLS\n\n/**\n * autosave_lock:\n *\n * Lock autosave.\n **/\nvoid autosave_lock(void);\n\n/**\n * autosave_unlock:\n *\n * Unlocks autosave.\n **/\nvoid autosave_unlock(void);\n\nbool autosave_init(void);\n\nvoid autosave_deinit(void);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "bluetooth",
          "type": "tree",
          "content": null
        },
        {
          "name": "bootstrap",
          "type": "tree",
          "content": null
        },
        {
          "name": "camera",
          "type": "tree",
          "content": null
        },
        {
          "name": "cheat_manager.c",
          "type": "blob",
          "size": 58.841796875,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdlib.h>\n#include <stddef.h>\n#include <string.h>\n#include <errno.h>\n#include <math.h>\n\n#include <file/config_file.h>\n#include <file/file_path.h>\n#include <compat/strl.h>\n#include <compat/posix_string.h>\n#include <string/stdstring.h>\n#include <retro_miscellaneous.h>\n#include <features/features_cpu.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef HAVE_MENU\n#include \"menu/menu_driver.h\"\n#endif\n\n#ifdef HAVE_CHEEVOS\n#include \"cheevos/cheevos.h\"\n#endif\n\n#include \"cheat_manager.h\"\n\n#include \"msg_hash.h\"\n#include \"configuration.h\"\n#include \"retroarch.h\"\n#include \"runloop.h\"\n#include \"dynamic.h\"\n#include \"core.h\"\n#include \"verbosity.h\"\n\n/* TODO/FIXME - public global variables */\ncheat_manager_t cheat_manager_state;\n\nunsigned cheat_manager_get_buf_size(void)\n{\n   cheat_manager_t *cheat_st = &cheat_manager_state;\n   return cheat_st->buf_size;\n}\n\nunsigned cheat_manager_get_size(void)\n{\n   cheat_manager_t *cheat_st = &cheat_manager_state;\n   return cheat_st->size;\n}\n\n#ifdef HAVE_CHEEVOS\nstatic void cheat_manager_pause_cheevos(void)\n{\n   const char *msg = msg_hash_to_str(MSG_CHEEVOS_HARDCORE_MODE_DISABLED_CHEAT);\n   rcheevos_pause_hardcore();\n\n   runloop_msg_queue_push(msg, strlen(msg), 1, 180, true, NULL,\n         MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n   RARCH_LOG(\"%s\\n\", msg);\n}\n#endif\n\nvoid cheat_manager_apply_cheats(void)\n{\n   unsigned i, idx           = 0;\n   settings_t *settings      = config_get_ptr();\n   cheat_manager_t *cheat_st = &cheat_manager_state;\n\n   if (!cheat_st->cheats)\n      return;\n\n   core_reset_cheat();\n\n   for (i = 0; i < cheat_st->size; i++)\n   {\n      if (     cheat_st->cheats[i].state\n            && cheat_st->cheats[i].handler == CHEAT_HANDLER_TYPE_EMU)\n      {\n         retro_ctx_cheat_info_t cheat_info;\n\n         cheat_info.index   = idx++;\n         cheat_info.enabled = true;\n         cheat_info.code    = cheat_st->cheats[i].code;\n\n         if (!string_is_empty(cheat_info.code))\n            core_set_cheat(&cheat_info);\n      }\n   }\n\n   if (cheat_st->size > 0 && settings->bools.notification_show_cheats_applied)\n   {\n      const char *_msg = msg_hash_to_str(MSG_APPLYING_CHEAT);\n      runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n      RARCH_LOG(\"%s\\n\", _msg);\n   }\n\n#ifdef HAVE_CHEEVOS\n   if (idx != 0 && rcheevos_hardcore_active())\n      cheat_manager_pause_cheevos();\n#endif\n}\n\nvoid cheat_manager_set_code(unsigned i, const char *str)\n{\n   cheat_manager_t *cheat_st = &cheat_manager_state;\n   if (!cheat_st->cheats)\n      return;\n\n   if (!string_is_empty(str))\n      strcpy(cheat_st->cheats[i].code, str);\n\n   cheat_st->cheats[i].state = true;\n}\n\n/**\n * cheat_manager_save:\n * @path                      : Path to cheats file (relative path).\n *\n * Saves cheats to file on disk.\n *\n * Returns: true (1) if successful, otherwise false (0).\n **/\nbool cheat_manager_save(\n      const char *path,\n      const char *cheat_database,\n      bool overwrite)\n{\n   bool ret;\n   unsigned i;\n   char cheats_file[PATH_MAX_LENGTH];\n   config_file_t *conf         = NULL;\n   cheat_manager_t *cheat_st   = &cheat_manager_state;\n   unsigned int* data_ptrs[16] = { NULL};\n   char* keys[16] = {\n      (char*)\"cheat%u_handler\",\n      (char*)\"cheat%u_memory_search_size\",\n      (char*)\"cheat%u_cheat_type\",\n      (char*)\"cheat%u_value\",\n      (char*)\"cheat%u_address\",\n      (char*)\"cheat%u_address_bit_position\",\n      (char*)\"cheat%u_rumble_type\",\n      (char*)\"cheat%u_rumble_value\",\n      (char*)\"cheat%u_rumble_port\",\n      (char*)\"cheat%u_rumble_primary_strength\",\n      (char*)\"cheat%u_rumble_primary_duration\",\n      (char*)\"cheat%u_rumble_secondary_strength\",\n      (char*)\"cheat%u_rumble_secondary_duration\",\n      (char*)\"cheat%u_repeat_count\",\n      (char*)\"cheat%u_repeat_add_to_value\",\n      (char*)\"cheat%u_repeat_add_to_address\"\n   };\n\n   if (!cheat_st->cheats || cheat_st->size == 0)\n      return false;\n\n   if (!cheat_database)\n      strlcpy(cheats_file, path, sizeof(cheats_file));\n   else\n   {\n      size_t _len = fill_pathname_join_special(cheats_file, cheat_database,\n             path, sizeof(cheats_file));\n      strlcpy(cheats_file + _len, \".cht\", sizeof(cheats_file) - _len);\n   }\n\n   if (!overwrite)\n      conf = config_file_new_from_path_to_string(cheats_file);\n\n   if (!conf)\n      if (!(conf = config_file_new_alloc()))\n         return false;\n\n   conf->flags |= CONF_FILE_FLG_GUARANTEED_NO_DUPLICATES;\n\n   config_set_int(conf, \"cheats\", cheat_st->size);\n\n   for (i = 0; i < cheat_st->size; i++)\n   {\n      unsigned j;\n      char key[256];\n      char var_key[128];\n      size_t _len = snprintf(var_key, sizeof(var_key), \"cheat%u_\", i);\n\n      strlcpy(var_key + _len, \"desc\", sizeof(var_key) - _len);\n      if (!string_is_empty(cheat_st->cheats[i].desc))\n         config_set_string(conf, var_key, cheat_st->cheats[i].desc);\n      else\n         config_set_string(conf, var_key, cheat_st->cheats[i].code);\n\n      strlcpy(var_key + _len, \"code\", sizeof(var_key) - _len);\n      config_set_string(conf, var_key, cheat_st->cheats[i].code);\n\n      strlcpy(var_key + _len, \"enable\", sizeof(var_key) - _len);\n      config_set_string(conf, var_key,\n               cheat_st->cheats[i].state\n            ? \"true\"\n            : \"false\");\n\n      strlcpy(var_key + _len, \"big_endian\", sizeof(var_key) - _len);\n      config_set_string(conf, var_key,\n               cheat_st->cheats[i].big_endian\n            ? \"true\"\n            : \"false\"\n            );\n\n      data_ptrs[0]  = &cheat_st->cheats[i].handler;\n      data_ptrs[1]  = &cheat_st->cheats[i].memory_search_size;\n      data_ptrs[2]  = &cheat_st->cheats[i].cheat_type;\n      data_ptrs[3]  = &cheat_st->cheats[i].value;\n      data_ptrs[4]  = &cheat_st->cheats[i].address;\n      data_ptrs[5]  = &cheat_st->cheats[i].address_mask;\n      data_ptrs[6]  = &cheat_st->cheats[i].rumble_type;\n      data_ptrs[7]  = &cheat_st->cheats[i].rumble_value;\n      data_ptrs[8]  = &cheat_st->cheats[i].rumble_port;\n      data_ptrs[9]  = &cheat_st->cheats[i].rumble_primary_strength;\n      data_ptrs[10] = &cheat_st->cheats[i].rumble_primary_duration;\n      data_ptrs[11] = &cheat_st->cheats[i].rumble_secondary_strength;\n      data_ptrs[12] = &cheat_st->cheats[i].rumble_secondary_duration;\n      data_ptrs[13] = &cheat_st->cheats[i].repeat_count;\n      data_ptrs[14] = &cheat_st->cheats[i].repeat_add_to_value;\n      data_ptrs[15] = &cheat_st->cheats[i].repeat_add_to_address;\n\n      for (j = 0; j < 16; j++)\n      {\n         key[0] = '\\0';\n         snprintf(key, sizeof(key), keys[j], i);\n         config_set_uint(conf, key, *(data_ptrs[j]));\n      }\n\n   }\n\n   ret = config_file_write(conf, cheats_file, true);\n   config_file_free(conf);\n\n   return ret;\n}\n\nbool cheat_manager_copy_idx_to_working(unsigned idx)\n{\n   cheat_manager_t *cheat_st   = &cheat_manager_state;\n   if (!cheat_st->cheats || (cheat_st->size < idx + 1))\n      return false;\n\n   memcpy(&cheat_st->working_cheat,\n         &cheat_st->cheats[idx], sizeof(struct item_cheat));\n\n   if (cheat_st->cheats[idx].desc)\n      strlcpy(cheat_st->working_desc, cheat_st->cheats[idx].desc, CHEAT_DESC_SCRATCH_SIZE);\n   else\n      cheat_st->working_desc[0] = '\\0';\n\n   if (cheat_st->cheats[idx].code)\n      strlcpy(cheat_st->working_code,\n            cheat_st->cheats[idx].code,\n            CHEAT_CODE_SCRATCH_SIZE);\n   else\n      cheat_st->working_code[0] = '\\0';\n\n   return true;\n}\n\nbool cheat_manager_copy_working_to_idx(unsigned idx)\n{\n   cheat_manager_t *cheat_st   = &cheat_manager_state;\n   if (!cheat_st->cheats || (cheat_st->size < idx + 1))\n      return false;\n\n   memcpy(&cheat_st->cheats[idx], &cheat_st->working_cheat,\n         sizeof(struct item_cheat));\n\n   if (cheat_st->cheats[idx].desc)\n      free(cheat_st->cheats[idx].desc);\n\n   cheat_st->cheats[idx].desc = strdup(cheat_st->working_desc);\n\n   if (cheat_st->cheats[idx].code)\n      free(cheat_st->cheats[idx].code);\n\n   cheat_st->cheats[idx].code = strdup(cheat_st->working_code);\n\n   return true;\n}\n\nstatic void cheat_manager_free(void)\n{\n   unsigned i = 0;\n   cheat_manager_t *cheat_st   = &cheat_manager_state;\n\n   if (cheat_st->cheats)\n   {\n      for (i = 0; i < cheat_st->size; i++)\n      {\n         if (cheat_st->cheats[i].desc)\n            free(cheat_st->cheats[i].desc);\n         if (cheat_st->cheats[i].code)\n            free(cheat_st->cheats[i].code);\n         cheat_st->cheats[i].desc = NULL;\n         cheat_st->cheats[i].code = NULL;\n      }\n\n      free(cheat_st->cheats);\n   }\n\n   if (cheat_st->prev_memory_buf)\n      free(cheat_st->prev_memory_buf);\n\n   if (cheat_st->matches)\n      free(cheat_st->matches);\n\n   if (cheat_st->memory_buf_list)\n      free(cheat_st->memory_buf_list);\n\n   if (cheat_st->memory_size_list)\n      free(cheat_st->memory_size_list);\n\n   cheat_st->cheats                    = NULL;\n   cheat_st->size                      = 0;\n   cheat_st->buf_size                  = 0;\n   cheat_st->prev_memory_buf           = NULL;\n   cheat_st->curr_memory_buf           = NULL;\n   cheat_st->memory_buf_list           = NULL;\n   cheat_st->memory_size_list          = NULL;\n   cheat_st->matches                   = NULL;\n   cheat_st->num_memory_buffers        = 0;\n   cheat_st->total_memory_size         = 0;\n   cheat_st->memory_initialized        = false;\n   cheat_st->memory_search_initialized = false;\n}\n\nstatic void cheat_manager_new(unsigned size)\n{\n   unsigned i;\n   cheat_manager_t *cheat_st   = &cheat_manager_state;\n\n   cheat_manager_free();\n\n   cheat_st->buf_size          = size;\n   cheat_st->size              = size;\n   cheat_st->search_bit_size   = 3;\n   cheat_st->cheats            = (struct item_cheat*)\n         calloc(cheat_st->buf_size, sizeof(struct item_cheat));\n\n   if (!cheat_st->cheats)\n   {\n      cheat_st->buf_size       = 0;\n      cheat_st->size           = 0;\n      cheat_st->cheats         = NULL;\n      return;\n   }\n\n   for (i = 0; i < cheat_st->size; i++)\n   {\n      cheat_st->cheats[i].desc                  = NULL;\n      cheat_st->cheats[i].code                  = NULL;\n      cheat_st->cheats[i].state                 = false;\n      cheat_st->cheats[i].repeat_count          = 1;\n      cheat_st->cheats[i].repeat_add_to_value   = 0;\n      cheat_st->cheats[i].repeat_add_to_address = 1;\n   }\n}\n\nstatic void cheat_manager_load_cb_first_pass(char *key, char *value)\n{\n   cheat_manager_t *cheat_st   = &cheat_manager_state;\n\n   errno                       = 0;\n\n   if (string_is_equal(key, \"cheats\"))\n   {\n      cheat_st->loading_cheat_size = (unsigned)strtoul(value, NULL, 0);\n\n      if (errno != 0)\n         cheat_st->loading_cheat_size = 0;\n   }\n}\n\nstatic void cheat_manager_load_cb_second_pass(char *key, char *value)\n{\n   char cheat_num_str[20];\n   unsigned cheat_num;\n   unsigned cheat_idx;\n   unsigned idx                = 5;\n   size_t key_length           = 0;\n   cheat_manager_t *cheat_st   = &cheat_manager_state;\n\n   errno                       = 0;\n\n   if (strncmp(key, \"cheat\", 5) != 0)\n      return;\n\n   key_length = strlen((const char*)key);\n\n   while (idx < key_length && key[idx] >= '0' && key[idx] <= '9' && idx < 24)\n   {\n      cheat_num_str[idx - 5] = key[idx];\n      idx++;\n   }\n\n   cheat_num_str[idx - 5] = '\\0';\n\n   cheat_num = (unsigned)strtoul(cheat_num_str, NULL, 0);\n\n   if (cheat_num + cheat_st->loading_cheat_offset >= cheat_st->size)\n      return;\n\n   key = key + idx + 1;\n\n   cheat_idx = cheat_num + cheat_st->loading_cheat_offset;\n\n   if (string_is_equal(key, \"address\"))\n      cheat_st->cheats[cheat_idx].address = (unsigned)strtoul(value, NULL, 0);\n   else if (string_is_equal(key, \"address_bit_position\"))\n      cheat_st->cheats[cheat_idx].address_mask = (unsigned)strtoul(value, NULL, 0);\n   else if (string_is_equal(key, \"big_endian\"))\n      cheat_st->cheats[cheat_idx].big_endian = (string_is_equal(value, \"true\") || string_is_equal(value, \"1\"));\n   else if (string_is_equal(key, \"cheat_type\"))\n      cheat_st->cheats[cheat_idx].cheat_type = (unsigned)strtoul(value, NULL, 0);\n   else if (string_is_equal(key, \"code\"))\n      cheat_st->cheats[cheat_idx].code = strdup(value);\n   else if (string_is_equal(key, \"desc\"))\n      cheat_st->cheats[cheat_idx].desc = strdup(value);\n   else if (string_is_equal(key, \"enable\"))\n      cheat_st->cheats[cheat_idx].state = (string_is_equal(value, \"true\") || string_is_equal(value, \"1\"));\n   else if (string_is_equal(key, \"handler\"))\n      cheat_st->cheats[cheat_idx].handler = (unsigned)strtoul(value, NULL, 0);\n   else if (string_is_equal(key, \"memory_search_size\"))\n      cheat_st->cheats[cheat_idx].memory_search_size = (unsigned)strtoul(value, NULL, 0);\n   else if (string_starts_with_size(key, \"repeat_\", STRLEN_CONST(\"repeat_\")))\n   {\n      if (string_is_equal(key, \"repeat_add_to_address\"))\n         cheat_st->cheats[cheat_idx].repeat_add_to_address = (unsigned)strtoul(value, NULL, 0);\n      else if (string_is_equal(key, \"repeat_add_to_value\"))\n         cheat_st->cheats[cheat_idx].repeat_add_to_value = (unsigned)strtoul(value, NULL, 0);\n      else if (string_is_equal(key, \"repeat_count\"))\n         cheat_st->cheats[cheat_idx].repeat_count = (unsigned)strtoul(value, NULL, 0);\n   }\n   else if (string_starts_with_size(key, \"rumble\", STRLEN_CONST(\"rumble\")))\n   {\n      if (string_is_equal(key, \"rumble_port\"))\n         cheat_st->cheats[cheat_idx].rumble_port = (unsigned)strtoul(value, NULL, 0);\n      else if (string_is_equal(key, \"rumble_primary_duration\"))\n         cheat_st->cheats[cheat_idx].rumble_primary_duration = (unsigned)strtoul(value, NULL, 0);\n      else if (string_is_equal(key, \"rumble_primary_strength\"))\n         cheat_st->cheats[cheat_idx].rumble_primary_strength = (unsigned)strtoul(value, NULL, 0);\n      else if (string_is_equal(key, \"rumble_secondary_duration\"))\n         cheat_st->cheats[cheat_idx].rumble_secondary_duration = (unsigned)strtoul(value, NULL, 0);\n      else if (string_is_equal(key, \"rumble_secondary_strength\"))\n         cheat_st->cheats[cheat_idx].rumble_secondary_strength = (unsigned)strtoul(value, NULL, 0);\n      else if (string_is_equal(key, \"rumble_type\"))\n         cheat_st->cheats[cheat_idx].rumble_type = (unsigned)strtoul(value, NULL, 0);\n      else if (string_is_equal(key, \"rumble_value\"))\n         cheat_st->cheats[cheat_idx].rumble_value = (unsigned)strtoul(value, NULL, 0);\n   }\n   else if (string_is_equal(key, \"value\"))\n      cheat_st->cheats[cheat_idx].value = (unsigned)strtoul(value, NULL, 0);\n}\n\nbool cheat_manager_load(const char *path, bool append)\n{\n   config_file_cb_t cb;\n   unsigned          orig_size = 0;\n   unsigned             cheats = 0;\n   unsigned                  i = 0;\n   config_file_t         *conf = NULL;\n   cheat_manager_t   *cheat_st = &cheat_manager_state;\n\n   cb.config_file_new_entry_cb = cheat_manager_load_cb_first_pass;\n\n   cheat_st->loading_cheat_size = 0;\n\n   conf = config_file_new_with_callback(path, &cb);\n\n   if (!conf)\n      return false;\n\n   cheats = cheat_st->loading_cheat_size;\n\n   if (cheats == 0)\n      goto error;\n\n   config_file_free(conf);\n   conf = NULL;\n\n   cheat_manager_alloc_if_empty();\n\n   if (append)\n   {\n      orig_size = cheat_manager_get_size();\n      if (orig_size == 0)\n         cheat_manager_new(cheats);\n      else\n      {\n         cheats = cheats + orig_size;\n         if (cheat_manager_realloc(cheats, CHEAT_HANDLER_TYPE_EMU)) { }\n      }\n   }\n   else\n   {\n      orig_size = 0;\n      cheat_manager_new(cheats);\n   }\n\n   for (i = orig_size; cheat_st->cheats && i < cheats; i++)\n   {\n      cheat_st->cheats[i].idx                = i;\n      cheat_st->cheats[i].desc               = NULL;\n      cheat_st->cheats[i].code               = NULL;\n      cheat_st->cheats[i].state              = false;\n      cheat_st->cheats[i].big_endian         = false;\n      cheat_st->cheats[i].cheat_type         = CHEAT_TYPE_SET_TO_VALUE;\n      cheat_st->cheats[i].memory_search_size = 3;\n   }\n\n   cheat_st->loading_cheat_offset            = orig_size;\n   cb.config_file_new_entry_cb               =\n      cheat_manager_load_cb_second_pass;\n   conf = config_file_new_with_callback(path, &cb);\n\n   if (!conf)\n      return false;\n\n   config_file_free(conf);\n\n   return true;\n\nerror:\n   config_file_free(conf);\n   return false;\n}\n\nbool cheat_manager_realloc(unsigned new_size, unsigned default_handler)\n{\n   unsigned i;\n   unsigned        orig_size = 0;\n   cheat_manager_t *cheat_st = &cheat_manager_state;\n\n   if (!cheat_st->cheats)\n   {\n      cheat_st->cheats = (struct item_cheat*)\n            calloc(new_size, sizeof(struct item_cheat));\n      orig_size        = 0;\n   }\n   else\n   {\n      struct item_cheat *val = NULL;\n      orig_size              = cheat_st->size;\n\n      /* if size is decreasing, free the items that will be lost */\n      for (i = new_size; i < orig_size; i++)\n      {\n         if (cheat_st->cheats[i].code)\n            free(cheat_st->cheats[i].code);\n         if (cheat_st->cheats[i].desc)\n            free(cheat_st->cheats[i].desc);\n         cheat_st->cheats[i].code = NULL;\n         cheat_st->cheats[i].desc = NULL;\n      }\n\n      val = (struct item_cheat*)\n            realloc(cheat_st->cheats,\n            new_size * sizeof(struct item_cheat));\n\n      cheat_st->cheats = val ? val : NULL;\n   }\n\n   if (!cheat_st->cheats)\n   {\n      cheat_st->buf_size = cheat_st->size = 0;\n      cheat_st->cheats   = NULL;\n      return false;\n   }\n\n   cheat_st->buf_size = new_size;\n   cheat_st->size     = new_size;\n\n   for (i = orig_size; i < cheat_st->size; i++)\n   {\n      memset(&cheat_st->cheats[i], 0, sizeof(cheat_st->cheats[i]));\n      cheat_st->cheats[i].state                 = false;\n      cheat_st->cheats[i].handler               = default_handler;\n      cheat_st->cheats[i].cheat_type            = CHEAT_TYPE_SET_TO_VALUE;\n      cheat_st->cheats[i].memory_search_size    = 3;\n      cheat_st->cheats[i].idx                   = i;\n      cheat_st->cheats[i].repeat_count          = 1;\n      cheat_st->cheats[i].repeat_add_to_value   = 0;\n      cheat_st->cheats[i].repeat_add_to_address = 1;\n   }\n\n   return true;\n}\n\nvoid cheat_manager_update(cheat_manager_t *handle, unsigned handle_idx)\n{\n   size_t _len;\n   char msg[256];\n\n   if (!handle || !handle->cheats || handle->size == 0)\n      return;\n\n   /* TODO/FIXME - localize */\n   _len = snprintf(msg, sizeof(msg),\n         \"Cheat: #%u [%s]: %s\",\n         handle_idx,\n         handle->cheats[handle_idx].state\n         ? msg_hash_to_str(MENU_ENUM_LABEL_ON)\n         : msg_hash_to_str(MENU_ENUM_LABEL_OFF),\n         handle->cheats[handle_idx].desc\n         ? (handle->cheats[handle_idx].desc)\n         : (handle->cheats[handle_idx].code)\n         );\n   runloop_msg_queue_push(msg, _len, 1, 180, true, NULL,\n         MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n   RARCH_LOG(\"%s\\n\", msg);\n}\n\nvoid cheat_manager_toggle_index(bool apply_cheats_after_toggle,\n      unsigned i)\n{\n   cheat_manager_t *cheat_st = &cheat_manager_state;\n   if (!cheat_st->cheats || cheat_st->size == 0)\n      return;\n\n   cheat_st->cheats[i].state = !cheat_st->cheats[i].state;\n   cheat_manager_update(cheat_st, i);\n\n   if (apply_cheats_after_toggle)\n      cheat_manager_apply_cheats();\n}\n\nvoid cheat_manager_toggle(void)\n{\n   cheat_manager_t *cheat_st = &cheat_manager_state;\n   if (!cheat_st->cheats || cheat_st->size == 0)\n      return;\n\n   cheat_st->cheats[cheat_st->ptr].state ^= true;\n   cheat_manager_apply_cheats();\n   cheat_manager_update(cheat_st, cheat_st->ptr);\n}\n\nvoid cheat_manager_index_next(void)\n{\n   cheat_manager_t *cheat_st = &cheat_manager_state;\n   if (!cheat_st->cheats || cheat_st->size == 0)\n      return;\n\n   cheat_st->ptr = (cheat_st->ptr + 1) % cheat_st->size;\n   cheat_manager_update(cheat_st, cheat_st->ptr);\n}\n\nvoid cheat_manager_index_prev(void)\n{\n   cheat_manager_t *cheat_st = &cheat_manager_state;\n   if (!cheat_st->cheats || cheat_st->size == 0)\n      return;\n\n   if (cheat_st->ptr == 0)\n      cheat_st->ptr = cheat_st->size - 1;\n   else\n      cheat_st->ptr--;\n\n   cheat_manager_update(cheat_st, cheat_st->ptr);\n}\n\nconst char *cheat_manager_get_code(unsigned i)\n{\n   cheat_manager_t *cheat_st = &cheat_manager_state;\n   if (!cheat_st->cheats)\n      return NULL;\n   return cheat_st->cheats[i].code;\n}\n\nconst char *cheat_manager_get_desc(unsigned i)\n{\n   cheat_manager_t *cheat_st = &cheat_manager_state;\n   if (!cheat_st->cheats)\n      return NULL;\n   return cheat_st->cheats[i].desc;\n}\n\nbool cheat_manager_get_code_state(unsigned i)\n{\n   cheat_manager_t *cheat_st = &cheat_manager_state;\n   if (!cheat_st->cheats)\n      return false;\n   return cheat_st->cheats[i].state;\n}\n\nstatic bool cheat_manager_get_game_specific_filename(\n      char *s, size_t len,\n      const char *path_cheat_database,\n      bool saving)\n{\n   char s1[PATH_MAX_LENGTH];\n   struct retro_system_info sysinfo;\n   runloop_state_t *runloop_st = runloop_state_get_ptr();\n   const char *core_name       = NULL;\n   const char *game_name       = NULL;\n\n   if (!core_get_system_info(&sysinfo))\n      return false;\n\n   core_name = sysinfo.library_name;\n   game_name = path_basename_nocompression(runloop_st->name.cheatfile);\n\n   if (     string_is_empty(path_cheat_database)\n         || string_is_empty(core_name)\n         || string_is_empty(game_name))\n      return false;\n\n   fill_pathname_join_special(s1,\n         path_cheat_database, core_name,\n         sizeof(s1));\n\n   if (saving)\n   {\n      /* Check if directory is valid, if not, create it */\n      if (!path_is_valid(s1))\n         path_mkdir(s1);\n   }\n\n   fill_pathname_join_special(s, s1, game_name, len);\n\n   return true;\n}\n\nvoid cheat_manager_load_game_specific_cheats(const char *path_cheat_database)\n{\n   char cheat_file[PATH_MAX_LENGTH];\n\n   if (cheat_manager_get_game_specific_filename(\n            cheat_file, sizeof(cheat_file),\n            path_cheat_database,\n            false))\n   {\n      if (cheat_manager_load(cheat_file, true))\n         RARCH_LOG(\"[Cheats]: Load game-specific cheatfile: %s\\n\", cheat_file);\n   }\n}\n\nvoid cheat_manager_save_game_specific_cheats(const char *path_cheat_database)\n{\n   char cheat_file[PATH_MAX_LENGTH];\n\n   if (cheat_manager_get_game_specific_filename(\n            cheat_file, sizeof(cheat_file),\n            path_cheat_database,\n            true))\n   {\n      if (cheat_manager_save(cheat_file, NULL, true))\n         RARCH_LOG(\"[Cheats]: Save game-specific cheatfile: %s\\n\", cheat_file);\n   }\n}\n\nvoid cheat_manager_state_free(void)\n{\n   cheat_manager_free();\n}\n\nvoid cheat_manager_alloc_if_empty(void)\n{\n   cheat_manager_t *cheat_st = &cheat_manager_state;\n   if (!cheat_st->cheats)\n      cheat_manager_new(0);\n}\n\nint cheat_manager_initialize_memory(rarch_setting_t *setting, size_t idx, bool wraparound)\n{\n   unsigned i;\n   retro_ctx_memory_info_t meminfo;\n   bool is_search_initialization          = (setting != NULL);\n   rarch_system_info_t *sys_info          = &runloop_state_get_ptr()->system;\n   unsigned offset                        = 0;\n   cheat_manager_t              *cheat_st = &cheat_manager_state;\n#ifdef HAVE_MENU\n   struct menu_state *menu_st             = menu_state_get_ptr();\n#endif\n\n   cheat_st->num_memory_buffers           = 0;\n   cheat_st->total_memory_size            = 0;\n   cheat_st->curr_memory_buf              = NULL;\n\n   if (cheat_st->memory_buf_list)\n   {\n      free(cheat_st->memory_buf_list);\n      cheat_st->memory_buf_list = NULL;\n   }\n\n   if (cheat_st->memory_size_list)\n   {\n      free(cheat_st->memory_size_list);\n      cheat_st->memory_size_list = NULL;\n   }\n\n   if (sys_info && sys_info->mmaps.num_descriptors > 0)\n   {\n      for (i = 0; i < sys_info->mmaps.num_descriptors; i++)\n      {\n         if ((sys_info->mmaps.descriptors[i].core.flags\n                  & RETRO_MEMDESC_SYSTEM_RAM) != 0\n               && sys_info->mmaps.descriptors[i].core.ptr\n               && sys_info->mmaps.descriptors[i].core.len > 0)\n         {\n            cheat_st->num_memory_buffers++;\n\n            if (!cheat_st->memory_buf_list)\n               cheat_st->memory_buf_list = (uint8_t**)calloc(1, sizeof(uint8_t *));\n            else\n               cheat_st->memory_buf_list = (uint8_t**)realloc(\n                     cheat_st->memory_buf_list, sizeof(uint8_t *) * cheat_st->num_memory_buffers);\n\n            if (!cheat_st->memory_size_list)\n               cheat_st->memory_size_list = (unsigned*)calloc(1, sizeof(unsigned));\n            else\n            {\n               unsigned *val = (unsigned*)realloc(\n                     cheat_st->memory_size_list,\n                     sizeof(unsigned) *\n                     cheat_st->num_memory_buffers);\n\n               if (val)\n                  cheat_st->memory_size_list = val;\n            }\n\n            cheat_st->memory_buf_list[cheat_st->num_memory_buffers  - 1] = (uint8_t*)sys_info->mmaps.descriptors[i].core.ptr;\n            cheat_st->memory_size_list[cheat_st->num_memory_buffers - 1] = (unsigned)sys_info->mmaps.descriptors[i].core.len;\n            cheat_st->total_memory_size += sys_info->mmaps.descriptors[i].core.len;\n\n            if (!cheat_st->curr_memory_buf)\n               cheat_st->curr_memory_buf = (uint8_t*)sys_info->mmaps.descriptors[i].core.ptr;\n         }\n      }\n   }\n\n   if (cheat_st->num_memory_buffers == 0)\n   {\n      meminfo.id = RETRO_MEMORY_SYSTEM_RAM;\n      if (!core_get_memory(&meminfo))\n      {\n         const char *_msg = msg_hash_to_str(MSG_CHEAT_INIT_FAIL);\n         runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n               MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n         return 0;\n      }\n\n      if (meminfo.size == 0)\n         return 0;\n\n      cheat_st->memory_buf_list     = (uint8_t**)\n            calloc(1, sizeof(uint8_t *));\n      cheat_st->memory_size_list    = (unsigned*)\n            calloc(1, sizeof(unsigned));\n      cheat_st->num_memory_buffers  = 1;\n      cheat_st->memory_buf_list[0]  = (uint8_t*)meminfo.data;\n      cheat_st->memory_size_list[0] = (unsigned)meminfo.size;\n      cheat_st->total_memory_size   = (unsigned)meminfo.size;\n      cheat_st->curr_memory_buf     = (uint8_t*)meminfo.data;\n\n   }\n\n   cheat_st->num_matches = (cheat_st->total_memory_size * 8) / (1 << cheat_st->search_bit_size);\n\n#if 0\n   /* Ensure we're aligned on 4-byte boundary */\n   if (meminfo.size % 4 > 0)\n      cheat_st->total_memory_size = cheat_st->total_memory_size + (4 - (meminfo.size % 4));\n#endif\n\n   if (is_search_initialization)\n   {\n      const char *msg = NULL;\n      if (cheat_st->prev_memory_buf)\n      {\n         free(cheat_st->prev_memory_buf);\n         cheat_st->prev_memory_buf = NULL;\n      }\n\n      cheat_st->prev_memory_buf = (uint8_t*)calloc(\n            cheat_st->total_memory_size, sizeof(uint8_t));\n\n      if (!cheat_st->prev_memory_buf)\n      {\n         const char *_msg = msg_hash_to_str(MSG_CHEAT_INIT_FAIL);\n         runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n               MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n         return 0;\n      }\n\n      if (cheat_st->matches)\n      {\n         free(cheat_st->matches);\n         cheat_st->matches = NULL;\n      }\n\n      cheat_st->matches = (uint8_t*)calloc(\n            cheat_st->total_memory_size, sizeof(uint8_t));\n\n      if (!cheat_st->matches)\n      {\n         const char *_msg = msg_hash_to_str(MSG_CHEAT_INIT_FAIL);\n         free(cheat_st->prev_memory_buf);\n         cheat_st->prev_memory_buf = NULL;\n         runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n               MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n         return 0;\n      }\n\n      memset(cheat_st->matches, 0xFF, cheat_st->total_memory_size);\n\n      offset = 0;\n\n      for (i = 0; i < cheat_st->num_memory_buffers; i++)\n      {\n         memcpy(cheat_st->prev_memory_buf + offset,\n               cheat_st->memory_buf_list[i],\n               cheat_st->memory_size_list[i]);\n         offset += cheat_st->memory_size_list[i];\n      }\n\n      msg = msg_hash_to_str(MSG_CHEAT_INIT_SUCCESS);\n      runloop_msg_queue_push(msg, strlen(msg), 1, 180, true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n      cheat_st->memory_search_initialized = true;\n   }\n\n   cheat_st->memory_initialized = true;\n\n#ifdef HAVE_MENU\n   if (!wraparound)\n      menu_st->flags                 |=  MENU_ST_FLAG_ENTRIES_NEED_REFRESH\n                                      |  MENU_ST_FLAG_PREVENT_POPULATE;\n#endif\n\n   return 0;\n}\n\nstatic unsigned translate_address(unsigned address, unsigned char **curr)\n{\n   unsigned             offset = 0;\n   unsigned                  i = 0;\n   cheat_manager_t   *cheat_st = &cheat_manager_state;\n\n   for (i = 0; i < cheat_st->num_memory_buffers; i++)\n   {\n      if ((address >= offset) && (address < offset + cheat_st->memory_size_list[i]))\n      {\n         *curr = cheat_st->memory_buf_list[i];\n         break;\n      }\n      else\n         offset += cheat_st->memory_size_list[i];\n   }\n\n   return offset;\n}\n\nstatic void cheat_manager_setup_search_meta(\n      unsigned int bitsize,\n      unsigned int *bytes_per_item,\n      unsigned int *mask,\n      unsigned int *bits)\n{\n   switch (bitsize)\n   {\n      case 0:\n         *bytes_per_item = 1;\n         *bits           = 1;\n         *mask           = 0x01;\n         break;\n      case 1:\n         *bytes_per_item = 1;\n         *bits           = 2;\n         *mask           = 0x03;\n         break;\n      case 2:\n         *bytes_per_item = 1;\n         *bits           = 4;\n         *mask           = 0x0F;\n         break;\n      case 3:\n         *bytes_per_item = 1;\n         *bits           = 8;\n         *mask           = 0xFF;\n         break;\n      case 4:\n         *bytes_per_item = 2;\n         *bits           = 8;\n         *mask           = 0xFFFF;\n         break;\n      case 5:\n         *bytes_per_item = 4;\n         *bits           = 8;\n         *mask           = 0xFFFFFFFF;\n         break;\n   }\n}\n\nstatic int cheat_manager_search(enum cheat_search_type search_type)\n{\n   size_t _len;\n   char msg[100];\n   cheat_manager_t   *cheat_st = &cheat_manager_state;\n   unsigned char *curr         = cheat_st->curr_memory_buf;\n   unsigned char *prev         = cheat_st->prev_memory_buf;\n   unsigned int idx            = 0;\n   unsigned int curr_val       = 0;\n   unsigned int prev_val       = 0;\n   unsigned int mask           = 0;\n   unsigned int bytes_per_item = 1;\n   unsigned int bits           = 8;\n   unsigned int offset         = 0;\n   unsigned int i              = 0;\n#ifdef HAVE_MENU\n   struct menu_state *menu_st  = menu_state_get_ptr();\n#endif\n\n   if (cheat_st->num_memory_buffers == 0 || !prev || !cheat_st->matches)\n   {\n      const char *msg = msg_hash_to_str(MSG_CHEAT_SEARCH_NOT_INITIALIZED);\n      runloop_msg_queue_push(msg, strlen(msg), 1, 180, true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n      return 0;\n   }\n\n   cheat_manager_setup_search_meta(cheat_st->search_bit_size, &bytes_per_item, &mask, &bits);\n\n   /* little endian FF000000 = 256 */\n   for (idx = 0; idx < cheat_st->total_memory_size; idx = idx + bytes_per_item)\n   {\n      unsigned byte_part;\n\n      offset = translate_address(idx, &curr);\n\n      switch (bytes_per_item)\n      {\n         case 2:\n            curr_val = cheat_st->big_endian ?\n               (*(curr + idx - offset) * 256) + *(curr + idx + 1 - offset) :\n               *(curr + idx - offset) + (*(curr + idx + 1 - offset) * 256);\n            prev_val = cheat_st->big_endian ?\n               (*(prev + idx) * 256) + *(prev + idx + 1) :\n               *(prev + idx) + (*(prev + idx + 1) * 256);\n            break;\n         case 4:\n            curr_val = cheat_st->big_endian ?\n               (*(curr + idx - offset) * 256 * 256 * 256) + (*(curr + idx + 1 - offset) * 256 * 256) + (*(curr + idx + 2 - offset) * 256) + *(curr + idx + 3 - offset) :\n               *(curr + idx - offset) + (*(curr + idx + 1 - offset) * 256) + (*(curr + idx + 2 - offset) * 256 * 256) + (*(curr + idx + 3 - offset) * 256 * 256 * 256);\n            prev_val = cheat_st->big_endian ?\n               (*(prev + idx) * 256 * 256 * 256) + (*(prev + idx + 1) * 256 * 256) + (*(prev + idx + 2) * 256) + *(prev + idx + 3) :\n               *(prev + idx) + (*(prev + idx + 1) * 256) + (*(prev + idx + 2) * 256 * 256) + (*(prev + idx + 3) * 256 * 256 * 256);\n            break;\n         case 1:\n         default:\n            curr_val = *(curr - offset + idx);\n            prev_val = *(prev + idx);\n            break;\n      }\n\n      for (byte_part = 0; byte_part < 8 / bits; byte_part++)\n      {\n         unsigned int curr_subval = (curr_val >> (byte_part * bits)) & mask;\n         unsigned int prev_subval = (prev_val >> (byte_part * bits)) & mask;\n         unsigned int prev_match;\n\n         if (bits < 8)\n            prev_match = *(cheat_st->matches + idx) & (mask << (byte_part * bits));\n         else\n            prev_match = *(cheat_st->matches + idx);\n\n         if (prev_match > 0)\n         {\n            bool match = false;\n            switch (search_type)\n            {\n               case CHEAT_SEARCH_TYPE_EXACT:\n                  match = (curr_subval == cheat_st->search_exact_value);\n                  break;\n               case CHEAT_SEARCH_TYPE_LT:\n                  match = (curr_subval < prev_subval);\n                  break;\n               case CHEAT_SEARCH_TYPE_GT:\n                  match = (curr_subval > prev_subval);\n                  break;\n               case CHEAT_SEARCH_TYPE_LTE:\n                  match = (curr_subval <= prev_subval);\n                  break;\n               case CHEAT_SEARCH_TYPE_GTE:\n                  match = (curr_subval >= prev_subval);\n                  break;\n               case CHEAT_SEARCH_TYPE_EQ:\n                  match = (curr_subval == prev_subval);\n                  break;\n               case CHEAT_SEARCH_TYPE_NEQ:\n                  match = (curr_subval != prev_subval);\n                  break;\n               case CHEAT_SEARCH_TYPE_EQPLUS:\n                  match = (curr_subval == prev_subval + cheat_st->search_eqplus_value);\n                  break;\n               case CHEAT_SEARCH_TYPE_EQMINUS:\n                  match = (curr_subval == prev_subval - cheat_st->search_eqminus_value);\n                  break;\n            }\n\n            if (!match)\n            {\n               if (bits < 8)\n                  *(cheat_st->matches + idx) = *(cheat_st->matches + idx) &\n                     ((~(mask << (byte_part * bits))) & 0xFF);\n               else\n                  memset(cheat_st->matches + idx, 0, bytes_per_item);\n               if (cheat_st->num_matches > 0)\n                  cheat_st->num_matches--;\n            }\n         }\n      }\n   }\n\n   offset = 0;\n\n   for (i = 0; i < cheat_st->num_memory_buffers; i++)\n   {\n      memcpy(cheat_st->prev_memory_buf + offset, cheat_st->memory_buf_list[i], cheat_st->memory_size_list[i]);\n      offset += cheat_st->memory_size_list[i];\n   }\n\n   _len = snprintf(msg, sizeof(msg), msg_hash_to_str(MSG_CHEAT_SEARCH_FOUND_MATCHES), cheat_st->num_matches);\n   runloop_msg_queue_push(msg, _len, 1, 180, true, NULL,\n         MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n#ifdef HAVE_MENU\n   menu_st->flags                 |=  MENU_ST_FLAG_ENTRIES_NEED_REFRESH\n                                   |  MENU_ST_FLAG_PREVENT_POPULATE;\n#endif\n   return 0;\n}\n\nint cheat_manager_search_exact(rarch_setting_t *setting, size_t idx, bool wraparound)\n{\n   return cheat_manager_search(CHEAT_SEARCH_TYPE_EXACT);\n}\n\nint cheat_manager_search_lt(rarch_setting_t *setting, size_t idx, bool wraparound)\n{\n   return cheat_manager_search(CHEAT_SEARCH_TYPE_LT);\n}\n\nint cheat_manager_search_gt(rarch_setting_t *setting, size_t idx, bool wraparound)\n{\n   return cheat_manager_search(CHEAT_SEARCH_TYPE_GT);\n}\n\nint cheat_manager_search_lte(rarch_setting_t *setting, size_t idx, bool wraparound)\n{\n   return cheat_manager_search(CHEAT_SEARCH_TYPE_LTE);\n}\n\nint cheat_manager_search_gte(rarch_setting_t *setting, size_t idx, bool wraparound)\n{\n   return cheat_manager_search(CHEAT_SEARCH_TYPE_GTE);\n}\n\nint cheat_manager_search_eq(rarch_setting_t *setting, size_t idx, bool wraparound)\n{\n   return cheat_manager_search(CHEAT_SEARCH_TYPE_EQ);\n}\n\nint cheat_manager_search_neq(rarch_setting_t *setting, size_t idx, bool wraparound)\n{\n   return cheat_manager_search(CHEAT_SEARCH_TYPE_NEQ);\n}\n\nint cheat_manager_search_eqplus(rarch_setting_t *setting, size_t idx, bool wraparound)\n{\n   return cheat_manager_search(CHEAT_SEARCH_TYPE_EQPLUS);\n}\n\nint cheat_manager_search_eqminus(rarch_setting_t *setting, size_t idx, bool wraparound)\n{\n   return cheat_manager_search(CHEAT_SEARCH_TYPE_EQMINUS);\n}\n\nunsigned cheat_manager_get_state_search_size(unsigned search_size)\n{\n   uint32_t n[] = {1,3,15,255,0x0000ffff,0xffffffff};\n   return n[search_size];\n}\n\nbool cheat_manager_add_new_code(unsigned int memory_search_size, unsigned int address, unsigned int address_mask,\n      bool big_endian, unsigned int value)\n{\n   cheat_manager_t   *cheat_st = &cheat_manager_state;\n   int                new_size = cheat_manager_get_size() + 1;\n\n   if (!cheat_manager_realloc(new_size, CHEAT_HANDLER_TYPE_RETRO))\n      return false;\n\n   cheat_st->cheats[cheat_st->size - 1].address = address;\n   cheat_st->cheats[cheat_st->size - 1].address_mask = address_mask;\n   cheat_st->cheats[cheat_st->size - 1].memory_search_size = memory_search_size;\n   cheat_st->cheats[cheat_st->size - 1].value = value;\n   cheat_st->cheats[cheat_st->size - 1].big_endian = big_endian;\n\n   return true;\n}\n\nint cheat_manager_add_matches(const char *path,\n      const char *label, unsigned type, size_t menuidx, size_t entry_idx)\n{\n   size_t _len;\n   char msg[100];\n   unsigned          byte_part = 0;\n   unsigned            int idx = 0;\n   unsigned           int mask = 0;\n   unsigned int bytes_per_item = 1;\n   unsigned           int bits = 8;\n   unsigned       int curr_val = 0;\n   unsigned         int offset = 0;\n   cheat_manager_t   *cheat_st = &cheat_manager_state;\n   unsigned char         *curr = cheat_st->curr_memory_buf;\n#ifdef HAVE_MENU\n   struct menu_state *menu_st  = menu_state_get_ptr();\n#endif\n\n   if (cheat_st->num_matches + cheat_st->size > 100)\n   {\n      const char *_msg = msg_hash_to_str(MSG_CHEAT_SEARCH_ADDED_MATCHES_TOO_MANY);\n      runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n      return 0;\n   }\n   cheat_manager_setup_search_meta(cheat_st->search_bit_size, &bytes_per_item, &mask, &bits);\n\n   for (idx = 0; idx < cheat_st->total_memory_size; idx = idx + bytes_per_item)\n   {\n      offset = translate_address(idx, &curr);\n\n      switch (bytes_per_item)\n      {\n         case 2:\n            curr_val = cheat_st->big_endian ?\n               (*(curr + idx - offset) * 256) + *(curr + idx + 1 - offset) :\n               *(curr + idx - offset) + (*(curr + idx + 1 - offset) * 256);\n            break;\n         case 4:\n            curr_val = cheat_st->big_endian ?\n               (*(curr + idx - offset) * 256 * 256 * 256) + (*(curr + idx + 1 - offset) * 256 * 256) + (*(curr + idx + 2 - offset) * 256) + *(curr + idx + 3 - offset) :\n               *(curr + idx - offset) + (*(curr + idx + 1 - offset) * 256) + (*(curr + idx + 2 - offset) * 256 * 256) + (*(curr + idx + 3 - offset) * 256 * 256 * 256);\n            break;\n         case 1:\n         default:\n            curr_val = *(curr - offset + idx);\n            break;\n      }\n      for (byte_part = 0; byte_part < 8 / bits; byte_part++)\n      {\n         unsigned int prev_match;\n\n         if (bits < 8)\n         {\n            prev_match = *(cheat_st->matches + idx) & (mask << (byte_part * bits));\n            if (prev_match)\n            {\n               if (!cheat_manager_add_new_code(cheat_st->search_bit_size, idx, (mask << (byte_part * bits)),\n                        cheat_st->big_endian, curr_val))\n               {\n                  const char *_msg = msg_hash_to_str(MSG_CHEAT_SEARCH_ADDED_MATCHES_FAIL);\n                  runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                        MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n                  return 0;\n               }\n            }\n         }\n         else\n         {\n            prev_match = *(cheat_st->matches + idx);\n            if (prev_match)\n            {\n               if (!cheat_manager_add_new_code(cheat_st->search_bit_size, idx, 0xFF,\n                        cheat_st->big_endian, curr_val))\n               {\n                  const char *_msg = msg_hash_to_str(MSG_CHEAT_SEARCH_ADDED_MATCHES_FAIL);\n                  runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                        MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n                  return 0;\n               }\n            }\n         }\n\n      }\n   }\n\n   _len = snprintf(msg, sizeof(msg), msg_hash_to_str(MSG_CHEAT_SEARCH_ADDED_MATCHES_SUCCESS), cheat_st->num_matches);\n\n   runloop_msg_queue_push(msg, _len, 1, 180, true, NULL, MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n#ifdef HAVE_MENU\n   menu_st->flags                 |=  MENU_ST_FLAG_ENTRIES_NEED_REFRESH\n                                   |  MENU_ST_FLAG_PREVENT_POPULATE;\n#endif\n   return 0;\n}\n\nvoid cheat_manager_apply_rumble(struct item_cheat *cheat, unsigned int curr_value)\n{\n   bool rumble               = false;\n   retro_time_t current_time = cpu_features_get_time_usec();\n\n   switch (cheat->rumble_type)\n   {\n      case RUMBLE_TYPE_DISABLED:\n         return;\n      case RUMBLE_TYPE_CHANGES:\n         rumble = (curr_value != cheat->rumble_prev_value);\n         break;\n      case RUMBLE_TYPE_DOES_NOT_CHANGE:\n         rumble = (curr_value == cheat->rumble_prev_value);\n         break;\n      case RUMBLE_TYPE_INCREASE:\n         rumble = (curr_value > cheat->rumble_prev_value);\n         break;\n      case RUMBLE_TYPE_DECREASE:\n         rumble = (curr_value < cheat->rumble_prev_value);\n         break;\n      case RUMBLE_TYPE_EQ_VALUE:\n         rumble = (curr_value == cheat->rumble_value);\n         break;\n      case RUMBLE_TYPE_NEQ_VALUE:\n         rumble = (curr_value != cheat->rumble_value);\n         break;\n      case RUMBLE_TYPE_LT_VALUE:\n         rumble = (curr_value < cheat->rumble_value);\n         break;\n      case RUMBLE_TYPE_GT_VALUE:\n         rumble = (curr_value > cheat->rumble_value);\n         break;\n      case RUMBLE_TYPE_INCREASE_BY_VALUE:\n         rumble = (curr_value == cheat->rumble_prev_value + cheat->rumble_value);\n         break;\n      case RUMBLE_TYPE_DECREASE_BY_VALUE:\n         rumble = (curr_value == cheat->rumble_prev_value - cheat->rumble_value);\n         break;\n   }\n\n   cheat->rumble_prev_value = curr_value;\n\n   /* Give the emulator enough time\n    * to initialize, load state, etc */\n   if (cheat->rumble_initialized > 300)\n   {\n      if (rumble)\n      {\n         cheat->rumble_primary_end_time   = current_time + (cheat->rumble_primary_duration * 1000);\n         cheat->rumble_secondary_end_time = current_time + (cheat->rumble_secondary_duration * 1000);\n         input_set_rumble_state(cheat->rumble_port, RETRO_RUMBLE_STRONG, cheat->rumble_primary_strength);\n         input_set_rumble_state(cheat->rumble_port, RETRO_RUMBLE_WEAK, cheat->rumble_secondary_strength);\n      }\n   }\n   else\n   {\n      cheat->rumble_initialized++;\n      return;\n   }\n\n   if (cheat->rumble_primary_end_time <= current_time)\n   {\n      if (cheat->rumble_primary_end_time != 0)\n         input_set_rumble_state(cheat->rumble_port,\n               RETRO_RUMBLE_STRONG, 0);\n      cheat->rumble_primary_end_time = 0;\n   }\n   else\n   {\n      input_set_rumble_state(cheat->rumble_port,\n            RETRO_RUMBLE_STRONG, cheat->rumble_primary_strength);\n   }\n\n   if (cheat->rumble_secondary_end_time <= current_time)\n   {\n      if (cheat->rumble_secondary_end_time != 0)\n         input_set_rumble_state(cheat->rumble_port, RETRO_RUMBLE_WEAK, 0);\n      cheat->rumble_secondary_end_time = 0;\n   }\n   else\n      input_set_rumble_state(cheat->rumble_port, RETRO_RUMBLE_WEAK, cheat->rumble_secondary_strength);\n}\n\nvoid cheat_manager_apply_retro_cheats(void)\n{\n   unsigned i;\n   unsigned int offset;\n   unsigned int mask           = 0;\n   unsigned int bytes_per_item = 1;\n   unsigned int bits           = 8;\n   unsigned int curr_val       = 0;\n   bool run_cheat              = true;\n#ifdef HAVE_CHEEVOS\n   bool cheat_applied          = false;\n#endif\n   cheat_manager_t   *cheat_st = &cheat_manager_state;\n\n   if ((!cheat_st->cheats))\n      return;\n\n   for (i = 0; i < cheat_st->size; i++)\n   {\n      unsigned char *curr       = NULL;\n      bool set_value            = false;\n      unsigned int idx          = 0;\n      unsigned int value_to_set = 0;\n      unsigned int repeat_iter  = 0;\n      unsigned int address_mask = cheat_st->cheats[i].address_mask;\n\n      if (cheat_st->cheats[i].handler != CHEAT_HANDLER_TYPE_RETRO || !cheat_st->cheats[i].state)\n         continue;\n      if (!cheat_st->memory_initialized)\n         cheat_manager_initialize_memory(NULL, 0, false);\n\n      /* If we're still not initialized, something\n       * must have gone wrong - just bail */\n      if (!cheat_st->memory_initialized)\n         return;\n\n      if (!run_cheat)\n      {\n         run_cheat = true;\n         continue;\n      }\n      cheat_manager_setup_search_meta(cheat_st->cheats[i].memory_search_size, &bytes_per_item, &mask, &bits);\n\n      curr   = cheat_st->curr_memory_buf;\n      idx    = cheat_st->cheats[i].address;\n\n      offset = translate_address(idx, &curr);\n\n      switch (bytes_per_item)\n      {\n         case 2:\n            curr_val = cheat_st->big_endian ?\n               (*(curr + idx - offset) * 256) + *(curr + idx + 1 - offset) :\n               *(curr + idx - offset) + (*(curr + idx + 1 - offset) * 256);\n            break;\n         case 4:\n            curr_val = cheat_st->big_endian ?\n               (*(curr + idx - offset) * 256 * 256 * 256) + (*(curr + idx + 1 - offset) * 256 * 256) + (*(curr + idx + 2 - offset) * 256) + *(curr + idx + 3 - offset) :\n               *(curr + idx - offset) + (*(curr + idx + 1 - offset) * 256) + (*(curr + idx + 2 - offset) * 256 * 256) + (*(curr + idx + 3 - offset) * 256 * 256 * 256);\n            break;\n         case 1:\n         default:\n            curr_val = *(curr + idx - offset);\n            break;\n      }\n\n      cheat_manager_apply_rumble(&cheat_st->cheats[i], curr_val);\n\n      switch (cheat_st->cheats[i].cheat_type)\n      {\n         case CHEAT_TYPE_SET_TO_VALUE:\n            set_value = true;\n            value_to_set = cheat_st->cheats[i].value;\n            break;\n         case CHEAT_TYPE_INCREASE_VALUE:\n            set_value = true;\n            value_to_set = curr_val + cheat_st->cheats[i].value;\n            break;\n         case CHEAT_TYPE_DECREASE_VALUE:\n            set_value = true;\n            value_to_set = curr_val - cheat_st->cheats[i].value;\n            break;\n         case CHEAT_TYPE_RUN_NEXT_IF_EQ:\n            if (!(curr_val == cheat_st->cheats[i].value))\n               run_cheat = false;\n            break;\n         case CHEAT_TYPE_RUN_NEXT_IF_NEQ:\n            if (!(curr_val != cheat_st->cheats[i].value))\n               run_cheat = false;\n            break;\n         case CHEAT_TYPE_RUN_NEXT_IF_LT:\n            if (!(cheat_st->cheats[i].value < curr_val))\n               run_cheat = false;\n            break;\n         case CHEAT_TYPE_RUN_NEXT_IF_GT:\n            if (!(cheat_st->cheats[i].value > curr_val))\n               run_cheat = false;\n            break;\n      }\n\n      if (set_value)\n      {\n#ifdef HAVE_CHEEVOS\n         cheat_applied = true;\n#endif\n         for (repeat_iter = 1; repeat_iter <= cheat_st->cheats[i].repeat_count; repeat_iter++)\n         {\n            switch (bytes_per_item)\n            {\n               case 2:\n                  if (cheat_st->cheats[i].big_endian)\n                  {\n                     *(curr + idx - offset) = (value_to_set >> 8) & 0xFF;\n                     *(curr + idx + 1 - offset) = value_to_set & 0xFF;\n                  }\n                  else\n                  {\n                     *(curr + idx - offset) = value_to_set & 0xFF;\n                     *(curr + idx + 1 - offset) = (value_to_set >> 8) & 0xFF;\n                  }\n                  break;\n               case 4:\n                  if (cheat_st->cheats[i].big_endian)\n                  {\n                     *(curr + idx - offset) = (value_to_set >> 24) & 0xFF;\n                     *(curr + idx + 1 - offset) = (value_to_set >> 16) & 0xFF;\n                     *(curr + idx + 2 - offset) = (value_to_set >> 8) & 0xFF;\n                     *(curr + idx + 3 - offset) = value_to_set & 0xFF;\n                  }\n                  else\n                  {\n                     *(curr + idx - offset) = value_to_set & 0xFF;\n                     *(curr + idx + 1 - offset) = (value_to_set >> 8) & 0xFF;\n                     *(curr + idx + 2 - offset) = (value_to_set >> 16) & 0xFF;\n                     *(curr + idx + 3 - offset) = (value_to_set >> 24) & 0xFF;\n                  }\n                  break;\n               case 1:\n                  if (bits < 8)\n                  {\n                     unsigned bitpos;\n                     unsigned char val = *(curr + idx - offset);\n\n                     for (bitpos = 0; bitpos < 8; bitpos++)\n                     {\n                        if ((address_mask >> bitpos) & 0x01)\n                        {\n                           mask = (~(1 << bitpos) & 0xFF);\n                           /* Clear current bit value */\n                           val = val & mask;\n                           /* Inject cheat bit value */\n                           val = val | (((value_to_set >> bitpos) & 0x01) << bitpos);\n                        }\n                     }\n\n                     *(curr + idx - offset) = val;\n                  }\n                  else\n                     *(curr + idx - offset) = value_to_set & 0xFF;\n                  break;\n               default:\n                  *(curr + idx - offset) = value_to_set & 0xFF;\n                  break;\n            }\n\n            value_to_set += cheat_st->cheats[i].repeat_add_to_value;\n\n            if (mask != 0)\n               value_to_set = value_to_set % mask;\n\n            if (bits < 8)\n            {\n               unsigned int bit_iter;\n               for (bit_iter = 0; bit_iter < cheat_st->cheats[i].repeat_add_to_address; bit_iter++)\n               {\n                  address_mask = (address_mask << mask) & 0xFF;\n\n                  if (address_mask == 0)\n                  {\n                     address_mask = mask;\n                     idx++;\n                  }\n               }\n            }\n            else\n               idx += (cheat_st->cheats[i].repeat_add_to_address * bytes_per_item);\n\n            idx = idx % cheat_st->total_memory_size;\n\n            offset = translate_address(idx, &curr);\n         }\n      }\n   }\n\n#ifdef HAVE_CHEEVOS\n   if (cheat_applied && rcheevos_hardcore_active())\n      cheat_manager_pause_cheevos();\n#endif\n}\n\nvoid cheat_manager_match_action(enum cheat_match_action_type match_action, unsigned int target_match_idx, unsigned int *address, unsigned int *address_mask,\n      unsigned int *prev_value, unsigned int *curr_value)\n{\n   unsigned int byte_part;\n   unsigned int idx;\n   unsigned int start_idx;\n   unsigned int           mask = 0;\n   unsigned int bytes_per_item = 1;\n   unsigned int           bits = 8;\n   unsigned int       curr_val = 0;\n   unsigned int       prev_val = 0;\n   unsigned int         offset = 0;\n   cheat_manager_t   *cheat_st = &cheat_manager_state;\n   unsigned char         *curr = cheat_st->curr_memory_buf;\n   unsigned char         *prev = cheat_st->prev_memory_buf;\n   unsigned int curr_match_idx = 0;\n\n   if (target_match_idx > cheat_st->num_matches - 1)\n      return;\n\n   if (cheat_st->num_memory_buffers == 0)\n      return;\n\n   cheat_manager_setup_search_meta(cheat_st->search_bit_size, &bytes_per_item, &mask, &bits);\n\n   if (match_action == CHEAT_MATCH_ACTION_TYPE_BROWSE)\n      start_idx = *address;\n   else\n      start_idx = 0;\n\n   for (idx = start_idx; idx < cheat_st->total_memory_size; idx = idx + bytes_per_item)\n   {\n      offset = translate_address(idx, &curr);\n\n      switch (bytes_per_item)\n      {\n      case 2:\n         curr_val = cheat_st->big_endian ?\n               (*(curr + idx - offset) * 256) + *(curr + idx + 1 - offset) :\n               *(curr + idx - offset) + (*(curr + idx + 1 - offset) * 256);\n         if (prev)\n            prev_val = cheat_st->big_endian ?\n                  (*(prev + idx) * 256) + *(prev + idx + 1) :\n                  *(prev + idx) + (*(prev + idx + 1) * 256);\n         break;\n      case 4:\n         curr_val = cheat_st->big_endian ?\n               (*(curr + idx - offset) * 256 * 256 * 256) + (*(curr + idx + 1 - offset) * 256 * 256) + (*(curr + idx + 2 - offset) * 256) + *(curr + idx + 3 - offset) :\n               *(curr + idx - offset) + (*(curr + idx + 1 - offset) * 256) + (*(curr + idx + 2 - offset) * 256 * 256) + (*(curr + idx + 3 - offset) * 256 * 256 * 256);\n         if (prev)\n            prev_val = cheat_st->big_endian ?\n                  (*(prev + idx) * 256 * 256 * 256) + (*(prev + idx + 1) * 256 * 256) + (*(prev + idx + 2) * 256) + *(prev + idx + 3) :\n                  *(prev + idx) + (*(prev + idx + 1) * 256) + (*(prev + idx + 2) * 256 * 256) + (*(prev + idx + 3) * 256 * 256 * 256);\n         break;\n      case 1:\n      default:\n         curr_val = *(curr + idx - offset);\n         if (prev)\n            prev_val = *(prev + idx);\n         break;\n      }\n\n      if (match_action == CHEAT_MATCH_ACTION_TYPE_BROWSE)\n      {\n         *curr_value = curr_val;\n         *prev_value = prev_val;\n         return;\n      }\n\n      if (!prev)\n         return;\n\n      for (byte_part = 0; byte_part < 8 / bits; byte_part++)\n      {\n         unsigned int prev_match;\n\n         if (bits < 8)\n         {\n            prev_match = *(cheat_st->matches + idx) & (mask << (byte_part * bits));\n            if (prev_match)\n            {\n               if (target_match_idx == curr_match_idx)\n               {\n                  switch (match_action)\n                  {\n                  case CHEAT_MATCH_ACTION_TYPE_BROWSE:\n                     return;\n                  case CHEAT_MATCH_ACTION_TYPE_VIEW:\n                     *address = idx;\n                     *address_mask = (mask << (byte_part * bits));\n                     *curr_value = curr_val;\n                     *prev_value = prev_val;\n                     return;\n                  case CHEAT_MATCH_ACTION_TYPE_COPY:\n                     if (!cheat_manager_add_new_code(cheat_st->search_bit_size, idx, (mask << (byte_part * bits)),\n                           cheat_st->big_endian, curr_val))\n                     {\n                        const char *_msg = msg_hash_to_str(MSG_CHEAT_SEARCH_ADD_MATCH_FAIL);\n                        runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                              MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n                     }\n                     else\n                     {\n                        const char *_msg = msg_hash_to_str(MSG_CHEAT_SEARCH_ADD_MATCH_SUCCESS);\n                        runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                              MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n                     }\n                     return;\n                  case CHEAT_MATCH_ACTION_TYPE_DELETE:\n                     {\n                        const char *_msg;\n                        if (bits < 8)\n                           *(cheat_st->matches + idx) = *(cheat_st->matches + idx) &\n                              ((~(mask << (byte_part * bits))) & 0xFF);\n                        else\n                           memset(cheat_st->matches + idx, 0, bytes_per_item);\n                        if (cheat_st->num_matches > 0)\n                           cheat_st->num_matches--;\n                        _msg = msg_hash_to_str(MSG_CHEAT_SEARCH_DELETE_MATCH_SUCCESS);\n                        runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                              MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n                     }\n                     return;\n                  }\n                  return;\n               }\n               curr_match_idx++;\n            }\n         }\n         else\n         {\n            prev_match = *(cheat_st->matches + idx);\n            if (prev_match)\n            {\n               if (target_match_idx == curr_match_idx)\n               {\n                  switch (match_action)\n                  {\n                  case CHEAT_MATCH_ACTION_TYPE_BROWSE:\n                     return;\n                  case CHEAT_MATCH_ACTION_TYPE_VIEW:\n                     *address = idx;\n                     *address_mask = 0xFF;\n                     *curr_value = curr_val;\n                     *prev_value = prev_val;\n                     return;\n                  case CHEAT_MATCH_ACTION_TYPE_COPY:\n                     if (!cheat_manager_add_new_code(cheat_st->search_bit_size, idx, 0xFF,\n                           cheat_st->big_endian, curr_val))\n                     {\n                        const char *_msg = msg_hash_to_str(MSG_CHEAT_SEARCH_ADD_MATCH_FAIL);\n                        runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                              MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n                     }\n                     else\n                     {\n                        const char *_msg = msg_hash_to_str(MSG_CHEAT_SEARCH_ADD_MATCH_SUCCESS);\n                        runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                              MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n                     }\n                     return;\n                  case CHEAT_MATCH_ACTION_TYPE_DELETE:\n                     {\n                        const char *_msg;\n                        if (bits < 8)\n                           *(cheat_st->matches + idx) = *(cheat_st->matches + idx) &\n                              ((~(mask << (byte_part * bits))) & 0xFF);\n                        else\n                           memset(cheat_st->matches + idx, 0, bytes_per_item);\n                        if (cheat_st->num_matches > 0)\n                           cheat_st->num_matches--;\n                        _msg = msg_hash_to_str(MSG_CHEAT_SEARCH_DELETE_MATCH_SUCCESS);\n                        runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                              MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n                        return;\n                     }\n                  }\n               }\n\n               curr_match_idx++;\n            }\n         }\n      }\n   }\n}\n\nint cheat_manager_copy_match(rarch_setting_t *setting, size_t idx, bool wraparound)\n{\n   cheat_manager_t *cheat_st = &cheat_manager_state;\n   cheat_manager_match_action(CHEAT_MATCH_ACTION_TYPE_COPY,\n         cheat_st->match_idx, NULL, NULL, NULL, NULL);\n   return 0;\n}\n\nint cheat_manager_delete_match(rarch_setting_t *setting, size_t idx, bool wraparound)\n{\n   cheat_manager_t *cheat_st  = &cheat_manager_state;\n#ifdef HAVE_MENU\n   struct menu_state *menu_st = menu_state_get_ptr();\n#endif\n   cheat_manager_match_action(CHEAT_MATCH_ACTION_TYPE_DELETE,\n         cheat_st->match_idx, NULL, NULL, NULL, NULL);\n#ifdef HAVE_MENU\n   menu_st->flags                 |=  MENU_ST_FLAG_ENTRIES_NEED_REFRESH\n                                   |  MENU_ST_FLAG_PREVENT_POPULATE;\n#endif\n   return 0;\n}\n"
        },
        {
          "name": "cheat_manager.h",
          "type": "blob",
          "size": 8.583984375,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __CHEAT_MANAGER_H\n#define __CHEAT_MANAGER_H\n\n#include <boolean.h>\n#include <retro_common_api.h>\n\n#include \"../setting_list.h\"\n\nRETRO_BEGIN_DECLS\n\nenum cheat_handler_type\n{\n   CHEAT_HANDLER_TYPE_EMU = 0,\n   CHEAT_HANDLER_TYPE_RETRO,\n   CHEAT_HANDLER_TYPE_END\n};\n\nenum cheat_type\n{\n   CHEAT_TYPE_DISABLED = 0,\n   CHEAT_TYPE_SET_TO_VALUE,\n   CHEAT_TYPE_INCREASE_VALUE,\n   CHEAT_TYPE_DECREASE_VALUE,\n   CHEAT_TYPE_RUN_NEXT_IF_EQ,\n   CHEAT_TYPE_RUN_NEXT_IF_NEQ,\n   CHEAT_TYPE_RUN_NEXT_IF_LT,\n   CHEAT_TYPE_RUN_NEXT_IF_GT\n};\n\nenum cheat_search_type\n{\n   CHEAT_SEARCH_TYPE_EXACT = 0,\n   CHEAT_SEARCH_TYPE_LT,\n   CHEAT_SEARCH_TYPE_LTE,\n   CHEAT_SEARCH_TYPE_GT,\n   CHEAT_SEARCH_TYPE_GTE,\n   CHEAT_SEARCH_TYPE_EQ,\n   CHEAT_SEARCH_TYPE_NEQ,\n   CHEAT_SEARCH_TYPE_EQPLUS,\n   CHEAT_SEARCH_TYPE_EQMINUS\n};\n\nenum cheat_match_action_type\n{\n   CHEAT_MATCH_ACTION_TYPE_VIEW = 0,\n   CHEAT_MATCH_ACTION_TYPE_DELETE,\n   CHEAT_MATCH_ACTION_TYPE_COPY,\n   CHEAT_MATCH_ACTION_TYPE_BROWSE\n};\n\nenum cheat_rumble_type\n{\n   RUMBLE_TYPE_DISABLED = 0,\n   RUMBLE_TYPE_CHANGES,\n   RUMBLE_TYPE_DOES_NOT_CHANGE,\n   RUMBLE_TYPE_INCREASE,\n   RUMBLE_TYPE_DECREASE,\n   RUMBLE_TYPE_EQ_VALUE,\n   RUMBLE_TYPE_NEQ_VALUE,\n   RUMBLE_TYPE_LT_VALUE,\n   RUMBLE_TYPE_GT_VALUE,\n   RUMBLE_TYPE_INCREASE_BY_VALUE,\n   RUMBLE_TYPE_DECREASE_BY_VALUE,\n   RUMBLE_TYPE_END_LIST\n};\n\n/* Some codes are ridiculously large - over 10000 bytes */\n#define CHEAT_CODE_SCRATCH_SIZE 16*1024\n#define CHEAT_DESC_SCRATCH_SIZE 255\n\nstruct item_cheat\n{\n   /* Clock value for when rumbling should stop */\n   retro_time_t rumble_primary_end_time;\n   retro_time_t rumble_secondary_end_time;\n\n   char *desc;\n   char *code;\n\n   unsigned int idx;\n   unsigned int handler;\n   /* Number of bits = 2^memory_search_size\n    * 0=1, 1=2, 2=4, 3=8, 4=16, 5=32\n    */\n   unsigned int memory_search_size;\n   unsigned int cheat_type;\n   unsigned int value;\n   unsigned int address;\n   /*\n    * address_mask used when memory_search_size <8 bits\n    * if memory_search_size=0, then the number of bits is 1 and this value can be one of the following:\n    * 0 : 00000001\n    * 1 : 00000010\n    * 2 : 00000100\n    * 3 : 00001000\n    * 4 : 00010000\n    * 5 : 00100000\n    * 6 : 01000000\n    * 7 : 10000000\n    * if memory_search_size=1, then the number of bits is 2 and this value can be one of the following:\n    * 0 : 00000011\n    * 1 : 00001100\n    * 2 : 00110000\n    * 3 : 11000000\n    * if memory_search_size=2, then the number of bits is 4 and this value can be one of the following:\n    * 0 : 00001111\n    * 1 : 11110000\n    */\n   unsigned int address_mask;\n   unsigned int rumble_type;\n   unsigned int rumble_value;\n   unsigned int rumble_prev_value;\n   unsigned int rumble_initialized;\n   /* 0-15 for specific port, anything else means \"all ports\" */\n   unsigned int rumble_port;\n   unsigned int rumble_primary_strength; /* 0-65535 */\n   unsigned int rumble_primary_duration; /* in milliseconds */\n   unsigned int rumble_secondary_strength; /* 0-65535 */\n   unsigned int rumble_secondary_duration; /* in milliseconds */\n\n   /*\n    * The repeat_ variables allow for a single cheat code to affect multiple memory addresses.\n    * repeat_count - the number of times the cheat code should be applied\n    * repeat_add_to_value - every iteration of repeat_count will have this amount added to item_cheat.value\n    * repeat_add_to_address - every iteration of repeat_count will have this amount added to item_cheat.address\n    *\n    * Note that repeat_add_to_address represents the number of \"memory_search_size\" blocks to add to\n    * item_cheat.address.  If memory_search_size is 16-bits and repeat_add_to_address is 2, then item_cheat.address\n    * will be increased by 4 bytes 2*(16-bits) for every iteration.\n    *\n    * This is a cheating structure used for codes like unlocking all levels, giving yourself 1 of every item,etc.\n    */\n   unsigned int repeat_count;\n   unsigned int repeat_add_to_value;\n   unsigned int repeat_add_to_address;\n\n   bool state;\n   /* Whether to apply the cheat based on big-endian console memory or not */\n   bool big_endian;\n};\n\nstruct cheat_manager\n{\n   struct item_cheat working_cheat; /* retro_time_t alignment */\n   struct item_cheat *cheats;\n   uint8_t *curr_memory_buf;\n   uint8_t *prev_memory_buf;\n   uint8_t *matches;\n   uint8_t **memory_buf_list;\n   unsigned *memory_size_list;\n   unsigned int delete_state;\n   unsigned int loading_cheat_size;\n   unsigned int loading_cheat_offset;\n   unsigned ptr;\n   unsigned size;\n   unsigned buf_size;\n   unsigned total_memory_size;\n   unsigned num_memory_buffers;\n   unsigned match_idx;\n   unsigned match_action;\n   unsigned search_bit_size;\n   unsigned dummy;\n   unsigned search_exact_value;\n   unsigned search_eqplus_value;\n   unsigned search_eqminus_value;\n   unsigned num_matches;\n   unsigned browse_address;\n   char working_desc[CHEAT_DESC_SCRATCH_SIZE];\n   char working_code[CHEAT_CODE_SCRATCH_SIZE];\n   bool  big_endian;\n   bool  memory_initialized;\n   bool  memory_search_initialized;\n};\n\ntypedef struct cheat_manager cheat_manager_t;\n\nextern cheat_manager_t cheat_manager_state;\n\nunsigned cheat_manager_get_size(void);\n\nbool cheat_manager_load(const char *path, bool append);\n\n/**\n * cheat_manager_save:\n * @path                      : Path to cheats file (absolute path).\n *\n * Saves cheats to file on disk.\n *\n * Returns: true (1) if successful, otherwise false (0).\n **/\nbool cheat_manager_save(const char *path,\n      const char *cheat_database, bool overwrite);\n\nbool cheat_manager_realloc(unsigned new_size, unsigned default_handler);\n\nvoid cheat_manager_set_code(unsigned index, const char *str);\n\nvoid cheat_manager_index_next(void);\n\nvoid cheat_manager_index_prev(void);\n\nvoid cheat_manager_toggle(void);\n\nvoid cheat_manager_apply_cheats(void);\n\nvoid cheat_manager_update(cheat_manager_t *handle, unsigned handle_idx);\n\nvoid cheat_manager_toggle_index(bool apply_cheats_after_toggle,\n      unsigned i);\n\nunsigned cheat_manager_get_buf_size(void);\n\nconst char *cheat_manager_get_desc(unsigned i);\n\nconst char *cheat_manager_get_code(unsigned i);\n\nbool cheat_manager_get_code_state(unsigned i);\n\nvoid cheat_manager_state_free(void);\n\nvoid cheat_manager_alloc_if_empty(void);\n\nbool cheat_manager_copy_idx_to_working(unsigned idx);\n\nbool cheat_manager_copy_working_to_idx(unsigned idx);\n\nvoid cheat_manager_load_game_specific_cheats(const char *path_cheat_database);\n\nvoid cheat_manager_save_game_specific_cheats(const char *path_cheat_database);\n\nint cheat_manager_initialize_memory(rarch_setting_t *setting, size_t idx, bool wraparound);\n\nint cheat_manager_search_exact(rarch_setting_t *setting, size_t idx, bool wraparound);\n\nint cheat_manager_search_lt(rarch_setting_t *setting, size_t idx, bool wraparound);\n\nint cheat_manager_search_gt(rarch_setting_t *setting, size_t idx, bool wraparound);\n\nint cheat_manager_search_lte(rarch_setting_t *setting, size_t idx, bool wraparound);\n\nint cheat_manager_search_gte(rarch_setting_t *setting, size_t idx, bool wraparound);\n\nint cheat_manager_search_eq(rarch_setting_t *setting, size_t idx, bool wraparound);\n\nint cheat_manager_search_neq(rarch_setting_t *setting, size_t idx, bool wraparound);\n\nint cheat_manager_search_eqplus(rarch_setting_t *setting, size_t idx, bool wraparound);\n\nint cheat_manager_search_eqminus(rarch_setting_t *setting, size_t idx, bool wraparound);\n\nunsigned cheat_manager_get_state_search_size(unsigned search_size);\n\nint cheat_manager_add_matches(const char *path,\n      const char *label, unsigned type, size_t idx, size_t entry_idx);\n\nvoid cheat_manager_apply_retro_cheats(void);\n\nvoid cheat_manager_match_action(\n      enum cheat_match_action_type match_action,\n      unsigned int target_match_idx,\n      unsigned int *address, unsigned int *address_mask,\n      unsigned int *prev_value, unsigned int *curr_value);\n\nint cheat_manager_copy_match(rarch_setting_t *setting, size_t idx, bool wraparound);\n\nint cheat_manager_delete_match(rarch_setting_t *setting, size_t idx, bool wraparound);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "cheevos",
          "type": "tree",
          "content": null
        },
        {
          "name": "com.libretro.RetroArch.desktop",
          "type": "blob",
          "size": 0.6142578125,
          "content": "[Desktop Entry]\nVersion=1.0\nName=RetroArch\nGenericName=Frontend for the libretro API\nType=Application\nComment=Frontend for emulators, game engines and media players\nComment[ru]=   ,    \nComment[fr]=Interface graphique pour mulateurs, moteurs de jeu et lecteurs multimdia\nComment[de]=Front-End fr Emulatoren, Spiel-Engines und Mediaplayer\nIcon=com.libretro.RetroArch\nExec=retroarch\nTerminal=false\nStartupNotify=false\nStartupWMClass=retroarch\nKeywords=multi;engine;emulator;xmb;\nCategories=Game;Emulator;\n"
        },
        {
          "name": "com.libretro.RetroArch.metainfo.xml",
          "type": "blob",
          "size": 114.2041015625,
          "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!-- Copyright 2019 Rob Loach <robloach@gmail.com> -->\n<component type=\"desktop-application\">\n  <id>com.libretro.RetroArch</id>\n  <launchable type=\"desktop-id\">com.libretro.RetroArch.desktop</launchable>\n  <name>RetroArch</name>\n  <summary>Frontend for emulators, game engines and media players</summary>\n  <developer_name>libretro</developer_name>\n  <url type=\"homepage\">https://www.retroarch.com</url>\n  <url type=\"bugtracker\">https://github.com/libretro/RetroArch/issues</url>\n  <url type=\"help\">https://docs.libretro.com</url>\n  <url type=\"faq\">https://retroarch.com/?page=faq</url>\n  <url type=\"donation\">https://retroarch.com/index.php?page=donate</url>\n  <content_rating type=\"oars-1.0\" />\n  <screenshots>\n    <screenshot type=\"default\">\n      <caption>RetroArch main menu</caption>\n      <image type=\"source\" width=\"768\" height=\"414\">https://www.libretro.com/wp-content/uploads/2020/03/ozone-768x414.png</image>\n    </screenshot>\n    <screenshot>\n      <caption>RetroArch running the NES</caption>\n      <image type=\"source\" width=\"768\" height=\"672\">https://www.libretro.com/wp-content/uploads/2020/03/micromachines-200313-175514-768x672.png</image>\n    </screenshot>\n    <screenshot>\n      <caption>Rabbit : a fighting game from 1997, one of the only Electronic Arts arcade games</caption>\n      <image type=\"source\" width=\"768\" height=\"575\">https://www.libretro.com/wp-content/uploads/2020/03/rabbit-200313-180233-768x575.png</image>\n    </screenshot>\n    <screenshot>\n      <caption>Wolfenstein 3D (Shareware)</caption>\n      <image type=\"source\" width=\"768\" height=\"480\">https://www.libretro.com/wp-content/uploads/2020/02/gamemaps-200225-094528-768x480.png</image>\n    </screenshot>\n  </screenshots>\n  <description>\n    <p>\n      RetroArch enables you to run classic games on a wide range of computers and consoles through its slick graphical interface. Settings are also unified so configuration is done once and for all.\n    </p>\n    <p>\n      It enables you to run classic games on a wide range of computers and consoles through its slick graphical interface. Settings are also unified so configuration is done once and for all. RetroArch has advanced features like shaders, netplay, rewinding, next-frame response times, runahead, and more!\n    </p>\n  </description>\n  <project_license>GPL-3.0</project_license>\n  <metadata_license>CC0-1.0</metadata_license>\n  <releases>\n    <release version=\"1.9.11\" date=\"2021-10-09\">\n      <url>https://github.com/libretro/RetroArch/releases/tag/v1.9.11</url>\n      <description>\n        <ul>\n          <li>INPUT: Refactor menu toggle combo button logic to allow quit combo button</li>\n          <li>INPUT/UDEV: Add mouse relative check and set appropriately to fix issue</li>\n          <li>LIBRETRO: Add environment callback to enable cores to notify the frontend that a core otion value has changed</li>\n          <li>STEAM/LINUX: Move to new 'soldier' runtime</li>\n          <li>WAYLAND: Remove xdg-shell-v6 protocol</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.9.10\" date=\"2021-09-18\">\n      <url>https://github.com/libretro/RetroArch/releases/tag/v1.9.10</url>\n      <description>\n        <ul>\n          <li>AUDIO/MIXER: Pad sample buffers to prevent potential heap-buffer-overflows when resampling (fixes crash when using 30 kHz menu audio files)</li>\n          <li>AUDIO/LINUX/SNAP: Add JACK support</li>\n          <li>CHEEVOS: Don't write achievement credentials to overrides</li>\n          <li>CHEEVOS: Disable slowmotion when enabling hardcore mode</li>\n          <li>BUGFIX/ANDROID: Fix crash that could happen on Android with Sameboy core - would crash on rumble function</li>\n          <li>GFX/WIDGETS: New regular widget message appearance</li>\n          <li>INPUT/MOUSE: Add distinct mouse zero index label for drivers that do not support multimouse</li>\n          <li>INPUT/RUMBLE: Add generic rumble gain to input settings</li>\n          <li>INPUT/UDEV/X11: Add workaround to fix keyboard input when using X11 + Udev</li>\n          <li>LIBNX/SWITCH: Add Video Filters support</li>\n          <li>LOCALIZATION: Fetch translations from Crowdin</li>\n          <li>OPENDINGUX/BETA: Disable OpenAL</li>\n          <li>PLAYLISTS: Add 'Refresh Playlist' option</li>\n          <li>STEAM: Initial release on Steam</li>\n          <li>UWP/VFS/XBOX: Improvements and bugfixes to UWP VFS driver</li>\n          <li>VIDEO/REFRESH RATE: Automatic PAL/NTSC refresh rate switch where available - as long as the platform display server allows changing refresh rates and the display has the desired refresh rate</li>\n          <li>VIDEO FILTERS: Add 'Picoscale_256x-320x240' video filter</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.9.9\" date=\"2021-09-05\">\n      <url>https://github.com/libretro/RetroArch/releases/tag/v1.9.9</url>\n      <description>\n        <ul>\n          <li>AUDIO/MIXER: Ensure than menu sounds are re-enabled when calling CMD_EVENT_AUDIO_REINIT</li>\n          <li>AUDIO/RESAMPLER/MIXER: Fix menu sounds (audio mixing) when using the 'sinc' resampler with quality lower than 'normal'</li>\n          <li>AUDIO/CONVERSION/ARM NEON: Add intrinsic NEON versions for float_to_s16/s16_to_float - should lead to optimized codepaths for AArch64/ARMv7 architectures without being dependent on ASM codepaths.</li>\n          <li>AUDIO/RESAMPLER/ARM NEON: Add intrinsic NEON version for lanczos sinc function - should lead to optimized codepaths for AArch64/ARMv7 architectures without being dependent on ASM codepaths.</li>\n          <li>CHEEVOS: Upgrade to rcheevos 10.2</li>\n          <li>CHEATS: Add enhanced search functionality to the 'Cheats' menu</li>\n          <li>CHEATS/RUNAHEAD: Fix cheats when using second instance runahead</li>\n          <li>CONFIG: Add option to (force-)write current core options to disk (Quick Menu)</li>\n          <li>CORE INFO CACHE: Remove core path from core info cache. Should make core info caches portable now (for example: you can move RetroArch to a separate dir and they would still work).</li>\n          <li>INPUT/OVERLAY: Fix overlay input when analog to digital mapping is enabled</li>\n          <li>INPUT/UDEV: Look for \"ID_INPUT_KEY\", not \"ID_INPUT_KEYBOARD\"</li>\n          <li>MENU: Allow 'Custom Aspect Ratio (X Position)/(Y Position)/(Width)/(Height)' to be entered manually via keyboard</li>\n          <li>MENU: Allow 'Vertical Refresh Rate' to be entered manually via keyboard</li>\n          <li>MENU/SHADERS: Highlight currently selected value in Shader Parameter drop-down lists</li>\n          <li>STABILITY: Safer way of avoiding the race condition in audio_driver_sample/audio_driver_sample_batch</li>\n          <li>STABILITY: When audio driver write callback function fails, don't turn audio off completely</li>\n          <li>STABILITY: Input robustness for cores that use internal threading, no audio should be processed at this point in time</li>\n          <li>VIDEO: Screen resolution list sanitizing</li>\n          <li>VULKAN: Fix some Vulkan validation layer errors</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.9.8\" date=\"2021-08-25\">\n      <url>https://github.com/libretro/RetroArch/releases/tag/v1.9.8</url>\n      <description>\n        <ul>\n          <li>CHEEVOS: Hide challenge indicators when resetting</li>\n          <li>CHEEVOS: Support for more than 64 memory regions</li>\n          <li>CHEEVOS: Automatically retry 'http error code -1'</li>\n          <li>CONTENT INFORMATION: Show content info label+path rows always</li>\n          <li>CORE OPTIONS: Core option categories implemented</li>\n          <li>CORE OPTIONS: Add option to disable core option categories</li>\n          <li>DATABASE: Fix heap-buffer-overflow when fetching CRC values</li>\n          <li>DATABASE/EXPLORE: Fix CRC32 reading in explore menu</li>\n          <li>DATABASE/LIBRETRODB: Fix writing of numerical values</li>\n          <li>DATABASE/LIBRETRODB: Fix libretro-db loading on big endian platforms</li>\n          <li>INPUT/UDEV: Limit udev device scan to subsystem 'input'</li>\n          <li>INPUT/SDL2/WINDOWS: Fix keyboard event keycodes</li>\n          <li>INPUT/WAYLAND: Fixes a bug where the first player's mouse, pointer, and lightgun are echoed to the other ports. Now, those other ports correctly report zero. In the future support for multiple mouselike devices will need to be added, which is a bigger project</li>\n          <li>INPUT/WAYLAND: The driver now respects keyboard_mapping_blocked</li>\n          <li>INPUT/WAYLAND: When possible, deprecated lightgun defines are replaced with the new ones. The coordinates are still using the old relative callbacks</li>\n          <li>LIBRETRO: Core options category API implemented</li>\n          <li>LIBRETRO: Fix RETRO_ENVIRONMENT_SET_FASTFORWARDING_OVERRIDE callback when runahead is enabled</li>\n          <li>LIBRETRO: Add environment callback for enabling core option menu visibility updates without toggling Quick Menu</li>\n          <li>LOGGING: Starting logging and verbose mode before first config load</li>\n          <li>LINUX: In some Linux Desktop Environments, like Budgie, task bar feature is unable to pin applications. With StartupWMClass= present in .desktop file, it is possible to pin the application</li>\n          <li>LOCALIZATION: Fetch translations from Crowdin</li>\n          <li>MENU: Relocate 'Manage Playlists' to top</li>\n          <li>MENU: Fullscreen resolution width/height settings no longer require 'advanced settings'</li>\n          <li>MENU/REFRESH RATE: Fix double notifications with refresh rate settings</li>\n          <li>MENU/OZONE: Ensure the existence of values used in selection calculation</li>\n          <li>MENU/OZONE/VULKAN: Casting to unsigned caused an integer overflow and after float promotion would lead to 'x' being a garbage value, leading to problems when this value was passed to vkCmdSetViewport. This stops Vulkan validation layers from complaining about it</li>\n          <li>MOUSE: Change default mouse index to port index</li>\n          <li>MOUSE: Friendly names for mice where available</li>\n          <li>VIDEO: Fix refresh rate 59Hz rounding</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.9.7\" date=\"2021-07-25\">\n      <url>https://github.com/libretro/RetroArch/releases/tag/v1.9.7</url>\n      <description>\n        <ul>\n          <li>CORE INFO: Automatically disable core info cache when core info directory is read-only</li>\n          <li>INPUT/UDEV: udev fixes add pointer pressed to pointer device to allow udev users to access this device</li>\n          <li>LINUX/XDG: Prevent xdg-screensaver's \"Protocol error\" messages</li>\n          <li>LOCALIZATION: Fetch translations from Crowdin</li>\n          <li>LOCALIZATION: Add missing languages for the first startup</li>\n          <li>MENU/XMB/WIDGETS: Add workaround for FPU bug that breaks scale factor comparisons on certain platforms (fixes XMB thumbnails on 32bit Linux/Windows)</li>\n          <li>MENU/RGUI: Enable fullscreen thumbnail toggle using RetroPad 'start' button</li>\n          <li>MENU/RGUI: Fix sublabel length when menu clock is disabled</li>\n          <li>NETWORK/HTTP: Fix HTTP progress indication for large files on 32-bit systems</li>\n          <li>NETWORK/NATT: implement natt fix from void()</li>\n          <li>PATHS: Fix garbled path string</li>\n          <li>SHADERS: Max Shader Parameters increased to 1024</li>\n          <li>VIDEO: Add 'Integer Scale Overlay' - Force integer scaling to round up to the next larger integer instead of rounding down</li>\n          <li>VIDEO: New 'Full' aspect ratio added. This aspect ratio is useful when used with a shader which has a border in it. The aspect ratio is set to the full window area, so that the viewport spans the whole viewport. When using a border type shader like the Mega Bezel this allows the graphics to span the whole window regardless of the user's monitor aspect ratio</li>\n          <li>UNIX: Correct backlight max_brightness path</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.9.6\" date=\"2021-07-04\">\n      <url>https://github.com/libretro/RetroArch/releases/tag/v1.9.6</url>\n      <description>\n        <ul>\n          <li>ARCHIVE: Fix archive delimiter detection when file path contains no slashes</li>\n          <li>ANDROID: Do not duplicate port 0 mouse and gun inputs to other ports</li>\n          <li>AUDIO/XAUDIO2: Fail instead of crashing when disconnecting an audio device</li>\n          <li>CHEEVOS: Reset cached progress each time menu is opened</li>\n          <li>GFX: Fix uninitialized variables in gfx_display_draw_cursor</li>\n          <li>HISTORY: Hide 'Add to Favorites' when viewing an entry of the favorites playlist</li>\n          <li>INPUT: 'Analog to Digital Type' usability improvements</li>\n          <li>INPUT: Add support for mapping multiple controllers to a single input device</li>\n          <li>INPUT/REMAPPING: Add support for mapping multiple controllers to a single input device</li>\n          <li>INPUT/LIGHTGUN: Bind lightgun trigger to first mouse button by default</li>\n          <li>INPUT/UDEV: Only add mouse if it has buttons and add vebose device friendly names</li>\n          <li>INPUT/UDEV: Skip mouse with no button errors and keep the rest</li>\n          <li>INPUT/UDEV: Fix Game Focus mode</li>\n          <li>INPUT/UDEV/X11: Change udev driver for dual lightgun support in X11</li>\n          <li>LOCALIZATION: Fetch translations from Crowdin</li>\n          <li>LOCALIZATION: Fix Switchres menu texts</li>\n          <li>MENU/OZONE: Ensure sidebar display status is updated correctly when performing rapid menu navigation</li>\n          <li>MENU/XMB: Dynamic wallpaper fix</li>\n          <li>MENU/XMB: Icon opacity fix</li>\n          <li>MENU/QT/WIMP: Fix default core detection when playlist file name does not match db_name</li>\n          <li>PLAYLISTS: Optimise scanning of large rom sets</li>\n          <li>X11: Fix threaded video segfault</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.9.5\" date=\"2021-06-12\">\n      <url>https://github.com/libretro/RetroArch/releases/tag/v1.9.5</url>\n      <description>\n        <ul>\n          <li>ALSATHREAD: Make alsathread default for all ALSA devices with threads</li>\n          <li>ARCHIVE: Fix loading of archived content with file names containing # characters</li>\n          <li>CHEEVOS: Upgrade to rcheevos 10.1</li>\n          <li>CHEEVOS: Challenge indicators</li>\n          <li>CHEEVOS: Group achievements by category in quick menu</li>\n          <li>CHEEVOS: Relabel Start Active with Encore Mode</li>\n          <li>FONTS: Improve message wrapping with CJK languages</li>\n          <li>FONTS: Fix garbled characters when converting encodings</li>\n          <li>INPUT: Allow the 8 analog stick directions to be used as keys for core keyboard mappings</li>\n          <li>LIBRETRO: Add API extension for setting need_fullpath based on content file extension and to request persistent frontend content data buffers</li>\n          <li>MENU/SEARCH: Add enhanced search functionality to the 'Manage Cores' menu</li>\n          <li>UNIX: Get better battery stats on sysfs nodes</li>\n          <li>VIDEO: Extend Frame Delay range to 19 to accommodate PAL land too</li>\n          <li>X11: fix fullscreen when swapping monitors/resolution</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.9.4\" date=\"2021-05-28\">\n      <url>https://github.com/libretro/RetroArch/releases/tag/v1.9.4</url>\n      <description>\n        <ul>\n          <li>CHEEVOS: update rcheevos to v10.0.0</li>\n          <li>CONTENT LOADING/FILE IO: Prevent unnecessary extraction (to disk) of compressed content files when need_fullpath is false</li>\n          <li>CORE INFO/FILE IO: Enable core info cache by default now for all platforms</li>\n          <li>CORE INFO/REGRESSION FIX: Fix regression caused by core info file caching - Downloads was no longer showing up in Load Content</li>\n          <li>FILE IO/COMPRESSED: Ability to load content inside ZIP files directly into RAM</li>\n          <li>INPUT/OVERLAYS: Add option to select between 'touched' elements and physical controller inputs when showing inputs on overlays</li>\n          <li>INPUT REMAPPING/OVERLAYS: Prevent duplicate inputs when using remaps with input overlays</li>\n          <li>LOCALIZATION: Fetch translations from Crowdin</li>\n          <li>MENU/OZONE: Added simple playlist entry enumeration</li>\n          <li>MENU/XMB: Fix display of 'Maximum Users' menu entry dropdown list</li>\n          <li>RPNG: Fix some memory corruption if processing broken input PNG file</li>\n          <li>SECURITY: Fix CVE-2021-28927</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.9.3\" date=\"2021-05-17\">\n      <url>https://www.libretro.com/index.php/retroarch-1-9-3-released/</url>\n      <description>\n        <ul>\n          <li>COMMAND: Initialize netcmd-&gt;cmd_source_len before recvfrom()</li>\n          <li>CONTENT LOADING/STATICALLY LINKED: Ensure 'Always Reload Core on Run Content' setting is applied when loading content via the file browser</li>\n          <li>CONTENT LOADING/EMSCRIPTEN: Fix content loading via file browser on platforms with 'broken' core handling (i.e. emscripten)</li>\n          <li>CORE INFO: Skip whitespace when writing compressed core info cache files</li>\n          <li>CORE INFO/FILE IO: Core Info cache; significant file I/O performance improvements on systems with slow disk file I/O</li>\n          <li>CORE INFO/FILE IO: Enable core info cache by default on all 'console' platforms</li>\n          <li>FREEBSD: FreeBSD build fix</li>\n          <li>LIBRETRO API: Add API extension for cores to override frontend fast-forward state</li>\n          <li>MENU/RGUI: Fix saving of config files/overrides when 'Lock Menu Aspect Ratio' is enabled</li>\n          <li>SHADERS: Fix 'Auto-Shader Delay' functionality</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.9.2\" date=\"2021-04-30\">\n      <url>https://www.libretro.com/index.php/retroarch-1-9-2-released/</url>\n      <description>\n        <ul>\n          <li>CHEEVOS: Allow rcheevos_patch_address to be called on game without achievements</li>\n          <li>CHEEVOS: Update achievement memory maps (add Supervision)</li>\n          <li>CONFIG/FILE: Use hash map to optimise key/value lookups</li>\n          <li>CORE INFO: Performance optimisations + code clean-ups/refactors</li>\n          <li>CRT/SWITCHRES: Fixed CRTSwitchRes framebuffer bug</li>\n          <li>DISCORD/RP: Fix regression</li>\n          <li>DRM: set the correct video mode</li>\n          <li>FASTFORWARD: Enforce minimum fastforward_ratio of 1.0</li>\n          <li>FONTS/FREETYPE/STB_UNICODE/BITMAPFONT: Prevent texture bleed when rendering text at non-integer scales</li>\n          <li>INPUT: Ensure that 'retro_set_controller_port_device' is called when updating 'Max Users'</li>\n          <li>INPUT/XEGL/MOUSE: Fix xegl_ctx.c mouse activation</li>\n          <li>INPUT/SDL: Fix crash in SDL input driver when analogs are bound.</li>\n          <li>INPUT/POINTER: Add scaling to pointer input.</li>\n          <li>INPUT REMAPPING: Fix regression on loading file</li>\n          <li>INPUT REMAPPING: Fix regression where disabling input remapping would disable input</li>\n          <li>LOGGING: RARCH_LOG_V checking for verbosity level is not necessary and can cause issues; removed said check.</li>\n          <li>LOGGING: Silence inappropriate cheatfile logging</li>\n          <li>MENU: Add optional menu screensaver</li>\n          <li>MENU: Add search filter support to cheats and overlays file browser menus</li>\n          <li>MENU/FILEBROWSER: Enhanced 'Load Content' file browser search functionality</li>\n          <li>MENU/INPUT: Block accidental diagonals in menu navigation </li>\n          <li>MENU/RGUI: Add option to disable menu transparency</li>\n          <li>MENU/RGUI: Fix display of 'Video > Scaling' menu when 'Lock Menu Aspect Ratio' is enabled</li>\n          <li>MENU/MATERIALUI: Add icon to 'Turbo Fire' menu entry</li>\n          <li>MENU/OZONE: Ozone Dracula theme</li>\n          <li>PATCHES: Added multi-softpatching support + OSD messages for patches</li>\n          <li>RHMAP: Track the complete string in rhmap</li>\n          <li>XEGL: Fix mouse not working when using OpenGLES with X11</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.9.1\" date=\"2021-03-30\">\n      <url>https://www.libretro.com/index.php/retroarch-1-9-1-released/</url>\n      <description>\n        <ul>\n          <li>AUDIO: Memalign audio buffers to 64 bytes. This is the most common cache line size, helps with performance. Also fixes issues with platforms like PSP that wrongly assume that malloc returns aligned buffers (to 16bytes). This recently broke the PSP builds</li>\n          <li>AUDIO/ALSA: Fix float format detection</li>\n          <li>AUDIO/JACK: Deinterleave in the process callback. This allows us to avoid the extra copy to the deinterleave buffer and lets us use only a single jack ringbuffer</li>\n          <li>AUDIO/JACK: (Audio/JACK) Fix non-blocking write. Previously we would wait on the condition variable even in the non-blocking case. This improves fast-forward performance massively and brings JACK in line with other backends in that regard</li>\n          <li>AUDIO/XAUDIO2: Fix threaded audio bugs with cores like Dinothawr</li>\n          <li>CONFIG: Add support for saving per-directory core options and deleting core option overrides</li>\n          <li>CONFIG: Enable saving of changed parameters when '#include' directives are used</li>\n          <li>CONFIG/DIRS: Enable configuration of the directories used for Favorites, History, Images, Music and Video playlists</li>\n          <li>CONFIG/REMAPS: Allow loading core remaps without content</li>\n          <li>CONFIG/OVERRIDES: Fix empty override paths when launching without content</li>\n          <li>CHEATS: Maximum search value corrections</li>\n          <li>CHEEVOS: Generic memory mapping using rcheevos</li>\n          <li>CHEEVOS: Ensure badge textures are released before video driver is deinitialized. Should fix crashes with slang shaders.</li>\n          <li>CHEEVOS: Include achievement runtime state in save states</li>\n          <li>CHEEVOS: Prevent hardcore toggle when emu-handled cheats are active</li>\n          <li>CHEEVOS: Add confirmation submenu to achievements hardcore toggle</li>\n          <li>CHEEVOS: Calculate leaderboard widget spacing based on video resolution</li>\n          <li>CHEEVOS: Show unsupported core message when viewing achievement list for unsupported core</li>\n          <li>CHEEVOS: Allow disabling leaderboard notifications and trackers separately</li>\n          <li>CHEEVOS: Add display widget for active leaderboards</li>\n          <li>CHEEVOS/CORE OPTIONS: Core options blacklist. Disables hardcore mode when certain core options are set</li>\n          <li>CLI: Add option for quitting on close content</li>\n          <li>CONTEXT/DRIVER SWITCHING: Allow context switching from gl to glcore</li>\n          <li>CORE OPTIONS: Add option to reset all core options for current core/content</li>\n          <li>CORE OPTIONS: Add per-folder core options</li>\n          <li>CRT/SWITCHRES: Improvements</li>\n          <li>CRT/SWITCHRES: Low resolution switch bug fix  This allows resolutions lower that 32224 like 256224 to work</li>\n          <li>CORE DOWNLOADER: Enhanced core downloader search functionality</li>\n          <li>DRM: Fix race condition in drm_surface_set_aspect</li>\n          <li>DRM/KMS: add support for custom HDMI timings / modes</li>\n          <li>DATABASE: Fix crash that could happen when selecting cursor</li>\n          <li>DATABASE/EXPLORE: Fix  Prevent segfault when accessing 'Explore' menu</li>\n          <li>FILEIO/PERFORMANCE: Only attempt to call dir_check_defaults once per runtime session</li>\n          <li>FILEIO/PERFORMANCE/3DS: Increase file buffer size and savestate chunk size. This seems to help with saving large savestates</li>\n          <li>FONTS: Improve handling of Arabic and Persian text</li>\n          <li>FONTS/FREETYPE: Use fontconfig to select fonts if available</li>\n          <li>INPUT: Add hold mode for turbo fire 'Single Button'</li>\n          <li>INPUT MAPPING: Refresh bind list on device type change</li>\n          <li>INPUT MAPPING/REMAPPING: Minor bugfix  Remap file browsing starts navigation at input_remapping_directory even if the core-subdir (where saved files go) exists Having remaps for many different cores makes finding the active core files cumbersome, especially because remaps are not compatible between different cores (but maybe for cores emulating the same hardware)</li>\n          <li>INPUT: Keyboard device mapper rework</li>\n          <li>INPUT: New input bind order scan/clear fix</li>\n          <li>INPUT: Duplicate key event blocking additions</li>\n          <li>INPUT: Prevent duplicate key events with hotkeys + keyboard device type</li>\n          <li>INPUT: Keyboard LED driver</li>\n          <li>INPUT/AUTOCONFIG: Allow controllers with no/empty names to work.</li>\n          <li>INPUT/GAME FOCUS: Add option to automatically enable 'game focus' mode when running/resuming content</li>\n          <li>INPUT/HOTKEYS: Hotkey for Close Content / Unload Core</li>\n          <li>INPUT/LIBCEC: Map libcec-daemon keys to RETROK</li>\n          <li>INPUT/X11: Enable keyboard input when mouse cursor is not inside the RetroArch window but window still has focus</li>\n          <li>INPUT/X11: Fix mouse input when mouse is grabbed</li>\n          <li>INPUT/UDEV/RUMBLE: Fix rumble.</li>\n          <li>INPUT/WINDOWS/DINPUT: Simultaneous shift sticky fix</li>\n          <li>INPUT/WINDOWS/DINPUT: Prevent Win-key from opening Start Menu</li>\n          <li>INPUT/WINDOWS/DINPUT: Option for disabling Windows hotkeys</li>\n          <li>INPUT/WINDOWS/DINPUT: Mouse grabbing/clipping with Alt-Tab</li>\n          <li>INPUT/WINDOWS/DINPUT: Mouse grab fixes</li>\n          <li>INPUT/WINDOWS/RAWINPUT: Key position fixes</li>\n          <li>INPUT/WINDOWS/RAWINPUT: Mouse grab fixes</li>\n          <li>INPUT/WINDOWS/RAWINPUT: Prevent outside window mouse clicks when grabbed</li>\n          <li>INPUT/WINDOWS/RAWINPUT: Option for disabling Windows hotkeys</li>\n          <li>INPUT MAPPING/REMAPPING: Major bugfix  Remap file having a different device type requires manual intervention after loading for the core to register the type properly</li>\n          <li>JSON: New faster json parser/writer library rjson</li>\n          <li>JSON/RJSON: Replace rapidjson parser/writer in discord-rpc with rjson</li>\n          <li>LIBRETRO: Add API extension for cores to query the number of active inputs provided by the frontend</li>\n          <li>LIBRETRO: Ensure RARCH_CTL_CORE_OPTIONS_LIST_GET returns false if no core options are available</li>\n          <li>LIBRETRO: Add API extension for overriding frontend audio latency</li>\n          <li>LIBRETRO: Add API extension for cores to monitor frontend audio buffer occupancy</li>\n          <li>LINUX: Also show /run/media or /run/media/$USER in drives list</li>\n          <li>LINUX: Adjust brightness according to the limit. Seems like some platforms feature non-standard maximums, but the variable is correclty exported for us to use</li>\n          <li>LOCALIZATION: Add Finnish language</li>\n          <li>LOGS/SHADER: Shader log spam reduction</li>\n          <li>LOGS/CONFIG: Config logging cleanup</li>\n          <li>LOGS/SAVESTATE: Config logging cleanup</li>\n          <li>MENU: Add 'L2 + R2' menu toggle gamepad combo</li>\n          <li>MENU: Menu text improvements; clarifications, consistency, text mistakes,</li>\n          <li>MENU: Tweak menu scroll initial hold delays</li>\n          <li>MENU: Restrict menu acceleration to navigation buttons</li>\n          <li>MENU: Add 'Menu Driver' setting to 'User Interface'</li>\n          <li>MENU: Relocate 'Menu Scroll' settings.</li>\n          <li>MENU: Separate 'Turbo Fire' menu.</li>\n          <li>MENU: Dropdown menu for 'Custom Aspect Ratio' setting.</li>\n          <li>MENU: Reorder Mouse Index next to Device Index</li>\n          <li>MENU: Submenu for Device Index/Mouse Index</li>\n          <li>MENU: Reorganize User Interface menu</li>\n          <li>MENU: Add 'Remove DSP Plugin' menu entry</li>\n          <li>MENU: Hide 'Auto-Shader Delay' menu setting when shaders are unavailable</li>\n          <li>MENU/ANIMATIONS: Fix non-smooth text ticker + reduce line ticker code duplication</li>\n          <li>MENU/ANIMATIONS/OZONE: Add cursor wiggle animation</li>\n          <li>MENU/ANIMATIONS/OZONE: Implement wiggling for main menu when wrap-around is disabled</li>\n          <li>MENU/NOTIFICATIONS: On-Screen Notifications' menu clean-ups</li>\n          <li>MENU/NOTIFICATIONS: Add option to show/hide Refresh Rate notification</li>\n          <li>MENU/FILEBROWSER: Start auto-selecting last used path for more file browser menu entries</li>\n          <li>MENU/INPUT: Input port label adjustments</li>\n          <li>MENU/INPUT/XMB: Proper control port icons</li>\n          <li>MENU/INPUT/OZONE: Proper control port icons</li>\n          <li>MENU/QUICK MENU: Add remap clearing ability under Quick Menu controls</li>\n          <li>MENU/QUICK MENU: Cap 'State Slot' drop-down list to a maximum of 1000 (+Auto) entries</li>\n          <li>MENU: Customizable menu scroll hold delay.</li>\n          <li>MENU/DESKTOP: Fix mouse cursor limited by window range on F5 press</li>\n          <li>MENU/DESKTOP: Add simple shader option</li>\n          <li>MENU/DESKTOP/WINDOWS: Remove broken 'Update RetroArch' functionality for Windows. We want this to not only be system agnostic if we bring it back, but also work outside of the Qt desktop interface</li>\n          <li>MENU/OZONE: New Theme  Twilight Zone</li>\n          <li>MENU/RGUI: Add 3:2, 5:3 and 3:2/5:3 (centered) aspects</li>\n          <li>MENU/RGUI/TEXT RENDERING: Add Russian language text support</li>\n          <li>MENU/RGUI/TEXT RENDERING: Add support for CJK punctuation glyphs</li>\n          <li>MIDI/WINMM: Recover from MIDI messages not handled by the device</li>\n          <li>MIDI/WINMM: Fix winmm midi driver hanging on content closing</li>\n          <li>NETWORK: Add READ/WRITE_CORE_MEMORY network commands</li>\n          <li>NETWORK: Fix backwards condition in socket blocking behavior</li>\n          <li>NETWORK/NETPLAY: Attempt IPv4 when IPv6 fails</li>\n          <li>OGA/VIDEO: support for OGS</li>\n          <li>OGA: This keeps the tradition DRM driver along with the OGA one. The probe function skips the driver if the screen is non rotated to fall back to the regular DRM driver.</li>\n          <li>OGA: Fix messages from not disappearing</li>\n          <li>OGA: Implement RETRO_ENVIRONMENT_GET_CURRENT_SOFTWARE_FRAMEBUFFER. This is a faster rendering codepath for software rendered libretro cores that some libretro cores use right now. Video drivers in RetroArch have to explicitly implement this for this codepath to work at runtime.</li>\n          <li>OPENDINGUX: Add/Optimise rumble interface</li>\n          <li>OPENDINGUX: Fix frozen video when enabling fast forward</li>\n          <li>OPENDINGUX/SDL: OSD font clean-up</li>\n          <li>OPENDINGUX/SDL: Enable selection of image interpolation method when using 'sdl_dingux' gfx driver</li>\n          <li>OPENDINGUX/SDL: Enable integer scaling when using the 'sdl_dingux' gfx driver</li>\n          <li>OVERLAYS: Add option to scale overlays automatically (with aspect ratio correction)</li>\n          <li>OVERLAYS: Hide Overlay When Gamepad is Connected. Overlays will be hidden automatically when a gamepad is connected in port 1, and shown again when the gamepad is disconnected.</li>\n          <li>OVERLAYS: New default overlays for mobile (neo-retropad)</li>\n          <li>OVERLAYS: In addition to overlay scale, the user can now set an Overlay Aspect Adjustment factor. Most overlays are designed for 16:9 displays, which means they become stretched/ugly on modern wide aspect phones and suchlike. By changing the Overlay Aspect Adjustment factor, a user can scale the overlay width/height to achieve a uniform appearance regardless of display resolution.</li>\n          <li>OVERLAYS/FIX: The Overlay X Offset and Overlay Y Offset options have been fixed, and now work correctly</li>\n          <li>OVERLAYS/FIX: All of the above options (and Overlay Scale) are configured and saved independently for landscape and portrait display orientations  so adjusting everything for a nice landscape layout won't break the portrait display</li>\n          <li>OVERLAYS/FIX: When using the Vulkan gfx driver, memory is leaked every time an overlay is freed</li>\n          <li>OVERLAYS/FIX: When threaded video is enabled, loading overlays with no images (i.e. utility-type overlays, where everything is hidden until the screen is touched) can generate segfaults due to improper usage of realloc()</li>\n          <li>OVERLAYS/FIX: When Show Inputs on Overlay is enabled, ASAN reports bit shift errors due to an incorrect range check when handling turbo inputs  essentially, there is no upper limit to the considered input id range, which means overlay hotkeys (menu toggle, etc.) are incorrectly treated as having turbo support, causing bit shifts using wildly inappropriate id indices</li>\n          <li>PLAYLISTS/PORTABLE: Fixed first load initialization</li>\n          <li>REWIND: Prevent 'Rewind Frames' from being set to '1' incorrectly on load content</li>\n          <li>RUNAHEAD: Add Run-Ahead Toggle hotkey with notifications</li>\n          <li>RBUF/ANIMATIONS: Simplify gfx_animation by switching from dynarray to rbuf</li>\n          <li>RBUF/CORE UPDATER: Replace static entries array with dynamic array via RBUF library</li>\n          <li>RBUF/M3U: Replace static entries array with dynamic array via RBUF library</li>\n          <li>SENSORS: Android (crash-)fixes/improvements + add option to disable sensor input</li>\n          <li>SDL2/VIDEO: Get the SDL2 video driver to work in Wayland/KMS</li>\n          <li>SAVESTATES: Adding savestate garbage collector for autoincrement stavestates</li>\n          <li>SAVESTATES/SAVEFILES: Ensure save file and playlist compression is disabled by default</li>\n          <li>SHADERS: Add option to remember last selected shader preset/shader pass directories</li>\n          <li>SHADERS: Use last selected shader preset directory when changing shaders via previous/next hotkeys</li>\n          <li>SHADERS: Remove Parameters line</li>\n          <li>SHADERS: Shaders fix for duplicate parameters loading bug</li>\n          <li>SHADERS: Fix Crash change num shader passes in UI</li>\n          <li>SHADERS/SLANG: Fix slang shaders with rotation</li>\n          <li>STREAMING/FFMPEG: Add Facebook Game Stream option (for embedded ffmpeg core-enabled RetroArch builds)</li>\n          <li>TLS/SSL: Add BearSSL support, as alternative to mbedTLS</li>\n          <li>VIDEO: AddVariable BFI (Black Frame Insertion)</li>\n          <li>VIDEO/DRM GO2: Dynamic resolution support</li>\n          <li>VIDEO FILTERS: Video filter optimisations</li>\n          <li>VIDEO FILTERS: Add several LCD-effect video filters</li>\n          <li>VIDEO FILTERS: Gameboy/Dot_Matrix video filters: Add XRGB8888 support</li>\n          <li>VIDEO FILTERS: Add Normal4x video filter</li>\n          <li>VIDEO FILTERS: Add 'Upscale_256x-320240' video filter</li>\n          <li>VIDEO FILTERS: Add 'Upscale1.5x' video filter</li>\n          <li>WIFI/LAKKA: Add a proper WiFi menu, with Enable/Disable and Disconnect options. This also allows WiFi passwords to be remembered. The underlying tool (connman) allows to store passswords (that's why it auto connects whenever you boot a Lakka device), so we expose this so that the user does not have to re-input the pass when connecting to a saved wifi.</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.9.0\" date=\"2020-08-09\">\n      <url>https://www.libretro.com/index.php/retroarch-1-9-0-released/</url>\n      <description>\n        <ul>\n          <li>AUTOCONFIG: Ensure correct directory is used when saving autoconfig profiles</li>\n          <li>BLUETOOTH: Add a Bluetooth driver (Lakka-only for now)</li>\n          <li>CHEATS: Fix for wrong number of remaining cheat search matches on some machines</li>\n          <li>CHEEVOS: Option to play sound on achievement unlock.</li>\n          <li>CHEEVOS: Upgrade to rcheevos 9.1</li>\n          <li>CHEEVOS: Restore display of unlocked achievements across hardcore modes</li>\n          <li>CHEEVOS: Hash buffered data when available</li>\n          <li>CHEEVOS: Fix Auto Save State freezes RetroArch while Cheevos is enabled</li>\n          <li>CORE OPTIONS: Pressing OK (or clicking/tapping) on a boolean toggle core option no longer opens a drop-down list. The value now toggles directly, just like boolean options everywhere else in the menu</li>\n          <li>CORE OPTIONS: Toggling an option that changes the number of core options being displayed (i.e. things like `Show Advanced Audio/Video Settings) no longer resets the navigation pointer to the start of the list</li>\n          <li>CORE OPTIONS: Before, RetroArch would identify core option values as being boolean if they had labels matching the specific strings enabled or disabled. Most core devs would abide by this, but not always... As a result, we sometimes would end up with misidentified values, with all kinds of Enabled, Off, True, etc. strings littering the menu, in place of proper toggle switches. All boolean-type value labels are now detected, and replaced with standard ON/OFF strings.</li>\n          <li>CLI: A new command line option --load-menu-on-error has been added</li>\n          <li>CRT: On the fly CRT porch adjuments - these changes allow a user to adjust how the porch algorithm generates the 15khz/31khz output. Giving the ability to change over/under scan.</li>\n          <li>CONFIG FILE: Optimise parsing of configuration files</li>\n          <li>DRIVERS: Implemented protection to avoid setting critical drivers to nothing thus preventing the user from locking him/herself out of the program</li>\n          <li>FFMPEG CORE: Prevent seeking past the end of files (hang fix)</li>\n          <li>FILE I/O: VFS and NBIO interfaces will now use 64-bit fseek/ftell where possible, should allow for reading/writing to files bigger than 2GB</li>\n          <li>INPUT MAPPING/REMAPPING: Add input remap drop-down lists</li>\n          <li>LOCALIZATION: Updates for several languages (synchronized from Crowdin)</li>\n          <li>MEMORY/LINUX/ANDROID: Fix reporting of free memory</li>\n          <li>MEMORY/WINDOWS: Fix reporting of free memory</li>\n          <li>MENU: Enlarged INT/UINT selection limit from 999 to 9999</li>\n          <li>MENU: Fix cursor forced to first entry after displaying lists</li>\n          <li>MENU: Make Notification Font option visible when Graphics Widgets are enabled</li>\n          <li>MENU/RGUI: Add optional toggle switch icons</li>\n          <li>MENU/WIDGETS: Add optional widget-based load content launch feedback animation</li>\n          <li>MENU/WIDGETS: Make notification font size option visible when graphics widgets are enabled</li>\n          <li>PLAYLISTS: Change playlists to use dynamic arrays. Instead of a fixed initial 12MB memory allocation (99999 * 128 byte (on 64bit arch)), use a dynamically growing array</li>\n          <li>PLAYLISTS: Playlist base content directory paths - portable playlists</li>\n          <li>PLAYLISTS/SEARCH: Enhanced playlist search functionality</li>\n          <li>PLAYLISTS/DATABASE: Add Explore view</li>\n          <li>PLAYLISTS/DATABASE/EXPLORE: Show system icons in explore view</li>\n          <li>RUNAHEAD: Prevent runahead from being disabled permanently when an error occurs</li>\n          <li>SCANNER: Add more region codes for GameCube/Wii game detection</li>\n          <li>SHADERS/SLANG: Increased Slang max Parameters, Textures &amp; Passes</li>\n          <li>VIDEO FILTERS/BLARGG: Make Blargg_snes filter customizable</li>\n          <li>X11: Add lightgun support</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.8.9\" date=\"2020-06-20\">\n      <url>https://www.libretro.com/index.php/retroarch-1-8-9-released/</url>\n      <description>\n        <ul>\n          <li>AUTO SAVESTATES: Ensure save states are correctly flushed to disk when quitting RetroArch (fixes broken save states when exiting RetroArch - without first closing content - with 'Auto Save State' enabled)</li>\n          <li>BUILTIN CORES: Builtin cores like ffmpeg and imageviewer would previously try  to erroneously load a dynamic core named 'builtin' - this would fail and would just be a wasteful operation - this now skips dylib loading in libretro_get_system_info for builtin cores</li>\n          <li>CHEEVOS: Report API errors when unlocking achievements or submitting leaderboards</li>\n          <li>CHEEVOS: Support less common file extensions</li>\n          <li>CHEEVOS: Disable hardcore mode when playing BSV file</li>\n          <li>CHEEVOS: Correctly report unlocked non-hardcore achievements when hardcore is paused</li>\n          <li>CHEEVOS/M3U: Bugfix - did not handle absolute/relative paths in M3U files correctly before</li>\n          <li>CHEEVOS/M3U: Bugfix - it didn't handle comments/directives</li>\n          <li>CHEEVOS/M3U: Bugfix - it doesn't handle trailing whitespace</li>\n          <li>CHEEVOS/M3U: Bugfix - failed when loading M3U files with certain line endings</li>\n          <li>CORE MANAGEMENT: Add 'core management' menu (Settings -&gt; Core)</li>\n          <li>CORE MANAGEMENT: Add option to backup/restore installed cores</li>\n          <li>CORE MANAGEMENT: Improved core selection logic</li>\n          <li>CORE INFO: Search search optimisations</li>\n          <li>CORE DOWNLOADER: Rename 'Core Updater' to 'Core Downloader'</li>\n          <li>CORE DOWNLOADER: Add 'Show Experimental Cores' setting under Settings &gt; Network &gt; Updater</li>\n          <li>CORE DOWNLOADER: Core licenses are now shown for all entries in the Core Updater menu</li>\n          <li>CORE DOWNLOADER: Pressing RetroPad select on a Core Updater entry will now display any text in the description field of its info file</li>\n          <li>CORE DOWNLOADER: Installed cores are now highlighted via a [#] symbol</li>\n          <li>CORE DOWNLOADER: Pressing RetroPad start on a selected, installed entry opens the Core Information menu (when using Material UI, swiping left or right triggers the same action). This means we can now view bios info etc. - and more importantly delete cores - without jumping through all the hoops of loading a core first and navigating all over the place</li>\n          <li>CORE DOWNLOADER/UPDATER: Add option to automatically backup cores when updating</li>\n          <li>DISK CONTROL: Enable 'Load New Disc' while disk tray is open</li>\n          <li>INPUT: Added a hotkey delay option to allow hotkey input to work properly when it is assigned to another action</li>\n          <li>INPUT: Remove 'All Users Control Menu' setting, was buggy and will be properly reintroduced after input overhaul</li>\n          <li>LINUX: Set default saves/save states/system paths</li>\n          <li>LOCALIZATION: Add Persian language</li>\n          <li>LOCALIZATION: Add Hebrew language</li>\n          <li>LOCALIZATION: Add Asturian language</li>\n          <li>MENU: Proper line wrapping for message dialog boxes</li>\n          <li>MENU/HOTKEYS: Add sublabels to all hotkey bind entries</li>\n          <li>MENU/QUICK MENU: Suppress the display of 'empty' quick menu listings when closing content</li>\n          <li>MENU/OZONE: Performance improvements</li>\n          <li>MENU/SDL: Add mouse controls</li>\n          <li>OPENGL1/VITA: Initial changes for HW context without FBO</li>\n          <li>OVERLAYS: Add options for moving the on-screen overlay</li>\n          <li>PLAYLISTS/WINDOWS: Fix core path entries in image/video/music history playlists</li>\n          <li>SDL/GL: Advertise GLSL support</li>\n          <li>VIDEO/WIDGETS: Fix heap-use-after-free errors, leading to memory corruption</li>\n          <li>VULKAN/WSI: Better frame pacing</li>\n          <li>VULKAN/WSI: Fix Intel Mesa being broken when using Fences, we have to use Semaphores to acquire the swapchain or the entire GPU stalls</li>\n          <li>VULKAN/WSI: Add support for either using fences or semaphores when syncing</li>\n          <li>VULKAN/WSI: Prefer using semaphores for integrated GPUs as it promotes better throughput over fences</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.8.7\" date=\"2020-05-18\">\n      <url>https://www.libretro.com/index.php/retroarch-1-8-7-released/</url>\n      <description>\n        <ul>\n          <li>CHEEVOS/BUGFIX: Opening achievements list would crash RetroArch with badges enabled (on new games)</li>\n          <li>CHEEVOS: Option to start a session with all achievements active</li>\n          <li>CHEEVOS: Don't perform unnecessary cheevos initialisation when cheevos are disabled. Should reduce startup times when loading content</li>\n          <li>CORE OPTIONS: Disable 'Use Global Core Options File' by default</li>\n          <li>GLCORE: Switch to glcore video driver when requested by a core</li>\n          <li>LINUX/XDG: Use GenericName correctly in desktop entry</li>\n          <li>MENU/MATERIALUI: Add desktop-style playlist view mode</li>\n          <li>MENU/MATERIALUI/DESKTOPVIEW: When scrolling playlists, show last selected thumbnails while waiting for next entry to load</li>\n          <li>MENU/MATERIALUI: Limit tab switch rate when input repeat is active</li>\n          <li>MENU/OZONE: Fix sidebar playlist sort order when 'Truncate Playlist Names' is enabled</li>\n          <li>MENU/RGUI: Adjusted menu defaults, adjusted default scrolling speed</li>\n          <li>MENU/RGUI: Enable custom wallpaper when menu size is reduced at low resolutions</li>\n          <li>MENU/XMB: Limit tab switch rate when input repeat is active</li>\n          <li>NETPLAY: Fix regressions introduced in 1.8.5</li>\n          <li>RGUI: Add option to always stretch menu to fill the screen</li>\n          <li>WIIU: Enable graphics widgets</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.8.6\" date=\"2020-05-06\">\n      <url>https://www.libretro.com/index.php/retroarch-1-8-6-released/</url>\n      <description>\n        <ul>\n          <li>ARCHIVE/ZIP: Expand functionality of rzip_stream interface</li>\n          <li>AI SERVICE: Hide redundant entries when service is disabled</li>\n          <li>AI SERVICE: Added in auto-translate support</li>\n          <li>AI SERVICE: support for NVDA and SAPI narration</li>\n          <li>AUTOCONFIG: Use correct port index in input device configured/disconnected notifications</li>\n          <li>BUGFIX: Fix race condition where task could momentarily not be in the queue when reordering</li>\n          <li>CHEEVOS/BUGFIX: Prevent null reference rendering achievement list while closing application</li>\n          <li>CHEEVOS/BUGFIX: Report non-memorymap GBA cores as unsupported</li>\n          <li>COMMANDLINE: Advise against using -s and -S variables on the command line</li>\n          <li>CONFIG FILE: Only write config files to disk when parameters change</li>\n          <li>CONFIG FILE/BUGFIX: RetroArch no longer crashes when attempting to save a config file after unsetting a parameter (currently, this can be triggered quite easily by manipulating input remaps)</li>\n          <li>CONFIG FILE/BUGFIX: When using Material UI, RetroArch no longer modifies the wrong setting (or segfaults...) when tapping entries in the Quick Menu &gt; Controls input remapping submenu</li>\n          <li>CONFIG FILE/BUGFIX: Quite a few real and potential memory leaks have been fixed.</li>\n          <li>CHD: Fixes a crash caused by ignoring the return value from one of the CHD library functions</li>\n          <li>FASTFORWARDING: A new Mute When Fast-Forwarding option has been added under Settings &gt; Audio</li>\n          <li>GLCORE/SLANG: Set filter and wrap mode correctly when intialising shader textures</li>\n          <li>LOCALIZATION: Update Japanese translation</li>\n          <li>LOCALIZATION: Update Spanish translation</li>\n          <li>LOCALIZATION: Update Portuguese Brazilian translation</li>\n          <li>MENU: Prevent font-related segfaults when using extremely small scales/window sizes</li>\n          <li>MENU: Fix gfx_display_draw_texture_slice()</li>\n          <li>MENU/FONT: Enable correct vertical alignment of text (+ font rendering fixes)</li>\n          <li>MENU/RGUI: Enable automatic menu size reduction when running at low resolutions (down to 256x192)</li>\n          <li>MENU/OZONE: Update timedate style options for Last Played sublabel metadata</li>\n          <li>MENU/OZONE: Hide Menu Color Theme setting when Use preferred system color theme is enabled</li>\n          <li>MENU/OZONE: Fix thumbnail switching via scan button functionality</li>\n          <li>MENU/OZONE: Prevent glitches when rendering Ozones selection cursor</li>\n          <li>MENU/OZONE: Enable proper vertical text alignment + thumbnail display improvements</li>\n          <li>MENU/OZONE: Enable second thumbnail/content metadata toggle using RetroPad select</li>\n          <li>MENU/OZONE: Refactor footer display</li>\n          <li>MENU/OZONE: Hide thumbnail button hints when viewing file browser lists</li>\n          <li>MENU/OZONE/INPUT/BUGFIX: Fix undefined behaviour when using touch screen to change input remaps</li>\n          <li>MENU/OZONE/INPUT/BUGFIX: Pointer input is now correctly disabled when message boxes are displayed</li>\n          <li>MENU/XMB: Fix thumbnail switching via scan button functionality</li>\n          <li>ODROID GO ADVANCE: Add DRM HW context driver</li>\n          <li>PSL1GHT: Initial port</li>\n          <li>PSL1GHT/KEYBOARD: Implement PSL1GHT keyboard</li>\n          <li>PLAYLIST/BUGFIX: Improve handling of broken playlists</li>\n          <li>PLAYLIST/BUGFIX: RetroArch will no longer segfault when attempting to fetch content runtime information when core path is NULL</li>\n          <li>PLAYLIST/BUGFIX: Core name + runtime info will only be displayed on playlists and in the Information submenu if both the core path and core name fields are valid</li>\n          <li>PLAYLIST/BUGFIX: When handling entries with missing path fields, the menu sorting order now matches that of the playlist sorting order</li>\n          <li>PLAYLIST: Add optional per-playlist alphabetical sorting</li>\n          <li>PLAYLIST: Omit whitespace when writing compressed JSON format playlists</li>\n          <li>PLAYLIST: Add optional playlist compression</li>\n          <li>QNX: Support analog sticks</li>\n          <li>SAVESTATES: Add optional save state compression (enabled by default now)</li>\n          <li>SRAM: Add optional save (SRAM) file compression</li>\n          <li>SCANNER: Prevent redundant playlist entries when handling M3U content</li>\n          <li>SCANNER/ANDROID: Fix content scanner being unable to identify certain games from CHD images (raw data sector/subcode)</li>\n          <li>TASKS/BUGFIX: Fix task deadlocks</li>\n          <li>TASKS/SCREENSHOT/BUGFIX: Fix heap-use-after-free error when widgets are disabled</li>\n          <li>TVOS: Disable overlays for tvOS, fix app icon</li>\n          <li>VIDEO/WIDGETS/BUGFIX: The font ascender/descender metrics added in #10375 are now used to achieve pixel perfect vertical text alignment</li>\n          <li>VIDEO/WIDGETS/BUGFIX: Message queue text now uses its own dedicated font</li>\n          <li>VIDEO/WIDGETS/BUGFIX: Performance updates</li>\n          <li>VULKAN/BUGFIX: Fix display of statistics text</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.8.5\" date=\"2020-03-21\">\n      <url>https://www.libretro.com/index.php/retroarch-1-8-5-released/</url>\n      <description>\n        <ul>\n          <li>BUGFIX: Prevent double input when using return key (hardware) to close on-screen keyboard</li>\n          <li>BUGFIX: Fix mouse capture hotkey not working</li>\n          <li>BUGFIX: Avoid overflow when calculating multiplying performance counter</li>\n          <li>BUGFIX: Retroarch overlay displaying &quot;Game remap file loaded.&quot; on the overlay instead of &quot;Core remap file loaded.&quot; when only a core remap file is present</li>\n          <li>CHEEVOS/BUGFIX: Achievement triggers could cause Retroarch to Crash</li>\n          <li>CHEEVOS: Dont block Sameboy core because it only exposes some memory</li>\n          <li>CHEEVOS: Support for extended Sega CD memory</li>\n          <li>CHEEVOS: Show RetroAchievements Hash in content information list</li>\n          <li>CHEEVOS: If the core says its exposing SYSTEM_RAM, give it the benefit of the doubt</li>\n          <li>CHEEVOS: RetroAchievements rich presence for RA.org website/Discord</li>\n          <li>CHEEVOS: Reset token when username or password changes</li>\n          <li>CHEEVOS: Display measured progress on locked achievements</li>\n          <li>CHEEVOS: Queue multiple popups</li>\n          <li>CHEEVOS: Add delay retries to leaderboard submits</li>\n          <li>CHEEVOS: Prevent buffer overflow when encountering an unknown macro</li>\n          <li>CORE UPDATER: Prevent hang when fetching core list if HTTP transfer fails</li>\n          <li>DISK CONTROL: Add disk labels to disk inserted notifications</li>\n          <li>FFMPEG CORE: Fix crash on seeking when using HW decoding in some cases</li>\n          <li>LIBRETRO: Add disk control interface API extension</li>\n          <li>LINUX: Avoid possible crash when running retroarch at startup</li>\n          <li>LINUX/GLX: Fix threaded video crashes/instability because of GLX OML sync callbacks</li>\n          <li>LOCALIZATION: Update French translation</li>\n          <li>LOCALIZATION: Update Korean translation</li>\n          <li>LOCALIZATION: Update Polish translation</li>\n          <li>LOCALIZATION: Update Spanish translation</li>\n          <li>LOCALIZATION: Update Portuguese Brazilian translation</li>\n          <li>MENU: Add Menu Scroll Acceleration option</li>\n          <li>MENU: Automatically select currently checked item when opening drop-down lists</li>\n          <li>MENU: Fix smooth (vertical) line ticker scroll speed</li>\n          <li>MENU: Dont flush on override/remap messages</li>\n          <li>MENU/DATETIME: Adds some new timedate styles that follow DD/MM/YYYY</li>\n          <li>MENU/DATETIME: Modifies the existing translation files in order to accommodate the new options that are now available</li>\n          <li>MENU/DATETIME: Reorders the timedate view options</li>\n          <li>MENU/BUGFIX: Fix bug when switching to RGUI menu driver</li>\n          <li>MENU/MATERIALUI: Add option to remove navigation bar</li>\n          <li>MENU/OZONE: Add DPI-based scaling</li>\n          <li>MENU/OZONE: Add rudimentary pointer support</li>\n          <li>MENU/OZONE: Add Nord and Gruvbox Dark themes</li>\n          <li>MENU/OZONE/POINTER: Pointer can be used to switch between sidebar and entries list</li>\n          <li>MENU/OZONE/POINTER: Pointer can be used to select sidebar and entries list items</li>\n          <li>MENU/OZONE/POINTER: Both sidebar and entries list can be scrolled by dragging</li>\n          <li>MENU/OZONE/POINTER: Clicking/pressing the header or footer produces a cancel action</li>\n          <li>MENU/OZONE/POINTER: Cursor focus follows mouse pointer from sidebar to entries list (and vice versa)</li>\n          <li>MENU/OZONE/POINTER: In entries list, item under cursor is automatically selected</li>\n          <li>MENU/OZONE/POINTER: In sidebar, item under cursor is not automatically selected (this is too jarring)</li>\n          <li>MENU/RGUI: Add Flux theme</li>\n          <li>MENU/XMB: New color themes Cube Purple, Family Red, etc</li>\n          <li>NETPLAY/MENU/BUGFIX: Fix Netplay Stateless Mode doesnt save. Affects other netplay settings which can be overridden by commandline option</li>\n          <li>NETPLAY/ROOMS/BUGFIX: Prevent out-of-bounds array indexing when displaying/selecting netplay rooms in menus</li>\n          <li>SCANNER: Add Arcade DAT Filter Option</li>\n          <li>SCANNER: Add scanning Korea and Asia PS1 discs</li>\n          <li>SCANNER: Add support for scanning PSP Korean</li>\n          <li>VIDEO: Set hardware Bilinear filtering off by default</li>\n          <li>VIDEO/WIDGETS: Widgets are now menu-independent</li>\n          <li>VIDEO/WIDGETS: Allow notifications to use full screen width when not displaying menu</li>\n          <li>VIDEO/WIDGETS: DPI-based scaling</li>\n          <li>VIDEO/WIDGETS: Fix volume widget scaling</li>\n          <li>VIDEO/WIDGETS: Add independent widget scale override settings for fullscreen/windowed modes</li>\n          <li>VIDEO/WIDGETS/BUGFIX: Prevent improper display of (old style) OSD text when widgets are enabled</li>\n          <li>VIDEO/WIDGETS/THREADED/BUGFIX: Fix issue - corruption of menu widgets when running some cores (e.g. VICE) with threaded video enabled</li>\n          <li>WIFI/CONNMANCTL: Display more characters from SSID</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.8.4\" date=\"2020-01-15\">\n      <url>https://www.libretro.com/index.php/retroarch-1-8-4-released/</url>\n      <description>\n        <ul>\n          <li>CAMERA/BUGFIX: Fix crash when a core requires the camera driver and the platform only has a null driver. This would crash mgba on Wii for example</li>\n          <li>DISK CONTROL: Cycle Disk Tray now becomes Eject Disk or Insert Disk depending upon current drive state</li>\n          <li>DISK CONTROL: Current Disk Index is only shown when the current disk has been ejected</li>\n          <li>DISK CONTROL: The old Insert Disk entry has been changed to Load New Disk, and is only shown when a disk is currently inserted (this is because loading a new disk from the filesystem - i.e. bypassing the m3u playlist disk index interface - automatically ejects and inserts disks, and so cannot be done while the virtual drive is empty)</li>\n          <li>DISK CONTROL: The Current Disk Index may now be set more easily via a drop-down list.</li>\n          <li>DISK CONTROL: Selecting Eject Disk automatically moves the menu selection to the Current Disk Index entry</li>\n          <li>DISK CONTROL: Selecting an index via the Current Disk Index drop-down list automatically moves the menu selection back to Insert Disk</li>\n          <li>DISK CONTROL: The Disk Control entry sublabels have been changed for greater clarity</li>\n          <li>DISK CONTROL: All of the horrendous notification spam has been removed.</li>\n          <li>DISK CONTROL: A new Resume content after changing disks option has been added under Settings > User Interface. When enabled (default setting), content is resumed automatically after selecting either Insert Disk or Load New Disk</li>\n          <li>DISK CONTROL/BUGFIX: The Disk Control menu now has the correct title</li>\n          <li>DISK CONTROL/BUGFIX: Selecting a disk via the Load New Disk file browser no longer flushes the user back to the top level menu (it now correctly returns to the Disk Control menu)</li>\n          <li>PLAYLISTS: Add 'Clean Playlist' option</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.8.2\" date=\"2019-12-28\">\n      <url>https://www.libretro.com/index.php/retroarch-1-8-2-released/</url>\n      <description>\n        <ul>\n          <li>BUG/CRASH/GLSLANG: Fix glslang crashing error - managed to reproduce an issue which has been plaguing\n          users for a while, where glslang throws an assert after closing a game (and starting a new one). This would affect all video drivers that use Slang for shaders, such as D3D10/11/12/Vulkan/Metal.</li>\n          <li>CHEEVOS: Display Unofficial and Unsupported achievement states.</li>\n          <li>CHEEVOS: Pass RetroArch and core versions through User-Agent HTTP header.</li>\n          <li>CHEEVOS: Use PSX.EXE if SYSTEM.CNF cannot be found</li>\n          <li>CHEEVOS: Prevent loading state while achievements are still being fetched from server.</li>\n          <li>CHEEVOS: Pause hardcore if core doesn't support achievements.</li>\n          <li>CHEEVOS/CRASH: Fix AddressSanitizer + CHD cause hard crash when Cheevos are enabled.</li>\n          <li>CORE UPDATER: Only download when new core is available.</li>\n          <li>CORE UPDATER: Add option to update all installed cores.</li>\n          <li>DRM/KMS: Better detection for the current video mode.</li>\n          <li>DYNAMIC RATE CONTROL: Support DRC even when using a vsync swap interval higher than 1.</li>\n          <li>FFMPEG CORE: Hardware accelerated video decoding.</li>\n          <li>FFMPEG CORE: Implement send/receive encoding API, will allow for hardware accelerated AMD video encoding.</li>\n          <li>FFMPEG CORE: The video FIFO can be removed, since we have a ring buffer in its place. This removes unneeded copy operations and as a positive side improves overall decoding speed. Makes 8k60p SW and 4k60p HW decoding feasible on many systems. For now the ring buffer is 32 images deep. This limitation will be removed, once audio and video decoder have their own packet handling.</li>\n          <li>INPUT: Fix 'Analog stick controls menu even if autoconfig disabled'.</li>\n          <li>INPUT/TURBO: Added alternate Turbo-Mode 'Single Button' - For systems supporting only a single button, the turbo-button will toggle firing that button without the need to hold it. When holding the button turbo will be suspended and resumed when the button is released. Holding the button may have a different function to just tapping it.</li>\n          <li>INPUT/ANALOG: Fix radial analog deadzone scaling.</li>\n          <li>INPUT/ANALOG: Implement proper analog button deadzone.</li>\n          <li>INPUT/MENU: Analog stick controls menu even if autoconfig disabled.</li>\n          <li>LOCALIZATION: Update Italian translation.</li>\n          <li>LOCALIZATION: Update French translation.</li>\n          <li>LOCALIZATION: Update Polish translation.</li>\n          <li>LOCALIZATION: Update Portuguese Brazilian Translation.</li>\n          <li>LOCALIZATION: Update Turkish translation.</li>\n          <li>LINUX/LOCALIZATION: Correct Droid Sans Fallback font path in Linux. This should fix Chinese/Korean font display issues on Fedora/RHEL/CentOS/openSUSE/SLE.</li>\n          <li>MENU/BUGFIX: When using a keyboard/gamepad/mouse wheel to navigate, the menu scroll position is always maintained and updated in a consistent (and expected) fashion.</li>\n          <li>MENU/BUGFIX: When resizing the window, or changing the orientation of a mobile device, the current scroll position is correctly preserved.</li>\n          <li>MENU/BUGFIX: All 'normal' pointer input is now inhibited when showing message boxes.</li>\n          <li>MENU/BUGFIX: The pointer actions 'select' and 'cancel' both now properly close a message box if it is currently being shown.</li>\n          <li>MENU/BUGFIX: Pointer 'select' and 'cancel' actions are now inhibited when an input bind dialog is active.</li>\n          <li>MENU/INPUT: Change 'User' terminology to 'Port' for input binding.</li>\n          <li>MENU/LINUX: Add proper drives to Load Content.</li>\n          <li>MENU/MATERIALUI: Halt scrolling when pointer is pressed/stationary.</li>\n          <li>MENU/MATERIALUI: Dual thumbnail view.</li>\n          <li>MENU/MATERIALUI: Fullscreen thumbnail viewer for boxart.</li>\n          <li>MENU/MATERIALUI: Scroll rapidly by press and holding the scrollbar.</li>\n          <li>MENU/RGUI: New theme 'Flux'.</li>\n          <li>MENU/OZONE: Thumbnails now have a fade-in animation.</li>\n          <li>MENU/OZONE: Fullscreen thumbnail viewer for boxart and pictures.</li>\n          <li>MENU/QT/WIMP: Fix dock titles getting cut off</li>\n          <li>MENU/XMB: Fullscreen thumbnail viewer for boxart and pictures</li>\n          <li>MENU/USABILITY: Selectively hide 'Disallow Non-Slave Mode Clients' if 'Allow Slave-Mode Clients' is disabled.</li>\n          <li>MENU/USABILITY: Hide 'Show desktop menu on startup' if 'Desktop menu' setting itself is disabled.</li>\n          <li>MENU/USABILITY: Reimplement Quick Menu - > Shaders -> Watch shader files for changes - can now be turned on/off through touch.</li>\n          <li>MENU/USABILITY: Refactor Quick Menu - Controls - each port now has its own submenu.</li>\n          <li>MENU/USABILITY: Quick Menu - Cheats - Delete All no longer requires five right button presses - this should fix this functionality for mobile touch users too.</li>\n          <li>MENU/USABILITY: Hide Refresh Rate options when Threaded Video is enabled - these settings do nothing with Threaded Video.</li>\n          <li>MENU/USABILITY: Hide Logging Verbosity levels behind Logging Verbosity.</li>\n          <li>MENU/USABILITY: Get rid of 'Port Number' label for Port Binds screen.</li>\n          <li>MENU/USABILITY/MOBILE: Should no longer crash when clicking on a cheat entry.</li>\n          <li>MENU/USABILITY: Shader parameters now have a dropdown list.</li>\n          <li>MENU/USABILITY: Shader passes now has a dropdown list.</li>\n          <li>MENU/USABILITY: Video - Hide Windowed Mode settings selectively.</li>\n          <li>MENU/USABILITY: Video - Hide Fullscreen Mode settings if windowed mode is not supported by context driver.</li>\n          <li>MENU/USABILITY: Selectively hide Network Command Port.</li>\n          <li>MENU/USABILITY: Selectively hide Relay Server Location.</li>\n          <li>MENU/USABILITY: User Interface -> Appearance - Selectively hide XMB Horizontal Animation setting.</li>\n          <li>MENU/USABILITY: Playlists - more selective hiding.</li>\n          <li>MENU/USABILITY: Selectively hide Rewind Settings.</li>\n          <li>MENU/USABILITY: Selectively hide Overlay Settings.</li>\n          <li>MENU/USABILITY: Selectively hide FPS Update Interval based on Display Framerate being enabled.</li>\n          <li>MENU/USABILITY: Selectively hide Onscreen Notifications BG Color Settings.</li>\n          <li>MENU/USABILITY: Settings -> Logging - Hide 'Log To File Timestamp' if 'Log To File' is disabled.</li>\n          <li>MENU/USABILITY: Video -> Scaling - Hide Custom Viewport X/Y when Integer Scale is enabled as description indicates.</li>\n          <li>MENU/USABILITY: Achievement submenu - selectively hide.</li>\n          <li>MENU/USABILITY: Settings -> Video -> Aspect ratio - selectively hide/show values based on whether you have Custom or Config selected.</li>\n          <li>MENU/USABILITY: Settings -> Video -> Selectively hide Hard Sync.</li>\n          <li>MENU/USABILITY: Settings -> Video -> Implement selective hiding for VSync and Hard Sync.</li>\n          <li>MENU/USABILITY: Selective hiding of Runahead settings based on global setting.</li>\n          <li>MENU/USABILITY: Add Input -> Haptic Feedback submenu.</li>\n          <li>MENU/USABILITY: Add Input -> Menu Controls submenu.</li>\n          <li>MENU/USABILITY: Settings -> Video -> Max Swapchain Images - Add OK action.</li>\n          <li>MENU/USABILITY: Input - Implement OK action for Bind Hold, Turbo Period and Duty Cycle.</li>\n          <li>MENU/USABILITY: Input - Hotkey Binds refactor.</li>\n          <li>MENU/USABILITY: Move 'Press Quit Twice' and 'Menu Toggle Gamepad Combo' to Input -> Hotkey Binds.</li>\n          <li>MENU/USABILITY: Video - Add sublabel for Video Output submenu.</li>\n          <li>MENU/USABILITY:  If 'Favorites Tab' is disabled, don't show 'Add To Favorites' option in Quick Menu/Playlist menu.</li>\n          <li>MENU/USABILITY: If On-Demand Thumbnail Downloader is enabled, hide 'Download Thumbnails' from playlist menu screen.</li>\n          <li>MENU/USABILITY: Add Audio Driver setting to Audio -> Output.</li>\n          <li>MENU/USABILITY: Add Audio -> Resampler settings.</li>\n          <li>MENU/USABILITY: Add Audio -> Output and Audio -> Synchronization.</li>\n          <li>OPENGL: Shaders are now working properly (only in OpenGL) when rotating both from Core API rotation and from menu video rotation. The fix is clearly visible with crt-royale for example.</li>\n          <li>OPENGL: 1:1 PAR is now correct when rotating (both from Core API rotation and from menu video rotation, as you said, in the latter case you currently have to change Aspect Ratio after menu video rotation for it to work).</li>\n          <li>OPENGL: When using Custom Aspect Ratio and rotation (both from Core API rotation and from menu video rotation), Integer Scaling is now working properly (correct multiples of internal resolution). Even when Integer Scaling is not activated, the Custom AR width / height are now correctly labeled using (1x), (2x), ... suffixes. You also have to activate Integer Scaling after menu video rotation for it to work.</li>\n          <li>OPENGL: For all other Aspect Ratio options, Integer Scaling and rotation (both from Core API rotation and from menu video rotation) are now working properly together (correct multiples of internal resolution). You also have to activate Integer Scaling after menu video rotation for it to work.</li>\n          <li>PLAYLISTS: Pressing 'Start' or long touching a playlist will bring you to a Playlist submenu where you can set a default core, setup thumbnail view, delete the playlist, etc.</li>\n          <li>SCANNER: Manual scanner, not dependent on database files.</li>\n          <li>SCANNER/MANUAL: Add option to scan inside archives.</li>\n          <li>SCANNER/MANUAL: Enable automatic naming of arcade content via DAT files. This is compatible with DAT files in either Logiqx XML or MAME List XML format.</li>\n          <li>VIDEO: Do not reinit video driver on SET_SYSTEM_AV_INFO unless needed.</li>\n          <li>VIDEO: Support DRC even when using a vsync swap interval higher than 1.</li>\n          <li>VIDEO LAYOUT: Fixed XML parsing of attributes with spaces, should fix issues with several video layouts.</li>\n          <li>VULKAN/ANDROID: Workaround weird WSI return codes in landscape mode -  Android WSI wants you to use preTransform, and if it is not used correctly, Android 10 will return VK_SUBOPTIMAL_KHR, and we would create a new swapchain every frame. This workaround just ignores this error, since it's not really an error. A more \"proper\" fix is to use prerotate and modify the MVP matrices,\n          which might help certain devices with crummy display processors.</li>\n          <li>VULKAN/ANDROID: Recreate swapchain on orientation change. ANativeWindow getWidth/Height does not detect any changes when using\n          Vulkan, so use the old onContentRectChanged callback to get notified when size changed. Use those values instead when figuring out how large swapchain to create.</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.8.1\" date=\"2019-11-03\">\n      <url>https://www.libretro.com/index.php/retroarch-1-8-1-released/</url>\n      <description>\n        <ul>\n          <li>BUGFIX/MENU: Fix menu rendering with Mali GPUs after changing video dimensions</li>\n          <li>CDROM: Adds pregap support to cdfs helper methods</li>\n          <li>CHEEVOS: Provides the new PCEngine hashing algorithm for RetroAchievements</li>\n          <li>LOCALIZATION: Update French translation</li>\n          <li>LOCALIZATION: Update Polish translation</li>\n          <li>LOCALIZATION: Update Spanish translation</li>\n          <li>MENU/MATERIALUI: Initial thumbnail support</li>\n          <li>MENU/MATERIALUI: Cutie / Virtual Boy theme added</li>\n          <li>MENU/MATERIALUI: Bugfix - Under certain extreme circumstances, entries with very long sublabel strings could have their text prematurely clipped as the entry is scrolled beyond the top of the screen</li>\n          <li>MENU/MATERIALUI: Bugfix - Certain setting value strings were unnecessarily truncated (with a ...) when using smooth ticker text</li>\n          <li>MENU/XMB: Sunbeam theme added</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.8.0\" date=\"2019-10-26\">\n      <url>https://www.libretro.com/index.php/retroarch-1-8-0-released/</url>\n      <description>\n        <ul>\n          <li>AI SERVICE: Added in fix for BMP returns to AI service</li>\n          <li>BSV: Fix BSV recording/playback</li>\n          <li>BUGFIX: Fix crash when setting Thumbnail Directory</li>\n          <li>BUGFIX/STABILITY: Set \"Automatically Add Content to Playlist\" to false by default</li>\n          <li>COMMON: Graceful driver switching for Windows and Linux</li>\n          <li>COMMON: Cache frame before converting 0RGB1555</li>\n          <li>MENU: Menu scaling improvements</li>\n          <li>MENU/MATERIALUI: There are no longer any animation glitches when 'wraparound' scrolling from the last entry in a list to the first, or when performing horizontal swipe navigation gestures on certain settings-type entries</li>\n          <li>MENU/MATERIALUI: List entries underneath the title and navigation bars are no longer highlighted when touching the title/navigation bars</li>\n          <li>MENU/MATERIALUI: The current menu list is no longer reloaded when pressing the currently active tab on the navigation bar</li>\n          <li>MENU/MATERIALUI: The ticker text spacer has been set to a 'bullet' character (same as Ozone)</li>\n          <li>MENU/MATERIALUI: The default colour theme has been set to 'Ozone Dark'</li>\n          <li>MENU/MATERIALUI: Three new colour themes have been added</li>\n          <li>MENU/MATERIALUI: A new Menu Transition Animation option has been added under User Interface > Appearance</li>\n          <li>MENU/MATERIALUI: The navigation bar is now shown at all times</li>\n          <li>MENU/MATERIALUI: Two new context-sensitive buttons have been added to the navigation bar - back button and resume button</li>\n          <li>MENU/MATERIALUI: A new Auto-Rotate Navigation Bar option has been added under User Interface > Appearance</li>\n          <li>MENU/MATERIALUI: The playlists tab is now correctly hidden when User Interface > Views > Show Playlist Tabs is disabled</li>\n          <li>MENU/MATERIALUI: Material UI now correctly readjusts its layout when screen orientation changes on mobile devices</li>\n          <li>MENU/MATERIALUI: Material UI now resizes in real-time when the user manually sets the Menu Scale Factor (this never worked properly with the old DPI override)</li>\n          <li>MENU/MATERIALUI: Material UI no longer leaks memory on 'context reset' (fonts were previously never free()'d)</li>\n          <li>MENU/MATERIALUI: A new Android-style 'system bar' has been added. This shows current core name, clock and battery level</li>\n          <li>MENU/MATERIALUI: A new search icon is shown on the title bar when viewing playlists and file browser lists</li>\n          <li>MENU/MATERIALUI: The title bar now uses a larger font, and the sublabel font has also been enlarged a little, to more closely align with Material UI standards</li>\n          <li>MENU/MATERIALUI: A number (quite a large number) of layout/spacing issues have been fixed</li>\n          <li>MENU/MATERIALUI: The existing colour theme handling code is not fit for purpose, so the whole lot got ripped out and reimplemented</li>\n          <li>OSD: Fix fast forward indicator when not using menu widgets</li>\n          <li>VIDEO LAYOUT: Add video layout mame overlay compatibility</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.7.9\" date=\"2019-10-07\">\n      <url>https://www.libretro.com/index.php/retroarch-1-7-9-released/</url>\n      <description>\n        <ul>\n          <li>AI SERVICE: Image mode is now much faster</li>\n          <li>BUGFIX: Touch input - When using an overlay to toggle the quick menu on touchscreen devices</li>\n          <li>BUGFIX: Networking - RetroArch crashed when pressing left while Relay Server Location entry was selected</li>\n          <li>BUGFIX: Networking - fix memory leak that could happen at exit after a network\n          operation had run</li>\n          <li>CHEEVOS: Improve handling of line endings when calculating CD hashes for retroachievements</li>\n          <li>CHEEVOS: Add support for Sega CD/Saturn; reduce hash calls to server</li>\n          <li>FPGA: Add initial FPGA port for Z-Turn boards - not really release-ready yet, will need community support to continue. Currently employs naive framebuffer approach, not fullspeed</li>\n          <li>GL1: GLDirect (D3D9 to OGL1.1 wrapper) support</li>\n          <li>GONG: Stability fixes</li>\n          <li>LINUX/UDEV: Fix touchscreen/lightgun issues</li>\n          <li>MENU/MATERIALUI: MaterialUI no longer 'forgets' its place when navigating backwards in menus, and navigation in general is 'cleaner'.</li>\n          <li>MENU/MATERIALUI: Add initial gesture support</li>\n          <li>MENU/MATERIALUI: Improved touch support</li>\n          <li>MENU/MATERIALUI: Bugfix - Random' items are no longer automatically highlighted when performing standard up/down 'flick' scrolling through lists</li>\n          <li>MENU/MATERIALUI: Bugfix - The display no longer 'jerks' for one frame when navigating backwards through lists</li>\n          <li>MENU/MATERIALUI: Bugfix - The Material UI scaling factor is now based upon the device-reported screen DPI value (previously it relied upon a hard-coded magic number, which was never correct)</li>\n          <li>MENU/RGUI: Functional mouse/touchscreen support</li>\n          <li>MENU/ONSCREEN KEYBOARD: On-screen keyboard entry via mouse/touchscreen has been tidied up - no more double inputs (or unwanted menu interaction in the background)</li>\n          <li>MENU/MOUSE: Mouse wheel up/down is now a proper 'up/down', same as using cursor keys or a dpad</li>\n          <li>MENU/MOUSE: Mouse wheel tilt left/right has been wired up to normal 'left/right' commands</li>\n          <li>MENU/OZONE: Add option to toggle between static and scrolling content metadata</li>\n          <li>MENU/XMB: Add full gesture support</li>\n          <li>MENU: When navigating backwards from a core options drop-down list (i.e. pressing select or cancel), the last menu position is remembered (instead of resetting back to the first core option item each time)</li>\n          <li>MENU: Add mouse/touchscreen gesture support</li>\n          <li>MENU: Add option to delete playlists (Settings and Playlists: Playlist Management)</li>\n          <li>OSD: Memory details should now be available on every platform (get_mem_total and get_mem_free need to be implemented in the frontend driver for it to work)</li>\n          <li>OSD: Memory details can now be shown individually without FPS and frame count</li>\n          <li>THREADED VIDEO: Fix FPS text in threaded video mode</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.7.8\" date=\"2019-08-30\">\n      <url>https://www.libretro.com/index.php/retroarch-1-7-8-v2-released/</url>\n      <description>\n        <ul>\n          <li>AI: Add AI Service functionality</li>\n          <li>AI: Fix 'Japanese' setting</li>\n          <li>BPS/UPS: Re-allocation target_data variable for target patch size</li>\n          <li>CDROM: Added real CD-ROM functionality for Windows and Linux</li>\n          <li>CDROM: Added disc dumping</li>\n          <li>CHEEVOS: Fix Achievements badges</li>\n          <li>CHEEVOS: Add hashing support for PSX (bin/cue, chd, or real CD)</li>\n          <li>COMMON: Add separate frontend logging</li>\n          <li>COMMON: Ability to set FPS update interval (used in the window titlebar/FPS widget)</li>\n          <li>COMMON: Add 'Reset Frame Time Counter' functionality</li>\n          <li>COMMON: Add optional 'on demand' thumbnail downloads</li>\n          <li>COMMON: Add new playlist-based thumbnail downloader</li>\n          <li>COMMON: Show license per core (if available) inside 'Load Core'</li>\n          <li>COMMON: Add option to load content from (and dump) CD-ROM discs</li>\n          <li>COMMON: Re-enable '--log-file' command line option</li>\n          <li>COMMON: Default playlist core association is now stored as metadata inside each playlist</li>\n          <li>COMMON: Fix playlist format detection</li>\n          <li>COMMON: Favorites playlist size can now be set independently of content history size</li>\n          <li>COMMON: Prevent adding new items to favorites when playlist is full (old entries are no longer overwritten)</li>\n          <li>COMMON: Prevent loading content with cores that require an incompatible graphics API version from the current one</li>\n          <li>COMMON: Saved shader presets are now portable across platforms and use relative paths</li>\n          <li>COMMON: Add '--set-shader' command line option which works like an override for automatic shader presets</li>\n          <li>COMMON: Add global shader presets</li>\n          <li>COMMON: Remove 'video_shader' setting, shaders are not saved automatically anymore</li>\n          <li>CORE OPTIONS: When saving core option overrides, only include settings for the current core</li>\n          <li>CORE OPTIONS: Add option to save core options per-core</li>\n          <li>CPU FILTERS: Add Scanline2x filter</li>\n          <li>GL/MALI400: Fix menu issues on Mali 400 series GPUs, should also fix 'RetroArch flickers black on ARM Mali GPUs (Android/ARM Linux)</li>\n          <li>GL/GLCORE: Use highest supported OpenGL Core version on Windows and X11</li>\n          <li>GL1: Ignore alpha in core video, fixes XRGB8888 rendering in some cores</li>\n          <li>GLCORE: Don't hardcode shader cross compilation target version but poll it</li>\n          <li>GLCORE: Fix regression - shaders don't work</li>\n          <li>GLCORE/SLANG: Added \"FrameDirection slang semantic</li>\n          <li>HID: Add Retrode support. Should work on Wii/WiiU</li>\n          <li>INPUT: Menu toggle hotkey can now be bound to another keyboard key and it will toggle properly</li>\n          <li>LIBRETRO: Add new core options interface, allows for localization, sublabels and more</li>\n          <li>LIBRETRO: Add new bitmask input codepath, for RETRO_DEVICE_ID_JOYPAD only for now</li>\n          <li>LOCALIZATION: Update Korean translation</li>\n          <li>LOCALIZATION: Update Japanese translation</li>\n          <li>LOCALIZATION: Update Portuguese Brazilian Translation</li>\n          <li>LOCALIZATION: Update Polish translation</li>\n          <li>LOCALIZATION: Update Turkish translation</li>\n          <li>LOCALIZATION: Update Japanese translation</li>\n          <li>LOCALIZATION: Update Korean translation</li>\n          <li>LOCALIZATION: Update Polish translation</li>\n          <li>MENU/XMB: Smooth vertical ticker scrolling</li>\n          <li>MENU: Add smooth ticker text</li>\n          <li>MENU: Ability to hide every settings submenu (User Interface, Views, Settings)</li>\n          <li>MENU: Ability to hide nearly every quick menu entry (User Interface, Views, Quick Menu)</li>\n          <li>MENU: Fix longstanding menu display issues on Mali400 GPUs (on ARM hardware, SBCs and mobile phones/tablets)</li>\n          <li>MENU: Fix Record Streaming Quality, and Record, Recording Threads settings</li>\n          <li>MENU: Fix history playlist navigation after running content</li>\n          <li>NENU: Menu entry performance optimisations</li>\n          <li>MENU: Add option to show 'remove playlist entry' only on history/favourites</li>\n          <li>MENU: Overhaul content 'Information' menu display</li>\n          <li>MENU: Add new 'Playlist Management' submenu. Allows default core associations to be set (via dropdown list), and all existing associations to be reset</li>\n          <li>MENU: Add 'Set Core Association' option to Quick Menu</li>\n          <li>MENU: Add option to remain in menu after saving/loading states</li>\n          <li>MENU: Pressing the Start button on 'Load Core' will unload the core</li>\n          <li>MENU: After a core is running, Load Core will be hidden from view until you select 'Close Content' from the Quick Menu</li>\n          <li>MENU/WIDGETS: All widgets are now properly cleaned up, fixing the frozen widgets bug when loading / closing content</li>\n          <li>MENU/WIDGETS: Fix crash with tasks</li>\n          <li>MENU/WIDGETS: Widgets are now drawn above the overlay with OpenGL and Vulkan</li>\n          <li>MENU/WIDGETS: Fine tune progress bar colors</li>\n          <li>MENU/WIDGETS: Have the progression widget always resize</li>\n          <li>MENU/THUMBNAILS: Ensure that displayed thumbnails are always refreshed correctly after selecting 'Download Thumbnails' from Quick Menu</li>\n          <li>MENU/THUMBNAILS: Make PNG image loading/processing non-blocking on non-threaded systems</li>\n          <li>MENU/OZONE: Add it for PS3</li>\n          <li>MENU/OZONE: Fix regression in 1.7.7 - OSX/macOS - was unable to start it</li>\n          <li>MENU/OZONE: Fix sublabel spacing</li>\n          <li>MENU/OZONE: Add toggle to enable/disable playlist name truncation in Ozone</li>\n          <li>MENU/OZONE: (Ozone) Fix display of (semi-)transparent thumbnails</li>\n          <li>MENU/XMB: Add menu animation settings</li>\n          <li>MENU/XMB: Add optional thumbnail scaling</li>\n          <li>MENU/XMB: Fix display of long sublabels. Text that would exceed the display area now scrolls line-by-line</li>\n          <li>MENU/XMB/OZONE: Add optional thumbnail upscaling</li>\n          <li>MENU/QT/WIMP: Add core option sublabels as tooltips, add buttons to reset one/all core options</li>\n          <li>MENU/QT/WIMP: Word-wrap core option tooltips</li>\n          <li>MENU/QT/WIMP: Path selector fixes</li>\n          <li>MENU/RGUI: Enable playlist display on platforms without database support</li>\n          <li>MENU/RGUI: Make particle effects framerate independent + add animation speed setting</li>\n          <li>MIDI: correct pitch bend in ALSA driver - MIDI standard pitch bend center position is 0x2000 but ALSA's is 0</li>\n          <li>MIDI: Fix SysEx handling</li>\n          <li>OSD: OSD is now drawn above the overlay with Vulkan</li>\n          <li>PATCH: Fix IPS patches</li>\n          <li>PLAYLISTS: Fix playlist heap corruption bug</li>\n          <li>PLAYLISTS: Add history/favourites to 'Playlist Management' menu</li>\n          <li>RECORD: Fix Twitch streaming</li>\n          <li>REMOTE RETROPAD: Fix for Remote RetroPad input</li>\n          <li>RUNAHEAD/MSVC2010:  Build in runahead support for MSVC2010 and up</li>\n          <li>RUNAHEAD/VITA: Build in runahead support for Vita version</li>\n          <li>SAVESTATES: Allow auto save states also in cores that support no content as long as some content is loaded</li>\n          <li>SCALER: Fix SSE2 path for ARGB/BGRA -&gt; BGR24 - should fix screenshots being taken for XRGB888 (viewport)</li>\n          <li>SCANNER: Skip all databases with incompatible file extensions, whether content is inside an archive or not</li>\n          <li>SCANNER: Fix hang on empty files inside archives</li>\n          <li>SHADERS: Fix shader loading and saving in content-less cores</li>\n          <li>SHADERS: Implement video shader delay setting</li>\n          <li>SHADERS: Add proper shader compatibility checks</li>\n          <li>SHADERS: Enable Cg shaders for D3D9</li>\n          <li>SHADERS: Remove 'video_shader' setting, replace it with global presets that make more sense</li>\n          <li>SHADERS: #reference directive for shaders. Presets can point to other existing presets if they are unchanged</li>\n          <li>SHADERS: Will attempt to cache the shader/preset into memory before loading to avoid costly getline/gets/getc operations</li>\n          <li>SHADERS: New --set-shader commandline option</li>\n          <li>SHADERS/MENU: Prevent undefined behaviour when failing to load shaders</li>\n          <li>SHADERS/MENU: Pressing the Start button on 'Load Shader Preset' will reset all shader passes and apply changes, effectively disabling the shaders</li>\n          <li>SHADERS/MENU: New menu options for removing shader presets (global/core/parent/etc)</li>\n          <li>THUMBNAILS: Add optional On-Demand Thumbnails</li>\n          <li>UDEV: Fix wrong udev devices order</li>\n          <li>UDEV/X11: Mouse pointer should work now in X11 environment with no Display</li>\n          <li>VULKAN/SLANG: Added \"FrameDirection\" slang semantic</li>\n          <li>VULKAN: Add option to select which GPU to render with</li>\n          <li>VULKAN: Validate non-causal filter chain for texture inputs. We only validated for UBO inputs apparently</li>\n          <li>WII: Add default video/audio filter directories</li>\n          <li>X11: Add improved menu resizing for window resizing</li>\n          <li>X11: Add non-evdev keycodes to fix keyboard input on non-Linux systems with X11</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.7.7\" date=\"2019-05-07\">\n      <url>https://www.libretro.com/index.php/retroarch-1-7-7-released/</url>\n      <description>\n        <ul>\n          <li>AUDIO: Avoid deadlocks in certain audio drivers when toggling menu sounds on</li>\n          <li>BLISS-BOX: Support PSX Jogcon (requires firmware 3.0)</li>\n          <li>CHEEVOS: Fix crash when reading memory that is out of range</li>\n          <li>CHEEVOS: New Cheevos implementation enabled by default</li>\n          <li>CHEEVOS: Pop-up badges when an achievement is triggered</li>\n          <li>CRT: Dynamic super resolution support</li>\n          <li>DISCORD: Fix potential crash when username is empty and discord is disabled</li>\n          <li>DISCORD: Ask to join support for Linux</li>\n          <li>INPUT/ANDROID: Add \"Input Block Timeout\" option</li>\n          <li>COMMON: For platforms without HAVE_THREADS, don't automatically resume content when saving/loading states</li>\n          <li>COMMON: Make playlist sorting optional and consistent</li>\n          <li>COMMON: Fix sorting of playlists with blank labels</li>\n          <li>COMMON: Fix content scanner creating false positive playlist entries that also have wrong label and crc32</li>\n          <li>COMMON: Add some MMX-optimized pixel conversion routines</li>\n          <li>COMMON: Fix typo preventing some SSE2-optimized pixel conversions from being used</li>\n          <li>COMMON: Add option to track how long content has been running over time</li>\n          <li>COMMON: Fix buffer overflows in system information</li>\n          <li>COMMON: Add option to change screen orientation via the windowing system (Android, Windows, X11)</li>\n          <li>COMMON: Show CPU model name in log</li>\n          <li>COMMON: Add \"Help -> Send Debug Info\" option (and F10 hotkey) to send diagnostic info to the RetroArch team for help with problems</li>\n          <li>COMMON: Show GPU device name/version in log</li>\n          <li>COMMON: Add menu option to write log info to a file</li>\n          <li>COMMON: Add subsystem support for playlists. Subsystem info is automatically saved to the history playlist for easy relaunching</li>\n          <li>GL: Add new \"gl1\" OpenGL 1.1 compliant video driver for legacy GPUs and software renderers</li>\n          <li>GL: Add a new \"glcore\" driver with slang support (requires GL 3.2+ or GLES3)</li>\n          <li>GL: Draw OSD on top of overlay</li>\n          <li>GONG: Add savestate support</li>\n          <li>GONG: Add video refresh rate core options</li>\n          <li>GONG: Two player support via core option</li>\n          <li>GUI: Fix text alignment when using stb_unicode</li>\n          <li>GUI: Fix text display issues when using Japanese (and other unicode-dependent language) text with stb_unicode</li>\n          <li>GUI: Set language on first startup to the user's preferred OS language (Windows, *nix and Android)</li>\n          <li>INPUT: Add (scaled radial) analog deadzone and sensitivity options</li>\n          <li>LIBRETRO: Add Turkish language support</li>\n          <li>LIBRETRO: Allow non-accelerated video to rotate the display</li>\n          <li>LOCALIZATION: Update Chinese (Simplified) translation</li>\n          <li>LOCALIZATION: Update Chinese (Traditional) translation</li>\n          <li>LOCALIZATION: Update Dutch translation</li>\n          <li>LOCALIZATION: Update French translation</li>\n          <li>LOCALIZATION: Update German translation</li>\n          <li>LOCALIZATION: Update Japanese translation</li>\n          <li>LOCALIZATION: Update Polish translation</li>\n          <li>LOCALIZATION: Update Russian translation</li>\n          <li>LOCALIZATION: Update Spanish translation</li>\n          <li>LOCALIZATION: Add new Turkish translation</li>\n          <li>MIDI: Fix startup crash in midi driver</li>\n          <li>MENU: Bugfix - you can no longer get stuck in Online Updater -> Update Core screen when toggling between ingame and menu</li>\n          <li>MENU: Selectively hide 'Take Screenshot' for video drivers that don't support taking screenshots</li>\n          <li>MENU: Framerate independent menu rendering. MaterialUI/Ozone/XMB/RGUI can now run at higher framerates</li>\n          <li>MENU: Thumbnails work in history list</li>\n          <li>MENU: Menu widgets</li>\n          <li>MENU: Add memory statistics support to more context drivers</li>\n          <li>MENU: Enable ozone driver for UWP builds</li>\n          <li>MENU: Add optional \"looping\" menu text ticker with configurable speed</li>\n          <li>MENU: Fix core video rendering when using ozone with GL cores that implement the scissor test</li>\n          <li>MENU: Add optional playlist sublabels (associated core + play time, where available)</li>\n          <li>MENU: Dropdown list settings now apply immediately</li>\n          <li>MENU: Add setting to require pressing the \"Exit RetroArch\" hotkey twice to confirm</li>\n          <li>MENU: Now able to run at higher refresh rates than 60Hz</li>\n          <li>MENU: Enable \"Add to Favorites\" without loading a core</li>\n          <li>MENU: Allow core name to be hidden on history/favorites playlists</li>\n          <li>MENU: Populate crc32 and db_name fields when adding history/favourites playlist entries</li>\n          <li>MENU: Fix TTF files not showing in OSD/menu font selection screen</li>\n          <li>MENU: Fix audio/video filters not showing in file browser</li>\n          <li>MENU/MaterialUI: Add subsystem support</li>\n          <li>MENU/MaterialUI: Add currently selected entry in dropdown menus</li>\n          <li>MENU/OZONE: Add mouse support on entries (no sidebar yet)</li>\n          <li>MENU/OZONE: Allow collapsing the sidebar</li>\n          <li>MENU/OZONE: Add thumbnail support</li>\n          <li>MENU/OZONE: Battery notifications</li>\n          <li>MENU/OZONE: Add wifi icon for network entries</li>\n          <li>MENU/QT/WIMP: Add git version and build date to Help->About window</li>\n          <li>MENU/QT/WIMP: Fix content loading via the file browser</li>\n          <li>MENU/QT/WIMP: Add new settings window to control all RetroArch settings</li>\n          <li>MENU/RGUI: Improve playlist titles</li>\n          <li>MENU/RGUI: Add option to hide associated cores in playlists</li>\n          <li>MENU/RGUI: Add internal upscaling option</li>\n          <li>MENU/RGUI: Add subsystem support</li>\n          <li>MENU/RGUI: Add menu sublabel support</li>\n          <li>MENU/RGUI: Re-enable \"Load Core\" option when content is loaded</li>\n          <li>MENU/RGUI: Add optional \"Collections\" entry to main menu</li>\n          <li>MENU/RGUI: Add \"Lock Menu Aspect Ratio\" option</li>\n          <li>MENU/RGUI: Add \"full width\" layout option</li>\n          <li>MENU/RGUI: Ensure menu color theme is applied immediately</li>\n          <li>MENU/RGUI: Fix \"Lock Menu Aspect Ratio\" option when using custom viewports</li>\n          <li>MENU/RGUI: Add widescreen support</li>\n          <li>MENU/RGUI: Allow text to be centred when selecting widescreen layouts</li>\n          <li>MENU/RGUI: Add inline playlist thumbnail support</li>\n          <li>MENU/RGUI: Add optional shadow effects</li>\n          <li>MENU/RGUI: Performance optimizations</li>\n          <li>MENU/RGUI: Add optional extended ASCII support</li>\n          <li>MENU/RGUI: Add optional delay when loading thumbnails</li>\n          <li>MENU/RGUI: Add on-screen keyboard</li>\n          <li>MENU/RGUI: Battery notifications</li>\n          <li>MENU/XMB: Prevent crashes when resizing to a tiny window</li>\n          <li>MENU/XMB: XMB honors the 'show menu sublabels' setting now - was previously RGUI only</li>\n          <li>NETPLAY: Fix stall-out causing total disconnection with >2 players</li>\n          <li>NETPLAY: Different (more intuitive?) default netplay share policy</li>\n          <li>NETPLAY: Add hotkey option to toggle hosting on/off</li>\n          <li>NETWORKING: Encode URLs to allow for spaces in directory names</li>\n          <li>SCANNER: New option 'Scan without core match'</li>\n          <li>SHADERS: Don't alphabetize shader presets</li>\n          <li>VULKAN: Fix color issues with RGBA8888 swapchains in readback (screenshots)</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.7.6\" date=\"2019-02-03\">\n      <url>https://www.libretro.com/index.php/retroarch-1-7-6-released/</url>\n      <description>\n        <ul>\n          <li>CHEEVOS: Reset when hardcore mode is toggled</li>\n          <li>CHEEVOS: Update the hashing methods to identify NES, SNES and Lynx games (more accurate and accepting headerless ROMs)</li>\n          <li>COMMON: Add new JSON playlist format</li>\n          <li>COMMON: Fix playlist corruption when deleting items</li>\n          <li>COMMON: Fix archive progress display calculation</li>\n          <li>COMMON: Fix playlist entries appearing with previously used names</li>\n          <li>COMMON: Fix screenshot filename with no core or content</li>\n          <li>COMMON: Allow compiling without menu support</li>\n          <li>CORE UPDATER: Allow sideloading cores from the menu</li>\n          <li>CPU FILTERS: Add Normal2x filter</li>\n          <li>CRT/LINUX: New Linux switching method partially implemented</li>\n          <li>CRT/LINUX: Linux restore desktop resolution fixed</li>\n          <li>CRT/LINUX: Monitor index switching and auto enumerate for output detection in Linux (still working on the windows method)</li>\n          <li>CRT/RASPBERRY PI: Initial support</li>\n          <li>DATE: Add Date / Time style options</li>\n          <li>DEBUGGING: Add an integrated crash handler for debug builds</li>\n          <li>DISCORD: Register the application name properly</li>\n          <li>DISK CONTROL: Remember the last used folder / current active folder to make disk-swapping faster</li>\n          <li>INPUT: Add new menu toggle (hold start button for 2 seconds)</li>\n          <li>INPUT: Fix arrow keys being incorrectly bound as numpad keys</li>\n          <li>INPUT/SDL: Flush the joypad events. Decreases cpu usage over time with the SDL joypad driver</li>\n          <li>LOCALIZATION: Add Greek translation</li>\n          <li>LOCALIZATION: Update German translation</li>\n          <li>LOCALIZATION: Update Italian translation</li>\n          <li>LOCALIZATION: Update Japanese translation</li>\n          <li>LOCALIZATION: Update Simplified Chinese translation</li>\n          <li>LOCALIZATION: Update Spanish translation</li>\n          <li>MENU: New \"ozone\" menu driver</li>\n          <li>MENU: Only show CRT SwitchRes if video display server is implemented (Windows/Linux for now)</li>\n          <li>MENU: User Interface -> Appearance -> 'Menu Font Green/Blue Color' settings now work properly</li>\n          <li>MENU: Add option to enable in-menu sound effects</li>\n          <li>MENU/QT/WIMP: Allow building with MSVC2017</li>\n          <li>MENU/QT/WIMP: Add detailed file browser table</li>\n          <li>MENU/QT/WIMP: New grid view implementation that is faster and loads thumbnails on-demand</li>\n          <li>MENU/QT/WIMP: Thumbnail drag and drop support</li>\n          <li>MENU/RGUI: Overhaul custom theme interface + add wallpaper support</li>\n          <li>MENU/RGUI: Thumbnail support and thumbnail downscaling</li>\n          <li>MENU: Hide password values</li>\n          <li>MENU/SOUNDS: Implement in-menu sound effects (not enabled by default for now, still experimental)</li>\n          <li>MIDI: Add a Linux ALSA driver for MIDI</li>\n          <li>NETPLAY: Force fast-save-states when netplay is enabled</li>\n          <li>NETPLAY: Allow quick joining subsystem lobbies</li>\n          <li>RECORDING: Implement recording options in the menu complete with quality profiles, streaming, and proper file naming</li>\n          <li>SCANNER: Fix GDI disc scanning</li>\n          <li>SHADERS: Fix auto shader preset loading on D3D10, D3D11, D3D12</li>\n          <li>SUBSYSTEM: Allow more than 10 subsystems</li>\n          <li>SUBSYSTEM: Cores that use subsystem for complex scenarios can now load content without starting a regular content first</li>\n          <li>SUBSYSTEM: Remember the last used folder to make loading subsystem type content faster</li>\n          <li>VULKAN: Fix RGUI crashing at startup</li>\n          <li>VULKAN/RGUI: Enable 'Menu Linear Filter' option</li>\n          <li>VULKAN: Fix secondary screens in overlays not working</li>\n          <li>WAYLAND: Implement idle-inhibit support (needed for screensaver suspend)</li>\n          <li>WAYLAND: Fix fullscreen toggle</li>\n          <li>VFS: Update to version 3</li>\n          <li>XBONE: Initial Xbox One port</li>\n          <li>XMB/OZONE: Add more icons</li>\n          <li>Easter egg</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.7.5\" date=\"2018-10-2\">\n      <description>\n        <ul>\n          <li>CAMERA: Fix Video4Linux2 driver that broke years ago</li>\n          <li>CONFIG: Add 'Reset To Defaults' setting in Configurations. Thi will reset your config file to defaults</li>\n          <li>CHEATS: Add support for Rumble when increase or decrease by the rumble value</li>\n          <li>CHEATS: Add cheat variables to allow for updating large portions of memory</li>\n          <li>CHEEVOS: Prevent loading states before achievements are fully loaded</li>\n          <li>COMMON: Support for \"OEM-102\" key (usually '' on Euro keyboards)</li>\n          <li>DISCORD: Add 'Ask To Join' Feature</li>\n          <li>INPUT: Add new menu toggle combos 'L3 + R' and 'L + R' (useful for Switch)</li>\n          <li>LOCALIZATION: Update Portuguese / Brazilian translation</li>\n          <li>LOCALIZATION: Update Japanese translation</li>\n          <li>LOCALIZATION: Update Polish translation</li>\n          <li>LOCALIZATION: Update Spanish translation</li>\n          <li>MENU: Add dropdown lists for many settings</li>\n          <li>MENU: Fix crash that could happen when changing core's options on Android</li>\n          <li>MENU/QT/WIMP: Add option to rename playlists</li>\n          <li>MENU/QT/WIMP: Add option to filter extensions inside archives when adding to a playlist</li>\n          <li>MENU/QT/WIMP: Rename playlist entries with 2 single clicks</li>\n          <li>MENU/QT/WIMP: Fix shader parameter checkboxes not working</li>\n          <li>NETPLAY: Save lobby details received back from server after first announcement</li>\n          <li>OPENGL/GLX: Implement Adaptive VSync - GLX_EXT_swap_control_tear</li>\n          <li>OPENGL/WGL: Implement Adaptive VSync - WGL_EXT_swap_control_tear</li>\n          <li>RUNAHEAD: Fix performance degradation that could happen over time (after approx. 30 mins). Fixed input IDs outside of range 0-35 causing slow performance in runahead</li>\n          <li>VULKAN: Fix race condition in threaded mailbox emulation</li>\n          <li>VULKAN: Maintenance fixes</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.7.4\" date=\"2018-08-30\">\n      <description>\n        <ul>\n          <li>CHEEVOS: Fix crash when scrolling Achievement List while Unofficial Achievements enabled (#6732)</li>\n          <li>CHEEVOS: Added hitcounts support for PauseIf/ResetIf (#6817)</li>\n          <li>COMMON: Automatically hide \"Configuration Override options\" in Quick Menu</li>\n          <li>COMMON: Small Bugfix to not trigger savestate code when pressing Reset</li>\n          <li>COMMON: Added libsixel video driver</li>\n          <li>LOCALIZATION: Update Italian translation</li>\n          <li>LOCALIZATION: Update Japanese translation</li>\n          <li>LOCALIZATION: Update Polish translation</li>\n          <li>LOCALIZATION: Update Portuguese / Brazilian translation</li>\n          <li>LOCALIZATION: Update Russian translation</li>\n          <li>LOCALIZATION: Update Spanish translation</li>\n          <li>MIDI: Add MIDI support to the libretro API. Dosbox is the first proof of concept core implementing libretro MIDI</li>\n          <li>MENU/QT/WIMP: Qt QSlider styling for Dark Theme</li>\n          <li>MENU/QT/WIMP: Remove button ghostly inside highlighting</li>\n          <li>MENU/QT/WIMP: Initial grid view</li>\n          <li>MENU/QT/WIMP: Drag and drop to add new playlist items, add option to add/edit/delete playlists</li>\n          <li>MENU/QT/WIMP: Add menu option to update RetroArch (Windows only for now)</li>\n          <li>MENU/QT/WIMP: Add menu option to manage shaders</li>\n          <li>MENU/QT/WIMP: Add menu option to manage core options</li>\n          <li>MENU/XMB: Add new icons for the settings</li>\n          <li>MENU/XMB: Add an option to show the desktop ui</li>\n          <li>NETWORK: Enable SSL/TLS support by default for desktop platforms</li>\n          <li>REMAPS: Fix the way offsets are calculated for keyboard remapping</li>\n          <li>RUNAHEAD: Fix full-screen mode change breaking Secondary Core's environment variables</li>\n          <li>VULKAN: Fix two validation errors</li>\n          <li>VULKAN: Try to avoid creating swapchains redundantly. Should fix black screen and having to alt tab out of window again to get display working on Nvidia GPUs (Windows)</li>\n          <li>X11: Fix Game Focus Toggle</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.7.3\" date=\"2018-05-03\">\n      <description>\n        <ul>\n          <li>AUDIO: Audio mixer supports FLAC/MP3 file types now</li>\n          <li>COMMON: Fixed bug 'crashing in cores that don't range check retro_set_controller_type'</li>\n          <li>COMMON: (QuickMenu) Added Configuration Override submenu</li>\n          <li>LOCALIZATION: Update Italian translation</li>\n          <li>LOCALIZATION: Update Portuguese translation</li>\n          <li>MENU: Audio mixer now works in the menu without any cores loaded. You have to enable the setting 'Enable menu audio' for this to work</li>\n          <li>REMAPPING/OVERLAYS: Fix regression - overlays could no longer be remapped</li>\n          <li>SCANNER: Add Wii Backup File WBFS support</li>\n          <li>X11: CRT SwitchRes support for X11/Linux</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.7.2\" date=\"2018-04-24\">\n      <description>\n        <ul>\n          <li>CRT: Added CRT SwitchRes</li>\n          <li>COMMON: Hide the 'Core delete' option if the 'Core updater' is also hidden</li>\n          <li>COMMON: Add way to reset core association for playlist entry</li>\n          <li>COMMON: Fix invalid long command line options causing infinite loop on Windows</li>\n          <li>COMMON: Add OSD statistics for video/audio/core</li>\n          <li>COMMON: Added runahead system; allows you to drive down latency even further</li>\n          <li>CHEEVOS: Support Atari 2600, Virtual Boy, and Arcade (only Neo Geo, CPS-1, CPS-2 and CPS-3 and only with fbalpha core)</li>\n          <li>CHEEVOS: Add option to automatically take a screenshot when an achievement is triggered</li>\n          <li>CHEEVOS: Fixed incompatibilities with Neo Geo Pocket achievement sets</li>\n          <li>LIBRETRO: Addition - Functions to enable and disable audio and video, and an environment function to query status of audio and video enables</li>\n          <li>LOCALIZATION: Update Italian translation</li>\n          <li>LOCALIZATION: Update Polish translation</li>\n          <li>MENU: Add Rewind/Latency/Overlay settings to Quick Menu, add options to show/hide them (User Interface -> Views -> Quick Menu)</li>\n          <li>MENU/RGUI: Only show Menu Linear Filter for RGUI and only show it for video drivers that implement it (D3D8/9/10/11/12/GL)</li>\n          <li>MENU/RGUI: Add User Interface -> Appearance options</li>\n          <li>MENU/RGUI: D3D8/D3D9: Hookup Menu Linear Filter</li>\n          <li>MENU/XMB: Disable XMB shadow icons by default for PowerPC and ARM for performance reasons</li>\n          <li>MENU/XMB: Left/right thumbnails are now automatically scaled according to layout</li>\n          <li>MENU/XMB: Add Left Thumbnails (additional to the right)</li>\n          <li>MENU/XMB: Fixed left/right tab regression</li>\n          <li>MENU/XMB: Fix scaling of tall images that were cut on bottom previously</li>\n          <li>MENU/XMB: Menu scale factor setting now changes texts length, image scaling and margins</li>\n          <li>MENU/XMB: Mouse cursor scales correctly now</li>\n          <li>MENU/XMB: Add toggle to show/hide Playlist tabs</li>\n          <li>MENU/XMB: Add menu layout - can switch between Desktop, Handheld and Auto</li>\n          <li>MENU/XMB: Don't load menu pipeline shaders unless XMB is selected (D3D10/D3D11/D3D12/GL/Vulkan)</li>\n          <li>MENU/VIDEO: Only show black frame insertion for the video drivers/context drivers that support it (so far this includes - D3D8/D3D9, OpenGL, Vulkan)</li>\n          <li>MENU/VIDEO: Only show max swapchain images if supported by video driver and/or context driver (so far this includes - DRM EGL context driver, VideoCore EGL context driver, Vulkan)</li>\n          <li>MENU/MaterialUI: Automatic DPI Scaling should be much improved now, now scales as expected at 1440p and 4K resolutions</li>\n          <li>MENU/MaterialUI: Fix wrong calculation of an entry height causing long playlists to end up outside of screen range. This also could cause crashes on low DPI screens</li>\n          <li>SCANNER: Should be able to scan dual-layer Wii disc images now, filestream code now supports files larger than 4GB</li>\n          <li>SHADERS/SLANG: Slang shaders should work again on Android version and MSVC versions (basically all the Griffin-based versions)</li>\n          <li>SHADERS: If GL context is GLES2/3/Core context, Cg shaders are unavailable. Applies to shader list too</li>\n          <li>SHADERS: Hide cg/glsl shaders from being able to be selected if D3D8/9/10/11/Vulkan video drivers are selected</li>\n          <li>SHADERS: Hide slang shaders from being able to be selected if D3D8/9/OpenGL video drivers are selected</li>\n          <li>SHADERS: Prevent crashes from occurring if we have the GL video driver in use and we try to skip to a slang shader through next/previous hotkeys</li>\n          <li>SHADERS: Fix shader parameter increase / decrease functions</li>\n          <li>SUBSYSTEM: handle savestates properly (cart1 + cart2.state0)</li>\n          <li>VULKAN/X11: Fix X11 Vulkan bug from Wayland driver</li>\n          <li>VULKAN: Fix multi-line text spacing in menus with Vulkan driver</li>\n          <li>X11: Allow compositor disabling on X11 fullscreen through _NET_WM_BYPASS_COMPOSITOR</li>\n          <li>X11: Prioritize _NET_WM_STATE_FULLSCREEN in true fullscreen mode</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.7.1\" date=\"2018-02-19\">\n      <description>\n        <ul>\n          <li>AUDIO: Added 'Audio Resampler Quality' setting to Audio Settings</li>\n          <li>CHEEVOS: Fix unofficial achievements not being loaded</li>\n          <li>CHEEVOS: Show savestate menu entries when no achievements are found even if hardcore mode is enabled</li>\n          <li>CHEEVOS: Support Neo Geo Pocket</li>\n          <li>COMMON: Bugfix for issue related to 'Windows mouse pointer visible when running MESS or MAME cores'</li>\n          <li>COMMON: Fix bug 'Last item in a Playlist is ignored'</li>\n          <li>COMMON: New LED API. Driver implemented for Raspberry Pi, proof of concept implemented for core MAME 2003</li>\n          <li>COMMON: Add quick menu option to watch shader files for changes and recompile them automatically (Linux only for now)</li>\n          <li>D3D8: Direct3D 8 can now work on systems that have Direct3D 8 installed</li>\n          <li>INPUT: show friendly names when available under input binds and system information</li>\n          <li>INPUT: show the config name when available under system information</li>\n          <li>GUI: Allow changing menu font color</li>\n          <li>GUI: Menu visibility options for RGUI and MaterialUI</li>\n          <li>GUI/MaterialUI: Works now with D3D8, D3D9 Cg, D3D11 and D3D12 drivers</li>\n          <li>GUI/XMB: Add Monochrome Inverted icon theme</li>\n          <li>GUI/XMB: Allow changing menu scale to 200%</li>\n          <li>GUI/XMB: Works now with D3D8, D3D9 Cg, D3D11 and D3D12 drivers. Menu shader effects currently don't work on D3D8/D3D9 Cg</li>\n          <li>KEYMAPPER: prevent a condition that caused input_menu_toggle to stop working when a RETRO_DEVICE_KEYBOARD type device is enabled</li>\n          <li>GL: ignore hard gpu sync when fast-forwarding</li>\n          <li>LOCALIZATION: Update Italian translation</li>\n          <li>LOCALIZATION: Update Japanese translation</li>\n          <li>LOCALIZATION: Update Portuguese-Brazilian translation</li>\n          <li>LOCALIZATION: Update Spanish translation</li>\n          <li>NETPLAY: Add menu option to select different MITM (relay) server locations</li>\n          <li>SHADERS: Allow saving of shader presets based on the parent directory</li>\n          <li>SHADERS: Don't save the path to the current preset to the main config</li>\n          <li>SHADERS: SPIRV-Cross/slang shader support for D3D11</li>\n          <li>SUBSYSTEM: Subsystem saves now respect the save directory</li>\n          <li>SUBSYSTEM: You can now load subsystem games from the menu</li>\n          <li>VULKAN: Fix swapchain recreation bug on Nvidia GPUs with Windows 10 (resolved in Windows Nvidia driver version 390.77)</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.7.0\" date=\"2017-12-25\">\n      <description>\n        <ul>\n          <li>CHEEVOS: Add badges for achievements, shows thumbnail images of achievements</li>\n          <li>CHEEVOS: Leaderboard support</li>\n          <li>CHEEVOS: Only disable savestates on hardcore mode if achievements are not available</li>\n          <li>COMMANDLINE: Fix fullscreen toggle switch</li>\n          <li>COMMON: Add 'Automatically Load Content To Playlist' feature, enabled by default</li>\n          <li>COMMON: Fix slowmotion ratio always being reset back to 1</li>\n          <li>COMMON: Optimized NBIO implementations now for Apple, Windows, and Linux. Uses mmap for Linux/Windows/BSD if/when available. File I/O should now be much faster for loading images inside the menu</li>\n          <li>COMMON: Native Blissbox support now for latest firmware as of writing (2.0). Implementation through libusb and/or native Windows HID</li>\n          <li>COMMON: New lightgun API</li>\n          <li>COMMON: New VFS (Virtual File System) API</li>\n          <li>COMMON: Fixed some playlist bugs</li>\n          <li>COMMON: New snow shader</li>\n          <li>COMMON: Fix Quick Menu title, no longer shows 'Select File'</li>\n          <li>COMMON: Fix loading cores that require no content one after another</li>\n          <li>COMMON: Map Delete key to Y button for non-unified menu keyboard controls</li>\n          <li>COMMON: Fix for relative paths being normalised and generating a duplicate history entry</li>\n          <li>INPUT: Map clear button to DEL key</li>\n          <li>LINUX/X11: Add RetroArch logo to window title bar</li>\n          <li>LINUX/X11: Input driver now supports new lightgun code</li>\n          <li>LINUX/X11: Support window transparency (requires a compositing window manager)</li>\n          <li>LOBBIES: Fix for crash on join netplay rooms via touch / glui</li>\n          <li>LOCALIZATION: Update Italian translation</li>\n          <li>LOCALIZATION: Update Japanese translation</li>\n          <li>LOCALIZATION: Update Portuguese-Brazilian translation</li>\n          <li>LOCALIZATION: Update Polish translation</li>\n          <li>LOCALIZATION: Update Russian translation</li>\n          <li>MENU: Snowflake menu shader effect</li>\n          <li>SCANNER: Fix crash from Windows-incompatible format string</li>\n          <li>VULKAN: Various stability fixes for WSI</li>\n        </ul>\n      </description>\n    </release>\n    <release version=\"1.6.9\" date=\"2017-11-21\">\n      <description>\n        <ul>\n          <li>COMMON: Small memory leak</li>\n          <li>NETPLAY: Fix network command only working once</li>\n        </ul>\n      </description>\n    </release>\n  </releases>\n</component>\n"
        },
        {
          "name": "command.c",
          "type": "blob",
          "size": 66.1376953125,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2021      - David G.F.\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <locale.h>\n#ifdef HAVE_NETWORKING\n#include <net/net_compat.h>\n#include <net/net_socket.h>\n#endif\n#include <lists/dir_list.h>\n#include <file/file_path.h>\n#include <streams/stdin_stream.h>\n#include <streams/file_stream.h>\n#include <string/stdstring.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef HAVE_CHEEVOS\n#include \"cheevos/cheevos.h\"\n#endif\n\n#ifdef HAVE_GFX_WIDGETS\n#include \"gfx/gfx_widgets.h\"\n#endif\n\n#ifdef HAVE_MENU\n#include \"menu/menu_driver.h\"\n#endif\n\n#ifdef HAVE_NETWORKING\n#include \"network/netplay/netplay.h\"\n#endif\n\n#include \"audio/audio_driver.h\"\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n#include \"gfx/video_shader_parse.h\"\n#endif\n#include \"autosave.h\"\n#include \"command.h\"\n#include \"core_info.h\"\n#include \"cheat_manager.h\"\n#include \"content.h\"\n#include \"dynamic.h\"\n#include \"list_special.h\"\n#include \"paths.h\"\n#include \"retroarch.h\"\n#include \"runloop.h\"\n#include \"verbosity.h\"\n#include \"version.h\"\n#include \"version_git.h\"\n\n#define CMD_BUF_SIZE           4096\n\nstatic void command_post_state_loaded(void)\n{\n#ifdef HAVE_CHEEVOS\n   if (rcheevos_hardcore_active())\n   {\n      const char *_msg = msg_hash_to_str(MSG_CHEEVOS_HARDCORE_MODE_DISABLED);\n      rcheevos_pause_hardcore();\n      runloop_msg_queue_push(_msg, strlen(_msg), 0, 180, true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n   }\n#endif\n#ifdef HAVE_NETWORKING\n   netplay_driver_ctl(RARCH_NETPLAY_CTL_LOAD_SAVESTATE, NULL);\n#endif\n   {\n     settings_t *settings        = config_get_ptr();\n     video_driver_state_t *video_st                 =\n       video_state_get_ptr();\n     bool frame_time_counter_reset_after_load_state =\n       settings->bools.frame_time_counter_reset_after_load_state;\n     if (frame_time_counter_reset_after_load_state)\n        video_st->frame_time_count = 0;\n   }\n}\n\n#if defined(HAVE_COMMAND)\n\n/* Generic command parse utilities */\n\nstatic bool command_get_arg(const char *tok,\n      const char **arg, unsigned *index)\n{\n   unsigned i;\n\n   for (i = 0; i < ARRAY_SIZE(map); i++)\n   {\n      if (string_is_equal(tok, map[i].str))\n      {\n         if (arg)\n            *arg = NULL;\n\n         if (index)\n            *index = i;\n\n         return true;\n      }\n   }\n\n   for (i = 0; i < ARRAY_SIZE(action_map); i++)\n   {\n      const char *str = strstr(tok, action_map[i].str);\n      if (str == tok)\n      {\n         const char *argument = str + strlen(action_map[i].str);\n         if (!argument)\n            return false;\n         if (*argument != ' ' && *argument != '\\0')\n            return false;\n\n         if (arg)\n            *arg = argument + 1;\n\n         if (index)\n            *index = i;\n\n         return true;\n      }\n   }\n\n   return false;\n}\n\nstatic void command_parse_sub_msg(command_t *handle, const char *tok)\n{\n   const char *arg = NULL;\n   unsigned index  = 0;\n\n   if (command_get_arg(tok, &arg, &index))\n   {\n      if (arg)\n      {\n         if (!action_map[index].action(handle, arg))\n            RARCH_ERR(\"Command \\\"%s\\\" failed.\\n\", arg);\n      }\n      else\n         handle->state[map[index].id] = true;\n   }\n   else\n      RARCH_WARN(msg_hash_to_str(MSG_UNRECOGNIZED_COMMAND), tok);\n}\n\nstatic void command_parse_msg(\n      command_t *handle, char *buf)\n{\n   char     *save  = NULL;\n   const char *tok = strtok_r(buf, \"\\n\", &save);\n\n   while (tok)\n   {\n      command_parse_sub_msg(handle, tok);\n      tok = strtok_r(NULL, \"\\n\", &save);\n   }\n}\n\n#if defined(HAVE_NETWORK_CMD)\ntypedef struct\n{\n   /* Network socket FD */\n   int net_fd;\n   /* Source address for the command received */\n   struct sockaddr_storage cmd_source;\n   /* Size of the previous structure in use */\n   socklen_t cmd_source_len;\n} command_network_t;\n\nstatic void network_command_reply(\n      command_t *cmd,\n      const char * data, size_t len)\n{\n   command_network_t *netcmd = (command_network_t*)cmd->userptr;\n   /* Respond (fire and forget since it's UDP) */\n   sendto(netcmd->net_fd, data, len, 0,\n      (struct sockaddr*)&netcmd->cmd_source, netcmd->cmd_source_len);\n}\n\nstatic void network_command_free(command_t *handle)\n{\n   command_network_t *netcmd = (command_network_t*)handle->userptr;\n\n   if (netcmd->net_fd >= 0)\n      socket_close(netcmd->net_fd);\n\n   free(netcmd);\n   free(handle);\n}\n\nstatic void command_network_poll(command_t *handle)\n{\n   ssize_t ret;\n   char buf[2048];\n   command_network_t *netcmd = (command_network_t*)handle->userptr;\n\n   if (netcmd->net_fd < 0)\n      return;\n\n   for (;;)\n   {\n      netcmd->cmd_source_len = sizeof(netcmd->cmd_source);\n\n      if ((ret = recvfrom(netcmd->net_fd, buf, sizeof(buf) - 1, 0,\n                  (struct sockaddr*)&netcmd->cmd_source,\n                  &netcmd->cmd_source_len)) <= 0)\n         return;\n\n      buf[ret] = '\\0';\n\n      command_parse_msg(handle, buf);\n   }\n}\n\ncommand_t* command_network_new(uint16_t port)\n{\n   struct addrinfo     *res  = NULL;\n   command_t            *cmd = (command_t*)calloc(1, sizeof(*cmd));\n   command_network_t *netcmd = (command_network_t*)calloc(\n                                   1, sizeof(command_network_t));\n   int fd                    = socket_init(\n         (void**)&res, port, NULL, SOCKET_TYPE_DATAGRAM, AF_INET);\n\n   RARCH_LOG(\"[NetCMD]: %s %hu.\\n\",\n         msg_hash_to_str(MSG_BRINGING_UP_COMMAND_INTERFACE_ON_PORT),\n         (unsigned short)port);\n\n   if (fd < 0)\n      goto error;\n\n   netcmd->net_fd = fd;\n   cmd->userptr   = netcmd;\n   cmd->poll      = command_network_poll;\n   cmd->replier   = network_command_reply;\n   cmd->destroy   = network_command_free;\n\n   if (!socket_nonblock(netcmd->net_fd))\n      goto error;\n\n   if (!socket_bind(netcmd->net_fd, (void*)res))\n   {\n      RARCH_ERR(\"[NetCMD]: %s.\\n\",\n            msg_hash_to_str(MSG_FAILED_TO_BIND_SOCKET));\n      goto error;\n   }\n\n   freeaddrinfo_retro(res);\n   return cmd;\n\nerror:\n   if (res)\n      freeaddrinfo_retro(res);\n   free(netcmd);\n   free(cmd);\n   return NULL;\n}\n#endif\n\n#if defined(HAVE_STDIN_CMD)\ntypedef struct\n{\n   /* Buffer and pointer for stdin reads */\n   size_t stdin_buf_ptr;\n   char stdin_buf[CMD_BUF_SIZE];\n} command_stdin_t;\n\nstatic void stdin_command_reply(\n      command_t *cmd,\n      const char * data, size_t len)\n{\n   /* Just write to stdout! */\n   fwrite(data, 1, len, stdout);\n   fflush(stdout);\n}\n\nstatic void stdin_command_free(command_t *handle)\n{\n   free(handle->userptr);\n   free(handle);\n}\n\nstatic void command_stdin_poll(command_t *handle)\n{\n   ptrdiff_t msg_len;\n   char        *last_newline = NULL;\n   command_stdin_t *stdincmd = (command_stdin_t*)handle->userptr;\n   ssize_t               ret = read_stdin(\n         stdincmd->stdin_buf + stdincmd->stdin_buf_ptr,\n         CMD_BUF_SIZE - stdincmd->stdin_buf_ptr - 1);\n\n   if (ret == 0)\n      return;\n\n   stdincmd->stdin_buf_ptr                      += ret;\n   stdincmd->stdin_buf[stdincmd->stdin_buf_ptr]  = '\\0';\n\n   last_newline = strrchr(stdincmd->stdin_buf, '\\n');\n\n   if (!last_newline)\n   {\n      /* We're receiving bogus data in pipe\n       * (no terminating newline), flush out the buffer. */\n      if (stdincmd->stdin_buf_ptr + 1 >= CMD_BUF_SIZE)\n      {\n         stdincmd->stdin_buf_ptr = 0;\n         stdincmd->stdin_buf[0]  = '\\0';\n      }\n\n      return;\n   }\n\n   *last_newline++ = '\\0';\n   msg_len         = last_newline - stdincmd->stdin_buf;\n\n   command_parse_msg(handle, stdincmd->stdin_buf);\n\n   memmove(stdincmd->stdin_buf, last_newline,\n         stdincmd->stdin_buf_ptr - msg_len);\n   stdincmd->stdin_buf_ptr -= msg_len;\n}\n\ncommand_t* command_stdin_new(void)\n{\n   command_t *cmd;\n   command_stdin_t *stdincmd;\n\n#ifndef _WIN32\n#ifdef HAVE_NETWORKING\n   if (!socket_nonblock(STDIN_FILENO))\n      return NULL;\n#endif\n#endif\n\n   cmd          = (command_t*)calloc(1, sizeof(command_t));\n   stdincmd     = (command_stdin_t*)calloc(1, sizeof(command_stdin_t));\n\n   if (!cmd)\n      return NULL;\n   if (!stdincmd)\n   {\n      free(cmd);\n      return NULL;\n   }\n   cmd->userptr = stdincmd;\n   cmd->poll    = command_stdin_poll;\n   cmd->replier = stdin_command_reply;\n   cmd->destroy = stdin_command_free;\n\n   return cmd;\n}\n#endif\n\nbool command_get_config_param(command_t *cmd, const char* arg)\n{\n   size_t _len;\n   char reply[8192];\n   #ifdef HAVE_BSV_MOVIE\n   char value_dynamic[256];\n   #endif\n   const char *value              = \"unsupported\";\n   settings_t *settings           = config_get_ptr();\n   bool       video_fullscreen    = settings->bools.video_fullscreen;\n   const char *dir_runtime_log    = settings->paths.directory_runtime_log;\n   const char *log_dir            = settings->paths.log_dir;\n   const char *directory_cache    = settings->paths.directory_cache;\n   const char *directory_system   = settings->paths.directory_system;\n   const char *path_username      = settings->paths.username;\n\n   if (string_is_equal(arg, \"video_fullscreen\"))\n   {\n      if (video_fullscreen)\n         value = \"true\";\n      else\n         value = \"false\";\n   }\n   else if (string_is_equal(arg, \"savefile_directory\"))\n      value = dir_get_ptr(RARCH_DIR_SAVEFILE);\n   else if (string_is_equal(arg, \"savestate_directory\"))\n      value = dir_get_ptr(RARCH_DIR_SAVESTATE);\n   else if (string_is_equal(arg, \"runtime_log_directory\"))\n      value = dir_runtime_log;\n   else if (string_is_equal(arg, \"log_dir\"))\n      value = log_dir;\n   else if (string_is_equal(arg, \"cache_directory\"))\n      value = directory_cache;\n   else if (string_is_equal(arg, \"system_directory\"))\n      value = directory_system;\n   else if (string_is_equal(arg, \"netplay_nickname\"))\n      value = path_username;\n#ifdef HAVE_BSV_MOVIE\n   else if (string_is_equal(arg, \"active_replay\"))\n   {\n      input_driver_state_t *input_st = input_state_get_ptr();\n      value            = value_dynamic;\n      value_dynamic[0] = '\\0';\n      if (input_st->bsv_movie_state_handle)\n      {\n         bsv_movie_t *movie = input_st->bsv_movie_state_handle;\n         snprintf(value_dynamic, sizeof(value_dynamic), \"%lld %u %lld\",\n               (long long)(movie->identifier),\n                  input_st->bsv_movie_state.flags,\n                  (long long)(movie->frame_counter));\n      }\n      else\n         strlcpy(value_dynamic, \"0 0 0\", sizeof(value_dynamic));\n   }\n   #endif\n   /* TODO: query any string */\n\n   _len  = strlcpy(reply, \"GET_CONFIG_PARAM \", sizeof(reply));\n   _len += strlcpy(reply + _len, arg, sizeof(reply)  - _len);\n   reply[  _len] = ' ';\n   reply[++_len] = '\\0';\n   _len += strlcpy(reply + _len, value, sizeof(reply) - _len);\n   cmd->replier(cmd, reply, _len);\n   return true;\n}\n\n#if defined(HAVE_LAKKA)\n#include <sys/un.h>\n#define MAX_USER_CONNECTIONS  4\ntypedef struct\n{\n   /* File descriptor for the domain socket */\n   int sfd;\n   /* Client sockets */\n   int userfd[MAX_USER_CONNECTIONS];\n   /* Last received user socket */\n   int last_fd;\n} command_uds_t;\n\nstatic void uds_command_reply(\n      command_t *cmd,\n      const char * data, size_t len)\n{\n   command_uds_t *subcmd = (command_uds_t*)cmd->userptr;\n   write(subcmd->last_fd, data, len);\n}\n\nstatic void uds_command_free(command_t *handle)\n{\n   int i;\n   command_uds_t *udscmd = (command_uds_t*)handle->userptr;\n\n   for (i = 0; i < MAX_USER_CONNECTIONS; i++)\n      if (udscmd->userfd[i] >= 0)\n         socket_close(udscmd->userfd[i]);\n   socket_close(udscmd->sfd);\n\n   free(handle->userptr);\n   free(handle);\n}\n\nstatic void command_uds_poll(command_t *handle)\n{\n   int i;\n   int fd;\n   ssize_t ret;\n   char buf[2048];\n   command_uds_t *udscmd = (command_uds_t*)handle->userptr;\n\n   if (udscmd->sfd < 0)\n      return;\n\n   /* Read data from clients and process commands */\n   for (i = 0; i < MAX_USER_CONNECTIONS; i++)\n   {\n      bool err = false;\n\n      fd = udscmd->userfd[i];\n      if (fd < 0)\n         continue;\n\n      ret = socket_receive_all_nonblocking(fd, &err, buf, sizeof(buf) - 1);\n      if (!ret)\n         continue;\n\n      if (!err)\n      {\n         buf[ret]        = '\\0';\n         udscmd->last_fd = fd;\n\n         command_parse_msg(handle, buf);\n      }\n      else\n      {\n         socket_close(fd);\n         udscmd->userfd[i] = -1;\n      }\n   }\n\n   /* Accepts new connections from clients */\n   fd = accept(udscmd->sfd, NULL, NULL);\n   if (fd >= 0)\n   {\n      if (socket_nonblock(fd))\n      {\n         for (i = 0; i < MAX_USER_CONNECTIONS; i++)\n         {\n            if (udscmd->userfd[i] < 0)\n            {\n               udscmd->userfd[i] = fd;\n               return;\n            }\n         }\n      }\n\n      socket_close(fd);\n   }\n}\n\ncommand_t* command_uds_new(void)\n{\n   int i;\n   command_t *cmd;\n   command_uds_t *subcmd;\n   struct sockaddr_un addr;\n   socklen_t addrsz = offsetof(struct sockaddr_un, sun_path) + STRLEN_CONST(\"retroarch/cmd\") + 1;\n   int           fd = socket(AF_UNIX, SOCK_STREAM, 0);\n   if (fd < 0)\n      return NULL;\n\n   /* use an abstract socket for simplicity */\n   memset(&addr, 0, sizeof(addr));\n   addr.sun_family = AF_UNIX;\n   strcpy(&addr.sun_path[1], \"retroarch/cmd\");\n\n   if (bind(fd, (struct sockaddr*)&addr, addrsz) < 0 ||\n       listen(fd, MAX_USER_CONNECTIONS) < 0)\n   {\n      socket_close(fd);\n      return NULL;\n   }\n\n   if (!socket_nonblock(fd))\n   {\n      socket_close(fd);\n      return NULL;\n   }\n\n   cmd             = (command_t*)calloc(1, sizeof(command_t));\n   subcmd          = (command_uds_t*)calloc(1, sizeof(command_uds_t));\n   subcmd->sfd     = fd;\n   subcmd->last_fd = -1;\n   for (i = 0; i < MAX_USER_CONNECTIONS; i++)\n      subcmd->userfd[i] = -1;\n\n   cmd->userptr = subcmd;\n   cmd->poll    = command_uds_poll;\n   cmd->replier = uds_command_reply;\n   cmd->destroy = uds_command_free;\n\n   return cmd;\n}\n#endif\n\n\n/* Routines used to invoke retroarch command ... */\n\n#ifdef HAVE_NETWORK_CMD\nstatic bool command_verify(const char *cmd)\n{\n   unsigned i;\n\n   if (command_get_arg(cmd, NULL, NULL))\n      return true;\n\n   RARCH_ERR(\"[NetCMD]: Command \\\"%s\\\" is not recognized by the program.\\n\", cmd);\n   RARCH_ERR(\"[NetCMD]: \\tValid commands:\\n\");\n   for (i = 0; i < ARRAY_SIZE(map); i++)\n      RARCH_ERR(\"\\t\\t%s\\n\", map[i].str);\n\n   for (i = 0; i < ARRAY_SIZE(action_map); i++)\n      RARCH_ERR(\"\\t\\t%s %s\\n\", action_map[i].str, action_map[i].arg_desc);\n\n   return false;\n}\n\nstatic bool udp_send_packet(const char *host, uint16_t port, const char *msg)\n{\n   char port_buf[6];\n   const struct addrinfo *tmp_info;\n   struct addrinfo *addr = NULL;\n   struct addrinfo hints = {0};\n   size_t          len   = strlen(msg);\n   bool            ret   = false;\n\n   snprintf(port_buf, sizeof(port_buf), \"%hu\", (unsigned short)port);\n\n   hints.ai_socktype = SOCK_DGRAM;\n   hints.ai_flags    = AI_NUMERICSERV;\n\n   if (getaddrinfo_retro(host, port_buf, &hints, &addr))\n      return false;\n   if (!addr)\n      return false;\n\n   /* Send to all possible targets. */\n   tmp_info = addr;\n\n   do\n   {\n      int fd = socket(tmp_info->ai_family,\n         tmp_info->ai_socktype, tmp_info->ai_protocol);\n\n      if (fd < 0)\n         continue;\n\n      if (sendto(fd, msg, len, 0, tmp_info->ai_addr, tmp_info->ai_addrlen) ==\n            (ssize_t)len)\n         ret = true;\n\n      socket_close(fd);\n   } while ((tmp_info = tmp_info->ai_next));\n\n   freeaddrinfo_retro(addr);\n\n   return ret;\n}\n\nbool command_network_send(const char *cmd_)\n{\n   char *command        = NULL;\n   char *save           = NULL;\n   const char *cmd      = NULL;\n\n   if (!network_init())\n      return false;\n\n   if (!(command = strdup(cmd_)))\n      return false;\n\n   cmd                  = strtok_r(command, \";\", &save);\n   if (cmd)\n   {\n      uint16_t port     = DEFAULT_NETWORK_CMD_PORT;\n      const char *port_ = NULL;\n      const char *host  = strtok_r(NULL, \";\", &save);\n      if (host)\n         port_          = strtok_r(NULL, \";\", &save);\n      else\n      {\n#ifdef _WIN32\n         host = \"127.0.0.1\";\n#else\n         host = \"localhost\";\n#endif\n      }\n\n      if (port_)\n         port = strtoul(port_, NULL, 0);\n\n      RARCH_LOG(\"[NetCMD]: %s: \\\"%s\\\" to %s:%hu\\n\",\n            msg_hash_to_str(MSG_SENDING_COMMAND),\n            cmd, host, (unsigned short)port);\n\n      if (command_verify(cmd) && udp_send_packet(host, port, cmd))\n      {\n         free(command);\n         return true;\n      }\n   }\n\n   free(command);\n   return false;\n}\n#endif\n\nbool command_show_osd_msg(command_t *cmd, const char* arg)\n{\n    runloop_msg_queue_push(arg, strlen(arg), 1, 180, false, NULL,\n          MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n    return true;\n}\n\n\nbool command_load_state_slot(command_t *cmd, const char *arg)\n{\n   char state_path[16384];\n   size_t _len                  = 0;\n   char reply[128]              = \"\";\n   unsigned int slot            = (unsigned int)strtoul(arg, NULL, 10);\n   bool savestates_enabled      = core_info_current_supports_savestate();\n   bool ret                     = false;\n   state_path[0]                = '\\0';\n   _len  = strlcpy(reply, \"LOAD_STATE_SLOT \", sizeof(reply));\n   _len += snprintf(reply + _len, sizeof(reply) - _len, \"%d\", slot);\n   if (savestates_enabled)\n   {\n      size_t info_size;\n      runloop_get_savestate_path(state_path, sizeof(state_path), slot);\n\n      info_size          = core_serialize_size();\n      savestates_enabled = (info_size > 0);\n   }\n   if (savestates_enabled)\n   {\n      if ((ret = content_load_state(state_path, false, false)))\n         command_post_state_loaded();\n   }\n   else\n      ret = false;\n\n   cmd->replier(cmd, reply, _len);\n   return ret;\n}\n\nbool command_play_replay_slot(command_t *cmd, const char *arg)\n{\n#ifdef HAVE_BSV_MOVIE\n   char replay_path[16384];\n   char reply[128]              = \"\";\n   unsigned int slot            = (unsigned int)strtoul(arg, NULL, 10);\n   bool savestates_enabled      = core_info_current_supports_savestate();\n   bool ret                     = false;\n   replay_path[0]               = '\\0';\n   if (savestates_enabled)\n   {\n      size_t info_size;\n      runloop_get_replay_path(replay_path, sizeof(replay_path), slot);\n\n      info_size          = core_serialize_size();\n      savestates_enabled = (info_size > 0);\n   }\n   if (savestates_enabled)\n   {\n      ret = movie_start_playback(input_state_get_ptr(), replay_path);\n      if (ret)\n      {\n         input_driver_state_t *input_st = input_state_get_ptr();\n         task_queue_wait(NULL, NULL);\n         if (input_st->bsv_movie_state_next_handle)\n            snprintf(reply, sizeof(reply) - 1, \"PLAY_REPLAY_SLOT %lld\", (long long)(input_st->bsv_movie_state_next_handle->identifier));\n         else\n            snprintf(reply, sizeof(reply) - 1, \"PLAY_REPLAY_SLOT 0\");\n         command_post_state_loaded();\n      }\n   }\n   else\n      ret = false;\n\n   cmd->replier(cmd, reply, strlen(reply));\n   return ret;\n#else\n   return false;\n#endif\n}\n\n\n#if defined(HAVE_CHEEVOS)\nbool command_read_ram(command_t *cmd, const char *arg)\n{\n   unsigned i;\n   char *reply                  = NULL;\n   const uint8_t  *data         = NULL;\n   char *reply_at               = NULL;\n   unsigned int nbytes          = 0;\n   unsigned int alloc_size      = 0;\n   unsigned int addr            = -1;\n   size_t _len                  = 0;\n\n   if (sscanf(arg, \"%x %u\", &addr, &nbytes) != 2)\n      return true;\n   /* We allocate more than needed, saving 20 bytes is not really relevant */\n   alloc_size              = 40 + nbytes * 3;\n   reply                   = (char*)malloc(alloc_size);\n   reply[0]                = '\\0';\n   reply_at                = reply + snprintf(\n         reply, alloc_size - 1, \"READ_CORE_RAM\" \" %x\", addr);\n\n   if ((data = rcheevos_patch_address(addr)))\n   {\n      for (i = 0; i < nbytes; i++)\n         snprintf(reply_at + 3 * i, 4, \" %.2X\", data[i]);\n      reply_at[3 * nbytes] = '\\n';\n      _len                 = reply_at + 3 * nbytes + 1 - reply;\n   }\n   else\n   {\n      strlcpy(reply_at, \" -1\\n\", sizeof(reply) - strlen(reply));\n      _len                  = reply_at + STRLEN_CONST(\" -1\\n\") - reply;\n   }\n   cmd->replier(cmd, reply, _len);\n   free(reply);\n   return true;\n}\n\nbool command_write_ram(command_t *cmd, const char *arg)\n{\n   unsigned int addr    = (unsigned int)strtoul(arg, (char**)&arg, 16);\n   uint8_t *data        = (uint8_t *)rcheevos_patch_address(addr);\n\n   if (!data)\n      return false;\n\n   if (rcheevos_hardcore_active())\n   {\n      RARCH_LOG(\"[Command]: Achievements hardcore mode disabled by WRITE_CORE_RAM.\\n\");\n      rcheevos_pause_hardcore();\n   }\n\n   while (*arg)\n   {\n      *data = strtoul(arg, (char**)&arg, 16);\n      data++;\n   }\n   return true;\n}\n#endif\n\nbool command_version(command_t *cmd, const char* arg)\n{\n   char reply[256];\n   size_t  _len  = strlcpy(reply, PACKAGE_VERSION, sizeof(reply));\n   reply[  _len] = '\\n';\n   reply[++_len] = '\\0';\n   cmd->replier(cmd, reply, _len);\n   return true;\n}\n\nstatic const rarch_memory_descriptor_t* command_memory_get_descriptor(const rarch_memory_map_t* mmap, unsigned address, size_t* offset)\n{\n   const rarch_memory_descriptor_t* desc = mmap->descriptors;\n   const rarch_memory_descriptor_t* end  = desc + mmap->num_descriptors;\n\n   for (; desc < end; desc++)\n   {\n      if (desc->core.select == 0)\n      {\n         /* if select is 0, attempt to explicitly match the address */\n         if (address >= desc->core.start && address < desc->core.start + desc->core.len)\n         {\n            *offset = address - desc->core.start;\n            return desc;\n         }\n      }\n      else\n      {\n         /* otherwise, attempt to match the address by matching the select bits */\n         if (((desc->core.start ^ address) & desc->core.select) == 0)\n         {\n            /* adjust the address to the start of the descriptor */\n            unsigned desc_offset = address - (unsigned)desc->core.start;\n\n            /* address is unsigned. we only need that much of the disconnect mask */\n            unsigned mask = (unsigned)desc->core.disconnect;\n\n            /* this magic logic is copied from mmap_reduce. it removes any bits from\n             * address that are non-zero in the disconnect field. bits above the\n             * removed bits are shifted down to fill the gap. */\n            while (mask)\n            {\n               const unsigned tmp = (mask - 1) & ~mask;\n               desc_offset = (desc_offset & tmp) | ((desc_offset >> 1) & ~tmp);\n               mask        = (mask & (mask - 1)) >> 1;\n            }\n\n            /* we've calculated the actual offset of the data within the descriptor */\n            *offset = desc_offset;\n\n            /* sanity check - make sure the descriptor is large enough to hold the target address */\n            if (desc_offset < desc->core.len)\n               return desc;\n         }\n      }\n   }\n\n   return NULL;\n}\n\nstatic uint8_t *command_memory_get_pointer(\n      const rarch_system_info_t* sys_info,\n      unsigned address, unsigned int* max_bytes,\n      int for_write, char *s, size_t len)\n{\n   if (!sys_info || sys_info->mmaps.num_descriptors == 0)\n      strlcpy(s, \" -1 no memory map defined\\n\", len);\n   else\n   {\n      size_t offset;\n      const rarch_memory_descriptor_t* desc = command_memory_get_descriptor(&sys_info->mmaps, address, &offset);\n      if (!desc)\n         strlcpy(s, \" -1 no descriptor for address\\n\", len);\n      else if (!desc->core.ptr)\n         strlcpy(s, \" -1 no data for descriptor\\n\", len);\n      else if (for_write && (desc->core.flags & RETRO_MEMDESC_CONST))\n         strlcpy(s, \" -1 descriptor data is readonly\\n\", len);\n      else\n      {\n         *max_bytes = (unsigned int)(desc->core.len - offset);\n         return (uint8_t*)desc->core.ptr + desc->core.offset + offset;\n      }\n   }\n\n   *max_bytes = 0;\n   return NULL;\n}\n\nbool command_get_status(command_t *cmd, const char* arg)\n{\n   size_t _len;\n   char reply[4096];\n   uint8_t flags                  = content_get_flags();\n\n   if (flags & CONTENT_ST_FLAG_IS_INITED)\n   {\n      /* add some content info */\n      core_info_t *core_info      = NULL;\n      runloop_state_t *runloop_st = runloop_state_get_ptr();\n\n      core_info_get_current_core(&core_info);\n\n      _len     = strlcpy(reply, \"GET_STATUS \", sizeof(reply));\n      if (runloop_st->flags & RUNLOOP_FLAG_PAUSED)\n         _len += strlcpy(reply + _len, \"PAUSED\", sizeof(reply) - _len);\n      else\n         _len += strlcpy(reply + _len, \"PLAYING\", sizeof(reply) - _len);\n      _len    += strlcpy(reply + _len, \" \", sizeof(reply) - _len);\n      if (core_info)\n         _len += strlcpy(reply + _len, core_info->system_id,\n               sizeof(reply) - _len);\n      else\n         _len += strlcpy(reply + _len, runloop_st->system.info.library_name,\n               sizeof(reply) - _len);\n      _len    += strlcpy(reply + _len, \",\", sizeof(reply) - _len);\n      _len    += strlcpy(reply + _len,\n            path_basename(path_get(RARCH_PATH_BASENAME)), sizeof(reply) - _len);\n      _len    += snprintf(reply + _len, sizeof(reply) - _len,\n            \",crc32=%x\\n\", content_get_crc());\n   }\n   else\n       _len = strlcpy(reply, \"GET_STATUS CONTENTLESS\", sizeof(reply));\n\n   cmd->replier(cmd, reply, _len);\n\n   return true;\n}\n\nbool command_read_memory(command_t *cmd, const char *arg)\n{\n   unsigned i;\n   char* reply                        = NULL;\n   char* reply_at                     = NULL;\n   const uint8_t* data                = NULL;\n   unsigned int nbytes                = 0;\n   unsigned int alloc_size            = 0;\n   unsigned int address               = -1;\n   size_t _len                        = 0;\n   unsigned int max_bytes             = 0;\n   runloop_state_t *runloop_st        = runloop_state_get_ptr();\n   const rarch_system_info_t* sys_info= &runloop_st->system;\n\n   if (sscanf(arg, \"%x %u\", &address, &nbytes) != 2)\n      return false;\n\n   /* Ensure large enough to return all requested bytes or an error message */\n   alloc_size = 64 + nbytes * 3;\n   reply      = (char*)malloc(alloc_size);\n   reply_at   = reply + snprintf(reply, alloc_size - 1, \"READ_CORE_MEMORY %x\", address);\n\n   if ((data = command_memory_get_pointer(\n               sys_info, address, &max_bytes,\n               0, reply_at, alloc_size - strlen(reply))))\n   {\n      if (nbytes > max_bytes)\n          nbytes = max_bytes;\n\n      for (i = 0; i < nbytes; i++)\n         snprintf(reply_at + 3 * i, 4, \" %02X\", data[i]);\n\n      reply_at[3 * nbytes] = '\\n';\n      _len                 = reply_at + 3 * nbytes + 1 - reply;\n   }\n   else\n      _len                 = strlen(reply);\n\n   cmd->replier(cmd, reply, _len);\n   free(reply);\n   return true;\n}\n\nbool command_write_memory(command_t *cmd, const char *arg)\n{\n   unsigned int address         = (unsigned int)strtoul(arg, (char**)&arg, 16);\n   unsigned int max_bytes       = 0;\n   char reply[128]              = \"\";\n   runloop_state_t *runloop_st  = runloop_state_get_ptr();\n   const rarch_system_info_t\n      *sys_info                 = &runloop_st->system;\n   char *reply_at               = reply + snprintf(reply, sizeof(reply) - 1, \"WRITE_CORE_MEMORY %x\", address);\n   uint8_t *data                = command_memory_get_pointer(sys_info, address, &max_bytes, 1, reply_at, sizeof(reply) - strlen(reply) - 1);\n\n   if (data)\n   {\n      uint8_t* start = data;\n      while (*arg && max_bytes > 0)\n      {\n         --max_bytes;\n         *data = strtoul(arg, (char**)&arg, 16);\n         data++;\n      }\n\n      snprintf(reply_at, sizeof(reply) - strlen(reply) - 1,\n            \" %u\\n\", (unsigned)(data - start));\n\n#ifdef HAVE_CHEEVOS\n      if (rcheevos_hardcore_active())\n      {\n         RARCH_LOG(\"[Command]: Achievements hardcore mode disabled by WRITE_CORE_MEMORY.\\n\");\n         rcheevos_pause_hardcore();\n      }\n#endif\n   }\n\n   cmd->replier(cmd, reply, strlen(reply));\n   return true;\n}\n#endif\n\nvoid command_event_set_volume(\n      settings_t *settings,\n      float gain,\n      bool widgets_active,\n      bool audio_driver_mute_enable)\n{\n   size_t _len;\n   char msg[128];\n   float new_volume = settings->floats.audio_volume + gain;\n   new_volume       = MAX(new_volume, -80.0f);\n   new_volume       = MIN(new_volume, 12.0f);\n   configuration_set_float(settings, settings->floats.audio_volume, new_volume);\n   _len             = strlcpy(msg, msg_hash_to_str(MSG_AUDIO_VOLUME),\n         sizeof(msg));\n   msg[_len  ]      = ':';\n   msg[++_len]      = ' ';\n   msg[++_len]      = '\\0';\n   _len            += snprintf(msg + _len, sizeof(msg) - _len, \"%.1f\",\n         new_volume);\n   msg[_len  ]      = ' ';\n   msg[++_len]      = 'd';\n   msg[++_len]      = 'B';\n   msg[++_len]      = '\\0';\n\n#if defined(HAVE_GFX_WIDGETS)\n   if (widgets_active)\n      gfx_widget_volume_update_and_show(new_volume,\n            audio_driver_mute_enable);\n   else\n#endif\n      runloop_msg_queue_push(msg, _len, 1, 180, true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n   RARCH_LOG(\"[Audio]: %s\\n\", msg);\n\n   audio_set_float(AUDIO_ACTION_VOLUME_GAIN, new_volume);\n}\n\n/**\n * event_set_mixer_volume:\n * @gain      : amount of gain to be applied to current volume level.\n *\n * Adjusts the current audio volume level.\n *\n **/\nvoid command_event_set_mixer_volume(\n      settings_t *settings,\n      float gain)\n{\n   size_t _len;\n   char msg[128];\n   float new_volume = settings->floats.audio_mixer_volume + gain;\n   new_volume       = MAX(new_volume, -80.0f);\n   new_volume       = MIN(new_volume, 12.0f);\n   configuration_set_float(settings, settings->floats.audio_mixer_volume, new_volume);\n   _len             = strlcpy(msg, msg_hash_to_str(MSG_AUDIO_VOLUME),\n         sizeof(msg));\n   msg[_len  ]      = ':';\n   msg[++_len]      = ' ';\n   msg[++_len]      = '\\0';\n   _len            += snprintf(msg + _len, sizeof(msg) - _len, \"%.1f\",\n         new_volume);\n   msg[_len  ]      = ' ';\n   msg[++_len]      = 'd';\n   msg[++_len]      = 'B';\n   msg[++_len]      = '\\0';\n   runloop_msg_queue_push(msg, _len, 1, 180, true, NULL,\n         MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n   RARCH_LOG(\"[Audio]: %s\\n\", msg);\n\n   audio_set_float(AUDIO_ACTION_VOLUME_GAIN, new_volume);\n}\n\nvoid command_event_init_controllers(rarch_system_info_t *sys_info,\n      settings_t *settings, unsigned num_active_users)\n{\n   unsigned port;\n   unsigned num_core_ports = sys_info->ports.size;\n\n   for (port = 0; port < num_core_ports; port++)\n   {\n      unsigned i;\n      retro_ctx_controller_info_t pad;\n      unsigned device                                 = RETRO_DEVICE_NONE;\n      const struct retro_controller_description *desc = NULL;\n\n      /* Check whether current core port is mapped\n       * to an input device\n       * > If is not, leave 'device' set to\n       *   'RETRO_DEVICE_NONE'\n       * > For example: if input ports 0 and 1 are\n       *   mapped to core port 0, core port 1 will\n       *   be unmapped and should be disabled */\n      for (i = 0; i < num_active_users; i++)\n      {\n         if (i >= MAX_USERS)\n            break;\n\n         if (port == settings->uints.input_remap_ports[i])\n         {\n            device = input_config_get_device(port);\n            break;\n         }\n      }\n\n      desc = libretro_find_controller_description(\n            &sys_info->ports.data[port], device);\n\n      if (desc && !desc->desc)\n      {\n         /* If we're trying to connect a completely unknown device,\n          * revert back to JOYPAD. */\n         if (device != RETRO_DEVICE_JOYPAD && device != RETRO_DEVICE_NONE)\n         {\n            /* Do not fix device,\n             * because any use of dummy core will reset this,\n             * which is not a good idea. */\n            RARCH_WARN(\"[Input]: Input device ID %u is unknown to this \"\n                  \"libretro implementation. Using RETRO_DEVICE_JOYPAD.\\n\",\n                  device);\n            device = RETRO_DEVICE_JOYPAD;\n         }\n      }\n\n      pad.device     = device;\n      pad.port       = port;\n      core_set_controller_port_device(&pad);\n   }\n}\n\n#ifdef HAVE_CONFIGFILE\nstatic size_t command_event_save_config(\n      const char *config_path, char *s, size_t len)\n{\n   size_t _len      = 0;\n   bool path_exists = !string_is_empty(config_path);\n   const char *str  = path_exists ? config_path :\n      path_get(RARCH_PATH_CONFIG);\n\n   /* Workaround for libdecor 0.2.0 setting unwanted locale */\n#if defined(HAVE_WAYLAND) && defined(HAVE_DYNAMIC)\n   setlocale(LC_NUMERIC,\"C\");\n#endif\n   if (path_exists && config_save_file(config_path))\n   {\n#if IOS\n      char tmp[PATH_MAX_LENGTH] = {0};\n      fill_pathname_abbreviate_special(tmp, config_path, sizeof(tmp));\n      _len = snprintf(s, len, \"%s \\\"%s\\\".\",\n            msg_hash_to_str(MSG_SAVED_NEW_CONFIG_TO),\n            tmp);\n#else\n      _len = snprintf(s, len, \"%s \\\"%s\\\".\",\n            msg_hash_to_str(MSG_SAVED_NEW_CONFIG_TO),\n            config_path);\n#endif\n      RARCH_LOG(\"[Config]: %s\\n\", s);\n      return _len;\n   }\n\n   if (!string_is_empty(str))\n   {\n      _len = snprintf(s, len, \"%s \\\"%s\\\".\",\n            msg_hash_to_str(MSG_FAILED_SAVING_CONFIG_TO),\n            str);\n      RARCH_ERR(\"[Config]: %s\\n\", s);\n   }\n\n   return _len;\n}\n#endif\n\nstatic size_t command_event_undo_save_state(char *s, size_t len)\n{\n   if (content_undo_save_buf_is_empty())\n      return strlcpy(s,\n         msg_hash_to_str(MSG_NO_SAVE_STATE_HAS_BEEN_OVERWRITTEN_YET), len);\n   if (!content_undo_save_state())\n      return strlcpy(s,\n         msg_hash_to_str(MSG_FAILED_TO_UNDO_SAVE_STATE), len);\n   return strlcpy(s,\n         msg_hash_to_str(MSG_UNDOING_SAVE_STATE), len);\n}\n\nstatic size_t command_event_undo_load_state(char *s, size_t len)\n{\n   if (content_undo_load_buf_is_empty())\n      return strlcpy(s,\n         msg_hash_to_str(MSG_NO_STATE_HAS_BEEN_LOADED_YET),\n         len);\n   if (!content_undo_load_state())\n      return snprintf(s, len, \"%s \\\"%s\\\".\",\n            msg_hash_to_str(MSG_FAILED_TO_UNDO_LOAD_STATE),\n            \"RAM\");\n#ifdef HAVE_NETWORKING\n   netplay_driver_ctl(RARCH_NETPLAY_CTL_LOAD_SAVESTATE, NULL);\n#endif\n   return strlcpy(s,\n         msg_hash_to_str(MSG_UNDID_LOAD_STATE), len);\n}\n\nbool command_event_resize_windowed_scale(settings_t *settings,\n      unsigned window_scale)\n{\n   unsigned                idx = 0;\n   bool      video_fullscreen  = settings->bools.video_fullscreen;\n\n   if (window_scale == 0)\n      return false;\n\n   configuration_set_uint(settings, settings->uints.video_scale, window_scale);\n\n   if (!video_fullscreen)\n      command_event(CMD_EVENT_REINIT, NULL);\n\n   retroarch_ctl(RARCH_CTL_SET_WINDOWED_SCALE, &idx);\n\n   return true;\n}\n\nbool command_event_save_auto_state(void)\n{\n   size_t _len;\n   runloop_state_t *runloop_st = runloop_state_get_ptr();\n   char savestate_name_auto[PATH_MAX_LENGTH];\n\n   if (runloop_st->entry_state_slot)\n      return false;\n   if (!core_info_current_supports_savestate())\n      return false;\n   if (string_is_empty(path_basename(path_get(RARCH_PATH_BASENAME))))\n      return false;\n\n   _len = strlcpy(savestate_name_auto,\n         runloop_st->name.savestate,\n         sizeof(savestate_name_auto));\n   strlcpy(savestate_name_auto + _len, \".auto\",\n         sizeof(savestate_name_auto) - _len);\n\n   if (content_auto_save_state((const char*)savestate_name_auto))\n\t   RARCH_LOG(\"[State]: %s \\\"%s\\\" %s.\\n\",\n\t\t\t   msg_hash_to_str(MSG_AUTO_SAVE_STATE_TO),\n\t\t\t   savestate_name_auto, \"succeeded\");\n   else\n\t   RARCH_LOG(\"[State]: %s \\\"%s\\\" %s.\\n\",\n\t\t\t   msg_hash_to_str(MSG_AUTO_SAVE_STATE_TO),\n\t\t\t   savestate_name_auto, \"failed\");\n\n   return true;\n}\n\n#ifdef HAVE_CHEATS\nvoid command_event_init_cheats(\n      bool apply_cheats_after_load,\n      const char *path_cheat_db,\n      void *bsv_movie_data)\n{\n#ifdef HAVE_NETWORKING\n   bool allow_cheats             = !netplay_driver_ctl(\n         RARCH_NETPLAY_CTL_IS_DATA_INITED, NULL);\n#else\n   bool allow_cheats             = true;\n#endif\n#ifdef HAVE_BSV_MOVIE\n   allow_cheats                 &= !(bsv_movie_data != NULL);\n#endif\n\n   if (!allow_cheats)\n      return;\n\n   cheat_manager_alloc_if_empty();\n   cheat_manager_load_game_specific_cheats(path_cheat_db);\n\n   if (apply_cheats_after_load)\n      cheat_manager_apply_cheats();\n}\n#endif\n\nbool command_event_load_entry_state(settings_t *settings)\n{\n   char entry_state_path[PATH_MAX_LENGTH];\n   int entry_path_stats;\n   runloop_state_t *runloop_st     = runloop_state_get_ptr();\n   bool ret                        = false;\n\n   if (!core_info_current_supports_savestate())\n      return false;\n\n#ifdef HAVE_CHEEVOS\n   if (rcheevos_hardcore_active())\n      return false;\n#endif\n#ifdef HAVE_NETWORKING\n   if (netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_ENABLED, NULL))\n      return false;\n#endif\n\n   entry_state_path[0] = '\\0';\n\n   if (!runloop_get_entry_state_path(\n            entry_state_path, sizeof(entry_state_path),\n            runloop_st->entry_state_slot))\n      return false;\n\n   entry_path_stats = path_stat(entry_state_path);\n\n   if ((entry_path_stats & RETRO_VFS_STAT_IS_VALID) == 0\n         || (entry_path_stats & RETRO_VFS_STAT_IS_DIRECTORY) != 0)\n      return false;\n\n   ret = content_load_state(entry_state_path, false, true);\n\n   RARCH_LOG(\"[State]: %s \\\"%s\\\".\\n\",\n         msg_hash_to_str(MSG_FOUND_ENTRY_STATE_IN),\n         entry_state_path);\n   RARCH_LOG(\"[State]: %s \\\"%s\\\" %s.\\n\",\n         msg_hash_to_str(MSG_LOADING_ENTRY_STATE_FROM),\n         entry_state_path, ret ? \"succeeded\" : \"failed\"\n         );\n\n   if (ret)\n      configuration_set_int(settings, settings->ints.state_slot, runloop_st->entry_state_slot);\n\n   return ret;\n}\n\nvoid command_event_load_auto_state(void)\n{\n   size_t _len;\n   char savestate_name_auto[PATH_MAX_LENGTH];\n   runloop_state_t *runloop_st     = runloop_state_get_ptr();\n\n   if (!core_info_current_supports_savestate())\n      return;\n\n#ifdef HAVE_CHEEVOS\n   if (rcheevos_hardcore_active())\n      return;\n#endif\n#ifdef HAVE_NETWORKING\n   if (netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_ENABLED, NULL))\n      return;\n#endif\n\n   _len = strlcpy(savestate_name_auto,\n         runloop_st->name.savestate,\n         sizeof(savestate_name_auto));\n   strlcpy(savestate_name_auto + _len, \".auto\",\n         sizeof(savestate_name_auto) - _len);\n\n   if (!path_is_valid(savestate_name_auto))\n      return;\n\n   RARCH_LOG(\"[State]: %s \\\"%s\\\".\\n\",\n         msg_hash_to_str(MSG_FOUND_AUTO_SAVESTATE_IN),\n         savestate_name_auto);\n\n   if ((content_load_state(savestate_name_auto, false, true)))\n      RARCH_LOG(\"[State]: %s \\\"%s\\\" %s.\\n\",\n            msg_hash_to_str(MSG_AUTOLOADING_SAVESTATE_FROM),\n            savestate_name_auto, \"succeeded\");\n   else\n      RARCH_LOG(\"[State]: %s \\\"%s\\\" %s.\\n\",\n            msg_hash_to_str(MSG_AUTOLOADING_SAVESTATE_FROM),\n            savestate_name_auto, \"failed\");\n}\n\n/**\n * Scans existing states to determine which one should be loaded\n * and which one can be deleted, using savestate wraparound if\n * enabled.\n *\n * @param settings The usual RetroArch settings ptr.\n * @param last_index Return value for load slot.\n * @param @s Return value for file name that should be removed.\n */\nstatic void scan_states(settings_t *settings,\n      unsigned *last_index, char *s)\n{\n   /* Base name of 128 may be too short for some (<<1%) of the\n      tosec-based file names, but in practice truncating will not\n      lead to mismatch */\n   char state_base[128];\n   char state_dir[DIR_MAX_LENGTH];\n   runloop_state_t *runloop_st        = runloop_state_get_ptr();\n   bool show_hidden_files             = settings->bools.show_hidden_files;\n   unsigned savestate_max_keep        = settings->uints.savestate_max_keep;\n   int curr_state_slot                = settings->ints.state_slot;\n\n   unsigned max_idx                   = 0;\n   unsigned loa_idx                   = 0;\n   unsigned gap_idx                   = UINT_MAX;\n   unsigned del_idx                   = UINT_MAX;\n   retro_bits_512_t slot_mapping_low  = {0};\n   retro_bits_512_t slot_mapping_high = {0};\n\n   struct string_list *dir_list       = NULL;\n   const char *savefile_root          = NULL;\n   size_t savefile_root_length        = 0;\n\n   size_t i, cnt                      = 0;\n   size_t cnt_in_range                = 0;\n\n   fill_pathname_basedir(state_dir, runloop_st->name.savestate,\n         sizeof(state_dir));\n\n   if (!(dir_list = dir_list_new_special(state_dir,\n               DIR_LIST_PLAIN, NULL, show_hidden_files)))\n      return;\n\n   fill_pathname_base(state_base, runloop_st->name.savestate,\n         sizeof(state_base));\n\n   for (i = 0; i < dir_list->size; i++)\n   {\n      unsigned idx;\n      size_t _len;\n      char elem_base[128];\n      const char *ext      = NULL;\n      const char *end      = NULL;\n      const char *dir_elem = dir_list->elems[i].data;\n\n      if (string_is_empty(dir_elem))\n         continue;\n\n      _len = strlen(dir_elem);\n      fill_pathname_base(elem_base, dir_elem, sizeof(elem_base));\n\n      /* Only consider files with a '.state' extension\n       * > i.e. Ignore '.state.auto', '.state.bak', etc. */\n      ext = path_get_extension(elem_base);\n      if (    string_is_empty(ext)\n          || !string_starts_with_size(ext, \"state\", STRLEN_CONST(\"state\")))\n         continue;\n\n      /* Check whether this file is associated with\n       * the current content */\n      if (!string_starts_with(elem_base, state_base))\n         continue;\n\n      /* This looks like a valid savestate */\n      /* Save filename root and length (once) */\n      if (savefile_root_length == 0)\n      {\n         savefile_root        = dir_elem;\n         savefile_root_length = _len;\n      }\n\n      /* Decode the savestate index */\n      end = dir_elem + _len;\n      while ((end > dir_elem) && ISDIGIT((int)end[-1]))\n      {\n         end--;\n         if (savefile_root == dir_elem)\n            savefile_root_length--;\n      }\n      idx = string_to_unsigned(end);\n\n      /* Simple administration: max, total. */\n      if (idx > max_idx)\n         max_idx = idx;\n      cnt++;\n      if (idx <= savestate_max_keep)\n         cnt_in_range++;\n\n      /* Maintain a 2x512 bit map of occupied save states */\n      if (idx < 512)\n         BIT512_SET(slot_mapping_low,idx);\n      else if (idx < 1024)\n         BIT512_SET(slot_mapping_high, idx - 512);\n   }\n\n   /* Next loop on the bitmap, since the file system may have presented the files in any order above */\n   for (i = 0; i <= savestate_max_keep; i++)\n   {\n      /* Unoccupied save slots */\n      if (   (i < 512 && !BIT512_GET(slot_mapping_low,  i))\n          || (i > 511 && !BIT512_GET(slot_mapping_high, i-512)))\n      {\n         /* Gap index: lowest free slot in the wraparound range */\n         if (gap_idx == UINT_MAX)\n            gap_idx = (unsigned)i;\n      }\n      else /* Occupied save slots */\n      {\n         /* Del index: first occupied slot in the wraparound range,\n            after gap index */\n         if (    gap_idx < UINT_MAX && del_idx == UINT_MAX)\n            del_idx = (unsigned)i;\n      }\n   }\n\n   /* Special cases of wraparound */\n\n   /* No previous savestate - set to end, so that first save\n      goes to 0 */\n   if (cnt_in_range == 0)\n   {\n      if (cnt == 0)\n         loa_idx = savestate_max_keep;\n      /* Transient: nothing in current range, but something is present\n       * higher up -> load that */\n      else\n         loa_idx = max_idx;\n      gap_idx    = savestate_max_keep;\n      del_idx    = savestate_max_keep;\n   }\n   /* No gap was found - deduct from current index or default\n      and set (missing) gap index to be deleted */\n   else if (gap_idx == UINT_MAX)\n   {\n      /* Transient: no gap, and max is higher than currently\n       * allowed -> load that, but wrap around so that next\n       * time gap will be present */\n      if (max_idx > savestate_max_keep)\n      {\n         loa_idx = max_idx;\n         gap_idx = 1;\n      }\n      /* Current index is in range, so let's assume it is correct */\n      else if ( (unsigned)curr_state_slot < savestate_max_keep)\n      {\n         loa_idx = curr_state_slot;\n         gap_idx = curr_state_slot + 1;\n      }\n      else\n      {\n         loa_idx = savestate_max_keep;\n         gap_idx = 0;\n      }\n      del_idx    = gap_idx;\n   }\n   /* Gap was found */\n   else\n   {\n      /* No candidate to delete */\n      /* Either gap is at the end of the range: wraparound.\n         or there is no better idea than the lowest index  */\n      if (del_idx == UINT_MAX)\n         del_idx = 0;\n      /* Adjust load index */\n      if (gap_idx == 0)\n         loa_idx = savestate_max_keep;\n      else\n         loa_idx = gap_idx - 1;\n   }\n\n   RARCH_DBG(\"[State]: Save state scanning finished, used slots (in range): \"\n             \"%d (%d), max:%d, load index %d, gap index %d, delete index %d.\\n\",\n             cnt, cnt_in_range, max_idx, loa_idx, gap_idx, del_idx);\n\n   if (last_index)\n         *last_index = loa_idx;\n\n   if (     s\n         && cnt_in_range >= savestate_max_keep)\n   {\n      strlcpy(s, savefile_root, savefile_root_length + 1);\n      /* \".state0\" is just \".state\" instead, so don't print that. */\n      if (del_idx > 0)\n         snprintf(s + savefile_root_length, 5, \"%d\", del_idx);\n   }\n\n   dir_list_free(dir_list);\n}\n\n/**\n * Determines next savestate slot in case of auto-increment,\n * i.e. save state scanning was done already earlier.\n * Logic moved here so that all save state wraparound code is\n * in this file.\n *\n * @param settings The usual RetroArch settings ptr.\n * @return \\c The next savestate slot.\n */\nint command_event_get_next_savestate_auto_index(settings_t *settings)\n{\n   unsigned savestate_max_keep = settings->uints.savestate_max_keep;\n   int new_state_slot          = settings->ints.state_slot + 1;\n   /* If previous save was above the wraparound range, or it overflows,\n      return to the start of the range. */\n   if (     (savestate_max_keep > 0)\n         && (unsigned)new_state_slot > savestate_max_keep)\n      return 0;\n   return new_state_slot;\n}\n\n/**\n * Determines most recent savestate slot in case of content load.\n *\n * @param settings The usual RetroArch settings ptr.\n * @return \\c The most recent savestate slot.\n */\nvoid command_event_set_savestate_auto_index(settings_t *settings)\n{\n   unsigned max_idx          = 0;\n   bool savestate_auto_index = settings->bools.savestate_auto_index;\n   if (!savestate_auto_index)\n   {\n      /* Reset savestate index to 0 when loading content. */\n      configuration_set_int(settings, settings->ints.state_slot, 0);\n      return;\n   }\n   scan_states(settings, &max_idx, NULL);\n   configuration_set_int(settings, settings->ints.state_slot, max_idx);\n   RARCH_LOG(\"[State]: %s: #%d.\\n\",\n         msg_hash_to_str(MSG_FOUND_LAST_STATE_SLOT),\n         max_idx);\n}\n\n/**\n * Deletes the oldest save state and its thumbnail, if needed.\n *\n * @param settings The usual RetroArch settings ptr.\n */\nstatic void command_event_set_savestate_garbage_collect(settings_t *settings)\n{\n   size_t i;\n   char state_to_delete[PATH_MAX_LENGTH] = {0};\n   scan_states(settings, NULL, state_to_delete);\n   /* Only delete one save state per save action\n    * > Conservative behaviour, designed to minimise\n    *   the risk of deleting multiple incorrect files\n    *   in case of accident */\n   if (!string_is_empty(state_to_delete))\n   {\n      filestream_delete(state_to_delete);\n      RARCH_DBG(\"[State]: Garbage collect, deleting \\\"%s\\\".\\n\",state_to_delete);\n      /* Construct the save state thumbnail name\n       * and delete that one as well. */\n      i = strlen(state_to_delete);\n      strlcpy(state_to_delete + i,\".png\",STRLEN_CONST(\".png\")+1);\n      filestream_delete(state_to_delete);\n      RARCH_DBG(\"[State]: Garbage collect, deleting \\\"%s\\\".\\n\",state_to_delete);\n   }\n}\n\nvoid command_event_set_replay_auto_index(settings_t *settings)\n{\n   size_t i;\n   char state_base[128];\n   char state_dir[DIR_MAX_LENGTH];\n\n   struct string_list *dir_list      = NULL;\n   unsigned max_idx                  = 0;\n   runloop_state_t *runloop_st       = runloop_state_get_ptr();\n   bool replay_auto_index            = settings->bools.replay_auto_index;\n   bool show_hidden_files            = settings->bools.show_hidden_files;\n\n   if (!replay_auto_index)\n      return;\n   /* Find the file in the same directory as runloop_st->names.replay\n    * with the largest numeral suffix.\n    *\n    * E.g. /foo/path/content.replay will try to find\n    * /foo/path/content.replay%d, where %d is the largest number available.\n    */\n   fill_pathname_basedir(state_dir, runloop_st->name.replay,\n         sizeof(state_dir));\n\n   if (!(dir_list = dir_list_new_special(state_dir,\n               DIR_LIST_PLAIN, NULL, show_hidden_files)))\n      return;\n\n   fill_pathname_base(state_base, runloop_st->name.replay,\n         sizeof(state_base));\n\n   for (i = 0; i < dir_list->size; i++)\n   {\n      unsigned idx;\n      char elem_base[128]             = {0};\n      const char *end                 = NULL;\n      const char *dir_elem            = dir_list->elems[i].data;\n      size_t _len = fill_pathname_base(elem_base, dir_elem, sizeof(elem_base));\n\n      if (strstr(elem_base, state_base) != elem_base)\n         continue;\n\n      end = dir_elem + _len;\n\n      while ((end > dir_elem) && ISDIGIT((int)end[-1]))\n         end--;\n\n      idx = (unsigned)strtoul(end, NULL, 0);\n      if (idx > max_idx)\n         max_idx = idx;\n   }\n\n   dir_list_free(dir_list);\n\n   configuration_set_int(settings, settings->ints.replay_slot, max_idx);\n\n   if (max_idx)\n      RARCH_LOG(\"[Replay]: %s: #%d\\n\",\n            msg_hash_to_str(MSG_FOUND_LAST_REPLAY_SLOT),\n            max_idx);\n}\n\nvoid command_event_set_replay_garbage_collect(\n      unsigned max_to_keep,\n      bool show_hidden_files\n      )\n{\n  /* TODO: debugme */\n   size_t i, cnt = 0;\n   char state_base[128];\n   char state_dir[DIR_MAX_LENGTH];\n   runloop_state_t *runloop_st       = runloop_state_get_ptr();\n\n   struct string_list *dir_list      = NULL;\n   unsigned min_idx                  = UINT_MAX;\n   const char *oldest_save           = NULL;\n\n   /* Similar to command_event_set_replay_auto_index(),\n    * this will find the lowest numbered replay */\n   fill_pathname_basedir(state_dir, runloop_st->name.replay,\n         sizeof(state_dir));\n\n   if (!(dir_list = dir_list_new_special(state_dir,\n               DIR_LIST_PLAIN, NULL, show_hidden_files)))\n      return;\n\n   fill_pathname_base(state_base, runloop_st->name.replay,\n         sizeof(state_base));\n\n   for (i = 0; i < dir_list->size; i++)\n   {\n      unsigned idx;\n      size_t _len;\n      char elem_base[128];\n      const char *ext                 = NULL;\n      const char *end                 = NULL;\n      const char *dir_elem            = dir_list->elems[i].data;\n\n      if (string_is_empty(dir_elem))\n         continue;\n\n      _len = fill_pathname_base(elem_base, dir_elem, sizeof(elem_base));\n\n      /* Only consider files with a '.replayXX' extension\n       * > i.e. Ignore '.replay.auto', '.replay.bak', etc. */\n      ext = path_get_extension(elem_base);\n      if (    string_is_empty(ext)\n          || !string_starts_with_size(ext, \"replay\", STRLEN_CONST(\"REPLAY\")))\n         continue;\n\n      /* Check whether this file is associated with\n       * the current content */\n      if (!string_starts_with(elem_base, state_base))\n         continue;\n\n      /* This looks like a valid save */\n      cnt++;\n\n      /* > Get index */\n      end = dir_elem + _len;\n\n      while ((end > dir_elem) && ISDIGIT((int)end[-1]))\n         end--;\n\n      idx = string_to_unsigned(end);\n\n      /* > Check if this is the lowest index so far */\n      if (idx < min_idx)\n      {\n         min_idx     = idx;\n         oldest_save = dir_elem;\n      }\n   }\n\n   /* Only delete one save state per save action\n    * > Conservative behaviour, designed to minimise\n    *   the risk of deleting multiple incorrect files\n    *   in case of accident */\n   if (!string_is_empty(oldest_save) && (cnt > max_to_keep))\n      filestream_delete(oldest_save);\n\n   dir_list_free(dir_list);\n}\n\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\nbool command_set_shader(command_t *cmd, const char *arg)\n{\n   enum  rarch_shader_type type = video_shader_parse_type(arg);\n   settings_t  *settings        = config_get_ptr();\n\n   if (!string_is_empty(arg))\n   {\n      gfx_ctx_flags_t flags;\n      flags.flags     = 0;\n      video_context_driver_get_flags(&flags);\n\n      if (!BIT32_GET(flags.flags, video_shader_type_to_flag(type)))\n         return false;\n\n      /* rebase on shader directory */\n      if (!path_is_absolute(arg))\n      {\n         char abs_arg[PATH_MAX_LENGTH];\n         const char *ref_path = settings->paths.directory_video_shader;\n         fill_pathname_join_special(abs_arg, ref_path, arg, sizeof(abs_arg));\n         return video_shader_apply_shader(settings, type, abs_arg, true);\n      }\n   }\n\n   return video_shader_apply_shader(settings, type, arg, true);\n}\n#endif\n\n#ifdef HAVE_CONFIGFILE\nbool command_event_save_core_config(\n      const char *dir_menu_config,\n      const char *rarch_path_config)\n{\n   char msg[128];\n   char config_dir[DIR_MAX_LENGTH];\n   char config_path[PATH_MAX_LENGTH];\n   char config_name[NAME_MAX_LENGTH];\n   size_t _len                     = 0;\n   bool new_path_available         = false;\n   bool overrides_active           = false;\n   const char *core_path           = NULL;\n   runloop_state_t *runloop_st     = runloop_state_get_ptr();\n\n   msg[0]                          = '\\0';\n\n   if (!string_is_empty(dir_menu_config))\n      _len = strlcpy(config_dir, dir_menu_config, sizeof(config_dir));\n   else if (!string_is_empty(rarch_path_config)) /* Fallback */\n      _len = fill_pathname_basedir(config_dir, rarch_path_config,\n            sizeof(config_dir));\n\n   if (_len == 0)\n   {\n      const char *_msg = msg_hash_to_str(MSG_CONFIG_DIRECTORY_NOT_SET);\n      runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n      RARCH_ERR(\"[Config]: %s\\n\", _msg);\n      return false;\n   }\n\n   core_path                       = path_get(RARCH_PATH_CORE);\n\n   /* Infer file name based on libretro core. */\n   if (path_is_valid(core_path))\n   {\n      unsigned i;\n      char tmp[PATH_MAX_LENGTH + 8];\n      RARCH_LOG(\"[Config]: %s\\n\", msg_hash_to_str(MSG_USING_CORE_NAME_FOR_NEW_CONFIG));\n\n      fill_pathname(config_name, path_basename(core_path), \"\",\n            sizeof(config_name));\n      fill_pathname_join_special(config_path, config_dir, config_name,\n            sizeof(config_path));\n\n      /* In case of collision, find an alternative name. */\n      for (i = 0; i < 16; i++)\n      {\n         size_t __len = strlcpy(tmp, config_path, sizeof(tmp));\n\n         if (i)\n            __len += snprintf(tmp + __len, sizeof(tmp) - __len, \"-%u\", i);\n         strlcpy(tmp + __len, \".cfg\", sizeof(tmp) - __len);\n\n         if (!path_is_valid(tmp))\n         {\n            strlcpy(config_path, tmp, sizeof(config_path));\n            new_path_available = true;\n            break;\n         }\n      }\n   }\n\n   if (!new_path_available)\n   {\n      /* Fallback to system time... */\n      RARCH_WARN(\"[Config]: %s\\n\",\n            msg_hash_to_str(MSG_CANNOT_INFER_NEW_CONFIG_PATH));\n      fill_dated_filename(config_name, \".cfg\", sizeof(config_name));\n      fill_pathname_join_special(config_path, config_dir, config_name,\n            sizeof(config_path));\n   }\n\n   if (runloop_st->flags & RUNLOOP_FLAG_OVERRIDES_ACTIVE)\n   {\n      /* Overrides block config file saving,\n       * make it appear as overrides weren't enabled\n       * for a manual save. */\n      runloop_st->flags &= ~RUNLOOP_FLAG_OVERRIDES_ACTIVE;\n      overrides_active   = true;\n   }\n\n#ifdef HAVE_CONFIGFILE\n   _len = command_event_save_config(config_path, msg, sizeof(msg));\n#endif\n\n   if (_len > 0)\n      runloop_msg_queue_push(msg, _len, 1, 180, true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n   if (overrides_active)\n      runloop_st->flags |=  RUNLOOP_FLAG_OVERRIDES_ACTIVE;\n   else\n      runloop_st->flags &= ~RUNLOOP_FLAG_OVERRIDES_ACTIVE;\n\n   return true;\n}\n\nvoid command_event_save_current_config(enum override_type type)\n{\n   runloop_state_t *runloop_st     = runloop_state_get_ptr();\n\n   switch (type)\n   {\n      default:\n      case OVERRIDE_NONE:\n         {\n            size_t _len;\n            char msg[256];\n\n            msg[0] = '\\0';\n\n            if (path_is_empty(RARCH_PATH_CONFIG))\n            {\n               _len = strlcpy(msg, \"Config directory not set, cannot save configuration.\", sizeof(msg));\n               runloop_msg_queue_push(msg, _len, 1, 180, true, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n            }\n            else\n            {\n               if (runloop_st->flags & RUNLOOP_FLAG_OVERRIDES_ACTIVE)\n               {\n                  _len = strlcpy(msg, msg_hash_to_str(MSG_OVERRIDES_ACTIVE_NOT_SAVING), sizeof(msg));\n                  runloop_msg_queue_push(msg, _len, 1, 180, true, NULL,\n                        MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n               }\n               else\n               {\n                  _len = command_event_save_config(path_get(RARCH_PATH_CONFIG), msg, sizeof(msg));\n                  runloop_msg_queue_push(msg, _len, 1, 180, true, NULL,\n                        MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n               }\n            }\n         }\n         break;\n      case OVERRIDE_GAME:\n      case OVERRIDE_CORE:\n      case OVERRIDE_CONTENT_DIR:\n         {\n            size_t _len;\n            char msg[256];\n            int8_t ret = config_save_overrides(type, &runloop_st->system, false, NULL);\n\n            switch (ret)\n            {\n               case 1:\n                  _len = strlcpy(msg,\n                        msg_hash_to_str(MSG_OVERRIDES_SAVED_SUCCESSFULLY), sizeof(msg));\n                  /* set overrides to active so the original config can be\n                     restored after closing content */\n                  runloop_st->flags |= RUNLOOP_FLAG_OVERRIDES_ACTIVE;\n                  break;\n               case -1:\n                  _len = strlcpy(msg, msg_hash_to_str(MSG_OVERRIDES_NOT_SAVED), sizeof(msg));\n                  break;\n               default:\n               case 0:\n                  _len = strlcpy(msg, msg_hash_to_str(MSG_OVERRIDES_ERROR_SAVING), sizeof(msg));\n                  break;\n            }\n\n            RARCH_LOG(\"[Overrides]: %s\\n\", msg);\n            runloop_msg_queue_push(msg, _len, 1, 180, true, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n#ifdef HAVE_MENU\n            {\n               struct menu_state *menu_st      = menu_state_get_ptr();\n               menu_st->flags                 |=  MENU_ST_FLAG_ENTRIES_NEED_REFRESH\n                                               |  MENU_ST_FLAG_PREVENT_POPULATE;\n            }\n#endif\n         }\n         break;\n   }\n}\n\nvoid command_event_remove_current_config(enum override_type type)\n{\n   runloop_state_t *runloop_st     = runloop_state_get_ptr();\n\n   switch (type)\n   {\n      default:\n      case OVERRIDE_NONE:\n         break;\n      case OVERRIDE_GAME:\n      case OVERRIDE_CORE:\n      case OVERRIDE_CONTENT_DIR:\n         {\n            size_t _len;\n            char msg[256];\n            if (config_save_overrides(type, &runloop_st->system, true, NULL))\n               _len = strlcpy(msg, msg_hash_to_str(MSG_OVERRIDES_REMOVED_SUCCESSFULLY), sizeof(msg));\n            else\n               _len = strlcpy(msg, msg_hash_to_str(MSG_OVERRIDES_ERROR_REMOVING), sizeof(msg));\n\n            RARCH_LOG(\"[Overrides]: %s\\n\", msg);\n            runloop_msg_queue_push(msg, _len, 1, 180, true, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n#ifdef HAVE_MENU\n            {\n               struct menu_state *menu_st      = menu_state_get_ptr();\n               menu_st->flags                 |=  MENU_ST_FLAG_ENTRIES_NEED_REFRESH\n                                               |  MENU_ST_FLAG_PREVENT_POPULATE;\n            }\n#endif\n         }\n         break;\n   }\n}\n#endif\n\nbool command_event_main_state(unsigned cmd)\n{\n   char msg[128];\n   char state_path[16384];\n   size_t _len                 = 0;\n   settings_t *settings        = config_get_ptr();\n   bool savestates_enabled     = core_info_current_supports_savestate();\n   bool ret                    = false;\n\n   state_path[0] = msg[0]      = '\\0';\n\n   if (savestates_enabled)\n   {\n      size_t info_size;\n      runloop_get_current_savestate_path(state_path,\n            sizeof(state_path));\n\n      info_size          = core_serialize_size();\n      savestates_enabled = (info_size > 0);\n   }\n\n  /* TODO: Load state should act in one of three ways:\n     - [X] Not during recording or playback: normally\n     - [-] During playback: If the state is part of this replay, go back to that state and rewind the replay (not yet implemented); otherwise halt playback and go to that state normally.\n     - [-] During recording: If the state is part of this replay, go back to that state and rewind the replay, clobbering the stuff in between then and now (not yet implemented); if the state is not part of the replay, do nothing and log a warning.\n   */\n\n\n   if (savestates_enabled)\n   {\n      switch (cmd)\n      {\n         case CMD_EVENT_SAVE_STATE:\n         case CMD_EVENT_SAVE_STATE_TO_RAM:\n            {\n               /* TODO: Saving state during recording should associate the state with the replay. */\n               video_driver_state_t *video_st                 =\n                  video_state_get_ptr();\n               bool savestate_auto_index                      =\n                     settings->bools.savestate_auto_index;\n               unsigned savestate_max_keep                    =\n                     settings->uints.savestate_max_keep;\n               bool frame_time_counter_reset_after_save_state =\n                     settings->bools.frame_time_counter_reset_after_save_state;\n\n               if (cmd == CMD_EVENT_SAVE_STATE)\n                  content_save_state(state_path, true);\n               else\n                  content_save_state_to_ram();\n\n               /* Clean up excess savestates if necessary */\n               if (savestate_auto_index && (savestate_max_keep > 0))\n                  command_event_set_savestate_garbage_collect(settings);\n\n               if (frame_time_counter_reset_after_save_state)\n                  video_st->frame_time_count = 0;\n\n               ret      = true;\n            }\n            break;\n         case CMD_EVENT_LOAD_STATE:\n         case CMD_EVENT_LOAD_STATE_FROM_RAM:\n            {\n               bool res = false;\n               if (cmd == CMD_EVENT_LOAD_STATE)\n                  res = content_load_state(state_path, false, false);\n               else\n                  res = content_load_state_from_ram();\n\n               if (res)\n               {\n                  command_post_state_loaded();\n                  ret = true;\n               }\n            }\n            break;\n        case CMD_EVENT_UNDO_LOAD_STATE:\n           {\n              /* TODO: To support this through re-recording would take some care around moving the replay recording forward to the time when the undo happened, which would need undo support for replays. For now, forbid it during recording and halt playback. */\n#ifdef HAVE_BSV_MOVIE\n              input_driver_state_t *input_st   = input_state_get_ptr();\n              if (input_st->bsv_movie_state.flags & BSV_FLAG_MOVIE_RECORDING)\n              {\n                 RARCH_ERR(\"[State]: Can't undo load state during movie record.\\n\");\n                 return false;\n              }\n              if (input_st->bsv_movie_state.flags & BSV_FLAG_MOVIE_PLAYBACK)\n              {\n                 RARCH_LOG(\"[State]: Undo load state during movie playback, halting playback.\\n\");\n                 movie_stop(input_st);\n              }\n#endif\n              _len = command_event_undo_load_state(msg, sizeof(msg));\n              ret = true;\n              break;\n            }\n         case CMD_EVENT_UNDO_SAVE_STATE:\n            _len = command_event_undo_save_state(msg, sizeof(msg));\n            ret  = true;\n            break;\n      }\n   }\n   else\n      _len = strlcpy(msg, msg_hash_to_str(\n               MSG_CORE_DOES_NOT_SUPPORT_SAVESTATES), sizeof(msg));\n\n   if (_len > 0)\n   {\n      runloop_msg_queue_push(msg, _len, 2, 180, true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n      RARCH_LOG(\"[State]: %s\\n\", msg);\n   }\n\n   return ret;\n}\n\nbool command_event_disk_control_append_image(\n      const char *path)\n{\n   runloop_state_t *runloop_st    = runloop_state_get_ptr();\n   rarch_system_info_t *sys_info  = runloop_st ? (rarch_system_info_t*)&runloop_st->system : NULL;\n   if (  !sys_info ||\n         !disk_control_append_image(&sys_info->disk_control, path))\n      return false;\n\n#ifdef HAVE_THREADS\n   if (runloop_st->flags & RUNLOOP_FLAG_USE_SRAM)\n      autosave_deinit();\n#endif\n\n   /* TODO/FIXME: Need to figure out what to do with subsystems case. */\n   if (path_is_empty(RARCH_PATH_SUBSYSTEM))\n   {\n      /* Update paths for our new image.\n       * If we actually use append_image, we assume that we\n       * started out in a single disk case, and that this way\n       * of doing it makes the most sense. */\n      path_set(RARCH_PATH_NAMES, path);\n      runloop_path_fill_names();\n   }\n\n   command_event(CMD_EVENT_AUTOSAVE_INIT, NULL);\n\n   return true;\n}\n\nvoid command_event_reinit(const int flags)\n{\n   settings_t *settings           = config_get_ptr();\n   input_driver_state_t *input_st = input_state_get_ptr();\n   video_driver_state_t *video_st = video_state_get_ptr();\n#ifdef HAVE_MENU\n   gfx_display_t *p_disp          = disp_get_ptr();\n   struct menu_state *menu_st     = menu_state_get_ptr();\n   bool video_fullscreen          = settings->bools.video_fullscreen;\n   bool adaptive_vsync            = settings->bools.video_adaptive_vsync;\n   unsigned swap_interval_config  = settings->uints.video_swap_interval;\n#endif\n   enum input_game_focus_cmd_type\n      game_focus_cmd              = GAME_FOCUS_CMD_REAPPLY;\n   const input_device_driver_t\n      *joypad                     = input_st->primary_joypad;\n#ifdef HAVE_MFI\n   const input_device_driver_t\n      *sec_joypad                 = input_st->secondary_joypad;\n#else\n   const input_device_driver_t\n      *sec_joypad                 = NULL;\n#endif\n\n   video_driver_reinit(flags);\n   /* Poll input to avoid possibly stale data to corrupt things. */\n   if (  joypad && joypad->poll)\n      joypad->poll();\n   if (  sec_joypad && sec_joypad->poll)\n      sec_joypad->poll();\n   if (  input_st->current_driver &&\n         input_st->current_driver->poll)\n      input_st->current_driver->poll(input_st->current_data);\n   command_event(CMD_EVENT_GAME_FOCUS_TOGGLE, &game_focus_cmd);\n\n#ifdef HAVE_MENU\n   p_disp->flags |= GFX_DISP_FLAG_FB_DIRTY;\n   if (video_fullscreen)\n   {\n      if (     video_st->poke\n            && video_st->poke->show_mouse)\n         video_st->poke->show_mouse(video_st->data, false);\n   }\n   if (     (menu_st->flags & MENU_ST_FLAG_ALIVE)\n         && video_st->current_video->set_nonblock_state)\n      video_st->current_video->set_nonblock_state(\n            video_st->data, false,\n            video_driver_test_all_flags(GFX_CTX_FLAGS_ADAPTIVE_VSYNC) &&\n            adaptive_vsync,\n            runloop_get_video_swap_interval(swap_interval_config));\n#endif\n}\n"
        },
        {
          "name": "command.h",
          "type": "blob",
          "size": 17.681640625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2016 - Daniel De Matteis\n *  Copyright (C) 2021      - David G.F.\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef COMMAND_H__\n#define COMMAND_H__\n\n#include <stdint.h>\n\n#include <boolean.h>\n#include <retro_common_api.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <streams/interface_stream.h>\n\n#include \"retroarch_types.h\"\n#include \"input/input_defines.h\"\n\n#include \"configuration.h\"\n\n#define MAX_CMD_DRIVERS              3\n#define DEFAULT_NETWORK_CMD_PORT 55355\n\nRETRO_BEGIN_DECLS\n\nenum event_command\n{\n   CMD_EVENT_NONE = 0,\n   /* Resets RetroArch. */\n   CMD_EVENT_RESET,\n   CMD_EVENT_SET_PER_GAME_RESOLUTION,\n   CMD_EVENT_SET_FRAME_LIMIT,\n   /* Loads core. */\n   CMD_EVENT_LOAD_CORE,\n   CMD_EVENT_LOAD_CORE_PERSIST,\n#if defined(HAVE_RUNAHEAD) && (defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB))\n   CMD_EVENT_LOAD_SECOND_CORE,\n#endif\n   CMD_EVENT_UNLOAD_CORE,\n   /* Closes content. */\n   CMD_EVENT_CLOSE_CONTENT,\n   /* Swaps the current state with what's on the undo load buffer. */\n   CMD_EVENT_UNDO_LOAD_STATE,\n   /* Rewrites a savestate on disk. */\n   CMD_EVENT_UNDO_SAVE_STATE,\n   /* Save state hotkeys. */\n   CMD_EVENT_LOAD_STATE,\n   CMD_EVENT_SAVE_STATE,\n   CMD_EVENT_SAVE_STATE_DECREMENT,\n   CMD_EVENT_SAVE_STATE_INCREMENT,\n   /* Replay hotkeys. */\n   CMD_EVENT_PLAY_REPLAY,\n   CMD_EVENT_RECORD_REPLAY,\n   CMD_EVENT_HALT_REPLAY,\n   CMD_EVENT_REPLAY_DECREMENT,\n   CMD_EVENT_REPLAY_INCREMENT,\n   /* Save state actions. */\n   CMD_EVENT_SAVE_STATE_TO_RAM,\n   CMD_EVENT_LOAD_STATE_FROM_RAM,\n   CMD_EVENT_RAM_STATE_TO_FILE,\n   /* Takes screenshot. */\n   CMD_EVENT_TAKE_SCREENSHOT,\n   /* Quits RetroArch. */\n   CMD_EVENT_QUIT,\n   /* Reinitialize all drivers. */\n   CMD_EVENT_REINIT_FROM_TOGGLE,\n   /* Reinitialize all drivers. */\n   CMD_EVENT_REINIT,\n   /* Toggles cheevos hardcore mode. */\n   CMD_EVENT_CHEEVOS_HARDCORE_MODE_TOGGLE,\n   /* Deinitialize rewind. */\n   CMD_EVENT_REWIND_DEINIT,\n   /* Initializes rewind. */\n   CMD_EVENT_REWIND_INIT,\n   /* Reinitializes rewind (primarily if the state size changes). */\n   CMD_EVENT_REWIND_REINIT,\n   /* Toggles rewind. */\n   CMD_EVENT_REWIND_TOGGLE,\n   /* Initializes autosave. */\n   CMD_EVENT_AUTOSAVE_INIT,\n   /* Stops audio. */\n   CMD_EVENT_AUDIO_STOP,\n   /* Starts audio. */\n   CMD_EVENT_AUDIO_START,\n   /* Mutes audio. */\n   CMD_EVENT_AUDIO_MUTE_TOGGLE,\n   /* Volume adjustments. */\n   CMD_EVENT_VOLUME_UP,\n   CMD_EVENT_VOLUME_DOWN,\n   CMD_EVENT_MIXER_VOLUME_UP,\n   CMD_EVENT_MIXER_VOLUME_DOWN,\n   /* Toggles FPS counter. */\n   CMD_EVENT_FPS_TOGGLE,\n   /* Toggles statistics display. */\n   CMD_EVENT_STATISTICS_TOGGLE,\n   /* Initializes overlay. */\n   CMD_EVENT_OVERLAY_INIT,\n   /* Frees or caches overlay. */\n   CMD_EVENT_OVERLAY_UNLOAD,\n   /* Sets current scale factor for overlay. */\n   CMD_EVENT_OVERLAY_SET_SCALE_FACTOR,\n   /* Sets current alpha modulation for overlay. */\n   CMD_EVENT_OVERLAY_SET_ALPHA_MOD,\n   /* Sets diagonal sensitivities of overlay eightway areas. */\n   CMD_EVENT_OVERLAY_SET_EIGHTWAY_DIAGONAL_SENSITIVITY,\n   /* Deinitializes overlay. */\n   CMD_EVENT_DSP_FILTER_INIT,\n   /* Initializes recording system. */\n   CMD_EVENT_RECORD_INIT,\n   /* Deinitializes recording system. */\n   CMD_EVENT_RECORD_DEINIT,\n   /* Deinitializes history playlist. */\n   CMD_EVENT_HISTORY_DEINIT,\n   /* Initializes history playlist. */\n   CMD_EVENT_HISTORY_INIT,\n   /* Deinitializes core information. */\n   CMD_EVENT_CORE_INFO_DEINIT,\n   /* Initializes core information. */\n   CMD_EVENT_CORE_INFO_INIT,\n   /* Deinitializes core. */\n   CMD_EVENT_CORE_DEINIT,\n   /* Initializes core. */\n   CMD_EVENT_CORE_INIT,\n   /* Apply video state changes. */\n   CMD_EVENT_VIDEO_APPLY_STATE_CHANGES,\n   /* Set video blocking state. */\n   CMD_EVENT_VIDEO_SET_BLOCKING_STATE,\n   /* Sets current aspect ratio index. */\n   CMD_EVENT_VIDEO_SET_ASPECT_RATIO,\n   /* Restarts RetroArch. */\n   CMD_EVENT_RESTART_RETROARCH,\n   /* Shutdown the OS */\n   CMD_EVENT_SHUTDOWN,\n   /* Reboot the OS */\n   CMD_EVENT_REBOOT,\n   /* Resume RetroArch when in menu. */\n   CMD_EVENT_RESUME,\n   /* Add a playlist entry to favorites. */\n   CMD_EVENT_ADD_TO_FAVORITES,\n   /* Reset playlist entry associated core to DETECT */\n   CMD_EVENT_RESET_CORE_ASSOCIATION,\n   /* Toggles pause. */\n   CMD_EVENT_PAUSE_TOGGLE,\n   /* Pauses RetroArch. */\n   CMD_EVENT_MENU_PAUSE_LIBRETRO,\n   CMD_EVENT_PAUSE,\n   /* Unpauses RetroArch. */\n   CMD_EVENT_UNPAUSE,\n   /* Toggles menu on/off. */\n   CMD_EVENT_MENU_TOGGLE,\n   /* Configuration saving. */\n   CMD_EVENT_MENU_RESET_TO_DEFAULT_CONFIG,\n   CMD_EVENT_MENU_SAVE_CONFIG,\n   CMD_EVENT_MENU_SAVE_CURRENT_CONFIG,\n   CMD_EVENT_MENU_SAVE_CURRENT_CONFIG_OVERRIDE_CORE,\n   CMD_EVENT_MENU_SAVE_CURRENT_CONFIG_OVERRIDE_CONTENT_DIR,\n   CMD_EVENT_MENU_SAVE_CURRENT_CONFIG_OVERRIDE_GAME,\n   CMD_EVENT_MENU_REMOVE_CURRENT_CONFIG_OVERRIDE_CORE,\n   CMD_EVENT_MENU_REMOVE_CURRENT_CONFIG_OVERRIDE_CONTENT_DIR,\n   CMD_EVENT_MENU_REMOVE_CURRENT_CONFIG_OVERRIDE_GAME,\n   /* Applies shader changes. */\n   CMD_EVENT_SHADERS_APPLY_CHANGES,\n   /* A new shader preset has been loaded */\n   CMD_EVENT_SHADER_PRESET_LOADED,\n   /* Shader hotkeys. */\n   CMD_EVENT_SHADER_NEXT,\n   CMD_EVENT_SHADER_PREV,\n   CMD_EVENT_SHADER_TOGGLE,\n   /* Apply cheats. */\n   CMD_EVENT_CHEATS_APPLY,\n   /* Cheat hotkeys. */\n   CMD_EVENT_CHEAT_TOGGLE,\n   CMD_EVENT_CHEAT_INDEX_PLUS,\n   CMD_EVENT_CHEAT_INDEX_MINUS,\n   /* Initializes network system. */\n   CMD_EVENT_NETWORK_INIT,\n   /* Initializes netplay system with a string or no host specified. */\n   CMD_EVENT_NETPLAY_INIT,\n   /* Initializes netplay system with a direct host specified. */\n   CMD_EVENT_NETPLAY_INIT_DIRECT,\n   /* Initializes netplay system with a direct host specified after loading content. */\n   CMD_EVENT_NETPLAY_INIT_DIRECT_DEFERRED,\n   /* Deinitializes netplay system. */\n   CMD_EVENT_NETPLAY_DEINIT,\n   /* Switch between netplay gaming and watching. */\n   CMD_EVENT_NETPLAY_GAME_WATCH,\n   /* Open a netplay chat input menu. */\n   CMD_EVENT_NETPLAY_PLAYER_CHAT,\n   /* Toggle chat fading. */\n   CMD_EVENT_NETPLAY_FADE_CHAT_TOGGLE,\n   /* Start hosting netplay. */\n   CMD_EVENT_NETPLAY_ENABLE_HOST,\n   /* Disconnect from the netplay host. */\n   CMD_EVENT_NETPLAY_DISCONNECT,\n   /* Toggle ping counter. */\n   CMD_EVENT_NETPLAY_PING_TOGGLE,\n   /* Toggles netplay hosting. */\n   CMD_EVENT_NETPLAY_HOST_TOGGLE,\n   /* Reinitializes audio driver. */\n   CMD_EVENT_AUDIO_REINIT,\n   /* Resizes windowed scale. Will reinitialize video driver. */\n   CMD_EVENT_RESIZE_WINDOWED_SCALE,\n   /* Toggles disk eject. */\n   CMD_EVENT_DISK_EJECT_TOGGLE,\n   /* Cycle to next disk. */\n   CMD_EVENT_DISK_NEXT,\n   /* Cycle to previous disk. */\n   CMD_EVENT_DISK_PREV,\n   /* Switch to specified disk index */\n   CMD_EVENT_DISK_INDEX,\n   /* Appends disk image to disk image list. */\n   CMD_EVENT_DISK_APPEND_IMAGE,\n   /* Stops rumbling. */\n   CMD_EVENT_RUMBLE_STOP,\n   /* Toggles mouse grab. */\n   CMD_EVENT_GRAB_MOUSE_TOGGLE,\n   /* Toggles game focus. */\n   CMD_EVENT_GAME_FOCUS_TOGGLE,\n   /* Toggles desktop menu. */\n   CMD_EVENT_UI_COMPANION_TOGGLE,\n   /* Toggles fullscreen mode. */\n   CMD_EVENT_FULLSCREEN_TOGGLE,\n   /* Toggle recording. */\n   CMD_EVENT_RECORDING_TOGGLE,\n   /* Toggle streaming. */\n   CMD_EVENT_STREAMING_TOGGLE,\n   /* Toggle Run-Ahead. */\n   CMD_EVENT_RUNAHEAD_TOGGLE,\n   /* Toggle Preemtive Frames. */\n   CMD_EVENT_PREEMPT_TOGGLE,\n   /* Deinitialize or Reinitialize Preemptive Frames. */\n   CMD_EVENT_PREEMPT_UPDATE,\n   /* Force Preemptive Frames to refill its state buffer. */\n   CMD_EVENT_PREEMPT_RESET_BUFFER,\n   /* Toggle VRR runloop. */\n   CMD_EVENT_VRR_RUNLOOP_TOGGLE,\n   /* AI service. */\n   CMD_EVENT_AI_SERVICE_TOGGLE,\n   CMD_EVENT_AI_SERVICE_CALL,\n   /* Misc. */\n   CMD_EVENT_SAVE_FILES,\n   CMD_EVENT_CONTROLLER_INIT,\n   CMD_EVENT_DISCORD_INIT,\n   CMD_EVENT_PRESENCE_UPDATE,\n   CMD_EVENT_OVERLAY_NEXT,\n   CMD_EVENT_OSK_TOGGLE,\n#ifdef HAVE_MICROPHONE\n   /* Stops all enabled microphones. */\n   CMD_EVENT_MICROPHONE_STOP,\n   /* Starts all enabled microphones */\n   CMD_EVENT_MICROPHONE_START,\n   /* Reinitializes microphone driver. */\n   CMD_EVENT_MICROPHONE_REINIT,\n#endif\n   /* Deprecated */\n   CMD_EVENT_SEND_DEBUG_INFO,\n   /* Add a playlist entry to another playlist. */\n   CMD_EVENT_ADD_TO_PLAYLIST\n};\n\nenum cmd_source_t\n{\n   CMD_NONE = 0,\n   CMD_STDIN,\n   CMD_NETWORK\n};\n\nstruct cmd_map\n{\n   const char *str;\n   unsigned id;\n};\n\nstruct command_handler;\n\ntypedef void (*command_poller_t)(struct command_handler *cmd);\ntypedef void (*command_replier_t)(struct command_handler *cmd, const char * data, size_t len);\ntypedef void (*command_destructor_t)(struct command_handler *cmd);\n\nstruct command_handler\n{\n   /* Interface to poll the driver */\n   command_poller_t poll;\n   /* Interface to reply */\n   command_replier_t replier;\n   /* Interface to delete the underlying command */\n   command_destructor_t destroy;\n   /* Underlying command storage */\n   void *userptr;\n   /* State received */\n   bool state[RARCH_BIND_LIST_END];\n};\n\ntypedef struct command_handler command_t;\n\ntypedef struct command_handle\n{\n   command_t *handle;\n   unsigned id;\n} command_handle_t;\n\nstruct rarch_state;\n\n/**\n * command_event:\n * @cmd                  : Command index.\n *\n * Performs RetroArch command with index @cmd.\n *\n * Returns: true (1) on success, otherwise false (0).\n **/\nbool command_event(enum event_command action, void *data);\n\n/* Constructors for the supported drivers */\ncommand_t* command_network_new(uint16_t port);\ncommand_t* command_stdin_new(void);\ncommand_t* command_uds_new(void);\n\nbool command_network_send(const char *cmd_);\n\nvoid command_event_set_mixer_volume(\n      settings_t *settings,\n      float gain);\n\nbool command_event_resize_windowed_scale(settings_t *settings,\n      unsigned window_scale);\n\nbool command_event_save_auto_state(void);\n\n/**\n * event_set_volume:\n * @gain      : amount of gain to be applied to current volume level.\n *\n * Adjusts the current audio volume level.\n *\n **/\nvoid command_event_set_volume(\n      settings_t *settings,\n      float gain,\n      bool widgets_active,\n      bool audio_driver_mute_enable);\n\n/**\n * command_event_init_controllers:\n *\n * Initialize libretro controllers.\n **/\nvoid command_event_init_controllers(rarch_system_info_t *info,\n      settings_t *settings, unsigned num_active_users);\n\nbool command_event_load_entry_state(settings_t *settings);\n\nvoid command_event_load_auto_state(void);\n\nvoid command_event_set_savestate_auto_index(\n      settings_t *settings);\n\nint command_event_get_next_savestate_auto_index(\n      settings_t *settings);\n\nvoid command_event_set_replay_auto_index(\n      settings_t *settings);\n\nvoid command_event_set_replay_garbage_collect(\n      unsigned max_to_keep,\n      bool show_hidden_files\n      );\n\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\nbool command_set_shader(command_t *cmd, const char *arg);\n#endif\n\n#ifdef HAVE_CHEATS\nvoid command_event_init_cheats(\n      bool apply_cheats_after_load,\n      const char *path_cheat_db,\n      void *bsv_movie_data);\n#endif\n\n#if defined(HAVE_COMMAND)\nstruct cmd_action_map\n{\n   const char *str;\n   bool (*action)(command_t* cmd, const char *arg);\n   const char *arg_desc;\n};\n\nbool command_version(command_t *cmd, const char* arg);\nbool command_get_status(command_t *cmd, const char* arg);\nbool command_get_config_param(command_t *cmd, const char* arg);\nbool command_show_osd_msg(command_t *cmd, const char* arg);\nbool command_load_state_slot(command_t *cmd, const char* arg);\nbool command_play_replay_slot(command_t *cmd, const char* arg);\n#ifdef HAVE_CHEEVOS\nbool command_read_ram(command_t *cmd, const char *arg);\nbool command_write_ram(command_t *cmd, const char *arg);\n#endif\nbool command_read_memory(command_t *cmd, const char *arg);\nbool command_write_memory(command_t *cmd, const char *arg);\n\nstatic const struct cmd_action_map action_map[] = {\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n   { \"SET_SHADER\",       command_set_shader,       \"<shader path>\" },\n#endif\n   { \"VERSION\",          command_version,          \"No argument\"},\n   { \"GET_STATUS\",       command_get_status,       \"No argument\" },\n   { \"GET_CONFIG_PARAM\", command_get_config_param, \"<param name>\" },\n   { \"SHOW_MSG\",         command_show_osd_msg,     \"No argument\" },\n#if defined(HAVE_CHEEVOS)\n   /* These functions use achievement addresses and only work if a game with achievements is\n    * loaded. READ_CORE_MEMORY and WRITE_CORE_MEMORY are preferred and use system addresses. */\n   { \"READ_CORE_RAM\",    command_read_ram,         \"<address> <number of bytes>\" },\n   { \"WRITE_CORE_RAM\",   command_write_ram,        \"<address> <byte1> <byte2> ...\" },\n#endif\n   { \"READ_CORE_MEMORY\", command_read_memory,      \"<address> <number of bytes>\" },\n   { \"WRITE_CORE_MEMORY\",command_write_memory,     \"<address> <byte1> <byte2> ...\" },\n\n   { \"LOAD_STATE_SLOT\",command_load_state_slot, \"<slot number>\"},\n   { \"PLAY_REPLAY_SLOT\",command_play_replay_slot, \"<slot number>\"},\n};\n\nstatic const struct cmd_map map[] = {\n   { \"MENU_TOGGLE\",            RARCH_MENU_TOGGLE },\n   { \"QUIT\",                   RARCH_QUIT_KEY },\n   { \"CLOSE_CONTENT\",          RARCH_CLOSE_CONTENT_KEY },\n   { \"RESET\",                  RARCH_RESET },\n\n   { \"FAST_FORWARD\",           RARCH_FAST_FORWARD_KEY },\n   { \"FAST_FORWARD_HOLD\",      RARCH_FAST_FORWARD_HOLD_KEY },\n   { \"SLOWMOTION\",             RARCH_SLOWMOTION_KEY },\n   { \"SLOWMOTION_HOLD\",        RARCH_SLOWMOTION_HOLD_KEY },\n   { \"REWIND\",                 RARCH_REWIND },\n   { \"PAUSE_TOGGLE\",           RARCH_PAUSE_TOGGLE },\n   { \"FRAMEADVANCE\",           RARCH_FRAMEADVANCE },\n\n   { \"MUTE\",                   RARCH_MUTE },\n   { \"VOLUME_UP\",              RARCH_VOLUME_UP },\n   { \"VOLUME_DOWN\",            RARCH_VOLUME_DOWN },\n\n   { \"LOAD_STATE\",             RARCH_LOAD_STATE_KEY },\n   { \"SAVE_STATE\",             RARCH_SAVE_STATE_KEY },\n   { \"STATE_SLOT_PLUS\",        RARCH_STATE_SLOT_PLUS },\n   { \"STATE_SLOT_MINUS\",       RARCH_STATE_SLOT_MINUS },\n\n   { \"PLAY_REPLAY\",            RARCH_PLAY_REPLAY_KEY },\n   { \"RECORD_REPLAY\",          RARCH_RECORD_REPLAY_KEY },\n   { \"HALT_REPLAY\",            RARCH_HALT_REPLAY_KEY },\n   { \"REPLAY_SLOT_PLUS\",       RARCH_REPLAY_SLOT_PLUS },\n   { \"REPLAY_SLOT_MINUS\",      RARCH_REPLAY_SLOT_MINUS },\n\n   { \"DISK_EJECT_TOGGLE\",      RARCH_DISK_EJECT_TOGGLE },\n   { \"DISK_NEXT\",              RARCH_DISK_NEXT },\n   { \"DISK_PREV\",              RARCH_DISK_PREV },\n\n   { \"SHADER_TOGGLE\",          RARCH_SHADER_TOGGLE },\n   { \"SHADER_NEXT\",            RARCH_SHADER_NEXT },\n   { \"SHADER_PREV\",            RARCH_SHADER_PREV },\n\n   { \"CHEAT_TOGGLE\",           RARCH_CHEAT_TOGGLE },\n   { \"CHEAT_INDEX_PLUS\",       RARCH_CHEAT_INDEX_PLUS },\n   { \"CHEAT_INDEX_MINUS\",      RARCH_CHEAT_INDEX_MINUS },\n\n   { \"SCREENSHOT\",             RARCH_SCREENSHOT },\n   { \"RECORDING_TOGGLE\",       RARCH_RECORDING_TOGGLE },\n   { \"STREAMING_TOGGLE\",       RARCH_STREAMING_TOGGLE },\n\n   { \"GRAB_MOUSE_TOGGLE\",      RARCH_GRAB_MOUSE_TOGGLE },\n   { \"GAME_FOCUS_TOGGLE\",      RARCH_GAME_FOCUS_TOGGLE },\n   { \"FULLSCREEN_TOGGLE\",      RARCH_FULLSCREEN_TOGGLE_KEY },\n   { \"UI_COMPANION_TOGGLE\",    RARCH_UI_COMPANION_TOGGLE },\n\n   { \"VRR_RUNLOOP_TOGGLE\",     RARCH_VRR_RUNLOOP_TOGGLE },\n   { \"RUNAHEAD_TOGGLE\",        RARCH_RUNAHEAD_TOGGLE },\n   { \"PREEMPT_TOGGLE\",         RARCH_PREEMPT_TOGGLE },\n   { \"FPS_TOGGLE\",             RARCH_FPS_TOGGLE },\n   { \"STATISTICS_TOGGLE\",      RARCH_STATISTICS_TOGGLE },\n   { \"AI_SERVICE\",             RARCH_AI_SERVICE },\n\n   { \"NETPLAY_PING_TOGGLE\",    RARCH_NETPLAY_PING_TOGGLE },\n   { \"NETPLAY_HOST_TOGGLE\",    RARCH_NETPLAY_HOST_TOGGLE },\n   { \"NETPLAY_GAME_WATCH\",     RARCH_NETPLAY_GAME_WATCH },\n   { \"NETPLAY_PLAYER_CHAT\",    RARCH_NETPLAY_PLAYER_CHAT },\n   { \"NETPLAY_FADE_CHAT_TOGGLE\", RARCH_NETPLAY_FADE_CHAT_TOGGLE },\n\n   { \"MENU_UP\",                RETRO_DEVICE_ID_JOYPAD_UP },\n   { \"MENU_DOWN\",              RETRO_DEVICE_ID_JOYPAD_DOWN },\n   { \"MENU_LEFT\",              RETRO_DEVICE_ID_JOYPAD_LEFT },\n   { \"MENU_RIGHT\",             RETRO_DEVICE_ID_JOYPAD_RIGHT },\n   { \"MENU_A\",                 RETRO_DEVICE_ID_JOYPAD_A },\n   { \"MENU_B\",                 RETRO_DEVICE_ID_JOYPAD_B },\n\n   { \"OVERLAY_NEXT\",           RARCH_OVERLAY_NEXT },\n   { \"OSK\",                    RARCH_OSK },\n\n#if 0\n   /* Deprecated */\n   { \"SEND_DEBUG_INFO\",        RARCH_SEND_DEBUG_INFO },\n#endif\n};\n#endif\n\n#ifdef HAVE_CONFIGFILE\n/**\n * command_event_save_core_config:\n *\n * Saves a new (core) configuration to a file. Filename is based\n * on heuristics to avoid typing.\n *\n * Returns: true (1) on success, otherwise false (0).\n **/\nbool command_event_save_core_config(\n      const char *dir_menu_config,\n      const char *rarch_path_config);\n\n/**\n * command_event_save_current_config:\n *\n * Saves current configuration file to disk, and (optionally)\n * autosave state.\n **/\nvoid command_event_save_current_config(enum override_type type);\n\n/**\n * command_event_remove_current_config:\n *\n * Removes current configuration file from disk.\n **/\nvoid command_event_remove_current_config(enum override_type type);\n#endif\n\n/**\n * command_event_disk_control_append_image:\n * @path                 : Path to disk image.\n *\n * Appends disk image to disk image list.\n **/\nbool command_event_disk_control_append_image(const char *path);\n\nvoid command_event_reinit(const int flags);\n\nbool command_event_main_state(unsigned cmd);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "config.def.h",
          "type": "blob",
          "size": 61.4228515625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2016 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __CONFIG_DEF_H\n#define __CONFIG_DEF_H\n\n#include <boolean.h>\n#include <audio/audio_resampler.h>\n#include \"configuration.h\"\n#include \"gfx/video_defines.h\"\n#include \"input/input_defines.h\"\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef HAVE_NETWORKING\n#include \"network/netplay/netplay_defines.h\"\n#endif\n\n/* Required for 3DS display mode setting */\n#if defined(_3DS)\n#include \"gfx/common/ctr_defines.h\"\n#endif\n\n/* Required for OpenDingux IPU filter + refresh\n * rate settings */\n#if defined(DINGUX)\n#include \"dingux/dingux_utils.h\"\n#endif\n\n/* Required for 'show inputs on overlay' setting */\n#if defined(HAVE_OVERLAY)\n#include \"../input/input_overlay.h\"\n#endif\n\n/* Required for Steam enum settings */\n#if defined(HAVE_MIST)\n#include \"steam/steam.h\"\n#endif\n\n#if defined(HW_RVL)\n#define MAX_GAMMA_SETTING 30\n#elif defined(GEKKO)\n#define MAX_GAMMA_SETTING 2\n#else\n#define MAX_GAMMA_SETTING 1\n#endif\n\n#if defined(XENON) || defined(_XBOX360) || defined(__PSL1GHT__) || defined(__PS3__)\n#define DEFAULT_ASPECT_RATIO 1.7778f\n#elif defined(_XBOX1) || defined(GEKKO) || defined(ANDROID)\n#define DEFAULT_ASPECT_RATIO 1.3333f\n#else\n#define DEFAULT_ASPECT_RATIO 1.3333f\n#endif\n\n#define DEFAULT_VIEWPORT_BIAS_X 0.5\n#define DEFAULT_VIEWPORT_BIAS_Y 0.5\n\n#if defined(RARCH_MOBILE)\n#define DEFAULT_VIEWPORT_BIAS_PORTRAIT_X 0.5\n#define DEFAULT_VIEWPORT_BIAS_PORTRAIT_Y 0.0\n#endif\n\n#if defined(GEKKO)\n#define DEFAULT_MOUSE_SCALE 1\n#endif\n\n#define DEFAULT_TOUCH_SCALE 1\n\n#if defined(RARCH_MOBILE) || defined(HAVE_LIBNX) || defined(__WINRT__) || defined(EMSCRIPTEN)\n#define DEFAULT_POINTER_ENABLE true\n#else\n#define DEFAULT_POINTER_ENABLE false\n#endif\n\n/* Certain platforms might have assets stored in the bundle that\n * we need to extract to a user-writable directory on first boot.\n *\n * Examples include: Android, iOS/OSX) */\n#if defined(ANDROID) || defined(__APPLE__)\n#define DEFAULT_BUNDLE_ASSETS_EXTRACT_ENABLE true\n#else\n#define DEFAULT_BUNDLE_ASSETS_EXTRACT_ENABLE false\n#endif\n\n#ifdef HAVE_MATERIALUI\n/* Show icons to the left of each menu entry */\n#define DEFAULT_MATERIALUI_ICONS_ENABLE true\n/* Show boolean option ON/OFF icons */\n#define DEFAULT_MATERIALUI_SWITCH_ICONS true\n/* Show system-specific icons in the playlists tab */\n#define DEFAULT_MATERIALUI_PLAYLIST_ICONS_ENABLE true\n#endif\n\n/* Material UI colour theme */\n#define DEFAULT_MATERIALUI_THEME MATERIALUI_THEME_OZONE_DARK\n\n/* Type of animation to use when performing menu transitions\n * > 'Auto' follows Material UI standards:\n *   - Slide when switching between parent menus (tabs)\n *   - Fade when changing levels in a menu\n * Note: Not wrapping this with a HAVE_MATERIALUI ifdef\n * because there's too much baggage involved... */\n#define DEFAULT_MATERIALUI_TRANSITION_ANIM MATERIALUI_TRANSITION_ANIM_AUTO\n\n/* Adjust menu padding etc. to better fit the\n * screen when using landscape layouts */\n#if defined(RARCH_MOBILE)\n#define DEFAULT_MATERIALUI_LANDSCAPE_LAYOUT_OPTIMIZATION MATERIALUI_LANDSCAPE_LAYOUT_OPTIMIZATION_DISABLED\n#else\n#define DEFAULT_MATERIALUI_LANDSCAPE_LAYOUT_OPTIMIZATION MATERIALUI_LANDSCAPE_LAYOUT_OPTIMIZATION_ALWAYS\n#endif\n\n/* Show/hide navigation bar\n * > When hidden, MaterialUI menu navigation\n *   behaves like RGUI */\n#define DEFAULT_MATERIALUI_SHOW_NAV_BAR true\n\n/* Reposition navigation bar to make better use\n * of screen space when using landscape layouts */\n#define DEFAULT_MATERIALUI_AUTO_ROTATE_NAV_BAR true\n\n/* Default portrait/landscape playlist view modes\n * (when thumbnails are enabled) */\n#define DEFAULT_MATERIALUI_THUMBNAIL_VIEW_PORTRAIT MATERIALUI_THUMBNAIL_VIEW_PORTRAIT_LIST_SMALL\n#define DEFAULT_MATERIALUI_THUMBNAIL_VIEW_LANDSCAPE MATERIALUI_THUMBNAIL_VIEW_LANDSCAPE_LIST_MEDIUM\n\n/* Enable second thumbnail when using 'list view'\n * thumbnail views\n * Note: Second thumbnail will only be drawn if\n * display has sufficient horizontal real estate */\n#if defined(RARCH_MOBILE)\n#define DEFAULT_MATERIALUI_DUAL_THUMBNAIL_LIST_VIEW_ENABLE false\n#else\n#define DEFAULT_MATERIALUI_DUAL_THUMBNAIL_LIST_VIEW_ENABLE true\n#endif\n\n/* Draw solid colour 4:3 background when rendering\n * thumbnails\n * > Helps to unify menu appearance when viewing\n *   thumbnails of different sizes */\n#define DEFAULT_MATERIALUI_THUMBNAIL_BACKGROUND_ENABLE true\n\n#define DEFAULT_SCREEN_BRIGHTNESS 100\n\n#define DEFAULT_CRT_SWITCH_RESOLUTION CRT_SWITCH_NONE\n\n#define DEFAULT_CRT_SWITCH_RESOLUTION_SUPER 2560\n\n#define DEFAULT_CRT_SWITCH_CENTER_ADJUST 0\n\n#define DEFAULT_CRT_SWITCH_PORCH_ADJUST 0\n\n#define DEFAULT_CRT_SWITCH_HIRES_MENU true\n\n#define DEFAULT_HISTORY_LIST_ENABLE true\n\n#define DEFAULT_PLAYLIST_ENTRY_RENAME true\n\n#define DEFAULT_WIFI_ENABLE true\n\n#define DEFAULT_ACCESSIBILITY_ENABLE false\n\n#define DEFAULT_ACCESSIBILITY_NARRATOR_SPEECH_SPEED 5\n\n#define DEFAULT_DRIVER_SWITCH_ENABLE true\n\n#define DEFAULT_USER_LANGUAGE 0\n\n#define DEFAULT_GAMEMODE_ENABLE true\n\n#ifdef HAVE_LAKKA_SWITCH\n#define DEFAULT_SWITCH_OC false\n#define DEFAULT_SWITCH_CEC true\n#define DEFAULT_BLUETOOTH_ERTM false\n#endif\n\n#if (defined(_WIN32) && !defined(_XBOX)) || (defined(__linux) && !defined(ANDROID) && !defined(HAVE_LAKKA)) || (defined(__MACH__) && !defined(IOS)) || defined(EMSCRIPTEN)\n#define DEFAULT_MOUSE_ENABLE true\n#else\n#define DEFAULT_MOUSE_ENABLE false\n#endif\n\n#ifdef HAVE_CHEEVOS\n#define DEFAULT_CHEEVOS_ENABLE false\n#define DEFAULT_CHEEVOS_APPEARANCE_ANCHOR 0 /* CHEEVOS_APPEARANCE_ANCHOR_TOPLEFT */\n#define DEFAULT_CHEEVOS_APPEARANCE_PADDING_AUTO true\n#define DEFAULT_CHEEVOS_APPEARANCE_PADDING_H 0.0f\n#define DEFAULT_CHEEVOS_APPEARANCE_PADDING_V 0.0f\n#define DEFAULT_CHEEVOS_VISIBILITY_SUMMARY 1 /* RCHEEVOS_SUMMARY_HASCHEEVOS */\n#define DEFAULT_CHEEVOS_VISIBILITY_UNLOCK true\n#define DEFAULT_CHEEVOS_VISIBILITY_MASTERY true\n#define DEFAULT_CHEEVOS_VISIBILITY_ACCOUNT true\n#define DEFAULT_CHEEVOS_VISIBILITY_LBOARD_START true\n#define DEFAULT_CHEEVOS_VISIBILITY_LBOARD_SUBMIT true\n#define DEFAULT_CHEEVOS_VISIBILITY_LBOARD_CANCEL true\n#define DEFAULT_CHEEVOS_VISIBILITY_LBOARD_TRACKERS true\n#define DEFAULT_CHEEVOS_VISIBILITY_PROGRESS_TRACKER true\n#endif\n\n/* VIDEO */\n\n#if defined(_XBOX360)\n#define DEFAULT_GAMMA 1\n#else\n#define DEFAULT_GAMMA 0\n#endif\n\n/* Windowed\n * Real x resolution = aspect * base_size * x scale\n * Real y resolution = base_size * y scale\n */\n#define DEFAULT_SCALE 3\n\n/* Fullscreen */\n\n/* To start in Fullscreen, or not. */\n\n#if defined(HAVE_STEAM) || defined(DINGUX) || defined(__WINRT__) || defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP\n/* Start in fullscreen mode for Steam and Dingux\n * WinRT and Winapi Family builds */\n#define DEFAULT_FULLSCREEN true\n#else\n#define DEFAULT_FULLSCREEN false\n#endif\n\n/* To use windowed mode or not when going fullscreen. */\n#if defined(__WINRT__) || defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP\n/* Do not use windowed mode for WinRT and Winapi Family builds on the Xbox UWP with fixed resolution shrinks the image into the left top corner of the screen with some libretro cores */\n#define DEFAULT_WINDOWED_FULLSCREEN false\n#else\n#define DEFAULT_WINDOWED_FULLSCREEN true\n#endif\n\n/* Enable automatic switching of the screen refresh rate when using the specified screen mode(s),\n * based on running core/content */\n#define DEFAULT_AUTOSWITCH_REFRESH_RATE AUTOSWITCH_REFRESH_RATE_EXCLUSIVE_FULLSCREEN\n#define DEFAULT_AUTOSWITCH_PAL_THRESHOLD 54.50f\n\n/* Which monitor to prefer. 0 is any monitor, 1 and up selects\n * specific monitors, 1 being the first monitor. */\n#define DEFAULT_MONITOR_INDEX 0\n\n/* Window */\n\n/* DEFAULT_WINDOW_DECORATIONS:\n   Whether to show the usual window decorations like border, titlebar etc. */\n#ifdef WEBOS\n#define DEFAULT_WINDOW_DECORATIONS false\n#else\n#define DEFAULT_WINDOW_DECORATIONS true\n#endif\n\n/* Amount of transparency to use for the main window.\n * 1 is the most transparent while 100 is opaque. */\n#define DEFAULT_WINDOW_OPACITY 100\n\n/* DEFAULT_WINDOW_SAVE_POSITIONS:\n * Whether to remember window positions\n * NOTE: Only enabled for desktop Windows\n * at present. */\n#define DEFAULT_WINDOW_SAVE_POSITIONS false\n\n/* Whether to use custom (fixed size)\n * window dimensions in windowed mode. */\n#ifdef WEBOS\n#define DEFAULT_WINDOW_CUSTOM_SIZE_ENABLE true\n#else\n#define DEFAULT_WINDOW_CUSTOM_SIZE_ENABLE false\n#endif\n\n/* Window dimensions when using a fixed size\n * window. A value of 0 disables fixed size\n * windows, using nominal dimensions of\n * window scale multiplied by the core\n * framebuffer size. */\n#if defined(WEBOS)\n#define DEFAULT_WINDOW_WIDTH  1920\n#define DEFAULT_WINDOW_HEIGHT 1080\n#else\n#define DEFAULT_WINDOW_WIDTH  1280\n#define DEFAULT_WINDOW_HEIGHT 720\n#endif\n\n/* Maximum auto-set window dimensions\n * when not using a fixed size window */\n#define DEFAULT_WINDOW_AUTO_WIDTH_MAX  1920\n#define DEFAULT_WINDOW_AUTO_HEIGHT_MAX 1080\n\n/* Fullscreen resolution. A value of 0 uses the desktop\n * resolution. */\n#if defined(DINGUX)\n#define DEFAULT_FULLSCREEN_X 320\n#define DEFAULT_FULLSCREEN_Y 240\n#elif defined(__WINRT__) || defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP\n#define DEFAULT_FULLSCREEN_X 1920\n#define DEFAULT_FULLSCREEN_Y 1080\n#else\n#define DEFAULT_FULLSCREEN_X 0\n#define DEFAULT_FULLSCREEN_Y 0\n#endif\n\n#if defined(HAVE_WINDOW_OFFSET)\n/* Screen offsets to center content in CTRs */\n#define DEFAULT_WINDOW_OFFSET_X 0\n#define DEFAULT_WINDOW_OFFSET_Y 0\n#endif\n\n/* Number of threads to use for video recording */\n#define DEFAULT_VIDEO_RECORD_THREADS 2\n\n#if defined(RARCH_CONSOLE)\n#define DEFAULT_LOAD_DUMMY_ON_CORE_SHUTDOWN false\n#else\n#define DEFAULT_LOAD_DUMMY_ON_CORE_SHUTDOWN true\n#endif\n#define DEFAULT_CHECK_FIRMWARE_BEFORE_LOADING false\n\n/* Specifies whether cores are allowed to\n * present core options in category submenus */\n#define DEFAULT_CORE_OPTION_CATEGORY_ENABLE true\n\n/* Specifies whether to cache core info\n * into a single (compressed) file for improved\n * load times on platforms with slow IO */\n#define DEFAULT_CORE_INFO_CACHE_ENABLE true\n\n/* Specifies whether to ignore core info\n * savestate capabilities, allowing to\n * experiment with related features\n * (run ahead, rewind, etc) */\n#define DEFAULT_CORE_INFO_SAVESTATE_BYPASS false\n\n/* Specifies whether to 'reload' (fork and quit)\n * RetroArch when launching content with the\n * currently loaded core\n * > Only relevant on platforms without dynamic core\n *   loading support\n * > Setting this to 'false' will decrease loading\n *   times when required core is already running,\n *   but may cause stability issues (if core misbehaves) */\n#ifndef HAVE_DYNAMIC\n#define DEFAULT_ALWAYS_RELOAD_CORE_ON_RUN_CONTENT true\n#endif\n\n/* Forcibly disable composition.\n * Only valid on Windows Vista/7/8 for now. */\n#define DEFAULT_DISABLE_COMPOSITION false\n\n/* Video VSYNC (recommended) */\n#define DEFAULT_VSYNC true\n\n/* Vulkan specific */\n#define DEFAULT_MAX_SWAPCHAIN_IMAGES 3\n#define MINIMUM_MAX_SWAPCHAIN_IMAGES 2\n#define MAXIMUM_MAX_SWAPCHAIN_IMAGES 4\n\n/* D3D1x specific */\n#if defined(__WINRT__) || defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP\n#define DEFAULT_WAITABLE_SWAPCHAINS false\n#else\n#define DEFAULT_WAITABLE_SWAPCHAINS true\n#endif\n#define DEFAULT_MAX_FRAME_LATENCY 1\n#define MAXIMUM_MAX_FRAME_LATENCY 4\n\n/* GL specific */\n#define DEFAULT_ADAPTIVE_VSYNC false\n\n/* Attempts to hard-synchronize CPU and GPU.\n * Can reduce latency at cost of performance. */\n#define DEFAULT_HARD_SYNC false\n\n/* Configures how many frames the GPU can run ahead of CPU.\n * 0: Syncs to GPU immediately.\n * 1: Syncs to previous frame.\n * 2: Etc ...\n */\n#define DEFAULT_HARD_SYNC_FRAMES 0\n#define MINIMUM_HARD_SYNC_FRAMES 0\n#define MAXIMUM_HARD_SYNC_FRAMES 3\n\n/* Sets how many milliseconds to delay after VSync before running the core.\n * Can reduce latency at cost of higher risk of stuttering.\n */\n#define DEFAULT_FRAME_DELAY 0\n#define MAXIMUM_FRAME_DELAY 99\n#define DEFAULT_FRAME_DELAY_AUTO false\n\n/* Duplicates frames for the purposes of running Shaders at a higher framerate\n * than content framerate. Requires running screen at multiple of 60hz, and\n * don't combine with Swap_interval > 1, or BFI. (Though BFI can be done in a shader\n * with multi-frame shaders.)\n */\n#define DEFAULT_SHADER_SUBFRAMES 1\n\n/* Divides implements basic rolling scanning of sub frames - does this simply by scrolling a\n * a scissor rect down the screen according to how many sub frames there are\n */\n#define DEFAULT_SCAN_SUBFRAMES false\n\n/* Inserts black frame(s) inbetween frames.\n * Useful for Higher Hz monitors (set to multiples of 60 Hz) who want to play 60 Hz\n * material with CRT-like motion clarity.\n */\n#define DEFAULT_BLACK_FRAME_INSERTION 0\n\n/* Black Frame Insertion Dark Frames.\n * Increase for more clarity at the cost of lower brightness. Adjusting can also eliminate\n * any temporary image retention if noticed. Only useful at 180hz or higher 60hz multiples,\n * as 120hz only has one total extra frame for BFI to work with.\n */\n#define DEFAULT_BFI_DARK_FRAMES 1\n\n/* Uses a custom swap interval for VSync.\n * Set this to effectively halve monitor refresh rate.\n */\n#define DEFAULT_SWAP_INTERVAL 1\n\n/* Threaded video. Will possibly increase performance significantly\n * at the cost of worse synchronization and latency.\n */\n#if defined(HAVE_LIBNX)\n#define DEFAULT_VIDEO_THREADED true\n#else\n#define DEFAULT_VIDEO_THREADED false\n#endif\n\n#if defined(HAVE_THREADS)\n#if defined(GEKKO) || defined(PSP) || defined(PS2)\n/* For single-core consoles right now it's best to have this be disabled. */\n#define DEFAULT_THREADED_DATA_RUNLOOP_ENABLE false\n#else\n#define DEFAULT_THREADED_DATA_RUNLOOP_ENABLE true\n#endif\n#else\n#define DEFAULT_THREADED_DATA_RUNLOOP_ENABLE false\n#endif\n\n/* Set to true if HW render cores should get their private context. */\n#define DEFAULT_VIDEO_SHARED_CONTEXT false\n\n/* Sets GC/Wii screen width. */\n#define DEFAULT_VIDEO_VI_WIDTH 640\n\n#ifdef GEKKO\n/* Removes 480i flicker, smooths picture a little. */\n#define DEFAULT_VIDEO_VFILTER true\n\n/* Allow overscan to be corrected on displays that\n * do not have proper 'pixel perfect' scaling */\n#define DEFAULT_VIDEO_OVERSCAN_CORRECTION_TOP 0\n#define DEFAULT_VIDEO_OVERSCAN_CORRECTION_BOTTOM 0\n#endif\n\n/* Smooths picture. */\n#if defined(_3DS) || defined(GEKKO) || defined(HW_RVL) || defined(PSP) || defined(VITA) || defined(SN_TARGET_PSP2) || defined(PS2) || defined(_XBOX) || defined(DINGUX)\n#define DEFAULT_VIDEO_SMOOTH true\n#else\n#define DEFAULT_VIDEO_SMOOTH false\n#endif\n\n/* Graphics context specific scaling */\n#define DEFAULT_VIDEO_CTX_SCALING false\n\n/* On resize and fullscreen, rendering area will stay 4:3 */\n#define DEFAULT_FORCE_ASPECT true\n\n/* Only applies to Android 9.0 (API 28) and up */\n/* Choose if the screen will be able to write around the notch or not */\n#define DEFAULT_NOTCH_WRITE_OVER_ENABLE false\n\n/* Enable use of shaders. */\n#ifdef RARCH_CONSOLE\n#define DEFAULT_SHADER_ENABLE true\n#else\n#define DEFAULT_SHADER_ENABLE false\n#endif\n\n/* Should we enable hdr when its supported*/\n#define DEFAULT_VIDEO_HDR_ENABLE false\n\n/* The maximum nunmber of nits the actual display can show - needs to be calibrated */\n#define DEFAULT_VIDEO_HDR_MAX_NITS 1000.0f\n\n/* The number of nits that paper white is at */\n#define DEFAULT_VIDEO_HDR_PAPER_WHITE_NITS 200.0f\n\n/* The contrast setting for hdr used to calculate the display gamma by dividing this value by gamma 2.2  */\n#define DEFAULT_VIDEO_HDR_CONTRAST 5.0f\n\n/* Should we expand the colour gamut when using hdr */\n#define DEFAULT_VIDEO_HDR_EXPAND_GAMUT true\n\n/* When presets are saved they will be saved using the #reference\n * directive by default */\n#define DEFAULT_VIDEO_SHADER_PRESET_SAVE_REFERENCE_ENABLE true\n\n#define DEFAULT_SHADER_DELAY 0\n\n/* Only scale in integer steps.\n * The base size depends on system-reported geometry and aspect ratio.\n * If video_force_aspect is not set, X/Y will be integer scaled independently.\n * Overscale rounds up instead of down, default is downscale.\n */\n#define DEFAULT_SCALE_INTEGER false\n#define DEFAULT_SCALE_INTEGER_AXIS 0\n#define DEFAULT_SCALE_INTEGER_SCALING 0\n\n/* Controls aspect ratio handling. */\n\n/* 1:1 PAR */\n#define DEFAULT_ASPECT_RATIO_AUTO false\n\n#if defined(_XBOX360) || defined(__PS3__)\n#define DEFAULT_ASPECT_RATIO_IDX ASPECT_RATIO_16_9\n#elif defined(PSP) || defined(_3DS) || defined(HAVE_LIBNX) || defined(VITA)\n#define DEFAULT_ASPECT_RATIO_IDX ASPECT_RATIO_CORE\n#elif defined(RARCH_CONSOLE)\n#define DEFAULT_ASPECT_RATIO_IDX ASPECT_RATIO_4_3\n#else\n#define DEFAULT_ASPECT_RATIO_IDX ASPECT_RATIO_CORE\n#endif\n\n#if defined(DINGUX)\n/* Enables aspect ratio correction (1:1 PAR) when\n * using the IPU hardware scaler in Dingux devices */\n#define DEFAULT_DINGUX_IPU_KEEP_ASPECT true\n/* Sets image filtering method when using the\n * IPU hardware scaler in Dingux devices */\n#if defined(RETROFW)\n#define DEFAULT_DINGUX_IPU_FILTER_TYPE DINGUX_IPU_FILTER_NEAREST\n#else\n#define DEFAULT_DINGUX_IPU_FILTER_TYPE DINGUX_IPU_FILTER_BICUBIC\n#endif\n\n#if defined(DINGUX_BETA)\n/* Sets refresh rate of integral LCD panel\n * in Dingux devices */\n#define DEFAULT_DINGUX_REFRESH_RATE DINGUX_REFRESH_RATE_60HZ\n#endif\n#if defined(RS90) || defined(MIYOO)\n/* Sets image filtering method on the RS90\n * when integer scaling is disabled */\n#define DEFAULT_DINGUX_RS90_SOFTFILTER_TYPE DINGUX_RS90_SOFTFILTER_POINT\n#endif\n#endif\n\n/* Save configuration file on exit. */\n#define DEFAULT_CONFIG_SAVE_ON_EXIT true\n\n/* Save active input remap file on exit/close content */\n#define DEFAULT_REMAP_SAVE_ON_EXIT true\n\n#define DEFAULT_SHOW_HIDDEN_FILES false\n\n/* Initialise file browser with the last used start directory */\n#define DEFAULT_USE_LAST_START_DIRECTORY false\n\n#define DEFAULT_OVERLAY_BEHIND_MENU false\n\n#define DEFAULT_OVERLAY_HIDE_IN_MENU true\n\n/* Automatically disable overlays when a\n * controller is connected in port 1 */\n#define DEFAULT_OVERLAY_HIDE_WHEN_GAMEPAD_CONNECTED false\n\n#define DEFAULT_OVERLAY_SHOW_MOUSE_CURSOR true\n\n#define DEFAULT_DISPLAY_KEYBOARD_OVERLAY false\n\n#ifdef HAKCHI\n#define DEFAULT_INPUT_OVERLAY_OPACITY 0.5f\n#else\n#define DEFAULT_INPUT_OVERLAY_OPACITY 0.7f\n#endif\n\n#define DEFAULT_INPUT_OVERLAY_SCALE_LANDSCAPE 1.0f\n#define DEFAULT_INPUT_OVERLAY_ASPECT_ADJUST_LANDSCAPE 0.0f\n#define DEFAULT_INPUT_OVERLAY_X_SEPARATION_LANDSCAPE 0.0f\n#define DEFAULT_INPUT_OVERLAY_Y_SEPARATION_LANDSCAPE 0.0f\n#define DEFAULT_INPUT_OVERLAY_X_OFFSET_LANDSCAPE 0.0f\n#define DEFAULT_INPUT_OVERLAY_Y_OFFSET_LANDSCAPE 0.0f\n\n#define DEFAULT_INPUT_OVERLAY_SCALE_PORTRAIT 1.0f\n#define DEFAULT_INPUT_OVERLAY_ASPECT_ADJUST_PORTRAIT 0.0f\n#define DEFAULT_INPUT_OVERLAY_X_SEPARATION_PORTRAIT 0.0f\n#define DEFAULT_INPUT_OVERLAY_Y_SEPARATION_PORTRAIT 0.0f\n#define DEFAULT_INPUT_OVERLAY_X_OFFSET_PORTRAIT 0.0f\n#define DEFAULT_INPUT_OVERLAY_Y_OFFSET_PORTRAIT 0.0f\n\n#if defined(RARCH_MOBILE)\n#define DEFAULT_OVERLAY_AUTO_ROTATE true\n#else\n#define DEFAULT_OVERLAY_AUTO_ROTATE false\n#endif\n\n#if defined(RARCH_MOBILE)\n#define DEFAULT_INPUT_OVERLAY_AUTO_SCALE true\n#else\n#define DEFAULT_INPUT_OVERLAY_AUTO_SCALE false\n#endif\n\n#if defined(RARCH_MOBILE)\n#define DEFAULT_INPUT_OVERLAY_POINTER_ENABLE true\n#else\n#define DEFAULT_INPUT_OVERLAY_POINTER_ENABLE false\n#endif\n\n#define DEFAULT_INPUT_OVERLAY_ANALOG_RECENTER_ZONE 0\n\n#define DEFAULT_INPUT_OVERLAY_LIGHTGUN_PORT -1\n#define DEFAULT_INPUT_OVERLAY_LIGHTGUN_TRIGGER_ON_TOUCH true\n#define DEFAULT_INPUT_OVERLAY_LIGHTGUN_TRIGGER_DELAY 1\n#define DEFAULT_INPUT_OVERLAY_LIGHTGUN_MULTI_TOUCH_INPUT 0\n#define DEFAULT_INPUT_OVERLAY_LIGHTGUN_ALLOW_OFFSCREEN true\n#define DEFAULT_INPUT_OVERLAY_MOUSE_SPEED 1.0f\n#define DEFAULT_INPUT_OVERLAY_MOUSE_HOLD_TO_DRAG true\n#define DEFAULT_INPUT_OVERLAY_MOUSE_HOLD_MSEC 200\n#define DEFAULT_INPUT_OVERLAY_MOUSE_DTAP_TO_DRAG false\n#define DEFAULT_INPUT_OVERLAY_MOUSE_DTAP_MSEC 200\n#define DEFAULT_INPUT_OVERLAY_MOUSE_SWIPE_THRESHOLD 1.0f\n\n#ifdef UDEV_TOUCH_SUPPORT\n#define DEFAULT_INPUT_TOUCH_VMOUSE_POINTER true\n#define DEFAULT_INPUT_TOUCH_VMOUSE_MOUSE true\n#define DEFAULT_INPUT_TOUCH_VMOUSE_TOUCHPAD true\n#define DEFAULT_INPUT_TOUCH_VMOUSE_TRACKBALL false\n#define DEFAULT_INPUT_TOUCH_VMOUSE_GESTURE true\n#endif\n\n#include \"runtime_file_defines.h\"\n#ifdef HAVE_MENU\n#include \"menu/menu_defines.h\"\n\n#ifdef HAVE_LIBNX\n#define DEFAULT_MENU_USE_PREFERRED_SYSTEM_COLOR_THEME true\n#else\n#define DEFAULT_MENU_USE_PREFERRED_SYSTEM_COLOR_THEME false\n#endif\n\n#ifdef HAVE_OZONE\n/* Ozone colour theme: 1 == Basic Black */\n#define DEFAULT_OZONE_COLOR_THEME 1\n#define DEFAULT_OZONE_COLLAPSE_SIDEBAR false\n#define DEFAULT_OZONE_SCROLL_CONTENT_METADATA false\n#define DEFAULT_OZONE_THUMBNAIL_SCALE_FACTOR 1.0f\n#endif\n\n#if defined(HAVE_OZONE) || defined(HAVE_XMB)\n#define DEFAULT_OZONE_TRUNCATE_PLAYLIST_NAME true\n#define DEFAULT_OZONE_SORT_AFTER_TRUNCATE_PLAYLIST_NAME false\n#endif\n\n#define DEFAULT_SETTINGS_SHOW_DRIVERS true\n#define DEFAULT_SETTINGS_SHOW_VIDEO true\n#define DEFAULT_SETTINGS_SHOW_AUDIO true\n#define DEFAULT_SETTINGS_SHOW_INPUT true\n#define DEFAULT_SETTINGS_SHOW_LATENCY true\n#define DEFAULT_SETTINGS_SHOW_CORE true\n#define DEFAULT_SETTINGS_SHOW_CONFIGURATION true\n#define DEFAULT_SETTINGS_SHOW_SAVING true\n#define DEFAULT_SETTINGS_SHOW_LOGGING true\n#define DEFAULT_SETTINGS_SHOW_FILE_BROWSER true\n#define DEFAULT_SETTINGS_SHOW_FRAME_THROTTLE true\n#define DEFAULT_SETTINGS_SHOW_RECORDING true\n#define DEFAULT_SETTINGS_SHOW_ONSCREEN_DISPLAY true\n#define DEFAULT_SETTINGS_SHOW_USER_INTERFACE true\n#define DEFAULT_SETTINGS_SHOW_AI_SERVICE true\n#define DEFAULT_SETTINGS_SHOW_ACCESSIBILITY true\n#define DEFAULT_SETTINGS_SHOW_POWER_MANAGEMENT true\n#define DEFAULT_SETTINGS_SHOW_ACHIEVEMENTS true\n#define DEFAULT_SETTINGS_SHOW_NETWORK true\n#define DEFAULT_SETTINGS_SHOW_PLAYLISTS true\n#define DEFAULT_SETTINGS_SHOW_USER true\n#define DEFAULT_SETTINGS_SHOW_DIRECTORY true\n#define DEFAULT_SETTINGS_SHOW_STEAM true\n\n#define DEFAULT_QUICK_MENU_SHOW_RESUME_CONTENT true\n#define DEFAULT_QUICK_MENU_SHOW_RESTART_CONTENT true\n#define DEFAULT_QUICK_MENU_SHOW_CLOSE_CONTENT true\n#define DEFAULT_QUICK_MENU_SHOW_TAKE_SCREENSHOT true\n#define DEFAULT_QUICK_MENU_SHOW_SAVESTATE_SUBMENU true\n#define DEFAULT_QUICK_MENU_SHOW_SAVE_LOAD_STATE true\n#define DEFAULT_QUICK_MENU_SHOW_UNDO_SAVE_LOAD_STATE true\n#define DEFAULT_QUICK_MENU_SHOW_REPLAY false\n#define DEFAULT_QUICK_MENU_SHOW_ADD_TO_FAVORITES true\n#define DEFAULT_QUICK_MENU_SHOW_ADD_TO_PLAYLIST false\n#define DEFAULT_QUICK_MENU_SHOW_START_RECORDING true\n#define DEFAULT_QUICK_MENU_SHOW_START_STREAMING true\n#define DEFAULT_QUICK_MENU_SHOW_SET_CORE_ASSOCIATION true\n#define DEFAULT_QUICK_MENU_SHOW_RESET_CORE_ASSOCIATION true\n#define DEFAULT_QUICK_MENU_SHOW_CORE_OPTIONS true\n#define DEFAULT_QUICK_MENU_SHOW_CORE_OPTIONS_FLUSH false\n#define DEFAULT_QUICK_MENU_SHOW_CONTROLS true\n#define DEFAULT_QUICK_MENU_SHOW_LATENCY true\n#define DEFAULT_QUICK_MENU_SHOW_REWIND true\n#define DEFAULT_QUICK_MENU_SHOW_OVERLAYS true\n#define DEFAULT_QUICK_MENU_SHOW_VIDEO_LAYOUT false\n#define DEFAULT_QUICK_MENU_SHOW_CHEATS true\n#define DEFAULT_QUICK_MENU_SHOW_SHADERS true\n#define DEFAULT_QUICK_MENU_SHOW_INFORMATION true\n#define DEFAULT_QUICK_MENU_SHOW_SAVE_CORE_OVERRIDES true\n#define DEFAULT_QUICK_MENU_SHOW_SAVE_GAME_OVERRIDES true\n#define DEFAULT_QUICK_MENU_SHOW_SAVE_CONTENT_DIR_OVERRIDES true\n#ifdef HAVE_NETWORKING\n#define DEFAULT_QUICK_MENU_SHOW_DOWNLOAD_THUMBNAILS true\n#endif\n\n#define DEFAULT_MENU_SHOW_ONLINE_UPDATER true\n#if defined(HAVE_LAKKA) || defined(VITA)\n#define DEFAULT_MENU_SHOW_CORE_UPDATER false\n#else\n#define DEFAULT_MENU_SHOW_CORE_UPDATER true\n#endif\n#define DEFAULT_MENU_SHOW_LOAD_CORE true\n#define DEFAULT_MENU_SHOW_LOAD_CONTENT true\n#ifdef HAVE_CDROM\n#define DEFAULT_MENU_SHOW_LOAD_DISC true\n#define DEFAULT_MENU_SHOW_DUMP_DISC true\n#ifdef HAVE_LAKKA\n#define DEFAULT_MENU_SHOW_EJECT_DISC true\n#endif /* HAVE_LAKKA */\n#endif\n#define DEFAULT_MENU_SHOW_INFORMATION true\n#define DEFAULT_MENU_SHOW_CONFIGURATIONS true\n#define DEFAULT_MENU_SHOW_HELP true\n#define DEFAULT_MENU_SHOW_QUIT true\n#define DEFAULT_MENU_SHOW_RESTART true\n#define DEFAULT_MENU_SHOW_REBOOT true\n#define DEFAULT_MENU_SHOW_SHUTDOWN true\n#ifdef HAVE_MIST\n#define DEFAULT_MENU_SHOW_CORE_MANAGER_STEAM true\n#endif\n#if 0\n/* Thumbnailpack removal */\n#define DEFAULT_MENU_SHOW_LEGACY_THUMBNAIL_UPDATER false\n#endif\n#define DEFAULT_MENU_SHOW_SUBLABELS true\n#define DEFAULT_MENU_DYNAMIC_WALLPAPER_ENABLE true\n#define DEFAULT_MENU_SCROLL_FAST false\n#define DEFAULT_MENU_SCROLL_DELAY 256\n\n#define DEFAULT_KIOSK_MODE_ENABLE false\n#define DEFAULT_MENU_HORIZONTAL_ANIMATION true\n\n#define DEFAULT_MENU_TICKER_TYPE (TICKER_TYPE_LOOP)\n#define DEFAULT_MENU_TICKER_SPEED 2.0f\n#define DEFAULT_MENU_TICKER_SMOOTH true\n\n#if defined(HAVE_THREADS)\n#define DEFAULT_MENU_SAVESTATE_RESUME true\n#else\n#define DEFAULT_MENU_SAVESTATE_RESUME false\n#endif\n\n#define DEFAULT_MENU_INSERT_DISK_RESUME true\n\n#define DEFAULT_QUIT_ON_CLOSE_CONTENT QUIT_ON_CLOSE_CONTENT_DISABLED\n\n/* While the menu is active, supported drivers\n * will display a screensaver after SCREENSAVER_TIMEOUT\n * seconds of inactivity. A timeout of zero disables\n * the screensaver */\n#define DEFAULT_MENU_SCREENSAVER_TIMEOUT 0\n\n#if defined(HAVE_MATERIALUI) || defined(HAVE_XMB) || defined(HAVE_OZONE)\n/* When menu screensaver is enabled, specifies\n * animation effect and animation speed */\n#define DEFAULT_MENU_SCREENSAVER_ANIMATION MENU_SCREENSAVER_BLANK\n#define DEFAULT_MENU_SCREENSAVER_ANIMATION_SPEED 1.0f\n#endif\n\n#define DEFAULT_CONTENT_SHOW_SETTINGS true\n#define DEFAULT_CONTENT_SHOW_HISTORY true\n#define DEFAULT_CONTENT_SHOW_FAVORITES true\n#ifdef HAVE_IMAGEVIEWER\n#define DEFAULT_CONTENT_SHOW_IMAGES true\n#endif\n#define DEFAULT_CONTENT_SHOW_MUSIC false\n#if defined(HAVE_FFMPEG) || defined(HAVE_MPV)\n#define DEFAULT_CONTENT_SHOW_VIDEO true\n#endif\n#if defined(HAVE_NETWORKING)\n#if defined(_3DS)\n#define DEFAULT_CONTENT_SHOW_NETPLAY false\n#else\n#define DEFAULT_CONTENT_SHOW_NETPLAY true\n#endif\n#endif\n\n/* Specifies 'add content' visibility when using\n * menus WITH a dedicated 'Import Content' tab */\n#define DEFAULT_MENU_CONTENT_SHOW_ADD true\n/* Specifies 'add content' visibility when using\n * menus WITHOUT a dedicated 'Import Content' tab */\n#define DEFAULT_MENU_CONTENT_SHOW_ADD_ENTRY MENU_ADD_CONTENT_ENTRY_DISPLAY_PLAYLISTS_TAB\n\n#define DEFAULT_CONTENT_SHOW_PLAYLISTS true\n\n#if defined(HAVE_LIBRETRODB)\n#define DEFAULT_MENU_CONTENT_SHOW_EXPLORE true\n#endif\n#define DEFAULT_MENU_CONTENT_SHOW_CONTENTLESS_CORES MENU_CONTENTLESS_CORES_DISPLAY_SINGLE_PURPOSE\n\n#ifdef HAVE_XMB\n#define DEFAULT_XMB_ANIMATION                      0\n#define DEFAULT_XMB_VERTICAL_FADE_FACTOR           100\n#define DEFAULT_XMB_SHOW_TITLE_HEADER              true\n#define DEFAULT_XMB_SWITCH_ICONS                   true\n#define DEFAULT_XMB_TITLE_MARGIN                   5\n#define DEFAULT_XMB_TITLE_MARGIN_HORIZONTAL_OFFSET 0\n#define MAXIMUM_XMB_TITLE_MARGIN                   12\n#define DEFAULT_XMB_ALPHA_FACTOR                   90\n\n#define DEFAULT_MENU_FONT_COLOR_RED 255\n#define DEFAULT_MENU_FONT_COLOR_GREEN 255\n#define DEFAULT_MENU_FONT_COLOR_BLUE 255\n#ifdef HAVE_ODROIDGO2\n#define DEFAULT_XMB_MENU_LAYOUT 2\n#else\n#define DEFAULT_XMB_MENU_LAYOUT 0\n#endif\n#define DEFAULT_XMB_ICON_THEME XMB_ICON_THEME_MONOCHROME\n#define DEFAULT_XMB_THEME XMB_THEME_ELECTRIC_BLUE\n\n#if defined(HAVE_LAKKA) || defined(__arm__) || defined(__PPC64__) || defined(__ppc64__) || defined(__powerpc64__) || defined(__powerpc__) || defined(__ppc__) || defined(__POWERPC__)\n#define DEFAULT_XMB_SHADOWS_ENABLE false\n#else\n#define DEFAULT_XMB_SHADOWS_ENABLE true\n#endif\n#endif\n\n#define DEFAULT_MENU_FRAMEBUFFER_OPACITY 0.900f\n#define DEFAULT_MENU_WALLPAPER_OPACITY 0.900f\n#define DEFAULT_MENU_FOOTER_OPACITY 1.000f\n#define DEFAULT_MENU_HEADER_OPACITY 1.000f\n\n#if defined(HAVE_OPENGLES2) || (defined(__MACH__)  && defined(MAC_OS_X_VERSION_MAX_ALLOWED) && (MAC_OS_X_VERSION_MAX_ALLOWED < 101200))\n#define DEFAULT_MENU_SHADER_PIPELINE 1\n#else\n#define DEFAULT_MENU_SHADER_PIPELINE 2\n#endif\n\n#define DEFAULT_SHOW_ADVANCED_SETTINGS true\n\n#define DEFAULT_RGUI_COLOR_THEME RGUI_THEME_CLASSIC_GREEN\n#define DEFAULT_RGUI_TRANSPARENCY true\n\n#define DEFAULT_RGUI_INLINE_THUMBNAILS false\n#define DEFAULT_RGUI_SWAP_THUMBNAILS false\n#define DEFAULT_RGUI_THUMBNAIL_DOWNSCALER RGUI_THUMB_SCALE_POINT\n#define DEFAULT_RGUI_THUMBNAIL_DELAY 0\n#define DEFAULT_RGUI_INTERNAL_UPSCALE_LEVEL RGUI_UPSCALE_NONE\n#define DEFAULT_RGUI_FULL_WIDTH_LAYOUT true\n#define DEFAULT_RGUI_ASPECT RGUI_ASPECT_RATIO_4_3\n#define DEFAULT_RGUI_ASPECT_LOCK RGUI_ASPECT_RATIO_LOCK_NONE\n#define DEFAULT_RGUI_SHADOWS false\n#define DEFAULT_RGUI_PARTICLE_EFFECT RGUI_PARTICLE_EFFECT_NONE\n#define DEFAULT_RGUI_PARTICLE_EFFECT_SPEED 1.0f\n#define DEFAULT_RGUI_PARTICLE_EFFECT_SCREENSAVER true\n#define DEFAULT_RGUI_EXTENDED_ASCII false\n#define DEFAULT_RGUI_SWITCH_ICONS true\n#endif\n\n#ifdef HAVE_MENU\n#define DEFAULT_BLOCK_CONFIG_READ true\n#else\n#define DEFAULT_BLOCK_CONFIG_READ false\n#endif\n\n/* TODO/FIXME - this setting is thread-unsafe right now and can corrupt the stack - default to off */\n#define DEFAULT_AUTOMATICALLY_ADD_CONTENT_TO_PLAYLIST false\n\n#define DEFAULT_GAME_SPECIFIC_OPTIONS true\n#define DEFAULT_AUTO_OVERRIDES_ENABLE true\n#define DEFAULT_AUTO_REMAPS_ENABLE true\n#define DEFAULT_INITIAL_DISK_CHANGE_ENABLE true\n#define DEFAULT_GLOBAL_CORE_OPTIONS false\n#define DEFAULT_AUTO_SHADERS_ENABLE true\n\n#define DEFAULT_SORT_SAVEFILES_ENABLE true\n#define DEFAULT_SORT_SAVESTATES_ENABLE true\n#define DEFAULT_SORT_SAVEFILES_BY_CONTENT_ENABLE false\n#define DEFAULT_SORT_SAVESTATES_BY_CONTENT_ENABLE false\n#define DEFAULT_SORT_SCREENSHOTS_BY_CONTENT_ENABLE false\n\n#define DEFAULT_SAVESTATES_IN_CONTENT_DIR false\n#define DEFAULT_SAVEFILES_IN_CONTENT_DIR false\n#define DEFAULT_SYSTEMFILES_IN_CONTENT_DIR false\n#define DEFAULT_SCREENSHOTS_IN_CONTENT_DIR false\n\n#if defined(RS90) || defined(RETROFW) || defined(MIYOO) || defined(SWITCH) || defined(ORBIS) || defined(__WINRT__)\n#define DEFAULT_MENU_TOGGLE_GAMEPAD_COMBO INPUT_COMBO_START_SELECT\n#elif defined(_XBOX1) || defined(__PS3__) || defined(_XBOX360) || defined(DINGUX)\n#define DEFAULT_MENU_TOGGLE_GAMEPAD_COMBO INPUT_COMBO_L3_R3\n#elif defined(PS2) || defined(PSP)\n#define DEFAULT_MENU_TOGGLE_GAMEPAD_COMBO INPUT_COMBO_HOLD_START\n#elif defined(VITA)\n#define DEFAULT_MENU_TOGGLE_GAMEPAD_COMBO INPUT_COMBO_L1_R1_START_SELECT\n#elif TARGET_OS_TV\n#define DEFAULT_MENU_TOGGLE_GAMEPAD_COMBO INPUT_COMBO_DOWN_Y_L_R\n#else\n#define DEFAULT_MENU_TOGGLE_GAMEPAD_COMBO INPUT_COMBO_NONE\n#endif\n\n#define DEFAULT_QUIT_GAMEPAD_COMBO INPUT_COMBO_NONE\n\n#if defined(VITA)\n#define DEFAULT_INPUT_BACKTOUCH_ENABLE false\n#define DEFAULT_INPUT_BACKTOUCH_TOGGLE false\n#endif\n\n#if defined(ANDROID) || defined(IOS)\n#define DEFAULT_OVERLAY_ENABLE_AUTOPREFERRED true\n#else\n#define DEFAULT_OVERLAY_ENABLE_AUTOPREFERRED false\n#endif\n\n#if defined(HAVE_OVERLAY)\n#if defined(RARCH_MOBILE)\n#define DEFAULT_OVERLAY_SHOW_INPUTS OVERLAY_SHOW_INPUT_TOUCHED\n#else\n#define DEFAULT_OVERLAY_SHOW_INPUTS OVERLAY_SHOW_INPUT_PHYSICAL\n#endif\n#endif\n\n#define DEFAULT_OVERLAY_SHOW_INPUTS_PORT 0\n\n#define DEFAULT_OVERLAY_DPAD_DIAGONAL_SENSITIVITY 80\n#define DEFAULT_OVERLAY_ABXY_DIAGONAL_SENSITIVITY 50\n\n#if defined(ANDROID) || defined(_WIN32) || defined(HAVE_STEAM) || TARGET_OS_TV\n#define DEFAULT_MENU_SWAP_OK_CANCEL_BUTTONS true\n#else\n#define DEFAULT_MENU_SWAP_OK_CANCEL_BUTTONS false\n#endif\n#define DEFAULT_MENU_SWAP_SCROLL_BUTTONS false\n\n#if defined(WIIU)\n#define DEFAULT_ALL_USERS_CONTROL_MENU true\n#else\n#define DEFAULT_ALL_USERS_CONTROL_MENU false\n#endif\n\n#define DEFAULT_QUIT_PRESS_TWICE true\n\n#define DEFAULT_LOG_TO_FILE false\n\n#define DEFAULT_LOG_TO_FILE_TIMESTAMP false\n\n/* Crop overscanned frames. */\n#define DEFAULT_CROP_OVERSCAN true\n\n/* Font size for on-screen messages. */\n#if defined(DINGUX)\n#define DEFAULT_FONT_SIZE 12\n#elif defined(PS2)\n#define DEFAULT_FONT_SIZE 16\n#else\n#define DEFAULT_FONT_SIZE 32\n#endif\n\n/* Offset for where messages will be placed on-screen.\n * Values are in range [0.0, 1.0]. */\n#define DEFAULT_MESSAGE_POS_OFFSET_X 0.05f\n#define DEFAULT_MESSAGE_POS_OFFSET_Y 0.05f\n\n/* Color of the message.\n * RGB hex value. */\n#define DEFAULT_MESSAGE_COLOR 0xffff00\n\n#define DEFAULT_MESSAGE_BGCOLOR_ENABLE false\n#define DEFAULT_MESSAGE_BGCOLOR_RED 0\n#define DEFAULT_MESSAGE_BGCOLOR_GREEN 0\n#define DEFAULT_MESSAGE_BGCOLOR_BLUE 0\n#define DEFAULT_MESSAGE_BGCOLOR_OPACITY 1.0f\n\n/* Record post-filtered (CPU filter) video,\n * rather than raw game output. */\n#define DEFAULT_POST_FILTER_RECORD false\n\n/* Screenshots post-shaded GPU output if available. */\n#define DEFAULT_GPU_SCREENSHOT true\n\n/* Watch shader files for changes and auto-apply as necessary. */\n#define DEFAULT_VIDEO_SHADER_WATCH_FILES false\n\n/* Initialise file browser with last used directory\n * when selecting shader presets/passes via the menu */\n#define DEFAULT_VIDEO_SHADER_REMEMBER_LAST_DIR false\n\n/* Screenshots named automatically. */\n#define DEFAULT_AUTO_SCREENSHOT_FILENAME true\n\n/* Record post-shaded GPU output instead of raw game footage if available. */\n#define DEFAULT_GPU_RECORD false\n\n/* OSD-messages. */\n#define DEFAULT_FONT_ENABLE true\n\n/* The accurate refresh rate of your monitor (Hz).\n * This is used to calculate audio input rate with the formula:\n * audio_input_rate = game_input_rate * display_refresh_rate /\n * game_refresh_rate.\n *\n * If the implementation does not report any values,\n * NTSC defaults will be assumed for compatibility.\n * This value should stay close to 60Hz to avoid large pitch changes.\n * If your monitor does not run at 60Hz, or something close to it,\n * disable VSync, and leave this at its default. */\n#ifdef _3DS\n#define DEFAULT_REFRESH_RATE ((32730.0f * 8192.0f) / 4481134.0f)\n#elif defined(RARCH_CONSOLE)\n#define DEFAULT_REFRESH_RATE (60 / 1.001f)\n#else\n#define DEFAULT_REFRESH_RATE (60)\n#endif\n#define DEFAULT_CRT_REFRESH_RATE (DEFAULT_REFRESH_RATE)\n\n/* Allow games to set rotation. If false, rotation requests are\n * honored, but ignored.\n * Used for setups where one manually rotates the monitor. */\n#define DEFAULT_ALLOW_ROTATE true\n\n#ifdef _3DS\n/* Enable New3DS clock and L2 cache */\n#define DEFAULT_NEW_3DS_SPEEDUP_ENABLE true\n/* Enable bottom LCD screen */\n#define DEFAULT_VIDEO_3DS_LCD_BOTTOM true\n/* Sets video display mode (3D, 2D, etc.) */\n#define DEFAULT_VIDEO_3DS_DISPLAY_MODE CTR_VIDEO_MODE_3D\n\n#define DEFAULT_BOTTOM_FONT_ENABLE true\n#define DEFAULT_BOTTOM_FONT_COLOR 255\n#define DEFAULT_BOTTOM_FONT_SCALE 1.48f\n#endif\n\n#ifdef WIIU\n/* On Wii U, whether to optimize for the native TV resolution\n * or exactly 2x the Wii U GamePad resolution. */\n#define DEFAULT_WIIU_PREFER_DRC false\n#endif\n\n/* AUDIO */\n\n/* Will enable audio or not. */\n#define DEFAULT_AUDIO_ENABLE true\n\n/* Enable menu audio sounds. */\n#define DEFAULT_AUDIO_ENABLE_MENU false\n#define DEFAULT_AUDIO_ENABLE_MENU_OK false\n#define DEFAULT_AUDIO_ENABLE_MENU_CANCEL false\n#define DEFAULT_AUDIO_ENABLE_MENU_NOTICE false\n#define DEFAULT_AUDIO_ENABLE_MENU_BGM    false\n#define DEFAULT_AUDIO_ENABLE_MENU_SCROLL false\n\n#ifdef HAVE_GFX_WIDGETS\n#define DEFAULT_MENU_ENABLE_WIDGETS true\n#else\n#define DEFAULT_MENU_ENABLE_WIDGETS false\n#endif\n\n/* Display an animation when loading content\n * > Currently implemented only as a widget */\n#define DEFAULT_MENU_SHOW_LOAD_CONTENT_ANIMATION DEFAULT_MENU_ENABLE_WIDGETS\n\n/* Display a notification when successfully\n * connecting/disconnecting an autoconfigured\n * controller\n * > Disabled by default on the Switch */\n#if defined(HAVE_LIBNX) && defined(HAVE_GFX_WIDGETS)\n#define DEFAULT_NOTIFICATION_SHOW_AUTOCONFIG false\n#else\n#define DEFAULT_NOTIFICATION_SHOW_AUTOCONFIG true\n#endif\n\n/* Display a notification when cheats are being\n * applied */\n#define DEFAULT_NOTIFICATION_SHOW_CHEATS_APPLIED true\n\n/* Display a notification when applying an\n * IPS/BPS/UPS/Xdelta patch file */\n#define DEFAULT_NOTIFICATION_SHOW_PATCH_APPLIED true\n\n/* Display a notification when loading an\n * input remap file */\n#define DEFAULT_NOTIFICATION_SHOW_REMAP_LOAD true\n\n/* Display a notification when loading a\n * configuration override file */\n#define DEFAULT_NOTIFICATION_SHOW_CONFIG_OVERRIDE_LOAD true\n\n/* Display a notification when automatically restoring\n * at launch the last used disk of multi-disk content */\n#define DEFAULT_NOTIFICATION_SHOW_SET_INITIAL_DISK true\n\n/* Display disc control notifications */\n#define DEFAULT_NOTIFICATION_SHOW_DISK_CONTROL true\n\n/* Display save state notifications */\n#define DEFAULT_NOTIFICATION_SHOW_SAVE_STATE true\n\n/* Display a notification when fast forwarding\n * content */\n#define DEFAULT_NOTIFICATION_SHOW_FAST_FORWARD true\n\n#if defined(HAVE_SCREENSHOTS)\n/*Display a notification when taking a screenshot*/\n#define DEFAULT_NOTIFICATION_SHOW_SCREENSHOT true\n\n/*Desired duration of the screenshot notification*/\n#define DEFAULT_NOTIFICATION_SHOW_SCREENSHOT_DURATION 0\n\n/* Display a white flashing effect with the desired\n * duration when taking a screenshot*/\n#define DEFAULT_NOTIFICATION_SHOW_SCREENSHOT_FLASH 0\n#endif\n\n/* Display a notification when setting the refresh rate*/\n#if defined(_3DS) || (defined(DINGUX) && defined(DINGUX_BETA))\n/* 3DS and OpenDingux Beta devices set refresh rate\n * on gfx driver init - set default notification\n * state to 'false' in order to avoid OSD log spam */\n#define DEFAULT_NOTIFICATION_SHOW_REFRESH_RATE false\n#else\n#define DEFAULT_NOTIFICATION_SHOW_REFRESH_RATE true\n#endif\n\n#ifdef HAVE_NETWORKING\n#define DEFAULT_NOTIFICATION_SHOW_NETPLAY_EXTRA false\n#endif\n\n#ifdef HAVE_MENU\n#define DEFAULT_NOTIFICATION_SHOW_WHEN_MENU_IS_ALIVE false\n#endif\n\n/* Output samplerate. */\n#if defined(GEKKO) || defined(MIYOO)\n#define DEFAULT_OUTPUT_RATE 32000\n#define DEFAULT_INPUT_RATE  32000\n#elif defined(_3DS) || defined(RETROFW)\n#define DEFAULT_OUTPUT_RATE 32730\n#define DEFAULT_INPUT_RATE  32730\n#elif defined(EMSCRIPTEN)\n#define DEFAULT_OUTPUT_RATE 44100\n#define DEFAULT_INPUT_RATE  44100\n#else\n#define DEFAULT_OUTPUT_RATE 48000\n#define DEFAULT_INPUT_RATE  48000\n#endif\n\n/* Audio device (e.g. hw:0,0 or /dev/audio). If NULL, will use defaults. */\n#define DEFAULT_AUDIO_DEVICE NULL\n\n/* Desired audio latency in milliseconds. Might not be honored\n * if driver can't provide given latency. */\n#if defined(ANDROID) || defined(EMSCRIPTEN) || defined(RETROFW) || defined(MIYOO)\n/* For most Android devices, 64ms is way too low. */\n#define DEFAULT_OUT_LATENCY 128\n#define DEFAULT_IN_LATENCY 128\n#else\n#define DEFAULT_OUT_LATENCY 64\n#define DEFAULT_IN_LATENCY 64\n#endif\n\n/* Will sync audio. (recommended) */\n#define DEFAULT_AUDIO_SYNC true\n\n/* Audio rate control. */\n#if !defined(RARCH_CONSOLE)\n#define DEFAULT_RATE_CONTROL true\n#else\n#define DEFAULT_RATE_CONTROL false\n#endif\n\n/* Rate control delta. Defines how much rate_control\n * is allowed to adjust input rate. */\n#define DEFAULT_RATE_CONTROL_DELTA  0.005f\n\n/* Maximum timing skew. Defines how much adjust_system_rates\n * is allowed to adjust input rate. */\n#define DEFAULT_MAX_TIMING_SKEW  0.05f\n\n/* Default audio volume in dB. (0.0 dB == unity gain). */\n#define DEFAULT_AUDIO_VOLUME 0.0f\n\n/* Default audio volume of the audio mixer in dB. (0.0 dB == unity gain). */\n#define DEFAULT_AUDIO_MIXER_VOLUME 0.0f\n\n#ifdef HAVE_WASAPI\n/* WASAPI defaults */\n#define DEFAULT_WASAPI_EXCLUSIVE_MODE false\n#define DEFAULT_WASAPI_FLOAT_FORMAT false\n/* Automatic shared mode buffer */\n#define DEFAULT_WASAPI_SH_BUFFER_LENGTH 0\n#endif\n\n#if TARGET_OS_IOS\n/* Respect silent mode (false will render audio in silent mode) */\n#define DEFAULT_AUDIO_RESPECT_SILENT_MODE true\n#endif\n\n/* Automatically mute audio when fast forward\n * is enabled */\n#define DEFAULT_AUDIO_FASTFORWARD_MUTE false\n/* Speed up audio to match fast-forward speed up.\n * Avoids crackling */\n#define DEFAULT_AUDIO_FASTFORWARD_SPEEDUP false\n\n#ifdef HAVE_MICROPHONE\n/* Microphone support */\n#define DEFAULT_MICROPHONE_ENABLE true\n#define DEFAULT_MICROPHONE_DEVICE NULL\n\n#ifdef HAVE_WASAPI\n#define DEFAULT_WASAPI_MICROPHONE_SH_BUFFER_LENGTH 0\n#endif\n#endif\n\n/* MISC */\n\n/* Enables displaying the current frames per second. */\n#define DEFAULT_FPS_SHOW false\n\n/* FPS display will be updated at the set interval (in frames) */\n#define DEFAULT_FPS_UPDATE_INTERVAL 256\n\n/* Memory status display will be updated at the set interval (in frames) */\n#define DEFAULT_MEMORY_UPDATE_INTERVAL 256\n\n/* Enables displaying the current frame count. */\n#define DEFAULT_FRAMECOUNT_SHOW false\n\n/* Includes displaying the current memory usage/total with FPS/Frames. */\n#define DEFAULT_MEMORY_SHOW false\n\n/* Enables displaying various timing statistics. */\n#define DEFAULT_STATISTICS_SHOW false\n\n/* Enables displaying the current netplay room ping. */\n#define DEFAULT_NETPLAY_PING_SHOW false\n\n/* Enables use of rewind. This will incur some memory footprint\n * depending on the save state buffer. */\n#define DEFAULT_REWIND_ENABLE false\n\n/* When set, any time a cheat is toggled it is immediately applied. */\n#define DEFAULT_APPLY_CHEATS_AFTER_TOGGLE false\n\n/* When set, all enabled cheats are auto-applied when a game is loaded. */\n#define DEFAULT_APPLY_CHEATS_AFTER_LOAD false\n\n\n#if defined(RETROFW) || defined(MIYOO)\n/*RETROFW jz4760 has significant slowdown with default settings */\n#define DEFAULT_REWIND_BUFFER_SIZE (1 << 20)\n#define DEFAULT_REWIND_BUFFER_SIZE_STEP 1\n#define DEFAULT_REWIND_GRANULARITY 6\n#else\n/* The buffer size for the rewind buffer. This needs to be about\n * 15-20MB per minute. Very game dependant. */\n#define DEFAULT_REWIND_BUFFER_SIZE (20 << 20) /* 20MiB */\n\n/* The amount of MB to increase/decrease the rewind_buffer_size when it is changed via the UI. */\n#define DEFAULT_REWIND_BUFFER_SIZE_STEP 10 /* 10MB */\n\n/* How many frames to rewind at a time. */\n#define DEFAULT_REWIND_GRANULARITY 1\n#endif\n\n/* Pause gameplay when window loses focus. */\n#if defined(EMSCRIPTEN)\n#define DEFAULT_PAUSE_NONACTIVE false\n#else\n#define DEFAULT_PAUSE_NONACTIVE true\n#endif\n\n/* Pause gameplay when controller disconnects. */\n#define DEFAULT_PAUSE_ON_DISCONNECT false\n\n/* Saves non-volatile SRAM at a regular interval.\n * It is measured in seconds. A value of 0 disables autosave. */\n#if defined(__i386__) || defined(__i486__) || defined(__i686__) || defined(__x86_64__) || defined(_M_X64) || defined(_WIN32) || defined(OSX) || defined(ANDROID) || defined(IOS) || defined(DINGUX)\n/* Flush to file every 10 seconds on modern platforms by default */\n#define DEFAULT_AUTOSAVE_INTERVAL 10\n#else\n/* Default to disabled on I/O-constrained platforms */\n#define DEFAULT_AUTOSAVE_INTERVAL 0\n#endif\n\n/* Netplay lobby filters */\n#define DEFAULT_NETPLAY_SHOW_ONLY_CONNECTABLE     true\n#define DEFAULT_NETPLAY_SHOW_ONLY_INSTALLED_CORES false\n#define DEFAULT_NETPLAY_SHOW_PASSWORDED           true\n\n/* Publicly announce netplay */\n#define DEFAULT_NETPLAY_PUBLIC_ANNOUNCE true\n\n/* Start netplay in spectator mode */\n#define DEFAULT_NETPLAY_START_AS_SPECTATOR false\n\n/* Netplay chat fading toggle */\n#define DEFAULT_NETPLAY_FADE_CHAT true\n\n/* Netplay chat colors */\n#define DEFAULT_NETPLAY_CHAT_COLOR_NAME 0x008000\n#define DEFAULT_NETPLAY_CHAT_COLOR_MSG 0xFFFFFF\n\n/* Allow players to pause */\n#define DEFAULT_NETPLAY_ALLOW_PAUSING false\n\n/* Allow connections in slave mode */\n#define DEFAULT_NETPLAY_ALLOW_SLAVES true\n\n/* Require connections only in slave mode */\n#define DEFAULT_NETPLAY_REQUIRE_SLAVES false\n\n/* When being client over netplay, use keybinds for\n * user 1 rather than user 2. */\n#define DEFAULT_NETPLAY_CLIENT_SWAP_INPUT true\n\n#define DEFAULT_NETPLAY_NAT_TRAVERSAL false\n\n#define DEFAULT_NETPLAY_DELAY_FRAMES 16\n\n#define DEFAULT_NETPLAY_CHECK_FRAMES 600\n\n#define DEFAULT_NETPLAY_USE_MITM_SERVER false\n\n#define DEFAULT_NETPLAY_MITM_SERVER \"nyc\"\n\n#ifdef HAVE_NETWORKING\n#define DEFAULT_NETPLAY_MAX_CONNECTIONS 3\n#define DEFAULT_NETPLAY_MAX_PING 0\n\n#define DEFAULT_NETPLAY_SHARE_DIGITAL RARCH_NETPLAY_SHARE_DIGITAL_NO_SHARING\n#define DEFAULT_NETPLAY_SHARE_ANALOG  RARCH_NETPLAY_SHARE_ANALOG_NO_SHARING\n#endif\n\n/* On save state load, block SRAM from being overwritten.\n * This could potentially lead to buggy games. */\n#define DEFAULT_BLOCK_SRAM_OVERWRITE false\n\n/* When saving savestates, state index is automatically\n * incremented before saving.\n * When the content is loaded, state index will be set\n * to the highest existing value. */\n#define DEFAULT_SAVESTATE_AUTO_INDEX false\n\n/* Specifies the maximum number of savestates to keep\n * when savestate auto index is enabled\n * > When limit is exceeded, savestate with the lowest\n *   index will be deleted automatically when creating\n *   a new savestate\n * > Setting value to zero disables the limit (no\n *   savestates will be deleted in this case) */\n#define DEFAULT_SAVESTATE_MAX_KEEP 0\n\n/* When recording replays, replay index is automatically\n * incremented before recording starts.\n * When the content is loaded, replay index will be set\n * to the highest existing value. */\n#define DEFAULT_REPLAY_AUTO_INDEX true\n\n/* Specifies the maximum number of replays to keep\n * when replay auto index is enabled\n * > When limit is exceeded, replay with the lowest\n *   index will be deleted automatically when creating\n *   a new replay\n * > Setting value to zero disables the limit (no\n *   replays will be deleted in this case) */\n#define DEFAULT_REPLAY_MAX_KEEP 0\n\n/* Specifies how often checkpoints will be saved to replay files during recording.\n * > Setting value to zero disables recording checkpoints. */\n#define DEFAULT_REPLAY_CHECKPOINT_INTERVAL 0\n\n/* Automatically saves a savestate at the end of RetroArch's lifetime.\n * The path is $SRAM_PATH.auto.\n * RetroArch will automatically load any savestate with this path on\n * startup if savestate_auto_load is set. */\n#define DEFAULT_SAVESTATE_AUTO_SAVE false\n#define DEFAULT_SAVESTATE_AUTO_LOAD false\n\n#define DEFAULT_SAVESTATE_THUMBNAIL_ENABLE false\n\n/* When creating save (srm) files, compress\n * written data */\n#define DEFAULT_SAVE_FILE_COMPRESSION false\n\n/* When creating save state files, compress\n * written data */\n#if defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP\n#define DEFAULT_SAVESTATE_FILE_COMPRESSION false\n#else\n#define DEFAULT_SAVESTATE_FILE_COMPRESSION true\n#endif\n\n/* Slowmotion ratio. */\n#define DEFAULT_SLOWMOTION_RATIO 3.0f\n\n/* Maximum fast forward ratio. */\n#define DEFAULT_FASTFORWARD_RATIO 0.0f\n#define MAXIMUM_FASTFORWARD_RATIO 50.0f\n\n/* Skip frames when fast forwarding. */\n#define DEFAULT_FASTFORWARD_FRAMESKIP true\n\n/* Enable runloop for variable refresh rate screens. Force x1 speed while handling fast forward too. */\n#define DEFAULT_VRR_RUNLOOP_ENABLE false\n\n/* Run core logic one or more frames ahead then load the state back to reduce perceived input lag. */\n#define DEFAULT_RUN_AHEAD_FRAMES 1\n\n/* When using the Run Ahead feature, use a secondary instance of the core. */\n#define DEFAULT_RUN_AHEAD_SECONDARY_INSTANCE true\n\n/* Hide warning messages when using the Run Ahead feature. */\n#define DEFAULT_RUN_AHEAD_HIDE_WARNINGS false\n\n/* Enable stdin/network command interface. */\n#define DEFAULT_NETWORK_CMD_ENABLE false\n#define DEFAULT_NETWORK_CMD_PORT 55355\n#define DEFAULT_NETWORK_REMOTE_BASE_PORT 55400\n#define DEFAULT_STDIN_CMD_ENABLE false\n\n#define DEFAULT_NETWORK_BUILDBOT_AUTO_EXTRACT_ARCHIVE true\n#define DEFAULT_NETWORK_BUILDBOT_SHOW_EXPERIMENTAL_CORES false\n\n/* Automatically create a backup whenever a core is\n * updated via the online updater\n * > Enable by default on all modern platforms with\n *   online updater support */\n#if defined(HAVE_ONLINE_UPDATER) && (defined(__i386__) || defined(__i486__) || defined(__i686__) || defined(__x86_64__) || defined(_M_X64) || defined(_WIN32) || defined(OSX) || defined(ANDROID) || defined(IOS))\n#define DEFAULT_CORE_UPDATER_AUTO_BACKUP true\n#else\n#define DEFAULT_CORE_UPDATER_AUTO_BACKUP false\n#endif\n/* Number of automatic core backups to retain\n * (oldest backup will be deleted when creating\n * a new one) */\n#define DEFAULT_CORE_UPDATER_AUTO_BACKUP_HISTORY_SIZE 1\n\n#define DEFAULT_NETWORK_ON_DEMAND_THUMBNAILS false\n\n/* Number of entries that will be kept in content history playlist file. */\n#define DEFAULT_CONTENT_HISTORY_SIZE 200\n\n/* Number of entries that will be kept in content favorites playlist file.\n * -1 == 'unlimited' (99999) */\n#define DEFAULT_CONTENT_FAVORITES_SIZE 200\n\n/* Sort all playlists (apart from histories) alphabetically */\n#define DEFAULT_PLAYLIST_SORT_ALPHABETICAL true\n\n/* File format to use when writing playlists to disk */\n#define DEFAULT_PLAYLIST_USE_OLD_FORMAT false\n\n/* When creating/updating playlists, compress written data */\n#define DEFAULT_PLAYLIST_COMPRESSION false\n\n#ifdef HAVE_MENU\n/* Specify when to display 'core name' inline on playlist entries */\n#define DEFAULT_PLAYLIST_SHOW_INLINE_CORE_NAME PLAYLIST_INLINE_CORE_DISPLAY_HIST_FAV\n\n/* Specifies which runtime record to use on playlist sublabels */\n#define DEFAULT_PLAYLIST_SUBLABEL_RUNTIME_TYPE PLAYLIST_RUNTIME_PER_CORE\n\n/* Specifies time/date display format for runtime 'last played' data */\n#define DEFAULT_PLAYLIST_SUBLABEL_LAST_PLAYED_STYLE PLAYLIST_LAST_PLAYED_STYLE_YMD_HM\n\n#define DEFAULT_PLAYLIST_ENTRY_REMOVE_ENABLE PLAYLIST_ENTRY_REMOVE_ENABLE_ALL\n#endif\n\n#define DEFAULT_SCAN_WITHOUT_CORE_MATCH false\n\n#define DEFAULT_SCAN_SERIAL_AND_CRC false\n\n#ifdef __WINRT__\n/* Be paranoid about WinRT file I/O performance, and leave this disabled by\n * default */\n#define DEFAULT_PLAYLIST_SHOW_SUBLABELS false\n#else\n#define DEFAULT_PLAYLIST_SHOW_SUBLABELS true\n#endif\n\n#define DEFAULT_PLAYLIST_SHOW_HISTORY_ICONS PLAYLIST_SHOW_HISTORY_ICONS_MAIN\n\n/* Show the indices of playlist entries in\n * a menu-driver-specific fashion */\n#define DEFAULT_PLAYLIST_SHOW_ENTRY_IDX true\n\n#define DEFAULT_PLAYLIST_FUZZY_ARCHIVE_MATCH false\n\n#define DEFAULT_PLAYLIST_PORTABLE_PATHS false\n\n#define DEFAULT_PLAYLIST_USE_FILENAME false\n\n#define DEFAULT_PLAYLIST_ALLOW_NON_PNG false\n\n/* Show Menu start-up screen on boot. */\n#define DEFAULT_MENU_SHOW_START_SCREEN true\n\n/* Default scale factor for non-framebuffer-based display\n * drivers and display widgets */\n#if defined(VITA)\n#define DEFAULT_MENU_SCALE_FACTOR 1.5f\n#elif defined(__ANDROID__)\n#define DEFAULT_MENU_SCALE_FACTOR 0.75f\n#else\n#define DEFAULT_MENU_SCALE_FACTOR 1.0f\n#endif\n/* Specifies whether display widgets should be scaled\n * automatically using the default menu scale factor */\n#define DEFAULT_MENU_WIDGET_SCALE_AUTO true\n/* Default scale factor for display widgets when widget\n * auto scaling is disabled (fullscreen mode) */\n#define DEFAULT_MENU_WIDGET_SCALE_FACTOR 1.0f\n/* Default scale factor for display widgets when widget\n * auto scaling is disabled (windowed mode) */\n#define DEFAULT_MENU_WIDGET_SCALE_FACTOR_WINDOWED 1.0f\n\n/* Log level for the frontend */\n#define DEFAULT_FRONTEND_LOG_LEVEL 1\n\n/* Log level for libretro cores (GET_LOG_INTERFACE). */\n#define DEFAULT_LIBRETRO_LOG_LEVEL 1\n\n#ifndef RARCH_DEFAULT_PORT\n#ifndef VITA\n#define RARCH_DEFAULT_PORT 55435\n#else\n#define RARCH_DEFAULT_PORT 19492\n#endif\n#endif\n\n#ifndef RARCH_STREAM_DEFAULT_PORT\n#define RARCH_STREAM_DEFAULT_PORT 56400\n#endif\n\n/* KEYBINDS, JOYPAD */\n\n/* Axis threshold (between 0.0 and 1.0)\n * How far an axis must be tilted to result in a button press. */\n#define DEFAULT_AXIS_THRESHOLD 0.5f\n#define DEFAULT_ANALOG_DEADZONE 0.0f\n#define DEFAULT_ANALOG_SENSITIVITY 1.0f\n\n/* Describes speed of which turbo-enabled buttons toggle. */\n#define DEFAULT_TURBO_PERIOD 6\n#define DEFAULT_TURBO_DUTY_CYCLE 3\n#define DEFAULT_TURBO_MODE 0\n#define DEFAULT_TURBO_DEFAULT_BTN RETRO_DEVICE_ID_JOYPAD_B\n#define DEFAULT_ALLOW_TURBO_DPAD false\n\n/* Enable automatic mouse grab by default\n * only on Android */\n#if defined(ANDROID)\n#define DEFAULT_INPUT_AUTO_MOUSE_GRAB true\n#else\n#define DEFAULT_INPUT_AUTO_MOUSE_GRAB false\n#endif\n\n#if TARGET_OS_IPHONE\n#define DEFAULT_INPUT_KEYBOARD_GAMEPAD_ENABLE false\n#else\n#define DEFAULT_INPUT_KEYBOARD_GAMEPAD_ENABLE true\n#endif\n\n/* Enable input auto-detection. Will attempt to autoconfigure\n * gamepads, plug-and-play style. */\n#define DEFAULT_INPUT_AUTODETECT_ENABLE true\n\n/* Enables accelerometer/gyroscope/illuminance\n * sensor input, if supported */\n#if defined(ANDROID)\n/* Hardware sensors cause substantial battery\n * drain on Android... */\n#define DEFAULT_INPUT_SENSORS_ENABLE false\n#else\n#define DEFAULT_INPUT_SENSORS_ENABLE true\n#endif\n\n/* Automatically enable game focus when running or\n * resuming content */\n#define DEFAULT_INPUT_AUTO_GAME_FOCUS AUTO_GAME_FOCUS_OFF\n\n/* Show the input descriptors set by the core instead\n * of the default ones. */\n#define DEFAULT_INPUT_DESCRIPTOR_LABEL_SHOW true\n#define DEFAULT_INPUT_DESCRIPTOR_HIDE_UNBOUND false\n\n#if defined(DINGUX)\n#define DEFAULT_INPUT_MAX_USERS 1\n#else\n#define DEFAULT_INPUT_MAX_USERS 8\n#endif\n\n#define DEFAULT_INPUT_BIND_TIMEOUT 3\n#define DEFAULT_INPUT_BIND_HOLD 0\n#define DEFAULT_INPUT_POLL_TYPE_BEHAVIOR 2\n#define DEFAULT_INPUT_HOTKEY_BLOCK_DELAY 5\n#define DEFAULT_INPUT_HOTKEY_DEVICE_MERGE false\n\n#define DEFAULT_GFX_THUMBNAILS_DEFAULT 3\n\n#define DEFAULT_MENU_LEFT_THUMBNAILS_DEFAULT 0\n#define DEFAULT_MENU_ICON_THUMBNAILS_DEFAULT 0\n\n#define DEFAULT_GFX_THUMBNAIL_UPSCALE_THRESHOLD 0\n\n#ifdef HAVE_MENU\n#if defined(RS90) || defined(MIYOO)\n/* The RS-90 has a hardware clock that is neither\n * configurable nor persistent, rendering it useless.\n * We therefore hide it in the menu by default. */\n#define DEFAULT_MENU_TIMEDATE_ENABLE false\n#else\n#define DEFAULT_MENU_TIMEDATE_ENABLE true\n#endif\n#define DEFAULT_MENU_TIMEDATE_STYLE          MENU_TIMEDATE_STYLE_DDMM_HM\n#define DEFAULT_MENU_TIMEDATE_DATE_SEPARATOR MENU_TIMEDATE_DATE_SEPARATOR_HYPHEN\n#define DEFAULT_MENU_REMEMBER_SELECTION      MENU_REMEMBER_SELECTION_ALWAYS\n#endif\n\n#define DEFAULT_XMB_VERTICAL_THUMBNAILS false\n\n#define DEFAULT_XMB_THUMBNAIL_SCALE_FACTOR 100\n\n#ifdef IOS\n#define DEFAULT_UI_COMPANION_START_ON_BOOT false\n#else\n#define DEFAULT_UI_COMPANION_START_ON_BOOT true\n#endif\n\n#define DEFAULT_UI_COMPANION_ENABLE false\n/* Currently only used to show the WIMP UI on startup */\n#define DEFAULT_UI_COMPANION_TOGGLE false\n\n/* Only init the WIMP UI for this session if this is enabled */\n#define DEFAULT_DESKTOP_MENU_ENABLE true\n\n/* Keep track of how long each core+content has been running for over time */\n\n#ifdef __WINRT__\n/* Be paranoid about WinRT file I/O performance, and leave this disabled by\n * default */\n#define DEFAULT_CONTENT_RUNTIME_LOG false\n#else\n#define DEFAULT_CONTENT_RUNTIME_LOG true\n#endif\n\n/* Keep track of how long each content has been running\n * for over time (ignores core) */\n#define DEFAULT_CONTENT_RUNTIME_LOG_AGGREGATE false\n\n#define DEFAULT_UI_MENUBAR_ENABLE true\n\n#if defined(__QNX__) || defined(_XBOX1) || defined(_XBOX360) || (defined(__MACH__) && defined(IOS)) || defined(ANDROID) || defined(WIIU) || defined(HAVE_NEON) || defined(GEKKO) || defined(__ARM_NEON__) || defined(__PS3__)\n#define DEFAULT_AUDIO_RESAMPLER_QUALITY_LEVEL RESAMPLER_QUALITY_LOWER\n#elif defined(PSP) || defined(_3DS) || defined(VITA) || defined(PS2) || defined(DINGUX) || defined(EMSCRIPTEN)\n#define DEFAULT_AUDIO_RESAMPLER_QUALITY_LEVEL RESAMPLER_QUALITY_LOWEST\n#else\n#define DEFAULT_AUDIO_RESAMPLER_QUALITY_LEVEL RESAMPLER_QUALITY_NORMAL\n#endif\n\n/* MIDI */\n#if defined(_WIN32) && !defined(_XBOX) && !defined(__WINRT__)\n#define DEFAULT_MIDI_OUTPUT \"Microsoft GS Wavetable Synth\"\n#else\n#define DEFAULT_MIDI_OUTPUT \"OFF\"\n#endif\n#define DEFAULT_MIDI_INPUT  \"OFF\"\n#define DEFAULT_MIDI_VOLUME 100\n\n#ifdef HAVE_MIST\n/* Steam */\n#define DEFAULT_STEAM_RICH_PRESENCE_FORMAT STEAM_RICH_PRESENCE_FORMAT_CONTENT_SYSTEM\n#endif\n\n/* Only applies to Android 7.0 (API 24) and up */\n#define DEFAULT_SUSTAINED_PERFORMANCE_MODE false\n\n#if defined(ANDROID) || defined(IOS)\n#define DEFAULT_VIBRATE_ON_KEYPRESS true\n#else\n#define DEFAULT_VIBRATE_ON_KEYPRESS false\n#endif\n\n#if defined(IOS)\n#define DEFAULT_ENABLE_DEVICE_VIBRATION true\n#else\n#define DEFAULT_ENABLE_DEVICE_VIBRATION false\n#endif\n\n/* Defines the strength of rumble effects\n * on OpenDingux devices */\n#if defined(DINGUX) && defined(HAVE_LIBSHAKE)\n#define DEFAULT_RUMBLE_GAIN 50\n#else\n#define DEFAULT_RUMBLE_GAIN 100\n#endif\n\n#ifdef HAVE_VULKAN\n#define DEFAULT_VULKAN_GPU_INDEX 0\n#endif\n\n#ifdef HAVE_D3D10\n#define DEFAULT_D3D10_GPU_INDEX 0\n#endif\n\n#ifdef HAVE_D3D11\n#define DEFAULT_D3D11_GPU_INDEX 0\n#endif\n\n#ifdef HAVE_D3D12\n#define DEFAULT_D3D12_GPU_INDEX 0\n#endif\n\n#if defined(HAKCHI)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://hakchicloud.com/Libretro_Cores/\"\n#elif defined(WEBOS)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://retroarch-cores.webosbrew.org/armv7a/\"\n#elif defined(ANDROID)\n#if defined(ANDROID_ARM_V7)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/android/latest/armeabi-v7a/\"\n#elif defined(ANDROID_ARM)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/android/latest/armeabi/\"\n#elif defined(ANDROID_AARCH64)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/android/latest/arm64-v8a/\"\n#elif defined(ANDROID_X86)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/android/latest/x86/\"\n#elif defined(ANDROID_X64)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/android/latest/x86_64/\"\n#else\n#define DEFAULT_BUILDBOT_SERVER_URL \"\"\n#endif\n#elif defined(__QNX__)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/blackberry/latest/\"\n#elif defined(IOS)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/apple/ios/latest/\"\n#elif defined(OSX)\n#if defined(__x86_64__)\n#if defined(HAVE_SSL)\n#define DEFAULT_BUILDBOT_SERVER_URL \"https://buildbot.libretro.com/nightly/apple/osx/x86_64/latest/\"\n#else\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/apple/osx/x86_64/latest/\"\n#endif\n#elif defined(__i386__) || defined(__i486__) || defined(__i686__)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://bot.libretro.com/nightly/apple/osx/x86/latest/\"\n#elif defined(__aarch64__)\n#if defined(HAVE_SSL)\n#define DEFAULT_BUILDBOT_SERVER_URL \"https://buildbot.libretro.com/nightly/apple/osx/arm64/latest/\"\n#else\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/apple/osx/arm64/latest/\"\n#endif\n#else\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/apple/osx/ppc/latest/\"\n#endif\n#elif defined(_WIN32) && !defined(_XBOX)\n#if _MSC_VER >= 1910\n#ifndef __WINRT__\n#if defined(__x86_64__) || defined(_M_X64)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/windows/x86_64/latest/\"\n#elif defined(__i386__) || defined(__i486__) || defined(__i686__) || defined(_M_IX86) || defined(_M_IA64)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/windows-msvc2017-desktop/x86/latest/\"\n#elif defined(__arm__) || defined(_M_ARM)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/windows-msvc2017-desktop/arm/latest/\"\n#elif defined(__aarch64__) || defined(_M_ARM64)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/windows-msvc2017-desktop/arm64/latest/\"\n#endif\n#else\n#if defined(__x86_64__) || defined(_M_X64)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/windows/x86_64/latest/\"\n#elif defined(__i386__) || defined(__i486__) || defined(__i686__) || defined(_M_IX86) || defined(_M_IA64)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/windows/x86/latest/\"\n#elif defined(__arm__) || defined(_M_ARM)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/windows-msvc2017-uwp/arm/latest/\"\n#elif defined(__aarch64__) || defined(_M_ARM64)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/windows-msvc2017-uwp/arm64/latest/\"\n#endif\n#endif\n#elif _MSC_VER == 1600\n#if defined(__x86_64__) || defined(_M_X64)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/windows-msvc2010/x86_64/latest/\"\n#elif defined(__i386__) || defined(__i486__) || defined(__i686__) || defined(_M_IX86) || defined(_M_IA64)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/windows-msvc2010/x86/latest/\"\n#endif\n#elif _MSC_VER == 1400\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/windows-msvc2005/x86/latest/\"\n#elif _MSC_VER == 1310\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/windows-msvc2003/x86/latest/\"\n#else\n#if defined(__x86_64__) || defined(_M_X64)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/windows/x86_64/latest/\"\n#elif defined(__i386__) || defined(__i486__) || defined(__i686__) || defined(_M_IX86) || defined(_M_IA64)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/windows/x86/latest/\"\n#endif\n#endif\n#elif defined(__linux__)\n#if defined(__x86_64__)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/linux/x86_64/latest/\"\n#elif defined(__i386__) || defined(__i486__) || defined(__i686__)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/linux/x86/latest/\"\n#elif defined(__arm__) && __ARM_ARCH == 7 && defined(__ARM_PCS_VFP)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/linux/armhf/latest/\"\n#else\n#define DEFAULT_BUILDBOT_SERVER_URL \"\"\n#endif\n#elif defined(WIIU)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/nintendo/wiiu/latest/\"\n#elif defined(HAVE_LIBNX)\n#define DEFAULT_BUILDBOT_SERVER_URL \"http://buildbot.libretro.com/nightly/nintendo/switch/libnx/latest/\"\n#elif defined(_3DS)\n#define DEFAULT_BUILDBOT_SERVER_URL envIsHomebrew() ? \"http://buildbot.libretro.com/nightly/nintendo/3ds/latest/3dsx/\" : \"http://buildbot.libretro.com/nightly/nintendo/3ds/latest/cia/\"\n#else\n#define DEFAULT_BUILDBOT_SERVER_URL \"\"\n#endif\n\n#define DEFAULT_BUILDBOT_ASSETS_SERVER_URL \"http://buildbot.libretro.com/assets/\"\n\n#define DEFAULT_DISCORD_APP_ID \"475456035851599874\"\n\n#define DEFAULT_AI_SERVICE_SOURCE_LANG 0\n\n#define DEFAULT_AI_SERVICE_TARGET_LANG 0\n\n#define DEFAULT_AI_SERVICE_ENABLE false\n\n#define DEFAULT_AI_SERVICE_PAUSE false\n\n#define DEFAULT_AI_SERVICE_MODE 1\n\n#define DEFAULT_AI_SERVICE_URL \"http://localhost:4404/\"\n\n#if defined(HAVE_FFMPEG) || defined(HAVE_MPV)\n#define DEFAULT_BUILTIN_MEDIAPLAYER_ENABLE true\n#else\n#define DEFAULT_BUILTIN_MEDIAPLAYER_ENABLE false\n#endif\n\n#if defined(HAVE_IMAGEVIEWER)\n#define DEFAULT_BUILTIN_IMAGEVIEWER_ENABLE true\n#else\n#define DEFAULT_BUILTIN_IMAGEVIEWER_ENABLE false\n#endif\n\n#define DEFAULT_FILTER_BY_CURRENT_CORE false\n\n#endif\n"
        },
        {
          "name": "config.def.keybinds.h",
          "type": "blob",
          "size": 60.0634765625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2016 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __CONFIG_DEF_KEYBINDS_H\n#define __CONFIG_DEF_KEYBINDS_H\n\n#ifndef IS_SALAMANDER\n\n/* User 1 */\nstatic const struct retro_keybind retro_keybinds_1[] = {\n#ifdef __QNX__\n   { \n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_B, RETROK_k,\n      RETRO_DEVICE_ID_JOYPAD_B, NO_BTN, NO_BTN, 0,\n      true\n   },\n   { \n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_Y, RETROK_i,\n      RETRO_DEVICE_ID_JOYPAD_Y, NO_BTN, NO_BTN, 0,\n      true\n   },\n   { \n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_SELECT, RETROK_v,\n      RETRO_DEVICE_ID_JOYPAD_SELECT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   { \n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_START, RETROK_b,\n      RETRO_DEVICE_ID_JOYPAD_START, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_UP, RETROK_e,\n      RETRO_DEVICE_ID_JOYPAD_UP, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_DOWN, RETROK_s,\n      RETRO_DEVICE_ID_JOYPAD_DOWN, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_LEFT, RETROK_w,\n      RETRO_DEVICE_ID_JOYPAD_LEFT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_RIGHT, RETROK_d,\n      RETRO_DEVICE_ID_JOYPAD_RIGHT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_A, RETROK_l,\n      RETRO_DEVICE_ID_JOYPAD_A, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_X, RETROK_o,\n      RETRO_DEVICE_ID_JOYPAD_X, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L, RETROK_f,\n      RETRO_DEVICE_ID_JOYPAD_L, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R, RETROK_j,\n      RETRO_DEVICE_ID_JOYPAD_R, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L2, RETROK_r,\n      RETRO_DEVICE_ID_JOYPAD_L2, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R2, RETROK_u,\n      RETRO_DEVICE_ID_JOYPAD_R2, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L3, RETROK_g,\n      RETRO_DEVICE_ID_JOYPAD_L3, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R3, RETROK_h,\n      RETRO_DEVICE_ID_JOYPAD_R3, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_X_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_X_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_X_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_X_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_Y_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_Y_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_Y_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_Y_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_X_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_X_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_X_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_X_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_Y_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_Y_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_Y_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_Y_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_TRIGGER, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_TRIGGER, RETRO_DEVICE_ID_MOUSE_LEFT, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_RELOAD, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_RELOAD, RETRO_DEVICE_ID_MOUSE_RIGHT, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_A, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_AUX_A, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_B, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_AUX_B, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_C, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_AUX_C, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_START, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_START, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_SELECT, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_SELECT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_UP, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_UP, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_DOWN, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_DOWN, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_LEFT, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_LEFT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_RIGHT, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_RIGHT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_TURBO_ENABLE, RETROK_UNKNOWN,\n      RARCH_TURBO_ENABLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   /* Hotkeys */\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_ENABLE_HOTKEY, RETROK_UNKNOWN,\n      RARCH_ENABLE_HOTKEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_MENU_TOGGLE, RETROK_SPACE,\n      RARCH_MENU_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_QUIT_KEY, RETROK_UNKNOWN,\n      RARCH_QUIT_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_CLOSE_CONTENT_KEY, RETROK_UNKNOWN,\n      RARCH_CLOSE_CONTENT_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_RESET, RETROK_UNKNOWN,\n      RARCH_RESET, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_FAST_FORWARD_KEY, RETROK_UNKNOWN,\n      RARCH_FAST_FORWARD_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_FAST_FORWARD_HOLD_KEY, RETROK_UNKNOWN,\n      RARCH_FAST_FORWARD_HOLD_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SLOWMOTION_KEY, RETROK_UNKNOWN,\n      RARCH_SLOWMOTION_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SLOWMOTION_HOLD_KEY, RETROK_UNKNOWN,\n      RARCH_SLOWMOTION_HOLD_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_REWIND, RETROK_UNKNOWN,\n      RARCH_REWIND, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_PAUSE_TOGGLE, RETROK_UNKNOWN,\n      RARCH_PAUSE_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_FRAMEADVANCE, RETROK_UNKNOWN,\n      RARCH_FRAMEADVANCE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_MUTE, RETROK_UNKNOWN,\n      RARCH_MUTE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_VOLUME_UP, RETROK_UNKNOWN,\n      RARCH_VOLUME_UP, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_VOLUME_DOWN, RETROK_UNKNOWN,\n      RARCH_VOLUME_DOWN, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_LOAD_STATE_KEY, RETROK_UNKNOWN,\n      RARCH_LOAD_STATE_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SAVE_STATE_KEY, RETROK_UNKNOWN,\n      RARCH_SAVE_STATE_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_STATE_SLOT_PLUS, RETROK_UNKNOWN,\n      RARCH_STATE_SLOT_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_STATE_SLOT_MINUS, RETROK_UNKNOWN,\n      RARCH_STATE_SLOT_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_PLAY_REPLAY_KEY, RETROK_UNKNOWN,\n      RARCH_PLAY_REPLAY_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_RECORD_REPLAY_KEY, RETROK_UNKNOWN,\n      RARCH_RECORD_REPLAY_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_HALT_REPLAY_KEY, RETROK_UNKNOWN,\n      RARCH_HALT_REPLAY_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_REPLAY_SLOT_PLUS, RETROK_UNKNOWN,\n      RARCH_REPLAY_SLOT_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_REPLAY_SLOT_MINUS, RETROK_UNKNOWN,\n      RARCH_REPLAY_SLOT_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_DISK_EJECT_TOGGLE, RETROK_UNKNOWN,\n      RARCH_DISK_EJECT_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_DISK_NEXT, RETROK_UNKNOWN,\n      RARCH_DISK_NEXT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_DISK_PREV, RETROK_UNKNOWN,\n      RARCH_DISK_PREV, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SHADER_TOGGLE, RETROK_UNKNOWN,\n      RARCH_SHADER_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SHADER_NEXT, RETROK_UNKNOWN,\n      RARCH_SHADER_NEXT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SHADER_PREV, RETROK_UNKNOWN,\n      RARCH_SHADER_PREV, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_CHEAT_TOGGLE, RETROK_UNKNOWN,\n      RARCH_CHEAT_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_CHEAT_INDEX_PLUS, RETROK_UNKNOWN,\n      RARCH_CHEAT_INDEX_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_CHEAT_INDEX_MINUS, RETROK_UNKNOWN,\n      RARCH_CHEAT_INDEX_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SCREENSHOT, RETROK_UNKNOWN,\n      RARCH_SCREENSHOT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_RECORDING_TOGGLE, RETROK_UNKNOWN,\n      RARCH_RECORDING_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_STREAMING_TOGGLE, RETROK_UNKNOWN,\n      RARCH_STREAMING_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_GRAB_MOUSE_TOGGLE, RETROK_UNKNOWN,\n      RARCH_GRAB_MOUSE_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_GAME_FOCUS_TOGGLE, RETROK_UNKNOWN,\n      RARCH_GAME_FOCUS_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_FULLSCREEN_TOGGLE_KEY, RETROK_UNKNOWN,\n      RARCH_FULLSCREEN_TOGGLE_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_UI_COMPANION_TOGGLE, RETROK_UNKNOWN,\n      RARCH_UI_COMPANION_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_VRR_RUNLOOP_TOGGLE, RETROK_UNKNOWN,\n      RARCH_VRR_RUNLOOP_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_RUNAHEAD_TOGGLE, RETROK_UNKNOWN,\n      RARCH_RUNAHEAD_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_PREEMPT_TOGGLE, RETROK_UNKNOWN,\n      RARCH_PREEMPT_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_FPS_TOGGLE, RETROK_UNKNOWN,\n      RARCH_FPS_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_STATISTICS_TOGGLE, RETROK_UNKNOWN,\n      RARCH_STATISTICS_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_AI_SERVICE, RETROK_UNKNOWN,\n      RARCH_AI_SERVICE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_PING_TOGGLE, RETROK_UNKNOWN,\n      RARCH_NETPLAY_PING_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_HOST_TOGGLE, RETROK_UNKNOWN,\n      RARCH_NETPLAY_HOST_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_GAME_WATCH, RETROK_UNKNOWN,\n      RARCH_NETPLAY_GAME_WATCH, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_PLAYER_CHAT, RETROK_UNKNOWN,\n      RARCH_NETPLAY_PLAYER_CHAT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_FADE_CHAT_TOGGLE, RETROK_UNKNOWN,\n      RARCH_NETPLAY_FADE_CHAT_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_OVERLAY_NEXT, RETROK_UNKNOWN,\n      RARCH_OVERLAY_NEXT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_OSK, RETROK_UNKNOWN,\n      RARCH_OSK, NO_BTN, NO_BTN, 0,\n      true\n   },\n#if 0\n   /* Deprecated */\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SEND_DEBUG_INFO, RETROK_UNKNOWN,\n      RARCH_SEND_DEBUG_INFO, NO_BTN, NO_BTN, 0,\n      true\n   },\n#endif\n#elif defined(DINGUX)\n   { \n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_B, RETROK_LALT,\n      RETRO_DEVICE_ID_JOYPAD_B, NO_BTN, NO_BTN, 0,\n      true\n   },\n   { \n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_Y, RETROK_LSHIFT,\n      RETRO_DEVICE_ID_JOYPAD_Y, NO_BTN, NO_BTN, 0,\n      true\n   },\n   { \n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_SELECT, RETROK_ESCAPE,\n      RETRO_DEVICE_ID_JOYPAD_SELECT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   { \n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_START, RETROK_RETURN,\n      RETRO_DEVICE_ID_JOYPAD_START, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_UP, RETROK_UP,\n      RETRO_DEVICE_ID_JOYPAD_UP, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_DOWN, RETROK_DOWN,\n      RETRO_DEVICE_ID_JOYPAD_DOWN, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_LEFT, RETROK_LEFT,\n      RETRO_DEVICE_ID_JOYPAD_LEFT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_RIGHT, RETROK_RIGHT,\n      RETRO_DEVICE_ID_JOYPAD_RIGHT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_A, RETROK_LCTRL,\n      RETRO_DEVICE_ID_JOYPAD_A, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_X, RETROK_SPACE,\n      RETRO_DEVICE_ID_JOYPAD_X, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L, RETROK_TAB,\n      RETRO_DEVICE_ID_JOYPAD_L, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R, RETROK_BACKSPACE,\n      RETRO_DEVICE_ID_JOYPAD_R, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L2, RETROK_PAGEUP,\n      RETRO_DEVICE_ID_JOYPAD_L2, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R2, RETROK_PAGEDOWN,\n      RETRO_DEVICE_ID_JOYPAD_R2, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L3, RETROK_KP_DIVIDE,\n      RETRO_DEVICE_ID_JOYPAD_L3, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R3, RETROK_KP_PERIOD,\n      RETRO_DEVICE_ID_JOYPAD_R3, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_X_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_X_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_X_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_X_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_Y_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_Y_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_Y_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_Y_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_X_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_X_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_X_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_X_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_Y_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_Y_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_Y_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_Y_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_TRIGGER, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_TRIGGER, RETRO_DEVICE_ID_MOUSE_LEFT, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_RELOAD, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_RELOAD, RETRO_DEVICE_ID_MOUSE_RIGHT, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_A, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_AUX_A, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_B, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_AUX_B, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_C, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_AUX_C, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_START, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_START, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_SELECT, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_SELECT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_UP, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_UP, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_DOWN, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_DOWN, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_LEFT, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_LEFT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_RIGHT, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_RIGHT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_TURBO_ENABLE, RETROK_UNKNOWN,\n      RARCH_TURBO_ENABLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   /* Hotkeys */\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_ENABLE_HOTKEY, RETROK_UNKNOWN,\n      RARCH_ENABLE_HOTKEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_MENU_TOGGLE, RETROK_HOME,\n      RARCH_MENU_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_QUIT_KEY, RETROK_UNKNOWN,\n      RARCH_QUIT_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_CLOSE_CONTENT_KEY, RETROK_UNKNOWN,\n      RARCH_CLOSE_CONTENT_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_RESET, RETROK_UNKNOWN,\n      RARCH_RESET, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_FAST_FORWARD_KEY, RETROK_UNKNOWN,\n      RARCH_FAST_FORWARD_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_FAST_FORWARD_HOLD_KEY, RETROK_UNKNOWN,\n      RARCH_FAST_FORWARD_HOLD_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SLOWMOTION_KEY, RETROK_UNKNOWN,\n      RARCH_SLOWMOTION_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SLOWMOTION_HOLD_KEY, RETROK_UNKNOWN,\n      RARCH_SLOWMOTION_HOLD_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_REWIND, RETROK_UNKNOWN,\n      RARCH_REWIND, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_PAUSE_TOGGLE, RETROK_UNKNOWN,\n      RARCH_PAUSE_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_FRAMEADVANCE, RETROK_UNKNOWN,\n      RARCH_FRAMEADVANCE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_MUTE, RETROK_UNKNOWN,\n      RARCH_MUTE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_VOLUME_UP, RETROK_UNKNOWN,\n      RARCH_VOLUME_UP, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_VOLUME_DOWN, RETROK_UNKNOWN,\n      RARCH_VOLUME_DOWN, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_LOAD_STATE_KEY, RETROK_UNKNOWN,\n      RARCH_LOAD_STATE_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SAVE_STATE_KEY, RETROK_UNKNOWN,\n      RARCH_SAVE_STATE_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_STATE_SLOT_PLUS, RETROK_UNKNOWN,\n      RARCH_STATE_SLOT_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_STATE_SLOT_MINUS, RETROK_UNKNOWN,\n      RARCH_STATE_SLOT_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_PLAY_REPLAY_KEY, RETROK_UNKNOWN,\n      RARCH_PLAY_REPLAY_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_RECORD_REPLAY_KEY, RETROK_UNKNOWN,\n      RARCH_RECORD_REPLAY_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_HALT_REPLAY_KEY, RETROK_UNKNOWN,\n      RARCH_HALT_REPLAY_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_REPLAY_SLOT_PLUS, RETROK_UNKNOWN,\n      RARCH_REPLAY_SLOT_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_REPLAY_SLOT_MINUS, RETROK_UNKNOWN,\n      RARCH_REPLAY_SLOT_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_DISK_EJECT_TOGGLE, RETROK_UNKNOWN,\n      RARCH_DISK_EJECT_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_DISK_NEXT, RETROK_UNKNOWN,\n      RARCH_DISK_NEXT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_DISK_PREV, RETROK_UNKNOWN,\n      RARCH_DISK_PREV, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SHADER_TOGGLE, RETROK_UNKNOWN,\n      RARCH_SHADER_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SHADER_NEXT, RETROK_UNKNOWN,\n      RARCH_SHADER_NEXT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SHADER_PREV, RETROK_UNKNOWN,\n      RARCH_SHADER_PREV, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_CHEAT_TOGGLE, RETROK_UNKNOWN,\n      RARCH_CHEAT_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_CHEAT_INDEX_PLUS, RETROK_UNKNOWN,\n      RARCH_CHEAT_INDEX_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_CHEAT_INDEX_MINUS, RETROK_UNKNOWN,\n      RARCH_CHEAT_INDEX_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SCREENSHOT, RETROK_UNKNOWN,\n      RARCH_SCREENSHOT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_RECORDING_TOGGLE, RETROK_UNKNOWN,\n      RARCH_RECORDING_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_STREAMING_TOGGLE, RETROK_UNKNOWN,\n      RARCH_STREAMING_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_GRAB_MOUSE_TOGGLE, RETROK_UNKNOWN,\n      RARCH_GRAB_MOUSE_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_GAME_FOCUS_TOGGLE, RETROK_UNKNOWN,\n      RARCH_GAME_FOCUS_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_FULLSCREEN_TOGGLE_KEY, RETROK_UNKNOWN,\n      RARCH_FULLSCREEN_TOGGLE_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_UI_COMPANION_TOGGLE, RETROK_UNKNOWN,\n      RARCH_UI_COMPANION_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_VRR_RUNLOOP_TOGGLE, RETROK_UNKNOWN,\n      RARCH_VRR_RUNLOOP_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_RUNAHEAD_TOGGLE, RETROK_UNKNOWN,\n      RARCH_RUNAHEAD_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_PREEMPT_TOGGLE, RETROK_UNKNOWN,\n      RARCH_PREEMPT_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_FPS_TOGGLE, RETROK_UNKNOWN,\n      RARCH_FPS_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_STATISTICS_TOGGLE, RETROK_UNKNOWN,\n      RARCH_STATISTICS_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_AI_SERVICE, RETROK_UNKNOWN,\n      RARCH_AI_SERVICE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_PING_TOGGLE, RETROK_UNKNOWN,\n      RARCH_NETPLAY_PING_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_HOST_TOGGLE, RETROK_UNKNOWN,\n      RARCH_NETPLAY_HOST_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_GAME_WATCH, RETROK_UNKNOWN,\n      RARCH_NETPLAY_GAME_WATCH, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_PLAYER_CHAT, RETROK_UNKNOWN,\n      RARCH_NETPLAY_PLAYER_CHAT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_FADE_CHAT_TOGGLE, RETROK_UNKNOWN,\n      RARCH_NETPLAY_FADE_CHAT_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_OVERLAY_NEXT, RETROK_UNKNOWN,\n      RARCH_OVERLAY_NEXT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_OSK, RETROK_UNKNOWN,\n      RARCH_OSK, NO_BTN, NO_BTN, 0,\n      true\n   },\n#if 0\n   /* Deprecated */\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SEND_DEBUG_INFO, RETROK_UNKNOWN,\n      RARCH_SEND_DEBUG_INFO, NO_BTN, NO_BTN, 0,\n      true\n   },\n#endif\n#else\n   { \n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_B, RETROK_z,\n      RETRO_DEVICE_ID_JOYPAD_B, NO_BTN, NO_BTN, 0,\n      true\n   },\n   { \n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_Y, RETROK_a,\n      RETRO_DEVICE_ID_JOYPAD_Y, NO_BTN, NO_BTN, 0,\n      true\n   },\n   { \n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_SELECT, RETROK_RSHIFT,\n      RETRO_DEVICE_ID_JOYPAD_SELECT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   { \n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_START, RETROK_RETURN,\n      RETRO_DEVICE_ID_JOYPAD_START, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_UP, RETROK_UP,\n      RETRO_DEVICE_ID_JOYPAD_UP, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_DOWN, RETROK_DOWN,\n      RETRO_DEVICE_ID_JOYPAD_DOWN, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_LEFT, RETROK_LEFT,\n      RETRO_DEVICE_ID_JOYPAD_LEFT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_RIGHT, RETROK_RIGHT,\n      RETRO_DEVICE_ID_JOYPAD_RIGHT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_A, RETROK_x,\n      RETRO_DEVICE_ID_JOYPAD_A, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_X, RETROK_s,\n      RETRO_DEVICE_ID_JOYPAD_X, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L, RETROK_q,\n      RETRO_DEVICE_ID_JOYPAD_L, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R, RETROK_w,\n      RETRO_DEVICE_ID_JOYPAD_R, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L2, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_L2, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R2, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_R2, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L3, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_L3, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R3, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_R3, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_X_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_X_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_X_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_X_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_Y_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_Y_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_Y_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_Y_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_X_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_X_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_X_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_X_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_Y_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_Y_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_Y_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_Y_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_TRIGGER, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_TRIGGER, RETRO_DEVICE_ID_MOUSE_LEFT, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_RELOAD, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_RELOAD, RETRO_DEVICE_ID_MOUSE_RIGHT, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_A, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_AUX_A, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_B, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_AUX_B, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_C, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_AUX_C, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_START, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_START, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_SELECT, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_SELECT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_UP, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_UP, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_DOWN, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_DOWN, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_LEFT, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_LEFT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_RIGHT, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_RIGHT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_TURBO_ENABLE, RETROK_UNKNOWN,\n      RARCH_TURBO_ENABLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   /* Hotkeys */\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_ENABLE_HOTKEY, RETROK_UNKNOWN,\n      RARCH_ENABLE_HOTKEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_MENU_TOGGLE, RETROK_F1,\n      RARCH_MENU_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n#ifdef HAVE_LAKKA\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_RESTART_KEY, RETROK_ESCAPE,\n      RARCH_QUIT_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n#else\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_QUIT_KEY, RETROK_ESCAPE,\n      RARCH_QUIT_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n#endif\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_CLOSE_CONTENT_KEY, RETROK_UNKNOWN,\n      RARCH_CLOSE_CONTENT_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_RESET, RETROK_h,\n      RARCH_RESET, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_FAST_FORWARD_KEY, RETROK_SPACE,\n      RARCH_FAST_FORWARD_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_FAST_FORWARD_HOLD_KEY, RETROK_l,\n      RARCH_FAST_FORWARD_HOLD_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SLOWMOTION_KEY, RETROK_UNKNOWN,\n      RARCH_SLOWMOTION_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SLOWMOTION_HOLD_KEY, RETROK_e,\n      RARCH_SLOWMOTION_HOLD_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_REWIND, RETROK_r,\n      RARCH_REWIND, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_PAUSE_TOGGLE, RETROK_p,\n      RARCH_PAUSE_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_FRAMEADVANCE, RETROK_k,\n      RARCH_FRAMEADVANCE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_MUTE, RETROK_F9,\n      RARCH_MUTE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_VOLUME_UP, RETROK_KP_PLUS,\n      RARCH_VOLUME_UP, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_VOLUME_DOWN, RETROK_KP_MINUS,\n      RARCH_VOLUME_DOWN, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_LOAD_STATE_KEY, RETROK_F4,\n      RARCH_LOAD_STATE_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SAVE_STATE_KEY, RETROK_F2,\n      RARCH_SAVE_STATE_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_STATE_SLOT_PLUS, RETROK_F7,\n      RARCH_STATE_SLOT_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_STATE_SLOT_MINUS, RETROK_F6,\n      RARCH_STATE_SLOT_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_PLAY_REPLAY_KEY, RETROK_UNKNOWN,\n      RARCH_PLAY_REPLAY_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_RECORD_REPLAY_KEY, RETROK_UNKNOWN,\n      RARCH_RECORD_REPLAY_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_HALT_REPLAY_KEY, RETROK_UNKNOWN,\n      RARCH_HALT_REPLAY_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_REPLAY_SLOT_PLUS, RETROK_UNKNOWN,\n      RARCH_REPLAY_SLOT_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_REPLAY_SLOT_MINUS, RETROK_UNKNOWN,\n      RARCH_REPLAY_SLOT_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_DISK_EJECT_TOGGLE, RETROK_UNKNOWN,\n      RARCH_DISK_EJECT_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_DISK_NEXT, RETROK_UNKNOWN,\n      RARCH_DISK_NEXT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_DISK_PREV, RETROK_UNKNOWN,\n      RARCH_DISK_PREV, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SHADER_TOGGLE, RETROK_COMMA,\n      RARCH_SHADER_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SHADER_NEXT, RETROK_m,\n      RARCH_SHADER_NEXT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SHADER_PREV, RETROK_n,\n      RARCH_SHADER_PREV, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_CHEAT_TOGGLE, RETROK_u,\n      RARCH_CHEAT_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_CHEAT_INDEX_PLUS, RETROK_y,\n      RARCH_CHEAT_INDEX_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_CHEAT_INDEX_MINUS, RETROK_t,\n      RARCH_CHEAT_INDEX_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SCREENSHOT, RETROK_F8,\n      RARCH_SCREENSHOT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_RECORDING_TOGGLE, RETROK_UNKNOWN,\n      RARCH_RECORDING_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_STREAMING_TOGGLE, RETROK_UNKNOWN,\n      RARCH_STREAMING_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_GRAB_MOUSE_TOGGLE, RETROK_F11,\n      RARCH_GRAB_MOUSE_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_GAME_FOCUS_TOGGLE, RETROK_SCROLLOCK,\n      RARCH_GAME_FOCUS_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_FULLSCREEN_TOGGLE_KEY, RETROK_f,\n      RARCH_FULLSCREEN_TOGGLE_KEY, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_UI_COMPANION_TOGGLE, RETROK_F5,\n      RARCH_UI_COMPANION_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_VRR_RUNLOOP_TOGGLE, RETROK_UNKNOWN,\n      RARCH_VRR_RUNLOOP_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_RUNAHEAD_TOGGLE, RETROK_UNKNOWN,\n      RARCH_RUNAHEAD_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_PREEMPT_TOGGLE, RETROK_UNKNOWN,\n      RARCH_PREEMPT_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_FPS_TOGGLE, RETROK_F3,\n      RARCH_FPS_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_STATISTICS_TOGGLE, RETROK_UNKNOWN,\n      RARCH_STATISTICS_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_AI_SERVICE, RETROK_UNKNOWN,\n      RARCH_AI_SERVICE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_PING_TOGGLE, RETROK_UNKNOWN,\n      RARCH_NETPLAY_PING_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_HOST_TOGGLE, RETROK_UNKNOWN,\n      RARCH_NETPLAY_HOST_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_GAME_WATCH, RETROK_i,\n      RARCH_NETPLAY_GAME_WATCH, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_PLAYER_CHAT, RETROK_BACKQUOTE,\n      RARCH_NETPLAY_PLAYER_CHAT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_FADE_CHAT_TOGGLE, RETROK_UNKNOWN,\n      RARCH_NETPLAY_FADE_CHAT_TOGGLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_OVERLAY_NEXT, RETROK_UNKNOWN,\n      RARCH_OVERLAY_NEXT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_OSK, RETROK_UNKNOWN,\n      RARCH_OSK, NO_BTN, NO_BTN, 0,\n      true\n   },\n#if 0\n   /* Deprecated */\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_META_SEND_DEBUG_INFO, RETROK_UNKNOWN,\n      RARCH_SEND_DEBUG_INFO, NO_BTN, NO_BTN, 0,\n      true\n   },\n#endif\n#endif\n};\n\n/* Users 2 to MAX_USERS */\nstatic const struct retro_keybind retro_keybinds_rest[] = {\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_B, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_B, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_Y, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_Y, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_SELECT, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_SELECT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_START, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_START, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_UP, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_UP, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_DOWN, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_DOWN, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_LEFT, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_LEFT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_RIGHT, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_RIGHT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_A, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_A, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_X, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_X, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_L, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_R, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L2, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_L2, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R2, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_R2, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L3, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_L3, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R3, RETROK_UNKNOWN,\n      RETRO_DEVICE_ID_JOYPAD_R3, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_X_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_X_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_X_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_X_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_Y_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_Y_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_Y_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_LEFT_Y_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_X_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_X_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_X_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_X_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_Y_PLUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_Y_PLUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_Y_MINUS, RETROK_UNKNOWN,\n      RARCH_ANALOG_RIGHT_Y_MINUS, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_TRIGGER, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_TRIGGER, RETRO_DEVICE_ID_MOUSE_LEFT, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_RELOAD, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_RELOAD, RETRO_DEVICE_ID_MOUSE_RIGHT, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_A, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_AUX_A, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_B, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_AUX_B, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_C, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_AUX_C, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_START, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_START, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_SELECT, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_SELECT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_UP, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_UP, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_DOWN, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_DOWN, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_LEFT, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_LEFT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_RIGHT, RETROK_UNKNOWN,\n      RARCH_LIGHTGUN_DPAD_RIGHT, NO_BTN, NO_BTN, 0,\n      true\n   },\n   {\n      NULL, NULL,\n      AXIS_NONE, AXIS_NONE, AXIS_NONE,\n      MENU_ENUM_LABEL_VALUE_INPUT_TURBO_ENABLE, RETROK_UNKNOWN,\n      RARCH_TURBO_ENABLE, NO_BTN, NO_BTN, 0,\n      true\n   },\n};\n\n#endif\n\n#endif\n"
        },
        {
          "name": "config.features.h",
          "type": "blob",
          "size": 6.4580078125,
          "content": "#ifndef __RARCH_FEATURES_H\n#define __RARCH_FEATURES_H\n\n#include <stddef.h>\n#include <boolean.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef HAVE_OVERLAY\n#define SUPPORTS_OVERLAY true\n#else\n#define SUPPORTS_OVERLAY false\n#endif\n\n#ifdef HAVE_V4L2\n#define SUPPORTS_V4L2 true\n#else\n#define SUPPORTS_V4L2 false\n#endif\n\n#ifdef HAVE_COMMAND\n#define SUPPORTS_COMMAND true\n#else\n#define SUPPORTS_COMMAND false\n#endif\n\n#ifdef HAVE_NETWORK_CMD\n#define SUPPORTS_NETWORK_COMMAND true\n#else\n#define SUPPORTS_NETWORK_COMMAND false\n#endif\n\n#ifdef HAVE_NETWORKGAMEPAD\n#define SUPPORTS_NETWORK_GAMEPAD true\n#else\n#define SUPPORTS_NETWORK_GAMEPAD false\n#endif\n\n#ifdef HAVE_FILTERS_BUILTIN\n#define SUPPORTS_CPU_FILTERS true\n#else\n#define SUPPORTS_CPU_FILTERS false\n#endif\n\n#ifdef HAVE_LIBUSB\n#define SUPPORTS_LIBUSB true\n#else\n#define SUPPORTS_LIBUSB false\n#endif\n\n#if defined(HAVE_SDL)\n#define SUPPORTS_SDL true\n#else\n#define SUPPORTS_SDL false\n#endif\n\n#ifdef HAVE_SDL2\n#define SUPPORTS_SDL2 true\n#else\n#define SUPPORTS_SDL2 false\n#endif\n\n#ifdef HAVE_THREADS\n#define SUPPORTS_THREAD true\n#else\n#define SUPPORTS_THREAD false\n#endif\n\n#ifdef HAVE_OPENGL\n#define SUPPORTS_OPENGL true\n#else\n#define SUPPORTS_OPENGL false\n#endif\n\n#ifdef HAVE_D3D8\n#define SUPPORTS_D3D8 true\n#else\n#define SUPPORTS_D3D8 false\n#endif\n\n#ifdef HAVE_D3D9\n#define SUPPORTS_D3D9 true\n#else\n#define SUPPORTS_D3D9 false\n#endif\n\n#ifdef HAVE_D3D10\n#define SUPPORTS_D3D10 true\n#else\n#define SUPPORTS_D3D10 false\n#endif\n\n#ifdef HAVE_D3D11\n#define SUPPORTS_D3D11 true\n#else\n#define SUPPORTS_D3D11 false\n#endif\n\n#ifdef HAVE_D3D12\n#define SUPPORTS_D3D12 true\n#else\n#define SUPPORTS_D3D12 false\n#endif\n\n#ifdef HAVE_GDI\n#define SUPPORTS_GDI true\n#else\n#define SUPPORTS_GDI false\n#endif\n\n#ifdef HAVE_VULKAN\n#define SUPPORTS_VULKAN true\n#else\n#define SUPPORTS_VULKAN false\n#endif\n\n#ifdef HAVE_METAL\n#define SUPPORTS_METAL true\n#else\n#define SUPPORTS_METAL false\n#endif\n\n#if defined(HAVE_OPENGLES) || defined(HAVE_OPENGLES2) || defined(HAVE_OPENGLES3) || defined(HAVE_OPENGLES_3_1) || defined(HAVE_OPENGLES_3_2)\n#define SUPPORTS_OPENGLES true\n#else\n#define SUPPORTS_OPENGLES false\n#endif\n\n#ifdef HAVE_KMS\n#define SUPPORTS_KMS true\n#else\n#define SUPPORTS_KMS false\n#endif\n\n#ifdef HAVE_UDEV\n#define SUPPORTS_UDEV true\n#else\n#define SUPPORTS_UDEV false\n#endif\n\n#ifdef HAVE_VG\n#define SUPPORTS_VG true\n#else\n#define SUPPORTS_VG false\n#endif\n\n#ifdef HAVE_EGL\n#define SUPPORTS_EGL true\n#else\n#define SUPPORTS_EGL false\n#endif\n\n#ifdef HAVE_X11\n#define SUPPORTS_X11 true\n#else\n#define SUPPORTS_X11 false\n#endif\n\n#ifdef HAVE_WAYLAND\n#define SUPPORTS_WAYLAND true\n#else\n#define SUPPORTS_WAYLAND false\n#endif\n\n#ifdef HAVE_XVIDEO\n#define SUPPORTS_XVIDEO true\n#else\n#define SUPPORTS_XVIDEO false\n#endif\n\n#ifdef HAVE_SLANG\n#define SUPPORTS_SLANG true\n#else\n#define SUPPORTS_SLANG false\n#endif\n\n#ifdef HAVE_ALSA\n#define SUPPORTS_ALSA true\n#else\n#define SUPPORTS_ALSA false\n#endif\n\n#ifdef HAVE_TINYALSA\n#define SUPPORTS_TINYALSA true\n#else\n#define SUPPORTS_TINYALSA false\n#endif\n\n#ifdef HAVE_COREAUDIO\n#define SUPPORTS_COREAUDIO true\n#else\n#define SUPPORTS_COREAUDIO false\n#endif\n\n#ifdef HAVE_COREAUDIO3\n#define SUPPORTS_COREAUDIO3 true\n#else\n#define SUPPORTS_COREAUDIO3 false\n#endif\n\n#if defined(HAVE_OSS) || defined(HAVE_OSS_BSD)\n#define SUPPORTS_OSS true\n#else\n#define SUPPORTS_OSS false\n#endif\n\n#ifdef HAVE_AL\n#define SUPPORTS_AL true\n#else\n#define SUPPORTS_AL false\n#endif\n\n#ifdef HAVE_SL\n#define SUPPORTS_SL true\n#else\n#define SUPPORTS_SL false\n#endif\n\n#ifdef HAVE_LIBRETRODB\n#define SUPPORTS_LIBRETRODB true\n#else\n#define SUPPORTS_LIBRETRODB false\n#endif\n\n#ifdef HAVE_RSOUND\n#define SUPPORTS_RSOUND true\n#else\n#define SUPPORTS_RSOUND false\n#endif\n\n#ifdef HAVE_ROAR\n#define SUPPORTS_ROAR true\n#else\n#define SUPPORTS_ROAR false\n#endif\n\n#ifdef HAVE_JACK\n#define SUPPORTS_JACK true\n#else\n#define SUPPORTS_JACK false\n#endif\n\n#ifdef HAVE_PULSE\n#define SUPPORTS_PULSE true\n#else\n#define SUPPORTS_PULSE false\n#endif\n\n#ifdef HAVE_DSOUND\n#define SUPPORTS_DSOUND true\n#else\n#define SUPPORTS_DSOUND false\n#endif\n\n#ifdef HAVE_WASAPI\n#define SUPPORTS_WASAPI true\n#else\n#define SUPPORTS_WASAPI false\n#endif\n\n#ifdef HAVE_PIPEWIRE\n#define SUPPORTS_PIPEWIRE true\n#else\n#define SUPPORTS_PIPEWIRE false\n#endif\n\n#ifdef HAVE_XAUDIO\n#define SUPPORTS_XAUDIO true\n#else\n#define SUPPORTS_XAUDIO false\n#endif\n\n#ifdef HAVE_ZLIB\n#define SUPPORTS_ZLIB true\n#else\n#define SUPPORTS_ZLIB false\n#endif\n\n#ifdef HAVE_7ZIP\n#define SUPPORTS_7ZIP true\n#else\n#define SUPPORTS_7ZIP false\n#endif\n\n#ifdef HAVE_DYLIB\n#define SUPPORTS_DYLIB true\n#else\n#define SUPPORTS_DYLIB false\n#endif\n\n#ifdef HAVE_CG\n#define SUPPORTS_CG true\n#else\n#define SUPPORTS_CG false\n#endif\n\n#ifdef HAVE_GLSL\n#define SUPPORTS_GLSL true\n#else\n#define SUPPORTS_GLSL false\n#endif\n\n#ifdef HAVE_HLSL\n#define SUPPORTS_HLSL true\n#else\n#define SUPPORTS_HLSL false\n#endif\n\n#ifdef HAVE_SDL_IMAGE\n#define SUPPORTS_SDL_IMAGE true\n#else\n#define SUPPORTS_SDL_IMAGE false\n#endif\n\n#ifdef HAVE_DYNAMIC\n#define SUPPORTS_DYNAMIC true\n#else\n#define SUPPORTS_DYNAMIC false\n#endif\n\n#ifdef HAVE_FFMPEG\n#define SUPPORTS_FFMPEG true\n#else\n#define SUPPORTS_FFMPEG false\n#endif\n\n#ifdef HAVE_MPV\n#define SUPPORTS_MPV true\n#else\n#define SUPPORTS_MPV false\n#endif\n\n#ifdef HAVE_FREETYPE\n#define SUPPORTS_FREETYPE true\n#else\n#define SUPPORTS_FREETYPE false\n#endif\n\n#ifdef HAVE_STB_FONT\n#define SUPPORTS_STBFONT true\n#else\n#define SUPPORTS_STBFONT false\n#endif\n\n#ifdef HAVE_NETWORKING\n#define SUPPORTS_NETPLAY true\n#else\n#define SUPPORTS_NETPLAY false\n#endif\n\n#ifdef HAVE_SSL\n#define SUPPORTS_SSL true\n#else\n#define SUPPORTS_SSL false\n#endif\n\n#if defined(HAVE_COCOA) || defined(HAVE_COCOATOUCH) || defined(HAVE_COCOA_METAL)\n#define SUPPORTS_COCOA true\n#else\n#define SUPPORTS_COCOA false\n#endif\n\n#ifdef HAVE_QT\n#define SUPPORTS_QT true\n#else\n#define SUPPORTS_QT false\n#endif\n\n#ifdef HAVE_QT6\n#define SUPPORTS_QT6 true\n#else\n#define SUPPORTS_QT6 false\n#endif\n\n#ifdef HAVE_RPNG\n#define SUPPORTS_RPNG true\n#else\n#define SUPPORTS_RPNG false\n#endif\n\n#ifdef HAVE_RJPEG\n#define SUPPORTS_RJPEG true\n#else\n#define SUPPORTS_RJPEG false\n#endif\n\n#ifdef HAVE_RBMP\n#define SUPPORTS_RBMP true\n#else\n#define SUPPORTS_RBMP false\n#endif\n\n#ifdef HAVE_RTGA\n#define SUPPORTS_RTGA true\n#else\n#define SUPPORTS_RTGA false\n#endif\n\n#ifdef HAVE_CORETEXT\n#define SUPPORTS_CORETEXT true\n#else\n#define SUPPORTS_CORETEXT false\n#endif\n\n#ifdef HAVE_CHECK\n#define SUPPORTS_CHECK true\n#else\n#define SUPPORTS_CHECK false\n#endif\n\n#if !defined(_WIN32) && !defined(GLOBAL_CONFIG_DIR)\n#if defined(__HAIKU__)\n#define GLOBAL_CONFIG_DIR \"/system/settings\"\n#else\n#define GLOBAL_CONFIG_DIR \"/etc\"\n#endif\n#endif\n\n#endif\n"
        },
        {
          "name": "configuration.c",
          "type": "blob",
          "size": 290.755859375,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2014-2017 - Jean-Andr Santoni\n *  Copyright (C) 2015-2019 - Andrs Surez (input remapping + other things)\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <ctype.h>\n\n#include <libretro.h>\n#include <file/config_file.h>\n#include <file/file_path.h>\n#include <compat/strl.h>\n#include <compat/posix_string.h>\n#include <string/stdstring.h>\n#include <streams/file_stream.h>\n#include <array/rhmap.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"file_path_special.h\"\n#include \"command.h\"\n#include \"configuration.h\"\n#include \"content.h\"\n#include \"config.def.h\"\n#include \"config.features.h\"\n#include \"input/input_keymaps.h\"\n#include \"input/input_remapping.h\"\n#include \"led/led_defines.h\"\n#include \"defaults.h\"\n#include \"core.h\"\n#include \"paths.h\"\n#include \"retroarch.h\"\n#include \"verbosity.h\"\n\n#include \"audio/audio_driver.h\"\n#include \"record/record_driver.h\"\n#include \"gfx/gfx_animation.h\"\n\n#include \"tasks/task_content.h\"\n#include \"tasks/tasks_internal.h\"\n\n#include \"list_special.h\"\n\n#if defined(__WINRT__) || defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP\n#include \"uwp/uwp_func.h\"\n#endif\n\n#include \"lakka.h\"\n\n#ifdef HAVE_LAKKA_SWITCH\n#include \"lakka-switch.h\"\n#endif\n\n#if defined(HAVE_LIBNX)\n#include \"switch_performance_profiles.h\"\n#endif\n\n#if __APPLE__\n#include \"ui/drivers/cocoa/apple_platform.h\"\n#endif\n\n#ifdef HAVE_LAKKA\n#include <time.h>\n#endif\n\nenum video_driver_enum\n{\n   VIDEO_GL                 = 0,\n   VIDEO_GL1,\n   VIDEO_GL_CORE,\n   VIDEO_VULKAN,\n   VIDEO_METAL,\n   VIDEO_DRM,\n   VIDEO_XVIDEO,\n   VIDEO_SDL,\n   VIDEO_SDL2,\n   VIDEO_SDL_DINGUX,\n   VIDEO_SDL_RS90,\n   VIDEO_EXT,\n   VIDEO_WII,\n   VIDEO_WIIU,\n   VIDEO_XENON360,\n   VIDEO_PSP1,\n   VIDEO_VITA2D,\n   VIDEO_PS2,\n   VIDEO_CTR,\n   VIDEO_SWITCH,\n   VIDEO_D3D8,\n   VIDEO_D3D9_CG,\n   VIDEO_D3D9_HLSL,\n   VIDEO_D3D10,\n   VIDEO_D3D11,\n   VIDEO_D3D12,\n   VIDEO_VG,\n   VIDEO_OMAP,\n   VIDEO_EXYNOS,\n   VIDEO_SUNXI,\n   VIDEO_DISPMANX,\n   VIDEO_CACA,\n   VIDEO_GDI,\n   VIDEO_VGA,\n   VIDEO_FPGA,\n   VIDEO_RSX,\n   VIDEO_NULL\n};\n\nenum audio_driver_enum\n{\n   AUDIO_RSOUND             = VIDEO_NULL + 1,\n   AUDIO_AUDIOIO,\n   AUDIO_OSS,\n   AUDIO_ALSA,\n   AUDIO_ALSATHREAD,\n   AUDIO_TINYALSA,\n   AUDIO_ROAR,\n   AUDIO_AL,\n   AUDIO_SL,\n   AUDIO_JACK,\n   AUDIO_SDL,\n   AUDIO_SDL2,\n   AUDIO_XAUDIO,\n   AUDIO_PULSE,\n   AUDIO_EXT,\n   AUDIO_DSOUND,\n   AUDIO_WASAPI,\n   AUDIO_COREAUDIO,\n   AUDIO_COREAUDIO3,\n   AUDIO_PS3,\n   AUDIO_XENON360,\n   AUDIO_WII,\n   AUDIO_WIIU,\n   AUDIO_RWEBAUDIO,\n   AUDIO_PSP,\n   AUDIO_PS2,\n   AUDIO_CTR,\n   AUDIO_SWITCH,\n   AUDIO_PIPEWIRE,\n   AUDIO_NULL\n};\n\nenum microphone_driver_enum\n{\n   MICROPHONE_ALSA = AUDIO_NULL + 1,\n   MICROPHONE_ALSATHREAD,\n   MICROPHONE_SDL2,\n   MICROPHONE_WASAPI,\n   MICROPHONE_PIPEWIRE,\n   MICROPHONE_NULL\n};\n\nenum audio_resampler_driver_enum\n{\n   AUDIO_RESAMPLER_CC       = MICROPHONE_NULL + 1,\n   AUDIO_RESAMPLER_SINC,\n   AUDIO_RESAMPLER_NEAREST,\n   AUDIO_RESAMPLER_NULL\n};\n\nenum input_driver_enum\n{\n   INPUT_ANDROID            = AUDIO_RESAMPLER_NULL + 1,\n   INPUT_SDL,\n   INPUT_SDL2,\n   INPUT_SDL_DINGUX,\n   INPUT_X,\n   INPUT_WAYLAND,\n   INPUT_DINPUT,\n   INPUT_PS4,\n   INPUT_PS3,\n   INPUT_PSP,\n   INPUT_PS2,\n   INPUT_CTR,\n   INPUT_SWITCH,\n   INPUT_XENON360,\n   INPUT_WII,\n   INPUT_WIIU,\n   INPUT_XINPUT,\n   INPUT_UWP,\n   INPUT_UDEV,\n   INPUT_LINUXRAW,\n   INPUT_COCOA,\n   INPUT_QNX,\n   INPUT_RWEBINPUT,\n   INPUT_DOS,\n   INPUT_WINRAW,\n   INPUT_NULL\n};\n\nenum joypad_driver_enum\n{\n   JOYPAD_PS3               = INPUT_NULL + 1,\n   JOYPAD_XINPUT,\n   JOYPAD_GX,\n   JOYPAD_WIIU,\n   JOYPAD_XDK,\n   JOYPAD_PS4,\n   JOYPAD_PSP,\n   JOYPAD_PS2,\n   JOYPAD_CTR,\n   JOYPAD_SWITCH,\n   JOYPAD_DINPUT,\n   JOYPAD_UDEV,\n   JOYPAD_LINUXRAW,\n   JOYPAD_ANDROID,\n   JOYPAD_SDL,\n   JOYPAD_SDL_DINGUX,\n   JOYPAD_DOS,\n   JOYPAD_HID,\n   JOYPAD_QNX,\n   JOYPAD_RWEBPAD,\n   JOYPAD_MFI,\n   JOYPAD_NULL\n};\n\nenum camera_driver_enum\n{\n   CAMERA_V4L2              = JOYPAD_NULL + 1,\n   CAMERA_RWEBCAM,\n   CAMERA_ANDROID,\n   CAMERA_AVFOUNDATION,\n   CAMERA_NULL\n};\n\nenum bluetooth_driver_enum\n{\n   BLUETOOTH_BLUETOOTHCTL   = CAMERA_NULL + 1,\n   BLUETOOTH_BLUEZ,\n   BLUETOOTH_NULL\n};\n\nenum wifi_driver_enum\n{\n   WIFI_CONNMANCTL          = BLUETOOTH_NULL + 1,\n   WIFI_NMCLI,\n   WIFI_NULL\n};\n\nenum location_driver_enum\n{\n   LOCATION_ANDROID         = WIFI_NULL + 1,\n   LOCATION_CORELOCATION,\n   LOCATION_NULL\n};\n\nenum osk_driver_enum\n{\n   OSK_PS3                  = LOCATION_NULL + 1,\n   OSK_NULL\n};\n\nenum menu_driver_enum\n{\n   MENU_RGUI                = OSK_NULL + 1,\n   MENU_MATERIALUI,\n   MENU_XMB,\n   MENU_STRIPES,\n   MENU_OZONE,\n   MENU_NULL\n};\n\nenum record_driver_enum\n{\n   RECORD_FFMPEG            = MENU_NULL + 1,\n   RECORD_NULL\n};\n\nenum midi_driver_enum\n{\n   MIDI_WINMM               = RECORD_NULL + 1,\n   MIDI_ALSA,\n   MIDI_NULL\n};\n\n#define DECLARE_BIND(base, bind, desc) { #base, desc, 0, bind, true }\n#define DECLARE_META_BIND(level, base, bind, desc) { #base, desc, level, bind, true }\n\nconst struct input_bind_map input_config_bind_map[RARCH_BIND_LIST_END_NULL] = {\n   DECLARE_BIND(b,                             RETRO_DEVICE_ID_JOYPAD_B,     MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_B),\n   DECLARE_BIND(y,                             RETRO_DEVICE_ID_JOYPAD_Y,     MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_Y),\n   DECLARE_BIND(select,                        RETRO_DEVICE_ID_JOYPAD_SELECT,MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_SELECT),\n   DECLARE_BIND(start,                         RETRO_DEVICE_ID_JOYPAD_START, MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_START),\n   DECLARE_BIND(up,                            RETRO_DEVICE_ID_JOYPAD_UP,    MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_UP),\n   DECLARE_BIND(down,                          RETRO_DEVICE_ID_JOYPAD_DOWN,  MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_DOWN),\n   DECLARE_BIND(left,                          RETRO_DEVICE_ID_JOYPAD_LEFT,  MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_LEFT),\n   DECLARE_BIND(right,                         RETRO_DEVICE_ID_JOYPAD_RIGHT, MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_RIGHT),\n   DECLARE_BIND(a,                             RETRO_DEVICE_ID_JOYPAD_A,     MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_A),\n   DECLARE_BIND(x,                             RETRO_DEVICE_ID_JOYPAD_X,     MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_X),\n   DECLARE_BIND(l,                             RETRO_DEVICE_ID_JOYPAD_L,     MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L),\n   DECLARE_BIND(r,                             RETRO_DEVICE_ID_JOYPAD_R,     MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R),\n   DECLARE_BIND(l2,                            RETRO_DEVICE_ID_JOYPAD_L2,    MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L2),\n   DECLARE_BIND(r2,                            RETRO_DEVICE_ID_JOYPAD_R2,    MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R2),\n   DECLARE_BIND(l3,                            RETRO_DEVICE_ID_JOYPAD_L3,    MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L3),\n   DECLARE_BIND(r3,                            RETRO_DEVICE_ID_JOYPAD_R3,    MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R3),\n   DECLARE_BIND(l_x_plus,                      RARCH_ANALOG_LEFT_X_PLUS,     MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_X_PLUS),\n   DECLARE_BIND(l_x_minus,                     RARCH_ANALOG_LEFT_X_MINUS,    MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_X_MINUS),\n   DECLARE_BIND(l_y_plus,                      RARCH_ANALOG_LEFT_Y_PLUS,     MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_Y_PLUS),\n   DECLARE_BIND(l_y_minus,                     RARCH_ANALOG_LEFT_Y_MINUS,    MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_Y_MINUS),\n   DECLARE_BIND(r_x_plus,                      RARCH_ANALOG_RIGHT_X_PLUS,    MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_X_PLUS),\n   DECLARE_BIND(r_x_minus,                     RARCH_ANALOG_RIGHT_X_MINUS,   MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_X_MINUS),\n   DECLARE_BIND(r_y_plus,                      RARCH_ANALOG_RIGHT_Y_PLUS,    MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_Y_PLUS),\n   DECLARE_BIND(r_y_minus,                     RARCH_ANALOG_RIGHT_Y_MINUS,   MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_Y_MINUS),\n\n   DECLARE_BIND(gun_trigger,                   RARCH_LIGHTGUN_TRIGGER,       MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_TRIGGER),\n   DECLARE_BIND(gun_offscreen_shot,            RARCH_LIGHTGUN_RELOAD,        MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_RELOAD),\n   DECLARE_BIND(gun_aux_a,                     RARCH_LIGHTGUN_AUX_A,         MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_A),\n   DECLARE_BIND(gun_aux_b,                     RARCH_LIGHTGUN_AUX_B,         MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_B),\n   DECLARE_BIND(gun_aux_c,                     RARCH_LIGHTGUN_AUX_C,         MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_C),\n   DECLARE_BIND(gun_start,                     RARCH_LIGHTGUN_START,         MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_START),\n   DECLARE_BIND(gun_select,                    RARCH_LIGHTGUN_SELECT,        MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_SELECT),\n   DECLARE_BIND(gun_dpad_up,                   RARCH_LIGHTGUN_DPAD_UP,       MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_UP),\n   DECLARE_BIND(gun_dpad_down,                 RARCH_LIGHTGUN_DPAD_DOWN,     MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_DOWN),\n   DECLARE_BIND(gun_dpad_left,                 RARCH_LIGHTGUN_DPAD_LEFT,     MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_LEFT),\n   DECLARE_BIND(gun_dpad_right,                RARCH_LIGHTGUN_DPAD_RIGHT,    MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_RIGHT),\n\n   DECLARE_BIND(turbo,                         RARCH_TURBO_ENABLE,           MENU_ENUM_LABEL_VALUE_INPUT_TURBO_ENABLE),\n\n   DECLARE_META_BIND(2, enable_hotkey,         RARCH_ENABLE_HOTKEY,          MENU_ENUM_LABEL_VALUE_INPUT_META_ENABLE_HOTKEY),\n#ifdef HAVE_MENU\n   DECLARE_META_BIND(1, menu_toggle,           RARCH_MENU_TOGGLE,            MENU_ENUM_LABEL_VALUE_INPUT_META_MENU_TOGGLE),\n#endif\n#ifdef HAVE_LAKKA\n   DECLARE_META_BIND(2, exit_emulator,         RARCH_QUIT_KEY,               MENU_ENUM_LABEL_VALUE_INPUT_META_RESTART_KEY),\n#else\n   DECLARE_META_BIND(2, exit_emulator,         RARCH_QUIT_KEY,               MENU_ENUM_LABEL_VALUE_INPUT_META_QUIT_KEY),\n#endif\n   DECLARE_META_BIND(2, close_content,         RARCH_CLOSE_CONTENT_KEY,      MENU_ENUM_LABEL_VALUE_INPUT_META_CLOSE_CONTENT_KEY),\n   DECLARE_META_BIND(2, reset,                 RARCH_RESET,                  MENU_ENUM_LABEL_VALUE_INPUT_META_RESET),\n   DECLARE_META_BIND(1, toggle_fast_forward,   RARCH_FAST_FORWARD_KEY,       MENU_ENUM_LABEL_VALUE_INPUT_META_FAST_FORWARD_KEY),\n   DECLARE_META_BIND(2, hold_fast_forward,     RARCH_FAST_FORWARD_HOLD_KEY,  MENU_ENUM_LABEL_VALUE_INPUT_META_FAST_FORWARD_HOLD_KEY),\n   DECLARE_META_BIND(1, toggle_slowmotion,     RARCH_SLOWMOTION_KEY,         MENU_ENUM_LABEL_VALUE_INPUT_META_SLOWMOTION_KEY),\n   DECLARE_META_BIND(2, hold_slowmotion,       RARCH_SLOWMOTION_HOLD_KEY,    MENU_ENUM_LABEL_VALUE_INPUT_META_SLOWMOTION_HOLD_KEY),\n   DECLARE_META_BIND(1, rewind,                RARCH_REWIND,                 MENU_ENUM_LABEL_VALUE_INPUT_META_REWIND),\n   DECLARE_META_BIND(2, pause_toggle,          RARCH_PAUSE_TOGGLE,           MENU_ENUM_LABEL_VALUE_INPUT_META_PAUSE_TOGGLE),\n   DECLARE_META_BIND(2, frame_advance,         RARCH_FRAMEADVANCE,           MENU_ENUM_LABEL_VALUE_INPUT_META_FRAMEADVANCE),\n\n   DECLARE_META_BIND(2, audio_mute,            RARCH_MUTE,                   MENU_ENUM_LABEL_VALUE_INPUT_META_MUTE),\n   DECLARE_META_BIND(2, volume_up,             RARCH_VOLUME_UP,              MENU_ENUM_LABEL_VALUE_INPUT_META_VOLUME_UP),\n   DECLARE_META_BIND(2, volume_down,           RARCH_VOLUME_DOWN,            MENU_ENUM_LABEL_VALUE_INPUT_META_VOLUME_DOWN),\n\n   DECLARE_META_BIND(1, load_state,            RARCH_LOAD_STATE_KEY,         MENU_ENUM_LABEL_VALUE_INPUT_META_LOAD_STATE_KEY),\n   DECLARE_META_BIND(1, save_state,            RARCH_SAVE_STATE_KEY,         MENU_ENUM_LABEL_VALUE_INPUT_META_SAVE_STATE_KEY),\n   DECLARE_META_BIND(2, state_slot_increase,   RARCH_STATE_SLOT_PLUS,        MENU_ENUM_LABEL_VALUE_INPUT_META_STATE_SLOT_PLUS),\n   DECLARE_META_BIND(2, state_slot_decrease,   RARCH_STATE_SLOT_MINUS,       MENU_ENUM_LABEL_VALUE_INPUT_META_STATE_SLOT_MINUS),\n\n   DECLARE_META_BIND(1, play_replay,           RARCH_PLAY_REPLAY_KEY,        MENU_ENUM_LABEL_VALUE_INPUT_META_PLAY_REPLAY_KEY),\n   DECLARE_META_BIND(1, record_replay,         RARCH_RECORD_REPLAY_KEY,      MENU_ENUM_LABEL_VALUE_INPUT_META_RECORD_REPLAY_KEY),\n   DECLARE_META_BIND(1, halt_replay,           RARCH_HALT_REPLAY_KEY,        MENU_ENUM_LABEL_VALUE_INPUT_META_HALT_REPLAY_KEY),\n   DECLARE_META_BIND(2, replay_slot_increase,  RARCH_REPLAY_SLOT_PLUS,       MENU_ENUM_LABEL_VALUE_INPUT_META_REPLAY_SLOT_PLUS),\n   DECLARE_META_BIND(2, replay_slot_decrease,  RARCH_REPLAY_SLOT_MINUS,      MENU_ENUM_LABEL_VALUE_INPUT_META_REPLAY_SLOT_MINUS),\n\n   DECLARE_META_BIND(2, disk_eject_toggle,     RARCH_DISK_EJECT_TOGGLE,      MENU_ENUM_LABEL_VALUE_INPUT_META_DISK_EJECT_TOGGLE),\n   DECLARE_META_BIND(2, disk_next,             RARCH_DISK_NEXT,              MENU_ENUM_LABEL_VALUE_INPUT_META_DISK_NEXT),\n   DECLARE_META_BIND(2, disk_prev,             RARCH_DISK_PREV,              MENU_ENUM_LABEL_VALUE_INPUT_META_DISK_PREV),\n\n   DECLARE_META_BIND(2, shader_toggle,         RARCH_SHADER_TOGGLE,          MENU_ENUM_LABEL_VALUE_INPUT_META_SHADER_TOGGLE),\n   DECLARE_META_BIND(2, shader_next,           RARCH_SHADER_NEXT,            MENU_ENUM_LABEL_VALUE_INPUT_META_SHADER_NEXT),\n   DECLARE_META_BIND(2, shader_prev,           RARCH_SHADER_PREV,            MENU_ENUM_LABEL_VALUE_INPUT_META_SHADER_PREV),\n\n   DECLARE_META_BIND(2, cheat_toggle,          RARCH_CHEAT_TOGGLE,           MENU_ENUM_LABEL_VALUE_INPUT_META_CHEAT_TOGGLE),\n   DECLARE_META_BIND(2, cheat_index_plus,      RARCH_CHEAT_INDEX_PLUS,       MENU_ENUM_LABEL_VALUE_INPUT_META_CHEAT_INDEX_PLUS),\n   DECLARE_META_BIND(2, cheat_index_minus,     RARCH_CHEAT_INDEX_MINUS,      MENU_ENUM_LABEL_VALUE_INPUT_META_CHEAT_INDEX_MINUS),\n\n   DECLARE_META_BIND(2, screenshot,            RARCH_SCREENSHOT,             MENU_ENUM_LABEL_VALUE_INPUT_META_SCREENSHOT),\n   DECLARE_META_BIND(2, recording_toggle,      RARCH_RECORDING_TOGGLE,       MENU_ENUM_LABEL_VALUE_INPUT_META_RECORDING_TOGGLE),\n   DECLARE_META_BIND(2, streaming_toggle,      RARCH_STREAMING_TOGGLE,       MENU_ENUM_LABEL_VALUE_INPUT_META_STREAMING_TOGGLE),\n\n   DECLARE_META_BIND(2, grab_mouse_toggle,     RARCH_GRAB_MOUSE_TOGGLE,      MENU_ENUM_LABEL_VALUE_INPUT_META_GRAB_MOUSE_TOGGLE),\n   DECLARE_META_BIND(2, game_focus_toggle,     RARCH_GAME_FOCUS_TOGGLE,      MENU_ENUM_LABEL_VALUE_INPUT_META_GAME_FOCUS_TOGGLE),\n   DECLARE_META_BIND(2, toggle_fullscreen,     RARCH_FULLSCREEN_TOGGLE_KEY,  MENU_ENUM_LABEL_VALUE_INPUT_META_FULLSCREEN_TOGGLE_KEY),\n   DECLARE_META_BIND(2, desktop_menu_toggle,   RARCH_UI_COMPANION_TOGGLE,    MENU_ENUM_LABEL_VALUE_INPUT_META_UI_COMPANION_TOGGLE),\n\n   DECLARE_META_BIND(2, toggle_vrr_runloop,    RARCH_VRR_RUNLOOP_TOGGLE,     MENU_ENUM_LABEL_VALUE_INPUT_META_VRR_RUNLOOP_TOGGLE),\n   DECLARE_META_BIND(2, runahead_toggle,       RARCH_RUNAHEAD_TOGGLE,        MENU_ENUM_LABEL_VALUE_INPUT_META_RUNAHEAD_TOGGLE),\n   DECLARE_META_BIND(2, preempt_toggle,        RARCH_PREEMPT_TOGGLE,         MENU_ENUM_LABEL_VALUE_INPUT_META_PREEMPT_TOGGLE),\n   DECLARE_META_BIND(2, fps_toggle,            RARCH_FPS_TOGGLE,             MENU_ENUM_LABEL_VALUE_INPUT_META_FPS_TOGGLE),\n   DECLARE_META_BIND(2, toggle_statistics,     RARCH_STATISTICS_TOGGLE,      MENU_ENUM_LABEL_VALUE_INPUT_META_STATISTICS_TOGGLE),\n   DECLARE_META_BIND(2, ai_service,            RARCH_AI_SERVICE,             MENU_ENUM_LABEL_VALUE_INPUT_META_AI_SERVICE),\n\n   DECLARE_META_BIND(2, netplay_ping_toggle,   RARCH_NETPLAY_PING_TOGGLE,    MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_PING_TOGGLE),\n   DECLARE_META_BIND(2, netplay_host_toggle,   RARCH_NETPLAY_HOST_TOGGLE,    MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_HOST_TOGGLE),\n   DECLARE_META_BIND(2, netplay_game_watch,    RARCH_NETPLAY_GAME_WATCH,     MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_GAME_WATCH),\n   DECLARE_META_BIND(2, netplay_player_chat,   RARCH_NETPLAY_PLAYER_CHAT,    MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_PLAYER_CHAT),\n   DECLARE_META_BIND(2, netplay_fade_chat_toggle, RARCH_NETPLAY_FADE_CHAT_TOGGLE, MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_FADE_CHAT_TOGGLE),\n\n   /* Hidden in displaylist */\n   DECLARE_META_BIND(2, overlay_next,          RARCH_OVERLAY_NEXT,           MENU_ENUM_LABEL_VALUE_INPUT_META_OVERLAY_NEXT),\n\n   DECLARE_META_BIND(2, osk_toggle,            RARCH_OSK,                    MENU_ENUM_LABEL_VALUE_INPUT_META_OSK),\n#if 0\n   /* Deprecated */\n   DECLARE_META_BIND(2, send_debug_info,       RARCH_SEND_DEBUG_INFO,        MENU_ENUM_LABEL_VALUE_INPUT_META_SEND_DEBUG_INFO),\n#endif\n};\n\n#if defined(HAVE_METAL)\n#if defined(HAVE_VULKAN)\n/* Default to Vulkan/MoltenVK when available */\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_VULKAN;\n#else\n/* iOS supports both the OpenGL and Metal video drivers; default to OpenGL since Metal support is preliminary */\n#if defined(HAVE_COCOATOUCH) && defined(HAVE_OPENGL)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_GL;\n#else\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_METAL;\n#endif\n#endif\n#elif defined(HAVE_D3D11) || defined(__WINRT__) || (defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP)\n/* Default to D3D11 in UWP, even when its compiled with ANGLE, since ANGLE is just calling D3D anyway.*/\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_D3D11;\n#elif defined(HAVE_OPENGL1) && defined(_MSC_VER) && (_MSC_VER <= 1600)\n/* On Windows XP and earlier, use gl1 by default\n * (regular opengl has compatibility issues with\n * obsolete hardware drivers...) */\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_GL1;\n#elif defined(HAVE_VITA2D)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_VITA2D;\n#elif defined(HAVE_OPENGL) || defined(HAVE_OPENGLES) || defined(HAVE_PSGL)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_GL;\n#elif defined(HAVE_OPENGL_CORE) && !defined(__HAIKU__)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_GL_CORE;\n#elif defined(HAVE_OPENGL1)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_GL1;\n#elif defined(HAVE_VULKAN)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_VULKAN;\n#elif defined(GEKKO)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_WII;\n#elif defined(WIIU)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_WIIU;\n#elif defined(XENON)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_XENON360;\n#elif defined(HAVE_D3D12)\n/* FIXME/WARNING: DX12 performance on Xbox is horrible for\n * some reason. For now, we will default to D3D11 when possible. */\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_D3D12;\n#elif defined(HAVE_D3D10)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_D3D10;\n#elif defined(HAVE_D3D9)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_D3D9;\n#elif defined(HAVE_D3D8)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_D3D8;\n#elif defined(HAVE_VG)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_VG;\n#elif defined(PSP)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_PSP1;\n#elif defined(PS2)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_PS2;\n#elif defined(_3DS)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_CTR;\n#elif defined(SWITCH)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_SWITCH;\n#elif defined(HAVE_XVIDEO)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_XVIDEO;\n#elif defined(HAVE_SDL) && !defined(HAVE_SDL_DINGUX)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_SDL;\n#elif defined(HAVE_SDL2)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_SDL2;\n#elif defined(HAVE_SDL_DINGUX)\n#if defined(RS90) || defined(MIYOO)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_SDL_RS90;\n#else\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_SDL_DINGUX;\n#endif\n#elif defined(_WIN32) && !defined(_XBOX)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_GDI;\n#elif defined(DJGPP)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_VGA;\n#elif defined(HAVE_FPGA)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_FPGA;\n#elif defined(HAVE_DYLIB) && !defined(ANDROID)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_EXT;\n#elif defined(__PSL1GHT__)\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_RSX;\n#else\nstatic const enum video_driver_enum VIDEO_DEFAULT_DRIVER = VIDEO_NULL;\n#endif\n\n#if defined(XENON)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_XENON360;\n#elif defined(GEKKO)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_WII;\n#elif defined(WIIU)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_WIIU;\n#elif defined(PSP) || defined(VITA) || defined(ORBIS)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_PSP;\n#elif defined(PS2)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_PS2;\n#elif defined(__PS3__)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_PS3;\n#elif defined(_3DS)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_CTR;\n#elif defined(SWITCH)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_SWITCH;\n#elif (defined(DINGUX_BETA) || defined(MIYOO)) && defined(HAVE_ALSA)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_ALSA;\n#elif defined(DINGUX) && defined(HAVE_AL)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_AL;\n#elif defined(HAVE_PULSE)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_PULSE;\n#elif defined(HAVE_PIPEWIRE)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_PIPEWIRE;\n#elif defined(HAVE_ALSA) && defined(HAVE_THREADS)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_ALSATHREAD;\n#elif defined(HAVE_ALSA)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_ALSA;\n#elif defined(HAVE_TINYALSA)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_TINYALSA;\n#elif defined(HAVE_AUDIOIO)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_AUDIOIO;\n#elif defined(HAVE_OSS)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_OSS;\n#elif defined(HAVE_JACK)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_JACK;\n#elif defined(HAVE_COREAUDIO3) || defined(HAVE_COREAUDIO)\n/* SDL microphone does not play well with coreaudio audio driver */\n#if defined(HAVE_SDL2) && defined(HAVE_MICROPHONE)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_SDL2;\n#elif defined(HAVE_COREAUDIO3)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_COREAUDIO3;\n#elif defined(HAVE_COREAUDIO)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_COREAUDIO;\n#endif\n#elif defined(HAVE_WASAPI)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_WASAPI;\n#elif defined(HAVE_XAUDIO)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_XAUDIO;\n#elif defined(HAVE_DSOUND)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_DSOUND;\n#elif defined(HAVE_AL)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_AL;\n#elif defined(HAVE_SL)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_SL;\n#elif defined(EMSCRIPTEN)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_RWEBAUDIO;\n#elif defined(HAVE_SDL)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_SDL;\n#elif defined(HAVE_SDL2)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_SDL2;\n#elif defined(HAVE_RSOUND)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_RSOUND;\n#elif defined(HAVE_ROAR)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_ROAR;\n#elif defined(HAVE_DYLIB) && !defined(ANDROID)\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_EXT;\n#else\nstatic const enum audio_driver_enum AUDIO_DEFAULT_DRIVER = AUDIO_NULL;\n#endif\n\n#if defined(HAVE_MICROPHONE)\n#if defined(HAVE_WASAPI)\n/* The default mic driver on Windows is WASAPI if it's available. */\nstatic const enum microphone_driver_enum MICROPHONE_DEFAULT_DRIVER = MICROPHONE_WASAPI;\n#elif defined(HAVE_ALSA) && defined(HAVE_THREADS)\n/* The default mic driver on Linux is the threaded ALSA driver, if available. */\nstatic const enum microphone_driver_enum MICROPHONE_DEFAULT_DRIVER = MICROPHONE_ALSATHREAD;\n#elif defined(HAVE_ALSA)\nstatic const enum microphone_driver_enum MICROPHONE_DEFAULT_DRIVER = MICROPHONE_ALSA;\n#elif defined(HAVE_PIPEWIRE)\nstatic const enum microphone_driver_enum MICROPHONE_DEFAULT_DRIVER = MICROPHONE_PIPEWIRE;\n#elif defined(HAVE_SDL2)\n/* The default fallback driver is SDL2, if available. */\nstatic const enum microphone_driver_enum MICROPHONE_DEFAULT_DRIVER = MICROPHONE_SDL2;\n#else\nstatic const enum microphone_driver_enum MICROPHONE_DEFAULT_DRIVER = MICROPHONE_NULL;\n#endif\n#endif\n\n#if defined(RS90) || defined(MIYOO)\nstatic const enum audio_resampler_driver_enum AUDIO_DEFAULT_RESAMPLER_DRIVER = AUDIO_RESAMPLER_NEAREST;\n#elif defined(PSP) || defined(EMSCRIPTEN)\nstatic const enum audio_resampler_driver_enum AUDIO_DEFAULT_RESAMPLER_DRIVER = AUDIO_RESAMPLER_CC;\n#else\nstatic const enum audio_resampler_driver_enum AUDIO_DEFAULT_RESAMPLER_DRIVER = AUDIO_RESAMPLER_SINC;\n#endif\n\n#if defined(HAVE_FFMPEG)\nstatic const enum record_driver_enum RECORD_DEFAULT_DRIVER = RECORD_FFMPEG;\n#else\nstatic const enum record_driver_enum RECORD_DEFAULT_DRIVER = RECORD_NULL;\n#endif\n\n#ifdef HAVE_WINMM\nstatic const enum midi_driver_enum MIDI_DEFAULT_DRIVER = MIDI_WINMM;\n#elif defined(HAVE_ALSA) && !defined(HAVE_HAKCHI) && !defined(HAVE_SEGAM) && !defined(DINGUX)\nstatic const enum midi_driver_enum MIDI_DEFAULT_DRIVER = MIDI_ALSA;\n#else\nstatic const enum midi_driver_enum MIDI_DEFAULT_DRIVER = MIDI_NULL;\n#endif\n\n#if defined(HAVE_STEAM) && defined(__linux__) && defined(HAVE_SDL2)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_SDL2;\n#elif defined(__WINRT__) || defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_UWP;\n#elif defined(XENON)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_XENON360;\n#elif defined(_XBOX360) || defined(_XBOX) || defined(HAVE_XINPUT2) || defined(HAVE_XINPUT_XBOX1)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_XINPUT;\n#elif defined(ANDROID)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_ANDROID;\n#elif defined(EMSCRIPTEN) && defined(HAVE_SDL2)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_SDL2;\n#elif defined(WEBOS) && defined(HAVE_SDL2)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_SDL2;\n#elif defined(EMSCRIPTEN)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_RWEBINPUT;\n#elif defined(_WIN32) && defined(HAVE_DINPUT)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_DINPUT;\n#elif defined(_WIN32) && !defined(HAVE_DINPUT) && _WIN32_WINNT >= 0x0501\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_WINRAW;\n#elif defined(PS2)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_PS2;\n#elif defined(__PS3__)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_PS3;\n#elif defined(ORBIS)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_PS4;\n#elif defined(PSP) || defined(VITA)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_PSP;\n#elif defined(_3DS)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_CTR;\n#elif defined(SWITCH)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_SWITCH;\n#elif defined(GEKKO)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_WII;\n#elif defined(WIIU)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_WIIU;\n#elif defined(DINGUX) && defined(HAVE_SDL_DINGUX)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_SDL_DINGUX;\n#elif defined(HAVE_X11)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_X;\n#elif defined(HAVE_UDEV)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_UDEV;\n#elif defined(__linux__) && !defined(ANDROID)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_LINUXRAW;\n#elif defined(HAVE_WAYLAND)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_WAYLAND;\n#elif defined(HAVE_COCOA) || defined(HAVE_COCOATOUCH) || defined(HAVE_COCOA_METAL)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_COCOA;\n#elif defined(__QNX__)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_QNX;\n#elif defined(HAVE_SDL)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_SDL;\n#elif defined(HAVE_SDL2)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_SDL2;\n#elif defined(DJGPP)\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_DOS;\n#else\nstatic const enum input_driver_enum INPUT_DEFAULT_DRIVER = INPUT_NULL;\n#endif\n\n#if defined(HAVE_STEAM) && defined(__linux__) && defined(HAVE_SDL2)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_SDL;\n#elif defined(HAVE_XINPUT)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_XINPUT;\n#elif defined(GEKKO)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_GX;\n#elif defined(WIIU)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_WIIU;\n#elif defined(WEBOS)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_SDL;\n#elif defined(_XBOX)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_XDK;\n#elif defined(PS2)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_PS2;\n#elif defined(__PS3__) || defined(__PSL1GHT__)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_PS3;\n#elif defined(ORBIS)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_PS4;\n#elif defined(PSP) || defined(VITA)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_PSP;\n#elif defined(_3DS)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_CTR;\n#elif defined(SWITCH)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_SWITCH;\n#elif defined(DINGUX) && defined(HAVE_SDL_DINGUX)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_SDL_DINGUX;\n#elif defined(HAVE_DINPUT)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_DINPUT;\n#elif defined(HAVE_UDEV)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_UDEV;\n#elif defined(__linux) && !defined(ANDROID)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_LINUXRAW;\n#elif defined(ANDROID)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_ANDROID;\n#elif defined(HAVE_MFI)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_MFI;\n#elif defined(HAVE_SDL) || defined(HAVE_SDL2)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_SDL;\n#elif defined(DJGPP)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_DOS;\n#elif defined(HAVE_HID)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_HID;\n#elif defined(__QNX__)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_QNX;\n#elif defined(EMSCRIPTEN)\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_RWEBPAD;\n#else\nstatic const enum joypad_driver_enum JOYPAD_DEFAULT_DRIVER = JOYPAD_NULL;\n#endif\n\n#if defined(HAVE_V4L2)\nstatic const enum camera_driver_enum CAMERA_DEFAULT_DRIVER = CAMERA_V4L2;\n#elif defined(EMSCRIPTEN)\nstatic const enum camera_driver_enum CAMERA_DEFAULT_DRIVER = CAMERA_RWEBCAM;\n#elif defined(ANDROID)\nstatic const enum camera_driver_enum CAMERA_DEFAULT_DRIVER = CAMERA_ANDROID;\n#else\nstatic const enum camera_driver_enum CAMERA_DEFAULT_DRIVER = CAMERA_NULL;\n#endif\n\n#if defined(HAVE_BLUETOOTH)\n# if defined(HAVE_DBUS)\nstatic const enum bluetooth_driver_enum BLUETOOTH_DEFAULT_DRIVER = BLUETOOTH_BLUEZ;\n# else\nstatic const enum bluetooth_driver_enum BLUETOOTH_DEFAULT_DRIVER = BLUETOOTH_BLUETOOTHCTL;\n# endif\n#else\nstatic const enum bluetooth_driver_enum BLUETOOTH_DEFAULT_DRIVER = BLUETOOTH_NULL;\n#endif\n\n#if defined(HAVE_LAKKA)\nstatic const enum wifi_driver_enum WIFI_DEFAULT_DRIVER = WIFI_CONNMANCTL;\n#else\nstatic const enum wifi_driver_enum WIFI_DEFAULT_DRIVER = WIFI_NULL;\n#endif\n\n#if defined(ANDROID)\nstatic const enum location_driver_enum LOCATION_DEFAULT_DRIVER = LOCATION_ANDROID;\n#else\nstatic const enum location_driver_enum LOCATION_DEFAULT_DRIVER = LOCATION_NULL;\n#endif\n\n#if (defined(_3DS) || defined(DINGUX)) && defined(HAVE_RGUI)\nstatic const enum menu_driver_enum MENU_DEFAULT_DRIVER = MENU_RGUI;\n#elif defined(IOS) && !TARGET_OS_TV\n#define MENU_DEFAULT_DRIVER (ios_running_on_ipad() ? MENU_OZONE : MENU_MATERIALUI)\n#elif defined(HAVE_MATERIALUI) && defined(RARCH_MOBILE)\nstatic const enum menu_driver_enum MENU_DEFAULT_DRIVER = MENU_MATERIALUI;\n#elif defined(HAVE_OZONE)\nstatic const enum menu_driver_enum MENU_DEFAULT_DRIVER = MENU_OZONE;\n#elif defined(HAVE_XMB) && !defined(_XBOX)\nstatic const enum menu_driver_enum MENU_DEFAULT_DRIVER = MENU_XMB;\n#elif defined(HAVE_RGUI)\nstatic const enum menu_driver_enum MENU_DEFAULT_DRIVER = MENU_RGUI;\n#else\nstatic const enum menu_driver_enum MENU_DEFAULT_DRIVER = MENU_NULL;\n#endif\n\n/* All config related settings go here. */\nenum config_bool_flags\n{\n   CFG_BOOL_FLG_DEF_ENABLE = (1 << 0),\n   CFG_BOOL_FLG_HANDLE     = (1 << 1)\n};\n\nstruct config_bool_setting\n{\n   const char *ident;\n   bool *ptr;\n   enum rarch_override_setting override;\n   uint8_t flags;\n   bool def;\n};\n\nstruct config_int_setting\n{\n   const char *ident;\n   int *ptr;\n   int def;\n   enum rarch_override_setting override;\n   uint8_t flags;\n};\n\nstruct config_uint_setting\n{\n   const char *ident;\n   unsigned *ptr;\n   unsigned def;\n   enum rarch_override_setting override;\n   uint8_t flags;\n};\n\nstruct config_size_setting\n{\n   const char *ident;\n   size_t *ptr;\n   size_t def;\n   enum rarch_override_setting override;\n   uint8_t flags;\n};\n\nstruct config_float_setting\n{\n   const char *ident;\n   float *ptr;\n   float def;\n   enum rarch_override_setting override;\n   uint8_t flags;\n};\n\nstruct config_array_setting\n{\n   const char *ident;\n   const char *def;\n   char *ptr;\n   enum rarch_override_setting override;\n   uint8_t flags;\n};\n\nstruct config_path_setting\n{\n   const char *ident;\n   char *ptr;\n   char *def;\n   uint8_t flags;\n};\n\n#define GENERAL_SETTING(key, configval, default_enable, default_setting, type, handle_setting) \\\n{ \\\n   tmp[count].ident      = key; \\\n   tmp[count].ptr        = configval; \\\n   if (default_enable) \\\n   { \\\n      tmp[count].flags |= CFG_BOOL_FLG_DEF_ENABLE; \\\n      tmp[count].def    = default_setting; \\\n   } \\\n   if (handle_setting) \\\n      tmp[count].flags |= CFG_BOOL_FLG_HANDLE; \\\n   count++; \\\n}\n\n#define SETTING_BOOL(key, configval, default_enable, default_setting, handle_setting) \\\n   GENERAL_SETTING(key, configval, default_enable, default_setting, struct config_bool_setting, handle_setting)\n\n#define SETTING_FLOAT(key, configval, default_enable, default_setting, handle_setting) \\\n   GENERAL_SETTING(key, configval, default_enable, default_setting, struct config_float_setting, handle_setting)\n\n#define SETTING_INT(key, configval, default_enable, default_setting, handle_setting) \\\n   GENERAL_SETTING(key, configval, default_enable, default_setting, struct config_int_setting, handle_setting)\n\n#define SETTING_UINT(key, configval, default_enable, default_setting, handle_setting) \\\n   GENERAL_SETTING(key, configval, default_enable, default_setting, struct config_uint_setting, handle_setting)\n\n#define SETTING_SIZE(key, configval, default_enable, default_setting, handle_setting) \\\n   GENERAL_SETTING(key, configval, default_enable, default_setting, struct config_size_setting, handle_setting)\n\n#define SETTING_PATH(key, configval, default_enable, default_setting, handle_setting) \\\n   GENERAL_SETTING(key, configval, default_enable, default_setting, struct config_path_setting, handle_setting)\n\n#define SETTING_ARRAY(key, configval, default_enable, default_setting, handle_setting) \\\n   GENERAL_SETTING(key, configval, default_enable, default_setting, struct config_array_setting, handle_setting)\n\n#define SETTING_OVERRIDE(override_setting) \\\n   tmp[count-1].override = override_setting\n\n/* Forward declarations */\n#ifdef HAVE_CONFIGFILE\nstatic void config_parse_file(global_t *global);\n#endif\n\nstruct defaults g_defaults;\n\nstatic settings_t *config_st = NULL;\n\nsettings_t *config_get_ptr(void)\n{\n   return config_st;\n}\n\n/**\n * config_get_default_audio:\n *\n * Gets default audio driver.\n *\n * Returns: Default audio driver.\n **/\nconst char *config_get_default_audio(void)\n{\n   enum audio_driver_enum default_driver = AUDIO_DEFAULT_DRIVER;\n\n   switch (default_driver)\n   {\n      case AUDIO_RSOUND:\n         return \"rsound\";\n      case AUDIO_AUDIOIO:\n         return \"audioio\";\n      case AUDIO_OSS:\n         return \"oss\";\n      case AUDIO_ALSA:\n         return \"alsa\";\n      case AUDIO_ALSATHREAD:\n         return \"alsathread\";\n      case AUDIO_TINYALSA:\n         return \"tinyalsa\";\n      case AUDIO_ROAR:\n         return \"roar\";\n      case AUDIO_COREAUDIO:\n         return \"coreaudio\";\n      case AUDIO_COREAUDIO3:\n         return \"coreaudio3\";\n      case AUDIO_AL:\n         return \"openal\";\n      case AUDIO_SL:\n         return \"opensl\";\n      case AUDIO_SDL:\n         return \"sdl\";\n      case AUDIO_SDL2:\n         return \"sdl2\";\n      case AUDIO_DSOUND:\n         return \"dsound\";\n      case AUDIO_WASAPI:\n         return \"wasapi\";\n      case AUDIO_XAUDIO:\n         return \"xaudio\";\n      case AUDIO_PULSE:\n         return \"pulse\";\n      case AUDIO_PIPEWIRE:\n         return \"pipewire\";\n      case AUDIO_EXT:\n         return \"ext\";\n      case AUDIO_XENON360:\n         return \"xenon360\";\n      case AUDIO_PS3:\n         return \"ps3\";\n      case AUDIO_WII:\n         return \"gx\";\n      case AUDIO_WIIU:\n         return \"AX\";\n      case AUDIO_PSP:\n#if defined(VITA)\n         return \"vita\";\n#elif defined(ORBIS)\n         return \"orbis\";\n#else\n         return \"psp\";\n#endif\n      case AUDIO_PS2:\n         return \"ps2\";\n      case AUDIO_CTR:\n         return \"dsp\";\n      case AUDIO_SWITCH:\n#if defined(HAVE_LIBNX)\n         return \"switch_audren_thread\";\n#else\n         return \"switch\";\n#endif\n      case AUDIO_RWEBAUDIO:\n         return \"rwebaudio\";\n      case AUDIO_JACK:\n         return \"jack\";\n      case AUDIO_NULL:\n         break;\n   }\n\n   return \"null\";\n}\n\n#if defined(HAVE_MICROPHONE)\n/**\n * config_get_default_microphone:\n *\n * Gets default microphone driver.\n *\n * Returns: Default microphone driver.\n **/\nconst char *config_get_default_microphone(void)\n{\n   enum microphone_driver_enum default_driver = MICROPHONE_DEFAULT_DRIVER;\n\n   switch (default_driver)\n   {\n      case MICROPHONE_ALSA:\n         return \"alsa\";\n      case MICROPHONE_ALSATHREAD:\n         return \"alsathread\";\n      case MICROPHONE_PIPEWIRE:\n         return \"pipewire\";\n      case MICROPHONE_WASAPI:\n         return \"wasapi\";\n      case MICROPHONE_SDL2:\n         return \"sdl2\";\n      case MICROPHONE_NULL:\n         break;\n   }\n\n   return \"null\";\n}\n#endif\n\n\nconst char *config_get_default_record(void)\n{\n   enum record_driver_enum default_driver = RECORD_DEFAULT_DRIVER;\n\n   switch (default_driver)\n   {\n      case RECORD_FFMPEG:\n         return \"ffmpeg\";\n      case RECORD_NULL:\n         break;\n   }\n\n   return \"null\";\n}\n\n/**\n * config_get_default_audio_resampler:\n *\n * Gets default audio resampler driver.\n *\n * Returns: Default audio resampler driver.\n **/\nconst char *config_get_default_audio_resampler(void)\n{\n   enum audio_resampler_driver_enum default_driver = AUDIO_DEFAULT_RESAMPLER_DRIVER;\n\n   switch (default_driver)\n   {\n      case AUDIO_RESAMPLER_CC:\n         return \"cc\";\n      case AUDIO_RESAMPLER_SINC:\n         return \"sinc\";\n      case AUDIO_RESAMPLER_NEAREST:\n         return \"nearest\";\n      case AUDIO_RESAMPLER_NULL:\n         break;\n   }\n\n   return \"null\";\n}\n\n/**\n * config_get_default_video:\n *\n * Gets default video driver.\n *\n * Returns: Default video driver.\n **/\nconst char *config_get_default_video(void)\n{\n   enum video_driver_enum default_driver = VIDEO_DEFAULT_DRIVER;\n\n   switch (default_driver)\n   {\n      case VIDEO_GL:\n         return \"gl\";\n      case VIDEO_GL1:\n         return \"gl1\";\n      case VIDEO_GL_CORE:\n         return \"glcore\";\n      case VIDEO_VULKAN:\n         return \"vulkan\";\n      case VIDEO_METAL:\n         return \"metal\";\n      case VIDEO_DRM:\n         return \"drm\";\n      case VIDEO_WII:\n         return \"gx\";\n      case VIDEO_WIIU:\n         return \"gx2\";\n      case VIDEO_XENON360:\n         return \"xenon360\";\n      case VIDEO_D3D8:\n         return \"d3d8\";\n      case VIDEO_D3D9_CG:\n         return \"d3d9_cg\";\n      case VIDEO_D3D9_HLSL:\n         return \"d3d9_hlsl\";\n      case VIDEO_D3D10:\n         return \"d3d10\";\n      case VIDEO_D3D11:\n         return \"d3d11\";\n      case VIDEO_D3D12:\n         return \"d3d12\";\n      case VIDEO_PSP1:\n         return \"psp1\";\n      case VIDEO_PS2:\n         return \"ps2\";\n      case VIDEO_VITA2D:\n         return \"vita2d\";\n      case VIDEO_CTR:\n         return \"ctr\";\n      case VIDEO_SWITCH:\n         return \"switch\";\n      case VIDEO_XVIDEO:\n         return \"xvideo\";\n      case VIDEO_SDL_DINGUX:\n         return \"sdl_dingux\";\n      case VIDEO_SDL_RS90:\n         return \"sdl_rs90\";\n      case VIDEO_SDL:\n         return \"sdl\";\n      case VIDEO_SDL2:\n         return \"sdl2\";\n      case VIDEO_EXT:\n         return \"ext\";\n      case VIDEO_VG:\n         return \"vg\";\n      case VIDEO_OMAP:\n         return \"omap\";\n      case VIDEO_EXYNOS:\n         return \"exynos\";\n      case VIDEO_DISPMANX:\n         return \"dispmanx\";\n      case VIDEO_SUNXI:\n         return \"sunxi\";\n      case VIDEO_CACA:\n         return \"caca\";\n      case VIDEO_GDI:\n         return \"gdi\";\n      case VIDEO_VGA:\n         return \"vga\";\n      case VIDEO_FPGA:\n         return \"fpga\";\n      case VIDEO_RSX:\n         return \"rsx\";\n      case VIDEO_NULL:\n         break;\n   }\n\n   return \"null\";\n}\n\n/**\n * config_get_default_input:\n *\n * Gets default input driver.\n *\n * Returns: Default input driver.\n **/\nconst char *config_get_default_input(void)\n{\n   enum input_driver_enum default_driver = INPUT_DEFAULT_DRIVER;\n\n   switch (default_driver)\n   {\n      case INPUT_ANDROID:\n         return \"android\";\n      case INPUT_PS4:\n         return \"ps4\";\n      case INPUT_PS3:\n         return \"ps3\";\n      case INPUT_PSP:\n#ifdef VITA\n         return \"vita\";\n#else\n         return \"psp\";\n#endif\n      case INPUT_PS2:\n         return \"ps2\";\n      case INPUT_CTR:\n         return \"ctr\";\n      case INPUT_SWITCH:\n         return \"switch\";\n      case INPUT_SDL:\n         return \"sdl\";\n      case INPUT_SDL2:\n         return \"sdl2\";\n      case INPUT_SDL_DINGUX:\n         return \"sdl_dingux\";\n      case INPUT_DINPUT:\n         return \"dinput\";\n      case INPUT_WINRAW:\n         return \"raw\";\n      case INPUT_X:\n         return \"x\";\n      case INPUT_WAYLAND:\n         return \"wayland\";\n      case INPUT_XENON360:\n         return \"xenon360\";\n      case INPUT_XINPUT:\n         return \"xinput\";\n      case INPUT_UWP:\n         return \"uwp\";\n      case INPUT_WII:\n         return \"gx\";\n      case INPUT_WIIU:\n         return \"wiiu\";\n      case INPUT_LINUXRAW:\n         return \"linuxraw\";\n      case INPUT_UDEV:\n         return \"udev\";\n      case INPUT_COCOA:\n         return \"cocoa\";\n      case INPUT_QNX:\n          return \"qnx_input\";\n      case INPUT_RWEBINPUT:\n          return \"rwebinput\";\n      case INPUT_DOS:\n         return \"dos\";\n      case INPUT_NULL:\n          break;\n   }\n\n   return \"null\";\n}\n\n/**\n * config_get_default_joypad:\n *\n * Gets default input joypad driver.\n *\n * Returns: Default input joypad driver.\n **/\nconst char *config_get_default_joypad(void)\n{\n   enum joypad_driver_enum default_driver = JOYPAD_DEFAULT_DRIVER;\n\n   switch (default_driver)\n   {\n      case JOYPAD_PS4:\n         return \"ps4\";\n      case JOYPAD_PS3:\n         return \"ps3\";\n      case JOYPAD_XINPUT:\n         return \"xinput\";\n      case JOYPAD_GX:\n         return \"gx\";\n      case JOYPAD_WIIU:\n         return \"wiiu\";\n      case JOYPAD_XDK:\n         return \"xdk\";\n      case JOYPAD_PSP:\n#ifdef VITA\n         return \"vita\";\n#else\n         return \"psp\";\n#endif\n      case JOYPAD_PS2:\n         return \"ps2\";\n      case JOYPAD_CTR:\n         return \"ctr\";\n      case JOYPAD_SWITCH:\n         return \"switch\";\n      case JOYPAD_DINPUT:\n         return \"dinput\";\n      case JOYPAD_UDEV:\n         return \"udev\";\n      case JOYPAD_LINUXRAW:\n         return \"linuxraw\";\n      case JOYPAD_ANDROID:\n         return \"android\";\n      case JOYPAD_SDL:\n#ifdef HAVE_SDL2\n         return \"sdl2\";\n#else\n         return \"sdl\";\n#endif\n      case JOYPAD_SDL_DINGUX:\n         return \"sdl_dingux\";\n      case JOYPAD_HID:\n         return \"hid\";\n      case JOYPAD_QNX:\n         return \"qnx\";\n      case JOYPAD_RWEBPAD:\n         return \"rwebpad\";\n      case JOYPAD_DOS:\n         return \"dos\";\n      case JOYPAD_MFI:\n         return \"mfi\";\n      case JOYPAD_NULL:\n         break;\n   }\n\n   return \"null\";\n}\n\n/**\n * config_get_default_camera:\n *\n * Gets default camera driver.\n *\n * Returns: Default camera driver.\n **/\nconst char *config_get_default_camera(void)\n{\n   enum camera_driver_enum default_driver = CAMERA_DEFAULT_DRIVER;\n\n   switch (default_driver)\n   {\n      case CAMERA_V4L2:\n         return \"video4linux2\";\n      case CAMERA_RWEBCAM:\n         return \"rwebcam\";\n      case CAMERA_ANDROID:\n         return \"android\";\n      case CAMERA_AVFOUNDATION:\n         return \"avfoundation\";\n      case CAMERA_NULL:\n         break;\n   }\n\n   return \"null\";\n}\n\n/**\n * config_get_default_bluetooth:\n *\n * Gets default bluetooth driver.\n *\n * Returns: Default bluetooth driver.\n **/\nconst char *config_get_default_bluetooth(void)\n{\n   enum bluetooth_driver_enum default_driver = BLUETOOTH_DEFAULT_DRIVER;\n\n   switch (default_driver)\n   {\n      case BLUETOOTH_BLUETOOTHCTL:\n         return \"bluetoothctl\";\n      case BLUETOOTH_BLUEZ:\n         return \"bluez\";\n      case BLUETOOTH_NULL:\n         break;\n   }\n\n   return \"null\";\n}\n\n/**\n * config_get_default_wifi:\n *\n * Gets default wifi driver.\n *\n * Returns: Default wifi driver.\n **/\nconst char *config_get_default_wifi(void)\n{\n   enum wifi_driver_enum default_driver = WIFI_DEFAULT_DRIVER;\n\n   switch (default_driver)\n   {\n      case WIFI_CONNMANCTL:\n         return \"connmanctl\";\n      case WIFI_NMCLI:\n         return \"nmcli\";\n      case WIFI_NULL:\n         break;\n   }\n\n   return \"null\";\n}\n\n/**\n * config_get_default_led:\n *\n * Gets default led driver.\n *\n * Returns: Default led driver.\n **/\nconst char *config_get_default_led(void)\n{\n   return \"null\";\n}\n\n/**\n * config_get_default_cloudsync:\n *\n * Gets default cloud sync driver.\n *\n * Returns: Default cloud sync driver.\n **/\nconst char *config_get_default_cloudsync(void)\n{\n   return \"null\";\n}\n\n/**\n * config_get_default_location:\n *\n * Gets default location driver.\n *\n * Returns: Default location driver.\n **/\nconst char *config_get_default_location(void)\n{\n   enum location_driver_enum default_driver = LOCATION_DEFAULT_DRIVER;\n\n   switch (default_driver)\n   {\n      case LOCATION_ANDROID:\n         return \"android\";\n      case LOCATION_CORELOCATION:\n         return \"corelocation\";\n      case LOCATION_NULL:\n         break;\n   }\n\n   return \"null\";\n}\n\n/**\n * config_get_default_menu:\n *\n * Gets default menu driver.\n *\n * Returns: Default menu driver.\n **/\nconst char *config_get_default_menu(void)\n{\n#ifdef HAVE_MENU\n   enum menu_driver_enum default_driver = MENU_DEFAULT_DRIVER;\n\n   if (!string_is_empty(g_defaults.settings_menu))\n      return g_defaults.settings_menu;\n\n   switch (default_driver)\n   {\n      case MENU_RGUI:\n         return \"rgui\";\n      case MENU_OZONE:\n         return \"ozone\";\n      case MENU_MATERIALUI:\n         return \"glui\";\n      case MENU_XMB:\n         return \"xmb\";\n      case MENU_STRIPES:\n         return \"stripes\";\n      case MENU_NULL:\n         break;\n   }\n#endif\n\n   return \"null\";\n}\n\nconst char *config_get_default_midi(void)\n{\n   enum midi_driver_enum default_driver = MIDI_DEFAULT_DRIVER;\n\n   switch (default_driver)\n   {\n      case MIDI_WINMM:\n         return \"winmm\";\n      case MIDI_ALSA:\n         return \"alsa\";\n      case MIDI_NULL:\n         break;\n   }\n\n   return \"null\";\n}\n\nconst char *config_get_midi_driver_options(void)\n{\n   return char_list_new_special(STRING_LIST_MIDI_DRIVERS, NULL);\n}\n\n#ifdef HAVE_LAKKA\nvoid config_set_timezone(char *timezone)\n{\n   setenv(\"TZ\", timezone, 1);\n   tzset();\n}\n\nconst char *config_get_all_timezones(void)\n{\n   return char_list_new_special(STRING_LIST_TIMEZONES, NULL);\n}\n\nstatic void load_timezone(char *s, size_t len)\n{\n   char haystack[TIMEZONE_LENGTH+32];\n   RFILE *tzfp             = filestream_open(LAKKA_TIMEZONE_PATH,\n                       RETRO_VFS_FILE_ACCESS_READ,\n                       RETRO_VFS_FILE_ACCESS_HINT_NONE);\n   if (tzfp)\n   {\n      static char *needle = \"TIMEZONE=\";\n      char *start = NULL;\n\n      filestream_gets(tzfp, haystack, sizeof(haystack)-1);\n      filestream_close(tzfp);\n\n      if ((start = strstr(haystack, needle)))\n         strlcpy(s, start + STRLEN_CONST(\"TIMEZONE=\"), len);\n      else\n         strlcpy(s, DEFAULT_TIMEZONE, len);\n   }\n   else\n      strlcpy(s, DEFAULT_TIMEZONE, len);\n   config_set_timezone(s);\n}\n#endif\n\nbool config_overlay_enable_default(void)\n{\n   if (g_defaults.overlay_set)\n      return g_defaults.overlay_enable;\n#if defined(RARCH_MOBILE) && !TARGET_OS_TV\n   return true;\n#else\n   return false;\n#endif\n}\n\nstatic struct config_array_setting *populate_settings_array(\n      settings_t *settings, int *size)\n{\n   unsigned i                           = 0;\n   unsigned count                       = 0;\n   struct config_array_setting  *tmp    = (struct config_array_setting*)calloc(1, (*size + 1) * sizeof(struct config_array_setting));\n\n   if (!tmp)\n      return NULL;\n\n   /* Arrays */\n   SETTING_ARRAY(\"audio_driver\",                 settings->arrays.audio_driver, false, NULL, true);\n   SETTING_ARRAY(\"audio_device\",                 settings->arrays.audio_device, false, NULL, true);\n   SETTING_ARRAY(\"audio_resampler\",              settings->arrays.audio_resampler, false, NULL, true);\n#ifdef HAVE_MICROPHONE\n   SETTING_ARRAY(\"microphone_device\",            settings->arrays.microphone_device, false, NULL, true);\n   SETTING_ARRAY(\"microphone_driver\",            settings->arrays.microphone_driver, false, NULL, true);\n   SETTING_ARRAY(\"microphone_resampler\",         settings->arrays.microphone_resampler, false, NULL, true);\n#endif\n   SETTING_ARRAY(\"midi_driver\",                  settings->arrays.midi_driver, false, NULL, true);\n   SETTING_ARRAY(\"midi_input\",                   settings->arrays.midi_input, true, DEFAULT_MIDI_INPUT, true);\n   SETTING_ARRAY(\"midi_output\",                  settings->arrays.midi_output, true, DEFAULT_MIDI_OUTPUT, true);\n\n   SETTING_ARRAY(\"video_driver\",                 settings->arrays.video_driver, false, NULL, true);\n   SETTING_ARRAY(\"video_context_driver\",         settings->arrays.video_context_driver, false, NULL, true);\n   SETTING_ARRAY(\"crt_switch_timings\",           settings->arrays.crt_switch_timings, false, NULL, true);\n\n   SETTING_ARRAY(\"input_driver\",                 settings->arrays.input_driver, false, NULL, true);\n   SETTING_ARRAY(\"input_joypad_driver\",          settings->arrays.input_joypad_driver, false, NULL, true);\n   SETTING_ARRAY(\"input_keyboard_layout\",        settings->arrays.input_keyboard_layout, false, NULL, true);\n#ifdef ANDROID\n   SETTING_ARRAY(\"input_android_physical_keyboard\", settings->arrays.input_android_physical_keyboard, false, NULL, true);\n#endif\n\n   for (i = 0; i < MAX_USERS; i++)\n   {\n      char key[32];\n      size_t _len  = strlcpy(key, \"input_player\", sizeof(key));\n      _len += snprintf(key + _len, sizeof(key) - _len, \"%u\", i + 1);\n      strlcpy(key + _len, \"_reserved_device\", sizeof(key) - _len);\n      SETTING_ARRAY(strdup(key), settings->arrays.input_reserved_devices[i], false, NULL, true);\n   }\n\n#ifdef HAVE_MENU\n   SETTING_ARRAY(\"menu_driver\",                  settings->arrays.menu_driver, false, NULL, true);\n#endif\n\n   SETTING_ARRAY(\"record_driver\",                settings->arrays.record_driver, false, NULL, true);\n   SETTING_ARRAY(\"camera_driver\",                settings->arrays.camera_driver, false, NULL, true);\n   SETTING_ARRAY(\"camera_device\",                settings->arrays.camera_device, false, NULL, true);\n   SETTING_ARRAY(\"bluetooth_driver\",             settings->arrays.bluetooth_driver, false, NULL, true);\n   SETTING_ARRAY(\"wifi_driver\",                  settings->arrays.wifi_driver, false, NULL, true);\n   SETTING_ARRAY(\"led_driver\",                   settings->arrays.led_driver, false, NULL, true);\n   SETTING_ARRAY(\"location_driver\",              settings->arrays.location_driver, false, NULL, true);\n   SETTING_ARRAY(\"cloud_sync_driver\",            settings->arrays.cloud_sync_driver, false, NULL, true);\n\n#ifdef HAVE_CHEEVOS\n   SETTING_ARRAY(\"cheevos_custom_host\",          settings->arrays.cheevos_custom_host, false, NULL, true);\n   SETTING_ARRAY(\"cheevos_username\",             settings->arrays.cheevos_username, false, NULL, true);\n   SETTING_ARRAY(\"cheevos_password\",             settings->arrays.cheevos_password, false, NULL, true);\n   SETTING_ARRAY(\"cheevos_token\",                settings->arrays.cheevos_token, false, NULL, true);\n   SETTING_ARRAY(\"cheevos_leaderboards_enable\",  settings->arrays.cheevos_leaderboards_enable, true, \"\", true); /* deprecated */\n#endif\n\n#ifdef HAVE_NETWORKING\n   SETTING_ARRAY(\"netplay_mitm_server\",          settings->arrays.netplay_mitm_server, false, NULL, true);\n   SETTING_ARRAY(\"webdav_url\",                   settings->arrays.webdav_url, false, NULL, true);\n   SETTING_ARRAY(\"webdav_username\",              settings->arrays.webdav_username, false, NULL, true);\n   SETTING_ARRAY(\"webdav_password\",              settings->arrays.webdav_password, false, NULL, true);\n   SETTING_ARRAY(\"youtube_stream_key\",           settings->arrays.youtube_stream_key, true, NULL, true);\n   SETTING_ARRAY(\"twitch_stream_key\",            settings->arrays.twitch_stream_key, true, NULL, true);\n   SETTING_ARRAY(\"facebook_stream_key\",          settings->arrays.facebook_stream_key, true, NULL, true);\n   SETTING_ARRAY(\"discord_app_id\",               settings->arrays.discord_app_id, true, DEFAULT_DISCORD_APP_ID, true);\n   SETTING_ARRAY(\"ai_service_url\",               settings->arrays.ai_service_url, true, DEFAULT_AI_SERVICE_URL, true);\n#endif\n\n#ifdef HAVE_LAKKA\n   SETTING_ARRAY(\"cpu_main_gov\",                 settings->arrays.cpu_main_gov, false, NULL, true);\n   SETTING_ARRAY(\"cpu_menu_gov\",                 settings->arrays.cpu_menu_gov, false, NULL, true);\n#endif\n\n   *size = count;\n\n   return tmp;\n}\n\nstatic struct config_path_setting *populate_settings_path(\n      settings_t *settings, int *size)\n{\n   unsigned count = 0;\n   recording_state_t *recording_st     = recording_state_get_ptr();\n   struct config_path_setting  *tmp    = (struct config_path_setting*)calloc(1, (*size + 1) * sizeof(struct config_path_setting));\n\n   if (!tmp)\n      return NULL;\n\n   /* Paths */\n   SETTING_PATH(\"bundle_assets_src_path\",        settings->paths.bundle_assets_src, false, NULL, true);\n   SETTING_PATH(\"bundle_assets_dst_path\",        settings->paths.bundle_assets_dst, false, NULL, true);\n   SETTING_PATH(\"bundle_assets_dst_path_subdir\", settings->paths.bundle_assets_dst_subdir, false, NULL, true);\n   SETTING_PATH(\"core_updater_buildbot_cores_url\",  settings->paths.network_buildbot_url, false, NULL, true);\n   SETTING_PATH(\"core_updater_buildbot_assets_url\", settings->paths.network_buildbot_assets_url, false, NULL, true);\n   SETTING_PATH(\"libretro_directory\",            settings->paths.directory_libretro, false, NULL, false);\n   SETTING_PATH(\"core_options_path\",             settings->paths.path_core_options, false, NULL, true);\n   SETTING_PATH(\"libretro_info_path\",            settings->paths.path_libretro_info, false, NULL, true);\n   SETTING_PATH(\"playlist_directory\",            settings->paths.directory_playlist, true, NULL, true);\n   SETTING_PATH(\"cheat_database_path\",           settings->paths.path_cheat_database, false, NULL, true);\n   SETTING_PATH(\"system_directory\",              settings->paths.directory_system, true, NULL, true);\n   SETTING_PATH(\"cache_directory\",               settings->paths.directory_cache, false, NULL, true);\n   SETTING_PATH(\"audio_dsp_plugin\",              settings->paths.path_audio_dsp_plugin, false, NULL, true);\n   SETTING_PATH(\"audio_filter_dir\",              settings->paths.directory_audio_filter, true, NULL, true);\n   SETTING_PATH(\"video_shader_dir\",              settings->paths.directory_video_shader, true, NULL, true);\n   SETTING_PATH(\"video_filter_dir\",              settings->paths.directory_video_filter, true, NULL, true);\n   SETTING_PATH(\"video_filter\",                  settings->paths.path_softfilter_plugin, false, NULL, true);\n   SETTING_PATH(\"video_font_path\",               settings->paths.path_font, false, NULL, true);\n   SETTING_PATH(\"video_record_config\",           settings->paths.path_record_config, false, NULL, true);\n   SETTING_PATH(\"video_stream_config\",           settings->paths.path_stream_config, false, NULL, true);\n   SETTING_PATH(\"video_stream_url\",              settings->paths.path_stream_url, false, NULL, true);\n   SETTING_PATH(\"input_remapping_directory\",     settings->paths.directory_input_remapping, false, NULL, true);\n   SETTING_PATH(\"core_assets_directory\",         settings->paths.directory_core_assets, true, NULL, true);\n   SETTING_PATH(\"assets_directory\",              settings->paths.directory_assets, true, NULL, true);\n   SETTING_PATH(\"dynamic_wallpapers_directory\",  settings->paths.directory_dynamic_wallpapers, true, NULL, true);\n   SETTING_PATH(\"thumbnails_directory\",          settings->paths.directory_thumbnails, true, NULL, true);\n   SETTING_PATH(\"runtime_log_directory\",         settings->paths.directory_runtime_log, true, NULL, true);\n   SETTING_PATH(\"joypad_autoconfig_dir\",         settings->paths.directory_autoconfig, false, NULL, true);\n   SETTING_PATH(\"savefile_directory\",            dir_get_ptr(RARCH_DIR_SAVEFILE), true, NULL, false);\n   SETTING_PATH(\"savestate_directory\",           dir_get_ptr(RARCH_DIR_SAVESTATE), true, NULL, false);\n   SETTING_PATH(\"screenshot_directory\",          settings->paths.directory_screenshot, true, NULL, true);\n   SETTING_PATH(\"recording_output_directory\",    recording_st->output_dir, false, NULL, true);\n   SETTING_PATH(\"recording_config_directory\",    recording_st->config_dir, false, NULL, true);\n\n   SETTING_PATH(\"content_database_path\",           settings->paths.path_content_database, false, NULL, true);\n   SETTING_PATH(\"content_favorites_path\",          settings->paths.path_content_favorites, false, NULL, true);\n   SETTING_PATH(\"content_history_path\",            settings->paths.path_content_history, false, NULL, true);\n   SETTING_PATH(\"content_image_history_path\",      settings->paths.path_content_image_history, false, NULL, true);\n   SETTING_PATH(\"content_music_history_path\",      settings->paths.path_content_music_history, false, NULL, true);\n   SETTING_PATH(\"content_video_history_path\",      settings->paths.path_content_video_history, false, NULL, true);\n   SETTING_PATH(\"content_favorites_directory\",     settings->paths.directory_content_favorites, true, NULL, true);\n   SETTING_PATH(\"content_history_directory\",       settings->paths.directory_content_history, true, NULL, true);\n   SETTING_PATH(\"content_image_history_directory\", settings->paths.directory_content_image_history, true, NULL, true);\n   SETTING_PATH(\"content_music_history_directory\", settings->paths.directory_content_music_history, true, NULL, true);\n   SETTING_PATH(\"content_video_directory\",         settings->paths.directory_content_video_history, true, NULL, true);\n\n#ifdef HAVE_MENU\n   SETTING_PATH(\"content_show_settings_password\", settings->paths.menu_content_show_settings_password, false, NULL, true);\n   SETTING_PATH(\"kiosk_mode_password\",           settings->paths.kiosk_mode_password, false, NULL, true);\n   SETTING_PATH(\"menu_wallpaper\",                settings->paths.path_menu_wallpaper, false, NULL, true);\n#ifdef HAVE_RGUI\n   SETTING_PATH(\"rgui_menu_theme_preset\",        settings->paths.path_rgui_theme_preset, false, NULL, true);\n#endif\n   /* Browser and config directories are not RGUI dependent, but name is kept to avoid config file change */\n   SETTING_PATH(\"rgui_browser_directory\",        settings->paths.directory_menu_content, true, NULL, true);\n   SETTING_PATH(\"rgui_config_directory\",         settings->paths.directory_menu_config, true, NULL, true);\n#ifdef HAVE_XMB\n   SETTING_PATH(\"xmb_font\",                      settings->paths.path_menu_xmb_font, false, NULL, true);\n#endif\n#endif /* HAVE_MENU */\n\n#ifdef HAVE_OVERLAY\n   SETTING_PATH(\"input_overlay\",                 settings->paths.path_overlay, false, NULL, true);\n   SETTING_PATH(\"input_osk_overlay\",             settings->paths.path_osk_overlay, false, NULL, true);\n   SETTING_PATH(\"overlay_directory\",             settings->paths.directory_overlay, true, NULL, true);\n   SETTING_PATH(\"osk_overlay_directory\",         settings->paths.directory_osk_overlay, true, NULL, true);\n#endif\n\n#ifdef HAVE_NETWORKING\n   SETTING_PATH(\"netplay_ip_address\",            settings->paths.netplay_server, false, NULL, true);\n   SETTING_PATH(\"netplay_custom_mitm_server\",    settings->paths.netplay_custom_mitm_server, false, NULL, true);\n   SETTING_PATH(\"netplay_nickname\",              settings->paths.username, false, NULL, true);\n   SETTING_PATH(\"netplay_password\",              settings->paths.netplay_password, false, NULL, true);\n   SETTING_PATH(\"netplay_spectate_password\",     settings->paths.netplay_spectate_password, false, NULL, true);\n#endif\n\n#ifdef _3DS\n   SETTING_PATH(\"bottom_assets_directory\",       settings->paths.directory_bottom_assets, true, NULL, true);\n#endif\n\n#ifdef HAVE_TEST_DRIVERS\n   SETTING_PATH(\"test_input_file_joypad\",        settings->paths.test_input_file_joypad,  false, NULL, true);\n   SETTING_PATH(\"test_input_file_general\",       settings->paths.test_input_file_general, false, NULL, true);\n#endif\n\n   SETTING_ARRAY(\"log_dir\",                      settings->paths.log_dir, true, NULL, true);\n   SETTING_ARRAY(\"app_icon\",                     settings->paths.app_icon, true, NULL, true);\n\n   *size = count;\n\n   return tmp;\n}\n\nstatic struct config_bool_setting *populate_settings_bool(\n      settings_t *settings, int *size)\n{\n   struct config_bool_setting  *tmp    = (struct config_bool_setting*)calloc(1, (*size + 1) * sizeof(struct config_bool_setting));\n   unsigned count                      = 0;\n\n   SETTING_BOOL(\"accessibility_enable\",          &settings->bools.accessibility_enable, true, DEFAULT_ACCESSIBILITY_ENABLE, false);\n   SETTING_BOOL(\"driver_switch_enable\",          &settings->bools.driver_switch_enable, true, DEFAULT_DRIVER_SWITCH_ENABLE, false);\n   SETTING_BOOL(\"ui_companion_start_on_boot\",    &settings->bools.ui_companion_start_on_boot, true, DEFAULT_UI_COMPANION_START_ON_BOOT, false);\n   SETTING_BOOL(\"ui_companion_enable\",           &settings->bools.ui_companion_enable, true, DEFAULT_UI_COMPANION_ENABLE, false);\n   SETTING_BOOL(\"ui_companion_toggle\",           &settings->bools.ui_companion_toggle, false, DEFAULT_UI_COMPANION_TOGGLE, false);\n   SETTING_BOOL(\"desktop_menu_enable\",           &settings->bools.desktop_menu_enable, true, DEFAULT_DESKTOP_MENU_ENABLE, false);\n   SETTING_BOOL(\"video_gpu_record\",              &settings->bools.video_gpu_record, true, DEFAULT_GPU_RECORD, false);\n   SETTING_BOOL(\"input_descriptor_label_show\",   &settings->bools.input_descriptor_label_show, true, DEFAULT_INPUT_DESCRIPTOR_LABEL_SHOW, false);\n   SETTING_BOOL(\"input_descriptor_hide_unbound\", &settings->bools.input_descriptor_hide_unbound, true, DEFAULT_INPUT_DESCRIPTOR_HIDE_UNBOUND, false);\n   SETTING_BOOL(\"load_dummy_on_core_shutdown\",   &settings->bools.load_dummy_on_core_shutdown, true, DEFAULT_LOAD_DUMMY_ON_CORE_SHUTDOWN, false);\n   SETTING_BOOL(\"check_firmware_before_loading\", &settings->bools.check_firmware_before_loading, true, DEFAULT_CHECK_FIRMWARE_BEFORE_LOADING, false);\n   SETTING_BOOL(\"core_option_category_enable\",   &settings->bools.core_option_category_enable, true, DEFAULT_CORE_OPTION_CATEGORY_ENABLE, false);\n   SETTING_BOOL(\"core_info_savestate_bypass\",    &settings->bools.core_info_savestate_bypass, true, DEFAULT_CORE_INFO_SAVESTATE_BYPASS, false);\n#if defined(__WINRT__) || defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP\n   SETTING_BOOL(\"core_info_cache_enable\",        &settings->bools.core_info_cache_enable, false, DEFAULT_CORE_INFO_CACHE_ENABLE, false);\n#else\n   SETTING_BOOL(\"core_info_cache_enable\",        &settings->bools.core_info_cache_enable, true, DEFAULT_CORE_INFO_CACHE_ENABLE, false);\n#endif\n   SETTING_BOOL(\"core_set_supports_no_game_enable\", &settings->bools.set_supports_no_game_enable, true, true, false);\n   SETTING_BOOL(\"core_updater_auto_extract_archive\", &settings->bools.network_buildbot_auto_extract_archive, true, DEFAULT_NETWORK_BUILDBOT_AUTO_EXTRACT_ARCHIVE, false);\n   SETTING_BOOL(\"core_updater_show_experimental_cores\", &settings->bools.network_buildbot_show_experimental_cores, true, DEFAULT_NETWORK_BUILDBOT_SHOW_EXPERIMENTAL_CORES, false);\n   SETTING_BOOL(\"core_updater_auto_backup\",      &settings->bools.core_updater_auto_backup, true, DEFAULT_CORE_UPDATER_AUTO_BACKUP, false);\n#ifndef HAVE_DYNAMIC\n   SETTING_BOOL(\"always_reload_core_on_run_content\", &settings->bools.always_reload_core_on_run_content, true, DEFAULT_ALWAYS_RELOAD_CORE_ON_RUN_CONTENT, false);\n#endif\n   SETTING_BOOL(\"builtin_mediaplayer_enable\",    &settings->bools.multimedia_builtin_mediaplayer_enable, true, DEFAULT_BUILTIN_MEDIAPLAYER_ENABLE, false);\n   SETTING_BOOL(\"builtin_imageviewer_enable\",    &settings->bools.multimedia_builtin_imageviewer_enable, true, DEFAULT_BUILTIN_IMAGEVIEWER_ENABLE, false);\n   SETTING_BOOL(\"bundle_assets_extract_enable\",  &settings->bools.bundle_assets_extract_enable, true, DEFAULT_BUNDLE_ASSETS_EXTRACT_ENABLE, false);\n   SETTING_BOOL(\"fps_show\",                      &settings->bools.video_fps_show, true, DEFAULT_FPS_SHOW, false);\n   SETTING_BOOL(\"statistics_show\",               &settings->bools.video_statistics_show, true, DEFAULT_STATISTICS_SHOW, false);\n   SETTING_BOOL(\"framecount_show\",               &settings->bools.video_framecount_show, true, DEFAULT_FRAMECOUNT_SHOW, false);\n   SETTING_BOOL(\"memory_show\",                   &settings->bools.video_memory_show, true, DEFAULT_MEMORY_SHOW, false);\n   SETTING_BOOL(\"ui_menubar_enable\",             &settings->bools.ui_menubar_enable, true, DEFAULT_UI_MENUBAR_ENABLE, false);\n   SETTING_BOOL(\"pause_nonactive\",               &settings->bools.pause_nonactive, true, DEFAULT_PAUSE_NONACTIVE, false);\n   SETTING_BOOL(\"pause_on_disconnect\",           &settings->bools.pause_on_disconnect, true, DEFAULT_PAUSE_ON_DISCONNECT, false);\n   SETTING_BOOL(\"auto_screenshot_filename\",      &settings->bools.auto_screenshot_filename, true, DEFAULT_AUTO_SCREENSHOT_FILENAME, false);\n   SETTING_BOOL(\"suspend_screensaver_enable\",    &settings->bools.ui_suspend_screensaver_enable, true, true, false);\n   SETTING_BOOL(\"apply_cheats_after_toggle\",     &settings->bools.apply_cheats_after_toggle, true, DEFAULT_APPLY_CHEATS_AFTER_TOGGLE, false);\n   SETTING_BOOL(\"apply_cheats_after_load\",       &settings->bools.apply_cheats_after_load, true, DEFAULT_APPLY_CHEATS_AFTER_LOAD, false);\n   SETTING_BOOL(\"rewind_enable\",                 &settings->bools.rewind_enable, true, DEFAULT_REWIND_ENABLE, false);\n   SETTING_BOOL(\"fastforward_frameskip\",         &settings->bools.fastforward_frameskip, true, DEFAULT_FASTFORWARD_FRAMESKIP, false);\n   SETTING_BOOL(\"vrr_runloop_enable\",            &settings->bools.vrr_runloop_enable, true, DEFAULT_VRR_RUNLOOP_ENABLE, false);\n   SETTING_BOOL(\"menu_throttle_framerate\",       &settings->bools.menu_throttle_framerate, true, true, false);\n   SETTING_BOOL(\"run_ahead_enabled\",             &settings->bools.run_ahead_enabled, true, false, false);\n   SETTING_BOOL(\"run_ahead_secondary_instance\",  &settings->bools.run_ahead_secondary_instance, true, DEFAULT_RUN_AHEAD_SECONDARY_INSTANCE, false);\n   SETTING_BOOL(\"run_ahead_hide_warnings\",       &settings->bools.run_ahead_hide_warnings, true, DEFAULT_RUN_AHEAD_HIDE_WARNINGS, false);\n   SETTING_BOOL(\"preemptive_frames_enable\",      &settings->bools.preemptive_frames_enable, true, false, false);\n#if HAVE_MENU\n   SETTING_BOOL(\"kiosk_mode_enable\",             &settings->bools.kiosk_mode_enable, true, DEFAULT_KIOSK_MODE_ENABLE, false);\n#endif\n   SETTING_BOOL(\"block_sram_overwrite\",          &settings->bools.block_sram_overwrite, true, DEFAULT_BLOCK_SRAM_OVERWRITE, false);\n   SETTING_BOOL(\"replay_auto_index\",             &settings->bools.replay_auto_index, true, DEFAULT_REPLAY_AUTO_INDEX, false);\n   SETTING_BOOL(\"savestate_auto_index\",          &settings->bools.savestate_auto_index, true, DEFAULT_SAVESTATE_AUTO_INDEX, false);\n   SETTING_BOOL(\"savestate_auto_save\",           &settings->bools.savestate_auto_save, true, DEFAULT_SAVESTATE_AUTO_SAVE, false);\n   SETTING_BOOL(\"savestate_auto_load\",           &settings->bools.savestate_auto_load, true, DEFAULT_SAVESTATE_AUTO_LOAD, false);\n   SETTING_BOOL(\"savestate_thumbnail_enable\",    &settings->bools.savestate_thumbnail_enable, true, DEFAULT_SAVESTATE_THUMBNAIL_ENABLE, false);\n   SETTING_BOOL(\"save_file_compression\",         &settings->bools.save_file_compression, true, DEFAULT_SAVE_FILE_COMPRESSION, false);\n   SETTING_BOOL(\"savestate_file_compression\",    &settings->bools.savestate_file_compression, true, DEFAULT_SAVESTATE_FILE_COMPRESSION, false);\n   SETTING_BOOL(\"game_specific_options\",         &settings->bools.game_specific_options, true, DEFAULT_GAME_SPECIFIC_OPTIONS, false);\n   SETTING_BOOL(\"auto_overrides_enable\",         &settings->bools.auto_overrides_enable, true, DEFAULT_AUTO_OVERRIDES_ENABLE, false);\n   SETTING_BOOL(\"auto_remaps_enable\",            &settings->bools.auto_remaps_enable, true, DEFAULT_AUTO_REMAPS_ENABLE, false);\n   SETTING_BOOL(\"initial_disk_change_enable\",    &settings->bools.initial_disk_change_enable, true, DEFAULT_INITIAL_DISK_CHANGE_ENABLE, false);\n   SETTING_BOOL(\"global_core_options\",           &settings->bools.global_core_options, true, DEFAULT_GLOBAL_CORE_OPTIONS, false);\n   SETTING_BOOL(\"auto_shaders_enable\",           &settings->bools.auto_shaders_enable, true, DEFAULT_AUTO_SHADERS_ENABLE, false);\n   SETTING_BOOL(\"scan_without_core_match\",       &settings->bools.scan_without_core_match, true, DEFAULT_SCAN_WITHOUT_CORE_MATCH, false);\n   SETTING_BOOL(\"scan_serial_and_crc\",           &settings->bools.scan_serial_and_crc, true, DEFAULT_SCAN_SERIAL_AND_CRC, false);\n   SETTING_BOOL(\"sort_savefiles_enable\",              &settings->bools.sort_savefiles_enable, true, DEFAULT_SORT_SAVEFILES_ENABLE, false);\n   SETTING_BOOL(\"sort_savestates_enable\",             &settings->bools.sort_savestates_enable, true, DEFAULT_SORT_SAVESTATES_ENABLE, false);\n   SETTING_BOOL(\"sort_savefiles_by_content_enable\",   &settings->bools.sort_savefiles_by_content_enable, true, DEFAULT_SORT_SAVEFILES_BY_CONTENT_ENABLE, false);\n   SETTING_BOOL(\"sort_savestates_by_content_enable\",  &settings->bools.sort_savestates_by_content_enable, true, DEFAULT_SORT_SAVESTATES_BY_CONTENT_ENABLE, false);\n   SETTING_BOOL(\"sort_screenshots_by_content_enable\", &settings->bools.sort_screenshots_by_content_enable, true, DEFAULT_SORT_SCREENSHOTS_BY_CONTENT_ENABLE, false);\n   SETTING_BOOL(\"savestates_in_content_dir\",     &settings->bools.savestates_in_content_dir, true, DEFAULT_SAVESTATES_IN_CONTENT_DIR, false);\n   SETTING_BOOL(\"savefiles_in_content_dir\",      &settings->bools.savefiles_in_content_dir, true, DEFAULT_SAVEFILES_IN_CONTENT_DIR, false);\n   SETTING_BOOL(\"systemfiles_in_content_dir\",    &settings->bools.systemfiles_in_content_dir, true, DEFAULT_SYSTEMFILES_IN_CONTENT_DIR, false);\n   SETTING_BOOL(\"screenshots_in_content_dir\",    &settings->bools.screenshots_in_content_dir, true, DEFAULT_SCREENSHOTS_IN_CONTENT_DIR, false);\n   SETTING_BOOL(\"quit_press_twice\",              &settings->bools.quit_press_twice, true, DEFAULT_QUIT_PRESS_TWICE, false);\n   SETTING_BOOL(\"config_save_on_exit\",           &settings->bools.config_save_on_exit, true, DEFAULT_CONFIG_SAVE_ON_EXIT, false);\n   SETTING_BOOL(\"remap_save_on_exit\",            &settings->bools.remap_save_on_exit, true, DEFAULT_REMAP_SAVE_ON_EXIT, false);\n   SETTING_BOOL(\"show_hidden_files\",             &settings->bools.show_hidden_files, true, DEFAULT_SHOW_HIDDEN_FILES, false);\n   SETTING_BOOL(\"use_last_start_directory\",      &settings->bools.use_last_start_directory, true, DEFAULT_USE_LAST_START_DIRECTORY, false);\n   SETTING_BOOL(\"camera_allow\",                  &settings->bools.camera_allow, true, false, false);\n   SETTING_BOOL(\"location_allow\",                &settings->bools.location_allow, true, false, false);\n   SETTING_BOOL(\"cloud_sync_enable\",             &settings->bools.cloud_sync_enable, true, false, false);\n   SETTING_BOOL(\"cloud_sync_destructive\",        &settings->bools.cloud_sync_destructive, true, false, false);\n   SETTING_BOOL(\"cloud_sync_sync_saves\",         &settings->bools.cloud_sync_sync_saves, true, true, false);\n   SETTING_BOOL(\"cloud_sync_sync_configs\",       &settings->bools.cloud_sync_sync_configs, true, true, false);\n   SETTING_BOOL(\"cloud_sync_sync_thumbs\",        &settings->bools.cloud_sync_sync_thumbs, true, false, false);\n   SETTING_BOOL(\"cloud_sync_sync_system\",        &settings->bools.cloud_sync_sync_system, true, false, false);\n   SETTING_BOOL(\"discord_allow\",                 &settings->bools.discord_enable, true, false, false);\n#ifdef HAVE_MIST\n   SETTING_BOOL(\"steam_rich_presence_enable\",    &settings->bools.steam_rich_presence_enable, true, false, false);\n#endif\n#ifdef HAVE_THREADS\n   SETTING_BOOL(\"threaded_data_runloop_enable\",  &settings->bools.threaded_data_runloop_enable, true, DEFAULT_THREADED_DATA_RUNLOOP_ENABLE, false);\n#endif\n   SETTING_BOOL(\"log_to_file\",                   &settings->bools.log_to_file, true, DEFAULT_LOG_TO_FILE, false);\n   SETTING_OVERRIDE(RARCH_OVERRIDE_SETTING_LOG_TO_FILE);\n   SETTING_BOOL(\"log_to_file_timestamp\",         &settings->bools.log_to_file_timestamp, true, DEFAULT_LOG_TO_FILE_TIMESTAMP, false);\n   SETTING_BOOL(\"ai_service_enable\",             &settings->bools.ai_service_enable, true, DEFAULT_AI_SERVICE_ENABLE, false);\n   SETTING_BOOL(\"ai_service_pause\",              &settings->bools.ai_service_pause, true, DEFAULT_AI_SERVICE_PAUSE, false);\n   SETTING_BOOL(\"wifi_enabled\",                  &settings->bools.wifi_enabled, true, DEFAULT_WIFI_ENABLE, false);\n#ifndef HAVE_LAKKA\n   SETTING_BOOL(\"gamemode_enable\",               &settings->bools.gamemode_enable, true, DEFAULT_GAMEMODE_ENABLE, false);\n#endif\n#ifdef HAVE_LAKKA_SWITCH\n   SETTING_BOOL(\"switch_oc\",                     &settings->bools.switch_oc, true, DEFAULT_SWITCH_OC, false);\n   SETTING_BOOL(\"switch_cec\",                    &settings->bools.switch_cec, true, DEFAULT_SWITCH_CEC, false);\n   SETTING_BOOL(\"bluetooth_ertm_disable\",        &settings->bools.bluetooth_ertm_disable, true, DEFAULT_BLUETOOTH_ERTM, false);\n#endif\n   SETTING_BOOL(\"audio_enable\",                  &settings->bools.audio_enable, true, DEFAULT_AUDIO_ENABLE, false);\n   SETTING_BOOL(\"audio_sync\",                    &settings->bools.audio_sync, true, DEFAULT_AUDIO_SYNC, false);\n   SETTING_BOOL(\"audio_rate_control\",            &settings->bools.audio_rate_control, true, DEFAULT_RATE_CONTROL, false);\n   SETTING_BOOL(\"audio_enable_menu\",             &settings->bools.audio_enable_menu, true, DEFAULT_AUDIO_ENABLE_MENU, false);\n   SETTING_BOOL(\"audio_enable_menu_ok\",          &settings->bools.audio_enable_menu_ok, true, DEFAULT_AUDIO_ENABLE_MENU_OK, false);\n   SETTING_BOOL(\"audio_enable_menu_cancel\",      &settings->bools.audio_enable_menu_cancel, true, DEFAULT_AUDIO_ENABLE_MENU_CANCEL, false);\n   SETTING_BOOL(\"audio_enable_menu_notice\",      &settings->bools.audio_enable_menu_notice, true, DEFAULT_AUDIO_ENABLE_MENU_NOTICE, false);\n   SETTING_BOOL(\"audio_enable_menu_bgm\",         &settings->bools.audio_enable_menu_bgm, true, DEFAULT_AUDIO_ENABLE_MENU_BGM, false);\n   SETTING_BOOL(\"audio_enable_menu_scroll\",      &settings->bools.audio_enable_menu_scroll, true, DEFAULT_AUDIO_ENABLE_MENU_SCROLL, false);\n   SETTING_BOOL(\"audio_mute_enable\",             audio_get_bool_ptr(AUDIO_ACTION_MUTE_ENABLE), true, false, false);\n#ifdef HAVE_AUDIOMIXER\n   SETTING_BOOL(\"audio_mixer_mute_enable\",       audio_get_bool_ptr(AUDIO_ACTION_MIXER_MUTE_ENABLE), true, false, false);\n#endif\n#if TARGET_OS_IOS\n   SETTING_BOOL(\"audio_respect_silent_mode\",     &settings->bools.audio_respect_silent_mode, true, DEFAULT_AUDIO_RESPECT_SILENT_MODE, false);\n#endif\n   SETTING_BOOL(\"audio_fastforward_mute\",        &settings->bools.audio_fastforward_mute, true, DEFAULT_AUDIO_FASTFORWARD_MUTE, false);\n   SETTING_BOOL(\"audio_fastforward_speedup\",     &settings->bools.audio_fastforward_speedup, true, DEFAULT_AUDIO_FASTFORWARD_SPEEDUP, false);\n\n#ifdef HAVE_WASAPI\n   SETTING_BOOL(\"audio_wasapi_exclusive_mode\",   &settings->bools.audio_wasapi_exclusive_mode, true, DEFAULT_WASAPI_EXCLUSIVE_MODE, false);\n   SETTING_BOOL(\"audio_wasapi_float_format\",     &settings->bools.audio_wasapi_float_format, true, DEFAULT_WASAPI_FLOAT_FORMAT, false);\n#endif\n\n#ifdef HAVE_MICROPHONE\n   SETTING_BOOL(\"microphone_enable\",             &settings->bools.microphone_enable, true, DEFAULT_MICROPHONE_ENABLE, false);\n#ifdef HAVE_WASAPI\n   SETTING_BOOL(\"microphone_wasapi_exclusive_mode\", &settings->bools.microphone_wasapi_exclusive_mode, true, DEFAULT_WASAPI_EXCLUSIVE_MODE, false);\n   SETTING_BOOL(\"microphone_wasapi_float_format\",   &settings->bools.microphone_wasapi_float_format, true, DEFAULT_WASAPI_FLOAT_FORMAT, false);\n#endif\n#endif\n\n   SETTING_BOOL(\"crt_switch_resolution_use_custom_refresh_rate\", &settings->bools.crt_switch_custom_refresh_enable, true, false, false);\n   SETTING_BOOL(\"crt_switch_hires_menu\",         &settings->bools.crt_switch_hires_menu, true, false, true);\n   SETTING_BOOL(\"video_shader_enable\",           &settings->bools.video_shader_enable, true, DEFAULT_SHADER_ENABLE, false);\n   SETTING_BOOL(\"video_shader_watch_files\",      &settings->bools.video_shader_watch_files, true, DEFAULT_VIDEO_SHADER_WATCH_FILES, false);\n   SETTING_BOOL(\"video_shader_remember_last_dir\", &settings->bools.video_shader_remember_last_dir, true, DEFAULT_VIDEO_SHADER_REMEMBER_LAST_DIR, false);\n   SETTING_BOOL(\"video_shader_preset_save_reference_enable\", &settings->bools.video_shader_preset_save_reference_enable, true, DEFAULT_VIDEO_SHADER_PRESET_SAVE_REFERENCE_ENABLE, false);\n\n   /* Let implementation decide if automatic, or 1:1 PAR. */\n   SETTING_BOOL(\"video_aspect_ratio_auto\",       &settings->bools.video_aspect_ratio_auto, true, DEFAULT_ASPECT_RATIO_AUTO, false);\n\n   SETTING_BOOL(\"video_scan_subframes\",          &settings->bools.video_scan_subframes, true, DEFAULT_SCAN_SUBFRAMES, false);\n\n   SETTING_BOOL(\"video_allow_rotate\",            &settings->bools.video_allow_rotate, true, DEFAULT_ALLOW_ROTATE, false);\n   SETTING_BOOL(\"video_windowed_fullscreen\",     &settings->bools.video_windowed_fullscreen, true, DEFAULT_WINDOWED_FULLSCREEN, false);\n   SETTING_BOOL(\"video_crop_overscan\",           &settings->bools.video_crop_overscan, true, DEFAULT_CROP_OVERSCAN, false);\n   SETTING_BOOL(\"video_scale_integer\",           &settings->bools.video_scale_integer, true, DEFAULT_SCALE_INTEGER, false);\n   SETTING_BOOL(\"video_smooth\",                  &settings->bools.video_smooth, true, DEFAULT_VIDEO_SMOOTH, false);\n   SETTING_BOOL(\"video_ctx_scaling\",             &settings->bools.video_ctx_scaling, true, DEFAULT_VIDEO_CTX_SCALING, false);\n   SETTING_BOOL(\"video_force_aspect\",            &settings->bools.video_force_aspect, true, DEFAULT_FORCE_ASPECT, false);\n   SETTING_BOOL(\"video_frame_delay_auto\",        &settings->bools.video_frame_delay_auto, true, DEFAULT_FRAME_DELAY_AUTO, false);\n#if defined(DINGUX)\n   SETTING_BOOL(\"video_dingux_ipu_keep_aspect\",  &settings->bools.video_dingux_ipu_keep_aspect, true, DEFAULT_DINGUX_IPU_KEEP_ASPECT, false);\n#endif\n   SETTING_BOOL(\"video_threaded\",                video_driver_get_threaded(), true, DEFAULT_VIDEO_THREADED, false);\n   SETTING_BOOL(\"video_shared_context\",          &settings->bools.video_shared_context, true, DEFAULT_VIDEO_SHARED_CONTEXT, false);\n#ifdef GEKKO\n   SETTING_BOOL(\"video_vfilter\",                 &settings->bools.video_vfilter, true, DEFAULT_VIDEO_VFILTER, false);\n#endif\n   SETTING_BOOL(\"video_font_enable\",             &settings->bools.video_font_enable, true, DEFAULT_FONT_ENABLE, false);\n   SETTING_BOOL(\"video_force_srgb_disable\",      &settings->bools.video_force_srgb_disable, true, false, false);\n   SETTING_BOOL(\"video_fullscreen\",              &settings->bools.video_fullscreen, true, DEFAULT_FULLSCREEN, false);\n   SETTING_BOOL(\"video_hdr_enable\",              &settings->bools.video_hdr_enable, true, DEFAULT_VIDEO_HDR_ENABLE, false);\n   SETTING_BOOL(\"video_hdr_expand_gamut\",        &settings->bools.video_hdr_expand_gamut, true, DEFAULT_VIDEO_HDR_EXPAND_GAMUT, false);\n   SETTING_BOOL(\"video_vsync\",                   &settings->bools.video_vsync, true, DEFAULT_VSYNC, false);\n   SETTING_BOOL(\"video_adaptive_vsync\",          &settings->bools.video_adaptive_vsync, true, DEFAULT_ADAPTIVE_VSYNC, false);\n   SETTING_BOOL(\"video_hard_sync\",               &settings->bools.video_hard_sync, true, DEFAULT_HARD_SYNC, false);\n   SETTING_BOOL(\"video_waitable_swapchains\",     &settings->bools.video_waitable_swapchains, true, DEFAULT_WAITABLE_SWAPCHAINS, false);\n   SETTING_BOOL(\"video_disable_composition\",     &settings->bools.video_disable_composition, true, DEFAULT_DISABLE_COMPOSITION, false);\n   SETTING_BOOL(\"video_gpu_screenshot\",          &settings->bools.video_gpu_screenshot, true, DEFAULT_GPU_SCREENSHOT, false);\n   SETTING_BOOL(\"video_post_filter_record\",      &settings->bools.video_post_filter_record, true, DEFAULT_POST_FILTER_RECORD, false);\n   SETTING_BOOL(\"video_notch_write_over_enable\", &settings->bools.video_notch_write_over_enable, true, DEFAULT_NOTCH_WRITE_OVER_ENABLE, false);\n   SETTING_BOOL(\"video_msg_bgcolor_enable\",      &settings->bools.video_msg_bgcolor_enable, true, DEFAULT_MESSAGE_BGCOLOR_ENABLE, false);\n   SETTING_BOOL(\"video_window_show_decorations\", &settings->bools.video_window_show_decorations, true, DEFAULT_WINDOW_DECORATIONS, false);\n   SETTING_BOOL(\"video_window_save_positions\",   &settings->bools.video_window_save_positions, true, DEFAULT_WINDOW_SAVE_POSITIONS, false);\n   SETTING_BOOL(\"video_window_custom_size_enable\", &settings->bools.video_window_custom_size_enable, true, DEFAULT_WINDOW_CUSTOM_SIZE_ENABLE, false);\n\n   SETTING_BOOL(\"menu_enable_widgets\",           &settings->bools.menu_enable_widgets, true, DEFAULT_MENU_ENABLE_WIDGETS, false);\n   SETTING_BOOL(\"menu_widget_scale_auto\",        &settings->bools.menu_widget_scale_auto, true, DEFAULT_MENU_WIDGET_SCALE_AUTO, false);\n   SETTING_BOOL(\"menu_show_load_content_animation\", &settings->bools.menu_show_load_content_animation, true, DEFAULT_MENU_SHOW_LOAD_CONTENT_ANIMATION, false);\n   SETTING_BOOL(\"notification_show_autoconfig\",  &settings->bools.notification_show_autoconfig, true, DEFAULT_NOTIFICATION_SHOW_AUTOCONFIG, false);\n   SETTING_BOOL(\"notification_show_cheats_applied\", &settings->bools.notification_show_cheats_applied, true, DEFAULT_NOTIFICATION_SHOW_CHEATS_APPLIED, false);\n   SETTING_BOOL(\"notification_show_patch_applied\", &settings->bools.notification_show_patch_applied, true, DEFAULT_NOTIFICATION_SHOW_PATCH_APPLIED, false);\n   SETTING_BOOL(\"notification_show_remap_load\",  &settings->bools.notification_show_remap_load, true, DEFAULT_NOTIFICATION_SHOW_REMAP_LOAD, false);\n   SETTING_BOOL(\"notification_show_config_override_load\", &settings->bools.notification_show_config_override_load, true, DEFAULT_NOTIFICATION_SHOW_CONFIG_OVERRIDE_LOAD, false);\n   SETTING_BOOL(\"notification_show_set_initial_disk\", &settings->bools.notification_show_set_initial_disk, true, DEFAULT_NOTIFICATION_SHOW_SET_INITIAL_DISK, false);\n   SETTING_BOOL(\"notification_show_disk_control\", &settings->bools.notification_show_disk_control, true, DEFAULT_NOTIFICATION_SHOW_DISK_CONTROL, false);\n   SETTING_BOOL(\"notification_show_save_state\",  &settings->bools.notification_show_save_state, true, DEFAULT_NOTIFICATION_SHOW_SAVE_STATE, false);\n   SETTING_BOOL(\"notification_show_fast_forward\", &settings->bools.notification_show_fast_forward, true, DEFAULT_NOTIFICATION_SHOW_FAST_FORWARD, false);\n#ifdef HAVE_SCREENSHOTS\n   SETTING_BOOL(\"notification_show_screenshot\",  &settings->bools.notification_show_screenshot, true, DEFAULT_NOTIFICATION_SHOW_SCREENSHOT, false);\n#endif\n   SETTING_BOOL(\"notification_show_refresh_rate\", &settings->bools.notification_show_refresh_rate, true, DEFAULT_NOTIFICATION_SHOW_REFRESH_RATE, false);\n#ifdef HAVE_NETWORKING\n   SETTING_BOOL(\"notification_show_netplay_extra\", &settings->bools.notification_show_netplay_extra, true, DEFAULT_NOTIFICATION_SHOW_NETPLAY_EXTRA, false);\n#endif\n#ifdef HAVE_MENU\n   SETTING_BOOL(\"notification_show_when_menu_is_alive\", &settings->bools.notification_show_when_menu_is_alive, true, DEFAULT_NOTIFICATION_SHOW_WHEN_MENU_IS_ALIVE, false);\n#endif\n\n#ifdef HAVE_MENU\n   SETTING_BOOL(\"menu_unified_controls\",         &settings->bools.menu_unified_controls, true, false, false);\n   SETTING_BOOL(\"menu_disable_info_button\",      &settings->bools.menu_disable_info_button, true, false, false);\n   SETTING_BOOL(\"menu_disable_search_button\",    &settings->bools.menu_disable_search_button, true, false, false);\n   SETTING_BOOL(\"menu_disable_left_analog\",      &settings->bools.menu_disable_left_analog, true, false, false);\n   SETTING_BOOL(\"menu_disable_right_analog\",     &settings->bools.menu_disable_right_analog, true, false, false);\n   SETTING_BOOL(\"menu_linear_filter\",            &settings->bools.menu_linear_filter, true, DEFAULT_VIDEO_SMOOTH, false);\n   SETTING_BOOL(\"menu_horizontal_animation\",     &settings->bools.menu_horizontal_animation, true, DEFAULT_MENU_HORIZONTAL_ANIMATION, false);\n   SETTING_BOOL(\"menu_pause_libretro\",           &settings->bools.menu_pause_libretro, true, true, false);\n   SETTING_BOOL(\"menu_savestate_resume\",         &settings->bools.menu_savestate_resume, true, DEFAULT_MENU_SAVESTATE_RESUME, false);\n   SETTING_BOOL(\"menu_insert_disk_resume\",       &settings->bools.menu_insert_disk_resume, true, DEFAULT_MENU_INSERT_DISK_RESUME, false);\n   SETTING_BOOL(\"menu_mouse_enable\",             &settings->bools.menu_mouse_enable, true, DEFAULT_MOUSE_ENABLE, false);\n   SETTING_BOOL(\"menu_pointer_enable\",           &settings->bools.menu_pointer_enable, true, DEFAULT_POINTER_ENABLE, false);\n   SETTING_BOOL(\"menu_timedate_enable\",          &settings->bools.menu_timedate_enable, true, DEFAULT_MENU_TIMEDATE_ENABLE, false);\n   SETTING_BOOL(\"menu_battery_level_enable\",     &settings->bools.menu_battery_level_enable, true, true, false);\n   SETTING_BOOL(\"menu_core_enable\",              &settings->bools.menu_core_enable, true, true, false);\n   SETTING_BOOL(\"menu_show_sublabels\",           &settings->bools.menu_show_sublabels, true, DEFAULT_MENU_SHOW_SUBLABELS, false);\n   SETTING_BOOL(\"menu_dynamic_wallpaper_enable\", &settings->bools.menu_dynamic_wallpaper_enable, true, DEFAULT_MENU_DYNAMIC_WALLPAPER_ENABLE, false);\n   SETTING_BOOL(\"menu_ticker_smooth\",            &settings->bools.menu_ticker_smooth, true, DEFAULT_MENU_TICKER_SMOOTH, false);\n   SETTING_BOOL(\"menu_scroll_fast\",              &settings->bools.menu_scroll_fast, true, DEFAULT_MENU_SCROLL_FAST, false);\n\n   SETTING_BOOL(\"settings_show_drivers\",         &settings->bools.settings_show_drivers, true, DEFAULT_SETTINGS_SHOW_DRIVERS, false);\n   SETTING_BOOL(\"settings_show_video\",           &settings->bools.settings_show_video, true, DEFAULT_SETTINGS_SHOW_VIDEO, false);\n   SETTING_BOOL(\"settings_show_audio\",           &settings->bools.settings_show_audio, true, DEFAULT_SETTINGS_SHOW_AUDIO, false);\n   SETTING_BOOL(\"settings_show_input\",           &settings->bools.settings_show_input, true, DEFAULT_SETTINGS_SHOW_INPUT, false);\n   SETTING_BOOL(\"settings_show_latency\",         &settings->bools.settings_show_latency, true, DEFAULT_SETTINGS_SHOW_LATENCY, false);\n   SETTING_BOOL(\"settings_show_core\",            &settings->bools.settings_show_core, true, DEFAULT_SETTINGS_SHOW_CORE, false);\n   SETTING_BOOL(\"settings_show_configuration\",   &settings->bools.settings_show_configuration, true, DEFAULT_SETTINGS_SHOW_CONFIGURATION, false);\n   SETTING_BOOL(\"settings_show_saving\",          &settings->bools.settings_show_saving, true, DEFAULT_SETTINGS_SHOW_SAVING, false);\n   SETTING_BOOL(\"settings_show_logging\",         &settings->bools.settings_show_logging, true, DEFAULT_SETTINGS_SHOW_LOGGING, false);\n   SETTING_BOOL(\"settings_show_file_browser\",    &settings->bools.settings_show_file_browser, true, DEFAULT_SETTINGS_SHOW_FILE_BROWSER, false);\n   SETTING_BOOL(\"settings_show_frame_throttle\",  &settings->bools.settings_show_frame_throttle, true, DEFAULT_SETTINGS_SHOW_FRAME_THROTTLE, false);\n   SETTING_BOOL(\"settings_show_recording\",       &settings->bools.settings_show_recording, true, DEFAULT_SETTINGS_SHOW_RECORDING, false);\n   SETTING_BOOL(\"settings_show_onscreen_display\",&settings->bools.settings_show_onscreen_display, true, DEFAULT_SETTINGS_SHOW_ONSCREEN_DISPLAY, false);\n   SETTING_BOOL(\"settings_show_user_interface\",  &settings->bools.settings_show_user_interface, true, DEFAULT_SETTINGS_SHOW_USER_INTERFACE, false);\n   SETTING_BOOL(\"settings_show_ai_service\",      &settings->bools.settings_show_ai_service, true, DEFAULT_SETTINGS_SHOW_AI_SERVICE, false);\n   SETTING_BOOL(\"settings_show_accessibility\",   &settings->bools.settings_show_accessibility, true, DEFAULT_SETTINGS_SHOW_ACCESSIBILITY, false);\n   SETTING_BOOL(\"settings_show_power_management\",&settings->bools.settings_show_power_management, true, DEFAULT_SETTINGS_SHOW_POWER_MANAGEMENT, false);\n   SETTING_BOOL(\"settings_show_achievements\",    &settings->bools.settings_show_achievements, true, DEFAULT_SETTINGS_SHOW_ACHIEVEMENTS, false);\n   SETTING_BOOL(\"settings_show_network\",         &settings->bools.settings_show_network, true, DEFAULT_SETTINGS_SHOW_NETWORK, false);\n   SETTING_BOOL(\"settings_show_playlists\",       &settings->bools.settings_show_playlists, true, DEFAULT_SETTINGS_SHOW_PLAYLISTS, false);\n   SETTING_BOOL(\"settings_show_user\",            &settings->bools.settings_show_user, true, DEFAULT_SETTINGS_SHOW_USER, false);\n   SETTING_BOOL(\"settings_show_directory\",       &settings->bools.settings_show_directory, true, DEFAULT_SETTINGS_SHOW_DIRECTORY, false);\n#ifdef HAVE_MIST\n   SETTING_BOOL(\"settings_show_steam\",           &settings->bools.settings_show_steam, true, DEFAULT_SETTINGS_SHOW_STEAM, false);\n#endif\n\n   SETTING_BOOL(\"quick_menu_show_resume_content\",             &settings->bools.quick_menu_show_resume_content, true, DEFAULT_QUICK_MENU_SHOW_RESUME_CONTENT, false);\n   SETTING_BOOL(\"quick_menu_show_restart_content\",            &settings->bools.quick_menu_show_restart_content, true, DEFAULT_QUICK_MENU_SHOW_RESTART_CONTENT, false);\n   SETTING_BOOL(\"quick_menu_show_close_content\",              &settings->bools.quick_menu_show_close_content, true, DEFAULT_QUICK_MENU_SHOW_CLOSE_CONTENT, false);\n   SETTING_BOOL(\"quick_menu_show_savestate_submenu\",          &settings->bools.quick_menu_show_savestate_submenu, true, DEFAULT_QUICK_MENU_SHOW_SAVESTATE_SUBMENU, false);\n   SETTING_BOOL(\"quick_menu_show_save_load_state\",            &settings->bools.quick_menu_show_save_load_state, true, DEFAULT_QUICK_MENU_SHOW_SAVE_LOAD_STATE, false);\n   SETTING_BOOL(\"quick_menu_show_replay\",                     &settings->bools.quick_menu_show_replay, true, DEFAULT_QUICK_MENU_SHOW_REPLAY, false);\n   SETTING_BOOL(\"quick_menu_show_take_screenshot\",            &settings->bools.quick_menu_show_take_screenshot, true, DEFAULT_QUICK_MENU_SHOW_TAKE_SCREENSHOT, false);\n   SETTING_BOOL(\"quick_menu_show_undo_save_load_state\",       &settings->bools.quick_menu_show_undo_save_load_state, true, DEFAULT_QUICK_MENU_SHOW_UNDO_SAVE_LOAD_STATE, false);\n   SETTING_BOOL(\"quick_menu_show_add_to_favorites\",           &settings->bools.quick_menu_show_add_to_favorites, true, DEFAULT_QUICK_MENU_SHOW_ADD_TO_FAVORITES, false);\n   SETTING_BOOL(\"quick_menu_show_add_to_playlist\",            &settings->bools.quick_menu_show_add_to_playlist, true, DEFAULT_QUICK_MENU_SHOW_ADD_TO_PLAYLIST, false);\n   SETTING_BOOL(\"quick_menu_show_start_recording\",            &settings->bools.quick_menu_show_start_recording, true, DEFAULT_QUICK_MENU_SHOW_START_RECORDING, false);\n   SETTING_BOOL(\"quick_menu_show_start_streaming\",            &settings->bools.quick_menu_show_start_streaming, true, DEFAULT_QUICK_MENU_SHOW_START_STREAMING, false);\n   SETTING_BOOL(\"quick_menu_show_set_core_association\",       &settings->bools.quick_menu_show_set_core_association, true, DEFAULT_QUICK_MENU_SHOW_SET_CORE_ASSOCIATION, false);\n   SETTING_BOOL(\"quick_menu_show_reset_core_association\",     &settings->bools.quick_menu_show_reset_core_association, true, DEFAULT_QUICK_MENU_SHOW_RESET_CORE_ASSOCIATION, false);\n   SETTING_BOOL(\"quick_menu_show_options\",                    &settings->bools.quick_menu_show_options, true, DEFAULT_QUICK_MENU_SHOW_CORE_OPTIONS, false);\n   SETTING_BOOL(\"quick_menu_show_core_options_flush\",         &settings->bools.quick_menu_show_core_options_flush, true, DEFAULT_QUICK_MENU_SHOW_CORE_OPTIONS_FLUSH, false);\n   SETTING_BOOL(\"quick_menu_show_controls\",                   &settings->bools.quick_menu_show_controls, true, DEFAULT_QUICK_MENU_SHOW_CONTROLS, false);\n   SETTING_BOOL(\"quick_menu_show_cheats\",                     &settings->bools.quick_menu_show_cheats, true, DEFAULT_QUICK_MENU_SHOW_CHEATS, false);\n   SETTING_BOOL(\"quick_menu_show_shaders\",                    &settings->bools.quick_menu_show_shaders, true, DEFAULT_QUICK_MENU_SHOW_SHADERS, false);\n   SETTING_BOOL(\"quick_menu_show_save_core_overrides\",        &settings->bools.quick_menu_show_save_core_overrides, true, DEFAULT_QUICK_MENU_SHOW_SAVE_CORE_OVERRIDES, false);\n   SETTING_BOOL(\"quick_menu_show_save_content_dir_overrides\", &settings->bools.quick_menu_show_save_content_dir_overrides, true, DEFAULT_QUICK_MENU_SHOW_SAVE_CONTENT_DIR_OVERRIDES, false);\n   SETTING_BOOL(\"quick_menu_show_save_game_overrides\",        &settings->bools.quick_menu_show_save_game_overrides, true, DEFAULT_QUICK_MENU_SHOW_SAVE_GAME_OVERRIDES, false);\n   SETTING_BOOL(\"quick_menu_show_information\",                &settings->bools.quick_menu_show_information, true, DEFAULT_QUICK_MENU_SHOW_INFORMATION, false);\n#ifdef HAVE_NETWORKING\n   SETTING_BOOL(\"quick_menu_show_download_thumbnails\",        &settings->bools.quick_menu_show_download_thumbnails, true, DEFAULT_QUICK_MENU_SHOW_DOWNLOAD_THUMBNAILS, false);\n#endif\n\n   SETTING_BOOL(\"content_show_settings\",         &settings->bools.menu_content_show_settings, true, DEFAULT_CONTENT_SHOW_SETTINGS, false);\n   SETTING_BOOL(\"content_show_favorites\",        &settings->bools.menu_content_show_favorites, true, DEFAULT_CONTENT_SHOW_FAVORITES, false);\n#ifdef HAVE_IMAGEVIEWER\n   SETTING_BOOL(\"content_show_images\",           &settings->bools.menu_content_show_images, true, DEFAULT_CONTENT_SHOW_IMAGES, false);\n#endif\n   SETTING_BOOL(\"content_show_music\",            &settings->bools.menu_content_show_music, true, DEFAULT_CONTENT_SHOW_MUSIC, false);\n#if defined(HAVE_FFMPEG) || defined(HAVE_MPV)\n   SETTING_BOOL(\"content_show_video\",            &settings->bools.menu_content_show_video, true, DEFAULT_CONTENT_SHOW_VIDEO, false);\n#endif\n#ifdef HAVE_NETWORKING\n   SETTING_BOOL(\"content_show_netplay\",          &settings->bools.menu_content_show_netplay, true, DEFAULT_CONTENT_SHOW_NETPLAY, false);\n#endif\n   SETTING_BOOL(\"content_show_history\",          &settings->bools.menu_content_show_history, true, DEFAULT_CONTENT_SHOW_HISTORY, false);\n   SETTING_BOOL(\"content_show_add\",              &settings->bools.menu_content_show_add, true, DEFAULT_MENU_CONTENT_SHOW_ADD, false);\n   SETTING_BOOL(\"content_show_playlists\",        &settings->bools.menu_content_show_playlists, true, DEFAULT_CONTENT_SHOW_PLAYLISTS, false);\n#if defined(HAVE_LIBRETRODB)\n   SETTING_BOOL(\"content_show_explore\",          &settings->bools.menu_content_show_explore, true, DEFAULT_MENU_CONTENT_SHOW_EXPLORE, false);\n#endif\n   SETTING_BOOL(\"menu_show_load_core\",           &settings->bools.menu_show_load_core, true, DEFAULT_MENU_SHOW_LOAD_CORE, false);\n   SETTING_BOOL(\"menu_show_load_content\",        &settings->bools.menu_show_load_content, true, DEFAULT_MENU_SHOW_LOAD_CONTENT, false);\n#ifdef HAVE_CDROM\n   SETTING_BOOL(\"menu_show_load_disc\",           &settings->bools.menu_show_load_disc, true, DEFAULT_MENU_SHOW_LOAD_DISC, false);\n   SETTING_BOOL(\"menu_show_dump_disc\",           &settings->bools.menu_show_dump_disc, true, DEFAULT_MENU_SHOW_DUMP_DISC, false);\n#ifdef HAVE_LAKKA\n   SETTING_BOOL(\"menu_show_eject_disc\",          &settings->bools.menu_show_eject_disc, true, DEFAULT_MENU_SHOW_EJECT_DISC, false);\n#endif\n#endif /* HAVE_CDROM */\n   SETTING_BOOL(\"menu_show_information\",         &settings->bools.menu_show_information, true, DEFAULT_MENU_SHOW_INFORMATION, false);\n   SETTING_BOOL(\"menu_show_configurations\",      &settings->bools.menu_show_configurations, true, DEFAULT_MENU_SHOW_CONFIGURATIONS, false);\n\n   /* Actually Quick Menu items, but too late to change without breaking old confs */\n   SETTING_BOOL(\"menu_show_latency\",             &settings->bools.menu_show_latency, true, DEFAULT_QUICK_MENU_SHOW_LATENCY, false);\n   SETTING_BOOL(\"menu_show_rewind\",              &settings->bools.menu_show_rewind, true, DEFAULT_QUICK_MENU_SHOW_REWIND, false);\n   SETTING_BOOL(\"menu_show_overlays\",            &settings->bools.menu_show_overlays, true, DEFAULT_QUICK_MENU_SHOW_OVERLAYS, false);\n\n   SETTING_BOOL(\"menu_show_help\",                &settings->bools.menu_show_help, true, DEFAULT_MENU_SHOW_HELP, false);\n   SETTING_BOOL(\"menu_show_quit_retroarch\",      &settings->bools.menu_show_quit_retroarch, true, DEFAULT_MENU_SHOW_QUIT, false);\n   SETTING_BOOL(\"menu_show_restart_retroarch\",   &settings->bools.menu_show_restart_retroarch, true, DEFAULT_MENU_SHOW_RESTART, false);\n   SETTING_BOOL(\"menu_show_reboot\",              &settings->bools.menu_show_reboot, true, DEFAULT_MENU_SHOW_REBOOT, false);\n   SETTING_BOOL(\"menu_show_shutdown\",            &settings->bools.menu_show_shutdown, true, DEFAULT_MENU_SHOW_SHUTDOWN, false);\n   SETTING_BOOL(\"menu_show_online_updater\",      &settings->bools.menu_show_online_updater, true, DEFAULT_MENU_SHOW_ONLINE_UPDATER, false);\n   SETTING_BOOL(\"menu_show_core_updater\",        &settings->bools.menu_show_core_updater, true, DEFAULT_MENU_SHOW_CORE_UPDATER, false);\n#if 0\n/* Thumbnailpack removal */\n   SETTING_BOOL(\"menu_show_legacy_thumbnail_updater\", &settings->bools.menu_show_legacy_thumbnail_updater, true, DEFAULT_MENU_SHOW_LEGACY_THUMBNAIL_UPDATER, false);\n#endif\n#ifdef HAVE_MIST\n   SETTING_BOOL(\"menu_show_core_manager_steam\",  &settings->bools.menu_show_core_manager_steam, true, DEFAULT_MENU_SHOW_CORE_MANAGER_STEAM, false);\n#endif\n   SETTING_BOOL(\"filter_by_current_core\",        &settings->bools.filter_by_current_core, true, DEFAULT_FILTER_BY_CURRENT_CORE, false);\n   SETTING_BOOL(\"menu_use_preferred_system_color_theme\", &settings->bools.menu_use_preferred_system_color_theme, true, DEFAULT_MENU_USE_PREFERRED_SYSTEM_COLOR_THEME, false);\n   SETTING_BOOL(\"menu_navigation_wraparound_enable\", &settings->bools.menu_navigation_wraparound_enable, true, true, false);\n   SETTING_BOOL(\"menu_navigation_browser_filter_supported_extensions_enable\", &settings->bools.menu_navigation_browser_filter_supported_extensions_enable, true, true, false);\n   SETTING_BOOL(\"menu_show_advanced_settings\",   &settings->bools.menu_show_advanced_settings, true, DEFAULT_SHOW_ADVANCED_SETTINGS, false);\n#ifdef HAVE_MATERIALUI\n   SETTING_BOOL(\"materialui_icons_enable\",                    &settings->bools.menu_materialui_icons_enable, true, DEFAULT_MATERIALUI_ICONS_ENABLE, false);\n   SETTING_BOOL(\"materialui_switch_icons\",                    &settings->bools.menu_materialui_switch_icons, true, DEFAULT_MATERIALUI_SWITCH_ICONS, false);\n   SETTING_BOOL(\"materialui_playlist_icons_enable\",           &settings->bools.menu_materialui_playlist_icons_enable, true, DEFAULT_MATERIALUI_PLAYLIST_ICONS_ENABLE, false);\n   SETTING_BOOL(\"materialui_show_nav_bar\",                    &settings->bools.menu_materialui_show_nav_bar, true, DEFAULT_MATERIALUI_SHOW_NAV_BAR, false);\n   SETTING_BOOL(\"materialui_auto_rotate_nav_bar\",             &settings->bools.menu_materialui_auto_rotate_nav_bar, true, DEFAULT_MATERIALUI_AUTO_ROTATE_NAV_BAR, false);\n   SETTING_BOOL(\"materialui_dual_thumbnail_list_view_enable\", &settings->bools.menu_materialui_dual_thumbnail_list_view_enable, true, DEFAULT_MATERIALUI_DUAL_THUMBNAIL_LIST_VIEW_ENABLE, false);\n   SETTING_BOOL(\"materialui_thumbnail_background_enable\",     &settings->bools.menu_materialui_thumbnail_background_enable, true, DEFAULT_MATERIALUI_THUMBNAIL_BACKGROUND_ENABLE, false);\n#endif\n#ifdef HAVE_RGUI\n   SETTING_BOOL(\"rgui_show_start_screen\",                  &settings->bools.menu_show_start_screen, false, false /* TODO */, false);\n   SETTING_BOOL(\"rgui_background_filler_thickness_enable\", &settings->bools.menu_rgui_background_filler_thickness_enable, true, true, false);\n   SETTING_BOOL(\"rgui_border_filler_thickness_enable\",     &settings->bools.menu_rgui_border_filler_thickness_enable, true, true, false);\n   SETTING_BOOL(\"rgui_border_filler_enable\",               &settings->bools.menu_rgui_border_filler_enable, true, true, false);\n   SETTING_BOOL(\"menu_rgui_transparency\",                  &settings->bools.menu_rgui_transparency, true, DEFAULT_RGUI_TRANSPARENCY, false);\n   SETTING_BOOL(\"menu_rgui_shadows\",                       &settings->bools.menu_rgui_shadows, true, DEFAULT_RGUI_SHADOWS, false);\n   SETTING_BOOL(\"menu_rgui_full_width_layout\",             &settings->bools.menu_rgui_full_width_layout, true, DEFAULT_RGUI_FULL_WIDTH_LAYOUT, false);\n   SETTING_BOOL(\"rgui_inline_thumbnails\",                  &settings->bools.menu_rgui_inline_thumbnails, true, DEFAULT_RGUI_INLINE_THUMBNAILS, false);\n   SETTING_BOOL(\"rgui_swap_thumbnails\",                    &settings->bools.menu_rgui_swap_thumbnails, true, DEFAULT_RGUI_SWAP_THUMBNAILS, false);\n   SETTING_BOOL(\"rgui_extended_ascii\",                     &settings->bools.menu_rgui_extended_ascii, true, DEFAULT_RGUI_EXTENDED_ASCII, false);\n   SETTING_BOOL(\"rgui_switch_icons\",                       &settings->bools.menu_rgui_switch_icons, true, DEFAULT_RGUI_SWITCH_ICONS, false);\n   SETTING_BOOL(\"rgui_particle_effect_screensaver\",        &settings->bools.menu_rgui_particle_effect_screensaver, true, DEFAULT_RGUI_PARTICLE_EFFECT_SCREENSAVER, false);\n#endif\n#ifdef HAVE_XMB\n   SETTING_BOOL(\"xmb_shadows_enable\",            &settings->bools.menu_xmb_shadows_enable, true, DEFAULT_XMB_SHADOWS_ENABLE, false);\n   SETTING_BOOL(\"xmb_switch_icons\",              &settings->bools.menu_xmb_switch_icons, true, DEFAULT_XMB_SWITCH_ICONS, false);\n   SETTING_BOOL(\"xmb_vertical_thumbnails\",       &settings->bools.menu_xmb_vertical_thumbnails, true, DEFAULT_XMB_VERTICAL_THUMBNAILS, false);\n   SETTING_BOOL(\"menu_xmb_show_title_header\",    &settings->bools.menu_xmb_show_title_header, true, DEFAULT_XMB_SHOW_TITLE_HEADER, false);\n#endif\n#ifdef HAVE_OZONE\n   SETTING_BOOL(\"ozone_collapse_sidebar\",        &settings->bools.ozone_collapse_sidebar, true, DEFAULT_OZONE_COLLAPSE_SIDEBAR, false);\n   SETTING_BOOL(\"ozone_scroll_content_metadata\", &settings->bools.ozone_scroll_content_metadata, true, DEFAULT_OZONE_SCROLL_CONTENT_METADATA, false);\n#endif\n#if defined(HAVE_OZONE) || defined(HAVE_XMB)\n   SETTING_BOOL(\"ozone_truncate_playlist_name\",            &settings->bools.ozone_truncate_playlist_name, true, DEFAULT_OZONE_TRUNCATE_PLAYLIST_NAME, false);\n   SETTING_BOOL(\"ozone_sort_after_truncate_playlist_name\", &settings->bools.ozone_sort_after_truncate_playlist_name, true, DEFAULT_OZONE_SORT_AFTER_TRUNCATE_PLAYLIST_NAME, false);\n#endif\n#endif /* HAVE_MENU */\n\n#ifdef HAVE_CHEEVOS\n   SETTING_BOOL(\"cheevos_enable\",                &settings->bools.cheevos_enable, true, DEFAULT_CHEEVOS_ENABLE, false);\n   SETTING_BOOL(\"cheevos_test_unofficial\",       &settings->bools.cheevos_test_unofficial, true, false, false);\n   SETTING_BOOL(\"cheevos_hardcore_mode_enable\",  &settings->bools.cheevos_hardcore_mode_enable, true, true, false);\n   SETTING_BOOL(\"cheevos_challenge_indicators\",  &settings->bools.cheevos_challenge_indicators, true, true, false);\n   SETTING_BOOL(\"cheevos_richpresence_enable\",   &settings->bools.cheevos_richpresence_enable, true, true, false);\n   SETTING_BOOL(\"cheevos_unlock_sound_enable\",   &settings->bools.cheevos_unlock_sound_enable, true, false, false);\n   SETTING_BOOL(\"cheevos_verbose_enable\",        &settings->bools.cheevos_verbose_enable, true, true, false);\n   SETTING_BOOL(\"cheevos_auto_screenshot\",       &settings->bools.cheevos_auto_screenshot, true, false, false);\n   SETTING_BOOL(\"cheevos_badges_enable\",         &settings->bools.cheevos_badges_enable, true, false, false);\n   SETTING_BOOL(\"cheevos_start_active\",          &settings->bools.cheevos_start_active, true, false, false);\n   SETTING_BOOL(\"cheevos_appearance_padding_auto\", &settings->bools.cheevos_appearance_padding_auto, true, DEFAULT_CHEEVOS_APPEARANCE_PADDING_AUTO, false);\n   SETTING_BOOL(\"cheevos_visibility_unlock\",     &settings->bools.cheevos_visibility_unlock, true, DEFAULT_CHEEVOS_VISIBILITY_UNLOCK, false);\n   SETTING_BOOL(\"cheevos_visibility_mastery\",    &settings->bools.cheevos_visibility_mastery, true, DEFAULT_CHEEVOS_VISIBILITY_MASTERY, false);\n   SETTING_BOOL(\"cheevos_visibility_account\",    &settings->bools.cheevos_visibility_account, true, DEFAULT_CHEEVOS_VISIBILITY_ACCOUNT, false);\n   SETTING_BOOL(\"cheevos_visibility_lboard_start\", &settings->bools.cheevos_visibility_lboard_start, true, DEFAULT_CHEEVOS_VISIBILITY_LBOARD_START, false);\n   SETTING_BOOL(\"cheevos_visibility_lboard_submit\", &settings->bools.cheevos_visibility_lboard_submit, true, DEFAULT_CHEEVOS_VISIBILITY_LBOARD_SUBMIT, false);\n   SETTING_BOOL(\"cheevos_visibility_lboard_cancel\", &settings->bools.cheevos_visibility_lboard_cancel, true, DEFAULT_CHEEVOS_VISIBILITY_LBOARD_CANCEL, false);\n   SETTING_BOOL(\"cheevos_visibility_lboard_trackers\", &settings->bools.cheevos_visibility_lboard_trackers, true, DEFAULT_CHEEVOS_VISIBILITY_LBOARD_TRACKERS, false);\n   SETTING_BOOL(\"cheevos_visibility_progress_tracker\", &settings->bools.cheevos_visibility_progress_tracker, true, DEFAULT_CHEEVOS_VISIBILITY_PROGRESS_TRACKER, false);\n#endif\n#ifdef HAVE_OVERLAY\n   SETTING_BOOL(\"input_overlay_enable\",          &settings->bools.input_overlay_enable, true, config_overlay_enable_default(), false);\n   SETTING_BOOL(\"input_overlay_enable_autopreferred\", &settings->bools.input_overlay_enable_autopreferred, true, DEFAULT_OVERLAY_ENABLE_AUTOPREFERRED, false);\n   SETTING_BOOL(\"input_overlay_behind_menu\",     &settings->bools.input_overlay_behind_menu, true, DEFAULT_OVERLAY_BEHIND_MENU, false);\n   SETTING_BOOL(\"input_overlay_hide_in_menu\",    &settings->bools.input_overlay_hide_in_menu, true, DEFAULT_OVERLAY_HIDE_IN_MENU, false);\n   SETTING_BOOL(\"input_overlay_hide_when_gamepad_connected\", &settings->bools.input_overlay_hide_when_gamepad_connected, true, DEFAULT_OVERLAY_HIDE_WHEN_GAMEPAD_CONNECTED, false);\n   SETTING_BOOL(\"input_overlay_show_mouse_cursor\", &settings->bools.input_overlay_show_mouse_cursor, true, DEFAULT_OVERLAY_SHOW_MOUSE_CURSOR, false);\n   SETTING_BOOL(\"input_overlay_auto_rotate\",     &settings->bools.input_overlay_auto_rotate, true, DEFAULT_OVERLAY_AUTO_ROTATE, false);\n   SETTING_BOOL(\"input_overlay_auto_scale\",      &settings->bools.input_overlay_auto_scale, true, DEFAULT_INPUT_OVERLAY_AUTO_SCALE, false);\n   SETTING_BOOL(\"input_osk_overlay_auto_scale\",  &settings->bools.input_osk_overlay_auto_scale, true, DEFAULT_INPUT_OVERLAY_AUTO_SCALE, false);\n   SETTING_BOOL(\"input_overlay_pointer_enable\",  &settings->bools.input_overlay_pointer_enable, true, DEFAULT_INPUT_OVERLAY_POINTER_ENABLE, false);\n   SETTING_BOOL(\"input_overlay_lightgun_trigger_on_touch\", &settings->bools.input_overlay_lightgun_trigger_on_touch, true, DEFAULT_INPUT_OVERLAY_LIGHTGUN_TRIGGER_ON_TOUCH, false);\n   SETTING_BOOL(\"input_overlay_lightgun_allow_offscreen\",  &settings->bools.input_overlay_lightgun_allow_offscreen, true, DEFAULT_INPUT_OVERLAY_LIGHTGUN_ALLOW_OFFSCREEN, false);\n   SETTING_BOOL(\"input_overlay_mouse_hold_to_drag\", &settings->bools.input_overlay_mouse_hold_to_drag, true, DEFAULT_INPUT_OVERLAY_MOUSE_HOLD_TO_DRAG, false);\n   SETTING_BOOL(\"input_overlay_mouse_dtap_to_drag\", &settings->bools.input_overlay_mouse_dtap_to_drag, true, DEFAULT_INPUT_OVERLAY_MOUSE_DTAP_TO_DRAG, false);\n#endif\n#ifdef UDEV_TOUCH_SUPPORT\n   SETTING_BOOL(\"input_touch_vmouse_pointer\",    &settings->bools.input_touch_vmouse_pointer, true, DEFAULT_INPUT_TOUCH_VMOUSE_POINTER, false);\n   SETTING_BOOL(\"input_touch_vmouse_mouse\",      &settings->bools.input_touch_vmouse_mouse, true, DEFAULT_INPUT_TOUCH_VMOUSE_MOUSE, false);\n   SETTING_BOOL(\"input_touch_vmouse_touchpad\",   &settings->bools.input_touch_vmouse_touchpad, true, DEFAULT_INPUT_TOUCH_VMOUSE_TOUCHPAD, false);\n   SETTING_BOOL(\"input_touch_vmouse_trackball\",  &settings->bools.input_touch_vmouse_trackball, true, DEFAULT_INPUT_TOUCH_VMOUSE_TRACKBALL, false);\n   SETTING_BOOL(\"input_touch_vmouse_gesture\",    &settings->bools.input_touch_vmouse_gesture, true, DEFAULT_INPUT_TOUCH_VMOUSE_GESTURE, false);\n#endif\n#if defined(VITA)\n   SETTING_BOOL(\"input_backtouch_enable\",        &settings->bools.input_backtouch_enable, false, DEFAULT_INPUT_BACKTOUCH_ENABLE, false);\n   SETTING_BOOL(\"input_backtouch_toggle\",        &settings->bools.input_backtouch_toggle, false, DEFAULT_INPUT_BACKTOUCH_TOGGLE, false);\n#endif\n#if TARGET_OS_IPHONE\n   SETTING_BOOL(\"small_keyboard_enable\",         &settings->bools.input_small_keyboard_enable, true, false, false);\n#endif\n   SETTING_BOOL(\"keyboard_gamepad_enable\",       &settings->bools.input_keyboard_gamepad_enable, true, DEFAULT_INPUT_KEYBOARD_GAMEPAD_ENABLE, false);\n   SETTING_BOOL(\"input_autodetect_enable\",       &settings->bools.input_autodetect_enable, true, DEFAULT_INPUT_AUTODETECT_ENABLE, false);\n   SETTING_BOOL(\"input_allow_turbo_dpad\",        &settings->bools.input_allow_turbo_dpad, true, DEFAULT_ALLOW_TURBO_DPAD, false);\n   SETTING_BOOL(\"input_auto_mouse_grab\",         &settings->bools.input_auto_mouse_grab, true, DEFAULT_INPUT_AUTO_MOUSE_GRAB, false);\n   SETTING_BOOL(\"input_remap_binds_enable\",      &settings->bools.input_remap_binds_enable, true, true, false);\n   SETTING_BOOL(\"input_remap_sort_by_controller_enable\",      &settings->bools.input_remap_sort_by_controller_enable, true, false, false);\n   SETTING_BOOL(\"input_hotkey_device_merge\",     &settings->bools.input_hotkey_device_merge, true, DEFAULT_INPUT_HOTKEY_DEVICE_MERGE, false);\n   SETTING_BOOL(\"all_users_control_menu\",        &settings->bools.input_all_users_control_menu, true, DEFAULT_ALL_USERS_CONTROL_MENU, false);\n#ifdef HAVE_MENU\n   SETTING_BOOL(\"menu_swap_ok_cancel_buttons\",   &settings->bools.input_menu_swap_ok_cancel_buttons, true, DEFAULT_MENU_SWAP_OK_CANCEL_BUTTONS, false);\n   SETTING_BOOL(\"menu_swap_scroll_buttons\",      &settings->bools.input_menu_swap_scroll_buttons, true, DEFAULT_MENU_SWAP_SCROLL_BUTTONS, false);\n#endif\n#if defined(HAVE_DINPUT) || defined(HAVE_WINRAWINPUT)\n   SETTING_BOOL(\"input_nowinkey_enable\",         &settings->bools.input_nowinkey_enable, true, false, false);\n#endif\n   SETTING_BOOL(\"input_sensors_enable\",          &settings->bools.input_sensors_enable, true, DEFAULT_INPUT_SENSORS_ENABLE, false);\n   SETTING_BOOL(\"vibrate_on_keypress\",           &settings->bools.vibrate_on_keypress, true, DEFAULT_VIBRATE_ON_KEYPRESS, false);\n   SETTING_BOOL(\"enable_device_vibration\",       &settings->bools.enable_device_vibration, true, DEFAULT_ENABLE_DEVICE_VIBRATION, false);\n   SETTING_BOOL(\"sustained_performance_mode\",    &settings->bools.sustained_performance_mode, true, DEFAULT_SUSTAINED_PERFORMANCE_MODE, false);\n\n   SETTING_BOOL(\"content_runtime_log\",           &settings->bools.content_runtime_log, true, DEFAULT_CONTENT_RUNTIME_LOG, false);\n   SETTING_BOOL(\"content_runtime_log_aggregate\", &settings->bools.content_runtime_log_aggregate, true, DEFAULT_CONTENT_RUNTIME_LOG_AGGREGATE, false);\n   SETTING_BOOL(\"history_list_enable\",           &settings->bools.history_list_enable, true, DEFAULT_HISTORY_LIST_ENABLE, false);\n   SETTING_BOOL(\"playlist_entry_rename\",         &settings->bools.playlist_entry_rename, true, DEFAULT_PLAYLIST_ENTRY_RENAME, false);\n   SETTING_BOOL(\"playlist_use_old_format\",       &settings->bools.playlist_use_old_format, true, DEFAULT_PLAYLIST_USE_OLD_FORMAT, false);\n   SETTING_BOOL(\"playlist_compression\",          &settings->bools.playlist_compression, true, DEFAULT_PLAYLIST_COMPRESSION, false);\n   SETTING_BOOL(\"playlist_show_sublabels\",       &settings->bools.playlist_show_sublabels, true, DEFAULT_PLAYLIST_SHOW_SUBLABELS, false);\n   SETTING_BOOL(\"playlist_show_entry_idx\",       &settings->bools.playlist_show_entry_idx, true, DEFAULT_PLAYLIST_SHOW_ENTRY_IDX, false);\n   SETTING_BOOL(\"playlist_sort_alphabetical\",    &settings->bools.playlist_sort_alphabetical, true, DEFAULT_PLAYLIST_SORT_ALPHABETICAL, false);\n   SETTING_BOOL(\"playlist_fuzzy_archive_match\",  &settings->bools.playlist_fuzzy_archive_match, true, DEFAULT_PLAYLIST_FUZZY_ARCHIVE_MATCH, false);\n   SETTING_BOOL(\"playlist_portable_paths\",       &settings->bools.playlist_portable_paths, true, DEFAULT_PLAYLIST_PORTABLE_PATHS, false);\n   SETTING_BOOL(\"playlist_use_filename\",         &settings->bools.playlist_use_filename, true, DEFAULT_PLAYLIST_USE_FILENAME, false);\n   SETTING_BOOL(\"playlist_allow_non_png\",        &settings->bools.playlist_allow_non_png, true, DEFAULT_PLAYLIST_ALLOW_NON_PNG, false);\n\n   SETTING_BOOL(\"frame_time_counter_reset_after_fastforwarding\", &settings->bools.frame_time_counter_reset_after_fastforwarding, true, false, false);\n   SETTING_BOOL(\"frame_time_counter_reset_after_load_state\",     &settings->bools.frame_time_counter_reset_after_load_state, true, false, false);\n   SETTING_BOOL(\"frame_time_counter_reset_after_save_state\",     &settings->bools.frame_time_counter_reset_after_save_state, true, false, false);\n\n#ifdef HAVE_COMMAND\n   SETTING_BOOL(\"network_cmd_enable\",            &settings->bools.network_cmd_enable, true, DEFAULT_NETWORK_CMD_ENABLE, false);\n   SETTING_BOOL(\"stdin_cmd_enable\",              &settings->bools.stdin_cmd_enable, true, DEFAULT_STDIN_CMD_ENABLE, false);\n#endif\n\n#ifdef HAVE_NETWORKING\n   SETTING_BOOL(\"netplay_show_only_connectable\", &settings->bools.netplay_show_only_connectable, true, DEFAULT_NETPLAY_SHOW_ONLY_CONNECTABLE, false);\n   SETTING_BOOL(\"netplay_show_only_installed_cores\", &settings->bools.netplay_show_only_installed_cores, true, DEFAULT_NETPLAY_SHOW_ONLY_INSTALLED_CORES, false);\n   SETTING_BOOL(\"netplay_show_passworded\",       &settings->bools.netplay_show_passworded, true, DEFAULT_NETPLAY_SHOW_PASSWORDED, false);\n   SETTING_BOOL(\"netplay_public_announce\",       &settings->bools.netplay_public_announce, true, DEFAULT_NETPLAY_PUBLIC_ANNOUNCE, false);\n   SETTING_BOOL(\"netplay_start_as_spectator\",    &settings->bools.netplay_start_as_spectator, false, DEFAULT_NETPLAY_START_AS_SPECTATOR, false);\n   SETTING_BOOL(\"netplay_nat_traversal\",         &settings->bools.netplay_nat_traversal, true, true, false);\n   SETTING_BOOL(\"netplay_fade_chat\",             &settings->bools.netplay_fade_chat, true, DEFAULT_NETPLAY_FADE_CHAT, false);\n   SETTING_BOOL(\"netplay_allow_pausing\",         &settings->bools.netplay_allow_pausing, true, DEFAULT_NETPLAY_ALLOW_PAUSING, false);\n   SETTING_BOOL(\"netplay_allow_slaves\",          &settings->bools.netplay_allow_slaves, true, DEFAULT_NETPLAY_ALLOW_SLAVES, false);\n   SETTING_BOOL(\"netplay_require_slaves\",        &settings->bools.netplay_require_slaves, true, DEFAULT_NETPLAY_REQUIRE_SLAVES, false);\n   SETTING_BOOL(\"netplay_use_mitm_server\",       &settings->bools.netplay_use_mitm_server, true, DEFAULT_NETPLAY_USE_MITM_SERVER, false);\n   SETTING_BOOL(\"netplay_request_device_p1\",     &settings->bools.netplay_request_devices[0], true, false, false);\n   SETTING_BOOL(\"netplay_request_device_p2\",     &settings->bools.netplay_request_devices[1], true, false, false);\n   SETTING_BOOL(\"netplay_request_device_p3\",     &settings->bools.netplay_request_devices[2], true, false, false);\n   SETTING_BOOL(\"netplay_request_device_p4\",     &settings->bools.netplay_request_devices[3], true, false, false);\n   SETTING_BOOL(\"netplay_request_device_p5\",     &settings->bools.netplay_request_devices[4], true, false, false);\n   SETTING_BOOL(\"netplay_request_device_p6\",     &settings->bools.netplay_request_devices[5], true, false, false);\n   SETTING_BOOL(\"netplay_request_device_p7\",     &settings->bools.netplay_request_devices[6], true, false, false);\n   SETTING_BOOL(\"netplay_request_device_p8\",     &settings->bools.netplay_request_devices[7], true, false, false);\n   SETTING_BOOL(\"netplay_request_device_p9\",     &settings->bools.netplay_request_devices[8], true, false, false);\n   SETTING_BOOL(\"netplay_request_device_p10\",    &settings->bools.netplay_request_devices[9], true, false, false);\n   SETTING_BOOL(\"netplay_request_device_p11\",    &settings->bools.netplay_request_devices[10], true, false, false);\n   SETTING_BOOL(\"netplay_request_device_p12\",    &settings->bools.netplay_request_devices[11], true, false, false);\n   SETTING_BOOL(\"netplay_request_device_p13\",    &settings->bools.netplay_request_devices[12], true, false, false);\n   SETTING_BOOL(\"netplay_request_device_p14\",    &settings->bools.netplay_request_devices[13], true, false, false);\n   SETTING_BOOL(\"netplay_request_device_p15\",    &settings->bools.netplay_request_devices[14], true, false, false);\n   SETTING_BOOL(\"netplay_request_device_p16\",    &settings->bools.netplay_request_devices[15], true, false, false);\n   SETTING_BOOL(\"netplay_ping_show\",             &settings->bools.netplay_ping_show, true, DEFAULT_NETPLAY_PING_SHOW, false);\n   SETTING_BOOL(\"network_on_demand_thumbnails\",  &settings->bools.network_on_demand_thumbnails, true, DEFAULT_NETWORK_ON_DEMAND_THUMBNAILS, false);\n#ifdef HAVE_NETWORKGAMEPAD\n   SETTING_BOOL(\"network_remote_enable\",         &settings->bools.network_remote_enable, false, false /* TODO */, false);\n#endif\n#endif\n\n#ifdef ANDROID\n   SETTING_BOOL(\"android_input_disconnect_workaround\", &settings->bools.android_input_disconnect_workaround, true, false, false);\n#endif\n\n#ifdef _3DS\n   SETTING_BOOL(\"new3ds_speedup_enable\",         &settings->bools.new3ds_speedup_enable, true, DEFAULT_NEW_3DS_SPEEDUP_ENABLE,      false);\n   SETTING_BOOL(\"video_3ds_lcd_bottom\",          &settings->bools.video_3ds_lcd_bottom,  true, DEFAULT_VIDEO_3DS_LCD_BOTTOM, false);\n   SETTING_BOOL(\"bottom_font_enable\",            &settings->bools.bottom_font_enable,    true, DEFAULT_BOTTOM_FONT_ENABLE, false);\n#endif\n\n#ifdef WIIU\n   SETTING_BOOL(\"video_wiiu_prefer_drc\",         &settings->bools.video_wiiu_prefer_drc, true, DEFAULT_WIIU_PREFER_DRC, false);\n#endif\n\n#if defined(HAVE_COCOATOUCH) && defined(TARGET_OS_TV)\n   SETTING_BOOL(\"gcdwebserver_alert\",            &settings->bools.gcdwebserver_alert, true, true, false);\n#endif\n\n   *size = count;\n\n   return tmp;\n}\n\nstatic struct config_float_setting *populate_settings_float(\n      settings_t *settings, int *size)\n{\n   unsigned count = 0;\n   struct config_float_setting  *tmp      = (struct config_float_setting*)calloc(1, (*size + 1) * sizeof(struct config_float_setting));\n\n   if (!tmp)\n      return NULL;\n\n#ifdef HAVE_MENU\n   SETTING_FLOAT(\"menu_scale_factor\",            &settings->floats.menu_scale_factor, true, DEFAULT_MENU_SCALE_FACTOR, false);\n   SETTING_FLOAT(\"menu_widget_scale_factor\",     &settings->floats.menu_widget_scale_factor, true, DEFAULT_MENU_WIDGET_SCALE_FACTOR, false);\n#if !(defined(RARCH_CONSOLE) || defined(RARCH_MOBILE))\n   SETTING_FLOAT(\"menu_widget_scale_factor_windowed\", &settings->floats.menu_widget_scale_factor_windowed, true, DEFAULT_MENU_WIDGET_SCALE_FACTOR_WINDOWED, false);\n#endif\n   SETTING_FLOAT(\"menu_wallpaper_opacity\",       &settings->floats.menu_wallpaper_opacity,   true, DEFAULT_MENU_WALLPAPER_OPACITY, false);\n   SETTING_FLOAT(\"menu_framebuffer_opacity\",     &settings->floats.menu_framebuffer_opacity, true, DEFAULT_MENU_FRAMEBUFFER_OPACITY, false);\n   SETTING_FLOAT(\"menu_footer_opacity\",          &settings->floats.menu_footer_opacity,      true, DEFAULT_MENU_FOOTER_OPACITY, false);\n   SETTING_FLOAT(\"menu_header_opacity\",          &settings->floats.menu_header_opacity,      true, DEFAULT_MENU_HEADER_OPACITY, false);\n   SETTING_FLOAT(\"menu_ticker_speed\",            &settings->floats.menu_ticker_speed,        true, DEFAULT_MENU_TICKER_SPEED,   false);\n#ifdef HAVE_RGUI\n   SETTING_FLOAT(\"rgui_particle_effect_speed\",   &settings->floats.menu_rgui_particle_effect_speed, true, DEFAULT_RGUI_PARTICLE_EFFECT_SPEED, false);\n#endif\n#if defined(HAVE_MATERIALUI) || defined(HAVE_XMB) || defined(HAVE_OZONE)\n   SETTING_FLOAT(\"menu_screensaver_animation_speed\", &settings->floats.menu_screensaver_animation_speed, true, DEFAULT_MENU_SCREENSAVER_ANIMATION_SPEED, false);\n#endif\n#ifdef HAVE_OZONE\n   SETTING_FLOAT(\"ozone_thumbnail_scale_factor\", &settings->floats.ozone_thumbnail_scale_factor, true, DEFAULT_OZONE_THUMBNAIL_SCALE_FACTOR, false);\n#endif\n#endif /* HAVE_MENU */\n\n#ifdef HAVE_CHEEVOS\n   SETTING_FLOAT(\"cheevos_appearance_padding_h\", &settings->floats.cheevos_appearance_padding_h, true, DEFAULT_CHEEVOS_APPEARANCE_PADDING_H, false);\n   SETTING_FLOAT(\"cheevos_appearance_padding_v\", &settings->floats.cheevos_appearance_padding_v, true, DEFAULT_CHEEVOS_APPEARANCE_PADDING_V, false);\n#endif\n\n   SETTING_FLOAT(\"fastforward_ratio\",            &settings->floats.fastforward_ratio, true, DEFAULT_FASTFORWARD_RATIO, false);\n   SETTING_FLOAT(\"slowmotion_ratio\",             &settings->floats.slowmotion_ratio,  true, DEFAULT_SLOWMOTION_RATIO, false);\n\n   SETTING_FLOAT(\"audio_rate_control_delta\",     audio_get_float_ptr(AUDIO_ACTION_RATE_CONTROL_DELTA), true, DEFAULT_RATE_CONTROL_DELTA, false);\n   SETTING_FLOAT(\"audio_max_timing_skew\",        &settings->floats.audio_max_timing_skew, true, DEFAULT_MAX_TIMING_SKEW, false);\n   SETTING_FLOAT(\"audio_volume\",                 &settings->floats.audio_volume, true, DEFAULT_AUDIO_VOLUME, false);\n#ifdef HAVE_AUDIOMIXER\n   SETTING_FLOAT(\"audio_mixer_volume\",           &settings->floats.audio_mixer_volume, true, DEFAULT_AUDIO_MIXER_VOLUME, false);\n#endif\n\n   SETTING_FLOAT(\"video_aspect_ratio\",           &settings->floats.video_aspect_ratio, true, DEFAULT_ASPECT_RATIO, false);\n   SETTING_FLOAT(\"video_viewport_bias_x\",        &settings->floats.video_vp_bias_x, true, DEFAULT_VIEWPORT_BIAS_X, false);\n   SETTING_FLOAT(\"video_viewport_bias_y\",        &settings->floats.video_vp_bias_y, true, DEFAULT_VIEWPORT_BIAS_Y, false);\n#if defined(RARCH_MOBILE)\n   SETTING_FLOAT(\"video_viewport_bias_portrait_x\", &settings->floats.video_vp_bias_portrait_x, true, DEFAULT_VIEWPORT_BIAS_PORTRAIT_X, false);\n   SETTING_FLOAT(\"video_viewport_bias_portrait_y\", &settings->floats.video_vp_bias_portrait_y, true, DEFAULT_VIEWPORT_BIAS_PORTRAIT_Y, false);\n#endif\n   SETTING_FLOAT(\"video_refresh_rate\",           &settings->floats.video_refresh_rate, true, DEFAULT_REFRESH_RATE, false);\n   SETTING_FLOAT(\"video_autoswitch_pal_threshold\", &settings->floats.video_autoswitch_pal_threshold, true, DEFAULT_AUTOSWITCH_PAL_THRESHOLD, false);\n   SETTING_FLOAT(\"crt_video_refresh_rate\",       &settings->floats.crt_video_refresh_rate, true, DEFAULT_CRT_REFRESH_RATE, false);\n   SETTING_FLOAT(\"video_message_pos_x\",          &settings->floats.video_msg_pos_x, true, DEFAULT_MESSAGE_POS_OFFSET_X, false);\n   SETTING_FLOAT(\"video_message_pos_y\",          &settings->floats.video_msg_pos_y, true, DEFAULT_MESSAGE_POS_OFFSET_Y, false);\n   SETTING_FLOAT(\"video_font_size\",              &settings->floats.video_font_size, true, DEFAULT_FONT_SIZE, false);\n   SETTING_FLOAT(\"video_msg_bgcolor_opacity\",    &settings->floats.video_msg_bgcolor_opacity, true, DEFAULT_MESSAGE_BGCOLOR_OPACITY, false);\n   SETTING_FLOAT(\"video_hdr_max_nits\",           &settings->floats.video_hdr_max_nits, true, DEFAULT_VIDEO_HDR_MAX_NITS, false);\n   SETTING_FLOAT(\"video_hdr_paper_white_nits\",   &settings->floats.video_hdr_paper_white_nits, true, DEFAULT_VIDEO_HDR_PAPER_WHITE_NITS, false);\n   SETTING_FLOAT(\"video_hdr_display_contrast\",   &settings->floats.video_hdr_display_contrast, true, DEFAULT_VIDEO_HDR_CONTRAST, false);\n\n   SETTING_FLOAT(\"input_axis_threshold\",         &settings->floats.input_axis_threshold,     true, DEFAULT_AXIS_THRESHOLD, false);\n   SETTING_FLOAT(\"input_analog_deadzone\",        &settings->floats.input_analog_deadzone,    true, DEFAULT_ANALOG_DEADZONE, false);\n   SETTING_FLOAT(\"input_analog_sensitivity\",     &settings->floats.input_analog_sensitivity, true, DEFAULT_ANALOG_SENSITIVITY, false);\n#ifdef HAVE_OVERLAY\n   SETTING_FLOAT(\"input_overlay_opacity\",                 &settings->floats.input_overlay_opacity, true, DEFAULT_INPUT_OVERLAY_OPACITY, false);\n   SETTING_FLOAT(\"input_osk_overlay_opacity\",             &settings->floats.input_osk_overlay_opacity, true, DEFAULT_INPUT_OVERLAY_OPACITY, false);\n   SETTING_FLOAT(\"input_overlay_scale_landscape\",         &settings->floats.input_overlay_scale_landscape, true, DEFAULT_INPUT_OVERLAY_SCALE_LANDSCAPE, false);\n   SETTING_FLOAT(\"input_overlay_aspect_adjust_landscape\", &settings->floats.input_overlay_aspect_adjust_landscape, true, DEFAULT_INPUT_OVERLAY_ASPECT_ADJUST_LANDSCAPE, false);\n   SETTING_FLOAT(\"input_overlay_x_separation_landscape\",  &settings->floats.input_overlay_x_separation_landscape, true, DEFAULT_INPUT_OVERLAY_X_SEPARATION_LANDSCAPE, false);\n   SETTING_FLOAT(\"input_overlay_y_separation_landscape\",  &settings->floats.input_overlay_y_separation_landscape, true, DEFAULT_INPUT_OVERLAY_Y_SEPARATION_LANDSCAPE, false);\n   SETTING_FLOAT(\"input_overlay_x_offset_landscape\",      &settings->floats.input_overlay_x_offset_landscape, true, DEFAULT_INPUT_OVERLAY_X_OFFSET_LANDSCAPE, false);\n   SETTING_FLOAT(\"input_overlay_y_offset_landscape\",      &settings->floats.input_overlay_y_offset_landscape, true, DEFAULT_INPUT_OVERLAY_Y_OFFSET_LANDSCAPE, false);\n   SETTING_FLOAT(\"input_overlay_scale_portrait\",          &settings->floats.input_overlay_scale_portrait, true, DEFAULT_INPUT_OVERLAY_SCALE_PORTRAIT, false);\n   SETTING_FLOAT(\"input_overlay_aspect_adjust_portrait\",  &settings->floats.input_overlay_aspect_adjust_portrait, true, DEFAULT_INPUT_OVERLAY_ASPECT_ADJUST_PORTRAIT, false);\n   SETTING_FLOAT(\"input_overlay_x_separation_portrait\",   &settings->floats.input_overlay_x_separation_portrait, true, DEFAULT_INPUT_OVERLAY_X_SEPARATION_PORTRAIT, false);\n   SETTING_FLOAT(\"input_overlay_y_separation_portrait\",   &settings->floats.input_overlay_y_separation_portrait, true, DEFAULT_INPUT_OVERLAY_Y_SEPARATION_PORTRAIT, false);\n   SETTING_FLOAT(\"input_overlay_x_offset_portrait\",       &settings->floats.input_overlay_x_offset_portrait, true, DEFAULT_INPUT_OVERLAY_X_OFFSET_PORTRAIT, false);\n   SETTING_FLOAT(\"input_overlay_y_offset_portrait\",       &settings->floats.input_overlay_y_offset_portrait, true, DEFAULT_INPUT_OVERLAY_Y_OFFSET_PORTRAIT, false);\n   SETTING_FLOAT(\"input_overlay_mouse_speed\",             &settings->floats.input_overlay_mouse_speed, true, DEFAULT_INPUT_OVERLAY_MOUSE_SPEED, false);\n   SETTING_FLOAT(\"input_overlay_mouse_swipe_threshold\",   &settings->floats.input_overlay_mouse_swipe_threshold, true, DEFAULT_INPUT_OVERLAY_MOUSE_SWIPE_THRESHOLD, false);\n#endif\n\n#ifdef _3DS\n   SETTING_FLOAT(\"bottom_font_scale\",            &settings->floats.bottom_font_scale, true, DEFAULT_BOTTOM_FONT_SCALE, false);\n#endif\n\n   *size = count;\n\n   return tmp;\n}\n\nstatic struct config_uint_setting *populate_settings_uint(\n      settings_t *settings, int *size)\n{\n   unsigned count                     = 0;\n   struct config_uint_setting  *tmp   = (struct config_uint_setting*)calloc(1, (*size + 1) * sizeof(struct config_uint_setting));\n\n   if (!tmp)\n      return NULL;\n\n   SETTING_UINT(\"frontend_log_level\",            &settings->uints.frontend_log_level, true, DEFAULT_FRONTEND_LOG_LEVEL, false);\n   SETTING_UINT(\"libretro_log_level\",            &settings->uints.libretro_log_level, true, DEFAULT_LIBRETRO_LOG_LEVEL, false);\n   SETTING_UINT(\"fps_update_interval\",           &settings->uints.fps_update_interval, true, DEFAULT_FPS_UPDATE_INTERVAL, false);\n   SETTING_UINT(\"memory_update_interval\",        &settings->uints.memory_update_interval, true, DEFAULT_MEMORY_UPDATE_INTERVAL, false);\n   SETTING_UINT(\"core_updater_auto_backup_history_size\", &settings->uints.core_updater_auto_backup_history_size, true, DEFAULT_CORE_UPDATER_AUTO_BACKUP_HISTORY_SIZE, false);\n   SETTING_UINT(\"autosave_interval\",             &settings->uints.autosave_interval,  true, DEFAULT_AUTOSAVE_INTERVAL, false);\n   SETTING_UINT(\"rewind_granularity\",            &settings->uints.rewind_granularity, true, DEFAULT_REWIND_GRANULARITY, false);\n   SETTING_UINT(\"rewind_buffer_size_step\",       &settings->uints.rewind_buffer_size_step, true, DEFAULT_REWIND_BUFFER_SIZE_STEP, false);\n   SETTING_UINT(\"run_ahead_frames\",              &settings->uints.run_ahead_frames, true, 1,  false);\n   SETTING_UINT(\"replay_max_keep\",               &settings->uints.replay_max_keep, true, DEFAULT_REPLAY_MAX_KEEP, false);\n   SETTING_UINT(\"replay_checkpoint_interval\",    &settings->uints.replay_checkpoint_interval,  true, DEFAULT_REPLAY_CHECKPOINT_INTERVAL, false);\n   SETTING_UINT(\"savestate_max_keep\",            &settings->uints.savestate_max_keep, true, DEFAULT_SAVESTATE_MAX_KEEP, false);\n#ifdef HAVE_MENU\n   SETTING_UINT(\"content_show_add_entry\",        &settings->uints.menu_content_show_add_entry, true, DEFAULT_MENU_CONTENT_SHOW_ADD_ENTRY, false);\n   SETTING_UINT(\"content_show_contentless_cores\",&settings->uints.menu_content_show_contentless_cores, true, DEFAULT_MENU_CONTENT_SHOW_CONTENTLESS_CORES, false);\n   SETTING_UINT(\"content_history_size\",          &settings->uints.content_history_size, true, DEFAULT_CONTENT_HISTORY_SIZE, false);\n   SETTING_UINT(\"playlist_entry_remove_enable\",        &settings->uints.playlist_entry_remove_enable, true, DEFAULT_PLAYLIST_ENTRY_REMOVE_ENABLE, false);\n   SETTING_UINT(\"playlist_show_inline_core_name\",      &settings->uints.playlist_show_inline_core_name, true, DEFAULT_PLAYLIST_SHOW_INLINE_CORE_NAME, false);\n   SETTING_UINT(\"playlist_show_history_icons\",         &settings->uints.playlist_show_history_icons, true, DEFAULT_PLAYLIST_SHOW_HISTORY_ICONS, false);\n   SETTING_UINT(\"playlist_sublabel_runtime_type\",      &settings->uints.playlist_sublabel_runtime_type, true, DEFAULT_PLAYLIST_SUBLABEL_RUNTIME_TYPE, false);\n   SETTING_UINT(\"playlist_sublabel_last_played_style\", &settings->uints.playlist_sublabel_last_played_style, true, DEFAULT_PLAYLIST_SUBLABEL_LAST_PLAYED_STYLE, false);\n   SETTING_UINT(\"quit_on_close_content\",         &settings->uints.quit_on_close_content, true, DEFAULT_QUIT_ON_CLOSE_CONTENT, false);\n   SETTING_UINT(\"menu_thumbnails\",               &settings->uints.gfx_thumbnails, true, DEFAULT_GFX_THUMBNAILS_DEFAULT, false);\n   SETTING_UINT(\"menu_left_thumbnails\",          &settings->uints.menu_left_thumbnails, true, DEFAULT_MENU_LEFT_THUMBNAILS_DEFAULT, false);\n   SETTING_UINT(\"menu_icon_thumbnails\",          &settings->uints.menu_icon_thumbnails, true, DEFAULT_MENU_ICON_THUMBNAILS_DEFAULT, false);\n   SETTING_UINT(\"menu_thumbnail_upscale_threshold\", &settings->uints.gfx_thumbnail_upscale_threshold, true, DEFAULT_GFX_THUMBNAIL_UPSCALE_THRESHOLD, false);\n   SETTING_UINT(\"menu_timedate_style\",           &settings->uints.menu_timedate_style, true, DEFAULT_MENU_TIMEDATE_STYLE, false);\n   SETTING_UINT(\"menu_timedate_date_separator\",  &settings->uints.menu_timedate_date_separator, true, DEFAULT_MENU_TIMEDATE_DATE_SEPARATOR, false);\n   SETTING_UINT(\"menu_ticker_type\",              &settings->uints.menu_ticker_type, true, DEFAULT_MENU_TICKER_TYPE, false);\n   SETTING_UINT(\"menu_scroll_delay\",             &settings->uints.menu_scroll_delay, true, DEFAULT_MENU_SCROLL_DELAY, false);\n   SETTING_UINT(\"menu_screensaver_timeout\",      &settings->uints.menu_screensaver_timeout, true, DEFAULT_MENU_SCREENSAVER_TIMEOUT, false);\n#if defined(HAVE_MATERIALUI) || defined(HAVE_XMB) || defined(HAVE_OZONE)\n   SETTING_UINT(\"menu_screensaver_animation\",    &settings->uints.menu_screensaver_animation, true, DEFAULT_MENU_SCREENSAVER_ANIMATION, false);\n#endif\n#if defined(HAVE_XMB) || defined(HAVE_OZONE)\n   SETTING_UINT(\"menu_remember_selection\",       &settings->uints.menu_remember_selection, true, DEFAULT_MENU_REMEMBER_SELECTION, false);\n#endif\n#ifdef HAVE_RGUI\n   SETTING_UINT(\"rgui_menu_color_theme\",         &settings->uints.menu_rgui_color_theme, true, DEFAULT_RGUI_COLOR_THEME, false);\n   SETTING_UINT(\"rgui_thumbnail_downscaler\",     &settings->uints.menu_rgui_thumbnail_downscaler, true, DEFAULT_RGUI_THUMBNAIL_DOWNSCALER, false);\n   SETTING_UINT(\"rgui_thumbnail_delay\",          &settings->uints.menu_rgui_thumbnail_delay, true, DEFAULT_RGUI_THUMBNAIL_DELAY, false);\n   SETTING_UINT(\"rgui_internal_upscale_level\",   &settings->uints.menu_rgui_internal_upscale_level, true, DEFAULT_RGUI_INTERNAL_UPSCALE_LEVEL, false);\n   SETTING_UINT(\"rgui_aspect_ratio\",             &settings->uints.menu_rgui_aspect_ratio, true, DEFAULT_RGUI_ASPECT, false);\n   SETTING_UINT(\"rgui_aspect_ratio_lock\",        &settings->uints.menu_rgui_aspect_ratio_lock, true, DEFAULT_RGUI_ASPECT_LOCK, false);\n   SETTING_UINT(\"rgui_particle_effect\",          &settings->uints.menu_rgui_particle_effect, true, DEFAULT_RGUI_PARTICLE_EFFECT, false);\n#endif\n#ifdef HAVE_XMB\n   SETTING_UINT(\"menu_xmb_animation_opening_main_menu\",    &settings->uints.menu_xmb_animation_opening_main_menu, true, DEFAULT_XMB_ANIMATION, false);\n   SETTING_UINT(\"menu_xmb_animation_horizontal_highlight\", &settings->uints.menu_xmb_animation_horizontal_highlight, true, DEFAULT_XMB_ANIMATION, false);\n   SETTING_UINT(\"menu_xmb_animation_move_up_down\",         &settings->uints.menu_xmb_animation_move_up_down, true, DEFAULT_XMB_ANIMATION, false);\n   SETTING_UINT(\"menu_xmb_thumbnail_scale_factor\",         &settings->uints.menu_xmb_thumbnail_scale_factor, true, DEFAULT_XMB_THUMBNAIL_SCALE_FACTOR, false);\n   SETTING_UINT(\"menu_xmb_vertical_fade_factor\",           &settings->uints.menu_xmb_vertical_fade_factor, true, DEFAULT_XMB_VERTICAL_FADE_FACTOR, false);\n   SETTING_UINT(\"xmb_alpha_factor\",              &settings->uints.menu_xmb_alpha_factor, true, DEFAULT_XMB_ALPHA_FACTOR, false);\n   SETTING_UINT(\"xmb_layout\",                    &settings->uints.menu_xmb_layout, true, DEFAULT_XMB_MENU_LAYOUT, false);\n   SETTING_UINT(\"xmb_theme\",                     &settings->uints.menu_xmb_theme, true, DEFAULT_XMB_ICON_THEME, false);\n   SETTING_UINT(\"xmb_menu_color_theme\",          &settings->uints.menu_xmb_color_theme, true, DEFAULT_XMB_THEME, false);\n   SETTING_UINT(\"menu_shader_pipeline\",          &settings->uints.menu_xmb_shader_pipeline, true, DEFAULT_MENU_SHADER_PIPELINE, false);\n   SETTING_UINT(\"menu_font_color_red\",           &settings->uints.menu_font_color_red, true, DEFAULT_MENU_FONT_COLOR_RED, false);\n   SETTING_UINT(\"menu_font_color_green\",         &settings->uints.menu_font_color_green, true, DEFAULT_MENU_FONT_COLOR_GREEN, false);\n   SETTING_UINT(\"menu_font_color_blue\",          &settings->uints.menu_font_color_blue, true, DEFAULT_MENU_FONT_COLOR_BLUE, false);\n#endif\n#ifdef HAVE_MATERIALUI\n   SETTING_UINT(\"materialui_menu_color_theme\",              &settings->uints.menu_materialui_color_theme, true, DEFAULT_MATERIALUI_THEME, false);\n   SETTING_UINT(\"materialui_menu_transition_animation\",     &settings->uints.menu_materialui_transition_animation, true, DEFAULT_MATERIALUI_TRANSITION_ANIM, false);\n   SETTING_UINT(\"materialui_thumbnail_view_portrait\",       &settings->uints.menu_materialui_thumbnail_view_portrait, true, DEFAULT_MATERIALUI_THUMBNAIL_VIEW_PORTRAIT, false);\n   SETTING_UINT(\"materialui_thumbnail_view_landscape\",      &settings->uints.menu_materialui_thumbnail_view_landscape, true, DEFAULT_MATERIALUI_THUMBNAIL_VIEW_LANDSCAPE, false);\n   SETTING_UINT(\"materialui_landscape_layout_optimization\", &settings->uints.menu_materialui_landscape_layout_optimization, true, DEFAULT_MATERIALUI_LANDSCAPE_LAYOUT_OPTIMIZATION, false);\n#endif\n#ifdef HAVE_OZONE\n   SETTING_UINT(\"ozone_menu_color_theme\",        &settings->uints.menu_ozone_color_theme, true, DEFAULT_OZONE_COLOR_THEME, false);\n#endif\n#endif /* HAVE_MENU */\n\n   SETTING_UINT(\"audio_out_rate\",                &settings->uints.audio_output_sample_rate, true, DEFAULT_OUTPUT_RATE, false);\n   SETTING_UINT(\"audio_latency\",                 &settings->uints.audio_latency, false, 0 /* TODO */, false);\n   SETTING_UINT(\"audio_resampler_quality\",       &settings->uints.audio_resampler_quality, true, DEFAULT_AUDIO_RESAMPLER_QUALITY_LEVEL, false);\n   SETTING_UINT(\"audio_block_frames\",            &settings->uints.audio_block_frames, true, 0, false);\n   SETTING_UINT(\"midi_volume\",                   &settings->uints.midi_volume, true, DEFAULT_MIDI_VOLUME, false);\n\n#ifdef HAVE_WASAPI\n   SETTING_UINT(\"audio_wasapi_sh_buffer_length\",  &settings->uints.audio_wasapi_sh_buffer_length, true, DEFAULT_WASAPI_SH_BUFFER_LENGTH, false);\n#endif\n\n#ifdef HAVE_MICROPHONE\n   SETTING_UINT(\"microphone_latency\",            &settings->uints.microphone_latency, false, 0 /* TODO */, false);\n   SETTING_UINT(\"microphone_resampler_quality\",  &settings->uints.microphone_resampler_quality, true, DEFAULT_AUDIO_RESAMPLER_QUALITY_LEVEL, false);\n   SETTING_UINT(\"microphone_block_frames\",       &settings->uints.microphone_block_frames, true, 0, false);\n   SETTING_UINT(\"microphone_rate\",               &settings->uints.microphone_sample_rate, true, DEFAULT_INPUT_RATE, false);\n#ifdef HAVE_WASAPI\n   SETTING_UINT(\"microphone_wasapi_sh_buffer_length\", &settings->uints.microphone_wasapi_sh_buffer_length, true, DEFAULT_WASAPI_MICROPHONE_SH_BUFFER_LENGTH, false);\n#endif\n#endif\n\n   SETTING_UINT(\"crt_switch_resolution\",         &settings->uints.crt_switch_resolution, true, DEFAULT_CRT_SWITCH_RESOLUTION, false);\n   SETTING_UINT(\"crt_switch_resolution_super\",   &settings->uints.crt_switch_resolution_super, true, DEFAULT_CRT_SWITCH_RESOLUTION_SUPER, false);\n   SETTING_UINT(\"custom_viewport_width\",         &settings->video_vp_custom.width, false, 0 /* TODO */, false);\n   SETTING_UINT(\"custom_viewport_height\",        &settings->video_vp_custom.height, false, 0 /* TODO */, false);\n   SETTING_UINT(\"custom_viewport_x\",             (unsigned*)&settings->video_vp_custom.x, false, 0 /* TODO */, false);\n   SETTING_UINT(\"custom_viewport_y\",             (unsigned*)&settings->video_vp_custom.y, false, 0 /* TODO */, false);\n   SETTING_UINT(\"aspect_ratio_index\",            &settings->uints.video_aspect_ratio_idx, true, DEFAULT_ASPECT_RATIO_IDX, false);\n   SETTING_UINT(\"video_autoswitch_refresh_rate\", &settings->uints.video_autoswitch_refresh_rate, true, DEFAULT_AUTOSWITCH_REFRESH_RATE, false);\n   SETTING_UINT(\"video_monitor_index\",           &settings->uints.video_monitor_index, true, DEFAULT_MONITOR_INDEX, false);\n   SETTING_UINT(\"video_windowed_position_x\",     &settings->uints.window_position_x,    true, 0, false);\n   SETTING_UINT(\"video_windowed_position_y\",     &settings->uints.window_position_y,    true, 0, false);\n   SETTING_UINT(\"video_windowed_position_width\", &settings->uints.window_position_width,    true, DEFAULT_WINDOW_WIDTH, false);\n   SETTING_UINT(\"video_windowed_position_height\",&settings->uints.window_position_height,    true, DEFAULT_WINDOW_HEIGHT, false);\n   SETTING_UINT(\"video_window_auto_width_max\",   &settings->uints.window_auto_width_max,    true, DEFAULT_WINDOW_AUTO_WIDTH_MAX, false);\n   SETTING_UINT(\"video_window_auto_height_max\",  &settings->uints.window_auto_height_max,    true, DEFAULT_WINDOW_AUTO_HEIGHT_MAX, false);\n#ifdef __WINRT__\n   SETTING_UINT(\"video_fullscreen_x\",            &settings->uints.video_fullscreen_x, true, uwp_get_width(), false);\n   SETTING_UINT(\"video_fullscreen_y\",            &settings->uints.video_fullscreen_y, true, uwp_get_height(), false);\n#else\n   SETTING_UINT(\"video_fullscreen_x\",            &settings->uints.video_fullscreen_x, true, DEFAULT_FULLSCREEN_X, false);\n   SETTING_UINT(\"video_fullscreen_y\",            &settings->uints.video_fullscreen_y, true, DEFAULT_FULLSCREEN_Y, false);\n#endif\n   SETTING_UINT(\"video_scale\",                   &settings->uints.video_scale, true, DEFAULT_SCALE, false);\n   SETTING_UINT(\"video_scale_integer_axis\",      &settings->uints.video_scale_integer_axis, true, DEFAULT_SCALE_INTEGER_AXIS, false);\n   SETTING_UINT(\"video_scale_integer_scaling\",   &settings->uints.video_scale_integer_scaling, true, DEFAULT_SCALE_INTEGER_SCALING, false);\n   SETTING_UINT(\"video_window_opacity\",          &settings->uints.video_window_opacity, true, DEFAULT_WINDOW_OPACITY, false);\n   SETTING_UINT(\"video_shader_delay\",            &settings->uints.video_shader_delay, true, DEFAULT_SHADER_DELAY, false);\n#ifdef GEKKO\n   SETTING_UINT(\"video_viwidth\",                    &settings->uints.video_viwidth, true, DEFAULT_VIDEO_VI_WIDTH, false);\n   SETTING_UINT(\"video_overscan_correction_top\",    &settings->uints.video_overscan_correction_top, true, DEFAULT_VIDEO_OVERSCAN_CORRECTION_TOP, false);\n   SETTING_UINT(\"video_overscan_correction_bottom\", &settings->uints.video_overscan_correction_bottom, true, DEFAULT_VIDEO_OVERSCAN_CORRECTION_BOTTOM, false);\n#endif\n   SETTING_UINT(\"video_hard_sync_frames\",        &settings->uints.video_hard_sync_frames, true, DEFAULT_HARD_SYNC_FRAMES, false);\n   SETTING_UINT(\"video_frame_delay\",             &settings->uints.video_frame_delay,      true, DEFAULT_FRAME_DELAY, false);\n   SETTING_UINT(\"video_max_swapchain_images\",    &settings->uints.video_max_swapchain_images, true, DEFAULT_MAX_SWAPCHAIN_IMAGES, false);\n   SETTING_UINT(\"video_max_frame_latency\",       &settings->uints.video_max_frame_latency, true, DEFAULT_MAX_FRAME_LATENCY, false);\n   SETTING_UINT(\"video_black_frame_insertion\",   &settings->uints.video_black_frame_insertion, true, DEFAULT_BLACK_FRAME_INSERTION, false);\n   SETTING_UINT(\"video_bfi_dark_frames\",         &settings->uints.video_bfi_dark_frames, true, DEFAULT_BFI_DARK_FRAMES, false);\n   SETTING_UINT(\"video_shader_subframes\",        &settings->uints.video_shader_subframes, true, DEFAULT_SHADER_SUBFRAMES, false);\n   SETTING_UINT(\"video_swap_interval\",           &settings->uints.video_swap_interval, true, DEFAULT_SWAP_INTERVAL, false);\n   SETTING_UINT(\"video_rotation\",                &settings->uints.video_rotation, true, ORIENTATION_NORMAL, false);\n   SETTING_UINT(\"screen_orientation\",            &settings->uints.screen_orientation, true, ORIENTATION_NORMAL, false);\n   SETTING_UINT(\"video_msg_bgcolor_red\",         &settings->uints.video_msg_bgcolor_red, true, DEFAULT_MESSAGE_BGCOLOR_RED, false);\n   SETTING_UINT(\"video_msg_bgcolor_green\",       &settings->uints.video_msg_bgcolor_green, true, DEFAULT_MESSAGE_BGCOLOR_GREEN, false);\n   SETTING_UINT(\"video_msg_bgcolor_blue\",        &settings->uints.video_msg_bgcolor_blue, true, DEFAULT_MESSAGE_BGCOLOR_BLUE, false);\n\n   SETTING_UINT(\"video_stream_port\",             &settings->uints.video_stream_port, true, RARCH_STREAM_DEFAULT_PORT, false);\n   SETTING_UINT(\"video_record_threads\",          &settings->uints.video_record_threads, true, DEFAULT_VIDEO_RECORD_THREADS, false);\n   SETTING_UINT(\"video_record_quality\",          &settings->uints.video_record_quality, true, RECORD_CONFIG_TYPE_RECORDING_MED_QUALITY, false);\n   SETTING_UINT(\"video_stream_quality\",          &settings->uints.video_stream_quality, true, RECORD_CONFIG_TYPE_STREAMING_MED_QUALITY, false);\n   SETTING_UINT(\"video_record_scale_factor\",     &settings->uints.video_record_scale_factor, true, 1, false);\n   SETTING_UINT(\"video_stream_scale_factor\",     &settings->uints.video_stream_scale_factor, true, 1, false);\n\n#ifdef HAVE_NETWORKING\n   SETTING_UINT(\"streaming_mode\",                &settings->uints.streaming_mode, true, STREAMING_MODE_TWITCH, false);\n#endif\n   SETTING_UINT(\"screen_brightness\",             &settings->uints.screen_brightness, true, DEFAULT_SCREEN_BRIGHTNESS, false);\n\n   SETTING_UINT(\"input_bind_timeout\",            &settings->uints.input_bind_timeout,     true, DEFAULT_INPUT_BIND_TIMEOUT, false);\n   SETTING_UINT(\"input_bind_hold\",               &settings->uints.input_bind_hold,        true, DEFAULT_INPUT_BIND_HOLD, false);\n   SETTING_UINT(\"input_turbo_period\",            &settings->uints.input_turbo_period,     true, DEFAULT_TURBO_PERIOD, false);\n   SETTING_UINT(\"input_duty_cycle\",              &settings->uints.input_turbo_duty_cycle, true, DEFAULT_TURBO_DUTY_CYCLE, false);\n   SETTING_UINT(\"input_turbo_mode\",              &settings->uints.input_turbo_mode, true, DEFAULT_TURBO_MODE, false);\n   SETTING_UINT(\"input_turbo_default_button\",    &settings->uints.input_turbo_default_button, true, DEFAULT_TURBO_DEFAULT_BTN, false);\n   SETTING_UINT(\"input_max_users\",               &settings->uints.input_max_users,          true, DEFAULT_INPUT_MAX_USERS, false);\n   SETTING_UINT(\"input_menu_toggle_gamepad_combo\", &settings->uints.input_menu_toggle_gamepad_combo, true, DEFAULT_MENU_TOGGLE_GAMEPAD_COMBO, false);\n   SETTING_UINT(\"input_poll_type_behavior\",      &settings->uints.input_poll_type_behavior, true, DEFAULT_INPUT_POLL_TYPE_BEHAVIOR, false);\n   SETTING_UINT(\"input_quit_gamepad_combo\",      &settings->uints.input_quit_gamepad_combo, true, DEFAULT_QUIT_GAMEPAD_COMBO, false);\n   SETTING_UINT(\"input_hotkey_block_delay\",      &settings->uints.input_hotkey_block_delay, true, DEFAULT_INPUT_HOTKEY_BLOCK_DELAY, false);\n#ifdef GEKKO\n   SETTING_UINT(\"input_mouse_scale\",             &settings->uints.input_mouse_scale, true, DEFAULT_MOUSE_SCALE, false);\n#endif\n   SETTING_UINT(\"input_touch_scale\",             &settings->uints.input_touch_scale, true, DEFAULT_TOUCH_SCALE, false);\n   SETTING_UINT(\"input_rumble_gain\",             &settings->uints.input_rumble_gain, true, DEFAULT_RUMBLE_GAIN, false);\n   SETTING_UINT(\"input_auto_game_focus\",         &settings->uints.input_auto_game_focus, true, DEFAULT_INPUT_AUTO_GAME_FOCUS, false);\n#ifdef ANDROID\n   SETTING_UINT(\"input_block_timeout\",           &settings->uints.input_block_timeout, true, 0, false);\n#endif\n   SETTING_UINT(\"keyboard_gamepad_mapping_type\", &settings->uints.input_keyboard_gamepad_mapping_type, true, 1, false);\n\n#if defined(HAVE_OVERLAY)\n   SETTING_UINT(\"input_overlay_show_inputs\",               &settings->uints.input_overlay_show_inputs, true, DEFAULT_OVERLAY_SHOW_INPUTS, false);\n   SETTING_UINT(\"input_overlay_show_inputs_port\",          &settings->uints.input_overlay_show_inputs_port, true, DEFAULT_OVERLAY_SHOW_INPUTS_PORT, false);\n   SETTING_UINT(\"input_overlay_dpad_diagonal_sensitivity\", &settings->uints.input_overlay_dpad_diagonal_sensitivity, true, DEFAULT_OVERLAY_DPAD_DIAGONAL_SENSITIVITY, false);\n   SETTING_UINT(\"input_overlay_abxy_diagonal_sensitivity\", &settings->uints.input_overlay_abxy_diagonal_sensitivity, true, DEFAULT_OVERLAY_ABXY_DIAGONAL_SENSITIVITY, false);\n   SETTING_UINT(\"input_overlay_analog_recenter_zone\",      &settings->uints.input_overlay_analog_recenter_zone, true, DEFAULT_INPUT_OVERLAY_ANALOG_RECENTER_ZONE, false);\n#endif\n\n#ifdef HAVE_LIBNX\n   SETTING_UINT(\"split_joycon_p1\",               &settings->uints.input_split_joycon[0], true, 0, false);\n   SETTING_UINT(\"split_joycon_p2\",               &settings->uints.input_split_joycon[1], true, 0, false);\n   SETTING_UINT(\"split_joycon_p3\",               &settings->uints.input_split_joycon[2], true, 0, false);\n   SETTING_UINT(\"split_joycon_p4\",               &settings->uints.input_split_joycon[3], true, 0, false);\n   SETTING_UINT(\"split_joycon_p5\",               &settings->uints.input_split_joycon[4], true, 0, false);\n   SETTING_UINT(\"split_joycon_p6\",               &settings->uints.input_split_joycon[5], true, 0, false);\n   SETTING_UINT(\"split_joycon_p7\",               &settings->uints.input_split_joycon[6], true, 0, false);\n   SETTING_UINT(\"split_joycon_p8\",               &settings->uints.input_split_joycon[7], true, 0, false);\n#endif\n\n#ifdef HAVE_SCREENSHOTS\n   SETTING_UINT(\"notification_show_screenshot_duration\", &settings->uints.notification_show_screenshot_duration, true, DEFAULT_NOTIFICATION_SHOW_SCREENSHOT_DURATION, false);\n   SETTING_UINT(\"notification_show_screenshot_flash\",    &settings->uints.notification_show_screenshot_flash, true, DEFAULT_NOTIFICATION_SHOW_SCREENSHOT_FLASH, false);\n#endif\n\n#ifdef HAVE_NETWORKING\n   SETTING_UINT(\"netplay_ip_port\",                    &settings->uints.netplay_port, true, RARCH_DEFAULT_PORT, false);\n   SETTING_OVERRIDE(RARCH_OVERRIDE_SETTING_NETPLAY_IP_PORT);\n   SETTING_UINT(\"netplay_max_connections\",            &settings->uints.netplay_max_connections, true, DEFAULT_NETPLAY_MAX_CONNECTIONS, false);\n   SETTING_UINT(\"netplay_max_ping\",                   &settings->uints.netplay_max_ping, true, DEFAULT_NETPLAY_MAX_PING, false);\n   SETTING_UINT(\"netplay_chat_color_name\",            &settings->uints.netplay_chat_color_name, true, DEFAULT_NETPLAY_CHAT_COLOR_NAME, false);\n   SETTING_UINT(\"netplay_chat_color_msg\",             &settings->uints.netplay_chat_color_msg, true, DEFAULT_NETPLAY_CHAT_COLOR_MSG, false);\n   SETTING_UINT(\"netplay_input_latency_frames_min\",   &settings->uints.netplay_input_latency_frames_min, true, 0, false);\n   SETTING_UINT(\"netplay_input_latency_frames_range\", &settings->uints.netplay_input_latency_frames_range, true, 0, false);\n   SETTING_UINT(\"netplay_share_digital\",              &settings->uints.netplay_share_digital, true, DEFAULT_NETPLAY_SHARE_DIGITAL, false);\n   SETTING_UINT(\"netplay_share_analog\",               &settings->uints.netplay_share_analog,  true, DEFAULT_NETPLAY_SHARE_ANALOG, false);\n#endif\n#ifdef HAVE_COMMAND\n   SETTING_UINT(\"network_cmd_port\",              &settings->uints.network_cmd_port,    true, DEFAULT_NETWORK_CMD_PORT, false);\n#endif\n#ifdef HAVE_NETWORKGAMEPAD\n   SETTING_UINT(\"network_remote_base_port\",      &settings->uints.network_remote_base_port, true, DEFAULT_NETWORK_REMOTE_BASE_PORT, false);\n#endif\n\n#ifdef HAVE_LANGEXTRA\n   SETTING_UINT(\"user_language\",                 msg_hash_get_uint(MSG_HASH_USER_LANGUAGE), true, frontend_driver_get_user_language(), false);\n#endif\n#ifndef __APPLE__\n   SETTING_UINT(\"bundle_assets_extract_version_current\", &settings->uints.bundle_assets_extract_version_current, true, 0, false);\n#endif\n   SETTING_UINT(\"bundle_assets_extract_last_version\",    &settings->uints.bundle_assets_extract_last_version, true, 0, false);\n\n\n#ifdef HAVE_CHEEVOS\n   SETTING_UINT(\"cheevos_appearance_anchor\",     &settings->uints.cheevos_appearance_anchor, true, DEFAULT_CHEEVOS_APPEARANCE_ANCHOR, false);\n   SETTING_UINT(\"cheevos_visibility_summary\",    &settings->uints.cheevos_visibility_summary, true, DEFAULT_CHEEVOS_VISIBILITY_SUMMARY, false);\n#endif\n   SETTING_UINT(\"accessibility_narrator_speech_speed\", &settings->uints.accessibility_narrator_speech_speed, true, DEFAULT_ACCESSIBILITY_NARRATOR_SPEECH_SPEED, false);\n   SETTING_UINT(\"ai_service_mode\",              &settings->uints.ai_service_mode,            true, DEFAULT_AI_SERVICE_MODE, false);\n   SETTING_UINT(\"ai_service_target_lang\",       &settings->uints.ai_service_target_lang,     true, 0, false);\n   SETTING_UINT(\"ai_service_source_lang\",       &settings->uints.ai_service_source_lang,     true, 0, false);\n\n#ifdef HAVE_LIBNX\n   SETTING_UINT(\"libnx_overclock\",               &settings->uints.libnx_overclock, true, SWITCH_DEFAULT_CPU_PROFILE, false);\n#endif\n#ifdef _3DS\n   SETTING_UINT(\"video_3ds_display_mode\",        &settings->uints.video_3ds_display_mode, true, DEFAULT_VIDEO_3DS_DISPLAY_MODE, false);\n#endif\n#if defined(DINGUX)\n   SETTING_UINT(\"video_dingux_ipu_filter_type\",  &settings->uints.video_dingux_ipu_filter_type, true, DEFAULT_DINGUX_IPU_FILTER_TYPE, false);\n#if defined(DINGUX_BETA)\n   SETTING_UINT(\"video_dingux_refresh_rate\",     &settings->uints.video_dingux_refresh_rate, true, DEFAULT_DINGUX_REFRESH_RATE, false);\n#endif\n#if defined(RS90) || defined(MIYOO)\n   SETTING_UINT(\"video_dingux_rs90_softfilter_type\", &settings->uints.video_dingux_rs90_softfilter_type, true, DEFAULT_DINGUX_RS90_SOFTFILTER_TYPE, false);\n#endif\n#endif\n\n#ifdef HAVE_LAKKA\n   SETTING_UINT(\"cpu_scaling_mode\",              &settings->uints.cpu_scaling_mode,    true,   0, false);\n   SETTING_UINT(\"cpu_min_freq\",                  &settings->uints.cpu_min_freq,        true,   1, false);\n   SETTING_UINT(\"cpu_max_freq\",                  &settings->uints.cpu_max_freq,        true, ~0U, false);\n#endif\n\n#ifdef HAVE_MIST\n   SETTING_UINT(\"steam_rich_presence_format\",    &settings->uints.steam_rich_presence_format, true, DEFAULT_STEAM_RICH_PRESENCE_FORMAT, false);\n#endif\n\n#ifdef HAVE_OVERLAY\n   SETTING_UINT(\"input_overlay_lightgun_trigger_delay\",     &settings->uints.input_overlay_lightgun_trigger_delay, true, DEFAULT_INPUT_OVERLAY_LIGHTGUN_TRIGGER_DELAY, false);\n   SETTING_UINT(\"input_overlay_lightgun_two_touch_input\",   &settings->uints.input_overlay_lightgun_two_touch_input, true, DEFAULT_INPUT_OVERLAY_LIGHTGUN_MULTI_TOUCH_INPUT, false);\n   SETTING_UINT(\"input_overlay_lightgun_three_touch_input\", &settings->uints.input_overlay_lightgun_three_touch_input, true, DEFAULT_INPUT_OVERLAY_LIGHTGUN_MULTI_TOUCH_INPUT, false);\n   SETTING_UINT(\"input_overlay_lightgun_four_touch_input\",  &settings->uints.input_overlay_lightgun_four_touch_input, true, DEFAULT_INPUT_OVERLAY_LIGHTGUN_MULTI_TOUCH_INPUT, false);\n   SETTING_UINT(\"input_overlay_mouse_hold_msec\",            &settings->uints.input_overlay_mouse_hold_msec, true, DEFAULT_INPUT_OVERLAY_MOUSE_HOLD_MSEC, false);\n   SETTING_UINT(\"input_overlay_mouse_dtap_msec\",            &settings->uints.input_overlay_mouse_dtap_msec, true, DEFAULT_INPUT_OVERLAY_MOUSE_DTAP_MSEC, false);\n#endif\n\n   *size = count;\n\n   return tmp;\n}\n\nstatic struct config_size_setting *populate_settings_size(\n      settings_t *settings, int *size)\n{\n   unsigned count                     = 0;\n   struct config_size_setting  *tmp   = (struct config_size_setting*)calloc((*size + 1), sizeof(struct config_size_setting));\n\n   if (!tmp)\n      return NULL;\n\n   SETTING_SIZE(\"rewind_buffer_size\",            &settings->sizes.rewind_buffer_size, true, DEFAULT_REWIND_BUFFER_SIZE, false);\n\n   *size = count;\n\n   return tmp;\n}\n\nstatic struct config_int_setting *populate_settings_int(\n      settings_t *settings, int *size)\n{\n   unsigned count                     = 0;\n   struct config_int_setting  *tmp    = (struct config_int_setting*)calloc((*size + 1), sizeof(struct config_int_setting));\n\n   if (!tmp)\n      return NULL;\n\n   SETTING_INT(\"content_favorites_size\",         &settings->ints.content_favorites_size, true, DEFAULT_CONTENT_FAVORITES_SIZE, false);\n   SETTING_INT(\"state_slot\",                     &settings->ints.state_slot, false, 0, false);\n   SETTING_INT(\"replay_slot\",                    &settings->ints.replay_slot, false, 0, false);\n\n#ifdef HAVE_XMB\n   SETTING_INT(\"menu_xmb_title_margin\",                   &settings->ints.menu_xmb_title_margin, true, DEFAULT_XMB_TITLE_MARGIN, false);\n   SETTING_INT(\"menu_xmb_title_margin_horizontal_offset\", &settings->ints.menu_xmb_title_margin_horizontal_offset, true, DEFAULT_XMB_TITLE_MARGIN_HORIZONTAL_OFFSET, false);\n#endif\n\n   SETTING_INT(\"crt_switch_center_adjust\",       &settings->ints.crt_switch_center_adjust, false, DEFAULT_CRT_SWITCH_CENTER_ADJUST, false);\n   SETTING_INT(\"crt_switch_porch_adjust\",        &settings->ints.crt_switch_porch_adjust, false, DEFAULT_CRT_SWITCH_PORCH_ADJUST, false);\n#ifdef HAVE_WINDOW_OFFSET\n   SETTING_INT(\"video_window_offset_x\",          &settings->ints.video_window_offset_x, true, DEFAULT_WINDOW_OFFSET_X, false);\n   SETTING_INT(\"video_window_offset_y\",          &settings->ints.video_window_offset_y, true, DEFAULT_WINDOW_OFFSET_Y, false);\n#endif\n\n#ifdef HAVE_D3D10\n   SETTING_INT(\"d3d10_gpu_index\",                &settings->ints.d3d10_gpu_index, true, DEFAULT_D3D10_GPU_INDEX, false);\n#endif\n#ifdef HAVE_D3D11\n   SETTING_INT(\"d3d11_gpu_index\",                &settings->ints.d3d11_gpu_index, true, DEFAULT_D3D11_GPU_INDEX, false);\n#endif\n#ifdef HAVE_D3D12\n   SETTING_INT(\"d3d12_gpu_index\",                &settings->ints.d3d12_gpu_index, true, DEFAULT_D3D12_GPU_INDEX, false);\n#endif\n#ifdef HAVE_VULKAN\n   SETTING_INT(\"vulkan_gpu_index\",               &settings->ints.vulkan_gpu_index, true, DEFAULT_VULKAN_GPU_INDEX, false);\n#endif\n\n#ifdef HAVE_NETWORKING\n   SETTING_INT(\"netplay_check_frames\",           &settings->ints.netplay_check_frames, true, DEFAULT_NETPLAY_CHECK_FRAMES, false);\n   SETTING_OVERRIDE(RARCH_OVERRIDE_SETTING_NETPLAY_CHECK_FRAMES);\n#endif\n\n#ifdef _3DS\n   SETTING_INT(\"bottom_font_color_red\",          &settings->ints.bottom_font_color_red,     true, DEFAULT_BOTTOM_FONT_COLOR, false);\n   SETTING_INT(\"bottom_font_color_green\",        &settings->ints.bottom_font_color_green,   true, DEFAULT_BOTTOM_FONT_COLOR, false);\n   SETTING_INT(\"bottom_font_color_blue\",         &settings->ints.bottom_font_color_blue,    true, DEFAULT_BOTTOM_FONT_COLOR, false);\n   SETTING_INT(\"bottom_font_color_opacity\",      &settings->ints.bottom_font_color_opacity, true, DEFAULT_BOTTOM_FONT_COLOR, false);\n#endif\n\n#ifdef HAVE_OVERLAY\n   SETTING_INT(\"input_overlay_lightgun_port\",    &settings->ints.input_overlay_lightgun_port, true, DEFAULT_INPUT_OVERLAY_LIGHTGUN_PORT, false);\n#endif\n\n   *size = count;\n\n   return tmp;\n}\n\nstatic void video_driver_default_settings(global_t *global)\n{\n   if (!global)\n      return;\n\n   global->console.screen.gamma_correction       = DEFAULT_GAMMA;\n   global->console.flickerfilter_enable          = false;\n   global->console.softfilter_enable             = false;\n\n   global->console.screen.resolutions.current.id = 0;\n}\n\n/**\n * config_set_defaults:\n *\n * Set 'default' configuration values.\n **/\nvoid config_set_defaults(void *data)\n{\n   size_t i;\n#ifdef HAVE_MENU\n   static bool first_initialized   = true;\n#endif\n   global_t *global                 = (global_t*)data;\n   settings_t *settings             = config_st;\n   recording_state_t *recording_st  = recording_state_get_ptr();\n   int bool_settings_size           = sizeof(settings->bools)   / sizeof(settings->bools.placeholder);\n   int float_settings_size          = sizeof(settings->floats)  / sizeof(settings->floats.placeholder);\n   int int_settings_size            = sizeof(settings->ints)    / sizeof(settings->ints.placeholder);\n   int uint_settings_size           = sizeof(settings->uints)   / sizeof(settings->uints.placeholder);\n   int size_settings_size           = sizeof(settings->sizes)   / sizeof(settings->sizes.placeholder);\n   const char *def_video            = config_get_default_video();\n   const char *def_audio            = config_get_default_audio();\n#ifdef HAVE_MICROPHONE\n   const char *def_microphone       = config_get_default_microphone();\n#endif\n   const char *def_audio_resampler  = config_get_default_audio_resampler();\n   const char *def_input            = config_get_default_input();\n   const char *def_joypad           = config_get_default_joypad();\n#ifdef HAVE_MENU\n   const char *def_menu             = config_get_default_menu();\n#endif\n   const char *def_camera           = config_get_default_camera();\n   const char *def_bluetooth        = config_get_default_bluetooth();\n   const char *def_wifi             = config_get_default_wifi();\n   const char *def_led              = config_get_default_led();\n   const char *def_cloudsync        = config_get_default_cloudsync();\n   const char *def_location         = config_get_default_location();\n   const char *def_record           = config_get_default_record();\n   const char *def_midi             = config_get_default_midi();\n   const char *def_mitm             = DEFAULT_NETPLAY_MITM_SERVER;\n   struct video_viewport *custom_vp = &settings->video_vp_custom;\n   struct config_float_setting      *float_settings = populate_settings_float (settings, &float_settings_size);\n   struct config_bool_setting       *bool_settings  = populate_settings_bool  (settings, &bool_settings_size);\n   struct config_int_setting        *int_settings   = populate_settings_int   (settings, &int_settings_size);\n   struct config_uint_setting       *uint_settings  = populate_settings_uint  (settings, &uint_settings_size);\n   struct config_size_setting       *size_settings  = populate_settings_size  (settings, &size_settings_size);\n\n   if (bool_settings && (bool_settings_size > 0))\n   {\n      for (i = 0; i < (unsigned)bool_settings_size; i++)\n      {\n         if (bool_settings[i].flags & CFG_BOOL_FLG_DEF_ENABLE)\n            *bool_settings[i].ptr = bool_settings[i].def;\n      }\n\n      free(bool_settings);\n   }\n\n   if (int_settings && (int_settings_size > 0))\n   {\n      for (i = 0; i < (unsigned)int_settings_size; i++)\n      {\n         if (int_settings[i].flags & CFG_BOOL_FLG_DEF_ENABLE)\n            *int_settings[i].ptr = int_settings[i].def;\n      }\n\n      free(int_settings);\n   }\n\n   if (uint_settings && (uint_settings_size > 0))\n   {\n      for (i = 0; i < (unsigned)uint_settings_size; i++)\n      {\n         if (uint_settings[i].flags & CFG_BOOL_FLG_DEF_ENABLE)\n            *uint_settings[i].ptr = uint_settings[i].def;\n      }\n\n      free(uint_settings);\n   }\n\n   if (size_settings && (size_settings_size > 0))\n   {\n      for (i = 0; i < (unsigned)size_settings_size; i++)\n      {\n         if (size_settings[i].flags & CFG_BOOL_FLG_DEF_ENABLE)\n            *size_settings[i].ptr = size_settings[i].def;\n      }\n\n      free(size_settings);\n   }\n\n   if (float_settings && (float_settings_size > 0))\n   {\n      for (i = 0; i < (unsigned)float_settings_size; i++)\n      {\n         if (float_settings[i].flags & CFG_BOOL_FLG_DEF_ENABLE)\n            *float_settings[i].ptr = float_settings[i].def;\n      }\n\n      free(float_settings);\n   }\n\n   if (def_camera)\n      configuration_set_string(settings,\n            settings->arrays.camera_driver,\n            def_camera);\n   if (def_bluetooth)\n      configuration_set_string(settings,\n            settings->arrays.bluetooth_driver,\n            def_bluetooth);\n   if (def_wifi)\n      configuration_set_string(settings,\n            settings->arrays.wifi_driver,\n            def_wifi);\n   if (def_led)\n      configuration_set_string(settings,\n            settings->arrays.led_driver,\n            def_led);\n   if (def_cloudsync)\n      configuration_set_string(settings,\n            settings->arrays.cloud_sync_driver,\n            def_cloudsync);\n   if (def_location)\n      configuration_set_string(settings,\n            settings->arrays.location_driver,\n            def_location);\n   if (def_video)\n      configuration_set_string(settings,\n            settings->arrays.video_driver,\n            def_video);\n   if (def_audio)\n      configuration_set_string(settings,\n            settings->arrays.audio_driver,\n            def_audio);\n#ifdef HAVE_MICROPHONE\n   if (def_microphone)\n      configuration_set_string(settings,\n            settings->arrays.microphone_driver,\n            def_microphone);\n   if (def_audio_resampler)  /* not a typo, microphone's default sampler is the same as audio's */\n      configuration_set_string(settings,\n            settings->arrays.microphone_resampler,\n            def_audio_resampler);\n#endif\n   if (def_audio_resampler)\n      configuration_set_string(settings,\n            settings->arrays.audio_resampler,\n            def_audio_resampler);\n   if (def_input)\n      configuration_set_string(settings,\n            settings->arrays.input_driver,\n            def_input);\n   if (def_joypad)\n      configuration_set_string(settings,\n            settings->arrays.input_joypad_driver,\n            def_joypad);\n   if (def_record)\n      configuration_set_string(settings,\n            settings->arrays.record_driver,\n            def_record);\n   if (def_midi)\n      configuration_set_string(settings,\n            settings->arrays.midi_driver,\n            def_midi);\n   if (def_mitm)\n      configuration_set_string(settings,\n            settings->arrays.netplay_mitm_server,\n            def_mitm);\n#ifdef HAVE_MENU\n   if (def_menu)\n      configuration_set_string(settings,\n            settings->arrays.menu_driver,\n            def_menu);\n#ifdef HAVE_XMB\n   *settings->paths.path_menu_xmb_font            = '\\0';\n#endif\n\n   configuration_set_string(settings,\n         settings->arrays.discord_app_id,\n         DEFAULT_DISCORD_APP_ID);\n\n   configuration_set_string(settings,\n         settings->arrays.ai_service_url,\n         DEFAULT_AI_SERVICE_URL);\n\n#ifdef HAVE_MATERIALUI\n   if (g_defaults.menu_materialui_menu_color_theme_enable)\n      settings->uints.menu_materialui_color_theme = g_defaults.menu_materialui_menu_color_theme;\n#endif\n#endif\n\n   settings->uints.video_scale                 = DEFAULT_SCALE;\n\n   video_driver_set_threaded(DEFAULT_VIDEO_THREADED);\n\n   settings->floats.video_msg_color_r          = ((DEFAULT_MESSAGE_COLOR >> 16) & 0xff) / 255.0f;\n   settings->floats.video_msg_color_g          = ((DEFAULT_MESSAGE_COLOR >>  8) & 0xff) / 255.0f;\n   settings->floats.video_msg_color_b          = ((DEFAULT_MESSAGE_COLOR >>  0) & 0xff) / 255.0f;\n\n   if (g_defaults.settings_video_refresh_rate > 0.0 &&\n         g_defaults.settings_video_refresh_rate != DEFAULT_REFRESH_RATE)\n      settings->floats.video_refresh_rate      = g_defaults.settings_video_refresh_rate;\n\n   if (DEFAULT_AUDIO_DEVICE)\n      configuration_set_string(settings,\n            settings->arrays.audio_device,\n            DEFAULT_AUDIO_DEVICE);\n\n   if (!g_defaults.settings_out_latency)\n      g_defaults.settings_out_latency          = DEFAULT_OUT_LATENCY;\n\n   settings->uints.audio_latency               = g_defaults.settings_out_latency;\n\n   if (!g_defaults.settings_in_latency)\n      g_defaults.settings_in_latency          = DEFAULT_IN_LATENCY;\n\n\n   audio_set_float(AUDIO_ACTION_VOLUME_GAIN, settings->floats.audio_volume);\n#ifdef HAVE_AUDIOMIXER\n   audio_set_float(AUDIO_ACTION_MIXER_VOLUME_GAIN, settings->floats.audio_mixer_volume);\n#endif\n\n#ifdef HAVE_MICROPHONE\n   if (DEFAULT_MICROPHONE_DEVICE)\n      configuration_set_string(settings,\n            settings->arrays.microphone_device,\n            DEFAULT_MICROPHONE_DEVICE);\n\n   settings->uints.microphone_latency         = g_defaults.settings_in_latency;\n#endif\n\n#ifdef HAVE_LAKKA\n   configuration_set_bool(settings,\n         settings->bools.ssh_enable, filestream_exists(LAKKA_SSH_PATH));\n   configuration_set_bool(settings,\n         settings->bools.samba_enable, filestream_exists(LAKKA_SAMBA_PATH));\n   configuration_set_bool(settings,\n         settings->bools.bluetooth_enable, filestream_exists(LAKKA_BLUETOOTH_PATH));\n   configuration_set_bool(settings, settings->bools.localap_enable, false);\n   load_timezone(settings->arrays.timezone, TIMEZONE_LENGTH);\n#endif\n\n#if __APPLE__\n   configuration_set_bool(settings,\n         settings->bools.accessibility_enable, RAIsVoiceOverRunning());\n#endif\n\n#ifdef ANDROID\n   configuration_set_bool(settings,\n         settings->bools.accessibility_enable, is_screen_reader_enabled());\n#endif\n\n#ifdef HAVE_MENU\n   if (first_initialized)\n      configuration_set_bool(settings,\n            settings->bools.menu_show_start_screen,\n            DEFAULT_MENU_SHOW_START_SCREEN);\n#endif\n\n#ifdef HAVE_CHEEVOS\n   *settings->arrays.cheevos_username                 = '\\0';\n   *settings->arrays.cheevos_password                 = '\\0';\n   *settings->arrays.cheevos_token                    = '\\0';\n#endif\n\n   input_config_reset();\n   input_remapping_deinit(false);\n   input_remapping_set_defaults(false);\n\n   configuration_set_string(settings,\n         settings->paths.network_buildbot_url, DEFAULT_BUILDBOT_SERVER_URL);\n   configuration_set_string(settings,\n         settings->paths.network_buildbot_assets_url,\n         DEFAULT_BUILDBOT_ASSETS_SERVER_URL);\n\n   *settings->arrays.input_keyboard_layout                = '\\0';\n\n   for (i = 0; i < MAX_USERS; i++)\n   {\n      settings->uints.input_joypad_index[i] = (unsigned)i;\n#ifdef SWITCH /* Switch preferred default dpad mode */\n      settings->uints.input_analog_dpad_mode[i] = ANALOG_DPAD_LSTICK;\n#else\n      settings->uints.input_analog_dpad_mode[i] = ANALOG_DPAD_NONE;\n#endif\n      input_config_set_device((unsigned)i, RETRO_DEVICE_JOYPAD);\n      settings->uints.input_mouse_index[i] = (unsigned)i;\n   }\n\n   custom_vp->width  = 0;\n   custom_vp->height = 0;\n   custom_vp->x      = 0;\n   custom_vp->y      = 0;\n\n   /* Make sure settings from other configs carry over into defaults\n    * for another config. */\n   if (!retroarch_override_setting_is_set(RARCH_OVERRIDE_SETTING_SAVE_PATH, NULL))\n      dir_clear(RARCH_DIR_SAVEFILE);\n   if (!retroarch_override_setting_is_set(RARCH_OVERRIDE_SETTING_STATE_PATH, NULL))\n      dir_clear(RARCH_DIR_SAVESTATE);\n\n   *settings->paths.path_libretro_info = '\\0';\n   *settings->paths.directory_libretro = '\\0';\n   *settings->paths.directory_screenshot = '\\0';\n   *settings->paths.directory_system = '\\0';\n   *settings->paths.directory_cache = '\\0';\n   *settings->paths.directory_input_remapping = '\\0';\n   *settings->paths.directory_core_assets = '\\0';\n   *settings->paths.directory_assets = '\\0';\n   *settings->paths.directory_dynamic_wallpapers = '\\0';\n   *settings->paths.directory_thumbnails = '\\0';\n   *settings->paths.directory_playlist = '\\0';\n   *settings->paths.directory_content_favorites = '\\0';\n   *settings->paths.directory_content_history = '\\0';\n   *settings->paths.directory_content_image_history = '\\0';\n   *settings->paths.directory_content_music_history = '\\0';\n   *settings->paths.directory_content_video_history = '\\0';\n   *settings->paths.directory_runtime_log = '\\0';\n   *settings->paths.directory_autoconfig = '\\0';\n#ifdef HAVE_MENU\n   *settings->paths.directory_menu_content = '\\0';\n   *settings->paths.directory_menu_config = '\\0';\n#endif\n   *settings->paths.directory_video_shader = '\\0';\n   *settings->paths.directory_video_filter = '\\0';\n   *settings->paths.directory_audio_filter = '\\0';\n\n   retroarch_ctl(RARCH_CTL_UNSET_UPS_PREF, NULL);\n   retroarch_ctl(RARCH_CTL_UNSET_BPS_PREF, NULL);\n   retroarch_ctl(RARCH_CTL_UNSET_IPS_PREF, NULL);\n   retroarch_ctl(RARCH_CTL_UNSET_XDELTA_PREF, NULL);\n\n   *recording_st->output_dir                     = '\\0';\n   *recording_st->config_dir                     = '\\0';\n\n   *settings->paths.path_core_options            = '\\0';\n   *settings->paths.path_content_favorites       = '\\0';\n   *settings->paths.path_content_history         = '\\0';\n   *settings->paths.path_content_image_history   = '\\0';\n   *settings->paths.path_content_music_history   = '\\0';\n   *settings->paths.path_content_video_history   = '\\0';\n   *settings->paths.path_cheat_settings          = '\\0';\n#if !defined(__APPLE__)\n   *settings->paths.bundle_assets_src            = '\\0';\n   *settings->paths.bundle_assets_dst            = '\\0';\n   *settings->paths.bundle_assets_dst_subdir     = '\\0';\n#endif\n   *settings->paths.path_cheat_database    = '\\0';\n   *settings->paths.path_menu_wallpaper    = '\\0';\n   *settings->paths.path_rgui_theme_preset = '\\0';\n   *settings->paths.path_content_database  = '\\0';\n   *settings->paths.path_overlay           = '\\0';\n   *settings->paths.path_osk_overlay       = '\\0';\n   *settings->paths.path_record_config     = '\\0';\n   *settings->paths.path_stream_config     = '\\0';\n   *settings->paths.path_stream_url        = '\\0';\n   *settings->paths.path_softfilter_plugin = '\\0';\n\n   *settings->paths.path_audio_dsp_plugin = '\\0';\n\n   *settings->paths.log_dir = '\\0';\n\n   video_driver_default_settings(global);\n\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_WALLPAPERS]))\n      configuration_set_string(settings,\n            settings->paths.directory_dynamic_wallpapers,\n            g_defaults.dirs[DEFAULT_DIR_WALLPAPERS]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_THUMBNAILS]))\n      configuration_set_string(settings,\n            settings->paths.directory_thumbnails,\n            g_defaults.dirs[DEFAULT_DIR_THUMBNAILS]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_REMAP]))\n      configuration_set_string(settings,\n            settings->paths.directory_input_remapping,\n            g_defaults.dirs[DEFAULT_DIR_REMAP]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_CACHE]))\n      configuration_set_string(settings,\n            settings->paths.directory_cache,\n            g_defaults.dirs[DEFAULT_DIR_CACHE]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_ASSETS]))\n      configuration_set_string(settings,\n            settings->paths.directory_assets,\n            g_defaults.dirs[DEFAULT_DIR_ASSETS]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_CORE_ASSETS]))\n      configuration_set_string(settings,\n            settings->paths.directory_core_assets,\n            g_defaults.dirs[DEFAULT_DIR_CORE_ASSETS]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_PLAYLIST]))\n      configuration_set_string(settings,\n            settings->paths.directory_playlist,\n            g_defaults.dirs[DEFAULT_DIR_PLAYLIST]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_CONTENT_FAVORITES]))\n      configuration_set_string(settings,\n            settings->paths.directory_content_favorites,\n            g_defaults.dirs[DEFAULT_DIR_CONTENT_FAVORITES]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_CONTENT_HISTORY]))\n      configuration_set_string(settings,\n            settings->paths.directory_content_history,\n            g_defaults.dirs[DEFAULT_DIR_CONTENT_HISTORY]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_CONTENT_IMAGE_HISTORY]))\n      configuration_set_string(settings,\n            settings->paths.directory_content_image_history,\n            g_defaults.dirs[DEFAULT_DIR_CONTENT_IMAGE_HISTORY]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_CONTENT_MUSIC_HISTORY]))\n      configuration_set_string(settings,\n            settings->paths.directory_content_music_history,\n            g_defaults.dirs[DEFAULT_DIR_CONTENT_MUSIC_HISTORY]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_CONTENT_VIDEO_HISTORY]))\n      configuration_set_string(settings,\n            settings->paths.directory_content_video_history,\n            g_defaults.dirs[DEFAULT_DIR_CONTENT_VIDEO_HISTORY]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_CORE]))\n      fill_pathname_expand_special(settings->paths.directory_libretro,\n            g_defaults.dirs[DEFAULT_DIR_CORE],\n            sizeof(settings->paths.directory_libretro));\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_AUDIO_FILTER]))\n      configuration_set_string(settings,\n            settings->paths.directory_audio_filter,\n            g_defaults.dirs[DEFAULT_DIR_AUDIO_FILTER]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_VIDEO_FILTER]))\n      configuration_set_string(settings,\n            settings->paths.directory_video_filter,\n            g_defaults.dirs[DEFAULT_DIR_VIDEO_FILTER]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_SHADER]))\n      fill_pathname_expand_special(settings->paths.directory_video_shader,\n            g_defaults.dirs[DEFAULT_DIR_SHADER],\n            sizeof(settings->paths.directory_video_shader));\n\n   if (!string_is_empty(g_defaults.path_buildbot_server_url))\n      configuration_set_string(settings,\n            settings->paths.network_buildbot_url,\n            g_defaults.path_buildbot_server_url);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_DATABASE]))\n      configuration_set_string(settings,\n            settings->paths.path_content_database,\n            g_defaults.dirs[DEFAULT_DIR_DATABASE]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_CHEATS]))\n      configuration_set_string(settings,\n            settings->paths.path_cheat_database,\n            g_defaults.dirs[DEFAULT_DIR_CHEATS]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_CORE_INFO]))\n      fill_pathname_expand_special(settings->paths.path_libretro_info,\n            g_defaults.dirs[DEFAULT_DIR_CORE_INFO],\n            sizeof(settings->paths.path_libretro_info));\n#ifdef HAVE_OVERLAY\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_OVERLAY]))\n   {\n      fill_pathname_expand_special(settings->paths.directory_overlay,\n            g_defaults.dirs[DEFAULT_DIR_OVERLAY],\n            sizeof(settings->paths.directory_overlay));\n#ifdef RARCH_MOBILE\n      if (string_is_empty(settings->paths.path_overlay))\n         fill_pathname_join_special(settings->paths.path_overlay,\n               settings->paths.directory_overlay,\n               FILE_PATH_DEFAULT_OVERLAY,\n               sizeof(settings->paths.path_overlay));\n#endif\n   }\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_OSK_OVERLAY]))\n      fill_pathname_expand_special(settings->paths.directory_osk_overlay,\n            g_defaults.dirs[DEFAULT_DIR_OSK_OVERLAY],\n            sizeof(settings->paths.directory_osk_overlay));\n#endif\n\n#ifdef HAVE_MENU\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_MENU_CONFIG]))\n   {\n      configuration_set_string(settings,\n            settings->paths.directory_menu_config,\n            g_defaults.dirs[DEFAULT_DIR_MENU_CONFIG]);\n#if TARGET_OS_IPHONE\n      {\n         char config_file_path[PATH_MAX_LENGTH];\n         fill_pathname_join_special(config_file_path,\n               settings->paths.directory_menu_config,\n               FILE_PATH_MAIN_CONFIG,\n               sizeof(config_file_path));\n         path_set(RARCH_PATH_CONFIG,\n               config_file_path);\n      }\n#endif\n   }\n\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_MENU_CONTENT]))\n      configuration_set_string(settings,\n            settings->paths.directory_menu_content,\n            g_defaults.dirs[DEFAULT_DIR_MENU_CONTENT]);\n#endif\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_AUTOCONFIG]))\n      configuration_set_string(settings,\n            settings->paths.directory_autoconfig,\n            g_defaults.dirs[DEFAULT_DIR_AUTOCONFIG]);\n\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_SAVESTATE]))\n      dir_set(RARCH_DIR_SAVESTATE, g_defaults.dirs[DEFAULT_DIR_SAVESTATE]);\n\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_SRAM]))\n      dir_set(RARCH_DIR_SAVEFILE, g_defaults.dirs[DEFAULT_DIR_SRAM]);\n\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_SYSTEM]))\n      configuration_set_string(settings,\n            settings->paths.directory_system,\n            g_defaults.dirs[DEFAULT_DIR_SYSTEM]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_SCREENSHOT]))\n      configuration_set_string(settings,\n            settings->paths.directory_screenshot,\n            g_defaults.dirs[DEFAULT_DIR_SCREENSHOT]);\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_LOGS]))\n      configuration_set_string(settings,\n            settings->paths.log_dir,\n            g_defaults.dirs[DEFAULT_DIR_LOGS]);\n\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_RECORD_OUTPUT]))\n      fill_pathname_expand_special(recording_st->output_dir,\n            g_defaults.dirs[DEFAULT_DIR_RECORD_OUTPUT],\n            sizeof(recording_st->output_dir));\n   if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_RECORD_CONFIG]))\n      fill_pathname_expand_special(recording_st->config_dir,\n            g_defaults.dirs[DEFAULT_DIR_RECORD_CONFIG],\n            sizeof(recording_st->config_dir));\n\n   if (!string_is_empty(g_defaults.path_config))\n   {\n      char temp_str[PATH_MAX_LENGTH];\n\n      temp_str[0] = '\\0';\n\n      fill_pathname_expand_special(temp_str,\n            g_defaults.path_config,\n            sizeof(temp_str));\n      path_set(RARCH_PATH_CONFIG, temp_str);\n   }\n\n   configuration_set_string(settings,\n         settings->arrays.midi_input,\n         DEFAULT_MIDI_INPUT);\n   configuration_set_string(settings,\n         settings->arrays.midi_output,\n         DEFAULT_MIDI_OUTPUT);\n\n#ifdef HAVE_CONFIGFILE\n   /* Avoid reloading config on every content load */\n   if (DEFAULT_BLOCK_CONFIG_READ)\n      retroarch_ctl(RARCH_CTL_SET_BLOCK_CONFIG_READ, NULL);\n   else\n      retroarch_ctl(RARCH_CTL_UNSET_BLOCK_CONFIG_READ, NULL);\n#endif\n\n#ifdef HAVE_MENU\n   first_initialized = false;\n#endif\n}\n\n/**\n * config_load:\n *\n * Loads a config file and reads all the values into memory.\n *\n */\nvoid config_load(void *data)\n{\n   global_t *global = (global_t*)data;\n   config_set_defaults(global);\n#ifdef HAVE_CONFIGFILE\n   config_parse_file(global);\n#endif\n}\n\n#ifdef HAVE_CONFIGFILE\n#if defined(HAVE_MENU) && defined(HAVE_RGUI)\nstatic bool check_menu_driver_compatibility(settings_t *settings)\n{\n   char *video_driver   = settings->arrays.video_driver;\n   char *menu_driver    = settings->arrays.menu_driver;\n\n   if (     string_is_equal(menu_driver,  \"rgui\")\n         || string_is_equal(menu_driver,  \"null\")\n         || string_is_equal(video_driver, \"null\"))\n      return true;\n\n   /* TODO/FIXME - maintenance hazard */\n   if (string_starts_with_size(video_driver, \"d3d\", STRLEN_CONST(\"d3d\")))\n      if (\n               string_is_equal(video_driver, \"d3d9_hlsl\")\n            || string_is_equal(video_driver, \"d3d9_cg\")\n            || string_is_equal(video_driver, \"d3d10\")\n            || string_is_equal(video_driver, \"d3d11\")\n            || string_is_equal(video_driver, \"d3d12\")\n         )\n      return true;\n   if (string_starts_with_size(video_driver, \"gl\", STRLEN_CONST(\"gl\")))\n      if (\n               string_is_equal(video_driver, \"gl\")\n            || string_is_equal(video_driver, \"gl1\")\n            || string_is_equal(video_driver, \"glcore\")\n         )\n         return true;\n   if (\n            string_is_equal(video_driver, \"caca\")\n         || string_is_equal(video_driver, \"gdi\")\n         || string_is_equal(video_driver, \"gx2\")\n         || string_is_equal(video_driver, \"vulkan\")\n         || string_is_equal(video_driver, \"metal\")\n         || string_is_equal(video_driver, \"ctr\")\n         || string_is_equal(video_driver, \"vita2d\")\n         || string_is_equal(video_driver, \"rsx\")\n      )\n      return true;\n\n   return false;\n}\n#endif\n\n/**\n * open_default_config_file\n *\n * Open a default config file. Platform-specific.\n *\n * Returns: handle to config file if found, otherwise NULL.\n **/\nstatic config_file_t *open_default_config_file(void)\n{\n   char conf_path[PATH_MAX_LENGTH];\n   config_file_t *conf                    = NULL;\n#ifndef RARCH_CONSOLE\n   char application_data[PATH_MAX_LENGTH] = {0};\n#endif\n#if defined(_WIN32) && !defined(_XBOX)\n   char app_path[PATH_MAX_LENGTH]         = {0};\n#if defined(__WINRT__) || defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP\n   /* On UWP, the app install directory is not writable so use the writable LocalState dir instead */\n   fill_pathname_home_dir(app_path, sizeof(app_path));\n#else\n   fill_pathname_application_dir(app_path, sizeof(app_path));\n#endif\n   fill_pathname_resolve_relative(conf_path, app_path,\n         FILE_PATH_MAIN_CONFIG, sizeof(conf_path));\n\n   conf = config_file_new_from_path_to_string(conf_path);\n\n   if (!conf)\n   {\n      if (fill_pathname_application_data(application_data,\n            sizeof(application_data)))\n      {\n         fill_pathname_join_special(conf_path, application_data,\n               FILE_PATH_MAIN_CONFIG, sizeof(conf_path));\n         conf = config_file_new_from_path_to_string(conf_path);\n      }\n   }\n\n   if (!conf)\n   {\n      bool saved = false;\n\n      /* Try to create a new config file. */\n      conf = config_file_new_alloc();\n\n      if (conf)\n      {\n         /* Since this is a clean config file, we can\n          * safely use config_save_on_exit. */\n         fill_pathname_resolve_relative(conf_path, app_path,\n               FILE_PATH_MAIN_CONFIG, sizeof(conf_path));\n         config_set_string(conf, \"config_save_on_exit\", \"true\");\n         saved = config_file_write(conf, conf_path, true);\n      }\n\n      if (!saved)\n      {\n         /* WARN here to make sure user has a good chance of seeing it. */\n         RARCH_ERR(\"[Config]: Failed to create new config file in: \\\"%s\\\".\\n\",\n               conf_path);\n         goto error;\n      }\n\n      RARCH_WARN(\"[Config]: Created new config file in: \\\"%s\\\".\\n\", conf_path);\n   }\n#elif defined(OSX)\n   if (!fill_pathname_application_data(application_data,\n            sizeof(application_data)))\n      goto error;\n\n   /* Group config file with menu configs, remaps, etc: */\n   strlcat(application_data, \"/config\", sizeof(application_data));\n\n   path_mkdir(application_data);\n\n   fill_pathname_join_special(conf_path, application_data,\n         FILE_PATH_MAIN_CONFIG, sizeof(conf_path));\n\n   if (!(conf = config_file_new_from_path_to_string(conf_path)))\n   {\n      bool saved = false;\n\n      if ((conf = config_file_new_alloc()))\n      {\n         config_set_string(conf, \"config_save_on_exit\", \"true\");\n         saved = config_file_write(conf, conf_path, true);\n      }\n\n      if (!saved)\n      {\n         /* WARN here to make sure user has a good chance of seeing it. */\n         RARCH_ERR(\"Failed to create new config file in: \\\"%s\\\".\\n\",\n               conf_path);\n         goto error;\n      }\n\n      RARCH_WARN(\"Created new config file in: \\\"%s\\\".\\n\", conf_path);\n   }\n#elif !defined(RARCH_CONSOLE)\n   bool has_application_data =\n      fill_pathname_application_data(application_data,\n            sizeof(application_data));\n\n   if (has_application_data)\n   {\n      fill_pathname_join_special(conf_path, application_data,\n            FILE_PATH_MAIN_CONFIG, sizeof(conf_path));\n      RARCH_LOG(\"[Config]: Looking for config in: \\\"%s\\\".\\n\", conf_path);\n      conf = config_file_new_from_path_to_string(conf_path);\n   }\n\n   /* Fallback to $HOME/.retroarch.cfg. */\n   if (!conf && getenv(\"HOME\"))\n   {\n      fill_pathname_join_special(conf_path, getenv(\"HOME\"),\n            \".\" FILE_PATH_MAIN_CONFIG, sizeof(conf_path));\n      RARCH_LOG(\"[Config]: Looking for config in: \\\"%s\\\".\\n\", conf_path);\n      conf = config_file_new_from_path_to_string(conf_path);\n   }\n\n   if (!conf && has_application_data)\n   {\n      char basedir[DIR_MAX_LENGTH];\n      /* Try to create a new config file. */\n      fill_pathname_basedir(basedir, application_data, sizeof(basedir));\n      fill_pathname_join_special(conf_path, application_data,\n            FILE_PATH_MAIN_CONFIG, sizeof(conf_path));\n\n      if ((path_mkdir(basedir)))\n      {\n         char skeleton_conf[PATH_MAX_LENGTH];\n         bool saved          = false;\n         /* Build a retroarch.cfg path from the\n          * global config directory (/etc). */\n         fill_pathname_join_special(skeleton_conf, GLOBAL_CONFIG_DIR,\n            FILE_PATH_MAIN_CONFIG, sizeof(skeleton_conf));\n         if ((conf = config_file_new_from_path_to_string(skeleton_conf)))\n            RARCH_WARN(\"[Config]: Using skeleton config \\\"%s\\\" as base for a new config file.\\n\", skeleton_conf);\n         else\n            conf = config_file_new_alloc();\n\n         if (conf)\n         {\n            /* Since this is a clean config file, we can\n             * safely use config_save_on_exit. */\n            config_set_string(conf, \"config_save_on_exit\", \"true\");\n            saved = config_file_write(conf, conf_path, true);\n         }\n\n         if (!saved)\n         {\n            /* WARN here to make sure user has a good chance of seeing it. */\n            RARCH_ERR(\"[Config]: Failed to create new config file in: \\\"%s\\\".\\n\",\n                  conf_path);\n            goto error;\n         }\n\n         RARCH_WARN(\"[Config]: Created new config file in: \\\"%s\\\".\\n\",\n               conf_path);\n      }\n   }\n#endif\n\n   if (!conf)\n      goto error;\n\n   path_set(RARCH_PATH_CONFIG, conf_path);\n\n   return conf;\n\nerror:\n   if (conf)\n      config_file_free(conf);\n   return NULL;\n}\n\n#ifdef RARCH_CONSOLE\nstatic void video_driver_load_settings(global_t *global,\n      config_file_t *conf)\n{\n   bool               tmp_bool = false;\n\n   CONFIG_GET_INT_BASE(conf, global,\n         console.screen.gamma_correction, \"gamma_correction\");\n\n   if (config_get_bool(conf, \"flicker_filter_enable\",\n         &tmp_bool))\n      global->console.flickerfilter_enable = tmp_bool;\n\n   if (config_get_bool(conf, \"soft_filter_enable\",\n         &tmp_bool))\n      global->console.softfilter_enable = tmp_bool;\n\n   CONFIG_GET_INT_BASE(conf, global,\n         console.screen.soft_filter_index,\n         \"soft_filter_index\");\n   CONFIG_GET_INT_BASE(conf, global,\n         console.screen.resolutions.current.id,\n         \"current_resolution_id\");\n   CONFIG_GET_INT_BASE(conf, global,\n         console.screen.flicker_filter_index,\n         \"flicker_filter_index\");\n}\n#endif\n\nstatic void check_verbosity_settings(config_file_t *conf,\n      settings_t *settings)\n{\n   unsigned tmp_uint                               = 0;\n   bool tmp_bool                                   = false;\n\n   /* Make sure log_to_file is true if 'log-file' command line argument was used. */\n   if (retroarch_override_setting_is_set(RARCH_OVERRIDE_SETTING_LOG_TO_FILE, NULL))\n   {\n      configuration_set_bool(settings, settings->bools.log_to_file, true);\n   }\n   else\n   {\n      /* Make sure current 'log_to_file' is effective */\n      if (config_get_bool(conf, \"log_to_file\", &tmp_bool))\n         configuration_set_bool(settings, settings->bools.log_to_file, tmp_bool);\n   }\n\n   /* Set frontend log level */\n   if (config_get_uint(conf, \"frontend_log_level\", &tmp_uint))\n      verbosity_set_log_level(tmp_uint);\n\n   /* Set verbosity according to config only if command line argument was not used. */\n   if (retroarch_override_setting_is_set(RARCH_OVERRIDE_SETTING_VERBOSITY, NULL))\n   {\n      verbosity_enable();\n   }\n   else\n   {\n      if (config_get_bool(conf, \"log_verbosity\", &tmp_bool))\n      {\n         if (tmp_bool)\n            verbosity_enable();\n         else\n            verbosity_disable();\n      }\n   }\n}\n\n/**\n * config_load:\n * @path                : path to be read from.\n * @set_defaults        : set default values first before\n *                        reading the values from the config file\n *\n * Loads a config file and reads all the values into memory.\n *\n */\nstatic bool config_load_file(global_t *global,\n      const char *path, settings_t *settings)\n{\n   unsigned i;\n   char tmp_str[PATH_MAX_LENGTH];\n   static bool first_load                          = true;\n   bool without_overrides                          = false;\n   unsigned msg_color                              = 0;\n   char *save                                      = NULL;\n   char *override_username                         = NULL;\n   const char *path_config                         = NULL;\n   runloop_state_t *runloop_st                     = runloop_state_get_ptr();\n   int bool_settings_size                          = sizeof(settings->bools)  / sizeof(settings->bools.placeholder);\n   int float_settings_size                         = sizeof(settings->floats) / sizeof(settings->floats.placeholder);\n   int int_settings_size                           = sizeof(settings->ints)   / sizeof(settings->ints.placeholder);\n   int uint_settings_size                          = sizeof(settings->uints)  / sizeof(settings->uints.placeholder);\n   int size_settings_size                          = sizeof(settings->sizes)  / sizeof(settings->sizes.placeholder);\n   int array_settings_size                         = sizeof(settings->arrays) / sizeof(settings->arrays.placeholder);\n   int path_settings_size                          = sizeof(settings->paths)  / sizeof(settings->paths.placeholder);\n   struct config_bool_setting *bool_settings       = NULL;\n   struct config_float_setting *float_settings     = NULL;\n   struct config_int_setting *int_settings         = NULL;\n   struct config_uint_setting *uint_settings       = NULL;\n   struct config_size_setting *size_settings       = NULL;\n   struct config_array_setting *array_settings     = NULL;\n   struct config_path_setting *path_settings       = NULL;\n   config_file_t *conf                             = NULL;\n   uint16_t rarch_flags                            = retroarch_get_flags();\n\n   tmp_str[0]                                      = '\\0';\n\n   /* Override config comparison must be compared to config before overrides */\n   if (string_is_equal(path, \"without-overrides\"))\n   {\n      path              = path_get(RARCH_PATH_CONFIG);\n      without_overrides = true;\n   }\n\n   conf = (path) ? config_file_new_from_path_to_string(path) : open_default_config_file();\n\n#if TARGET_OS_TV\n   if (!conf && path && string_is_equal(path, path_get(RARCH_PATH_CONFIG)))\n   {\n      /* Sometimes the OS decides it needs to reclaim disk space\n       * by emptying the cache, which is the only disk space we\n       * have access to, other than NSUserDefaults. */\n      conf = open_userdefaults_config_file();\n   }\n#endif\n\n   if (!conf)\n   {\n      first_load = false;\n      if (!path)\n         return true;\n      return false;\n   }\n\n   bool_settings    = populate_settings_bool  (settings, &bool_settings_size);\n   float_settings   = populate_settings_float (settings, &float_settings_size);\n   int_settings     = populate_settings_int   (settings, &int_settings_size);\n   uint_settings    = populate_settings_uint  (settings, &uint_settings_size);\n   size_settings    = populate_settings_size  (settings, &size_settings_size);\n   array_settings   = populate_settings_array (settings, &array_settings_size);\n   path_settings    = populate_settings_path  (settings, &path_settings_size);\n\n   /* Initialize verbosity settings */\n   check_verbosity_settings(conf, settings);\n\n   if (!first_load)\n   {\n      if (!path)\n         RARCH_LOG(\"[Config]: Loading default config.\\n\");\n      else\n         RARCH_LOG(\"[Config]: Loading config: \\\"%s\\\".\\n\", path);\n   }\n\n   if (!path_is_empty(RARCH_PATH_CONFIG_APPEND))\n   {\n      /* Don't destroy append_config_path, store in temporary\n       * variable. */\n      char tmp_append_path[PATH_MAX_LENGTH];\n      const char *extra_path = NULL;\n      strlcpy(tmp_append_path, path_get(RARCH_PATH_CONFIG_APPEND),\n            sizeof(tmp_append_path));\n      extra_path = strtok_r(tmp_append_path, \"|\", &save);\n\n      while (extra_path)\n      {\n         bool result = config_append_file(conf, extra_path);\n\n         if (!first_load)\n         {\n            RARCH_LOG(\"[Config]: Appending config: \\\"%s\\\".\\n\", extra_path);\n\n            if (!result)\n               RARCH_ERR(\"[Config]: Failed to append config: \\\"%s\\\".\\n\", extra_path);\n         }\n         extra_path = strtok_r(NULL, \"|\", &save);\n      }\n\n      /* Re-check verbosity settings */\n      check_verbosity_settings(conf, settings);\n   }\n\n   if (!path_is_empty(RARCH_PATH_CONFIG_OVERRIDE) && !without_overrides)\n   {\n      /* Don't destroy append_config_path, store in temporary\n       * variable. */\n      char tmp_append_path[PATH_MAX_LENGTH];\n      const char *extra_path = NULL;\n#ifdef HAVE_OVERLAY\n      char old_overlay_path[PATH_MAX_LENGTH], new_overlay_path[PATH_MAX_LENGTH];\n      config_get_path(conf, \"input_overlay\", old_overlay_path, sizeof(old_overlay_path));\n#endif\n      strlcpy(tmp_append_path, path_get(RARCH_PATH_CONFIG_OVERRIDE),\n            sizeof(tmp_append_path));\n      extra_path = strtok_r(tmp_append_path, \"|\", &save);\n\n      while (extra_path)\n      {\n         bool result = config_append_file(conf, extra_path);\n\n         if (!first_load)\n         {\n            RARCH_LOG(\"[Config]: Appending override config: \\\"%s\\\".\\n\", extra_path);\n\n            if (!result)\n               RARCH_ERR(\"[Config]: Failed to append override config: \\\"%s\\\".\\n\", extra_path);\n         }\n         extra_path = strtok_r(NULL, \"|\", &save);\n      }\n\n      /* Re-check verbosity settings */\n      check_verbosity_settings(conf, settings);\n#ifdef HAVE_OVERLAY\n      config_get_path(conf, \"input_overlay\", new_overlay_path, sizeof(new_overlay_path));\n      if (!string_is_equal(old_overlay_path, new_overlay_path))\n         retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_OVERLAY_PRESET, NULL);\n#endif\n   }\n\n#if 0\n   if (verbosity_is_enabled())\n   {\n      RARCH_LOG_OUTPUT(\"=== Config ===\\n\");\n      config_file_dump_all(conf);\n      RARCH_LOG_OUTPUT(\"=== Config end ===\\n\");\n   }\n#endif\n\n   /* Overrides */\n\n   if (rarch_flags & RARCH_FLAGS_HAS_SET_USERNAME)\n      override_username = strdup(settings->paths.username);\n\n   /* Boolean settings */\n\n   for (i = 0; i < (unsigned)bool_settings_size; i++)\n   {\n      bool tmp = false;\n      if (config_get_bool(conf, bool_settings[i].ident, &tmp))\n         *bool_settings[i].ptr = tmp;\n   }\n\n#ifdef HAVE_NETWORKGAMEPAD\n   {\n      char tmp[64];\n      size_t _len = strlcpy(tmp, \"network_remote_enable_user_p\", sizeof(tmp));\n      for (i = 0; i < MAX_USERS; i++)\n      {\n         bool tmp_bool = false;\n         snprintf(tmp + _len, sizeof(tmp) - _len, \"%u\", i + 1);\n         if (config_get_bool(conf, tmp, &tmp_bool))\n            configuration_set_bool(settings,\n                  settings->bools.network_remote_enable_user[i], tmp_bool);\n      }\n   }\n#endif\n\n   /* Integer settings */\n\n   for (i = 0; i < (unsigned)int_settings_size; i++)\n   {\n      int tmp = 0;\n      if (config_get_int(conf, int_settings[i].ident, &tmp))\n         *int_settings[i].ptr = tmp;\n   }\n\n   for (i = 0; i < (unsigned)uint_settings_size; i++)\n   {\n      int tmp = 0;\n      if (config_get_int(conf, uint_settings[i].ident, &tmp))\n         *uint_settings[i].ptr = tmp;\n   }\n\n   for (i = 0; i < (unsigned)size_settings_size; i++)\n   {\n      size_t tmp = 0;\n      if (config_get_size_t(conf, size_settings[i].ident, &tmp))\n         *size_settings[i].ptr = tmp;\n      /* Special case for rewind_buffer_size - need to convert\n       * low values to what they were\n       * intended to be based on the default value in config.def.h\n       * If the value is less than 10000 then multiple by 1MB because if\n       * the retroarch.cfg\n       * file contains rewind_buffer_size = \"100\",\n       * then that ultimately gets interpreted as\n       * 100MB, so ensure the internal values represent that.*/\n      if (string_is_equal(size_settings[i].ident, \"rewind_buffer_size\"))\n         if (*size_settings[i].ptr < 10000)\n            *size_settings[i].ptr  = *size_settings[i].ptr * 1024 * 1024;\n   }\n\n   {\n      char prefix[64];\n      size_t _len    = strlcpy(prefix, \"input_player\", sizeof(prefix));\n      size_t old_len = _len;\n      for (i = 0; i < MAX_USERS; i++)\n      {\n         _len  = old_len;\n         _len += snprintf(prefix + _len, sizeof(prefix) - _len, \"%u\", i + 1);\n\n         strlcpy(prefix + _len, \"_mouse_index\", sizeof(prefix) - _len);\n         CONFIG_GET_INT_BASE(conf, settings, uints.input_mouse_index[i], prefix);\n\n         strlcpy(prefix + _len, \"_joypad_index\", sizeof(prefix) - _len);\n         CONFIG_GET_INT_BASE(conf, settings, uints.input_joypad_index[i], prefix);\n\n         strlcpy(prefix + _len, \"_analog_dpad_mode\", sizeof(prefix) - _len);\n         CONFIG_GET_INT_BASE(conf, settings, uints.input_analog_dpad_mode[i], prefix);\n\n         strlcpy(prefix + _len, \"_device_reservation_type\", sizeof(prefix) - _len);\n         CONFIG_GET_INT_BASE(conf, settings, uints.input_device_reservation_type[i], prefix);\n      }\n   }\n\n   /* LED map for use by the led driver */\n   for (i = 0; i < MAX_LEDS; i++)\n   {\n      char buf[64];\n\n      buf[0] = '\\0';\n\n      snprintf(buf, sizeof(buf), \"led%u_map\", i + 1);\n\n      /* TODO/FIXME - change of sign - led_map is unsigned */\n      settings->uints.led_map[i] = -1;\n\n      CONFIG_GET_INT_BASE(conf, settings, uints.led_map[i], buf);\n   }\n\n   /* Hexadecimal settings  */\n\n   if (config_get_hex(conf, \"video_message_color\", &msg_color))\n   {\n      settings->floats.video_msg_color_r = ((msg_color >> 16) & 0xff) / 255.0f;\n      settings->floats.video_msg_color_g = ((msg_color >>  8) & 0xff) / 255.0f;\n      settings->floats.video_msg_color_b = ((msg_color >>  0) & 0xff) / 255.0f;\n   }\n\n   /* Float settings */\n   for (i = 0; i < (unsigned)float_settings_size; i++)\n   {\n      float tmp = 0.0f;\n      if (config_get_float(conf, float_settings[i].ident, &tmp))\n         *float_settings[i].ptr = tmp;\n   }\n\n   /* Array settings  */\n   for (i = 0; i < (unsigned)array_settings_size; i++)\n   {\n      if (array_settings[i].flags & CFG_BOOL_FLG_HANDLE)\n         config_get_array(conf, array_settings[i].ident,\n               array_settings[i].ptr, PATH_MAX_LENGTH);\n   }\n\n   /* Path settings  */\n   for (i = 0; i < (unsigned)path_settings_size; i++)\n   {\n      if (!(path_settings[i].flags & CFG_BOOL_FLG_HANDLE))\n         continue;\n      if (config_get_path(conf, path_settings[i].ident, tmp_str, sizeof(tmp_str)))\n         strlcpy(path_settings[i].ptr, tmp_str, PATH_MAX_LENGTH);\n   }\n\n#if !IOS\n   if (config_get_path(conf, \"libretro_directory\", tmp_str, sizeof(tmp_str)))\n      configuration_set_string(settings,\n            settings->paths.directory_libretro, tmp_str);\n#endif\n\n#ifdef RARCH_CONSOLE\n   if (conf)\n      video_driver_load_settings(global, conf);\n#endif\n\n   /* Post-settings load */\n\n   if (     (rarch_flags & RARCH_FLAGS_HAS_SET_USERNAME)\n         && (override_username))\n   {\n      configuration_set_string(settings,\n            settings->paths.username,\n            override_username);\n      free(override_username);\n   }\n\n   if (settings->uints.video_hard_sync_frames > MAXIMUM_HARD_SYNC_FRAMES)\n      settings->uints.video_hard_sync_frames = MAXIMUM_HARD_SYNC_FRAMES;\n\n   if (settings->uints.video_max_swapchain_images < MINIMUM_MAX_SWAPCHAIN_IMAGES)\n      settings->uints.video_max_swapchain_images = MINIMUM_MAX_SWAPCHAIN_IMAGES;\n   if (settings->uints.video_max_swapchain_images > MAXIMUM_MAX_SWAPCHAIN_IMAGES)\n      settings->uints.video_max_swapchain_images = MAXIMUM_MAX_SWAPCHAIN_IMAGES;\n\n   if (settings->uints.video_frame_delay > MAXIMUM_FRAME_DELAY)\n      settings->uints.video_frame_delay = MAXIMUM_FRAME_DELAY;\n\n   settings->uints.video_swap_interval = MAX(settings->uints.video_swap_interval, 0);\n   settings->uints.video_swap_interval = MIN(settings->uints.video_swap_interval, 4);\n\n   audio_set_float(AUDIO_ACTION_VOLUME_GAIN, settings->floats.audio_volume);\n#ifdef HAVE_AUDIOMIXER\n   audio_set_float(AUDIO_ACTION_MIXER_VOLUME_GAIN, settings->floats.audio_mixer_volume);\n#endif\n\n#ifdef HAVE_WASAPI\n   {\n      /* Migrate from old deprecated negative value */\n      int wasapi_sh_buffer_length = settings->uints.audio_wasapi_sh_buffer_length;\n      if (wasapi_sh_buffer_length < 0)\n         settings->uints.audio_wasapi_sh_buffer_length = 0;\n   }\n#endif\n\n   /* MIDI fallback for old OFF-string */\n   if (string_is_equal(settings->arrays.midi_input, \"Off\"))\n      configuration_set_string(settings,\n            settings->arrays.midi_input,\n            DEFAULT_MIDI_INPUT);\n   if (string_is_equal(settings->arrays.midi_output, \"Off\"))\n      configuration_set_string(settings,\n            settings->arrays.midi_output,\n            DEFAULT_MIDI_OUTPUT);\n\n   path_config = path_get(RARCH_PATH_CONFIG);\n\n   if (string_is_empty(settings->paths.path_content_favorites))\n      strlcpy(settings->paths.directory_content_favorites, \"default\",\n            sizeof(settings->paths.directory_content_favorites));\n\n   if (     string_is_empty(settings->paths.directory_content_favorites)\n         || string_is_equal(settings->paths.directory_content_favorites, \"default\"))\n      fill_pathname_resolve_relative(\n            settings->paths.path_content_favorites,\n            path_config,\n            FILE_PATH_CONTENT_FAVORITES,\n            sizeof(settings->paths.path_content_favorites));\n   else\n      fill_pathname_join_special(\n            settings->paths.path_content_favorites,\n            settings->paths.directory_content_favorites,\n            FILE_PATH_CONTENT_FAVORITES,\n            sizeof(settings->paths.path_content_favorites));\n\n   if (string_is_empty(settings->paths.path_content_history))\n      strlcpy(settings->paths.directory_content_history, \"default\",\n            sizeof(settings->paths.directory_content_history));\n\n   if (     string_is_empty(settings->paths.directory_content_history)\n         || string_is_equal(settings->paths.directory_content_history, \"default\"))\n      fill_pathname_resolve_relative(\n            settings->paths.path_content_history,\n            path_config,\n            FILE_PATH_CONTENT_HISTORY,\n            sizeof(settings->paths.path_content_history));\n   else\n      fill_pathname_join_special(\n            settings->paths.path_content_history,\n            settings->paths.directory_content_history,\n            FILE_PATH_CONTENT_HISTORY,\n            sizeof(settings->paths.path_content_history));\n\n   if (string_is_empty(settings->paths.path_content_image_history))\n      strlcpy(settings->paths.directory_content_image_history, \"default\",\n            sizeof(settings->paths.directory_content_image_history));\n\n   if (     string_is_empty(settings->paths.directory_content_image_history)\n         || string_is_equal(settings->paths.directory_content_image_history, \"default\"))\n      fill_pathname_resolve_relative(\n            settings->paths.path_content_image_history,\n            path_config,\n            FILE_PATH_CONTENT_IMAGE_HISTORY,\n            sizeof(settings->paths.path_content_image_history));\n   else\n      fill_pathname_join_special(\n            settings->paths.path_content_image_history,\n            settings->paths.directory_content_image_history,\n            FILE_PATH_CONTENT_IMAGE_HISTORY,\n            sizeof(settings->paths.path_content_image_history));\n\n   if (string_is_empty(settings->paths.path_content_music_history))\n      strlcpy(settings->paths.directory_content_music_history, \"default\",\n            sizeof(settings->paths.directory_content_music_history));\n\n   if (     string_is_empty(settings->paths.directory_content_music_history)\n         || string_is_equal(settings->paths.directory_content_music_history, \"default\"))\n      fill_pathname_resolve_relative(\n            settings->paths.path_content_music_history,\n            path_config,\n            FILE_PATH_CONTENT_MUSIC_HISTORY,\n            sizeof(settings->paths.path_content_music_history));\n   else\n      fill_pathname_join_special(\n            settings->paths.path_content_music_history,\n            settings->paths.directory_content_music_history,\n            FILE_PATH_CONTENT_MUSIC_HISTORY,\n            sizeof(settings->paths.path_content_music_history));\n\n   if (string_is_empty(settings->paths.path_content_video_history))\n      strlcpy(settings->paths.directory_content_video_history, \"default\",\n            sizeof(settings->paths.directory_content_video_history));\n\n   if (     string_is_empty(settings->paths.directory_content_video_history)\n         || string_is_equal(settings->paths.directory_content_video_history, \"default\"))\n      fill_pathname_resolve_relative(\n            settings->paths.path_content_video_history,\n            path_config,\n            FILE_PATH_CONTENT_VIDEO_HISTORY,\n            sizeof(settings->paths.path_content_video_history));\n   else\n      fill_pathname_join_special(\n            settings->paths.path_content_video_history,\n            settings->paths.directory_content_video_history,\n            FILE_PATH_CONTENT_VIDEO_HISTORY,\n            sizeof(settings->paths.path_content_video_history));\n\n   if (!string_is_empty(settings->paths.directory_screenshot))\n   {\n      if (string_is_equal(settings->paths.directory_screenshot, \"default\"))\n         *settings->paths.directory_screenshot = '\\0';\n      else if (!path_is_directory(settings->paths.directory_screenshot))\n      {\n         RARCH_WARN(\"[Config]: 'screenshot_directory' is not an existing directory, ignoring..\\n\");\n         *settings->paths.directory_screenshot = '\\0';\n      }\n   }\n\n#if defined(__APPLE__) && defined(OSX)\n   if (     ((frontend_driver_get_cpu_architecture() == FRONTEND_ARCH_X86_64) &&\n            string_ends_with(settings->paths.network_buildbot_url, \"/arm64/latest/\"))\n         || ((frontend_driver_get_cpu_architecture() == FRONTEND_ARCH_ARMV8) &&\n            string_ends_with(settings->paths.network_buildbot_url, \"/x86_64/latest/\")))\n      /* Wrong architecture, set it back */\n      configuration_set_string(settings,\n            settings->paths.network_buildbot_url, DEFAULT_BUILDBOT_SERVER_URL);\n#endif\n\n   if (string_is_equal(settings->paths.path_menu_wallpaper, \"default\"))\n      *settings->paths.path_menu_wallpaper = '\\0';\n   if (string_is_equal(settings->paths.path_rgui_theme_preset, \"default\"))\n      *settings->paths.path_rgui_theme_preset = '\\0';\n   if (string_is_equal(settings->paths.directory_video_shader, \"default\"))\n      *settings->paths.directory_video_shader = '\\0';\n   if (string_is_equal(settings->paths.directory_video_filter, \"default\"))\n      *settings->paths.directory_video_filter = '\\0';\n   if (string_is_equal(settings->paths.directory_audio_filter, \"default\"))\n      *settings->paths.directory_audio_filter = '\\0';\n   if (string_is_equal(settings->paths.directory_core_assets, \"default\"))\n      *settings->paths.directory_core_assets = '\\0';\n   if (string_is_equal(settings->paths.directory_assets, \"default\"))\n      *settings->paths.directory_assets = '\\0';\n#ifdef _3DS\n   if (string_is_equal(settings->paths.directory_bottom_assets, \"default\"))\n      configuration_set_string(settings,\n            settings->paths.directory_bottom_assets,\n            g_defaults.dirs[DEFAULT_DIR_BOTTOM_ASSETS]);\n#endif\n   if (string_is_equal(settings->paths.directory_dynamic_wallpapers, \"default\"))\n      *settings->paths.directory_dynamic_wallpapers = '\\0';\n   if (string_is_equal(settings->paths.directory_thumbnails, \"default\"))\n      *settings->paths.directory_thumbnails = '\\0';\n   if (string_is_equal(settings->paths.directory_playlist, \"default\"))\n      *settings->paths.directory_playlist = '\\0';\n   if (string_is_equal(settings->paths.directory_content_favorites, \"default\"))\n      *settings->paths.directory_content_favorites = '\\0';\n   if (string_is_equal(settings->paths.directory_content_history, \"default\"))\n      *settings->paths.directory_content_history = '\\0';\n   if (string_is_equal(settings->paths.directory_content_image_history, \"default\"))\n      *settings->paths.directory_content_image_history = '\\0';\n   if (string_is_equal(settings->paths.directory_content_music_history, \"default\"))\n      *settings->paths.directory_content_music_history = '\\0';\n   if (string_is_equal(settings->paths.directory_content_video_history, \"default\"))\n      *settings->paths.directory_content_video_history = '\\0';\n   if (string_is_equal(settings->paths.directory_runtime_log, \"default\"))\n      *settings->paths.directory_runtime_log = '\\0';\n#ifdef HAVE_MENU\n   if (string_is_equal(settings->paths.directory_menu_content, \"default\"))\n      *settings->paths.directory_menu_content = '\\0';\n   if (string_is_equal(settings->paths.directory_menu_config, \"default\"))\n      *settings->paths.directory_menu_config = '\\0';\n#endif\n#ifdef HAVE_OVERLAY\n   if (string_is_equal(settings->paths.directory_overlay, \"default\"))\n      *settings->paths.directory_overlay = '\\0';\n   if (string_is_equal(settings->paths.directory_osk_overlay, \"default\"))\n      *settings->paths.directory_osk_overlay = '\\0';\n#endif\n   if (string_is_equal(settings->paths.directory_system, \"default\"))\n      *settings->paths.directory_system = '\\0';\n\n   /* Log directory is a special case, since it must contain\n    * a valid path as soon as possible - if config file\n    * value is 'default' must copy g_defaults.dirs[DEFAULT_DIR_LOGS]\n    * directly... */\n   if (string_is_equal(settings->paths.log_dir, \"default\"))\n   {\n      if (!string_is_empty(g_defaults.dirs[DEFAULT_DIR_LOGS]))\n      {\n         configuration_set_string(settings,\n               settings->paths.log_dir,\n               g_defaults.dirs[DEFAULT_DIR_LOGS]);\n      }\n      else\n         *settings->paths.log_dir = '\\0';\n   }\n\n   if (settings->floats.slowmotion_ratio < 1.0f)\n      configuration_set_float(settings, settings->floats.slowmotion_ratio, 1.0f);\n\n   /* Sanitize fastforward_ratio value - previously range was -1\n    * and up (with 0 being skipped) */\n   if (settings->floats.fastforward_ratio < 0.0f)\n      configuration_set_float(settings, settings->floats.fastforward_ratio, 0.0f);\n\n#ifdef HAVE_CHEEVOS\n   if (!string_is_empty(settings->arrays.cheevos_leaderboards_enable))\n   {\n      if (string_is_equal(settings->arrays.cheevos_leaderboards_enable, \"true\"))\n      {\n         settings->bools.cheevos_visibility_lboard_start    = true;\n         settings->bools.cheevos_visibility_lboard_submit   = true;\n         settings->bools.cheevos_visibility_lboard_cancel   = true;\n         settings->bools.cheevos_visibility_lboard_trackers = true;\n      }\n      else if (string_is_equal(settings->arrays.cheevos_leaderboards_enable, \"trackers\"))\n      {\n         settings->bools.cheevos_visibility_lboard_start    = false;\n         settings->bools.cheevos_visibility_lboard_submit   = true;\n         settings->bools.cheevos_visibility_lboard_cancel   = false;\n         settings->bools.cheevos_visibility_lboard_trackers = true;\n      }\n      else if (string_is_equal(settings->arrays.cheevos_leaderboards_enable, \"notifications\"))\n      {\n         settings->bools.cheevos_visibility_lboard_start    = true;\n         settings->bools.cheevos_visibility_lboard_submit   = true;\n         settings->bools.cheevos_visibility_lboard_cancel   = true;\n         settings->bools.cheevos_visibility_lboard_trackers = false;\n      }\n      else\n      {\n         settings->bools.cheevos_visibility_lboard_start    = false;\n         settings->bools.cheevos_visibility_lboard_submit   = false;\n         settings->bools.cheevos_visibility_lboard_cancel   = false;\n         settings->bools.cheevos_visibility_lboard_trackers = false;\n      }\n      settings->arrays.cheevos_leaderboards_enable[0]       = '\\0';\n   }\n#endif\n\n#ifdef HAVE_LAKKA\n   configuration_set_bool(settings,\n         settings->bools.ssh_enable, filestream_exists(LAKKA_SSH_PATH));\n   configuration_set_bool(settings,\n         settings->bools.samba_enable, filestream_exists(LAKKA_SAMBA_PATH));\n   configuration_set_bool(settings,\n         settings->bools.bluetooth_enable, filestream_exists(LAKKA_BLUETOOTH_PATH));\n#endif\n\n   if (    !retroarch_override_setting_is_set(RARCH_OVERRIDE_SETTING_SAVE_PATH, NULL)\n         && config_get_path(conf, \"savefile_directory\", tmp_str, sizeof(tmp_str)))\n   {\n      if (string_is_equal(tmp_str, \"default\"))\n         dir_set(RARCH_DIR_SAVEFILE, g_defaults.dirs[DEFAULT_DIR_SRAM]);\n      else if (path_is_directory(tmp_str))\n      {\n         dir_set(RARCH_DIR_SAVEFILE, tmp_str);\n\n         strlcpy(runloop_st->name.savefile, tmp_str,\n               sizeof(runloop_st->name.savefile));\n         fill_pathname_dir(runloop_st->name.savefile,\n               path_get(RARCH_PATH_BASENAME),\n               FILE_PATH_SRM_EXTENSION,\n               sizeof(runloop_st->name.savefile));\n      }\n      else\n         RARCH_WARN(\"[Config]: 'savefile_directory' is not a directory, ignoring..\\n\");\n   }\n\n   if (    !retroarch_override_setting_is_set(RARCH_OVERRIDE_SETTING_STATE_PATH, NULL)\n         && config_get_path(conf, \"savestate_directory\", tmp_str, sizeof(tmp_str)))\n   {\n      if (string_is_equal(tmp_str, \"default\"))\n         dir_set(RARCH_DIR_SAVESTATE, g_defaults.dirs[DEFAULT_DIR_SAVESTATE]);\n      else if (path_is_directory(tmp_str))\n      {\n         dir_set(RARCH_DIR_SAVESTATE, tmp_str);\n\n         strlcpy(runloop_st->name.savestate, tmp_str,\n               sizeof(runloop_st->name.savestate));\n         fill_pathname_dir(runloop_st->name.savestate,\n               path_get(RARCH_PATH_BASENAME),\n               \".state\",\n               sizeof(runloop_st->name.savestate));\n         strlcpy(runloop_st->name.replay, tmp_str,\n               sizeof(runloop_st->name.replay));\n         fill_pathname_dir(runloop_st->name.replay,\n               path_get(RARCH_PATH_BASENAME),\n               \".replay\",\n               sizeof(runloop_st->name.replay));\n      }\n      else\n         RARCH_WARN(\"[Config]: 'savestate_directory' is not a directory, ignoring..\\n\");\n   }\n\n   config_read_keybinds_conf(conf);\n\n#if defined(HAVE_MENU) && defined(HAVE_RGUI)\n   if (!check_menu_driver_compatibility(settings))\n      configuration_set_string(settings,\n            settings->arrays.menu_driver, \"rgui\");\n#endif\n\n#ifdef HAVE_LIBNX\n   /* Apply initial clocks */\n   extern void libnx_apply_overclock();\n   libnx_apply_overclock();\n#endif\n\n#ifdef HAVE_LAKKA_SWITCH\n   FILE* f = fopen(SWITCH_OC_TOGGLE_PATH, \"w\");\n   if (settings->bools.switch_oc)\n      fprintf(f, \"1\\n\");\n   else\n      fprintf(f, \"0\\n\");\n   fclose(f);\n\n   if (settings->bools.switch_cec)\n   {\n      FILE* f = fopen(SWITCH_CEC_TOGGLE_PATH, \"w\");\n      fprintf(f, \"\\n\");\n      fclose(f);\n   }\n   else\n      filestream_delete(SWITCH_CEC_TOGGLE_PATH);\n\n   if (settings->bools.bluetooth_ertm_disable)\n   {\n      FILE* f = fopen(BLUETOOTH_ERTM_TOGGLE_PATH, \"w\");\n      fprintf(f, \"1\\n\");\n      fclose(f);\n   }\n   else\n   {\n      FILE* f = fopen(BLUETOOTH_ERTM_TOGGLE_PATH, \"w\");\n      fprintf(f, \"0\\n\");\n      fclose(f);\n   }\n#endif\n\n   frontend_driver_set_sustained_performance_mode(settings->bools.sustained_performance_mode);\n   recording_driver_update_streaming_url();\n\n   if (!(bool)RHMAP_HAS_STR(conf->entries_map, \"user_language\"))\n      msg_hash_set_uint(MSG_HASH_USER_LANGUAGE, frontend_driver_get_user_language());\n\n   if (frontend_driver_has_gamemode() &&\n         !frontend_driver_set_gamemode(settings->bools.gamemode_enable) &&\n         settings->bools.gamemode_enable)\n   {\n      RARCH_WARN(\"[Config]: GameMode unsupported - disabling..\\n\");\n      configuration_set_bool(settings,\n            settings->bools.gamemode_enable, false);\n   }\n\n   /* If this is the first run of an existing installation\n    * after the independent favourites playlist size limit was\n    * added, set the favourites limit according to the current\n    * history playlist size limit. (Have to do this, otherwise\n    * users with large custom history size limits may lose\n    * favourites entries when updating RetroArch...) */\n   if (    (bool)RHMAP_HAS_STR(conf->entries_map, \"content_history_size\")\n         && !(bool)RHMAP_HAS_STR(conf->entries_map, \"content_favorites_size\"))\n   {\n      if (settings->uints.content_history_size > 999)\n         settings->ints.content_favorites_size = -1;\n      else\n         settings->ints.content_favorites_size = (int)settings->uints.content_history_size;\n   }\n\n   if (conf)\n      config_file_free(conf);\n   if (bool_settings)\n      free(bool_settings);\n   if (int_settings)\n      free(int_settings);\n   if (uint_settings)\n      free(uint_settings);\n   if (float_settings)\n      free(float_settings);\n   if (array_settings)\n      free(array_settings);\n   if (path_settings)\n      free(path_settings);\n   if (size_settings)\n      free(size_settings);\n   first_load = false;\n   return true;\n}\n\n/**\n * config_load_override:\n *\n * Tries to append game-specific and core-specific configuration.\n * These settings will always have precedence, thus this feature\n * can be used to enforce overrides.\n *\n * This function only has an effect if a game-specific or core-specific\n * configuration file exists at respective locations.\n *\n * core-specific: $CONFIG_DIR/$CORE_NAME/$CORE_NAME.cfg\n * fallback:      $CURRENT_CFG_LOCATION/$CORE_NAME/$CORE_NAME.cfg\n *\n * game-specific: $CONFIG_DIR/$CORE_NAME/$ROM_NAME.cfg\n * fallback:      $CURRENT_CFG_LOCATION/$CORE_NAME/$GAME_NAME.cfg\n *\n * Returns: false if there was an error or no action was performed.\n *\n */\nbool config_load_override(void *data)\n{\n   char core_path[PATH_MAX_LENGTH];\n   char game_path[PATH_MAX_LENGTH];\n   char content_path[PATH_MAX_LENGTH];\n   char config_directory[DIR_MAX_LENGTH];\n   bool should_append                     = false;\n   bool show_notification                 = true;\n   rarch_system_info_t *sys_info          = (rarch_system_info_t*)data;\n   const char *core_name                  = sys_info\n      ? sys_info->info.library_name : NULL;\n   const char *rarch_path_basename        = path_get(RARCH_PATH_BASENAME);\n   const char *game_name                  = NULL;\n   settings_t *settings                   = config_st;\n   bool has_content                       = !string_is_empty(rarch_path_basename);\n\n   core_path[0]        = '\\0';\n   game_path[0]        = '\\0';\n   content_path[0]     = '\\0';\n   config_directory[0] = '\\0';\n\n   path_clear(RARCH_PATH_CONFIG_OVERRIDE);\n\n   /* Cannot load an override if we have no core */\n   if (string_is_empty(core_name))\n      return false;\n\n   /* Get base config directory */\n   fill_pathname_application_special(config_directory,\n         sizeof(config_directory),\n         APPLICATION_SPECIAL_DIRECTORY_CONFIG);\n\n   /* Concatenate strings into full paths for core_path,\n    * game_path, content_path */\n   if (has_content)\n   {\n      char content_dir_name[DIR_MAX_LENGTH];\n      fill_pathname_parent_dir_name(content_dir_name,\n            rarch_path_basename, sizeof(content_dir_name));\n      game_name = path_basename_nocompression(rarch_path_basename);\n\n      fill_pathname_join_special_ext(game_path,\n            config_directory, core_name,\n            game_name,\n            \".cfg\",\n            sizeof(game_path));\n\n      fill_pathname_join_special_ext(content_path,\n         config_directory, core_name,\n         content_dir_name,\n         \".cfg\",\n         sizeof(content_path));\n   }\n\n   fill_pathname_join_special_ext(core_path,\n         config_directory, core_name,\n         core_name,\n         \".cfg\",\n         sizeof(core_path));\n\n   /* Prevent \"--appendconfig\" from being ignored */\n   if (!path_is_empty(RARCH_PATH_CONFIG_APPEND))\n   {\n      should_append     = true;\n      show_notification = false;\n   }\n\n   /* per-core overrides */\n   /* Create a new config file from core_path */\n   if (path_is_valid(core_path))\n   {\n\n      RARCH_LOG(\"[Overrides]: Core-specific overrides found at \\\"%s\\\".\\n\",\n            core_path);\n\n      if (should_append && !string_is_empty(path_get(RARCH_PATH_CONFIG_OVERRIDE)))\n      {\n         char tmp_path[PATH_MAX_LENGTH];\n         size_t _len      = strlcpy(tmp_path,\n               path_get(RARCH_PATH_CONFIG_OVERRIDE),\n               sizeof(tmp_path));\n         tmp_path[  _len] = '|';\n         tmp_path[++_len] = '\\0';\n         strlcpy(tmp_path + _len, core_path, sizeof(tmp_path) - _len);\n         path_set(RARCH_PATH_CONFIG_OVERRIDE, tmp_path);\n         RARCH_LOG(\"[Overrides]: Core-specific overrides stacking on top of previous overrides.\\n\");\n      }\n      else\n         path_set(RARCH_PATH_CONFIG_OVERRIDE, core_path);\n\n      should_append     = true;\n      show_notification = true;\n   }\n\n   if (has_content)\n   {\n      /* per-content-dir overrides */\n      /* Create a new config file from content_path */\n      if (path_is_valid(content_path))\n      {\n         RARCH_LOG(\"[Overrides]: Content dir-specific overrides found at \\\"%s\\\".\\n\",\n               content_path);\n\n         if (should_append && !string_is_empty(path_get(RARCH_PATH_CONFIG_OVERRIDE)))\n         {\n            char tmp_path[PATH_MAX_LENGTH];\n            size_t _len      = strlcpy(tmp_path,\n                  path_get(RARCH_PATH_CONFIG_OVERRIDE),\n                  sizeof(tmp_path));\n            tmp_path[  _len] = '|';\n            tmp_path[++_len] = '\\0';\n            strlcpy(tmp_path + _len, content_path, sizeof(tmp_path) - _len);\n            path_set(RARCH_PATH_CONFIG_OVERRIDE, tmp_path);\n            RARCH_LOG(\"[Overrides]: Content dir-specific overrides stacking on top of previous overrides.\\n\");\n         }\n         else\n            path_set(RARCH_PATH_CONFIG_OVERRIDE, content_path);\n\n         should_append     = true;\n         show_notification = true;\n      }\n\n      /* per-game overrides */\n      /* Create a new config file from game_path */\n      if (path_is_valid(game_path))\n      {\n         RARCH_LOG(\"[Overrides]: Game-specific overrides found at \\\"%s\\\".\\n\",\n               game_path);\n\n         if (should_append && !string_is_empty(path_get(RARCH_PATH_CONFIG_OVERRIDE)))\n         {\n            char tmp_path[PATH_MAX_LENGTH];\n            size_t _len      = strlcpy(tmp_path,\n                  path_get(RARCH_PATH_CONFIG_OVERRIDE),\n                  sizeof(tmp_path));\n            tmp_path[  _len] = '|';\n            tmp_path[++_len] = '\\0';\n            strlcpy(tmp_path + _len, game_path, sizeof(tmp_path) - _len);\n            path_set(RARCH_PATH_CONFIG_OVERRIDE, tmp_path);\n            RARCH_LOG(\"[Overrides]: Game-specific overrides stacking on top of previous overrides.\\n\");\n         }\n         else\n            path_set(RARCH_PATH_CONFIG_OVERRIDE, game_path);\n\n         should_append     = true;\n         show_notification = true;\n      }\n   }\n\n   if (!should_append)\n      return false;\n\n   /* Re-load the configuration with any overrides\n    * that might have been found */\n\n   /* Toggle has_save_path to false so it resets */\n   retroarch_override_setting_unset(RARCH_OVERRIDE_SETTING_STATE_PATH, NULL);\n   retroarch_override_setting_unset(RARCH_OVERRIDE_SETTING_SAVE_PATH, NULL);\n\n   if (!config_load_file(global_get_ptr(),\n            path_get(RARCH_PATH_CONFIG), settings))\n      return false;\n\n   if (settings->bools.notification_show_config_override_load\n         && show_notification)\n   {\n      const char *_msg = msg_hash_to_str(MSG_CONFIG_OVERRIDE_LOADED);\n      runloop_msg_queue_push(_msg, strlen(_msg), 1, 100, false, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n   }\n\n   /* Reset save paths. */\n   retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_STATE_PATH, NULL);\n   retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_SAVE_PATH, NULL);\n\n   if (!string_is_empty(path_get(RARCH_PATH_CONFIG_OVERRIDE)))\n      runloop_state_get_ptr()->flags |=  RUNLOOP_FLAG_OVERRIDES_ACTIVE;\n   else\n      runloop_state_get_ptr()->flags &= ~RUNLOOP_FLAG_OVERRIDES_ACTIVE;\n\n   return true;\n}\n\nbool config_load_override_file(const char *config_path)\n{\n   char config_directory[DIR_MAX_LENGTH];\n   bool should_append                     = false;\n   bool show_notification                 = true;\n   settings_t *settings                   = config_st;\n\n   config_directory[0] = '\\0';\n\n   path_clear(RARCH_PATH_CONFIG_OVERRIDE);\n\n   /* Get base config directory */\n   fill_pathname_application_special(config_directory,\n         sizeof(config_directory),\n         APPLICATION_SPECIAL_DIRECTORY_CONFIG);\n\n   if (path_is_valid(config_path))\n   {\n      path_set(RARCH_PATH_CONFIG_OVERRIDE, config_path);\n      should_append = true;\n   }\n\n   if (!should_append)\n      return false;\n\n   /* Re-load the configuration with any overrides\n    * that might have been found */\n\n   /* Toggle has_save_path to false so it resets */\n   retroarch_override_setting_unset(RARCH_OVERRIDE_SETTING_STATE_PATH, NULL);\n   retroarch_override_setting_unset(RARCH_OVERRIDE_SETTING_SAVE_PATH, NULL);\n\n   if (!config_load_file(global_get_ptr(),\n            path_get(RARCH_PATH_CONFIG), settings))\n      return false;\n\n   if (settings->bools.notification_show_config_override_load\n         && show_notification)\n   {\n      const char *_msg = msg_hash_to_str(MSG_CONFIG_OVERRIDE_LOADED);\n      runloop_msg_queue_push(_msg, strlen(_msg), 1, 100, false, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n   }\n\n   /* Reset save paths. */\n   retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_STATE_PATH, NULL);\n   retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_SAVE_PATH, NULL);\n\n   if (!string_is_empty(path_get(RARCH_PATH_CONFIG_OVERRIDE)))\n      runloop_state_get_ptr()->flags |=  RUNLOOP_FLAG_OVERRIDES_ACTIVE;\n   else\n      runloop_state_get_ptr()->flags &= ~RUNLOOP_FLAG_OVERRIDES_ACTIVE;\n\n   return true;\n}\n\n/**\n * config_unload_override:\n *\n * Unloads configuration overrides if overrides are active.\n *\n *\n * Returns: false if there was an error.\n */\nbool config_unload_override(void)\n{\n   settings_t *settings = config_st;\n   bool fullscreen_prev = settings->bools.video_fullscreen;\n   uint32_t flags       = runloop_get_flags();\n\n   runloop_state_get_ptr()->flags &= ~RUNLOOP_FLAG_OVERRIDES_ACTIVE;\n   path_clear(RARCH_PATH_CONFIG_OVERRIDE);\n\n   /* Toggle has_save_path to false so it resets */\n   retroarch_override_setting_unset(RARCH_OVERRIDE_SETTING_STATE_PATH, NULL);\n   retroarch_override_setting_unset(RARCH_OVERRIDE_SETTING_SAVE_PATH, NULL);\n\n   if (!config_load_file(global_get_ptr(),\n            path_get(RARCH_PATH_CONFIG), config_st))\n      return false;\n\n   if (settings->bools.video_fullscreen != fullscreen_prev)\n   {\n      /* This is for 'win32_common.c', so we don't save\n       * fullscreen size and position if we're switching\n       * back to windowed mode.\n       * Might be useful for other devices as well? */\n      if (      settings->bools.video_window_save_positions\n            && !settings->bools.video_fullscreen)\n         settings->flags |= SETTINGS_FLG_SKIP_WINDOW_POSITIONS;\n\n      if (flags & RUNLOOP_FLAG_CORE_RUNNING)\n         command_event(CMD_EVENT_REINIT, NULL);\n   }\n\n   RARCH_LOG(\"[Overrides]: Configuration overrides unloaded, original configuration restored.\\n\");\n\n   /* Reset save paths */\n   retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_STATE_PATH, NULL);\n   retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_SAVE_PATH, NULL);\n\n   return true;\n}\n\n/**\n * config_load_remap:\n *\n * Tries to append game-specific and core-specific remap files.\n *\n * This function only has an effect if a game-specific or core-specific\n * configuration file exists at respective locations.\n *\n * core-specific: $REMAP_DIR/$CORE_NAME/$CORE_NAME.cfg\n * game-specific: $REMAP_DIR/$CORE_NAME/$GAME_NAME.cfg\n *\n * Returns: false if there was an error or no action was performed.\n */\nbool config_load_remap(const char *directory_input_remapping,\n      void *data)\n{\n   /* final path for core-specific configuration (prefix+suffix) */\n   char core_path[PATH_MAX_LENGTH];\n   /* final path for game-specific configuration (prefix+suffix) */\n   char game_path[PATH_MAX_LENGTH];\n   /* final path for content-dir-specific configuration (prefix+suffix) */\n   char content_path[PATH_MAX_LENGTH];\n   char remap_path[PATH_MAX_LENGTH];\n\n   config_file_t *new_conf                = NULL;\n   rarch_system_info_t *sys_info          = (rarch_system_info_t*)data;\n   const char *core_name                  = sys_info ? sys_info->info.library_name : NULL;\n   const char *rarch_path_basename        = path_get(RARCH_PATH_BASENAME);\n   enum msg_hash_enums msg_remap_loaded   = MSG_GAME_REMAP_FILE_LOADED;\n   settings_t *settings                   = config_st;\n   bool notification_show_remap_load      = settings->bools.notification_show_remap_load;\n   unsigned joypad_port                   = settings->uints.input_joypad_index[0];\n   const char *inp_dev_name               = input_config_get_device_display_name(joypad_port);\n   bool sort_remaps_by_controller         = settings->bools.input_remap_sort_by_controller_enable;\n\n   /* > Cannot load remaps if we have no core\n    * > Cannot load remaps if remap directory is unset */\n   if (   string_is_empty(core_name)\n       || string_is_empty(directory_input_remapping))\n      return false;\n\n   game_path[0]        = '\\0';\n   content_path[0]     = '\\0';\n\n   if (   sort_remaps_by_controller\n       && !string_is_empty(inp_dev_name)\n       )\n   {\n      /* Ensure directory does not contain special chars */\n      const char *inp_dev_dir = sanitize_path_part(\n            inp_dev_name, strlen(inp_dev_name));\n      /*  Build the new path with the controller name */\n      size_t _len = strlcpy(remap_path, core_name, sizeof(remap_path));\n      _len += strlcpy(remap_path + _len, PATH_DEFAULT_SLASH(),\n            sizeof(remap_path) - _len);\n      _len += strlcpy(remap_path + _len, inp_dev_dir,\n            sizeof(remap_path) - _len);\n      /* Deallocate as we no longer this */\n      free((char*)inp_dev_dir);\n      inp_dev_dir = NULL;\n   }\n   else /* We're not using controller path, just use core name */\n      strlcpy(remap_path, core_name, sizeof(remap_path));\n\n   if (!string_is_empty(rarch_path_basename))\n   {\n      char content_dir_name[DIR_MAX_LENGTH];\n\n      fill_pathname_join_special_ext(game_path,\n            directory_input_remapping, remap_path,\n            path_basename_nocompression(rarch_path_basename),\n            FILE_PATH_REMAP_EXTENSION,\n            sizeof(game_path));\n\n      /* If a game remap file exists, load it. */\n      if ((new_conf = config_file_new_from_path_to_string(game_path)))\n      {\n         bool ret = input_remapping_load_file(new_conf, game_path);\n         config_file_free(new_conf);\n         new_conf = NULL;\n         RARCH_LOG(\"[Remaps]: Game-specific remap found at \\\"%s\\\".\\n\", game_path);\n         if (ret)\n         {\n            retroarch_ctl(RARCH_CTL_SET_REMAPS_GAME_ACTIVE, NULL);\n            /* msg_remap_loaded is set to MSG_GAME_REMAP_FILE_LOADED\n             * by default - no need to change it here */\n            goto success;\n         }\n      }\n\n      fill_pathname_parent_dir_name(content_dir_name,\n            rarch_path_basename, sizeof(content_dir_name));\n\n      fill_pathname_join_special_ext(content_path,\n            directory_input_remapping, remap_path,\n            content_dir_name,\n            FILE_PATH_REMAP_EXTENSION,\n            sizeof(content_path));\n\n      /* If a content-dir remap file exists, load it. */\n      if ((new_conf = config_file_new_from_path_to_string(content_path)))\n      {\n         bool ret = input_remapping_load_file(new_conf, content_path);\n         config_file_free(new_conf);\n         new_conf = NULL;\n         RARCH_LOG(\"[Remaps]: Content-dir-specific remap found at \\\"%s\\\".\\n\", content_path);\n         if (ret)\n         {\n            retroarch_ctl(RARCH_CTL_SET_REMAPS_CONTENT_DIR_ACTIVE, NULL);\n            msg_remap_loaded = MSG_DIRECTORY_REMAP_FILE_LOADED;\n            goto success;\n         }\n      }\n   }\n\n   fill_pathname_join_special_ext(core_path,\n         directory_input_remapping, remap_path,\n         core_name,\n         FILE_PATH_REMAP_EXTENSION,\n         sizeof(core_path));\n\n   /* If a core remap file exists, load it. */\n   if ((new_conf = config_file_new_from_path_to_string(core_path)))\n   {\n      bool ret = input_remapping_load_file(new_conf, core_path);\n      config_file_free(new_conf);\n      new_conf = NULL;\n      RARCH_LOG(\"[Remaps]: Core-specific remap found at \\\"%s\\\".\\n\", core_path);\n      if (ret)\n      {\n         retroarch_ctl(RARCH_CTL_SET_REMAPS_CORE_ACTIVE, NULL);\n         msg_remap_loaded = MSG_CORE_REMAP_FILE_LOADED;\n         goto success;\n      }\n   }\n\n   if (new_conf)\n      config_file_free(new_conf);\n   new_conf = NULL;\n\n   return false;\n\nsuccess:\n   if (notification_show_remap_load)\n   {\n      const char *_msg = msg_hash_to_str(msg_remap_loaded);\n      runloop_msg_queue_push(_msg, strlen(_msg), 1, 100, false, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n   }\n   return true;\n}\n\n/**\n * config_parse_file:\n *\n * Loads a config file and reads all the values into memory.\n *\n */\nstatic void config_parse_file(global_t *global)\n{\n   const char *config_path = path_get(RARCH_PATH_CONFIG);\n\n   if (!config_load_file(global, config_path, config_st))\n   {\n      RARCH_ERR(\"[Config]: Config not found at: \\\"%s\\\".\\n\",\n            config_path);\n   }\n}\n\nstatic void video_driver_save_settings(global_t *global, config_file_t *conf)\n{\n   config_set_int(conf, \"gamma_correction\",\n         global->console.screen.gamma_correction);\n   config_set_string(conf, \"flicker_filter_enable\",\n           global->console.flickerfilter_enable\n         ? \"true\"\n         : \"false\");\n   config_set_string(conf, \"soft_filter_enable\",\n           global->console.softfilter_enable\n         ? \"true\"\n         : \"false\");\n\n   config_set_int(conf, \"soft_filter_index\",\n         global->console.screen.soft_filter_index);\n   config_set_int(conf, \"current_resolution_id\",\n         global->console.screen.resolutions.current.id);\n   config_set_int(conf, \"flicker_filter_index\",\n         global->console.screen.flicker_filter_index);\n}\n\nstatic void save_keybind_hat(config_file_t *conf, const char *key,\n      const struct retro_keybind *bind)\n{\n   size_t _len;\n   char s[16];\n   s[0]      = '\\0';\n   _len      = snprintf(s, sizeof(s), \"h%u\", GET_HAT(bind->joykey));\n\n   switch (GET_HAT_DIR(bind->joykey))\n   {\n      case HAT_UP_MASK:\n         strlcpy(s + _len, \"up\", sizeof(s) - _len);\n         break;\n      case HAT_DOWN_MASK:\n         strlcpy(s + _len, \"down\", sizeof(s) - _len);\n         break;\n      case HAT_LEFT_MASK:\n         strlcpy(s + _len, \"left\", sizeof(s) - _len);\n         break;\n      case HAT_RIGHT_MASK:\n         strlcpy(s + _len, \"right\", sizeof(s) - _len);\n         break;\n      default:\n         break;\n   }\n\n   config_set_string(conf, key, s);\n}\n\nstatic void save_keybind_joykey(config_file_t *conf,\n      const char *prefix,\n      const char *base,\n      const struct retro_keybind *bind, bool save_empty)\n{\n   char key[64];\n   size_t _len = fill_pathname_join_delim(key, prefix,\n         base, '_', sizeof(key));\n   strlcpy(key + _len, \"_btn\", sizeof(key) - _len);\n\n   if (bind->joykey == NO_BTN)\n   {\n       if (save_empty)\n         config_set_string(conf, key, \"nul\");\n   }\n   else if (GET_HAT_DIR(bind->joykey))\n      save_keybind_hat(conf, key, bind);\n   else\n      config_set_uint64(conf, key, bind->joykey);\n}\n\nstatic void save_keybind_axis(config_file_t *conf,\n      const char *prefix,\n      const char *base,\n      const struct retro_keybind *bind, bool save_empty)\n{\n   char key[64];\n   size_t _len = fill_pathname_join_delim(key, prefix, base, '_', sizeof(key));\n   strlcpy(key + _len, \"_axis\", sizeof(key) - _len);\n\n   if (bind->joyaxis == AXIS_NONE)\n   {\n      if (save_empty)\n         config_set_string(conf, key, \"nul\");\n   }\n   else if (AXIS_NEG_GET(bind->joyaxis) != AXIS_DIR_NONE)\n   {\n      char config[16];\n      config[0] = '-';\n      config[1] = '\\0';\n      snprintf(config + 1, sizeof(config) - 1, \"%u\",\n            AXIS_NEG_GET(bind->joyaxis));\n      config_set_string(conf, key, config);\n   }\n   else if (AXIS_POS_GET(bind->joyaxis) != AXIS_DIR_NONE)\n   {\n      char config[16];\n      config[0] = '+';\n      config[1] = '\\0';\n      snprintf(config + 1, sizeof(config) - 1, \"%u\",\n            AXIS_POS_GET(bind->joyaxis));\n      config_set_string(conf, key, config);\n   }\n}\n\nstatic void save_keybind_mbutton(config_file_t *conf,\n      const char *prefix,\n      const char *base,\n      const struct retro_keybind *bind, bool save_empty)\n{\n   char key[64];\n   size_t _len = fill_pathname_join_delim(key, prefix,\n      base, '_', sizeof(key));\n   strlcpy(key + _len, \"_mbtn\", sizeof(key) - _len);\n\n   switch (bind->mbutton)\n   {\n      case RETRO_DEVICE_ID_MOUSE_LEFT:\n         config_set_uint64(conf, key, 1);\n         break;\n      case RETRO_DEVICE_ID_MOUSE_RIGHT:\n         config_set_uint64(conf, key, 2);\n         break;\n      case RETRO_DEVICE_ID_MOUSE_MIDDLE:\n         config_set_uint64(conf, key, 3);\n         break;\n      case RETRO_DEVICE_ID_MOUSE_BUTTON_4:\n         config_set_uint64(conf, key, 4);\n         break;\n      case RETRO_DEVICE_ID_MOUSE_BUTTON_5:\n         config_set_uint64(conf, key, 5);\n         break;\n      case RETRO_DEVICE_ID_MOUSE_WHEELUP:\n         config_set_string(conf, key, \"wu\");\n         break;\n      case RETRO_DEVICE_ID_MOUSE_WHEELDOWN:\n         config_set_string(conf, key, \"wd\");\n         break;\n      case RETRO_DEVICE_ID_MOUSE_HORIZ_WHEELUP:\n         config_set_string(conf, key, \"whu\");\n         break;\n      case RETRO_DEVICE_ID_MOUSE_HORIZ_WHEELDOWN:\n         config_set_string(conf, key, \"whd\");\n         break;\n      default:\n         if (save_empty)\n            config_set_string(conf, key, \"nul\");\n         break;\n   }\n}\n\nconst char *input_config_get_prefix(unsigned user, bool meta)\n{\n   static const char *bind_user_prefix[MAX_USERS] = {\n      \"input_player1\",\n      \"input_player2\",\n      \"input_player3\",\n      \"input_player4\",\n      \"input_player5\",\n      \"input_player6\",\n      \"input_player7\",\n      \"input_player8\",\n      \"input_player9\",\n      \"input_player10\",\n      \"input_player11\",\n      \"input_player12\",\n      \"input_player13\",\n      \"input_player14\",\n      \"input_player15\",\n      \"input_player16\",\n   };\n   if (meta)\n   {\n      if (user == 0)\n         return \"input\";\n      /* Don't bother with meta bind for anyone else than first user. */\n      return NULL;\n   }\n   return bind_user_prefix[user];\n}\n\n/**\n * input_config_save_keybinds_user:\n * @conf               : pointer to config file object\n * @user               : user number\n *\n * Save the current keybinds of a user (@user) to the config file (@conf).\n */\nstatic void input_config_save_keybinds_user(config_file_t *conf, unsigned user)\n{\n   unsigned i = 0;\n\n   for (i = 0; input_config_bind_map_get_valid(i); i++)\n   {\n      char key[64];\n      char btn[64];\n      const struct input_bind_map *keybind =\n         (const struct input_bind_map*)INPUT_CONFIG_BIND_MAP_GET(i);\n      bool meta                            = keybind ? keybind->meta : false;\n      const char *prefix                   = input_config_get_prefix(user, meta);\n      const struct retro_keybind *bind     = &input_config_binds[user][i];\n      const char                 *base     = NULL;\n\n      if (!prefix || !bind->valid || !keybind)\n         continue;\n\n      base                                 = keybind->base;\n      btn[0]                               = '\\0';\n\n      fill_pathname_join_delim(key, prefix, base, '_', sizeof(key));\n\n      input_keymaps_translate_rk_to_str(bind->key, btn, sizeof(btn));\n\n      config_set_string(conf, key, btn);\n      save_keybind_joykey (conf, prefix, base, bind, true);\n      save_keybind_axis   (conf, prefix, base, bind, true);\n      save_keybind_mbutton(conf, prefix, base, bind, true);\n   }\n}\n\n/**\n * input_config_save_keybinds_user_override:\n * @conf               : pointer to config file object\n * @user               : user number\n * @bind_id            : bind number\n * @override_bind      : override retro_keybind for comparison and saving\n *\n * Save the current bind (@override_bind) override of a user (@user) to the\n * config file (@conf), and skip binds that are not modified.\n */\nstatic void input_config_save_keybinds_user_override(config_file_t *conf,\n      unsigned user, unsigned bind_id,\n      const struct retro_keybind *override_bind)\n{\n   unsigned i = bind_id;\n\n   if (input_config_bind_map_get_valid(i))\n   {\n      char key[64];\n      char btn[64];\n      const struct input_bind_map *keybind =\n         (const struct input_bind_map*)INPUT_CONFIG_BIND_MAP_GET(i);\n      bool meta                            = keybind ? keybind->meta : false;\n      const char *prefix                   = input_config_get_prefix(user, meta);\n      const struct retro_keybind *bind     = &input_config_binds[user][i];\n      const char                 *base     = NULL;\n\n      if (!prefix || !bind->valid || !keybind)\n         return;\n\n      base                                 = keybind->base;\n      btn[0]                               = '\\0';\n\n      fill_pathname_join_delim(key, prefix, base, '_', sizeof(key));\n\n      input_keymaps_translate_rk_to_str(override_bind->key, btn, sizeof(btn));\n\n      config_set_string(conf, key, btn);\n\n      if (bind->joykey  != override_bind->joykey)\n         save_keybind_joykey (conf, prefix, base, override_bind, true);\n      if (bind->joyaxis != override_bind->joyaxis)\n         save_keybind_axis   (conf, prefix, base, override_bind, true);\n      if (bind->mbutton != override_bind->mbutton)\n         save_keybind_mbutton(conf, prefix, base, override_bind, true);\n\n      RARCH_DBG(\"[Overrides]: %s = \\\"%s\\\"\\n\", key, btn);\n   }\n}\n\nvoid config_get_autoconf_profile_filename(\n      const char *device_name, unsigned user,\n      char *s, size_t len)\n{\n   static const char* invalid_filename_chars[] = {\n      /* https://support.microsoft.com/en-us/help/905231/information-about-the-characters-that-you-cannot-use-in-site-names--fo */\n      \"~\", \"#\", \"%\", \"&\", \"*\", \"{\", \"}\", \"\\\\\", \":\", \"[\", \"]\", \"?\", \"/\", \"|\", \"\\'\", \"\\\"\",\n      NULL\n   };\n   size_t _len;\n   unsigned i;\n\n   settings_t *settings                 = config_st;\n   const char *autoconf_dir             = settings->paths.directory_autoconfig;\n   const char *joypad_driver_fallback   = settings->arrays.input_joypad_driver;\n   const char *joypad_driver            = NULL;\n   char *sanitised_name                 = NULL;\n\n   if (string_is_empty(device_name))\n      goto end;\n\n   /* Get currently set joypad driver */\n   joypad_driver = input_config_get_device_joypad_driver(user);\n   if (string_is_empty(joypad_driver))\n   {\n      /* This cannot happen, but if we reach this\n       * point without a driver being set for the\n       * current input device then use the value\n       * from the settings struct as a fallback */\n      joypad_driver = joypad_driver_fallback;\n\n      if (string_is_empty(joypad_driver))\n         goto end;\n   }\n\n   sanitised_name = strdup(device_name);\n\n   /* Remove invalid filename characters from\n    * input device name */\n   for (i = 0; invalid_filename_chars[i]; i++)\n   {\n      for (;;)\n      {\n         char *tmp = strstr(sanitised_name,\n               invalid_filename_chars[i]);\n\n         if (tmp)\n            *tmp = '_';\n         else\n            break;\n      }\n   }\n\n   /* Generate autoconfig file path */\n   fill_pathname_join_special(s, autoconf_dir, joypad_driver, len);\n\n   /* Driver specific autoconf dir may not exist, if autoconfs are not downloaded. */\n   if (!path_is_directory(s))\n      _len = strlcpy(s, sanitised_name, len);\n   else\n      _len = fill_pathname_join_special(s, joypad_driver, sanitised_name, len);\n   strlcpy(s + _len, \".cfg\", len - _len);\n\nend:\n   if (sanitised_name)\n      free(sanitised_name);\n}\n\n/**\n * config_save_autoconf_profile:\n * @device_name       : Input device name\n * @user              : Controller number to save\n * Writes a controller autoconf file to disk.\n **/\nbool config_save_autoconf_profile(const char *device_name, unsigned user)\n{\n   unsigned i;\n   char buf[PATH_MAX_LENGTH];\n   char autoconf_file[PATH_MAX_LENGTH];\n   config_file_t *conf                  = NULL;\n   int32_t pid_user                     = 0;\n   int32_t vid_user                     = 0;\n   bool ret                             = false;\n   settings_t *settings                 = config_st;\n   const char *autoconf_dir             = settings->paths.directory_autoconfig;\n   const char *joypad_driver_fallback   = settings->arrays.input_joypad_driver;\n   const char *joypad_driver            = NULL;\n\n   if (string_is_empty(device_name))\n      goto end;\n\n   /* Get currently set joypad driver */\n   joypad_driver = input_config_get_device_joypad_driver(user);\n   if (string_is_empty(joypad_driver))\n   {\n      /* This cannot happen, but if we reach this\n       * point without a driver being set for the\n       * current input device then use the value\n       * from the settings struct as a fallback */\n      joypad_driver = joypad_driver_fallback;\n\n      if (string_is_empty(joypad_driver))\n         goto end;\n   }\n\n   /* Generate autoconfig file path */\n   config_get_autoconf_profile_filename(device_name, user, buf, sizeof(buf));\n   fill_pathname_join_special(autoconf_file, autoconf_dir, buf, sizeof(autoconf_file));\n\n   /* Open config file */\n   if (     !(conf = config_file_new_from_path_to_string(autoconf_file))\n         && !(conf = config_file_new_alloc())\n      )\n      goto end;\n\n   /* Update config file */\n   config_set_string(conf, \"input_driver\",\n         joypad_driver);\n   config_set_string(conf, \"input_device\",\n         input_config_get_device_name(settings->uints.input_joypad_index[user]));\n\n   pid_user = input_config_get_device_pid(settings->uints.input_joypad_index[user]);\n   vid_user = input_config_get_device_vid(settings->uints.input_joypad_index[user]);\n\n   if (pid_user && vid_user)\n   {\n      config_set_int(conf, \"input_vendor_id\",\n            vid_user);\n      config_set_int(conf, \"input_product_id\",\n            pid_user);\n   }\n\n   for (i = 0; i < RARCH_FIRST_META_KEY; i++)\n   {\n      const struct retro_keybind *bind = &input_config_binds[user][i];\n      if (bind->valid)\n      {\n         save_keybind_joykey(\n               conf, \"input\", input_config_bind_map_get_base(i),\n               bind, false);\n         save_keybind_axis(\n               conf, \"input\", input_config_bind_map_get_base(i),\n               bind, false);\n      }\n   }\n\n   RARCH_LOG(\"[Autoconf]: Writing autoconf file for device \\\"%s\\\" to \\\"%s\\\".\\n\", device_name, autoconf_file);\n   ret = config_file_write(conf, autoconf_file, false);\n\nend:\n   if (conf)\n      config_file_free(conf);\n\n   return ret;\n}\n\n/**\n * config_save_file:\n * @path            : Path that shall be written to.\n *\n * Writes a config file to disk.\n *\n * Returns: true (1) on success, otherwise returns false (0).\n **/\nbool config_save_file(const char *path)\n{\n   float msg_color;\n   unsigned i                                        = 0;\n   bool ret                                          = false;\n   struct config_bool_setting     *bool_settings     = NULL;\n   struct config_int_setting     *int_settings       = NULL;\n   struct config_uint_setting     *uint_settings     = NULL;\n   struct config_size_setting     *size_settings     = NULL;\n   struct config_float_setting     *float_settings   = NULL;\n   struct config_array_setting     *array_settings   = NULL;\n   struct config_path_setting     *path_settings     = NULL;\n   uint32_t flags                                    = runloop_get_flags();\n   config_file_t                              *conf  = config_file_new_from_path_to_string(path);\n   settings_t                              *settings = config_st;\n   global_t *global                                  = global_get_ptr();\n   int bool_settings_size                            = sizeof(settings->bools) / sizeof(settings->bools.placeholder);\n   int float_settings_size                           = sizeof(settings->floats)/ sizeof(settings->floats.placeholder);\n   int int_settings_size                             = sizeof(settings->ints)  / sizeof(settings->ints.placeholder);\n   int uint_settings_size                            = sizeof(settings->uints) / sizeof(settings->uints.placeholder);\n   int size_settings_size                            = sizeof(settings->sizes) / sizeof(settings->sizes.placeholder);\n   int array_settings_size                           = sizeof(settings->arrays)/ sizeof(settings->arrays.placeholder);\n   int path_settings_size                            = sizeof(settings->paths) / sizeof(settings->paths.placeholder);\n\n   if (!conf)\n      conf = config_file_new_alloc();\n\n   if (!conf || (flags & RUNLOOP_FLAG_OVERRIDES_ACTIVE))\n   {\n      if (conf)\n         config_file_free(conf);\n      return false;\n   }\n\n   bool_settings   = populate_settings_bool  (settings, &bool_settings_size);\n   int_settings    = populate_settings_int   (settings, &int_settings_size);\n   uint_settings   = populate_settings_uint  (settings, &uint_settings_size);\n   size_settings   = populate_settings_size  (settings, &size_settings_size);\n   float_settings  = populate_settings_float (settings, &float_settings_size);\n   array_settings  = populate_settings_array (settings, &array_settings_size);\n   path_settings   = populate_settings_path  (settings, &path_settings_size);\n\n   /* Path settings */\n   if (path_settings && (path_settings_size > 0))\n   {\n      for (i = 0; i < (unsigned)path_settings_size; i++)\n      {\n         const char *value = path_settings[i].ptr;\n\n         if (path_settings[i].flags & CFG_BOOL_FLG_DEF_ENABLE)\n            if (string_is_empty(path_settings[i].ptr))\n               value = \"default\";\n\n         config_set_path(conf, path_settings[i].ident, value);\n      }\n\n      free(path_settings);\n   }\n\n#ifdef HAVE_MENU\n   config_set_path(conf, \"xmb_font\",\n         !string_is_empty(settings->paths.path_menu_xmb_font)\n         ? settings->paths.path_menu_xmb_font : \"\");\n#endif\n\n   /* String settings  */\n   if (array_settings && (array_settings_size > 0))\n   {\n      for (i = 0; i < (unsigned)array_settings_size; i++)\n         if (   !array_settings[i].override\n             || !retroarch_override_setting_is_set(array_settings[i].override, NULL))\n            config_set_string(conf,\n                  array_settings[i].ident,\n                  array_settings[i].ptr);\n\n      free(array_settings);\n   }\n\n   /* Float settings  */\n   if (float_settings && (float_settings_size > 0))\n   {\n      for (i = 0; i < (unsigned)float_settings_size; i++)\n         if (   !float_settings[i].override\n             || !retroarch_override_setting_is_set(float_settings[i].override, NULL))\n            config_set_float(conf,\n                  float_settings[i].ident,\n                  *float_settings[i].ptr);\n\n      free(float_settings);\n   }\n\n   /* Integer settings */\n   if (int_settings && (int_settings_size > 0))\n   {\n      for (i = 0; i < (unsigned)int_settings_size; i++)\n         if (   !int_settings[i].override\n             || !retroarch_override_setting_is_set(int_settings[i].override, NULL))\n            config_set_int(conf,\n                  int_settings[i].ident,\n                  *int_settings[i].ptr);\n\n      free(int_settings);\n   }\n\n   if (uint_settings && (uint_settings_size > 0))\n   {\n      for (i = 0; i < (unsigned)uint_settings_size; i++)\n         if (   !uint_settings[i].override\n             || !retroarch_override_setting_is_set(uint_settings[i].override, NULL))\n            config_set_int(conf,\n                  uint_settings[i].ident,\n                  *uint_settings[i].ptr);\n\n      free(uint_settings);\n   }\n\n   if (size_settings && (size_settings_size > 0))\n   {\n      for (i = 0; i < (unsigned)size_settings_size; i++)\n         if (   !size_settings[i].override\n             || !retroarch_override_setting_is_set(size_settings[i].override, NULL))\n            config_set_int(conf,\n                  size_settings[i].ident,\n                  (int)*size_settings[i].ptr);\n\n      free(size_settings);\n   }\n\n   for (i = 0; i < MAX_USERS; i++)\n   {\n      size_t _len;\n      char cfg[64];\n      char formatted_number[4];\n      formatted_number[0] = '\\0';\n\n      snprintf(formatted_number, sizeof(formatted_number), \"%u\", i + 1);\n\n      _len = strlcpy(cfg, \"input_device_p\",     sizeof(cfg));\n      strlcpy(cfg + _len, formatted_number,     sizeof(cfg) - _len);\n      config_set_int(conf, cfg, settings->uints.input_device[i]);\n\n      _len  = strlcpy(cfg, \"input_player\",          sizeof(cfg));\n      _len += strlcpy(cfg + _len, formatted_number, sizeof(cfg) - _len);\n\n      strlcpy(cfg + _len, \"_mouse_index\",       sizeof(cfg) - _len);\n      config_set_int(conf, cfg, settings->uints.input_mouse_index[i]);\n\n      strlcpy(cfg + _len, \"_joypad_index\",      sizeof(cfg) - _len);\n      config_set_int(conf, cfg, settings->uints.input_joypad_index[i]);\n\n      strlcpy(cfg + _len, \"_analog_dpad_mode\",  sizeof(cfg) - _len);\n      config_set_int(conf, cfg, settings->uints.input_analog_dpad_mode[i]);\n\n      strlcpy(cfg + _len, \"_device_reservation_type\",  sizeof(cfg) - _len);\n      config_set_int(conf, cfg, settings->uints.input_device_reservation_type[i]);\n   }\n\n   /* Boolean settings */\n   if (bool_settings && (bool_settings_size > 0))\n   {\n      for (i = 0; i < (unsigned)bool_settings_size; i++)\n         if (   !bool_settings[i].override\n             || !retroarch_override_setting_is_set(bool_settings[i].override, NULL))\n            config_set_string(conf, bool_settings[i].ident,\n                  *bool_settings[i].ptr\n                  ? \"true\" : \"false\");\n\n      free(bool_settings);\n   }\n\n#ifdef HAVE_NETWORKGAMEPAD\n   {\n      char tmp[64];\n      size_t _len = strlcpy(tmp, \"network_remote_enable_user_p\", sizeof(tmp));\n      for (i = 0; i < MAX_USERS; i++)\n      {\n         snprintf(tmp + _len, sizeof(tmp) - _len, \"%u\", i + 1);\n         config_set_string(conf, tmp,\n               settings->bools.network_remote_enable_user[i]\n               ? \"true\" : \"false\");\n      }\n   }\n#endif\n\n   /* Verbosity isn't in bool_settings since it needs to be loaded differently */\n   if (!retroarch_override_setting_is_set(RARCH_OVERRIDE_SETTING_VERBOSITY, NULL))\n      config_set_string(conf, \"log_verbosity\",\n            verbosity_is_enabled() ? \"true\" : \"false\");\n   config_set_string(conf, \"perfcnt_enable\",\n            retroarch_ctl(RARCH_CTL_IS_PERFCNT_ENABLE, NULL)\n         ? \"true\" : \"false\");\n\n   msg_color = (((int)(settings->floats.video_msg_color_r * 255.0f) & 0xff) << 16) +\n               (((int)(settings->floats.video_msg_color_g * 255.0f) & 0xff) <<  8) +\n               (((int)(settings->floats.video_msg_color_b * 255.0f) & 0xff));\n\n   /* Hexadecimal settings */\n   config_set_hex(conf, \"video_message_color\", msg_color);\n\n   if (conf)\n      video_driver_save_settings(global, conf);\n\n#ifdef HAVE_LAKKA\n   if (settings->bools.ssh_enable)\n      filestream_close(filestream_open(LAKKA_SSH_PATH,\n               RETRO_VFS_FILE_ACCESS_WRITE,\n               RETRO_VFS_FILE_ACCESS_HINT_NONE));\n   else\n      filestream_delete(LAKKA_SSH_PATH);\n   if (settings->bools.samba_enable)\n      filestream_close(filestream_open(LAKKA_SAMBA_PATH,\n               RETRO_VFS_FILE_ACCESS_WRITE,\n               RETRO_VFS_FILE_ACCESS_HINT_NONE));\n   else\n      filestream_delete(LAKKA_SAMBA_PATH);\n   if (settings->bools.bluetooth_enable)\n      filestream_close(filestream_open(LAKKA_BLUETOOTH_PATH,\n               RETRO_VFS_FILE_ACCESS_WRITE,\n               RETRO_VFS_FILE_ACCESS_HINT_NONE));\n   else\n      filestream_delete(LAKKA_BLUETOOTH_PATH);\n#endif\n\n   for (i = 0; i < MAX_USERS; i++)\n      input_config_save_keybinds_user(conf, i);\n\n   ret = config_file_write(conf, path, true);\n   config_file_free(conf);\n\n#if TARGET_OS_TV\n   if (ret && string_is_equal(path, path_get(RARCH_PATH_CONFIG)))\n       write_userdefaults_config_file();\n#endif\n\n   return ret;\n}\n\n/**\n * config_save_overrides:\n * @path            : Path that shall be written to.\n *\n * Writes a config file override to disk.\n *\n * Returns: true (1) on success, (-1) if nothing to write, otherwise returns false (0).\n **/\nint8_t config_save_overrides(enum override_type type,\n      void *data, bool remove, const char *path)\n{\n   int tmp_i                                   = 0;\n   unsigned i                                  = 0;\n   int8_t ret                                  = 0;\n   retro_keybind_set input_override_binds[MAX_USERS]\n                                               = {0};\n   config_file_t *conf                         = NULL;\n   settings_t *settings                        = NULL;\n   struct config_bool_setting *bool_settings   = NULL;\n   struct config_bool_setting *bool_overrides  = NULL;\n   struct config_int_setting *int_settings     = NULL;\n   struct config_uint_setting *uint_settings   = NULL;\n   struct config_size_setting *size_settings   = NULL;\n   struct config_int_setting *int_overrides    = NULL;\n   struct config_uint_setting *uint_overrides  = NULL;\n   struct config_size_setting *size_overrides  = NULL;\n   struct config_float_setting *float_settings = NULL;\n   struct config_float_setting *float_overrides= NULL;\n   struct config_array_setting *array_settings = NULL;\n   struct config_array_setting *array_overrides= NULL;\n   struct config_path_setting *path_settings   = NULL;\n   struct config_path_setting *path_overrides  = NULL;\n   char config_directory[DIR_MAX_LENGTH];\n   char override_directory[DIR_MAX_LENGTH];\n   char override_path[PATH_MAX_LENGTH];\n   settings_t *overrides                       = config_st;\n   int bool_settings_size                      = sizeof(settings->bools)  / sizeof(settings->bools.placeholder);\n   int float_settings_size                     = sizeof(settings->floats) / sizeof(settings->floats.placeholder);\n   int int_settings_size                       = sizeof(settings->ints)   / sizeof(settings->ints.placeholder);\n   int uint_settings_size                      = sizeof(settings->uints)  / sizeof(settings->uints.placeholder);\n   int size_settings_size                      = sizeof(settings->sizes)  / sizeof(settings->sizes.placeholder);\n   int array_settings_size                     = sizeof(settings->arrays) / sizeof(settings->arrays.placeholder);\n   int path_settings_size                      = sizeof(settings->paths)  / sizeof(settings->paths.placeholder);\n   rarch_system_info_t *sys_info               = (rarch_system_info_t*)data;\n   const char *core_name                       = sys_info ? sys_info->info.library_name : NULL;\n   const char *rarch_path_basename             = path_get(RARCH_PATH_BASENAME);\n   const char *game_name                       = NULL;\n   bool has_content                            = !string_is_empty(rarch_path_basename);\n\n   override_path[0]      = '\\0';\n\n   /* > Cannot save an override if we have no core\n    * > Cannot save a per-game or per-content-directory\n    *   override if we have no content */\n   if (     string_is_empty(core_name)\n       || (!has_content && (type != OVERRIDE_CORE)))\n      return false;\n\n   settings = (settings_t*)calloc(1, sizeof(settings_t));\n   conf     = config_file_new_alloc();\n\n   /* Get base config directory */\n   fill_pathname_application_special(config_directory,\n         sizeof(config_directory),\n         APPLICATION_SPECIAL_DIRECTORY_CONFIG);\n\n   fill_pathname_join_special(override_directory,\n      config_directory, core_name,\n      sizeof(override_directory));\n\n   /* Ensure base config directory exists */\n   if (!path_is_directory(override_directory))\n      path_mkdir(override_directory);\n\n   /* Store current binds as override binds */\n   memcpy(input_override_binds, input_config_binds, sizeof(input_override_binds));\n\n   /* Load the original config file in memory */\n   config_load_file(global_get_ptr(),\n         \"without-overrides\", settings);\n\n   bool_settings       = populate_settings_bool(settings,   &bool_settings_size);\n   tmp_i               = sizeof(settings->bools) / sizeof(settings->bools.placeholder);\n   bool_overrides      = populate_settings_bool(overrides,  &tmp_i);\n\n   int_settings        = populate_settings_int(settings,    &int_settings_size);\n   tmp_i               = sizeof(settings->ints) / sizeof(settings->ints.placeholder);\n   int_overrides       = populate_settings_int(overrides,   &tmp_i);\n\n   uint_settings       = populate_settings_uint(settings,   &uint_settings_size);\n   tmp_i               = sizeof(settings->uints) / sizeof(settings->uints.placeholder);\n   uint_overrides      = populate_settings_uint(overrides,  &tmp_i);\n\n   size_settings       = populate_settings_size(settings,   &size_settings_size);\n   tmp_i               = sizeof(settings->sizes) / sizeof(settings->sizes.placeholder);\n   size_overrides      = populate_settings_size(overrides,  &tmp_i);\n\n   float_settings      = populate_settings_float(settings,  &float_settings_size);\n   tmp_i               = sizeof(settings->floats) / sizeof(settings->floats.placeholder);\n   float_overrides     = populate_settings_float(overrides, &tmp_i);\n\n   array_settings      = populate_settings_array(settings,  &array_settings_size);\n   tmp_i               = sizeof(settings->arrays) / sizeof(settings->arrays.placeholder);\n   array_overrides     = populate_settings_array(overrides, &tmp_i);\n\n   path_settings       = populate_settings_path(settings,   &path_settings_size);\n   tmp_i               = sizeof(settings->paths) / sizeof(settings->paths.placeholder);\n   path_overrides      = populate_settings_path(overrides,  &tmp_i);\n\n   if (conf->flags & CONF_FILE_FLG_MODIFIED)\n      RARCH_LOG(\"[Overrides]: Looking for changed settings..\\n\");\n\n   if (conf)\n   {\n      for (i = 0; i < (unsigned)bool_settings_size; i++)\n      {\n         if ((*bool_settings[i].ptr) != (*bool_overrides[i].ptr))\n         {\n            config_set_string(conf, bool_overrides[i].ident,\n                  (*bool_overrides[i].ptr) ? \"true\" : \"false\");\n            RARCH_DBG(\"[Overrides]: %s = \\\"%s\\\"\\n\",\n                  bool_overrides[i].ident,\n                  (*bool_overrides[i].ptr) ? \"true\" : \"false\");\n         }\n      }\n      for (i = 0; i < (unsigned)int_settings_size; i++)\n      {\n         if ((*int_settings[i].ptr) != (*int_overrides[i].ptr))\n         {\n            config_set_int(conf, int_overrides[i].ident,\n                  (*int_overrides[i].ptr));\n            RARCH_DBG(\"[Overrides]: %s = \\\"%d\\\"\\n\",\n                  int_overrides[i].ident, *int_overrides[i].ptr);\n         }\n      }\n      for (i = 0; i < (unsigned)uint_settings_size; i++)\n      {\n         if ((*uint_settings[i].ptr) != (*uint_overrides[i].ptr))\n         {\n            config_set_int(conf, uint_overrides[i].ident,\n                  (*uint_overrides[i].ptr));\n            RARCH_DBG(\"[Overrides]: %s = \\\"%d\\\"\\n\",\n                  uint_overrides[i].ident, *uint_overrides[i].ptr);\n         }\n      }\n      for (i = 0; i < (unsigned)size_settings_size; i++)\n      {\n         if ((*size_settings[i].ptr) != (*size_overrides[i].ptr))\n         {\n            config_set_int(conf, size_overrides[i].ident,\n                  (int)(*size_overrides[i].ptr));\n            RARCH_DBG(\"[Overrides]: %s = \\\"%d\\\"\\n\",\n                  size_overrides[i].ident, *size_overrides[i].ptr);\n         }\n      }\n      for (i = 0; i < (unsigned)float_settings_size; i++)\n      {\n         if ((*float_settings[i].ptr) != (*float_overrides[i].ptr))\n         {\n            config_set_float(conf, float_overrides[i].ident,\n                  *float_overrides[i].ptr);\n            RARCH_DBG(\"[Overrides]: %s = \\\"%f\\\"\\n\",\n                  float_overrides[i].ident, *float_overrides[i].ptr);\n         }\n      }\n\n      for (i = 0; i < (unsigned)array_settings_size; i++)\n      {\n         if (!string_is_equal(array_settings[i].ptr, array_overrides[i].ptr))\n         {\n#ifdef HAVE_CHEEVOS\n            /* As authentication doesn't occur until after content is loaded,\n             * the achievement authentication token might only exist in the\n             * override set, and therefore differ from the master config set.\n             * Storing the achievement authentication token in an override\n             * is a recipe for disaster. If it expires and the user generates\n             * a new token, then the override will be out of date and the\n             * user will have to reauthenticate for each override (and also\n             * remember to update each override). Also exclude the username\n             * as it's directly tied to the token and password.\n             */\n            if (   string_is_equal(array_settings[i].ident, \"cheevos_token\")\n                || string_is_equal(array_settings[i].ident, \"cheevos_password\")\n                || string_is_equal(array_settings[i].ident, \"cheevos_username\"))\n               continue;\n#endif\n            config_set_string(conf, array_overrides[i].ident,\n                  array_overrides[i].ptr);\n            RARCH_DBG(\"[Overrides]: %s = \\\"%s\\\"\\n\",\n                  array_overrides[i].ident, array_overrides[i].ptr);\n         }\n      }\n\n      for (i = 0; i < (unsigned)path_settings_size; i++)\n      {\n         if (!string_is_equal(path_settings[i].ptr, path_overrides[i].ptr))\n         {\n#if IOS\n            if (string_is_equal(path_settings[i].ident, \"libretro_directory\"))\n               continue;\n#endif\n            config_set_path(conf, path_overrides[i].ident,\n                  path_overrides[i].ptr);\n            RARCH_DBG(\"[Overrides]: %s = \\\"%s\\\"\\n\",\n                  path_overrides[i].ident, path_overrides[i].ptr);\n         }\n      }\n\n      for (i = 0; i < MAX_USERS; i++)\n      {\n         size_t _len;\n         uint8_t j;\n         char cfg[64];\n         char formatted_number[4];\n         cfg[0] = formatted_number[0] = '\\0';\n\n         snprintf(formatted_number, sizeof(formatted_number), \"%u\", i + 1);\n\n         if (settings->uints.input_device[i]\n               != overrides->uints.input_device[i])\n         {\n            size_t _len = strlcpy(cfg, \"input_device_p\", sizeof(cfg));\n            strlcpy(cfg + _len, formatted_number, sizeof(cfg) - _len);\n            config_set_int(conf, cfg, overrides->uints.input_device[i]);\n            RARCH_DBG(\"[Overrides]: %s = \\\"%u\\\"\\n\", cfg, overrides->uints.input_device[i]);\n         }\n\n         _len  = strlcpy(cfg, \"input_player\",          sizeof(cfg));\n         _len += strlcpy(cfg + _len, formatted_number, sizeof(cfg) - _len);\n\n         if (settings->uints.input_mouse_index[i]\n               != overrides->uints.input_mouse_index[i])\n         {\n            strlcpy(cfg + _len, \"_mouse_index\",   sizeof(cfg) - _len);\n            config_set_int(conf, cfg, overrides->uints.input_mouse_index[i]);\n            RARCH_DBG(\"[Overrides]: %s = \\\"%u\\\"\\n\", cfg, overrides->uints.input_mouse_index[i]);\n         }\n\n         if (settings->uints.input_joypad_index[i]\n               != overrides->uints.input_joypad_index[i])\n         {\n            strlcpy(cfg + _len, \"_joypad_index\",  sizeof(cfg) - _len);\n            config_set_int(conf, cfg, overrides->uints.input_joypad_index[i]);\n            RARCH_DBG(\"[Overrides]: %s = \\\"%u\\\"\\n\", cfg, overrides->uints.input_joypad_index[i]);\n         }\n\n         if (settings->uints.input_analog_dpad_mode[i]\n               != overrides->uints.input_analog_dpad_mode[i])\n         {\n            strlcpy(cfg + _len, \"_analog_dpad_mode\", sizeof(cfg) - _len);\n            config_set_int(conf, cfg, overrides->uints.input_analog_dpad_mode[i]);\n            RARCH_DBG(\"[Overrides]: %s = \\\"%u\\\"\\n\", cfg, overrides->uints.input_analog_dpad_mode[i]);\n         }\n\n        if (settings->uints.input_device_reservation_type[i]\n               != overrides->uints.input_device_reservation_type[i])\n         {\n            strlcpy(cfg + _len, \"_device_reservation_type\", sizeof(cfg) - _len);\n            config_set_int(conf, cfg, overrides->uints.input_device_reservation_type[i]);\n            RARCH_DBG(\"[Overrides]: %s = \\\"%u\\\"\\n\", cfg, overrides->uints.input_device_reservation_type[i]);\n         }\n\n         /* TODO: is this whole section really necessary? Does the loop above not do this? */\n         if (!string_is_equal(settings->arrays.input_reserved_devices[i], overrides->arrays.input_reserved_devices[i]))\n         {\n            strlcpy(cfg + _len, \"_device_reservation_type\", sizeof(cfg) - _len);\n\n            config_set_string(conf, cfg,\n                  overrides->arrays.input_reserved_devices[i]);\n            RARCH_DBG(\"[Overrides]: %s = \\\"%s\\\"\\n\",\n                  cfg, overrides->arrays.input_reserved_devices[i]);\n         }\n\n         for (j = 0; j < RARCH_BIND_LIST_END; j++)\n         {\n            const struct retro_keybind *override_bind = &input_override_binds[i][j];\n            const struct retro_keybind *config_bind   = &input_config_binds[i][j];\n\n            if (     config_bind->joyaxis != override_bind->joyaxis\n                  || config_bind->joykey  != override_bind->joykey\n                  || config_bind->key     != override_bind->key\n                  || config_bind->mbutton != override_bind->mbutton\n               )\n               input_config_save_keybinds_user_override(conf, i, j, override_bind);\n         }\n      }\n\n      ret = 0;\n\n      switch (type)\n      {\n         case OVERRIDE_CORE:\n            fill_pathname_join_special_ext(override_path,\n                  config_directory, core_name,\n                  core_name,\n                  FILE_PATH_CONFIG_EXTENSION,\n                  sizeof(override_path));\n            break;\n         case OVERRIDE_GAME:\n            game_name = path_basename_nocompression(rarch_path_basename);\n            fill_pathname_join_special_ext(override_path,\n                  config_directory, core_name,\n                  game_name,\n                  FILE_PATH_CONFIG_EXTENSION,\n                  sizeof(override_path));\n            break;\n         case OVERRIDE_CONTENT_DIR:\n            {\n               char content_dir_name[DIR_MAX_LENGTH];\n               content_dir_name[0]   = '\\0';\n               fill_pathname_parent_dir_name(content_dir_name,\n                     rarch_path_basename, sizeof(content_dir_name));\n               fill_pathname_join_special_ext(override_path,\n                     config_directory, core_name,\n                     content_dir_name,\n                     FILE_PATH_CONFIG_EXTENSION,\n                     sizeof(override_path));\n            }\n            break;\n         case OVERRIDE_AS:\n            fill_pathname_join_special_ext(override_path,\n                  config_directory, core_name,\n                  path,\n                  FILE_PATH_CONFIG_EXTENSION,\n                  sizeof(override_path));\n            break;\n         case OVERRIDE_NONE:\n         default:\n            break;\n      }\n\n      if (!(conf->flags & CONF_FILE_FLG_MODIFIED) && !remove)\n         ret = -1;\n\n      if (!string_is_empty(override_path))\n      {\n         if (!(conf->flags & CONF_FILE_FLG_MODIFIED) && !remove)\n            if (path_is_valid(override_path))\n               remove = true;\n\n         if (     remove\n               && path_is_valid(override_path))\n         {\n            if (filestream_delete(override_path) == 0)\n            {\n               ret = -1;\n               RARCH_LOG(\"[Overrides]: %s: \\\"%s\\\".\\n\",\n                     \"Deleted\", override_path);\n            }\n         }\n         else if (conf->flags & CONF_FILE_FLG_MODIFIED)\n         {\n            ret = config_file_write(conf, override_path, true);\n\n            if (ret)\n            {\n               path_set(RARCH_PATH_CONFIG_OVERRIDE, override_path);\n               RARCH_LOG(\"[Overrides]: %s: \\\"%s\\\".\\n\",\n                     \"Saved\", override_path);\n            }\n            else\n            {\n               RARCH_LOG(\"[Overrides]: %s: \\\"%s\\\".\\n\",\n                     \"Failed to save\", override_path);\n            }\n         }\n      }\n\n      config_file_free(conf);\n   }\n\n   /* Since config_load_file resets binds, restore overrides back to current binds */\n   memcpy(input_config_binds, input_override_binds, sizeof(input_config_binds));\n\n   if (bool_settings)\n      free(bool_settings);\n   if (bool_overrides)\n      free(bool_overrides);\n   if (int_settings)\n      free(int_settings);\n   if (uint_settings)\n      free(uint_settings);\n   if (size_settings)\n      free(size_settings);\n   if (int_overrides)\n      free(int_overrides);\n   if (uint_overrides)\n      free(uint_overrides);\n   if (float_settings)\n      free(float_settings);\n   if (float_overrides)\n      free(float_overrides);\n   if (array_settings)\n      free(array_settings);\n   if (array_overrides)\n      free(array_overrides);\n   if (path_settings)\n      free(path_settings);\n   if (path_overrides)\n      free(path_overrides);\n   if (size_overrides)\n      free(size_overrides);\n   free(settings);\n\n   return ret;\n}\n\n/* Replaces currently loaded configuration file with\n * another one. Will load a dummy core to flush state\n * properly. */\nbool config_replace(bool config_replace_save_on_exit, char *path)\n{\n   content_ctx_info_t content_info = {0};\n   const char *rarch_path_config   = path_get(RARCH_PATH_CONFIG);\n\n   /* If config file to be replaced is the same as the\n    * current config file, exit. */\n   if (string_is_equal(path, rarch_path_config))\n      return false;\n\n   if (config_replace_save_on_exit && !path_is_empty(RARCH_PATH_CONFIG))\n      config_save_file(rarch_path_config);\n\n   path_set(RARCH_PATH_CONFIG, path);\n\n   retroarch_ctl(RARCH_CTL_UNSET_BLOCK_CONFIG_READ, NULL);\n\n   /* Load core in new (salamander) config. */\n   path_clear(RARCH_PATH_CORE);\n\n   return task_push_start_dummy_core(&content_info);\n}\n\n/**\n * input_remapping_load_file:\n * @data                     : Path to config file.\n *\n * Loads a remap file from disk to memory.\n *\n * Returns: true (1) if successful, otherwise false (0).\n **/\nbool input_remapping_load_file(void *data, const char *path)\n{\n   unsigned i, j;\n   config_file_t *conf                              = (config_file_t*)data;\n   settings_t *settings                             = config_st;\n   runloop_state_t *runloop_st                      = runloop_state_get_ptr();\n   char key_strings[RARCH_FIRST_CUSTOM_BIND + 8][8] = {\n      \"b\", \"y\", \"select\", \"start\",\n      \"up\", \"down\", \"left\", \"right\",\n      \"a\", \"x\", \"l\", \"r\", \"l2\", \"r2\",\n      \"l3\", \"r3\", \"l_x+\", \"l_x-\", \"l_y+\", \"l_y-\", \"r_x+\", \"r_x-\", \"r_y+\", \"r_y-\" };\n\n   if (    !conf\n         || string_is_empty(path))\n      return false;\n\n   if (!string_is_empty(runloop_st->name.remapfile))\n      input_remapping_deinit(false);\n\n   input_remapping_set_defaults(false);\n   runloop_st->name.remapfile = strdup(path);\n\n   for (i = 0; i < MAX_USERS; i++)\n   {\n      size_t _len;\n      char prefix[16];\n      char s1[32], s2[32], s3[32];\n      char formatted_number[4];\n      formatted_number[0] = '\\0';\n      snprintf(formatted_number, sizeof(formatted_number), \"%u\", i + 1);\n      _len       = strlcpy(prefix, \"input_player\",   sizeof(prefix));\n      strlcpy(prefix + _len, formatted_number, sizeof(prefix) - _len);\n      _len       = strlcpy(s1, prefix, sizeof(s1));\n      strlcpy(s1 + _len, \"_btn\", sizeof(s1) - _len);\n      _len       = strlcpy(s2, prefix, sizeof(s2));\n      strlcpy(s2 + _len, \"_key\", sizeof(s2) - _len);\n      _len       = strlcpy(s3, prefix, sizeof(s3));\n      strlcpy(s3 + _len, \"_stk\", sizeof(s3) - _len);\n\n      for (j = 0; j < RARCH_FIRST_CUSTOM_BIND + 8; j++)\n      {\n         const char *key_string = key_strings[j];\n\n         if (j < RARCH_FIRST_CUSTOM_BIND)\n         {\n            char ident[128];\n            int _remap = -1;\n\n            fill_pathname_join_delim(ident, s1,\n                  key_string, '_', sizeof(ident));\n\n            if (config_get_int(conf, ident, &_remap))\n            {\n               if (_remap == -1)\n                  _remap = RARCH_UNMAPPED;\n\n               configuration_set_uint(settings,\n                     settings->uints.input_remap_ids[i][j], _remap);\n            }\n\n            fill_pathname_join_delim(ident, s2,\n                  key_string, '_', sizeof(ident));\n\n            _remap = -1;\n\n            if (!config_get_int(conf, ident, &_remap))\n               _remap = RETROK_UNKNOWN;\n\n            configuration_set_uint(settings,\n                  settings->uints.input_keymapper_ids[i][j], _remap);\n         }\n         else\n         {\n            char ident[256];\n            int _remap = -1;\n\n            fill_pathname_join_delim(ident, s3,\n                  key_string, '_', sizeof(ident));\n\n            if (config_get_int(conf, ident, &_remap))\n            {\n               if (_remap == -1)\n                  _remap = RARCH_UNMAPPED;\n\n               configuration_set_uint(settings,\n                     settings->uints.input_remap_ids[i][j], _remap);\n            }\n\n            fill_pathname_join_delim(ident, s2,\n                  key_string, '_', sizeof(ident));\n\n            _remap = -1;\n\n            if (!config_get_int(conf, ident, &_remap))\n               _remap = RETROK_UNKNOWN;\n\n            configuration_set_uint(settings,\n                  settings->uints.input_keymapper_ids[i][j], _remap);\n         }\n      }\n\n      _len = strlcpy(s1, prefix, sizeof(s1));\n      strlcpy(s1 + _len, \"_analog_dpad_mode\", sizeof(s1) - _len);\n      CONFIG_GET_INT_BASE(conf, settings, uints.input_analog_dpad_mode[i], s1);\n\n      _len = strlcpy(s1, \"input_libretro_device_p\", sizeof(s1));\n      strlcpy(s1 + _len, formatted_number, sizeof(s1) - _len);\n      CONFIG_GET_INT_BASE(conf, settings, uints.input_libretro_device[i], s1);\n\n      _len = strlcpy(s1, \"input_remap_port_p\", sizeof(s1));\n      strlcpy(s1 + _len, formatted_number, sizeof(s1) - _len);\n      CONFIG_GET_INT_BASE(conf, settings, uints.input_remap_ports[i], s1);\n   }\n\n   input_remapping_update_port_map();\n\n   /* Whenever a remap file is loaded, subsequent\n    * changes to global remap-related parameters\n    * must be reset at the next core deinitialisation */\n   input_state_get_ptr()->flags   |=  INP_FLAG_REMAPPING_CACHE_ACTIVE;\n\n   return true;\n}\n\n/**\n * input_remapping_save_file:\n * @path                     : Path to remapping file.\n *\n * Saves remapping values to file.\n *\n * Returns: true (1) if successful, otherwise false (0).\n **/\nbool input_remapping_save_file(const char *path)\n{\n   bool ret;\n   unsigned i, j;\n   char remap_file_dir[DIR_MAX_LENGTH];\n   char key_strings[RARCH_FIRST_CUSTOM_BIND + 8][8] =\n   {\n      \"b\",      \"y\",      \"select\", \"start\",\n      \"up\",     \"down\",   \"left\",   \"right\",\n      \"a\",      \"x\",      \"l\",      \"r\",\n      \"l2\",     \"r2\",     \"l3\",     \"r3\",\n      \"l_x+\",   \"l_x-\",   \"l_y+\",   \"l_y-\",\n      \"r_x+\",   \"r_x-\",   \"r_y+\",   \"r_y-\"\n   };\n   config_file_t         *conf = NULL;\n   runloop_state_t *runloop_st = runloop_state_get_ptr();\n   settings_t        *settings = config_st;\n   unsigned          max_users = settings->uints.input_max_users;\n\n   if (string_is_empty(path))\n      return false;\n\n   /* Create output directory, if required */\n   fill_pathname_parent_dir(remap_file_dir, path,\n         sizeof(remap_file_dir));\n\n   if (   !string_is_empty(remap_file_dir)\n       && !path_is_directory(remap_file_dir)\n       && !path_mkdir(remap_file_dir))\n      return false;\n\n   /* Attempt to load file */\n   if (!(conf = config_file_new_alloc()))\n      return false;\n\n   for (i = 0; i < MAX_USERS; i++)\n   {\n      size_t _len;\n      bool skip_port = true;\n      char formatted_number[4];\n      char prefix[16];\n      char s1[32];\n      char s2[32];\n      char s3[32];\n\n      formatted_number[0] = '\\0';\n\n      /* We must include all mapped ports + all those\n       * with an index less than max_users */\n      if (i < max_users)\n         skip_port = false;\n      else\n      {\n         /* Check whether current port is mapped\n          * to an input device */\n         for (j = 0; j < max_users; j++)\n         {\n            if (i == settings->uints.input_remap_ports[j])\n            {\n               skip_port = false;\n               break;\n            }\n         }\n      }\n\n      if (skip_port)\n         continue;\n\n      snprintf(formatted_number, sizeof(formatted_number), \"%u\", i + 1);\n      _len       = strlcpy(prefix, \"input_player\",   sizeof(prefix));\n      strlcpy(prefix + _len, formatted_number, sizeof(prefix) - _len);\n      _len       = strlcpy(s1, prefix, sizeof(s1));\n      strlcpy(s1 + _len, \"_btn\", sizeof(s1) - _len);\n      _len       = strlcpy(s2, prefix, sizeof(s2));\n      strlcpy(s2 + _len, \"_key\", sizeof(s2) - _len);\n      _len       = strlcpy(s3, prefix, sizeof(s3));\n      strlcpy(s3 + _len, \"_stk\", sizeof(s3) - _len);\n\n      for (j = 0; j < RARCH_FIRST_CUSTOM_BIND; j++)\n      {\n         char _ident[128];\n         const char *key_string = key_strings[j];\n         unsigned remap_id      = settings->uints.input_remap_ids[i][j];\n         unsigned keymap_id     = settings->uints.input_keymapper_ids[i][j];\n\n         fill_pathname_join_delim(_ident, s1,\n               key_string, '_', sizeof(_ident));\n\n         /* Only save modified button values */\n         if (remap_id == j)\n            config_unset(conf, _ident);\n         else\n         {\n            if (remap_id == RARCH_UNMAPPED)\n               config_set_int(conf, _ident, -1);\n            else\n               config_set_int(conf, _ident,\n                     settings->uints.input_remap_ids[i][j]);\n         }\n\n         fill_pathname_join_delim(_ident, s2,\n               key_string, '_', sizeof(_ident));\n\n         /* Only save non-empty keymapper values */\n         if (keymap_id == RETROK_UNKNOWN)\n            config_unset(conf, _ident);\n         else\n            config_set_int(conf, _ident,\n                  settings->uints.input_keymapper_ids[i][j]);\n      }\n\n      for (j = RARCH_FIRST_CUSTOM_BIND; j < (RARCH_FIRST_CUSTOM_BIND + 8); j++)\n      {\n         char _ident[128];\n         const char *key_string = key_strings[j];\n         unsigned remap_id      = settings->uints.input_remap_ids[i][j];\n         unsigned keymap_id     = settings->uints.input_keymapper_ids[i][j];\n\n         fill_pathname_join_delim(_ident, s3,\n               key_string, '_', sizeof(_ident));\n\n         /* Only save modified button values */\n         if (remap_id == j)\n            config_unset(conf, _ident);\n         else\n         {\n            if (remap_id == RARCH_UNMAPPED)\n               config_set_int(conf, _ident, -1);\n            else\n               config_set_int(conf, _ident,\n                     settings->uints.input_remap_ids[i][j]);\n         }\n\n         fill_pathname_join_delim(_ident, s2,\n               key_string, '_', sizeof(_ident));\n\n         /* Only save non-empty keymapper values */\n         if (keymap_id == RETROK_UNKNOWN)\n            config_unset(conf, _ident);\n         else\n            config_set_int(conf, _ident,\n                  settings->uints.input_keymapper_ids[i][j]);\n      }\n\n      _len = strlcpy(s1, \"input_libretro_device_p\", sizeof(s1));\n      strlcpy(s1 + _len, formatted_number, sizeof(s1) - _len);\n      config_set_int(conf, s1, input_config_get_device(i));\n\n      _len = strlcpy(s1, prefix, sizeof(s1));\n      strlcpy(s1 + _len, \"_analog_dpad_mode\", sizeof(s1) - _len);\n      config_set_int(conf, s1, settings->uints.input_analog_dpad_mode[i]);\n\n      _len = strlcpy(s1, \"input_remap_port_p\", sizeof(s1));\n      strlcpy(s1 + _len, formatted_number, sizeof(s1) - _len);\n      config_set_int(conf, s1, settings->uints.input_remap_ports[i]);\n   }\n\n   ret = config_file_write(conf, path, true);\n   config_file_free(conf);\n\n   /* Cache remap file path\n    * > Must guard against the case where\n    *   runloop_st->name.remapfile itself\n    *   is passed to this function... */\n   if (runloop_st->name.remapfile != path)\n   {\n      if (runloop_st->name.remapfile)\n         free(runloop_st->name.remapfile);\n      runloop_st->name.remapfile = strdup(path);\n   }\n\n   return ret;\n}\n#endif\n\n#if !defined(HAVE_DYNAMIC)\n/* Salamander config file contains a single\n * entry (libretro_path), which is linked to\n * RARCH_PATH_CORE\n * > Used to select which core to load\n *   when launching a salamander build */\n\nstatic bool config_file_salamander_get_path(char *s, size_t len)\n{\n   const char *rarch_config_path = g_defaults.path_config;\n\n   if (!string_is_empty(rarch_config_path))\n      fill_pathname_resolve_relative(s,\n            rarch_config_path,\n            FILE_PATH_SALAMANDER_CONFIG,\n            len);\n   else\n      strlcpy(s, FILE_PATH_SALAMANDER_CONFIG, len);\n\n   return !string_is_empty(s);\n}\n\nvoid config_load_file_salamander(void)\n{\n   config_file_t *config = NULL;\n   char config_path[PATH_MAX_LENGTH];\n   char libretro_path[PATH_MAX_LENGTH];\n\n   config_path[0]   = '\\0';\n   libretro_path[0] = '\\0';\n\n   /* Get config file path */\n   if (!config_file_salamander_get_path(\n         config_path, sizeof(config_path)))\n      return;\n\n   /* Open config file */\n   if (!(config = config_file_new_from_path_to_string(config_path)))\n      return;\n\n   /* Read 'libretro_path' value and update\n    * RARCH_PATH_CORE */\n   RARCH_LOG(\"[Config]: Loading salamander config from: \\\"%s\\\".\\n\",\n         config_path);\n\n   if (config_get_path(config, \"libretro_path\",\n         libretro_path, sizeof(libretro_path))\n       && !string_is_empty(libretro_path)\n       && !string_is_equal(libretro_path, \"builtin\"))\n      path_set(RARCH_PATH_CORE, libretro_path);\n\n   config_file_free(config);\n}\n\nvoid config_save_file_salamander(void)\n{\n   config_file_t *conf       = NULL;\n   const char *libretro_path = path_get(RARCH_PATH_CORE);\n   bool success              = false;\n   char config_path[PATH_MAX_LENGTH];\n\n   config_path[0] = '\\0';\n\n   if (   string_is_empty(libretro_path)\n       || string_is_equal(libretro_path, \"builtin\"))\n      return;\n\n   /* Get config file path */\n   if (!config_file_salamander_get_path(\n         config_path, sizeof(config_path)))\n      return;\n\n   /* Open config file */\n   if (     !(conf = config_file_new_from_path_to_string(config_path))\n         && !(conf = config_file_new_alloc())\n      )\n      goto end;\n\n   /* Update config file */\n   config_set_path(conf, \"libretro_path\", libretro_path);\n\n   /* Save config file\n    * > Only one entry - no need to sort */\n   success = config_file_write(conf, config_path, false);\n\nend:\n   if (success)\n      RARCH_LOG(\"[Config]: Saving salamander config to: \\\"%s\\\".\\n\",\n            config_path);\n   else\n      RARCH_ERR(\"[Config]: Failed to create new salamander config file in: \\\"%s\\\".\\n\",\n            config_path);\n\n   if (conf)\n      config_file_free(conf);\n}\n#endif\n\nbool input_config_bind_map_get_valid(unsigned bind_index)\n{\n   const struct input_bind_map *keybind =\n      (const struct input_bind_map*)INPUT_CONFIG_BIND_MAP_GET(bind_index);\n   if (!keybind)\n      return false;\n   return keybind->valid;\n}\n\nunsigned input_config_bind_map_get_meta(unsigned bind_index)\n{\n   const struct input_bind_map *keybind =\n      (const struct input_bind_map*)INPUT_CONFIG_BIND_MAP_GET(bind_index);\n   if (!keybind)\n      return 0;\n   return keybind->meta;\n}\n\nconst char *input_config_bind_map_get_base(unsigned bind_index)\n{\n   const struct input_bind_map *keybind =\n      (const struct input_bind_map*)INPUT_CONFIG_BIND_MAP_GET(bind_index);\n   if (!keybind)\n      return NULL;\n   return keybind->base;\n}\n\nconst char *input_config_bind_map_get_desc(unsigned bind_index)\n{\n   const struct input_bind_map *keybind =\n      (const struct input_bind_map*)INPUT_CONFIG_BIND_MAP_GET(bind_index);\n   if (!keybind)\n      return NULL;\n   return msg_hash_to_str(keybind->desc);\n}\n\nuint8_t input_config_bind_map_get_retro_key(unsigned bind_index)\n{\n   const struct input_bind_map *keybind =\n      (const struct input_bind_map*)INPUT_CONFIG_BIND_MAP_GET(bind_index);\n   if (!keybind)\n      return 0;\n   return keybind->retro_key;\n}\n\nvoid input_config_reset_autoconfig_binds(unsigned port)\n{\n   unsigned i;\n\n   if (port >= MAX_USERS)\n      return;\n\n   for (i = 0; i < RARCH_BIND_LIST_END; i++)\n   {\n      input_autoconf_binds[port][i].joykey  = NO_BTN;\n      input_autoconf_binds[port][i].joyaxis = AXIS_NONE;\n\n      if (input_autoconf_binds[port][i].joykey_label)\n      {\n         free(input_autoconf_binds[port][i].joykey_label);\n         input_autoconf_binds[port][i].joykey_label = NULL;\n      }\n\n      if (input_autoconf_binds[port][i].joyaxis_label)\n      {\n         free(input_autoconf_binds[port][i].joyaxis_label);\n         input_autoconf_binds[port][i].joyaxis_label = NULL;\n      }\n   }\n}\n\nvoid input_config_set_autoconfig_binds(unsigned port, void *data)\n{\n   unsigned i;\n   config_file_t *config       = (config_file_t*)data;\n   struct retro_keybind *binds = NULL;\n\n   if (    (port >= MAX_USERS)\n         || !config)\n      return;\n\n   binds = input_autoconf_binds[port];\n\n   for (i = 0; i < RARCH_BIND_LIST_END; i++)\n   {\n      const struct input_bind_map *keybind =\n         (const struct input_bind_map*)INPUT_CONFIG_BIND_MAP_GET(i);\n      if (keybind)\n      {\n         char str[256];\n         const char *base = keybind->base;\n         fill_pathname_join_delim(str, \"input\", base,  '_', sizeof(str));\n\n         input_config_parse_joy_button(str, config, \"input\", base, &binds[i]);\n         input_config_parse_joy_axis  (str, config, \"input\", base, &binds[i]);\n      }\n   }\n}\n\nvoid input_config_parse_mouse_button(\n      char *s,\n      void *conf_data, const char *prefix,\n      const char *btn, void *bind_data)\n{\n   int val;\n   char tmp[64];\n   char key[64];\n   config_file_t *conf        = (config_file_t*)conf_data;\n   struct retro_keybind *bind = (struct retro_keybind*)bind_data;\n\n   tmp[0] = '\\0';\n\n   fill_pathname_join_delim(key, s, \"mbtn\", '_', sizeof(key));\n\n   if (config_get_array(conf, key, tmp, sizeof(tmp)))\n   {\n      bind->mbutton = NO_BTN;\n\n      if (tmp[0]=='w')\n      {\n         switch (tmp[1])\n         {\n            case 'u':\n               bind->mbutton = RETRO_DEVICE_ID_MOUSE_WHEELUP;\n               break;\n            case 'd':\n               bind->mbutton = RETRO_DEVICE_ID_MOUSE_WHEELDOWN;\n               break;\n            case 'h':\n               switch (tmp[2])\n               {\n                  case 'u':\n                     bind->mbutton = RETRO_DEVICE_ID_MOUSE_HORIZ_WHEELUP;\n                     break;\n                  case 'd':\n                     bind->mbutton = RETRO_DEVICE_ID_MOUSE_HORIZ_WHEELDOWN;\n                     break;\n               }\n               break;\n         }\n      }\n      else\n      {\n         val = atoi(tmp);\n         switch (val)\n         {\n            case 1:\n               bind->mbutton = RETRO_DEVICE_ID_MOUSE_LEFT;\n               break;\n            case 2:\n               bind->mbutton = RETRO_DEVICE_ID_MOUSE_RIGHT;\n               break;\n            case 3:\n               bind->mbutton = RETRO_DEVICE_ID_MOUSE_MIDDLE;\n               break;\n            case 4:\n               bind->mbutton = RETRO_DEVICE_ID_MOUSE_BUTTON_4;\n               break;\n            case 5:\n               bind->mbutton = RETRO_DEVICE_ID_MOUSE_BUTTON_5;\n               break;\n         }\n      }\n   }\n}\n\nvoid input_config_parse_joy_axis(\n      char *s,\n      void *conf_data, const char *prefix,\n      const char *axis, void *bind_data)\n{\n   char       tmp[64];\n   char       key[64];\n   char key_label[64];\n   config_file_t *conf                     = (config_file_t*)conf_data;\n   struct retro_keybind *bind              = (struct retro_keybind*)bind_data;\n   struct config_entry_list *tmp_a         = NULL;\n\n   tmp[0] = '\\0';\n\n   fill_pathname_join_delim(key, s,\n         \"axis\", '_', sizeof(key));\n   fill_pathname_join_delim(key_label, s,\n         \"axis_label\", '_', sizeof(key_label));\n\n   if (config_get_array(conf, key, tmp, sizeof(tmp)))\n   {\n      if (     tmp[0] == 'n'\n            && tmp[1] == 'u'\n            && tmp[2] == 'l'\n            && tmp[3] == '\\0'\n         )\n         bind->joyaxis = AXIS_NONE;\n      else if\n         (     tmp[0] != '\\0'\n          &&   tmp[1] != '\\0'\n          && (*tmp    == '+'\n          ||  *tmp    == '-'))\n      {\n         int i_axis = (int)strtol(tmp + 1, NULL, 0);\n         if (*tmp == '+')\n            bind->joyaxis = AXIS_POS(i_axis);\n         else\n            bind->joyaxis = AXIS_NEG(i_axis);\n      }\n\n      /* Ensure that D-pad emulation doesn't screw this over. */\n      bind->orig_joyaxis = bind->joyaxis;\n   }\n\n   tmp_a = config_get_entry(conf, key_label);\n\n   if (tmp_a && (!string_is_empty(tmp_a->value)))\n   {\n      if (bind->joyaxis_label &&\n            !string_is_empty(bind->joyaxis_label))\n         free(bind->joyaxis_label);\n      bind->joyaxis_label = strdup(tmp_a->value);\n   }\n}\n\nstatic uint16_t input_config_parse_hat(const char *dir)\n{\n   if (     dir[0] == 'u'\n         && dir[1] == 'p'\n         && dir[2] == '\\0'\n      )\n      return HAT_UP_MASK;\n   else if (\n            dir[0] == 'd'\n         && dir[1] == 'o'\n         && dir[2] == 'w'\n         && dir[3] == 'n'\n         && dir[4] == '\\0'\n         )\n      return HAT_DOWN_MASK;\n   else if (\n            dir[0] == 'l'\n         && dir[1] == 'e'\n         && dir[2] == 'f'\n         && dir[3] == 't'\n         && dir[4] == '\\0'\n         )\n      return HAT_LEFT_MASK;\n   else if (\n            dir[0] == 'r'\n         && dir[1] == 'i'\n         && dir[2] == 'g'\n         && dir[3] == 'h'\n         && dir[4] == 't'\n         && dir[5] == '\\0'\n         )\n      return HAT_RIGHT_MASK;\n\n   return 0;\n}\n\nvoid input_config_parse_joy_button(\n      char *s,\n      void *data, const char *prefix,\n      const char *btn, void *bind_data)\n{\n   char tmp[64];\n   char key[64];\n   char key_label[64];\n   config_file_t *conf                     = (config_file_t*)data;\n   struct retro_keybind *bind              = (struct retro_keybind*)bind_data;\n   struct config_entry_list *tmp_a         = NULL;\n\n   tmp[0]                                  = '\\0';\n\n   fill_pathname_join_delim(key, s,\n         \"btn\", '_', sizeof(key));\n   fill_pathname_join_delim(key_label, s,\n         \"btn_label\", '_', sizeof(key_label));\n\n   if (config_get_array(conf, key, tmp, sizeof(tmp)))\n   {\n      btn = tmp;\n      if (     btn[0] == 'n'\n            && btn[1] == 'u'\n            && btn[2] == 'l'\n            && btn[3] == '\\0'\n         )\n         bind->joykey = NO_BTN;\n      else\n      {\n         if (*btn == 'h')\n         {\n            const char *str = btn + 1;\n            /* Parse hat? */\n            if (str && ISDIGIT((int)*str))\n            {\n               char        *dir = NULL;\n               uint16_t     hat = strtoul(str, &dir, 0);\n               uint16_t hat_dir = dir ? input_config_parse_hat(dir) : 0;\n               if (hat_dir)\n                  bind->joykey = HAT_MAP(hat, hat_dir);\n            }\n         }\n         else\n            bind->joykey = strtoull(tmp, NULL, 0);\n      }\n   }\n\n   tmp_a = config_get_entry(conf, key_label);\n\n   if (tmp_a && !string_is_empty(tmp_a->value))\n   {\n      if (!string_is_empty(bind->joykey_label))\n         free(bind->joykey_label);\n\n      bind->joykey_label = strdup(tmp_a->value);\n   }\n}\n\nvoid retroarch_config_deinit(void)\n{\n   if (config_st)\n      free(config_st);\n   config_st = NULL;\n}\n\nvoid retroarch_config_init(void)\n{\n   if (!config_st)\n      config_st = (settings_t*)calloc(1, sizeof(settings_t));\n}\n"
        },
        {
          "name": "configuration.h",
          "type": "blob",
          "size": 39.4775390625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2016 - Daniel De Matteis\n *  Copyright (C) 2014-2016 - Jean-Andr Santoni\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __RARCH_CONFIGURATION_H__\n#define __RARCH_CONFIGURATION_H__\n\n#include <stdint.h>\n\n#include <boolean.h>\n#include <retro_common_api.h>\n#include <retro_miscellaneous.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"gfx/video_defines.h\"\n#include \"led/led_defines.h\"\n\n#ifdef HAVE_LAKKA\n#include \"lakka.h\"\n#endif\n\n#include \"msg_hash.h\"\n\n#define configuration_set_float(settings, var, newvar) \\\n{ \\\n   settings->flags |= SETTINGS_FLG_MODIFIED; \\\n   var              = newvar; \\\n}\n\n#define configuration_set_bool(settings, var, newvar) \\\n{ \\\n   settings->flags |= SETTINGS_FLG_MODIFIED; \\\n   var              = newvar; \\\n}\n\n#define configuration_set_uint(settings, var, newvar) \\\n{ \\\n   settings->flags |= SETTINGS_FLG_MODIFIED; \\\n   var              = newvar; \\\n}\n\n#define configuration_set_int(settings, var, newvar) \\\n{ \\\n   settings->flags |= SETTINGS_FLG_MODIFIED; \\\n   var              = newvar; \\\n}\n\n#define configuration_set_string(settings, var, newvar) \\\n{ \\\n   settings->flags |= SETTINGS_FLG_MODIFIED; \\\n   strlcpy(var, newvar, sizeof(var)); \\\n}\n\nRETRO_BEGIN_DECLS\n\nenum crt_switch_type\n{\n   CRT_SWITCH_NONE = 0,\n   CRT_SWITCH_15KHZ,\n   CRT_SWITCH_31KHZ,\n   CRT_SWITCH_32_120,\n   CRT_SWITCH_INI\n};\n\nenum override_type\n{\n   OVERRIDE_NONE = 0,\n   OVERRIDE_AS,\n   OVERRIDE_CORE,\n   OVERRIDE_CONTENT_DIR,\n   OVERRIDE_GAME\n};\n\nenum settings_glob_flags\n{\n   SETTINGS_FLG_MODIFIED              = (1 << 0),\n   SETTINGS_FLG_SKIP_WINDOW_POSITIONS = (1 << 1)\n};\n\ntypedef struct settings\n{\n   struct\n   {\n      size_t placeholder;\n      size_t rewind_buffer_size;\n   } sizes;\n\n   video_viewport_t video_vp_custom; /* int alignment */\n\n   struct\n   {\n      int placeholder;\n      int netplay_check_frames;\n      int location_update_interval_ms;\n      int location_update_interval_distance;\n      int state_slot;\n      int replay_slot;\n      int crt_switch_center_adjust;\n      int crt_switch_porch_adjust;\n#ifdef HAVE_VULKAN\n      int vulkan_gpu_index;\n#endif\n#ifdef HAVE_D3D10\n      int d3d10_gpu_index;\n#endif\n#ifdef HAVE_D3D11\n      int d3d11_gpu_index;\n#endif\n#ifdef HAVE_D3D12\n      int d3d12_gpu_index;\n#endif\n#ifdef HAVE_WINDOW_OFFSET\n      int video_window_offset_x;\n      int video_window_offset_y;\n#endif\n      int content_favorites_size;\n#ifdef _3DS\n      int bottom_font_color_red;\n      int bottom_font_color_green;\n      int bottom_font_color_blue;\n      int bottom_font_color_opacity;\n#endif\n#ifdef HAVE_XMB\n      int menu_xmb_title_margin;\n      int menu_xmb_title_margin_horizontal_offset;\n#endif\n#ifdef HAVE_OVERLAY\n      int input_overlay_lightgun_port;\n#endif\n   } ints;\n\n   struct\n   {\n      unsigned placeholder;\n\n      unsigned input_split_joycon[MAX_USERS];\n      unsigned input_joypad_index[MAX_USERS];\n      unsigned input_device[MAX_USERS];\n      unsigned input_mouse_index[MAX_USERS];\n\n      unsigned input_libretro_device[MAX_USERS];\n      unsigned input_analog_dpad_mode[MAX_USERS];\n      unsigned input_device_reservation_type[MAX_USERS];\n\n      unsigned input_remap_ports[MAX_USERS];\n      unsigned input_remap_ids[MAX_USERS][RARCH_CUSTOM_BIND_LIST_END];\n      unsigned input_keymapper_ids[MAX_USERS][RARCH_CUSTOM_BIND_LIST_END];\n      unsigned input_remap_port_map[MAX_USERS][MAX_USERS + 1];\n\n      unsigned led_map[MAX_LEDS];\n\n      unsigned audio_output_sample_rate;\n      unsigned audio_block_frames;\n      unsigned audio_latency;\n\n#ifdef HAVE_WASAPI\n      unsigned audio_wasapi_sh_buffer_length;\n#endif\n\n#ifdef HAVE_MICROPHONE\n      unsigned microphone_sample_rate;\n      unsigned microphone_block_frames;\n      unsigned microphone_latency;\n      unsigned microphone_resampler_quality;\n#ifdef HAVE_WASAPI\n      unsigned microphone_wasapi_sh_buffer_length;\n#endif\n#endif\n\n      unsigned fps_update_interval;\n      unsigned memory_update_interval;\n\n      unsigned input_block_timeout;\n\n      unsigned audio_resampler_quality;\n\n      unsigned input_turbo_period;\n      unsigned input_turbo_duty_cycle;\n      unsigned input_turbo_mode;\n      unsigned input_turbo_default_button;\n\n      unsigned input_bind_timeout;\n      unsigned input_bind_hold;\n#ifdef GEKKO\n      unsigned input_mouse_scale;\n#endif\n      unsigned input_touch_scale;\n      unsigned input_hotkey_block_delay;\n      unsigned input_quit_gamepad_combo;\n      unsigned input_menu_toggle_gamepad_combo;\n      unsigned input_keyboard_gamepad_mapping_type;\n      unsigned input_poll_type_behavior;\n      unsigned input_rumble_gain;\n      unsigned input_auto_game_focus;\n      unsigned input_max_users;\n\n      unsigned netplay_port;\n      unsigned netplay_max_connections;\n      unsigned netplay_max_ping;\n      unsigned netplay_chat_color_name;\n      unsigned netplay_chat_color_msg;\n      unsigned netplay_input_latency_frames_min;\n      unsigned netplay_input_latency_frames_range;\n      unsigned netplay_share_digital;\n      unsigned netplay_share_analog;\n      unsigned bundle_assets_extract_version_current;\n      unsigned bundle_assets_extract_last_version;\n      unsigned content_history_size;\n      unsigned frontend_log_level;\n      unsigned libretro_log_level;\n      unsigned rewind_granularity;\n      unsigned rewind_buffer_size_step;\n      unsigned autosave_interval;\n      unsigned replay_checkpoint_interval;\n      unsigned replay_max_keep;\n      unsigned savestate_max_keep;\n      unsigned network_cmd_port;\n      unsigned network_remote_base_port;\n      unsigned keymapper_port;\n      unsigned video_window_opacity;\n      unsigned crt_switch_resolution;\n      unsigned crt_switch_resolution_super;\n      unsigned screen_brightness;\n      unsigned video_monitor_index;\n      unsigned video_fullscreen_x;\n      unsigned video_fullscreen_y;\n      unsigned video_scale;\n      unsigned video_scale_integer_axis;\n      unsigned video_scale_integer_scaling;\n      unsigned video_max_swapchain_images;\n      unsigned video_max_frame_latency;\n      unsigned video_swap_interval;\n      unsigned video_hard_sync_frames;\n      unsigned video_frame_delay;\n      unsigned video_viwidth;\n      unsigned video_aspect_ratio_idx;\n      unsigned video_rotation;\n      unsigned screen_orientation;\n      unsigned video_msg_bgcolor_red;\n      unsigned video_msg_bgcolor_green;\n      unsigned video_msg_bgcolor_blue;\n      unsigned video_stream_port;\n      unsigned video_record_quality;\n      unsigned video_stream_quality;\n      unsigned video_record_scale_factor;\n      unsigned video_stream_scale_factor;\n      unsigned video_3ds_display_mode;\n      unsigned video_dingux_ipu_filter_type;\n      unsigned video_dingux_refresh_rate;\n      unsigned video_dingux_rs90_softfilter_type;\n#ifdef GEKKO\n      unsigned video_overscan_correction_top;\n      unsigned video_overscan_correction_bottom;\n#endif\n      unsigned video_shader_delay;\n#ifdef HAVE_SCREENSHOTS\n      unsigned notification_show_screenshot_duration;\n      unsigned notification_show_screenshot_flash;\n#endif\n\n      /* Accessibility */\n      unsigned accessibility_narrator_speech_speed;\n\n      unsigned menu_timedate_style;\n      unsigned menu_timedate_date_separator;\n      unsigned gfx_thumbnails;\n      unsigned menu_left_thumbnails;\n      unsigned menu_icon_thumbnails;\n      unsigned gfx_thumbnail_upscale_threshold;\n      unsigned menu_rgui_thumbnail_downscaler;\n      unsigned menu_rgui_thumbnail_delay;\n      unsigned menu_rgui_color_theme;\n      unsigned menu_xmb_animation_opening_main_menu;\n      unsigned menu_xmb_animation_horizontal_highlight;\n      unsigned menu_xmb_animation_move_up_down;\n      unsigned menu_xmb_layout;\n      unsigned menu_xmb_shader_pipeline;\n      unsigned menu_xmb_alpha_factor;\n      unsigned menu_xmb_theme;\n      unsigned menu_xmb_color_theme;\n      unsigned menu_xmb_thumbnail_scale_factor;\n      unsigned menu_xmb_vertical_fade_factor;\n      unsigned menu_materialui_color_theme;\n      unsigned menu_materialui_transition_animation;\n      unsigned menu_materialui_thumbnail_view_portrait;\n      unsigned menu_materialui_thumbnail_view_landscape;\n      unsigned menu_materialui_landscape_layout_optimization;\n      unsigned menu_ozone_color_theme;\n      unsigned menu_font_color_red;\n      unsigned menu_font_color_green;\n      unsigned menu_font_color_blue;\n      unsigned menu_rgui_internal_upscale_level;\n      unsigned menu_rgui_aspect_ratio;\n      unsigned menu_rgui_aspect_ratio_lock;\n      unsigned menu_rgui_particle_effect;\n      unsigned menu_ticker_type;\n      unsigned menu_scroll_delay;\n      unsigned menu_content_show_add_entry;\n      unsigned menu_content_show_contentless_cores;\n      unsigned menu_screensaver_timeout;\n      unsigned menu_screensaver_animation;\n      unsigned menu_remember_selection;\n\n      unsigned playlist_entry_remove_enable;\n      unsigned playlist_show_inline_core_name;\n      unsigned playlist_show_history_icons;\n      unsigned playlist_sublabel_runtime_type;\n      unsigned playlist_sublabel_last_played_style;\n\n      unsigned camera_width;\n      unsigned camera_height;\n\n#ifdef HAVE_OVERLAY\n      unsigned input_overlay_show_inputs;\n      unsigned input_overlay_show_inputs_port;\n      unsigned input_overlay_dpad_diagonal_sensitivity;\n      unsigned input_overlay_abxy_diagonal_sensitivity;\n      unsigned input_overlay_analog_recenter_zone;\n      unsigned input_overlay_lightgun_trigger_delay;\n      unsigned input_overlay_lightgun_two_touch_input;\n      unsigned input_overlay_lightgun_three_touch_input;\n      unsigned input_overlay_lightgun_four_touch_input;\n      unsigned input_overlay_mouse_hold_msec;\n      unsigned input_overlay_mouse_dtap_msec;\n#endif\n\n      unsigned run_ahead_frames;\n\n      unsigned midi_volume;\n      unsigned streaming_mode;\n\n      unsigned window_position_x;\n      unsigned window_position_y;\n      unsigned window_position_width;\n      unsigned window_position_height;\n      unsigned window_auto_width_max;\n      unsigned window_auto_height_max;\n\n      unsigned video_record_threads;\n\n      unsigned libnx_overclock;\n      unsigned ai_service_mode;\n      unsigned ai_service_target_lang;\n      unsigned ai_service_source_lang;\n\n      unsigned core_updater_auto_backup_history_size;\n      unsigned video_black_frame_insertion;\n      unsigned video_bfi_dark_frames;\n      unsigned video_shader_subframes;\n      unsigned video_autoswitch_refresh_rate;\n      unsigned quit_on_close_content;\n\n#ifdef HAVE_LAKKA\n      unsigned cpu_scaling_mode;\n      unsigned cpu_min_freq;\n      unsigned cpu_max_freq;\n#endif\n\n#ifdef HAVE_MIST\n      unsigned steam_rich_presence_format;\n#endif\n\n      unsigned cheevos_appearance_anchor;\n      unsigned cheevos_visibility_summary;\n   } uints;\n\n   struct\n   {\n      float placeholder;\n      float video_aspect_ratio;\n      float video_vp_bias_x;\n      float video_vp_bias_y;\n#if defined(RARCH_MOBILE)\n      float video_vp_bias_portrait_x;\n      float video_vp_bias_portrait_y;\n#endif\n      float video_refresh_rate;\n      float video_autoswitch_pal_threshold;\n      float crt_video_refresh_rate;\n      float video_font_size;\n      float video_msg_pos_x;\n      float video_msg_pos_y;\n      float video_msg_color_r;\n      float video_msg_color_g;\n      float video_msg_color_b;\n      float video_msg_bgcolor_opacity;\n      float video_hdr_max_nits;\n      float video_hdr_paper_white_nits;\n      float video_hdr_display_contrast;\n\n      float menu_scale_factor;\n      float menu_widget_scale_factor;\n      float menu_widget_scale_factor_windowed;\n      float menu_wallpaper_opacity;\n      float menu_framebuffer_opacity;\n      float menu_footer_opacity;\n      float menu_header_opacity;\n      float menu_ticker_speed;\n      float menu_rgui_particle_effect_speed;\n      float menu_screensaver_animation_speed;\n      float ozone_thumbnail_scale_factor;\n\n      float cheevos_appearance_padding_h;\n      float cheevos_appearance_padding_v;\n\n      float audio_max_timing_skew;\n      float audio_volume; /* dB scale. */\n      float audio_mixer_volume; /* dB scale. */\n\n      float input_overlay_opacity;\n      float input_osk_overlay_opacity;\n\n      float input_overlay_scale_landscape;\n      float input_overlay_aspect_adjust_landscape;\n      float input_overlay_x_separation_landscape;\n      float input_overlay_y_separation_landscape;\n      float input_overlay_x_offset_landscape;\n      float input_overlay_y_offset_landscape;\n\n      float input_overlay_scale_portrait;\n      float input_overlay_aspect_adjust_portrait;\n      float input_overlay_x_separation_portrait;\n      float input_overlay_y_separation_portrait;\n      float input_overlay_x_offset_portrait;\n      float input_overlay_y_offset_portrait;\n\n      float input_overlay_mouse_speed;\n      float input_overlay_mouse_swipe_threshold;\n\n      float slowmotion_ratio;\n      float fastforward_ratio;\n      float input_analog_deadzone;\n      float input_axis_threshold;\n      float input_analog_sensitivity;\n#ifdef _3DS\n      float bottom_font_scale;\n#endif\n   } floats;\n\n   struct\n   {\n      char placeholder;\n\n      char video_driver[32];\n      char record_driver[32];\n      char camera_driver[32];\n      char bluetooth_driver[32];\n      char wifi_driver[32];\n      char led_driver[32];\n      char location_driver[32];\n      char cloud_sync_driver[32];\n      char menu_driver[32];\n      char cheevos_username[32];\n      char cheevos_token[32];\n      char cheevos_leaderboards_enable[32];\n      char video_context_driver[32];\n      char audio_driver[32];\n      char audio_resampler[32];\n      char input_driver[32];\n      char input_joypad_driver[32];\n      char midi_driver[32];\n      char midi_input[32];\n      char midi_output[32];\n#ifdef HAVE_LAKKA\n      char cpu_main_gov[32];\n      char cpu_menu_gov[32];\n#endif\n#ifdef HAVE_MICROPHONE\n      char microphone_driver[32];\n      char microphone_resampler[32];\n#endif\n      char input_keyboard_layout[64];\n      char cheevos_custom_host[64];\n\n#ifdef HAVE_LAKKA\n      char timezone[TIMEZONE_LENGTH];\n#endif\n\n      char cheevos_password[NAME_MAX_LENGTH];\n#ifdef HAVE_MICROPHONE\n      char microphone_device[NAME_MAX_LENGTH];\n#endif\n#ifdef ANDROID\n      char input_android_physical_keyboard[NAME_MAX_LENGTH];\n#endif\n      char audio_device[NAME_MAX_LENGTH];\n      char camera_device[NAME_MAX_LENGTH];\n      char netplay_mitm_server[NAME_MAX_LENGTH];\n      char webdav_url[NAME_MAX_LENGTH];\n      char webdav_username[NAME_MAX_LENGTH];\n      char webdav_password[NAME_MAX_LENGTH];\n\n      char crt_switch_timings[NAME_MAX_LENGTH];\n      char input_reserved_devices[MAX_USERS][NAME_MAX_LENGTH];\n\n      char youtube_stream_key[PATH_MAX_LENGTH];\n      char twitch_stream_key[PATH_MAX_LENGTH];\n      char facebook_stream_key[PATH_MAX_LENGTH];\n      char discord_app_id[PATH_MAX_LENGTH];\n      char ai_service_url[PATH_MAX_LENGTH];\n\n      char translation_service_url[2048]; /* TODO/FIXME - check size */\n   } arrays;\n\n   struct\n   {\n      char placeholder;\n\n      char username[32];\n\n      char netplay_password[128];\n      char netplay_spectate_password[128];\n\n      char streaming_title[512]; /* TODO/FIXME - check size */\n\n      char netplay_server[NAME_MAX_LENGTH];\n      char netplay_custom_mitm_server[NAME_MAX_LENGTH];\n      char network_buildbot_url[NAME_MAX_LENGTH];\n      char network_buildbot_assets_url[NAME_MAX_LENGTH];\n      char menu_content_show_settings_password[NAME_MAX_LENGTH];\n      char kiosk_mode_password[NAME_MAX_LENGTH];\n\n      char bundle_assets_dst_subdir[DIR_MAX_LENGTH];\n      char directory_audio_filter[DIR_MAX_LENGTH];\n      char directory_autoconfig[DIR_MAX_LENGTH];\n      char directory_video_filter[DIR_MAX_LENGTH];\n      char directory_video_shader[DIR_MAX_LENGTH];\n      char directory_libretro[DIR_MAX_LENGTH];\n      char directory_input_remapping[DIR_MAX_LENGTH];\n      char directory_overlay[DIR_MAX_LENGTH];\n      char directory_osk_overlay[DIR_MAX_LENGTH];\n      char directory_screenshot[DIR_MAX_LENGTH];\n      char directory_system[DIR_MAX_LENGTH];\n      char directory_cache[DIR_MAX_LENGTH];\n      char directory_playlist[DIR_MAX_LENGTH];\n      char directory_content_favorites[DIR_MAX_LENGTH];\n      char directory_content_history[DIR_MAX_LENGTH];\n      char directory_content_image_history[DIR_MAX_LENGTH];\n      char directory_content_music_history[DIR_MAX_LENGTH];\n      char directory_content_video_history[DIR_MAX_LENGTH];\n      char directory_runtime_log[DIR_MAX_LENGTH];\n      char directory_core_assets[DIR_MAX_LENGTH];\n      char directory_assets[DIR_MAX_LENGTH];\n      char directory_dynamic_wallpapers[DIR_MAX_LENGTH];\n      char directory_thumbnails[DIR_MAX_LENGTH];\n      char directory_menu_config[DIR_MAX_LENGTH];\n      char directory_menu_content[DIR_MAX_LENGTH];\n#ifdef _3DS\n      char directory_bottom_assets[DIR_MAX_LENGTH];\n#endif\n      char log_dir[DIR_MAX_LENGTH];\n\n#ifdef HAVE_TEST_DRIVERS\n      char test_input_file_joypad[PATH_MAX_LENGTH];\n      char test_input_file_general[PATH_MAX_LENGTH];\n#endif\n      char bundle_assets_src[PATH_MAX_LENGTH];\n      char bundle_assets_dst[PATH_MAX_LENGTH];\n      char path_menu_xmb_font[PATH_MAX_LENGTH];\n      char path_cheat_database[PATH_MAX_LENGTH];\n      char path_content_database[PATH_MAX_LENGTH];\n      char path_overlay[PATH_MAX_LENGTH];\n      char path_osk_overlay[PATH_MAX_LENGTH];\n      char path_record_config[PATH_MAX_LENGTH];\n      char path_stream_config[PATH_MAX_LENGTH];\n      char path_menu_wallpaper[PATH_MAX_LENGTH];\n      char path_audio_dsp_plugin[PATH_MAX_LENGTH];\n      char path_softfilter_plugin[PATH_MAX_LENGTH];\n      char path_core_options[PATH_MAX_LENGTH];\n      char path_content_favorites[PATH_MAX_LENGTH];\n      char path_content_history[PATH_MAX_LENGTH];\n      char path_content_image_history[PATH_MAX_LENGTH];\n      char path_content_music_history[PATH_MAX_LENGTH];\n      char path_content_video_history[PATH_MAX_LENGTH];\n      char path_libretro_info[PATH_MAX_LENGTH];\n      char path_cheat_settings[PATH_MAX_LENGTH];\n      char path_font[PATH_MAX_LENGTH];\n      char path_rgui_theme_preset[PATH_MAX_LENGTH];\n      char app_icon[PATH_MAX_LENGTH];\n\n      char browse_url[4096];      /* TODO/FIXME - check size */\n      char path_stream_url[8192]; /* TODO/FIXME - check size */\n   } paths;\n\n\n   struct\n   {\n      bool placeholder;\n\n      /* Video */\n      bool video_fullscreen;\n      bool video_windowed_fullscreen;\n      bool video_vsync;\n      bool video_adaptive_vsync;\n      bool video_hard_sync;\n      bool video_waitable_swapchains;\n      bool video_vfilter;\n      bool video_smooth;\n      bool video_ctx_scaling;\n      bool video_force_aspect;\n      bool video_frame_delay_auto;\n      bool video_crop_overscan;\n      bool video_aspect_ratio_auto;\n      bool video_dingux_ipu_keep_aspect;\n      bool video_scale_integer;\n      bool video_shader_enable;\n      bool video_shader_watch_files;\n      bool video_shader_remember_last_dir;\n      bool video_shader_preset_save_reference_enable;\n      bool video_scan_subframes;\n      bool video_threaded;\n      bool video_font_enable;\n      bool video_disable_composition;\n      bool video_post_filter_record;\n      bool video_gpu_record;\n      bool video_gpu_screenshot;\n      bool video_allow_rotate;\n      bool video_shared_context;\n      bool video_force_srgb_disable;\n      bool video_fps_show;\n      bool video_statistics_show;\n      bool video_framecount_show;\n      bool video_memory_show;\n      bool video_msg_bgcolor_enable;\n#ifdef _3DS\n      bool video_3ds_lcd_bottom;\n#endif\n      bool video_wiiu_prefer_drc;\n      bool video_notch_write_over_enable;\n      bool video_hdr_enable;\n      bool video_hdr_expand_gamut;\n\n      /* Accessibility */\n      bool accessibility_enable;\n\n      /* Audio */\n      bool audio_enable;\n      bool audio_enable_menu;\n      bool audio_enable_menu_ok;\n      bool audio_enable_menu_cancel;\n      bool audio_enable_menu_notice;\n      bool audio_enable_menu_bgm;\n      bool audio_enable_menu_scroll;\n      bool audio_sync;\n      bool audio_rate_control;\n      bool audio_fastforward_mute;\n      bool audio_fastforward_speedup;\n#ifdef IOS\n      bool audio_respect_silent_mode;\n#endif\n\n#ifdef HAVE_WASAPI\n      bool audio_wasapi_exclusive_mode;\n      bool audio_wasapi_float_format;\n#endif\n\n#ifdef HAVE_MICROPHONE\n      /* Microphone */\n      bool microphone_enable;\n#ifdef HAVE_WASAPI\n      bool microphone_wasapi_exclusive_mode;\n      bool microphone_wasapi_float_format;\n#endif\n#endif\n\n      /* Input */\n      bool input_remap_binds_enable;\n      bool input_remap_sort_by_controller_enable;\n      bool input_autodetect_enable;\n      bool input_sensors_enable;\n      bool input_overlay_enable;\n      bool input_overlay_enable_autopreferred;\n      bool input_overlay_behind_menu;\n      bool input_overlay_hide_in_menu;\n      bool input_overlay_hide_when_gamepad_connected;\n      bool input_overlay_show_mouse_cursor;\n      bool input_overlay_auto_rotate;\n      bool input_overlay_auto_scale;\n      bool input_osk_overlay_auto_scale;\n      bool input_overlay_pointer_enable;\n      bool input_overlay_lightgun_trigger_on_touch;\n      bool input_overlay_lightgun_allow_offscreen;\n      bool input_overlay_mouse_hold_to_drag;\n      bool input_overlay_mouse_dtap_to_drag;\n      bool input_descriptor_label_show;\n      bool input_descriptor_hide_unbound;\n      bool input_all_users_control_menu;\n      bool input_menu_swap_ok_cancel_buttons;\n      bool input_menu_swap_scroll_buttons;\n      bool input_backtouch_enable;\n      bool input_backtouch_toggle;\n      bool input_small_keyboard_enable;\n      bool input_keyboard_gamepad_enable;\n      bool input_auto_mouse_grab;\n      bool input_allow_turbo_dpad;\n      bool input_hotkey_device_merge;\n#if defined(HAVE_DINPUT) || defined(HAVE_WINRAWINPUT)\n      bool input_nowinkey_enable;\n#endif\n#ifdef UDEV_TOUCH_SUPPORT\n      bool input_touch_vmouse_pointer;\n      bool input_touch_vmouse_mouse;\n      bool input_touch_vmouse_touchpad;\n      bool input_touch_vmouse_trackball;\n      bool input_touch_vmouse_gesture;\n#endif\n\n      /* Frame time counter */\n      bool frame_time_counter_reset_after_fastforwarding;\n      bool frame_time_counter_reset_after_load_state;\n      bool frame_time_counter_reset_after_save_state;\n\n      /* Menu */\n      bool filter_by_current_core;\n      bool menu_enable_widgets;\n      bool menu_show_load_content_animation;\n      bool notification_show_autoconfig;\n      bool notification_show_cheats_applied;\n      bool notification_show_patch_applied;\n      bool notification_show_remap_load;\n      bool notification_show_config_override_load;\n      bool notification_show_set_initial_disk;\n      bool notification_show_disk_control;\n      bool notification_show_save_state;\n      bool notification_show_fast_forward;\n#ifdef HAVE_SCREENSHOTS\n      bool notification_show_screenshot;\n#endif\n      bool notification_show_refresh_rate;\n      bool notification_show_netplay_extra;\n#ifdef HAVE_MENU\n      bool notification_show_when_menu_is_alive;\n#endif\n      bool menu_widget_scale_auto;\n      bool menu_show_start_screen;\n      bool menu_pause_libretro;\n      bool menu_savestate_resume;\n      bool menu_insert_disk_resume;\n      bool menu_timedate_enable;\n      bool menu_battery_level_enable;\n      bool menu_core_enable;\n      bool menu_show_sublabels;\n      bool menu_dynamic_wallpaper_enable;\n      bool menu_mouse_enable;\n      bool menu_pointer_enable;\n      bool menu_navigation_wraparound_enable;\n      bool menu_navigation_browser_filter_supported_extensions_enable;\n      bool menu_show_advanced_settings;\n      bool menu_linear_filter;\n      bool menu_horizontal_animation;\n      bool menu_scroll_fast;\n      bool menu_show_online_updater;\n#ifdef HAVE_MIST\n      bool menu_show_core_manager_steam;\n#endif\n      bool menu_show_core_updater;\n      bool menu_show_load_core;\n      bool menu_show_load_content;\n      bool menu_show_load_disc;\n      bool menu_show_dump_disc;\n#ifdef HAVE_LAKKA\n      bool menu_show_eject_disc;\n#endif\n      bool menu_show_information;\n      bool menu_show_configurations;\n      bool menu_show_help;\n      bool menu_show_quit_retroarch;\n      bool menu_show_restart_retroarch;\n      bool menu_show_reboot;\n      bool menu_show_shutdown;\n      bool menu_show_latency;\n      bool menu_show_rewind;\n      bool menu_show_overlays;\n#if 0\n/* Thumbnailpack removal */\n      bool menu_show_legacy_thumbnail_updater;\n#endif\n      bool menu_materialui_icons_enable;\n      bool menu_materialui_playlist_icons_enable;\n      bool menu_materialui_switch_icons;\n      bool menu_materialui_show_nav_bar;\n      bool menu_materialui_auto_rotate_nav_bar;\n      bool menu_materialui_dual_thumbnail_list_view_enable;\n      bool menu_materialui_thumbnail_background_enable;\n      bool menu_rgui_background_filler_thickness_enable;\n      bool menu_rgui_border_filler_thickness_enable;\n      bool menu_rgui_border_filler_enable;\n      bool menu_rgui_full_width_layout;\n      bool menu_rgui_transparency;\n      bool menu_rgui_shadows;\n      bool menu_rgui_inline_thumbnails;\n      bool menu_rgui_swap_thumbnails;\n      bool menu_rgui_extended_ascii;\n      bool menu_rgui_switch_icons;\n      bool menu_rgui_particle_effect_screensaver;\n      bool menu_xmb_shadows_enable;\n      bool menu_xmb_show_title_header;\n      bool menu_xmb_switch_icons;\n      bool menu_xmb_vertical_thumbnails;\n      bool menu_content_show_settings;\n      bool menu_content_show_favorites;\n      bool menu_content_show_images;\n      bool menu_content_show_music;\n      bool menu_content_show_video;\n      bool menu_content_show_netplay;\n      bool menu_content_show_history;\n      bool menu_content_show_add;\n      bool menu_content_show_playlists;\n      bool menu_content_show_explore;\n      bool menu_use_preferred_system_color_theme;\n      bool menu_preferred_system_color_theme_set;\n      bool menu_unified_controls;\n      bool menu_disable_info_button;\n      bool menu_disable_search_button;\n      bool menu_disable_left_analog;\n      bool menu_disable_right_analog;\n      bool menu_ticker_smooth;\n      bool settings_show_drivers;\n      bool settings_show_video;\n      bool settings_show_audio;\n      bool settings_show_input;\n      bool settings_show_latency;\n      bool settings_show_core;\n      bool settings_show_configuration;\n      bool settings_show_saving;\n      bool settings_show_logging;\n      bool settings_show_file_browser;\n      bool settings_show_frame_throttle;\n      bool settings_show_recording;\n      bool settings_show_onscreen_display;\n      bool settings_show_user_interface;\n      bool settings_show_ai_service;\n      bool settings_show_accessibility;\n      bool settings_show_power_management;\n      bool settings_show_achievements;\n      bool settings_show_network;\n      bool settings_show_playlists;\n      bool settings_show_user;\n      bool settings_show_directory;\n#ifdef HAVE_MIST\n      bool settings_show_steam;\n#endif\n      bool quick_menu_show_resume_content;\n      bool quick_menu_show_restart_content;\n      bool quick_menu_show_close_content;\n      bool quick_menu_show_take_screenshot;\n      bool quick_menu_show_savestate_submenu;\n      bool quick_menu_show_save_load_state;\n      bool quick_menu_show_replay;\n      bool quick_menu_show_undo_save_load_state;\n      bool quick_menu_show_add_to_favorites;\n      bool quick_menu_show_add_to_playlist;\n      bool quick_menu_show_start_recording;\n      bool quick_menu_show_start_streaming;\n      bool quick_menu_show_set_core_association;\n      bool quick_menu_show_reset_core_association;\n      bool quick_menu_show_options;\n      bool quick_menu_show_core_options_flush;\n      bool quick_menu_show_controls;\n      bool quick_menu_show_cheats;\n      bool quick_menu_show_shaders;\n      bool quick_menu_show_save_core_overrides;\n      bool quick_menu_show_save_game_overrides;\n      bool quick_menu_show_save_content_dir_overrides;\n      bool quick_menu_show_information;\n      bool quick_menu_show_recording;\n      bool quick_menu_show_streaming;\n      bool quick_menu_show_download_thumbnails;\n      bool kiosk_mode_enable;\n\n      bool crt_switch_custom_refresh_enable;\n      bool crt_switch_hires_menu;\n\n      /* Netplay */\n      bool netplay_show_only_connectable;\n      bool netplay_show_only_installed_cores;\n      bool netplay_show_passworded;\n      bool netplay_public_announce;\n      bool netplay_start_as_spectator;\n      bool netplay_fade_chat;\n      bool netplay_allow_pausing;\n      bool netplay_allow_slaves;\n      bool netplay_require_slaves;\n      bool netplay_nat_traversal;\n      bool netplay_use_mitm_server;\n      bool netplay_request_devices[MAX_USERS];\n      bool netplay_ping_show;\n\n      /* Network */\n      bool network_buildbot_auto_extract_archive;\n      bool network_buildbot_show_experimental_cores;\n      bool network_on_demand_thumbnails;\n      bool core_updater_auto_backup;\n\n      /* UI */\n      bool ui_menubar_enable;\n      bool ui_suspend_screensaver_enable;\n      bool ui_companion_start_on_boot;\n      bool ui_companion_enable;\n      bool ui_companion_toggle;\n      bool desktop_menu_enable;\n\n      /* Cheevos */\n      bool cheevos_enable;\n      bool cheevos_test_unofficial;\n      bool cheevos_hardcore_mode_enable;\n      bool cheevos_richpresence_enable;\n      bool cheevos_badges_enable;\n      bool cheevos_verbose_enable;\n      bool cheevos_auto_screenshot;\n      bool cheevos_start_active;\n      bool cheevos_unlock_sound_enable;\n      bool cheevos_challenge_indicators;\n      bool cheevos_appearance_padding_auto;\n      bool cheevos_visibility_unlock;\n      bool cheevos_visibility_mastery;\n      bool cheevos_visibility_account;\n      bool cheevos_visibility_lboard_start;\n      bool cheevos_visibility_lboard_submit;\n      bool cheevos_visibility_lboard_cancel;\n      bool cheevos_visibility_lboard_trackers;\n      bool cheevos_visibility_progress_tracker;\n\n      /* Camera */\n      bool camera_allow;\n\n      /* Bluetooth */\n      bool bluetooth_allow;\n\n      /* WiFi */\n      bool wifi_allow;\n      bool wifi_enabled;\n\n      /* Location */\n      bool location_allow;\n\n      /* Multimedia */\n      bool multimedia_builtin_mediaplayer_enable;\n      bool multimedia_builtin_imageviewer_enable;\n\n      /* Bundle */\n      bool bundle_finished;\n      bool bundle_assets_extract_enable;\n\n      /* Driver */\n      bool driver_switch_enable;\n\n#ifdef HAVE_MIST\n      /* Steam */\n      bool steam_rich_presence_enable;\n#endif\n\n      /* Cloud Sync */\n      bool cloud_sync_enable;\n      bool cloud_sync_destructive;\n      bool cloud_sync_sync_saves;\n      bool cloud_sync_sync_configs;\n      bool cloud_sync_sync_thumbs;\n      bool cloud_sync_sync_system;\n\n      /* Misc. */\n      bool discord_enable;\n      bool threaded_data_runloop_enable;\n      bool set_supports_no_game_enable;\n      bool auto_screenshot_filename;\n      bool history_list_enable;\n      bool playlist_entry_rename;\n      bool rewind_enable;\n      bool fastforward_frameskip;\n      bool vrr_runloop_enable;\n      bool menu_throttle_framerate;\n      bool apply_cheats_after_toggle;\n      bool apply_cheats_after_load;\n      bool run_ahead_enabled;\n      bool run_ahead_secondary_instance;\n      bool run_ahead_hide_warnings;\n      bool preemptive_frames_enable;\n      bool pause_nonactive;\n      bool pause_on_disconnect;\n      bool block_sram_overwrite;\n      bool replay_auto_index;\n      bool savestate_auto_index;\n      bool savestate_auto_save;\n      bool savestate_auto_load;\n      bool savestate_thumbnail_enable;\n      bool save_file_compression;\n      bool savestate_file_compression;\n      bool network_cmd_enable;\n      bool stdin_cmd_enable;\n      bool keymapper_enable;\n      bool network_remote_enable;\n      bool network_remote_enable_user[MAX_USERS];\n      bool load_dummy_on_core_shutdown;\n      bool check_firmware_before_loading;\n      bool core_option_category_enable;\n      bool core_info_cache_enable;\n      bool core_info_savestate_bypass;\n#ifndef HAVE_DYNAMIC\n      bool always_reload_core_on_run_content;\n#endif\n\n      bool game_specific_options;\n      bool auto_overrides_enable;\n      bool auto_remaps_enable;\n      bool initial_disk_change_enable;\n      bool global_core_options;\n      bool auto_shaders_enable;\n\n      bool sort_savefiles_enable;\n      bool sort_savestates_enable;\n      bool sort_savefiles_by_content_enable;\n      bool sort_savestates_by_content_enable;\n      bool sort_screenshots_by_content_enable;\n      bool config_save_on_exit;\n      bool remap_save_on_exit;\n      bool show_hidden_files;\n      bool use_last_start_directory;\n\n      bool savefiles_in_content_dir;\n      bool savestates_in_content_dir;\n      bool screenshots_in_content_dir;\n      bool systemfiles_in_content_dir;\n      bool ssh_enable;\n#ifdef HAVE_LAKKA_SWITCH\n      bool switch_oc;\n      bool switch_cec;\n      bool bluetooth_ertm_disable;\n#endif\n      bool samba_enable;\n      bool bluetooth_enable;\n      bool localap_enable;\n\n      bool video_window_show_decorations;\n      bool video_window_save_positions;\n      bool video_window_custom_size_enable;\n\n      bool sustained_performance_mode;\n      bool playlist_use_old_format;\n      bool playlist_compression;\n      bool content_runtime_log;\n      bool content_runtime_log_aggregate;\n\n      bool playlist_sort_alphabetical;\n      bool playlist_show_sublabels;\n      bool playlist_show_entry_idx;\n      bool playlist_fuzzy_archive_match;\n      bool playlist_portable_paths;\n      bool playlist_use_filename;\n      bool playlist_allow_non_png;\n\n      bool quit_press_twice;\n      bool vibrate_on_keypress;\n      bool enable_device_vibration;\n      bool ozone_collapse_sidebar;\n      bool ozone_truncate_playlist_name;\n      bool ozone_sort_after_truncate_playlist_name;\n      bool ozone_scroll_content_metadata;\n\n      bool log_to_file;\n      bool log_to_file_timestamp;\n\n      bool scan_without_core_match;\n      bool scan_serial_and_crc;\n\n      bool ai_service_enable;\n      bool ai_service_pause;\n\n      bool gamemode_enable;\n#ifdef _3DS\n      bool new3ds_speedup_enable;\n      bool bottom_font_enable;\n#endif\n\n#ifdef ANDROID\n      bool android_input_disconnect_workaround;\n#endif\n\n#if defined(HAVE_COCOATOUCH)\n      bool gcdwebserver_alert;\n#endif\n   } bools;\n\n   uint8_t flags;\n\n} settings_t;\n\n/**\n * config_get_default_camera:\n *\n * Gets default camera driver.\n *\n * Returns: Default camera driver.\n **/\nconst char *config_get_default_camera(void);\n\n/**\n * config_get_default_bluetooth:\n *\n * Gets default bluetooth driver.\n *\n * Returns: Default bluetooth driver.\n **/\nconst char *config_get_default_bluetooth(void);\n\n/**\n * config_get_default_wifi:\n *\n * Gets default wifi driver.\n *\n * Returns: Default wifi driver.\n **/\nconst char *config_get_default_wifi(void);\n\n/**\n * config_get_default_location:\n *\n * Gets default location driver.\n *\n * Returns: Default location driver.\n **/\nconst char *config_get_default_location(void);\n\n/**\n * config_get_default_video:\n *\n * Gets default video driver.\n *\n * Returns: Default video driver.\n **/\nconst char *config_get_default_video(void);\n\n/**\n * config_get_default_audio:\n *\n * Gets default audio driver.\n *\n * Returns: Default audio driver.\n **/\nconst char *config_get_default_audio(void);\n\n#if defined(HAVE_MICROPHONE)\n/**\n * config_get_default_microphone:\n *\n * Gets default microphone driver.\n *\n * Returns: Default microphone driver.\n **/\nconst char *config_get_default_microphone(void);\n#endif\n\n/**\n * config_get_default_audio_resampler:\n *\n * Gets default audio resampler driver.\n *\n * Returns: Default audio resampler driver.\n **/\nconst char *config_get_default_audio_resampler(void);\n\n/**\n * config_get_default_input:\n *\n * Gets default input driver.\n *\n * Returns: Default input driver.\n **/\nconst char *config_get_default_input(void);\n\n/**\n * config_get_default_joypad:\n *\n * Gets default input joypad driver.\n *\n * Returns: Default input joypad driver.\n **/\nconst char *config_get_default_joypad(void);\n\n/**\n * config_get_default_menu:\n *\n * Gets default menu driver.\n *\n * Returns: Default menu driver.\n **/\nconst char *config_get_default_menu(void);\n\nconst char *config_get_default_midi(void);\nconst char *config_get_midi_driver_options(void);\n\nconst char *config_get_default_record(void);\n\n#ifdef HAVE_CONFIGFILE\n/**\n * config_load_override:\n *\n * Tries to append game-specific and core-specific configuration.\n * These settings will always have precedence, thus this feature\n * can be used to enforce overrides.\n *\n * Returns: false if there was an error or no action was performed.\n *\n */\nbool config_load_override(void *data);\n\n/**\n * config_load_override_file:\n *\n * Tries to load specified configuration file.\n * These settings will always have precedence, thus this feature\n * can be used to enforce overrides.\n *\n * Returns: false if there was an error or no action was performed.\n *\n */\nbool config_load_override_file(const char *path);\n\n/**\n * config_unload_override:\n *\n * Unloads configuration overrides if overrides are active.\n *\n *\n * Returns: false if there was an error.\n */\nbool config_unload_override(void);\n\n/**\n * config_load_remap:\n *\n * Tries to append game-specific and core-specific remap files.\n *\n * Returns: false if there was an error or no action was performed.\n *\n */\nbool config_load_remap(const char *directory_input_remapping,\n      void *data);\n\n/**\n * config_get_autoconf_profile_filename:\n * @device_name       : Input device name\n * @user              : Controller number to save\n * Fills buf with the autoconf profile file name (including driver dir if needed).\n **/\n\nvoid config_get_autoconf_profile_filename(\n      const char *device_name, unsigned user,\n      char *buf, size_t len_buf);\n/**\n * config_save_autoconf_profile:\n * @device_name       : Input device name\n * @user              : Controller number to save\n * Writes a controller autoconf file to disk.\n **/\nbool config_save_autoconf_profile(const char *device_name, unsigned user);\n\n/**\n * config_save_file:\n * @path            : Path that shall be written to.\n *\n * Writes a config file to disk.\n *\n * Returns: true (1) on success, otherwise returns false (0).\n **/\nbool config_save_file(const char *path);\n\n/**\n * config_save_overrides:\n * @path            : Path that shall be written to.\n *\n * Writes a config file override to disk.\n *\n * Returns: true (1) on success, (-1) if nothing to write, otherwise returns false (0).\n **/\nint8_t config_save_overrides(enum override_type type,\n      void *data, bool remove, const char *path);\n\n/* Replaces currently loaded configuration file with\n * another one. Will load a dummy core to flush state\n * properly. */\nbool config_replace(bool config_save_on_exit, char *path);\n#endif\n\nbool config_overlay_enable_default(void);\n\nvoid config_set_defaults(void *data);\n\nvoid config_load(void *data);\n\n#if !defined(HAVE_DYNAMIC)\n/* Salamander config file contains a single\n * entry (libretro_path), which is linked to\n * RARCH_PATH_CORE\n * > Used to select which core to load\n *   when launching a salamander build */\nvoid config_load_file_salamander(void);\nvoid config_save_file_salamander(void);\n#endif\n\nvoid retroarch_config_init(void);\n\nvoid retroarch_config_deinit(void);\n\nsettings_t *config_get_ptr(void);\n\n#ifdef HAVE_LAKKA\nconst char *config_get_all_timezones(void);\nvoid config_set_timezone(char *timezone);\n#endif\n\nbool input_config_bind_map_get_valid(unsigned bind_index);\n\nvoid input_config_parse_joy_button(\n      char *s,\n      void *data, const char *prefix,\n      const char *btn, void *bind_data);\n\nvoid input_config_parse_joy_axis(\n      char *s,\n      void *conf_data, const char *prefix,\n      const char *axis, void *bind_data);\n\nvoid input_config_parse_mouse_button(\n      char *s,\n      void *conf_data, const char *prefix,\n      const char *btn, void *bind_data);\n\nconst char *input_config_get_prefix(unsigned user, bool meta);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 0.15234375,
          "content": "#!/bin/sh\n\nPACKAGE_NAME=retroarch\n\n. qb/qb.init.sh\n\n. qb/qb.params.sh\n\n. qb/qb.system.sh\n\n. qb/qb.comp.sh\n\n. qb/qb.libs.sh\n\n. qb/qb.moc.sh\n\n. qb/qb.make.sh\n"
        },
        {
          "name": "content.h",
          "type": "blob",
          "size": 4.677734375,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __RARCH_FILE_H\n#define __RARCH_FILE_H\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <sys/types.h>\n\n#include <boolean.h>\n#include <retro_common_api.h>\n#include <retro_miscellaneous.h>\n\n#include \"frontend/frontend_driver.h\"\n\nRETRO_BEGIN_DECLS\n\ntypedef struct content_ctx_info\n{\n   char **argv;                    /* Argument variable list. */\n   void *args;                     /* Arguments passed from callee */\n   environment_get_t environ_get;  /* Function passed for environment_get function */\n   int argc;                       /* Argument count. */\n} content_ctx_info_t;\n\n/* Load a state from memory. */\nbool content_load_state_from_ram(void);\n\n/* Save a state to memory. */\nbool content_save_state_to_ram(void);\n\n/* Save a ram state from memory to disk. */\nbool content_ram_state_to_file(const char *path);\n\n/* Load a state from disk to memory. */\nbool content_load_state(const char* path, bool load_to_backup_buffer, bool autoload);\n\n/* Save a state from memory to disk. */\nbool content_save_state(const char *path, bool save_to_disk);\n\n/* Save an automatic savestate to disk. */\nbool content_auto_save_state(const char *path);\n\n/* Check a ram state write to disk. */\nbool content_ram_state_pending(void);\n\n/* Gets the number of bytes required to serialize the state. */\nsize_t content_get_serialized_size(void);\n\n/* Gets the number of bytes required to serialize the state for rewind. */\nsize_t content_get_serialized_size_rewind(void);\n\n/* Serializes the current state for rewinding. buffer must be at least content_get_serialized_size bytes */\nbool content_serialize_state_rewind(void* buffer, size_t buffer_size);\n\n/* Deserializes the current state. */\nbool content_deserialize_state(const void* serialized_data, size_t serialized_size);\n\n/* Waits for any in-progress save state tasks to finish */\nvoid content_wait_for_save_state_task(void);\n/* Waits for any in-progress load state tasks to finish */\nvoid content_wait_for_load_state_task(void);\n\n/* Copy a save state. */\nbool content_rename_state(const char *origin, const char *dest);\n\n/* Undoes the last load state operation that was done */\nbool content_undo_load_state(void);\n\n/* Restores the last savestate file which was overwritten */\nbool content_undo_save_state(void);\n\nuint8_t content_get_flags(void);\n\nvoid content_set_does_not_need_content(void);\n\nvoid content_unset_does_not_need_content(void);\n\nuint32_t content_get_crc(void);\n\nvoid content_deinit(void);\n\n/* Initializes and loads a content file for the currently\n * selected libretro core. */\nbool content_init(void);\n\n/* Resets the state and savefile backup buffers */\nvoid content_reset_savestate_backups(void);\n\n/* Checks if the buffers are empty */\nbool content_undo_load_buf_is_empty(void);\nbool content_undo_save_buf_is_empty(void);\n\n/* Clears the pending subsystem rom buffer */\nbool content_is_subsystem_pending_load(void);\n\n/* Clears the pending subsystem rom buffer */\nvoid content_clear_subsystem(void);\n\n/* Set the current subsystem*/\nvoid content_set_subsystem(unsigned subsystem);\n\n/* Get the current subsystem*/\nint content_get_subsystem(void);\n\n/* Add a rom to the subsystem rom buffer */\nvoid content_add_subsystem(const char* path);\n\n/* Get the current subsystem rom id */\nunsigned content_get_subsystem_rom_id(void);\n\n/* Set environment variables before a subsystem load */\nvoid content_set_subsystem_info(void);\n\n/* Get the path to the last selected subsystem rom */\nchar* content_get_subsystem_rom(unsigned index);\n\n/* Sets the subsystem by name */\nbool content_set_subsystem_by_name(const char* subsystem_name);\n\n/* Get the current subsystem \"friendly name\" */\nvoid content_get_subsystem_friendly_name(const char* subsystem_name, char* subsystem_friendly_name, size_t len);\n\n/* Sets overrides which modify frontend handling of\n * specific content file types */\nbool content_file_override_set(const struct retro_system_content_info_override *overrides);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "core.h",
          "type": "blob",
          "size": 2.2041015625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2016 - Daniel De Matteis\n *  Copyright (C) 2012-2015 - Michael Lelli\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _LIBRETRO_CORE_IMPL_H\n#define _LIBRETRO_CORE_IMPL_H\n\n#include <boolean.h>\n#include <libretro.h>\n\n#include <retro_common_api.h>\n\n#include \"retroarch_types.h\"\n\nRETRO_BEGIN_DECLS\n\n#ifdef HAVE_NETWORKING\nbool core_set_netplay_callbacks(void);\n\nbool core_unset_netplay_callbacks(void);\n#endif\n\nbool core_set_poll_type(unsigned type);\n\n/* Runs the core for one frame. */\nvoid core_run(void);\n\nvoid core_reset(void);\n\nsize_t core_serialize_size(void);\nsize_t core_serialize_size_special(void);\n\nuint64_t core_serialization_quirks(void);\n\nbool core_serialize(retro_ctx_serialize_info_t *info);\nbool core_serialize_special(retro_ctx_serialize_info_t *info);\n\nbool core_unserialize(retro_ctx_serialize_info_t *info);\nbool core_unserialize_special(retro_ctx_serialize_info_t *info);\n\nbool core_set_cheat(retro_ctx_cheat_info_t *info);\n\nbool core_reset_cheat(void);\n\nbool core_get_memory(retro_ctx_memory_info_t *info);\n\n/* Get system A/V information. */\nbool core_get_system_info(struct retro_system_info *system);\n\nbool core_load_game(retro_ctx_load_content_info_t *load_info);\n\nbool core_set_controller_port_device(retro_ctx_controller_info_t *pad);\n\nbool core_has_set_input_descriptor(void);\n\n/**\n * core_set_default_callbacks:\n * @data           : pointer to retro_callbacks object\n *\n * Binds the libretro callbacks to default callback functions.\n **/\nbool core_set_default_callbacks(void *data);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "core_backup.c",
          "type": "blob",
          "size": 18.4501953125,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2014-2017 - Jean-Andr Santoni\n *  Copyright (C) 2016-2019 - Brad Parker\n *  Copyright (C) 2019-2020 - James Leaver\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <string/stdstring.h>\n#include <lists/string_list.h>\n#include <file/file_path.h>\n#include <streams/interface_stream.h>\n#include <streams/file_stream.h>\n#include <lists/dir_list.h>\n#include <time/rtime.h>\n#include <retro_miscellaneous.h>\n\n#include \"frontend/frontend_driver.h\"\n#include \"file_path_special.h\"\n#include \"verbosity.h\"\n\n#include \"core_backup.h\"\n\n/* Holds all entries in a core backup list */\nstruct core_backup_list\n{\n   core_backup_list_entry_t *entries;\n   size_t size;\n   size_t capacity;\n};\n\n/*********************/\n/* Utility Functions */\n/*********************/\n\n/* Generates backup directory path for specified core.\n * Returns false if 'core_path' and/or 'dir_core_assets'\n * are invalid, or a filesystem error occurs */\nstatic bool core_backup_get_backup_dir(\n      const char *dir_libretro, const char *dir_core_assets,\n      const char *core_filename,\n      char *backup_dir, size_t len)\n{\n   char tmp[PATH_MAX_LENGTH];\n   char core_file_id[NAME_MAX_LENGTH];\n   char *last_underscore = NULL;\n\n   /* Extract core file 'ID' (name without extension + suffix)\n    * from core path */\n   if (   string_is_empty(dir_libretro)\n       || string_is_empty(core_filename)\n       || (len < 1))\n      return false;\n\n   fill_pathname(core_file_id, core_filename, \"\",\n         sizeof(core_file_id));\n   if (string_is_empty(core_file_id))\n      return false;\n\n   /* > Remove platform-specific file name suffix,\n    *   if required */\n   last_underscore = strrchr(core_file_id, '_');\n\n   if (!string_is_empty(last_underscore))\n      if (!string_is_equal(last_underscore, \"_libretro\"))\n         *last_underscore = '\\0';\n\n   if (string_is_empty(core_file_id))\n      return false;\n\n   /* Get core backup directory\n    * > If no assets directory is defined, use\n    *   core directory as a base */\n   fill_pathname_join_special(tmp,\n         string_is_empty(dir_core_assets)\n         ? dir_libretro\n         : dir_core_assets,\n               \"core_backups\", sizeof(tmp));\n\n   fill_pathname_join_special(backup_dir, tmp,\n         core_file_id, len);\n\n   if (string_is_empty(backup_dir))\n      return false;\n\n   /* > Create directory, if required */\n   if (!path_is_directory(backup_dir))\n   {\n      if (!path_mkdir(backup_dir))\n      {\n         RARCH_ERR(\"[core backup] Failed to create backup directory: %s.\\n\", backup_dir);\n         return false;\n      }\n   }\n\n   return true;\n}\n\n/* Generates a timestamped core backup file path from\n * the specified core path. Returns true if successful */\nbool core_backup_get_backup_path(\n      const char *core_path, uint32_t crc,\n      enum core_backup_mode backup_mode,\n      const char *dir_core_assets,\n      char *backup_path, size_t len)\n{\n   time_t current_time;\n   struct tm time_info;\n   const char *core_filename = NULL;\n   char core_dir[DIR_MAX_LENGTH];\n   char backup_dir[DIR_MAX_LENGTH];\n   char backup_filename[PATH_MAX_LENGTH];\n\n   backup_dir[0]      = '\\0';\n   backup_filename[0] = '\\0';\n\n   /* Get core filename and parent directory */\n   if (string_is_empty(core_path))\n      return false;\n\n   core_filename = path_basename(core_path);\n\n   if (string_is_empty(core_filename))\n      return false;\n\n   fill_pathname_parent_dir(core_dir, core_path, sizeof(core_dir));\n\n   if (string_is_empty(core_dir))\n      return false;\n\n   /* Get backup directory */\n   if (!core_backup_get_backup_dir(core_dir, dir_core_assets, core_filename,\n         backup_dir, sizeof(backup_dir)))\n      return false;\n\n   /* Get current time */\n   time(&current_time);\n   rtime_localtime(&current_time, &time_info);\n\n   /* Generate backup filename */\n   snprintf(backup_filename, sizeof(backup_filename),\n         \"%s.%04u%02u%02uT%02u%02u%02u.%08lx.%u%s\",\n         core_filename,\n         (unsigned)time_info.tm_year + 1900,\n         (unsigned)time_info.tm_mon + 1,\n         (unsigned)time_info.tm_mday,\n         (unsigned)time_info.tm_hour,\n         (unsigned)time_info.tm_min,\n         (unsigned)time_info.tm_sec,\n         (unsigned long)crc,\n         (unsigned)backup_mode,\n         FILE_PATH_CORE_BACKUP_EXTENSION);\n\n   /* Build final path */\n   fill_pathname_join_special(backup_path, backup_dir,\n         backup_filename, len);\n\n   return true;\n}\n\n/* Returns detected type of specified core backup file */\nenum core_backup_type core_backup_get_backup_type(const char *backup_path)\n{\n   char core_ext[16];\n   const char *backup_ext            = NULL;\n   struct string_list *metadata_list = NULL;\n\n   if (string_is_empty(backup_path) || !path_is_valid(backup_path))\n      goto error;\n\n   /* Get backup file extension */\n   backup_ext = path_get_extension(backup_path);\n\n   if (string_is_empty(backup_ext))\n      goto error;\n\n   /* Get platform-specific dynamic library extension */\n   if (!frontend_driver_get_core_extension(core_ext, sizeof(core_ext)))\n      goto error;\n\n   /* Check if this is an archived backup */\n   if (string_is_equal_noncase(backup_ext,\n         FILE_PATH_CORE_BACKUP_EXTENSION_NO_DOT))\n   {\n      const char *backup_filename = NULL;\n      const char *src_ext         = NULL;\n\n      /* Split the backup filename into its various\n       * metadata components */\n      backup_filename = path_basename(backup_path);\n\n      if (string_is_empty(backup_filename))\n         goto error;\n\n      metadata_list = string_split(backup_filename, \".\");\n\n      if (!metadata_list || (metadata_list->size != 6))\n         goto error;\n\n      /* Get extension of source core file */\n      src_ext = metadata_list->elems[1].data;\n\n      if (string_is_empty(src_ext))\n         goto error;\n\n      /* Check whether extension is valid */\n      if (!string_is_equal_noncase(src_ext, core_ext))\n         goto error;\n\n      string_list_free(metadata_list);\n      metadata_list = NULL;\n\n      return CORE_BACKUP_TYPE_ARCHIVE;\n   }\n\n   /* Check if this is a plain dynamic library file */\n   if (string_is_equal_noncase(backup_ext, core_ext))\n      return CORE_BACKUP_TYPE_LIB;\n\nerror:\n   if (metadata_list)\n   {\n      string_list_free(metadata_list);\n      metadata_list = NULL;\n   }\n\n   return CORE_BACKUP_TYPE_INVALID;\n}\n\n/* Fetches crc value of specified core backup file.\n * Returns true if successful */\nbool core_backup_get_backup_crc(char *backup_path, uint32_t *crc)\n{\n   enum core_backup_type backup_type;\n   struct string_list *metadata_list = NULL;\n\n   if (string_is_empty(backup_path) || !crc)\n      return false;\n\n   /* Get backup type */\n   backup_type = core_backup_get_backup_type(backup_path);\n\n   switch (backup_type)\n   {\n      case CORE_BACKUP_TYPE_ARCHIVE:\n         {\n            const char *backup_filename = NULL;\n            const char *crc_str         = NULL;\n\n            /* Split the backup filename into its various\n             * metadata components */\n            backup_filename = path_basename(backup_path);\n\n            if (string_is_empty(backup_filename))\n               goto error;\n\n            metadata_list = string_split(backup_filename, \".\");\n\n            if (!metadata_list || (metadata_list->size != 6))\n               goto error;\n\n            /* Get crc string */\n            crc_str = metadata_list->elems[3].data;\n\n            if (string_is_empty(crc_str))\n               goto error;\n\n            /* Convert to an integer */\n            if ((*crc = (uint32_t)string_hex_to_unsigned(crc_str)) == 0)\n               goto error;\n\n            string_list_free(metadata_list);\n            metadata_list = NULL;\n\n         }\n         return true;\n      case CORE_BACKUP_TYPE_LIB:\n         {\n            intfstream_t *backup_file = NULL;\n\n            /* This is a plain dynamic library file,\n             * have to read file data to determine crc */\n\n            /* Open backup file */\n            backup_file = intfstream_open_file(\n                  backup_path, RETRO_VFS_FILE_ACCESS_READ,\n                  RETRO_VFS_FILE_ACCESS_HINT_NONE);\n\n            if (backup_file)\n            {\n               bool success;\n\n               /* Get crc value */\n               success = intfstream_get_crc(backup_file, crc);\n\n               /* Close backup file */\n               intfstream_close(backup_file);\n               free(backup_file);\n               backup_file = NULL;\n\n               return success;\n            }\n         }\n         break;\n      default:\n         /* Backup is invalid */\n         break;\n   }\n\nerror:\n   if (metadata_list)\n   {\n      string_list_free(metadata_list);\n      metadata_list = NULL;\n   }\n\n   return false;\n}\n\n/* Fetches core path associated with specified core\n * backup file. Returns detected type of backup\n * file - CORE_BACKUP_TYPE_INVALID indicates that\n * backup file cannot be restored/installed, or\n * arguments are otherwise invalid */\nenum core_backup_type core_backup_get_core_path(\n      const char *backup_path, const char *dir_libretro,\n      char *core_path, size_t len)\n{\n   const char *backup_filename       = NULL;\n\n   if (string_is_empty(backup_path) || string_is_empty(dir_libretro))\n      return CORE_BACKUP_TYPE_INVALID;\n\n   backup_filename = path_basename(backup_path);\n\n   if (!string_is_empty(backup_filename))\n   {\n      /* Check backup type */\n      switch (core_backup_get_backup_type(backup_path))\n      {\n         case CORE_BACKUP_TYPE_ARCHIVE:\n            {\n               /* This is an archived backup with timestamp/crc\n                * metadata in the filename */\n               char *core_filename = strdup(backup_filename);\n               /* Find the location of the second period */\n               char *period        = strchr(core_filename, '.');\n               if (!period || (*(++period) == '\\0'))\n               {\n                  free(core_filename);\n                  break;\n               }\n\n               if (!(period = strchr(period, '.')))\n               {\n                  free(core_filename);\n                  break;\n               }\n\n               /* Trim everything after (and including) the\n                * second period */\n               *period = '\\0';\n\n               if (string_is_empty(core_filename))\n               {\n                  free(core_filename);\n                  break;\n               }\n\n               /* All good - build core path */\n               fill_pathname_join_special(core_path, dir_libretro,\n                     core_filename, len);\n               free(core_filename);\n            }\n            return CORE_BACKUP_TYPE_ARCHIVE;\n         case CORE_BACKUP_TYPE_LIB:\n            /* This is a plain dynamic library file */\n            fill_pathname_join_special(core_path, dir_libretro,\n                  backup_filename, len);\n            return CORE_BACKUP_TYPE_LIB;\n         default:\n            /* Backup is invalid */\n            break;\n      }\n   }\n\n   return CORE_BACKUP_TYPE_INVALID;\n}\n\n/*************************/\n/* Backup List Functions */\n/*************************/\n\n/**************************************/\n/* Initialisation / De-Initialisation */\n/**************************************/\n\n/* Parses backup file name and adds to backup list, if valid */\nstatic bool core_backup_add_entry(core_backup_list_t *backup_list,\n      const char *core_filename, const char *backup_path)\n{\n   char *backup_filename           = NULL;\n   core_backup_list_entry_t *entry = NULL;\n   unsigned long crc               = 0;\n   unsigned backup_mode            = 0;\n\n   if (  !backup_list\n       || string_is_empty(core_filename)\n       || string_is_empty(backup_path)\n       || (backup_list->size >= backup_list->capacity))\n      return false;\n\n   backup_filename = strdup(path_basename(backup_path));\n\n   if (string_is_empty(backup_filename))\n      goto error;\n\n   /* Ensure base backup filename matches core */\n   if (!string_starts_with(backup_filename, core_filename))\n      goto error;\n\n   /* Remove backup file extension */\n   path_remove_extension(backup_filename);\n\n   /* Parse backup filename metadata\n    * - <core_filename>.<timestamp>.<crc>.<backup_mode>\n    * - timestamp: YYYYMMDDTHHMMSS */\n   entry = &backup_list->entries[backup_list->size];\n\n   if (sscanf(backup_filename + strlen(core_filename),\n       \".%04u%02u%02uT%02u%02u%02u.%08lx.%u\",\n       &entry->date.year, &entry->date.month, &entry->date.day,\n       &entry->date.hour, &entry->date.minute, &entry->date.second,\n       &crc, &backup_mode) != 8)\n      goto error;\n\n   entry->crc         = (uint32_t)crc;\n   entry->backup_mode = (enum core_backup_mode)backup_mode;\n\n   /* Cache backup path */\n   entry->backup_path = strdup(backup_path);\n   backup_list->size++;\n\n   free(backup_filename);\n\n   return true;\n\nerror:\n   if (backup_filename)\n      free(backup_filename);\n\n   return false;\n}\n\n/* Creates a new core backup list containing entries\n * for all existing backup files.\n * Returns a handle to a new core_backup_list_t object\n * on success, otherwise returns NULL. */\ncore_backup_list_t *core_backup_list_init(\n      const char *core_path, const char *dir_core_assets)\n{\n   size_t i;\n   const char *core_filename         = NULL;\n   struct string_list *dir_list      = NULL;\n   core_backup_list_t *backup_list   = NULL;\n   core_backup_list_entry_t *entries = NULL;\n   char core_dir[DIR_MAX_LENGTH];\n   char backup_dir[DIR_MAX_LENGTH];\n\n   core_dir[0]   = '\\0';\n   backup_dir[0] = '\\0';\n\n   /* Get core filename and parent directory */\n   if (string_is_empty(core_path))\n      goto error;\n\n   core_filename = path_basename(core_path);\n\n   if (string_is_empty(core_filename))\n      goto error;\n\n   fill_pathname_parent_dir(core_dir, core_path, sizeof(core_dir));\n\n   if (string_is_empty(core_dir))\n      goto error;\n\n   /* Get backup directory */\n   if (!core_backup_get_backup_dir(core_dir, dir_core_assets, core_filename,\n         backup_dir, sizeof(backup_dir)))\n      goto error;\n\n   /* Get backup file list */\n   dir_list = dir_list_new(\n         backup_dir,\n         FILE_PATH_CORE_BACKUP_EXTENSION,\n         false, /* include_dirs */\n         false, /* include_hidden */\n         false, /* include_compressed */\n         false  /* recursive */\n   );\n\n   /* Sanity check */\n   if (!dir_list)\n      goto error;\n\n   if (dir_list->size < 1)\n      goto error;\n\n   /* Ensure list is sorted in alphabetical order\n    * > This corresponds to 'timestamp' order */\n   dir_list_sort(dir_list, true);\n\n   /* Create core backup list */\n   if (!(backup_list = (core_backup_list_t*)malloc(sizeof(*backup_list))))\n      goto error;\n\n   backup_list->entries  = NULL;\n   backup_list->capacity = 0;\n   backup_list->size     = 0;\n\n   /* Create entries array\n    * (Note: Set this to the full size of the directory\n    * list - this may be larger than we need, but saves\n    * many inefficiencies later)   */\n   if (!(entries = (core_backup_list_entry_t*)\n      calloc(dir_list->size, sizeof(*entries))))\n      goto error;\n\n   backup_list->entries  = entries;\n   backup_list->capacity = dir_list->size;\n\n   /* Loop over backup files and parse file names */\n   for (i = 0; i < dir_list->size; i++)\n   {\n      const char *backup_path = dir_list->elems[i].data;\n      core_backup_add_entry(backup_list, core_filename, backup_path);\n   }\n\n   if (backup_list->size == 0)\n      goto error;\n\n   string_list_free(dir_list);\n\n   return backup_list;\n\nerror:\n   if (dir_list)\n      string_list_free(dir_list);\n\n   if (backup_list)\n      core_backup_list_free(backup_list);\n\n   return NULL;\n}\n\n/* Frees specified core backup list */\nvoid core_backup_list_free(core_backup_list_t *backup_list)\n{\n   size_t i;\n\n   if (!backup_list)\n      return;\n\n   if (backup_list->entries)\n   {\n      for (i = 0; i < backup_list->size; i++)\n      {\n         core_backup_list_entry_t *entry = &backup_list->entries[i];\n\n         if (!entry)\n            continue;\n\n         if (entry->backup_path)\n         {\n            free(entry->backup_path);\n            entry->backup_path = NULL;\n         }\n      }\n\n      free(backup_list->entries);\n      backup_list->entries = NULL;\n   }\n\n   free(backup_list);\n}\n\n/***********/\n/* Getters */\n/***********/\n\n/* Returns number of entries in core backup list */\nsize_t core_backup_list_size(core_backup_list_t *backup_list)\n{\n   if (!backup_list)\n      return 0;\n\n   return backup_list->size;\n}\n\n/* Returns number of entries of specified 'backup mode'\n * (manual or automatic) in core backup list */\nsize_t core_backup_list_get_num_backups(\n      core_backup_list_t *backup_list,\n      enum core_backup_mode backup_mode)\n{\n   size_t i;\n   size_t num_backups = 0;\n\n   if (!backup_list || !backup_list->entries)\n      return 0;\n\n   for (i = 0; i < backup_list->size; i++)\n   {\n      core_backup_list_entry_t *current_entry = &backup_list->entries[i];\n      if (    current_entry\n          && (current_entry->backup_mode == backup_mode))\n         num_backups++;\n   }\n\n   return num_backups;\n}\n\n/* Fetches core backup list entry corresponding\n * to the specified entry index.\n * Returns false if index is invalid. */\nbool core_backup_list_get_index(\n      core_backup_list_t *backup_list,\n      size_t idx,\n      const core_backup_list_entry_t **entry)\n{\n   if (!backup_list || !backup_list->entries || !entry)\n      return false;\n\n   if (idx >= backup_list->size)\n      return false;\n\n   *entry = &backup_list->entries[idx];\n\n   if (*entry)\n      return true;\n\n   return false;\n}\n\n/* Fetches core backup list entry corresponding\n * to the specified core crc checksum value.\n * Note that 'manual' and 'auto' backups are\n * considered independent - we only compare\n * crc values for the specified backup_mode.\n * Returns false if entry is not found. */\nbool core_backup_list_get_crc(\n      core_backup_list_t *backup_list,\n      uint32_t crc, enum core_backup_mode backup_mode,\n      const core_backup_list_entry_t **entry)\n{\n   size_t i;\n\n   if (!backup_list || !backup_list->entries || !entry)\n      return false;\n\n   for (i = 0; i < backup_list->size; i++)\n   {\n      core_backup_list_entry_t *current_entry = &backup_list->entries[i];\n\n      if (   (current_entry)\n          && (current_entry->crc == crc)\n          && (current_entry->backup_mode == backup_mode))\n      {\n         *entry = current_entry;\n         return true;\n      }\n   }\n\n   return false;\n}\n"
        },
        {
          "name": "core_backup.h",
          "type": "blob",
          "size": 5.0263671875,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2014-2017 - Jean-Andr Santoni\n *  Copyright (C) 2016-2019 - Brad Parker\n *  Copyright (C) 2019-2020 - James Leaver\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __CORE_BACKUP_H\n#define __CORE_BACKUP_H\n\n#include <retro_common_api.h>\n#include <libretro.h>\n\n#include <boolean.h>\n\nRETRO_BEGIN_DECLS\n\n/* Defines the various types of supported core backup\n * file. Allows us to handle manual core installs\n * (via downloaded/compiled dynamic libraries dropped\n * in the 'downloads' folder) using the same task\n * interface as 'managed'/archived backups */\nenum core_backup_type\n{\n   CORE_BACKUP_TYPE_INVALID = 0,\n   CORE_BACKUP_TYPE_ARCHIVE,\n   CORE_BACKUP_TYPE_LIB\n};\n\n/* Used to distinguish manual and automatic\n * core backups */\nenum core_backup_mode\n{\n   CORE_BACKUP_MODE_MANUAL = 0,\n   CORE_BACKUP_MODE_AUTO\n};\n\n/* Note: These must be kept synchronised with\n * 'enum menu_timedate_date_separator_type' in\n * 'menu_defines.h' */\nenum core_backup_date_separator_type\n{\n   CORE_BACKUP_DATE_SEPARATOR_HYPHEN = 0,\n   CORE_BACKUP_DATE_SEPARATOR_SLASH,\n   CORE_BACKUP_DATE_SEPARATOR_PERIOD,\n   CORE_BACKUP_DATE_SEPARATOR_LAST\n};\n\n/* Holds all timestamp info for a core backup file */\ntypedef struct\n{\n   unsigned year;\n   unsigned month;\n   unsigned day;\n   unsigned hour;\n   unsigned minute;\n   unsigned second;\n} core_backup_list_date_t;\n\n/* Holds all info related to a core backup file */\ntypedef struct\n{\n   char *backup_path;\n   core_backup_list_date_t date;       /* unsigned alignment */\n   uint32_t crc;\n   enum core_backup_mode backup_mode;\n} core_backup_list_entry_t;\n\n/* Prevent direct access to core_backup_list_t\n * members */\ntypedef struct core_backup_list core_backup_list_t;\n\n/*********************/\n/* Utility Functions */\n/*********************/\n\n/* Generates a timestamped core backup file path from\n * the specified core path. Returns true if successful */\nbool core_backup_get_backup_path(\n      const char *core_path, uint32_t crc, enum core_backup_mode backup_mode,\n      const char *dir_core_assets, char *backup_path, size_t len);\n\n/* Returns detected type of specified core backup file */\nenum core_backup_type core_backup_get_backup_type(const char *backup_path);\n\n/* Fetches crc value of specified core backup file.\n * Returns true if successful */\nbool core_backup_get_backup_crc(char *backup_path, uint32_t *crc);\n\n/* Fetches core path associated with specified core\n * backup file. Returns detected type of backup\n * file - CORE_BACKUP_TYPE_INVALID indicates that\n * backup file cannot be restored/installed, or\n * arguments are otherwise invalid */\nenum core_backup_type core_backup_get_core_path(\n      const char *backup_path, const char *dir_libretro,\n      char *core_path, size_t len);\n\n/*************************/\n/* Backup List Functions */\n/*************************/\n\n/**************************************/\n/* Initialisation / De-Initialisation */\n/**************************************/\n\n/* Creates a new core backup list containing entries\n * for all existing backup files.\n * Returns a handle to a new core_backup_list_t object\n * on success, otherwise returns NULL. */\ncore_backup_list_t *core_backup_list_init(\n      const char *core_path, const char *dir_core_assets);\n\n/* Frees specified core backup list */\nvoid core_backup_list_free(core_backup_list_t *backup_list);\n\n/***********/\n/* Getters */\n/***********/\n\n/* Returns number of entries in core backup list */\nsize_t core_backup_list_size(core_backup_list_t *backup_list);\n\n/* Returns number of entries of specified 'backup mode'\n * (manual or automatic) in core backup list */\nsize_t core_backup_list_get_num_backups(\n      core_backup_list_t *backup_list,\n      enum core_backup_mode backup_mode);\n\n/* Fetches core backup list entry corresponding\n * to the specified entry index.\n * Returns false if index is invalid. */\nbool core_backup_list_get_index(\n      core_backup_list_t *backup_list,\n      size_t idx,\n      const core_backup_list_entry_t **entry);\n\n/* Fetches core backup list entry corresponding\n * to the specified core crc checksum value.\n * Note that 'manual' and 'auto' backups are\n * considered independent - we only compare\n * crc values for the specified backup_mode.\n * Returns false if entry is not found. */\nbool core_backup_list_get_crc(\n      core_backup_list_t *backup_list,\n      uint32_t crc, enum core_backup_mode backup_mode,\n      const core_backup_list_entry_t **entry);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "core_info.c",
          "type": "blob",
          "size": 92.9990234375,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <compat/strl.h>\n#include <string/stdstring.h>\n#include <file/config_file.h>\n#include <file/file_path.h>\n#include <streams/file_stream.h>\n#include <streams/interface_stream.h>\n#include <formats/rjson.h>\n#include <lists/dir_list.h>\n#include <file/archive_file.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"retroarch.h\"\n#include \"verbosity.h\"\n\n#include \"core_info.h\"\n#include \"file_path_special.h\"\n\n#if defined(__WINRT__) || defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP\n#include \"uwp/uwp_func.h\"\n#endif\n\n#if defined(ANDROID)\n#include \"play_feature_delivery/play_feature_delivery.h\"\n#endif\n\n/*************************/\n/* Core Info Cache START */\n/*************************/\n\n#define CORE_INFO_CACHE_VERSION \"1.2\"\n#define CORE_INFO_CACHE_DEFAULT_CAPACITY 8\n\n/* TODO/FIXME: Apparently rzip compression is an issue on UWP */\n#if defined(HAVE_ZLIB) && !(defined(__WINRT__) || defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP)\n#define CORE_INFO_CACHE_COMPRESS\n#endif\n\ntypedef struct\n{\n   core_info_t *items;\n   size_t length;\n   size_t capacity;\n   char *version;\n   bool refresh;\n} core_info_cache_list_t;\n\ntypedef struct\n{\n   core_info_t *core_info;\n   core_info_cache_list_t *core_info_cache_list;\n   char **current_string_val;\n   struct string_list **current_string_list_val;\n   uint32_t *current_entry_uint_val;\n   bool *current_entry_bool_val;\n   unsigned array_depth;\n   unsigned object_depth;\n   bool to_core_file_id;\n   bool to_firmware;\n} CCJSONContext;\n\n/* Forward declarations */\nstatic void core_info_free(core_info_t* info);\nstatic uint32_t core_info_hash_string(const char *str);\n#ifdef HAVE_CORE_INFO_CACHE\nstatic core_info_cache_list_t *core_info_cache_list_new(void);\n#endif\nstatic void core_info_cache_add(core_info_cache_list_t *list,\n      core_info_t *info, bool transfer);\n\nstatic core_info_state_t core_info_st = {\n#ifdef HAVE_COMPRESSION\n   NULL,\n#endif\n   NULL,\n   NULL,\n   NULL\n};\n\n#ifdef HAVE_CORE_INFO_CACHE\n/* JSON Handlers START */\n\nstatic bool CCJSONObjectMemberHandler(void *context,\n      const char *pValue, size_t length)\n{\n   CCJSONContext *pCtx = (CCJSONContext *)context;\n\n   if (length)\n   {\n      switch (pCtx->array_depth)\n      {\n         case 0:\n            if (pCtx->object_depth == 1)\n            {\n               pCtx->current_string_val     = NULL;\n\n               if (string_is_equal(pValue, \"version\"))\n                  pCtx->current_string_val  = &pCtx->core_info_cache_list->version;\n            }\n            break;\n         case 1:\n            if (pCtx->object_depth == 2)\n            {\n               pCtx->current_string_val      = NULL;\n               pCtx->current_string_list_val = NULL;\n               pCtx->current_entry_uint_val  = NULL;\n               pCtx->current_entry_bool_val  = NULL;\n               pCtx->to_core_file_id         = false;\n               pCtx->to_firmware             = false;\n\n               switch (pValue[0])\n               {\n                  case 'a':\n                     if (string_is_equal(pValue, \"authors\"))\n                     {\n                        pCtx->current_string_val      = &pCtx->core_info->authors;\n                        pCtx->current_string_list_val = &pCtx->core_info->authors_list;\n                     }\n                     break;\n                  case 'c':\n                     if (string_is_equal(pValue, \"categories\"))\n                     {\n                        pCtx->current_string_val      = &pCtx->core_info->categories;\n                        pCtx->current_string_list_val = &pCtx->core_info->categories_list;\n                     }\n                     else if (string_is_equal(pValue, \"core_name\"))\n                        pCtx->current_string_val      = &pCtx->core_info->core_name;\n                     else if (string_is_equal(pValue, \"core_file_id\"))\n                        pCtx->to_core_file_id         = true;\n                     break;\n                  case 'd':\n                     if (string_is_equal(pValue, \"display_name\"))\n                        pCtx->current_string_val      = &pCtx->core_info->display_name;\n                     else if (string_is_equal(pValue, \"display_version\"))\n                        pCtx->current_string_val      = &pCtx->core_info->display_version;\n                     else if (string_is_equal(pValue, \"databases\"))\n                     {\n                        pCtx->current_string_val      = &pCtx->core_info->databases;\n                        pCtx->current_string_list_val = &pCtx->core_info->databases_list;\n                     }\n                     else if (string_is_equal(pValue, \"description\"))\n                        pCtx->current_string_val      = &pCtx->core_info->description;\n                     else if (string_is_equal(pValue, \"database_match_archive_member\"))\n                        pCtx->current_entry_bool_val  = &pCtx->core_info->database_match_archive_member;\n                     break;\n                  case 'f':\n                     if (string_is_equal(pValue, \"firmware\"))\n                        pCtx->to_firmware             = true;\n                     break;\n                  case 'h':\n                     if (string_is_equal(pValue, \"has_info\"))\n                        pCtx->current_entry_bool_val  = &pCtx->core_info->has_info;\n                     break;\n                  case 'l':\n                     if (string_is_equal(pValue, \"licenses\"))\n                     {\n                        pCtx->current_string_val      = &pCtx->core_info->licenses;\n                        pCtx->current_string_list_val = &pCtx->core_info->licenses_list;\n                     }\n                     else if (string_is_equal(pValue, \"is_experimental\"))\n                        pCtx->current_entry_bool_val  = &pCtx->core_info->is_experimental;\n                     break;\n                  case 'n':\n                     if (string_is_equal(pValue, \"notes\"))\n                     {\n                        pCtx->current_string_val      = &pCtx->core_info->notes;\n                        pCtx->current_string_list_val = &pCtx->core_info->note_list;\n                     }\n                     break;\n                  case 'p':\n                     if (string_is_equal(pValue, \"permissions\"))\n                     {\n                        pCtx->current_string_val      = &pCtx->core_info->permissions;\n                        pCtx->current_string_list_val = &pCtx->core_info->permissions_list;\n                     }\n                     break;\n                  case 'r':\n                     if (string_is_equal(pValue, \"required_hw_api\"))\n                     {\n                        pCtx->current_string_val      = &pCtx->core_info->required_hw_api;\n                        pCtx->current_string_list_val = &pCtx->core_info->required_hw_api_list;\n                     }\n                     break;\n                  case 's':\n                     if (string_is_equal(pValue, \"system_manufacturer\"))\n                        pCtx->current_string_val      = &pCtx->core_info->system_manufacturer;\n                     else if (string_is_equal(pValue, \"systemname\"))\n                        pCtx->current_string_val      = &pCtx->core_info->systemname;\n                     else if (string_is_equal(pValue, \"system_id\"))\n                        pCtx->current_string_val      = &pCtx->core_info->system_id;\n                     else if (string_is_equal(pValue, \"supported_extensions\"))\n                     {\n                        pCtx->current_string_val      = &pCtx->core_info->supported_extensions;\n                        pCtx->current_string_list_val = &pCtx->core_info->supported_extensions_list;\n                     }\n                     else if (string_is_equal(pValue, \"supports_no_game\"))\n                        pCtx->current_entry_bool_val  = &pCtx->core_info->supports_no_game;\n                     else if (string_is_equal(pValue, \"single_purpose\"))\n                        pCtx->current_entry_bool_val  = &pCtx->core_info->single_purpose;\n                     else if (string_is_equal(pValue, \"savestate_support_level\"))\n                        pCtx->current_entry_uint_val  = &pCtx->core_info->savestate_support_level;\n                     break;\n               }\n            }\n            else if (pCtx->object_depth == 3)\n            {\n               pCtx->current_string_val      = NULL;\n               pCtx->current_entry_uint_val  = NULL;\n\n               if (pCtx->to_core_file_id)\n               {\n                  if (string_is_equal(pValue, \"str\"))\n                     pCtx->current_string_val      = &pCtx->core_info->core_file_id.str;\n                  else if (string_is_equal(pValue, \"hash\"))\n                     pCtx->current_entry_uint_val  = &pCtx->core_info->core_file_id.hash;\n               }\n            }\n            break;\n         case 2:\n            if (pCtx->object_depth == 3)\n            {\n               pCtx->current_string_val            = NULL;\n               pCtx->current_entry_bool_val        = NULL;\n\n               if (pCtx->to_firmware && (pCtx->core_info->firmware_count > 0))\n               {\n                  size_t firmware_idx              = pCtx->core_info->firmware_count - 1;\n\n                  if (string_is_equal(pValue, \"path\"))\n                     pCtx->current_string_val      = &pCtx->core_info->firmware[firmware_idx].path;\n                  else if (string_is_equal(pValue, \"desc\"))\n                     pCtx->current_string_val      = &pCtx->core_info->firmware[firmware_idx].desc;\n                  else if (string_is_equal(pValue, \"optional\"))\n                     pCtx->current_entry_bool_val  = &pCtx->core_info->firmware[firmware_idx].optional;\n               }\n            }\n            break;\n      }\n\n   }\n\n   return true;\n}\n\nstatic bool CCJSONStringHandler(void *context,\n      const char *pValue, size_t length)\n{\n   CCJSONContext *pCtx = (CCJSONContext*)context;\n\n   if (     pCtx->current_string_val\n         && length\n         && !string_is_empty(pValue))\n   {\n      if (*pCtx->current_string_val)\n         free(*pCtx->current_string_val);\n      *pCtx->current_string_val = strdup(pValue);\n\n      if (pCtx->current_string_list_val)\n      {\n         if (*pCtx->current_string_list_val)\n            string_list_free(*pCtx->current_string_list_val);\n         *pCtx->current_string_list_val =\n            string_split(*pCtx->current_string_val, \"|\");\n      }\n   }\n\n   pCtx->current_string_val      = NULL;\n   pCtx->current_string_list_val = NULL;\n\n   return true;\n}\n\nstatic bool CCJSONNumberHandler(void *context,\n      const char *pValue, size_t length)\n{\n   CCJSONContext *pCtx              = (CCJSONContext*)context;\n\n   if (pCtx->current_entry_uint_val)\n      *pCtx->current_entry_uint_val = string_to_unsigned(pValue);\n\n   pCtx->current_entry_uint_val     = NULL;\n\n   return true;\n}\n\nstatic bool CCJSONBoolHandler(void *context, bool value)\n{\n   CCJSONContext *pCtx              = (CCJSONContext *)context;\n\n   if (pCtx->current_entry_bool_val)\n      *pCtx->current_entry_bool_val = value;\n\n   pCtx->current_entry_bool_val     = NULL;\n\n   return true;\n}\n\nstatic bool CCJSONStartObjectHandler(void *context)\n{\n   CCJSONContext *pCtx = (CCJSONContext*)context;\n\n   pCtx->object_depth++;\n\n   switch (pCtx->array_depth)\n   {\n      case 0:\n         if (pCtx->object_depth == 1)\n         {\n            if (pCtx->core_info_cache_list)\n               return false;\n            if (!(pCtx->core_info_cache_list = core_info_cache_list_new()))\n               return false;\n         }\n         break;\n      case 1:\n         if (pCtx->object_depth == 2)\n         {\n            if (pCtx->core_info)\n            {\n               core_info_free(pCtx->core_info);\n               free(pCtx->core_info);\n               pCtx->core_info = NULL;\n            }\n\n            if (!(pCtx->core_info = (core_info_t*)calloc(1, sizeof(core_info_t))))\n               return false;\n\n            /* Assume all cores have 'full' savestate support\n             * by default */\n            pCtx->core_info->savestate_support_level =\n               CORE_INFO_SAVESTATE_DETERMINISTIC;\n         }\n         break;\n      case 2:\n         if (pCtx->object_depth == 3 && pCtx->to_firmware)\n         {\n            size_t new_idx            = pCtx->core_info->firmware_count;\n            core_info_firmware_t *tmp = (core_info_firmware_t*)\n               realloc(pCtx->core_info->firmware,\n                     (pCtx->core_info->firmware_count + 1)\n                     * sizeof(core_info_firmware_t));\n\n            if (!tmp)\n               return false;\n\n            tmp[new_idx].path              = NULL;\n            tmp[new_idx].desc              = NULL;\n            tmp[new_idx].missing           = false;\n            tmp[new_idx].optional          = false;\n\n            pCtx->core_info->firmware      = tmp;\n            pCtx->core_info->firmware_count++;\n         }\n         break;\n   }\n\n\n   return true;\n}\n\nstatic bool CCJSONEndObjectHandler(void *context)\n{\n   CCJSONContext *pCtx = (CCJSONContext*)context;\n\n   if (pCtx->array_depth == 1)\n   {\n      switch (pCtx->object_depth)\n      {\n         case 2:\n            if (pCtx->core_info)\n            {\n               core_info_cache_add(\n                     pCtx->core_info_cache_list, pCtx->core_info, true);\n               free(pCtx->core_info);\n               pCtx->core_info = NULL;\n            }\n            break;\n         case 3:\n            pCtx->to_core_file_id = false;\n            break;\n         default:\n            break;\n      }\n   }\n\n   pCtx->object_depth--;\n\n   return true;\n}\n\nstatic bool CCJSONStartArrayHandler(void *context)\n{\n   CCJSONContext *pCtx = (CCJSONContext*)context;\n   pCtx->array_depth++;\n   return true;\n}\n\nstatic bool CCJSONEndArrayHandler(void *context)\n{\n   CCJSONContext *pCtx = (CCJSONContext*)context;\n\n   if ((pCtx->object_depth == 2) && (pCtx->array_depth == 2))\n      pCtx->to_firmware = false;\n\n   pCtx->array_depth--;\n\n   return true;\n}\n\n/* JSON Handlers END */\n#endif\n\n/* Note: 'dst' must be zero initialised, or memory\n * leaks will occur */\nstatic void core_info_copy(core_info_t *src, core_info_t *dst)\n{\n   dst->path                      = src->path                 ? strdup(src->path)                 : NULL;\n   dst->display_name              = src->display_name         ? strdup(src->display_name)         : NULL;\n   dst->display_version           = src->display_version      ? strdup(src->display_version)      : NULL;\n   dst->core_name                 = src->core_name            ? strdup(src->core_name)            : NULL;\n   dst->system_manufacturer       = src->system_manufacturer  ? strdup(src->system_manufacturer)  : NULL;\n   dst->systemname                = src->systemname           ? strdup(src->systemname)           : NULL;\n   dst->system_id                 = src->system_id            ? strdup(src->system_id)            : NULL;\n   dst->supported_extensions      = src->supported_extensions ? strdup(src->supported_extensions) : NULL;\n   dst->authors                   = src->authors              ? strdup(src->authors)              : NULL;\n   dst->permissions               = src->permissions          ? strdup(src->permissions)          : NULL;\n   dst->licenses                  = src->licenses             ? strdup(src->licenses)             : NULL;\n   dst->categories                = src->categories           ? strdup(src->categories)           : NULL;\n   dst->databases                 = src->databases            ? strdup(src->databases)            : NULL;\n   dst->notes                     = src->notes                ? strdup(src->notes)                : NULL;\n   dst->required_hw_api           = src->required_hw_api      ? strdup(src->required_hw_api)      : NULL;\n   dst->description               = src->description          ? strdup(src->description)          : NULL;\n\n   dst->categories_list           = src->categories_list           ? string_list_clone(src->categories_list)           : NULL;\n   dst->databases_list            = src->databases_list            ? string_list_clone(src->databases_list)            : NULL;\n   dst->note_list                 = src->note_list                 ? string_list_clone(src->note_list)                 : NULL;\n   dst->supported_extensions_list = src->supported_extensions_list ? string_list_clone(src->supported_extensions_list) : NULL;\n   dst->authors_list              = src->authors_list              ? string_list_clone(src->authors_list)              : NULL;\n   dst->permissions_list          = src->permissions_list          ? string_list_clone(src->permissions_list)          : NULL;\n   dst->licenses_list             = src->licenses_list             ? string_list_clone(src->licenses_list)             : NULL;\n   dst->required_hw_api_list      = src->required_hw_api_list      ? string_list_clone(src->required_hw_api_list)      : NULL;\n\n   if (src->firmware_count > 0)\n   {\n      dst->firmware = (core_info_firmware_t*)calloc(src->firmware_count,\n            sizeof(core_info_firmware_t));\n\n      if (dst->firmware)\n      {\n         size_t i;\n\n         dst->firmware_count = src->firmware_count;\n\n         for (i = 0; i < src->firmware_count; i++)\n         {\n            dst->firmware[i].path     = src->firmware[i].path ? strdup(src->firmware[i].path) : NULL;\n            dst->firmware[i].desc     = src->firmware[i].desc ? strdup(src->firmware[i].desc) : NULL;\n            dst->firmware[i].missing  = src->firmware[i].missing;\n            dst->firmware[i].optional = src->firmware[i].optional;\n         }\n      }\n      else\n         dst->firmware_count = 0;\n   }\n\n   dst->core_file_id.str              = src->core_file_id.str\n      ? strdup(src->core_file_id.str) : NULL;\n   dst->core_file_id.hash             = src->core_file_id.hash;\n\n   dst->savestate_support_level       = src->savestate_support_level;\n   dst->has_info                      = src->has_info;\n   dst->supports_no_game              = src->supports_no_game;\n   dst->single_purpose                = src->single_purpose;\n   dst->database_match_archive_member = src->database_match_archive_member;\n   dst->is_experimental               = src->is_experimental;\n   dst->is_locked                     = src->is_locked;\n   dst->is_standalone_exempt          = src->is_standalone_exempt;\n   dst->is_installed                  = src->is_installed;\n}\n\n/* Like core_info_copy, but transfers 'ownership'\n * of internal objects/data structures from 'src'\n * to 'dst' */\nstatic void core_info_transfer(core_info_t *src, core_info_t *dst)\n{\n   dst->path                      = src->path;\n   src->path                      = NULL;\n\n   dst->display_name              = src->display_name;\n   src->display_name              = NULL;\n\n   dst->display_version           = src->display_version;\n   src->display_version           = NULL;\n\n   dst->core_name                 = src->core_name;\n   src->core_name                 = NULL;\n\n   dst->system_manufacturer       = src->system_manufacturer;\n   src->system_manufacturer       = NULL;\n\n   dst->systemname                = src->systemname;\n   src->systemname                = NULL;\n\n   dst->system_id                 = src->system_id;\n   src->system_id                 = NULL;\n\n   dst->supported_extensions      = src->supported_extensions;\n   src->supported_extensions      = NULL;\n\n   dst->authors                   = src->authors;\n   src->authors                   = NULL;\n\n   dst->permissions               = src->permissions;\n   src->permissions               = NULL;\n\n   dst->licenses                  = src->licenses;\n   src->licenses                  = NULL;\n\n   dst->categories                = src->categories;\n   src->categories                = NULL;\n\n   dst->databases                 = src->databases;\n   src->databases                 = NULL;\n\n   dst->notes                     = src->notes;\n   src->notes                     = NULL;\n\n   dst->required_hw_api           = src->required_hw_api;\n   src->required_hw_api           = NULL;\n\n   dst->description               = src->description;\n   src->description               = NULL;\n\n   dst->categories_list           = src->categories_list;\n   src->categories_list           = NULL;\n\n   dst->databases_list            = src->databases_list;\n   src->databases_list            = NULL;\n\n   dst->note_list                 = src->note_list;\n   src->note_list                 = NULL;\n\n   dst->supported_extensions_list = src->supported_extensions_list;\n   src->supported_extensions_list = NULL;\n\n   dst->authors_list              = src->authors_list;\n   src->authors_list              = NULL;\n\n   dst->permissions_list          = src->permissions_list;\n   src->permissions_list          = NULL;\n\n   dst->licenses_list             = src->licenses_list;\n   src->licenses_list             = NULL;\n\n   dst->required_hw_api_list      = src->required_hw_api_list;\n   src->required_hw_api_list      = NULL;\n\n   dst->firmware                  = src->firmware;\n   dst->firmware_count            = src->firmware_count;\n   src->firmware                  = NULL;\n   src->firmware_count            = 0;\n\n   dst->core_file_id.str              = src->core_file_id.str;\n   src->core_file_id.str              = NULL;\n   dst->core_file_id.hash             = src->core_file_id.hash;\n\n   dst->savestate_support_level       = src->savestate_support_level;\n   dst->has_info                      = src->has_info;\n   dst->supports_no_game              = src->supports_no_game;\n   dst->single_purpose                = src->single_purpose;\n   dst->database_match_archive_member = src->database_match_archive_member;\n   dst->is_experimental               = src->is_experimental;\n   dst->is_locked                     = src->is_locked;\n   dst->is_standalone_exempt          = src->is_standalone_exempt;\n   dst->is_installed                  = src->is_installed;\n}\n\nstatic void core_info_cache_list_free(\n      core_info_cache_list_t *core_info_cache_list)\n{\n   size_t i;\n\n   if (!core_info_cache_list)\n      return;\n\n   for (i = 0; i < core_info_cache_list->length; i++)\n   {\n      core_info_t* info = (core_info_t*)&core_info_cache_list->items[i];\n      core_info_free(info);\n   }\n\n   free(core_info_cache_list->items);\n\n   if (core_info_cache_list->version)\n      free(core_info_cache_list->version);\n\n   free(core_info_cache_list);\n}\n\nstatic core_info_t *core_info_cache_find(\n      core_info_cache_list_t *list, char *core_file_id)\n{\n   uint32_t hash;\n   size_t i;\n\n   if (  !list\n       || string_is_empty(core_file_id))\n      return NULL;\n\n   hash = core_info_hash_string(core_file_id);\n\n   for (i = 0; i < list->length; i++)\n   {\n      core_info_t *info = (core_info_t*)&list->items[i];\n\n      if (!info)\n         continue;\n\n      if (  (info->core_file_id.hash == hash)\n          && string_is_equal(info->core_file_id.str, core_file_id))\n      {\n         info->is_installed = true;\n         return info;\n      }\n   }\n\n   return NULL;\n}\n\nstatic void core_info_cache_add(\n      core_info_cache_list_t *list, core_info_t *info,\n      bool transfer)\n{\n   core_info_t *info_cache = NULL;\n\n   if (   !list\n       || !info\n       || (info->core_file_id.hash == 0)\n       || string_is_empty(info->core_file_id.str))\n      return;\n\n   if (list->length >= list->capacity)\n   {\n      size_t prev_capacity   = list->capacity;\n      core_info_t *items_tmp = (core_info_t*)realloc(list->items,\n            (list->capacity << 1) * sizeof(core_info_t));\n\n      if (!items_tmp)\n         return;\n\n      list->capacity         = list->capacity << 1;\n      list->items            = items_tmp;\n\n      memset(&list->items[prev_capacity], 0,\n            (list->capacity - prev_capacity) * sizeof(core_info_t));\n   }\n\n   info_cache = (core_info_t*)&list->items[list->length];\n\n   if (transfer)\n      core_info_transfer(info, info_cache);\n   else\n      core_info_copy(info, info_cache);\n\n   list->length++;\n}\n\n#ifdef HAVE_CORE_INFO_CACHE\nstatic core_info_cache_list_t *core_info_cache_list_new(void)\n{\n   core_info_cache_list_t *core_info_cache_list =\n      (core_info_cache_list_t *)malloc(sizeof(*core_info_cache_list));\n   if (!core_info_cache_list)\n      return NULL;\n\n   core_info_cache_list->length = 0;\n   core_info_cache_list->items  = (core_info_t *)\n      calloc(CORE_INFO_CACHE_DEFAULT_CAPACITY,\n            sizeof(core_info_t));\n\n   if (!core_info_cache_list->items)\n   {\n      core_info_cache_list_free(core_info_cache_list);\n      return NULL;\n   }\n\n   core_info_cache_list->capacity = CORE_INFO_CACHE_DEFAULT_CAPACITY;\n   core_info_cache_list->refresh  = false;\n   core_info_cache_list->version  = NULL;\n\n   return core_info_cache_list;\n}\n\nstatic core_info_cache_list_t *core_info_cache_read(const char *info_dir)\n{\n   intfstream_t *file                           = NULL;\n   rjson_t *parser                              = NULL;\n   CCJSONContext context                        = {0};\n   core_info_cache_list_t *core_info_cache_list = NULL;\n   char file_path[PATH_MAX_LENGTH];\n\n   /* Check whether a 'force refresh' file\n    * is present */\n   if (string_is_empty(info_dir))\n      strlcpy(file_path,\n            FILE_PATH_CORE_INFO_CACHE_REFRESH, sizeof(file_path));\n   else\n      fill_pathname_join_special(file_path,\n            info_dir, FILE_PATH_CORE_INFO_CACHE_REFRESH,\n            sizeof(file_path));\n\n   if (path_is_valid(file_path))\n      return core_info_cache_list_new();\n\n   /* Open info cache file */\n   if (string_is_empty(info_dir))\n      strlcpy(file_path, FILE_PATH_CORE_INFO_CACHE, sizeof(file_path));\n   else\n      fill_pathname_join_special(file_path, info_dir,\n            FILE_PATH_CORE_INFO_CACHE,\n            sizeof(file_path));\n\n#if defined(HAVE_ZLIB)\n   file = intfstream_open_rzip_file(file_path,\n         RETRO_VFS_FILE_ACCESS_READ);\n#else\n   file = intfstream_open_file(file_path,\n         RETRO_VFS_FILE_ACCESS_READ,\n         RETRO_VFS_FILE_ACCESS_HINT_NONE);\n#endif\n\n   if (!file)\n      return core_info_cache_list_new();\n\n   /* Parse info cache file */\n   if (!(parser = rjson_open_stream(file)))\n   {\n      RARCH_ERR(\"[Core Info]: Failed to create JSON parser.\\n\");\n      goto end;\n   }\n\n   rjson_set_options(parser,\n           RJSON_OPTION_ALLOW_UTF8BOM\n         | RJSON_OPTION_ALLOW_COMMENTS\n         | RJSON_OPTION_ALLOW_UNESCAPED_CONTROL_CHARACTERS\n         | RJSON_OPTION_REPLACE_INVALID_ENCODING);\n\n   if (rjson_parse(parser, &context,\n         CCJSONObjectMemberHandler,\n         CCJSONStringHandler,\n         CCJSONNumberHandler,\n         CCJSONStartObjectHandler,\n         CCJSONEndObjectHandler,\n         CCJSONStartArrayHandler,\n         CCJSONEndArrayHandler,\n         CCJSONBoolHandler,\n         NULL) /* Unused null handler */\n         != RJSON_DONE)\n   {\n      RARCH_WARN(\"[Core Info]: Error parsing chunk:\\n---snip---\\n%.*s\\n---snip---\\n\",\n            rjson_get_source_context_len(parser),\n            rjson_get_source_context_buf(parser));\n      RARCH_WARN(\"[Core Info]: Error: Invalid JSON at line %d, column %d - %s.\\n\",\n            (int)rjson_get_source_line(parser),\n            (int)rjson_get_source_column(parser),\n            (*rjson_get_error(parser)\n             ? rjson_get_error(parser)\n             : \"format error\"));\n\n      /* Info cache is corrupt - discard it */\n      core_info_cache_list_free(context.core_info_cache_list);\n      core_info_cache_list = core_info_cache_list_new();\n   }\n   else\n      core_info_cache_list = context.core_info_cache_list;\n\n   rjson_free(parser);\n\n   /* Clean up leftovers in the event of\n    * a parsing error */\n   if (context.core_info)\n   {\n      core_info_free(context.core_info);\n      free(context.core_info);\n   }\n\n   if (!core_info_cache_list)\n      goto end;\n\n   /* If info cache file has the wrong version\n    * number, discard it */\n   if (    string_is_empty(core_info_cache_list->version)\n       || !string_is_equal(core_info_cache_list->version,\n            CORE_INFO_CACHE_VERSION))\n   {\n      RARCH_WARN(\"[Core Info]: Core info cache has invalid version\"\n            \" - forcing refresh (required v%s, found v%s).\\n\",\n            CORE_INFO_CACHE_VERSION,\n            core_info_cache_list->version);\n\n      core_info_cache_list_free(context.core_info_cache_list);\n      core_info_cache_list = core_info_cache_list_new();\n   }\n\nend:\n   intfstream_close(file);\n   free(file);\n\n   return core_info_cache_list;\n}\n#endif\n\nstatic bool core_info_cache_write(core_info_cache_list_t *list, const char *info_dir)\n{\n   intfstream_t *file    = NULL;\n   rjsonwriter_t *writer = NULL;\n   bool success          = false;\n   char file_path[PATH_MAX_LENGTH];\n   size_t i, j;\n\n   if (!list)\n      return false;\n\n   /* Open info cache file */\n   if (string_is_empty(info_dir))\n      strlcpy(file_path, FILE_PATH_CORE_INFO_CACHE, sizeof(file_path));\n   else\n      fill_pathname_join_special(file_path, info_dir,\n            FILE_PATH_CORE_INFO_CACHE,\n            sizeof(file_path));\n\n#if defined(CORE_INFO_CACHE_COMPRESS)\n   file = intfstream_open_rzip_file(file_path,\n         RETRO_VFS_FILE_ACCESS_WRITE);\n#else\n   file = intfstream_open_file(file_path,\n         RETRO_VFS_FILE_ACCESS_WRITE,\n         RETRO_VFS_FILE_ACCESS_HINT_NONE);\n#endif\n\n   if (!file)\n   {\n      RARCH_ERR(\"[Core Info]: Failed to write core info cache file: \\\"%s\\\".\\n\", file_path);\n      return false;\n   }\n\n   /* Write info cache */\n   if (!(writer = rjsonwriter_open_stream(file)))\n   {\n      RARCH_ERR(\"[Core Info]: Failed to create JSON writer.\\n\");\n      goto end;\n   }\n\n#if defined(CORE_INFO_CACHE_COMPRESS)\n   /* When compressing info cache, human readability\n    * is not a factor - can skip all indentation\n    * and new line characters */\n   rjsonwriter_set_options(writer, RJSONWRITER_OPTION_SKIP_WHITESPACE);\n#endif\n\n   rjsonwriter_raw(writer, \"{\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n   rjsonwriter_add_spaces(writer, 2);\n   rjsonwriter_add_string(writer, \"version\");\n   rjsonwriter_raw(writer, \":\", 1);\n   rjsonwriter_raw(writer, \" \", 1);\n   rjsonwriter_add_string(writer, CORE_INFO_CACHE_VERSION);\n   rjsonwriter_raw(writer, \",\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n   rjsonwriter_add_spaces(writer, 2);\n   rjsonwriter_add_string(writer, \"items\");\n   rjsonwriter_raw(writer, \":\", 1);\n   rjsonwriter_raw(writer, \" \", 1);\n   rjsonwriter_raw(writer, \"[\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n\n   for (i = 0; i < list->length; i++)\n   {\n      core_info_t* info = &list->items[i];\n\n      if (!info || !info->is_installed)\n         continue;\n\n      if (i > 0)\n      {\n         rjsonwriter_raw(writer, \",\", 1);\n         rjsonwriter_raw(writer, \"\\n\", 1);\n      }\n\n      rjsonwriter_add_spaces(writer, 4);\n      rjsonwriter_raw(writer, \"{\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"display_name\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->display_name);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"display_version\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->display_version);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"core_name\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->core_name);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"system_manufacturer\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->system_manufacturer);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"systemname\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->systemname);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"system_id\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->system_id);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"supported_extensions\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->supported_extensions);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"authors\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->authors);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"permissions\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->permissions);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"licenses\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->licenses);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"categories\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->categories);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"databases\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->databases);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"notes\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->notes);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"required_hw_api\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->required_hw_api);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"description\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->description);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      if (info->firmware_count > 0)\n      {\n         rjsonwriter_add_spaces(writer, 6);\n         rjsonwriter_add_string(writer, \"firmware\");\n         rjsonwriter_raw(writer, \":\", 1);\n         rjsonwriter_raw(writer, \" \", 1);\n         rjsonwriter_raw(writer, \"[\", 1);\n         rjsonwriter_raw(writer, \"\\n\", 1);\n\n         for (j = 0; j < info->firmware_count; j++)\n         {\n            rjsonwriter_add_spaces(writer, 8);\n            rjsonwriter_raw(writer, \"{\", 1);\n            rjsonwriter_raw(writer, \"\\n\", 1);\n            rjsonwriter_add_spaces(writer, 10);\n            rjsonwriter_add_string(writer, \"path\");\n            rjsonwriter_raw(writer, \":\", 1);\n            rjsonwriter_raw(writer, \" \", 1);\n            rjsonwriter_add_string(writer, info->firmware[j].path);\n            rjsonwriter_raw(writer, \",\", 1);\n            rjsonwriter_raw(writer, \"\\n\", 1);\n            rjsonwriter_add_spaces(writer, 10);\n            rjsonwriter_add_string(writer, \"desc\");\n            rjsonwriter_raw(writer, \":\", 1);\n            rjsonwriter_raw(writer, \" \", 1);\n            rjsonwriter_add_string(writer, info->firmware[j].desc);\n            rjsonwriter_raw(writer, \",\", 1);\n            rjsonwriter_raw(writer, \"\\n\", 1);\n            rjsonwriter_add_spaces(writer, 10);\n            rjsonwriter_add_string(writer, \"optional\");\n            rjsonwriter_raw(writer, \":\", 1);\n            rjsonwriter_raw(writer, \" \", 1);\n            {\n               bool value = info->firmware[j].optional;\n               rjsonwriter_raw(writer, (value ? \"true\" : \"false\"), (value ? 4 : 5));\n            }\n            rjsonwriter_raw(writer, \"\\n\", 1);\n            rjsonwriter_add_spaces(writer, 8);\n            rjsonwriter_raw(writer, \"}\", 1);\n\n            if (j < info->firmware_count - 1)\n               rjsonwriter_raw(writer, \",\", 1);\n\n            rjsonwriter_raw(writer, \"\\n\", 1);\n         }\n\n         rjsonwriter_add_spaces(writer, 6);\n         rjsonwriter_raw(writer, \"]\", 1);\n         rjsonwriter_raw(writer, \",\", 1);\n         rjsonwriter_raw(writer, \"\\n\", 1);\n      }\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"core_file_id\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_raw(writer, \"{\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n      rjsonwriter_add_spaces(writer, 8);\n      rjsonwriter_add_string(writer, \"str\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, info->core_file_id.str);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n      rjsonwriter_add_spaces(writer, 8);\n      rjsonwriter_add_string(writer, \"hash\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%u\", info->core_file_id.hash);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_raw(writer, \"}\", 1);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"firmware_count\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%u\", info->firmware_count);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"savestate_support_level\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%u\", info->savestate_support_level);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"has_info\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      {\n         bool value = info->has_info;\n         rjsonwriter_raw(writer, (value ? \"true\" : \"false\"), (value ? 4 : 5));\n      }\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"supports_no_game\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      {\n         bool value = info->supports_no_game;\n         rjsonwriter_raw(writer, (value ? \"true\" : \"false\"), (value ? 4 : 5));\n      }\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"single_purpose\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      {\n         bool value = info->single_purpose;\n         rjsonwriter_raw(writer, (value ? \"true\" : \"false\"), (value ? 4 : 5));\n      }\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"database_match_archive_member\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      {\n         bool value = info->database_match_archive_member;\n         rjsonwriter_raw(writer, (value ? \"true\" : \"false\"), (value ? 4 : 5));\n      }\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"is_experimental\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      {\n         bool value = info->is_experimental;\n         rjsonwriter_raw(writer, (value ? \"true\" : \"false\"), (value ? 4 : 5));\n      }\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 4);\n      rjsonwriter_raw(writer, \"}\", 1);\n   }\n\n   rjsonwriter_raw(writer, \"\\n\", 1);\n   rjsonwriter_add_spaces(writer, 2);\n   rjsonwriter_raw(writer, \"]\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n   rjsonwriter_raw(writer, \"}\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n   rjsonwriter_free(writer);\n\n   RARCH_LOG(\"[Core Info]: Wrote to cache file: \\\"%s\\\".\\n\", file_path);\n   success = true;\n\n   /* Remove 'force refresh' file, if required */\n   if (string_is_empty(info_dir))\n      strlcpy(file_path,\n            FILE_PATH_CORE_INFO_CACHE_REFRESH, sizeof(file_path));\n   else\n      fill_pathname_join_special(file_path,\n            info_dir, FILE_PATH_CORE_INFO_CACHE_REFRESH,\n            sizeof(file_path));\n\n   if (path_is_valid(file_path))\n      filestream_delete(file_path);\n\nend:\n   intfstream_close(file);\n   free(file);\n\n   list->refresh = false;\n   return success;\n}\n\nstatic void core_info_check_uninstalled(core_info_cache_list_t *list)\n{\n   size_t i;\n\n   if (!list)\n      return;\n\n   for (i = 0; i < list->length; i++)\n   {\n      core_info_t *info = (core_info_t *)&list->items[i];\n\n      if (!info)\n         continue;\n\n      if (!info->is_installed)\n      {\n         list->refresh = true;\n         return;\n      }\n   }\n}\n\n/* When called, generates a temporary file\n * that will force an info cache refresh the\n * next time that core info is initialised with\n * caching enabled */\nbool core_info_cache_force_refresh(const char *path_info)\n{\n   char file_path[PATH_MAX_LENGTH];\n\n   /* Get 'force refresh' file path */\n   if (string_is_empty(path_info))\n      strlcpy(file_path,\n            FILE_PATH_CORE_INFO_CACHE_REFRESH, sizeof(file_path));\n   else\n      fill_pathname_join_special(file_path,\n            path_info, FILE_PATH_CORE_INFO_CACHE_REFRESH,\n            sizeof(file_path));\n\n   /* Generate a new, empty 'force refresh' file,\n    * if required */\n   if (!path_is_valid(file_path))\n   {\n      RFILE *refresh_file = filestream_open(\n            file_path,\n            RETRO_VFS_FILE_ACCESS_WRITE,\n            RETRO_VFS_FILE_ACCESS_HINT_NONE);\n\n      if (!refresh_file)\n         return false;\n\n      /* We have to write something - just output\n       * a single character */\n      if (filestream_putc(refresh_file, 0) != 0)\n      {\n         filestream_close(refresh_file);\n         return false;\n      }\n\n      filestream_close(refresh_file);\n   }\n\n   return true;\n}\n\n/***********************/\n/* Core Info Cache END */\n/***********************/\n\ntypedef struct\n{\n   const char *path;\n   const char *filename;\n} core_file_path_t;\n\ntypedef struct\n{\n   core_file_path_t *list;\n   size_t size;\n} core_file_path_list_t;\n\ntypedef struct\n{\n   const char *filename;\n   uint32_t hash;\n} core_aux_file_path_t;\n\ntypedef struct\n{\n   core_aux_file_path_t *list;\n   size_t size;\n} core_aux_file_path_list_t;\n\ntypedef struct\n{\n   struct string_list *dir_list;\n   core_file_path_list_t *core_list;\n   core_aux_file_path_list_t *lock_list;\n   core_aux_file_path_list_t *standalone_exempt_list;\n} core_path_list_t;\n\nstatic uint32_t core_info_hash_string(const char *str)\n{\n   unsigned char c;\n   uint32_t hash = (uint32_t)0x811c9dc5;\n   while ((c = (unsigned char)*(str++)) != '\\0')\n      hash = ((hash * (uint32_t)0x01000193) ^ (uint32_t)c);\n   return (hash ? hash : 1);\n}\n\nstatic void core_info_path_list_free(core_path_list_t *path_list)\n{\n   if (!path_list)\n      return;\n\n   if (path_list->core_list)\n   {\n      if (path_list->core_list->list)\n         free(path_list->core_list->list);\n      free(path_list->core_list);\n   }\n\n   if (path_list->lock_list)\n   {\n      if (path_list->lock_list->list)\n         free(path_list->lock_list->list);\n      free(path_list->lock_list);\n   }\n\n   if (path_list->standalone_exempt_list)\n   {\n      if (path_list->standalone_exempt_list->list)\n         free(path_list->standalone_exempt_list->list);\n      free(path_list->standalone_exempt_list);\n   }\n\n   if (path_list->dir_list)\n      string_list_free(path_list->dir_list);\n\n   free(path_list);\n}\n\nstatic core_path_list_t *core_info_path_list_new(const char *core_dir,\n      const char *core_exts, bool show_hidden_files)\n{\n   size_t i, _len;\n   char exts[32];\n   core_path_list_t *path_list       = NULL;\n   struct string_list *core_ext_list = NULL;\n   bool dir_list_ok                  = false;\n\n   if (string_is_empty(core_exts))\n      return NULL;\n\n   if (!(path_list = (core_path_list_t*)calloc(1, sizeof(*path_list))))\n      return NULL;\n\n   if (!(core_ext_list = string_split(core_exts, \"|\")))\n   {\n      core_info_path_list_free(path_list);\n      return NULL;\n   }\n\n   /* Allocate list containers */\n   path_list->dir_list               = string_list_new();\n   path_list->core_list              = (core_file_path_list_t*)\n         calloc(1, sizeof(*path_list->core_list));\n   path_list->lock_list              = (core_aux_file_path_list_t*)\n         calloc(1, sizeof(*path_list->lock_list));\n   path_list->standalone_exempt_list = (core_aux_file_path_list_t*)\n         calloc(1, sizeof(*path_list->standalone_exempt_list));\n\n   if (   !path_list->dir_list\n       || !path_list->core_list\n       || !path_list->lock_list\n       || !path_list->standalone_exempt_list)\n      goto error;\n\n   /* Get list of file extensions to include\n    * > core + lock */\n   _len = strlcpy(exts, core_exts, sizeof(exts));\n#if defined(HAVE_DYNAMIC)\n   /* > 'standalone exempt' */\n   strlcpy(exts + _len, \"|lck|lsae\", sizeof(exts) - _len);\n#else\n   strlcpy(exts + _len, \"|lck\",      sizeof(exts) - _len);\n#endif\n\n   /* Fetch core directory listing */\n   dir_list_ok = dir_list_append(path_list->dir_list,\n         core_dir, exts, false, show_hidden_files,\n               false, false);\n\n#if defined(__WINRT__) || defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP\n   {\n      /* UWP: browse the optional packages for additional cores */\n      struct string_list core_packages = {0};\n\n      if (string_list_initialize(&core_packages))\n      {\n         uwp_fill_installed_core_packages(&core_packages);\n         for (i = 0; i < core_packages.size; i++)\n            dir_list_append(path_list->dir_list,\n                  core_packages.elems[i].data, exts, false,\n                        show_hidden_files, false, false);\n         string_list_deinitialize(&core_packages);\n      }\n   }\n#else\n   /* Keep the old 'directory not found' behaviour */\n   if (!dir_list_ok)\n      goto error;\n#endif\n\n   /* Allocate sub lists */\n   path_list->core_list->list              = (core_file_path_t*)\n         malloc(path_list->dir_list->size *\n               sizeof(*path_list->core_list->list));\n   path_list->lock_list->list              = (core_aux_file_path_t*)\n         malloc(path_list->dir_list->size *\n               sizeof(*path_list->lock_list->list));\n   path_list->standalone_exempt_list->list = (core_aux_file_path_t*)\n         malloc(path_list->dir_list->size *\n               sizeof(*path_list->standalone_exempt_list->list));\n\n   if (   !path_list->core_list->list\n       || !path_list->lock_list->list\n       || !path_list->standalone_exempt_list->list)\n      goto error;\n\n   /* Parse directory listing */\n   for (i = 0; i < path_list->dir_list->size; i++)\n   {\n      const char *file_path = path_list->dir_list->elems[i].data;\n      const char *filename  = NULL;\n      const char *file_ext  = NULL;\n\n      if (     string_is_empty(file_path)\n          || !(filename = path_basename_nocompression(file_path))\n          || !(file_ext = path_get_extension(filename)))\n         continue;\n\n      /* Check whether this is a core, lock or\n       * 'standalone exempt' file */\n      if (string_list_find_elem(core_ext_list, file_ext))\n      {\n         path_list->core_list->list[\n               path_list->core_list->size].path     = file_path;\n         path_list->core_list->list[\n               path_list->core_list->size].filename = filename;\n         path_list->core_list->size++;\n      }\n      else if (string_is_equal(file_ext, FILE_PATH_LOCK_EXTENSION_NO_DOT))\n      {\n         path_list->lock_list->list[\n               path_list->lock_list->size].filename = filename;\n         path_list->lock_list->list[\n               path_list->lock_list->size].hash     = core_info_hash_string(filename);\n         path_list->lock_list->size++;\n      }\n#if defined(HAVE_DYNAMIC)\n      else if (string_is_equal(file_ext, FILE_PATH_STANDALONE_EXEMPT_EXTENSION_NO_DOT))\n      {\n         path_list->standalone_exempt_list->list[\n               path_list->standalone_exempt_list->size].filename = filename;\n         path_list->standalone_exempt_list->list[\n               path_list->standalone_exempt_list->size].hash     = core_info_hash_string(filename);\n         path_list->standalone_exempt_list->size++;\n      }\n#endif\n   }\n\n   string_list_free(core_ext_list);\n   return path_list;\n\nerror:\n   string_list_free(core_ext_list);\n   core_info_path_list_free(path_list);\n   return NULL;\n}\n\nstatic bool core_info_path_is_locked(\n      core_aux_file_path_list_t *lock_list,\n      const char *core_file_name)\n{\n   size_t i, len;\n   uint32_t hash;\n   char lock_filename[NAME_MAX_LENGTH];\n\n   if (lock_list->size < 1)\n      return false;\n\n   len = strlcpy(lock_filename, core_file_name,\n         sizeof(lock_filename));\n   strlcpy(lock_filename       + len,\n         \".lck\",\n         sizeof(lock_filename) - len);\n\n   hash = core_info_hash_string(lock_filename);\n\n   for (i = 0; i < lock_list->size; i++)\n   {\n      core_aux_file_path_t *lock_file = &lock_list->list[i];\n\n      if (  (lock_file->hash == hash)\n          && string_is_equal(lock_file->filename, lock_filename))\n         return true;\n   }\n\n   return false;\n}\n\nstatic bool core_info_path_is_standalone_exempt(\n      core_aux_file_path_list_t *exempt_list,\n      const char *core_file_name)\n{\n   size_t i, len;\n   uint32_t hash;\n   char exempt_filename[NAME_MAX_LENGTH];\n\n   if (exempt_list->size < 1)\n      return false;\n\n   len = strlcpy(exempt_filename, core_file_name,\n         sizeof(exempt_filename));\n   strlcpy(exempt_filename       + len,\n         \".lsae\",\n         sizeof(exempt_filename) - len);\n\n   hash = core_info_hash_string(exempt_filename);\n\n   for (i = 0; i < exempt_list->size; i++)\n   {\n      core_aux_file_path_t *exempt_file = &exempt_list->list[i];\n\n      if (  (exempt_file->hash == hash)\n          && string_is_equal(exempt_file->filename, exempt_filename))\n         return true;\n   }\n\n   return false;\n}\n\nstatic size_t core_info_get_file_id(const char *core_filename,\n      char *s, size_t len)\n{\n   size_t _len;\n   char *last_underscore = NULL;\n   if (string_is_empty(core_filename))\n      return 0;\n   /* Core file 'id' is filename without extension\n    * or platform-specific suffix */\n   /* > Remove extension */\n   _len = fill_pathname(s, core_filename, \"\", len);\n#if defined(IOS) || defined(OSX)\n   /* iOS framework names, to quote Apple:\n    * \"must contain only alphanumerics, dots, hyphens and must not end with a dot.\"\n    *\n    * Since core names include underscore, which is not allowed, but not dot,\n    * which is, we change underscore to dot. Here, we need to change it back.\n    */\n   string_replace_all_chars(s, '.', '_');\n#endif\n   /* > Remove suffix */\n   last_underscore = (char*)strrchr(s, '_');\n   if (   !string_is_empty(last_underscore)\n       && !string_is_equal(last_underscore, \"_libretro\"))\n   {\n      *last_underscore = '\\0';\n      _len = strlen(s); /* TODO/FIXME - make this unnecessary later on */\n   }\n   return _len;\n}\n\nstatic core_info_t *core_info_find_internal(core_info_list_t *list,\n      const char *core_path)\n{\n   char core_file_id[256];\n\n   if (list && !string_is_empty(core_path))\n   {\n      if ((core_info_get_file_id(path_basename_nocompression(core_path),\n                  core_file_id, sizeof(core_file_id))) > 0)\n      {\n         size_t i;\n         uint32_t hash = core_info_hash_string(core_file_id);\n         for (i = 0; i < list->count; i++)\n         {\n            core_info_t *info = &list->list[i];\n            if ((info->core_file_id.hash == hash)\n                  && string_is_equal(info->core_file_id.str, core_file_id))\n               return info;\n         }\n      }\n   }\n\n   return NULL;\n}\n\nstatic void core_info_resolve_firmware(\n      core_info_t *info, config_file_t *conf)\n{\n   unsigned i;\n   size_t _len;\n   char prefix[12];\n   unsigned firmware_count        = 0;\n   core_info_firmware_t *firmware = NULL;\n\n   if (!config_get_uint(conf, \"firmware_count\", &firmware_count))\n      return;\n\n   firmware = (core_info_firmware_t*)calloc(\n         firmware_count, sizeof(*firmware));\n\n   if (!firmware)\n      return;\n\n   _len = strlcpy(prefix, \"firmware\", sizeof(prefix));\n\n   for (i = 0; i < firmware_count; i++)\n   {\n      size_t _len2;\n      char key[64];\n      struct config_entry_list *entry = NULL;\n      bool tmp_bool                   = false;\n\n      snprintf(prefix + _len, sizeof(prefix) - _len, \"%u_\", i);\n      _len2 = strlcpy(key, prefix, sizeof(key));\n      strlcpy(key + _len2, \"opt\", sizeof(key) - _len2);\n\n      if (config_get_bool(conf, key, &tmp_bool))\n         firmware[i].optional = tmp_bool;\n\n      strlcpy(key + _len2, \"path\", sizeof(key) - _len2);\n\n      entry = config_get_entry(conf, key);\n\n      if (entry && !string_is_empty(entry->value))\n      {\n         firmware[i].path = entry->value;\n         entry->value     = NULL;\n      }\n\n      strlcpy(key + _len2, \"desc\", sizeof(key) - _len2);\n\n      entry = config_get_entry(conf, key);\n\n      if (entry && !string_is_empty(entry->value))\n      {\n         firmware[i].desc = entry->value;\n         entry->value     = NULL;\n      }\n   }\n\n   info->firmware_count = firmware_count;\n   info->firmware       = firmware;\n}\n\nstatic config_file_t *core_info_get_config_file(\n      const char *core_file_id, const char *info_dir)\n{\n   if (!string_is_empty(info_dir))\n   {\n      char info_path[PATH_MAX_LENGTH];\n      fill_pathname_join_special(info_path, info_dir,\n            core_file_id, sizeof(info_path));\n      return config_file_new_from_path_to_string(info_path);\n   }\n   return config_file_new_from_path_to_string(core_file_id);\n}\n\nstatic void core_info_parse_config_file(\n      core_info_list_t *list, core_info_t *info,\n      config_file_t *conf)\n{\n   bool tmp_bool                   = false;\n   struct config_entry_list *entry = config_get_entry(conf, \"display_name\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->display_name = entry->value;\n      entry->value       = NULL;\n   }\n\n   entry = config_get_entry(conf, \"display_version\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->display_version = entry->value;\n      entry->value          = NULL;\n   }\n\n   entry = config_get_entry(conf, \"corename\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->core_name = entry->value;\n      entry->value    = NULL;\n   }\n\n   entry = config_get_entry(conf, \"systemname\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->systemname = entry->value;\n      entry->value     = NULL;\n   }\n\n   entry = config_get_entry(conf, \"systemid\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->system_id = entry->value;\n      entry->value    = NULL;\n   }\n\n   entry = config_get_entry(conf, \"manufacturer\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->system_manufacturer = entry->value;\n      entry->value              = NULL;\n   }\n\n   entry = config_get_entry(conf, \"supported_extensions\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->supported_extensions      = entry->value;\n      entry->value                    = NULL;\n\n      info->supported_extensions_list =\n            string_split(info->supported_extensions, \"|\");\n   }\n\n   entry = config_get_entry(conf, \"authors\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->authors      = entry->value;\n      entry->value       = NULL;\n\n      info->authors_list =\n            string_split(info->authors, \"|\");\n   }\n\n   entry = config_get_entry(conf, \"permissions\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->permissions      = entry->value;\n      entry->value           = NULL;\n\n      info->permissions_list =\n            string_split(info->permissions, \"|\");\n   }\n\n   entry = config_get_entry(conf, \"license\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->licenses      = entry->value;\n      entry->value        = NULL;\n\n      info->licenses_list =\n            string_split(info->licenses, \"|\");\n   }\n\n   entry = config_get_entry(conf, \"categories\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->categories      = entry->value;\n      entry->value          = NULL;\n\n      info->categories_list =\n            string_split(info->categories, \"|\");\n   }\n\n   entry = config_get_entry(conf, \"database\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->databases      = entry->value;\n      entry->value         = NULL;\n\n      info->databases_list =\n            string_split(info->databases, \"|\");\n   }\n\n   entry = config_get_entry(conf, \"notes\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->notes     = entry->value;\n      entry->value    = NULL;\n\n      info->note_list =\n            string_split(info->notes, \"|\");\n   }\n\n   entry = config_get_entry(conf, \"required_hw_api\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->required_hw_api      = entry->value;\n      entry->value               = NULL;\n\n      info->required_hw_api_list =\n            string_split(info->required_hw_api, \"|\");\n   }\n\n   entry = config_get_entry(conf, \"description\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->description = entry->value;\n      entry->value      = NULL;\n   }\n\n   if (config_get_bool(conf, \"supports_no_game\",\n            &tmp_bool))\n      info->supports_no_game = tmp_bool;\n\n   if (config_get_bool(conf, \"single_purpose\",\n            &tmp_bool))\n      info->single_purpose = tmp_bool;\n\n   if (config_get_bool(conf, \"database_match_archive_member\",\n            &tmp_bool))\n      info->database_match_archive_member = tmp_bool;\n\n   if (config_get_bool(conf, \"is_experimental\",\n            &tmp_bool))\n      info->is_experimental = tmp_bool;\n\n\n   /* Savestate support level is slightly more complex,\n    * since it is a value derived from two configuration\n    * parameters */\n\n   /* > Assume all cores have 'full' savestate support\n    *   by default */\n   info->savestate_support_level =\n         CORE_INFO_SAVESTATE_DETERMINISTIC;\n\n   /* > Check whether savestate functionality is defined\n    *   in the info file */\n   if (config_get_bool(conf, \"savestate\", &tmp_bool))\n   {\n      if (tmp_bool)\n      {\n         /* Check if savestate features are defined */\n         entry = config_get_entry(conf, \"savestate_features\");\n\n         if (entry && !string_is_empty(entry->value))\n         {\n            if (string_is_equal(entry->value, \"basic\"))\n               info->savestate_support_level =\n                     CORE_INFO_SAVESTATE_BASIC;\n            else if (string_is_equal(entry->value, \"serialized\"))\n               info->savestate_support_level =\n                     CORE_INFO_SAVESTATE_SERIALIZED;\n         }\n      }\n      else\n         info->savestate_support_level =\n               CORE_INFO_SAVESTATE_DISABLED;\n   }\n\n   core_info_resolve_firmware(info, conf);\n\n   info->has_info = true;\n   list->info_count++;\n}\n\nstatic void core_info_list_resolve_all_extensions(\n      core_info_list_t *core_info_list)\n{\n   size_t i              = 0;\n   size_t all_ext_len    = 0;\n   char *all_ext         = NULL;\n\n   for (i = 0; i < core_info_list->count; i++)\n   {\n      if (core_info_list->list[i].supported_extensions)\n         all_ext_len +=\n            (strlen(core_info_list->list[i].supported_extensions) + 2);\n   }\n\n   all_ext_len       += STRLEN_CONST(\"7z|\") + STRLEN_CONST(\"zip|\");\n   if (!(all_ext      = (char*)calloc(1, all_ext_len)))\n      return;\n\n   core_info_list->all_ext = all_ext;\n\n   for (i = 0; i < core_info_list->count; i++)\n   {\n      size_t _len;\n      if (!core_info_list->list[i].supported_extensions)\n         continue;\n\n      _len = strlcat(core_info_list->all_ext,\n            core_info_list->list[i].supported_extensions, all_ext_len);\n      strlcpy(core_info_list->all_ext + _len, \"|\", all_ext_len - _len);\n   }\n#ifdef HAVE_7ZIP\n   strlcat(core_info_list->all_ext, \"7z|\", all_ext_len);\n#endif\n#ifdef HAVE_ZLIB\n   strlcat(core_info_list->all_ext, \"zip|\", all_ext_len);\n#endif\n}\n\nstatic void core_info_free(core_info_t* info)\n{\n   size_t i;\n\n   free(info->path);\n   free(info->core_name);\n   free(info->systemname);\n   free(info->system_id);\n   free(info->system_manufacturer);\n   free(info->display_name);\n   free(info->display_version);\n   free(info->supported_extensions);\n   free(info->authors);\n   free(info->permissions);\n   free(info->licenses);\n   free(info->categories);\n   free(info->databases);\n   free(info->notes);\n   free(info->required_hw_api);\n   free(info->description);\n   string_list_free(info->supported_extensions_list);\n   string_list_free(info->authors_list);\n   string_list_free(info->note_list);\n   string_list_free(info->permissions_list);\n   string_list_free(info->licenses_list);\n   string_list_free(info->categories_list);\n   string_list_free(info->databases_list);\n   string_list_free(info->required_hw_api_list);\n\n   for (i = 0; i < info->firmware_count; i++)\n   {\n      if (info->firmware[i].path)\n         free(info->firmware[i].path);\n      if (info->firmware[i].desc)\n         free(info->firmware[i].desc);\n      info->firmware[i].path = NULL;\n      info->firmware[i].desc = NULL;\n   }\n   free(info->firmware);\n\n   free(info->core_file_id.str);\n}\n\nstatic void core_info_list_free(core_info_list_t *core_info_list)\n{\n   size_t i;\n\n   if (!core_info_list)\n      return;\n\n   for (i = 0; i < core_info_list->count; i++)\n   {\n      core_info_t *info = (core_info_t*)&core_info_list->list[i];\n      core_info_free(info);\n   }\n\n   free(core_info_list->all_ext);\n   free(core_info_list->list);\n   free(core_info_list);\n}\n\nstatic core_info_list_t *core_info_list_new(const char *path,\n      const char *libretro_info_dir,\n      const char *exts,\n      bool dir_show_hidden_files,\n      bool enable_cache,\n      bool *cache_supported)\n{\n   size_t i;\n   core_info_t *core_info                       = NULL;\n   core_info_list_t *core_info_list             = NULL;\n   core_info_cache_list_t *core_info_cache_list = NULL;\n   const char *info_dir                         = libretro_info_dir;\n   core_path_list_t *path_list                  = core_info_path_list_new(\n         path, exts, dir_show_hidden_files);\n   if (!path_list)\n      goto error;\n\n   if (!(core_info_list = (core_info_list_t*)malloc(sizeof(*core_info_list))))\n      goto error;\n\n   core_info_list->list       = NULL;\n   core_info_list->count      = 0;\n   core_info_list->info_count = 0;\n   core_info_list->all_ext    = NULL;\n\n   if (!(core_info = (core_info_t*)calloc(path_list->core_list->size,\n         sizeof(*core_info))))\n   {\n      core_info_list_free(core_info_list);\n      goto error;\n   }\n\n   core_info_list->list  = core_info;\n   core_info_list->count = path_list->core_list->size;\n\n#ifdef HAVE_CORE_INFO_CACHE\n   /* Read core info cache, if enabled */\n   if (enable_cache)\n   {\n      if (!(core_info_cache_list = core_info_cache_read(info_dir)))\n         goto error;\n   }\n#endif\n\n   for (i = 0; i < path_list->core_list->size; i++)\n   {\n      char core_file_id[256];\n      config_file_t *conf         = NULL;\n      core_info_t *info           = &core_info[i];\n      core_file_path_t *core_file = &path_list->core_list->list[i];\n      const char *base_path       = core_file->path;\n      const char *core_filename   = core_file->filename;\n      size_t _len = core_info_get_file_id(core_filename, core_file_id,\n               sizeof(core_file_id));\n      if (_len == 0)\n         continue;\n\n      /* If info cache is available, search for\n       * current core */\n      if (core_info_cache_list)\n      {\n         core_info_t *info_cache = core_info_cache_find(\n               core_info_cache_list, core_file_id);\n\n         if (info_cache)\n         {\n            core_info_copy(info_cache, info);\n\n            /* Core path is 'dynamic', and cannot\n             * be cached (i.e. core directory may\n             * change between runs) */\n            if (info->path)\n               free(info->path);\n            info->path = strdup(base_path);\n\n            /* Core lock status is 'dynamic', and\n             * cannot be cached */\n            info->is_locked = core_info_path_is_locked(\n                  path_list->lock_list, core_filename);\n\n            /* Core 'standalone exempt' status is 'dynamic',\n             * and cannot be cached\n             * > It is also dependent upon whether the core\n             *   supports contentless operation */\n            info->is_standalone_exempt = info->supports_no_game &&\n                  core_info_path_is_standalone_exempt(\n                        path_list->standalone_exempt_list,\n                        core_filename);\n\n            /* 'info_count' is normally incremented inside\n             * core_info_parse_config_file(). If core entry\n             * is cached, must instead increment the value\n             * here */\n            if (info->has_info)\n               core_info_list->info_count++;\n\n            continue;\n         }\n      }\n\n      /* Cache core path */\n      info->path              = strdup(base_path);\n\n      /* Get core lock status */\n      info->is_locked         = core_info_path_is_locked(\n            path_list->lock_list, core_filename);\n\n      /* Cache core file 'id' */\n      info->core_file_id.str  = strdup(core_file_id);\n      info->core_file_id.hash = core_info_hash_string(core_file_id);\n\n      strlcpy(core_file_id + _len, \".info\", sizeof(core_file_id) - _len);\n\n      /* Parse core info file */\n      if ((conf = core_info_get_config_file(core_file_id, info_dir)))\n      {\n         core_info_parse_config_file(core_info_list, info, conf);\n         config_file_free(conf);\n      }\n\n      /* Get fallback display name, if required */\n      if (!info->display_name)\n         info->display_name = strdup(core_filename);\n\n      /* Get core 'standalone exempt' status */\n      info->is_standalone_exempt = info->supports_no_game &&\n            core_info_path_is_standalone_exempt(\n                  path_list->standalone_exempt_list,\n                  core_filename);\n\n      info->is_installed = true;\n\n      /* If info cache is enabled and we reach this\n       * point, current core is uncached\n       * > Add it to the list, and trigger a cache\n       *   refresh */\n      if (core_info_cache_list)\n      {\n         core_info_cache_add(core_info_cache_list, info, false);\n         core_info_cache_list->refresh = true;\n      }\n   }\n\n   core_info_list_resolve_all_extensions(core_info_list);\n\n   /* If info cache is enabled\n    * > Check whether any cached cores have been\n    *   uninstalled since the last run (triggers\n    *   a refresh)\n    * > Write new cache to disk if updates are\n    *   required */\n   *cache_supported = true;\n   if (core_info_cache_list)\n   {\n      core_info_check_uninstalled(core_info_cache_list);\n\n      if (core_info_cache_list->refresh)\n         *cache_supported = core_info_cache_write(\n               core_info_cache_list, info_dir);\n\n      core_info_cache_list_free(core_info_cache_list);\n   }\n\n   core_info_path_list_free(path_list);\n   return core_info_list;\n\nerror:\n   core_info_path_list_free(path_list);\n   return NULL;\n}\n\n/* Shallow-copies internal state.\n *\n * Data in *info is invalidated when the\n * core_info_list is freed. */\nbool core_info_list_get_info(core_info_list_t *core_info_list,\n      core_info_t *out_info, const char *core_path)\n{\n   if (out_info)\n   {\n      core_info_t *info = core_info_find_internal(\n            core_info_list, core_path);\n\n      memset(out_info, 0, sizeof(*out_info));\n\n      if (info)\n      {\n         *out_info = *info;\n         return true;\n      }\n   }\n\n   return false;\n}\n\n#ifdef HAVE_COMPRESSION\nstatic bool core_info_does_support_any_file(const core_info_t *core,\n      const struct string_list *list)\n{\n   size_t i;\n   if (!list || !core || !core->supported_extensions_list)\n      return false;\n\n   for (i = 0; i < list->size; i++)\n      if (string_list_find_elem_prefix(core->supported_extensions_list,\n               \".\", path_get_extension(list->elems[i].data)))\n         return true;\n   return false;\n}\n#endif\n\nstatic bool core_info_does_support_file(\n      const core_info_t *core, const char *path)\n{\n   const char *basename, *ext;\n\n   if (!core || !core->supported_extensions_list)\n      return false;\n   if (string_is_empty(path))\n      return false;\n\n   basename = path_basename(path);\n\n   /* if a core has / in its list of supported extensions, the core\n      supports loading of directories on the host file system */\n   if (string_is_empty(basename))\n      return string_list_find_elem(core->supported_extensions_list, \"/\");\n\n   ext = strrchr(basename, '.');\n   return string_list_find_elem_prefix(\n         core->supported_extensions_list, \".\", (ext ? ext + 1 : \"\"));\n}\n\n/* qsort_r() is not in standard C, sadly. */\n\nstatic int core_info_qsort_cmp(const void *a_, const void *b_)\n{\n   core_info_state_t *p_coreinfo = &core_info_st;\n   const core_info_t          *a = (const core_info_t*)a_;\n   const core_info_t          *b = (const core_info_t*)b_;\n   int support_a                 = core_info_does_support_file(a,\n         p_coreinfo->tmp_path);\n   int support_b                 = core_info_does_support_file(b,\n         p_coreinfo->tmp_path);\n#ifdef HAVE_COMPRESSION\n   support_a            = support_a ||\n      core_info_does_support_any_file(a, p_coreinfo->tmp_list);\n   support_b            = support_b ||\n      core_info_does_support_any_file(b, p_coreinfo->tmp_list);\n#endif\n\n   if (support_a != support_b)\n      return support_b - support_a;\n   return strcasecmp(a->display_name, b->display_name);\n}\n\nstatic bool core_info_list_update_missing_firmware_internal(\n      core_info_list_t *core_info_list,\n      const char *core_path,\n      const char *systemdir,\n      bool *set_missing_bios)\n{\n   size_t i;\n   char path[PATH_MAX_LENGTH];\n   core_info_t      *info = NULL;\n\n   if (!core_info_list)\n      return false;\n\n   if (!(info = core_info_find_internal(\n         core_info_list, core_path)))\n      return false;\n\n   for (i = 0; i < info->firmware_count; i++)\n   {\n      if (string_is_empty(info->firmware[i].path))\n         continue;\n\n      fill_pathname_join(path, systemdir,\n            info->firmware[i].path, sizeof(path));\n      info->firmware[i].missing = !path_is_valid(path);\n      if (info->firmware[i].missing && !info->firmware[i].optional)\n         *set_missing_bios = true;\n   }\n\n   return true;\n}\n\nvoid core_info_free_current_core(void)\n{\n   core_info_state_t *p_coreinfo = &core_info_st;\n   if (p_coreinfo->current)\n      free(p_coreinfo->current);\n   p_coreinfo->current = NULL;\n}\n\nbool core_info_init_current_core(void)\n{\n   core_info_state_t *p_coreinfo          = &core_info_st;\n   core_info_t *current                   = (core_info_t*)\n      malloc(sizeof(*current));\n   if (!current)\n      return false;\n   current->has_info                      = false;\n   current->supports_no_game              = false;\n   current->single_purpose                = false;\n   current->database_match_archive_member = false;\n   current->is_experimental               = false;\n   current->is_locked                     = false;\n   current->is_standalone_exempt          = false;\n   current->is_installed                  = false;\n   current->firmware_count                = 0;\n   current->savestate_support_level       = CORE_INFO_SAVESTATE_DETERMINISTIC;\n   current->path                          = NULL;\n   current->display_name                  = NULL;\n   current->display_version               = NULL;\n   current->core_name                     = NULL;\n   current->system_manufacturer           = NULL;\n   current->systemname                    = NULL;\n   current->system_id                     = NULL;\n   current->supported_extensions          = NULL;\n   current->authors                       = NULL;\n   current->permissions                   = NULL;\n   current->licenses                      = NULL;\n   current->categories                    = NULL;\n   current->databases                     = NULL;\n   current->notes                         = NULL;\n   current->required_hw_api               = NULL;\n   current->description                   = NULL;\n   current->categories_list               = NULL;\n   current->databases_list                = NULL;\n   current->note_list                     = NULL;\n   current->supported_extensions_list     = NULL;\n   current->authors_list                  = NULL;\n   current->permissions_list              = NULL;\n   current->licenses_list                 = NULL;\n   current->required_hw_api_list          = NULL;\n   current->firmware                      = NULL;\n   current->core_file_id.str              = NULL;\n   current->core_file_id.hash             = 0;\n\n   p_coreinfo->current                    = current;\n   return true;\n}\n\nbool core_info_get_current_core(core_info_t **core)\n{\n   core_info_state_t *p_coreinfo          = &core_info_st;\n   if (!core)\n      return false;\n   *core = p_coreinfo->current;\n   return true;\n}\n\nvoid core_info_deinit_list(void)\n{\n   core_info_state_t *p_coreinfo          = &core_info_st;\n   if (p_coreinfo->curr_list)\n      core_info_list_free(p_coreinfo->curr_list);\n   p_coreinfo->curr_list = NULL;\n}\n\nbool core_info_init_list(\n      const char *path_info, const char *dir_cores,\n      const char *exts,  bool dir_show_hidden_files,\n      bool enable_cache, bool *cache_supported)\n{\n   core_info_state_t *p_coreinfo          = &core_info_st;\n   if (!(p_coreinfo->curr_list            = core_info_list_new(\n               dir_cores,\n               !string_is_empty(path_info)\n               ? path_info\n               : dir_cores,\n               exts,\n               dir_show_hidden_files,\n               enable_cache,\n               cache_supported)))\n      return false;\n   return true;\n}\n\nbool core_info_get_list(core_info_list_t **core)\n{\n   core_info_state_t *p_coreinfo          = &core_info_st;\n   if (!core)\n      return false;\n   *core = p_coreinfo->curr_list;\n   return true;\n}\n\n/* Returns number of installed cores */\nsize_t core_info_count(void)\n{\n   core_info_state_t *p_coreinfo          = &core_info_st;\n   if (p_coreinfo && p_coreinfo->curr_list)\n      return p_coreinfo->curr_list->count;\n   return 0;\n}\n\nbool core_info_list_update_missing_firmware(\n      core_info_ctx_firmware_t *info, bool *set_missing_bios)\n{\n   core_info_state_t *p_coreinfo          = &core_info_st;\n   if (info)\n      return core_info_list_update_missing_firmware_internal(\n            p_coreinfo->curr_list,\n            info->path, info->directory.system,\n            set_missing_bios);\n   return false;\n}\n\nbool core_info_load(const char *core_path)\n{\n   core_info_state_t *p_coreinfo = &core_info_st;\n   core_info_t    *core_info     = NULL;\n\n   if (!p_coreinfo->current)\n      core_info_init_current_core();\n\n   core_info_get_current_core(&core_info);\n\n   if (!p_coreinfo->curr_list)\n      return false;\n\n   if (!core_info_list_get_info(p_coreinfo->curr_list,\n            core_info, core_path))\n      return false;\n\n   return true;\n}\n\nbool core_info_find(const char *core_path,\n      core_info_t **core_info)\n{\n   core_info_state_t *p_coreinfo = &core_info_st;\n   core_info_t *info             = NULL;\n\n   if (!core_info || !p_coreinfo->curr_list)\n      return false;\n\n   if (!(info = core_info_find_internal(p_coreinfo->curr_list, core_path)))\n      return false;\n\n   *core_info = info;\n   return true;\n}\n\ncore_info_t *core_info_get(core_info_list_t *list, size_t i)\n{\n   core_info_t *info = NULL;\n\n   if (!list || (i >= list->count))\n      return NULL;\n   info = (core_info_t*)&list->list[i];\n   if (!info || !info->path)\n      return NULL;\n\n   return info;\n}\n\nvoid core_info_list_get_supported_cores(core_info_list_t *core_info_list,\n      const char *path, const core_info_t **infos, size_t *num_infos)\n{\n   size_t i;\n   size_t supported              = 0;\n#ifdef HAVE_COMPRESSION\n   struct string_list *list      = NULL;\n#endif\n   core_info_state_t *p_coreinfo = &core_info_st;\n   char dir_path[PATH_MAX_LENGTH];\n\n   if (!core_info_list)\n      return;\n\n   if (path_is_directory(path))\n   {\n      /* Add a slash so core_info_does_support_file can know it is\n         a directory without having to check the file system again. */\n      fill_pathname_join_special(dir_path, path, \"\", sizeof(dir_path));\n      path = dir_path;\n   }\n\n   p_coreinfo->tmp_path          = path;\n\n#ifdef HAVE_COMPRESSION\n   if (path_is_compressed_file(path))\n      list                       = file_archive_get_file_list(path, NULL);\n   p_coreinfo->tmp_list          = list;\n#endif\n\n   /* Let supported core come first in list so we can return\n    * a pointer to them. */\n   qsort(core_info_list->list, core_info_list->count,\n         sizeof(core_info_t), core_info_qsort_cmp);\n\n   for (i = 0; i < core_info_list->count; i++, supported++)\n   {\n      const core_info_t *core = &core_info_list->list[i];\n\n      if (core_info_does_support_file(core, path))\n         continue;\n\n#ifdef HAVE_COMPRESSION\n      if (core_info_does_support_any_file(core, list))\n         continue;\n#endif\n\n      break;\n   }\n\n#ifdef HAVE_COMPRESSION\n   if (list)\n      string_list_free(list);\n#endif\n\n   *infos     = core_info_list->list;\n   *num_infos = supported;\n}\n\n/*\n * Matches core A and B file IDs\n *\n * e.g.:\n *   snes9x_libretro.dll and snes9x_libretro_android.so are matched\n *   snes9x__2005_libretro.dll and snes9x_libretro_android.so are\n *   NOT matched\n */\nbool core_info_core_file_id_is_equal(const char *core_path_a,\n      const char *core_path_b)\n{\n   char core_file_id_a[256];\n   char core_file_id_b[256];\n   if (   string_is_empty(core_path_a)\n       || string_is_empty(core_path_b)\n       || (core_info_get_file_id(\n          path_basename_nocompression(core_path_a),\n            core_file_id_a, sizeof(core_file_id_a) == 0))\n       || (core_info_get_file_id(\n          path_basename_nocompression(core_path_b),\n            core_file_id_b, sizeof(core_file_id_b)) == 0))\n      return false;\n   return string_is_equal(core_file_id_a, core_file_id_b);\n}\n\nbool core_info_database_match_archive_member(const char *database_path)\n{\n   char      *database           = NULL;\n   const char      *new_path     = path_basename_nocompression(\n         database_path);\n   core_info_state_t *p_coreinfo = NULL;\n\n   if (string_is_empty(new_path))\n      return false;\n   if (!(database = strdup(new_path)))\n      return false;\n\n   path_remove_extension(database);\n\n   p_coreinfo                     = &core_info_st;\n\n   if (p_coreinfo->curr_list)\n   {\n      size_t i;\n\n      for (i = 0; i < p_coreinfo->curr_list->count; i++)\n      {\n         const core_info_t *info = &p_coreinfo->curr_list->list[i];\n\n         if (!info->database_match_archive_member)\n             continue;\n\n         if (!string_list_find_elem(info->databases_list, database))\n             continue;\n\n         free(database);\n         return true;\n      }\n   }\n\n   free(database);\n   return false;\n}\n\nbool core_info_database_supports_content_path(\n      const char *database_path, const char *path)\n{\n   char      *database           = NULL;\n   const char      *new_path     = path_basename(database_path);\n   core_info_state_t *p_coreinfo = NULL;\n\n   if (string_is_empty(new_path))\n      return false;\n   if (!(database = strdup(new_path)))\n      return false;\n\n   path_remove_extension(database);\n\n   p_coreinfo                    = &core_info_st;\n\n   if (p_coreinfo->curr_list)\n   {\n      size_t i;\n\n      for (i = 0; i < p_coreinfo->curr_list->count; i++)\n      {\n         const core_info_t *info = &p_coreinfo->curr_list->list[i];\n\n         if (!string_list_find_elem(info->supported_extensions_list,\n                  path_get_extension(path)))\n            continue;\n\n         if (!string_list_find_elem(info->databases_list, database))\n            continue;\n\n         free(database);\n         return true;\n      }\n   }\n\n   free(database);\n   return false;\n}\n\nsize_t core_info_list_get_display_name(\n      core_info_list_t *core_info_list,\n      const char *core_path, char *s, size_t len)\n{\n   if (core_info_list)\n   {\n      core_info_t *info = core_info_find_internal(\n            core_info_list, core_path);\n      if (s && info && !string_is_empty(info->display_name))\n         return strlcpy(s, info->display_name, len);\n   }\n   return 0;\n}\n\n/* Returns core_info parameters required for\n * core updater tasks, read from specified file.\n * Returned core_updater_info_t object must be\n * freed using core_info_free_core_updater_info().\n * Returns NULL if 'path' is invalid. */\ncore_updater_info_t *core_info_get_core_updater_info(\n      const char *info_path)\n{\n   struct config_entry_list\n      *entry                 = NULL;\n   bool tmp_bool             = false;\n   core_updater_info_t *info = NULL;\n   config_file_t *conf       = NULL;\n\n   if (string_is_empty(info_path))\n      return NULL;\n\n   /* Read config file */\n   if (!(conf = config_file_new_from_path_to_string(info_path)))\n      return NULL;\n\n   /* Create info struct */\n   if (!(info = (core_updater_info_t*)malloc(sizeof(*info))))\n      return NULL;\n\n   info->is_experimental     = false;\n   info->display_name        = NULL;\n   info->description         = NULL;\n   info->licenses            = NULL;\n\n   /* Fetch required parameters */\n\n   /* > is_experimental */\n   if (config_get_bool(conf, \"is_experimental\", &tmp_bool))\n      info->is_experimental  = tmp_bool;\n\n   /* > display_name */\n   entry                     = config_get_entry(conf, \"display_name\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->display_name     = entry->value;\n      entry->value           = NULL;\n   }\n\n   /* > description */\n   entry                     = config_get_entry(conf, \"description\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->description      = entry->value;\n      entry->value           = NULL;\n   }\n\n   /* > licenses */\n   entry                     = config_get_entry(conf, \"license\");\n\n   if (entry && !string_is_empty(entry->value))\n   {\n      info->licenses         = entry->value;\n      entry->value           = NULL;\n   }\n\n   /* Clean up */\n   config_file_free(conf);\n\n   return info;\n}\n\nvoid core_info_free_core_updater_info(core_updater_info_t *info)\n{\n   if (!info)\n      return;\n\n   if (info->display_name)\n      free(info->display_name);\n\n   if (info->description)\n      free(info->description);\n\n   if (info->licenses)\n      free(info->licenses);\n\n   free(info);\n   info = NULL;\n}\n\nstatic int core_info_qsort_func_path(const core_info_t *a,\n      const core_info_t *b)\n{\n   if (!a || !b || string_is_empty(a->path) || string_is_empty(b->path))\n      return 0;\n   return strcasecmp(a->path, b->path);\n}\n\nstatic int core_info_qsort_func_display_name(const core_info_t *a,\n      const core_info_t *b)\n{\n   if (     !a\n         || !b\n         || string_is_empty(a->display_name)\n         || string_is_empty(b->display_name))\n      return 0;\n   return strcasecmp(a->display_name, b->display_name);\n}\n\nstatic int core_info_qsort_func_core_name(const core_info_t *a,\n      const core_info_t *b)\n{\n   if (     !a\n         || !b\n         || string_is_empty(a->core_name)\n         || string_is_empty(b->core_name))\n      return 0;\n   return strcasecmp(a->core_name, b->core_name);\n}\n\nstatic int core_info_qsort_func_system_name(const core_info_t *a,\n      const core_info_t *b)\n{\n   if (\n            !a\n         || !b\n         || string_is_empty(a->systemname)\n         || string_is_empty(b->systemname))\n      return 0;\n   return strcasecmp(a->systemname, b->systemname);\n}\n\nvoid core_info_qsort(core_info_list_t *core_info_list,\n      enum core_info_list_qsort_type qsort_type)\n{\n   if (!core_info_list)\n      return;\n\n   if (core_info_list->count < 2)\n      return;\n\n   switch (qsort_type)\n   {\n      case CORE_INFO_LIST_SORT_PATH:\n         qsort(core_info_list->list,\n               core_info_list->count,\n               sizeof(core_info_t),\n               (int (*)(const void *, const void *))\n               core_info_qsort_func_path);\n         break;\n      case CORE_INFO_LIST_SORT_DISPLAY_NAME:\n         qsort(core_info_list->list,\n               core_info_list->count,\n               sizeof(core_info_t),\n               (int (*)(const void *, const void *))\n               core_info_qsort_func_display_name);\n         break;\n      case CORE_INFO_LIST_SORT_CORE_NAME:\n         qsort(core_info_list->list,\n               core_info_list->count,\n               sizeof(core_info_t),\n               (int (*)(const void *, const void *))\n               core_info_qsort_func_core_name);\n         break;\n      case CORE_INFO_LIST_SORT_SYSTEM_NAME:\n         qsort(core_info_list->list,\n               core_info_list->count,\n               sizeof(core_info_t),\n               (int (*)(const void *, const void *))\n               core_info_qsort_func_system_name);\n         break;\n      default:\n         break;\n   }\n}\n\nbool core_info_current_supports_savestate(void)\n{\n   core_info_state_t *p_coreinfo = &core_info_st;\n   settings_t        *settings   = config_get_ptr();\n\n   if (settings->bools.core_info_savestate_bypass)\n      return true;\n\n   /* If no core is currently loaded, assume\n    * by default that all savestate functionality\n    * is supported */\n   if (!p_coreinfo->current)\n      return true;\n\n   return p_coreinfo->current->savestate_support_level >=\n         CORE_INFO_SAVESTATE_BASIC;\n}\n\nbool core_info_current_supports_rewind(void)\n{\n   core_info_state_t *p_coreinfo = &core_info_st;\n   settings_t        *settings   = config_get_ptr();\n\n   if (settings->bools.core_info_savestate_bypass)\n      return true;\n\n   /* If no core is currently loaded, assume\n    * by default that all savestate functionality\n    * is supported */\n   if (!p_coreinfo->current)\n      return true;\n\n   return p_coreinfo->current->savestate_support_level >=\n         CORE_INFO_SAVESTATE_SERIALIZED;\n}\n\nbool core_info_current_supports_netplay(void)\n{\n   core_info_state_t *p_coreinfo = &core_info_st;\n   settings_t        *settings   = config_get_ptr();\n\n   if (settings->bools.core_info_savestate_bypass)\n      return true;\n\n   /* If no core is currently loaded, assume\n    * by default that all savestate functionality\n    * is supported */\n   if (!p_coreinfo->current)\n      return true;\n\n   return p_coreinfo->current->savestate_support_level >=\n         CORE_INFO_SAVESTATE_DETERMINISTIC;\n}\n\nbool core_info_current_supports_runahead(void)\n{\n   core_info_state_t *p_coreinfo = &core_info_st;\n   settings_t        *settings   = config_get_ptr();\n\n   if (settings->bools.core_info_savestate_bypass)\n      return true;\n\n   /* If no core is currently loaded, assume\n    * by default that all savestate functionality\n    * is supported */\n   if (!p_coreinfo->current)\n      return true;\n\n   return p_coreinfo->current->savestate_support_level >=\n         CORE_INFO_SAVESTATE_DETERMINISTIC;\n}\n\nstatic bool core_info_update_core_aux_file(const char *path, bool create)\n{\n   bool aux_file_exists = false;\n\n   if (string_is_empty(path))\n      return false;\n\n   /* Check whether aux file exists */\n   aux_file_exists = path_is_valid(path);\n\n   /* Create or delete aux file, as required */\n   if (create && !aux_file_exists)\n   {\n      RFILE *aux_file = filestream_open(path,\n            RETRO_VFS_FILE_ACCESS_WRITE,\n            RETRO_VFS_FILE_ACCESS_HINT_NONE);\n\n      if (!aux_file)\n         return false;\n\n      /* We have to write something - just output\n       * a single character */\n      if (filestream_putc(aux_file, 0) != 0)\n      {\n         filestream_close(aux_file);\n         return false;\n      }\n\n      filestream_close(aux_file);\n   }\n   else if (!create && aux_file_exists)\n      if (filestream_delete(path) != 0)\n         return false;\n\n   return true;\n}\n\n/* Sets 'locked' status of specified core\n * > Returns true if successful\n * > Like all functions that access the cached\n *   core info list this is *not* thread safe */\nbool core_info_set_core_lock(const char *core_path, bool lock)\n{\n   size_t _len;\n   core_info_t *core_info = NULL;\n   char lock_file_path[PATH_MAX_LENGTH];\n\n#if defined(ANDROID)\n   /* Play Store builds do not support\n    * core locking */\n   if (play_feature_delivery_enabled())\n      return false;\n#endif\n\n   /* Search for specified core */\n   if (\n           string_is_empty(core_path)\n       || !core_info_find(core_path, &core_info)\n       || string_is_empty(core_info->path))\n      return false;\n\n   /* Get lock file path */\n   _len  = strlcpy(lock_file_path, core_info->path,\n          sizeof(lock_file_path));\n   strlcpy(lock_file_path       + _len,\n         \".lck\",\n         sizeof(lock_file_path) - _len);\n\n   /* Create or delete lock file, as required */\n   if (!core_info_update_core_aux_file(lock_file_path, lock))\n      return false;\n\n   /* File operations were successful - update\n    * core info entry */\n   core_info->is_locked = lock;\n\n   return true;\n}\n\n/* Fetches 'locked' status of specified core\n * > If 'validate_path' is 'true', will search\n *   cached core info list for a corresponding\n *   'sanitised' core file path. This is *not*\n *   thread safe\n * > If 'validate_path' is 'false', performs a\n *   direct filesystem check. This *is* thread\n *   safe, but validity of specified core path\n *   must be checked externally */\nbool core_info_get_core_lock(const char *core_path, bool validate_path)\n{\n   size_t _len;\n   core_info_t *core_info     = NULL;\n   const char *core_file_path = NULL;\n   bool is_locked             = false;\n   char lock_file_path[PATH_MAX_LENGTH];\n\n#if defined(ANDROID)\n   /* Play Store builds do not support\n    * core locking */\n   if (play_feature_delivery_enabled())\n      return false;\n#endif\n\n   if (string_is_empty(core_path))\n      return false;\n\n   /* Check whether core path is to be validated */\n   if (validate_path)\n   {\n      if (core_info_find(core_path, &core_info))\n         core_file_path = core_info->path;\n   }\n   else\n      core_file_path    = core_path;\n\n   /* A core cannot be locked if it does not exist... */\n   if (    string_is_empty(core_file_path)\n       || !path_is_valid(core_file_path))\n      return false;\n\n   /* Get lock file path */\n   _len = strlcpy(lock_file_path, core_file_path,\n         sizeof(lock_file_path));\n   strlcpy(lock_file_path       + _len,\n         \".lck\",\n         sizeof(lock_file_path) - _len);\n\n   /* Check whether lock file exists */\n   is_locked = path_is_valid(lock_file_path);\n\n   /* If core path has been validated (and a\n    * core info object is available), ensure\n    * that core info 'is_locked' field is\n    * up to date */\n   if (validate_path && core_info)\n      core_info->is_locked = is_locked;\n\n   return is_locked;\n}\n\n/* Sets 'standalone exempt' status of specified core\n * > A 'standalone exempt' core will not be shown\n *   in the contentless cores menu when display type\n *   is set to 'custom'\n * > Returns true if successful\n * > Returns false if core does not support\n *   contentless operation\n * > *Not* thread safe */\nbool core_info_set_core_standalone_exempt(const char *core_path, bool exempt)\n{\n   /* Static platforms do not support the contentless\n    * cores menu */\n#if defined(HAVE_DYNAMIC)\n   size_t _len;\n   core_info_t *core_info = NULL;\n   char exempt_file_path[PATH_MAX_LENGTH];\n\n   /* Search for specified core */\n   if (    string_is_empty(core_path)\n       || !core_info_find(core_path, &core_info)\n       || string_is_empty(core_info->path)\n       || !core_info->supports_no_game)\n      return false;\n\n   /* Get 'standalone exempt' file path */\n   _len = strlcpy(exempt_file_path, core_info->path,\n         sizeof(exempt_file_path));\n   strlcpy(exempt_file_path       + _len,\n         \".lsae\",\n         sizeof(exempt_file_path) - _len);\n\n   /* Create or delete 'standalone exempt' file, as required */\n   if (core_info_update_core_aux_file(exempt_file_path, exempt))\n   {\n      /* File operations were successful - update\n       * core info entry */\n      core_info->is_standalone_exempt = exempt;\n      return true;\n   }\n#endif\n   return false;\n}\n\n/* Fetches 'standalone exempt' status of specified core\n * > Returns true if core should be excluded from\n *   the contentless cores menu when display type is\n *   set to 'custom'\n * > *Not* thread safe */\nbool core_info_get_core_standalone_exempt(const char *core_path)\n{\n   /* Static platforms do not support the contentless\n    * cores menu */\n#if defined(HAVE_DYNAMIC)\n   size_t _len;\n   core_info_t *core_info = NULL;\n   char exempt_file_path[PATH_MAX_LENGTH];\n\n   /* Search for specified core */\n   if (    string_is_empty(core_path)\n       || !core_info_find(core_path, &core_info)\n       ||  string_is_empty(core_info->path)\n       || !core_info->supports_no_game)\n      return false;\n\n   /* Get 'standalone exempt' file path */\n   _len = strlcpy(exempt_file_path, core_info->path,\n         sizeof(exempt_file_path));\n   strlcpy(exempt_file_path       + _len,\n         \".lsae\",\n         sizeof(exempt_file_path) - _len);\n\n   /* Check whether 'standalone exempt' file exists */\n   if (path_is_valid(exempt_file_path))\n   {\n      core_info->is_standalone_exempt = true;\n      return true;\n   }\n\n   core_info->is_standalone_exempt    = false;\n#endif\n   return false;\n}\n"
        },
        {
          "name": "core_info.h",
          "type": "blob",
          "size": 7.7451171875,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CORE_INFO_H_\n#define CORE_INFO_H_\n\n#include <stddef.h>\n\n#include <lists/string_list.h>\n#include <retro_common_api.h>\n\nRETRO_BEGIN_DECLS\n\n/* Defines the levels of savestate support\n * that may be offered by a core:\n *   - serialized:    rewind\n *   - deterministic: netplay/runahead\n * Thus:\n *   (level < CORE_INFO_SAVESTATE_BASIC)\n *      -> no savestate support\n *   (level < CORE_INFO_SAVESTATE_SERIALIZED)\n *      -> no rewind/netplay/runahead\n *   (level < CORE_INFO_SAVESTATE_DETERMINISTIC)\n *      -> no netplay/runahead\n */\n#define CORE_INFO_SAVESTATE_DISABLED      0\n#define CORE_INFO_SAVESTATE_BASIC         1\n#define CORE_INFO_SAVESTATE_SERIALIZED    2\n#define CORE_INFO_SAVESTATE_DETERMINISTIC 3\n\nenum core_info_list_qsort_type\n{\n   CORE_INFO_LIST_SORT_PATH = 0,\n   CORE_INFO_LIST_SORT_DISPLAY_NAME,\n   CORE_INFO_LIST_SORT_CORE_NAME,\n   CORE_INFO_LIST_SORT_SYSTEM_NAME\n};\n\ntypedef struct\n{\n   char *path;\n   char *desc;\n   /* Set missing once to avoid opening\n    * the same file several times. */\n   bool missing;\n   bool optional;\n} core_info_firmware_t;\n\n/* Simple container/convenience struct for\n * holding the 'id' of a core file\n * > 'str' is the filename without extension or\n *   platform-specific suffix\n * > 'hash' is a hash key used for efficient core\n *   list searches */\ntypedef struct\n{\n   char *str;\n   uint32_t hash;\n} core_file_id_t;\n\ntypedef struct\n{\n   char *path;\n   char *display_name;\n   char *display_version;\n   char *core_name;\n   char *system_manufacturer;\n   char *systemname;\n   char *system_id;\n   char *supported_extensions;\n   char *authors;\n   char *permissions;\n   char *licenses;\n   char *categories;\n   char *databases;\n   char *notes;\n   char *required_hw_api;\n   char *description;\n   struct string_list *categories_list;\n   struct string_list *databases_list;\n   struct string_list *note_list;\n   struct string_list *supported_extensions_list;\n   struct string_list *authors_list;\n   struct string_list *permissions_list;\n   struct string_list *licenses_list;\n   struct string_list *required_hw_api_list;\n   core_info_firmware_t *firmware;\n   core_file_id_t core_file_id; /* ptr alignment */\n   size_t firmware_count;\n   uint32_t savestate_support_level;\n   bool has_info;\n   bool supports_no_game;\n   bool single_purpose;\n   bool database_match_archive_member;\n   bool is_experimental;\n   bool is_locked;\n   bool is_standalone_exempt;\n   bool is_installed;\n} core_info_t;\n\n/* A subset of core_info parameters required for\n * core updater tasks */\ntypedef struct\n{\n   char *display_name;\n   char *description;\n   char *licenses;\n   bool is_experimental;\n} core_updater_info_t;\n\ntypedef struct\n{\n   core_info_t *list;\n   char *all_ext;\n   size_t count;\n   size_t info_count;\n} core_info_list_t;\n\ntypedef struct core_info_ctx_firmware\n{\n   const char *path;\n   struct\n   {\n      const char *system;\n   } directory;\n} core_info_ctx_firmware_t;\n\nstruct core_info_state\n{\n#ifdef HAVE_COMPRESSION\n   const struct string_list *tmp_list;\n#endif\n   const char *tmp_path;\n   core_info_t *current;\n   core_info_list_t *curr_list;\n};\n\ntypedef struct core_info_state core_info_state_t;\n\n/* Non-reentrant, does not allocate. Returns pointer to internal state. */\nvoid core_info_list_get_supported_cores(core_info_list_t *list,\n      const char *path, const core_info_t **infos, size_t *num_infos);\n\nsize_t core_info_list_get_display_name(core_info_list_t *list,\n      const char *core_path, char *s, size_t len);\n\n/* Returns core_info parameters required for\n * core updater tasks, read from specified file.\n * Returned core_updater_info_t object must be\n * freed using core_info_free_core_updater_info().\n * Returns NULL if 'path' is invalid. */\ncore_updater_info_t *core_info_get_core_updater_info(const char *info_path);\nvoid core_info_free_core_updater_info(core_updater_info_t *info);\n\ncore_info_t *core_info_get(core_info_list_t *list, size_t i);\n\nvoid core_info_free_current_core(void);\n\nbool core_info_init_current_core(void);\n\nbool core_info_get_current_core(core_info_t **core);\n\nvoid core_info_deinit_list(void);\n\nbool core_info_init_list(const char *path_info, const char *dir_cores,\n      const char *exts, bool show_hidden_files,\n      bool enable_cache, bool *cache_supported);\n\nbool core_info_get_list(core_info_list_t **core);\n\n/* Returns number of installed cores */\nsize_t core_info_count(void);\n\nbool core_info_list_update_missing_firmware(core_info_ctx_firmware_t *info,\n      bool *set_missing_bios);\n\nbool core_info_find(const char *core_path,\n      core_info_t **core_info);\n\nbool core_info_load(const char *core_path);\n\nbool core_info_database_supports_content_path(const char *database_path, const char *path);\n\nbool core_info_database_match_archive_member(const char *database_path);\n\nvoid core_info_qsort(core_info_list_t *core_info_list, enum core_info_list_qsort_type qsort_type);\n\nbool core_info_list_get_info(core_info_list_t *core_info_list,\n      core_info_t *out_info, const char *core_path);\n\n/* Convenience wrapper functions used to interpret\n * the 'savestate_support_level' parameter of\n * the currently loaded core. If no core is\n * loaded, will return 'true' (since full\n * savestate functionality is assumed by default) */\nbool core_info_current_supports_savestate(void);\nbool core_info_current_supports_rewind(void);\nbool core_info_current_supports_netplay(void);\nbool core_info_current_supports_runahead(void);\n\n/* Sets 'locked' status of specified core\n * > Returns true if successful\n * > Like all functions that access the cached\n *   core info list this is *not* thread safe */\nbool core_info_set_core_lock(const char *core_path, bool lock);\n/* Fetches 'locked' status of specified core\n * > If 'validate_path' is 'true', will search\n *   cached core info list for a corresponding\n *   'sanitised' core file path. This is *not*\n *   thread safe\n * > If 'validate_path' is 'false', performs a\n *   direct filesystem check. This *is* thread\n *   safe, but validity of specified core path\n *   must be checked externally */\nbool core_info_get_core_lock(const char *core_path, bool validate_path);\n\n/* Sets 'standalone exempt' status of specified core\n * > A 'standalone exempt' core will not be shown\n *   in the contentless cores menu when display type\n *   is set to 'custom'\n * > Returns true if successful\n * > Returns false if core does not support\n *   contentless operation\n * > *Not* thread safe */\nbool core_info_set_core_standalone_exempt(const char *core_path, bool exempt);\n/* Fetches 'standalone exempt' status of specified core\n * > Returns true if core should be excluded from\n *   the contentless cores menu when display type is\n *   set to 'custom'\n * > *Not* thread safe */\nbool core_info_get_core_standalone_exempt(const char *core_path);\n\nbool core_info_core_file_id_is_equal(const char *core_path_a, const char *core_path_b);\n\n/* When called, generates a temporary file\n * that will force an info cache refresh the\n * next time that core info is initialised with\n * caching enabled */\nbool core_info_cache_force_refresh(const char *path_info);\n\nRETRO_END_DECLS\n\n#endif /* CORE_INFO_H_ */\n"
        },
        {
          "name": "core_option_manager.c",
          "type": "blob",
          "size": 54.798828125,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <string/stdstring.h>\n\n#ifdef HAVE_CHEEVOS\n#include \"cheevos/cheevos.h\"\n#endif\n\n#ifdef HAVE_MENU\n#include \"menu/menu_driver.h\"\n#endif\n\n#include \"core_option_manager.h\"\n#include \"msg_hash.h\"\n\n/*********************/\n/* Option Conversion */\n/*********************/\n\n/**\n * core_option_manager_convert_v1:\n *\n * @options_v1 : an array of retro_core_option_definition\n *               structs\n *\n * Converts an array of core option v1 definitions into\n * a v2 core options struct. Returned pointer must be\n * freed using core_option_manager_free_converted().\n *\n * Returns: Valid pointer to a new v2 core options struct\n * if successful, otherwise NULL.\n **/\nstruct retro_core_options_v2 *core_option_manager_convert_v1(\n      const struct retro_core_option_definition *options_v1)\n{\n   size_t i;\n   size_t num_options                                     = 0;\n   struct retro_core_options_v2 *options_v2               = NULL;\n   struct retro_core_option_v2_definition *option_v2_defs = NULL;\n\n   if (!options_v1)\n      return NULL;\n\n   /* Determine number of options */\n   for (;;)\n   {\n      if (string_is_empty(options_v1[num_options].key))\n         break;\n      num_options++;\n   }\n\n   if (num_options < 1)\n      return NULL;\n\n   /* Allocate output retro_core_options_v2 struct */\n   if (!(options_v2 = (struct retro_core_options_v2 *)\n         malloc(sizeof(*options_v2))))\n      return NULL;\n\n   /* Note: v1 options have no concept of\n    * categories, so this field will be left\n    * as NULL */\n   options_v2->categories  = NULL;\n   options_v2->definitions = NULL;\n\n   /* Allocate output option_v2_defs array\n    * > One extra entry required for terminating NULL entry\n    * > Note that calloc() sets terminating NULL entry and\n    *   correctly 'nullifies' each values array */\n   if (!(option_v2_defs = (struct retro_core_option_v2_definition *)\n         calloc(num_options + 1, sizeof(*option_v2_defs))))\n   {\n      free(options_v2);\n      return NULL;\n   }\n\n   options_v2->definitions = option_v2_defs;\n\n   /* Loop through options... */\n   for (i = 0; i < num_options; i++)\n   {\n      size_t j;\n      size_t num_values = 0;\n\n      /* Set key */\n      option_v2_defs[i].key           = options_v1[i].key;\n\n      /* Set default value */\n      option_v2_defs[i].default_value = options_v1[i].default_value;\n\n      /* Set desc and info strings */\n      option_v2_defs[i].desc = options_v1[i].desc;\n      option_v2_defs[i].info = options_v1[i].info;\n\n      /* v1 options have no concept of categories\n       * (Note: These are already nullified by\n       * the preceding calloc(), but we do it\n       * explicitly here for code clarity) */\n      option_v2_defs[i].desc_categorized = NULL;\n      option_v2_defs[i].info_categorized = NULL;\n      option_v2_defs[i].category_key     = NULL;\n\n      /* Determine number of values */\n      for (;;)\n      {\n         if (string_is_empty(options_v1[i].values[num_values].value))\n            break;\n         num_values++;\n      }\n\n      /* Copy values */\n      for (j = 0; j < num_values; j++)\n      {\n         /* Set value string */\n         option_v2_defs[i].values[j].value = options_v1[i].values[j].value;\n\n         /* Set value label string */\n         option_v2_defs[i].values[j].label = options_v1[i].values[j].label;\n      }\n   }\n\n   return options_v2;\n}\n\n/**\n * core_option_manager_convert_v1_intl:\n *\n * @options_v1_intl : pointer to a retro_core_options_intl\n *                    struct\n *\n * Converts a v1 'international' core options definition\n * struct into a v2 core options struct. Returned pointer\n * must be freed using core_option_manager_free_converted().\n *\n * Returns: Valid pointer to a new v2 core options struct\n * if successful, otherwise NULL.\n **/\nstruct retro_core_options_v2 *core_option_manager_convert_v1_intl(\n      const struct retro_core_options_intl *options_v1_intl)\n{\n   size_t i;\n   size_t num_options                                     = 0;\n   struct retro_core_option_definition *option_defs_us    = NULL;\n   struct retro_core_option_definition *option_defs_local = NULL;\n   struct retro_core_options_v2 *options_v2               = NULL;\n   struct retro_core_option_v2_definition *option_v2_defs = NULL;\n\n   if (!options_v1_intl)\n      return NULL;\n\n   option_defs_us    = options_v1_intl->us;\n   option_defs_local = options_v1_intl->local;\n\n   if (!option_defs_us)\n      return NULL;\n\n   /* Determine number of options */\n   for (;;)\n   {\n      if (string_is_empty(option_defs_us[num_options].key))\n         break;\n      num_options++;\n   }\n\n   if (num_options < 1)\n      return NULL;\n\n   /* Allocate output retro_core_options_v2 struct */\n   if (!(options_v2 = (struct retro_core_options_v2 *)\n         malloc(sizeof(*options_v2))))\n      return NULL;\n\n   /* Note: v1 options have no concept of\n    * categories, so this field will be left\n    * as NULL */\n   options_v2->categories  = NULL;\n   options_v2->definitions = NULL;\n\n   /* Allocate output option_v2_defs array\n    * > One extra entry required for terminating NULL entry\n    * > Note that calloc() sets terminating NULL entry and\n    *   correctly 'nullifies' each values array */\n   if (!(option_v2_defs = (struct retro_core_option_v2_definition *)\n         calloc(num_options + 1, sizeof(*option_v2_defs))))\n   {\n      core_option_manager_free_converted(options_v2);\n      return NULL;\n   }\n\n   options_v2->definitions = option_v2_defs;\n\n   /* Loop through options... */\n   for (i = 0; i < num_options; i++)\n   {\n      size_t j;\n      size_t num_values                            = 0;\n      const char *key                              = option_defs_us[i].key;\n      const char *local_desc                       = NULL;\n      const char *local_info                       = NULL;\n      struct retro_core_option_value *local_values = NULL;\n\n      /* Key is always taken from us english defs */\n      option_v2_defs[i].key = key;\n\n      /* Default value is always taken from us english defs */\n      option_v2_defs[i].default_value = option_defs_us[i].default_value;\n\n      /* Try to find corresponding entry in local defs array */\n      if (option_defs_local)\n      {\n         size_t index = 0;\n\n         for (;;)\n         {\n            const char *local_key = option_defs_local[index].key;\n\n            if (string_is_empty(local_key))\n               break;\n\n            if (string_is_equal(key, local_key))\n            {\n               local_desc   = option_defs_local[index].desc;\n               local_info   = option_defs_local[index].info;\n               local_values = option_defs_local[index].values;\n               break;\n            }\n\n            index++;\n         }\n      }\n\n      /* Set desc and info strings */\n      option_v2_defs[i].desc = string_is_empty(local_desc) ?\n            option_defs_us[i].desc : local_desc;\n      option_v2_defs[i].info = string_is_empty(local_info) ?\n            option_defs_us[i].info : local_info;\n\n      /* v1 options have no concept of categories\n       * (Note: These are already nullified by\n       * the preceding calloc(), but we do it\n       * explicitly here for code clarity) */\n      option_v2_defs[i].desc_categorized = NULL;\n      option_v2_defs[i].info_categorized = NULL;\n      option_v2_defs[i].category_key     = NULL;\n\n      /* Determine number of values\n       * (always taken from us english defs) */\n      for (;;)\n      {\n         if (string_is_empty(option_defs_us[i].values[num_values].value))\n            break;\n         num_values++;\n      }\n\n      /* Copy values */\n      for (j = 0; j < num_values; j++)\n      {\n         const char *value       = option_defs_us[i].values[j].value;\n         const char *local_label = NULL;\n\n         /* Value string is always taken from us english defs */\n         option_v2_defs[i].values[j].value = value;\n\n         /* Try to find corresponding entry in local defs values array */\n         if (local_values)\n         {\n            size_t value_index = 0;\n\n            for (;;)\n            {\n               const char *local_value = local_values[value_index].value;\n\n               if (string_is_empty(local_value))\n                  break;\n\n               if (string_is_equal(value, local_value))\n               {\n                  local_label = local_values[value_index].label;\n                  break;\n               }\n\n               value_index++;\n            }\n         }\n\n         /* Set value label string */\n         option_v2_defs[i].values[j].label = string_is_empty(local_label) ?\n               option_defs_us[i].values[j].label : local_label;\n      }\n   }\n\n   return options_v2;\n}\n\n/**\n * core_option_manager_convert_v2_intl:\n *\n * @options_v2_intl : pointer to a retro_core_options_v2_intl\n *                    struct\n *\n * Converts a v2 'international' core options struct\n * into a regular v2 core options struct. Returned pointer\n * must be freed using core_option_manager_free_converted().\n *\n * Returns: Valid pointer to a new v2 core options struct\n * if successful, otherwise NULL.\n **/\nstruct retro_core_options_v2 *core_option_manager_convert_v2_intl(\n      const struct retro_core_options_v2_intl *options_v2_intl)\n{\n   size_t i;\n   size_t num_categories                                  = 0;\n   size_t num_options                                     = 0;\n   struct retro_core_options_v2 *options_v2_us            = NULL;\n   struct retro_core_options_v2 *options_v2_local         = NULL;\n   struct retro_core_options_v2 *options_v2               = NULL;\n   struct retro_core_option_v2_category *option_v2_cats   = NULL;\n   struct retro_core_option_v2_definition *option_v2_defs = NULL;\n\n   if (!options_v2_intl)\n      return NULL;\n\n   options_v2_us    = options_v2_intl->us;\n   options_v2_local = options_v2_intl->local;\n\n   if (!options_v2_us ||\n       !options_v2_us->definitions)\n      return NULL;\n\n   /* Determine number of categories\n    * (Note: zero categories are permitted) */\n   if (options_v2_us->categories)\n   {\n      for (;;)\n      {\n         if (string_is_empty(options_v2_us->categories[num_categories].key))\n            break;\n         num_categories++;\n      }\n   }\n\n   /* Determine number of options */\n   for (;;)\n   {\n      if (string_is_empty(options_v2_us->definitions[num_options].key))\n         break;\n      num_options++;\n   }\n\n   if (num_options < 1)\n      return NULL;\n\n   /* Allocate output retro_core_options_v2 struct */\n   if (!(options_v2 = (struct retro_core_options_v2 *)\n         malloc(sizeof(*options_v2))))\n      return NULL;\n\n   options_v2->categories  = NULL;\n   options_v2->definitions = NULL;\n\n   /* Allocate output option_v2_cats array\n    * > One extra entry required for terminating NULL entry\n    * > Note that calloc() sets terminating NULL entry */\n   if (num_categories > 0)\n   {\n      if (!(option_v2_cats = (struct retro_core_option_v2_category *)\n            calloc(num_categories + 1, sizeof(*option_v2_cats))))\n      {\n         core_option_manager_free_converted(options_v2);\n         return NULL;\n      }\n   }\n\n   options_v2->categories = option_v2_cats;\n\n   /* Allocate output option_v2_defs array\n    * > One extra entry required for terminating NULL entry\n    * > Note that calloc() sets terminating NULL entry and\n    *   correctly 'nullifies' each values array */\n   if (!(option_v2_defs = (struct retro_core_option_v2_definition *)\n         calloc(num_options + 1, sizeof(*option_v2_defs))))\n   {\n      core_option_manager_free_converted(options_v2);\n      return NULL;\n   }\n\n   options_v2->definitions = option_v2_defs;\n\n   /* Loop through categories...\n    * (Note: This loop will not execute if\n    * options_v2_us->categories is NULL) */\n   for (i = 0; i < num_categories; i++)\n   {\n      const char *key        = options_v2_us->categories[i].key;\n      const char *local_desc = NULL;\n      const char *local_info = NULL;\n\n      /* Key is always taken from us english\n       * categories */\n      option_v2_cats[i].key = key;\n\n      /* Try to find corresponding entry in local\n       * categories array */\n      if (options_v2_local &&\n          options_v2_local->categories)\n      {\n         size_t index = 0;\n\n         for (;;)\n         {\n            const char *local_key = options_v2_local->categories[index].key;\n\n            if (string_is_empty(local_key))\n               break;\n\n            if (string_is_equal(key, local_key))\n            {\n               local_desc = options_v2_local->categories[index].desc;\n               local_info = options_v2_local->categories[index].info;\n               break;\n            }\n\n            index++;\n         }\n      }\n\n      /* Set desc and info strings */\n      option_v2_cats[i].desc = string_is_empty(local_desc) ?\n            options_v2_us->categories[i].desc : local_desc;\n      option_v2_cats[i].info = string_is_empty(local_info) ?\n            options_v2_us->categories[i].info : local_info;\n\n   }\n\n   /* Loop through options... */\n   for (i = 0; i < num_options; i++)\n   {\n      size_t j;\n      size_t num_values                            = 0;\n      const char *key                              = options_v2_us->definitions[i].key;\n      const char *local_desc                       = NULL;\n      const char *local_desc_categorized           = NULL;\n      const char *local_info                       = NULL;\n      const char *local_info_categorized           = NULL;\n      struct retro_core_option_value *local_values = NULL;\n\n      /* Key is always taken from us english defs */\n      option_v2_defs[i].key = key;\n\n      /* Default value is always taken from us english defs */\n      option_v2_defs[i].default_value = options_v2_us->definitions[i].default_value;\n\n      /* Try to find corresponding entry in local defs array */\n      if (options_v2_local &&\n          options_v2_local->definitions)\n      {\n         size_t index = 0;\n\n         for (;;)\n         {\n            const char *local_key = options_v2_local->definitions[index].key;\n\n            if (string_is_empty(local_key))\n               break;\n\n            if (string_is_equal(key, local_key))\n            {\n               local_desc             = options_v2_local->definitions[index].desc;\n               local_desc_categorized = options_v2_local->definitions[index].desc_categorized;\n               local_info             = options_v2_local->definitions[index].info;\n               local_info_categorized = options_v2_local->definitions[index].info_categorized;\n               local_values           = options_v2_local->definitions[index].values;\n               break;\n            }\n\n            index++;\n         }\n      }\n\n      /* Set desc and info strings */\n      option_v2_defs[i].desc             = string_is_empty(local_desc) ?\n            options_v2_us->definitions[i].desc : local_desc;\n      option_v2_defs[i].desc_categorized = string_is_empty(local_desc_categorized) ?\n            options_v2_us->definitions[i].desc_categorized : local_desc_categorized;\n      option_v2_defs[i].info             = string_is_empty(local_info) ?\n            options_v2_us->definitions[i].info : local_info;\n      option_v2_defs[i].info_categorized = string_is_empty(local_info_categorized) ?\n            options_v2_us->definitions[i].info_categorized : local_info_categorized;\n\n      /* Category key is always taken from us english defs */\n      option_v2_defs[i].category_key = options_v2_us->definitions[i].category_key;\n\n      /* Determine number of values\n       * (always taken from us english defs) */\n      for (;;)\n      {\n         if (string_is_empty(\n               options_v2_us->definitions[i].values[num_values].value))\n            break;\n         num_values++;\n      }\n\n      /* Copy values */\n      for (j = 0; j < num_values; j++)\n      {\n         const char *value       = options_v2_us->definitions[i].values[j].value;\n         const char *local_label = NULL;\n\n         /* Value string is always taken from us english defs */\n         option_v2_defs[i].values[j].value = value;\n\n         /* Try to find corresponding entry in local defs values array */\n         if (local_values)\n         {\n            size_t value_index = 0;\n\n            for (;;)\n            {\n               const char *local_value = local_values[value_index].value;\n\n               if (string_is_empty(local_value))\n                  break;\n\n               if (string_is_equal(value, local_value))\n               {\n                  local_label = local_values[value_index].label;\n                  break;\n               }\n\n               value_index++;\n            }\n         }\n\n         /* Set value label string */\n         option_v2_defs[i].values[j].label = string_is_empty(local_label) ?\n               options_v2_us->definitions[i].values[j].label : local_label;\n      }\n   }\n\n   return options_v2;\n}\n\n/**\n * core_option_manager_convert_v2_intl:\n *\n * @options_v2 : pointer to a retro_core_options_v2\n *               struct\n *\n * Frees the pointer returned by any\n * core_option_manager_convert_*() function.\n **/\nvoid core_option_manager_free_converted(\n      struct retro_core_options_v2 *options_v2)\n{\n   if (!options_v2)\n      return;\n\n   if (options_v2->categories)\n   {\n      free(options_v2->categories);\n      options_v2->categories = NULL;\n   }\n\n   if (options_v2->definitions)\n   {\n      free(options_v2->definitions);\n      options_v2->definitions = NULL;\n   }\n\n   free(options_v2);\n}\n\n/**************************************/\n/* Initialisation / De-Initialisation */\n/**************************************/\n\n/* Generates a hash key for the specified string */\nstatic uint32_t core_option_manager_hash_string(const char *str)\n{\n   unsigned char c;\n   uint32_t hash = (uint32_t)0x811c9dc5;\n   while ((c = (unsigned char)*(str++)) != '\\0')\n      hash = ((hash * (uint32_t)0x01000193) ^ (uint32_t)c);\n   return (hash ? hash : 1);\n}\n\n/* Sanitises a core option value label, handling the case\n * where an explicit label is not provided and performing\n * conversion of various true/false identifiers to\n * ON/OFF strings */\nstatic const char *core_option_manager_parse_value_label(\n      const char *value, const char *value_label)\n{\n   /* 'value_label' may be NULL */\n   const char *label = string_is_empty(value_label) ?\n         value : value_label;\n\n   if (string_is_empty(label))\n      return NULL;\n\n   /* Any label starting with a digit (or +/-)\n    * cannot be a boolean string, and requires\n    * no further processing */\n   if (ISDIGIT((unsigned char)*label) ||\n       (*label == '+') ||\n       (*label == '-'))\n      return label;\n\n   /* Core devs have a habit of using arbitrary\n    * strings to label boolean values (i.e. enabled,\n    * Enabled, on, On, ON, true, True, TRUE, disabled,\n    * Disabled, off, Off, OFF, false, False, FALSE).\n    * These should all be converted to standard ON/OFF\n    * strings\n    * > Note: We require some duplication here\n    *   (e.g. MENU_ENUM_LABEL_ENABLED *and*\n    *    MENU_ENUM_LABEL_VALUE_ENABLED) in order\n    *   to match both localised and non-localised\n    *   strings. This function is not performance\n    *   critical, so these extra comparisons do\n    *   no harm */\n   if (string_is_equal_noncase(label, msg_hash_to_str(MENU_ENUM_LABEL_ENABLED)) ||\n       string_is_equal_noncase(label, msg_hash_to_str(MENU_ENUM_LABEL_VALUE_ENABLED)) ||\n       string_is_equal_noncase(label, \"enable\") ||\n       string_is_equal_noncase(label, \"on\") ||\n       string_is_equal_noncase(label, msg_hash_to_str(MENU_ENUM_LABEL_VALUE_ON)) ||\n       string_is_equal_noncase(label, \"true\") ||\n       string_is_equal_noncase(label, msg_hash_to_str(MENU_ENUM_LABEL_VALUE_TRUE)))\n      label = msg_hash_to_str(MENU_ENUM_LABEL_VALUE_ON);\n   else if (string_is_equal_noncase(label, msg_hash_to_str(MENU_ENUM_LABEL_DISABLED)) ||\n            string_is_equal_noncase(label, msg_hash_to_str(MENU_ENUM_LABEL_VALUE_DISABLED)) ||\n            string_is_equal_noncase(label, \"disable\") ||\n            string_is_equal_noncase(label, \"off\") ||\n            string_is_equal_noncase(label, msg_hash_to_str(MENU_ENUM_LABEL_VALUE_OFF)) ||\n            string_is_equal_noncase(label, \"false\") ||\n            string_is_equal_noncase(label, msg_hash_to_str(MENU_ENUM_LABEL_VALUE_FALSE)))\n      label = msg_hash_to_str(MENU_ENUM_LABEL_VALUE_OFF);\n\n   return label;\n}\n\n/* Parses a single legacy core options interface\n * variable, extracting all present core_option\n * information */\nstatic bool core_option_manager_parse_variable(\n      core_option_manager_t *opt, size_t idx,\n      const struct retro_variable *var,\n      config_file_t *config_src)\n{\n   size_t i;\n   union string_list_elem_attr attr;\n   const char *val_start      = NULL;\n   char *value                = NULL;\n   char *desc_end             = NULL;\n   struct core_option *option = (struct core_option*)&opt->opts[idx];\n   struct config_entry_list\n         *entry               = NULL;\n\n   /* Record option index (required to facilitate\n    * option map handling) */\n   option->opt_idx            = idx;\n\n   /* All options are visible by default */\n   option->visible            = true;\n\n   if (!string_is_empty(var->key))\n   {\n      option->key             = strdup(var->key);\n      option->key_hash        = core_option_manager_hash_string(var->key);\n   }\n\n   if (!string_is_empty(var->value))\n      value                   = strdup(var->value);\n\n   if (!string_is_empty(value))\n      desc_end                = strstr(value, \"; \");\n\n   if (!desc_end)\n      goto error;\n\n   *desc_end    = '\\0';\n\n   if (!string_is_empty(value))\n      option->desc    = strdup(value);\n\n   val_start          = desc_end + 2;\n   option->vals       = string_split(val_start, \"|\");\n\n   if (!option->vals)\n      goto error;\n\n   /* Legacy core option interface has no concept\n    * of value labels\n    * > Use actual values for display purposes */\n   attr.i             = 0;\n   option->val_labels = string_list_new();\n\n   if (!option->val_labels)\n      goto error;\n\n   /* > Loop over values and:\n    *   - Set value hashes\n    *   - 'Extract' labels */\n   for (i = 0; i < option->vals->size; i++)\n   {\n      const char *value       = option->vals->elems[i].data;\n      uint32_t *value_hash    = (uint32_t *)malloc(sizeof(uint32_t));\n      const char *value_label = core_option_manager_parse_value_label(\n            value, NULL);\n\n      /* Set value hash */\n      *value_hash                     = core_option_manager_hash_string(value);\n      option->vals->elems[i].userdata = (void*)value_hash;\n\n      /* Redundant safely check... */\n      if (string_is_empty(value_label))\n         value_label = value;\n\n      /* Append value label string */\n      string_list_append(option->val_labels, value_label, attr);\n   }\n\n   /* Legacy core option interface always uses first\n    * defined value as the default */\n   option->default_index = 0;\n   option->index         = 0;\n\n   if (config_src)\n      entry              = config_get_entry(config_src, option->key);\n   else\n      entry              = config_get_entry(opt->conf,  option->key);\n\n   /* Set current config value */\n   if (entry && !string_is_empty(entry->value))\n   {\n      uint32_t entry_value_hash = core_option_manager_hash_string(entry->value);\n\n      for (i = 0; i < option->vals->size; i++)\n      {\n         const char *value   = option->vals->elems[i].data;\n         uint32_t value_hash = *((uint32_t*)option->vals->elems[i].userdata);\n\n         if ((value_hash == entry_value_hash) &&\n             string_is_equal(value, entry->value))\n         {\n            option->index = i;\n            break;\n         }\n      }\n   }\n\n   /* Legacy core option interface has no concept\n    * of categories */\n   option->desc_categorized = NULL;\n   option->info_categorized = NULL;\n   option->category_key     = NULL;\n\n   free(value);\n   return true;\n\nerror:\n   free(value);\n   return false;\n}\n\n/**\n * core_option_manager_new_vars:\n *\n * @conf_path     : Filesystem path to write core option\n *                  config file to\n * @src_conf_path : Filesystem path from which to load\n *                  initial config settings.\n * @vars          : Pointer to core option variable array\n *                  handle\n *\n * Legacy version of core_option_manager_new().\n * Creates and initializes a core manager handle.\n *\n * Returns: handle to new core manager handle if successful,\n * otherwise NULL.\n **/\ncore_option_manager_t *core_option_manager_new_vars(\n      const char *conf_path, const char *src_conf_path,\n      const struct retro_variable *vars)\n{\n   const struct retro_variable *var = NULL;\n   size_t size                      = 0;\n   config_file_t *config_src        = NULL;\n   core_option_manager_t *opt       = NULL;\n\n   if (!vars)\n      return NULL;\n\n   if (!(opt = (core_option_manager_t*)malloc(sizeof(*opt))))\n      return NULL;\n\n   opt->conf                        = NULL;\n   opt->conf_path[0]                = '\\0';\n   /* Legacy core option interface has no concept\n    * of categories, so leave opt->cats as NULL\n    * and opt->cats_size as zero */\n   opt->cats                        = NULL;\n   opt->cats_size                   = 0;\n   opt->opts                        = NULL;\n   opt->size                        = 0;\n   opt->option_map                  = nested_list_init();\n   opt->updated                     = false;\n\n   if (!opt->option_map)\n      goto error;\n\n   /* Open 'output' config file */\n   if (!string_is_empty(conf_path))\n      if (!(opt->conf = config_file_new_from_path_to_string(conf_path)))\n         if (!(opt->conf = config_file_new_alloc()))\n            goto error;\n\n   strlcpy(opt->conf_path, conf_path, sizeof(opt->conf_path));\n\n   /* Load source config file, if required */\n   if (!string_is_empty(src_conf_path))\n      config_src = config_file_new_from_path_to_string(src_conf_path);\n\n   /* Get number of variables */\n   for (var = vars; var->key && var->value; var++)\n      size++;\n\n   if (size == 0)\n      goto error;\n\n   /* Create options array */\n   if (!(opt->opts = (struct core_option*)calloc(size, sizeof(*opt->opts))))\n      goto error;\n\n   opt->size = size;\n   size      = 0;\n\n   /* Parse each variable */\n   for (var = vars; var->key && var->value; size++, var++)\n   {\n      if (core_option_manager_parse_variable(opt, size, var, config_src))\n      {\n         size_t _len = 0;\n         /* If variable is read correctly, add it to\n          * the map */\n         char address[256];\n         address[  _len]  = '#';\n         address[++_len]  = '\\0';\n\n         /* Address string is normally:\n          *    <category_key><delim><tag><option_key>\n          * ...where <tag> is prepended to the option\n          * key in order to avoid category/option key\n          * collisions. Legacy options have no categories,\n          * so we could just set the address to\n          * <option_key> - but for consistency with\n          * 'modern' options, we apply the tag regardless */\n         strlcpy(address + _len, var->key, sizeof(address) - _len);\n\n         if (!nested_list_add_item(opt->option_map,\n               address, NULL, (const void*)&opt->opts[size]))\n            goto error;\n      }\n      else\n         goto error;\n   }\n\n   if (config_src)\n      config_file_free(config_src);\n\n   return opt;\n\nerror:\n   if (config_src)\n      config_file_free(config_src);\n   core_option_manager_free(opt);\n   return NULL;\n}\n\n/* Parses a single v2 core options interface\n * option, extracting all present core_option\n * information */\nstatic bool core_option_manager_parse_option(\n      core_option_manager_t *opt, size_t idx,\n      const struct retro_core_option_v2_definition *option_def,\n      config_file_t *config_src)\n{\n   size_t i;\n   union string_list_elem_attr attr;\n   struct config_entry_list\n      *entry                  = NULL;\n   size_t num_vals            = 0;\n   struct core_option *option = (struct core_option*)&opt->opts[idx];\n   const char *key            = option_def->key;\n   const char *category_key   = option_def->category_key;\n   const struct retro_core_option_value\n         *values              = option_def->values;\n\n   /* Record option index (required to facilitate\n    * option map handling) */\n   option->opt_idx            = idx;\n\n   /* All options are visible by default */\n   option->visible            = true;\n\n   if (!string_is_empty(option_def->desc))\n      option->desc            = strdup(option_def->desc);\n\n   if (!string_is_empty(option_def->info))\n      option->info            = strdup(option_def->info);\n\n   /* Set category-related parameters\n    * > Ignore if specified category key does not\n    *   match an entry in the categories array\n    * > Category key cannot contain a map delimiter\n    *   character */\n   if (opt->cats &&\n       !string_is_empty(category_key) &&\n       !strstr(category_key, \":\"))\n   {\n      for (i = 0; i < opt->cats_size; i++)\n      {\n         const char *search_key = opt->cats[i].key;\n\n         if (string_is_empty(search_key))\n            break;\n\n         if (string_is_equal(search_key, category_key))\n         {\n            option->category_key        = strdup(category_key);\n\n            if (!string_is_empty(option_def->desc_categorized))\n               option->desc_categorized = strdup(option_def->desc_categorized);\n\n            if (!string_is_empty(option_def->info_categorized))\n               option->info_categorized = strdup(option_def->info_categorized);\n\n            break;\n         }\n      }\n   }\n\n   /* Have to set key *after* checking for option\n    * categories */\n   if (!string_is_empty(option_def->key))\n   {\n      /* If option has a category, option key\n       * cannot contain a map delimiter character */\n      if (!string_is_empty(option->category_key) &&\n          strstr(key, \":\"))\n         return false;\n\n      option->key      = strdup(key);\n      option->key_hash = core_option_manager_hash_string(key);\n   }\n\n   /* Get number of values */\n   for (;;)\n   {\n      if (string_is_empty(values[num_vals].value))\n         break;\n      num_vals++;\n   }\n\n   if (num_vals < 1)\n      return false;\n\n   /* Initialise string lists */\n   attr.i             = 0;\n   option->vals       = string_list_new();\n   option->val_labels = string_list_new();\n\n   if (!option->vals || !option->val_labels)\n      return false;\n\n   /* Initialise default value */\n   option->default_index = 0;\n   option->index         = 0;\n\n   /* Extract value/label pairs */\n   for (i = 0; i < num_vals; i++)\n   {\n      const char *value       = values[i].value;\n      uint32_t *value_hash    = (uint32_t *)malloc(sizeof(uint32_t));\n      const char *value_label = values[i].label;\n\n      /* Append value string\n       * > We know that 'value' is always valid */\n      string_list_append(option->vals, value, attr);\n\n      /* > Set value hash */\n      *value_hash = core_option_manager_hash_string(value);\n      option->vals->elems[option->vals->size - 1].userdata = (void*)value_hash;\n\n      /* Value label requires additional processing */\n      value_label = core_option_manager_parse_value_label(\n            value, value_label);\n\n      /* > Redundant safely check... */\n      if (string_is_empty(value_label))\n         value_label = value;\n\n      /* Append value label string */\n      string_list_append(option->val_labels, value_label, attr);\n\n      /* Check whether this value is the default setting */\n      if (!string_is_empty(option_def->default_value))\n      {\n         if (string_is_equal(option_def->default_value, value))\n         {\n            option->default_index = i;\n            option->index         = i;\n         }\n      }\n   }\n\n   if (config_src)\n      entry              = config_get_entry(config_src, option->key);\n   else\n      entry              = config_get_entry(opt->conf,  option->key);\n\n   /* Set current config value */\n   if (entry && !string_is_empty(entry->value))\n   {\n      uint32_t entry_value_hash = core_option_manager_hash_string(entry->value);\n\n      for (i = 0; i < option->vals->size; i++)\n      {\n         const char *value   = option->vals->elems[i].data;\n         uint32_t value_hash = *((uint32_t*)option->vals->elems[i].userdata);\n\n         if ((value_hash == entry_value_hash) &&\n             string_is_equal(value, entry->value))\n         {\n            option->index = i;\n            break;\n         }\n      }\n   }\n\n   return true;\n}\n\n/**\n * core_option_manager_new:\n *\n * @conf_path     : Filesystem path to write core option\n *                  config file to\n * @src_conf_path : Filesystem path from which to load\n *                  initial config settings.\n * @options_v2    : Pointer to retro_core_options_v2 struct\n * @categorized   : Flag specifying whether core option\n *                  category information should be read\n *                  from @options_v2\n *\n * Creates and initializes a core manager handle. Parses\n * information from a retro_core_options_v2 struct.\n * If @categorized is false, all option category\n * assignments will be ignored.\n *\n * Returns: handle to new core manager handle if successful,\n * otherwise NULL.\n **/\ncore_option_manager_t *core_option_manager_new(\n      const char *conf_path, const char *src_conf_path,\n      const struct retro_core_options_v2 *options_v2,\n      bool categorized)\n{\n   const struct retro_core_option_v2_category *option_cat   = NULL;\n   const struct retro_core_option_v2_definition *option_def = NULL;\n   struct retro_core_option_v2_category *option_cats        = NULL;\n   struct retro_core_option_v2_definition *option_defs      = NULL;\n   size_t cats_size                                         = 0;\n   size_t size                                              = 0;\n   config_file_t *config_src                                = NULL;\n   core_option_manager_t *opt                               = NULL;\n\n   if (!options_v2 ||\n       !options_v2->definitions)\n      return NULL;\n\n   option_cats = options_v2->categories;\n   option_defs = options_v2->definitions;\n\n   if (!(opt = (core_option_manager_t*)malloc(sizeof(*opt))))\n      return NULL;\n\n   opt->conf                         = NULL;\n   opt->conf_path[0]                 = '\\0';\n   opt->cats                         = NULL;\n   opt->cats_size                    = 0;\n   opt->opts                         = NULL;\n   opt->size                         = 0;\n   opt->option_map                   = nested_list_init();\n   opt->updated                      = false;\n\n   if (!opt->option_map)\n      goto error;\n\n   /* Open 'output' config file */\n   if (!string_is_empty(conf_path))\n      if (!(opt->conf = config_file_new_from_path_to_string(conf_path)))\n         if (!(opt->conf = config_file_new_alloc()))\n            goto error;\n\n   strlcpy(opt->conf_path, conf_path, sizeof(opt->conf_path));\n\n   /* Load source config file, if required */\n   if (!string_is_empty(src_conf_path))\n      config_src = config_file_new_from_path_to_string(src_conf_path);\n\n   /* Get number of categories, if required\n    * > Note: 'option_cat->info == NULL' is valid */\n   if (categorized && option_cats)\n   {\n      for (option_cat = option_cats;\n           !string_is_empty(option_cat->key) &&\n                  !string_is_empty(option_cat->desc);\n           option_cat++)\n         cats_size++;\n   }\n\n   /* Get number of options\n    * > Note: 'option_def->info == NULL' is valid */\n   for (option_def = option_defs;\n        option_def->key && option_def->desc && option_def->values[0].value;\n        option_def++)\n      size++;\n\n   if (size == 0)\n      goto error;\n\n   /* Create categories array */\n   if (cats_size > 0)\n   {\n      if (!(opt->cats = (struct core_category*)calloc(size,\n                  sizeof(*opt->cats))))\n         goto error;\n\n      opt->cats_size = cats_size;\n      cats_size      = 0;\n\n      /* Parse each category\n       * > Note: 'option_cat->info == NULL' is valid */\n      for (option_cat = option_cats;\n           !string_is_empty(option_cat->key) &&\n                  !string_is_empty(option_cat->desc);\n           cats_size++, option_cat++)\n      {\n         opt->cats[cats_size].key      = strdup(option_cat->key);\n         opt->cats[cats_size].key_hash = core_option_manager_hash_string(option_cat->key);\n         opt->cats[cats_size].desc     = strdup(option_cat->desc);\n\n         if (!string_is_empty(option_cat->info))\n            opt->cats[cats_size].info  = strdup(option_cat->info);\n      }\n   }\n\n   /* Create options array */\n   if (!(opt->opts = (struct core_option*)calloc(size, sizeof(*opt->opts))))\n      goto error;\n\n   opt->size = size;\n   size      = 0;\n\n   /* Parse each option\n    * > Note: 'option_def->info == NULL' is valid */\n   for (option_def = option_defs;\n        option_def->key && option_def->desc && option_def->values[0].value;\n        size++, option_def++)\n   {\n      if (core_option_manager_parse_option(opt, size, option_def, config_src))\n      {\n         /* If option is read correctly, add it to\n          * the map */\n         const char *category_key = opt->opts[size].category_key;\n         char address[256];\n\n         /* Address string is nominally:\n          *    <category_key><delim><tag><option_key>\n          * ...where <tag> is prepended to the option\n          * key in order to avoid category/option key\n          * collisions */\n         if (string_is_empty(category_key))\n         {\n            size_t _len     = 0;\n            address[  _len] = '#';\n            address[++_len] = '\\0';\n            strlcpy(address + _len, option_def->key, sizeof(address) - _len);\n         }\n         else\n         {\n            size_t _len      = strlcpy(address, category_key, sizeof(address));\n            address[  _len]  = ':';\n            address[++_len]  = '#';\n            address[++_len]  = '\\0';\n            strlcpy(address + _len, option_def->key, sizeof(address) - _len);\n         }\n\n         if (!nested_list_add_item(opt->option_map,\n               address, \":\",\n               (const void*)&opt->opts[size]))\n            goto error;\n      }\n      else\n         goto error;\n   }\n\n   if (config_src)\n      config_file_free(config_src);\n\n   return opt;\n\nerror:\n   if (config_src)\n      config_file_free(config_src);\n   core_option_manager_free(opt);\n   return NULL;\n}\n\n/**\n * core_option_manager_free:\n *\n * @opt : options manager handle\n *\n * Frees specified core options manager handle.\n **/\nvoid core_option_manager_free(core_option_manager_t *opt)\n{\n   size_t i;\n\n   if (!opt)\n      return;\n\n   for (i = 0; i < opt->cats_size; i++)\n   {\n      if (opt->cats[i].key)\n         free(opt->cats[i].key);\n      if (opt->cats[i].desc)\n         free(opt->cats[i].desc);\n      if (opt->cats[i].info)\n         free(opt->cats[i].info);\n\n      opt->cats[i].key  = NULL;\n      opt->cats[i].desc = NULL;\n      opt->cats[i].info = NULL;\n   }\n\n   for (i = 0; i < opt->size; i++)\n   {\n      if (opt->opts[i].desc)\n         free(opt->opts[i].desc);\n      if (opt->opts[i].desc_categorized)\n         free(opt->opts[i].desc_categorized);\n      if (opt->opts[i].info)\n         free(opt->opts[i].info);\n      if (opt->opts[i].info_categorized)\n         free(opt->opts[i].info_categorized);\n      if (opt->opts[i].key)\n         free(opt->opts[i].key);\n      if (opt->opts[i].category_key)\n         free(opt->opts[i].category_key);\n\n      if (opt->opts[i].vals)\n         string_list_free(opt->opts[i].vals);\n      if (opt->opts[i].val_labels)\n         string_list_free(opt->opts[i].val_labels);\n\n      opt->opts[i].desc             = NULL;\n      opt->opts[i].desc_categorized = NULL;\n      opt->opts[i].info             = NULL;\n      opt->opts[i].info_categorized = NULL;\n      opt->opts[i].key              = NULL;\n      opt->opts[i].category_key     = NULL;\n      opt->opts[i].vals             = NULL;\n   }\n\n   if (opt->option_map)\n      nested_list_free(opt->option_map);\n\n   if (opt->conf)\n      config_file_free(opt->conf);\n\n   free(opt->cats);\n   free(opt->opts);\n   free(opt);\n}\n\n/********************/\n/* Category Getters */\n/********************/\n\n/**\n * core_option_manager_get_category_desc:\n *\n * @opt : options manager handle\n * @key : core option category id string\n *\n * Fetches the 'description' text of the core option\n * category identified by @key (used as the\n * category label in the menu).\n *\n * Returns: description string (menu label) of the\n * specified option category if successful,\n * otherwise NULL.\n **/\nconst char *core_option_manager_get_category_desc(core_option_manager_t *opt,\n      const char *key)\n{\n   uint32_t key_hash;\n   size_t i;\n\n   if (  !opt\n       || string_is_empty(key))\n      return NULL;\n\n   key_hash = core_option_manager_hash_string(key);\n\n   for (i = 0; i < opt->cats_size; i++)\n   {\n      struct core_category *category = &opt->cats[i];\n\n      if (   (key_hash == category->key_hash)\n          && !string_is_empty(category->key)\n          &&  string_is_equal(key, category->key))\n         return category->desc;\n   }\n\n   return NULL;\n}\n\n/**\n * core_option_manager_get_category_info:\n *\n * @opt : options manager handle\n * @key : core option category id string\n *\n * Fetches the 'info' text of the core option\n * category identified by @key (used as the category\n * sublabel in the menu).\n *\n * Returns: information string (menu sublabel) of\n * the specified option category if successful,\n * otherwise NULL.\n **/\nconst char *core_option_manager_get_category_info(core_option_manager_t *opt,\n      const char *key)\n{\n   uint32_t key_hash;\n   size_t i;\n\n   if (!opt ||\n       string_is_empty(key))\n      return NULL;\n\n   key_hash = core_option_manager_hash_string(key);\n\n   for (i = 0; i < opt->cats_size; i++)\n   {\n      struct core_category *category = &opt->cats[i];\n\n      if (   (key_hash == category->key_hash)\n          && !string_is_empty(category->key)\n          &&  string_is_equal(key, category->key))\n         return category->info;\n   }\n\n   return NULL;\n}\n\n/**\n * core_option_manager_get_category_visible:\n *\n * @opt : options manager handle\n * @key : core option category id string\n *\n * Queries whether the core option category\n * identified by @key should be displayed in\n * the frontend menu. (A category is deemed to\n * be visible if at least one of the options\n * in the category is visible)\n *\n * @return true if option category should be\n * displayed by the frontend, otherwise false.\n **/\nbool core_option_manager_get_category_visible(core_option_manager_t *opt,\n      const char *key)\n{\n   size_t i;\n   nested_list_item_t *category_item = NULL;\n   nested_list_t *option_list        = NULL;\n\n   if (  !opt\n       || string_is_empty(key))\n      return false;\n\n   /* Fetch category item from map */\n   if (!(category_item = nested_list_get_item(opt->option_map,\n         key, NULL)))\n      return false;\n\n   /* Get child options of specified category */\n   if (!(option_list = nested_list_item_get_children(category_item)))\n      return false;\n\n   /* Loop over child options */\n   for (i = 0; i < nested_list_get_size(option_list); i++)\n   {\n      nested_list_item_t *option_item  = nested_list_get_item_idx(option_list, i);\n      const struct core_option *option = (const struct core_option *)\n            nested_list_item_get_value(option_item);\n      /* Check if current option is visible */\n      if (option && option->visible)\n         return true;\n   }\n\n   return false;\n}\n\n/******************/\n/* Option Getters */\n/******************/\n\n/**\n * core_option_manager_get_idx:\n *\n * @opt : options manager handle\n * @key : core option key string (variable to query\n *        in RETRO_ENVIRONMENT_GET_VARIABLE)\n * @idx : index of core option corresponding\n *        to @key\n *\n * Fetches the index of the core option identified\n * by the specified @key.\n *\n * @return true if option matching the specified\n * key was found, otherwise false.\n **/\nbool core_option_manager_get_idx(core_option_manager_t *opt,\n      const char *key, size_t *idx)\n{\n   uint32_t key_hash;\n   size_t i;\n\n   if (  !opt\n       || string_is_empty(key)\n       || !idx)\n      return false;\n\n   key_hash = core_option_manager_hash_string(key);\n\n   for (i = 0; i < opt->size; i++)\n   {\n      struct core_option *option = &opt->opts[i];\n\n      if (   (key_hash == option->key_hash)\n          && !string_is_empty(option->key)\n          &&  string_is_equal(key, option->key))\n      {\n         *idx = i;\n         return true;\n      }\n   }\n\n   return false;\n}\n\n/**\n * core_option_manager_get_val_idx:\n *\n * @opt     : options manager handle\n * @idx     : core option index\n * @val     : string representation of the\n *            core option value\n * @val_idx : index of core option value\n *            corresponding to @val\n *\n * Fetches the index of the core option value\n * identified by the specified core option @idx\n * and @val string.\n *\n * Returns: true if option value matching the\n * specified option index and value string\n * was found, otherwise false.\n **/\nbool core_option_manager_get_val_idx(core_option_manager_t *opt,\n      size_t idx, const char *val, size_t *val_idx)\n{\n   struct core_option *option = NULL;\n   uint32_t val_hash;\n   size_t i;\n\n   if (   !opt\n       || (idx >= opt->size)\n       || string_is_empty(val)\n       || !val_idx)\n      return false;\n\n   val_hash = core_option_manager_hash_string(val);\n   option   = (struct core_option*)&opt->opts[idx];\n\n   for (i = 0; i < option->vals->size; i++)\n   {\n      const char *option_val   = option->vals->elems[i].data;\n      uint32_t option_val_hash = *((uint32_t*)option->vals->elems[i].userdata);\n\n      if ((val_hash == option_val_hash) &&\n          !string_is_empty(option_val) &&\n          string_is_equal(val, option_val))\n      {\n         *val_idx = i;\n         return true;\n      }\n   }\n\n   return false;\n}\n\n/**\n * core_option_manager_get_desc:\n *\n * @opt         : options manager handle\n * @idx         : core option index\n * @categorized : flag specifying whether to\n *                fetch the categorised description\n *                or the legacy fallback\n *\n * Fetches the 'description' of the core option at\n * index @idx (used as the option label in the menu).\n * If menu has option category support, @categorized\n * should be true. (At present, only the Qt interface\n * requires @categorized to be false)\n *\n * Returns: description string (menu label) of the\n * specified option if successful, otherwise NULL.\n **/\nconst char *core_option_manager_get_desc(core_option_manager_t *opt,\n      size_t idx, bool categorized)\n{\n   const char *desc = NULL;\n\n   if (   !opt\n       || (idx >= opt->size))\n      return NULL;\n   /* Try categorised description first,\n    * if requested */\n   if (categorized)\n      desc = opt->opts[idx].desc_categorized;\n   /* Fall back to legacy description, if\n    * required */\n   if (string_is_empty(desc))\n      return opt->opts[idx].desc;\n   return desc;\n}\n\n/**\n * core_option_manager_get_info:\n *\n * @opt         : options manager handle\n * @idx         : core option index\n * @categorized : flag specifying whether to\n *                fetch the categorised information\n *                or the legacy fallback\n *\n * Fetches the 'info' text of the core option at\n * index @idx (used as the option sublabel in the\n * menu). If menu has option category support,\n * @categorized should be true. (At present, only\n * the Qt interface requires @categorized to be false)\n *\n * Returns: information string (menu sublabel) of the\n * specified option if successful, otherwise NULL.\n **/\nconst char *core_option_manager_get_info(core_option_manager_t *opt,\n      size_t idx, bool categorized)\n{\n   const char *info = NULL;\n\n   if (   !opt\n       || (idx >= opt->size))\n      return NULL;\n\n   /* Try categorised information first,\n    * if requested */\n   if (categorized)\n      info = opt->opts[idx].info_categorized;\n   /* Fall back to legacy information, if\n    * required */\n   if (string_is_empty(info))\n      return opt->opts[idx].info;\n   return info;\n}\n\n/**\n * core_option_manager_get_val:\n *\n * @opt : options manager handle\n * @idx : core option index\n *\n * Fetches the string representation of the current\n * value of the core option at index @idx.\n *\n * Returns: core option value string if successful,\n * otherwise NULL.\n **/\nconst char *core_option_manager_get_val(core_option_manager_t *opt,\n      size_t idx)\n{\n   struct core_option *option = NULL;\n\n   if (   !opt\n       || (idx >= opt->size))\n      return NULL;\n\n   option = (struct core_option*)&opt->opts[idx];\n\n   return option->vals->elems[option->index].data;\n}\n\n/**\n * core_option_manager_get_val_label:\n *\n * @opt : options manager handle\n * @idx : core option index\n *\n * Fetches the 'label' text (used for display purposes\n * in the menu) for the current value of the core\n * option at index @idx.\n *\n * Returns: core option value label string if\n * successful, otherwise NULL.\n **/\nconst char *core_option_manager_get_val_label(core_option_manager_t *opt,\n      size_t idx)\n{\n   struct core_option *option = NULL;\n\n   if (   !opt\n       || (idx >= opt->size))\n      return NULL;\n\n   option = (struct core_option*)&opt->opts[idx];\n\n   return option->val_labels->elems[option->index].data;\n}\n\n/**\n * core_option_manager_get_visible:\n *\n * @opt : options manager handle\n * @idx : core option index\n *\n * Queries whether the core option at index @idx\n * should be displayed in the frontend menu.\n *\n * Returns: true if option should be displayed by\n * the frontend, otherwise false.\n **/\nbool core_option_manager_get_visible(core_option_manager_t *opt,\n      size_t idx)\n{\n   if (    !opt\n       || (idx >= opt->size))\n      return false;\n\n   return opt->opts[idx].visible;\n}\n\n/******************/\n/* Option Setters */\n/******************/\n\n/**\n * core_option_manager_set_val:\n *\n * @opt          : options manager handle\n * @idx          : core option index\n * @val_idx      : index of the value to set\n * @refresh_menu : flag specifying whether menu\n *                 should be refreshed if changes\n *                 to option visibility are detected\n *\n * Sets the core option at index @idx to the\n * option value corresponding to @val_idx.\n * After setting the option value, a request\n * will be made for the core to update the\n * in-menu visibility of all options; if\n * visibility changes are detected and\n * @refresh_menu is true, the menu will be\n * redrawn.\n **/\nvoid core_option_manager_set_val(core_option_manager_t *opt,\n      size_t idx, size_t val_idx, bool refresh_menu)\n{\n   struct core_option *option = NULL;\n\n   if (!opt ||\n       (idx >= opt->size))\n      return;\n\n   option        = (struct core_option*)&opt->opts[idx];\n   option->index = val_idx % option->vals->size;\n   opt->updated  = true;\n\n#ifdef HAVE_CHEEVOS\n   rcheevos_validate_config_settings();\n#endif\n\n#ifdef HAVE_MENU\n   /* Refresh menu (if required) if core option\n    * visibility has changed as a result of modifying\n    * the current option value */\n   if (retroarch_ctl(RARCH_CTL_CORE_OPTION_UPDATE_DISPLAY, NULL) &&\n       refresh_menu)\n   {\n      struct menu_state *menu_st = menu_state_get_ptr();\n      menu_st->flags            |=  MENU_ST_FLAG_ENTRIES_NEED_REFRESH\n                                 |  MENU_ST_FLAG_PREVENT_POPULATE;\n   }\n#endif\n}\n\n/**\n * core_option_manager_adjust_val:\n *\n * @opt          : options manager handle\n * @idx          : core option index\n * @adjustment   : offset to apply from current\n *                 value index\n * @refresh_menu : flag specifying whether menu\n *                 should be refreshed if changes\n *                 to option visibility are detected\n *\n * Modifies the value of the core option at\n * index @idx by incrementing the current option\n * value index by @adjustment.\n * After setting the option value, a request\n * will be made for the core to update the\n * in-menu visibility of all options; if\n * visibility changes are detected and\n * @refresh_menu is true, the menu will be\n * redrawn.\n **/\nvoid core_option_manager_adjust_val(core_option_manager_t* opt,\n      size_t idx, int adjustment, bool refresh_menu)\n{\n   struct core_option* option = NULL;\n\n   if (   !opt\n       || (idx >= opt->size))\n      return;\n\n   option        = (struct core_option*)&opt->opts[idx];\n   option->index = (option->index + option->vals->size + adjustment) % option->vals->size;\n   opt->updated  = true;\n\n#ifdef HAVE_CHEEVOS\n   rcheevos_validate_config_settings();\n#endif\n\n#ifdef HAVE_MENU\n   /* Refresh menu (if required) if core option\n    * visibility has changed as a result of modifying\n    * the current option value */\n   if (retroarch_ctl(RARCH_CTL_CORE_OPTION_UPDATE_DISPLAY, NULL) &&\n       refresh_menu)\n   {\n      struct menu_state *menu_st = menu_state_get_ptr();\n      menu_st->flags            |=  MENU_ST_FLAG_ENTRIES_NEED_REFRESH\n                                 |  MENU_ST_FLAG_PREVENT_POPULATE;\n   }\n#endif\n}\n\n/**\n * core_option_manager_set_default:\n *\n * @opt          : options manager handle\n * @idx          : core option index\n * @refresh_menu : flag specifying whether menu\n *                 should be refreshed if changes\n *                 to option visibility are detected\n *\n * Resets the core option at index @idx to\n * its default value.\n * After setting the option value, a request\n * will be made for the core to update the\n * in-menu visibility of all options; if\n * visibility changes are detected and\n * @refresh_menu is true, the menu will be\n * redrawn.\n **/\nvoid core_option_manager_set_default(core_option_manager_t *opt,\n      size_t idx, bool refresh_menu)\n{\n   if (   !opt\n       || (idx >= opt->size))\n      return;\n\n   opt->opts[idx].index = opt->opts[idx].default_index;\n   opt->updated         = true;\n\n#ifdef HAVE_CHEEVOS\n   rcheevos_validate_config_settings();\n#endif\n\n#ifdef HAVE_MENU\n   /* Refresh menu (if required) if core option\n    * visibility has changed as a result of modifying\n    * the current option value */\n   if (retroarch_ctl(RARCH_CTL_CORE_OPTION_UPDATE_DISPLAY, NULL) &&\n       refresh_menu)\n   {\n      struct menu_state *menu_st = menu_state_get_ptr();\n      menu_st->flags            |=  MENU_ST_FLAG_ENTRIES_NEED_REFRESH\n                                 |  MENU_ST_FLAG_PREVENT_POPULATE;\n   }\n#endif\n}\n\n/**\n * core_option_manager_set_visible:\n *\n * @opt     : options manager handle\n * @key     : core option key string (variable to query\n *            in RETRO_ENVIRONMENT_GET_VARIABLE)\n * @visible : flag specifying whether option should\n *            be shown in the menu\n *\n * Sets the in-menu visibility of the core option\n * identified by the specified @key.\n **/\nvoid core_option_manager_set_visible(core_option_manager_t *opt,\n      const char *key, bool visible)\n{\n   uint32_t key_hash;\n   size_t i;\n\n   if (!opt || string_is_empty(key))\n      return;\n\n   key_hash = core_option_manager_hash_string(key);\n\n   for (i = 0; i < opt->size; i++)\n   {\n      struct core_option *option = &opt->opts[i];\n\n      if ((key_hash == option->key_hash) &&\n          !string_is_empty(option->key) &&\n          string_is_equal(key, option->key))\n      {\n         option->visible = visible;\n         return;\n      }\n   }\n}\n\n/**********************/\n/* Configuration File */\n/**********************/\n\n/**\n * core_option_manager_flush:\n *\n * @opt  : options manager handle\n * @conf : configuration file handle\n *\n * Writes all core option key-pair values from the\n * specified core option manager handle to the\n * specified configuration file struct.\n **/\nvoid core_option_manager_flush(core_option_manager_t *opt,\n      config_file_t *conf)\n{\n   size_t i;\n\n   for (i = 0; i < opt->size; i++)\n   {\n      struct core_option *option = (struct core_option*)&opt->opts[i];\n\n      if (option)\n         config_set_string(conf, option->key,\n               opt->opts[i].vals->elems[opt->opts[i].index].data);\n   }\n}\n"
        },
        {
          "name": "core_option_manager.h",
          "type": "blob",
          "size": 14.2197265625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef CORE_OPTION_MANAGER_H__\n#define CORE_OPTION_MANAGER_H__\n\n#include <stddef.h>\n\n#include <boolean.h>\n#include <retro_common_api.h>\n#include <lists/string_list.h>\n#include <lists/nested_list.h>\n#include <file/config_file.h>\n#include <libretro.h>\n\n#include <retro_miscellaneous.h>\n\nRETRO_BEGIN_DECLS\n\nstruct core_option\n{\n   char *desc;\n   char *desc_categorized;\n   char *info;\n   char *info_categorized;\n   char *key;\n   char *category_key;\n   struct string_list *vals;\n   struct string_list *val_labels;\n   /* opt_idx: option index, used for internal\n    * bookkeeping */\n   size_t opt_idx;\n   /* default_index, index: correspond to\n    * option *value* indices */\n   size_t default_index;\n   size_t index;\n   uint32_t key_hash;\n   bool visible;\n};\n\nstruct core_category\n{\n   char *key;\n   char *desc;\n   char *info;\n   uint32_t key_hash;\n};\n\n/* TODO/FIXME: This struct should be made\n * 'private', with restricted access to its\n * members via interface functions. This\n * requires significant refactoring... */\nstruct core_option_manager\n{\n   config_file_t *conf;\n   char conf_path[PATH_MAX_LENGTH];\n\n   struct core_category *cats;\n   struct core_option *opts;\n   nested_list_t *option_map;\n\n   size_t cats_size;\n   size_t size;\n\n   bool updated;\n};\n\ntypedef struct core_option_manager core_option_manager_t;\n\n/*********************/\n/* Option Conversion */\n/*********************/\n\n/**\n * core_option_manager_convert_v1:\n *\n * @options_v1 : an array of retro_core_option_definition\n *               structs\n *\n * Converts an array of core option v1 definitions into\n * a v2 core options struct. Returned pointer must be\n * freed using core_option_manager_free_converted().\n *\n * Returns: Valid pointer to a new v2 core options struct\n * if successful, otherwise NULL.\n **/\nstruct retro_core_options_v2 *core_option_manager_convert_v1(\n      const struct retro_core_option_definition *options_v1);\n\n/**\n * core_option_manager_convert_v1_intl:\n *\n * @options_v1_intl : pointer to a retro_core_options_intl\n *                    struct\n *\n * Converts a v1 'international' core options definition\n * struct into a v2 core options struct. Returned pointer\n * must be freed using core_option_manager_free_converted().\n *\n * Returns: Valid pointer to a new v2 core options struct\n * if successful, otherwise NULL.\n **/\nstruct retro_core_options_v2 *core_option_manager_convert_v1_intl(\n      const struct retro_core_options_intl *options_v1_intl);\n\n/**\n * core_option_manager_convert_v2_intl:\n *\n * @options_v2_intl : pointer to a retro_core_options_v2_intl\n *                    struct\n *\n * Converts a v2 'international' core options struct\n * into a regular v2 core options struct. Returned pointer\n * must be freed using core_option_manager_free_converted().\n *\n * Returns: Valid pointer to a new v2 core options struct\n * if successful, otherwise NULL.\n **/\nstruct retro_core_options_v2 *core_option_manager_convert_v2_intl(\n      const struct retro_core_options_v2_intl *options_v2_intl);\n\n/**\n * core_option_manager_free_converted:\n *\n * @options_v2 : pointer to a retro_core_options_v2\n *               struct\n *\n * Frees the pointer returned by any\n * core_option_manager_convert_*() function.\n **/\nvoid core_option_manager_free_converted(\n      struct retro_core_options_v2 *options_v2);\n\n/**************************************/\n/* Initialisation / De-Initialisation */\n/**************************************/\n\n/**\n * core_option_manager_new_vars:\n *\n * @conf_path     : Filesystem path to write core option\n *                  config file to\n * @src_conf_path : Filesystem path from which to load\n *                  initial config settings.\n * @vars          : Pointer to core option variable array\n *                  handle\n *\n * Legacy version of core_option_manager_new().\n * Creates and initializes a core manager handle.\n *\n * Returns: handle to new core manager handle if successful,\n * otherwise NULL.\n **/\ncore_option_manager_t *core_option_manager_new_vars(\n      const char *conf_path, const char *src_conf_path,\n      const struct retro_variable *vars);\n\n/**\n * core_option_manager_new:\n *\n * @conf_path     : Filesystem path to write core option\n *                  config file to\n * @src_conf_path : Filesystem path from which to load\n *                  initial config settings.\n * @options_v2    : Pointer to retro_core_options_v2 struct\n * @categorized   : Flag specifying whether core option\n *                  category information should be read\n *                  from @options_v2\n *\n * Creates and initializes a core manager handle. Parses\n * information from a retro_core_options_v2 struct.\n * If @categorized is false, all option category\n * assignments will be ignored.\n *\n * Returns: handle to new core manager handle if successful,\n * otherwise NULL.\n **/\ncore_option_manager_t *core_option_manager_new(\n      const char *conf_path, const char *src_conf_path,\n      const struct retro_core_options_v2 *options_v2,\n      bool categorized);\n\n/**\n * core_option_manager_free:\n *\n * @opt : options manager handle\n *\n * Frees specified core options manager handle.\n **/\nvoid core_option_manager_free(core_option_manager_t *opt);\n\n/********************/\n/* Category Getters */\n/********************/\n\n/**\n * core_option_manager_get_category_desc:\n *\n * @opt : options manager handle\n * @key : core option category id string\n *\n * Fetches the 'description' text of the core option\n * category identified by @key (used as the\n * category label in the menu).\n *\n * Returns: description string (menu label) of the\n * specified option category if successful,\n * otherwise NULL.\n **/\nconst char *core_option_manager_get_category_desc(core_option_manager_t *opt,\n      const char *key);\n\n/**\n * core_option_manager_get_category_info:\n *\n * @opt : options manager handle\n * @key : core option category id string\n *\n * Fetches the 'info' text of the core option\n * category identified by @key (used as the category\n * sublabel in the menu).\n *\n * Returns: information string (menu sublabel) of\n * the specified option category if successful,\n * otherwise NULL.\n **/\nconst char *core_option_manager_get_category_info(core_option_manager_t *opt,\n      const char *key);\n\n/**\n * core_option_manager_get_category_visible:\n *\n * @opt : options manager handle\n * @key : core option category id string\n *\n * Queries whether the core option category\n * identified by @key should be displayed in\n * the frontend menu. (A category is deemed to\n * be visible if at least one of the options\n * in the category is visible)\n *\n * @return true if option category should be\n * displayed by the frontend, otherwise false.\n **/\nbool core_option_manager_get_category_visible(core_option_manager_t *opt,\n      const char *key);\n\n/******************/\n/* Option Getters */\n/******************/\n\n/**\n * core_option_manager_get_idx:\n *\n * @opt : options manager handle\n * @key : core option key string (variable to query\n *        in RETRO_ENVIRONMENT_GET_VARIABLE)\n * @idx : index of core option corresponding\n *        to @key\n *\n * Fetches the index of the core option identified\n * by the specified @key.\n *\n * @return true if option matching the specified\n * key was found, otherwise false.\n **/\nbool core_option_manager_get_idx(core_option_manager_t *opt,\n      const char *key, size_t *idx);\n\n/**\n * core_option_manager_get_val_idx:\n *\n * @opt     : options manager handle\n * @idx     : core option index\n * @val     : string representation of the\n *            core option value\n * @val_idx : index of core option value\n *            corresponding to @val\n *\n * Fetches the index of the core option value\n * identified by the specified core option @idx\n * and @val string.\n *\n * Returns: true if option value matching the\n * specified option index and value string\n * was found, otherwise false.\n **/\nbool core_option_manager_get_val_idx(core_option_manager_t *opt,\n      size_t idx, const char *val, size_t *val_idx);\n\n/**\n * core_option_manager_get_desc:\n *\n * @opt         : options manager handle\n * @idx         : core option index\n * @categorized : flag specifying whether to\n *                fetch the categorised description\n *                or the legacy fallback\n *\n * Fetches the 'description' of the core option at\n * index @idx (used as the option label in the menu).\n * If menu has option category support, @categorized\n * should be true. (At present, only the Qt interface\n * requires @categorized to be false)\n *\n * Returns: description string (menu label) of the\n * specified option if successful, otherwise NULL.\n **/\nconst char *core_option_manager_get_desc(core_option_manager_t *opt,\n      size_t idx, bool categorized);\n\n/**\n * core_option_manager_get_info:\n *\n * @opt         : options manager handle\n * @idx         : core option index\n * @categorized : flag specifying whether to\n *                fetch the categorised information\n *                or the legacy fallback\n *\n * Fetches the 'info' text of the core option at\n * index @idx (used as the option sublabel in the\n * menu). If menu has option category support,\n * @categorized should be true. (At present, only\n * the Qt interface requires @categorized to be false)\n *\n * Returns: information string (menu sublabel) of the\n * specified option if successful, otherwise NULL.\n **/\nconst char *core_option_manager_get_info(core_option_manager_t *opt,\n      size_t idx, bool categorized);\n\n/**\n * core_option_manager_get_val:\n *\n * @opt : options manager handle\n * @idx : core option index\n *\n * Fetches the string representation of the current\n * value of the core option at index @idx.\n *\n * Returns: core option value string if successful,\n * otherwise NULL.\n **/\nconst char *core_option_manager_get_val(core_option_manager_t *opt,\n      size_t idx);\n\n/**\n * core_option_manager_get_val_label:\n *\n * @opt : options manager handle\n * @idx : core option index\n *\n * Fetches the 'label' text (used for display purposes\n * in the menu) for the current value of the core\n * option at index @idx.\n *\n * Returns: core option value label string if\n * successful, otherwise NULL.\n **/\nconst char *core_option_manager_get_val_label(core_option_manager_t *opt,\n      size_t idx);\n\n/**\n * core_option_manager_get_visible:\n *\n * @opt : options manager handle\n * @idx : core option index\n *\n * Queries whether the core option at index @idx\n * should be displayed in the frontend menu.\n *\n * Returns: true if option should be displayed by\n * the frontend, otherwise false.\n **/\nbool core_option_manager_get_visible(core_option_manager_t *opt,\n      size_t idx);\n\n/******************/\n/* Option Setters */\n/******************/\n\n/**\n * core_option_manager_set_val:\n *\n * @opt          : options manager handle\n * @idx          : core option index\n * @val_idx      : index of the value to set\n * @refresh_menu : flag specifying whether menu\n *                 should be refreshed if changes\n *                 to option visibility are detected\n *\n * Sets the core option at index @idx to the\n * option value corresponding to @val_idx.\n * After setting the option value, a request\n * will be made for the core to update the\n * in-menu visibility of all options; if\n * visibility changes are detected and\n * @refresh_menu is true, the menu will be\n * redrawn.\n **/\nvoid core_option_manager_set_val(core_option_manager_t *opt,\n      size_t idx, size_t val_idx, bool refresh_menu);\n\n/**\n * core_option_manager_adjust_val:\n *\n * @opt          : options manager handle\n * @idx          : core option index\n * @adjustment   : offset to apply from current\n *                 value index\n * @refresh_menu : flag specifying whether menu\n *                 should be refreshed if changes\n *                 to option visibility are detected\n *\n * Modifies the value of the core option at\n * index @idx by incrementing the current option\n * value index by @adjustment.\n * After setting the option value, a request\n * will be made for the core to update the\n * in-menu visibility of all options; if\n * visibility changes are detected and\n * @refresh_menu is true, the menu will be\n * redrawn.\n **/\nvoid core_option_manager_adjust_val(core_option_manager_t* opt,\n      size_t idx, int adjustment, bool refresh_menu);\n\n/**\n * core_option_manager_set_default:\n *\n * @opt          : options manager handle\n * @idx          : core option index\n * @refresh_menu : flag specifying whether menu\n *                 should be refreshed if changes\n *                 to option visibility are detected\n *\n * Resets the core option at index @idx to\n * its default value.\n * After setting the option value, a request\n * will be made for the core to update the\n * in-menu visibility of all options; if\n * visibility changes are detected and\n * @refresh_menu is true, the menu will be\n * redrawn.\n **/\nvoid core_option_manager_set_default(core_option_manager_t *opt,\n      size_t idx, bool refresh_menu);\n\n/**\n * core_option_manager_set_visible:\n *\n * @opt     : options manager handle\n * @key     : core option key string (variable to query\n *            in RETRO_ENVIRONMENT_GET_VARIABLE)\n * @visible : flag specifying whether option should\n *            be shown in the menu\n *\n * Sets the in-menu visibility of the core option\n * identified by the specified @key.\n **/\nvoid core_option_manager_set_visible(core_option_manager_t *opt,\n      const char *key, bool visible);\n\n/**********************/\n/* Configuration File */\n/**********************/\n\n/**\n * core_option_manager_flush:\n *\n * @opt  : options manager handle\n * @conf : configuration file handle\n *\n * Writes all core option key-pair values from the\n * specified core option manager handle to the\n * specified configuration file struct.\n **/\nvoid core_option_manager_flush(core_option_manager_t *opt,\n      config_file_t *conf);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "core_updater_list.c",
          "type": "blob",
          "size": 26.6337890625,
          "content": "/* Copyright  (C) 2010-2019 The RetroArch team\n *\n * ---------------------------------------------------------------------------------------\n * The following license statement only applies to this file (core_updater_list.c).\n * ---------------------------------------------------------------------------------------\n *\n * Permission is hereby granted, free of charge,\n * to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <file/file_path.h>\n#include <string/stdstring.h>\n#include <lists/string_list.h>\n#include <net/net_http.h>\n#include <array/rbuf.h>\n#include <retro_miscellaneous.h>\n\n#include \"file_path_special.h\"\n#include \"core_info.h\"\n\n#include \"core_updater_list.h\"\n\n/* Holds all entries in a core updater list */\nstruct core_updater_list\n{\n   core_updater_list_entry_t *entries;\n   enum core_updater_list_type type;\n};\n\n/* Cached ('global') core updater list */\nstatic core_updater_list_t *core_list_cached = NULL;\n\n/**************************************/\n/* Initialisation / De-Initialisation */\n/**************************************/\n\n/* Frees contents of specified core updater\n * list entry */\nstatic void core_updater_list_free_entry(core_updater_list_entry_t *entry)\n{\n   if (!entry)\n      return;\n\n   if (entry->remote_filename)\n   {\n      free(entry->remote_filename);\n      entry->remote_filename = NULL;\n   }\n\n   if (entry->remote_core_path)\n   {\n      free(entry->remote_core_path);\n      entry->remote_core_path = NULL;\n   }\n\n   if (entry->local_core_path)\n   {\n      free(entry->local_core_path);\n      entry->local_core_path = NULL;\n   }\n\n   if (entry->local_info_path)\n   {\n      free(entry->local_info_path);\n      entry->local_info_path = NULL;\n   }\n\n   if (entry->display_name)\n   {\n      free(entry->display_name);\n      entry->display_name = NULL;\n   }\n\n   if (entry->description)\n   {\n      free(entry->description);\n      entry->description = NULL;\n   }\n\n   if (entry->licenses_list)\n   {\n      string_list_free(entry->licenses_list);\n      entry->licenses_list = NULL;\n   }\n}\n\n/* Creates a new, empty core updater list.\n * Returns a handle to a new core_updater_list_t object\n * on success, otherwise returns NULL. */\ncore_updater_list_t *core_updater_list_init(void)\n{\n   /* Create core updater list */\n   core_updater_list_t *core_list = (core_updater_list_t*)\n         malloc(sizeof(*core_list));\n\n   if (!core_list)\n      return NULL;\n\n   /* Initialise members */\n   core_list->entries = NULL;\n   core_list->type    = CORE_UPDATER_LIST_TYPE_UNKNOWN;\n\n   return core_list;\n}\n\n/* Resets (removes all entries of) specified core\n * updater list */\nvoid core_updater_list_reset(core_updater_list_t *core_list)\n{\n   if (!core_list)\n      return;\n\n   if (core_list->entries)\n   {\n      size_t i;\n\n      for (i = 0; i < RBUF_LEN(core_list->entries); i++)\n         core_updater_list_free_entry(&core_list->entries[i]);\n\n      RBUF_FREE(core_list->entries);\n   }\n\n   core_list->type = CORE_UPDATER_LIST_TYPE_UNKNOWN;\n}\n\n/* Frees specified core updater list */\nvoid core_updater_list_free(core_updater_list_t *core_list)\n{\n   if (!core_list)\n      return;\n\n   core_updater_list_reset(core_list);\n   free(core_list);\n}\n\n/***************/\n/* Cached List */\n/***************/\n\n/* Creates a new, empty cached core updater list\n * (i.e. 'global' list).\n * Returns false in the event of an error. */\nbool core_updater_list_init_cached(void)\n{\n   /* Free any existing cached core updater list */\n   if (core_list_cached)\n   {\n      core_updater_list_free(core_list_cached);\n      core_list_cached = NULL;\n   }\n\n   core_list_cached = core_updater_list_init();\n\n   if (!core_list_cached)\n      return false;\n\n   return true;\n}\n\n/* Fetches cached core updater list */\ncore_updater_list_t *core_updater_list_get_cached(void)\n{\n   if (core_list_cached)\n      return core_list_cached;\n\n   return NULL;\n}\n\n/* Frees cached core updater list */\nvoid core_updater_list_free_cached(void)\n{\n   core_updater_list_free(core_list_cached);\n   core_list_cached = NULL;\n}\n\n/***********/\n/* Getters */\n/***********/\n\n/* Returns number of entries in core updater list */\nsize_t core_updater_list_size(core_updater_list_t *core_list)\n{\n   if (!core_list)\n      return 0;\n\n   return RBUF_LEN(core_list->entries);\n}\n\n/* Returns 'type' (core delivery method) of\n * specified core updater list */\nenum core_updater_list_type core_updater_list_get_type(\n      core_updater_list_t *core_list)\n{\n   if (!core_list)\n      return CORE_UPDATER_LIST_TYPE_UNKNOWN;\n\n   return core_list->type;\n}\n\n/* Fetches core updater list entry corresponding\n * to the specified entry index.\n * Returns false if index is invalid. */\nbool core_updater_list_get_index(\n      core_updater_list_t *core_list,\n      size_t idx,\n      const core_updater_list_entry_t **entry)\n{\n   if (!core_list || !entry)\n      return false;\n\n   if (idx >= RBUF_LEN(core_list->entries))\n      return false;\n\n   *entry = &core_list->entries[idx];\n\n   return true;\n}\n\n/* Fetches core updater list entry corresponding\n * to the specified remote core filename.\n * Returns false if core is not found. */\nbool core_updater_list_get_filename(\n      core_updater_list_t *core_list,\n      const char *remote_filename,\n      const core_updater_list_entry_t **entry)\n{\n   size_t num_entries;\n   size_t i;\n\n   if (!core_list || !entry || string_is_empty(remote_filename))\n      return false;\n\n   num_entries = RBUF_LEN(core_list->entries);\n\n   if (num_entries < 1)\n      return false;\n\n   /* Search for specified filename */\n   for (i = 0; i < num_entries; i++)\n   {\n      core_updater_list_entry_t *current_entry = &core_list->entries[i];\n\n      if (string_is_empty(current_entry->remote_filename))\n         continue;\n\n      if (string_is_equal(remote_filename, current_entry->remote_filename))\n      {\n         *entry = current_entry;\n         return true;\n      }\n   }\n\n   return false;\n}\n\n/* Fetches core updater list entry corresponding\n * to the specified core.\n * Returns false if core is not found. */\nbool core_updater_list_get_core(\n      core_updater_list_t *core_list,\n      const char *local_core_path,\n      const core_updater_list_entry_t **entry)\n{\n   bool resolve_symlinks;\n   size_t num_entries;\n   size_t i;\n   char real_core_path[PATH_MAX_LENGTH];\n\n   if (!core_list || !entry || string_is_empty(local_core_path))\n      return false;\n   if ((num_entries = RBUF_LEN(core_list->entries)) < 1)\n      return false;\n\n   /* Resolve absolute pathname of local_core_path */\n   strlcpy(real_core_path, local_core_path, sizeof(real_core_path));\n   /* Can't resolve symlinks when dealing with cores\n    * installed via play feature delivery, because the\n    * source files have non-standard file names (which\n    * will not be recognised by regular core handling\n    * routines) */\n   resolve_symlinks = (core_list->type != CORE_UPDATER_LIST_TYPE_PFD);\n   path_resolve_realpath(real_core_path, sizeof(real_core_path),\n         resolve_symlinks);\n\n   if (string_is_empty(real_core_path))\n      return false;\n\n   /* Search for specified core */\n   for (i = 0; i < num_entries; i++)\n   {\n      core_updater_list_entry_t *current_entry = &core_list->entries[i];\n\n      if (string_is_empty(current_entry->local_core_path))\n         continue;\n\n#ifdef _WIN32\n      /* Handle case-insensitive operating systems*/\n      if (string_is_equal_noncase(real_core_path, current_entry->local_core_path))\n      {\n#else\n      if (string_is_equal(real_core_path, current_entry->local_core_path))\n      {\n#endif\n         *entry = current_entry;\n         return true;\n      }\n   }\n\n   return false;\n}\n\n/***********/\n/* Setters */\n/***********/\n\n/* Parses date string and adds contents to\n * specified core updater list entry */\nstatic bool core_updater_list_set_date(\n      core_updater_list_entry_t *entry, const char *date_str)\n{\n   char *tok, *save;\n   char *elem0        = NULL;\n   char *elem1        = NULL;\n   char *elem2        = NULL;\n   unsigned list_size = 0;\n   char *date_str_cpy = NULL;\n\n   if (!entry || string_is_empty(date_str))\n      return false;\n\n   date_str_cpy = strdup(date_str);\n\n   /* Split date string into component values */\n   if ((tok = strtok_r(date_str_cpy, \"-\", &save)))\n   {\n      elem0 = strdup(tok);\n      list_size++;\n   }\n   if ((tok = strtok_r(NULL, \"-\", &save)))\n   {\n      elem1 = strdup(tok);\n      list_size++;\n   }\n   if ((tok = strtok_r(NULL, \"-\", &save)))\n   {\n      elem2 = strdup(tok);\n      list_size++;\n   }\n   free(date_str_cpy);\n\n   /* Date string must have 3 values:\n    * [year] [month] [day] */\n   if (list_size < 3)\n   {\n      if (elem0)\n         free(elem0);\n      if (elem1)\n         free(elem1);\n      if (elem2)\n         free(elem2);\n\n      return false;\n   }\n\n   /* Convert date string values */\n   entry->date.year  = string_to_unsigned(elem0);\n   entry->date.month = string_to_unsigned(elem1);\n   entry->date.day   = string_to_unsigned(elem2);\n\n   /* Clean up */\n   free(elem0);\n   free(elem1);\n   free(elem2);\n\n   return true;\n}\n\n/* Parses crc string and adds value to\n * specified core updater list entry */\nstatic bool core_updater_list_set_crc(\n      core_updater_list_entry_t *entry, const char *crc_str)\n{\n   uint32_t crc;\n\n   if (!entry || string_is_empty(crc_str))\n      return false;\n\n   if ((crc = (uint32_t)string_hex_to_unsigned(crc_str)) == 0)\n      return false;\n\n   entry->crc = crc;\n\n   return true;\n}\n\n/* Parses core filename string and adds all\n * associated paths to the specified core\n * updater list entry */\nstatic bool core_updater_list_set_paths(\n      core_updater_list_entry_t *entry,\n      const char *path_dir_libretro,\n      const char *path_libretro_info,\n      const char *network_buildbot_url,\n      const char *filename_str,\n      enum core_updater_list_type list_type)\n{\n   char *last_underscore                  = NULL;\n   char *tmp_url                          = NULL;\n   bool is_archive                        = true;\n   /* Can't resolve symlinks when dealing with cores\n    * installed via play feature delivery, because the\n    * source files have non-standard file names (which\n    * will not be recognised by regular core handling\n    * routines) */\n   char remote_core_path[PATH_MAX_LENGTH];\n   char local_core_path[PATH_MAX_LENGTH];\n   char local_info_path[PATH_MAX_LENGTH];\n   bool resolve_symlinks = (list_type != CORE_UPDATER_LIST_TYPE_PFD);\n\n   if (  !entry\n       || string_is_empty(filename_str)\n       || string_is_empty(path_dir_libretro)\n       || string_is_empty(path_libretro_info))\n      return false;\n\n   /* Only buildbot cores require the buildbot URL */\n   if ((list_type == CORE_UPDATER_LIST_TYPE_BUILDBOT) &&\n       string_is_empty(network_buildbot_url))\n      return false;\n\n   /* Check whether remote file is an archive */\n   is_archive = path_is_compressed_file(filename_str);\n\n   /* remote_filename */\n   if (entry->remote_filename)\n   {\n      free(entry->remote_filename);\n      entry->remote_filename = NULL;\n   }\n\n   entry->remote_filename = strdup(filename_str);\n\n   /* remote_core_path\n    * > Leave blank if this is not a buildbot core */\n   if (list_type == CORE_UPDATER_LIST_TYPE_BUILDBOT)\n   {\n      fill_pathname_join_special(\n            remote_core_path,\n            network_buildbot_url,\n            filename_str,\n            sizeof(remote_core_path));\n\n      /* > Apply proper URL encoding (messy...) */\n      tmp_url             = strdup(remote_core_path);\n      remote_core_path[0] = '\\0';\n      net_http_urlencode_full(\n            remote_core_path, tmp_url, sizeof(remote_core_path));\n      if (tmp_url)\n         free(tmp_url);\n   }\n\n   if (entry->remote_core_path)\n   {\n      free(entry->remote_core_path);\n      entry->remote_core_path = NULL;\n   }\n\n   entry->remote_core_path = strdup(remote_core_path);\n\n   fill_pathname_join_special(\n         local_core_path,\n         path_dir_libretro,\n         filename_str,\n         sizeof(local_core_path));\n\n   if (is_archive)\n      path_remove_extension(local_core_path);\n\n   path_resolve_realpath(local_core_path, sizeof(local_core_path),\n         resolve_symlinks);\n\n   if (entry->local_core_path)\n   {\n      free(entry->local_core_path);\n      entry->local_core_path = NULL;\n   }\n\n   entry->local_core_path = strdup(local_core_path);\n\n   fill_pathname_join_special(\n         local_info_path,\n         path_libretro_info,\n         filename_str,\n         sizeof(local_info_path));\n   path_remove_extension(local_info_path);\n\n   if (is_archive)\n      path_remove_extension(local_info_path);\n\n   /* > Remove any non-standard core filename\n    *   additions (i.e. info files end with\n    *   '_libretro' but core files may have\n    *   a platform specific addendum,\n    *   e.g. '_android')*/\n   last_underscore = (char*)strrchr(local_info_path, '_');\n\n   if (!string_is_empty(last_underscore))\n      if (!string_is_equal(last_underscore, \"_libretro\"))\n         *last_underscore = '\\0';\n\n   /* > Add proper file extension */\n   strlcat(\n         local_info_path,\n         FILE_PATH_CORE_INFO_EXTENSION,\n         sizeof(local_info_path));\n\n   if (entry->local_info_path)\n   {\n      free(entry->local_info_path);\n      entry->local_info_path = NULL;\n   }\n\n   entry->local_info_path = strdup(local_info_path);\n\n   return true;\n}\n\n/* Reads info file associated with core and\n * adds relevant information to updater list\n * entry */\nstatic bool core_updater_list_set_core_info(\n      core_updater_list_entry_t *entry,\n      const char *local_info_path,\n      const char *filename_str)\n{\n   core_updater_info_t *core_info = NULL;\n\n   if (  !entry\n       || string_is_empty(local_info_path)\n       || string_is_empty(filename_str))\n      return false;\n\n   /* Clear any existing core info */\n   if (entry->display_name)\n   {\n      free(entry->display_name);\n      entry->display_name = NULL;\n   }\n\n   if (entry->description)\n   {\n      free(entry->description);\n      entry->description = NULL;\n   }\n\n   if (entry->licenses_list)\n   {\n      /* Note: We can safely leave this as NULL if\n       * the core info file is invalid */\n      string_list_free(entry->licenses_list);\n      entry->licenses_list = NULL;\n   }\n\n   entry->is_experimental = false;\n\n   /* Read core info file\n    * > Note: It's a bit rubbish that we have to\n    *   read the actual core info files here...\n    *   Would be better to cache this globally\n    *   (at present, we only cache info for\n    *    *installed* cores...) */\n   if ((core_info = core_info_get_core_updater_info(local_info_path)))\n   {\n      /* display_name + is_experimental */\n      if (!string_is_empty(core_info->display_name))\n      {\n         entry->display_name    = strdup(core_info->display_name);\n         entry->is_experimental = core_info->is_experimental;\n      }\n      else\n      {\n         /* If display name is blank, use core filename and\n          * assume core is experimental (i.e. all 'fit for consumption'\n          * cores must have a valid/complete core info file) */\n         entry->display_name    = strdup(filename_str);\n         entry->is_experimental = true;\n      }\n\n      /* description */\n      if (!string_is_empty(core_info->description))\n         entry->description     = strdup(core_info->description);\n      else\n         entry->description     = strldup(\"\", sizeof(\"\"));\n\n      /* licenses_list */\n      if (!string_is_empty(core_info->licenses))\n         entry->licenses_list   = string_split(core_info->licenses, \"|\");\n\n      /* Clean up */\n      core_info_free_core_updater_info(core_info);\n   }\n   else\n   {\n      /* If info file is missing, use core filename and\n       * assume core is experimental (i.e. all 'fit for consumption'\n       * cores must have a valid/complete core info file) */\n      entry->display_name       = strdup(filename_str);\n      entry->is_experimental    = true;\n      entry->description        = strldup(\"\", sizeof(\"\"));\n   }\n\n   return true;\n}\n\n/* Adds entry to the end of the specified core\n * updater list\n * NOTE: Entry string values are passed by\n * reference - *do not free the entry passed\n * to this function* */\nstatic bool core_updater_list_push_entry(\n      core_updater_list_t *core_list, core_updater_list_entry_t *entry)\n{\n   core_updater_list_entry_t *list_entry = NULL;\n   size_t num_entries;\n\n   if (!core_list || !entry)\n      return false;\n\n   /* Get current number of list entries */\n   num_entries = RBUF_LEN(core_list->entries);\n\n   /* Attempt to allocate memory for new entry */\n   if (!RBUF_TRYFIT(core_list->entries, num_entries + 1))\n      return false;\n\n   /* Allocation successful - increment array size */\n   RBUF_RESIZE(core_list->entries, num_entries + 1);\n\n   /* Get handle of new entry at end of list, and\n    * zero-initialise members */\n   list_entry = &core_list->entries[num_entries];\n   memset(list_entry, 0, sizeof(*list_entry));\n\n   /* Assign paths */\n   list_entry->remote_filename  = entry->remote_filename;\n   list_entry->remote_core_path = entry->remote_core_path;\n   list_entry->local_core_path  = entry->local_core_path;\n   list_entry->local_info_path  = entry->local_info_path;\n\n   /* Assign core info */\n   list_entry->display_name     = entry->display_name;\n   list_entry->description      = entry->description;\n   list_entry->licenses_list    = entry->licenses_list;\n   list_entry->is_experimental  = entry->is_experimental;\n\n   /* Copy crc */\n   list_entry->crc              = entry->crc;\n\n   /* Copy date */\n   memcpy(&list_entry->date, &entry->date, sizeof(core_updater_list_date_t));\n\n   return true;\n}\n\n/* Parses the contents of a single buildbot\n * core listing and adds it to the specified\n * core updater list */\nstatic void core_updater_list_add_entry(\n      core_updater_list_t *core_list,\n      const char *path_dir_libretro,\n      const char *path_libretro_info,\n      const char *network_buildbot_url,\n      const char *date_str,\n      const char *crc_str,\n      const char *filename_str)\n{\n   const core_updater_list_entry_t *search_entry = NULL;\n   core_updater_list_entry_t entry               = {0};\n\n   /* Check whether core file is already included\n    * in the list (this is *not* an error condition,\n    * it just means we can skip the current listing) */\n   if (core_updater_list_get_filename(core_list,\n         filename_str, &search_entry))\n      goto error;\n\n   /* Parse individual listing strings */\n   if (!core_updater_list_set_date(&entry, date_str))\n      goto error;\n\n   if (!core_updater_list_set_crc(&entry, crc_str))\n      goto error;\n\n   if (!core_updater_list_set_paths(\n            &entry,\n            path_dir_libretro,\n            path_libretro_info,\n            network_buildbot_url,\n            filename_str,\n            CORE_UPDATER_LIST_TYPE_BUILDBOT))\n      goto error;\n\n   if (!core_updater_list_set_core_info(\n         &entry,\n         entry.local_info_path,\n         filename_str))\n      goto error;\n\n   /* Add entry to list */\n   if (!core_updater_list_push_entry(core_list, &entry))\n      goto error;\n\n   return;\n\nerror:\n   /* This is not a *fatal* error - it just\n    * means one of the following:\n    * - The current line of entry text received\n    *   from the buildbot is broken somehow\n    *   (could be the case that the network buffer\n    *    wasn't large enough to cache the entire\n    *    string, so the last line was truncated)\n    * - We had insufficient memory to allocate a new\n    *   entry in the core updater list\n    * In either case, the current entry is discarded\n    * and we move on to the next one\n    * (network transfers are fishy business, so we\n    * choose to ignore this sort of error - don't\n    * want the whole fetch to fail because of a\n    * trivial glitch...) */\n   core_updater_list_free_entry(&entry);\n}\n\n/* Core updater list qsort helper function */\nstatic int core_updater_list_qsort_func(\n      const core_updater_list_entry_t *a, const core_updater_list_entry_t *b)\n{\n   if (!a || !b)\n      return 0;\n\n   if (string_is_empty(a->display_name) || string_is_empty(b->display_name))\n      return 0;\n\n   return strcasecmp(a->display_name, b->display_name);\n}\n\n/* Sorts core updater list into alphabetical order */\nstatic void core_updater_list_qsort(core_updater_list_t *core_list)\n{\n   size_t num_entries;\n\n   if (!core_list)\n      return;\n   if ((num_entries = RBUF_LEN(core_list->entries)) < 2)\n      return;\n   if (core_list->entries)\n      qsort(\n         core_list->entries, num_entries,\n         sizeof(core_updater_list_entry_t),\n         (int (*)(const void *, const void *))\n               core_updater_list_qsort_func);\n}\n\n/* Reads the contents of a buildbot core list\n * network request into the specified\n * core_updater_list_t object.\n * Returns false in the event of an error. */\nbool core_updater_list_parse_network_data(\n      core_updater_list_t *core_list,\n      const char *path_dir_libretro,\n      const char *path_libretro_info,\n      const char *network_buildbot_url,\n      const char *data, size_t len)\n{\n   char *tok, *save;\n   unsigned list_size = 0;\n   char *data_buf     = NULL;\n\n   /* Sanity check */\n   if (!core_list || string_is_empty(data) || (len < 1))\n      return false;\n\n   /* We're populating a list 'from scratch' - remove\n    * any existing entries */\n   core_updater_list_reset(core_list);\n\n   /* Input data string is not terminated - have\n    * to copy it to a temporary buffer... */\n   if (!(data_buf = (char*)malloc((len + 1) * sizeof(char))))\n      return false;\n\n   memcpy(data_buf, data, len * sizeof(char));\n   data_buf[len] = '\\0';\n\n   list_size     = string_count_occurrences_single_character(data_buf, '\\n');\n\n   if (list_size < 1)\n   {\n      free(data_buf);\n      return false;\n   }\n\n   /* Split network listing request into lines */\n   /* Loop over lines */\n   for (tok = strtok_r(data_buf, \"\\n\", &save); tok;\n        tok = strtok_r(NULL, \"\\n\", &save))\n   {\n      char *tok2, *save2;\n      char *elem0      = NULL;\n      char *elem1      = NULL;\n      char *elem2      = NULL;\n      char *line_cpy   = NULL;\n      const char *line = tok;\n\n      if (string_is_empty(line))\n         continue;\n\n      line_cpy = strdup(line);\n\n      /* Split line into listings info components */\n      if ((tok2 = strtok_r(line_cpy, \" \", &save2)))\n         elem0 = strdup(tok2); /* date */\n      if ((tok2 = strtok_r(NULL, \" \", &save2)))\n         elem1 = strdup(tok2); /* crc  */\n      if ((tok2 = strtok_r(NULL, \" \", &save2)))\n         elem2 = strdup(tok2); /* filename */\n\n      free(line_cpy);\n\n      /* Parse listings info and add to core updater\n       * list */\n      /* > Listings must have 3 entries:\n       *   [date] [crc] [filename] */\n      if (     !string_is_empty(elem0)\n            && !string_is_empty(elem1)\n            && !string_is_empty(elem2))\n         core_updater_list_add_entry(\n               core_list,\n               path_dir_libretro,\n               path_libretro_info,\n               network_buildbot_url,\n               elem0, elem1, elem2);\n\n      /* Clean up */\n      free(elem0);\n      free(elem1);\n      free(elem2);\n   }\n\n   /* Temporary data buffer is no longer required */\n   free(data_buf);\n   data_buf = NULL;\n\n   /* Sanity check */\n   if (RBUF_LEN(core_list->entries) < 1)\n      return false;\n\n   /* Sort completed list */\n   core_updater_list_qsort(core_list);\n\n   /* Set list type */\n   core_list->type = CORE_UPDATER_LIST_TYPE_BUILDBOT;\n\n   return true;\n}\n\n/* Parses a single play feature delivery core\n * listing and adds it to the specified core\n * updater list */\nstatic void core_updater_list_add_pfd_entry(\n      core_updater_list_t *core_list,\n      const char *path_dir_libretro,\n      const char *path_libretro_info,\n      const char *filename_str)\n{\n   const core_updater_list_entry_t *search_entry = NULL;\n   core_updater_list_entry_t entry               = {0};\n\n   if (!core_list || string_is_empty(filename_str))\n      goto error;\n\n   /* Check whether core file is already included\n    * in the list (this is *not* an error condition,\n    * it just means we can skip the current listing) */\n   if (core_updater_list_get_filename(core_list,\n         filename_str, &search_entry))\n      goto error;\n\n   /* Note: Play feature delivery cores have no\n    * timestamp or CRC info - leave these fields\n    * zero initialised */\n\n   /* Populate entry fields */\n   if (!core_updater_list_set_paths(\n            &entry,\n            path_dir_libretro,\n            path_libretro_info,\n            NULL,\n            filename_str,\n            CORE_UPDATER_LIST_TYPE_PFD))\n      goto error;\n\n   if (!core_updater_list_set_core_info(\n         &entry,\n         entry.local_info_path,\n         filename_str))\n      goto error;\n\n   /* Add entry to list */\n   if (!core_updater_list_push_entry(core_list, &entry))\n      goto error;\n\n   return;\n\nerror:\n   /* This is not a *fatal* error - it just\n    * means one of the following:\n    * - The core listing entry obtained from the\n    *   play feature delivery interface is broken\n    *   somehow\n    * - We had insufficient memory to allocate a new\n    *   entry in the core updater list\n    * In either case, the current entry is discarded\n    * and we move on to the next one */\n   core_updater_list_free_entry(&entry);\n}\n\n/* Reads the list of cores currently available\n * via play feature delivery (PFD) into the\n * specified core_updater_list_t object.\n * Returns false in the event of an error. */\nbool core_updater_list_parse_pfd_data(\n      core_updater_list_t *core_list,\n      const char *path_dir_libretro,\n      const char *path_libretro_info,\n      const struct string_list *pfd_cores)\n{\n   size_t i;\n\n   /* Sanity check */\n   if (!core_list || !pfd_cores || (pfd_cores->size < 1))\n      return false;\n\n   /* We're populating a list 'from scratch' - remove\n    * any existing entries */\n   core_updater_list_reset(core_list);\n\n   /* Loop over play feature delivery core list */\n   for (i = 0; i < pfd_cores->size; i++)\n   {\n      const char *filename_str = pfd_cores->elems[i].data;\n\n      if (string_is_empty(filename_str))\n         continue;\n\n      /* Parse core file name and add to core\n       * updater list */\n      core_updater_list_add_pfd_entry(\n            core_list,\n            path_dir_libretro,\n            path_libretro_info,\n            filename_str);\n   }\n\n   /* Sanity check */\n   if (RBUF_LEN(core_list->entries) < 1)\n      return false;\n\n   /* Sort completed list */\n   core_updater_list_qsort(core_list);\n\n   /* Set list type */\n   core_list->type = CORE_UPDATER_LIST_TYPE_PFD;\n\n   return true;\n}\n"
        },
        {
          "name": "core_updater_list.h",
          "type": "blob",
          "size": 5.3544921875,
          "content": "/* Copyright  (C) 2010-2019 The RetroArch team\n *\n * ---------------------------------------------------------------------------------------\n * The following license statement only applies to this file (core_updater_list.h).\n * ---------------------------------------------------------------------------------------\n *\n * Permission is hereby granted, free of charge,\n * to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#ifndef __CORE_UPDATER_LIST_H\n#define __CORE_UPDATER_LIST_H\n\n#include <retro_common_api.h>\n#include <libretro.h>\n\n#include <lists/string_list.h>\n\n#include <boolean.h>\n\nRETRO_BEGIN_DECLS\n\n/* Defines all possible 'types' of core\n * updater list - corresponds to core\n * delivery method:\n * > Buildbot\n * > Play feature delivery (PFD) */\nenum core_updater_list_type\n{\n   CORE_UPDATER_LIST_TYPE_UNKNOWN = 0,\n   CORE_UPDATER_LIST_TYPE_BUILDBOT,\n   CORE_UPDATER_LIST_TYPE_PFD\n};\n\n/* Holds all date info for a core file\n * on the buildbot */\ntypedef struct\n{\n   unsigned year;\n   unsigned month;\n   unsigned day;\n} core_updater_list_date_t;\n\n/* Holds all info related to a core\n * file on the buildbot */\ntypedef struct\n{\n   char *remote_filename;\n   char *remote_core_path;\n   char *local_core_path;\n   char *local_info_path;\n   char *display_name;\n   char *description;\n   struct string_list *licenses_list;\n   core_updater_list_date_t date;   /* unsigned alignment */\n   uint32_t crc;\n   bool is_experimental;\n} core_updater_list_entry_t;\n\n/* Prevent direct access to core_updater_list_t\n * members */\ntypedef struct core_updater_list core_updater_list_t;\n\n/**************************************/\n/* Initialisation / De-Initialisation */\n/**************************************/\n\n/* Creates a new, empty core updater list.\n * Returns a handle to a new core_updater_list_t object\n * on success, otherwise returns NULL. */\ncore_updater_list_t *core_updater_list_init(void);\n\n/* Resets (removes all entries of) specified core\n * updater list */\nvoid core_updater_list_reset(core_updater_list_t *core_list);\n\n/* Frees specified core updater list */\nvoid core_updater_list_free(core_updater_list_t *core_list);\n\n/***************/\n/* Cached List */\n/***************/\n\n/* Creates a new, empty cached core updater list\n * (i.e. 'global' list).\n * Returns false in the event of an error. */\nbool core_updater_list_init_cached(void);\n\n/* Fetches cached core updater list */\ncore_updater_list_t *core_updater_list_get_cached(void);\n\n/* Frees cached core updater list */\nvoid core_updater_list_free_cached(void);\n\n/***********/\n/* Getters */\n/***********/\n\n/* Returns number of entries in core updater list */\nsize_t core_updater_list_size(core_updater_list_t *core_list);\n\n/* Returns 'type' (core delivery method) of\n * specified core updater list */\nenum core_updater_list_type core_updater_list_get_type(\n      core_updater_list_t *core_list);\n\n/* Fetches core updater list entry corresponding\n * to the specified entry index.\n * Returns false if index is invalid. */\nbool core_updater_list_get_index(\n      core_updater_list_t *core_list,\n      size_t idx,\n      const core_updater_list_entry_t **entry);\n\n/* Fetches core updater list entry corresponding\n * to the specified remote core filename.\n * Returns false if core is not found. */\nbool core_updater_list_get_filename(\n      core_updater_list_t *core_list,\n      const char *remote_filename,\n      const core_updater_list_entry_t **entry);\n\n/* Fetches core updater list entry corresponding\n * to the specified core.\n * Returns false if core is not found. */\nbool core_updater_list_get_core(\n      core_updater_list_t *core_list,\n      const char *local_core_path,\n      const core_updater_list_entry_t **entry);\n\n/***********/\n/* Setters */\n/***********/\n\n/* Reads the contents of a buildbot core list\n * network request into the specified\n * core_updater_list_t object.\n * Returns false in the event of an error. */\nbool core_updater_list_parse_network_data(\n      core_updater_list_t *core_list,\n      const char *path_dir_libretro,\n      const char *path_libretro_info,\n      const char *network_buildbot_url,\n      const char *data, size_t len);\n\n/* Reads the list of cores currently available\n * via play feature delivery (PFD) into the\n * specified core_updater_list_t object.\n * Returns false in the event of an error. */\nbool core_updater_list_parse_pfd_data(\n      core_updater_list_t *core_list,\n      const char *path_dir_libretro,\n      const char *path_libretro_info,\n      const struct string_list *pfd_cores);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "cores",
          "type": "tree",
          "content": null
        },
        {
          "name": "ctr",
          "type": "tree",
          "content": null
        },
        {
          "name": "database_info.c",
          "type": "blob",
          "size": 32.0078125,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdio.h>\n#include <stdint.h>\n\n#include <compat/strl.h>\n#include <retro_endianness.h>\n#include <file/file_path.h>\n#include <lists/string_list.h>\n#include <lists/dir_list.h>\n#include <string/stdstring.h>\n\n#include \"libretro-db/libretrodb.h\"\n\n#include \"core_info.h\"\n#include \"database_info.h\"\n\nint database_info_build_query_enum(char *s, size_t len,\n      enum database_query_type type,\n      const char *path)\n{\n   size_t _len = 0;\n\n   switch (type)\n   {\n      case DATABASE_QUERY_ENTRY:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'n';\n         s[++_len]  = 'a';\n         s[++_len]  = 'm';\n         s[++_len]  = 'e';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\"';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '\"';\n         s[++_len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_PUBLISHER:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'p';\n         s[++_len]  = 'u';\n         s[++_len]  = 'b';\n         s[++_len]  = 'l';\n         s[++_len]  = 'i';\n         s[++_len]  = 's';\n         s[++_len]  = 'h';\n         s[++_len]  = 'e';\n         s[++_len]  = 'r';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\"';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '\"';\n         s[++_len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_DEVELOPER:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'd';\n         s[++_len]  = 'e';\n         s[++_len]  = 'v';\n         s[++_len]  = 'e';\n         s[++_len]  = 'l';\n         s[++_len]  = 'o';\n         s[++_len]  = 'p';\n         s[++_len]  = 'e';\n         s[++_len]  = 'r';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = 'g';\n         s[++_len]  = 'l';\n         s[++_len]  = 'o';\n         s[++_len]  = 'b';\n         s[++_len]  = '(';\n         s[++_len]  = '\\'';\n         s[++_len]  = '*';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '*';\n         s[++_len]  = '\\'';\n         s[++_len]  = ')';\n         s[++_len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_ORIGIN:\n         s[  _len]  = '{';\n\t      s[++_len]  = '\\'';\n         s[++_len]  = 'o';\n         s[++_len]  = 'r';\n         s[++_len]  = 'i';\n         s[++_len]  = 'g';\n         s[++_len]  = 'i';\n         s[++_len]  = 'n';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\"';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '\"';\n         s[++_len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_FRANCHISE:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'f';\n         s[++_len]  = 'r';\n         s[++_len]  = 'a';\n         s[++_len]  = 'n';\n         s[++_len]  = 'c';\n         s[++_len]  = 'h';\n         s[++_len]  = 'i';\n         s[++_len]  = 's';\n         s[++_len]  = 'e';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\"';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '\"';\n         s[++_len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_RATING:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'e';\n         s[++_len]  = 's';\n         s[++_len]  = 'r';\n         s[++_len]  = 'b';\n         s[++_len]  = '_';\n         s[++_len]  = 'r';\n         s[++_len]  = 'a';\n         s[++_len]  = 't';\n         s[++_len]  = 'i';\n         s[++_len]  = 'n';\n         s[++_len]  = 'g';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\"';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '\"';\n         s[++_len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_BBFC_RATING:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'b';\n         s[++_len]  = 'b';\n         s[++_len]  = 'f';\n         s[++_len]  = 'c';\n         s[++_len]  = '_';\n         s[++_len]  = 'r';\n         s[++_len]  = 'a';\n         s[++_len]  = 't';\n         s[++_len]  = 'i';\n         s[++_len]  = 'n';\n         s[++_len]  = 'g';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\"';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[++_len]  = '\"';\n         s[++_len]  = '}';\n         s[++_len] = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_ELSPA_RATING:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'e';\n         s[++_len]  = 'l';\n         s[++_len]  = 's';\n         s[++_len]  = 'p';\n         s[++_len]  = 'a';\n         s[++_len]  = '_';\n         s[++_len]  = 'r';\n         s[++_len]  = 'a';\n         s[++_len]  = 't';\n         s[++_len]  = 'i';\n         s[++_len]  = 'n';\n         s[++_len]  = 'g';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\"';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '\"';\n         s[++_len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_ESRB_RATING:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'e';\n         s[++_len]  = 's';\n         s[++_len]  = 'r';\n         s[++_len]  = 'b';\n         s[++_len]  = '_';\n         s[++_len]  = 'r';\n         s[++_len]  = 'a';\n         s[++_len]  = 't';\n         s[++_len]  = 'i';\n         s[++_len]  = 'n';\n         s[++_len]  = 'g';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\"';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '\"';\n         s[++_len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_PEGI_RATING:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'p';\n         s[++_len]  = 'e';\n         s[++_len]  = 'g';\n         s[++_len]  = 'i';\n         s[++_len]  = '_';\n         s[++_len]  = 'r';\n         s[++_len]  = 'a';\n         s[++_len]  = 't';\n         s[++_len]  = 'i';\n         s[++_len]  = 'n';\n         s[++_len]  = 'g';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\"';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '\"';\n         s[++_len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_CERO_RATING:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'c';\n         s[++_len]  = 'e';\n         s[++_len]  = 'r';\n         s[++_len]  = 'o';\n         s[++_len]  = '_';\n         s[++_len]  = 'r';\n         s[++_len]  = 'a';\n         s[++_len]  = 't';\n         s[++_len]  = 'i';\n         s[++_len]  = 'n';\n         s[++_len]  = 'g';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\"';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '\"';\n         s[++_len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_ENHANCEMENT_HW:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'e';\n         s[++_len]  = 'n';\n         s[++_len]  = 'h';\n         s[++_len]  = 'a';\n         s[++_len]  = 'n';\n         s[++_len]  = 'c';\n         s[++_len]  = 'e';\n         s[++_len]  = 'm';\n         s[++_len]  = 'e';\n         s[++_len]  = 'n';\n         s[++_len]  = 't';\n         s[++_len]  = '_';\n         s[++_len]  = 'h';\n         s[++_len]  = 'w';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\"';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '\"';\n         s[++_len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_EDGE_MAGAZINE_RATING:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'e';\n         s[++_len]  = 'd';\n         s[++_len]  = 'g';\n         s[++_len]  = 'e';\n         s[++_len]  = '_';\n         s[++_len]  = 'r';\n         s[++_len]  = 'a';\n         s[++_len]  = 't';\n         s[++_len]  = 'i';\n         s[++_len]  = 'n';\n         s[++_len]  = 'g';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]   = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_EDGE_MAGAZINE_ISSUE:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'e';\n         s[++_len]  = 'd';\n         s[++_len]  = 'g';\n         s[++_len]  = 'e';\n         s[++_len]  = '_';\n         s[++_len]  = 'i';\n         s[++_len]  = 's';\n         s[++_len]  = 's';\n         s[++_len]  = 'u';\n         s[++_len]  = 'e';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_FAMITSU_MAGAZINE_RATING:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'f';\n         s[++_len]  = 'a';\n         s[++_len]  = 'm';\n         s[++_len]  = 'i';\n         s[++_len]  = 't';\n         s[++_len]  = 's';\n         s[++_len]  = 'u';\n         s[++_len]  = '_';\n         s[++_len]  = 'r';\n         s[++_len]  = 'a';\n         s[++_len]  = 't';\n         s[++_len]  = 'i';\n         s[++_len]  = 'n';\n         s[++_len]  = 'g';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_RELEASEDATE_MONTH:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'r';\n         s[++_len]  = 'e';\n         s[++_len]  = 'l';\n         s[++_len]  = 'e';\n         s[++_len]  = 'a';\n         s[++_len]  = 's';\n         s[++_len]  = 'e';\n         s[++_len]  = 'm';\n         s[++_len]  = 'o';\n         s[++_len]  = 'n';\n         s[++_len]  = 't';\n         s[++_len]  = 'h';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_RELEASEDATE_YEAR:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'r';\n         s[++_len]  = 'e';\n         s[++_len]  = 'l';\n         s[++_len]  = 'e';\n         s[++_len]  = 'a';\n         s[++_len]  = 's';\n         s[++_len]  = 'e';\n         s[++_len]  = 'y';\n         s[++_len]  = 'e';\n         s[++_len]  = 'a';\n         s[++_len]  = 'r';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_ENTRY_MAX_USERS:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = 'u';\n         s[++_len]  = 's';\n         s[++_len]  = 'e';\n         s[++_len]  = 'r';\n         s[++_len]  = 's';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n      case DATABASE_QUERY_NONE:\n         s[  _len]  = '{';\n         s[++_len]  = '\\'';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\\'';\n         s[++_len]  = ':';\n         s[++_len]  = '\"';\n         s[++_len]  = '\\0';\n         _len      += strlcpy(s + _len, path, len - _len);\n         s[  _len]  = '\"';\n         s[++_len]  = '}';\n         s[++_len]  = '\\0';\n         break;\n   }\n\n   return 0;\n}\n\n/*\n * NOTE: Allocates memory, it is the caller's responsibility to free the\n * memory after it is no longer required.\n */\nchar *bin_to_hex_alloc(const uint8_t *data, size_t len)\n{\n   size_t i;\n   char *ret = (char*)malloc(len * 2 + 1);\n\n   if (len && !ret)\n      return NULL;\n\n   for (i = 0; i < len; i++)\n      snprintf(ret+i * 2, 3, \"%02X\", data[i]);\n   return ret;\n}\n\nstatic int database_cursor_iterate(libretrodb_cursor_t *cur,\n      database_info_t *db_info)\n{\n   unsigned i;\n   struct rmsgpack_dom_value item;\n   const char* str                = NULL;\n\n   if (libretrodb_cursor_read_item(cur, &item) != 0)\n      return -1;\n\n   if (item.type != RDT_MAP)\n   {\n      rmsgpack_dom_value_free(&item);\n      return 1;\n   }\n\n   db_info->analog_supported       = -1;\n   db_info->rumble_supported       = -1;\n   db_info->coop_supported         = -1;\n\n   for (i = 0; i < item.val.map.len; i++)\n   {\n      struct rmsgpack_dom_value *key = &item.val.map.items[i].key;\n      struct rmsgpack_dom_value *val = &item.val.map.items[i].value;\n      const char *val_string         = NULL;\n\n      if (!key || !val)\n         continue;\n\n      val_string                     = val->val.string.buff;\n      str                            = key->val.string.buff;\n\n      if (string_is_equal(str, \"publisher\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->publisher = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"developer\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->developer = string_split(val_string, \"|\");\n      }\n      else if (string_is_equal(str, \"serial\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->serial = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"rom_name\"))\n      {\n/* rom_name is not used anywhere in codebase, but is frequently added to DB */\n#if 0\n         if (!string_is_empty(val_string))\n            db_info->rom_name = strdup(val_string);\n#endif\n      }\n      else if (string_is_equal(str, \"name\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->name = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"description\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->description = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"genre\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->genre = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"category\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->category = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"language\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->language = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"region\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->region = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"score\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->score = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"media\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->media = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"controls\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->controls = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"artstyle\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->artstyle = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"gameplay\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->gameplay = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"narrative\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->narrative = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"pacing\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->pacing = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"perspective\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->perspective = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"setting\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->setting = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"visual\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->visual = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"vehicular\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->vehicular = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"origin\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->origin = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"franchise\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->franchise = strdup(val_string);\n      }\n      else if (string_ends_with_size(str, \"_rating\",\n               strlen(str), STRLEN_CONST(\"_rating\")))\n      {\n         if (string_is_equal(str, \"bbfc_rating\"))\n         {\n            if (!string_is_empty(val_string))\n               db_info->bbfc_rating = strdup(val_string);\n         }\n         else if (string_is_equal(str, \"esrb_rating\"))\n         {\n            if (!string_is_empty(val_string))\n               db_info->esrb_rating = strdup(val_string);\n         }\n         else if (string_is_equal(str, \"elspa_rating\"))\n         {\n            if (!string_is_empty(val_string))\n               db_info->elspa_rating = strdup(val_string);\n         }\n         else if (string_is_equal(str, \"cero_rating\"))\n         {\n            if (!string_is_empty(val_string))\n               db_info->cero_rating          = strdup(val_string);\n         }\n         else if (string_is_equal(str, \"pegi_rating\"))\n         {\n            if (!string_is_empty(val_string))\n               db_info->pegi_rating          = strdup(val_string);\n         }\n         else if (string_is_equal(str, \"edge_rating\"))\n            db_info->edge_magazine_rating    = (unsigned)val->val.uint_;\n         else if (string_is_equal(str, \"famitsu_rating\"))\n            db_info->famitsu_magazine_rating = (unsigned)val->val.uint_;\n         else if (string_is_equal(str, \"tgdb_rating\"))\n            db_info->tgdb_rating             = (unsigned)val->val.uint_;\n      }\n      else if (string_is_equal(str, \"enhancement_hw\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->enhancement_hw       = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"edge_review\"))\n      {\n         if (!string_is_empty(val_string))\n            db_info->edge_magazine_review = strdup(val_string);\n      }\n      else if (string_is_equal(str, \"edge_issue\"))\n         db_info->edge_magazine_issue     = (unsigned)val->val.uint_;\n      else if (string_is_equal(str, \"users\"))\n         db_info->max_users               = (unsigned)val->val.uint_;\n      else if (string_is_equal(str, \"releasemonth\"))\n         db_info->releasemonth            = (unsigned)val->val.uint_;\n      else if (string_is_equal(str, \"releaseyear\"))\n         db_info->releaseyear             = (unsigned)val->val.uint_;\n      else if (string_is_equal(str, \"rumble\"))\n         db_info->rumble_supported        = (int)val->val.uint_;\n      else if (string_is_equal(str, \"achievements\"))\n         db_info->achievements            = (int)val->val.uint_;\n      else if (string_is_equal(str, \"console_exclusive\"))\n         db_info->console_exclusive       = (int)val->val.uint_;\n      else if (string_is_equal(str, \"platform_exclusive\"))\n         db_info->platform_exclusive      = (int)val->val.uint_;\n      else if (string_is_equal(str, \"coop\"))\n         db_info->coop_supported          = (int)val->val.uint_;\n      else if (string_is_equal(str, \"analog\"))\n         db_info->analog_supported        = (int)val->val.uint_;\n      else if (string_is_equal(str, \"size\"))\n         db_info->size                    = (unsigned)val->val.uint_;\n      else if (string_is_equal(str, \"crc\"))\n      {\n         switch (val->val.binary.len)\n         {\n            case 1:\n               db_info->crc32 = *(uint8_t*)val->val.binary.buff;\n               break;\n            case 2:\n               db_info->crc32 = swap_if_little16(*(uint16_t*)val->val.binary.buff);\n               break;\n            case 4:\n               db_info->crc32 = swap_if_little32(*(uint32_t*)val->val.binary.buff);\n               break;\n            default:\n               db_info->crc32 = 0;\n               break;\n         }\n      }\n      else if (string_is_equal(str, \"sha1\"))\n         db_info->sha1 = bin_to_hex_alloc(\n               (uint8_t*)val->val.binary.buff, val->val.binary.len);\n      else if (string_is_equal(str, \"md5\"))\n         db_info->md5 = bin_to_hex_alloc(\n               (uint8_t*)val->val.binary.buff, val->val.binary.len);\n   }\n\n   rmsgpack_dom_value_free(&item);\n\n   return 0;\n}\n\nstatic int database_cursor_open(libretrodb_t *db,\n      libretrodb_cursor_t *cur, const char *path, const char *query)\n{\n   const char *error     = NULL;\n   libretrodb_query_t *q = NULL;\n\n   if ((libretrodb_open(path, db, false)) != 0)\n      return -1;\n\n   if (query)\n      q = (libretrodb_query_t*)libretrodb_query_compile(db, query,\n      strlen(query), &error);\n\n   if (error)\n      goto error;\n   if ((libretrodb_cursor_open(db, cur, q)) != 0)\n      goto error;\n\n   if (q)\n      libretrodb_query_free(q);\n\n   return 0;\n\nerror:\n   if (q)\n      libretrodb_query_free(q);\n   libretrodb_close(db);\n\n   return -1;\n}\n\nstatic bool type_is_prioritized(const char *path)\n{\n   const char *ext = path_get_extension(path);\n   if (string_is_equal_noncase(ext, \"cue\"))\n      return true;\n   if (string_is_equal_noncase(ext, \"gdi\"))\n      return true;\n   return false;\n}\n\nstatic int dir_entry_compare(const void *left, const void *right)\n{\n   const struct string_list_elem *le = (const struct string_list_elem*)left;\n   const struct string_list_elem *re = (const struct string_list_elem*)right;\n   bool                            l = type_is_prioritized(le->data);\n   bool                            r = type_is_prioritized(re->data);\n\n   return (int) r - (int) l;\n}\n\ndatabase_info_handle_t *database_info_dir_init(const char *dir,\n      enum database_type type, retro_task_t *task,\n      bool show_hidden_files)\n{\n   core_info_list_t *core_info_list = NULL;\n   struct string_list       *list   = NULL;\n   database_info_handle_t     *db   = (database_info_handle_t*)\n      malloc(sizeof(*db));\n\n   if (!db)\n      return NULL;\n\n   core_info_get_list(&core_info_list);\n\n   if (!(list = dir_list_new(dir, core_info_list ? core_info_list->all_ext : NULL,\n         false, show_hidden_files,\n         false, true)))\n   {\n      free(db);\n      return NULL;\n   }\n\n   /* dir list prioritize */\n   qsort(list->elems, list->size, sizeof(*list->elems), dir_entry_compare);\n\n   db->status             = DATABASE_STATUS_ITERATE;\n   db->type               = type;\n   db->list_ptr           = 0;\n   db->list               = list;\n\n   return db;\n}\n\ndatabase_info_handle_t *database_info_file_init(const char *path,\n      enum database_type type, retro_task_t *task)\n{\n   union string_list_elem_attr attr;\n   struct string_list        *list  = NULL;\n   database_info_handle_t      *db  = (database_info_handle_t*)\n      malloc(sizeof(*db));\n\n   if (!db)\n      return NULL;\n\n   if (!(list = string_list_new()))\n   {\n      free(db);\n      return NULL;\n   }\n\n   attr.i                 = 0;\n   string_list_append(list, path, attr);\n\n   db->status             = DATABASE_STATUS_ITERATE;\n   db->type               = type;\n   db->list_ptr           = 0;\n   db->list               = list;\n\n   return db;\n}\n\nvoid database_info_free(database_info_handle_t *db)\n{\n   if (db)\n      string_list_free(db->list);\n}\n\ndatabase_info_list_t *database_info_list_new(\n      const char *rdb_path, const char *query)\n{\n   int ret                                  = 0;\n   unsigned k                               = 0;\n   database_info_t *database_info           = NULL;\n   database_info_list_t *database_info_list = NULL;\n   libretrodb_t *db                         = libretrodb_new();\n   libretrodb_cursor_t *cur                 = libretrodb_cursor_new();\n\n   if (!db || !cur)\n      goto end;\n\n   if ((database_cursor_open(db, cur, rdb_path, query) != 0))\n      goto end;\n\n   database_info_list = (database_info_list_t*)\n      malloc(sizeof(*database_info_list));\n\n   if (!database_info_list)\n      goto end;\n\n   database_info_list->count  = 0;\n   database_info_list->list   = NULL;\n\n   while (ret != -1)\n   {\n      database_info_t db_info = {0};\n      ret = database_cursor_iterate(cur, &db_info);\n\n      if (ret == 0)\n      {\n         database_info_t *db_ptr  = NULL;\n         database_info_t *new_ptr = (database_info_t*)\n            realloc(database_info, (k+1) * sizeof(database_info_t));\n\n         if (!new_ptr)\n         {\n            if (db_info.bbfc_rating)\n               free(db_info.bbfc_rating);\n            if (db_info.cero_rating)\n               free(db_info.cero_rating);\n            if (db_info.description)\n               free(db_info.description);\n            if (db_info.edge_magazine_review)\n               free(db_info.edge_magazine_review);\n            if (db_info.elspa_rating)\n               free(db_info.elspa_rating);\n            if (db_info.enhancement_hw)\n               free(db_info.enhancement_hw);\n            if (db_info.esrb_rating)\n               free(db_info.esrb_rating);\n            if (db_info.franchise)\n               free(db_info.franchise);\n            if (db_info.genre)\n               free(db_info.genre);\n            if (db_info.category)\n               free(db_info.category);\n            if (db_info.language)\n               free(db_info.language);\n            if (db_info.region)\n               free(db_info.region);\n            if (db_info.score)\n               free(db_info.score);\n            if (db_info.media)\n               free(db_info.media);\n            if (db_info.controls)\n               free(db_info.controls);\n            if (db_info.artstyle)\n               free(db_info.artstyle);\n            if (db_info.gameplay)\n               free(db_info.gameplay);\n            if (db_info.narrative)\n               free(db_info.narrative);\n            if (db_info.pacing)\n               free(db_info.pacing);\n            if (db_info.perspective)\n               free(db_info.perspective);\n            if (db_info.setting)\n               free(db_info.setting);\n            if (db_info.visual)\n               free(db_info.visual);\n            if (db_info.vehicular)\n               free(db_info.vehicular);\n            if (db_info.name)\n               free(db_info.name);\n            if (db_info.origin)\n               free(db_info.origin);\n            if (db_info.pegi_rating)\n               free(db_info.pegi_rating);\n            if (db_info.publisher)\n               free(db_info.publisher);\n            if (db_info.rom_name)\n               free(db_info.rom_name);\n            if (db_info.serial)\n               free(db_info.serial);\n            if (db_info.md5)\n               free(db_info.md5);\n            if (db_info.sha1)\n               free(db_info.sha1);\n\n            db_info.name                 = NULL;\n            db_info.rom_name             = NULL;\n            db_info.serial               = NULL;\n            db_info.genre                = NULL;\n            db_info.description          = NULL;\n            db_info.publisher            = NULL;\n            db_info.developer            = NULL;\n            db_info.origin               = NULL;\n            db_info.franchise            = NULL;\n            db_info.edge_magazine_review = NULL;\n            db_info.cero_rating          = NULL;\n            db_info.pegi_rating          = NULL;\n            db_info.enhancement_hw       = NULL;\n            db_info.elspa_rating         = NULL;\n            db_info.esrb_rating          = NULL;\n            db_info.bbfc_rating          = NULL; \n            db_info.sha1                 = NULL;\n            db_info.md5                  = NULL;\n\n            database_info_list_free(database_info_list);\n            free(database_info);\n            free(database_info_list);\n            database_info_list = NULL;\n            goto end;\n         }\n\n         database_info = new_ptr;\n         db_ptr        = &database_info[k];\n\n         memcpy(db_ptr, &db_info, sizeof(*db_ptr));\n\n         k++;\n      }\n   }\n\n   database_info_list->list  = database_info;\n   database_info_list->count = k;\n\nend:\n   if (db)\n   {\n      libretrodb_cursor_close(cur);\n      libretrodb_close(db);\n      libretrodb_free(db);\n   }\n   if (cur)\n      libretrodb_cursor_free(cur);\n\n   return database_info_list;\n}\n\nvoid database_info_list_free(database_info_list_t *database_info_list)\n{\n   size_t i;\n\n   if (!database_info_list)\n      return;\n\n   for (i = 0; i < database_info_list->count; i++)\n   {\n      database_info_t *info = &database_info_list->list[i];\n\n      if (info->name)\n         free(info->name);\n      if (info->rom_name)\n         free(info->rom_name);\n      if (info->serial)\n         free(info->serial);\n      if (info->genre)\n         free(info->genre);\n      if (info->category)\n         free(info->category);\n      if (info->language)\n         free(info->language);\n      if (info->region)\n         free(info->region);\n      if (info->score)\n         free(info->score);\n      if (info->media)\n         free(info->media);\n      if (info->controls)\n         free(info->controls);\n      if (info->artstyle)\n         free(info->artstyle);\n      if (info->gameplay)\n         free(info->gameplay);\n      if (info->narrative)\n         free(info->narrative);\n      if (info->pacing)\n         free(info->pacing);\n      if (info->perspective)\n         free(info->perspective);\n      if (info->setting)\n         free(info->setting);\n      if (info->visual)\n         free(info->visual);\n      if (info->vehicular)\n         free(info->vehicular);\n      if (info->description)\n         free(info->description);\n      if (info->publisher)\n         free(info->publisher);\n      if (info->developer)\n         string_list_free(info->developer);\n      if (info->origin)\n         free(info->origin);\n      if (info->franchise)\n         free(info->franchise);\n      if (info->edge_magazine_review)\n         free(info->edge_magazine_review);\n\n      if (info->cero_rating)\n         free(info->cero_rating);\n      if (info->pegi_rating)\n         free(info->pegi_rating);\n      if (info->enhancement_hw)\n         free(info->enhancement_hw);\n      if (info->elspa_rating)\n         free(info->elspa_rating);\n      if (info->esrb_rating)\n         free(info->esrb_rating);\n      if (info->bbfc_rating)\n         free(info->bbfc_rating);\n      if (info->sha1)\n         free(info->sha1);\n      if (info->md5)\n         free(info->md5);\n\n      info->name                 = NULL;\n      info->rom_name             = NULL;\n      info->serial               = NULL;\n      info->genre                = NULL;\n      info->description          = NULL;\n      info->publisher            = NULL;\n      info->developer            = NULL;\n      info->origin               = NULL;\n      info->franchise            = NULL;\n      info->edge_magazine_review = NULL;\n      info->cero_rating          = NULL;\n      info->pegi_rating          = NULL;\n      info->enhancement_hw       = NULL;\n      info->elspa_rating         = NULL;\n      info->esrb_rating          = NULL;\n      info->bbfc_rating          = NULL; \n      info->sha1                 = NULL;\n      info->md5                  = NULL;\n   }\n\n   free(database_info_list->list);\n}\n"
        },
        {
          "name": "database_info.h",
          "type": "blob",
          "size": 4.2138671875,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef DATABASE_INFO_H_\n#define DATABASE_INFO_H_\n\n#include <stdint.h>\n#include <stddef.h>\n\n#include <file/archive_file.h>\n#include <retro_common_api.h>\n#include <queues/task_queue.h>\n\nRETRO_BEGIN_DECLS\n\nenum database_status\n{\n   DATABASE_STATUS_NONE = 0,\n   DATABASE_STATUS_ITERATE,\n   DATABASE_STATUS_ITERATE_BEGIN,\n   DATABASE_STATUS_ITERATE_START,\n   DATABASE_STATUS_ITERATE_NEXT,\n   DATABASE_STATUS_FREE\n};\n\nenum database_type\n{\n   DATABASE_TYPE_NONE = 0,\n   DATABASE_TYPE_ITERATE,\n   DATABASE_TYPE_ITERATE_ARCHIVE,\n   DATABASE_TYPE_ITERATE_LUTRO,\n   DATABASE_TYPE_SERIAL_LOOKUP,\n   DATABASE_TYPE_CRC_LOOKUP\n};\n\nenum database_query_type\n{\n   DATABASE_QUERY_NONE = 0,\n   DATABASE_QUERY_ENTRY,\n   DATABASE_QUERY_ENTRY_PUBLISHER,\n   DATABASE_QUERY_ENTRY_DEVELOPER,\n   DATABASE_QUERY_ENTRY_ORIGIN,\n   DATABASE_QUERY_ENTRY_FRANCHISE,\n   DATABASE_QUERY_ENTRY_RATING,\n   DATABASE_QUERY_ENTRY_BBFC_RATING,\n   DATABASE_QUERY_ENTRY_ELSPA_RATING,\n   DATABASE_QUERY_ENTRY_ESRB_RATING,\n   DATABASE_QUERY_ENTRY_PEGI_RATING,\n   DATABASE_QUERY_ENTRY_CERO_RATING,\n   DATABASE_QUERY_ENTRY_ENHANCEMENT_HW,\n   DATABASE_QUERY_ENTRY_EDGE_MAGAZINE_RATING,\n   DATABASE_QUERY_ENTRY_EDGE_MAGAZINE_ISSUE,\n   DATABASE_QUERY_ENTRY_FAMITSU_MAGAZINE_RATING,\n   DATABASE_QUERY_ENTRY_RELEASEDATE_MONTH,\n   DATABASE_QUERY_ENTRY_RELEASEDATE_YEAR,\n   DATABASE_QUERY_ENTRY_MAX_USERS\n};\n\ntypedef struct\n{\n   struct string_list *list;\n   size_t list_ptr;\n   enum database_status status;\n   enum database_type type;\n} database_info_handle_t;\n\ntypedef struct\n{\n   char *name;\n   char *rom_name;\n   char *serial;\n   char *description;\n   char *genre;\n   char *category;\n   char *language;\n   char *region;\n   char *score;\n   char *media;\n   char *controls;\n   char *artstyle;\n   char *gameplay;\n   char *narrative;\n   char *pacing;\n   char *perspective;\n   char *setting;\n   char *visual;\n   char *vehicular;\n   char *publisher;\n   struct string_list *developer;\n   char *origin;\n   char *franchise;\n   char *edge_magazine_review;\n   char *bbfc_rating;\n   char *elspa_rating;\n   char *esrb_rating;\n   char *pegi_rating;\n   char *cero_rating;\n   char *enhancement_hw;\n   char *sha1;\n   char *md5;\n   void *userdata;\n   int achievements;\n   int console_exclusive;\n   int platform_exclusive;\n   int analog_supported;\n   int rumble_supported;\n   int coop_supported;\n   uint32_t crc32;\n   unsigned size;\n   unsigned famitsu_magazine_rating;\n   unsigned edge_magazine_rating;\n   unsigned edge_magazine_issue;\n   unsigned max_users;\n   unsigned releasemonth;\n   unsigned releaseyear;\n   unsigned tgdb_rating;\n} database_info_t;\n\ntypedef struct\n{\n   database_info_t *list;\n   size_t count;\n} database_info_list_t;\n\ndatabase_info_list_t *database_info_list_new(const char *rdb_path,\n      const char *query);\n\nvoid database_info_list_free(database_info_list_t *list);\n\ndatabase_info_handle_t *database_info_dir_init(const char *dir,\n      enum database_type type, retro_task_t *task,\n      bool show_hidden_files);\n\ndatabase_info_handle_t *database_info_file_init(const char *path,\n      enum database_type type, retro_task_t *task);\n\nvoid database_info_free(database_info_handle_t *handle);\n\nint database_info_build_query_enum(\n      char *query, size_t len, enum database_query_type type, const char *path);\n\n/* NOTE: Allocates memory, it is the caller's responsibility to free the\n * memory after it is no longer required. */\nchar *bin_to_hex_alloc(const uint8_t *data, size_t len);\n\nRETRO_END_DECLS\n\n#endif /* CORE_INFO_H_ */\n"
        },
        {
          "name": "default.txt",
          "type": "blob",
          "size": 14.2841796875,
          "content": "# 1.20.0\n- AUDIO: Fix audio handling in case of RARCH_NETPLAY_CTL_USE_CORE_PACKET_INTERFACE\n- AUDIO: Include missing audio filters on some platforms\n- AUDIO/PIPEWIRE: Add PipeWire audio driver\n- AUDIO/PIPEWIRE: Add PipeWire microphone driver\n- APPLE: Hide threaded video setting\n- APPLE: Use mfi joypad driver by default\n- APPLE: Include holani, noods, mrboom, yabause, bsnes-jg core in App Store builds\n- CHEEVOS: Add rarity and points to achievement unlock widget\n- CHEEVOS: Add rank to leaderboard submission notification\n- CHEEVOS: Update to rcheevos 11.5\n- CHEEVOS: Update to rcheevos 11.6\n- CHEEVOS: Show rcheevos game image in Discord rich presence\n- CHEEVOS: Use translated strings for achievement messages\n- CLOUDSYNC: Allow saves and configs to be synced optionally\n- CLOUDSYNC: Add iCloud cloud sync driver\n- CLOUDSYNC: Speed up by upload/download in parallel\n- CLOUDSYNC: Allow thumbnails and system dir to be synced optionally\n- CLOUDSYNC: Enable CloudSync on Android (non-SSL)\n- CLOUDSYNC: Add more logs in failure situations\n- CLOUDSYNC: Fixes for reauthentication and parallel sync\n- CLOUDSYNC: Fixes for file resurrection\n- CLOUDSYNC: Enable CloudSync on Windows\n- CRT/SWITCHRES: Update switchres to 2.2.1\n- GENERAL: Support for mbedtls v3\n- GENERAL: Automatic Frame Delay refactor\n- GENERAL: Remove Frame Rest, obsoleted by Frame Delay refactor\n- GENERAL: Wrap around auto increment save state indexes when amount of states is limited\n- GENERAL: Enable CHD hashing for Switch and DOS\n- GENERAL: Enable auto save state when new content is loaded\n- GENERAL: Improve Preemptive Frames when pointing device is used\n- GENERAL: Fix building with menu disabled\n- HAIKU: Restore Haiku build\n- INPUT: Allow to select a preferred/reserved device for each player\n- INPUT: Enable Caps, Num, Scroll Lock modifiers on multiple platforms\n- INPUT: Autoconfig extension with alternative name/vid/pid\n- INPUT: Fix autoconfig profile saving when device is not in the default port\n- INPUT: Change classic turbo mode to work independently of which key was pressed first\n- INPUT: Pointer and lightgun handling sanitization on Windows and Linux desktop platforms. These input drivers will now report edge and offscreen positions in a harmonized way, and will not return 0 instead.\n- INPUT/DINPUT: Fix detection of quick shift key presses\n- INPUT/HID: Fix crash on macOS when disconnecting the controller a second time\n- INPUT/LINUX: Add illuminance sensor support to the linuxraw, sdl2, udev, and x11 input drivers\n- INPUT/Remaps: Sort and apply remaps based on the specific connected controller\n- INPUT/UDEV: Enable mouse buttons 4 and 5\n- INPUT/WAYLAND: Enable horizontal scroll and mouse buttons 4 and 5\n- INPUT/WAYLAND: Simulate lightgun input for cores\n- INPUT/WAYLAND: Support for cursor-shape-v1 and content-type-v1 protocol\n- INPUT/X11: Enable mouse buttons 4 and 5\n- iOS: Enable vibration by default\n- iOS: Better handling of physical mice/magic keyboard trackpad\n- iOS: Mouse grab fixes\n- iOS: Fix mouse cursor movement when button is held down\n- iOS: Fix microphone support request and entitlement\n- iOS: Enable compilation back to iOS 12\n- iOS: Fix OpenGL ES context usage on iOS 9\n- iOS/TVOS: Add Opera to App Store build\n- iOS/TVOS: Bring NEON defines in line with ARM64\n- iOS/TVOS: Flush save files on backgrounding\n- LIBRETRO: Support RETRO_ENVIRONMENT_GET_FILE_BROWSER_START_DIRECTORY\n- LIBRETRO: Support \"/\" as a file extension for loading a directory as content\n- FFMPEG: Fix crash when playing back a file with 96 kHz audio\n- MACOS: New display server, including support for ProMotion 120Hz V-Sync\n- MACOS: Create App Store build\n- MACOS: Generate key up events for command keys\n- MIDI: Fix long messages (SysEx) in WinMM driver\n- MIDI: Fix lingering notes on close in Alsa driver\n- MENU: Support local thumbnails in other image formats than png (jpg/jpeg, bmp, tga)\n- MENU: Delete also savestate thumbnails when savestates are garbage collected\n- MENU: Option to disable analog stick menu navigation\n- MENU: Fix pause toggle to not clear fast forward state\n- MENU: Fix search playlist index in XMB/Ozone\n- MENU: Fix renamed entry display\n- MENU: Filter unknown extensions also inside zip files\n- MENU: Add icons for present / missing firmware on core info page\n- MENU: Ignore other hotkeys when menu toggle is pressed\n- MENU: Fix menu jumping when using L3+R3 combo\n- MENU: System Information now only shows features relevant for the platform\n- MENU/GLUI: Make Show Sublabels options effective\n- MENU/GLUI: Icon fixes\n- MENU/XMB: Allow playlist icons to be individually customized, by looking for images in Named_Logos\n- MENU/OZONE: Add Selenium theme for Ozone\n- MENU/OZONE: Touchscreen improvements\n- MENU/OZONE: Add a touch-sensitive Resume button in the lower right corner\n- NETPLAY: Add East Asian relay server\n- OVERLAY: Add option to load overlay based on system name\n- PS2: Fix several broken cores depending on pthread\n- QT: Enable building with Qt6\n- QT: Fix input panel\n- RECORDING: New WAV recording driver (audio only)\n- REMOTE RETROPAD: Add gyro/acceleration/light sensor test screen\n- REMOTE RETROPAD: Add pointer test screen\n- REPLAY: Replay format extended to support external tools\n- TVOS: Support bluetooth keyboards on tvOS\n- TVOS: Fixes to run correctly on TVOS13\n- TVOS: Better handling of Siri remote\n- TVOS: WebDAV server for adding files more easily\n- TVOS: Add Settings.app option to reset retroarch.cfg\n- TVOS: Bring minimum tvos version down to 13.0\n- VIDEO: Show and use exact refresh rate (3 decimals) and interlace/doublestrike where available\n- VIDEO: Allow setting viewport bias to offset viewport horizontally/vertically\n- VIDEO: Support viewport bias also with integer overscale and custom aspect ratios\n- VIDEO: Use shader path from CLI for shader cycling\n- VIDEO: Pixel perfect integer scaling improvements: axis options, smart mode\n- VIDEO: Add upscale 1.66x filter\n- VIDEO/D3D: Fix GPU screenshots\n- VIDEO/KMS: Force fullscreen when KMS is used\n- VIDEO/OpenGLES: Improve version directive granularity\n- VIDEO/SHADERS: Fix memory leak when shader parameter step is 0.0\n- VIDEO/SHADERS: Add 2 uniforms, OriginalAspect and OriginalAspectRot.\n- VIDEO/SHADERS: Add CoreFPS and FrameTimeDelta uniforms.\n- VIDEO/SLANG: Support optional includes\n- VIDEO/VULKAN: Fix Vulkan window freezes when swapchain becomes suboptimal\n- VIDEO/VULKAN: Prefer IMMEDIATE mode without vsync\n- VIDEO/X11: Support inhibit of Xss screensaver\n- VITA: Enable analog L2/R2 triggers when a DS3 controller is used with PS Vita\n- WAYLAND: Fix segfault when relative pointer is not supported\n- WAYLAND: Use reverse DNS name for desktop file and icon\n- WAYLAND: Commit viewport resizes for more responsive display when resizing window\n- WINDOWS: Fix restart if path to executable contains non-ASCII symbols\n- WINDOWS: Hide directories starting with $ from file browser\n\n# 1.19.1\n- Savestates: Revert savestate changes, was causing corruption and other issues\n\n# 1.19.0\n- AI: Revert AI translation to previous version (fix for translation not working with HW rendered cores)\n- APPLE: Try to use system preferred language\n- APPLE: Correctly register for filetypes uniquely\n- APPLE/MFI: improved Switch Online controller support through MFi\n- AUDIO: Bring back audio toggling on menu toggle\n- CHEEVOS: Build a default RetroAchievements memory map when no RetroAchievements game is loaded\n- CHEEVOS: Update to rcheevos 11.3\n- CHEEVOS: fix hardcore acting as if it's enabled when it isn't\n- CLANG: Fix clang error incompatible-pointer-types-discards-qualifiers\n- CLOUDSYNC/LINUX: Enable Cloud Sync by default on Linux builds with network (#16456)\n- CLOUDSYNC/WEBOS: Enable Cloud Sync by default on Linux builds with network (#16456)\n- CORE: Set compute fps stats logging to debug level\n- EMSCRIPTEN: Added M2000 to core selection dropdown\n- FFMPEG: Add compatibility with FFMPEG 7.0\n- GLSLANG: Remove unneeded ENABLE_HLSL code from glslang\n- GENERAL: Memory leak: Dynamic allocation from msg_hash_get_help_us_enum was not freed.\n- INPUT/KEYBOARD: Add support for multimedia keys - Extended RETROK_ values with 18 new items, commonly found on\n\"multimedia\" keyboards. Mapping added for SDL, X11, Wayland, dinput, winraw keymaps.\n- INPUT/MFI: Pressure sensitive left/right triggers\n- INPUT/MFI: Fix Start + L1/L2/R2 combinations\n- INPUT/MFI: Support strong and weak rumble\n- INTL: Fetch translations from Crowdin\n- INTL: Add Galician and Norwegian to list of languages\n- LAKKA: Display reboot/shutdown message also when not saving config on exit\n- LAKKA: Provide update URL and target name at buildtime\n- LIBRETRO: Add a debug message for the SET_ROTATION callback\n- macOS: Default Accessibility on if VoiceOver is on\n- iOS: default audio sync on again, also more mfi logging\n- iOS: Fix Import Content\n- iOS: Fix ios-arm64 nightly build crash\n- iOS: Import content from iCloud\n- iOS: Fix #16485 crash on startup\n- iOS: Display app icon in app icon picker in materialui\n- iOS/tvOS: Various QoL improvements\n- iOS/tvOS: Fix a couple more path name mangling bugs\n- iOS/tvOS: Better way of packaging Frameworks\n- iOS/tvOS: define PACKAGE_VERSION to be App Store MARKETING_VERSION\n- iOS/tvOS: Fix keyboard handling for app store builds\n- iOS/tvOS: Fix escaping the sandbox for jailbroken devices\n- iOS/tvOS: default accessibility on if voice over is enabled\n- iOS/tvOS: better way of reporting available memory\n- macOS/iOS/tvOS: enable text-to-speech using AVSpeechSynthesizer.\n- tvOS: Fix scaling for 720p\n- MENU: New function in Quick Menu: Add to Playlist\n- MENU/XMB: New theme: FlatUX, designed to merge FlatUI and Retroactive themes into a single, unified design\n- NETWORKING/RETROPAD CORE:  Fix socket close method\n- PIXMAN: Update pixman-private.h - patch to fix build issue with musl\n- PLAYLIST: Cleanup 'Add to Playlist' (#16495)\n- SCANNING: Fix for scanning PSP ISOs (and probably few others)\n- SAVES: Fix core config saving\n- SAVES: Fix save new config name when core loaded\n- SAVESTATES: Increase save state chunk size for all platforms - Even a class 6 or class 10 SD card can handle reads and writes on the order of MB/s, which means a 4KB chunk size is just wasting time in syscalls.  This could maybe be fixed with a buffering reader but I don't feel comfortable tweaking libretro-common's VFS to handle that.  Instead, I thought it would be good to both remove an ifdef and increase the chunk size to 128KB.  For cores with small states this will should make state saving virtually instantaneous, and for cores with large states it should be a 32x speedup.\n- VIDEO: Fix crash when using threaded video - for Mesa 23.2 and later\n- VIDEO/GL: Fix reinitialization of the threaded gl drivers\n- VIDEO/VULKAN: Add support for A2R10G10B10 HDR format\n- VIDEO/VULKAN: Implement HDR readback - screenshot support\n- WAYLAND: Ignore configure events during splash (fix not remembering window size)\n- WAYLAND: Use frontend signal handler to quit (fix quit by window close)\n- WAYLAND: Commit viewport resizes (window resize is more responsive)\n- UWP: Align MESA to alpha-2-resfix - Remove wrong resolution special handling for OPENGL\n- UWP: 4K fix: align MESA reading of ClientRect to retroarch procedure, this fixes max resolution being set to 1080p. As reading must be done inside an UI thread and is in fact an async operation which might delay frame generation, the reading itself is doen once and cached, give that changing resolution while the app is running is an unlikely corner-case use\n- WINDOWS: Windows mouse ungrab must release the mouse instead of confine it to the current desktop (#16488)\n- WINDOWS: Fix numlock/pause key release events\n\n# 1.18.0\n- AI: Fix narrator language when AI translation and menu languages are different\n- DISK CONTROL: Add option to disable initial disk change\n- DISK CONTROL: Visibility option for disk control notifications\n- DRM: Fix mode vrefresh calculation. When using an interlaced/doublescan mode, the vertical refresh rate is mis-calculated.\n- EMSCRIPTEN: Fix mouse Y parameter translation in rwebinput\n- INPUT: Fix input state combos including R3 and false triggers of RETROK_UNKNOWN\n- INPUT: Add a new turbo mode, \"Classic (Toggle)\"\n- INPUT: Fix bind hold when axis does not rest at 0\n- INPUT: Limit axis threshold setting to sensible values\n- INPUT: Add Overlay Mouse, Lightgun, and Pointer\n- INPUT/ANDROID: Fix mouse grab behavior on Android\n- INPUT/LINUXRAW: Fix device name and hotplug reconnect\n- IOS: Minor iOS JIT availability information\n- IOS/TVOS: Pause application on applicationWillResignActive\n- LIBRETRO: Add Doxygen-styled comments to parts of the libretro API\n- LUA: Update Lua to version 5.3.6\n- MENU: Add sublabels for input bind common entries\n- MENU: Don't load history and favorites if size is 0\n- MENU: Don't disable fast forward when entering menu\n- MENU: Widget position, size, color, icon adjustments\n- MENU: Fix savestate slots in Qt UI\n- MENU: Reorder and reduce depth of User Interface menu\n- MENU/OZONE: Fix sidebar wraparound, visibility after config load, crash after playlist delete\n- MENU/OZONE: Fix sidebar and sublabel animations\n- OSX/MACOS: Fix crash on non-Metal build\n- OSX/MACOS: Add portable.txt as flag for portable install\n- REMOTE RETROPAD: add display for analog axes, indication of inputs already pressed\n- SAVES: Allow combining saves in content dir with save sorting\n- SHADER: Added rolling scan line simulation based on the shader subframe feature. This is implemented with a scrolling scissor rect rather than in the shader itself as this is more efficient although may not work for every shader pass - we may need an option to exclude certain passes. The implementation simply divides the screen up by the number of sub frames and then moves the scissor rect down over the screen over the number of sub frames\n- TVOS: Force asset re-extraction when cache is deleted\n- TVOS: Add history and favorites to Top Shelf\n- TVOS: Fix crash when history item does not have a label\n- UWP: Enable HAVE_ACCESSIBILITY for UWP builds\n- UWP: Allow UWP build to work with a modified version of Mesa Gallium D3D12\n- VIDEO: Add subframe shader support for Vulkan/GLcore/DX10-11-12, enabling shaders to run at higher framerate than the content\n- VIDEO: Fix restoring fullscreen/windowed setting when unloading override\n- VIDEO/VULKAN: Fix HDR with Vulkan after reinit\n- VIDEO/VULKAN: Remove the use of oldSwapchain\n- VIDEO/GL2: Fix OpenGL ES version detection\n- WEBDAV: Fixed SEGFAULT in WebDav task sync + type changes\n- WEBOS: Fix build, add core location on webosbrew.org\n- WIN32: Fix Alt+Enter not working when menubar is disabled\n"
        },
        {
          "name": "defaults.h",
          "type": "blob",
          "size": 2.80859375,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __RARCH_DEFAULTS_H\n#define __RARCH_DEFAULTS_H\n\n#include <stdint.h>\n\n#include <boolean.h>\n\n#include <retro_miscellaneous.h>\n\n#ifndef IS_SALAMANDER\n#include \"playlist.h\"\n#endif\n\nenum default_dirs\n{\n   DEFAULT_DIR_MENU_CONTENT = 0,\n   DEFAULT_DIR_CORE_ASSETS,\n   DEFAULT_DIR_MENU_CONFIG,\n   DEFAULT_DIR_AUTOCONFIG,\n   DEFAULT_DIR_AUDIO_FILTER,\n   DEFAULT_DIR_VIDEO_FILTER,\n   DEFAULT_DIR_ASSETS,\n#ifdef _3DS\n   DEFAULT_DIR_BOTTOM_ASSETS,\n#endif\n   DEFAULT_DIR_CORE,\n   DEFAULT_DIR_CORE_INFO,\n   DEFAULT_DIR_OVERLAY,\n   DEFAULT_DIR_OSK_OVERLAY,\n   DEFAULT_DIR_PORT,\n   DEFAULT_DIR_SHADER,\n   DEFAULT_DIR_SAVESTATE,\n   DEFAULT_DIR_SRAM,\n   DEFAULT_DIR_SCREENSHOT,\n   DEFAULT_DIR_SYSTEM,\n   DEFAULT_DIR_PLAYLIST,\n   DEFAULT_DIR_CONTENT_FAVORITES,\n   DEFAULT_DIR_CONTENT_HISTORY,\n   DEFAULT_DIR_CONTENT_IMAGE_HISTORY,\n   DEFAULT_DIR_CONTENT_MUSIC_HISTORY,\n   DEFAULT_DIR_CONTENT_VIDEO_HISTORY,\n   DEFAULT_DIR_REMAP,\n   DEFAULT_DIR_CACHE,\n   DEFAULT_DIR_WALLPAPERS,\n   DEFAULT_DIR_THUMBNAILS,\n   DEFAULT_DIR_DATABASE,\n   DEFAULT_DIR_CHEATS,\n   DEFAULT_DIR_RECORD_CONFIG,\n   DEFAULT_DIR_RECORD_OUTPUT,\n   DEFAULT_DIR_LOGS,\n   DEFAULT_DIR_LAST\n};\n\nstruct defaults\n{\n#ifndef IS_SALAMANDER\n   playlist_t *content_history;\n   playlist_t *content_favorites;\n#ifdef HAVE_IMAGEVIEWER\n   playlist_t *image_history;\n#endif\n   playlist_t *music_history;\n#if defined(HAVE_FFMPEG) || defined(HAVE_MPV)\n   playlist_t *video_history;\n#endif\n#endif\n   int settings_out_latency;\n   int settings_in_latency;\n#ifdef HAVE_MENU\n   unsigned menu_materialui_menu_color_theme;\n#endif\n\n   float settings_video_refresh_rate;\n\n   char dirs [DEFAULT_DIR_LAST + 1][DIR_MAX_LENGTH];\n   char path_config[PATH_MAX_LENGTH];\n   char path_buildbot_server_url[NAME_MAX_LENGTH];\n   char settings_menu[32];\n\n#ifdef HAVE_MENU\n   bool menu_materialui_menu_color_theme_enable;\n   bool menu_controls_menu_btn_ok;\n   bool menu_controls_menu_btn_cancel;\n   bool menu_controls_set;\n#endif\n   bool overlay_set;\n   bool overlay_enable;\n};\n\nbool dir_set_defaults(enum default_dirs dir_type, const char *dirpath);\n\n/* Public data structures. */\nextern struct defaults g_defaults;\n\n#endif\n"
        },
        {
          "name": "deps",
          "type": "tree",
          "content": null
        },
        {
          "name": "dingux",
          "type": "tree",
          "content": null
        },
        {
          "name": "disk_control_interface.c",
          "type": "blob",
          "size": 25.056640625,
          "content": "/* Copyright  (C) 2010-2020 The RetroArch team\n *\n * ---------------------------------------------------------------------------------------\n * The following license statement only applies to this file (disk_control_interface.c).\n * ---------------------------------------------------------------------------------------\n *\n * Permission is hereby granted, free of charge,\n * to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <string/stdstring.h>\n#include <file/file_path.h>\n\n#include \"paths.h\"\n#include \"retroarch.h\"\n#include \"verbosity.h\"\n#include \"msg_hash.h\"\n\n#include \"disk_control_interface.h\"\n\n#ifdef HAVE_CHEEVOS\n#include \"cheevos/cheevos.h\"\n#endif\n\n/*****************/\n/* Configuration */\n/*****************/\n\n/**\n * disk_control_reset_callback:\n *\n * Sets all disk interface callback functions\n * to NULL\n **/\nstatic void disk_control_reset_callback(\n      disk_control_interface_t *disk_control)\n{\n   if (!disk_control)\n      return;\n\n   memset(&disk_control->cb, 0,\n         sizeof(struct retro_disk_control_ext_callback));\n}\n\n/**\n * disk_control_set_callback:\n *\n * Set v0 disk interface callback functions\n **/\nvoid disk_control_set_callback(\n      disk_control_interface_t *disk_control,\n      const struct retro_disk_control_callback *cb)\n{\n   if (!disk_control)\n      return;\n\n   disk_control_reset_callback(disk_control);\n\n   if (!cb)\n      return;\n\n   disk_control->cb.set_eject_state     = cb->set_eject_state;\n   disk_control->cb.get_eject_state     = cb->get_eject_state;\n   disk_control->cb.get_image_index     = cb->get_image_index;\n   disk_control->cb.set_image_index     = cb->set_image_index;\n   disk_control->cb.get_num_images      = cb->get_num_images;\n   disk_control->cb.replace_image_index = cb->replace_image_index;\n   disk_control->cb.add_image_index     = cb->add_image_index;\n}\n\n/**\n * disk_control_set_ext_callback:\n *\n * Set v1+ disk interface callback functions\n **/\nvoid disk_control_set_ext_callback(\n      disk_control_interface_t *disk_control,\n      const struct retro_disk_control_ext_callback *cb)\n{\n   if (!disk_control)\n      return;\n\n   disk_control_reset_callback(disk_control);\n\n   if (!cb)\n      return;\n\n   disk_control->cb.set_eject_state     = cb->set_eject_state;\n   disk_control->cb.get_eject_state     = cb->get_eject_state;\n   disk_control->cb.get_image_index     = cb->get_image_index;\n   disk_control->cb.set_image_index     = cb->set_image_index;\n   disk_control->cb.get_num_images      = cb->get_num_images;\n   disk_control->cb.replace_image_index = cb->replace_image_index;\n   disk_control->cb.add_image_index     = cb->add_image_index;\n\n   disk_control->cb.set_initial_image   = cb->set_initial_image;\n   disk_control->cb.get_image_path      = cb->get_image_path;\n   disk_control->cb.get_image_label     = cb->get_image_label;\n}\n\n/**********/\n/* Status */\n/**********/\n\n/**\n * disk_control_enabled:\n *\n * Leaf function.\n *\n * @return true if core supports basic disk control functionality\n * - set_eject_state\n * - get_eject_state\n * - get_image_index\n * - set_image_index\n * - get_num_images\n **/\nbool disk_control_enabled(\n      disk_control_interface_t *disk_control)\n{\n   if (     disk_control\n         && disk_control->cb.set_eject_state\n         && disk_control->cb.get_eject_state\n         && disk_control->cb.get_image_index\n         && disk_control->cb.set_image_index\n         && disk_control->cb.get_num_images)\n      return true;\n   return false;\n}\n\n/**\n * disk_control_append_enabled:\n *\n * Leaf function.\n *\n * @return true if core supports disk append functionality\n * - replace_image_index\n * - add_image_index\n **/\nbool disk_control_append_enabled(\n      disk_control_interface_t *disk_control)\n{\n   if (     disk_control\n         && disk_control->cb.replace_image_index\n         && disk_control->cb.add_image_index)\n      return true;\n   return false;\n}\n\n/**\n * disk_control_image_label_enabled:\n *\n * Leaf function.\n *\n * @return true if core supports image labels\n * - get_image_label\n **/\nbool disk_control_image_label_enabled(\n      disk_control_interface_t *disk_control)\n{\n   return disk_control && disk_control->cb.get_image_label;\n}\n\n/**\n * disk_control_initial_image_enabled:\n *\n * Leaf function.\n *\n * @return true if core supports setting initial disk index\n * - set_initial_image\n * - get_image_path\n **/\nbool disk_control_initial_image_enabled(\n      disk_control_interface_t *disk_control)\n{\n   if (     disk_control\n         && disk_control->cb.set_initial_image\n         && disk_control->cb.get_image_path)\n      return true;\n   return false;\n}\n\n/***********/\n/* Getters */\n/***********/\n\n/**\n * disk_control_get_eject_state:\n *\n * @return true if disk is currently ejected\n **/\nbool disk_control_get_eject_state(\n      disk_control_interface_t *disk_control)\n{\n   if (!disk_control || !disk_control->cb.get_eject_state)\n      return false;\n   return disk_control->cb.get_eject_state();\n}\n\n/**\n * disk_control_get_num_images:\n *\n * @return number of disk images registered by the core\n **/\nunsigned disk_control_get_num_images(\n      disk_control_interface_t *disk_control)\n{\n   if (!disk_control || !disk_control->cb.get_num_images)\n      return 0;\n   return disk_control->cb.get_num_images();\n}\n\n/**\n * disk_control_get_image_index:\n *\n * @return currently selected disk image index\n **/\nunsigned disk_control_get_image_index(\n      disk_control_interface_t *disk_control)\n{\n   if (!disk_control || !disk_control->cb.get_image_index)\n      return 0;\n   return disk_control->cb.get_image_index();\n}\n\n/**\n * disk_control_get_image_label:\n *\n * Fetches core-provided disk image label\n * (label is set to an empty string if core\n * does not support image labels)\n **/\nvoid disk_control_get_image_label(\n      disk_control_interface_t *disk_control,\n      unsigned index, char *label, size_t len)\n{\n   if (!label || len < 1)\n      return;\n\n   if (!disk_control)\n      goto error;\n\n   if (!disk_control->cb.get_image_label)\n      goto error;\n\n   if (!disk_control->cb.get_image_label(index, label, len))\n      goto error;\n\n   return;\n\nerror:\n   label[0] = '\\0';\n}\n\n/***********/\n/* Setters */\n/***********/\n\n/**\n * disk_control_get_index_set_msg:\n *\n * Generates an appropriate log/notification message\n * for a disk index change event\n **/\nstatic void disk_control_get_index_set_msg(\n      disk_control_interface_t *disk_control,\n      unsigned num_images, unsigned index, bool success,\n      unsigned *msg_duration, char *msg, size_t len)\n{\n   bool has_label = false;\n   char image_label[128];\n\n   image_label[0] = '\\0';\n\n   if (!disk_control || !msg_duration || !msg || len < 1)\n      return;\n\n   /* Attempt to get image label */\n   if (index < num_images)\n   {\n      disk_control_get_image_label(\n            disk_control, index, image_label, sizeof(image_label));\n      has_label = !string_is_empty(image_label);\n   }\n\n   /* Get message duration\n    * > Default is 60\n    * > If a label is shown, then increase duration by 50%\n    * > For errors, duration is always 180 */\n   *msg_duration = success ?\n         (has_label ? 90 : 60) :\n         180;\n\n   /* Check whether image was inserted or removed */\n   if (index < num_images)\n   {\n      size_t _len = strlcpy(msg,\n            success\n            ? msg_hash_to_str(MSG_SETTING_DISK_IN_TRAY)\n            : msg_hash_to_str(MSG_FAILED_TO_SET_DISK), len);\n      if (has_label)\n         snprintf(\n               msg + _len, len - _len, \": %u/%u - %s\",\n               index + 1, num_images, image_label);\n      else\n         snprintf(\n               msg + _len, len - _len, \": %u/%u\",\n               index + 1, num_images);\n   }\n   else\n      strlcpy(\n            msg,\n            success\n            ? msg_hash_to_str(MSG_REMOVED_DISK_FROM_TRAY)\n            : msg_hash_to_str(MSG_FAILED_TO_REMOVE_DISK_FROM_TRAY),\n            len);\n}\n\n/**\n * disk_control_set_eject_state:\n *\n * Sets the eject state of the virtual disk tray\n **/\nbool disk_control_set_eject_state(\n      disk_control_interface_t *disk_control,\n      bool eject, bool verbosity)\n{\n   bool error = false;\n   char msg[128];\n   size_t _len;\n\n   if (!disk_control || !disk_control->cb.set_eject_state)\n      return false;\n\n   /* Set eject state */\n   if (disk_control->cb.set_eject_state(eject))\n      _len  = strlcpy(\n            msg,\n            eject\n            ? msg_hash_to_str(MSG_DISK_EJECTED)\n            : msg_hash_to_str(MSG_DISK_CLOSED),\n              sizeof(msg));\n   else\n   {\n      error = true;\n      _len  = strlcpy(\n            msg,\n            eject\n            ? msg_hash_to_str(MSG_VIRTUAL_DISK_TRAY_EJECT)\n            : msg_hash_to_str(MSG_VIRTUAL_DISK_TRAY_CLOSE),\n              sizeof(msg));\n   }\n\n   if (_len > 0)\n   {\n      if (error)\n         RARCH_ERR(\"[Disc]: %s\\n\", msg);\n      else\n         RARCH_LOG(\"[Disc]: %s\\n\", msg);\n\n      /* Errors should always be displayed */\n      if (verbosity || error)\n         runloop_msg_queue_push(\n               msg, _len, 1, error ? 180 : 60, true, NULL,\n               MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n   }\n\n#ifdef HAVE_CHEEVOS\n   if (!error && !eject)\n   {\n      if (disk_control->cb.get_image_index && disk_control->cb.get_image_path)\n      {\n         char image_path[PATH_MAX_LENGTH] = \"\";\n         unsigned image_index = disk_control->cb.get_image_index();\n\n         if (disk_control->cb.get_image_path(image_index, image_path, sizeof(image_path)))\n            rcheevos_change_disc(image_path, false);\n      }\n   }\n#endif\n\n   return !error;\n}\n\n/**\n * disk_control_set_index:\n *\n * Sets currently selected disk index\n *\n * NOTE: Will fail if disk is not currently ejected\n **/\nbool disk_control_set_index(\n      disk_control_interface_t *disk_control,\n      unsigned index, bool verbosity)\n{\n   bool error            = false;\n   unsigned num_images   = 0;\n   unsigned msg_duration = 0;\n   char msg[128];\n\n   msg[0] = '\\0';\n\n   if (!disk_control)\n      return false;\n\n   if (   !disk_control->cb.get_eject_state\n       || !disk_control->cb.get_num_images\n       || !disk_control->cb.set_image_index)\n      return false;\n\n   /* Ensure that disk is currently ejected */\n   if (!disk_control->cb.get_eject_state())\n      return false;\n\n   /* Get current number of disk images */\n   num_images = disk_control->cb.get_num_images();\n\n   /* Perform 'set index' action */\n   error = !disk_control->cb.set_image_index(index);\n\n   /* Get log/notification message */\n   disk_control_get_index_set_msg(\n         disk_control, num_images, index, !error,\n         &msg_duration, msg, sizeof(msg));\n\n   /* Output log/notification message */\n   if (!string_is_empty(msg))\n   {\n      if (error)\n         RARCH_ERR(\"[Disc]: %s\\n\", msg);\n      else\n         RARCH_LOG(\"[Disc]: %s\\n\", msg);\n\n      /* Errors should always be displayed */\n      if (verbosity || error)\n         runloop_msg_queue_push(msg, strlen(msg), 1, msg_duration, true, NULL,\n               MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n   }\n\n   /* If operation was successful, update disk\n    * index record (if enabled) */\n   if (!error && disk_control->record_enabled)\n   {\n      if (   disk_control->cb.get_image_index\n          && disk_control->cb.get_image_path)\n      {\n         char new_image_path[PATH_MAX_LENGTH] = {0};\n         /* Get current image index + path */\n         unsigned new_image_index = disk_control->cb.get_image_index();\n         bool image_path_valid    = disk_control->cb.get_image_path(\n               new_image_index, new_image_path, sizeof(new_image_path));\n\n         if (image_path_valid)\n            disk_index_file_set(\n                  &disk_control->index_record,\n                  new_image_index, new_image_path);\n         else\n            disk_index_file_set(\n                  &disk_control->index_record, 0, NULL);\n      }\n   }\n\n   return !error;\n}\n\n/**\n * disk_control_set_index_next:\n *\n * Increments selected disk index\n **/\nbool disk_control_set_index_next(\n      disk_control_interface_t *disk_control,\n      bool verbosity)\n{\n   unsigned num_images   = 0;\n   unsigned image_index  = 0;\n   bool disk_next_enable = false;\n\n   if (!disk_control)\n      return false;\n\n   if (   !disk_control->cb.get_num_images\n       || !disk_control->cb.get_image_index)\n      return false;\n\n   num_images  = disk_control->cb.get_num_images();\n   image_index = disk_control->cb.get_image_index();\n\n   /* Would seem more sensible to check (num_images > 1)\n    * here, but seems we need to be able to cycle the\n    * same image for legacy reasons... */\n   disk_next_enable = (num_images > 0) && (num_images != UINT_MAX);\n\n   if (!disk_next_enable)\n   {\n      RARCH_ERR(\"[Disc]: %s\\n\", msg_hash_to_str(MSG_GOT_INVALID_DISK_INDEX));\n      return false;\n   }\n\n   if (image_index < (num_images - 1))\n      image_index++;\n\n   return disk_control_set_index(disk_control, image_index, verbosity);\n}\n\n/**\n * disk_control_set_index_prev:\n *\n * Decrements selected disk index\n **/\nbool disk_control_set_index_prev(\n      disk_control_interface_t *disk_control,\n      bool verbosity)\n{\n   unsigned num_images   = 0;\n   unsigned image_index  = 0;\n   bool disk_prev_enable = false;\n\n   if (!disk_control)\n      return false;\n\n   if (   !disk_control->cb.get_num_images\n       || !disk_control->cb.get_image_index)\n      return false;\n\n   num_images       = disk_control->cb.get_num_images();\n   image_index      = disk_control->cb.get_image_index();\n   /* Would seem more sensible to check (num_images > 1)\n    * here, but seems we need to be able to cycle the\n    * same image for legacy reasons... */\n   disk_prev_enable = (num_images > 0);\n\n   if (!disk_prev_enable)\n   {\n      RARCH_ERR(\"[Disc]: %s\\n\", msg_hash_to_str(MSG_GOT_INVALID_DISK_INDEX));\n      return false;\n   }\n\n   if (image_index > 0)\n      image_index--;\n\n   return disk_control_set_index(disk_control, image_index, verbosity);\n}\n\n/**\n * disk_control_append_image:\n *\n * Appends specified image file to disk image list\n **/\nbool disk_control_append_image(\n      disk_control_interface_t *disk_control,\n      const char *image_path)\n{\n   size_t _len;\n   bool initial_disk_ejected   = false;\n   unsigned initial_index      = 0;\n   unsigned new_index          = 0;\n   const char *image_filename  = NULL;\n   struct retro_game_info info = {0};\n   char msg[128];\n\n   /* Sanity check. If any of these fail then a\n    * frontend error has occurred - we will not\n    * deal with that here */\n   if (!disk_control)\n      return false;\n\n   if (   !disk_control->cb.get_image_index\n       || !disk_control->cb.get_num_images\n       || !disk_control->cb.add_image_index\n       || !disk_control->cb.replace_image_index\n       || !disk_control->cb.get_eject_state)\n      return false;\n\n   if (string_is_empty(image_path))\n      return false;\n\n   image_filename = path_basename(image_path);\n\n   if (string_is_empty(image_filename))\n      return false;\n\n   /* Get initial disk eject state */\n   initial_disk_ejected = disk_control_get_eject_state(disk_control);\n\n   /* Cache initial image index */\n   initial_index        = disk_control->cb.get_image_index();\n\n   /* If tray is currently closed, eject disk */\n   if (!initial_disk_ejected &&\n       !disk_control_set_eject_state(disk_control, true, false))\n      goto error;\n\n   /* Append image */\n   if (!disk_control->cb.add_image_index())\n      goto error;\n\n   if ((new_index = disk_control->cb.get_num_images()) < 1)\n      goto error;\n   new_index--;\n\n   info.path = image_path;\n   if (!disk_control->cb.replace_image_index(new_index, &info))\n      goto error;\n\n   /* Set new index */\n   if (!disk_control_set_index(disk_control, new_index, false))\n      goto error;\n\n   /* If tray was initially closed, insert disk\n    * (i.e. leave system in the state we found it) */\n   if (   !initial_disk_ejected\n       && !disk_control_set_eject_state(disk_control, false, false))\n      goto error;\n\n   /* Display log */\n   _len        = strlcpy(msg, msg_hash_to_str(MSG_APPENDED_DISK), sizeof(msg));\n   msg[  _len] = ':';\n   msg[++_len] = ' ';\n   msg[++_len] = '\\0';\n   _len += strlcpy(msg + _len, image_filename, sizeof(msg) - _len);\n\n   RARCH_LOG(\"[Disc]: %s\\n\", msg);\n   /* This message should always be displayed, since\n    * the menu itself does not provide sufficient\n    * visual feedback */\n   runloop_msg_queue_push(msg, _len, 0, 120, true, NULL,\n         MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n   return true;\n\nerror:\n   /* If we reach this point then everything is\n    * broken and the disk control interface is\n    * in an undefined state. Try to restore some\n    * sanity by reinserting the original disk...\n    * NOTE: If this fails then it's game over -\n    * just display the error notification and\n    * hope for the best... */\n   if (!disk_control->cb.get_eject_state())\n      disk_control_set_eject_state(disk_control, true, false);\n   disk_control_set_index(disk_control, initial_index, false);\n   if (!initial_disk_ejected)\n      disk_control_set_eject_state(disk_control, false, false);\n\n   _len        = strlcpy(msg,\n         msg_hash_to_str(MSG_FAILED_TO_APPEND_DISK), sizeof(msg));\n   msg[  _len] = ':';\n   msg[++_len] = ' ';\n   msg[++_len] = '\\0';\n   _len += strlcpy(msg + _len, image_filename, sizeof(msg) - _len);\n\n   runloop_msg_queue_push(msg, _len, 0, 180, true, NULL,\n         MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n   return false;\n}\n\n/*****************************/\n/* 'Initial index' functions */\n/*****************************/\n\n/**\n * disk_control_set_initial_index:\n *\n * Attempts to set current core's initial disk index.\n * > disk_control->record_enabled will be set to\n *   'false' if core does not support initial\n *   index functionality\n * > disk_control->index_record will be loaded\n *   from file (if an existing record is found)\n * NOTE: Must be called immediately before\n * loading content\n **/\nbool disk_control_set_initial_index(\n      disk_control_interface_t *disk_control,\n      const char *content_path,\n      const char *dir_savefile)\n{\n   if (!disk_control)\n      return false;\n\n   if (string_is_empty(content_path))\n      goto error;\n\n   /* Check that 'initial index' functionality is enabled */\n   if (   !disk_control->cb.set_initial_image\n       || !disk_control->cb.get_num_images\n       || !disk_control->cb.get_image_index\n       || !disk_control->cb.get_image_path)\n      goto error;\n\n   /* Attempt to initialise disk index record (reading\n    * from disk, if file exists) */\n   disk_control->record_enabled = disk_index_file_init(\n         &disk_control->index_record,\n         content_path, dir_savefile);\n\n   /* If record is enabled and initial index is *not*\n    * zero, notify current core */\n   if (    disk_control->record_enabled\n       && (disk_control->index_record.image_index != 0))\n   {\n      if ( !disk_control->cb.set_initial_image(\n            disk_control->index_record.image_index,\n            disk_control->index_record.image_path))\n      {\n         /* Note: We don't bother with an on-screen\n          * notification at this stage, since an error\n          * here may not matter (have to wait until\n          * disk index is verified) */\n         RARCH_ERR(\n               \"[Disc]: Failed to set initial disk index: [%u] %s\\n\",\n               disk_control->index_record.image_index,\n               disk_control->index_record.image_path);\n         return false;\n      }\n   }\n\n   return true;\n\nerror:\n   disk_control->record_enabled = false;\n   return false;\n}\n\n/**\n * disk_control_verify_initial_index:\n *\n * Checks that initial index has been set correctly\n * and provides user notification.\n * > Sets disk_control->initial_num_images if\n *   if functionality is supported by core\n * NOTE: Must be called immediately after\n * loading content\n **/\nbool disk_control_verify_initial_index(\n      disk_control_interface_t *disk_control,\n      bool verbosity,\n      bool enabled)\n{\n   bool success         = false;\n   unsigned image_index = 0;\n   char image_path[PATH_MAX_LENGTH];\n\n   image_path[0] = '\\0';\n\n   if (!disk_control)\n      return false;\n\n   /* If index record is disabled, can return immediately */\n   if (!disk_control->record_enabled && enabled)\n      return false;\n\n   /* Check that 'initial index' functionality is enabled */\n   if (   !disk_control->cb.set_initial_image\n       || !disk_control->cb.get_num_images\n       || !disk_control->cb.get_image_index\n       || !disk_control->cb.get_image_path)\n      return false;\n\n   /* Cache initial number of images\n    * (required for error checking when saving\n    * disk index file) */\n   disk_control->initial_num_images =\n         disk_control->cb.get_num_images();\n\n   /* Get current image index + path */\n   image_index = disk_control->cb.get_image_index();\n\n   if (disk_control->cb.get_image_path(\n         image_index, image_path, sizeof(image_path)))\n   {\n      /* Check whether index + path match set\n       * values\n       * > Note that if set index was zero and\n       *   set path was empty, we ignore the path\n       *   read here (since this corresponds to a\n       *   'first run', where no existing disk index\n       *   file was present) */\n      if (   (image_index == disk_control->index_record.image_index)\n          && (string_is_equal(image_path, disk_control->index_record.image_path)\n          ||   ((disk_control->index_record.image_index == 0)\n          &&  string_is_empty(disk_control->index_record.image_path))))\n         success = true;\n   }\n\n   /* If current disk is incorrect, notify user */\n   if (!success && enabled)\n   {\n      const char *_msg = msg_hash_to_str(MSG_FAILED_TO_SET_INITIAL_DISK);\n      RARCH_ERR(\n               \"[Disc]: Failed to set initial disc index:\\n> Expected\"\n               \" [%u] %s\\n> Detected [%u] %s\\n\",\n               disk_control->index_record.image_index + 1,\n               disk_control->index_record.image_path,\n               image_index + 1,\n               image_path);\n\n      /* Ignore 'verbosity' setting - errors should\n       * always be displayed */\n      runloop_msg_queue_push(_msg, strlen(_msg), 0, 60, true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n      /* Since a failure here typically means that the\n       * original M3U content file has been altered,\n       * any existing disk index record file will be\n       * invalid. We therefore 'reset' and save the disk\n       * index record to prevent a repeat of the error on\n       * the next run */\n      disk_index_file_set(&disk_control->index_record, 0, NULL);\n      disk_index_file_save(&disk_control->index_record);\n   }\n\n   /* If current disk is correct and recorded image\n    * path is empty (i.e. first run), need to register\n    * current image path */\n   else if (string_is_empty(disk_control->index_record.image_path))\n      disk_index_file_set(\n            &disk_control->index_record, image_index, image_path);\n\n   /* Regardless of success/failure, notify user of\n    * current disk index *if* more than one disk\n    * is available */\n   if (disk_control->initial_num_images > 1)\n   {\n      unsigned msg_duration = 0;\n      char msg[128];\n\n      msg[0] = '\\0';\n\n      disk_control_get_index_set_msg(\n            disk_control, disk_control->initial_num_images, image_index, true,\n            &msg_duration, msg, sizeof(msg));\n\n      RARCH_LOG(\"[Disc]: %s\\n\", msg);\n\n      /* Note: Do not flush message queue here, since\n       * it is likely other notifications will be\n       * generated before setting the disk index, and\n       * we do not want to 'overwrite' them */\n      if (verbosity)\n         runloop_msg_queue_push(\n               msg, strlen(msg), 0, msg_duration, false, NULL,\n               MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n#ifdef HAVE_CHEEVOS\n      if (image_index > 0)\n         rcheevos_change_disc(disk_control->index_record.image_path, true);\n#endif\n   }\n\n   return success;\n}\n\n/**\n * disk_control_save_image_index:\n *\n * Saves current disk index to file, if supported\n * by current core\n **/\nbool disk_control_save_image_index(\n      disk_control_interface_t *disk_control)\n{\n   if (!disk_control)\n      return false;\n\n   /* If index record is disabled, can return immediately */\n   if (!disk_control->record_enabled)\n      return false;\n\n   /* If core started with less than two disks,\n    * then a disk index record is unnecessary */\n   if (disk_control->initial_num_images < 2)\n      return false;\n\n   /* If current index is greater than initial\n    * number of disks then user has appended a\n    * disk and it is currently active. This setup\n    * *cannot* be restored, so cancel the file save */\n   if (disk_control->index_record.image_index >=\n         disk_control->initial_num_images)\n      return false;\n\n   /* Save record */\n   return disk_index_file_save(&disk_control->index_record);\n}\n"
        },
        {
          "name": "disk_control_interface.h",
          "type": "blob",
          "size": 6.5361328125,
          "content": "/* Copyright  (C) 2010-2020 The RetroArch team\n *\n * ---------------------------------------------------------------------------------------\n * The following license statement only applies to this file (disk_control_interface.h).\n * ---------------------------------------------------------------------------------------\n *\n * Permission is hereby granted, free of charge,\n * to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#ifndef __DISK_CONTROL_INTERFACE_H\n#define __DISK_CONTROL_INTERFACE_H\n\n#include <retro_common_api.h>\n#include <libretro.h>\n\n#include <boolean.h>\n\n#include \"disk_index_file.h\"\n\nRETRO_BEGIN_DECLS\n\n/* Holds all objects to operate the disk\n * control interface */\ntypedef struct\n{\n   struct retro_disk_control_ext_callback cb; /* ptr alignment */\n   disk_index_file_t index_record;            /* unsigned alignment */\n   unsigned initial_num_images;\n   bool record_enabled;\n} disk_control_interface_t;\n\n/*****************/\n/* Configuration */\n/*****************/\n\n/**\n * disk_control_set_callback:\n *\n * Set v0 disk interface callback functions\n **/\nvoid disk_control_set_callback(\n      disk_control_interface_t *disk_control,\n      const struct retro_disk_control_callback *cb);\n\n/**\n * disk_control_set_ext_callback:\n *\n * Set v1+ disk interface callback functions\n **/\nvoid disk_control_set_ext_callback(\n      disk_control_interface_t *disk_control,\n      const struct retro_disk_control_ext_callback *cb);\n\n/**********/\n/* Status */\n/**********/\n\n/**\n * disk_control_enabled:\n *\n * Leaf function.\n *\n * @return true if core supports basic disk control functionality\n * - set_eject_state\n * - get_eject_state\n * - get_image_index\n * - set_image_index\n * - get_num_images\n **/\nbool disk_control_enabled(\n      disk_control_interface_t *disk_control);\n\n/**\n * disk_control_append_enabled:\n *\n * Leaf function.\n *\n * @return true if core supports disk append functionality\n * - replace_image_index\n * - add_image_index\n **/\nbool disk_control_append_enabled(\n      disk_control_interface_t *disk_control);\n\n/**\n * disk_control_image_label_enabled:\n *\n * Leaf function.\n *\n * @return true if core supports image labels \n * - get_image_label\n **/\nbool disk_control_image_label_enabled(\n      disk_control_interface_t *disk_control);\n\n/**\n * disk_control_initial_image_enabled:\n *\n * Leaf function.\n *\n * @return true if core supports setting initial disk index\n * - set_initial_image\n * - get_image_path\n **/\nbool disk_control_initial_image_enabled(\n      disk_control_interface_t *disk_control);\n\n/***********/\n/* Getters */\n/***********/\n\n/**\n * disk_control_get_eject_state:\n *\n * @return true if disk is currently ejected\n **/\nbool disk_control_get_eject_state(\n      disk_control_interface_t *disk_control);\n\n/**\n * disk_control_get_num_images:\n *\n * @return number of disk images registered by the core\n **/\nunsigned disk_control_get_num_images(\n      disk_control_interface_t *disk_control);\n\n/**\n * disk_control_get_image_index:\n *\n * @return currently selected disk image index\n **/\nunsigned disk_control_get_image_index(\n      disk_control_interface_t *disk_control);\n\n/**\n * disk_control_get_image_label:\n *\n * Fetches core-provided disk image label\n * (label is set to an empty string if core\n * does not support image labels)\n **/\nvoid disk_control_get_image_label(\n      disk_control_interface_t *disk_control,\n      unsigned index, char *label, size_t len);\n\n/***********/\n/* Setters */\n/***********/\n\n/**\n * disk_control_set_eject_state:\n *\n * Sets the eject state of the virtual disk tray\n **/\nbool disk_control_set_eject_state(\n      disk_control_interface_t *disk_control,\n      bool eject, bool verbosity);\n\n/**\n * disk_control_set_index:\n *\n * Sets currently selected disk index\n *\n * NOTE: Will fail if disk is not currently ejected\n **/\nbool disk_control_set_index(\n      disk_control_interface_t *disk_control,\n      unsigned index, bool verbosity);\n\n/**\n * disk_control_set_index_next:\n *\n * Increments selected disk index\n **/\nbool disk_control_set_index_next(\n      disk_control_interface_t *disk_control,\n      bool verbosity);\n\n/**\n * disk_control_set_index_prev:\n *\n * Decrements selected disk index\n **/\nbool disk_control_set_index_prev(\n      disk_control_interface_t *disk_control,\n      bool verbosity);\n\n/**\n * disk_control_append_image:\n *\n * Appends specified image file to disk image list\n **/\nbool disk_control_append_image(\n      disk_control_interface_t *disk_control,\n      const char *image_path);\n\n/*****************************/\n/* 'Initial index' functions */\n/*****************************/\n\n/**\n * disk_control_set_initial_index:\n *\n * Attempts to set current core's initial disk index.\n * > disk_control->record_enabled will be set to\n *   'false' if core does not support initial\n *   index functionality\n * > disk_control->index_record will be loaded\n *   from file (if an existing record is found)\n * NOTE: Must be called immediately before\n * loading content\n **/\nbool disk_control_set_initial_index(\n      disk_control_interface_t *disk_control,\n      const char *content_path,\n      const char *dir_savefile);\n\n/**\n * disk_control_verify_initial_index:\n *\n * Checks that initial index has been set correctly\n * and provides user notification.\n * > Sets disk_control->initial_num_images if\n *   if functionality is supported by core\n * NOTE: Must be called immediately after\n * loading content\n **/\nbool disk_control_verify_initial_index(\n      disk_control_interface_t *disk_control,\n      bool verbosity,\n      bool enabled);\n\n/**\n * disk_control_save_image_index:\n *\n * Saves current disk index to file, if supported\n * by current core\n **/\nbool disk_control_save_image_index(\n      disk_control_interface_t *disk_control);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "disk_index_file.c",
          "type": "blob",
          "size": 11.884765625,
          "content": "/* Copyright  (C) 2010-2020 The RetroArch team\n *\n * ---------------------------------------------------------------------------------------\n * The following license statement only applies to this file (disk_index_file.c).\n * ---------------------------------------------------------------------------------------\n *\n * Permission is hereby granted, free of charge,\n * to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <file/file_path.h>\n#include <string/stdstring.h>\n#include <streams/file_stream.h>\n#include <formats/rjson.h>\n\n#include \"file_path_special.h\"\n#include \"verbosity.h\"\n#include \"msg_hash.h\"\n\n#include \"disk_index_file.h\"\n\n/****************/\n/* JSON Helpers */\n/****************/\n\ntypedef struct\n{\n   unsigned *current_entry_uint_val;\n   char **current_entry_str_val;\n   unsigned image_index;\n   char *image_path;\n} DCifJSONContext;\n\nstatic bool DCifJSONObjectMemberHandler(void* context, const char *pValue, size_t length)\n{\n   DCifJSONContext *pCtx = (DCifJSONContext*)context;\n\n   /* something went wrong */\n   if (pCtx->current_entry_str_val)\n      return false;\n\n   if (length)\n   {\n      if (string_is_equal(pValue, \"image_index\"))\n         pCtx->current_entry_uint_val = &pCtx->image_index;\n      else if (string_is_equal(pValue, \"image_path\"))\n         pCtx->current_entry_str_val = &pCtx->image_path;\n      /* ignore unknown members */\n   }\n\n   return true;\n}\n\nstatic bool DCifJSONNumberHandler(void* context, const char *pValue, size_t length)\n{\n   DCifJSONContext *pCtx = (DCifJSONContext*)context;\n\n   if (pCtx->current_entry_uint_val && length && !string_is_empty(pValue))\n      *pCtx->current_entry_uint_val = string_to_unsigned(pValue);\n   /* ignore unknown members */\n\n   pCtx->current_entry_uint_val = NULL;\n\n   return true;\n}\n\nstatic bool DCifJSONStringHandler(void* context, const char *pValue, size_t length)\n{\n   DCifJSONContext *pCtx = (DCifJSONContext*)context;\n\n   if (pCtx->current_entry_str_val && length && !string_is_empty(pValue))\n   {\n      free(*pCtx->current_entry_str_val);\n\n      *pCtx->current_entry_str_val = strdup(pValue);\n   }\n   /* ignore unknown members */\n\n   pCtx->current_entry_str_val = NULL;\n\n   return true;\n}\n\n/******************/\n/* Initialisation */\n/******************/\n\n/* Parses disk index file referenced by\n * disk_index_file->file_path.\n * Does nothing if disk index file does not exist. */\nstatic bool disk_index_file_read(disk_index_file_t *disk_index_file)\n{\n   const char *file_path   = NULL;\n   bool success            = false;\n   DCifJSONContext context = {0};\n   RFILE *file             = NULL;\n   rjson_t* parser;\n\n   /* Sanity check */\n   if (!disk_index_file)\n      return false;\n\n   file_path = disk_index_file->file_path;\n\n   if (    string_is_empty(file_path)\n       || !path_is_valid(file_path)\n      )\n      return false;\n\n   /* Attempt to open disk index file */\n   file = filestream_open(\n         file_path,\n         RETRO_VFS_FILE_ACCESS_READ,\n         RETRO_VFS_FILE_ACCESS_HINT_NONE);\n\n   if (!file)\n   {\n      RARCH_ERR(\n            \"[disk index file] Failed to open disk index record file: %s\\n\",\n            file_path);\n      return false;\n   }\n\n   /* Initialise JSON parser */\n   if (!(parser = rjson_open_rfile(file)))\n   {\n      RARCH_ERR(\"[disk index file] Failed to create JSON parser.\\n\");\n      goto end;\n   }\n\n   /* Configure parser */\n   rjson_set_options(parser, RJSON_OPTION_ALLOW_UTF8BOM);\n\n   /* Read file */\n   if (rjson_parse(parser, &context,\n         DCifJSONObjectMemberHandler,\n         DCifJSONStringHandler,\n         DCifJSONNumberHandler,\n         NULL, NULL, NULL, NULL, /* unused object/array handlers */\n         NULL, NULL) /* unused boolean/null handlers */\n         != RJSON_DONE)\n   {\n      if (rjson_get_source_context_len(parser))\n      {\n         RARCH_ERR(\n               \"[disk index file] Error parsing chunk of disk index file: %s\\n---snip---\\n%.*s\\n---snip---\\n\",\n               file_path,\n               rjson_get_source_context_len(parser),\n               rjson_get_source_context_buf(parser));\n      }\n      RARCH_WARN(\n            \"[disk index file] Error parsing disk index file: %s\\n\",\n            file_path);\n      RARCH_ERR(\"[disk index file] Error: Invalid JSON at line %d, column %d - %s.\\n\",\n            (int)rjson_get_source_line(parser),\n            (int)rjson_get_source_column(parser),\n            (*rjson_get_error(parser) ? rjson_get_error(parser) : \"format error\"));\n   }\n\n   /* Free parser */\n   rjson_free(parser);\n\n   /* Copy values read from JSON file */\n   disk_index_file->image_index = context.image_index;\n\n   if (!string_is_empty(context.image_path))\n      strlcpy(\n            disk_index_file->image_path, context.image_path,\n            sizeof(disk_index_file->image_path));\n   else\n      disk_index_file->image_path[0] = '\\0';\n\n   success = true;\n\nend:\n   /* Clean up leftover strings */\n   if (context.image_path)\n      free(context.image_path);\n\n   /* Close log file */\n   filestream_close(file);\n\n   return success;\n}\n\n/* Initialises existing disk index record, loading\n * current parameters if a record file exists.\n * Returns false if arguments are invalid. */\nbool disk_index_file_init(\n      disk_index_file_t *disk_index_file,\n      const char *content_path,\n      const char *dir_savefile)\n{\n   size_t _len;\n   char content_name[NAME_MAX_LENGTH];\n   char disk_index_file_dir[DIR_MAX_LENGTH];\n\n   /* Sanity check */\n   if (!disk_index_file)\n      return false;\n\n   /* Disk index records are only valid when loading\n    * content (i.e. they do not apply to contentless\n    * cores) */\n   if (string_is_empty(content_path))\n      goto error;\n\n   /* Build disk index file path */\n   fill_pathname(content_name, path_basename(content_path), \"\",\n         sizeof(content_name));\n   if (string_is_empty(content_name))\n      goto error;\n\n   /* > Get disk index file directory */\n   if (!string_is_empty(dir_savefile))\n      strlcpy(disk_index_file_dir, dir_savefile, sizeof(disk_index_file_dir));\n   else\n   {\n      /* Use content directory */\n      strlcpy(disk_index_file_dir, content_path, sizeof(disk_index_file_dir));\n      path_basedir(disk_index_file_dir);\n   }\n\n   /* > Create directory, if required */\n   if (     !path_is_directory(disk_index_file_dir)\n         && !path_mkdir(disk_index_file_dir))\n   {\n      RARCH_ERR(\n            \"[disk index file] failed to create directory for disk index file: %s\\n\",\n            disk_index_file_dir);\n      goto error;\n   }\n\n   /* > Generate final path */\n   _len = fill_pathname_join_special(\n         disk_index_file->file_path, disk_index_file_dir,\n         content_name, sizeof(disk_index_file->file_path));\n   strlcpy(disk_index_file->file_path       + _len,\n         \".ldci\",\n         sizeof(disk_index_file->file_path) - _len);\n\n   /* All is well - reset disk_index_file_t and\n    * attempt to load values from file */\n   disk_index_file->modified      = false;\n   disk_index_file->image_index   = 0;\n   disk_index_file->image_path[0] = '\\0';\n\n   /* > If file does not exist (or some other\n    *   error occurs) then this is a new record\n    *   - in this case, 'modified' flag should\n    *   be set to 'true' */\n   if (!disk_index_file_read(disk_index_file))\n      disk_index_file->modified   = true;\n\n   return true;\n\nerror:\n   disk_index_file->modified      = false;\n   disk_index_file->image_index   = 0;\n   disk_index_file->image_path[0] = '\\0';\n   disk_index_file->file_path[0]  = '\\0';\n   return false;\n}\n\n/***********/\n/* Setters */\n/***********/\n\n/* Sets image index and path */\nvoid disk_index_file_set(\n      disk_index_file_t *disk_index_file,\n      unsigned image_index,\n      const char *image_path)\n{\n   if (!disk_index_file)\n      return;\n\n   /* Check whether image index should be updated */\n   if (disk_index_file->image_index != image_index)\n   {\n      disk_index_file->image_index   = image_index;\n      disk_index_file->modified      = true;\n   }\n\n   /* Check whether image path should be updated */\n   if (!string_is_empty(image_path))\n   {\n      if (!string_is_equal(disk_index_file->image_path, image_path))\n      {\n         strlcpy(\n               disk_index_file->image_path, image_path,\n               sizeof(disk_index_file->image_path));\n         disk_index_file->modified   = true;\n      }\n   }\n   else if (!string_is_empty(disk_index_file->image_path))\n   {\n      disk_index_file->image_path[0] = '\\0';\n      disk_index_file->modified      = true;\n   }\n}\n\n/**********/\n/* Saving */\n/**********/\n\n/* Saves specified disk index file to disk */\nbool disk_index_file_save(disk_index_file_t *disk_index_file)\n{\n   const char *file_path;\n   rjsonwriter_t* writer;\n   RFILE *file             = NULL;\n   bool success            = false;\n\n   /* Sanity check */\n   if (!disk_index_file)\n      return false;\n\n   /* > Only save file if record has been modified.\n    *   We return true in this case - since there\n    *   was nothing to write, there can be no\n    *   'failure' */\n   if (!disk_index_file->modified)\n      return true;\n\n   file_path = disk_index_file->file_path;\n\n   if (string_is_empty(file_path))\n      return false;\n\n   RARCH_LOG(\n         \"[disk index file] Saving disk index file: %s\\n\",\n         file_path);\n\n   /* Attempt to open disk index file */\n   if (!(file = filestream_open(\n         file_path,\n         RETRO_VFS_FILE_ACCESS_WRITE,\n         RETRO_VFS_FILE_ACCESS_HINT_NONE)))\n   {\n      RARCH_ERR(\n            \"[disk index file] Failed to open disk index file: %s\\n\",\n            file_path);\n      return false;\n   }\n\n   /* Initialise JSON writer */\n   if (!(writer = rjsonwriter_open_rfile(file)))\n   {\n      RARCH_ERR(\"[disk index file] Failed to create JSON writer.\\n\");\n      goto end;\n   }\n\n   /* Write output file */\n   rjsonwriter_raw(writer, \"{\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n\n   /* > Version entry */\n   rjsonwriter_add_spaces(writer, 2);\n   rjsonwriter_add_string(writer, \"version\");\n   rjsonwriter_raw(writer, \":\", 1);\n   rjsonwriter_raw(writer, \" \", 1);\n   rjsonwriter_add_string(writer, \"1.0\");\n   rjsonwriter_raw(writer, \",\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n\n   /* > image index entry */\n   rjsonwriter_add_spaces(writer, 2);\n   rjsonwriter_add_string(writer, \"image_index\");\n   rjsonwriter_raw(writer, \":\", 1);\n   rjsonwriter_raw(writer, \" \", 1);\n   rjsonwriter_rawf(writer, \"%u\", disk_index_file->image_index);\n   rjsonwriter_raw(writer, \",\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n\n   /* > image path entry */\n   rjsonwriter_add_spaces(writer, 2);\n   rjsonwriter_add_string(writer, \"image_path\");\n   rjsonwriter_raw(writer, \":\", 1);\n   rjsonwriter_raw(writer, \" \", 1);\n   rjsonwriter_add_string(writer, disk_index_file->image_path);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n\n   /* > Finalise */\n   rjsonwriter_raw(writer, \"}\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n\n   /* Free JSON writer */\n   if (!rjsonwriter_free(writer))\n   {\n      RARCH_ERR(\"[disk index file] Error writing disk index file: %s\\n\", file_path);\n   }\n\n   /* Changes have been written - record\n    * is no longer considered to be in a\n    * 'modified' state */\n   disk_index_file->modified = false;\n   success                   = true;\n\nend:\n   /* Close disk index file */\n   filestream_close(file);\n\n   return success;\n}\n"
        },
        {
          "name": "disk_index_file.h",
          "type": "blob",
          "size": 2.5,
          "content": "/* Copyright  (C) 2010-2020 The RetroArch team\n *\n * ---------------------------------------------------------------------------------------\n * The following license statement only applies to this file (disk_index_file.h).\n * ---------------------------------------------------------------------------------------\n *\n * Permission is hereby granted, free of charge,\n * to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#ifndef __DISK_INDEX_FILE_H\n#define __DISK_INDEX_FILE_H\n\n#include <retro_common_api.h>\n#include <libretro.h>\n#include <retro_miscellaneous.h>\n\n#include <boolean.h>\n\nRETRO_BEGIN_DECLS\n\n/* Holds all parameters required for recording\n * the last disk image selected via the disk\n * control interface */\ntypedef struct\n{\n   unsigned image_index;\n   char image_path[PATH_MAX_LENGTH];\n   char file_path[PATH_MAX_LENGTH];\n   bool modified;\n} disk_index_file_t;\n\n/******************/\n/* Initialisation */\n/******************/\n\n/* Initialises existing disk index record, loading\n * current parameters if a record file exists.\n * Returns false if arguments are invalid. */\nbool disk_index_file_init(\n      disk_index_file_t *disk_index_file,\n      const char *content_path,\n      const char *dir_savefile);\n\n/***********/\n/* Setters */\n/***********/\n\n/* Sets image index and path */\nvoid disk_index_file_set(\n      disk_index_file_t *disk_index_file,\n      unsigned image_index,\n      const char *image_path);\n\n/**********/\n/* Saving */\n/**********/\n\n/* Saves specified disk index file to disk */\nbool disk_index_file_save(disk_index_file_t *disk_index_file);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "dist-scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "driver.h",
          "type": "blob",
          "size": 5.072265625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __RARCH_DRIVER__H\n#define __RARCH_DRIVER__H\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <sys/types.h>\n\n#include <boolean.h>\n#include <retro_common_api.h>\n\n#include \"configuration.h\"\n#include \"retroarch_types.h\"\n\nRETRO_BEGIN_DECLS\n\nenum\n{\n   DRIVER_AUDIO = 0,\n   DRIVER_VIDEO,\n   DRIVER_INPUT,\n   DRIVER_CAMERA,\n   DRIVER_LOCATION,\n   DRIVER_MENU,\n   DRIVERS_VIDEO_INPUT,\n   DRIVER_BLUETOOTH,\n   DRIVER_WIFI,\n   DRIVER_LED,\n   DRIVER_MIDI,\n   DRIVER_MICROPHONE\n};\n\nenum\n{\n   DRIVER_AUDIO_MASK        = 1 << DRIVER_AUDIO,\n   DRIVER_VIDEO_MASK        = 1 << DRIVER_VIDEO,\n   DRIVER_INPUT_MASK        = 1 << DRIVER_INPUT,\n   DRIVER_CAMERA_MASK       = 1 << DRIVER_CAMERA,\n   DRIVER_LOCATION_MASK     = 1 << DRIVER_LOCATION,\n   DRIVER_MENU_MASK         = 1 << DRIVER_MENU,\n   DRIVERS_VIDEO_INPUT_MASK = 1 << DRIVERS_VIDEO_INPUT,\n   DRIVER_BLUETOOTH_MASK    = 1 << DRIVER_BLUETOOTH,\n   DRIVER_WIFI_MASK         = 1 << DRIVER_WIFI,\n   DRIVER_LED_MASK          = 1 << DRIVER_LED,\n   DRIVER_MIDI_MASK         = 1 << DRIVER_MIDI,\n   DRIVER_MICROPHONE_MASK   = 1 << DRIVER_MICROPHONE\n};\n\n/**\n * These flags indicate special requirements or requests\n * of a driver's setup or teardown process.\n *\n * They are passed to \\c drivers_init and \\c driver_deinit.\n * Not all drivers will need them.\n *\n * @see drivers_init\n * @see driver_deinit\n */\nenum driver_lifetime_flags\n{\n   /**\n    * Indicates that the driver is being reset.\n    * When passed \\c driver_deinit, indicates that the targeted drivers\n    * are about to be reinitialized.\n    * When passed to \\c driver_init, indicates that the targeted drivers\n    * are in the middle of being reinitialized.\n    *\n    * This is useful for drivers that provide core-accessible resource handles,\n    * such as the microphone driver.\n    * When closed by normal means, such drivers will de-allocate the resources\n    * that their opened handles represent.\n    * If the game isn't being exited, then these resources would effectively\n    * be closed while the core might still be using them.\n    *\n    * This flag can be used to ensure that existing core-accessible handles\n    * are reinitialized with valid resources\n    * before the core notices that anything's wrong.\n    */\n   DRIVER_LIFETIME_RESET = 1 << 0\n};\n\nenum driver_ctl_state\n{\n   RARCH_DRIVER_CTL_NONE = 0,\n\n   /* Sets monitor refresh rate to new value by calling\n    * video_monitor_set_refresh_rate(). Subsequently\n    * calls audio_monitor_set_refresh_rate(). */\n   RARCH_DRIVER_CTL_SET_REFRESH_RATE,\n\n   RARCH_DRIVER_CTL_FIND_FIRST,\n\n   RARCH_DRIVER_CTL_FIND_LAST,\n\n   RARCH_DRIVER_CTL_FIND_PREV,\n\n   RARCH_DRIVER_CTL_FIND_NEXT\n};\n\ntypedef struct driver_ctx_info\n{\n   const char *label;\n   char *s;\n   ssize_t len;\n} driver_ctx_info_t;\n\nbool driver_ctl(enum driver_ctl_state state, void *data);\n\n/**\n * driver_find_index:\n * @label              : string of driver type to be found.\n * @drv                : identifier of driver to be found.\n *\n * Find index of the driver, based on @label.\n *\n * Returns: -1 if no driver based on @label and @drv found, otherwise\n * index number of the driver found in the array.\n **/\nint driver_find_index(const char *label, const char *drv);\n\n/* Sets audio and video drivers to nonblock state.\n *\n * If nonblock state is false, sets blocking state for both\n * audio and video drivers instead. */\nvoid driver_set_nonblock_state(void);\n\n/**\n * drivers_init:\n * @flags              : Bitmask of drivers to initialize.\n *\n * Initializes drivers.\n * @flags determines which drivers get initialized.\n **/\nvoid drivers_init(settings_t *settings, int flags,\n      enum driver_lifetime_flags lifetime_flags, bool verbosity_enabled);\n\n/**\n * Driver ownership - set this to true if the platform in\n * question needs to 'own'\n * the respective handle and therefore skip regular RetroArch\n * driver teardown/reiniting procedure.\n *\n * If  to true, the 'free' function will get skipped. It is\n * then up to the driver implementation to properly handle\n * 'reiniting' inside the 'init' function and make sure it\n * returns the existing handle instead of allocating and\n * returning a pointer to a new handle.\n *\n * Typically, if a driver intends to make use of this, it should\n * set this to true at the end of its 'init' function.\n **/\nvoid driver_uninit(int flags, enum driver_lifetime_flags lifetime_flags);\n\nvoid retro_input_poll_null(void);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "dynamic.h",
          "type": "blob",
          "size": 3.560546875,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __DYNAMIC_H\n#define __DYNAMIC_H\n\n#include <boolean.h>\n#include <retro_common_api.h>\n#include <libretro.h>\n\n#include \"retroarch_types.h\"\n\nRETRO_BEGIN_DECLS\n\nenum retro_core_flags\n{\n   RETRO_CORE_FLAG_INITED                    = (1 << 0),\n   RETRO_CORE_FLAG_SYMBOLS_INITED            = (1 << 1),\n   RETRO_CORE_FLAG_GAME_LOADED               = (1 << 2),\n   RETRO_CORE_FLAG_INPUT_POLLED              = (1 << 3),\n   RETRO_CORE_FLAG_HAS_SET_SUBSYSTEMS        = (1 << 4),\n   RETRO_CORE_FLAG_HAS_SET_INPUT_DESCRIPTORS = (1 << 5)\n};\n\nstruct retro_core_t\n{\n   uint64_t serialization_quirks_v;\n   void (*retro_init)(void);\n   void (*retro_deinit)(void);\n   unsigned (*retro_api_version)(void);\n   void (*retro_get_system_info)(struct retro_system_info*);\n   void (*retro_get_system_av_info)(struct retro_system_av_info*);\n   void (*retro_set_environment)(retro_environment_t);\n   void (*retro_set_video_refresh)(retro_video_refresh_t);\n   void (*retro_set_audio_sample)(retro_audio_sample_t);\n   void (*retro_set_audio_sample_batch)(retro_audio_sample_batch_t);\n   void (*retro_set_input_poll)(retro_input_poll_t);\n   void (*retro_set_input_state)(retro_input_state_t);\n   void (*retro_set_controller_port_device)(unsigned, unsigned);\n   void (*retro_reset)(void);\n   void (*retro_run)(void);\n   size_t (*retro_serialize_size)(void);\n   bool (*retro_serialize)(void*, size_t);\n   bool (*retro_unserialize)(const void*, size_t);\n   void (*retro_cheat_reset)(void);\n   void (*retro_cheat_set)(unsigned, bool, const char*);\n   bool (*retro_load_game)(const struct retro_game_info*);\n   bool (*retro_load_game_special)(unsigned,\n         const struct retro_game_info*, size_t);\n   void (*retro_unload_game)(void);\n   unsigned (*retro_get_region)(void);\n   void *(*retro_get_memory_data)(unsigned);\n   size_t (*retro_get_memory_size)(unsigned);\n\n   unsigned poll_type;\n   uint8_t flags;\n};\n\n\n/**\n * libretro_free_system_info:\n * @info                         : Pointer to system info information.\n *\n * Frees system information.\n **/\nvoid libretro_free_system_info(struct retro_system_info *info);\n\nconst struct retro_subsystem_info *libretro_find_subsystem_info(\n      const struct retro_subsystem_info *info,\n      unsigned num_info, const char *ident);\n\n/**\n * libretro_find_controller_description:\n * @info                         : Pointer to controller info handle.\n * @id                           : Identifier of controller to search\n *                                 for.\n *\n * Search for a controller of type @id in @info.\n *\n * Leaf function.\n *\n * @return controller description of found controller on success,\n * otherwise NULL.\n **/\nconst struct retro_controller_description *\n   libretro_find_controller_description(\n         const struct retro_controller_info *info, unsigned id);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "emscripten",
          "type": "tree",
          "content": null
        },
        {
          "name": "fastlane",
          "type": "tree",
          "content": null
        },
        {
          "name": "fetch-submodules.sh",
          "type": "blob",
          "size": 2.3203125,
          "content": "#! /usr/bin/env bash\n# vim: set ts=3 sw=3 noet ft=sh : bash\n\nset -e # quit script on error\n\n# TODO: This entire script _should_ be replaced with git submodules, but\n# that cannot be done until we sort out the limitations of that option.  At\n# this time, this script is called by libretro-super.  Revisit the whole\n# issue at some point.\n\nSCRIPT=\"${0#./}\"\nBASE_DIR=\"${SCRIPT%/*}\"\nWORKDIR=\"$PWD\"\n\nif [ \"$BASE_DIR\" = \"$SCRIPT\" ]; then\n\tBASE_DIR=\"$WORKDIR\"\nelse\n\tif [[ \"$0\" != /* ]]; then\n\t\t# Make the path absolute\n\t\tBASE_DIR=\"$WORKDIR/$BASE_DIR\"\n\tfi\nfi\n\n# Inserted here is libretro-super's script-modules/fetch-rules.sh, with a\n# couple of features related to core submodules removed from fetch_git.  If\n# that file is changed, it should be safe to import it verbatim.\n\n### START OF FETCH-RULES.SH (with mods)\n\n# fetch_git: Clones or pulls updates from a git repository into a local directory\n#\n# $1\tThe URI to fetch\n# $2\tThe local directory to fetch to (relative)\n#\n# NOTE: git _now_ has a -C argument that would replace the cd commands in\n#       this rule, but this is a fairly recent addition to git, so we can't\n#       use it here.  --iKarith\nfetch_git() {\n\tfetch_dir=\"$WORKDIR/$2\"\n\tif [ -d \"$fetch_dir/.git\" ]; then\n\t\techo \"cd \\\"$fetch_dir\\\"\"\n\t\tcd \"$fetch_dir\"\n\t\techo \"git pull\"\n\t\tgit pull\n\telse\n\t\tclone_type=\n\t\t[ -n \"$SHALLOW_CLONE\" ] && depth=\"--depth 1\"\n\t\techo \"git clone $depth \\\"$1\\\" \\\"$WORKDIR/$2\\\"\"\n\t\tgit clone $depth \"$1\" \"$WORKDIR/$2\"\n\tfi\n}\n\n# fetch_revision_git: Output the hash of the last commit in a git repository\n#\n# $1\tLocal directory to run git in\nfetch_revision_git() {\n\t[ -n \"$1\" ] && cd \"$1\"\n\tgit log -n 1 --pretty=format:%H\n}\n\n# fetch_revision: Output SCM-dependent revision string of a module\n#                 (currently just calls fetch_revision_git)\n#\n# $1\tThe directory of the module\nfetch_revision() {\n\t   fetch_revision_git $1\n}\n\n### END OF FETCH-RULES.SH\n\necho \"Fetching RetroArch's submodules...\"\nfetch_git \"https://github.com/libretro/common-shaders.git\" \"media/shaders_cg\"\nfetch_git \"https://github.com/libretro/common-overlays.git\" \"media/overlays\"\nfetch_git \"https://github.com/libretro/retroarch-assets.git\" \"media/assets\"\nfetch_git \"https://github.com/libretro/retroarch-joypad-autoconfig.git\" \"media/autoconfig\"\nfetch_git \"https://github.com/libretro/libretro-database.git\" \"media/libretrodb\"\n\ngit submodule update --init --recursive\n"
        },
        {
          "name": "file_path_special.c",
          "type": "blob",
          "size": 15.130859375,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/* Assume W-functions do not work below Win2K and Xbox platforms */\n#if defined(_WIN32_WINNT) && _WIN32_WINNT < 0x0500 || defined(_XBOX)\n\n#ifndef LEGACY_WIN32\n#define LEGACY_WIN32\n#endif\n\n#endif\n\n#ifdef _WIN32\n#include <direct.h>\n#else\n#include <unistd.h>\n#endif\n\n#ifdef OSX\n#include <CoreFoundation/CoreFoundation.h>\n#endif\n\n#ifdef __QNX__\n#include <libgen.h>\n#endif\n\n#ifdef __HAIKU__\n#include <kernel/image.h>\n#endif\n\n#if defined(DINGUX)\n#include \"dingux/dingux_utils.h\"\n#endif\n\n#include <stdlib.h>\n#include <boolean.h>\n#include <string.h>\n#include <time.h>\n\n#include <file/file_path.h>\n#include <string/stdstring.h>\n\n#include <compat/strl.h>\n#include <compat/posix_string.h>\n#include <retro_assert.h>\n#include <retro_miscellaneous.h>\n#include <encodings/utf.h>\n\n#ifdef HAVE_MENU\n#include \"menu/menu_driver.h\"\n#endif\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"configuration.h\"\n#include \"file_path_special.h\"\n\n#include \"msg_hash.h\"\n#include \"paths.h\"\n#include \"verbosity.h\"\n\nbool fill_pathname_application_data(char *s, size_t len)\n{\n#if defined(_WIN32) && !defined(_XBOX) && !defined(__WINRT__)\n#ifdef LEGACY_WIN32\n   const char *appdata = getenv(\"APPDATA\");\n\n   if (appdata)\n   {\n      strlcpy(s, appdata, len);\n      return true;\n   }\n#else\n   const wchar_t *appdataW = _wgetenv(L\"APPDATA\");\n\n   if (appdataW)\n   {\n      char *appdata = utf16_to_utf8_string_alloc(appdataW);\n\n      if (appdata)\n      {\n         strlcpy(s, appdata, len);\n         free(appdata);\n         return true;\n      }\n   }\n#endif\n\n#elif defined(OSX)\n   CFBundleRef bundle = CFBundleGetMainBundle();\n   if (!bundle)\n      return false;\n\n   /* get the directory containing the app */\n   CFStringRef parent_path;\n   CFURLRef bundle_url, parent_url;\n   bundle_url  = CFBundleCopyBundleURL(bundle);\n   parent_url  = CFURLCreateCopyDeletingLastPathComponent(NULL, bundle_url);\n   parent_path = CFURLCopyFileSystemPath(parent_url, kCFURLPOSIXPathStyle);\n   CFStringGetCString(parent_path, s, len, kCFStringEncodingUTF8);\n   CFRelease(parent_path);\n   CFRelease(parent_url);\n   CFRelease(bundle_url);\n\n#if HAVE_STEAM\n   return true;\n#else\n   /* if portable.txt exists next to the app then we use that directory */\n   char portable_buf[PATH_MAX_LENGTH] = {0};\n   fill_pathname_join(portable_buf, s, \"portable.txt\", sizeof(portable_buf));\n   if (path_is_valid(portable_buf))\n      return true;\n\n   /* if the app itself says it's portable we obey that as well */\n   CFStringRef key = CFStringCreateWithCString(NULL, \"RAPortableInstall\", kCFStringEncodingUTF8);\n   if (key)\n   {\n      CFBooleanRef val = CFBundleGetValueForInfoDictionaryKey(bundle, key);\n      CFRelease(key);\n      if (val)\n      {\n         bool portable = CFBooleanGetValue(val);\n         CFRelease(val);\n         if (portable)\n            return true;\n      }\n   }\n\n   /* otherwise we use ~/Library/Application Support/RetroArch */\n   const char *appdata = getenv(\"HOME\");\n   if (appdata)\n   {\n      fill_pathname_join(s, appdata,\n                         \"Library/Application Support/RetroArch\", len);\n      return true;\n   }\n#endif\n#elif defined(RARCH_UNIX_CWD_ENV)\n   getcwd(s, len);\n   return true;\n#elif defined(DINGUX)\n   dingux_get_base_path(s, len);\n   return true;\n#elif !defined(RARCH_CONSOLE)\n   const char *xdg     = getenv(\"XDG_CONFIG_HOME\");\n   const char *appdata = getenv(\"HOME\");\n\n   /* XDG_CONFIG_HOME falls back to $HOME/.config with most Unix systems */\n   /* On Haiku, it is set by default to /home/user/config/settings */\n   if (xdg)\n   {\n      fill_pathname_join(s, xdg, \"retroarch/\", len);\n      return true;\n   }\n\n   if (appdata)\n   {\n#ifdef __HAIKU__\n      /* in theory never used as Haiku has XDG_CONFIG_HOME set by default */\n      fill_pathname_join(s, appdata,\n            \"config/settings/retroarch/\", len);\n#else\n      fill_pathname_join(s, appdata,\n            \".config/retroarch/\", len);\n#endif\n      return true;\n   }\n#endif\n\n   return false;\n}\n\n#ifdef HAVE_XMB\nconst char* xmb_theme_ident(void);\n#endif\n\nsize_t fill_pathname_application_special(char *s,\n      size_t len, enum application_special_type type)\n{\n   size_t _len = 0;\n   switch (type)\n   {\n      case APPLICATION_SPECIAL_DIRECTORY_CONFIG:\n         {\n            settings_t *settings        = config_get_ptr();\n            const char *dir_menu_config = settings->paths.directory_menu_config;\n\n            /* Try config directory setting first,\n             * fallback to the location of the current configuration file. */\n            if (!string_is_empty(dir_menu_config))\n               _len = strlcpy(s, dir_menu_config, len);\n            else if (!path_is_empty(RARCH_PATH_CONFIG))\n               _len = fill_pathname_basedir(s, path_get(RARCH_PATH_CONFIG), len);\n         }\n         break;\n      case APPLICATION_SPECIAL_DIRECTORY_ASSETS_XMB_ICONS:\n#ifdef HAVE_XMB\n         {\n            char tmp_path[PATH_MAX_LENGTH];\n            char tmp_dir[DIR_MAX_LENGTH];\n            settings_t *settings     = config_get_ptr();\n            const char *dir_assets   = settings->paths.directory_assets;\n            fill_pathname_join_special(tmp_dir, dir_assets, \"xmb\", sizeof(tmp_dir));\n            fill_pathname_join_special(tmp_path, tmp_dir, xmb_theme_ident(), sizeof(tmp_path));\n            _len = fill_pathname_join_special(s, tmp_path, \"png\", len);\n         }\n#endif\n         break;\n      case APPLICATION_SPECIAL_DIRECTORY_ASSETS_XMB_BG:\n#ifdef HAVE_XMB\n         {\n            settings_t *settings            = config_get_ptr();\n            const char *path_menu_wallpaper = settings->paths.path_menu_wallpaper;\n\n            if (!string_is_empty(path_menu_wallpaper))\n               _len = strlcpy(s, path_menu_wallpaper, len);\n            else\n            {\n               char tmp_dir[DIR_MAX_LENGTH];\n               char tmp_dir2[DIR_MAX_LENGTH];\n               char tmp_path[PATH_MAX_LENGTH];\n               const char *dir_assets   = settings->paths.directory_assets;\n               fill_pathname_join_special(tmp_dir, dir_assets, \"xmb\", sizeof(tmp_dir));\n               fill_pathname_join_special(tmp_dir2,  tmp_dir, xmb_theme_ident(), sizeof(tmp_dir2));\n               fill_pathname_join_special(tmp_path, tmp_dir2, \"png\", sizeof(tmp_path));\n               _len = fill_pathname_join_special(s, tmp_path, FILE_PATH_BACKGROUND_IMAGE, len);\n            }\n         }\n#endif\n         break;\n      case APPLICATION_SPECIAL_DIRECTORY_ASSETS_SOUNDS:\n         {\n#ifdef HAVE_MENU\n            settings_t *settings   = config_get_ptr();\n#if defined(HAVE_XMB) || defined(HAVE_MATERIALUI) || defined(HAVE_OZONE)\n            const char *menu_ident = settings->arrays.menu_driver;\n#endif\n            const char *dir_assets = settings->paths.directory_assets;\n\n#ifdef HAVE_XMB\n            if (string_is_equal(menu_ident, \"xmb\"))\n            {\n               char tmp_dir[DIR_MAX_LENGTH];\n               char tmp_path[PATH_MAX_LENGTH];\n               fill_pathname_join_special(tmp_dir, dir_assets, menu_ident, sizeof(tmp_dir));\n               fill_pathname_join_special(tmp_path, tmp_dir, xmb_theme_ident(), sizeof(tmp_path));\n               _len = fill_pathname_join_special(s, tmp_path, \"sounds\", len);\n            }\n            else\n#endif\n#if defined(HAVE_MATERIALUI) || defined(HAVE_OZONE)\n            if (     string_is_equal(menu_ident, \"glui\")\n                  || string_is_equal(menu_ident, \"ozone\"))\n            {\n               char tmp_dir[DIR_MAX_LENGTH];\n               fill_pathname_join_special(tmp_dir, dir_assets, menu_ident, sizeof(tmp_dir));\n               _len = fill_pathname_join_special(s, tmp_dir, \"sounds\", len);\n            }\n            else\n#endif\n            {\n               _len = fill_pathname_join_special(\n                     s, dir_assets, \"sounds\", len);\n            }\n#endif\n         }\n\n         break;\n      case APPLICATION_SPECIAL_DIRECTORY_ASSETS_SYSICONS:\n         {\n#ifdef HAVE_MENU\n#if defined(HAVE_XMB) || defined(HAVE_MATERIALUI) || defined(HAVE_OZONE)\n            settings_t *settings   = config_get_ptr();\n            const char *menu_ident = settings->arrays.menu_driver;\n#endif\n\n#ifdef HAVE_XMB\n            if (string_is_equal(menu_ident, \"xmb\"))\n            {\n               char tmp_dir[DIR_MAX_LENGTH];\n               char tmp_path[PATH_MAX_LENGTH];\n               const char *dir_assets   = settings->paths.directory_assets;\n               fill_pathname_join_special(tmp_dir, dir_assets, menu_ident, sizeof(tmp_dir));\n               fill_pathname_join_special(tmp_path, tmp_dir, xmb_theme_ident(), sizeof(tmp_path));\n               _len = fill_pathname_join_special(s, tmp_path, \"png\", len);\n            }\n            else\n#endif\n#if defined(HAVE_OZONE) || defined(HAVE_MATERIALUI)\n\t\t    if (    string_is_equal(menu_ident, \"ozone\")\n               || string_is_equal(menu_ident, \"glui\"))\n            {\n               char tmp_dir[DIR_MAX_LENGTH];\n               char tmp_path[PATH_MAX_LENGTH];\n               const char *dir_assets   = settings->paths.directory_assets;\n\n#if defined(WIIU) || defined(VITA)\n               /* Smaller 46x46 icons look better on low-DPI devices */\n               fill_pathname_join_special(tmp_dir, dir_assets, \"ozone\", sizeof(tmp_dir));\n               fill_pathname_join_special(tmp_path, \"png\", \"icons\", sizeof(tmp_path));\n#else\n               /* Otherwise, use large 256x256 icons */\n               fill_pathname_join_special(tmp_dir, dir_assets, \"xmb\", sizeof(tmp_dir));\n               fill_pathname_join_special(tmp_path, \"monochrome\", \"png\", sizeof(tmp_path));\n#endif\n               _len = fill_pathname_join_special(s, tmp_dir, tmp_path, len);\n            }\n            else\n#endif\n               if (len) s[0] = '\\0';\n#endif\n         }\n\n         break;\n      case APPLICATION_SPECIAL_DIRECTORY_ASSETS_OZONE_ICONS:\n#ifdef HAVE_OZONE\n         {\n            char tmp_dir[DIR_MAX_LENGTH];\n            char tmp_path[PATH_MAX_LENGTH];\n            settings_t *settings     = config_get_ptr();\n            const char *dir_assets   = settings->paths.directory_assets;\n#if defined(WIIU) || defined(VITA)\n            /* Smaller 46x46 icons look better on low-DPI devices */\n            fill_pathname_join_special(tmp_dir, dir_assets, \"ozone\", sizeof(tmp_dir));\n            fill_pathname_join_special(tmp_path, \"png\", \"icons\", sizeof(tmp_path));\n#else\n            /* Otherwise, use large 256x256 icons */\n            fill_pathname_join_special(tmp_dir, dir_assets, \"xmb\", sizeof(tmp_dir));\n            fill_pathname_join_special(tmp_path, \"monochrome\", \"png\", sizeof(tmp_path));\n#endif\n            _len = fill_pathname_join_special(s, tmp_dir, tmp_path, len);\n         }\n#endif\n         break;\n\n      case APPLICATION_SPECIAL_DIRECTORY_ASSETS_RGUI_FONT:\n#ifdef HAVE_RGUI\n         {\n            char tmp_dir[DIR_MAX_LENGTH];\n            settings_t *settings     = config_get_ptr();\n            const char *dir_assets   = settings->paths.directory_assets;\n            fill_pathname_join_special(tmp_dir, dir_assets, \"rgui\", sizeof(tmp_dir));\n            _len = fill_pathname_join_special(s, tmp_dir, \"font\", len);\n         }\n#endif\n         break;\n\n      case APPLICATION_SPECIAL_DIRECTORY_ASSETS_XMB:\n#ifdef HAVE_XMB\n         {\n            char tmp_dir[DIR_MAX_LENGTH];\n            settings_t *settings     = config_get_ptr();\n            const char *dir_assets   = settings->paths.directory_assets;\n            fill_pathname_join_special(tmp_dir, dir_assets, \"xmb\", sizeof(tmp_dir));\n            _len = fill_pathname_join_special(s, tmp_dir, xmb_theme_ident(), len);\n         }\n#endif\n         break;\n      case APPLICATION_SPECIAL_DIRECTORY_ASSETS_XMB_FONT:\n#ifdef HAVE_XMB\n         {\n            settings_t           *settings = config_get_ptr();\n            const char *path_menu_xmb_font = settings->paths.path_menu_xmb_font;\n\n            if (!string_is_empty(path_menu_xmb_font))\n               _len = strlcpy(s, path_menu_xmb_font, len);\n            else\n            {\n               char tmp_dir[DIR_MAX_LENGTH];\n\n               switch (*msg_hash_get_uint(MSG_HASH_USER_LANGUAGE))\n               {\n                  case RETRO_LANGUAGE_ARABIC:\n                  case RETRO_LANGUAGE_PERSIAN:\n                     fill_pathname_join_special(tmp_dir,\n                           settings->paths.directory_assets, \"pkg\", sizeof(tmp_dir));\n                     _len = fill_pathname_join_special(s, tmp_dir, \"fallback-font.ttf\", len);\n                     break;\n                  case RETRO_LANGUAGE_CHINESE_SIMPLIFIED:\n                  case RETRO_LANGUAGE_CHINESE_TRADITIONAL:\n                     fill_pathname_join_special(tmp_dir,\n                           settings->paths.directory_assets, \"pkg\", sizeof(tmp_dir));\n                     _len = fill_pathname_join_special(s, tmp_dir, \"chinese-fallback-font.ttf\", len);\n                     break;\n                  case RETRO_LANGUAGE_KOREAN:\n                     fill_pathname_join_special(tmp_dir,\n                           settings->paths.directory_assets, \"pkg\", sizeof(tmp_dir));\n                     _len = fill_pathname_join_special(s, tmp_dir, \"korean-fallback-font.ttf\", len);\n                     break;\n                  default:\n                     {\n                        char tmp_dir2[DIR_MAX_LENGTH];\n                        settings_t *settings     = config_get_ptr();\n                        const char *dir_assets   = settings->paths.directory_assets;\n                        fill_pathname_join_special(tmp_dir2, dir_assets, \"xmb\", sizeof(tmp_dir2));\n                        fill_pathname_join_special(tmp_dir, tmp_dir2, xmb_theme_ident(), sizeof(tmp_dir));\n                        _len = fill_pathname_join_special(s, tmp_dir, FILE_PATH_TTF_FONT, len);\n                     }\n                     break;\n               }\n            }\n         }\n#endif\n         break;\n      case APPLICATION_SPECIAL_DIRECTORY_THUMBNAILS_DISCORD_AVATARS:\n      {\n        char tmp_dir[DIR_MAX_LENGTH];\n        settings_t *settings       = config_get_ptr();\n        const char *dir_thumbnails = settings->paths.directory_thumbnails;\n        fill_pathname_join_special(tmp_dir, dir_thumbnails, \"discord\", sizeof(tmp_dir));\n        _len = fill_pathname_join_special(s, tmp_dir, \"avatars\", len);\n      }\n      break;\n\n      case APPLICATION_SPECIAL_DIRECTORY_THUMBNAILS_CHEEVOS_BADGES:\n      {\n        char tmp_dir[DIR_MAX_LENGTH];\n        settings_t *settings       = config_get_ptr();\n        const char *dir_thumbnails = settings->paths.directory_thumbnails;\n        fill_pathname_join_special(tmp_dir, dir_thumbnails, \"cheevos\", sizeof(tmp_dir));\n        _len = fill_pathname_join_special(s, tmp_dir, \"badges\", len);\n      }\n      break;\n\n      case APPLICATION_SPECIAL_NONE:\n      default:\n         break;\n   }\n   return _len;\n}\n"
        },
        {
          "name": "file_path_special.h",
          "type": "blob",
          "size": 6.06640625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2016 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _FILE_PATH_SPECIAL_H\n#define _FILE_PATH_SPECIAL_H\n\n#include <stdint.h>\n#include <stddef.h>\n\n#include <boolean.h>\n#include <retro_common_api.h>\n#include <retro_environment.h>\n\nRETRO_BEGIN_DECLS\n\n#define FILE_PATH_UNKNOWN          \"null\"\n#define FILE_PATH_CONTENT_BASENAME \"content.png\"\n#define FILE_PATH_BUILTIN          \"builtin\"\n#define FILE_PATH_DETECT           \"DETECT\"\n#define FILE_PATH_LUTRO_PLAYLIST   \"Lutro.lpl\"\n#define FILE_PATH_NUL              \"nul\"\n#define FILE_PATH_CGP_EXTENSION \".cgp\"\n#define FILE_PATH_GLSLP_EXTENSION \".glslp\"\n#define FILE_PATH_SLANGP_EXTENSION \".slangp\"\n#define FILE_PATH_AUTO_EXTENSION \".auto\"\n#define FILE_PATH_BSV_EXTENSION \".replay\"\n#define FILE_PATH_OPT_EXTENSION \".opt\"\n#define FILE_PATH_CORE_INFO_EXTENSION \".info\"\n#define FILE_PATH_CONFIG_EXTENSION \".cfg\"\n#define FILE_PATH_REMAP_EXTENSION \".rmp\"\n#define FILE_PATH_RTC_EXTENSION \".rtc\"\n#define FILE_PATH_CHT_EXTENSION \".cht\"\n#define FILE_PATH_SRM_EXTENSION \".srm\"\n#define FILE_PATH_STATE_EXTENSION \".state\"\n#define FILE_PATH_LPL_EXTENSION \".lpl\"\n#define FILE_PATH_LPL_EXTENSION_NO_DOT \"lpl\"\n#define FILE_PATH_PNG_EXTENSION \".png\"\n#define FILE_PATH_MP3_EXTENSION \".mp3\"\n#define FILE_PATH_FLAC_EXTENSION \".flac\"\n#define FILE_PATH_OGG_EXTENSION \".ogg\"\n#define FILE_PATH_WAV_EXTENSION \".wav\"\n#define FILE_PATH_MOD_EXTENSION \".mod\"\n#define FILE_PATH_S3M_EXTENSION \".s3m\"\n#define FILE_PATH_XM_EXTENSION \".xm\"\n#define FILE_PATH_JPEG_EXTENSION \".jpeg\"\n#define FILE_PATH_BMP_EXTENSION \".bmp\"\n#define FILE_PATH_TGA_EXTENSION \".tga\"\n#define FILE_PATH_JPG_EXTENSION \".jpg\"\n#define FILE_PATH_UPS_EXTENSION \".ups\"\n#define FILE_PATH_IPS_EXTENSION \".ips\"\n#define FILE_PATH_BPS_EXTENSION \".bps\"\n#define FILE_PATH_XDELTA_EXTENSION \".xdelta\"\n#define FILE_PATH_RDB_EXTENSION \".rdb\"\n#define FILE_PATH_RDB_EXTENSION_NO_DOT \"rdb\"\n#define FILE_PATH_ZIP_EXTENSION \".zip\"\n#define FILE_PATH_7Z_EXTENSION \".7z\"\n#define FILE_PATH_INDEX_URL \".index\"\n#define FILE_PATH_INDEX_DIRS_URL \".index-dirs\"\n#define FILE_PATH_INDEX_EXTENDED_URL \".index-extended\"\n#define FILE_PATH_NETPLAY_ROOM_LIST_URL \"registry.lpl\"\n#define FILE_PATH_RETROACHIEVEMENTS_URL \"http://i.retroachievements.org\"\n#define FILE_PATH_LOBBY_LIBRETRO_URL \"http://lobby.libretro.com/\"\n#define FILE_PATH_CORE_THUMBNAILS_URL \"http://thumbnails.libretro.com\"\n#define FILE_PATH_CORE_THUMBNAILPACKS_URL \"http://thumbnailpacks.libretro.com\"\n#define FILE_PATH_SHADERS_GLSL_ZIP \"shaders_glsl.zip\"\n#define FILE_PATH_SHADERS_SLANG_ZIP \"shaders_slang.zip\"\n#define FILE_PATH_SHADERS_CG_ZIP \"shaders_cg.zip\"\n#define FILE_PATH_DATABASE_RDB_ZIP \"database-rdb.zip\"\n#define FILE_PATH_OVERLAYS_ZIP \"overlays.zip\"\n#define FILE_PATH_CORE_INFO_ZIP \"info.zip\"\n#define FILE_PATH_CHEATS_ZIP \"cheats.zip\"\n#define FILE_PATH_ASSETS_ZIP \"assets.zip\"\n#define FILE_PATH_AUTOCONFIG_ZIP \"autoconfig.zip\"\n#define FILE_PATH_CONTENT_FAVORITES \"content_favorites.lpl\"\n#define FILE_PATH_CONTENT_HISTORY \"content_history.lpl\"\n#define FILE_PATH_CONTENT_IMAGE_HISTORY \"content_image_history.lpl\"\n#define FILE_PATH_CONTENT_MUSIC_HISTORY \"content_music_history.lpl\"\n#define FILE_PATH_CONTENT_VIDEO_HISTORY \"content_video_history.lpl\"\n#define FILE_PATH_CORE_OPTIONS_CONFIG \"retroarch-core-options.cfg\"\n#define FILE_PATH_MAIN_CONFIG \"retroarch.cfg\"\n#define FILE_PATH_SALAMANDER_CONFIG \"retroarch-salamander.cfg\"\n#define FILE_PATH_BACKGROUND_IMAGE \"bg.png\"\n#define FILE_PATH_TTF_FONT \"font.ttf\"\n#define FILE_PATH_RUNTIME_EXTENSION \".lrtl\"\n#define FILE_PATH_DEFAULT_EVENT_LOG \"retroarch.log\"\n#define FILE_PATH_EVENT_LOG_EXTENSION \".log\"\n#define FILE_PATH_DISK_CONTROL_INDEX_EXTENSION \".ldci\"\n#define FILE_PATH_CORE_BACKUP_EXTENSION \".lcbk\"\n#define FILE_PATH_CORE_BACKUP_EXTENSION_NO_DOT \"lcbk\"\n#define FILE_PATH_LOCK_EXTENSION \".lck\"\n#define FILE_PATH_LOCK_EXTENSION_NO_DOT \"lck\"\n#define FILE_PATH_STANDALONE_EXEMPT_EXTENSION \".lsae\"\n#define FILE_PATH_STANDALONE_EXEMPT_EXTENSION_NO_DOT \"lsae\"\n#define FILE_PATH_BACKUP_EXTENSION \".bak\"\n#if defined(RARCH_MOBILE)\n#define FILE_PATH_DEFAULT_OVERLAY \"gamepads/neo-retropad/neo-retropad.cfg\"\n#endif\n#define FILE_PATH_CORE_INFO_CACHE \"core_info.cache\"\n#define FILE_PATH_CORE_INFO_CACHE_REFRESH \"core_info.refresh\"\n\n#ifdef HAVE_LAKKA\n #ifdef HAVE_LAKKA_SERVER\n  #define FILE_PATH_LAKKA_URL HAVE_LAKKA_SERVER\n #else\n  #error \"Building for Lakka, but no update server was defined! Add -DHAVE_LAKKA_SERVER=\\\\\\\"http://...\\\\\\\"\"\n #endif\n #ifdef HAVE_LAKKA_PROJECT\n  #define LAKKA_PROJECT HAVE_LAKKA_PROJECT\n #else\n  #error \"Building for Lakka, but no target device name was defined! Add -DHAVE_LAKKA_PROJECT=\\\\\\\"DeviceName.arch\\\\\\\"\"\n #endif\n#endif\n\nenum application_special_type\n{\n   APPLICATION_SPECIAL_NONE = 0,\n   APPLICATION_SPECIAL_DIRECTORY_CONFIG,\n   APPLICATION_SPECIAL_DIRECTORY_ASSETS_XMB,\n   APPLICATION_SPECIAL_DIRECTORY_ASSETS_XMB_BG,\n   APPLICATION_SPECIAL_DIRECTORY_ASSETS_XMB_ICONS,\n   APPLICATION_SPECIAL_DIRECTORY_ASSETS_XMB_FONT,\n   APPLICATION_SPECIAL_DIRECTORY_ASSETS_OZONE_ICONS,\n   APPLICATION_SPECIAL_DIRECTORY_ASSETS_RGUI_FONT,\n   APPLICATION_SPECIAL_DIRECTORY_ASSETS_SOUNDS,\n   APPLICATION_SPECIAL_DIRECTORY_ASSETS_SYSICONS,\n   APPLICATION_SPECIAL_DIRECTORY_THUMBNAILS_CHEEVOS_BADGES,\n   APPLICATION_SPECIAL_DIRECTORY_THUMBNAILS_DISCORD_AVATARS\n};\n\nbool fill_pathname_application_data(char *s, size_t len);\n\nsize_t fill_pathname_application_special(char *s, size_t len, enum application_special_type type);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "frontend",
          "type": "tree",
          "content": null
        },
        {
          "name": "gfx",
          "type": "tree",
          "content": null
        },
        {
          "name": "github-contributors.py",
          "type": "blob",
          "size": 3.0322265625,
          "content": "#!/usr/bin/python3\n#\n# Get list of repo contributors from GitHub using v4 GraphQL API\n#\n# Copyright (C) 2016-2019 - Brad Parker\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nfrom urllib.request import urlopen, Request\nimport json\nimport sys\n\n### SETTINGS ###\n# https://help.github.com/articles/creating-an-access-token-for-command-line-use/\n#TOKEN = 'Your access token here'\nif len(sys.argv) != 2:\n  print(f'Usage: {sys.argv[0]} [GitHub Access Token]')\n  exit()\n\nTOKEN = sys.argv[1];\n\norgName = 'libretro'\nrepoName = 'RetroArch'\n### END SETTINGS ###\n\n######\n\nlines = []\n\ndef get_contributors(after=None):\n  global lines\n  headers = {'Authorization': 'bearer ' + TOKEN}\n  url = 'https://api.github.com/graphql'\n\n  dataStr = \"\"\"{\n    repository(owner: \\\"\"\"\" + orgName + \"\"\"\\\", name: \\\"\"\"\" + repoName + \"\"\"\\\") {\n\"\"\"\n\n  if after:\n    dataStr += \"\"\"\n      mentionableUsers(first: 100 after:\\\"\"\"\" + after + \"\"\"\\\") {\n\"\"\"\n  else:\n    dataStr += \"\"\"\n      mentionableUsers(first: 100) {\n\"\"\"\n\n  dataStr += \"\"\"\n        edges {\n          node {\n            name\n            login\n          }\n          cursor\n        }\n      }\n    }\n  }\n\"\"\"\n\n  d = {'query': dataStr}\n\n  data = json.dumps(d).encode('utf-8')\n\n  req = Request(url, data, headers)\n\n  with urlopen(req) as resp:\n    d = resp.read()\n\n  j = json.loads(d)\n\n  if len(j['data']['repository']['mentionableUsers']['edges']) == 0:\n    return None\n\n  cursor = None\n\n  for key in j['data']['repository']['mentionableUsers']['edges']:\n    line = ''\n    name = None\n    login = None\n    node = key['node']\n\n    if 'name' in node and node['name'] and len(node['name']) > 0:\n      name = node['name']\n\n    if 'login' in node and node['login'] and len(node['login']) > 0:\n      login = node['login']\n\n    if 'cursor' in key and key['cursor'] and len(key['cursor']) > 0:\n      cursor = key['cursor']\n\n    if name:\n      line = name\n\n      if login and login.lower() != name.lower():\n        line += ' (' + login + ')'\n    elif login:\n      line = login\n    else:\n      continue\n\n    if len(line) > 0:\n      lines.append(line)\n\n  if cursor and len(cursor) > 0:\n    return cursor\n\ndef doit(cont):\n  after = get_contributors(cont)\n\n  if after:\n    doit(after)\n\ndoit(None)\n\n### File output\nf = open('AUTHORS.h', 'w', encoding='utf-8', newline='')\nf.write('static const char *retroarch_contributors_list = R\"(\\nRetroArch and the libretro team would like to\\nacknowledge the following contributors:\\n\\n');\nf.write('\\n'.join(sorted(lines, key=str.lower)))\nf.write('\\n)\\\";\\n')\nf.close()\n"
        },
        {
          "name": "griffin",
          "type": "tree",
          "content": null
        },
        {
          "name": "input",
          "type": "tree",
          "content": null
        },
        {
          "name": "intl",
          "type": "tree",
          "content": null
        },
        {
          "name": "lakka-switch.h",
          "type": "blob",
          "size": 1.8603515625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2023 - Gavin_Darkglider\n * \n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __RARCH_LAKKA_SWITCH_H\n#define __RARCH_LAKKA_SWITCH_H\n\n#define SWITCH_OC_TOGGLE_PATH \"/sys/kernel/tegra_cpufreq/overclock\"\n#define SWITCH_CEC_TOGGLE_PATH \"/tmp/.CEC\"\n#define SWITCH_GPU_PROFILE_FILE_MAX_PATH  \"/sys/devices/57000000.gpu/devfreq/57000000.gpu/max_freq\"\n#define SWITCH_GPU_PROFILE_FILE_MIN_PATH  \"/sys/devices/57000000.gpu/devfreq/57000000.gpu/min_freq\"\n#define SWITCH_GPU_PROFILE_FILE_GOVERNOR_PATH \"/sys/devices/57000000.gpu/devfreq/57000000.gpu/governor\"\n#define SWITCH_GPU_PROFILE_FILE_AVAILABLE_GOVERNORS_PATH \"/sys/devices/57000000.gpu/devfreq/57000000.gpu/available_governors\"\n#define SWITCH_GPU_PROFILE_FILE_AVAILABLE_FREQ_PATH \"/sys/devices/57000000.gpu/devfreq/57000000.gpu/available_governors\"\n\n#define BLUETOOTH_ERTM_TOGGLE_PATH \"/sys/module/bluetooth/parameters/disable_ertm\"\n\n#define SWITCH_R2P_ENABLED_PATH \"/sys/module/pmc_r2p/parameters/enabled\" \n#define SWITCH_R2P_ACTION_PATH /sys/module/pmc_r2p/parameters/action \n#define SWITCH_R2P_ENTRY_ID_PATH /sys/module/pmc_r2p/parameters/entry_id \n#define SWITCH_R2P_PARAM1_PATH /sys/module/pmc_r2p/parameters/param1\n#define SWITCH_R2P_PARAM2_PATH /sys/module/pmc_r2p/parameters/param2\n#endif\n"
        },
        {
          "name": "lakka.h",
          "type": "blob",
          "size": 1.353515625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2016 - Daniel De Matteis\n *  Copyright (C) 2014-2016 - Jean-Andr Santoni\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __RARCH_LAKKA_H\n#define __RARCH_LAKKA_H\n\n#define LAKKA_SSH_PATH       \"/storage/.cache/services/sshd.conf\"\n#define LAKKA_SAMBA_PATH     \"/storage/.cache/services/samba.conf\"\n#define LAKKA_BLUETOOTH_PATH \"/storage/.cache/services/bluez.conf\"\n#define LAKKA_UPDATE_DIR     \"/storage/.update/\"\n#define LAKKA_CONNMAN_DIR    \"/storage/.cache/connman/\"\n#define LAKKA_LOCALAP_PATH   \"/storage/.cache/services/localap.conf\"\n#define LAKKA_TIMEZONE_PATH  \"/storage/.cache/timezone\"\n\n#define DEFAULT_TIMEZONE \"UTC\"\n#define TIMEZONE_LENGTH 255\n\n#endif\n"
        },
        {
          "name": "led",
          "type": "tree",
          "content": null
        },
        {
          "name": "libretro-common",
          "type": "tree",
          "content": null
        },
        {
          "name": "libretro-db",
          "type": "tree",
          "content": null
        },
        {
          "name": "list_special.h",
          "type": "blob",
          "size": 2.0439453125,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _LIST_SPECIAL_H\n#define _LIST_SPECIAL_H\n\n#include <stdint.h>\n#include <stddef.h>\n\n#include <lists/string_list.h>\n#include <retro_environment.h>\n\nRETRO_BEGIN_DECLS\n\nenum dir_list_type\n{\n   DIR_LIST_NONE = 0,\n   DIR_LIST_CORES,\n   DIR_LIST_CORE_INFO,\n   DIR_LIST_DATABASES,\n   DIR_LIST_COLLECTIONS,\n   DIR_LIST_PLAIN,\n   DIR_LIST_SHADERS,\n   DIR_LIST_AUTOCONFIG,\n   DIR_LIST_RECURSIVE\n};\n\nenum string_list_type\n{\n   STRING_LIST_NONE = 0,\n   STRING_LIST_MENU_DRIVERS,\n   STRING_LIST_CAMERA_DRIVERS,\n   STRING_LIST_BLUETOOTH_DRIVERS,\n   STRING_LIST_WIFI_DRIVERS,\n   STRING_LIST_LOCATION_DRIVERS,\n   STRING_LIST_AUDIO_DRIVERS,\n#ifdef HAVE_MICROPHONE\n   STRING_LIST_MICROPHONE_DRIVERS,\n#endif\n   STRING_LIST_AUDIO_RESAMPLER_DRIVERS,\n   STRING_LIST_VIDEO_DRIVERS,\n   STRING_LIST_INPUT_DRIVERS,\n   STRING_LIST_INPUT_JOYPAD_DRIVERS,\n   STRING_LIST_INPUT_HID_DRIVERS,\n   STRING_LIST_RECORD_DRIVERS,\n   STRING_LIST_CLOUD_SYNC_DRIVERS,\n#ifdef HAVE_LAKKA\n   STRING_LIST_TIMEZONES,\n#endif\n   STRING_LIST_MIDI_DRIVERS\n};\n\nstruct string_list *dir_list_new_special(const char *input_dir,\n      enum dir_list_type type, const char *filter,\n      bool show_hidden_files);\n\nconst char *char_list_new_special(enum string_list_type type, void *data);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "location",
          "type": "tree",
          "content": null
        },
        {
          "name": "location_driver.h",
          "type": "blob",
          "size": 3.1005859375,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2018 The RetroArch team\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __LOCATION_DRIVER__H\n#define __LOCATION_DRIVER__H\n\n#include <boolean.h>\n#include <retro_common_api.h>\n\nRETRO_BEGIN_DECLS\n\ntypedef struct location_driver\n{\n   void *(*init)(void);\n   void (*free)(void *data);\n\n   bool (*start)(void *data);\n   void (*stop)(void *data);\n\n   bool (*get_position)(void *data, double *lat, double *lon,\n         double *horiz_accuracy, double *vert_accuracy);\n   void (*set_interval)(void *data, unsigned interval_msecs,\n         unsigned interval_distance);\n   const char *ident;\n} location_driver_t;\n\ntypedef struct\n{\n   const location_driver_t *driver;\n   void *data;\n   bool active;\n} location_driver_state_t;\n\n/**\n * config_get_location_driver_options:\n *\n * Get an enumerated list of all location driver names,\n * separated by '|'.\n *\n * Returns: string listing of all location driver names,\n * separated by '|'.\n **/\nconst char* config_get_location_driver_options(void);\n\n/**\n * driver_location_get_position:\n * @lat                : Latitude of current position.\n * @lon                : Longitude of current position.\n * @horiz_accuracy     : Horizontal accuracy.\n * @vert_accuracy      : Vertical accuracy.\n *\n * Gets current positioning information from\n * location driver interface.\n * Used by RETRO_ENVIRONMENT_GET_LOCATION_INTERFACE.\n *\n * Returns: bool (1) if successful, otherwise false (0).\n **/\nbool driver_location_get_position(double *lat, double *lon,\n      double *horiz_accuracy, double *vert_accuracy);\n\n/**\n * driver_location_set_interval:\n * @interval_msecs     : Interval time in milliseconds.\n * @interval_distance  : Distance at which to update.\n *\n * Sets interval update time for location driver interface.\n * Used by RETRO_ENVIRONMENT_GET_LOCATION_INTERFACE.\n **/\nvoid driver_location_set_interval(unsigned interval_msecs,\n      unsigned interval_distance);\n\n/**\n * driver_location_stop:\n *\n * Stops location driver interface..\n * Used by RETRO_ENVIRONMENT_GET_LOCATION_INTERFACE.\n *\n * Returns: true (1) if successful, otherwise false (0).\n **/\nvoid driver_location_stop(void);\n\n/**\n * driver_location_start:\n *\n * Starts location driver interface..\n * Used by RETRO_ENVIRONMENT_GET_LOCATION_INTERFACE.\n *\n * Returns: true (1) if successful, otherwise false (0).\n **/\nbool driver_location_start(void);\n\nlocation_driver_state_t *location_state_get_ptr(void);\n\nextern location_driver_t location_corelocation;\nextern location_driver_t location_android;\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "manual_content_scan.c",
          "type": "blob",
          "size": 42.462890625,
          "content": "/* Copyright  (C) 2010-2019 The RetroArch team\n *\n * ---------------------------------------------------------------------------------------\n * The following license statement only applies to this file (manual_content_scan.c).\n * ---------------------------------------------------------------------------------------\n *\n * Permission is hereby granted, free of charge,\n * to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <file/file_path.h>\n#include <file/archive_file.h>\n#include <string/stdstring.h>\n#include <lists/dir_list.h>\n#include <retro_miscellaneous.h>\n\n#include \"msg_hash.h\"\n#include \"list_special.h\"\n#include \"core_info.h\"\n#include \"file_path_special.h\"\n\n#include \"frontend/frontend_driver.h\"\n\n#include \"manual_content_scan.h\"\n\n/* Holds all configuration parameters associated\n * with a manual content scan */\ntypedef struct\n{\n   enum manual_content_scan_system_name_type system_name_type;\n   enum manual_content_scan_core_type core_type;\n\n   char core_path[PATH_MAX_LENGTH];\n   char file_exts_core[PATH_MAX_LENGTH];\n   char file_exts_custom[PATH_MAX_LENGTH];\n   char dat_file_path[PATH_MAX_LENGTH];\n   char content_dir[DIR_MAX_LENGTH];\n   char system_name_content_dir[DIR_MAX_LENGTH];\n   char system_name_database[NAME_MAX_LENGTH];\n   char system_name_custom[NAME_MAX_LENGTH];\n   char core_name[NAME_MAX_LENGTH];\n\n   bool search_recursively;\n   bool search_archives;\n   bool filter_dat_content;\n   bool overwrite_playlist;\n   bool validate_entries;\n} scan_settings_t;\n\n/* TODO/FIXME - static public global variables */\n/* Static settings object\n * > Provides easy access to settings parameters\n *   when creating associated menu entries\n * > We are handling this in almost exactly the same\n *   way as the regular global 'static settings_t *configuration_settings;'\n *   object in retroarch.c. This means it is not inherently thread safe,\n *   but this should not be an issue (i.e. regular configuration_settings\n *   are not thread safe, but we only access them when pushing a\n *   task, not in the task thread itself, so all is well) */\nstatic scan_settings_t scan_settings = {\n   MANUAL_CONTENT_SCAN_SYSTEM_NAME_CONTENT_DIR, /* system_name_type */\n   MANUAL_CONTENT_SCAN_CORE_DETECT,             /* core_type */\n   \"\",                                          /* content_dir */\n   \"\",                                          /* system_name_content_dir */\n   \"\",                                          /* system_name_database */\n   \"\",                                          /* system_name_custom */\n   \"\",                                          /* core_name */\n   \"\",                                          /* core_path */\n   \"\",                                          /* file_exts_core */\n   \"\",                                          /* file_exts_custom */\n   \"\",                                          /* dat_file_path */\n   true,                                        /* search_recursively */\n   false,                                       /* search_archives */\n   false,                                       /* filter_dat_content */\n   false,                                       /* overwrite_playlist */\n   false                                        /* validate_entries */\n};\n\n/*****************/\n/* Configuration */\n/*****************/\n\n/* Pointer access */\n\n/* Returns a pointer to the internal\n * 'content_dir' string */\nchar *manual_content_scan_get_content_dir_ptr(void)\n{\n   return scan_settings.content_dir;\n}\n\n/* Returns a pointer to the internal\n * 'system_name_custom' string */\nchar *manual_content_scan_get_system_name_custom_ptr(void)\n{\n   return scan_settings.system_name_custom;\n}\n\n/* Returns size of the internal\n * 'system_name_custom' string */\nsize_t manual_content_scan_get_system_name_custom_size(void)\n{\n   return sizeof(scan_settings.system_name_custom);\n}\n\n/* Returns a pointer to the internal\n * 'file_exts_custom' string */\nchar *manual_content_scan_get_file_exts_custom_ptr(void)\n{\n   return scan_settings.file_exts_custom;\n}\n\n/* Returns size of the internal\n * 'file_exts_custom' string */\nsize_t manual_content_scan_get_file_exts_custom_size(void)\n{\n   return sizeof(scan_settings.file_exts_custom);\n}\n\n/* Returns a pointer to the internal\n * 'dat_file_path' string */\nchar *manual_content_scan_get_dat_file_path_ptr(void)\n{\n   return scan_settings.dat_file_path;\n}\n\n/* Returns size of the internal\n * 'dat_file_path' string */\nsize_t manual_content_scan_get_dat_file_path_size(void)\n{\n   return sizeof(scan_settings.dat_file_path);\n}\n\n/* Returns a pointer to the internal\n * 'search_recursively' bool */\nbool *manual_content_scan_get_search_recursively_ptr(void)\n{\n   return &scan_settings.search_recursively;\n}\n\n/* Returns a pointer to the internal\n * 'search_archives' bool */\nbool *manual_content_scan_get_search_archives_ptr(void)\n{\n   return &scan_settings.search_archives;\n}\n\n/* Returns a pointer to the internal\n * 'filter_dat_content' bool */\nbool *manual_content_scan_get_filter_dat_content_ptr(void)\n{\n   return &scan_settings.filter_dat_content;\n}\n\n/* Returns a pointer to the internal\n * 'overwrite_playlist' bool */\nbool *manual_content_scan_get_overwrite_playlist_ptr(void)\n{\n   return &scan_settings.overwrite_playlist;\n}\n\n/* Returns a pointer to the internal\n * 'validate_entries' bool */\nbool *manual_content_scan_get_validate_entries_ptr(void)\n{\n   return &scan_settings.validate_entries;\n}\n\n/* Sanitisation */\n\n/* Sanitises file extensions list string:\n * > Removes period (full stop) characters\n * > Converts to lower case\n * > Trims leading/trailing whitespace */\nstatic void manual_content_scan_scrub_file_exts(char *file_exts)\n{\n   if (string_is_empty(file_exts))\n      return;\n\n   string_remove_all_chars(file_exts, '.');\n   string_to_lower(file_exts);\n   string_trim_whitespace_right(file_exts);\n   string_trim_whitespace_left(file_exts);\n}\n\n/* Removes invalid characters from\n * 'system_name_custom' string */\nvoid manual_content_scan_scrub_system_name_custom(void)\n{\n   char *scrub_char_pointer = NULL;\n   if (string_is_empty(scan_settings.system_name_custom))\n      return;\n   /* Scrub characters that are not cross-platform\n    * and/or violate the No-Intro filename standard:\n    * http://datomatic.no-intro.org/stuff/The%20Official%20No-Intro%20Convention%20(20071030).zip\n    * Replace these characters with underscores */\n   while ((scrub_char_pointer =\n            strpbrk(scan_settings.system_name_custom, \"&*/:`\\\"<>?\\\\|\")))\n      *scrub_char_pointer = '_';\n}\n\n/* Removes period (full stop) characters from\n * 'file_exts_custom' string and converts to\n * lower case */\nvoid manual_content_scan_scrub_file_exts_custom(void)\n{\n   manual_content_scan_scrub_file_exts(scan_settings.file_exts_custom);\n}\n\n/* Checks 'dat_file_path' string and resets it\n * if invalid */\nenum manual_content_scan_dat_file_path_status\n      manual_content_scan_validate_dat_file_path(void)\n{\n   enum manual_content_scan_dat_file_path_status dat_file_path_status =\n         MANUAL_CONTENT_SCAN_DAT_FILE_UNSET;\n\n   /* Check if 'dat_file_path' has been set */\n   if (!string_is_empty(scan_settings.dat_file_path))\n   {\n      uint64_t file_size;\n\n      /* Check if path itself is valid */\n      if (logiqx_dat_path_is_valid(scan_settings.dat_file_path, &file_size))\n      {\n         uint64_t free_memory = frontend_driver_get_free_memory();\n         dat_file_path_status = MANUAL_CONTENT_SCAN_DAT_FILE_OK;\n\n         /* DAT files can be *very* large...\n          * Try to enforce sane behaviour by requiring\n          * the system to have an amount of free memory\n          * at least twice the size of the DAT file...\n          * > Note that desktop (and probably mobile)\n          *   platforms should always have enough memory\n          *   for this - we're really only protecting the\n          *   console ports here */\n         if (free_memory > 0)\n         {\n            if (free_memory < (2 * file_size))\n               dat_file_path_status = MANUAL_CONTENT_SCAN_DAT_FILE_TOO_LARGE;\n         }\n         /* This is an annoying condition - it means the\n          * current platform doesn't have a 'free_memory'\n          * implementation...\n          * Have to make some assumptions in this case:\n          * > Typically the lowest system RAM of a supported\n          *   platform in 32MB\n          * > Propose that (2 * file_size) should be no more\n          *   than 1/4 of this total RAM value */\n         else if ((2 * file_size) > (8 * 1048576))\n            dat_file_path_status = MANUAL_CONTENT_SCAN_DAT_FILE_TOO_LARGE;\n      }\n      else\n         dat_file_path_status = MANUAL_CONTENT_SCAN_DAT_FILE_INVALID;\n   }\n\n   /* Reset 'dat_file_path' if status is anything other\n    * that 'OK' */\n   if (dat_file_path_status != MANUAL_CONTENT_SCAN_DAT_FILE_OK)\n      scan_settings.dat_file_path[0] = '\\0';\n\n   return dat_file_path_status;\n}\n\n/* Menu setters */\n\n/* Sets content directory for next manual scan\n * operation.\n * Returns true if content directory is valid. */\nbool manual_content_scan_set_menu_content_dir(const char *content_dir)\n{\n   size_t _len;\n   const char *dir_name = NULL;\n\n   /* Sanity check */\n   if (string_is_empty(content_dir))\n      goto error;\n\n   if (!path_is_directory(content_dir))\n      goto error;\n\n   /* Copy directory path to settings struct.\n    * Remove trailing slash, if required */\n   if ((_len = strlcpy(\n         scan_settings.content_dir, content_dir,\n         sizeof(scan_settings.content_dir))) <= 0)\n      goto error;\n\n   if (scan_settings.content_dir[_len - 1] == PATH_DEFAULT_SLASH_C())\n       scan_settings.content_dir[_len - 1] = '\\0';\n\n   /* Handle case where path was a single slash... */\n   if (string_is_empty(scan_settings.content_dir))\n      goto error;\n\n   /* Get directory name (used as system name\n    * when scan_settings.system_name_type ==\n    * MANUAL_CONTENT_SCAN_SYSTEM_NAME_CONTENT_DIR) */\n   dir_name = path_basename(scan_settings.content_dir);\n\n   if (string_is_empty(dir_name))\n      goto error;\n\n   /* Copy directory name to settings struct */\n   strlcpy(\n         scan_settings.system_name_content_dir,\n         dir_name,\n         sizeof(scan_settings.system_name_content_dir));\n\n   return true;\n\nerror:\n   /* Directory is invalid - reset internal\n    * content directory and associated 'directory'\n    * system name */\n   scan_settings.content_dir[0]             = '\\0';\n   scan_settings.system_name_content_dir[0] = '\\0';\n   return false;\n}\n\n/* Sets system name for the next manual scan\n * operation.\n * Returns true if system name is valid.\n * NOTE:\n * > Only sets 'system_name_type' and 'system_name_database'\n * > 'system_name_content_dir' and 'system_name_custom' are\n *   (by necessity) handled elsewhere\n * > This may look fishy, but it's not - it's a menu-specific\n *   function, and this is simply the cleanest way to handle\n *   the setting... */\nbool manual_content_scan_set_menu_system_name(\n      enum manual_content_scan_system_name_type system_name_type,\n      const char *system_name)\n{\n   /* Sanity check */\n   if (system_name_type > MANUAL_CONTENT_SCAN_SYSTEM_NAME_DATABASE)\n      goto error;\n\n   /* Cache system name 'type' */\n   scan_settings.system_name_type = system_name_type;\n\n   /* Check if we are using a non-database name */\n   if ((scan_settings.system_name_type == MANUAL_CONTENT_SCAN_SYSTEM_NAME_CONTENT_DIR) ||\n       (scan_settings.system_name_type == MANUAL_CONTENT_SCAN_SYSTEM_NAME_CUSTOM))\n      scan_settings.system_name_database[0] = '\\0';\n   else\n   {\n      /* We are using a database name... */\n      if (string_is_empty(system_name))\n         goto error;\n\n      /* Copy database name to settings struct */\n      strlcpy(\n            scan_settings.system_name_database,\n            system_name,\n            sizeof(scan_settings.system_name_database));\n   }\n\n   return true;\n\nerror:\n   /* Input parameters are invalid - reset internal\n    * 'system_name_type' and 'system_name_database' */\n   scan_settings.system_name_type        = MANUAL_CONTENT_SCAN_SYSTEM_NAME_CONTENT_DIR;\n   scan_settings.system_name_database[0] = '\\0';\n   return false;\n}\n\n/* Sets core name for the next manual scan\n * operation (+ core path and other associated\n * parameters).\n * Returns true if core name is valid. */\nbool manual_content_scan_set_menu_core_name(\n      enum manual_content_scan_core_type core_type,\n      const char *core_name)\n{\n   /* Sanity check */\n   if (core_type > MANUAL_CONTENT_SCAN_CORE_SET)\n      goto error;\n\n   /* Cache core 'type' */\n   scan_settings.core_type = core_type;\n\n   /* Check if we are using core autodetection */\n   if (scan_settings.core_type == MANUAL_CONTENT_SCAN_CORE_DETECT)\n   {\n      scan_settings.core_name[0]      = '\\0';\n      scan_settings.core_path[0]      = '\\0';\n      scan_settings.file_exts_core[0] = '\\0';\n   }\n   else\n   {\n      size_t i;\n      core_info_list_t *core_info_list = NULL;\n      core_info_t *core_info           = NULL;\n      bool core_found                  = false;\n\n      /* We are using a manually set core... */\n      if (string_is_empty(core_name))\n         goto error;\n\n      /* Get core list */\n      core_info_get_list(&core_info_list);\n\n      if (!core_info_list)\n         goto error;\n\n      /* Search for the specified core name */\n      for (i = 0; i < core_info_list->count; i++)\n      {\n         core_info = NULL;\n         core_info = core_info_get(core_info_list, i);\n\n         if (core_info)\n         {\n            if (string_is_equal(core_info->display_name, core_name))\n            {\n               /* Core has been found */\n               core_found = true;\n\n               /* Copy core path to settings struct */\n               if (string_is_empty(core_info->path))\n                  goto error;\n\n               strlcpy(\n                     scan_settings.core_path,\n                     core_info->path,\n                     sizeof(scan_settings.core_path));\n\n               /* Copy core name to settings struct */\n               strlcpy(\n                     scan_settings.core_name,\n                     core_info->display_name,\n                     sizeof(scan_settings.core_name));\n\n               /* Copy supported extensions to settings\n                * struct, if required */\n               if (!string_is_empty(core_info->supported_extensions))\n               {\n                  strlcpy(\n                        scan_settings.file_exts_core,\n                        core_info->supported_extensions,\n                        sizeof(scan_settings.file_exts_core));\n\n                  /* Core info extensions are delimited by\n                   * vertical bars. For internal consistency,\n                   * replace them with spaces */\n                  string_replace_all_chars(scan_settings.file_exts_core, '|', ' ');\n\n                  /* Apply standard scrubbing/clean-up\n                   * (should not be required, but must handle the\n                   * case where a core info file is incorrectly\n                   * formatted) */\n                  manual_content_scan_scrub_file_exts(scan_settings.file_exts_core);\n               }\n               else\n                  scan_settings.file_exts_core[0] = '\\0';\n\n               break;\n            }\n         }\n      }\n\n      /* Sanity check */\n      if (!core_found)\n         goto error;\n   }\n\n   return true;\n\nerror:\n   /* Input parameters are invalid - reset internal\n    * core values */\n   scan_settings.core_type         = MANUAL_CONTENT_SCAN_CORE_DETECT;\n   scan_settings.core_name[0]      = '\\0';\n   scan_settings.core_path[0]      = '\\0';\n   scan_settings.file_exts_core[0] = '\\0';\n   return false;\n}\n\n/* Sets all parameters for the next manual scan\n * operation according the to recorded values in\n * the specified playlist.\n * Returns MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_OK\n * if playlist contains a valid scan record. */\nenum manual_content_scan_playlist_refresh_status\n      manual_content_scan_set_menu_from_playlist(playlist_t *playlist,\n            const char *path_content_database, bool show_hidden_files)\n{\n   const char *playlist_path    = NULL;\n   const char *content_dir      = NULL;\n   const char *core_name        = NULL;\n   const char *file_exts        = NULL;\n   const char *dat_file_path    = NULL;\n   bool search_recursively      = false;\n   bool search_archives         = false;\n   bool filter_dat_content      = false;\n   bool overwrite_playlist      = false;\n#ifdef HAVE_LIBRETRODB\n   struct string_list *rdb_list = NULL;\n#endif\n   enum manual_content_scan_system_name_type\n         system_name_type       = MANUAL_CONTENT_SCAN_SYSTEM_NAME_CONTENT_DIR;\n   enum manual_content_scan_core_type\n         core_type              = MANUAL_CONTENT_SCAN_CORE_DETECT;\n   enum manual_content_scan_playlist_refresh_status\n         playlist_status        = MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_OK;\n   char system_name[NAME_MAX_LENGTH];\n\n   if (!playlist_scan_refresh_enabled(playlist))\n   {\n      playlist_status = MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_MISSING_CONFIG;\n      goto end;\n   }\n\n   /* Read scan parameters from playlist */\n   playlist_path      = playlist_get_conf_path(playlist);\n   content_dir        = playlist_get_scan_content_dir(playlist);\n   core_name          = playlist_get_default_core_name(playlist);\n   file_exts          = playlist_get_scan_file_exts(playlist);\n   dat_file_path      = playlist_get_scan_dat_file_path(playlist);\n\n   search_recursively = playlist_get_scan_search_recursively(playlist);\n   search_archives    = playlist_get_scan_search_archives(playlist);\n   filter_dat_content = playlist_get_scan_filter_dat_content(playlist);\n   overwrite_playlist = playlist_get_scan_overwrite_playlist(playlist);\n\n   /* Determine system name (playlist basename\n    * without extension) */\n   if (string_is_empty(playlist_path))\n   {\n      /* Cannot happen, but would constitute a\n       * 'system name' error */\n      playlist_status = MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_INVALID_SYSTEM_NAME;\n      goto end;\n   }\n\n   fill_pathname(system_name, path_basename(playlist_path),\n         \"\", sizeof(system_name));\n\n   if (string_is_empty(system_name))\n   {\n      /* Cannot happen, but would constitute a\n       * 'system name' error */\n      playlist_status = MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_INVALID_SYSTEM_NAME;\n      goto end;\n   }\n\n   /* Set content directory */\n   if (!manual_content_scan_set_menu_content_dir(content_dir))\n   {\n      playlist_status = MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_INVALID_CONTENT_DIR;\n      goto end;\n   }\n\n   /* Set system name */\n#ifdef HAVE_LIBRETRODB\n   /* > If platform has database support, get names\n    *   of all installed database files */\n   rdb_list = dir_list_new_special(\n         path_content_database,\n         DIR_LIST_DATABASES, NULL, show_hidden_files);\n\n   if (rdb_list && rdb_list->size)\n   {\n      size_t i;\n\n      /* Loop over database files */\n      for (i = 0; i < rdb_list->size; i++)\n      {\n         char rdb_name[NAME_MAX_LENGTH];\n         const char *rdb_path = rdb_list->elems[i].data;\n         /* Sanity check */\n         if (string_is_empty(rdb_path))\n            continue;\n         fill_pathname(rdb_name, path_basename(rdb_path), \"\",\n               sizeof(rdb_name));\n         if (string_is_empty(rdb_name))\n            continue;\n         /* Check whether playlist system name\n          * matches current database file */\n         if (string_is_equal(system_name, rdb_name))\n         {\n            system_name_type = MANUAL_CONTENT_SCAN_SYSTEM_NAME_DATABASE;\n            break;\n         }\n      }\n   }\n\n   string_list_free(rdb_list);\n#endif\n\n   /* > If system name does not match a database\n    *   file, then check whether it matches the\n    *   content directory name */\n   if (system_name_type !=\n         MANUAL_CONTENT_SCAN_SYSTEM_NAME_DATABASE)\n   {\n      /* system_name_type is set to\n       * MANUAL_CONTENT_SCAN_SYSTEM_NAME_CONTENT_DIR\n       * by default - so if a match is found just\n       * reset 'custom name' field */\n      if (string_is_equal(system_name,\n            scan_settings.system_name_content_dir))\n         scan_settings.system_name_custom[0] = '\\0';\n      else\n      {\n         /* Playlist is using a custom system name */\n         system_name_type = MANUAL_CONTENT_SCAN_SYSTEM_NAME_CUSTOM;\n         strlcpy(scan_settings.system_name_custom, system_name,\n               sizeof(scan_settings.system_name_custom));\n      }\n   }\n\n   if (!manual_content_scan_set_menu_system_name(\n         system_name_type, system_name))\n   {\n      playlist_status = MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_INVALID_SYSTEM_NAME;\n      goto end;\n   }\n\n   /* Set core path/name */\n   if (   !string_is_empty(core_name)\n       && !string_is_equal(core_name, FILE_PATH_DETECT))\n      core_type = MANUAL_CONTENT_SCAN_CORE_SET;\n\n   if (!manual_content_scan_set_menu_core_name(\n         core_type, core_name))\n   {\n      playlist_status = MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_INVALID_CORE;\n      goto end;\n   }\n\n   /* Set custom file extensions */\n   if (string_is_empty(file_exts))\n      scan_settings.file_exts_custom[0] = '\\0';\n   else\n   {\n      strlcpy(scan_settings.file_exts_custom, file_exts,\n            sizeof(scan_settings.file_exts_custom));\n\n      /* File extensions read from playlist should\n       * be correctly formatted, with '|' characters\n       * as delimiters\n       * > For menu purposes, must replace these\n       *   delimiters with space characters\n       * > Additionally scrub the resultant string,\n       *   to handle the case where a user has\n       *   'corrupted' it by manually tampering with\n       *   the playlist file */\n      string_replace_all_chars(scan_settings.file_exts_custom, '|', ' ');\n      manual_content_scan_scrub_file_exts(scan_settings.file_exts_custom);\n   }\n\n   /* Set DAT file path */\n   if (string_is_empty(dat_file_path))\n      scan_settings.dat_file_path[0] = '\\0';\n   else\n   {\n      strlcpy(scan_settings.dat_file_path, dat_file_path,\n            sizeof(scan_settings.dat_file_path));\n\n      switch (manual_content_scan_validate_dat_file_path())\n      {\n         case MANUAL_CONTENT_SCAN_DAT_FILE_INVALID:\n            playlist_status = MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_INVALID_DAT_FILE;\n            goto end;\n         case MANUAL_CONTENT_SCAN_DAT_FILE_TOO_LARGE:\n            playlist_status = MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_DAT_FILE_TOO_LARGE;\n            goto end;\n         default:\n            /* No action required */\n            break;\n      }\n   }\n\n   /* Set remaining boolean parameters */\n   scan_settings.search_recursively = search_recursively;\n   scan_settings.search_archives    = search_archives;\n   scan_settings.filter_dat_content = filter_dat_content;\n   scan_settings.overwrite_playlist = overwrite_playlist;\n   /* When refreshing a playlist:\n    * > We always validate entries in the\n    *   existing file */\n   scan_settings.validate_entries   = true;\n\nend:\n   return playlist_status;\n}\n\n/* Menu getters */\n\n/* Fetches content directory for next manual scan\n * operation.\n * Returns true if content directory is valid. */\nbool manual_content_scan_get_menu_content_dir(const char **content_dir)\n{\n   if (!content_dir)\n      return false;\n   if (string_is_empty(scan_settings.content_dir))\n      return false;\n   *content_dir = scan_settings.content_dir;\n   return true;\n}\n\n/* Fetches system name for the next manual scan operation.\n * Returns true if system name is valid.\n * NOTE: This corresponds to the 'System Name' value\n * displayed in menus - this is not identical to the\n * actual system name used when generating the playlist */\nbool manual_content_scan_get_menu_system_name(const char **system_name)\n{\n   if (system_name)\n   {\n      switch (scan_settings.system_name_type)\n      {\n         case MANUAL_CONTENT_SCAN_SYSTEM_NAME_CONTENT_DIR:\n            *system_name = msg_hash_to_str(\n                  MENU_ENUM_LABEL_VALUE_MANUAL_CONTENT_SCAN_SYSTEM_NAME_USE_CONTENT_DIR);\n            return true;\n         case MANUAL_CONTENT_SCAN_SYSTEM_NAME_CUSTOM:\n            *system_name = msg_hash_to_str(\n                  MENU_ENUM_LABEL_VALUE_MANUAL_CONTENT_SCAN_SYSTEM_NAME_USE_CUSTOM);\n            return true;\n         case MANUAL_CONTENT_SCAN_SYSTEM_NAME_DATABASE:\n            if (!string_is_empty(scan_settings.system_name_database))\n            {\n               *system_name = scan_settings.system_name_database;\n               return true;\n            }\n            break;\n         default:\n            break;\n      }\n   }\n\n   return false;\n}\n\n/* Fetches core name for the next manual scan operation.\n * Returns true if core name is valid. */\nbool manual_content_scan_get_menu_core_name(const char **core_name)\n{\n   if (core_name)\n   {\n      switch (scan_settings.core_type)\n      {\n         case MANUAL_CONTENT_SCAN_CORE_DETECT:\n            *core_name = msg_hash_to_str(\n                  MENU_ENUM_LABEL_VALUE_MANUAL_CONTENT_SCAN_CORE_NAME_DETECT);\n            return true;\n         case MANUAL_CONTENT_SCAN_CORE_SET:\n            if (!string_is_empty(scan_settings.core_name))\n            {\n               *core_name = scan_settings.core_name;\n               return true;\n            }\n            break;\n         default:\n            break;\n      }\n   }\n\n   return false;\n}\n\n/* Menu utility functions */\n\n/* Creates a list of all possible 'system name' menu\n * strings, for use in 'menu_displaylist' drop-down\n * lists and 'menu_cbs_left/right'\n * > Returns NULL in the event of failure\n * > Returned string list must be free()'d */\nstruct string_list *manual_content_scan_get_menu_system_name_list(\n      const char *path_content_database, bool show_hidden_files)\n{\n   union string_list_elem_attr attr;\n   struct string_list *name_list = string_list_new();\n\n   /* Sanity check */\n   if (!name_list)\n      return NULL;\n\n   attr.i = 0;\n\n   /* Add 'use content directory' entry */\n   if (!string_list_append(name_list, msg_hash_to_str(\n         MENU_ENUM_LABEL_VALUE_MANUAL_CONTENT_SCAN_SYSTEM_NAME_USE_CONTENT_DIR), attr))\n      goto error;\n\n   /* Add 'use custom' entry */\n   if (!string_list_append(name_list, msg_hash_to_str(\n         MENU_ENUM_LABEL_VALUE_MANUAL_CONTENT_SCAN_SYSTEM_NAME_USE_CUSTOM), attr))\n      goto error;\n\n#ifdef HAVE_LIBRETRODB\n   /* If platform has database support, get names\n    * of all installed database files */\n   {\n      /* Note: dir_list_new_special() is well behaved - the\n       * returned string list will only include database\n       * files (i.e. don't have to check for directories,\n       * or verify file extensions) */\n      struct string_list *rdb_list = dir_list_new_special(\n            path_content_database,\n            DIR_LIST_DATABASES, NULL, show_hidden_files);\n\n      if (rdb_list && rdb_list->size)\n      {\n         unsigned i;\n\n         /* Ensure database list is in alphabetical order */\n         dir_list_sort(rdb_list, true);\n\n         /* Loop over database files */\n         for (i = 0; i < rdb_list->size; i++)\n         {\n            char rdb_name[NAME_MAX_LENGTH];\n            const char *rdb_path = rdb_list->elems[i].data;\n            /* Sanity check */\n            if (string_is_empty(rdb_path))\n               continue;\n            fill_pathname(rdb_name, path_basename(rdb_path), \"\",\n                  sizeof(rdb_name));\n            if (string_is_empty(rdb_name))\n               continue;\n            /* Add database name to list */\n            if (!string_list_append(name_list, rdb_name, attr))\n               goto error;\n         }\n      }\n\n      /* Clean up */\n      string_list_free(rdb_list);\n   }\n\n#endif\n\n   return name_list;\n\nerror:\n   if (name_list)\n      string_list_free(name_list);\n   return NULL;\n}\n\n/* Creates a list of all possible 'core name' menu\n * strings, for use in 'menu_displaylist' drop-down\n * lists and 'menu_cbs_left/right'\n * > Returns NULL in the event of failure\n * > Returned string list must be free()'d */\nstruct string_list *manual_content_scan_get_menu_core_name_list(void)\n{\n   union string_list_elem_attr attr;\n   struct string_list *name_list    = string_list_new();\n   core_info_list_t *core_info_list = NULL;\n\n   /* Sanity check */\n   if (!name_list)\n      return NULL;\n\n   attr.i = 0;\n\n   /* Add 'DETECT' entry */\n   if (!string_list_append(name_list, msg_hash_to_str(\n         MENU_ENUM_LABEL_VALUE_MANUAL_CONTENT_SCAN_CORE_NAME_DETECT), attr))\n      goto error;\n\n   /* Get core list */\n   core_info_get_list(&core_info_list);\n\n   if (core_info_list)\n   {\n      size_t i;\n      core_info_t *core_info = NULL;\n\n      /* Sort cores alphabetically */\n      core_info_qsort(core_info_list, CORE_INFO_LIST_SORT_DISPLAY_NAME);\n\n      /* Loop through cores */\n      for (i = 0; i < core_info_list->count; i++)\n      {\n         if ((core_info = core_info_get(core_info_list, i)))\n         {\n            if (string_is_empty(core_info->display_name))\n               continue;\n            /* Add core name to list */\n            if (!string_list_append(name_list, core_info->display_name, attr))\n               goto error;\n         }\n      }\n   }\n\n   return name_list;\n\nerror:\n   if (name_list)\n      string_list_free(name_list);\n   return NULL;\n}\n\n/****************/\n/* Task Helpers */\n/****************/\n\n/* Parses current manual content scan settings,\n * and extracts all information required to configure\n * a manual content scan task.\n * Returns false if current settings are invalid. */\nbool manual_content_scan_get_task_config(\n      manual_content_scan_task_config_t *task_config,\n      const char *path_dir_playlist)\n{\n   size_t _len;\n   if (!task_config)\n      return false;\n\n   /* Ensure all 'task_config' strings are\n    * correctly initialised */\n   task_config->playlist_file[0] = '\\0';\n   task_config->content_dir[0]   = '\\0';\n   task_config->system_name[0]   = '\\0';\n   task_config->database_name[0] = '\\0';\n   task_config->core_name[0]     = '\\0';\n   task_config->core_path[0]     = '\\0';\n   task_config->file_exts[0]     = '\\0';\n   task_config->dat_file_path[0] = '\\0';\n\n   /* Get content directory */\n   if (string_is_empty(scan_settings.content_dir))\n      return false;\n\n   if (!path_is_directory(scan_settings.content_dir))\n      return false;\n\n   strlcpy(\n         task_config->content_dir,\n         scan_settings.content_dir,\n         sizeof(task_config->content_dir));\n\n   /* Get system name */\n   switch (scan_settings.system_name_type)\n   {\n      case MANUAL_CONTENT_SCAN_SYSTEM_NAME_CONTENT_DIR:\n         if (string_is_empty(scan_settings.system_name_content_dir))\n            return false;\n         strlcpy(\n               task_config->system_name,\n               scan_settings.system_name_content_dir,\n               sizeof(task_config->system_name));\n         break;\n      case MANUAL_CONTENT_SCAN_SYSTEM_NAME_CUSTOM:\n         if (string_is_empty(scan_settings.system_name_custom))\n            return false;\n         strlcpy(\n               task_config->system_name,\n               scan_settings.system_name_custom,\n               sizeof(task_config->system_name));\n         break;\n      case MANUAL_CONTENT_SCAN_SYSTEM_NAME_DATABASE:\n         if (string_is_empty(scan_settings.system_name_database))\n            return false;\n         strlcpy(\n               task_config->system_name,\n               scan_settings.system_name_database,\n               sizeof(task_config->system_name));\n         break;\n      default:\n         return false;\n   }\n\n   /* Now we have a valid system name, can generate\n    * a 'database' name... */\n   _len = strlcpy(\n         task_config->database_name,\n         task_config->system_name,\n         sizeof(task_config->database_name));\n   strlcpy(task_config->database_name       + _len,\n         \".lpl\",\n         sizeof(task_config->database_name) - _len);\n\n   /* ...which can in turn be used to generate the\n    * playlist path */\n   if (string_is_empty(path_dir_playlist))\n      return false;\n\n   fill_pathname_join_special(\n         task_config->playlist_file,\n         path_dir_playlist,\n         task_config->database_name,\n         sizeof(task_config->playlist_file));\n\n   if (string_is_empty(task_config->playlist_file))\n      return false;\n\n   /* Get core name and path */\n   switch (scan_settings.core_type)\n   {\n      case MANUAL_CONTENT_SCAN_CORE_DETECT:\n         task_config->core_set = false;\n         break;\n      case MANUAL_CONTENT_SCAN_CORE_SET:\n         task_config->core_set = true;\n\n         if (string_is_empty(scan_settings.core_name))\n            return false;\n         if (string_is_empty(scan_settings.core_path))\n            return false;\n\n         strlcpy(\n               task_config->core_name,\n               scan_settings.core_name,\n               sizeof(task_config->core_name));\n\n         strlcpy(\n               task_config->core_path,\n               scan_settings.core_path,\n               sizeof(task_config->core_path));\n\n         break;\n      default:\n         return false;\n   }\n\n   /* Get file extensions list */\n   task_config->file_exts_custom_set = false;\n   if (!string_is_empty(scan_settings.file_exts_custom))\n   {\n      task_config->file_exts_custom_set = true;\n      strlcpy(\n            task_config->file_exts,\n            scan_settings.file_exts_custom,\n            sizeof(task_config->file_exts));\n   }\n   else if (scan_settings.core_type == MANUAL_CONTENT_SCAN_CORE_SET)\n      if (!string_is_empty(scan_settings.file_exts_core))\n         strlcpy(\n               task_config->file_exts,\n               scan_settings.file_exts_core,\n               sizeof(task_config->file_exts));\n\n   /* Our extension lists are space delimited\n    * > dir_list_new() expects vertical bar\n    *   delimiters, so find and replace */\n   if (!string_is_empty(task_config->file_exts))\n      string_replace_all_chars(task_config->file_exts, ' ', '|');\n\n   /* Get DAT file path */\n   if (!string_is_empty(scan_settings.dat_file_path))\n   {\n      if (!logiqx_dat_path_is_valid(scan_settings.dat_file_path, NULL))\n         return false;\n      strlcpy(\n            task_config->dat_file_path,\n            scan_settings.dat_file_path,\n            sizeof(task_config->dat_file_path));\n   }\n\n   /* Copy 'search recursively' setting */\n   task_config->search_recursively = scan_settings.search_recursively;\n   /* Copy 'search inside archives' setting */\n   task_config->search_archives    = scan_settings.search_archives;\n   /* Copy 'DAT file filter' setting */\n   task_config->filter_dat_content = scan_settings.filter_dat_content;\n   /* Copy 'overwrite playlist' setting */\n   task_config->overwrite_playlist = scan_settings.overwrite_playlist;\n   /* Copy 'validate_entries' setting */\n   task_config->validate_entries   = scan_settings.validate_entries;\n\n   return true;\n}\n\n/* Creates a list of all valid content in the specified\n * content directory\n * > Returns NULL in the event of failure\n * > Returned string list must be free()'d */\nstruct string_list *manual_content_scan_get_content_list(\n      manual_content_scan_task_config_t *task_config)\n{\n   bool filter_exts;\n   bool include_compressed;\n   struct string_list *dir_list = NULL;\n\n   /* Sanity check */\n   if (!task_config)\n      goto error;\n   if (string_is_empty(task_config->content_dir))\n      goto error;\n\n   /* Check whether files should be filtered by\n    * extension */\n   filter_exts = !string_is_empty(task_config->file_exts);\n\n   /* Check whether compressed files should be\n    * included in the directory list\n    * > If compressed files are already listed in\n    *   the 'file_exts' string, they will be included\n    *   automatically\n    * > If we don't have a 'file_exts' list, then all\n    *   files must be included regardless of type\n    * > If user has enabled 'search inside archives',\n    *   then compressed files must of course be included */\n   include_compressed = (!filter_exts || task_config->search_archives);\n\n   /* Get directory listing\n    * > Exclude directories and hidden files */\n   dir_list = dir_list_new(\n         task_config->content_dir,\n         filter_exts ? task_config->file_exts : NULL,\n         false, /* include_dirs */\n         false, /* include_hidden */\n         include_compressed,\n         task_config->search_recursively\n   );\n\n   /* Sanity check */\n   if (!dir_list || dir_list->size < 1)\n      goto error;\n\n   /* Ensure list is in alphabetical order\n    * > Not strictly required, but task status\n    *   messages will be unintuitive if we leave\n    *   the order 'random' */\n   dir_list_sort(dir_list, true);\n\n   return dir_list;\n\nerror:\n   if (dir_list)\n      string_list_free(dir_list);\n   return NULL;\n}\n\n/* Converts specified content path string to 'real'\n * file path for use in playlists - i.e. handles\n * identification of content *inside* archive files.\n * Returns false if specified content is invalid. */\nstatic bool manual_content_scan_get_playlist_content_path(\n      manual_content_scan_task_config_t *task_config,\n      const char *content_path, int content_type,\n      char *s, size_t len)\n{\n   size_t _len;\n   struct string_list *archive_list = NULL;\n   /* Sanity check */\n   if (!task_config || string_is_empty(content_path))\n      return false;\n   if (!path_is_valid(content_path))\n      return false;\n   /* In all cases, base content path must be\n    * copied to @s */\n   _len = strlcpy(s, content_path, len);\n   /* Check whether this is an archive file\n    * requiring special attention... */\n   if (  (content_type == RARCH_COMPRESSED_ARCHIVE)\n       && task_config->search_archives)\n   {\n      bool filter_exts         = !string_is_empty(task_config->file_exts);\n      const char *archive_file = NULL;\n\n      /* Important note:\n       * > If an archive file of a particular type is\n       *   included in the task_config->file_exts list,\n       *   dir_list_new() will assign it a file type of\n       *   RARCH_PLAIN_FILE\n       * > Thus we will only reach this point if\n       *   (a) We are not filtering by extension\n       *   (b) This is an archive file type *not*\n       *       already included in the supported\n       *       extensions list\n       * > These guarantees substantially reduce the\n       *   complexity of the following code... */\n\n      /* Get archive file contents */\n      if (!(archive_list = file_archive_get_file_list(\n            content_path, filter_exts ? task_config->file_exts : NULL)))\n         goto error;\n\n      if (archive_list->size < 1)\n         goto error;\n\n      /* Get first file contained in archive */\n      dir_list_sort(archive_list, true);\n      archive_file = archive_list->elems[0].data;\n      if (string_is_empty(archive_file))\n         goto error;\n\n      /* Have to take care to ensure that we don't make\n       * a mess of arcade content...\n       * > If we are filtering by extension, then the\n       *   archive file itself is *not* valid content,\n       *   so link to the first file inside the archive\n       * > If we are not filtering by extension, then:\n       *   - If archive contains one valid file, assume\n       *     it is a compressed ROM\n       *   - If archive contains multiple files, have to\n       *     assume it is MAME/FBA-style content, where\n       *     only the archive itself is valid */\n      if (filter_exts || (archive_list->size == 1))\n      {\n         /* Build path to file inside archive */\n         s[  _len] = '#';\n         s[++_len] = '\\0';\n         strlcpy(s + _len, archive_file, len - _len);\n      }\n\n      string_list_free(archive_list);\n   }\n\n   return true;\n\nerror:\n   if (archive_list)\n      string_list_free(archive_list);\n   return false;\n}\n\n/* Extracts content 'label' (name) from content path\n * > If a DAT file is specified, performs a lookup\n *   of content file name in an attempt to find a\n *   valid 'description' string.\n * Returns false if specified content is invalid. */\nstatic bool manual_content_scan_get_playlist_content_label(\n      const char *content_path, logiqx_dat_t *dat_file,\n      bool filter_dat_content,\n      char *s, size_t len)\n{\n   /* Sanity check */\n   if (string_is_empty(content_path))\n      return false;\n\n   /* In most cases, content label is just the\n    * filename without extension */\n   fill_pathname(s, path_basename(content_path),\n         \"\", len);\n\n   if (string_is_empty(s))\n      return false;\n\n   /* Check if a DAT file has been specified */\n   if (dat_file)\n   {\n      logiqx_dat_game_info_t game_info;\n\n      /* Search for current content\n       * > If content is not listed in DAT file,\n       *   use existing filename without extension */\n      if (logiqx_dat_search(dat_file, s, &game_info))\n      {\n         /* BIOS files should always be skipped */\n         if (game_info.is_bios)\n            return false;\n         /* Only include 'runnable' content */\n         if (!game_info.is_runnable)\n            return false;\n         /* Copy game description */\n         if (!string_is_empty(game_info.description))\n         {\n            strlcpy(s, game_info.description, len);\n            return true;\n         }\n      }\n\n      /* If we are applying a DAT file filter,\n       * unlisted content should be skipped */\n      if (filter_dat_content)\n         return false;\n   }\n   return true;\n}\n\n/* Adds specified content to playlist, if not already\n * present */\nvoid manual_content_scan_add_content_to_playlist(\n      manual_content_scan_task_config_t *task_config,\n      playlist_t *playlist, const char *content_path,\n      int content_type, logiqx_dat_t *dat_file)\n{\n   char playlist_content_path[PATH_MAX_LENGTH];\n\n   /* Sanity check */\n   if (!task_config || !playlist)\n      return;\n\n   /* Get 'actual' content path */\n   if (!manual_content_scan_get_playlist_content_path(\n         task_config, content_path, content_type,\n         playlist_content_path, sizeof(playlist_content_path)))\n      return;\n\n   /* Check whether content is already included\n    * in playlist */\n   if (!playlist_entry_exists(playlist, playlist_content_path))\n   {\n      char label[NAME_MAX_LENGTH];\n      struct playlist_entry entry = {0};\n\n      label[0] = '\\0';\n\n      /* Get entry label */\n      if (!manual_content_scan_get_playlist_content_label(\n            playlist_content_path, dat_file,\n            task_config->filter_dat_content,\n            label, sizeof(label)))\n         return;\n\n      /* Configure playlist entry\n       * > The push function reads our entry as const,\n       *   so these casts are safe */\n      entry.path       = (char*)playlist_content_path;\n      entry.label      = label;\n      entry.core_path  = (char*)FILE_PATH_DETECT;\n      entry.core_name  = (char*)FILE_PATH_DETECT;\n      entry.crc32      = (char*)\"00000000|crc\";\n      entry.db_name    = task_config->database_name;\n      entry.entry_slot = 0;\n\n      /* Add entry to playlist */\n      playlist_push(playlist, &entry);\n   }\n}\n"
        },
        {
          "name": "manual_content_scan.h",
          "type": "blob",
          "size": 9.5,
          "content": "/* Copyright  (C) 2010-2019 The RetroArch team\n *\n * ---------------------------------------------------------------------------------------\n * The following license statement only applies to this file (manual_content_scan.c).\n * ---------------------------------------------------------------------------------------\n *\n * Permission is hereby granted, free of charge,\n * to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#ifndef __MANUAL_CONTENT_SCAN_H\n#define __MANUAL_CONTENT_SCAN_H\n\n#include <retro_common_api.h>\n#include <libretro.h>\n\n#include <boolean.h>\n\n#include <lists/string_list.h>\n#include <formats/logiqx_dat.h>\n\n#include \"playlist.h\"\n\nRETRO_BEGIN_DECLS\n\n/* Defines all possible system name types\n * > Use content directory name\n * > Use custom name\n * > Use database name */\nenum manual_content_scan_system_name_type\n{\n   MANUAL_CONTENT_SCAN_SYSTEM_NAME_CONTENT_DIR = 0,\n   MANUAL_CONTENT_SCAN_SYSTEM_NAME_CUSTOM,\n   MANUAL_CONTENT_SCAN_SYSTEM_NAME_DATABASE\n};\n\n/* Defines all possible core name types\n * > Autodetect core (DETECT)\n * > Use manually set core */\nenum manual_content_scan_core_type\n{\n   MANUAL_CONTENT_SCAN_CORE_DETECT = 0,\n   MANUAL_CONTENT_SCAN_CORE_SET\n};\n\n/* Defines all possible return values for\n * manual_content_scan_validate_dat_file_path() */\nenum manual_content_scan_dat_file_path_status\n{\n   MANUAL_CONTENT_SCAN_DAT_FILE_UNSET = 0,\n   MANUAL_CONTENT_SCAN_DAT_FILE_OK,\n   MANUAL_CONTENT_SCAN_DAT_FILE_INVALID,\n   MANUAL_CONTENT_SCAN_DAT_FILE_TOO_LARGE\n};\n\n/* Defines all possible return values for\n * manual_content_scan_set_menu_from_playlist() */\nenum manual_content_scan_playlist_refresh_status\n{\n   MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_OK = 0,\n   MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_MISSING_CONFIG,\n   MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_INVALID_CONTENT_DIR,\n   MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_INVALID_SYSTEM_NAME,\n   MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_INVALID_CORE,\n   MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_INVALID_DAT_FILE,\n   MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_DAT_FILE_TOO_LARGE\n};\n\n/* Holds all configuration parameters required\n * for a manual content scan task */\ntypedef struct\n{\n   char core_name[NAME_MAX_LENGTH];\n   char system_name[NAME_MAX_LENGTH];\n   char database_name[NAME_MAX_LENGTH];\n   char content_dir[DIR_MAX_LENGTH];\n   char playlist_file[PATH_MAX_LENGTH];\n   char core_path[PATH_MAX_LENGTH];\n   char file_exts[PATH_MAX_LENGTH];\n   char dat_file_path[PATH_MAX_LENGTH];\n   bool core_set;\n   bool file_exts_custom_set;\n   bool search_recursively;\n   bool search_archives;\n   bool filter_dat_content;\n   bool overwrite_playlist;\n   bool validate_entries;\n} manual_content_scan_task_config_t;\n\n/*****************/\n/* Configuration */\n/*****************/\n\n/* Pointer access\n * > This is a little ugly, but it allows us to\n *   make use of standard 'menu_settings' code\n *   for several config parameters (rather than\n *   implementing unnecessary custom menu entries) */\n\n/* Returns a pointer to the internal\n * 'content_dir' string */\nchar *manual_content_scan_get_content_dir_ptr(void);\n\n/* Returns a pointer to the internal\n * 'system_name_custom' string */\nchar *manual_content_scan_get_system_name_custom_ptr(void);\n\n/* Returns size of the internal\n * 'system_name_custom' string */\nsize_t manual_content_scan_get_system_name_custom_size(void);\n\n/* Returns a pointer to the internal\n * 'file_exts_custom' string */\nchar *manual_content_scan_get_file_exts_custom_ptr(void);\n\n/* Returns size of the internal\n * 'file_exts_custom' string */\nsize_t manual_content_scan_get_file_exts_custom_size(void);\n\n/* Returns a pointer to the internal\n * 'dat_file_path' string */\nchar *manual_content_scan_get_dat_file_path_ptr(void);\n\n/* Returns size of the internal\n * 'dat_file_path' string */\nsize_t manual_content_scan_get_dat_file_path_size(void);\n\n/* Returns a pointer to the internal\n * 'search_recursively' bool */\nbool *manual_content_scan_get_search_recursively_ptr(void);\n\n/* Returns a pointer to the internal\n * 'search_archives' bool */\nbool *manual_content_scan_get_search_archives_ptr(void);\n\n/* Returns a pointer to the internal\n * 'filter_dat_content' bool */\nbool *manual_content_scan_get_filter_dat_content_ptr(void);\n\n/* Returns a pointer to the internal\n * 'overwrite_playlist' bool */\nbool *manual_content_scan_get_overwrite_playlist_ptr(void);\n\n/* Returns a pointer to the internal\n * 'validate_entries' bool */\nbool *manual_content_scan_get_validate_entries_ptr(void);\n\n/* Sanitisation */\n\n/* Removes invalid characters from\n * 'system_name_custom' string */\nvoid manual_content_scan_scrub_system_name_custom(void);\n\n/* Removes period (full stop) characters from\n * 'file_exts_custom' string and converts to\n * lower case */\nvoid manual_content_scan_scrub_file_exts_custom(void);\n\n/* Checks 'dat_file_path' string and resets it\n * if invalid */\nenum manual_content_scan_dat_file_path_status\n      manual_content_scan_validate_dat_file_path(void);\n\n/* Menu setters */\n\n/* Sets content directory for next manual scan\n * operation.\n * Returns true if content directory is valid. */\nbool manual_content_scan_set_menu_content_dir(const char *content_dir);\n\n/* Sets system name for the next manual scan\n * operation.\n * Returns true if system name is valid.\n * NOTE:\n * > Only sets 'system_name_type' and 'system_name_database'\n * > 'system_name_content_dir' and 'system_name_custom' are\n *   (by necessity) handled elsewhere\n * > This may look fishy, but it's not - it's a menu-specific\n *   function, and this is simply the cleanest way to handle\n *   the setting... */\nbool manual_content_scan_set_menu_system_name(\n      enum manual_content_scan_system_name_type system_name_type,\n      const char *system_name);\n\n/* Sets core name for the next manual scan\n * operation (+ core path and other associated\n * parameters).\n * Returns true if core name is valid. */\nbool manual_content_scan_set_menu_core_name(\n      enum manual_content_scan_core_type core_type,\n      const char *core_name);\n\n/* Sets all parameters for the next manual scan\n * operation according the to recorded values in\n * the specified playlist.\n * Returns MANUAL_CONTENT_SCAN_PLAYLIST_REFRESH_OK\n * if playlist contains a valid scan record. */\nenum manual_content_scan_playlist_refresh_status\n      manual_content_scan_set_menu_from_playlist(playlist_t *playlist,\n            const char *path_content_database, bool show_hidden_files);\n\n/* Menu getters */\n\n/* Fetches content directory for next manual scan\n * operation.\n * Returns true if content directory is valid. */\nbool manual_content_scan_get_menu_content_dir(const char **content_dir);\n\n/* Fetches system name for the next manual scan operation.\n * Returns true if system name is valid.\n * NOTE: This corresponds to the 'System Name' value\n * displayed in menus - this is not identical to the\n * actual system name used when generating the playlist */\nbool manual_content_scan_get_menu_system_name(const char **system_name);\n\n/* Fetches core name for the next manual scan operation.\n * Returns true if core name is valid. */\nbool manual_content_scan_get_menu_core_name(const char **core_name);\n\n/* Menu utility functions */\n\n/* Creates a list of all possible 'system name' menu\n * strings, for use in 'menu_displaylist' drop-down\n * lists and 'menu_cbs_left/right'\n * > Returns NULL in the event of failure\n * > Returned string list must be free()'d */\nstruct string_list *manual_content_scan_get_menu_system_name_list(\n      const char *path_content_database, bool show_hidden_files);\n\n/* Creates a list of all possible 'core name' menu\n * strings, for use in 'menu_displaylist' drop-down\n * lists and 'menu_cbs_left/right'\n * > Returns NULL in the event of failure\n * > Returned string list must be free()'d */\nstruct string_list *manual_content_scan_get_menu_core_name_list(void);\n\n/****************/\n/* Task Helpers */\n/****************/\n\n/* Parses current manual content scan settings,\n * and extracts all information required to configure\n * a manual content scan task.\n * Returns false if current settings are invalid. */\nbool manual_content_scan_get_task_config(\n      manual_content_scan_task_config_t *task_config,\n      const char *path_dir_playlist\n      );\n\n/* Creates a list of all valid content in the specified\n * content directory\n * > Returns NULL in the event of failure\n * > Returned string list must be free()'d */\nstruct string_list *manual_content_scan_get_content_list(\n      manual_content_scan_task_config_t *task_config);\n\n/* Adds specified content to playlist, if not already\n * present */\nvoid manual_content_scan_add_content_to_playlist(\n      manual_content_scan_task_config_t *task_config,\n      playlist_t *playlist, const char *content_path,\n      int content_type, logiqx_dat_t *dat_file);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "media",
          "type": "tree",
          "content": null
        },
        {
          "name": "memory",
          "type": "tree",
          "content": null
        },
        {
          "name": "menu",
          "type": "tree",
          "content": null
        },
        {
          "name": "midi",
          "type": "tree",
          "content": null
        },
        {
          "name": "midi_driver.h",
          "type": "blob",
          "size": 9.041015625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2018 The RetroArch team\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __MIDI_DRIVER__H\n#define __MIDI_DRIVER__H\n\n#include <boolean.h>\n#include <retro_common_api.h>\n\nRETRO_BEGIN_DECLS\n\nstruct string_list;\n\ntypedef struct\n{\n   uint8_t *data;\n   size_t data_size;\n   uint32_t delta_time;\n} midi_event_t;\n\ntypedef struct midi_driver\n{\n   /**\n    * ident:\n    * Driver name (visible in the menu). Must be unique among the MIDI drivers.\n    **/\n   const char *ident;\n\n   /**\n    * get_avail_inputs:\n    * Populates provided list with currently available inputs (if any).\n    *\n    * @inputs                 : List of available inputs (visible in the menu).\n    *                           This argument will never be NULL.\n    *\n    * Returns: True if successful (even if there are no inputs available),\n    *          false otherwise.\n    *\n    * Remarks: Before this function is called the list will already contain one\n    *          member (\"Off\") which can be used by the user to disable input.\n    *\n    *          If the driver supports input but underlying API don't offers this\n    *          list, driver should/must provide some \"fake\" name(s) here,\n    *          otherwise user will only see \"Off\" option in the menu.\n    **/\n   bool (*get_avail_inputs)(struct string_list *inputs);\n\n   /**\n    * get_avail_outputs:\n    * Populates provided list with currently available outputs (if any).\n    *\n    * @outputs                : List of available outputs (visible in the menu).\n    *                           This argument will never be NULL.\n    *\n    * Returns: True if successful (even if there are no outputs available),\n    *          false otherwise.\n    *\n    * Remarks: Before this function is called the list will already contain one\n    *          member (\"Off\") which can be used by the user to disable output.\n    *\n    *          If the driver supports output but underlying API don't offers this\n    *          list, driver should/must provide some \"fake\" name(s) here,\n    *          otherwise user will only see \"Off\" option in the menu.\n    **/\n   bool (*get_avail_outputs)(struct string_list *outputs);\n\n   /**\n    * init:\n    * Initializes driver and starts input (if 'input' argument is non NULL) and\n    * starts output (if 'output' argument is non NULL).\n    *\n    * @input                  : One of the input names previously returned by\n    *                           the 'get_avail_inputs' function or NULL which\n    *                           means don't initialize input.\n    * @output                 : One of the output names previously returned by\n    *                           the 'get_avail_outputs' function or NULL which\n    *                           means don't initialize output.\n    *\n    * Returns: Driver specific data pointer if successful, NULL otherwise.\n    *\n    * Remarks: If requested input/output is unavailable driver should return\n    *          NULL (don't implement \"fallback\" mechanism).\n    **/\n   void *(*init)(const char *input, const char *output);\n\n   /**\n    * free:\n    * Stops I/O and releases any resources used by the driver.\n    *\n    * @p                      : Driver specific data pointer previously returned\n    *                           by the 'init' function.\n    *                           This argument will never be NULL.\n    **/\n   void (*free)(void *p);\n\n   /**\n    * set_input:\n    * This function is used for changing/disabling input.\n    *\n    * @p                      : Driver specific data pointer previously returned\n    *                           by the 'init' function.\n    *                           This argument will never be NULL.\n    * @input                  : One of the input names previously returned by\n    *                           the 'get_avail_inputs' function or NULL which\n    *                           means disable input.\n    *\n    * Returns: True if successful, false otherwise.\n    *\n    * Remarks: On error, driver should leave the current input as is (if possible).\n    **/\n   bool (*set_input)(void *p, const char *input);\n\n   /**\n    * set_output:\n    * This function is used for changing/disabling output.\n    *\n    * @p                      : Driver specific data pointer previously returned\n    *                           by the 'init' function.\n    *                           This argument will never be NULL.\n    * @output                 : One of the output names previously returned by\n    *                           the 'get_avail_outputs' function or NULL which\n    *                           means disable output.\n    *\n    * Returns: True if successful, false otherwise.\n    *\n    * Remarks: On error, driver should leave the current output as is (if possible).\n    **/\n   bool (*set_output)(void *p, const char *output);\n\n   /**\n    * read:\n    * This function is used for reading received data. When called, 'data_size'\n    * member of the 'event' argument will hold max data size (in bytes)\n    * that event can hold. After successful read driver should set this member\n    * to actual data size that is returned, and 'delta_time' member should be\n    * set to time (in microseconds) between previous event and this one (if this\n    * is the first event set 'delta_time' to 0).\n    *\n    * @p                      : Driver specific data pointer previously returned\n    *                           by the 'init' function.\n    *                           This argument will never be NULL.\n    * @event                  : Address of the event structure.\n    *                           This argument will never be NULL, 'data' member\n    *                           will never be NULL and 'data_size' member\n    *                           will never be 0.\n    *\n    * Returns: True if event was available and read successfully, false otherwise.\n    *\n    * Remarks: If the driver can't supply timing info 'delta_time' member\n    *          of the 'event' argument should be set to 0.\n    **/\n   bool (*read)(void *p, midi_event_t *event);\n\n   /**\n    * write:\n    * This function is used for writing events.\n    *\n    * @p                      : Driver specific data pointer previously returned\n    *                           by the 'init' function.\n    *                           This argument will never be NULL.\n    * @event                  : Address of the event structure.\n    *                           This argument will never be NULL, 'data' member\n    *                           will never be NULL and 'data_size' member\n    *                           will never be 0.\n    *\n    * Returns: True if event was written successfully, false otherwise.\n    *\n    * Remarks: This event should be buffered by the driver and sent later\n    *          when 'flush' function is called.\n    *\n    *          If the underlying API don't support event scheduling 'delta_time'\n    *          member of the 'event' argument may be ignored by the driver.\n    **/\n   bool (*write)(void *p, const midi_event_t *event);\n\n   /**\n    * flush:\n    * This function is used for transferring events previously stored by the\n    * 'write' function.\n    *\n    * @p                      : Driver specific data pointer previously returned\n    *                           by the 'init' function.\n    *                           This argument will never be NULL.\n    *\n    * Returns: True if successful, false otherwise.\n    *\n    * Remarks: On error, drivers should keep the events (don't drop them).\n    **/\n   bool (*flush)(void *p);\n} midi_driver_t;\n\nstruct string_list *midi_driver_get_avail_inputs(void);\nstruct string_list *midi_driver_get_avail_outputs(void);\n\nbool midi_driver_set_volume(unsigned volume);\n\nbool midi_driver_set_input(const char *input);\nbool midi_driver_set_output(void *data, const char *output);\n\n/**\n * midi_driver_get_event_size:\n * This is a convenience function for finding out the size of the event based\n * on the status byte.\n *\n * @status                 : Status (first) byte of the event.\n *\n * Returns: Size of the event (in bytes). If 'status' argument is invalid\n *          (< 0x80) or 'status' represents start of the \"SysEx\" event (0xF0)\n *          this function will return 0.\n **/\nsize_t midi_driver_get_event_size(uint8_t status);\n\nbool midi_driver_input_enabled(void);\n\nbool midi_driver_output_enabled(void);\n\nbool midi_driver_flush(void);\n\nbool midi_driver_read(uint8_t *byte);\n\nbool midi_driver_write(uint8_t byte, uint32_t delta_time);\n\nbool midi_driver_set_all_sounds_off(void);\n\nextern midi_driver_t midi_winmm;\nextern midi_driver_t midi_alsa;\n\nextern midi_driver_t *midi_drivers[];\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "msg_hash.c",
          "type": "blob",
          "size": 26.1171875,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdio.h>\n#include <string.h>\n\n#include <lrc_hash.h>\n#include <string/stdstring.h>\n#include <libretro.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"msg_hash.h\"\n\n#if defined(_MSC_VER) && !defined(_XBOX) && (_MSC_VER >= 1500 && _MSC_VER < 1900)\n#if (_MSC_VER >= 1700)\n/* https://support.microsoft.com/en-us/kb/980263 */\n#pragma execution_character_set(\"utf-8\")\n#endif\n#pragma warning(disable:4566)\n#endif\n\n/* TODO/FIXME - static public global variable */\nstatic unsigned uint_user_language;\n\nint msg_hash_get_help_enum(enum msg_hash_enums msg, char *s, size_t len)\n{\n   int ret = msg_hash_get_help_us_enum(msg, s, len);\n   /* Replace line-breaks with \"empty line-breaks\" for readability */\n   const char *temp = string_replace_substring(s, strlen(s),\n         \"\\n\",    STRLEN_CONST(\"\\n\"),\n         \"\\n \\n\", STRLEN_CONST(\"\\n \\n\"));\n\n   if (temp)\n   {\n      strlcpy(s, temp, len);\n      free((void*)temp);\n   }\n   return ret;\n}\n\nconst char *get_user_language_iso639_1(bool limit)\n{\n   switch (uint_user_language)\n   {\n      case RETRO_LANGUAGE_FRENCH:\n         return \"fr\";\n      case RETRO_LANGUAGE_GERMAN:\n         return \"de\";\n      case RETRO_LANGUAGE_SPANISH:\n         return \"es\";\n      case RETRO_LANGUAGE_ITALIAN:\n         return \"it\";\n      case RETRO_LANGUAGE_PORTUGUESE_BRAZIL:\n         if (limit)\n            return \"pt\";\n         return \"pt_br\";\n      case RETRO_LANGUAGE_PORTUGUESE_PORTUGAL:\n         if (limit)\n            return \"pt\";\n         return \"pt_pt\";\n      case RETRO_LANGUAGE_DUTCH:\n         return \"nl\";\n      case RETRO_LANGUAGE_ESPERANTO:\n         return \"eo\";\n      case RETRO_LANGUAGE_POLISH:\n         return \"pl\";\n      case RETRO_LANGUAGE_JAPANESE:\n         return \"ja\";\n      case RETRO_LANGUAGE_KOREAN:\n         return \"ko\";\n      case RETRO_LANGUAGE_VIETNAMESE:\n         return \"vi\";\n      case RETRO_LANGUAGE_CHINESE_SIMPLIFIED:\n         if (limit)\n            return \"zh\";\n         return \"zh_cn\";\n      case RETRO_LANGUAGE_CHINESE_TRADITIONAL:\n         if (limit)\n            return \"zh\";\n         return \"zh_tw\";\n      case RETRO_LANGUAGE_ARABIC:\n         return \"ar\";\n      case RETRO_LANGUAGE_GREEK:\n         return \"el\";\n      case RETRO_LANGUAGE_TURKISH:\n         return \"tr\";\n      case RETRO_LANGUAGE_SLOVAK:\n         return \"sk\";\n      case RETRO_LANGUAGE_RUSSIAN:\n         return \"ru\";\n      case RETRO_LANGUAGE_PERSIAN:\n         return \"fa\";\n      case RETRO_LANGUAGE_HEBREW:\n         return \"he\";\n      case RETRO_LANGUAGE_ASTURIAN:\n         return \"ast\";\n      case RETRO_LANGUAGE_FINNISH:\n         return \"fi\";\n      case RETRO_LANGUAGE_INDONESIAN:\n         return \"id\";\n      case RETRO_LANGUAGE_SWEDISH:\n         return \"sv\";\n      case RETRO_LANGUAGE_UKRAINIAN:\n         return \"uk\";\n      case RETRO_LANGUAGE_CZECH:\n         return \"cs\";\n      case RETRO_LANGUAGE_CATALAN_VALENCIA:\n         if (limit)\n            return \"ca\";\n         return \"ca_ES@valencia\";\n      case RETRO_LANGUAGE_CATALAN:\n         return \"ca\";\n      case RETRO_LANGUAGE_BRITISH_ENGLISH:\n         if (limit)\n            return \"en\";\n         return \"en_gb\";\n      case RETRO_LANGUAGE_HUNGARIAN:\n         return \"hu\";\n      case RETRO_LANGUAGE_BELARUSIAN:\n         return \"be\";\n      case RETRO_LANGUAGE_GALICIAN:\n          return \"gl\";\n      case RETRO_LANGUAGE_NORWEGIAN:\n          return \"no\";\n   }\n   return \"en\";\n}\n\n#ifdef HAVE_LANGEXTRA\nstatic const char *msg_hash_to_str_he(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_he.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_sk(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_sk.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_uk(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_uk.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_eo(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n      #include \"intl/msg_hash_eo.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_pl(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_pl.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_fi(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_fi.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_hu(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_hu.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_be(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_be.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_en(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_en.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_it(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_it.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_fa(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_fa.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_ast(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_ast.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_nl(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n      #include \"intl/msg_hash_nl.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_sv(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_sv.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_id(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_id.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_cs(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_cs.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_ar(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_ar.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_fr(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_fr.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_cht(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_cht.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_de(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n      #include \"intl/msg_hash_de.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_es(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_es.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_ca(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_ca.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_el(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_el.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_jp(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_ja.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_ko(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_ko.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_pt_pt(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_pt_pt.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_ru(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_ru.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_tr(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_tr.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_val(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_val.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_vn(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_vn.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_chs(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_chs.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_pt_br(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_pt_br.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_gl(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_gl.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\nstatic const char *msg_hash_to_str_no(enum msg_hash_enums msg)\n{\n   switch (msg)\n   {\n#include \"intl/msg_hash_no.h\"\n      default:\n         break;\n   }\n\n   return \"null\";\n}\n\n#endif\n\nconst char *msg_hash_to_str(enum msg_hash_enums msg)\n{\n   const char *ret = NULL;\n\n#ifdef HAVE_LANGEXTRA\n   switch (uint_user_language)\n   {\n      case RETRO_LANGUAGE_FRENCH:\n         ret = msg_hash_to_str_fr(msg);\n         break;\n      case RETRO_LANGUAGE_GERMAN:\n         ret = msg_hash_to_str_de(msg);\n         break;\n      case RETRO_LANGUAGE_SPANISH:\n         ret = msg_hash_to_str_es(msg);\n         break;\n      case RETRO_LANGUAGE_ITALIAN:\n         ret = msg_hash_to_str_it(msg);\n         break;\n      case RETRO_LANGUAGE_PORTUGUESE_BRAZIL:\n         ret = msg_hash_to_str_pt_br(msg);\n         break;\n      case RETRO_LANGUAGE_PORTUGUESE_PORTUGAL:\n         ret = msg_hash_to_str_pt_pt(msg);\n         break;\n      case RETRO_LANGUAGE_DUTCH:\n         ret = msg_hash_to_str_nl(msg);\n         break;\n      case RETRO_LANGUAGE_ESPERANTO:\n         ret = msg_hash_to_str_eo(msg);\n         break;\n      case RETRO_LANGUAGE_POLISH:\n         ret = msg_hash_to_str_pl(msg);\n         break;\n      case RETRO_LANGUAGE_RUSSIAN:\n         ret = msg_hash_to_str_ru(msg);\n         break;\n      case RETRO_LANGUAGE_JAPANESE:\n         ret = msg_hash_to_str_jp(msg);\n         break;\n      case RETRO_LANGUAGE_KOREAN:\n         ret = msg_hash_to_str_ko(msg);\n         break;\n      case RETRO_LANGUAGE_VIETNAMESE:\n         ret = msg_hash_to_str_vn(msg);\n         break;\n      case RETRO_LANGUAGE_CHINESE_SIMPLIFIED:\n         ret = msg_hash_to_str_chs(msg);\n         break;\n      case RETRO_LANGUAGE_CHINESE_TRADITIONAL:\n         ret = msg_hash_to_str_cht(msg);\n         break;\n      case RETRO_LANGUAGE_ARABIC:\n         ret = msg_hash_to_str_ar(msg);\n         break;\n      case RETRO_LANGUAGE_GREEK:\n         ret = msg_hash_to_str_el(msg);\n         break;\n      case RETRO_LANGUAGE_TURKISH:\n         ret = msg_hash_to_str_tr(msg);\n         break;\n      case RETRO_LANGUAGE_SLOVAK:\n         ret = msg_hash_to_str_sk(msg);\n         break;\n      case RETRO_LANGUAGE_PERSIAN:\n         ret = msg_hash_to_str_fa(msg);\n         break;\n      case RETRO_LANGUAGE_HEBREW:\n         ret = msg_hash_to_str_he(msg);\n         break;\n      case RETRO_LANGUAGE_ASTURIAN:\n         ret = msg_hash_to_str_ast(msg);\n         break;\n      case RETRO_LANGUAGE_FINNISH:\n         ret = msg_hash_to_str_fi(msg);\n         break;\n      case RETRO_LANGUAGE_INDONESIAN:\n         ret = msg_hash_to_str_id(msg);\n         break;\n      case RETRO_LANGUAGE_SWEDISH:\n         ret = msg_hash_to_str_sv(msg);\n         break;\n      case RETRO_LANGUAGE_UKRAINIAN:\n         ret = msg_hash_to_str_uk(msg);\n         break;\n      case RETRO_LANGUAGE_CZECH:\n         ret = msg_hash_to_str_cs(msg);\n         break;\n      case RETRO_LANGUAGE_CATALAN_VALENCIA:\n         ret = msg_hash_to_str_val(msg);\n         break;\n      case RETRO_LANGUAGE_CATALAN:\n         ret = msg_hash_to_str_ca(msg);\n         break;\n      case RETRO_LANGUAGE_BRITISH_ENGLISH:\n         ret = msg_hash_to_str_en(msg);\n         break;\n      case RETRO_LANGUAGE_HUNGARIAN:\n         ret = msg_hash_to_str_hu(msg);\n         break;\n      case RETRO_LANGUAGE_BELARUSIAN:\n         ret = msg_hash_to_str_be(msg);\n         break;\n      case RETRO_LANGUAGE_GALICIAN:\n         ret = msg_hash_to_str_gl(msg);\n         break;\n      case RETRO_LANGUAGE_NORWEGIAN:\n         ret = msg_hash_to_str_no(msg);\n         break;\n      default:\n         break;\n   }\n#endif\n\n   if (ret && !string_is_equal(ret, \"null\"))\n      return ret;\n\n   return msg_hash_to_str_us(msg);\n}\n\nuint32_t msg_hash_calculate(const char *s)\n{\n   return djb2_calculate(s);\n}\n\n#define MENU_VALUE_FILE_WEBM                                                   0x7ca00b50U\n#define MENU_VALUE_FILE_F4F                                                    0x0b886be5U\n#define MENU_VALUE_FILE_F4V                                                    0x0b886bf5U\n#define MENU_VALUE_FILE_OGM                                                    0x0b8898c8U\n#define MENU_VALUE_FILE_MKV                                                    0x0b8890d3U\n#define MENU_VALUE_FILE_AVI                                                    0x0b885f25U\n#define MENU_VALUE_FILE_M4A                                                    0x0b8889a7U\n#define MENU_VALUE_FILE_3GP                                                    0x0b87998fU\n#define MENU_VALUE_FILE_MP4                                                    0x0b889136U\n#define MENU_VALUE_FILE_MP3                                                    0x0b889135U\n#define MENU_VALUE_FILE_FLAC                                                   0x7c96d67bU\n#define MENU_VALUE_FILE_OGG                                                    0x0b8898c2U\n#define MENU_VALUE_FILE_MOD                                                    0x0b889145U\n#define MENU_VALUE_FILE_S3M                                                    0x0b88a318U\n#define MENU_VALUE_FILE_XM                                                     0x00597a2aU\n#define MENU_VALUE_FILE_FLV                                                    0x0b88732dU\n#define MENU_VALUE_FILE_WAV                                                    0x0b88ba13U\n#define MENU_VALUE_FILE_MOV                                                    0x0b889157U\n#define MENU_VALUE_FILE_WMV                                                    0x0b88bb9fU\n#define MENU_VALUE_FILE_3G2                                                    0x0b879951U\n#define MENU_VALUE_FILE_MPG                                                    0x0b889169U\n#define MENU_VALUE_FILE_MPEG                                                   0x7c9abeaeU\n#define MENU_VALUE_FILE_VOB                                                    0x0b88b78cU\n#define MENU_VALUE_FILE_ASF                                                    0x0b885ebfU\n#define MENU_VALUE_FILE_DIVX                                                   0x7c95b3c0U\n#define MENU_VALUE_FILE_M2P                                                    0x0b888974U\n#define MENU_VALUE_FILE_M2TS                                                   0x7c99b8ebU\n#define MENU_VALUE_FILE_PS                                                     0x00597928U\n#define MENU_VALUE_FILE_TS                                                     0x005979acU\n#define MENU_VALUE_FILE_MXF                                                    0x0b889270U\n#define MENU_VALUE_FILE_WMA                                                    0x0b88bb8aU\n\n#define MENU_VALUE_FILE_JPG                                                    0x0b8884a6U\n#define MENU_VALUE_FILE_JPEG                                                   0x7c99198bU\n#define MENU_VALUE_FILE_JPG_CAPS                                               0x0b87f846U\n#define MENU_VALUE_FILE_JPEG_CAPS                                              0x7c87010bU\n#define MENU_VALUE_FILE_PNG                                                    0x0b889deaU\n#define MENU_VALUE_FILE_PNG_CAPS                                               0x0b88118aU\n#define MENU_VALUE_FILE_GONG                                                   0x7c977150U\n#define MENU_VALUE_FILE_GONG_CAPS                                              0x7c8558d0U\n#define MENU_VALUE_FILE_TGA                                                    0x0b88ae01U\n#define MENU_VALUE_FILE_BMP                                                    0x0b886244U\n\n#define MENU_VALUE_MD5                                                         0x0b888fabU\n#define MENU_VALUE_SHA1                                                        0x7c9de632U\n#define MENU_VALUE_CRC                                                         0x0b88671dU\n#define MENU_VALUE_MORE                                                        0x0b877cafU\n#define MENU_VALUE_CFILE                                                       0xac3ec4f9U\n#define MENU_VALUE_ON                                                          0x005974c2U\n#define MENU_VALUE_OFF                                                         0x0b880c40U\n#define MENU_VALUE_COMP                                                        0x6a166ba5U\n#define MENU_VALUE_MUSIC                                                       0xc4a73997U\n#define MENU_VALUE_IMAGE                                                       0xbab7ebf9U\n#define MENU_VALUE_MOVIE                                                       0xc43c4bf6U\n#define MENU_VALUE_CORE                                                        0x6a167f7fU\n#define MENU_VALUE_FILE                                                        0x6a496536U\n#define MENU_VALUE_RDB                                                         0x0b00f54eU\n#define MENU_VALUE_DIR                                                         0x0af95f55U\n#define MENU_VALUE_GLSLP                                                       0x0f840c87U\n#define MENU_VALUE_CGP                                                         0x0b8865bfU\n#define MENU_VALUE_GLSL                                                        0x7c976537U\n#define MENU_VALUE_HLSL                                                        0x7c97f198U\n#define MENU_VALUE_HLSLP                                                       0x0f962508U\n#define MENU_VALUE_CG                                                          0x0059776fU\n#define MENU_VALUE_SLANG                                                       0x105ce63aU\n#define MENU_VALUE_SLANGP                                                      0x1bf9adeaU\n\n#define FILE_HASH_APK                                                          0x0b885e61U\n\n#define HASH_EXTENSION_7Z                                                      0x005971d6U\n#define HASH_EXTENSION_7Z_UPP                                                  0x005971b6U\n#define HASH_EXTENSION_ZIP                                                     0x0b88c7d8U\n#define HASH_EXTENSION_ZIP_UPP                                                 0x0b883b78U\n#define HASH_EXTENSION_CUE                                                     0x0b886782U\n#define HASH_EXTENSION_CUE_UPPERCASE                                           0x0b87db22U\n#define HASH_EXTENSION_GDI                                                     0x00b887659\n#define HASH_EXTENSION_GDI_UPPERCASE                                           0x00b87e9f9\n#define HASH_EXTENSION_ISO                                                     0x0b8880d0U\n#define HASH_EXTENSION_ISO_UPPERCASE                                           0x0b87f470U\n#define HASH_EXTENSION_LUTRO                                                   0x0fe37b7bU\n#define HASH_EXTENSION_CHD                                                     0x0b8865d4U\n\nenum msg_file_type msg_hash_to_file_type(uint32_t hash)\n{\n   switch (hash)\n   {\n      case MENU_VALUE_COMP:\n      case HASH_EXTENSION_7Z:\n      case HASH_EXTENSION_7Z_UPP:\n      case HASH_EXTENSION_ZIP:\n      case HASH_EXTENSION_ZIP_UPP:\n      case FILE_HASH_APK:\n         return FILE_TYPE_COMPRESSED;\n      case MENU_VALUE_CFILE:\n         return FILE_TYPE_IN_CARCHIVE;\n      case MENU_VALUE_MORE:\n         return FILE_TYPE_MORE;\n      case MENU_VALUE_CORE:\n         return FILE_TYPE_CORE;\n      case MENU_VALUE_RDB:\n         return FILE_TYPE_RDB;\n      case MENU_VALUE_FILE:\n         return FILE_TYPE_PLAIN;\n      case MENU_VALUE_DIR:\n         return FILE_TYPE_DIRECTORY;\n      case MENU_VALUE_MUSIC:\n         return FILE_TYPE_MUSIC;\n      case MENU_VALUE_IMAGE:\n         return FILE_TYPE_IMAGE;\n      case MENU_VALUE_MOVIE:\n         return FILE_TYPE_MOVIE;\n      case MENU_VALUE_ON:\n         return FILE_TYPE_BOOL_ON;\n      case MENU_VALUE_OFF:\n         return FILE_TYPE_BOOL_OFF;\n      case MENU_VALUE_GLSL:\n         return FILE_TYPE_SHADER_GLSL;\n      case MENU_VALUE_HLSL:\n         return FILE_TYPE_SHADER_HLSL;\n      case MENU_VALUE_CG:\n         return FILE_TYPE_SHADER_CG;\n      case MENU_VALUE_SLANG:\n         return FILE_TYPE_SHADER_SLANG;\n      case MENU_VALUE_GLSLP:\n         return FILE_TYPE_SHADER_PRESET_GLSLP;\n      case MENU_VALUE_HLSLP:\n         return FILE_TYPE_SHADER_PRESET_HLSLP;\n      case MENU_VALUE_CGP:\n         return FILE_TYPE_SHADER_PRESET_CGP;\n      case MENU_VALUE_SLANGP:\n         return FILE_TYPE_SHADER_PRESET_SLANGP;\n      case MENU_VALUE_CRC:\n         return FILE_TYPE_CRC;\n      case MENU_VALUE_SHA1:\n         return FILE_TYPE_SHA1;\n      case MENU_VALUE_MD5:\n         return FILE_TYPE_MD5;\n#if defined(HAVE_FFMPEG) || defined(HAVE_MPV)\n      case MENU_VALUE_FILE_OGM:\n         return FILE_TYPE_OGM;\n      case MENU_VALUE_FILE_MKV:\n         return FILE_TYPE_MKV;\n      case MENU_VALUE_FILE_AVI:\n         return FILE_TYPE_AVI;\n      case MENU_VALUE_FILE_MP4:\n         return FILE_TYPE_MP4;\n      case MENU_VALUE_FILE_FLV:\n         return FILE_TYPE_FLV;\n      case MENU_VALUE_FILE_WEBM:\n         return FILE_TYPE_WEBM;\n      case MENU_VALUE_FILE_3GP:\n         return FILE_TYPE_3GP;\n      case MENU_VALUE_FILE_F4F:\n         return FILE_TYPE_F4F;\n      case MENU_VALUE_FILE_F4V:\n         return FILE_TYPE_F4V;\n      case MENU_VALUE_FILE_MOV:\n         return FILE_TYPE_MOV;\n      case MENU_VALUE_FILE_WMV:\n         return FILE_TYPE_WMV;\n      case MENU_VALUE_FILE_M4A:\n         return FILE_TYPE_M4A;\n      case MENU_VALUE_FILE_3G2:\n         return FILE_TYPE_3G2;\n      case MENU_VALUE_FILE_MPG:\n         return FILE_TYPE_MPG;\n      case MENU_VALUE_FILE_MPEG:\n         return FILE_TYPE_MPEG;\n      case MENU_VALUE_FILE_VOB:\n         return FILE_TYPE_VOB;\n      case MENU_VALUE_FILE_ASF:\n         return FILE_TYPE_ASF;\n      case MENU_VALUE_FILE_DIVX:\n         return FILE_TYPE_DIVX;\n      case MENU_VALUE_FILE_M2P:\n         return FILE_TYPE_M2P;\n      case MENU_VALUE_FILE_M2TS:\n         return FILE_TYPE_M2TS;\n      case MENU_VALUE_FILE_PS:\n         return FILE_TYPE_PS;\n      case MENU_VALUE_FILE_TS:\n         return FILE_TYPE_TS;\n      case MENU_VALUE_FILE_MXF:\n         return FILE_TYPE_MXF;\n      case MENU_VALUE_FILE_WMA:\n         return FILE_TYPE_WMA;\n#endif\n#if defined(HAVE_FFMPEG) || defined(HAVE_MPV) || defined(HAVE_AUDIOMIXER)\n#if !defined(HAVE_AUDIOMIXER) || defined(HAVE_DR_MP3)\n      case MENU_VALUE_FILE_MP3:\n         return FILE_TYPE_MP3;\n#endif\n#if !defined(HAVE_AUDIOMIXER) || defined(HAVE_STB_VORBIS)\n      case MENU_VALUE_FILE_OGG:\n         return FILE_TYPE_OGG;\n#endif\n#if !defined(HAVE_AUDIOMIXER) || defined(HAVE_DR_FLAC)\n      case MENU_VALUE_FILE_FLAC:\n         return FILE_TYPE_FLAC;\n#endif\n#if !defined(HAVE_AUDIOMIXER) || defined(HAVE_RWAV)\n      case MENU_VALUE_FILE_WAV:\n         return FILE_TYPE_WAV;\n#endif\n#if !defined(HAVE_AUDIOMIXER) || defined(HAVE_IBXM)\n       case MENU_VALUE_FILE_MOD:\n           return FILE_TYPE_MOD;\n       case MENU_VALUE_FILE_S3M:\n           return FILE_TYPE_S3M;\n       case MENU_VALUE_FILE_XM:\n           return FILE_TYPE_XM;\n#endif\n#endif\n#ifdef HAVE_IMAGEVIEWER\n      case MENU_VALUE_FILE_JPG:\n      case MENU_VALUE_FILE_JPG_CAPS:\n      case MENU_VALUE_FILE_JPEG:\n      case MENU_VALUE_FILE_JPEG_CAPS:\n         return FILE_TYPE_JPEG;\n      case MENU_VALUE_FILE_PNG:\n      case MENU_VALUE_FILE_PNG_CAPS:\n         return FILE_TYPE_PNG;\n      case MENU_VALUE_FILE_TGA:\n         return FILE_TYPE_TGA;\n      case MENU_VALUE_FILE_BMP:\n         return FILE_TYPE_BMP;\n#endif\n#ifdef HAVE_EASTEREGG\n      case MENU_VALUE_FILE_GONG:\n      case MENU_VALUE_FILE_GONG_CAPS:\n         return FILE_TYPE_GONG;\n#endif\n      case HASH_EXTENSION_CUE:\n      case HASH_EXTENSION_CUE_UPPERCASE:\n         return FILE_TYPE_CUE;\n      case HASH_EXTENSION_GDI:\n      case HASH_EXTENSION_GDI_UPPERCASE:\n         return FILE_TYPE_GDI;\n      case HASH_EXTENSION_ISO:\n      case HASH_EXTENSION_ISO_UPPERCASE:\n         return FILE_TYPE_ISO;\n      case HASH_EXTENSION_LUTRO:\n         return FILE_TYPE_LUTRO;\n      case HASH_EXTENSION_CHD:\n         return FILE_TYPE_CHD;\n      default:\n         break;\n   }\n\n   return FILE_TYPE_NONE;\n}\n\nunsigned *msg_hash_get_uint(enum msg_hash_action type)\n{\n   switch (type)\n   {\n      case MSG_HASH_USER_LANGUAGE:\n         return &uint_user_language;\n      case MSG_HASH_NONE:\n         break;\n   }\n\n   return NULL;\n}\n\nvoid msg_hash_set_uint(enum msg_hash_action type, unsigned val)\n{\n   switch (type)\n   {\n      case MSG_HASH_USER_LANGUAGE:\n         uint_user_language = val;\n         break;\n      case MSG_HASH_NONE:\n         break;\n   }\n}\n\nconst char *msg_hash_get_wideglyph_str(void)\n{\n#ifdef HAVE_LANGEXTRA\n   switch (uint_user_language)\n   {\n      case RETRO_LANGUAGE_CHINESE_SIMPLIFIED:\n         return \"\";\n      case RETRO_LANGUAGE_CHINESE_TRADITIONAL:\n         return \"\";\n      case RETRO_LANGUAGE_JAPANESE:\n         return \"\";\n      case RETRO_LANGUAGE_KOREAN:\n         return \"\";\n      default:\n         break;\n   }\n#endif\n\n   return NULL;\n}\n"
        },
        {
          "name": "msg_hash.h",
          "type": "blob",
          "size": 162.814453125,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __MSG_HASH_H\n#define __MSG_HASH_H\n\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n#include <boolean.h>\n#include <retro_common_api.h>\n\n#include \"input/input_defines.h\"\n\n#define MSG_HASH(Id, str) case Id: return str;\n\n#define MENU_LABEL(STR) \\\n   MENU_ENUM_LABEL_##STR, \\\n   MENU_ENUM_SUBLABEL_##STR, \\\n   MENU_ENUM_LABEL_VALUE_##STR\n\n#define MENU_LBL_H(STR) \\\n   MENU_ENUM_LABEL_##STR, \\\n   MENU_ENUM_SUBLABEL_##STR, \\\n   MENU_ENUM_LABEL_VALUE_##STR, \\\n   MENU_ENUM_LABEL_HELP_##STR\n\nRETRO_BEGIN_DECLS\n\nenum msg_hash_action\n{\n   MSG_HASH_NONE = 0,\n   MSG_HASH_USER_LANGUAGE\n};\n\nenum msg_file_type\n{\n   FILE_TYPE_NONE = 0,\n   FILE_TYPE_PLAIN,\n   FILE_TYPE_DIRECTORY,\n   FILE_TYPE_PARENT_DIRECTORY,\n   FILE_TYPE_PATH,\n   FILE_TYPE_DEVICE,\n   FILE_TYPE_CORE,\n   FILE_TYPE_PLAYLIST_ENTRY,\n   FILE_TYPE_CONTENTLIST_ENTRY,\n   FILE_TYPE_SHADER_PRESET,\n   FILE_TYPE_SHADER,\n   FILE_TYPE_VIDEOFILTER,\n   FILE_TYPE_AUDIOFILTER,\n   FILE_TYPE_CHEAT,\n   FILE_TYPE_OVERLAY,\n   FILE_TYPE_FONT,\n   FILE_TYPE_CONFIG,\n   FILE_TYPE_USE_DIRECTORY,\n   FILE_TYPE_SCAN_DIRECTORY,\n   FILE_TYPE_CARCHIVE,\n   FILE_TYPE_IN_CARCHIVE,\n   FILE_TYPE_IMAGE,\n   FILE_TYPE_IMAGEVIEWER,\n   FILE_TYPE_REMAP,\n   FILE_TYPE_DOWNLOAD_CORE,\n   FILE_TYPE_DOWNLOAD_URL,\n   FILE_TYPE_DOWNLOAD_CORE_CONTENT,\n   FILE_TYPE_DOWNLOAD_CORE_INFO,\n   FILE_TYPE_DOWNLOAD_THUMBNAIL_CONTENT,\n   FILE_TYPE_DOWNLOAD_LAKKA,\n   FILE_TYPE_RDB,\n   FILE_TYPE_RDB_ENTRY,\n   FILE_TYPE_RPL_ENTRY,\n   FILE_TYPE_BOOL_ON,\n   FILE_TYPE_BOOL_OFF,\n   FILE_TYPE_RECORD_CONFIG,\n   FILE_TYPE_STREAM_CONFIG,\n   FILE_TYPE_PLAYLIST_COLLECTION,\n   FILE_TYPE_PLAYLIST_ASSOCIATION,\n   FILE_TYPE_MOVIE,\n   FILE_TYPE_MUSIC,\n   FILE_TYPE_SHADER_SLANG,\n   FILE_TYPE_SHADER_GLSL,\n   FILE_TYPE_SHADER_HLSL,\n   FILE_TYPE_SHADER_CG,\n   FILE_TYPE_SHADER_PRESET_GLSLP,\n   FILE_TYPE_SHADER_PRESET_HLSLP,\n   FILE_TYPE_SHADER_PRESET_CGP,\n   FILE_TYPE_SHADER_PRESET_SLANGP,\n   FILE_TYPE_DOWNLOAD_THUMBNAIL,\n   FILE_TYPE_MORE,\n   FILE_TYPE_COMPRESSED,\n   FILE_TYPE_SHA1,\n   FILE_TYPE_MD5,\n   FILE_TYPE_CRC,\n   FILE_TYPE_RGUI_THEME_PRESET,\n   FILE_TYPE_VIDEO_LAYOUT,\n   FILE_TYPE_WEBM,\n   FILE_TYPE_F4F,\n   FILE_TYPE_F4V,\n   FILE_TYPE_OGM,\n   FILE_TYPE_MKV,\n   FILE_TYPE_AVI,\n   FILE_TYPE_M4A,\n   FILE_TYPE_3GP,\n   FILE_TYPE_3G2,\n   FILE_TYPE_MP4,\n   FILE_TYPE_MP3,\n   FILE_TYPE_FLAC,\n   FILE_TYPE_OGG,\n   FILE_TYPE_FLV,\n   FILE_TYPE_WAV,\n   FILE_TYPE_MOV,\n   FILE_TYPE_WMA,\n   FILE_TYPE_WMV,\n   FILE_TYPE_MPG,\n   FILE_TYPE_MPEG,\n   FILE_TYPE_VOB,\n   FILE_TYPE_ASF,\n   FILE_TYPE_DIVX,\n   FILE_TYPE_M2P,\n   FILE_TYPE_M2TS,\n   FILE_TYPE_PS,\n   FILE_TYPE_TS,\n   FILE_TYPE_MXF,\n\n   FILE_TYPE_JPEG,\n   FILE_TYPE_PNG,\n   FILE_TYPE_TGA,\n   FILE_TYPE_BMP,\n\n   FILE_TYPE_MOD,\n   FILE_TYPE_S3M,\n   FILE_TYPE_XM,\n\n   FILE_TYPE_CUE,\n   FILE_TYPE_GDI,\n   FILE_TYPE_ISO,\n   FILE_TYPE_LUTRO,\n   FILE_TYPE_CHD,\n   FILE_TYPE_WBFS,\n   FILE_TYPE_RVZ,\n   FILE_TYPE_WIA,\n\n   FILE_TYPE_DIRECT_LOAD,\n\n   FILE_TYPE_GONG,\n\n   /* Note: New entries must be added at the end, otherwise\n    * menu_cbs_init_bind_get_string_representation_compare_type() breaks... */\n   FILE_TYPE_DOWNLOAD_PL_THUMBNAIL_CONTENT,\n\n   FILE_TYPE_MANUAL_SCAN_DIRECTORY,\n   FILE_TYPE_MANUAL_SCAN_DAT,\n\n   FILE_TYPE_SIDELOAD_CORE,\n\n   FILE_TYPE_VIDEO_FONT,\n\n   FILE_TYPE_DOWNLOAD_CORE_SYSTEM_FILES,\n\n   FILE_TYPE_OSK_OVERLAY,\n\n   FILE_TYPE_LAST\n};\n\nenum msg_hash_enums\n{\n   MSG_UNKNOWN = 0,\n   MSG_ROOM_PASSWORDED,\n   MSG_INTERNET,\n   MSG_INTERNET_RELAY,\n   MSG_INTERNET_NOT_CONNECTABLE,\n   MSG_READ_WRITE,\n   MSG_READ_ONLY,\n   MSG_LOCAL,\n   MSG_SETTING_DISK_IN_TRAY,\n   MSG_FAILED_TO_SET_DISK,\n   MSG_FAILED_TO_SET_INITIAL_DISK,\n   MSG_NETPLAY_NEED_CONTENT_LOADED,\n   MSG_FAILED_TO_CONNECT_TO_CLIENT,\n   MSG_FAILED_TO_CONNECT_TO_HOST,\n   MSG_NETPLAY_HOST_FULL,\n   MSG_NETPLAY_BANNED,\n   MSG_FAILED_TO_RECEIVE_HEADER_FROM_HOST,\n   MSG_NETPLAY_FAILED,\n   MSG_NETPLAY_UNSUPPORTED,\n   MSG_UNKNOWN_NETPLAY_COMMAND_RECEIVED,\n   MSG_CONNECTING_TO_NETPLAY_HOST,\n   MSG_NETPLAY_LAN_SCAN_COMPLETE,\n   MSG_NETPLAY_LAN_SCANNING,\n   MSG_WAITING_FOR_CLIENT,\n   MSG_ROOM_NOT_CONNECTABLE,\n   MSG_NETPLAY_YOU_HAVE_LEFT_THE_GAME,\n   MSG_NETPLAY_YOU_HAVE_JOINED_AS_PLAYER_N,\n   MSG_NETPLAY_YOU_HAVE_JOINED_WITH_INPUT_DEVICES_S,\n   MSG_NETPLAY_PLAYER_S_LEFT,\n   MSG_NETPLAY_S_HAS_JOINED_AS_PLAYER_N,\n   MSG_NETPLAY_S_HAS_JOINED_WITH_INPUT_DEVICES_S,\n   MSG_NETPLAY_NOT_RETROARCH,\n   MSG_NETPLAY_OUT_OF_DATE,\n   MSG_NETPLAY_DIFFERENT_VERSIONS,\n   MSG_NETPLAY_DIFFERENT_CORES,\n   MSG_NETPLAY_DIFFERENT_CORE_VERSIONS,\n   MSG_NETPLAY_ENDIAN_DEPENDENT,\n   MSG_NETPLAY_PLATFORM_DEPENDENT,\n   MSG_NETPLAY_ENTER_PASSWORD,\n   MSG_NETPLAY_ENTER_CHAT,\n   MSG_NETPLAY_INCORRECT_PASSWORD,\n   MSG_NETPLAY_SERVER_NAMED_HANGUP,\n   MSG_NETPLAY_SERVER_HANGUP,\n   MSG_NETPLAY_CLIENT_HANGUP,\n   MSG_NETPLAY_CANNOT_PLAY_UNPRIVILEGED,\n   MSG_NETPLAY_CANNOT_PLAY_NO_SLOTS,\n   MSG_NETPLAY_CANNOT_PLAY_NOT_AVAILABLE,\n   MSG_NETPLAY_CANNOT_PLAY,\n   MSG_NETPLAY_PEER_PAUSED,\n   MSG_NETPLAY_CHANGED_NICK,\n   MSG_NETPLAY_KICKED_CLIENT_S,\n   MSG_NETPLAY_FAILED_TO_KICK_CLIENT_S,\n   MSG_NETPLAY_BANNED_CLIENT_S,\n   MSG_NETPLAY_FAILED_TO_BAN_CLIENT_S,\n   MSG_NETPLAY_STATUS_PLAYING,\n   MSG_NETPLAY_STATUS_SPECTATING,\n   MSG_NETPLAY_CLIENT_DEVICES,\n   MSG_NETPLAY_CHAT_SUPPORTED,\n   MSG_NETPLAY_SLOWDOWNS_CAUSED,\n   MSG_RESAMPLER_QUALITY_LOWEST,\n   MSG_RESAMPLER_QUALITY_LOWER,\n   MSG_RESAMPLER_QUALITY_NORMAL,\n   MSG_RESAMPLER_QUALITY_HIGHER,\n   MSG_RESAMPLER_QUALITY_HIGHEST,\n   MSG_DISCORD_CONNECTION_REQUEST,\n   MSG_ADDED_TO_FAVORITES,\n   MSG_ADD_TO_FAVORITES_FAILED,\n   MSG_SET_CORE_ASSOCIATION,\n   MSG_RESET_CORE_ASSOCIATION,\n   MSG_CORE_ASSOCIATION_RESET,\n   MSG_AUTODETECT,\n   MSG_AUDIO_VOLUME,\n   MSG_AUDIO_MIXER_VOLUME,\n   MSG_LIBRETRO_FRONTEND,\n   MSG_CAPABILITIES,\n   MSG_DEVICE_CONFIGURED_IN_PORT, /* deprecated */\n   MSG_DEVICE_CONFIGURED_IN_PORT_NR,\n   MSG_DEVICE_NOT_CONFIGURED,  /* deprecated */\n   MSG_DEVICE_NOT_CONFIGURED_NR,\n   MSG_DEVICE_NOT_CONFIGURED_FALLBACK, /* deprecated */\n   MSG_DEVICE_NOT_CONFIGURED_FALLBACK_NR,\n   MSG_DEVICE_DISCONNECTED_FROM_PORT, /* deprecated */\n   MSG_DEVICE_DISCONNECTED_FROM_PORT_NR,\n   MSG_NO_ARGUMENTS_SUPPLIED_AND_NO_MENU_BUILTIN,\n   MSG_COMPILER,\n   MSG_NATIVE,\n   MSG_DYNAMIC,\n   MSG_UNKNOWN_COMPILER,\n   MSG_AUTOLOADING_SAVESTATE_FAILED,\n   MSG_AUTOLOADING_SAVESTATE_SUCCEEDED,\n   MSG_LOADING,\n   MSG_FIRMWARE,\n   MSG_CONNECTING_TO_PORT,\n   MSG_CONNECTED_TO,\n   MSG_FAILED_TO_LOAD,\n   MSG_USING_CORE_NAME_FOR_NEW_CONFIG,\n   MSG_SAVED_NEW_CONFIG_TO,\n   MSG_FAILED_SAVING_CONFIG_TO,\n   MSG_INFLATED_CHECKSUM_DID_NOT_MATCH_CRC32,\n   MSG_FAILED_TO_EXTRACT_CONTENT_FROM_COMPRESSED_FILE,\n   MSG_FILE_NOT_FOUND,\n   MSG_VALUE_SHUTTING_DOWN,\n   MSG_VALUE_REBOOTING,\n   MSG_FAILED_TO_START_AUDIO_DRIVER,\n   MSG_FOUND_LAST_STATE_SLOT,\n   MSG_FOUND_LAST_REPLAY_SLOT,\n   MSG_REPLAY_LOAD_STATE_HALT_INCOMPAT,\n   MSG_REPLAY_LOAD_STATE_FAILED_INCOMPAT,\n   MSG_RESTORED_OLD_SAVE_STATE,\n   MSG_NO_STATE_HAS_BEEN_LOADED_YET,\n   MSG_GOT_CONNECTION_FROM,\n   MSG_GOT_CONNECTION_FROM_NAME,\n   MSG_CONNECTION_SLOT,\n   MSG_PUBLIC_ADDRESS,\n   MSG_PRIVATE_OR_SHARED_ADDRESS,\n   MSG_UPNP_FAILED,\n   MSG_NO_SAVE_STATE_HAS_BEEN_OVERWRITTEN_YET,\n   MSG_CANNOT_INFER_NEW_CONFIG_PATH,\n   MSG_UNDID_LOAD_STATE,\n   MSG_UNDID_SAVE_STATE,\n   MSG_CONNECT_DEVICE_FROM_A_VALID_PORT,\n   MSG_VALUE_CONNECT_DEVICE_FROM_A_VALID_PORT,\n   MSG_DISCONNECT_DEVICE_FROM_A_VALID_PORT,\n   MSG_DISCONNECTING_DEVICE_FROM_PORT, /* deprecated */\n   MSG_VALUE_DISCONNECTING_DEVICE_FROM_PORT, /* deprecated */\n   MSG_BRINGING_UP_COMMAND_INTERFACE_ON_PORT,\n   MSG_FAILED_TO_ACCEPT_INCOMING_SPECTATOR,\n   MSG_FAILED_TO_GET_NICKNAME_FROM_CLIENT,\n   MSG_FAILED_TO_SEND_NICKNAME_TO_CLIENT,\n   MSG_FAILED_TO_SEND_NICKNAME_TO_HOST,\n   MSG_FAILED_TO_RECEIVE_NICKNAME_SIZE_FROM_HOST,\n   MSG_FAILED_TO_RECEIVE_NICKNAME,\n   MSG_FAILED_TO_RECEIVE_NICKNAME_FROM_HOST,\n   MSG_FAILED_TO_RECEIVE_HEADER_FROM_CLIENT,\n   MSG_FAILED_TO_RECEIVE_SRAM_DATA_FROM_HOST,\n   MSG_FAILED_TO_SEND_NICKNAME_SIZE,\n   MSG_FAILED_TO_SEND_NICKNAME,\n   MSG_FAILED_TO_SEND_SRAM_DATA_TO_CLIENT,\n   MSG_GAME_SPECIFIC_CORE_OPTIONS_FOUND_AT,\n   MSG_FOLDER_SPECIFIC_CORE_OPTIONS_FOUND_AT,\n   MSG_INVALID_NICKNAME_SIZE,\n   MSG_VERSION_OF_LIBRETRO_API,\n   MSG_COMPILED_AGAINST_API,\n   MSG_ERROR_LIBRETRO_CORE_REQUIRES_SPECIAL_CONTENT,\n   MSG_ERROR_LIBRETRO_CORE_REQUIRES_CONTENT,\n   MSG_ERROR_LIBRETRO_CORE_REQUIRES_VFS,\n   MSG_SEVERAL_PATCHES_ARE_EXPLICITLY_DEFINED,\n   MSG_DID_NOT_FIND_A_VALID_CONTENT_PATCH,\n   MSG_FAILED_TO_ALLOCATE_MEMORY_FOR_PATCHED_CONTENT,\n   MSG_CONTENT_LOADING_SKIPPED_IMPLEMENTATION_WILL_DO_IT,\n   MSG_PROGRAM,\n   MSG_ERROR,\n   MSG_FOUND_DISK_LABEL,\n   MSG_READING_FIRST_DATA_TRACK,\n   MSG_COULD_NOT_FIND_COMPATIBLE_SYSTEM,\n   MSG_COMPARING_WITH_KNOWN_MAGIC_NUMBERS,\n   MSG_COULD_NOT_FIND_VALID_DATA_TRACK,\n   MSG_COULD_NOT_OPEN_DATA_TRACK,\n   MSG_FOUND_FIRST_DATA_TRACK_ON_FILE,\n   MSG_FRAMES,\n   MSG_FOUND_SHADER,\n   MSG_LOADING_HISTORY_FILE,\n   MSG_LOADING_FAVORITES_FILE,\n   MSG_COULD_NOT_READ_STATE_FROM_MOVIE,\n   MSG_MOVIE_FILE_IS_NOT_A_VALID_REPLAY_FILE,\n   MSG_OVERRIDES_NOT_SAVED,\n   MSG_OVERRIDES_ACTIVE_NOT_SAVING,\n   MSG_OVERRIDES_SAVED_SUCCESSFULLY,\n   MSG_OVERRIDES_REMOVED_SUCCESSFULLY,\n   MSG_OVERRIDES_UNLOADED_SUCCESSFULLY,\n   MSG_OVERRIDES_ERROR_SAVING,\n   MSG_OVERRIDES_ERROR_REMOVING,\n   MSG_AUTOCONFIG_FILE_SAVED_SUCCESSFULLY,\n   MSG_AUTOCONFIG_FILE_SAVED_SUCCESSFULLY_NAMED,\n   MSG_AUTOCONFIG_FILE_ERROR_SAVING,\n   MSG_FILE_ALREADY_EXISTS_SAVING_TO_BACKUP_BUFFER,\n   MSG_AUTOLOADING_SAVESTATE_FROM,\n   MSG_FOUND_AUTO_SAVESTATE_IN,\n   MSG_SRAM_WILL_NOT_BE_SAVED,\n   MSG_FAILED_TO_BIND_SOCKET,\n   MSG_AUTO_SAVE_STATE_TO,\n   MSG_RESTORING_DEFAULT_SHADER_PRESET_TO,\n   MSG_SORRY_UNIMPLEMENTED_CORES_DONT_DEMAND_CONTENT_NETPLAY,\n   MSG_LOADING_CONTENT_FILE,\n   MSG_FATAL_ERROR_RECEIVED_IN,\n   MSG_FAILED_TO_PATCH,\n   MSG_COULD_NOT_READ_MOVIE_HEADER,\n   MSG_CRC32_CHECKSUM_MISMATCH,\n   MSG_USING_LIBRETRO_DUMMY_CORE_RECORDING_SKIPPED,\n   MSG_FAILED_TO_OPEN_LIBRETRO_CORE,\n   MSG_COULD_NOT_FIND_ANY_NEXT_DRIVER,\n   MSG_MOVIE_FORMAT_DIFFERENT_SERIALIZER_VERSION,\n   MSG_CONTENT_CRC32S_DIFFER,\n   MSG_CONTENT_NETPACKET_CRC32S_DIFFER,\n   MSG_PING_TOO_HIGH,\n   MSG_RECORDING_TERMINATED_DUE_TO_RESIZE,\n   MSG_FAILED_TO_START_RECORDING,\n   MSG_REVERTING_SAVEFILE_DIRECTORY_TO,\n   MSG_ERROR_PARSING_ARGUMENTS,\n   MSG_REVERTING_SAVESTATE_DIRECTORY_TO,\n   MSG_DOWNLOAD_FAILED,\n   MSG_APPLYING_CHEAT,\n   MSG_APPLYING_PATCH,\n   MSG_INPUT_CHEAT,\n   MSG_INPUT_CHEAT_FILENAME,\n   MSG_INPUT_PRESET_FILENAME,\n   MSG_INPUT_OVERRIDE_FILENAME,\n   MSG_INPUT_REMAP_FILENAME,\n   MSG_INPUT_RENAME_ENTRY,\n   MSG_INPUT_ENABLE_SETTINGS_PASSWORD,\n   MSG_INPUT_ENABLE_SETTINGS_PASSWORD_OK,\n   MSG_INPUT_ENABLE_SETTINGS_PASSWORD_NOK,\n   MSG_INPUT_KIOSK_MODE_PASSWORD,\n   MSG_INPUT_KIOSK_MODE_PASSWORD_OK,\n   MSG_INPUT_KIOSK_MODE_PASSWORD_NOK,\n   MSG_REMAP_FILE_SAVED_SUCCESSFULLY,\n   MSG_REMAP_FILE_REMOVED_SUCCESSFULLY,\n   MSG_REMAP_FILE_RESET,\n   MSG_INPUT_BIND_PRESS,\n   MSG_INPUT_BIND_RELEASE,\n   MSG_INPUT_BIND_TIMEOUT,\n   MSG_INPUT_BIND_HOLD,\n   MSG_OVERRIDE_UNLOAD,\n   MSG_SHADER_PRESET_SAVED_SUCCESSFULLY,\n   MSG_SHADER_PRESET_REMOVED_SUCCESSFULLY,\n   MSG_ERROR_SAVING_REMAP_FILE,\n   MSG_ERROR_REMOVING_REMAP_FILE,\n   MSG_ERROR_SAVING_SHADER_PRESET,\n   MSG_ERROR_REMOVING_SHADER_PRESET,\n   MSG_FAILED_TO_CREATE_THE_DIRECTORY,\n   MSG_ERROR_SAVING_CORE_OPTIONS_FILE,\n   MSG_ERROR_REMOVING_CORE_OPTIONS_FILE,\n   MSG_CORE_OPTIONS_FILE_CREATED_SUCCESSFULLY,\n   MSG_CORE_OPTIONS_FILE_REMOVED_SUCCESSFULLY,\n   MSG_CORE_OPTIONS_RESET,\n   MSG_CORE_OPTIONS_FLUSHED,\n   MSG_CORE_OPTIONS_FLUSH_FAILED,\n   MSG_DECOMPRESSION_ALREADY_IN_PROGRESS,\n   MSG_DECOMPRESSION_FAILED,\n   MSG_DISK_EJECTED,\n   MSG_DISK_CLOSED,\n   MSG_REWIND_UNSUPPORTED,\n   MSG_REWIND_INIT,\n   MSG_REWIND_INIT_FAILED,\n   MSG_REWIND_INIT_FAILED_THREADED_AUDIO,\n   MSG_LIBRETRO_ABI_BREAK,\n   MSG_DETECTED_VIEWPORT_OF,\n   MSG_RECORDING_TO,\n   MSG_HW_RENDERED_MUST_USE_POSTSHADED_RECORDING,\n   MSG_VIEWPORT_SIZE_CALCULATION_FAILED,\n   MSG_AUTOSAVE_FAILED,\n   MSG_MOVIE_RECORD_STOPPED,\n   MSG_MOVIE_PLAYBACK_ENDED,\n   MSG_TAKING_SCREENSHOT,\n   MSG_SCREENSHOT_SAVED,\n   MSG_ACHIEVEMENT_UNLOCKED,\n   MSG_RARE_ACHIEVEMENT_UNLOCKED,\n   MSG_LEADERBOARD_STARTED,\n   MSG_LEADERBOARD_FAILED,\n   MSG_LEADERBOARD_SUBMISSION,\n   MSG_LEADERBOARD_RANK,\n   MSG_LEADERBOARD_BEST,\n   MSG_CHANGE_THUMBNAIL_TYPE,\n   MSG_TOGGLE_FULLSCREEN_THUMBNAILS,\n   MSG_TOGGLE_CONTENT_METADATA,\n   MSG_NO_THUMBNAIL_AVAILABLE,\n   MSG_NO_THUMBNAIL_DOWNLOAD_POSSIBLE,\n   MSG_PRESS_AGAIN_TO_QUIT,\n   MSG_BLUETOOTH_PAIRING_REMOVED,\n   MSG_BLUETOOTH_SCAN_COMPLETE,\n   MSG_WIFI_SCAN_COMPLETE,\n   MSG_WIFI_CONNECTING_TO,\n   MSG_WIFI_EMPTY_SSID,\n   MSG_SCANNING_BLUETOOTH_DEVICES,\n   MSG_SCANNING_WIRELESS_NETWORKS,\n   MSG_ENABLING_WIRELESS,\n   MSG_DISABLING_WIRELESS,\n   MSG_DISCONNECTING_WIRELESS,\n   MSG_FAILED_TO_TAKE_SCREENSHOT,\n   MSG_CUSTOM_TIMING_GIVEN,\n   MSG_SAVING_STATE,\n   MSG_UNDOING_SAVE_STATE,\n   MSG_LOADING_STATE,\n   MSG_FAILED_TO_SAVE_STATE_TO,\n   MSG_FAILED_TO_SAVE_SRAM,\n   MSG_FAILED_TO_LOAD_SRAM,\n   MSG_STATE_SIZE,\n   MSG_FAILED_TO_LOAD_CONTENT,\n   MSG_COULD_NOT_READ_CONTENT_FILE,\n   MSG_SAVED_SUCCESSFULLY_TO,\n   MSG_BYTES,\n   MSG_BLOCKING_SRAM_OVERWRITE,\n   MSG_UNRECOGNIZED_COMMAND,\n   MSG_SENDING_COMMAND,\n   MSG_RESTARTING_RECORDING_DUE_TO_DRIVER_REINIT,\n   MSG_REWINDING,\n   MSG_SLOW_MOTION_REWIND,\n   MSG_SLOW_MOTION,\n   MSG_FAST_FORWARD,\n   MSG_REWIND_REACHED_END,\n   MSG_FAILED_TO_START_MOVIE_RECORD,\n   MSG_STATE_SLOT,\n   MSG_REPLAY_SLOT,\n   MSG_STARTING_MOVIE_RECORD_TO,\n   MSG_FAILED_TO_APPLY_SHADER,\n   MSG_FAILED_TO_APPLY_SHADER_PRESET,\n   MSG_APPLYING_SHADER,\n   MSG_SHADER,\n   MSG_REDIRECTING_SAVESTATE_TO,\n   MSG_REDIRECTING_SAVEFILE_TO,\n   MSG_REDIRECTING_CHEATFILE_TO,\n   MSG_PREPARING_FOR_CONTENT_SCAN,\n   MSG_SCANNING,\n   MSG_SCANNING_OF_DIRECTORY_FINISHED,\n   MSG_SCANNING_OF_FILE_FINISHED,\n   MSG_LOADED_STATE_FROM_SLOT,\n   MSG_LOADED_STATE_FROM_SLOT_AUTO,\n   MSG_REMOVING_TEMPORARY_CONTENT_FILE,\n   MSG_FAILED_TO_REMOVE_TEMPORARY_FILE,\n   MSG_STARTING_MOVIE_PLAYBACK,\n   MSG_APPENDED_DISK,\n   MSG_FAILED_TO_APPEND_DISK,\n   MSG_SKIPPING_SRAM_LOAD,\n   MSG_CONFIG_DIRECTORY_NOT_SET,\n   MSG_SAVED_STATE_TO_SLOT,\n   MSG_SAVED_STATE_TO_SLOT_AUTO,\n   MSG_CORE_DOES_NOT_SUPPORT_SAVESTATES,\n   MSG_FAILED_TO_LOAD_STATE,\n   MSG_FAILED_TO_UNDO_LOAD_STATE,\n   MSG_FAILED_TO_UNDO_SAVE_STATE,\n   MSG_RESET,\n   MSG_AUDIO_MUTED,\n   MSG_AUDIO_UNMUTED,\n   MSG_FAILED_TO_UNMUTE_AUDIO,\n   MSG_FAILED_TO_LOAD_OVERLAY,\n   MSG_OSK_OVERLAY_NOT_SET,\n   MSG_PAUSED,\n   MSG_UNPAUSED,\n   MSG_CORE_DOES_NOT_SUPPORT_DISK_OPTIONS,\n   MSG_GRAB_MOUSE_STATE,\n   MSG_GAME_FOCUS_ON,\n   MSG_GAME_FOCUS_OFF,\n   MSG_FAILED_TO_LOAD_MOVIE_FILE,\n   MSG_FAILED_TO,\n   MSG_SAVING_RAM_TYPE,\n   MSG_TO,\n   MSG_REMOVED_DISK_FROM_TRAY,\n   MSG_FAILED_TO_REMOVE_DISK_FROM_TRAY,\n   MSG_VIRTUAL_DISK_TRAY_EJECT,\n   MSG_VIRTUAL_DISK_TRAY_CLOSE,\n   MSG_GOT_INVALID_DISK_INDEX,\n   MSG_INDEX_FILE,\n   MSG_DOWNLOADING,\n   MSG_EXTRACTING,\n   MSG_EXTRACTING_FILE,\n   MSG_NO_CONTENT_STARTING_DUMMY_CORE,\n   MSG_CONFIG_OVERRIDE_LOADED,\n   MSG_GAME_REMAP_FILE_LOADED,\n   MSG_DIRECTORY_REMAP_FILE_LOADED,\n   MSG_CORE_REMAP_FILE_LOADED,\n   MSG_REMAP_FILE_FLUSHED,\n   MSG_REMAP_FILE_FLUSH_FAILED,\n   MSG_RUNAHEAD_ENABLED,\n   MSG_RUNAHEAD_ENABLED_WITH_SECOND_INSTANCE,\n   MSG_RUNAHEAD_DISABLED,\n   MSG_RUNAHEAD_CORE_DOES_NOT_SUPPORT_SAVESTATES,\n   MSG_RUNAHEAD_CORE_DOES_NOT_SUPPORT_RUNAHEAD,\n   MSG_RUNAHEAD_FAILED_TO_SAVE_STATE,\n   MSG_RUNAHEAD_FAILED_TO_LOAD_STATE,\n   MSG_RUNAHEAD_FAILED_TO_CREATE_SECONDARY_INSTANCE,\n   MSG_PREEMPT_ENABLED,\n   MSG_PREEMPT_DISABLED,\n   MSG_PREEMPT_CORE_DOES_NOT_SUPPORT_SAVESTATES,\n   MSG_PREEMPT_CORE_DOES_NOT_SUPPORT_PREEMPT,\n   MSG_PREEMPT_FAILED_TO_ALLOCATE,\n   MSG_PREEMPT_FAILED_TO_SAVE_STATE,\n   MSG_PREEMPT_FAILED_TO_LOAD_STATE,\n   MSG_MISSING_ASSETS,\n   MSG_RGUI_MISSING_FONTS,\n   MSG_RGUI_INVALID_LANGUAGE,\n#ifdef HAVE_LAKKA\n   MSG_LOCALAP_SWITCHING_OFF,\n   MSG_WIFI_DISCONNECT_FROM,\n   MSG_LOCALAP_ALREADY_RUNNING,\n   MSG_LOCALAP_NOT_RUNNING,\n   MSG_LOCALAP_STARTING,\n   MSG_LOCALAP_ERROR_CONFIG_CREATE,\n   MSG_LOCALAP_ERROR_CONFIG_PARSE,\n#endif\n   MSG_UNSUPPORTED_VIDEO_MODE,\n   MSG_CORE_INFO_CACHE_UNSUPPORTED,\n   MSG_LOADING_ENTRY_STATE_FROM,\n   MSG_FOUND_ENTRY_STATE_IN,\n   MSG_FAILED_TO_ENTER_GAMEMODE,\n   MSG_FAILED_TO_ENTER_GAMEMODE_LINUX,\n   MSG_VRR_RUNLOOP_ENABLED,\n   MSG_VRR_RUNLOOP_DISABLED,\n   MSG_VIDEO_REFRESH_RATE_CHANGED,\n\n   MSG_IOS_TOUCH_MOUSE_ENABLED,\n   MSG_IOS_TOUCH_MOUSE_DISABLED,\n   MSG_SDL2_MIC_NEEDS_SDL2_AUDIO,\n\n   /* Add To Playlist*/\n   MSG_ADDED_TO_PLAYLIST,\n   MSG_ADD_TO_PLAYLIST_FAILED,\n   MENU_ENUM_LABEL_ADD_ENTRY_TO_PLAYLIST,\n   MENU_ENUM_LABEL_DEFERRED_ADD_TO_PLAYLIST_LIST,\n   MENU_LABEL(ADD_TO_PLAYLIST),\n   MENU_LABEL(CREATE_NEW_PLAYLIST),\n\n   MENU_LABEL(MENU_XMB_ANIMATION_HORIZONTAL_HIGHLIGHT),\n   MENU_LABEL(MENU_XMB_ANIMATION_MOVE_UP_DOWN),\n   MENU_LABEL(MENU_XMB_ANIMATION_OPENING_MAIN_MENU),\n   MENU_LABEL(SCAN_WITHOUT_CORE_MATCH),\n   MENU_LABEL(SCAN_SERIAL_AND_CRC),\n   MENU_LABEL(STREAMING_TITLE),\n   MENU_LABEL(STREAMING_MODE),\n   MENU_ENUM_LABEL_VALUE_VIDEO_STREAMING_MODE_TWITCH,\n   MENU_ENUM_LABEL_VALUE_VIDEO_STREAMING_MODE_YOUTUBE,\n   MENU_ENUM_LABEL_VALUE_VIDEO_STREAMING_MODE_FACEBOOK,\n   MENU_ENUM_LABEL_VALUE_VIDEO_STREAMING_MODE_LOCAL,\n   MENU_ENUM_LABEL_VALUE_VIDEO_STREAMING_MODE_CUSTOM,\n   MENU_LABEL(VIDEO_RECORD_QUALITY),\n   MENU_ENUM_LABEL_VALUE_VIDEO_RECORD_CONFIG_TYPE_RECORDING_CUSTOM,\n   MENU_ENUM_LABEL_VALUE_VIDEO_RECORD_CONFIG_TYPE_RECORDING_LOW_QUALITY,\n   MENU_ENUM_LABEL_VALUE_VIDEO_RECORD_CONFIG_TYPE_RECORDING_MED_QUALITY,\n   MENU_ENUM_LABEL_VALUE_VIDEO_RECORD_CONFIG_TYPE_RECORDING_HIGH_QUALITY,\n   MENU_ENUM_LABEL_VALUE_VIDEO_RECORD_CONFIG_TYPE_RECORDING_LOSSLESS_QUALITY,\n   MENU_ENUM_LABEL_VALUE_VIDEO_RECORD_CONFIG_TYPE_RECORDING_WEBM_FAST,\n   MENU_ENUM_LABEL_VALUE_VIDEO_RECORD_CONFIG_TYPE_RECORDING_WEBM_HIGH_QUALITY,\n   MENU_ENUM_LABEL_VALUE_VIDEO_RECORD_CONFIG_TYPE_RECORDING_GIF,\n   MENU_ENUM_LABEL_VALUE_VIDEO_RECORD_CONFIG_TYPE_RECORDING_APNG,\n   MENU_LABEL(VIDEO_STREAM_QUALITY),\n   MENU_ENUM_LABEL_VALUE_VIDEO_RECORD_CONFIG_TYPE_STREAMING_CUSTOM,\n   MENU_ENUM_LABEL_VALUE_VIDEO_RECORD_CONFIG_TYPE_STREAMING_LOW_QUALITY,\n   MENU_ENUM_LABEL_VALUE_VIDEO_RECORD_CONFIG_TYPE_STREAMING_MED_QUALITY,\n   MENU_ENUM_LABEL_VALUE_VIDEO_RECORD_CONFIG_TYPE_STREAMING_HIGH_QUALITY,\n   MENU_LABEL(STREAMING_URL),\n   MENU_LABEL(UDP_STREAM_PORT),\n   MENU_LABEL(MIXER_STREAM),\n   MENU_LABEL(ADD_TO_MIXER),\n   MENU_LABEL(ADD_TO_MIXER_AND_PLAY),\n   MENU_LABEL(ADD_TO_MIXER_AND_COLLECTION),\n   MENU_LABEL(ADD_TO_MIXER_AND_COLLECTION_AND_PLAY),\n   MENU_ENUM_LABEL_VALUE_AUDIO_STREAM_STATE_NONE,\n   MENU_ENUM_LABEL_VALUE_AUDIO_STREAM_STATE_STOPPED,\n   MENU_ENUM_LABEL_VALUE_AUDIO_STREAM_STATE_PLAYING,\n   MENU_ENUM_LABEL_VALUE_AUDIO_STREAM_STATE_PLAYING_LOOPED,\n   MENU_ENUM_LABEL_VALUE_AUDIO_STREAM_STATE_PLAYING_SEQUENTIAL,\n   MENU_LABEL(TWITCH_STREAM_KEY),\n   MENU_LABEL(YOUTUBE_STREAM_KEY),\n   MENU_LABEL(FACEBOOK_STREAM_KEY),\n   MENU_ENUM_LABEL_MENU_TOGGLE,\n\n   MENU_LABEL(FILTER_BY_CURRENT_CORE),\n\n   MENU_LABEL(NO_HISTORY_AVAILABLE),\n   MENU_LABEL(NO_MUSIC_AVAILABLE),\n   MENU_LABEL(NO_VIDEOS_AVAILABLE),\n   MENU_LABEL(NO_IMAGES_AVAILABLE),\n   MENU_LABEL(NO_FAVORITES_AVAILABLE),\n\n   MENU_ENUM_LABEL_DISCORD_IN_MENU,\n   MENU_ENUM_LABEL_VALUE_DISCORD_IN_MENU,\n   MENU_ENUM_LABEL_DISCORD_IN_GAME,\n   MENU_ENUM_LABEL_VALUE_DISCORD_IN_GAME,\n   MENU_ENUM_LABEL_DISCORD_IN_GAME_PAUSED,\n   MENU_ENUM_LABEL_VALUE_DISCORD_IN_GAME_PAUSED,\n   MENU_ENUM_LABEL_DISCORD_STATUS_PLAYING,\n   MENU_ENUM_LABEL_VALUE_DISCORD_STATUS_PLAYING,\n   MENU_ENUM_LABEL_DISCORD_STATUS_PAUSED,\n   MENU_ENUM_LABEL_VALUE_DISCORD_STATUS_PAUSED,\n\n   MENU_ENUM_LABEL_VALUE_CHEAT_FILE,\n   MENU_ENUM_LABEL_VALUE_CHEAT_FILE_APPEND,\n\n   MENU_ENUM_LABEL_HELP_INPUT_RETROPAD_BINDS,\n   MENU_ENUM_LABEL_INPUT_HOTKEY_BIND_BEGIN,\n   MENU_ENUM_LABEL_INPUT_HOTKEY_BIND_END   = MENU_ENUM_LABEL_INPUT_HOTKEY_BIND_BEGIN + RARCH_BIND_LIST_END,\n\n   MENU_LABEL(MENU_SCALE_FACTOR),\n   MENU_LABEL(MENU_WIDGET_SCALE_AUTO),\n   MENU_LABEL(MENU_WIDGET_SCALE_FACTOR),\n   MENU_LABEL(MENU_WIDGET_SCALE_FACTOR_FULLSCREEN),\n   MENU_LABEL(MENU_WIDGET_SCALE_FACTOR_WINDOWED),\n   MENU_LABEL(MENU_WALLPAPER_OPACITY),\n   MENU_LABEL(MENU_FRAMEBUFFER_OPACITY),\n   MENU_LABEL(MENU_USE_PREFERRED_SYSTEM_COLOR_THEME),\n\n   MENU_ENUM_LABEL_VALUE_CONFIG,\n   MENU_ENUM_LABEL_VALUE_OVERLAY,\n   MENU_ENUM_LABEL_VALUE_AUTO,\n\n   MENU_LABEL(MATERIALUI_ICONS_ENABLE),\n   MENU_LABEL(MATERIALUI_SWITCH_ICONS),\n   MENU_LABEL(MATERIALUI_PLAYLIST_ICONS_ENABLE),\n   MENU_LABEL(MATERIALUI_SHOW_NAV_BAR),\n   MENU_LABEL(MATERIALUI_AUTO_ROTATE_NAV_BAR),\n   MENU_LABEL(MATERIALUI_DUAL_THUMBNAIL_LIST_VIEW_ENABLE),\n   MENU_LABEL(MATERIALUI_THUMBNAIL_BACKGROUND_ENABLE),\n\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_CUSTOM,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_CLASSIC_RED,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_CLASSIC_ORANGE,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_CLASSIC_YELLOW,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_CLASSIC_GREEN,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_CLASSIC_BLUE,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_CLASSIC_VIOLET,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_CLASSIC_GREY,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_LEGACY_RED,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_DARK_PURPLE,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_MIDNIGHT_BLUE,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_GOLDEN,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_ELECTRIC_BLUE,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_APPLE_GREEN,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_VOLCANIC_RED,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_LAGOON,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_BROGRAMMER,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_DRACULA,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_FAIRYFLOSS,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_FLATUI,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_GRUVBOX_DARK,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_GRUVBOX_LIGHT,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_HACKING_THE_KERNEL,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_NORD,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_NOVA,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_ONE_DARK,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_PALENIGHT,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_SOLARIZED_DARK,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_SOLARIZED_LIGHT,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_TANGO_DARK,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_TANGO_LIGHT,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_ZENBURN,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_ANTI_ZENBURN,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_FLUX,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_DYNAMIC,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_GRAY_DARK,\n   MENU_ENUM_LABEL_VALUE_RGUI_MENU_COLOR_THEME_GRAY_LIGHT,\n\n   MENU_ENUM_LABEL_VALUE_OZONE_COLOR_THEME_BASIC_WHITE,\n   MENU_ENUM_LABEL_VALUE_OZONE_COLOR_THEME_BASIC_BLACK,\n   MENU_ENUM_LABEL_VALUE_OZONE_COLOR_THEME_NORD,\n   MENU_ENUM_LABEL_VALUE_OZONE_COLOR_THEME_GRUVBOX_DARK,\n   MENU_ENUM_LABEL_VALUE_OZONE_COLOR_THEME_BOYSENBERRY,\n   MENU_ENUM_LABEL_VALUE_OZONE_COLOR_THEME_HACKING_THE_KERNEL,\n   MENU_ENUM_LABEL_VALUE_OZONE_COLOR_THEME_TWILIGHT_ZONE,\n   MENU_ENUM_LABEL_VALUE_OZONE_COLOR_THEME_DRACULA,\n   MENU_ENUM_LABEL_VALUE_OZONE_COLOR_THEME_SELENIUM,\n   MENU_ENUM_LABEL_VALUE_OZONE_COLOR_THEME_SOLARIZED_DARK,\n   MENU_ENUM_LABEL_VALUE_OZONE_COLOR_THEME_SOLARIZED_LIGHT,\n   MENU_ENUM_LABEL_VALUE_OZONE_COLOR_THEME_GRAY_DARK,\n   MENU_ENUM_LABEL_VALUE_OZONE_COLOR_THEME_GRAY_LIGHT,\n   MENU_ENUM_LABEL_VALUE_OZONE_COLOR_THEME_PURPLE_RAIN,\n\n   MENU_ENUM_LABEL_VALUE_XMB_ICON_THEME_MONOCHROME,\n   MENU_ENUM_LABEL_VALUE_XMB_ICON_THEME_MONOCHROME_INVERTED,\n   MENU_ENUM_LABEL_VALUE_XMB_ICON_THEME_FLATUI,\n   MENU_ENUM_LABEL_VALUE_XMB_ICON_THEME_FLATUX,\n   MENU_ENUM_LABEL_VALUE_XMB_ICON_THEME_RETROSYSTEM,\n   MENU_ENUM_LABEL_VALUE_XMB_ICON_THEME_PIXEL,\n   MENU_ENUM_LABEL_VALUE_XMB_ICON_THEME_SYSTEMATIC,\n   MENU_ENUM_LABEL_VALUE_XMB_ICON_THEME_DOTART,\n   MENU_ENUM_LABEL_VALUE_XMB_ICON_THEME_CUSTOM,\n   MENU_ENUM_LABEL_VALUE_XMB_ICON_THEME_AUTOMATIC,\n   MENU_ENUM_LABEL_VALUE_XMB_ICON_THEME_AUTOMATIC_INVERTED,\n   MENU_ENUM_LABEL_VALUE_XMB_ICON_THEME_DAITE,\n\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_LEGACY_RED,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_DARK_PURPLE,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_MIDNIGHT_BLUE,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_GOLDEN,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_ELECTRIC_BLUE,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_APPLE_GREEN,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_UNDERSEA,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_VOLCANIC_RED,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_DARK,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_LIGHT,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_PLAIN,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_MORNING_BLUE,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_SUNBEAM,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_LIME,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_PIKACHU_YELLOW,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_GAMECUBE_PURPLE,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_FAMICOM_RED,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_FLAMING_HOT,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_ICE_COLD,\n   MENU_ENUM_LABEL_VALUE_XMB_MENU_COLOR_THEME_MIDGAR,\n\n   MENU_LABEL(SHADER_PIPELINE_RIBBON_SIMPLIFIED),\n   MENU_LABEL(SHADER_PIPELINE_RIBBON),\n   MENU_LABEL(SHADER_PIPELINE_SIMPLE_SNOW),\n   MENU_LABEL(SHADER_PIPELINE_SNOW),\n   MENU_LABEL(SHADER_PIPELINE_BOKEH),\n   MENU_LABEL(SHADER_PIPELINE_SNOWFLAKE),\n\n   MENU_LABEL(VIDEO_SHADERS_ENABLE),\n\n   MENU_LABEL(MATERIALUI_MENU_HEADER_OPACITY),\n   MENU_LABEL(MATERIALUI_MENU_FOOTER_OPACITY),\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_BLUE,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_BLUE_GREY,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_RED,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_GREEN,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_YELLOW,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_NVIDIA_SHIELD,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_DARK_BLUE,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_MATERIALUI,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_MATERIALUI_DARK,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_OZONE_DARK,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_NORD,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_GRUVBOX_DARK,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_SOLARIZED_DARK,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_CUTIE_BLUE,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_CUTIE_CYAN,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_CUTIE_GREEN,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_CUTIE_ORANGE,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_CUTIE_PINK,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_CUTIE_PURPLE,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_CUTIE_RED,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_VIRTUAL_BOY,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_HACKING_THE_KERNEL,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_GRAY_DARK,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_COLOR_THEME_GRAY_LIGHT,\n\n   MENU_LABEL(MATERIALUI_MENU_TRANSITION_ANIMATION),\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_TRANSITION_ANIM_AUTO,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_TRANSITION_ANIM_FADE,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_TRANSITION_ANIM_SLIDE,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_MENU_TRANSITION_ANIM_NONE,\n\n   MENU_LABEL(MATERIALUI_MENU_THUMBNAIL_VIEW_PORTRAIT),\n   MENU_LABEL(MATERIALUI_MENU_THUMBNAIL_VIEW_LANDSCAPE),\n\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_THUMBNAIL_VIEW_PORTRAIT_DISABLED,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_THUMBNAIL_VIEW_PORTRAIT_LIST_SMALL,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_THUMBNAIL_VIEW_PORTRAIT_LIST_MEDIUM,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_THUMBNAIL_VIEW_PORTRAIT_DUAL_ICON,\n\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_THUMBNAIL_VIEW_LANDSCAPE_DISABLED,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_THUMBNAIL_VIEW_LANDSCAPE_LIST_SMALL,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_THUMBNAIL_VIEW_LANDSCAPE_LIST_MEDIUM,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_THUMBNAIL_VIEW_LANDSCAPE_LIST_LARGE,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_THUMBNAIL_VIEW_LANDSCAPE_DESKTOP,\n\n   MENU_LABEL(MATERIALUI_LANDSCAPE_LAYOUT_OPTIMIZATION),\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_LANDSCAPE_LAYOUT_OPTIMIZATION_DISABLED,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_LANDSCAPE_LAYOUT_OPTIMIZATION_ALWAYS,\n   MENU_ENUM_LABEL_VALUE_MATERIALUI_LANDSCAPE_LAYOUT_OPTIMIZATION_EXCLUDE_THUMBNAIL_VIEWS,\n\n   MENU_ENUM_LABEL_VALUE_INPUT_POLL_TYPE_BEHAVIOR_LATE,\n   MENU_ENUM_LABEL_VALUE_INPUT_POLL_TYPE_BEHAVIOR_NORMAL,\n   MENU_ENUM_LABEL_VALUE_INPUT_POLL_TYPE_BEHAVIOR_EARLY,\n\n   MENU_ENUM_LABEL_VALUE_RUNAHEAD_MODE_SINGLE_INSTANCE,\n   MENU_ENUM_LABEL_VALUE_RUNAHEAD_MODE_SECOND_INSTANCE,\n   MENU_ENUM_LABEL_VALUE_RUNAHEAD_MODE_PREEMPTIVE_FRAMES,\n\n   MENU_LABEL(CHEEVOS_UNLOCKED_ENTRY),\n   MENU_LABEL(CHEEVOS_UNLOCKED_ENTRY_HARDCORE),\n   MENU_LABEL(CHEEVOS_LOCKED_ENTRY),\n   MENU_LABEL(CHEEVOS_UNSUPPORTED_ENTRY),\n   MENU_LABEL(CHEEVOS_UNOFFICIAL_ENTRY),\n   MENU_ENUM_LABEL_VALUE_CHEEVOS_RECENTLY_UNLOCKED_ENTRY,\n   MENU_ENUM_LABEL_VALUE_CHEEVOS_ALMOST_THERE_ENTRY,\n   MENU_ENUM_LABEL_VALUE_CHEEVOS_ACTIVE_CHALLENGES_ENTRY,\n   MENU_ENUM_LABEL_VALUE_CHEEVOS_TRACKERS_ONLY,\n   MENU_ENUM_LABEL_VALUE_CHEEVOS_NOTIFICATIONS_ONLY,\n\n   MENU_ENUM_LABEL_SHADER_PARAMETERS_ENTRY,\n   MENU_ENUM_LABEL_RDB_ENTRY,\n   MENU_ENUM_LABEL_URL_ENTRY,\n   MENU_ENUM_LABEL_CORE_UPDATER_ENTRY,\n   MENU_ENUM_LABEL_CORE_OPTION_ENTRY,\n   MENU_ENUM_LABEL_NETWORK_INFO_ENTRY,\n   MENU_ENUM_LABEL_SYSTEM_INFO_ENTRY,\n   MENU_ENUM_LABEL_SYSTEM_INFO_CONTROLLER_ENTRY,\n   MENU_ENUM_LABEL_CORE_INFO_ENTRY,\n   MENU_ENUM_LABEL_CORE_MANAGER_ENTRY,\n#ifdef HAVE_MIST\n   MENU_ENUM_LABEL_CORE_MANAGER_STEAM_ENTRY,\n#endif\n   MENU_ENUM_LABEL_PLAYLIST_COLLECTION_ENTRY,\n   MENU_ENUM_LABEL_PLAYLIST_ENTRY,\n\n   MENU_LABEL(START_VIDEO_PROCESSOR),\n   MENU_LABEL(START_NET_RETROPAD),\n   MENU_LABEL(START_GONG),\n\n   /* System information */\n   MENU_LABEL(CPU_CORES),\n   MENU_LABEL(CPU_ARCHITECTURE),\n   MENU_LABEL(JIT_AVAILABLE),\n\n   /* Input  */\n\n   MENU_ENUM_LABEL_INPUT_LIBRETRO_DEVICE,\n   MENU_ENUM_LABEL_INPUT_LIBRETRO_DEVICE_LAST = MENU_ENUM_LABEL_INPUT_LIBRETRO_DEVICE + MAX_USERS,\n   MENU_ENUM_LABEL_INPUT_PLAYER_ANALOG_DPAD_MODE,\n   MENU_ENUM_LABEL_INPUT_PLAYER_ANALOG_DPAD_MODE_LAST = MENU_ENUM_LABEL_INPUT_PLAYER_ANALOG_DPAD_MODE + MAX_USERS,\n   MENU_ENUM_LABEL_INPUT_DEVICE_INDEX,\n   MENU_ENUM_LABEL_INPUT_DEVICE_INDEX_LAST = MENU_ENUM_LABEL_INPUT_DEVICE_INDEX + MAX_USERS,\n   MENU_ENUM_LABEL_INPUT_DEVICE_RESERVATION_TYPE,\n   MENU_ENUM_LABEL_INPUT_DEVICE_RESERVATION_TYPE_LAST = MENU_ENUM_LABEL_INPUT_DEVICE_RESERVATION_TYPE + MAX_USERS,\n   MENU_ENUM_LABEL_INPUT_DEVICE_RESERVED_DEVICE_NAME,\n   MENU_ENUM_LABEL_INPUT_DEVICE_RESERVED_DEVICE_NAME_LAST = MENU_ENUM_LABEL_INPUT_DEVICE_RESERVED_DEVICE_NAME + MAX_USERS,\n   MENU_ENUM_LABEL_INPUT_MOUSE_INDEX,\n   MENU_ENUM_LABEL_INPUT_MOUSE_INDEX_LAST = MENU_ENUM_LABEL_INPUT_MOUSE_INDEX + MAX_USERS,\n   MENU_ENUM_LABEL_INPUT_REMAP_PORT,\n   MENU_ENUM_LABEL_INPUT_REMAP_PORT_LAST = MENU_ENUM_LABEL_INPUT_REMAP_PORT + MAX_USERS,\n\n   MENU_ENUM_LABEL_INPUT_SETTINGS_BEGIN,\n\n   MENU_LABEL(INPUT_RETROPAD_BINDS),\n   MENU_LABEL(INPUT_HOTKEY_BINDS),\n   MENU_LABEL(INPUT_HOTKEY_BLOCK_DELAY),\n   MENU_LABEL(INPUT_HOTKEY_DEVICE_MERGE),\n   MENU_LABEL(INPUT_SPLIT_JOYCON),\n\n   MENU_ENUM_LABEL_INPUT_HOTKEY_BINDS_BEGIN,\n\n   MENU_LABEL(INPUT_TURBO_PERIOD),\n   MENU_LABEL(INPUT_TURBO_MODE),\n   MENU_ENUM_LABEL_VALUE_TURBO_MODE_CLASSIC,\n   MENU_ENUM_LABEL_VALUE_TURBO_MODE_CLASSIC_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_TURBO_MODE_SINGLEBUTTON,\n   MENU_ENUM_LABEL_VALUE_TURBO_MODE_SINGLEBUTTON_HOLD,\n   MENU_ENUM_LABEL_HELP_TURBO_MODE_CLASSIC,\n   MENU_ENUM_LABEL_HELP_TURBO_MODE_CLASSIC_TOGGLE,\n   MENU_ENUM_LABEL_HELP_TURBO_MODE_SINGLEBUTTON,\n   MENU_ENUM_LABEL_HELP_TURBO_MODE_SINGLEBUTTON_HOLD,\n   MENU_LABEL(INPUT_TURBO_DEFAULT_BUTTON),\n   MENU_LABEL(INPUT_ALLOW_TURBO_DPAD),\n\n/* MENU_ENUM_LABEL_INPUT_PLAYER1_JOYPAD_INDEX,\n   MENU_ENUM_LABEL_INPUT_PLAYER2_JOYPAD_INDEX,\n   MENU_ENUM_LABEL_INPUT_PLAYER3_JOYPAD_INDEX,\n   MENU_ENUM_LABEL_INPUT_PLAYER4_JOYPAD_INDEX,\n   MENU_ENUM_LABEL_INPUT_PLAYER5_JOYPAD_INDEX,*/\n   MENU_ENUM_LABEL_INPUT_BIND_DEVICE_TYPE,\n   MENU_ENUM_LABEL_INPUT_BIND_DEVICE_INDEX,\n\n   MENU_ENUM_LABEL_INPUT_DRIVER_ANDROID,\n   MENU_ENUM_LABEL_INPUT_DRIVER_PS4,\n   MENU_ENUM_LABEL_INPUT_DRIVER_PS3,\n   MENU_ENUM_LABEL_INPUT_DRIVER_PSP,\n   MENU_ENUM_LABEL_INPUT_DRIVER_PS2,\n   MENU_ENUM_LABEL_INPUT_DRIVER_CTR,\n   MENU_ENUM_LABEL_INPUT_DRIVER_SWITCH,\n   MENU_ENUM_LABEL_INPUT_DRIVER_SDL,\n   MENU_ENUM_LABEL_INPUT_DRIVER_SDL2,\n   MENU_ENUM_LABEL_INPUT_DRIVER_SDL_DINGUX,\n   MENU_ENUM_LABEL_INPUT_DRIVER_DINPUT,\n   MENU_ENUM_LABEL_INPUT_DRIVER_WINRAW,\n   MENU_ENUM_LABEL_INPUT_DRIVER_X,\n   MENU_ENUM_LABEL_INPUT_DRIVER_WAYLAND,\n   MENU_ENUM_LABEL_INPUT_DRIVER_XENON360,\n   MENU_ENUM_LABEL_INPUT_DRIVER_XINPUT,\n   MENU_ENUM_LABEL_INPUT_DRIVER_UWP,\n   MENU_ENUM_LABEL_INPUT_DRIVER_WII,\n   MENU_ENUM_LABEL_INPUT_DRIVER_WIIU,\n   MENU_ENUM_LABEL_INPUT_DRIVER_UDEV,\n   MENU_ENUM_LABEL_INPUT_DRIVER_LINUXRAW,\n   MENU_ENUM_LABEL_INPUT_DRIVER_COCOA,\n   MENU_ENUM_LABEL_INPUT_DRIVER_QNX,\n   MENU_ENUM_LABEL_INPUT_DRIVER_RWEBINPUT,\n   MENU_ENUM_LABEL_INPUT_DRIVER_DOS,\n   MENU_ENUM_LABEL_INPUT_DRIVER_NULL,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_ANDROID,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_PS4,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_PS3,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_PSP,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_PS2,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_CTR,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_SWITCH,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_SDL,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_SDL2,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_SDL_DINGUX,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_DINPUT,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_WINRAW,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_X,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_WAYLAND,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_XENON360,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_XINPUT,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_UWP,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_WII,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_WIIU,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_UDEV,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_LINUXRAW,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_COCOA,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_QNX,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_RWEBINPUT,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_DOS,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_NULL,\n   MENU_ENUM_LABEL_HELP_INPUT_DRIVER_NO_DETAILS,\n\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_ANDROID,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_CTR,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_DINPUT,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_DOS,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_GX,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_HID,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_LINUXRAW,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_PARPORT,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_PS2,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_PS3,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_PS4,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_PSP,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_QNX,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_RWEBPAD,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_SDL_DINGUX,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_SDL,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_SWITCH,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_UDEV,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_WIIU,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_XDK,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_XINPUT,\n   MENU_ENUM_LABEL_JOYPAD_DRIVER_NULL,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_ANDROID,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_CTR,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_DINPUT,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_DOS,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_GX,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_HID,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_LINUXRAW,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_PARPORT,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_PS2,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_PS3,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_PS4,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_PSP,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_QNX,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_RWEBPAD,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_SDL_DINGUX,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_SDL,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_SWITCH,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_UDEV,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_WIIU,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_XDK,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_XINPUT,\n   MENU_ENUM_LABEL_HELP_JOYPAD_DRIVER_NULL,\n\n   MENU_ENUM_LABEL_INPUT_USER_1_BINDS,\n   MENU_ENUM_LABEL_INPUT_USER_2_BINDS,\n   MENU_ENUM_LABEL_INPUT_USER_3_BINDS,\n   MENU_ENUM_LABEL_INPUT_USER_4_BINDS,\n   MENU_ENUM_LABEL_INPUT_USER_5_BINDS,\n   MENU_ENUM_LABEL_INPUT_USER_6_BINDS,\n   MENU_ENUM_LABEL_INPUT_USER_7_BINDS,\n   MENU_ENUM_LABEL_INPUT_USER_8_BINDS,\n   MENU_ENUM_LABEL_INPUT_USER_9_BINDS,\n   MENU_ENUM_LABEL_INPUT_USER_10_BINDS,\n   MENU_ENUM_LABEL_INPUT_USER_11_BINDS,\n   MENU_ENUM_LABEL_INPUT_USER_12_BINDS,\n   MENU_ENUM_LABEL_INPUT_USER_13_BINDS,\n   MENU_ENUM_LABEL_INPUT_USER_14_BINDS,\n   MENU_ENUM_LABEL_INPUT_USER_15_BINDS,\n   MENU_ENUM_LABEL_INPUT_USER_16_BINDS,\n   MENU_ENUM_LABEL_INPUT_RETROPAD_SETTINGS,\n   MENU_ENUM_LABEL_INPUT_HOTKEY_SETTINGS,\n\n   MENU_LABEL(INPUT_REMAPPING_DIRECTORY),\n\n   MENU_ENUM_LABEL_INPUT_OVERLAY,\n   MENU_ENUM_LABEL_INPUT_OSK_OVERLAY,\n\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_B,\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_Y,\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_SELECT,\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_START,\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_UP,\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_DOWN,\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_LEFT,\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_RIGHT,\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_A,\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_X,\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L,\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R,\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L2,\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R2,\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_L3,\n   MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_R3,\n   MENU_ENUM_LABEL_VALUE_INPUT_KEY,\n   MENU_ENUM_LABEL_VALUE_INPUT_MOUSE_LEFT,\n   MENU_ENUM_LABEL_VALUE_INPUT_MOUSE_RIGHT,\n   MENU_ENUM_LABEL_VALUE_INPUT_MOUSE_MIDDLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_MOUSE_BUTTON4,\n   MENU_ENUM_LABEL_VALUE_INPUT_MOUSE_BUTTON5,\n   MENU_ENUM_LABEL_VALUE_INPUT_MOUSE_WHEEL_UP,\n   MENU_ENUM_LABEL_VALUE_INPUT_MOUSE_WHEEL_DOWN,\n   MENU_ENUM_LABEL_VALUE_INPUT_MOUSE_HORIZ_WHEEL_UP,\n   MENU_ENUM_LABEL_VALUE_INPUT_MOUSE_HORIZ_WHEEL_DOWN,\n   MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_X,\n   MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_Y,\n   MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_X,\n   MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_Y,\n   MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_X_PLUS,\n   MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_X_MINUS,\n   MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_Y_PLUS,\n   MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_LEFT_Y_MINUS,\n   MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_X_PLUS,\n   MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_X_MINUS,\n   MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_Y_PLUS,\n   MENU_ENUM_LABEL_VALUE_INPUT_ANALOG_RIGHT_Y_MINUS,\n   MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_TRIGGER,\n   MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_RELOAD,\n   MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_A,\n   MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_B,\n   MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_AUX_C,\n   MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_START,\n   MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_SELECT,\n   MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_UP,\n   MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_DOWN,\n   MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_LEFT,\n   MENU_ENUM_LABEL_VALUE_INPUT_LIGHTGUN_DPAD_RIGHT,\n   MENU_ENUM_LABEL_VALUE_INPUT_TURBO_ENABLE,\n\n   MENU_ENUM_LABEL_VALUE_INPUT_META_ENABLE_HOTKEY,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_MENU_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_QUIT_KEY,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_RESTART_KEY,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_CLOSE_CONTENT_KEY,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_RESET,\n\n   MENU_ENUM_LABEL_VALUE_INPUT_META_FAST_FORWARD_KEY,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_FAST_FORWARD_HOLD_KEY,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_SLOWMOTION_KEY,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_SLOWMOTION_HOLD_KEY,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_PAUSE_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_FRAMEADVANCE,\n\n   MENU_ENUM_LABEL_VALUE_INPUT_META_MUTE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_VOLUME_UP,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_VOLUME_DOWN,\n\n   MENU_ENUM_LABEL_VALUE_INPUT_META_LOAD_STATE_KEY,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_SAVE_STATE_KEY,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_STATE_SLOT_PLUS,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_STATE_SLOT_MINUS,\n\n   MENU_ENUM_LABEL_VALUE_INPUT_META_PLAY_REPLAY_KEY,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_RECORD_REPLAY_KEY,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_HALT_REPLAY_KEY,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_REPLAY_SLOT_PLUS,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_REPLAY_SLOT_MINUS,\n\n   MENU_ENUM_LABEL_VALUE_INPUT_META_DISK_EJECT_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_DISK_NEXT,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_DISK_PREV,\n\n   MENU_ENUM_LABEL_VALUE_INPUT_META_SHADER_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_SHADER_NEXT,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_SHADER_PREV,\n\n   MENU_ENUM_LABEL_VALUE_INPUT_META_CHEAT_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_CHEAT_INDEX_PLUS,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_CHEAT_INDEX_MINUS,\n\n   MENU_ENUM_LABEL_VALUE_INPUT_META_SCREENSHOT,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_RECORDING_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_STREAMING_TOGGLE,\n\n   MENU_ENUM_LABEL_VALUE_INPUT_META_GRAB_MOUSE_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_GAME_FOCUS_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_FULLSCREEN_TOGGLE_KEY,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_UI_COMPANION_TOGGLE,\n\n   MENU_ENUM_LABEL_VALUE_INPUT_META_VRR_RUNLOOP_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_RUNAHEAD_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_PREEMPT_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_FPS_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_STATISTICS_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_AI_SERVICE,\n\n   MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_PING_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_HOST_TOGGLE,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_GAME_WATCH,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_PLAYER_CHAT,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_NETPLAY_FADE_CHAT_TOGGLE,\n\n   MENU_ENUM_LABEL_VALUE_INPUT_META_OVERLAY_NEXT, /* Hidden */\n   MENU_ENUM_LABEL_VALUE_INPUT_META_OSK,\n   MENU_ENUM_LABEL_VALUE_INPUT_META_SEND_DEBUG_INFO, /* Deprecated */\n\n   MENU_ENUM_LABEL_VALUE_INPUT_DEVICE_INDEX,\n   MENU_ENUM_LABEL_VALUE_INPUT_DEVICE_TYPE,\n   MENU_ENUM_LABEL_VALUE_INPUT_ADC_TYPE,\n   MENU_ENUM_LABEL_VALUE_INPUT_BIND_ALL,\n   MENU_ENUM_LABEL_VALUE_INPUT_BIND_DEFAULT_ALL,\n   MENU_ENUM_LABEL_VALUE_INPUT_SAVE_AUTOCONFIG,\n   MENU_ENUM_LABEL_VALUE_INPUT_MOUSE_INDEX,\n   MENU_ENUM_LABEL_INPUT_JOYPAD_INDEX,\n   MENU_ENUM_LABEL_VALUE_INPUT_DEVICE_RESERVED_DEVICE_NAME,\n   MENU_ENUM_LABEL_VALUE_INPUT_DEVICE_RESERVATION_TYPE,\n   MENU_ENUM_LABEL_VALUE_DEVICE_RESERVATION_NONE,\n   MENU_ENUM_LABEL_VALUE_DEVICE_RESERVATION_PREFERRED,\n   MENU_ENUM_LABEL_VALUE_DEVICE_RESERVATION_RESERVED,\n   MENU_ENUM_LABEL_INPUT_BIND_ALL_INDEX,\n   MENU_ENUM_LABEL_INPUT_SAVE_AUTOCONFIG_INDEX,\n   MENU_ENUM_LABEL_INPUT_BIND_DEFAULTS_INDEX,\n   MENU_ENUM_LABEL_VALUE_INPUT_REMAP_PORT,\n\n   MENU_ENUM_SUBLABEL_INPUT_DEVICE_TYPE,\n   MENU_ENUM_SUBLABEL_INPUT_DEVICE_INDEX,\n   MENU_ENUM_SUBLABEL_INPUT_DEVICE_RESERVED_DEVICE_NAME,\n   MENU_ENUM_SUBLABEL_INPUT_DEVICE_RESERVATION_TYPE,\n   MENU_ENUM_LABEL_HELP_INPUT_DEVICE_RESERVATION_TYPE,\n   MENU_ENUM_SUBLABEL_INPUT_MOUSE_INDEX,\n   MENU_ENUM_SUBLABEL_INPUT_ADC_TYPE,\n   MENU_ENUM_LABEL_HELP_INPUT_ADC_TYPE,\n   MENU_ENUM_SUBLABEL_INPUT_BIND_ALL,\n   MENU_ENUM_SUBLABEL_INPUT_SAVE_AUTOCONFIG,\n   MENU_ENUM_SUBLABEL_INPUT_BIND_DEFAULTS,\n   MENU_ENUM_SUBLABEL_INPUT_REMAP_PORT,\n\n   MENU_ENUM_SUBLABEL_INPUT_META_ENABLE_HOTKEY,\n   MENU_ENUM_SUBLABEL_INPUT_META_MENU_TOGGLE,\n   MENU_ENUM_SUBLABEL_INPUT_META_QUIT_KEY,\n   MENU_ENUM_SUBLABEL_INPUT_META_RESTART_KEY,\n   MENU_ENUM_SUBLABEL_INPUT_META_CLOSE_CONTENT_KEY,\n   MENU_ENUM_SUBLABEL_INPUT_META_RESET,\n\n   MENU_ENUM_SUBLABEL_INPUT_META_FAST_FORWARD_KEY,\n   MENU_ENUM_SUBLABEL_INPUT_META_FAST_FORWARD_HOLD_KEY,\n   MENU_ENUM_SUBLABEL_INPUT_META_SLOWMOTION_KEY,\n   MENU_ENUM_SUBLABEL_INPUT_META_SLOWMOTION_HOLD_KEY,\n   MENU_ENUM_SUBLABEL_INPUT_META_REWIND_HOTKEY,\n   MENU_ENUM_SUBLABEL_INPUT_META_PAUSE_TOGGLE,\n   MENU_ENUM_SUBLABEL_INPUT_META_FRAMEADVANCE,\n\n   MENU_ENUM_SUBLABEL_INPUT_META_MUTE,\n   MENU_ENUM_SUBLABEL_INPUT_META_VOLUME_UP,\n   MENU_ENUM_SUBLABEL_INPUT_META_VOLUME_DOWN,\n\n   MENU_ENUM_SUBLABEL_INPUT_META_LOAD_STATE_KEY,\n   MENU_ENUM_SUBLABEL_INPUT_META_SAVE_STATE_KEY,\n   MENU_ENUM_SUBLABEL_INPUT_META_STATE_SLOT_PLUS,\n   MENU_ENUM_SUBLABEL_INPUT_META_STATE_SLOT_MINUS,\n\n   MENU_ENUM_SUBLABEL_INPUT_META_PLAY_REPLAY_KEY,\n   MENU_ENUM_SUBLABEL_INPUT_META_RECORD_REPLAY_KEY,\n   MENU_ENUM_SUBLABEL_INPUT_META_HALT_REPLAY_KEY,\n   MENU_ENUM_SUBLABEL_INPUT_META_REPLAY_SLOT_PLUS,\n   MENU_ENUM_SUBLABEL_INPUT_META_REPLAY_SLOT_MINUS,\n\n   MENU_ENUM_SUBLABEL_INPUT_META_DISK_EJECT_TOGGLE,\n   MENU_ENUM_SUBLABEL_INPUT_META_DISK_NEXT,\n   MENU_ENUM_SUBLABEL_INPUT_META_DISK_PREV,\n\n   MENU_ENUM_SUBLABEL_INPUT_META_SHADER_TOGGLE,\n   MENU_ENUM_SUBLABEL_INPUT_META_SHADER_NEXT,\n   MENU_ENUM_SUBLABEL_INPUT_META_SHADER_PREV,\n\n   MENU_ENUM_SUBLABEL_INPUT_META_CHEAT_TOGGLE,\n   MENU_ENUM_SUBLABEL_INPUT_META_CHEAT_INDEX_PLUS,\n   MENU_ENUM_SUBLABEL_INPUT_META_CHEAT_INDEX_MINUS,\n\n   MENU_ENUM_SUBLABEL_INPUT_META_SCREENSHOT,\n   MENU_ENUM_SUBLABEL_INPUT_META_RECORDING_TOGGLE,\n   MENU_ENUM_SUBLABEL_INPUT_META_STREAMING_TOGGLE,\n\n   MENU_ENUM_SUBLABEL_INPUT_META_GRAB_MOUSE_TOGGLE,\n   MENU_ENUM_SUBLABEL_INPUT_META_GAME_FOCUS_TOGGLE,\n   MENU_ENUM_SUBLABEL_INPUT_META_FULLSCREEN_TOGGLE_KEY,\n   MENU_ENUM_SUBLABEL_INPUT_META_UI_COMPANION_TOGGLE,\n\n   MENU_ENUM_SUBLABEL_INPUT_META_VRR_RUNLOOP_TOGGLE,\n   MENU_ENUM_SUBLABEL_INPUT_META_RUNAHEAD_TOGGLE,\n   MENU_ENUM_SUBLABEL_INPUT_META_PREEMPT_TOGGLE,\n   MENU_ENUM_SUBLABEL_INPUT_META_FPS_TOGGLE,\n   MENU_ENUM_SUBLABEL_INPUT_META_STATISTICS_TOGGLE,\n   MENU_ENUM_SUBLABEL_INPUT_META_AI_SERVICE,\n\n   MENU_ENUM_SUBLABEL_INPUT_META_NETPLAY_PING_TOGGLE,\n   MENU_ENUM_SUBLABEL_INPUT_META_NETPLAY_HOST_TOGGLE,\n   MENU_ENUM_SUBLABEL_INPUT_META_NETPLAY_GAME_WATCH,\n   MENU_ENUM_SUBLABEL_INPUT_META_NETPLAY_PLAYER_CHAT,\n   MENU_ENUM_SUBLABEL_INPUT_META_NETPLAY_FADE_CHAT_TOGGLE,\n\n   MENU_ENUM_SUBLABEL_INPUT_META_OVERLAY_NEXT, /* Hidden */\n   MENU_ENUM_SUBLABEL_INPUT_META_OSK,\n   MENU_ENUM_SUBLABEL_INPUT_META_SEND_DEBUG_INFO, /* Deprecated */\n\n   MENU_ENUM_LABEL_INPUT_DESCRIPTION,\n   MENU_ENUM_LABEL_INPUT_DESCRIPTION_KBD,\n\n   MENU_LABEL(INPUT_MAX_USERS),\n   MENU_LABEL(INPUT_USER_BINDS),\n   MENU_ENUM_SUBLABEL_INPUT_USER_REMAPS,\n\n   MENU_LABEL(INPUT_DUTY_CYCLE),\n   MENU_LABEL(INPUT_AUTODETECT_ENABLE),\n#if defined(HAVE_DINPUT) || defined(HAVE_WINRAWINPUT)\n   MENU_LABEL(INPUT_NOWINKEY_ENABLE),\n#endif\n\n#ifdef ANDROID\n    MENU_LBL_H(INPUT_SELECT_PHYSICAL_KEYBOARD),\n#endif\n\n   MENU_LABEL(INPUT_SENSORS_ENABLE),\n   MENU_LABEL(INPUT_AUTO_MOUSE_GRAB),\n\n   MENU_LABEL(INPUT_AUTO_GAME_FOCUS),\n   MENU_ENUM_LABEL_VALUE_INPUT_AUTO_GAME_FOCUS_OFF,\n   MENU_ENUM_LABEL_VALUE_INPUT_AUTO_GAME_FOCUS_ON,\n   MENU_ENUM_LABEL_VALUE_INPUT_AUTO_GAME_FOCUS_DETECT,\n\n   MENU_LABEL(INPUT_DESCRIPTOR_LABEL_SHOW),\n   MENU_LABEL(INPUT_DESCRIPTOR_HIDE_UNBOUND),\n   MENU_LABEL(INPUT_BUTTON_AXIS_THRESHOLD),\n#if defined(GEKKO)\n   MENU_LABEL(INPUT_MOUSE_SCALE),\n#endif\n   MENU_LABEL(INPUT_TOUCH_SCALE),\n   MENU_LABEL(INPUT_ANALOG_DEADZONE),\n   MENU_LABEL(INPUT_ANALOG_SENSITIVITY),\n   MENU_LABEL(INPUT_BIND_TIMEOUT),\n   MENU_LABEL(INPUT_BIND_HOLD),\n   MENU_LABEL(INPUT_REMAP_BINDS_ENABLE),\n   MENU_LABEL(INPUT_REMAP_SORT_BY_CONTROLLER_ENABLE),\n   MENU_LABEL(MENU_INPUT_SWAP_OK_CANCEL),\n   MENU_LABEL(MENU_INPUT_SWAP_SCROLL),\n   MENU_LABEL(INPUT_OVERLAY_ENABLE),\n   MENU_LABEL(INPUT_OSK_OVERLAY_ENABLE),\n   MENU_LABEL(INPUT_MENU_ENUM_TOGGLE_GAMEPAD_COMBO),\n   MENU_LABEL(INPUT_QUIT_GAMEPAD_COMBO),\n   MENU_LABEL(INPUT_OVERLAY_BEHIND_MENU),\n   MENU_LABEL(INPUT_OVERLAY_HIDE_IN_MENU),\n   MENU_LABEL(INPUT_OVERLAY_HIDE_WHEN_GAMEPAD_CONNECTED),\n#ifdef UDEV_TOUCH_SUPPORT\n   MENU_LABEL(INPUT_TOUCH_VMOUSE_POINTER),\n   MENU_LABEL(INPUT_TOUCH_VMOUSE_MOUSE),\n   MENU_LABEL(INPUT_TOUCH_VMOUSE_TOUCHPAD),\n   MENU_LABEL(INPUT_TOUCH_VMOUSE_TRACKBALL),\n   MENU_LABEL(INPUT_TOUCH_VMOUSE_GESTURE),\n#endif\n#if defined(ANDROID)\n   MENU_ENUM_SUBLABEL_INPUT_OVERLAY_HIDE_WHEN_GAMEPAD_CONNECTED_ANDROID,\n#endif\n\n   /* Legacy enums - no longer needed, but cannot\n    * delete because they are used by Crowdin\n    * translations... */\n   MENU_LABEL(INPUT_OVERLAY_SHOW_PHYSICAL_INPUTS),\n   MENU_LABEL(INPUT_OVERLAY_SHOW_PHYSICAL_INPUTS_PORT),\n\n   MENU_LABEL(INPUT_OVERLAY_SHOW_INPUTS),\n   MENU_LABEL(INPUT_OVERLAY_SHOW_INPUTS_PORT),\n   MENU_ENUM_LABEL_VALUE_INPUT_OVERLAY_SHOW_INPUTS_NONE,\n   MENU_ENUM_LABEL_VALUE_INPUT_OVERLAY_SHOW_INPUTS_TOUCHED,\n   MENU_ENUM_LABEL_VALUE_INPUT_OVERLAY_SHOW_INPUTS_PHYSICAL,\n\n   MENU_LABEL(INPUT_OVERLAY_SHOW_MOUSE_CURSOR),\n   MENU_LABEL(INPUT_OVERLAY_AUTO_ROTATE),\n   MENU_LABEL(INPUT_OVERLAY_AUTO_SCALE),\n   MENU_LABEL(INPUT_OSK_OVERLAY_AUTO_SCALE),\n   MENU_LABEL(INPUT_OVERLAY_DPAD_DIAGONAL_SENSITIVITY),\n   MENU_LABEL(INPUT_OVERLAY_ABXY_DIAGONAL_SENSITIVITY),\n   MENU_LABEL(INPUT_OVERLAY_ANALOG_RECENTER_ZONE),\n   MENU_LABEL(INPUT_OVERLAY_POINTER_ENABLE),\n   MENU_LABEL(INPUT_OVERLAY_LIGHTGUN_PORT),\n   MENU_LABEL(INPUT_OVERLAY_LIGHTGUN_TRIGGER_ON_TOUCH),\n   MENU_ENUM_LABEL_VALUE_INPUT_OVERLAY_LIGHTGUN_PORT_ANY,\n   MENU_LABEL(INPUT_OVERLAY_LIGHTGUN_TRIGGER_DELAY),\n   MENU_LABEL(INPUT_OVERLAY_LIGHTGUN_ALLOW_OFFSCREEN),\n   MENU_LABEL(INPUT_OVERLAY_LIGHTGUN_TWO_TOUCH_INPUT),\n   MENU_LABEL(INPUT_OVERLAY_LIGHTGUN_THREE_TOUCH_INPUT),\n   MENU_LABEL(INPUT_OVERLAY_LIGHTGUN_FOUR_TOUCH_INPUT),\n   MENU_LABEL(INPUT_OVERLAY_MOUSE_SPEED),\n   MENU_LABEL(INPUT_OVERLAY_MOUSE_HOLD_TO_DRAG),\n   MENU_LABEL(INPUT_OVERLAY_MOUSE_HOLD_MSEC),\n   MENU_LABEL(INPUT_OVERLAY_MOUSE_DTAP_TO_DRAG),\n   MENU_LABEL(INPUT_OVERLAY_MOUSE_DTAP_MSEC),\n   MENU_LABEL(INPUT_OVERLAY_MOUSE_SWIPE_THRESHOLD),\n   MENU_LABEL(INPUT_KEYBOARD_GAMEPAD_MAPPING_TYPE),\n   MENU_LABEL(INPUT_SMALL_KEYBOARD_ENABLE),\n   MENU_LABEL(INPUT_TOUCH_ENABLE),\n   MENU_LBL_H(INPUT_PREFER_FRONT_TOUCH),\n   MENU_LABEL(INPUT_ICADE_ENABLE),\n   MENU_LABEL(INPUT_ALL_USERS_CONTROL_MENU),\n   MENU_LBL_H(INPUT_POLL_TYPE_BEHAVIOR),\n   MENU_LABEL(RUNAHEAD_MODE),\n#if !(defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB))\n   MENU_ENUM_SUBLABEL_RUNAHEAD_MODE_NO_SECOND_INSTANCE,\n#endif\n   MENU_LABEL(INPUT_UNIFIED_MENU_CONTROLS),\n   MENU_LABEL(INPUT_DISABLE_INFO_BUTTON),\n   MENU_LABEL(INPUT_DISABLE_SEARCH_BUTTON),\n   MENU_LABEL(INPUT_DISABLE_LEFT_ANALOG_IN_MENU),\n   MENU_LABEL(INPUT_DISABLE_RIGHT_ANALOG_IN_MENU),\n   MENU_LABEL(INPUT_RUMBLE_GAIN),\n\n   MENU_LABEL(QUIT_PRESS_TWICE),\n   MENU_LABEL(QUIT_ON_CLOSE_CONTENT),\n\n   MENU_LABEL(ANDROID_INPUT_DISCONNECT_WORKAROUND),\n\n   MENU_ENUM_LABEL_VALUE_QUIT_ON_CLOSE_CONTENT_DISABLED,\n   MENU_ENUM_LABEL_VALUE_QUIT_ON_CLOSE_CONTENT_ENABLED,\n   MENU_ENUM_LABEL_VALUE_QUIT_ON_CLOSE_CONTENT_CLI,\n\n   /* Video */\n   MENU_LABEL(BRIGHTNESS_CONTROL),\n   MENU_LABEL(CRT_SWITCH_RESOLUTION),\n   MENU_LABEL(CRT_SWITCH_RESOLUTION_SUPER),\n   MENU_LABEL(CRT_SWITCH_RESOLUTION_OUTPUT_DISPLAY_ID),\n   MENU_LABEL(CRT_SWITCH_HIRES_MENU),\n   MENU_LABEL(CRT_SWITCH_RESOLUTION_USE_CUSTOM_REFRESH_RATE),\n   MENU_LABEL(CRT_SWITCH_X_AXIS_CENTERING),\n   MENU_LABEL(CRT_SWITCH_PORCH_ADJUST),\n   MENU_LABEL(VIDEO_FONT_ENABLE),\n   MENU_LABEL(VIDEO_FONT_PATH),\n   MENU_LABEL(VIDEO_FONT_SIZE),\n   MENU_LABEL(VIDEO_MESSAGE_POS_X),\n   MENU_LABEL(VIDEO_MESSAGE_POS_Y),\n   MENU_LABEL(VIDEO_MESSAGE_COLOR_RED),\n   MENU_LABEL(VIDEO_MESSAGE_COLOR_GREEN),\n   MENU_LABEL(VIDEO_MESSAGE_COLOR_BLUE),\n   MENU_LABEL(VIDEO_MESSAGE_BGCOLOR_ENABLE),\n   MENU_LABEL(VIDEO_MESSAGE_BGCOLOR_RED),\n   MENU_LABEL(VIDEO_MESSAGE_BGCOLOR_GREEN),\n   MENU_LABEL(VIDEO_MESSAGE_BGCOLOR_BLUE),\n   MENU_LABEL(VIDEO_MESSAGE_BGCOLOR_OPACITY),\n   MENU_LABEL(VIDEO_FILTER_FLICKER),\n   MENU_LABEL(VIDEO_SOFT_FILTER),\n   MENU_LBL_H(VIDEO_MAX_SWAPCHAIN_IMAGES),\n   MENU_LABEL(VIDEO_WAITABLE_SWAPCHAINS),\n   MENU_LABEL(VIDEO_MAX_FRAME_LATENCY),\n   MENU_LABEL(VIDEO_GPU_SCREENSHOT),\n   MENU_LBL_H(VIDEO_BLACK_FRAME_INSERTION),\n   MENU_LBL_H(VIDEO_BFI_DARK_FRAMES),\n   MENU_LBL_H(VIDEO_SHADER_SUBFRAMES),\n   MENU_LBL_H(VIDEO_SCAN_SUBFRAMES),\n   MENU_LBL_H(VIDEO_FRAME_DELAY),\n   MENU_LBL_H(VIDEO_FRAME_DELAY_AUTO),\n   MENU_ENUM_LABEL_VALUE_VIDEO_FRAME_DELAY_AUTOMATIC,\n   MENU_ENUM_LABEL_VALUE_VIDEO_FRAME_DELAY_EFFECTIVE,\n   MENU_LABEL(VIDEO_SHADER_DELAY),\n   MENU_LABEL(VIDEO_VSYNC),\n   MENU_LABEL(VIDEO_ADAPTIVE_VSYNC),\n   MENU_LABEL(VIDEO_HARD_SYNC),\n   MENU_LBL_H(VIDEO_HARD_SYNC_FRAMES),\n   MENU_LABEL(VIDEO_WINDOWED_FULLSCREEN),\n   MENU_LABEL(VIDEO_AUTOSWITCH_REFRESH_RATE),\n   MENU_LABEL(VIDEO_AUTOSWITCH_PAL_THRESHOLD),\n\n   MENU_ENUM_LABEL_VALUE_VIDEO_AUTOSWITCH_REFRESH_RATE_EXCLUSIVE_FULLSCREEN,\n   MENU_ENUM_LABEL_VALUE_VIDEO_AUTOSWITCH_REFRESH_RATE_WINDOWED_FULLSCREEN,\n   MENU_ENUM_LABEL_VALUE_VIDEO_AUTOSWITCH_REFRESH_RATE_ALL_FULLSCREEN,\n\n   MENU_LABEL(VIDEO_WINDOW_WIDTH),\n   MENU_LABEL(VIDEO_WINDOW_HEIGHT),\n   MENU_LABEL(VIDEO_WINDOW_AUTO_WIDTH_MAX),\n   MENU_LABEL(VIDEO_WINDOW_AUTO_HEIGHT_MAX),\n   MENU_LABEL(VIDEO_WINDOW_OPACITY),\n   MENU_LABEL(VIDEO_FULLSCREEN_X),\n   MENU_LABEL(VIDEO_FULLSCREEN_Y),\n   MENU_LABEL(VIDEO_FORCE_RESOLUTION),\n   MENU_LABEL(VIDEO_FORCE_SRGB_DISABLE),\n   MENU_LABEL(VIDEO_ROTATION),\n   MENU_LABEL(SCREEN_ORIENTATION),\n   MENU_LABEL(VIDEO_SCALE),\n   MENU_LABEL(VIDEO_RECORD_THREADS),\n   MENU_LABEL(VIDEO_SMOOTH),\n   MENU_LABEL(VIDEO_CTX_SCALING),\n#ifdef HAVE_ODROIDGO2\n   MENU_LABEL(VIDEO_RGA_SCALING),\n#endif\n\n   MENU_LABEL(VIDEO_CROP_OVERSCAN),\n\n   MENU_LABEL(VIDEO_NOTCH_WRITE_OVER),\n\n   MENU_LABEL(VIDEO_SCALE_INTEGER),\n   MENU_LABEL(VIDEO_SCALE_INTEGER_AXIS),\n   MENU_LABEL(VIDEO_SCALE_INTEGER_SCALING),\n   MENU_ENUM_LABEL_VALUE_VIDEO_SCALE_INTEGER_SCALING_UNDERSCALE,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SCALE_INTEGER_SCALING_OVERSCALE,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SCALE_INTEGER_SCALING_SMART,\n   MENU_LABEL(VIDEO_VIEWPORT_CUSTOM_X),\n   MENU_LABEL(VIDEO_VIEWPORT_CUSTOM_Y),\n   MENU_LABEL(VIDEO_VIEWPORT_CUSTOM_WIDTH),\n   MENU_LABEL(VIDEO_VIEWPORT_CUSTOM_HEIGHT),\n   MENU_LABEL(VIDEO_GAMMA),\n\n   MENU_LABEL(VIDEO_ALLOW_ROTATE),\n   MENU_ENUM_LABEL_VALUE_VIDEO_ROTATION_NORMAL,\n   MENU_ENUM_LABEL_VALUE_VIDEO_ROTATION_90_DEG,\n   MENU_ENUM_LABEL_VALUE_VIDEO_ROTATION_180_DEG,\n   MENU_ENUM_LABEL_VALUE_VIDEO_ROTATION_270_DEG,\n   MENU_ENUM_LABEL_VALUE_VIDEO_ORIENTATION_NORMAL,\n   MENU_ENUM_LABEL_VALUE_VIDEO_ORIENTATION_VERTICAL,\n   MENU_ENUM_LABEL_VALUE_VIDEO_ORIENTATION_FLIPPED,\n   MENU_ENUM_LABEL_VALUE_VIDEO_ORIENTATION_FLIPPED_ROTATED,\n\n   MENU_LABEL(VIDEO_SHARED_CONTEXT),\n   MENU_LABEL(DRIVER_SWITCH_ENABLE),\n   MENU_LBL_H(VIDEO_THREADED),\n\n   MENU_LABEL(VIDEO_SWAP_INTERVAL),\n   MENU_ENUM_LABEL_VALUE_VIDEO_SWAP_INTERVAL_AUTO,\n\n   MENU_ENUM_LABEL_VALUE_VIDEO_BLACK_FRAME_INSERTION_VALUE_120,\n   MENU_ENUM_LABEL_VALUE_VIDEO_BLACK_FRAME_INSERTION_VALUE_180,\n   MENU_ENUM_LABEL_VALUE_VIDEO_BLACK_FRAME_INSERTION_VALUE_240,\n   MENU_ENUM_LABEL_VALUE_VIDEO_BLACK_FRAME_INSERTION_VALUE_300,\n   MENU_ENUM_LABEL_VALUE_VIDEO_BLACK_FRAME_INSERTION_VALUE_360,\n   MENU_ENUM_LABEL_VALUE_VIDEO_BLACK_FRAME_INSERTION_VALUE_420,\n   MENU_ENUM_LABEL_VALUE_VIDEO_BLACK_FRAME_INSERTION_VALUE_480,\n   MENU_ENUM_LABEL_VALUE_VIDEO_BLACK_FRAME_INSERTION_VALUE_540,\n   MENU_ENUM_LABEL_VALUE_VIDEO_BLACK_FRAME_INSERTION_VALUE_600,\n   MENU_ENUM_LABEL_VALUE_VIDEO_BLACK_FRAME_INSERTION_VALUE_660,\n   MENU_ENUM_LABEL_VALUE_VIDEO_BLACK_FRAME_INSERTION_VALUE_720,\n   MENU_ENUM_LABEL_VALUE_VIDEO_BLACK_FRAME_INSERTION_VALUE_780,\n   MENU_ENUM_LABEL_VALUE_VIDEO_BLACK_FRAME_INSERTION_VALUE_840,\n   MENU_ENUM_LABEL_VALUE_VIDEO_BLACK_FRAME_INSERTION_VALUE_900,\n   MENU_ENUM_LABEL_VALUE_VIDEO_BLACK_FRAME_INSERTION_VALUE_960,\n\n   MENU_ENUM_LABEL_VALUE_VIDEO_SHADER_SUBFRAMES_VALUE_120,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SHADER_SUBFRAMES_VALUE_180,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SHADER_SUBFRAMES_VALUE_240,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SHADER_SUBFRAMES_VALUE_300,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SHADER_SUBFRAMES_VALUE_360,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SHADER_SUBFRAMES_VALUE_420,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SHADER_SUBFRAMES_VALUE_480,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SHADER_SUBFRAMES_VALUE_540,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SHADER_SUBFRAMES_VALUE_600,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SHADER_SUBFRAMES_VALUE_660,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SHADER_SUBFRAMES_VALUE_720,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SHADER_SUBFRAMES_VALUE_780,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SHADER_SUBFRAMES_VALUE_840,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SHADER_SUBFRAMES_VALUE_900,\n   MENU_ENUM_LABEL_VALUE_VIDEO_SHADER_SUBFRAMES_VALUE_960,\n\n   MENU_LABEL(VIDEO_FULLSCREEN),\n   MENU_LBL_H(VIDEO_MONITOR_INDEX),\n   MENU_LABEL(VIDEO_WIIU_PREFER_DRC),\n   MENU_LABEL(VIDEO_WINDOW_SCALE),\n   MENU_LABEL(VIDEO_WINDOW_OFFSET_X),\n   MENU_LABEL(VIDEO_WINDOW_OFFSET_Y),\n   MENU_LABEL(VIDEO_REFRESH_RATE),\n   MENU_LBL_H(VIDEO_REFRESH_RATE_AUTO),\n   MENU_LABEL(VIDEO_REFRESH_RATE_POLLED),\n\n   MENU_LABEL(VIDEO_HDR_ENABLE),\n   MENU_LABEL(VIDEO_HDR_MAX_NITS),\n   MENU_LABEL(VIDEO_HDR_PAPER_WHITE_NITS),\n   MENU_LABEL(VIDEO_HDR_CONTRAST),\n   MENU_LABEL(VIDEO_HDR_EXPAND_GAMUT),\n\n   MENU_LABEL(VIDEO_LAYOUT_ENABLE),\n   MENU_LABEL(VIDEO_LAYOUT_PATH),\n   MENU_LABEL(VIDEO_LAYOUT_SELECTED_VIEW),\n\n   MENU_LBL_H(PARENT_DIRECTORY),\n\n   MENU_LBL_H(FILE_BROWSER_OPEN_UWP_PERMISSIONS),\n   MENU_LABEL(FILE_BROWSER_OPEN_PICKER),\n\n   MENU_ENUM_LABEL_CONTENT_ACTIONS,\n\n   /* Menu settings */\n   MENU_LABEL(MENU_SHOW_LOAD_CORE),\n   MENU_LABEL(MENU_SHOW_LOAD_CONTENT),\n   MENU_LABEL(MENU_SHOW_LOAD_DISC),\n   MENU_LABEL(MENU_SHOW_DUMP_DISC),\n#ifdef HAVE_LAKKA\n   MENU_LABEL(MENU_SHOW_EJECT_DISC),\n#endif\n   MENU_LABEL(MENU_SHOW_INFORMATION),\n   MENU_LABEL(MENU_SHOW_CONFIGURATIONS),\n   MENU_LABEL(MENU_SHOW_HELP),\n   MENU_LABEL(MENU_SHOW_QUIT_RETROARCH),\n   MENU_ENUM_SUBLABEL_QUIT_RETROARCH_NOSAVE,\n   MENU_LABEL(MENU_SHOW_RESTART_RETROARCH),\n   MENU_LABEL(MENU_SHOW_REBOOT),\n   MENU_LABEL(MENU_SHOW_SHUTDOWN),\n   MENU_LABEL(MENU_SHOW_ONLINE_UPDATER),\n   MENU_LABEL(MENU_SHOW_CORE_UPDATER),\n   MENU_LABEL(MENU_SHOW_LEGACY_THUMBNAIL_UPDATER), /* Thumbnailpack removal - deprecated*/\n   MENU_LABEL(MENU_SCROLL_FAST),\n   MENU_LABEL(MENU_SCROLL_DELAY),\n   MENU_LABEL(MENU_ENABLE_KIOSK_MODE),\n   MENU_LABEL(MENU_DISABLE_KIOSK_MODE),\n   MENU_LABEL(MENU_KIOSK_MODE_PASSWORD),\n   MENU_LABEL(RUN_MUSIC),\n   MENU_LABEL(RUN),\n   MENU_LABEL(MENU_WALLPAPER),\n   MENU_LABEL(DYNAMIC_WALLPAPER),\n   MENU_LABEL(PAUSE_NONACTIVE),\n   MENU_LABEL(PAUSE_ON_DISCONNECT),\n   MENU_LABEL(MENU_SCREENSAVER_TIMEOUT),\n   MENU_LABEL(MENU_SCREENSAVER_ANIMATION),\n   MENU_LABEL(MENU_SCREENSAVER_ANIMATION_SPEED),\n\n   MENU_ENUM_LABEL_VALUE_MENU_SCREENSAVER_ANIMATION_SNOW,\n   MENU_ENUM_LABEL_VALUE_MENU_SCREENSAVER_ANIMATION_STARFIELD,\n   MENU_ENUM_LABEL_VALUE_MENU_SCREENSAVER_ANIMATION_VORTEX,\n\n   MENU_LABEL(MOUSE_ENABLE),\n   MENU_LABEL(POINTER_ENABLE),\n   MENU_LABEL(MENU_RGUI_BORDER_FILLER_ENABLE),\n   MENU_LABEL(MENU_RGUI_BACKGROUND_FILLER_THICKNESS_ENABLE),\n   MENU_LABEL(MENU_RGUI_BORDER_FILLER_THICKNESS_ENABLE),\n   MENU_LABEL(MENU_RGUI_INTERNAL_UPSCALE_LEVEL),\n   MENU_LABEL(MENU_RGUI_ASPECT_RATIO),\n   MENU_LABEL(MENU_RGUI_ASPECT_RATIO_LOCK),\n   MENU_LABEL(MENU_RGUI_FULL_WIDTH_LAYOUT),\n   MENU_LABEL(MENU_RGUI_TRANSPARENCY),\n   MENU_LABEL(MENU_RGUI_SHADOWS),\n   MENU_LABEL(MENU_RGUI_PARTICLE_EFFECT),\n   MENU_LABEL(MENU_RGUI_PARTICLE_EFFECT_SPEED),\n   MENU_LABEL(MENU_RGUI_PARTICLE_EFFECT_SCREENSAVER),\n   MENU_LABEL(MENU_RGUI_EXTENDED_ASCII),\n   MENU_LABEL(MENU_RGUI_SWITCH_ICONS),\n   MENU_LABEL(MENU_LINEAR_FILTER),\n   MENU_LABEL(MENU_HORIZONTAL_ANIMATION),\n   MENU_LABEL(NAVIGATION_WRAPAROUND),\n   MENU_LABEL(SHOW_ADVANCED_SETTINGS),\n   MENU_LABEL(THREADED_DATA_RUNLOOP_ENABLE),\n   MENU_LABEL(XMB_ALPHA_FACTOR),\n   MENU_LABEL(MENU_FONT_COLOR_RED),\n   MENU_LABEL(MENU_FONT_COLOR_GREEN),\n   MENU_LABEL(MENU_FONT_COLOR_BLUE),\n   MENU_LABEL(XMB_FONT),\n   MENU_LABEL(XMB_LAYOUT),\n   MENU_LABEL(XMB_THEME),\n   MENU_LABEL(XMB_SWITCH_ICONS),\n   MENU_LABEL(XMB_MAIN_MENU_ENABLE_SETTINGS),\n   MENU_LABEL(XMB_SHADOWS_ENABLE),\n   MENU_LABEL(CONTENT_SHOW_REWIND),\n   MENU_LABEL(CONTENT_SHOW_LATENCY),\n   MENU_LABEL(CONTENT_SHOW_OVERLAYS),\n   MENU_LABEL(CONTENT_SHOW_VIDEO_LAYOUT),\n   MENU_LABEL(CONTENT_SHOW_SETTINGS),\n   MENU_LABEL(CONTENT_SHOW_SETTINGS_PASSWORD),\n   MENU_LABEL(CONTENT_SHOW_FAVORITES),\n   MENU_LABEL(CONTENT_SHOW_IMAGES),\n   MENU_LABEL(CONTENT_SHOW_MUSIC),\n   MENU_LABEL(CONTENT_SHOW_VIDEO),\n   MENU_LABEL(CONTENT_SHOW_NETPLAY),\n   MENU_LABEL(CONTENT_SHOW_HISTORY),\n   MENU_LABEL(CONTENT_SHOW_ADD),\n   MENU_LABEL(CONTENT_SHOW_ADD_ENTRY),\n   MENU_LABEL(CONTENT_SHOW_PLAYLISTS),\n   MENU_LABEL(CONTENT_SHOW_EXPLORE),\n   MENU_LABEL(CONTENT_SHOW_CONTENTLESS_CORES),\n   MENU_ENUM_LABEL_VALUE_SHOW_CONTENTLESS_CORES_ALL,\n   MENU_ENUM_LABEL_VALUE_SHOW_CONTENTLESS_CORES_SINGLE_PURPOSE,\n   MENU_ENUM_LABEL_VALUE_SHOW_CONTENTLESS_CORES_CUSTOM,\n   MENU_LABEL(XMB_RIBBON_ENABLE),\n   MENU_LABEL(THUMBNAILS),\n   MENU_LABEL(THUMBNAILS_RGUI),\n   MENU_LABEL(THUMBNAILS_MATERIALUI),\n   MENU_LABEL(LEFT_THUMBNAILS),\n   MENU_LABEL(LEFT_THUMBNAILS_RGUI),\n   MENU_LABEL(LEFT_THUMBNAILS_OZONE),\n   MENU_LABEL(LEFT_THUMBNAILS_MATERIALUI),\n   MENU_LABEL(ICON_THUMBNAILS),\n   MENU_LABEL(XMB_VERTICAL_THUMBNAILS),\n   MENU_LABEL(MENU_XMB_THUMBNAIL_SCALE_FACTOR),\n   MENU_LABEL(MENU_XMB_VERTICAL_FADE_FACTOR),\n   MENU_LABEL(MENU_XMB_SHOW_TITLE_HEADER),\n   MENU_LABEL(MENU_XMB_TITLE_MARGIN),\n   MENU_LABEL(MENU_XMB_TITLE_MARGIN_HORIZONTAL_OFFSET),\n   MENU_LABEL(MENU_THUMBNAIL_UPSCALE_THRESHOLD),\n   MENU_LABEL(MENU_RGUI_INLINE_THUMBNAILS),\n   MENU_LABEL(MENU_RGUI_SWAP_THUMBNAILS),\n   MENU_LABEL(MENU_RGUI_THUMBNAIL_DOWNSCALER),\n   MENU_LABEL(MENU_RGUI_THUMBNAIL_DELAY),\n   MENU_LABEL(TIMEDATE_ENABLE),\n   MENU_LABEL(TIMEDATE_STYLE),\n   MENU_LABEL(TIMEDATE_DATE_SEPARATOR),\n   MENU_LABEL(BATTERY_LEVEL_ENABLE),\n   MENU_LABEL(MENU_SHOW_SUBLABELS),\n   MENU_LABEL(RGUI_MENU_COLOR_THEME),\n   MENU_LABEL(RGUI_MENU_THEME_PRESET),\n   MENU_LABEL(XMB_MENU_COLOR_THEME),\n   MENU_LABEL(OZONE_MENU_COLOR_THEME),\n   MENU_LABEL(OZONE_COLLAPSE_SIDEBAR),\n   MENU_LABEL(OZONE_TRUNCATE_PLAYLIST_NAME),\n   MENU_LABEL(OZONE_SORT_AFTER_TRUNCATE_PLAYLIST_NAME),\n   MENU_LABEL(OZONE_SCROLL_CONTENT_METADATA),\n   MENU_LABEL(OZONE_THUMBNAIL_SCALE_FACTOR),\n   MENU_LABEL(MATERIALUI_MENU_COLOR_THEME),\n   MENU_LABEL(QUICK_MENU_OVERRIDE_OPTIONS),\n   MENU_LABEL(SETTINGS_SHOW_DRIVERS),\n   MENU_LABEL(SETTINGS_SHOW_VIDEO),\n   MENU_LABEL(SETTINGS_SHOW_AUDIO),\n   MENU_LABEL(SETTINGS_SHOW_INPUT),\n   MENU_LABEL(SETTINGS_SHOW_LATENCY),\n   MENU_LABEL(SETTINGS_SHOW_CORE),\n   MENU_LABEL(SETTINGS_SHOW_CONFIGURATION),\n   MENU_LABEL(SETTINGS_SHOW_SAVING),\n   MENU_LABEL(SETTINGS_SHOW_LOGGING),\n   MENU_LABEL(SETTINGS_SHOW_FILE_BROWSER),\n   MENU_LABEL(SETTINGS_SHOW_FRAME_THROTTLE),\n   MENU_LABEL(SETTINGS_SHOW_RECORDING),\n   MENU_LABEL(SETTINGS_SHOW_ONSCREEN_DISPLAY),\n   MENU_LABEL(SETTINGS_SHOW_USER_INTERFACE),\n   MENU_LABEL(SETTINGS_SHOW_AI_SERVICE),\n   MENU_LABEL(SETTINGS_SHOW_ACCESSIBILITY),\n   MENU_LABEL(SETTINGS_SHOW_POWER_MANAGEMENT),\n   MENU_LABEL(SETTINGS_SHOW_ACHIEVEMENTS),\n   MENU_LABEL(SETTINGS_SHOW_NETWORK),\n   MENU_LABEL(SETTINGS_SHOW_PLAYLISTS),\n   MENU_LABEL(SETTINGS_SHOW_USER),\n   MENU_LABEL(SETTINGS_SHOW_DIRECTORY),\n   MENU_LABEL(SETTINGS_SHOW_STEAM),\n   MENU_LABEL(QUICK_MENU_SHOW_RESUME_CONTENT),\n   MENU_LABEL(QUICK_MENU_SHOW_RESTART_CONTENT),\n   MENU_LABEL(QUICK_MENU_SHOW_CLOSE_CONTENT),\n   MENU_LABEL(QUICK_MENU_SHOW_TAKE_SCREENSHOT),\n   MENU_LABEL(QUICK_MENU_SHOW_SAVESTATE_SUBMENU),\n   MENU_LABEL(QUICK_MENU_SHOW_SAVE_LOAD_STATE),\n   MENU_LABEL(QUICK_MENU_SHOW_UNDO_SAVE_LOAD_STATE),\n   MENU_LABEL(QUICK_MENU_SHOW_REPLAY),\n   MENU_LABEL(QUICK_MENU_SHOW_ADD_TO_FAVORITES),\n   MENU_LABEL(QUICK_MENU_SHOW_ADD_TO_PLAYLIST),\n   MENU_LABEL(QUICK_MENU_SHOW_START_RECORDING),\n   MENU_LABEL(QUICK_MENU_SHOW_START_STREAMING),\n   MENU_LABEL(QUICK_MENU_SHOW_SET_CORE_ASSOCIATION),\n   MENU_LABEL(QUICK_MENU_SHOW_RESET_CORE_ASSOCIATION),\n   MENU_LABEL(QUICK_MENU_SHOW_OPTIONS),\n   MENU_LABEL(QUICK_MENU_SHOW_CORE_OPTIONS_FLUSH),\n   MENU_LABEL(QUICK_MENU_SHOW_CONTROLS),\n   MENU_LABEL(QUICK_MENU_SHOW_CHEATS),\n   MENU_LABEL(QUICK_MENU_SHOW_SHADERS),\n   MENU_LABEL(QUICK_MENU_SHOW_SAVE_CORE_OVERRIDES),\n   MENU_LABEL(QUICK_MENU_SHOW_SAVE_CONTENT_DIR_OVERRIDES),\n   MENU_LABEL(QUICK_MENU_SHOW_SAVE_GAME_OVERRIDES),\n   MENU_LABEL(QUICK_MENU_SHOW_INFORMATION),\n   MENU_LABEL(QUICK_MENU_START_RECORDING),\n   MENU_LABEL(QUICK_MENU_STOP_RECORDING),\n   MENU_LABEL(QUICK_MENU_START_STREAMING),\n   MENU_LABEL(QUICK_MENU_STOP_STREAMING),\n   MENU_LABEL(QUICK_MENU_SHOW_DOWNLOAD_THUMBNAILS),\n   MENU_LABEL(MENU_TICKER_TYPE),\n   MENU_LABEL(MENU_TICKER_SPEED),\n   MENU_LABEL(MENU_TICKER_SMOOTH),\n\n   MENU_ENUM_LABEL_VALUE_MENU_TICKER_TYPE_BOUNCE,\n   MENU_ENUM_LABEL_VALUE_MENU_TICKER_TYPE_LOOP,\n\n   MENU_ENUM_LABEL_VALUE_SCROLL_NORMAL,\n   MENU_ENUM_LABEL_VALUE_SCROLL_FAST,\n\n   MENU_ENUM_LABEL_VALUE_MENU_ADD_CONTENT_ENTRY_DISPLAY_MAIN_TAB,\n   MENU_ENUM_LABEL_VALUE_MENU_ADD_CONTENT_ENTRY_DISPLAY_PLAYLISTS_TAB,\n\n   MENU_LABEL(MENU_REMEMBER_SELECTION),\n\n   MENU_ENUM_LABEL_VALUE_MENU_REMEMBER_SELECTION_ALWAYS,\n   MENU_ENUM_LABEL_VALUE_MENU_REMEMBER_SELECTION_PLAYLISTS,\n   MENU_ENUM_LABEL_VALUE_MENU_REMEMBER_SELECTION_MAIN,\n\n   /* UI settings */\n   MENU_LBL_H(VIDEO_DISABLE_COMPOSITION),\n   MENU_LABEL(UI_COMPANION_ENABLE),\n   MENU_LBL_H(UI_COMPANION_START_ON_BOOT),\n   MENU_LABEL(UI_COMPANION_TOGGLE),\n   MENU_LABEL(DESKTOP_MENU_ENABLE),\n   MENU_LABEL(UI_MENUBAR_ENABLE),\n#ifdef _3DS\n   MENU_LABEL(NEW3DS_SPEEDUP_ENABLE),\n   MENU_LABEL(VIDEO_3DS_LCD_BOTTOM),\n   MENU_LABEL(VIDEO_3DS_DISPLAY_MODE),\n   MENU_ENUM_LABEL_VALUE_CTR_VIDEO_MODE_3D,\n   MENU_ENUM_LABEL_VALUE_CTR_VIDEO_MODE_2D,\n   MENU_ENUM_LABEL_VALUE_CTR_VIDEO_MODE_2D_400X240,\n   MENU_ENUM_LABEL_VALUE_CTR_VIDEO_MODE_2D_800X240,\n   MENU_LABEL(BOTTOM_ASSETS_DIRECTORY),\n   MENU_LABEL(BOTTOM_FONT_ENABLE),\n   MENU_LABEL(BOTTOM_FONT_COLOR_RED),\n   MENU_LABEL(BOTTOM_FONT_COLOR_GREEN),\n   MENU_LABEL(BOTTOM_FONT_COLOR_BLUE),\n   MENU_LABEL(BOTTOM_FONT_COLOR_OPACITY),\n   MENU_LABEL(BOTTOM_FONT_SCALE),\n#endif\n   MENU_ENUM_LABEL_FILE_CONFIG,\n   MENU_ENUM_LABEL_HELP_FILE_CONFIG,\n   MENU_ENUM_LABEL_FILE_BROWSER_COMPRESSED_ARCHIVE,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_COMPRESSED_ARCHIVE,\n   MENU_ENUM_LABEL_FILE_BROWSER_CONFIG,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_CONFIG,\n   MENU_ENUM_LABEL_FILE_BROWSER_RECORD_CONFIG,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_RECORD_CONFIG,\n   MENU_ENUM_LABEL_FILE_BROWSER_CURSOR,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_CURSOR,\n   MENU_ENUM_LABEL_FILE_BROWSER_DIRECTORY,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_DIRECTORY,\n   MENU_ENUM_LABEL_FILE_BROWSER_PLAIN_FILE,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_PLAIN_FILE,\n   MENU_ENUM_LABEL_FILE_BROWSER_SHADER_PRESET,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_SHADER_PRESET,\n   MENU_ENUM_LABEL_FILE_BROWSER_SHADER,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_SHADER,\n   MENU_ENUM_LABEL_FILE_BROWSER_REMAP,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_REMAP,\n   MENU_ENUM_LABEL_FILE_BROWSER_CORE,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_CORE,\n   MENU_ENUM_LABEL_FILE_BROWSER_OVERLAY,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_OVERLAY,\n   MENU_ENUM_LABEL_FILE_BROWSER_VIDEO_LAYOUT,\n   MENU_ENUM_LABEL_FILE_BROWSER_CHEAT,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_CHEAT,\n   MENU_ENUM_LABEL_FILE_BROWSER_FONT,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_FONT,\n   MENU_ENUM_LABEL_FILE_BROWSER_RDB,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_RDB,\n   MENU_ENUM_LABEL_FILE_BROWSER_CORE_SELECT_FROM_COLLECTION,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_CORE_SELECT_FROM_COLLECTION,\n   MENU_ENUM_LABEL_FILE_BROWSER_CORE_SELECT_FROM_COLLECTION_CURRENT_CORE,\n   MENU_ENUM_LABEL_FILE_BROWSER_CORE_DETECTED,\n   MENU_ENUM_LABEL_FILE_BROWSER_IMAGE,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_IMAGE,\n   MENU_ENUM_LABEL_FILE_BROWSER_IMAGE_OPEN_WITH_VIEWER,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_IMAGE_OPEN_WITH_VIEWER,\n   MENU_ENUM_LABEL_FILE_BROWSER_MOVIE_OPEN,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_MOVIE_OPEN,\n   MENU_ENUM_LABEL_FILE_BROWSER_MUSIC_OPEN,\n   MENU_ENUM_LABEL_HELP_FILE_BROWSER_MUSIC_OPEN,\n\n   /* Menu file browser */\n   MENU_LABEL(NAVIGATION_BROWSER_FILTER_SUPPORTED_EXTENSIONS_ENABLE),\n\n   /* Playlists */\n   MENU_LABEL(HISTORY_LIST_ENABLE),\n   MENU_LABEL(CONTENT_HISTORY_SIZE),\n   MENU_LABEL(CONTENT_FAVORITES_SIZE),\n   MENU_LABEL(PLAYLIST_ENTRY_REMOVE),\n   MENU_LABEL(PLAYLIST_ENTRY_RENAME),\n   MENU_LABEL(GOTO_FAVORITES),\n   MENU_LABEL(GOTO_MUSIC),\n   MENU_LABEL(GOTO_IMAGES),\n   MENU_LABEL(GOTO_VIDEO),\n   MENU_LABEL(GOTO_EXPLORE),\n   MENU_LABEL(GOTO_CONTENTLESS_CORES),\n   MENU_LABEL(ADD_TO_FAVORITES),\n   MENU_LABEL(ADD_TO_FAVORITES_PLAYLIST),\n   MENU_LABEL(SET_CORE_ASSOCIATION),\n   MENU_LABEL(RESET_CORE_ASSOCIATION),\n\n   MENU_LABEL(NO_ACHIEVEMENTS_TO_DISPLAY),\n   MENU_LABEL(NOT_LOGGED_IN),\n   MENU_LABEL(NETWORK_ERROR),\n   MENU_LABEL(UNKNOWN_GAME),\n   MENU_LABEL(CANNOT_ACTIVATE_ACHIEVEMENTS_WITH_THIS_CORE),\n   MENU_LABEL(NO_ENTRIES_TO_DISPLAY),\n   MENU_LABEL(DOWNLOAD_PL_ENTRY_THUMBNAILS),\n\n   /* Help */\n\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_CONTROLS,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_CONTROLS_SCROLL_UP,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_CONTROLS_SCROLL_DOWN,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_CONTROLS_CONFIRM,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_CONTROLS_OK,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_CONTROLS_BACK,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_CONTROLS_START,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_CONTROLS_INFO,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_CONTROLS_TOGGLE_MENU,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_CONTROLS_QUIT,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_CONTROLS_TOGGLE_KEYBOARD,\n\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_ENUM_CONTROLS,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_ENUM_CONTROLS_SCROLL_UP,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_ENUM_CONTROLS_CONFIRM,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_ENUM_CONTROLS_START,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_ENUM_CONTROLS_INFO,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_ENUM_CONTROLS_TOGGLE_MENU,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_ENUM_CONTROLS_QUIT,\n   MENU_ENUM_LABEL_VALUE_BASIC_MENU_ENUM_CONTROLS_TOGGLE_KEYBOARD,\n\n   MENU_LABEL(MENU_VIEWS_SETTINGS),\n   MENU_LABEL(QUICK_MENU_VIEWS_SETTINGS),\n   MENU_LABEL(SETTINGS_VIEWS_SETTINGS),\n   MENU_LABEL(MENU_SETTINGS),\n   MENU_LABEL(APPICON_SETTINGS),\n#ifdef _3DS\n   MENU_LABEL(MENU_BOTTOM_SETTINGS),\n#endif\n   MENU_LABEL(THUMBNAILS_UPDATER_LIST), /* Thumbnailpack removal - deprecated*/\n   MENU_LABEL(PL_THUMBNAILS_UPDATER_LIST),\n   MENU_LABEL(PL_THUMBNAILS_UPDATER_ENTRY),\n   MENU_LABEL(USER_INTERFACE_SETTINGS),\n   MENU_LABEL(POWER_MANAGEMENT_SETTINGS),\n   MENU_LABEL(RETRO_ACHIEVEMENTS_SETTINGS),\n   MENU_LABEL(MENU_FILE_BROWSER_SETTINGS),\n   MENU_LABEL(UPDATER_SETTINGS),\n   MENU_LABEL(BLUETOOTH_SETTINGS),\n   MENU_LABEL(WIFI_SETTINGS),\n   MENU_LABEL(WIFI_NETWORKS),\n   MENU_LABEL(USER_SETTINGS),\n   MENU_LABEL(DIRECTORY_SETTINGS),\n   MENU_LABEL(PRIVACY_SETTINGS),\n   MENU_LABEL(MIDI_SETTINGS),\n   MENU_LABEL(SUBSYSTEM_SETTINGS),\n   MENU_ENUM_LABEL_VALUE_SUBSYSTEM_CONTENT_INFO,\n   MENU_LABEL(NETWORK_HOSTING_SETTINGS),\n   MENU_LABEL(NETWORK_SETTINGS),\n   MENU_LABEL(NETPLAY_LOBBY_FILTERS),\n   MENU_LABEL(NETPLAY_LAN_SCAN_SETTINGS),\n   MENU_LABEL(WIFI_ENABLED),\n   MENU_LABEL(WIFI_NETWORK_SCAN),\n   MENU_LABEL(WIFI_DISCONNECT),\n\n   MENU_ENUM_LABEL_CONNECT_BLUETOOTH,\n   MENU_ENUM_LABEL_CONNECT_WIFI,\n   MENU_ENUM_LABEL_CONNECT_NETPLAY_ROOM,\n   MENU_ENUM_LABEL_CONNECT_NETPLAY_LAN,\n\n   MENU_LABEL(MENU_ENUM_LINEAR_FILTER),\n   MENU_LABEL(MENU_THROTTLE_FRAMERATE),\n   MENU_LABEL(MENU_ENUM_THROTTLE_FRAMERATE),\n   MENU_LABEL(STATE_SLOT),\n\n   MENU_ENUM_LABEL_PLAYLIST_SETTINGS_BEGIN,\n\n   MENU_ENUM_LABEL_VALUE_CHEEVOS_SETTINGS,\n\n   MENU_LABEL(CHEEVOS_USERNAME),\n   MENU_LABEL(CHEEVOS_PASSWORD),\n\n   MENU_ENUM_LABEL_VALUE_ACCOUNTS_CHEEVOS_SETTINGS,\n   MENU_ENUM_LABEL_VALUE_ACCOUNTS_CHEEVOS_PASSWORD,\n\n   MENU_LABEL(ACCOUNTS_CHEEVOS_USERNAME),\n   MENU_LABEL(CHEEVOS_HARDCORE_MODE_ENABLE),\n   MENU_LABEL(CHEEVOS_LEADERBOARDS_ENABLE),\n   MENU_LABEL(CHEEVOS_RICHPRESENCE_ENABLE),\n   MENU_LABEL(CHEEVOS_BADGES_ENABLE),\n   MENU_LABEL(CHEEVOS_TEST_UNOFFICIAL),\n   MENU_LABEL(CHEEVOS_VERBOSE_ENABLE),\n   MENU_LABEL(CHEEVOS_UNLOCK_SOUND_ENABLE),\n   MENU_LABEL(CHEEVOS_AUTO_SCREENSHOT),\n   MENU_LABEL(CHEEVOS_START_ACTIVE),\n   MENU_LABEL(CHEEVOS_CHALLENGE_INDICATORS),\n   MENU_LABEL(CHEEVOS_ENABLE),\n   MENU_LABEL(CHEEVOS_DESCRIPTION),\n\n   MENU_LABEL(CHEEVOS_APPEARANCE_SETTINGS),\n   MENU_LABEL(CHEEVOS_APPEARANCE_ANCHOR),\n   MENU_LABEL(CHEEVOS_APPEARANCE_PADDING_AUTO),\n   MENU_LABEL(CHEEVOS_APPEARANCE_PADDING_H),\n   MENU_LABEL(CHEEVOS_APPEARANCE_PADDING_V),\n\n   MENU_ENUM_LABEL_VALUE_CHEEVOS_APPEARANCE_ANCHOR_TOPLEFT,\n   MENU_ENUM_LABEL_VALUE_CHEEVOS_APPEARANCE_ANCHOR_TOPCENTER,\n   MENU_ENUM_LABEL_VALUE_CHEEVOS_APPEARANCE_ANCHOR_TOPRIGHT,\n   MENU_ENUM_LABEL_VALUE_CHEEVOS_APPEARANCE_ANCHOR_BOTTOMLEFT,\n   MENU_ENUM_LABEL_VALUE_CHEEVOS_APPEARANCE_ANCHOR_BOTTOMCENTER,\n   MENU_ENUM_LABEL_VALUE_CHEEVOS_APPEARANCE_ANCHOR_BOTTOMRIGHT,\n\n   MENU_LABEL(CHEEVOS_VISIBILITY_SETTINGS),\n   MENU_LABEL(CHEEVOS_VISIBILITY_SUMMARY),\n   MENU_LABEL(CHEEVOS_VISIBILITY_UNLOCK),\n   MENU_LABEL(CHEEVOS_VISIBILITY_MASTERY),\n   MENU_LABEL(CHEEVOS_VISIBILITY_ACCOUNT),\n   MENU_LABEL(CHEEVOS_VISIBILITY_LBOARD_START),\n   MENU_LABEL(CHEEVOS_VISIBILITY_LBOARD_SUBMIT),\n   MENU_LABEL(CHEEVOS_VISIBILITY_LBOARD_CANCEL),\n   MENU_LABEL(CHEEVOS_VISIBILITY_LBOARD_TRACKERS),\n   MENU_LABEL(CHEEVOS_VISIBILITY_PROGRESS_TRACKER),\n\n   MENU_ENUM_LABEL_VALUE_CHEEVOS_VISIBILITY_SUMMARY_ALLGAMES,\n   MENU_ENUM_LABEL_VALUE_CHEEVOS_VISIBILITY_SUMMARY_HASCHEEVOS,\n\n   MENU_LBL_H(ACCOUNTS_RETRO_ACHIEVEMENTS),\n   MENU_LABEL(ACCOUNTS_TWITCH),\n   MENU_LABEL(ACCOUNTS_YOUTUBE),\n   MENU_LABEL(ACCOUNTS_FACEBOOK),\n\n   MENU_LABEL(ACCOUNTS_LIST),\n\n   MENU_ENUM_LABEL_VALUE_ACCOUNTS_LIST_END,\n\n   MENU_ENUM_LABEL_VALUE_MENU_ENUM_CONTROLS_PROLOG,\n\n   MENU_LABEL(HELP_WHAT_IS_A_CORE),\n   MENU_LABEL(HELP_LOADING_CONTENT),\n   MENU_LABEL(HELP_LIST),\n   MENU_LABEL(HELP_CONTROLS),\n   MENU_LABEL(HELP_CHEEVOS_DESCRIPTION),\n\n   MENU_ENUM_LABEL_VALUE_EXTRACTING_PLEASE_WAIT,\n\n   MENU_ENUM_LABEL_WELCOME_TO_RETROARCH,\n\n   MENU_LABEL(BROWSE_URL),\n   MENU_LABEL(BROWSE_START),\n   /* Deferred */\n   MENU_ENUM_LABEL_DEFERRED_VIDEO_SHADER_PRESET_REMOVE_LIST,\n   MENU_ENUM_LABEL_DEFERRED_VIDEO_SHADER_PRESET_SAVE_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CDROM_INFO_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CDROM_INFO_DETAIL_LIST,\n   MENU_ENUM_LABEL_DEFERRED_LOAD_DISC_LIST,\n   MENU_ENUM_LABEL_DEFERRED_DUMP_DISC_LIST,\n#ifdef HAVE_LAKKA\n   MENU_ENUM_LABEL_DEFERRED_EJECT_DISC,\n#endif\n   MENU_ENUM_LABEL_DEFERRED_REMAP_FILE_MANAGER_LIST,\n   MENU_ENUM_LABEL_DEFERRED_REMAPPINGS_PORT_LIST,\n   MENU_ENUM_LABEL_DEFERRED_OVERRIDE_FILE_MANAGER_LIST,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_SPECIAL,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_RESOLUTION,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_AUDIO_DEVICE,\n#ifdef HAVE_MICROPHONE\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_MICROPHONE_DEVICE,\n#endif\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_VIDEO_SHADER_PARAMETER,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_VIDEO_SHADER_PRESET_PARAMETER,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_VIDEO_SHADER_NUM_PASSES,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_PLAYLIST_DEFAULT_CORE,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_PLAYLIST_LABEL_DISPLAY_MODE,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_PLAYLIST_RIGHT_THUMBNAIL_MODE,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_PLAYLIST_LEFT_THUMBNAIL_MODE,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_PLAYLIST_ICON_THUMBNAIL_MODE,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_PLAYLIST_SORT_MODE,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_MANUAL_CONTENT_SCAN_SYSTEM_NAME,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_MANUAL_CONTENT_SCAN_CORE_NAME,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_DISK_INDEX,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_INPUT_DEVICE_TYPE,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_INPUT_DESCRIPTION,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_INPUT_DESCRIPTION_KBD,\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_INPUT_SELECT_RESERVED_DEVICE,\n#ifdef ANDROID\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_INPUT_SELECT_PHYSICAL_KEYBOARD,\n#endif\n   MENU_ENUM_LABEL_DEFERRED_DROPDOWN_BOX_LIST_NETPLAY_MITM_SERVER,\n   MENU_ENUM_LABEL_DEFERRED_MIXER_STREAM_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CONFIGURATIONS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_FAVORITES_LIST,\n   MENU_ENUM_LABEL_DEFERRED_PLAYLIST_LIST,\n   MENU_ENUM_LABEL_DEFERRED_IMAGES_LIST,\n   MENU_ENUM_LABEL_DEFERRED_MUSIC_LIST,\n   MENU_ENUM_LABEL_DEFERRED_VIDEO_LIST,\n   MENU_ENUM_LABEL_DEFERRED_EXPLORE_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CONTENTLESS_CORES_LIST,\n   MENU_ENUM_LABEL_DEFERRED_NETPLAY,\n   MENU_ENUM_LABEL_DEFERRED_MUSIC,\n   MENU_ENUM_LABEL_DEFERRED_BROWSE_URL_START,\n   MENU_ENUM_LABEL_DEFERRED_BROWSE_URL_LIST,\n   MENU_ENUM_LABEL_DEFERRED_ARCHIVE_ACTION_DETECT_CORE,\n   MENU_ENUM_LABEL_DEFERRED_ARCHIVE_ACTION,\n   MENU_ENUM_LABEL_DEFERRED_ARCHIVE_OPEN_DETECT_CORE,\n   MENU_ENUM_LABEL_DEFERRED_ARCHIVE_OPEN,\n   MENU_ENUM_LABEL_DEFERRED_CORE_CONTENT_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CORE_CONTENT_DIRS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CORE_CONTENT_DIRS_SUBDIR_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CORE_SYSTEM_FILES_LIST,\n   MENU_ENUM_LABEL_DEFERRED_LAKKA_LIST,\n   MENU_ENUM_LABEL_DEFERRED_INPUT_HOTKEY_BINDS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_INPUT_RETROPAD_BINDS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_DATABASE_MANAGER_LIST,\n   MENU_ENUM_LABEL_DEFERRED_VIDEO_FILTER,\n   MENU_ENUM_LABEL_DEFERRED_CORE_LIST_SET,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_DEVELOPER,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_PUBLISHER,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_ORIGIN,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_FRANCHISE,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_EDGE_MAGAZINE_RATING,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_EDGE_MAGAZINE_ISSUE,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_FAMITSU_MAGAZINE_RATING,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_ENHANCEMENT_HW,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_RELEASEMONTH,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_RELEASEYEAR,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_ESRB_RATING,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_ELSPA_RATING,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_PEGI_RATING,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_CERO_RATING,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_BBFC_RATING,\n   MENU_ENUM_LABEL_DEFERRED_CURSOR_MANAGER_LIST_RDB_ENTRY_MAX_USERS,\n   MENU_ENUM_LABEL_DEFERRED_RDB_ENTRY_DETAIL,\n   MENU_ENUM_LABEL_DEFERRED_RPL_ENTRY_ACTIONS,\n   MENU_ENUM_LABEL_DEFERRED_CORE_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CORE_UPDATER_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CORE_MANAGER_LIST,\n#ifdef HAVE_MIST\n   MENU_ENUM_LABEL_DEFERRED_STEAM_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CORE_MANAGER_STEAM_LIST,\n#endif\n#if 0\n/* Thumbnailpack removal */\n   MENU_ENUM_LABEL_DEFERRED_THUMBNAILS_UPDATER_LIST,\n#endif\n   MENU_ENUM_LABEL_DEFERRED_PL_THUMBNAILS_UPDATER_LIST,\n   MENU_ENUM_LABEL_DEFERRED_RECORDING_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_PLAYLIST_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_PLAYLIST_MANAGER_LIST,\n   MENU_ENUM_LABEL_DEFERRED_PLAYLIST_MANAGER_SETTINGS,\n   MENU_ENUM_LABEL_DEFERRED_INPUT_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_INPUT_TURBO_FIRE_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_INPUT_HAPTIC_FEEDBACK_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_INPUT_MENU_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_LATENCY_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_DRIVER_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_VIDEO_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_VIDEO_WINDOWED_MODE_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_VIDEO_FULLSCREEN_MODE_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_VIDEO_OUTPUT_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_VIDEO_SYNCHRONIZATION_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_VIDEO_HDR_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_VIDEO_SCALING_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CRT_SWITCHRES_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CONFIGURATION_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_SAVING_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CLOUD_SYNC_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_FRAME_THROTTLE_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_REWIND_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_FRAME_TIME_COUNTER_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_AI_SERVICE_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_ACCESSIBILITY_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CHEAT_DETAILS_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CHEAT_SEARCH_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_ONSCREEN_DISPLAY_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_ONSCREEN_OVERLAY_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_OSK_OVERLAY_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_OVERLAY_LIGHTGUN_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_OVERLAY_MOUSE_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_ONSCREEN_VIDEO_LAYOUT_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_ONSCREEN_NOTIFICATIONS_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_ONSCREEN_NOTIFICATIONS_VIEWS_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_MENU_VIEWS_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_QUICK_MENU_VIEWS_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_SETTINGS_VIEWS_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_QUICK_MENU_OVERRIDE_OPTIONS,\n   MENU_ENUM_LABEL_DEFERRED_MENU_SETTINGS_LIST,\n#ifdef _3DS\n   MENU_ENUM_LABEL_DEFERRED_MENU_BOTTOM_SETTINGS_LIST,\n#endif\n   MENU_ENUM_LABEL_DEFERRED_USER_INTERFACE_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_POWER_MANAGEMENT_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CPU_PERFPOWER_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CPU_POLICY_ENTRY,\n   MENU_ENUM_LABEL_DEFERRED_MENU_SOUNDS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_MENU_FILE_BROWSER_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_RETRO_ACHIEVEMENTS_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CHEEVOS_APPEARANCE_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CHEEVOS_VISIBILITY_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_UPDATER_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_BLUETOOTH_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_WIFI_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_WIFI_NETWORKS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_SUBSYSTEM_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_NETWORK_HOSTING_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_NETWORK_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_NETPLAY_LOBBY_FILTERS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_NETPLAY_LAN_SCAN_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_LAKKA_SERVICES_LIST,\n   MENU_ENUM_LABEL_DEFERRED_LAKKA_SWITCH_OPTIONS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_USER_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_DIRECTORY_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_PRIVACY_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_MIDI_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_LOGGING_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_AUDIO_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_AUDIO_RESAMPLER_SETTINGS_LIST, /* deprecated */\n   MENU_ENUM_LABEL_DEFERRED_AUDIO_OUTPUT_SETTINGS_LIST,\n#ifdef HAVE_MICROPHONE\n   MENU_ENUM_LABEL_DEFERRED_MICROPHONE_SETTINGS_LIST,\n#endif\n   MENU_ENUM_LABEL_DEFERRED_AUDIO_SYNCHRONIZATION_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_AUDIO_MIXER_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CORE_SETTINGS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CORE_INFORMATION_LIST,\n#ifdef HAVE_MIST\n   MENU_ENUM_LABEL_DEFERRED_CORE_INFORMATION_STEAM_LIST,\n#endif\n   MENU_ENUM_LABEL_DEFERRED_CORE_RESTORE_BACKUP_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CORE_DELETE_BACKUP_LIST,\n   MENU_ENUM_LABEL_DEFERRED_CORE_OPTION_OVERRIDE_LIST,\n   MENU_ENUM_LABEL_DEFERRED_USER_BINDS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_ACCOUNTS_CHEEVOS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_ACCOUNTS_TWITCH_LIST,\n   MENU_ENUM_LABEL_DEFERRED_ACCOUNTS_YOUTUBE_LIST,\n   MENU_ENUM_LABEL_DEFERRED_ACCOUNTS_FACEBOOK_LIST,\n   MENU_ENUM_LABEL_DEFERRED_ACCOUNTS_LIST,\n   MENU_ENUM_LABEL_DEFERRED_INFORMATION,\n   MENU_ENUM_LABEL_DEFERRED_MANUAL_CONTENT_SCAN_LIST,\n\n   MENU_LABEL(FILE_DETECT_CORE_LIST_PUSH_DIR),\n   MENU_LABEL(DOWNLOADED_FILE_DETECT_CORE_LIST),\n\n   MENU_ENUM_LABEL_VALUE_SEARCH,\n   MENU_ENUM_LABEL_VALUE_CYCLE_THUMBNAILS,\n\n   MENU_LABEL(DOWNLOAD_CORE_CONTENT),\n   MENU_LABEL(DOWNLOAD_CORE_CONTENT_DIRS),\n   MENU_LABEL(DOWNLOAD_CORE_SYSTEM_FILES),\n   MENU_LBL_H(SCAN_THIS_DIRECTORY),\n   MENU_LABEL(SCAN_DIRECTORY),\n   MENU_LABEL(SCAN_FILE),\n   MENU_LABEL(NETPLAY_SHOW_ONLY_CONNECTABLE),\n   MENU_LABEL(NETPLAY_SHOW_ONLY_INSTALLED_CORES),\n   MENU_LABEL(NETPLAY_SHOW_PASSWORDED),\n   MENU_LABEL(NETPLAY_REFRESH_ROOMS),\n   MENU_LABEL(NETPLAY_REFRESH_LAN),\n   MENU_LABEL(NETPLAY_ROOM_NICKNAME),\n   MENU_LABEL(NETPLAY_ROOM_NICKNAME_LAN),\n   MENU_LABEL(ADD_CONTENT_LIST),\n   MENU_LABEL(CONFIGURATIONS_LIST),\n\n   MENU_ENUM_LABEL_VALUE_DONT_CARE,\n   MENU_ENUM_LABEL_VALUE_LINEAR,\n   MENU_ENUM_LABEL_VALUE_NEAREST,\n   MENU_ENUM_LABEL_VALUE_MAIN,\n   MENU_ENUM_LABEL_VALUE_CONTENT,\n   MENU_ENUM_LABEL_VALUE_UNKNOWN,\n   MENU_ENUM_LABEL_VALUE_USER,\n   MENU_ENUM_LABEL_VALUE_KEYBOARD,\n   MENU_ENUM_LABEL_VALUE_CHEAT,\n   MENU_ENUM_LABEL_VALUE_SHADER,\n   MENU_ENUM_LABEL_VALUE_DIRECTORY_CONTENT,\n   MENU_ENUM_LABEL_VALUE_DIRECTORY_NONE,\n   MENU_ENUM_LABEL_VALUE_DIRECTORY_DEFAULT,\n   MENU_ENUM_LABEL_VALUE_NOT_AVAILABLE,\n   MENU_ENUM_LABEL_VALUE_ASK_ARCHIVE,\n\n   /* Online Updater */\n\n   MENU_LABEL(UPDATE_ASSETS),\n   MENU_LABEL(UPDATE_LAKKA),\n   MENU_LABEL(UPDATE_CHEATS),\n   MENU_LABEL(UPDATE_AUTOCONFIG_PROFILES),\n   MENU_LABEL(UPDATE_DATABASES),\n   MENU_LABEL(UPDATE_CG_SHADERS),\n   MENU_LABEL(UPDATE_OVERLAYS),\n   MENU_LABEL(UPDATE_GLSL_SHADERS),\n   MENU_LABEL(UPDATE_SLANG_SHADERS),\n   MENU_LABEL(UPDATE_CORE_INFO_FILES),\n\n   MENU_LABEL(INFORMATION),\n   MENU_LABEL(INFORMATION_LIST),\n   MENU_LABEL(USE_BUILTIN_PLAYER),\n   MENU_LABEL(NETPLAY_SETTINGS),\n   MENU_LABEL(CONTENT_SETTINGS),\n   MENU_LBL_H(LOAD_CONTENT_LIST),\n   MENU_LABEL(LOAD_CONTENT_SPECIAL),\n   MENU_LABEL(NO_SETTINGS_FOUND),\n   MENU_LABEL(NO_PRESETS_FOUND),\n   MENU_LABEL(NO_BT_DEVICES_FOUND),\n   MENU_LABEL(NO_NETWORKS_FOUND),\n   MENU_LABEL(NO_PERFORMANCE_COUNTERS),\n   MENU_LABEL(FRAME_THROTTLE_SETTINGS),\n   MENU_LABEL(FRAME_THROTTLE_ENABLE),\n   MENU_LABEL(CORE_ENABLE),\n\n   /* Netplay */\n   MENU_LABEL(NETPLAY_ENABLE_HOST),\n   MENU_LABEL(NETPLAY_DISABLE_HOST),\n   MENU_LABEL(NETPLAY_ENABLE_CLIENT),\n   MENU_LABEL(NETPLAY_DISCONNECT),\n   MENU_LABEL(NETPLAY_CONNECT_TO),\n   MENU_LABEL(NETPLAY_KICK),\n   MENU_ENUM_LABEL_DEFERRED_NETPLAY_KICK_LIST,\n   MENU_ENUM_LABEL_NETPLAY_KICK_CLIENT,\n   MENU_LABEL(NETPLAY_BAN),\n   MENU_ENUM_LABEL_DEFERRED_NETPLAY_BAN_LIST,\n   MENU_ENUM_LABEL_NETPLAY_BAN_CLIENT,\n   MENU_LABEL(NO_NETPLAY_HOSTS_FOUND),\n   MENU_LABEL(NO_NETPLAY_CLIENTS_FOUND),\n\n   MENU_ENUM_LABEL_RESET,\n   MENU_ENUM_LABEL_SLOWMOTION_HOLD,\n   MENU_ENUM_LABEL_HOLD_FAST_FORWARD,\n   MENU_ENUM_LABEL_CHEAT_TOGGLE,\n   MENU_ENUM_LABEL_PAUSE_TOGGLE,\n\n   MENU_LABEL(PAUSE_LIBRETRO),\n   MENU_LABEL(MENU_SAVESTATE_RESUME),\n   MENU_LABEL(MENU_INSERT_DISK_RESUME),\n   MENU_LABEL(DIRECTORY_NOT_FOUND),\n   MENU_LABEL(NO_ITEMS),\n   MENU_LABEL(NO_PLAYLISTS),\n\n   MSG_INTERFACE,\n   MSG_MEMORY,\n   MSG_IN_BYTES,\n   MSG_IN_MEGABYTES,\n   MSG_IN_GIGABYTES,\n   MSG_INTERNAL_STORAGE,\n   MSG_REMOVABLE_STORAGE,\n   MSG_APPLICATION_DIR,\n   MSG_EXTERNAL_APPLICATION_DIR,\n\n   MENU_LABEL(SHADER_OPTIONS),\n   MENU_LBL_H(USE_THIS_DIRECTORY),\n   MENU_LABEL(SAVESTATE_LIST),\n   MENU_LABEL(CORE_OPTIONS),\n   MENU_LABEL(NO_SHADER_PARAMETERS),\n   MENU_LABEL(NO_CORE_INFORMATION_AVAILABLE),\n   MENU_LABEL(NO_CORE_BACKUPS_AVAILABLE),\n   MENU_LABEL(NO_CORES_AVAILABLE),\n\n   /* Audio */\n   MENU_LABEL(AUDIO_ENABLE),\n   MENU_LABEL(AUDIO_ENABLE_MENU),\n   MENU_LBL_H(AUDIO_MAX_TIMING_SKEW),\n   MENU_LABEL(AUDIO_OUTPUT_RATE),\n   MENU_LBL_H(AUDIO_DEVICE),\n   MENU_ENUM_LABEL_AUDIO_DEVICE_LIST,\n   MENU_ENUM_LABEL_HELP_AUDIO_DEVICE_ALSA,\n   MENU_ENUM_LABEL_HELP_AUDIO_DEVICE_OSS,\n   MENU_ENUM_LABEL_HELP_AUDIO_DEVICE_JACK,\n   MENU_ENUM_LABEL_HELP_AUDIO_DEVICE_RSOUND,\n   MENU_LABEL(AUDIO_BLOCK_FRAMES),\n   MENU_LABEL(AUDIO_DSP_PLUGIN),\n   MENU_LABEL(AUDIO_DSP_PLUGIN_REMOVE),\n   MENU_LABEL(AUDIO_MUTE),\n   MENU_LABEL(AUDIO_MIXER_MUTE),\n   MENU_LABEL(AUDIO_RESPECT_SILENT_MODE),\n   MENU_LABEL(AUDIO_FASTFORWARD_MUTE),\n   MENU_LABEL(AUDIO_FASTFORWARD_SPEEDUP),\n   MENU_LABEL(AUDIO_SYNC),\n   MENU_LBL_H(AUDIO_VOLUME),\n   MENU_LABEL(AUDIO_MIXER_VOLUME),\n   MENU_LBL_H(AUDIO_RATE_CONTROL_DELTA),\n   MENU_LABEL(AUDIO_LATENCY),\n   MENU_LABEL(AUDIO_RESAMPLER_QUALITY),\n   MENU_LABEL(AUDIO_WASAPI_EXCLUSIVE_MODE),\n   MENU_LABEL(AUDIO_WASAPI_FLOAT_FORMAT),\n   MENU_LABEL(AUDIO_WASAPI_SH_BUFFER_LENGTH),\n\n#ifdef HAVE_MICROPHONE\n   /* Microphone */\n   MENU_LABEL(MICROPHONE_ENABLE),\n   MENU_LABEL(MICROPHONE_INPUT_RATE),\n   MENU_LABEL(MICROPHONE_LATENCY),\n   MENU_LABEL(MICROPHONE_RESAMPLER_QUALITY),\n   MENU_LBL_H(MICROPHONE_DEVICE),\n   MENU_ENUM_LABEL_MICROPHONE_DEVICE_LIST,\n   MENU_LABEL(MICROPHONE_BLOCK_FRAMES),\n   MENU_LABEL(MICROPHONE_WASAPI_EXCLUSIVE_MODE),\n   MENU_LABEL(MICROPHONE_WASAPI_FLOAT_FORMAT),\n   MENU_LABEL(MICROPHONE_WASAPI_SH_BUFFER_LENGTH),\n#endif\n\n   MENU_LABEL(SAVE_STATE),\n   MENU_LABEL(LOAD_STATE),\n   MENU_LABEL(UNDO_LOAD_STATE),\n   MENU_LABEL(UNDO_SAVE_STATE),\n\n   MENU_LABEL(PLAY_REPLAY),\n   MENU_LABEL(RECORD_REPLAY),\n   MENU_LABEL(HALT_REPLAY),\n   MENU_LABEL(REPLAY_SLOT),\n\n   MENU_LABEL(NETPLAY_GAME_WATCH),\n   MENU_LABEL(CHEAT_INDEX_MINUS),\n   MENU_LABEL(CHEAT_INDEX_PLUS),\n   MENU_LABEL(SHADER_NEXT),\n   MENU_LABEL(SHADER_PREV),\n   MENU_LABEL(SHADER_TOGGLE),\n   MENU_LABEL(FRAME_ADVANCE),\n   MENU_LABEL(FPS_SHOW),\n   MENU_LABEL(FPS_UPDATE_INTERVAL),\n   MENU_LABEL(MEMORY_SHOW),\n   MENU_LABEL(MEMORY_UPDATE_INTERVAL),\n   MENU_LABEL(STATISTICS_SHOW),\n   MENU_LABEL(FRAMECOUNT_SHOW),\n   MENU_ENUM_LABEL_L_X_PLUS,\n   MENU_ENUM_LABEL_L_X_MINUS,\n   MENU_ENUM_LABEL_L_Y_PLUS,\n   MENU_ENUM_LABEL_L_Y_MINUS,\n   MENU_ENUM_LABEL_R_X_PLUS,\n   MENU_ENUM_LABEL_R_X_MINUS,\n   MENU_ENUM_LABEL_R_Y_MINUS,\n   MENU_ENUM_LABEL_R_Y_PLUS,\n\n   MENU_LABEL(BLOCK_SRAM_OVERWRITE),\n   MENU_LABEL(GAME_SPECIFIC_OPTIONS),\n\n   MENU_LABEL(CORE_OPTION_OVERRIDE_LIST),\n   MENU_LABEL(GAME_SPECIFIC_CORE_OPTIONS_CREATE),\n   MENU_LABEL(GAME_SPECIFIC_CORE_OPTIONS_REMOVE),\n   MENU_LABEL(FOLDER_SPECIFIC_CORE_OPTIONS_CREATE),\n   MENU_LABEL(FOLDER_SPECIFIC_CORE_OPTIONS_REMOVE),\n   MENU_LABEL(CORE_OPTION_OVERRIDE_INFO),\n   MENU_LABEL(CORE_OPTIONS_RESET),\n   MENU_LABEL(CORE_OPTIONS_FLUSH),\n\n   /* Legacy (unused)\n    * > Cannot remove these because they are\n    *   referenced in the translation files,\n    *   which are handled via Crowdin */\n   MENU_LABEL(GAME_SPECIFIC_OPTIONS_CREATE),\n   MENU_LABEL(GAME_SPECIFIC_OPTIONS_IN_USE),\n\n   MENU_LABEL(AUTO_OVERRIDES_ENABLE),\n   MENU_LABEL(AUTO_REMAPS_ENABLE),\n   MENU_LABEL(INITIAL_DISK_CHANGE_ENABLE),\n   MENU_LABEL(GLOBAL_CORE_OPTIONS),\n   MENU_LABEL(AUTO_SHADERS_ENABLE),\n   MENU_LABEL(RGUI_SHOW_START_SCREEN),\n   MENU_LABEL(SCREENSHOT),\n   MENU_LABEL(REWIND),\n   MENU_LABEL(REWIND_GRANULARITY),\n   MENU_LABEL(REWIND_BUFFER_SIZE),\n   MENU_LABEL(REWIND_BUFFER_SIZE_STEP),\n   /* TODO/FIXME: INPUT_META_REWIND is incorrectly defined;\n    * the LABEL/SUBLABEL enums should be entered 'manually',\n    * like all the other hotkeys. Moreover, the resultant\n    * MENU_ENUM_SUBLABEL_INPUT_META_REWIND enum is incorrectly\n    * used for the MENU_ENUM_LABEL_REWIND_SETTINGS menu entry.\n    * Because of this mistake, we now have improper entries\n    * in all the translation files, which cannot easily be removed\n    * now that everything is handled via Crowdin.\n    * To work around this error, we have to use a separate\n    * MENU_ENUM_SUBLABEL_INPUT_META_REWIND_HOTKEY enum\n    * for the actual rewind hotkey sublabel... */\n   MENU_LABEL(INPUT_META_REWIND),\n   MENU_LABEL(INPUT_META_CHEAT_DETAILS),\n   MENU_LABEL(INPUT_META_CHEAT_SEARCH),\n\n   MENU_LABEL(CHEAT_IDX),\n   MENU_LABEL(CHEAT_DESC),\n   MENU_LABEL(CHEAT_STATE),\n   MENU_LABEL(CHEAT_CODE),\n   MENU_LABEL(CHEAT_HANDLER),\n   MENU_LABEL(CHEAT_MEMORY_SEARCH_SIZE),\n   MENU_LABEL(CHEAT_TYPE),\n   MENU_LABEL(CHEAT_VALUE),\n   MENU_LABEL(CHEAT_ADDRESS),\n   MENU_LABEL(CHEAT_ADDRESS_BIT_POSITION),\n   MENU_LABEL(CHEAT_REPEAT_COUNT),\n   MENU_LABEL(CHEAT_REPEAT_ADD_TO_VALUE),\n   MENU_LABEL(CHEAT_REPEAT_ADD_TO_ADDRESS),\n   MENU_LABEL(CHEAT_RUMBLE_TYPE),\n   MENU_LABEL(CHEAT_RUMBLE_VALUE),\n   MENU_LABEL(CHEAT_RUMBLE_PORT),\n   MENU_LABEL(CHEAT_RUMBLE_PRIMARY_STRENGTH),\n   MENU_LABEL(CHEAT_RUMBLE_PRIMARY_DURATION),\n   MENU_LABEL(CHEAT_RUMBLE_SECONDARY_STRENGTH),\n   MENU_LABEL(CHEAT_RUMBLE_SECONDARY_DURATION),\n   MENU_LABEL(CHEAT_ADD_NEW_AFTER),\n   MENU_LABEL(CHEAT_ADD_NEW_BEFORE),\n   MENU_LABEL(CHEAT_COPY_AFTER),\n   MENU_LABEL(CHEAT_COPY_BEFORE),\n   MENU_LABEL(CHEAT_DELETE),\n\n   MENU_LBL_H(CHEAT_START_OR_CONT),\n   MENU_LABEL(CHEAT_START_OR_RESTART),\n   MENU_LABEL(CHEAT_SEARCH_EXACT),\n   MENU_LABEL(CHEAT_SEARCH_LT),\n   MENU_LABEL(CHEAT_SEARCH_GT),\n   MENU_LABEL(CHEAT_SEARCH_LTE),\n   MENU_LABEL(CHEAT_SEARCH_GTE),\n   MENU_LABEL(CHEAT_SEARCH_EQ),\n   MENU_LABEL(CHEAT_SEARCH_NEQ),\n   MENU_LABEL(CHEAT_SEARCH_EQPLUS),\n   MENU_LABEL(CHEAT_SEARCH_EQMINUS),\n   MENU_LABEL(CHEAT_ADD_MATCHES),\n   MENU_LABEL(CHEAT_CREATE_OPTION),\n   MENU_LABEL(CHEAT_DELETE_OPTION),\n   MENU_LABEL(CHEAT_ADD_NEW_TOP),\n   MENU_LABEL(CHEAT_ADD_NEW_BOTTOM),\n   MENU_LABEL(CHEAT_DELETE_ALL),\n   MENU_LABEL(CHEAT_RELOAD_CHEATS),\n   MENU_LABEL(CHEAT_BIG_ENDIAN),\n   MENU_LABEL(CHEAT_MATCH_IDX),\n   MENU_LABEL(CHEAT_MATCH),\n   MENU_LABEL(CHEAT_BROWSE_MEMORY),\n   MENU_LABEL(CHEAT_COPY_MATCH),\n   MENU_LABEL(CHEAT_DELETE_MATCH),\n   MENU_LABEL(SCREEN_RESOLUTION),\n\n   MSG_SCREEN_RESOLUTION_FORMAT_NO_DESC,\n   MSG_SCREEN_RESOLUTION_FORMAT_DESC,\n   MSG_SCREEN_RESOLUTION_DEFAULT,\n   MSG_SCREEN_RESOLUTION_NO_DESC,\n   MSG_SCREEN_RESOLUTION_DESC,\n   MSG_SCREEN_RESOLUTION_APPLYING_DEFAULT,\n   MSG_SCREEN_RESOLUTION_APPLYING_NO_DESC,\n   MSG_SCREEN_RESOLUTION_APPLYING_DESC,\n   MSG_SCREEN_RESOLUTION_RESETTING_DEFAULT,\n   MSG_SCREEN_RESOLUTION_RESETTING_NO_DESC,\n   MSG_SCREEN_RESOLUTION_RESETTING_DESC,\n\n   MENU_LABEL(SAVESTATE_AUTO_INDEX),\n   MENU_LABEL(SAVESTATE_MAX_KEEP),\n   MENU_LABEL(REPLAY_AUTO_INDEX),\n   MENU_LABEL(REPLAY_MAX_KEEP),\n   MENU_LABEL(SAVESTATE_AUTO_SAVE),\n   MENU_LABEL(SAVESTATE_AUTO_LOAD),\n   MENU_LABEL(SAVESTATE_THUMBNAIL_ENABLE),\n   MENU_LABEL(SAVE_FILE_COMPRESSION),\n   MENU_LABEL(SAVESTATE_FILE_COMPRESSION),\n\n   MENU_LBL_H(SUSPEND_SCREENSAVER_ENABLE),\n   MENU_ENUM_LABEL_VOLUME_UP,\n   MENU_ENUM_LABEL_VOLUME_DOWN,\n\n   MENU_LABEL(LOG_VERBOSITY),\n   MENU_ENUM_LABEL_VALUE_LOG_VERBOSITY_DEBUG,\n   MENU_ENUM_LABEL_VALUE_LOG_VERBOSITY_INFO,\n   MENU_ENUM_LABEL_VALUE_LOG_VERBOSITY_WARNING,\n   MENU_ENUM_LABEL_VALUE_LOG_VERBOSITY_ERROR,\n   MENU_LABEL(LOG_TO_FILE),\n   MENU_LABEL(LOG_TO_FILE_TIMESTAMP),\n\n   MENU_ENUM_LABEL_OVERLAY_NEXT,\n\n   MENU_LABEL(NETPLAY_ENABLE),\n#ifdef HAVE_LAKKA\n   MENU_LABEL(SSH_ENABLE),\n   MENU_LABEL(SAMBA_ENABLE),\n   MENU_LABEL(BLUETOOTH_ENABLE),\n   MENU_LABEL(LOCALAP_ENABLE),\n   MENU_LBL_H(TIMEZONE),\n#endif\n#ifdef HAVE_LAKKA_SWITCH\n   MENU_LABEL(SWITCH_OC_ENABLE),\n   MENU_LABEL(SWITCH_CEC_ENABLE),\n   MENU_LABEL(BLUETOOTH_ERTM_DISABLE),\n#endif\n   MENU_LABEL(NETPLAY_DELAY_FRAMES), /* deprecated */\n   MENU_LABEL(NETPLAY_PUBLIC_ANNOUNCE),\n   MENU_LBL_H(NETPLAY_START_AS_SPECTATOR),\n   MENU_LABEL(NETPLAY_FADE_CHAT),\n   MENU_LABEL(NETPLAY_CHAT_COLOR_NAME),\n   MENU_LABEL(NETPLAY_CHAT_COLOR_MSG),\n   MENU_LABEL(NETPLAY_ALLOW_PAUSING),\n   MENU_LABEL(NETPLAY_ALLOW_SLAVES),\n   MENU_LABEL(NETPLAY_REQUIRE_SLAVES),\n   MENU_LBL_H(NETPLAY_CHECK_FRAMES),\n   MENU_LBL_H(NETPLAY_INPUT_LATENCY_FRAMES_MIN),\n   MENU_LBL_H(NETPLAY_INPUT_LATENCY_FRAMES_RANGE),\n   MENU_LABEL(NETPLAY_SPECTATOR_MODE_ENABLE), /* deprecated */\n   MENU_LABEL(NETPLAY_TCP_UDP_PORT),\n   MENU_LABEL(NETPLAY_MAX_CONNECTIONS),\n   MENU_LABEL(NETPLAY_MAX_PING),\n   MENU_LABEL(NETPLAY_NAT_TRAVERSAL),\n   MENU_LABEL(NETPLAY_REQUEST_DEVICE_I),\n   MENU_LABEL(NETPLAY_PING_SHOW),\n   MENU_ENUM_LABEL_NETPLAY_REQUEST_DEVICE_1,\n   MENU_ENUM_LABEL_NETPLAY_REQUEST_DEVICE_LAST = MENU_ENUM_LABEL_NETPLAY_REQUEST_DEVICE_1 + MAX_USERS,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_SHARE_NONE,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_SHARE_NO_PREFERENCE,\n   MENU_LABEL(NETPLAY_SHARE_DIGITAL),\n   MENU_ENUM_LABEL_VALUE_NETPLAY_SHARE_DIGITAL_OR,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_SHARE_DIGITAL_XOR,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_SHARE_DIGITAL_VOTE,\n   MENU_LABEL(NETPLAY_SHARE_ANALOG),\n   MENU_ENUM_LABEL_VALUE_NETPLAY_SHARE_ANALOG_MAX,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_SHARE_ANALOG_AVERAGE,\n\n   MENU_LABEL(SORT_SAVEFILES_ENABLE),\n   MENU_LABEL(SORT_SAVESTATES_ENABLE),\n   MENU_LABEL(SORT_SAVEFILES_BY_CONTENT_ENABLE),\n   MENU_LABEL(SORT_SAVESTATES_BY_CONTENT_ENABLE),\n   MENU_LABEL(SAVEFILES_IN_CONTENT_DIR_ENABLE),\n   MENU_LABEL(SAVESTATES_IN_CONTENT_DIR_ENABLE),\n   MENU_LABEL(SYSTEMFILES_IN_CONTENT_DIR_ENABLE),\n   MENU_LABEL(SCREENSHOTS_IN_CONTENT_DIR_ENABLE),\n   MENU_LABEL(SORT_SCREENSHOTS_BY_CONTENT_ENABLE),\n   MENU_LABEL(NETPLAY_IP_ADDRESS),\n   MENU_LABEL(NETPLAY_PASSWORD),\n   MENU_LABEL(NETPLAY_SPECTATE_PASSWORD),\n   MENU_LABEL(NETPLAY_MODE), /* deprecated */\n   MENU_LABEL(PERFCNT_ENABLE),\n   MENU_LABEL(OVERLAY_SCALE_LANDSCAPE),\n   MENU_LABEL(OVERLAY_ASPECT_ADJUST_LANDSCAPE),\n   MENU_LABEL(OVERLAY_X_SEPARATION_LANDSCAPE),\n   MENU_LABEL(OVERLAY_Y_SEPARATION_LANDSCAPE),\n   MENU_LABEL(OVERLAY_X_OFFSET_LANDSCAPE),\n   MENU_LABEL(OVERLAY_Y_OFFSET_LANDSCAPE),\n   MENU_LABEL(OVERLAY_SCALE_PORTRAIT),\n   MENU_LABEL(OVERLAY_ASPECT_ADJUST_PORTRAIT),\n   MENU_LABEL(OVERLAY_X_SEPARATION_PORTRAIT),\n   MENU_LABEL(OVERLAY_Y_SEPARATION_PORTRAIT),\n   MENU_LABEL(OVERLAY_X_OFFSET_PORTRAIT),\n   MENU_LABEL(OVERLAY_Y_OFFSET_PORTRAIT),\n   MENU_LABEL(OVERLAY_PRESET),\n   MENU_LABEL(OSK_OVERLAY_PRESET),\n   MENU_LABEL(OVERLAY_OPACITY),\n   MENU_LABEL(OSK_OVERLAY_OPACITY),\n\n   /* TODO/FIXME: These legacy enums are no longer\n    * required, but we cannot delete them until the\n    * corresponding translation file entries have\n    * been removed via Crowdin... */\n   MENU_LABEL(OVERLAY_SCALE),\n   MENU_LABEL(OVERLAY_CENTER_X),\n   MENU_LABEL(OVERLAY_CENTER_Y),\n\n   MENU_LBL_H(FASTFORWARD_RATIO),\n   MENU_LABEL(FASTFORWARD_FRAMESKIP),\n   MENU_LBL_H(VRR_RUNLOOP_ENABLE),\n   MENU_LABEL(REWIND_ENABLE),\n   MENU_LABEL(CHEAT_APPLY_AFTER_TOGGLE),\n   MENU_LABEL(CHEAT_APPLY_AFTER_LOAD),\n\n   MENU_ENUM_LABEL_ENABLE_HOTKEY,\n   MENU_ENUM_LABEL_HELP_ENABLE_HOTKEY,\n   MENU_ENUM_LABEL_DISK_EJECT_TOGGLE,\n   MENU_ENUM_LABEL_DISK_NEXT,\n   MENU_ENUM_LABEL_GRAB_MOUSE_TOGGLE,\n   MENU_ENUM_LABEL_GAME_FOCUS_TOGGLE,\n   MENU_LABEL(STATE_SLOT_DECREASE),\n   MENU_LABEL(STATE_SLOT_INCREASE),\n   MENU_LABEL(REPLAY_SLOT_DECREASE),\n   MENU_LABEL(REPLAY_SLOT_INCREASE),\n\n   MENU_LABEL(FRONTEND_LOG_LEVEL),\n   MENU_LBL_H(LIBRETRO_LOG_LEVEL),\n   MENU_LBL_H(AUTOSAVE_INTERVAL),\n   MENU_LBL_H(REPLAY_CHECKPOINT_INTERVAL),\n   MENU_LBL_H(CONFIG_SAVE_ON_EXIT),\n   MENU_LABEL(REMAP_SAVE_ON_EXIT),\n   MENU_LABEL(CONFIGURATION_LIST),\n   MENU_LABEL(CONFIRM_ON_EXIT),\n   MENU_LABEL(SHOW_HIDDEN_FILES),\n   MENU_LABEL(USE_LAST_START_DIRECTORY),\n\n   /* Driver settings */\n\n   MENU_LABEL(AUDIO_DRIVER),\n   MENU_LABEL(JOYPAD_DRIVER),\n   MENU_LABEL(MENU_DRIVER),\n   MENU_LABEL(LOCATION_DRIVER),\n   MENU_LABEL(CAMERA_DRIVER),\n   MENU_LABEL(BLUETOOTH_DRIVER),\n   MENU_LABEL(WIFI_DRIVER),\n   MENU_LABEL(AUDIO_RESAMPLER_DRIVER),\n#ifdef HAVE_MICROPHONE\n   MENU_LABEL(MICROPHONE_DRIVER),\n   MENU_LABEL(MICROPHONE_RESAMPLER_DRIVER),\n#endif\n   MENU_LABEL(RECORD_DRIVER),\n   MENU_LABEL(VIDEO_DRIVER),\n   MENU_LABEL(INPUT_DRIVER),\n   MENU_LABEL(MIDI_DRIVER),\n\n   MENU_ENUM_LABEL_AUDIO_DRIVER_RSOUND,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_AUDIOIO,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_OSS,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_ALSA,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_ALSATHREAD,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_TINYALSA,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_ROAR,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_COREAUDIO,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_COREAUDIO3,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_AL,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_SL,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_SDL,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_SDL2,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_DSOUND,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_WASAPI,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_XAUDIO,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_PULSE,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_PIPEWIRE,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_EXT,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_XENON360,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_PS3,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_WII,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_WIIU,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_PSP,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_PS2,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_CTR,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_SWITCH,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_RWEBAUDIO,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_JACK,\n   MENU_ENUM_LABEL_AUDIO_DRIVER_NULL,\n\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_RSOUND,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_AUDIOIO,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_OSS,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_ALSA,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_ALSATHREAD,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_TINYALSA,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_ROAR,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_COREAUDIO,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_COREAUDIO3,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_AL,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_SL,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_SDL,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_SDL2,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_DSOUND,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_WASAPI,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_XAUDIO,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_PULSE,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_PIPEWIRE,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_EXT,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_XENON360,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_PS3,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_WII,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_WIIU,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_PSP,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_PS2,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_CTR,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_SWITCH,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_RWEBAUDIO,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_JACK,\n   MENU_ENUM_LABEL_HELP_AUDIO_DRIVER_NULL,\n\n   MENU_ENUM_LABEL_VIDEO_DRIVER_GL,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_GL1,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_GL_CORE,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_VULKAN,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_METAL,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_DRM,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_WII,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_WIIU,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_XENON360,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_D3D8,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_D3D9_CG,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_D3D9_HLSL,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_D3D10,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_D3D11,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_D3D12,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_PSP1,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_PS2,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_VITA2D,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_CTR,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_SWITCH,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_XVIDEO,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_SDL_DINGUX,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_SDL_RS90,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_SDL1,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_SDL2,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_EXT,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_VG,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_OMAP,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_EXYNOS,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_DISPMANX,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_SUNXI,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_CACA,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_GDI,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_VGA,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_FPGA,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_RSX,\n   MENU_ENUM_LABEL_VIDEO_DRIVER_NULL,\n\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_GL,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_GL1,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_GL_CORE,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_VULKAN,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_METAL,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_DRM,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_WII,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_WIIU,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_XENON360,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_D3D8,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_D3D9_CG,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_D3D9_HLSL,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_D3D10,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_D3D11,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_D3D12,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_PSP1,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_PS2,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_VITA2D,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_CTR,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_SWITCH,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_XVIDEO,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_SDL_DINGUX,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_SDL_RS90,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_SDL1,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_SDL2,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_EXT,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_VG,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_OMAP,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_EXYNOS,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_DISPMANX,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_SUNXI,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_CACA,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_GDI,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_VGA,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_FPGA,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_RSX,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_NULL,\n   MENU_ENUM_LABEL_HELP_VIDEO_DRIVER_NO_DETAILS,\n\n   MENU_LABEL(MENU_ENUM_DRIVER),\n\n   MENU_ENUM_LABEL_AUDIO_RESAMPLER_DRIVER_SINC,\n   MENU_ENUM_LABEL_AUDIO_RESAMPLER_DRIVER_CC,\n   MENU_ENUM_LABEL_AUDIO_RESAMPLER_DRIVER_NEAREST,\n   MENU_ENUM_LABEL_AUDIO_RESAMPLER_DRIVER_NULL,\n   MENU_ENUM_LABEL_HELP_AUDIO_RESAMPLER_DRIVER_SINC,\n   MENU_ENUM_LABEL_HELP_AUDIO_RESAMPLER_DRIVER_CC,\n   MENU_ENUM_LABEL_HELP_AUDIO_RESAMPLER_DRIVER_NEAREST,\n   MENU_ENUM_LABEL_HELP_AUDIO_RESAMPLER_DRIVER_NULL,\n\n   MENU_ENUM_LABEL_MENU_DRIVER_RGUI,\n   MENU_ENUM_LABEL_MENU_DRIVER_OZONE,\n   MENU_ENUM_LABEL_MENU_DRIVER_MATERIALUI,\n   MENU_ENUM_LABEL_MENU_DRIVER_XMB,\n   MENU_ENUM_LABEL_HELP_MENU_DRIVER_RGUI,\n   MENU_ENUM_LABEL_HELP_MENU_DRIVER_OZONE,\n   MENU_ENUM_LABEL_HELP_MENU_DRIVER_MATERIALUI,\n   MENU_ENUM_LABEL_HELP_MENU_DRIVER_XMB,\n\n   MENU_LBL_H(SAVEFILE_DIRECTORY),\n   MENU_LABEL(SAVESTATE_DIRECTORY),\n   MENU_LABEL(DYNAMIC_WALLPAPERS_DIRECTORY),\n   MENU_LABEL(THUMBNAILS_DIRECTORY),\n\n   MENU_LABEL(SLOWMOTION_RATIO),\n   MENU_LABEL(RUN_AHEAD_UNSUPPORTED),\n   MENU_LABEL(RUN_AHEAD_HIDE_WARNINGS),\n   MENU_LABEL(RUN_AHEAD_FRAMES),\n   MENU_LABEL(PREEMPT_FRAMES),\n   MENU_LABEL(INPUT_BLOCK_TIMEOUT),\n   MENU_LABEL(TURBO),\n\n   /* Privacy settings */\n\n   MENU_LABEL(CAMERA_ALLOW),\n   MENU_LABEL(DISCORD_ALLOW),\n   MENU_LABEL(LOCATION_ALLOW),\n\n   /* RDB Settings */\n\n   MENU_LABEL(RDB_ENTRY_ANALOG),\n   MENU_LABEL(RDB_ENTRY_SERIAL),\n   MENU_LABEL(RDB_ENTRY_RUMBLE),\n   MENU_LABEL(RDB_ENTRY_COOP),\n   MENU_LABEL(RDB_ENTRY_START_CONTENT),\n   MENU_LABEL(RDB_ENTRY_DESCRIPTION),\n   MENU_LABEL(RDB_ENTRY_GENRE),\n   MENU_LABEL(RDB_ENTRY_ACHIEVEMENTS),\n   MENU_LABEL(RDB_ENTRY_CATEGORY),\n   MENU_LABEL(RDB_ENTRY_LANGUAGE),\n   MENU_LABEL(RDB_ENTRY_REGION),\n   MENU_LABEL(RDB_ENTRY_CONSOLE_EXCLUSIVE),\n   MENU_LABEL(RDB_ENTRY_PLATFORM_EXCLUSIVE),\n   MENU_LABEL(RDB_ENTRY_SCORE),\n   MENU_LABEL(RDB_ENTRY_MEDIA),\n   MENU_LABEL(RDB_ENTRY_CONTROLS),\n   MENU_LABEL(RDB_ENTRY_ARTSTYLE),\n   MENU_LABEL(RDB_ENTRY_GAMEPLAY),\n   MENU_LABEL(RDB_ENTRY_NARRATIVE),\n   MENU_LABEL(RDB_ENTRY_PACING),\n   MENU_LABEL(RDB_ENTRY_PERSPECTIVE),\n   MENU_LABEL(RDB_ENTRY_SETTING),\n   MENU_LABEL(RDB_ENTRY_VISUAL),\n   MENU_LABEL(RDB_ENTRY_VEHICULAR),\n   MENU_LABEL(RDB_ENTRY_ENHANCEMENT_HW),\n   MENU_LABEL(RDB_ENTRY_FRANCHISE),\n   MENU_LABEL(RDB_ENTRY_ORIGIN),\n   MENU_LABEL(RDB_ENTRY_DEVELOPER),\n   MENU_LABEL(RDB_ENTRY_NAME),\n   MENU_LABEL(RDB_ENTRY_PUBLISHER),\n   MENU_LABEL(RDB_ENTRY_ESRB_RATING),\n   MENU_LABEL(RDB_ENTRY_BBFC_RATING),\n   MENU_LABEL(RDB_ENTRY_ELSPA_RATING),\n   MENU_LABEL(RDB_ENTRY_PEGI_RATING),\n   MENU_LABEL(RDB_ENTRY_CERO_RATING),\n   MENU_LABEL(RDB_ENTRY_EDGE_MAGAZINE_RATING),\n   MENU_LABEL(RDB_ENTRY_EDGE_MAGAZINE_ISSUE),\n   MENU_LABEL(RDB_ENTRY_EDGE_MAGAZINE_REVIEW),\n   MENU_LABEL(RDB_ENTRY_FAMITSU_MAGAZINE_RATING),\n   MENU_LABEL(RDB_ENTRY_TGDB_RATING),\n   MENU_LABEL(RDB_ENTRY_RELEASE_MONTH),\n   MENU_LABEL(RDB_ENTRY_RELEASE_YEAR),\n   MENU_LABEL(RDB_ENTRY_MAX_USERS),\n   MENU_LABEL(RDB_ENTRY_SHA1),\n   MENU_LABEL(RDB_ENTRY_MD5),\n   MENU_LABEL(RDB_ENTRY_CRC32),\n   MENU_LABEL(RDB_ENTRY_DETAIL),\n\n   /* Explore tab */\n   MENU_LABEL(EXPLORE_INITIALISING_LIST),\n   MENU_ENUM_LABEL_VALUE_EXPLORE_CATEGORY_RELEASE_YEAR,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_CATEGORY_PLAYER_COUNT,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_CATEGORY_REGION,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_CATEGORY_TAG,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_SEARCH_NAME,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_SHOW_ALL,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_ADDITIONAL_FILTER,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_ALL,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_ADD_ADDITIONAL_FILTER,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_ITEMS_COUNT,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_DEVELOPER,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_PUBLISHER,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_RELEASE_YEAR,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_PLAYER_COUNT,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_GENRE,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_ACHIEVEMENTS,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_CATEGORY,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_LANGUAGE,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_CONSOLE_EXCLUSIVE,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_PLATFORM_EXCLUSIVE,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_RUMBLE,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_SCORE,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_MEDIA,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_CONTROLS,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_ARTSTYLE,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_GAMEPLAY,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_NARRATIVE,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_PACING,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_PERSPECTIVE,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_SETTING,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_VISUAL,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_VEHICULAR,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_ORIGIN,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_REGION,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_FRANCHISE,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_TAG,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_BY_SYSTEM_NAME,\n   MENU_ENUM_LABEL_EXPLORE_RANGE_FILTER,\n   MENU_ENUM_LABEL_EXPLORE_VIEW,\n   MENU_ENUM_LABEL_EXPLORE_SAVE_VIEW,\n   MENU_ENUM_LABEL_EXPLORE_DELETE_VIEW,\n   MENU_ENUM_LABEL_EXPLORE_NEW_VIEW,\n   MENU_ENUM_LABEL_EXPLORE_VIEW_EXISTS,\n   MENU_ENUM_LABEL_EXPLORE_VIEW_SAVED,\n   MENU_ENUM_LABEL_EXPLORE_VIEW_DELETED,\n\n   /* Content information settings */\n   MENU_LABEL(CONTENT_INFO_LABEL),\n   MENU_LABEL(CONTENT_INFO_PATH),\n   MENU_LABEL(CONTENT_INFO_ENTRY_IDX),\n   MENU_LABEL(CONTENT_INFO_CORE_NAME),\n   MENU_LABEL(CONTENT_INFO_DATABASE),\n   MENU_LABEL(CONTENT_INFO_RUNTIME),\n   MENU_LABEL(CONTENT_INFO_LAST_PLAYED),\n   MENU_LABEL(CONTENT_INFO_CHEEVOS_HASH),\n\n   MENU_LABEL(NO_PLAYLIST_ENTRIES_AVAILABLE),\n\n   MENU_ENUM_LABEL_VIDEO_SHADER_DEFAULT_FILTER,\n   MENU_ENUM_LABEL_VIDEO_SHADER_FILTER_PASS,\n   MENU_ENUM_LABEL_HELP_VIDEO_SHADER_FILTER_PASS,\n   MENU_ENUM_LABEL_VIDEO_SHADER_SCALE_PASS,\n   MENU_ENUM_LABEL_HELP_VIDEO_SHADER_SCALE_PASS,\n\n   MENU_LBL_H(VIDEO_SHADER_NUM_PASSES),\n   MENU_LABEL(CHEAT_NUM_PASSES),\n\n   MENU_LABEL(NO_DISK),\n\n   MENU_ENUM_LABEL_VALUE_MD5,\n   MENU_ENUM_LABEL_VALUE_SHA1,\n   MENU_ENUM_LABEL_VALUE_CRC,\n   MENU_ENUM_LABEL_VALUE_MORE,\n\n   MENU_LABEL(VIDEO_TAB),\n   MENU_LABEL(MUSIC_TAB),\n   MENU_LABEL(IMAGES_TAB),\n   MENU_LABEL(HORIZONTAL_MENU),\n   MENU_LABEL(SETTINGS_TAB),\n   MENU_LABEL(HISTORY_TAB),\n   MENU_LABEL(FAVORITES_TAB),\n   MENU_ENUM_LABEL_EXPLORE_TAB,\n   MENU_ENUM_LABEL_EXPLORE_ITEM,\n   MENU_ENUM_LABEL_VALUE_EXPLORE_TAB,\n   MENU_LABEL(CONTENTLESS_CORES_TAB),\n   MENU_LABEL(CONTENTLESS_CORE),\n   MENU_LABEL(ADD_TAB),\n   MENU_LABEL(NETPLAY_TAB),\n   MENU_LABEL(PLAYLISTS_TAB),\n   MENU_LABEL(MAIN_MENU),\n   MENU_LABEL(INPUT_SETTINGS),\n   MENU_LABEL(INPUT_MENU_SETTINGS),\n   MENU_LABEL(INPUT_TURBO_FIRE_SETTINGS),\n   MENU_LABEL(INPUT_HAPTIC_FEEDBACK_SETTINGS),\n   MENU_LABEL(ACCESSIBILITY_SETTINGS),\n   MENU_LABEL(ACCESSIBILITY_ENABLED),\n   MENU_LABEL(ACCESSIBILITY_NARRATOR_SPEECH_SPEED),\n   MENU_LABEL(AI_SERVICE_SETTINGS),\n   MENU_LABEL(AI_SERVICE_MODE),\n   MENU_LABEL(AI_SERVICE_TARGET_LANG),\n   MENU_LABEL(AI_SERVICE_SOURCE_LANG),\n   MENU_LABEL(AI_SERVICE_URL),\n   MENU_LABEL(AI_SERVICE_ENABLE),\n   MENU_LABEL(AI_SERVICE_PAUSE),\n\n   MSG_ACCESSIBILITY_STARTUP,\n   MSG_AI_SERVICE_STOPPED,\n\n   MENU_LABEL(ON),\n   MENU_LABEL(OFF),\n   MENU_LABEL(DISABLED),\n   MENU_LABEL(ENABLED),\n   MENU_ENUM_LABEL_VALUE_TRUE,\n   MENU_ENUM_LABEL_VALUE_FALSE,\n   MENU_ENUM_LABEL_VALUE_COMP,\n   MENU_ENUM_LABEL_VALUE_MUSIC,\n   MENU_ENUM_LABEL_VALUE_IMAGE,\n   MENU_ENUM_LABEL_VALUE_MOVIE,\n   MENU_ENUM_LABEL_VALUE_CORE,\n   MENU_ENUM_LABEL_VALUE_CURSOR,\n   MENU_ENUM_LABEL_VALUE_FILE,\n   MENU_ENUM_LABEL_VALUE_MISSING_REQUIRED,\n   MENU_ENUM_LABEL_VALUE_PRESENT_OPTIONAL,\n   MENU_ENUM_LABEL_VALUE_MISSING_OPTIONAL,\n   MENU_ENUM_LABEL_VALUE_PRESENT_REQUIRED,\n   MENU_ENUM_LABEL_VALUE_RDB,\n   MENU_ENUM_LABEL_VALUE_DIR,\n   MENU_ENUM_LABEL_VALUE_NO_CORE,\n   MENU_ENUM_LABEL_VALUE_DETECT,\n   MENU_ENUM_LABEL_VALUE_GLSLP,\n   MENU_ENUM_LABEL_VALUE_CGP,\n   MENU_ENUM_LABEL_VALUE_GLSL,\n   MENU_ENUM_LABEL_VALUE_CG,\n   MENU_ENUM_LABEL_VALUE_SLANG,\n   MENU_ENUM_LABEL_VALUE_SLANGP,\n\n   MENU_ENUM_LABEL_VALUE_RETROPAD,\n   MENU_ENUM_LABEL_VALUE_RETROPAD_WITH_ANALOG,\n   MENU_ENUM_LABEL_VALUE_RETROKEYBOARD,\n\n   MENU_LABEL(SYSTEM_BGM_ENABLE),\n\n   MENU_LABEL(NETWORK_CMD_ENABLE),\n   MENU_LABEL(NETWORK_CMD_PORT),\n   MENU_LABEL(STDIN_CMD_ENABLE),\n   MENU_LABEL(NETWORK_REMOTE_ENABLE),\n   MENU_LABEL(NETWORK_REMOTE_PORT),\n   MENU_LABEL(NETWORK_ON_DEMAND_THUMBNAILS),\n\n   MENU_ENUM_LABEL_NETWORK_REMOTE_USER_1_ENABLE,\n\n   MENU_ENUM_LABEL_NETWORK_REMOTE_USER_LAST_ENABLE = MENU_ENUM_LABEL_NETWORK_REMOTE_USER_1_ENABLE + MAX_USERS,\n\n   MENU_LABEL(NETWORK_USER_REMOTE_ENABLE),\n\n   MENU_LBL_H(DUMMY_ON_CORE_SHUTDOWN),\n   MENU_LBL_H(CHECK_FOR_MISSING_FIRMWARE),\n   MENU_LABEL(CORE_INFO_SAVESTATE_BYPASS),\n   MENU_LABEL(CORE_OPTION_CATEGORY_ENABLE),\n   MENU_LABEL(CORE_INFO_CACHE_ENABLE),\n#ifndef HAVE_DYNAMIC\n   MENU_LABEL(ALWAYS_RELOAD_CORE_ON_RUN_CONTENT),\n#endif\n\n   MENU_LABEL(DETECT_CORE_LIST_OK_CURRENT_CORE),\n   MENU_LABEL(DETECT_CORE_LIST_OK),\n   MENU_LABEL(FAVORITES),\n   MENU_LABEL(START_CORE),\n   MENU_LABEL(CORE_UPDATER_LIST),\n   MENU_LABEL(CORE_MANAGER_LIST),\n#ifdef HAVE_MIST\n   /* Steam settings */\n   MENU_LABEL(STEAM_SETTINGS),\n   MENU_LABEL(STEAM_RICH_PRESENCE_ENABLE),\n   MENU_LABEL(STEAM_RICH_PRESENCE_FORMAT),\n\n   MENU_ENUM_LABEL_VALUE_STEAM_RICH_PRESENCE_FORMAT_CONTENT,\n   MENU_ENUM_LABEL_VALUE_STEAM_RICH_PRESENCE_FORMAT_CORE,\n   MENU_ENUM_LABEL_VALUE_STEAM_RICH_PRESENCE_FORMAT_SYSTEM,\n   MENU_ENUM_LABEL_VALUE_STEAM_RICH_PRESENCE_FORMAT_CONTENT_SYSTEM,\n   MENU_ENUM_LABEL_VALUE_STEAM_RICH_PRESENCE_FORMAT_CONTENT_CORE,\n   MENU_ENUM_LABEL_VALUE_STEAM_RICH_PRESENCE_FORMAT_CONTENT_SYSTEM_CORE,\n\n   /* Steam Core Manager */\n   MENU_LABEL(CORE_MANAGER_STEAM_LIST),\n   MENU_LABEL(CORE_STEAM_INSTALL),\n   MENU_LABEL(CORE_STEAM_UNINSTALL),\n   MENU_LABEL(MENU_SHOW_CORE_MANAGER_STEAM),\n   MSG_CORE_STEAM_INSTALLING,\n   MSG_CORE_STEAM_UNINSTALLED,\n   MSG_CORE_STEAM_CURRENTLY_DOWNLOADING,\n#endif\n   MENU_LABEL(CORE_UPDATER_AUTO_EXTRACT_ARCHIVE),\n   MENU_LABEL(CORE_UPDATER_SHOW_EXPERIMENTAL_CORES),\n   MENU_LABEL(CORE_UPDATER_AUTO_BACKUP),\n   MENU_LABEL(CORE_UPDATER_AUTO_BACKUP_HISTORY_SIZE),\n   MENU_LABEL(CORE_UPDATER_BUILDBOT_URL),\n   MENU_LABEL(BUILDBOT_ASSETS_URL),\n   MENU_LABEL(CORE_SET_SUPPORTS_NO_CONTENT_ENABLE),\n   MENU_LABEL(CLOSE_CONTENT),\n   MENU_LABEL(SHOW_WIMP),\n   MENU_LBL_H(QUIT_RETROARCH),\n   MENU_LABEL(RESTART_RETROARCH),\n   MENU_LABEL(SHUTDOWN),\n   MENU_LABEL(REBOOT),\n   MENU_LABEL(DISK_IMAGE_APPEND),\n\n   MENU_ENUM_SUBLABEL_DISK_IMAGE_APPEND_TRAY_OPEN,\n\n   MENU_LABEL(SUBSYSTEM_ADD),\n   MENU_LABEL(SUBSYSTEM_LOAD),\n   MENU_LBL_H(CORE_LIST),\n   MENU_LABEL(DOWNLOAD_CORE),\n   MENU_LABEL(SIDELOAD_CORE_LIST),\n   MENU_LABEL(SIDELOAD_CORE_ERROR),\n   MENU_LABEL(SIDELOAD_CORE_SUCCESS),\n   MENU_LABEL(MANAGEMENT),\n   MENU_LABEL(BT_CONNECTED),\n   MENU_LABEL(ONLINE),\n   MENU_LABEL(ONLINE_UPDATER),\n   MENU_LABEL(NETPLAY),\n   MENU_LABEL(SETTINGS),\n   MENU_LABEL(FRONTEND_COUNTERS),\n   MENU_LABEL(CORE_COUNTERS),\n   MENU_LBL_H(LOAD_CONTENT_HISTORY),\n   MENU_LABEL(LOAD_DISC),\n   MENU_LABEL(DUMP_DISC),\n#ifdef HAVE_LAKKA\n   MENU_LABEL(EJECT_DISC),\n#endif\n   MENU_LABEL(NETWORK_INFORMATION),\n   MENU_LABEL(SYSTEM_INFORMATION),\n   MENU_LABEL(ACHIEVEMENT_LIST),\n   MENU_LABEL(ACHIEVEMENT_LIST_HARDCORE),\n   MENU_LABEL(ACHIEVEMENT_PAUSE_MENU),\n   MENU_LABEL(ACHIEVEMENT_PAUSE_CANCEL),\n   MENU_LABEL(ACHIEVEMENT_RESUME_CANCEL),\n   MENU_LABEL(ACHIEVEMENT_PAUSE),\n   MENU_LABEL(ACHIEVEMENT_RESUME),\n   MENU_LABEL(ACHIEVEMENT_SERVER_UNREACHABLE),\n   MENU_LABEL(CHEEVOS_SERVER_DISCONNECTED),\n   MENU_LABEL(CHEEVOS_SERVER_RECONNECTED),\n   MENU_LABEL(CHEEVOS_IDENTIFYING_GAME),\n   MENU_LABEL(CHEEVOS_FETCHING_GAME_DATA),\n   MENU_LABEL(CHEEVOS_STARTING_SESSION),\n   MENU_LABEL(CORE_INFORMATION),\n   MENU_LABEL(DISC_INFORMATION),\n   MENU_LABEL(CORE_LOCK),\n   MENU_LABEL(CORE_SET_STANDALONE_EXEMPT),\n   MENU_LABEL(CORE_DELETE),\n\n   MSG_CORE_LOCK_FAILED,\n   MSG_CORE_UNLOCK_FAILED,\n   MSG_CORE_SET_STANDALONE_EXEMPT_FAILED,\n   MSG_CORE_UNSET_STANDALONE_EXEMPT_FAILED,\n   MSG_CORE_DELETE_DISABLED,\n\n   /* Core updater */\n   MENU_LABEL(UPDATE_INSTALLED_CORES),\n   MENU_LABEL(SWITCH_INSTALLED_CORES_PFD),\n\n   MSG_FETCHING_CORE_LIST,\n   MSG_CORE_LIST_FAILED,\n   MSG_LATEST_CORE_INSTALLED,\n   MSG_UPDATING_CORE,\n   MSG_DOWNLOADING_CORE,\n   MSG_EXTRACTING_CORE,\n   MSG_CORE_INSTALLED,\n   MSG_CORE_INSTALL_FAILED,\n   MSG_SCANNING_CORES,\n   MSG_CHECKING_CORE,\n   MSG_ALL_CORES_UPDATED,\n   MSG_ALL_CORES_SWITCHED_PFD,\n   MSG_NUM_CORES_UPDATED,\n   MSG_NUM_CORES_LOCKED,\n   MSG_CORE_UPDATE_DISABLED,\n\n   /* Core backup/restore */\n   MENU_LABEL(CORE_CREATE_BACKUP),\n   MENU_LABEL(CORE_RESTORE_BACKUP_LIST),\n   MENU_LABEL(CORE_DELETE_BACKUP_LIST),\n\n   MENU_ENUM_LABEL_CORE_RESTORE_BACKUP_ENTRY,\n   MENU_ENUM_LABEL_CORE_DELETE_BACKUP_ENTRY,\n   MENU_ENUM_LABEL_VALUE_CORE_BACKUP_MODE_AUTO,\n   MENU_ENUM_LABEL_VALUE_CORE_BACKUP_CRC,\n\n   MSG_CORE_BACKUP_SCANNING_CORE,\n   MSG_CORE_BACKUP_ALREADY_EXISTS,\n   MSG_BACKING_UP_CORE,\n   MSG_PRUNING_CORE_BACKUP_HISTORY,\n   MSG_CORE_BACKUP_COMPLETE,\n   MSG_CORE_RESTORATION_ALREADY_INSTALLED,\n   MSG_RESTORING_CORE,\n   MSG_CORE_RESTORATION_COMPLETE,\n   MSG_CORE_INSTALLATION_ALREADY_INSTALLED,\n   MSG_INSTALLING_CORE,\n   MSG_CORE_INSTALLATION_COMPLETE,\n   MSG_CORE_RESTORATION_INVALID_CONTENT,\n   MSG_CORE_BACKUP_FAILED,\n   MSG_CORE_RESTORATION_FAILED,\n   MSG_CORE_INSTALLATION_FAILED,\n   MSG_CORE_RESTORATION_DISABLED,\n   MSG_CORE_INSTALLATION_DISABLED,\n\n   MENU_LABEL(VIDEO_SHADER_PARAMETERS),\n   MENU_LABEL(VIDEO_SHADER_PRESET_PARAMETERS),\n   MENU_LABEL(DISK_OPTIONS),\n   MENU_LABEL(DISK_CYCLE_TRAY_STATUS),\n   MENU_LABEL(DISK_TRAY_EJECT),\n   MENU_LABEL(DISK_TRAY_INSERT),\n   MENU_LABEL(NO_CORE_OPTIONS_AVAILABLE),\n   MENU_LABEL(DISK_INDEX),\n   MENU_LABEL(CORE_CHEAT_OPTIONS),\n   MENU_LABEL(CORE_INPUT_REMAPPING_OPTIONS),\n   MENU_LABEL(DATABASE_MANAGER),\n   MENU_LABEL(CURSOR_MANAGER),\n\n   MENU_ENUM_LABEL_DATABASE_MANAGER_LIST,\n   MENU_ENUM_LABEL_CURSOR_MANAGER_LIST,\n   MENU_ENUM_LABEL_VALUE_SUPPORTED_CORES,\n   MENU_ENUM_LABEL_VIDEO_SHADER_PASS,\n   MENU_ENUM_LABEL_HELP_VIDEO_SHADER_PASS,\n   MENU_ENUM_LABEL_VIDEO_SHADER_PRESET_TWO,\n   MENU_ENUM_LABEL_VIDEO_SHADER_PRESET_PREPEND_TWO,\n   MENU_ENUM_LABEL_VIDEO_SHADER_PRESET_APPEND_TWO,\n\n   MENU_LBL_H(VIDEO_SHADER_PRESET),\n   MENU_LABEL(VIDEO_SHADER_PRESET_PREPEND),\n   MENU_LABEL(VIDEO_SHADER_PRESET_APPEND),\n   MENU_LABEL(CHEAT_FILE_LOAD),\n   MENU_LABEL(CHEAT_FILE_LOAD_APPEND),\n   MENU_LABEL(CHEAT_FILE_SAVE_AS),\n\n   MENU_ENUM_LABEL_MESSAGE,\n   MENU_ENUM_LABEL_INFO_SCREEN,\n\n   MENU_LABEL(CUSTOM_RATIO),\n   MENU_LABEL(HELP),\n   MENU_ENUM_LABEL_VALUE_CLEAR_SETTING,\n   MENU_ENUM_LABEL_VALUE_SCAN_ENTRY,\n   MENU_ENUM_LABEL_VALUE_MANAGE,\n   MENU_LABEL(CHEAT_DATABASE_PATH),\n   MENU_LABEL(OSK_OVERLAY_DIRECTORY),\n   MENU_LABEL(RECORDING_OUTPUT_DIRECTORY),\n   MENU_LABEL(RECORDING_CONFIG_DIRECTORY),\n   MENU_LBL_H(VIDEO_FILTER),\n   MENU_ENUM_LABEL_HELP_VIDEO_FILTER_BUILTIN,\n   MENU_LABEL(VIDEO_FILTER_REMOVE),\n   MENU_LABEL(PAL60_ENABLE),\n\n   MENU_LABEL(CONTENT_HISTORY_PATH),\n\n   MENU_LABEL(RGUI_BROWSER_DIRECTORY),\n   MENU_LABEL(CONTENT_DATABASE_DIRECTORY),\n   MENU_LABEL(PLAYLIST_DIRECTORY),\n   MENU_LABEL(CONTENT_FAVORITES_DIRECTORY),\n   MENU_LABEL(CONTENT_HISTORY_DIRECTORY),\n   MENU_LABEL(CONTENT_IMAGE_HISTORY_DIRECTORY),\n   MENU_LABEL(CONTENT_MUSIC_HISTORY_DIRECTORY),\n   MENU_LABEL(CONTENT_VIDEO_HISTORY_DIRECTORY),\n   MENU_LABEL(RUNTIME_LOG_DIRECTORY),\n   MENU_LABEL(CORE_ASSETS_DIRECTORY),\n   MENU_LABEL(SCREENSHOT_DIRECTORY),\n   MENU_LABEL(CONTENT_DIRECTORY),\n   MENU_LABEL(VIDEO_SHADER_DIR),\n   MENU_LABEL(VIDEO_FILTER_DIR),\n   MENU_LABEL(AUDIO_FILTER_DIR),\n   MENU_LABEL(LOG_DIR),\n\n   MENU_LABEL(TURBO_DEADZONE_LIST),\n   MENU_LABEL(LIBRETRO_DIR_PATH),\n   MENU_LABEL(LIBRETRO_INFO_PATH),\n   MENU_LABEL(RGUI_CONFIG_DIRECTORY),\n   MENU_LABEL(OVERLAY_DIRECTORY),\n   MENU_LABEL(VIDEO_LAYOUT_DIRECTORY),\n   MENU_LABEL(SYSTEM_DIRECTORY),\n   MENU_LABEL(ASSETS_DIRECTORY),\n   MENU_LABEL(CACHE_DIRECTORY),\n   MENU_LABEL(JOYPAD_AUTOCONFIG_DIR),\n   MENU_LABEL(DRIVER_SETTINGS),\n   MENU_LABEL(VIDEO_SETTINGS),\n   MENU_LABEL(VIDEO_WINDOWED_MODE_SETTINGS),\n   MENU_LABEL(VIDEO_FULLSCREEN_MODE_SETTINGS),\n   MENU_LABEL(VIDEO_OUTPUT_SETTINGS),\n   MENU_LABEL(VIDEO_SYNCHRONIZATION_SETTINGS),\n   MENU_LABEL(VIDEO_SCALING_SETTINGS),\n   MENU_LABEL(VIDEO_HDR_SETTINGS),\n   MENU_LABEL(CRT_SWITCHRES_SETTINGS),\n   MENU_LABEL(AUDIO_SETTINGS),\n   MENU_LABEL(AUDIO_RESAMPLER_SETTINGS), /* deprecated */\n   MENU_LABEL(AUDIO_OUTPUT_SETTINGS),\n#ifdef HAVE_MICROPHONE\n   MENU_LABEL(MICROPHONE_SETTINGS),\n#endif\n   MENU_LABEL(AUDIO_SYNCHRONIZATION_SETTINGS),\n   MENU_LABEL(AUDIO_MIXER_SETTINGS),\n   MENU_LABEL(LATENCY_SETTINGS),\n   MENU_LABEL(CORE_SETTINGS),\n   MENU_LABEL(CONFIGURATION_SETTINGS),\n   MENU_LABEL(LOGGING_SETTINGS),\n   MENU_LABEL(SAVING_SETTINGS),\n   MENU_LABEL(CLOUD_SYNC_SETTINGS),\n   MENU_LABEL(CLOUD_SYNC_ENABLE),\n   MENU_LABEL(CLOUD_SYNC_DESTRUCTIVE),\n   MENU_LABEL(CLOUD_SYNC_SYNC_SAVES),\n   MENU_LABEL(CLOUD_SYNC_SYNC_CONFIGS),\n   MENU_LABEL(CLOUD_SYNC_SYNC_THUMBS),\n   MENU_LABEL(CLOUD_SYNC_SYNC_SYSTEM),\n   MENU_LABEL(CLOUD_SYNC_DRIVER),\n   MENU_LABEL(CLOUD_SYNC_URL),\n   MENU_LABEL(CLOUD_SYNC_USERNAME),\n   MENU_LABEL(CLOUD_SYNC_PASSWORD),\n   MENU_LABEL(RECORDING_SETTINGS),\n   MENU_LABEL(OVERLAY_SETTINGS),\n   MENU_LABEL(REWIND_SETTINGS),\n   MENU_LABEL(FRAME_TIME_COUNTER_SETTINGS),\n   MENU_LABEL(FRAME_TIME_COUNTER_RESET_AFTER_FASTFORWARDING),\n   MENU_LABEL(FRAME_TIME_COUNTER_RESET_AFTER_LOAD_STATE),\n   MENU_LABEL(FRAME_TIME_COUNTER_RESET_AFTER_SAVE_STATE),\n   MENU_LABEL(CHEAT_SETTINGS),\n   MENU_LABEL(CHEAT_DETAILS_SETTINGS),\n   MENU_LABEL(CHEAT_SEARCH_SETTINGS),\n\n   /* Core option category placeholders for icons */\n   MENU_LABEL(HACKS_SETTINGS),\n   MENU_LABEL(MAPPING_SETTINGS),\n   MENU_LABEL(MEDIA_SETTINGS),\n   MENU_LABEL(PERFORMANCE_SETTINGS),\n   MENU_LABEL(SOUND_SETTINGS),\n   MENU_LABEL(SPECS_SETTINGS),\n   MENU_LABEL(STORAGE_SETTINGS),\n   MENU_LABEL(SYSTEM_SETTINGS),\n   MENU_LABEL(TIMING_SETTINGS),\n\n   MENU_ENUM_LABEL_ONSCREEN_KEYBOARD_OVERLAY_SETTINGS,\n\n   MENU_LABEL(MULTIMEDIA_SETTINGS),\n   MENU_LABEL(PLAYLIST_SETTINGS),\n   MENU_LABEL(PLAYLIST_MANAGER_LIST),\n   MENU_LABEL(PLAYLIST_MANAGER_SETTINGS),\n   MENU_LABEL(PLAYLIST_MANAGER_DEFAULT_CORE),\n   MENU_LABEL(PLAYLIST_MANAGER_RESET_CORES),\n\n   MSG_PLAYLIST_MANAGER_RESETTING_CORES,\n   MSG_PLAYLIST_MANAGER_CORES_RESET,\n\n   MENU_LABEL(PLAYLIST_MANAGER_LABEL_DISPLAY_MODE),\n\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_MANAGER_LABEL_DISPLAY_MODE_DEFAULT,\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_MANAGER_LABEL_DISPLAY_MODE_REMOVE_PARENS,\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_MANAGER_LABEL_DISPLAY_MODE_REMOVE_BRACKETS,\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_MANAGER_LABEL_DISPLAY_MODE_REMOVE_PARENS_AND_BRACKETS,\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_MANAGER_LABEL_DISPLAY_MODE_KEEP_REGION,\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_MANAGER_LABEL_DISPLAY_MODE_KEEP_DISC_INDEX,\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_MANAGER_LABEL_DISPLAY_MODE_KEEP_REGION_AND_DISC_INDEX,\n\n   MENU_LABEL(PLAYLIST_MANAGER_RIGHT_THUMBNAIL_MODE),\n   MENU_LABEL(PLAYLIST_MANAGER_LEFT_THUMBNAIL_MODE),\n\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_MANAGER_THUMBNAIL_MODE_DEFAULT,\n\n   MENU_LABEL(PLAYLIST_MANAGER_SORT_MODE),\n\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_MANAGER_SORT_MODE_DEFAULT,\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_MANAGER_SORT_MODE_ALPHABETICAL,\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_MANAGER_SORT_MODE_OFF,\n\n   MENU_LABEL(PLAYLIST_MANAGER_CLEAN_PLAYLIST),\n\n   MSG_PLAYLIST_MANAGER_CLEANING_PLAYLIST,\n   MSG_PLAYLIST_MANAGER_PLAYLIST_CLEANED,\n\n   MENU_LABEL(PLAYLIST_MANAGER_REFRESH_PLAYLIST),\n\n   MSG_PLAYLIST_MANAGER_REFRESH_MISSING_CONFIG,\n   MSG_PLAYLIST_MANAGER_REFRESH_INVALID_CONTENT_DIR,\n   MSG_PLAYLIST_MANAGER_REFRESH_INVALID_SYSTEM_NAME,\n   MSG_PLAYLIST_MANAGER_REFRESH_INVALID_CORE,\n   MSG_PLAYLIST_MANAGER_REFRESH_INVALID_DAT_FILE,\n   MSG_PLAYLIST_MANAGER_REFRESH_DAT_FILE_TOO_LARGE,\n\n   MENU_LABEL(CORE_UPDATER_SETTINGS),\n   MENU_LABEL(LAKKA_SERVICES),\n#ifdef HAVE_LAKKA_SWITCH\n   MENU_LABEL(LAKKA_SWITCH_OPTIONS),\n#endif\n   MENU_LBL_H(SHADER_APPLY_CHANGES),\n   MENU_LBL_H(SHADER_WATCH_FOR_CHANGES),\n   MENU_LABEL(VIDEO_SHADER_REMEMBER_LAST_DIR),\n   MENU_LABEL(SAVE_NEW_CONFIG),\n   MENU_LABEL(ONSCREEN_DISPLAY_SETTINGS),\n   MENU_LABEL(ONSCREEN_OVERLAY_SETTINGS),\n   MENU_LABEL(OVERLAY_LIGHTGUN_SETTINGS),\n   MENU_LABEL(OVERLAY_MOUSE_SETTINGS),\n   MENU_LABEL(OSK_OVERLAY_SETTINGS),\n   MENU_LABEL(ONSCREEN_VIDEO_LAYOUT_SETTINGS),\n   MENU_LABEL(ONSCREEN_NOTIFICATIONS_SETTINGS),\n   MENU_LABEL(ONSCREEN_NOTIFICATIONS_VIEWS_SETTINGS),\n   MENU_LABEL(CHEAT_APPLY_CHANGES),\n   MENU_LABEL(CHEAT_START_SEARCH),\n   MENU_LABEL(CHEAT_CONTINUE_SEARCH),\n   MENU_LABEL(CHEAT_VIEW_MATCHES),\n\n   MENU_ENUM_LABEL_COLLECTION,\n   MENU_LABEL(CONFIGURATIONS),\n   MENU_LABEL(BROWSE_URL_LIST),\n\n   MENU_ENUM_LABEL_CUSTOM_BIND,\n\n   MENU_ENUM_LABEL_CUSTOM_BIND_ALL,\n\n   MENU_ENUM_LABEL_CUSTOM_BIND_DEFAULTS,\n   MENU_ENUM_LABEL_EXIT_EMULATOR,\n   MENU_ENUM_LABEL_OSK_ENABLE,\n\n   MENU_ENUM_LABEL_VALUE_REMAP_FILE,\n   MENU_LABEL(REMAP_FILE_MANAGER_LIST),\n   MENU_LABEL(REMAP_FILE_INFO),\n   MENU_LABEL(REMAP_FILE_LOAD),\n   MENU_LABEL(REMAP_FILE_SAVE_AS),\n   MENU_LABEL(REMAP_FILE_SAVE_CORE),\n   MENU_LABEL(REMAP_FILE_SAVE_CONTENT_DIR),\n   MENU_LABEL(REMAP_FILE_SAVE_GAME),\n   MENU_LABEL(REMAP_FILE_REMOVE_CORE),\n   MENU_LABEL(REMAP_FILE_REMOVE_CONTENT_DIR),\n   MENU_LABEL(REMAP_FILE_REMOVE_GAME),\n   MENU_LABEL(REMAP_FILE_RESET),\n   MENU_LABEL(REMAP_FILE_FLUSH),\n\n   MENU_LABEL(OVERRIDE_FILE_INFO),\n   MENU_LABEL(OVERRIDE_FILE_LOAD),\n   MENU_LABEL(OVERRIDE_FILE_SAVE_AS),\n   MENU_LABEL(OVERRIDE_UNLOAD),\n\n   MENU_LABEL(RESTART_CONTENT),\n   MENU_LABEL(RESUME),\n   MENU_LABEL(RESUME_CONTENT),\n\n   MENU_LABEL(DELETE_ENTRY),\n   MENU_LABEL(RENAME_ENTRY),\n\n   MENU_LABEL(TAKE_SCREENSHOT),\n\n   MENU_ENUM_LABEL_VALUE_UNABLE_TO_READ_COMPRESSED_FILE,\n\n   MENU_LABEL(VIDEO_SHADER_PRESET_REMOVE),\n   MENU_LABEL(VIDEO_SHADER_PRESET_REMOVE_GLOBAL),\n   MENU_LABEL(VIDEO_SHADER_PRESET_REMOVE_CORE),\n   MENU_LABEL(VIDEO_SHADER_PRESET_REMOVE_PARENT),\n   MENU_LABEL(VIDEO_SHADER_PRESET_REMOVE_GAME),\n   MENU_LABEL(VIDEO_SHADER_PRESET_SAVE),\n   MENU_LABEL(VIDEO_SHADER_PRESET_SAVE_REFERENCE),\n   MENU_LABEL(VIDEO_SHADER_PRESET_SAVE_AS),\n   MENU_LABEL(VIDEO_SHADER_PRESET_SAVE_GLOBAL),\n   MENU_LABEL(VIDEO_SHADER_PRESET_SAVE_CORE),\n   MENU_LABEL(VIDEO_SHADER_PRESET_SAVE_PARENT),\n   MENU_LABEL(VIDEO_SHADER_PRESET_SAVE_GAME),\n   MENU_LBL_H(USER_LANGUAGE),\n   MENU_LABEL(NETPLAY_NICKNAME),\n   MENU_LABEL(VIDEO_VI_WIDTH),\n   MENU_LABEL(VIDEO_OVERSCAN_CORRECTION_TOP),\n   MENU_LABEL(VIDEO_OVERSCAN_CORRECTION_BOTTOM),\n   MENU_LABEL(VIDEO_ASPECT_RATIO),\n   MENU_LABEL(VIDEO_VIEWPORT_BIAS_X),\n   MENU_LABEL(VIDEO_VIEWPORT_BIAS_Y),\n#if defined(RARCH_MOBILE)\n   MENU_LABEL(VIDEO_VIEWPORT_BIAS_PORTRAIT_X),\n   MENU_LABEL(VIDEO_VIEWPORT_BIAS_PORTRAIT_Y),\n#endif\n   MENU_LABEL(VIDEO_FORCE_ASPECT),\n   MENU_LABEL(VIDEO_ASPECT_RATIO_AUTO),\n   MENU_LABEL(VIDEO_ASPECT_RATIO_INDEX),\n   MENU_ENUM_LABEL_VALUE_VIDEO_ASPECT_RATIO_CONFIG,\n   MENU_ENUM_LABEL_VALUE_VIDEO_ASPECT_RATIO_SQUARE_PIXEL,\n   MENU_ENUM_LABEL_VALUE_VIDEO_ASPECT_RATIO_CORE_PROVIDED,\n   MENU_ENUM_LABEL_VALUE_VIDEO_ASPECT_RATIO_CUSTOM,\n   MENU_ENUM_LABEL_VALUE_VIDEO_ASPECT_RATIO_FULL,\n#if defined(DINGUX)\n   MENU_LABEL(VIDEO_DINGUX_IPU_KEEP_ASPECT),\n   MENU_LABEL(VIDEO_DINGUX_IPU_FILTER_TYPE),\n\n   MENU_ENUM_LABEL_VALUE_VIDEO_DINGUX_IPU_FILTER_BICUBIC,\n   MENU_ENUM_LABEL_VALUE_VIDEO_DINGUX_IPU_FILTER_BILINEAR,\n   MENU_ENUM_LABEL_VALUE_VIDEO_DINGUX_IPU_FILTER_NEAREST,\n#if defined(DINGUX_BETA)\n   MENU_LABEL(VIDEO_DINGUX_REFRESH_RATE),\n\n   MENU_ENUM_LABEL_VALUE_VIDEO_DINGUX_REFRESH_RATE_60HZ,\n   MENU_ENUM_LABEL_VALUE_VIDEO_DINGUX_REFRESH_RATE_50HZ,\n#endif\n#if defined(RS90) || defined(MIYOO)\n   MENU_LABEL(VIDEO_DINGUX_RS90_SOFTFILTER_TYPE),\n\n   MENU_ENUM_LABEL_VALUE_VIDEO_DINGUX_RS90_SOFTFILTER_POINT,\n   MENU_ENUM_LABEL_VALUE_VIDEO_DINGUX_RS90_SOFTFILTER_BRESENHAM_HORZ,\n#endif\n#endif\n   MENU_LABEL(VIDEO_VFILTER),\n   MENU_LABEL(VIDEO_GPU_RECORD),\n   MENU_LABEL(RECORD_USE_OUTPUT_DIRECTORY),\n   MENU_LABEL(RECORD_CONFIG),\n   MENU_LABEL(STREAM_CONFIG),\n   MENU_LABEL(RECORD_PATH),\n   MENU_LABEL(VIDEO_POST_FILTER_RECORD),\n   MENU_LABEL(RECORD_ENABLE),\n\n   MENU_LABEL(SECONDS),\n   MENU_LABEL(STATUS),\n\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_CORE_NAME,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_CORE_LABEL,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_CORE_VERSION,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_SYSTEM_NAME,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_SYSTEM_MANUFACTURER,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_CATEGORIES,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_AUTHORS,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_PERMISSIONS,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_LICENSES,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_SUPPORTED_EXTENSIONS,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_FIRMWARE,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_FIRMWARE_IN_CONTENT_DIRECTORY,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_FIRMWARE_PATH,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_REQUIRED_HW_API,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_CORE_PATH,\n\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_SAVESTATE_SUPPORT_LEVEL,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_SAVESTATE_DISABLED,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_SAVESTATE_BASIC,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_SAVESTATE_SERIALIZED,\n   MENU_ENUM_LABEL_VALUE_CORE_INFO_SAVESTATE_DETERMINISTIC,\n\n   /* System information */\n\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_LAKKA_VERSION,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_DYNAMIC_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_BUILD_DATE,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_RETROARCH_VERSION,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_GIT_VERSION,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_CPU_MODEL,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_CPU_FEATURES,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_FRONTEND_IDENTIFIER,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_FRONTEND_NAME,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_FRONTEND_OS,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_RETRORATING_LEVEL,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_POWER_SOURCE,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_POWER_SOURCE_NO_SOURCE,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_POWER_SOURCE_CHARGING,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_POWER_SOURCE_CHARGED,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_POWER_SOURCE_DISCHARGING,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_VIDEO_CONTEXT_DRIVER,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_DISPLAY_METRIC_MM_WIDTH,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_DISPLAY_METRIC_MM_HEIGHT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_DISPLAY_METRIC_DPI,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_LIBRETRODB_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_OVERLAY_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_COMMAND_IFACE_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_NETWORK_COMMAND_IFACE_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_NETWORK_REMOTE_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_COCOA_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_RTGA_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_RBMP_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_RJPEG_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_RPNG_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_SDL_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_SDL2_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_GDI_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_D3D8_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_D3D9_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_D3D10_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_D3D11_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_D3D12_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_VULKAN_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_METAL_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_OPENGL_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_OPENGLES_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_THREADING_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_KMS_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_UDEV_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_OPENVG_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_EGL_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_X11_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_WAYLAND_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_XVIDEO_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_ALSA_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_OSS_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_OPENAL_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_COREAUDIO_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_COREAUDIO3_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_OPENSL_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_RSOUND_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_ROARAUDIO_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_JACK_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_PULSEAUDIO_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_PIPEWIRE_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_DSOUND_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_WASAPI_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_XAUDIO2_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_ZLIB_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_7ZIP_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_DYLIB_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_CG_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_GLSL_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_SLANG_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_HLSL_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_SDL_IMAGE_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_FBO_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_FFMPEG_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_MPV_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_CORETEXT_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_FREETYPE_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_STB_TRUETYPE_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_NETPLAY_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_V4L2_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_SSL_SUPPORT,\n   MENU_ENUM_LABEL_VALUE_SYSTEM_INFO_LIBUSB_SUPPORT,\n\n   MENU_ENUM_LABEL_VALUE_CORE_ASSETS_DIR,\n\n   MENU_LABEL(CONTENT_DIR),\n   MENU_LABEL(DATABASE_SELECTION),\n   MENU_LABEL(DATABASE_CURSOR_LIST),\n   MENU_LABEL(DATABASE_CURSOR_LIST_ENTRY_DEVELOPER),\n   MENU_LABEL(DATABASE_CURSOR_LIST_ENTRY_PUBLISHER),\n   MENU_LABEL(DATABASE_CURSOR_LIST_ENTRY_ORIGIN),\n   MENU_LABEL(DATABASE_CURSOR_LIST_ENTRY_FRANCHISE),\n   MENU_LABEL(DATABASE_CURSOR_LIST_ENTRY_ESRB_RATING),\n   MENU_LABEL(DATABASE_CURSOR_LIST_ENTRY_ELSPA_RATING),\n   MENU_LABEL(DATABASE_CURSOR_LIST_ENTRY_PEGI_RATING),\n   MENU_LABEL(DATABASE_CURSOR_LIST_ENTRY_CERO_RATING),\n   MENU_LABEL(DATABASE_CURSOR_LIST_ENTRY_BBFC_RATING),\n   MENU_LABEL(DATABASE_CURSOR_LIST_ENTRY_MAX_USERS),\n   MENU_LABEL(DATABASE_CURSOR_LIST_ENTRY_EDGE_MAGAZINE_ISSUE),\n   MENU_LABEL(DATABASE_CURSOR_LIST_ENTRY_EDGE_MAGAZINE_RATING),\n   MENU_LABEL(DATABASE_CURSOR_LIST_ENTRY_RELEASEDATE_BY_MONTH),\n   MENU_LABEL(DATABASE_CURSOR_LIST_ENTRY_RELEASEDATE_BY_YEAR),\n   MENU_LABEL(DATABASE_CURSOR_LIST_ENTRY_DATABASE_INFO),\n\n   MENU_ENUM_LABEL_VALUE_NO,\n   MENU_ENUM_LABEL_VALUE_YES,\n\n   MENU_ENUM_LABEL_VALUE_PORT,\n   MENU_ENUM_LABEL_VALUE_PORT_DEVICE_NAME,\n   MENU_ENUM_LABEL_VALUE_PORT_DEVICE_INFO,\n\n   MENU_ENUM_LABEL_VALUE_LEFT_ANALOG,\n   MENU_ENUM_LABEL_VALUE_RIGHT_ANALOG,\n   MENU_ENUM_LABEL_VALUE_LEFT_ANALOG_FORCED,\n   MENU_ENUM_LABEL_VALUE_RIGHT_ANALOG_FORCED,\n\n   MENU_ENUM_LABEL_VALUE_LANG_ENGLISH,\n   MENU_ENUM_LABEL_VALUE_LANG_JAPANESE,\n   MENU_ENUM_LABEL_VALUE_LANG_FRENCH,\n   MENU_ENUM_LABEL_VALUE_LANG_SPANISH,\n   MENU_ENUM_LABEL_VALUE_LANG_GERMAN,\n   MENU_ENUM_LABEL_VALUE_LANG_ITALIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_DUTCH,\n   MENU_ENUM_LABEL_VALUE_LANG_PORTUGUESE_BRAZIL,\n   MENU_ENUM_LABEL_VALUE_LANG_PORTUGUESE_PORTUGAL,\n   MENU_ENUM_LABEL_VALUE_LANG_RUSSIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_KOREAN,\n   MENU_ENUM_LABEL_VALUE_LANG_CHINESE_TRADITIONAL,\n   MENU_ENUM_LABEL_VALUE_LANG_CHINESE_SIMPLIFIED,\n   MENU_ENUM_LABEL_VALUE_LANG_ESPERANTO,\n   MENU_ENUM_LABEL_VALUE_LANG_POLISH,\n   MENU_ENUM_LABEL_VALUE_LANG_VIETNAMESE,\n   MENU_ENUM_LABEL_VALUE_LANG_ARABIC,\n   MENU_ENUM_LABEL_VALUE_LANG_GREEK,\n   MENU_ENUM_LABEL_VALUE_LANG_TURKISH,\n\n   MENU_ENUM_LABEL_VALUE_LANG_ASTURIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_BRITISH_ENGLISH,\n   MENU_ENUM_LABEL_VALUE_LANG_CZECH,\n   MENU_ENUM_LABEL_VALUE_LANG_DANISH,\n   MENU_ENUM_LABEL_VALUE_LANG_SWEDISH,\n   MENU_ENUM_LABEL_VALUE_LANG_CROATIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_CATALAN,\n   MENU_ENUM_LABEL_VALUE_LANG_BULGARIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_BENGALI,\n   MENU_ENUM_LABEL_VALUE_LANG_BASQUE,\n   MENU_ENUM_LABEL_VALUE_LANG_AZERBAIJANI,\n   MENU_ENUM_LABEL_VALUE_LANG_ALBANIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_AFRIKAANS,\n   MENU_ENUM_LABEL_VALUE_LANG_ESTONIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_FILIPINO,\n   MENU_ENUM_LABEL_VALUE_LANG_FINNISH,\n   MENU_ENUM_LABEL_VALUE_LANG_GALICIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_GEORGIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_GUJARATI,\n   MENU_ENUM_LABEL_VALUE_LANG_HAITIAN_CREOLE,\n   MENU_ENUM_LABEL_VALUE_LANG_HEBREW,\n   MENU_ENUM_LABEL_VALUE_LANG_HINDI,\n   MENU_ENUM_LABEL_VALUE_LANG_HUNGARIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_ICELANDIC,\n   MENU_ENUM_LABEL_VALUE_LANG_INDONESIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_IRISH,\n   MENU_ENUM_LABEL_VALUE_LANG_KANNADA,\n   MENU_ENUM_LABEL_VALUE_LANG_LATIN,\n   MENU_ENUM_LABEL_VALUE_LANG_LATVIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_LITHUANIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_MACEDONIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_MALAY,\n   MENU_ENUM_LABEL_VALUE_LANG_MALTESE,\n   MENU_ENUM_LABEL_VALUE_LANG_NORWEGIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_PERSIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_ROMANIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_SERBIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_SLOVAK,\n   MENU_ENUM_LABEL_VALUE_LANG_SLOVENIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_SWAHILI,\n   MENU_ENUM_LABEL_VALUE_LANG_TAMIL,\n   MENU_ENUM_LABEL_VALUE_LANG_TELUGU,\n   MENU_ENUM_LABEL_VALUE_LANG_THAI,\n   MENU_ENUM_LABEL_VALUE_LANG_UKRAINIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_BELARUSIAN,\n   MENU_ENUM_LABEL_VALUE_LANG_URDU,\n   MENU_ENUM_LABEL_VALUE_LANG_CATALAN_VALENCIA,\n   MENU_ENUM_LABEL_VALUE_LANG_WELSH,\n   MENU_ENUM_LABEL_VALUE_LANG_YIDDISH,\n   /* Entries beginning with MENU_ENUM_LABEL_VALUE_LANG will not be uploaded to Crowdin. */\n   MENU_ENUM_LABEL_VALUE_LNG_COMPLETION_95_PLUS,\n   MENU_ENUM_LABEL_VALUE_LNG_COMPLETION_75_PLUS,\n   MENU_ENUM_LABEL_VALUE_LNG_COMPLETION_50_PLUS,\n   MENU_ENUM_LABEL_VALUE_LNG_COMPLETION_25_PLUS,\n   MENU_ENUM_LABEL_VALUE_LNG_COMPLETION_25_MINUS,\n   MENU_ENUM_LABEL_VALUE_AI_SERVICE_IMAGE_MODE,\n   MENU_ENUM_LABEL_VALUE_AI_SERVICE_SPEECH_MODE,\n   MENU_ENUM_LABEL_VALUE_AI_SERVICE_NARRATOR_MODE,\n   MENU_ENUM_LABEL_VALUE_NONE,\n   MENU_ENUM_LABEL_VALUE_NO_INFORMATION_AVAILABLE,\n\n   MENU_LABEL(USE_BUILTIN_IMAGE_VIEWER),\n   MENU_LABEL(OVERLAY_AUTOLOAD_PREFERRED),\n   MENU_LABEL(LOAD_ARCHIVE),\n   MENU_LABEL(OPEN_ARCHIVE),\n   MENU_ENUM_LABEL_LOAD_ARCHIVE_DETECT_CORE,\n   MENU_ENUM_LABEL_OPEN_ARCHIVE_DETECT_CORE,\n\n   MENU_ENUM_LABEL_VALUE_WHAT_IS_A_CORE_DESC,\n\n   MENU_LABEL(HELP_CHANGE_VIRTUAL_GAMEPAD),\n   MENU_LABEL(HELP_CHANGE_VIRTUAL_GAMEPAD_DESC),\n\n   MENU_LABEL(HELP_AUDIO_VIDEO_TROUBLESHOOTING),\n\n   MENU_ENUM_LABEL_VALUE_HELP_AUDIO_VIDEO_TROUBLESHOOTING_DESC,\n\n   MENU_LABEL(HELP_SCANNING_CONTENT),\n\n   MENU_ENUM_LABEL_VALUE_HELP_SCANNING_CONTENT_DESC,\n\n   MENU_LABEL(RESET_TO_DEFAULT_CONFIG),\n   MENU_LABEL(SAVE_CURRENT_CONFIG),\n   MENU_LABEL(SAVE_CURRENT_CONFIG_OVERRIDE_CORE),\n   MENU_LABEL(SAVE_CURRENT_CONFIG_OVERRIDE_CONTENT_DIR),\n   MENU_LABEL(SAVE_CURRENT_CONFIG_OVERRIDE_GAME),\n   MENU_LABEL(REMOVE_CURRENT_CONFIG_OVERRIDE_CORE),\n   MENU_LABEL(REMOVE_CURRENT_CONFIG_OVERRIDE_CONTENT_DIR),\n   MENU_LABEL(REMOVE_CURRENT_CONFIG_OVERRIDE_GAME),\n\n   MENU_ENUM_LABEL_VALUE_THUMBNAIL_MODE_BOXARTS,\n   MENU_ENUM_LABEL_VALUE_THUMBNAIL_MODE_SCREENSHOTS,\n   MENU_ENUM_LABEL_VALUE_THUMBNAIL_MODE_TITLE_SCREENS,\n   MENU_ENUM_LABEL_VALUE_THUMBNAIL_MODE_LOGOS,\n\n   MENU_ENUM_LABEL_VALUE_RGUI_THUMB_SCALE_POINT,\n   MENU_ENUM_LABEL_VALUE_RGUI_THUMB_SCALE_BILINEAR,\n   MENU_ENUM_LABEL_VALUE_RGUI_THUMB_SCALE_SINC,\n\n   MENU_ENUM_LABEL_VALUE_RGUI_UPSCALE_NONE,\n   MENU_ENUM_LABEL_VALUE_RGUI_UPSCALE_AUTO,\n   MENU_ENUM_LABEL_VALUE_RGUI_UPSCALE_X2,\n   MENU_ENUM_LABEL_VALUE_RGUI_UPSCALE_X3,\n   MENU_ENUM_LABEL_VALUE_RGUI_UPSCALE_X4,\n   MENU_ENUM_LABEL_VALUE_RGUI_UPSCALE_X5,\n   MENU_ENUM_LABEL_VALUE_RGUI_UPSCALE_X6,\n   MENU_ENUM_LABEL_VALUE_RGUI_UPSCALE_X7,\n   MENU_ENUM_LABEL_VALUE_RGUI_UPSCALE_X8,\n   MENU_ENUM_LABEL_VALUE_RGUI_UPSCALE_X9,\n\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_4_3,\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_16_9,\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_16_9_CENTRE,\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_16_10,\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_16_10_CENTRE,\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_21_9,\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_21_9_CENTRE,\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_3_2,\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_3_2_CENTRE,\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_5_3,\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_5_3_CENTRE,\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_AUTO,\n\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_LOCK_NONE,\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_LOCK_FIT_SCREEN,\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_LOCK_INTEGER,\n   MENU_ENUM_LABEL_VALUE_RGUI_ASPECT_RATIO_LOCK_FILL_SCREEN,\n\n   MENU_ENUM_LABEL_VALUE_RGUI_PARTICLE_EFFECT_NONE,\n   MENU_ENUM_LABEL_VALUE_RGUI_PARTICLE_EFFECT_SNOW,\n   MENU_ENUM_LABEL_VALUE_RGUI_PARTICLE_EFFECT_SNOW_ALT,\n   MENU_ENUM_LABEL_VALUE_RGUI_PARTICLE_EFFECT_RAIN,\n   MENU_ENUM_LABEL_VALUE_RGUI_PARTICLE_EFFECT_VORTEX,\n   MENU_ENUM_LABEL_VALUE_RGUI_PARTICLE_EFFECT_STARFIELD,\n\n   /* Callback strings */\n   MENU_ENUM_LABEL_CB_CORE_CONTENT_DIRS_LIST,\n   MENU_ENUM_LABEL_CB_CORE_CONTENT_DOWNLOAD,\n   MENU_ENUM_LABEL_CB_CORE_CONTENT_LIST,\n   MENU_ENUM_LABEL_CB_CORE_SYSTEM_FILES_DOWNLOAD,\n   MENU_ENUM_LABEL_CB_CORE_SYSTEM_FILES_LIST,\n   MENU_ENUM_LABEL_CB_CORE_THUMBNAILS_DOWNLOAD,\n   MENU_ENUM_LABEL_CB_CORE_UPDATER_DOWNLOAD,\n   MENU_ENUM_LABEL_CB_CORE_UPDATER_LIST,\n   MENU_ENUM_LABEL_CB_DOWNLOAD_URL,\n   MENU_ENUM_LABEL_CB_LAKKA_DOWNLOAD,\n   MENU_ENUM_LABEL_CB_LAKKA_LIST,\n   MENU_ENUM_LABEL_CB_MENU_THUMBNAIL,\n   MENU_ENUM_LABEL_CB_MENU_LEFT_THUMBNAIL,\n   MENU_ENUM_LABEL_CB_MENU_SAVESTATE_THUMBNAIL,\n   MENU_ENUM_LABEL_CB_MENU_WALLPAPER,\n   MENU_ENUM_LABEL_CB_PL_THUMBNAILS_DOWNLOAD,\n#if 0\n/* Thumbnailpack removal */\n   MENU_ENUM_LABEL_CB_THUMBNAILS_UPDATER_DOWNLOAD,\n   MENU_ENUM_LABEL_CB_THUMBNAILS_UPDATER_LIST,\n#endif\n   MENU_ENUM_LABEL_CB_UPDATE_ASSETS,\n   MENU_ENUM_LABEL_CB_UPDATE_AUTOCONFIG_PROFILES,\n   MENU_ENUM_LABEL_CB_UPDATE_CHEATS,\n   MENU_ENUM_LABEL_CB_UPDATE_CORE_INFO_FILES,\n   MENU_ENUM_LABEL_CB_UPDATE_DATABASES,\n   MENU_ENUM_LABEL_CB_UPDATE_OVERLAYS,\n   MENU_ENUM_LABEL_CB_UPDATE_SHADERS_CG,\n   MENU_ENUM_LABEL_CB_UPDATE_SHADERS_GLSL,\n   MENU_ENUM_LABEL_CB_UPDATE_SHADERS_SLANG,\n   MENU_ENUM_LABEL_CB_DISCORD_AVATAR,\n   MENU_ENUM_LABEL_CB_SINGLE_THUMBNAIL,\n\n   /* Sublabels */\n   MENU_LABEL(MIXER_ACTION_PLAY),\n   MENU_LABEL(MIXER_ACTION_PLAY_LOOPED),\n   MENU_LABEL(MIXER_ACTION_PLAY_SEQUENTIAL),\n   MENU_LABEL(MIXER_ACTION_STOP),\n   MENU_LABEL(MIXER_ACTION_REMOVE),\n   MENU_LABEL(MIXER_ACTION_VOLUME),\n   MENU_ENUM_SUBLABEL_INFORMATION_LIST_LIST,\n#ifdef HAVE_LAKKA\n   MENU_ENUM_SUBLABEL_SERVICES_SETTINGS,\n#endif\n\n   MENU_LABEL(MENU_WIDGETS_ENABLE),\n   MENU_LABEL(MENU_SHOW_LOAD_CONTENT_ANIMATION),\n\n   MENU_LABEL(NOTIFICATION_SHOW_AUTOCONFIG),\n   MENU_LABEL(NOTIFICATION_SHOW_CHEATS_APPLIED),\n   MENU_LABEL(NOTIFICATION_SHOW_PATCH_APPLIED),\n   MENU_LABEL(NOTIFICATION_SHOW_REMAP_LOAD),\n   MENU_LABEL(NOTIFICATION_SHOW_CONFIG_OVERRIDE_LOAD),\n   MENU_LABEL(NOTIFICATION_SHOW_SET_INITIAL_DISK),\n   MENU_LABEL(NOTIFICATION_SHOW_DISK_CONTROL),\n   MENU_LABEL(NOTIFICATION_SHOW_SAVE_STATE),\n   MENU_LABEL(NOTIFICATION_SHOW_FAST_FORWARD),\n   MENU_LABEL(NOTIFICATION_SHOW_SCREENSHOT),\n   MENU_LABEL(NOTIFICATION_SHOW_SCREENSHOT_DURATION),\n   MENU_LABEL(NOTIFICATION_SHOW_SCREENSHOT_FLASH),\n\n   MENU_ENUM_LABEL_VALUE_NOTIFICATION_SHOW_SCREENSHOT_DURATION_NORMAL,\n   MENU_ENUM_LABEL_VALUE_NOTIFICATION_SHOW_SCREENSHOT_DURATION_FAST,\n   MENU_ENUM_LABEL_VALUE_NOTIFICATION_SHOW_SCREENSHOT_DURATION_VERY_FAST,\n   MENU_ENUM_LABEL_VALUE_NOTIFICATION_SHOW_SCREENSHOT_DURATION_INSTANT,\n\n   MENU_ENUM_LABEL_VALUE_NOTIFICATION_SHOW_SCREENSHOT_FLASH_NORMAL,\n   MENU_ENUM_LABEL_VALUE_NOTIFICATION_SHOW_SCREENSHOT_FLASH_FAST,\n\n   MENU_LABEL(NOTIFICATION_SHOW_REFRESH_RATE),\n   MENU_LABEL(NOTIFICATION_SHOW_NETPLAY_EXTRA),\n   MENU_LABEL(NOTIFICATION_SHOW_WHEN_MENU_IS_ALIVE),\n\n   MENU_LABEL(SELECT_FILE),\n   MENU_LABEL(SELECT_FROM_PLAYLIST),\n\n   MENU_ENUM_LABEL_VALUE_FILTER,\n   MENU_ENUM_LABEL_VALUE_SCALE,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_START_WHEN_LOADED,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_LOAD_CONTENT_MANUALLY,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_COMPAT_CONTENT_LOOK,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_COMPAT_CONTENT_NO_CORE,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_COMPAT_CONTENT_NO_PLAYLISTS,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_COMPAT_CONTENT_FOUND,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_COMPAT_CONTENT_NOT_FOUND,\n\n   MENU_LABEL(NETPLAY_USE_MITM_SERVER),\n   MENU_LABEL(NETPLAY_MITM_SERVER),\n   MENU_ENUM_LABEL_NETPLAY_MITM_SERVER_LOCATION,\n   MENU_LABEL(NETPLAY_CUSTOM_MITM_SERVER),\n   MENU_ENUM_LABEL_VALUE_NETPLAY_MITM_SERVER_LOCATION_1,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_MITM_SERVER_LOCATION_2,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_MITM_SERVER_LOCATION_3,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_MITM_SERVER_LOCATION_4,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_MITM_SERVER_LOCATION_5,\n   MENU_ENUM_LABEL_VALUE_NETPLAY_MITM_SERVER_LOCATION_CUSTOM,\n   MENU_LABEL(VIDEO_WINDOW_SHOW_DECORATIONS),\n   MENU_LABEL(VIDEO_WINDOW_SAVE_POSITION),\n   MENU_LABEL(VIDEO_WINDOW_CUSTOM_SIZE_ENABLE),\n\n   MENU_ENUM_LABEL_VALUE_QT_INFO,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_FILE,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_FILE_LOAD_CORE,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_FILE_UNLOAD_CORE,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_FILE_EXIT,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_EDIT,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_EDIT_SEARCH,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_SEARCH_CLEAR,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_CLOSED_DOCKS,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_SHADER_PARAMS,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_SAVE_DOCK_POSITIONS,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_SAVE_GEOMETRY,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_SAVE_LAST_TAB,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_THEME,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_THEME_SYSTEM_DEFAULT,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_THEME_DARK,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_THEME_CUSTOM,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_TITLE,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_HIGHLIGHT_COLOR,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_SUGGEST_LOADED_CORE_FIRST,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_SHOW_HIDDEN_FILES,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_ALL_PLAYLISTS_LIST_MAX_COUNT,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_ALL_PLAYLISTS_GRID_MAX_COUNT,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_STARTUP_PLAYLIST,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_THUMBNAIL_TYPE,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_THUMBNAIL_CACHE_LIMIT,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_VIEW_OPTIONS_THUMBNAIL_DROP_SIZE_LIMIT,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_TOOLS,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_HELP,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_DOCK_CONTENT_BROWSER,\n   MENU_ENUM_LABEL_VALUE_QT_THUMBNAIL_BOXART,\n   MENU_ENUM_LABEL_VALUE_QT_THUMBNAIL_SCREENSHOT,\n   MENU_ENUM_LABEL_VALUE_QT_THUMBNAIL_TITLE_SCREEN,\n   MENU_ENUM_LABEL_VALUE_QT_THUMBNAIL_LOGO,\n   MENU_ENUM_LABEL_VALUE_QT_LOAD_CORE,\n   MENU_ENUM_LABEL_VALUE_QT_LOAD_CUSTOM_CORE,\n   MENU_ENUM_LABEL_VALUE_QT_LOADING_CORE,\n   MENU_ENUM_LABEL_VALUE_QT_NAME,\n   MENU_ENUM_LABEL_VALUE_QT_CORE_VERSION,\n   MENU_ENUM_LABEL_VALUE_QT_TAB_PLAYLISTS,\n   MENU_ENUM_LABEL_VALUE_QT_TAB_FILE_BROWSER,\n   MENU_ENUM_LABEL_VALUE_QT_TAB_FILE_BROWSER_TOP,\n   MENU_ENUM_LABEL_VALUE_QT_TAB_FILE_BROWSER_UP,\n   MENU_ENUM_LABEL_VALUE_QT_ALL_PLAYLISTS,\n   MENU_ENUM_LABEL_VALUE_QT_CORE,\n   MENU_ENUM_LABEL_VALUE_QT_CORE_INFO,\n   MENU_ENUM_LABEL_VALUE_QT_CORE_SELECTION_ASK,\n   MENU_ENUM_LABEL_VALUE_QT_INFORMATION,\n   MENU_ENUM_LABEL_VALUE_QT_WARNING,\n   MENU_ENUM_LABEL_VALUE_QT_ERROR,\n   MENU_ENUM_LABEL_VALUE_QT_RESTART_TO_TAKE_EFFECT,\n   MENU_ENUM_LABEL_VALUE_QT_LOG,\n   MENU_ENUM_LABEL_VALUE_QT_SCAN_FINISHED,\n   MENU_ENUM_LABEL_VALUE_QT_DONT_SHOW_AGAIN,\n   MENU_ENUM_LABEL_VALUE_QT_STOP,\n   MENU_ENUM_LABEL_VALUE_QT_ASSOCIATE_CORE,\n   MENU_ENUM_LABEL_VALUE_QT_HIDDEN_PLAYLISTS,\n   MENU_ENUM_LABEL_VALUE_QT_HIDE,\n   MENU_ENUM_LABEL_VALUE_QT_CHOOSE,\n   MENU_ENUM_LABEL_VALUE_QT_SELECT_COLOR,\n   MENU_ENUM_LABEL_VALUE_QT_SELECT_THEME,\n   MENU_ENUM_LABEL_VALUE_QT_CUSTOM_THEME,\n   MENU_ENUM_LABEL_VALUE_QT_FILE_PATH_IS_BLANK,\n   MENU_ENUM_LABEL_VALUE_QT_FILE_IS_EMPTY,\n   MENU_ENUM_LABEL_VALUE_QT_FILE_READ_OPEN_FAILED,\n   MENU_ENUM_LABEL_VALUE_QT_FILE_WRITE_OPEN_FAILED,\n   MENU_ENUM_LABEL_VALUE_QT_FILE_DOES_NOT_EXIST,\n   MENU_ENUM_LABEL_VALUE_QT_ZOOM,\n   MENU_ENUM_LABEL_VALUE_QT_VIEW,\n   MENU_ENUM_LABEL_VALUE_QT_VIEW_TYPE_ICONS,\n   MENU_ENUM_LABEL_VALUE_QT_VIEW_TYPE_LIST,\n   MENU_ENUM_LABEL_VALUE_QT_PROGRESS,\n   MENU_ENUM_LABEL_VALUE_QT_NEW_PLAYLIST,\n   MENU_ENUM_LABEL_VALUE_QT_ENTER_NEW_PLAYLIST_NAME,\n   MENU_ENUM_LABEL_VALUE_QT_DELETE_PLAYLIST,\n   MENU_ENUM_LABEL_VALUE_QT_RENAME_PLAYLIST,\n   MENU_ENUM_LABEL_VALUE_QT_CONFIRM_DELETE_PLAYLIST,\n   MENU_ENUM_LABEL_VALUE_QT_CONFIRM_DELETE_PLAYLIST_ITEM,\n   MENU_ENUM_LABEL_VALUE_QT_QUESTION,\n   MENU_ENUM_LABEL_VALUE_QT_COULD_NOT_DELETE_FILE,\n   MENU_ENUM_LABEL_VALUE_QT_COULD_NOT_RENAME_FILE,\n   MENU_ENUM_LABEL_VALUE_QT_GATHERING_LIST_OF_FILES,\n   MENU_ENUM_LABEL_VALUE_QT_ADDING_FILES_TO_PLAYLIST,\n   MENU_ENUM_LABEL_VALUE_QT_PLAYLIST_ENTRY,\n   MENU_ENUM_LABEL_VALUE_QT_PLAYLIST_ENTRY_NAME,\n   MENU_ENUM_LABEL_VALUE_QT_PLAYLIST_ENTRY_PATH,\n   MENU_ENUM_LABEL_VALUE_QT_PLAYLIST_ENTRY_CORE,\n   MENU_ENUM_LABEL_VALUE_QT_PLAYLIST_ENTRY_DATABASE,\n   MENU_ENUM_LABEL_VALUE_QT_PLAYLIST_ENTRY_EXTENSIONS,\n   MENU_ENUM_LABEL_VALUE_QT_PLAYLIST_ENTRY_EXTENSIONS_PLACEHOLDER,\n   MENU_ENUM_LABEL_VALUE_QT_PLAYLIST_ENTRY_FILTER_INSIDE_ARCHIVES,\n   MENU_ENUM_LABEL_VALUE_QT_FOR_THUMBNAILS,\n   MENU_ENUM_LABEL_VALUE_QT_CANNOT_ADD_TO_ALL_PLAYLISTS,\n   MENU_ENUM_LABEL_VALUE_QT_DELETE,\n   MENU_ENUM_LABEL_VALUE_QT_ADD_ENTRY,\n   MENU_ENUM_LABEL_VALUE_QT_ADD_FILES,\n   MENU_ENUM_LABEL_VALUE_QT_ADD_FOLDER,\n   MENU_ENUM_LABEL_VALUE_QT_EDIT,\n   MENU_ENUM_LABEL_VALUE_QT_SELECT_FILES,\n   MENU_ENUM_LABEL_VALUE_QT_SELECT_FOLDER,\n   MENU_ENUM_LABEL_VALUE_QT_FIELD_MULTIPLE,\n   MENU_ENUM_LABEL_VALUE_QT_COULD_NOT_UPDATE_PLAYLIST_ENTRY,\n   MENU_ENUM_LABEL_VALUE_QT_PLEASE_FILL_OUT_REQUIRED_FIELDS,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_HELP_ABOUT,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_HELP_ABOUT_CONTRIBUTORS,\n   MENU_ENUM_LABEL_VALUE_QT_MENU_HELP_DOCUMENTATION,\n   MENU_ENUM_LABEL_VALUE_QT_NETWORK_ERROR,\n   MENU_ENUM_LABEL_VALUE_QT_UPDATE_RETROARCH_NIGHTLY,\n   MENU_ENUM_LABEL_VALUE_QT_UPDATE_RETROARCH_FINISHED,\n   MENU_ENUM_LABEL_VALUE_QT_UPDATE_RETROARCH_FAILED,\n   MENU_ENUM_LABEL_VALUE_QT_CURRENT_SHADER,\n   MENU_ENUM_LABEL_VALUE_QT_MOVE_DOWN,\n   MENU_ENUM_LABEL_VALUE_QT_MOVE_UP,\n   MENU_ENUM_LABEL_VALUE_QT_LOAD,\n   MENU_ENUM_LABEL_VALUE_QT_SAVE,\n   MENU_ENUM_LABEL_VALUE_QT_REMOVE,\n   MENU_ENUM_LABEL_VALUE_QT_REMOVE_PASSES,\n   MENU_ENUM_LABEL_VALUE_QT_APPLY,\n   MENU_ENUM_LABEL_VALUE_QT_SHADER_ADD_PASS,\n   MENU_ENUM_LABEL_VALUE_QT_SHADER_CLEAR_ALL_PASSES,\n   MENU_ENUM_LABEL_VALUE_QT_SHADER_NO_PASSES,\n   MENU_ENUM_LABEL_VALUE_QT_RESET_PASS,\n   MENU_ENUM_LABEL_VALUE_QT_RESET_ALL_PASSES,\n   MENU_ENUM_LABEL_VALUE_QT_RESET_PARAMETER,\n   MENU_ENUM_LABEL_VALUE_QT_DOWNLOAD_THUMBNAIL,\n   MENU_ENUM_LABEL_VALUE_QT_DOWNLOAD_ALREADY_IN_PROGRESS,\n   MENU_ENUM_LABEL_VALUE_QT_DOWNLOAD_ALL_THUMBNAILS,\n   MENU_ENUM_LABEL_VALUE_QT_DOWNLOAD_ALL_THUMBNAILS_ENTIRE_SYSTEM,\n   MENU_ENUM_LABEL_VALUE_QT_DOWNLOAD_ALL_THUMBNAILS_THIS_PLAYLIST,\n   MENU_ENUM_LABEL_VALUE_QT_THUMBNAIL_PACK_DOWNLOADED_SUCCESSFULLY,\n   MENU_ENUM_LABEL_VALUE_QT_DOWNLOAD_PLAYLIST_THUMBNAIL_PROGRESS,\n   MENU_ENUM_LABEL_VALUE_QT_CORE_OPTIONS,\n   MENU_ENUM_LABEL_VALUE_QT_ITEMS_COUNT,\n   MENU_ENUM_LABEL_VALUE_QT_DROP_IMAGE_HERE,\n   MENU_ENUM_LABEL_VALUE_QT_RESET,\n   MENU_ENUM_LABEL_VALUE_QT_RESET_ALL,\n\n   MENU_LBL_H(MIDI_INPUT),\n   MENU_LBL_H(MIDI_OUTPUT),\n   MENU_LABEL(MIDI_VOLUME),\n\n   /* Power Management */\n   MENU_LABEL(SUSTAINED_PERFORMANCE_MODE),\n   MENU_LABEL(CPU_PERF_MODE),\n   MENU_LABEL(CPU_PERFPOWER),\n   MENU_LABEL(CPU_POLICY_ENTRY),\n   MENU_LABEL(CPU_POLICY_MIN_FREQ),\n   MENU_LABEL(CPU_POLICY_MAX_FREQ),\n   MENU_LABEL(CPU_POLICY_GOVERNOR),\n   MENU_LABEL(CPU_POLICY_CORE_GOVERNOR),\n   MENU_LABEL(CPU_POLICY_MENU_GOVERNOR),\n   MENU_LABEL(CPU_MANAGED_MIN_FREQ),\n   MENU_LABEL(CPU_MANAGED_MAX_FREQ),\n   MENU_LBL_H(GAMEMODE_ENABLE),\n   MENU_ENUM_SUBLABEL_GAMEMODE_ENABLE_LINUX,\n\n   MENU_ENUM_LABEL_VALUE_CPU_PERF_MODE_MANAGED_PERF,\n   MENU_ENUM_LABEL_VALUE_CPU_PERF_MODE_MANAGED_PER_CONTEXT,\n   MENU_ENUM_LABEL_VALUE_CPU_PERF_MODE_MAX_PERF,\n   MENU_ENUM_LABEL_VALUE_CPU_PERF_MODE_MIN_POWER,\n   MENU_ENUM_LABEL_VALUE_CPU_PERF_MODE_BALANCED,\n   MENU_ENUM_LABEL_VALUE_CPU_PERF_MODE_MANUAL,\n\n   MENU_ENUM_SUBLABEL_VALUE_CPU_PERF_MODE_MANAGED_PERF,\n   MENU_ENUM_SUBLABEL_VALUE_CPU_PERF_MODE_MANAGED_PER_CONTEXT,\n   MENU_ENUM_SUBLABEL_VALUE_CPU_PERF_MODE_MAX_PERF,\n   MENU_ENUM_SUBLABEL_VALUE_CPU_PERF_MODE_MIN_POWER,\n   MENU_ENUM_SUBLABEL_VALUE_CPU_PERF_MODE_BALANCED,\n   MENU_ENUM_SUBLABEL_VALUE_CPU_PERF_MODE_MANUAL,\n\n   MENU_ENUM_LABEL_CHEAT_HANDLER_TYPE_EMU,\n   MENU_ENUM_LABEL_CHEAT_HANDLER_TYPE_RETRO,\n   MENU_ENUM_LABEL_CHEAT_TYPE_DISABLED,\n   MENU_ENUM_LABEL_CHEAT_TYPE_SET_TO_VALUE,\n   MENU_ENUM_LABEL_CHEAT_TYPE_INCREASE_VALUE,\n   MENU_ENUM_LABEL_CHEAT_TYPE_DECREASE_VALUE,\n   MENU_ENUM_LABEL_CHEAT_TYPE_RUN_NEXT_IF_EQ,\n   MENU_ENUM_LABEL_CHEAT_TYPE_RUN_NEXT_IF_NEQ,\n   MENU_ENUM_LABEL_CHEAT_TYPE_RUN_NEXT_IF_LT,\n   MENU_ENUM_LABEL_CHEAT_TYPE_RUN_NEXT_IF_GT,\n   MENU_ENUM_LABEL_RUMBLE_TYPE_DISABLED,\n   MENU_ENUM_LABEL_RUMBLE_TYPE_CHANGES,\n   MENU_ENUM_LABEL_RUMBLE_TYPE_DOES_NOT_CHANGE,\n   MENU_ENUM_LABEL_RUMBLE_TYPE_INCREASE,\n   MENU_ENUM_LABEL_RUMBLE_TYPE_DECREASE,\n   MENU_ENUM_LABEL_RUMBLE_TYPE_EQ_VALUE,\n   MENU_ENUM_LABEL_RUMBLE_TYPE_NEQ_VALUE,\n   MENU_ENUM_LABEL_RUMBLE_TYPE_LT_VALUE,\n   MENU_ENUM_LABEL_RUMBLE_TYPE_GT_VALUE,\n   MENU_ENUM_LABEL_RUMBLE_TYPE_INCREASE_BY_VALUE,\n   MENU_ENUM_LABEL_RUMBLE_TYPE_DECREASE_BY_VALUE,\n   MENU_ENUM_LABEL_CHEAT_MEMORY_SIZE_1,\n   MENU_ENUM_LABEL_CHEAT_MEMORY_SIZE_2,\n   MENU_ENUM_LABEL_CHEAT_MEMORY_SIZE_4,\n   MENU_ENUM_LABEL_CHEAT_MEMORY_SIZE_8,\n   MENU_ENUM_LABEL_CHEAT_MEMORY_SIZE_16,\n   MENU_ENUM_LABEL_CHEAT_MEMORY_SIZE_32,\n   MENU_ENUM_LABEL_RUMBLE_PORT_0,\n   MENU_ENUM_LABEL_RUMBLE_PORT_1,\n   MENU_ENUM_LABEL_RUMBLE_PORT_2,\n   MENU_ENUM_LABEL_RUMBLE_PORT_3,\n   MENU_ENUM_LABEL_RUMBLE_PORT_4,\n   MENU_ENUM_LABEL_RUMBLE_PORT_5,\n   MENU_ENUM_LABEL_RUMBLE_PORT_6,\n   MENU_ENUM_LABEL_RUMBLE_PORT_7,\n   MENU_ENUM_LABEL_RUMBLE_PORT_8,\n   MENU_ENUM_LABEL_RUMBLE_PORT_9,\n   MENU_ENUM_LABEL_RUMBLE_PORT_10,\n   MENU_ENUM_LABEL_RUMBLE_PORT_11,\n   MENU_ENUM_LABEL_RUMBLE_PORT_12,\n   MENU_ENUM_LABEL_RUMBLE_PORT_13,\n   MENU_ENUM_LABEL_RUMBLE_PORT_14,\n   MENU_ENUM_LABEL_RUMBLE_PORT_15,\n   MENU_ENUM_LABEL_RUMBLE_PORT_16,\n   MENU_ENUM_LABEL_CHEAT_SEARCH_EXACT_VAL,\n   MENU_ENUM_LABEL_CHEAT_SEARCH_LT_VAL,\n   MENU_ENUM_LABEL_CHEAT_SEARCH_LTE_VAL,\n   MENU_ENUM_LABEL_CHEAT_SEARCH_GT_VAL,\n   MENU_ENUM_LABEL_CHEAT_SEARCH_GTE_VAL,\n   MENU_ENUM_LABEL_CHEAT_SEARCH_EQ_VAL,\n   MENU_ENUM_LABEL_CHEAT_SEARCH_NEQ_VAL,\n   MENU_ENUM_LABEL_CHEAT_SEARCH_EQPLUS_VAL,\n   MENU_ENUM_LABEL_CHEAT_SEARCH_EQMINUS_VAL,\n   MSG_CHEAT_INIT_SUCCESS,\n   MSG_CHEAT_INIT_FAIL,\n   MSG_CHEAT_SEARCH_NOT_INITIALIZED,\n   MSG_CHEAT_SEARCH_FOUND_MATCHES,\n   MSG_CHEAT_SEARCH_ADDED_MATCHES_SUCCESS,\n   MSG_CHEAT_SEARCH_ADDED_MATCHES_FAIL,\n   MSG_CHEAT_SEARCH_ADDED_MATCHES_TOO_MANY,\n   MSG_CHEAT_DELETE_ALL_INSTRUCTIONS,\n   MSG_CHEAT_ADD_TOP_SUCCESS,\n   MSG_CHEAT_ADD_BOTTOM_SUCCESS,\n   MSG_CHEAT_DELETE_ALL_SUCCESS,\n   MSG_CHEAT_ADD_AFTER_SUCCESS,\n   MSG_CHEAT_ADD_BEFORE_SUCCESS,\n   MSG_CHEAT_COPY_AFTER_SUCCESS,\n   MSG_CHEAT_COPY_BEFORE_SUCCESS,\n   MSG_CHEAT_DELETE_SUCCESS,\n   MSG_CHEAT_SEARCH_ADD_MATCH_SUCCESS,\n   MSG_CHEAT_SEARCH_ADD_MATCH_FAIL,\n   MSG_CHEAT_SEARCH_DELETE_MATCH_SUCCESS,\n   MSG_CHEEVOS_LOGGED_IN_AS_USER,\n   MSG_CHEEVOS_LOAD_STATE_PREVENTED_BY_HARDCORE_MODE,\n   MSG_CHEEVOS_HARDCORE_MODE_DISABLED,\n   MSG_CHEEVOS_HARDCORE_MODE_DISABLED_CHEAT,\n   MSG_CHEEVOS_MASTERED_GAME,\n   MSG_CHEEVOS_COMPLETED_GAME,\n   MSG_CHEEVOS_HARDCORE_MODE_ENABLE,\n   MSG_CHEEVOS_GAME_HAS_NO_ACHIEVEMENTS,\n   MSG_CHEEVOS_ALL_ACHIEVEMENTS_ACTIVATED,\n   MSG_CHEEVOS_UNOFFICIAL_ACHIEVEMENTS_ACTIVATED,\n   MSG_CHEEVOS_NUMBER_ACHIEVEMENTS_UNLOCKED,\n   MSG_CHEEVOS_UNSUPPORTED_COUNT,\n   MSG_CHEEVOS_RICH_PRESENCE_SPECTATING,\n   MSG_CHEEVOS_HARDCORE_PAUSED_MANUAL_FRAME_DELAY,\n   MSG_CHEEVOS_HARDCORE_PAUSED_VSYNC_SWAP_INTERVAL,\n   MSG_CHEEVOS_HARDCORE_PAUSED_BLACK_FRAME_INSERTION,\n   MSG_CHEEVOS_HARDCORE_PAUSED_SETTING_NOT_ALLOWED,\n   MSG_CHEEVOS_HARDCORE_PAUSED_SYSTEM_NOT_FOR_CORE,\n   MSG_CHEEVOS_GAME_NOT_IDENTIFIED,\n   MSG_CHEEVOS_GAME_LOAD_FAILED,\n   MSG_CHEEVOS_CHANGE_MEDIA_FAILED,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_YMD_HMS,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_YMD_HM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_YMD,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_YM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_MDYYYY_HMS,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_MDYYYY_HM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_MD_HM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_MDYYYY,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_MD,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_DDMMYYYY_HMS,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_DDMMYYYY_HM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_DDMM_HM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_DDMMYYYY,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_DDMM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_HMS,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_HM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_YMD_HMS_AMPM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_YMD_HM_AMPM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_MDYYYY_HMS_AMPM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_MDYYYY_HM_AMPM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_MD_HM_AMPM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_DDMMYYYY_HMS_AMPM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_DDMMYYYY_HM_AMPM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_DDMM_HM_AMPM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_HMS_AMPM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_HM_AMPM,\n   MENU_ENUM_LABEL_VALUE_TIMEDATE_AGO,\n\n   MENU_LABEL(SWITCH_GPU_PROFILE),\n   MENU_LABEL(SWITCH_CPU_PROFILE),\n\n   MENU_ENUM_LABEL_VALUE_DOWN_Y_L_R,\n   MENU_ENUM_LABEL_VALUE_L3_R3,\n   MENU_ENUM_LABEL_VALUE_L1_R1_START_SELECT,\n   MENU_ENUM_LABEL_VALUE_START_SELECT,\n   MENU_ENUM_LABEL_VALUE_L3_R,\n   MENU_ENUM_LABEL_VALUE_L_R,\n   MENU_ENUM_LABEL_VALUE_HOLD_START,\n   MENU_ENUM_LABEL_VALUE_HOLD_SELECT,\n   MENU_ENUM_LABEL_VALUE_DOWN_SELECT,\n   MENU_ENUM_LABEL_VALUE_L2_R2,\n\n   MENU_LABEL(PLAYLIST_USE_OLD_FORMAT),\n   MENU_LABEL(PLAYLIST_COMPRESSION),\n   MENU_LABEL(MENU_SOUNDS),\n   MENU_LABEL(MENU_SOUND_OK),\n   MENU_LABEL(MENU_SOUND_CANCEL),\n   MENU_LABEL(MENU_SOUND_NOTICE),\n   MENU_LABEL(MENU_SOUND_BGM),\n   MENU_LABEL(MENU_SOUND_SCROLL),\n   MENU_ENUM_LABEL_VALUE_VIDEO_DRIVER_FALLBACK,\n   MENU_LABEL(CONTENT_RUNTIME_LOG),\n   MENU_LABEL(CONTENT_RUNTIME_LOG_AGGREGATE),\n\n   MENU_LABEL(PLAYLIST_SHOW_INLINE_CORE_NAME),\n   MENU_LABEL(PLAYLIST_SORT_ALPHABETICAL),\n   MENU_LABEL(PLAYLIST_SHOW_SUBLABELS),\n   MENU_LABEL(PLAYLIST_SHOW_HISTORY_ICONS),\n   MENU_LABEL(PLAYLIST_SHOW_ENTRY_IDX),\n   MENU_LABEL(PLAYLIST_FUZZY_ARCHIVE_MATCH),\n   MENU_LABEL(PLAYLIST_SUBLABEL_RUNTIME_TYPE),\n   MENU_LABEL(PLAYLIST_SUBLABEL_LAST_PLAYED_STYLE),\n   MENU_LABEL(PLAYLIST_PORTABLE_PATHS),\n   MENU_LABEL(PLAYLIST_USE_FILENAME),\n   MENU_LABEL(PLAYLIST_ALLOW_NON_PNG),\n\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_INLINE_CORE_DISPLAY_HIST_FAV,\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_INLINE_CORE_DISPLAY_ALWAYS,\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_INLINE_CORE_DISPLAY_NEVER,\n\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_ENTRY_REMOVE_ENABLE_HIST_FAV,\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_ENTRY_REMOVE_ENABLE_ALL,\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_ENTRY_REMOVE_ENABLE_NONE,\n\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_SUBLABEL_CORE,\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_SUBLABEL_RUNTIME,\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_SUBLABEL_LAST_PLAYED,\n\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_RUNTIME_PER_CORE,\n   MENU_ENUM_LABEL_VALUE_PLAYLIST_RUNTIME_AGGREGATE,\n\n   MENU_ENUM_LABEL_VALUE_TIME_UNIT_SECONDS_SINGLE,\n   MENU_ENUM_LABEL_VALUE_TIME_UNIT_SECONDS_PLURAL,\n   MENU_ENUM_LABEL_VALUE_TIME_UNIT_MINUTES_SINGLE,\n   MENU_ENUM_LABEL_VALUE_TIME_UNIT_MINUTES_PLURAL,\n   MENU_ENUM_LABEL_VALUE_TIME_UNIT_HOURS_SINGLE,\n   MENU_ENUM_LABEL_VALUE_TIME_UNIT_HOURS_PLURAL,\n   MENU_ENUM_LABEL_VALUE_TIME_UNIT_DAYS_SINGLE,\n   MENU_ENUM_LABEL_VALUE_TIME_UNIT_DAYS_PLURAL,\n   MENU_ENUM_LABEL_VALUE_TIME_UNIT_WEEKS_SINGLE,\n   MENU_ENUM_LABEL_VALUE_TIME_UNIT_WEEKS_PLURAL,\n   MENU_ENUM_LABEL_VALUE_TIME_UNIT_MONTHS_SINGLE,\n   MENU_ENUM_LABEL_VALUE_TIME_UNIT_MONTHS_PLURAL,\n   MENU_ENUM_LABEL_VALUE_TIME_UNIT_YEARS_SINGLE,\n   MENU_ENUM_LABEL_VALUE_TIME_UNIT_YEARS_PLURAL,\n   MENU_ENUM_LABEL_VALUE_TIME_UNIT_AGO,\n\n   MENU_LABEL(HELP_SEND_DEBUG_INFO),\n   MENU_ENUM_LABEL_VALUE_HELP_SEND_DEBUG_INFO_DESC,\n\n   MSG_FAILED_TO_SAVE_DEBUG_INFO,\n   MSG_FAILED_TO_SEND_DEBUG_INFO,\n   MSG_SENDING_DEBUG_INFO,\n   MSG_SENT_DEBUG_INFO,\n   MSG_PRESS_TWO_MORE_TIMES_TO_SEND_DEBUG_INFO,\n   MSG_PRESS_ONE_MORE_TIME_TO_SEND_DEBUG_INFO,\n\n   MENU_LABEL(VIBRATE_ON_KEYPRESS),\n   MENU_LABEL(ENABLE_DEVICE_VIBRATION),\n   MENU_LABEL(VIDEO_GPU_INDEX),\n\n   MSG_DUMPING_DISC,\n   MSG_DRIVE_NUMBER,\n   MSG_LOAD_CORE_FIRST,\n   MSG_DISC_DUMP_FAILED_TO_READ_FROM_DRIVE,\n   MSG_DISC_DUMP_FAILED_TO_WRITE_TO_DISK,\n   MSG_NO_DISC_INSERTED,\n   MENU_LABEL(DELETE_PLAYLIST),\n\n   /* Manual content scan */\n   MENU_LABEL(MANUAL_CONTENT_SCAN_LIST),\n   MENU_LABEL(MANUAL_CONTENT_SCAN_DIR),\n   MENU_LABEL(MANUAL_CONTENT_SCAN_SYSTEM_NAME),\n   MENU_LABEL(MANUAL_CONTENT_SCAN_SYSTEM_NAME_CUSTOM),\n   MENU_LABEL(MANUAL_CONTENT_SCAN_CORE_NAME),\n   MENU_LABEL(MANUAL_CONTENT_SCAN_FILE_EXTS),\n   MENU_LABEL(MANUAL_CONTENT_SCAN_SEARCH_RECURSIVELY),\n   MENU_LABEL(MANUAL_CONTENT_SCAN_SEARCH_ARCHIVES),\n   MENU_LABEL(MANUAL_CONTENT_SCAN_DAT_FILE),\n   MENU_LABEL(MANUAL_CONTENT_SCAN_DAT_FILE_FILTER),\n   MENU_LABEL(MANUAL_CONTENT_SCAN_OVERWRITE),\n   MENU_LABEL(MANUAL_CONTENT_SCAN_VALIDATE_ENTRIES),\n   MENU_LABEL(MANUAL_CONTENT_SCAN_START),\n\n   MENU_ENUM_LABEL_VALUE_MANUAL_CONTENT_SCAN_SYSTEM_NAME_USE_CONTENT_DIR,\n   MENU_ENUM_LABEL_VALUE_MANUAL_CONTENT_SCAN_SYSTEM_NAME_USE_CUSTOM,\n\n   MENU_ENUM_LABEL_VALUE_MANUAL_CONTENT_SCAN_CORE_NAME_DETECT,\n\n   MSG_MANUAL_CONTENT_SCAN_DAT_FILE_INVALID,\n   MSG_MANUAL_CONTENT_SCAN_DAT_FILE_TOO_LARGE,\n   MSG_MANUAL_CONTENT_SCAN_DAT_FILE_LOAD_ERROR,\n   MSG_MANUAL_CONTENT_SCAN_INVALID_CONFIG,\n   MSG_MANUAL_CONTENT_SCAN_INVALID_CONTENT,\n   MSG_MANUAL_CONTENT_SCAN_START,\n   MSG_MANUAL_CONTENT_SCAN_PLAYLIST_CLEANUP,\n   MSG_MANUAL_CONTENT_SCAN_IN_PROGRESS,\n   MSG_MANUAL_CONTENT_SCAN_M3U_CLEANUP,\n   MSG_MANUAL_CONTENT_SCAN_END,\n\n   MSG_3DS_BOTTOM_MENU_DEFAULT,\n   MSG_3DS_BOTTOM_MENU_ASSET_NOT_FOUND,\n   MSG_3DS_BOTTOM_MENU_NO_STATE_DATA,\n   MSG_3DS_BOTTOM_MENU_NO_STATE_THUMBNAIL,\n   MSG_3DS_BOTTOM_MENU_RESUME,\n   MSG_3DS_BOTTOM_MENU_SAVE_STATE,\n   MSG_3DS_BOTTOM_MENU_LOAD_STATE,\n\n   MSG_LAST,\n\n   /* Ensure sizeof(enum) == sizeof(int) */\n   MSG_DUMMY          = INT_MAX\n};\n\n/* Callback strings */\n\nconst char *msg_hash_to_str(enum msg_hash_enums msg);\n\nconst char *msg_hash_to_str_us(enum msg_hash_enums msg);\nint msg_hash_get_help_us_enum(enum msg_hash_enums msg, char *s, size_t len);\n\nint msg_hash_get_help_enum(enum msg_hash_enums msg, char *s, size_t len);\n\nenum msg_file_type msg_hash_to_file_type(uint32_t hash);\n\nunsigned *msg_hash_get_uint(enum msg_hash_action type);\n\nvoid msg_hash_set_uint(enum msg_hash_action type, unsigned val);\n\n/* Latin languages typically consist of regular\n * alpha numeric characters with a 'standard'\n * on-screen pixel width.\n * Non-Latin languages (e.g. CJK) typically consist\n * of so-called 'wide' Unicode glyphs, which may have\n * an on-screen pixel width several times that of Latin\n * characters.\n * In order to determine efficiently the on-screen width\n * of a text string (e.g. when word wrapping), it is\n * therefore necessary to:\n * - Identify which languages make use of 'wide' Unicode\n *   glyphs\n * - For each of these languages, provide a mechanism for\n *   measuring the typical on-screen pixel width of\n *   language-specific 'wide' Unicode glyphs\n * As such, msg_hash_get_wideglyph_str() returns a pointer\n * to a 'wide' Unicode character of typical on-screen pixel\n * width for the currently set user language.\n * - If msg_hash_get_wideglyph_str() returns NULL, the current\n *   language is assumed to be Latin-based, with no usage\n *   of 'wide' Unicode glyphs\n * - If msg_hash_get_wideglyph_str() returns a valid pointer,\n *   actual 'wide' glyph width for the current language may\n *   be found by passing said pointer to the current font\n *   rendering implementation */\nconst char *msg_hash_get_wideglyph_str(void);\n\nuint32_t msg_hash_calculate(const char *s);\n\nconst char *get_user_language_iso639_1(bool limit);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "network",
          "type": "tree",
          "content": null
        },
        {
          "name": "no-xib.diff",
          "type": "blob",
          "size": 6.7802734375,
          "content": "diff --git a/gfx/drivers_context/cocoa_gl_ctx.m b/gfx/drivers_context/cocoa_gl_ctx.m\nindex e67725f..868d874 100644\n--- a/gfx/drivers_context/cocoa_gl_ctx.m\n+++ b/gfx/drivers_context/cocoa_gl_ctx.m\n@@ -83,6 +83,7 @@ static NSOpenGLPixelFormat* g_format;\n\n static unsigned g_minor = 0;\n static unsigned g_major = 0;\n+static bool g_is_inited = false;\n\n /* forward declaration */\n void *nsview_get_ptr(void);\n@@ -152,6 +153,9 @@ static bool cocoagl_gfx_ctx_init(void *data)\n {\n    (void)data;\n\n+    if (g_is_inited)\n+        return true;\n+\n #if defined(HAVE_COCOA)\n     CocoaView *g_view = (CocoaView*)nsview_get_ptr();\n #if MAC_OS_X_VERSION_10_7\n@@ -196,6 +200,11 @@ static bool cocoagl_gfx_ctx_init(void *data)\n     [g_context makeCurrentContext];\n    // Make sure the view was created\n    [CocoaView get];\n+#if defined(HAVE_COCOA)\n+    [NSApp setDelegate:g_view];\n+#endif\n+\n+    g_is_inited = true;\n    return true;\n }\n\n@@ -221,6 +230,8 @@ static void cocoagl_gfx_ctx_destroy(void *data)\n #endif\n    [GLContextClass clearCurrentContext];\n    g_context = nil;\n+\n+    g_is_inited = false;\n }\n\n static bool cocoagl_gfx_ctx_bind_api(void *data, enum gfx_ctx_api api, unsigned major, unsigned minor)\ndiff --git a/pkg/apple/OSX/Info.plist b/pkg/apple/OSX/Info.plist\nindex 8d59658..af95482 100644\n--- a/pkg/apple/OSX/Info.plist\n+++ b/pkg/apple/OSX/Info.plist\n@@ -41,8 +41,6 @@\n \t<true/>\n \t<key>NSHumanReadableCopyright</key>\n \t<string>Copyright  2015 RetroArch. All rights reserved.</string>\n-\t<key>NSMainNibFile</key>\n-\t<string>MainMenu</string>\n \t<key>NSPrincipalClass</key>\n \t<string>RApplication</string>\n </dict>\ndiff --git a/pkg/apple/RetroArch.xcodeproj/project.pbxproj b/pkg/apple/RetroArch.xcodeproj/project.pbxproj\nindex a7c1b57..e48f0bf 100644\n--- a/pkg/apple/RetroArch.xcodeproj/project.pbxproj\n+++ b/pkg/apple/RetroArch.xcodeproj/project.pbxproj\n@@ -7,9 +7,7 @@\n \tobjects = {\n\n /* Begin PBXBuildFile section */\n-\t\t1DDD58160DA1D0A300B32029 /* MainMenu.xib in Resources */ = {isa = PBXBuildFile; fileRef = 1DDD58140DA1D0A300B32029 /* MainMenu.xib */; };\n \t\t500845251B89300700CE6073 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = 089C165CFE840E0CC02AAC07 /* InfoPlist.strings */; };\n-\t\t500845261B89300700CE6073 /* MainMenu.xib in Resources */ = {isa = PBXBuildFile; fileRef = 1DDD58140DA1D0A300B32029 /* MainMenu.xib */; };\n \t\t500845271B89300700CE6073 /* retroarch.icns in Resources */ = {isa = PBXBuildFile; fileRef = 84DD5EB71A89F1C7007336C1 /* retroarch.icns */; };\n \t\t500845291B89300700CE6073 /* griffin_objc.m in Sources */ = {isa = PBXBuildFile; fileRef = 509F0C9C1AA23AFC00619ECC /* griffin_objc.m */; };\n \t\t5008452A1B89300700CE6073 /* griffin.c in Sources */ = {isa = PBXBuildFile; fileRef = 840222FB1A889EE2009AB261 /* griffin.c */; };\n@@ -75,7 +73,6 @@\n\n /* Begin PBXFileReference section */\n \t\t089C165DFE840E0CC02AAC07 /* InfoPlist.strings */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.strings; name = InfoPlist.strings; path = OSX/en.lproj/InfoPlist.strings; sourceTree = \"<group>\"; };\n-\t\t1DDD58150DA1D0A300B32029 /* MainMenu.xib */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = MainMenu.xib; path = OSX/en.lproj/MainMenu.xib; sourceTree = \"<group>\"; };\n \t\t29B97324FDCFA39411CA2CEA /* AppKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = AppKit.framework; path = /System/Library/Frameworks/AppKit.framework; sourceTree = \"<absolute>\"; };\n \t\t5008453A1B89300700CE6073 /* RetroArch copy.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = \"RetroArch copy.app\"; sourceTree = BUILT_PRODUCTS_DIR; };\n \t\t5008453B1B89300700CE6073 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; name = \"Info.plist\"; path = \"/../../pkg/apple/OSX/Info.plist\"; sourceTree = SOURCE_ROOT; };\n@@ -196,7 +193,6 @@\n \t\t\t\t84DD5EB71A89F1C7007336C1 /* retroarch.icns */,\n \t\t\t\t8D1107310486CEB800E47090 /* Info.plist */,\n \t\t\t\t089C165CFE840E0CC02AAC07 /* InfoPlist.strings */,\n-\t\t\t\t1DDD58140DA1D0A300B32029 /* MainMenu.xib */,\n \t\t\t);\n \t\t\tname = Resources;\n \t\t\tsourceTree = \"<group>\";\n@@ -301,7 +297,6 @@\n \t\t\tbuildActionMask = 2147483647;\n \t\t\tfiles = (\n \t\t\t\t500845251B89300700CE6073 /* InfoPlist.strings in Resources */,\n-\t\t\t\t500845261B89300700CE6073 /* MainMenu.xib in Resources */,\n \t\t\t\t500845271B89300700CE6073 /* retroarch.icns in Resources */,\n \t\t\t);\n \t\t\trunOnlyForDeploymentPostprocessing = 0;\n@@ -311,7 +306,6 @@\n \t\t\tbuildActionMask = 2147483647;\n \t\t\tfiles = (\n \t\t\t\t8D11072B0486CEB800E47090 /* InfoPlist.strings in Resources */,\n-\t\t\t\t1DDD58160DA1D0A300B32029 /* MainMenu.xib in Resources */,\n \t\t\t\t84DD5EB81A89F1C7007336C1 /* retroarch.icns in Resources */,\n \t\t\t);\n \t\t\trunOnlyForDeploymentPostprocessing = 0;\n@@ -348,14 +342,6 @@\n \t\t\tname = InfoPlist.strings;\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n-\t\t1DDD58140DA1D0A300B32029 /* MainMenu.xib */ = {\n-\t\t\tisa = PBXVariantGroup;\n-\t\t\tchildren = (\n-\t\t\t\t1DDD58150DA1D0A300B32029 /* MainMenu.xib */,\n-\t\t\t);\n-\t\t\tname = MainMenu.xib;\n-\t\t\tsourceTree = \"<group>\";\n-\t\t};\n /* End PBXVariantGroup section */\n\n /* Begin XCBuildConfiguration section */\ndiff --git a/ui/drivers/ui_cocoa.m b/ui/drivers/ui_cocoa.m\nindex 5dde6f9..37cd066 100644\n--- a/ui/drivers/ui_cocoa.m\n+++ b/ui/drivers/ui_cocoa.m\n@@ -421,10 +421,50 @@ extern void action_ok_push_quick_menu(void);\n\n @end\n\n+static void setup_appkit(void)\n+{\n+   [NSAutoreleasePool new];\n+   [NSApplication sharedApplication];\n+\n+   /* Might be Snow Leopard (10.6) only and up */\n+   [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];\n+\n+   id menubar = [[NSMenu new] autorelease];\n+   id appMenuItem = [[NSMenuItem new] autorelease];\n+\n+   [menubar addItem:appMenuItem];\n+   [NSApp setMainMenu:menubar];\n+\n+    /* Add 'Quit' to menu */\n+    id appMenu = [[NSMenu new] autorelease];\n+    id appName = [[NSProcessInfo processInfo] processName];\n+    id quitTitle = BOXSTRING(\"Quit\");\n+    id quitMenuItem = [[[NSMenuItem alloc] initWithTitle:quitTitle\n+    action:@selector(terminate:) keyEquivalent:BOXSTRING(\"q\")] autorelease];\n+    [appMenu addItem:quitMenuItem];\n+    [appMenuItem setSubmenu:appMenu];\n+\n+    /* Create a window and activate the application */\n+    id window = [[[NSWindow alloc] initWithContentRect:NSMakeRect(0, 0, 200, 200) styleMask:NSTitledWindowMask backing:NSBackingStoreBuffered defer:NO] autorelease];\n+    [window cascadeTopLeftFromPoint:NSMakePoint(20,20)];\n+    [window setTitle:appName];\n+    [window makeKeyAndOrderFront:nil];\n+\n+    cocoagl_gfx_ctx_init(NULL);\n+    [window setContentView:(CocoaView*)nsview_get_ptr()];\n+\n+    /* Start the application */\n+    [NSApp activateIgnoringOtherApps:YES]; /* Brings application to front on startup */\n+    [NSApp run];\n+}\n+\n int main(int argc, char *argv[])\n {\n    waiting_argc = argc;\n    waiting_argv = argv;\n+\n+   setup_appkit();\n+\n    return NSApplicationMain(argc, (const char **) argv);\n }\n"
        },
        {
          "name": "nvdaControllerClient64.dll",
          "type": "blob",
          "size": 150,
          "content": null
        },
        {
          "name": "nvda_controller.h",
          "type": "blob",
          "size": 2.21484375,
          "content": "/* this ALWAYS GENERATED file contains the definitions for the interfaces */\n\n\n /* File created by MIDL compiler version 7.00.0555 */\n/* at Fri Feb 19 11:21:40 2010\n */\n/* Compiler settings for interfaces\\nvdaController\\nvdaController.idl, interfaces\\nvdaController\\nvdaController.acf:\n    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 7.00.0555 \n    protocol : dce , ms_ext, c_ext, robust\n    error checks: allocation ref bounds_check enum stub_data \n    VC __declspec() decoration level: \n         __declspec(uuid()), __declspec(selectany), __declspec(novtable)\n         DECLSPEC_UUID(), MIDL_INTERFACE()\n*/\n/* @@MIDL_FILE_HEADING(  ) */\n\n#pragma warning( disable: 4049 )  /* more than 64k source lines */\n\n\n/* verify that the <rpcndr.h> version is high enough to compile this file*/\n#ifndef __REQUIRED_RPCNDR_H_VERSION__\n#define __REQUIRED_RPCNDR_H_VERSION__ 475\n#endif\n\n#include \"rpc.h\"\n#include \"rpcndr.h\"\n\n#ifndef __RPCNDR_H_VERSION__\n#error this stub requires an updated version of <rpcndr.h>\n#endif /* __RPCNDR_H_VERSION__ */\n\n\n#ifndef __nvdaController_h__\n#define __nvdaController_h__\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1020)\n#pragma once\n#endif\n\n/* Forward Declarations */ \n\n#ifdef __cplusplus\nextern \"C\"{\n#endif \n\n\n#ifndef __NvdaController_INTERFACE_DEFINED__\n#define __NvdaController_INTERFACE_DEFINED__\n\n/* interface NvdaController */\n/* [implicit_handle][version][uuid] */ \n\n/* [comm_status][fault_status] */ error_status_t __stdcall nvdaController_testIfRunning( void);\n\n/* [comm_status][fault_status] */ error_status_t __stdcall nvdaController_speakText( \n    /* [string][in] */ const wchar_t *text);\n\n/* [comm_status][fault_status] */ error_status_t __stdcall nvdaController_cancelSpeech( void);\n\n/* [comm_status][fault_status] */ error_status_t __stdcall nvdaController_brailleMessage( \n    /* [string][in] */ const wchar_t *message);\n\n\nextern handle_t nvdaControllerBindingHandle;\n\n\nextern RPC_IF_HANDLE nvdaController_NvdaController_v1_0_c_ifspec;\nextern RPC_IF_HANDLE NvdaController_v1_0_c_ifspec;\nextern RPC_IF_HANDLE nvdaController_NvdaController_v1_0_s_ifspec;\n#endif /* __NvdaController_INTERFACE_DEFINED__ */\n\n/* Additional Prototypes for ALL interfaces */\n\n/* end of Additional Prototypes */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
        },
        {
          "name": "paths.h",
          "type": "blob",
          "size": 2.2353515625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2011-2019 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __PATHS_H\n#define __PATHS_H\n\n#include <boolean.h>\n#include <retro_common_api.h>\n\n#include <lists/string_list.h>\n\nRETRO_BEGIN_DECLS\n\nenum rarch_dir_type\n{\n   RARCH_DIR_NONE = 0,\n   RARCH_DIR_SAVEFILE,\n   RARCH_DIR_SAVESTATE,\n   RARCH_DIR_CURRENT_SAVEFILE,\n   RARCH_DIR_CURRENT_SAVESTATE,\n   RARCH_DIR_SYSTEM\n};\n\nenum rarch_content_type\n{\n   RARCH_CONTENT_NONE = 0,\n   RARCH_CONTENT_MOVIE,\n   RARCH_CONTENT_MUSIC,\n   RARCH_CONTENT_IMAGE,\n   RARCH_CONTENT_GONG\n};\n\nenum rarch_path_type\n{\n   RARCH_PATH_NONE = 0,\n   RARCH_PATH_CORE,\n   RARCH_PATH_NAMES,\n   RARCH_PATH_CONFIG,\n   RARCH_PATH_CONTENT,\n   RARCH_PATH_CONFIG_APPEND,\n   RARCH_PATH_CONFIG_OVERRIDE,\n   RARCH_PATH_CORE_OPTIONS,\n   RARCH_PATH_DEFAULT_SHADER_PRESET,\n   RARCH_PATH_BASENAME,\n   RARCH_PATH_SUBSYSTEM\n};\n\nvoid dir_clear(enum rarch_dir_type type);\n\nsize_t dir_get_size(enum rarch_dir_type type);\n\nchar *dir_get_ptr(enum rarch_dir_type type);\n\nvoid dir_set(enum rarch_dir_type type, const char *path);\n\nvoid dir_check_defaults(const char *custom_ini_path);\n\nvoid path_deinit_savefile(void);\n\nbool path_set(enum rarch_path_type type, const char *path);\n\nsize_t path_get_realsize(enum rarch_path_type type);\n\nstruct string_list *path_get_subsystem_list(void);\n\nchar *path_get_ptr(enum rarch_path_type type);\n\nconst char *path_get(enum rarch_path_type type);\n\nvoid path_clear(enum rarch_path_type type);\n\nbool path_is_empty(enum rarch_path_type type);\n\nenum rarch_content_type path_is_media_type(const char *path);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "performance_counters.h",
          "type": "blob",
          "size": 2.4501953125,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _PERFORMANCE_COUNTERS_H\n#define _PERFORMANCE_COUNTERS_H\n\n#include <stdint.h>\n#include <boolean.h>\n\n#include <retro_common_api.h>\n#include <libretro.h>\n#include <features/features_cpu.h>\n\n#ifndef MAX_COUNTERS\n#define MAX_COUNTERS 64\n#endif\n\n#define performance_counter_init(perf, name) \\\n   perf.ident = name; \\\n   if (!perf.registered) \\\n      rarch_perf_register(&perf)\n\n#define performance_counter_start_internal(is_perfcnt_enable, perf) \\\n   if ((is_perfcnt_enable)) \\\n   { \\\n      perf.call_cnt++; \\\n      perf.start = cpu_features_get_perf_counter(); \\\n   }\n\n#define performance_counter_stop_internal(is_perfcnt_enable, perf) \\\n   if ((is_perfcnt_enable)) \\\n      perf.total += cpu_features_get_perf_counter() - perf.start\n\n/**\n * performance_counter_start:\n * @perf               : pointer to performance counter\n *\n * Start performance counter.\n **/\n#define performance_counter_start_plus(is_perfcnt_enable, perf) performance_counter_start_internal(is_perfcnt_enable, perf)\n\n/**\n * performance_counter_stop:\n * @perf               : pointer to performance counter\n *\n * Stop performance counter.\n **/\n#define performance_counter_stop_plus(is_perfcnt_enable, perf) performance_counter_stop_internal(is_perfcnt_enable, perf)\n\nRETRO_BEGIN_DECLS\n\ntypedef struct rarch_timer\n{\n   int64_t current;\n   int64_t timeout_us;\n   int64_t timeout_end;\n   bool timer_begin;\n   bool timer_end;\n} rarch_timer_t;\n\nstruct retro_perf_counter **retro_get_perf_counter_rarch(void);\n\nstruct retro_perf_counter **retro_get_perf_counter_libretro(void);\n\nunsigned retro_get_perf_count_rarch(void);\n\nunsigned retro_get_perf_count_libretro(void);\n\nvoid rarch_perf_register(struct retro_perf_counter *perf);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "pkg",
          "type": "tree",
          "content": null
        },
        {
          "name": "play_feature_delivery",
          "type": "tree",
          "content": null
        },
        {
          "name": "playlist.c",
          "type": "blob",
          "size": 118.0703125,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include <libretro.h>\n#include <boolean.h>\n#include <retro_miscellaneous.h>\n#include <compat/posix_string.h>\n#include <string/stdstring.h>\n#include <streams/interface_stream.h>\n#include <file/file_path.h>\n#include <file/archive_file.h>\n#include <lists/string_list.h>\n#include <formats/rjson.h>\n#include <array/rbuf.h>\n\n#include \"playlist.h\"\n#include \"verbosity.h\"\n#include \"file_path_special.h\"\n#include \"core_info.h\"\n\n#if defined(ANDROID)\n#include \"play_feature_delivery/play_feature_delivery.h\"\n#endif\n\n#ifndef PLAYLIST_ENTRIES\n#define PLAYLIST_ENTRIES 6\n#endif\n\n#define WINDOWS_PATH_DELIMITER '\\\\'\n#define POSIX_PATH_DELIMITER '/'\n\n/* Holds all configuration parameters required\n * to repeat a manual content scan for a\n * previously manual-scan-generated playlist */\ntypedef struct\n{\n   char *content_dir;\n   char *file_exts;\n   char *dat_file_path;\n   bool search_recursively;\n   bool search_archives;\n   bool filter_dat_content;\n   bool overwrite_playlist;\n} playlist_manual_scan_record_t;\n\nenum content_playlist_flags\n{\n   CNT_PLAYLIST_FLG_MOD        = (1 << 0),\n   CNT_PLAYLIST_FLG_OLD_FMT    = (1 << 1),\n   CNT_PLAYLIST_FLG_COMPRESSED = (1 << 2),\n   CNT_PLAYLIST_FLG_CACHED_EXT = (1 << 3)\n};\n\nstruct content_playlist\n{\n   char *default_core_path;\n   char *default_core_name;\n   char *base_content_directory;\n\n   struct playlist_entry *entries;\n\n   playlist_manual_scan_record_t scan_record; /* ptr alignment */\n   playlist_config_t config;                  /* size_t alignment */\n\n   enum playlist_label_display_mode label_display_mode;\n   enum playlist_thumbnail_mode right_thumbnail_mode;\n   enum playlist_thumbnail_mode left_thumbnail_mode;\n   enum playlist_thumbnail_match_mode thumbnail_match_mode;\n   enum playlist_sort_mode sort_mode;\n\n   uint8_t flags;\n};\n\nenum json_ctx_flags\n{\n   JSON_CTX_FLG_IN_ITEMS             = (1 << 0),\n   JSON_CTX_FLG_IN_SUBSYSTEM_CONTENT = (1 << 1),\n   JSON_CTX_FLG_CAPACITY_EXCEEDED    = (1 << 2),\n   JSON_CTX_FLG_OOM                  = (1 << 3)\n};\n\ntypedef struct\n{\n   struct playlist_entry *current_entry;\n   char **current_string_val;\n   unsigned *current_entry_uint_val;\n   enum playlist_label_display_mode *current_meta_label_display_mode_val;\n   enum playlist_thumbnail_mode *current_meta_thumbnail_mode_val;\n   enum playlist_thumbnail_match_mode *current_meta_thumbnail_match_mode_val;\n   enum playlist_sort_mode *current_meta_sort_mode_val;\n   bool *current_meta_bool_val;\n   playlist_t *playlist;\n\n   unsigned array_depth;\n   unsigned object_depth;\n\n   uint8_t flags;\n} JSONContext;\n\n/* TODO/FIXME - global state - perhaps move outside this file */\nstatic playlist_t *playlist_cached = NULL;\n\ntypedef int (playlist_sort_fun_t)(\n      const struct playlist_entry *a,\n      const struct playlist_entry *b);\n\n/* TODO/FIXME - hack for allowing the explore view to switch\n * over to a playlist item */\nvoid playlist_set_cached_external(playlist_t* pl)\n{\n   playlist_free_cached();\n   if (!pl)\n      return;\n\n   playlist_cached         = pl;\n   playlist_cached->flags |= CNT_PLAYLIST_FLG_CACHED_EXT;\n}\n\n/* Convenience function: copies specified playlist\n * path to specified playlist configuration object */\nvoid playlist_config_set_path(playlist_config_t *config, const char *path)\n{\n   if (!config)\n      return;\n\n   if (!string_is_empty(path))\n      strlcpy(config->path, path, sizeof(config->path));\n   else\n      config->path[0] = '\\0';\n}\n\n/* Convenience function: copies base content directory\n * path to specified playlist configuration object.\n * Also sets autofix_paths boolean, depending on base\n * content directory value */\nvoid playlist_config_set_base_content_directory(\n      playlist_config_t* config, const char* path)\n{\n   if (!config)\n      return;\n\n   config->autofix_paths = !string_is_empty(path);\n   if (config->autofix_paths)\n      strlcpy(config->base_content_directory, path,\n            sizeof(config->base_content_directory));\n   else\n      config->base_content_directory[0] = '\\0';\n}\n\n\n/* Creates a copy of the specified playlist configuration.\n * Returns false in the event of an error */\nbool playlist_config_copy(const playlist_config_t *src,\n      playlist_config_t *dst)\n{\n   if (!src || !dst)\n      return false;\n\n   strlcpy(dst->path, src->path, sizeof(dst->path));\n   strlcpy(dst->base_content_directory, src->base_content_directory,\n         sizeof(dst->base_content_directory));\n\n   dst->capacity            = src->capacity;\n   dst->old_format          = src->old_format;\n   dst->compress            = src->compress;\n   dst->fuzzy_archive_match = src->fuzzy_archive_match;\n   dst->autofix_paths       = src->autofix_paths;\n\n   return true;\n}\n\n/* Returns internal playlist configuration object\n * of specified playlist.\n * Returns NULL it the event of an error. */\nplaylist_config_t *playlist_get_config(playlist_t *playlist)\n{\n   if (!playlist)\n      return NULL;\n\n   return &playlist->config;\n}\n\nstatic void path_replace_base_path_and_convert_to_local_file_system(\n      char *out_path,\n      const char *in_path,\n      const char *in_oldrefpath,\n      const char *in_refpath,\n      size_t size)\n{\n   size_t in_oldrefpath_length = strlen(in_oldrefpath);\n\n   /* If entry path is inside playlist base path,\n    * replace it with new base content directory */\n   if (string_starts_with_size(in_path, in_oldrefpath, in_oldrefpath_length))\n   {\n      size_t in_refpath_length = strlen(in_refpath);\n      memcpy(out_path, in_refpath, in_refpath_length);\n      memcpy(\n            out_path + in_refpath_length,\n            in_path  + in_oldrefpath_length,\n            strlen(in_path) - in_oldrefpath_length + 1);\n#ifdef _WIN32\n      /* If we are running under a Windows filesystem,\n       * '/' characters are not allowed anywhere.\n       * We replace with '\\' and hope for the best... */\n      string_replace_all_chars(out_path,\n            POSIX_PATH_DELIMITER, WINDOWS_PATH_DELIMITER);\n#else\n      /* Under POSIX filesystem, we replace '\\' characters with '/' */\n      string_replace_all_chars(out_path,\n            WINDOWS_PATH_DELIMITER, POSIX_PATH_DELIMITER);\n#endif\n   }\n   else\n      strlcpy(out_path, in_path, size);\n}\n\n/* Generates a case insensitive hash for the\n * specified path string */\nstatic uint32_t playlist_path_hash(const char *path)\n{\n   unsigned char c;\n   uint32_t hash = (uint32_t)0x811c9dc5;\n   while ((c = (unsigned char)*(path++)) != '\\0')\n      hash = ((hash * (uint32_t)0x01000193) ^ (uint32_t)((c >= 'A' && c <= 'Z') ? (c | 0x20) : c));\n   return (hash ? hash : 1);\n}\n\nstatic void playlist_path_id_free(playlist_path_id_t *path_id)\n{\n   if (   (path_id->archive_path)\n       && (path_id->archive_path != path_id->real_path))\n      free(path_id->archive_path);\n\n   if (path_id->real_path)\n      free(path_id->real_path);\n\n   free(path_id);\n}\n\nstatic playlist_path_id_t *playlist_path_id_init(const char *path)\n{\n   playlist_path_id_t *path_id  = (playlist_path_id_t*)malloc(sizeof(*path_id));\n\n   if (!path_id)\n      return NULL;\n\n   path_id->real_path           = NULL;\n   path_id->archive_path        = NULL;\n   path_id->real_path_hash      = 0;\n   path_id->archive_path_hash   = 0;\n   path_id->is_archive          = false;\n   path_id->is_in_archive       = false;\n\n   if (!string_is_empty(path))\n   {\n      char real_path[PATH_MAX_LENGTH];\n      const char *archive_delim = NULL;\n      /* Get real path */\n      strlcpy(real_path, path, sizeof(real_path));\n      playlist_resolve_path(PLAYLIST_SAVE, false, real_path,\n            sizeof(real_path));\n\n      path_id->real_path      = strdup(real_path);\n      path_id->real_path_hash = playlist_path_hash(real_path);\n\n      /* Check archive status */\n      path_id->is_archive     = path_is_compressed_file(real_path);\n      archive_delim           = path_get_archive_delim(real_path);\n\n      /* If path refers to a file inside an archive,\n       * extract the path of the parent archive */\n      if (archive_delim)\n      {\n         char archive_path[PATH_MAX_LENGTH];\n         size_t _len                 = (1 + archive_delim - real_path);\n         if (_len >= PATH_MAX_LENGTH)\n            _len                     = PATH_MAX_LENGTH;\n         strlcpy(archive_path, real_path, _len * sizeof(char));\n\n         path_id->archive_path       = strdup(archive_path);\n         path_id->archive_path_hash  = playlist_path_hash(archive_path);\n         path_id->is_in_archive      = true;\n      }\n      else if (path_id->is_archive)\n      {\n         path_id->archive_path       = path_id->real_path;\n         path_id->archive_path_hash  = path_id->real_path_hash;\n      }\n   }\n\n   return path_id;\n}\n\n/**\n * playlist_path_equal:\n * @real_path           : 'Real' search path, generated by path_resolve_realpath()\n * @entry_path          : Existing playlist entry 'path' value\n *\n * Returns 'true' if real_path matches entry_path\n * (Taking into account relative paths, case insensitive\n * filesystems, 'incomplete' archive paths)\n **/\nstatic bool playlist_path_equal(const char *real_path,\n      const char *entry_path, const playlist_config_t *config)\n{\n   bool real_path_is_compressed;\n   bool entry_real_path_is_compressed;\n   char entry_real_path[PATH_MAX_LENGTH];\n\n   /* Sanity check */\n   if (   string_is_empty(real_path)\n       || string_is_empty(entry_path)\n       || !config)\n      return false;\n\n   /* Get entry 'real' path */\n   strlcpy(entry_real_path, entry_path, sizeof(entry_real_path));\n   playlist_resolve_path(PLAYLIST_LOAD, false, entry_real_path, sizeof(entry_real_path));\n   path_resolve_realpath(entry_real_path, sizeof(entry_real_path), true);\n\n   if (string_is_empty(entry_real_path))\n      return false;\n\n   /* First pass comparison */\n#ifdef _WIN32\n   /* Handle case-insensitive operating systems*/\n   if (string_is_equal_noncase(real_path, entry_real_path))\n      return true;\n#else\n   if (string_is_equal(real_path, entry_real_path))\n      return true;\n#endif\n\n#ifdef RARCH_INTERNAL\n   /* If fuzzy matching is disabled, we can give up now */\n   if (!config->fuzzy_archive_match)\n      return false;\n#endif\n\n   /* If we reach this point, we have to work\n    * harder...\n    * Need to handle a rather awkward archive file\n    * case where:\n    * - playlist path contains a properly formatted\n    *   [archive_path][delimiter][rom_file]\n    * - search path is just [archive_path]\n    * ...or vice versa.\n    * This pretty much always happens when a playlist\n    * is generated via scan content (which handles the\n    * archive paths correctly), but the user subsequently\n    * loads an archive file via the command line or some\n    * external launcher (where the [delimiter][rom_file]\n    * part is almost always omitted) */\n   real_path_is_compressed           = path_is_compressed_file(real_path);\n   entry_real_path_is_compressed     = path_is_compressed_file(entry_real_path);\n\n   if (   (real_path_is_compressed  && !entry_real_path_is_compressed)\n       || (!real_path_is_compressed &&  entry_real_path_is_compressed))\n   {\n      const char *compressed_path_a  = real_path_is_compressed ? real_path       : entry_real_path;\n      const char *full_path          = real_path_is_compressed ? entry_real_path : real_path;\n      const char *delim              = path_get_archive_delim(full_path);\n\n      if (delim)\n      {\n         char compressed_path_b[PATH_MAX_LENGTH];\n         unsigned len = (unsigned)(1 + delim - full_path);\n\n         strlcpy(compressed_path_b, full_path,\n               (len < PATH_MAX_LENGTH ? len : PATH_MAX_LENGTH) * sizeof(char));\n\n#ifdef _WIN32\n         /* Handle case-insensitive operating systems*/\n         if (string_is_equal_noncase(compressed_path_a, compressed_path_b))\n            return true;\n#else\n         if (string_is_equal(compressed_path_a, compressed_path_b))\n            return true;\n#endif\n      }\n   }\n\n   return false;\n}\n\n/**\n * playlist_path_matches_entry:\n * @path_id           : Path identity, containing 'real' path,\n *                      hash and archive status information\n * @entry             : Playlist entry to compare with path_id\n *\n * Returns 'true' if 'path_id' matches path information\n * contained in specified 'entry'. Will update path_id\n * cache inside specified 'entry', if not already present.\n **/\nstatic bool playlist_path_matches_entry(playlist_path_id_t *path_id,\n      struct playlist_entry *entry, const playlist_config_t *config)\n{\n   /* Sanity check */\n   if (!path_id || !entry || !config)\n      return false;\n\n   /* Check whether entry contains a path ID cache */\n   if (!entry->path_id)\n   {\n      if (!(entry->path_id = playlist_path_id_init(entry->path)))\n         return false;\n   }\n\n   /* Ensure we have valid real_path strings */\n   if (   string_is_empty(path_id->real_path)\n       || string_is_empty(entry->path_id->real_path))\n      return false;\n\n   /* First pass comparison */\n   if (path_id->real_path_hash == entry->path_id->real_path_hash)\n   {\n#ifdef _WIN32\n      /* Handle case-insensitive operating systems*/\n      if (string_is_equal_noncase(path_id->real_path,\n            entry->path_id->real_path))\n         return true;\n#else\n      if (string_is_equal(path_id->real_path, entry->path_id->real_path))\n         return true;\n#endif\n   }\n\n#ifdef RARCH_INTERNAL\n   /* If fuzzy matching is disabled, we can give up now */\n   if (!config->fuzzy_archive_match)\n      return false;\n#endif\n\n   /* If we reach this point, we have to work\n    * harder...\n    * Need to handle a rather awkward archive file\n    * case where:\n    * - playlist path contains a properly formatted\n    *   [archive_path][delimiter][rom_file]\n    * - search path is just [archive_path]\n    * ...or vice versa.\n    * This pretty much always happens when a playlist\n    * is generated via scan content (which handles the\n    * archive paths correctly), but the user subsequently\n    * loads an archive file via the command line or some\n    * external launcher (where the [delimiter][rom_file]\n    * part is almost always omitted) */\n   if (   ((path_id->is_archive        && !path_id->is_in_archive)        && entry->path_id->is_in_archive)\n       || ((entry->path_id->is_archive && !entry->path_id->is_in_archive) && path_id->is_in_archive))\n   {\n      /* Ensure we have valid parent archive path\n       * strings */\n      if (   string_is_empty(path_id->archive_path)\n          || string_is_empty(entry->path_id->archive_path))\n         return false;\n\n      if (path_id->archive_path_hash == entry->path_id->archive_path_hash)\n      {\n#ifdef _WIN32\n         /* Handle case-insensitive operating systems*/\n         if (string_is_equal_noncase(path_id->archive_path,\n               entry->path_id->archive_path))\n            return true;\n#else\n         if (string_is_equal(path_id->archive_path,\n               entry->path_id->archive_path))\n            return true;\n#endif\n      }\n   }\n\n   return false;\n}\n\n/**\n * playlist_core_path_equal:\n * @real_core_path  : 'Real' search path, generated by path_resolve_realpath()\n * @entry_core_path : Existing playlist entry 'core path' value\n * @config          : Playlist config parameters\n *\n * Returns 'true' if real_core_path matches entry_core_path\n * (Taking into account relative paths, case insensitive\n * filesystems)\n **/\nstatic bool playlist_core_path_equal(const char *real_core_path,\n      const char *entry_core_path, const playlist_config_t *config)\n{\n   char entry_real_core_path[PATH_MAX_LENGTH];\n\n   /* Sanity check */\n   if (     string_is_empty(real_core_path)\n         || string_is_empty(entry_core_path))\n      return false;\n\n   /* Get entry 'real' core path */\n   strlcpy(entry_real_core_path, entry_core_path, sizeof(entry_real_core_path));\n   if (   !string_is_equal(entry_real_core_path, FILE_PATH_DETECT)\n       && !string_is_equal(entry_real_core_path, FILE_PATH_BUILTIN))\n      playlist_resolve_path(PLAYLIST_SAVE, true, entry_real_core_path,\n            sizeof(entry_real_core_path));\n\n   if (!string_is_empty(entry_real_core_path))\n   {\n#ifdef _WIN32\n      /* Handle case-insensitive operating systems*/\n      if (string_is_equal_noncase(real_core_path, entry_real_core_path))\n         return true;\n#else\n      if (string_is_equal(real_core_path, entry_real_core_path))\n         return true;\n#endif\n      if (     config->autofix_paths\n            && core_info_core_file_id_is_equal(real_core_path, entry_core_path))\n         return true;\n   }\n\n   return false;\n}\n\nuint32_t playlist_get_size(playlist_t *playlist)\n{\n   if (!playlist)\n      return 0;\n   return (uint32_t)RBUF_LEN(playlist->entries);\n}\n\nchar *playlist_get_conf_path(playlist_t *playlist)\n{\n   if (!playlist)\n      return NULL;\n   return playlist->config.path;\n}\n\n/**\n * playlist_get_index:\n * @playlist            : Playlist handle.\n * @idx                 : Index of playlist entry.\n * @path                : Path of playlist entry.\n * @core_path           : Core path of playlist entry.\n * @core_name           : Core name of playlist entry.\n *\n * Gets values of playlist index:\n **/\nvoid playlist_get_index(playlist_t *playlist,\n      size_t idx,\n      const struct playlist_entry **entry)\n{\n   if (!playlist || !entry || (idx >= RBUF_LEN(playlist->entries)))\n      return;\n\n   *entry = &playlist->entries[idx];\n}\n\n/**\n * playlist_free_entry:\n * @entry               : Playlist entry handle.\n *\n * Frees playlist entry.\n **/\nstatic void playlist_free_entry(struct playlist_entry *entry)\n{\n   if (!entry)\n      return;\n\n   if (entry->path)\n      free(entry->path);\n   if (entry->label)\n      free(entry->label);\n   if (entry->core_path)\n      free(entry->core_path);\n   if (entry->core_name)\n      free(entry->core_name);\n   if (entry->db_name)\n      free(entry->db_name);\n   if (entry->crc32)\n      free(entry->crc32);\n   if (entry->subsystem_ident)\n      free(entry->subsystem_ident);\n   if (entry->subsystem_name)\n      free(entry->subsystem_name);\n   if (entry->runtime_str)\n      free(entry->runtime_str);\n   if (entry->last_played_str)\n      free(entry->last_played_str);\n   if (entry->subsystem_roms)\n      string_list_free(entry->subsystem_roms);\n   if (entry->path_id)\n      playlist_path_id_free(entry->path_id);\n\n   entry->path               = NULL;\n   entry->label              = NULL;\n   entry->core_path          = NULL;\n   entry->core_name          = NULL;\n   entry->db_name            = NULL;\n   entry->crc32              = NULL;\n   entry->subsystem_ident    = NULL;\n   entry->subsystem_name     = NULL;\n   entry->runtime_str        = NULL;\n   entry->last_played_str    = NULL;\n   entry->subsystem_roms     = NULL;\n   entry->path_id            = NULL;\n   entry->entry_slot         = 0;\n   entry->runtime_status     = PLAYLIST_RUNTIME_UNKNOWN;\n   entry->runtime_hours      = 0;\n   entry->runtime_minutes    = 0;\n   entry->runtime_seconds    = 0;\n   entry->last_played_year   = 0;\n   entry->last_played_month  = 0;\n   entry->last_played_day    = 0;\n   entry->last_played_hour   = 0;\n   entry->last_played_minute = 0;\n   entry->last_played_second = 0;\n}\n\n/**\n * playlist_delete_index:\n * @playlist            : Playlist handle.\n * @idx                 : Index of playlist entry.\n *\n * Delete the entry at the index:\n **/\nvoid playlist_delete_index(playlist_t *playlist,\n      size_t idx)\n{\n   size_t _len;\n   struct playlist_entry *entry_to_delete;\n\n   if (!playlist)\n      return;\n\n   _len = RBUF_LEN(playlist->entries);\n   if (idx >= _len)\n      return;\n\n   /* Free unwanted entry */\n   entry_to_delete = (struct playlist_entry *)(playlist->entries + idx);\n   if (entry_to_delete)\n      playlist_free_entry(entry_to_delete);\n\n   /* Shift remaining entries to fill the gap */\n   memmove(playlist->entries + idx, playlist->entries + idx + 1,\n         (_len - 1 - idx) * sizeof(struct playlist_entry));\n\n   RBUF_RESIZE(playlist->entries, _len - 1);\n\n   playlist->flags |= CNT_PLAYLIST_FLG_MOD;\n}\n\n/**\n * playlist_delete_by_path:\n * @playlist            : Playlist handle.\n * @search_path         : Content path.\n *\n * Deletes all entries with content path\n * matching 'search_path'\n **/\nvoid playlist_delete_by_path(playlist_t *playlist,\n      const char *search_path)\n{\n   playlist_path_id_t *path_id = NULL;\n   size_t i                    = 0;\n\n   if (!playlist || string_is_empty(search_path))\n      return;\n\n   if (!(path_id = playlist_path_id_init(search_path)))\n      return;\n\n   while (i < RBUF_LEN(playlist->entries))\n   {\n      if (!playlist_path_matches_entry(path_id,\n            &playlist->entries[i], &playlist->config))\n      {\n         i++;\n         continue;\n      }\n\n      /* Paths are equal - delete entry */\n      playlist_delete_index(playlist, i);\n\n      /* Entries are shifted up by the delete\n       * operation - *do not* increment i */\n   }\n\n   playlist_path_id_free(path_id);\n}\n\nvoid playlist_get_index_by_path(playlist_t *playlist,\n      const char *search_path,\n      const struct playlist_entry **entry)\n{\n   playlist_path_id_t *path_id = NULL;\n   size_t i, len;\n\n   if (!playlist || !entry || string_is_empty(search_path))\n      return;\n\n   if (!(path_id = playlist_path_id_init(search_path)))\n      return;\n\n   for (i = 0, len = RBUF_LEN(playlist->entries); i < len; i++)\n   {\n      if (!playlist_path_matches_entry(path_id,\n            &playlist->entries[i], &playlist->config))\n         continue;\n\n      *entry = &playlist->entries[i];\n      break;\n   }\n\n   playlist_path_id_free(path_id);\n}\n\nbool playlist_entry_exists(playlist_t *playlist,\n      const char *path)\n{\n   playlist_path_id_t *path_id = NULL;\n   size_t i, len;\n\n   if (!playlist || string_is_empty(path))\n      return false;\n\n   if (!(path_id = playlist_path_id_init(path)))\n      return false;\n\n   for (i = 0, len = RBUF_LEN(playlist->entries); i < len; i++)\n   {\n      if (playlist_path_matches_entry(path_id,\n            &playlist->entries[i], &playlist->config))\n      {\n         playlist_path_id_free(path_id);\n         return true;\n      }\n   }\n\n   playlist_path_id_free(path_id);\n   return false;\n}\n\nvoid playlist_update(playlist_t *playlist, size_t idx,\n      const struct playlist_entry *update_entry)\n{\n   struct playlist_entry *entry = NULL;\n\n   if (!playlist || idx >= RBUF_LEN(playlist->entries))\n      return;\n\n   entry            = &playlist->entries[idx];\n\n   if (update_entry->path && (update_entry->path != entry->path))\n   {\n      if (entry->path)\n         free(entry->path);\n      entry->path        = strdup(update_entry->path);\n\n      if (entry->path_id)\n      {\n         playlist_path_id_free(entry->path_id);\n         entry->path_id  = NULL;\n      }\n\n      playlist->flags |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->label && (update_entry->label != entry->label))\n   {\n      if (entry->label)\n         free(entry->label);\n      entry->label       = strdup(update_entry->label);\n      playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->core_path && (update_entry->core_path != entry->core_path))\n   {\n      if (entry->core_path)\n         free(entry->core_path);\n      entry->core_path   = strdup(update_entry->core_path);\n      playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->core_name && (update_entry->core_name != entry->core_name))\n   {\n      if (entry->core_name)\n         free(entry->core_name);\n      entry->core_name   = strdup(update_entry->core_name);\n      playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->db_name && (update_entry->db_name != entry->db_name))\n   {\n      if (entry->db_name)\n         free(entry->db_name);\n      entry->db_name     = strdup(update_entry->db_name);\n      playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->crc32 && (update_entry->crc32 != entry->crc32))\n   {\n      if (entry->crc32)\n         free(entry->crc32);\n      entry->crc32       = strdup(update_entry->crc32);\n      playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n}\n\nvoid playlist_update_runtime(playlist_t *playlist, size_t idx,\n      const struct playlist_entry *update_entry,\n      bool register_update)\n{\n   struct playlist_entry *entry = NULL;\n\n   if (!playlist || idx >= RBUF_LEN(playlist->entries))\n      return;\n\n   entry            = &playlist->entries[idx];\n\n   if (update_entry->path && (update_entry->path != entry->path))\n   {\n      if (entry->path)\n         free(entry->path);\n      entry->path        = strdup(update_entry->path);\n\n      if (entry->path_id)\n      {\n         playlist_path_id_free(entry->path_id);\n         entry->path_id  = NULL;\n      }\n\n      if (register_update)\n         playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->core_path && (update_entry->core_path != entry->core_path))\n   {\n      if (entry->core_path)\n         free(entry->core_path);\n      entry->core_path      = strdup(update_entry->core_path);\n      if (register_update)\n         playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->runtime_status != entry->runtime_status)\n   {\n      entry->runtime_status = update_entry->runtime_status;\n      if (register_update)\n         playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->runtime_hours != entry->runtime_hours)\n   {\n      entry->runtime_hours = update_entry->runtime_hours;\n      if (register_update)\n         playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->runtime_minutes != entry->runtime_minutes)\n   {\n      entry->runtime_minutes = update_entry->runtime_minutes;\n      if (register_update)\n         playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->runtime_seconds != entry->runtime_seconds)\n   {\n      entry->runtime_seconds = update_entry->runtime_seconds;\n      if (register_update)\n         playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->last_played_year != entry->last_played_year)\n   {\n      entry->last_played_year = update_entry->last_played_year;\n      if (register_update)\n         playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->last_played_month != entry->last_played_month)\n   {\n      entry->last_played_month = update_entry->last_played_month;\n      if (register_update)\n         playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->last_played_day != entry->last_played_day)\n   {\n      entry->last_played_day = update_entry->last_played_day;\n      if (register_update)\n         playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->last_played_hour != entry->last_played_hour)\n   {\n      entry->last_played_hour = update_entry->last_played_hour;\n      if (register_update)\n         playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->last_played_minute != entry->last_played_minute)\n   {\n      entry->last_played_minute = update_entry->last_played_minute;\n      if (register_update)\n         playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->last_played_second != entry->last_played_second)\n   {\n      entry->last_played_second = update_entry->last_played_second;\n      if (register_update)\n         playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->runtime_str && (update_entry->runtime_str != entry->runtime_str))\n   {\n      if (entry->runtime_str)\n         free(entry->runtime_str);\n      entry->runtime_str    = strdup(update_entry->runtime_str);\n      if (register_update)\n         playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   }\n\n   if (update_entry->last_played_str && (update_entry->last_played_str != entry->last_played_str))\n   {\n      if (entry->last_played_str)\n         free(entry->last_played_str);\n      entry->last_played_str = NULL;\n      entry->last_played_str = strdup(update_entry->last_played_str);\n      if (register_update)\n         playlist->flags    |= CNT_PLAYLIST_FLG_MOD;\n   }\n}\n\nbool playlist_push_runtime(playlist_t *playlist,\n      const struct playlist_entry *entry)\n{\n   playlist_path_id_t *path_id = NULL;\n   size_t i, len;\n   char real_core_path[PATH_MAX_LENGTH];\n\n   if (!playlist || !entry)\n      goto error;\n\n   if (string_is_empty(entry->core_path))\n   {\n      RARCH_ERR(\"Cannot push NULL or empty core path into the playlist.\\n\");\n      goto error;\n   }\n\n   /* Get path ID */\n   if (!(path_id = playlist_path_id_init(entry->path)))\n      goto error;\n\n   /* Get 'real' core path */\n   strlcpy(real_core_path, entry->core_path, sizeof(real_core_path));\n   if (   !string_is_equal(real_core_path, FILE_PATH_DETECT)\n       && !string_is_equal(real_core_path, FILE_PATH_BUILTIN))\n      playlist_resolve_path(PLAYLIST_SAVE, true, real_core_path,\n             sizeof(real_core_path));\n\n   if (string_is_empty(real_core_path))\n   {\n      RARCH_ERR(\"Cannot push NULL or empty core path into the playlist.\\n\");\n      goto error;\n   }\n\n   len = RBUF_LEN(playlist->entries);\n   for (i = 0; i < len; i++)\n   {\n      struct playlist_entry tmp;\n      bool equal_path  = (string_is_empty(path_id->real_path)\n            && string_is_empty(playlist->entries[i].path));\n\n      equal_path       = equal_path || playlist_path_matches_entry(\n            path_id, &playlist->entries[i], &playlist->config);\n\n      if (!equal_path)\n         continue;\n\n      /* Core name can have changed while still being the same core.\n       * Differentiate based on the core path only. */\n      if (!playlist_core_path_equal(real_core_path, playlist->entries[i].core_path, &playlist->config))\n         continue;\n\n      /* If top entry, we don't want to push a new entry since\n       * the top and the entry to be pushed are the same. */\n      if (i == 0)\n         goto error;\n\n      /* Seen it before, bump to top. */\n      tmp = playlist->entries[i];\n      memmove(playlist->entries + 1, playlist->entries,\n            i * sizeof(struct playlist_entry));\n      playlist->entries[0] = tmp;\n\n      goto success;\n   }\n\n   if (playlist->config.capacity == 0)\n      goto error;\n\n   if (len == playlist->config.capacity)\n   {\n      struct playlist_entry *last_entry = &playlist->entries[len - 1];\n      playlist_free_entry(last_entry);\n      len--;\n   }\n   else\n   {\n      /* Allocate memory to fit one more item and resize the buffer */\n      if (!RBUF_TRYFIT(playlist->entries, len + 1))\n         goto error; /* out of memory */\n      RBUF_RESIZE(playlist->entries, len + 1);\n   }\n\n   if (playlist->entries)\n   {\n      memmove(playlist->entries + 1, playlist->entries,\n            len * sizeof(struct playlist_entry));\n\n      playlist->entries[0].path               = NULL;\n      playlist->entries[0].core_path          = NULL;\n\n      if (!string_is_empty(path_id->real_path))\n         playlist->entries[0].path            = strdup(path_id->real_path);\n      playlist->entries[0].path_id            = path_id;\n      path_id                                 = NULL;\n\n      if (!string_is_empty(real_core_path))\n         playlist->entries[0].core_path       = strdup(real_core_path);\n\n      playlist->entries[0].runtime_status     = entry->runtime_status;\n      playlist->entries[0].runtime_hours      = entry->runtime_hours;\n      playlist->entries[0].runtime_minutes    = entry->runtime_minutes;\n      playlist->entries[0].runtime_seconds    = entry->runtime_seconds;\n      playlist->entries[0].last_played_year   = entry->last_played_year;\n      playlist->entries[0].last_played_month  = entry->last_played_month;\n      playlist->entries[0].last_played_day    = entry->last_played_day;\n      playlist->entries[0].last_played_hour   = entry->last_played_hour;\n      playlist->entries[0].last_played_minute = entry->last_played_minute;\n      playlist->entries[0].last_played_second = entry->last_played_second;\n\n      playlist->entries[0].runtime_str        = NULL;\n      playlist->entries[0].last_played_str    = NULL;\n\n      if (!string_is_empty(entry->runtime_str))\n         playlist->entries[0].runtime_str     = strdup(entry->runtime_str);\n      if (!string_is_empty(entry->last_played_str))\n         playlist->entries[0].last_played_str = strdup(entry->last_played_str);\n   }\n\nsuccess:\n   if (path_id)\n      playlist_path_id_free(path_id);\n   playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   return true;\n\nerror:\n   if (path_id)\n      playlist_path_id_free(path_id);\n   return false;\n}\n\nvoid playlist_update_thumbnail_name_flag(playlist_t *playlist, size_t idx,\n      enum playlist_thumbnail_name_flags thumbnail_flags)\n{\n   struct playlist_entry *entry = NULL;\n\n   if (!playlist || idx >= RBUF_LEN(playlist->entries))\n      return;\n\n   entry                   = &playlist->entries[idx];\n   entry->thumbnail_flags |= thumbnail_flags;\n}\n\nenum playlist_thumbnail_name_flags playlist_get_curr_thumbnail_name_flag(playlist_t *playlist, size_t idx)\n{\n   struct playlist_entry *entry = NULL;\n\n   if (!playlist || idx >= RBUF_LEN(playlist->entries))\n      return    PLAYLIST_THUMBNAIL_FLAG_NONE;\n\n   entry = &playlist->entries[idx];\n   return entry->thumbnail_flags;\n}\n\n\nenum playlist_thumbnail_name_flags playlist_get_next_thumbnail_name_flag(playlist_t *playlist, size_t idx)\n{\n   struct playlist_entry *entry = NULL;\n\n   if (!playlist || idx >= RBUF_LEN(playlist->entries))\n      return    PLAYLIST_THUMBNAIL_FLAG_NONE;\n   entry = &playlist->entries[idx];\n\n   if (entry->thumbnail_flags & PLAYLIST_THUMBNAIL_FLAG_SHORT_NAME)\n            return PLAYLIST_THUMBNAIL_FLAG_NONE;\n   if (entry->thumbnail_flags & PLAYLIST_THUMBNAIL_FLAG_STD_NAME)\n            return PLAYLIST_THUMBNAIL_FLAG_SHORT_NAME;\n   if (entry->thumbnail_flags & PLAYLIST_THUMBNAIL_FLAG_FULL_NAME)\n            return PLAYLIST_THUMBNAIL_FLAG_STD_NAME;\n   /* Special case: only one entry in playlist, only one query is possible\n    * as flag swapping relies on going back and forth among entries\n    * so just use the most likely version here */\n   if (idx == 0 && RBUF_LEN(playlist->entries) == 1)\n            return PLAYLIST_THUMBNAIL_FLAG_STD_NAME;\n   return PLAYLIST_THUMBNAIL_FLAG_FULL_NAME;\n}\n\n\n/**\n * playlist_resolve_path:\n * @mode      : PLAYLIST_LOAD or PLAYLIST_SAVE\n * @is_core   : Set true if path to be resolved is a core file\n * @path      : The path to be modified\n *\n * Resolves the path of an item, such as the content path or path to the core, to a format\n * appropriate for saving or loading depending on the @mode parameter\n *\n * Can be platform specific. File paths for saving can be abbreviated to avoid saving absolute\n * paths, as the base directory (home or application dir) may change after each subsequent\n * install (iOS)\n**/\nvoid playlist_resolve_path(enum playlist_file_mode mode,\n      bool is_core, char *s, size_t len)\n{\n#ifdef HAVE_COCOATOUCH\n   char tmp[PATH_MAX_LENGTH];\n   int _len = 0;\n\n   if (mode == PLAYLIST_LOAD)\n   {\n      if (   is_core\n          && string_starts_with(s, \":/modules/\")\n          && string_ends_with(s, \".dylib\"))\n      {\n         /* iOS cores used to be packaged as .dylib files in the modules\n          * directory; App Store rules require turning them into Frameworks and\n          * putting them in the Frameworks directory. Because some playlists\n          * include the old core path, we'll translate it here.\n          */\n         s[string_index_last_occurance(s, '.')] = '\\0';\n         if (string_ends_with(s, \"_ios\"))\n            s[string_index_last_occurance(s, '_')] = '\\0';\n         _len += strlcpy(tmp + _len, \":/Frameworks/\", STRLEN_CONST(\":/Frameworks/\") + 1);\n         _len += strlcpy(tmp + _len, s + STRLEN_CONST(\":/modules/\"), sizeof(tmp) - _len);\n         /* iOS framework names, to quote Apple:\n          * \"must contain only alphanumerics, dots, hyphens and must not end with a dot.\"\n          *\n          * Since core names include underscore, which is not allowed, but not dot,\n          * which is, we change underscore to dot.\n          */\n         string_replace_all_chars(tmp, '_', '.');\n         strlcpy(tmp + _len, \".framework\", sizeof(tmp));\n         fill_pathname_expand_special(s, tmp, len);\n      }\n      else\n      {\n         fill_pathname_expand_special(tmp, s, sizeof(tmp));\n         strlcpy(s, tmp, len);\n      }\n   }\n   else\n   {\n      /* iOS needs to call realpath here since the call\n       * above fails due to possibly buffer related issues.\n       * Try to expand the path to ensure that it gets saved\n       * correctly. The path can be abbreviated if saving to\n       * a playlist from another playlist (ex: content history to favorites)\n       */\n      char tmp2[PATH_MAX_LENGTH];\n      fill_pathname_expand_special(tmp, s, sizeof(tmp));\n      realpath(tmp, tmp2);\n      fill_pathname_abbreviate_special(s, tmp2, len);\n   }\n#else\n   bool resolve_symlinks = true;\n\n   if (mode == PLAYLIST_LOAD)\n      return;\n\n#if defined(ANDROID)\n   /* Can't resolve symlinks when dealing with cores\n    * installed via play feature delivery, because the\n    * source files have non-standard file names (which\n    * will not be recognised by regular core handling\n    * routines) */\n   if (is_core)\n      resolve_symlinks = !play_feature_delivery_enabled();\n#endif\n\n   path_resolve_realpath(s, len, resolve_symlinks);\n#endif\n}\n\n/**\n * playlist_content_path_is_valid:\n * @path      : Content path\n *\n * Checks whether specified playlist content path\n * refers to an existent file. Handles all playlist\n * content path 'types' (i.e. can validate paths\n * referencing files inside archives).\n *\n * Returns true if file referenced by content\n * path exists on the host filesystem.\n **/\nbool playlist_content_path_is_valid(const char *path)\n{\n   /* Sanity check */\n   if (string_is_empty(path))\n      return false;\n\n   /* If content is inside an archive, special\n    * handling is required... */\n   if (path_contains_compressed_file(path))\n   {\n      char archive_path[PATH_MAX_LENGTH];\n      const char *delim                  = path_get_archive_delim(path);\n      size_t _len                        = 0;\n      struct string_list *archive_list   = NULL;\n      const char *content_file           = NULL;\n      bool content_found                 = false;\n\n      if (!delim)\n         return false;\n\n      /* Get path of 'parent' archive file */\n      _len = (size_t)(1 + delim - path);\n      if (_len < PATH_MAX_LENGTH)\n         strlcpy(archive_path, path, _len * sizeof(char));\n      else\n         strlcpy(archive_path, path,\n               PATH_MAX_LENGTH * sizeof(char));\n\n      /* Check if archive itself exists */\n      if (!path_is_valid(archive_path))\n         return false;\n\n      /* Check if file exists inside archive */\n      if (!(archive_list = file_archive_get_file_list(archive_path, NULL)))\n         return false;\n\n      /* > Get playlist entry content file name\n       *   (sans archive file path) */\n      content_file = delim;\n      content_file++;\n\n      if (!string_is_empty(content_file))\n      {\n         size_t i;\n\n         /* > Loop over archive file contents */\n         for (i = 0; i < archive_list->size; i++)\n         {\n            const char *archive_file = archive_list->elems[i].data;\n\n            if (string_is_empty(archive_file))\n               continue;\n\n            if (string_is_equal(content_file, archive_file))\n            {\n               content_found = true;\n               break;\n            }\n         }\n      }\n\n      /* Clean up */\n      string_list_free(archive_list);\n\n      return content_found;\n   }\n   /* This is a 'normal' path - just check if\n    * it's valid */\n   return path_is_valid(path);\n}\n\n/**\n * playlist_push:\n * @playlist           : Playlist handle.\n *\n * Push entry to top of playlist.\n **/\nbool playlist_push(playlist_t *playlist,\n      const struct playlist_entry *entry)\n{\n   size_t i, _len;\n   char real_core_path[PATH_MAX_LENGTH];\n   playlist_path_id_t *path_id = NULL;\n   const char *core_name       = entry->core_name;\n   bool entry_updated          = false;\n\n   if (!playlist || !entry)\n      goto error;\n\n   if (string_is_empty(entry->core_path))\n   {\n      RARCH_ERR(\"Cannot push NULL or empty core path into the playlist.\\n\");\n      goto error;\n   }\n\n   /* Get path ID */\n   if (!(path_id = playlist_path_id_init(entry->path)))\n      goto error;\n\n   /* Get 'real' core path */\n   strlcpy(real_core_path, entry->core_path, sizeof(real_core_path));\n   if (   !string_is_equal(real_core_path, FILE_PATH_DETECT)\n       && !string_is_equal(real_core_path, FILE_PATH_BUILTIN))\n      playlist_resolve_path(PLAYLIST_SAVE, true, real_core_path,\n             sizeof(real_core_path));\n\n   if (string_is_empty(real_core_path))\n   {\n      RARCH_ERR(\"Cannot push NULL or empty core path into the playlist.\\n\");\n      goto error;\n   }\n\n   if (string_is_empty(core_name))\n   {\n      static char base_path[NAME_MAX_LENGTH] = {0};\n      fill_pathname(base_path, path_basename(real_core_path), \"\",\n            sizeof(base_path));\n\n      core_name = base_path;\n\n      if (string_is_empty(core_name))\n      {\n         RARCH_ERR(\"Cannot push NULL or empty core name into the playlist.\\n\");\n         goto error;\n      }\n   }\n\n   _len = RBUF_LEN(playlist->entries);\n   for (i = 0; i < _len; i++)\n   {\n      struct playlist_entry tmp;\n      bool equal_path  = (string_is_empty(path_id->real_path)\n                       && string_is_empty(playlist->entries[i].path));\n\n      equal_path       = equal_path || playlist_path_matches_entry(\n            path_id, &playlist->entries[i], &playlist->config);\n\n      if (!equal_path)\n         continue;\n\n      /* Core name can have changed while still being the same core.\n       * Differentiate based on the core path only. */\n      if (!playlist_core_path_equal(real_core_path, playlist->entries[i].core_path, &playlist->config))\n         continue;\n\n      if (     !string_is_empty(entry->subsystem_ident)\n            && !string_is_empty(playlist->entries[i].subsystem_ident)\n            && !string_is_equal(playlist->entries[i].subsystem_ident, entry->subsystem_ident))\n         continue;\n\n      if (      string_is_empty(entry->subsystem_ident)\n            && !string_is_empty(playlist->entries[i].subsystem_ident))\n         continue;\n\n      if (    !string_is_empty(entry->subsystem_ident)\n            && string_is_empty(playlist->entries[i].subsystem_ident))\n         continue;\n\n      if (     !string_is_empty(entry->subsystem_name)\n            && !string_is_empty(playlist->entries[i].subsystem_name)\n            && !string_is_equal(playlist->entries[i].subsystem_name, entry->subsystem_name))\n         continue;\n\n      if (      string_is_empty(entry->subsystem_name)\n            && !string_is_empty(playlist->entries[i].subsystem_name))\n         continue;\n\n      if (     !string_is_empty(entry->subsystem_name)\n            &&  string_is_empty(playlist->entries[i].subsystem_name))\n         continue;\n\n      if (entry->subsystem_roms)\n      {\n         unsigned j;\n         const struct string_list *roms = playlist->entries[i].subsystem_roms;\n         bool                   unequal = false;\n\n         if (entry->subsystem_roms->size != roms->size)\n            continue;\n\n         for (j = 0; j < entry->subsystem_roms->size; j++)\n         {\n            char real_rom_path[PATH_MAX_LENGTH];\n\n            if (!string_is_empty(entry->subsystem_roms->elems[j].data))\n            {\n               strlcpy(real_rom_path, entry->subsystem_roms->elems[j].data, sizeof(real_rom_path));\n               path_resolve_realpath(real_rom_path, sizeof(real_rom_path), true);\n            }\n            else\n               real_rom_path[0] = '\\0';\n\n            if (!playlist_path_equal(real_rom_path, roms->elems[j].data,\n                     &playlist->config))\n            {\n               unequal = true;\n               break;\n            }\n         }\n\n         if (unequal)\n            continue;\n      }\n\n      if (playlist->entries[i].entry_slot != entry->entry_slot)\n      {\n         playlist->entries[i].entry_slot  = entry->entry_slot;\n         entry_updated                    = true;\n      }\n\n      /* If content was previously loaded via file browser\n       * or command line, certain entry values will be missing.\n       * If we are now loading the same content from a playlist,\n       * fill in any blanks */\n      if (     !playlist->entries[i].label\n            && !string_is_empty(entry->label))\n      {\n         playlist->entries[i].label       = strdup(entry->label);\n         entry_updated                    = true;\n      }\n      if (     !playlist->entries[i].crc32\n            && !string_is_empty(entry->crc32))\n      {\n         playlist->entries[i].crc32       = strdup(entry->crc32);\n         entry_updated                    = true;\n      }\n      if (     !playlist->entries[i].db_name\n            && !string_is_empty(entry->db_name))\n      {\n         playlist->entries[i].db_name     = strdup(entry->db_name);\n         entry_updated                    = true;\n      }\n\n      /* If top entry, we don't want to push a new entry since\n       * the top and the entry to be pushed are the same. */\n      if (i == 0)\n      {\n         if (entry_updated)\n            goto success;\n\n         goto error;\n      }\n\n      /* Seen it before, bump to top. */\n      tmp = playlist->entries[i];\n      memmove(playlist->entries + 1, playlist->entries,\n            i * sizeof(struct playlist_entry));\n      playlist->entries[0] = tmp;\n\n      goto success;\n   }\n\n   if (playlist->config.capacity == 0)\n      goto error;\n\n   if (_len == playlist->config.capacity)\n   {\n      struct playlist_entry *last_entry = &playlist->entries[_len - 1];\n      playlist_free_entry(last_entry);\n      _len--;\n   }\n   else\n   {\n      /* Allocate memory to fit one more item and resize the buffer */\n      if (!RBUF_TRYFIT(playlist->entries, _len + 1))\n         goto error; /* out of memory */\n      RBUF_RESIZE(playlist->entries, _len + 1);\n   }\n\n   if (playlist->entries)\n   {\n      memmove(playlist->entries + 1, playlist->entries,\n            _len * sizeof(struct playlist_entry));\n\n      playlist->entries[0].path               = NULL;\n      playlist->entries[0].label              = NULL;\n      playlist->entries[0].core_path          = NULL;\n      playlist->entries[0].core_name          = NULL;\n      playlist->entries[0].db_name            = NULL;\n      playlist->entries[0].crc32              = NULL;\n      playlist->entries[0].subsystem_ident    = NULL;\n      playlist->entries[0].subsystem_name     = NULL;\n      playlist->entries[0].runtime_str        = NULL;\n      playlist->entries[0].last_played_str    = NULL;\n      playlist->entries[0].subsystem_roms     = NULL;\n      playlist->entries[0].path_id            = NULL;\n      playlist->entries[0].runtime_status     = PLAYLIST_RUNTIME_UNKNOWN;\n      playlist->entries[0].runtime_hours      = 0;\n      playlist->entries[0].runtime_minutes    = 0;\n      playlist->entries[0].runtime_seconds    = 0;\n      playlist->entries[0].last_played_year   = 0;\n      playlist->entries[0].last_played_month  = 0;\n      playlist->entries[0].last_played_day    = 0;\n      playlist->entries[0].last_played_hour   = 0;\n      playlist->entries[0].last_played_minute = 0;\n      playlist->entries[0].last_played_second = 0;\n\n      if (!string_is_empty(path_id->real_path))\n         playlist->entries[0].path            = strdup(path_id->real_path);\n      playlist->entries[0].path_id            = path_id;\n      path_id                                 = NULL;\n\n      playlist->entries[0].entry_slot         = entry->entry_slot;\n\n      if (!string_is_empty(entry->label))\n         playlist->entries[0].label           = strdup(entry->label);\n      if (!string_is_empty(real_core_path))\n         playlist->entries[0].core_path       = strdup(real_core_path);\n      if (!string_is_empty(core_name))\n         playlist->entries[0].core_name       = strdup(core_name);\n      if (!string_is_empty(entry->db_name))\n         playlist->entries[0].db_name         = strdup(entry->db_name);\n      if (!string_is_empty(entry->crc32))\n         playlist->entries[0].crc32           = strdup(entry->crc32);\n      if (!string_is_empty(entry->subsystem_ident))\n         playlist->entries[0].subsystem_ident = strdup(entry->subsystem_ident);\n      if (!string_is_empty(entry->subsystem_name))\n         playlist->entries[0].subsystem_name  = strdup(entry->subsystem_name);\n\n      if (entry->subsystem_roms)\n      {\n         union string_list_elem_attr attributes = {0};\n\n         playlist->entries[0].subsystem_roms    = string_list_new();\n\n         for (i = 0; i < entry->subsystem_roms->size; i++)\n            string_list_append(playlist->entries[0].subsystem_roms, entry->subsystem_roms->elems[i].data, attributes);\n      }\n   }\n\nsuccess:\n   if (path_id)\n      playlist_path_id_free(path_id);\n   playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n   return true;\n\nerror:\n   if (path_id)\n      playlist_path_id_free(path_id);\n   return false;\n}\n\nvoid playlist_write_runtime_file(playlist_t *playlist)\n{\n   size_t i, _len;\n   intfstream_t *file  = NULL;\n   rjsonwriter_t* writer;\n\n   if (!playlist || !(playlist->flags & CNT_PLAYLIST_FLG_MOD))\n      return;\n\n   if (!(file = intfstream_open_file(playlist->config.path,\n         RETRO_VFS_FILE_ACCESS_WRITE, RETRO_VFS_FILE_ACCESS_HINT_NONE)))\n   {\n      RARCH_ERR(\"Failed to write to playlist file: \\\"%s\\\".\\n\", playlist->config.path);\n      return;\n   }\n\n   if (!(writer = rjsonwriter_open_stream(file)))\n   {\n      RARCH_ERR(\"Failed to create JSON writer\\n\");\n      goto end;\n   }\n\n   rjsonwriter_raw(writer, \"{\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n   rjsonwriter_add_spaces(writer, 2);\n   rjsonwriter_add_string(writer, \"version\");\n   rjsonwriter_raw(writer, \":\", 1);\n   rjsonwriter_raw(writer, \" \", 1);\n   rjsonwriter_add_string(writer, \"1.0\");\n   rjsonwriter_raw(writer, \",\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n   rjsonwriter_add_spaces(writer, 2);\n   rjsonwriter_add_string(writer, \"items\");\n   rjsonwriter_raw(writer, \":\", 1);\n   rjsonwriter_raw(writer, \" \", 1);\n   rjsonwriter_raw(writer, \"[\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n\n   for (i = 0, _len = RBUF_LEN(playlist->entries); i < _len; i++)\n   {\n      rjsonwriter_add_spaces(writer, 4);\n      rjsonwriter_raw(writer, \"{\", 1);\n\n      rjsonwriter_raw(writer, \"\\n\", 1);\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"path\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, playlist->entries[i].path);\n      rjsonwriter_raw(writer, \",\", 1);\n\n      rjsonwriter_raw(writer, \"\\n\", 1);\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"core_path\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, playlist->entries[i].core_path);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"runtime_hours\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%u\", playlist->entries[i].runtime_hours);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"runtime_minutes\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%u\", playlist->entries[i].runtime_minutes);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"runtime_seconds\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%u\", playlist->entries[i].runtime_seconds);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"last_played_year\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%u\", playlist->entries[i].last_played_year);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"last_played_month\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%u\", playlist->entries[i].last_played_month);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"last_played_day\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%u\", playlist->entries[i].last_played_day);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"last_played_hour\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%u\", playlist->entries[i].last_played_hour);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"last_played_minute\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%u\", playlist->entries[i].last_played_minute);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 6);\n      rjsonwriter_add_string(writer, \"last_played_second\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%u\", playlist->entries[i].last_played_second);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 4);\n      rjsonwriter_raw(writer, \"}\", 1);\n\n      if (i < _len - 1)\n         rjsonwriter_raw(writer, \",\", 1);\n\n      rjsonwriter_raw(writer, \"\\n\", 1);\n   }\n\n   rjsonwriter_add_spaces(writer, 2);\n   rjsonwriter_raw(writer, \"]\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n   rjsonwriter_raw(writer, \"}\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n   rjsonwriter_free(writer);\n\n   playlist->flags          &= ~(CNT_PLAYLIST_FLG_MOD\n                               | CNT_PLAYLIST_FLG_OLD_FMT\n                               | CNT_PLAYLIST_FLG_COMPRESSED);\n\n   RARCH_LOG(\"[Playlist]: Written to playlist file: \\\"%s\\\".\\n\", playlist->config.path);\nend:\n   intfstream_close(file);\n   free(file);\n}\n\nvoid playlist_write_file(playlist_t *playlist)\n{\n   size_t i, _len;\n   intfstream_t *file = NULL;\n   bool compressed    = false;\n\n   /* Playlist will be written if any of the\n    * following are true:\n    * > 'modified' flag is set\n    * > Current playlist format (old/new) does not\n    *   match requested\n    * > Current playlist compression status does\n    *   not match requested */\n   bool pl_compressed   = ((playlist->flags & CNT_PLAYLIST_FLG_COMPRESSED) > 0);\n   bool pl_old_fmt      = ((playlist->flags & CNT_PLAYLIST_FLG_OLD_FMT)    > 0);\n\n   if (   !playlist\n       || !((playlist->flags & CNT_PLAYLIST_FLG_MOD) ||\n#if defined(HAVE_ZLIB)\n        (pl_compressed != playlist->config.compress) ||\n#endif\n        (pl_old_fmt    != playlist->config.old_format)))\n      return;\n\n#if defined(HAVE_ZLIB)\n   if (playlist->config.compress)\n      file = intfstream_open_rzip_file(playlist->config.path,\n            RETRO_VFS_FILE_ACCESS_WRITE);\n   else\n#endif\n      file = intfstream_open_file(playlist->config.path,\n            RETRO_VFS_FILE_ACCESS_WRITE,\n            RETRO_VFS_FILE_ACCESS_HINT_NONE);\n\n   if (!file)\n   {\n      RARCH_ERR(\"Failed to write to playlist file: \\\"%s\\\".\\n\", playlist->config.path);\n      return;\n   }\n\n   /* Get current file compression state */\n   compressed = intfstream_is_compressed(file);\n\n#ifdef RARCH_INTERNAL\n   if (playlist->config.old_format)\n   {\n      for (i = 0, _len = RBUF_LEN(playlist->entries); i < _len; i++)\n         intfstream_printf(file, \"%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n\",\n               playlist->entries[i].path      ? playlist->entries[i].path      : \"\",\n               playlist->entries[i].label     ? playlist->entries[i].label     : \"\",\n               playlist->entries[i].core_path ? playlist->entries[i].core_path : \"\",\n               playlist->entries[i].core_name ? playlist->entries[i].core_name : \"\",\n               playlist->entries[i].crc32     ? playlist->entries[i].crc32     : \"\",\n               playlist->entries[i].db_name   ? playlist->entries[i].db_name   : \"\"\n               );\n\n      /* Add metadata lines\n       * > We add these at the end of the file to prevent\n       *   breakage if the playlist is loaded with an older\n       *   version of RetroArch */\n      intfstream_printf(\n            file,\n            \"default_core_path = \\\"%s\\\"\\n\"\n            \"default_core_name = \\\"%s\\\"\\n\"\n            \"label_display_mode = \\\"%d\\\"\\n\"\n            \"thumbnail_mode = \\\"%d|%d\\\"\\n\"\n            \"sort_mode = \\\"%d\\\"\\n\",\n            playlist->default_core_path ? playlist->default_core_path : \"\",\n            playlist->default_core_name ? playlist->default_core_name : \"\",\n            playlist->label_display_mode,\n            playlist->right_thumbnail_mode, playlist->left_thumbnail_mode,\n            playlist->sort_mode);\n\n      playlist->flags  |=  (CNT_PLAYLIST_FLG_OLD_FMT);\n   }\n   else\n#endif\n   {\n      rjsonwriter_t* writer = rjsonwriter_open_stream(file);\n      if (!writer)\n      {\n         RARCH_ERR(\"Failed to create JSON writer\\n\");\n         goto end;\n      }\n      /*  When compressing playlists, human readability\n       *   is not a factor - can skip all indentation\n       *   and new line characters */\n      if (compressed)\n         rjsonwriter_set_options(writer, RJSONWRITER_OPTION_SKIP_WHITESPACE);\n\n      rjsonwriter_raw(writer, \"{\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 2);\n      rjsonwriter_add_string(writer, \"version\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, \"1.5\");\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 2);\n      rjsonwriter_add_string(writer, \"default_core_path\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, playlist->default_core_path);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 2);\n      rjsonwriter_add_string(writer, \"default_core_name\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_add_string(writer, playlist->default_core_name);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      if (!string_is_empty(playlist->base_content_directory))\n      {\n         rjsonwriter_add_spaces(writer, 2);\n         rjsonwriter_add_string(writer, \"base_content_directory\");\n         rjsonwriter_raw(writer, \":\", 1);\n         rjsonwriter_raw(writer, \" \", 1);\n         rjsonwriter_add_string(writer, playlist->base_content_directory);\n         rjsonwriter_raw(writer, \",\", 1);\n         rjsonwriter_raw(writer, \"\\n\", 1);\n      }\n\n      rjsonwriter_add_spaces(writer, 2);\n      rjsonwriter_add_string(writer, \"label_display_mode\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%d\", (int)playlist->label_display_mode);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 2);\n      rjsonwriter_add_string(writer, \"right_thumbnail_mode\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%d\", (int)playlist->right_thumbnail_mode);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 2);\n      rjsonwriter_add_string(writer, \"left_thumbnail_mode\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%d\", (int)playlist->left_thumbnail_mode);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 2);\n      rjsonwriter_add_string(writer, \"thumbnail_match_mode\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%d\", (int)playlist->thumbnail_match_mode);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      rjsonwriter_add_spaces(writer, 2);\n      rjsonwriter_add_string(writer, \"sort_mode\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_rawf(writer, \"%d\", (int)playlist->sort_mode);\n      rjsonwriter_raw(writer, \",\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      if (!string_is_empty(playlist->scan_record.content_dir))\n      {\n         rjsonwriter_add_spaces(writer, 2);\n         rjsonwriter_add_string(writer, \"scan_content_dir\");\n         rjsonwriter_raw(writer, \":\", 1);\n         rjsonwriter_raw(writer, \" \", 1);\n         rjsonwriter_add_string(writer, playlist->scan_record.content_dir);\n         rjsonwriter_raw(writer, \",\", 1);\n         rjsonwriter_raw(writer, \"\\n\", 1);\n\n         rjsonwriter_add_spaces(writer, 2);\n         rjsonwriter_add_string(writer, \"scan_file_exts\");\n         rjsonwriter_raw(writer, \":\", 1);\n         rjsonwriter_raw(writer, \" \", 1);\n         rjsonwriter_add_string(writer, playlist->scan_record.file_exts);\n         rjsonwriter_raw(writer, \",\", 1);\n         rjsonwriter_raw(writer, \"\\n\", 1);\n\n         rjsonwriter_add_spaces(writer, 2);\n         rjsonwriter_add_string(writer, \"scan_dat_file_path\");\n         rjsonwriter_raw(writer, \":\", 1);\n         rjsonwriter_raw(writer, \" \", 1);\n         rjsonwriter_add_string(writer, playlist->scan_record.dat_file_path);\n         rjsonwriter_raw(writer, \",\", 1);\n         rjsonwriter_raw(writer, \"\\n\", 1);\n\n         rjsonwriter_add_spaces(writer, 2);\n         rjsonwriter_add_string(writer, \"scan_search_recursively\");\n         rjsonwriter_raw(writer, \":\", 1);\n         rjsonwriter_raw(writer, \" \", 1);\n         {\n            bool value = playlist->scan_record.search_recursively;\n            rjsonwriter_raw(writer, (value ? \"true\" : \"false\"), (value ? 4 : 5));\n         }\n         rjsonwriter_raw(writer, \",\", 1);\n         rjsonwriter_raw(writer, \"\\n\", 1);\n\n         rjsonwriter_add_spaces(writer, 2);\n         rjsonwriter_add_string(writer, \"scan_search_archives\");\n         rjsonwriter_raw(writer, \":\", 1);\n         rjsonwriter_raw(writer, \" \", 1);\n         {\n            bool value = playlist->scan_record.search_archives;\n            rjsonwriter_raw(writer, (value ? \"true\" : \"false\"), (value ? 4 : 5));\n         }\n         rjsonwriter_raw(writer, \",\", 1);\n         rjsonwriter_raw(writer, \"\\n\", 1);\n\n         rjsonwriter_add_spaces(writer, 2);\n         rjsonwriter_add_string(writer, \"scan_filter_dat_content\");\n         rjsonwriter_raw(writer, \":\", 1);\n         rjsonwriter_raw(writer, \" \", 1);\n         {\n            bool value = playlist->scan_record.filter_dat_content;\n            rjsonwriter_raw(writer, (value ? \"true\" : \"false\"), (value ? 4 : 5));\n         }\n         rjsonwriter_raw(writer, \",\", 1);\n         rjsonwriter_raw(writer, \"\\n\", 1);\n\n         rjsonwriter_add_spaces(writer, 2);\n         rjsonwriter_add_string(writer, \"scan_overwrite_playlist\");\n         rjsonwriter_raw(writer, \":\", 1);\n         rjsonwriter_raw(writer, \" \", 1);\n         {\n            bool value = playlist->scan_record.overwrite_playlist;\n            rjsonwriter_raw(writer, (value ? \"true\" : \"false\"), (value ? 4 : 5));\n         }\n         rjsonwriter_raw(writer, \",\", 1);\n         rjsonwriter_raw(writer, \"\\n\", 1);\n      }\n\n      rjsonwriter_add_spaces(writer, 2);\n      rjsonwriter_add_string(writer, \"items\");\n      rjsonwriter_raw(writer, \":\", 1);\n      rjsonwriter_raw(writer, \" \", 1);\n      rjsonwriter_raw(writer, \"[\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      for (i = 0, _len = RBUF_LEN(playlist->entries); i < _len; i++)\n      {\n         rjsonwriter_add_spaces(writer, 4);\n         rjsonwriter_raw(writer, \"{\", 1);\n\n         rjsonwriter_raw(writer, \"\\n\", 1);\n         rjsonwriter_add_spaces(writer, 6);\n         rjsonwriter_add_string(writer, \"path\");\n         rjsonwriter_raw(writer, \":\", 1);\n         rjsonwriter_raw(writer, \" \", 1);\n         rjsonwriter_add_string(writer, playlist->entries[i].path);\n         rjsonwriter_raw(writer, \",\", 1);\n\n         if (playlist->entries[i].entry_slot)\n         {\n            rjsonwriter_raw(writer, \"\\n\", 1);\n            rjsonwriter_add_spaces(writer, 6);\n            rjsonwriter_add_string(writer, \"entry_slot\");\n            rjsonwriter_raw(writer, \":\", 1);\n            rjsonwriter_raw(writer, \" \", 1);\n            rjsonwriter_rawf(writer, \"%d\", (int)playlist->entries[i].entry_slot);\n            rjsonwriter_raw(writer, \",\", 1);\n         }\n\n         rjsonwriter_raw(writer, \"\\n\", 1);\n         rjsonwriter_add_spaces(writer, 6);\n         rjsonwriter_add_string(writer, \"label\");\n         rjsonwriter_raw(writer, \":\", 1);\n         rjsonwriter_raw(writer, \" \", 1);\n         rjsonwriter_add_string(writer, playlist->entries[i].label);\n         rjsonwriter_raw(writer, \",\", 1);\n\n         rjsonwriter_raw(writer, \"\\n\", 1);\n         rjsonwriter_add_spaces(writer, 6);\n         rjsonwriter_add_string(writer, \"core_path\");\n         rjsonwriter_raw(writer, \":\", 1);\n         rjsonwriter_raw(writer, \" \", 1);\n         rjsonwriter_add_string(writer, playlist->entries[i].core_path);\n         rjsonwriter_raw(writer, \",\", 1);\n\n         rjsonwriter_raw(writer, \"\\n\", 1);\n         rjsonwriter_add_spaces(writer, 6);\n         rjsonwriter_add_string(writer, \"core_name\");\n         rjsonwriter_raw(writer, \":\", 1);\n         rjsonwriter_raw(writer, \" \", 1);\n         rjsonwriter_add_string(writer, playlist->entries[i].core_name);\n         rjsonwriter_raw(writer, \",\", 1);\n\n         rjsonwriter_raw(writer, \"\\n\", 1);\n         rjsonwriter_add_spaces(writer, 6);\n         rjsonwriter_add_string(writer, \"crc32\");\n         rjsonwriter_raw(writer, \":\", 1);\n         rjsonwriter_raw(writer, \" \", 1);\n         rjsonwriter_add_string(writer, playlist->entries[i].crc32);\n         rjsonwriter_raw(writer, \",\", 1);\n\n         rjsonwriter_raw(writer, \"\\n\", 1);\n         rjsonwriter_add_spaces(writer, 6);\n         rjsonwriter_add_string(writer, \"db_name\");\n         rjsonwriter_raw(writer, \":\", 1);\n         rjsonwriter_raw(writer, \" \", 1);\n         rjsonwriter_add_string(writer, playlist->entries[i].db_name);\n\n         if (!string_is_empty(playlist->entries[i].subsystem_ident))\n         {\n            rjsonwriter_raw(writer, \",\", 1);\n            rjsonwriter_raw(writer, \"\\n\", 1);\n            rjsonwriter_add_spaces(writer, 6);\n            rjsonwriter_add_string(writer, \"subsystem_ident\");\n            rjsonwriter_raw(writer, \":\", 1);\n            rjsonwriter_raw(writer, \" \", 1);\n            rjsonwriter_add_string(writer, playlist->entries[i].subsystem_ident);\n         }\n\n         if (!string_is_empty(playlist->entries[i].subsystem_name))\n         {\n            rjsonwriter_raw(writer, \",\", 1);\n            rjsonwriter_raw(writer, \"\\n\", 1);\n            rjsonwriter_add_spaces(writer, 6);\n            rjsonwriter_add_string(writer, \"subsystem_name\");\n            rjsonwriter_raw(writer, \":\", 1);\n            rjsonwriter_raw(writer, \" \", 1);\n            rjsonwriter_add_string(writer, playlist->entries[i].subsystem_name);\n         }\n\n         if (  playlist->entries[i].subsystem_roms &&\n               playlist->entries[i].subsystem_roms->size > 0)\n         {\n            unsigned j;\n\n            rjsonwriter_raw(writer, \",\", 1);\n            rjsonwriter_raw(writer, \"\\n\", 1);\n            rjsonwriter_add_spaces(writer, 6);\n            rjsonwriter_add_string(writer, \"subsystem_roms\");\n            rjsonwriter_raw(writer, \":\", 1);\n            rjsonwriter_raw(writer, \" \", 1);\n            rjsonwriter_raw(writer, \"[\", 1);\n            rjsonwriter_raw(writer, \"\\n\", 1);\n\n            for (j = 0; j < playlist->entries[i].subsystem_roms->size; j++)\n            {\n               const struct string_list *roms = playlist->entries[i].subsystem_roms;\n               rjsonwriter_add_spaces(writer, 8);\n               rjsonwriter_add_string(writer,\n                     !string_is_empty(roms->elems[j].data)\n                     ? roms->elems[j].data\n                     : \"\");\n\n               if (j < playlist->entries[i].subsystem_roms->size - 1)\n               {\n                  rjsonwriter_raw(writer, \",\", 1);\n                  rjsonwriter_raw(writer, \"\\n\", 1);\n               }\n            }\n\n            rjsonwriter_raw(writer, \"\\n\", 1);\n            rjsonwriter_add_spaces(writer, 6);\n            rjsonwriter_raw(writer, \"]\", 1);\n         }\n\n         rjsonwriter_raw(writer, \"\\n\", 1);\n\n         rjsonwriter_add_spaces(writer, 4);\n         rjsonwriter_raw(writer, \"}\", 1);\n\n         if (i < _len - 1)\n            rjsonwriter_raw(writer, \",\", 1);\n\n         rjsonwriter_raw(writer, \"\\n\", 1);\n      }\n\n      rjsonwriter_add_spaces(writer, 2);\n      rjsonwriter_raw(writer, \"]\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n      rjsonwriter_raw(writer, \"}\", 1);\n      rjsonwriter_raw(writer, \"\\n\", 1);\n\n      if (!rjsonwriter_free(writer))\n      {\n         RARCH_ERR(\"Failed to write to playlist file: \\\"%s\\\".\\n\", playlist->config.path);\n      }\n\n      playlist->flags  &= ~(CNT_PLAYLIST_FLG_OLD_FMT);\n   }\n\n   playlist->flags     &= ~CNT_PLAYLIST_FLG_MOD;\n\n   if (compressed)\n      playlist->flags  |=  (CNT_PLAYLIST_FLG_COMPRESSED);\n   else\n      playlist->flags  &= ~(CNT_PLAYLIST_FLG_COMPRESSED);\n\n   RARCH_LOG(\"[Playlist]: Written to playlist file: \\\"%s\\\".\\n\", playlist->config.path);\nend:\n   intfstream_close(file);\n   free(file);\n}\n\n/**\n * playlist_free:\n * @playlist            : Playlist handle.\n *\n * Frees playlist handle.\n */\nvoid playlist_free(playlist_t *playlist)\n{\n   size_t i, _len;\n\n   if (!playlist)\n      return;\n\n   if (playlist->default_core_path)\n      free(playlist->default_core_path);\n   playlist->default_core_path = NULL;\n\n   if (playlist->default_core_name)\n      free(playlist->default_core_name);\n   playlist->default_core_name = NULL;\n\n   if (playlist->base_content_directory)\n      free(playlist->base_content_directory);\n   playlist->base_content_directory = NULL;\n\n   if (playlist->scan_record.content_dir)\n      free(playlist->scan_record.content_dir);\n   playlist->scan_record.content_dir = NULL;\n\n   if (playlist->scan_record.file_exts)\n      free(playlist->scan_record.file_exts);\n   playlist->scan_record.file_exts = NULL;\n\n   if (playlist->scan_record.dat_file_path)\n      free(playlist->scan_record.dat_file_path);\n   playlist->scan_record.dat_file_path = NULL;\n\n   if (playlist->entries)\n   {\n      for (i = 0, _len = RBUF_LEN(playlist->entries); i < _len; i++)\n      {\n         struct playlist_entry *entry = &playlist->entries[i];\n\n         if (entry)\n            playlist_free_entry(entry);\n      }\n\n      RBUF_FREE(playlist->entries);\n   }\n\n   free(playlist);\n}\n\n/**\n * playlist_clear:\n * @playlist           : Playlist handle.\n *\n * Clears all playlist entries in playlist.\n **/\nvoid playlist_clear(playlist_t *playlist)\n{\n   size_t i, _len;\n   if (!playlist)\n      return;\n\n   for (i = 0, _len = RBUF_LEN(playlist->entries); i < _len; i++)\n   {\n      struct playlist_entry *entry = &playlist->entries[i];\n\n      if (entry)\n         playlist_free_entry(entry);\n   }\n   RBUF_CLEAR(playlist->entries);\n}\n\n/**\n * playlist_size:\n * @playlist           : Playlist handle.\n *\n * Gets size of playlist.\n * Returns: size of playlist.\n **/\nsize_t playlist_size(playlist_t *playlist)\n{\n   if (!playlist)\n      return 0;\n   return RBUF_LEN(playlist->entries);\n}\n\n/**\n * playlist_capacity:\n * @playlist           : Playlist handle.\n *\n * Gets maximum capacity of playlist.\n * Returns: maximum capacity of playlist.\n **/\nsize_t playlist_capacity(playlist_t *playlist)\n{\n   if (!playlist)\n      return 0;\n   return playlist->config.capacity;\n}\n\nstatic bool JSONStartArrayHandler(void *context)\n{\n   JSONContext *pCtx = (JSONContext *)context;\n\n   pCtx->array_depth++;\n\n   return true;\n}\n\nstatic bool JSONEndArrayHandler(void *context)\n{\n   JSONContext *pCtx = (JSONContext *)context;\n\n   pCtx->array_depth--;\n\n   if (     (pCtx->flags & JSON_CTX_FLG_IN_ITEMS)\n         && (pCtx->array_depth  == 0)\n         && (pCtx->object_depth <= 1))\n      pCtx->flags &= (JSON_CTX_FLG_IN_ITEMS);\n   else if ((pCtx->flags & JSON_CTX_FLG_IN_SUBSYSTEM_CONTENT)\n         && (pCtx->array_depth  <= 1)\n         && (pCtx->object_depth <= 2))\n      pCtx->flags &= (JSON_CTX_FLG_IN_SUBSYSTEM_CONTENT);\n\n   return true;\n}\n\nstatic bool JSONStartObjectHandler(void *context)\n{\n   JSONContext *pCtx = (JSONContext *)context;\n\n   pCtx->object_depth++;\n\n   if (     (pCtx->flags & JSON_CTX_FLG_IN_ITEMS)\n         && (pCtx->object_depth == 2))\n   {\n      if (\n            (pCtx->array_depth == 1)\n         && !(pCtx->flags & JSON_CTX_FLG_CAPACITY_EXCEEDED))\n      {\n         size_t _len = RBUF_LEN(pCtx->playlist->entries);\n         if (_len < pCtx->playlist->config.capacity)\n         {\n            /* Allocate memory to fit one more item but don't resize the\n             * buffer just yet, wait until JSONEndObjectHandler for that */\n            if (!RBUF_TRYFIT(pCtx->playlist->entries, _len + 1))\n            {\n               pCtx->flags |= JSON_CTX_FLG_OOM;\n               return false;\n            }\n            pCtx->current_entry = &pCtx->playlist->entries[_len];\n            memset(pCtx->current_entry, 0, sizeof(*pCtx->current_entry));\n         }\n         else\n         {\n            /* Hit max item limit.\n             * Note: We can't just abort here, since there may\n             * be more metadata to read at the end of the file... */\n            RARCH_WARN(\"JSON file contains more entries than current playlist capacity. Excess entries will be discarded.\\n\");\n            pCtx->flags             |= JSON_CTX_FLG_CAPACITY_EXCEEDED;\n            pCtx->current_entry      = NULL;\n            /* In addition, since we are discarding excess entries,\n             * the playlist must be flagged as being modified\n             * (i.e. the playlist is not the same as when it was\n             * last saved to disk...) */\n            pCtx->playlist->flags   |= CNT_PLAYLIST_FLG_MOD;\n         }\n      }\n   }\n\n   return true;\n}\n\nstatic bool JSONEndObjectHandler(void *context)\n{\n   JSONContext *pCtx = (JSONContext *)context;\n\n   if (     (pCtx->flags & JSON_CTX_FLG_IN_ITEMS)\n         && (pCtx->object_depth == 2))\n   {\n      if (     (pCtx->array_depth == 1)\n            && !(pCtx->flags & JSON_CTX_FLG_CAPACITY_EXCEEDED))\n         RBUF_RESIZE(pCtx->playlist->entries,\n               RBUF_LEN(pCtx->playlist->entries) + 1);\n   }\n\n   pCtx->object_depth--;\n\n   return true;\n}\n\nstatic bool JSONStringHandler(void *context, const char *pValue, size_t len)\n{\n   JSONContext *pCtx = (JSONContext *)context;\n\n   if (     (pCtx->flags & JSON_CTX_FLG_IN_ITEMS)\n         && (pCtx->flags & JSON_CTX_FLG_IN_SUBSYSTEM_CONTENT)\n         && (pCtx->object_depth == 2)\n         && (pCtx->array_depth  == 2))\n   {\n      if (len && !string_is_empty(pValue))\n      {\n         union string_list_elem_attr attr = {0};\n\n         if (!pCtx->current_entry->subsystem_roms)\n            pCtx->current_entry->subsystem_roms = string_list_new();\n\n         string_list_append(pCtx->current_entry->subsystem_roms, pValue, attr);\n      }\n   }\n   else if ((pCtx->flags & JSON_CTX_FLG_IN_ITEMS)\n         && (pCtx->object_depth == 2))\n   {\n      if (pCtx->array_depth == 1)\n      {\n         if (     pCtx->current_string_val\n               && len\n               && !string_is_empty(pValue))\n         {\n            if (*pCtx->current_string_val)\n                free(*pCtx->current_string_val);\n             *pCtx->current_string_val = strdup(pValue);\n         }\n      }\n   }\n   else if (pCtx->object_depth == 1)\n   {\n      if (pCtx->array_depth == 0)\n      {\n         if (     pCtx->current_string_val\n               && len\n               && !string_is_empty(pValue))\n         {\n            /* handle any top-level playlist metadata here */\n            if (*pCtx->current_string_val)\n                free(*pCtx->current_string_val);\n            *pCtx->current_string_val = strdup(pValue);\n         }\n      }\n   }\n\n   pCtx->current_string_val = NULL;\n\n   return true;\n}\n\nstatic bool JSONNumberHandler(void *context, const char *pValue, size_t len)\n{\n   JSONContext *pCtx = (JSONContext *)context;\n\n   if (     (pCtx->flags & JSON_CTX_FLG_IN_ITEMS)\n         && (pCtx->object_depth == 2))\n   {\n      if (    (pCtx->array_depth == 1)\n            && len\n            && !string_is_empty(pValue))\n      {\n         if (pCtx->current_entry_uint_val)\n            *pCtx->current_entry_uint_val = (unsigned)strtoul(pValue, NULL, 10);\n      }\n   }\n   else if (pCtx->object_depth == 1)\n   {\n      if (pCtx->array_depth == 0)\n      {\n         if (len && !string_is_empty(pValue))\n         {\n            /* handle any top-level playlist metadata here */\n            if (pCtx->current_meta_label_display_mode_val)\n               *pCtx->current_meta_label_display_mode_val   = (enum playlist_label_display_mode)strtoul(pValue, NULL, 10);\n            else if (pCtx->current_meta_thumbnail_mode_val)\n               *pCtx->current_meta_thumbnail_mode_val       = (enum playlist_thumbnail_mode)strtoul(pValue, NULL, 10);\n            else if (pCtx->current_meta_thumbnail_match_mode_val)\n               *pCtx->current_meta_thumbnail_match_mode_val = (enum playlist_thumbnail_match_mode)strtoul(pValue, NULL, 10);\n            else if (pCtx->current_meta_sort_mode_val)\n               *pCtx->current_meta_sort_mode_val            = (enum playlist_sort_mode)strtoul(pValue, NULL, 10);\n         }\n      }\n   }\n\n   pCtx->current_entry_uint_val                = NULL;\n   pCtx->current_meta_label_display_mode_val   = NULL;\n   pCtx->current_meta_thumbnail_mode_val       = NULL;\n   pCtx->current_meta_thumbnail_match_mode_val = NULL;\n   pCtx->current_meta_sort_mode_val            = NULL;\n\n   return true;\n}\n\nstatic bool JSONBoolHandler(void *context, bool value)\n{\n   JSONContext *pCtx = (JSONContext *)context;\n\n   if (   (!(pCtx->flags & JSON_CTX_FLG_IN_ITEMS))\n       && (pCtx->object_depth == 1)\n       && (pCtx->array_depth  == 0)\n       && pCtx->current_meta_bool_val)\n      *pCtx->current_meta_bool_val = value;\n\n   pCtx->current_meta_bool_val = NULL;\n\n   return true;\n}\n\nstatic bool JSONObjectMemberHandler(void *context, const char *pValue, size_t len)\n{\n   JSONContext *pCtx = (JSONContext *)context;\n\n   if (     (pCtx->flags & JSON_CTX_FLG_IN_ITEMS)\n         && (pCtx->object_depth == 2))\n   {\n      if (pCtx->array_depth == 1)\n      {\n         /* Something went wrong */\n         if (pCtx->current_string_val)\n            return false;\n\n         if (len && (!(pCtx->flags & JSON_CTX_FLG_CAPACITY_EXCEEDED)))\n         {\n            pCtx->current_string_val     = NULL;\n            pCtx->current_entry_uint_val = NULL;\n            pCtx->flags                 &= ~(JSON_CTX_FLG_IN_SUBSYSTEM_CONTENT);\n            switch (pValue[0])\n            {\n               case 'c':\n                     if (string_is_equal(pValue, \"core_name\"))\n                        pCtx->current_string_val = &pCtx->current_entry->core_name;\n                     else if (string_is_equal(pValue, \"core_path\"))\n                        pCtx->current_string_val = &pCtx->current_entry->core_path;\n                     else if (string_is_equal(pValue, \"crc32\"))\n                        pCtx->current_string_val = &pCtx->current_entry->crc32;\n                     break;\n               case 'd':\n                     if (string_is_equal(pValue, \"db_name\"))\n                        pCtx->current_string_val = &pCtx->current_entry->db_name;\n                     break;\n               case 'e':\n                     if (string_is_equal(pValue, \"entry_slot\"))\n                        pCtx->current_entry_uint_val = &pCtx->current_entry->entry_slot;\n                     break;\n               case 'l':\n                     if (string_is_equal(pValue, \"label\"))\n                        pCtx->current_string_val = &pCtx->current_entry->label;\n                     else if (string_is_equal(pValue, \"last_played_day\"))\n                        pCtx->current_entry_uint_val = &pCtx->current_entry->last_played_day;\n                     else if (string_is_equal(pValue, \"last_played_hour\"))\n                        pCtx->current_entry_uint_val = &pCtx->current_entry->last_played_hour;\n                     else if (string_is_equal(pValue, \"last_played_minute\"))\n                        pCtx->current_entry_uint_val = &pCtx->current_entry->last_played_minute;\n                     else if (string_is_equal(pValue, \"last_played_month\"))\n                        pCtx->current_entry_uint_val = &pCtx->current_entry->last_played_month;\n                     else if (string_is_equal(pValue, \"last_played_second\"))\n                        pCtx->current_entry_uint_val = &pCtx->current_entry->last_played_second;\n                     else if (string_is_equal(pValue, \"last_played_year\"))\n                        pCtx->current_entry_uint_val = &pCtx->current_entry->last_played_year;\n                     break;\n               case 'p':\n                     if (string_is_equal(pValue, \"path\"))\n                        pCtx->current_string_val = &pCtx->current_entry->path;\n                     break;\n               case 'r':\n                     if (string_is_equal(pValue, \"runtime_hours\"))\n                        pCtx->current_entry_uint_val = &pCtx->current_entry->runtime_hours;\n                     else if (string_is_equal(pValue, \"runtime_minutes\"))\n                        pCtx->current_entry_uint_val = &pCtx->current_entry->runtime_minutes;\n                     else if (string_is_equal(pValue, \"runtime_seconds\"))\n                        pCtx->current_entry_uint_val = &pCtx->current_entry->runtime_seconds;\n                     break;\n               case 's':\n                     if (string_is_equal(pValue, \"subsystem_ident\"))\n                        pCtx->current_string_val = &pCtx->current_entry->subsystem_ident;\n                     else if (string_is_equal(pValue, \"subsystem_name\"))\n                        pCtx->current_string_val = &pCtx->current_entry->subsystem_name;\n                     else if (string_is_equal(pValue, \"subsystem_roms\"))\n                        pCtx->flags |= (JSON_CTX_FLG_IN_SUBSYSTEM_CONTENT);\n                     break;\n            }\n         }\n      }\n   }\n   else if ((pCtx->object_depth == 1)\n         && (pCtx->array_depth  == 0)\n         && len)\n   {\n      pCtx->current_string_val                    = NULL;\n      pCtx->current_meta_label_display_mode_val   = NULL;\n      pCtx->current_meta_thumbnail_mode_val       = NULL;\n      pCtx->current_meta_thumbnail_match_mode_val = NULL;\n      pCtx->current_meta_sort_mode_val            = NULL;\n      pCtx->current_meta_bool_val                 = NULL;\n      pCtx->flags                                &= ~(JSON_CTX_FLG_IN_ITEMS);\n\n      switch (pValue[0])\n      {\n         case 'b':\n            if (string_is_equal(pValue, \"base_content_directory\"))\n               pCtx->current_string_val = &pCtx->playlist->base_content_directory;\n            break;\n         case 'd':\n            if (string_is_equal(pValue,      \"default_core_path\"))\n               pCtx->current_string_val = &pCtx->playlist->default_core_path;\n            else if (string_is_equal(pValue, \"default_core_name\"))\n               pCtx->current_string_val = &pCtx->playlist->default_core_name;\n            break;\n         case 'i':\n            if (string_is_equal(pValue, \"items\"))\n               pCtx->flags |= JSON_CTX_FLG_IN_ITEMS;\n            break;\n         case 'l':\n            if (string_is_equal(pValue,      \"label_display_mode\"))\n               pCtx->current_meta_label_display_mode_val = &pCtx->playlist->label_display_mode;\n            else if (string_is_equal(pValue, \"left_thumbnail_mode\"))\n               pCtx->current_meta_thumbnail_mode_val     = &pCtx->playlist->left_thumbnail_mode;\n            break;\n         case 'r':\n            if (string_is_equal(pValue, \"right_thumbnail_mode\"))\n               pCtx->current_meta_thumbnail_mode_val = &pCtx->playlist->right_thumbnail_mode;\n            break;\n         case 's':\n            if (string_is_equal(pValue,      \"scan_content_dir\"))\n               pCtx->current_string_val         = &pCtx->playlist->scan_record.content_dir;\n            else if (string_is_equal(pValue, \"scan_file_exts\"))\n               pCtx->current_string_val         = &pCtx->playlist->scan_record.file_exts;\n            else if (string_is_equal(pValue, \"scan_dat_file_path\"))\n               pCtx->current_string_val         = &pCtx->playlist->scan_record.dat_file_path;\n            else if (string_is_equal(pValue, \"scan_search_recursively\"))\n               pCtx->current_meta_bool_val      = &pCtx->playlist->scan_record.search_recursively;\n            else if (string_is_equal(pValue, \"scan_search_archives\"))\n               pCtx->current_meta_bool_val      = &pCtx->playlist->scan_record.search_archives;\n            else if (string_is_equal(pValue, \"scan_filter_dat_content\"))\n               pCtx->current_meta_bool_val      = &pCtx->playlist->scan_record.filter_dat_content;\n            else if (string_is_equal(pValue, \"scan_overwrite_playlist\"))\n               pCtx->current_meta_bool_val      = &pCtx->playlist->scan_record.overwrite_playlist;\n            else if (string_is_equal(pValue, \"sort_mode\"))\n               pCtx->current_meta_sort_mode_val = &pCtx->playlist->sort_mode;\n            break;\n\t  case 't':\n            if (string_is_equal(pValue, \"thumbnail_match_mode\"))\n               pCtx->current_meta_thumbnail_match_mode_val     = &pCtx->playlist->thumbnail_match_mode;\n\t    break;\n      }\n   }\n\n   return true;\n}\n\nstatic void playlist_get_old_format_metadata_value(\n      char *metadata_line, char *value, size_t len)\n{\n   char *end   = NULL;\n   char *start = strchr(metadata_line, '\\\"');\n\n   if (!start)\n      return;\n\n   start++;\n   if (!(end = strchr(start, '\\\"')))\n      return;\n\n   *end        = '\\0';\n   strlcpy(value, start, len);\n}\n\nstatic bool playlist_read_file(playlist_t *playlist)\n{\n   unsigned i;\n   int test_char;\n   bool res             = true;\n#if defined(HAVE_ZLIB)\n      /* Always use RZIP interface when reading playlists\n       * > this will automatically handle uncompressed\n       *   data */\n   intfstream_t *file   = intfstream_open_rzip_file(\n         playlist->config.path,\n         RETRO_VFS_FILE_ACCESS_READ);\n#else\n   intfstream_t *file   = intfstream_open_file(\n         playlist->config.path,\n         RETRO_VFS_FILE_ACCESS_READ,\n         RETRO_VFS_FILE_ACCESS_HINT_NONE);\n#endif\n\n   /* If playlist file does not exist,\n    * create an empty playlist instead */\n   if (!file)\n      return true;\n\n   if (intfstream_is_compressed(file))\n      playlist->flags |=  CNT_PLAYLIST_FLG_COMPRESSED;\n   else\n      playlist->flags &= ~CNT_PLAYLIST_FLG_COMPRESSED;\n\n   /* Detect format of playlist\n    * > Read file until we find the first printable\n    *   non-whitespace ASCII character */\n   do\n   {\n      /* Read error or EOF (end of file) */\n      if ((test_char = intfstream_getc(file)) == EOF)\n         goto end;\n   } while (!isgraph(test_char) || test_char > 0x7F);\n\n   if (test_char != '{')\n      playlist->flags |=  (CNT_PLAYLIST_FLG_OLD_FMT);\n   else\n      playlist->flags &= ~(CNT_PLAYLIST_FLG_OLD_FMT);\n\n   /* Reset file to start */\n   intfstream_rewind(file);\n\n   if (!(playlist->flags & CNT_PLAYLIST_FLG_OLD_FMT))\n   {\n      rjson_t* parser;\n      JSONContext context = {0};\n      context.playlist    = playlist;\n\n      if (!(parser = rjson_open_stream(file)))\n      {\n         RARCH_ERR(\"Failed to create JSON parser\\n\");\n         goto end;\n      }\n\n      rjson_set_options(parser,\n              RJSON_OPTION_ALLOW_UTF8BOM\n            | RJSON_OPTION_ALLOW_COMMENTS\n            | RJSON_OPTION_ALLOW_UNESCAPED_CONTROL_CHARACTERS\n            | RJSON_OPTION_REPLACE_INVALID_ENCODING);\n\n      if (rjson_parse(parser, &context,\n            JSONObjectMemberHandler,\n            JSONStringHandler,\n            JSONNumberHandler,\n            JSONStartObjectHandler,\n            JSONEndObjectHandler,\n            JSONStartArrayHandler,\n            JSONEndArrayHandler,\n            JSONBoolHandler,\n            NULL) /* Unused null handler */\n            != RJSON_DONE)\n      {\n         if (context.flags & JSON_CTX_FLG_OOM)\n         {\n            RARCH_WARN(\"Ran out of memory while parsing JSON playlist\\n\");\n            res = false;\n         }\n         else\n         {\n            RARCH_WARN(\"Error parsing chunk:\\n---snip---\\n%.*s\\n---snip---\\n\",\n                  rjson_get_source_context_len(parser),\n                  rjson_get_source_context_buf(parser));\n            RARCH_WARN(\"Error: Invalid JSON at line %d, column %d - %s.\\n\",\n                  (int)rjson_get_source_line(parser),\n                  (int)rjson_get_source_column(parser),\n                  (*rjson_get_error(parser) ? rjson_get_error(parser) : \"format error\"));\n         }\n      }\n      rjson_free(parser);\n   }\n   else\n   {\n      size_t _len = RBUF_LEN(playlist->entries);\n      char line_buf[PLAYLIST_ENTRIES][PATH_MAX_LENGTH] = {{0}};\n\n      /* Unnecessary, but harmless */\n      for (i = 0; i < PLAYLIST_ENTRIES; i++)\n         line_buf[i][0] = '\\0';\n\n      /* Read playlist entries */\n      while (_len < playlist->config.capacity)\n      {\n         size_t i;\n         size_t lines_read = 0;\n\n         /* Attempt to read the next 'PLAYLIST_ENTRIES'\n          * lines from the file */\n         for (i = 0; i < PLAYLIST_ENTRIES; i++)\n         {\n            *line_buf[i] = '\\0';\n\n            if (!intfstream_gets(file, line_buf[i], sizeof(line_buf[i])))\n               break;\n            /* Ensure line is NULL terminated, regardless of\n             * Windows or Unix line endings */\n            string_replace_all_chars(line_buf[i], '\\r', '\\0');\n            string_replace_all_chars(line_buf[i], '\\n', '\\0');\n\n            lines_read++;\n         }\n\n         /* If a 'full set' of lines were read, then this\n          * is a valid playlist entry */\n         if (lines_read >= PLAYLIST_ENTRIES)\n         {\n            struct playlist_entry* entry;\n\n            if (!RBUF_TRYFIT(playlist->entries, _len + 1))\n            {\n               res = false; /* out of memory */\n               goto end;\n            }\n            RBUF_RESIZE(playlist->entries, _len + 1);\n            entry = &playlist->entries[_len++];\n\n            memset(entry, 0, sizeof(*entry));\n\n            /* path */\n            if (!string_is_empty(line_buf[0]))\n               entry->path      = strdup(line_buf[0]);\n\n            /* label */\n            if (!string_is_empty(line_buf[1]))\n               entry->label     = strdup(line_buf[1]);\n\n            /* core_path */\n            if (!string_is_empty(line_buf[2]))\n               entry->core_path = strdup(line_buf[2]);\n\n            /* core_name */\n            if (!string_is_empty(line_buf[3]))\n               entry->core_name = strdup(line_buf[3]);\n\n            /* crc32 */\n            if (!string_is_empty(line_buf[4]))\n               entry->crc32     = strdup(line_buf[4]);\n\n            /* db_name */\n            if (!string_is_empty(line_buf[5]))\n               entry->db_name   = strdup(line_buf[5]);\n         }\n         /* If fewer than 'PLAYLIST_ENTRIES' lines were\n          * read, then this is metadata */\n         else\n         {\n            char default_core_path[PATH_MAX_LENGTH];\n            char default_core_name[NAME_MAX_LENGTH];\n\n            default_core_path[0] = '\\0';\n            default_core_name[0] = '\\0';\n\n            /* Get default_core_path */\n            if (lines_read < 1)\n               break;\n\n            if (strncmp(\"default_core_path\",\n                     line_buf[0],\n                     STRLEN_CONST(\"default_core_path\")) == 0)\n               playlist_get_old_format_metadata_value(\n                     line_buf[0], default_core_path, sizeof(default_core_path));\n\n            /* Get default_core_name */\n            if (lines_read < 2)\n               break;\n\n            if (strncmp(\"default_core_name\",\n                     line_buf[1],\n                     STRLEN_CONST(\"default_core_name\")) == 0)\n               playlist_get_old_format_metadata_value(\n                     line_buf[1], default_core_name, sizeof(default_core_name));\n\n            /* > Populate default core path/name, if required\n             *   (if one is empty, the other should be ignored) */\n            if (   !string_is_empty(default_core_path)\n                && !string_is_empty(default_core_name))\n            {\n               playlist->default_core_path = strdup(default_core_path);\n               playlist->default_core_name = strdup(default_core_name);\n            }\n\n            /* Get label_display_mode */\n            if (lines_read < 3)\n               break;\n\n            if (strncmp(\"label_display_mode\",\n                     line_buf[2],\n                     STRLEN_CONST(\"label_display_mode\")) == 0)\n            {\n               unsigned display_mode;\n               char display_mode_str[4] = {0};\n\n               playlist_get_old_format_metadata_value(\n                     line_buf[2], display_mode_str, sizeof(display_mode_str));\n\n               display_mode = string_to_unsigned(display_mode_str);\n\n               if (display_mode <= LABEL_DISPLAY_MODE_KEEP_REGION_AND_DISC_INDEX)\n                  playlist->label_display_mode = (enum playlist_label_display_mode)display_mode;\n            }\n\n            /* Get thumbnail modes */\n            if (lines_read < 4)\n               break;\n\n            if (strncmp(\"thumbnail_mode\",\n                     line_buf[3],\n                     STRLEN_CONST(\"thumbnail_mode\")) == 0)\n            {\n               char *tok, *save;\n               char thumbnail_mode_str[8]   = {0};\n               char *thumbnail_mode_str_cpy = strdup(thumbnail_mode_str);\n\n               playlist_get_old_format_metadata_value(\n                     line_buf[3], thumbnail_mode_str,\n                     sizeof(thumbnail_mode_str));\n\n               if ((tok = strtok_r(thumbnail_mode_str_cpy, \"|\", &save)))\n               {\n                  char *elem0 = strdup(tok);\n                  if ((tok = strtok_r(NULL, \"|\", &save)))\n                  {\n                     /* Right thumbnail mode */\n                     unsigned thumbnail_mode = string_to_unsigned(elem0);\n                     if (thumbnail_mode <= PLAYLIST_THUMBNAIL_MODE_LOGOS)\n                        playlist->right_thumbnail_mode = (enum playlist_thumbnail_mode)thumbnail_mode;\n\n                     /* Left thumbnail mode */\n                     thumbnail_mode = string_to_unsigned(tok);\n                     if (thumbnail_mode <= PLAYLIST_THUMBNAIL_MODE_LOGOS)\n                        playlist->left_thumbnail_mode = (enum playlist_thumbnail_mode)thumbnail_mode;\n                  }\n                  free(elem0);\n               }\n               free(thumbnail_mode_str_cpy);\n            }\n\n            /* Get sort_mode */\n            if (lines_read < 5)\n               break;\n\n            if (strncmp(\"sort_mode\",\n                     line_buf[4],\n                     STRLEN_CONST(\"sort_mode\")) == 0)\n            {\n               unsigned sort_mode;\n               char sort_mode_str[4] = {0};\n\n               playlist_get_old_format_metadata_value(\n                     line_buf[4], sort_mode_str, sizeof(sort_mode_str));\n\n               sort_mode = string_to_unsigned(sort_mode_str);\n\n               if (sort_mode <= PLAYLIST_SORT_MODE_OFF)\n                  playlist->sort_mode = (enum playlist_sort_mode)sort_mode;\n            }\n\n            /* All metadata parsed -> end of file */\n            break;\n         }\n      }\n   }\n\nend:\n   intfstream_close(file);\n   free(file);\n   return res;\n}\n\nvoid playlist_free_cached(void)\n{\n   if (playlist_cached && !(playlist_cached->flags & CNT_PLAYLIST_FLG_CACHED_EXT))\n      playlist_free(playlist_cached);\n   playlist_cached = NULL;\n}\n\nplaylist_t *playlist_get_cached(void)\n{\n   if (playlist_cached)\n      return playlist_cached;\n   return NULL;\n}\n\nbool playlist_init_cached(const playlist_config_t *config)\n{\n   bool pl_compressed, pl_old_fmt;\n   playlist_t *playlist = playlist_init(config);\n   if (!playlist)\n      return false;\n\n   pl_compressed   = ((playlist->flags & CNT_PLAYLIST_FLG_COMPRESSED) > 0);\n   pl_old_fmt      = ((playlist->flags & CNT_PLAYLIST_FLG_OLD_FMT)    > 0);\n   /* If playlist format/compression state\n    * does not match requested settings, update\n    * file on disk immediately */\n   if (\n#if defined(HAVE_ZLIB)\n       (pl_compressed != playlist->config.compress) ||\n#endif\n       (pl_old_fmt != playlist->config.old_format))\n      playlist_write_file(playlist);\n\n   playlist_cached      = playlist;\n   return true;\n}\n\n/**\n * playlist_init:\n * @config            : Playlist configuration object.\n *\n * Creates and initializes a playlist.\n *\n * Returns: handle to new playlist if successful, otherwise NULL\n **/\nplaylist_t *playlist_init(const playlist_config_t *config)\n{\n   playlist_t           *playlist   = (playlist_t*)malloc(sizeof(*playlist));\n   if (!playlist)\n      return NULL;\n\n   /* Set initial values */\n   playlist->flags                          = 0;\n   playlist->default_core_name              = NULL;\n   playlist->default_core_path              = NULL;\n   playlist->base_content_directory         = NULL;\n   playlist->entries                        = NULL;\n   playlist->label_display_mode             = LABEL_DISPLAY_MODE_DEFAULT;\n   playlist->right_thumbnail_mode           = PLAYLIST_THUMBNAIL_MODE_DEFAULT;\n   playlist->left_thumbnail_mode            = PLAYLIST_THUMBNAIL_MODE_DEFAULT;\n   playlist->thumbnail_match_mode           = PLAYLIST_THUMBNAIL_MATCH_MODE_DEFAULT;\n   playlist->sort_mode                      = PLAYLIST_SORT_MODE_DEFAULT;\n\n   playlist->scan_record.search_recursively = false;\n   playlist->scan_record.search_archives    = false;\n   playlist->scan_record.filter_dat_content = false;\n   playlist->scan_record.content_dir        = NULL;\n   playlist->scan_record.file_exts          = NULL;\n   playlist->scan_record.dat_file_path      = NULL;\n\n   /* Cache configuration parameters */\n   if (!playlist_config_copy(config, &playlist->config))\n      goto error;\n\n   /* Attempt to read any existing playlist file */\n   if (!playlist_read_file(playlist))\n      goto error;\n\n   /* Try auto-fixing paths if enabled, and playlist\n    * base content directory is different */\n   if (    config->autofix_paths\n       && !string_is_equal(playlist->base_content_directory,\n            config->base_content_directory))\n   {\n      if (!string_is_empty(playlist->base_content_directory))\n      {\n         size_t i, j, _len;\n         char tmp_entry_path[PATH_MAX_LENGTH];\n\n         for (i = 0, _len = RBUF_LEN(playlist->entries); i < _len; i++)\n         {\n            struct playlist_entry* entry = &playlist->entries[i];\n\n            if (!entry || string_is_empty(entry->path))\n               continue;\n\n            /* Fix entry path */\n            tmp_entry_path[0] = '\\0';\n            path_replace_base_path_and_convert_to_local_file_system(\n                  tmp_entry_path, entry->path,\n                  playlist->base_content_directory, playlist->config.base_content_directory,\n                  sizeof(tmp_entry_path));\n\n            free(entry->path);\n            entry->path = strdup(tmp_entry_path);\n\n            /* Fix subsystem roms paths*/\n            if (     (entry->subsystem_roms)\n                  && (entry->subsystem_roms->size > 0))\n            {\n               struct string_list* subsystem_roms_new_paths = string_list_new();\n               union string_list_elem_attr attributes       = { 0 };\n\n               if (!subsystem_roms_new_paths)\n                  goto error;\n\n               for (j = 0; j < entry->subsystem_roms->size; j++)\n               {\n                  const char* subsystem_rom_path = entry->subsystem_roms->elems[j].data;\n\n                  if (string_is_empty(subsystem_rom_path))\n                     continue;\n\n                  tmp_entry_path[0] = '\\0';\n                  path_replace_base_path_and_convert_to_local_file_system(\n                        tmp_entry_path,\n                        subsystem_rom_path,\n                        playlist->base_content_directory,\n                        playlist->config.base_content_directory,\n                        sizeof(tmp_entry_path));\n                  string_list_append(subsystem_roms_new_paths, tmp_entry_path, attributes);\n               }\n\n               string_list_free(entry->subsystem_roms);\n               entry->subsystem_roms = subsystem_roms_new_paths;\n            }\n         }\n\n         /* Fix scan record content directory */\n         if (!string_is_empty(playlist->scan_record.content_dir))\n         {\n            tmp_entry_path[0] = '\\0';\n            path_replace_base_path_and_convert_to_local_file_system(\n                  tmp_entry_path,\n                  playlist->scan_record.content_dir,\n                  playlist->base_content_directory,\n                  playlist->config.base_content_directory,\n                  sizeof(tmp_entry_path));\n\n            free(playlist->scan_record.content_dir);\n            playlist->scan_record.content_dir = strdup(tmp_entry_path);\n         }\n\n         /* Fix scan record arcade DAT file */\n         if (!string_is_empty(playlist->scan_record.dat_file_path))\n         {\n            tmp_entry_path[0] = '\\0';\n            path_replace_base_path_and_convert_to_local_file_system(\n                  tmp_entry_path,\n                  playlist->scan_record.dat_file_path,\n                  playlist->base_content_directory,\n                  playlist->config.base_content_directory,\n                  sizeof(tmp_entry_path));\n\n            free(playlist->scan_record.dat_file_path);\n            playlist->scan_record.dat_file_path = strdup(tmp_entry_path);\n         }\n      }\n\n      /* Update playlist base content directory*/\n      if (playlist->base_content_directory)\n         free(playlist->base_content_directory);\n      playlist->base_content_directory = strdup(playlist->config.base_content_directory);\n\n      /* Save playlist */\n      playlist->flags   |=  CNT_PLAYLIST_FLG_MOD;\n      playlist_write_file(playlist);\n   }\n\n   return playlist;\n\nerror:\n   playlist_free(playlist);\n   return NULL;\n}\n\nstatic int playlist_qsort_func(const struct playlist_entry *a,\n      const struct playlist_entry *b)\n{\n   char *a_str            = NULL;\n   char *b_str            = NULL;\n   char *a_fallback_label = NULL;\n   char *b_fallback_label = NULL;\n   int ret                = 0;\n\n   if (!a || !b)\n      goto end;\n\n   a_str                  = a->label;\n   b_str                  = b->label;\n\n   /* It is quite possible for playlist labels\n    * to be blank. If that is the case, have to use\n    * filename as a fallback (this is slow, but we\n    * have no other option...) */\n   if (string_is_empty(a_str))\n   {\n      if (!(a_fallback_label = (char*)calloc(NAME_MAX_LENGTH, sizeof(char))))\n         goto end;\n\n      if (!string_is_empty(a->path))\n         fill_pathname(a_fallback_label,\n               path_basename_nocompression(a->path),\n               \"\",\n               NAME_MAX_LENGTH * sizeof(char));\n      /* If filename is also empty, use core name\n       * instead -> this matches the behaviour of\n       * menu_displaylist_parse_playlist() */\n      else if (!string_is_empty(a->core_name))\n         strlcpy(a_fallback_label, a->core_name, NAME_MAX_LENGTH * sizeof(char));\n\n      /* If both filename and core name are empty,\n       * then have to compare an empty string\n       * -> again, this is to match the behaviour of\n       * menu_displaylist_parse_playlist() */\n\n      a_str = a_fallback_label;\n   }\n\n   if (string_is_empty(b_str))\n   {\n      if (!(b_fallback_label = (char*)calloc(NAME_MAX_LENGTH, sizeof(char))))\n         goto end;\n\n      if (!string_is_empty(b->path))\n         fill_pathname(b_fallback_label,\n               path_basename_nocompression(b->path),\n               \"\",\n               NAME_MAX_LENGTH * sizeof(char));\n      else if (!string_is_empty(b->core_name))\n         strlcpy(b_fallback_label, b->core_name, NAME_MAX_LENGTH * sizeof(char));\n\n      b_str = b_fallback_label;\n   }\n\n   ret = strcasecmp(a_str, b_str);\n\nend:\n\n   a_str = NULL;\n   b_str = NULL;\n\n   if (a_fallback_label)\n   {\n      free(a_fallback_label);\n      a_fallback_label = NULL;\n   }\n\n   if (b_fallback_label)\n   {\n      free(b_fallback_label);\n      b_fallback_label = NULL;\n   }\n\n   return ret;\n}\n\nvoid playlist_qsort(playlist_t *playlist)\n{\n   /* Avoid inadvertent sorting if 'sort mode'\n    * has been set explicitly to PLAYLIST_SORT_MODE_OFF */\n   if (   !playlist\n       || !playlist->entries\n       || (playlist->sort_mode == PLAYLIST_SORT_MODE_OFF))\n      return;\n\n   qsort(playlist->entries, RBUF_LEN(playlist->entries),\n         sizeof(struct playlist_entry),\n         (int (*)(const void *, const void *))playlist_qsort_func);\n}\n\nvoid command_playlist_push_write(\n      playlist_t *playlist,\n      const struct playlist_entry *entry)\n{\n   if (playlist && playlist_push(playlist, entry))\n      playlist_write_file(playlist);\n}\n\nvoid command_playlist_update_write(\n      playlist_t *plist,\n      size_t idx,\n      const struct playlist_entry *entry)\n{\n   playlist_t *playlist = plist ? plist : playlist_get_cached();\n\n   if (!playlist)\n      return;\n\n   playlist_update(\n         playlist,\n         idx,\n         entry);\n\n   playlist_write_file(playlist);\n}\n\nbool playlist_index_is_valid(playlist_t *playlist, size_t idx,\n      const char *path, const char *core_path)\n{\n   if (!playlist || idx >= RBUF_LEN(playlist->entries))\n      return false;\n   return    playlist_path_equal(path, playlist->entries[idx].path, &playlist->config)\n          && string_is_equal(path_basename_nocompression(playlist->entries[idx].core_path),\n                path_basename_nocompression(core_path));\n}\n\nbool playlist_entries_are_equal(\n      const struct playlist_entry *entry_a,\n      const struct playlist_entry *entry_b,\n      const playlist_config_t *config)\n{\n   char real_path_a[PATH_MAX_LENGTH];\n   char real_core_path_a[PATH_MAX_LENGTH];\n\n   /* Sanity check */\n   if (!entry_a || !entry_b || !config)\n      return false;\n\n   if (   string_is_empty(entry_a->path)\n       && string_is_empty(entry_a->core_path)\n       && string_is_empty(entry_b->path)\n       && string_is_empty(entry_b->core_path))\n      return true;\n\n   /* Check content paths */\n   if (!string_is_empty(entry_a->path))\n   {\n      strlcpy(real_path_a, entry_a->path, sizeof(real_path_a));\n      path_resolve_realpath(real_path_a, sizeof(real_path_a), true);\n   }\n   else\n      real_path_a[0]      = '\\0';\n\n   if (!playlist_path_equal(\n         real_path_a, entry_b->path, config))\n      return false;\n\n   /* Check core paths */\n   if (!string_is_empty(entry_a->core_path))\n   {\n      strlcpy(real_core_path_a, entry_a->core_path, sizeof(real_core_path_a));\n      if (   !string_is_equal(real_core_path_a, FILE_PATH_DETECT)\n          && !string_is_equal(real_core_path_a, FILE_PATH_BUILTIN))\n         playlist_resolve_path(PLAYLIST_SAVE, true,\n               real_core_path_a, sizeof(real_core_path_a));\n   }\n   else\n      real_core_path_a[0] = '\\0';\n\n   return playlist_core_path_equal(real_core_path_a, entry_b->core_path, config);\n}\n\n/* Returns true if entries at specified indices\n * of specified playlist have identical content\n * and core paths */\nbool playlist_index_entries_are_equal(\n      playlist_t *playlist, size_t idx_a, size_t idx_b)\n{\n   size_t _len;\n   struct playlist_entry *entry_a = NULL;\n   struct playlist_entry *entry_b = NULL;\n\n   if (!playlist)\n      return false;\n\n   _len = RBUF_LEN(playlist->entries);\n\n   if ((idx_a >= _len) || (idx_b >= _len))\n      return false;\n\n   /* Fetch entries */\n   entry_a = &playlist->entries[idx_a];\n   entry_b = &playlist->entries[idx_b];\n\n   if (!entry_a || !entry_b)\n      return false;\n\n   /* Initialise path ID for entry A, if required\n    * (entry B will be handled inside\n    * playlist_path_matches_entry()) */\n   if (!entry_a->path_id)\n      entry_a->path_id = playlist_path_id_init(entry_a->path);\n\n   return playlist_path_matches_entry(\n         entry_a->path_id, entry_b, &playlist->config);\n}\n\nvoid playlist_get_crc32(playlist_t *playlist, size_t idx,\n      const char **crc32)\n{\n   if (!playlist || idx >= RBUF_LEN(playlist->entries))\n      return;\n\n   if (crc32)\n      *crc32 = playlist->entries[idx].crc32;\n}\n\nvoid playlist_get_db_name(playlist_t *playlist, size_t idx,\n      const char **db_name)\n{\n   if (!playlist || !db_name || idx >= RBUF_LEN(playlist->entries))\n      return;\n\n   if (!string_is_empty(playlist->entries[idx].db_name))\n       *db_name = playlist->entries[idx].db_name;\n   else\n   {\n       const char *conf_path_basename = path_basename_nocompression(playlist->config.path);\n\n       /* Only use file basename if this is a 'collection' playlist\n        * (i.e. ignore history/favourites) */\n       if (\n              !string_is_empty(conf_path_basename)\n           && !string_is_equal(conf_path_basename, FILE_PATH_CONTENT_HISTORY)\n           && !string_is_equal(conf_path_basename, FILE_PATH_CONTENT_FAVORITES)\n           )\n           *db_name = conf_path_basename;\n       else\n       {\n          core_info_t *core_info = playlist_entry_get_core_info(&playlist->entries[idx]);\n          if (core_info && core_info->databases)\n             *db_name = core_info->databases;\n       }\n   }\n}\n\nconst char *playlist_get_default_core_path(playlist_t *playlist)\n{\n   return playlist ? playlist->default_core_path : NULL;\n}\n\nconst char *playlist_get_default_core_name(playlist_t *playlist)\n{\n   return playlist ? playlist->default_core_name : NULL;\n}\n\nenum playlist_label_display_mode playlist_get_label_display_mode(playlist_t *playlist)\n{\n   return playlist ? playlist->label_display_mode : LABEL_DISPLAY_MODE_DEFAULT;\n}\n\nenum playlist_thumbnail_mode playlist_get_thumbnail_mode(\n      playlist_t *playlist, enum playlist_thumbnail_id thumbnail_id)\n{\n   if (playlist)\n   {\n      if (thumbnail_id == PLAYLIST_THUMBNAIL_RIGHT)\n         return playlist->right_thumbnail_mode;\n      else if (thumbnail_id == PLAYLIST_THUMBNAIL_LEFT)\n         return playlist->left_thumbnail_mode;\n   }\n   /* Fallback */\n   return PLAYLIST_THUMBNAIL_MODE_DEFAULT;\n}\n\nbool playlist_thumbnail_match_with_filename(playlist_t *playlist)\n{\n   if (!playlist)\n      return false;\n   return playlist->thumbnail_match_mode == PLAYLIST_THUMBNAIL_MATCH_MODE_WITH_FILENAME;\n}\n\nenum playlist_sort_mode playlist_get_sort_mode(playlist_t *playlist)\n{\n   if (!playlist)\n      return PLAYLIST_SORT_MODE_DEFAULT;\n   return playlist->sort_mode;\n}\n\nconst char *playlist_get_scan_content_dir(playlist_t *playlist)\n{\n   if (!playlist)\n      return NULL;\n   return playlist->scan_record.content_dir;\n}\n\nconst char *playlist_get_scan_file_exts(playlist_t *playlist)\n{\n   if (!playlist)\n      return NULL;\n   return playlist->scan_record.file_exts;\n}\n\nconst char *playlist_get_scan_dat_file_path(playlist_t *playlist)\n{\n   if (!playlist)\n      return NULL;\n   return playlist->scan_record.dat_file_path;\n}\n\nbool playlist_get_scan_search_recursively(playlist_t *playlist)\n{\n   if (!playlist)\n      return false;\n   return playlist->scan_record.search_recursively;\n}\n\nbool playlist_get_scan_search_archives(playlist_t *playlist)\n{\n   if (!playlist)\n      return false;\n   return playlist->scan_record.search_archives;\n}\n\nbool playlist_get_scan_filter_dat_content(playlist_t *playlist)\n{\n   if (!playlist)\n      return false;\n   return playlist->scan_record.filter_dat_content;\n}\n\nbool playlist_get_scan_overwrite_playlist(playlist_t *playlist)\n{\n   if (!playlist)\n      return false;\n   return playlist->scan_record.overwrite_playlist;\n}\n\nbool playlist_scan_refresh_enabled(playlist_t *playlist)\n{\n   if (!playlist)\n      return false;\n   return !string_is_empty(playlist->scan_record.content_dir);\n}\n\nvoid playlist_set_default_core_path(playlist_t *playlist,\n      const char *core_path)\n{\n   char real_core_path[PATH_MAX_LENGTH];\n\n   if (!playlist || string_is_empty(core_path))\n      return;\n\n   /* Get 'real' core path */\n   strlcpy(real_core_path, core_path, sizeof(real_core_path));\n   if (   !string_is_equal(real_core_path, FILE_PATH_DETECT)\n       && !string_is_equal(real_core_path, FILE_PATH_BUILTIN))\n       playlist_resolve_path(PLAYLIST_SAVE, true,\n             real_core_path, sizeof(real_core_path));\n\n   if (string_is_empty(real_core_path))\n      return;\n\n   if (!string_is_equal(playlist->default_core_path, real_core_path))\n   {\n      if (playlist->default_core_path)\n         free(playlist->default_core_path);\n      playlist->default_core_path  = strdup(real_core_path);\n      playlist->flags             |=  CNT_PLAYLIST_FLG_MOD;\n   }\n}\n\nvoid playlist_set_default_core_name(\n      playlist_t *playlist, const char *core_name)\n{\n   if (!playlist || string_is_empty(core_name))\n      return;\n\n   if (!string_is_equal(playlist->default_core_name, core_name))\n   {\n      if (playlist->default_core_name)\n         free(playlist->default_core_name);\n      playlist->default_core_name  = strdup(core_name);\n      playlist->flags             |=  CNT_PLAYLIST_FLG_MOD;\n   }\n}\n\nvoid playlist_set_label_display_mode(playlist_t *playlist,\n      enum playlist_label_display_mode label_display_mode)\n{\n   if (playlist && playlist->label_display_mode != label_display_mode)\n   {\n      playlist->label_display_mode = label_display_mode;\n      playlist->flags             |=  CNT_PLAYLIST_FLG_MOD;\n   }\n}\n\nvoid playlist_set_thumbnail_mode(\n      playlist_t *playlist, enum playlist_thumbnail_id thumbnail_id,\n      enum playlist_thumbnail_mode thumbnail_mode)\n{\n   if (!playlist)\n      return;\n\n   switch (thumbnail_id)\n   {\n      case PLAYLIST_THUMBNAIL_RIGHT:\n         playlist->right_thumbnail_mode = thumbnail_mode;\n         playlist->flags               |=  CNT_PLAYLIST_FLG_MOD;\n         break;\n      case PLAYLIST_THUMBNAIL_LEFT:\n         playlist->left_thumbnail_mode  = thumbnail_mode;\n         playlist->flags               |=  CNT_PLAYLIST_FLG_MOD;\n         break;\n      case PLAYLIST_THUMBNAIL_ICON:\n         /* should never be reached.  Do Nothing */\n         break;\n\n   }\n}\n\nvoid playlist_set_sort_mode(playlist_t *playlist,\n      enum playlist_sort_mode sort_mode)\n{\n   if (playlist && playlist->sort_mode != sort_mode)\n   {\n      playlist->sort_mode = sort_mode;\n      playlist->flags    |=  CNT_PLAYLIST_FLG_MOD;\n   }\n}\n\nvoid playlist_set_scan_content_dir(playlist_t *playlist, const char *content_dir)\n{\n   bool current_string_empty;\n   bool new_string_empty;\n\n   if (!playlist)\n      return;\n\n   current_string_empty = string_is_empty(playlist->scan_record.content_dir);\n   new_string_empty     = string_is_empty(content_dir);\n\n   /* Check whether string value has changed\n    * (note that a NULL or empty argument will\n    * unset the playlist value) */\n   if (    (current_string_empty && !new_string_empty)\n       || (!current_string_empty &&  new_string_empty)\n       || !string_is_equal(playlist->scan_record.content_dir, content_dir))\n      playlist->flags    |=  CNT_PLAYLIST_FLG_MOD;\n   else\n      return; /* Strings are identical; do nothing */\n\n   if (playlist->scan_record.content_dir)\n   {\n      free(playlist->scan_record.content_dir);\n      playlist->scan_record.content_dir = NULL;\n   }\n\n   if (!new_string_empty)\n      playlist->scan_record.content_dir = strdup(content_dir);\n}\n\nvoid playlist_set_scan_file_exts(playlist_t *playlist, const char *file_exts)\n{\n   bool current_string_empty;\n   bool new_string_empty;\n\n   if (!playlist)\n      return;\n\n   current_string_empty = string_is_empty(playlist->scan_record.file_exts);\n   new_string_empty     = string_is_empty(file_exts);\n\n   /* Check whether string value has changed\n    * (note that a NULL or empty argument will\n    * unset the playlist value) */\n   if (   ( current_string_empty && !new_string_empty)\n       || (!current_string_empty &&  new_string_empty)\n       || !string_is_equal(playlist->scan_record.file_exts, file_exts))\n      playlist->flags    |=  CNT_PLAYLIST_FLG_MOD;\n   else\n      return; /* Strings are identical; do nothing */\n\n   if (playlist->scan_record.file_exts)\n   {\n      free(playlist->scan_record.file_exts);\n      playlist->scan_record.file_exts = NULL;\n   }\n\n   if (!new_string_empty)\n      playlist->scan_record.file_exts = strdup(file_exts);\n}\n\nvoid playlist_set_scan_dat_file_path(playlist_t *playlist, const char *dat_file_path)\n{\n   bool current_string_empty;\n   bool new_string_empty;\n\n   if (!playlist)\n      return;\n\n   current_string_empty = string_is_empty(playlist->scan_record.dat_file_path);\n   new_string_empty     = string_is_empty(dat_file_path);\n\n   /* Check whether string value has changed\n    * (note that a NULL or empty argument will\n    * unset the playlist value) */\n   if (   ( current_string_empty && !new_string_empty)\n       || (!current_string_empty &&  new_string_empty)\n       || !string_is_equal(playlist->scan_record.dat_file_path, dat_file_path))\n      playlist->flags    |=  CNT_PLAYLIST_FLG_MOD;\n   else\n      return; /* Strings are identical; do nothing */\n\n   if (playlist->scan_record.dat_file_path)\n   {\n      free(playlist->scan_record.dat_file_path);\n      playlist->scan_record.dat_file_path = NULL;\n   }\n\n   if (!new_string_empty)\n      playlist->scan_record.dat_file_path = strdup(dat_file_path);\n}\n\nvoid playlist_set_scan_search_recursively(playlist_t *playlist, bool search_recursively)\n{\n   if (playlist && playlist->scan_record.search_recursively != search_recursively)\n   {\n      playlist->scan_record.search_recursively = search_recursively;\n      playlist->flags    |=  CNT_PLAYLIST_FLG_MOD;\n   }\n}\n\nvoid playlist_set_scan_search_archives(playlist_t *playlist, bool search_archives)\n{\n   if (playlist && playlist->scan_record.search_archives != search_archives)\n   {\n      playlist->scan_record.search_archives = search_archives;\n      playlist->flags    |=  CNT_PLAYLIST_FLG_MOD;\n   }\n}\n\nvoid playlist_set_scan_filter_dat_content(playlist_t *playlist, bool filter_dat_content)\n{\n   if (playlist && playlist->scan_record.filter_dat_content != filter_dat_content)\n   {\n      playlist->scan_record.filter_dat_content = filter_dat_content;\n      playlist->flags    |=  CNT_PLAYLIST_FLG_MOD;\n   }\n}\n\nvoid playlist_set_scan_overwrite_playlist(playlist_t *playlist, bool overwrite_playlist)\n{\n   if (playlist && playlist->scan_record.overwrite_playlist != overwrite_playlist)\n   {\n      playlist->scan_record.overwrite_playlist = overwrite_playlist;\n      playlist->flags    |=  CNT_PLAYLIST_FLG_MOD;\n   }\n}\n\n/* Returns true if specified entry has a valid\n * core association (i.e. a non-empty string\n * other than DETECT) */\nbool playlist_entry_has_core(const struct playlist_entry *entry)\n{\n   if (  !entry\n       || string_is_empty(entry->core_path)\n       || string_is_empty(entry->core_name)\n       || string_is_equal(entry->core_path, FILE_PATH_DETECT)\n       || string_is_equal(entry->core_name, FILE_PATH_DETECT))\n      return false;\n   return true;\n}\n\n/* Fetches core info object corresponding to the\n * currently associated core of the specified\n * playlist entry.\n * Returns NULL if entry does not have a valid\n * core association */\ncore_info_t *playlist_entry_get_core_info(const struct playlist_entry* entry)\n{\n   if (playlist_entry_has_core(entry))\n   {\n      core_info_t *core_info = NULL;\n      /* Search for associated core */\n      if (core_info_find(entry->core_path, &core_info))\n         return core_info;\n   }\n   return NULL;\n}\n\n/* Fetches core info object corresponding to the\n * currently associated default core of the\n * specified playlist.\n * Returns NULL if playlist does not have a valid\n * default core association */\ncore_info_t *playlist_get_default_core_info(playlist_t* playlist)\n{\n   core_info_t *core_info = NULL;\n\n   if (  !playlist\n       || string_is_empty(playlist->default_core_path)\n       || string_is_empty(playlist->default_core_name)\n       || string_is_equal(playlist->default_core_path, FILE_PATH_DETECT)\n       || string_is_equal(playlist->default_core_name, FILE_PATH_DETECT))\n      return NULL;\n\n   /* Search for associated core */\n   if (core_info_find(playlist->default_core_path, &core_info))\n      return core_info;\n\n   return NULL;\n}\n"
        },
        {
          "name": "playlist.h",
          "type": "blob",
          "size": 13.6875,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _PLAYLIST_H__\n#define _PLAYLIST_H__\n\n#include <stddef.h>\n\n#include <retro_common_api.h>\n#include <boolean.h>\n#include <lists/string_list.h>\n\n#include \"core_info.h\"\n\n/* Default maximum playlist size */\n#define COLLECTION_SIZE 0x7FFFFFFF\n\nRETRO_BEGIN_DECLS\n\nenum playlist_runtime_status\n{\n   PLAYLIST_RUNTIME_UNKNOWN = 0,\n   PLAYLIST_RUNTIME_MISSING,\n   PLAYLIST_RUNTIME_VALID\n};\n\nenum playlist_file_mode\n{\n   PLAYLIST_LOAD = 0,\n   PLAYLIST_SAVE\n};\n\nenum playlist_label_display_mode\n{\n   LABEL_DISPLAY_MODE_DEFAULT = 0,\n   LABEL_DISPLAY_MODE_REMOVE_PARENTHESES,\n   LABEL_DISPLAY_MODE_REMOVE_BRACKETS,\n   LABEL_DISPLAY_MODE_REMOVE_PARENTHESES_AND_BRACKETS,\n   LABEL_DISPLAY_MODE_KEEP_REGION,\n   LABEL_DISPLAY_MODE_KEEP_DISC_INDEX,\n   LABEL_DISPLAY_MODE_KEEP_REGION_AND_DISC_INDEX\n};\n\nenum playlist_thumbnail_mode\n{\n   PLAYLIST_THUMBNAIL_MODE_DEFAULT = 0,\n   PLAYLIST_THUMBNAIL_MODE_OFF,\n   PLAYLIST_THUMBNAIL_MODE_SCREENSHOTS,\n   PLAYLIST_THUMBNAIL_MODE_TITLE_SCREENS,\n   PLAYLIST_THUMBNAIL_MODE_BOXARTS,\n   PLAYLIST_THUMBNAIL_MODE_LOGOS\n};\n\nenum playlist_thumbnail_match_mode\n{\n   PLAYLIST_THUMBNAIL_MATCH_MODE_DEFAULT = 0,\n   PLAYLIST_THUMBNAIL_MATCH_MODE_WITH_LABEL = PLAYLIST_THUMBNAIL_MATCH_MODE_DEFAULT,\n   PLAYLIST_THUMBNAIL_MATCH_MODE_WITH_FILENAME\n};\n\nenum playlist_sort_mode\n{\n   PLAYLIST_SORT_MODE_DEFAULT = 0,\n   PLAYLIST_SORT_MODE_ALPHABETICAL,\n   PLAYLIST_SORT_MODE_OFF\n};\n\n/* Note: We already have a left/right enum defined\n * in gfx_thumbnail_path.h - but we can't include\n * menu code here, so have to make a 'duplicate'... */\nenum playlist_thumbnail_id\n{\n   PLAYLIST_THUMBNAIL_RIGHT = 0,\n   PLAYLIST_THUMBNAIL_LEFT,\n   PLAYLIST_THUMBNAIL_ICON\n};\n\nenum playlist_thumbnail_name_flags\n{\n   PLAYLIST_THUMBNAIL_FLAG_INVALID          = 0,\n   PLAYLIST_THUMBNAIL_FLAG_FULL_NAME        = (1 << 0),\n   PLAYLIST_THUMBNAIL_FLAG_STD_NAME         = (1 << 1),\n   PLAYLIST_THUMBNAIL_FLAG_SHORT_NAME       = (1 << 2),\n   PLAYLIST_THUMBNAIL_FLAG_NONE             = (1 << 3)\n};\n\ntypedef struct content_playlist playlist_t;\n\n/* Holds all parameters required to uniquely\n * identify a playlist content path */\ntypedef struct\n{\n   char *real_path;\n   char *archive_path;\n   uint32_t real_path_hash;\n   uint32_t archive_path_hash;\n   bool is_archive;\n   bool is_in_archive;\n} playlist_path_id_t;\n\nstruct playlist_entry\n{\n   char *path;\n   char *label;\n   char *core_path;\n   char *core_name;\n   char *db_name;\n   char *crc32;\n   char *subsystem_ident;\n   char *subsystem_name;\n   char *runtime_str;\n   char *last_played_str;\n   struct string_list *subsystem_roms;\n   playlist_path_id_t *path_id;\n   unsigned entry_slot;\n   unsigned runtime_hours;\n   unsigned runtime_minutes;\n   unsigned runtime_seconds;\n   /* Note: due to platform dependence, have to record\n    * timestamp as either a string or independent integer\n    * values. The latter is more verbose, but more efficient. */\n   unsigned last_played_year;\n   unsigned last_played_month;\n   unsigned last_played_day;\n   unsigned last_played_hour;\n   unsigned last_played_minute;\n   unsigned last_played_second;\n   enum playlist_runtime_status runtime_status;\n   enum playlist_thumbnail_name_flags thumbnail_flags;\n};\n\n/* Holds all configuration parameters required\n * when initialising/saving playlists */\ntypedef struct\n{\n   size_t capacity;\n   bool old_format;\n   bool compress;\n   bool fuzzy_archive_match;\n   bool autofix_paths;\n   char path[PATH_MAX_LENGTH];\n   char base_content_directory[DIR_MAX_LENGTH];\n} playlist_config_t;\n\n/* Convenience function: copies specified playlist\n * path to specified playlist configuration object */\nvoid playlist_config_set_path(playlist_config_t *config, const char *path);\n\n/* Convenience function: copies base content directory\n * path to specified playlist configuration object */\nvoid playlist_config_set_base_content_directory(playlist_config_t* config, const char* path);\n\n/* Creates a copy of the specified playlist configuration.\n * Returns false in the event of an error */\nbool playlist_config_copy(const playlist_config_t *src, playlist_config_t *dst);\n\n/* Returns internal playlist configuration object\n * of specified playlist.\n * Returns NULL it the event of an error. */\nplaylist_config_t *playlist_get_config(playlist_t *playlist);\n\n/**\n * playlist_init:\n * @config            \t: Playlist configuration object.\n *\n * Creates and initializes a playlist.\n *\n * Returns: handle to new playlist if successful, otherwise NULL\n **/\nplaylist_t *playlist_init(const playlist_config_t *config);\n\n/**\n * playlist_free:\n * @playlist        \t   : Playlist handle.\n *\n * Frees playlist handle.\n */\nvoid playlist_free(playlist_t *playlist);\n\n/**\n * playlist_clear:\n * @playlist        \t   : Playlist handle.\n *\n * Clears all playlist entries in playlist.\n **/\nvoid playlist_clear(playlist_t *playlist);\n\n/**\n * playlist_size:\n * @playlist        \t   : Playlist handle.\n *\n * Gets size of playlist.\n * Returns: size of playlist.\n **/\nsize_t playlist_size(playlist_t *playlist);\n\n/**\n * playlist_capacity:\n * @playlist        \t   : Playlist handle.\n *\n * Gets maximum capacity of playlist.\n * Returns: maximum capacity of playlist.\n **/\nsize_t playlist_capacity(playlist_t *playlist);\n\n/**\n * playlist_get_index:\n * @playlist               : Playlist handle.\n * @idx                 : Index of playlist entry.\n *\n * Gets values of playlist index:\n **/\nvoid playlist_get_index(playlist_t *playlist,\n      size_t idx,\n      const struct playlist_entry **entry);\n\n/**\n * playlist_delete_index:\n * @playlist               : Playlist handle.\n * @idx                 : Index of playlist entry.\n *\n * Deletes the entry at index:\n **/\nvoid playlist_delete_index(playlist_t *playlist,\n      size_t idx);\n\n/**\n * playlist_delete_by_path:\n * @playlist            : Playlist handle.\n * @search_path         : Content path.\n *\n * Deletes all entries with content path\n * matching 'search_path'\n **/\nvoid playlist_delete_by_path(playlist_t *playlist,\n      const char *search_path);\n\n/**\n * playlist_resolve_path:\n * @mode      : PLAYLIST_LOAD or PLAYLIST_SAVE\n * @is_core   : Set true if path to be resolved is a core file\n * @path      : The path to be modified\n *\n * Resolves the path of an item, such as the content path or path to the core, to a format\n * appropriate for saving or loading depending on the @mode parameter\n *\n * Can be platform specific. File paths for saving can be abbreviated to avoid saving absolute\n * paths, as the base directory (home or application dir) may change after each subsequent\n * install (iOS)\n **/\nvoid playlist_resolve_path(enum playlist_file_mode mode,\n      bool is_core, char *path, size_t len);\n\n/**\n * playlist_content_path_is_valid:\n * @path      : Content path\n *\n * Checks whether specified playlist content path\n * refers to an existent file. Handles all playlist\n * content path 'types' (i.e. can validate paths\n * referencing files inside archives).\n *\n * Returns true if file referenced by content\n * path exists on the host filesystem.\n **/\nbool playlist_content_path_is_valid(const char *path);\n\n/**\n * playlist_push:\n * @playlist        \t   : Playlist handle.\n *\n * Push entry to top of playlist.\n **/\nbool playlist_push(playlist_t *playlist,\n      const struct playlist_entry *entry);\n\nbool playlist_push_runtime(playlist_t *playlist,\n      const struct playlist_entry *entry);\n\nvoid playlist_update(playlist_t *playlist, size_t idx,\n      const struct playlist_entry *update_entry);\n\n/* Note: register_update determines whether the internal\n * 'playlist->modified' flag is set when updating runtime\n * values. Since these are normally set temporarily (for\n * display purposes), we do not always want this function\n * to trigger a re-write of the playlist file. */\nvoid playlist_update_runtime(playlist_t *playlist, size_t idx,\n      const struct playlist_entry *update_entry,\n      bool register_update);\n\nvoid playlist_update_thumbnail_name_flag(playlist_t *playlist, size_t idx,\n     enum playlist_thumbnail_name_flags thumbnail_flags);\nenum playlist_thumbnail_name_flags playlist_get_next_thumbnail_name_flag(playlist_t *playlist, size_t idx);\nenum playlist_thumbnail_name_flags playlist_get_curr_thumbnail_name_flag(playlist_t *playlist, size_t idx);\n\nvoid playlist_get_index_by_path(playlist_t *playlist,\n      const char *search_path,\n      const struct playlist_entry **entry);\n\nbool playlist_entry_exists(playlist_t *playlist,\n      const char *path);\n\nchar *playlist_get_conf_path(playlist_t *playlist);\n\nuint32_t playlist_get_size(playlist_t *playlist);\n\nvoid playlist_write_file(playlist_t *playlist);\n\nvoid playlist_write_runtime_file(playlist_t *playlist);\n\nvoid playlist_qsort(playlist_t *playlist);\n\nvoid playlist_free_cached(void);\n\nplaylist_t *playlist_get_cached(void);\n\n/* If current on-disk playlist file referenced\n * by 'config->path' does not match requested\n * 'old format' or 'compression' state, file will\n * be updated automatically\n * > Since this function is called whenever a\n *   playlist is browsed via the menu, this is\n *   a simple method for ensuring that files\n *   are always kept synced with user settings */\nbool playlist_init_cached(const playlist_config_t *config);\n\nvoid command_playlist_push_write(\n      playlist_t *playlist,\n      const struct playlist_entry *entry);\n\nvoid command_playlist_update_write(\n      playlist_t *playlist,\n      size_t idx,\n      const struct playlist_entry *entry);\n\n/* Returns true if specified playlist index matches\n * specified content/core paths */\nbool playlist_index_is_valid(playlist_t *playlist, size_t idx,\n      const char *path, const char *core_path);\n\n/* Returns true if specified playlist entries have\n * identical content and core paths */\nbool playlist_entries_are_equal(\n      const struct playlist_entry *entry_a,\n      const struct playlist_entry *entry_b,\n      const playlist_config_t *config);\n\n/* Returns true if entries at specified indices\n * of specified playlist have identical content\n * and core paths */\nbool playlist_index_entries_are_equal(\n      playlist_t *playlist, size_t idx_a, size_t idx_b);\n\nvoid playlist_get_crc32(playlist_t *playlist, size_t idx,\n      const char **crc32);\n\n/* If db_name is empty, 'returns' playlist file basename */\nvoid playlist_get_db_name(playlist_t *playlist, size_t idx,\n      const char **db_name);\n\nconst char *playlist_get_default_core_path(playlist_t *playlist);\nconst char *playlist_get_default_core_name(playlist_t *playlist);\nenum playlist_label_display_mode playlist_get_label_display_mode(playlist_t *playlist);\nenum playlist_thumbnail_mode playlist_get_thumbnail_mode(\n      playlist_t *playlist, enum playlist_thumbnail_id thumbnail_id);\nbool playlist_thumbnail_match_with_filename(playlist_t *playlist);\nenum playlist_sort_mode playlist_get_sort_mode(playlist_t *playlist);\nconst char *playlist_get_scan_content_dir(playlist_t *playlist);\nconst char *playlist_get_scan_file_exts(playlist_t *playlist);\nconst char *playlist_get_scan_dat_file_path(playlist_t *playlist);\nbool playlist_get_scan_search_recursively(playlist_t *playlist);\nbool playlist_get_scan_search_archives(playlist_t *playlist);\nbool playlist_get_scan_filter_dat_content(playlist_t *playlist);\nbool playlist_get_scan_overwrite_playlist(playlist_t *playlist);\nbool playlist_scan_refresh_enabled(playlist_t *playlist);\n\nvoid playlist_set_default_core_path(playlist_t *playlist, const char *core_path);\nvoid playlist_set_default_core_name(playlist_t *playlist, const char *core_name);\nvoid playlist_set_label_display_mode(playlist_t *playlist, enum playlist_label_display_mode label_display_mode);\nvoid playlist_set_thumbnail_mode(\n      playlist_t *playlist, enum playlist_thumbnail_id thumbnail_id, enum playlist_thumbnail_mode thumbnail_mode);\nvoid playlist_set_sort_mode(playlist_t *playlist, enum playlist_sort_mode sort_mode);\nvoid playlist_set_scan_content_dir(playlist_t *playlist, const char *content_dir);\nvoid playlist_set_scan_file_exts(playlist_t *playlist, const char *file_exts);\nvoid playlist_set_scan_dat_file_path(playlist_t *playlist, const char *dat_file_path);\nvoid playlist_set_scan_search_recursively(playlist_t *playlist, bool search_recursively);\nvoid playlist_set_scan_search_archives(playlist_t *playlist, bool search_archives);\nvoid playlist_set_scan_filter_dat_content(playlist_t *playlist, bool filter_dat_content);\nvoid playlist_set_scan_overwrite_playlist(playlist_t *playlist, bool overwrite_playlist);\n\n/* Returns true if specified entry has a valid\n * core association (i.e. a non-empty string\n * other than DETECT) */\nbool playlist_entry_has_core(const struct playlist_entry *entry);\n\n/* Fetches core info object corresponding to the\n * currently associated core of the specified\n * playlist entry.\n * Returns NULL if entry does not have a valid\n * core association */\ncore_info_t *playlist_entry_get_core_info(const struct playlist_entry* entry);\n\n/* Fetches core info object corresponding to the\n * currently associated default core of the\n * specified playlist.\n * Returns NULL if playlist does not have a valid\n * default core association */\ncore_info_t *playlist_get_default_core_info(playlist_t* playlist);\n\nvoid playlist_set_cached_external(playlist_t* pl);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "qb",
          "type": "tree",
          "content": null
        },
        {
          "name": "record",
          "type": "tree",
          "content": null
        },
        {
          "name": "reference",
          "type": "tree",
          "content": null
        },
        {
          "name": "retroarch-android-debug.diff",
          "type": "blob",
          "size": 1.578125,
          "content": "diff --git a/pkg/android/phoenix/AndroidManifest.xml b/pkg/android/phoenix/AndroidManifest.xml\nindex ce2114c..12d8fbb 100644\n--- a/pkg/android/phoenix/AndroidManifest.xml\n+++ b/pkg/android/phoenix/AndroidManifest.xml\n@@ -21,7 +21,8 @@\n         android:label=\"RetroArch\"\n         android:hasCode=\"true\"\n         android:isGame=\"true\"\n-        android:banner=\"@drawable/banner\">\n+        android:banner=\"@drawable/banner\"\n+        android:debuggable=\"true\">\n         <meta-data android:name=\"com.google.android.gms.version\" android:value=\"@integer/google_play_services_version\" />\n         <activity android:name=\"com.retroarch.browser.mainmenu.MainMenuActivity\" android:exported=\"true\" android:launchMode=\"singleInstance\">\n             <intent-filter>\ndiff --git a/pkg/android/phoenix/build.xml b/pkg/android/phoenix/build.xml\nindex 9698a04..6b2c101 100644\n--- a/pkg/android/phoenix/build.xml\n+++ b/pkg/android/phoenix/build.xml\n@@ -96,7 +96,7 @@\n               <replaceregexp\n                       file=\"AndroidManifest.xml\"\n                       match=\"(android:debuggable=&#34;).*(&#34;)\"\n-                      replace=\"\\1false\\2\"/>\n+                      replace=\"\\1true\\2\"/>\n           </else>\n        </if>\n        <exec executable=\"${ndk.dir}/${ndk.cmd}\" failonerror=\"true\">\ndiff --git a/pkg/android/phoenix/jni/Application.mk b/pkg/android/phoenix/jni/Application.mk\nindex b179dbf..84ade89 100644\n--- a/pkg/android/phoenix/jni/Application.mk\n+++ b/pkg/android/phoenix/jni/Application.mk\n@@ -1,3 +1,5 @@\n+APP_OPTIM := debug\n+\n ifeq ($(GLES),3)\n    ifndef NDK_GL_HEADER_VER\n       APP_PLATFORM := android-18\n"
        },
        {
          "name": "retroarch-apple-packaging.sh",
          "type": "blob",
          "size": 1.2421875,
          "content": "#!/bin/sh\n# app stuff\n\nrm -rf RetroArch.app\n\nmkdir -p RetroArch.app/Contents/MacOS\ncp -r pkg/apple/OSX/* RetroArch.app/Contents\ncp retroarch RetroArch.app/Contents/MacOS\n\nmv RetroArch.app/Contents/Info_Metal.plist RetroArch.app/Contents/Info.plist\n\nsed -i'.bak' 's/\\${EXECUTABLE_NAME}/RetroArch/' RetroArch.app/Contents/Info.plist\nsed -i'.bak' 's/\\$(PRODUCT_BUNDLE_IDENTIFIER)/com.libretro.RetroArch/' RetroArch.app/Contents/Info.plist\nsed -i'.bak' 's/\\${PRODUCT_NAME}/RetroArch/' RetroArch.app/Contents/Info.plist\nsed -i'.bak' 's/\\${MACOSX_DEPLOYMENT_TARGET}/10.13/' RetroArch.app/Contents/Info.plist\n\ncp media/retroarch.icns RetroArch.app/Contents/Resources/\n\n# dmg stuff\n\numount wc\nrm -rf RetroArch.dmg wc empty.dmg\n\nmkdir -p template\nhdiutil create -fs HFSX -layout SPUD -size 200m empty.dmg -srcfolder template -format UDRW -volname RetroArch -quiet\nrmdir template\n\nmkdir -p wc\nhdiutil attach empty.dmg -noautoopen -quiet -mountpoint wc\nrm -rf wc/RetroArch.app\nditto -rsrc RetroArch.app wc/RetroArch.app\nln -s /Applications wc/Applications\nWC_DEV=`hdiutil info | grep wc | grep \"Apple_HFS\" | awk '{print $1}'` && hdiutil detach $WC_DEV -quiet -force\nhdiutil convert empty.dmg -quiet -format UDZO -imagekey zlib-level=9 -o RetroArch.dmg\n\numount wc\nrm -rf wc empty.dmg\n"
        },
        {
          "name": "retroarch-mingw-build.sh",
          "type": "blob",
          "size": 4.279296875,
          "content": "#!/bin/sh\n###############\n# Build script which builds and packages RetroArch for MinGW 32/64-bit.\n# Preferably build on Linux with a cross chain ... :D\n##########\n\n####\n## Tweak these to suit your environment.\n## Not defining the variable will avoid building that target.\n## Set MINGW32_BASE and/or MINGW64_BASE to set toolchain prefix:\n## E.g.: i486-mingw32-gcc would get prefix \"i486-mingw32\".\n\nBUILD_32BIT=yes\nBUILD_64BIT=yes\nBUILD_PHOENIX_GUI=yes\n\nif [ ! -z \"$NOBUILD_32BIT\" ]; then\n   BUILD_32BIT=no\nfi\nif [ ! -z \"$NOBUILD_64BIT\" ]; then\n   BUILD_64BIT=no\nfi\nif [ ! -z \"$NOBUILD_PHOENIX_GUI\" ]; then\n   BUILD_PHOENIX_GUI=no\nfi\n\n########\n\ndie()\n{\n   echo \"$@\"\n   exit 1\n}\n\nmessage()\n{\n   echo \"\"\n   echo \"================================\"\n   echo \"$@\"\n   echo \"================================\"\n   echo \"\"\n}\n\nif [ -z \"$MAKE\" ]; then\n   if uname -s | grep -i MINGW32 > /dev/null 2>&1; then\n      MAKE=mingw32-make\n   else\n      if type gmake > /dev/null 2>&1; then\n         MAKE=gmake\n      else\n         MAKE=make\n      fi\n   fi\nfi\n\nif [ ! -f \"`which zip`\" ]; then\n   echo \"Cannot find 'zip'. Cannot package, quitting ...\"\n   exit 1\nfi\n\nif [ ! -f \"`which unzip`\" ]; then\n   echo \"Cannot find 'unzip'. Cannot unpack, quitting ...\"\n   exit 1\nfi\n\nif [ ! -f \"`which wget`\" ]; then\n   echo \"Cannot find 'wget'. Cannot unpack, quitting ...\"\n   exit 1\nfi\n\ndo_phoenix_build()\n{\n   message \"Build Phoenix GUI\"\n   ### Build Phoenix GUI\n   if [ ! -d \"Phoenix\" ]; then\n      git clone git://github.com/Themaister/RetroArch-Phoenix.git Phoenix\n      cd Phoenix\n   else\n      cd Phoenix\n      git pull origin master\n   fi\n\n   \"${MAKE}\" -f Makefile.win clean || die \"Failed to clean ...\"\n   \"${MAKE}\" -f Makefile.win CC=\"$C_COMPILER\" CXX=\"$CXX_COMPILER\" WINDRES=\"$WINDRES\" -j4 all || die \"Failed to build ...\"\n   touch retroarch-phoenix.cfg\n   cp retroarch-phoenix.cfg retroarch-phoenix.exe ../ || die \"Failed to copy ...\"\n\n   cd ..\n}\n\ndo_build()\n{\n   RetroArch_DIR=\"$1\"\n   LIBZIPNAME=\"$2\"\n   BUILDTYPE=\"$3\"\n\n   if [ ! -d \"$RetroArch_DIR\" ]; then\n      git clone git://github.com/libretro/RetroArch.git \"$RetroArch_DIR\"\n      cd \"$RetroArch_DIR\"\n   else\n      cd \"$RetroArch_DIR\"\n      git pull origin master\n   fi\n\n   if [ ! -f \"$LIBZIPNAME\" ]; then\n      \"${MAKE}\" -f Makefile.win libs_${BUILDTYPE} || die \"Failed to extract\"\n   fi\n\n   \"${MAKE}\" -f Makefile.win clean || die \"Failed to clean ...\"\n   \"${MAKE}\" -f Makefile.win CC=\"$C_COMPILER\" CXX=\"$CXX_COMPILER\" WINDRES=\"$WINDRES\" -j4 all SLIM=1 || die \"Failed to build ...\"\n   \"${MAKE}\" -f Makefile.win CC=\"$C_COMPILER\" CXX=\"$CXX_COMPILER\" WINDRES=\"$WINDRES\" dist_${BUILDTYPE} SLIM=1 || die \"Failed to dist ...\"\n   if [ -z \"`find . | grep \"retroarch-win\"`\" ]; then\n      die \"Did not find build ...\"\n   fi\n\n   if [ \"$BUILD_PHOENIX_GUI\" = \"yes\" ]; then\n      do_phoenix_build\n   fi\n\n   ZIP_BASE=\"`find . | grep \"retroarch-win\" | head -n1`\"\n   ZIP_SLIM=\"`echo $ZIP_BASE | sed -e 's|\\.zip|-slim.zip|'`\"\n   ZIP_FULL=\"`echo $ZIP_BASE | sed -e 's|\\.zip|-full.zip|'`\"\n\n   if [ \"$BUILD_PHOENIX_GUI\" = \"yes\" ]; then\n      zip \"$ZIP_BASE\" retroarch-phoenix.exe retroarch-phoenix.cfg\n   fi\n   mv -v \"$ZIP_BASE\" \"../$ZIP_SLIM\" || die \"Failed to move final build ...\"\n\n   \"${MAKE}\" -f Makefile.win clean || die \"Failed to clean ...\"\n   \"${MAKE}\" -f Makefile.win CC=\"$C_COMPILER\" CXX=\"$CXX_COMPILER\" WINDRES=\"$WINDRES\" HAVE_D3D9=1 -j4 all || die \"Failed to build ...\"\n   \"${MAKE}\" -f Makefile.win CC=\"$C_COMPILER\" CXX=\"$CXX_COMPILER\" WINDRES=\"$WINDRES\" HAVE_D3D9=1 dist_${BUILDTYPE} || die \"Failed to dist ...\"\n\n   if [ \"$BUILD_PHOENIX_GUI\" = \"yes\" ]; then\n      zip \"$ZIP_BASE\" retroarch-phoenix.exe retroarch-phoenix.cfg\n   fi\n\n   cp -v \"$ZIP_BASE\" \"../$ZIP_FULL\" || die \"Failed to move final build ...\"\n   mv -v \"$ZIP_BASE\" ..\n   zip \"../$ZIP_BASE\" *.dll retroarch-redist-version || die \"Failed to build full/redist ...\"\n\n   cd ..\n}\n\nif [ \"$BUILD_32BIT\" = yes ]; then\n   message \"Building for 32-bit!\"\n   C_COMPILER=\"${MINGW32_BASE}-gcc\"\n   CXX_COMPILER=\"${MINGW32_BASE}-g++\"\n   WINDRES=${MINGW32_BASE}-windres\n   do_build \"RetroArch-w32\" \"RetroArch-win32-libs.zip\" \"x86\"\nfi\n\nif [ \"$BUILD_64BIT\" = yes ]; then\n   message \"Building for 64-bit!\"\n   C_COMPILER=${MINGW64_BASE}-gcc\n   CXX_COMPILER=${MINGW64_BASE}-g++\n   WINDRES=${MINGW64_BASE}-windres\n   do_build \"RetroArch-w64\" \"RetroArch-win64-libs.zip\" \"x86_64\"\nfi\n\nmessage \"Built successfully! :)\"\n"
        },
        {
          "name": "retroarch.c",
          "type": "blob",
          "size": 285.8017578125,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2021 - Daniel De Matteis\n *  Copyright (C) 2012-2015 - Michael Lelli\n *  Copyright (C) 2014-2017 - Jean-Andr Santoni\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifdef _WIN32\n#ifdef _XBOX\n#include <xtl.h>\n#else\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#endif\n#if defined(DEBUG) && defined(HAVE_DRMINGW)\n#include \"exchndl.h\"\n#endif\n#endif\n\n#if defined(DINGUX)\n#include <sys/types.h>\n#include <unistd.h>\n#endif\n\n#if (defined(__linux__) || defined(__unix__) || defined(DINGUX)) && !defined(EMSCRIPTEN)\n#include <signal.h>\n#endif\n\n#if defined(_WIN32_WINNT) && _WIN32_WINNT < 0x0500 || defined(_XBOX)\n#ifndef LEGACY_WIN32\n#define LEGACY_WIN32\n#endif\n#endif\n\n#if defined(_WIN32) && !defined(_XBOX) && !defined(__WINRT__)\n#include <objbase.h>\n#include <process.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n#include <locale.h>\n\n#include <boolean.h>\n#include <clamping.h>\n#include <string/stdstring.h>\n#include <dynamic/dylib.h>\n#include <file/config_file.h>\n#include <lists/string_list.h>\n#include <memalign.h>\n#include <retro_math.h>\n#include <retro_timers.h>\n#include <encodings/utf.h>\n#include <time/rtime.h>\n\n#include <libretro.h>\n#define VFS_FRONTEND\n#include <vfs/vfs_implementation.h>\n\n#include <features/features_cpu.h>\n\n#include <compat/strl.h>\n#include <compat/strcasestr.h>\n#include <compat/getopt.h>\n#include <compat/posix_string.h>\n#include <file/file_path.h>\n#include <retro_miscellaneous.h>\n#include <lists/dir_list.h>\n\n#ifdef EMSCRIPTEN\n#include <emscripten/emscripten.h>\n#endif\n\n#ifdef HAVE_LIBNX\n#include <switch.h>\n#include \"switch_performance_profiles.h\"\n#endif\n\n#if defined(ANDROID)\n#include \"play_feature_delivery/play_feature_delivery.h\"\n#endif\n\n#ifdef HAVE_PRESENCE\n#include \"network/presence.h\"\n#endif\n#ifdef HAVE_DISCORD\n#include \"network/discord.h\"\n#endif\n\n#ifdef HAVE_MIST\n#include \"steam/steam.h\"\n#endif\n\n#include \"config.def.h\"\n\n#ifdef HAVE_MENU\n#include \"menu/menu_driver.h\"\n#endif\n\n#include \"location_driver.h\"\n\n#include \"runloop.h\"\n#include \"camera/camera_driver.h\"\n#include \"location_driver.h\"\n#include \"record/record_driver.h\"\n\n#ifdef HAVE_MICROPHONE\n#include \"audio/microphone_driver.h\"\n#endif\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef HAVE_NETWORKING\n#include <net/net_compat.h>\n#include <net/net_socket.h>\n#endif\n\n#include <audio/audio_resampler.h>\n\n#include \"audio/audio_driver.h\"\n\n#ifdef HAVE_GFX_WIDGETS\n#include \"gfx/gfx_widgets.h\"\n#endif\n\n#include \"input/input_remapping.h\"\n\n#ifdef HAVE_CHEEVOS\n#include \"cheevos/cheevos.h\"\n#include \"cheevos/cheevos_menu.h\"\n#endif\n\n#ifdef HAVE_TRANSLATE\n#include <encodings/base64.h>\n#include <formats/rbmp.h>\n#include <formats/rpng.h>\n#include <formats/rjson.h>\n#include \"translation_defines.h\"\n#endif\n\n#ifdef HAVE_NETWORKING\n#include \"network/netplay/netplay.h\"\n#include \"network/netplay/netplay_private.h\"\n#ifdef HAVE_WIFI\n#include \"network/wifi_driver.h\"\n#endif\n#ifdef HAVE_CLOUDSYNC\n#include \"network/cloud_sync_driver.h\"\n#endif\n#endif\n\n#ifdef HAVE_THREADS\n#include <rthreads/rthreads.h>\n#endif\n\n#include \"autosave.h\"\n#include \"config.features.h\"\n#include \"content.h\"\n#include \"core_info.h\"\n#include \"dynamic.h\"\n#include \"defaults.h\"\n#include \"driver.h\"\n#include \"msg_hash.h\"\n#include \"paths.h\"\n#include \"file_path_special.h\"\n#include \"ui/ui_companion_driver.h\"\n#include \"verbosity.h\"\n\n#include \"gfx/video_driver.h\"\n#include \"gfx/video_display_server.h\"\n#ifdef HAVE_BLUETOOTH\n#include \"bluetooth/bluetooth_driver.h\"\n#endif\n#include \"misc/cpufreq/cpufreq.h\"\n#include \"led/led_driver.h\"\n#include \"midi_driver.h\"\n#include \"core.h\"\n#include \"configuration.h\"\n#include \"list_special.h\"\n#ifdef HAVE_CHEATS\n#include \"cheat_manager.h\"\n#endif\n#include \"tasks/task_content.h\"\n#include \"tasks/tasks_internal.h\"\n\n#include \"version.h\"\n#include \"version_git.h\"\n\n#include \"retroarch.h\"\n\n#include \"accessibility.h\"\n\n#if defined(HAVE_SDL) || defined(HAVE_SDL2) || defined(HAVE_SDL_DINGUX)\n#include \"SDL.h\"\n#endif\n\n#ifdef HAVE_LAKKA\n#include \"lakka.h\"\n#endif\n\n#define _PSUPP(var, name, desc) printf(\"  %s:\\n\\t\\t%s: %s\\n\", name, desc, var ? \"yes\" : \"no\")\n\n#define FAIL_CPU(simd_type) do { \\\n   RARCH_ERR(simd_type \" code is compiled in, but CPU does not support this feature. Cannot continue.\\n\"); \\\n   retroarch_fail(1, \"validate_cpu_features()\"); \\\n} while (0)\n\n#define FFMPEG_RECORD_ARG \"r:\"\n\n#ifdef HAVE_DYNAMIC\n#define DYNAMIC_ARG \"L:\"\n#else\n#define DYNAMIC_ARG\n#endif\n\n#ifdef HAVE_NETWORKING\n#define NETPLAY_ARG \"HC:F:\"\n#else\n#define NETPLAY_ARG\n#endif\n\n#ifdef HAVE_CONFIGFILE\n#define CONFIG_FILE_ARG \"c:\"\n#else\n#define CONFIG_FILE_ARG\n#endif\n\n#ifdef HAVE_BSV_MOVIE\n#define BSV_MOVIE_ARG \"P:R:M:\"\n#else\n#define BSV_MOVIE_ARG\n#endif\n\n/* Griffin hack */\n#ifdef HAVE_QT\n#ifndef HAVE_MAIN\n#define HAVE_MAIN\n#endif\n#endif\n\n#define MIDI_DRIVER_BUF_SIZE 4096\n#define MIDI_DRIVER_OFF \"OFF\"\n\n/* Descriptive names for options without short variant.\n *\n * Please keep the name in sync with the option name.\n * Order does not matter. */\nenum\n{\n   RA_OPT_MENU = 256, /* must be outside the range of a char */\n   RA_OPT_CHECK_FRAMES,\n   RA_OPT_PORT,\n   RA_OPT_SPECTATE,\n   RA_OPT_NICK,\n   RA_OPT_COMMAND,\n   RA_OPT_APPENDCONFIG,\n   RA_OPT_BPS,\n   RA_OPT_IPS,\n   RA_OPT_XDELTA,\n   RA_OPT_NO_PATCH,\n   RA_OPT_RECORDCONFIG,\n   RA_OPT_SUBSYSTEM,\n   RA_OPT_SIZE,\n   RA_OPT_FEATURES,\n   RA_OPT_VERSION,\n   RA_OPT_EOF_EXIT,\n   RA_OPT_LOG_FILE,\n   RA_OPT_MAX_FRAMES,\n   RA_OPT_MAX_FRAMES_SCREENSHOT,\n   RA_OPT_MAX_FRAMES_SCREENSHOT_PATH,\n   RA_OPT_SET_SHADER,\n   RA_OPT_DATABASE_SCAN,\n   RA_OPT_ACCESSIBILITY,\n   RA_OPT_LOAD_MENU_ON_ERROR\n};\n\n/* DRIVERS */\n#ifdef HAVE_BLUETOOTH\nextern const bluetooth_driver_t *bluetooth_drivers[];\n#endif\n\n/* MAIN GLOBAL VARIABLES */\nstruct rarch_state\n{\n   char *connect_host; /* Netplay hostname passed from CLI */\n   char *connect_mitm_id; /* Netplay MITM address from CLI */\n\n   struct retro_perf_counter *perf_counters_rarch[MAX_COUNTERS];\n\n#ifdef HAVE_THREAD_STORAGE\n   sthread_tls_t rarch_tls;               /* unsigned alignment */\n#endif\n   unsigned perf_ptr_rarch;\n   uint32_t flags;\n\n   char launch_arguments[4096];\n   char path_default_shader_preset[PATH_MAX_LENGTH];\n   char path_content[PATH_MAX_LENGTH];\n   char path_libretro[PATH_MAX_LENGTH];\n   char path_config_file[PATH_MAX_LENGTH];\n   char path_config_append_file[PATH_MAX_LENGTH];\n   char path_config_override_file[PATH_MAX_LENGTH];\n   char path_core_options_file[PATH_MAX_LENGTH];\n   char dir_system[DIR_MAX_LENGTH];\n   char dir_savefile[DIR_MAX_LENGTH];\n   char dir_savestate[DIR_MAX_LENGTH];\n};\n\n/* Forward declarations */\n#ifdef HAVE_LIBNX\nvoid libnx_apply_overclock(void);\n#endif\n\nstatic struct rarch_state rarch_st        = {0};\n\n#ifdef HAVE_THREAD_STORAGE\nstatic const void *MAGIC_POINTER          = (void*)(uintptr_t)0x0DEFACED;\n#endif\n\nstatic access_state_t access_state_st     = {0};\nstatic struct global global_driver_st     = {0}; /* retro_time_t alignment */\n\nstatic void retro_frame_null(const void *data, unsigned width,\n      unsigned height, size_t pitch) { }\nvoid retro_input_poll_null(void) { }\n\nstatic location_driver_t location_null = {\n   NULL,\n   NULL,\n   NULL,\n   NULL,\n   NULL,\n   NULL,\n   \"null\",\n};\n\nstatic const location_driver_t *location_drivers[] = {\n#ifdef ANDROID\n   &location_android,\n#endif\n   &location_null,\n   NULL,\n};\n\nstatic location_driver_state_t location_driver_st     = {0};\n\nlocation_driver_state_t *location_state_get_ptr(void)\n{\n   return &location_driver_st;\n}\n\nconst char *config_get_location_driver_options(void)\n{\n   return char_list_new_special(STRING_LIST_LOCATION_DRIVERS, NULL);\n}\n\nstatic void location_driver_find_driver(\n      settings_t *settings,\n      location_driver_state_t *location_st,\n      const char *prefix,\n      bool verbosity_enabled)\n{\n   int i                        = (int)driver_find_index(\n         \"location_driver\",\n         settings->arrays.location_driver);\n\n   if (i >= 0)\n      location_st->driver       = (const location_driver_t*)\n         location_drivers[i];\n   else\n   {\n      if (verbosity_enabled)\n      {\n         unsigned d;\n         RARCH_ERR(\"Couldn't find any %s named \\\"%s\\\"\\n\", prefix,\n               settings->arrays.location_driver);\n         RARCH_LOG_OUTPUT(\"Available %ss are:\\n\", prefix);\n         for (d = 0; location_drivers[d]; d++)\n            RARCH_LOG_OUTPUT(\"\\t%s\\n\", location_drivers[d]->ident);\n\n         RARCH_WARN(\"Going to default to first %s...\\n\", prefix);\n      }\n\n      location_st->driver = (const location_driver_t*)location_drivers[0];\n   }\n}\n\nbool driver_location_start(void)\n{\n   location_driver_state_t\n      *location_st              = &location_driver_st;\n   if (     location_st\n         && location_st->data\n         && location_st->driver\n         && location_st->driver->start)\n   {\n      settings_t *settings = config_get_ptr();\n      bool location_allow  = settings->bools.location_allow;\n      if (location_allow)\n         return location_st->driver->start(location_st->data);\n\n      /* TODO/FIXME - localize */\n      runloop_msg_queue_push(\n            \"Location is explicitly disabled.\\n\",\n            STRLEN_CONST(\"Location is explicitly disabled.\\n\"),\n            1, 180, true, NULL, MESSAGE_QUEUE_ICON_DEFAULT,\n            MESSAGE_QUEUE_CATEGORY_INFO);\n   }\n   return false;\n}\n\nvoid driver_location_stop(void)\n{\n   location_driver_state_t\n      *location_st              = &location_driver_st;\n   if (     location_st\n         && location_st->driver\n         && location_st->driver->stop\n         && location_st->data)\n      location_st->driver->stop(location_st->data);\n}\n\nvoid driver_location_set_interval(unsigned interval_msecs,\n      unsigned interval_distance)\n{\n   location_driver_state_t\n      *location_st              = &location_driver_st;\n   if (     location_st\n         && location_st->driver\n         && location_st->driver->set_interval\n         && location_st->data)\n      location_st->driver->set_interval(location_st->data,\n            interval_msecs, interval_distance);\n}\n\nbool driver_location_get_position(double *lat, double *lon,\n      double *horiz_accuracy, double *vert_accuracy)\n{\n   location_driver_state_t\n      *location_st              = &location_driver_st;\n   if (     location_st\n         && location_st->driver\n         && location_st->driver->get_position\n         && location_st->data)\n      return location_st->driver->get_position(location_st->data,\n            lat, lon, horiz_accuracy, vert_accuracy);\n\n   *lat            = 0.0;\n   *lon            = 0.0;\n   *horiz_accuracy = 0.0;\n   *vert_accuracy  = 0.0;\n   return false;\n}\n\nstatic bool init_location(\n      void *data,\n      location_driver_state_t *location_st,\n      settings_t *settings,\n      bool verbosity_enabled)\n{\n   /* Resource leaks will follow if location\n      interface is initialized twice. */\n   if (!location_st->data)\n   {\n      rarch_system_info_t *sys_info = (rarch_system_info_t*)data;\n      location_driver_find_driver(settings,\n            &location_driver_st,\n            \"location driver\", verbosity_enabled);\n\n      if (!(location_st->data = location_st->driver->init()))\n      {\n         RARCH_ERR(\"Failed to initialize location driver. Will continue without location.\\n\");\n         return false;\n      }\n\n      if (sys_info->location_cb.initialized)\n         sys_info->location_cb.initialized();\n   }\n\n   return true;\n}\n\nstatic void uninit_location(void *data, location_driver_state_t *location_st)\n{\n   if (location_st->data && location_st->driver)\n   {\n      rarch_system_info_t *sys_info = (rarch_system_info_t*)data;\n      if (sys_info->location_cb.deinitialized)\n         sys_info->location_cb.deinitialized();\n\n      if (location_st->driver->free)\n         location_st->driver->free(location_st->data);\n   }\n\n   location_st->active = false;\n   location_st->data   = NULL;\n}\n\nstatic void *rarch_midi_drv_data;\nstatic struct string_list *rarch_midi_drv_inputs;\nstatic struct string_list *rarch_midi_drv_outputs;\nstatic uint8_t *rarch_midi_drv_input_buffer;\nstatic uint8_t *rarch_midi_drv_output_buffer;\n\nstatic midi_event_t rarch_midi_drv_input_event;  /* ptr alignment */\nstatic midi_event_t rarch_midi_drv_output_event; /* ptr alignment */\n\nstatic bool rarch_midi_drv_input_enabled;\nstatic bool rarch_midi_drv_output_enabled;\nstatic bool rarch_midi_drv_output_pending;\n\nstatic void null_midi_free(void *p) { }\nstatic void *null_midi_init(const char *input, const char *output) { return (void*)-1; }\nstatic bool null_midi_get_avail_inputs(struct string_list *inputs) { union string_list_elem_attr attr = {0}; return string_list_append(inputs, \"Null\", attr); }\nstatic bool null_midi_get_avail_outputs(struct string_list *outputs) { union string_list_elem_attr attr = {0}; return string_list_append(outputs, \"Null\", attr); }\nstatic bool null_midi_set_input(void *p, const char *input) { return input == NULL || string_is_equal(input, \"Null\"); }\nstatic bool null_midi_set_output(void *p, const char *output) { return output == NULL || string_is_equal(output, \"Null\"); }\nstatic bool null_midi_read(void *p, midi_event_t *event) { return false; }\nstatic bool null_midi_write(void *p, const midi_event_t *event) { return true; }\nstatic bool null_midi_flush(void *p) { return true; }\n\nstatic midi_driver_t midi_null = {\n   \"null\",\n   null_midi_get_avail_inputs,\n   null_midi_get_avail_outputs,\n   null_midi_init,\n   null_midi_free,\n   null_midi_set_input,\n   null_midi_set_output,\n   null_midi_read,\n   null_midi_write,\n   null_midi_flush\n};\n\nstatic midi_driver_t *midi_drv  = &midi_null;\n\nmidi_driver_t *midi_drivers[]   = {\n#if defined(HAVE_ALSA) && !defined(HAVE_HAKCHI) && !defined(HAVE_SEGAM) && !defined(DINGUX)\n   &midi_alsa,\n#endif\n#ifdef HAVE_WINMM\n   &midi_winmm,\n#endif\n   &midi_null\n};\n\nstatic midi_driver_t *midi_driver_find_driver(const char *ident)\n{\n   unsigned i;\n\n   for (i = 0; i < ARRAY_SIZE(midi_drivers); ++i)\n   {\n      if (string_is_equal(midi_drivers[i]->ident, ident))\n         return midi_drivers[i];\n   }\n\n   RARCH_ERR(\"[MIDI]: Unknown driver \\\"%s\\\", falling back to \\\"null\\\" driver.\\n\", ident);\n\n   return &midi_null;\n}\n\nstatic const void *midi_driver_find_handle(int index)\n{\n   if (index < 0 || index >= (int)ARRAY_SIZE(midi_drivers))\n      return NULL;\n\n   return midi_drivers[index];\n}\n\nstruct string_list *midi_driver_get_avail_inputs(void)\n{\n   return rarch_midi_drv_inputs;\n}\n\nstruct string_list *midi_driver_get_avail_outputs(void)\n{\n   return rarch_midi_drv_outputs;\n}\n\nbool midi_driver_set_all_sounds_off(void)\n{\n   midi_event_t event;\n   uint8_t i;\n   uint8_t data[3]     = { 0xB0, 120, 0 };\n   bool result         = true;\n\n   if (!rarch_midi_drv_data || !rarch_midi_drv_output_enabled)\n      return false;\n\n#ifdef HAVE_WASAPI\n   /* FIXME: Due to some mysterious reason Frame Delay does not\n    * work with WASAPI unless MIDI output is active, even when\n    * MIDI is not used. Frame Delay also breaks if MIDI sounds\n    * are \"set off\", which happens on menu toggle, therefore\n    * skip this if WASAPI is used and Frame Delay is active.. */\n   if (string_is_equal(audio_state_get_ptr()->current_audio->ident, \"wasapi\"))\n   {\n      if (video_state_get_ptr()->frame_delay_target > 0)\n         return false;\n   }\n#endif\n\n   event.data       = data;\n   event.data_size  = sizeof(data);\n   event.delta_time = 0;\n\n   for (i = 0; i < 16; ++i)\n   {\n      data[0] = 0xB0 | i;\n\n      if (!midi_drv->write(rarch_midi_drv_data, &event))\n         result = false;\n   }\n\n   if (!midi_drv->flush(rarch_midi_drv_data))\n      result = false;\n\n   if (!result)\n      RARCH_ERR(\"[MIDI]: All sounds off failed.\\n\");\n\n   return result;\n}\n\nbool midi_driver_set_volume(unsigned volume)\n{\n   midi_event_t event;\n   uint8_t         data[8]     = {\n      0xF0, 0x7F, 0x7F, 0x04, 0x01, 0, 0, 0xF7};\n\n   if (!rarch_midi_drv_data || !rarch_midi_drv_output_enabled)\n      return false;\n\n   volume           = (unsigned)(163.83 * volume + 0.5);\n   if (volume > 16383)\n      volume        = 16383;\n\n   data[5]          = (uint8_t)(volume & 0x7F);\n   data[6]          = (uint8_t)(volume >> 7);\n\n   event.data       = data;\n   event.data_size  = sizeof(data);\n   event.delta_time = 0;\n\n   if (!midi_drv->write(rarch_midi_drv_data, &event))\n   {\n      RARCH_ERR(\"[MIDI]: Volume change failed.\\n\");\n      return false;\n   }\n\n   return true;\n}\n\nstatic bool midi_driver_init_io_buffers(void)\n{\n   uint8_t *midi_drv_input_buffer  = (uint8_t*)malloc(MIDI_DRIVER_BUF_SIZE);\n   uint8_t *midi_drv_output_buffer = (uint8_t*)malloc(MIDI_DRIVER_BUF_SIZE);\n\n   if (!midi_drv_input_buffer || !midi_drv_output_buffer)\n   {\n      if (midi_drv_input_buffer)\n         free(midi_drv_input_buffer);\n      if (midi_drv_output_buffer)\n         free(midi_drv_output_buffer);\n      return false;\n   }\n\n   rarch_midi_drv_input_buffer           = midi_drv_input_buffer;\n   rarch_midi_drv_output_buffer          = midi_drv_output_buffer;\n\n   rarch_midi_drv_input_event.data       = midi_drv_input_buffer;\n   rarch_midi_drv_input_event.data_size  = 0;\n\n   rarch_midi_drv_output_event.data      = midi_drv_output_buffer;\n   rarch_midi_drv_output_event.data_size = 0;\n\n   return true;\n}\n\nstatic void midi_driver_free(void)\n{\n   if (rarch_midi_drv_data)\n   {\n      midi_drv->free(rarch_midi_drv_data);\n      rarch_midi_drv_data = NULL;\n   }\n\n   if (rarch_midi_drv_inputs)\n   {\n      string_list_free(rarch_midi_drv_inputs);\n      rarch_midi_drv_inputs = NULL;\n   }\n\n   if (rarch_midi_drv_outputs)\n   {\n      string_list_free(rarch_midi_drv_outputs);\n      rarch_midi_drv_outputs = NULL;\n   }\n\n   if (rarch_midi_drv_input_buffer)\n   {\n      free(rarch_midi_drv_input_buffer);\n      rarch_midi_drv_input_buffer = NULL;\n   }\n\n   if (rarch_midi_drv_output_buffer)\n   {\n      free(rarch_midi_drv_output_buffer);\n      rarch_midi_drv_output_buffer = NULL;\n   }\n\n   rarch_midi_drv_input_enabled  = false;\n   rarch_midi_drv_output_enabled = false;\n}\n\nstatic bool midi_driver_init(void *data)\n{\n   union string_list_elem_attr\n      attr                        = {0};\n   bool ret                       = true;\n   settings_t *settings           = (settings_t*)data;\n\n   rarch_midi_drv_inputs          = string_list_new();\n   rarch_midi_drv_outputs         = string_list_new();\n\n   if (!rarch_midi_drv_inputs || !rarch_midi_drv_outputs)\n      ret = false;\n   else if (!string_list_append(rarch_midi_drv_inputs, MIDI_DRIVER_OFF, attr) ||\n            !string_list_append(rarch_midi_drv_outputs, MIDI_DRIVER_OFF, attr))\n      ret = false;\n   else\n   {\n      char * input  = NULL;\n      char * output = NULL;\n\n      midi_drv      = midi_driver_find_driver(\n            settings->arrays.midi_driver);\n\n      if (strcmp(midi_drv->ident, settings->arrays.midi_driver))\n      {\n         configuration_set_string(settings,\n               settings->arrays.midi_driver, midi_drv->ident);\n      }\n\n      if (!midi_drv->get_avail_inputs(rarch_midi_drv_inputs))\n         ret = false;\n      else if (!midi_drv->get_avail_outputs(rarch_midi_drv_outputs))\n         ret = false;\n      else\n      {\n         if (string_is_not_equal(settings->arrays.midi_input, MIDI_DRIVER_OFF))\n         {\n            if (string_list_find_elem(rarch_midi_drv_inputs, settings->arrays.midi_input))\n               input = settings->arrays.midi_input;\n            else\n            {\n               RARCH_WARN(\"[MIDI]: Input device \\\"%s\\\" unavailable.\\n\",\n                     settings->arrays.midi_input);\n               configuration_set_string(settings,\n                     settings->arrays.midi_input, MIDI_DRIVER_OFF);\n            }\n         }\n\n         if (string_is_not_equal(settings->arrays.midi_output, MIDI_DRIVER_OFF))\n         {\n            if (string_list_find_elem(rarch_midi_drv_outputs, settings->arrays.midi_output))\n               output = settings->arrays.midi_output;\n            else\n            {\n               RARCH_WARN(\"[MIDI]: Output device \\\"%s\\\" unavailable.\\n\",\n                     settings->arrays.midi_output);\n               configuration_set_string(settings,\n                     settings->arrays.midi_output, MIDI_DRIVER_OFF);\n            }\n         }\n\n         rarch_midi_drv_data = midi_drv->init(input, output);\n         if (!rarch_midi_drv_data)\n            ret = false;\n         else\n         {\n            rarch_midi_drv_input_enabled  = (input  != NULL);\n            rarch_midi_drv_output_enabled = (output != NULL);\n\n            if (!midi_driver_init_io_buffers())\n               ret = false;\n            else\n            {\n               if (input)\n                  RARCH_LOG(\"[MIDI]: Input device: \\\"%s\\\".\\n\", input);\n\n               if (output)\n               {\n                  RARCH_LOG(\"[MIDI]: Output device: \\\"%s\\\".\\n\", output);\n                  midi_driver_set_volume(settings->uints.midi_volume);\n               }\n            }\n         }\n      }\n   }\n\n   if (!ret)\n   {\n      midi_driver_free();\n      RARCH_ERR(\"[MIDI]: Initialization failed.\\n\");\n      return false;\n   }\n   return true;\n}\n\nbool midi_driver_set_input(const char *input)\n{\n   if (!rarch_midi_drv_data)\n   {\n#ifdef DEBUG\n      RARCH_ERR(\"[MIDI]: midi_driver_set_input called on uninitialized driver.\\n\");\n#endif\n      return false;\n   }\n\n   if (string_is_equal(input, MIDI_DRIVER_OFF))\n      input = NULL;\n\n   if (!midi_drv->set_input(rarch_midi_drv_data, input))\n   {\n      if (input)\n         RARCH_ERR(\"[MIDI]: Failed to change input device to \\\"%s\\\".\\n\", input);\n      else\n         RARCH_ERR(\"[MIDI]: Failed to disable input.\\n\");\n      return false;\n   }\n\n   if (input)\n      RARCH_LOG(\"[MIDI]: Input device changed to \\\"%s\\\".\\n\", input);\n   else\n      RARCH_LOG(\"[MIDI]: Input disabled.\\n\");\n\n   rarch_midi_drv_input_enabled = input != NULL;\n\n   return true;\n}\n\nbool midi_driver_set_output(void *settings_data, const char *output)\n{\n   settings_t        *settings = (settings_t*)settings_data;\n\n   if (!rarch_midi_drv_data)\n   {\n#ifdef DEBUG\n      RARCH_ERR(\"[MIDI]: midi_driver_set_output called on uninitialized driver.\\n\");\n#endif\n      return false;\n   }\n\n   if (string_is_equal(output, MIDI_DRIVER_OFF))\n      output = NULL;\n\n   if (!midi_drv->set_output(rarch_midi_drv_data, output))\n   {\n      if (output)\n         RARCH_ERR(\"[MIDI]: Failed to change output device to \\\"%s\\\".\\n\", output);\n      else\n         RARCH_ERR(\"[MIDI]: Failed to disable output.\\n\");\n      return false;\n   }\n\n   if (output)\n   {\n      rarch_midi_drv_output_enabled = true;\n      RARCH_LOG(\"[MIDI]: Output device changed to \\\"%s\\\".\\n\", output);\n\n      midi_driver_set_volume(settings->uints.midi_volume);\n   }\n   else\n   {\n      rarch_midi_drv_output_enabled = false;\n      RARCH_LOG(\"[MIDI]: Output disabled.\\n\");\n   }\n\n   return true;\n}\n\nbool midi_driver_input_enabled(void)\n{\n   return rarch_midi_drv_input_enabled;\n}\n\nbool midi_driver_output_enabled(void)\n{\n   return rarch_midi_drv_output_enabled;\n}\n\nbool midi_driver_read(uint8_t *byte)\n{\n   static int i = 0;\n\n   if (!rarch_midi_drv_data || !rarch_midi_drv_input_enabled || !byte)\n   {\n#ifdef DEBUG\n      if (!rarch_midi_drv_data)\n         RARCH_ERR(\"[MIDI]: midi_driver_read called on uninitialized driver.\\n\");\n      else if (!rarch_midi_drv_input_enabled)\n         RARCH_ERR(\"[MIDI]: midi_driver_read called when input is disabled.\\n\");\n      else\n         RARCH_ERR(\"[MIDI]: midi_driver_read called with null pointer.\\n\");\n#endif\n      return false;\n   }\n\n   if (i == (int)rarch_midi_drv_input_event.data_size)\n   {\n      rarch_midi_drv_input_event.data_size = MIDI_DRIVER_BUF_SIZE;\n      if (!midi_drv->read(rarch_midi_drv_data, &rarch_midi_drv_input_event))\n      {\n         rarch_midi_drv_input_event.data_size = i;\n         return false;\n      }\n\n      i = 0;\n\n#ifdef DEBUG\n      if (rarch_midi_drv_input_event.data_size == 1)\n         RARCH_LOG(\"[MIDI]: In [0x%02X].\\n\",\n               rarch_midi_drv_input_event.data[0]);\n      else if (rarch_midi_drv_input_event.data_size == 2)\n         RARCH_LOG(\"[MIDI]: In [0x%02X, 0x%02X].\\n\",\n               rarch_midi_drv_input_event.data[0],\n               rarch_midi_drv_input_event.data[1]);\n      else if (rarch_midi_drv_input_event.data_size == 3)\n         RARCH_LOG(\"[MIDI]: In [0x%02X, 0x%02X, 0x%02X].\\n\",\n               rarch_midi_drv_input_event.data[0],\n               rarch_midi_drv_input_event.data[1],\n               rarch_midi_drv_input_event.data[2]);\n      else\n         RARCH_LOG(\"[MIDI]: In [0x%02X, ...], size %u.\\n\",\n               rarch_midi_drv_input_event.data[0],\n               rarch_midi_drv_input_event.data_size);\n#endif\n   }\n\n   *byte = rarch_midi_drv_input_event.data[i++];\n\n   return true;\n}\n\nbool midi_driver_write(uint8_t byte, uint32_t delta_time)\n{\n   static int event_size;\n\n   if (!rarch_midi_drv_data || !rarch_midi_drv_output_enabled)\n   {\n#ifdef DEBUG\n      if (!rarch_midi_drv_data)\n         RARCH_ERR(\"[MIDI]: midi_driver_write called on uninitialized driver.\\n\");\n      else\n         RARCH_ERR(\"[MIDI]: midi_driver_write called when output is disabled.\\n\");\n#endif\n      return false;\n   }\n\n   if (byte >= 0x80)\n   {\n      if (     rarch_midi_drv_output_event.data_size\n            && rarch_midi_drv_output_event.data[0] == 0xF0)\n      {\n         if (byte == 0xF7)\n            event_size = (int)rarch_midi_drv_output_event.data_size + 1;\n         else\n         {\n            if (!midi_drv->write(rarch_midi_drv_data,\n                     &rarch_midi_drv_output_event))\n               return false;\n\n#ifdef DEBUG\n            switch (rarch_midi_drv_output_event.data_size)\n            {\n               case 1:\n                  RARCH_LOG(\"[MIDI]: Out [0x%02X].\\n\",\n                        rarch_midi_drv_output_event.data[0]);\n                  break;\n               case 2:\n                  RARCH_LOG(\"[MIDI]: Out [0x%02X, 0x%02X].\\n\",\n                        rarch_midi_drv_output_event.data[0],\n                        rarch_midi_drv_output_event.data[1]);\n                  break;\n               case 3:\n                  RARCH_LOG(\"[MIDI]: Out [0x%02X, 0x%02X, 0x%02X].\\n\",\n                        rarch_midi_drv_output_event.data[0],\n                        rarch_midi_drv_output_event.data[1],\n                        rarch_midi_drv_output_event.data[2]);\n                  break;\n               default:\n                  RARCH_LOG(\"[MIDI]: Out [0x%02X, ...], size %u.\\n\",\n                        rarch_midi_drv_output_event.data[0],\n                        rarch_midi_drv_output_event.data_size);\n                  break;\n            }\n#endif\n\n            rarch_midi_drv_output_pending             = true;\n            event_size                                = (int)midi_driver_get_event_size(byte);\n            rarch_midi_drv_output_event.data_size     = 0;\n            rarch_midi_drv_output_event.delta_time    = 0;\n         }\n      }\n      else\n      {\n         event_size                                   = (int)midi_driver_get_event_size(byte);\n         rarch_midi_drv_output_event.data_size        = 0;\n         rarch_midi_drv_output_event.delta_time       = 0;\n      }\n   }\n\n   if (rarch_midi_drv_output_event.data_size < MIDI_DRIVER_BUF_SIZE)\n   {\n      rarch_midi_drv_output_event.data[rarch_midi_drv_output_event.data_size] = byte;\n      ++rarch_midi_drv_output_event.data_size;\n      rarch_midi_drv_output_event.delta_time += delta_time;\n   }\n   else\n   {\n#ifdef DEBUG\n      RARCH_ERR(\"[MIDI]: Output event dropped.\\n\");\n#endif\n      return false;\n   }\n\n   if (event_size == (int)rarch_midi_drv_output_event.data_size)\n   {\n      if (!midi_drv->write(rarch_midi_drv_data, &rarch_midi_drv_output_event))\n         return false;\n\n#ifdef DEBUG\n      switch (rarch_midi_drv_output_event.data_size)\n      {\n         case 1:\n            RARCH_LOG(\"[MIDI]: Out [0x%02X].\\n\",\n                  rarch_midi_drv_output_event.data[0]);\n            break;\n         case 2:\n            RARCH_LOG(\"[MIDI]: Out [0x%02X, 0x%02X].\\n\",\n                  rarch_midi_drv_output_event.data[0],\n                  rarch_midi_drv_output_event.data[1]);\n            break;\n         case 3:\n            RARCH_LOG(\"[MIDI]: Out [0x%02X, 0x%02X, 0x%02X].\\n\",\n                  rarch_midi_drv_output_event.data[0],\n                  rarch_midi_drv_output_event.data[1],\n                  rarch_midi_drv_output_event.data[2]);\n            break;\n         default:\n            RARCH_LOG(\"[MIDI]: Out [0x%02X, ...], size %u.\\n\",\n                  rarch_midi_drv_output_event.data[0],\n                  rarch_midi_drv_output_event.data_size);\n            break;\n      }\n#endif\n\n      rarch_midi_drv_output_pending             = true;\n      rarch_midi_drv_output_event.data_size     = 0;\n      rarch_midi_drv_output_event.delta_time    = 0;\n   }\n\n   return true;\n}\n\nbool midi_driver_flush(void)\n{\n   if (!rarch_midi_drv_data)\n      return false;\n\n   if (rarch_midi_drv_output_pending)\n      rarch_midi_drv_output_pending = !midi_drv->flush(rarch_midi_drv_data);\n\n   return !rarch_midi_drv_output_pending;\n}\n\nsize_t midi_driver_get_event_size(uint8_t status)\n{\n   static const uint8_t midi_drv_ev_sizes[128]                     =\n   {\n      3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n      3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n      3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n      3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n      3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n      0, 2, 3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n   };\n\n   if (status < 0x80)\n   {\n#ifdef DEBUG\n      RARCH_ERR(\"[MIDI]: midi_driver_get_event_size called with invalid status.\\n\");\n#endif\n      return 0;\n   }\n\n   return midi_drv_ev_sizes[status - 0x80];\n}\n\n/**\n * find_driver_nonempty:\n * @label              : string of driver type to be found.\n * @i                  : index of driver.\n * @str                : identifier name of the found driver\n *                       gets written to this string.\n * @len                : size of @str.\n *\n * Find driver based on @label.\n *\n * Returns: NULL if no driver based on @label found, otherwise\n * pointer to driver.\n **/\nstatic size_t find_driver_nonempty(\n      const char *label, int i, char *s, size_t len)\n{\n   if (string_is_equal(label, \"camera_driver\"))\n   {\n      if (camera_drivers[i])\n         return strlcpy(s, camera_drivers[i]->ident, len);\n   }\n   else if (string_is_equal(label, \"location_driver\"))\n   {\n      if (location_drivers[i])\n         return strlcpy(s, location_drivers[i]->ident, len);\n   }\n#ifdef HAVE_MENU\n   else if (string_is_equal(label, \"menu_driver\"))\n   {\n      if (menu_ctx_drivers[i])\n         return strlcpy(s, menu_ctx_drivers[i]->ident, len);\n   }\n#endif\n   else if (string_is_equal(label, \"input_driver\"))\n   {\n      if (input_drivers[i])\n         return strlcpy(s, input_drivers[i]->ident, len);\n   }\n   else if (string_is_equal(label, \"input_joypad_driver\"))\n   {\n      if (joypad_drivers[i])\n         return strlcpy(s, joypad_drivers[i]->ident, len);\n   }\n   else if (string_is_equal(label, \"video_driver\"))\n   {\n      if (video_drivers[i])\n         return strlcpy(s, video_drivers[i]->ident, len);\n   }\n   else if (string_is_equal(label, \"audio_driver\"))\n   {\n      if (audio_drivers[i])\n         return strlcpy(s, audio_drivers[i]->ident, len);\n   }\n#ifdef HAVE_MICROPHONE\n   else if (string_is_equal(label, \"microphone_driver\"))\n   {\n      if (microphone_drivers[i])\n         return strlcpy(s, microphone_drivers[i]->ident, len);\n   }\n#endif\n   else if (string_is_equal(label, \"record_driver\"))\n   {\n      if (record_drivers[i])\n         return strlcpy(s, record_drivers[i]->ident, len);\n   }\n   else if (string_is_equal(label, \"midi_driver\"))\n   {\n      if (midi_driver_find_handle(i))\n         return strlcpy(s, midi_drivers[i]->ident, len);\n   }\n   else if (string_is_equal(label, \"audio_resampler_driver\"))\n   {\n      if (audio_resampler_driver_find_handle(i))\n         return strlcpy(s, audio_resampler_driver_find_ident(i), len);\n   }\n#ifdef HAVE_BLUETOOTH\n   else if (string_is_equal(label, \"bluetooth_driver\"))\n   {\n      if (bluetooth_drivers[i])\n         return strlcpy(s, bluetooth_drivers[i]->ident, len);\n   }\n#endif\n#ifdef HAVE_WIFI\n   else if (string_is_equal(label, \"wifi_driver\"))\n   {\n      if (wifi_drivers[i])\n         return strlcpy(s, wifi_drivers[i]->ident, len);\n   }\n#endif\n#ifdef HAVE_CLOUDSYNC\n   else if (string_is_equal(label, \"cloud_sync_driver\"))\n   {\n      if (cloud_sync_drivers[i])\n         return strlcpy(s, cloud_sync_drivers[i]->ident, len);\n   }\n#endif\n   return 0;\n}\n\nint driver_find_index(const char *label, const char *drv)\n{\n   unsigned i;\n   char str[NAME_MAX_LENGTH];\n\n   str[0] = '\\0';\n\n   for (i = 0;\n         find_driver_nonempty(label, i, str, sizeof(str)) > 0; i++)\n   {\n      if (string_is_empty(str))\n         break;\n      if (string_is_equal_noncase(drv, str))\n         return i;\n   }\n\n   return -1;\n}\n\n/**\n * driver_find_last:\n * @label              : string of driver type to be found.\n * @s                  : identifier of driver to be found.\n * @len                : size of @s.\n *\n * Find last driver in driver array.\n **/\nstatic void driver_find_last(const char *label, char *s, size_t len)\n{\n   unsigned i;\n\n   for (i = 0;\n         find_driver_nonempty(label, i, s, len) > 0; i++) { }\n\n   if (i)\n      i = i - 1;\n   else\n      i = 0;\n\n   find_driver_nonempty(label, i, s, len);\n}\n\n/**\n * driver_find_prev:\n * @label              : string of driver type to be found.\n * @s                  : identifier of driver to be found.\n * @len                : size of @s.\n *\n * Find previous driver in driver array.\n **/\nstatic size_t driver_find_prev(const char *label, char *s, size_t len)\n{\n   int i = driver_find_index(label, s);\n\n   if (i > 0)\n      return find_driver_nonempty(label, i - 1, s, len);\n\n   RARCH_WARN(\n         \"Couldn't find any previous driver (current one: \\\"%s\\\").\\n\", s);\n   return 0;\n}\n\n/**\n * driver_find_next:\n * @label              : string of driver type to be found.\n * @s                  : identifier of driver to be found.\n * @len                : size of @s.\n *\n * Find next driver in driver array.\n **/\nstatic size_t driver_find_next(const char *label, char *s, size_t len)\n{\n   int i = driver_find_index(label, s);\n   if (i >= 0 && string_is_not_equal(s, \"null\"))\n      return find_driver_nonempty(label, i + 1, s, len);\n   RARCH_WARN(\"%s (current one: \\\"%s\\\").\\n\",\n         msg_hash_to_str(MSG_COULD_NOT_FIND_ANY_NEXT_DRIVER),\n         s);\n   return 0;\n}\n\nstatic float audio_driver_monitor_adjust_system_rates(\n      double input_sample_rate,\n      double input_fps,\n      float video_refresh_rate,\n      unsigned video_swap_interval,\n      unsigned black_frame_insertion,\n      unsigned shader_subframes,\n      float audio_max_timing_skew)\n{\n   float inp_sample_rate        = input_sample_rate;\n\n   /*  This much like the auto swap interval algorithm and will\n    *  find the correct desired target rate the majority of sane\n    *  cases. Any failures should be no worse than the previous\n    *  very incomplete high hz skew adjustments. */\n   float refresh_ratio                   = video_refresh_rate/input_fps;\n   unsigned refresh_closest_multiple     = (unsigned)(refresh_ratio + 0.5f);\n   float target_video_sync_rate          = video_refresh_rate;\n   float timing_skew                     = 0.0f;\n\n   if (refresh_closest_multiple > 1)\n      target_video_sync_rate /= (((float)black_frame_insertion + 1.0f) * (float)video_swap_interval * (float)shader_subframes);\n\n   timing_skew            =\n      fabs(1.0f - input_fps / target_video_sync_rate);\n   if (timing_skew <= audio_max_timing_skew)\n      return (inp_sample_rate * target_video_sync_rate / input_fps);\n   return inp_sample_rate;\n}\n\nstatic bool video_driver_monitor_adjust_system_rates(\n      float timing_skew_hz,\n      float video_refresh_rate,\n      bool vrr_runloop_enable,\n      float audio_max_timing_skew,\n      unsigned video_swap_interval,\n      unsigned black_frame_insertion,\n      unsigned shader_subframes,\n      double input_fps)\n{\n   float target_video_sync_rate = timing_skew_hz;\n\n   /* Same concept as for audio driver adjust. */\n   float refresh_ratio                   = target_video_sync_rate/input_fps;\n   unsigned refresh_closest_multiple     = (unsigned)(refresh_ratio + 0.5f);\n   float timing_skew                     = 0.0f;\n\n   if (refresh_closest_multiple > 1)\n      target_video_sync_rate /= (((float)black_frame_insertion + 1.0f) * (float)video_swap_interval * (float)shader_subframes);\n\n   if (!vrr_runloop_enable)\n   {\n      timing_skew         =\n         fabs(1.0f - input_fps / target_video_sync_rate);\n      /* We don't want to adjust pitch too much. If we have extreme cases,\n       * just don't readjust at all. */\n      if (timing_skew <= audio_max_timing_skew)\n         return true;\n      RARCH_LOG(\"[Video]: Timings deviate too much. Will not adjust.\"\n            \" (Target = %.2f Hz, Game = %.2f Hz)\\n\",\n            target_video_sync_rate,\n            (float)input_fps);\n   }\n   return input_fps <= target_video_sync_rate;\n}\n\nstatic void driver_adjust_system_rates(\n      runloop_state_t *runloop_st,\n      video_driver_state_t *video_st,\n      settings_t *settings)\n{\n   struct retro_system_av_info *av_info   = &video_st->av_info;\n   const struct retro_system_timing *info =\n      (const struct retro_system_timing*)&av_info->timing;\n   double input_sample_rate               = info->sample_rate;\n   double input_fps                       = info->fps;\n   float video_refresh_rate               = settings->floats.video_refresh_rate;\n   float audio_max_timing_skew            = settings->floats.audio_max_timing_skew;\n   unsigned video_swap_interval           = settings->uints.video_swap_interval;\n   unsigned black_frame_insertion         = settings->uints.video_black_frame_insertion;\n   unsigned shader_subframes              = settings->uints.video_shader_subframes;\n   bool vrr_runloop_enable                = settings->bools.vrr_runloop_enable;\n   bool video_adaptive_vsync              = settings->bools.video_adaptive_vsync;\n\n   /* Update video swap interval if automatic\n    * switching is enabled */\n   runloop_set_video_swap_interval(\n         vrr_runloop_enable,\n         (video_st->flags & VIDEO_FLAG_CRT_SWITCHING_ACTIVE) ? true : false,\n         video_swap_interval,\n         black_frame_insertion,\n         shader_subframes,\n         audio_max_timing_skew,\n         video_refresh_rate,\n         input_fps);\n   video_swap_interval = runloop_get_video_swap_interval(\n         video_swap_interval);\n\n   if (input_sample_rate > 0.0)\n   {\n      audio_driver_state_t *audio_st      = audio_state_get_ptr();\n      if (vrr_runloop_enable)\n         audio_st->input = input_sample_rate;\n      else\n         audio_st->input =\n            audio_driver_monitor_adjust_system_rates(\n                  input_sample_rate,\n                  input_fps,\n                  video_refresh_rate,\n                  video_swap_interval,\n                  black_frame_insertion,\n                  shader_subframes,\n                  audio_max_timing_skew);\n\n      RARCH_LOG(\"[Audio]: Set audio input rate to: %.2f Hz.\\n\",\n            audio_st->input);\n   }\n\n   runloop_st->flags &= ~RUNLOOP_FLAG_FORCE_NONBLOCK;\n\n   if (input_fps > 0.0)\n   {\n      float timing_skew_hz          = video_refresh_rate;\n\n      if (video_st->flags & VIDEO_FLAG_CRT_SWITCHING_ACTIVE)\n         timing_skew_hz             = input_fps;\n      video_st->core_hz             = input_fps;\n\n      if (!video_driver_monitor_adjust_system_rates(\n               timing_skew_hz,\n               video_refresh_rate,\n               vrr_runloop_enable,\n               audio_max_timing_skew,\n               video_swap_interval,\n               black_frame_insertion,\n               shader_subframes,\n               input_fps))\n      {\n         /* We won't be able to do VSync reliably\n            when game FPS > monitor FPS. */\n         runloop_st->flags |= RUNLOOP_FLAG_FORCE_NONBLOCK;\n         RARCH_LOG(\"[Video]: Game FPS > Monitor FPS. Cannot rely on VSync.\\n\");\n\n         if (VIDEO_DRIVER_GET_PTR_INTERNAL(video_st))\n         {\n            if (video_st->current_video->set_nonblock_state)\n               video_st->current_video->set_nonblock_state(\n                     video_st->data, true,\n                     video_driver_test_all_flags(GFX_CTX_FLAGS_ADAPTIVE_VSYNC)\n                     && video_adaptive_vsync,\n                     video_swap_interval);\n         }\n         return;\n      }\n   }\n\n   if (VIDEO_DRIVER_GET_PTR_INTERNAL(video_st))\n      driver_set_nonblock_state();\n}\n\n/**\n * driver_set_nonblock_state:\n *\n * Sets audio and video drivers to nonblock state (if enabled).\n *\n * If nonblock state is false, sets\n * blocking state for both audio and video drivers instead.\n **/\nvoid driver_set_nonblock_state(void)\n{\n   runloop_state_t *runloop_st = runloop_state_get_ptr();\n   input_driver_state_t\n      *input_st                = input_state_get_ptr();\n   audio_driver_state_t\n      *audio_st                = audio_state_get_ptr();\n   video_driver_state_t\n      *video_st                = video_state_get_ptr();\n   bool                 enable = input_st ?\n      (input_st->flags & INP_FLAG_NONBLOCKING) : false;\n   settings_t       *settings  = config_get_ptr();\n   bool audio_sync             = settings->bools.audio_sync;\n   bool video_vsync            = settings->bools.video_vsync;\n   bool adaptive_vsync         = settings->bools.video_adaptive_vsync;\n   unsigned swap_interval      = runloop_get_video_swap_interval(\n         settings->uints.video_swap_interval);\n   bool video_driver_active    = (video_st->flags  & VIDEO_FLAG_ACTIVE) ? true : false;\n   bool audio_driver_active    = (audio_st->flags  & AUDIO_FLAG_ACTIVE) ? true : false;\n   bool runloop_force_nonblock = (runloop_st->flags & RUNLOOP_FLAG_FORCE_NONBLOCK) ? true : false;\n\n   /* Only apply non-block-state for video if we're using vsync. */\n   if (video_driver_active && VIDEO_DRIVER_GET_PTR_INTERNAL(video_st))\n   {\n      if (video_st->current_video->set_nonblock_state)\n      {\n         bool video_nonblock        = enable;\n         if (!video_vsync || runloop_force_nonblock)\n            video_nonblock = true;\n         video_st->current_video->set_nonblock_state(video_st->data,\n               video_nonblock,\n               video_driver_test_all_flags(GFX_CTX_FLAGS_ADAPTIVE_VSYNC)\n               && adaptive_vsync, swap_interval);\n      }\n   }\n\n   if (audio_driver_active && audio_st->context_audio_data)\n      audio_st->current_audio->set_nonblock_state(\n            audio_st->context_audio_data,\n            audio_sync ? enable : true);\n\n   audio_st->chunk_size = enable\n      ? audio_st->chunk_nonblock_size\n      : audio_st->chunk_block_size;\n}\n\nvoid drivers_init(\n      settings_t *settings,\n      int flags,\n      enum driver_lifetime_flags lifetime_flags,\n      bool verbosity_enabled)\n{\n   runloop_state_t *runloop_st       = runloop_state_get_ptr();\n   audio_driver_state_t *audio_st    = audio_state_get_ptr();\n   input_driver_state_t *input_st    = input_state_get_ptr();\n   video_driver_state_t *video_st    = video_state_get_ptr();\n#ifdef HAVE_MICROPHONE\n   microphone_driver_state_t *mic_st = microphone_state_get_ptr();\n#endif\n#ifdef HAVE_MENU\n   struct menu_state *menu_st     = menu_state_get_ptr();\n#endif\n   camera_driver_state_t\n      *camera_st                  = camera_state_get_ptr();\n   location_driver_state_t\n      *location_st                = location_state_get_ptr();\n   bool video_is_threaded         = VIDEO_DRIVER_IS_THREADED_INTERNAL(video_st);\n   gfx_display_t *p_disp          = disp_get_ptr();\n#if defined(HAVE_GFX_WIDGETS)\n   bool video_font_enable         = settings->bools.video_font_enable;\n   bool menu_enable_widgets       = settings->bools.menu_enable_widgets;\n   dispgfx_widget_t *p_dispwidget = dispwidget_get_ptr();\n   /* By default, we want display widgets to persist through driver reinits. */\n   p_dispwidget->flags           |= DISPGFX_WIDGET_FLAG_PERSISTING;\n#endif\n#ifdef HAVE_MENU\n   /* By default, we want the menu to persist through driver reinits. */\n   if (menu_st)\n      menu_st->flags             |= MENU_ST_FLAG_DATA_OWN;\n#endif\n\n   /* Initialize video driver */\n   if (flags & DRIVER_VIDEO_MASK)\n   {\n      struct retro_hw_render_callback *hwr   =\n         VIDEO_DRIVER_GET_HW_CONTEXT_INTERNAL(video_st);\n\n      video_st->frame_time_count = 0;\n\n      video_driver_lock_new();\n#ifdef HAVE_VIDEO_FILTER\n      video_driver_filter_free();\n#endif\n      video_st->frame_cache_data  = NULL;\n      if (!video_driver_init_internal(&video_is_threaded,\n               verbosity_enabled))\n         retroarch_fail(1, \"video_driver_init_internal()\");\n\n      if (   !(video_st->flags & VIDEO_FLAG_CACHE_CONTEXT_ACK)\n            && hwr->context_reset)\n         hwr->context_reset();\n      video_st->flags            &= ~VIDEO_FLAG_CACHE_CONTEXT_ACK;\n      runloop_st->frame_time_last = 0;\n   }\n\n   /* Regular display refresh rate startup autoswitch based on content av_info */\n   if (     flags & (DRIVER_VIDEO_MASK | DRIVER_AUDIO_MASK)\n         && !(runloop_st->flags & RUNLOOP_FLAG_IS_INITED))\n   {\n      struct retro_system_av_info *av_info = &video_st->av_info;\n      float refresh_rate                   = av_info->timing.fps;\n      unsigned autoswitch_refresh_rate     = settings->uints.video_autoswitch_refresh_rate;\n      bool exclusive_fullscreen            = settings->bools.video_fullscreen && !settings->bools.video_windowed_fullscreen;\n      bool windowed_fullscreen             = settings->bools.video_fullscreen &&  settings->bools.video_windowed_fullscreen;\n      bool all_fullscreen                  = settings->bools.video_fullscreen ||  settings->bools.video_windowed_fullscreen;\n\n      /* Making a switch from PC standard 60 Hz to NTSC 59.94 is excluded by the last condition. */\n      if (     (refresh_rate > 0.0f)\n            && !settings->uints.crt_switch_resolution\n            && !settings->bools.vrr_runloop_enable\n            && video_display_server_has_resolution_list()\n            && (autoswitch_refresh_rate != AUTOSWITCH_REFRESH_RATE_OFF)\n            && (fabs(settings->floats.video_refresh_rate - refresh_rate) > 1))\n      {\n         if (   ((autoswitch_refresh_rate == AUTOSWITCH_REFRESH_RATE_EXCLUSIVE_FULLSCREEN) && exclusive_fullscreen)\n             || ((autoswitch_refresh_rate == AUTOSWITCH_REFRESH_RATE_WINDOWED_FULLSCREEN)  && windowed_fullscreen)\n             || ((autoswitch_refresh_rate == AUTOSWITCH_REFRESH_RATE_ALL_FULLSCREEN)       && all_fullscreen))\n         {\n            bool video_switch_refresh_rate = false;\n\n            video_switch_refresh_rate_maybe(&refresh_rate, &video_switch_refresh_rate);\n            if (video_switch_refresh_rate && video_display_server_set_refresh_rate(refresh_rate))\n               video_monitor_set_refresh_rate(refresh_rate);\n         }\n      }\n   }\n\n   /* Adjust rates */\n   if (flags & (DRIVER_VIDEO_MASK | DRIVER_AUDIO_MASK))\n      driver_adjust_system_rates(runloop_st, video_st, settings);\n\n   /* Initialize audio driver */\n   if (flags & DRIVER_AUDIO_MASK)\n   {\n      audio_driver_init_internal(\n            settings,\n            audio_st->callback.callback != NULL);\n      if (     audio_st->current_audio\n            && audio_st->current_audio->device_list_new\n            && audio_st->context_audio_data)\n         audio_st->devices_list = (struct string_list*)\n            audio_st->current_audio->device_list_new(\n                  audio_st->context_audio_data);\n   }\n\n#ifdef HAVE_MICROPHONE\n   if (flags & DRIVER_MICROPHONE_MASK)\n   {\n      microphone_driver_init_internal(settings);\n      if (mic_st->driver && mic_st->driver->device_list_new && mic_st->driver_context)\n         mic_st->devices_list = mic_st->driver->device_list_new(mic_st->driver_context);\n   }\n#endif\n\n   if (flags & DRIVER_CAMERA_MASK)\n   {\n      /* Only initialize camera driver if we're ever going to use it. */\n      if (camera_st->active)\n      {\n         /* Resource leaks will follow if camera is initialized twice. */\n         if (!camera_st->data)\n         {\n            if (!camera_driver_find_driver(\"camera driver\",\n                     verbosity_enabled))\n               retroarch_fail(1, \"find_camera_driver()\");\n\n            if (camera_st->driver)\n            {\n               camera_st->data = camera_st->driver->init(\n                     *settings->arrays.camera_device ?\n                     settings->arrays.camera_device : NULL,\n                     camera_st->cb.caps,\n                     settings->uints.camera_width ?\n                     settings->uints.camera_width  : camera_st->cb.width,\n                     settings->uints.camera_height ?\n                     settings->uints.camera_height : camera_st->cb.height);\n\n               if (!camera_st->data)\n               {\n                  RARCH_ERR(\"Failed to initialize camera driver. Will continue without camera.\\n\");\n                  camera_st->active = false;\n               }\n\n               if (camera_st->cb.initialized)\n                  camera_st->cb.initialized();\n            }\n         }\n      }\n   }\n\n#ifdef HAVE_BLUETOOTH\n   if (flags & DRIVER_BLUETOOTH_MASK)\n      bluetooth_driver_ctl(RARCH_BLUETOOTH_CTL_INIT, NULL);\n#endif\n#ifdef HAVE_WIFI\n   if ((flags & DRIVER_WIFI_MASK))\n      wifi_driver_ctl(RARCH_WIFI_CTL_INIT, NULL);\n#endif\n\n   if (flags & DRIVER_LOCATION_MASK)\n   {\n      /* Only initialize location driver if we're ever going to use it. */\n      if (location_st->active)\n         if (!init_location(&runloop_state_get_ptr()->system,\n                  &location_driver_st,\n                  settings, verbosity_is_enabled()))\n            location_st->active = false;\n   }\n\n   core_info_init_current_core();\n\n#if defined(HAVE_GFX_WIDGETS)\n   /* Note that we only enable widgets if 'video_font_enable'\n    * is true. 'video_font_enable' corresponds to the generic\n    * 'On-Screen Notifications' setting, which should serve as\n    * a global notifications on/off toggle switch */\n   if (   video_font_enable\n       && menu_enable_widgets\n       && video_st->current_video\n       && video_st->current_video->gfx_widgets_enabled\n       && video_st->current_video->gfx_widgets_enabled(video_st->data))\n   {\n      bool rarch_force_fullscreen = (video_st->flags &\n         VIDEO_FLAG_FORCE_FULLSCREEN) ? true : false;\n      bool video_is_fullscreen    = settings->bools.video_fullscreen\n                                 || rarch_force_fullscreen;\n\n      p_dispwidget->active= gfx_widgets_init(\n            p_disp,\n            anim_get_ptr(),\n            settings,\n            (uintptr_t)&p_dispwidget->active,\n            video_is_threaded,\n            video_st->width,\n            video_st->height,\n            video_is_fullscreen,\n            settings->paths.directory_assets,\n            settings->paths.path_font);\n   }\n   else\n#endif\n   {\n      gfx_display_init_first_driver(p_disp, video_is_threaded);\n   }\n\n#ifdef HAVE_MENU\n   if (flags & DRIVER_VIDEO_MASK)\n   {\n      /* Initialize menu driver */\n      if (flags & DRIVER_MENU_MASK)\n      {\n         if (!menu_driver_init(video_is_threaded))\n             RARCH_ERR(\"Unable to init menu driver.\\n\");\n\n#ifdef HAVE_LIBRETRODB\n         menu_explore_context_init();\n#endif\n         menu_contentless_cores_context_init();\n      }\n   }\n\n   /* Initialising the menu driver will also initialise\n    * core info - if we are not initialising the menu\n    * driver, must initialise core info 'by hand' */\n   if (   !(flags & DRIVER_VIDEO_MASK)\n       || !(flags & DRIVER_MENU_MASK))\n   {\n      command_event(CMD_EVENT_CORE_INFO_INIT, NULL);\n      command_event(CMD_EVENT_LOAD_CORE_PERSIST, NULL);\n   }\n\n#else\n   /* Qt uses core info, even if the menu is disabled */\n   command_event(CMD_EVENT_CORE_INFO_INIT, NULL);\n   command_event(CMD_EVENT_LOAD_CORE_PERSIST, NULL);\n#endif\n\n   /* Keep non-throttled state as good as possible. */\n   if (flags & (DRIVER_VIDEO_MASK | DRIVER_AUDIO_MASK))\n      if (input_st && (input_st->flags & INP_FLAG_NONBLOCKING))\n         driver_set_nonblock_state();\n\n   /* Initialize LED driver */\n   if (flags & DRIVER_LED_MASK)\n      led_driver_init(settings->arrays.led_driver);\n\n   /* Initialize MIDI driver */\n   if (flags & DRIVER_MIDI_MASK)\n      midi_driver_init(settings);\n\n#ifdef HAVE_LAKKA\n   cpu_scaling_driver_init();\n#endif\n}\n\nvoid driver_uninit(int flags, enum driver_lifetime_flags lifetime_flags)\n{\n   runloop_state_t *runloop_st      = runloop_state_get_ptr();\n   video_driver_state_t *video_st   = video_state_get_ptr();\n   camera_driver_state_t *camera_st = camera_state_get_ptr();\n#if defined(HAVE_GFX_WIDGETS)\n   dispgfx_widget_t *p_dispwidget   = dispwidget_get_ptr();\n#endif\n\n   core_info_deinit_list();\n   core_info_free_current_core();\n\n#if defined(HAVE_GFX_WIDGETS)\n   /* This absolutely has to be done before video_driver_free_internal()\n    * is called/completes, otherwise certain menu drivers\n    * (e.g. Vulkan) will segfault */\n   if (p_dispwidget->flags & DISPGFX_WIDGET_FLAG_INITED)\n   {\n      gfx_widgets_deinit(p_dispwidget->flags & DISPGFX_WIDGET_FLAG_PERSISTING);\n      p_dispwidget->active = false;\n   }\n#endif\n\n#ifdef HAVE_MENU\n   if (flags & DRIVER_MENU_MASK)\n   {\n#ifdef HAVE_LIBRETRODB\n      menu_explore_context_deinit();\n#endif\n      menu_contentless_cores_context_deinit();\n\n#ifdef HAVE_CHEEVOS\n      rcheevos_menu_reset_badges();\n#endif\n\n      menu_driver_ctl(RARCH_MENU_CTL_DEINIT, NULL);\n   }\n#endif\n\n   if ((flags & DRIVER_LOCATION_MASK))\n      uninit_location(&runloop_st->system, &location_driver_st);\n\n   if ((flags & DRIVER_CAMERA_MASK))\n   {\n      if (camera_st->data && camera_st->driver)\n      {\n         if (camera_st->cb.deinitialized)\n            camera_st->cb.deinitialized();\n\n         if (camera_st->driver->free)\n            camera_st->driver->free(camera_st->data);\n      }\n\n      camera_st->data = NULL;\n   }\n\n#ifdef HAVE_BLUETOOTH\n   if ((flags & DRIVER_BLUETOOTH_MASK))\n      bluetooth_driver_ctl(RARCH_BLUETOOTH_CTL_DEINIT, NULL);\n#endif\n#ifdef HAVE_WIFI\n   if ((flags & DRIVER_WIFI_MASK))\n      wifi_driver_ctl(RARCH_WIFI_CTL_DEINIT, NULL);\n#endif\n\n   if (flags & DRIVER_LED)\n      led_driver_free();\n\n   if (flags & DRIVERS_VIDEO_INPUT)\n   {\n      video_driver_free_internal();\n      VIDEO_DRIVER_LOCK_FREE(video_st);\n      video_st->data              = NULL;\n      video_st->frame_cache_data  = NULL;\n   }\n\n   if (flags & DRIVER_AUDIO_MASK)\n      audio_driver_deinit();\n\n   if ((flags & DRIVER_VIDEO_MASK))\n      video_st->data = NULL;\n\n   if ((flags & DRIVER_INPUT_MASK))\n      input_state_get_ptr()->current_data = NULL;\n\n   if ((flags & DRIVER_AUDIO_MASK))\n      audio_state_get_ptr()->context_audio_data = NULL;\n\n#ifdef HAVE_MICROPHONE\n   if (flags & DRIVER_MICROPHONE_MASK)\n      microphone_driver_deinit(lifetime_flags & DRIVER_LIFETIME_RESET);\n#endif\n\n   if (flags & DRIVER_MIDI_MASK)\n      midi_driver_free();\n\n#ifdef HAVE_LAKKA\n   cpu_scaling_driver_free();\n#endif\n}\n\nstatic void retroarch_deinit_drivers(struct retro_callbacks *cbs)\n{\n   input_driver_state_t *input_st  = input_state_get_ptr();\n   video_driver_state_t *video_st  = video_state_get_ptr();\n   camera_driver_state_t *camera_st= camera_state_get_ptr();\n   location_driver_state_t\n      *location_st                 = location_state_get_ptr();\n   runloop_state_t     *runloop_st = runloop_state_get_ptr();\n#if defined(HAVE_GFX_WIDGETS)\n   /* Tear down display widgets no matter what\n    * in case the handle is lost in the threaded\n    * video driver in the meantime\n    * (breaking video_driver_has_widgets) */\n   dispgfx_widget_t *p_dispwidget  = dispwidget_get_ptr();\n   if (p_dispwidget->flags & DISPGFX_WIDGET_FLAG_INITED)\n   {\n      gfx_widgets_deinit(\n            p_dispwidget->flags & DISPGFX_WIDGET_FLAG_PERSISTING);\n      p_dispwidget->active         = false;\n   }\n#endif\n\n#if defined(HAVE_CRTSWITCHRES)\n   /* Switchres deinit */\n   if (video_st->flags & VIDEO_FLAG_CRT_SWITCHING_ACTIVE)\n      crt_destroy_modes(&video_st->crt_switch_st);\n#endif\n\n   /* Video */\n   video_display_server_destroy();\n\n   video_st->flags &= ~(VIDEO_FLAG_ACTIVE      | VIDEO_FLAG_USE_RGBA      |\n                        VIDEO_FLAG_HDR_SUPPORT | VIDEO_FLAG_CACHE_CONTEXT |\n                        VIDEO_FLAG_CACHE_CONTEXT_ACK\n                       );\n   video_st->record_gpu_buffer          = NULL;\n   video_st->current_video              = NULL;\n   video_st->frame_cache_data           = NULL;\n\n   /* Audio */\n   audio_state_get_ptr()->flags        &= ~AUDIO_FLAG_ACTIVE;\n   audio_state_get_ptr()->current_audio = NULL;\n\n   if (input_st)\n   {\n      /* Input */\n      input_st->flags &= ~(INP_FLAG_KB_LINEFEED_ENABLE\n                         | INP_FLAG_BLOCK_HOTKEY\n                         | INP_FLAG_BLOCK_LIBRETRO_INPUT\n                         | INP_FLAG_NONBLOCKING);\n\n      memset(&input_st->turbo_btns, 0, sizeof(turbo_buttons_t));\n      memset(&input_st->analog_requested, 0,\n         sizeof(input_st->analog_requested));\n      input_st->current_driver           = NULL;\n   }\n\n#ifdef HAVE_MENU\n   menu_driver_destroy(\n         menu_state_get_ptr());\n#endif\n   location_st->active                              = false;\n   location_st->driver                              = NULL;\n\n   /* Camera */\n   camera_st->active                                = false;\n   camera_st->driver                                = NULL;\n   camera_st->data                                  = NULL;\n\n#ifdef HAVE_BLUETOOTH\n   bluetooth_driver_ctl(RARCH_BLUETOOTH_CTL_DESTROY, NULL);\n#endif\n#ifdef HAVE_WIFI\n   wifi_driver_ctl(RARCH_WIFI_CTL_DESTROY, NULL);\n#endif\n\n   cbs->frame_cb                    = retro_frame_null;\n   cbs->poll_cb                     = retro_input_poll_null;\n   cbs->sample_cb                   = NULL;\n   cbs->sample_batch_cb             = NULL;\n   cbs->state_cb                    = NULL;\n\n   runloop_st->current_core.flags  &= ~RETRO_CORE_FLAG_INITED;\n}\n\nbool driver_ctl(enum driver_ctl_state state, void *data)\n{\n   driver_ctx_info_t      *drv = (driver_ctx_info_t*)data;\n\n   switch (state)\n   {\n      case RARCH_DRIVER_CTL_SET_REFRESH_RATE:\n         {\n            float *hz                     = (float*)data;\n            audio_driver_state_t\n               *audio_st                  = audio_state_get_ptr();\n            settings_t *settings          = config_get_ptr();\n            runloop_state_t *runloop_st   = runloop_state_get_ptr();\n            video_driver_state_t*video_st = video_state_get_ptr();\n            unsigned\n               audio_output_sample_rate   = settings->uints.audio_output_sample_rate;\n\n            video_monitor_set_refresh_rate(*hz);\n\n            /* Sets audio monitor rate to new value. */\n            audio_st->source_ratio_original   =\n            audio_st->source_ratio_current    =\n            (double)audio_output_sample_rate / audio_st->input;\n\n            driver_adjust_system_rates(runloop_st, video_st, settings);\n         }\n         break;\n      case RARCH_DRIVER_CTL_FIND_FIRST:\n         if (!drv)\n            return false;\n         find_driver_nonempty(drv->label, 0, drv->s, drv->len);\n         break;\n      case RARCH_DRIVER_CTL_FIND_LAST:\n         if (!drv)\n            return false;\n         driver_find_last(drv->label, drv->s, drv->len);\n         break;\n      case RARCH_DRIVER_CTL_FIND_PREV:\n         if (!drv)\n            return false;\n         return (bool)driver_find_prev(drv->label, drv->s, drv->len);\n      case RARCH_DRIVER_CTL_FIND_NEXT:\n         if (!drv)\n            return false;\n         return (bool)driver_find_next(drv->label, drv->s, drv->len);\n      case RARCH_DRIVER_CTL_NONE:\n      default:\n         break;\n   }\n\n   return true;\n}\n\naccess_state_t *access_state_get_ptr(void)\n{\n   return &access_state_st;\n}\n\n/* GLOBAL POINTER GETTERS */\nglobal_t *global_get_ptr(void)\n{\n   return &global_driver_st;\n}\n\nuint16_t retroarch_get_flags(void)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n   return p_rarch->flags;\n}\n\nstruct retro_perf_counter **retro_get_perf_counter_rarch(void)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n   return p_rarch->perf_counters_rarch;\n}\n\nunsigned retro_get_perf_count_rarch(void)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n   return p_rarch->perf_ptr_rarch;\n}\n\nvoid rarch_perf_register(struct retro_perf_counter *perf)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n   runloop_state_t *runloop_st = runloop_state_get_ptr();\n   if (\n            !runloop_st->perfcnt_enable\n         || perf->registered\n         || p_rarch->perf_ptr_rarch >= MAX_COUNTERS\n      )\n      return;\n\n   p_rarch->perf_counters_rarch[p_rarch->perf_ptr_rarch++] = perf;\n   perf->registered = true;\n}\n\nstruct string_list *dir_list_new_special(const char *input_dir,\n      enum dir_list_type type, const char *filter,\n      bool show_hidden_files)\n{\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n   char ext_shaders[NAME_MAX_LENGTH];\n#endif\n   char ext_name[16];\n   const char *exts    = NULL;\n   bool recursive      = false;\n\n   switch (type)\n   {\n      case DIR_LIST_AUTOCONFIG:\n         exts = filter;\n         break;\n      case DIR_LIST_CORES:\n         if (!frontend_driver_get_core_extension(ext_name, sizeof(ext_name)))\n            return NULL;\n         exts = ext_name;\n         break;\n      case DIR_LIST_RECURSIVE:\n         recursive = true;\n         /* fall-through */\n      case DIR_LIST_CORE_INFO:\n         {\n            core_info_list_t *list = NULL;\n            core_info_get_list(&list);\n\n            if (list)\n               exts = list->all_ext;\n         }\n         break;\n      case DIR_LIST_SHADERS:\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n         {\n            gfx_ctx_flags_t flags;\n            size_t _len         = 0;\n            flags.flags         = 0;\n            ext_shaders[0]      = '\\0';\n\n            video_context_driver_get_flags(&flags);\n\n            if (BIT32_GET(flags.flags, GFX_CTX_FLAGS_SHADERS_CG))\n            {\n               _len    += strlcpy(ext_shaders + _len, \"cgp\", sizeof(ext_shaders) - _len);\n               if (ext_shaders[_len-1] != '\\0')\n                  _len += strlcpy(ext_shaders + _len, \"|\",   sizeof(ext_shaders) - _len);\n               _len    += strlcpy(ext_shaders + _len, \"cg\",  sizeof(ext_shaders) - _len);\n            }\n\n            if (BIT32_GET(flags.flags, GFX_CTX_FLAGS_SHADERS_GLSL))\n            {\n               if (ext_shaders[_len-1] != '\\0')\n                  _len += strlcpy(ext_shaders + _len, \"|\",     sizeof(ext_shaders) - _len);\n               _len    += strlcpy(ext_shaders + _len, \"glslp\", sizeof(ext_shaders) - _len);\n               if (ext_shaders[_len-1] != '\\0')\n                  _len += strlcpy(ext_shaders + _len, \"|\",     sizeof(ext_shaders) - _len);\n               _len    += strlcpy(ext_shaders + _len, \"glsl\",  sizeof(ext_shaders) - _len);\n            }\n\n            if (BIT32_GET(flags.flags, GFX_CTX_FLAGS_SHADERS_SLANG))\n            {\n               if (ext_shaders[_len-1] != '\\0')\n                  _len += strlcpy(ext_shaders + _len, \"|\",      sizeof(ext_shaders) - _len);\n               _len    += strlcpy(ext_shaders + _len, \"slangp\", sizeof(ext_shaders) - _len);\n               if (ext_shaders[_len-1] != '\\0')\n                  _len += strlcpy(ext_shaders + _len, \"|\",      sizeof(ext_shaders) - _len);\n               _len    += strlcpy(ext_shaders + _len, \"slang\",  sizeof(ext_shaders) - _len);\n            }\n\n            exts = ext_shaders;\n         }\n         break;\n#else\n         return NULL;\n#endif\n      case DIR_LIST_COLLECTIONS:\n         exts = \"lpl\";\n         break;\n      case DIR_LIST_DATABASES:\n         exts = \"rdb\";\n         break;\n      case DIR_LIST_PLAIN:\n         exts = filter;\n         break;\n      case DIR_LIST_NONE:\n      default:\n         return NULL;\n   }\n\n   return dir_list_new(input_dir, exts, false,\n         show_hidden_files,\n         type == DIR_LIST_CORE_INFO, recursive);\n}\n\nstatic struct string_list *string_list_new_special(\n      enum string_list_type type,\n      void *data, unsigned *len, size_t *list_size)\n{\n   union string_list_elem_attr attr;\n   unsigned i;\n   struct string_list *s = string_list_new();\n\n   if (!s || !len)\n      goto error;\n\n   attr.i = 0;\n   *len   = 0;\n\n   switch (type)\n   {\n      case STRING_LIST_MENU_DRIVERS:\n#ifdef HAVE_MENU\n         for (i = 0; menu_ctx_drivers[i]; i++)\n         {\n            const char *opt  = menu_ctx_drivers[i]->ident;\n            *len            += strlen(opt) + 1;\n\n            /* Don't allow the user to set menu driver to \"null\" using the UI.\n             * Can prevent the user from locking him/herself out of the program. */\n            if (string_is_not_equal(opt, \"null\"))\n               string_list_append(s, opt, attr);\n         }\n         break;\n#endif\n      case STRING_LIST_CAMERA_DRIVERS:\n         for (i = 0; camera_drivers[i]; i++)\n         {\n            const char *opt  = camera_drivers[i]->ident;\n            *len            += strlen(opt) + 1;\n\n            string_list_append(s, opt, attr);\n         }\n         break;\n      case STRING_LIST_BLUETOOTH_DRIVERS:\n#ifdef HAVE_BLUETOOTH\n         for (i = 0; bluetooth_drivers[i]; i++)\n         {\n            const char *opt  = bluetooth_drivers[i]->ident;\n            *len            += strlen(opt) + 1;\n\n            string_list_append(s, opt, attr);\n         }\n         break;\n#endif\n      case STRING_LIST_WIFI_DRIVERS:\n#ifdef HAVE_WIFI\n         for (i = 0; wifi_drivers[i]; i++)\n         {\n            const char *opt  = wifi_drivers[i]->ident;\n            *len            += strlen(opt) + 1;\n\n            string_list_append(s, opt, attr);\n         }\n         break;\n#endif\n      case STRING_LIST_LOCATION_DRIVERS:\n         for (i = 0; location_drivers[i]; i++)\n         {\n            const char *opt  = location_drivers[i]->ident;\n            *len            += strlen(opt) + 1;\n\n            string_list_append(s, opt, attr);\n         }\n         break;\n      case STRING_LIST_AUDIO_DRIVERS:\n         for (i = 0; audio_drivers[i]; i++)\n         {\n            const char *opt  = audio_drivers[i]->ident;\n            *len            += strlen(opt) + 1;\n\n            string_list_append(s, opt, attr);\n         }\n         break;\n#ifdef HAVE_MICROPHONE\n      case STRING_LIST_MICROPHONE_DRIVERS:\n         for (i = 0; microphone_drivers[i]; i++)\n         {\n            const char *opt  = microphone_drivers[i]->ident;\n            *len            += strlen(opt) + 1;\n\n            string_list_append(s, opt, attr);\n         }\n         break;\n#endif\n      case STRING_LIST_AUDIO_RESAMPLER_DRIVERS:\n         for (i = 0; audio_resampler_driver_find_handle(i); i++)\n         {\n            const char *opt  = audio_resampler_driver_find_ident(i);\n            *len            += strlen(opt) + 1;\n\n            string_list_append(s, opt, attr);\n         }\n         break;\n      case STRING_LIST_VIDEO_DRIVERS:\n         for (i = 0; video_drivers[i]; i++)\n         {\n            const char *opt  = video_drivers[i]->ident;\n            *len            += strlen(opt) + 1;\n\n            /* Don't allow the user to set video driver to \"null\" using the UI.\n             * Can prevent the user from locking him/herself out of the program. */\n            if (string_is_not_equal(opt, \"null\"))\n               string_list_append(s, opt, attr);\n         }\n         break;\n      case STRING_LIST_INPUT_DRIVERS:\n         for (i = 0; input_drivers[i]; i++)\n         {\n            const char *opt  = input_drivers[i]->ident;\n            *len            += strlen(opt) + 1;\n\n            /* Don't allow the user to set input driver to \"null\" using the UI.\n             * Can prevent the user from locking him/herself out of the program. */\n            if (string_is_not_equal(opt, \"null\"))\n               string_list_append(s, opt, attr);\n         }\n         break;\n      case STRING_LIST_INPUT_HID_DRIVERS:\n#ifdef HAVE_HID\n         for (i = 0; hid_drivers[i]; i++)\n         {\n            const char *opt  = hid_drivers[i]->ident;\n            *len            += strlen(opt) + 1;\n\n            /* Don't allow the user to set input HID driver to \"null\" using the UI.\n             * Can prevent the user from locking him/herself out of the program. */\n            if (string_is_not_equal(opt, \"null\"))\n               string_list_append(s, opt, attr);\n         }\n#endif\n         break;\n      case STRING_LIST_INPUT_JOYPAD_DRIVERS:\n         for (i = 0; joypad_drivers[i]; i++)\n         {\n            const char *opt  = joypad_drivers[i]->ident;\n            *len            += strlen(opt) + 1;\n\n            /* Don't allow the user to set input joypad driver to \"null\" using the UI.\n             * Can prevent the user from locking him/herself out of the program. */\n            if (string_is_not_equal(opt, \"null\"))\n               string_list_append(s, opt, attr);\n         }\n         break;\n      case STRING_LIST_RECORD_DRIVERS:\n         for (i = 0; record_drivers[i]; i++)\n         {\n            const char *opt  = record_drivers[i]->ident;\n            *len            += strlen(opt) + 1;\n\n            string_list_append(s, opt, attr);\n         }\n         break;\n      case STRING_LIST_MIDI_DRIVERS:\n         for (i = 0; midi_driver_find_handle(i); i++)\n         {\n            const char *opt  = midi_drivers[i]->ident;\n            *len            += strlen(opt) + 1;\n\n            string_list_append(s, opt, attr);\n         }\n         break;\n      case STRING_LIST_CLOUD_SYNC_DRIVERS:\n#ifdef HAVE_CLOUDSYNC\n         for (i = 0; cloud_sync_drivers[i]; i++)\n         {\n            const char *opt  = cloud_sync_drivers[i]->ident;\n            *len            += strlen(opt) + 1;\n\n            string_list_append(s, opt, attr);\n         }\n#endif\n         break;\n#ifdef HAVE_LAKKA\n      case STRING_LIST_TIMEZONES:\n         {\n            const char *opt  = DEFAULT_TIMEZONE;\n            *len            += STRLEN_CONST(DEFAULT_TIMEZONE) + 1;\n            string_list_append(s, opt, attr);\n\n            FILE *zones_file = popen(\"grep -v ^# /usr/share/zoneinfo/zone.tab | \"\n                                     \"cut -f3 | \"\n                                     \"sort\", \"r\");\n\n            if (zones_file)\n            {\n               char zone_desc[TIMEZONE_LENGTH];\n               while (fgets(zone_desc, TIMEZONE_LENGTH, zones_file))\n               {\n                  size_t zone_desc_len = strlen(zone_desc);\n\n                  if (zone_desc_len > 0)\n                     if (zone_desc[--zone_desc_len] == '\\n')\n                        zone_desc[zone_desc_len] = '\\0';\n\n                  if (zone_desc && zone_desc[0] != '\\0')\n                  {\n                     const char *opt  = zone_desc;\n                     *len            += strlen(opt) + 1;\n                     string_list_append(s, opt, attr);\n                  }\n               }\n               pclose(zones_file);\n            }\n         }\n         break;\n#endif\n      case STRING_LIST_NONE:\n      default:\n         goto error;\n   }\n\n   return s;\n\nerror:\n   string_list_free(s);\n   s    = NULL;\n   return NULL;\n}\n\nconst char *char_list_new_special(enum string_list_type type, void *data)\n{\n   unsigned len = 0;\n   size_t list_size;\n   struct string_list *s = string_list_new_special(type, data, &len, &list_size);\n   char         *options = (len > 0) ? (char*)calloc(len, sizeof(char)): NULL;\n\n   if (options && s)\n      string_list_join_concat(options, len, s, \"|\");\n\n   string_list_free(s);\n   s = NULL;\n\n   return options;\n}\n\nchar *path_get_ptr(enum rarch_path_type type)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n   runloop_state_t *runloop_st = runloop_state_get_ptr();\n\n   switch (type)\n   {\n      case RARCH_PATH_CONTENT:\n         return p_rarch->path_content;\n      case RARCH_PATH_DEFAULT_SHADER_PRESET:\n         return p_rarch->path_default_shader_preset;\n      case RARCH_PATH_BASENAME:\n         return runloop_st->runtime_content_path_basename;\n      case RARCH_PATH_CORE_OPTIONS:\n         if (!path_is_empty(RARCH_PATH_CORE_OPTIONS))\n            return p_rarch->path_core_options_file;\n         break;\n      case RARCH_PATH_SUBSYSTEM:\n         return runloop_st->subsystem_path;\n      case RARCH_PATH_CONFIG:\n         if (!path_is_empty(RARCH_PATH_CONFIG))\n            return p_rarch->path_config_file;\n         break;\n      case RARCH_PATH_CONFIG_APPEND:\n         if (!path_is_empty(RARCH_PATH_CONFIG_APPEND))\n            return p_rarch->path_config_append_file;\n         break;\n      case RARCH_PATH_CONFIG_OVERRIDE:\n         if (!path_is_empty(RARCH_PATH_CONFIG_OVERRIDE))\n            return p_rarch->path_config_override_file;\n         break;\n      case RARCH_PATH_CORE:\n         return p_rarch->path_libretro;\n      case RARCH_PATH_NONE:\n      case RARCH_PATH_NAMES:\n         break;\n   }\n\n   return NULL;\n}\n\nconst char *path_get(enum rarch_path_type type)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n\n   switch (type)\n   {\n      case RARCH_PATH_CONTENT:\n         return p_rarch->path_content;\n      case RARCH_PATH_DEFAULT_SHADER_PRESET:\n         return p_rarch->path_default_shader_preset;\n      case RARCH_PATH_CORE_OPTIONS:\n         if (!path_is_empty(RARCH_PATH_CORE_OPTIONS))\n            return p_rarch->path_core_options_file;\n         break;\n      case RARCH_PATH_CONFIG:\n         if (!path_is_empty(RARCH_PATH_CONFIG))\n            return p_rarch->path_config_file;\n         break;\n      case RARCH_PATH_CONFIG_APPEND:\n         if (!path_is_empty(RARCH_PATH_CONFIG_APPEND))\n            return p_rarch->path_config_append_file;\n         break;\n      case RARCH_PATH_CONFIG_OVERRIDE:\n         if (!path_is_empty(RARCH_PATH_CONFIG_OVERRIDE))\n            return p_rarch->path_config_override_file;\n         break;\n      case RARCH_PATH_CORE:\n         return p_rarch->path_libretro;\n      case RARCH_PATH_NONE:\n      case RARCH_PATH_NAMES:\n         break;\n      case RARCH_PATH_BASENAME:\n         return runloop_state_get_ptr()->runtime_content_path_basename;\n      case RARCH_PATH_SUBSYSTEM:\n         return runloop_state_get_ptr()->subsystem_path;\n   }\n\n   return NULL;\n}\n\nsize_t path_get_realsize(enum rarch_path_type type)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n\n   switch (type)\n   {\n      case RARCH_PATH_CONTENT:\n         return sizeof(p_rarch->path_content);\n      case RARCH_PATH_DEFAULT_SHADER_PRESET:\n         return sizeof(p_rarch->path_default_shader_preset);\n      case RARCH_PATH_CORE_OPTIONS:\n         return sizeof(p_rarch->path_core_options_file);\n      case RARCH_PATH_CONFIG:\n         return sizeof(p_rarch->path_config_file);\n      case RARCH_PATH_CONFIG_APPEND:\n         return sizeof(p_rarch->path_config_append_file);\n      case RARCH_PATH_CONFIG_OVERRIDE:\n         return sizeof(p_rarch->path_config_override_file);\n      case RARCH_PATH_CORE:\n         return sizeof(p_rarch->path_libretro);\n      case RARCH_PATH_NONE:\n      case RARCH_PATH_NAMES:\n         break;\n      case RARCH_PATH_BASENAME:\n         return sizeof(runloop_state_get_ptr()->runtime_content_path_basename);\n      case RARCH_PATH_SUBSYSTEM:\n         return sizeof(runloop_state_get_ptr()->subsystem_path);\n   }\n\n   return 0;\n}\n\nbool path_set(enum rarch_path_type type, const char *path)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n   runloop_state_t *runloop_st = NULL;\n\n   if (!path)\n      return false;\n\n   switch (type)\n   {\n      case RARCH_PATH_NAMES:\n         runloop_path_set_basename(path);\n         runloop_path_set_names();\n         runloop_path_set_redirect(config_get_ptr(), p_rarch->dir_savefile,\n               p_rarch->dir_savestate);\n         break;\n      case RARCH_PATH_CORE:\n         strlcpy(p_rarch->path_libretro, path,\n               sizeof(p_rarch->path_libretro));\n         break;\n      case RARCH_PATH_DEFAULT_SHADER_PRESET:\n         strlcpy(p_rarch->path_default_shader_preset, path,\n               sizeof(p_rarch->path_default_shader_preset));\n         break;\n      case RARCH_PATH_CONFIG_APPEND:\n         strlcpy(p_rarch->path_config_append_file, path,\n               sizeof(p_rarch->path_config_append_file));\n         break;\n      case RARCH_PATH_CONFIG:\n         strlcpy(p_rarch->path_config_file, path,\n               sizeof(p_rarch->path_config_file));\n         break;\n      case RARCH_PATH_CONFIG_OVERRIDE:\n         strlcpy(p_rarch->path_config_override_file, path,\n               sizeof(p_rarch->path_config_override_file));\n         break;\n      case RARCH_PATH_CORE_OPTIONS:\n         strlcpy(p_rarch->path_core_options_file, path,\n               sizeof(p_rarch->path_core_options_file));\n         break;\n      case RARCH_PATH_CONTENT:\n         strlcpy(p_rarch->path_content, path,\n               sizeof(p_rarch->path_content));\n         break;\n      case RARCH_PATH_NONE:\n         break;\n      case RARCH_PATH_BASENAME:\n         runloop_st = runloop_state_get_ptr();\n         strlcpy(runloop_st->runtime_content_path_basename, path,\n               sizeof(runloop_st->runtime_content_path_basename));\n         break;\n      case RARCH_PATH_SUBSYSTEM:\n         runloop_st = runloop_state_get_ptr();\n         strlcpy(runloop_st->subsystem_path, path,\n               sizeof(runloop_st->subsystem_path));\n         break;\n   }\n\n   return true;\n}\n\nbool path_is_empty(enum rarch_path_type type)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n\n   switch (type)\n   {\n      case RARCH_PATH_DEFAULT_SHADER_PRESET:\n         if (string_is_empty(p_rarch->path_default_shader_preset))\n            return true;\n         break;\n      case RARCH_PATH_CONFIG:\n         if (string_is_empty(p_rarch->path_config_file))\n            return true;\n         break;\n      case RARCH_PATH_CONFIG_APPEND:\n         if (string_is_empty(p_rarch->path_config_append_file))\n            return true;\n         break;\n      case RARCH_PATH_CONFIG_OVERRIDE:\n         if (string_is_empty(p_rarch->path_config_override_file))\n            return true;\n         break;\n      case RARCH_PATH_CORE_OPTIONS:\n         if (string_is_empty(p_rarch->path_core_options_file))\n            return true;\n         break;\n      case RARCH_PATH_CONTENT:\n         if (string_is_empty(p_rarch->path_content))\n            return true;\n         break;\n      case RARCH_PATH_CORE:\n         if (string_is_empty(p_rarch->path_libretro))\n            return true;\n         break;\n      case RARCH_PATH_BASENAME:\n         if (string_is_empty(runloop_state_get_ptr()->runtime_content_path_basename))\n            return true;\n         break;\n      case RARCH_PATH_SUBSYSTEM:\n         if (string_is_empty(runloop_state_get_ptr()->subsystem_path))\n            return true;\n         break;\n      case RARCH_PATH_NONE:\n      case RARCH_PATH_NAMES:\n         break;\n   }\n\n   return false;\n}\n\nvoid path_clear(enum rarch_path_type type)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n   runloop_state_t *runloop_st = NULL;\n\n   switch (type)\n   {\n      case RARCH_PATH_CORE:\n         *p_rarch->path_libretro = '\\0';\n         break;\n      case RARCH_PATH_CONFIG:\n         *p_rarch->path_config_file = '\\0';\n         break;\n      case RARCH_PATH_CONTENT:\n         *p_rarch->path_content = '\\0';\n         break;\n      case RARCH_PATH_CORE_OPTIONS:\n         *p_rarch->path_core_options_file = '\\0';\n         break;\n      case RARCH_PATH_DEFAULT_SHADER_PRESET:\n         *p_rarch->path_default_shader_preset = '\\0';\n         break;\n      case RARCH_PATH_CONFIG_APPEND:\n         *p_rarch->path_config_append_file = '\\0';\n         break;\n      case RARCH_PATH_CONFIG_OVERRIDE:\n         *p_rarch->path_config_override_file = '\\0';\n         break;\n      case RARCH_PATH_NONE:\n      case RARCH_PATH_NAMES:\n         break;\n      case RARCH_PATH_BASENAME:\n         runloop_st = runloop_state_get_ptr();\n         *runloop_st->runtime_content_path_basename = '\\0';\n         break;\n      case RARCH_PATH_SUBSYSTEM:\n         runloop_st = runloop_state_get_ptr();\n         *runloop_st->subsystem_path = '\\0';\n         break;\n   }\n}\n\nstatic void path_clear_all(void)\n{\n   path_clear(RARCH_PATH_CONTENT);\n   path_clear(RARCH_PATH_CONFIG);\n   path_clear(RARCH_PATH_CONFIG_APPEND);\n   path_clear(RARCH_PATH_CONFIG_OVERRIDE);\n   path_clear(RARCH_PATH_CORE_OPTIONS);\n   path_clear(RARCH_PATH_BASENAME);\n}\n\nstatic void ram_state_to_file(void)\n{\n   char state_path[PATH_MAX_LENGTH];\n\n   if (!content_ram_state_pending())\n      return;\n\n   state_path[0] = '\\0';\n\n   if (runloop_get_current_savestate_path(state_path, sizeof(state_path)))\n      command_event(CMD_EVENT_RAM_STATE_TO_FILE, state_path);\n}\n\nenum rarch_content_type path_is_media_type(const char *path)\n{\n   char ext_lower[16];\n   strlcpy(ext_lower, path_get_extension(path), sizeof(ext_lower));\n\n   string_to_lower(ext_lower);\n\n   /* hack, to detect livestreams so the ffmpeg core can be started */\n   if (   string_starts_with_size(path, \"udp://\",   STRLEN_CONST(\"udp://\"))\n       || string_starts_with_size(path, \"http://\",  STRLEN_CONST(\"http://\"))\n       || string_starts_with_size(path, \"https://\", STRLEN_CONST(\"https://\"))\n       || string_starts_with_size(path, \"tcp://\",   STRLEN_CONST(\"tcp://\"))\n       || string_starts_with_size(path, \"rtmp://\",  STRLEN_CONST(\"rtmp://\"))\n       || string_starts_with_size(path, \"rtp://\",   STRLEN_CONST(\"rtp://\")))\n      return RARCH_CONTENT_MOVIE;\n\n   switch (msg_hash_to_file_type(msg_hash_calculate(ext_lower)))\n   {\n#if defined(HAVE_FFMPEG) || defined(HAVE_MPV)\n      case FILE_TYPE_OGM:\n      case FILE_TYPE_MKV:\n      case FILE_TYPE_AVI:\n      case FILE_TYPE_MP4:\n      case FILE_TYPE_FLV:\n      case FILE_TYPE_WEBM:\n      case FILE_TYPE_3GP:\n      case FILE_TYPE_3G2:\n      case FILE_TYPE_F4F:\n      case FILE_TYPE_F4V:\n      case FILE_TYPE_MOV:\n      case FILE_TYPE_WMV:\n      case FILE_TYPE_MPG:\n      case FILE_TYPE_MPEG:\n      case FILE_TYPE_VOB:\n      case FILE_TYPE_ASF:\n      case FILE_TYPE_DIVX:\n      case FILE_TYPE_M2P:\n      case FILE_TYPE_M2TS:\n      case FILE_TYPE_PS:\n      case FILE_TYPE_TS:\n      case FILE_TYPE_MXF:\n         return RARCH_CONTENT_MOVIE;\n      case FILE_TYPE_WMA:\n      case FILE_TYPE_M4A:\n#endif\n#if defined(HAVE_FFMPEG) || defined(HAVE_MPV) || defined(HAVE_AUDIOMIXER)\n#if !defined(HAVE_AUDIOMIXER) || defined(HAVE_STB_VORBIS)\n      case FILE_TYPE_OGG:\n#endif\n#if !defined(HAVE_AUDIOMIXER) || defined(HAVE_DR_MP3)\n      case FILE_TYPE_MP3:\n#endif\n#if !defined(HAVE_AUDIOMIXER) || defined(HAVE_DR_FLAC)\n      case FILE_TYPE_FLAC:\n#endif\n#if !defined(HAVE_AUDIOMIXER) || defined(HAVE_RWAV)\n      case FILE_TYPE_WAV:\n#endif\n#if !defined(HAVE_AUDIOMIXER) || defined(HAVE_IBXM)\n      case FILE_TYPE_MOD:\n      case FILE_TYPE_S3M:\n      case FILE_TYPE_XM:\n#endif\n         return RARCH_CONTENT_MUSIC;\n#endif\n#ifdef HAVE_IMAGEVIEWER\n      case FILE_TYPE_JPEG:\n      case FILE_TYPE_PNG:\n      case FILE_TYPE_TGA:\n      case FILE_TYPE_BMP:\n         return RARCH_CONTENT_IMAGE;\n#endif\n      case FILE_TYPE_NONE:\n      default:\n         break;\n   }\n\n   return RARCH_CONTENT_NONE;\n}\n\n/* get size functions */\n\nsize_t dir_get_size(enum rarch_dir_type type)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n\n   switch (type)\n   {\n      case RARCH_DIR_SYSTEM:\n         return sizeof(p_rarch->dir_system);\n      case RARCH_DIR_SAVESTATE:\n         return sizeof(p_rarch->dir_savestate);\n      case RARCH_DIR_CURRENT_SAVESTATE:\n         return sizeof(runloop_state_get_ptr()->savestate_dir);\n      case RARCH_DIR_SAVEFILE:\n         return sizeof(p_rarch->dir_savefile);\n      case RARCH_DIR_CURRENT_SAVEFILE:\n         return sizeof(runloop_state_get_ptr()->savefile_dir);\n      case RARCH_DIR_NONE:\n         break;\n   }\n\n   return 0;\n}\n\n/* clear functions */\n\nvoid dir_clear(enum rarch_dir_type type)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n   runloop_state_t *runloop_st = NULL;\n\n   switch (type)\n   {\n      case RARCH_DIR_SAVEFILE:\n         *p_rarch->dir_savefile = '\\0';\n         break;\n      case RARCH_DIR_SAVESTATE:\n         *p_rarch->dir_savestate = '\\0';\n         break;\n      case RARCH_DIR_SYSTEM:\n         *p_rarch->dir_system = '\\0';\n         break;\n      case RARCH_DIR_NONE:\n         break;\n      case RARCH_DIR_CURRENT_SAVEFILE:\n         runloop_st = runloop_state_get_ptr();\n         *runloop_st->savefile_dir = '\\0';\n         break;\n      case RARCH_DIR_CURRENT_SAVESTATE:\n         runloop_st = runloop_state_get_ptr();\n         *runloop_st->savestate_dir = '\\0';\n         break;\n   }\n}\n\nstatic void dir_clear_all(void)\n{\n   dir_clear(RARCH_DIR_SYSTEM);\n   dir_clear(RARCH_DIR_SAVEFILE);\n   dir_clear(RARCH_DIR_SAVESTATE);\n}\n\n/* get ptr functions */\n\nchar *dir_get_ptr(enum rarch_dir_type type)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n\n   switch (type)\n   {\n      case RARCH_DIR_SAVEFILE:\n         return p_rarch->dir_savefile;\n      case RARCH_DIR_CURRENT_SAVEFILE:\n         return runloop_state_get_ptr()->savefile_dir;\n      case RARCH_DIR_SAVESTATE:\n         return p_rarch->dir_savestate;\n      case RARCH_DIR_CURRENT_SAVESTATE:\n         return runloop_state_get_ptr()->savestate_dir;\n      case RARCH_DIR_SYSTEM:\n         return p_rarch->dir_system;\n      case RARCH_DIR_NONE:\n         break;\n   }\n\n   return NULL;\n}\n\nvoid dir_set(enum rarch_dir_type type, const char *path)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n   runloop_state_t *runloop_st = NULL;\n\n   switch (type)\n   {\n      case RARCH_DIR_SAVEFILE:\n         strlcpy(p_rarch->dir_savefile, path,\n               sizeof(p_rarch->dir_savefile));\n         break;\n      case RARCH_DIR_SAVESTATE:\n         strlcpy(p_rarch->dir_savestate, path,\n               sizeof(p_rarch->dir_savestate));\n         break;\n      case RARCH_DIR_SYSTEM:\n         strlcpy(p_rarch->dir_system, path,\n               sizeof(p_rarch->dir_system));\n         break;\n      case RARCH_DIR_NONE:\n         break;\n      case RARCH_DIR_CURRENT_SAVEFILE:\n         runloop_st = runloop_state_get_ptr();\n         strlcpy(runloop_st->savefile_dir, path,\n               sizeof(runloop_st->savefile_dir));\n         break;\n      case RARCH_DIR_CURRENT_SAVESTATE:\n         runloop_st = runloop_state_get_ptr();\n         strlcpy(runloop_st->savestate_dir, path,\n               sizeof(runloop_st->savestate_dir));\n         break;\n   }\n}\n\nvoid dir_check_defaults(const char *custom_ini_path)\n{\n   size_t i;\n\n   /* Early return for people with a custom folder setup\n    * so it doesn't create unnecessary directories */\n   if (  !string_is_empty(custom_ini_path)\n       && path_is_valid(custom_ini_path))\n      return;\n\n   for (i = 0; i < DEFAULT_DIR_LAST; i++)\n   {\n      const char *dir_path = g_defaults.dirs[i];\n      char new_path[PATH_MAX_LENGTH];\n\n      if (string_is_empty(dir_path))\n         continue;\n\n      fill_pathname_expand_special(new_path,\n            dir_path, sizeof(new_path));\n\n      if (!path_is_directory(new_path))\n         path_mkdir(new_path);\n   }\n}\n\n#ifdef __APPLE__\nstatic void dir_check_config(void)\n{\n   settings_t *settings            = config_get_ptr();\n\n#define ENSURE_DIRECTORY(DIRPATH)               \\\n   if (!string_is_empty(DIRPATH))               \\\n      if (!path_is_directory(DIRPATH))          \\\n         path_mkdir(DIRPATH)\n\n   /* the order here mimics the order of enum default_dirs */\n   /* TODO: not all of these are necessary/used and many are created on demand, make fewer */\n   ENSURE_DIRECTORY(settings->paths.directory_menu_content);\n   ENSURE_DIRECTORY(settings->paths.directory_core_assets);\n   ENSURE_DIRECTORY(settings->paths.directory_menu_config);\n   ENSURE_DIRECTORY(settings->paths.directory_autoconfig);\n   ENSURE_DIRECTORY(settings->paths.directory_audio_filter);\n   ENSURE_DIRECTORY(settings->paths.directory_video_filter);\n   ENSURE_DIRECTORY(settings->paths.directory_assets);\n#ifdef _3DS\n   ENSURE_DIRECTORY(settings->paths.directory_bottom_assets);\n#endif\n   ENSURE_DIRECTORY(settings->paths.directory_libretro);\n   ENSURE_DIRECTORY(settings->paths.path_libretro_info);\n   ENSURE_DIRECTORY(settings->paths.directory_overlay);\n   ENSURE_DIRECTORY(settings->paths.directory_osk_overlay);\n   /* PORT */\n   ENSURE_DIRECTORY(settings->paths.directory_video_shader);\n   ENSURE_DIRECTORY(dir_get_ptr(RARCH_DIR_SAVESTATE));\n   ENSURE_DIRECTORY(dir_get_ptr(RARCH_DIR_SAVEFILE));\n   ENSURE_DIRECTORY(settings->paths.directory_screenshot);\n   ENSURE_DIRECTORY(settings->paths.directory_system);\n   ENSURE_DIRECTORY(settings->paths.directory_playlist);\n   ENSURE_DIRECTORY(settings->paths.directory_content_favorites);\n   ENSURE_DIRECTORY(settings->paths.directory_content_history);\n   ENSURE_DIRECTORY(settings->paths.directory_content_image_history);\n   ENSURE_DIRECTORY(settings->paths.directory_content_music_history);\n   ENSURE_DIRECTORY(settings->paths.directory_content_video_history);\n   ENSURE_DIRECTORY(settings->paths.directory_input_remapping);\n   ENSURE_DIRECTORY(settings->paths.directory_cache);\n   ENSURE_DIRECTORY(settings->paths.directory_dynamic_wallpapers);\n   ENSURE_DIRECTORY(settings->paths.directory_thumbnails);\n   ENSURE_DIRECTORY(settings->paths.path_content_database);\n   ENSURE_DIRECTORY(settings->paths.path_cheat_database);\n   /* RECORD_CONFIG */\n   /* RECORD_OUTPUT */\n   ENSURE_DIRECTORY(settings->paths.log_dir);\n\n#undef ENSURE_DIRECTORY\n}\n#endif\n\n#ifdef HAVE_ACCESSIBILITY\nbool is_accessibility_enabled(bool accessibility_enable, bool accessibility_enabled)\n{\n   return accessibility_enabled || accessibility_enable;\n}\n#endif\n\n/**\n * command_event:\n * @cmd                  : Event command index.\n *\n * Performs program event command with index @cmd.\n *\n * Returns: true (1) on success, otherwise false (0).\n **/\nbool command_event(enum event_command cmd, void *data)\n{\n   struct rarch_state *p_rarch     = &rarch_st;\n   runloop_state_t *runloop_st     = runloop_state_get_ptr();\n   uico_driver_state_t *uico_st    = uico_state_get_ptr();\n#if defined(HAVE_ACCESSIBILITY) || defined(HAVE_TRANSLATE)\n   access_state_t *access_st       = access_state_get_ptr();\n#endif\n#ifdef HAVE_MENU\n   struct menu_state *menu_st      = menu_state_get_ptr();\n#endif\n   video_driver_state_t *video_st  = video_state_get_ptr();\n   settings_t *settings            = config_get_ptr();\n   recording_state_t *rec_st       = recording_state_get_ptr();\n\n   switch (cmd)\n   {\n      case CMD_EVENT_SAVE_FILES:\n         event_save_files(runloop_st->flags & RUNLOOP_FLAG_USE_SRAM);\n         break;\n      case CMD_EVENT_OVERLAY_UNLOAD:\n#ifdef HAVE_OVERLAY\n         input_overlay_unload();\n#endif\n#if defined(HAVE_TRANSLATE) && defined(HAVE_GFX_WIDGETS)\n         /* Because the overlay is a display widget,\n          * it's going to be written\n          * over the menu, so we unset it here. */\n         if (dispwidget_get_ptr()->ai_service_overlay_state != 0)\n            gfx_widgets_ai_service_overlay_unload();\n#endif\n         break;\n      case CMD_EVENT_OVERLAY_INIT:\n#ifdef HAVE_OVERLAY\n         input_overlay_init();\n#endif\n         break;\n      case CMD_EVENT_CHEAT_INDEX_PLUS:\n#ifdef HAVE_CHEATS\n         cheat_manager_index_next();\n#endif\n         break;\n      case CMD_EVENT_CHEAT_INDEX_MINUS:\n#ifdef HAVE_CHEATS\n         cheat_manager_index_prev();\n#endif\n         break;\n      case CMD_EVENT_CHEAT_TOGGLE:\n#ifdef HAVE_CHEATS\n         cheat_manager_toggle();\n#endif\n         break;\n      case CMD_EVENT_SHADER_NEXT:\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n#ifdef HAVE_MENU\n         video_shader_dir_check_shader(menu_st->driver_data, settings,\n               &video_st->dir_shader_list, true, false);\n#else\n         video_shader_dir_check_shader(NULL, settings,\n               &video_st->dir_shader_list, true, false);\n#endif\n#endif\n         break;\n      case CMD_EVENT_SHADER_PREV:\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n#ifdef HAVE_MENU\n         video_shader_dir_check_shader(menu_st->driver_data, settings,\n               &video_st->dir_shader_list, false, true);\n#else\n         video_shader_dir_check_shader(NULL, settings,\n               &video_st->dir_shader_list, false, true);\n#endif\n#endif\n         break;\n      case CMD_EVENT_SHADER_TOGGLE:\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n         video_shader_toggle(settings);\n#endif\n         break;\n      case CMD_EVENT_AI_SERVICE_TOGGLE:\n         {\n#ifdef HAVE_TRANSLATE\n            bool ai_service_pause     = settings->bools.ai_service_pause;\n\n            if (!settings->bools.ai_service_enable)\n               break;\n\n            if (ai_service_pause)\n            {\n               /* Unpause on second press */\n               if (runloop_st->flags & RUNLOOP_FLAG_PAUSED)\n               {\n#ifdef HAVE_ACCESSIBILITY\n                  bool accessibility_enable = settings->bools.accessibility_enable;\n                  unsigned accessibility_narrator_speech_speed = settings->uints.accessibility_narrator_speech_speed;\n                  if (is_accessibility_enabled(\n                           accessibility_enable,\n                           access_st->enabled))\n                     accessibility_speak_priority(\n                           accessibility_enable,\n                           accessibility_narrator_speech_speed,\n                           (char*)msg_hash_to_str(MSG_UNPAUSED), 10);\n#endif\n                  command_event(CMD_EVENT_UNPAUSE, NULL);\n               }\n               else /* Pause on call */\n               {\n                  command_event(CMD_EVENT_PAUSE, NULL);\n                  command_event(CMD_EVENT_AI_SERVICE_CALL, NULL);\n               }\n            }\n            else\n            {\n               /* Don't pause - useful for Text-To-Speech since\n                * the audio can't currently play while paused.\n                * Also useful for cases when users don't want the\n                * core's sound to stop while translating.\n                *\n                * Also, this mode is required for \"auto\" translation\n                * packages, since you don't want to pause for that.\n                */\n               if (access_st->ai_service_auto == 2)\n               {\n                  /* Auto mode was turned on, but we pressed the\n                   * toggle button, so turn it off now. */\n                  access_st->ai_service_auto = 0;\n#ifdef HAVE_MENU_WIDGETS\n                  gfx_widgets_ai_service_overlay_unload();\n#endif\n               }\n               else\n               {\n                  command_event(CMD_EVENT_AI_SERVICE_CALL, NULL);\n               }\n            }\n#endif\n            break;\n         }\n      case CMD_EVENT_STREAMING_TOGGLE:\n         if (rec_st->streaming_enable)\n            command_event(CMD_EVENT_RECORD_DEINIT, NULL);\n         else\n         {\n            streaming_set_state(true);\n            command_event(CMD_EVENT_RECORD_INIT, NULL);\n         }\n         break;\n      case CMD_EVENT_RUNAHEAD_TOGGLE:\n#if HAVE_RUNAHEAD\n         {\n            if (!core_info_current_supports_runahead())\n            {\n               const char *_msg = msg_hash_to_str(MSG_RUNAHEAD_CORE_DOES_NOT_SUPPORT_RUNAHEAD);\n               runloop_msg_queue_push(_msg, strlen(_msg), 1, 100, false, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n               break;\n            }\n\n            settings->bools.run_ahead_enabled =\n               !(settings->bools.run_ahead_enabled);\n\n            if (settings->bools.run_ahead_enabled)\n            {\n               char msg[128];\n               size_t _len;\n               if (settings->bools.run_ahead_secondary_instance)\n                  _len = snprintf(msg, sizeof(msg),\n                        msg_hash_to_str(MSG_RUNAHEAD_ENABLED_WITH_SECOND_INSTANCE),\n                        settings->uints.run_ahead_frames);\n               else\n                  _len = snprintf(msg, sizeof(msg),\n                        msg_hash_to_str(MSG_RUNAHEAD_ENABLED),\n                        settings->uints.run_ahead_frames);\n               runloop_msg_queue_push(msg, _len, 1, 100, false,\n                     NULL, MESSAGE_QUEUE_ICON_DEFAULT,\n                     MESSAGE_QUEUE_CATEGORY_INFO);\n\n               /* Disable preemptive frames */\n               settings->bools.preemptive_frames_enable = false;\n               preempt_deinit(runloop_st);\n            }\n            else\n            {\n               const char *_msg = msg_hash_to_str(MSG_RUNAHEAD_DISABLED);\n               runloop_msg_queue_push(_msg, strlen(_msg), 1, 100, false, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n            }\n\n#ifdef HAVE_MENU\n            /* Update menu */\n            menu_update_runahead_mode();\n#endif\n         }\n#endif\n         break;\n      case CMD_EVENT_PREEMPT_TOGGLE:\n#if HAVE_RUNAHEAD\n         {\n            bool old_warn   = settings->bools.run_ahead_hide_warnings;\n            bool old_inited = runloop_st->preempt_data != NULL;\n\n            /* Toggle with warnings shown */\n            settings->bools.run_ahead_hide_warnings  = false;\n            settings->bools.preemptive_frames_enable =\n                  !(settings->bools.preemptive_frames_enable);\n            command_event(CMD_EVENT_PREEMPT_UPDATE, NULL);\n\n            settings->bools.run_ahead_hide_warnings = old_warn;\n\n            if (old_inited && !runloop_st->preempt_data)\n            {\n               const char *_msg = msg_hash_to_str(MSG_PREEMPT_DISABLED);\n               runloop_msg_queue_push(_msg, strlen(_msg), 1, 100, false, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n            }\n            else if (runloop_st->preempt_data)\n            {\n               char msg[128];\n               size_t _len = snprintf(msg, sizeof(msg), msg_hash_to_str(MSG_PREEMPT_ENABLED),\n                     settings->uints.run_ahead_frames);\n               runloop_msg_queue_push(msg, _len, 1, 100, false, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n               /* Disable runahead */\n               settings->bools.run_ahead_enabled        = false;\n            }\n            else /* Failed to init */\n               settings->bools.preemptive_frames_enable = false;\n\n#ifdef HAVE_MENU\n            /* Update menu */\n            menu_update_runahead_mode();\n#endif\n         }\n#endif\n         break;\n      case CMD_EVENT_PREEMPT_UPDATE:\n#if HAVE_RUNAHEAD\n#ifdef HAVE_NETWORKING\n         if (netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_ENABLED, NULL))\n            break;\n#endif\n         preempt_deinit(runloop_st);\n         preempt_init(runloop_st);\n#endif\n         break;\n      case CMD_EVENT_PREEMPT_RESET_BUFFER:\n#if HAVE_RUNAHEAD\n         if (runloop_st->preempt_data)\n            runloop_st->preempt_data->frame_count = 0;\n#endif\n         break;\n      case CMD_EVENT_RECORDING_TOGGLE:\n         if (rec_st->enable)\n            command_event(CMD_EVENT_RECORD_DEINIT, NULL);\n         else\n            command_event(CMD_EVENT_RECORD_INIT, NULL);\n         break;\n      case CMD_EVENT_SET_PER_GAME_RESOLUTION:\n#if defined(GEKKO)\n         {\n            unsigned width = 0, height = 0;\n            char desc[64] = {0};\n\n            command_event(CMD_EVENT_VIDEO_SET_ASPECT_RATIO, NULL);\n\n            if (video_driver_get_video_output_size(&width, &height, desc, sizeof(desc)))\n            {\n               size_t _len;\n               char msg[128];\n\n               video_driver_set_video_mode(width, height, true);\n\n               if (width == 0 || height == 0)\n                  _len = strlcpy(msg, msg_hash_to_str(MSG_SCREEN_RESOLUTION_DEFAULT), sizeof(msg));\n               else\n               {\n                  msg[0] = '\\0';\n                  if (!string_is_empty(desc))\n                     _len = snprintf(msg, sizeof(msg),\n                        msg_hash_to_str(MSG_SCREEN_RESOLUTION_DESC),\n                        width, height, desc);\n                  else\n                     _len = snprintf(msg, sizeof(msg), msg_hash_to_str(MSG_SCREEN_RESOLUTION_NO_DESC),\n                        width, height);\n               }\n\n               runloop_msg_queue_push(msg, _len, 1, 100, true, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n            }\n         }\n#endif\n         break;\n      case CMD_EVENT_LOAD_CORE_PERSIST:\n         {\n            rarch_system_info_t *sys_info     = &runloop_st->system;\n            struct retro_system_info *sysinfo = &sys_info->info;\n            const char *core_path             = p_rarch->path_libretro;\n\n#if defined(HAVE_DYNAMIC)\n            if (string_is_empty(core_path))\n               return false;\n#endif\n\n            if (!libretro_get_system_info(\n                     core_path,\n                     sysinfo,\n                     &sys_info->load_no_content))\n               return false;\n\n            if (!core_info_load(core_path))\n            {\n#ifdef HAVE_DYNAMIC\n               return false;\n#endif\n            }\n         }\n         break;\n      case CMD_EVENT_LOAD_CORE:\n         runloop_st->subsystem_current_count = 0;\n         content_clear_subsystem();\n#ifdef HAVE_DYNAMIC\n         if (!(command_event(CMD_EVENT_LOAD_CORE_PERSIST, NULL)))\n            return false;\n#else\n         command_event(CMD_EVENT_LOAD_CORE_PERSIST, NULL);\n         command_event(CMD_EVENT_QUIT, NULL);\n#endif\n         break;\n#if defined(HAVE_RUNAHEAD) && (defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB))\n      case CMD_EVENT_LOAD_SECOND_CORE:\n         if (   !(runloop_st->flags & RUNLOOP_FLAG_CORE_RUNNING)\n             || !(runloop_st->flags & RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE))\n            return false;\n\n         if (!runloop_st->secondary_lib_handle)\n         {\n            if (!secondary_core_ensure_exists(runloop_st, settings))\n            {\n               runahead_secondary_core_destroy(runloop_st);\n               runloop_st->flags &=\n                  ~RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE;\n               return false;\n            }\n         }\n         break;\n#endif\n      case CMD_EVENT_LOAD_STATE:\n         {\n#ifdef HAVE_CHEEVOS\n            if (rcheevos_hardcore_active())\n            {\n               const char *_msg = msg_hash_to_str(MSG_CHEEVOS_LOAD_STATE_PREVENTED_BY_HARDCORE_MODE);\n               runloop_msg_queue_push(_msg, strlen(_msg), 0, 180, true, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_WARNING);\n               return false;\n            }\n#endif\n#ifdef HAVE_NETWORKING\n            if (!netplay_driver_ctl(RARCH_NETPLAY_CTL_ALLOW_TIMESKIP, NULL))\n               return false;\n#endif\n            if (!command_event_main_state(cmd))\n               return false;\n            /* Run next frame to see the core output while paused */\n            else if (runloop_st->flags & RUNLOOP_FLAG_PAUSED)\n            {\n               runloop_st->flags               &= ~RUNLOOP_FLAG_PAUSED;\n               runloop_st->run_frames_and_pause = 1;\n            }\n\n#if HAVE_RUNAHEAD\n            command_event(CMD_EVENT_PREEMPT_RESET_BUFFER, NULL);\n#endif\n         }\n         break;\n      case CMD_EVENT_UNDO_LOAD_STATE:\n      case CMD_EVENT_UNDO_SAVE_STATE:\n      case CMD_EVENT_LOAD_STATE_FROM_RAM:\n         if (!command_event_main_state(cmd))\n            return false;\n         break;\n      case CMD_EVENT_RAM_STATE_TO_FILE:\n         if (!content_ram_state_to_file((char *) data))\n            return false;\n         break;\n      case CMD_EVENT_RESIZE_WINDOWED_SCALE:\n         if\n            (!command_event_resize_windowed_scale\n             (settings,\n              runloop_st->pending_windowed_scale))\n            return false;\n         break;\n      case CMD_EVENT_MENU_TOGGLE:\n#ifdef HAVE_MENU\n         if (menu_st->flags & MENU_ST_FLAG_ALIVE)\n            retroarch_menu_running_finished(false);\n         else\n            retroarch_menu_running();\n#endif\n         break;\n      case CMD_EVENT_RESET:\n         {\n            const char *_msg = msg_hash_to_str(MSG_RESET);\n            RARCH_LOG(\"[Core]: %s.\\n\", _msg);\n            runloop_msg_queue_push(_msg, strlen(_msg), 1, 120, true, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n            core_reset();\n#ifdef HAVE_CHEEVOS\n#ifdef HAVE_GFX_WIDGETS\n            rcheevos_reset_game(dispwidget_get_ptr()->active);\n#else\n            rcheevos_reset_game(false);\n#endif\n#endif\n#ifdef HAVE_NETWORKING\n            netplay_driver_ctl(RARCH_NETPLAY_CTL_RESET, NULL);\n#endif\n            /* Recalibrate frame delay target */\n            if (settings->bools.video_frame_delay_auto)\n               video_st->frame_delay_target = 0;\n\n            /* Run a few frames to blank core output while paused */\n            if (runloop_st->flags & RUNLOOP_FLAG_PAUSED)\n            {\n               runloop_st->flags               &= ~RUNLOOP_FLAG_PAUSED;\n               runloop_st->run_frames_and_pause = 8;\n            }\n\n#if HAVE_RUNAHEAD\n            command_event(CMD_EVENT_PREEMPT_RESET_BUFFER, NULL);\n#endif\n         }\n         return false;\n      case CMD_EVENT_PLAY_REPLAY:\n      {\n#ifdef HAVE_BSV_MOVIE\n         input_driver_state_t *input_st = input_state_get_ptr();\n         char replay_path[PATH_MAX_LENGTH];\n         bool res = true;\n         /* TODO: Consider extending the current replay if we start recording during a playback */\n         if (input_st->bsv_movie_state.flags & BSV_FLAG_MOVIE_RECORDING)\n            res = false;\n         else if (input_st->bsv_movie_state.flags & BSV_FLAG_MOVIE_PLAYBACK)\n            res = movie_stop(input_st);\n         if (!runloop_get_current_replay_path(replay_path, sizeof(replay_path)))\n            res = false;\n         if (res)\n            res = movie_start_playback(input_st, replay_path);\n         if (!res)\n         {\n            const char *_msg        =\n               msg_hash_to_str(MSG_FAILED_TO_LOAD_MOVIE_FILE);\n            runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n            RARCH_ERR(\"%s.\\n\", _msg);\n         }\n         return res;\n#else\n         return false;\n#endif\n      }\n      case CMD_EVENT_RECORD_REPLAY:\n      {\n#ifdef HAVE_BSV_MOVIE\n         char replay_path[PATH_MAX_LENGTH];\n         bool res                       = true;\n         input_driver_state_t *input_st = input_state_get_ptr();\n         int replay_slot                = settings->ints.replay_slot;\n         if (settings->bools.replay_auto_index)\n            replay_slot += 1;\n         /* TODO: Consider cloning and extending the current replay if we start recording during a recording */\n         if (input_st->bsv_movie_state.flags & BSV_FLAG_MOVIE_RECORDING)\n            res = false;\n         else if (input_st->bsv_movie_state.flags & BSV_FLAG_MOVIE_PLAYBACK)\n            res = movie_stop(input_st);\n         if (!runloop_get_replay_path(replay_path, sizeof(replay_path), replay_slot))\n            res = false;\n         if (res)\n            res = movie_start_record(input_st, replay_path);\n         if (res && settings->bools.replay_auto_index)\n            configuration_set_int(settings, settings->ints.replay_slot, replay_slot);\n         if (!res)\n         {\n             const char *_msg = msg_hash_to_str(MSG_FAILED_TO_START_MOVIE_RECORD);\n            runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n            RARCH_ERR(\"%s.\\n\", _msg);\n         }\n         return res;\n#else\n         break;\n#endif\n      }\n      case CMD_EVENT_HALT_REPLAY:\n#ifdef HAVE_BSV_MOVIE\n         movie_stop(input_state_get_ptr());\n#endif\n         break;\n      case CMD_EVENT_SAVE_STATE:\n      case CMD_EVENT_SAVE_STATE_TO_RAM:\n         {\n            if (settings->bools.savestate_auto_index)\n            {\n               configuration_set_int(settings, settings->ints.state_slot,\n                  command_event_get_next_savestate_auto_index(settings));\n            }\n         }\n         if (!command_event_main_state(cmd))\n            return false;\n         break;\n      case CMD_EVENT_SAVE_STATE_DECREMENT:\n         {\n            int state_slot            = settings->ints.state_slot;\n\n            /* Slot -1 is (auto) slot. */\n            if (state_slot >= 0)\n            {\n               int new_state_slot = state_slot - 1;\n               configuration_set_int(settings, settings->ints.state_slot, new_state_slot);\n            }\n         }\n         break;\n      case CMD_EVENT_SAVE_STATE_INCREMENT:\n         {\n            int new_state_slot        = settings->ints.state_slot + 1;\n            configuration_set_int(settings, settings->ints.state_slot, new_state_slot);\n         }\n         break;\n      case CMD_EVENT_REPLAY_DECREMENT:\n#ifdef HAVE_BSV_MOVIE\n         {\n            int slot            = settings->ints.replay_slot;\n\n            /* Slot -1 is (auto) slot. */\n            if (slot >= 0)\n            {\n               int new_slot = slot - 1;\n               configuration_set_int(settings, settings->ints.replay_slot, new_slot);\n            }\n         }\n#endif\n         break;\n      case CMD_EVENT_REPLAY_INCREMENT:\n#ifdef HAVE_BSV_MOVIE\n         {\n            int new_slot        = settings->ints.replay_slot + 1;\n            configuration_set_int(settings, settings->ints.replay_slot, new_slot);\n         }\n#endif\n         break;\n      case CMD_EVENT_TAKE_SCREENSHOT:\n#ifdef HAVE_SCREENSHOTS\n         {\n            const char *dir_screenshot      = settings->paths.directory_screenshot;\n            video_driver_state_t *video_st  = video_state_get_ptr();\n            if (!take_screenshot(dir_screenshot,\n                     runloop_st->runtime_content_path_basename,\n                     false,\n                     video_st->frame_cache_data && (video_st->frame_cache_data == RETRO_HW_FRAME_BUFFER_VALID),\n                     false,\n                     true))\n               return false;\n         }\n#endif\n         break;\n      case CMD_EVENT_UNLOAD_CORE:\n         {\n            bool load_dummy_core            = data ? *(bool*)data : true;\n            content_ctx_info_t content_info = {0};\n            video_driver_state_t *video_st  = video_state_get_ptr();\n            rarch_system_info_t *sys_info   = &runloop_st->system;\n            uint8_t flags                   = content_get_flags();\n\n            runloop_st->flags              &= ~RUNLOOP_FLAG_CORE_RUNNING;\n\n            /* The platform that uses ram_state_save calls it when the content\n             * ends and writes it to a file */\n            ram_state_to_file();\n\n            /* Save last selected disk index, if required */\n            if (sys_info)\n               disk_control_save_image_index(&sys_info->disk_control);\n\n            runloop_runtime_log_deinit(runloop_st,\n                  settings->bools.content_runtime_log,\n                  settings->bools.content_runtime_log_aggregate,\n                  settings->paths.directory_runtime_log,\n                  settings->paths.directory_playlist);\n            if (settings->bools.savestate_auto_save &&\n                runloop_st->current_core_type != CORE_TYPE_DUMMY)\n               command_event_save_auto_state();\n\n            if (     (runloop_st->flags & RUNLOOP_FLAG_REMAPS_CORE_ACTIVE)\n                  || (runloop_st->flags & RUNLOOP_FLAG_REMAPS_CONTENT_DIR_ACTIVE)\n                  || (runloop_st->flags & RUNLOOP_FLAG_REMAPS_GAME_ACTIVE)\n                  || !string_is_empty(runloop_st->name.remapfile)\n               )\n            {\n               input_remapping_deinit(settings->bools.remap_save_on_exit);\n               input_remapping_set_defaults(true);\n            }\n            else\n               input_remapping_restore_global_config(true, false);\n\n#ifdef HAVE_CONFIGFILE\n            if (runloop_st->flags & RUNLOOP_FLAG_OVERRIDES_ACTIVE)\n            {\n               /* Reload the original config */\n               config_unload_override();\n\n               if (!settings->bools.video_fullscreen)\n               {\n                  input_driver_state_t *input_st = input_state_get_ptr();\n                  if (     video_st->poke\n                        && video_st->poke->show_mouse)\n                     video_st->poke->show_mouse(video_st->data, true);\n                  if (input_driver_ungrab_mouse())\n                     input_st->flags &= ~INP_FLAG_GRAB_MOUSE_STATE;\n               }\n            }\n#endif\n#ifdef HAVE_CLOUDSYNC\n            task_push_cloud_sync();\n#endif\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n            runloop_st->runtime_shader_preset_path[0] = '\\0';\n#endif\n\n            video_driver_restore_cached(settings);\n\n            if (    (flags & CONTENT_ST_FLAG_IS_INITED)\n                  && load_dummy_core)\n            {\n               if (!task_push_start_dummy_core(&content_info))\n                  return false;\n            }\n#ifdef HAVE_PRESENCE\n            {\n               presence_userdata_t userdata;\n               userdata.status = PRESENCE_NETPLAY_NETPLAY_STOPPED;\n               command_event(CMD_EVENT_PRESENCE_UPDATE, &userdata);\n               userdata.status = PRESENCE_MENU;\n               command_event(CMD_EVENT_PRESENCE_UPDATE, &userdata);\n            }\n#endif\n#ifdef HAVE_DYNAMIC\n            path_clear(RARCH_PATH_CORE);\n            runloop_system_info_free();\n#endif\n            {\n               audio_driver_state_t\n                  *audio_st                  = audio_state_get_ptr();\n               audio_st->callback.callback   = NULL;\n               audio_st->callback.set_state  = NULL;\n            }\n            if (flags & CONTENT_ST_FLAG_IS_INITED)\n            {\n               runloop_st->subsystem_current_count = 0;\n               content_clear_subsystem();\n            }\n         }\n         break;\n      case CMD_EVENT_CLOSE_CONTENT:\n#ifdef HAVE_MENU\n         /* If we need to quit, skip unloading the core to avoid performing\n          * cleanup actions (like writing autosave state) twice. */\n         if (should_quit_on_close()) {\n            command_event(CMD_EVENT_QUIT, NULL);\n            break;\n         }\n         /* Closing content via hotkey requires toggling menu\n          * and resetting the position later on to prevent\n          * going to empty Quick Menu */\n         if (!(menu_state_get_ptr()->flags & MENU_ST_FLAG_ALIVE))\n         {\n            menu_state_get_ptr()->flags |= MENU_ST_FLAG_PENDING_CLOSE_CONTENT;\n            command_event(CMD_EVENT_MENU_TOGGLE, NULL);\n         }\n#else\n         command_event(CMD_EVENT_QUIT, NULL);\n#endif\n         break;\n      case CMD_EVENT_QUIT:\n         if (!retroarch_main_quit())\n            return false;\n         break;\n      case CMD_EVENT_CHEEVOS_HARDCORE_MODE_TOGGLE:\n#ifdef HAVE_CHEEVOS\n         rcheevos_toggle_hardcore_paused();\n#endif\n         break;\n      case CMD_EVENT_REINIT_FROM_TOGGLE:\n         video_st->flags &= ~VIDEO_FLAG_FORCE_FULLSCREEN;\n         /* this fallthrough is on purpose, it should do\n            a CMD_EVENT_REINIT too */\n      case CMD_EVENT_REINIT:\n         command_event_reinit(\n               data ? *(const int*)data : DRIVERS_CMD_ALL);\n\n#if defined(HAVE_AUDIOMIXER) && defined(HAVE_MENU)\n         /* Menu sounds require audio reinit. */\n         if (settings->bools.audio_enable_menu)\n            command_event(CMD_EVENT_AUDIO_REINIT, NULL);\n#endif\n\n         /* Recalibrate frame delay target if not pausing */\n         if (settings->bools.video_frame_delay_auto && !video_st->frame_delay_pause)\n            video_st->frame_delay_target = 0;\n\n         break;\n      case CMD_EVENT_CHEATS_APPLY:\n#ifdef HAVE_CHEATS\n         cheat_manager_apply_cheats();\n#endif\n         break;\n      case CMD_EVENT_REWIND_DEINIT:\n#ifdef HAVE_REWIND\n         {\n            bool core_type_is_dummy   = runloop_st->current_core_type == CORE_TYPE_DUMMY;\n\n            if (core_type_is_dummy)\n               return false;\n\n            state_manager_event_deinit(&runloop_st->rewind_st,\n                  &runloop_st->current_core);\n         }\n#endif\n         break;\n      case CMD_EVENT_REWIND_INIT:\n#ifdef HAVE_REWIND\n         {\n            bool rewind_enable        = settings->bools.rewind_enable;\n            size_t rewind_buf_size    = settings->sizes.rewind_buffer_size;\n            bool core_type_is_dummy   = runloop_st->current_core_type == CORE_TYPE_DUMMY;\n\n            if (core_type_is_dummy)\n               return false;\n#ifdef HAVE_CHEEVOS\n            if (rcheevos_hardcore_active())\n               return false;\n#endif\n#ifdef HAVE_NETWORKING\n            if (!netplay_driver_ctl(RARCH_NETPLAY_CTL_ALLOW_TIMESKIP, NULL))\n               return false;\n#endif\n            if (rewind_enable)\n            {\n#ifdef HAVE_NETWORKING\n               /* Only enable state manager if netplay is not underway\n                  TODO/FIXME: Add a setting for these tweaks */\n               if (!netplay_driver_ctl(\n                        RARCH_NETPLAY_CTL_IS_ENABLED, NULL))\n#endif\n               {\n                  state_manager_event_init(&runloop_st->rewind_st,\n                        (unsigned)rewind_buf_size);\n               }\n            }\n         }\n#endif\n         break;\n      case CMD_EVENT_REWIND_REINIT:\n#ifdef HAVE_REWIND\n         /* to reinitialize the the rewind state manager, we have to recreate it.\n          * the easiest way to do that is a full deinit followed by an init. */\n         if (runloop_st->rewind_st.state != NULL)\n         {\n            command_event(CMD_EVENT_REWIND_DEINIT, NULL);\n            command_event(CMD_EVENT_REWIND_INIT, NULL);\n         }\n#endif\n         break;\n      case CMD_EVENT_REWIND_TOGGLE:\n#ifdef HAVE_REWIND\n         {\n            bool rewind_enable        = settings->bools.rewind_enable;\n            if (rewind_enable)\n               command_event(CMD_EVENT_REWIND_INIT, NULL);\n            else\n               command_event(CMD_EVENT_REWIND_DEINIT, NULL);\n         }\n#endif\n         break;\n      case CMD_EVENT_AUTOSAVE_INIT:\n#ifdef HAVE_THREADS\n         if (runloop_st->flags & RUNLOOP_FLAG_USE_SRAM)\n            autosave_deinit();\n         {\n#ifdef HAVE_NETWORKING\n            unsigned autosave_interval =\n               settings->uints.autosave_interval;\n            /* Only enable state manager if netplay is not underway\n               TODO/FIXME: Add a setting for these tweaks */\n            if (      (autosave_interval != 0)\n                  && !netplay_driver_ctl(\n                     RARCH_NETPLAY_CTL_IS_ENABLED, NULL))\n#endif\n            {\n               if (autosave_init())\n                  runloop_st->flags |=  RUNLOOP_FLAG_AUTOSAVE;\n               else\n                  runloop_st->flags &= ~RUNLOOP_FLAG_AUTOSAVE;\n            }\n         }\n#endif\n         break;\n      case CMD_EVENT_AUDIO_STOP:\n         {\n            bool menu_pause_libretro = false;\n            bool audio_enable_menu   = false;\n\n#if defined(HAVE_AUDIOMIXER) && defined(HAVE_MENU)\n            audio_enable_menu        = settings->bools.audio_enable_menu\n                  && menu_state_get_ptr()->flags & MENU_ST_FLAG_ALIVE;\n#endif\n#ifdef HAVE_NETWORKING\n            menu_pause_libretro      = settings->bools.menu_pause_libretro\n                  && netplay_driver_ctl(RARCH_NETPLAY_CTL_ALLOW_PAUSE, NULL)\n                  && !netplay_driver_ctl(RARCH_NETPLAY_CTL_USE_CORE_PACKET_INTERFACE, NULL);\n#else\n            menu_pause_libretro      = settings->bools.menu_pause_libretro;\n#endif\n\n            if (audio_enable_menu || !menu_pause_libretro)\n               return false;\n\n            if (!audio_driver_stop())\n               return false;\n         }\n         break;\n      case CMD_EVENT_AUDIO_START:\n         {\n            bool menu_pause_libretro = false;\n            bool audio_enable_menu   = false;\n\n#if defined(HAVE_AUDIOMIXER) && defined(HAVE_MENU)\n            audio_enable_menu        = settings->bools.audio_enable_menu\n                  && menu_state_get_ptr()->flags & MENU_ST_FLAG_ALIVE;\n#endif\n#ifdef HAVE_NETWORKING\n            menu_pause_libretro      = settings->bools.menu_pause_libretro\n                  && netplay_driver_ctl(RARCH_NETPLAY_CTL_ALLOW_PAUSE, NULL)\n                  && !netplay_driver_ctl(RARCH_NETPLAY_CTL_USE_CORE_PACKET_INTERFACE, NULL);\n#else\n            menu_pause_libretro      = settings->bools.menu_pause_libretro;\n#endif\n\n            if (audio_enable_menu && !menu_pause_libretro)\n               return false;\n\n            if (!audio_driver_start(runloop_st->flags & RUNLOOP_FLAG_SHUTDOWN_INITIATED))\n               return false;\n         }\n         break;\n#ifdef HAVE_MICROPHONE\n      case CMD_EVENT_MICROPHONE_STOP:\n         if (!microphone_driver_stop())\n            return false;\n         break;\n      case CMD_EVENT_MICROPHONE_START:\n         if (!microphone_driver_start())\n            return false;\n         break;\n#endif\n      case CMD_EVENT_AUDIO_MUTE_TOGGLE:\n         {\n            audio_driver_state_t\n               *audio_st                       = audio_state_get_ptr();\n            bool audio_mute_enable             =\n               *(audio_get_bool_ptr(AUDIO_ACTION_MUTE_ENABLE));\n            const char *msg                    = !audio_mute_enable ?\n               msg_hash_to_str(MSG_AUDIO_MUTED):\n               msg_hash_to_str(MSG_AUDIO_UNMUTED);\n\n            audio_st->mute_enable  =\n               !audio_st->mute_enable;\n\n#if defined(HAVE_GFX_WIDGETS)\n            if (dispwidget_get_ptr()->active)\n               gfx_widget_volume_update_and_show(\n                     settings->floats.audio_volume,\n                     audio_st->mute_enable);\n            else\n#endif\n               runloop_msg_queue_push(msg, strlen(msg), 1, 180, true, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n         }\n         break;\n      case CMD_EVENT_FPS_TOGGLE:\n         settings->bools.video_fps_show = !(settings->bools.video_fps_show);\n         break;\n      case CMD_EVENT_STATISTICS_TOGGLE:\n         settings->bools.video_statistics_show = !(settings->bools.video_statistics_show);\n         break;\n      case CMD_EVENT_OVERLAY_NEXT:\n         /* Switch to the next available overlay screen. */\n#ifdef HAVE_OVERLAY\n         {\n            bool *check_rotation           = (bool*)data;\n            video_driver_state_t\n               *video_st                   = video_state_get_ptr();\n            input_driver_state_t *input_st = input_state_get_ptr();\n            bool inp_overlay_auto_rotate   = settings->bools.input_overlay_auto_rotate;\n            input_overlay_t *ol            = input_st->overlay_ptr;\n            float input_overlay_opacity;\n            if (!ol)\n               return false;\n\n            ol->index                      = ol->next_index;\n            ol->active                     = &ol->overlays[ol->index];\n\n            input_overlay_opacity          = (ol->flags & INPUT_OVERLAY_IS_OSK)\n                  ? settings->floats.input_osk_overlay_opacity\n                  : settings->floats.input_overlay_opacity;\n\n            input_overlay_load_active(input_st->overlay_visibility,\n                  ol, input_overlay_opacity);\n\n            ol->flags                     |= INPUT_OVERLAY_BLOCKED;\n            ol->next_index                 =\n                  (unsigned)((ol->index + 1) % ol->size);\n\n            /* Check orientation, if required */\n            if (inp_overlay_auto_rotate)\n               if (check_rotation)\n                  if (*check_rotation)\n                     input_overlay_auto_rotate_(\n                           video_st->width,\n                           video_st->height,\n                           settings->bools.input_overlay_enable,\n                           ol);\n         }\n#endif\n         break;\n      case CMD_EVENT_OSK_TOGGLE:\n#ifdef HAVE_OVERLAY\n         {\n            settings_t *settings           = config_get_ptr();\n            input_driver_state_t *input_st = input_state_get_ptr();\n\n            if (input_st->flags & INP_FLAG_KB_LINEFEED_ENABLE)\n               input_st->flags &= ~INP_FLAG_KB_LINEFEED_ENABLE;\n            else if (!string_is_empty(settings->paths.path_osk_overlay))\n               input_st->flags |=  INP_FLAG_KB_LINEFEED_ENABLE;\n            else\n            {\n               const char *_msg = msg_hash_to_str(MSG_OSK_OVERLAY_NOT_SET);\n               runloop_msg_queue_push(_msg, strlen(_msg), 1, 100, false, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n            }\n\n            command_event(CMD_EVENT_OVERLAY_INIT, NULL);\n\n#ifdef HAVE_MENU\n            /* Avoid stray menu input during transition */\n            if (menu_st->flags & MENU_ST_FLAG_ALIVE)\n            {\n               menu_st->input_state.select_inhibit  = true;\n               menu_st->input_state.cancel_inhibit  = true;\n            }\n#endif\n         }\n#endif\n         break;\n      case CMD_EVENT_DSP_FILTER_INIT:\n#ifdef HAVE_DSP_FILTER\n         {\n            const char *path_audio_dsp_plugin = settings->paths.path_audio_dsp_plugin;\n            audio_driver_dsp_filter_free();\n            if (string_is_empty(path_audio_dsp_plugin))\n               break;\n            if (!audio_driver_dsp_filter_init(path_audio_dsp_plugin))\n            {\n               RARCH_ERR(\"[DSP]: Failed to initialize DSP filter \\\"%s\\\".\\n\",\n                     path_audio_dsp_plugin);\n            }\n         }\n#endif\n         break;\n      case CMD_EVENT_RECORD_DEINIT:\n         rec_st->enable = false;\n         streaming_set_state(false);\n         if (!recording_deinit())\n            return false;\n         break;\n      case CMD_EVENT_RECORD_INIT:\n         rec_st->enable = true;\n         if (!recording_init())\n         {\n            command_event(CMD_EVENT_RECORD_DEINIT, NULL);\n            return false;\n         }\n         break;\n      case CMD_EVENT_HISTORY_DEINIT:\n         if (g_defaults.content_history)\n         {\n            playlist_write_file(g_defaults.content_history);\n            playlist_free(g_defaults.content_history);\n         }\n         g_defaults.content_history = NULL;\n\n         if (g_defaults.music_history)\n         {\n            playlist_write_file(g_defaults.music_history);\n            playlist_free(g_defaults.music_history);\n         }\n         g_defaults.music_history = NULL;\n\n#if defined(HAVE_FFMPEG) || defined(HAVE_MPV)\n         if (g_defaults.video_history)\n         {\n            playlist_write_file(g_defaults.video_history);\n            playlist_free(g_defaults.video_history);\n         }\n         g_defaults.video_history = NULL;\n#endif\n\n#ifdef HAVE_IMAGEVIEWER\n         if (g_defaults.image_history)\n         {\n            playlist_write_file(g_defaults.image_history);\n            playlist_free(g_defaults.image_history);\n         }\n         g_defaults.image_history = NULL;\n#endif\n         break;\n      case CMD_EVENT_HISTORY_INIT:\n         {\n            playlist_config_t playlist_config;\n            const char *_msg                       = NULL;\n            bool history_list_enable               = settings->bools.history_list_enable;\n            const char *path_content_history       = settings->paths.path_content_history;\n            const char *path_content_music_history = settings->paths.path_content_music_history;\n#if defined(HAVE_FFMPEG) || defined(HAVE_MPV)\n            const char *path_content_video_history = settings->paths.path_content_video_history;\n#endif\n#ifdef HAVE_IMAGEVIEWER\n            const char *path_content_image_history = settings->paths.path_content_image_history;\n#endif\n            playlist_config.capacity               = settings->uints.content_history_size;\n            playlist_config.old_format             = settings->bools.playlist_use_old_format;\n            playlist_config.compress               = settings->bools.playlist_compression;\n            playlist_config.fuzzy_archive_match    = settings->bools.playlist_fuzzy_archive_match;\n            /* don't use relative paths for content, music, video, and image histories */\n            playlist_config_set_base_content_directory(&playlist_config, NULL);\n\n            command_event(CMD_EVENT_HISTORY_DEINIT, NULL);\n\n            if (!history_list_enable || !playlist_config.capacity)\n               return false;\n\n            _msg = msg_hash_to_str(MSG_LOADING_HISTORY_FILE);\n\n            /* Note: Sorting is disabled by default for\n             * all content history playlists */\n            RARCH_LOG(\"[Playlist]: %s: \\\"%s\\\".\\n\", _msg,\n                  path_content_history);\n            playlist_config_set_path(&playlist_config, path_content_history);\n            g_defaults.content_history = playlist_init(&playlist_config);\n            playlist_set_sort_mode(\n                  g_defaults.content_history, PLAYLIST_SORT_MODE_OFF);\n\n            RARCH_LOG(\"[Playlist]: %s: \\\"%s\\\".\\n\", _msg,\n                  path_content_music_history);\n            playlist_config_set_path(&playlist_config, path_content_music_history);\n            g_defaults.music_history = playlist_init(&playlist_config);\n            playlist_set_sort_mode(\n                  g_defaults.music_history, PLAYLIST_SORT_MODE_OFF);\n\n#if defined(HAVE_FFMPEG) || defined(HAVE_MPV)\n            RARCH_LOG(\"[Playlist]: %s: \\\"%s\\\".\\n\", _msg,\n                  path_content_video_history);\n            playlist_config_set_path(&playlist_config, path_content_video_history);\n            g_defaults.video_history = playlist_init(&playlist_config);\n            playlist_set_sort_mode(\n                  g_defaults.video_history, PLAYLIST_SORT_MODE_OFF);\n#endif\n\n#ifdef HAVE_IMAGEVIEWER\n            RARCH_LOG(\"[Playlist]: %s: \\\"%s\\\".\\n\", _msg,\n                  path_content_image_history);\n            playlist_config_set_path(&playlist_config, path_content_image_history);\n            g_defaults.image_history = playlist_init(&playlist_config);\n            playlist_set_sort_mode(\n                  g_defaults.image_history, PLAYLIST_SORT_MODE_OFF);\n#endif\n         }\n         break;\n      case CMD_EVENT_CORE_INFO_DEINIT:\n         core_info_deinit_list();\n         core_info_free_current_core();\n         break;\n      case CMD_EVENT_CORE_INFO_INIT:\n         {\n            char ext_name[16];\n            const char *dir_libretro       = settings->paths.directory_libretro;\n            const char *path_libretro_info = settings->paths.path_libretro_info;\n            bool show_hidden_files         = settings->bools.show_hidden_files;\n            bool core_info_cache_enable    = settings->bools.core_info_cache_enable;\n\n            command_event(CMD_EVENT_CORE_INFO_DEINIT, NULL);\n\n            if (!frontend_driver_get_core_extension(ext_name, sizeof(ext_name)))\n               return false;\n\n            if (!string_is_empty(dir_libretro))\n            {\n               bool cache_supported = false;\n\n               core_info_init_list(path_libretro_info,\n                     dir_libretro,\n                     ext_name,\n                     show_hidden_files,\n                     core_info_cache_enable,\n                     &cache_supported);\n\n               /* If core info cache is enabled but cache\n                * functionality is unsupported (i.e. because\n                * the core info directory is on read-only\n                * storage), force-disable the setting to\n                * avoid repeated failures */\n               if (core_info_cache_enable && !cache_supported)\n                  configuration_set_bool(settings,\n                        settings->bools.core_info_cache_enable, false);\n            }\n         }\n         break;\n      case CMD_EVENT_CORE_DEINIT:\n         {\n            struct retro_hw_render_callback *hwr = NULL;\n            video_driver_state_t\n               *video_st                         = video_state_get_ptr();\n            rarch_system_info_t *sys_info        = &runloop_st->system;\n\n            /* The platform that uses ram_state_save calls it when the content\n             * ends and writes it to a file */\n            ram_state_to_file();\n\n            /* Save last selected disk index, if required */\n            if (sys_info)\n               disk_control_save_image_index(&sys_info->disk_control);\n\n            runloop_runtime_log_deinit(runloop_st,\n                  settings->bools.content_runtime_log,\n                  settings->bools.content_runtime_log_aggregate,\n                  settings->paths.directory_runtime_log,\n                  settings->paths.directory_playlist);\n\n            if (     runloop_st->flags & RUNLOOP_FLAG_CORE_RUNNING\n                  && settings->bools.savestate_auto_save)\n            {\n               command_event_save_auto_state();\n               content_wait_for_save_state_task();\n            }\n\n            content_reset_savestate_backups();\n            hwr = VIDEO_DRIVER_GET_HW_CONTEXT_INTERNAL(video_st);\n#ifdef HAVE_CHEEVOS\n            rcheevos_unload();\n#endif\n            runloop_event_deinit_core();\n\n#ifdef HAVE_RUNAHEAD\n            /* If 'runahead_available' is false, then\n             * runahead is enabled by the user but an\n             * error occurred while the core was running\n             * (typically a save state issue). In this\n             * case we have to 'manually' reset the runahead\n             * runtime variables, otherwise runahead will\n             * remain disabled until the user restarts\n             * RetroArch */\n            if (!(runloop_st->flags & RUNLOOP_FLAG_RUNAHEAD_AVAILABLE))\n               runahead_clear_variables(runloop_st);\n\n            /* Deallocate preemptive frames */\n            preempt_deinit(runloop_st);\n#endif\n\n            if (hwr)\n               memset(hwr, 0, sizeof(*hwr));\n\n            break;\n         }\n      case CMD_EVENT_CORE_INIT:\n         {\n            enum rarch_core_type *type     = (enum rarch_core_type*)data;\n            rarch_system_info_t *sys_info  = &runloop_st->system;\n            input_driver_state_t *input_st = input_state_get_ptr();\n            audio_driver_state_t *audio_st = audio_state_get_ptr();\n\n            content_reset_savestate_backups();\n\n            /* Ensure that disk control interface is reset */\n            if (sys_info)\n               disk_control_set_ext_callback(&sys_info->disk_control, NULL);\n\n            /* Ensure that audio callback interface is reset */\n            audio_st->callback.callback  = NULL;\n            audio_st->callback.set_state = NULL;\n\n            if (     !type\n                  || !runloop_event_init_core(settings, input_st, *type,\n                     p_rarch->dir_savefile, p_rarch->dir_savestate))\n            {\n               /* If core failed to initialise, audio callback\n                * interface may be assigned invalid function\n                * pointers -> ensure it is reset */\n               audio_st->callback.callback  = NULL;\n               audio_st->callback.set_state = NULL;\n               return false;\n            }\n         }\n         break;\n      case CMD_EVENT_VIDEO_APPLY_STATE_CHANGES:\n         video_driver_apply_state_changes();\n         break;\n      case CMD_EVENT_VIDEO_SET_BLOCKING_STATE:\n         {\n            bool adaptive_vsync       = settings->bools.video_adaptive_vsync;\n            unsigned swap_interval    = runloop_get_video_swap_interval(\n                  settings->uints.video_swap_interval);\n            video_driver_state_t\n               *video_st              = video_state_get_ptr();\n\n            if (video_st->current_video->set_nonblock_state)\n               video_st->current_video->set_nonblock_state(\n                     video_st->data, false,\n                     video_driver_test_all_flags(\n                        GFX_CTX_FLAGS_ADAPTIVE_VSYNC)\n                     && adaptive_vsync, swap_interval);\n         }\n         break;\n      case CMD_EVENT_VIDEO_SET_ASPECT_RATIO:\n         video_driver_set_aspect_ratio();\n         break;\n      case CMD_EVENT_OVERLAY_SET_SCALE_FACTOR:\n#ifdef HAVE_OVERLAY\n         {\n            overlay_layout_desc_t layout_desc;\n            video_driver_state_t *video_st = video_state_get_ptr();\n            input_driver_state_t *input_st = input_state_get_ptr();\n            input_overlay_t *ol            = input_st->overlay_ptr;\n\n            if (!ol)\n               break;\n\n            if (ol->flags & INPUT_OVERLAY_IS_OSK)\n            {\n               memset(&layout_desc, 0, sizeof(overlay_layout_desc_t));\n               layout_desc.scale_landscape         = 1.0f;\n               layout_desc.scale_portrait          = 1.0f;\n               layout_desc.touch_scale             = 1.0f;\n               layout_desc.auto_scale              = settings->bools.input_osk_overlay_auto_scale;\n            }\n            else\n            {\n               layout_desc.scale_landscape         = settings->floats.input_overlay_scale_landscape;\n               layout_desc.aspect_adjust_landscape = settings->floats.input_overlay_aspect_adjust_landscape;\n               layout_desc.x_separation_landscape  = settings->floats.input_overlay_x_separation_landscape;\n               layout_desc.y_separation_landscape  = settings->floats.input_overlay_y_separation_landscape;\n               layout_desc.x_offset_landscape      = settings->floats.input_overlay_x_offset_landscape;\n               layout_desc.y_offset_landscape      = settings->floats.input_overlay_y_offset_landscape;\n               layout_desc.scale_portrait          = settings->floats.input_overlay_scale_portrait;\n               layout_desc.aspect_adjust_portrait  = settings->floats.input_overlay_aspect_adjust_portrait;\n               layout_desc.x_separation_portrait   = settings->floats.input_overlay_x_separation_portrait;\n               layout_desc.y_separation_portrait   = settings->floats.input_overlay_y_separation_portrait;\n               layout_desc.x_offset_portrait       = settings->floats.input_overlay_x_offset_portrait;\n               layout_desc.y_offset_portrait       = settings->floats.input_overlay_y_offset_portrait;\n               layout_desc.touch_scale             = (float)settings->uints.input_touch_scale;\n               layout_desc.auto_scale              = settings->bools.input_overlay_auto_scale;\n            }\n\n            input_overlay_set_scale_factor(ol,\n                  &layout_desc,\n                  video_st->width,\n                  video_st->height);\n         }\n#endif\n         break;\n      case CMD_EVENT_OVERLAY_SET_ALPHA_MOD:\n         /* Sets a modulating factor for alpha channel. Default is 1.0.\n          * The alpha factor is applied for all overlays. */\n#ifdef HAVE_OVERLAY\n         {\n            input_driver_state_t *input_st = input_state_get_ptr();\n            input_overlay_t *ol            = input_st->overlay_ptr;\n\n            if (ol)\n            {\n               float input_overlay_opacity = (ol->flags & INPUT_OVERLAY_IS_OSK)\n                     ? settings->floats.input_osk_overlay_opacity\n                     : settings->floats.input_overlay_opacity;\n\n               input_overlay_set_alpha_mod(input_st->overlay_visibility,\n                        ol, input_overlay_opacity);\n            }\n         }\n#endif\n         break;\n      case CMD_EVENT_OVERLAY_SET_EIGHTWAY_DIAGONAL_SENSITIVITY:\n#ifdef HAVE_OVERLAY\n         input_overlay_set_eightway_diagonal_sensitivity();\n#endif\n         break;\n      case CMD_EVENT_AUDIO_REINIT:\n         driver_uninit(DRIVER_AUDIO_MASK, DRIVER_LIFETIME_RESET);\n         drivers_init(settings, DRIVER_AUDIO_MASK, DRIVER_LIFETIME_RESET, verbosity_is_enabled());\n#if defined(HAVE_AUDIOMIXER)\n         audio_driver_load_system_sounds();\n#endif\n         break;\n#ifdef HAVE_MICROPHONE\n      case CMD_EVENT_MICROPHONE_REINIT:\n         driver_uninit(DRIVER_MICROPHONE_MASK, DRIVER_LIFETIME_RESET);\n         drivers_init(settings, DRIVER_MICROPHONE_MASK, DRIVER_LIFETIME_RESET, verbosity_is_enabled());\n         break;\n#endif\n      case CMD_EVENT_SHUTDOWN:\n         {\n#if defined(__linux__) && !defined(ANDROID)\n            const char *_msg = msg_hash_to_str(MSG_VALUE_SHUTTING_DOWN);\n            if (settings->bools.config_save_on_exit)\n               command_event(CMD_EVENT_MENU_SAVE_CURRENT_CONFIG, NULL);\n            runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n#ifdef HAVE_LAKKA\n            system(\"nohup /usr/bin/lakka-shutdown.sh 2>&1 >/dev/null & exit\");\n#else\n            command_event(CMD_EVENT_QUIT, NULL);\n            system(\"shutdown -P now\");\n#endif /* HAVE_LAKKA */\n#endif\n         }\n         break;\n      case CMD_EVENT_REBOOT:\n         {\n#if defined(__linux__) && !defined(ANDROID)\n            const char *_msg = msg_hash_to_str(MSG_VALUE_REBOOTING);\n            if (settings->bools.config_save_on_exit)\n               command_event(CMD_EVENT_MENU_SAVE_CURRENT_CONFIG, NULL);\n            runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n#ifdef HAVE_LAKKA\n            system(\"nohup /usr/bin/lakka-reboot.sh 2>&1 >/dev/null & exit\");\n#else\n            command_event(CMD_EVENT_QUIT, NULL);\n            system(\"shutdown -r now\");\n#endif /* HAVE_LAKKA */\n#endif\n         }\n         break;\n      case CMD_EVENT_RESUME:\n#ifdef HAVE_MENU\n         retroarch_menu_running_finished(false);\n#endif\n         if (uico_st->flags & UICO_ST_FLAG_IS_ON_FOREGROUND)\n         {\n#ifdef HAVE_QT\n            bool desktop_menu_enable = settings->bools.desktop_menu_enable;\n            bool ui_companion_toggle = settings->bools.ui_companion_toggle;\n#else\n            bool desktop_menu_enable = false;\n            bool ui_companion_toggle = false;\n#endif\n            ui_companion_driver_toggle(desktop_menu_enable,\n                  ui_companion_toggle, false);\n         }\n         break;\n      case CMD_EVENT_ADD_TO_FAVORITES:\n         {\n            struct string_list *str_list = (struct string_list*)data;\n\n            /* Check whether favourites playlist is at capacity */\n            if (     playlist_size(g_defaults.content_favorites)\n                  >= playlist_capacity(g_defaults.content_favorites))\n            {\n               const char *_msg = msg_hash_to_str(MSG_ADD_TO_FAVORITES_FAILED);\n               runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_ERROR);\n               return true;\n            }\n\n            if (str_list)\n            {\n               if (str_list->size >= 6)\n               {\n                  struct playlist_entry entry     = {0};\n                  bool playlist_sort_alphabetical = settings->bools.playlist_sort_alphabetical;\n\n                  entry.path      = str_list->elems[0].data; /* content_path */\n                  entry.label     = str_list->elems[1].data; /* content_label */\n                  entry.core_path = str_list->elems[2].data; /* core_path */\n                  entry.core_name = str_list->elems[3].data; /* core_name */\n                  entry.crc32     = str_list->elems[4].data; /* crc32 */\n                  entry.db_name   = str_list->elems[5].data; /* db_name */\n\n                  /* Write playlist entry */\n                  if (playlist_push(g_defaults.content_favorites, &entry))\n                  {\n                     const char *_msg;\n                     enum playlist_sort_mode current_sort_mode =\n                        playlist_get_sort_mode(g_defaults.content_favorites);\n\n                     /* New addition - need to resort if option is enabled */\n                     if (     (playlist_sort_alphabetical\n                           && (current_sort_mode == PLAYLIST_SORT_MODE_DEFAULT))\n                           || (current_sort_mode == PLAYLIST_SORT_MODE_ALPHABETICAL))\n                        playlist_qsort(g_defaults.content_favorites);\n\n                     playlist_write_file(g_defaults.content_favorites);\n                     _msg = msg_hash_to_str(MSG_ADDED_TO_FAVORITES);\n                     runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                           MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n#if TARGET_OS_TV\n                     update_topshelf();\n#endif\n                  }\n               }\n            }\n            break;\n         }\n         case CMD_EVENT_ADD_TO_PLAYLIST:\n         {\n#ifdef HAVE_MENU\n            struct string_list *str_list = (struct string_list*)data;\n            struct menu_state *menu_st     = menu_state_get_ptr();\n            settings_t *settings = config_get_ptr();\n\n            if (str_list)\n            {\n               if (str_list->size >= 7)\n               {\n                  playlist_config_t playlist_config;\n                  playlist_t * playlist;\n\n                  struct playlist_entry entry     = {0};\n                  bool playlist_sort_alphabetical = settings->bools.playlist_sort_alphabetical;\n\n                  entry.path      = str_list->elems[0].data; /* content_path */\n                  entry.label     = str_list->elems[1].data; /* content_label */\n                  entry.core_path = str_list->elems[2].data; /* core_path */\n                  entry.core_name = str_list->elems[3].data; /* core_name */\n                  entry.crc32     = str_list->elems[4].data; /* crc32 */\n                  entry.db_name   = str_list->elems[5].data; /* db_name */\n\n                  /* load the playlist */\n                  playlist_config.capacity            = COLLECTION_SIZE;\n                  playlist_config.old_format          = settings->bools.playlist_use_old_format;\n                  playlist_config.compress            = settings->bools.playlist_compression;\n                  playlist_config.fuzzy_archive_match = settings->bools.playlist_fuzzy_archive_match;\n                  playlist_config_set_base_content_directory(&playlist_config,\n                        settings->bools.playlist_portable_paths\n                        ? settings->paths.directory_menu_content\n                        : NULL);\n                  playlist_config_set_path(&playlist_config, str_list->elems[6].data);\n                  playlist = playlist_init(&playlist_config);\n\n                  /* Check whether favourites playlist is at capacity */\n                  if (     playlist_size(playlist)\n                        >= playlist_capacity(playlist))\n                  {\n                     const char *_msg = msg_hash_to_str(MSG_ADD_TO_PLAYLIST_FAILED);\n                     runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                           MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_ERROR);\n                     return true;\n                  }\n\n                  /* Write playlist entry */\n                  if (playlist_push(playlist, &entry))\n                  {\n                     const char *_msg = NULL;\n                     enum playlist_sort_mode current_sort_mode =\n                        playlist_get_sort_mode(playlist);\n\n                     /* New addition - need to resort if option is enabled */\n                     if (     (playlist_sort_alphabetical\n                           && (current_sort_mode == PLAYLIST_SORT_MODE_DEFAULT))\n                           || (current_sort_mode == PLAYLIST_SORT_MODE_ALPHABETICAL))\n                        playlist_qsort(playlist);\n\n                     playlist_write_file(playlist);\n                     _msg = msg_hash_to_str(MSG_ADDED_TO_PLAYLIST);\n                     runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                           MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n                  }\n                  menu_st->flags                  |= MENU_ST_FLAG_ENTRIES_NEED_REFRESH;\n                  if (menu_st->driver_ctx->environ_cb)\n                     menu_st->driver_ctx->environ_cb(MENU_ENVIRON_RESET_HORIZONTAL_LIST,\n                           NULL, menu_st->userdata);\n               }\n            }\n#endif\n            break;\n         }\n      case CMD_EVENT_RESET_CORE_ASSOCIATION:\n         {\n            const char *_msg;\n            const char *core_name          = \"DETECT\";\n            const char *core_path          = \"DETECT\";\n            size_t *playlist_index         = (size_t*)data;\n            struct playlist_entry entry    = {0};\n            unsigned i                     = 0;\n#ifdef HAVE_MENU\n            struct menu_state *menu_st     = menu_state_get_ptr();\n#endif\n\n            /* the update function reads our entry as const,\n             * so these casts are safe */\n            entry.core_path                = (char*)core_path;\n            entry.core_name                = (char*)core_name;\n\n            command_playlist_update_write(\n                  NULL, *playlist_index, &entry);\n\n#ifdef HAVE_MENU\n            /* Update playlist metadata */\n            if (     menu_st->driver_ctx\n                  && menu_st->driver_ctx->refresh_thumbnail_image)\n               menu_st->driver_ctx->refresh_thumbnail_image(\n                     menu_st->userdata, i);\n#endif\n\n            _msg = msg_hash_to_str(MSG_RESET_CORE_ASSOCIATION);\n            runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n            break;\n         }\n      case CMD_EVENT_RESTART_RETROARCH:\n         if (!frontend_driver_set_fork(FRONTEND_FORK_RESTART))\n            return false;\n#ifndef HAVE_DYNAMIC\n         command_event(CMD_EVENT_QUIT, NULL);\n#endif\n         break;\n      case CMD_EVENT_MENU_RESET_TO_DEFAULT_CONFIG:\n         config_set_defaults(global_get_ptr());\n         break;\n      case CMD_EVENT_MENU_SAVE_CURRENT_CONFIG:\n#if !defined(HAVE_DYNAMIC)\n         config_save_file_salamander();\n#endif\n#ifdef HAVE_CONFIGFILE\n         command_event_save_current_config(OVERRIDE_NONE);\n#endif\n         break;\n      case CMD_EVENT_MENU_SAVE_CURRENT_CONFIG_OVERRIDE_CORE:\n#ifdef HAVE_CONFIGFILE\n         command_event_save_current_config(OVERRIDE_CORE);\n#endif\n         break;\n      case CMD_EVENT_MENU_SAVE_CURRENT_CONFIG_OVERRIDE_CONTENT_DIR:\n#ifdef HAVE_CONFIGFILE\n         command_event_save_current_config(OVERRIDE_CONTENT_DIR);\n#endif\n         break;\n      case CMD_EVENT_MENU_SAVE_CURRENT_CONFIG_OVERRIDE_GAME:\n#ifdef HAVE_CONFIGFILE\n         command_event_save_current_config(OVERRIDE_GAME);\n#endif\n         break;\n      case CMD_EVENT_MENU_REMOVE_CURRENT_CONFIG_OVERRIDE_CORE:\n#ifdef HAVE_CONFIGFILE\n         command_event_remove_current_config(OVERRIDE_CORE);\n#endif\n         break;\n      case CMD_EVENT_MENU_REMOVE_CURRENT_CONFIG_OVERRIDE_CONTENT_DIR:\n#ifdef HAVE_CONFIGFILE\n         command_event_remove_current_config(OVERRIDE_CONTENT_DIR);\n#endif\n         break;\n      case CMD_EVENT_MENU_REMOVE_CURRENT_CONFIG_OVERRIDE_GAME:\n#ifdef HAVE_CONFIGFILE\n         command_event_remove_current_config(OVERRIDE_GAME);\n#endif\n         break;\n      case CMD_EVENT_MENU_SAVE_CONFIG:\n#ifdef HAVE_CONFIGFILE\n         if (!command_event_save_core_config(\n                  settings->paths.directory_menu_config,\n                  p_rarch->path_config_file))\n            return false;\n#endif\n         break;\n      case CMD_EVENT_SHADER_PRESET_LOADED:\n         ui_companion_event_command(cmd);\n         break;\n      case CMD_EVENT_SHADERS_APPLY_CHANGES:\n#ifdef HAVE_MENU\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n         menu_shader_manager_apply_changes(menu_shader_get(),\n               settings->paths.directory_video_shader,\n               settings->paths.directory_menu_config\n               );\n#endif\n#endif\n         ui_companion_event_command(cmd);\n         break;\n      case CMD_EVENT_PAUSE_TOGGLE:\n         {\n            bool paused          = (runloop_st->flags & RUNLOOP_FLAG_PAUSED) ? true : false;\n#ifdef HAVE_ACCESSIBILITY\n            bool accessibility_enable\n                                 = settings->bools.accessibility_enable;\n            unsigned accessibility_narrator_speech_speed\n                                 = settings->uints.accessibility_narrator_speech_speed;\n#endif\n\n#ifdef HAVE_NETWORKING\n            if (!netplay_driver_ctl(RARCH_NETPLAY_CTL_ALLOW_PAUSE, NULL))\n               break;\n#endif\n\n            paused               = !paused;\n\n#ifdef HAVE_ACCESSIBILITY\n            if (is_accessibility_enabled(\n                  accessibility_enable,\n                  access_st->enabled))\n            {\n               if (paused)\n                  accessibility_speak_priority(\n                     accessibility_enable,\n                     accessibility_narrator_speech_speed,\n                     (char*)msg_hash_to_str(MSG_PAUSED), 10);\n               else\n                  accessibility_speak_priority(\n                     accessibility_enable,\n                     accessibility_narrator_speech_speed,\n                     (char*)msg_hash_to_str(MSG_UNPAUSED), 10);\n            }\n#endif\n            if (paused)\n               runloop_st->flags |=  RUNLOOP_FLAG_PAUSED;\n            else\n               runloop_st->flags &= ~RUNLOOP_FLAG_PAUSED;\n            runloop_pause_checks();\n         }\n         break;\n      case CMD_EVENT_UNPAUSE:\n#ifdef HAVE_NETWORKING\n         if (!netplay_driver_ctl(RARCH_NETPLAY_CTL_ALLOW_PAUSE, NULL))\n            break;\n#endif\n         runloop_st->flags      &= ~RUNLOOP_FLAG_PAUSED;\n         runloop_pause_checks();\n         break;\n      case CMD_EVENT_PAUSE:\n#ifdef HAVE_NETWORKING\n         if (!netplay_driver_ctl(RARCH_NETPLAY_CTL_ALLOW_PAUSE, NULL))\n            break;\n#endif\n         runloop_st->flags      |= RUNLOOP_FLAG_PAUSED;\n         runloop_pause_checks();\n         break;\n      case CMD_EVENT_MENU_PAUSE_LIBRETRO:\n#ifdef HAVE_MENU\n         {\n#ifdef HAVE_NETWORKING\n            bool menu_pause_libretro = settings->bools.menu_pause_libretro\n                  && netplay_driver_ctl(RARCH_NETPLAY_CTL_ALLOW_PAUSE, NULL);\n#else\n            bool menu_pause_libretro = settings->bools.menu_pause_libretro;\n#endif\n\n            if (menu_pause_libretro)\n            {\n               command_event(CMD_EVENT_AUDIO_STOP, NULL);\n#ifdef HAVE_MICROPHONE\n               command_event(CMD_EVENT_MICROPHONE_STOP, NULL);\n#endif\n            }\n            else\n            {\n               command_event(CMD_EVENT_AUDIO_START, NULL);\n#ifdef HAVE_MICROPHONE\n               command_event(CMD_EVENT_MICROPHONE_START, NULL);\n#endif\n            }\n         }\n#endif\n         break;\n#ifdef HAVE_NETWORKING\n      case CMD_EVENT_NETPLAY_PING_TOGGLE:\n         settings->bools.netplay_ping_show =\n            !settings->bools.netplay_ping_show;\n         break;\n      case CMD_EVENT_NETPLAY_GAME_WATCH:\n         netplay_driver_ctl(RARCH_NETPLAY_CTL_GAME_WATCH, NULL);\n         break;\n      case CMD_EVENT_NETPLAY_PLAYER_CHAT:\n         netplay_driver_ctl(RARCH_NETPLAY_CTL_PLAYER_CHAT, NULL);\n         break;\n      case CMD_EVENT_NETPLAY_FADE_CHAT_TOGGLE:\n         settings->bools.netplay_fade_chat =\n            !settings->bools.netplay_fade_chat;\n         break;\n      case CMD_EVENT_NETPLAY_DEINIT:\n         deinit_netplay();\n         break;\n      case CMD_EVENT_NETWORK_INIT:\n         network_init();\n         break;\n         /* init netplay manually */\n      case CMD_EVENT_NETPLAY_INIT:\n         {\n            char tmp_netplay_server[256];\n            char tmp_netplay_session[256];\n            char *netplay_server  = NULL;\n            char *netplay_session = NULL;\n            unsigned netplay_port = 0;\n\n            command_event(CMD_EVENT_NETPLAY_DEINIT, NULL);\n\n            tmp_netplay_server[0]  = '\\0';\n            tmp_netplay_session[0] = '\\0';\n            if (netplay_decode_hostname(p_rarch->connect_host,\n               tmp_netplay_server, &netplay_port, tmp_netplay_session,\n               sizeof(tmp_netplay_server)))\n            {\n               netplay_server  = tmp_netplay_server;\n               netplay_session = tmp_netplay_session;\n            }\n\n            if (p_rarch->connect_mitm_id)\n                netplay_session = strdup(p_rarch->connect_mitm_id);\n\n            if (p_rarch->connect_host)\n            {\n                free(p_rarch->connect_host);\n                p_rarch->connect_host = NULL;\n            }\n\n            if (string_is_empty(netplay_server))\n               netplay_server = settings->paths.netplay_server;\n            if (!netplay_port)\n               netplay_port   = settings->uints.netplay_port;\n\n            if (!init_netplay(netplay_server, netplay_port, netplay_session))\n            {\n               command_event(CMD_EVENT_NETPLAY_DEINIT, NULL);\n               if (p_rarch->connect_mitm_id)\n               {\n                  free(p_rarch->connect_mitm_id);\n                  free(netplay_session);\n                  p_rarch->connect_mitm_id = NULL;\n                  netplay_session          = NULL;\n               }\n               return false;\n            }\n\n            if (p_rarch->connect_mitm_id)\n            {\n               free(p_rarch->connect_mitm_id);\n               free(netplay_session);\n               p_rarch->connect_mitm_id = NULL;\n               netplay_session          = NULL;\n            }\n\n            /* Disable rewind & SRAM autosave if it was enabled\n             * TODO/FIXME: Add a setting for these tweaks */\n#ifdef HAVE_REWIND\n            state_manager_event_deinit(&runloop_st->rewind_st,\n                  &runloop_st->current_core);\n#endif\n#ifdef HAVE_THREADS\n            autosave_deinit();\n#endif\n         }\n         break;\n         /* Initialize netplay via lobby when content is loaded */\n      case CMD_EVENT_NETPLAY_INIT_DIRECT:\n         {\n            char netplay_server[256];\n            char netplay_session[256];\n            unsigned netplay_port = 0;\n\n            command_event(CMD_EVENT_NETPLAY_DEINIT, NULL);\n\n            netplay_server[0]  = '\\0';\n            netplay_session[0] = '\\0';\n            netplay_decode_hostname((char*) data, netplay_server,\n               &netplay_port, netplay_session, sizeof(netplay_server));\n\n            if (!netplay_port)\n               netplay_port = settings->uints.netplay_port;\n\n            RARCH_LOG(\"[Netplay]: Connecting to %s|%d (direct)\\n\",\n               netplay_server, netplay_port);\n\n            if (!init_netplay(netplay_server, netplay_port, netplay_session))\n            {\n               command_event(CMD_EVENT_NETPLAY_DEINIT, NULL);\n               return false;\n            }\n\n            /* Disable rewind if it was enabled\n               TODO/FIXME: Add a setting for these tweaks */\n#ifdef HAVE_REWIND\n            state_manager_event_deinit(&runloop_st->rewind_st,\n                  &runloop_st->current_core);\n#endif\n#ifdef HAVE_THREADS\n            autosave_deinit();\n#endif\n         }\n         break;\n         /* init netplay via lobby when content is not loaded */\n      case CMD_EVENT_NETPLAY_INIT_DIRECT_DEFERRED:\n         {\n            char netplay_server[256];\n            char netplay_session[256];\n            unsigned netplay_port = 0;\n\n            command_event(CMD_EVENT_NETPLAY_DEINIT, NULL);\n\n            netplay_server[0]  = '\\0';\n            netplay_session[0] = '\\0';\n            netplay_decode_hostname((char*) data, netplay_server,\n               &netplay_port, netplay_session, sizeof(netplay_server));\n\n            if (!netplay_port)\n               netplay_port = settings->uints.netplay_port;\n\n            RARCH_LOG(\"[Netplay]: Connecting to %s|%d (deferred)\\n\",\n               netplay_server, netplay_port);\n\n            if (!init_netplay_deferred(netplay_server, netplay_port, netplay_session))\n            {\n               command_event(CMD_EVENT_NETPLAY_DEINIT, NULL);\n               return false;\n            }\n\n            /* Disable rewind if it was enabled\n             * TODO/FIXME: Add a setting for these tweaks */\n#ifdef HAVE_REWIND\n            state_manager_event_deinit(&runloop_st->rewind_st,\n                  &runloop_st->current_core);\n#endif\n#ifdef HAVE_THREADS\n            autosave_deinit();\n#endif\n         }\n         break;\n      case CMD_EVENT_NETPLAY_ENABLE_HOST:\n         {\n            if (netplay_driver_ctl(RARCH_NETPLAY_CTL_USE_CORE_PACKET_INTERFACE, NULL))\n            {\n               netplay_driver_ctl(RARCH_NETPLAY_CTL_ENABLE_SERVER, NULL);\n               command_event(CMD_EVENT_NETPLAY_INIT, NULL);\n            }\n            else if (!task_push_netplay_content_reload(NULL))\n            {\n#ifdef HAVE_DYNAMIC\n               const char *_msg = msg_hash_to_str(MENU_ENUM_LABEL_VALUE_NETPLAY_START_WHEN_LOADED);\n               command_event(CMD_EVENT_NETPLAY_DEINIT, NULL);\n               netplay_driver_ctl(RARCH_NETPLAY_CTL_ENABLE_SERVER, NULL);\n\n               runloop_msg_queue_push(_msg, strlen(_msg), 1, 480, true, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n#else\n               const char *_msg = msg_hash_to_str(MSG_NETPLAY_NEED_CONTENT_LOADED);\n               runloop_msg_queue_push(_msg, strlen(_msg), 1, 480, true, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n#endif\n\n               return false;\n            }\n#if HAVE_RUNAHEAD\n            /* Deinit preemptive frames; not compatible with netplay */\n            preempt_deinit(runloop_st);\n#endif\n         }\n         break;\n      case CMD_EVENT_NETPLAY_DISCONNECT:\n         {\n            bool rewind_enable         = settings->bools.rewind_enable;\n            unsigned autosave_interval = settings->uints.autosave_interval;\n\n            netplay_driver_ctl(RARCH_NETPLAY_CTL_DISCONNECT, NULL);\n            netplay_driver_ctl(RARCH_NETPLAY_CTL_DISABLE, NULL);\n\n#ifdef HAVE_REWIND\n            /* Re-enable rewind if it was enabled\n             * TODO/FIXME: Add a setting for these tweaks */\n            if (rewind_enable)\n               command_event(CMD_EVENT_REWIND_INIT, NULL);\n#endif\n            if (autosave_interval != 0)\n               command_event(CMD_EVENT_AUTOSAVE_INIT, NULL);\n         }\n         break;\n      case CMD_EVENT_NETPLAY_HOST_TOGGLE:\n         if (netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_ENABLED, NULL))\n         {\n            if (     netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_SERVER, NULL)\n                  || netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_CONNECTED, NULL))\n               command_event(CMD_EVENT_NETPLAY_DISCONNECT, NULL);\n         }\n         else\n            command_event(CMD_EVENT_NETPLAY_ENABLE_HOST, NULL);\n\n         break;\n#else\n      case CMD_EVENT_NETPLAY_DEINIT:\n      case CMD_EVENT_NETWORK_INIT:\n      case CMD_EVENT_NETPLAY_INIT:\n      case CMD_EVENT_NETPLAY_INIT_DIRECT:\n      case CMD_EVENT_NETPLAY_INIT_DIRECT_DEFERRED:\n      case CMD_EVENT_NETPLAY_HOST_TOGGLE:\n      case CMD_EVENT_NETPLAY_DISCONNECT:\n      case CMD_EVENT_NETPLAY_ENABLE_HOST:\n      case CMD_EVENT_NETPLAY_PING_TOGGLE:\n      case CMD_EVENT_NETPLAY_GAME_WATCH:\n      case CMD_EVENT_NETPLAY_PLAYER_CHAT:\n      case CMD_EVENT_NETPLAY_FADE_CHAT_TOGGLE:\n         return false;\n#endif\n      case CMD_EVENT_FULLSCREEN_TOGGLE:\n         {\n            audio_driver_state_t\n               *audio_st              = audio_state_get_ptr();\n            input_driver_state_t\n               *input_st              = input_state_get_ptr();\n            bool *userdata            = (bool*)data;\n            bool video_fullscreen     = settings->bools.video_fullscreen;\n            bool ra_is_forced_fs      = (video_st->flags &\n               VIDEO_FLAG_FORCE_FULLSCREEN) ? true : false;\n            bool new_fullscreen_state = !video_fullscreen && !ra_is_forced_fs;\n\n            if (!video_driver_has_windowed())\n               return false;\n\n            audio_st->flags |= AUDIO_FLAG_SUSPENDED;\n            video_st->flags |= VIDEO_FLAG_IS_SWITCHING_DISPLAY_MODE;\n\n            /* we toggled manually, write the new value to settings */\n            configuration_set_bool(settings, settings->bools.video_fullscreen,\n                  new_fullscreen_state);\n            /* Need to grab this setting's value again */\n            video_fullscreen = new_fullscreen_state;\n\n            /* we toggled manually, the CLI arg is irrelevant now */\n            if (ra_is_forced_fs)\n               video_st->flags &= ~VIDEO_FLAG_FORCE_FULLSCREEN;\n\n            /* If we go fullscreen we drop all drivers and\n             * reinitialize to be safe. */\n            command_event(CMD_EVENT_REINIT, NULL);\n            if (video_fullscreen)\n            {\n               if (     video_st->poke\n                     && video_st->poke->show_mouse)\n                  video_st->poke->show_mouse(video_st->data, false);\n               if (!settings->bools.video_windowed_fullscreen)\n                  if (input_driver_grab_mouse())\n                     input_st->flags |= INP_FLAG_GRAB_MOUSE_STATE;\n            }\n            else\n            {\n               if (     video_st->poke\n                     && video_st->poke->show_mouse)\n                  video_st->poke->show_mouse(video_st->data, true);\n               if (!settings->bools.video_windowed_fullscreen)\n                  if (input_driver_ungrab_mouse())\n                     input_st->flags &= ~INP_FLAG_GRAB_MOUSE_STATE;\n            }\n#ifdef HAVE_OVERLAY\n            input_overlay_check_mouse_cursor();\n#endif\n\n            video_st->flags &= ~VIDEO_FLAG_IS_SWITCHING_DISPLAY_MODE;\n            audio_st->flags &= ~AUDIO_FLAG_SUSPENDED;\n\n            if (userdata && *userdata == true)\n               video_driver_cached_frame();\n         }\n         break;\n      case CMD_EVENT_DISK_APPEND_IMAGE:\n         {\n            const char *path              = (const char*)data;\n            rarch_system_info_t *sys_info = &runloop_st->system;\n\n            if (string_is_empty(path) || !sys_info)\n               return false;\n\n            if (disk_control_enabled(&sys_info->disk_control))\n            {\n#if defined(HAVE_MENU)\n               struct menu_state *menu_st = menu_state_get_ptr();\n               /* Get initial disk eject state */\n               bool initial_disk_ejected  = disk_control_get_eject_state(&sys_info->disk_control);\n#endif\n               /* Append disk image */\n               bool success               =\n                  command_event_disk_control_append_image(path);\n\n#if defined(HAVE_MENU)\n               /* Appending a disk image may or may not affect\n                * the disk tray eject status. If status has changed,\n                * must refresh the disk options menu */\n               if (initial_disk_ejected != disk_control_get_eject_state(\n                     &sys_info->disk_control))\n                  menu_st->flags                 |=  MENU_ST_FLAG_ENTRIES_NEED_REFRESH\n                                                  |  MENU_ST_FLAG_PREVENT_POPULATE;\n#endif\n               return success;\n            }\n            else\n            {\n               const char *_msg = msg_hash_to_str(MSG_CORE_DOES_NOT_SUPPORT_DISK_OPTIONS);\n               runloop_msg_queue_push(_msg, strlen(_msg), 1, 120, true, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n            }\n         }\n         break;\n      case CMD_EVENT_DISK_EJECT_TOGGLE:\n         {\n            rarch_system_info_t *sys_info = &runloop_st->system;\n\n            if (!sys_info)\n               return false;\n\n            if (disk_control_enabled(&sys_info->disk_control))\n            {\n               bool *show_msg                  = (bool*)data;\n               bool eject                      = !disk_control_get_eject_state(\n                                                  &sys_info->disk_control);\n               bool verbose                    = true;\n#if defined(HAVE_MENU)\n               struct menu_state *menu_st      = menu_state_get_ptr();\n#endif\n\n               if (show_msg)\n                  verbose                      = *show_msg;\n\n               if (!settings->bools.notification_show_disk_control)\n                  verbose                      = false;\n\n               disk_control_set_eject_state(\n                     &sys_info->disk_control, eject, verbose);\n\n#if defined(HAVE_MENU)\n               /* It is necessary to refresh the disk options\n                * menu when toggling the tray state */\n               menu_st->flags                 |=  MENU_ST_FLAG_ENTRIES_NEED_REFRESH\n                                               |  MENU_ST_FLAG_PREVENT_POPULATE;\n#endif\n            }\n            else\n            {\n               const char *_msg = msg_hash_to_str(MSG_CORE_DOES_NOT_SUPPORT_DISK_OPTIONS);\n               runloop_msg_queue_push(_msg, strlen(_msg), 1, 120, true, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n            }\n         }\n         break;\n      case CMD_EVENT_DISK_NEXT:\n         {\n            rarch_system_info_t *sys_info = &runloop_st->system;\n\n            if (!sys_info)\n               return false;\n\n            if (disk_control_enabled(&sys_info->disk_control))\n            {\n               bool *show_msg = (bool*)data;\n               bool verbose   = true;\n\n               if (show_msg)\n                  verbose     = *show_msg;\n\n               if (!settings->bools.notification_show_disk_control)\n                  verbose     = false;\n\n               disk_control_set_index_next(&sys_info->disk_control, verbose);\n            }\n            else\n            {\n               const char *_msg = msg_hash_to_str(MSG_CORE_DOES_NOT_SUPPORT_DISK_OPTIONS);\n               runloop_msg_queue_push(_msg, strlen(_msg), 1, 120, true, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n            }\n         }\n         break;\n      case CMD_EVENT_DISK_PREV:\n         {\n            rarch_system_info_t *sys_info = &runloop_st->system;\n\n            if (!sys_info)\n               return false;\n\n            if (disk_control_enabled(&sys_info->disk_control))\n            {\n               bool *show_msg = (bool*)data;\n               bool verbose   = true;\n\n               if (show_msg)\n                  verbose     = *show_msg;\n\n               if (!settings->bools.notification_show_disk_control)\n                  verbose     = false;\n\n               disk_control_set_index_prev(&sys_info->disk_control, verbose);\n            }\n            else\n            {\n               const char *_msg = msg_hash_to_str(MSG_CORE_DOES_NOT_SUPPORT_DISK_OPTIONS);\n               runloop_msg_queue_push(_msg, strlen(_msg), 1, 120, true, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n            }\n         }\n         break;\n      case CMD_EVENT_DISK_INDEX:\n         {\n            rarch_system_info_t *sys_info = &runloop_st->system;\n            unsigned *index               = (unsigned*)data;\n\n            if (!sys_info || !index)\n               return false;\n\n            /* Note: Menu itself provides visual feedback - no\n             * need to print info message to screen */\n            if (disk_control_enabled(&sys_info->disk_control))\n               disk_control_set_index(&sys_info->disk_control, *index, false);\n            else\n            {\n               const char *_msg = msg_hash_to_str(MSG_CORE_DOES_NOT_SUPPORT_DISK_OPTIONS);\n               runloop_msg_queue_push(_msg, strlen(_msg), 1, 120, true, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n            }\n         }\n         break;\n      case CMD_EVENT_RUMBLE_STOP:\n         {\n            unsigned i;\n\n            for (i = 0; i < MAX_USERS; i++)\n            {\n               unsigned joy_idx = settings->uints.input_joypad_index[i];\n               input_driver_set_rumble(i, joy_idx, RETRO_RUMBLE_STRONG, 0);\n               input_driver_set_rumble(i, joy_idx, RETRO_RUMBLE_WEAK, 0);\n            }\n         }\n         break;\n      case CMD_EVENT_GRAB_MOUSE_TOGGLE:\n         {\n            bool ret              = false;\n            input_driver_state_t\n               *input_st          = input_state_get_ptr();\n            bool grab_mouse_state = !(input_st->flags &\n                  INP_FLAG_GRAB_MOUSE_STATE);\n\n            if (grab_mouse_state)\n            {\n               if ((ret = input_driver_grab_mouse()))\n                  input_st->flags |= INP_FLAG_GRAB_MOUSE_STATE;\n            }\n            else\n            {\n               if ((ret = input_driver_ungrab_mouse()))\n                  input_st->flags &= ~INP_FLAG_GRAB_MOUSE_STATE;\n            }\n\n            if (!ret)\n               return false;\n\n            RARCH_LOG(\"[Input]: %s => %s\\n\",\n                  msg_hash_to_str(MSG_GRAB_MOUSE_STATE),\n                  grab_mouse_state ? \"ON\" : \"OFF\");\n\n            if (grab_mouse_state)\n            {\n               if (     video_st->poke\n                     && video_st->poke->show_mouse)\n                  video_st->poke->show_mouse(video_st->data, false);\n            }\n            else\n            {\n               if (     video_st->poke\n                     && video_st->poke->show_mouse)\n                  video_st->poke->show_mouse(video_st->data, true);\n            }\n         }\n         break;\n      case CMD_EVENT_UI_COMPANION_TOGGLE:\n         {\n#ifdef HAVE_QT\n            bool desktop_menu_enable = settings->bools.desktop_menu_enable;\n            bool ui_companion_toggle = settings->bools.ui_companion_toggle;\n#else\n            bool desktop_menu_enable = false;\n            bool ui_companion_toggle = false;\n#endif\n            ui_companion_driver_toggle(desktop_menu_enable,\n                  ui_companion_toggle, true);\n         }\n         break;\n      case CMD_EVENT_GAME_FOCUS_TOGGLE:\n         {\n            bool video_fullscreen                         =\n                  settings->bools.video_fullscreen\n               || (video_st->flags & VIDEO_FLAG_FORCE_FULLSCREEN);\n            enum input_game_focus_cmd_type game_focus_cmd = GAME_FOCUS_CMD_TOGGLE;\n            input_driver_state_t\n               *input_st                                  = input_state_get_ptr();\n            bool current_enable_state                     = input_st->game_focus_state.enabled;\n            bool apply_update                             = false;\n            bool show_message                             = false;\n\n            if (data)\n               game_focus_cmd = *((enum input_game_focus_cmd_type*)data);\n\n            switch (game_focus_cmd)\n            {\n               case GAME_FOCUS_CMD_OFF:\n                  /* Force game focus off */\n                  input_st->game_focus_state.enabled = false;\n                  if (input_st->game_focus_state.enabled != current_enable_state)\n                  {\n                     apply_update = true;\n                     show_message = true;\n                  }\n                  break;\n               case GAME_FOCUS_CMD_ON:\n                  /* Force game focus on */\n                  input_st->game_focus_state.enabled = true;\n                  if (input_st->game_focus_state.enabled != current_enable_state)\n                  {\n                     apply_update = true;\n                     show_message = true;\n                  }\n                  break;\n               case GAME_FOCUS_CMD_TOGGLE:\n                  /* Invert current game focus state */\n                  input_st->game_focus_state.enabled = !input_st->game_focus_state.enabled;\n#ifdef HAVE_MENU\n                  /* If menu is currently active, disable\n                   * 'toggle on' functionality */\n                  if (menu_st->flags & MENU_ST_FLAG_ALIVE)\n                     input_st->game_focus_state.enabled = false;\n#endif\n                  if (input_st->game_focus_state.enabled != current_enable_state)\n                  {\n                     apply_update = true;\n                     show_message = true;\n                  }\n                  break;\n               case GAME_FOCUS_CMD_REAPPLY:\n                  /* Reapply current game focus state */\n                  apply_update = true;\n                  show_message = false;\n                  break;\n               default:\n                  break;\n            }\n\n            if (apply_update)\n            {\n               input_driver_state_t\n                  *input_st          = input_state_get_ptr();\n\n               if (input_st->game_focus_state.enabled)\n               {\n                  if (input_driver_grab_mouse())\n                     input_st->flags |= INP_FLAG_GRAB_MOUSE_STATE;\n                  if (     video_st->poke\n                        && video_st->poke->show_mouse)\n                     video_st->poke->show_mouse(video_st->data, false);\n               }\n               /* Ungrab only if windowed and auto mouse grab is disabled */\n               else if (!video_fullscreen\n                     && !settings->bools.input_auto_mouse_grab)\n               {\n                  if (input_driver_ungrab_mouse())\n                     input_st->flags &= ~INP_FLAG_GRAB_MOUSE_STATE;\n                  if (     video_st->poke\n                        && video_st->poke->show_mouse)\n                     video_st->poke->show_mouse(video_st->data, true);\n               }\n\n               if (input_st->game_focus_state.enabled)\n                  input_st->flags |=  INP_FLAG_BLOCK_HOTKEY\n                                   |  INP_FLAG_KB_MAPPING_BLOCKED;\n               else\n                  input_st->flags &= ~(INP_FLAG_BLOCK_HOTKEY\n                                     | INP_FLAG_KB_MAPPING_BLOCKED);\n\n               if (show_message)\n               {\n                  const char *_msg =\n                        input_st->game_focus_state.enabled ?\n                        msg_hash_to_str(MSG_GAME_FOCUS_ON) :\n                        msg_hash_to_str(MSG_GAME_FOCUS_OFF);\n\n                  runloop_msg_queue_push(_msg, strlen(_msg), 1, 60, true, NULL,\n                        MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n               }\n\n               RARCH_LOG(\"[Input]: %s => %s\\n\",\n                     \"Game Focus\",\n                     input_st->game_focus_state.enabled ? \"ON\" : \"OFF\");\n            }\n         }\n         break;\n      case CMD_EVENT_VOLUME_UP:\n         {\n            audio_driver_state_t\n               *audio_st              = audio_state_get_ptr();\n            command_event_set_volume(settings, 0.5f,\n#if defined(HAVE_GFX_WIDGETS)\n                  dispwidget_get_ptr()->active,\n#else\n                  false,\n#endif\n                  audio_st->mute_enable);\n         }\n         break;\n      case CMD_EVENT_VOLUME_DOWN:\n         command_event_set_volume(settings, -0.5f,\n#if defined(HAVE_GFX_WIDGETS)\n               dispwidget_get_ptr()->active,\n#else\n               false,\n#endif\n               audio_state_get_ptr()->mute_enable\n               );\n         break;\n      case CMD_EVENT_MIXER_VOLUME_UP:\n         command_event_set_mixer_volume(settings, 0.5f);\n         break;\n      case CMD_EVENT_MIXER_VOLUME_DOWN:\n         command_event_set_mixer_volume(settings, -0.5f);\n         break;\n      case CMD_EVENT_SET_FRAME_LIMIT:\n         {\n            video_driver_state_t\n               *video_st                        = video_state_get_ptr();\n            runloop_set_frame_limit(&video_st->av_info,\n                  runloop_get_fastforward_ratio(\n                     settings,\n                     &runloop_st->fastmotion_override.current));\n         }\n         break;\n      case CMD_EVENT_DISCORD_INIT:\n#ifdef HAVE_DISCORD\n         {\n            bool discord_enable         = settings ? settings->bools.discord_enable : false;\n            const char *discord_app_id  = settings ? settings->arrays.discord_app_id : NULL;\n            discord_state_t *discord_st = discord_state_get_ptr();\n            if (!settings)\n               return false;\n            if (!discord_enable)\n               return false;\n            if (!discord_st->ready)\n               discord_init(discord_app_id, p_rarch->launch_arguments);\n         }\n#endif\n         break;\n      case CMD_EVENT_PRESENCE_UPDATE:\n         {\n#ifdef HAVE_PRESENCE\n            presence_userdata_t *userdata = NULL;\n            if (!data)\n               return false;\n\n            userdata = (presence_userdata_t*)data;\n            presence_update(userdata->status);\n#endif\n         }\n         break;\n\n      case CMD_EVENT_AI_SERVICE_CALL:\n         {\n#ifdef HAVE_TRANSLATE\n#ifdef HAVE_ACCESSIBILITY\n            bool accessibility_enable = settings->bools.accessibility_enable;\n            unsigned accessibility_narrator_speech_speed = settings->uints.accessibility_narrator_speech_speed;\n#endif\n            unsigned ai_service_mode  = settings->uints.ai_service_mode;\n\n#ifdef HAVE_AUDIOMIXER\n            if (    (ai_service_mode == 1)\n                  && audio_driver_is_ai_service_speech_running())\n            {\n               audio_driver_mixer_stop_stream(10);\n               audio_driver_mixer_remove_stream(10);\n#ifdef HAVE_ACCESSIBILITY\n               if (is_accessibility_enabled(\n                        accessibility_enable,\n                        access_st->enabled))\n                  accessibility_speak_priority(\n                        accessibility_enable,\n                        accessibility_narrator_speech_speed,\n                        (char*)msg_hash_to_str(MSG_AI_SERVICE_STOPPED),\n                        10);\n#endif\n            }\n            else\n#endif\n#ifdef HAVE_ACCESSIBILITY\n            if (is_accessibility_enabled(\n                     accessibility_enable,\n                     access_st->enabled)\n                  && (ai_service_mode == 2)\n                  && is_narrator_running(accessibility_enable))\n               accessibility_speak_priority(\n                     accessibility_enable,\n                     accessibility_narrator_speech_speed,\n                     (char*)msg_hash_to_str(MSG_AI_SERVICE_STOPPED),\n                     10);\n            else\n#endif\n            {\n               bool paused = (runloop_st->flags & RUNLOOP_FLAG_PAUSED) ? true : false;\n               if (data)\n                  paused = *((bool*)data);\n               if (     (access_st->ai_service_auto == 0)\n                     && !settings->bools.ai_service_pause)\n                  access_st->ai_service_auto = 1;\n               run_translation_service(settings, paused);\n            }\n#endif\n            break;\n         }\n      case CMD_EVENT_CONTROLLER_INIT:\n         {\n            rarch_system_info_t *sys_info = &runloop_st->system;\n            if (sys_info)\n               command_event_init_controllers(sys_info, settings,\n                     settings->uints.input_max_users);\n         }\n         break;\n      case CMD_EVENT_VRR_RUNLOOP_TOGGLE:\n         {\n            const char *_msg = msg_hash_to_str(\n                     settings->bools.vrr_runloop_enable ? MSG_VRR_RUNLOOP_ENABLED\n                     : MSG_VRR_RUNLOOP_DISABLED);\n            settings->bools.vrr_runloop_enable = !(settings->bools.vrr_runloop_enable);\n            runloop_msg_queue_push(_msg, strlen(_msg), 1, 100, false, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n         }\n         break;\n      case CMD_EVENT_NONE:\n         return false;\n\n      /* Deprecated */\n      case CMD_EVENT_SEND_DEBUG_INFO:\n         break;\n   }\n\n   return true;\n}\n\n/* FRONTEND */\n\nvoid retroarch_override_setting_set(\n      enum rarch_override_setting enum_idx, void *data)\n{\n   struct rarch_state            *p_rarch = &rarch_st;\n#ifdef HAVE_NETWORKING\n   net_driver_state_t *net_st  = networking_state_get_ptr();\n#endif\n\n   switch (enum_idx)\n   {\n      case RARCH_OVERRIDE_SETTING_LIBRETRO_DEVICE:\n         {\n            unsigned *val = (unsigned*)data;\n            if (val)\n            {\n               unsigned                bit = *val;\n               runloop_state_t *runloop_st = runloop_state_get_ptr();\n               BIT256_SET(runloop_st->has_set_libretro_device, bit);\n            }\n         }\n         break;\n      case RARCH_OVERRIDE_SETTING_VERBOSITY:\n         p_rarch->flags |= RARCH_FLAGS_HAS_SET_VERBOSITY;\n         break;\n      case RARCH_OVERRIDE_SETTING_LIBRETRO:\n         p_rarch->flags |= RARCH_FLAGS_HAS_SET_LIBRETRO;\n         break;\n      case RARCH_OVERRIDE_SETTING_LIBRETRO_DIRECTORY:\n         p_rarch->flags |= RARCH_FLAGS_HAS_SET_LIBRETRO_DIRECTORY;\n         break;\n      case RARCH_OVERRIDE_SETTING_SAVE_PATH:\n         p_rarch->flags |= RARCH_FLAGS_HAS_SET_SAVE_PATH;\n         break;\n      case RARCH_OVERRIDE_SETTING_STATE_PATH:\n         p_rarch->flags |= RARCH_FLAGS_HAS_SET_STATE_PATH;\n         break;\n#ifdef HAVE_NETWORKING\n     case RARCH_OVERRIDE_SETTING_NETPLAY_MODE:\n         net_st->flags |= NET_DRIVER_ST_FLAG_HAS_SET_NETPLAY_MODE;\n         break;\n      case RARCH_OVERRIDE_SETTING_NETPLAY_IP_ADDRESS:\n         net_st->flags |= NET_DRIVER_ST_FLAG_HAS_SET_NETPLAY_IP_ADDRESS;\n         break;\n      case RARCH_OVERRIDE_SETTING_NETPLAY_IP_PORT:\n         net_st->flags |= NET_DRIVER_ST_FLAG_HAS_SET_NETPLAY_IP_PORT;\n         break;\n      case RARCH_OVERRIDE_SETTING_NETPLAY_CHECK_FRAMES:\n         net_st->flags |= NET_DRIVER_ST_FLAG_HAS_SET_NETPLAY_CHECK_FRAMES;\n         break;\n#endif\n      case RARCH_OVERRIDE_SETTING_UPS_PREF:\n#ifdef HAVE_PATCH\n         p_rarch->flags |= RARCH_FLAGS_HAS_SET_UPS_PREF;\n#endif\n         break;\n      case RARCH_OVERRIDE_SETTING_BPS_PREF:\n#ifdef HAVE_PATCH\n         p_rarch->flags |= RARCH_FLAGS_HAS_SET_BPS_PREF;\n#endif\n         break;\n      case RARCH_OVERRIDE_SETTING_IPS_PREF:\n#ifdef HAVE_PATCH\n         p_rarch->flags |= RARCH_FLAGS_HAS_SET_IPS_PREF;\n#endif\n         break;\n       case RARCH_OVERRIDE_SETTING_XDELTA_PREF:\n#if defined(HAVE_PATCH) && defined(HAVE_XDELTA)\n           p_rarch->flags |= RARCH_FLAGS_HAS_SET_XDELTA_PREF;\n#endif\n           break;\n      case RARCH_OVERRIDE_SETTING_LOG_TO_FILE:\n         p_rarch->flags |= RARCH_FLAGS_HAS_SET_LOG_TO_FILE;\n         break;\n      case RARCH_OVERRIDE_SETTING_DATABASE_SCAN:\n         p_rarch->flags |= RARCH_FLAGS_CLI_DATABASE_SCAN;\n         break;\n      case RARCH_OVERRIDE_SETTING_OVERLAY_PRESET:\n         p_rarch->flags |= RARCH_FLAGS_HAS_SET_OVERLAY_PRESET;\n         break;\n      case RARCH_OVERRIDE_SETTING_NONE:\n      default:\n         break;\n   }\n}\n\nvoid retroarch_override_setting_unset(\n      enum rarch_override_setting enum_idx, void *data)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n#ifdef HAVE_NETWORKING\n   net_driver_state_t *net_st  = networking_state_get_ptr();\n#endif\n\n   switch (enum_idx)\n   {\n      case RARCH_OVERRIDE_SETTING_LIBRETRO_DEVICE:\n         {\n            unsigned *val = (unsigned*)data;\n            if (val)\n            {\n               unsigned                bit = *val;\n               runloop_state_t *runloop_st = runloop_state_get_ptr();\n               BIT256_CLEAR(runloop_st->has_set_libretro_device, bit);\n            }\n         }\n         break;\n      case RARCH_OVERRIDE_SETTING_VERBOSITY:\n         p_rarch->flags &= ~RARCH_FLAGS_HAS_SET_VERBOSITY;\n         break;\n      case RARCH_OVERRIDE_SETTING_LIBRETRO:\n         p_rarch->flags &= ~RARCH_FLAGS_HAS_SET_LIBRETRO;\n         break;\n      case RARCH_OVERRIDE_SETTING_LIBRETRO_DIRECTORY:\n         p_rarch->flags &= ~RARCH_FLAGS_HAS_SET_LIBRETRO_DIRECTORY;\n         break;\n      case RARCH_OVERRIDE_SETTING_SAVE_PATH:\n         p_rarch->flags &= ~RARCH_FLAGS_HAS_SET_SAVE_PATH;\n         break;\n      case RARCH_OVERRIDE_SETTING_STATE_PATH:\n         p_rarch->flags &= ~RARCH_FLAGS_HAS_SET_STATE_PATH;\n         break;\n#ifdef HAVE_NETWORKING\n    case RARCH_OVERRIDE_SETTING_NETPLAY_MODE:\n         net_st->flags &= ~NET_DRIVER_ST_FLAG_HAS_SET_NETPLAY_MODE;\n         break;\n      case RARCH_OVERRIDE_SETTING_NETPLAY_IP_ADDRESS:\n         net_st->flags &= ~NET_DRIVER_ST_FLAG_HAS_SET_NETPLAY_IP_ADDRESS;\n         break;\n      case RARCH_OVERRIDE_SETTING_NETPLAY_IP_PORT:\n         net_st->flags &= ~NET_DRIVER_ST_FLAG_HAS_SET_NETPLAY_IP_PORT;\n         break;\n      case RARCH_OVERRIDE_SETTING_NETPLAY_CHECK_FRAMES:\n         net_st->flags &= ~NET_DRIVER_ST_FLAG_HAS_SET_NETPLAY_CHECK_FRAMES;\n         break;\n#endif\n      case RARCH_OVERRIDE_SETTING_UPS_PREF:\n#ifdef HAVE_PATCH\n         p_rarch->flags &= ~RARCH_FLAGS_HAS_SET_UPS_PREF;\n#endif\n         break;\n      case RARCH_OVERRIDE_SETTING_BPS_PREF:\n#ifdef HAVE_PATCH\n         p_rarch->flags &= ~RARCH_FLAGS_HAS_SET_BPS_PREF;\n#endif\n         break;\n      case RARCH_OVERRIDE_SETTING_IPS_PREF:\n#ifdef HAVE_PATCH\n         p_rarch->flags &= ~RARCH_FLAGS_HAS_SET_IPS_PREF;\n#endif\n         break;\n       case RARCH_OVERRIDE_SETTING_XDELTA_PREF:\n#if defined(HAVE_PATCH) && defined(HAVE_XDELTA)\n           p_rarch->flags &= ~RARCH_FLAGS_HAS_SET_XDELTA_PREF;\n#endif\n         break;\n      case RARCH_OVERRIDE_SETTING_LOG_TO_FILE:\n         p_rarch->flags &= ~RARCH_FLAGS_HAS_SET_LOG_TO_FILE;\n         break;\n      case RARCH_OVERRIDE_SETTING_DATABASE_SCAN:\n         p_rarch->flags &= ~RARCH_FLAGS_CLI_DATABASE_SCAN;\n         break;\n      case RARCH_OVERRIDE_SETTING_OVERLAY_PRESET:\n         p_rarch->flags &= ~RARCH_FLAGS_HAS_SET_OVERLAY_PRESET;\n         break;\n      case RARCH_OVERRIDE_SETTING_NONE:\n      default:\n         break;\n   }\n}\n\nstatic void retroarch_override_setting_free_state(void)\n{\n   unsigned i;\n   for (i = 0; i < RARCH_OVERRIDE_SETTING_LAST; i++)\n   {\n      if (i == RARCH_OVERRIDE_SETTING_LIBRETRO_DEVICE)\n      {\n         unsigned j;\n         for (j = 0; j < MAX_USERS; j++)\n            retroarch_override_setting_unset(\n                  RARCH_OVERRIDE_SETTING_LIBRETRO_DEVICE, &j);\n      }\n      else\n         retroarch_override_setting_unset(\n               (enum rarch_override_setting)(i), NULL);\n   }\n}\n\nstatic void global_free(struct rarch_state *p_rarch)\n{\n   global_t            *global = NULL;\n   runloop_state_t *runloop_st = runloop_state_get_ptr();\n\n   content_deinit();\n\n   runloop_path_deinit_subsystem();\n   command_event(CMD_EVENT_RECORD_DEINIT, NULL);\n\n   retro_main_log_file_deinit();\n\n   runloop_st->flags &= ~(\n                          RUNLOOP_FLAG_IS_SRAM_LOAD_DISABLED\n                        | RUNLOOP_FLAG_IS_SRAM_SAVE_DISABLED\n                        | RUNLOOP_FLAG_USE_SRAM);\n#ifdef HAVE_PATCH\n   p_rarch->flags    &= ~(\n                         RARCH_FLAGS_BPS_PREF\n                       | RARCH_FLAGS_IPS_PREF\n                       | RARCH_FLAGS_UPS_PREF\n                       | RARCH_FLAGS_XDELTA_PREF);\n   runloop_st->flags &= ~RUNLOOP_FLAG_PATCH_BLOCKED;\n\n#endif\n#ifdef HAVE_CONFIGFILE\n   p_rarch->flags    &= ~RARCH_FLAGS_BLOCK_CONFIG_READ;\n   runloop_st->flags &= ~(RUNLOOP_FLAG_OVERRIDES_ACTIVE\n                        | RUNLOOP_FLAG_REMAPS_CORE_ACTIVE\n                        | RUNLOOP_FLAG_REMAPS_GAME_ACTIVE\n                        | RUNLOOP_FLAG_REMAPS_CONTENT_DIR_ACTIVE);\n#endif\n\n   runloop_st->current_core.flags &= ~(RETRO_CORE_FLAG_HAS_SET_INPUT_DESCRIPTORS\n                                     | RETRO_CORE_FLAG_HAS_SET_SUBSYSTEMS);\n\n   global                                = global_get_ptr();\n   path_clear_all();\n   dir_clear_all();\n\n   if (!string_is_empty(runloop_st->name.remapfile))\n      free(runloop_st->name.remapfile);\n   runloop_st->name.remapfile = NULL;\n   *runloop_st->name.ups                 = '\\0';\n   *runloop_st->name.bps                 = '\\0';\n   *runloop_st->name.ips                 = '\\0';\n   *runloop_st->name.xdelta              = '\\0';\n   *runloop_st->name.savefile            = '\\0';\n   *runloop_st->name.savestate           = '\\0';\n   *runloop_st->name.replay              = '\\0';\n   *runloop_st->name.cheatfile           = '\\0';\n   *runloop_st->name.label               = '\\0';\n\n   if (global)\n      memset(global, 0, sizeof(struct global));\n   retroarch_override_setting_free_state();\n}\n\n#if defined(HAVE_SDL) || defined(HAVE_SDL2) || defined(HAVE_SDL_DINGUX)\nstatic void sdl_exit(void)\n{\n   /* Quit any SDL subsystems, then quit\n    * SDL itself */\n   uint32_t sdl_subsystem_flags = SDL_WasInit(0);\n\n   if (sdl_subsystem_flags != 0)\n   {\n      SDL_QuitSubSystem(sdl_subsystem_flags);\n      SDL_Quit();\n   }\n}\n#endif\n\n/**\n * main_exit:\n *\n * Cleanly exit RetroArch.\n *\n **/\nvoid main_exit(void *args)\n{\n   struct rarch_state *p_rarch  = &rarch_st;\n   runloop_state_t *runloop_st  = runloop_state_get_ptr();\n#ifdef HAVE_MENU\n   struct menu_state  *menu_st  = menu_state_get_ptr();\n#endif\n   settings_t     *settings     = config_get_ptr();\n\n   video_driver_restore_cached(settings);\n\n#if defined(HAVE_GFX_WIDGETS)\n   /* Do not want display widgets to live any more. */\n   dispwidget_get_ptr()->flags &= ~DISPGFX_WIDGET_FLAG_PERSISTING;\n#endif\n#ifdef HAVE_MENU\n   /* Do not want menu context to live any more. */\n   if (menu_st)\n      menu_st->flags &= ~MENU_ST_FLAG_DATA_OWN;\n#endif\n   retroarch_ctl(RARCH_CTL_MAIN_DEINIT, NULL);\n\n   if (runloop_st->perfcnt_enable)\n   {\n      RARCH_LOG(\"[PERF]: Performance counters (RetroArch):\\n\");\n      runloop_log_counters(p_rarch->perf_counters_rarch, p_rarch->perf_ptr_rarch);\n   }\n\n#if defined(HAVE_LOGGER) && !defined(ANDROID)\n   logger_shutdown();\n#endif\n#ifdef PS2\n   /* PS2 frontend driver deinit also detaches filesystem,\n    * so make sure logs are written in advance. */\n   retro_main_log_file_deinit();\n#endif\n   frontend_driver_deinit(args);\n   frontend_driver_exitspawn(\n         p_rarch->path_libretro,\n         sizeof(p_rarch->path_libretro),\n         p_rarch->launch_arguments);\n\n   p_rarch->flags                  &= ~RARCH_FLAGS_HAS_SET_USERNAME;\n   runloop_st->flags               &= ~RUNLOOP_FLAG_IS_INITED;\n   global_get_ptr()->flags         &= ~GLOB_FLG_ERR_ON_INIT;\n#ifdef HAVE_CONFIGFILE\n   p_rarch->flags                  &= ~RARCH_FLAGS_BLOCK_CONFIG_READ;\n#endif\n\n   runloop_msg_queue_deinit();\n   driver_uninit(DRIVERS_CMD_ALL, (enum driver_lifetime_flags)0);\n\n   retro_main_log_file_deinit();\n\n   retroarch_ctl(RARCH_CTL_STATE_FREE,  NULL);\n   global_free(p_rarch);\n   task_queue_deinit();\n\n   ui_companion_driver_deinit();\n   retroarch_config_deinit();\n\n   frontend_driver_shutdown(false);\n\n   retroarch_deinit_drivers(&runloop_st->retro_ctx);\n   uico_state_get_ptr()->drv = NULL;\n   frontend_driver_free();\n\n   rtime_deinit();\n\n#if defined(ANDROID)\n   play_feature_delivery_deinit();\n#endif\n\n#if defined(HAVE_MIST)\n   steam_deinit();\n#endif\n\n#if defined(_WIN32) && !defined(_XBOX) && !defined(__WINRT__)\n   CoUninitialize();\n#endif\n\n#if defined(HAVE_SDL) || defined(HAVE_SDL2) || defined(HAVE_SDL_DINGUX)\n   sdl_exit();\n#endif\n}\n\n/**\n * main_entry:\n *\n * Main function of RetroArch.\n *\n * If HAVE_MAIN is not defined, will contain main loop and will not\n * be exited from until we exit the program. Otherwise, will\n * just do initialization.\n *\n * Returns: varies per platform.\n **/\nint rarch_main(int argc, char *argv[], void *data)\n{\n   struct rarch_state *p_rarch         = &rarch_st;\n   runloop_state_t *runloop_st         = runloop_state_get_ptr();\n   video_driver_state_t *video_st      = video_state_get_ptr();\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n   video_st->flags   |= VIDEO_FLAG_SHADER_PRESETS_NEED_RELOAD;\n#endif\n#ifdef HAVE_RUNAHEAD\n   video_st->flags   |= VIDEO_FLAG_RUNAHEAD_IS_ACTIVE;\n   runloop_st->flags |= (\n                         RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE\n                      |  RUNLOOP_FLAG_RUNAHEAD_AVAILABLE\n                      |  RUNLOOP_FLAG_RUNAHEAD_FORCE_INPUT_DIRTY\n                        );\n#endif\n#if defined(_WIN32) && !defined(_XBOX) && !defined(__WINRT__)\n   if (FAILED(CoInitialize(NULL)))\n   {\n      RARCH_ERR(\"FATAL: Failed to initialize the COM interface\\n\");\n      return 1;\n   }\n#endif\n\n   rtime_init();\n\n#if defined(ANDROID)\n   play_feature_delivery_init();\n#endif\n\n#if defined(HAVE_MIST)\n   steam_init();\n#endif\n\n   libretro_free_system_info(&runloop_st->system.info);\n   command_event(CMD_EVENT_HISTORY_DEINIT, NULL);\n   retroarch_favorites_deinit();\n\n   retroarch_config_init();\n\n   retroarch_deinit_drivers(&runloop_st->retro_ctx);\n   retroarch_ctl(RARCH_CTL_STATE_FREE,  NULL);\n   global_free(p_rarch);\n\n   frontend_driver_init_first(data);\n\n   if (runloop_st->flags & RUNLOOP_FLAG_IS_INITED)\n      driver_uninit(DRIVERS_CMD_ALL, (enum driver_lifetime_flags)0);\n\n#ifdef HAVE_THREAD_STORAGE\n   sthread_tls_create(&p_rarch->rarch_tls);\n   sthread_tls_set(&p_rarch->rarch_tls, MAGIC_POINTER);\n#endif\n   video_st->flags              |= VIDEO_FLAG_ACTIVE;\n   audio_state_get_ptr()->flags |= AUDIO_FLAG_ACTIVE;\n\n   {\n      int i;\n      for (i = 0; i < MAX_USERS; i++)\n         input_config_set_device(i, RETRO_DEVICE_JOYPAD);\n   }\n\n   runloop_msg_queue_init();\n\n   if (frontend_state_get_ptr()->current_frontend_ctx)\n   {\n      content_ctx_info_t info;\n\n      info.argc            = argc;\n      info.argv            = argv;\n      info.args            = data;\n      info.environ_get     = frontend_state_get_ptr()->current_frontend_ctx->environment_get;\n\n      if (!task_push_load_content_from_cli(\n               NULL,\n               NULL,\n               &info,\n               CORE_TYPE_PLAIN,\n               NULL,\n               NULL))\n         return 1;\n   }\n\n   ui_companion_driver_init_first();\n#if HAVE_CLOUDSYNC\n   task_push_cloud_sync();\n#endif\n#if !defined(HAVE_MAIN) || defined(HAVE_QT)\n   for (;;)\n   {\n      int ret;\n      bool app_exit     = false;\n#ifdef HAVE_QT\n      ui_companion_qt.application->process_events();\n#endif\n      ret = runloop_iterate();\n\n      task_queue_check();\n\n#ifdef HAVE_MIST\n   steam_poll();\n#endif\n\n#ifdef HAVE_QT\n      app_exit = ui_companion_qt.application->exiting;\n#endif\n\n      if (ret == -1 || app_exit)\n      {\n#ifdef HAVE_QT\n         ui_companion_qt.application->quit();\n#endif\n         break;\n      }\n   }\n\n   main_exit(data);\n#endif\n\n   return 0;\n}\n\n#if defined(EMSCRIPTEN)\n#include \"gfx/common/gl_common.h\"\n\n#ifdef HAVE_RWEBAUDIO\nvoid RWebAudioRecalibrateTime(void);\n#endif\n\nvoid emscripten_mainloop(void)\n{\n   int ret;\n   static unsigned emscripten_frame_count = 0;\n   video_driver_state_t *video_st         = video_state_get_ptr();\n   settings_t        *settings            = config_get_ptr();\n   input_driver_state_t *input_st         = input_state_get_ptr();\n   bool black_frame_insertion             = settings->uints.video_black_frame_insertion;\n   bool input_driver_nonblock_state       = input_st ?\n      (input_st->flags & INP_FLAG_NONBLOCKING) : false;\n   uint32_t runloop_flags                 = runloop_get_flags();\n   bool runloop_is_slowmotion             = (runloop_flags & RUNLOOP_FLAG_SLOWMOTION) ? true : false;\n   bool runloop_is_paused                 = (runloop_flags & RUNLOOP_FLAG_PAUSED)     ? true : false;\n\n#ifdef HAVE_RWEBAUDIO\n   RWebAudioRecalibrateTime();\n#endif\n\n   emscripten_frame_count++;\n\n   /* Disable BFI during fast forward, slow-motion,\n    * and pause to prevent flicker. */\n   if (\n             black_frame_insertion\n         && !input_driver_nonblock_state\n         && !runloop_is_slowmotion\n         && !runloop_is_paused)\n   {\n      if ((emscripten_frame_count % (black_frame_insertion+1)) != 0)\n      {\n         gl_clear();\n         if (video_st->current_video_context.swap_buffers)\n            video_st->current_video_context.swap_buffers(\n                  video_st->context_data);\n         return;\n      }\n   }\n\n   ret = runloop_iterate();\n\n   task_queue_check();\n\n   if (ret != -1)\n      return;\n\n   main_exit(NULL);\n   emscripten_force_exit(0);\n}\n#endif\n\n#ifndef HAVE_MAIN\n#ifdef __cplusplus\nextern \"C\"\n#endif\nint main(int argc, char *argv[])\n{\n   return rarch_main(argc, argv, NULL);\n}\n#endif\n\n/* DYNAMIC LIBRETRO CORE  */\n\nconst struct retro_subsystem_info *libretro_find_subsystem_info(\n      const struct retro_subsystem_info *info, unsigned num_info,\n      const char *ident)\n{\n   unsigned i;\n   for (i = 0; i < num_info; i++)\n   {\n      if (     string_is_equal(info[i].ident, ident)\n            || string_is_equal(info[i].desc,  ident)\n         )\n         return &info[i];\n   }\n\n   return NULL;\n}\n\n/**\n * libretro_find_controller_description:\n * @info                         : Pointer to controller info handle.\n * @id                           : Identifier of controller to search\n *                                 for.\n *\n * Search for a controller of type @id in @info.\n *\n * Leaf function.\n *\n * @return controller description of found controller on success,\n * otherwise NULL.\n **/\nconst struct retro_controller_description *\nlibretro_find_controller_description(\n      const struct retro_controller_info *info, unsigned id)\n{\n   unsigned i;\n\n   for (i = 0; i < info->num_types; i++)\n   {\n      if (info->types[i].id != id)\n         continue;\n\n      return &info->types[i];\n   }\n\n   return NULL;\n}\n\n/**\n * libretro_free_system_info:\n * @info                         : Pointer to system info information.\n *\n * Frees system information.\n **/\nvoid libretro_free_system_info(struct retro_system_info *sysinfo)\n{\n   if (!sysinfo)\n      return;\n\n   free((void*)sysinfo->library_name);\n   free((void*)sysinfo->library_version);\n   free((void*)sysinfo->valid_extensions);\n   memset(sysinfo, 0, sizeof(*sysinfo));\n}\n\n#define _PSUPP_BUF(buf, len, var, name, desc) snprintf(buf + len, sizeof(buf) - len, \"  %-15s - %s: %s\", name, desc, var ? \"yes\\n\" : \"no\\n\")\n\nstatic void retroarch_print_features(void)\n{\n   size_t _len;\n   char buf[4096];\n\n   frontend_driver_attach_console();\n\n   _len  = strlcpy(buf, \"Features:\\n\", sizeof(buf));\n#ifdef HAVE_LIBRETRODB\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_LIBRETRODB,      \"LibretroDB\",      \"LibretroDB support\");\n#endif\n#ifdef HAVE_COMMAND\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_COMMAND,         \"Command\",         \"Command interface support\");\n#endif\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_NETWORK_COMMAND, \"Network Command\", \"Network Command interface support\");\n#ifdef HAVE_SDL\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_SDL,             \"SDL1\",            \"SDL1 input/audio/video drivers\");\n#endif\n#ifdef HAVE_SDL2\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_SDL2,            \"SDL2\",            \"SDL2 input/audio/video drivers\");\n#endif\n#ifdef HAVE_X11\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_X11,             \"X11\",             \"X11 input/video drivers\");\n#endif\n#ifdef HAVE_UDEV\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_UDEV,            \"UDEV\",            \"UDEV/EVDEV input driver\");\n#endif\n#ifdef HAVE_WAYLAND\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_WAYLAND,         \"Wayland\",         \"Wayland input/video drivers\");\n#endif\n#ifdef HAVE_THREADS\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_THREAD,          \"Threads\",         \"Threading support\");\n#endif\n#ifdef HAVE_GDI\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_GDI,            \"GDI\",               \"Video driver\");\n#endif\n#ifdef HAVE_D3D8\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_D3D8,            \"Direct3D 8\",       \"Video driver\");\n#endif\n#ifdef HAVE_D3D9\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_D3D9,            \"Direct3D 9\",       \"Video driver\");\n#endif\n#ifdef HAVE_D3D10\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_D3D10,           \"Direct3D 10\",      \"Video driver\");\n#endif\n#ifdef HAVE_D3D11\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_D3D11,           \"Direct3D 11\",      \"Video driver\");\n#endif\n#ifdef HAVE_D3D12\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_D3D12,           \"Direct3D 12\",      \"Video driver\");\n#endif\n#ifdef HAVE_VULKAN\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_VULKAN,          \"Vulkan\",          \"Video driver\");\n#endif\n#ifdef HAVE_METAL\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_METAL,           \"Metal\",           \"Video driver\");\n#endif\n#if defined(HAVE_OPENGL) || defined(HAVE_OPENGL1) || defined(HAVE_OPENGL_CORE)\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_OPENGL,          \"OpenGL\",          \"Video driver\");\n#endif\n#if defined(HAVE_OPENGLES) || defined(HAVE_OPENGLES2) || defined(HAVE_OPENGLES3) || defined(HAVE_OPENGLES3_1) || defined(HAVE_OPENGLES3_2)\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_OPENGLES,        \"OpenGLES\",        \"Video driver\");\n#endif\n#ifdef HAVE_XVIDEO\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_XVIDEO,          \"XVideo\",          \"Video driver\");\n#endif\n#ifdef HAVE_EGL\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_EGL,             \"EGL\",             \"Video context driver\");\n#endif\n#ifdef HAVE_KMS\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_KMS,             \"KMS\",             \"Video context driver\");\n#endif\n#ifdef HAVE_VG\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_VG,              \"OpenVG\",          \"Video context driver\");\n#endif\n#ifdef HAVE_COREAUDIO\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_COREAUDIO,       \"CoreAudio\",       \"Audio driver\");\n#endif\n#ifdef HAVE_COREAUDIO3\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_COREAUDIO3,      \"CoreAudioV3\",     \"Audio driver\");\n#endif\n#ifdef HAVE_ALSA\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_ALSA,            \"ALSA\",            \"Audio driver\");\n#endif\n#ifdef HAVE_PIPEWIRE\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_PIPEWIRE,        \"PipeWire\",        \"Audio driver\");\n#endif\n#ifdef HAVE_OSS\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_OSS,             \"OSS\",             \"Audio driver\");\n#endif\n#ifdef HAVE_JACK\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_JACK,            \"Jack\",            \"Audio driver\");\n#endif\n#ifdef HAVE_RSOUND\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_RSOUND,          \"RSound\",          \"Audio driver\");\n#endif\n#ifdef HAVE_ROAR\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_ROAR,            \"RoarAudio\",       \"Audio driver\");\n#endif\n#ifdef HAVE_PULSE\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_PULSE,           \"PulseAudio\",      \"Audio driver\");\n#endif\n#ifdef HAVE_DSOUND\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_DSOUND,          \"DirectSound\",     \"Audio driver\");\n#endif\n#ifdef HAVE_WASAPI\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_WASAPI,          \"WASAPI\",          \"Audio driver\");\n#endif\n#ifdef HAVE_XAUDIO\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_XAUDIO,          \"XAudio2\",         \"Audio driver\");\n#endif\n#ifdef HAVE_AL\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_AL,              \"OpenAL\",          \"Audio driver\");\n#endif\n#ifdef HAVE_SL\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_SL,              \"OpenSL\",          \"Audio driver\");\n#endif\n#ifdef HAVE_7ZIP\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_7ZIP,            \"7zip\",            \"7zip extraction support\");\n#endif\n#ifdef HAVE_ZLIB\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_ZLIB,            \"zlib\",            \"zip extraction support\");\n#endif\n#ifdef HAVE_DYLIB\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_DYLIB,           \"External\",        \"External filter and plugin support\");\n#endif\n#ifdef HAVE_CG\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_CG,              \"Cg\",              \"Fragment/vertex shader driver\");\n#endif\n#ifdef HAVE_GLSL\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_GLSL,            \"GLSL\",            \"Fragment/vertex shader driver\");\n#endif\n#ifdef HAVE_HLSL\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_HLSL,            \"HLSL\",            \"Fragment/vertex shader driver\");\n#endif\n#ifdef HAVE_SLANG\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_SLANG,           \"glslang\",         \"Fragment/vertex shader driver\");\n#endif\n#ifdef HAVE_SDL_IMAGE\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_SDL_IMAGE,       \"SDL_image\",       \"SDL_image image loading\");\n#endif\n#ifdef HAVE_RPNG\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_RPNG,            \"rpng\",            \"PNG image loading/encoding\");\n#endif\n#ifdef HAVE_RJPEG\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_RJPEG,           \"rjpeg\",           \"JPEG image loading\");\n#endif\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_DYNAMIC,         \"Dynamic\",         \"Dynamic run-time loading of libretro library\");\n#ifdef HAVE_FFMPEG\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_FFMPEG,          \"FFmpeg\",          \"On-the-fly recording of gameplay with libavcodec\");\n#endif\n#ifdef HAVE_FREETYPE\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_FREETYPE,        \"FreeType\",        \"TTF font rendering driver\");\n#endif\n#ifdef HAVE_CORETEXT\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_CORETEXT,        \"CoreText\",        \"TTF font rendering driver\");\n#endif\n#ifdef HAVE_NETWORKING\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_NETPLAY,         \"Netplay\",         \"Peer-to-peer netplay\");\n#endif\n#ifdef HAVE_SSL\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_SSL,              \"SSL\",            \"SSL Support\");\n#endif\n#ifdef HAVE_LIBUSB\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_LIBUSB,          \"Libusb\",          \"Libusb support\");\n#endif\n#ifdef HAVE_COCOA\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_COCOA,           \"Cocoa\",           \"Cocoa UI companion support (for OSX and/or iOS)\");\n#endif\n#ifdef HAVE_QT\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_QT,              \"Qt\",              \"Qt UI companion support\");\n#endif\n#ifdef HAVE_QT6\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_QT6,             \"Qt6\",              \"Qt 6.x support\");\n#endif\n#ifdef HAVE_V4L2\n   _len += _PSUPP_BUF(buf, _len, SUPPORTS_V4L2,            \"Video4Linux2\",    \"Camera driver\");\n#endif\n\n   fputs(buf, stdout);\n}\n\nstatic void retroarch_print_version(void)\n{\n   char str[256];\n   str[0] = '\\0';\n\n   frontend_driver_attach_console();\n\n   fprintf(stdout, \"%s - %s\\n\",\n         msg_hash_to_str(MSG_PROGRAM),\n         msg_hash_to_str(MSG_LIBRETRO_FRONTEND));\n\n   fprintf(stdout, \"Version: %s\", PACKAGE_VERSION);\n#ifdef HAVE_GIT_VERSION\n   fprintf(stdout, \" (Git %s)\", retroarch_git_version);\n#endif\n   fprintf(stdout, \" \" __DATE__ \"\\n\");\n\n   retroarch_get_capabilities(RARCH_CAPABILITIES_COMPILER, str, sizeof(str));\n   fprintf(stdout, \"%s\\n\", str);\n}\n\n/**\n * retroarch_print_help:\n *\n * Prints help message explaining the program's commandline switches.\n **/\nstatic void retroarch_print_help(const char *arg0)\n{\n   char buf[2048];\n   size_t _len = 0;\n   buf[0]      = '\\0';\n\n   frontend_driver_attach_console();\n   fputs(\"\\n\", stdout);\n   puts(\"===================================================================\");\n   retroarch_print_version();\n   puts(\"===================================================================\");\n   fputs(\"\\n\", stdout);\n\n   fprintf(stdout, \"Usage: %s [OPTIONS]... [FILE]\\n\\n\", arg0);\n\n   _len = strlcpy(buf + _len,\n         \"  -h, --help                     \"\n         \"Show this help message.\\n\"\n         \"  -v, --verbose                  \"\n         \"Verbose logging.\\n\"\n         \"      --log-file=FILE            \"\n         \"Log messages to FILE.\\n\"\n         \"  -V, --version                  \"\n         \"Show version.\\n\"\n         \"      --features                 \"\n         \"Print available features compiled into program.\\n\"\n         , sizeof(buf) - _len);\n#ifdef HAVE_MENU\n   _len += strlcpy(buf + _len,\n         \"      --menu                     \"\n         \"Do not require content or libretro core to be loaded,\\n\"\n         \"                                 \"\n         \"  starts directly in menu. If no arguments are passed to\\n\"\n         \"                                 \"\n         \"  the program, it is equivalent to using --menu as only argument.\\n\"\n         , sizeof(buf) - _len);\n#endif\n\n#ifdef HAVE_CONFIGFILE\n   _len += strlcpy(buf + _len, \"  -c, --config=FILE              \"\n         \"Path for config file.\\n\", sizeof(buf) - _len);\n#ifdef _WIN32\n   _len += strlcpy(buf + _len, \"                                 \"\n         \"  Defaults to retroarch.cfg in same directory as retroarch.exe.\\n\"\n         \"                                 \"\n         \"  If a default config is not found, the program will attempt to create one.\\n\"\n         , sizeof(buf) - _len);\n#else\n   _len += strlcpy(buf + _len,\n         \"                                 \"\n         \"  By default looks for config in\\n\"\n         \"                                 \"\n         \"  $XDG_CONFIG_HOME/retroarch/retroarch.cfg,\\n\"\n         \"                                 \"\n         \"  $HOME/.config/retroarch/retroarch.cfg, and\\n\"\n         \"                                 \"\n         \"  $HOME/.retroarch.cfg.\\n\"\n         \"                                 \"\n         \"  If a default config is not found, the program will attempt to create one\\n\"\n         \"                                 \"\n         \"  based on the skeleton config (\" GLOBAL_CONFIG_DIR \"/retroarch.cfg).\\n\"\n         , sizeof(buf) - _len);\n#endif\n   _len += strlcpy(buf + _len, \"      --appendconfig=FILE        \"\n         \"Extra config files are loaded in, and take priority over\\n\"\n         \"                                 \"\n         \"  config selected in -c (or default). Multiple configs are\\n\"\n         \"                                 \"\n         \"  delimited by '|'.\\n\"\n         , sizeof(buf) - _len);\n#endif\n\n   fputs(buf, stdout);\n   buf[0] = '\\0';\n   _len   = 0;\n\n   _len += strlcpy(buf + _len,\n         \"      --subsystem=NAME           \"\n         \"Use a subsystem of the libretro core. Multiple content\\n\"\n         \"                                 \"\n         \"  files are loaded as multiple arguments. If a content\\n\"\n         \"                                 \"\n         \"  file is skipped, use a blank (\\\"\\\") command line argument.\\n\"\n         , sizeof(buf) - _len);\n\n#ifdef HAVE_DYNAMIC\n   _len += strlcpy(buf + _len,\n         \"  -L, --libretro=FILE            \"\n         \"Path to libretro implementation. Overrides any config setting.\\n\"\n         \"                                 \"\n         \"  FILE may be one of the following:\\n\"\n         \"                                 \"\n         \"  1. The full path to a core shared object library: path/to/<core_name>_libretro.<lib_ext>\\n\"\n         \"                                 \"\n         \"  2. A core shared object library 'file name' (*): <core_name>_libretro.<lib_ext>\\n\"\n         , sizeof(buf) - _len);\n   _len += strlcpy(buf + _len,\n         \"                                 \"\n         \"  3. A core 'short name' (*): <core_name>_libretro OR <core_name>\\n\"\n         \"                                 \"\n         \"  (*) If 'file name' or 'short name' do not correspond to an existing full file path,\\n\"\n         \"                                 \"\n         \"  the configured frontend 'cores' directory will be searched for a match.\\n\"\n         , sizeof(buf) - _len);\n#endif\n\n   _len += strlcpy(buf + _len,\n         \"                                 \"\n         \"  Content must be loaded in an order which depends on the\\n\"\n         \"                                 \"\n         \"  particular subsystem used. See verbose log output to learn\\n\"\n         \"                                 \"\n         \"  how a particular subsystem wants content to be loaded.\\n\"\n         , sizeof(buf) - _len);\n\n#ifdef HAVE_LIBRETRODB\n   _len += strlcpy(buf + _len,\n         \"      --scan=PATH|FILE           \"\n         \"Import content from path.\\n\"\n         , sizeof(buf) - _len);\n#endif\n\n   _len = strlcpy(buf + _len,\n         \"  -f, --fullscreen               \"\n         \"Start the program in fullscreen regardless of config setting.\\n\"\n         \"      --set-shader=PATH          \"\n         \"Path to a shader (preset) that will be loaded each time content is loaded.\\n\"\n         \"                                 \"\n         \"  Effectively overrides automatic shader presets.\\n\"\n         \"                                 \"\n         \"  An empty argument \\\"\\\" will disable automatic shader presets.\\n\"\n         , sizeof(buf) - _len);\n\n   fputs(buf, stdout);\n   buf[0] = '\\0';\n   _len   = 0;\n\n   _len += snprintf(buf + _len, sizeof(buf) - _len,\"  -N, --nodevice=PORT            \"\n         \"Disconnects controller device connected to PORT (1 to %d).\\n\", MAX_USERS);\n   _len += snprintf(buf + _len, sizeof(buf) - _len,\"  -A, --dualanalog=PORT          \"\n         \"Connect a DualAnalog controller to PORT (1 to %d).\\n\", MAX_USERS);\n   _len += snprintf(buf + _len, sizeof(buf) - _len,\"  -d, --device=PORT:ID           \"\n         \"Connect a generic device into PORT of the device (1 to %d).\\n\", MAX_USERS);\n\n   _len += strlcpy(buf + _len,\n         \"                                 \"\n         \"  Format is PORT:ID, where ID is a number corresponding to the particular device.\\n\"\n         \"  -M, --sram-mode=MODE           \"\n         \"SRAM handling mode. MODE can be:\\n\"\n         \"                                 \"\n         \"  'noload-nosave', 'noload-save', 'load-nosave' or 'load-save'.\\n\"\n         \"                                 \"\n         \"  Note: 'noload-save' implies that save files *WILL BE OVERWRITTEN*.\\n\"\n         , sizeof(buf) - _len);\n\n#ifdef HAVE_NETWORKING\n   _len += strlcpy(buf + _len,\n         \"  -H, --host                     \"\n         \"Host netplay as user 1.\\n\"\n         \"  -C, --connect=HOST             \"\n         \"Connect to netplay server as user 2.\\n\"\n         \"      --port=PORT                \"\n         \"Port used to netplay. Default is 55435.\\n\"\n         \"      --mitm-session=ID           \"\n         \"MITM (relay) session ID to join.\\n\"\n         \"      --nick=NICK                \"\n         \"Picks a username (for use with netplay). Not mandatory.\\n\"\n         \"      --check-frames=NUMBER      \"\n         \"Check frames when using netplay.\\n\"\n         , sizeof(buf) - _len);\n#ifdef HAVE_NETWORK_CMD\n   _len += strlcpy(buf + _len,\n         \"      --command                  \"\n         \"Sends a command over UDP to an already running program process.\\n\"\n         \"                                 \"\n         \"  Available commands are listed if command is invalid.\\n\"\n         , sizeof(buf) - _len);\n#endif\n#endif\n\n#ifdef HAVE_BSV_MOVIE\n   _len += strlcpy(buf + _len,\n         \"  -P, --play-replay=FILE         \"\n         \"Playback a replay file.\\n\"\n         \"  -R, --record-replay=FILE       \"\n         \"Start recording a replay file from the beginning.\\n\"\n         \"      --eof-exit                 \"\n         \"Exit upon reaching the end of the replay file.\\n\"\n         , sizeof(buf) - _len);\n#endif\n\n   _len += strlcpy(buf + _len,\n         \"  -r, --record=FILE              \"\n         \"Path to record video file. Using mkv extension is recommended.\\n\"\n         \"      --recordconfig             \"\n         \"Path to settings used during recording.\\n\"\n         \"      --size=WIDTHxHEIGHT        \"\n         \"Overrides output video size when recording.\\n\"\n         , sizeof(buf) - _len);\n\n   fputs(buf, stdout);\n   buf[0] = '\\0';\n   _len   = 0;\n\n   _len   = strlcpy(buf + _len,\n         \"  -D, --detach                   \"\n         \"Detach program from the running console. Not relevant for all platforms.\\n\"\n         \"      --max-frames=NUMBER        \"\n         \"Runs for the specified number of frames, then exits.\\n\"\n         , sizeof(buf) - _len);\n\n#ifdef HAVE_PATCH\n   _len += strlcpy(buf + _len,\n         \"  -U, --ups=FILE                 \"\n         \"Specifies path for UPS patch that will be applied to content.\\n\"\n         \"      --bps=FILE                 \"\n         \"Specifies path for BPS patch that will be applied to content.\\n\"\n         \"      --ips=FILE                 \"\n         \"Specifies path for IPS patch that will be applied to content.\\n\"\n         , sizeof(buf) - _len);\n#ifdef HAVE_XDELTA\n   _len += strlcpy(buf + _len,\n         \"      --xdelta=FILE              \"\n         \"Specifies path for Xdelta patch that will be applied to content.\\n\"\n         , sizeof(buf) - _len);\n#endif /* HAVE_XDELTA */\n   _len += strlcpy(buf + _len,\n         \"      --no-patch                 \"\n         \"Disables all forms of content patching.\\n\"\n         , sizeof(buf) - _len);\n#endif /* HAVE_PATCH */\n\n#ifdef HAVE_SCREENSHOTS\n   _len += strlcpy(buf + _len,\n         \"      --max-frames-ss            \"\n         \"Takes a screenshot at the end of max-frames.\\n\"\n         \"      --max-frames-ss-path=FILE  \"\n         \"Path to save the screenshot to at the end of max-frames.\\n\"\n         , sizeof(buf) - _len);\n#endif\n\n#ifdef HAVE_ACCESSIBILITY\n   _len += strlcpy(buf + _len,\n         \"      --accessibility            \"\n         \"Enables accessibility for blind users using text-to-speech.\\n\"\n         , sizeof(buf) - _len);\n#endif\n\n   _len += strlcpy(buf + _len,\n         \"      --load-menu-on-error       \"\n         \"Open menu instead of quitting if specified core or content fails to load.\\n\"\n         \"  -e, --entryslot=NUMBER         \"\n         \"Slot from which to load an entry state.\\n\"\n         \"  -s, --save=PATH                \"\n         \"Path for save files (*.srm). (DEPRECATED, use --appendconfig and savefile_directory)\\n\"\n         \"  -S, --savestate=PATH           \"\n         \"Path for the save state files (*.state). (DEPRECATED, use --appendconfig and savestate_directory)\\n\"\n         , sizeof(buf) - _len);\n\n   fputs(buf, stdout);\n}\n\n#ifdef HAVE_DYNAMIC\nstatic void retroarch_parse_input_libretro_path(\n      struct rarch_state *p_rarch,\n      const char *path, size_t path_len)\n{\n   settings_t *settings   = config_get_ptr();\n   int path_stats         = 0;\n   const char *path_ext   = NULL;\n   core_info_t *core_info = NULL;\n   const char *core_path  = NULL;\n   bool core_path_matched = false;\n   char tmp_path[PATH_MAX_LENGTH];\n\n   if (string_is_empty(path))\n      goto end;\n\n   /* Check if path refers to a built-in core */\n   if (string_ends_with_size(path, \"builtin\",\n            path_len, STRLEN_CONST(\"builtin\")))\n   {\n      RARCH_LOG(\"--libretro argument \\\"%s\\\" is a built-in core. Ignoring.\\n\",\n            path);\n      return;\n   }\n\n   path_stats = path_stat(path);\n\n   /* Check if path is a directory */\n   if (\n       ((path_stats & RETRO_VFS_STAT_IS_DIRECTORY) != 0)\n#if defined(IOS) || defined(OSX)\n       && !string_ends_with(path, \".framework\")\n#endif\n       )\n   {\n      path_clear(RARCH_PATH_CORE);\n\n      configuration_set_string(settings,\n            settings->paths.directory_libretro, path);\n\n      retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_LIBRETRO, NULL);\n      retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_LIBRETRO_DIRECTORY, NULL);\n\n      RARCH_WARN(\"Using old --libretro behavior. \"\n            \"Setting libretro_directory to \\\"%s\\\" instead.\\n\",\n            path);\n      return;\n   }\n\n   /* Check if path is a valid file */\n   if ((path_stats & RETRO_VFS_STAT_IS_VALID) != 0)\n   {\n      core_path = path;\n      goto end;\n   }\n\n   /* If path refers to a core file that does not exist,\n    * check for its presence in the user-defined cores\n    * directory */\n   path_ext = path_get_extension(path);\n\n   if (!string_is_empty(path_ext))\n   {\n      char core_ext[16];\n      if (    string_is_empty(settings->paths.directory_libretro)\n          || !frontend_driver_get_core_extension(core_ext,\n               sizeof(core_ext))\n          || !string_is_equal(path_ext, core_ext))\n         goto end;\n\n      fill_pathname_join_special(tmp_path, settings->paths.directory_libretro,\n            path, sizeof(tmp_path));\n\n      if (string_is_empty(tmp_path))\n         goto end;\n\n      path_stats = path_stat(tmp_path);\n\n      if (   (path_stats & RETRO_VFS_STAT_IS_VALID)     != 0\n          && (path_stats & RETRO_VFS_STAT_IS_DIRECTORY) == 0)\n      {\n         core_path         = tmp_path;\n         core_path_matched = true;\n         goto end;\n      }\n   }\n   else\n   {\n      size_t _len;\n      const char *slash     = strrchr(path, '/');\n      const char *backslash = strrchr(path, '\\\\');\n      /* If path has no extension and contains no path\n       * delimiters, check if it is a core 'name', matching\n       * an existing file in the cores directory */\n      if (((!slash || (backslash > slash)) ? (char*)backslash : (char*)slash))\n         goto end;\n\n      /* First check for built-in cores */\n      if (string_is_equal(path, \"ffmpeg\"))\n      {\n         runloop_set_current_core_type(CORE_TYPE_FFMPEG, true);\n         return;\n      }\n      else if (string_is_equal(path, \"mpv\"))\n      {\n         runloop_set_current_core_type(CORE_TYPE_MPV, true);\n         return;\n      }\n      else if (string_is_equal(path, \"imageviewer\"))\n      {\n         runloop_set_current_core_type(CORE_TYPE_IMAGEVIEWER, true);\n         return;\n      }\n      if (string_is_equal(path, \"netretropad\"))\n      {\n         runloop_set_current_core_type(CORE_TYPE_NETRETROPAD, true);\n         return;\n      }\n      else if (string_is_equal(path, \"videoprocessor\"))\n      {\n         runloop_set_current_core_type(CORE_TYPE_VIDEO_PROCESSOR, true);\n         return;\n      }\n\n      command_event(CMD_EVENT_CORE_INFO_INIT, NULL);\n\n      _len = strlcpy(tmp_path, path, sizeof(tmp_path));\n\n      if (!string_ends_with_size(tmp_path, \"_libretro\",\n            _len, STRLEN_CONST(\"_libretro\")))\n         strlcpy(tmp_path       + _len,\n               \"_libretro\",\n               sizeof(tmp_path) - _len);\n\n      if (  !core_info_find(tmp_path, &core_info)\n          || string_is_empty(core_info->path))\n         goto end;\n\n      core_path         = core_info->path;\n      core_path_matched = true;\n   }\n\nend:\n   if (!string_is_empty(core_path))\n   {\n      strlcpy(p_rarch->path_libretro, core_path,\n            sizeof(p_rarch->path_libretro));\n      retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_LIBRETRO, NULL);\n\n      /* We requested an explicit core, so use PLAIN core type. */\n      runloop_set_current_core_type(CORE_TYPE_PLAIN, false);\n\n      if (core_path_matched)\n         RARCH_LOG(\"--libretro argument \\\"%s\\\" matches core file \\\"%s\\\".\\n\",\n               path, core_path);\n   }\n   else\n      RARCH_WARN(\"--libretro argument \\\"%s\\\" is not a file, core name\"\n            \" or directory. Ignoring.\\n\",\n            path ? path : \"\");\n}\n#endif\n\n#if defined(HAVE_LIBRETRODB) && defined(HAVE_MENU)\nvoid handle_dbscan_finished(retro_task_t *task,\n      void *task_data, void *user_data, const char *err);\n#endif\n\n/**\n * retroarch_parse_input_and_config:\n * @argc                 : Count of (commandline) arguments.\n * @argv                 : (Commandline) arguments.\n *\n * Parses (commandline) arguments passed to program and loads the config file,\n * with command line options overriding the config file.\n *\n **/\nstatic bool retroarch_parse_input_and_config(\n      struct rarch_state *p_rarch,\n      global_t *global,\n      int argc, char *argv[])\n{\n   unsigned i;\n   static bool           first_run = true;\n   bool verbosity_enabled          = false;\n   const char           *optstring = NULL;\n   bool              explicit_menu = false;\n   bool                 cli_active = false;\n   bool               cli_core_set = false;\n   bool            cli_content_set = false;\n   recording_state_t *rec_st       = recording_state_get_ptr();\n   video_driver_state_t *video_st  = video_state_get_ptr();\n   runloop_state_t     *runloop_st = runloop_state_get_ptr();\n   settings_t          *settings   = config_get_ptr();\n#ifdef HAVE_ACCESSIBILITY\n   access_state_t *access_st       = access_state_get_ptr();\n#endif\n#ifdef HAVE_LIBRETRODB\n   retro_task_callback_t cb_task_dbscan\n                                   = NULL;\n#endif\n\n   const struct option opts[]      = {\n#ifdef HAVE_DYNAMIC\n      { \"libretro\",           1, NULL, 'L' },\n#endif\n      { \"menu\",               0, NULL, RA_OPT_MENU },\n      { \"help\",               0, NULL, 'h' },\n      { \"save\",               1, NULL, 's' },\n      { \"fullscreen\",         0, NULL, 'f' },\n      { \"record\",             1, NULL, 'r' },\n      { \"recordconfig\",       1, NULL, RA_OPT_RECORDCONFIG },\n      { \"size\",               1, NULL, RA_OPT_SIZE },\n      { \"verbose\",            0, NULL, 'v' },\n#ifdef HAVE_CONFIGFILE\n      { \"config\",             1, NULL, 'c' },\n      { \"appendconfig\",       1, NULL, RA_OPT_APPENDCONFIG },\n#endif\n      { \"nodevice\",           1, NULL, 'N' },\n      { \"dualanalog\",         1, NULL, 'A' },\n      { \"device\",             1, NULL, 'd' },\n      { \"savestate\",          1, NULL, 'S' },\n      { \"set-shader\",         1, NULL, RA_OPT_SET_SHADER },\n#ifdef HAVE_BSV_MOVIE\n      { \"play-replay\",        1, NULL, 'P' },\n      { \"record-replay\",      1, NULL, 'R' },\n#endif\n      { \"sram-mode\",          1, NULL, 'M' },\n#ifdef HAVE_NETWORKING\n      { \"host\",               0, NULL, 'H' },\n      { \"connect\",            1, NULL, 'C' },\n      { \"mitm-session\",       1, NULL, 'T' },\n      { \"check-frames\",       1, NULL, RA_OPT_CHECK_FRAMES },\n      { \"port\",               1, NULL, RA_OPT_PORT },\n#ifdef HAVE_NETWORK_CMD\n      { \"command\",            1, NULL, RA_OPT_COMMAND },\n#endif\n#endif\n      { \"nick\",               1, NULL, RA_OPT_NICK },\n#ifdef HAVE_PATCH\n      { \"ups\",                1, NULL, 'U' },\n      { \"bps\",                1, NULL, RA_OPT_BPS },\n      { \"ips\",                1, NULL, RA_OPT_IPS },\n#ifdef HAVE_XDELTA\n      { \"xdelta\",             1, NULL, RA_OPT_XDELTA },\n#endif /* HAVE_XDELTA */\n      { \"no-patch\",           0, NULL, RA_OPT_NO_PATCH },\n#endif /* HAVE_PATCH */\n      { \"detach\",             0, NULL, 'D' },\n      { \"features\",           0, NULL, RA_OPT_FEATURES },\n      { \"subsystem\",          1, NULL, RA_OPT_SUBSYSTEM },\n      { \"max-frames\",         1, NULL, RA_OPT_MAX_FRAMES },\n      { \"max-frames-ss\",      0, NULL, RA_OPT_MAX_FRAMES_SCREENSHOT },\n      { \"max-frames-ss-path\", 1, NULL, RA_OPT_MAX_FRAMES_SCREENSHOT_PATH },\n      { \"eof-exit\",           0, NULL, RA_OPT_EOF_EXIT },\n      { \"version\",            0, NULL, 'V' /* RA_OPT_VERSION */ },\n      { \"log-file\",           1, NULL, RA_OPT_LOG_FILE },\n      { \"accessibility\",      0, NULL, RA_OPT_ACCESSIBILITY},\n      { \"load-menu-on-error\", 0, NULL, RA_OPT_LOAD_MENU_ON_ERROR },\n      { \"entryslot\",          1, NULL, 'e' },\n#ifdef HAVE_LIBRETRODB\n      { \"scan\",               1, NULL, RA_OPT_DATABASE_SCAN },\n#endif\n      { NULL, 0, NULL, 0 }\n   };\n\n   if (first_run)\n   {\n      size_t _len = 0;\n      /* Copy the args into a buffer so launch arguments can be reused */\n      for (i = 0; i < (unsigned)argc; i++)\n      {\n         _len += strlcpy(p_rarch->launch_arguments        + _len,\n               argv[i], sizeof(p_rarch->launch_arguments) - _len);\n         _len += strlcpy(p_rarch->launch_arguments        + _len,\n               \" \",     sizeof(p_rarch->launch_arguments) - _len);\n      }\n      string_trim_whitespace_left(p_rarch->launch_arguments);\n      string_trim_whitespace_right(p_rarch->launch_arguments);\n\n      first_run  = false;\n\n      /* Command line interface is only considered\n       * to be 'active' (i.e. used by a third party)\n       * if this is the first run (subsequent runs\n       * are triggered by RetroArch itself) */\n      cli_active = true;\n   }\n\n   /* Handling the core type is finicky. Based on the arguments we pass in,\n    * we handle it differently.\n    * Some current cases which track desired behavior and how it is supposed to work:\n    *\n    * Dynamically linked RA:\n    * ./retroarch                            -> CORE_TYPE_DUMMY\n    * ./retroarch -v                         -> CORE_TYPE_DUMMY + verbose\n    * ./retroarch --menu                     -> CORE_TYPE_DUMMY\n    * ./retroarch --menu -v                  -> CORE_TYPE_DUMMY + verbose\n    * ./retroarch -L contentless-core        -> CORE_TYPE_PLAIN\n    * ./retroarch -L content-core            -> CORE_TYPE_PLAIN + FAIL (This currently crashes)\n    * ./retroarch [-L content-core] ROM      -> CORE_TYPE_PLAIN\n    * ./retroarch <-L or ROM> --menu         -> FAIL\n    *\n    * The heuristic here seems to be that if we use the -L CLI option or\n    * optind < argc at the end we should set CORE_TYPE_PLAIN.\n    * To handle --menu, we should ensure that CORE_TYPE_DUMMY is still set\n    * otherwise, fail early, since the CLI options are non-sensical.\n    * We could also simply ignore --menu in this case to be more friendly with\n    * bogus arguments.\n    */\n\n   if (!(runloop_st->flags & RUNLOOP_FLAG_HAS_SET_CORE))\n      runloop_set_current_core_type(CORE_TYPE_DUMMY, false);\n\n   path_clear(RARCH_PATH_SUBSYSTEM);\n\n   retroarch_override_setting_free_state();\n\n   p_rarch->flags                 &= ~RARCH_FLAGS_HAS_SET_USERNAME;\n#ifdef HAVE_PATCH\n   p_rarch->flags                 &= ~(  RARCH_FLAGS_UPS_PREF | RARCH_FLAGS_IPS_PREF\n                                       | RARCH_FLAGS_BPS_PREF | RARCH_FLAGS_XDELTA_PREF);\n   *runloop_st->name.ups           = '\\0';\n   *runloop_st->name.bps           = '\\0';\n   *runloop_st->name.ips           = '\\0';\n   *runloop_st->name.xdelta        = '\\0';\n#endif\n#ifdef HAVE_CONFIGFILE\n   runloop_st->flags              &= ~RUNLOOP_FLAG_OVERRIDES_ACTIVE;\n#endif\n   global->flags                  &= ~GLOB_FLG_CLI_LOAD_MENU_ON_ERR;\n\n   /* Make sure we can call retroarch_parse_input several times ... */\n   optind                          = 0;\n   optstring                       = \"hs:fvVS:A:U:DN:d:e:\"\n      BSV_MOVIE_ARG NETPLAY_ARG DYNAMIC_ARG FFMPEG_RECORD_ARG CONFIG_FILE_ARG;\n\n#if defined(WEBOS)\n   argv                            = &(argv[1]);\n   argc                            = argc - 1;\n#endif\n\n#ifndef HAVE_MENU\n   if (argc == 1)\n   {\n      printf(\"%s\\n\", msg_hash_to_str(MSG_NO_ARGUMENTS_SUPPLIED_AND_NO_MENU_BUILTIN));\n      retroarch_print_help(argv[0]);\n      exit(0);\n   }\n#endif\n\n   /* First pass: Read the config file path and any directory overrides, so\n    * they're in place when we load the config */\n   if (argc)\n   {\n      for (;;)\n      {\n         int c = getopt_long(argc, argv, optstring, opts, NULL);\n\n#if 0\n         fprintf(stderr, \"c is: %c (%d), optarg is: [%s]\\n\", c, c, string_is_empty(optarg) ? \"\" : optarg);\n#endif\n\n         if (c == -1)\n            break;\n\n         /* Graceful failure with empty \"-\" parameter instead of allowing\n          * to continue to segmentation fault by trying to load content */\n         if (c == 0)\n         {\n            verbosity_enable();\n            fprintf(stderr, \"%s\\n\", msg_hash_to_str(MSG_ERROR_PARSING_ARGUMENTS));\n            fprintf(stderr, \"Try '%s --help' for more information\\n\", argv[0]);\n            exit(EXIT_FAILURE);\n         }\n\n         switch (c)\n         {\n            case 'h':\n               retroarch_print_help(argv[0]);\n               exit(0);\n\n            case 'V':\n            case RA_OPT_VERSION:\n               retroarch_print_version();\n               exit(0);\n\n            case RA_OPT_FEATURES:\n               retroarch_print_features();\n               exit(0);\n\n#ifdef HAVE_CONFIGFILE\n            case 'c':\n               strlcpy(p_rarch->path_config_file, optarg,\n                     sizeof(p_rarch->path_config_file));\n               break;\n            case RA_OPT_APPENDCONFIG:\n               strlcpy(p_rarch->path_config_append_file, optarg,\n                     sizeof(p_rarch->path_config_append_file));\n               break;\n#endif\n\n            case 's':\n               strlcpy(runloop_st->name.savefile, optarg,\n                     sizeof(runloop_st->name.savefile));\n               retroarch_override_setting_set(\n                     RARCH_OVERRIDE_SETTING_SAVE_PATH, NULL);\n               break;\n\n            case 'S':\n               strlcpy(runloop_st->name.savestate, optarg,\n                     sizeof(runloop_st->name.savestate));\n               strlcpy(runloop_st->name.replay, optarg,\n                     sizeof(runloop_st->name.replay));\n               retroarch_override_setting_set(\n                     RARCH_OVERRIDE_SETTING_STATE_PATH, NULL);\n               break;\n\n            case 'v':\n               verbosity_enable();\n               retroarch_override_setting_set(\n                     RARCH_OVERRIDE_SETTING_VERBOSITY, NULL);\n               break;\n            case RA_OPT_LOG_FILE:\n               /* Enable 'log to file' */\n               configuration_set_bool(settings,\n                     settings->bools.log_to_file, true);\n\n               retroarch_override_setting_set(\n                     RARCH_OVERRIDE_SETTING_LOG_TO_FILE, NULL);\n\n               /* Cache log file path override */\n               rarch_log_file_set_override(optarg);\n               break;\n\n            case RA_OPT_MENU:\n               explicit_menu = true;\n               break;\n            case RA_OPT_DATABASE_SCAN:\n#ifdef HAVE_LIBRETRODB\n               verbosity_enable();\n               retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_DATABASE_SCAN, NULL);\n#endif\n               break;\n\n            /* Must handle '?' otherwise you get an infinite loop */\n            case '?':\n               frontend_driver_attach_console();\n#ifdef _WIN32\n               fprintf(stderr, \"\\n%s: unrecognized option '%s'\\n\", argv[0], argv[optind]);\n#endif\n               fprintf(stderr, \"Try '%s --help' for more information\\n\", argv[0]);\n               exit(EXIT_FAILURE);\n               break;\n            /* All other arguments are handled in the second pass */\n         }\n      }\n   }\n   verbosity_enabled = verbosity_is_enabled();\n   /* Enable logging to file if verbosity and log-file arguments were passed.\n    * RARCH_OVERRIDE_SETTING_LOG_TO_FILE is set by the RA_OPT_LOG_FILE case above\n    * The parameters passed to rarch_log_file_init are hardcoded as the config\n    * has not yet been initialized at this point. */\n   if (verbosity_enabled && retroarch_override_setting_is_set(RARCH_OVERRIDE_SETTING_LOG_TO_FILE, NULL))\n      rarch_log_file_init(true, false, NULL);\n\n   /* Flush out some states that could have been set\n    * by core environment variables. */\n   runloop_st->current_core.flags &= ~(RETRO_CORE_FLAG_HAS_SET_INPUT_DESCRIPTORS\n                                     | RETRO_CORE_FLAG_HAS_SET_SUBSYSTEMS);\n\n   /* Load the config file now that we know what it is */\n#ifdef HAVE_CONFIGFILE\n   if (!(p_rarch->flags & RARCH_FLAGS_BLOCK_CONFIG_READ))\n#endif\n   {\n      /* Workaround for libdecor 0.2.0 setting unwanted locale */\n#if defined(HAVE_WAYLAND) && defined(HAVE_DYNAMIC)\n      setlocale(LC_NUMERIC,\"C\");\n#endif\n      /* If this is a static build, load salamander\n       * config file first (sets RARCH_PATH_CORE) */\n#if !defined(HAVE_DYNAMIC)\n      config_load_file_salamander();\n#endif\n      config_load(global_get_ptr());\n   }\n\n   verbosity_enabled = verbosity_is_enabled();\n   /* Init logging after config load only if not overridden by command line argument.\n    * This handles when logging is set in the config but not via the --log-file option. */\n   if (verbosity_enabled && !retroarch_override_setting_is_set(RARCH_OVERRIDE_SETTING_LOG_TO_FILE, NULL))\n      rarch_log_file_init(\n            settings->bools.log_to_file,\n            settings->bools.log_to_file_timestamp,\n            settings->paths.log_dir);\n\n   /* Second pass: All other arguments override the config file */\n   optind = 1;\n\n   if (argc)\n   {\n      for (;;)\n      {\n         int c = getopt_long(argc, argv, optstring, opts, NULL);\n\n         if (c == -1)\n            break;\n\n         switch (c)\n         {\n            case 'd':\n               {\n                  unsigned new_port;\n                  char *save               = NULL;\n                  char *tok                = NULL;\n                  int    port              = 0;\n                  unsigned id              = 0;\n                  char *optarg_cpy         = strdup(optarg);\n\n                  if ((tok = strtok_r(optarg_cpy, \":\", &save)))\n                     port = (int)strtol(tok, NULL, 0);\n                  if ((tok = strtok_r(NULL, \":\", &save)))\n                     id   = (unsigned)strtoul(tok, NULL, 0);\n                  free(optarg_cpy);\n\n                  if (port < 1 || port > MAX_USERS)\n                  {\n                     RARCH_ERR(\"%s\\n\", msg_hash_to_str(MSG_VALUE_CONNECT_DEVICE_FROM_A_VALID_PORT));\n                     retroarch_print_help(argv[0]);\n                     retroarch_fail(1, \"retroarch_parse_input()\");\n                  }\n                  new_port = port - 1;\n\n                  input_config_set_device(new_port, id);\n\n                  retroarch_override_setting_set(\n                        RARCH_OVERRIDE_SETTING_LIBRETRO_DEVICE, &new_port);\n               }\n               break;\n\n            case 'A':\n               {\n                  unsigned new_port;\n                  int port = (int)strtol(optarg, NULL, 0);\n\n                  if (port < 1 || port > MAX_USERS)\n                  {\n                     RARCH_ERR(\"Connect dualanalog to a valid port.\\n\");\n                     retroarch_print_help(argv[0]);\n                     retroarch_fail(1, \"retroarch_parse_input()\");\n                  }\n                  new_port = port - 1;\n\n                  input_config_set_device(new_port, RETRO_DEVICE_ANALOG);\n                  retroarch_override_setting_set(\n                        RARCH_OVERRIDE_SETTING_LIBRETRO_DEVICE, &new_port);\n               }\n               break;\n\n            case 'f':\n               video_st->flags |= VIDEO_FLAG_FORCE_FULLSCREEN;\n               break;\n\n            case 'N':\n               {\n                  unsigned new_port;\n                  int port = (int)strtol(optarg, NULL, 0);\n\n                  if (port < 1 || port > MAX_USERS)\n                  {\n                     RARCH_ERR(\"%s\\n\",\n                           msg_hash_to_str(MSG_DISCONNECT_DEVICE_FROM_A_VALID_PORT));\n                     retroarch_print_help(argv[0]);\n                     retroarch_fail(1, \"retroarch_parse_input()\");\n                  }\n                  new_port = port - 1;\n                  input_config_set_device(new_port, RETRO_DEVICE_NONE);\n                  retroarch_override_setting_set(\n                        RARCH_OVERRIDE_SETTING_LIBRETRO_DEVICE, &new_port);\n               }\n               break;\n\n            case 'r':\n               strlcpy(rec_st->path, optarg, sizeof(rec_st->path));\n               if (rec_st->enable)\n                  rec_st->enable = true;\n               break;\n\n            case RA_OPT_SET_SHADER:\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n               /* disable auto-shaders */\n               if (string_is_empty(optarg))\n               {\n                  video_st->flags |= VIDEO_FLAG_CLI_SHADER_DISABLE;\n                  break;\n               }\n\n               /* rebase on shader directory */\n               if (path_is_absolute(optarg))\n                  strlcpy(video_st->cli_shader_path, optarg,\n                        sizeof(video_st->cli_shader_path));\n               else\n                  fill_pathname_join_special(video_st->cli_shader_path,\n                        settings->paths.directory_video_shader,\n                        optarg, sizeof(video_st->cli_shader_path));\n#endif\n               break;\n\n#ifdef HAVE_DYNAMIC\n            case 'L':\n               retroarch_parse_input_libretro_path(p_rarch, optarg, strlen(optarg));\n               break;\n#endif\n            case 'P':\n#ifdef HAVE_BSV_MOVIE\n               {\n                  input_driver_state_t *input_st = input_state_get_ptr();\n                  strlcpy(input_st->bsv_movie_state.movie_start_path, optarg,\n                        sizeof(input_st->bsv_movie_state.movie_start_path));\n                  input_st->bsv_movie_state.flags |=\n                      BSV_FLAG_MOVIE_START_PLAYBACK;\n                  input_st->bsv_movie_state.flags &=\n                     ~BSV_FLAG_MOVIE_START_RECORDING;\n               }\n#endif\n               break;\n            case 'R':\n#ifdef HAVE_BSV_MOVIE\n               {\n                  input_driver_state_t *input_st = input_state_get_ptr();\n                  strlcpy(input_st->bsv_movie_state.movie_start_path, optarg,\n                        sizeof(input_st->bsv_movie_state.movie_start_path));\n                  input_st->bsv_movie_state.flags &=\n                     ~BSV_FLAG_MOVIE_START_PLAYBACK;\n                  input_st->bsv_movie_state.flags |=\n                     BSV_FLAG_MOVIE_START_RECORDING;\n               }\n#endif\n               break;\n\n            case 'M':\n               if (string_is_equal(optarg, \"noload-nosave\"))\n                  runloop_st->flags |= RUNLOOP_FLAG_IS_SRAM_LOAD_DISABLED\n                                     | RUNLOOP_FLAG_IS_SRAM_SAVE_DISABLED;\n               else if (string_is_equal(optarg, \"noload-save\"))\n                  runloop_st->flags |= RUNLOOP_FLAG_IS_SRAM_LOAD_DISABLED;\n               else if (string_is_equal(optarg, \"load-nosave\"))\n                  runloop_st->flags |= RUNLOOP_FLAG_IS_SRAM_SAVE_DISABLED;\n               else if (string_is_not_equal(optarg, \"load-save\"))\n               {\n                  RARCH_ERR(\"Invalid argument in --sram-mode.\\n\");\n                  retroarch_print_help(argv[0]);\n                  retroarch_fail(1, \"retroarch_parse_input()\");\n               }\n               break;\n\n#ifdef HAVE_NETWORKING\n            case 'H':\n               retroarch_override_setting_set(\n                     RARCH_OVERRIDE_SETTING_NETPLAY_MODE, NULL);\n               netplay_driver_ctl(RARCH_NETPLAY_CTL_ENABLE_SERVER, NULL);\n               break;\n\n            case 'C':\n               retroarch_override_setting_set(\n                     RARCH_OVERRIDE_SETTING_NETPLAY_MODE, NULL);\n               netplay_driver_ctl(RARCH_NETPLAY_CTL_ENABLE_CLIENT, NULL);\n               p_rarch->connect_host = strdup(optarg);\n               break;\n\n            case 'T':\n               p_rarch->connect_mitm_id = strdup(optarg);\n               break;\n\n            case RA_OPT_CHECK_FRAMES:\n               retroarch_override_setting_set(\n                     RARCH_OVERRIDE_SETTING_NETPLAY_CHECK_FRAMES, NULL);\n\n               configuration_set_int(settings,\n                     settings->ints.netplay_check_frames,\n                     (int)strtoul(optarg, NULL, 0));\n               break;\n\n            case RA_OPT_PORT:\n               retroarch_override_setting_set(\n                     RARCH_OVERRIDE_SETTING_NETPLAY_IP_PORT, NULL);\n               configuration_set_uint(settings,\n                     settings->uints.netplay_port,\n                     (int)strtoul(optarg, NULL, 0));\n               break;\n\n#ifdef HAVE_NETWORK_CMD\n            case RA_OPT_COMMAND:\n#ifdef HAVE_COMMAND\n               if (command_network_send((const char*)optarg))\n                  exit(0);\n               else\n                  retroarch_fail(1, \"network_cmd_send()\");\n#endif\n               break;\n#endif\n\n#endif\n\n            case RA_OPT_BPS:\n#ifdef HAVE_PATCH\n               strlcpy(runloop_st->name.bps, optarg,\n                     sizeof(runloop_st->name.bps));\n               p_rarch->flags |= RARCH_FLAGS_BPS_PREF;\n               retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_BPS_PREF, NULL);\n#endif\n               break;\n\n            case 'U':\n#ifdef HAVE_PATCH\n               strlcpy(runloop_st->name.ups, optarg,\n                     sizeof(runloop_st->name.ups));\n               p_rarch->flags |= RARCH_FLAGS_UPS_PREF;\n               retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_UPS_PREF, NULL);\n#endif\n               break;\n\n            case RA_OPT_IPS:\n#ifdef HAVE_PATCH\n               strlcpy(runloop_st->name.ips, optarg,\n                     sizeof(runloop_st->name.ips));\n               p_rarch->flags |= RARCH_FLAGS_IPS_PREF;\n               retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_IPS_PREF, NULL);\n#endif\n               break;\n             case RA_OPT_XDELTA:\n#if defined(HAVE_PATCH) && defined(HAVE_XDELTA)\n                 strlcpy(runloop_st->name.xdelta, optarg,\n                     sizeof(runloop_st->name.xdelta));\n               p_rarch->flags |= RARCH_FLAGS_XDELTA_PREF;\n               retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_XDELTA_PREF, NULL);\n#endif\n                 break;\n            case RA_OPT_NO_PATCH:\n#ifdef HAVE_PATCH\n               runloop_st->flags |= RUNLOOP_FLAG_PATCH_BLOCKED;\n#endif\n               break;\n\n            case 'D':\n               frontend_driver_detach_console();\n               break;\n\n            case RA_OPT_MENU:\n               explicit_menu = true;\n               break;\n\n            case RA_OPT_NICK:\n               p_rarch->flags |= RARCH_FLAGS_HAS_SET_USERNAME;\n\n               configuration_set_string(settings,\n                     settings->paths.username, optarg);\n               break;\n\n            case RA_OPT_SIZE:\n               if (sscanf(optarg, \"%ux%u\",\n                        &rec_st->width, &rec_st->height) != 2)\n               {\n                  RARCH_ERR(\"Wrong format for --size.\\n\");\n                  retroarch_print_help(argv[0]);\n                  retroarch_fail(1, \"retroarch_parse_input()\");\n               }\n               break;\n\n            case RA_OPT_RECORDCONFIG:\n               strlcpy(rec_st->config, optarg, sizeof(rec_st->config));\n               break;\n\n            case RA_OPT_MAX_FRAMES:\n               runloop_st->max_frames  = (unsigned)strtoul(optarg, NULL, 10);\n               break;\n\n            case RA_OPT_MAX_FRAMES_SCREENSHOT:\n#ifdef HAVE_SCREENSHOTS\n               runloop_st->flags |= RUNLOOP_FLAG_MAX_FRAMES_SCREENSHOT;\n#endif\n               break;\n\n            case RA_OPT_MAX_FRAMES_SCREENSHOT_PATH:\n#ifdef HAVE_SCREENSHOTS\n               strlcpy(runloop_st->max_frames_screenshot_path,\n                     optarg,\n                     sizeof(runloop_st->max_frames_screenshot_path));\n#endif\n               break;\n\n            case RA_OPT_SUBSYSTEM:\n               strlcpy(runloop_st->subsystem_path, optarg,\n                     sizeof(runloop_st->subsystem_path));\n               break;\n\n            case RA_OPT_EOF_EXIT:\n#ifdef HAVE_BSV_MOVIE\n               {\n                  input_driver_state_t *input_st   = input_state_get_ptr();\n                  input_st->bsv_movie_state.flags |= BSV_FLAG_MOVIE_EOF_EXIT;\n               }\n#endif\n               break;\n\n            case 'h':\n            case 'V':\n            case RA_OPT_VERSION:\n            case RA_OPT_FEATURES:\n#ifdef HAVE_CONFIGFILE\n            case 'c':\n            case RA_OPT_APPENDCONFIG:\n#endif\n            case 's':\n            case 'S':\n            case 'v':\n            case RA_OPT_LOG_FILE:\n               break; /* Handled in the first pass */\n\n            case '?':\n               retroarch_print_help(argv[0]);\n               retroarch_fail(1, \"retroarch_parse_input()\");\n            case RA_OPT_ACCESSIBILITY:\n#ifdef HAVE_ACCESSIBILITY\n               access_st->enabled = true;\n#endif\n               break;\n            case RA_OPT_LOAD_MENU_ON_ERROR:\n               global->flags |= GLOB_FLG_CLI_LOAD_MENU_ON_ERR;\n               break;\n            case 'e':\n               {\n                  unsigned entry_state_slot = (unsigned)strtoul(optarg, NULL, 0);\n\n                  if (entry_state_slot)\n                     runloop_st->entry_state_slot = entry_state_slot;\n                  else\n                     RARCH_WARN(\"--entryslot argument \\\"%s\\\" is not a valid \"\n                        \"entry state slot index. Ignoring.\\n\", optarg);\n               }\n               break;\n            case RA_OPT_DATABASE_SCAN:\n#ifdef HAVE_LIBRETRODB\n               {\n                  settings_t *settings           = config_get_ptr();\n                  bool show_hidden_files         = settings->bools.show_hidden_files;\n                  const char *directory_playlist = settings->paths.directory_playlist;\n                  const char *path_content_db    = settings->paths.path_content_database;\n                  int reinit_flags               = DRIVERS_CMD_ALL &\n                        ~(DRIVER_VIDEO_MASK | DRIVER_AUDIO_MASK | DRIVER_MICROPHONE_MASK | DRIVER_INPUT_MASK | DRIVER_MIDI_MASK);\n\n                  drivers_init(settings, reinit_flags, (enum driver_lifetime_flags)0, false);\n                  retroarch_init_task_queue();\n\n#ifdef HAVE_MENU\n                  if (explicit_menu)\n                     cb_task_dbscan = handle_dbscan_finished;\n#endif\n\n                  task_push_dbscan(\n                        directory_playlist,\n                        path_content_db,\n                        optarg, path_is_directory(optarg),\n                        show_hidden_files,\n                        cb_task_dbscan);\n\n                  if (!explicit_menu)\n                  {\n                     task_queue_wait(NULL, NULL);\n                     driver_uninit(DRIVERS_CMD_ALL, (enum driver_lifetime_flags)0);\n                     exit(0);\n                  }\n               }\n#endif\n               break;\n            default:\n               RARCH_ERR(\"%s\\n\", msg_hash_to_str(MSG_ERROR_PARSING_ARGUMENTS));\n               retroarch_fail(1, \"retroarch_parse_input()\");\n         }\n      }\n   }\n\n#ifdef HAVE_GIT_VERSION\n   RARCH_LOG(\"RetroArch %s (Git %s)\\n\",\n         PACKAGE_VERSION, retroarch_git_version);\n#endif\n\n   if (explicit_menu)\n   {\n      if (optind < argc)\n      {\n         RARCH_ERR(\"--menu was used, but content file was passed as well.\\n\");\n         retroarch_fail(1, \"retroarch_parse_input()\");\n      }\n#ifdef HAVE_DYNAMIC\n      else\n      {\n         /* Allow stray -L arguments to go through to workaround cases\n          * where it's used as \"config file\".\n          *\n          * This seems to still be the case for Android, which\n          * should be properly fixed. */\n         runloop_set_current_core_type(CORE_TYPE_DUMMY, false);\n      }\n#endif\n   }\n\n   if (optind < argc)\n   {\n      bool subsystem_path_is_empty = path_is_empty(RARCH_PATH_SUBSYSTEM);\n\n      /* We requested explicit ROM, so use PLAIN core type. */\n      runloop_set_current_core_type(CORE_TYPE_PLAIN, false);\n\n      if (subsystem_path_is_empty)\n      {\n         runloop_path_set_basename((const char*)argv[optind]);\n         runloop_path_set_names();\n         runloop_path_set_redirect(settings, p_rarch->dir_savefile,\n               p_rarch->dir_savestate);\n      }\n      else\n         runloop_path_set_special(argv + optind, argc - optind);\n\n      /* Register that content has been set via the\n       * command line interface */\n      cli_content_set = true;\n   }\n   else if (runloop_st->entry_state_slot)\n   {\n      runloop_st->entry_state_slot = 0;\n      RARCH_WARN(\"Trying to load entry state without content. Ignoring.\\n\");\n   }\n   #ifdef HAVE_BSV_MOVIE\n   if (runloop_st->entry_state_slot)\n   {\n     input_driver_state_t *input_st = input_state_get_ptr();\n     if (input_st->bsv_movie_state.flags & BSV_FLAG_MOVIE_START_PLAYBACK)\n     {\n        runloop_st->entry_state_slot = 0;\n        RARCH_WARN(\"Trying to load entry state while replay playback is active. Ignoring entry state.\\n\");\n     }\n   }\n   #endif\n\n\n   /* Check whether a core has been set via the\n    * command line interface */\n   cli_core_set = (runloop_st->current_core_type != CORE_TYPE_DUMMY);\n\n   /* Update global 'content launched from command\n    * line' status flag */\n   if (cli_active && (cli_core_set || cli_content_set))\n      global->flags |=  (GLOB_FLG_LAUNCHED_FROM_CLI);\n   else\n      global->flags &= ~(GLOB_FLG_LAUNCHED_FROM_CLI);\n\n   /* Copy SRM/state dirs used, so they can be reused on reentrancy. */\n   if (retroarch_override_setting_is_set(RARCH_OVERRIDE_SETTING_SAVE_PATH, NULL) &&\n         path_is_directory(runloop_st->name.savefile))\n      dir_set(RARCH_DIR_SAVEFILE, runloop_st->name.savefile);\n\n   if (retroarch_override_setting_is_set(RARCH_OVERRIDE_SETTING_STATE_PATH, NULL) &&\n         path_is_directory(runloop_st->name.savestate))\n      dir_set(RARCH_DIR_SAVESTATE, runloop_st->name.savestate);\n\n   return verbosity_enabled;\n}\n\n/**\n * retroarch_validate_cpu_features:\n *\n * Validates CPU features for given processor architecture.\n * Make sure we haven't compiled for something we cannot run.\n * Ideally, code would get swapped out depending on CPU support,\n * but this will do for now.\n **/\nstatic void retroarch_validate_cpu_features(void)\n{\n   uint64_t cpu = cpu_features_get();\n   (void)cpu;\n\n#ifdef __MMX__\n   if (!(cpu & RETRO_SIMD_MMX))\n      FAIL_CPU(\"MMX\");\n#endif\n#ifdef __SSE__\n   if (!(cpu & RETRO_SIMD_SSE))\n      FAIL_CPU(\"SSE\");\n#endif\n#ifdef __SSE2__\n   if (!(cpu & RETRO_SIMD_SSE2))\n      FAIL_CPU(\"SSE2\");\n#endif\n#ifdef __AVX__\n   if (!(cpu & RETRO_SIMD_AVX))\n      FAIL_CPU(\"AVX\");\n#endif\n}\n\n/**\n * retroarch_main_init:\n * @argc                 : Count of (commandline) arguments.\n * @argv                 : (Commandline) arguments.\n *\n * Initializes the program.\n *\n * @return true on success, otherwise false if there was an error.\n **/\nbool retroarch_main_init(int argc, char *argv[])\n{\n#if defined(DEBUG) && defined(HAVE_DRMINGW)\n   char log_file_name[128];\n#endif\n   bool verbosity_enabled        = false;\n   bool           init_failed    = false;\n   struct rarch_state *p_rarch   = &rarch_st;\n   runloop_state_t *runloop_st   = runloop_state_get_ptr();\n   input_driver_state_t\n      *input_st                  = input_state_get_ptr();\n   video_driver_state_t*video_st = video_state_get_ptr();\n   settings_t *settings          = config_get_ptr();\n   recording_state_t *rec_st     = recording_state_get_ptr();\n   global_t            *global   = global_get_ptr();\n#ifdef HAVE_ACCESSIBILITY\n   access_state_t *access_st     = access_state_get_ptr();\n   bool accessibility_enable     = false;\n   unsigned accessibility_narrator_speech_speed = 0;\n#endif\n#ifdef HAVE_MENU\n   struct menu_state *menu_st    = menu_state_get_ptr();\n#endif\n\n   input_st->osk_idx             = OSK_LOWERCASE_LATIN;\n   video_st->flags              |= VIDEO_FLAG_ACTIVE;\n   audio_state_get_ptr()->flags |= AUDIO_FLAG_ACTIVE;\n\n   if (setjmp(global->error_sjlj_context) > 0)\n   {\n      RARCH_ERR(\"%s: \\\"%s\\\"\\n\",\n            msg_hash_to_str(MSG_FATAL_ERROR_RECEIVED_IN),\n            global_get_ptr()->error_string);\n      goto error;\n   }\n\n   global->flags |= GLOB_FLG_ERR_ON_INIT;\n\n   /* Have to initialise non-file logging once at the start... */\n   retro_main_log_file_init(NULL, false);\n\n   verbosity_enabled = retroarch_parse_input_and_config(p_rarch,\n         global_get_ptr(), argc, argv);\n\n#ifdef __APPLE__\n   /* This doesn't have to be apple specific but it's currently the only\n    * platform that doesn't call dir_check_defaults(). This does exactly the\n    * same thing as dir_check_defaults() except that it makes the directories\n    * pointed at by the config file rather than the defaults, which is why it\n    * comes right after parsing the config. osx users seem to be more likely to\n    * want to do change the default directories.\n    */\n   dir_check_config();\n#endif\n\n#ifdef HAVE_ACCESSIBILITY\n   accessibility_enable                = settings->bools.accessibility_enable;\n   accessibility_narrator_speech_speed = settings->uints.accessibility_narrator_speech_speed;\n   /* State that the narrator is on, and also include the first menu\n      item we're on at startup. */\n   if (is_accessibility_enabled(\n            accessibility_enable,\n            access_st->enabled))\n      accessibility_speak_priority(\n            accessibility_enable,\n            accessibility_narrator_speech_speed,\n            (char*)msg_hash_to_str(MSG_ACCESSIBILITY_STARTUP),\n            10);\n#endif\n\n   if (verbosity_enabled)\n   {\n      {\n         char str_output[256];\n         const char *cpu_model  = frontend_driver_get_cpu_model_name();\n         size_t _len = strlcpy(str_output,\n               \"=== Build =======================================\\n\",\n               sizeof(str_output));\n\n         if (!string_is_empty(cpu_model))\n         {\n            /* TODO/FIXME - localize */\n            _len += strlcpy(str_output + _len,\n                  FILE_PATH_LOG_INFO \" CPU Model Name: \",\n                  sizeof(str_output)   - _len);\n            _len += strlcpy(str_output + _len,\n                  cpu_model,\n                  sizeof(str_output) - _len);\n            str_output[  _len] = '\\n';\n            str_output[++_len] = '\\0';\n         }\n\n         RARCH_LOG_OUTPUT(\"%s\", str_output);\n      }\n\n      {\n         char str_output[256];\n         char str[128];\n         retroarch_get_capabilities(RARCH_CAPABILITIES_CPU, str, sizeof(str));\n\n#ifdef HAVE_GIT_VERSION\n         snprintf(str_output, sizeof(str_output),\n               \"%s: %s\" \"\\n\"\n               FILE_PATH_LOG_INFO \" Version: \" PACKAGE_VERSION \"\\n\"\n               FILE_PATH_LOG_INFO \" Git: %s\" \"\\n\"\n               FILE_PATH_LOG_INFO \" Built: \" __DATE__ \"\\n\"\n               FILE_PATH_LOG_INFO \" =================================================\\n\",\n               msg_hash_to_str(MSG_CAPABILITIES),\n               str,\n               retroarch_git_version\n               );\n#else\n         snprintf(str_output, sizeof(str_output),\n               \"%s: %s\" \"\\n\"\n               FILE_PATH_LOG_INFO \" Version: \" PACKAGE_VERSION \"\\n\"\n               FILE_PATH_LOG_INFO \" Built: \" __DATE__ \"\\n\"\n               FILE_PATH_LOG_INFO \" =================================================\\n\",\n               msg_hash_to_str(MSG_CAPABILITIES),\n               str);\n#endif\n         RARCH_LOG_OUTPUT(\"%s\", str_output);\n      }\n   }\n\n#if defined(DEBUG) && defined(HAVE_DRMINGW)\n   RARCH_LOG_OUTPUT(\"Initializing Dr.MingW Exception handler\\n\");\n   fill_str_dated_filename(log_file_name, \"crash\",\n         \"log\", sizeof(log_file_name));\n   ExcHndlInit();\n   ExcHndlSetLogFileNameA(log_file_name);\n#endif\n\n   retroarch_validate_cpu_features();\n   retroarch_init_task_queue();\n\n   {\n      const char    *fullpath  = p_rarch->path_content;\n\n      if (!string_is_empty(fullpath))\n      {\n         enum rarch_content_type cont_type = path_is_media_type(fullpath);\n#ifdef HAVE_IMAGEVIEWER\n         bool builtin_imageviewer          = settings->bools.multimedia_builtin_imageviewer_enable;\n#endif\n         bool builtin_mediaplayer          = settings->bools.multimedia_builtin_mediaplayer_enable;\n\n         switch (cont_type)\n         {\n            case RARCH_CONTENT_MOVIE:\n            case RARCH_CONTENT_MUSIC:\n               if (builtin_mediaplayer)\n               {\n                  /* TODO/FIXME - it needs to become possible to\n                   * switch between FFmpeg and MPV at runtime */\n#if defined(HAVE_MPV)\n                  retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_LIBRETRO, NULL);\n                  runloop_set_current_core_type(CORE_TYPE_MPV, false);\n#elif defined(HAVE_FFMPEG)\n                  retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_LIBRETRO, NULL);\n                  runloop_set_current_core_type(CORE_TYPE_FFMPEG, false);\n#endif\n               }\n               break;\n#ifdef HAVE_IMAGEVIEWER\n            case RARCH_CONTENT_IMAGE:\n               if (builtin_imageviewer)\n               {\n                  retroarch_override_setting_set(RARCH_OVERRIDE_SETTING_LIBRETRO, NULL);\n                  runloop_set_current_core_type(CORE_TYPE_IMAGEVIEWER, false);\n               }\n               break;\n#endif\n            default:\n               break;\n         }\n      }\n   }\n\n   /* Pre-initialize all drivers\n    * Attempts to find a default driver for\n    * all driver types.\n    */\n   if (!(audio_driver_find_driver(settings,\n         \"audio driver\", verbosity_enabled)))\n      retroarch_fail(1, \"audio_driver_find()\");\n   if (!video_driver_find_driver(settings,\n         \"video driver\", verbosity_enabled))\n      retroarch_fail(1, \"video_driver_find_driver()\");\n   if (!input_driver_find_driver(settings,\n         \"input driver\", verbosity_enabled))\n      retroarch_fail(1, \"input_driver_find_driver()\");\n\n   if (!camera_driver_find_driver(\"camera driver\", verbosity_enabled))\n      retroarch_fail(1, \"find_camera_driver()\");\n\n#ifdef HAVE_BLUETOOTH\n   bluetooth_driver_ctl(RARCH_BLUETOOTH_CTL_FIND_DRIVER, NULL);\n#endif\n#ifdef HAVE_WIFI\n   wifi_driver_ctl(RARCH_WIFI_CTL_FIND_DRIVER, NULL);\n#endif\n#ifdef HAVE_CLOUDSYNC\n   cloud_sync_find_driver(settings,\n         \"cloud sync driver\", verbosity_enabled);\n#endif\n   location_driver_find_driver(settings,\n         &location_driver_st,\n         \"location driver\", verbosity_enabled);\n#ifdef HAVE_MENU\n   {\n      if (!(menu_st->driver_ctx = menu_driver_find_driver(settings,\n                  \"menu driver\", verbosity_enabled)))\n         retroarch_fail(1, \"menu_driver_find_driver()\");\n   }\n#endif\n   /* Enforce stored brightness if needed */\n   if (frontend_driver_can_set_screen_brightness())\n      frontend_driver_set_screen_brightness(settings->uints.screen_brightness);\n\n   /* Attempt to initialize core */\n   if (runloop_st->flags & RUNLOOP_FLAG_HAS_SET_CORE)\n   {\n      runloop_st->flags &= ~RUNLOOP_FLAG_HAS_SET_CORE;\n      if (!command_event(CMD_EVENT_CORE_INIT,\n               &runloop_st->explicit_current_core_type))\n         init_failed = true;\n   }\n   else if (!command_event(CMD_EVENT_CORE_INIT,\n            &runloop_st->current_core_type))\n      init_failed = true;\n\n   /* Handle core initialization failure */\n   if (init_failed)\n   {\n#ifdef HAVE_DYNAMIC\n      /* Check if menu was active prior to core initialization */\n      if (   (!(global->flags & GLOB_FLG_LAUNCHED_FROM_CLI))\n          ||   (global->flags & GLOB_FLG_CLI_LOAD_MENU_ON_ERR)\n#ifdef HAVE_MENU\n          ||  (menu_st->flags & MENU_ST_FLAG_ALIVE)\n#endif\n         )\n#endif\n      {\n         /* Before initialising the dummy core, ensure\n          * that we:\n          * - Unload any active input remaps\n          * - Disable any active config overrides */\n         if (     (runloop_st->flags & RUNLOOP_FLAG_REMAPS_CORE_ACTIVE)\n               || (runloop_st->flags & RUNLOOP_FLAG_REMAPS_CONTENT_DIR_ACTIVE)\n               || (runloop_st->flags & RUNLOOP_FLAG_REMAPS_GAME_ACTIVE)\n               || !string_is_empty(runloop_st->name.remapfile)\n            )\n         {\n            input_remapping_deinit(false);\n            input_remapping_set_defaults(true);\n         }\n         else\n            input_remapping_restore_global_config(true, false);\n\n#ifdef HAVE_CONFIGFILE\n         /* Reload the original config */\n         if (runloop_st->flags & RUNLOOP_FLAG_OVERRIDES_ACTIVE)\n            config_unload_override();\n#endif\n\n#ifdef HAVE_DYNAMIC\n         /* Ensure that currently loaded core is properly\n          * deinitialised */\n         if (runloop_st->current_core_type != CORE_TYPE_DUMMY)\n            command_event(CMD_EVENT_CORE_DEINIT, NULL);\n#endif\n         /* Attempt initializing dummy core */\n         runloop_st->current_core_type = CORE_TYPE_DUMMY;\n         if (!command_event(CMD_EVENT_CORE_INIT, &runloop_st->current_core_type))\n            goto error;\n      }\n#ifdef HAVE_DYNAMIC\n      else /* Fall back to regular error handling */\n         goto error;\n#endif\n   }\n\n#ifdef HAVE_CHEATS\n   cheat_manager_state_free();\n   command_event_init_cheats(\n         settings->bools.apply_cheats_after_load,\n         settings->paths.path_cheat_database,\n#ifdef HAVE_BSV_MOVIE\n         input_st->bsv_movie_state_handle\n#else\n         NULL\n#endif\n         );\n#endif\n   drivers_init(settings, DRIVERS_CMD_ALL, (enum driver_lifetime_flags)0, verbosity_enabled);\n#ifdef HAVE_COMMAND\n   input_driver_deinit_command(input_st);\n   input_driver_init_command(input_st, settings);\n#endif\n#ifdef HAVE_NETWORKGAMEPAD\n   if (input_st->remote)\n      input_remote_free(input_st->remote,\n            settings->uints.input_max_users);\n   input_st->remote    = NULL;\n   if (settings->bools.network_remote_enable)\n      input_st->remote = input_driver_init_remote(\n            settings,\n            settings->uints.input_max_users);\n#endif\n   input_mapper_reset(&input_st->mapper);\n#ifdef HAVE_REWIND\n   command_event(CMD_EVENT_REWIND_INIT, NULL);\n#endif\n   command_event(CMD_EVENT_CONTROLLER_INIT, NULL);\n   if (!string_is_empty(rec_st->path))\n      command_event(CMD_EVENT_RECORD_INIT, NULL);\n\n   command_event(CMD_EVENT_SET_PER_GAME_RESOLUTION, NULL);\n\n   global->flags                   &= ~GLOB_FLG_ERR_ON_INIT;\n   runloop_st->flags               |=  RUNLOOP_FLAG_IS_INITED;\n\n#ifdef HAVE_DISCORD\n   {\n      discord_state_t *discord_st = discord_state_get_ptr();\n\n      if (command_event(CMD_EVENT_DISCORD_INIT, NULL))\n         discord_st->inited = true;\n   }\n#endif\n\n#ifdef HAVE_PRESENCE\n   {\n      presence_userdata_t userdata;\n      userdata.status = PRESENCE_MENU;\n      command_event(CMD_EVENT_PRESENCE_UPDATE, &userdata);\n   }\n#endif\n\n#if defined(HAVE_AUDIOMIXER)\n   audio_driver_load_system_sounds();\n#endif\n\n#ifdef HAVE_RUNAHEAD\n#ifdef HAVE_MENU\n   menu_update_runahead_mode();\n#endif\n#ifdef HAVE_NETWORKING\n   if (!netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_ENABLED, NULL))\n#endif\n      preempt_init(runloop_st);\n#endif\n\n   return true;\n\nerror:\n   command_event(CMD_EVENT_CORE_DEINIT, NULL);\n   runloop_state_get_ptr()->flags            &= ~RUNLOOP_FLAG_IS_INITED;\n\n   return false;\n}\n\nvoid retroarch_init_task_queue(void)\n{\n#ifdef HAVE_THREADS\n   settings_t *settings        = config_get_ptr();\n   bool threaded_enable        = settings->bools.threaded_data_runloop_enable;\n#else\n   bool threaded_enable        = false;\n#endif\n\n   task_queue_deinit();\n   task_queue_init(threaded_enable, runloop_task_msg_queue_push);\n}\n\nbool retroarch_ctl(enum rarch_ctl_state state, void *data)\n{\n   struct rarch_state     *p_rarch = &rarch_st;\n   runloop_state_t     *runloop_st = runloop_state_get_ptr();\n\n   switch(state)\n   {\n#ifdef HAVE_BSV_MOVIE\n      case RARCH_CTL_BSV_MOVIE_IS_INITED:\n         return (input_state_get_ptr()->bsv_movie_state_handle != NULL);\n#endif\n#ifdef HAVE_PATCH\n      case RARCH_CTL_UNSET_BPS_PREF:\n         p_rarch->flags &= ~RARCH_FLAGS_BPS_PREF;\n         break;\n      case RARCH_CTL_UNSET_UPS_PREF:\n         p_rarch->flags &= ~RARCH_FLAGS_UPS_PREF;\n         break;\n      case RARCH_CTL_UNSET_IPS_PREF:\n         p_rarch->flags &= ~RARCH_FLAGS_IPS_PREF;\n         break;\n#ifdef HAVE_XDELTA\n      case RARCH_CTL_UNSET_XDELTA_PREF:\n         p_rarch->flags &= ~RARCH_FLAGS_XDELTA_PREF;\n         break;\n#endif /* HAVE_XDELTA */\n#endif /* HAVE_PATCH */\n      case RARCH_CTL_IS_DUMMY_CORE:\n         return runloop_st->current_core_type == CORE_TYPE_DUMMY;\n      case RARCH_CTL_IS_CORE_LOADED:\n         {\n            const char *core_path = (const char*)data;\n            const char *core_file = path_basename_nocompression(core_path);\n            if (!string_is_empty(core_file))\n            {\n               /* Get loaded core file name */\n               const char *loaded_core_file = path_basename_nocompression(\n                     p_rarch->path_libretro);\n               /* Check whether specified core and currently\n                * loaded core are the same */\n               if (!string_is_empty(loaded_core_file))\n                  if (string_is_equal(core_file, loaded_core_file))\n                     return true;\n            }\n         }\n         return false;\n#if defined(HAVE_RUNAHEAD) && (defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB))\n      case RARCH_CTL_IS_SECOND_CORE_AVAILABLE:\n         return\n                  (runloop_st->flags & RUNLOOP_FLAG_CORE_RUNNING)\n               && (runloop_st->flags & RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE);\n      case RARCH_CTL_IS_SECOND_CORE_LOADED:\n         return\n                   (runloop_st->flags & RUNLOOP_FLAG_CORE_RUNNING)\n               &&  (runloop_st->secondary_lib_handle != NULL);\n#endif\n      case RARCH_CTL_MAIN_DEINIT:\n         {\n            input_driver_state_t *input_st = input_state_get_ptr();\n            if (!(runloop_st->flags & RUNLOOP_FLAG_IS_INITED))\n               return false;\n            command_event(CMD_EVENT_NETPLAY_DEINIT, NULL);\n#ifdef HAVE_COMMAND\n            input_driver_deinit_command(input_st);\n#endif\n#ifdef HAVE_NETWORKGAMEPAD\n            if (input_st->remote)\n               input_remote_free(input_st->remote,\n                     config_get_ptr()->uints.input_max_users);\n            input_st->remote = NULL;\n#endif\n            input_mapper_reset(&input_st->mapper);\n\n#ifdef HAVE_THREADS\n            if (runloop_st->flags & RUNLOOP_FLAG_USE_SRAM)\n               autosave_deinit();\n#endif\n\n            command_event(CMD_EVENT_RECORD_DEINIT, NULL);\n\n            command_event(CMD_EVENT_SAVE_FILES, NULL);\n\n#ifdef HAVE_REWIND\n            command_event(CMD_EVENT_REWIND_DEINIT, NULL);\n#endif\n#ifdef HAVE_CHEATS\n            cheat_manager_state_free();\n#endif\n#ifdef HAVE_BSV_MOVIE\n            movie_stop(input_st);\n#endif\n            command_event(CMD_EVENT_CORE_DEINIT, NULL);\n\n            content_deinit();\n\n            runloop_path_deinit_subsystem();\n            path_deinit_savefile();\n\n            runloop_st->flags &= ~RUNLOOP_FLAG_IS_INITED;\n\n#ifdef HAVE_THREAD_STORAGE\n            sthread_tls_delete(&p_rarch->rarch_tls);\n#endif\n         }\n         break;\n#ifdef HAVE_CONFIGFILE\n      case RARCH_CTL_SET_BLOCK_CONFIG_READ:\n         p_rarch->flags |= RARCH_FLAGS_BLOCK_CONFIG_READ;\n         break;\n      case RARCH_CTL_UNSET_BLOCK_CONFIG_READ:\n         p_rarch->flags &= ~RARCH_FLAGS_BLOCK_CONFIG_READ;\n         break;\n#endif\n      case RARCH_CTL_CORE_OPTIONS_LIST_GET:\n         {\n            core_option_manager_t **coreopts = (core_option_manager_t**)data;\n            if (!coreopts || !runloop_st->core_options)\n               return false;\n            *coreopts = runloop_st->core_options;\n         }\n         break;\n      case RARCH_CTL_CORE_OPTION_UPDATE_DISPLAY:\n         if (   runloop_st->core_options\n             && runloop_st->core_options_callback.update_display)\n         {\n            /* Note: The update_display() callback may read\n             * core option values via RETRO_ENVIRONMENT_GET_VARIABLE.\n             * This will reset the 'options updated' flag.\n             * We therefore have to cache the current 'options updated'\n             * state and restore it after the update_display() function\n             * returns */\n            bool values_updated  = runloop_st->core_options->updated;\n            bool display_updated = runloop_st->core_options_callback.update_display();\n\n            runloop_st->core_options->updated = values_updated;\n            return display_updated;\n         }\n         return false;\n#ifdef HAVE_CONFIGFILE\n      case RARCH_CTL_SET_REMAPS_CORE_ACTIVE:\n         /* Only one type of remap can be active\n          * at any one time */\n         runloop_st->flags &= ~(RUNLOOP_FLAG_REMAPS_CONTENT_DIR_ACTIVE\n                              | RUNLOOP_FLAG_REMAPS_GAME_ACTIVE);\n         runloop_st->flags |=   RUNLOOP_FLAG_REMAPS_CORE_ACTIVE;\n         break;\n      case RARCH_CTL_SET_REMAPS_GAME_ACTIVE:\n         runloop_st->flags &= ~(RUNLOOP_FLAG_REMAPS_CORE_ACTIVE\n                              | RUNLOOP_FLAG_REMAPS_CONTENT_DIR_ACTIVE);\n         runloop_st->flags |=   RUNLOOP_FLAG_REMAPS_GAME_ACTIVE;\n         break;\n      case RARCH_CTL_SET_REMAPS_CONTENT_DIR_ACTIVE:\n         runloop_st->flags &= ~(RUNLOOP_FLAG_REMAPS_CORE_ACTIVE\n                              | RUNLOOP_FLAG_REMAPS_GAME_ACTIVE);\n         runloop_st->flags |=   RUNLOOP_FLAG_REMAPS_CONTENT_DIR_ACTIVE;\n         break;\n#endif\n      case RARCH_CTL_GET_PERFCNT:\n         {\n            bool **perfcnt = (bool**)data;\n            if (!perfcnt)\n               return false;\n            *perfcnt = &runloop_st->perfcnt_enable;\n         }\n         break;\n      case RARCH_CTL_SET_PERFCNT_ENABLE:\n         runloop_st->perfcnt_enable = true;\n         break;\n      case RARCH_CTL_UNSET_PERFCNT_ENABLE:\n         runloop_st->perfcnt_enable = false;\n         break;\n      case RARCH_CTL_IS_PERFCNT_ENABLE:\n         return runloop_st->perfcnt_enable;\n      case RARCH_CTL_SET_WINDOWED_SCALE:\n         {\n            unsigned *idx = (unsigned*)data;\n            if (!idx)\n               return false;\n            runloop_st->pending_windowed_scale = *idx;\n         }\n         break;\n      case RARCH_CTL_STATE_FREE:\n         {\n            input_driver_state_t *input_st = input_state_get_ptr();\n            runloop_st->perfcnt_enable     = false;\n#ifdef HAVE_CONFIGFILE\n            runloop_st->flags             &= ~RUNLOOP_FLAG_OVERRIDES_ACTIVE;\n#endif\n            runloop_st->flags             &= ~(RUNLOOP_FLAG_AUTOSAVE\n                                           |   RUNLOOP_FLAG_SLOWMOTION\n                                           |   RUNLOOP_FLAG_IDLE\n                                           |   RUNLOOP_FLAG_PAUSED\n                                              );\n            runloop_state_free(runloop_st);\n\n            memset(&input_st->analog_requested, 0,\n                  sizeof(input_st->analog_requested));\n         }\n         break;\n      case RARCH_CTL_SET_SHUTDOWN:\n         runloop_st->flags |= RUNLOOP_FLAG_SHUTDOWN_INITIATED;\n         break;\n      case RARCH_CTL_CORE_OPTION_PREV:\n         /*\n          * Get previous value for core option specified by @idx.\n          * Options wrap around.\n          */\n         {\n            unsigned *idx = (unsigned*)data;\n            if (!idx || !runloop_st->core_options)\n               return false;\n            core_option_manager_adjust_val(runloop_st->core_options,\n                  *idx, -1, true);\n         }\n         break;\n      case RARCH_CTL_CORE_OPTION_NEXT:\n         /*\n          * Get next value for core option specified by @idx.\n          * Options wrap around.\n          */\n         {\n            unsigned* idx = (unsigned*)data;\n            if (!idx || !runloop_st->core_options)\n               return false;\n            core_option_manager_adjust_val(runloop_st->core_options,\n                  *idx, 1, true);\n         }\n         break;\n      case RARCH_CTL_NONE:\n      default:\n         return false;\n   }\n\n   return true;\n}\n\nbool retroarch_override_setting_is_set(\n      enum rarch_override_setting enum_idx, void *data)\n{\n   struct rarch_state *p_rarch = &rarch_st;\n#ifdef HAVE_NETWORKING\n   net_driver_state_t *net_st  = networking_state_get_ptr();\n#endif\n\n   switch (enum_idx)\n   {\n      case RARCH_OVERRIDE_SETTING_LIBRETRO_DEVICE:\n         {\n            unsigned *val = (unsigned*)data;\n            if (val)\n            {\n               unsigned                bit = *val;\n               runloop_state_t *runloop_st = runloop_state_get_ptr();\n               return BIT256_GET(runloop_st->has_set_libretro_device, bit);\n            }\n         }\n         break;\n      case RARCH_OVERRIDE_SETTING_VERBOSITY:\n         return ((p_rarch->flags & RARCH_FLAGS_HAS_SET_VERBOSITY) > 0);\n      case RARCH_OVERRIDE_SETTING_LIBRETRO:\n         return ((p_rarch->flags & RARCH_FLAGS_HAS_SET_LIBRETRO) > 0);\n      case RARCH_OVERRIDE_SETTING_LIBRETRO_DIRECTORY:\n         return ((p_rarch->flags & RARCH_FLAGS_HAS_SET_LIBRETRO_DIRECTORY) > 0);\n      case RARCH_OVERRIDE_SETTING_SAVE_PATH:\n         return ((p_rarch->flags & RARCH_FLAGS_HAS_SET_SAVE_PATH) > 0);\n      case RARCH_OVERRIDE_SETTING_STATE_PATH:\n         return ((p_rarch->flags & RARCH_FLAGS_HAS_SET_STATE_PATH) > 0);\n#ifdef HAVE_NETWORKING\n      case RARCH_OVERRIDE_SETTING_NETPLAY_MODE:\n         return ((net_st->flags & NET_DRIVER_ST_FLAG_HAS_SET_NETPLAY_MODE) > 0);\n      case RARCH_OVERRIDE_SETTING_NETPLAY_IP_ADDRESS:\n         return ((net_st->flags & NET_DRIVER_ST_FLAG_HAS_SET_NETPLAY_IP_ADDRESS) > 0);\n      case RARCH_OVERRIDE_SETTING_NETPLAY_IP_PORT:\n         return ((net_st->flags & NET_DRIVER_ST_FLAG_HAS_SET_NETPLAY_IP_PORT) > 0);\n      case RARCH_OVERRIDE_SETTING_NETPLAY_CHECK_FRAMES:\n         return ((net_st->flags & NET_DRIVER_ST_FLAG_HAS_SET_NETPLAY_CHECK_FRAMES) > 0);\n#endif\n#ifdef HAVE_PATCH\n      case RARCH_OVERRIDE_SETTING_UPS_PREF:\n         return ((p_rarch->flags & RARCH_FLAGS_HAS_SET_UPS_PREF) > 0);\n      case RARCH_OVERRIDE_SETTING_BPS_PREF:\n         return ((p_rarch->flags & RARCH_FLAGS_HAS_SET_BPS_PREF) > 0);\n      case RARCH_OVERRIDE_SETTING_IPS_PREF:\n         return ((p_rarch->flags & RARCH_FLAGS_HAS_SET_IPS_PREF) > 0);\n#ifdef HAVE_XDELTA\n      case RARCH_OVERRIDE_SETTING_XDELTA_PREF:\n         return ((p_rarch->flags & RARCH_FLAGS_HAS_SET_XDELTA_PREF) > 0);\n#endif /* HAVE_XDELTA */\n#endif /* HAVE_PATCH */\n      case RARCH_OVERRIDE_SETTING_LOG_TO_FILE:\n         return ((p_rarch->flags & RARCH_FLAGS_HAS_SET_LOG_TO_FILE) > 0);\n      case RARCH_OVERRIDE_SETTING_DATABASE_SCAN:\n         return ((p_rarch->flags & RARCH_FLAGS_CLI_DATABASE_SCAN) > 0);\n      case RARCH_OVERRIDE_SETTING_OVERLAY_PRESET:\n         return ((p_rarch->flags & RARCH_FLAGS_HAS_SET_OVERLAY_PRESET) > 0);\n      case RARCH_OVERRIDE_SETTING_NONE:\n      default:\n         break;\n   }\n\n   return false;\n}\n\nsize_t retroarch_get_capabilities(enum rarch_capabilities type,\n      char *s, size_t len)\n{\n   size_t _len = 0;\n   switch (type)\n   {\n      case RARCH_CAPABILITIES_CPU:\n         {\n            uint64_t cpu = cpu_features_get();\n            if (cpu & RETRO_SIMD_MMX)\n               _len += strlcpy(s + _len, \"MMX \", len - _len);\n            if (cpu & RETRO_SIMD_MMXEXT)\n               _len += strlcpy(s + _len, \"MMXEXT \", len - _len);\n            if (cpu & RETRO_SIMD_SSE)\n               _len += strlcpy(s + _len, \"SSE \", len - _len);\n            if (cpu & RETRO_SIMD_SSE2)\n               _len += strlcpy(s + _len, \"SSE2 \", len - _len);\n            if (cpu & RETRO_SIMD_SSE3)\n               _len += strlcpy(s + _len, \"SSE3 \", len - _len);\n            if (cpu & RETRO_SIMD_SSSE3)\n               _len += strlcpy(s + _len, \"SSSE3 \", len - _len);\n            if (cpu & RETRO_SIMD_SSE4)\n               _len += strlcpy(s + _len, \"SSE4 \", len - _len);\n            if (cpu & RETRO_SIMD_SSE42)\n               _len += strlcpy(s + _len, \"SSE42 \", len - _len);\n            if (cpu & RETRO_SIMD_AES)\n               _len += strlcpy(s + _len, \"AES \", len - _len);\n            if (cpu & RETRO_SIMD_AVX)\n               _len += strlcpy(s + _len, \"AVX \", len - _len);\n            if (cpu & RETRO_SIMD_AVX2)\n               _len += strlcpy(s + _len, \"AVX2 \", len - _len);\n            if (cpu & RETRO_SIMD_NEON)\n               _len += strlcpy(s + _len, \"NEON \", len - _len);\n            if (cpu & RETRO_SIMD_VFPV3)\n               _len += strlcpy(s + _len, \"VFPV3 \", len - _len);\n            if (cpu & RETRO_SIMD_VFPV4)\n               _len += strlcpy(s + _len, \"VFPV4 \", len - _len);\n            if (cpu & RETRO_SIMD_VMX)\n               _len += strlcpy(s + _len, \"VMX \", len - _len);\n            if (cpu & RETRO_SIMD_VMX128)\n               _len += strlcpy(s + _len, \"VMX128 \", len - _len);\n            if (cpu & RETRO_SIMD_VFPU)\n               _len += strlcpy(s + _len, \"VFPU \", len - _len);\n            if (cpu & RETRO_SIMD_PS)\n               _len += strlcpy(s + _len, \"PS \", len - _len);\n            if (cpu & RETRO_SIMD_ASIMD)\n               _len += strlcpy(s + _len, \"ASIMD \", len - _len);\n            break;\n         }\n         break;\n      case RARCH_CAPABILITIES_COMPILER:\n#if defined(_MSC_VER)\n         _len += strlcpy (s + _len, msg_hash_to_str(MSG_COMPILER), len - _len);\n         _len += snprintf(s + _len, len - _len, \": MSVC (%d)\",\n               _MSC_VER);\n#elif defined(__SNC__)\n         _len += strlcpy (s + _len, msg_hash_to_str(MSG_COMPILER), len - _len);\n         _len += snprintf(s + _len, len - _len, \": SNC (%d)\",\n               __SN_VER__);\n#elif defined(_WIN32) && defined(__GNUC__)\n         _len += strlcpy (s + _len, msg_hash_to_str(MSG_COMPILER), len - _len);\n         _len += snprintf(s + _len, len - _len, \": MinGW (%d.%d.%d)\",\n               __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);\n#elif defined(__clang__)\n         _len += strlcpy(s + _len, msg_hash_to_str(MSG_COMPILER), len - _len);\n         _len += strlcpy(s + _len, \": Clang/LLVM (\", len - _len);\n         _len += strlcpy(s + _len, __clang_version__, len - _len);\n         _len += strlcpy(s + _len, \")\", len - _len);\n#elif defined(__GNUC__)\n         _len += strlcpy (s + _len, msg_hash_to_str(MSG_COMPILER), len - _len);\n         _len += snprintf(s + _len, len - _len, \": GCC (%d.%d.%d)\",\n               __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);\n#else\n         _len += strlcpy(s + _len, msg_hash_to_str(MSG_UNKNOWN_COMPILER), len - _len);\n#endif\n         _len += snprintf(s + _len, len - _len, \" %u-bit\",\n               (unsigned)(CHAR_BIT * sizeof(size_t)));\n         break;\n      default:\n      case RARCH_CAPABILITIES_NONE:\n         break;\n   }\n   return _len;\n}\n\nvoid retroarch_fail(int error_code, const char *error)\n{\n   global_t *global                = global_get_ptr();\n   /* We cannot longjmp unless we're in retroarch_main_init().\n    * If not, something went very wrong, and we should\n    * just exit right away. */\n   strlcpy(global->error_string, error,\n         sizeof(global->error_string));\n   longjmp(global->error_sjlj_context, error_code);\n}\n\n/* Called on close content, checks if we need to also exit retroarch */\nbool should_quit_on_close(void)\n{\n#ifdef HAVE_MENU\n   settings_t *settings   = config_get_ptr();\n   global_t   *global     = global_get_ptr();\n   if (       ((settings->uints.quit_on_close_content ==\n               QUIT_ON_CLOSE_CONTENT_CLI)\n            && (global->flags & GLOB_FLG_LAUNCHED_FROM_CLI))\n            || (settings->uints.quit_on_close_content ==\n               QUIT_ON_CLOSE_CONTENT_ENABLED)\n      )\n      return true;\n#endif\n   return false;\n}\n\n/*\n * Also saves configuration files to disk,\n * and (optionally) autosave state.\n */\nbool retroarch_main_quit(void)\n{\n   runloop_state_t *runloop_st   = runloop_state_get_ptr();\n   video_driver_state_t*video_st = video_state_get_ptr();\n   settings_t *settings          = config_get_ptr();\n   bool config_save_on_exit      = settings->bools.config_save_on_exit;\n\n   /* Restore video driver before saving */\n   video_driver_restore_cached(settings);\n\n#if !defined(HAVE_DYNAMIC)\n   {\n      /* Salamander sets RUNLOOP_FLAG_SHUTDOWN_INITIATED prior, so we need to handle it separately */\n      /* config_save_file_salamander() must be called independent of config_save_on_exit */\n      config_save_file_salamander();\n      if (config_save_on_exit)\n         command_event(CMD_EVENT_MENU_SAVE_CURRENT_CONFIG, NULL);\n   }\n#endif\n\n#ifdef HAVE_PRESENCE\n   {\n      presence_userdata_t userdata;\n      userdata.status = PRESENCE_SHUTDOWN;\n      command_event(CMD_EVENT_PRESENCE_UPDATE, &userdata);\n   }\n#endif\n#ifdef HAVE_DISCORD\n   {\n      discord_state_t *discord_st = discord_state_get_ptr();\n      if (discord_st->ready)\n      {\n         Discord_ClearPresence();\n#ifdef DISCORD_DISABLE_IO_THREAD\n         Discord_UpdateConnection();\n#endif\n         Discord_Shutdown();\n         discord_st->ready       = false;\n      }\n      discord_st->inited         = false;\n   }\n#endif\n\n   /* Restore original refresh rate, if it has been changed\n    * automatically in SET_SYSTEM_AV_INFO */\n   if (video_st->video_refresh_rate_original)\n      video_display_server_restore_refresh_rate();\n\n   if (!(runloop_st->flags & RUNLOOP_FLAG_SHUTDOWN_INITIATED))\n   {\n      if (   settings->bools.savestate_auto_save\n          && runloop_st->current_core_type != CORE_TYPE_DUMMY)\n         command_event_save_auto_state();\n\n      /* If any save states are in progress, wait\n       * until all tasks are complete (otherwise\n       * save state file may be truncated) */\n      content_wait_for_save_state_task();\n\n      if (     (runloop_st->flags & RUNLOOP_FLAG_REMAPS_CORE_ACTIVE)\n            || (runloop_st->flags & RUNLOOP_FLAG_REMAPS_CONTENT_DIR_ACTIVE)\n            || (runloop_st->flags & RUNLOOP_FLAG_REMAPS_GAME_ACTIVE)\n            || !string_is_empty(runloop_st->name.remapfile)\n         )\n      {\n         input_remapping_deinit(settings->bools.remap_save_on_exit);\n         input_remapping_set_defaults(true);\n      }\n      else\n         input_remapping_restore_global_config(true, false);\n\n#ifdef HAVE_CONFIGFILE\n      if (runloop_st->flags & RUNLOOP_FLAG_OVERRIDES_ACTIVE)\n      {\n         /* Reload the original config */\n         config_unload_override();\n      }\n#endif\n\n      /* Save configs before quitting\n       * as for UWP depending on `OnSuspending` is not important as we can call it directly here\n       * specifically we need to get width,height which requires UI thread and it will not be available on exit\n       */\n#if defined(HAVE_DYNAMIC)\n      if (config_save_on_exit)\n         command_event(CMD_EVENT_MENU_SAVE_CURRENT_CONFIG, NULL);\n#endif\n\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n      runloop_st->runtime_shader_preset_path[0] = '\\0';\n#endif\n   }\n\n   runloop_st->flags |= RUNLOOP_FLAG_SHUTDOWN_INITIATED;\n#ifdef HAVE_MENU\n   retroarch_menu_running_finished(true);\n#endif\n\n   return true;\n}\n\nenum retro_language retroarch_get_language_from_iso(const char *iso639)\n{\n   unsigned i;\n   enum retro_language lang = RETRO_LANGUAGE_ENGLISH;\n\n   struct lang_pair\n   {\n      const char *iso639;\n      enum retro_language lang;\n   };\n\n   const struct lang_pair pairs[] =\n   {\n      {\"ja\", RETRO_LANGUAGE_JAPANESE},\n      {\"fr\", RETRO_LANGUAGE_FRENCH},\n      {\"es\", RETRO_LANGUAGE_SPANISH},\n      {\"de\", RETRO_LANGUAGE_GERMAN},\n      {\"it\", RETRO_LANGUAGE_ITALIAN},\n      {\"nl\", RETRO_LANGUAGE_DUTCH},\n      {\"pt_BR\", RETRO_LANGUAGE_PORTUGUESE_BRAZIL},\n      {\"pt_PT\", RETRO_LANGUAGE_PORTUGUESE_PORTUGAL},\n      {\"pt\", RETRO_LANGUAGE_PORTUGUESE_PORTUGAL},\n      {\"ru\", RETRO_LANGUAGE_RUSSIAN},\n      {\"ko\", RETRO_LANGUAGE_KOREAN},\n      {\"zh_CN\", RETRO_LANGUAGE_CHINESE_SIMPLIFIED},\n      {\"zh_SG\", RETRO_LANGUAGE_CHINESE_SIMPLIFIED},\n      {\"zh_HK\", RETRO_LANGUAGE_CHINESE_TRADITIONAL},\n      {\"zh_TW\", RETRO_LANGUAGE_CHINESE_TRADITIONAL},\n      {\"zh\", RETRO_LANGUAGE_CHINESE_SIMPLIFIED},\n      {\"eo\", RETRO_LANGUAGE_ESPERANTO},\n      {\"pl\", RETRO_LANGUAGE_POLISH},\n      {\"vi\", RETRO_LANGUAGE_VIETNAMESE},\n      {\"ar\", RETRO_LANGUAGE_ARABIC},\n      {\"el\", RETRO_LANGUAGE_GREEK},\n      {\"tr\", RETRO_LANGUAGE_TURKISH},\n      {\"sk\", RETRO_LANGUAGE_SLOVAK},\n      {\"fa\", RETRO_LANGUAGE_PERSIAN},\n      {\"he\", RETRO_LANGUAGE_HEBREW},\n      {\"ast\", RETRO_LANGUAGE_ASTURIAN},\n      {\"fi\", RETRO_LANGUAGE_FINNISH},\n      {\"id\", RETRO_LANGUAGE_INDONESIAN},\n      {\"sv\", RETRO_LANGUAGE_SWEDISH},\n      {\"uk\", RETRO_LANGUAGE_UKRAINIAN},\n      {\"cs\", RETRO_LANGUAGE_CZECH},\n      {\"ca_ES@valencia\", RETRO_LANGUAGE_CATALAN_VALENCIA},\n      {\"en_CA\", RETRO_LANGUAGE_BRITISH_ENGLISH}, /* Canada must be indexed before Catalan's \"ca\". */\n      {\"ca\", RETRO_LANGUAGE_CATALAN},\n      {\"en_GB\", RETRO_LANGUAGE_BRITISH_ENGLISH},\n      {\"en\", RETRO_LANGUAGE_ENGLISH},\n      {\"hu\", RETRO_LANGUAGE_HUNGARIAN},\n      {\"be\", RETRO_LANGUAGE_BELARUSIAN},\n      {\"gl\", RETRO_LANGUAGE_GALICIAN},\n      {\"no\", RETRO_LANGUAGE_NORWEGIAN},\n   };\n\n   if (string_is_empty(iso639))\n      return lang;\n\n   for (i = 0; i < ARRAY_SIZE(pairs); i++)\n   {\n      if (string_starts_with_case_insensitive(iso639, pairs[i].iso639))\n      {\n         lang = pairs[i].lang;\n         break;\n      }\n   }\n\n   return lang;\n}\n\nvoid retroarch_favorites_init(void)\n{\n   settings_t *settings                = config_get_ptr();\n   int content_favorites_size          = settings ? settings->ints.content_favorites_size : 0;\n   const char *path_content_favorites  = settings ? settings->paths.path_content_favorites : NULL;\n   bool playlist_sort_alphabetical     = settings ? settings->bools.playlist_sort_alphabetical : false;\n   playlist_config_t playlist_config;\n   enum playlist_sort_mode current_sort_mode;\n\n   playlist_config.capacity            = COLLECTION_SIZE;\n   playlist_config.old_format          = settings ? settings->bools.playlist_use_old_format : false;\n   playlist_config.compress            = settings ? settings->bools.playlist_compression : false;\n   playlist_config.fuzzy_archive_match = settings ? settings->bools.playlist_fuzzy_archive_match : false;\n   playlist_config_set_base_content_directory(&playlist_config, NULL);\n\n   if (!settings)\n      return;\n\n   if (content_favorites_size >= 0)\n      playlist_config.capacity = (size_t)content_favorites_size;\n\n   retroarch_favorites_deinit();\n\n   if (!playlist_config.capacity)\n      return;\n\n   RARCH_LOG(\"[Playlist]: %s: \\\"%s\\\".\\n\",\n         msg_hash_to_str(MSG_LOADING_FAVORITES_FILE),\n         path_content_favorites);\n   playlist_config_set_path(&playlist_config, path_content_favorites);\n   g_defaults.content_favorites = playlist_init(&playlist_config);\n\n   /* Get current per-playlist sort mode */\n   current_sort_mode = playlist_get_sort_mode(g_defaults.content_favorites);\n\n   /* Ensure that playlist is sorted alphabetically,\n    * if required */\n   if (   (playlist_sort_alphabetical && (current_sort_mode == PLAYLIST_SORT_MODE_DEFAULT))\n       || (current_sort_mode == PLAYLIST_SORT_MODE_ALPHABETICAL))\n      playlist_qsort(g_defaults.content_favorites);\n}\n\nvoid retroarch_favorites_deinit(void)\n{\n   if (!g_defaults.content_favorites)\n      return;\n\n   playlist_write_file(g_defaults.content_favorites);\n   playlist_free(g_defaults.content_favorites);\n   g_defaults.content_favorites = NULL;\n}\n\n#ifdef HAVE_ACCESSIBILITY\nbool accessibility_speak_priority(\n      bool accessibility_enable,\n      unsigned accessibility_narrator_speech_speed,\n      const char* speak_text, int priority)\n{\n   access_state_t *access_st   = access_state_get_ptr();\n   if (is_accessibility_enabled(\n            accessibility_enable,\n            access_st->enabled))\n   {\n\n      frontend_ctx_driver_t *frontend =\n         frontend_state_get_ptr()->current_frontend_ctx;\n\n      RARCH_LOG(\"Spoke: %s\\n\", speak_text);\n\n      if (frontend && frontend->accessibility_speak)\n         return frontend->accessibility_speak(accessibility_narrator_speech_speed, speak_text,\n               priority);\n      /* The following method is a fallback for other platforms to use the\n         AI Service url to do the TTS.  However, since the playback is done\n         via the audio mixer, which only processes the audio while the\n         core is running, this playback method won't work.  When the audio\n         mixer can handle playing streams while the core is paused, then\n         we can use this. */\n#if 0\n#if defined(HAVE_NETWORKING)\n         return accessibility_speak_ai_service(speak_text, voice, priority);\n#endif\n#endif\n   }\n\n   return true;\n}\n\n#endif\n"
        },
        {
          "name": "retroarch.cfg",
          "type": "blob",
          "size": 33.3935546875,
          "content": "## Skeleton config file for RetroArch\n\n# If set to a directory, the content history playlist will be saved\n# to this directory.\n# content_history_dir =\n\n# Automatically saves a savestate at the end of RetroArch's lifetime.\n# The path is $SRAM_PATH.auto.\n# RetroArch will automatically load any savestate with this path on startup if savestate_auto_load is set.\n# savestate_auto_save = false\n# savestate_auto_load = true\n\n# Load libretro from a dynamic location for dynamically built RetroArch.\n# This option is mandatory.\n\n# Path to a libretro implementation.\n# libretro_path = \"/path/to/libretro.so\"\n\n# Sets log level for libretro cores (GET_LOG_INTERFACE).\n# If a log level issued by a libretro core is below libretro_log_level, it is ignored.\n# DEBUG logs are always ignored unless verbose mode is activated (--verbose).\n# DEBUG = 0, INFO = 1, WARN = 2, ERROR = 3.\n# libretro_log_level = 0\n\n# Enable or disable verbosity level of frontend.\n# log_verbosity = false\n\n# If this option is enabled, every content file loaded in RetroArch will be\n# automatically added to a history list.\n# history_list_enable = true\n\n# Enable performance counters\n# perfcnt_enable = false\n\n# Path to core options config file.\n# This config file is used to expose core-specific options.\n# It will be written to by RetroArch.\n# A default path will be assigned if not set.\n# core_options_path =\n\n# Path to content history file.\n# RetroArch keeps track of all content loaded in the menu and from CLI directly for convenient quick loading.\n# A default path will be assigned if not set.\n# content_history_path =\n\n# Path to music content history file (optional).\n# RetroArch keeps track of all music content loaded in the menu and from CLI directly for convenient quick loading.\n# A default path will be assigned if not set.\n# content_music_history_path =\n\n# Path to image content history file (optional).\n# RetroArch keeps track of all image content loaded in the menu and from CLI directly for convenient quick loading.\n# A default path will be assigned if not set.\n# content_image_history_path =\n\n# Path to video content history file (optional).\n# RetroArch keeps track of all video content loaded in the menu and from CLI directly for convenient quick loading.\n# A default path will be assigned if not set.\n# content_video_history_path =\n\n# Number of entries that will be kept in content history file.\n# content_history_size = 200\n\n# Content directory. Interacts with RETRO_ENVIRONMENT_GET_CONTENT_DIRECTORY.\n# Usually set by developers who bundle libretro/RetroArch apps to point to assets.\n# content_directory =\n\n# Sets start directory for menu config browser.\n# rgui_config_directory =\n\n# Show startup screen in menu.\n# Is automatically set to false when seen for the first time.\n# This is only updated in config if config_save_on_exit is set to true, however.\n# rgui_show_start_screen = true\n\n# Flushes config to disk on exit. Useful for menu as settings can be modified.\n# Overwrites the config. #include's and comments are not preserved.\n# config_save_on_exit = true\n\n# Shows hidden files and folders in directory listings.\n# show_hidden_files = false\n\n#### Driver\n\n# Input driver. Depending on video driver, it might force a different input driver.\n# input_driver = sdl\n\n# Joypad driver. (\"udev\", \"linuxraw\", \"paraport\", \"sdl2\", \"hid\", \"dinput\")\n# input_joypad_driver =\n\n# Video driver to use. \"gl\", \"xvideo\", \"sdl\", \"d3d\"\n# video_driver = \"gl\"\n\n# Which context implementation to use.\n# Possible ones for desktop are: glx, x-egl, kms-egl, sdl-gl, wgl.\n# By default, tries to use first suitable driver.\n# video_context_driver =\n\n# Audio driver backend. Depending on configuration possible candidates are: alsa, pulse, oss, jack, rsound, roar, openal, sdl, xaudio.\n# audio_driver =\n\n# Audio resampler driver backend. Which audio resampler to use.\n# Default will use \"sinc\".\n# audio_resampler =\n\n# Camera driver.\n# camera_driver =\n\n# Location driver.\n# location_driver =\n\n# Menu driver to use. (\"rgui\", \"xmb\", \"glui\")\n# menu_driver = \"rgui\"\n\n# Record driver. Used when recording video.\n# record_driver =\n\n#### Video\n\n# Suspends the screensaver if set to true. Is a hint that does not necessarily have to be honored\n# by video driver.\n# suspend_screensaver_enable  = true\n\n# Display framerate.\n# fps_show = false\n\n# Display memory.\n# memory_show = false\n\n# Display total number of frames rendered. (only displays if fps_show is enabled)\n# framecount_show =\n\n# Which monitor to prefer. 0 (default) means no particular monitor is preferred, 1 and up (1 being first monitor),\n# suggests RetroArch to use that particular monitor.\n# video_monitor_index = 0\n\n# Start in fullscreen. Can be changed at runtime.\n# video_fullscreen = false\n\n# If fullscreen, prefer using a windowed fullscreen mode.\n# video_windowed_fullscreen = true\n\n# Fullscreen resolution. Resolution of 0 uses the resolution of the desktop.\n# video_fullscreen_x = 0\n# video_fullscreen_y = 0\n\n# Video refresh rate of your CRT monitor.\n# Used to calculate a suitable audio input rate.\n# crt_video_refresh_rate = 59.94\n\n# Video refresh rate of your monitor.\n# Used to calculate a suitable audio input rate.\n# video_refresh_rate = 59.94\n\n# Forcibly disable sRGB FBO support. Some Intel OpenGL drivers on Windows\n# have video problems with sRGB FBO support enabled.\n# video_force_srgb_disable = false\n\n# If this is true and video_aspect_ratio is not set,\n# aspect ratio is decided by libretro implementation.\n# If this is false, 1:1 PAR will always be assumed if video_aspect_ratio is not set.\n# video_aspect_ratio_auto = false\n\n# A floating point value for video aspect ratio (width / height).\n# If this is not set, aspect ratio is assumed to be automatic.\n# Behavior then is defined by video_aspect_ratio_auto.\n# video_aspect_ratio =\n\n# Windowed x resolution scale and y resolution scale\n# (Real x res: base_size * xscale * aspect_ratio, real y res: base_size * yscale)\n# video_scale = 3.0\n\n# Percentage of opacity to use for the window (100 is completely opaque).\n# video_window_opacity = 100\n\n# Whether to enable the default window decorations like border, titlebar etc.\n# video_window_show_decorations = true\n\n# Forcibly disable composition. Only works in Windows Vista/7 for now.\n# video_disable_composition = false\n\n# Video vsync.\n# video_vsync = true\n\n# Interval at which a Vsync swap is performed.\n# 1 is normal, 2 is doubled frames, 3 is tripled frames, etc.\n# video_swap_interval = 1\n\n# Max amount of swapchain images.\n# Single buffering = 1, Double buffering = 2, 3 = Triple buffering\n# video_max_swapchain_images = 3\n\n# Attempts to hard-synchronize CPU and GPU. Can reduce latency at cost of performance.\n# video_hard_sync = false\n\n# Sets how many frames CPU can run ahead of GPU when using video_hard_sync.\n# Maximum is 3.\n# video_hard_sync_frames = 0\n\n# Sets how many milliseconds to delay after VSync before running the core.\n# Can reduce latency at cost of higher risk of stuttering.\n# Maximum is 15.\n# video_frame_delay = 0\n\n# Inserts a black frame inbetween frames.\n# Useful for 120 Hz monitors who want to play 60 Hz material with eliminated ghosting.\n# video_refresh_rate should still be configured as if it is a 60 Hz monitor (divide refresh rate by 2).\n# video_black_frame_insertion = false\n\n# Use threaded video driver. Using this might improve performance at possible cost of latency and more video stuttering.\n# video_threaded = false\n\n# Use a shared context for HW rendered libretro cores.\n# Avoids having to assume HW state changes inbetween frames.\n# video_shared_context = false\n\n# Smoothens picture with bilinear filtering. Should be disabled if using pixel shaders.\n# video_smooth = true\n\n# Forces rendering area to stay equal to content aspect ratio or as defined in video_aspect_ratio.\n# video_force_aspect = true\n\n# Only scales video in integer steps.\n# The base size depends on system-reported geometry and aspect ratio.\n# If video_force_aspect is not set, X/Y will be integer scaled independently.\n# video_scale_integer = false\n\n# Index of the aspect ratio selection in the menu.\n# 20 = Config, 21 = 1:1 PAR, 22 = Core Provided, 23 = Custom Aspect Ratio\n# aspect_ratio_index = 20\n\n# Forces cropping of overscanned frames.\n# Exact behavior of this option is implementation specific.\n# video_crop_overscan = true\n\n# Path to shader. Shader can be either Cg, CGP (Cg preset) or GLSL, GLSLP (GLSL preset)\n# video_shader = \"/path/to/shader.{cg,cgp,glsl,glslp}\"\n\n# Load video_shader on startup.\n# Other shaders can still be loaded later in runtime.\n# video_shader_enable = false\n\n# CPU-based video filter. Path to a dynamic library.\n# video_filter =\n\n# Path to a font used for rendering messages. This path must be defined to enable fonts.\n# Do note that the _full_ path of the font is necessary!\n# video_font_path =\n\n# Size of the font rendered in points.\n# video_font_size = 32\n\n# Enable usage of OSD messages.\n# video_font_enable = true\n\n# Offset for where messages will be placed on screen. Values are in range 0.0 to 1.0 for both x and y values.\n# [0.0, 0.0] maps to the lower left corner of the screen.\n# video_message_pos_x = 0.05\n# video_message_pos_y = 0.05\n\n# Color for message. The value is treated as a hexadecimal value.\n# It is a regular RGB hex number, i.e. red is \"ff0000\".\n# video_message_color = ffffff\n\n# Background color for OSD messages. Red/Green/Blue values are from 0 to 255 and opacity is 0.0 to 1.0.\n# video_message_bgcolor_enable = false\n# video_message_bgcolor_red = 0\n# video_message_bgcolor_green = 0\n# video_message_bgcolor_blue = 0\n# video_message_bgcolor_opacity = 1.0\n\n# Allows libretro cores to set rotation modes.\n# Setting this to false will honor, but ignore this request.\n# This is useful for vertically oriented content where one manually rotates the monitor.\n# video_allow_rotate = true\n\n# Forces a certain rotation of the video.\n# The rotation is added to rotations which the libretro core sets (see video_allow_rotate).\n# The angle is <value> * 90 degrees counter-clockwise.\n# video_rotation = 0\n\n# Forces a certain orientation of the screen from the operating system.\n# The angle is <value> * 90 degrees counter-clockwise.\n# screen_orientation = 0\n\n# HDR settings\n# video_hdr_enable            = false\n# video_hdr_max_nits          = 1000.0f\n# video_hdr_paper_white_nits  = 200.0f\n# video_hdr_contrast          = 1.0f\n# video_hdr_expand_gamut      = true\n\n#### Audio\n\n# Enable audio.\n# audio_enable = true\n\n# Enable menu audio sounds.\n# audio_enable_menu = false\n# audio_enable_menu_ok = false\n# audio_enable_menu_cancel = false\n# audio_enable_menu_notice = false\n# audio_enable_menu_bgm = false\n\n# Mutes audio.\n# audio_mute_enable = false\n\n# Mutes audio mixer volume globally.\n# audio_mixer_mute_enable = false\n\n# Audio output samplerate.\n# audio_out_rate = 48000\n\n# Override the default audio device the audio_driver uses. This is driver dependant. E.g. ALSA wants a PCM device, OSS wants a path (e.g. /dev/dsp), Jack wants portnames (e.g. system:playback1,system:playback_2), and so on ...\n# audio_device =\n\n# Audio DSP plugin that processes audio before it's sent to the driver. Path to a dynamic library.\n# audio_dsp_plugin =\n\n# Will sync (block) on audio. Recommended.\n# audio_sync = true\n\n# Desired audio latency in milliseconds. Might not be honored if driver can't provide given latency.\n# audio_latency = 64\n\n# Enable audio rate control.\n# audio_rate_control = true\n\n# Controls audio rate control delta. Defines how much input rate can be adjusted dynamically.\n# Input rate = in_rate * (1.0 +/- audio_rate_control_delta)\n# audio_rate_control_delta = 0.005\n\n# Controls maximum audio timing skew. Defines the maximum change in input rate.\n# Input rate = in_rate * (1.0 +/- max_timing_skew)\n# audio_max_timing_skew = 0.05\n\n# Audio volume. Volume is expressed in dB.\n# 0 dB is normal volume. No gain will be applied.\n# Gain can be controlled in runtime with input_volume_up/input_volume_down.\n# audio_volume = 0.0\n\n# Audio mixer volume. Volume is expressed in dB.\n# 0 dB is normal volume. No gain will be applied.\n# audio_mixer_volume = 0.0\n\n#### Microphone\n\n# Enable microphone support.\n# microphone_enable = true\n\n# Desired microphone latency in milliseconds. Might not be honored if driver can't provide given latency.\n# microphone_latency = 64\n\n#### Overlay\n\n# Enable the overlay.\n# input_overlay_enable = true\n\n# Show the overlay behind the menu instead of in front.\n# input_overlay_behind_menu = \"false\"\n\n# Hide the current overlay from appearing inside the menu.\n# input_overlay_hide_in_menu = true\n\n# Path to input overlay.\n# input_overlay =\n\n# Opacity of all the UI elements of the overlay.\n# input_overlay_opacity = 1.0\n\n# Scale of all UI elements of the overlay.\n# input_overlay_scale = 1.0\n\n# Center of all UI elements of the overlay.\n# input_overlay_center_x = 0.5\n# input_overlay_center_y = 0.5\n\n#### Input\n\n# Path to input remapping file.\n# input_remapping_path =\n\n# Input bind timer timeout.\n# Amount of seconds to wait until proceeding to the next bind. Default: 5, minimum: 1\n# input_bind_timeout = 1\n\n# If enabled, overrides the input binds with the remapped binds set for the current core.\n# input_remap_binds_enable = true\n\n# Maximum amount of users supported by RetroArch.\n# input_max_users = 16\n\n# Keyboard layout for input driver if applicable (udev/evdev for now).\n# Syntax is either just layout (e.g. \"no\"), or a layout and variant separated with colon (\"no:nodeadkeys\").\n# input_keyboard_layout =\n\n# Defines axis threshold. Possible values are [0.0, 1.0]\n# input_axis_threshold = 0.5\n\n# input_analog_deadzone = 0.0\n\n# input_analog_sensitivity = 1.0\n\n# Enable input auto-detection. Will attempt to autoconfigure\n# joypads, Plug-and-Play style.\n# input_autodetect_enable = true\n\n# Show the input descriptors set by the core instead of the\n# default ones.\n# input_descriptor_label_show = true\n\n# Hide input descriptors that were not set by the core.\n# input_descriptor_hide_unbound = false\n\n# Influence how input polling is done inside RetroArch.\n# 0 : Early  - Input polling is performed before call to retro_run.\n# 1 : Normal - Input polling is performed when retro_input_poll is\n#     requested.\n# 2 : Late   - Input polling is performed on first call to retro_input_state\n#     per frame\n#\n# Setting it to 0 or 2 can result in less latency depending on\n# your configuration.\n#\n# When netplay is enabled, the default polling behavior (1) will\n# be used regardless of the value set here.\n# input_poll_type_behavior = 1\n\n# Sets which libretro device is used for a user.\n# Devices are indentified with a number.\n# This is normally saved by the menu.\n# Device IDs are found in libretro.h.\n# These settings are overridden by explicit command-line arguments which refer to input devices.\n# None: 0\n# Joypad (RetroPad): 1\n# Mouse: 2\n# Keyboard: 3\n# Generic Lightgun: 4\n# Joypad w/ Analog (RetroPad + Analog sticks): 5\n# Multitap (SNES specific): 257\n# Super Scope (SNES specific): 260\n# Justifier (SNES specific): 516\n# Justifiers (SNES specific): 772\n\n# input_libretro_device_p1 =\n# input_libretro_device_p2 =\n# input_libretro_device_p3 =\n# input_libretro_device_p4 =\n# input_libretro_device_p5 =\n# input_libretro_device_p6 =\n# input_libretro_device_p7 =\n# input_libretro_device_p8 =\n\n# Keyboard input. Will recognize letters (\"a\" to \"z\") and the following special keys (where \"kp_\"\n# is for keypad keys):\n#\n#   left, right, up, down, enter, kp_enter, tab, insert, del, end, home,\n#   rshift, shift, ctrl, alt, space, escape, add, subtract, kp_plus, kp_minus,\n#   f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12,\n#   num0, num1, num2, num3, num4, num5, num6, num7, num8, num9, pageup, pagedown,\n#   keypad0, keypad1, keypad2, keypad3, keypad4, keypad5, keypad6, keypad7, keypad8, keypad9,\n#   period, capslock, numlock, backspace, multiply, divide, print_screen, scroll_lock,\n#   tilde, backquote, pause, quote, comma, minus, slash, semicolon, equals, leftbracket,\n#   backslash, rightbracket, kp_period, kp_equals, rctrl, ralt\n#\n# Keyboard input, Joypad and Joyaxis will all obey the \"nul\" bind, which disables the bind completely,\n# rather than relying on a default.\n# input_player1_a = \"x\"\n# input_player1_b = \"z\"\n# input_player1_y = \"a\"\n# input_player1_x = \"s\"\n# input_player1_start = \"enter\"\n# input_player1_select = \"rshift\"\n# input_player1_l = \"q\"\n# input_player1_r = \"w\"\n# input_player1_left = \"left\"\n# input_player1_right = \"right\"\n# input_player1_up = \"up\"\n# input_player1_down = \"down\"\n# input_player1_l2 =\n# input_player1_r2 =\n# input_player1_l3 =\n# input_player1_r3 =\n\n# Two analog sticks (DualShock-esque).\n# Bound as usual, however, if a real analog axis is bound,\n# it can be read as a true analog.\n# Positive X axis is right, Positive Y axis is down.\n# input_player1_l_x_plus =\n# input_player1_l_x_minus =\n# input_player1_l_y_plus =\n# input_player1_l_y_minus =\n# input_player1_r_x_plus =\n# input_player1_r_x_minus =\n# input_player1_r_y_plus =\n# input_player1_r_y_minus =\n\n# If desired, it is possible to override which joypads are being used for user 1 through 8.\n# First joypad available is 0.\n# input_player1_joypad_index = 0\n# input_player2_joypad_index = 1\n# input_player3_joypad_index = 2\n# input_player4_joypad_index = 3\n# input_player5_joypad_index = 4\n# input_player6_joypad_index = 5\n# input_player7_joypad_index = 6\n# input_player8_joypad_index = 7\n\n# Input device buttons.\n# Figure these out by using the RetroArch configuration menu\n# You can use joypad hats with hnxx, where n is the hat, and xx is a string representing direction.\n# E.g. \"h0up\"\n# input_player1_a_btn =\n# input_player1_b_btn =\n# input_player1_y_btn =\n# input_player1_x_btn =\n# input_player1_start_btn =\n# input_player1_select_btn =\n# input_player1_l_btn =\n# input_player1_r_btn =\n# input_player1_left_btn =\n# input_player1_right_btn =\n# input_player1_up_btn =\n# input_player1_down_btn =\n# input_player1_l2_btn =\n# input_player1_r2_btn =\n# input_player1_l3_btn =\n# input_player1_r3_btn =\n\n# Menu buttons.\n# menu_search_btn      =\n# menu_info_btn        =\n# menu_default_btn     =\n# menu_scroll_down_btn =\n# menu_scroll_up_btn   =\n\n# Swap buttons for OK/Cancel\n# menu_swap_ok_cancel_buttons = false\n\n# Swap buttons for scrolling (10 items vs alphabetical)\n# menu_swap_scroll_buttons = false\n\n# Axis for RetroArch D-Pad.\n# Needs to be either '+' or '-' in the first character signaling either positive or negative direction of the axis, then the axis number.\n# Do note that every other input option has the corresponding _btn and _axis binds as well; they are omitted here for clarity.\n# input_player1_left_axis =\n# input_player1_right_axis =\n# input_player1_up_axis =\n# input_player1_down_axis =\n\n# Holding the turbo while pressing another button will let the button enter a turbo mode\n# where the button state is modulated with a periodic signal.\n# The modulation stops when the button itself (not turbo button) is released.\n# input_player1_turbo =\n\n# Describes the period and how long of that period a turbo-enabled button should behave.\n# Numbers are described in frames.\n# input_turbo_period = 6\n# input_turbo_duty_cycle = 3\n\n# This goes all the way to user 8 (*_player2_*, *_player3_*, etc), but omitted for clarity.\n# All input binds have corresponding binds for keyboard (none), joykeys (_btn) and joyaxes (_axis) as well.\n\n# Toggles fullscreen.\n# input_toggle_fullscreen = f\n\n# Saves state.\n# input_save_state = f2\n# Loads state.\n# input_load_state = f4\n\n# State slots. With slot set to 0, save state name is *.state (or whatever defined on commandline).\n# When slot is != 0, path will be $path%d, where %d is slot number.\n# input_state_slot_increase = f7\n# input_state_slot_decrease = f6\n\n# Toggles between fast-forwarding and normal speed.\n# input_toggle_fast_forward = space\n\n# Hold for fast-forward. Releasing button disables fast-forward.\n# input_hold_fast_forward = l\n\n# Key to exit RetroArch cleanly.\n# Killing it in any hard way (SIGKILL, etc) will terminate RetroArch without saving RAM, etc.\n# On Unix-likes, SIGINT/SIGTERM allows a clean deinitialization.\n# input_exit_emulator = escape\n\n# Applies next and previous shader in directory.\n# input_shader_next = m\n# input_shader_prev = n\n# input_shader_toggle = comma\n\n# Hold button down to rewind. Rewinding must be enabled.\n# input_rewind = r\n\n# Toggle between recording and not.\n# input_movie_record_toggle = o\n\n# Toggle between paused and non-paused state\n# input_pause_toggle = p\n\n# Frame advance when content is paused\n# input_frame_advance = k\n\n# Reset the content.\n# input_reset = h\n\n# Cheats.\n# input_cheat_index_plus = y\n# input_cheat_index_minus = t\n# input_cheat_toggle = u\n\n# Mute/unmute audio\n# input_audio_mute = f9\n\n# Take screenshot\n# input_screenshot = f8\n\n# Netplay flip users.\n# input_netplay_flip_players = i\n\n# Hold for slowmotion.\n# input_slowmotion = e\n\n# Toggles sync to exact content framerate.\n# input_toggle_vrr_runloop =\n\n# Enable other hotkeys.\n# If this hotkey is bound to either keyboard, joybutton or joyaxis,\n# all other hotkeys will be disabled unless this hotkey is also held at the same time.\n# This is useful for RETRO_KEYBOARD centric implementations\n# which query a large area of the keyboard, where it is not desirable\n# that hotkeys get in the way.\n\n# Alternatively, all hotkeys for keyboard could be disabled by the user.\n# input_enable_hotkey_btn =\n\n# Adds a delay in frames before the assigned hotkey blocks input.  Useful if the the\n# hotkey input is mapped to another action.\n# input_hotkey_block_delay = \"5\"\n\n# Increases audio volume.\n# input_volume_up = kp_plus\n# Decreases audio volume.\n# input_volume_down = kp_minus\n\n# Toggles to next overlay. Wraps around.\n# input_overlay_next =\n\n# Toggles eject for disks. Used for multiple-disk content.\n# input_disk_eject_toggle =\n\n# Cycles through disk images. Use after ejecting.\n# Complete by toggling eject again.\n# input_disk_next =\n\n# Toggles menu.\n# input_menu_toggle = f1\n\n# Toggles display of on-screen technical statistics.\n# input_toggle_statistics =\n\n# RetroPad button combination to toggle menu\n# 0: None\n# 1: Down + Y + L1 + R1\n# 2: L3 + R3\n# 3: L1 + R1 + Start + Select\n# 4: Start + Select\n# 5: L3 + R1\n# 6: L1 + R1\n# 7: Hold Start (2 seconds)\n# 8: Hold Select (2 seconds)\n# 9: Down + Select\n# 10: L2 + R2\n# input_menu_toggle_gamepad_combo = 0\n\n# RetroPad button combination to quit\n# 0: None\n# 1: Down + Y + L1 + R1\n# 2: L3 + R3\n# 3: L1 + R1 + Start + Select\n# 4: Start + Select\n# 5: L3 + R1\n# 6: L1 + R1\n# 7: Hold Start (2 seconds)\n# 8: Hold Select (2 seconds)\n# 9: Down + Select\n# 10: L2 + R2\n# input_quit_gamepad_combo = 0\n\n# allow any RetroPad to control the menu\n# all_users_control_menu = false\n\n# Toggles mouse grab. When mouse is grabbed, RetroArch hides the mouse,\n# and keeps the mouse pointer inside the window to allow relative mouse input\n# to work better.\n# input_grab_mouse_toggle = f11\n\n#### Menu\n\n# If disabled, will hide 'Online Updater' inside the menu.\n# menu_show_online_updater = true\n\n# If disabled, will hide the ability to update cores (and core info files) inside the menu.\n# menu_show_core_updater = true\n\n# If disabled, the libretro core will keep running in the background when we\n# are in the menu.\n# menu_pause_libretro = false\n\n# If disabled, we use separate controls for menu operation.\n# menu_unified_controls = false\n\n# Enable mouse controls inside the menu.\n# menu_mouse_enable = false\n\n# Enable touch controls inside the menu.\n# menu_pointer_enable = false\n\n# Shows current date and/or time inside menu.\n# menu_timedate_enable = true\n\n# Shows current battery level inside menu.\n# menu_battery_level_enable = true\n\n# Shows current core inside menu.\n# menu_core_enable = true\n\n# Path to an image to set as menu wallpaper.\n# menu_wallpaper =\n\n# Dynamically load a new wallpaper depending on context.\n# menu_dynamic_wallpaper_enable = false\n\n# Type of thumbnail to display. 0 = none, 1 = snaps, 2 = titles, 3 = boxarts,  4 = logos\n# menu_thumbnails = 0\n# menu_left_thumbnails = 0\n\n# Wrap-around to beginning and/or end if boundary of list is reached horizontally or vertically.\n# menu_navigation_wraparound_enable = false\n\n# Filter files being shown in filebrowser by supported extensions.\n# menu_navigation_browser_filter_supported_extensions_enable = true\n\n# Collapse subgroup settings into main group to create one big listing of settings\n# per category.\n# menu_collapse_subgroups_enable = false\n\n#### Core\n#\n# Prevent libretro cores from closing RetroArch on exit by loading a dummy core.\n# load_dummy_on_core_shutdown = \"true\"\n\n# Check for firmware requirement(s) before loading a content.\n# check_firmware_before_loading = \"false\"\n\n#### User Interface\n\n# Start UI companion driver's interface on boot (if available).\n# ui_companion_start_on_boot  = true\n\n# Toggle companion UI on startup (currently only used to show the WIMP UI)\n# ui_companion_toggle = false\n\n# Only init the WIMP UI for this session if this is enabled\n# desktop_menu_enable = true\n\n#### Camera\n\n# Override the default camera device the camera driver uses. This is driver dependant.\n# camera_device =\n\n# Override the default privacy permission for cores that want to access camera services. Is \"false\" by default.\n# camera_allow = false\n\n#### Location\n\n# Override the default privacy permission for cores that want to access location services. Is \"false\" by default.\n# location_allow = false\n\n#### Core Updater\n\n# URL to core update directory on buildbot.\n# core_updater_buildbot_url = \"http://buildbot.libretro.com\"\n\n# URL to assets update directory on buildbot.\n# core_updater_buildbot_assets_url = \"http://buildbot.libretro.com/assets/\"\n\n# After downloading, automatically extract archives that the downloads are contained inside.\n# core_updater_auto_extract_archive = true\n\n#### Network\n\n# When being client over netplay, use keybinds for user 1.\n# netplay_client_swap_input = false\n\n# The username of the person running RetroArch. This will be used for playing online, for instance.\n# netplay_nickname =\n\n# The amount of delay frames to use for netplay. Increasing this value will increase\n# performance, but introduce more latency.\n# netplay_delay_frames = 0\n\n# Netplay mode for the current user.\n# false is Server, true is Client.\n# netplay_mode = false\n\n# Enable or disable spectator mode for the user during netplay.\n# netplay_spectator_mode_enable = false\n\n# The IP Address of the host to connect to.\n# netplay_ip_address =\n\n# The port of the host IP Address. Can be either a TCP or UDP port.\n# netplay_ip_port = 55435\n\n# Force game hosting to go through a man-in-the-middle server to get around firewalls and NAT/UPnP problems.\n# netplay_use_mitm_server = false\n\n# The requested MITM server to use.\n# netplay_mitm_server = \"nyc\"\n\n#### Directory\n\n# Sets the System/BIOS directory.\n# Implementations can query for this directory to load BIOSes, system-specific configs, etc.\n# system_directory =\n\n# Save all downloaded files to this directory.\n# core_assets_directory =\n\n# Assets directory. This location is queried by default when menu interfaces try to look for\n# loadable assets, etc.\n# assets_directory =\n\n# Dynamic wallpapers directory. The place to store the wallpapers dynamically\n# loaded by the menu depending on context.\n# dynamic_wallpapers_directory =\n\n# Thumbnails directory. To store thumbnail files.\n# thumbnails_directory =\n\n# File browser directory. Sets start directory for menu file browser.\n# rgui_browser_directory =\n\n# Core directory for libretro core implementations.\n# libretro_directory =\n\n# Core info directory for libretro core information.\n# libretro_info_path =\n\n# Path to content database directory.\n# content_database_path =\n\n# Path to cheat database directory.\n# cheat_database_path =\n\n# Defines a directory where CPU-based video filters are kept.\n# video_filter_dir =\n\n# Directory where DSP plugins are kept.\n# audio_filter_dir =\n\n# Defines a directory where shaders (Cg, CGP, GLSL) are kept for easy access.\n# video_shader_dir =\n\n# Recording output directory. Where recordings are saved.\n# recording_output_directory =\n\n# Recording config directory. Where recording settings are kept.\n# recording_config_directory =\n\n# Overlay directory. Where overlays are kept for easy access.\n# overlay_directory =\n\n# Directory to dump screenshots to.\n# screenshot_directory =\n\n# Directory for joypad autoconfigs.\n# If a joypad is plugged in, that joypad will be autoconfigured if a config file\n# corresponding to that joypad is present in joypad_autoconfig_dir.\n# Input binds which are made explicit (input_playerN_*_btn/axis) will take priority over autoconfigs.\n# Autoconfigs can be created with manually, or with the frontend.\n# Requires input_autodetect_enable to be enabled.\n# joypad_autoconfig_dir =\n\n# Save all remapped controls to this directory.\n# input_remapping_directory =\n\n# Save all playlists/collections to this directory.\n# playlist_directory =\n\n# Save all save files (*.srm) to this directory. This includes related files like .bsv, .rtc, .psrm, etc ...\n# This will be overridden by explicit command line options.\n# savefile_directory =\n\n# Save all save states (*.state) to this directory.\n# This will be overridden by explicit command line options.\n# savestate_directory =\n\n# If set to a directory, content which is temporarily extracted\n# will be extracted to this directory.\n# cache_directory =\n\n#### RetroAchievements\n\n# Enable the RetroAchievements feature.\n# cheevos_enable = false\n\n# RetroAchievements.org credentials.\n# cheevos_username =\n# cheevos_password =\n\n# Show a popup when logging in to RetroAchievements.\n# cheevos_visibility_account = true\n\n# The hardcore mode disables savestates and cheating features. Achievements\n# earned in hardcore mode are uniquely marked so that you can show others\n# what you've achieved without emulator assistance features.\n# cheevos_hardcore_mode_enable = true\n\n# Show a popup when an achievement is unlocked.\n# cheevos_visibility_unlock = true\n\n# Play the 'unlock' audio sound when an achievement is unlocked.\n# cheevos_unlock_sound_enable = false\n\n# Take a screenshot when an achievement is triggered.\n# cheevos_auto_screenshot = false\n\n# Show a popup when all achievements for a game are unlocked.\n# cheevos_visibility_mastery = true\n\n# Shows additional diagnostic and error messages\n# cheevos_verbose_enable = false\n\n# Show achievements' badges in Quick Menu > Achievements List.\n# (note: has no effect if menu_driver = rgui).\n# cheevos_badges_enable = false\n\n# Show an on-screen indicator when attempting challenging achievements\n# to provide feedback when the attempt has failed (for achievements that\n# support it)\n# cheevos_challenge_indicators = true\n\n# Shows a message when a leaderboard activates.\n# cheevos_visibility_lboard_start = true\n\n# Shows a message with your score when a leaderboard is submitted to the server.\n# cheevos_visibility_lboard_submit = true\n\n# Shows an on-screen tracker with the current value of active leaderboards.\n# cheevos_visibility_lboard_trackers = true\n\n# Send some messages to the RetroAchievements.org saying, for example,\n# where you are in the game, how many lives you have, your score, etc.\n# cheevos_richpresence_enable = true\n\n# Even after unlocking achievements in previous sessions, you may still want\n# to see them triggering in the current session. (encore mode)\n# cheevos_start_active = false\n\n# Unnoficial achievements are used only for achievement creators and testers.\n# cheevos_test_unofficial = false\n\n#### Misc\n\n# Enable rewinding. This will take a performance hit when playing, so it is disabled by default.\n# rewind_enable = false\n\n# Rewinding buffer size in megabytes. Bigger rewinding buffer means you can rewind longer.\n# The buffer should be approx. 20MB per minute of buffer time.\n# rewind_buffer_size = 20\n\n# Rewind granularity. When rewinding defined number of frames, you can rewind several frames at a time, increasing the rewinding speed.\n# rewind_granularity = 1\n\n# Pause gameplay when window focus is lost.\n# pause_nonactive = true\n\n# Pause gameplay when controller disconnects.\n# pause_on_disconnect = true\n\n# Autosaves the non-volatile SRAM at a regular interval. This is disabled by default unless set otherwise.\n# The interval is measured in seconds. A value of 0 disables autosave.\n# autosave_interval =\n\n# Records video after CPU video filter.\n# video_post_filter_record = false\n\n# Records output of GPU shaded material if available.\n# video_gpu_record = false\n\n# Screenshots output of GPU shaded material if available.\n# video_gpu_screenshot = true\n\n# Watch content shader files for changes and auto-apply as necessary.\n# video_shader_watch_files = false\n\n# Block SRAM from being overwritten when loading save states.\n# Might potentially lead to buggy games.\n# block_sram_overwrite = false\n\n# When saving a savestate, save state index is automatically increased before\n# it is saved.\n# Also, when loading content, the index will be set to the highest existing index.\n# There is no upper bound on the index.\n# savestate_auto_index = false\n\n# Slowmotion ratio. When slowmotion, content will slow down by factor.\n# slowmotion_ratio = 3.0\n\n# The maximum rate at which content will be run when using fast forward. (E.g. 5.0 for 60 fps content => 300 fps cap).\n# RetroArch will go to sleep to ensure that the maximum rate will not be exceeded.\n# Do not rely on this cap to be perfectly accurate.\n# If this is set at 0, then fastforward ratio is unlimited (no FPS cap)\n# fastforward_ratio = 0.0\n\n# Enable stdin/network command interface.\n# network_cmd_enable = false\n# network_cmd_port = 55355\n# stdin_cmd_enable = false\n\n# Enable Sustained Performance Mode in Android 7.0+\n# sustained_performance_mode = true\n\n# File format to use when writing playlists to disk\n# playlist_use_old_format = false\n\n# Keep track of how long each core+content has been running for over time\n# content_runtime_log = false\n\n# vibrate_on_keypress = false\n\n# Enable device vibration for supported cores\n# enable_device_vibration = false\n\n# Enable game mode on supported platforms.\n# Depending on the system, it can result in more stable frame times, less audio\n# crackling, better performance and lower latency. On Linux, Feral GameMode\n# needs to be installed (https://github.com/FeralInteractive/gamemode).\n#\n# gamemode_enable = true\n"
        },
        {
          "name": "retroarch.h",
          "type": "blob",
          "size": 7.2041015625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2021 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __RETROARCH_H\n#define __RETROARCH_H\n\n#include <stdint.h>\n#include <stddef.h>\n#include <sys/types.h>\n#include <stdlib.h>\n\n#include <boolean.h>\n#include <retro_inline.h>\n#include <retro_common_api.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <lists/string_list.h>\n#include <queues/task_queue.h>\n#include <queues/message_queue.h>\n#include \"gfx/video_driver.h\"\n\n#include \"core.h\"\n\n#include \"driver.h\"\n#include \"runloop.h\"\n#include \"retroarch_types.h\"\n\n#define RETRO_ENVIRONMENT_RETROARCH_START_BLOCK 0x800000\n\n#define RETRO_ENVIRONMENT_SET_SAVE_STATE_IN_BACKGROUND (2 | RETRO_ENVIRONMENT_RETROARCH_START_BLOCK)\n                                            /* bool * --\n                                            * Boolean value that tells the front end to save states in the\n                                            * background or not.\n                                            */\n\n#define RETRO_ENVIRONMENT_GET_CLEAR_ALL_THREAD_WAITS_CB (3 | RETRO_ENVIRONMENT_RETROARCH_START_BLOCK)\n                                            /* retro_environment_t * --\n                                            * Provides the callback to the frontend method which will cancel\n                                            * all currently waiting threads.  Used when coordination is needed\n                                            * between the core and the frontend to gracefully stop all threads.\n                                            */\n\n#define RETRO_ENVIRONMENT_POLL_TYPE_OVERRIDE (4 | RETRO_ENVIRONMENT_RETROARCH_START_BLOCK)\n                                            /* unsigned * --\n                                            * Tells the frontend to override the poll type behavior.\n                                            * Allows the frontend to influence the polling behavior of the\n                                            * frontend.\n                                            *\n                                            * Will be unset when retro_unload_game is called.\n                                            *\n                                            * 0 - Don't Care, no changes, frontend still determines polling type behavior.\n                                            * 1 - Early\n                                            * 2 - Normal\n                                            * 3 - Late\n                                            */\n\n#define DRIVERS_CMD_ALL \\\n      ( DRIVER_AUDIO_MASK \\\n      | DRIVER_MICROPHONE_MASK \\\n      | DRIVER_VIDEO_MASK \\\n      | DRIVER_INPUT_MASK \\\n      | DRIVER_CAMERA_MASK \\\n      | DRIVER_LOCATION_MASK \\\n      | DRIVER_MENU_MASK \\\n      | DRIVERS_VIDEO_INPUT_MASK \\\n      | DRIVER_BLUETOOTH_MASK \\\n      | DRIVER_WIFI_MASK \\\n      | DRIVER_LED_MASK \\\n      | DRIVER_MIDI_MASK )\n\n\nRETRO_BEGIN_DECLS\n\nenum rarch_state_flags\n{\n   RARCH_FLAGS_HAS_SET_USERNAME             = (1 << 0),\n   RARCH_FLAGS_HAS_SET_VERBOSITY            = (1 << 1),\n   RARCH_FLAGS_HAS_SET_LIBRETRO             = (1 << 2),\n   RARCH_FLAGS_HAS_SET_LIBRETRO_DIRECTORY   = (1 << 3),\n   RARCH_FLAGS_HAS_SET_SAVE_PATH            = (1 << 4),\n   RARCH_FLAGS_HAS_SET_STATE_PATH           = (1 << 5),\n   RARCH_FLAGS_HAS_SET_UPS_PREF             = (1 << 6),\n   RARCH_FLAGS_HAS_SET_BPS_PREF             = (1 << 7),\n   RARCH_FLAGS_HAS_SET_IPS_PREF             = (1 << 8),\n   RARCH_FLAGS_HAS_SET_LOG_TO_FILE          = (1 << 9),\n   RARCH_FLAGS_UPS_PREF                     = (1 << 10),\n   RARCH_FLAGS_BPS_PREF                     = (1 << 11),\n   RARCH_FLAGS_IPS_PREF                     = (1 << 12),\n   RARCH_FLAGS_BLOCK_CONFIG_READ            = (1 << 13),\n   RARCH_FLAGS_CLI_DATABASE_SCAN            = (1 << 14),\n   RARCH_FLAGS_HAS_SET_XDELTA_PREF          = (1 << 15),\n   RARCH_FLAGS_XDELTA_PREF                  = (1 << 16),\n   RARCH_FLAGS_HAS_SET_OVERLAY_PRESET       = (1 << 17)\n};\n\nbool retroarch_ctl(enum rarch_ctl_state state, void *data);\n\nsize_t retroarch_get_capabilities(enum rarch_capabilities type,\n      char *s, size_t len);\n\nvoid retroarch_override_setting_set(enum rarch_override_setting enum_idx, void *data);\n\nvoid retroarch_override_setting_unset(enum rarch_override_setting enum_idx, void *data);\n\nbool retroarch_override_setting_is_set(enum rarch_override_setting enum_idx, void *data);\n\nconst char* video_shader_get_current_shader_preset(void);\n\n/**\n * retroarch_main_init:\n * @argc                 : Count of (commandline) arguments.\n * @argv                 : (Commandline) arguments.\n *\n * Initializes the program.\n *\n * @return true on success, otherwise false if there was an error.\n **/\nbool retroarch_main_init(int argc, char *argv[]);\n\nbool retroarch_main_quit(void);\n\nglobal_t *global_get_ptr(void);\n\ncontent_state_t *content_state_get_ptr(void);\n\nunsigned content_get_subsystem_rom_id(void);\n\nint content_get_subsystem(void);\n\nvoid retroarch_menu_running(void);\n\nvoid retroarch_menu_running_finished(bool quit);\n\nenum retro_language retroarch_get_language_from_iso(const char *lang);\n\nvoid retroarch_favorites_init(void);\n\nvoid retroarch_favorites_deinit(void);\n\n/* Audio */\n\n/**\n * config_get_audio_driver_options:\n *\n * Get an enumerated list of all audio driver names, separated by '|'.\n *\n * Returns: string listing of all audio driver names, separated by '|'.\n **/\nconst char* config_get_audio_driver_options(void);\n\n#ifdef HAVE_MICROPHONE\n/**\n * config_get_microphone_driver_options:\n *\n * Get an enumerated list of all microphone driver names, separated by '|'.\n *\n * Returns: string listing of all microphone driver names, separated by '|'.\n **/\nconst char* config_get_microphone_driver_options(void);\n#endif\n\n/* Camera */\n\n/*\n   Returns rotation requested by the core regardless of if it has been\n   applied with the final video rotation\n*/\nunsigned int retroarch_get_core_requested_rotation(void);\n\n/*\n   Returns final rotation including both user chosen video rotation\n   and core requested rotation if allowed by video_allow_rotate\n*/\nunsigned int retroarch_get_rotation(void);\n\nvoid retroarch_init_task_queue(void);\n\n/* Creates folder and core options stub file for subsequent runs */\nbool core_options_create_override(bool game_specific);\nbool core_options_remove_override(bool game_specific);\nvoid core_options_reset(void);\nvoid core_options_flush(void);\n\n/**\n * retroarch_fail:\n * @error_code  : Error code.\n * @error       : Error message to show.\n *\n * Sanely kills the program.\n **/\nvoid retroarch_fail(int error_code, const char *error);\n\nbool should_quit_on_close(void);\n\nuint16_t retroarch_get_flags(void);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "retroarch_types.h",
          "type": "blob",
          "size": 7.96875,
          "content": "#ifndef _RETROARCH_TYPES_H\n#define _RETROARCH_TYPES_H\n\n#include <setjmp.h>\n#include <boolean.h>\n#include <retro_inline.h>\n#include <retro_common_api.h>\n#include <retro_miscellaneous.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef HAVE_MENU\n#include \"menu/menu_defines.h\"\n#endif\n\n#include \"input/input_defines.h\"\n#include \"disk_control_interface.h\"\n\nRETRO_BEGIN_DECLS\n\nenum\n{\n   /* Polling is performed before\n    * call to retro_run. */\n   POLL_TYPE_EARLY = 0,\n\n   /* Polling is performed when requested. */\n   POLL_TYPE_NORMAL,\n\n   /* Polling is performed on first call to\n    * retro_input_state per frame. */\n   POLL_TYPE_LATE\n};\n\nenum rarch_core_type\n{\n   CORE_TYPE_PLAIN = 0,\n   CORE_TYPE_DUMMY,\n   CORE_TYPE_FFMPEG,\n   CORE_TYPE_MPV,\n   CORE_TYPE_IMAGEVIEWER,\n   CORE_TYPE_NETRETROPAD,\n   CORE_TYPE_VIDEO_PROCESSOR\n};\n\nenum rarch_ctl_state\n{\n   RARCH_CTL_NONE = 0,\n\n   /* Deinitializes RetroArch. */\n   RARCH_CTL_MAIN_DEINIT,\n\n   RARCH_CTL_IS_DUMMY_CORE,\n   RARCH_CTL_IS_CORE_LOADED,\n\n#if defined(HAVE_RUNAHEAD) && (defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB))\n   RARCH_CTL_IS_SECOND_CORE_AVAILABLE,\n   RARCH_CTL_IS_SECOND_CORE_LOADED,\n#endif\n\n   RARCH_CTL_UNSET_BPS_PREF,\n   RARCH_CTL_UNSET_UPS_PREF,\n   RARCH_CTL_UNSET_IPS_PREF,\n   RARCH_CTL_UNSET_XDELTA_PREF,\n\n#ifdef HAVE_CONFIGFILE\n   /* Block config read */\n   RARCH_CTL_SET_BLOCK_CONFIG_READ,\n   RARCH_CTL_UNSET_BLOCK_CONFIG_READ,\n#endif\n\n   RARCH_CTL_SET_WINDOWED_SCALE,\n\n#ifdef HAVE_CONFIGFILE\n   RARCH_CTL_SET_REMAPS_CORE_ACTIVE,\n   RARCH_CTL_SET_REMAPS_CONTENT_DIR_ACTIVE,\n   RARCH_CTL_SET_REMAPS_GAME_ACTIVE,\n#endif\n\n   RARCH_CTL_SET_SHUTDOWN,\n\n   /* Runloop state */\n   RARCH_CTL_STATE_FREE,\n\n   /* Performance counters */\n   RARCH_CTL_GET_PERFCNT,\n   RARCH_CTL_SET_PERFCNT_ENABLE,\n   RARCH_CTL_UNSET_PERFCNT_ENABLE,\n   RARCH_CTL_IS_PERFCNT_ENABLE,\n\n   /* Core options */\n   RARCH_CTL_CORE_OPTIONS_LIST_GET,\n   RARCH_CTL_CORE_OPTION_PREV,\n   RARCH_CTL_CORE_OPTION_NEXT,\n   RARCH_CTL_CORE_OPTION_UPDATE_DISPLAY,\n\n   /* BSV Movie */\n   RARCH_CTL_BSV_MOVIE_IS_INITED\n};\n\nenum rarch_capabilities\n{\n   RARCH_CAPABILITIES_NONE = 0,\n   RARCH_CAPABILITIES_CPU,\n   RARCH_CAPABILITIES_COMPILER\n};\n\nenum rarch_override_setting\n{\n   RARCH_OVERRIDE_SETTING_NONE = 0,\n   RARCH_OVERRIDE_SETTING_LIBRETRO,\n   RARCH_OVERRIDE_SETTING_VERBOSITY,\n   RARCH_OVERRIDE_SETTING_LIBRETRO_DIRECTORY,\n   RARCH_OVERRIDE_SETTING_SAVE_PATH,\n   RARCH_OVERRIDE_SETTING_STATE_PATH,\n#ifdef HAVE_NETWORKING\n   RARCH_OVERRIDE_SETTING_NETPLAY_MODE,\n   RARCH_OVERRIDE_SETTING_NETPLAY_IP_ADDRESS,\n   RARCH_OVERRIDE_SETTING_NETPLAY_IP_PORT,\n   RARCH_OVERRIDE_SETTING_NETPLAY_CHECK_FRAMES,\n#endif\n   RARCH_OVERRIDE_SETTING_UPS_PREF,\n   RARCH_OVERRIDE_SETTING_BPS_PREF,\n   RARCH_OVERRIDE_SETTING_IPS_PREF,\n   RARCH_OVERRIDE_SETTING_XDELTA_PREF,\n   RARCH_OVERRIDE_SETTING_LIBRETRO_DEVICE,\n   RARCH_OVERRIDE_SETTING_LOG_TO_FILE,\n   RARCH_OVERRIDE_SETTING_DATABASE_SCAN,\n   RARCH_OVERRIDE_SETTING_OVERLAY_PRESET,\n   RARCH_OVERRIDE_SETTING_LAST\n};\n\nenum runloop_action\n{\n   RUNLOOP_ACTION_NONE = 0,\n   RUNLOOP_ACTION_AUTOSAVE\n};\n\nenum rarch_main_wrap_flags\n{\n   RARCH_MAIN_WRAP_FLAG_VERBOSE    = (1 << 0),\n   RARCH_MAIN_WRAP_FLAG_NO_CONTENT = (1 << 1),\n   RARCH_MAIN_WRAP_FLAG_TOUCHED    = (1 << 2)\n};\n\nenum content_state_flags\n{\n   CONTENT_ST_FLAG_IS_INITED                  = (1 << 0),\n   CONTENT_ST_FLAG_CORE_DOES_NOT_NEED_CONTENT = (1 << 1),\n   CONTENT_ST_FLAG_PENDING_SUBSYSTEM_INIT     = (1 << 2),\n   CONTENT_ST_FLAG_PENDING_ROM_CRC            = (1 << 3)\n};\n\ntypedef struct rarch_memory_descriptor\n{\n   struct retro_memory_descriptor core;        /* uint64_t alignment */\n   /* Retroarch can have additional context here */\n} rarch_memory_descriptor_t;\n\ntypedef struct rarch_memory_map\n{\n   rarch_memory_descriptor_t *descriptors;\n   unsigned num_descriptors;\n} rarch_memory_map_t;\n\ntypedef struct rarch_system_info\n{\n   struct retro_location_callback location_cb; /* ptr alignment */\n   disk_control_interface_t disk_control;      /* ptr alignment */\n   struct retro_system_info info;              /* ptr alignment */\n   rarch_memory_map_t mmaps;                   /* ptr alignment */\n   const char *input_desc_btn[MAX_USERS][RARCH_FIRST_META_KEY];\n   struct\n   {\n      struct retro_subsystem_info *data;\n      unsigned size;\n   } subsystem;\n   struct\n   {\n      struct retro_controller_info *data;\n      unsigned size;\n   } ports;\n   unsigned rotation;\n   unsigned core_requested_rotation;\n   unsigned performance_level;\n   char valid_extensions[256];\n   bool load_no_content;\n   bool supports_vfs;\n} rarch_system_info_t;\n\ntypedef struct retro_ctx_input_state_info\n{\n   retro_input_state_t cb;\n} retro_ctx_input_state_info_t;\n\ntypedef struct retro_ctx_cheat_info\n{\n   const char *code;\n   unsigned index;\n   bool enabled;\n} retro_ctx_cheat_info_t;\n\ntypedef struct retro_ctx_controller_info\n{\n   unsigned port;\n   unsigned device;\n} retro_ctx_controller_info_t;\n\ntypedef struct retro_ctx_memory_info\n{\n   void *data;\n   size_t size;\n   unsigned id;\n} retro_ctx_memory_info_t;\n\ntypedef struct retro_ctx_load_content_info\n{\n   struct retro_game_info *info;\n   const struct string_list *content;\n   const struct retro_subsystem_info *special;\n} retro_ctx_load_content_info_t;\n\ntypedef struct retro_ctx_serialize_info\n{\n   const void *data_const;\n   void *data;\n   size_t size;\n} retro_ctx_serialize_info_t;\n\ntypedef struct retro_callbacks\n{\n   retro_video_refresh_t frame_cb;\n   retro_audio_sample_t sample_cb;\n   retro_audio_sample_batch_t sample_batch_cb;\n   retro_input_state_t state_cb;\n   retro_input_poll_t poll_cb;\n} retro_callbacks_t;\n\nstruct rarch_main_wrap\n{\n   char **argv;\n   const char *content_path;\n   const char *sram_path;\n   const char *state_path;\n   const char *config_path;\n   const char *libretro_path;\n   int argc;\n   uint8_t flags;\n};\n\n/* All run-time- / command line flag-related globals go here. */\nenum global_flags\n{\n   GLOB_FLG_ERR_ON_INIT          = (1 << 0),\n   GLOB_FLG_LAUNCHED_FROM_CLI    = (1 << 1),\n   GLOB_FLG_CLI_LOAD_MENU_ON_ERR = (1 << 2)\n};\n\ntypedef struct global\n{\n   jmp_buf error_sjlj_context; /* 4-byte alignment, put it right before long */\n\n   /* Settings and/or global state that is specific to\n    * a console-style implementation. */\n   struct\n   {\n      struct\n      {\n         struct\n         {\n            uint32_t *list;\n            unsigned count;\n            struct\n            {\n               unsigned idx;\n               unsigned id;\n            } current;\n            struct\n            {\n               unsigned idx;\n               unsigned id;\n            } initial;\n            bool check;\n         } resolutions;\n         unsigned      gamma_correction;\n         unsigned int  flicker_filter_index;\n         unsigned char soft_filter_index;\n         bool pal_enable;\n         bool pal60_enable;\n      } screen;\n\n      bool flickerfilter_enable;\n      bool softfilter_enable;\n\n   } console;\n\n   char error_string[NAME_MAX_LENGTH];\n   uint8_t flags;\n} global_t;\n\ntypedef struct content_file_override\n{\n   char *ext;\n   bool need_fullpath;\n   bool persistent_data;\n} content_file_override_t;\n\ntypedef struct content_file_info\n{\n   char *full_path;\n   char *archive_path;\n   char *archive_file;\n   char *dir;\n   char *name;\n   char *ext;\n   char *meta; /* Unused at present */\n   void *data;\n   size_t data_size;\n   bool file_in_archive;\n   bool persistent_data;\n} content_file_info_t;\n\ntypedef struct content_file_list\n{\n   content_file_info_t *entries;\n   struct string_list *temporary_files;\n   struct retro_game_info *game_info;\n   struct retro_game_info_ext *game_info_ext;\n   size_t size;\n} content_file_list_t;\n\ntypedef struct content_state\n{\n   char *pending_subsystem_roms[RARCH_MAX_SUBSYSTEM_ROMS];\n\n   content_file_override_t *content_override_list;\n   content_file_list_t *content_list;\n\n   int pending_subsystem_rom_num;\n   int pending_subsystem_id;\n   unsigned pending_subsystem_rom_id;\n   uint32_t rom_crc;\n   uint8_t flags;\n\n   char companion_ui_crc32[32];\n   char pending_subsystem_ident[NAME_MAX_LENGTH];\n   char pending_rom_crc_path[PATH_MAX_LENGTH];\n   char companion_ui_db_name[PATH_MAX_LENGTH];\n} content_state_t;\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "runahead.c",
          "type": "blob",
          "size": 51.2275390625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2023 - Daniel De Matteis\n *  Copyright (C) 2018-2023 - Dan Weiss\n *  Copyright (C) 2022-2023 - Neil Fore\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdint.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <encodings/utf.h>\n#include <string/stdstring.h>\n#include <streams/file_stream.h>\n#include <time/rtime.h>\n\n#include \"content.h\"\n#include \"core.h\"\n#include \"dynamic.h\"\n#include \"driver.h\"\n#include \"audio/audio_driver.h\"\n#include \"gfx/video_driver.h\"\n#include \"paths.h\"\n#include \"runloop.h\"\n#include \"verbosity.h\"\n\nstatic int16_t input_state_get_last(unsigned port,\n      unsigned device, unsigned index, unsigned id)\n{\n   runloop_state_t      *runloop_st = runloop_state_get_ptr();\n\n   if (runloop_st->input_state_list)\n   {\n      int i;\n      /* find list item */\n      for (i = 0; i < runloop_st->input_state_list->size; i++)\n      {\n         input_list_element *element =\n            (input_list_element*)runloop_st->input_state_list->data[i];\n\n         if (     (element->port   == port)\n               && (element->device == device)\n               && (element->index  == index))\n         {\n            if (id < element->state_size)\n               return element->state[id];\n            break;\n         }\n      }\n   }\n\n   return 0;\n}\n\nstatic void free_retro_ctx_load_content_info(struct\n      retro_ctx_load_content_info *dest)\n{\n   if (!dest)\n      return;\n\n   string_list_free((struct string_list*)dest->content);\n   if (dest->info)\n      free(dest->info);\n\n   dest->info    = NULL;\n   dest->content = NULL;\n}\n\nstatic struct retro_game_info* clone_retro_game_info(const\n      struct retro_game_info *src)\n{\n   struct retro_game_info *dest = (struct retro_game_info*)malloc(\n         sizeof(struct retro_game_info));\n\n   if (!dest)\n      return NULL;\n\n   /* content_file_init() guarantees that all\n    * elements of the source retro_game_info\n    * struct will persist for the lifetime of\n    * the core. This means we do not have to\n    * copy any data; pointer assignment is\n    * sufficient */\n   dest->path = src->path;\n   dest->data = src->data;\n   dest->size = src->size;\n   dest->meta = src->meta;\n\n   return dest;\n}\n\nstatic struct retro_ctx_load_content_info\n*clone_retro_ctx_load_content_info(\n      const struct retro_ctx_load_content_info *src)\n{\n   struct retro_ctx_load_content_info *dest = NULL;\n   if (!src || src->special)\n      return NULL;   /* refuse to deal with the Special field */\n\n   dest          = (struct retro_ctx_load_content_info*)\n      malloc(sizeof(*dest));\n\n   if (!dest)\n      return NULL;\n\n   dest->info       = NULL;\n   dest->content    = NULL;\n   dest->special    = NULL;\n\n   if (src->info)\n      dest->info    = clone_retro_game_info(src->info);\n   if (src->content)\n      dest->content = string_list_clone(src->content);\n\n   return dest;\n}\n\nvoid runahead_set_load_content_info(void *data,\n      const retro_ctx_load_content_info_t *ctx)\n{\n   runloop_state_t *runloop_st = (runloop_state_t*)data;\n   free_retro_ctx_load_content_info(runloop_st->load_content_info);\n   free(runloop_st->load_content_info);\n   runloop_st->load_content_info = clone_retro_ctx_load_content_info(ctx);\n}\n\n/* RUNAHEAD - SECONDARY CORE  */\n#if defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB)\nstatic void strcat_alloc(char **dst, const char *s)\n{\n   size_t _len;\n   char *src          = *dst;\n\n   if (!src)\n   {\n      if (s)\n      {\n         size_t __len = strlen(s);\n         if (__len != 0)\n         {\n            char *_dst= (char*)malloc(__len + 1);\n            strcpy_literal(_dst, s);\n            src       = _dst;\n         }\n         else\n            src       = NULL;\n      }\n      else\n         src          = (char*)calloc(1,1);\n\n      *dst            = src;\n      return;\n   }\n\n   if (!s)\n      return;\n\n   _len               = strlen(src);\n\n   if (!(src = (char*)realloc(src, _len + strlen(s) + 1)))\n      return;\n\n   *dst               = src;\n   strcpy_literal(src + _len, s);\n}\n\nvoid runahead_secondary_core_destroy(void *data)\n{\n   runloop_state_t *runloop_st      = (runloop_state_t*)data;\n   if (!runloop_st->secondary_lib_handle)\n      return;\n\n   /* unload game from core */\n   if (runloop_st->secondary_core.retro_unload_game)\n      runloop_st->secondary_core.retro_unload_game();\n   runloop_st->core_poll_type_override = POLL_TYPE_OVERRIDE_DONTCARE;\n\n   /* deinit */\n   if (runloop_st->secondary_core.retro_deinit)\n      runloop_st->secondary_core.retro_deinit();\n   memset(&runloop_st->secondary_core, 0, sizeof(struct retro_core_t));\n\n   dylib_close(runloop_st->secondary_lib_handle);\n   runloop_st->secondary_lib_handle = NULL;\n   filestream_delete(runloop_st->secondary_library_path);\n   if (runloop_st->secondary_library_path)\n      free(runloop_st->secondary_library_path);\n   runloop_st->secondary_library_path = NULL;\n}\n\nstatic char *get_tmpdir_alloc(const char *override_dir)\n{\n   const char *src    = NULL;\n   char *path         = NULL;\n#ifdef _WIN32\n#ifdef LEGACY_WIN32\n   DWORD plen         = GetTempPath(0, NULL) + 1;\n\n   if (!(path = (char*)malloc(plen * sizeof(char))))\n      return NULL;\n\n   path[plen - 1]     = 0;\n   GetTempPath(plen, path);\n#else\n   DWORD plen         = GetTempPathW(0, NULL) + 1;\n   wchar_t *wide_str  = (wchar_t*)malloc(plen * sizeof(wchar_t));\n\n   if (!wide_str)\n      return NULL;\n\n   wide_str[plen - 1] = 0;\n   GetTempPathW(plen, wide_str);\n\n   path               = utf16_to_utf8_string_alloc(wide_str);\n   free(wide_str);\n#endif\n#else\n#if defined ANDROID\n   src                = override_dir;\n#else\n   {\n      char *tmpdir    = getenv(\"TMPDIR\");\n      if (tmpdir)\n         src          = tmpdir;\n      else\n         src          = \"/tmp\";\n   }\n#endif\n   if (src)\n   {\n      size_t _len     = strlen(src);\n      if (_len != 0)\n      {\n         char *dst    = (char*)malloc(_len + 1);\n         strcpy_literal(dst, src);\n         path         = dst;\n      }\n   }\n   else\n      path            = (char*)calloc(1,1);\n#endif\n   return path;\n}\n\nstatic bool write_file_with_random_name(char **temp_dll_path,\n      const char *tmp_path, const void* data, ssize_t dataSize)\n{\n   int i;\n   size_t ext_len;\n   char number_buf[32];\n   bool okay                = false;\n   const char *prefix       = \"tmp\";\n   char *ext                = NULL;\n   time_t time_value        = time(NULL);\n   unsigned _number_value   = (unsigned)time_value;\n   const char *src          = path_get_extension(*temp_dll_path);\n\n   if (src)\n   {\n      size_t _len           = strlen(src);\n      if (_len != 0)\n      {\n         char *dst          = (char*)malloc(_len + 1);\n         strcpy_literal(dst, src);\n         ext                = dst;\n      }\n   }\n   else\n      ext                   = (char*)calloc(1,1);\n\n   ext_len                  = strlen(ext);\n\n   if (ext_len > 0)\n   {\n      strcat_alloc(&ext, \".\");\n      memmove(ext + 1, ext, ext_len);\n      ext[0] = '.';\n      ext_len++;\n   }\n\n   /* Try up to 30 'random' filenames before giving up */\n   for (i = 0; i < 30; i++)\n   {\n      int number_value = _number_value * 214013 + 2531011;\n      int number       = (number_value >> 14) % 100000;\n\n      snprintf(number_buf, sizeof(number_buf), \"%05d\", number);\n\n      if (*temp_dll_path)\n         free(*temp_dll_path);\n      *temp_dll_path = NULL;\n\n      strcat_alloc(temp_dll_path, tmp_path);\n      strcat_alloc(temp_dll_path, PATH_DEFAULT_SLASH());\n      strcat_alloc(temp_dll_path, prefix);\n      strcat_alloc(temp_dll_path, number_buf);\n      strcat_alloc(temp_dll_path, ext);\n\n      if (filestream_write_file(*temp_dll_path, data, dataSize))\n      {\n         okay = true;\n         break;\n      }\n   }\n\n   if (ext)\n      free(ext);\n   ext = NULL;\n   return okay;\n}\n\n\nstatic char *copy_core_to_temp_file(\n      const char *core_path,\n      const char *dir_libretro)\n{\n   char tmp_path[PATH_MAX_LENGTH];\n   bool  failed                = false;\n   char  *tmpdir               = NULL;\n   char  *tmp_dll_path         = NULL;\n   void  *dll_file_data        = NULL;\n   int64_t  dll_file_size      = 0;\n   const char  *core_base_name = path_basename_nocompression(core_path);\n\n   if (string_is_empty(core_base_name))\n      return NULL;\n\n   if (!(tmpdir = get_tmpdir_alloc(dir_libretro)))\n      return NULL;\n\n   fill_pathname_join_special(tmp_path,\n         tmpdir, \"retroarch_temp\",\n         sizeof(tmp_path));\n\n   if (!path_mkdir(tmp_path))\n   {\n      failed = true;\n      goto end;\n   }\n\n   if (!filestream_read_file(core_path, &dll_file_data, &dll_file_size))\n   {\n      failed = true;\n      goto end;\n   }\n\n   strcat_alloc(&tmp_dll_path, tmp_path);\n   strcat_alloc(&tmp_dll_path, PATH_DEFAULT_SLASH());\n   strcat_alloc(&tmp_dll_path, core_base_name);\n\n   if (!filestream_write_file(tmp_dll_path, dll_file_data, dll_file_size))\n   {\n      /* try other file names */\n      if (!write_file_with_random_name(&tmp_dll_path,\n               tmp_path, dll_file_data, dll_file_size))\n         failed = true;\n   }\n\nend:\n   if (tmpdir)\n      free(tmpdir);\n   if (dll_file_data)\n      free(dll_file_data);\n\n   tmpdir              = NULL;\n   dll_file_data       = NULL;\n\n   if (!failed)\n      return tmp_dll_path;\n\n   if (tmp_dll_path)\n      free(tmp_dll_path);\n\n   tmp_dll_path     = NULL;\n\n   return NULL;\n}\n\nstatic bool runloop_environment_secondary_core_hook(\n      unsigned cmd, void *data)\n{\n   runloop_state_t *runloop_st    = runloop_state_get_ptr();\n   bool result                    = runloop_environment_cb(cmd, data);\n\n   if (runloop_st->flags & RUNLOOP_FLAG_HAS_VARIABLE_UPDATE)\n   {\n      if (cmd == RETRO_ENVIRONMENT_GET_VARIABLE_UPDATE)\n      {\n         bool *bool_p                      = (bool*)data;\n         *bool_p                           = true;\n         runloop_st->flags                &= ~RUNLOOP_FLAG_HAS_VARIABLE_UPDATE;\n         return true;\n      }\n      else if (cmd == RETRO_ENVIRONMENT_GET_VARIABLE)\n         runloop_st->flags &= ~RUNLOOP_FLAG_HAS_VARIABLE_UPDATE;\n   }\n   return result;\n}\n\nvoid runahead_clear_controller_port_map(void *data)\n{\n   int port;\n   runloop_state_t *runloop_st = (runloop_state_t*)data;\n   for (port = 0; port < MAX_USERS; port++)\n      runloop_st->port_map[port] = -1;\n}\n\nstatic bool secondary_core_create(runloop_state_t *runloop_st,\n      settings_t *settings)\n{\n   const enum rarch_core_type\n      last_core_type             = runloop_st->last_core_type;\n   rarch_system_info_t *sys_info = &runloop_st->system;\n   unsigned num_active_users     = settings->uints.input_max_users;\n   uint8_t flags                 = content_get_flags();\n\n   if (     (last_core_type != CORE_TYPE_PLAIN)\n         || (!runloop_st->load_content_info)\n         || ( runloop_st->load_content_info->special))\n      return false;\n\n   if (runloop_st->secondary_library_path)\n      free(runloop_st->secondary_library_path);\n   runloop_st->secondary_library_path = NULL;\n   runloop_st->secondary_library_path = copy_core_to_temp_file(\n\t\t   path_get(RARCH_PATH_CORE),\n\t\t   settings->paths.directory_libretro);\n\n   if (!runloop_st->secondary_library_path)\n      return false;\n\n   /* Load Core */\n   if (!runloop_init_libretro_symbols(runloop_st,\n            CORE_TYPE_PLAIN, &runloop_st->secondary_core,\n            runloop_st->secondary_library_path,\n            &runloop_st->secondary_lib_handle))\n      return false;\n\n   runloop_st->secondary_core.flags |= RETRO_CORE_FLAG_SYMBOLS_INITED;\n   runloop_st->secondary_core.retro_set_environment(\n         runloop_environment_secondary_core_hook);\n   runloop_st->flags                |= RUNLOOP_FLAG_HAS_VARIABLE_UPDATE;\n\n   runloop_st->secondary_core.retro_init();\n\n   if (flags & CONTENT_ST_FLAG_IS_INITED)\n      runloop_st->secondary_core.flags |=  RETRO_CORE_FLAG_INITED;\n   else\n      runloop_st->secondary_core.flags &= ~RETRO_CORE_FLAG_INITED;\n\n   /* Load Content */\n   /* disabled due to crashes */\n   if (    (!runloop_st->load_content_info)\n         || (runloop_st->load_content_info->special))\n      return false;\n\n   if ( (   runloop_st->load_content_info->content->size > 0)\n         && runloop_st->load_content_info->content->elems[0].data)\n   {\n      if (!runloop_st->secondary_core.retro_load_game(\n               runloop_st->load_content_info->info))\n      {\n         runloop_st->secondary_core.flags &= ~RETRO_CORE_FLAG_GAME_LOADED;\n         goto error;\n      }\n      runloop_st->secondary_core.flags    |=  RETRO_CORE_FLAG_GAME_LOADED;\n   }\n   else if (flags & CONTENT_ST_FLAG_CORE_DOES_NOT_NEED_CONTENT)\n   {\n      if (!runloop_st->secondary_core.retro_load_game(NULL))\n      {\n         runloop_st->secondary_core.flags &= ~RETRO_CORE_FLAG_GAME_LOADED;\n         goto error;\n      }\n      runloop_st->secondary_core.flags    |=  RETRO_CORE_FLAG_GAME_LOADED;\n   }\n   else\n      runloop_st->secondary_core.flags    &= ~RETRO_CORE_FLAG_GAME_LOADED;\n\n   if (!(runloop_st->secondary_core.flags & RETRO_CORE_FLAG_INITED))\n      goto error;\n\n   core_set_default_callbacks(&runloop_st->secondary_callbacks);\n   runloop_st->secondary_core.retro_set_video_refresh(\n         runloop_st->secondary_callbacks.frame_cb);\n   runloop_st->secondary_core.retro_set_audio_sample(\n         runloop_st->secondary_callbacks.sample_cb);\n   runloop_st->secondary_core.retro_set_audio_sample_batch(\n         runloop_st->secondary_callbacks.sample_batch_cb);\n   runloop_st->secondary_core.retro_set_input_state(\n         runloop_st->secondary_callbacks.state_cb);\n   runloop_st->secondary_core.retro_set_input_poll(\n         runloop_st->secondary_callbacks.poll_cb);\n\n   if (sys_info)\n   {\n      ssize_t port;\n      for (port = 0; port < MAX_USERS; port++)\n      {\n         if (port < (ssize_t)sys_info->ports.size)\n         {\n            unsigned device = (port < (ssize_t)num_active_users)\n                  ? runloop_st->port_map[port]\n                  : RETRO_DEVICE_NONE;\n            runloop_st->secondary_core.retro_set_controller_port_device(\n                  (unsigned)port, device);\n         }\n      }\n   }\n\n#if defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB)\n   runahead_clear_controller_port_map(runloop_st);\n#endif\n\n   return true;\n\nerror:\n   runahead_secondary_core_destroy(runloop_st);\n   return false;\n}\n\n#if defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB)\nbool secondary_core_ensure_exists(void *data, settings_t *settings)\n{\n   runloop_state_t *runloop_st   = (runloop_state_t*)data;\n   if (!runloop_st->secondary_lib_handle)\n      if (!secondary_core_create(runloop_st, settings))\n         return false;\n   return true;\n}\n#endif\n\n#if defined(HAVE_DYNAMIC)\nstatic bool secondary_core_deserialize(runloop_state_t *runloop_st,\n      settings_t *settings,\n      const void *data, size_t size)\n{\n   bool ret = false;\n\n   if (secondary_core_ensure_exists(runloop_st, settings))\n   {\n      runloop_st->flags |=  RUNLOOP_FLAG_REQUEST_SPECIAL_SAVESTATE;\n      ret                = runloop_st->secondary_core.retro_unserialize(data, size);\n      runloop_st->flags &= ~RUNLOOP_FLAG_REQUEST_SPECIAL_SAVESTATE;\n   }\n   else\n      runahead_secondary_core_destroy(runloop_st);\n\n   return ret;\n}\n#endif\n\nstatic void secondary_core_input_poll_null(void) { }\n\nstatic bool secondary_core_run_use_last_input(runloop_state_t *runloop_st)\n{\n   retro_input_poll_t old_poll_function;\n   retro_input_state_t old_input_function;\n\n   if (!secondary_core_ensure_exists(runloop_st, config_get_ptr()))\n   {\n      runahead_secondary_core_destroy(runloop_st);\n      return false;\n   }\n\n   old_poll_function                        = runloop_st->secondary_callbacks.poll_cb;\n   old_input_function                       = runloop_st->secondary_callbacks.state_cb;\n\n   runloop_st->secondary_callbacks.poll_cb  = secondary_core_input_poll_null;\n   runloop_st->secondary_callbacks.state_cb = input_state_get_last;\n\n   runloop_st->secondary_core.retro_set_input_poll(\n         runloop_st->secondary_callbacks.poll_cb);\n   runloop_st->secondary_core.retro_set_input_state(\n         runloop_st->secondary_callbacks.state_cb);\n\n   runloop_st->secondary_core.retro_run();\n   runloop_st->secondary_callbacks.poll_cb  = old_poll_function;\n   runloop_st->secondary_callbacks.state_cb = old_input_function;\n\n   runloop_st->secondary_core.retro_set_input_poll(\n         runloop_st->secondary_callbacks.poll_cb);\n   runloop_st->secondary_core.retro_set_input_state(\n         runloop_st->secondary_callbacks.state_cb);\n\n   return true;\n}\n\nvoid runahead_remember_controller_port_device(void *data,\n\t\tlong port, long device)\n{\n   runloop_state_t *runloop_st   = (runloop_state_t*)data;\n   if (port >= 0 && port < MAX_USERS)\n      runloop_st->port_map[port] = (int)device;\n   if (     runloop_st->secondary_lib_handle\n         && runloop_st->secondary_core.retro_set_controller_port_device)\n      runloop_st->secondary_core.retro_set_controller_port_device((unsigned)port, (unsigned)device);\n}\n\n#else\nvoid runahead_secondary_core_destroy(void *data) { }\n#endif\n\nstatic void mylist_resize(my_list *list,\n      int new_size, bool run_constructor)\n{\n   int i;\n   int new_capacity;\n   int old_size;\n   void *element    = NULL;\n   if (new_size < 0)\n      new_size      = 0;\n   new_capacity     = new_size;\n   old_size         = list->size;\n\n   if (new_size == old_size)\n      return;\n\n   if (new_size > list->capacity)\n   {\n      if (new_capacity < list->capacity * 2)\n         new_capacity = list->capacity * 2;\n\n      /* try to realloc */\n      list->data      = (void**)realloc(\n            (void*)list->data, new_capacity * sizeof(void*));\n\n      for (i = list->capacity; i < new_capacity; i++)\n         list->data[i] = NULL;\n\n      list->capacity = new_capacity;\n   }\n\n   if (new_size <= list->size)\n   {\n      for (i = new_size; i < list->size; i++)\n      {\n         element = list->data[i];\n\n         if (element)\n         {\n            list->destructor(element);\n            list->data[i] = NULL;\n         }\n      }\n   }\n   else\n   {\n      for (i = list->size; i < new_size; i++)\n      {\n         list->data[i] = NULL;\n         if (run_constructor)\n            list->data[i] = list->constructor();\n      }\n   }\n\n   list->size = new_size;\n}\n\nstatic void *mylist_add_element(my_list *list)\n{\n   int old_size = list->size;\n   if (list)\n      mylist_resize(list, old_size + 1, true);\n   return list->data[old_size];\n}\n\nstatic void mylist_destroy(my_list **list_p)\n{\n   my_list *list = NULL;\n   if (!list_p)\n      return;\n\n   list = *list_p;\n\n   if (list)\n   {\n      mylist_resize(list, 0, false);\n      free(list->data);\n      free(list);\n      *list_p = NULL;\n   }\n}\n\nstatic void mylist_create(my_list **list_p, int initial_capacity,\n      constructor_t constructor, destructor_t destructor)\n{\n   my_list *list        = NULL;\n\n   if (!list_p)\n      return;\n\n   list                = *list_p;\n   if (list)\n      mylist_destroy(list_p);\n\n   list               = (my_list*)malloc(sizeof(my_list));\n   *list_p            = list;\n   list->size         = 0;\n   list->constructor  = constructor;\n   list->destructor   = destructor;\n   list->data         = (void**)calloc(initial_capacity, sizeof(void*));\n   list->capacity     = initial_capacity;\n}\n\nstatic void *input_list_element_constructor(void)\n{\n   void *ptr                   = malloc(sizeof(input_list_element));\n   input_list_element *element = (input_list_element*)ptr;\n\n   element->port               = 0;\n   element->device             = 0;\n   element->index              = 0;\n   element->state              = (int16_t*)calloc(NAME_MAX_LENGTH,\n         sizeof(int16_t));\n   element->state_size         = NAME_MAX_LENGTH;\n\n   return ptr;\n}\n\nstatic void input_list_element_realloc(\n      input_list_element *element,\n      unsigned int new_size)\n{\n   if (new_size > element->state_size)\n   {\n      element->state = (int16_t*)realloc(element->state,\n            new_size * sizeof(int16_t));\n      memset(&element->state[element->state_size], 0,\n            (new_size - element->state_size) * sizeof(int16_t));\n      element->state_size = new_size;\n   }\n}\n\nstatic void input_list_element_expand(\n      input_list_element *element, unsigned int new_index)\n{\n   unsigned int new_size = element->state_size;\n   if (new_size == 0)\n      new_size = 32;\n   while (new_index >= new_size)\n      new_size *= 2;\n   input_list_element_realloc(element, new_size);\n}\n\nstatic void input_list_element_destructor(void* element_ptr)\n{\n   input_list_element *element = (input_list_element*)element_ptr;\n   if (!element)\n      return;\n\n   free(element->state);\n   free(element_ptr);\n}\n\nstatic void runahead_input_state_set_last(\n      runloop_state_t *runloop_st,\n      unsigned port, unsigned device,\n      unsigned index, unsigned id, int16_t value)\n{\n   unsigned i;\n   input_list_element *element = NULL;\n\n   if (!runloop_st->input_state_list)\n      mylist_create(&runloop_st->input_state_list, 16,\n            input_list_element_constructor,\n            input_list_element_destructor);\n\n   /* Find list item */\n   for (i = 0; i < (unsigned)runloop_st->input_state_list->size; i++)\n   {\n      element = (input_list_element*)runloop_st->input_state_list->data[i];\n      if (  (element->port   == port)   &&\n            (element->device == device) &&\n            (element->index  == index)\n         )\n      {\n         if (id >= element->state_size)\n            input_list_element_expand(element, id);\n         element->state[id] = value;\n         return;\n      }\n   }\n\n   element               = NULL;\n   if (runloop_st->input_state_list)\n      element            = (input_list_element*)\n         mylist_add_element(runloop_st->input_state_list);\n   if (element)\n   {\n      element->port         = port;\n      element->device       = device;\n      element->index        = index;\n      if (id >= element->state_size)\n         input_list_element_expand(element, id);\n      element->state[id]    = value;\n   }\n}\n\nstatic int16_t runahead_input_state_with_logging(unsigned port,\n      unsigned device, unsigned index, unsigned id)\n{\n   runloop_state_t     *runloop_st  = runloop_state_get_ptr();\n\n   if (runloop_st->input_state_callback_original)\n   {\n      int16_t result                =\n         runloop_st->input_state_callback_original(\n            port, device, index, id);\n      int16_t last_input            =\n         input_state_get_last(port, device, index, id);\n      if (result != last_input)\n         runloop_st->flags         |= RUNLOOP_FLAG_INPUT_IS_DIRTY;\n      /*arbitrary limit of up to 65536 elements in state array*/\n      if (id < 65536)\n         runahead_input_state_set_last(runloop_st, port, device, index, id, result);\n      return result;\n   }\n   return 0;\n}\n\nstatic void runahead_reset_hook(void)\n{\n   runloop_state_t *runloop_st = runloop_state_get_ptr();\n   runloop_st->flags          |= RUNLOOP_FLAG_INPUT_IS_DIRTY;\n   if (runloop_st->retro_reset_callback_original)\n      runloop_st->retro_reset_callback_original();\n}\n\nstatic bool runahead_unserialize_hook(const void *buf, size_t size)\n{\n   runloop_state_t *runloop_st = runloop_state_get_ptr();\n   runloop_st->flags          |= RUNLOOP_FLAG_INPUT_IS_DIRTY;\n   if (runloop_st->retro_unserialize_callback_original)\n      return runloop_st->retro_unserialize_callback_original(buf, size);\n   return false;\n}\n\nstatic void runahead_add_input_state_hook(runloop_state_t *runloop_st)\n{\n   struct retro_callbacks *cbs      = &runloop_st->retro_ctx;\n\n   if (!runloop_st->input_state_callback_original)\n   {\n      runloop_st->input_state_callback_original = cbs->state_cb;\n      cbs->state_cb                             = runahead_input_state_with_logging;\n      runloop_st->current_core.retro_set_input_state(cbs->state_cb);\n   }\n\n   if (!runloop_st->retro_reset_callback_original)\n   {\n      runloop_st->retro_reset_callback_original\n         = runloop_st->current_core.retro_reset;\n      runloop_st->current_core.retro_reset   = runahead_reset_hook;\n   }\n\n   if (!runloop_st->retro_unserialize_callback_original)\n   {\n      runloop_st->retro_unserialize_callback_original = runloop_st->current_core.retro_unserialize;\n      runloop_st->current_core.retro_unserialize      = runahead_unserialize_hook;\n   }\n}\n\nstatic void runahead_remove_input_state_hook(runloop_state_t *runloop_st)\n{\n   struct retro_callbacks *cbs      = &runloop_st->retro_ctx;\n\n   if (runloop_st->input_state_callback_original)\n   {\n      cbs->state_cb                             =\n         runloop_st->input_state_callback_original;\n      runloop_st->current_core.retro_set_input_state(cbs->state_cb);\n      runloop_st->input_state_callback_original = NULL;\n      mylist_destroy(&runloop_st->input_state_list);\n   }\n\n   if (runloop_st->retro_reset_callback_original)\n   {\n      runloop_st->current_core.retro_reset               =\n         runloop_st->retro_reset_callback_original;\n      runloop_st->retro_reset_callback_original          = NULL;\n   }\n\n   if (runloop_st->retro_unserialize_callback_original)\n   {\n      runloop_st->current_core.retro_unserialize                =\n         runloop_st->retro_unserialize_callback_original;\n      runloop_st->retro_unserialize_callback_original           = NULL;\n   }\n}\n\nstatic void *runahead_save_state_alloc(void)\n{\n   runloop_state_t     *runloop_st       = runloop_state_get_ptr();\n   retro_ctx_serialize_info_t *savestate = (retro_ctx_serialize_info_t*)\n      malloc(sizeof(retro_ctx_serialize_info_t));\n\n   if (!savestate)\n      return NULL;\n\n   savestate->data          = NULL;\n   savestate->data_const    = NULL;\n   savestate->size          = 0;\n\n   if (     (runloop_st->runahead_save_state_size > 0)\n         && (runloop_st->flags & RUNLOOP_FLAG_RUNAHEAD_SAVE_STATE_SIZE_KNOWN))\n   {\n      savestate->data       = malloc(runloop_st->runahead_save_state_size);\n      savestate->data_const = savestate->data;\n      savestate->size       = runloop_st->runahead_save_state_size;\n   }\n\n   return savestate;\n}\n\nstatic void runahead_save_state_free(void *data)\n{\n   retro_ctx_serialize_info_t *savestate = (retro_ctx_serialize_info_t*)data;\n   if (!savestate)\n      return;\n   free(savestate->data);\n   free(savestate);\n}\n\nstatic void runahead_save_state_list_init(\n      runloop_state_t *runloop_st,\n      size_t save_state_size)\n{\n   runloop_st->runahead_save_state_size  = save_state_size;\n   runloop_st->flags                    |= RUNLOOP_FLAG_RUNAHEAD_SAVE_STATE_SIZE_KNOWN;\n\n   mylist_create(&runloop_st->runahead_save_state_list, 16,\n         runahead_save_state_alloc, runahead_save_state_free);\n}\n\n/* Hooks - Hooks to cleanup, and add dirty input hooks */\nstatic void runahead_remove_hooks(runloop_state_t *runloop_st)\n{\n   if (runloop_st->original_retro_deinit)\n   {\n      runloop_st->current_core.retro_deinit =\n         runloop_st->original_retro_deinit;\n      runloop_st->original_retro_deinit     = NULL;\n   }\n\n   if (runloop_st->original_retro_unload)\n   {\n      runloop_st->current_core.retro_unload_game =\n         runloop_st->original_retro_unload;\n      runloop_st->original_retro_unload          = NULL;\n   }\n   runahead_remove_input_state_hook(runloop_st);\n}\n\nstatic void runahead_destroy(runloop_state_t *runloop_st)\n{\n   mylist_destroy(&runloop_st->runahead_save_state_list);\n   runahead_remove_hooks(runloop_st);\n   runahead_clear_variables(runloop_st);\n}\n\nstatic void runahead_unload_hook(void)\n{\n   runloop_state_t     *runloop_st  = runloop_state_get_ptr();\n\n   runahead_remove_hooks(runloop_st);\n   runahead_destroy(runloop_st);\n   runahead_secondary_core_destroy(runloop_st);\n   if (runloop_st->current_core.retro_unload_game)\n      runloop_st->current_core.retro_unload_game();\n   runloop_st->core_poll_type_override = POLL_TYPE_OVERRIDE_DONTCARE;\n}\n\nstatic void runahead_deinit_hook(void)\n{\n   runloop_state_t     *runloop_st = runloop_state_get_ptr();\n\n   runahead_remove_hooks(runloop_st);\n   runahead_destroy(runloop_st);\n   runahead_secondary_core_destroy(runloop_st);\n   if (runloop_st->current_core.retro_deinit)\n      runloop_st->current_core.retro_deinit();\n}\n\nstatic void runahead_add_hooks(runloop_state_t *runloop_st)\n{\n   if (!runloop_st->original_retro_deinit)\n   {\n      runloop_st->original_retro_deinit     =\n         runloop_st->current_core.retro_deinit;\n      runloop_st->current_core.retro_deinit = runahead_deinit_hook;\n   }\n\n   if (!runloop_st->original_retro_unload)\n   {\n      runloop_st->original_retro_unload          = runloop_st->current_core.retro_unload_game;\n      runloop_st->current_core.retro_unload_game = runahead_unload_hook;\n   }\n   runahead_add_input_state_hook(runloop_st);\n}\n\n/* Runahead Code */\n\nstatic void runahead_error(runloop_state_t *runloop_st)\n{\n   runloop_st->flags &= ~RUNLOOP_FLAG_RUNAHEAD_AVAILABLE;\n   mylist_destroy(&runloop_st->runahead_save_state_list);\n   runahead_remove_hooks(runloop_st);\n   runloop_st->runahead_save_state_size       = 0;\n   runloop_st->flags                         |= RUNLOOP_FLAG_RUNAHEAD_SAVE_STATE_SIZE_KNOWN;\n}\n\nstatic bool runahead_create(runloop_state_t *runloop_st)\n{\n   /* get savestate size and allocate buffer */\n   video_driver_state_t *video_st = video_state_get_ptr();\n   size_t info_size               = core_serialize_size_special();\n\n   runahead_save_state_list_init(runloop_st, info_size);\n   if (video_st->flags & VIDEO_FLAG_ACTIVE)\n      video_st->flags |=  VIDEO_FLAG_RUNAHEAD_IS_ACTIVE;\n   else\n      video_st->flags &= ~VIDEO_FLAG_RUNAHEAD_IS_ACTIVE;\n\n   if (      (runloop_st->runahead_save_state_size == 0)\n         || !(runloop_st->flags & RUNLOOP_FLAG_RUNAHEAD_SAVE_STATE_SIZE_KNOWN))\n   {\n      runahead_error(runloop_st);\n      return false;\n   }\n\n   runahead_add_hooks(runloop_st);\n   runloop_st->flags |= RUNLOOP_FLAG_RUNAHEAD_FORCE_INPUT_DIRTY;\n   if (runloop_st->runahead_save_state_list)\n      mylist_resize(runloop_st->runahead_save_state_list, 1, true);\n   return true;\n}\n\nstatic bool runahead_save_state(runloop_state_t *runloop_st)\n{\n   retro_ctx_serialize_info_t *serialize_info;\n\n   if (!runloop_st->runahead_save_state_list)\n      return false;\n\n   serialize_info                  =\n      (retro_ctx_serialize_info_t*)runloop_st->runahead_save_state_list->data[0];\n\n   if (core_serialize_special(serialize_info))\n      return true;\n\n   runahead_error(runloop_st);\n   return false;\n}\n\nstatic bool runahead_load_state(runloop_state_t *runloop_st)\n{\n   retro_ctx_serialize_info_t *serialize_info =\n      (retro_ctx_serialize_info_t*)\n      runloop_st->runahead_save_state_list->data[0];\n   bool last_dirty                            = (runloop_st->flags & RUNLOOP_FLAG_INPUT_IS_DIRTY) ? true : false;\n   bool ret                                   = core_unserialize_special(serialize_info);\n   if (last_dirty)\n      runloop_st->flags                      |=  RUNLOOP_FLAG_INPUT_IS_DIRTY;\n   else\n      runloop_st->flags                      &= ~RUNLOOP_FLAG_INPUT_IS_DIRTY;\n\n   if (!ret)\n      runahead_error(runloop_st);\n\n   return ret;\n}\n\n#if HAVE_DYNAMIC\nstatic bool runahead_load_state_secondary(runloop_state_t *runloop_st, settings_t *settings)\n{\n   retro_ctx_serialize_info_t *serialize_info =\n      (retro_ctx_serialize_info_t*)runloop_st->runahead_save_state_list->data[0];\n\n   if (!secondary_core_deserialize(runloop_st,\n            settings, serialize_info->data_const,\n            serialize_info->size))\n   {\n      runloop_st->flags &= ~RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE;\n      runahead_error(runloop_st);\n\n      return false;\n   }\n\n   return true;\n}\n#endif\n\nstatic void runahead_core_run_use_last_input(runloop_state_t *runloop_st)\n{\n   struct retro_callbacks *cbs            = &runloop_st->retro_ctx;\n   retro_input_poll_t old_poll_function   = cbs->poll_cb;\n   retro_input_state_t old_input_function = cbs->state_cb;\n\n   cbs->poll_cb                           = retro_input_poll_null;\n   cbs->state_cb                          = input_state_get_last;\n\n   runloop_st->current_core.retro_set_input_poll(cbs->poll_cb);\n   runloop_st->current_core.retro_set_input_state(cbs->state_cb);\n\n   runloop_st->current_core.retro_run();\n\n   cbs->poll_cb                           = old_poll_function;\n   cbs->state_cb                          = old_input_function;\n\n   runloop_st->current_core.retro_set_input_poll(cbs->poll_cb);\n   runloop_st->current_core.retro_set_input_state(cbs->state_cb);\n}\n\nvoid runahead_run(void *data,\n      int runahead_count,\n      bool runahead_hide_warnings,\n      bool use_secondary)\n{\n   runloop_state_t *runloop_st = (runloop_state_t*)data;\n   int frame_number        = 0;\n   bool last_frame         = false;\n   bool suspended_frame    = false;\n#if defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB)\n   const bool have_dynamic = true;\n   settings_t *settings    = config_get_ptr();\n#else\n   const bool have_dynamic = false;\n#endif\n   video_driver_state_t\n      *video_st            = video_state_get_ptr();\n   uint64_t frame_count    = video_st->frame_count;\n   audio_driver_state_t\n      *audio_st            = audio_state_get_ptr();\n\n   if (      runahead_count <= 0\n         || !(runloop_st->flags & RUNLOOP_FLAG_RUNAHEAD_AVAILABLE))\n      goto force_input_dirty;\n\n   if (!(runloop_st->flags & RUNLOOP_FLAG_RUNAHEAD_SAVE_STATE_SIZE_KNOWN))\n   {\n      /* Disable runahead if current core reports\n       * that it has an insufficient savestate\n       * support level */\n      if (!core_info_current_supports_runahead())\n      {\n         runahead_error(runloop_st);\n         /* If core is incompatible with runahead,\n          * log a warning but do not spam OSD messages.\n          * Runahead menu entries are hidden when using\n          * incompatible cores, so there is no mechanism\n          * for users to respond to notifications. In\n          * addition, auto-disabling runahead is a feature,\n          * not a cause for 'concern'; OSD warnings should\n          * be reserved for when a core reports that it is\n          * runahead-compatible but subsequently fails in\n          * execution */\n         RARCH_WARN(\"[Run-Ahead]: %s\\n\", msg_hash_to_str(MSG_RUNAHEAD_CORE_DOES_NOT_SUPPORT_RUNAHEAD));\n         goto force_input_dirty;\n      }\n\n      if (!runahead_create(runloop_st))\n      {\n         const char *_msg =\n            msg_hash_to_str(MSG_RUNAHEAD_CORE_DOES_NOT_SUPPORT_SAVESTATES);\n         if (!runahead_hide_warnings)\n            runloop_msg_queue_push(_msg, strlen(_msg), 0, 2 * 60, true, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n         RARCH_WARN(\"[Run-Ahead]: %s\\n\", _msg);\n         goto force_input_dirty;\n      }\n   }\n\n   /* Check for GUI */\n   /* Hack: If we were in the GUI, force a resync. */\n   if (frame_count != runloop_st->runahead_last_frame_count + 1)\n      runloop_st->flags                  |= RUNLOOP_FLAG_RUNAHEAD_FORCE_INPUT_DIRTY;\n\n   runloop_st->runahead_last_frame_count  = frame_count;\n\n   if (     !use_secondary\n         || !have_dynamic\n         || !(runloop_st->flags & RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE))\n   {\n      /* TODO: multiple savestates for higher performance\n       * when not using secondary core */\n      for (frame_number = 0; frame_number <= runahead_count; frame_number++)\n      {\n         last_frame      = frame_number == runahead_count;\n         suspended_frame = !last_frame;\n\n         if (suspended_frame)\n         {\n            audio_st->flags     |=  AUDIO_FLAG_SUSPENDED;\n            video_st->flags     &= ~VIDEO_FLAG_ACTIVE;\n         }\n\n         if (frame_number == 0)\n            core_run();\n         else\n            runahead_core_run_use_last_input(runloop_st);\n\n         if (suspended_frame)\n         {\n            if (video_st->flags & VIDEO_FLAG_RUNAHEAD_IS_ACTIVE)\n               video_st->flags |=  VIDEO_FLAG_ACTIVE;\n            else\n               video_st->flags &= ~VIDEO_FLAG_ACTIVE;\n\n            audio_st->flags    &= ~AUDIO_FLAG_SUSPENDED;\n         }\n\n         if (frame_number == 0)\n         {\n            if (!runahead_save_state(runloop_st))\n            {\n               const char *_msg =\n                  msg_hash_to_str(MSG_RUNAHEAD_FAILED_TO_SAVE_STATE);\n               runloop_msg_queue_push(_msg, strlen(_msg), 0, 3 * 60, true, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n               RARCH_WARN(\"[Run-Ahead]: %s\\n\", _msg);\n               return;\n            }\n         }\n\n         if (last_frame)\n         {\n            if (!runahead_load_state(runloop_st))\n            {\n               const char *_msg = msg_hash_to_str(MSG_RUNAHEAD_FAILED_TO_LOAD_STATE);\n               runloop_msg_queue_push(_msg, strlen(_msg), 0, 3 * 60, true, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n               RARCH_WARN(\"[Run-Ahead]: %s\\n\", _msg);\n               return;\n            }\n         }\n      }\n   }\n   else\n   {\n#if HAVE_DYNAMIC\n      if (!secondary_core_ensure_exists(runloop_st, config_get_ptr()))\n      {\n         const char *_msg =\n            msg_hash_to_str(MSG_RUNAHEAD_FAILED_TO_CREATE_SECONDARY_INSTANCE);\n         runahead_secondary_core_destroy(runloop_st);\n         runloop_st->flags &= ~RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE;\n         runloop_msg_queue_push(_msg, strlen(_msg), 0, 3 * 60, true, NULL,\n               MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n         RARCH_WARN(\"[Run-Ahead]: %s\\n\", _msg);\n         goto force_input_dirty;\n      }\n\n      /* run main core with video suspended */\n      video_st->flags &= ~VIDEO_FLAG_ACTIVE;\n      core_run();\n      if (video_st->flags & VIDEO_FLAG_RUNAHEAD_IS_ACTIVE)\n         video_st->flags |=  VIDEO_FLAG_ACTIVE;\n      else\n         video_st->flags &= ~VIDEO_FLAG_ACTIVE;\n\n      if (     (runloop_st->flags & RUNLOOP_FLAG_INPUT_IS_DIRTY)\n            || (runloop_st->flags & RUNLOOP_FLAG_RUNAHEAD_FORCE_INPUT_DIRTY))\n      {\n         runloop_st->flags &= ~RUNLOOP_FLAG_INPUT_IS_DIRTY;\n\n         if (!runahead_save_state(runloop_st))\n         {\n            const char *_msg = msg_hash_to_str(MSG_RUNAHEAD_FAILED_TO_SAVE_STATE);\n            runloop_msg_queue_push(_msg, strlen(_msg), 0, 3 * 60, true, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n            RARCH_WARN(\"[Run-Ahead]: %s\\n\", _msg);\n            return;\n         }\n\n         if (!runahead_load_state_secondary(runloop_st, settings))\n         {\n            const char *_msg = msg_hash_to_str(MSG_RUNAHEAD_FAILED_TO_LOAD_STATE);\n            runloop_msg_queue_push(_msg, strlen(_msg), 0, 3 * 60, true, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n            RARCH_WARN(\"[Run-Ahead]: %s\\n\", _msg);\n            return;\n         }\n\n         for (frame_number = 0; frame_number < runahead_count - 1; frame_number++)\n         {\n            video_st->flags             &= ~VIDEO_FLAG_ACTIVE;\n            audio_st->flags             |= AUDIO_FLAG_SUSPENDED\n                                         | AUDIO_FLAG_HARD_DISABLE;\n            if (secondary_core_run_use_last_input(runloop_st))\n               runloop_st->flags        |=  RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE;\n            else\n               runloop_st->flags        &= ~RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE;\n            audio_st->flags             &= ~(AUDIO_FLAG_SUSPENDED\n                                         | AUDIO_FLAG_HARD_DISABLE);\n            if (video_st->flags & VIDEO_FLAG_RUNAHEAD_IS_ACTIVE)\n               video_st->flags          |=  VIDEO_FLAG_ACTIVE;\n            else\n               video_st->flags          &= ~VIDEO_FLAG_ACTIVE;\n         }\n      }\n      audio_st->flags                   |= AUDIO_FLAG_SUSPENDED\n                                         | AUDIO_FLAG_HARD_DISABLE;\n      if (secondary_core_run_use_last_input(runloop_st))\n         runloop_st->flags              |=  RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE;\n      else\n         runloop_st->flags              &= ~RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE;\n      audio_st->flags                   &= ~(AUDIO_FLAG_SUSPENDED\n                                         | AUDIO_FLAG_HARD_DISABLE);\n#endif\n   }\n   runloop_st->flags &= ~RUNLOOP_FLAG_RUNAHEAD_FORCE_INPUT_DIRTY;\n   return;\n\nforce_input_dirty:\n   core_run();\n   runloop_st->flags |=  RUNLOOP_FLAG_RUNAHEAD_FORCE_INPUT_DIRTY;\n}\n\n/* Preemptive Frames */\n\nstatic int16_t preempt_input_state(unsigned port,\n      unsigned device, unsigned index, unsigned id)\n{\n   runloop_state_t *runloop_st = runloop_state_get_ptr();\n   preempt_t *preempt          = runloop_st->preempt_data;\n   unsigned device_class       = device & RETRO_DEVICE_MASK;\n\n   switch (device_class)\n   {\n      case RETRO_DEVICE_ANALOG:\n         /* Add requested inputs to mask */\n         preempt->analog_mask[port] |= (1 << (id + index * 2));\n         break;\n      case RETRO_DEVICE_LIGHTGUN:\n      case RETRO_DEVICE_POINTER:\n         /* Set pointing device for this port */\n         preempt->ptr_dev_needed[port] = device_class;\n         break;\n      case RETRO_DEVICE_MOUSE:\n         /* Set pointing device and return stored x,y */\n         if (id <= RETRO_DEVICE_ID_MOUSE_Y)\n         {\n            preempt->ptr_dev_needed[port] = device_class;\n            if (preempt->ptr_dev_polled[port] == device_class)\n               return preempt->ptrdev_state[port][id];\n         }\n         break;\n      default:\n         break;\n   }\n\n   return input_driver_state_wrapper(port, device, index, id);\n}\n\nstatic const char* preempt_allocate(runloop_state_t *runloop_st,\n      const uint8_t frames)\n{\n   uint8_t i;\n   size_t info_size;\n   preempt_t *preempt          = (preempt_t*)calloc(1, sizeof(preempt_t));\n\n   if (!(runloop_st->preempt_data = preempt))\n      return msg_hash_to_str(MSG_PREEMPT_FAILED_TO_ALLOCATE);\n\n   info_size = core_serialize_size_special();\n   if (!info_size)\n      return msg_hash_to_str(MSG_PREEMPT_CORE_DOES_NOT_SUPPORT_SAVESTATES);\n\n   preempt->state_size = info_size;\n   preempt->frames     = frames;\n\n   for (i = 0; i < frames; i++)\n   {\n      preempt->buffer[i] = malloc(preempt->state_size);\n      if (!preempt->buffer[i])\n         return msg_hash_to_str(MSG_PREEMPT_FAILED_TO_ALLOCATE);\n   }\n\n   return NULL;\n}\n\n/**\n * preempt_deinit:\n *\n * Frees preempt object and unsets overrides.\n **/\nvoid preempt_deinit(void *data)\n{\n   size_t i;\n   runloop_state_t *runloop_st       = (runloop_state_t*)data;\n   preempt_t *preempt                = runloop_st->preempt_data;\n   struct retro_core_t *current_core = &runloop_st->current_core;\n\n   if (!preempt)\n      return;\n\n   /* Free memory */\n   for (i = 0; i < preempt->frames; i++)\n      free(preempt->buffer[i]);\n\n   free(preempt);\n   runloop_st->preempt_data = NULL;\n\n   /* Undo overrides */\n   runloop_st->flags |= (RUNLOOP_FLAG_RUNAHEAD_AVAILABLE\n         | RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE);\n\n   if (current_core->retro_set_input_poll)\n      current_core->retro_set_input_poll(runloop_st->input_poll_callback_original);\n   if (current_core->retro_set_input_state)\n      current_core->retro_set_input_state(runloop_st->retro_ctx.state_cb);\n}\n\n\n/**\n * preempt_init:\n *\n * @return true on success, false on failure\n *\n * Allocates savestate buffer and sets overrides for preemptive frames.\n **/\nbool preempt_init(void *data)\n{\n   runloop_state_t *runloop_st = (runloop_state_t*)data;\n   settings_t *settings        = config_get_ptr();\n   const char *_msg            = NULL;\n\n   if (     runloop_st->preempt_data\n         || !settings->bools.preemptive_frames_enable\n         || !settings->uints.run_ahead_frames\n         || !(runloop_st->current_core.flags & RETRO_CORE_FLAG_GAME_LOADED))\n      return false;\n\n   /* Check if supported - same requirements as runahead */\n   if (!core_info_current_supports_runahead())\n   {\n      _msg = msg_hash_to_str(MSG_PREEMPT_CORE_DOES_NOT_SUPPORT_PREEMPT);\n      goto error;\n   }\n\n   /* Set flags to block runahead and request 'same instance' states */\n   runloop_st->flags &= ~(RUNLOOP_FLAG_RUNAHEAD_AVAILABLE\n         | RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE);\n\n   /* Run at least one frame before attempting\n    * retro_serialize_size or retro_serialize */\n   if (video_state_get_ptr()->frame_count == 0)\n      runloop_st->current_core.retro_run();\n\n   /* Allocate - same 'frames' setting as runahead */\n   if ((_msg = preempt_allocate(runloop_st,\n               settings->uints.run_ahead_frames)))\n      goto error;\n\n   /* Only poll in preempt_run() */\n   runloop_st->current_core.retro_set_input_poll(retro_input_poll_null);\n   /* Track requested analog states and pointing device types */\n   runloop_st->current_core.retro_set_input_state(preempt_input_state);\n\n   return true;\n\nerror:\n   preempt_deinit(runloop_st);\n\n   if (!settings->bools.run_ahead_hide_warnings)\n      runloop_msg_queue_push(_msg, strlen(_msg), 0, 2 * 60, true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n   RARCH_WARN(\"[Preemptive Frames]: %s\\n\", _msg);\n\n   return false;\n}\n\nstatic INLINE bool preempt_analog_input_dirty(preempt_t *preempt,\n      retro_input_state_t state_cb, unsigned port)\n{\n   int16_t state[20] = {0};\n   uint8_t base, i;\n\n   /* axes */\n   for (i = 0; i < 2; i++)\n   {\n      base = i * 2;\n      if (preempt->analog_mask[port] & (1 << (base    )))\n         state[base    ] = state_cb(port, RETRO_DEVICE_ANALOG, i, 0);\n      if (preempt->analog_mask[port] & (1 << (base + 1)))\n         state[base + 1] = state_cb(port, RETRO_DEVICE_ANALOG, i, 1);\n   }\n\n   /* buttons */\n   if (preempt->analog_mask[port] & 0xfff0)\n   {\n      for (i = 0; i < RARCH_FIRST_CUSTOM_BIND; i++)\n      {\n         if (preempt->analog_mask[port] & (1 << (i + 4)))\n            state[i + 4] = state_cb(port, RETRO_DEVICE_ANALOG,\n                  RETRO_DEVICE_INDEX_ANALOG_BUTTON, i);\n      }\n   }\n\n   if (memcmp(preempt->analog_state[port], state, sizeof(state)) == 0)\n      return false;\n\n   memcpy(preempt->analog_state[port], state, sizeof(state));\n   return true;\n}\n\nstatic INLINE bool preempt_ptr_input_dirty(preempt_t *preempt,\n      retro_input_state_t state_cb, unsigned device, unsigned port)\n{\n   int16_t state[4]  = {0};\n   unsigned count_id = 0;\n   unsigned x_id     = 0;\n   unsigned id, max_id;\n\n   switch (device)\n   {\n      case RETRO_DEVICE_MOUSE:\n         max_id = RETRO_DEVICE_ID_MOUSE_BUTTON_5;\n         break;\n      case RETRO_DEVICE_LIGHTGUN:\n         x_id   = RETRO_DEVICE_ID_LIGHTGUN_SCREEN_X;\n         max_id = RETRO_DEVICE_ID_LIGHTGUN_DPAD_RIGHT;\n         break;\n      case RETRO_DEVICE_POINTER:\n         max_id   = RETRO_DEVICE_ID_POINTER_PRESSED;\n         count_id = RETRO_DEVICE_ID_POINTER_COUNT;\n         break;\n      default:\n         return false;\n   }\n\n   /* x, y */\n   state[0] = state_cb(port, device, 0, x_id    );\n   state[1] = state_cb(port, device, 0, x_id + 1);\n\n   /* buttons */\n   for (id = 2; id <= max_id; id++)\n      state[2] |= state_cb(port, device, 0, id) ? 1 << id : 0;\n\n   /* ptr count */\n   if (count_id)\n      state[3] = state_cb(port, device, 0, count_id);\n\n   if (memcmp(preempt->ptrdev_state[port], state, sizeof(state)) == 0)\n      return false;\n\n   memcpy(preempt->ptrdev_state[port], state, sizeof(state));\n   return true;\n}\n\nstatic INLINE void preempt_input_poll(preempt_t *preempt,\n      runloop_state_t *runloop_st, settings_t *settings)\n{\n   size_t p;\n   int16_t joypad_state;\n   retro_input_state_t state_cb = input_driver_state_wrapper;\n   unsigned max_users           = settings->uints.input_max_users;\n\n   input_driver_poll();\n\n   /* Check for input state changes */\n   for (p = 0; p < max_users; p++)\n   {\n      /* Check full digital joypad */\n      joypad_state = state_cb(p, RETRO_DEVICE_JOYPAD,\n            0, RETRO_DEVICE_ID_JOYPAD_MASK);\n      if (joypad_state != preempt->joypad_state[p])\n      {\n         preempt->joypad_state[p] = joypad_state;\n         runloop_st->flags |= RUNLOOP_FLAG_INPUT_IS_DIRTY;\n      }\n\n      /* Check requested analogs */\n      if (     preempt->analog_mask[p]\n            && preempt_analog_input_dirty(preempt, state_cb, (unsigned)p))\n      {\n         runloop_st->flags |= RUNLOOP_FLAG_INPUT_IS_DIRTY;\n         preempt->analog_mask[p] = 0;\n      }\n\n      /* Check requested pointing device */\n      if (preempt->ptr_dev_needed[p])\n      {\n         if (preempt_ptr_input_dirty(\n               preempt, state_cb, preempt->ptr_dev_needed[p], (unsigned)p))\n            runloop_st->flags |= RUNLOOP_FLAG_INPUT_IS_DIRTY;\n\n         preempt->ptr_dev_polled[p] = preempt->ptr_dev_needed[p];\n         preempt->ptr_dev_needed[p] = RETRO_DEVICE_NONE;\n      }\n   }\n}\n\n/* macro for preempt_run */\n#define PREEMPT_NEXT_PTR(x) ((x + 1) % preempt->frames)\n\n/**\n * preempt_run:\n * @preempt : pointer to preemptive frames object\n *\n * Call in place of core_run() for preemptive frames.\n **/\nvoid preempt_run(preempt_t *preempt, void *data)\n{\n   runloop_state_t     *runloop_st   = (runloop_state_t*)data;\n   struct retro_core_t *current_core = &runloop_st->current_core;\n   const char *_msg                  = NULL;\n   settings_t *settings              = config_get_ptr();\n   audio_driver_state_t *audio_st    = audio_state_get_ptr();\n   video_driver_state_t *video_st    = video_state_get_ptr();\n\n   /* Poll and check for dirty input */\n   preempt_input_poll(preempt, runloop_st, settings);\n\n   runloop_st->flags                |= RUNLOOP_FLAG_REQUEST_SPECIAL_SAVESTATE;\n\n   if ((runloop_st->flags & RUNLOOP_FLAG_INPUT_IS_DIRTY)\n         && preempt->frame_count >= preempt->frames)\n   {\n      /* Suspend A/V and run preemptive frames */\n      audio_st->flags |=  AUDIO_FLAG_SUSPENDED;\n      video_st->flags &= ~VIDEO_FLAG_ACTIVE;\n\n      if (!current_core->retro_unserialize(\n            preempt->buffer[preempt->start_ptr], preempt->state_size))\n      {\n         _msg = msg_hash_to_str(MSG_PREEMPT_FAILED_TO_LOAD_STATE);\n         goto error;\n      }\n\n      current_core->retro_run();\n      preempt->replay_ptr = PREEMPT_NEXT_PTR(preempt->start_ptr);\n\n      while (preempt->replay_ptr != preempt->start_ptr)\n      {\n         if (!current_core->retro_serialize(\n               preempt->buffer[preempt->replay_ptr], preempt->state_size))\n         {\n            _msg = msg_hash_to_str(MSG_PREEMPT_FAILED_TO_SAVE_STATE);\n            goto error;\n         }\n\n         current_core->retro_run();\n         preempt->replay_ptr = PREEMPT_NEXT_PTR(preempt->replay_ptr);\n      }\n\n      audio_st->flags &= ~AUDIO_FLAG_SUSPENDED;\n      video_st->flags |=  VIDEO_FLAG_ACTIVE;\n   }\n\n   /* Save current state and set start_ptr to oldest state */\n   if (!current_core->retro_serialize(\n         preempt->buffer[preempt->start_ptr], preempt->state_size))\n   {\n      _msg = msg_hash_to_str(MSG_PREEMPT_FAILED_TO_SAVE_STATE);\n      goto error;\n   }\n   preempt->start_ptr = PREEMPT_NEXT_PTR(preempt->start_ptr);\n   runloop_st->flags &= ~(RUNLOOP_FLAG_REQUEST_SPECIAL_SAVESTATE\n         | RUNLOOP_FLAG_INPUT_IS_DIRTY);\n\n   /* Run normal frame */\n   current_core->retro_run();\n   preempt->frame_count++;\n   return;\n\nerror:\n   runloop_st->flags &= ~(RUNLOOP_FLAG_REQUEST_SPECIAL_SAVESTATE\n         | RUNLOOP_FLAG_INPUT_IS_DIRTY);\n   audio_st->flags   &= ~AUDIO_FLAG_SUSPENDED;\n   video_st->flags   |=  VIDEO_FLAG_ACTIVE;\n   preempt_deinit(runloop_st);\n\n   if (!settings->bools.run_ahead_hide_warnings)\n      runloop_msg_queue_push(_msg, strlen(_msg), 0, 2 * 60, true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n   RARCH_ERR(\"[Preemptive Frames]: %s\\n\", _msg);\n}\n\nvoid runahead_clear_variables(void *data)\n{\n   runloop_state_t *runloop_st            = (runloop_state_t*)data;\n   video_driver_state_t *video_st         = video_state_get_ptr();\n   runloop_st->runahead_save_state_size   = 0;\n   runloop_st->flags                     &= ~RUNLOOP_FLAG_RUNAHEAD_SAVE_STATE_SIZE_KNOWN;\n   video_st->flags                       |= VIDEO_FLAG_RUNAHEAD_IS_ACTIVE;\n   runloop_st->flags                     |= RUNLOOP_FLAG_RUNAHEAD_AVAILABLE\n                                          | RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE\n                                          | RUNLOOP_FLAG_RUNAHEAD_FORCE_INPUT_DIRTY;\n   runloop_st->runahead_last_frame_count  = 0;\n}\n"
        },
        {
          "name": "runahead.h",
          "type": "blob",
          "size": 2.654296875,
          "content": "/*  RetroArch - A frontend for libretro.\r\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\r\n *  Copyright (C) 2011-2023 - Daniel De Matteis\r\n *\r\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\r\n *  of the GNU General Public License as published by the Free Software Found-\r\n *  ation, either version 3 of the License, or (at your option) any later version.\r\n *\r\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\r\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\r\n *  PURPOSE.  See the GNU General Public License for more details.\r\n *\r\n *  You should have received a copy of the GNU General Public License along with RetroArch.\r\n *  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n\r\n#ifndef __RUNAHEAD_H\r\n#define __RUNAHEAD_H\r\n\r\n#include <stdint.h>\r\n\r\n#include <boolean.h>\r\n#include <retro_common_api.h>\r\n\r\n#include \"core.h\"\r\n\r\n#define MAX_RUNAHEAD_FRAMES 12\r\n\r\ntypedef void *(*constructor_t)(void);\r\ntypedef void  (*destructor_t )(void*);\r\n\r\ntypedef struct my_list_t\r\n{\r\n   void **data;\r\n   constructor_t constructor;\r\n   destructor_t destructor;\r\n   int capacity;\r\n   int size;\r\n} my_list;\r\n\r\ntypedef struct preemptive_frames_data\r\n{\r\n   /* Savestate buffer */\r\n   void* buffer[MAX_RUNAHEAD_FRAMES];\r\n   size_t state_size;\r\n\r\n   /* Frame count since buffer init/reset */\r\n   uint64_t frame_count;\r\n\r\n   /* Mask of analog states requested */\r\n   uint32_t analog_mask[MAX_USERS];\r\n\r\n   /* Input states. Replays triggered on changes */\r\n   int16_t joypad_state[MAX_USERS];\r\n   int16_t analog_state[MAX_USERS][20];\r\n   int16_t ptrdev_state[MAX_USERS][4];\r\n\r\n   /* Pointing device requested */\r\n   uint8_t ptr_dev_needed[MAX_USERS];\r\n   /* Device ID of ptrdev_state */\r\n   uint8_t ptr_dev_polled[MAX_USERS];\r\n   /* Buffer indexes for replays */\r\n   uint8_t start_ptr;\r\n   uint8_t replay_ptr;\r\n   /* Number of latency frames to remove */\r\n   uint8_t frames;\r\n} preempt_t;\r\n\r\nRETRO_BEGIN_DECLS\r\n\r\ntypedef bool(*runahead_load_state_function)(const void*, size_t);\r\n\r\nvoid runahead_run(\r\n      void *data,\r\n      int runahead_count,\r\n      bool runahead_hide_warnings,\r\n      bool use_secondary);\r\n\r\nvoid runahead_clear_variables(void *data);\r\n\r\nvoid runahead_remember_controller_port_device(void *data,\r\n      long port, long device);\r\nvoid runahead_clear_controller_port_map(void *data);\r\n\r\nvoid runahead_set_load_content_info(\r\n      void *data,\r\n      const retro_ctx_load_content_info_t *ctx);\r\n\r\nvoid runahead_secondary_core_destroy(void *data);\r\n\r\nbool preempt_init(void *data);\r\nvoid preempt_deinit(void *data);\r\n\r\nvoid preempt_run(preempt_t *preempt, void *data);\r\n\r\nRETRO_END_DECLS\r\n\r\n#endif\r\n"
        },
        {
          "name": "runloop.c",
          "type": "blob",
          "size": 274.0009765625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2021 - Daniel De Matteis\n *  Copyright (C) 2012-2015 - Michael Lelli\n *  Copyright (C) 2014-2017 - Jean-Andr Santoni\n *  Copyright (C) 2016-2019 - Brad Parker\n *  Copyright (C) 2016-2019 - Andrs Surez (input mapper code)\n *  Copyright (C) 2016-2017 - Gregor Richards (network code)\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifdef _WIN32\n#ifdef _XBOX\n#include <xtl.h>\n#else\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#endif\n#if defined(DEBUG) && defined(HAVE_DRMINGW)\n#include \"exchndl.h\"\n#endif\n#endif\n\n#if defined(DINGUX)\n#include <sys/types.h>\n#include <unistd.h>\n#endif\n\n#if (defined(__linux__) || defined(__unix__) || defined(DINGUX)) && !defined(EMSCRIPTEN)\n#include <signal.h>\n#endif\n\n#if defined(_WIN32_WINNT) && _WIN32_WINNT < 0x0500 || defined(_XBOX)\n#ifndef LEGACY_WIN32\n#define LEGACY_WIN32\n#endif\n#endif\n\n#if defined(_WIN32) && !defined(_XBOX) && !defined(__WINRT__)\n#include <objbase.h>\n#include <process.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n#include <locale.h>\n\n#include <boolean.h>\n#include <clamping.h>\n#include <string/stdstring.h>\n#include <dynamic/dylib.h>\n#include <file/config_file.h>\n#include <lists/string_list.h>\n#include <memalign.h>\n#include <retro_math.h>\n#include <retro_timers.h>\n#include <encodings/utf.h>\n\n#include <libretro.h>\n#ifdef HAVE_VULKAN\n#include <libretro_vulkan.h>\n#endif\n\n#define VFS_FRONTEND\n#include <vfs/vfs_implementation.h>\n\n#include <features/features_cpu.h>\n\n#include <compat/strl.h>\n#include <compat/strcasestr.h>\n#include <compat/getopt.h>\n#include <compat/posix_string.h>\n#include <streams/file_stream.h>\n#include <file/file_path.h>\n#include <retro_miscellaneous.h>\n#include <queues/message_queue.h>\n#include <lists/dir_list.h>\n\n#ifdef EMSCRIPTEN\n#include <emscripten/emscripten.h>\n#endif\n\n#ifdef HAVE_LIBNX\n#include <switch.h>\n#include \"switch_performance_profiles.h\"\n#endif\n\n#if defined(ANDROID)\n#include \"play_feature_delivery/play_feature_delivery.h\"\n#endif\n\n#ifdef HAVE_PRESENCE\n#include \"network/presence.h\"\n#endif\n#ifdef HAVE_DISCORD\n#include \"network/discord.h\"\n#endif\n\n#include \"config.def.h\"\n\n#include \"runtime_file.h\"\n#include \"runloop.h\"\n#include \"camera/camera_driver.h\"\n#include \"location_driver.h\"\n#include \"record/record_driver.h\"\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef HAVE_NETWORKING\n#include <net/net_compat.h>\n#include <net/net_socket.h>\n#endif\n\n#include <audio/audio_resampler.h>\n\n#include \"audio/audio_driver.h\"\n#include \"gfx/gfx_animation.h\"\n#include \"gfx/gfx_display.h\"\n#include \"gfx/gfx_thumbnail.h\"\n#include \"gfx/video_filter.h\"\n\n#include \"input/input_osk.h\"\n\n#ifdef HAVE_RUNAHEAD\n#include \"runahead.h\"\n#endif\n\n#ifdef HAVE_MENU\n#include \"menu/menu_cbs.h\"\n#include \"menu/menu_driver.h\"\n#include \"menu/menu_input.h\"\n#endif\n\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n#include \"menu/menu_shader.h\"\n#endif\n\n#ifdef HAVE_GFX_WIDGETS\n#include \"gfx/gfx_widgets.h\"\n#endif\n\n#include \"input/input_keymaps.h\"\n#include \"input/input_remapping.h\"\n\n#ifdef HAVE_MICROPHONE\n#include \"audio/microphone_driver.h\"\n#endif\n\n#ifdef HAVE_CHEEVOS\n#include \"cheevos/cheevos.h\"\n#include \"cheevos/cheevos_menu.h\"\n#endif\n\n#ifdef HAVE_NETWORKING\n#include \"network/netplay/netplay.h\"\n#include \"network/netplay/netplay_private.h\"\n#ifdef HAVE_WIFI\n#include \"network/wifi_driver.h\"\n#endif\n#endif\n\n#ifdef HAVE_THREADS\n#include <rthreads/rthreads.h>\n#endif\n\n#include \"autosave.h\"\n#include \"command.h\"\n#include \"config.features.h\"\n#include \"cores/internal_cores.h\"\n#include \"content.h\"\n#include \"core_info.h\"\n#include \"dynamic.h\"\n#include \"defaults.h\"\n#include \"msg_hash.h\"\n#include \"paths.h\"\n#include \"file_path_special.h\"\n#include \"ui/ui_companion_driver.h\"\n#include \"verbosity.h\"\n\n#include \"frontend/frontend_driver.h\"\n#ifdef HAVE_THREADS\n#include \"gfx/video_thread_wrapper.h\"\n#endif\n#include \"gfx/video_display_server.h\"\n#ifdef HAVE_CRTSWITCHRES\n#include \"gfx/video_crt_switch.h\"\n#endif\n#ifdef HAVE_BLUETOOTH\n#include \"bluetooth/bluetooth_driver.h\"\n#endif\n#include \"misc/cpufreq/cpufreq.h\"\n#include \"led/led_driver.h\"\n#include \"midi_driver.h\"\n#include \"location_driver.h\"\n#include \"core.h\"\n#include \"configuration.h\"\n#include \"list_special.h\"\n#include \"core_option_manager.h\"\n#ifdef HAVE_CHEATS\n#include \"cheat_manager.h\"\n#endif\n#ifdef HAVE_REWIND\n#include \"state_manager.h\"\n#endif\n#include \"tasks/task_content.h\"\n#include \"tasks/task_file_transfer.h\"\n#include \"tasks/task_powerstate.h\"\n#include \"tasks/tasks_internal.h\"\n#include \"performance_counters.h\"\n\n#include \"version.h\"\n#include \"version_git.h\"\n\n#include \"retroarch.h\"\n\n#include \"accessibility.h\"\n\n#if defined(HAVE_SDL) || defined(HAVE_SDL2) || defined(HAVE_SDL_DINGUX)\n#include \"SDL.h\"\n#endif\n\n#ifdef HAVE_LAKKA\n#include \"lakka.h\"\n#endif\n\n#if TARGET_OS_IPHONE\n#include \"JITSupport.h\"\n#endif\n\n#define SHADER_FILE_WATCH_DELAY_MSEC 500\n\n#define QUIT_DELAY_USEC 3 * 1000000 /* 3 seconds */\n\n#define DEFAULT_NETWORK_GAMEPAD_PORT 55400\n#define UDP_FRAME_PACKETS 16\n\n#ifdef HAVE_ZLIB\n#define DEFAULT_EXT \"zip\"\n#else\n#define DEFAULT_EXT \"\"\n#endif\n\n#ifdef HAVE_DYNAMIC\n#define SYMBOL(x) do { \\\n   function_t func = dylib_proc(lib_handle_local, #x); \\\n   memcpy(&current_core->x, &func, sizeof(func)); \\\n   if (!current_core->x) { RARCH_ERR(\"Failed to load symbol: \\\"%s\\\"\\n\", #x); retroarch_fail(1, \"runloop_init_libretro_symbols()\"); } \\\n} while (0)\n#else\n#define SYMBOL(x) current_core->x = x\n#endif\n\n#define SYMBOL_DUMMY(x) current_core->x = libretro_dummy_##x\n\n#ifdef HAVE_FFMPEG\n#define SYMBOL_FFMPEG(x) current_core->x = libretro_ffmpeg_##x\n#endif\n\n#ifdef HAVE_MPV\n#define SYMBOL_MPV(x) current_core->x = libretro_mpv_##x\n#endif\n\n#ifdef HAVE_IMAGEVIEWER\n#define SYMBOL_IMAGEVIEWER(x) current_core->x = libretro_imageviewer_##x\n#endif\n\n#if defined(HAVE_NETWORKING) && defined(HAVE_NETWORKGAMEPAD)\n#define SYMBOL_NETRETROPAD(x) current_core->x = libretro_netretropad_##x\n#endif\n\n#if defined(HAVE_VIDEOPROCESSOR)\n#define SYMBOL_VIDEOPROCESSOR(x) current_core->x = libretro_videoprocessor_##x\n#endif\n\n#define CORE_SYMBOLS(x) \\\n            x(retro_init); \\\n            x(retro_deinit); \\\n            x(retro_api_version); \\\n            x(retro_get_system_info); \\\n            x(retro_get_system_av_info); \\\n            x(retro_set_environment); \\\n            x(retro_set_video_refresh); \\\n            x(retro_set_audio_sample); \\\n            x(retro_set_audio_sample_batch); \\\n            x(retro_set_input_poll); \\\n            x(retro_set_input_state); \\\n            x(retro_set_controller_port_device); \\\n            x(retro_reset); \\\n            x(retro_run); \\\n            x(retro_serialize_size); \\\n            x(retro_serialize); \\\n            x(retro_unserialize); \\\n            x(retro_cheat_reset); \\\n            x(retro_cheat_set); \\\n            x(retro_load_game); \\\n            x(retro_load_game_special); \\\n            x(retro_unload_game); \\\n            x(retro_get_region); \\\n            x(retro_get_memory_data); \\\n            x(retro_get_memory_size);\n\n#ifdef _WIN32\n#define PERF_LOG_FMT \"[PERF]: Avg (%s): %I64u ticks, %I64u runs.\\n\"\n#else\n#define PERF_LOG_FMT \"[PERF]: Avg (%s): %llu ticks, %llu runs.\\n\"\n#endif\n\nstatic runloop_state_t runloop_state      = {0};\n\n/* GLOBAL POINTER GETTERS */\nrunloop_state_t *runloop_state_get_ptr(void)\n{\n   return &runloop_state;\n}\n\nbool state_manager_frame_is_reversed(void)\n{\n#ifdef HAVE_REWIND\n   return (runloop_state.rewind_st.flags & STATE_MGR_REWIND_ST_FLAG_FRAME_IS_REVERSED) > 0;\n#else\n   return false;\n#endif\n}\n\ncontent_state_t *content_state_get_ptr(void)\n{\n   return &runloop_state.content_st;\n}\n\n/* Get the current subsystem rom id */\nunsigned content_get_subsystem_rom_id(void)\n{\n   return runloop_state.content_st.pending_subsystem_rom_id;\n}\n\n/* Get the current subsystem */\nint content_get_subsystem(void)\n{\n   return runloop_state.content_st.pending_subsystem_id;\n}\n\nstruct retro_perf_counter **retro_get_perf_counter_libretro(void)\n{\n   return runloop_state.perf_counters_libretro;\n}\n\nunsigned retro_get_perf_count_libretro(void)\n{\n   return runloop_state.perf_ptr_libretro;\n}\n\nvoid runloop_performance_counter_register(struct retro_perf_counter *perf)\n{\n   if (     perf->registered\n         || runloop_state.perf_ptr_libretro >= MAX_COUNTERS)\n      return;\n\n   runloop_state.perf_counters_libretro[runloop_state.perf_ptr_libretro++] = perf;\n   perf->registered = true;\n}\n\nvoid runloop_log_counters(\n      struct retro_perf_counter **counters, unsigned num)\n{\n   int i;\n   for (i = 0; i < (int)num; i++)\n   {\n      if (counters[i]->call_cnt)\n      {\n         RARCH_LOG(PERF_LOG_FMT,\n               counters[i]->ident,\n               (uint64_t)counters[i]->total /\n               (uint64_t)counters[i]->call_cnt,\n               (uint64_t)counters[i]->call_cnt);\n      }\n   }\n}\n\nstatic void runloop_perf_log(void)\n{\n   if (!runloop_state.perfcnt_enable)\n      return;\n\n   RARCH_LOG(\"[PERF]: Performance counters (libretro):\\n\");\n   runloop_log_counters(runloop_state.perf_counters_libretro,\n         runloop_state.perf_ptr_libretro);\n}\n\nstatic bool runloop_environ_cb_get_system_info(unsigned cmd, void *data)\n{\n   runloop_state_t *runloop_st    = &runloop_state;\n   rarch_system_info_t *sys_info  = &runloop_st->system;\n\n   switch (cmd)\n   {\n      case RETRO_ENVIRONMENT_SET_SUPPORT_NO_GAME:\n         *runloop_st->load_no_content_hook = *(const bool*)data;\n         break;\n      case RETRO_ENVIRONMENT_SET_SUBSYSTEM_INFO:\n      {\n         size_t i, j, size;\n         const struct retro_subsystem_info *info =\n            (const struct retro_subsystem_info*)data;\n         settings_t *settings    = config_get_ptr();\n         unsigned log_level      = settings->uints.libretro_log_level;\n\n         runloop_st->subsystem_current_count = 0;\n\n         RARCH_LOG(\"[Environ]: SET_SUBSYSTEM_INFO.\\n\");\n\n         for (i = 0; info[i].ident; i++)\n         {\n            if (log_level != RETRO_LOG_DEBUG)\n               continue;\n\n            RARCH_DBG(\"Subsystem ID: %d\\nSpecial game type: %s\\n  Ident: %s\\n  ID: %u\\n  Content:\\n\",\n                  i,\n                  info[i].desc,\n                  info[i].ident,\n                  info[i].id\n                  );\n            for (j = 0; j < info[i].num_roms; j++)\n            {\n               RARCH_DBG(\"    %s (%s)\\n\",\n                     info[i].roms[j].desc, info[i].roms[j].required ?\n                     \"required\" : \"optional\");\n            }\n         }\n\n         size = i;\n\n         if (log_level == RETRO_LOG_DEBUG)\n         {\n            RARCH_DBG(\"Subsystems: %d\\n\", i);\n            if (size > SUBSYSTEM_MAX_SUBSYSTEMS)\n               RARCH_WARN(\"Subsystems exceed subsystem max, clamping to %d\\n\", SUBSYSTEM_MAX_SUBSYSTEMS);\n         }\n\n         if (sys_info)\n         {\n            for (i = 0; i < size && i < SUBSYSTEM_MAX_SUBSYSTEMS; i++)\n            {\n               struct retro_subsystem_info *subsys_info         = &runloop_st->subsystem_data[i];\n               struct retro_subsystem_rom_info *subsys_rom_info = runloop_st->subsystem_data_roms[i];\n               /* Nasty, but have to do it like this since\n                * the pointers are const char *\n                * (if we don't free them, we get a memory leak) */\n               if (!string_is_empty(subsys_info->desc))\n                  free((char*)subsys_info->desc);\n               if (!string_is_empty(subsys_info->ident))\n                  free((char*)subsys_info->ident);\n               subsys_info->desc     = strdup(info[i].desc);\n               subsys_info->ident    = strdup(info[i].ident);\n               subsys_info->id       = info[i].id;\n               subsys_info->num_roms = info[i].num_roms;\n\n               if (log_level == RETRO_LOG_DEBUG)\n                  if (subsys_info->num_roms > SUBSYSTEM_MAX_SUBSYSTEM_ROMS)\n                     RARCH_WARN(\"Subsystems exceed subsystem max roms, clamping to %d\\n\", SUBSYSTEM_MAX_SUBSYSTEM_ROMS);\n\n               for (j = 0; j < subsys_info->num_roms && j < SUBSYSTEM_MAX_SUBSYSTEM_ROMS; j++)\n               {\n                  /* Nasty, but have to do it like this since\n                   * the pointers are const char *\n                   * (if we don't free them, we get a memory leak) */\n                  if (!string_is_empty(subsys_rom_info[j].desc))\n                     free((char*)\n                           subsys_rom_info[j].desc);\n                  if (!string_is_empty(\n                           subsys_rom_info[j].valid_extensions))\n                     free((char*)\n                           subsys_rom_info[j].valid_extensions);\n                  subsys_rom_info[j].desc             =\n                     strdup(info[i].roms[j].desc);\n                  subsys_rom_info[j].valid_extensions =\n                     strdup(info[i].roms[j].valid_extensions);\n                  subsys_rom_info[j].required         =\n                     info[i].roms[j].required;\n                  subsys_rom_info[j].block_extract    =\n                     info[i].roms[j].block_extract;\n                  subsys_rom_info[j].need_fullpath    =\n                     info[i].roms[j].need_fullpath;\n               }\n\n               subsys_info->roms = subsys_rom_info;\n            }\n\n            runloop_st->subsystem_current_count =\n               size <= SUBSYSTEM_MAX_SUBSYSTEMS\n               ? (unsigned)size\n               : SUBSYSTEM_MAX_SUBSYSTEMS;\n         }\n         break;\n      }\n      default:\n         return false;\n   }\n\n   return true;\n}\n\n\n#ifdef HAVE_DYNAMIC\n/**\n * libretro_get_environment_info:\n * @func                         : Function pointer for get_environment_info.\n * @load_no_content              : If true, core should be able to auto-start\n *                                 without any content loaded.\n *\n * Sets environment callback in order to get statically known\n * information from it.\n *\n * Fetched via environment callbacks instead of\n * retro_get_system_info(), as this info is part of extensions.\n *\n * Should only be called once right after core load to\n * avoid overwriting the \"real\" environ callback.\n *\n * For statically linked cores, pass retro_set_environment as argument.\n */\nvoid libretro_get_environment_info(\n      void (*func)(retro_environment_t),\n      bool *load_no_content)\n{\n   runloop_state_t *runloop_st      = &runloop_state;\n\n   runloop_st->load_no_content_hook = load_no_content;\n\n   /* load_no_content gets set in this callback. */\n   func(runloop_environ_cb_get_system_info);\n\n   /* It's possible that we just set get_system_info callback\n    * to the currently running core.\n    *\n    * Make sure we reset it to the actual environment callback.\n    * Ignore any environment callbacks here in case we're running\n    * on the non-current core. */\n   runloop_st->flags |=  RUNLOOP_FLAG_IGNORE_ENVIRONMENT_CB;\n   func(runloop_environment_cb);\n   runloop_st->flags &= ~RUNLOOP_FLAG_IGNORE_ENVIRONMENT_CB;\n}\n\nstatic dylib_t load_dynamic_core(const char *path, char *buf,\n      size_t size)\n{\n#if defined(ANDROID)\n   /* Can't resolve symlinks when dealing with cores\n    * installed via play feature delivery, because the\n    * source files have non-standard file names (which\n    * will not be recognised by regular core handling\n    * routines) */\n   bool resolve_symlinks = !play_feature_delivery_enabled();\n#else\n   bool resolve_symlinks = true;\n#endif\n\n   /* Can't lookup symbols in itself on UWP */\n#if !(defined(__WINRT__) || defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_FAMILY_PHONE_APP)\n   if (dylib_proc(NULL, \"retro_init\"))\n   {\n      /* Try to verify that -lretro was not linked in from other modules\n       * since loading it dynamically and with -l will fail hard. */\n      RARCH_ERR(\"Serious problem. RetroArch wants to load libretro cores\"\n            \" dynamically, but it is already linked.\\n\");\n      RARCH_ERR(\"This could happen if other modules RetroArch depends on \"\n            \"link against libretro directly.\\n\");\n      RARCH_ERR(\"Proceeding could cause a crash. Aborting ...\\n\");\n      retroarch_fail(1, \"load_dynamic_core()\");\n   }\n#endif\n\n   /* Need to use absolute path for this setting. It can be\n    * saved to content history, and a relative path would\n    * break in that scenario. */\n   path_resolve_realpath(buf, size, resolve_symlinks);\n   return dylib_load(path);\n}\n\nstatic dylib_t libretro_get_system_info_lib(const char *path,\n      struct retro_system_info *sysinfo, bool *load_no_content)\n{\n   dylib_t lib = dylib_load(path);\n   void (*proc)(struct retro_system_info*);\n\n   if (!lib)\n      return NULL;\n\n   proc = (void (*)(struct retro_system_info*))\n      dylib_proc(lib, \"retro_get_system_info\");\n\n   if (!proc)\n   {\n      dylib_close(lib);\n      return NULL;\n   }\n\n   proc(sysinfo);\n\n   if (load_no_content)\n   {\n      void (*set_environ)(retro_environment_t);\n      *load_no_content = false;\n      set_environ = (void (*)(retro_environment_t))\n         dylib_proc(lib, \"retro_set_environment\");\n\n      if (set_environ)\n         libretro_get_environment_info(set_environ, load_no_content);\n   }\n\n   return lib;\n}\n#endif\n\nstatic void runloop_update_runtime_log(\n      runloop_state_t *runloop_st,\n      const char *dir_runtime_log,\n      const char *dir_playlist,\n      bool log_per_core)\n{\n   /* Initialise runtime log file */\n   runtime_log_t *runtime_log   = runtime_log_init(\n         runloop_st->runtime_content_path,\n         runloop_st->runtime_core_path,\n         dir_runtime_log,\n         dir_playlist,\n         log_per_core);\n\n   if (!runtime_log)\n      return;\n\n   /* Add additional runtime */\n   runtime_log_add_runtime_usec(runtime_log,\n         runloop_st->core_runtime_usec);\n\n   /* Update 'last played' entry */\n   runtime_log_set_last_played_now(runtime_log);\n\n   /* Save runtime log file */\n   runtime_log_save(runtime_log);\n\n   /* Clean up */\n   free(runtime_log);\n}\n\n\nvoid runloop_runtime_log_deinit(\n      runloop_state_t *runloop_st,\n      bool content_runtime_log,\n      bool content_runtime_log_aggregate,\n      const char *dir_runtime_log,\n      const char *dir_playlist)\n{\n   if (verbosity_is_enabled())\n   {\n      char log[256]             = {0};\n      unsigned hours            = 0;\n      unsigned minutes          = 0;\n      unsigned seconds          = 0;\n\n      runtime_log_convert_usec2hms(\n            runloop_st->core_runtime_usec,\n            &hours, &minutes, &seconds);\n\n      /* TODO/FIXME - localize */\n      snprintf(log, sizeof(log),\n            \"[Core]: Content ran for a total of:\"\n            \" %02u hours, %02u minutes, %02u seconds.\",\n            hours, minutes, seconds);\n      RARCH_LOG(\"%s\\n\", log);\n   }\n\n   /* Only write to file if content has run for a non-zero length of time */\n   if (runloop_st->core_runtime_usec > 0)\n   {\n      /* Per core logging */\n      if (content_runtime_log)\n         runloop_update_runtime_log(runloop_st, dir_runtime_log, dir_playlist, true);\n\n      /* Aggregate logging */\n      if (content_runtime_log_aggregate)\n         runloop_update_runtime_log(runloop_st, dir_runtime_log, dir_playlist, false);\n   }\n\n   /* Reset runtime + content/core paths, to prevent any\n    * possibility of duplicate logging */\n   runloop_st->core_runtime_usec = 0;\n   memset(runloop_st->runtime_content_path, 0,\n         sizeof(runloop_st->runtime_content_path));\n   memset(runloop_st->runtime_core_path, 0,\n         sizeof(runloop_st->runtime_core_path));\n}\n\nstatic bool runloop_clear_all_thread_waits(\n      unsigned clear_threads, void *data)\n{\n   /* Does this need to treat the microphone driver the same way? */\n   if (clear_threads > 0)\n      audio_driver_start(false);\n   else\n      audio_driver_stop();\n\n   return true;\n}\n\nstatic bool dynamic_verify_hw_context(\n      const char *video_ident,\n      bool driver_switch_enable,\n      enum retro_hw_context_type type,\n      unsigned minor, unsigned major)\n{\n   if (!driver_switch_enable)\n   {\n      switch (type)\n      {\n         case RETRO_HW_CONTEXT_VULKAN:\n            if (!string_is_equal(video_ident, \"vulkan\"))\n               return false;\n            break;\n#if defined(HAVE_OPENGL_CORE)\n         case RETRO_HW_CONTEXT_OPENGL_CORE:\n            if (!string_is_equal(video_ident, \"glcore\"))\n               return false;\n            break;\n#else\n         case RETRO_HW_CONTEXT_OPENGL_CORE:\n#endif\n         case RETRO_HW_CONTEXT_OPENGLES2:\n         case RETRO_HW_CONTEXT_OPENGLES3:\n         case RETRO_HW_CONTEXT_OPENGLES_VERSION:\n         case RETRO_HW_CONTEXT_OPENGL:\n            if (     !string_is_equal(video_ident, \"gl\")\n                  && !string_is_equal(video_ident, \"glcore\"))\n               return false;\n            break;\n         case RETRO_HW_CONTEXT_D3D10:\n            if (!string_is_equal(video_ident, \"d3d10\"))\n               return false;\n            break;\n         case RETRO_HW_CONTEXT_D3D11:\n            if (!string_is_equal(video_ident, \"d3d11\"))\n               return false;\n            break;\n         case RETRO_HW_CONTEXT_D3D12:\n            if (!string_is_equal(video_ident, \"d3d12\"))\n               return false;\n            break;\n         default:\n            break;\n      }\n   }\n\n   return true;\n}\n\nstatic bool dynamic_request_hw_context(enum retro_hw_context_type type,\n      unsigned minor, unsigned major)\n{\n   switch (type)\n   {\n      case RETRO_HW_CONTEXT_NONE:\n         RARCH_LOG(\"Requesting no HW context.\\n\");\n         break;\n\n      case RETRO_HW_CONTEXT_VULKAN:\n#ifdef HAVE_VULKAN\n         RARCH_LOG(\"Requesting Vulkan context.\\n\");\n         break;\n#else\n         RARCH_ERR(\"Requesting Vulkan context, but RetroArch is not compiled against Vulkan. Cannot use HW context.\\n\");\n         return false;\n#endif\n\n#if defined(HAVE_OPENGLES)\n\n#if (defined(HAVE_OPENGLES2) || defined(HAVE_OPENGLES3))\n      case RETRO_HW_CONTEXT_OPENGLES2:\n      case RETRO_HW_CONTEXT_OPENGLES3:\n         RARCH_LOG(\"Requesting OpenGLES%u context.\\n\",\n               type == RETRO_HW_CONTEXT_OPENGLES2 ? 2 : 3);\n         break;\n\n#if defined(HAVE_OPENGLES3)\n      case RETRO_HW_CONTEXT_OPENGLES_VERSION:\n#ifndef HAVE_OPENGLES3_2\n         if (major == 3 && minor == 2)\n         {\n            RARCH_ERR(\"Requesting OpenGLES%u.%u context, but RetroArch is compiled against a lesser version. Cannot use HW context.\\n\",\n                  major, minor);\n            return false;\n         }\n#endif\n#if !defined(HAVE_OPENGLES3_2) && !defined(HAVE_OPENGLES3_1)\n         if (major == 3 && minor == 1)\n         {\n            RARCH_ERR(\"Requesting OpenGLES%u.%u context, but RetroArch is compiled against a lesser version. Cannot use HW context.\\n\",\n                  major, minor);\n            return false;\n         }\n#endif\n         RARCH_LOG(\"Requesting OpenGLES%u.%u context.\\n\",\n               major, minor);\n         break;\n#endif\n\n#endif\n      case RETRO_HW_CONTEXT_OPENGL:\n      case RETRO_HW_CONTEXT_OPENGL_CORE:\n         RARCH_ERR(\"Requesting OpenGL context, but RetroArch \"\n               \"is compiled against OpenGLES. Cannot use HW context.\\n\");\n         return false;\n\n#elif defined(HAVE_OPENGL) || defined(HAVE_OPENGL_CORE)\n      case RETRO_HW_CONTEXT_OPENGLES2:\n      case RETRO_HW_CONTEXT_OPENGLES3:\n         RARCH_ERR(\"Requesting OpenGLES%u context, but RetroArch \"\n               \"is compiled against OpenGL. Cannot use HW context.\\n\",\n               type == RETRO_HW_CONTEXT_OPENGLES2 ? 2 : 3);\n         return false;\n\n      case RETRO_HW_CONTEXT_OPENGLES_VERSION:\n         RARCH_ERR(\"Requesting OpenGLES%u.%u context, but RetroArch \"\n               \"is compiled against OpenGL. Cannot use HW context.\\n\",\n               major, minor);\n         return false;\n\n      case RETRO_HW_CONTEXT_OPENGL:\n         RARCH_LOG(\"Requesting OpenGL context.\\n\");\n         break;\n\n      case RETRO_HW_CONTEXT_OPENGL_CORE:\n         /* TODO/FIXME - we should do a check here to see if\n          * the requested core GL version is supported */\n         RARCH_LOG(\"Requesting core OpenGL context (%u.%u).\\n\",\n               major, minor);\n         break;\n#endif\n\n#if defined(HAVE_D3D11)\n      case RETRO_HW_CONTEXT_D3D11:\n         RARCH_LOG(\"Requesting D3D11 context.\\n\");\n         break;\n#endif\n#ifdef HAVE_D3D10\n      case RETRO_HW_CONTEXT_D3D10:\n         RARCH_LOG(\"Requesting D3D10 context.\\n\");\n         break;\n#endif\n#ifdef HAVE_D3D12\n      case RETRO_HW_CONTEXT_D3D12:\n         RARCH_LOG(\"Requesting D3D12 context.\\n\");\n         break;\n#endif\n#if defined(HAVE_D3D9)\n      case RETRO_HW_CONTEXT_D3D9:\n         RARCH_LOG(\"Requesting D3D9 context.\\n\");\n         break;\n#endif\n      default:\n         RARCH_LOG(\"Requesting unknown context.\\n\");\n         return false;\n   }\n\n   return true;\n}\n\nstatic void libretro_log_cb(\n      enum retro_log_level level,\n      const char *fmt, ...)\n{\n   va_list vp;\n   settings_t        *settings = config_get_ptr();\n   unsigned libretro_log_level = settings->uints.libretro_log_level;\n\n   if ((unsigned)level < libretro_log_level)\n      return;\n\n   if (!verbosity_is_enabled())\n      return;\n\n   va_start(vp, fmt);\n\n   switch (level)\n   {\n      case RETRO_LOG_DEBUG:\n         RARCH_LOG_V(\"[libretro DEBUG]\", fmt, vp);\n         break;\n\n      case RETRO_LOG_INFO:\n         RARCH_LOG_OUTPUT_V(\"[libretro INFO]\", fmt, vp);\n         break;\n\n      case RETRO_LOG_WARN:\n         RARCH_WARN_V(\"[libretro WARN]\", fmt, vp);\n         break;\n\n      case RETRO_LOG_ERROR:\n         RARCH_ERR_V(\"[libretro ERROR]\", fmt, vp);\n         break;\n\n      default:\n         break;\n   }\n\n   va_end(vp);\n}\n\nstatic size_t mmap_add_bits_down(size_t n)\n{\n   n |= n >>  1;\n   n |= n >>  2;\n   n |= n >>  4;\n   n |= n >>  8;\n   n |= n >> 16;\n\n   /* double shift to avoid warnings on 32bit (it's dead code,\n    * but compilers suck) */\n   if (sizeof(size_t) > 4)\n      n |= n >> 16 >> 16;\n\n   return n;\n}\n\nstatic size_t mmap_inflate(size_t addr, size_t mask)\n{\n    while (mask)\n   {\n      size_t tmp = (mask - 1) & ~mask;\n\n      /* to put in an 1 bit instead, OR in tmp+1 */\n      addr       = ((addr & ~tmp) << 1) | (addr & tmp);\n      mask       = mask & (mask - 1);\n   }\n\n   return addr;\n}\n\nstatic size_t mmap_reduce(size_t addr, size_t mask)\n{\n   while (mask)\n   {\n      size_t tmp = (mask - 1) & ~mask;\n      addr       = (addr & tmp) | ((addr >> 1) & ~tmp);\n      mask       = (mask & (mask - 1)) >> 1;\n   }\n\n   return addr;\n}\n\n\nstatic size_t mmap_highest_bit(size_t n)\n{\n   n = mmap_add_bits_down(n);\n   return n ^ (n >> 1);\n}\n\nstatic bool mmap_preprocess_descriptors(\n      rarch_memory_descriptor_t *first, unsigned count)\n{\n   size_t                      top_addr = 1;\n   rarch_memory_descriptor_t *desc      = NULL;\n   const rarch_memory_descriptor_t *end = first + count;\n   size_t             highest_reachable = 0;\n\n   for (desc = first; desc < end; desc++)\n   {\n      if (desc->core.select != 0)\n         top_addr |= desc->core.select;\n      else\n         top_addr |= desc->core.start + desc->core.len - 1;\n   }\n\n   top_addr = mmap_add_bits_down(top_addr);\n\n   for (desc = first; desc < end; desc++)\n   {\n      if (desc->core.select == 0)\n      {\n         if (desc->core.len == 0)\n            return false;\n\n         if ((desc->core.len & (desc->core.len - 1)) != 0)\n            return false;\n\n         desc->core.select = top_addr\n            & ~mmap_inflate(mmap_add_bits_down(desc->core.len - 1),\n               desc->core.disconnect);\n      }\n\n      if (desc->core.len == 0)\n         desc->core.len = mmap_add_bits_down(\n               mmap_reduce(top_addr & ~desc->core.select,\n                  desc->core.disconnect)) + 1;\n\n      if (desc->core.start & ~desc->core.select)\n         return false;\n\n      highest_reachable = mmap_inflate(desc->core.len - 1,\n            desc->core.disconnect);\n\n      /* Disconnect unselected bits that are too high to ever\n       * index into the core's buffer. Higher addresses will\n       * repeat / mirror the buffer as long as they match select */\n      while (mmap_highest_bit(top_addr\n               & ~desc->core.select\n               & ~desc->core.disconnect) >\n                mmap_highest_bit(highest_reachable))\n         desc->core.disconnect |= mmap_highest_bit(top_addr\n               & ~desc->core.select\n               & ~desc->core.disconnect);\n   }\n\n   return true;\n}\n\nstatic void runloop_deinit_core_options(\n      bool game_options_active,\n      const char *path_core_options,\n      core_option_manager_t *core_options)\n{\n   /* Check whether game-specific options file is being used */\n   if (!string_is_empty(path_core_options))\n   {\n      config_file_t *conf_tmp = NULL;\n\n      /* We only need to save configuration settings for\n       * the current core\n       * > If game-specific options file exists, have\n       *   to read it (to ensure file only gets written\n       *   if config values change)\n       * > Otherwise, create a new, empty config_file_t\n       *   object */\n      if (path_is_valid(path_core_options))\n         conf_tmp = config_file_new_from_path_to_string(path_core_options);\n\n      if (!conf_tmp)\n         conf_tmp = config_file_new_alloc();\n\n      if (conf_tmp)\n      {\n         core_option_manager_flush(\n               core_options,\n               conf_tmp);\n         RARCH_LOG(\"[Core]: Saved %s-specific core options to \\\"%s\\\".\\n\",\n               game_options_active ? \"game\" : \"folder\", path_core_options);\n         config_file_write(conf_tmp, path_core_options, true);\n         config_file_free(conf_tmp);\n         conf_tmp = NULL;\n      }\n      path_clear(RARCH_PATH_CORE_OPTIONS);\n   }\n   else\n   {\n      const char *path = core_options->conf_path;\n      core_option_manager_flush(\n            core_options,\n            core_options->conf);\n      RARCH_LOG(\"[Core]: Saved core options file to \\\"%s\\\".\\n\", path);\n      config_file_write(core_options->conf, path, true);\n   }\n\n   if (core_options)\n      core_option_manager_free(core_options);\n}\n\nstatic bool validate_per_core_options(char *s,\n      size_t len, bool mkdir,\n      const char *core_name, const char *game_name)\n{\n   char config_directory[DIR_MAX_LENGTH];\n   config_directory[0] = '\\0';\n\n   if (   (!s)\n       || (len < 1)\n       || string_is_empty(core_name)\n       || string_is_empty(game_name))\n      return false;\n\n   fill_pathname_application_special(config_directory,\n         sizeof(config_directory), APPLICATION_SPECIAL_DIRECTORY_CONFIG);\n\n   fill_pathname_join_special_ext(s,\n         config_directory, core_name, game_name,\n         \".opt\", len);\n\n   /* No need to make a directory if file already exists... */\n   if (mkdir && !path_is_valid(s))\n   {\n      char new_path[PATH_MAX_LENGTH];\n      fill_pathname_join_special(new_path,\n            config_directory, core_name, sizeof(new_path));\n      if (!path_is_directory(new_path))\n         path_mkdir(new_path);\n   }\n\n   return true;\n}\n\nstatic bool validate_game_options(\n      const char *core_name,\n      char *s, size_t len, bool mkdir)\n{\n   const char *game_name = path_basename_nocompression(path_get(RARCH_PATH_BASENAME));\n   return validate_per_core_options(s, len, mkdir,\n         core_name, game_name);\n}\n\n/**\n * game_specific_options:\n *\n * @return true if a game specific core\n * options path has been found, otherwise false.\n **/\nstatic bool validate_game_specific_options(char *s, size_t len)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n   if (!validate_game_options(\n            runloop_st->system.info.library_name,\n            s, len, false)\n       || !path_is_valid(s))\n      return false;\n   RARCH_LOG(\"[Core]: %s \\\"%s\\\".\\n\",\n         msg_hash_to_str(MSG_GAME_SPECIFIC_CORE_OPTIONS_FOUND_AT),\n         s);\n   return true;\n}\n\nstatic bool validate_folder_options(\n      char *s, size_t len, bool mkdir)\n{\n   const char *game_path       = path_get(RARCH_PATH_BASENAME);\n\n   if (!string_is_empty(game_path))\n   {\n      char folder_name[DIR_MAX_LENGTH];\n      runloop_state_t *runloop_st = &runloop_state;\n      const char *core_name       = runloop_st->system.info.library_name;\n      fill_pathname_parent_dir_name(folder_name,\n            game_path, sizeof(folder_name));\n      return validate_per_core_options(s, len, mkdir,\n            core_name, folder_name);\n   }\n   return false;\n}\n\n\n/**\n * validate_folder_specific_options:\n *\n * @return true if a folder specific core\n * options path has been found, otherwise false.\n **/\nstatic bool validate_folder_specific_options(char *s, size_t len)\n{\n   if (!validate_folder_options(s, len, false)\n       || !path_is_valid(s))\n      return false;\n   RARCH_LOG(\"[Core]: %s \\\"%s\\\".\\n\",\n         msg_hash_to_str(MSG_FOLDER_SPECIFIC_CORE_OPTIONS_FOUND_AT),\n         s);\n   return true;\n}\n\n/**\n * runloop_init_core_options_path:\n *\n * Fetches core options path for current core/content\n * - path: path from which options should be read\n *   from/saved to\n * - src_path: in the event that 'path' file does not\n *   yet exist, provides source path from which initial\n *   options should be extracted\n *\n *   NOTE: caller must ensure\n *   path and src_path are NULL-terminated\n *\n **/\nstatic void runloop_init_core_options_path(\n      settings_t *settings,\n      char *s, size_t len,\n      char *src_path, size_t src_len)\n{\n   runloop_state_t *runloop_st    = &runloop_state;\n   bool game_specific_options     = settings->bools.game_specific_options;\n\n   /* Check whether game-specific options exist */\n   if (   game_specific_options\n       && validate_game_specific_options(s, len))\n   {\n      /* Notify system that we have a valid core options\n       * override */\n      path_set(RARCH_PATH_CORE_OPTIONS, s);\n      runloop_st->flags &= ~RUNLOOP_FLAG_FOLDER_OPTIONS_ACTIVE;\n      runloop_st->flags |=  RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE;\n   }\n   /* Check whether folder-specific options exist */\n   else if (   game_specific_options\n            && validate_folder_specific_options(s, len))\n   {\n      /* Notify system that we have a valid core options\n       * override */\n      path_set(RARCH_PATH_CORE_OPTIONS, s);\n      runloop_st->flags &= ~RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE;\n      runloop_st->flags |=  RUNLOOP_FLAG_FOLDER_OPTIONS_ACTIVE;\n   }\n   else\n   {\n      char global_options_path[PATH_MAX_LENGTH];\n      char per_core_options_path[PATH_MAX_LENGTH];\n      bool per_core_options_exist   = false;\n      bool per_core_options         = !settings->bools.global_core_options;\n      const char *path_core_options = settings->paths.path_core_options;\n\n      per_core_options_path[0]      = '\\0';\n\n      if (per_core_options)\n      {\n         const char *core_name      = runloop_st->system.info.library_name;\n         /* Get core-specific options path\n          * > if validate_per_core_options() returns\n          *   false, then per-core options are disabled (due to\n          *   unknown system errors...) */\n         per_core_options = validate_per_core_options(\n               per_core_options_path, sizeof(per_core_options_path), true,\n               core_name, core_name);\n\n         /* If we can use per-core options, check whether an options\n          * file already exists */\n         if (per_core_options)\n            per_core_options_exist = path_is_valid(per_core_options_path);\n      }\n\n      /* If not using per-core options, or if a per-core options\n       * file does not yet exist, must fetch 'global' options path */\n      if (     !per_core_options\n            || !per_core_options_exist)\n      {\n         const char *options_path   = path_core_options;\n\n         if (!string_is_empty(options_path))\n            strlcpy(global_options_path,\n                  options_path, sizeof(global_options_path));\n         else if (!path_is_empty(RARCH_PATH_CONFIG))\n            fill_pathname_resolve_relative(\n                  global_options_path, path_get(RARCH_PATH_CONFIG),\n                  FILE_PATH_CORE_OPTIONS_CONFIG, sizeof(global_options_path));\n      }\n\n      /* Allocate correct path/src_path strings */\n      if (per_core_options)\n      {\n         strlcpy(s, per_core_options_path, len);\n         if (!per_core_options_exist)\n            strlcpy(src_path, global_options_path, src_len);\n      }\n      else\n         strlcpy(s, global_options_path, len);\n\n      /* Notify system that we *do not* have a valid core options\n       * options override */\n      runloop_st->flags &= ~(RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE\n                           | RUNLOOP_FLAG_FOLDER_OPTIONS_ACTIVE);\n   }\n}\n\nstatic core_option_manager_t *runloop_init_core_options(\n      settings_t *settings,\n      const struct retro_core_options_v2 *options_v2)\n{\n   bool categories_enabled = settings->bools.core_option_category_enable;\n   char options_path[PATH_MAX_LENGTH];\n   char src_options_path[PATH_MAX_LENGTH];\n\n   /* Ensure these are NULL-terminated */\n   options_path[0]     = '\\0';\n   src_options_path[0] = '\\0';\n\n   /* Get core options file path */\n   runloop_init_core_options_path(settings,\n         options_path, sizeof(options_path),\n         src_options_path, sizeof(src_options_path));\n\n   if (!string_is_empty(options_path))\n      return core_option_manager_new(options_path,\n            src_options_path, options_v2,\n            categories_enabled);\n   return NULL;\n}\n\nstatic core_option_manager_t *runloop_init_core_variables(\n      settings_t *settings, const struct retro_variable *vars)\n{\n   char options_path[PATH_MAX_LENGTH];\n   char src_options_path[PATH_MAX_LENGTH];\n\n   /* Ensure these are NULL-terminated */\n   options_path[0]     = '\\0';\n   src_options_path[0] = '\\0';\n\n   /* Get core options file path */\n   runloop_init_core_options_path(\n         settings,\n         options_path, sizeof(options_path),\n         src_options_path, sizeof(src_options_path));\n\n   if (!string_is_empty(options_path))\n      return core_option_manager_new_vars(options_path, src_options_path, vars);\n   return NULL;\n}\n\nstatic void runloop_core_msg_queue_push(\n      struct retro_system_av_info *av_info,\n      const struct retro_message_ext *msg)\n{\n   enum message_queue_category category;\n   /* Get duration in frames */\n   double fps               = (av_info && (av_info->timing.fps > 0)) ? av_info->timing.fps : 60.0;\n   unsigned duration_frames = (unsigned)((fps * (float)msg->duration / 1000.0f) + 0.5f);\n\n   /* Assign category */\n   switch (msg->level)\n   {\n      case RETRO_LOG_WARN:\n         category  = MESSAGE_QUEUE_CATEGORY_WARNING;\n         break;\n      case RETRO_LOG_ERROR:\n         category  = MESSAGE_QUEUE_CATEGORY_ERROR;\n         break;\n      case RETRO_LOG_INFO:\n      case RETRO_LOG_DEBUG:\n      default:\n         category  = MESSAGE_QUEUE_CATEGORY_INFO;\n         break;\n   }\n\n   /* Note: Do not flush the message queue here - a core\n    * may need to send multiple notifications simultaneously */\n   runloop_msg_queue_push(msg->msg, strlen(msg->msg),\n         msg->priority, duration_frames,\n         false, NULL, MESSAGE_QUEUE_ICON_DEFAULT,\n         category);\n}\n\nstatic void core_performance_counter_start(\n      struct retro_perf_counter *perf)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n   bool runloop_perfcnt_enable = runloop_st->perfcnt_enable;\n\n   if (runloop_perfcnt_enable)\n   {\n      perf->call_cnt++;\n      perf->start              = cpu_features_get_perf_counter();\n   }\n}\n\nstatic void core_performance_counter_stop(struct retro_perf_counter *perf)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n   bool runloop_perfcnt_enable = runloop_st->perfcnt_enable;\n\n   if (runloop_perfcnt_enable)\n      perf->total += cpu_features_get_perf_counter() - perf->start;\n}\n\n\nbool runloop_environment_cb(unsigned cmd, void *data)\n{\n   unsigned p;\n   runloop_state_t *runloop_st            = &runloop_state;\n   recording_state_t *recording_st        = recording_state_get_ptr();\n   settings_t         *settings           = config_get_ptr();\n   rarch_system_info_t *sys_info          = &runloop_st->system;\n   bool ignore_environment_cb             = (runloop_st->flags &\n      RUNLOOP_FLAG_IGNORE_ENVIRONMENT_CB) ? true : false;\n\n   if (ignore_environment_cb)\n      return false;\n\n   /* RETRO_ENVIRONMENT_GET_VARIABLE_UPDATE gets called\n    * by every core on every frame. Handle it first,\n    * to avoid the overhead of traversing the subsequent\n    * (enormous) case statement */\n   if (cmd == RETRO_ENVIRONMENT_GET_VARIABLE_UPDATE)\n   {\n      if (runloop_st->core_options)\n         *(bool*)data = runloop_st->core_options->updated;\n      else\n         *(bool*)data = false;\n\n      return true;\n   }\n\n   switch (cmd)\n   {\n      case RETRO_ENVIRONMENT_GET_OVERSCAN:\n         {\n            bool video_crop_overscan = settings->bools.video_crop_overscan;\n            *(bool*)data             = !video_crop_overscan;\n            RARCH_LOG(\"[Environ]: GET_OVERSCAN: %u\\n\",\n                  (unsigned)!video_crop_overscan);\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_GET_CAN_DUPE:\n         *(bool*)data = true;\n         RARCH_LOG(\"[Environ]: GET_CAN_DUPE: true\\n\");\n         break;\n\n      case RETRO_ENVIRONMENT_GET_VARIABLE:\n         {\n            struct retro_variable *var = (struct retro_variable*)data;\n            size_t opt_idx;\n\n            if (!var)\n               return true;\n\n            var->value = NULL;\n\n            if (!runloop_st->core_options)\n            {\n               RARCH_ERR(\"[Environ]: GET_VARIABLE: %s - %s.\\n\",\n                     var->key, \"Not implemented\");\n               return true;\n            }\n\n#ifdef HAVE_RUNAHEAD\n            if (runloop_st->core_options->updated)\n               runloop_st->flags |= RUNLOOP_FLAG_HAS_VARIABLE_UPDATE;\n#endif\n            runloop_st->core_options->updated = false;\n\n            if (core_option_manager_get_idx(runloop_st->core_options,\n                  var->key, &opt_idx))\n               var->value = core_option_manager_get_val(\n                     runloop_st->core_options, opt_idx);\n\n            if (!var->value)\n            {\n               RARCH_ERR(\"[Environ]: GET_VARIABLE: %s - %s.\\n\",\n                     var->key, \"Invalid value\");\n               return true;\n            }\n\n            RARCH_DBG(\"[Environ]: GET_VARIABLE: %s = \\\"%s\\\"\\n\",\n                  var->key, var->value);\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_SET_VARIABLE:\n         {\n            const struct retro_variable *var = (const struct retro_variable*)data;\n            size_t opt_idx;\n            size_t val_idx;\n\n            /* If core passes NULL to the callback, return\n             * value indicates whether callback is supported */\n            if (!var)\n               return true;\n\n            if (     string_is_empty(var->key)\n                  || string_is_empty(var->value))\n               return false;\n\n            if (!runloop_st->core_options)\n            {\n               RARCH_ERR(\"[Environ]: SET_VARIABLE: %s - %s.\\n\",\n                     var->key, \"Not implemented\");\n               return false;\n            }\n\n            /* Check whether key is valid */\n            if (!core_option_manager_get_idx(runloop_st->core_options,\n                  var->key, &opt_idx))\n            {\n               RARCH_ERR(\"[Environ]: SET_VARIABLE: %s - %s.\\n\",\n                     var->key, \"Invalid key\");\n               return false;\n            }\n\n            /* Check whether value is valid */\n            if (!core_option_manager_get_val_idx(runloop_st->core_options,\n                  opt_idx, var->value, &val_idx))\n            {\n               RARCH_ERR(\"[Environ]: SET_VARIABLE: %s - %s: %s\\n\",\n                     var->key, \"Invalid value\", var->value);\n               return false;\n            }\n\n            /* Update option value if core-requested value\n             * is not currently set */\n            if (val_idx != runloop_st->core_options->opts[opt_idx].index)\n               core_option_manager_set_val(runloop_st->core_options,\n                     opt_idx, val_idx, true);\n\n            RARCH_DBG(\"[Environ]: SET_VARIABLE: %s = \\\"%s\\\"\\n\",\n                  var->key, var->value);\n         }\n         break;\n\n      /* SET_VARIABLES: Legacy path */\n      case RETRO_ENVIRONMENT_SET_VARIABLES:\n         RARCH_LOG(\"[Environ]: SET_VARIABLES.\\n\");\n\n         {\n            core_option_manager_t *new_vars = NULL;\n\n            if (runloop_st->core_options)\n            {\n               runloop_deinit_core_options(\n                     (runloop_st->flags & RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE) ? true : false,\n                     path_get(RARCH_PATH_CORE_OPTIONS),\n                     runloop_st->core_options);\n               runloop_st->flags           &=\n                  ~(RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE\n                  | RUNLOOP_FLAG_FOLDER_OPTIONS_ACTIVE);\n               runloop_st->core_options     = NULL;\n            }\n\n            if ((new_vars = runloop_init_core_variables(\n                  settings,\n                  (const struct retro_variable *)data)))\n               runloop_st->core_options     = new_vars;\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_SET_CORE_OPTIONS:\n         RARCH_LOG(\"[Environ]: SET_CORE_OPTIONS.\\n\");\n\n         {\n            /* Parse core_option_definition array to\n             * create retro_core_options_v2 struct */\n            struct retro_core_options_v2 *options_v2 =\n                  core_option_manager_convert_v1(\n                        (const struct retro_core_option_definition*)data);\n\n            if (runloop_st->core_options)\n            {\n               runloop_deinit_core_options(\n                     (runloop_st->flags & RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE) ? true : false,\n                     path_get(RARCH_PATH_CORE_OPTIONS),\n                     runloop_st->core_options);\n               runloop_st->flags                &=\n                  ~(RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE\n                  | RUNLOOP_FLAG_FOLDER_OPTIONS_ACTIVE);\n               runloop_st->core_options          = NULL;\n            }\n\n            if (options_v2)\n            {\n               /* Initialise core options */\n               core_option_manager_t *new_vars = runloop_init_core_options(settings, options_v2);\n\n               if (new_vars)\n                  runloop_st->core_options   = new_vars;\n\n               /* Clean up */\n               core_option_manager_free_converted(options_v2);\n            }\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_SET_CORE_OPTIONS_INTL:\n         RARCH_LOG(\"[Environ]: RETRO_ENVIRONMENT_SET_CORE_OPTIONS_INTL.\\n\");\n\n         {\n            /* Parse core_options_intl to create\n             * retro_core_options_v2 struct */\n            struct retro_core_options_v2 *options_v2 =\n                  core_option_manager_convert_v1_intl(\n                        (const struct retro_core_options_intl*)data);\n\n            if (runloop_st->core_options)\n            {\n               runloop_deinit_core_options(\n                     (runloop_st->flags & RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE) ? true : false,\n                     path_get(RARCH_PATH_CORE_OPTIONS),\n                     runloop_st->core_options);\n               runloop_st->flags                &=\n                  ~(RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE\n                  | RUNLOOP_FLAG_FOLDER_OPTIONS_ACTIVE);\n               runloop_st->core_options          = NULL;\n            }\n\n            if (options_v2)\n            {\n               /* Initialise core options */\n               core_option_manager_t *new_vars = runloop_init_core_options(settings, options_v2);\n\n               if (new_vars)\n                  runloop_st->core_options = new_vars;\n\n               /* Clean up */\n               core_option_manager_free_converted(options_v2);\n            }\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2:\n         RARCH_LOG(\"[Environ]: RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2.\\n\");\n\n         {\n            core_option_manager_t *new_vars                = NULL;\n            const struct retro_core_options_v2 *options_v2 =\n                  (const struct retro_core_options_v2 *)data;\n            bool categories_enabled                        =\n                  settings->bools.core_option_category_enable;\n\n            if (runloop_st->core_options)\n            {\n               runloop_deinit_core_options(\n                     (runloop_st->flags & RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE) ? true : false,\n                     path_get(RARCH_PATH_CORE_OPTIONS),\n                     runloop_st->core_options);\n               runloop_st->flags                &=\n                  ~(RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE\n                  | RUNLOOP_FLAG_FOLDER_OPTIONS_ACTIVE);\n               runloop_st->core_options          = NULL;\n            }\n\n            if (options_v2)\n            {\n               new_vars = runloop_init_core_options(settings, options_v2);\n\n               if (new_vars)\n                  runloop_st->core_options = new_vars;\n            }\n\n            /* Return value does not indicate success.\n             * Callback returns 'true' if core option\n             * categories are supported/enabled,\n             * otherwise 'false'. */\n            return categories_enabled;\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2_INTL:\n         RARCH_LOG(\"[Environ]: RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2_INTL.\\n\");\n\n         {\n            /* Parse retro_core_options_v2_intl to create\n             * retro_core_options_v2 struct */\n            core_option_manager_t *new_vars          = NULL;\n            struct retro_core_options_v2 *options_v2 =\n                  core_option_manager_convert_v2_intl(\n                        (const struct retro_core_options_v2_intl*)data);\n            bool categories_enabled                  =\n                  settings->bools.core_option_category_enable;\n\n            if (runloop_st->core_options)\n            {\n               runloop_deinit_core_options(\n                     (runloop_st->flags & RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE) ? true : false,\n                     path_get(RARCH_PATH_CORE_OPTIONS),\n                     runloop_st->core_options);\n               runloop_st->flags                &=\n                  ~(RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE\n                  | RUNLOOP_FLAG_FOLDER_OPTIONS_ACTIVE);\n               runloop_st->core_options          = NULL;\n            }\n\n            if (options_v2)\n            {\n               /* Initialise core options */\n               new_vars = runloop_init_core_options(settings, options_v2);\n\n               if (new_vars)\n                  runloop_st->core_options = new_vars;\n\n               /* Clean up */\n               core_option_manager_free_converted(options_v2);\n            }\n\n            /* Return value does not indicate success.\n             * Callback returns 'true' if core option\n             * categories are supported/enabled,\n             * otherwise 'false'. */\n            return categories_enabled;\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY:\n         RARCH_DBG(\"[Environ]: RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY.\\n\");\n\n         {\n            const struct retro_core_option_display *core_options_display =\n                  (const struct retro_core_option_display *)data;\n\n            if (runloop_st->core_options && core_options_display)\n               core_option_manager_set_visible(\n                     runloop_st->core_options,\n                     core_options_display->key,\n                     core_options_display->visible);\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_SET_CORE_OPTIONS_UPDATE_DISPLAY_CALLBACK:\n         RARCH_DBG(\"[Environ]: RETRO_ENVIRONMENT_SET_CORE_OPTIONS_UPDATE_DISPLAY_CALLBACK.\\n\");\n\n         {\n            const struct retro_core_options_update_display_callback\n                  *update_display_callback =\n                        (const struct retro_core_options_update_display_callback*)data;\n\n            if (   update_display_callback\n                && update_display_callback->callback)\n               runloop_st->core_options_callback.update_display =\n                     update_display_callback->callback;\n            else\n               runloop_st->core_options_callback.update_display = NULL;\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_GET_MESSAGE_INTERFACE_VERSION:\n         RARCH_LOG(\"[Environ]: GET_MESSAGE_INTERFACE_VERSION.\\n\");\n         /* Current API version is 1 */\n         *(unsigned *)data = 1;\n         break;\n\n      case RETRO_ENVIRONMENT_SET_MESSAGE:\n      {\n         const struct retro_message *msg = (const struct retro_message*)data;\n#if defined(HAVE_GFX_WIDGETS)\n         dispgfx_widget_t *p_dispwidget  = dispwidget_get_ptr();\n\n         if (p_dispwidget->active)\n            gfx_widget_set_libretro_message(\n                  msg->msg,\n                  roundf((float)msg->frames / 60.0f * 1000.0f));\n         else\n#endif\n            runloop_msg_queue_push(msg->msg, strlen(msg->msg), 3, msg->frames,\n                  true, NULL, MESSAGE_QUEUE_ICON_DEFAULT,\n                  MESSAGE_QUEUE_CATEGORY_INFO);\n         RARCH_LOG(\"[Environ]: SET_MESSAGE: %s\\n\", msg->msg);\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_MESSAGE_EXT:\n      {\n         const struct retro_message_ext *msg =\n            (const struct retro_message_ext*)data;\n\n         /* Log message, if required */\n         if (msg->target != RETRO_MESSAGE_TARGET_OSD)\n         {\n            switch (msg->level)\n            {\n               case RETRO_LOG_DEBUG:\n                  RARCH_DBG(\"[Environ]: SET_MESSAGE_EXT: %s\\n\", msg->msg);\n                  break;\n               case RETRO_LOG_WARN:\n                  RARCH_WARN(\"[Environ]: SET_MESSAGE_EXT: %s\\n\", msg->msg);\n                  break;\n               case RETRO_LOG_ERROR:\n                  RARCH_ERR(\"[Environ]: SET_MESSAGE_EXT: %s\\n\", msg->msg);\n                  break;\n               case RETRO_LOG_INFO:\n               default:\n                  RARCH_LOG(\"[Environ]: SET_MESSAGE_EXT: %s\\n\", msg->msg);\n                  break;\n            }\n         }\n\n         /* Display message via OSD, if required */\n         if (msg->target != RETRO_MESSAGE_TARGET_LOG)\n         {\n            switch (msg->type)\n            {\n               /* Handle 'status' messages */\n               case RETRO_MESSAGE_TYPE_STATUS:\n\n                  /* Note: We need to lock a mutex here. Strictly\n                   * speaking, 'core_status_msg' is not part\n                   * of the message queue, but:\n                   * - It may be implemented as a queue in the future\n                   * - It seems unnecessary to create a new slock_t\n                   *   object for this type of message when\n                   *   _runloop_msg_queue_lock is already available\n                   * We therefore just call runloop_msg_queue_lock()/\n                   * runloop_msg_queue_unlock() in this case */\n                  RUNLOOP_MSG_QUEUE_LOCK(runloop_st);\n\n                  /* If a message is already set, only overwrite\n                   * it if the new message has the same or higher\n                   * priority */\n                  if (   !runloop_st->core_status_msg.set\n                      || (runloop_st->core_status_msg.priority <= msg->priority))\n                  {\n                     if (!string_is_empty(msg->msg))\n                     {\n                        strlcpy(runloop_st->core_status_msg.str, msg->msg,\n                              sizeof(runloop_st->core_status_msg.str));\n\n                        runloop_st->core_status_msg.duration = (float)msg->duration;\n                        runloop_st->core_status_msg.set      = true;\n                     }\n                     else\n                     {\n                        /* Ensure sane behaviour if core sends an\n                         * empty message */\n                        runloop_st->core_status_msg.str[0] = '\\0';\n                        runloop_st->core_status_msg.priority = 0;\n                        runloop_st->core_status_msg.duration = 0.0f;\n                        runloop_st->core_status_msg.set      = false;\n                     }\n                  }\n\n                  RUNLOOP_MSG_QUEUE_UNLOCK(runloop_st);\n                  break;\n\n#if defined(HAVE_GFX_WIDGETS)\n               /* Handle 'alternate' non-queued notifications */\n               case RETRO_MESSAGE_TYPE_NOTIFICATION_ALT:\n                  {\n                     video_driver_state_t *video_st =\n                        video_state_get_ptr();\n                     dispgfx_widget_t *p_dispwidget = dispwidget_get_ptr();\n\n                     if (p_dispwidget->active)\n                        gfx_widget_set_libretro_message(\n                              msg->msg, msg->duration);\n                     else\n                        runloop_core_msg_queue_push(\n                              &video_st->av_info, msg);\n\n                  }\n                  break;\n\n               /* Handle 'progress' messages */\n               case RETRO_MESSAGE_TYPE_PROGRESS:\n                  {\n                     video_driver_state_t *video_st =\n                        video_state_get_ptr();\n                     dispgfx_widget_t *p_dispwidget = dispwidget_get_ptr();\n\n                     if (p_dispwidget->active)\n                        gfx_widget_set_progress_message(\n                              msg->msg, msg->duration,\n                              msg->priority, msg->progress);\n                     else\n                        runloop_core_msg_queue_push(\n                              &video_st->av_info, msg);\n\n                  }\n                  break;\n#endif\n               /* Handle standard (queued) notifications */\n               case RETRO_MESSAGE_TYPE_NOTIFICATION:\n               default:\n                  {\n                     video_driver_state_t *video_st =\n                        video_state_get_ptr();\n                     runloop_core_msg_queue_push(\n                           &video_st->av_info, msg);\n                  }\n                  break;\n            }\n         }\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_ROTATION:\n      {\n         unsigned rotation       = *(const unsigned*)data;\n         unsigned rotation_v[4]  = {0, 90, 180, 270};\n         bool video_allow_rotate = settings->bools.video_allow_rotate;\n\n         RARCH_DBG(\"[Environ]: SET_ROTATION: \\\"%u\\\" (%u deg).\\n\", rotation, rotation_v[rotation % 4]);\n\n         if (sys_info)\n            sys_info->core_requested_rotation = rotation;\n\n         if (!video_allow_rotate)\n            return false;\n\n         if (sys_info)\n            sys_info->rotation = rotation;\n\n         if (!video_driver_set_rotation(rotation))\n            return false;\n\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SHUTDOWN:\n      {\n#ifdef HAVE_MENU\n         struct menu_state *menu_st = menu_state_get_ptr();\n#endif\n         /* This case occurs when a core (internally)\n          * requests a shutdown event */\n         RARCH_LOG(\"[Environ]: SHUTDOWN.\\n\");\n\n         runloop_st->flags |= RUNLOOP_FLAG_CORE_SHUTDOWN_INITIATED\n                            | RUNLOOP_FLAG_SHUTDOWN_INITIATED;\n#ifdef HAVE_MENU\n         /* Ensure that menu stack is flushed appropriately\n          * after the core has stopped running */\n         if (menu_st)\n         {\n            const char *content_path = path_get(RARCH_PATH_CONTENT);\n\n            menu_st->flags |= MENU_ST_FLAG_PENDING_ENV_SHUTDOWN_FLUSH;\n\n            if (!string_is_empty(content_path))\n               strlcpy(menu_st->pending_env_shutdown_content_path,\n                     content_path,\n                     sizeof(menu_st->pending_env_shutdown_content_path));\n            else\n               menu_st->pending_env_shutdown_content_path[0] = '\\0';\n         }\n#endif\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_PERFORMANCE_LEVEL:\n         if (sys_info)\n         {\n            sys_info->performance_level = *(const unsigned*)data;\n            RARCH_LOG(\"[Environ]: PERFORMANCE_LEVEL: %u.\\n\",\n                  sys_info->performance_level);\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY:\n         {\n            const char *dir_system          = settings->paths.directory_system;\n            bool systemfiles_in_content_dir = settings->bools.systemfiles_in_content_dir;\n\n            if (     string_is_empty(dir_system)\n                  || systemfiles_in_content_dir)\n            {\n               const char *fullpath = path_get(RARCH_PATH_CONTENT);\n\n               if (!string_is_empty(fullpath))\n               {\n                  size_t _len;\n                  char tmp_path[PATH_MAX_LENGTH];\n\n                  if (string_is_empty(dir_system))\n                     RARCH_WARN(\"[Environ]: SYSTEM DIR is empty, assume CONTENT DIR %s\\n\",\n                                fullpath);\n\n                  _len = fill_pathname_basedir(tmp_path, fullpath, sizeof(tmp_path));\n                  /* Removes trailing slash (unless root dir) */\n                  if (string_count_occurrences_single_character(tmp_path, PATH_DEFAULT_SLASH_C()) > 1\n                        && tmp_path[_len - 1] == PATH_DEFAULT_SLASH_C())\n                           tmp_path[_len - 1] = '\\0';\n\n                  dir_set(RARCH_DIR_SYSTEM, tmp_path);\n                  *(const char**)data = dir_get_ptr(RARCH_DIR_SYSTEM);\n               }\n               else /* If content path is empty, fall back to global system dir path */\n                  *(const char**)data = dir_system;\n\n               RARCH_LOG(\"[Environ]: SYSTEM_DIRECTORY: \\\"%s\\\".\\n\",\n                     *(const char**)data);\n            }\n            else\n            {\n               *(const char**)data = dir_system;\n               RARCH_LOG(\"[Environ]: SYSTEM_DIRECTORY: \\\"%s\\\".\\n\",\n                         dir_system);\n            }\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_GET_SAVE_DIRECTORY:\n         *(const char**)data = runloop_st->savefile_dir;\n         RARCH_LOG(\"[Environ]: SAVE_DIRECTORY: \\\"%s\\\".\\n\",\n               runloop_st->savefile_dir);\n         break;\n\n      case RETRO_ENVIRONMENT_GET_USERNAME:\n         *(const char**)data = *settings->paths.username ?\n            settings->paths.username : NULL;\n         RARCH_LOG(\"[Environ]: GET_USERNAME: \\\"%s\\\".\\n\",\n               settings->paths.username);\n         break;\n\n      case RETRO_ENVIRONMENT_GET_LANGUAGE:\n#ifdef HAVE_LANGEXTRA\n         {\n            unsigned user_lang = *msg_hash_get_uint(MSG_HASH_USER_LANGUAGE);\n            *(unsigned *)data  = user_lang;\n            RARCH_LOG(\"[Environ]: GET_LANGUAGE: \\\"%u\\\".\\n\", user_lang);\n         }\n#endif\n         break;\n\n      case RETRO_ENVIRONMENT_SET_PIXEL_FORMAT:\n      {\n         video_driver_state_t *video_st  =\n            video_state_get_ptr();\n         enum retro_pixel_format pix_fmt =\n            *(const enum retro_pixel_format*)data;\n\n         switch (pix_fmt)\n         {\n            case RETRO_PIXEL_FORMAT_0RGB1555:\n               RARCH_LOG(\"[Environ]: SET_PIXEL_FORMAT: 0RGB1555.\\n\");\n               break;\n\n            case RETRO_PIXEL_FORMAT_RGB565:\n               RARCH_LOG(\"[Environ]: SET_PIXEL_FORMAT: RGB565.\\n\");\n               break;\n            case RETRO_PIXEL_FORMAT_XRGB8888:\n               RARCH_LOG(\"[Environ]: SET_PIXEL_FORMAT: XRGB8888.\\n\");\n               break;\n            default:\n               return false;\n         }\n\n         video_st->pix_fmt = pix_fmt;\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_INPUT_DESCRIPTORS:\n      {\n         if (sys_info)\n         {\n            unsigned retro_id;\n            const struct retro_input_descriptor *desc = NULL;\n            memset((void*)&sys_info->input_desc_btn, 0,\n                  sizeof(sys_info->input_desc_btn));\n\n            desc = (const struct retro_input_descriptor*)data;\n\n            for (; desc->description; desc++)\n            {\n               unsigned retro_port = desc->port;\n\n               retro_id            = desc->id;\n\n               if (desc->port >= MAX_USERS)\n                  continue;\n\n               if (desc->id >= RARCH_FIRST_CUSTOM_BIND)\n                  continue;\n\n               switch (desc->device)\n               {\n                  case RETRO_DEVICE_JOYPAD:\n                     sys_info->input_desc_btn[retro_port]\n                        [retro_id] = desc->description;\n                     break;\n                  case RETRO_DEVICE_ANALOG:\n                     switch (retro_id)\n                     {\n                        case RETRO_DEVICE_ID_ANALOG_X:\n                           switch (desc->index)\n                           {\n                              case RETRO_DEVICE_INDEX_ANALOG_LEFT:\n                                 sys_info->input_desc_btn[retro_port]\n                                    [RARCH_ANALOG_LEFT_X_PLUS]  = desc->description;\n                                 sys_info->input_desc_btn[retro_port]\n                                    [RARCH_ANALOG_LEFT_X_MINUS] = desc->description;\n                                 break;\n                              case RETRO_DEVICE_INDEX_ANALOG_RIGHT:\n                                 sys_info->input_desc_btn[retro_port]\n                                    [RARCH_ANALOG_RIGHT_X_PLUS] = desc->description;\n                                 sys_info->input_desc_btn[retro_port]\n                                    [RARCH_ANALOG_RIGHT_X_MINUS] = desc->description;\n                                 break;\n                           }\n                           break;\n                        case RETRO_DEVICE_ID_ANALOG_Y:\n                           switch (desc->index)\n                           {\n                              case RETRO_DEVICE_INDEX_ANALOG_LEFT:\n                                 sys_info->input_desc_btn[retro_port]\n                                    [RARCH_ANALOG_LEFT_Y_PLUS] = desc->description;\n                                 sys_info->input_desc_btn[retro_port]\n                                    [RARCH_ANALOG_LEFT_Y_MINUS] = desc->description;\n                                 break;\n                              case RETRO_DEVICE_INDEX_ANALOG_RIGHT:\n                                 sys_info->input_desc_btn[retro_port]\n                                    [RARCH_ANALOG_RIGHT_Y_PLUS] = desc->description;\n                                 sys_info->input_desc_btn[retro_port]\n                                    [RARCH_ANALOG_RIGHT_Y_MINUS] = desc->description;\n                                 break;\n                           }\n                           break;\n                        case RETRO_DEVICE_ID_JOYPAD_R2:\n                           switch (desc->index)\n                           {\n                              case RETRO_DEVICE_INDEX_ANALOG_BUTTON:\n                                 sys_info->input_desc_btn[retro_port]\n                                    [retro_id] = desc->description;\n                                 break;\n                           }\n                           break;\n                        case RETRO_DEVICE_ID_JOYPAD_L2:\n                           switch (desc->index)\n                           {\n                              case RETRO_DEVICE_INDEX_ANALOG_BUTTON:\n                                 sys_info->input_desc_btn[retro_port]\n                                    [retro_id] = desc->description;\n                                 break;\n                           }\n                           break;\n                     }\n                     break;\n               }\n            }\n\n            RARCH_LOG(\"[Environ]: SET_INPUT_DESCRIPTORS:\\n\");\n\n            {\n               unsigned log_level      = settings->uints.libretro_log_level;\n\n               if (log_level == RETRO_LOG_DEBUG)\n               {\n                  unsigned input_driver_max_users = settings->uints.input_max_users;\n\n                  for (p = 0; p < input_driver_max_users; p++)\n                  {\n                     unsigned mapped_port = settings->uints.input_remap_ports[p];\n\n                     RARCH_DBG(\"   %s %u:\\n\", msg_hash_to_str(MENU_ENUM_LABEL_VALUE_PORT), p + 1);\n\n                     for (retro_id = 0; retro_id < RARCH_FIRST_CUSTOM_BIND; retro_id++)\n                     {\n                        unsigned bind_index     = input_config_bind_order[retro_id];\n                        const char *description = sys_info->input_desc_btn[mapped_port][bind_index];\n\n                        if (!description)\n                           continue;\n\n                        RARCH_DBG(\"      \\\"%s\\\" => \\\"%s\\\"\\n\",\n                              msg_hash_to_str(MENU_ENUM_LABEL_VALUE_INPUT_JOYPAD_B + bind_index),\n                              description);\n                     }\n                  }\n               }\n            }\n\n            runloop_st->current_core.flags |=\n               RETRO_CORE_FLAG_HAS_SET_INPUT_DESCRIPTORS;\n         }\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_KEYBOARD_CALLBACK:\n      {\n         input_driver_state_t\n            *input_st                               = input_state_get_ptr();\n         const struct retro_keyboard_callback *info =\n            (const struct retro_keyboard_callback*)data;\n         retro_keyboard_event_t *frontend_key_event = &runloop_st->frontend_key_event;\n         retro_keyboard_event_t *key_event          = &runloop_st->key_event;\n\n         RARCH_LOG(\"[Environ]: SET_KEYBOARD_CALLBACK.\\n\");\n\n         if (key_event)\n            *key_event                  = info->callback;\n\n         if (frontend_key_event && key_event)\n            *frontend_key_event         = *key_event;\n\n         /* If a core calls RETRO_ENVIRONMENT_SET_KEYBOARD_CALLBACK,\n          * then it is assumed that Game Focus mode is desired */\n         input_st->game_focus_state.core_requested = true;\n\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_DISK_CONTROL_INTERFACE_VERSION:\n         RARCH_LOG(\"[Environ]: GET_DISK_CONTROL_INTERFACE_VERSION.\\n\");\n         /* Current API version is 1 */\n         *(unsigned *)data = 1;\n         break;\n\n      case RETRO_ENVIRONMENT_SET_DISK_CONTROL_INTERFACE:\n         {\n            const struct retro_disk_control_callback *control_cb =\n                  (const struct retro_disk_control_callback*)data;\n\n            if (sys_info)\n            {\n               RARCH_LOG(\"[Environ]: SET_DISK_CONTROL_INTERFACE.\\n\");\n               disk_control_set_callback(&sys_info->disk_control, control_cb);\n            }\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_SET_DISK_CONTROL_EXT_INTERFACE:\n         {\n            const struct retro_disk_control_ext_callback *control_cb =\n                  (const struct retro_disk_control_ext_callback*)data;\n\n            if (sys_info)\n            {\n               RARCH_LOG(\"[Environ]: SET_DISK_CONTROL_EXT_INTERFACE.\\n\");\n               disk_control_set_ext_callback(&sys_info->disk_control, control_cb);\n            }\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_GET_PREFERRED_HW_RENDER:\n      {\n         unsigned *cb = (unsigned*)data;\n         settings_t *settings          = config_get_ptr();\n         const char *video_driver_name = settings->arrays.video_driver;\n         bool driver_switch_enable     = settings->bools.driver_switch_enable;\n\n         RARCH_LOG(\"[Environ]: GET_PREFERRED_HW_RENDER, video driver name: %s.\\n\", video_driver_name);\n\n         if (string_is_equal(video_driver_name, \"glcore\"))\n         {\n             *cb = RETRO_HW_CONTEXT_OPENGL_CORE;\n             RARCH_LOG(\"[Environ]: GET_PREFERRED_HW_RENDER - Context callback set to RETRO_HW_CONTEXT_OPENGL_CORE.\\n\");\n         }\n         else if (string_is_equal(video_driver_name, \"gl\"))\n         {\n             *cb = RETRO_HW_CONTEXT_OPENGL;\n             RARCH_LOG(\"[Environ]: GET_PREFERRED_HW_RENDER - Context callback set to RETRO_HW_CONTEXT_OPENGL.\\n\");\n         }\n         else if (string_is_equal(video_driver_name, \"vulkan\"))\n         {\n             *cb = RETRO_HW_CONTEXT_VULKAN;\n             RARCH_LOG(\"[Environ]: GET_PREFERRED_HW_RENDER - Context callback set to RETRO_HW_CONTEXT_VULKAN.\\n\");\n         }\n         else if (string_is_equal(video_driver_name, \"d3d11\"))\n         {\n             *cb = RETRO_HW_CONTEXT_D3D11;\n             RARCH_LOG(\"[Environ]: GET_PREFERRED_HW_RENDER - Context callback set to RETRO_HW_CONTEXT_D3D11.\\n\");\n         }\n         else if (string_is_equal(video_driver_name, \"d3d12\"))\n         {\n             *cb = RETRO_HW_CONTEXT_D3D12;\n             RARCH_LOG(\"[Environ]: GET_PREFERRED_HW_RENDER - Context callback set to RETRO_HW_CONTEXT_D3D12.\\n\");\n         }\n         else\n         {\n             *cb = RETRO_HW_CONTEXT_NONE;\n             RARCH_LOG(\"[Environ]: GET_PREFERRED_HW_RENDER - Context callback set to RETRO_HW_CONTEXT_NONE.\\n\");\n         }\n\n         if (!driver_switch_enable)\n         {\n            RARCH_LOG(\"[Environ]: Driver switching disabled, GET_PREFERRED_HW_RENDER will be ignored.\\n\");\n            return false;\n         }\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_HW_RENDER:\n      case RETRO_ENVIRONMENT_SET_HW_RENDER | RETRO_ENVIRONMENT_EXPERIMENTAL:\n      {\n         settings_t *settings                 = config_get_ptr();\n         struct retro_hw_render_callback *cb  =\n            (struct retro_hw_render_callback*)data;\n         video_driver_state_t *video_st       =\n            video_state_get_ptr();\n         struct retro_hw_render_callback *hwr =\n            VIDEO_DRIVER_GET_HW_CONTEXT_INTERNAL(video_st);\n\n         if (!cb)\n         {\n            RARCH_ERR(\"[Environ]: SET_HW_RENDER - No valid callback passed, returning...\\n\");\n            return false;\n         }\n\n         RARCH_LOG(\"[Environ]: SET_HW_RENDER, context type: %s.\\n\", hw_render_context_name(cb->context_type, cb->version_major, cb->version_minor));\n\n         if (!dynamic_request_hw_context(\n                  cb->context_type, cb->version_minor, cb->version_major))\n         {\n            RARCH_ERR(\"[Environ]: SET_HW_RENDER - Dynamic request HW context failed.\\n\");\n            return false;\n         }\n\n         if (!dynamic_verify_hw_context(\n                  settings->arrays.video_driver,\n                  settings->bools.driver_switch_enable,\n                  cb->context_type, cb->version_minor, cb->version_major))\n         {\n            RARCH_ERR(\"[Environ]: SET_HW_RENDER: Dynamic verify HW context failed.\\n\");\n            return false;\n         }\n\n#if defined(HAVE_OPENGL) || defined(HAVE_OPENGL_CORE)\n         /* TODO/FIXME - should check first if an OpenGL\n          * driver is running */\n         if (cb->context_type == RETRO_HW_CONTEXT_OPENGL_CORE)\n         {\n            /* Ensure that the rest of the frontend knows\n             * we have a core context */\n            gfx_ctx_flags_t flags;\n            flags.flags = 0;\n            BIT32_SET(flags.flags, GFX_CTX_FLAGS_GL_CORE_CONTEXT);\n\n            video_context_driver_set_flags(&flags);\n         }\n#endif\n\n         cb->get_current_framebuffer = video_driver_get_current_framebuffer;\n         cb->get_proc_address        = video_driver_get_proc_address;\n\n         /* Old ABI. Don't copy garbage. */\n         if (cmd & RETRO_ENVIRONMENT_EXPERIMENTAL)\n         {\n            memcpy(hwr,\n                  cb, offsetof(struct retro_hw_render_callback, stencil));\n            memset((uint8_t*)hwr + offsetof(struct retro_hw_render_callback, stencil),\n               0, sizeof(*cb) - offsetof(struct retro_hw_render_callback, stencil));\n         }\n         else\n            memcpy(hwr, cb, sizeof(*cb));\n         RARCH_DBG(\"Reached end of SET_HW_RENDER.\\n\");\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_SUPPORT_NO_GAME:\n      {\n         bool state = *(const bool*)data;\n         RARCH_LOG(\"[Environ]: SET_SUPPORT_NO_GAME: %s.\\n\", state ? \"yes\" : \"no\");\n\n         if (state)\n            content_set_does_not_need_content();\n         else\n            content_unset_does_not_need_content();\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_LIBRETRO_PATH:\n      {\n         const char **path = (const char**)data;\n         RARCH_LOG(\"[Environ]: GET_LIBRETRO_PATH.\\n\");\n#ifdef HAVE_DYNAMIC\n         *path = path_get(RARCH_PATH_CORE);\n#else\n         *path = NULL;\n#endif\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_AUDIO_CALLBACK:\n#ifdef HAVE_THREADS\n      {\n         recording_state_t\n            *recording_st            = recording_state_get_ptr();\n         audio_driver_state_t\n            *audio_st                = audio_state_get_ptr();\n         const struct\n            retro_audio_callback *cb = (const struct retro_audio_callback*)data;\n         RARCH_LOG(\"[Environ]: SET_AUDIO_CALLBACK.\\n\");\n#ifdef HAVE_NETWORKING\n         if (netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_ENABLED, NULL))\n            return false;\n#endif\n         if (recording_st->data) /* A/V sync is a must. */\n            return false;\n         if (cb)\n            audio_st->callback = *cb;\n      }\n      break;\n#else\n      return false;\n#endif\n\n      case RETRO_ENVIRONMENT_SET_FRAME_TIME_CALLBACK:\n      {\n         const struct retro_frame_time_callback *info =\n            (const struct retro_frame_time_callback*)data;\n\n         RARCH_LOG(\"[Environ]: SET_FRAME_TIME_CALLBACK.\\n\");\n#ifdef HAVE_NETWORKING\n         /* retro_run() will be called in very strange and\n          * mysterious ways, have to disable it. */\n         if (netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_ENABLED, NULL))\n            return false;\n#endif\n         runloop_st->frame_time = *info;\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_AUDIO_BUFFER_STATUS_CALLBACK:\n      {\n         const struct retro_audio_buffer_status_callback *info =\n            (const struct retro_audio_buffer_status_callback*)data;\n\n         RARCH_LOG(\"[Environ]: SET_AUDIO_BUFFER_STATUS_CALLBACK.\\n\");\n\n         if (info)\n            runloop_st->audio_buffer_status.callback = info->callback;\n         else\n            runloop_st->audio_buffer_status.callback = NULL;\n\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_MINIMUM_AUDIO_LATENCY:\n      {\n         unsigned audio_latency_default = settings->uints.audio_latency;\n         unsigned audio_latency_current =\n               (runloop_st->audio_latency > audio_latency_default) ?\n                     runloop_st->audio_latency : audio_latency_default;\n         unsigned audio_latency_new;\n\n         RARCH_LOG(\"[Environ]: RETRO_ENVIRONMENT_SET_MINIMUM_AUDIO_LATENCY.\\n\");\n\n         /* Sanitise input latency value */\n         runloop_st->audio_latency    = 0;\n         if (data)\n            runloop_st->audio_latency = *(const unsigned*)data;\n         if (runloop_st->audio_latency > 512)\n         {\n            RARCH_WARN(\"[Environ]: Requested audio latency of %u ms - limiting to maximum of 512 ms.\\n\",\n                  runloop_st->audio_latency);\n            runloop_st->audio_latency = 512;\n         }\n\n         /* Determine new set-point latency value */\n         if (runloop_st->audio_latency >= audio_latency_default)\n            audio_latency_new = runloop_st->audio_latency;\n         else\n         {\n            if (runloop_st->audio_latency != 0)\n               RARCH_WARN(\"[Environ]: Requested audio latency of %u ms is less than frontend default of %u ms.\"\n                     \" Using frontend default...\\n\",\n                     runloop_st->audio_latency, audio_latency_default);\n\n            audio_latency_new = audio_latency_default;\n         }\n\n         /* Check whether audio driver requires reinitialisation\n          * (Identical to RETRO_ENVIRONMENT_SET_SYSTEM_AV_INFO,\n          * without video driver initialisation) */\n         if (audio_latency_new != audio_latency_current)\n         {\n            recording_state_t\n               *recording_st      = recording_state_get_ptr();\n            video_driver_state_t *video_st    = video_state_get_ptr();\n            bool video_fullscreen = settings->bools.video_fullscreen;\n            int reinit_flags      = DRIVERS_CMD_ALL &\n                  ~(DRIVER_VIDEO_MASK | DRIVER_INPUT_MASK | DRIVER_MENU_MASK);\n\n            RARCH_LOG(\"[Environ]: Setting audio latency to %u ms.\\n\", audio_latency_new);\n\n            command_event(CMD_EVENT_REINIT, &reinit_flags);\n            video_driver_set_aspect_ratio();\n\n            /* Cannot continue recording with different\n             * parameters.\n             * Take the easiest route out and just restart\n             * the recording. */\n\n            if (recording_st->data)\n            {\n               const char *_msg = msg_hash_to_str(MSG_RESTARTING_RECORDING_DUE_TO_DRIVER_REINIT);\n               runloop_msg_queue_push(_msg, strlen(_msg), 2, 180, false, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n               if (recording_st->streaming_enable)\n               {\n                  command_event(CMD_EVENT_STREAMING_TOGGLE, NULL);\n                  command_event(CMD_EVENT_STREAMING_TOGGLE, NULL);\n               }\n               else\n               {\n                  command_event(CMD_EVENT_RECORD_DEINIT, NULL);\n                  command_event(CMD_EVENT_RECORD_INIT, NULL);\n               }\n            }\n\n            /* Hide mouse cursor in fullscreen mode */\n            if (video_fullscreen)\n            {\n               if (     video_st->poke\n                     && video_st->poke->show_mouse)\n                  video_st->poke->show_mouse(video_st->data, false);\n            }\n         }\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_RUMBLE_INTERFACE:\n      {\n         struct retro_rumble_interface *iface =\n            (struct retro_rumble_interface*)data;\n\n         RARCH_LOG(\"[Environ]: GET_RUMBLE_INTERFACE.\\n\");\n         iface->set_rumble_state = input_set_rumble_state;\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_INPUT_DEVICE_CAPABILITIES:\n      {\n         uint64_t *mask       = (uint64_t*)data;\n         input_driver_state_t\n            *input_st         = input_state_get_ptr();\n\n         RARCH_LOG(\"[Environ]: GET_INPUT_DEVICE_CAPABILITIES.\\n\");\n\n         if (     !input_st->current_driver->get_capabilities\n               || !input_st->current_data)\n            return false;\n\n         *mask = input_driver_get_capabilities();\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_SENSOR_INTERFACE:\n      {\n         settings_t *settings                 = config_get_ptr();\n         bool input_sensors_enable            = settings->bools.input_sensors_enable;\n         struct retro_sensor_interface *iface = (struct retro_sensor_interface*)data;\n\n         RARCH_LOG(\"[Environ]: GET_SENSOR_INTERFACE.\\n\");\n\n         if (!input_sensors_enable)\n            return false;\n\n         iface->set_sensor_state = input_set_sensor_state;\n         iface->get_sensor_input = input_get_sensor_state;\n         break;\n      }\n      case RETRO_ENVIRONMENT_GET_CAMERA_INTERFACE:\n      {\n         struct retro_camera_callback *cb =\n            (struct retro_camera_callback*)data;\n         camera_driver_state_t *camera_st = camera_state_get_ptr();\n\n         RARCH_LOG(\"[Environ]: GET_CAMERA_INTERFACE.\\n\");\n         cb->start                        = driver_camera_start;\n         cb->stop                         = driver_camera_stop;\n\n         camera_st->cb                    = *cb;\n         camera_st->active                = (cb->caps != 0);\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_LOCATION_INTERFACE:\n      {\n         struct retro_location_callback *cb =\n            (struct retro_location_callback*)data;\n         location_driver_state_t\n            *location_st                    = location_state_get_ptr();\n\n         RARCH_LOG(\"[Environ]: GET_LOCATION_INTERFACE.\\n\");\n         cb->start                       = driver_location_start;\n         cb->stop                        = driver_location_stop;\n         cb->get_position                = driver_location_get_position;\n         cb->set_interval                = driver_location_set_interval;\n\n         if (sys_info)\n            sys_info->location_cb        = *cb;\n\n         location_st->active             = false;\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_LOG_INTERFACE:\n      {\n         struct retro_log_callback *cb = (struct retro_log_callback*)data;\n\n         RARCH_LOG(\"[Environ]: GET_LOG_INTERFACE.\\n\");\n         cb->log = libretro_log_cb;\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_PERF_INTERFACE:\n      {\n         struct retro_perf_callback *cb = (struct retro_perf_callback*)data;\n\n         RARCH_LOG(\"[Environ]: GET_PERF_INTERFACE.\\n\");\n         cb->get_time_usec    = cpu_features_get_time_usec;\n         cb->get_cpu_features = cpu_features_get;\n         cb->get_perf_counter = cpu_features_get_perf_counter;\n\n         cb->perf_register    = runloop_performance_counter_register;\n         cb->perf_start       = core_performance_counter_start;\n         cb->perf_stop        = core_performance_counter_stop;\n         cb->perf_log         = runloop_perf_log;\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_CORE_ASSETS_DIRECTORY:\n      {\n         const char **dir            = (const char**)data;\n         const char *dir_core_assets = settings->paths.directory_core_assets;\n\n         *dir = *dir_core_assets ? dir_core_assets : NULL;\n         RARCH_LOG(\"[Environ]: CORE_ASSETS_DIRECTORY: \\\"%s\\\".\\n\",\n               dir_core_assets);\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_PLAYLIST_DIRECTORY:\n      {\n         const char **dir            = (const char**)data;\n         const char *dir_playlist    = settings->paths.directory_playlist;\n\n         *dir = *dir_playlist ? dir_playlist : NULL;\n         RARCH_LOG(\"[Environ]: PLAYLIST_DIRECTORY: \\\"%s\\\".\\n\",\n               dir_playlist);\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_FILE_BROWSER_START_DIRECTORY:\n      {\n         const char **dir            = (const char**)data;\n         const char *dir_content     = settings->paths.directory_menu_content;\n\n         *dir = *dir_content ? dir_content : NULL;\n         RARCH_LOG(\"[Environ]: FILE_BROWSER_START_DIRECTORY: \\\"%s\\\".\\n\",\n               dir_content);\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_SYSTEM_AV_INFO:\n      /**\n       * Update the system Audio/Video information.\n       * Will reinitialize audio/video drivers if needed.\n       * Used by RETRO_ENVIRONMENT_SET_SYSTEM_AV_INFO.\n       **/\n      {\n         const struct retro_system_av_info **info = (const struct retro_system_av_info**)&data;\n         video_driver_state_t *video_st           = video_state_get_ptr();\n         struct retro_system_av_info *av_info     = &video_st->av_info;\n\n         if (data)\n         {\n            int reinit_flags                      = DRIVERS_CMD_ALL;\n            settings_t *settings                  = config_get_ptr();\n            float refresh_rate                    = (*info)->timing.fps;\n            unsigned crt_switch_resolution        = settings->uints.crt_switch_resolution;\n            bool video_fullscreen                 = settings->bools.video_fullscreen;\n            bool video_switch_refresh_rate        = false;\n            bool no_video_reinit                  = true;\n\n            /* Refresh rate switch for regular displays */\n            if (video_display_server_has_resolution_list())\n               video_switch_refresh_rate_maybe(&refresh_rate, &video_switch_refresh_rate);\n\n            /* Recalibrate frame delay target when video reinits\n             * and pause frame delay when video does not reinit */\n            if (settings->bools.video_frame_delay_auto)\n            {\n               if (no_video_reinit && !video_switch_refresh_rate)\n                  video_st->frame_delay_pause  = true;\n               else\n                  video_st->frame_delay_target = 0;\n            }\n\n            no_video_reinit                       = (\n                     (crt_switch_resolution     == 0)\n                  && (video_switch_refresh_rate == false)\n                  && data\n                  && ((*info)->geometry.max_width  == av_info->geometry.max_width)\n                  && ((*info)->geometry.max_height == av_info->geometry.max_height));\n\n            /* First set new refresh rate and display rate, then after REINIT do\n             * another display rate change to make sure the change stays */\n            if (     video_switch_refresh_rate\n                  && video_display_server_set_refresh_rate(refresh_rate))\n               video_monitor_set_refresh_rate(refresh_rate);\n\n            /* When not doing video reinit, we also must not do input and menu\n             * reinit, otherwise the input driver crashes and the menu gets\n             * corrupted. */\n            if (no_video_reinit)\n               reinit_flags =\n                  DRIVERS_CMD_ALL &\n                  ~(DRIVER_VIDEO_MASK | DRIVER_INPUT_MASK |\n                                        DRIVER_MENU_MASK);\n\n            RARCH_LOG(\"[Environ]: SET_SYSTEM_AV_INFO: %ux%u, Aspect: %.3f, FPS: %.2f, Sample rate: %.2f Hz.\\n\",\n                  (*info)->geometry.base_width, (*info)->geometry.base_height,\n                  (*info)->geometry.aspect_ratio,\n                  (*info)->timing.fps,\n                  (*info)->timing.sample_rate);\n\n            memcpy(av_info, *info, sizeof(*av_info));\n\n            command_event(CMD_EVENT_REINIT, &reinit_flags);\n\n            if (no_video_reinit)\n               video_driver_set_aspect_ratio();\n\n            if (video_switch_refresh_rate)\n               video_display_server_set_refresh_rate(refresh_rate);\n\n            /* Cannot continue recording with different parameters.\n             * Take the easiest route out and just restart\n             * the recording. */\n            if (recording_st->data)\n            {\n               const char *_msg = msg_hash_to_str(MSG_RESTARTING_RECORDING_DUE_TO_DRIVER_REINIT);\n               runloop_msg_queue_push(_msg, strlen(_msg), 2, 180, false, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n               if (recording_st->streaming_enable)\n               {\n                  command_event(CMD_EVENT_STREAMING_TOGGLE, NULL);\n                  command_event(CMD_EVENT_STREAMING_TOGGLE, NULL);\n               }\n               else\n               {\n                  command_event(CMD_EVENT_RECORD_DEINIT, NULL);\n                  command_event(CMD_EVENT_RECORD_INIT, NULL);\n               }\n            }\n\n            /* Hide mouse cursor in fullscreen after\n             * a RETRO_ENVIRONMENT_SET_SYSTEM_AV_INFO call. */\n            if (video_fullscreen)\n            {\n               if (     video_st->poke\n                     && video_st->poke->show_mouse)\n                  video_st->poke->show_mouse(video_st->data, false);\n            }\n\n            return true;\n         }\n         return false;\n      }\n\n      case RETRO_ENVIRONMENT_SET_SUBSYSTEM_INFO:\n      {\n         unsigned i;\n         const struct retro_subsystem_info *info =\n               (const struct retro_subsystem_info*)data;\n         unsigned log_level   = settings->uints.libretro_log_level;\n\n         RARCH_DBG(\"[Environ]: SET_SUBSYSTEM_INFO.\\n\");\n\n         for (i = 0; info[i].ident; i++)\n         {\n            unsigned j;\n\n            if (log_level != RETRO_LOG_DEBUG)\n               continue;\n\n            RARCH_DBG(\"Special game type: %s\\n  Ident: %s\\n  ID: %u\\n  Content:\\n\",\n                  info[i].desc,\n                  info[i].ident,\n                  info[i].id\n                  );\n\n            for (j = 0; j < info[i].num_roms; j++)\n            {\n               RARCH_DBG(\"    %s (%s)\\n\",\n                     info[i].roms[j].desc, info[i].roms[j].required ?\n                     \"required\" : \"optional\");\n            }\n         }\n\n         if (sys_info)\n         {\n            struct retro_subsystem_info *info_ptr = NULL;\n            free(sys_info->subsystem.data);\n            sys_info->subsystem.data = NULL;\n            sys_info->subsystem.size = 0;\n\n            info_ptr = (struct retro_subsystem_info*)\n                  malloc(i * sizeof(*info_ptr));\n\n            if (!info_ptr)\n               return false;\n\n            sys_info->subsystem.data = info_ptr;\n\n            memcpy(sys_info->subsystem.data, info,\n                  i * sizeof(*sys_info->subsystem.data));\n            sys_info->subsystem.size                 = i;\n            runloop_st->current_core.flags          |=\n                  RETRO_CORE_FLAG_HAS_SET_SUBSYSTEMS;\n         }\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_CONTROLLER_INFO:\n      {\n         unsigned i, j;\n         const struct retro_controller_info *info\n                                 = (const struct retro_controller_info*)data;\n         unsigned log_level      = settings->uints.libretro_log_level;\n\n         RARCH_LOG(\"[Environ]: SET_CONTROLLER_INFO.\\n\");\n\n         for (i = 0; info[i].types; i++)\n         {\n            if (log_level != RETRO_LOG_DEBUG)\n               continue;\n\n            RARCH_DBG(\"   %s %u:\\n\", msg_hash_to_str(MENU_ENUM_LABEL_VALUE_PORT), i + 1);\n\n            for (j = 0; j < info[i].num_types; j++)\n               if (info[i].types[j].desc)\n                  RARCH_DBG(\"      \\\"%s\\\" (%u)\\n\",\n                        info[i].types[j].desc,\n                     info[i].types[j].id);\n         }\n\n         if (sys_info)\n         {\n            struct retro_controller_info *info_ptr = NULL;\n\n            free(sys_info->ports.data);\n            sys_info->ports.data = NULL;\n            sys_info->ports.size = 0;\n\n            if (!(info_ptr = (struct retro_controller_info*)\n                     calloc(i, sizeof(*info_ptr))))\n               return false;\n\n            sys_info->ports.data = info_ptr;\n            memcpy(sys_info->ports.data, info,\n                  i * sizeof(*sys_info->ports.data));\n            sys_info->ports.size = i;\n         }\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_MEMORY_MAPS:\n      {\n         if (sys_info)\n         {\n            unsigned i;\n            const struct retro_memory_map *mmaps   =\n                  (const struct retro_memory_map*)data;\n            rarch_memory_descriptor_t *descriptors = NULL;\n            unsigned int log_level                 = settings->uints.libretro_log_level;\n\n            RARCH_LOG(\"[Environ]: SET_MEMORY_MAPS.\\n\");\n\n            free((void*)sys_info->mmaps.descriptors);\n            sys_info->mmaps.descriptors     = 0;\n            sys_info->mmaps.num_descriptors = 0;\n\n            if (!(descriptors = (rarch_memory_descriptor_t*)calloc(mmaps->num_descriptors,\n                  sizeof(*descriptors))))\n               return false;\n\n            sys_info->mmaps.descriptors     = descriptors;\n            sys_info->mmaps.num_descriptors = mmaps->num_descriptors;\n\n            for (i = 0; i < mmaps->num_descriptors; i++)\n               sys_info->mmaps.descriptors[i].core = mmaps->descriptors[i];\n\n            mmap_preprocess_descriptors(descriptors, mmaps->num_descriptors);\n\n#ifdef HAVE_CHEEVOS\n            rcheevos_refresh_memory();\n#endif\n#ifdef HAVE_CHEATS\n            if (cheat_manager_state.memory_initialized)\n            {\n               cheat_manager_initialize_memory(NULL, 0, true);\n               cheat_manager_apply_retro_cheats();\n            }\n#endif\n\n            if (log_level != RETRO_LOG_DEBUG)\n               break;\n\n            if (sizeof(void *) == 8)\n               RARCH_DBG(\"           ndx flags  ptr              offset   start    select   disconn  len      addrspace\\n\");\n            else\n               RARCH_DBG(\"           ndx flags  ptr          offset   start    select   disconn  len      addrspace\\n\");\n\n            for (i = 0; i < sys_info->mmaps.num_descriptors; i++)\n            {\n               char flags[7];\n               const rarch_memory_descriptor_t *desc =\n                  &sys_info->mmaps.descriptors[i];\n\n               flags[0]    = 'M';\n               if (     (desc->core.flags & RETRO_MEMDESC_MINSIZE_8) == RETRO_MEMDESC_MINSIZE_8)\n                  flags[1] = '8';\n               else if ((desc->core.flags & RETRO_MEMDESC_MINSIZE_4) == RETRO_MEMDESC_MINSIZE_4)\n                  flags[1] = '4';\n               else if ((desc->core.flags & RETRO_MEMDESC_MINSIZE_2) == RETRO_MEMDESC_MINSIZE_2)\n                  flags[1] = '2';\n               else\n                  flags[1] = '1';\n\n               flags[2] = 'A';\n               if (     (desc->core.flags & RETRO_MEMDESC_ALIGN_8) == RETRO_MEMDESC_ALIGN_8)\n                  flags[3] = '8';\n               else if ((desc->core.flags & RETRO_MEMDESC_ALIGN_4) == RETRO_MEMDESC_ALIGN_4)\n                  flags[3] = '4';\n               else if ((desc->core.flags & RETRO_MEMDESC_ALIGN_2) == RETRO_MEMDESC_ALIGN_2)\n                  flags[3] = '2';\n               else\n                  flags[3] = '1';\n\n               flags[4] = (desc->core.flags & RETRO_MEMDESC_BIGENDIAN) ? 'B' : 'b';\n               flags[5] = (desc->core.flags & RETRO_MEMDESC_CONST)     ? 'C' : 'c';\n               flags[6] = 0;\n\n               RARCH_DBG(\"           %03u %s %p %08X %08X %08X %08X %08X %s\\n\",\n                     i + 1, flags, desc->core.ptr, desc->core.offset, desc->core.start,\n                     desc->core.select, desc->core.disconnect, desc->core.len,\n                     desc->core.addrspace ? desc->core.addrspace : \"\");\n            }\n         }\n         else\n         {\n            RARCH_WARN(\"[Environ]: SET_MEMORY_MAPS, but system pointer not initialized..\\n\");\n         }\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_GEOMETRY:\n      {\n         video_driver_state_t *video_st           = video_state_get_ptr();\n         struct retro_system_av_info *av_info     = &video_st->av_info;\n         struct retro_game_geometry  *geom        = (struct retro_game_geometry*)&av_info->geometry;\n         const struct retro_game_geometry *in_geom= (const struct retro_game_geometry*)data;\n\n         if (!geom)\n            return false;\n\n         /* Can potentially be called every frame,\n          * don't do anything unless required. */\n         if (     (geom->base_width   != in_geom->base_width)\n               || (geom->base_height  != in_geom->base_height)\n               || (geom->aspect_ratio != in_geom->aspect_ratio))\n         {\n            geom->base_width   = in_geom->base_width;\n            geom->base_height  = in_geom->base_height;\n            geom->aspect_ratio = in_geom->aspect_ratio;\n\n            RARCH_LOG(\"[Environ]: SET_GEOMETRY: %ux%u, Aspect: %.3f.\\n\",\n                  geom->base_width, geom->base_height, geom->aspect_ratio);\n\n            /* Forces recomputation of aspect ratios if\n             * using core-dependent aspect ratios. */\n            video_driver_set_aspect_ratio();\n\n            /* Ignore frame delay target temporarily */\n            if (settings->bools.video_frame_delay_auto)\n               video_st->frame_delay_pause = true;\n\n            /* TODO: Figure out what to do, if anything, with\n               recording. */\n         }\n         else\n         {\n            RARCH_LOG(\"[Environ]: SET_GEOMETRY.\\n\");\n         }\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_CURRENT_SOFTWARE_FRAMEBUFFER:\n      {\n         video_driver_state_t *video_st = video_state_get_ptr();\n         struct retro_framebuffer *fb   = (struct retro_framebuffer*)data;\n\n         if (\n                  video_st->poke\n               && video_st->poke->get_current_software_framebuffer\n               && video_st->poke->get_current_software_framebuffer(\n                  video_st->data, fb))\n            return true;\n\n         return false;\n      }\n\n      case RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE:\n      {\n         video_driver_state_t *video_st = video_state_get_ptr();\n         const struct retro_hw_render_interface **iface = (const struct retro_hw_render_interface **)data;\n\n         if (\n                  video_st->poke\n               && video_st->poke->get_hw_render_interface\n               && video_st->poke->get_hw_render_interface(\n                  video_st->data, iface))\n            return true;\n\n         return false;\n      }\n\n      case RETRO_ENVIRONMENT_SET_SUPPORT_ACHIEVEMENTS:\n#ifdef HAVE_CHEEVOS\n         {\n            bool state = *(const bool*)data;\n\n            RARCH_LOG(\"[Environ]: SET_SUPPORT_ACHIEVEMENTS: %s.\\n\", state ? \"yes\" : \"no\");\n            rcheevos_set_support_cheevos(state);\n         }\n#endif\n         break;\n\n      case RETRO_ENVIRONMENT_SET_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE:\n      {\n         video_driver_state_t *video_st = video_state_get_ptr();\n         const struct retro_hw_render_context_negotiation_interface *iface =\n               (const struct retro_hw_render_context_negotiation_interface*)data;\n\n         RARCH_LOG(\"[Environ]: SET_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE.\\n\");\n         video_st->hw_render_context_negotiation = iface;\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_SERIALIZATION_QUIRKS:\n      {\n         uint64_t *quirks = (uint64_t *) data;\n\n         RARCH_LOG(\"[Environ]: SET_SERIALIZATION_QUIRKS.\\n\");\n         runloop_st->current_core.serialization_quirks_v = *quirks;\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_SET_HW_SHARED_CONTEXT:\n#ifdef HAVE_LIBNX\n         RARCH_LOG(\"[Environ]: SET_HW_SHARED_CONTEXT - ignored for now.\\n\");\n         /* TODO/FIXME - Force this off for now for Switch\n          * until shared HW context can work there */\n         return false;\n#else\n         RARCH_LOG(\"[Environ]: SET_HW_SHARED_CONTEXT.\\n\");\n         runloop_st->flags |= RUNLOOP_FLAG_CORE_SET_SHARED_CONTEXT;\n#endif\n         break;\n\n      case RETRO_ENVIRONMENT_GET_VFS_INTERFACE:\n      {\n         const uint32_t supported_vfs_version = 3;\n         static struct retro_vfs_interface vfs_iface =\n         {\n            /* VFS API v1 */\n            retro_vfs_file_get_path_impl,\n            retro_vfs_file_open_impl,\n            retro_vfs_file_close_impl,\n            retro_vfs_file_size_impl,\n            retro_vfs_file_tell_impl,\n            retro_vfs_file_seek_impl,\n            retro_vfs_file_read_impl,\n            retro_vfs_file_write_impl,\n            retro_vfs_file_flush_impl,\n            retro_vfs_file_remove_impl,\n            retro_vfs_file_rename_impl,\n            /* VFS API v2 */\n            retro_vfs_file_truncate_impl,\n            /* VFS API v3 */\n            retro_vfs_stat_impl,\n            retro_vfs_mkdir_impl,\n            retro_vfs_opendir_impl,\n            retro_vfs_readdir_impl,\n            retro_vfs_dirent_get_name_impl,\n            retro_vfs_dirent_is_dir_impl,\n            retro_vfs_closedir_impl\n         };\n\n         struct retro_vfs_interface_info *vfs_iface_info = (struct retro_vfs_interface_info *) data;\n         if (vfs_iface_info->required_interface_version <= supported_vfs_version)\n         {\n            RARCH_LOG(\"[Environ]: GET_VFS_INTERFACE. Core requested version >= V%d, providing V%d.\\n\",\n                  vfs_iface_info->required_interface_version, supported_vfs_version);\n\n            vfs_iface_info->required_interface_version = supported_vfs_version;\n            vfs_iface_info->iface                      = &vfs_iface;\n            sys_info->supports_vfs                     = true;\n         }\n         else\n         {\n            RARCH_WARN(\"[Environ]: GET_VFS_INTERFACE. Core requested version V%d which is higher than what we support (V%d).\\n\",\n                  vfs_iface_info->required_interface_version, supported_vfs_version);\n\n            return false;\n         }\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_LED_INTERFACE:\n      {\n         struct retro_led_interface *ledintf = (struct retro_led_interface *)data;\n\n         if (ledintf)\n            ledintf->set_led_state = led_driver_set_led;\n\n         RARCH_LOG(\"[Environ]: GET_LED_INTERFACE.\\n\");\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_AUDIO_VIDEO_ENABLE:\n      {\n         enum retro_av_enable_flags result = (enum retro_av_enable_flags)0;\n         video_driver_state_t *video_st    = video_state_get_ptr();\n         audio_driver_state_t *audio_st    = audio_state_get_ptr();\n\n         if (    !(audio_st->flags & AUDIO_FLAG_SUSPENDED)\n               && (audio_st->flags & AUDIO_FLAG_ACTIVE))\n            result |= RETRO_AV_ENABLE_AUDIO;\n\n         if (      (video_st->flags & VIDEO_FLAG_ACTIVE)\n               && !(video_st->current_video->frame == video_null.frame))\n            result |= RETRO_AV_ENABLE_VIDEO;\n\n#ifdef HAVE_RUNAHEAD\n         if (audio_st->flags & AUDIO_FLAG_HARD_DISABLE)\n            result |= RETRO_AV_ENABLE_HARD_DISABLE_AUDIO;\n#endif\n\n#ifdef HAVE_NETWORKING\n         if (netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_REPLAYING, NULL))\n            result &= ~(RETRO_AV_ENABLE_VIDEO|RETRO_AV_ENABLE_AUDIO);\n#endif\n\n#if defined(HAVE_RUNAHEAD) || defined(HAVE_NETWORKING)\n         /* Deprecated.\n            Use RETRO_ENVIRONMENT_GET_SAVESTATE_CONTEXT instead. */\n         /* TODO/FIXME: Get rid of this ugly hack. */\n         if (runloop_st->flags & RUNLOOP_FLAG_REQUEST_SPECIAL_SAVESTATE)\n            result |= RETRO_AV_ENABLE_FAST_SAVESTATES;\n#endif\n         if (data)\n         {\n            enum retro_av_enable_flags* result_p = (enum retro_av_enable_flags*)data;\n            *result_p = result;\n         }\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_SAVESTATE_CONTEXT:\n      {\n         int result = RETRO_SAVESTATE_CONTEXT_NORMAL;\n\n#if defined(HAVE_RUNAHEAD) || defined(HAVE_NETWORKING)\n         if (runloop_st->flags & RUNLOOP_FLAG_REQUEST_SPECIAL_SAVESTATE)\n         {\n#ifdef HAVE_NETWORKING\n            if (netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_ENABLED, NULL))\n               result = RETRO_SAVESTATE_CONTEXT_ROLLBACK_NETPLAY;\n            else\n#endif\n            {\n#ifdef HAVE_RUNAHEAD\n#if defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB)\n               settings_t *settings = config_get_ptr();\n\n               if (      settings->bools.run_ahead_secondary_instance\n                     && (runloop_st->flags & RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE)\n                     &&  secondary_core_ensure_exists(runloop_st, settings))\n                  result = RETRO_SAVESTATE_CONTEXT_RUNAHEAD_SAME_BINARY;\n               else\n#endif\n                  result = RETRO_SAVESTATE_CONTEXT_RUNAHEAD_SAME_INSTANCE;\n#endif\n            }\n         }\n#endif\n\n         if (data)\n            *(int*)data = result;\n\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_MIDI_INTERFACE:\n      {\n         struct retro_midi_interface *midi_interface =\n               (struct retro_midi_interface *)data;\n\n         if (midi_interface)\n         {\n            midi_interface->input_enabled  = midi_driver_input_enabled;\n            midi_interface->output_enabled = midi_driver_output_enabled;\n            midi_interface->read           = midi_driver_read;\n            midi_interface->write          = midi_driver_write;\n            midi_interface->flush          = midi_driver_flush;\n         }\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_FASTFORWARDING:\n         *(bool *)data = ((runloop_st->flags & RUNLOOP_FLAG_FASTMOTION) > 0);\n         break;\n\n      case RETRO_ENVIRONMENT_SET_FASTFORWARDING_OVERRIDE:\n      {\n         struct retro_fastforwarding_override *fastforwarding_override =\n               (struct retro_fastforwarding_override *)data;\n\n         /* Record new retro_fastforwarding_override parameters\n          * and schedule application on the the next call of\n          * runloop_check_state() */\n         if (fastforwarding_override)\n         {\n            memcpy(&runloop_st->fastmotion_override.next,\n                  fastforwarding_override,\n                  sizeof(runloop_st->fastmotion_override.next));\n            runloop_st->fastmotion_override.pending = true;\n         }\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_THROTTLE_STATE:\n      {\n         video_driver_state_t *video_st = video_state_get_ptr();\n         audio_driver_state_t *audio_st = audio_state_get_ptr();\n         struct retro_throttle_state *throttle_state\n                                        = (struct retro_throttle_state *)data;\n\n         bool menu_opened = false;\n         bool core_paused = (runloop_st->flags & RUNLOOP_FLAG_PAUSED) ? true : false;\n         bool no_audio    = ((audio_st->flags & AUDIO_FLAG_SUSPENDED)\n                         || !(audio_st->flags & AUDIO_FLAG_ACTIVE));\n         float core_fps   = (float)video_st->av_info.timing.fps;\n\n#ifdef HAVE_REWIND\n         if (runloop_st->rewind_st.flags\n               & STATE_MGR_REWIND_ST_FLAG_FRAME_IS_REVERSED)\n         {\n            throttle_state->mode = RETRO_THROTTLE_REWINDING;\n            throttle_state->rate = 0.0f;\n            break; /* ignore vsync */\n         }\n#endif\n\n#ifdef HAVE_MENU\n         menu_opened = (menu_state_get_ptr()->flags & MENU_ST_FLAG_ALIVE) ? true : false;\n         if (menu_opened)\n#ifdef HAVE_NETWORKING\n            core_paused = settings->bools.menu_pause_libretro\n               && netplay_driver_ctl(RARCH_NETPLAY_CTL_ALLOW_PAUSE, NULL);\n#else\n            core_paused = settings->bools.menu_pause_libretro;\n#endif\n#endif\n\n         if (core_paused)\n         {\n            throttle_state->mode = RETRO_THROTTLE_FRAME_STEPPING;\n            throttle_state->rate = 0.0f;\n            break; /* ignore vsync */\n         }\n\n         /* Base mode and rate. */\n         throttle_state->mode = RETRO_THROTTLE_NONE;\n         throttle_state->rate = core_fps;\n\n         if (runloop_st->flags & RUNLOOP_FLAG_FASTMOTION)\n         {\n            throttle_state->mode  = RETRO_THROTTLE_FAST_FORWARD;\n            throttle_state->rate *= runloop_get_fastforward_ratio(\n                  settings, &runloop_st->fastmotion_override.current);\n         }\n         else if ((runloop_st->flags & RUNLOOP_FLAG_SLOWMOTION)\n               && !no_audio)\n         {\n            throttle_state->mode = RETRO_THROTTLE_SLOW_MOTION;\n            throttle_state->rate /= (settings->floats.slowmotion_ratio > 0.0f ?\n                  settings->floats.slowmotion_ratio : 1.0f);\n         }\n\n         /* VSync overrides the mode if the rate is limited by the display. */\n         if (      menu_opened /* Menu currently always runs with vsync on. */\n               || (settings->bools.video_vsync\n               && (!(runloop_st->flags & RUNLOOP_FLAG_FORCE_NONBLOCK))\n               && !(input_state_get_ptr()->flags & INP_FLAG_NONBLOCKING)))\n         {\n            float refresh_rate = video_driver_get_refresh_rate();\n            if (refresh_rate == 0.0f)\n               refresh_rate = settings->floats.video_refresh_rate;\n            if (    (refresh_rate < throttle_state->rate)\n                  || !throttle_state->rate)\n            {\n               /* Keep the mode as fast forward even if vsync limits it. */\n               if (refresh_rate < core_fps)\n                  throttle_state->mode = RETRO_THROTTLE_VSYNC;\n               throttle_state->rate = refresh_rate;\n            }\n         }\n\n         /* Special behavior while audio output is not available. */\n         if (no_audio && throttle_state->mode != RETRO_THROTTLE_FAST_FORWARD\n                      && throttle_state->mode != RETRO_THROTTLE_VSYNC)\n         {\n            /* Keep base if frame limiter matching the core is active. */\n            retro_time_t core_limit     = (core_fps\n                  ? (retro_time_t)(1000000.0f / core_fps)\n                  : (retro_time_t)0);\n            retro_time_t frame_limit    = runloop_st->frame_limit_minimum_time;\n            if (abs((int)(core_limit - frame_limit)) > 10)\n            {\n               throttle_state->mode     = RETRO_THROTTLE_UNBLOCKED;\n               throttle_state->rate     = 0.0f;\n            }\n         }\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_INPUT_BITMASKS:\n         /* Just falldown, the function will return true */\n         break;\n\n      case RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION:\n         RARCH_LOG(\"[Environ]: GET_CORE_OPTIONS_VERSION.\\n\");\n         /* Current API version is 2 */\n         *(unsigned *)data = 2;\n         break;\n\n      case RETRO_ENVIRONMENT_GET_TARGET_REFRESH_RATE:\n      {\n         /* Try to use the polled refresh rate first.  */\n         float target_refresh_rate = video_driver_get_refresh_rate();\n\n         /* If the above function failed [possibly because it is not\n          * implemented], use the refresh rate set in the config instead. */\n         if (target_refresh_rate == 0.0f)\n         {\n            if (settings)\n               target_refresh_rate = settings->floats.video_refresh_rate;\n         }\n\n         *(float *)data = target_refresh_rate;\n         break;\n      }\n\n      case RETRO_ENVIRONMENT_GET_INPUT_MAX_USERS:\n         *(unsigned *)data = settings->uints.input_max_users;\n         break;\n\n      /* Private environment callbacks.\n       *\n       * Should all be properly addressed in version 2.\n       * */\n\n      case RETRO_ENVIRONMENT_POLL_TYPE_OVERRIDE:\n         {\n            const unsigned *poll_type_data = (const unsigned*)data;\n\n            if (poll_type_data)\n               runloop_st->core_poll_type_override = (enum poll_type_override_t)*poll_type_data;\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_GET_CLEAR_ALL_THREAD_WAITS_CB:\n         *(retro_environment_t *)data = runloop_clear_all_thread_waits;\n         break;\n\n      case RETRO_ENVIRONMENT_SET_SAVE_STATE_IN_BACKGROUND:\n         {\n            bool state = *(const bool*)data;\n\n            RARCH_LOG(\"[Environ]: SET_SAVE_STATE_IN_BACKGROUND: %s.\\n\", state ? \"yes\" : \"no\");\n\n            set_save_state_in_background(state);\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_SET_CONTENT_INFO_OVERRIDE:\n         {\n            const struct retro_system_content_info_override *overrides =\n                  (const struct retro_system_content_info_override *)data;\n\n            RARCH_LOG(\"[Environ]: RETRO_ENVIRONMENT_SET_CONTENT_INFO_OVERRIDE.\\n\");\n\n            /* Passing NULL always results in 'success' - this\n             * allows cores to test for frontend support of\n             * the RETRO_ENVIRONMENT_SET_CONTENT_INFO_OVERRIDE and\n             * RETRO_ENVIRONMENT_GET_GAME_INFO_EXT callbacks */\n            if (!overrides)\n               return true;\n\n            return content_file_override_set(overrides);\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_GET_GAME_INFO_EXT:\n         {\n            content_state_t *p_content                       =\n                  content_state_get_ptr();\n            const struct retro_game_info_ext **game_info_ext =\n                  (const struct retro_game_info_ext **)data;\n\n            RARCH_LOG(\"[Environ]: RETRO_ENVIRONMENT_GET_GAME_INFO_EXT.\\n\");\n\n            if (!game_info_ext)\n               return false;\n\n            if (     p_content\n                  && p_content->content_list\n                  && p_content->content_list->game_info_ext)\n               *game_info_ext = p_content->content_list->game_info_ext;\n            else\n            {\n               RARCH_ERR(\"[Environ]: Failed to retrieve extended game info.\\n\");\n               *game_info_ext = NULL;\n               return false;\n            }\n         }\n         break;\n      case RETRO_ENVIRONMENT_GET_MICROPHONE_INTERFACE:\n#ifdef HAVE_MICROPHONE\n         {\n            struct retro_microphone_interface* microphone = (struct retro_microphone_interface *)data;\n            microphone_driver_state_t *mic_st             = microphone_state_get_ptr();\n            const microphone_driver_t *driver             = mic_st->driver;\n\n            RARCH_LOG(\"[Environ]: RETRO_ENVIRONMENT_GET_MICROPHONE_INTERFACE.\\n\");\n\n            if (!microphone)\n               return false;\n            /* User didn't provide a pointer for a response, what can we do? */\n\n            if (microphone->interface_version != RETRO_MICROPHONE_INTERFACE_VERSION)\n            {\n               RARCH_ERR(\"[Environ]: Core requested unexpected microphone interface version %u, only %u is available\\n\",\n                  microphone->interface_version,\n                  RETRO_MICROPHONE_INTERFACE_VERSION);\n\n               return false;\n            }\n\n            /* Initialize the interface... */\n            memset(microphone, 0, sizeof(*microphone));\n\n            if (driver == &microphone_null)\n            { /* If the null driver is active... */\n               RARCH_ERR(\"[Environ]: Cannot initialize microphone interface, active driver is null\\n\");\n               return false;\n            }\n\n            if (!settings->bools.microphone_enable)\n            { /* If mic support is off... */\n               RARCH_WARN(\"[Environ]: Will not initialize microphone interface, support is turned off\\n\");\n               return false;\n            }\n\n            /* The core might request a mic before the mic driver is initialized,\n             * so we still have to see if the frontend intends to init a mic driver. */\n            if (!driver && string_is_equal(settings->arrays.microphone_driver, \"null\"))\n            { /* If we're going to load the null driver... */\n               RARCH_ERR(\"[Environ]: Cannot initialize microphone interface, configured driver is null\\n\");\n               return false;\n            }\n\n            microphone->interface_version = RETRO_MICROPHONE_INTERFACE_VERSION;\n            microphone->open_mic      = microphone_driver_open_mic;\n            microphone->close_mic     = microphone_driver_close_mic;\n            microphone->get_params    = microphone_driver_get_effective_params;\n            microphone->set_mic_state = microphone_driver_set_mic_state;\n            microphone->get_mic_state = microphone_driver_get_mic_state;\n            microphone->read_mic      = microphone_driver_read;\n         }\n#else\n         {\n            struct retro_microphone_interface* microphone = (struct retro_microphone_interface *)data;\n            RARCH_LOG(\"[Environ]: RETRO_ENVIRONMENT_GET_MICROPHONE_INTERFACE.\\n\");\n\n            if (microphone)\n               microphone->interface_version = 0;\n\n            RARCH_ERR(\"[Environ]: Core requested microphone interface, but this build does not include support\\n\");\n\n            return false;\n         }\n#endif\n         break;\n      case RETRO_ENVIRONMENT_GET_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_SUPPORT:\n         {\n            struct retro_hw_render_context_negotiation_interface *iface =\n                  (struct retro_hw_render_context_negotiation_interface*)data;\n\n#ifdef HAVE_VULKAN\n            if (iface->interface_type == RETRO_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_VULKAN)\n               iface->interface_version = RETRO_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_VULKAN_VERSION;\n            else\n#endif\n            {\n               iface->interface_version = 0;\n            }\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_GET_JIT_CAPABLE:\n         {\n#if TARGET_OS_IPHONE\n            *(bool*)data             = jit_available();\n#else\n            *(bool*)data             = true;\n#endif\n         }\n         break;\n\n      case RETRO_ENVIRONMENT_SET_NETPACKET_INTERFACE:\n#ifdef HAVE_NETWORKING\n         RARCH_LOG(\"[Environ]: RETRO_ENVIRONMENT_SET_NETPACKET_INTERFACE.\\n\");\n         if (!netplay_driver_ctl(RARCH_NETPLAY_CTL_SET_CORE_PACKET_INTERFACE, data))\n         {\n            RARCH_ERR(\"[Environ] RETRO_ENVIRONMENT_SET_NETPACKET_INTERFACE set too late\\n\");\n            return false;\n         }\n         break;\n#else\n         return false;\n#endif\n\n      case RETRO_ENVIRONMENT_GET_DEVICE_POWER:\n         {\n            struct retro_device_power *status = (struct retro_device_power *)data;\n            frontend_ctx_driver_t *frontend = frontend_get_ptr();\n            int seconds = 0;\n            int percent = 0;\n\n            /* If the frontend driver is unavailable... */\n            if (!frontend)\n               return false;\n\n            /* If the core just wants to query support for this environment call... */\n            if (!status)\n               return frontend->get_powerstate != NULL;\n\n            /* If the frontend driver doesn't support reporting the powerstate... */\n            if (frontend->get_powerstate == NULL)\n               return false;\n\n            switch (frontend->get_powerstate(&seconds, &percent))\n            {\n               case FRONTEND_POWERSTATE_ON_POWER_SOURCE: /* on battery power */\n                  status->state = RETRO_POWERSTATE_DISCHARGING;\n                  status->percent = (int8_t)percent;\n                  status->seconds = seconds == 0 ? RETRO_POWERSTATE_NO_ESTIMATE : seconds;\n                  break;\n               case FRONTEND_POWERSTATE_CHARGING /* battery available, charging */:\n                  status->state = RETRO_POWERSTATE_CHARGING;\n                  status->percent = (int8_t)percent;\n                  status->seconds = seconds == 0 ? RETRO_POWERSTATE_NO_ESTIMATE : seconds;\n                  break;\n               case FRONTEND_POWERSTATE_CHARGED: /* on AC, battery is full */\n                  status->state = RETRO_POWERSTATE_CHARGED;\n                  status->percent = (int8_t)percent;\n                  status->seconds = RETRO_POWERSTATE_NO_ESTIMATE;\n                  break;\n               case FRONTEND_POWERSTATE_NO_SOURCE: /* on AC, no battery available */\n                  status->state = RETRO_POWERSTATE_PLUGGED_IN;\n                  status->percent = RETRO_POWERSTATE_NO_ESTIMATE;\n                  status->seconds = RETRO_POWERSTATE_NO_ESTIMATE;\n                  break;\n               default:\n                  /* The frontend driver supports power status queries,\n                   * but it still gave us bad information for whatever reason. */\n                  return false;\n                  break;\n            }\n         }\n         break;\n      default:\n         RARCH_LOG(\"[Environ]: UNSUPPORTED (#%u).\\n\", cmd);\n         return false;\n   }\n\n   return true;\n}\n\nbool libretro_get_system_info(\n      const char *path,\n      struct retro_system_info *sysinfo,\n      bool *load_no_content)\n{\n   struct retro_system_info dummy_info;\n#ifdef HAVE_DYNAMIC\n   dylib_t lib;\n#endif\n   runloop_state_t *runloop_st  = &runloop_state;\n\n   if (string_ends_with_size(path,\n            \"builtin\", strlen(path), STRLEN_CONST(\"builtin\")))\n      return false;\n\n   dummy_info.library_name      = NULL;\n   dummy_info.library_version   = NULL;\n   dummy_info.valid_extensions  = NULL;\n   dummy_info.need_fullpath     = false;\n   dummy_info.block_extract     = false;\n\n#ifdef HAVE_DYNAMIC\n   if (!(lib = libretro_get_system_info_lib(\n         path, &dummy_info, load_no_content)))\n   {\n      RARCH_ERR(\"%s: \\\"%s\\\"\\n\",\n            msg_hash_to_str(MSG_FAILED_TO_OPEN_LIBRETRO_CORE),\n            path);\n      RARCH_ERR(\"Error(s): %s\\n\", dylib_error());\n      return false;\n   }\n#else\n   if (load_no_content)\n   {\n      runloop_st->load_no_content_hook = load_no_content;\n\n      /* load_no_content gets set in this callback. */\n      retro_set_environment(runloop_environ_cb_get_system_info);\n\n      /* It's possible that we just set get_system_info callback\n       * to the currently running core.\n       *\n       * Make sure we reset it to the actual environment callback.\n       * Ignore any environment callbacks here in case we're running\n       * on the non-current core. */\n      runloop_st->flags |=  RUNLOOP_FLAG_IGNORE_ENVIRONMENT_CB;\n      retro_set_environment(runloop_environment_cb);\n      runloop_st->flags &= ~RUNLOOP_FLAG_IGNORE_ENVIRONMENT_CB;\n   }\n\n   retro_get_system_info(&dummy_info);\n#endif\n\n   memcpy(sysinfo, &dummy_info, sizeof(*sysinfo));\n\n   runloop_st->current_library_name[0]     = '\\0';\n   runloop_st->current_library_version[0]  = '\\0';\n   runloop_st->current_valid_extensions[0] = '\\0';\n\n   if (!string_is_empty(dummy_info.library_name))\n      strlcpy(runloop_st->current_library_name,\n            dummy_info.library_name,\n            sizeof(runloop_st->current_library_name));\n   if (!string_is_empty(dummy_info.library_version))\n      strlcpy(runloop_st->current_library_version,\n            dummy_info.library_version,\n            sizeof(runloop_st->current_library_version));\n\n   if (dummy_info.valid_extensions)\n      strlcpy(runloop_st->current_valid_extensions,\n            dummy_info.valid_extensions,\n            sizeof(runloop_st->current_valid_extensions));\n\n   sysinfo->library_name     = runloop_st->current_library_name;\n   sysinfo->library_version  = runloop_st->current_library_version;\n   sysinfo->valid_extensions = runloop_st->current_valid_extensions;\n\n#ifdef HAVE_DYNAMIC\n   dylib_close(lib);\n#endif\n   return true;\n}\n\nbool runloop_init_libretro_symbols(\n      void *data,\n      enum rarch_core_type type,\n      struct retro_core_t *current_core,\n      const char *lib_path,\n      void *_lib_handle_p)\n{\n#ifdef HAVE_DYNAMIC\n   /* the library handle for use with the SYMBOL macro */\n   dylib_t lib_handle_local;\n   runloop_state_t *runloop_st = (runloop_state_t*)data;\n#endif\n\n   switch (type)\n   {\n      case CORE_TYPE_PLAIN:\n         {\n#ifdef HAVE_DYNAMIC\n#ifdef HAVE_RUNAHEAD\n            dylib_t *lib_handle_p = (dylib_t*)_lib_handle_p;\n            if (!lib_path || !lib_handle_p)\n#endif\n            {\n               const char *path = path_get(RARCH_PATH_CORE);\n\n               if (string_is_empty(path))\n               {\n                  RARCH_ERR(\"[Core]: Frontend is built for dynamic libretro cores, but \"\n                        \"path is not set. Cannot continue.\\n\");\n                  retroarch_fail(1, \"init_libretro_symbols()\");\n               }\n\n               RARCH_LOG(\"[Core]: Loading dynamic libretro core from: \\\"%s\\\"\\n\",\n                     path);\n\n               if (!(runloop_st->lib_handle = load_dynamic_core(\n                           path,\n                           path_get_ptr(RARCH_PATH_CORE),\n                           path_get_realsize(RARCH_PATH_CORE)\n                           )))\n               {\n                  const char *_msg = msg_hash_to_str(MSG_FAILED_TO_OPEN_LIBRETRO_CORE);\n                  RARCH_ERR(\"%s: \\\"%s\\\"\\nError(s): %s\\n\", _msg, path, dylib_error());\n                  runloop_msg_queue_push(_msg, strlen(_msg), 1, 180, true, NULL,\n                        MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n                  return false;\n               }\n               lib_handle_local = runloop_st->lib_handle;\n            }\n#ifdef HAVE_RUNAHEAD\n            else\n            {\n               /* for a secondary core, we already have a\n                * primary library loaded, so we can skip\n                * some checks and just load the library */\n               lib_handle_local = dylib_load(lib_path);\n\n               if (!lib_handle_local)\n                  return false;\n               *lib_handle_p = lib_handle_local;\n            }\n#endif\n#endif\n\n            CORE_SYMBOLS(SYMBOL);\n         }\n         break;\n      case CORE_TYPE_DUMMY:\n         CORE_SYMBOLS(SYMBOL_DUMMY);\n         break;\n      case CORE_TYPE_FFMPEG:\n#ifdef HAVE_FFMPEG\n         CORE_SYMBOLS(SYMBOL_FFMPEG);\n#endif\n         break;\n      case CORE_TYPE_MPV:\n#ifdef HAVE_MPV\n         CORE_SYMBOLS(SYMBOL_MPV);\n#endif\n         break;\n      case CORE_TYPE_IMAGEVIEWER:\n#ifdef HAVE_IMAGEVIEWER\n         CORE_SYMBOLS(SYMBOL_IMAGEVIEWER);\n#endif\n         break;\n      case CORE_TYPE_NETRETROPAD:\n#if defined(HAVE_NETWORKING) && defined(HAVE_NETWORKGAMEPAD)\n         CORE_SYMBOLS(SYMBOL_NETRETROPAD);\n#endif\n         break;\n      case CORE_TYPE_VIDEO_PROCESSOR:\n#if defined(HAVE_VIDEOPROCESSOR)\n         CORE_SYMBOLS(SYMBOL_VIDEOPROCESSOR);\n#endif\n         break;\n   }\n\n   return true;\n}\n\nuint32_t runloop_get_flags(void)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n   return runloop_st->flags;\n}\n\nvoid runloop_system_info_free(void)\n{\n   runloop_state_t *runloop_st   = &runloop_state;\n   rarch_system_info_t *sys_info = &runloop_st->system;\n\n   if (sys_info->subsystem.data)\n      free(sys_info->subsystem.data);\n   if (sys_info->ports.data)\n      free(sys_info->ports.data);\n   if (sys_info->mmaps.descriptors)\n      free((void *)sys_info->mmaps.descriptors);\n\n   sys_info->subsystem.data                           = NULL;\n   sys_info->subsystem.size                           = 0;\n\n   sys_info->ports.data                               = NULL;\n   sys_info->ports.size                               = 0;\n\n   sys_info->mmaps.descriptors                        = NULL;\n   sys_info->mmaps.num_descriptors                    = 0;\n\n   sys_info->info.library_name                        = NULL;\n   sys_info->info.library_version                     = NULL;\n   sys_info->info.valid_extensions                    = NULL;\n   sys_info->info.need_fullpath                       = false;\n   sys_info->info.block_extract                       = false;\n\n   runloop_st->key_event                              = NULL;\n   runloop_st->frontend_key_event                     = NULL;\n\n   memset(&runloop_st->system, 0, sizeof(rarch_system_info_t));\n}\n\nstatic void runloop_frame_time_free(runloop_state_t *runloop_st)\n{\n   memset(&runloop_st->frame_time, 0,\n         sizeof(struct retro_frame_time_callback));\n   runloop_st->frame_time_last    = 0;\n   runloop_st->max_frames         = 0;\n}\n\nstatic void runloop_audio_buffer_status_free(runloop_state_t *runloop_st)\n{\n   memset(&runloop_st->audio_buffer_status, 0,\n         sizeof(struct retro_audio_buffer_status_callback));\n   runloop_st->audio_latency = 0;\n}\n\nstatic void runloop_fastmotion_override_free(runloop_state_t *runloop_st)\n{\n   video_driver_state_t\n      *video_st            = video_state_get_ptr();\n   settings_t *settings    = config_get_ptr();\n   float fastforward_ratio = settings->floats.fastforward_ratio;\n   bool reset_frame_limit  = runloop_st->fastmotion_override.current.fastforward\n         && (runloop_st->fastmotion_override.current.ratio >= 0.0f)\n         && (runloop_st->fastmotion_override.current.ratio != fastforward_ratio);\n\n   runloop_st->fastmotion_override.current.ratio          = 0.0f;\n   runloop_st->fastmotion_override.current.fastforward    = false;\n   runloop_st->fastmotion_override.current.notification   = false;\n   runloop_st->fastmotion_override.current.inhibit_toggle = false;\n\n   runloop_st->fastmotion_override.next.ratio             = 0.0f;\n   runloop_st->fastmotion_override.next.fastforward       = false;\n   runloop_st->fastmotion_override.next.notification      = false;\n   runloop_st->fastmotion_override.next.inhibit_toggle    = false;\n\n   runloop_st->fastmotion_override.pending                = false;\n\n   if (reset_frame_limit)\n      runloop_set_frame_limit(&video_st->av_info, fastforward_ratio);\n}\n\nvoid runloop_state_free(runloop_state_t *runloop_st)\n{\n   runloop_frame_time_free(runloop_st);\n   runloop_audio_buffer_status_free(runloop_st);\n   input_game_focus_free();\n   runloop_fastmotion_override_free(runloop_st);\n\n   /* Only a single core options callback is used at present */\n   runloop_st->core_options_callback.update_display = NULL;\n\n   runloop_st->video_swap_interval_auto             = 1;\n}\n\n/**\n * uninit_libretro_symbols:\n *\n * Frees libretro core.\n *\n * Frees all core options, associated state, and\n * unbinds all libretro callback symbols.\n **/\nstatic void uninit_libretro_symbols(\n      struct retro_core_t *current_core)\n{\n   runloop_state_t *runloop_st          = &runloop_state;\n   input_driver_state_t *input_st       = input_state_get_ptr();\n   audio_driver_state_t *audio_st       = audio_state_get_ptr();\n   camera_driver_state_t *camera_st     = camera_state_get_ptr();\n   location_driver_state_t *location_st = location_state_get_ptr();\n#ifdef HAVE_DYNAMIC\n   if (runloop_st->lib_handle)\n      dylib_close(runloop_st->lib_handle);\n   runloop_st->lib_handle = NULL;\n#endif\n\n   memset(current_core, 0, sizeof(struct retro_core_t));\n\n   runloop_st->flags &= ~RUNLOOP_FLAG_CORE_SET_SHARED_CONTEXT;\n\n   if (runloop_st->core_options)\n   {\n      runloop_deinit_core_options(\n            (runloop_st->flags & RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE) ? true : false,\n            path_get(RARCH_PATH_CORE_OPTIONS),\n            runloop_st->core_options);\n      runloop_st->flags                &=\n                  ~(RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE\n                  | RUNLOOP_FLAG_FOLDER_OPTIONS_ACTIVE);\n      runloop_st->core_options          = NULL;\n   }\n   runloop_system_info_free();\n   audio_st->callback.callback                   = NULL;\n   audio_st->callback.set_state                  = NULL;\n   runloop_state_free(runloop_st);\n   camera_st->active                             = false;\n   location_st->active                           = false;\n\n   /* Core has finished utilising the input driver;\n    * reset 'analog input requested' flags */\n   memset(&input_st->analog_requested, 0,\n         sizeof(input_st->analog_requested));\n\n   /* Performance counters no longer valid. */\n   runloop_st->perf_ptr_libretro  = 0;\n   memset(runloop_st->perf_counters_libretro, 0,\n         sizeof(runloop_st->perf_counters_libretro));\n}\n\n\nstatic retro_time_t runloop_core_runtime_tick(\n      runloop_state_t *runloop_st,\n      float slowmotion_ratio,\n      retro_time_t current_time)\n{\n   video_driver_state_t *video_st       = video_state_get_ptr();\n   retro_time_t frame_time              =\n      (1.0 / video_st->av_info.timing.fps) * 1000000;\n   bool runloop_slowmotion              = (runloop_st->flags & RUNLOOP_FLAG_SLOWMOTION) ? true : false;\n   bool runloop_fastmotion              = (runloop_st->flags & RUNLOOP_FLAG_FASTMOTION) ? true : false;\n\n   /* Account for slow motion */\n   if (runloop_slowmotion)\n      return (retro_time_t)((double)frame_time * slowmotion_ratio);\n\n   /* Account for fast forward */\n   if (runloop_fastmotion)\n   {\n      /* Doing it this way means we miss the first frame after\n       * turning fast forward on, but it saves the overhead of\n       * having to do:\n       *    retro_time_t current_usec = cpu_features_get_time_usec();\n       *    core_runtime_last         = current_usec;\n       * every frame when fast forward is off. */\n      retro_time_t current_usec              = current_time;\n      retro_time_t potential_frame_time      = current_usec -\n         runloop_st->core_runtime_last;\n      runloop_st->core_runtime_last          = current_usec;\n\n      if (potential_frame_time < frame_time)\n         return potential_frame_time;\n   }\n\n   return frame_time;\n}\n\nstatic bool core_unload_game(void)\n{\n   runloop_state_t *runloop_st    = &runloop_state;\n   video_driver_state_t *video_st = video_state_get_ptr();\n\n   video_driver_free_hw_context();\n\n   video_st->frame_cache_data     = NULL;\n\n   if ((runloop_st->current_core.flags & RETRO_CORE_FLAG_GAME_LOADED))\n   {\n      RARCH_LOG(\"[Core]: Unloading game..\\n\");\n      runloop_st->current_core.retro_unload_game();\n      runloop_st->core_poll_type_override  = POLL_TYPE_OVERRIDE_DONTCARE;\n      runloop_st->current_core.flags      &= ~RETRO_CORE_FLAG_GAME_LOADED;\n   }\n\n   audio_driver_stop();\n\n#ifdef HAVE_MICROPHONE\n   microphone_driver_stop();\n#endif\n\n   return true;\n}\n\nstatic void runloop_apply_fastmotion_override(runloop_state_t *runloop_st, settings_t *settings)\n{\n   float fastforward_ratio_current;\n   video_driver_state_t *video_st                     = video_state_get_ptr();\n   bool frame_time_counter_reset_after_fastforwarding = settings ?\n         settings->bools.frame_time_counter_reset_after_fastforwarding : false;\n   float fastforward_ratio_default                    = settings ?\n         settings->floats.fastforward_ratio : 0.0f;\n   float fastforward_ratio_last                       =\n                     (runloop_st->fastmotion_override.current.fastforward\n                  && (runloop_st->fastmotion_override.current.ratio >= 0.0f)) ?\n                        runloop_st->fastmotion_override.current.ratio :\n                              fastforward_ratio_default;\n#if defined(HAVE_GFX_WIDGETS)\n   dispgfx_widget_t *p_dispwidget                     = dispwidget_get_ptr();\n#endif\n\n   memcpy(&runloop_st->fastmotion_override.current,\n         &runloop_st->fastmotion_override.next,\n         sizeof(runloop_st->fastmotion_override.current));\n\n   /* Check if 'fastmotion' state has changed */\n   if (((runloop_st->flags & RUNLOOP_FLAG_FASTMOTION) > 0) !=\n         runloop_st->fastmotion_override.current.fastforward)\n   {\n      input_driver_state_t *input_st = input_state_get_ptr();\n      if (runloop_st->fastmotion_override.current.fastforward)\n         runloop_st->flags |=  RUNLOOP_FLAG_FASTMOTION;\n      else\n         runloop_st->flags &= ~RUNLOOP_FLAG_FASTMOTION;\n\n      if (input_st)\n      {\n         if (runloop_st->flags & RUNLOOP_FLAG_FASTMOTION)\n            input_st->flags |=  INP_FLAG_NONBLOCKING;\n         else\n            input_st->flags &= ~INP_FLAG_NONBLOCKING;\n      }\n\n      if (!(runloop_st->flags & RUNLOOP_FLAG_FASTMOTION))\n         runloop_st->fastforward_after_frames = 1;\n\n      driver_set_nonblock_state();\n\n      /* Reset frame time counter when toggling\n       * fast-forward off, if required */\n      if ( !(runloop_st->flags & RUNLOOP_FLAG_FASTMOTION)\n          && frame_time_counter_reset_after_fastforwarding)\n         video_st->frame_time_count = 0;\n\n      /* Ensure fast forward widget is disabled when\n       * toggling fast-forward off\n       * (required if RETRO_ENVIRONMENT_SET_FASTFORWARDING_OVERRIDE\n       * is called during core de-initialisation) */\n#if defined(HAVE_GFX_WIDGETS)\n      if (      p_dispwidget->active\n            && !(runloop_st->flags & RUNLOOP_FLAG_FASTMOTION))\n         video_st->flags &= ~VIDEO_FLAG_WIDGETS_FAST_FORWARD;\n#endif\n   }\n\n   /* Update frame limit, if required */\n   fastforward_ratio_current = (runloop_st->fastmotion_override.current.fastforward\n         && (runloop_st->fastmotion_override.current.ratio >= 0.0f)) ?\n               runloop_st->fastmotion_override.current.ratio :\n                     fastforward_ratio_default;\n\n   if (fastforward_ratio_current != fastforward_ratio_last)\n      runloop_set_frame_limit(&video_st->av_info,\n            fastforward_ratio_current);\n}\n\nvoid runloop_event_deinit_core(void)\n{\n   video_driver_state_t\n      *video_st                = video_state_get_ptr();\n   runloop_state_t *runloop_st = &runloop_state;\n   settings_t        *settings = config_get_ptr();\n\n   core_unload_game();\n\n   video_st->frame_cache_data  = NULL;\n\n   if (runloop_st->current_core.flags & RETRO_CORE_FLAG_INITED)\n   {\n      RARCH_LOG(\"[Core]: Unloading core..\\n\");\n      runloop_st->current_core.retro_deinit();\n   }\n\n   /* retro_deinit() may call\n    * RETRO_ENVIRONMENT_SET_FASTFORWARDING_OVERRIDE\n    * (i.e. to ensure that fastforwarding is\n    * disabled on core close)\n    * > Check for any pending updates */\n   if (runloop_st->fastmotion_override.pending)\n   {\n      runloop_apply_fastmotion_override(runloop_st,\n            settings);\n      runloop_st->fastmotion_override.pending = false;\n   }\n\n   if (     (runloop_st->flags & RUNLOOP_FLAG_REMAPS_CORE_ACTIVE)\n         || (runloop_st->flags & RUNLOOP_FLAG_REMAPS_CONTENT_DIR_ACTIVE)\n         || (runloop_st->flags & RUNLOOP_FLAG_REMAPS_GAME_ACTIVE)\n         || !string_is_empty(runloop_st->name.remapfile)\n      )\n   {\n      input_remapping_deinit(settings->bools.remap_save_on_exit);\n      input_remapping_set_defaults(true);\n   }\n   else\n      input_remapping_restore_global_config(true, false);\n\n   RARCH_LOG(\"[Core]: Unloading core symbols..\\n\");\n   uninit_libretro_symbols(&runloop_st->current_core);\n   runloop_st->current_core.flags &= ~RETRO_CORE_FLAG_SYMBOLS_INITED;\n\n   /* Restore original refresh rate, if it has been changed\n    * automatically in SET_SYSTEM_AV_INFO */\n   if (video_st->video_refresh_rate_original)\n      video_display_server_restore_refresh_rate();\n\n   /* Recalibrate frame delay target */\n   if (settings->bools.video_frame_delay_auto)\n      video_st->frame_delay_target = 0;\n\n   driver_uninit(DRIVERS_CMD_ALL, 0);\n\n#ifdef HAVE_CONFIGFILE\n   if (runloop_st->flags & RUNLOOP_FLAG_OVERRIDES_ACTIVE)\n   {\n      /* Reload the original config */\n      config_unload_override();\n   }\n#endif\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n   runloop_st->runtime_shader_preset_path[0] = '\\0';\n#endif\n#ifdef HAVE_NETWORKING\n   netplay_driver_ctl(RARCH_NETPLAY_CTL_SET_CORE_PACKET_INTERFACE, NULL);\n#endif\n}\n\nstatic bool runloop_path_init_subsystem(runloop_state_t *runloop_st)\n{\n   unsigned i, j;\n   const struct retro_subsystem_info *info = NULL;\n   rarch_system_info_t           *sys_info = &runloop_st->system;\n   bool subsystem_path_empty               = path_is_empty(RARCH_PATH_SUBSYSTEM);\n   const char                *savefile_dir = runloop_st->savefile_dir;\n\n   if (!sys_info || subsystem_path_empty)\n      return false;\n\n   /* For subsystems, we know exactly which RAM types are supported. */\n   /* We'll handle this error gracefully later. */\n   if ((info = libretro_find_subsystem_info(\n         sys_info->subsystem.data,\n         sys_info->subsystem.size,\n         path_get(RARCH_PATH_SUBSYSTEM))))\n   {\n      unsigned num_content = MIN(info->num_roms,\n            subsystem_path_empty\n            ? 0\n            : (unsigned)runloop_st->subsystem_fullpaths->size);\n\n      for (i = 0; i < num_content; i++)\n      {\n         for (j = 0; j < info->roms[i].num_memory; j++)\n         {\n            char ext[32];\n            union string_list_elem_attr attr;\n            char savename[NAME_MAX_LENGTH];\n            char path[PATH_MAX_LENGTH];\n            size_t _len = 0;\n            const struct retro_subsystem_memory_info *mem =\n               (const struct retro_subsystem_memory_info*)\n               &info->roms[i].memory[j];\n            ext[  _len]  = '.';\n            ext[++_len]  = '\\0';\n            strlcpy(ext + _len, mem->extension, sizeof(ext) - _len);\n            fill_pathname(savename,\n                  runloop_st->subsystem_fullpaths->elems[i].data, \"\",\n                  sizeof(savename));\n\n            if (path_is_directory(savefile_dir))\n            {\n               /* Use SRAM dir */\n               /* Redirect content fullpath to save directory. */\n               strlcpy(path, savefile_dir, sizeof(path));\n               fill_pathname_dir(path, savename, ext, sizeof(path));\n            }\n            else\n               fill_pathname(path, savename, ext, sizeof(path));\n\n            RARCH_LOG(\"%s \\\"%s\\\".\\n\",\n               msg_hash_to_str(MSG_REDIRECTING_SAVEFILE_TO),\n               path);\n\n            attr.i = mem->type;\n            string_list_append((struct string_list*)savefile_ptr_get(),\n                  path, attr);\n         }\n      }\n   }\n\n   /* Let other relevant paths be inferred\n      from the main SRAM location. */\n   if (!retroarch_override_setting_is_set(\n            RARCH_OVERRIDE_SETTING_SAVE_PATH, NULL))\n      fill_pathname(runloop_st->name.savefile,\n            runloop_st->runtime_content_path_basename,\n            \".srm\",\n            sizeof(runloop_st->name.savefile));\n\n   if (path_is_directory(runloop_st->name.savefile))\n   {\n      fill_pathname_dir(runloop_st->name.savefile,\n            runloop_st->runtime_content_path_basename,\n            \".srm\",\n            sizeof(runloop_st->name.savefile));\n      RARCH_LOG(\"%s \\\"%s\\\".\\n\",\n            msg_hash_to_str(MSG_REDIRECTING_SAVEFILE_TO),\n            runloop_st->name.savefile);\n   }\n\n   return true;\n}\n\nstatic void runloop_path_init_savefile_internal(runloop_state_t *runloop_st)\n{\n   path_deinit_savefile();\n   path_init_savefile_new();\n   if (!runloop_path_init_subsystem(runloop_st))\n      path_init_savefile_rtc(runloop_st->name.savefile);\n}\n\nstatic void runloop_path_init_savefile(runloop_state_t *runloop_st)\n{\n   bool    should_sram_be_used =\n          (runloop_st->flags & RUNLOOP_FLAG_USE_SRAM)\n      && !(runloop_st->flags & RUNLOOP_FLAG_IS_SRAM_SAVE_DISABLED);\n\n   if (should_sram_be_used)\n      runloop_st->flags |=  RUNLOOP_FLAG_USE_SRAM;\n   else\n      runloop_st->flags &= ~RUNLOOP_FLAG_USE_SRAM;\n\n   if (!(runloop_st->flags & RUNLOOP_FLAG_USE_SRAM))\n   {\n      RARCH_LOG(\"[SRAM]: %s\\n\",\n            msg_hash_to_str(MSG_SRAM_WILL_NOT_BE_SAVED));\n      return;\n   }\n\n   command_event(CMD_EVENT_AUTOSAVE_INIT, NULL);\n}\n\nstatic bool event_init_content(\n      runloop_state_t *runloop_st,\n      settings_t *settings,\n      input_driver_state_t *input_st)\n{\n#ifdef HAVE_CHEEVOS\n   bool cheevos_enable                          =\n      settings->bools.cheevos_enable;\n   bool cheevos_hardcore_mode_enable            =\n      settings->bools.cheevos_hardcore_mode_enable;\n#endif\n   const enum rarch_core_type current_core_type = runloop_st->current_core_type;\n   uint8_t flags                                = content_get_flags();\n\n   if (current_core_type == CORE_TYPE_PLAIN)\n      runloop_st->flags |=  RUNLOOP_FLAG_USE_SRAM;\n   else\n      runloop_st->flags &= ~RUNLOOP_FLAG_USE_SRAM;\n\n   /* No content to be loaded for dummy core,\n    * just successfully exit. */\n   if (current_core_type == CORE_TYPE_DUMMY)\n      return true;\n\n   content_set_subsystem_info();\n\n   if (flags & CONTENT_ST_FLAG_CORE_DOES_NOT_NEED_CONTENT)\n      runloop_path_init_savefile_internal(runloop_st);\n\n   runloop_path_fill_names();\n\n   if (!content_init())\n      return false;\n\n   command_event_set_savestate_auto_index(settings);\n   command_event_set_replay_auto_index(settings);\n\n   runloop_path_init_savefile(runloop_st);\n\n   if (!event_load_save_files(runloop_st->flags &\n            RUNLOOP_FLAG_IS_SRAM_LOAD_DISABLED))\n      RARCH_LOG(\"[SRAM]: %s\\n\",\n            msg_hash_to_str(MSG_SKIPPING_SRAM_LOAD));\n\n/*\n   Since the operations are asynchronous we can't\n   guarantee users will not use auto_load_state to cheat on\n   achievements so we forbid auto_load_state from happening\n   if cheevos_enable and cheevos_hardcode_mode_enable\n   are true.\n*/\n#ifdef HAVE_CHEEVOS\n   if (     !cheevos_enable\n         || !cheevos_hardcore_mode_enable)\n#endif\n   {\n#ifdef HAVE_BSV_MOVIE\n     /* ignore entry state if we're doing bsv playback (we do want it\n        for bsv recording though) */\n     if (!(input_st->bsv_movie_state.flags & BSV_FLAG_MOVIE_START_PLAYBACK))\n#endif\n      {\n         if (      runloop_st->entry_state_slot\n               && !command_event_load_entry_state(settings))\n         {\n           /* loading the state failed, reset entry slot */\n            runloop_st->entry_state_slot = 0;\n         }\n      }\n#ifdef HAVE_BSV_MOVIE\n     /* ignore autoload state if we're doing bsv playback or recording */\n     if (!(input_st->bsv_movie_state.flags & (BSV_FLAG_MOVIE_START_RECORDING | BSV_FLAG_MOVIE_START_PLAYBACK)))\n#endif\n      {\n        if (!runloop_st->entry_state_slot && settings->bools.savestate_auto_load)\n          command_event_load_auto_state();\n      }\n   }\n\n#ifdef HAVE_BSV_MOVIE\n   movie_stop(input_st);\n   if (input_st->bsv_movie_state.flags & BSV_FLAG_MOVIE_START_RECORDING)\n   {\n     configuration_set_uint(settings, settings->uints.rewind_granularity, 1);\n#ifndef HAVE_THREADS\n     /* Hack: the regular scheduler doesn't do the right thing here at\n        least in emscripten builds.  I would expect that the check in\n        task_movie.c:343 should defer recording until the movie task\n        is done, but maybe that task isn't enqueued again yet when the\n        movie-record task is checked?  Or the finder call in\n        content_load_state_in_progress is not correct?  Either way,\n        the load happens after the recording starts rather than the\n        right way around.\n     */\n     task_queue_wait(NULL,NULL);\n#endif\n     movie_start_record(input_st, input_st->bsv_movie_state.movie_start_path);\n   }\n   else if (input_st->bsv_movie_state.flags & BSV_FLAG_MOVIE_START_PLAYBACK)\n   {\n     configuration_set_uint(settings, settings->uints.rewind_granularity, 1);\n     movie_start_playback(input_st, input_st->bsv_movie_state.movie_start_path);\n   }\n#endif\n\n   command_event(CMD_EVENT_NETPLAY_INIT, NULL);\n\n   return true;\n}\n\nstatic void runloop_runtime_log_init(runloop_state_t *runloop_st)\n{\n   const char *content_path            = path_get(RARCH_PATH_CONTENT);\n   const char *core_path               = path_get(RARCH_PATH_CORE);\n\n   runloop_st->core_runtime_last       = cpu_features_get_time_usec();\n   runloop_st->core_runtime_usec       = 0;\n\n   /* Have to cache content and core path here, otherwise\n    * logging fails if new content is loaded without\n    * closing existing content\n    * i.e. RARCH_PATH_CONTENT and RARCH_PATH_CORE get\n    * updated when the new content is loaded, which\n    * happens *before* command_event_runtime_log_deinit\n    * -> using RARCH_PATH_CONTENT and RARCH_PATH_CORE\n    *    directly in command_event_runtime_log_deinit\n    *    can therefore lead to the runtime of the currently\n    *    loaded content getting written to the *new*\n    *    content's log file... */\n   memset(runloop_st->runtime_content_path,\n         0, sizeof(runloop_st->runtime_content_path));\n   memset(runloop_st->runtime_core_path,\n         0, sizeof(runloop_st->runtime_core_path));\n\n   if (!string_is_empty(content_path))\n      strlcpy(runloop_st->runtime_content_path,\n            content_path,\n            sizeof(runloop_st->runtime_content_path));\n\n   if (!string_is_empty(core_path))\n      strlcpy(runloop_st->runtime_core_path,\n            core_path,\n            sizeof(runloop_st->runtime_core_path));\n}\n\nvoid runloop_set_frame_limit(\n      const struct retro_system_av_info *av_info,\n      float fastforward_ratio)\n{\n   runloop_state_t *runloop_st  = &runloop_state;\n   if (fastforward_ratio < 1.0f)\n      runloop_st->frame_limit_minimum_time = 0.0f;\n   else\n      runloop_st->frame_limit_minimum_time = (retro_time_t)\n         roundf(1000000.0f /\n               (av_info->timing.fps * fastforward_ratio));\n}\n\nfloat runloop_get_fastforward_ratio(\n      settings_t *settings,\n      struct retro_fastforwarding_override *fastmotion_override)\n{\n   if (      fastmotion_override->fastforward\n         && (fastmotion_override->ratio >= 0.0f))\n      return fastmotion_override->ratio;\n   return settings->floats.fastforward_ratio;\n}\n\nvoid runloop_set_video_swap_interval(\n      bool vrr_runloop_enable,\n      bool crt_switching_active,\n      unsigned swap_interval_config,\n      unsigned black_frame_insertion,\n      unsigned shader_subframes,\n      float audio_max_timing_skew,\n      float video_refresh_rate,\n      double input_fps)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n   float core_hz               = input_fps;\n   float timing_hz             = crt_switching_active ?\n         input_fps : video_refresh_rate;\n   float swap_ratio;\n   unsigned swap_integer;\n   float timing_skew;\n\n   /* If automatic swap interval selection is\n    * disabled, just record user-set value */\n   if (swap_interval_config != 0)\n   {\n      runloop_st->video_swap_interval_auto =\n            swap_interval_config;\n      return;\n   }\n\n   /* > If VRR is enabled, swap interval is irrelevant,\n    *   just set to 1\n    * > If core fps is higher than display refresh rate,\n    *   set swap interval to 1\n    * > If core fps or display refresh rate are zero,\n    *   set swap interval to 1\n    * > If BFI is active set swap interval to 1\n    * > If Shader Subframes active, set swap interval to 1 */\n   if (   (vrr_runloop_enable)\n       || (core_hz    > timing_hz)\n       || (core_hz   <= 0.0f)\n       || (timing_hz <= 0.0f)\n       || (black_frame_insertion)\n       || (shader_subframes > 1))\n   {\n      runloop_st->video_swap_interval_auto = 1;\n      return;\n   }\n\n   /* Check whether display refresh rate is an integer\n    * multiple of core fps (within timing skew tolerance) */\n   swap_ratio   = timing_hz / core_hz;\n   swap_integer = (unsigned)(swap_ratio + 0.5f);\n\n   /* > Sanity check: swap interval must be in the\n    *   range [1,4] - if we are outside this, then\n    *   bail... */\n   if ((swap_integer < 1) || (swap_integer > 4))\n   {\n      runloop_st->video_swap_interval_auto = 1;\n      return;\n   }\n\n   timing_skew = fabs(1.0f - core_hz / (timing_hz / (float)swap_integer));\n\n   runloop_st->video_swap_interval_auto =\n         (timing_skew <= audio_max_timing_skew) ?\n               swap_integer : 1;\n}\n\nunsigned runloop_get_video_swap_interval(\n      unsigned swap_interval_config)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n   return (swap_interval_config == 0) ?\n         runloop_st->video_swap_interval_auto :\n         swap_interval_config;\n}\n\n/*\n   Returns rotation requested by the core regardless of if it has been\n   applied with the final video rotation\n*/\nunsigned int retroarch_get_core_requested_rotation(void)\n{\n   return runloop_state.system.core_requested_rotation;\n}\n\n/*\n   Returns final rotation including both user chosen video rotation\n   and core requested rotation if allowed by video_allow_rotate\n*/\nunsigned int retroarch_get_rotation(void)\n{\n   settings_t     *settings    = config_get_ptr();\n   return settings->uints.video_rotation + runloop_state.system.rotation;\n}\n\nstatic void retro_run_null(void) { } /* Stub function callback impl. */\n\nstatic bool core_verify_api_version(runloop_state_t *runloop_st)\n{\n   unsigned api_version        = runloop_st->current_core.retro_api_version();\n   if (api_version != RETRO_API_VERSION)\n   {\n      RARCH_WARN(\"[Core]: %s\\n\", msg_hash_to_str(MSG_LIBRETRO_ABI_BREAK));\n      return false;\n   }\n   RARCH_LOG(\"[Core]: %s: %u, %s: %u\\n\",\n         msg_hash_to_str(MSG_VERSION_OF_LIBRETRO_API),\n         api_version,\n         msg_hash_to_str(MSG_COMPILED_AGAINST_API),\n         RETRO_API_VERSION\n         );\n   return true;\n}\n\nstatic int16_t core_input_state_poll_late(unsigned port,\n      unsigned device, unsigned idx, unsigned id)\n{\n   runloop_state_t     *runloop_st       = &runloop_state;\n   if (!(runloop_st->current_core.flags & RETRO_CORE_FLAG_INPUT_POLLED))\n      input_driver_poll();\n   runloop_st->current_core.flags       |= RETRO_CORE_FLAG_INPUT_POLLED;\n\n   return input_driver_state_wrapper(port, device, idx, id);\n}\n\nstatic void core_input_state_poll_maybe(void)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n   const enum poll_type_override_t\n      core_poll_type_override  = runloop_st->core_poll_type_override;\n   unsigned new_poll_type      = (core_poll_type_override > POLL_TYPE_OVERRIDE_DONTCARE)\n      ? (core_poll_type_override - 1)\n      : runloop_st->current_core.poll_type;\n   if (new_poll_type == POLL_TYPE_NORMAL)\n      input_driver_poll();\n}\n\n\nstatic retro_input_state_t core_input_state_poll_return_cb(void)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n   const enum poll_type_override_t\n      core_poll_type_override  = runloop_st->core_poll_type_override;\n   unsigned new_poll_type      = (core_poll_type_override > POLL_TYPE_OVERRIDE_DONTCARE)\n      ? (core_poll_type_override - 1)\n      : runloop_st->current_core.poll_type;\n   if (new_poll_type == POLL_TYPE_LATE)\n      return core_input_state_poll_late;\n   return input_driver_state_wrapper;\n}\n\n\n/**\n * core_init_libretro_cbs:\n * @data           : pointer to retro_callbacks object\n *\n * Initializes libretro callbacks, and binds the libretro callbacks\n * to default callback functions.\n **/\nstatic void core_init_libretro_cbs(runloop_state_t *runloop_st,\n      struct retro_callbacks *cbs)\n{\n   retro_input_state_t state_cb = core_input_state_poll_return_cb();\n\n   runloop_st->current_core.retro_set_video_refresh(video_driver_frame);\n   runloop_st->current_core.retro_set_audio_sample(audio_driver_sample);\n   runloop_st->current_core.retro_set_audio_sample_batch(audio_driver_sample_batch);\n   runloop_st->current_core.retro_set_input_state(state_cb);\n   runloop_st->current_core.retro_set_input_poll(core_input_state_poll_maybe);\n\n   runloop_st->input_poll_callback_original    = core_input_state_poll_maybe;\n\n   core_set_default_callbacks(cbs);\n\n#ifdef HAVE_NETWORKING\n   if (netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_DATA_INITED, NULL))\n      core_set_netplay_callbacks();\n#endif\n}\n\n\nstatic bool runloop_event_load_core(runloop_state_t *runloop_st,\n      unsigned poll_type_behavior)\n{\n   video_driver_state_t *video_st     = video_state_get_ptr();\n   runloop_st->current_core.poll_type = poll_type_behavior;\n\n   if (!core_verify_api_version(runloop_st))\n      return false;\n   core_init_libretro_cbs(runloop_st, &runloop_st->retro_ctx);\n\n   runloop_st->current_core.retro_get_system_av_info(&video_st->av_info);\n\n   RARCH_LOG(\"[Core]: Geometry: %ux%u, Aspect: %.3f, FPS: %.2f, Sample rate: %.2f Hz.\\n\",\n         video_st->av_info.geometry.base_width, video_st->av_info.geometry.base_height,\n         video_st->av_info.geometry.aspect_ratio,\n         video_st->av_info.timing.fps,\n         video_st->av_info.timing.sample_rate);\n\n   return true;\n}\n\nbool runloop_event_init_core(\n      settings_t *settings,\n      void *input_data,\n      enum rarch_core_type type,\n      const char *old_savefile_dir,\n      const char *old_savestate_dir)\n{\n   size_t _len;\n   runloop_state_t *runloop_st     = &runloop_state;\n   input_driver_state_t *input_st  = (input_driver_state_t*)input_data;\n   video_driver_state_t *video_st  = video_state_get_ptr();\n#ifdef HAVE_CONFIGFILE\n   bool auto_overrides_enable      = settings->bools.auto_overrides_enable;\n   bool auto_remaps_enable         = false;\n   const char *dir_input_remapping = NULL;\n#endif\n   bool initial_disk_change_enable = true;\n   bool show_set_initial_disk_msg  = false;\n   unsigned poll_type_behavior     = 0;\n   float fastforward_ratio         = 0.0f;\n   rarch_system_info_t *sys_info   = &runloop_st->system;\n\n#ifdef HAVE_NETWORKING\n   if (netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_ENABLED, NULL))\n   {\n      /* We need this in order for core_info_current_supports_netplay\n         to work correctly at init_netplay,\n         called later at event_init_content. */\n      command_event(CMD_EVENT_CORE_INFO_INIT, NULL);\n      command_event(CMD_EVENT_LOAD_CORE_PERSIST, NULL);\n   }\n#endif\n\n   /* Load symbols */\n   if (!runloop_init_libretro_symbols(runloop_st,\n            type, &runloop_st->current_core, NULL, NULL))\n      return false;\n#ifdef HAVE_RUNAHEAD\n   /* Remember last core type created, so creating a\n    * secondary core will know what core type to use. */\n   runloop_st->last_core_type              = type;\n#endif\n   if (!runloop_st->current_core.retro_run)\n      runloop_st->current_core.retro_run   = retro_run_null;\n   runloop_st->current_core.flags         |= RETRO_CORE_FLAG_SYMBOLS_INITED;\n   runloop_st->current_core.retro_get_system_info(&sys_info->info);\n\n   if (!sys_info->info.library_name)\n      sys_info->info.library_name = msg_hash_to_str(MSG_UNKNOWN);\n   if (!sys_info->info.library_version)\n      sys_info->info.library_version = \"v0\";\n\n   _len = strlcpy(\n         video_st->title_buf,\n         msg_hash_to_str(MSG_PROGRAM),\n         sizeof(video_st->title_buf));\n\n   if (!string_is_empty(sys_info->info.library_name))\n   {\n      video_st->title_buf[  _len] = ' ';\n      video_st->title_buf[++_len] = '\\0';\n      _len += strlcpy(video_st->title_buf + _len,\n            sys_info->info.library_name,\n            sizeof(video_st->title_buf)   - _len);\n   }\n\n   if (!string_is_empty(sys_info->info.library_version))\n   {\n      video_st->title_buf[  _len] = ' ';\n      video_st->title_buf[++_len] = '\\0';\n      strlcpy(video_st->title_buf        + _len,\n            sys_info->info.library_version,\n            sizeof(video_st->title_buf)  - _len);\n   }\n\n   if (!sys_info->info.valid_extensions)\n   strlcpy(sys_info->valid_extensions, DEFAULT_EXT,\n         sizeof(sys_info->valid_extensions));\n\n#ifdef HAVE_CONFIGFILE\n   if (auto_overrides_enable)\n      config_load_override(&runloop_st->system);\n#endif\n\n   /* Cannot access these settings-related parameters\n    * until *after* config overrides have been loaded */\n#ifdef HAVE_CONFIGFILE\n   auto_remaps_enable         = settings->bools.auto_remaps_enable;\n   dir_input_remapping        = settings->paths.directory_input_remapping;\n#endif\n   initial_disk_change_enable = settings->bools.initial_disk_change_enable;\n   show_set_initial_disk_msg  = settings->bools.notification_show_set_initial_disk;\n   poll_type_behavior         = settings->uints.input_poll_type_behavior;\n   fastforward_ratio          = runloop_get_fastforward_ratio(\n         settings, &runloop_st->fastmotion_override.current);\n\n#ifdef HAVE_CHEEVOS\n   /* Assume the core supports achievements unless it tells us otherwise */\n   rcheevos_set_support_cheevos(true);\n#endif\n\n   /* Load auto-shaders on the next occasion */\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n   video_st->flags |= VIDEO_FLAG_SHADER_PRESETS_NEED_RELOAD;\n   runloop_st->shader_delay_timer.timer_begin = false; /* not initialized */\n   runloop_st->shader_delay_timer.timer_end   = false; /* not expired */\n#endif\n\n   /* Reset video format to libretro's default */\n   video_st->pix_fmt = RETRO_PIXEL_FORMAT_0RGB1555;\n\n   /* Set save redirection paths */\n   runloop_path_set_redirect(settings, old_savefile_dir, old_savestate_dir);\n\n   /* Set core environment */\n   runloop_st->current_core.retro_set_environment(runloop_environment_cb);\n\n   /* Load any input remap files\n    * > Note that we always cache the current global\n    *   input settings when initialising a core\n    *   (regardless of whether remap files are loaded)\n    *   so settings can be restored when the core is\n    *   unloaded - i.e. core remapping options modified\n    *   at runtime should not 'bleed through' into the\n    *   master config file */\n   input_remapping_cache_global_config();\n#ifdef HAVE_CONFIGFILE\n   if (auto_remaps_enable)\n      config_load_remap(dir_input_remapping, &runloop_st->system);\n#endif\n\n   video_st->frame_cache_data              = NULL;\n\n   runloop_st->current_core.retro_init();\n   runloop_st->current_core.flags         |= RETRO_CORE_FLAG_INITED;\n\n   /* Attempt to set initial disk index */\n   if (initial_disk_change_enable)\n      disk_control_set_initial_index(\n         &sys_info->disk_control,\n         path_get(RARCH_PATH_CONTENT),\n         runloop_st->savefile_dir);\n\n   if (!event_init_content(runloop_st, settings, input_st))\n   {\n      runloop_st->flags &= ~RUNLOOP_FLAG_CORE_RUNNING;\n      return false;\n   }\n\n   /* Verify that initial disk index was set correctly */\n   disk_control_verify_initial_index(&sys_info->disk_control,\n         show_set_initial_disk_msg, initial_disk_change_enable);\n\n   if (!runloop_event_load_core(runloop_st, poll_type_behavior))\n      return false;\n\n   runloop_set_frame_limit(&video_st->av_info, fastforward_ratio);\n   runloop_st->frame_limit_last_time    = cpu_features_get_time_usec();\n\n   runloop_runtime_log_init(runloop_st);\n   return true;\n}\n\nvoid runloop_pause_checks(void)\n{\n#ifdef HAVE_PRESENCE\n   presence_userdata_t userdata;\n#endif\n   video_driver_state_t *video_st = video_state_get_ptr();\n   settings_t *settings           = config_get_ptr();\n   runloop_state_t *runloop_st    = &runloop_state;\n   bool is_paused                 = (runloop_st->flags & RUNLOOP_FLAG_PAUSED) ? true : false;\n   bool is_idle                   = (runloop_st->flags & RUNLOOP_FLAG_IDLE)   ? true : false;\n#if defined(HAVE_GFX_WIDGETS)\n   dispgfx_widget_t *p_dispwidget = dispwidget_get_ptr();\n   bool widgets_active            = p_dispwidget->active;\n   if (widgets_active)\n   {\n      if (is_paused)\n         video_st->flags |=  VIDEO_FLAG_WIDGETS_PAUSED;\n      else\n         video_st->flags &= ~VIDEO_FLAG_WIDGETS_PAUSED;\n   }\n#endif\n\n   if (is_paused)\n   {\n#if defined(HAVE_GFX_WIDGETS)\n      if (!widgets_active)\n#endif\n      {\n         const char *_msg = msg_hash_to_str(MSG_PAUSED);\n         runloop_msg_queue_push(_msg, strlen(_msg), 1, 1, true, NULL,\n               MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n      }\n\n      if (!is_idle)\n         video_driver_cached_frame();\n\n      midi_driver_set_all_sounds_off();\n\n#ifdef HAVE_PRESENCE\n      userdata.status = PRESENCE_GAME_PAUSED;\n      command_event(CMD_EVENT_PRESENCE_UPDATE, &userdata);\n#endif\n\n#ifdef HAVE_LAKKA\n      set_cpu_scaling_signal(CPUSCALING_EVENT_FOCUS_MENU);\n#endif\n\n      /* Limit paused frames to video refresh. */\n      runloop_st->frame_limit_minimum_time = (retro_time_t)roundf(1000000.0f /\n            ((video_st->video_refresh_rate_original)\n               ? video_st->video_refresh_rate_original\n               : settings->floats.video_refresh_rate));\n   }\n   else\n   {\n#ifdef HAVE_LAKKA\n      set_cpu_scaling_signal(CPUSCALING_EVENT_FOCUS_CORE);\n#endif\n\n      /* Restore frame limit. */\n      runloop_set_frame_limit(&video_st->av_info, settings->floats.fastforward_ratio);\n   }\n\n#if defined(HAVE_TRANSLATE) && defined(HAVE_GFX_WIDGETS)\n   if (p_dispwidget->ai_service_overlay_state == 1)\n      gfx_widgets_ai_service_overlay_unload();\n#endif\n\n   /* Signal/reset paused rewind to take the initial step */\n   runloop_st->run_frames_and_pause = -1;\n\n   /* Ignore frame delay target temporarily */\n   video_st->frame_delay_pause      = true;\n}\n\nstruct string_list *path_get_subsystem_list(void)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n   return runloop_st->subsystem_fullpaths;\n}\n\nvoid runloop_path_fill_names(void)\n{\n   runloop_state_t *runloop_st    = &runloop_state;\n#ifdef HAVE_BSV_MOVIE\n   input_driver_state_t *input_st = input_state_get_ptr();\n#endif\n\n   runloop_path_init_savefile_internal(runloop_st);\n\n#ifdef HAVE_BSV_MOVIE\n   strlcpy(input_st->bsv_movie_state.movie_auto_path,\n         runloop_st->name.replay,\n         sizeof(input_st->bsv_movie_state.movie_auto_path));\n#endif\n\n   if (string_is_empty(runloop_st->runtime_content_path_basename))\n      return;\n\n   if (string_is_empty(runloop_st->name.ups))\n    {\n      size_t len = strlcpy(runloop_st->name.ups,\n            runloop_st->runtime_content_path_basename,\n            sizeof(runloop_st->name.ups));\n      strlcpy(runloop_st->name.ups       + len,\n            \".ups\",\n            sizeof(runloop_st->name.ups) - len);\n   }\n\n   if (string_is_empty(runloop_st->name.bps))\n   {\n      size_t len = strlcpy(runloop_st->name.bps,\n            runloop_st->runtime_content_path_basename,\n            sizeof(runloop_st->name.bps));\n      strlcpy(runloop_st->name.bps       + len,\n            \".bps\",\n            sizeof(runloop_st->name.bps) - len);\n   }\n\n   if (string_is_empty(runloop_st->name.ips))\n   {\n      size_t len = strlcpy(runloop_st->name.ips,\n            runloop_st->runtime_content_path_basename,\n            sizeof(runloop_st->name.ips));\n      strlcpy(runloop_st->name.ips       + len,\n            \".ips\",\n            sizeof(runloop_st->name.ips) - len);\n   }\n\n   if (string_is_empty(runloop_st->name.xdelta))\n   {\n      size_t len = strlcpy(runloop_st->name.xdelta,\n            runloop_st->runtime_content_path_basename,\n            sizeof(runloop_st->name.xdelta));\n      strlcpy(runloop_st->name.xdelta       + len,\n            \".xdelta\",\n            sizeof(runloop_st->name.xdelta) - len);\n   }\n}\n\n\n/* Creates folder and core options stub file for subsequent runs */\nbool core_options_create_override(bool game_specific)\n{\n   char options_path[PATH_MAX_LENGTH];\n   runloop_state_t *runloop_st = &runloop_state;\n   const char *_msg            = NULL;\n   config_file_t *conf         = NULL;\n\n   options_path[0]             = '\\0';\n\n   if (game_specific)\n   {\n      /* Get options file path (game-specific) */\n      if (!validate_game_options(\n               runloop_st->system.info.library_name,\n               options_path,\n               sizeof(options_path), true))\n         goto error;\n   }\n   else\n   {\n      /* Sanity check - cannot create a folder-specific\n       * override if a game-specific override is\n       * already active */\n      if (runloop_st->flags & RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE)\n         goto error;\n\n      /* Get options file path (folder-specific) */\n      if (!validate_folder_options(\n               options_path,\n               sizeof(options_path), true))\n         goto error;\n   }\n\n   /* Open config file */\n   if (!(conf = config_file_new_from_path_to_string(options_path)))\n      if (!(conf = config_file_new_alloc()))\n         goto error;\n\n   /* Write config file */\n   core_option_manager_flush(runloop_st->core_options, conf);\n\n   if (!config_file_write(conf, options_path, true))\n      goto error;\n\n   RARCH_LOG(\"[Core]: Core options file created successfully: \\\"%s\\\".\\n\", options_path);\n   _msg = msg_hash_to_str(MSG_CORE_OPTIONS_FILE_CREATED_SUCCESSFULLY);\n   runloop_msg_queue_push(_msg, strlen(_msg), 1, 100, true, NULL,\n         MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n   path_set(RARCH_PATH_CORE_OPTIONS, options_path);\n   if (game_specific)\n   {\n      runloop_st->flags |=  RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE;\n      runloop_st->flags &= ~RUNLOOP_FLAG_FOLDER_OPTIONS_ACTIVE;\n   }\n   else\n   {\n      runloop_st->flags &= ~RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE;\n      runloop_st->flags |=  RUNLOOP_FLAG_FOLDER_OPTIONS_ACTIVE;\n   }\n\n   config_file_free(conf);\n   return true;\n\nerror:\n   _msg = msg_hash_to_str(MSG_ERROR_SAVING_CORE_OPTIONS_FILE);\n   runloop_msg_queue_push(_msg, strlen(_msg), 1, 100, true, NULL,\n         MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n   if (conf)\n      config_file_free(conf);\n\n   return false;\n}\n\nbool core_options_remove_override(bool game_specific)\n{\n   char new_options_path[PATH_MAX_LENGTH];\n   runloop_state_t *runloop_st      = &runloop_state;\n   settings_t *settings             = config_get_ptr();\n   core_option_manager_t *coreopts  = runloop_st->core_options;\n   bool per_core_options            = !settings->bools.global_core_options;\n   const char *path_core_options    = settings->paths.path_core_options;\n   const char *current_options_path = NULL;\n   config_file_t *conf              = NULL;\n   bool folder_options_active       = false;\n\n   new_options_path[0]              = '\\0';\n\n   /* Sanity check 1 - if there are no core options\n    * or no overrides are active, there is nothing to do */\n   if (          !coreopts\n         || (    (!(runloop_st->flags & RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE))\n              && (!(runloop_st->flags & RUNLOOP_FLAG_FOLDER_OPTIONS_ACTIVE))\n      ))\n      return true;\n\n   /* Sanity check 2 - can only remove an override\n    * if the specified type is currently active */\n   if (      game_specific\n         && !(runloop_st->flags & RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE)\n      )\n      goto error;\n\n   /* Get current options file path */\n   current_options_path = path_get(RARCH_PATH_CORE_OPTIONS);\n   if (string_is_empty(current_options_path))\n      goto error;\n\n   /* Remove current options file, if required */\n   if (path_is_valid(current_options_path))\n      filestream_delete(current_options_path);\n\n   /* Reload any existing 'parent' options file\n    * > If we have removed a game-specific config,\n    *   check whether a folder-specific config\n    *   exists */\n   if (   game_specific\n       && validate_folder_options(\n          new_options_path,\n          sizeof(new_options_path), false)\n       && path_is_valid(new_options_path))\n      folder_options_active = true;\n\n   /* > If a folder-specific config does not exist,\n    *   or we removed it, check whether we have a\n    *   top-level config file */\n   if (!folder_options_active)\n   {\n      /* Try core-specific options, if enabled */\n      if (per_core_options)\n      {\n         const char *core_name = runloop_st->system.info.library_name;\n         per_core_options      = validate_per_core_options(\n               new_options_path, sizeof(new_options_path), true,\n                     core_name, core_name);\n      }\n\n      /* ...otherwise use global options */\n      if (!per_core_options)\n      {\n         if (!string_is_empty(path_core_options))\n            strlcpy(new_options_path,\n                  path_core_options, sizeof(new_options_path));\n         else if (!path_is_empty(RARCH_PATH_CONFIG))\n            fill_pathname_resolve_relative(\n                  new_options_path, path_get(RARCH_PATH_CONFIG),\n                        FILE_PATH_CORE_OPTIONS_CONFIG, sizeof(new_options_path));\n      }\n   }\n\n   if (string_is_empty(new_options_path))\n      goto error;\n\n   /* > If we have a valid file, load it */\n   if (   folder_options_active\n       || path_is_valid(new_options_path))\n   {\n      size_t i, j;\n\n      if (!(conf = config_file_new_from_path_to_string(new_options_path)))\n         goto error;\n\n      for (i = 0; i < coreopts->size; i++)\n      {\n         struct config_entry_list *entry = NULL;\n         struct core_option      *option = (struct core_option*)&coreopts->opts[i];\n         if (!option)\n            continue;\n         if (!(entry = config_get_entry(conf, option->key)))\n            continue;\n         if (string_is_empty(entry->value))\n            continue;\n\n         /* Set current config value from file entry */\n         for (j = 0; j < option->vals->size; j++)\n         {\n            if (string_is_equal(option->vals->elems[j].data, entry->value))\n            {\n               option->index = j;\n               break;\n            }\n         }\n      }\n\n      coreopts->updated = true;\n\n#ifdef HAVE_CHEEVOS\n      rcheevos_validate_config_settings();\n#endif\n   }\n\n   /* Update runloop status */\n   if (folder_options_active)\n   {\n      path_set(RARCH_PATH_CORE_OPTIONS, new_options_path);\n      runloop_st->flags &= ~RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE;\n      runloop_st->flags |=  RUNLOOP_FLAG_FOLDER_OPTIONS_ACTIVE;\n   }\n   else\n   {\n      path_clear(RARCH_PATH_CORE_OPTIONS);\n      runloop_st->flags &= ~(RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE\n                           | RUNLOOP_FLAG_FOLDER_OPTIONS_ACTIVE);\n\n      /* Update config file path/object stored in\n       * core option manager struct */\n      strlcpy(coreopts->conf_path, new_options_path,\n            sizeof(coreopts->conf_path));\n\n      if (conf)\n      {\n         config_file_free(coreopts->conf);\n         coreopts->conf = conf;\n         conf           = NULL;\n      }\n   }\n\n\n   {\n      const char *_msg = msg_hash_to_str(MSG_CORE_OPTIONS_FILE_REMOVED_SUCCESSFULLY);\n      runloop_msg_queue_push(_msg, strlen(_msg), 1, 100, true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n   }\n\n   if (conf)\n      config_file_free(conf);\n\n   return true;\n\nerror:\n   {\n      const char *_msg = msg_hash_to_str(MSG_ERROR_REMOVING_CORE_OPTIONS_FILE);\n      runloop_msg_queue_push(_msg, strlen(_msg), 1, 100, true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n   }\n\n   if (conf)\n      config_file_free(conf);\n\n   return false;\n}\n\nvoid core_options_reset(void)\n{\n   size_t i;\n   runloop_state_t *runloop_st     = &runloop_state;\n   core_option_manager_t *coreopts = runloop_st->core_options;\n\n   /* If there are no core options, there\n    * is nothing to do */\n   if (!coreopts || (coreopts->size < 1))\n      return;\n\n   for (i = 0; i < coreopts->size; i++)\n      coreopts->opts[i].index = coreopts->opts[i].default_index;\n\n   coreopts->updated = true;\n\n#ifdef HAVE_CHEEVOS\n   rcheevos_validate_config_settings();\n#endif\n\n   {\n      const char *_msg = msg_hash_to_str(MSG_CORE_OPTIONS_RESET);\n      runloop_msg_queue_push(_msg, strlen(_msg), 1, 100, true, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n   }\n}\n\nvoid core_options_flush(void)\n{\n   size_t _len;\n   char msg[128];\n   runloop_state_t *runloop_st     = &runloop_state;\n   core_option_manager_t *coreopts = runloop_st->core_options;\n   const char *path_core_options   = path_get(RARCH_PATH_CORE_OPTIONS);\n   const char *core_options_file   = NULL;\n   bool success                    = false;\n\n   msg[0] = '\\0';\n\n   /* If there are no core options, there\n    * is nothing to do */\n   if (!coreopts || (coreopts->size < 1))\n      return;\n\n   /* Check whether game/folder-specific options file\n    * is being used */\n   if (!string_is_empty(path_core_options))\n   {\n      config_file_t *conf_tmp = NULL;\n      bool path_valid         = path_is_valid(path_core_options);\n\n      /* Attempt to load existing file */\n      if (path_valid)\n         conf_tmp = config_file_new_from_path_to_string(path_core_options);\n\n      /* Create new file if required */\n      if (!conf_tmp)\n         conf_tmp = config_file_new_alloc();\n\n      if (conf_tmp)\n      {\n         core_option_manager_flush(runloop_st->core_options, conf_tmp);\n\n         success = config_file_write(conf_tmp, path_core_options, true);\n         config_file_free(conf_tmp);\n      }\n   }\n   else\n   {\n      /* We are using the 'default' core options file */\n      path_core_options = runloop_st->core_options->conf_path;\n\n      if (!string_is_empty(path_core_options))\n      {\n         core_option_manager_flush(\n               runloop_st->core_options,\n               runloop_st->core_options->conf);\n\n         /* We must *guarantee* that a file gets written\n          * to disk if any options differ from the current\n          * options file contents. Must therefore handle\n          * the case where the 'default' file does not\n          * exist (e.g. if it gets deleted manually while\n          * a core is running) */\n         if (!path_is_valid(path_core_options))\n            runloop_st->core_options->conf->flags |= CONF_FILE_FLG_MODIFIED;\n\n         success = config_file_write(runloop_st->core_options->conf,\n               path_core_options, true);\n      }\n   }\n\n   /* Get options file name for display purposes */\n   if (!string_is_empty(path_core_options))\n      core_options_file = path_basename_nocompression(path_core_options);\n\n   if (string_is_empty(core_options_file))\n      core_options_file = msg_hash_to_str(MENU_ENUM_LABEL_VALUE_UNKNOWN);\n\n   if (success)\n   {\n      /* Log result */\n      _len = strlcpy(msg, msg_hash_to_str(MSG_CORE_OPTIONS_FLUSHED),\n            sizeof(msg));\n      RARCH_LOG(\n            \"[Core]: Saved core options to \\\"%s\\\".\\n\",\n            path_core_options ? path_core_options : \"UNKNOWN\");\n   }\n   else\n   {\n      /* Log result */\n      _len = strlcpy(msg, msg_hash_to_str(MSG_CORE_OPTIONS_FLUSH_FAILED),\n            sizeof(msg));\n      RARCH_LOG(\n            \"[Core]: Failed to save core options to \\\"%s\\\".\\n\",\n            path_core_options ? path_core_options : \"UNKNOWN\");\n   }\n\n   _len += snprintf(msg + _len, sizeof(msg) - _len, \" \\\"%s\\\"\",\n         core_options_file);\n\n   runloop_msg_queue_push(msg, _len, 1, 100, true, NULL,\n         MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n}\n\nvoid runloop_msg_queue_push(\n      const char *msg,\n      size_t len,\n      unsigned prio, unsigned duration,\n      bool flush,\n      char *title,\n      enum message_queue_icon icon,\n      enum message_queue_category category)\n{\n#if defined(HAVE_GFX_WIDGETS)\n   dispgfx_widget_t *p_dispwidget = dispwidget_get_ptr();\n   bool widgets_active            = p_dispwidget->active;\n#endif\n#ifdef HAVE_ACCESSIBILITY\n   settings_t *settings           = config_get_ptr();\n   bool accessibility_enable      = settings->bools.accessibility_enable;\n   unsigned accessibility_narrator_speech_speed = settings->uints.accessibility_narrator_speech_speed;\n   access_state_t *access_st      = access_state_get_ptr();\n#endif\n   runloop_state_t *runloop_st    = &runloop_state;\n\n   RUNLOOP_MSG_QUEUE_LOCK(runloop_st);\n#ifdef HAVE_ACCESSIBILITY\n   if (is_accessibility_enabled(\n            accessibility_enable,\n            access_st->enabled))\n      accessibility_speak_priority(\n            accessibility_enable,\n            accessibility_narrator_speech_speed,\n            (char*) msg, 0);\n#endif\n#if defined(HAVE_GFX_WIDGETS)\n   if (widgets_active)\n   {\n      gfx_widgets_msg_queue_push(\n            NULL,\n            msg,\n            len,\n            roundf((float)duration / 60.0f * 1000.0f),\n            title,\n            icon,\n            category,\n            prio,\n            flush,\n#ifdef HAVE_MENU\n            (menu_state_get_ptr()->flags & MENU_ST_FLAG_ALIVE) ? true : false\n#else\n            false\n#endif\n            );\n      duration = duration * 60 / 1000;\n   }\n   else\n#endif\n   {\n      if (flush)\n         msg_queue_clear(&runloop_st->msg_queue);\n\n      msg_queue_push(&runloop_st->msg_queue, msg,\n            prio, duration,\n            title, icon, category);\n\n      runloop_st->msg_queue_size = msg_queue_size(\n            &runloop_st->msg_queue);\n   }\n\n   ui_companion_driver_msg_queue_push(\n         msg, prio, duration, flush);\n\n   RUNLOOP_MSG_QUEUE_UNLOCK(runloop_st);\n}\n\n#ifdef HAVE_MENU\n/* Display the libretro core's framebuffer onscreen. */\nstatic bool display_menu_libretro(\n      runloop_state_t *runloop_st,\n      input_driver_state_t *input_st,\n      float slowmotion_ratio,\n      bool libretro_running,\n      retro_time_t current_time)\n{\n   bool runloop_idle             = (runloop_st->flags & RUNLOOP_FLAG_IDLE) ? true : false;\n   video_driver_state_t*video_st = video_state_get_ptr();\n\n   if (     video_st->poke\n         && video_st->poke->set_texture_enable)\n      video_st->poke->set_texture_enable(video_st->data, true, false);\n\n   if (libretro_running)\n   {\n      if (!(input_st->flags & INP_FLAG_BLOCK_LIBRETRO_INPUT))\n         input_st->flags |= INP_FLAG_BLOCK_LIBRETRO_INPUT;\n\n      core_run();\n      runloop_st->core_runtime_usec       +=\n         runloop_core_runtime_tick(runloop_st, slowmotion_ratio, current_time);\n      input_st->flags                     &= ~INP_FLAG_BLOCK_LIBRETRO_INPUT;\n\n      return false;\n   }\n\n   if (runloop_idle)\n   {\n#ifdef HAVE_PRESENCE\n      presence_userdata_t userdata;\n      userdata.status = PRESENCE_GAME_PAUSED;\n\n      command_event(CMD_EVENT_PRESENCE_UPDATE, &userdata);\n#endif\n      return false;\n   }\n\n   return true;\n}\n#endif\n\n#define HOTKEY_CHECK(cmd1, cmd2, cond, cond2) \\\n   { \\\n      static bool old_pressed                   = false; \\\n      bool pressed                              = BIT256_GET(current_bits, cmd1); \\\n      if (pressed && !old_pressed) \\\n         if (cond) \\\n            command_event(cmd2, cond2); \\\n      old_pressed                               = pressed; \\\n   }\n\n#define HOTKEY_CHECK3(cmd1, cmd2, cmd3, cmd4, cmd5, cmd6) \\\n   { \\\n      static bool old_pressed                   = false; \\\n      static bool old_pressed2                  = false; \\\n      static bool old_pressed3                  = false; \\\n      bool pressed                              = BIT256_GET(current_bits, cmd1); \\\n      bool pressed2                             = BIT256_GET(current_bits, cmd3); \\\n      bool pressed3                             = BIT256_GET(current_bits, cmd5); \\\n      if (pressed && !old_pressed) \\\n         command_event(cmd2, (void*)(intptr_t)0); \\\n      else if (pressed2 && !old_pressed2) \\\n         command_event(cmd4, (void*)(intptr_t)0); \\\n      else if (pressed3 && !old_pressed3) \\\n         command_event(cmd6, (void*)(intptr_t)0); \\\n      old_pressed                               = pressed; \\\n      old_pressed2                              = pressed2; \\\n      old_pressed3                              = pressed3; \\\n   }\n\nstatic void runloop_pause_toggle(\n      bool *runloop_paused_hotkey,\n      bool pause_pressed, bool old_pause_pressed,\n      bool focused, bool old_focus)\n{\n   runloop_state_t *runloop_st         = &runloop_state;\n\n   if (focused)\n   {\n      if (pause_pressed && !old_pause_pressed)\n      {\n         /* Keep track of hotkey triggered pause to\n          * distinguish it from menu triggered pause */\n         *runloop_paused_hotkey = !(runloop_st->flags & RUNLOOP_FLAG_PAUSED);\n         command_event(CMD_EVENT_PAUSE_TOGGLE, NULL);\n      }\n      else if (!old_focus)\n         command_event(CMD_EVENT_UNPAUSE, NULL);\n   }\n   else if (old_focus)\n      command_event(CMD_EVENT_PAUSE, NULL);\n}\n\nstatic enum runloop_state_enum runloop_check_state(\n      bool error_on_init,\n      settings_t *settings,\n      retro_time_t current_time)\n{\n   input_bits_t current_bits;\n#ifdef HAVE_MENU\n   static input_bits_t last_input      = {{0}};\n#endif\n   uico_driver_state_t  *uico_st       = uico_state_get_ptr();\n   input_driver_state_t *input_st      = input_state_get_ptr();\n   video_driver_state_t *video_st      = video_state_get_ptr();\n   gfx_display_t            *p_disp    = disp_get_ptr();\n   runloop_state_t *runloop_st         = &runloop_state;\n   static bool old_focus               = true;\n   static bool runloop_paused_hotkey   = false;\n   struct retro_callbacks *cbs         = &runloop_st->retro_ctx;\n   bool is_focused                     = false;\n   bool is_alive                       = false;\n   uint64_t frame_count                = 0;\n   bool focused                        = true;\n   bool rarch_is_initialized           = (runloop_st->flags & RUNLOOP_FLAG_IS_INITED) ? true : false;\n   bool runloop_paused                 = (runloop_st->flags & RUNLOOP_FLAG_PAUSED)    ? true : false;\n   bool pause_nonactive                = settings->bools.pause_nonactive;\n   unsigned quit_gamepad_combo         = settings->uints.input_quit_gamepad_combo;\n#ifdef HAVE_MENU\n   struct menu_state *menu_st          = menu_state_get_ptr();\n   menu_handle_t *menu                 = menu_st->driver_data;\n   unsigned menu_toggle_gamepad_combo  = settings->uints.input_menu_toggle_gamepad_combo;\n   bool menu_driver_binding_state      = (menu_st->flags & MENU_ST_FLAG_IS_BINDING) ? true : false;\n   bool menu_was_alive                 = (menu_st->flags & MENU_ST_FLAG_ALIVE)      ? true : false;\n   bool display_kb                     = menu_input_dialog_get_display_kb();\n#endif\n#if defined(HAVE_GFX_WIDGETS)\n   dispgfx_widget_t *p_dispwidget      = dispwidget_get_ptr();\n   bool widgets_active                 = p_dispwidget->active;\n#endif\n#ifdef HAVE_CHEEVOS\n   bool cheevos_hardcore_active        = false;\n#endif\n\n#if defined(HAVE_TRANSLATE) && defined(HAVE_GFX_WIDGETS)\n   if (p_dispwidget->ai_service_overlay_state == 3)\n   {\n      command_event(CMD_EVENT_PAUSE, NULL);\n      p_dispwidget->ai_service_overlay_state = 1;\n   }\n#endif\n\n#ifdef HAVE_LIBNX\n   /* Should be called once per frame */\n   if (!appletMainLoop())\n      return RUNLOOP_STATE_QUIT;\n#endif\n\n#ifdef _3DS\n   /* Should be called once per frame */\n   if (!aptMainLoop())\n      return RUNLOOP_STATE_QUIT;\n#endif\n\n   BIT256_CLEAR_ALL_PTR(&current_bits);\n\n   input_st->flags    &= ~(INP_FLAG_BLOCK_LIBRETRO_INPUT\n                         | INP_FLAG_BLOCK_HOTKEY);\n\n   if (input_st->flags & INP_FLAG_KB_MAPPING_BLOCKED)\n      input_st->flags |= INP_FLAG_BLOCK_HOTKEY;\n\n   input_driver_collect_system_input(input_st, settings, &current_bits);\n\n#ifdef HAVE_MENU\n   last_input                       = current_bits;\n   if (\n         ((menu_toggle_gamepad_combo != INPUT_COMBO_NONE)\n          && input_driver_button_combo(\n             menu_toggle_gamepad_combo,\n             current_time,\n             &last_input)))\n      BIT256_SET(current_bits, RARCH_MENU_TOGGLE);\n\n   if (menu_st->input_driver_flushing_input > 0)\n   {\n      bool input_active = bits_any_set(current_bits.data, ARRAY_SIZE(current_bits.data));\n      /* Don't count 'enable_hotkey' as active input */\n      if (      input_active\n            &&  BIT256_GET(current_bits, RARCH_ENABLE_HOTKEY)\n            && !BIT256_GET(current_bits, RARCH_MENU_TOGGLE))\n         input_active = false;\n\n      if (!input_active)\n         menu_st->input_driver_flushing_input--;\n\n      if (input_active || (menu_st->input_driver_flushing_input > 0))\n      {\n         BIT256_CLEAR_ALL(current_bits);\n         if (      runloop_paused\n               && !runloop_paused_hotkey\n               && settings->bools.menu_pause_libretro)\n            BIT256_SET(current_bits, RARCH_PAUSE_TOGGLE);\n         else if (runloop_paused_hotkey)\n         {\n            /* Restore pause if pause is triggered with both hotkey and menu,\n             * and restore cached video frame to continue properly to\n             * paused state from non-paused menu */\n            if (settings->bools.menu_pause_libretro)\n               command_event(CMD_EVENT_PAUSE, NULL);\n            else\n               video_driver_cached_frame();\n         }\n      }\n   }\n#endif\n\n   if (!VIDEO_DRIVER_IS_THREADED_INTERNAL(video_st))\n   {\n      const ui_application_t *application = uico_st->drv\n         ? uico_st->drv->application\n         : NULL;\n      if (application)\n         application->process_events();\n   }\n\n   frame_count = video_st->frame_count;\n   is_alive    = video_st->current_video\n      ? video_st->current_video->alive(video_st->data)\n      : true;\n   is_focused  = VIDEO_HAS_FOCUS(video_st);\n\n#ifdef HAVE_MENU\n   if (menu_driver_binding_state)\n      BIT256_CLEAR_ALL(current_bits);\n#endif\n\n   /* Check fullscreen hotkey */\n   HOTKEY_CHECK(RARCH_FULLSCREEN_TOGGLE_KEY, CMD_EVENT_FULLSCREEN_TOGGLE, true, NULL);\n\n   /* Check mouse grab hotkey */\n   HOTKEY_CHECK(RARCH_GRAB_MOUSE_TOGGLE, CMD_EVENT_GRAB_MOUSE_TOGGLE, true, NULL);\n\n   /* Automatic mouse grab on focus */\n   if (     settings->bools.input_auto_mouse_grab\n         && (is_focused)\n         && (is_focused != (((runloop_st->flags & RUNLOOP_FLAG_FOCUSED)) > 0))\n         && !(input_st->flags & INP_FLAG_GRAB_MOUSE_STATE))\n      command_event(CMD_EVENT_GRAB_MOUSE_TOGGLE, NULL);\n   if (is_focused)\n      runloop_st->flags |=  RUNLOOP_FLAG_FOCUSED;\n   else\n      runloop_st->flags &= ~RUNLOOP_FLAG_FOCUSED;\n\n#ifdef HAVE_OVERLAY\n   if (settings->bools.input_overlay_enable)\n   {\n      static unsigned last_width                     = 0;\n      static unsigned last_height                    = 0;\n      unsigned video_driver_width                    = video_st->width;\n      unsigned video_driver_height                   = video_st->height;\n      bool check_next_rotation                       = true;\n      bool input_overlay_hide_when_gamepad_connected = settings->bools.input_overlay_hide_when_gamepad_connected;\n      bool input_overlay_auto_rotate                 = settings->bools.input_overlay_auto_rotate;\n\n      /* Check whether overlay should be hidden\n       * when a gamepad is connected */\n      if (input_overlay_hide_when_gamepad_connected)\n      {\n         static bool last_controller_connected = false;\n         bool controller_connected             = (input_config_get_device_name(0) != NULL);\n\n         if (controller_connected != last_controller_connected)\n         {\n            if (controller_connected)\n               input_overlay_unload();\n            else\n               input_overlay_init();\n\n            last_controller_connected = controller_connected;\n         }\n      }\n\n      /* Check next overlay hotkey */\n      HOTKEY_CHECK(RARCH_OVERLAY_NEXT, CMD_EVENT_OVERLAY_NEXT, true, &check_next_rotation);\n\n      /* Check whether video aspect has changed */\n      if (   (video_driver_width  != last_width)\n          || (video_driver_height != last_height))\n      {\n         /* Update scaling/offset factors */\n         command_event(CMD_EVENT_OVERLAY_SET_SCALE_FACTOR, NULL);\n\n         /* Check overlay rotation, if required */\n         if (input_overlay_auto_rotate)\n            input_overlay_auto_rotate_(\n                  video_st->width,\n                  video_st->height,\n                  settings->bools.input_overlay_enable,\n                  input_st->overlay_ptr);\n\n         last_width  = video_driver_width;\n         last_height = video_driver_height;\n      }\n\n      /* Check OSK hotkey */\n      HOTKEY_CHECK(RARCH_OSK, CMD_EVENT_OSK_TOGGLE, true, NULL);\n   }\n#endif\n\n   /*\n   * If the Aspect Ratio is FULL then update the aspect ratio to the\n   * current video driver aspect ratio (The full window)\n   *\n   * TODO/FIXME\n   *      Should possibly be refactored to have last width & driver width & height\n   *      only be done once when we are using an overlay OR using aspect ratio\n   *      full\n   */\n   if (settings->uints.video_aspect_ratio_idx == ASPECT_RATIO_FULL)\n   {\n      static unsigned last_width                     = 0;\n      static unsigned last_height                    = 0;\n      unsigned video_driver_width                    = video_st->width;\n      unsigned video_driver_height                   = video_st->height;\n\n      /* Check whether video aspect has changed */\n      if (   (video_driver_width  != last_width)\n          || (video_driver_height != last_height))\n      {\n         /* Update set aspect ratio so the full matches the current video width & height */\n         command_event(CMD_EVENT_VIDEO_SET_ASPECT_RATIO, NULL);\n\n         last_width  = video_driver_width;\n         last_height = video_driver_height;\n      }\n   }\n\n   /* Check quit hotkey */\n   {\n      bool trig_quit_key, quit_press_twice;\n      static bool quit_key     = false;\n      static bool old_quit_key = false;\n      static bool runloop_exec = false;\n      quit_key                 = BIT256_GET(\n            current_bits, RARCH_QUIT_KEY);\n      trig_quit_key            = quit_key && !old_quit_key;\n      /* Check for quit gamepad combo */\n      if (    !trig_quit_key\n          && ((quit_gamepad_combo != INPUT_COMBO_NONE)\n          && input_driver_button_combo(\n             quit_gamepad_combo,\n             current_time,\n             &current_bits)))\n        trig_quit_key = true;\n      old_quit_key             = quit_key;\n      quit_press_twice         = settings->bools.quit_press_twice;\n\n      /* Check double press if enabled */\n      if (     trig_quit_key\n            && quit_press_twice)\n      {\n         static retro_time_t quit_key_time   = 0;\n         retro_time_t cur_time               = current_time;\n         trig_quit_key                       = (cur_time - quit_key_time < QUIT_DELAY_USEC);\n         quit_key_time                       = cur_time;\n\n         if (!trig_quit_key)\n         {\n            const char *_msg = msg_hash_to_str(MSG_PRESS_AGAIN_TO_QUIT);\n            float target_hz  = 0.0;\n\n            runloop_environment_cb(\n                  RETRO_ENVIRONMENT_GET_TARGET_REFRESH_RATE, &target_hz);\n\n            runloop_msg_queue_push(_msg, strlen(_msg), 1, QUIT_DELAY_USEC * target_hz / 1000000,\n                  true, NULL, MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n         }\n      }\n\n      if (RUNLOOP_TIME_TO_EXIT(trig_quit_key))\n      {\n         bool quit_runloop           = false;\n#ifdef HAVE_SCREENSHOTS\n         unsigned runloop_max_frames = runloop_st->max_frames;\n\n         if (     (runloop_max_frames != 0)\n               && (frame_count >= runloop_max_frames)\n               && (runloop_st->flags & RUNLOOP_FLAG_MAX_FRAMES_SCREENSHOT))\n         {\n            const char *screenshot_path = NULL;\n            bool fullpath               = false;\n\n            if (string_is_empty(runloop_st->max_frames_screenshot_path))\n               screenshot_path          = path_get(RARCH_PATH_BASENAME);\n            else\n            {\n               fullpath                 = true;\n               screenshot_path          = runloop_st->max_frames_screenshot_path;\n            }\n\n            RARCH_LOG(\"Taking a screenshot before exiting...\\n\");\n\n            /* Take a screenshot before we exit. */\n            if (!take_screenshot(settings->paths.directory_screenshot,\n                     screenshot_path,\n                     false,\n                     video_st->frame_cache_data && (video_st->frame_cache_data == RETRO_HW_FRAME_BUFFER_VALID),\n                     fullpath,\n                     false))\n            {\n               RARCH_ERR(\"Could not take a screenshot before exiting.\\n\");\n            }\n         }\n#endif\n\n         if (runloop_exec)\n            runloop_exec = false;\n\n         if (runloop_st->flags & RUNLOOP_FLAG_CORE_SHUTDOWN_INITIATED)\n         {\n            bool load_dummy_core = false;\n\n            runloop_st->flags   &= ~RUNLOOP_FLAG_CORE_SHUTDOWN_INITIATED;\n\n            /* Check whether dummy core should be loaded\n             * instead of exiting RetroArch completely\n             * (aborts shutdown if invoked) */\n            if (settings->bools.load_dummy_on_core_shutdown)\n            {\n               load_dummy_core    = true;\n               runloop_st->flags &= ~RUNLOOP_FLAG_SHUTDOWN_INITIATED;\n            }\n\n            /* Unload current core, and load dummy if\n             * required */\n            if (!command_event(CMD_EVENT_UNLOAD_CORE, &load_dummy_core))\n            {\n               runloop_st->flags |= RUNLOOP_FLAG_SHUTDOWN_INITIATED;\n               quit_runloop       = true;\n            }\n\n            if (!load_dummy_core)\n               quit_runloop = true;\n         }\n         else\n            quit_runloop                 = true;\n\n         runloop_st->flags              &= ~RUNLOOP_FLAG_CORE_RUNNING;\n\n         if (quit_runloop)\n         {\n            old_quit_key                 = quit_key;\n            return RUNLOOP_STATE_QUIT;\n         }\n      }\n   }\n\n#ifdef HAVE_MENU\n   /* Check menu hotkey */\n   {\n      static bool old_pressed = false;\n      char *menu_driver       = settings->arrays.menu_driver;\n      bool pressed            = BIT256_GET(current_bits, RARCH_MENU_TOGGLE)\n            && !string_is_equal(menu_driver, \"null\");\n      bool core_type_is_dummy = runloop_st->current_core_type == CORE_TYPE_DUMMY;\n\n      if (    (pressed && !old_pressed)\n            || core_type_is_dummy)\n      {\n         if (menu_st->flags & MENU_ST_FLAG_ALIVE)\n         {\n            if (rarch_is_initialized && !core_type_is_dummy)\n               retroarch_menu_running_finished(false);\n         }\n         else\n            retroarch_menu_running();\n      }\n\n      old_pressed             = pressed;\n   }\n#endif\n\n#if defined(HAVE_MENU) || defined(HAVE_GFX_WIDGETS)\n   gfx_animation_update(\n         current_time,\n         settings->bools.menu_timedate_enable,\n         settings->floats.menu_ticker_speed,\n         video_st->width,\n         video_st->height);\n\n#if defined(HAVE_GFX_WIDGETS)\n   if (widgets_active)\n   {\n      bool rarch_force_fullscreen = (video_st->flags &\n         VIDEO_FLAG_FORCE_FULLSCREEN) ? true : false;\n      bool video_is_fullscreen    = settings->bools.video_fullscreen\n                                 || rarch_force_fullscreen;\n\n      RUNLOOP_MSG_QUEUE_LOCK(runloop_st);\n      gfx_widgets_iterate(\n            p_disp,\n            settings,\n            video_st->width,\n            video_st->height,\n            video_is_fullscreen,\n            settings->paths.directory_assets,\n            settings->paths.path_font,\n            VIDEO_DRIVER_IS_THREADED_INTERNAL(video_st));\n      RUNLOOP_MSG_QUEUE_UNLOCK(runloop_st);\n   }\n#endif\n\n#ifdef HAVE_MENU\n   if (menu_st->flags & MENU_ST_FLAG_ALIVE)\n   {\n      enum menu_action action;\n      static input_bits_t old_input = {{0}};\n      static enum menu_action\n         old_action                 = MENU_ACTION_CANCEL;\n      struct menu_state *menu_st    = menu_state_get_ptr();\n      bool focused                  = false;\n      input_bits_t trigger_input    = current_bits;\n      unsigned screensaver_timeout  = settings->uints.menu_screensaver_timeout;\n\n      /* Get current time */\n      menu_st->current_time_us      = current_time;\n\n      cbs->poll_cb();\n\n      bits_clear_bits(trigger_input.data, old_input.data,\n            ARRAY_SIZE(trigger_input.data));\n      action                    = (enum menu_action)menu_event(\n            settings,\n            &current_bits, &trigger_input, display_kb);\n#ifdef HAVE_NETWORKING\n      if (!netplay_driver_ctl(RARCH_NETPLAY_CTL_ALLOW_PAUSE, NULL))\n         focused = true;\n      else\n#endif\n      {\n         if (pause_nonactive)\n            focused = is_focused && (!(uico_st->flags & UICO_ST_FLAG_IS_ON_FOREGROUND));\n         else\n            focused = (!(uico_st->flags & UICO_ST_FLAG_IS_ON_FOREGROUND));\n      }\n\n      if (action == old_action)\n      {\n         retro_time_t press_time          = current_time;\n\n         if (action == MENU_ACTION_NOOP)\n            menu_st->noop_press_time      = press_time - menu_st->noop_start_time;\n         else\n            menu_st->action_press_time    = press_time - menu_st->action_start_time;\n      }\n      else\n      {\n         if (action == MENU_ACTION_NOOP)\n         {\n            menu_st->noop_start_time      = current_time;\n            menu_st->noop_press_time      = 0;\n\n            if (menu_st->prev_action == old_action)\n               menu_st->action_start_time = menu_st->prev_start_time;\n            else\n               menu_st->action_start_time = current_time;\n         }\n         else\n         {\n            if (     menu_st->prev_action == action\n                  && menu_st->noop_press_time < 200000) /* 250ms */\n            {\n               menu_st->action_start_time = menu_st->prev_start_time;\n               menu_st->action_press_time = current_time - menu_st->action_start_time;\n            }\n            else\n            {\n               menu_st->prev_start_time   = current_time;\n               menu_st->prev_action       = action;\n               menu_st->action_press_time = 0;\n            }\n         }\n      }\n\n      /* Check whether menu screensaver should be enabled */\n      if (     (screensaver_timeout > 0)\n            && (menu_st->flags   & MENU_ST_FLAG_SCREENSAVER_SUPPORTED)\n            && (!(menu_st->flags & MENU_ST_FLAG_SCREENSAVER_ACTIVE))\n            && ((menu_st->current_time_us - menu_st->input_last_time_us)\n             > ((retro_time_t)screensaver_timeout * 1000000)))\n      {\n         menu_st->flags             |= MENU_ST_FLAG_SCREENSAVER_ACTIVE;\n         if (menu_st->driver_ctx->environ_cb)\n            menu_st->driver_ctx->environ_cb(MENU_ENVIRON_ENABLE_SCREENSAVER,\n                     NULL, menu_st->userdata);\n      }\n\n      /* Iterate the menu driver for one frame. */\n\n      /* If the user had requested that the Quick Menu\n       * be spawned during the previous frame, do this now\n       * and exit the function to go to the next frame. */\n      if (menu_st->flags & MENU_ST_FLAG_PENDING_QUICK_MENU)\n      {\n         /* We are going to push a new menu; ensure\n          * that the current one is cached for animation\n          * purposes */\n         if (menu_st->driver_ctx && menu_st->driver_ctx->list_cache)\n            menu_st->driver_ctx->list_cache(menu_st->userdata,\n                  MENU_LIST_PLAIN, MENU_ACTION_NOOP);\n\n         p_disp->flags   |= GFX_DISP_FLAG_MSG_FORCE;\n\n         generic_action_ok_displaylist_push(\"\", NULL,\n               \"\", 0, 0, 0, ACTION_OK_DL_CONTENT_SETTINGS);\n\n         menu_st->selection_ptr      = 0;\n         menu_st->flags             &= ~MENU_ST_FLAG_PENDING_QUICK_MENU;\n      }\n      else if (!menu_driver_iterate(\n               menu_st,\n               p_disp,\n               anim_get_ptr(),\n               settings,\n               action, current_time))\n      {\n         if (error_on_init)\n         {\n            content_ctx_info_t content_info = {0};\n            task_push_start_dummy_core(&content_info);\n         }\n         else\n            retroarch_menu_running_finished(false);\n      }\n\n      if (focused || !(runloop_st->flags & RUNLOOP_FLAG_IDLE))\n      {\n         bool runloop_is_inited      = (runloop_st->flags & RUNLOOP_FLAG_IS_INITED) ? true : false;\n#ifdef HAVE_NETWORKING\n         bool menu_pause_libretro    = settings->bools.menu_pause_libretro\n            && netplay_driver_ctl(RARCH_NETPLAY_CTL_ALLOW_PAUSE, NULL);\n#else\n         bool menu_pause_libretro    = settings->bools.menu_pause_libretro;\n#endif\n         bool libretro_running       =\n                  runloop_is_inited\n               && !(runloop_st->flags & RUNLOOP_FLAG_PAUSED)\n               && (  !menu_pause_libretro\n                  && runloop_st->flags & RUNLOOP_FLAG_CORE_RUNNING);\n\n         if (menu)\n         {\n            if (BIT64_GET(menu->state, MENU_STATE_RENDER_FRAMEBUFFER)\n                  != BIT64_GET(menu->state, MENU_STATE_RENDER_MESSAGEBOX))\n               BIT64_SET(menu->state, MENU_STATE_RENDER_FRAMEBUFFER);\n\n            if (BIT64_GET(menu->state, MENU_STATE_RENDER_FRAMEBUFFER))\n               p_disp->flags |= GFX_DISP_FLAG_FB_DIRTY;\n\n            if (BIT64_GET(menu->state, MENU_STATE_RENDER_MESSAGEBOX)\n                  && !string_is_empty(menu->menu_state_msg))\n            {\n               if (menu->driver_ctx->render_messagebox)\n                  menu->driver_ctx->render_messagebox(\n                        menu->userdata,\n                        menu->menu_state_msg);\n\n               if (uico_st->flags & UICO_ST_FLAG_IS_ON_FOREGROUND)\n               {\n                  if (     uico_st->drv\n                        && uico_st->drv->render_messagebox)\n                     uico_st->drv->render_messagebox(menu->menu_state_msg);\n               }\n            }\n\n            if (BIT64_GET(menu->state, MENU_STATE_BLIT))\n            {\n               if (menu->driver_ctx->render)\n                  menu->driver_ctx->render(\n                        menu->userdata,\n                        video_st->width,\n                        video_st->height,\n                        (runloop_st->flags & RUNLOOP_FLAG_IDLE) ? true : false);\n            }\n\n            if (      (menu_st->flags & MENU_ST_FLAG_ALIVE)\n                  && !(runloop_st->flags & RUNLOOP_FLAG_IDLE))\n               if (display_menu_libretro(runloop_st, input_st,\n                        settings->floats.slowmotion_ratio,\n                        libretro_running, current_time))\n                  video_driver_cached_frame();\n\n            if (menu->driver_ctx->set_texture)\n               menu->driver_ctx->set_texture(menu->userdata);\n\n            menu->state               = 0;\n         }\n\n         if (settings->bools.audio_enable_menu && !libretro_running)\n            audio_driver_menu_sample();\n      }\n\n      old_input                 = current_bits;\n      old_action                = action;\n\n      if (!focused || (runloop_st->flags & RUNLOOP_FLAG_IDLE))\n         return RUNLOOP_STATE_POLLED_AND_SLEEP;\n   }\n   else\n#endif\n#endif\n   {\n      if (runloop_st->flags & RUNLOOP_FLAG_IDLE)\n      {\n         cbs->poll_cb();\n         return RUNLOOP_STATE_POLLED_AND_SLEEP;\n      }\n   }\n\n   /* Check Game Focus hotkey */\n   {\n      enum input_game_focus_cmd_type game_focus_cmd = GAME_FOCUS_CMD_TOGGLE;\n      HOTKEY_CHECK(RARCH_GAME_FOCUS_TOGGLE, CMD_EVENT_GAME_FOCUS_TOGGLE, true, &game_focus_cmd);\n   }\n\n   /* Check UI companion hotkey */\n   HOTKEY_CHECK(RARCH_UI_COMPANION_TOGGLE, CMD_EVENT_UI_COMPANION_TOGGLE, true, NULL);\n\n   /* Check close content hotkey */\n   HOTKEY_CHECK(RARCH_CLOSE_CONTENT_KEY, CMD_EVENT_CLOSE_CONTENT, true, NULL);\n\n   /* Check FPS hotkey */\n   HOTKEY_CHECK(RARCH_FPS_TOGGLE, CMD_EVENT_FPS_TOGGLE, true, NULL);\n\n   /* Check statistics hotkey */\n   HOTKEY_CHECK(RARCH_STATISTICS_TOGGLE, CMD_EVENT_STATISTICS_TOGGLE, true, NULL);\n\n   /* Check netplay host hotkey */\n   HOTKEY_CHECK(RARCH_NETPLAY_HOST_TOGGLE, CMD_EVENT_NETPLAY_HOST_TOGGLE, true, NULL);\n\n   /* Volume stepping + acceleration */\n   {\n      static unsigned volume_hotkey_delay        = 0;\n      static unsigned volume_hotkey_delay_active = 0;\n      unsigned volume_hotkey_delay_default       = 6;\n      bool volume_hotkey_up                      = BIT256_GET(\n            current_bits, RARCH_VOLUME_UP);\n      bool volume_hotkey_down                    = BIT256_GET(\n            current_bits, RARCH_VOLUME_DOWN);\n\n      if (     (volume_hotkey_up   && !volume_hotkey_down)\n            || (volume_hotkey_down && !volume_hotkey_up))\n      {\n         if (volume_hotkey_delay > 0)\n            volume_hotkey_delay--;\n         else\n         {\n            if (volume_hotkey_up)\n               command_event(CMD_EVENT_VOLUME_UP, NULL);\n            else if (volume_hotkey_down)\n               command_event(CMD_EVENT_VOLUME_DOWN, NULL);\n\n            if (volume_hotkey_delay_active > 0)\n               volume_hotkey_delay_active--;\n            volume_hotkey_delay = volume_hotkey_delay_active;\n         }\n      }\n      else\n      {\n         volume_hotkey_delay        = 0;\n         volume_hotkey_delay_active = volume_hotkey_delay_default;\n      }\n   }\n\n   /* Check audio mute hotkey */\n   HOTKEY_CHECK(RARCH_MUTE, CMD_EVENT_AUDIO_MUTE_TOGGLE, true, NULL);\n\n#ifdef HAVE_SCREENSHOTS\n   /* Check screenshot hotkey */\n   HOTKEY_CHECK(RARCH_SCREENSHOT, CMD_EVENT_TAKE_SCREENSHOT, true, NULL);\n#endif\n\n#ifdef HAVE_CHEEVOS\n   /* Make sure not to evaluate this before calling menu_driver_iterate\n    * as that may change its value */\n   cheevos_hardcore_active = rcheevos_hardcore_active();\n\n   if (!cheevos_hardcore_active)\n#endif\n   {\n      /* Check rewind hotkey */\n      /* > Must do this before MENU_ITERATE to not lose rewind steps\n       *   while menu is active when menu pause is disabled */\n      {\n#ifdef HAVE_REWIND\n         char s[128];\n         bool rewinding      = false;\n         static bool old_rewind_pressed = false;\n         bool rewind_pressed = BIT256_GET(current_bits, RARCH_REWIND);\n         unsigned t          = 0;\n\n         s[0]                = '\\0';\n\n#ifdef HAVE_MENU\n         /* Don't allow rewinding while menu is active */\n         if (menu_st->flags & MENU_ST_FLAG_ALIVE)\n            rewind_pressed   = false;\n#endif\n\n         /* Prevent rewind hold while paused to rewind only one frame */\n         if (     runloop_paused\n               && rewind_pressed\n               && old_rewind_pressed\n               && !runloop_st->run_frames_and_pause)\n         {\n            cbs->poll_cb();\n            return RUNLOOP_STATE_PAUSE;\n         }\n\n         rewinding           = state_manager_check_rewind(\n               &runloop_st->rewind_st,\n               &runloop_st->current_core,\n               rewind_pressed,\n               settings->uints.rewind_granularity,\n               runloop_paused\n#ifdef HAVE_MENU\n                     || (  (menu_st->flags & MENU_ST_FLAG_ALIVE)\n                        && settings->bools.menu_pause_libretro)\n#endif\n               ,\n               s, sizeof(s), &t);\n\n         old_rewind_pressed = rewind_pressed;\n\n#if defined(HAVE_GFX_WIDGETS)\n         if (widgets_active)\n         {\n            if (rewinding)\n               video_st->flags |=  VIDEO_FLAG_WIDGETS_REWINDING;\n            else\n               video_st->flags &= ~VIDEO_FLAG_WIDGETS_REWINDING;\n         }\n         else\n#endif\n         {\n            if (rewinding)\n               runloop_msg_queue_push(s, strlen(s), 0, t, true, NULL,\n                     MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n         }\n\n         if (rewinding && runloop_paused\n#ifdef HAVE_MENU\n               && !(menu_st->flags & MENU_ST_FLAG_ALIVE)\n#endif\n            )\n         {\n            cbs->poll_cb();\n            /* Run a few frames on first press after pausing to\n             * prevent going forwards for the first frame */\n            if (runloop_st->run_frames_and_pause == -1)\n            {\n               runloop_st->flags               &= ~RUNLOOP_FLAG_PAUSED;\n               runloop_st->run_frames_and_pause = 3;\n            }\n            return RUNLOOP_STATE_ITERATE;\n         }\n#endif\n      }\n   }\n\n   /* Check pause hotkey in menu */\n#ifdef HAVE_MENU\n   if (menu_st->flags & MENU_ST_FLAG_ALIVE)\n   {\n      static bool old_pause_pressed = false;\n      bool pause_pressed            = BIT256_GET(current_bits, RARCH_PAUSE_TOGGLE);\n\n      /* Decide pause hotkey */\n      runloop_pause_toggle(&runloop_paused_hotkey,\n            pause_pressed, old_pause_pressed,\n            focused, old_focus);\n\n      old_focus           = focused;\n      old_pause_pressed   = pause_pressed;\n   }\n#endif\n\n#ifdef HAVE_MENU\n   /* Stop checking the rest of the hotkeys if menu is alive */\n   if (menu_st->flags & MENU_ST_FLAG_ALIVE)\n      return RUNLOOP_STATE_MENU;\n#endif\n\n#ifdef HAVE_NETWORKING\n   if (netplay_driver_ctl(RARCH_NETPLAY_CTL_ALLOW_PAUSE, NULL))\n#endif\n   if (pause_nonactive)\n      focused                = is_focused;\n\n   /* Check pause hotkey */\n   {\n      static bool old_frameadvance  = false;\n      static bool old_pause_pressed = false;\n      static bool pauseframeadvance = false;\n      bool frameadvance_pressed     = false;\n      bool frameadvance_trigger     = false;\n      bool pause_pressed            = BIT256_GET(current_bits, RARCH_PAUSE_TOGGLE);\n\n      /* Reset frameadvance pause when triggering pause */\n      if (pause_pressed)\n         pauseframeadvance          = false;\n\n      /* Allow unpausing with Start */\n      if (runloop_paused && settings->bools.pause_on_disconnect)\n         pause_pressed             |= BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_START);\n\n#ifdef HAVE_CHEEVOS\n      if (cheevos_hardcore_active)\n      {\n         if (!(runloop_st->flags & RUNLOOP_FLAG_PAUSED))\n         {\n            /* In hardcore mode, the user is only allowed to pause infrequently. */\n            if ((pause_pressed && !old_pause_pressed) ||\n               (!focused && old_focus && pause_nonactive))\n            {\n               /* If the user is trying to pause, check to see if it's allowed. */\n               if (!rcheevos_is_pause_allowed())\n               {\n                  pause_pressed = false;\n                  if (pause_nonactive)\n                     focused = true;\n               }\n            }\n         }\n      }\n      else /* frame advance not allowed in hardcore */\n#endif\n      {\n         frameadvance_pressed = BIT256_GET(current_bits, RARCH_FRAMEADVANCE);\n         frameadvance_trigger = frameadvance_pressed && !old_frameadvance;\n\n         /* FRAMEADVANCE will set us into special pause mode. */\n         if (frameadvance_trigger)\n         {\n            pauseframeadvance = true;\n            if (!(runloop_st->flags & RUNLOOP_FLAG_PAUSED))\n               pause_pressed = true;\n         }\n      }\n\n      /* Decide pause hotkey */\n      runloop_pause_toggle(&runloop_paused_hotkey,\n            pause_pressed, old_pause_pressed,\n            focused, old_focus);\n\n      old_focus           = focused;\n      old_pause_pressed   = pause_pressed;\n      old_frameadvance    = frameadvance_pressed;\n\n      if (runloop_st->flags & RUNLOOP_FLAG_PAUSED)\n      {\n#ifdef HAVE_REWIND\n         /* Frame advance must also trigger rewind save */\n         if (frameadvance_trigger && runloop_paused)\n            state_manager_check_rewind(\n               &runloop_st->rewind_st,\n               &runloop_st->current_core,\n               false,\n               settings->uints.rewind_granularity,\n               false,\n               NULL, 0, NULL);\n#endif\n\n         /* Check if it's not oneshot */\n#ifdef HAVE_REWIND\n         if (!(frameadvance_trigger || BIT256_GET(current_bits, RARCH_REWIND)))\n#else\n         if (!frameadvance_trigger)\n#endif\n            focused = false;\n#ifdef HAVE_CHEEVOS\n         else if (!cheevos_hardcore_active)\n#else\n         else\n#endif\n            runloop_paused = false;\n\n         /* Drop to RUNLOOP_STATE_POLLED_AND_SLEEP if frameadvance is triggered */\n         if (pauseframeadvance)\n            runloop_paused = false;\n      }\n   }\n\n   /* Check recording hotkey */\n   HOTKEY_CHECK(RARCH_RECORDING_TOGGLE, CMD_EVENT_RECORDING_TOGGLE, true, NULL);\n\n   /* Check streaming hotkey */\n   HOTKEY_CHECK(RARCH_STREAMING_TOGGLE, CMD_EVENT_STREAMING_TOGGLE, true, NULL);\n\n   /* Check Run-Ahead hotkey */\n   HOTKEY_CHECK(RARCH_RUNAHEAD_TOGGLE, CMD_EVENT_RUNAHEAD_TOGGLE, true, NULL);\n\n   /* Check Preemptive Frames hotkey */\n   HOTKEY_CHECK(RARCH_PREEMPT_TOGGLE, CMD_EVENT_PREEMPT_TOGGLE, true, NULL);\n\n   /* Check AI Service hotkey */\n   HOTKEY_CHECK(RARCH_AI_SERVICE, CMD_EVENT_AI_SERVICE_TOGGLE, true, NULL);\n\n#ifdef HAVE_NETWORKING\n   /* Check netplay hotkeys */\n   HOTKEY_CHECK(RARCH_NETPLAY_PING_TOGGLE, CMD_EVENT_NETPLAY_PING_TOGGLE, true, NULL);\n   HOTKEY_CHECK(RARCH_NETPLAY_GAME_WATCH, CMD_EVENT_NETPLAY_GAME_WATCH, true, NULL);\n   HOTKEY_CHECK(RARCH_NETPLAY_PLAYER_CHAT, CMD_EVENT_NETPLAY_PLAYER_CHAT, true, NULL);\n   HOTKEY_CHECK(RARCH_NETPLAY_FADE_CHAT_TOGGLE, CMD_EVENT_NETPLAY_FADE_CHAT_TOGGLE, true, NULL);\n#endif\n\n#ifdef HAVE_ACCESSIBILITY\n#ifdef HAVE_TRANSLATE\n   /* Copy over the retropad state to a buffer for the translate service\n      to send off if it's run. */\n   if (settings->bools.ai_service_enable)\n   {\n      input_st->ai_gamepad_state[0]  = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_B);\n      input_st->ai_gamepad_state[1]  = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_Y);\n      input_st->ai_gamepad_state[2]  = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_SELECT);\n      input_st->ai_gamepad_state[3]  = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_START);\n\n      input_st->ai_gamepad_state[4]  = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_UP);\n      input_st->ai_gamepad_state[5]  = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_DOWN);\n      input_st->ai_gamepad_state[6]  = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_LEFT);\n      input_st->ai_gamepad_state[7]  = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_RIGHT);\n\n      input_st->ai_gamepad_state[8]  = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_A);\n      input_st->ai_gamepad_state[9]  = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_X);\n      input_st->ai_gamepad_state[10] = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_L);\n      input_st->ai_gamepad_state[11] = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_R);\n\n      input_st->ai_gamepad_state[12] = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_L2);\n      input_st->ai_gamepad_state[13] = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_R2);\n      input_st->ai_gamepad_state[14] = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_L3);\n      input_st->ai_gamepad_state[15] = BIT256_GET(current_bits, RETRO_DEVICE_ID_JOYPAD_R3);\n   }\n#endif\n#endif\n\n   if (!focused && !runloop_paused)\n   {\n      cbs->poll_cb();\n      return RUNLOOP_STATE_POLLED_AND_SLEEP;\n   }\n\n   /* Apply any pending fastmotion override parameters */\n   if (runloop_st->fastmotion_override.pending)\n   {\n      runloop_apply_fastmotion_override(runloop_st, settings);\n      runloop_st->fastmotion_override.pending = false;\n   }\n\n   /* Check fastmotion hotkeys */\n   /* To avoid continuous switching if we hold the button down, we require\n    * that the button must go from pressed to unpressed back to pressed\n    * to be able to toggle between them.\n    */\n   if (!runloop_st->fastmotion_override.current.inhibit_toggle)\n   {\n      static bool old_button_state            = false;\n      static bool old_hold_button_state       = false;\n      bool new_button_state                   = BIT256_GET(\n            current_bits, RARCH_FAST_FORWARD_KEY);\n      bool new_hold_button_state              = BIT256_GET(\n            current_bits, RARCH_FAST_FORWARD_HOLD_KEY);\n      bool check2                             = new_button_state && !old_button_state;\n\n      if (!check2)\n         check2 = old_hold_button_state != new_hold_button_state;\n\n      /* Don't allow fastmotion while paused */\n      if (check2 && runloop_paused)\n      {\n         new_button_state      = false;\n         new_hold_button_state = false;\n         input_st->flags      |= INP_FLAG_NONBLOCKING;\n      }\n\n#ifdef HAVE_NETWORKING\n      if (check2\n            && !netplay_driver_ctl(RARCH_NETPLAY_CTL_ALLOW_TIMESKIP, NULL))\n         check2 = false;\n#endif\n\n      if (check2)\n      {\n         if (input_st->flags & INP_FLAG_NONBLOCKING)\n         {\n            input_st->flags                     &= ~INP_FLAG_NONBLOCKING;\n            runloop_st->flags                   &= ~RUNLOOP_FLAG_FASTMOTION;\n            runloop_st->fastforward_after_frames = 1;\n         }\n         else\n         {\n            input_st->flags                     |=  INP_FLAG_NONBLOCKING;\n            runloop_st->flags                   |=  RUNLOOP_FLAG_FASTMOTION;\n            command_event(CMD_EVENT_SET_FRAME_LIMIT, NULL);\n         }\n\n         driver_set_nonblock_state();\n\n         /* Reset frame time counter when toggling\n          * fast-forward off, if required */\n         if ( !(runloop_st->flags & RUNLOOP_FLAG_FASTMOTION)\n             && settings->bools.frame_time_counter_reset_after_fastforwarding)\n            video_st->frame_time_count  = 0;\n      }\n\n      old_button_state                  = new_button_state;\n      old_hold_button_state             = new_hold_button_state;\n   }\n\n   /* Display fast-forward notification, unless\n    * disabled via override */\n   if (  !runloop_st->fastmotion_override.current.fastforward\n       || runloop_st->fastmotion_override.current.notification)\n   {\n      /* > Use widgets, if enabled */\n#if defined(HAVE_GFX_WIDGETS)\n      if (widgets_active)\n      {\n         if (settings->bools.notification_show_fast_forward)\n         {\n            if (runloop_st->flags & RUNLOOP_FLAG_FASTMOTION)\n               video_st->flags |=  VIDEO_FLAG_WIDGETS_FAST_FORWARD;\n            else\n               video_st->flags &= ~VIDEO_FLAG_WIDGETS_FAST_FORWARD;\n         }\n         else\n            video_st->flags    &= ~VIDEO_FLAG_WIDGETS_FAST_FORWARD;\n      }\n      else\n#endif\n      {\n         /* > If widgets are disabled, display fast-forward\n          *   status via OSD text for 1 frame every frame */\n         if (   (runloop_st->flags & RUNLOOP_FLAG_FASTMOTION)\n             && settings->bools.notification_show_fast_forward)\n         {\n            const char *_msg = msg_hash_to_str(MSG_FAST_FORWARD);\n            runloop_msg_queue_push(_msg, strlen(_msg), 1, 1, false, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n         }\n      }\n   }\n#if defined(HAVE_GFX_WIDGETS)\n   else\n      video_st->flags &= ~VIDEO_FLAG_WIDGETS_FAST_FORWARD;\n#endif\n\n#ifdef HAVE_CHEEVOS\n   if (!cheevos_hardcore_active)\n#endif\n   {\n      {\n         /* Check slowmotion hotkeys */\n         static bool old_slowmotion_button_state      = false;\n         static bool old_slowmotion_hold_button_state = false;\n         bool new_slowmotion_button_state             = BIT256_GET(\n               current_bits, RARCH_SLOWMOTION_KEY);\n         bool new_slowmotion_hold_button_state        = BIT256_GET(\n               current_bits, RARCH_SLOWMOTION_HOLD_KEY);\n\n         /* Don't allow slowmotion while paused */\n         if (runloop_paused)\n         {\n            new_slowmotion_button_state      = false;\n            new_slowmotion_hold_button_state = false;\n         }\n\n         if (new_slowmotion_button_state && !old_slowmotion_button_state)\n         {\n            if (!(runloop_st->flags & RUNLOOP_FLAG_SLOWMOTION))\n               runloop_st->flags |=  RUNLOOP_FLAG_SLOWMOTION;\n            else\n               runloop_st->flags &= ~RUNLOOP_FLAG_SLOWMOTION;\n         }\n         else if (old_slowmotion_hold_button_state != new_slowmotion_hold_button_state)\n         {\n            if (new_slowmotion_hold_button_state)\n               runloop_st->flags |=  RUNLOOP_FLAG_SLOWMOTION;\n            else\n               runloop_st->flags &= ~RUNLOOP_FLAG_SLOWMOTION;\n         }\n\n#ifdef HAVE_NETWORKING\n         if ((runloop_st->flags & RUNLOOP_FLAG_SLOWMOTION)\n               && !netplay_driver_ctl(RARCH_NETPLAY_CTL_ALLOW_TIMESKIP, NULL))\n            runloop_st->flags &= ~RUNLOOP_FLAG_SLOWMOTION;\n#endif\n\n         if (runloop_st->flags & RUNLOOP_FLAG_SLOWMOTION)\n         {\n            if (settings->uints.video_black_frame_insertion)\n               if (!(runloop_st->flags & RUNLOOP_FLAG_IDLE))\n                  video_driver_cached_frame();\n\n#if defined(HAVE_GFX_WIDGETS)\n            if (!widgets_active)\n#endif\n            {\n#ifdef HAVE_REWIND\n               struct state_manager_rewind_state\n                  *rewind_st = &runloop_st->rewind_st;\n               if (rewind_st->flags\n                     & STATE_MGR_REWIND_ST_FLAG_FRAME_IS_REVERSED)\n               {\n                  const char *_msg = msg_hash_to_str(MSG_SLOW_MOTION_REWIND);\n                  runloop_msg_queue_push(_msg, strlen(_msg), 1, 1, false, NULL,\n                        MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n               }\n               else\n#endif\n               {\n                  const char *_msg = msg_hash_to_str(MSG_SLOW_MOTION);\n                  runloop_msg_queue_push(_msg, strlen(_msg), 1, 1, false, NULL,\n                        MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n               }\n            }\n         }\n\n         old_slowmotion_button_state                  = new_slowmotion_button_state;\n         old_slowmotion_hold_button_state             = new_slowmotion_hold_button_state;\n      }\n   }\n\n   /* Check save state slot hotkeys */\n   {\n      static bool old_should_slot_increase = false;\n      static bool old_should_slot_decrease = false;\n      bool should_slot_increase            = BIT256_GET(\n            current_bits, RARCH_STATE_SLOT_PLUS);\n      bool should_slot_decrease            = BIT256_GET(\n            current_bits, RARCH_STATE_SLOT_MINUS);\n      bool check1                          = true;\n      bool check2                          = should_slot_increase && !old_should_slot_increase;\n      int addition                         = 1;\n      int state_slot                       = settings->ints.state_slot;\n\n      if (!check2)\n      {\n         check2                            = should_slot_decrease && !old_should_slot_decrease;\n         check1                            = state_slot > -1;\n         addition                          = -1;\n\n         /* Wrap-around to 999 */\n         if (check2 && !check1 && state_slot + addition < -1)\n         {\n            state_slot = 1000;\n            check1     = true;\n         }\n      }\n      /* Wrap-around to -1 (Auto) */\n      else if (state_slot + addition > 999)\n         state_slot = -2;\n\n      if (check2)\n      {\n         size_t _len;\n         char msg[128];\n         int cur_state_slot                = state_slot + addition;\n\n         if (check1)\n            configuration_set_int(settings, settings->ints.state_slot,\n                  cur_state_slot);\n         _len  = strlcpy(msg, msg_hash_to_str(MSG_STATE_SLOT), sizeof(msg));\n         _len += snprintf(msg + _len, sizeof(msg) - _len,\n                  \": %d\", settings->ints.state_slot);\n\n         if (cur_state_slot < 0)\n            _len += strlcpy(msg + _len, \" (Auto)\", sizeof(msg) - _len);\n\n#ifdef HAVE_GFX_WIDGETS\n         if (dispwidget_get_ptr()->active)\n            gfx_widget_set_generic_message(msg, 1000);\n         else\n#endif\n            runloop_msg_queue_push(msg, _len, 2, 60, true, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n         RARCH_LOG(\"[State]: %s\\n\", msg);\n      }\n\n      old_should_slot_increase = should_slot_increase;\n      old_should_slot_decrease = should_slot_decrease;\n   }\n   /* Check replay slot hotkeys */\n   {\n      static bool old_should_replay_slot_increase = false;\n      static bool old_should_replay_slot_decrease = false;\n      bool should_slot_increase            = BIT256_GET(\n            current_bits, RARCH_REPLAY_SLOT_PLUS);\n      bool should_slot_decrease            = BIT256_GET(\n            current_bits, RARCH_REPLAY_SLOT_MINUS);\n      bool check1                          = true;\n      bool check2                          = should_slot_increase && !old_should_replay_slot_increase;\n      int addition                         = 1;\n      int replay_slot                       = settings->ints.replay_slot;\n\n      if (!check2)\n      {\n         check2                            = should_slot_decrease && !old_should_replay_slot_decrease;\n         check1                            = replay_slot > -1;\n         addition                          = -1;\n\n         /* Wrap-around to 999 */\n         if (check2 && !check1 && replay_slot + addition < -1)\n         {\n            replay_slot = 1000;\n            check1      = true;\n         }\n      }\n      /* Wrap-around to -1 (Auto) */\n      else if (replay_slot + addition > 999)\n         replay_slot    = -2;\n\n      if (check2)\n      {\n         size_t _len;\n         char msg[128];\n         int cur_replay_slot                = replay_slot + addition;\n\n         if (check1)\n            configuration_set_int(settings, settings->ints.replay_slot,\n                  cur_replay_slot);\n         _len  = strlcpy(msg, msg_hash_to_str(MSG_REPLAY_SLOT), sizeof(msg));\n         _len += snprintf(msg + _len, sizeof(msg) - _len,\n                  \": %d\", settings->ints.replay_slot);\n\n         if (cur_replay_slot < 0)\n            _len += strlcpy(msg + _len, \" (Auto)\", sizeof(msg) - _len);\n\n#ifdef HAVE_GFX_WIDGETS\n         if (dispwidget_get_ptr()->active)\n            gfx_widget_set_generic_message(msg, 1000);\n         else\n#endif\n            runloop_msg_queue_push(msg, _len, 2, 60, true, NULL,\n                  MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n\n         RARCH_LOG(\"[Replay]: %s\\n\", msg);\n      }\n\n      old_should_replay_slot_increase = should_slot_increase;\n      old_should_replay_slot_decrease = should_slot_decrease;\n   }\n\n   /* Check save state hotkeys */\n   HOTKEY_CHECK(RARCH_SAVE_STATE_KEY, CMD_EVENT_SAVE_STATE, true, NULL);\n   HOTKEY_CHECK(RARCH_LOAD_STATE_KEY, CMD_EVENT_LOAD_STATE, true, NULL);\n\n   /* Check reset hotkey */\n   HOTKEY_CHECK(RARCH_RESET, CMD_EVENT_RESET, true, NULL);\n\n   /* Check VRR runloop hotkey */\n   HOTKEY_CHECK(RARCH_VRR_RUNLOOP_TOGGLE, CMD_EVENT_VRR_RUNLOOP_TOGGLE, true, NULL);\n\n   /* Check bsv movie hotkeys */\n   HOTKEY_CHECK(RARCH_PLAY_REPLAY_KEY, CMD_EVENT_PLAY_REPLAY, true, NULL);\n   HOTKEY_CHECK(RARCH_RECORD_REPLAY_KEY, CMD_EVENT_RECORD_REPLAY, true, NULL);\n   HOTKEY_CHECK(RARCH_HALT_REPLAY_KEY, CMD_EVENT_HALT_REPLAY, true, NULL);\n\n   /* Check Disc Control hotkeys */\n   HOTKEY_CHECK3(\n         RARCH_DISK_EJECT_TOGGLE, CMD_EVENT_DISK_EJECT_TOGGLE,\n         RARCH_DISK_NEXT,         CMD_EVENT_DISK_NEXT,\n         RARCH_DISK_PREV,         CMD_EVENT_DISK_PREV);\n\n   /* Check cheat hotkeys */\n   HOTKEY_CHECK3(\n         RARCH_CHEAT_INDEX_PLUS,  CMD_EVENT_CHEAT_INDEX_PLUS,\n         RARCH_CHEAT_INDEX_MINUS, CMD_EVENT_CHEAT_INDEX_MINUS,\n         RARCH_CHEAT_TOGGLE,      CMD_EVENT_CHEAT_TOGGLE);\n\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n   /* Check shader hotkeys */\n   HOTKEY_CHECK3(\n         RARCH_SHADER_NEXT,   CMD_EVENT_SHADER_NEXT,\n         RARCH_SHADER_PREV,   CMD_EVENT_SHADER_PREV,\n         RARCH_SHADER_TOGGLE, CMD_EVENT_SHADER_TOGGLE);\n\n   if (settings->bools.video_shader_watch_files)\n   {\n      static rarch_timer_t timer = {0};\n      static bool need_to_apply  = false;\n\n      if (video_shader_check_for_changes())\n      {\n         need_to_apply = true;\n\n         if (!timer.timer_begin)\n         {\n            timer.timeout_us  = SHADER_FILE_WATCH_DELAY_MSEC * 1000;\n            timer.current     = cpu_features_get_time_usec();\n            timer.timeout_end = timer.current + timer.timeout_us;\n            timer.timer_begin = true;\n            timer.timer_end   = false;\n         }\n      }\n\n      /* If a file is modified atomically (moved/renamed from a different file),\n       * we have no idea how long that might take.\n       * If we're trying to re-apply shaders immediately after changes are made\n       * to the original file(s), the filesystem might be in an in-between\n       * state where the new file hasn't been moved over yet and the original\n       * file was already deleted. This leaves us no choice but to wait an\n       * arbitrary amount of time and hope for the best.\n       */\n      if (need_to_apply)\n      {\n         timer.current        = current_time;\n         timer.timeout_us     = timer.timeout_end - timer.current;\n\n         if (     !timer.timer_end\n               &&  timer.timeout_us <= 0)\n         {\n            timer.timer_end   = true;\n            timer.timer_begin = false;\n            timer.timeout_end = 0;\n            need_to_apply     = false;\n            command_event(CMD_EVENT_SHADERS_APPLY_CHANGES, NULL);\n         }\n      }\n   }\n\n   if (      settings->uints.video_shader_delay\n         && !runloop_st->shader_delay_timer.timer_end)\n   {\n      if (!runloop_st->shader_delay_timer.timer_begin)\n      {\n         runloop_st->shader_delay_timer.timeout_us     = settings->uints.video_shader_delay * 1000;\n         runloop_st->shader_delay_timer.current        = cpu_features_get_time_usec();\n         runloop_st->shader_delay_timer.timeout_end    = runloop_st->shader_delay_timer.current\n                                                       + runloop_st->shader_delay_timer.timeout_us;\n         runloop_st->shader_delay_timer.timer_begin    = true;\n         runloop_st->shader_delay_timer.timer_end      = false;\n      }\n      else\n      {\n         runloop_st->shader_delay_timer.current        = current_time;\n         runloop_st->shader_delay_timer.timeout_us     = runloop_st->shader_delay_timer.timeout_end\n                                                       - runloop_st->shader_delay_timer.current;\n\n         if (runloop_st->shader_delay_timer.timeout_us <= 0)\n         {\n            runloop_st->shader_delay_timer.timer_end   = true;\n            runloop_st->shader_delay_timer.timer_begin = false;\n            runloop_st->shader_delay_timer.timeout_end = 0;\n\n            {\n               const char *preset          = video_shader_get_current_shader_preset();\n               enum rarch_shader_type type = video_shader_parse_type(preset);\n               video_shader_apply_shader(settings, type, preset, false);\n            }\n         }\n      }\n   }\n#endif\n\n   if (runloop_paused)\n   {\n      cbs->poll_cb();\n      return RUNLOOP_STATE_PAUSE;\n   }\n#if HAVE_MENU\n   if (menu_was_alive)\n      return RUNLOOP_STATE_MENU;\n#endif\n   return RUNLOOP_STATE_ITERATE;\n}\n\n\n\n/**\n * runloop_iterate:\n *\n * Run Libretro core in RetroArch for one frame.\n *\n * Returns: 0 on success, 1 if we have to wait until\n * button input in order to wake up the loop,\n * -1 if we forcibly quit out of the RetroArch iteration loop.\n **/\nint runloop_iterate(void)\n{\n   int i;\n   enum analog_dpad_mode dpad_mode[MAX_USERS];\n   input_driver_state_t               *input_st = input_state_get_ptr();\n   audio_driver_state_t               *audio_st = audio_state_get_ptr();\n   video_driver_state_t               *video_st = video_state_get_ptr();\n   recording_state_t              *recording_st = recording_state_get_ptr();\n   camera_driver_state_t             *camera_st = camera_state_get_ptr();\n#if defined(HAVE_COCOATOUCH)\n   uico_driver_state_t  *uico_st                = uico_state_get_ptr();\n#endif\n   settings_t *settings                         = config_get_ptr();\n   runloop_state_t *runloop_st                  = &runloop_state;\n   bool vrr_runloop_enable                      = settings->bools.vrr_runloop_enable;\n   unsigned max_users                           = settings->uints.input_max_users;\n   retro_time_t current_time                    = cpu_features_get_time_usec();\n#ifdef HAVE_MENU\n#ifdef HAVE_NETWORKING\n   bool menu_pause_libretro                     = settings->bools.menu_pause_libretro &&\n         netplay_driver_ctl(RARCH_NETPLAY_CTL_ALLOW_PAUSE, NULL);\n#else\n   bool menu_pause_libretro                     = settings->bools.menu_pause_libretro;\n#endif\n   bool core_paused                             =\n            (runloop_st->flags & RUNLOOP_FLAG_PAUSED)\n         || (menu_pause_libretro && (menu_state_get_ptr()->flags & MENU_ST_FLAG_ALIVE));\n#else\n   bool core_paused                             = (runloop_st->flags & RUNLOOP_FLAG_PAUSED) ? true : false;\n#endif\n   float slowmotion_ratio                       = settings->floats.slowmotion_ratio;\n#ifdef HAVE_CHEEVOS\n   bool cheevos_enable                          = settings->bools.cheevos_enable;\n#endif\n   bool audio_sync                              = settings->bools.audio_sync;\n#ifdef HAVE_DISCORD\n   discord_state_t *discord_st                  = discord_state_get_ptr();\n\n   if (discord_st->inited)\n   {\n      Discord_RunCallbacks();\n#ifdef DISCORD_DISABLE_IO_THREAD\n      Discord_UpdateConnection();\n#endif\n   }\n#endif\n\n   if (runloop_st->frame_time.callback)\n   {\n      /* Updates frame timing if frame timing callback is in use by the core.\n       * Limits frame time if fast forward ratio throttle is enabled. */\n      retro_usec_t runloop_last_frame_time = runloop_st->frame_time_last;\n      retro_time_t current                 = current_time;\n      bool is_locked_fps                   = (\n               (runloop_st->flags & RUNLOOP_FLAG_PAUSED)\n            || (input_st->flags & INP_FLAG_NONBLOCKING))\n             | !!recording_st->data;\n      retro_time_t delta                   = (!runloop_last_frame_time || is_locked_fps)\n         ? runloop_st->frame_time.reference\n         : (current - runloop_last_frame_time);\n\n      if (is_locked_fps)\n         runloop_st->frame_time_last  = 0;\n      else\n      {\n         runloop_st->frame_time_last  = current;\n\n         if (runloop_st->flags & RUNLOOP_FLAG_SLOWMOTION)\n            delta /= slowmotion_ratio;\n      }\n\n      if (!core_paused)\n         runloop_st->frame_time.callback(delta);\n   }\n\n   /* Update audio buffer occupancy if buffer status\n    * callback is in use by the core */\n   if (runloop_st->audio_buffer_status.callback)\n   {\n      bool audio_buf_active        = false;\n      unsigned audio_buf_occupancy = 0;\n      bool audio_buf_underrun      = false;\n\n      if (!(    (runloop_st->flags & RUNLOOP_FLAG_PAUSED)\n            || !(audio_st->flags & AUDIO_FLAG_ACTIVE)\n            || !(audio_st->output_samples_buf))\n            && audio_st->current_audio->write_avail\n            && audio_st->context_audio_data\n            && audio_st->buffer_size)\n      {\n         size_t audio_buf_avail;\n\n         if ((audio_buf_avail = audio_st->current_audio->write_avail(\n               audio_st->context_audio_data)) > audio_st->buffer_size)\n            audio_buf_avail = audio_st->buffer_size;\n\n         audio_buf_occupancy = (unsigned)(100 - (audio_buf_avail * 100) /\n               audio_st->buffer_size);\n\n         /* Elsewhere, we standardise on a 'low water mark'\n          * of 25% of the total audio buffer size - use\n          * the same metric here (can be made more sophisticated\n          * if required - i.e. determine buffer occupancy in\n          * terms of usec, and weigh this against the expected\n          * frame time) */\n         audio_buf_underrun  = audio_buf_occupancy < 25;\n\n         audio_buf_active    = true;\n      }\n\n      if (!core_paused)\n         runloop_st->audio_buffer_status.callback(\n               audio_buf_active, audio_buf_occupancy, audio_buf_underrun);\n   }\n\n   switch ((enum runloop_state_enum)runloop_check_state(\n            ((global_get_ptr()->flags & GLOB_FLG_ERR_ON_INIT) > 0),\n            settings, current_time))\n   {\n      case RUNLOOP_STATE_QUIT:\n         runloop_st->frame_limit_last_time = 0.0;\n         runloop_st->flags                &= ~RUNLOOP_FLAG_CORE_RUNNING;\n         command_event(CMD_EVENT_QUIT, NULL);\n         return -1;\n      case RUNLOOP_STATE_POLLED_AND_SLEEP:\n#ifdef HAVE_NETWORKING\n         /* FIXME: This is an ugly way to tell Netplay this... */\n         netplay_driver_ctl(RARCH_NETPLAY_CTL_PAUSE, NULL);\n#endif\n#if defined(HAVE_COCOATOUCH)\n         if (!(uico_st->flags & UICO_ST_FLAG_IS_ON_FOREGROUND))\n#endif\n            retro_sleep(10);\n         return 1;\n      case RUNLOOP_STATE_PAUSE:\n#ifdef HAVE_NETWORKING\n         /* FIXME: This is an ugly way to tell Netplay this... */\n         netplay_driver_ctl(RARCH_NETPLAY_CTL_PAUSE, NULL);\n#endif\n         video_driver_cached_frame();\n         goto end;\n      case RUNLOOP_STATE_MENU:\n#ifdef HAVE_NETWORKING\n#ifdef HAVE_MENU\n         /* FIXME: This is an ugly way to tell Netplay this... */\n         if (     menu_pause_libretro\n               && netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_ENABLED, NULL)\n            )\n            netplay_driver_ctl(RARCH_NETPLAY_CTL_PAUSE, NULL);\n#endif\n#endif\n#ifdef HAVE_CHEEVOS\n         if (cheevos_enable)\n            rcheevos_idle();\n#endif\n#ifdef HAVE_MENU\n         /* Rely on vsync throttling unless VRR is enabled and menu throttle is disabled. */\n         if (vrr_runloop_enable && !settings->bools.menu_throttle_framerate)\n            return 0;\n         else if (settings->bools.video_vsync)\n            goto end;\n\n         /* Otherwise run menu in video refresh rate speed. */\n         if (menu_state_get_ptr()->flags & MENU_ST_FLAG_ALIVE)\n            runloop_st->frame_limit_minimum_time = (retro_time_t)roundf(1000000.0f /\n                  ((video_st->video_refresh_rate_original)\n                     ? video_st->video_refresh_rate_original\n                     : settings->floats.video_refresh_rate));\n         else\n            runloop_set_frame_limit(&video_st->av_info, settings->floats.fastforward_ratio);\n#endif\n         goto end;\n      case RUNLOOP_STATE_ITERATE:\n         runloop_st->flags       |= RUNLOOP_FLAG_CORE_RUNNING;\n         break;\n   }\n\n#ifdef HAVE_THREADS\n   if (runloop_st->flags & RUNLOOP_FLAG_AUTOSAVE)\n      autosave_lock();\n#endif\n\n#ifdef HAVE_BSV_MOVIE\n   bsv_movie_next_frame(input_st);\n#endif\n\n   if (     camera_st->cb.caps\n         && camera_st->driver\n         && camera_st->driver->poll\n         && camera_st->data)\n      camera_st->driver->poll(camera_st->data,\n            camera_st->cb.frame_raw_framebuffer,\n            camera_st->cb.frame_opengl_texture);\n\n   /* Update binds for analog dpad modes. */\n   for (i = 0; i < (int)max_users; i++)\n   {\n      dpad_mode[i] = (enum analog_dpad_mode)\n            settings->uints.input_analog_dpad_mode[i];\n\n      switch (dpad_mode[i])\n      {\n         case ANALOG_DPAD_LSTICK:\n         case ANALOG_DPAD_RSTICK:\n            {\n               unsigned mapped_port = settings->uints.input_remap_ports[i];\n               if (input_st->analog_requested[mapped_port])\n                  dpad_mode[i] = ANALOG_DPAD_NONE;\n            }\n            break;\n         case ANALOG_DPAD_LSTICK_FORCED:\n            dpad_mode[i] = ANALOG_DPAD_LSTICK;\n            break;\n         case ANALOG_DPAD_RSTICK_FORCED:\n            dpad_mode[i] = ANALOG_DPAD_RSTICK;\n            break;\n         default:\n            break;\n      }\n\n      /* Push analog to D-Pad mappings to binds. */\n      if (dpad_mode[i] != ANALOG_DPAD_NONE)\n      {\n         unsigned k;\n         unsigned joy_idx                    = settings->uints.input_joypad_index[i];\n         struct retro_keybind *general_binds = input_config_binds[joy_idx];\n         struct retro_keybind *auto_binds    = input_autoconf_binds[joy_idx];\n         unsigned x_plus                     = RARCH_ANALOG_RIGHT_X_PLUS;\n         unsigned y_plus                     = RARCH_ANALOG_RIGHT_Y_PLUS;\n         unsigned x_minus                    = RARCH_ANALOG_RIGHT_X_MINUS;\n         unsigned y_minus                    = RARCH_ANALOG_RIGHT_Y_MINUS;\n\n         if (dpad_mode[i] == ANALOG_DPAD_LSTICK)\n         {\n            x_plus                           = RARCH_ANALOG_LEFT_X_PLUS;\n            y_plus                           = RARCH_ANALOG_LEFT_Y_PLUS;\n            x_minus                          = RARCH_ANALOG_LEFT_X_MINUS;\n            y_minus                          = RARCH_ANALOG_LEFT_Y_MINUS;\n         }\n\n         for (k = RETRO_DEVICE_ID_JOYPAD_UP; k <= RETRO_DEVICE_ID_JOYPAD_RIGHT; k++)\n         {\n            (auto_binds)[k].orig_joyaxis     = (auto_binds)[k].joyaxis;\n            (general_binds)[k].orig_joyaxis  = (general_binds)[k].joyaxis;\n         }\n\n         if (!INHERIT_JOYAXIS(auto_binds))\n         {\n            unsigned j = x_plus + 3;\n            /* Inherit joyaxis from analogs. */\n            for (k = RETRO_DEVICE_ID_JOYPAD_UP; k <= RETRO_DEVICE_ID_JOYPAD_RIGHT; k++)\n               (auto_binds)[k].joyaxis = (auto_binds)[j--].joyaxis;\n         }\n\n         if (!INHERIT_JOYAXIS(general_binds))\n         {\n            unsigned j = x_plus + 3;\n            /* Inherit joyaxis from analogs. */\n            for (k = RETRO_DEVICE_ID_JOYPAD_UP; k <= RETRO_DEVICE_ID_JOYPAD_RIGHT; k++)\n               (general_binds)[k].joyaxis = (general_binds)[j--].joyaxis;\n         }\n      }\n   }\n\n   /* Measure the time between core_run() and video_driver_frame() */\n   runloop_st->core_run_time = cpu_features_get_time_usec();\n\n   {\n#ifdef HAVE_RUNAHEAD\n      bool run_ahead_enabled            = settings->bools.run_ahead_enabled;\n      unsigned run_ahead_num_frames     = settings->uints.run_ahead_frames;\n      bool run_ahead_hide_warnings      = settings->bools.run_ahead_hide_warnings;\n      bool run_ahead_secondary_instance = settings->bools.run_ahead_secondary_instance;\n      /* Run Ahead Feature replaces the call to core_run in this loop */\n      bool want_runahead                = run_ahead_enabled\n            && (run_ahead_num_frames > 0)\n            && (runloop_st->flags & RUNLOOP_FLAG_RUNAHEAD_AVAILABLE);\n#ifdef HAVE_NETWORKING\n      want_runahead                     = want_runahead\n            && !netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_ENABLED, NULL);\n#endif\n\n      if (want_runahead)\n         runahead_run(\n               runloop_st,\n               run_ahead_num_frames,\n               run_ahead_hide_warnings,\n               run_ahead_secondary_instance);\n      else if (runloop_st->preempt_data)\n         preempt_run(runloop_st->preempt_data, runloop_st);\n      else\n#endif\n         core_run();\n   }\n\n   /* Increment runtime tick counter after each call to\n    * core_run() or run_ahead() */\n   runloop_st->core_runtime_usec += runloop_core_runtime_tick(\n         runloop_st,\n         slowmotion_ratio,\n         current_time);\n\n#ifdef HAVE_CHEEVOS\n   if (cheevos_enable)\n      rcheevos_test();\n#endif\n#ifdef HAVE_CHEATS\n   cheat_manager_apply_retro_cheats();\n#endif\n#ifdef HAVE_PRESENCE\n   presence_update(PRESENCE_GAME);\n#endif\n\n   /* Restores analog D-pad binds temporarily overridden. */\n   for (i = 0; i < (int)max_users; i++)\n   {\n      if (dpad_mode[i] != ANALOG_DPAD_NONE)\n      {\n         int j;\n         unsigned joy_idx                    = settings->uints.input_joypad_index[i];\n         struct retro_keybind *general_binds = input_config_binds[joy_idx];\n         struct retro_keybind *auto_binds    = input_autoconf_binds[joy_idx];\n\n         for (j = RETRO_DEVICE_ID_JOYPAD_UP; j <= RETRO_DEVICE_ID_JOYPAD_RIGHT; j++)\n         {\n            (auto_binds)[j].joyaxis    = (auto_binds)[j].orig_joyaxis;\n            (general_binds)[j].joyaxis = (general_binds)[j].orig_joyaxis;\n         }\n      }\n   }\n\n#ifdef HAVE_BSV_MOVIE\n   bsv_movie_finish_rewind(input_st);\n   if (input_st->bsv_movie_state.flags & BSV_FLAG_MOVIE_END)\n   {\n      movie_stop_playback(input_st);\n      command_event(CMD_EVENT_PAUSE, NULL);\n   }\n   if (input_st->bsv_movie_state.flags & BSV_FLAG_MOVIE_END)\n   {\n      movie_stop_playback(input_st);\n      command_event(CMD_EVENT_PAUSE, NULL);\n   }\n#endif\n\n#ifdef HAVE_THREADS\n   if (runloop_st->flags & RUNLOOP_FLAG_AUTOSAVE)\n      autosave_unlock();\n#endif\n\nend:\n   if (vrr_runloop_enable)\n   {\n      /* Sync on video only, block audio later. */\n      if (runloop_st->fastforward_after_frames && audio_sync)\n      {\n         if (runloop_st->fastforward_after_frames == 1)\n         {\n            /* Nonblocking audio */\n            if (    (audio_st->flags & AUDIO_FLAG_ACTIVE)\n                 && (audio_st->context_audio_data))\n               audio_st->current_audio->set_nonblock_state(\n                     audio_st->context_audio_data, true);\n            audio_st->chunk_size =\n               audio_st->chunk_nonblock_size;\n         }\n\n         runloop_st->fastforward_after_frames++;\n\n         if (runloop_st->fastforward_after_frames == 6)\n         {\n            /* Blocking audio */\n            if (     (audio_st->flags & AUDIO_FLAG_ACTIVE)\n                  && (audio_st->context_audio_data))\n               audio_st->current_audio->set_nonblock_state(\n                     audio_st->context_audio_data,\n                     audio_sync ? false : true);\n\n            audio_st->chunk_size = audio_st->chunk_block_size;\n            runloop_st->fastforward_after_frames = 0;\n         }\n      }\n\n      if (runloop_st->flags & RUNLOOP_FLAG_FASTMOTION)\n         runloop_set_frame_limit(&video_st->av_info,\n               runloop_get_fastforward_ratio(settings,\n                  &runloop_st->fastmotion_override.current));\n      else\n         runloop_set_frame_limit(&video_st->av_info, 1.0f);\n   }\n\n   /* if there's a fast forward limit, inject sleeps to keep from going too fast. */\n   if (   (runloop_st->frame_limit_minimum_time)\n          && (   (vrr_runloop_enable)\n              || (runloop_st->flags & RUNLOOP_FLAG_FASTMOTION)\n#ifdef HAVE_MENU\n              || (menu_state_get_ptr()->flags & MENU_ST_FLAG_ALIVE && !(settings->bools.video_vsync))\n#endif\n              || (runloop_st->flags & RUNLOOP_FLAG_PAUSED)))\n   {\n      const retro_time_t end_frame_time  = cpu_features_get_time_usec();\n      const retro_time_t to_sleep_ms     = (\n            (  runloop_st->frame_limit_last_time\n             + runloop_st->frame_limit_minimum_time)\n            - end_frame_time) / 1000;\n\n      if (to_sleep_ms > 0)\n      {\n         unsigned               sleep_ms = (unsigned)to_sleep_ms;\n\n         /* Combat jitter a bit. */\n         runloop_st->frame_limit_last_time +=\n            runloop_st->frame_limit_minimum_time;\n\n         if (sleep_ms > 0)\n         {\n#if defined(HAVE_COCOATOUCH)\n            if (!(uico_state_get_ptr()->flags & UICO_ST_FLAG_IS_ON_FOREGROUND))\n#endif\n               retro_sleep(sleep_ms);\n         }\n\n         return 1;\n      }\n\n      runloop_st->frame_limit_last_time = end_frame_time;\n   }\n\n   /* Frame delay */\n   if (     !(input_st->flags & INP_FLAG_NONBLOCKING)\n         || (runloop_st->flags & RUNLOOP_FLAG_FASTMOTION))\n      video_frame_delay(video_st, settings);\n\n   /* Set paused state after x frames */\n   if (runloop_st->run_frames_and_pause > 0)\n   {\n      runloop_st->run_frames_and_pause--;\n      if (!runloop_st->run_frames_and_pause)\n         runloop_st->flags |= RUNLOOP_FLAG_PAUSED;\n   }\n\n   return 0;\n}\n\nvoid runloop_msg_queue_deinit(void)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n   RUNLOOP_MSG_QUEUE_LOCK(runloop_st);\n\n   msg_queue_deinitialize(&runloop_st->msg_queue);\n\n   RUNLOOP_MSG_QUEUE_UNLOCK(runloop_st);\n#ifdef HAVE_THREADS\n   slock_free(runloop_st->msg_queue_lock);\n   runloop_st->msg_queue_lock = NULL;\n#endif\n\n   runloop_st->msg_queue_size = 0;\n}\n\nvoid runloop_msg_queue_init(void)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n\n   runloop_msg_queue_deinit();\n   msg_queue_initialize(&runloop_st->msg_queue, 8);\n\n#ifdef HAVE_THREADS\n   runloop_st->msg_queue_lock   = slock_new();\n#endif\n}\n\nvoid runloop_task_msg_queue_push(\n      retro_task_t *task, const char *msg,\n      unsigned prio, unsigned duration,\n      bool flush)\n{\n#if defined(HAVE_GFX_WIDGETS)\n#ifdef HAVE_MENU\n   struct menu_state *menu_st     = menu_state_get_ptr();\n#endif\n#ifdef HAVE_ACCESSIBILITY\n   access_state_t *access_st      = access_state_get_ptr();\n   settings_t *settings           = config_get_ptr();\n   bool accessibility_enable      = settings->bools.accessibility_enable;\n   unsigned accessibility_narrator_speech_speed = settings->uints.accessibility_narrator_speech_speed;\n#endif\n   runloop_state_t *runloop_st    = &runloop_state;\n   dispgfx_widget_t *p_dispwidget = dispwidget_get_ptr();\n   bool widgets_active            = p_dispwidget->active;\n\n   if (widgets_active && task->title && (!((task->flags & RETRO_TASK_FLG_MUTE) > 0)))\n   {\n      RUNLOOP_MSG_QUEUE_LOCK(runloop_st);\n      ui_companion_driver_msg_queue_push(msg,\n            prio, task ? duration : duration * 60 / 1000, flush);\n#ifdef HAVE_ACCESSIBILITY\n      if (is_accessibility_enabled(\n            accessibility_enable,\n            access_st->enabled))\n         accessibility_speak_priority(\n               accessibility_enable,\n               accessibility_narrator_speech_speed,\n               (char*)msg, 0);\n#endif\n      gfx_widgets_msg_queue_push(\n            task,\n            msg,\n            strlen(msg),\n            duration,\n            NULL,\n            (enum message_queue_icon)MESSAGE_QUEUE_CATEGORY_INFO,\n            (enum message_queue_category)MESSAGE_QUEUE_ICON_DEFAULT,\n            prio,\n            flush,\n#ifdef HAVE_MENU\n            (menu_st->flags & MENU_ST_FLAG_ALIVE) ? true : false\n#else\n            false\n#endif\n            );\n      RUNLOOP_MSG_QUEUE_UNLOCK(runloop_st);\n   }\n   else\n#endif\n      runloop_msg_queue_push(msg, strlen(msg), prio, duration, flush, NULL,\n            MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n}\n\n\nbool runloop_get_current_savestate_path(char *path, size_t len)\n{\n   settings_t *settings        = config_get_ptr();\n   int state_slot              = settings ? settings->ints.state_slot : 0;\n   return runloop_get_savestate_path(path, len, state_slot);\n}\n\nbool runloop_get_savestate_path(char *path, size_t len, int state_slot)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n   const char *name_savestate  = NULL;\n\n   if (!path)\n      return false;\n\n   name_savestate              = runloop_st->name.savestate;\n   if (string_is_empty(name_savestate))\n      return false;\n\n   if (state_slot < 0)\n      fill_pathname_join_delim(path, name_savestate, \"auto\", '.', len);\n   else\n   {\n      size_t _len = strlcpy(path, name_savestate, len);\n      if (state_slot > 0)\n         snprintf(path + _len, len - _len, \"%d\", state_slot);\n   }\n\n   return true;\n}\n\n\nbool runloop_get_current_replay_path(char *path, size_t len)\n{\n   settings_t *settings = config_get_ptr();\n   int slot = settings ? settings->ints.replay_slot : 0;\n   return runloop_get_replay_path(path, len, slot);\n}\n\nbool runloop_get_replay_path(char *path, size_t len, unsigned slot)\n{\n   size_t _len;\n   runloop_state_t *runloop_st = &runloop_state;\n   const char *name_replay  = NULL;\n\n   if (!path)\n      return false;\n\n   name_replay = runloop_st->name.replay;\n   if (string_is_empty(name_replay))\n      return false;\n\n   _len = strlcpy(path, name_replay, len);\n   if (slot >= 0)\n      snprintf(path + _len, len - _len, \"%d\",  slot);\n\n   return true;\n}\n\n\nbool runloop_get_entry_state_path(char *path, size_t len, unsigned slot)\n{\n   size_t _len;\n   runloop_state_t *runloop_st = &runloop_state;\n   const char *name_savestate  = NULL;\n\n   if (!path || !slot)\n      return false;\n\n   name_savestate              = runloop_st->name.savestate;\n   if (string_is_empty(name_savestate))\n      return false;\n\n   _len = strlcpy(path, name_savestate, len);\n   snprintf(path + _len, len - _len, \"%d.entry\", slot);\n\n   return true;\n}\n\nvoid runloop_set_current_core_type(\n      enum rarch_core_type type, bool explicitly_set)\n{\n   runloop_state_t *runloop_st                = &runloop_state;\n\n   if (runloop_st->flags & RUNLOOP_FLAG_HAS_SET_CORE)\n      return;\n\n   if (explicitly_set)\n   {\n      runloop_st->flags                      |= RUNLOOP_FLAG_HAS_SET_CORE;\n      runloop_st->explicit_current_core_type  = type;\n   }\n   runloop_st->current_core_type              = type;\n}\n\nbool core_set_default_callbacks(void *data)\n{\n   struct retro_callbacks *cbs  = (struct retro_callbacks*)data;\n   retro_input_state_t state_cb = core_input_state_poll_return_cb();\n\n   cbs->frame_cb                = video_driver_frame;\n   cbs->sample_cb               = audio_driver_sample;\n   cbs->sample_batch_cb         = audio_driver_sample_batch;\n   cbs->state_cb                = state_cb;\n   cbs->poll_cb                 = input_driver_poll;\n\n   return true;\n}\n\n#ifdef HAVE_NETWORKING\n/**\n * core_set_netplay_callbacks:\n *\n * Set the I/O callbacks to use netplay's interceding callback system. Should\n * only be called while initializing netplay.\n **/\nbool core_set_netplay_callbacks(void)\n{\n   runloop_state_t *runloop_st        = &runloop_state;\n\n   if (netplay_driver_ctl(RARCH_NETPLAY_CTL_USE_CORE_PACKET_INTERFACE, NULL))\n      return true;\n\n   /* Force normal poll type for netplay. */\n   runloop_st->current_core.poll_type = POLL_TYPE_NORMAL;\n\n   /* And use netplay's interceding callbacks */\n   runloop_st->current_core.retro_set_video_refresh(video_frame_net);\n   runloop_st->current_core.retro_set_audio_sample(audio_sample_net);\n   runloop_st->current_core.retro_set_audio_sample_batch(audio_sample_batch_net);\n   runloop_st->current_core.retro_set_input_state(input_state_net);\n\n   return true;\n}\n\n/**\n * core_unset_netplay_callbacks\n *\n * Unset the I/O callbacks from having used netplay's interceding callback\n * system. Should only be called while uninitializing netplay.\n */\nbool core_unset_netplay_callbacks(void)\n{\n   struct retro_callbacks cbs;\n   runloop_state_t *runloop_st  = &runloop_state;\n\n   if (!core_set_default_callbacks(&cbs))\n      return false;\n\n   runloop_st->current_core.retro_set_video_refresh(cbs.frame_cb);\n   runloop_st->current_core.retro_set_audio_sample(cbs.sample_cb);\n   runloop_st->current_core.retro_set_audio_sample_batch(cbs.sample_batch_cb);\n   runloop_st->current_core.retro_set_input_state(cbs.state_cb);\n\n   return true;\n}\n#endif\n\nbool core_set_cheat(retro_ctx_cheat_info_t *info)\n{\n   runloop_state_t *runloop_st       = &runloop_state;\n#if defined(HAVE_RUNAHEAD) && (defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB))\n   settings_t *settings              = config_get_ptr();\n   bool run_ahead_enabled            = false;\n   unsigned run_ahead_frames         = 0;\n   bool run_ahead_secondary_instance = false;\n   bool want_runahead                = false;\n\n   if (settings)\n   {\n      run_ahead_enabled              = settings->bools.run_ahead_enabled;\n      run_ahead_frames               = settings->uints.run_ahead_frames;\n      run_ahead_secondary_instance   = settings->bools.run_ahead_secondary_instance;\n      want_runahead                  = run_ahead_enabled\n            && (run_ahead_frames > 0)\n            && (runloop_st->flags & RUNLOOP_FLAG_RUNAHEAD_AVAILABLE);\n#ifdef HAVE_NETWORKING\n      if (want_runahead)\n         want_runahead               = !netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_ENABLED, NULL);\n#endif\n   }\n#endif\n\n   runloop_st->current_core.retro_cheat_set(info->index, info->enabled, info->code);\n\n#if defined(HAVE_RUNAHEAD) && (defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB))\n   if (     (want_runahead)\n         && (run_ahead_secondary_instance)\n         && (runloop_st->flags & RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE)\n         && (secondary_core_ensure_exists(runloop_st, settings))\n         && (runloop_st->secondary_core.retro_cheat_set))\n      runloop_st->secondary_core.retro_cheat_set(\n            info->index, info->enabled, info->code);\n#endif\n\n   return true;\n}\n\nbool core_reset_cheat(void)\n{\n   runloop_state_t *runloop_st       = &runloop_state;\n#if defined(HAVE_RUNAHEAD) && (defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB))\n   settings_t *settings              = config_get_ptr();\n   bool run_ahead_enabled            = false;\n   unsigned run_ahead_frames         = 0;\n   bool run_ahead_secondary_instance = false;\n   bool want_runahead                = false;\n\n   if (settings)\n   {\n      run_ahead_enabled              = settings->bools.run_ahead_enabled;\n      run_ahead_frames               = settings->uints.run_ahead_frames;\n      run_ahead_secondary_instance   = settings->bools.run_ahead_secondary_instance;\n      want_runahead                  = run_ahead_enabled\n         && (run_ahead_frames > 0)\n         && (runloop_st->flags & RUNLOOP_FLAG_RUNAHEAD_AVAILABLE);\n#ifdef HAVE_NETWORKING\n      if (want_runahead)\n         want_runahead               = !netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_ENABLED, NULL);\n#endif\n   }\n#endif\n\n   runloop_st->current_core.retro_cheat_reset();\n\n#if defined(HAVE_RUNAHEAD) && (defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB))\n   if (   (want_runahead)\n       && (run_ahead_secondary_instance)\n       && (runloop_st->flags & RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE)\n       && (secondary_core_ensure_exists(runloop_st, settings))\n       && (runloop_st->secondary_core.retro_cheat_reset))\n      runloop_st->secondary_core.retro_cheat_reset();\n#endif\n\n   return true;\n}\n\nbool core_set_poll_type(unsigned type)\n{\n   runloop_state_t *runloop_st        = &runloop_state;\n   runloop_st->current_core.poll_type = type;\n   return true;\n}\n\nbool core_set_controller_port_device(retro_ctx_controller_info_t *pad)\n{\n   runloop_state_t *runloop_st    = &runloop_state;\n   input_driver_state_t *input_st = input_state_get_ptr();\n   if (!pad)\n      return false;\n\n   /* We are potentially 'connecting' a entirely different\n    * type of virtual input device, which may or may not\n    * support analog inputs. We therefore have to reset\n    * the 'analog input requested' flag for this port - but\n    * since port mapping is arbitrary/mutable, it is easiest\n    * to simply reset the flags for all ports.\n    * Correct values will be registered at the next call\n    * of 'input_state()' */\n   memset(&input_st->analog_requested, 0,\n         sizeof(input_st->analog_requested));\n\n#if defined(HAVE_RUNAHEAD)\n#if defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB)\n   runahead_remember_controller_port_device(runloop_st, pad->port, pad->device);\n#endif\n#endif\n\n   runloop_st->current_core.retro_set_controller_port_device(pad->port, pad->device);\n   return true;\n}\n\nbool core_get_memory(retro_ctx_memory_info_t *info)\n{\n   runloop_state_t *runloop_st    = &runloop_state;\n   if (!info)\n      return false;\n   info->size  = runloop_st->current_core.retro_get_memory_size(info->id);\n   info->data  = runloop_st->current_core.retro_get_memory_data(info->id);\n   return true;\n}\n\nbool core_load_game(retro_ctx_load_content_info_t *load_info)\n{\n   bool             game_loaded   = false;\n   video_driver_state_t *video_st = video_state_get_ptr();\n   runloop_state_t *runloop_st    = &runloop_state;\n\n   video_st->frame_cache_data     = NULL;\n\n#ifdef HAVE_RUNAHEAD\n   runahead_set_load_content_info(runloop_st, load_info);\n#if defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB)\n   runahead_clear_controller_port_map(runloop_st);\n#endif\n#endif\n\n   set_save_state_in_background(false);\n\n   if (load_info && load_info->special)\n      game_loaded = runloop_st->current_core.retro_load_game_special(\n            load_info->special->id, load_info->info, load_info->content->size);\n   else if (load_info && !string_is_empty(load_info->content->elems[0].data))\n      game_loaded = runloop_st->current_core.retro_load_game(load_info->info);\n   else if (content_get_flags() & CONTENT_ST_FLAG_CORE_DOES_NOT_NEED_CONTENT)\n      game_loaded = runloop_st->current_core.retro_load_game(NULL);\n\n   if (game_loaded)\n   {\n      /* If 'game_loaded' is true at this point, then\n       * core is actually running; register that any\n       * changes to global remap-related parameters\n       * should be reset once core is deinitialised */\n      input_state_get_ptr()->flags   |=  INP_FLAG_REMAPPING_CACHE_ACTIVE;\n      runloop_st->current_core.flags |=  RETRO_CORE_FLAG_GAME_LOADED;\n      return true;\n   }\n\n   runloop_st->current_core.flags &= ~RETRO_CORE_FLAG_GAME_LOADED;\n   return false;\n}\n\nbool core_get_system_info(struct retro_system_info *sysinfo)\n{\n   runloop_state_t *runloop_st  = &runloop_state;\n   if (!sysinfo)\n      return false;\n   runloop_st->current_core.retro_get_system_info(sysinfo);\n   return true;\n}\n\nbool core_unserialize(retro_ctx_serialize_info_t *info)\n{\n   runloop_state_t *runloop_st  = &runloop_state;\n   if (!info || !runloop_st->current_core.retro_unserialize(info->data_const, info->size))\n      return false;\n\n#ifdef HAVE_NETWORKING\n   netplay_driver_ctl(RARCH_NETPLAY_CTL_LOAD_SAVESTATE, info);\n#endif\n#if HAVE_RUNAHEAD\n   command_event(CMD_EVENT_PREEMPT_RESET_BUFFER, NULL);\n#endif\n\n   return true;\n}\n\nbool core_unserialize_special(retro_ctx_serialize_info_t *info)\n{\n   bool ret;\n   runloop_state_t *runloop_st = &runloop_state;\n\n   if (!info)\n      return false;\n\n   runloop_st->flags |=  RUNLOOP_FLAG_REQUEST_SPECIAL_SAVESTATE;\n   ret = runloop_st->current_core.retro_unserialize(info->data_const, info->size);\n   runloop_st->flags &= ~RUNLOOP_FLAG_REQUEST_SPECIAL_SAVESTATE;\n\n#ifdef HAVE_NETWORKING\n   if (ret)\n      netplay_driver_ctl(RARCH_NETPLAY_CTL_LOAD_SAVESTATE, info);\n#endif\n\n   return ret;\n}\n\nbool core_serialize(retro_ctx_serialize_info_t *info)\n{\n   runloop_state_t *runloop_st  = &runloop_state;\n   if (!info || !runloop_st->current_core.retro_serialize(info->data, info->size))\n      return false;\n   return true;\n}\n\nbool core_serialize_special(retro_ctx_serialize_info_t *info)\n{\n   bool ret;\n   runloop_state_t *runloop_st = &runloop_state;\n\n   if (!info)\n      return false;\n\n   runloop_st->flags |=  RUNLOOP_FLAG_REQUEST_SPECIAL_SAVESTATE;\n   ret                = runloop_st->current_core.retro_serialize(\n                        info->data, info->size);\n   runloop_st->flags &= ~RUNLOOP_FLAG_REQUEST_SPECIAL_SAVESTATE;\n\n   return ret;\n}\n\nsize_t core_serialize_size(void)\n{\n   runloop_state_t *runloop_st  = &runloop_state;\n   return runloop_st->current_core.retro_serialize_size();\n}\n\nsize_t core_serialize_size_special(void)\n{\n   size_t val;\n   runloop_state_t *runloop_st = &runloop_state;\n   runloop_st->flags |=  RUNLOOP_FLAG_REQUEST_SPECIAL_SAVESTATE;\n   val                = runloop_st->current_core.retro_serialize_size();\n   runloop_st->flags &= ~RUNLOOP_FLAG_REQUEST_SPECIAL_SAVESTATE;\n\n   return val;\n}\n\nuint64_t core_serialization_quirks(void)\n{\n   runloop_state_t *runloop_st  = &runloop_state;\n   return runloop_st->current_core.serialization_quirks_v;\n}\n\nvoid core_reset(void)\n{\n   runloop_state_t *runloop_st    = &runloop_state;\n   video_driver_state_t *video_st = video_state_get_ptr();\n   video_st->frame_cache_data     = NULL;\n   runloop_st->current_core.retro_reset();\n}\n\nvoid core_run(void)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n   struct retro_core_t *\n      current_core             = &runloop_st->current_core;\n   const enum poll_type_override_t\n      core_poll_type_override  = runloop_st->core_poll_type_override;\n   unsigned new_poll_type      = (core_poll_type_override != POLL_TYPE_OVERRIDE_DONTCARE)\n      ? (core_poll_type_override - 1)\n      : current_core->poll_type;\n   bool early_polling          = new_poll_type == POLL_TYPE_EARLY;\n   bool late_polling           = new_poll_type == POLL_TYPE_LATE;\n#ifdef HAVE_NETWORKING\n   bool netplay_preframe       = netplay_driver_ctl(\n         RARCH_NETPLAY_CTL_PRE_FRAME, NULL);\n\n   if (!netplay_preframe)\n   {\n      /* Paused due to netplay. We must poll and display something so that a\n       * netplay peer pausing doesn't just hang. */\n      input_driver_poll();\n      video_driver_cached_frame();\n      return;\n   }\n#endif\n\n   if (early_polling)\n      input_driver_poll();\n   else if (late_polling)\n      current_core->flags &= ~RETRO_CORE_FLAG_INPUT_POLLED;\n\n   current_core->retro_run();\n\n   if (      late_polling\n         && (!(current_core->flags & RETRO_CORE_FLAG_INPUT_POLLED)))\n      input_driver_poll();\n\n#ifdef HAVE_NETWORKING\n   netplay_driver_ctl(RARCH_NETPLAY_CTL_POST_FRAME, NULL);\n#endif\n}\n\nbool core_has_set_input_descriptor(void)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n   return ((runloop_st->current_core.flags &\n            RETRO_CORE_FLAG_HAS_SET_INPUT_DESCRIPTORS) > 0);\n}\n\nvoid runloop_path_set_basename(const char *path)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n   char *dst                   = NULL;\n\n   path_set(RARCH_PATH_CONTENT,  path);\n   strlcpy(runloop_st->runtime_content_path_basename, path,\n         sizeof(runloop_st->runtime_content_path_basename));\n\n#ifdef HAVE_COMPRESSION\n   /* Removing extension is a bit tricky for compressed files.\n    * Basename means:\n    * /file/to/path/game.extension should be:\n    * /file/to/path/game\n    *\n    * Two things to consider here are: /file/to/path/ is expected\n    * to be a directory and \"game\" is a single file. This is used for\n    * states and srm default paths.\n    *\n    * For compressed files we have:\n    *\n    * /file/to/path/comp.7z#game.extension and\n    * /file/to/path/comp.7z#folder/game.extension\n    *\n    * The choice I take here is:\n    * /file/to/path/game as basename. We might end up in a writable\n    * directory then and the name of srm and states are meaningful.\n    *\n    */\n   path_basedir_wrapper(runloop_st->runtime_content_path_basename);\n   if (!string_is_empty(runloop_st->runtime_content_path_basename))\n      fill_pathname_dir(runloop_st->runtime_content_path_basename, path, \"\", sizeof(runloop_st->runtime_content_path_basename));\n#endif\n\n   if ((dst = strrchr(runloop_st->runtime_content_path_basename, '.')))\n      *dst = '\\0';\n}\n\nvoid runloop_path_set_names(void)\n{\n   runloop_state_t *runloop_st = &runloop_state;\n   if (!retroarch_override_setting_is_set(\n            RARCH_OVERRIDE_SETTING_SAVE_PATH, NULL))\n      fill_pathname(runloop_st->name.savefile,\n             runloop_st->runtime_content_path_basename,\n             \".srm\",\n             sizeof(runloop_st->name.savefile));\n\n   if (!retroarch_override_setting_is_set(\n            RARCH_OVERRIDE_SETTING_STATE_PATH, NULL))\n      fill_pathname(runloop_st->name.savestate,\n            runloop_st->runtime_content_path_basename,\n            \".state\",\n            sizeof(runloop_st->name.savestate));\n\n#ifdef HAVE_BSV_MOVIE\n   if (!retroarch_override_setting_is_set(\n            RARCH_OVERRIDE_SETTING_STATE_PATH, NULL))\n      fill_pathname(\n            runloop_st->name.replay,\n            runloop_st->runtime_content_path_basename,\n            \".replay\",\n            sizeof(runloop_st->name.replay));\n#endif\n\n#ifdef HAVE_CHEATS\n   if (!string_is_empty(runloop_st->runtime_content_path_basename))\n      fill_pathname(\n            runloop_st->name.cheatfile,\n            runloop_st->runtime_content_path_basename,\n            \".cht\",\n            sizeof(runloop_st->name.cheatfile));\n#endif\n}\n\nvoid runloop_path_set_redirect(settings_t *settings,\n                               const char *old_savefile_dir,\n                               const char *old_savestate_dir)\n{\n   char content_dir_name[DIR_MAX_LENGTH];\n   char new_savefile_dir[DIR_MAX_LENGTH];\n   char new_savestate_dir[DIR_MAX_LENGTH];\n   char intermediate_savefile_dir[DIR_MAX_LENGTH];\n   char intermediate_savestate_dir[DIR_MAX_LENGTH];\n   runloop_state_t *runloop_st            = &runloop_state;\n   struct retro_system_info *sysinfo      = &runloop_st->system.info;\n   bool sort_savefiles_enable             = settings->bools.sort_savefiles_enable;\n   bool sort_savefiles_by_content_enable  = settings->bools.sort_savefiles_by_content_enable;\n   bool sort_savestates_enable            = settings->bools.sort_savestates_enable;\n   bool sort_savestates_by_content_enable = settings->bools.sort_savestates_by_content_enable;\n   bool savefiles_in_content_dir          = settings->bools.savefiles_in_content_dir;\n   bool savestates_in_content_dir         = settings->bools.savestates_in_content_dir;\n\n   content_dir_name[0] = '\\0';\n\n   /* Initialize current save directories\n    * with the values from the config. */\n   strlcpy(intermediate_savefile_dir, old_savefile_dir, sizeof(intermediate_savefile_dir));\n   strlcpy(intermediate_savestate_dir, old_savestate_dir, sizeof(intermediate_savestate_dir));\n\n   /* Get content directory name, if per-content-directory\n    * saves/states are enabled */\n   if ((   sort_savefiles_by_content_enable\n        || sort_savestates_by_content_enable)\n       && !string_is_empty(runloop_st->runtime_content_path_basename))\n      fill_pathname_parent_dir_name(content_dir_name,\n                                    runloop_st->runtime_content_path_basename,\n                                    sizeof(content_dir_name));\n\n   /* Set savefile directory if empty to content directory */\n   if (     string_is_empty(intermediate_savefile_dir)\n         || savefiles_in_content_dir)\n   {\n      strlcpy(intermediate_savefile_dir,\n              runloop_st->runtime_content_path_basename,\n              sizeof(intermediate_savefile_dir));\n      path_basedir(intermediate_savefile_dir);\n\n      if (string_is_empty(intermediate_savefile_dir))\n         RARCH_LOG(\"Cannot resolve save file path.\\n\");\n   }\n\n   /* Set savestate directory if empty based on content directory */\n   if (   string_is_empty(intermediate_savestate_dir)\n       || savestates_in_content_dir)\n   {\n      strlcpy(intermediate_savestate_dir,\n              runloop_st->runtime_content_path_basename,\n              sizeof(intermediate_savestate_dir));\n      path_basedir(intermediate_savestate_dir);\n\n      if (string_is_empty(intermediate_savestate_dir))\n         RARCH_LOG(\"Cannot resolve save state file path.\\n\");\n   }\n\n   strlcpy(new_savefile_dir, intermediate_savefile_dir, sizeof(new_savefile_dir));\n   strlcpy(new_savestate_dir, intermediate_savestate_dir, sizeof(new_savestate_dir));\n\n   if (sysinfo && !string_is_empty(sysinfo->library_name))\n   {\n#ifdef HAVE_MENU\n      if (!string_is_equal(sysinfo->library_name,\n                           msg_hash_to_str(MENU_ENUM_LABEL_VALUE_NO_CORE)))\n#endif\n      {\n         /* Per-core and/or per-content-directory saves */\n         if ((sort_savefiles_enable\n              || sort_savefiles_by_content_enable)\n             && !string_is_empty(new_savefile_dir))\n         {\n            /* Append content directory name to save location */\n            if (sort_savefiles_by_content_enable)\n               fill_pathname_join_special(\n                  new_savefile_dir,\n                  intermediate_savefile_dir,\n                  content_dir_name,\n                  sizeof(new_savefile_dir));\n\n            /* Append library_name to the save location */\n            if (sort_savefiles_enable)\n               fill_pathname_join(\n                  new_savefile_dir,\n                  new_savefile_dir,\n                  sysinfo->library_name,\n                  sizeof(new_savefile_dir));\n\n            /* If path doesn't exist, try to create it,\n             * if everything fails revert to the original path. */\n            if (!path_is_directory(new_savefile_dir))\n               if (!path_mkdir(new_savefile_dir))\n               {\n                  RARCH_LOG(\"%s %s\\n\",\n                            msg_hash_to_str(MSG_REVERTING_SAVEFILE_DIRECTORY_TO),\n                            intermediate_savefile_dir);\n                  strlcpy(new_savefile_dir,\n                        intermediate_savefile_dir,\n                        sizeof(new_savefile_dir));\n               }\n         }\n\n         /* Per-core and/or per-content-directory savestates */\n         if ((sort_savestates_enable || sort_savestates_by_content_enable)\n             && !string_is_empty(new_savestate_dir))\n         {\n            /* Append content directory name to savestate location */\n            if (sort_savestates_by_content_enable)\n               fill_pathname_join_special(\n                  new_savestate_dir,\n                  intermediate_savestate_dir,\n                  content_dir_name,\n                  sizeof(new_savestate_dir));\n\n            /* Append library_name to the savestate location */\n            if (sort_savestates_enable)\n               fill_pathname_join(\n                  new_savestate_dir,\n                  new_savestate_dir,\n                  sysinfo->library_name,\n                  sizeof(new_savestate_dir));\n\n            /* If path doesn't exist, try to create it.\n             * If everything fails, revert to the original path. */\n            if (!path_is_directory(new_savestate_dir))\n               if (!path_mkdir(new_savestate_dir))\n               {\n                  RARCH_LOG(\"%s %s\\n\",\n                            msg_hash_to_str(MSG_REVERTING_SAVESTATE_DIRECTORY_TO),\n                            intermediate_savestate_dir);\n                  strlcpy(new_savestate_dir,\n                          intermediate_savestate_dir,\n                          sizeof(new_savestate_dir));\n               }\n         }\n      }\n   }\n\n\n#ifdef HAVE_NETWORKING\n   /* Special save directory for netplay clients. */\n   if (      netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_ENABLED, NULL)\n         && !netplay_driver_ctl(RARCH_NETPLAY_CTL_IS_SERVER, NULL)\n         && !netplay_driver_ctl(RARCH_NETPLAY_CTL_USE_CORE_PACKET_INTERFACE, NULL))\n   {\n      fill_pathname_join(new_savefile_dir,\n            new_savefile_dir, \".netplay\",\n            sizeof(new_savefile_dir));\n\n      if (     !path_is_directory(new_savefile_dir)\n            && !path_mkdir(new_savefile_dir))\n         path_basedir(new_savefile_dir);\n   }\n#endif\n\n   if (sysinfo && !string_is_empty(sysinfo->library_name))\n   {\n      bool savefile_is_dir  = path_is_directory(new_savefile_dir);\n      bool savestate_is_dir = path_is_directory(new_savestate_dir);\n      if (savefile_is_dir)\n         strlcpy(runloop_st->name.savefile, new_savefile_dir,\n                 sizeof(runloop_st->name.savefile));\n      else\n         savefile_is_dir = path_is_directory(runloop_st->name.savefile);\n\n      if (savestate_is_dir)\n      {\n         strlcpy(runloop_st->name.savestate, new_savestate_dir,\n                 sizeof(runloop_st->name.savestate));\n         strlcpy(runloop_st->name.replay, new_savestate_dir,\n                 sizeof(runloop_st->name.replay));\n      }\n      else\n         savestate_is_dir = path_is_directory(runloop_st->name.savestate);\n\n      if (savefile_is_dir)\n      {\n         fill_pathname_dir(runloop_st->name.savefile,\n                           !string_is_empty(runloop_st->runtime_content_path_basename)\n                           ? runloop_st->runtime_content_path_basename\n                           : sysinfo->library_name,\n                           FILE_PATH_SRM_EXTENSION,\n                           sizeof(runloop_st->name.savefile));\n         RARCH_LOG(\"[Overrides]: %s \\\"%s\\\".\\n\",\n                   msg_hash_to_str(MSG_REDIRECTING_SAVEFILE_TO),\n                   runloop_st->name.savefile);\n      }\n\n      if (savestate_is_dir)\n      {\n         fill_pathname_dir(runloop_st->name.savestate,\n                           !string_is_empty(runloop_st->runtime_content_path_basename)\n                           ? runloop_st->runtime_content_path_basename\n                           : sysinfo->library_name,\n                           FILE_PATH_STATE_EXTENSION,\n                           sizeof(runloop_st->name.savestate));\n         fill_pathname_dir(runloop_st->name.replay,\n                           !string_is_empty(runloop_st->runtime_content_path_basename)\n                           ? runloop_st->runtime_content_path_basename\n                           : sysinfo->library_name,\n                           FILE_PATH_BSV_EXTENSION,\n                           sizeof(runloop_st->name.replay));\n         RARCH_LOG(\"[Overrides]: %s \\\"%s\\\".\\n\",\n                   msg_hash_to_str(MSG_REDIRECTING_SAVESTATE_TO),\n                   runloop_st->name.savestate);\n      }\n\n#ifdef HAVE_CHEATS\n      if (path_is_directory(runloop_st->name.cheatfile))\n      {\n         fill_pathname_dir(runloop_st->name.cheatfile,\n               !string_is_empty(runloop_st->runtime_content_path_basename)\n               ? runloop_st->runtime_content_path_basename\n               : sysinfo->library_name,\n               FILE_PATH_CHT_EXTENSION,\n               sizeof(runloop_st->name.cheatfile));\n         RARCH_LOG(\"[Overrides]: %s \\\"%s\\\".\\n\",\n               msg_hash_to_str(MSG_REDIRECTING_CHEATFILE_TO),\n               runloop_st->name.cheatfile);\n      }\n#endif\n   }\n\n   dir_set(RARCH_DIR_CURRENT_SAVEFILE, new_savefile_dir);\n   dir_set(RARCH_DIR_CURRENT_SAVESTATE, new_savestate_dir);\n}\n\nvoid runloop_path_deinit_subsystem(void)\n{\n   runloop_state_t *runloop_st  = &runloop_state;\n   if (runloop_st->subsystem_fullpaths)\n      string_list_free(runloop_st->subsystem_fullpaths);\n   runloop_st->subsystem_fullpaths = NULL;\n}\n\nvoid runloop_path_set_special(char **argv, unsigned num_content)\n{\n   unsigned i;\n   char str[PATH_MAX_LENGTH];\n   union string_list_elem_attr attr;\n   bool is_dir                         = false;\n   struct string_list subsystem_paths  = {0};\n   runloop_state_t         *runloop_st = &runloop_state;\n   const char *savestate_dir           = runloop_st->savestate_dir;\n\n   /* First content file is the significant one. */\n   runloop_path_set_basename(argv[0]);\n\n   string_list_initialize(&subsystem_paths);\n\n   runloop_st->subsystem_fullpaths     = string_list_new();\n\n   attr.i = 0;\n\n   for (i = 0; i < num_content; i++)\n   {\n      string_list_append(runloop_st->subsystem_fullpaths, argv[i], attr);\n      fill_pathname(str, argv[i], \"\", sizeof(str));\n      string_list_append(&subsystem_paths, path_basename(str), attr);\n   }\n\n   str[0] = '\\0';\n   string_list_join_concat(str, sizeof(str), &subsystem_paths, \" + \");\n   string_list_deinitialize(&subsystem_paths);\n\n   /* We defer SRAM path updates until we can resolve it.\n    * It is more complicated for special content types. */\n   is_dir = path_is_directory(savestate_dir);\n\n   if (is_dir)\n   {\n      strlcpy(runloop_st->name.savestate, savestate_dir,\n              sizeof(runloop_st->name.savestate));\n      strlcpy(runloop_st->name.replay, savestate_dir,\n              sizeof(runloop_st->name.replay));\n   }\n   else\n      is_dir   = path_is_directory(runloop_st->name.savestate);\n\n   if (is_dir)\n   {\n      fill_pathname_dir(runloop_st->name.savestate,\n            str,\n            \".state\",\n            sizeof(runloop_st->name.savestate));\n      fill_pathname_dir(runloop_st->name.replay,\n            str,\n            \".replay\",\n            sizeof(runloop_st->name.replay));\n      RARCH_LOG(\"%s \\\"%s\\\".\\n\",\n            msg_hash_to_str(MSG_REDIRECTING_SAVESTATE_TO),\n            runloop_st->name.savestate);\n   }\n}\n"
        },
        {
          "name": "runloop.h",
          "type": "blob",
          "size": 15.3046875,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2021 - Daniel De Matteis\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __RUNLOOP_H\n#define __RUNLOOP_H\n\n#include <stdint.h>\n#include <stddef.h>\n#include <stdlib.h>\n\n#include <boolean.h>\n#include <retro_inline.h>\n#include <retro_common_api.h>\n#include <libretro.h>\n#include <dynamic/dylib.h>\n#include <queues/message_queue.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef HAVE_THREADS\n#include <rthreads/rthreads.h>\n#endif\n\n#include \"dynamic.h\"\n#include \"configuration.h\"\n#include \"core_option_manager.h\"\n#include \"performance_counters.h\"\n#include \"state_manager.h\"\n#ifdef HAVE_RUNAHEAD\n#include \"runahead.h\"\n#endif\n#include \"tasks/tasks_internal.h\"\n\n/* Arbitrary twenty subsystems limit */\n#define SUBSYSTEM_MAX_SUBSYSTEMS 20\n\n/* Arbitrary 10 roms for each subsystem limit */\n#define SUBSYSTEM_MAX_SUBSYSTEM_ROMS 10\n\n#ifdef HAVE_THREADS\n#define RUNLOOP_MSG_QUEUE_LOCK(runloop_st) slock_lock((runloop_st)->msg_queue_lock)\n#define RUNLOOP_MSG_QUEUE_UNLOCK(runloop_st) slock_unlock((runloop_st)->msg_queue_lock)\n#else\n#define RUNLOOP_MSG_QUEUE_LOCK(runloop_st) (void)(runloop_st)\n#define RUNLOOP_MSG_QUEUE_UNLOCK(runloop_st) (void)(runloop_st)\n#endif\n\n#ifdef HAVE_BSV_MOVIE\n#define BSV_MOVIE_IS_EOF() || (((input_st->bsv_movie_state.flags & BSV_FLAG_MOVIE_END) && (input_st->bsv_movie_state.flags & BSV_FLAG_MOVIE_EOF_EXIT)))\n#else\n#define BSV_MOVIE_IS_EOF()\n#endif\n\n/* Time to exit out of the main loop?\n * Reasons for exiting:\n * a) Shutdown environment callback was invoked.\n * b) Quit key was pressed.\n * c) Frame count exceeds or equals maximum amount of frames to run.\n * d) Video driver no longer alive.\n * e) End of BSV movie and BSV EOF exit is true. (TODO/FIXME - explain better)\n */\n#define RUNLOOP_TIME_TO_EXIT(quit_key_pressed) ((runloop_state.flags & RUNLOOP_FLAG_SHUTDOWN_INITIATED) || quit_key_pressed || !is_alive BSV_MOVIE_IS_EOF() || ((runloop_state.max_frames != 0) && (frame_count >= runloop_state.max_frames)) || runloop_exec)\n\nenum runloop_state_enum\n{\n   RUNLOOP_STATE_ITERATE = 0,\n   RUNLOOP_STATE_POLLED_AND_SLEEP,\n   RUNLOOP_STATE_PAUSE,\n   RUNLOOP_STATE_MENU,\n   RUNLOOP_STATE_QUIT\n};\n\nenum poll_type_override_t\n{\n   POLL_TYPE_OVERRIDE_DONTCARE = 0,\n   POLL_TYPE_OVERRIDE_EARLY,\n   POLL_TYPE_OVERRIDE_NORMAL,\n   POLL_TYPE_OVERRIDE_LATE\n};\n\nenum runloop_flags\n{\n   RUNLOOP_FLAG_MAX_FRAMES_SCREENSHOT             = (1 << 0),\n   RUNLOOP_FLAG_HAS_SET_CORE                      = (1 << 1),\n   RUNLOOP_FLAG_CORE_SET_SHARED_CONTEXT           = (1 << 2),\n   RUNLOOP_FLAG_IGNORE_ENVIRONMENT_CB             = (1 << 3),\n   RUNLOOP_FLAG_IS_SRAM_LOAD_DISABLED             = (1 << 4),\n   RUNLOOP_FLAG_IS_SRAM_SAVE_DISABLED             = (1 << 5),\n   RUNLOOP_FLAG_USE_SRAM                          = (1 << 6),\n   RUNLOOP_FLAG_PATCH_BLOCKED                     = (1 << 7),\n   RUNLOOP_FLAG_REQUEST_SPECIAL_SAVESTATE         = (1 << 8),\n   RUNLOOP_FLAG_OVERRIDES_ACTIVE                  = (1 << 9),\n   RUNLOOP_FLAG_GAME_OPTIONS_ACTIVE               = (1 << 10),\n   RUNLOOP_FLAG_FOLDER_OPTIONS_ACTIVE             = (1 << 11),\n   RUNLOOP_FLAG_REMAPS_CORE_ACTIVE                = (1 << 12),\n   RUNLOOP_FLAG_REMAPS_GAME_ACTIVE                = (1 << 13),\n   RUNLOOP_FLAG_REMAPS_CONTENT_DIR_ACTIVE         = (1 << 14),\n   RUNLOOP_FLAG_SHUTDOWN_INITIATED                = (1 << 15),\n   RUNLOOP_FLAG_CORE_SHUTDOWN_INITIATED           = (1 << 16),\n   RUNLOOP_FLAG_CORE_RUNNING                      = (1 << 17),\n   RUNLOOP_FLAG_AUTOSAVE                          = (1 << 18),\n   RUNLOOP_FLAG_HAS_VARIABLE_UPDATE               = (1 << 19),\n   RUNLOOP_FLAG_INPUT_IS_DIRTY                    = (1 << 20),\n   RUNLOOP_FLAG_RUNAHEAD_SAVE_STATE_SIZE_KNOWN    = (1 << 21),\n   RUNLOOP_FLAG_RUNAHEAD_AVAILABLE                = (1 << 22),\n   RUNLOOP_FLAG_RUNAHEAD_SECONDARY_CORE_AVAILABLE = (1 << 23),\n   RUNLOOP_FLAG_RUNAHEAD_FORCE_INPUT_DIRTY        = (1 << 24),\n   RUNLOOP_FLAG_SLOWMOTION                        = (1 << 25),\n   RUNLOOP_FLAG_FASTMOTION                        = (1 << 26),\n   RUNLOOP_FLAG_PAUSED                            = (1 << 27),\n   RUNLOOP_FLAG_IDLE                              = (1 << 28),\n   RUNLOOP_FLAG_FOCUSED                           = (1 << 29),\n   RUNLOOP_FLAG_FORCE_NONBLOCK                    = (1 << 30),\n   RUNLOOP_FLAG_IS_INITED                         = (1 << 31)\n};\n\n/* Contains the current retro_fastforwarding_override\n * parameters along with any pending updates triggered\n * by RETRO_ENVIRONMENT_SET_FASTFORWARDING_OVERRIDE */\ntypedef struct fastmotion_overrides\n{\n   struct retro_fastforwarding_override current;\n   struct retro_fastforwarding_override next;\n   bool pending;\n} fastmotion_overrides_t;\n\ntypedef struct\n{\n   unsigned priority;\n   float duration;\n   char str[128];\n   bool set;\n} runloop_core_status_msg_t;\n\n/* Contains all callbacks associated with\n * core options.\n * > At present there is only a single\n *   callback, 'update_display' - but we\n *   may wish to add more in the future\n *   (e.g. for directly informing a core of\n *   core option value changes, or getting/\n *   setting extended/non-standard option\n *   value data types) */\ntypedef struct core_options_callbacks\n{\n   retro_core_options_update_display_callback_t update_display;\n} core_options_callbacks_t;\n\nstruct runloop\n{\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n   rarch_timer_t shader_delay_timer;            /* int64_t alignment */\n#endif\n   retro_time_t core_runtime_last;\n   retro_time_t core_runtime_usec;\n   retro_time_t core_run_time;\n   retro_time_t frame_limit_minimum_time;\n   retro_time_t frame_limit_last_time;\n   retro_usec_t frame_time_last;                /* int64_t alignment */\n\n   struct retro_core_t        current_core;     /* uint64_t alignment */\n#if defined(HAVE_RUNAHEAD)\n   uint64_t runahead_last_frame_count;          /* uint64_t alignment */\n#if defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB)\n   struct retro_core_t secondary_core;          /* uint64_t alignment */\n#endif\n   retro_ctx_load_content_info_t *load_content_info;\n#if defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB)\n   char    *secondary_library_path;\n#endif\n   my_list *runahead_save_state_list;\n   my_list *input_state_list;\n   preempt_t *preempt_data;\n#endif\n\n#ifdef HAVE_REWIND\n   struct state_manager_rewind_state rewind_st;\n#endif\n   struct retro_perf_counter *perf_counters_libretro[MAX_COUNTERS];\n   bool    *load_no_content_hook;\n   struct string_list *subsystem_fullpaths;\n   struct retro_subsystem_info subsystem_data[SUBSYSTEM_MAX_SUBSYSTEMS];\n   struct retro_callbacks retro_ctx;                     /* ptr alignment */\n   msg_queue_t msg_queue;                                /* ptr alignment */\n   retro_input_poll_t input_poll_callback_original;      /* ptr alignment */\n   retro_input_state_t input_state_callback_original;    /* ptr alignment */\n#ifdef HAVE_RUNAHEAD\n   function_t retro_reset_callback_original;             /* ptr alignment */\n   function_t original_retro_deinit;                     /* ptr alignment */\n   function_t original_retro_unload;                     /* ptr alignment */\n   runahead_load_state_function\n      retro_unserialize_callback_original;               /* ptr alignment */\n#if defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB)\n   struct retro_callbacks secondary_callbacks;           /* ptr alignment */\n#endif\n#endif\n#ifdef HAVE_THREADS\n   slock_t *msg_queue_lock;\n#endif\n\n   content_state_t            content_st;                /* ptr alignment */\n   struct retro_subsystem_rom_info\n      subsystem_data_roms[SUBSYSTEM_MAX_SUBSYSTEMS]\n      [SUBSYSTEM_MAX_SUBSYSTEM_ROMS];             /* ptr alignment */\n   core_option_manager_t *core_options;\n   core_options_callbacks_t core_options_callback;/* ptr alignment */\n\n   retro_keyboard_event_t key_event;             /* ptr alignment */\n   retro_keyboard_event_t frontend_key_event;    /* ptr alignment */\n\n   rarch_system_info_t system;                   /* ptr alignment */\n   struct retro_frame_time_callback frame_time;  /* ptr alignment */\n   struct retro_audio_buffer_status_callback audio_buffer_status; /* ptr alignment */\n#ifdef HAVE_DYNAMIC\n   dylib_t lib_handle;                                   /* ptr alignment */\n#endif\n#if defined(HAVE_RUNAHEAD)\n#if defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB)\n   dylib_t secondary_lib_handle;                         /* ptr alignment */\n#endif\n   size_t runahead_save_state_size;\n#endif\n   size_t msg_queue_size;\n\n#if defined(HAVE_RUNAHEAD)\n#if defined(HAVE_DYNAMIC) || defined(HAVE_DYLIB)\n   int port_map[MAX_USERS];\n#endif\n#endif\n\n   runloop_core_status_msg_t core_status_msg;\n\n   unsigned msg_queue_delay;\n   unsigned pending_windowed_scale;\n   unsigned max_frames;\n   unsigned audio_latency;\n   unsigned fastforward_after_frames;\n   unsigned perf_ptr_libretro;\n   unsigned subsystem_current_count;\n   unsigned entry_state_slot;\n   unsigned video_swap_interval_auto;\n\n   fastmotion_overrides_t fastmotion_override; /* float alignment */\n\n   retro_bits_t has_set_libretro_device;        /* uint32_t alignment */\n\n   enum rarch_core_type current_core_type;\n   enum rarch_core_type explicit_current_core_type;\n   enum poll_type_override_t core_poll_type_override;\n#if defined(HAVE_RUNAHEAD)\n   enum rarch_core_type last_core_type;\n#endif\n\n   uint32_t flags;\n   int8_t run_frames_and_pause;\n\n   char runtime_content_path_basename[PATH_MAX_LENGTH];\n#ifdef HAVE_SCREENSHOTS\n   char max_frames_screenshot_path[PATH_MAX_LENGTH];\n#endif\n#if defined(HAVE_CG) || defined(HAVE_GLSL) || defined(HAVE_SLANG) || defined(HAVE_HLSL)\n   char runtime_shader_preset_path[PATH_MAX_LENGTH];\n#endif\n   char runtime_content_path[PATH_MAX_LENGTH];\n   char runtime_core_path[PATH_MAX_LENGTH];\n   char savefile_dir[DIR_MAX_LENGTH];\n   char savestate_dir[DIR_MAX_LENGTH];\n   char current_library_name[NAME_MAX_LENGTH];\n   char current_valid_extensions[256];\n   char subsystem_path[256];\n   char current_library_version[64];\n\n   struct\n   {\n      char *remapfile;\n      char savefile [PATH_MAX_LENGTH*2];\n      char savestate[PATH_MAX_LENGTH*2];\n      char replay   [PATH_MAX_LENGTH*2];\n      char cheatfile[PATH_MAX_LENGTH*2];\n      char ups      [PATH_MAX_LENGTH*2];\n      char bps      [PATH_MAX_LENGTH*2];\n      char ips      [PATH_MAX_LENGTH*2];\n      char xdelta   [PATH_MAX_LENGTH*2];\n      char label    [PATH_MAX_LENGTH*2];\n   } name;\n\n   bool missing_bios;\n   bool perfcnt_enable;\n};\n\ntypedef struct runloop runloop_state_t;\n\nRETRO_BEGIN_DECLS\n\nvoid runloop_path_fill_names(void);\n\n/**\n * runloop_environment_cb:\n * @cmd                          : Identifier of command.\n * @data                         : Pointer to data.\n *\n * Environment callback function implementation.\n *\n * Returns: true (1) if environment callback command could\n * be performed, otherwise false (0).\n **/\nbool runloop_environment_cb(unsigned cmd, void *data);\n\nvoid runloop_msg_queue_push(const char *msg, size_t len,\n      unsigned prio, unsigned duration,\n      bool flush,\n      char *title,\n      enum message_queue_icon icon,\n      enum message_queue_category category);\n\nvoid runloop_set_current_core_type(\n      enum rarch_core_type type, bool explicitly_set);\n\n/**\n * runloop_iterate:\n *\n * Run Libretro core in RetroArch for one frame.\n *\n * Returns: 0 on successful run,\n * Returns 1 if we have to wait until button input in order\n * to wake up the loop.\n * Returns -1 if we forcibly quit out of the\n * RetroArch iteration loop.\n **/\nint runloop_iterate(void);\n\nvoid runloop_system_info_free(void);\n\n/**\n * libretro_get_system_info:\n * @path                         : Path to libretro library.\n * @info                         : Pointer to system info information.\n * @load_no_content              : If true, core should be able to auto-start\n *                                 without any content loaded.\n *\n * Gets system info from an arbitrary lib.\n * The struct returned must be freed as strings are allocated dynamically.\n *\n * Returns: true (1) if successful, otherwise false (0).\n **/\nbool libretro_get_system_info(\n      const char *path,\n      struct retro_system_info *info,\n      bool *load_no_content);\n\nvoid runloop_performance_counter_register(\n      struct retro_perf_counter *perf);\n\nvoid runloop_runtime_log_deinit(\n      runloop_state_t *runloop_st,\n      bool content_runtime_log,\n      bool content_runtime_log_aggregate,\n      const char *dir_runtime_log,\n      const char *dir_playlist);\n\nvoid runloop_event_deinit_core(void);\n\nbool runloop_event_init_core(\n      settings_t *settings,\n      void *input_data,\n      enum rarch_core_type type,\n      const char *old_savefile_dir,\n      const char *old_savestate_dir\n      );\n\nvoid runloop_pause_checks(void);\n\nvoid runloop_set_frame_limit(\n      const struct retro_system_av_info *av_info,\n      float fastforward_ratio);\n\nfloat runloop_get_fastforward_ratio(\n      settings_t *settings,\n      struct retro_fastforwarding_override *fastmotion_override);\n\nvoid runloop_set_video_swap_interval(\n      bool vrr_runloop_enable,\n      bool crt_switching_active,\n      unsigned swap_interval_config,\n      unsigned black_frame_insertion,\n      unsigned shader_subframes,\n      float audio_max_timing_skew,\n      float video_refresh_rate,\n      double input_fps);\nunsigned runloop_get_video_swap_interval(\n      unsigned swap_interval_config);\n\nvoid runloop_task_msg_queue_push(\n      retro_task_t *task, const char *msg,\n      unsigned prio, unsigned duration,\n      bool flush);\n\nbool secondary_core_ensure_exists(void *data, settings_t *settings);\n\nvoid runloop_log_counters(\n      struct retro_perf_counter **counters, unsigned num);\n\nvoid runloop_msg_queue_deinit(void);\n\nvoid runloop_msg_queue_init(void);\n\nvoid runloop_path_set_basename(const char *path);\n\nvoid runloop_path_set_names(void);\n\nuint32_t runloop_get_flags(void);\n\nbool runloop_get_entry_state_path(char *path, size_t len, unsigned slot);\n\nbool runloop_get_current_savestate_path(char *path, size_t len);\n\nbool runloop_get_savestate_path(char *path, size_t len, int slot);\n\nbool runloop_get_current_replay_path(char *path, size_t len);\n\nbool runloop_get_replay_path(char *path, size_t len, unsigned slot);\n\nvoid runloop_state_free(runloop_state_t *runloop_st);\n\nvoid runloop_path_set_redirect(settings_t *settings, const char *a, const char *b);\n\nvoid runloop_path_set_special(char **argv, unsigned num_content);\n\nvoid runloop_path_deinit_subsystem(void);\n\n/**\n * init_libretro_symbols:\n * @type                        : Type of core to be loaded.\n *                                If CORE_TYPE_DUMMY, will\n *                                load dummy symbols.\n *\n * Setup libretro callback symbols.\n *\n * @return true on success, or false if symbols could not be loaded.\n **/\nbool runloop_init_libretro_symbols(\n      void *data,\n      enum rarch_core_type type,\n      struct retro_core_t *current_core,\n      const char *lib_path,\n      void *_lib_handle_p);\n\nrunloop_state_t *runloop_state_get_ptr(void);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "runtime_file.c",
          "type": "blob",
          "size": 45.2998046875,
          "content": "/* Copyright  (C) 2010-2019 The RetroArch team\n *\n * ---------------------------------------------------------------------------------------\n * The following license statement only applies to this file (runtime_file.c).\n * ---------------------------------------------------------------------------------------\n *\n * Permission is hereby granted, free of charge,\n * to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#include <file/file_path.h>\n#include <retro_miscellaneous.h>\n#include <streams/file_stream.h>\n#include <formats/rjson.h>\n#include <string/stdstring.h>\n#include <encodings/utf.h>\n#include <time/rtime.h>\n\n#include \"file_path_special.h\"\n#include \"paths.h\"\n#include \"core_info.h\"\n#include \"verbosity.h\"\n#include \"msg_hash.h\"\n\n#if defined(HAVE_MENU)\n#include \"menu/menu_driver.h\"\n#endif\n\n#include \"runtime_file.h\"\n\n#define LOG_FILE_RUNTIME_FORMAT_STR \"%u:%02u:%02u\"\n#define LOG_FILE_LAST_PLAYED_FORMAT_STR \"%04u-%02u-%02u %02u:%02u:%02u\"\n\n/* JSON Stuff... */\n\ntypedef struct\n{\n   char **current_entry_val;\n   char *runtime_string;\n   char *last_played_string;\n} RtlJSONContext;\n\nstatic bool RtlJSONObjectMemberHandler(void *ctx, const char *s, size_t len)\n{\n   RtlJSONContext *p_ctx = (RtlJSONContext*)ctx;\n\n   /* Something went wrong */\n   if (p_ctx->current_entry_val)\n      return false;\n\n   if (len)\n   {\n      if (string_is_equal(s, \"runtime\"))\n         p_ctx->current_entry_val = &p_ctx->runtime_string;\n      else if (string_is_equal(s, \"last_played\"))\n         p_ctx->current_entry_val = &p_ctx->last_played_string;\n      /* Ignore unknown members */\n   }\n\n   return true;\n}\n\nstatic bool RtlJSONStringHandler(void *ctx, const char *s, size_t len)\n{\n   RtlJSONContext *p_ctx = (RtlJSONContext*)ctx;\n\n   if (p_ctx->current_entry_val && len && !string_is_empty(s))\n   {\n      if (*p_ctx->current_entry_val)\n         free(*p_ctx->current_entry_val);\n\n      *p_ctx->current_entry_val = strdup(s);\n   }\n\n   /* Ignore unknown members */\n   p_ctx->current_entry_val = NULL;\n\n   return true;\n}\n\n/* Initialisation */\n\n/* Parses log file referenced by runtime_log->path.\n * Does nothing if log file does not exist. */\nstatic void runtime_log_read_file(runtime_log_t *runtime_log)\n{\n   rjson_t* parser;\n   unsigned runtime_hours      = 0;\n   unsigned runtime_minutes    = 0;\n   unsigned runtime_seconds    = 0;\n\n   unsigned last_played_year   = 0;\n   unsigned last_played_month  = 0;\n   unsigned last_played_day    = 0;\n   unsigned last_played_hour   = 0;\n   unsigned last_played_minute = 0;\n   unsigned last_played_second = 0;\n\n   RtlJSONContext context      = {0};\n   /* Attempt to open log file */\n   RFILE *file                 = filestream_open(runtime_log->path,\n         RETRO_VFS_FILE_ACCESS_READ, RETRO_VFS_FILE_ACCESS_HINT_NONE);\n\n   if (!file)\n   {\n      RARCH_ERR(\"Failed to open runtime log file: %s\\n\", runtime_log->path);\n      return;\n   }\n\n   /* Initialise JSON parser */\n   if (!(parser = rjson_open_rfile(file)))\n   {\n      RARCH_ERR(\"Failed to create JSON parser.\\n\");\n      goto end;\n   }\n\n   /* Configure parser */\n   rjson_set_options(parser, RJSON_OPTION_ALLOW_UTF8BOM);\n\n   /* Read file */\n   if (rjson_parse(parser, &context,\n         RtlJSONObjectMemberHandler,\n         RtlJSONStringHandler,\n         NULL,                   /* unused number handler */\n         NULL, NULL, NULL, NULL, /* unused object/array handlers */\n         NULL, NULL)             /* unused boolean/null handlers */\n         != RJSON_DONE)\n   {\n      if (rjson_get_source_context_len(parser))\n      {\n         RARCH_ERR(\"Error parsing chunk of runtime log file: %s\\n---snip---\\n%.*s\\n---snip---\\n\",\n               runtime_log->path,\n               rjson_get_source_context_len(parser),\n               rjson_get_source_context_buf(parser));\n      }\n      RARCH_WARN(\"Error parsing runtime log file: %s\\n\", runtime_log->path);\n      RARCH_ERR(\"Error: Invalid JSON at line %d, column %d - %s.\\n\",\n            (int)rjson_get_source_line(parser),\n            (int)rjson_get_source_column(parser),\n            (*rjson_get_error(parser) ? rjson_get_error(parser) : \"format error\"));\n   }\n\n   /* Free parser */\n   rjson_free(parser);\n\n   /* Process string values read from JSON file */\n\n   /* Runtime */\n   if (!string_is_empty(context.runtime_string))\n   {\n      if (sscanf(context.runtime_string,\n               LOG_FILE_RUNTIME_FORMAT_STR,\n               &runtime_hours,\n               &runtime_minutes,\n               &runtime_seconds) != 3)\n      {\n         RARCH_ERR(\"Runtime log file - invalid 'runtime' entry detected: %s\\n\", runtime_log->path);\n         goto end;\n      }\n   }\n\n   /* Last played */\n   if (!string_is_empty(context.last_played_string))\n   {\n      if (sscanf(context.last_played_string,\n               LOG_FILE_LAST_PLAYED_FORMAT_STR,\n               &last_played_year,\n               &last_played_month,\n               &last_played_day,\n               &last_played_hour,\n               &last_played_minute,\n               &last_played_second) != 6)\n      {\n         RARCH_ERR(\"Runtime log file - invalid 'last played' entry detected: %s\\n\", runtime_log->path);\n         goto end;\n      }\n   }\n\n   /* If we reach this point then all is well\n    * > Assign values to runtime_log object */\n   runtime_log->runtime.hours      = runtime_hours;\n   runtime_log->runtime.minutes    = runtime_minutes;\n   runtime_log->runtime.seconds    = runtime_seconds;\n\n   runtime_log->last_played.year   = last_played_year;\n   runtime_log->last_played.month  = last_played_month;\n   runtime_log->last_played.day    = last_played_day;\n   runtime_log->last_played.hour   = last_played_hour;\n   runtime_log->last_played.minute = last_played_minute;\n   runtime_log->last_played.second = last_played_second;\n\nend:\n   /* Clean up leftover strings */\n   if (context.runtime_string)\n      free(context.runtime_string);\n   if (context.last_played_string)\n      free(context.last_played_string);\n\n   /* Close log file */\n   filestream_close(file);\n}\n\n/* Initialise runtime log, loading current parameters\n * if log file exists. Returned object must be free()'d.\n * Returns NULL if core_path is invalid, or content_path\n * is invalid and core does not support contentless\n * operation */\nruntime_log_t *runtime_log_init(\n      const char *content_path,\n      const char *core_path,\n      const char *dir_runtime_log,\n      const char *dir_playlist,\n      bool log_per_core)\n{\n   char log_file_dir[DIR_MAX_LENGTH];\n   char content_name[NAME_MAX_LENGTH];\n   char core_name[NAME_MAX_LENGTH];\n   char log_file_path[PATH_MAX_LENGTH];\n   char tmp_buf[PATH_MAX_LENGTH];\n   bool supports_no_game      = false;\n   core_info_t *core_info     = NULL;\n   runtime_log_t *runtime_log = NULL;\n\n   content_name[0]            = '\\0';\n   core_name[0]               = '\\0';\n\n   if (     string_is_empty(dir_runtime_log)\n         && string_is_empty(dir_playlist))\n   {\n      RARCH_ERR(\"Runtime log directory is undefined - cannot save\"\n            \" runtime log files.\\n\");\n      return NULL;\n   }\n\n   if (     string_is_empty(core_path)\n         || string_is_equal(core_path, \"builtin\")\n         || string_is_equal(core_path, \"DETECT\"))\n      return NULL;\n\n   /* Get core info:\n    * - Need to know if core supports contentless operation\n    * - Need core name in order to generate file path when\n    *   per-core logging is enabled\n    * Note: An annoyance - core name is required even when\n    * we are performing aggregate logging, since content\n    * name is sometimes dependent upon core\n    * (e.g. see TyrQuake below) */\n   if (core_info_find(core_path, &core_info))\n   {\n      supports_no_game = core_info->supports_no_game;\n      if (!string_is_empty(core_info->core_name))\n         strlcpy(core_name, core_info->core_name, sizeof(core_name));\n   }\n\n   if (string_is_empty(core_name))\n      return NULL;\n\n   /* Get runtime log directory\n    * If 'custom' runtime log path is undefined,\n    * use default 'playlists/logs' directory... */\n   if (string_is_empty(dir_runtime_log))\n      fill_pathname_join_special(\n            tmp_buf,\n            dir_playlist,\n            \"logs\",\n            sizeof(tmp_buf));\n   else\n      strlcpy(tmp_buf, dir_runtime_log, sizeof(tmp_buf));\n\n   if (string_is_empty(tmp_buf))\n      return NULL;\n\n   if (log_per_core)\n      fill_pathname_join_special(\n            log_file_dir,\n            tmp_buf,\n            core_name,\n            sizeof(log_file_dir));\n   else\n      strlcpy(log_file_dir, tmp_buf, sizeof(log_file_dir));\n\n   if (string_is_empty(log_file_dir))\n      return NULL;\n\n   /* Create directory, if required */\n   if (!path_is_directory(log_file_dir))\n   {\n      if (!path_mkdir(log_file_dir))\n      {\n         RARCH_ERR(\"[runtime] failed to create directory for\"\n               \" runtime log: %s.\\n\", log_file_dir);\n         return NULL;\n      }\n   }\n\n   /* Get content name */\n   if (string_is_empty(content_path))\n   {\n      /* If core supports contentless operation and\n       * no content is provided, 'content' is simply\n       * the name of the core itself */\n      if (supports_no_game)\n         fill_pathname(content_name, core_name,\n               \".lrtl\", sizeof(content_name));\n   }\n   /* NOTE: TyrQuake requires a specific hack, since all\n    * content has the same name... */\n   else if (string_is_equal(core_name, \"TyrQuake\"))\n   {\n      const char *slash      = strrchr(content_path, '/');\n      const char *backslash  = strrchr(content_path, '\\\\');\n      const char *last_slash = (!slash || (backslash > slash)) ? (char*)backslash : (char*)slash;\n      if (last_slash)\n      {\n         size_t path_length = last_slash + 1 - content_path;\n         if (path_length < PATH_MAX_LENGTH)\n         {\n            memset(tmp_buf, 0, sizeof(tmp_buf));\n            strlcpy(tmp_buf,\n                  content_path, path_length * sizeof(char));\n            fill_pathname(content_name,\n                  path_basename(tmp_buf), \".lrtl\", sizeof(content_name));\n         }\n      }\n   }\n   else\n      fill_pathname(content_name, path_basename(content_path), \".lrtl\",\n            sizeof(content_name));\n\n   if (string_is_empty(content_name))\n      return NULL;\n\n   /* Build final log file path */\n   fill_pathname_join_special(log_file_path, log_file_dir,\n         content_name, sizeof(log_file_path));\n\n   if (string_is_empty(log_file_path))\n      return NULL;\n\n   /* Phew... If we get this far then all is well.\n    * > Create 'runtime_log' object */\n   if (!(runtime_log = (runtime_log_t*)malloc(sizeof(*runtime_log))))\n      return NULL;\n\n   /* > Populate default values */\n   runtime_log->runtime.hours      = 0;\n   runtime_log->runtime.minutes    = 0;\n   runtime_log->runtime.seconds    = 0;\n\n   runtime_log->last_played.year   = 0;\n   runtime_log->last_played.month  = 0;\n   runtime_log->last_played.day    = 0;\n   runtime_log->last_played.hour   = 0;\n   runtime_log->last_played.minute = 0;\n   runtime_log->last_played.second = 0;\n\n   runtime_log->path[0]            = '\\0';\n\n   strlcpy(runtime_log->path, log_file_path, sizeof(runtime_log->path));\n\n   /* Load existing log file, if it exists */\n   if (path_is_valid(runtime_log->path))\n      runtime_log_read_file(runtime_log);\n\n   return runtime_log;\n}\n\n/* Convert from hours, minutes, seconds to microseconds */\nstatic retro_time_t runtime_log_convert_hms2usec(unsigned hours,\n      unsigned minutes, unsigned seconds)\n{\n   return ( (retro_time_t)hours   * 60 * 60 * 1000000) +\n           ((retro_time_t)minutes * 60      * 1000000) +\n           ((retro_time_t)seconds           * 1000000);\n}\n\n/* Setters */\n\n/* Adds specified microseconds value to current runtime */\nvoid runtime_log_add_runtime_usec(\n      runtime_log_t *runtime_log, retro_time_t usec)\n{\n   retro_time_t usec_old;\n\n   if (!runtime_log)\n      return;\n\n   usec_old = runtime_log_convert_hms2usec(\n         runtime_log->runtime.hours,\n         runtime_log->runtime.minutes,\n         runtime_log->runtime.seconds);\n\n   runtime_log_convert_usec2hms(usec_old + usec,\n         &runtime_log->runtime.hours,\n         &runtime_log->runtime.minutes,\n         &runtime_log->runtime.seconds);\n}\n\n/* Sets last played entry to specified value */\nvoid runtime_log_set_last_played(runtime_log_t *runtime_log,\n      unsigned year, unsigned month, unsigned day,\n      unsigned hour, unsigned minute, unsigned second)\n{\n   if (!runtime_log)\n      return;\n\n   /* This function should never be needed, so just\n    * perform dumb value assignment (i.e. no validation\n    * using mktime()) */\n   runtime_log->last_played.year   = year;\n   runtime_log->last_played.month  = month;\n   runtime_log->last_played.day    = day;\n   runtime_log->last_played.hour   = hour;\n   runtime_log->last_played.minute = minute;\n   runtime_log->last_played.second = second;\n}\n\n/* Sets last played entry to current date/time */\nvoid runtime_log_set_last_played_now(runtime_log_t *runtime_log)\n{\n   time_t current_time;\n   struct tm time_info;\n\n   if (!runtime_log)\n      return;\n\n   /* Get current time */\n   time(&current_time);\n   rtime_localtime(&current_time, &time_info);\n\n   /* Extract values */\n   runtime_log->last_played.year   = (unsigned)time_info.tm_year + 1900;\n   runtime_log->last_played.month  = (unsigned)time_info.tm_mon + 1;\n   runtime_log->last_played.day    = (unsigned)time_info.tm_mday;\n   runtime_log->last_played.hour   = (unsigned)time_info.tm_hour;\n   runtime_log->last_played.minute = (unsigned)time_info.tm_min;\n   runtime_log->last_played.second = (unsigned)time_info.tm_sec;\n}\n\n/* Resets log to default (zero) values */\nvoid runtime_log_reset(runtime_log_t *runtime_log)\n{\n   if (!runtime_log)\n      return;\n\n   runtime_log->runtime.hours      = 0;\n   runtime_log->runtime.minutes    = 0;\n   runtime_log->runtime.seconds    = 0;\n\n   runtime_log->last_played.year   = 0;\n   runtime_log->last_played.month  = 0;\n   runtime_log->last_played.day    = 0;\n   runtime_log->last_played.hour   = 0;\n   runtime_log->last_played.minute = 0;\n   runtime_log->last_played.second = 0;\n}\n\n/* Getters */\n\n/* Gets runtime in hours, minutes, seconds */\nstatic void runtime_log_get_runtime_hms(runtime_log_t *runtime_log,\n      unsigned *hours, unsigned *minutes, unsigned *seconds)\n{\n   if (!runtime_log)\n      return;\n\n   *hours   = runtime_log->runtime.hours;\n   *minutes = runtime_log->runtime.minutes;\n   *seconds = runtime_log->runtime.seconds;\n}\n\n/* Gets runtime as a pre-formatted string */\nvoid runtime_log_get_runtime_str(runtime_log_t *runtime_log,\n      char *s, size_t len)\n{\n   size_t _len = strlcpy(s,\n         msg_hash_to_str(MENU_ENUM_LABEL_VALUE_PLAYLIST_SUBLABEL_RUNTIME),\n         len);\n   s[_len  ]   = ' ';\n   if (runtime_log)\n      snprintf(s + _len + 1, len - _len - 1, \"%02u:%02u:%02u\",\n            runtime_log->runtime.hours, runtime_log->runtime.minutes,\n            runtime_log->runtime.seconds);\n   else\n   {\n      s[_len+1]   = '0';\n      s[_len+2]   = '0';\n      s[_len+3]   = ':';\n      s[_len+4]   = '0';\n      s[_len+5]   = '0';\n      s[_len+6]   = ':';\n      s[_len+7]   = '0';\n      s[_len+8]   = '0';\n      s[_len+9]   = '\\0';\n   }\n}\n\n/* Gets last played entry values */\nvoid runtime_log_get_last_played(runtime_log_t *runtime_log,\n      unsigned *year, unsigned *month, unsigned *day,\n      unsigned *hour, unsigned *minute, unsigned *second)\n{\n   if (!runtime_log)\n      return;\n\n   *year   = runtime_log->last_played.year;\n   *month  = runtime_log->last_played.month;\n   *day    = runtime_log->last_played.day;\n   *hour   = runtime_log->last_played.hour;\n   *minute = runtime_log->last_played.minute;\n   *second = runtime_log->last_played.second;\n}\n\n/* Gets last played entry values as a struct tm 'object'\n * (e.g. for printing with strftime()) */\nstatic void runtime_log_get_last_played_time(runtime_log_t *runtime_log,\n      struct tm *time_info)\n{\n   /* Set tm values */\n   time_info->tm_year  = (int)runtime_log->last_played.year  - 1900;\n   time_info->tm_mon   = (int)runtime_log->last_played.month - 1;\n   time_info->tm_mday  = (int)runtime_log->last_played.day;\n   time_info->tm_hour  = (int)runtime_log->last_played.hour;\n   time_info->tm_min   = (int)runtime_log->last_played.minute;\n   time_info->tm_sec   = (int)runtime_log->last_played.second;\n   time_info->tm_isdst = -1;\n\n   /* Perform any required range adjustment + populate\n    * missing entries */\n   mktime(time_info);\n}\n\nstatic size_t runtime_last_played_human(runtime_log_t *runtime_log,\n      char *s, size_t len)\n{\n   size_t _len;\n   struct tm time_info;\n   time_t last_played;\n   time_t current;\n   time_t delta;\n   unsigned i;\n\n   unsigned units[7][2] =\n   {\n      {MENU_ENUM_LABEL_VALUE_TIME_UNIT_SECONDS_SINGLE, MENU_ENUM_LABEL_VALUE_TIME_UNIT_SECONDS_PLURAL},\n      {MENU_ENUM_LABEL_VALUE_TIME_UNIT_MINUTES_SINGLE, MENU_ENUM_LABEL_VALUE_TIME_UNIT_MINUTES_PLURAL},\n      {MENU_ENUM_LABEL_VALUE_TIME_UNIT_HOURS_SINGLE, MENU_ENUM_LABEL_VALUE_TIME_UNIT_HOURS_PLURAL},\n      {MENU_ENUM_LABEL_VALUE_TIME_UNIT_DAYS_SINGLE, MENU_ENUM_LABEL_VALUE_TIME_UNIT_DAYS_PLURAL},\n      {MENU_ENUM_LABEL_VALUE_TIME_UNIT_WEEKS_SINGLE, MENU_ENUM_LABEL_VALUE_TIME_UNIT_WEEKS_PLURAL},\n      {MENU_ENUM_LABEL_VALUE_TIME_UNIT_MONTHS_SINGLE, MENU_ENUM_LABEL_VALUE_TIME_UNIT_MONTHS_PLURAL},\n      {MENU_ENUM_LABEL_VALUE_TIME_UNIT_YEARS_SINGLE, MENU_ENUM_LABEL_VALUE_TIME_UNIT_YEARS_PLURAL},\n   };\n\n   float periods[6] = {60.0f, 60.0f, 24.0f, 7.0f, 4.35f, 12.0f};\n\n   if (!runtime_log)\n      return 0;\n\n   /* Get time */\n   runtime_log_get_last_played_time(runtime_log, &time_info);\n\n   last_played = mktime(&time_info);\n   current     = time(NULL);\n\n   if ((delta = current - last_played) <= 0)\n      return 0;\n\n   for (i = 0; delta >= periods[i] && i < sizeof(periods) - 1; i++)\n      delta /= periods[i];\n\n   /* Generate string */\n   _len  = snprintf(s, len, \"%u \", (int)delta);\n   _len += strlcpy(s + _len,\n         msg_hash_to_str((enum msg_hash_enums)units[i][(delta == 1) ? 0 : 1]),\n         len - _len);\n\n   s[  _len] = ' ';\n   s[++_len] = '\\0';\n   _len += strlcpy(s   + _len,\n         msg_hash_to_str(MENU_ENUM_LABEL_VALUE_TIME_UNIT_AGO),\n         len - _len);\n\n   return _len;\n}\n\n/* Gets last played entry value as a pre-formatted string */\nvoid runtime_log_get_last_played_str(runtime_log_t *runtime_log,\n      char *s, size_t len,\n      enum playlist_sublabel_last_played_style_type timedate_style,\n      enum playlist_sublabel_last_played_date_separator_type date_separator)\n{\n   const char *format_str = \"\";\n   size_t _len            = strlcpy(s, msg_hash_to_str(\n            MENU_ENUM_LABEL_VALUE_PLAYLIST_SUBLABEL_LAST_PLAYED), len);\n\n   if (runtime_log)\n   {\n      bool has_am_pm      = false;\n      /* Handle 12-hour clock options\n       * > These require extra work, due to AM/PM localisation */\n      switch (timedate_style)\n      {\n         case PLAYLIST_LAST_PLAYED_STYLE_YMD_HMS_AMPM:\n            has_am_pm = true;\n            /* Using switch statements to set the format\n             * string is verbose, but has far less performance\n             * impact than setting the date separator dynamically\n             * (i.e. no snprintf() or character replacement...) */\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %Y/%m/%d %I:%M:%S %p\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %Y.%m.%d %I:%M:%S %p\";\n                  break;\n               default:\n                  format_str = \" %Y-%m-%d %I:%M:%S %p\";\n                  break;\n            }\n            break;\n         case PLAYLIST_LAST_PLAYED_STYLE_YMD_HM_AMPM:\n            has_am_pm = true;\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %Y/%m/%d %I:%M %p\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %Y.%m.%d %I:%M %p\";\n                  break;\n               default:\n                  format_str = \" %Y-%m-%d %I:%M %p\";\n                  break;\n            }\n            break;\n         case PLAYLIST_LAST_PLAYED_STYLE_MDYYYY_HMS_AMPM:\n            has_am_pm = true;\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %m/%d/%Y %I:%M:%S %p\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %m.%d.%Y %I:%M:%S %p\";\n                  break;\n               default:\n                  format_str = \" %m-%d-%Y %I:%M:%S %p\";\n                  break;\n            }\n            break;\n         case PLAYLIST_LAST_PLAYED_STYLE_MDYYYY_HM_AMPM:\n            has_am_pm = true;\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %m/%d/%Y %I:%M %p\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %m.%d.%Y %I:%M %p\";\n                  break;\n               default:\n                  format_str = \" %m-%d-%Y %I:%M %p\";\n                  break;\n            }\n            break;\n         case PLAYLIST_LAST_PLAYED_STYLE_MD_HM_AMPM:\n            has_am_pm = true;\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %m/%d %I:%M %p\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %m.%d %I:%M %p\";\n                  break;\n               default:\n                  format_str = \" %m-%d %I:%M %p\";\n                  break;\n            }\n            break;\n         case PLAYLIST_LAST_PLAYED_STYLE_DDMMYYYY_HMS_AMPM:\n            has_am_pm = true;\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %d/%m/%Y %I:%M:%S %p\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %d.%m.%Y %I:%M:%S %p\";\n                  break;\n               default:\n                  format_str = \" %d-%m-%Y %I:%M:%S %p\";\n                  break;\n            }\n            break;\n         case PLAYLIST_LAST_PLAYED_STYLE_DDMMYYYY_HM_AMPM:\n            has_am_pm = true;\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %d/%m/%Y %I:%M %p\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %d.%m.%Y %I:%M %p\";\n                  break;\n               default:\n                  format_str = \" %d-%m-%Y %I:%M %p\";\n                  break;\n            }\n            break;\n         case PLAYLIST_LAST_PLAYED_STYLE_DDMM_HM_AMPM:\n            has_am_pm = true;\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %d/%m %I:%M %p\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %d.%m %I:%M %p\";\n                  break;\n               default:\n                  format_str = \" %d-%m %I:%M %p\";\n                  break;\n            }\n            break;\n         default:\n            break;\n      }\n\n      if (has_am_pm)\n      {\n         /* Get time */\n         struct tm time_info;\n         runtime_log_get_last_played_time(runtime_log, &time_info);\n         strftime_am_pm(s + _len, len - _len, format_str, &time_info);\n         return;\n      }\n\n      /* Handle non-12-hour clock options */\n      switch (timedate_style)\n      {\n         case PLAYLIST_LAST_PLAYED_STYLE_YMD_HM:\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %04u/%02u/%02u %02u:%02u\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %04u.%02u.%02u %02u:%02u\";\n                  break;\n               default:\n                  format_str = \" %04u-%02u-%02u %02u:%02u\";\n                  break;\n            }\n            snprintf(s + _len, len - _len, format_str,\n                  runtime_log->last_played.year,\n                  runtime_log->last_played.month,\n                  runtime_log->last_played.day,\n                  runtime_log->last_played.hour,\n                  runtime_log->last_played.minute);\n            return;\n         case PLAYLIST_LAST_PLAYED_STYLE_YMD:\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %04u/%02u/%02u\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %04u.%02u.%02u\";\n                  break;\n               default:\n                  format_str = \" %04u-%02u-%02u\";\n                  break;\n            }\n            snprintf(s + _len, len - _len, format_str,\n                  runtime_log->last_played.year,\n                  runtime_log->last_played.month,\n                  runtime_log->last_played.day);\n            return;\n         case PLAYLIST_LAST_PLAYED_STYLE_YM:\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %04u/%02u\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %04u.%02u\";\n                  break;\n               default:\n                  format_str = \" %04u-%02u\";\n                  break;\n            }\n            snprintf(s + _len, len - _len, format_str,\n                  runtime_log->last_played.year,\n                  runtime_log->last_played.month);\n            return;\n         case PLAYLIST_LAST_PLAYED_STYLE_MDYYYY_HMS:\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %02u/%02u/%04u %02u:%02u:%02u\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %02u.%02u.%04u %02u:%02u:%02u\";\n                  break;\n               default:\n                  format_str = \" %02u-%02u-%04u %02u:%02u:%02u\";\n                  break;\n            }\n            snprintf(s + _len, len - _len, format_str,\n                  runtime_log->last_played.month,\n                  runtime_log->last_played.day,\n                  runtime_log->last_played.year,\n                  runtime_log->last_played.hour,\n                  runtime_log->last_played.minute,\n                  runtime_log->last_played.second);\n            return;\n         case PLAYLIST_LAST_PLAYED_STYLE_MDYYYY_HM:\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %02u/%02u/%04u %02u:%02u\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %02u.%02u.%04u %02u:%02u\";\n                  break;\n               default:\n                  format_str = \" %02u-%02u-%04u %02u:%02u\";\n                  break;\n            }\n            snprintf(s + _len, len - _len, format_str,\n                  runtime_log->last_played.month,\n                  runtime_log->last_played.day,\n                  runtime_log->last_played.year,\n                  runtime_log->last_played.hour,\n                  runtime_log->last_played.minute);\n            return;\n         case PLAYLIST_LAST_PLAYED_STYLE_MD_HM:\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %02u/%02u %02u:%02u\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %02u.%02u %02u:%02u\";\n                  break;\n               default:\n                  format_str = \" %02u-%02u %02u:%02u\";\n                  break;\n            }\n            snprintf(s + _len, len - _len, format_str,\n                  runtime_log->last_played.month,\n                  runtime_log->last_played.day,\n                  runtime_log->last_played.hour,\n                  runtime_log->last_played.minute);\n            return;\n         case PLAYLIST_LAST_PLAYED_STYLE_MDYYYY:\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %02u/%02u/%04u\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %02u.%02u.%04u\";\n                  break;\n               default:\n                  format_str = \" %02u-%02u-%04u\";\n                  break;\n            }\n            snprintf(s + _len, len - _len, format_str,\n                  runtime_log->last_played.month,\n                  runtime_log->last_played.day,\n                  runtime_log->last_played.year);\n            return;\n         case PLAYLIST_LAST_PLAYED_STYLE_MD:\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %02u/%02u\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %02u.%02u\";\n                  break;\n               default:\n                  format_str = \" %02u-%02u\";\n                  break;\n            }\n            snprintf(s + _len, len - _len, format_str,\n                  runtime_log->last_played.month,\n                  runtime_log->last_played.day);\n            return;\n         case PLAYLIST_LAST_PLAYED_STYLE_DDMMYYYY_HMS:\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %02u/%02u/%04u %02u:%02u:%02u\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %02u.%02u.%04u %02u:%02u:%02u\";\n                  break;\n               default:\n                  format_str = \" %02u-%02u-%04u %02u:%02u:%02u\";\n                  break;\n            }\n            snprintf(s + _len, len - _len, format_str,\n                  runtime_log->last_played.day,\n                  runtime_log->last_played.month,\n                  runtime_log->last_played.year,\n                  runtime_log->last_played.hour,\n                  runtime_log->last_played.minute,\n                  runtime_log->last_played.second);\n            return;\n         case PLAYLIST_LAST_PLAYED_STYLE_DDMMYYYY_HM:\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %02u/%02u/%04u %02u:%02u\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %02u.%02u.%04u %02u:%02u\";\n                  break;\n               default:\n                  format_str = \" %02u-%02u-%04u %02u:%02u\";\n                  break;\n            }\n            snprintf(s + _len, len - _len, format_str,\n                  runtime_log->last_played.day,\n                  runtime_log->last_played.month,\n                  runtime_log->last_played.year,\n                  runtime_log->last_played.hour,\n                  runtime_log->last_played.minute);\n            return;\n         case PLAYLIST_LAST_PLAYED_STYLE_DDMM_HM:\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %02u/%02u %02u:%02u\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %02u.%02u %02u:%02u\";\n                  break;\n               default:\n                  format_str = \" %02u-%02u %02u:%02u\";\n                  break;\n            }\n            snprintf(s + _len, len - _len, format_str,\n                  runtime_log->last_played.day,\n                  runtime_log->last_played.month,\n                  runtime_log->last_played.hour,\n                  runtime_log->last_played.minute);\n            return;\n         case PLAYLIST_LAST_PLAYED_STYLE_DDMMYYYY:\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %02u/%02u/%04u\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %02u.%02u.%04u\";\n                  break;\n               default:\n                  format_str = \" %02u-%02u-%04u\";\n                  break;\n            }\n            snprintf(s + _len, len - _len, format_str,\n                  runtime_log->last_played.day,\n                  runtime_log->last_played.month,\n                  runtime_log->last_played.year);\n            return;\n         case PLAYLIST_LAST_PLAYED_STYLE_DDMM:\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %02u/%02u\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %02u.%02u\";\n                  break;\n               default:\n                  format_str = \" %02u-%02u\";\n                  break;\n            }\n            snprintf(s + _len, len - _len, format_str,\n                  runtime_log->last_played.day, runtime_log->last_played.month);\n            return;\n         case PLAYLIST_LAST_PLAYED_STYLE_AGO:\n            s[  _len] = ' ';\n            s[++_len] = '\\0';\n            if ((runtime_last_played_human(runtime_log, s + _len, len - _len - 2)) == 0)\n               strlcat(s + _len,\n                     msg_hash_to_str(\n                        MENU_ENUM_LABEL_VALUE_PLAYLIST_INLINE_CORE_DISPLAY_NEVER),\n                     len - _len - 2);\n            return;\n         case PLAYLIST_LAST_PLAYED_STYLE_YMD_HMS:\n         default:\n            switch (date_separator)\n            {\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH:\n                  format_str = \" %04u/%02u/%02u %02u:%02u:%02u\";\n                  break;\n               case PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD:\n                  format_str = \" %04u.%02u.%02u %02u:%02u:%02u\";\n                  break;\n               default:\n                  format_str = \" %04u-%02u-%02u %02u:%02u:%02u\";\n                  break;\n            }\n            snprintf(s + _len, len - _len, format_str,\n                  runtime_log->last_played.year,\n                  runtime_log->last_played.month,\n                  runtime_log->last_played.day,\n                  runtime_log->last_played.hour,\n                  runtime_log->last_played.minute,\n                  runtime_log->last_played.second);\n            return;\n      }\n   }\n   else\n      snprintf(s + _len, len - _len,\n            \" %s\", msg_hash_to_str(MENU_ENUM_LABEL_VALUE_PLAYLIST_INLINE_CORE_DISPLAY_NEVER));\n}\n\n/* Status */\n\n/* Returns true if log has a non-zero runtime entry */\nbool runtime_log_has_runtime(runtime_log_t *runtime_log)\n{\n   if (runtime_log)\n      return !(\n               (runtime_log->runtime.hours   == 0)\n            && (runtime_log->runtime.minutes == 0)\n            && (runtime_log->runtime.seconds == 0));\n   return false;\n}\n\n/* Saving */\n\n/* Saves specified runtime log to disk */\nvoid runtime_log_save(runtime_log_t *runtime_log)\n{\n   char value_string[64]; /* 64 characters should be\n                             enough for a very long runtime... :) */\n   RFILE *file            = NULL;\n   rjsonwriter_t* writer;\n\n   if (!runtime_log)\n      return;\n\n   RARCH_LOG(\"[Runtime]: Saving runtime log file: \\\"%s\\\".\\n\", runtime_log->path);\n\n   /* Attempt to open log file */\n   if (!(file = filestream_open(runtime_log->path,\n         RETRO_VFS_FILE_ACCESS_WRITE, RETRO_VFS_FILE_ACCESS_HINT_NONE)))\n   {\n      RARCH_ERR(\"[Runtime]: Failed to open runtime log file: \\\"%s\\\".\\n\", runtime_log->path);\n      return;\n   }\n\n   /* Initialise JSON writer */\n   if (!(writer = rjsonwriter_open_rfile(file)))\n   {\n      RARCH_ERR(\"[Runtime]: Failed to create JSON writer.\\n\");\n      goto end;\n   }\n\n   /* Write output file */\n   rjsonwriter_raw(writer, \"{\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n\n   /* > Version entry */\n   rjsonwriter_add_spaces(writer, 2);\n   rjsonwriter_add_string(writer, \"version\");\n   rjsonwriter_raw(writer, \":\", 1);\n   rjsonwriter_raw(writer, \" \", 1);\n   rjsonwriter_add_string(writer, \"1.0\");\n   rjsonwriter_raw(writer, \",\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n\n   /* > Runtime entry */\n   snprintf(value_string,\n         sizeof(value_string),\n         LOG_FILE_RUNTIME_FORMAT_STR,\n         runtime_log->runtime.hours, runtime_log->runtime.minutes,\n         runtime_log->runtime.seconds);\n\n   rjsonwriter_add_spaces(writer, 2);\n   rjsonwriter_add_string(writer, \"runtime\");\n   rjsonwriter_raw(writer, \":\", 1);\n   rjsonwriter_raw(writer, \" \", 1);\n   rjsonwriter_add_string(writer, value_string);\n   rjsonwriter_raw(writer, \",\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n\n   /* > Last played entry */\n   value_string[0] = '\\0';\n   snprintf(value_string, sizeof(value_string),\n         LOG_FILE_LAST_PLAYED_FORMAT_STR,\n         runtime_log->last_played.year, runtime_log->last_played.month,\n         runtime_log->last_played.day,\n         runtime_log->last_played.hour, runtime_log->last_played.minute,\n         runtime_log->last_played.second);\n\n   rjsonwriter_add_spaces(writer, 2);\n   rjsonwriter_add_string(writer, \"last_played\");\n   rjsonwriter_raw(writer, \":\", 1);\n   rjsonwriter_raw(writer, \" \", 1);\n   rjsonwriter_add_string(writer, value_string);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n\n   /* > Finalise */\n   rjsonwriter_raw(writer, \"}\", 1);\n   rjsonwriter_raw(writer, \"\\n\", 1);\n\n   /* Free JSON writer */\n   if (!rjsonwriter_free(writer))\n   {\n      RARCH_ERR(\"Error writing runtime log file: %s\\n\", runtime_log->path);\n   }\n\nend:\n   /* Close log file */\n   filestream_close(file);\n}\n\n/* Utility functions */\n\n/* Convert from microseconds to hours, minutes, seconds */\nvoid runtime_log_convert_usec2hms(retro_time_t usec,\n      unsigned *hours, unsigned *minutes, unsigned *seconds)\n{\n   *seconds  = (unsigned)(usec / 1000000);\n   *minutes  = *seconds / 60;\n   *hours    = *minutes / 60;\n\n   *seconds -= *minutes * 60;\n   *minutes -= *hours * 60;\n}\n\n/* Playlist manipulation */\n\n/* Updates specified playlist entry runtime values with\n * contents of associated log file */\nvoid runtime_update_playlist(\n      playlist_t *playlist, size_t idx,\n      const char *dir_runtime_log,\n      const char *dir_playlist,\n      bool log_per_core,\n      enum playlist_sublabel_last_played_style_type timedate_style,\n      enum playlist_sublabel_last_played_date_separator_type date_separator)\n{\n   char runtime_str[64];\n   char last_played_str[64];\n   runtime_log_t *runtime_log             = NULL;\n   const struct playlist_entry *entry     = NULL;\n   struct playlist_entry update_entry     = {0};\n#if defined(HAVE_MENU) && (defined(HAVE_OZONE) || defined(HAVE_MATERIALUI))\n   const char *menu_ident                 = menu_driver_ident();\n#endif\n\n   /* Sanity check */\n   if (!playlist)\n      return;\n\n   if (idx >= playlist_get_size(playlist))\n      return;\n\n   /* Set fallback playlist 'runtime_status'\n    * (saves 'if' checks later...) */\n   update_entry.runtime_status = PLAYLIST_RUNTIME_MISSING;\n\n   /* 'Attach' runtime/last played strings */\n   runtime_str[0]               = '\\0';\n   last_played_str[0]           = '\\0';\n   update_entry.runtime_str     = runtime_str;\n   update_entry.last_played_str = last_played_str;\n\n   /* Read current playlist entry */\n   playlist_get_index(playlist, idx, &entry);\n\n   /* Attempt to open log file */\n   if ((runtime_log = runtime_log_init(\n         entry->path,\n         entry->core_path,\n         dir_runtime_log,\n         dir_playlist,\n         log_per_core)))\n   {\n      /* Check whether a non-zero runtime has been recorded */\n      if (runtime_log_has_runtime(runtime_log))\n      {\n         /* Read current runtime */\n         runtime_log_get_runtime_hms(runtime_log,\n               &update_entry.runtime_hours,\n               &update_entry.runtime_minutes,\n               &update_entry.runtime_seconds);\n\n         runtime_log_get_runtime_str(runtime_log,\n               runtime_str, sizeof(runtime_str));\n\n         /* Read last played timestamp */\n         runtime_log_get_last_played(runtime_log,\n               &update_entry.last_played_year,\n               &update_entry.last_played_month,\n               &update_entry.last_played_day,\n               &update_entry.last_played_hour,\n               &update_entry.last_played_minute,\n               &update_entry.last_played_second);\n\n         runtime_log_get_last_played_str(runtime_log,\n               last_played_str, sizeof(last_played_str),\n               timedate_style, date_separator);\n\n         /* Playlist entry now contains valid runtime data */\n         update_entry.runtime_status = PLAYLIST_RUNTIME_VALID;\n      }\n\n      /* Clean up */\n      free(runtime_log);\n   }\n\n#if defined(HAVE_MENU) && (defined(HAVE_OZONE) || defined(HAVE_MATERIALUI))\n   /* Ozone and GLUI require runtime/last played strings\n    * to be populated even when no runtime is recorded */\n   if (update_entry.runtime_status != PLAYLIST_RUNTIME_VALID)\n   {\n      if (   string_is_equal(menu_ident, \"ozone\")\n          || string_is_equal(menu_ident, \"glui\"))\n      {\n         runtime_log_get_runtime_str(NULL,\n               runtime_str, sizeof(runtime_str));\n         runtime_log_get_last_played_str(NULL,\n               last_played_str, sizeof(last_played_str),\n               timedate_style, date_separator);\n\n         /* While runtime data does not exist, the playlist\n          * entry does now contain valid information... */\n         update_entry.runtime_status = PLAYLIST_RUNTIME_VALID;\n      }\n   }\n#endif\n\n   /* Update playlist */\n   playlist_update_runtime(playlist, idx, &update_entry, false);\n}\n\n#if defined(HAVE_MENU)\n/* Contentless cores manipulation */\n\n/* Updates specified contentless core runtime values with\n * contents of associated log file */\nvoid runtime_update_contentless_core(\n      const char *core_path,\n      const char *dir_runtime_log,\n      const char *dir_playlist,\n      bool log_per_core,\n      enum playlist_sublabel_last_played_style_type timedate_style,\n      enum playlist_sublabel_last_played_date_separator_type date_separator)\n{\n   char runtime_str[64];\n   char last_played_str[64];\n   core_info_t *core_info                       = NULL;\n   runtime_log_t *runtime_log                   = NULL;\n   contentless_core_runtime_info_t runtime_info = {0};\n#if (defined(HAVE_OZONE) || defined(HAVE_MATERIALUI))\n   const char *menu_ident                       = menu_driver_ident();\n#endif\n\n   /* Sanity check */\n   if (    string_is_empty(core_path)\n       || !core_info_find(core_path, &core_info)\n       || !core_info->supports_no_game)\n      return;\n\n   /* Set fallback runtime status\n    * (saves 'if' checks later...) */\n   runtime_info.status = CONTENTLESS_CORE_RUNTIME_MISSING;\n\n   /* 'Attach' runtime/last played strings */\n   runtime_str[0]               = '\\0';\n   last_played_str[0]           = '\\0';\n   runtime_info.runtime_str     = runtime_str;\n   runtime_info.last_played_str = last_played_str;\n\n   /* Attempt to open log file */\n   runtime_log = runtime_log_init(\n         NULL,\n         core_path,\n         dir_runtime_log,\n         dir_playlist,\n         log_per_core);\n\n   if (runtime_log)\n   {\n      /* Check whether a non-zero runtime has been recorded */\n      if (runtime_log_has_runtime(runtime_log))\n      {\n         /* Read current runtime */\n         runtime_log_get_runtime_str(runtime_log,\n               runtime_str, sizeof(runtime_str));\n\n         /* Read last played timestamp */\n         runtime_log_get_last_played_str(runtime_log,\n               last_played_str, sizeof(last_played_str),\n               timedate_style, date_separator);\n\n         /* Contentless core entry now contains valid runtime data */\n         runtime_info.status = CONTENTLESS_CORE_RUNTIME_VALID;\n      }\n\n      /* Clean up */\n      free(runtime_log);\n   }\n\n#if (defined(HAVE_OZONE) || defined(HAVE_MATERIALUI))\n   /* Ozone and GLUI require runtime/last played strings\n    * to be populated even when no runtime is recorded */\n   if (runtime_info.status != CONTENTLESS_CORE_RUNTIME_VALID)\n   {\n      if (   string_is_equal(menu_ident, \"ozone\")\n          || string_is_equal(menu_ident, \"glui\"))\n      {\n         runtime_log_get_runtime_str(NULL,\n               runtime_str, sizeof(runtime_str));\n         runtime_log_get_last_played_str(NULL,\n               last_played_str, sizeof(last_played_str),\n               timedate_style, date_separator);\n\n         /* While runtime data does not exist, the contentless\n          * core entry does now contain valid information... */\n         runtime_info.status = CONTENTLESS_CORE_RUNTIME_VALID;\n      }\n   }\n#endif\n\n   /* Update contentless core */\n   menu_contentless_cores_set_runtime(core_info->core_file_id.str,\n         &runtime_info);\n}\n#endif\n"
        },
        {
          "name": "runtime_file.h",
          "type": "blob",
          "size": 5.14453125,
          "content": "/* Copyright  (C) 2010-2019 The RetroArch team\n *\n * ---------------------------------------------------------------------------------------\n * The following license statement only applies to this file (runtime_file.h).\n * ---------------------------------------------------------------------------------------\n *\n * Permission is hereby granted, free of charge,\n * to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#ifndef __RUNTIME_FILE_H\n#define __RUNTIME_FILE_H\n\n#include <retro_common_api.h>\n#include <libretro.h>\n\n#include <time.h>\n#include <boolean.h>\n\n#include \"playlist.h\"\n#include \"runtime_file_defines.h\"\n\nRETRO_BEGIN_DECLS\n\n/* Structs */\n\ntypedef struct\n{\n   unsigned hours;\n   unsigned minutes;\n   unsigned seconds;\n} rtl_runtime_t;\n\ntypedef struct\n{\n   unsigned year;\n   unsigned month;\n   unsigned day;\n   unsigned hour;\n   unsigned minute;\n   unsigned second;\n} rtl_last_played_t;\n\ntypedef struct\n{\n   rtl_runtime_t runtime;           /* unsigned alignment */\n   rtl_last_played_t last_played;   /* unsigned alignment */\n   char path[PATH_MAX_LENGTH];\n} runtime_log_t;\n\n/* Initialisation */\n\n/* Initialise runtime log, loading current parameters\n * if log file exists. Returned object must be free()'d.\n * Returns NULL if core_path is invalid, or content_path\n * is invalid and core does not support contentless\n * operation */\nruntime_log_t *runtime_log_init(\n      const char *content_path,\n      const char *core_path,\n      const char *dir_runtime_log,\n      const char *dir_playlist,\n      bool log_per_core);\n\n/* Setters */\n\n/* Adds specified microseconds value to current runtime */\nvoid runtime_log_add_runtime_usec(runtime_log_t *runtime_log, retro_time_t usec);\n\n/* Sets last played entry to specified value */\nvoid runtime_log_set_last_played(runtime_log_t *runtime_log,\n      unsigned year, unsigned month, unsigned day,\n      unsigned hour, unsigned minute, unsigned second);\n\n/* Sets last played entry to current date/time */\nvoid runtime_log_set_last_played_now(runtime_log_t *runtime_log);\n\n/* Resets log to default (zero) values */\nvoid runtime_log_reset(runtime_log_t *runtime_log);\n\n/* Getters */\n/* (Not strictly required, since we can get everything\n * from runtime_log directly - but perhaps it is logically\n * cleaner to have a symmetrical set/get interface) */\n\n/* Gets runtime as a pre-formatted string */\nvoid runtime_log_get_runtime_str(runtime_log_t *runtime_log, char *str, size_t len);\n\n/* Gets last played entry values */\nvoid runtime_log_get_last_played(runtime_log_t *runtime_log,\n      unsigned *year, unsigned *month, unsigned *day,\n      unsigned *hour, unsigned *minute, unsigned *second);\n\n/* Gets last played entry value as a pre-formatted string */\nvoid runtime_log_get_last_played_str(runtime_log_t *runtime_log,\n      char *str, size_t len,\n      enum playlist_sublabel_last_played_style_type timedate_style,\n      enum playlist_sublabel_last_played_date_separator_type date_separator);\n\n/* Status */\n\n/* Returns true if log has a non-zero runtime entry */\nbool runtime_log_has_runtime(runtime_log_t *runtime_log);\n\n/* Saving */\n\n/* Saves specified runtime log to disk */\nvoid runtime_log_save(runtime_log_t *runtime_log);\n\n/* Utility functions */\n\n/* Convert from microseconds to hours, minutes, seconds */\nvoid runtime_log_convert_usec2hms(retro_time_t usec, unsigned *hours, unsigned *minutes, unsigned *seconds);\n\n/* Playlist manipulation */\n\n/* Updates specified playlist entry runtime values with\n * contents of associated log file */\nvoid runtime_update_playlist(\n      playlist_t *playlist, size_t idx,\n      const char *dir_runtime_log,\n      const char *dir_playlist,\n      bool log_per_core,\n      enum playlist_sublabel_last_played_style_type timedate_style,\n      enum playlist_sublabel_last_played_date_separator_type date_separator);\n\n#if defined(HAVE_MENU)\n/* Contentless cores manipulation */\n\n/* Updates specified contentless core runtime values with\n * contents of associated log file */\nvoid runtime_update_contentless_core(\n      const char *core_path,\n      const char *dir_runtime_log,\n      const char *dir_playlist,\n      bool log_per_core,\n      enum playlist_sublabel_last_played_style_type timedate_style,\n      enum playlist_sublabel_last_played_date_separator_type date_separator);\n#endif\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "runtime_file_defines.h",
          "type": "blob",
          "size": 3.0068359375,
          "content": "/* Copyright  (C) 2010-2019 The RetroArch team\n *\n * ---------------------------------------------------------------------------------------\n * The following license statement only applies to this file (runtime_file.h).\n * ---------------------------------------------------------------------------------------\n *\n * Permission is hereby granted, free of charge,\n * to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#ifndef __RUNTIME_FILE_DEFINES_H\n#define __RUNTIME_FILE_DEFINES_H\n\n#include <retro_common_api.h>\n#include <libretro.h>\n\nRETRO_BEGIN_DECLS\n\n/* Enums */\n\nenum playlist_sublabel_last_played_style_type\n{\n   PLAYLIST_LAST_PLAYED_STYLE_YMD_HMS = 0,\n   PLAYLIST_LAST_PLAYED_STYLE_YMD_HM,\n   PLAYLIST_LAST_PLAYED_STYLE_YMD,\n   PLAYLIST_LAST_PLAYED_STYLE_YM,\n   PLAYLIST_LAST_PLAYED_STYLE_MDYYYY_HMS,\n   PLAYLIST_LAST_PLAYED_STYLE_MDYYYY_HM,\n   PLAYLIST_LAST_PLAYED_STYLE_MD_HM,\n   PLAYLIST_LAST_PLAYED_STYLE_MDYYYY,\n   PLAYLIST_LAST_PLAYED_STYLE_MD,\n   PLAYLIST_LAST_PLAYED_STYLE_DDMMYYYY_HMS,\n   PLAYLIST_LAST_PLAYED_STYLE_DDMMYYYY_HM,\n   PLAYLIST_LAST_PLAYED_STYLE_DDMM_HM,\n   PLAYLIST_LAST_PLAYED_STYLE_DDMMYYYY,\n   PLAYLIST_LAST_PLAYED_STYLE_DDMM,\n   PLAYLIST_LAST_PLAYED_STYLE_YMD_HMS_AMPM,\n   PLAYLIST_LAST_PLAYED_STYLE_YMD_HM_AMPM,\n   PLAYLIST_LAST_PLAYED_STYLE_MDYYYY_HMS_AMPM,\n   PLAYLIST_LAST_PLAYED_STYLE_MDYYYY_HM_AMPM,\n   PLAYLIST_LAST_PLAYED_STYLE_MD_HM_AMPM,\n   PLAYLIST_LAST_PLAYED_STYLE_DDMMYYYY_HMS_AMPM,\n   PLAYLIST_LAST_PLAYED_STYLE_DDMMYYYY_HM_AMPM,\n   PLAYLIST_LAST_PLAYED_STYLE_DDMM_HM_AMPM,\n   PLAYLIST_LAST_PLAYED_STYLE_AGO,\n   PLAYLIST_LAST_PLAYED_STYLE_LAST\n};\n\n/* Note: These must be kept synchronised with\n * 'enum menu_timedate_date_separator_type' in\n * 'menu_defines.h' */\nenum playlist_sublabel_last_played_date_separator_type\n{\n   PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_HYPHEN = 0,\n   PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_SLASH,\n   PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_PERIOD,\n   PLAYLIST_LAST_PLAYED_DATE_SEPARATOR_LAST\n};\n\nenum playlist_sublabel_runtime\n{\n   PLAYLIST_RUNTIME_PER_CORE = 0,\n   PLAYLIST_RUNTIME_AGGREGATE,\n   PLAYLIST_RUNTIME_LAST\n};\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "samples",
          "type": "tree",
          "content": null
        },
        {
          "name": "save.c",
          "type": "blob",
          "size": 13.8046875,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n#include <stdint.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <string.h>\n#include <time.h>\n\n#include <lists/string_list.h>\n#include <streams/interface_stream.h>\n#include <streams/file_stream.h>\n#include <streams/rzip_stream.h>\n#include <rthreads/rthreads.h>\n#include <file/file_path.h>\n#include <string/stdstring.h>\n#include <time/rtime.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"content.h\"\n#include \"core.h\"\n#include \"core_info.h\"\n#include \"file_path_special.h\"\n#include \"configuration.h\"\n#include \"msg_hash.h\"\n#include \"runloop.h\"\n#include \"verbosity.h\"\n#ifdef HAVE_CHEATS\n#include \"cheat_manager.h\"\n#endif\n\nstruct ram_type\n{\n   const char *path;\n   int type;\n};\n\nstatic struct string_list *task_save_files = NULL;\n\n#ifdef HAVE_THREADS\ntypedef struct autosave autosave_t;\n\n/* Autosave support. */\nstruct autosave_st\n{\n   autosave_t **list;\n   unsigned num;\n};\n\nenum autosave_flags\n{\n   AUTOSAVE_FLAG_QUIT           = (1 << 0),\n   AUTOSAVE_FLAG_COMPRESS_FILES = (1 << 1)\n};\n\nstruct autosave\n{\n   void *buffer;\n   const void *retro_buffer;\n   const char *path;\n   slock_t *lock;\n   slock_t *cond_lock;\n   scond_t *cond;\n   sthread_t *thread;\n   size_t bufsize;\n   unsigned interval;\n   uint8_t flags;\n};\n\nstatic struct autosave_st autosave_state;\n\n\n/**\n * autosave_thread:\n * @data            : pointer to autosave object\n *\n * Callback function for (threaded) autosave.\n **/\nstatic void autosave_thread(void *data)\n{\n   autosave_t *save = (autosave_t*)data;\n\n   for (;;)\n   {\n      bool differ;\n\n      slock_lock(save->lock);\n      differ = memcmp(save->buffer, save->retro_buffer,\n            save->bufsize) != 0;\n      if (differ)\n         memcpy(save->buffer, save->retro_buffer, save->bufsize);\n      slock_unlock(save->lock);\n\n      if (differ)\n      {\n         intfstream_t *file = NULL;\n\n         /* Should probably deal with this more elegantly. */\n         if (save->flags & AUTOSAVE_FLAG_COMPRESS_FILES)\n            file = intfstream_open_rzip_file(save->path,\n                  RETRO_VFS_FILE_ACCESS_WRITE);\n         else\n            file = intfstream_open_file(save->path,\n                  RETRO_VFS_FILE_ACCESS_WRITE, RETRO_VFS_FILE_ACCESS_HINT_NONE);\n\n         if (file)\n         {\n            intfstream_write(file, save->buffer, save->bufsize);\n            intfstream_flush(file);\n            intfstream_close(file);\n            free(file);\n         }\n      }\n\n      slock_lock(save->cond_lock);\n\n      if (save->flags & AUTOSAVE_FLAG_QUIT)\n      {\n         slock_unlock(save->cond_lock);\n         break;\n      }\n\n      scond_wait_timeout(save->cond,\n            save->cond_lock,\n#if defined(_MSC_VER) && _MSC_VER <= 1200\n            save->interval * 1000000\n#else\n            save->interval * 1000000LL\n#endif\n            );\n\n      slock_unlock(save->cond_lock);\n   }\n}\n\n/**\n * autosave_new:\n * @path            : path to autosave file\n * @data            : pointer to buffer\n * @size            : size of @data buffer\n * @interval        : interval at which saves should be performed.\n *\n * Create and initialize autosave object.\n *\n * @return Pointer to new autosave_t object if successful, otherwise\n * NULL.\n **/\nstatic autosave_t *autosave_new(const char *path,\n      const void *data, size_t size,\n      unsigned interval, bool compress)\n{\n   void       *buf               = NULL;\n   autosave_t *handle            = (autosave_t*)malloc(sizeof(*handle));\n   if (!handle)\n      return NULL;\n\n   handle->flags                 = 0;\n   handle->bufsize               = size;\n   handle->interval              = interval;\n   if (compress)\n      handle->flags             |= AUTOSAVE_FLAG_COMPRESS_FILES;\n   handle->retro_buffer          = data;\n   handle->path                  = path;\n\n   if (!(buf = malloc(size)))\n   {\n      free(handle);\n      return NULL;\n   }\n\n   handle->buffer                = buf;\n\n   memcpy(handle->buffer, handle->retro_buffer, handle->bufsize);\n\n   handle->lock                  = slock_new();\n   handle->cond_lock             = slock_new();\n   handle->cond                  = scond_new();\n   handle->thread                = sthread_create(autosave_thread, handle);\n\n   return handle;\n}\n\n/**\n * autosave_free:\n * @handle          : pointer to autosave object\n *\n * Frees autosave object.\n **/\nstatic void autosave_free(autosave_t *handle)\n{\n   slock_lock(handle->cond_lock);\n   handle->flags |= AUTOSAVE_FLAG_QUIT;\n   slock_unlock(handle->cond_lock);\n   scond_signal(handle->cond);\n   sthread_join(handle->thread);\n\n   slock_free(handle->lock);\n   slock_free(handle->cond_lock);\n   scond_free(handle->cond);\n\n   if (handle->buffer)\n      free(handle->buffer);\n   handle->buffer = NULL;\n}\n\nbool autosave_init(void)\n{\n   unsigned i;\n   autosave_t **list          = NULL;\n   settings_t *settings       = config_get_ptr();\n   unsigned autosave_interval = settings->uints.autosave_interval;\n#if defined(HAVE_ZLIB)\n   bool compress_files        = settings->bools.save_file_compression;\n#else\n   bool compress_files        = false;\n#endif\n\n   if (autosave_interval < 1 || !task_save_files)\n      return false;\n\n   if (!(list = (autosave_t**)\n      calloc(task_save_files->size,\n            sizeof(*autosave_state.list))))\n      return false;\n\n   autosave_state.list = list;\n   autosave_state.num  = (unsigned)task_save_files->size;\n\n   for (i = 0; i < task_save_files->size; i++)\n   {\n      retro_ctx_memory_info_t mem_info;\n      autosave_t *auto_st = NULL;\n      const char *path    = task_save_files->elems[i].data;\n      unsigned    type    = task_save_files->elems[i].attr.i;\n\n      mem_info.id         = type;\n\n      core_get_memory(&mem_info);\n\n      if (mem_info.size <= 0)\n         continue;\n\n      if (!(auto_st = autosave_new(path,\n            mem_info.data,\n            mem_info.size,\n            autosave_interval,\n            compress_files)))\n      {\n         RARCH_WARN(\"%s\\n\", msg_hash_to_str(MSG_AUTOSAVE_FAILED));\n         continue;\n      }\n\n      autosave_state.list[i] = auto_st;\n   }\n\n   return true;\n}\n\nvoid autosave_deinit(void)\n{\n   unsigned i;\n\n   for (i = 0; i < autosave_state.num; i++)\n   {\n      autosave_t *handle = autosave_state.list[i];\n      if (handle)\n      {\n         autosave_free(handle);\n         free(autosave_state.list[i]);\n      }\n      autosave_state.list[i] = NULL;\n   }\n\n   free(autosave_state.list);\n\n   autosave_state.list     = NULL;\n   autosave_state.num      = 0;\n}\n\n/**\n * autosave_lock:\n *\n * Lock autosave.\n **/\nvoid autosave_lock(void)\n{\n   unsigned i;\n\n   for (i = 0; i < autosave_state.num; i++)\n   {\n      autosave_t *handle = autosave_state.list[i];\n      if (handle)\n         slock_lock(handle->lock);\n   }\n}\n\n/**\n * autosave_unlock:\n *\n * Unlocks autosave.\n **/\nvoid autosave_unlock(void)\n{\n   unsigned i;\n\n   for (i = 0; i < autosave_state.num; i++)\n   {\n      autosave_t *handle = autosave_state.list[i];\n      if (handle)\n         slock_unlock(handle->lock);\n   }\n}\n#endif\n\nstatic bool content_get_memory(retro_ctx_memory_info_t *mem_info,\n      struct ram_type *ram, unsigned slot)\n{\n   ram->type     = task_save_files->elems[slot].attr.i;\n   ram->path     = task_save_files->elems[slot].data;\n   mem_info->id  = ram->type;\n\n   core_get_memory(mem_info);\n\n   if (!mem_info->data || mem_info->size == 0)\n      return false;\n\n   return true;\n}\n\n/**\n * content_load_ram_file:\n * @path             : path of RAM state that will be loaded from.\n * @type             : type of memory\n *\n * Load a RAM state from disk to memory.\n */\nstatic bool content_load_ram_file(unsigned slot)\n{\n   int64_t rc;\n   struct ram_type ram;\n   retro_ctx_memory_info_t mem_info;\n   void *buf        = NULL;\n\n   if (!content_get_memory(&mem_info, &ram, slot))\n      return false;\n\n   /* On first run of content, SRAM file will\n    * not exist. This is a common enough occurrence\n    * that we should check before attempting to\n    * invoke the relevant read_file() function */\n   if (    string_is_empty(ram.path)\n       || !path_is_valid(ram.path))\n      return false;\n\n#if defined(HAVE_ZLIB)\n   /* Always use RZIP interface when reading SRAM\n    * files - this will automatically handle uncompressed\n    * data */\n   if (!rzipstream_read_file(ram.path, &buf, &rc))\n#else\n   if (!filestream_read_file(ram.path, &buf, &rc))\n#endif\n      return false;\n\n   if (rc > 0)\n   {\n      if (rc > (ssize_t)mem_info.size)\n      {\n         RARCH_WARN(\"[SRAM]: SRAM is larger than implementation expects, \"\n               \"doing partial load (truncating %u %s %s %u).\\n\",\n               (unsigned)rc,\n               msg_hash_to_str(MSG_BYTES),\n               msg_hash_to_str(MSG_TO),\n               (unsigned)mem_info.size);\n         rc = mem_info.size;\n      }\n      memcpy(mem_info.data, buf, (size_t)rc);\n   }\n\n   if (buf)\n      free(buf);\n\n   return true;\n}\n\n/**\n * dump_to_file_desperate:\n * @data         : pointer to data buffer.\n * @size         : size of @data.\n * @type         : type of file to be saved.\n *\n * Attempt to save valuable RAM data somewhere.\n **/\nstatic bool dump_to_file_desperate(const void *data,\n      size_t size, unsigned type)\n{\n   char path[PATH_MAX_LENGTH + 256 + 32];\n   path            [0]    = '\\0';\n\n   if (fill_pathname_application_data(path,\n            sizeof(path)))\n   {\n      size_t _len;\n      time_t time_;\n      struct tm tm_;\n      time(&time_);\n      rtime_localtime(&time_, &tm_);\n      _len  = strlcat(path, \"/RetroArch-recovery-\", sizeof(path));\n      _len += snprintf(path + _len, sizeof(path) - _len, \"%u\", type);\n      strftime(path + _len, sizeof(path) - _len,\n            \"%Y-%m-%d-%H-%M-%S\", &tm_);\n\n      /* Fallback (emergency) saves are always\n       * uncompressed\n       * > If a regular save fails, then the host\n       *   system is experiencing serious technical\n       *   difficulties (most likely some kind of\n       *   hardware failure)\n       * > In this case, we don't want to further\n       *   complicate matters by introducing zlib\n       *   compression overheads */\n      if (filestream_write_file(path, data, size))\n      {\n         RARCH_WARN(\"[SRAM]: Succeeded in saving RAM data to \\\"%s\\\".\\n\", path);\n         return true;\n      }\n   }\n\n   return false;\n}\n\n/**\n * content_save_ram_file:\n * @path             : path of RAM state that shall be written to.\n * @type             : type of memory\n *\n * Save a RAM state from memory to disk.\n *\n */\nstatic bool content_save_ram_file(unsigned slot, bool compress)\n{\n   struct ram_type ram;\n   retro_ctx_memory_info_t mem_info;\n\n   if (!content_get_memory(&mem_info, &ram, slot))\n      return false;\n\n   RARCH_LOG(\"[SRAM]: %s #%u %s \\\"%s\\\".\\n\",\n         msg_hash_to_str(MSG_SAVING_RAM_TYPE),\n         ram.type,\n         msg_hash_to_str(MSG_TO),\n         ram.path);\n\n#if defined(HAVE_ZLIB)\n   if (compress)\n   {\n      if (!rzipstream_write_file(\n            ram.path, mem_info.data, mem_info.size))\n         goto fail;\n   }\n   else\n#endif\n   {\n      if (!filestream_write_file(\n            ram.path, mem_info.data, mem_info.size))\n         goto fail;\n   }\n\n   RARCH_LOG(\"[SRAM]: %s \\\"%s\\\".\\n\",\n         msg_hash_to_str(MSG_SAVED_SUCCESSFULLY_TO),\n         ram.path);\n\n   return true;\n\nfail:\n   RARCH_ERR(\"[SRAM]: %s.\\n\",\n         msg_hash_to_str(MSG_FAILED_TO_SAVE_SRAM));\n   RARCH_WARN(\"[SRAM]: Attempting to recover ...\\n\");\n\n   /* In case the file could not be written to,\n    * the fallback function 'dump_to_file_desperate'\n    * will be called. */\n   if (!dump_to_file_desperate(\n            mem_info.data, mem_info.size, ram.type))\n      RARCH_WARN(\"[SRAM]: Failed ... Cannot recover save file.\\n\");\n   return false;\n}\n\nbool event_save_files(bool is_sram_used)\n{\n   unsigned i;\n   settings_t *settings            = config_get_ptr();\n#ifdef HAVE_CHEATS\n   const char *path_cheat_database = settings->paths.path_cheat_database;\n#endif\n#if defined(HAVE_ZLIB)\n   bool compress_files             = settings->bools.save_file_compression;\n#else\n   bool compress_files             = false;\n#endif\n\n#ifdef HAVE_CHEATS\n   cheat_manager_save_game_specific_cheats(\n         path_cheat_database);\n#endif\n   if (!task_save_files || !is_sram_used)\n      return false;\n\n   for (i = 0; i < task_save_files->size; i++)\n   {\n      content_save_ram_file(i, compress_files);\n   }\n\n   return true;\n}\n\nbool event_load_save_files(bool is_sram_load_disabled)\n{\n   unsigned i;\n   bool success = false;\n\n   if (!task_save_files || is_sram_load_disabled)\n      return false;\n\n   /* Report a successful load operation if\n    * any type of RAM file is found and\n    * processed correctly */\n   for (i = 0; i < task_save_files->size; i++)\n      success |= content_load_ram_file(i);\n\n   return success;\n}\n\nvoid path_init_savefile_rtc(const char *savefile_path)\n{\n   union string_list_elem_attr attr;\n   char savefile_name_rtc[PATH_MAX_LENGTH];\n\n   attr.i = RETRO_MEMORY_SAVE_RAM;\n   string_list_append(task_save_files, savefile_path, attr);\n\n   /* Infer .rtc save path from save RAM path. */\n   attr.i = RETRO_MEMORY_RTC;\n   fill_pathname(savefile_name_rtc,\n         savefile_path, \".rtc\",\n         sizeof(savefile_name_rtc));\n   string_list_append(task_save_files, savefile_name_rtc, attr);\n}\n\nvoid path_deinit_savefile(void)\n{\n   if (task_save_files)\n      string_list_free(task_save_files);\n   task_save_files = NULL;\n}\n\nvoid path_init_savefile_new(void)\n{\n   task_save_files = string_list_new();\n}\n\nvoid *savefile_ptr_get(void)\n{\n   return task_save_files;\n}\n\n"
        },
        {
          "name": "setting_list.h",
          "type": "blob",
          "size": 5.9453125,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __SETTING_LIST_H\n#define __SETTING_LIST_H\n\n#include <boolean.h>\n\n#include <retro_common_api.h>\n\n#include \"command.h\"\n#include \"msg_hash.h\"\n\nRETRO_BEGIN_DECLS\n\nenum setting_type\n{\n   ST_NONE = 0,\n   ST_ACTION,\n   ST_BOOL,\n   ST_INT,\n   ST_UINT,\n   ST_SIZE,\n   ST_FLOAT,\n   ST_PATH,\n   ST_DIR,\n   ST_STRING,\n   ST_STRING_OPTIONS,\n   ST_BIND,\n   ST_GROUP,\n   ST_SUB_GROUP,\n   ST_END_GROUP,\n   ST_END_SUB_GROUP\n};\n\nenum ui_setting_type\n{\n   ST_UI_TYPE_NONE = 0,\n   ST_UI_TYPE_CHECKBOX,\n   ST_UI_TYPE_UINT_COLOR_BUTTON,\n   ST_UI_TYPE_UINT_SPINBOX,\n   ST_UI_TYPE_UINT_COMBOBOX,\n   ST_UI_TYPE_UINT_RADIO_BUTTONS,\n   ST_UI_TYPE_FLOAT_COLOR_BUTTON,\n   ST_UI_TYPE_FLOAT_SPINBOX,\n   ST_UI_TYPE_FLOAT_SLIDER_AND_SPINBOX,\n   ST_UI_TYPE_SIZE_SPINBOX,\n   ST_UI_TYPE_BIND_BUTTON,\n   ST_UI_TYPE_DIRECTORY_SELECTOR,\n   ST_UI_TYPE_FILE_SELECTOR,\n   ST_UI_TYPE_FONT_SELECTOR,\n   ST_UI_TYPE_STRING_COMBOBOX,\n   ST_UI_TYPE_STRING_LINE_EDIT,\n   ST_UI_TYPE_PASSWORD_LINE_EDIT,\n   ST_UI_TYPE_LAST\n};\n\nenum setting_flags\n{\n   SD_FLAG_NONE             = 0,\n   SD_FLAG_PATH_DIR         = (1 << 0),\n   SD_FLAG_PATH_FILE        = (1 << 1),\n   SD_FLAG_ALLOW_EMPTY      = (1 << 2),\n   SD_FLAG_HAS_RANGE        = (1 << 3),\n   SD_FLAG_ALLOW_INPUT      = (1 << 4),\n   SD_FLAG_IS_DRIVER        = (1 << 5),\n   SD_FLAG_EXIT             = (1 << 6),\n   SD_FLAG_CMD_APPLY_AUTO   = (1 << 7),\n   SD_FLAG_BROWSER_ACTION   = (1 << 8),\n   SD_FLAG_ADVANCED         = (1 << 9),\n   SD_FLAG_LAKKA_ADVANCED   = (1 << 10),\n   SD_FLAG_ENFORCE_MINRANGE = (1 << 11),\n   SD_FLAG_ENFORCE_MAXRANGE = (1 << 12),\n   SD_FLAG_DONT_USE_ENUM_IDX_REPRESENTATION = (1 << 13),\n   SD_FLAG_CMD_TRIGGER_EVENT_TRIGGERED      = (1 << 14),\n   SD_FLAG_DEFAULT_VALUE    = (1 << 15)\n};\n\nenum settings_free_flags\n{\n   SD_FREE_FLAG_VALUES    = (1 << 0),\n   SD_FREE_FLAG_NAME      = (1 << 1),\n   SD_FREE_FLAG_SHORT     = (1 << 2)\n};\n\ntypedef struct rarch_setting rarch_setting_t;\ntypedef struct rarch_setting_group_info rarch_setting_group_info_t;\n\ntypedef void (*change_handler_t               )(rarch_setting_t *setting);\ntypedef int  (*action_left_handler_t          )(rarch_setting_t *setting, size_t idx, bool wraparound);\ntypedef int  (*action_right_handler_t         )(rarch_setting_t *setting, size_t idx, bool wraparound);\ntypedef int  (*action_up_handler_t            )(rarch_setting_t *setting);\ntypedef int  (*action_down_handler_t          )(rarch_setting_t *setting);\ntypedef int  (*action_start_handler_t         )(rarch_setting_t *setting);\ntypedef int  (*action_cancel_handler_t        )(rarch_setting_t *setting);\ntypedef int  (*action_ok_handler_t            )(rarch_setting_t *setting, size_t idx, bool wraparound);\ntypedef int  (*action_select_handler_t        )(rarch_setting_t *setting, size_t idx, bool wraparound);\ntypedef void (*get_string_representation_t    )(rarch_setting_t *setting, char *s, size_t len);\n\nstruct rarch_setting_group_info\n{\n   const char *name;\n};\n\nstruct rarch_setting\n{\n\n   float               min;\n   float               max;\n   struct\n   {\n      const char     *off_label;\n      const char     *on_label;\n   } boolean;\n   struct\n   {\n      const char     *empty_path;\n   } dir;\n   const char           *rounding_fraction;\n   const char           *name;\n   const char           *short_description;\n   const char           *group;\n   const char           *subgroup;\n   const char           *parent_group;\n   const char           *values;\n\n   change_handler_t              change_handler;\n   change_handler_t              read_handler;\n   action_start_handler_t        action_start;\n   action_left_handler_t         action_left;\n   action_right_handler_t        action_right;\n   action_up_handler_t           action_up;\n   action_down_handler_t         action_down;\n   action_cancel_handler_t       action_cancel;\n   action_ok_handler_t           action_ok;\n   action_select_handler_t       action_select;\n   get_string_representation_t   get_string_representation;\n\n   struct\n   {\n      union\n      {\n         bool                 *boolean;\n         char                 *string;\n         int                  *integer;\n         unsigned int         *unsigned_integer;\n         float                *fraction;\n         struct retro_keybind *keybind;\n         size_t               *sizet;\n      } target;\n   } value;\n\n\n   union\n   {\n      const char                 *string;\n      const struct retro_keybind *keybind;\n      size_t                     sizet;\n      int                        integer;\n      unsigned int               unsigned_integer;\n      float                      fraction;\n      bool                       boolean;\n   } default_value;\n\n   union\n   {\n      size_t         sizet;\n      int            integer;\n      unsigned int   unsigned_integer;\n      float          fraction;\n      bool           boolean;\n   } original_value;\n\n   uint32_t             index_offset;\n   uint32_t             size;\n   unsigned             bind_type;\n   float                step;\n\n   enum event_command   cmd_trigger_idx;\n   enum ui_setting_type ui_type;\n   enum setting_type    browser_selection_type;\n   enum msg_hash_enums  enum_idx;\n   enum msg_hash_enums  enum_value_idx;\n   enum setting_type    type;\n\n   uint16_t             flags;\n\n   int16_t              offset_by;\n   uint8_t              free_flags;\n   uint8_t              index;\n};\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "shaders-hlsl-no-opt",
          "type": "tree",
          "content": null
        },
        {
          "name": "shaders-hlsl",
          "type": "tree",
          "content": null
        },
        {
          "name": "shaders-msl",
          "type": "tree",
          "content": null
        },
        {
          "name": "shaders-no-opt",
          "type": "tree",
          "content": null
        },
        {
          "name": "shaders",
          "type": "tree",
          "content": null
        },
        {
          "name": "state_manager.c",
          "type": "blob",
          "size": 23.021484375,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2014-2017 - Alfred Agrell\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __STDC_LIMIT_MACROS\n#define __STDC_LIMIT_MACROS\n#endif\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <retro_inline.h>\n#include <compat/strl.h>\n#include <compat/intrinsics.h>\n\n#include \"state_manager.h\"\n#include \"msg_hash.h\"\n#include \"core.h\"\n#include \"core_info.h\"\n#include \"retroarch.h\"\n#include \"verbosity.h\"\n#include \"content.h\"\n#include \"audio/audio_driver.h\"\n\n#ifdef HAVE_NETWORKING\n#include \"network/netplay/netplay.h\"\n#endif\n\n/* This makes Valgrind throw errors if a core overflows its savestate size. */\n/* Keep it off unless you're chasing a core bug, it slows things down. */\n#define STRICT_BUF_SIZE 0\n\n#ifndef UINT16_MAX\n#define UINT16_MAX 0xffff\n#endif\n\n#ifndef UINT32_MAX\n#define UINT32_MAX 0xffffffffu\n#endif\n\n#if defined(__x86_64__) || defined(__i386__) || defined(__i486__) || defined(__i686__) || defined(_M_IX86) || defined(_M_AMD64) || defined(_M_X64)\n#define CPU_X86\n#endif\n\n/* Other arches SIGBUS (usually) on unaligned accesses. */\n#ifndef CPU_X86\n#define NO_UNALIGNED_MEM\n#endif\n\n#if __SSE2__\n#include <emmintrin.h>\n#endif\n\n/* Format per frame (pseudocode): */\n#if 0\nsize nextstart;\nrepeat {\n   uint16 numchanged; /* everything is counted in units of uint16 */\n   if (numchanged)\n   {\n      uint16 numunchanged; /* skip these before handling numchanged */\n      uint16[numchanged] changeddata;\n   }\n   else\n   {\n      uint32 numunchanged;\n      if (!numunchanged)\n         break;\n   }\n}\nsize thisstart;\n#endif\n\n/* There's no equivalent in libc, you'd think so ...\n * std::mismatch exists, but it's not optimized at all. */\nstatic size_t find_change(const uint16_t *a, const uint16_t *b)\n{\n#if __SSE2__\n   const __m128i *a128 = (const __m128i*)a;\n   const __m128i *b128 = (const __m128i*)b;\n\n   for (;;)\n   {\n      __m128i v0    = _mm_loadu_si128(a128);\n      __m128i v1    = _mm_loadu_si128(b128);\n      __m128i c     = _mm_cmpeq_epi8(v0, v1);\n      uint32_t mask = _mm_movemask_epi8(c);\n\n      if (mask != 0xffff) /* Something has changed, figure out where. */\n      {\n         /* calculate the real offset to the differing byte */\n         size_t ret = (((uint8_t*)a128 - (uint8_t*)a) |\n               (compat_ctz(~mask)));\n\n         /* and convert that to the uint16_t offset */\n         return (ret >> 1);\n      }\n\n      a128++;\n      b128++;\n   }\n#else\n   const uint16_t *a_org = a;\n#ifdef NO_UNALIGNED_MEM\n   while (((uintptr_t)a & (sizeof(size_t) - 1)) && *a == *b)\n   {\n      a++;\n      b++;\n   }\n   if (*a == *b)\n#endif\n   {\n      const size_t *a_big = (const size_t*)a;\n      const size_t *b_big = (const size_t*)b;\n\n      while (*a_big == *b_big)\n      {\n         a_big++;\n         b_big++;\n      }\n      a = (const uint16_t*)a_big;\n      b = (const uint16_t*)b_big;\n\n      while (*a == *b)\n      {\n         a++;\n         b++;\n      }\n   }\n   return a - a_org;\n#endif\n}\n\nstatic size_t find_same(const uint16_t *a, const uint16_t *b)\n{\n   const uint16_t *a_org = a;\n#ifdef NO_UNALIGNED_MEM\n   if (((uintptr_t)a & (sizeof(uint32_t) - 1)) && *a != *b)\n   {\n      a++;\n      b++;\n   }\n   if (*a != *b)\n#endif\n   {\n      /* With this, it's random whether two consecutive identical\n       * words are caught.\n       *\n       * Luckily, compression rate is the same for both cases, and\n       * three is always caught.\n       *\n       * (We prefer to miss two-word blocks, anyways; fewer iterations\n       * of the outer loop, as well as in the decompressor.) */\n      const uint32_t *a_big = (const uint32_t*)a;\n      const uint32_t *b_big = (const uint32_t*)b;\n\n      while (*a_big != *b_big)\n      {\n         a_big++;\n         b_big++;\n      }\n      a = (const uint16_t*)a_big;\n      b = (const uint16_t*)b_big;\n\n      if (a != a_org && a[-1] == b[-1])\n      {\n         a--;\n         b--;\n      }\n   }\n   return a - a_org;\n}\n\n/* Returns the maximum compressed size of a savestate.\n * It is very likely to compress to far less. */\nstatic size_t state_manager_raw_maxsize(size_t uncomp)\n{\n   /* bytes covered by a compressed block */\n   const int maxcblkcover = UINT16_MAX * sizeof(uint16_t);\n   /* uncompressed size, rounded to 16 bits */\n   size_t uncomp16        = (uncomp + sizeof(uint16_t) - 1) & -sizeof(uint16_t);\n   /* number of blocks */\n   size_t maxcblks        = (uncomp + maxcblkcover - 1) / maxcblkcover;\n   return uncomp16 + maxcblks * sizeof(uint16_t) * 2 /* two u16 overhead per block */ + sizeof(uint16_t) *\n      3; /* three u16 to end it */\n}\n\n/*\n * See state_manager_raw_compress for information about this.\n * When you're done with it, send it to free().\n */\nstatic void *state_manager_raw_alloc(size_t len, uint16_t uniq)\n{\n   size_t  len16 = (len + sizeof(uint16_t) - 1) & -sizeof(uint16_t);\n   uint16_t *ret = (uint16_t*)calloc(len16 + sizeof(uint16_t) * 4 + 16, 1);\n\n   if (!ret)\n      return NULL;\n\n   /* Force in a different byte at the end, so we don't need to check\n    * bounds in the innermost loop (it's expensive).\n    *\n    * There is also a large amount of data that's the same, to stop\n    * the other scan.\n    *\n    * There is also some padding at the end. This is so we don't\n    * read outside the buffer end if we're reading in large blocks;\n    *\n    * It doesn't make any difference to us, but sacrificing 16 bytes to get\n    * Valgrind happy is worth it. */\n   ret[len16/sizeof(uint16_t) + 3] = uniq;\n\n   return ret;\n}\n\n/*\n * Takes two savestates and creates a patch that turns 'src' into 'dst'.\n * Both 'src' and 'dst' must be returned from state_manager_raw_alloc(),\n * with the same 'len', and different 'uniq'.\n *\n * 'patch' must be size 'state_manager_raw_maxsize(len)' or more.\n * Returns the number of bytes actually written to 'patch'.\n */\nstatic size_t state_manager_raw_compress(const void *src,\n      const void *dst, size_t len, void *patch)\n{\n   const uint16_t  *old16 = (const uint16_t*)src;\n   const uint16_t  *new16 = (const uint16_t*)dst;\n   uint16_t *compressed16 = (uint16_t*)patch;\n   size_t          num16s = (len + sizeof(uint16_t) - 1)\n      / sizeof(uint16_t);\n\n   while (num16s)\n   {\n      size_t i, changed;\n      size_t skip = find_change(old16, new16);\n\n      if (skip >= num16s)\n         break;\n\n      old16  += skip;\n      new16  += skip;\n      num16s -= skip;\n\n      if (skip > UINT16_MAX)\n      {\n         /* This will make it scan the entire thing again,\n          * but it only hits on 8GB unchanged data anyways,\n          * and if you're doing that, you've got bigger problems. */\n         if (skip > UINT32_MAX)\n            skip         = UINT32_MAX;\n\n         *compressed16++ = 0;\n         *compressed16++ = skip;\n         *compressed16++ = skip >> 16;\n         continue;\n      }\n\n      changed         = find_same(old16, new16);\n      if (changed > UINT16_MAX)\n         changed = UINT16_MAX;\n\n      *compressed16++ = changed;\n      *compressed16++ = skip;\n\n      for (i = 0; i < changed; i++)\n         compressed16[i] = old16[i];\n\n      old16        += changed;\n      new16        += changed;\n      num16s       -= changed;\n      compressed16 += changed;\n   }\n\n   compressed16[0]  = 0;\n   compressed16[1]  = 0;\n   compressed16[2]  = 0;\n\n   return (uint8_t*)(compressed16 + 3) - (uint8_t*)patch;\n}\n\n/*\n * Takes 'patch' from a previous call to 'state_manager_raw_compress'\n * and applies it to 'data' ('src' from that call),\n * yielding 'dst' in that call.\n *\n * If the given arguments do not match a previous call to\n * state_manager_raw_compress(), anything at all can happen.\n */\nstatic void state_manager_raw_decompress(const void *patch,\n      size_t patchlen, void *data, size_t datalen)\n{\n   uint16_t         *out16 = (uint16_t*)data;\n   const uint16_t *patch16 = (const uint16_t*)patch;\n\n   for (;;)\n   {\n      uint16_t numchanged  = *(patch16++);\n\n      if (numchanged)\n      {\n         uint16_t i;\n\n         out16       += *patch16++;\n\n         /* We could do memcpy, but it seems that memcpy has a\n          * constant-per-call overhead that actually shows up.\n          *\n          * Our average size in here seems to be 8 or something.\n          * Therefore, we do something with lower overhead. */\n         for (i = 0; i < numchanged; i++)\n            out16[i]  = patch16[i];\n\n         patch16     += numchanged;\n         out16       += numchanged;\n      }\n      else\n      {\n         uint32_t numunchanged = patch16[0] | (patch16[1] << 16);\n\n         if (!numunchanged)\n            break;\n         patch16 += 2;\n         out16   += numunchanged;\n      }\n   }\n}\n\n/* The start offsets point to 'nextstart' of any given compressed frame.\n * Each uint16 is stored native endian; anything that claims any other\n * endianness refers to the endianness of this specific item.\n * The uint32 is stored little endian.\n *\n * Each size value is stored native endian if alignment is not enforced;\n * if it is, they're little endian.\n *\n * The start of the buffer contains a size pointing to the end of the\n * buffer; the end points to its start.\n *\n * Wrapping is handled by returning to the start of the buffer if the\n * compressed data could potentially hit the edge;\n *\n * if the compressed data could potentially overwrite the tail pointer,\n * the tail retreats until it can no longer collide.\n *\n * This means that on average, ~2 * maxcompsize is\n * unused at any given moment. */\n\n/* These are called very few constant times per frame,\n * keep it as simple as possible. */\nstatic INLINE void write_size_t(void *ptr, size_t val)\n{\n   memcpy(ptr, &val, sizeof(val));\n}\n\nstatic INLINE size_t read_size_t(const void *ptr)\n{\n   size_t ret;\n\n   memcpy(&ret, ptr, sizeof(ret));\n   return ret;\n}\n\nstatic void state_manager_free(state_manager_t *state)\n{\n   if (!state)\n      return;\n\n   if (state->data)\n      free(state->data);\n   if (state->thisblock)\n      free(state->thisblock);\n   if (state->nextblock)\n      free(state->nextblock);\n#if STRICT_BUF_SIZE\n   if (state->debugblock)\n      free(state->debugblock);\n   state->debugblock = NULL;\n#endif\n   state->data       = NULL;\n   state->thisblock  = NULL;\n   state->nextblock  = NULL;\n}\n\nstatic state_manager_t *state_manager_new(\n      size_t state_size, size_t buffer_size)\n{\n   size_t max_comp_size, block_size;\n   uint8_t *next_block    = NULL;\n   uint8_t *this_block    = NULL;\n   uint8_t *state_data    = NULL;\n   state_manager_t *state = (state_manager_t*)calloc(1, sizeof(*state));\n\n   if (!state)\n      return NULL;\n\n   block_size         = (state_size + sizeof(uint16_t) - 1) & -sizeof(uint16_t);\n   /* the compressed data is surrounded by pointers to the other side */\n   max_comp_size      = state_manager_raw_maxsize(state_size) + sizeof(size_t) * 2;\n   state_data         = (uint8_t*)malloc(buffer_size);\n\n   if (!state_data)\n      goto error;\n\n   this_block         = (uint8_t*)state_manager_raw_alloc(state_size, 0);\n   next_block         = (uint8_t*)state_manager_raw_alloc(state_size, 1);\n\n   if (!this_block || !next_block)\n      goto error;\n\n   state->blocksize   = block_size;\n   state->maxcompsize = max_comp_size;\n   state->data        = state_data;\n   state->thisblock   = this_block;\n   state->nextblock   = next_block;\n   state->capacity    = buffer_size;\n\n   state->head        = state->data + sizeof(size_t);\n   state->tail        = state->data + sizeof(size_t);\n\n#if STRICT_BUF_SIZE\n   state->debugsize   = state_size;\n   state->debugblock  = (uint8_t*)malloc(state_size);\n#endif\n\n   return state;\n\nerror:\n   if (state_data)\n      free(state_data);\n   state_manager_free(state);\n   free(state);\n\n   return NULL;\n}\n\nstatic bool state_manager_pop(state_manager_t *state, const void **data)\n{\n   size_t start;\n   uint8_t *out                 = NULL;\n   const uint8_t *compressed    = NULL;\n\n   *data                        = NULL;\n\n   if (state->thisblock_valid)\n   {\n      state->thisblock_valid    = false;\n      state->entries--;\n      *data                     = state->thisblock;\n      return true;\n   }\n\n   *data                        = state->thisblock;\n   if (state->head == state->tail)\n      return false;\n\n   start                        = read_size_t(state->head - sizeof(size_t));\n   state->head                  = state->data + start;\n   compressed                   = state->data + start + sizeof(size_t);\n   out                          = state->thisblock;\n\n   state_manager_raw_decompress(compressed,\n         state->maxcompsize, out, state->blocksize);\n\n   state->entries--;\n   return true;\n}\n\nstatic void state_manager_push_where(state_manager_t *state, void **data)\n{\n   /* We need to ensure we have an uncompressed copy of the last\n    * pushed state, or we could end up applying a 'patch' to wrong\n    * savestate, and that'd blow up rather quickly. */\n\n   if (!state->thisblock_valid)\n   {\n      const void *ignored;\n      if (state_manager_pop(state, &ignored))\n      {\n         state->thisblock_valid = true;\n         state->entries++;\n      }\n   }\n\n   *data = state->nextblock;\n#if STRICT_BUF_SIZE\n   *data = state->debugblock;\n#endif\n}\n\nstatic void state_manager_push_do(state_manager_t *state)\n{\n   uint8_t *swap = NULL;\n\n#if STRICT_BUF_SIZE\n   memcpy(state->nextblock, state->debugblock, state->debugsize);\n#endif\n\n   if (state->thisblock_valid)\n   {\n      const uint8_t *oldb, *newb;\n      uint8_t *compressed;\n      size_t headpos, tailpos, remaining;\n      if (state->capacity < sizeof(size_t) + state->maxcompsize) {\n         RARCH_ERR(\"State capacity insufficient\\n\");\n         return;\n      }\n\nrecheckcapacity:;\n      headpos   = state->head - state->data;\n      tailpos   = state->tail - state->data;\n      remaining = (tailpos + state->capacity -\n            sizeof(size_t) - headpos - 1) % state->capacity + 1;\n\n      if (remaining <= state->maxcompsize)\n      {\n         state->tail = state->data + read_size_t(state->tail);\n         state->entries--;\n         goto recheckcapacity;\n      }\n\n      oldb              = state->thisblock;\n      newb              = state->nextblock;\n      compressed        = state->head + sizeof(size_t);\n\n      compressed       += state_manager_raw_compress(oldb, newb,\n            state->blocksize, compressed);\n\n      if (compressed - state->data + state->maxcompsize > state->capacity)\n      {\n         compressed     = state->data;\n         if (state->tail == state->data + sizeof(size_t))\n            state->tail = state->data + read_size_t(state->tail);\n      }\n      write_size_t(compressed, state->head-state->data);\n      compressed       += sizeof(size_t);\n      write_size_t(state->head, compressed-state->data);\n      state->head       = compressed;\n   }\n   else\n      state->thisblock_valid = true;\n\n   swap                      = state->thisblock;\n   state->thisblock          = state->nextblock;\n   state->nextblock          = swap;\n\n   state->entries++;\n}\n\n#if 0\nstatic void state_manager_capacity(state_manager_t *state,\n      unsigned *entries, size_t *bytes, bool *full)\n{\n   size_t headpos   = state->head - state->data;\n   size_t tailpos   = state->tail - state->data;\n   size_t remaining = (tailpos + state->capacity -\n         sizeof(size_t) - headpos - 1) % state->capacity + 1;\n\n   if (entries)\n      *entries      = state->entries;\n   if (bytes)\n      *bytes        = state->capacity-remaining;\n   if (full)\n      *full         = remaining <= state->maxcompsize * 2;\n}\n#endif\n\nvoid state_manager_event_init(\n      struct state_manager_rewind_state *rewind_st,\n      unsigned rewind_buffer_size)\n{\n   core_info_t *core_info = NULL;\n   void *state            = NULL;\n\n   if (  !rewind_st\n       || (rewind_st->flags & STATE_MGR_REWIND_ST_FLAG_INIT_ATTEMPTED)\n       || rewind_st->state)\n      return;\n\n   rewind_st->size               = 0;\n   rewind_st->flags             &= ~(\n                                   STATE_MGR_REWIND_ST_FLAG_FRAME_IS_REVERSED\n                                 | STATE_MGR_REWIND_ST_FLAG_HOTKEY_WAS_CHECKED\n                                 | STATE_MGR_REWIND_ST_FLAG_HOTKEY_WAS_PRESSED\n                                    );\n\n   /* We cannot initialise the rewind buffer\n    * unless the core info struct for the current\n    * core has been initialised (i.e. without this,\n    * the savestate support level for the current\n    * core is unknown) */\n   if (!core_info_get_current_core(&core_info) || !core_info)\n      return;\n\n   rewind_st->flags |= STATE_MGR_REWIND_ST_FLAG_INIT_ATTEMPTED;\n\n   if (!core_info_current_supports_rewind())\n   {\n      RARCH_ERR(\"%s\\n\", msg_hash_to_str(MSG_REWIND_UNSUPPORTED));\n      return;\n   }\n\n   if (audio_driver_has_callback())\n   {\n      RARCH_ERR(\"%s.\\n\", msg_hash_to_str(MSG_REWIND_INIT_FAILED_THREADED_AUDIO));\n      return;\n   }\n\n   rewind_st->size = content_get_serialized_size_rewind();\n\n   if (!rewind_st->size)\n   {\n      RARCH_ERR(\"%s.\\n\",\n            msg_hash_to_str(MSG_REWIND_INIT_FAILED));\n      return;\n   }\n\n   RARCH_LOG(\"%s: %u MB\\n\",\n         msg_hash_to_str(MSG_REWIND_INIT),\n         (unsigned)(rewind_buffer_size / 1000000));\n\n   rewind_st->state = state_manager_new(rewind_st->size,\n         rewind_buffer_size);\n\n   if (!rewind_st->state)\n      RARCH_WARN(\"%s.\\n\", msg_hash_to_str(MSG_REWIND_INIT_FAILED));\n\n   state_manager_push_where(rewind_st->state, &state);\n\n   content_serialize_state_rewind(state, rewind_st->size);\n\n   state_manager_push_do(rewind_st->state);\n}\n\nvoid state_manager_event_deinit(\n      struct state_manager_rewind_state *rewind_st,\n      struct retro_core_t *current_core)\n{\n   bool restore_callbacks = false;\n\n   if (!rewind_st)\n      return;\n\n   restore_callbacks =\n            (rewind_st->flags & STATE_MGR_REWIND_ST_FLAG_INIT_ATTEMPTED)\n         && (rewind_st->state)\n         && (current_core);\n\n   if (rewind_st->state)\n   {\n      state_manager_free(rewind_st->state);\n      free(rewind_st->state);\n   }\n\n   rewind_st->state              = NULL;\n   rewind_st->size               = 0;\n   rewind_st->flags             &= ~(\n                                   STATE_MGR_REWIND_ST_FLAG_FRAME_IS_REVERSED\n                                 | STATE_MGR_REWIND_ST_FLAG_HOTKEY_WAS_CHECKED\n                                 | STATE_MGR_REWIND_ST_FLAG_HOTKEY_WAS_PRESSED\n                                 | STATE_MGR_REWIND_ST_FLAG_INIT_ATTEMPTED\n                                    );\n\n   /* Restore regular (non-rewind) core audio\n    * callbacks if required */\n   if (restore_callbacks)\n   {\n      if (current_core->retro_set_audio_sample)\n         current_core->retro_set_audio_sample(audio_driver_sample);\n\n      if (current_core->retro_set_audio_sample_batch)\n         current_core->retro_set_audio_sample_batch(audio_driver_sample_batch);\n   }\n}\n\n/**\n * check_rewind:\n * @pressed              : was rewind key pressed or held?\n *\n * Checks if rewind toggle/hold was being pressed and/or held.\n **/\nbool state_manager_check_rewind(\n      struct state_manager_rewind_state *rewind_st,\n      struct retro_core_t *current_core,\n      bool pressed,\n      unsigned rewind_granularity, bool is_paused,\n      char *s, size_t len, unsigned *time)\n{\n   bool ret          = false;\n#ifdef HAVE_NETWORKING\n   bool was_reversed = false;\n#endif\n\n   if (    !rewind_st\n       || (!(rewind_st->flags & STATE_MGR_REWIND_ST_FLAG_INIT_ATTEMPTED)))\n      return false;\n\n   if (!(rewind_st->flags & STATE_MGR_REWIND_ST_FLAG_HOTKEY_WAS_CHECKED))\n   {\n      rewind_st->flags |= STATE_MGR_REWIND_ST_FLAG_HOTKEY_WAS_CHECKED;\n      return false;\n   }\n\n   if (!rewind_st->state)\n   {\n      if ((pressed\n          && (!(rewind_st->flags\n                & STATE_MGR_REWIND_ST_FLAG_HOTKEY_WAS_PRESSED)))\n          && !core_info_current_supports_rewind())\n      {\n         const char *_msg = msg_hash_to_str(MSG_REWIND_UNSUPPORTED);\n         runloop_msg_queue_push(_msg, strlen(_msg), 1, 100, false, NULL,\n               MESSAGE_QUEUE_ICON_DEFAULT, MESSAGE_QUEUE_CATEGORY_INFO);\n      }\n\n      if (pressed)\n         rewind_st->flags |=  STATE_MGR_REWIND_ST_FLAG_HOTKEY_WAS_PRESSED;\n      else\n         rewind_st->flags &= ~STATE_MGR_REWIND_ST_FLAG_HOTKEY_WAS_PRESSED;\n      return false;\n   }\n\n   if (rewind_st->flags & STATE_MGR_REWIND_ST_FLAG_FRAME_IS_REVERSED)\n   {\n#ifdef HAVE_NETWORKING\n      was_reversed = true;\n#endif\n      audio_driver_frame_is_reverse();\n      rewind_st->flags &= ~STATE_MGR_REWIND_ST_FLAG_FRAME_IS_REVERSED;\n   }\n\n   if (pressed)\n   {\n      const void *buf    = NULL;\n\n      if (state_manager_pop(rewind_st->state, &buf))\n      {\n#ifdef HAVE_NETWORKING\n         /* Make sure netplay isn't confused */\n         if (!was_reversed\n               && !netplay_driver_ctl(RARCH_NETPLAY_CTL_DESYNC_PUSH, NULL))\n            return false;\n#endif\n\n         rewind_st->flags |= STATE_MGR_REWIND_ST_FLAG_FRAME_IS_REVERSED;\n\n         audio_driver_setup_rewind();\n\n         strlcpy(s, msg_hash_to_str(MSG_REWINDING), len);\n\n         *time                  = is_paused ? 1 : 30;\n         ret                    = true;\n\n         content_deserialize_state(buf, rewind_st->size);\n\n#ifdef HAVE_BSV_MOVIE\n         bsv_movie_frame_rewind();\n#endif\n      }\n      else\n      {\n         content_deserialize_state(buf, rewind_st->size);\n\n#ifdef HAVE_NETWORKING\n         /* Tell netplay we're done */\n         if (was_reversed)\n            netplay_driver_ctl(RARCH_NETPLAY_CTL_DESYNC_POP, NULL);\n#endif\n\n         strlcpy(s,\n               msg_hash_to_str(MSG_REWIND_REACHED_END),\n               len);\n\n         *time = 30;\n         ret   = true;\n      }\n   }\n   else\n   {\n      static unsigned cnt      = 0;\n\n#ifdef HAVE_NETWORKING\n      /* Tell netplay we're done */\n      if (was_reversed)\n         netplay_driver_ctl(RARCH_NETPLAY_CTL_DESYNC_POP, NULL);\n#endif\n\n      cnt = (cnt + 1) % (rewind_granularity ?\n            rewind_granularity : 1); /* Avoid possible SIGFPE. */\n\n      if (     !is_paused\n            && ((cnt == 0) || retroarch_ctl(RARCH_CTL_BSV_MOVIE_IS_INITED, NULL)))\n      {\n         void *state = NULL;\n         state_manager_push_where(rewind_st->state, &state);\n\n         content_serialize_state_rewind(state, rewind_st->size);\n\n         state_manager_push_do(rewind_st->state);\n      }\n   }\n\n   /* Update core audio callbacks */\n   if (current_core)\n   {\n      if (current_core->retro_set_audio_sample)\n         current_core->retro_set_audio_sample(\n               (rewind_st->flags\n                & STATE_MGR_REWIND_ST_FLAG_FRAME_IS_REVERSED)\n               ? audio_driver_sample_rewind\n               : audio_driver_sample);\n\n      if (current_core->retro_set_audio_sample_batch)\n         current_core->retro_set_audio_sample_batch(\n               (  rewind_st->flags\n                & STATE_MGR_REWIND_ST_FLAG_FRAME_IS_REVERSED)\n               ? audio_driver_sample_batch_rewind\n               : audio_driver_sample_batch);\n   }\n\n   if (pressed)\n      rewind_st->flags |=  STATE_MGR_REWIND_ST_FLAG_HOTKEY_WAS_PRESSED;\n   else\n      rewind_st->flags &= ~STATE_MGR_REWIND_ST_FLAG_HOTKEY_WAS_PRESSED;\n   return ret;\n}\n"
        },
        {
          "name": "state_manager.h",
          "type": "blob",
          "size": 2.7265625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2014-2017 - Alfred Agrell\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __STATE_MANAGER_H\n#define __STATE_MANAGER_H\n\n#include <stdint.h>\n#include <stddef.h>\n\n#include <boolean.h>\n#include <retro_common_api.h>\n\n#include \"dynamic.h\"\n\nRETRO_BEGIN_DECLS\n\nenum state_manager_rewind_st_flags\n{\n   STATE_MGR_REWIND_ST_FLAG_FRAME_IS_REVERSED     = (1 << 0),\n   STATE_MGR_REWIND_ST_FLAG_INIT_ATTEMPTED        = (1 << 1),\n   STATE_MGR_REWIND_ST_FLAG_HOTKEY_WAS_CHECKED    = (1 << 2),\n   STATE_MGR_REWIND_ST_FLAG_HOTKEY_WAS_PRESSED    = (1 << 3)\n};\n\nstruct state_manager\n{\n   uint8_t *data;\n   /* Reading and writing is done here here. */\n   uint8_t *head;\n   /* If head comes close to this, discard a frame. */\n   uint8_t *tail;\n\n   uint8_t *thisblock;\n   uint8_t *nextblock;\n#if STRICT_BUF_SIZE\n   uint8_t *debugblock;\n   size_t debugsize;\n#endif\n\n   size_t capacity;\n   /* This one is rounded up from reset::blocksize. */\n   size_t blocksize;\n   /* size_t + (blocksize + 131071) / 131072 *\n    * (blocksize + u16 + u16) + u16 + u32 + size_t\n    * (yes, the math is a bit ugly). */\n   size_t maxcompsize;\n\n   unsigned entries;\n   bool thisblock_valid;\n};\n\ntypedef struct state_manager state_manager_t;\n\nstruct state_manager_rewind_state\n{\n   /* Rewind support. */\n   state_manager_t *state;\n   size_t size;\n   uint8_t flags;\n};\n\nbool state_manager_frame_is_reversed(void);\n\nvoid state_manager_event_deinit(\n      struct state_manager_rewind_state *rewind_st,\n      struct retro_core_t *current_core);\n\nvoid state_manager_event_init(struct state_manager_rewind_state *rewind_st,\n      unsigned rewind_buffer_size);\n\n/**\n * check_rewind:\n * @pressed              : was rewind key pressed or held?\n *\n * Checks if rewind toggle/hold was being pressed and/or held.\n **/\nbool state_manager_check_rewind(\n      struct state_manager_rewind_state *rewind_st,\n      struct retro_core_t *current_core,\n      bool pressed,\n      unsigned rewind_granularity, bool is_paused,\n      char *s, size_t len, unsigned *time);\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "steam",
          "type": "tree",
          "content": null
        },
        {
          "name": "switch_performance_profiles.h",
          "type": "blob",
          "size": 1.49609375,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2018-2018 - Natinusala\n *  Copyright (C) 2018-2018 - M4xw\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __SWITCH_PERFORMANCE_PROFILES_H\n#define __SWITCH_PERFORMANCE_PROFILES_H\n\n#if defined(HAVE_LIBNX)\n\nstatic char *SWITCH_CPU_PROFILES[] = {\n    \"Maximum Performance\",\n    \"High Performance\",\n    \"Boost Performance\",\n    \"Stock Performance\",\n    \"Powersaving Mode 1\",\n    \"Powersaving Mode 2\",\n    \"Powersaving Mode 3\",\n};\n\n#define SWITCH_DEFAULT_CPU_PROFILE 3 /* Stock Performance */\n#define LIBNX_MAX_CPU_PROFILE 0 /* Max Performance */\n\nstatic char *SWITCH_CPU_SPEEDS[] = {\n    \"1785 MHz\",\n    \"1581 MHz\",\n    \"1224 MHz\",\n    \"1020 MHz\",\n    \"918 MHz\",\n    \"816 MHz\",\n    \"714 MHz\"\n};\n\nstatic unsigned SWITCH_CPU_SPEEDS_VALUES[] = {\n    1785000000,\n    1581000000,\n    1224000000,\n    1020000000,\n    918000000,\n    816000000,\n    714000000\n};\n\n#endif\n\n#endif\n"
        },
        {
          "name": "tasks",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests-other",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "translation_defines.h",
          "type": "blob",
          "size": 2.818359375,
          "content": "#ifndef __TRANSLATION_DEFINES__H\n#define __TRANSLATION_DEFINES__H\n\nenum translation_lang\n{\n   TRANSLATION_LANG_DONT_CARE = 0,\n   TRANSLATION_LANG_EN,    /* English  */\n   TRANSLATION_LANG_ES,    /* Spanish  */\n   TRANSLATION_LANG_FR,    /* French   */\n   TRANSLATION_LANG_IT,    /* Italian */\n   TRANSLATION_LANG_DE,    /* German   */\n   TRANSLATION_LANG_JP,    /* Japanese */\n   TRANSLATION_LANG_NL,    /* Dutch    */\n   TRANSLATION_LANG_CS,    /* Czech    */\n   TRANSLATION_LANG_DA,    /* Danish   */\n   TRANSLATION_LANG_SV,    /* Swedish */\n   TRANSLATION_LANG_HR,    /* Croatian */\n   TRANSLATION_LANG_KO,    /* Korean */\n   TRANSLATION_LANG_ZH_CN, /* Chinese Simplified */\n   TRANSLATION_LANG_ZH_TW, /* Chinese Traditional */\n   TRANSLATION_LANG_CA,    /* Catalan */\n   TRANSLATION_LANG_BG,    /* Bulgarian */\n   TRANSLATION_LANG_BN,    /* Bengali */\n   TRANSLATION_LANG_EU,    /* Basque */\n   TRANSLATION_LANG_AZ,    /* Azerbaijani */\n   TRANSLATION_LANG_AR,    /* Arabic */\n   TRANSLATION_LANG_SQ,    /* Albanian */\n   TRANSLATION_LANG_AF,    /* Afrikaans */\n   TRANSLATION_LANG_AST,    /* Asturian */\n   TRANSLATION_LANG_EO,    /* Esperanto */\n   TRANSLATION_LANG_ET,    /* Estonian */\n   TRANSLATION_LANG_TL,    /* Filipino */\n   TRANSLATION_LANG_FI,    /* Finnish */\n   TRANSLATION_LANG_GL,    /* Galician */\n   TRANSLATION_LANG_KA,    /* Georgian */\n   TRANSLATION_LANG_EL,    /* Greek */\n   TRANSLATION_LANG_GU,    /* Gujarati */\n   TRANSLATION_LANG_HT,    /* Haitian Creole */\n   TRANSLATION_LANG_HE,    /* Hebrew */\n   TRANSLATION_LANG_HI,    /* Hindi */\n   TRANSLATION_LANG_HU,    /* Hungarian */\n   TRANSLATION_LANG_IS,    /* Icelandic */\n   TRANSLATION_LANG_ID,    /* Indonesian */\n   TRANSLATION_LANG_GA,    /* Irish */\n   TRANSLATION_LANG_KN,    /* Kannada */\n   TRANSLATION_LANG_LA,    /* Latin */\n   TRANSLATION_LANG_LV,    /* Latvian */\n   TRANSLATION_LANG_LT,    /* Lithuanian */\n   TRANSLATION_LANG_MK,    /* Macedonian */\n   TRANSLATION_LANG_MS,    /* Malay */\n   TRANSLATION_LANG_MT,    /* Maltese */\n   TRANSLATION_LANG_NO,    /* Norwegian */\n   TRANSLATION_LANG_FA,    /* Persian */\n   TRANSLATION_LANG_PL,    /* Polish */\n   TRANSLATION_LANG_PT,    /* Portuguese */\n   TRANSLATION_LANG_RO,    /* Romanian */\n   TRANSLATION_LANG_RU,    /* Russian */\n   TRANSLATION_LANG_SR,    /* Serbian */\n   TRANSLATION_LANG_SK,    /* Slovak */\n   TRANSLATION_LANG_SL,    /* Slovenian */\n   TRANSLATION_LANG_SW,    /* Swahili */\n   TRANSLATION_LANG_TA,    /* Tamil */\n   TRANSLATION_LANG_TE,    /* Telugu */\n   TRANSLATION_LANG_TH,    /* Thai */\n   TRANSLATION_LANG_TR,    /* Turkish */\n   TRANSLATION_LANG_UK,    /* Ukrainian */\n   TRANSLATION_LANG_BE,    /* Belarusian */\n   TRANSLATION_LANG_UR,    /* Urdu */\n   TRANSLATION_LANG_VI,    /* Vietnamese */\n   TRANSLATION_LANG_CY,    /* Welsh */\n   TRANSLATION_LANG_YI,    /* Yiddish */\n   TRANSLATION_LANG_LAST\n};\n\n#endif\n"
        },
        {
          "name": "travis-deploy-key.enc",
          "type": "blob",
          "size": 1.640625,
          "content": null
        },
        {
          "name": "travis_metal_deploy.sh",
          "type": "blob",
          "size": 1.5703125,
          "content": "#!/bin/bash\n\nmkdir -p ~/.ssh\n\nchmod 700 ~/.ssh\n\necho \"Decrypting SSH key...\"\n\nopenssl aes-256-cbc -K $encrypted_e9bb4da59666_key -iv $encrypted_e9bb4da59666_iv -in travis-deploy-key.enc -out ~/.ssh/id_rsa -d\n\nchmod 600 ~/.ssh/id_rsa\n\nmkdir ~/dist\ncd ~/dist\n\necho \"Copying binary into dist folder...\"\n\ncp -rv  ${TRAVIS_BUILD_DIR}/pkg/apple/build/Release/RetroArch.app .\n\necho \"Downloading assets...\"\n\ncd RetroArch.app/Contents/Resources/\ncurl -O http://bot.libretro.com/assets/frontend/bundle.zip\nunzip -q -o bundle.zip\nrm -rf bundle.zip\n\necho \"Creating DMG image...\"\n\ncd ~/dist\n\nFILENAME=$(date +%F)_RetroArch_Metal.dmg\n\nhdiutil create -volname RetroArch -srcfolder ./ -ov -format UDZO ~/${FILENAME}\ncp -f ~/${FILENAME} ~/RetroArch_Metal.dmg\n\necho \"Notarizing DMG...\"\n\ncodesign --force --verbose --timestamp --sign \"7069CC8A4AE9AFF0493CC539BBA4FA345F0A668B\" ~/RetroArch_Metal.dmg\nREQUESTUUID=$(xcrun altool --notarize-app -t osx -f ~/RetroArch_Metal.dmg --primary-bundle-id com.libretro.RetroArchM -u $APPLE_ID -p $APPLE_ID_PASS -itc_provider UK699V5ZS8 | awk '/RequestUUID/ { print $NF; }')\nsleep 200\nxcrun altool --notarization-info $REQUESTUUID -u $APPLE_ID -p $APPLE_ID_PASS -ascprovider UK699V5ZS8\nxcrun stapler staple ~/RetroArch_Metal.dmg\nxcrun stapler validate ~/RetroArch_Metal.dmg\n\necho \"Uploading to server...\"\n\nrsync -avhP -e 'ssh -p 12346 -o StrictHostKeyChecking=no' ~/${FILENAME} travis@bot.libretro.com:~/nightly/apple/osx/x86_64/\nrsync -avhP -e 'ssh -p 12346 -o StrictHostKeyChecking=no' ~/RetroArch_Metal.dmg travis@bot.libretro.com:~/nightly/apple/osx/x86_64/\n\nrm -f ~/RetroArch_Metal.dmg\n"
        },
        {
          "name": "ui",
          "type": "tree",
          "content": null
        },
        {
          "name": "uwp",
          "type": "tree",
          "content": null
        },
        {
          "name": "verbosity.c",
          "type": "blob",
          "size": 14.6494140625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *  Copyright (C) 2016-2019 - Brad Parker\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifdef _XBOX1\n#include <xtl.h>\n#endif\n\n#if defined(__PSL1GHT__) || defined(__PS3__)\n#include <defines/ps3_defines.h>\n#endif\n\n#ifdef __MACH__\n#include <TargetConditionals.h>\n#include <Availability.h>\n#if TARGET_IPHONE_SIMULATOR\n#include <stdio.h>\n#else\n#if __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_10_0 || __TV_OS_VERSION_MIN_REQUIRED > __TVOS_10_0\n#include <os/log.h>\n#else\n#include <asl.h>\n#endif\n#endif\n#endif\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <time.h>\n\n#ifdef _MSC_VER\n#include <compat/msvc.h>\n#endif\n\n#ifdef ANDROID\n#include <android/log.h>\n#endif\n\n#if defined(_WIN32)\n\n#if defined(_XBOX)\n#include <Xtl.h>\n#else\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#endif\n\n#endif\n\n#include <file/file_path.h>\n#include <string/stdstring.h>\n#include <streams/file_stream.h>\n#include <compat/fopen_utf8.h>\n#include <time/rtime.h>\n#include <retro_miscellaneous.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef RARCH_INTERNAL\n#include \"frontend/frontend_driver.h\"\n#endif\n\n#include \"verbosity.h\"\n\n#ifdef HAVE_QT\n#include \"ui/ui_companion_driver.h\"\n#endif\n\n#ifdef RARCH_INTERNAL\n#include \"config.def.h\"\n#else\n#define DEFAULT_FRONTEND_LOG_LEVEL 1\n#endif\n\n#if defined(IS_SALAMANDER)\n#define FILE_PATH_PROGRAM_NAME \"RetroArch Salamander\"\n#else\n#define FILE_PATH_PROGRAM_NAME \"RetroArch\"\n#endif\n\ntypedef struct verbosity_state\n{\n#ifdef HAVE_LIBNX\n   Mutex mtx;\n#endif\n   /* If this is non-NULL. RARCH_LOG and friends\n    * will write to this file. */\n   FILE *fp;\n   void *buf;\n\n   char override_path[PATH_MAX_LENGTH];\n   bool verbosity;\n   bool initialized;\n   bool override_active;\n} verbosity_state_t;\n\n/* TODO/FIXME - static public global variables */\nstatic verbosity_state_t main_verbosity_st;\nstatic unsigned verbosity_log_level           =\nDEFAULT_FRONTEND_LOG_LEVEL;\n\n#ifdef HAVE_LIBNX\n#ifdef NXLINK\n/* TODO/FIXME - global referenced in platform_switch.c - not\n * thread-safe */\nbool nxlink_connected = false;\n#endif /* NXLINK */\n\n#endif /* HAVE_LIBNX */\n\nvoid verbosity_set_log_level(unsigned level)\n{\n   verbosity_log_level = level;\n}\n\nvoid verbosity_enable(void)\n{\n   verbosity_state_t *g_verbosity = &main_verbosity_st;\n\n   g_verbosity->verbosity         = true;\n#ifdef RARCH_INTERNAL\n   if (!g_verbosity->initialized)\n      frontend_driver_attach_console();\n#endif\n}\n\nvoid verbosity_disable(void)\n{\n   verbosity_state_t *g_verbosity = &main_verbosity_st;\n\n   g_verbosity->verbosity         = false;\n#ifdef RARCH_INTERNAL\n   if (!g_verbosity->initialized)\n      frontend_driver_detach_console();\n#endif\n}\n\nbool verbosity_is_enabled(void)\n{\n   verbosity_state_t *g_verbosity = &main_verbosity_st;\n   return g_verbosity->verbosity;\n}\n\nbool is_logging_to_file(void)\n{\n   verbosity_state_t *g_verbosity = &main_verbosity_st;\n   return g_verbosity->initialized;\n}\n\nbool *verbosity_get_ptr(void)\n{\n   verbosity_state_t *g_verbosity = &main_verbosity_st;\n   return &g_verbosity->verbosity;\n}\n\nvoid retro_main_log_file_init(const char *path, bool append)\n{\n   FILE *tmp                      = NULL;\n   verbosity_state_t *g_verbosity = &main_verbosity_st;\n   if (g_verbosity->initialized)\n      return;\n\n#ifdef HAVE_LIBNX\n   mutexInit(&g_verbosity->mtx);\n#endif\n\n   g_verbosity->fp      = stderr;\n   if (!path)\n      return;\n\n   tmp                  = (FILE*)fopen_utf8(path, append ? \"ab\" : \"wb\");\n\n   if (!tmp)\n   {\n      RARCH_ERR(\"Failed to open system event log file: %s\\n\", path);\n      return;\n   }\n\n   g_verbosity->fp          = tmp;\n   g_verbosity->initialized = true;\n\n   /* TODO: this is only useful for a few platforms, find which and add ifdef */\n   g_verbosity->buf         = calloc(1, 0x4000);\n   setvbuf(g_verbosity->fp, (char*)g_verbosity->buf, _IOFBF, 0x4000);\n}\n\nvoid retro_main_log_file_deinit(void)\n{\n   verbosity_state_t *g_verbosity = &main_verbosity_st;\n\n   if (g_verbosity->fp && g_verbosity->initialized)\n   {\n      fclose(g_verbosity->fp);\n      g_verbosity->fp       = NULL;\n   }\n   if (g_verbosity->buf)\n      free(g_verbosity->buf);\n   g_verbosity->buf         = NULL;\n   g_verbosity->initialized = false;\n}\n\n#if !defined(HAVE_LOGGER)\nvoid RARCH_LOG_V(const char *tag, const char *fmt, va_list ap)\n{\n#if defined(_XBOX1) || defined (__WINRT__)\n   /* FIXME: Using arbitrary string as fmt argument is unsafe. */\n   char msg_new[256];\n   char buffer[256];\n   const char *tag_v = tag ? tag : FILE_PATH_LOG_INFO;\n\n   msg_new[0]        = buffer[0] = '\\0';\n   snprintf(msg_new, sizeof(msg_new), \"%s: %s %s\",\n         FILE_PATH_PROGRAM_NAME, tag_v, fmt);\n#if defined(__WINRT__)\n   vsnprintf(buffer, sizeof(buffer), msg_new, ap);\n#else\n   wvsprintf(buffer, msg_new, ap);\n#endif\n   OutputDebugStringA(buffer);\n#elif defined(ANDROID)\n   verbosity_state_t *g_verbosity = &main_verbosity_st;\n   int prio = ANDROID_LOG_INFO;\n   if (tag)\n   {\n      if (string_is_equal(FILE_PATH_LOG_WARN, tag))\n         prio = ANDROID_LOG_WARN;\n      else if (string_is_equal(FILE_PATH_LOG_ERROR, tag))\n         prio = ANDROID_LOG_ERROR;\n   }\n\n   if (g_verbosity->initialized)\n   {\n      vfprintf(g_verbosity->fp, fmt, ap);\n      fflush(g_verbosity->fp);\n   }\n   else\n      __android_log_vprint(prio, FILE_PATH_PROGRAM_NAME, fmt, ap);\n#else\n   verbosity_state_t *g_verbosity = &main_verbosity_st;\n   FILE                       *fp = (FILE*)g_verbosity->fp;\n   const char              *tag_v = tag ? tag : FILE_PATH_LOG_INFO;\n#if defined(HAVE_QT) || defined(__WINRT__)\n   char buffer[1024];\n   buffer[0]         = '\\0';\n   /* Ensure NULL termination and line break in error case */\n   if (vsnprintf(buffer, sizeof(buffer), fmt, ap) < 0)\n   {\n      size_t end;\n      buffer[sizeof(buffer) - 1]  = '\\0';\n      end = strlen(buffer) - 1;\n      if (end >= 0)\n         buffer[end] = '\\n';\n      else\n      {\n         buffer[0]   = '\\n';\n         buffer[1]   = '\\0';\n      }\n   }\n\n   if (fp)\n   {\n      fprintf(fp, \"%s %s\", tag_v, buffer);\n      fflush(fp);\n   }\n\n#if defined(HAVE_QT)\n   ui_companion_driver_log_msg(buffer);\n#endif\n\n#if defined(__WINRT__)\n   OutputDebugStringA(buffer);\n#endif\n#else /* !HAVE_QT && !__WINRT__ */\n#if TARGET_OS_IPHONE\n#if TARGET_IPHONE_SIMULATOR\n   vprintf(fmt, ap);\n#elif __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_10_0 || __TV_OS_VERSION_MIN_REQUIRED > __TVOS_10_0\n   int sz = vsnprintf(NULL, 0, fmt, ap) + 1;\n   char buffer[sz]; /* TODO/FIXME - VLA - C89 backwards compatibility */\n   vsnprintf(buffer, sz, fmt, ap);\n   os_log(OS_LOG_DEFAULT, \"%s %s\", tag_v, buffer);\n#else\n   static aslclient asl_client;\n   static int asl_initialized = 0;\n   if (!asl_initialized)\n   {\n      asl_client      = asl_open(\n                                 FILE_PATH_PROGRAM_NAME,\n                                 \"com.apple.console\",\n                                 ASL_OPT_STDERR | ASL_OPT_NO_DELAY);\n      asl_initialized = 1;\n   }\n   aslmsg msg = asl_new(ASL_TYPE_MSG);\n   asl_set(msg, ASL_KEY_READ_UID, \"-1\");\n   if (tag)\n      asl_log(asl_client, msg, ASL_LEVEL_NOTICE, \"%s\", tag);\n   asl_vlog(asl_client, msg, ASL_LEVEL_NOTICE, fmt, ap);\n   asl_free(msg);\n#endif\n#endif\n#if defined(HAVE_LIBNX)\n   mutexLock(&g_verbosity->mtx);\n#endif\n   if (fp)\n   {\n      fprintf(fp, \"%s \", tag_v);\n      vfprintf(fp, fmt, ap);\n      fflush(fp);\n   }\n#if defined(HAVE_LIBNX)\n   mutexUnlock(&g_verbosity->mtx);\n#endif\n\n#endif\n#endif\n}\n\nvoid RARCH_LOG_BUFFER(uint8_t *data, size_t size)\n{\n   unsigned i, offset;\n   int padding     = size % 16;\n   uint8_t buf[16] = {0};\n\n   RARCH_LOG(\"== %d-byte buffer ==================\\n\", (int)size);\n\n   for (i = 0, offset = 0; i < size; i++)\n   {\n      buf[offset] = data[i];\n      offset++;\n\n      if (offset == 16)\n      {\n         offset = 0;\n         RARCH_LOG(\"%02x%02x%02x%02x%02x%02x%02x%02x  %02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n            buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7],\n            buf[8], buf[9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]);\n      }\n   }\n\n   if (padding)\n   {\n      for (i = padding; i < 16; i++)\n         buf[i] = 0xff;\n      RARCH_LOG(\"%02x%02x%02x%02x%02x%02x%02x%02x  %02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n         buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7],\n         buf[8], buf[9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]);\n   }\n   RARCH_LOG(\"==================================\\n\");\n}\n\nvoid RARCH_DBG(const char *fmt, ...)\n{\n   va_list ap;\n   verbosity_state_t *g_verbosity = &main_verbosity_st;\n#ifndef _DEBUG\n   if (!g_verbosity->verbosity)\n      return;\n   if (verbosity_log_level > 0)\n      return;\n#endif\n\n   va_start(ap, fmt);\n   RARCH_LOG_V(FILE_PATH_LOG_DBG, fmt, ap);\n   va_end(ap);\n}\n\nvoid RARCH_LOG(const char *fmt, ...)\n{\n   va_list ap;\n   verbosity_state_t *g_verbosity = &main_verbosity_st;\n\n#ifndef _DEBUG\n   if (!g_verbosity->verbosity)\n      return;\n   if (verbosity_log_level > 1)\n      return;\n#endif\n\n   va_start(ap, fmt);\n   RARCH_LOG_V(FILE_PATH_LOG_INFO, fmt, ap);\n   va_end(ap);\n}\n\nvoid RARCH_LOG_OUTPUT(const char *msg, ...)\n{\n   va_list ap;\n   va_start(ap, msg);\n   RARCH_LOG_OUTPUT_V(FILE_PATH_LOG_INFO, msg, ap);\n   va_end(ap);\n}\n\nvoid RARCH_WARN(const char *fmt, ...)\n{\n   va_list ap;\n   verbosity_state_t *g_verbosity = &main_verbosity_st;\n\n#ifndef _DEBUG\n   if (!g_verbosity->verbosity)\n      return;\n   if (verbosity_log_level > 2)\n      return;\n#endif\n\n   va_start(ap, fmt);\n   RARCH_WARN_V(FILE_PATH_LOG_WARN, fmt, ap);\n   va_end(ap);\n}\n\nvoid RARCH_ERR(const char *fmt, ...)\n{\n   va_list ap;\n   verbosity_state_t *g_verbosity = &main_verbosity_st;\n\n#ifndef _DEBUG\n   if (!g_verbosity->verbosity)\n      return;\n#endif\n\n   va_start(ap, fmt);\n   RARCH_ERR_V(FILE_PATH_LOG_ERROR, fmt, ap);\n   va_end(ap);\n}\n#endif\n\nvoid rarch_log_file_set_override(const char *path)\n{\n   verbosity_state_t *g_verbosity = &main_verbosity_st;\n\n   g_verbosity->override_active   = true;\n   strlcpy(g_verbosity->override_path, path,\n         sizeof(g_verbosity->override_path));\n}\n\nvoid rarch_log_file_init(\n      bool log_to_file,\n      bool log_to_file_timestamp,\n      const char *log_dir\n      )\n{\n   char log_directory[DIR_MAX_LENGTH];\n   char log_file_path[PATH_MAX_LENGTH];\n   verbosity_state_t *g_verbosity            = &main_verbosity_st;\n   static bool log_file_created              = false;\n   static char timestamped_log_file_name[64] = {0};\n   bool logging_to_file                      = g_verbosity->initialized;\n\n   /* If this is the first run, generate a timestamped log\n    * file name (do this even when not outputting timestamped\n    * log files, since user may decide to switch at any moment...) */\n   if (string_is_empty(timestamped_log_file_name))\n   {\n      struct tm tm_;\n      time_t cur_time = time(NULL);\n\n      rtime_localtime(&cur_time, &tm_);\n      strftime(timestamped_log_file_name, sizeof(timestamped_log_file_name), \"retroarch__%Y_%m_%d__%H_%M_%S.log\", &tm_);\n   }\n\n   /* If nothing has changed, do nothing */\n   if (  (!log_to_file && !logging_to_file)\n       || (log_to_file &&  logging_to_file))\n      return;\n\n   /* If we are currently logging to file and wish to stop,\n    * de-initialise existing logger... */\n   if (!log_to_file && logging_to_file)\n   {\n      retro_main_log_file_deinit();\n      /* ...and revert to console */\n      retro_main_log_file_init(NULL, false);\n      return;\n   }\n\n   /* If we reach this point, then we are not currently\n    * logging to file, and wish to do so */\n\n   /* > Check whether we are already logging to console */\n   /* De-initialise existing logger */\n   if (g_verbosity->fp)\n      retro_main_log_file_deinit();\n\n   /* > Get directory/file paths */\n   if (g_verbosity->override_active)\n   {\n      /* Get log directory */\n      const char *override_path        = g_verbosity->override_path;\n      const char *slash                = strrchr(override_path, '/');\n      const char *backslash            = strrchr(override_path, '\\\\');\n      const char *last_slash           = (!slash || (backslash > slash)) ? (char*)backslash : (char*)slash;\n\n      if (last_slash)\n      {\n         char tmp_buf[PATH_MAX_LENGTH] = {0};\n         size_t path_length            = last_slash + 1 - override_path;\n\n         if ((path_length > 1) && (path_length < PATH_MAX_LENGTH))\n            strlcpy(tmp_buf, override_path, path_length * sizeof(char));\n         strlcpy(log_directory, tmp_buf, sizeof(log_directory));\n      }\n\n      /* Get log file path */\n      strlcpy(log_file_path, override_path, sizeof(log_file_path));\n   }\n   else if (!string_is_empty(log_dir))\n   {\n      /* Get log directory */\n      strlcpy(log_directory, log_dir, sizeof(log_directory));\n\n      /* Get log file path */\n      fill_pathname_join_special(log_file_path,\n            log_dir,\n            log_to_file_timestamp\n            ? timestamped_log_file_name\n            : \"retroarch.log\",\n            sizeof(log_file_path));\n   }\n   else\n\t   log_file_path[0] = '\\0';\n\n   /* > Attempt to initialise log file */\n   if (!string_is_empty(log_file_path))\n   {\n      /* Create log directory, if required */\n      if (     !string_is_empty(log_directory)\n            && !path_is_directory(log_directory)\n            && !path_mkdir(log_directory))\n      {\n         /* Re-enable console logging and output error message */\n         retro_main_log_file_init(NULL, false);\n         RARCH_ERR(\"Failed to create system event log directory: %s\\n\", log_directory);\n         return;\n      }\n\n      /* When RetroArch is launched, log file is overwritten.\n       * On subsequent calls within the same session, it is appended to. */\n      retro_main_log_file_init(log_file_path, log_file_created);\n      if (g_verbosity->initialized)\n         log_file_created = true;\n      return;\n   }\n\n   /* If we reach this point, then something went wrong...\n    * Just fall back to console logging */\n   retro_main_log_file_init(NULL, false);\n   RARCH_ERR(\"Failed to initialise system event file logging...\\n\");\n}\n\nvoid rarch_log_file_deinit(void)\n{\n   verbosity_state_t *g_verbosity = &main_verbosity_st;\n\n   /* De-initialise existing logger, if currently logging to file */\n   if (g_verbosity->initialized)\n      retro_main_log_file_deinit();\n\n   /* If logging is currently disabled... */\n   if (!g_verbosity->fp) /* ...initialise logging to console */\n      retro_main_log_file_init(NULL, false);\n}\n"
        },
        {
          "name": "verbosity.h",
          "type": "blob",
          "size": 5.9755859375,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef __RARCH_VERBOSITY_H\n#define __RARCH_VERBOSITY_H\n\n#include <stdarg.h>\n#include <stdlib.h>\n\n#include <boolean.h>\n#include <retro_common_api.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef ORBIS\n#include <debugnet.h>\n#endif\n\nRETRO_BEGIN_DECLS\n\n#define FILE_PATH_LOG_DBG   \"[DEBUG]\"\n#define FILE_PATH_LOG_INFO  \"[INFO]\"\n#define FILE_PATH_LOG_ERROR \"[ERROR]\"\n#define FILE_PATH_LOG_WARN  \"[WARN]\"\n\nbool verbosity_is_enabled(void);\n\nvoid verbosity_enable(void);\n\nvoid verbosity_disable(void);\n\nvoid verbosity_set_log_level(unsigned level);\n\nbool *verbosity_get_ptr(void);\n\nvoid retro_main_log_file_deinit(void);\n\nvoid retro_main_log_file_init(const char *path, bool append);\n\nbool is_logging_to_file(void);\n\n#if defined(HAVE_LOGGER)\n\nvoid logger_init (void);\nvoid logger_shutdown (void);\nvoid logger_send (const char *__format,...);\nvoid logger_send_v(const char *__format, va_list args);\n\n#ifdef IS_SALAMANDER\n\n#ifdef ORBIS\n#define RARCH_DBG(...) do { \\\n   debugNetPrintf(DEBUGNET_DEBUG,\"\" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_LOG(...) do { \\\n   debugNetPrintf(DEBUGNET_INFO,\"\" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_LOG_V(tag, fmt, vp) do { \\\n   debugNetPrintf(DEBUGNET_DEBUG,tag,fmt,vp); \\\n} while (0)\n\n#define RARCH_ERR(...) do { \\\n   debugNetPrintf(DEBUGNET_ERROR,\"\" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_ERR_V(tag, fmt, vp) do { \\\n   debugNetPrintf(DEBUGNET_ERROR,tag,fmt,vp); \\\n} while (0)\n\n#define RARCH_WARN(...) do { \\\n   debugNetPrintf(DEBUGNET_INFO,\"\" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_WARN_V(tag, fmt, vp) do { \\\n   debugNetPrintf(DEBUGNET_DEBUG,tag,fmt,vp); \\\n} while (0)\n\n#define RARCH_LOG_OUTPUT(...) do { \\\n   debugNetPrintf(DEBUGNET_INFO,\"\" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_LOG_OUTPUT_V(tag, fmt, vp) do { \\\n   debugNetPrintf(DEBUGNET_INFO,tag,fmt,vp); \\\n} while (0)\n\n#else\n#define RARCH_DBG(...) do { \\\n   logger_send(\"RetroArch Salamander: \" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_LOG(...) do { \\\n   logger_send(\"RetroArch Salamander: \" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_LOG_V(tag, fmt, vp) do { \\\n   logger_send(\"RetroArch Salamander: \" tag); \\\n   logger_send_v(fmt, vp); \\\n} while (0)\n\n#define RARCH_LOG_OUTPUT(...) do { \\\n   logger_send(\"[OUTPUT] \" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_LOG_OUTPUT_V(tag, fmt, vp) do { \\\n   logger_send(\"[OUTPUT] \" tag); \\\n   logger_send_v(fmt, vp); \\\n} while (0)\n\n#define RARCH_ERR(...) do { \\\n   logger_send(\"[ERROR] \" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_ERR_V(tag, fmt, vp) do { \\\n   logger_send(\"[ERROR] \" tag); \\\n   logger_send_v(fmt, vp); \\\n} while (0)\n\n#define RARCH_WARN(...) do { \\\n   logger_send(\"[WARN] \" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_WARN_V(tag, fmt, vp) do { \\\n   logger_send(\"[WARN] \" tag); \\\n   logger_send_v(fmt, vp); \\\n} while (0)\n#endif\n#else /* IS_SALAMANDER */\n\n#ifdef ORBIS\n#define RARCH_DBG(...) do { \\\n   debugNetPrintf(DEBUGNET_DEBUG,\"\" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_LOG(...) do { \\\n   debugNetPrintf(DEBUGNET_INFO,\"\" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_LOG_V(tag, fmt, vp) do { \\\n   debugNetPrintf(DEBUGNET_DEBUG,tag,fmt,vp); \\\n} while (0)\n\n#define RARCH_ERR(...) do { \\\n   debugNetPrintf(DEBUGNET_ERROR,\"\" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_ERR_V(tag, fmt, vp) do { \\\n   debugNetPrintf(DEBUGNET_ERROR,tag,fmt,vp); \\\n} while (0)\n\n#define RARCH_WARN(...) do { \\\n   debugNetPrintf(DEBUGNET_INFO,\"\" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_WARN_V(tag, fmt, vp) do { \\\n   debugNetPrintf(DEBUGNET_DEBUG,tag,fmt,vp); \\\n} while (0)\n\n#define RARCH_LOG_OUTPUT(...) do { \\\n   debugNetPrintf(DEBUGNET_INFO,\"\" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_LOG_OUTPUT_V(tag, fmt, vp) do { \\\n   debugNetPrintf(DEBUGNET_INFO,tag,fmt,vp); \\\n} while (0)\n\n#else\n#define RARCH_DBG(...) do { \\\n   logger_send(\"\" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_LOG(...) do { \\\n   logger_send(\"\" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_LOG_V(tag, fmt, vp) do { \\\n   logger_send(\"\" tag); \\\n   logger_send_v(fmt, vp); \\\n} while (0)\n\n#define RARCH_ERR(...) do { \\\n   logger_send(\"[ERROR] \" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_ERR_V(tag, fmt, vp) do { \\\n   logger_send(\"[ERROR] \" tag); \\\n   logger_send_v(fmt, vp); \\\n} while (0)\n\n#define RARCH_WARN(...) do { \\\n   logger_send(\"[WARN] \" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_WARN_V(tag, fmt, vp) do { \\\n   logger_send(\"[WARN] :: \" tag); \\\n   logger_send_v(fmt, vp); \\\n} while (0)\n\n#define RARCH_LOG_OUTPUT(...) do { \\\n   logger_send(\"[OUTPUT] \" __VA_ARGS__); \\\n} while (0)\n\n#define RARCH_LOG_OUTPUT_V(tag, fmt, vp) do { \\\n   logger_send(\"[OUTPUT] \" tag); \\\n   logger_send_v(fmt, vp); \\\n} while (0)\n#endif\n#endif\n#define RARCH_LOG_BUFFER(...) do { } while (0)\n\n#else /* HAVE_LOGGER */\nvoid RARCH_LOG_V(const char *tag, const char *fmt, va_list ap);\nvoid RARCH_DBG(const char *fmt, ...);\nvoid RARCH_LOG(const char *fmt, ...);\nvoid RARCH_LOG_BUFFER(uint8_t *buffer, size_t size);\nvoid RARCH_LOG_OUTPUT(const char *msg, ...);\nvoid RARCH_WARN(const char *fmt, ...);\nvoid RARCH_ERR(const char *fmt, ...);\n\n#define RARCH_LOG_OUTPUT_V RARCH_LOG_V\n#define RARCH_WARN_V RARCH_LOG_V\n#define RARCH_ERR_V RARCH_LOG_V\n#endif /* HAVE_LOGGER */\n\nvoid rarch_log_file_init(\n      bool log_to_file,\n      bool log_to_file_timestamp,\n      const char *log_dir);\n\nvoid rarch_log_file_deinit(void);\n\nvoid rarch_log_file_set_override(const char *path);\n\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "version.all",
          "type": "blob",
          "size": 0.390625,
          "content": "# /* this file is a polyglot: it's valid C, Makefile and shell */\n# /* this reduces the number of files to update when changing the version */\n# /* files to change to update version: */\n# /* - this one, obviously */\n# /* - version.dtd */\n# /* - pkg/snap/snapcraft.yaml (including the github url) */\n\n#if 0\nRARCH_VERSION=\"1.20.0\"\n#endif\n#ifndef PACKAGE_VERSION\n#define PACKAGE_VERSION \"1.20.0\"\n#endif\n"
        },
        {
          "name": "version.dtd",
          "type": "blob",
          "size": 0.0263671875,
          "content": "<!ENTITY version \"1.20.0\">\n"
        },
        {
          "name": "version.h",
          "type": "blob",
          "size": 0.8525390625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef RARCH_VERSION_H__\n#define RARCH_VERSION_H__\n\n#include \"version.all\"\n\n#endif\n"
        },
        {
          "name": "version_git.c",
          "type": "blob",
          "size": 0.8896484375,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"version_git.h\"\n#define STR_(x) #x\n#define STR(x) STR_(x)\nconst char retroarch_git_version[] = STR(GIT_VERSION);\n"
        },
        {
          "name": "version_git.h",
          "type": "blob",
          "size": 1.0400390625,
          "content": "/*  RetroArch - A frontend for libretro.\n *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen\n *  Copyright (C) 2011-2017 - Daniel De Matteis\n *\n *  RetroArch is free software: you can redistribute it and/or modify it under the terms\n *  of the GNU General Public License as published by the Free Software Found-\n *  ation, either version 3 of the License, or (at your option) any later version.\n *\n *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n *  PURPOSE.  See the GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along with RetroArch.\n *  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef RARCH_VERSION_GIT_H__\n#define RARCH_VERSION_GIT_H__\n\n#include <retro_common_api.h>\n\nRETRO_BEGIN_DECLS\n\n/* Put this in a separate file so we don't have to rebuilt\n * retroarch.c every single build. */\nextern const char retroarch_git_version[];\n\nRETRO_END_DECLS\n\n#endif\n"
        },
        {
          "name": "vita",
          "type": "tree",
          "content": null
        },
        {
          "name": "webos",
          "type": "tree",
          "content": null
        },
        {
          "name": "wii",
          "type": "tree",
          "content": null
        },
        {
          "name": "wiiu-devel.properties.template",
          "type": "blob",
          "size": 0.1953125,
          "content": "#\n# To use this file:\n# 1. Copy this file to wiiu-devel.properties\n# 2. Fill in the variables below with your IP address and desired\n#    port number.\n#\n\nPC_DEVELOPMENT_TCP_PORT=4405\nWIIU_IP_ADDRESS=\n"
        },
        {
          "name": "wiiu",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}